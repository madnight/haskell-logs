00:12:53 <ivanm> !paste
00:12:53 <hpaste> Haskell paste bin: http://hpaste.org/
00:20:29 <hpaste>  Bas van Dijk annotated "Weaving fun" with "(no title)" at http://hpaste.org/1338#a3
00:25:41 <hpaste>  ivanm pasted "Values from an array" at http://hpaste.org/1351
00:34:56 <Cale> ivanm: hmm
00:35:11 <ivanm> that's the problem I was talking about earlier
00:35:12 <Cale> ivanm: So you're partitioning the entries of the matrix based on those two conditions?
00:35:28 <ivanm> *nod*... if I understand what you're asking
00:35:49 <Cale> I'd say flatten the matrix into a list using assocs and then use Data.List.partition
00:35:49 <ivanm> I'll probably doing something similar with other conditions later on
00:36:08 * ivanm is re-writing a library he did bit by bit using arrays intead of lists of lists
00:36:38 <Cale> If you're going to go over a whole bunch of things linearly anyway, there's little point in using anything other than a list.
00:36:49 <Cale> (Lists are essentially loops)
00:37:27 <Cale> Now, there might be a point to not using a list when you need to do lots of lookups, but here, there's not a whole lot of random access, is there?
00:39:16 <dcoutts> lists are an excellent control structure
00:39:28 <dcoutts> and not too bad as a data structure either
00:40:29 <norpan> just ask any lisper
00:40:47 <ddarius> Lazy lists are better than strict ones.
00:42:07 <Cale> so... perhaps something like getSingles = partition (liftM2 (&&) single ((/= 0) . head) . snd) . assocs -- though perhaps that's a little overly points-free :)
00:42:07 <ivanm> *shrug* I want to convert my code to using arrays, because the lists weren't working nicely previously
00:42:21 <ivanm> no, I don't mind points-free...
00:42:39 <ivanm> but I was hoping to get the ones by rows and by columns in one pass
00:42:58 <Cale> Check and see if that's close to what you want.
00:43:01 <ivanm> because afterwards, I'm going to go through the list again, and remove elements from the association list depending on the rows and columns
00:44:33 <ivanm> Cale: nope... I get ([((2,1),[1]),((2,2),[2])],[((1,1),[1,2]),((1,2),[0])])
00:44:43 <ivanm> anyway, I have to go up to the shops to get stuff for dinner
00:44:55 <ivanm> if you guys think of anything, can you just annotate that hpaste please?
00:44:56 <ivanm> thanks
00:46:35 <Cale> Well, that gives you row/column numbers together with the entry
00:47:06 <Cale> Maybe I'm completely misunderstanding what your code is supposed to do...
00:48:42 <Cale> Is it essential that the 0 entry is deleted?
00:49:57 <Cale> oh, I see
00:50:28 <Cale> You're right, that's not what you want :)
00:50:53 <Cale> Not all the way there anyway.
01:00:34 <hpaste>  TSC pasted ""Hangs" on Windows" at http://hpaste.org/1352
01:00:58 <TSC> Do any Windowsy thready experts know why that code hangs?
01:02:25 <ejt> TSC: where does it hang ? does "..." or "done" appear ?
01:02:30 <sjanssen> it doesn't hang on some other platform?
01:02:38 <TSC> Let me explain (:
01:03:08 <TSC> If you don't type anything, I would expect that the spawned thread would be killed, and the program exits
01:03:15 <TSC> (after 1 second)
01:03:19 <Lemmih> 'getLine' probably performs a blocking foreign call.
01:03:26 <TSC> Yeah, that's what I thought
01:03:39 <TSC> But it behaves correctly in Linux
01:03:53 <TSC> In Windows, you have to type something (to end the getLine call) before the process ends
01:04:39 <Lemmih> The IO manager on Windows is somewhat limited.
01:04:58 <TSC> Is there any way to kill the thread even if it's blocking?
01:05:32 <Lemmih> Try using OS threads.
01:05:47 <TSC> Just change forkIO to forkOS?
01:06:34 <sjanssen> IO uses blocking foreign calls in Windows?
01:07:20 <sjanssen> that seems like a really big problem...
01:09:09 <TSC> OS threads didn't seem to help
01:09:35 <Lemmih> TSC: OS threads + -threaded perhaps?
01:09:49 <TSC> Yes, I had to enable -threaded to make it run
01:10:07 <TSC> killThread didn't return at all on Windows then
01:10:14 <Lemmih> @seen JaffaCake
01:10:14 <lambdabot> JaffaCake is in #haskell-soc, #haskell and #ghc. I last heard JaffaCake speak 18h 13m 59s ago.
01:10:27 <JaffaCake> Lemmih: ?
01:12:36 <codeshepher1> is haskell anyway related to AOP?
01:13:25 <codeshepherd> is there a comparision between haskell and AOP features ?
01:14:01 <Lemmih> JaffaCake: I seem to recall that you've discussed the I/O manager thread in length with Bulat. If you have time then I'm sure you'd be the best person to explain why TSC's code hangs and how to work around it.
01:14:43 <TSC> I think I can work around it by being careful not to enter the blocking call unless it will return
01:14:46 <JaffaCake> can you summarise the problem?
01:14:47 <flux> codeshepherd, apparently there exists an aop-variety of haskell, which you must've found also with google
01:15:16 <flux> but as answers to those questions: no, no
01:15:23 <codeshepherd> flux:  sorry i did not do my homework :(
01:15:24 <TSC> JaffaCake: If a thread is in a blocking call (e.g. getLine), it won't die until the call returns
01:15:46 <JaffaCake> right, this is a bug on Windows currently
01:15:54 <TSC> Ah, thanks
01:16:02 <JaffaCake> we implement blocking I/O via foreign calls, which can't be killed
01:16:12 <JaffaCake> you might find it works without -threaded
01:16:16 <boegel> dons: ping
01:16:20 <boegel> @localtime dons
01:16:22 <lambdabot> Local time for dons is Thu Apr 12 18:15:35 2007
01:16:35 <TSC> I was using it without threaded anyway
01:16:41 <JaffaCake> oh... hmm
01:16:47 <TSC> But thanks; if I know it's not my fault, I can work around it
01:16:59 <JaffaCake> then I think it might be a different problem
01:17:11 <JaffaCake> are you in GHCi?
01:17:26 <TSC> No, I compiled and ran it
01:18:49 <JaffaCake> I'll take a look
01:19:40 <TSC> http://hpaste.org/1352 is my example
01:39:34 <kzm> @quote Andrew_Morton
01:39:35 <lambdabot> Andrew_Morton says: I find that the key to understanding kernel code is to understand the data structures and the relationships between them. Once you have that in your head, the code tends to just
01:39:35 <lambdabot> fall out.
01:40:06 <kzm> (fits nicely with algebraic data structures and strong typing, IMHO)
01:40:53 <kzm> Anyway: GHC's Random module seems to give the same newStdGen when run in sufficiently quick succession?
01:41:03 <Syzygy-> @tell Igloo had to stop the buildbot run temporarily - file system reorganisation and building made the system balk. Restarting in a day or two - tops.
01:41:04 <lambdabot> Consider it noted.
01:41:09 <kzm> Does that count as a bug?
01:42:55 <ejt> kzm: I think so
01:43:15 <kzm> @seen JaffaCake
01:43:16 <lambdabot> JaffaCake is in #haskell-soc, #haskell and #ghc. I last heard JaffaCake speak 24m 26s ago.
01:43:27 <JaffaCake> kzm: ?
01:43:53 <kzm> Should I file the fact that newStdGen gives the same result on successive invocations as a bug?
01:44:28 <JaffaCake> I'm not sure, but I suspect it might be the right behaviour
01:44:48 <kzm> Within a program, it's no big deal (since I only use it once, and then split it), but on successive program invocations, I'd like different random results.
01:45:19 <JaffaCake> hmm, no it looks like it's supposed to give a new seed
01:46:11 <kzm> I think it would be most useful if it did.  I guess it's based on current time?  In seconds, maybe?
01:46:16 <JaffaCake> are you in GHCi?
01:47:40 <JaffaCake> it's based on the time in seconds plus CPU time in some smaller unit, I'm not sure exactly
01:47:59 <JaffaCake> if you're in GHCi, then I'd exepect to get the same result each time because the StdGen is a CAF
01:48:12 <josephholsten> CAF?
01:48:31 <sjanssen> josephholsten: constant applicative form -- basically means a constant
01:48:32 <kzm> Both GHCi and with a compiled program, I think.  Certainly the latter.
01:48:32 <JaffaCake> top-level binding with no args, CAF = "constant applicative form"
01:49:07 <JaffaCake> it's probably the second resolution that's hurting then
01:49:19 <JaffaCake> try making your own seed
01:49:26 <JaffaCake> and file a bug :)
01:49:53 <josephholsten> ah the joys of newbieism
01:50:10 <kzm> Hm, can't reproduce it in ghci here (and my program is at my - ahem - other job, where they block IRC)
01:50:31 <kzm> ghci produces different results each time - nice.
01:51:12 <kzm> The version is different though - this is 6.7 something, the other one is 6.6 from standard Ubuntu.
01:51:35 <sjanssen> @type fmap (sum . map fromEnum . take 1000) (readFile "/dev/urandom") -- a stupid seed generator
01:51:38 <lambdabot> IO Int
01:52:10 <josephholsten> oh, is the code for lamdabot available somewhere?
01:52:20 <sjanssen> @where lambdabot
01:52:21 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:52:30 <ski> @version
01:52:31 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
01:52:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:52:54 <josephholsten> argh, darcs again! foiled
01:53:24 <josephholsten> I've been compiling ghc for two days. I need to pay my electricity bill
01:53:42 <kzm> JaffaCake, it only happens with a compiled program, and newStdGen gives the same result when called within the same second.
01:54:05 <JaffaCake> josephholsten: sorry about that :)
01:54:11 <kzm> (Tested with "date; ./random", where random is just "main = newStdGen >>= print")
01:54:42 <JaffaCake> kzm: right, we should at least be using a better clock, and preferably seeding from /dev/random or something
01:55:15 <earthy> josephholsten: most darcs sources can also be downloaded using wget or curl
01:55:37 <earthy> it's just a directory made available over http after all
01:55:41 <josephholsten> earthy: interesting
01:55:55 <earthy> s/sources/repos/
01:59:12 <josephholsten> well, i get a bunch of index.html's but I should manage
01:59:43 <hpaste>  Cale annotated "Values from an array" with "I'm not certain whether this is clearer, but have a look." at http://hpaste.org/1351#a1
02:00:26 <Cale> (that's for ivanm)
02:02:52 <josephholsten> oh, hey. sjanssen
02:03:11 <josephholsten> I've been compiling ghc for two days to get xmonad
02:03:42 <josephholsten> i hope it's worth it
02:04:00 <Cale> josephholsten: why are you compiling ghc?
02:04:20 <Cale> Are you on a platform for which there is no binary?
02:04:26 <josephholsten> to build darcs
02:04:36 <josephholsten> meh
02:04:37 <Cale> What sort of machine are you using?
02:04:54 <Cale> You should never compile ghc without a really good reason to do so.
02:05:11 <josephholsten> janice% uname -a
02:05:11 <josephholsten> Darwin janice.local 8.8.0 Darwin Kernel Version 8.8.0: Fri Sep  8 17:18:57 PDT 2006; root:xnu-792.12.6.obj~1/RELEASE_PPC Power Macintosh powerpc
02:05:24 <Cale> Yeah, there's likely a binary for you.
02:05:27 <josephholsten> i see.
02:05:37 <sjanssen> josephholsten: yikes, I hope I don't disappoint
02:05:57 <sjanssen> there almost certainly is a binary for you -- how else could you build ghc?
02:06:07 <Cale> indeed :)
02:06:09 <josephholsten> well it's only ~400 lines. I have low standards
02:06:35 <josephholsten> ooh. good point. hugs?
02:06:40 <Cale> Unless you're bootstrapping.
02:06:53 <josephholsten> macports
02:06:56 <earthy> uhm, hugs won't help compiling ghc
02:06:56 <sjanssen> josephholsten: only ghc can build ghc
02:07:01 <josephholsten> who really knows
02:07:07 <earthy> nor will jhc, yhc, nhc or ehc
02:07:16 <Cale> So you must already have a working ghc binary
02:07:21 <sjanssen> macports downloads a binary version initially
02:07:43 <Cale> That's silly. Why doesn't it just install the binary that it downloads?
02:08:05 <sjanssen> I don't remember exactly what it does
02:08:37 <josephholsten> really? because sudo port install [whatever] has always compiled everything
02:08:40 <Cale> Are you running OS X or just Darwin?
02:08:47 <josephholsten> osX
02:09:09 <Cale> 10.4?
02:09:11 <earthy> heck, our entire group's OS X users use ghc binaries
02:09:30 <josephholsten> well, I'll leave that process going. or, maybe I should restart it and time it
02:09:31 <Cale> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-ppc-apple-darwin.tar.gz
02:09:32 <earthy> that's like 6 people
02:09:34 <lambdabot> http://tinyurl.com/2go7pa
02:09:38 <earthy> on both PPC and Intel
02:09:59 <josephholsten> well thanks
02:10:35 <Cale> As you can see, compiling GHC takes a really long time unless you have a ridiculously fast machine. :)
02:10:55 <josephholsten> i should also mention I'm outside, plugged into my neighbor's outside power outlet, useing his internet, at 4AM, freezing
02:11:00 <Cale> dons can compile it in 9 minutes on his 8-core machine.
02:11:01 <sjanssen> shouldn't take two days, I think
02:11:34 <josephholsten> I'm sort of a masochist, which is why I wonder why I'm trying to learn haskell instead of cobol
02:12:12 <josephholsten> ah, i mentioned I have no power.
02:12:24 <josephholsten> two days is my time, not compute time
02:13:51 <kzm> JaffaCake: Submitted http://hackage.haskell.org/trac/ghc/ticket/1272
02:13:52 <lambdabot> Title: #1272 (newStdGen returns the same value on successive calls) - GHC - Trac
02:14:05 <JaffaCake> cheers
02:14:17 <kzm> Must run, dentist appointment.
02:15:56 <josephholsten> is there a respective alternative to object prevalance in FP/haskell?
02:17:37 <josephholsten> a better alternative to using a rdbms?
02:18:51 <Saizan> "object prevalance"?
02:24:14 <Cale> hmm... http://en.wikipedia.org/wiki/Object_prevalence
02:24:15 <lambdabot> Title: Object Prevalence - Wikipedia, the free encyclopedia
02:25:50 <Cale> I'd never heard of the term before either.
02:27:13 <Saizan> these seems a lot like what HAppS does
02:27:27 <Cale> yeah.
02:27:37 <Cale> I have no idea why they chose the term "prevalence"
02:28:15 <Cale> Initially, I'd think that the term meant the widespread use of objects.
02:28:54 <Vq^> reminds me of Zope or divmod axiom
02:29:17 <osfameron> a little of memcached too
02:29:18 <Vq^> never heard that term thought
02:31:10 <Saizan> it's not clear if the snapshots are only for backup or you can "easily" request a previous version
02:32:05 <osfameron> that's now sounding like xanadu!
02:32:16 <osfameron> not that xanadu was ever going to be in-memory...
02:33:33 <Vq^> "Today, data persistence for object-oriented systems is an incredibly cumbersome task to deal with when building many kinds of applications. The developer must map objects to database tables, XML files or use some other non-OO way to represent data, destroying encapsulation completely. One solution to this problem is object prevalence."
02:33:51 <ivanm> Cale: thanks for that code, but it seems to freeze ghci :s
02:34:02 <Cale> Uh, that's odd
02:34:03 <DRMacIver> They're not joking about the cumbersome nature of it. :-/
02:34:15 * DRMacIver glares at Hibernate
02:34:36 <Cale> ivanm: It works for me.
02:34:48 <Cale> ivanm: Perhaps I should repaste what I have in my file?
02:34:49 <Vq^> seems like it's another word for persistence in environments where persistence systems is awkward
02:34:52 <Saizan> but java has Serializable, no?
02:35:41 <Vq^> Saizan: i believe it has
02:36:02 <hpaste>  Cale annotated "Values from an array" with "file." at http://hpaste.org/1351#a2
02:36:09 <DRMacIver> Saizan: Yes, although it's not good for long term storage.
02:36:14 <ivanm> Cale: yeah, if you could...
02:36:37 <Vq^> DRMacIver: what about Zope then?
02:36:57 <DRMacIver> Don't know. Not used it.
02:37:02 <ivanm> Cale: don't worry about it...
02:37:03 <Saizan> DRMacIver, for when you change someting in the class and deserialized objects start emitting NullPointers?
02:37:03 <DRMacIver> I'm not fond of Python.
02:37:06 <ivanm> I made a mistake copying it
02:37:10 <Cale> ah, okay
02:37:37 <Vq^> DRMacIver: ok
02:37:44 <DRMacIver> Saizan: Hm. I thought it flat out refused to deserialise from an old version of the class.
02:38:12 <Saizan> DRMacIver, well, only if you change the version number :)
02:38:18 <DRMacIver> Oh, heh.
02:38:58 <Saizan> anyway, why is it not good for long term storage in your opinion?
02:39:50 <DRMacIver> Mainly because it's finicky about changes to VMs and class files.
02:39:59 <DRMacIver> But also because that's not really its intended usage. :)
02:40:43 <DRMacIver> I'm not saying "Don't ever use it for long term storage. You're evil and vile if you do". It just wouldn't be my preferred choice.
02:40:51 <Saizan> ok
02:41:01 <DRMacIver> XML serialisation is probably a better (and just as easy) choice, even though I don't like XML much
02:42:22 <Saizan> i've written a derivation for my ToXmlTree class recently :)
02:43:22 <Vq^> RDBM is another way to go
02:43:48 <Saizan> it works well for records and non-recursive types, for Set Map etc.. i think the best solution is to convert to a list
02:44:28 <DRMacIver> Vq^: ORM is really bloody awkward though. :)
02:44:29 <Vq^> http://divmod.org/trac/wiki/DivmodAxiom <- does a pretty nice job mapping objects to rows in a relational database
02:44:31 <lambdabot> Title: DivmodAxiom - Divmod - Trac
02:47:59 <Vq^> DRMacIver: it's in the nature of ORM :P
02:50:25 <DRMacIver> Well, yes.
02:50:43 <Saizan> mmh HAppS has an experimental Data.Set-based DBMS module..
02:50:45 <DRMacIver> It's inherently really bloody awkward. :) That doesn't make it any better.
03:16:02 <Cheery> now I'd need just to write the class Code a where generate :: a -> String
03:16:24 <Cheery> anybody like to see the interface for writing those stylesheets?
03:29:19 <shapr> yow!
03:29:22 <tsp> saluton!
03:30:02 <shapr> Wassup?
03:30:37 <ivanm> clouds?
03:31:57 <shapr> ceilings?
03:32:17 <opqdonut> fives?
03:32:38 <dcoutts> hmm, cabal should really demand that package authors say which pre-processors/tools are required so that users can get told *all* the missing libs and tools, not just the first one.
03:32:59 <dcoutts> and so it can fail during configure, not during build when it finds that the tool is needed but missing
03:39:49 <eumenides> if I have data Blah = Blah { blah :: Int, ... }, why can't I write a function to update an arbitrary member of Blah? i.e. change st f n = st { f = n } ? it says f is not in scope
03:42:44 <ibid> because in haskell labels are not first-class values
03:43:15 <ibid> or, should i say, symbols :)
03:47:44 <opqdonut> mmh symbols as first-class values
03:47:46 <opqdonut> sounds like listp
03:47:48 <opqdonut> -t
03:49:20 <DRMacIver> Hm. Well there's always Liskell. :)
03:51:06 <shapr> hej bringert
03:51:16 <Vq^> hej formarn
03:51:32 <shapr> hej Vq^
03:52:24 <Vq^> shapr: still in .se?
03:52:28 <shapr> yup
03:52:44 <Vq^> nice :)
03:52:45 <shapr> five more days
03:53:12 <shapr> What about you? Still in .se?
03:53:33 <Vq^> yeah, i haven't moved an inch :)
03:54:02 <Vq^> whatever an inch is...
03:55:09 <SamB_XP_> @go an inch in centimeters
03:55:10 <lambdabot> 1 inch = 2.54 centimeters
03:55:23 <SamB_XP_> that is what I thought ;-)
03:56:01 <shapr> I finished reading Hamming's Art of Doing Science and Engineering
03:57:26 * SamB_XP_ concludes from this that shapr probably started reading said book at some point
03:57:59 <shapr> He asked scientists what the important questions were in their field, and why they weren't working on those problems.
03:58:18 <ivanm> money?
03:58:44 <ivanm> physics: unifying quantum with relativity... problem is, where do you start?
03:58:59 <shapr> Do you think that appplies to SoC? Is SoC about science or engineering? Thinking up new solutions, or implementing known solutions?
03:59:22 <shapr> ivanm: Hamming talks about that
03:59:27 * SamB_XP_ doesn't know
03:59:42 <ivanm> shapr: fair enough...
03:59:44 * SamB_XP_ has not been accepted ;-P (only applied once though)
03:59:58 <ivanm> but I really get annoyed when people talking about "engineers" coding something
04:00:01 <Svrog> soc?
04:00:15 <SamB_XP_> Svrog: Summer of Code!
04:00:19 <Svrog> oh
04:00:20 <ivanm> like google always talks about engineers... when its not just engineers that code
04:00:35 <ivanm> and not all engineers code
04:01:04 <shapr> ivanm: He says that some questions are important because the approach to them will have to be new, not so much that the answer is important
04:01:13 <ivanm> *nod*
04:01:28 <ivanm> but I'd like to think that tying together quantum with rel would be important
04:01:33 <DRMacIver> A lot of the summer of code projects just seem like SMOPs to me.
04:01:34 <SamB_XP_> heh
04:01:41 <DRMacIver> Potentially rather hard ones, but not really groundbreaking. :)
04:01:57 <ivanm> DRMacIver: SMOP?
04:02:00 <shapr> DRMacIver: Yeah, but is that the point of SoC or not?
04:02:04 <DRMacIver> Simple Matter of Programming
04:02:09 <ivanm> *nod*
04:02:25 <ivanm> I agree with shapr... the whole point of SoC is to let students code something
04:02:28 <DRMacIver> Yeah
04:02:30 <ivanm> in the RW
04:02:32 <DRMacIver> I'm not saying this is a problem.
04:03:33 <SamB_XP_> maybe google only hires engineer-class programmers?
04:04:00 <DRMacIver> Is engineer-class supposed to be a compliment or a pejorative? ;)
04:04:13 <ivanm> lol
04:04:41 <SamB_XP_> I mean, people who deserve the title of "software engineer"
04:05:00 <dcoutts> ye gads, don't let engineers code! have you ever seen the stuff? ugg
04:05:09 <ivanm> but you've also got people who studied IT, CS, etc
04:05:15 <ivanm> dcoutts: lol
04:05:20 <DRMacIver> I alternate between describing myself as a software engineer or a software developer depending on my mood at the time. :)
04:05:46 <SamB_XP_> I don't mean just ordinary engineers plunked in front of a computer!
04:05:48 * dcoutts studied computation
04:05:53 <ivanm> Cale: I'm having trouble understanding bits of that code you gave me.. for example, the collectBy function
04:06:11 * earthy studied informatics
04:06:19 <SamB_XP_> I mean people able to engineer software ;-)
04:06:22 * DRMacIver did mathematics
04:06:38 <dcoutts> earthy: but the year I left they changed the course name to 'computer science' :-)
04:06:42 * ivanm is doing IT + Maths + physics
04:06:49 <dcoutts> they were the last hold-outs
04:06:50 <ivanm> I thought IT meant CS when I started :(
04:06:55 <DRMacIver> Hardly ever did any programming in anger until I started this job, got stuck in front of a computer and told "Congratulations, you're a Java developer now." :)
04:06:56 <dcoutts> ivanm: heh heh
04:07:03 <SamB_XP_> dcoutts: isn't computation what computer scientists are supposed to study anyway?
04:07:23 <ivanm> dcoutts: yeah, I only worked it out this year when talking to all of you on IRC
04:07:29 <earthy> DRMacIver: ah! the type of person that would be perfect for the course I'll be giving as of may. :)
04:07:38 <ivanm> see? who said #haskell was useless? :p
04:07:41 <earthy> SamB: not really, no. ;)
04:07:45 <dcoutts> SamB_XP_: right, except there is no science in computation and there are not necessarily any computers
04:07:58 <DRMacIver> earthy: Hm?
04:08:03 <SamB_XP_> dcoutts: that sounds almost exactly like computer science!
04:08:30 <SamB_XP_> except ocassionally a computer scientist will try to model actual phenomina
04:08:30 <earthy> DRMacIver: I'll be teaching the first half of an 18 month course program towards a java certification
04:08:40 <shapr> Hamming says that science is what you're doing when you don't know what you're doing, and engineering is what you're doing when you do know what you're doing.
04:08:44 <earthy> DRMacIver: in Dutch, so it may not be of use to you. :)
04:08:47 <SamB_XP_> found in actual computers
04:08:53 <DRMacIver> earthy: Ew, no thanks.
04:09:05 <dcoutts> SamB_XP_: the original reasoning for not calling it computer science is that there are no experiments
04:09:28 <ivanm> sure there are... "how can we blow up the computer room today?" ;-)
04:09:31 <DRMacIver> earthy: I've no desire to become java certified, and probably know enough about Java by now that I'd find it amazingly tedious. :)
04:09:36 <earthy> ;)
04:09:37 <SamB_XP_> dcoutts: there aren't?
04:09:46 <earthy> this is not the Sun certification, and yes. ;)
04:09:55 <SamB_XP_> what do you call all that benchmarking?
04:09:58 <dcoutts> SamB_XP_: at my university computing is treated as a branch of mathematics rather than as a branch of engineering
04:10:10 <ivanm> can't remember where it was, but I read an article about a physicist who learnt lisp only because the CS building burnt down or something, so the CS honours students shared rooms with the physics honours students
04:10:18 <SamB_XP_> dcoutts: as it should be
04:10:19 <dcoutts> SamB_XP_: we don't benchmark we prove asymptotic bounds :-)
04:10:32 <ivanm> CS is a sub-discipline at my uni :(
04:10:35 <dcoutts> or count comparisons
04:10:37 <Cheer1> is it possible to express every mathematical operating with commutative operators?
04:10:40 <earthy> ivanm: that sucks
04:10:42 <ivanm> you can do it in science, or in IT
04:10:45 <Cheer1> *operation
04:10:45 <ivanm> earthy: I agree
04:11:05 <earthy> and IT is what? business-oriented information technology?
04:11:06 * ivanm had great hopes when he saw a dual CS/Maths honours mentioned on the science honours page
04:11:15 <ivanm> but now their telling me that it was a mistake :(
04:11:22 <QtPlatypus> Cheer1: I don't beleave so Cheer.
04:11:24 <ivanm> earthy: *nod*
04:11:28 <earthy> ah the great fallacy of believing university marketing
04:11:34 <earthy> ivanm: learn that stuff. It'll come in useful
04:11:35 <ivanm> lol
04:11:43 <shapr> Time and effort estimates are engineering, which can't be done if this particular program hasn't been written by these particular programmer.
04:11:44 <ivanm> what? business stuff?
04:11:47 <Cheer1> QtPlatypus: why so?
04:11:48 * earthy nods
04:12:17 <earthy> but there's a whole area of math-like cs that you'll probably have to learn on your own
04:12:17 <ivanm> earthy: yeah, unfortunately :(... currently doing a year long IT project, which includes all the business case, proposal, etc stuff
04:12:30 <ivanm> yeah... like lambda calculus, and haskell! :D
04:12:44 <QtPlatypus> Cheer1: Because there are so meany mathimatical operators that seem to me to be noncommutative.
04:12:48 <ivanm> the only real CS course I've done was algorithms and data structures... in Java :s
04:12:56 <earthy> proof theory, type theory, proofs-as-propositions, complexity theory, algorithmics
04:13:05 <ivanm> well, there was the UML and patterns in OOP subject, but I hated that
04:13:06 <DRMacIver> I've been working on brushing up on those areas myself.
04:13:18 <ivanm> earthy: any recommended references to look at?
04:13:20 <QtPlatypus> Though its just a guess, I don't know for certon.
04:13:22 <earthy> pfew
04:13:23 <ToRA> ivanm: shoulda come to my university - first year, first language taught was haskell, second year had lambda calculus
04:13:28 <earthy> TAPL, ofcourse.
04:13:33 <earthy> SICP
04:13:43 <DRMacIver> I really need to pick up a copy of SICP
04:13:51 <ivanm> ToRA: my year was the first one they used scheme in first year... and the last one to do introductory Java
04:13:52 <earthy> the handbook of logic in computer science
04:13:55 <DRMacIver> And finish reading TAPL. I got about 2/3 of the way through before I got distracted. :)
04:13:59 <ivanm> earthy: got SICP
04:14:02 <ivanm> not a bad book
04:14:03 <ToRA> what's SICP?
04:14:10 * earthy hasn't ever cracked open a copy of TAPL
04:14:13 <DRMacIver> Structure and Interpretation of Computer Programs
04:14:13 <ivanm> @google SICP scheme
04:14:15 <lambdabot> http://mitpress.mit.edu/sicp/
04:14:16 <lambdabot> Title: Welcome to the SICP Web Site
04:14:19 <ToRA> ahhh
04:14:19 <DRMacIver> Or something like that
04:14:21 <ivanm> its online as well
04:14:26 <earthy> oh, the dragon book
04:14:38 <shapr> earthy: TaPL is fun
04:14:42 <ToRA> isn't the dragon book kinda out of date now?
04:14:51 <ivanm> only good thing was, I managed to do the 2nd year Programming in the large course before they dumbed it down
04:14:53 <ToRA> and i'll 400th the votes for TaPL being a good book to have :)
04:14:53 <earthy> ToRA: you betcha it ain't.
04:15:05 <ivanm> earthy: the "dragon book"?
04:15:06 <bringert_> ToRA: the new edition came out just a few months ago
04:15:20 * ToRA hits amazon...
04:15:36 <bringert_> ToRA: be sure not to get the "international edition", there no dargon on it!
04:15:42 <bringert_> dragon
04:16:01 <earthy> ivanm: Compilers Principles, Techniques, and TOols by Aho, Sethi  and Ullman
04:16:10 * ToRA had too much faith in amazon to know what he really meant when he asked for "Dragon Book"
04:16:23 <ivanm> why is it called the dragon book? dragon on the front cover?
04:16:33 <earthy> exactly
04:16:39 <shapr> Hamming's Art of Doing Science and Engineering is now on my list with SICP and tPP
04:16:43 <ivanm> well, as good a reason as any, I suppose
04:16:47 <earthy> ofcourse, the 'Modern Compiler Implementation' series by Appel is good as well
04:16:47 <DRMacIver> Yeah, the dragon book is another thing I really need to finish reading.
04:17:04 <ivanm> arrgghhh!!!! too many books to go through!!
04:17:28 <ivanm> I quite like SICP, except for the last few chapters... never good get through them
04:17:34 <ivanm> the ones where they wrote Scheme in Scheme
04:17:42 <ivanm> s/like/liked
04:17:55 <DRMacIver> Writing Scheme in Haskell is clearly a better exercise.
04:18:10 <ivanm> lol, that's another thing on my large list of things to read and do
04:18:34 <DRMacIver> On my to do list is to create a toy language and write a compiler for it in Haskell which generates C code.
04:18:41 <ivanm> I wanted to borrow a book on lambda calculus out from the library to read over the easter break... but the newest book they had was from the 1980s :s
04:18:54 <earthy> on my to do list is to write a full language Algol'68 compiler
04:18:59 <ivanm> lol
04:19:04 <DRMacIver> Filling out my "write a toy language", "learn more Haskell" and "learn C" checkboxes on the list of things I really want to learn. :)
04:19:17 <ivanm> my uni used to have a haskell + prolog 3rd year course, but they dropped it :(
04:19:42 * ivanm has only done a little bit of C (for microcontrollers), and never wants to touch it again
04:19:50 <ivanm> I preffered Fortran 90 to C
04:19:59 <earthy> ;)
04:20:00 <ivanm> or python
04:20:01 <SamB_XP_> JohnMeacham decided to write a Haskell compiler. He wanted to learn Haskell twice as quickly ;-)
04:20:14 <earthy> yeah, JohnMeacham is scary
04:20:17 <ivanm> lol... Haskell in Haskell?
04:20:23 <ivanm> like GHC?
04:20:25 <SamB_XP_> (It *is* a good way to learn dark the dark corners)
04:20:31 <SamB_XP_> ivanm: he calls it JHC
04:20:34 <DRMacIver> Well, I'm interviewing for a position to work on C compilers in a few weeks.
04:20:42 <DRMacIver> So I figured it might be useful to know some of the language. :)
04:20:50 <SamB_XP_> I hope you don't have to write a parser!
04:21:07 <DRMacIver> It's an existing compiler.
04:21:13 <DRMacIver> Rather than writing one from scratch. :)
04:22:29 <dcoutts> DRMacIver: you can help me with the c2hs C parser :-)
04:22:46 <dcoutts> DRMacIver: I'm trying to teach it how to parse GNU C __attribute__s
04:23:26 <ivanm> SamB_XP_: oh, JohnMeacham is the guy who wrote JHC... for some reason, I thought JHC was in Java :s
04:23:42 <SamB_XP_> heh
04:23:44 <ivanm> so what _does_ the J stand for? JohnMeacham?
04:23:49 <SamB_XP_> yeah
04:23:57 <SamB_XP_> well, John, anyway ;-)
04:24:03 <shapr> Or maybe Just a Haskell Compiler?
04:24:15 <SamB_XP_> shapr: ... I don't think so.
04:24:24 <ivanm> you mean that's all it does? it doesn't generate world peace or anything? *faints*
04:24:25 <ivanm> ;-)
04:24:26 <SamB_XP_> that doesn't make any sense!
04:24:29 <DRMacIver> dcoutts: Not yet I can't! :)
04:25:12 <DRMacIver> I've spent a few days reading Dennis and Kernighan's book, and have written about two (totally trivial) C programs ever. Such is the sum total of my C knowledge.
04:25:15 <SamB_XP_> ivanm: it does use an interesting IR...
04:25:29 <ivanm> IR?  Industrial Relations? :p
04:25:45 <SamB_XP_> Intermediate Representation
04:25:57 <ivanm> DRMacIver: I think I bought that book... didn't make any sense to me :s
04:26:06 <DRMacIver> Seems fine to me.
04:26:20 <ivanm> or am I getting confused with another one?... D & K was one of the textbooks we could ge...
04:26:40 <SamB_XP_> usually we call it K&R
04:26:41 <TSC> K&R is its usual name
04:26:43 <ivanm> I take it back... I bought Harbison and Steel, but borrowed and read D & K
04:26:51 <SamB_XP_> also make sure you get the second edition!
04:26:55 <ivanm> yeah, K&R... I knew what he meant ;-)
04:27:07 <pejo> ivanm, the standard book on lambda calculus is Barendregt, and last edition is from late 80's iirc.
04:27:14 <SamB_XP_> the one with ANSI "stamped" on the cover
04:27:39 <TSC> Or you could get a book on C99, if there are any
04:27:42 <ivanm> well, I got "introduction to combinators and lambda calculus" by hindley and seldin
04:27:52 <ivanm> seemed like the easisest one they had there
04:28:07 <DRMacIver> Sorry. To me he's Dennis. :)
04:28:18 <ivanm> I'm going to be (hopefully) doing a "special topics in computer science" subject next semester, with one of the few professors who actually uses Haskell
04:28:21 <SamB_XP_> I think K&R is probably more usefull than most books on C99... unless they have a third edition, in which case it *is* a book on C99 ;-P
04:28:28 <DRMacIver> (He's my mother's first cousin)
04:28:38 <ivanm> DRMacIver: free edition then? :p
04:28:43 <DRMacIver> 'fraid not. :)
04:28:46 <ivanm> :(
04:28:56 <ivanm> then what's the point of being related to him?
04:28:58 <DRMacIver> (I could probably have got one if I asked, but it's hardly expensive)
04:29:02 <ivanm> lol
04:29:16 <SamB_XP_> DRMacIver: I wasn't trying to say that you should not call him that. only that the initials are considered to be K&R ;-)
04:29:29 <DRMacIver> Sure. :)
04:30:37 <ivanm> @src liftM2
04:30:38 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:32:47 <ivanm> Cale: OK, I think I've got what you were doing figured out
04:36:07 <mux> @larma
04:36:07 <lambdabot> You have a karma of 3
04:36:17 <mux> heh, I love that DWIM feature of lambdabot
04:37:10 <mightybyte> Is that some "real" karma number or just random?
04:37:27 <earthy> @tyme \x -> x
04:37:27 <lambdabot> Maybe you meant: time type
04:37:51 <earthy> @tyoe \x -> x
04:37:53 <lambdabot> forall t. t -> t
04:38:10 <mightybyte> @karma
04:38:11 <lambdabot> You have a karma of 0
04:38:14 <earthy> mightybyte: that's a realish karma number
04:38:15 <earthy> @karma
04:38:15 <lambdabot> You have a karma of 2
04:38:24 <mightybyte> Hmmm, what's it based on?
04:38:35 <mightybyte> Your channel activity or something?
04:38:36 <earthy> karmapoints handed to you
04:38:44 <mightybyte> @karma
04:38:45 <lambdabot> You have a karma of 0
04:39:06 <mightybyte> @tarma
04:39:07 <lambdabot> You have a karma of 0
04:39:27 <mightybyte> Heh, some kind of hamming distance calculation to determine which command you meant?
04:39:44 <earthy> edit distances to know commands
04:39:49 <earthy> n
04:40:05 <mightybyte> Yeah
04:40:12 <mightybyte> Cool feature
04:40:28 <ivanm> @karma
04:40:29 <lambdabot> You have a karma of 0
04:40:41 <ivanm> :(... not that it really matters ;-)
04:41:14 <TomMD> @karma dons
04:41:14 <lambdabot> dons has a karma of 133
04:41:25 <TomMD> He is up five over these past two weeks
04:41:28 <earthy> @lartma dcoutts
04:41:29 <lambdabot> dcoutts has a karma of 45
04:41:56 <earthy> which reminds me
04:44:05 <campusblo> hello all
04:44:19 <campusblo> trying to write a program to multiply two fraction
04:44:20 <campusblo> s
04:45:11 <campusblo> using a fraction data type
04:45:13 <campusblo> data Fraction = Fraction Int Int
04:45:13 <campusblo>      deriving ( Show )
04:45:35 <ivanm> > (1%2 :: Ratio Int) * (2%3 :: Ratio Int)
04:45:35 <campusblo> makeFraction :: Int -> Int -> Fraction
04:45:35 <campusblo> makeFraction n d = Fraction n d
04:45:36 <lambdabot>  1%3
04:45:53 <campusblo> well i have makeFraction n d
04:46:05 <campusblo> but i cant seem to find a way to multiply without squaring
04:46:28 <ivanm> squaring? why?
04:46:47 <campusblo> if i use two different variables for numerator and denominator it doesnt recognize the undefined variable
04:46:54 <campusblo> all it sees is n and d
04:47:04 <ivanm> Multiply (Fraction a b) (Fraction c d) = Fraction (a*c) (b * d)
04:47:08 <campusblo> and of course im doing this for a class and we have to only use n and d
04:47:17 <campusblo> right thats what i did
04:47:40 <ivanm> campusblo: find the online version of SICP... its got a chapter on this, IIRC, but done in scheme
04:47:53 <campusblo> but makeFraction is only defined by Fraction n d
04:48:15 <ivanm> makeFraction n d = Fraction (n / g) (d / g) where g = gcd n d
04:48:24 <ivanm> ^^ instant simplification!!!
04:48:29 <ivanm> that's taken from SICP
04:48:35 <int-e> ivanm: wrong division though
04:48:50 <campusblo> whats gcd?
04:48:52 <ivanm> int-e: well, you can't expect me to tell him _everything_, right?
04:49:00 <ivanm> gcd = greatest common divisor
04:49:22 <ivanm> its the highest integer d such that d is a factor of both n and d
04:49:28 <ivanm> @google wikipedia gcd
04:49:30 <lambdabot> http://en.wikipedia.org/wiki/Greatest_common_divisor
04:49:30 <lambdabot> Title: Greatest common divisor - Wikipedia, the free encyclopedia
04:49:33 <campusblo> ok yeh i got that
04:49:43 <ivanm> > gcd 6 4
04:49:44 <lambdabot>  2
04:49:53 * ivanm paths lambdabot 
04:49:57 <ivanm> s/paths/pats
04:50:08 <int-e> > 6 % 4
04:50:09 <lambdabot>  3%2
04:50:31 <ivanm> int-e: I suggested using that up above, but it looks like he has to implement it from scratch
04:50:38 <campusblo> this is what we are given exf1 :: Fraction
04:50:38 <campusblo> exf1 = makeFraction 1 2
04:50:38 <campusblo> exf2 :: Fraction
04:50:38 <campusblo> exf2 = makeFraction 1 3
04:50:50 <campusblo> and we have to multiply those
04:50:59 <TSC> It's 1/6
04:51:00 <ivanm> yep... I've given you the code for it above
04:51:22 <ivanm> you really should look at the online version of SICP and read through the fractions section there
04:51:36 <campusblo> whats the link?
04:51:59 <ivanm> SICP uses scheme... but its the same basic stuff that you've got to do here
04:52:14 <ivanm> as in, how do we represent/store/manipulate fractions?
04:52:22 <ivanm> for that chapter/section, anyway
04:52:34 * ivanm wonders if theres something like SICP for haskell...
04:52:38 <campusblo> i want to go there but i dont know what to click on
04:52:49 <campusblo> is there an html link?
04:52:53 <ivanm> @google SICP
04:52:54 <lambdabot> http://mitpress.mit.edu/sicp/
04:52:55 <lambdabot> Title: Welcome to the SICP Web Site
04:53:00 <ivanm> ^^ link!
04:53:05 <ivanm> GIYF!!!
04:54:24 <ivanm> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.1 in particular is what you want
04:54:25 <lambdabot> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.1
04:55:03 <ivanm> *gasp* LB couldn't get the title!!! :o
04:56:47 <ivanm> @tell Cale thanks for that code, once you sort through it it really is cooler than my version... but its not as straightforward, IMHO...
04:56:47 <lambdabot> Consider it noted.
04:56:49 <campusblo> thanks. i hope it works
04:56:58 <ivanm> campusblo: it should...
05:00:10 <joelr1> good day
05:01:10 <joelr1> how do you implement type checking in haskell? assuming i have an Expr type with 1 constructor per type and functions can take lists of expressions, do i create a function taking an Expr and pattern-matching on appropriate constructor?
05:01:12 <ivanm> is it? *runs through his day* not sure if I'd necessarily call it "good"...
05:01:13 <ivanm> ;-)
05:06:20 <dons> joelr1: re. type checking, look up 'Typing Haskell in Haskell'
05:06:30 <Cheer1> hmm... say. you run an algorithm:   5 = a + b + c,   you get k! + k + 1 permutations if going with wholes only
05:06:39 <joelr1> @google Typing Haskell in Haskell
05:06:41 <lambdabot> http://citeseer.ist.psu.edu/424440.html
05:06:42 <lambdabot> Title: Typing Haskell in Haskell - Jones (ResearchIndex)
05:06:49 <joelr1> dons: thanks!
05:06:51 <dons> joelr1: might be an idea to grab spj's book, or bob harper's book, or TAPL
05:06:54 <dons> ?where plbook
05:06:55 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
05:07:05 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1353
05:07:09 <dons> is one resource we use to teach compiler construction
05:07:34 <Cheer1> in other case you get a set where 0 =< a,b,c <=5 and 5=a+b
05:08:00 <joelr1> dons: thanks! the book above is the right one? practical foundations for programming languages?
05:08:12 <joelr1> dons: i also have compiler construction in ML by andrew appel
05:08:19 <joelr1> dons: let me see if he covers type checking
05:08:30 <ivanm> Cheer1: where you let a,b,c be in [0,k]?
05:08:48 <Cheer1> erm. sorry 5=a+b+c
05:09:22 <ivanm> Cheer1: where does the k come from?
05:09:40 <dons> yeah, the above is a good one. http://www.cs.cmu.edu/~rwh/plbook/book.pdf
05:10:01 <Cheer1> ivanm: it's general case. for 5 = a+b+c, k=5
05:10:59 <ivanm> oh, OK... I thought you had k! + K + ... there as a time/space complexity
05:11:06 <joelr1> dons: i see that appel covers that a bit as well. i, apparently, should be doing it differently than i thought. i should return the type of expr rather than checking constructors (cafe email)
05:11:09 <joelr1> dons: thanks for the tips!
05:11:26 <mux> dons: hey, I was curious to know why you didn't use the -n flag of sysctl in your cpuperf blog entry
05:11:51 <mike_fotp> Hello all. I am looking for a POP3 client lib. Is HaskellNet my best choice?
05:12:18 <manu_> Hello, I'm having problems trying to build Alex and Happy on Mac OS X
05:12:36 <manu_> this is what i get : ~/Sites/happy-1.16 manu$ ./Setup.lhs configure
05:12:37 <manu_> -bash: ./Setup.lhs: /usr/bin/runhaskell: bad interpreter: No such file or directory
05:12:58 <manu_> any idea ?
05:13:28 <joelr1> dons: i feel like i should set aside friday just for reading :D
05:14:29 <mike_fotp> manu_: How / which haskell do you have installed?
05:16:39 * mux ^R's the 'why perl is more learnable than haskell' thread
05:18:11 <osfameron> ^R ?
05:18:37 <mux> err, I actually meant <Esc>R
05:20:21 <osfameron> ah, I guess you mean "mark as read and ignore" ?
05:21:06 <mux> yeah
05:21:15 <mux> that's how you mark as read a whole thread in mutt
05:21:45 <osfameron> ah, I must learn mutt, I'm really getting sick of thunderbird (and that's the least hateful mail reader I've found)
05:22:24 <osfameron> it's quite a polite thread actually, but yeah, nothing much new I suppose
05:22:40 <mux> yeah, it's not bad, it's just that I'm not interested :)
05:22:55 <osfameron> :D
05:23:20 <manu_> mike I have GHC 6.6 installed through Darwinports and reside in /opt/local/bin
05:24:47 <manu_> and /opt/local/bin is in my $PATH
05:25:10 <mux> osfameron: btw, I'm often just using mutt, but for some things (work email), I'm guilty of using evolution, and guilty of even liking it to some extent
05:26:03 <dons> joelr1: hmm, some other resources for you, if you're writing a type checker. we actually have a course on this :-)
05:26:07 <dons> joelr1: you could do assignment 2, http://cgi.cse.unsw.edu.au/~cs3161/06s1/ass2/index.php
05:26:08 <lambdabot> Title: COMP3161 Assignment 2 : COMP3161/9161 Concepts of Progamming Languages 2006/S1
05:26:43 <dons> the assignment is set out on page 4, http://cgi.cse.unsw.edu.au/~cs3161/06s1/ass2/06s1-a2-tyinf.pdf
05:27:04 * dons does evil laugh at actually having that as the assignment spec.
05:27:42 <joelr1> dons: thanks! :D question... why do you need type substitution? there must be a simple answer to this but i can't think of one off the top of my head
05:28:14 <dons> so that f x = x + 1
05:28:18 <dons> isn't inferred as f :: a -> a
05:28:31 * ndm really must learn to write a type checker one day
05:28:31 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
05:28:32 <dons> the rhs has types , a , Int, and you substitute Int over a
05:28:50 <ndm> dcoutts: i'm all done with fixes, please go and upload
05:28:54 <shapr> Yow!
05:28:56 <dons> ndm, you could do my assignment. I think its a good one :-)
05:29:08 <dcoutts> ndm: ak sorry, I've got to run for the bus!
05:29:10 <dons> as a bonus task, add type classes, and add it to yhc
05:29:18 <dons> dcoutts: quick!
05:29:20 <joelr1> dons: oh, so you end up with f :: Int -> Int based on previous use of f?
05:29:23 <ndm> dons: i may do - i came up with a new idea for writing a type system (Neil Typing), and would like to try it on a real example
05:29:29 <dons> joelr1: based on the types of its body,
05:29:30 <ndm> dcoutts: no probs, run run
05:29:39 <joelr1> dons: ah, right
05:29:51 <ndm> dons: my type system includes rank-n types and type classes, in theory, so would like to try them all in practice
05:29:51 <dons> namely, x:: a, and 1 :: Int, + :: Int -> Int -> Int, ----> x ;: Int, f :: Int -> Int
05:30:22 <Syzygy-> > [0,5..22]
05:30:24 <lambdabot>  [0,5,10,15,20]
05:30:24 <lambdabot> Syzygy-: You have 1 new message. '/msg lambdabot @messages' to read it.
05:30:33 <dons> joelr1: actually, the type checker they implement in that assignment is pretty similar to 'typing haskell in haskell'
05:30:43 <dons> so you can't go wrong if you start with THiH.
05:31:16 <joelr1> dons: in the mj paper there's a TyCon, is this applicable to haskell only? mine is a pascal-like language
05:31:39 <dons> yeah, TyCon, such as hmm, Either or Maybe
05:31:44 <dons> or (->)
05:31:47 <joelr1> right
05:31:49 <dons> read up on THiH :-)
05:31:56 <joelr1> dons: doing
05:32:07 <joelr1> on p4 at the moment
05:32:27 <joelr1> just read through type subbing, thus the related question
05:32:34 <dons> ok. night all. time for my lambda sleep.
05:33:25 <eumenides> can i not import instance declarations?
05:33:31 <joelr1> dons: good night!
05:35:30 <pcmoritz> i've got a question about IORefs: does (==) compare the "adresses" of the referenced object, or what does this function do?
05:36:32 <ndm> @instances IORef
05:36:33 <lambdabot> Couldn't find class `IORef'. Try @instances-importing
05:36:54 <ndm> pcmoritz: is there an Eq instance for IORef? I'm not sure you can do (==) on IORef
05:36:58 <ndm> @docs IORef
05:36:59 <lambdabot> IORef not available
05:37:02 <ndm> @docs Data.IORef
05:37:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
05:37:15 <pcmoritz> Instances
05:37:15 <pcmoritz> Typeable1 IORef
05:37:15 <pcmoritz> Typeable a => Data (IORef a)
05:37:15 <pcmoritz> Eq (IORef a)
05:37:37 <ndm> pcmoritz: hmm, i guess it must do something like that - it certainly can't compare the insides
05:37:39 <gour> ndm: glad to see about guihaskell & SoC. some more details available somewhere'
05:37:40 <gour> ?
05:38:03 <ndm> @where guihaskell
05:38:04 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
05:38:17 <pcmoritz> but what about the GC?
05:38:17 <ndm> @where+ guihaskell http://www-users.cs.york.ac.uk/~ndm/guihaskell/
05:38:18 <lambdabot> Done.
05:38:29 <ski> @instances-importing Data.IORef Eq
05:38:31 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, IORef a, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
05:38:32 <ndm> pcmoritz: equality will be stable, the value may change though
05:38:59 <pcmoritz> i think, the GC can move the objects in the memory?
05:39:03 <ndm> gour: no more details yet, just the idea is to make it work properly - i'll get the student to post his application sometime soon - and hopefully blog his progress
05:39:04 <ski> it compares the references
05:39:18 <ndm> pcmoritz: yes, but it will the move the object at the same time, so Eq stays valid
05:39:24 <mux> mmm, unfoldr looks really interesting
05:39:29 * mux dives deeper in Data.List
05:39:34 <pcmoritz> ok, thank you
05:39:38 <ski> @instances-importing Data.IORef Ord
05:39:40 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
05:39:42 <gour> ndm: is it supposed to be 'real' IDE?
05:39:43 <ski> ^ note no 'Ord'
05:39:53 <ski> (for 'IORef' i.e.)
05:40:30 <opqdonut> ?list
05:40:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:40:33 <ndm> gour: its meant to be WinHugs++, not a full IDE though
05:40:39 <dmhouse> I'm surprised IORef has an Eq instance...
05:40:48 <ndm> gour: although may go that way, if the student manages it
05:40:55 <gour> ndm: ok. ta
05:40:57 <pcmoritz> so, i can safely use IORef as pointers in a double linked list?
05:41:06 <dmhouse> Does it just do equality based on being a pointer to the same memory location?
05:41:09 <opqdonut> ?src Ord
05:41:10 <lambdabot> class  (Eq a) => Ord a  where
05:41:10 <lambdabot>     compare      :: a -> a -> Ordering
05:41:10 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
05:41:10 <lambdabot>     max, min         :: a -> a -> a
05:41:11 <mux> instance Eq a => Eq (IORef a) would be logical though
05:41:37 <pcmoritz> because i want to test, whether a given node is the head...
05:41:48 <pcmoritz> during itzeration through the list
05:42:15 <pcmoritz> is (==) of IORef the right thing for that?
05:46:20 <desp> > \f -> (\g -> f (g g)) (\g -> f (g g))
05:46:21 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
05:46:21 <lambdabot>     Probab...
05:47:47 <desp> boo
05:48:23 <ivanm> With arrays, there's amap which maps a function over all the elements in the array...
05:48:44 <ivanm> is it possible to do a mapping over all the elements based on what the indices are?
05:49:12 <opqdonut> desp: use fix
05:49:13 <ivanm> _without_ doing assocs, then re-creating the array?
05:49:21 <opqdonut> > fix (1:)
05:49:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:49:33 <Syzygy-> > fix(1:2:3:)
05:49:34 <lambdabot>      The operator `:' [infixr 5] of a section
05:49:35 <lambdabot>         must have lower precede...
05:49:37 <dmhouse> desp: well, what did you expect? Haskell is a typed language, you can't express the Y combinator in it.
05:49:55 <Syzygy-> > [1,2]:3
05:49:56 <lambdabot>   add an instance declaration for (Num [[t]])
05:50:04 <Syzygy-> > fix (:1:2:3)
05:50:06 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
05:50:06 <lambdabot>       Expected...
05:50:08 <osfameron> I thought fix was a y combinator?
05:50:09 <opqdonut> Syzygy-: (1:2):3
05:50:12 <Syzygy-> Ah.
05:50:21 <opqdonut> > fix ((1:2):3:)
05:50:22 <lambdabot>      The operator `:' [infixr 5] of a section
05:50:23 <lambdabot>         must have lower precede...
05:50:26 <Syzygy-> > fix (((1:2):3):)
05:50:26 <opqdonut> > fix ((1:2:3):)
05:50:27 <lambdabot>   add an instance declaration for (Num [[t]])
05:50:27 <opqdonut> gah
05:50:28 <lambdabot>   add an instance declaration for (Num [t])
05:50:32 <dmhouse> > fix (\x -> 1:2:3:x)
05:50:34 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
05:50:41 <opqdonut> yes, that exactly
05:50:44 <Syzygy-> Ah, that's how.
05:51:01 <opqdonut> ?pl (\x -> 1:2:3:x)
05:51:02 <lambdabot> ([1, 2, 3] ++)
05:51:07 <opqdonut> figures
05:51:16 <dmhouse> osfameron: well, you can't express the Y combinator that desp was trying to use in a typed calculus, then.
05:51:41 <opqdonut> there are other fixed point combinators besides Y
05:51:48 <opqdonut> it doesn't really matter which one you use
05:51:52 <desp> > y f = f (y f)
05:51:53 <lambdabot>  Parse error
05:52:10 <desp> meh
05:52:20 <opqdonut> ?src fix
05:52:21 <lambdabot> fix f = let x = f x in x
05:52:27 <osfameron> ah.  /me still doesn't really understand this (I've read Why oh Y a couple of times, half grokked bits of it :D)
05:52:44 <desp> there's also http://www.nabble.com/Fixpoint-combinator-without-recursion-t3527513.html
05:52:47 <lambdabot> Title: Nabble - Fixpoint combinator without recursion, http://tinyurl.com/2boc3w
05:52:50 * dmhouse prefers the fix f = f (fix f) definition
05:52:54 <desp> which kind of makes my head swim
05:53:34 <dmhouse> Recursive let is weird. It makes me think "Where is that x coming from?", whereas the fix f = f (fix f) is not only shorter, it makes the expansion clearer.
05:53:59 <dmhouse> desp: why?
05:54:15 <desp> dmhouse: I am not a type theorist :)
05:54:25 <dmhouse> All you're doing is encoding function application into a datatype.
05:54:52 <mlh> i thinks it means just download enough to work with; don't download entire history
05:54:57 <desp> yes, I meant the discussion about types :)
05:55:20 <mlh> oops, had scrolled waaay back
06:00:10 <ivanm> With arrays, there's amap which maps a function over all the elements in the array...
06:00:12 <ivanm> is it possible to do a mapping over all the elements based on what the indices are?
06:00:13 <ivanm> _without_ doing assocs, then re-creating the array?
06:07:08 <ski> dmhouse : with a naive implementation the 'let' version will create a cycle, but the other won't
06:08:48 <pcmoritz> hm, this prints "False":
06:08:48 <pcmoritz> let i = 3 in do {s <- newIORef i; s' <- newIORef i; putStrLn $ show (s == s')}
06:09:09 <ndm> pcmoritz: it compares the IORef, not the value inside
06:09:21 <pcmoritz> is this, because the compiler optimizes away the let?
06:09:29 <pcmoritz> that is clear
06:09:47 <pcmoritz> but it should be the same adresses
06:09:51 <ndm> pcmoritz: Eq will only return True if the two IORef's are the same address
06:09:53 <ndm> pcmoritz: how?
06:10:09 <ndm> pcmoritz: you mean the insides of the IORef have the same address, each newIORef call allocates a new address
06:10:21 <ski> (ivan : hm you want something like 'iamap :: (IArray a e0, IArray a e1, Ix i) => (i -> e0 -> e1) -> a i e0 -> a i e1' ?)
06:10:40 <ski> (s/ivan/ivanm/)
06:11:01 <pcmoritz> but i want to compare the adresses in the inside of an ioref :(
06:11:07 <pcmoritz> can i achieve this?
06:11:19 <pcmoritz> like with pointers in c
06:11:20 <ndm> pcmoritz: you can't, its impossible in haskell - it breaks referential transparency
06:11:23 <ivanm> ski: yeah...
06:12:00 <ski> i guess you could ask about it on the mailing list
06:12:06 <pcmoritz> ok, thx
06:12:22 <ivanm> ski: OK, thanks anyway
06:13:01 <pcmoritz> so, if i wanted to do something like this, i would have to write my own memory-management?
06:13:15 <pcmoritz> e.g. besed on arrays?
06:13:23 <pcmoritz> based
06:14:25 <chessguy> 'morning
06:15:25 <ski> do {i <- newIORef 3; do {s <- newIORef i; s' <- newIORef i; putStrLn $ show (s == s')}}
06:17:21 <chessguy> ?hoogle newIORef
06:17:22 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
06:17:59 <ndm> pcmoritz: you probably don't want to do pointer equality
06:18:51 <pcmoritz> hm, i've got a double linked list
06:19:00 <pcmoritz> based on IORefs
06:19:07 <pcmoritz> i want to traverse it
06:19:25 <pcmoritz> without a sentinel node (it is circular)
06:19:30 <ndm> pcmoritz: you probably want to think your problem though again, and not use IORefs - thats the usual solution
06:19:45 <pcmoritz> but it is an imperative algorithm
06:19:53 <ski> pcmoritz : then you should just be able to compare the refs with '(==)'
06:19:54 <ndm> pcmoritz: you can do these things, but you probably don't want to - there is usually a much nicer way of doing it in Haskell
06:20:07 <chessguy> from the IORef docs, "This function is useful for using IORef in a safe way in a multithreaded program. If you only have one IORef, then using atomicModifyIORef to access and modify it will prevent race conditions.
06:20:07 <chessguy> Extending the atomicity to multiple IORefs is problematic...". I assume the problem here arises from deadlock?
06:20:39 <pcmoritz> the algo is called "weiler Atherton", it is for polygon clipping
06:20:50 <ski> (chessguy : i'd guess so ..)
06:21:00 <ndm> chessguy: you can have a lock around one IORef, extending it to many means you have to lock in the right global ordering etc, and possibly retry
06:21:24 <chessguy> ndm: yes, because of deadlock
06:21:40 <pcmoritz> it is based on a pointer-datastructure like a double linked list, but the lists are interlinked with each other
06:21:55 <pcmoritz> i don't see an other way than to use IORefs
06:21:55 <ski> what is the problem ?
06:22:27 <chessguy> !past
06:22:30 <chessguy> !paste
06:22:31 <hpaste> Haskell paste bin: http://hpaste.org/
06:22:34 <chessguy> pcmoritz: ^^
06:23:11 <pcmoritz> ?
06:23:46 <chessguy> pcmoritz: it would be good if you could paste your implementation
06:23:53 <pcmoritz> ok
06:26:23 <pcmoritz> http://hpaste.org/1354
06:26:52 <pcmoritz> at the moment, it is really terrible :)
06:27:22 <pcmoritz> the 'foreach' is the problem...
06:31:08 <chessguy> does foreach not typecheck?
06:32:09 <pcmoritz> what do you mean?
06:32:13 <ski> hm ..
06:32:36 <chessguy> you said "foreach is the problem", but you didn't say waht the problem was...
06:32:48 <pcmoritz> ah
06:32:53 <pcmoritz> yes, it does
06:33:12 <pcmoritz> the problem ist the test, when the start node is reached again
06:33:15 * chessguy gets out his teeth-pulling pliers
06:33:33 <pcmoritz> because the list is circular
06:33:59 <pcmoritz> i did it with the "visited" field, but fubctions are allowed to modify these
06:34:16 <pcmoritz> so, now, i save the adress of the start node
06:34:33 <pcmoritz> and check it, everytime i handle the next node
06:35:01 <pcmoritz> but because of the IORef and Eq-problem, that doesn't work...
06:35:27 <ski> pcmoritz : why do you pass around 'startPtr' in 'iter' instead of just grabbing 'startNodeAdress' ?
06:35:45 <hpaste>  br1 pasted "emonk" at http://hpaste.org/1355
06:35:57 <pcmoritz> oh, yes, that is an idea *g*
06:36:02 <ivanm> anyone know of any code/example that I can use to print a 2-dimensional array?
06:37:10 <chessguy> heh
06:37:25 <chessguy> these spanish-speakers are using hpaste to have some kind of flamewar, i think
06:39:25 <pcmoritz> ok, now i know, why i pass it around: it is local to the do-construct
06:44:58 <ski> pcmoritz_afk : hm, you're doing the data structure in an "odd" fashion .. considered making it "even" ?
06:48:22 <ski> also, 'acc++[r]' is bad
06:48:39 <ski> cons to the front, and reverse at the end (if you must)
06:51:57 <ski> also, i wonder why you're calling 'p' and 'f' on 'n' (next node) instead of on 'c' (current node)
06:56:39 <chessguy> ?hoogle (a->b) -> f a -> f b
06:56:40 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
06:56:41 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
06:56:41 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
06:57:50 <mux> sjanssen: awesome quote in the haskell weekly news :-)
06:58:39 <chessguy> glguy: what's that all about, anyway?
07:04:10 <ski> @type fmap
07:04:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:07:56 <fasta> How does Data.Sequence export the takeUntil and dropUntil operations like Data.FingerTree?
07:09:57 <dmead_> isn't takeUntil imported into the prelude?
07:11:05 <fasta> dmead_: takeUntil can be specified for other types than [a]
07:11:22 <fasta> dmead_: or in other words: you are misunderstanding
07:12:02 <fasta> I suppose the answer is that it makes the interface larger, but I don't think that's a bad thing in this case.
07:19:29 <pcmoritz> re
07:19:53 <pcmoritz> @ski: what do you mean with "odd" and "even"?
07:19:54 <lambdabot> Unknown command, try @list
07:22:43 <ski> pcmoritz : "even" is when every node/cell is wrapped in a reference/indirection .. "odd" is when the same holds, except for the root node/cell, which is naked
07:23:49 <pcmoritz> ah, ok
07:23:51 <pcmoritz> thank you, i think, this could solve my problem
07:23:52 <ski> you are passing around 'ClipStructure's, that's "odd" .. "even" would be to pass around 'NodePtr's
07:24:00 <pcmoritz> i see
07:24:13 <pcmoritz> i will try that, thx a lot
07:24:47 <pcmoritz> i think, then the comparison of the IORefs should function, shuldn't they?
07:24:47 <ski> @hoogle "How to add laziness to a strict language without even being odd"
07:24:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '"How to ad'
07:24:57 <ski> @google "How to add laziness to a strict language without even being odd"
07:25:01 <lambdabot> http://citeseer.ist.psu.edu/102172.html
07:25:01 <lambdabot> Title: How to Add Laziness to a Strict Language Without Even Being Odd (ResearchIndex)
07:25:15 <ski> pcmoritz : afaik, the terms origined from that paper
07:25:17 <tsp> http://ww.lernu.net
07:25:20 <lambdabot> Title: lernu!: efpao
07:25:55 <tsp> how the hell
07:25:57 <tsp> did it convert that
07:26:21 <tsp> I relaly want ot know how it turned those utf-8 esperanto chars into something meaningful :)
07:26:25 <ski> (pcmoritz : of course you need to access the 'ClipStructure's internally .. but the difference is what is the "official" outside interface, so to speak)
07:27:25 <tsp> sure I like the x method better, but that's interesting nonetheless
07:27:43 <pcmoritz> yes, and i think, this would also simplify other things, too
07:29:49 <glguy> chessguy: huh?
07:30:09 <chessguy> hpaste :: (a -> b) -> f a -> f b
07:30:22 <chessguy> ?hoogle fmap
07:30:23 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
07:30:23 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
07:30:23 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
07:31:03 <dino-> hi
07:31:13 <glguy> chessguy: dons made the header image
07:31:22 <glguy> I don't think it necessarily means anything
07:31:31 <chessguy> ah. ok, just curious
07:31:40 <glguy> but if you need it to mean something, its like a Functor which is a container which is what hpaste is for pastes
07:32:11 <chessguy> but what does it do to each paste?
07:33:06 <glguy> makes a webpage out of it?
07:33:23 <chessguy> that would mmmm
07:33:47 <chessguy> s/that would //
07:35:34 <mux> parsing without monadic combinators is like using threads with C
07:37:17 <mux> or digging a hole with a fork
07:39:09 * mux is desperately trying to end up in the next weekly haskell news quotes and noone is noticing
07:40:30 * chessguy giggles
07:41:15 <chessguy> @remember mux I'm  desperately trying to end up in the next weekly haskell news quotes and noone is noticing
07:41:15 <lambdabot> Done.
07:41:47 * Igloo prefers alex+happy over monadic combinators, anyway  :-)
07:41:53 <mux> heh
07:42:12 <nominolo> does anyone have an idea why i get the error message "Setup.lhs: cannot satisfy dependency FilePath>=0.11" even though i have 1.0 installed?
07:42:17 <nominolo> I'm trying to install shim
07:42:49 <Igloo> nominolo: It's "filepath" now
07:42:59 <nominolo> oh
07:43:18 <chessguy> that'd do it
07:44:57 <nominolo> hm, what's the syntax for "OR" instead of "AND"="," in .cabal files?
07:46:18 <Igloo> There isn't one yet
07:47:24 <nominolo> k, i guess this is part of my SoC project then :)
07:47:45 <chessguy> woohoo
07:48:12 <mux> I saw ParsecT is part of SoC this year, that's cool
07:49:33 <Igloo> nominolo: Ah, yes, definitely  :-)
07:56:29 * earthy still doesn't get why ParsecT is supposed to be so cool
08:02:41 <joelr1> what's the function to downcase a string?
08:02:48 <joelr1> @hoogle lower
08:02:49 <lambdabot> Text.ParserCombinators.Parsec.Char.lower :: CharParser st Char
08:02:49 <lambdabot> Char.isLower :: Char -> Bool
08:02:49 <lambdabot> Char.toLower :: Char -> Char
08:02:55 <ptolomy> I just printed the paper for reading, but in case I forget: what is the fundamental difference between ReadP/ParseP and Parsec?
08:03:04 <ptolomy> map . toLower
08:03:05 <joelr1> > toLower "Foo"
08:03:07 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
08:03:16 <joelr1> ptolomy: thanks
08:03:27 <ptolomy> > map Data.Char.toLower "Foo"
08:03:29 <lambdabot>  "foo"
08:05:20 <ptolomy> Heh. I took a day off work to read CS papers. Maybe I should go back to school..
08:08:08 <Speck> ptolomy: I need to do that. after starting my new job I haven't read any papers :-(
08:21:16 <hpaste>  joelr1 pasted "What am I missing?" at http://hpaste.org/1357
08:21:21 <ski> (ptolomy : istr something about 'ReadP' not cutting away alternatives early, or something like that ..)
08:21:23 <joelr1> folks, any suggestions with the above?
08:21:46 <joelr1> am i not properly comparing?
08:21:51 <joelr1> pattern-matching rather
08:24:42 <ski> joelr1 : you can't match againt earlier bound variables (like one can in Erlang and Logic Programming)
08:25:27 <ski> s/Just sym/Just sym'' | sym == sym''/  (in 'expect')
08:26:13 <joelr1> ski: trying, thanks
08:26:14 <fax> hi
08:26:34 <earthy>     Possible cause: the monomorphism restriction applied to the following:
08:26:36 <earthy> yaay
08:26:42 <earthy> hello old friend. :)
08:26:56 <fax> will ghci not work with unicode?
08:27:00 <fax> or ghc?
08:27:05 <earthy> err, yes it will
08:27:18 <ski> joelr1 : though maybe that's not the error you're asking about (it is an error, though, i think)
08:27:20 <fax> ok cool
08:27:32 <joelr1> ski: it's a logical error on my part
08:27:38 <ski> right
08:27:49 <joelr1> ski: that's preventing my program from working correctly
08:27:50 <joelr1> was
08:28:00 <joelr1> i fixed it using your suggestion so thanks again
08:28:53 <ski> (joelr1 : i'd suggest renaming "sym' :: Maybe Sym" into "mSym :: Maybe Sym" or something .. to better discern which are symbols and which are maybe symbols)
08:29:17 <joelr1> right
08:30:16 <ski> (hm, actually, probably that matching bug was what you asked about ..)
08:31:19 <bringert> hi shoffsta.
08:31:27 <scriptdevil> heya guys
08:31:36 <bringert> shoffsta: did you ever get around to releasing you web apps framework?
08:33:07 <scriptdevil> count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l
08:33:22 <scriptdevil> actually what does the lambda in the foldr take?
08:33:39 <scriptdevil> i mean what wil be x and c for say "Hello" in the first attempt
08:33:58 <scriptdevil> l is "Hello"
08:42:16 <fax> is there a function to print out a string with newlines?
08:42:48 <bringert> fax: where do you want the newlines? could you give an example of a call and its results?
08:43:15 <ndm> fax: PUTsTRlN
08:43:15 <ndm> fax: putStrLn
08:43:15 <fax> display "a\nb" would give
08:43:15 <fax> a
08:43:15 <fax> b
08:43:15 <bringert> putStrLn
08:43:15 <bringert> or putStr
08:43:19 <fax> ah cheers
08:43:21 <fax> thanks guys
08:43:21 * ndm sergically removes his CAPS key
08:43:45 * ndm spells checked surgically
08:43:45 <kolmodin> ndm: turn your CAPS key into another Ctrl :)
08:43:56 <ski> scriptdevil : x  will be  'H'  and  c  will be  count2 p "ello"
08:44:10 <ndm> kolmodin: windows with non-admin, too much hassle
08:45:16 <kolmodin> :/
08:49:11 <dino-> ndm: I have my caps and left-control keys swapped. It really is better, but was tough to get used to for a month or two.
08:49:36 <dino-> kolmodin: Ah, didn't see your comment.
08:49:54 <rhz> How can I learn more about c2hs?
08:50:12 <plediii> why isn't (\x -> x x) of type (t - > t) -> (t -> t)?
08:51:04 <kolmodin> ?google c2hs
08:51:05 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
08:51:06 <lambdabot> Title: Manuel M T Chakravarty - C->Haskell
08:51:13 <kolmodin> there is a research paper there
08:51:24 <rhz> I have read through that paper.
08:51:44 <kolmodin> you want to know more? try it out or read the code :)
08:51:45 <fax> aw
08:51:55 <fax> I thought it would convert C into haskell with a name like c2hs
08:52:24 <dmhouse> plediii: well, if x has a type of (t -> t), then in any call of x, the argument must have type t. But in the call x x, the argument has type t -> t, not t.
08:53:35 <kolmodin> waern: yarr!
08:53:41 <waern> hi
08:54:04 <waern> is cabal-install usable yet?
08:54:33 <dmhouse> Fsov "usable", I think so. Although I'd like to know a more detailed answer to that, too.
08:54:39 <waern> I'd like to try it, but I've only found it here: http://darcs.haskell.org/cabal-with-install-OLD/
08:54:41 <lambdabot> Title: Index of /cabal-with-install-OLD
08:58:23 <plediii> dmhouse: I think I understand.  So how would I define a function f such that (f x) y is equivalent to x x y?
08:59:31 <plediii> ah, .
09:00:44 <rhz> A simple example of how to use c2hs would be quite helpfull
09:01:15 <rhz> Is there something I could look at?
09:01:33 <fax> if you wanted to use the awesome string.h stuff from C
09:02:18 <kolmodin> rhz: does this help? http://www.haskell.org/~kolmodin/code/hdbus/module/DBus/Message.chs
09:02:21 <lambdabot> http://tinyurl.com/yt86sc
09:02:42 <kolmodin> I have to go now, bye!
09:03:27 <rhz> thanks I'll have a look at it
09:06:36 <matthew-_> MarcWeber: ping ?
09:16:31 <ptolomy> I can't tell if "awesome string.h stuff" was sarcastic or not.
09:17:07 <fax> no I was joking, string.h is hardly the pinnacle of string handling libraries
09:17:53 <ptolomy> Heh. Okay.
09:17:57 <ptolomy> Just wanted to be sure.
09:17:59 <ndm> who is the TMR author people, and do they hang on IRC?
09:19:27 <MarcWeber> matthew-_: I'm here.
09:19:48 <ptolomy> ndm: What did you mean in your blog post by "ICFP referees please stop reading now"?
09:20:11 <bos> because they would discover his secret plan to blow up the world if they read on?
09:20:52 <ndm> ptolomy: ICFP has double blind reviewing, so they shouldn't read that post as it gives them a good idea of which paper i wrote
09:20:53 <matthew-_> MarcWeber: I saw your emails to the Nix project. Are you using Nix atm then?
09:21:08 <ndm> (although if they can't figure it out in about 10 seconds, they aren't as clever as I know they are!)
09:21:14 <ptolomy> ahhh.
09:21:18 <MarcWeber> matthew-_: I want t start using it.
09:21:40 <ndm> ptolomy: even so, i've deliberately not mentioned the name of my tool, and deliberately picked an example that isn't in my paper
09:21:50 <matthew-_> MarcWeber: me too. What's stopping you?
09:22:32 <MarcWeber> matthew-_: Wind ws at the m ment (s rry my ' ' key n  l nger w rks n xming )
09:22:48 <MarcWeber> I w nt t  kn w why the hell this happens
09:23:09 <rhz> c2hs is giving me errors on a simple example. Is anyone able to diagnose them? - http://hpaste.org/1358
09:24:18 <MarcWeber> matthew-_: I'd like t  add all packages fr m hackage which are still missing
09:41:38 <stepcut> is there a flag for ghc that will let me put in type signatures for functions, with out having to define the functions? I want to put, myFunc :: SomeType, and have the compiler assume, myFunc = undefined, if I didn't actually define it in my code
09:54:35 <jmlin> How to stop ghci if I typed "factorial 10000"?
09:54:53 <bos> control-c?
09:55:52 <ndm> jmlin: windows?
09:55:58 <jmlin> It seem that not real time to stop factorial. XD
09:56:46 <jmlin> ndm: I install ghci on FB
09:58:43 <LeCamarade> ?who
09:58:45 <lambdabot> Maybe you meant: echo ghc show what wn
09:59:18 <LeCamarade> echo ghc show what wn # Yeah, whatevs.
10:01:13 <LeCamarade> Okay, I have hit a big one. Background first: I hate filter and map, because comprehensions are better. Guido van Rossum agrees.
10:01:50 <ndm> LeCamarade: and Guido is wrong...
10:01:51 <LeCamarade> Now, how can I filter in a comprehension, when the Bool is in the IO monad? I mean the Bool that does the filtering?
10:01:56 <opqdonut> how are comprehensions "better"
10:02:02 <opqdonut> map is very elegant imo
10:02:08 <bos> uh, guido doesn't carry much weight around here.
10:02:15 <ndm> LeCamarade: i guess you aren't a fan of fold's? but list comps are all folds
10:02:16 <mightybyte> lol
10:02:41 <mightybyte> @karma guido
10:02:42 <lambdabot> guido has a karma of 0
10:02:57 <opqdonut> hrmmm python and closures
10:03:01 <opqdonut> hrmmm python's lambdas
10:03:04 <LeCamarade> Well, I hate the fact that they don't eta-reduce. But, in general, comprehensions are cleaner, clearer. Sure, Guido doesn't weigh here. It's the moon over here. But Simon Peyton Jones would agree, too.
10:03:12 <ndm> @karma- guido
10:03:13 <lambdabot> guido's karma lowered to -1.
10:03:17 <LeCamarade> @karma simonpj
10:03:18 <lambdabot> simonpj has a karma of 0
10:03:24 <opqdonut> :D
10:03:28 <bos> why do you think simonpj would agree?
10:03:34 <ndm> LeCamarade: spj would agree that list comps are better than maps? really?
10:03:42 * ndm makes a mental note to ask spj that
10:04:16 <bos> haskellers generally tend to avoid list comprehensions. you almost never see them in code written by grizzled veterans.
10:04:16 <ndm> LeCamarade: both are really handy, i find list comps great, but if you want to write a functional pipeline a map is much better - its a case of using each one when appropriate
10:04:40 <LeCamarade> He's a smooth operator. Dont you see: filter odd [1 .. 10] vs [x | x <- [1 .. 10] , odd x] ... um, okay, just more-suited for my editor. :oD
10:04:46 <ndm> bos: i love them, if you use Play you can write beautiful and complex queries in a single line
10:04:46 <bos> i've nothing against them, but you can't deny that they just don't see much use.
10:05:11 <ndm> i think they are probably under-used
10:05:21 <LeCamarade> I was suggesting, in fact, that comprehensions be extended to provide zips, so that we don't need ...
10:05:25 <ndm> but at the same time, steal map or filter and i'll hunt you down with a spikey lambda
10:05:40 <ndm> LeCamarade: they are in GHC with the appropriate flag, and its probably a good idea
10:06:14 <LeCamarade> ... stuff like zip, zip3, zipWith, zipWith3 ... Oh! GHC! I was actually going to extend my copy, and the source barked at me. :oD
10:06:37 <ndm> > [(a,b) | a <- [1..5] | b <- [1..5]]
10:06:38 <LeCamarade> So we have them! But not standard, eh? Okay, anyway, I only use GHC. :oD
10:06:39 <lambdabot>  Parse error
10:06:56 <ndm> dons: doesn't lambdabot support list/zip comprehensions?
10:07:06 * LeCamarade lambdabot should be put on apt-get upgrade
10:07:23 <chessguy> > [(a,b) | a <- [1..5] , b <- [1..5]]
10:07:25 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
10:07:31 <chessguy> you mean that?
10:07:40 <ndm> chessguy: no, thats cross-product, i wanted zips
10:07:41 <stepcut> no
10:07:45 <hpaste>  jorend annotated "exceptions using Either" with "(no title)" at http://hpaste.org/1359#a1
10:07:54 <ndm> > [(a,b) | (a,b) <- zip [1..5] [1..5]]
10:07:56 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5)]
10:08:00 <stepcut> *Main>  [(a,b) | a <- [1..5] | b <- [1..5]]
10:08:00 <stepcut> [(1,1),(2,2),(3,3),(4,4),(5,5)]
10:08:05 <LeCamarade> Yeah, I knew the syntax was foxing. I was thing something less-consistent than that syntax.
10:08:10 <chessguy> ah
10:08:53 <LeCamarade> [(a, b) | (a, b) <- [1 .. 5] [1 .. 5]]
10:08:59 <LeCamarade> That's what I was thinking.
10:09:05 <LeCamarade> Neat, no?
10:09:22 <ndm> LeCamarade: insert the single work zip and it becomes more explicit, and doesn't overlap with the existing syntax of anything
10:09:23 * LeCamarade is pissed - nobody salutes his syntactical artistry!
10:09:24 <fax> cant you just do ([1 .. 5], [1 .. 5]) ?
10:09:29 <fax> LeCamarade:
10:09:33 <ndm> LeCamarade: plus it already works...
10:09:39 <chessguy> > do { x <- [1..5]; y <- [1..5]; return (x,y) }
10:09:40 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
10:09:48 <chessguy> i still like this :)
10:10:12 <ndm> LeCamarade: add a <> operator, put it between the lists, and it starts to look like inbuilt syntax
10:10:12 <fax> no cartesian product function exists?
10:10:33 <opqdonut> fax: well you can do it with the list monad
10:10:48 <LeCamarade> ndm: Ah. Yeah. Yep.
10:11:01 <opqdonut> liftM2 (,) [1,2,3,4] [1,2,3,4]
10:11:02 <LeCamarade> Now, back to my plea. Watch dis:
10:11:06 <opqdonut> > liftM2 (,) [1,2,3,4] [1,2,3,4]
10:11:08 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
10:11:10 <opqdonut> there
10:11:11 <fax> nice :D
10:11:21 <chessguy> > let cart xs ys = [(x,y) | x <- xs, y <- ys] in cart [1..5] [1..5]-- fax, you mean this?
10:11:23 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
10:11:32 <chessguy> ouch, opqdonut showed me up :)
10:11:38 <fax> can you have liftM (,) [[1..4],[1..4]] ?
10:11:54 <fax> instead of writing out the number of arguments
10:12:09 <opqdonut> > liftM2 (,) [1..4] [1..4]
10:12:09 <fax> chessguy: but it only takes two
10:12:11 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
10:12:13 <opqdonut> you mean that?
10:12:19 <fax> you have to say it takes 2 and also provide 2
10:12:36 <LeCamarade> ndm: You're gone?
10:12:44 <chessguy> opqdonut: i think he wants an arbitrary number of lists
10:13:23 <opqdonut> fax: you could make a version that folds over a list
10:13:23 <chessguy> > liftM (,) [[1..5],[1..5],[1..5]] -- i don't think this works
10:13:25 <lambdabot>  Add a type signature
10:13:46 <LeCamarade> Okay, guys, here. What if the predicate I use dabbles in the IO sin, how can I use it in a comprehension?
10:13:47 <chessguy> > liftM (,) [[1..5],[1..5],[1..5]] :: [(Int,Int,Int)]
10:13:48 <lambdabot>  Couldn't match expected type `(Int, Int, Int)'
10:14:06 <sjanssen> LeCamarade: you can't use a list comprehension then
10:14:12 <sjanssen> you can use filterM
10:14:15 <sjanssen> @type filterM
10:14:18 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:14:31 <bos> it used to be that comprehensions worked with monads, but that blew up in people's faces too often, so it was removed.
10:14:32 <stepcut> > liftM3 (,,) [1..5] [1..5] [1..5]
10:14:34 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,2,1),(1,2,2),(1,2,3),(1,2,4),(1,...
10:14:36 <stepcut> ?
10:14:46 <LeCamarade> Yeah, Monad.filterM would do, but so I have lost my comprehension?
10:14:48 <chessguy> yeah, turn your list comprehension into a form with map/filter, and then use mapM and filterM
10:14:50 <opqdonut> stepcut: variable number of arguments
10:15:04 <stepcut> opqdonut: right, that is different
10:15:34 * LeCamarade runs to the end of the world, distraught, crying ... `but I love her! I love the list comprehension!', she cries, inconsolably.
10:15:40 <sjanssen> LeCamarade: list comprehensions are overrated, anyway
10:15:49 * chessguy backs slowly away from LeCamarade 
10:16:02 <stepcut> for a variable number of arguments, you probably want a [[Int]] as the output type instead of [(Int,Int,...., Int)] ?
10:16:23 <LeCamarade> sjanssen: Nope. Best way to run over a list. I just love 'em.
10:16:31 <dmhouse> sjanssen: they are?
10:17:05 <d00nibro> anyone know of a function for truncating the number of decimals on a float, for prettier display?
10:17:11 <chessguy> stepcut: well yeah, but we're lifting (,)
10:17:13 * LeCamarade picks a knife. `Where is that guy?'
10:17:19 <sjanssen> dmhouse: of course that's an opinion, but yeah that's how I feel
10:17:38 <chessguy> or we were anyway
10:17:50 <dmhouse> They're occasionally very useful. I.e. sum [ x | Just x <- xs ] sums the numerical components of Justs within a list of Maybes.
10:17:59 <stepcut> chessguy: well, if you are lifting, (,) then you can only have the output type of [(a,b)] unless you do nested tuples, (a,(b,(c,...)))
10:18:07 <sjanssen> I especially prefer map/filter when you can manage to write it in a pointfree style
10:18:13 <chessguy> stepcut: good point
10:18:15 <dmhouse> (Of course, in this instance, sum . catMaybes is just as short, but if you're using something other than Maybe it becomes very useful.)
10:18:23 <sjanssen> dmhouse: yes, that's handy
10:18:42 <chessguy> @type sum [ x | Just x <- xs ]
10:18:44 <stepcut> chessguy: if you want [(Int,Int,Int)], then you have to lift (,,) as I did earlier
10:18:44 <sjanssen> @seen jcreigh
10:18:44 <lambdabot> Not in scope: `xs'
10:18:45 <lambdabot> jcreigh is in #haskell-blah and #haskell. I last heard jcreigh speak 12h 12m 33s ago.
10:18:51 <chessguy> @type sum [ x | Just x <- ?xs ]
10:18:53 <lambdabot> forall t. (?xs::[Maybe t], Num t) => t
10:19:03 <dmhouse> ?type \xs -> [ x | Just x <- xs ]
10:19:03 <chessguy> nice
10:19:05 <lambdabot> forall t. [Maybe t] -> [t]
10:19:16 <dmhouse> ?type \xs -> sum [ x | Just x <- xs ]
10:19:17 <chessguy> dmhouse: same thing :)
10:19:19 <lambdabot> forall t. (Num t) => [Maybe t] -> t
10:19:29 <LeCamarade> Yeah, when I want to pattern-match, comprehensions rule. I find a new niftiness about them every night.
10:19:40 <dmhouse> chessguy: well, yes, but there's no need to obfuscate things using implicit parameters.
10:19:58 <chessguy> hrm. (Maybe a) is an instance of num?
10:20:11 <dmhouse> chessguy: erm, no?
10:20:24 <LeCamarade> Okay, who knows the structure of PrintfType? The one in Text.Printf? If I can grok it, I and I will be like very happy ...
10:20:37 <dmhouse> > Just 3 + Nothing
10:20:40 <lambdabot>   add an instance declaration for (Num (Maybe t))
10:20:40 <lambdabot>     In the expression: (Jus...
10:20:49 <chessguy> ohhh, i thought you were counting. now i get it
10:21:07 <chessguy> ?type \xs -> length [ x | Just x <- xs ]
10:21:10 <lambdabot> forall t. [Maybe t] -> Int
10:21:32 <dmhouse> ?type length . catMaybes
10:21:35 <lambdabot> forall a. [Maybe a] -> Int
10:21:53 <thedward> LeCamarade: PrintfType is a type class
10:22:11 <chessguy> ?src catMaybes
10:22:11 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:22:15 <chessguy> :)
10:22:27 <MarcWeber> matthew_-: I'll tell you when working again on adding haskell packages. I want to get ti working on windows in general first
10:23:10 <LeCamarade> thedward: Yeah... like Eq. Okay, maybe my question should be: how does printf do it? Okay, wait. Methinks I'll be figuring it out soon ...
10:23:27 <sjanssen> LeCamarade: the Printf stuff is pretty serious voodoo
10:23:58 <sjanssen> LeCamarade: look for literature by Oleg Kiselyov on "polyvariadic functions"
10:24:02 <dmhouse> Printf is just typeclass hackery, isn't it? No dynamics or anything.
10:24:15 <dmhouse> It's not statically safe, but other than that...
10:24:21 <nibro> can it really be that there is no such function in Haskell?
10:24:27 * nibro is mildly annoyed
10:24:33 <dmhouse> nibro: to do what?
10:24:51 <nibro> truncate the number of decimals of a float for display
10:25:23 <rahikkala> nibro: \nDigits number -> take (2 + nDigits) (show number)
10:25:59 * LeCamarade looks at sjanssen, scared, and sprints calling for Mummy.
10:26:18 <nibro> rahikkala: sure, if I could be certain that the number before the . was a single digit
10:26:25 <dmhouse> The polyvariadic stuff is quite cool.
10:26:27 <sjanssen> dmhouse: yeah, it's all type class hackery -- but it's some crazy voodoo type class stuff
10:26:35 <LeCamarade> sjanssen: I can't even spell the name of ... `polyvaraidik'. Wow! I got it right!
10:26:49 * chessguy can't resist
10:26:50 <chessguy> @quote voodoo
10:26:50 <kc5tja> LeCamarade: No you didn't.
10:26:50 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
10:26:55 <chessguy> @quote goat
10:26:55 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
10:26:56 <nibro> I know how to do it the roundabout way, but I'm still perplexed that there is no standard function to do this
10:27:02 <rahikkala> nibro: Heheh, well, that's what I get for idly throwing out some code without thinking of what it does
10:27:13 <Saizan> nibro: there's printf
10:27:18 <dmhouse> Basically any time you say 'X can't be done in Haskell', you can be 80% sure that within a week, Oleg will respond saying "Actually, you can do it, using these 17 different type classes, here's how: ..."
10:27:41 <chessguy> @quote oleg
10:27:41 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
10:28:05 <rahikkala> dmhouse: ... but you only need one typeclass, don't you? :(
10:28:23 <dmhouse> nibro: try showFFloat from Numeric
10:28:33 <dmhouse> "In the call showFFloat digs val, if digs is Nothing, the value is shown to full precision; if digs is Just d, then at most d digits after the decimal point are shown."
10:29:00 <Saizan> ?hoogle showFFloat
10:29:01 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
10:29:30 <dmhouse> > showFFloat (Just 3) (1 / 3) ""
10:29:31 <lambdabot>  "0.333"
10:30:16 <dmhouse> (The last "" parameter is because showFFloat uses the annoying ShowS idiom, check out the Text.Show haddocks for more information.)
10:30:37 <chessguy> ooh, oleg has an RSS feed
10:30:42 <rahikkala> > showFFloat Nothing (1 / 3) ""
10:30:45 <lambdabot>  "0.3333333333333333"
10:31:32 <rahikkala> > (showFFloat Nothing ((1/3) :: Float)) ""
10:31:34 <lambdabot>  "0.33333334"
10:32:50 <dmwit> > printf "%.3f" (1 / 3)
10:32:51 <lambdabot>  Add a type signature
10:32:57 <dmwit> > printf "%.3f" (1 / 3) :: String
10:32:59 <lambdabot>  "0.333"
10:33:39 <opqdonut> :t printf
10:33:41 <lambdabot> forall r. (PrintfType r) => String -> r
10:33:50 <opqdonut> ah
10:33:55 <bos> chessguy: url?
10:34:43 <chessguy> http://okmij.org/ftp/rss.xml
10:34:50 <bos> yuM!
10:34:55 <chessguy> from his homepage, http://okmij.org/ftp/
10:34:56 <lambdabot> Title: This FTP site
10:35:11 <bos> (that's "yum" in the kleisli category. or a typo, depending on your perspective.)
10:36:15 <chessguy> nice title, too
10:40:31 <jcreigh> sjanssen: yes?
10:42:24 <ski> @remember dmhouse Basically any time you say 'X can't be done in Haskell', you can be 80% sure that within a week, Oleg will respond saying "Actually, you can do it, using these 17 different type classes, here's how: ..."
10:42:25 <lambdabot> Done.
10:44:03 <nominolo> As suggested on the homepage, I hereby express my liking of the shim package! :)
10:44:43 <ski> @where shim
10:44:45 <lambdabot> http://shim.haskellco.de/trac/
10:45:33 <nominolo> you might need to apply http://shim.haskellco.de/trac/attachment/ticket/7/shimbuild.patch first, though
10:45:35 <lambdabot> Title: #7: shimbuild.patch - shim - Trac
10:47:07 <nominolo> hi SyntaxNinja
10:47:29 <LeCamarade> Has anyone ported a Haskell compiler to .NET?
10:47:42 <LeCamarade> Some guys have done ML.NET, and I feel really envious.
10:47:51 <nibro> dmhouse: thanks a lot!
10:47:56 <LeCamarade> And there's F#, which is Ocaml for .NET.
10:47:56 <mightybyte> Why would one WANT to?
10:48:00 <nibro> I knew there had to be one :-D
10:48:09 <LeCamarade> Unfair!
10:48:23 <LeCamarade> Well, so you can write Haskell and run it on .NET.
10:48:56 <LeCamarade> So you can code the neater bits in Haskell, and just use them in C#. Same question for the JVM.
10:49:00 <nominolo> GHC compiles for Windows
10:49:01 <mightybyte> Oh, so something that COMPILES TO .NET rather than WRITTEN IN .NET?
10:49:20 <LeCamarade> Yeah, I meant the CLI. CLR. .NET. Whatever.
10:49:35 <nominolo> doesn't .net have a FFI?
10:49:39 <LeCamarade> Compile *to*.
10:49:57 <SyntaxNinja> yo
10:49:57 <mightybyte> Ok.
10:50:06 <LeCamarade> It has. But I don't mean Haskell using .NET assembies - that is not forgivable.
10:50:25 <SyntaxNinja> nominolo: how are you?
10:50:26 <LeCamarade> I mean .NET languages (#) using Haskell-written code.
10:51:01 <nominolo> SyntaxNinja: I take it you're going to be my mentor?
10:52:07 <LeCamarade> nominolo: SyntaxNinja and many other guys in here have nurtured the rest of us. You're in safe hands. This monastery has raised the greatest out there. Be of good cheer. SyntaxNinja ... please.
10:53:48 <nominolo> LeCamarade: i guess you could port ghc/yhc to compile to MSIL/CLR.  I wouldn't be too optimistic about comparable performance though
10:53:58 <nominolo> LeCamarade: does .NET allow custom GC?
10:54:13 <SyntaxNinja> nominolo: I haven't read my email today :)
10:54:21 <SyntaxNinja> LeCamarade: thanks
10:55:17 <LeCamarade> nominolo: No, if I am to do it, I would have to go from bare scratch. For a billion reasons.
10:56:15 <nominolo> LeCamarade: could you sketch the top-2 or something?
10:57:10 <LeCamarade> Okay ... the CLI's assemblies, I have heard, have subtle fineness that can't be used sans hand-coding your way there.
10:57:56 <LeCamarade> 2, if I am to implement laziness, I have to do it bravely, on the bare metal (or bare plastic).
10:57:56 <desp> is there a simple syntax for arrays in Haskell?
10:58:12 <LeCamarade> desp: [1 .. 10]
10:58:21 <LeCamarade> > [1 .. 20]
10:58:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
10:58:27 <wilx> I don't think so.
10:58:32 <wilx> And these are lists, not arrays.
10:58:32 <desp> LeCamarade: uh, no.
10:58:36 <nelhage> I'll point out that's not actually an array.
10:58:36 <wilx> No random access.
10:58:38 <LeCamarade> :oD
10:58:48 <nominolo> > [: 1 .. 5 :]
10:58:48 <lambdabot>  Parse error
10:58:50 <dmwit> ?index Array
10:58:51 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
10:58:55 <dmhouse> > zip "hello" [1..5]
10:58:56 <lambdabot>  [('h',1),('e',2),('l',3),('l',4),('o',5)]
10:59:02 <dmhouse> Now you get random access :)
10:59:03 <desp> so, nothing like OCaml's [|1; 2; 3|]?
10:59:10 <nominolo> :t newListArray
10:59:12 <lambdabot> Not in scope: `newListArray'
10:59:12 <LeCamarade> Array! Oh, gack, I need some sleep. Lists. /=. Arrays. I. Need. Some. Sleep.'
10:59:18 <dmwit> desp: Sorry, no, it's much uglier than that.
10:59:32 <nelhage> :t Data.Array.newListArray
10:59:35 <lambdabot> Not in scope: `Data.Array.newListArray'
10:59:37 <drigz> what's a good way to get every other element of a list?
10:59:40 <desp> @hoogle nth
10:59:41 <lambdabot> System.Time.ctMonth :: CalendarTime -> Month
10:59:42 <lambdabot> System.Time.Month :: data Month
10:59:42 <lambdabot> System.Time.tdMonth :: TimeDiff -> Int
10:59:47 <dmhouse> > Data.Array.fromAscList (zip "hello" [1..5])
10:59:49 <lambdabot>   Not in scope: `Data.Array.fromAscList'
10:59:49 <chessguy> > zip "hello" [1..] - /me golfs dmhouse
10:59:50 <lambdabot>  Parse error
10:59:51 <drigz> other than writing my own recursive function, which i'm told is to be avoided
10:59:53 <nominolo> LeCamarade: Did you read Simon's books on the STG-machine?
10:59:55 <chessguy> > zip "hello" [1..] -- /me golfs dmhouse
10:59:57 <lambdabot>  [('h',1),('e',2),('l',3),('l',4),('o',5)]
11:00:08 <desp> is there a built-in function to access the nth element of a list?
11:00:13 <dmhouse> desp: (!!)
11:00:17 <desp> aha, thanks
11:00:18 <nelhage> :t (!!)
11:00:21 <lambdabot> forall a. [a] -> Int -> a
11:00:26 <chessguy> ?src (!!)
11:00:27 <lambdabot> xs     !! n | n < 0 = undefined
11:00:27 <lambdabot> []     !! _         = undefined
11:00:27 <lambdabot> (x:_)  !! 0         = x
11:00:27 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:00:31 <xerox> > array (1,10) $ zip [1..] "abcdefghij"
11:00:33 <lambdabot>  array (1,10) [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'...
11:00:34 <dmhouse> > take 5 $ zip (cycle "hello") [1..] -- chessguy
11:00:36 <lambdabot>  [('h',1),('e',2),('l',3),('l',4),('o',5)]
11:00:51 <chessguy> that's longer, not shorter :)
11:00:59 <kpreid> drigz: I'd write it as a recursive function.
11:01:02 <dmwit> > array (1,5) (zip [1..] "hello")
11:01:04 <lambdabot>  array (1,5) [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
11:01:20 <drigz> > listArray (1,5) "hello"
11:01:22 <lambdabot>  array (1,5) [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
11:01:28 <dmhouse> chessguy: well, it's more... fun :)
11:01:34 <dmwit> desp: ^^
11:01:37 <kpreid> > let halve (x:_:xs) = x : halve xs; halve _ = [] in halve [1..]
11:01:37 <chessguy> lol
11:01:39 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:02:36 <chessguy> > let odds = iterate (+2) 1 in odds
11:02:37 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:02:54 <dmwit> > let odds xs = do { x <- xs; odd <- cycle [True, False]; guard odd; return x } in odds [1..]
11:02:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:03:03 <dmhouse> > let evens [] = []; evens (x:xs) = x : odds xs; odds xs = []; odds (_:xs) = evens xs in (evens [1..20], odds [1..20])
11:03:04 <lambdabot>      Warning: Pattern match(es) are overlapped
11:03:04 <lambdabot>              In the definition...
11:03:18 <dmhouse> > let evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (_:xs) = evens xs in (evens [1..20], odds [1..20])
11:03:19 <chessguy> > let odds = 1 : map (+2) odds in odds
11:03:21 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20])
11:03:22 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:03:43 * chessguy giggles
11:03:53 <dmhouse> > fix ((1:) . map (+2))
11:03:55 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:03:58 <chessguy> @type traverse
11:04:01 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:04:07 <dmwit> > map fst . filter fst $ zip (cycle [True, False]) [1..]
11:04:09 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
11:04:17 <dmwit> > map snd . filter fst $ zip (cycle [True, False]) [1..]
11:04:18 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:04:47 <chessguy> ugh
11:05:11 <dmwit> Three passes, yuck.
11:05:16 <xerox> > let evens = 0 : map (+1) odds; odds = map (+1) evens; in transpose [evens,odds]
11:05:18 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,2...
11:05:19 <xerox> I think I'm awfully lagged.
11:05:36 <dmhouse> > filter ((== 1) . (`mod` 2)) [1..]
11:05:38 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:06:13 <drigz> > filter (.&. 1) [1..]
11:06:14 <lambdabot>   add an instance declaration for (Bits Bool)
11:06:17 <dmwit> > filter odd [1..]
11:06:19 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:06:22 <dmwit> But that isn't what he asked for.
11:06:37 <dmwit> He wanted all the odd-numbered entries, and that doesn't do the trick on say, [2,4..]
11:06:48 <dmhouse> Wait, we're trying to actually get to something sensible?
11:07:17 <drigz> i thought we'd transitioned to the most interesting way of getting the odd numbers
11:07:29 <dmwit> o
11:07:37 <sjanssen> what's wrong with the map/filter/zip/cycle approach?
11:07:45 <drigz> given that i asked the original question and decided that a normal function was the easiest route
11:08:01 <sjanssen> that is how I would write it
11:08:34 <drigz> sjanssen: it seems like it would be a lot less efficient than just skipping every other elemnt
11:08:37 <drigz> (to me, at least)
11:08:39 <dmwit> Does laziness mean that those three map/filter/zip passes essentially become one?
11:08:41 <dmhouse> zip/filter or defining an odds function is the best way, I'd imagine.
11:08:48 <sjanssen> drigz: in Haskell, they should be about the same
11:08:50 <xinming> scw: hi
11:09:01 <sjanssen> especially in the presence of fusion
11:09:18 <dmhouse> > let odds [] = []; odds [_] = []; odds (_:x:xs) = x : odds xs in odds [0..10]
11:09:20 <lambdabot>  [1,3,5,7,9]
11:09:37 <SyntaxNinja> wow. lots of people in this room.
11:09:42 <dmhouse> ?users
11:09:42 <lambdabot> Maximum users seen in #haskell: 336, currently: 316 (94.0%), active: 48 (15.2%)
11:10:32 <drigz> > let odds (_:x:xs) = x : odds xs; odds _ = [] in odds [0..10]
11:10:34 <lambdabot>  [1,3,5,7,9]
11:12:13 <dmwit> > let odds = evens . drop 1; evens [] = []; evens xs = head xs : evens $ drop 2 xs in odds [0..10]
11:12:14 <lambdabot>  Couldn't match expected type `[t]'
11:12:41 <dmwit> > let odds = evens . drop 1; evens [] = []; evens xs = head xs : evens (drop 2 xs) in odds [0..10]
11:12:43 <lambdabot>  [1,3,5,7,9]
11:15:27 <dmhouse> > snd $ foldl (\(ix, acc) el -> (succ ix, if even ix then acc ++ [el] else acc)) (0, []) [0..10]
11:15:29 <lambdabot>  [0,2,4,6,8,10]
11:15:42 <dmhouse> "Everything is a fold" :)
11:16:22 <drigz> even if it's an O(n^2) fold?
11:16:49 <dmhouse> I'm just thinking about that, there must be a more natural way of encoding odds into a fold.
11:17:14 <drigz> you could do it with unfoldr, but that's rarely pretty
11:17:41 <drigz> (i say rarely, i've seen maybe 2-3 uses of it, so i shouldn't talk)
11:18:31 <dmhouse> drigz: well, this is more of a fold than an unfold...
11:19:12 <drigz> i'd say it's more of a scan than either
11:19:26 <dmhouse> Well, a scan is a type of fold.
11:20:55 <dmhouse> let xs = [0..10] in snd $ foldr (\el (ix, acc) -> (pred ix, if even ix then el : acc else acc)) (length xs, []) xs
11:21:04 <dmhouse> That's an O(n) version, but it's two-pass.
11:21:05 <dmhouse> > let xs = [0..12] in snd $ foldr (\el (ix, acc) -> (pred ix, if even ix then el : acc else acc)) (length xs, []) xs
11:21:08 <lambdabot>  [1,3,5,7,9,11]
11:21:43 <xerox> > unfoldr (Just . (join (&&&) (+2))) (-1)
11:21:45 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:22:12 <dmwit> :t foldl
11:22:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:22:22 <dmwit> :t foldl'
11:22:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:22:32 <dmhouse> dmwit: foldl' applies the function strictly.
11:22:40 <dmhouse> > foldl (+) 0 [1..10000000000]
11:22:44 <lambdabot> Terminated
11:22:48 <dmhouse> > foldl' (+) 0 [1..10000000000]
11:22:52 <lambdabot> Terminated
11:23:14 <dmhouse> Err, well, yeah, ignoring Lambdabot's timeouts, the first would be a stack overflow, the second would complete in O(1) space.
11:24:06 <sjanssen> though GHC has a tendency to turn the first into the second with strictness analysis
11:25:11 <dmwit> > foldl' (\(x, ys) y -> (not x, if x then y:ys else ys)) (True, []) [1..]
11:25:13 <dmhouse> foldl needs O(n) space because it builds up thunks, foldl' executes the thunks as it goes along and is tail recursive so only needs a constant amount of memory.
11:25:15 <lambdabot> Terminated
11:25:39 <dmwit> > foldl' (\(x, ys) y -> (not x, if x then y:ys else ys)) (True, []) [1..13]
11:25:41 <lambdabot>  (False,[13,11,9,7,5,3,1])
11:25:45 <dmhouse> No left folds work on infinite lists.
11:25:55 <dmwit> > foldr (\(x, ys) y -> (not x, if x then y:ys else ys)) (True, []) [1..13]
11:25:57 <lambdabot>      Occurs check: cannot construct the infinite type: t = [(Bool, t)]
11:25:57 <lambdabot>       ...
11:26:06 <dmwit> :t foldr
11:26:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:26:41 <dmwit> > foldr (\y (x, ys) -> (not x, if x then y:ys else ys)) (True, []) [1..13]
11:26:44 <lambdabot>  (False,[1,3,5,7,9,11,13])
11:27:10 <dmhouse> > foldr (\y (x, ys) -> (not x, if x then y:ys else ys)) (True, [])
11:27:10 <dmhouse>     [1..14]
11:27:12 <lambdabot>  Add a type signature
11:27:16 <dmwit> > let odds = snd . foldr (\y (x, ys) -> (not x, if x then y:ys else ys)) (False, []) in odds [0..]
11:27:19 <lambdabot>  Exception: stack overflow
11:27:22 <dmhouse> > foldr (\y (x, ys) -> (not x, if x then y:ys else ys)) (True, []) [1..14] -- Curse copy-paste :)
11:27:24 <lambdabot>  (True,[2,4,6,8,10,12,14])
11:27:30 <sjanssen> that's a bad one
11:27:45 <sjanssen> you never want to be strict in a foldr's second argument
11:27:47 <dmwit> Yeah, not very pretty at all.
11:27:53 <dmhouse> dmwit: it doesn't work; it returns the odd-numbered elements counting from the end, rather than from the beginning.
11:27:59 <sjanssen> dmhouse: and the O(n) stack thing
11:28:02 <ndm> if x then y:ys else ys ===> [y|x]++ys
11:28:06 <dmwit> Even worse... it's wrong, as dmhouse says. =P
11:28:11 <ndm> a much nicer and shorter way of writing it :)
11:28:19 <sjanssen> ndm: ooh, that's a nice one!
11:28:23 <dmhouse> ndm: nice idiom!
11:28:34 <ndm> sjanssen: Colin showed me that, Dr Haskell now automatically spots it
11:28:48 <ndm> (if Dr Haskell wasn't currently broken, it needs a Yhc.Core update)
11:29:01 <sjanssen> Haskell rox
11:29:58 <drigz> sjanssen: will the odds x:_:xs = x:odds xs one take O(n) stack?
11:30:10 <ndm> sjanssen: so you are getting funding from PSU for XMonad?
11:30:31 <ndm> sjanssen: or is it just XCB bindings (which you need for XMonad)
11:31:06 <dmhouse> ?src zip
11:31:07 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:31:07 <lambdabot> zip _      _      = []
11:32:26 <dmhouse> sjanssen: "you never want to be strict in a foldr's second argument"; You mean its first?
11:32:39 <dmhouse> Oh, the second argument to the function you pass to foldr, my bad.
11:32:49 <dmhouse> I thought you meant the second argument to foldr :)
11:35:20 <sjanssen> yeah, I was a bit unclear :)
11:35:52 <sjanssen> ndm: it's to write bindings to XCB.  However, in my proposal I said I'd port xmonad for "testing" purposes ;)
11:36:17 <sjanssen> drigz: nah, that will be O(1) stack
11:38:33 <ndm> sjanssen: cool, good luck :)
11:38:44 <fax> hey arent zip and foldl the same thing?
11:38:55 <fax> or well specific cases of somthing more general than both of them
11:38:55 <sjanssen> ndm: thanks
11:39:18 <sjanssen> fax: they're quite different
11:39:21 <sjanssen> @src zip
11:39:21 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:39:22 <lambdabot> zip _      _      = []
11:39:23 <sjanssen> @src foldl
11:39:24 <lambdabot> foldl f z xs = lgo z xs
11:39:24 <lambdabot>     where lgo z []     =  z
11:39:24 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
11:39:49 <sjanssen> foldl means "summarize a list to one value"
11:40:20 <sjanssen> zip means "make pairs of the elements of two lists in index order"
11:40:44 <chessguy_work> sjanssen: that's more of a general definition of fold, isn't it?
11:41:11 <sjanssen> chessguy_work: yeah
11:41:14 <fax> huh
11:41:17 <fax> why cant I do foldl (,) [1..5] ?
11:41:29 <chessguy_work> ?type foldl
11:41:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:41:44 <sjanssen> fax: that would require dependent types
11:41:46 <fax> ahh
11:43:32 <dmhouse> sjanssen: how would it work at all?
11:44:29 <sjanssen> dmhouse: it can't work in Haskell
11:44:58 <sjanssen> because the type of the result would depend on the value of the argument list
11:45:25 * monochrom builds ghc (today's release candidate) with -H64m -O -fasm to see if it's any faster.
11:45:58 <sjanssen> I don't actually know any dependently typed languages, so I can't demonstrate
11:46:13 <sjanssen> monochrom: seeing if the compiler is faster, or whether the build goes faster?
11:46:42 <sjanssen> the build will definitely go faster with -fasm, but will probably produce an executable that is slightly slower
11:47:04 <monochrom> whether the build is faster (than last time I built ghc 6.6 with all default flags)
11:47:21 <monochrom> err with all default mk/build.mk to be precise! :)
11:47:28 <sjanssen> should be way faster, like 1.5x or so
11:47:59 <monochrom> only 1.5x?  x_x  that will reduce 8 hours to maybe 5 hours...
11:49:05 <sjanssen> what does ghc usually compile with?
11:49:10 <sjanssen> -O3?
11:49:42 <monochrom> -H16m -O -fvia-C
11:50:53 <sjanssen> wow, did anybody catch Simon Marlow's "HEADS UP: Windows Vista users" email?
11:50:58 <monochrom> One can argue that 16m is too little for initial heap, leads to more gc and mallocs than necessary.  -fvia-C is a big cost.
11:51:28 <chessguy_work> sjanssen: yeah. typical windows crap
11:51:53 <sjanssen> chessguy_work: it's just totally stupid!  Matching against executable names to promote security?!
11:52:08 <chessguy_work> unbelievable
11:52:10 <mightybyte> sjannsen: No, what was the email about?
11:52:52 <drigz> : yeah. typical windows crap
11:53:03 <sjanssen> mightybyte: some dubious Vista security protection, look at the libraries mailing list for the subject line "HEADS UP: Windows Vista users"
11:53:11 <drigz> oops, sorry, drag-drop mistke
11:53:19 <mightybyte> Ok
11:53:30 <ski> foldr :: forall a (p :: [a] -> *). ((x :: a) -> (xs :: [a]) -> p xs -> p (x:xs)) -> p [] -> (xs0 :: [a]) -> p xs0   -- something like this, i think ..
11:55:17 <joelr1> how do you apply chainl1 in parsec?
11:55:18 <ndm> sjanssen: yeah, i saw that, its not great...
11:55:34 <sjanssen> ndm: do you run Vista yet?
11:55:47 <mightybyte> sjanssen: MS's brilliance astounds me
11:55:48 <ndm> sjanssen: it doesn't use it for security, it just uses it to guess at when a program might later require admin privilages, to stop being interuptted half way though
11:56:04 <ndm> sjanssen: nope, i much prefer XP, may have to upgrade when i get a new computer shortly
11:56:12 <sjanssen> ndm: that's just as bad, I'd say
11:56:19 <ndm> sjanssen: although am tempted to format and go back to XP, even with Vista pre-installed
11:56:29 <ndm> sjanssen: XP is pretty perfect
11:56:36 <sjanssen> ndm: aren't there plenty of programs that can install without admin privileges?
11:57:39 <sjanssen> especially silly is that you can rename the executable to sidestep the issue
12:00:10 <ndm> sjanssen: its fine, i always run as admin at home, and i rarely require admin at work - most programs install without it
12:09:11 <Igloo> :q
12:09:26 <sjanssen> #haskell is not vi
12:10:02 <merus> Oh, but if it were.
12:11:56 <Tene> :%s/sjanssen/prettypinkpenguin/g
12:12:18 <chessguy_work> @remember ndm XP is pretty perfect
12:12:18 <lambdabot> Done.
12:13:00 <ndm> @quote ndm
12:13:00 <lambdabot> ndm says: I guess the only thing to do is to trust that people who have learnt enough about monads and IO to hijack Haskell things probably realise how cool Haskell is...
12:13:08 <monochrom> I forgot to add -fasm to GhcLibHcOpts !!!
12:14:19 <monochrom> OTOH if I get to the library building stage this fast, it's already a good sign.
12:19:28 * monochrom modifies mk/build.mk concurrently with the build process!
12:20:25 <Igloo> If you just want to build GHC quickly then copy mk/build.mk.sample ro mk/build.mk and uncomment "BuildFlavour = quickest"
12:20:58 <monochrom> there is no such line
12:21:06 <monochrom> there is one with "devel"
12:21:11 <Igloo> Oh, that might be in the HEAD only
12:21:35 <Igloo> But if you grab a copy for the HEAD then I think it should still work with 6.6
12:21:45 <monochrom> yeah certainly.
12:31:23 <chessguy_work> ?where report
12:31:23 <lambdabot> http://www.haskell.org/onlinereport/
12:33:38 <vali> when i compile with ghc, i get a .hi-file in the same dir. what is that?
12:34:05 <monochrom> A summary of the .hs file
12:35:06 <chessguy_work> ?all-dict refractory
12:35:08 <lambdabot> *** "Refractory" gcide "The Collaborative International Dictionary of English v.0.48"
12:35:08 <lambdabot> Refractory \Re*frac"to*ry\ (-r?), a. [L. refractorius, fr.
12:35:08 <lambdabot>    refringere: cf. F. refractaire. See {Refract}.]
12:35:08 <lambdabot>    1. Obstinate in disobedience; contumacious; stubborn;
12:35:08 <lambdabot>       unmanageable; as, a refractory child; a refractory beast.
12:35:10 <lambdabot> [71 @more lines]
12:35:12 <monochrom> If you "import MyModule" then the compiler look for MyModule.hi and avoid a total re-compilation of MyModule.hs
12:35:18 <chessguy_work> heh, nice
12:35:57 <chessguy_work> @remember Haskell "Some half dozen persons have written technically on combinatory logic, and most of these, including ourselves, have published something erroneous. Since some of our fellow sinners are among the most careful and competent logicians on the contemporary scene, we regard this as evidence that the subject is refractory. " -- Haskell B. Curry
12:35:57 <lambdabot> Done.
12:36:47 <monochrom> haha
12:36:59 <LeCamarade> I have a BIG problem here that I can't seem to grok. I have a predicate that should help me filter stuff. But it has to sin with IO. So, it is in the IO monad, which I can't decosntruct (nope, uPIO was banned). How would you?
12:37:31 <sjanssen> LeCamarade: filterM
12:37:55 <monochrom> how did the predicate end up in IO?
12:37:59 <sjanssen> @type filterM
12:38:02 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:38:13 <sjanssen> filterM is filter lifted to monadic predicates
12:38:40 <LeCamarade> sjanssen: No, watch:
12:38:56 <LeCamarade> @type filterM
12:39:00 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:39:16 <LeCamarade> Oh, wait ... :oD
12:39:22 <monochrom> Let m be IO.
12:39:46 <dino-> LeCamarade: What's the type of your predicate function?
12:40:31 <LeCamarade> dino- : FilePath -> IO Bool. Directory.doesFileExist. I'm writing which(1) in Haskell.
12:40:41 <LeCamarade> Lemme dump, shall I?
12:40:50 <LeCamarade> Hp[aste, I mean.
12:40:57 <LeCamarade> Hpaste.
12:41:21 <Saizan> :t let f :: FilePath -> IO Boold; f = undefined in filterM f
12:41:24 <lambdabot> Not in scope: type constructor or class `Boold'
12:41:28 <Saizan> :t let f :: FilePath -> IO Bool; f = undefined in filterM f
12:41:31 <lambdabot> FilePath -> IO Bool; f = undefined in filterM f :: [FilePath] -> IO [FilePath]
12:43:41 <LeCamarade> Hold on, everyone. _Je pense que j'arrive a` la solution!'_
12:44:08 <dmhouse> LeCamarade: le yay!
12:44:13 <monochrom> Your pen has arrived at a solution?
12:44:23 <monochrom> Um, "le yay"??!!
12:44:37 <dmhouse> monochrom: franglais :)
12:46:00 <chessguy_work> he said he thinks he arrived at the solution
12:46:19 <LeCamarade> dmhouse: Le non!
12:46:24 <monochrom> Does -split-objs call gcc to do the job?
12:46:27 <dino-> alors
12:46:29 <dmhouse> LeCamarade: oh le dear.
12:46:46 <chessguy_work> it's actually very close to the spanish: Yo creo que he llegado a la solucion
12:47:16 <monochrom> and Latin too, of course.  They're all inspired by Latin.
12:47:24 <LeCamarade> dmhouse: Waittendre (i.e., wait ++ attendre) ... I think the answer is like close-by ...
12:48:05 <dmhouse> Not so close to the German: Ich glaube, ich habe die Lsung gefunden. :)
12:48:09 * LeCamarade thinks Haskell is the code equivalent of Ancient Koptic.
12:48:15 <dmwit> chessguy_work: And if you use pensar instead of creer, it's even closer...
12:48:27 <chessguy_work> oh whoops
12:48:28 <chessguy_work> haha
12:48:29 <monochrom> German was not inspired by Latin.
12:48:38 <chessguy_work> i thought "pienso" and wrote "creo"
12:49:12 <chessguy_work> (creo is how i would usually say it, but pienso is fine)
12:49:39 <LeCamarade> @src filterM
12:49:40 <lambdabot> Source not found. Do you think like you type?
12:49:51 <LeCamarade> ?src filterM
12:49:52 <lambdabot> Source not found. I feel much better now.
12:49:54 <Saizan> "penso che io sia arrivato alla soluzione" in a literal tranlation to italian :)
12:50:14 <LeCamarade> @src Monad.filterM
12:50:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:50:23 <LeCamarade> ?quote
12:50:24 <lambdabot> "no says: hacerle caso a br1"
12:50:26 <dmhouse> LeCamarade: I'm attendring. Let us savoir when you penser you avoir it.
12:51:13 <sjanssen> LeCamarade: @src has a length limit, filterM is probably too long
12:51:25 <LeCamarade> dmhouse: Oui, oui. Attendez un peu. I'll dire to tout le world quand je have got it.
12:51:41 <dmhouse> LeCamarade: no problme.
12:52:38 * LeCamarade envies dmhouse, parce que his keyboard n'a pas des accents, and there is aucune character map en Xfce.
12:52:53 <sjanssen> @type \p xs -> foldr (\y ys' -> do b <- p x; ys <- ys'; return (if b then y:ys else ys)) (return []) xs
12:52:56 <lambdabot> Not in scope: `x'
12:53:09 <sjanssen> @type \p xs -> foldr (\y ys' -> do b <- p y; ys <- ys'; return (if b then y:ys else ys)) (return []) xs
12:53:12 <lambdabot> forall (t :: * -> *) a. (Monad t) => (a -> t Bool) -> [a] -> t [a]
12:53:26 <sjanssen> LeCamarade: a definition of filterM ^^^
12:54:13 <chessguy_work> ?type foldr
12:54:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:54:20 <dmhouse> LeCamarade: ah, mon keyboard ne les a pas too, but si on use Linux then "AltGr+#, e" creates un accent.
12:55:03 <dmhouse> http://wiki.linuxquestions.org/wiki/Accented_Characters
12:55:04 <monochrom> Franglais is worse than Chinglish X_X
12:55:05 <lambdabot> Title: Accented Characters - LQWiki
12:55:12 <LeCamarade> dmhouse: Mais, mon keyboard doesn't avoir AltGr - seully Alt.
12:55:33 <dmhouse> Hehe, seully.
12:56:06 <LeCamarade> ?tiny http://wiki.linuxquestions.org/wiki/Accented_Characters
12:56:08 <lambdabot> http://tinyurl.com/ad2hn
12:56:39 <dino-> LeCamarade: So, you should be able to use your (FilePath -> IO Bool) with filterM to get :: [FilePath] -> IO [FilePath]
12:57:14 <LeCamarade> Yeah. I should. But now I am hitting other little type bugs on the side. I'll be done soon, I believe.
12:57:20 <chessguy_work> ?hoogle [(a,b)] -> ([a],b)
12:57:21 <lambdabot> No matches, try a more general search
12:57:43 <LeCamarade> dmhouse: Sans AltGr, what can-je utiliser?
12:58:41 <dmhouse> LeCamarade: je sais pas. So you have neither a French keyboard nor an AltGr key?
12:58:43 <araujo> :-)
12:58:45 <araujo> hello
12:59:04 * LeCamarade thinks dons wouldn't have let this Franglish claptrap go on for longer than four microseconds and six picoseconds and twelve smaller units.
12:59:36 <dmhouse> You might be able to bind a different key to the AltGr modifier.
12:59:48 <LeCamarade> Comment?
13:00:38 <LeCamarade> This keyboard is true brain damage. But as long as I can write unsafePerformIO with it, my faith is not shaken.
13:00:55 <cod3po37> Is there anyone here familiar with HAppS and or the OS X Intel version of GHC 6.6? I'm having some compiling difficulties I did not have on OS X PowerPC and I'm looking for some help.
13:01:23 <dmhouse> :) I'm not sure, you might be lucky and have some setting within your WM control panel that you can set it. Otherwise, you want to start playing around with xmodmap, I think. Try man xmodmap.
13:01:30 <LeCamarade> These days I start to shiver when I discover I have neither ghci nor hugs on the machine.
13:02:29 <LeCamarade> Gotta go.
13:02:37 <LeCamarade> Without finishing which(1)!
13:02:45 <LeCamarade> @time LeCamarade
13:02:47 <lambdabot> Local time for LeCamarade is Thu Apr 12 23:01:58 2007
13:02:49 <sjanssen> cod3po37: ask away
13:03:26 <LeCamarade> See? Should be sleeping. And I'm still at the office. Gotta run. Have about a kilometre to walk. Blame Haskell for keeping me here.
13:03:44 <LeCamarade> The Haskell report doesn't mention potential damange to social life. We should sue.
13:03:48 * dmhouse is going to dash, House is on
13:04:29 <cod3po37> when I try to compile HAppS 0.8.8 using GHC 6.6 for OS X Intel, using ./Setup.hs build, it only gets to step [69 of 72] and then it start linking but it never generates HAppS.hi and so the ./Setup.hs install step fails...can't figure out why...all of the dependencies are satisfied.
13:05:28 <monochrom> When has sleeping become part of social life?
13:06:46 <sjanssen> @seen dons
13:06:47 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 7h 34m 11s ago.
13:06:51 <sjanssen> @localtime dons
13:06:54 <lambdabot> Local time for dons is Fri Apr 13 06:06:04 2007
13:08:54 <cod3po37> sjanssen: would it help if I pasted the compilation output?
13:10:08 <sjanssen> cod3po37: sure
13:10:09 <Saizan> cod3po37, yeah
13:10:18 <Saizan> !paste
13:10:18 <hpaste> Haskell paste bin: http://hpaste.org/
13:11:34 <hpaste>  cod3po37 pasted "compiling HAppS 0.8.8 on OS X Intel" at http://hpaste.org/1360
13:11:44 <joelr1> :t collect
13:11:46 <lambdabot> forall a b. (Testable b, Show a) => a -> b -> Property
13:11:51 <joelr1> ugh
13:12:31 <Saizan> cod3po37, annotate the rest, hpaste truncates at 5000 chars
13:12:40 <cod3po37> yeah. I just noticed that.
13:13:47 <hpaste>  cod3po37 annotated "compiling HAppS 0.8.8 on OS X Intel" with "Compiling HAppS 0.8.8 on OS X Intel" at http://hpaste.org/1360#a1
13:13:49 <sjanssen> @tell glguy might be nice to bump the paste limit up a bit, http://hpaste.org/1360 ran into this problem
13:13:50 <lambdabot> Consider it noted.
13:14:17 <sjanssen> again with the truncating :(
13:14:38 <joelr1> how do i apply a list o functions to a list?
13:14:46 <hpaste>  cod3po37 annotated "compiling HAppS 0.8.8 on OS X Intel" with "Compiling HAppS 0.8.8 on OS X Intel" at http://hpaste.org/1360#a2
13:14:58 <joelr1> is there some zipWith combo?
13:15:01 <nominolo> joelr1: using the list monad
13:15:06 <glguy> ap
13:15:06 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:15:09 <joelr1> ah! comprehensions!
13:15:18 <glguy> > [ succ , pred ] `ap` [1..5]
13:15:20 <lambdabot>  [2,3,4,5,6,0,1,2,3,4]
13:15:22 <hpaste>  cod3po37 annotated "compiling HAppS 0.8.8 on OS X Intel" with "Compiling HAppS 0.8.8 on OS X Intel" at http://hpaste.org/1360#a3
13:15:22 <Saizan> cod3po37,  does it give an error in the end?
13:15:28 <nominolo> :t ap
13:15:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:15:35 <icarroll> joelr1: [(f x) | f <- fs, x <- xs]
13:15:45 <joelr1> icarroll: yeah!
13:15:50 <icarroll> oops, don't need parens
13:15:50 <glguy> bah!
13:15:53 <glguy> ap
13:16:06 <cod3po37> saizan: it just sort of stops at [69 of 72] and continues on but if I go to ./Setup.hs install, I get an error.
13:16:09 <dmwit> joelr1: ap is more mysterious, use that instead!
13:16:14 <joelr1> hehe
13:16:20 <glguy> that's exactly what ap is for :-p
13:16:27 <joelr1> comprehensions are more elegant as i need to generate my list of functions first
13:16:35 <glguy> given a computation containing functiosn, and one containing data, apply the functions to the data
13:16:48 <sjanssen> cod3po37: yeah, that's weird
13:16:52 <dmwit> Yeah, I agree it's the right thing.
13:16:55 <hpaste>  cod3po37 annotated "compiling HAppS 0.8.8 on OS X Intel" with "Compiling HAppS 0.8.8 on OS X Intel" at http://hpaste.org/1360#a4
13:17:17 <sjanssen> the "Loading package" stuff doesn't usually appear in the build stage
13:17:50 <Saizan> cod3po37, is this a realesed or darcs version?
13:17:51 <hpaste>  icarroll pasted "monomorphism restriction?" at http://hpaste.org/1361
13:18:00 <cod3po37> saizan: darcs
13:18:58 <Cale> icarroll: hmm, can we see more of the file?
13:18:59 <lambdabot> Cale: You have 4 new messages. '/msg lambdabot @messages' to read them.
13:19:02 <Cale> whoa
13:19:27 <icarroll> Cale: ok 1 sec
13:20:54 <Saizan> cod3po37, i've started a build
13:21:14 <cod3po37> saizan: cool, thanks.
13:23:05 <hpaste>  icarroll annotated "monomorphism restriction?" with "maybe more useful" at http://hpaste.org/1361#a1
13:25:06 <monochrom> 1st-rank polymorphism at work.
13:25:54 <monochrom> It is the problem as:  (\f -> (f True, f 'a')) id    will not work
13:26:08 <monochrom> > (\f -> (f True, f 'a')) id
13:26:09 <lambdabot>  Couldn't match expected type `Char' against inferred type `Bool'
13:26:34 <monochrom> You need 2nd-rank polymorphism if you want that to work.
13:27:19 <icarroll> so, when will haskell' be ready? :)
13:27:41 <sek> if i'm working with very large floats, what type should i use?
13:27:49 <Saizan> ?type succ
13:27:49 <monochrom> The type signature of (\f -> (f True, f 'a')) is going to be:  (forall a. a->a) -> (Bool,Char).  (Note that it is not: forall a. (a->a)->(Bool,Char))
13:27:54 <lambdabot> forall a. (Enum a) => a -> a
13:28:09 <samx_> I'm trying to use hxt to get nodes from an xml document, but stumbling to a problem, that if the document has a node with no content (say "<Name></Name>"), getText arrow will fail. Instead or failing, I'd like to get an empty String. Any idea how I could do that?
13:28:21 <monochrom> 2nd-rank polymorphism is available now in most haskell compilers
13:28:27 <Saizan> > let f :: Enum a => a -> a; f = succ in (succ 1, succ 'a')
13:28:28 <lambdabot>  (2,'b')
13:28:38 <Saizan> > let f :: Enum a => a -> a; f = succ in (f 1, f 'a')
13:28:40 <lambdabot>  (2,'b')
13:28:59 <Saizan> you just need to write the typesign yourself, right?
13:29:09 <dmwit> Saizan: No, that's different.
13:29:12 <monochrom> Try it on (\f -> (f True, f 'a'))
13:29:24 <dmwit> There you have two different copies of f, in monochrom's version you have only one.
13:30:16 <icarroll> monochrom: Thanks for the explanation. What's the simplest way to get my code to work in GHC?
13:30:18 <monochrom> Recall that do { f <- ...; ...f...} is desugared to ... >>= \f -> ...f...   "let" has nothing to do with it.
13:30:18 <dmwit> > let f :: Enum a => a -> a; f = succ in (\x -> (x 1, x 'a')) f
13:30:20 <lambdabot>   add an instance declaration for (Num Char)
13:31:20 <Saizan> yeah lambda bindings are monomorphic
13:31:44 <monochrom> processing
13:32:02 <dino-> samx_: Hm. I'm shake with hxt, but I wonder if hasText could be used in some way..
13:32:05 <dino-> s/shake/shaky/
13:32:30 <Saizan> samx_ there's someting like withDefault in the ArrowList class
13:33:21 <dino-> Saizan: Oh, I bet that will do it.
13:33:41 <Saizan> cod3po37, the build went fine here :\
13:34:12 <cod3po37> saizan: what installation of GHC do you have? MacPorts or Audrey Tang version?
13:34:16 <samx_> saizan, I think withDefault did the job. thanks
13:35:29 <cod3po37> saizan: can you also paste your configuration step so I can compare it to mine?
13:35:51 <Saizan> ehm, i'm on x86, just tried to help because i have the sources handy
13:36:37 <cod3po37> saizan: you're not on OS X?
13:36:58 <Saizan> no...
13:38:13 <cod3po37> saizan: ah. well, at least I know that it should compile. I haven't had any trouble with my GHC version for anything else. I can't think of what it would be.
13:38:15 <sek> if i'm forcing haskell to do a division of very large integers, and i know that the result will be an integer, what can i do to force the resulting type to be a Num (or whatever is neccesary for very large integers)
13:39:00 <icarroll> sek: a `div` b
13:39:28 <emu> :t div
13:39:31 <lambdabot> forall a. (Integral a) => a -> a -> a
13:39:31 <sek> oh ofcourse
13:39:35 <emu> :t (/)
13:39:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:39:56 <drigz> :t (//)
13:39:59 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
13:40:04 <drigz> damn
13:40:05 <emu> that's array update
13:40:12 <cod3po37> I guess the broader question is, is anyone else here using GHC 6.6 on OS X Intel and have they noticed any problems with it compiling projects?
13:40:18 <drigz> i couldn't remember if it was // or \\
13:40:26 <emu> \\ is set-minus
13:40:26 <drigz> :t (\\)
13:40:29 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:40:46 <cod3po37> (and which source for GHC are they using on OS X Intel?)
13:41:15 <drigz> why doesn't lambdabot respond to :t in /msg?
13:41:18 <drigz> :src (\\)
13:41:32 <emu> try @src
13:41:54 <emu> i think the only reason it responds to :t in chat is because ghci users may type it in without thinking
13:42:37 <drigz> ok
13:42:51 <drigz> is there an equivalent @ command?
13:43:25 <emu> @src (\\)
13:43:26 <lambdabot> (\\) = foldl (flip delete)
13:43:47 <emu> @type (\\)
13:43:50 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:44:22 <drigz> ah. could have thought of that one on my own, really :s
13:45:38 <drigz> thanks
13:47:46 <lokamr> how would i pass a function as an argument?,
13:48:13 <drigz> lokamr: like you'd pass any value
13:48:17 <dmwit> > let modify f = f . (+1) in modify (*2)
13:48:18 <lambdabot>  <Integer -> Integer>
13:48:33 <dmwit> > let modify f = f . (+1) in modify (*2) 3
13:48:35 <lambdabot>  8
13:48:38 <icarroll> @src map
13:48:39 <lambdabot> map _ []     = []
13:48:39 <lambdabot> map f (x:xs) = f x : map f xs
13:49:17 <cod3po37> saizan: do you still have the compilation window open? can you tell me what the missing steps are?
13:49:27 <lokamr> .ua discovery
13:49:35 <cod3po37> ie, [70 of 72], [71 of 72]...?
13:50:34 <sek> icarroll, as a follow up question: If i have 2 very large Integral numbers, how can i divide them and round the result to the closest integer? div seems to round down when i use it
13:50:45 <dmwit> > let runs n [] = []; runs n xs = take n xs : runs n (tail xs) in runs 5 [1..6]
13:50:47 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6]]
13:51:44 <drigz> sek: (a + (b `div` 2)) `div` 2 for integer division (excluding fencepost errors
13:51:57 <drigz> and replace the last 2 with a b
13:52:08 <Cale> > let runs n = map (take n) . tails in runs 5 [1..6]
13:52:10 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6],[]]
13:52:24 <ski> > init . tails $ [1..6]
13:52:25 <lambdabot>  [[1,2,3,4,5,6],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6]]
13:52:37 <dmwit> :t init
13:52:39 <Cale> Not quite the same
13:52:39 <lambdabot> forall a. [a] -> [a]
13:52:52 <Cale> init just drops the last element
13:52:53 <dmwit> > init [3,4,5]
13:52:55 <lambdabot>  [3,4]
13:53:44 <dmwit> tails is useful though
13:54:12 <icarroll> sek: use divMod, and use the "mod" portion to round
13:55:12 <dmwit> I'd prefer not to have the "short ones" at the end.  Let's see.
13:55:38 <dmwit> > let runs n = filter ((== n) . length) . map (take n) . tails in runs 5 [1..6]
13:55:40 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6]]
13:56:07 <dmwit> ?index tails
13:56:08 <lambdabot> Data.List
13:56:17 <sek> icarroll, so if the snd of the tuple is greater than half of the b (when i call divMod a b) then i round up?
13:56:17 <ski> > let runs n = tail . takeWhile (not . null) . iterate (take (n+1) . tail) . (undefined:) in runs 5 [1..6]  -- hm, a bit ugly
13:56:19 <lambdabot>  [[1,2,3,4,5,6],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6]]
13:56:56 <Cale> ski: also, doesn't seem to be working
13:57:03 <drigz> > let runs n = map (take n) . drop n . inits in runs 5 [1..6]
13:57:05 <lambdabot>  [[1,2,3,4,5],[1,2,3,4,5]]
13:57:07 <icarroll> sek: sounds reasonable to me
13:57:17 <sek> icarroll, drigz, many thanks
13:57:37 <dmwit> > take n []
13:57:38 <lambdabot>   Not in scope: `n'
13:57:41 <dmwit> > take 3 []
13:57:43 <lambdabot>  []
13:57:43 <ski> Cale : maybe i should first figure out what is sought after :)
13:58:05 <dmwit> >inits [1..3]
13:58:08 <dmwit> > inits [1..3]
13:58:10 <lambdabot>  [[],[1],[1,2],[1,2,3]]
13:58:11 <drigz> > let runs n = map (take n) . drop n . reverse . tails in runs 5 [1..6]
13:58:12 <lambdabot>  [[2,3,4,5,6],[1,2,3,4,5]]
13:58:21 <Cale> > let runs n [] = []; runs n xs = take n xs : runs n (tail xs) in runs 3 [1..6]
13:58:23 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6],[6]]
13:58:46 <dmwit> I like drigz's version a lot.
13:59:04 <dmwit> (If only it worked. =)
13:59:08 <Cale> that was the original bit of code, though it seems that dmwit doesn't want the partial ones at the end
13:59:57 <bd_> Sounds like a job for a comonad... :)
14:00:17 <drigz> @hoogle (a -> b) -> a -> b
14:00:19 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
14:00:19 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
14:00:19 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
14:00:26 <drigz> maybe too vague...
14:00:30 <ski> bd_ : which ?
14:00:31 <dmwit> Aw, crap, I just recently finally began understanding regular monads...
14:00:31 <drigz> @hoogle repeat
14:00:33 <lambdabot> Prelude.repeat :: a -> [a]
14:00:40 <bd_> runs n = (=>> (take n)), right?
14:00:53 <bd_> hm wait
14:00:57 <bd_> is list a comonad?
14:00:59 <dmwit> :t (=>>)
14:01:01 <lambdabot> Not in scope: `=>>'
14:01:06 <bd_> http://www.haskell.org/hawiki/CoMonad
14:01:08 <lambdabot> Title: CoMonad - The Haskell Wiki
14:01:24 <ski> bd_ : which comonad, i meant ?
14:01:52 <ski> bd_ : non-empty-list is a comonad
14:02:00 <bd_> ski: I'm wondering if list can be made into a comonad, with cojoin = tails...
14:02:19 <bd_> ah
14:02:32 <ski> stream is a comonad, with 'split = tails'
14:02:45 <bd_> runs n = filter ((== n).length) (=>> (take n)) -- something like this?
14:02:56 <drigz> @hoogle iterate
14:02:57 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
14:03:08 <sek> icarroll, sorry, last thing: i'm calling divMod a b     and its giving me Could not deduce (Integral (t, b)) from the context (Integral t)
14:03:40 <bd_> sek: divMod returns a pair of values - are you trying to use it as a single value?
14:03:45 <bd_> > divMod 5 3
14:03:47 <lambdabot>  (1,2)
14:03:53 <ski> bd_ : '(=>> (take n))' is a function, you can't filter that
14:03:57 <sek> i pass it to fst and snd
14:04:09 <bd_> ski: er, filter ((== n).length) . (=>> (take n))
14:04:35 <sek> oh crap, i see my error now. nm
14:05:32 <ski> NonEmptyList.split [3,2,1,0] = [[3,2,1,0],[2,1,0],[1,0],[0]]
14:06:37 <dmhouse> ?hoogle (=>>) -- is this the comonadic bind?
14:06:38 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- is this'
14:06:45 <dmhouse> ?hoogle (=>>)
14:06:46 <lambdabot> Did you mean: (=>>)
14:06:47 <lambdabot> Prelude.undefined :: a
14:06:47 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:07:01 <bd_> dmhouse: It's not in the standard libraries.
14:07:07 <ski> dmhouse : no it is the comonadic cobind (i call it 'preserve')
14:07:37 <dmhouse> ?tell ndm http://haskell.org/hoogle/?q=%28%3D%3E%3E%29 very weird hoogle results
14:07:38 <lambdabot> Consider it noted.
14:07:59 <bd_> http://www.haskell.org/hawiki/CoMonad <-- this class really should be defined in terms of Functor and cojoin :)
14:08:00 <lambdabot> Title: CoMonad - The Haskell Wiki
14:08:24 <ski> http://www.eyrie.org/~zednenem/2004/hsce/
14:08:24 <dmhouse> *Sigh* Why isn't join in the Monad class?
14:09:45 <bd_> presumably the haskell98 drafters thought defining monad in terms of return and >>= would be more common, and thus gave easy defaults for that case
14:09:49 <hpaste>  sek pasted "(no title)" at http://hpaste.org/1362
14:10:07 <ski> [1,2,3,4,5,6] =>> take 4  =  map (ta5C5Cke 4) (split [1,2,3,4,5,6])  =  map (take 4) [[1,2,3,4,5,6],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6]]  =  [take 4 [1,2,3,4,5,6],take 4 [2,3,4,5,6],take 4 [3,4,5,6],take 4 [4,5,6],take 4 [5,6],take 4 [6]]  =  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6],[5,6],[6]]
14:10:32 <twanvl> Also, if you want a monad based on join, Functor has to be a superclass
14:10:52 <ski> filter ((== 4) . length) [1,2,3,4,5,6] =>> take 4  =  [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
14:10:52 <bd_> twanvl: it really should be, though :)
14:11:02 <twanvl> of course
14:11:12 <twanvl> Well, not directly, via Applicative
14:11:14 <samx_> another hxt problem.. "getChildren >>> (hasName "foo" &&& hasName "bar")" returns an empty list, but "((getChildren >>> hasName "foo") &&& (getChildren >>> hasName "bar"))" returns a list with a number of elements. Shouldn't those two be equivalent?
14:11:24 <dmwit> ?hoogle Int -> a -> [a]
14:11:25 <lambdabot> Prelude.replicate :: Int -> a -> [a]
14:11:44 <drigz> ?hoogle compose
14:11:45 <lambdabot> No matches found
14:12:00 <drigz> is there a function that repeats a function n times?
14:12:03 <ski> bd_ : but i think one should be about to do this more directly with 'takeM :: Integral i => i -> [a] -> Maybe [a]' using 'StreamT Maybe'
14:12:22 <bd_> StreamT?
14:12:25 <drigz> like foldl (.) id . replicate
14:12:26 <bd_> @hoogle StreamT
14:12:27 <lambdabot> No matches found
14:12:42 <dmwit> :t all
14:12:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:12:53 <Saizan> samx_, got tricked by that too, getChildren is really a misleading name, it's more like you are only getting a child at a time, so it cannot both have name "foo" and "bar"
14:12:55 <dmhouse> bd_: you could have both (>>=) and join in the class, though, and define them within the class in terms of one another.
14:13:04 <dmwit> ?hoogle [Bool] -> Bool
14:13:05 <lambdabot> Prelude.and :: [Bool] -> Bool
14:13:05 <lambdabot> Prelude.or :: [Bool] -> Bool
14:13:13 <bd_> dmhouse: true, and you can have instance Functor foo where fmap = liftM
14:13:28 <samx_> saizan, oh, i see. thanks again
14:13:29 <ski> data StreamT f a = Cons a (f (StreamT f a))
14:13:55 <drigz> would init . init ... init (to drop the last n elements of a list) be O(n^2), or would the compiler work out what you were doing?
14:14:19 <thedward> @src iterate
14:14:19 <lambdabot> iterate f x =  x : iterate f (f x)
14:14:38 <bd_> drigz: Why would it be n^2? I'd think that'd be O(mn)...
14:14:39 <hpaste>  dmhouse pasted "Ideal Monad class" at http://hpaste.org/1363
14:14:49 <dmhouse> bd_, that'd be my ideal Monad class
14:14:50 <dmwit> > let dropLast n = reverse . drop n . reverse in dropLast 6 "hi there world"
14:14:51 <lambdabot>  "hi there"
14:15:15 <dmhouse> ski: difference between two sequences in what way? The symmetric difference/
14:15:22 <dmwit> ?hoogle [a] -> [a]
14:15:24 <lambdabot> Prelude.cycle :: [a] -> [a]
14:15:24 <lambdabot> Prelude.init :: [a] -> [a]
14:15:24 <lambdabot> Prelude.reverse :: [a] -> [a]
14:15:28 <ski> dmhouse : no, like '(\\)'
14:15:36 <ski> but
14:15:49 <hpaste>  Saizan annotated "Ideal Monad class" with "more versatile monad class" at http://hpaste.org/1363#a1
14:15:56 <drigz> bd_: yeah, that's clearer
14:15:59 <ski> > [0..] \\ [1,3..]  -- this doesn't work, but works with '`diff`' instead
14:16:03 <lambdabot> Terminated
14:16:19 <drigz> @src (\\)
14:16:20 <lambdabot> (\\) = foldl (flip delete)
14:16:53 <drigz> @src diff
14:16:53 <lambdabot> Source not found. I feel much better now.
14:17:06 <dmhouse> ski, and it should return [0, 2, 4, 6, ... ]?
14:17:08 <hpaste>  monochrom annotated "monomorphism restriction?" with "solution" at http://hpaste.org/1361#a2
14:17:18 <monochrom> that's for icarroll
14:17:24 <ski> Saizan : except that we'd like to define the default for 'fmap' inside that
14:17:28 <ski> dmhouse : yes
14:17:51 <dmhouse> ski: and does it assume the lists are sorted in ascending order?
14:18:04 <ski> s/Saizan/dmhouse/
14:18:10 <icarroll> monochrom: thanks
14:18:27 <ski> Saizan : i don't think that version makes very much sense ..
14:18:28 <dmhouse> ski: is that possible?
14:18:37 <ski> dmhouse : yes and yes
14:18:48 <dmhouse> Saizan: err, doesn't look like a monad to me.
14:19:03 <Saizan> ski: you could make Data.Set a monad with that class
14:21:09 * ski thinks it would be "monad" only in name
14:21:30 <icarroll> monochrom++
14:21:41 <stepcut> Saizan: does that actually work? This page claims it does not type-check (i think) -> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
14:21:43 <dmhouse> Saizan: you could probably make a whole load of things that shouldn't be monads monads with that class, to.
14:21:44 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
14:21:52 <drigz> icarroll: that's not a very haskell thing to say :p
14:22:06 <dmhouse> drigz: works with Lambdabot's karma counter, though :)
14:22:09 <icarroll> drigz++-- :)
14:22:14 <icarroll> @karma drigz
14:22:15 <lambdabot> drigz has a karma of 0
14:22:31 <dmhouse> ?karma drigz++
14:22:32 <lambdabot> drigz++ has a karma of -1
14:22:35 <Saizan> dmhouse, that's true, you don't force return and >>= to be "natural"
14:22:46 <icarroll> :)
14:23:33 <Saizan> stepcut, with the standard Monad class you can't make Data.Set a monad
14:23:47 <stepcut> Saizan: right
14:23:48 <icarroll> unsafePerformKarma (modifyKarmaRef monochrom (+1))
14:24:10 <dmhouse> succ monochrom
14:24:21 <stepcut> Saizan: but, according to that page, the monad class you proposed won't type-check
14:24:40 <Saizan> someone almost got there using a GADT which is a hybrid with []
14:24:47 <drigz> dmhouse: that kinda sounds like you want to thank him in a really special way
14:24:51 <dmhouse> stepcut: the reason is a technical one; sets do form monads, and it's a weakness in Haskell's type system that Data.Set can't be a monad.
14:25:33 <stepcut> dmhouse: yes, I understand that
14:25:43 <eumenides> when i do a client/server example, why do i only get output when the client disconnects?
14:26:49 <Saizan> stecut: uhm i see, but i'm not totally convinced
14:27:38 <dmhouse> Saizan: why not?
14:28:01 <dmhouse> Say you had instance Monad Foo Int Float, and instance Monad Foo Int Bool.
14:28:32 <dmhouse> And imagine you're using return :: Int -> Foo Int, you can't tell whether to pull the definition of return out of the first instance or the second instance.
14:29:20 <hpaste>  eumenides pasted "client/server" at http://hpaste.org/1364
14:29:29 <eumenides> is there something wrong with that code?
14:29:35 <stepcut> Saizan: well... can you get your Monad to pass the type-checker ?
14:29:55 <Saizan> stepcut: i have used a very similar Comonad class in my code
14:30:23 <stepcut> Saizan: the version on hpaste does not type check for me
14:30:45 * stepcut checks to make sure he didn't make a mistake
14:31:08 <glguy> Set would make for a lousy monad, all of your monadic functiosn would have to return instances of Ord and when would duplicates be eliminteated?
14:31:13 <glguy> eliminated*
14:32:40 <stepcut> glguy: perhaps, but the idea of being able to restrict monad or arrow instances to types that are in (Read, Show) is pretty useful
14:34:36 <Saizan> glguy: inside >>=
14:34:52 <glguy> maybe not allowing any constraints on the return types, you are guarenteed that the Monad isn't adjusting its behavior based on the return value
14:34:56 <glguy> you know that it can't see it
14:34:57 <Saizan> like (>>=) = nub . concatMap
14:35:12 <glguy> Saizan: right, but a monad shouldn't be able to know what its holder
14:35:30 <glguy> holding*
14:35:50 <glguy> and alter its behavior on that
14:36:03 <glguy> that's one of the things that the type system guarentees for you
14:36:05 <dmwit> ?index fromJust
14:36:05 <lambdabot> Data.Maybe
14:37:15 <Saizan> glguy: yes, but Set is a monad that we can't have only because it's not defined on every type, but it won't treat differently the types for which is defined
14:37:40 <glguy> and because its behavior would depend on the results of the monadic functions
14:37:55 <glguy> certain paths might not be followed because such a path created a duplicate result
14:38:28 <glguy> the reason that that would be possible is that the monad would have knowledge of the results it was handling
14:38:32 <glguy> which it should not be able to do
14:38:34 <Saizan> well in the list monad certain apths are not followed becayse they create a []
14:38:38 <dmwit> ?hoogle [a] -> [a] -> Int
14:38:39 <lambdabot> No matches, try a more general search
14:38:43 <hpaste>  stepcut annotated "Ideal Monad class" with "Monad fails to type-check" at http://hpaste.org/1363#a2
14:38:46 <glguy> Saizan: sure, but not because of the list monad
14:39:02 <Saizan> of what?
14:39:02 <glguy> looking at the results
14:39:11 <dmwit> ?hoogle (Eq a, Num b) => [a] -> [a] -> b
14:39:12 <lambdabot> No matches, try a more general search
14:39:26 <glguy> that behavior is due only to the monad, and not the monad looking at results of monadic functions
14:39:28 <dmwit> ?hoogle substring
14:39:29 <lambdabot> No matches found
14:39:47 <dobblego> ?hoogle nub
14:39:48 <lambdabot> List.nub :: Eq a => [a] -> [a]
14:39:48 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
14:39:53 <Saizan> what do you mean by monadic functions?
14:40:06 <glguy> ?type map succ
14:40:09 <lambdabot> forall a. (Enum a) => [a] -> [a]
14:40:19 <glguy> or
14:40:20 <glguy> rather
14:40:23 <glguy> ?type [ () ]
14:40:25 <lambdabot> [()]
14:40:37 <glguy> [ ] being the monad
14:40:47 <glguy> If you allowed what you guys are discussing, this could be legal:
14:41:01 <glguy> [ 1..10 ] >>= \x -> [x]
14:41:03 <glguy> returning
14:41:08 <glguy> [1,2,3,7,8,9]
14:41:17 <glguy> assuming not the standard list monad
14:41:30 <stepcut> glguy: are you sure that does not violate a monad law ?
14:41:50 <dmwit> \x -> [x] === return, so I'm fairly sure it does...
14:42:03 <DRMacIver> Hm. Oops. I made a goof in my interview earlier. (I said Set was a monad)
14:42:35 <stepcut> whoa, another San Diego haskell hacker
14:42:36 <glguy> so that specific example doesn't hold for the laws, but if you can't see where this is going I can't take you any further
14:43:05 <dmwit> yeah
14:43:16 <Saizan> glguy: i'm conscius that you lose some type guarantee of >>= and return being well defined, so that they don't "cheat" on special types/values
14:43:32 <gFunk_> hello
14:43:45 <Saizan> but a Set is indeed a monad, the laws hold
14:43:46 <glguy> Saizan: which is what set does
14:43:51 <sjanssen> isn't it the responsibility of the author to make sure that monad laws hold?
14:44:03 <gFunk_> does anyone know, is Stringable restricted to characters?
14:44:03 <sjanssen> we can already write plenty of non-sensical monads
14:44:11 <glguy> so.... in the Set monad:
14:44:24 <sjanssen> gFunk_: referring to the prototype implementation in fps-soc?
14:44:30 <glguy> fromList [ 1..10 ] >>= \x -> singleton x
14:44:31 <gFunk_> yes
14:44:35 <glguy> err
14:44:36 <glguy> fromList [ 1..10 ] >>= \x -> singleton 1
14:44:39 <sjanssen> gFunk_: yes, that version is Char only
14:44:48 <glguy> would return: fromList [ 1 ]
14:44:58 <Saizan> sure
14:44:58 <gFunk_> sjanssen: do you know why?
14:45:08 <dmwit> > mempty :: []
14:45:09 <lambdabot>      `[]' is not applied to enough type arguments
14:45:09 <lambdabot>     Expected kind `?', but ...
14:45:16 <dmwit> > mempty :: [Int]
14:45:17 <lambdabot>  []
14:45:26 <dmwit> ?src MonadPlus
14:45:27 <lambdabot> Source not found. I feel much better now.
14:45:44 <icarroll> @hoogle (a->b,c->d) -> (a,c) -> (b,d)
14:45:45 <lambdabot> No matches, try a more general search
14:45:49 <sjanssen> gFunk_: because Strings are sequences of Char
14:45:49 <dmwit> > mzero :: [Int]
14:45:51 <lambdabot>  []
14:45:58 <hpaste>  manu pasted "test monad laws" at http://hpaste.org/1365
14:46:12 <sjanssen> gFunk_: to write a more generic Sequence type class, you need extensions (MPTC, fundeps)
14:46:33 <manu_> who knows how to generate arbitrary data of type :: Tree a
14:47:03 <manu_> I'm trying to test the monad laws for a Tree type made into a monad
14:47:17 <manu_> (personnal challenge)
14:47:49 <gFunk_> sjanssen: okay, thanks
14:48:02 <manu_> i get : Not in scope: `tree'... so far :(
14:48:10 <stepcut> glguy: is that a statement or a question?
14:48:34 <glguy> that it would return that? a statement
14:49:12 <stepcut> glguy: ok. Do you consider that statement to be a problem ?
14:49:22 <glguy> hadn't decided yet :)
14:49:30 <manu_> anybody savvy with QuickCheck.... ?
14:49:32 <stepcut> glguy: it seems like the right answer to me
14:50:47 <stepcut> manu_: I think your prop_fmap_1 is wrong
14:51:14 <manu_> stepcut : in what way ?
14:51:15 * stepcut tries to remember how you do that in QuickCheck
14:53:05 <manu_> i lifted the QuickCheck code from the documentation but it is originally for  Tree datatype and not  Tree a...
14:53:50 <stepcut> manu_: ah, found it
14:54:01 <stepcut> prop_fmap_1 tree =
14:54:10 <stepcut> you need to pass tree in as an arguement
14:54:30 <stepcut> if you look in the examples, you will see they pass in 'xs' as an argument
14:54:47 <manu_> stepcut : bloody right !!! Jesus I should go to bed
14:54:52 <stepcut> manu_: :p
14:54:56 <manu_> Thanks
14:54:59 <stepcut> no problem
14:56:45 <glguy> well, if Oleg doesn't have a problem with it, i guess I don't
14:57:59 <Saizan> :D
15:01:15 <Saizan> oleg could go mad one day trying to prove the existence of god in the type system and we'll start having wrong monads..
15:02:38 <dmhouse> Saizan: the scary thing is, Oleg could probably do it, given enough functional dependencies.
15:06:48 <SamB_XP_> what type is the existance of god?
15:07:10 <Saizan> what? prove the existence of god using the type system or proving that there's a god in it?:D
15:07:21 <ski> "But in simple substances the influence of one Monad upon another is only ideal, and it can have its effect only through the mediation of God, in so far as in the ideas of God any Monad rightly claims that God, in regulating the others from the beginning of things, should have regard to it. For since one created Monad cannot have any physical influence upon the inner being of another, it is only by this means that the one can
15:07:27 <icarroll> SamB_XP_: forall a. b
15:07:51 <Saizan> ski: Laibniz?
15:07:56 <Saizan> *Leibniz
15:08:11 <ski> http://www.rbjones.com/rbjpub/philos/classics/leibniz/monad.htm
15:08:13 <lambdabot> Title: THE MONADOLOGY
15:09:06 <SamB_XP_> @src StateT
15:09:06 <lambdabot> Source not found. You type like i drive.
15:09:32 <Saizan> we should link this in All About Monads, then the newbies would really get scared
15:09:35 <ski> (hmm "For since one created Monad cannot have any physical influence upon the inner being of another" appears to refer to some naturalness (parametricity) condition ..)
15:10:06 <bjornbm> Hi all. I believe there is a tool that can automatically generate export lists for everything in a module. Can anyone give pointers?
15:10:21 <Saizan> nah, it clearly refers to monad transformers
15:10:51 <ski> newtype StateT s m a = StateT {runStateT :: s -> m (a,s)}
15:11:10 <Saizan> bjornbm, you mean something like haddock?
15:12:00 <ski> (Saizan : and surely that is a natualness condition of the transformer ?)
15:13:10 <Saizan> (ski: uhm yeah, wasn't thinking of that)
15:13:14 <bjornbm> Saizan : I haddock does that then yes. Thanks.
15:15:00 <bjornbm> Saizan : will it pick up functions without type signatures nowadays? (ok, I'll go read the docs...)
15:15:20 <Saizan> mmh i don't think so
15:19:49 <sorear> hello.
15:19:52 <SamB_XP_> I think it complains about them...
15:19:52 <sorear> @seen
15:19:59 <sorear> @uptime
15:20:00 <lambdabot> uptime: 8d 7h 9m 4s, longest uptime: 8d 7h 9m 4s
15:20:01 <SamB_XP_> or can...
15:20:04 <Saizan> isn't quite odd for the one who developed calculus to talk about indissoluble things?
15:20:29 <augustss> yo
15:20:32 <dmwit> ?index liftM
15:20:32 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:21:46 <Modius> Haskell noob here - In interactive, what's the trick to separating lines?  (Trying to experiment with pattern matching). . .
15:22:18 <Modius> let func 2 = 3, 3 = 4. . . .  What should I be using?
15:22:28 <kpreid> Modius: semicolons
15:22:31 <icarroll> Modius: try putting your code on one line and using semicolons
15:22:48 <kpreid> Modius: where grouping is ambiguous use braces around the semicolon-separated group
15:23:10 <icarroll> let func 2 = 3; func 3 = 4
15:23:31 <icarroll> > let func 2 = 3; func 3 = 4 in (func 2, func 3)
15:23:33 <lambdabot>  (3,4)
15:26:07 <Modius> Thanks!
15:29:50 * dmead is back (gone 17:40:49)
15:30:28 <sorear> > let { foo x = x } in last $ map foo [1..100000000]
15:30:32 <lambdabot> Terminated
15:30:36 <sorear> > let { foo x = x } in last $ map foo [1..10000000]
15:30:38 <lambdabot>  10000000
15:30:50 <sorear> > let { foo x = x ; {-# NOINLINE foo #-} } in last $ map foo [1..10000000]
15:30:53 <lambdabot>  10000000
15:32:44 <dmead> Modius: using emacs would be good
15:33:04 <sorear> > {-# RULES (+) = (-) #-} 2 + 2
15:33:06 <lambdabot>  4
15:33:19 <ski> > runWriter $ let concatMapM f = foldr (liftM2 (++) . f) (return []); display s x = tell $ s ++ "=" ++ show x ++ ";" in concatMapM (\x -> display "x" x >> concatMapM (\y -> display "y" y >> if x `mod` y /= 0 then return [] else tell "!;" >> return [(x,y)]) [1..x]) [1..4]
15:33:21 <lambdabot>  ([(1,1),(2,1),(2,2),(3,1),(3,3),(4,1),(4,2),(4,4)],"x=1;y=1;!;x=2;y=1;!;y=2;...
15:33:23 <sjanssen> sorear: RULES requires -fglasgow-exts
15:33:43 <sorear> why?
15:34:09 <sorear> h98 allows for pragmas by specifying that impls should ignore unrecognized pragmas
15:34:21 <sorear> so {-# RULES #-} is valid haskell 98
15:35:05 <sorear> I see it in the docs.  Strange.
15:35:32 <augustss> what is strange?
15:35:49 <SamB_XP_> what kind of stupid pragma system doesn't have implementations ignore unrecognized pragmas?
15:36:19 <sorear> SamB_XP_: think towers of hanoi ;)
15:36:37 <SamB_XP_> I can't imagine how you would use pragmas in towers of hanoi
15:36:46 <sorear> augustss: that RULES requires glasgow-exts, even though it can't possibly conflict with h98
15:37:08 <SamB_XP_> oh, that...
15:37:14 <augustss> ah.  yes
15:37:21 <SamB_XP_> that is indeed strange!
15:37:43 <dcoutts> sorear: it's because rules use extra tokens in the lexer that are not H98
15:37:44 <dcoutts> ie forall
15:37:45 <sjanssen> well, RULES are silently ignored without -fglasgow-exts, they're not an error or anything
15:38:10 <sorear> dcoutts' explanation makes (perverse) sense, thanks
15:38:24 <sjanssen> is it a side effect of the lexer/parser?
15:38:27 <dcoutts> it's an implementation convenicnce
15:38:53 <dcoutts> you could make the lexer recognise that token just inside rules pragmas, but it's a pain so they don't
15:38:59 <SamB_XP_> maybe there ought to be a warning
15:39:35 <sorear> > let { foo x = foo x * (foo x + 1) ; {-# SPECIALIZE INLINE foo :: Integer -> Integer #-} } in foo (0::Integer)
15:39:36 <lambdabot>  Exception: <<loop>>
15:39:51 <sjanssen> well, I'd say that the stuff inside a RULES should be parsed as raw text in the first stage, then reparsed (with glasgow-exts on if necessary) later
15:40:03 <sorear> > let { foo x = foo (x+1) * (foo (x+2) + 1) ; {-# SPECIALIZE INLINE foo :: Integer -> Integer #-} } in foo ((read "0")::Integer)
15:40:07 <lambdabot> Terminated
15:40:39 <augustss> sjanssen: indeed.  but it is a bit of a pain
15:41:01 <dcoutts> aye, don't knock easy of implementation :-)
15:41:11 <dcoutts> a lot of things only get done because of it
15:42:08 <balodja> hi, would you advise me an article about interation with other languages(mostly C)?
15:42:30 <icarroll> @where ffi
15:42:30 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:42:36 <dcoutts> balodja: the keyword you want is FFI
15:43:05 <dcoutts> the FFI spec and FFI tools like c2hs, hsc2hs, greencard
15:43:19 <dmead> do any of you guys know prolog?
15:43:30 <icarroll> dmead: a little, why?
15:43:32 <balodja> i see, stands for foreign function interface. good, thanks
15:43:38 <dcoutts> balodja: and then looking at some real examples might help, for example my zlib binding is fairly short
15:43:40 <dcoutts> @where zlib
15:43:41 <lambdabot> darcs get http://haskell.org/~duncan/zlib
15:43:43 <dmead> i'm curious to know if it's worth learning
15:44:15 <dcoutts> dmead: for the ideas/experience, yes
15:44:28 <icarroll> dmead: I found it very brain-bending, but then I'd had little exposure to anything but imperative languages at that point.
15:44:33 <dmead> ah
15:44:34 <dmead> hmm
15:44:35 <dmead> ok
15:44:40 <icarroll> After Haskell it's probably a cakewalk :)
15:44:53 <dmead> yea i've done lisp ml and haskell
15:44:53 <DRMacIver> It's fairly different from most functional languages as well though, isn't it?
15:45:07 <ski> yes
15:45:10 <sorear> it's not functional :)
15:45:11 <dmead> i was under the impressing it used a MH type inference system
15:45:15 <dmead> but it's not functional
15:45:15 <sorear> no
15:45:17 <DRMacIver> sorear: Well, yes. :)
15:45:18 <sorear> it's typeless
15:45:20 <dmead> ah
15:45:23 <dmead> right
15:45:24 <sorear> just like scheme
15:45:25 <dmead> 5th generation, etc
15:45:27 <DRMacIver> Hence I didn't say 'most other functional languages'
15:45:43 <icarroll> sorear: IBYM "dynamically typed", HTH
15:45:59 <sorear> @expand IBYM
15:45:59 <dmead> typless implies it has no capacity for types
15:45:59 <lambdabot> Unknown command, try @list
15:46:00 <dcoutts> dmead: the most radical thing is that instead of writing functions you write relations, then those relations can be used as functions in 'both' directions
15:46:09 <dmead> interesting
15:46:20 <dmead> so doing theorem proving is quite easy then?
15:46:26 <DRMacIver> Dynamically typed is like slightly pregnant. :)
15:46:31 <TSC> Yes, it has "modes" as well as types
15:46:32 <sorear> typechecking is very easy
15:46:34 <ski> (Erlang has some features borrowed from Prolog, that isn't so usual in other FPLs)
15:46:50 <dmead> TSC: modes as in modal logic?
15:46:50 <TSC> You could also try Mercury, which is Prologgy
15:47:07 <SamB_XP_> but mercury has types, right?
15:47:10 <ski> yes
15:47:16 <TSC> I'm not sure, but the modes are "input", "output", "either" and so on
15:47:32 <dcoutts> dmead: so the 'output' of the function is no more special than any of the 'inputs', and given some inputs you can solve for the outputs, and since it's a relation there can be a whole set of outputs
15:47:36 <ski> TSC : huh ?
15:47:43 <dmead> neat
15:47:51 <icarroll> http://www.informatik.uni-kiel.de/~curry/
15:47:53 <lambdabot> Title: The Functional Logic Language Curry
15:47:58 <TSC> I'm just explaining it badly
15:48:04 <icarroll> sort of a cross between Prolog and Haskell
15:48:09 <dmead> whats a good implementation?
15:48:12 <dmead> of prolog
15:48:13 <dcoutts> dmead: it's ideal for search algorithms
15:48:29 <dmead> i mean compiler/interpreter
15:49:12 <sorear> hindleyMilner(s,fn(fn(A,fn(B,C)),fn(fn(A,B),fn(B,C)))).
15:49:12 <sorear> hindleyMilner(k,fn(A,fn(B,A))).
15:49:12 <sorear> hindleyMilner(app(FN,ARG),RET) :- hindleyMilner(FN,fn(EATYPE,RET)), hindleyMilner(ARG,EATYPE).
15:49:26 <dmead> :O
15:49:27 <sorear> there, type checker for SK calculus in 3 lines of prolog
15:49:30 <ski> dmead : you can try SWI or Yap
15:49:33 <dmead> neat
15:49:34 <balodja> one more question. are there any bindings for gnu's iconv?
15:49:43 <dmead> whats iconv?
15:49:46 <icarroll> dmead: http://www.gprolog.org/
15:49:48 <lambdabot> Title: The GNU Prolog web site
15:49:51 <dmead> ahh
15:49:56 <sorear> dmead: character set conversion lib
15:49:57 <dmead> i'll check that out
15:50:03 <ski> @google SWI Prolog
15:50:06 <lambdabot> http://www.swi-prolog.org/
15:50:06 <lambdabot> Title: SWI-Prolog's Home
15:50:07 <sorear> dmead: utf8 -> ascii and that sort of thing
15:50:08 <ski> @google Yap Prolog
15:50:11 <lambdabot> http://www.ncc.up.pt/~vsc/Yap/
15:50:11 <lambdabot> Title: YAP Prolog
15:50:23 <sorear> I just learned prolog like three days ago.
15:50:41 <sorear> I finally realized how it must work, and wrote an implementation.  Fun.
15:51:03 <dmead> ah
15:52:28 <sorear> balodja: IIRC it was one of the rejected SoC proposals.  There is very real demand.
15:52:36 <icarroll> @quote prolog
15:52:37 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
15:53:14 <dmead> mm
15:53:16 <dmead> hmm
15:53:16 <dmead> so
15:53:23 <sorear> Basically, prolog is what you get when you take the GHC type checker and add backtracking.
15:53:24 <sorear> :)
15:53:39 <ski> @quote prolog
15:53:40 <lambdabot> psykotic says: Let me get this straight: in your tireless Lisp-bashing efforts you have now dragged out Prolog as an exemplar of practicality? *Prolog*? My goodness, you must be desperate!
15:53:40 <dmead> as i understand it you have code generating ala lisp in prolog
15:53:41 <sorear> it also has much nicer synax
15:53:42 <dmead> sooo
15:53:56 <dmead> if you have a page of code that rewrites itself, can you like
15:53:56 <SamB_XP_> -fallow-nondeterministic-functional-dependencies! oh noes!
15:53:58 <sorear> ugly, but still nicer than class/instance hackery
15:53:59 <dmead> store states
15:54:05 <dmead> and move bettween them?
15:54:11 <stepcut> SamB_XP_: haha
15:54:38 <sorear> oh, prolog is also impure.  (but pretend you never heard that)
15:54:43 <ski> SamB_XP_ : how can they be nondeterministic and still functional dependencies ?
15:55:01 <sorear> you also need *closed* type classes
15:55:09 <SamB_XP_> ski: its a silly joke, silly!
15:55:12 <sorear> er, nm
15:55:23 <ski> sorear : for negation-as-failure, you mean ?
15:55:47 <stepcut> has anyone made a prolog with static type checking and type inference ?
15:55:54 <sorear> yes, mercury
15:55:56 <ski> stepcut : see Mercury
15:55:59 <sorear> ski: no, for eliminating the need to prespecify fds
15:56:02 <stepcut> right, I forgot about that :)
15:56:04 <sorear> (but I was wrong there)
15:56:26 * dmead is away: food time
16:00:26 <hpaste>  chessguy pasted "any more elegant solutions?" at http://hpaste.org/1366
16:01:44 <TSC> Perhaps using partition?
16:02:33 <chessguy> ?type partition
16:02:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:02:52 <TSC> You can split the people into good/bad, then process the sublists separately
16:03:10 <TSC> Print the bad ones, and take the mean of the good ones
16:03:20 <hpaste>  augustss annotated "any more elegant solutions?" with "A little shorter" at http://hpaste.org/1366#a1
16:03:42 <TSC> Yes, like that (:
16:09:48 <icarroll> @src ++
16:09:49 <lambdabot> (++) []     ys = ys
16:09:49 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
16:19:06 <sorear> What is the recommended document system to use for in tree Commentary type documents?
16:19:32 * sorear is writing a commentary for lambdabot7 concurrently with the code
16:19:42 * sorear is currently using raw html, yukk
16:19:51 <sorear> any suggestions?
16:21:30 <dcoutts> sorear: txt2tags ? docbook ?
16:21:42 <sorear> @google txt2tags
16:21:42 <dcoutts> literate haskell
16:21:44 <lambdabot> http://txt2tags.sourceforge.net/
16:21:44 <lambdabot> Title: txt2tags
16:21:56 <sorear> I have no experience with either, unfortunately :(
16:21:57 <dcoutts> haddock style in-module docs
16:22:10 <dcoutts> txt2tags is very simple
16:22:20 <dcoutts> it's just an ascii wiki-like markup
16:22:51 <dcoutts> eg: http://darcs.haskell.org/gtk2hs/docs/tutorial/glade/index.t2t
16:22:53 <icarroll> > case [1,2] of foo@~(bar:_) -> (foo,bar)
16:22:53 <lambdabot>  Parse error in pattern
16:22:57 <sorear> API documentation is one thing, and haddock is great there.
16:23:15 <dcoutts> > case [1,2] of ~foo@(bar:_) -> (foo,bar)
16:23:16 <lambdabot>  ([1,2],1)
16:23:35 <sorear> but very good API reference docs are not indexed in a way suitable for newbie-hacking-docs
16:23:37 <dcoutts> > case [1,2] of foo@(bar:_) -> (foo,bar)
16:23:39 <lambdabot>  ([1,2],1)
16:23:40 <icarroll> > case [1] of ~foo@(bar:_) -> (foo,bar)
16:23:42 <lambdabot>  ([1],1)
16:23:51 <dcoutts> icarroll: what do you want the ~ for ?
16:23:51 <icarroll> > case [] of ~foo@(bar:_) -> (foo,bar)
16:23:53 <lambdabot>   Irrefutable pattern failed for pattern (foo@(bar : _))
16:23:55 <sorear> I commonly want a abstract overview
16:24:08 <icarroll> dcoutts: trying to get strict foo and lazy bar
16:24:15 <icarroll> looks like it doesn't work though
16:24:39 <sorear> icarroll: you can't
16:24:44 <dcoutts> icarroll: hmm, no I expect the ~ applies to the whole thing
16:24:46 <sorear> icarroll: variables are ALWAYS lazy
16:24:53 <sorear> w/o glasgow exts
16:24:58 <dcoutts> and foo@bar is just an alias
16:25:50 <sorear> > case [1] of !foo@(~(bar:_)) -> (foo,bar)        -- this should work with -fbang-patterns, producing strict foo and lazy bar (but bar will never be _|_ unless foo is [], if foo is _|_ the match diverges)
16:25:50 <lambdabot>  Parse error
16:26:15 <sorear> > case [1] of foo@(bar:_) -> foo `seq` (foo,bar)  -- same thing, manually
16:26:16 <lambdabot>  ([1],1)
16:26:44 <sorear> actually, no, wait, this won't work
16:26:59 * sorear forgot one of the technicalities of ~ matching
16:27:14 <sorear> > case [1] of foo -> foo `seq` (foo,head foo)  -- correct
16:27:16 <lambdabot>  ([1],1)
16:27:36 <icarroll> I found the best solution is to put separate declaration for the head. Not as nifty, but works.
16:27:49 <sjanssen> sorear: are you sure those are different?
16:29:14 <sjanssen> if you perform that case analysis on _|_, both yield _|_ (by virtue of the `seq`)
16:30:28 <augustss> > fst $ case [] of foo -> foo `seq` (foo,head foo)
16:30:30 <lambdabot>  []
16:30:46 <augustss> fst $ case [] foo@(bar:_) -> foo `seq` (foo,bar)
16:31:01 <augustss> > fst $ case [] foo@(bar:_) -> foo `seq` (foo,bar)
16:31:02 <lambdabot>  Parse error
16:31:04 <sjanssen> of course those two are different
16:31:08 <int-e> > fst (case [] of foo@(bar:_) -> (foo, bar))
16:31:09 <lambdabot>   Non-exhaustive patterns in case
16:31:32 <augustss> sjanssen: oh, so those are not the ones you were referring to
16:31:32 * sjanssen is wrong :(
16:31:46 <augustss> ah
16:31:47 <int-e> > fst (let foo@(bar:_) = [] in (foo, bar))
16:31:48 <lambdabot>   Irrefutable pattern failed for pattern (foo@(bar : _))
16:31:53 <sjanssen> augustss: I had imagined a ~ in there
16:33:10 <augustss> let ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~x = 1 in x
16:33:22 <augustss> > let ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~x = 1 in x
16:33:23 <lambdabot>  Parse error
16:33:30 <augustss> that's what i suspected
16:33:46 <int-e> > let ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~x = 1 in x
16:33:47 <lambdabot>  1
16:33:51 <augustss> > let y~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~x = 1 in 0
16:33:53 <lambdabot>  0
16:34:46 <augustss> ~ and - were special in the first few version of haskell.  thankfully that is gone
16:35:41 <bd_> What was ~ used for?
16:35:54 <bd_> oh, irrefutable match?
16:36:50 <augustss> same use as now, but operators could not start with - or ~ (i think that was the rule)
16:36:51 <int-e> yes
17:11:42 <dmwit> Is "map f" a section, or is there a better name for it?
17:11:58 <jcreigh> dmwit: partially applied function
17:12:09 <dmwit> Okay, thanks.
17:12:52 <jcreigh> I don't know if that's a better name, but that's what I call 'em. :)
17:14:21 <chessguy> i've never really understood the difference
17:14:32 <dons> jcreigh: also, i reckon we can send patches to xmonad@ now , for discussion
17:14:40 <dons> sjanssen: whddya reckon?
17:15:02 <jcreigh> chessguy: I believe that a section refers to infix. ie, "(*2)"
17:15:14 <chessguy> ah, that makes sense
17:15:31 <rahikkala> Ay, I think section is specifically a syntax feature for binary operators
17:16:22 <rahikkala> While partial application is just an invisible lambda :)
17:16:42 <jcreigh> dons: oh, so "darcs send" would just go to the ML? that would be fairly handy.
17:16:44 <fax> invisible lambda :D
17:16:47 <chessguy> aren't all functions pretty much just invisible lambdas?
17:16:54 <dons> jcreigh: yeah, i think we should set it up that way.
17:17:01 <fax> isnt .. everything just an invisible lambda?
17:17:04 <dons> sjanssen: should we change the default email to be the xmonad@ list?
17:17:06 <stepcut> is there an xmonad mailing list now ?
17:17:11 <Mitar> why this program does not compile: http://www.haskell.org/HOpenGL/examples/BezMesh.hs
17:17:11 <chessguy> dons: there's an xmonad mailing list now?
17:17:19 <jcreigh> stepcut, chessguy: yes
17:17:24 <jcreigh> @where xmonad-ml
17:17:24 <lambdabot> I know nothing about xmonad-ml.
17:17:33 <stepcut> is it invite only :p
17:17:45 <jcreigh> @where+ xmonad-ml http://www.haskell.org/mailman/listinfo/xmonad
17:17:46 <lambdabot> Done.
17:18:03 <dons> its just an normal haskell.org list.
17:18:07 <jcreigh> stepcut: I'm pretty sure we indent it let anybody in. :)
17:18:17 <jcreigh> *intend
17:18:18 <dmwit> Mitar: More info: what errors do you get?  Have you installed HOpenGL?  etc.
17:18:25 <stepcut> indent sounds more fun...
17:18:43 <jcreigh> stepcut: right. so we could only indent people if it still worked with layout. :)
17:19:06 <Mitar> first: Failed to load interface for `GL':
17:19:15 * chessguy indents lambdabot
17:19:15 <dmwit> Are haskell.org's mailing lists powered by mailman?
17:19:34 <dmwit> (That would be nice, because then I wouldn't have to learn a whole new mailing list system.)
17:19:37 <jcreigh> dmwit: I assume so, given the /mailman URL.
17:19:50 * dmwit feels unobservant
17:20:18 <sorear> http://txt2tags.sourceforge.net/tips.html#copyright-symbol
17:20:20 <lambdabot> Title: txt2tags tips
17:20:48 <sorear> Hmm, I'm having trouble writing a rant for their ML that sounds neither patronysing nor youre-an-idiot.
17:21:02 <sorear> And I'm waay to young to patronize :)
17:21:40 <jcreigh> "ASCII characters" my eye.
17:22:14 <jcreigh> I hate it when people say "ASCII characters" when they don't mean it.
17:22:53 <Mitar> so how can i compile this simple example under ghc 6.6?
17:23:17 <dons> Mitar: what errors, and what command line did you use?
17:23:23 <dons> something like, ghc --make -O Foo.hs ?
17:23:28 <Mitar> ghc BezMesh.hs
17:23:35 <Mitar> and I get: Failed to load interface for `GL':
17:23:35 <dons> ok, try adding --make -O
17:24:03 <dons> yes, because it can't find the GL library. --make will find it, if you installed it. (it does come by default I think)
17:24:47 <chessguy>     oooooooo
17:24:47 <chessguy>   ooo      ooo
17:24:47 <chessguy>  o    oooo    o
17:24:47 <chessguy> o    oooooo    o
17:24:47 <chessguy>  o    oooo    o
17:24:48 <chessguy>   ooo      ooo
17:24:50 <chessguy>     oooooooo
17:24:52 <chessguy> ASCII characters, my eye
17:24:56 <jcreigh> lol
17:25:03 <chessguy> sorry, i couldn't resist
17:25:16 <chessguy> that looks so stupid
17:25:25 <sorear> ouch, black iris
17:25:28 <jcreigh> I would ask lambdabot to @remember that if there was any way to preserve the formatting.
17:25:34 * sorear calls chessguy's doctor
17:25:52 <Mitar> it does this error with make too
17:26:15 <dons> what package does your code require? the GLUT package?
17:26:16 <Mitar> but I have GL: /sw/lib/ghc-6.6/imports/Graphics/Rendering/OpenGL/GL/
17:26:18 <chessguy> sorear: eye wouldn't do that if eye were you
17:26:28 <chessguy> ok, i'm officially in a weird mood
17:26:36 <Mitar> I am trying to compile this: http://www.haskell.org/HOpenGL/examples/BezMesh.hs
17:26:55 <int-e> @quote slow
17:26:55 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
17:27:20 <dons> Mitar: I think you need the GLUT package, as well as the OpenGL package.
17:27:32 <dons> for import Graphics.UI.GLUT
17:28:13 <dons> ah, maybe that is *old* code.
17:28:56 <Mitar> i also think it is old code ..
17:29:00 <Mitar> is there any newer example?
17:29:16 <dons> yes, it is out of date, import Graphics.Rendering.OpenGL.GL
17:29:23 <dons> is the new path, but it appears to use things not defined.
17:30:10 <dons> there are some OpenGL tutorials around.
17:30:19 <dons> lispy wrote a port of the NeHe tuts, you could google for.
17:30:26 <dons> should be linked on haskell.org somewhere.
17:30:30 <dons> or http://haskell.org/haskellwiki/Blog_articles#Graphics
17:30:32 <lambdabot> Title: Blog articles - HaskellWiki
17:30:50 <dons> ?users
17:30:51 <lambdabot> Maximum users seen in #haskell: 336, currently: 302 (89.9%), active: 44 (14.6%)
17:31:46 <thoughtpolice> woo! my little packet sniffer works. i'm so proud of myself. :>
17:33:23 <dons> http://programming.reddit.com/info/1hhrr/comments
17:33:25 <lambdabot> Title: Haskell projects for Google Summer of Code announced (reddit.com)
17:34:25 <joelr1> @hoogle isSpace
17:34:26 <lambdabot> Char.isSpace :: Char -> Bool
17:35:21 <joelr1> ?src isSpace
17:35:22 <lambdabot> Source not found. stty: unknown mode: doofus
17:35:36 <joelr1> ?src Char.isSpace
17:35:36 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:36:17 <dons> ?source Data.Char
17:36:18 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
17:38:46 <sorear> jcreigh: http://members.cox.net/stefanor/charsetrant.txt
17:38:56 <sorear> jcreigh: will this massively offend anyone?
17:40:40 <jcreigh> sorear: I don't think any reasonable person would be offended.
17:41:18 <sorear> ok.
17:41:21 * sorear sends
17:41:27 <Pseudonym> The unstated assumption is taht Haskellers are reasonable people/
17:41:46 <sorear> No, I'm not sending this to haskellers :)
17:43:35 <jcreigh> > maxBound :: Char
17:43:37 <lambdabot>  '\1114111'
17:43:45 <jcreigh> what's magic about 1114111 anyway?
17:44:44 <desp> "The (C) and (R) symbols are standard ASCII characters"?
17:44:50 <sorear> I don't recall.  I think it is the upper bound of the unicode spec
17:45:03 <sorear> desp: I don't have to agree with the quotations :)
17:45:12 <desp> :)
17:45:12 <sorear> esp when I'm attacking them
17:45:13 <jcreigh> oh, heh, it's prime.
17:45:34 <desp> sorear: right, sorry, missed the attack
17:45:41 <dmwit> ?hoogle sqrt
17:45:42 <lambdabot> Prelude.sqrt :: Floating a => a -> a
17:46:02 <int-e> > length ['\0'..]
17:46:04 <lambdabot>  1114112
17:46:08 <twanvl> > 0x10FFFF
17:46:09 <lambdabot>  1114111
17:46:29 <jcreigh> twanvl: ah, that's probably why.
17:47:00 <medfly> can someone explain to me what a functional language is?
17:47:00 <twanvl> The real reason is UTF16
17:47:17 <desp> sorear: although I'd object to you saying that there is no standard among the ISO Latin encodings
17:47:26 <desp> sorear: they *are* standards, often national ones.
17:48:05 <desp> sorear: I mean, often also national ones, in addition to being international
17:48:53 <sorear> The encodings are themselves standard, but there is no standard among them.
17:49:03 <sorear> Or, as I_FORGET put it:
17:49:18 <sorear> Standards are great!  There are so many of them to choose from!
17:49:26 <sorear> @goo "Standards are great!  There are so many of them to choose from!"
17:49:28 <lambdabot> No Result Found.
17:49:34 <sorear> @goo Standards are great!  There are so many of them to choose from!
17:49:36 <lambdabot> http://www.kenrockwell.com/tech/monitors.htm
17:49:37 <lambdabot> Title: How to choose a Monitor Test Review  2004 KenRockwell.com
17:50:02 * medfly dances for attention
17:50:15 <desp> sorear: I'm sorry, but again, I disagree
17:50:27 <desp> sorear: the standard depends on the context
17:50:32 <sorear> A functional lanuguage is a language where functions are themselves values.
17:50:40 <medfly> thanks
17:50:52 <sorear> > let { do_something f = f 2 2 } in do_something gcd
17:50:54 <lambdabot>  2
17:50:57 <sorear> like that
17:51:46 <thedward> I really hate that field labels are global
17:51:59 <bd_> > let { do_something = flip ($) 2 . join } in do_something gcd
17:52:00 <lambdabot>  2
17:52:07 <chessguy> ugh. what rules are there for what can be part of an infix constructor?
17:52:31 <sorear> any operator character
17:52:36 <sorear> the first must be ':'
17:52:41 <chessguy> aha
17:52:49 <sorear> it's in the report, section lexical syntax, production 'consym'
17:52:58 <Pseudonym> And yes, it's dumb.
17:53:07 <sorear> Pseudonym: what is?
17:53:16 <sorear> ( thedward's comment?)
17:53:18 <Pseudonym> Requiring the first character of a consym to be ':'.
17:53:33 <Pseudonym> It's also dumb that fields labels are global, yes.
17:54:25 <Pseudonym> Haskell doesn't really do nested namespaces.
17:54:25 <int-e> Pseudonym: let me guess, requiring constructor names to be capitalized is also dumb?
17:54:41 <Pseudonym> int-e: It's unfortunate.
17:56:06 <jargonjustin> I'm writing a binary search tree implementation and am having trouble adding a type-class qualification of Ord to my type-constructor.  Specifically, I'd like to declare my tree to be an instance of Functor, but need the signature to be (Ord a, Ord b) => (a -> b) -> f a -> f b instead.  Is this possible / type-safe?
17:56:21 <Pseudonym> At least there are a lot of capital letters.  There's only one colon.
17:56:47 <Pseudonym> jargonjustin: Congratulations, you've just found a limitation of Haskell's type system.
17:56:53 <Pseudonym> Sorry.
17:57:01 <int-e> Pseudonym: ok, so is let a +++ b = c  a pattern match or a definition of an infix operator?
17:57:27 <Pseudonym> int-e: If you'll read what I said, I noted that the problem is that there's only one colon, but lots of capital letters.
17:57:56 <chessguy> is it not possible to do something like this? data Foo = (Bar a) => T | F | S a
17:58:19 <Pseudonym> chessguy: There's a complication there.
17:58:36 <Pseudonym> First off, no.  You need an explicit forall.
17:58:54 <chessguy> i can't constrain the types that can build an algebraic type?
17:59:00 <sorear> With the full featured command line mode, an experienced user can automatize tasks and
17:59:05 <int-e> use GADT syntax.
17:59:06 <sorear> @all-dicts automatize
17:59:08 <lambdabot> *** "automatize" gcide "The Collaborative International Dictionary of English v.0.48"
17:59:09 <lambdabot> automatize \automatize\ v. t.
17:59:09 <lambdabot>    same as {automate}.
17:59:09 <lambdabot>  
17:59:09 <lambdabot>    Syn: automate.
17:59:10 <lambdabot> [8 @more lines]
17:59:16 <int-e> then you can.
17:59:16 <sorear> aww, not a typo :)
17:59:21 <Pseudonym> chessguy: In normal data syntax, a typeclass constraint only constrains the constructor.
17:59:22 <chessguy> automatize sounds way cooler
17:59:32 <Pseudonym> But yes, you can use GADT syntax, too.
18:00:03 <Pseudonym> data Foo = T | F | forall a. (Bar a) => S a
18:00:07 <Pseudonym> Hang on.
18:00:08 <sorear> Wow, the documentation author is REALLY not making himself look good.
18:00:09 <sorear>    It's free, GPL, open source, public domain, <put-your-favorite-buzzword-here>.
18:00:15 <Pseudonym> data (Bar a) => Foo a = T | F | S a
18:00:18 <chessguy> are GADTs '98?
18:00:25 <Pseudonym> That only puts a constraint on the constructors.
18:00:30 <sorear> GPL AND public domain = what exactly?
18:00:34 <Pseudonym> S :: (Bar a) => a -> Foo a
18:00:39 <sorear> chessguy: no.
18:00:41 <int-e> chessguy: what you want isn't possible in Haskell 98
18:00:45 <chessguy> ugh
18:00:48 <chessguy> ok
18:01:58 <chessguy> data (Bar a) => Foo a = T | F | S a -- this might be ok. i take it this isn't '98 either?
18:02:08 <Pseudonym> I think that is '98.
18:02:18 <Pseudonym> But as I said, it only puts a constraint on the constructors of Foo.
18:02:29 <Pseudonym> It doesn't make the type dictionary available when you pattern match on a Foo, for example.
18:02:38 <chessguy> i'm not sure what you mean
18:02:52 <Pseudonym> It makes S have the type:
18:02:57 <Pseudonym> S :: (Bar a) => a -> Foo a
18:02:58 <int-e> chessguy: it's Haskell 98 as far as I know, but it doesn't do what I think you want.
18:03:08 <Pseudonym> But it doesn't store a type dictionary for (Bar a) in S.
18:03:15 <int-e> chessguy: you'll still need explicity Bar a => constraints in functions that use the S constructor
18:03:19 <Pseudonym> Right.
18:03:38 <chessguy> that might be ok.
18:03:50 <chessguy> then again, it might get old fast. we'll see :)
18:03:52 <int-e> oh hmm.
18:04:08 <int-e> nm. I thought I missed something but I didn't :)
18:17:08 <chessguy> well, i don't know how hideous this is, but it seems to work
18:17:10 <chessguy> !paste
18:17:10 <hpaste> Haskell paste bin: http://hpaste.org/
18:17:37 <hpaste>  chessguy pasted "Wumpus, anyone?" at http://hpaste.org/1367
18:19:51 <sorear> dcoutts: thank you, txt2tags wasn't what I was looking for but it certainly does the job
18:19:54 <sorear> dcoutts++
18:20:15 <dcoutts> oh good :-)
18:20:42 <sorear> chessguy: what does this have to do with wumpii?
18:21:19 <chessguy> sorear: the wumpus world is a classic logic AI problem
18:21:49 <int-e> sorear: obviously, P = pit and B = bat
18:21:58 <sorear> I was thinking of "Hunt the wumpus" :)
18:22:01 <chessguy> int-e: almost
18:22:06 <chessguy> B = breeze
18:22:13 <sorear> er, what are conjunctions/disjunctions for then?
18:22:31 <chessguy> hmm?
18:22:47 <sorear> :\/
18:23:06 <chessguy> what about it?
18:23:19 <chessguy> it's for constructing more complex sentences
18:23:46 <int-e> chessguy: hmm."hazards included bottomless pits, super bats (which would drop the player in a random location) and the Wumpus itself." -- I've never heard of breezes
18:23:56 <int-e> (in the context of hunt the wumpus)
18:24:17 <chessguy> a breeze lets you know when you're downwind of the wumpus, i think
18:24:34 <chessguy> i'm sure there are lots of versions
18:36:01 <dmwit> A breeze tells when you're next to a bottomless pit.
18:36:09 <dmwit> Smells come from the Wumpus, and noises come from the bat.
18:39:01 <sorear> @flush
18:39:03 <sorear> @uptime
18:39:04 <lambdabot> uptime: 8d 10h 28m 7s, longest uptime: 8d 10h 28m 7s
18:39:17 <hpaste>  thoughtpolice pasted "little packet sniffer" at http://hpaste.org/1368
18:42:41 <jargonjustin> Why can I write: "data Entry k v = ...; instance Eq k => Eq (Entry k v) where ..." but not "data Tree a = ...; instance Ord a => Functor (Tree a) where..." ?
18:43:34 <jargonjustin> I'm trying to enforce the constraint that all my Binary Trees are parametized by an order-able type, but can't write a Functor instance declaration then.
18:44:20 <jargonjustin> I think the above is a problem because I need to write "instance SomeClass Kind" where Kind is * -> *
18:44:29 <dons> Functor Tree
18:44:45 <dons> so, yes, a kinding issue.
18:44:54 <jargonjustin> dons: Whoops, I meant to type "data Ord a => Tree a = ..."
18:45:13 <dons> instance Functor Tree where
18:45:14 <dons> makes sense
18:45:42 <dons> but it won't let you write a Tree Functor instance that depends on the type of the elements of the Tree.
18:45:47 <dons> hence no Ord a => Functor (Tree a)
18:45:48 <hpaste>  jorend pasted "finally... Data.HashTable.ST" at http://hpaste.org/1369
18:45:51 <dons> maybe this is a good thing.
18:46:14 <dons> jargonjustin: anyway, Functor is the wrong place to try to enforce an Ord constraint on the elements.
18:46:43 <dons> you could use an existential to require all tree elements are Ord'able
18:46:54 <dons> otherwise, just annotate each function in the api with this constraint
18:47:28 <dons> data OrdTree = forall a . Ord a => OrdTree a -- one very restricted option
18:47:33 <jargonjustin> dons: I miss-typed my question originally.  My data declaration of Tree is qualified with Ord a.
18:47:44 <dons> yes, but that does nothing :-)
18:48:10 <dons> f :: Ord a => ... -- on the function types is how you get this constraint. or use an existential.
18:48:18 <dons> am I forgetting any other tricks?
18:48:31 <dons> oh, you could attach an Ord to some new class, for building Tree
18:48:48 <dons> class Ord a => MkTree a where .. build a tree ..
18:48:54 <dons> then only export MkTree
18:49:02 <dons> which is basically a smart constructor
18:50:10 <dobblego> a "smart constructor"?
18:50:32 <dobblego> is that a specifically named concept?
18:50:38 <vincenz> it is now :)
18:51:38 <jargonjustin> Okay, I think I'm starting to figure it out.
18:52:08 <dons> yes, its a well known concept.
18:52:16 <dons> ?google site:haskell.org Smart constructor
18:52:19 <lambdabot> http://darcs.haskell.org/ghc/compiler/cmm/CmmUtils.hs
18:52:32 <dons> well, there's actually a wiki page on it. too
18:52:44 <vincenz> "gosh darnit, mary-ann, them builders be asking me again which two-by-fours to use. " "aaww...honey, why don't you do like ray-ray said and get one of them smart constructors"
18:52:59 <dobblego> do they exist specifically for the issue that jargonjustin mentions?
18:53:18 <jargonjustin> My case with " instance Eq" worked because the kinds worked and I didn't need to change the type of the functions, but to implement fmap I'd have to 1) qualify the type of the function, which I can't do in the type class and 2) figure out how to make the kinds work (which may only be a problem because of 1)
18:56:29 <jargonjustin> dons: I'm trying to see how your "smart constructor" would allow me to declare the functor instance.  Doing data Ord a => BTree a = Leaf a would make Leaf :: Ord a => a -> Leaf a
18:56:59 <Pseudonym> ?google SmartConstructor
18:57:01 <lambdabot> http://www.patentstorm.us/patents/6633888-description.html
18:57:02 <lambdabot> Title: Method and apparatus for visually creating and testing object oriented component ...
18:57:09 <Pseudonym> ?google SmartConstructor site:haskell.org
18:57:12 <lambdabot> http://www.haskell.org/hawiki/SmartConstructor
18:57:12 <lambdabot> Title: FactoryFunction - The Haskell Wiki
18:57:21 <Pseudonym> Ah, yes.  FactoryFunction is another name.
19:00:31 <jargonjustin> So the reason to make it like a Smart Constructor is to leave the qualification off the data, write my functor instance without it, but don't export the value constructor from the module and provide functions with the appropriate qualifications instead, right?
19:00:43 <jargonjustin> s/reason/way/
19:01:57 <dons> jargonjustin: I can't see how you can write a Functor instance that uses Ord.
19:02:10 <vincenz> that's why Set is not a Functor
19:02:13 <dons> given the kind restriction for functors and monads.
19:02:19 <dons> exactly.
19:02:31 <dons> :t fmap
19:02:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:02:39 <dons> f :: * -> &
19:02:46 <dons> but Tree a :: *
19:02:49 <jargonjustin> Yeah, I'm realizing I'd have to rebalance it afterwards anyway, which would require the Ord declaration and not work with the smart constructors either.
19:03:08 <vincenz> jargonjustin: There is an explanation for this
19:03:12 <jargonjustin> Okay, I'll write my own darn map function :-)
19:03:33 <jargonjustin> vincenz: it makes sense, just a little confusing at first because it feels like I'm sacrificing generality by working against idioms.
19:03:46 <vincenz> jargonjustin: basically Functor should only modify the elements, not the structure containing the elements, aka you keep the same structure those elements hang off of.  Now if your structure relies on the elements, then this is no longer valid
19:04:44 <jargonjustin> vincenz: Yeah, I'd hoped a BST would be "close enough" (the idea of a map function applies for instance) but I can see why it won't work with the type system.
19:05:16 <vincenz> jargonjustin: it also doesn't make sense, you're modifying the structure while traversing while Functor is structure-agnostic
19:06:31 <jargonjustin> vincenz: I agree, I'm just glad I understand why Haskell won't allow it (even though the intent of fmap is such that it should.)
19:06:50 <vincenz> :)
19:08:25 <jargonjustin> s/glad/satisfied/ :-/
19:09:05 <vincenz> why do you need Functor?
19:09:59 <jargonjustin> I don't really, I wrote a BST implementation as part of learning Haskell and was playing with type-classes.  I thought mapping a BTree would be a good example.
19:10:22 <vincenz> btreeMap?
19:10:57 <jargonjustin> Another question, why does "instance Eq k => Eq (Entry k v) where" work but "instance Eq k => Eq (Entry k) where" not?
19:11:12 <vincenz> different kinds
19:11:21 <vincenz> (Entry k) :: * -> *
19:11:25 <vincenz> (Entry k v) :: *
19:11:55 <badger_homes> eddie haskellllLLL!!
19:12:05 <jargonjustin> Isn't the datatype you're declaring an instance for supposed to be *->* ?
19:12:10 <vincenz> jargonjustin: not for Eq
19:12:18 <vincenz> jargonjustin: Eq is on pure data values
19:12:25 <vincenz> erm
19:12:33 <vincenz> and hence on types of kind *
19:12:39 <jargonjustin> Oh, so it depends on the class declaration?
19:12:44 <vincenz> yep
19:12:57 <vincenz> Functor :: We enable things forr containers of 'a's
19:13:05 <vincenz> Eq: Wee do things for values
19:13:07 <jargonjustin> Then by specifying v without a qualification has an implicit forall, which makes it work, right?
19:13:13 <vincenz> yes
19:13:26 <vincenz> I was going to say that :) the v is an implicit forall v
19:13:43 <vincenz> forall v k. Eq k => eq ...
19:14:34 <jargonjustin> The way the compiler infers the kinds is by looking at the method declarations for the typeclass?
19:15:00 <vincenz> indeed
19:15:17 <jargonjustin> Is there a way in GHCi to display information about a type-class?
19:15:19 <vincenz> Heh, never thought about that before :) But yes, it would appear so
19:15:35 <vincenz> jargonjustin: :i
19:16:25 <dons> http://programming.reddit.com/info/1higf/comments
19:16:27 <lambdabot> Title: The (functional) essence of iterators (reddit.com)
19:16:30 * dons tries to lift the standard a bit
19:16:54 <vincenz> dons: oh, saw my ask reddit?
19:17:05 <dons> hehe. i've been thinking the same thing though.
19:17:12 <dons> used to be 20% of articles were pdfs.
19:17:14 <vincenz> I thought it was time to make it explicit
19:17:18 <dons> now its all 'how to do blah with css'
19:17:21 <vincenz> yes
19:17:28 <vincenz> or "oh my god, look at this great social site!"
19:17:49 <dons> so i might go back to posting my one FP .pdf a day routine.
19:18:08 <vincenz> dons: I think one of the core issues is crossposting from plain reddit
19:18:14 <vincenz> that should be disabled imho
19:18:17 <dons> yeah.
19:18:19 <vincenz> why do we need crossposting anyways
19:18:22 <vincenz> damn karma-whores
19:19:00 <dons> dons (2039) mwhahaha
19:19:05 <vincenz> :D
19:19:12 <vincenz> vincenz (50)
19:21:16 <jcreigh> jcreigh (37)
19:28:42 <dons> http://programming.reddit.com/info/1hijh/comments
19:28:44 <lambdabot> Title: Practical programming with types parameterized by numbers (reddit.com)
19:33:39 <dons> hehe, xmonad hits the ion list.
19:33:50 <jcreigh> oh really?
19:33:50 <sorear> oh noes!
19:34:15 <dons> ah well, tumov is an old haskell hand, so he won't mind.
19:37:13 <dons> http://programming.reddit.com/info/1him0/details
19:37:15 <lambdabot> Title: Finger Trees: A Simple, General-purpose Sequence Data Structure (reddit.com)
19:37:24 <dons> take that reddit! get some learning into ya!
19:38:41 <jcreigh> so sjanssen is going to get paid to work on XHSB?
19:39:02 <dons> yeah.
19:39:05 <jcreigh> nice.
19:39:09 <dons> woot! xmonad looks safe, I think.
19:39:19 <jcreigh> "safe"?
19:39:20 <dons> since we can tie him down and make him write xmonad code for 3 months.
19:39:28 <jcreigh> oh, heh heh.
19:39:31 <dons> well, i think it'll be done to completion.
19:39:41 <jcreigh> what? It's not done? :)
19:39:44 <dons> since that's one full time paid dev on a small project.
19:39:57 <dons> i want type system proofs for xmonad by the end ;-)
19:40:30 <sjanssen> I don't think there are 3 months of full time work left in xmonad
19:40:43 <dons> sjanssen: you can rewrite it 9 ways.
19:40:57 <dons> including in the type system twice
19:42:33 <sorear> As if adding a usable IO system to the typechecker wasn't enough of a project :)
19:49:19 <sjanssen> xmonad has a fair amount of buzz for being unreleased
19:49:33 <sorear> @seen JohnMeacham
19:49:34 <lambdabot> JohnMeacham is in #haskell and #haskell-blah. I last heard JohnMeacham speak 57m 11s ago.
19:49:51 <dons> sjanssen: we should relesae it soon!
19:49:52 <sorear> JohnMeacham: the DrIFT repo is corrupt
19:50:14 <sjanssen> dons: yes
19:50:23 <sjanssen> what were we waiting for again?
19:50:40 <dons> well, a write up, a web page, some more QC properties. a little bit more testing.
19:50:49 <sjanssen> actually, all the "tasks before 0.1" in the TODO are done
19:50:56 <sjanssen> I'll add those new ones
19:50:57 <dons> we could probably finish it up within a week.
19:51:09 <dons> i'd like QC tests for the layout algo
19:51:17 <dons> some methodical user testing
19:51:23 <dons> hackage release for X11-extras
19:51:29 <dons> xmonad.org pointing to our web page.
19:51:42 <dons> and the TMR article, or at least, an article, done, covering the design.
19:51:46 <dons> that's the complete package then.
19:52:07 <dons> since i'm travelling tomorrow, i'm not terribly hopeful of getting the article written.
19:52:44 <sjanssen> oops
19:52:55 <dons> what do you think?
19:53:13 <sjanssen> the deadline is today, yeah?
19:53:20 <dons> 13th?
19:53:25 <dons> ?time sjanssen
19:53:38 <dons> is it the 13th in the US yet?
19:53:47 <sjanssen> Thu Apr 12 21:52:50 CDT 2007
19:53:48 <dons> not quite.
19:54:04 <dons> so yeah, 24 hours. but i won't be able to work on it.
19:54:59 <sorear> there should probably also be a hcar article
19:55:08 <sjanssen> sorear: oh, good catch
19:55:11 <sorear> the deadline is a bit looser on that though
19:55:22 <dons> yeah, a month or so.
19:55:22 <sjanssen> the deadline was just announced, right?
19:55:37 <dons> but i would like to write the 'design and implementation' report before we release, anyway.
19:55:42 <dons> i might do that after i get back.
19:55:46 <sorear> where "just" = sometime last week
19:55:50 <dons> hmm. maybe it could even be a proper TR.
19:56:27 <sjanssen> yeah, lets not try to rush it in
19:57:21 <sjanssen> dons: how long are you away?
19:57:42 <dons> Sat -> Fri.
19:57:54 <dons> i'll be online, but not available for much till Weds.
19:58:51 <sjanssen> where Sat = tomorrow?
19:59:09 <brad__> hello
19:59:23 <sjanssen> stupid Earth, it should be the same date everywhere
19:59:30 <brad__> google SOC projects for haskell look great!
19:59:48 <chessguy> man, i don't know if i'm ready to have kids yet. i just had to rock my nephew to sleep, but it took me away from my AI programming!
19:59:49 <sorear> yeah!!
20:00:10 <sjanssen> @remember chessguy man, i don't know if i'm ready to have kids yet. i just had to rock my nephew to sleep, but it took me away from my AI programming!
20:00:11 <lambdabot> Done.
20:00:11 <brad__> i would have added: 1. one true database api, 2. integrate GOA into ghci
20:00:13 <monochrom> Write an AI application to rock your nephew to sleep.
20:00:26 <dons> sjanssen: Sat == tomorrow :-)
20:00:31 <sorear> @botsnack
20:00:32 <lambdabot> :)
20:00:32 <plediii> am I the only one thinking write an AI program instead of children?
20:00:39 <sorear> @localtime dons
20:00:41 <lambdabot> Local time for dons is Fri Apr 13 12:59:52 2007
20:01:07 <chessguy> monochrom: even my mom's barely intelligent enough to do that
20:01:12 * sorear snoops
20:01:39 <brad__> why has there never been more excitement about shipping something like lambdabot with ghci?
20:01:48 <ariks> http://www.msnbc.msn.com/id/17542627/site/newsweek/from/ET/
20:01:51 <lambdabot> Title: The New Science of Human Evolution - Newsweek Technology - MSNBC.com
20:01:52 <brad__> seems i am the only one who thinks this would be cool
20:02:29 <sjanssen> brad__: the GHC hackers are working on reducing the size of the distribution, I bet they wouldn't like your idea much :)
20:02:39 <ariks> shit sorry, not used to this putty thing.. didn't know right click pasted..
20:02:46 <brad__> ah sjanssen, that makes sense
20:03:03 <ariks> good thing something much larger wasn't in my paste buffer
20:04:09 <chessguy> ariks: or more incriminating
20:04:49 <brad__> take care! bye
20:06:19 <ariks> chessguy: like monadsforpedophiles.com?
20:08:04 * sorear is considering @remembering that
20:08:23 <chessguy> sorear: just make sure you take my name out of it
20:09:41 <sorear> we've got a nice tradition of remembering things out of context
20:09:52 <sorear> @remember ariks monadsforpedophiles.com?
20:09:53 <lambdabot> Done.
20:09:59 <sorear> @qote glguy funny
20:10:00 <lambdabot> Maybe you meant: quote vote
20:10:03 <Pseudonym> No, we call them "warm fuzzy things" now.
20:10:04 <sorear> @quote glguy funny
20:10:05 <lambdabot> No quotes match. I've seen penguins that can type better than that.
20:10:11 <sorear> @quote glguy .*funny*
20:10:12 <lambdabot> No quotes match. Are you on drugs?
20:10:13 <sorear> @quote glguy .*funny.*
20:10:14 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
20:10:18 <chessguy> @quote glguy.funny
20:10:19 <lambdabot> No quotes match. Do you think like you type?
20:10:20 <dmwit> ?quote funny
20:10:21 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
20:10:21 * sorear beats up quote
20:10:29 <dmwit> ?help quote
20:10:30 <lambdabot> quote <nick>
20:10:30 <lambdabot> remember <nick> <quote>
20:10:30 <lambdabot> Quote somebody, a random person, or save a memorable quote
20:10:33 <chessguy> @quote beat
20:10:33 <Pseudonym> ?quote quote
20:10:34 <lambdabot> sorear says: for dealing with large numbers of people, euthenasia beats haskell in every way
20:10:34 <lambdabot> delicious-malicious-test says: @quote dmt
20:10:53 <dmwit> @quote dmt
20:10:53 <lambdabot> delicious-malicious-test says: @quote dmt
20:10:59 <chessguy> @quote dmwit
20:11:00 <lambdabot> lambdabot says: <dmwit> ?quote ?quote <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
20:11:10 <araujo> hello
20:11:12 <chessguy> @load dmwit
20:11:13 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
20:11:18 <dmwit> heh
20:11:27 * chessguy always gets a kick out of that
20:11:45 <sorear> ?quote glguy odd
20:11:46 <dmwit> Is dummy just the first plugin alphabetically or something?
20:11:46 <lambdabot> glguy says: that's odd, mine is this big : |-----------------------------|
20:12:17 <chessguy> beats me
20:12:46 <sorear>  @LOad  spell corrects as @REad
20:12:51 <sorear> @read foo
20:12:52 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
20:12:55 <sorear> @read "foo"
20:12:56 <lambdabot>  foo
20:12:59 <sorear> @help read
20:13:00 <lambdabot> read "<foo>". Print <foo>
20:13:14 <dmwit> ?read "3"
20:13:15 <lambdabot>  3
20:13:41 <sorear> ?read "\000foo"
20:13:42 <lambdabot>  
20:13:44 <ivanm> @type (^)
20:13:45 <Pseudonym> ?read "\127"
20:13:47 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:13:47 <lambdabot>  
20:13:52 <chessguy> @v
20:13:53 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
20:13:57 <Pseudonym> ?read "\127foo"
20:13:58 <lambdabot>  foo
20:14:08 <Pseudonym> ?read "\nfoo"
20:14:09 <lambdabot>  foo
20:14:09 <chessguy> @v
20:14:10 <lambdabot> Exception: <<loop>>
20:14:17 <dmwit> ?read "\32foo"
20:14:18 <lambdabot>   foo
20:14:20 <ivanm> @hoogle Int -> Int -> Int
20:14:21 <lambdabot> No matches, try a more general search
20:14:22 <dmwit> ?read "\032foo"
20:14:23 <lambdabot>   foo
20:14:29 <Pseudonym> That's right, it strips control characters.
20:14:29 <sorear> Pseudonym: nice try, it specifically strips newliney stuff
20:14:34 <Pseudonym> Yeah.
20:14:34 <chessguy> @hoogle (Num a) => a -> a -> a
20:14:36 <lambdabot> Prelude.(*) :: Num a => a -> a -> a
20:14:36 <lambdabot> Prelude.(+) :: Num a => a -> a -> a
20:14:36 <lambdabot> Prelude.(-) :: Num a => a -> a -> a
20:14:39 <sorear> Pseudonym: not all!
20:14:45 <chessguy> @hoogle+
20:14:48 <lambdabot> Control.Parallel.par :: a -> b -> b
20:14:50 <lambdabot> GHC.Conc.pseq :: a -> b -> b
20:14:50 <sorear> ?read "\001VERSION\001"
20:14:54 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c -> c) -> c -> m (gr a b) -> m c
20:14:58 <lambdabot>  VERSION
20:15:08 <sorear> <lambdabot>  ^AVERSION^A
20:15:09 <Pseudonym> ?read "\r\n\001VERSION\001"
20:15:09 <lambdabot>  VERSION
20:15:20 <chessguy> ?VERSION
20:15:21 <lambdabot> Unknown command, try @list
20:15:30 <Pseudonym> ?read "\r\n\001ACTION cries\001"
20:15:30 <chessguy> ?VERSION
20:15:30 <lambdabot>  ACTION cries
20:15:31 <lambdabot> Unknown command, try @list
20:15:44 <dmwit> ?read "ACTION\000cries"
20:15:45 <lambdabot>  ACTION
20:15:47 <sorear> of course there IS a way that works
20:15:54 <dmwit> So what just happened there?
20:16:00 <sorear> dmwit: C
20:16:06 <dmwit> Seriously?
20:16:10 <sorear> Seriously.
20:16:18 <sorear> think "Null terminator"
20:16:29 <dmwit> Oh, I guessed it.  But I couldn't believe it.
20:16:34 <dmwit> Even after you said it... =P
20:16:40 <dons> I'm not sure C got involved.
20:17:20 <sorear> hyperion is a very big C program
20:17:31 <chessguy> uh-oh, dons' has been watching as we prod his bot
20:17:33 <sorear> of course we know what it *should* be written in :)
20:17:41 <dons> seems odd. but yes, at least it wasn't lambdabot.
20:17:43 <chessguy> what's hyperion?
20:17:51 <sorear> freenode ircd
20:18:06 <dons> i find that scary.
20:18:39 <sorear> that someone would write an ircd in C, or that it truncates on nuls?  (or both?)
20:19:33 <chessguy> ?spell nuls
20:19:33 <dons> both.
20:19:34 <lambdabot> Nils nils nulls nu ls nu-ls
20:19:43 <chessguy> nu-ls?
20:19:55 <chessguy> is that some kind of molecule?
20:20:28 <sorear> NUL (one L) is the name of \0
20:20:33 <sorear> > show "\NUL"
20:20:35 <lambdabot>  "\"\\NUL\""
20:20:38 <chessguy> oh, interesting
20:20:44 <sorear> > show "\NULL"
20:20:46 <lambdabot>  "\"\\NULL\""
20:20:55 <chessguy> ?vera NUL
20:20:56 <sorear> odd.
20:20:57 <lambdabot> No match for "NUL".
20:20:59 <sorear> > show "\0"
20:21:01 <lambdabot>  "\"\\NUL\""
20:21:09 <sorear> doh.
20:21:12 <sorear> > "\0"
20:21:14 <lambdabot>  "\NUL"
20:21:29 <dmwit> > "\32"
20:21:30 <lambdabot>  " "
20:21:39 <dmwit> > "\96"
20:21:41 <lambdabot>  "`"
20:21:52 <dmwit> > ord 'A'
20:21:54 <lambdabot>  65
20:22:00 <thedward> Can I override functions in a derived class instance?
20:22:18 <sjanssen> thedward: nope
20:22:27 <thedward> alas.
20:27:38 <jargonjustin> thedward: You may want to take a look at newtype
20:34:42 <JohnMeacham> sorear: I know. I had to rebuild it from scratch. I have no idea what I did to screw it up... jusk 'darcs get' a new copy.
20:35:11 <sorear> I'll try again.
20:35:33 <sorear> At the time I sent the message, the command that failed was a ... fresh darcs get
20:35:52 <sorear> fresh darcs get still fails
20:36:05 <sorear> Applying patch 41 of 46... Unapplicable patch:
20:36:05 <sorear> Mon Apr  9 17:52:02 PDT 2007  John Meacham <john@repetae.net>
20:36:05 <sorear>   * move rules to Rules/ tree, clean up some code
20:36:05 <sorear> darcs: ./Makefile.in: openBinaryFile: does not exist (No such file or directory)
20:36:54 <sorear> fwiw, I'm getting 'darcs get http://repetae.net/repos/DrIFT'
20:37:37 <kc5tja> Confirmed -- I am too.
20:37:52 <kc5tja> I don't know what it is, but I thought I'd try it, and I second sorear's observation.  The repo is corrupt.
20:37:57 <kc5tja> darcs 1.0.9rc1
20:38:08 <JohnMeacham>  hrm... I have no idea what is going wrong then... it appears to happen in my working copy too...
20:39:23 <kc5tja> And now, it's back to coding on Kestrel's all-new cross compiler.  (Forth, not Haskell.)
20:53:00 <dolio> dons: I think there's a typo in figure 2 of your new stream fusion paper. At least, the copy I have.
21:04:24 <thedward> HXT is neat. I'm still mostly baffled by Arrows, but actually using HXT to process XML seems pretty straight forward.
21:05:05 <Cale> thedward: yeah :)
21:05:12 <Cale> There's not a whole lot to Arrows.
21:06:04 <Cale> They're pretty general. You can say a lot more about any particular arrow than you can say about all arrows.
21:06:43 <Pseudonym> Well, you can get free theorems out of them.
21:07:08 <Pseudonym> It's a little-known fact that some of the so-called arrow axioms are actually free theorems.
21:09:22 <thedward> I especially like the splitting and rejoining kind of action.
21:09:38 <thedward> I haven't played with any of the looping yet
21:10:33 <ivanm> Cale: that function you helped me with last night? I was doing it to convert my matrices from being [[a]] to IArray (Int,Int) a in the hope of a speedup, but it actually seems to be slower :(
21:10:59 <thedward> Hmm. There doesn't seem to be a way to generate a Module with the TH syntax lib.
21:12:32 <thetallguy> ?remember Cale: They're pretty general. You can say a lot more about any particular arrow than you can say about all arrows.
21:12:32 <lambdabot> Done.
21:14:18 <sorear> @quote Cale arrow
21:14:19 <lambdabot> No quotes match. Are you on drugs?
21:14:21 <sorear> @quote Cale: arrow
21:14:22 <lambdabot> Cale: says: They're pretty general. You can say a lot more about any particular arrow than you can say about all arrows.
21:14:52 <sorear> thedward: yes, since the TH syntax lib was for TH only
21:15:12 <ivanm> what's the LB command to find out what classess a type supports?
21:15:13 <thedward> sorear: but it is so much nicer than the other one. :)
21:15:21 <sorear> thetallguy: and since TH runs *after* renaming, it is simply impossible to splice in imports or modules
21:15:26 <sorear> thedward: agreed.
21:15:30 <sorear> ivanm: there is none
21:15:36 <sorear> ivanm: the ghci command is :info
21:15:49 <ivanm> isn't there? I'm sure someone was doing it yesterday...
21:16:00 <sorear> you may have been thinking of @instances, which only works the other way.
21:16:04 <thedward> I'm not really doing splicing, I'm just generating syntax trees to pretty print.
21:16:04 <sorear> @instances Integral
21:16:06 <lambdabot> Int, Integer
21:16:22 <sorear> no way to get from Int to Integral in LB :(
21:16:28 <ivanm> yeah, that's the one I was thinking of
21:16:31 <thetallguy> sorear: sorry, I don't follow.   What does TH have to do with Cale's quote?
21:16:38 <ivanm> must have gotten it confuses, thanks sorear
21:16:42 <ivanm> @instances Ord
21:16:43 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
21:16:58 <sorear> thetallguy: nothing
21:16:58 <thedward> thetallguy: I think he meant that for me.
21:17:14 <thetallguy> thedward: thanks, that makes mroe sense
21:17:16 <ivanm> is Array an extension library or something?
21:17:16 <sorear> thedward: I was pointing out that you @remembered Cale:, not Cale
21:17:18 <jcreigh> > () `compare` ()
21:17:20 <lambdabot>  EQ
21:17:21 <sorear> no, Array is H98
21:17:46 <ivanm> so why wasn't Array listed when I did @instances Eq?
21:17:53 <thedward> now I think he's doing it on purpose.
21:17:56 <sorear> because it's not in the Prelude
21:18:00 <thetallguy> I thought it was smarter than that
21:18:09 <sorear> @instances-importing Array Eq
21:18:10 <lambdabot> (), All, Any, Array i e, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
21:18:19 <ivanm> sorear: ahhhh
21:18:40 <ivanm> sorear: I was hoping to find out which Arrays support Eq :s
21:18:48 <ivanm> since Array.Diff doesn't seem to
21:18:49 <thetallguy> ?remember Cale They're pretty general. You can say a lot more about any particular arrow than you can say about all arrows.
21:18:49 <lambdabot> Done.
21:19:01 <thetallguy> It's worth putting in twice anyway.
21:19:04 <sorear> ivanm: Array.Diff isn't a real module, nor is it H98
21:19:16 <sorear> Data.Array.Diff is a non-standard ext
21:19:23 <sorear> not that the standard is good for much
21:19:30 <thetallguy> ?seen stepcut
21:19:31 <lambdabot> stepcut is in #haskell. I last heard stepcut speak 4h 1m 4s ago.
21:20:13 <ivanm> sorear: what do you mean the standard isn't good for much?
21:24:28 <sorear> ivanm: write a large program using only the h'98 language and libs
21:24:56 <sorear> even if you succeed in using the libs, the lack of hier modules will hurt
21:25:08 <sorear> OneBigFlatNamespace
21:25:49 <ivanm> *nod*... I thought you meant the standard Arrays or something :s
21:29:08 <dons> dolio: ok. what's the typo?
21:30:00 <dolio> dons: In the definition of foldr, go is defined with two parameters, but only ever used with one.
21:30:34 <JohnMeacham> I am getting my operating system code together from my archives... perhaps it would be a good fit with HOUSE/HOP/etc...
21:30:44 <dons> ah, yes.
21:31:14 <dons> go s = ..
21:31:17 <dons> the 'z' is a typo
21:35:38 <ivanm> what are the compilation flags I need to do to enable profiling again?
21:35:44 <sorear> -prof
21:35:52 <sorear> -auto-all -caf-all is recommended
21:36:02 <dons> dolio: i've updated the papers with that fix. thanks
21:36:17 <dolio> No problem.
21:36:17 <ivanm> thanks sorear... then its +RTS -p when running, isn't it?
21:36:19 <sorear> NB: some versions of GHC have a (reported) bug that causes link errors with -caf-all
21:36:23 <sorear> yes
21:36:32 <ivanm> which version of ghc? I've got 6.6...
21:36:55 <sorear> I forget, but trying isn't exactly hard :)
21:37:10 <ivanm> lol... didn't complain for me :D
21:37:47 <sorear> @where manual
21:37:48 <lambdabot> http://haskell.org/ghc/dist/current/docs/users_guide/
21:38:03 <sorear> ALL the profiling options are listed there (section 5 iirc)j
21:40:23 <ivanm> yeah, I've read through it before, just couldn't remember the flags off the top of my head
21:40:37 <ivanm> and I don't remember reading about -caf-all
21:41:26 <ivanm> are there general rules-of-thumb about inlining? i.e. when it will make a difference and when it won't?
21:42:19 <dons> small expressions: good, big expressions: bad
21:42:40 <ivanm> how small is "small"
21:43:23 <dons> -funfolding-creation-threshold=<N> small :-)
21:43:36 <dons>     (Default: 45) Governs the maximum size that GHC will allow a function unfolding to be. (An
21:43:39 <dons>     unfolding has a ?size? that reflects the cost in terms of ?code bloat? of expanding that
21:43:42 <dons>     unfolding at at a call site. A bigger function would be assigned a bigger cost.)
21:43:45 <dons>     Consequences: (a) nothing larger than this will be inlined (unless it has an INLINE pragma); (b)
21:43:48 <dons>     nothing larger than this will be spewed into an interface file.
21:44:11 <ivanm> how is the size of a function defined? size of the code? size when compiled?
21:44:56 <dons> ghc's heuristics. i think one of the simplifier papers would talk about this, actually.
21:45:07 <sorear> probably number of nodes in the core ast, or similar.
21:45:19 <ivanm> OK
21:45:22 <sorear> I know gCc uses count-of-il-instructions
21:45:36 <dons> roughly that, yes.
21:45:39 <sorear> so it wouldn't be implausible for gHc to use size-of-il too
21:45:46 <dons> perhaps some knowledge of how expensive primops are.
21:46:00 <dons> and let/case's
21:46:05 <ivanm> hmmm..... and I guess array manipulations would be too big then?
21:46:11 <dons> not necessarily.
21:46:19 <dons> we inline a lot in bytestring, and that's arrays.
21:46:23 <dons> arrays are Ptrs remember.
21:46:40 <dons> you sometimes need to `seq` values to get them exposed (and cheap enough) for the inliner, though.
21:46:44 <ivanm> as in each index value points to the location?
21:46:50 <ivanm> hmmm...
21:47:00 <sorear> bytestring uses foreignptrs, Array uses raw Array#
21:47:44 <sorear> are you using unboxed arrays?
21:47:51 <ivanm> I'm wanting to replace one particular cell in an array with a bunch of values, so I map \x -> the_array // (p,x)
21:48:08 <ivanm> sorear: I need to store lists in the array, so I don't think I can
21:48:09 <sorear> didn't you say you were using diffarray earlier?
21:48:31 <ivanm> I was wanting to try it, but it doesn't support Eq and Ord, and IIRC I'll be needing them later on
21:48:39 <ivanm> so I went back to IArray
21:48:42 <sorear> diffarray is (supposedly) extremely slow
21:48:55 <sorear> ivanm: how many elements do you update at a time?
21:48:56 <ivanm> is it? I thought it was meant to be faster than IArray...
21:49:25 <sorear> no, it's much slower within IArray's domain, and much slower within IOArray's domain
21:49:27 <ivanm> sorear: for this function, only one element in the array, but replacing it with multiple values
21:49:45 <sorear> uh, one element - one value, that's just the way arrays work
21:49:55 <ivanm> sorear: OK, I won't worry about diffaray then... so what's the point of using diffarray then? memory?
21:50:19 <sorear> when you are updating one element at a time, but you can't stomach the thought of monads.
21:50:25 <ivanm> sorear: I mean as in I'm creating a list of arrays, each one with a different value replacing the one at index i
21:50:38 <sorear> one element at a time updates kill IArray performance
21:50:40 <ivanm> sorear: *nod*... you mean like me :p
21:50:52 <sorear> !monads completely rules out IOArray
21:50:54 <ivanm> oh...
21:51:12 <sorear> so this array is NOT being used single-threaded?
21:51:28 <sorear> as in the old array is still used after the new one is made?
21:51:35 <ivanm> no, it isn't...
21:51:45 <ivanm> I have an array, where each cell contains a list
21:52:30 <ivanm> I go to the first cell with more than one value in the list, (say [a,b,c]) and create copies of that array such that I replace that cell with one of the values it previously had
21:53:08 <ivanm> i.e. if index i had [a,b,c], I create three new arrays, such that the first has (i,[a]), second has (i,[b]) and third has (i,[c])
21:53:09 <sorear> how do you create multiple copies without using the array multiple times?
21:53:34 <sorear> ah...
21:53:34 <ivanm> I do use it multiple times.... I create a list of new arrays
21:53:39 <ivanm> after that I don't use the old one again
21:54:00 <sorear> ok, you're problem is a bad fit for ALL of the haskell array implementations.  Sorry.
21:54:01 <ivanm> I was originally doing this with lists of lists for a 2D matrix, but wanted to try doing it with arrays in the hope of a speed-up
21:54:03 <sorear> I'd try a Map
21:54:11 <ivanm> OK, thanks
21:54:32 <ivanm> just use an (i,j) pair for the key value in the map?
21:54:54 <sorear> if you aren't using !! and can't unbox, lists should be the fastest option
21:54:55 <sorear> yes
21:55:12 <sorear> if you are using !!, you really want map
21:56:42 <ivanm> sorear: I'm not using !!... its just that I thought an array would be a better data structure to use for a matrix
21:57:09 <sorear> wild guess of the day:
21:57:10 <ivanm> and that around 15-20% of my runtime cost was doing transpositions, and with an array I figured I'd be able to avoid that
21:57:21 <sorear> are you writing Yet Another Sudoku Solver?
21:57:26 <sorear> transpositions?
21:57:34 <sorear> oh, matrix transpose
21:57:59 <dmwit> I'm going to bet Project Euler.
21:58:12 <ivanm> sorear: sort of... this is my Latin Squares project I was doing all over new years
21:58:13 <sorear> which one?
21:58:33 <ivanm> looking at ways of enumerating each possible isotopic class of Partial Latin Square
21:58:47 <ivanm> in the eventual hope of finding all those that fit a given criteria
21:59:02 <sorear> latin squares - is that the { permute 1..n^2 into a nxn array such that each linear sum is k } problem?
21:59:12 <ivanm> sort of...
21:59:22 <ivanm> each row/column has the values 1..n exactly once
21:59:26 <sorear> ah right.
21:59:28 <ivanm> partial latin squares are allowed to have some gaps
22:00:07 <ivanm> I was doing it as a summer scholarship at uni, did up a report on it, and am now looking at extending it
22:00:13 <sorear> so what does your matrix represent?
22:00:24 <ivanm> it took 15 seconds for order 4, then 5 days for order 5... I need to evaluate order 6
22:00:24 <sorear> is this some kind of non-determinism thing?
22:00:31 <ivanm> my matrices represent the latin squares
22:00:47 <ivanm> ummm.... not really non-determinism...
22:00:56 <ivanm> AFAIK, anyway...
22:01:22 <ivanm> I've got an idea on how I can improve my algorithm, but wanted to try improving the data structure at first if possible
22:01:37 <ivanm> problem is, as it stands most of my operations are on the row/column level
22:02:55 <ivanm> but at each stage of my recursive functions, I'm doing 2 transpositions, which I was trying to work out a way to avoid
22:03:02 <ivanm> oh well, back to the drawing board then
22:03:34 <sorear> do your latin squares care about diagonals?
22:06:09 <ivanm> sorear: nope...
22:06:35 <ivanm> just row-row comparisons, col-col comparisons and at the end row-col comparisons
22:07:14 <sorear> so basically, you just want to compute A40082?
22:07:14 <dmwit> ?hoogle [Bool] -> Bool
22:07:15 <lambdabot> Prelude.and :: [Bool] -> Bool
22:07:16 <lambdabot> Prelude.or :: [Bool] -> Bool
22:07:51 <ivanm> sorear: A40082?
22:07:57 <ivanm> @google A40082?
22:08:01 <lambdabot> http://www.accc.gov.au/content/index.phtml/itemId/744566
22:08:01 <lambdabot> Title: Myer Stores Limited - Authroisation - A40082
22:08:07 <ivanm> lol
22:08:15 <ivanm> @google A40082 sequence
22:08:16 <lambdabot> http://library.uws.edu.au/adt-NUWS/uploads/approved/adt-NUWS20060706.163501/public/05Chapter4.pdf
22:09:05 <dmwit> > let prime x = not . any ((== 0) . mod x) $ takeWhile (\n -> n * n <= x) primes; primes = 2 : filter prime [3,5..] in primes
22:09:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:09:32 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
22:09:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:09:42 <dmwit> Too slow for my needs. =(
22:10:45 <int-e> @pl \x y -> y `mod` x == 0
22:10:45 <lambdabot> flip flip 0 . ((==) .) . flip mod
22:11:20 <dmwit> \x -> (== 0) . flip mod x
22:11:29 <ivanm> sorear: A40082?
22:11:43 <dmwit> > nubBy (\x -> (== 0) . flip mod x) [2..]
22:11:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:12:25 <dmwit> > nubBy ((== 0 .) . flip mod) [2..]
22:12:25 <lambdabot>  Parse error
22:12:34 <dmwit> > nubBy (((== 0) .) . flip mod) [2..]
22:12:36 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:12:47 <sorear>     , ((modMask,               xK_t     ), spawn "sleep 0.1 ; exec /home/stefan/chvt 1")
22:12:55 <sorear> drat, pastebugger woes :)
22:12:58 <sorear> dmwit:
22:13:08 <sorear> > nubBy (((>1).).gcd)[2..]
22:13:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:13:13 <sorear> that's my minimal version
22:13:18 <sorear> ivanm: OEIS
22:13:18 <dmwit> whoo
22:13:31 <sorear> http://www.research.att.com/~njas/sequences/A040082
22:13:33 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
22:14:23 <ivanm> sorear: well, I want to actually create them, not just find how many there are...
22:14:51 <ivanm> also, I'm looking at _Partial_ Latin Squares, where you're allowed to have some blank cells, so there's a hell of a lot more than them :(
22:14:51 <sorear> there are gazillions, your program will be IO bound if you do that
22:15:19 <ivanm> sorear: only looking at small sizes
22:15:34 <ivanm> atm, mine does 5 in five days... I need it to do 6
22:19:02 <sorear> night all.
22:20:42 <ivanm> heya gour
22:20:57 <gour> ivanm: morning
22:22:24 <dmwit> ?hoogle (Eq a) => [a] -> ([a], [a])
22:22:25 <lambdabot> No matches, try a more general search
22:22:39 <dmwit> :t break
22:22:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:22:49 <dmwit> :t group
22:22:52 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
22:54:09 <scw>  /sb cl
23:01:26 <andrei> Hi; I have a question, I'm writing a function and I can't seem to get the type to be general enough
23:01:30 <andrei> iterateM p v = v:(v >>= \f -> iterateM p (p f))
23:01:40 <andrei> It works, aside from the fact that the type it has is
23:01:51 <andrei> iterateM :: (a -> [a]) -> [a] -> [[a]]
23:02:03 <andrei> I'm looking for a more general version that works on any monad
23:02:15 <andrei> Though I can't see why a list would be required here; any ideas?
23:02:52 <glguy> iterateM f x = liftM (x:) (f x >>= iterateM f)
23:03:16 <glguy> ?type \f x -> liftM (x:) (f x >>= iterateM f)
23:03:18 <lambdabot> Not in scope: `iterateM'
23:03:21 <glguy> heh
23:03:29 <narain> :t \p v -> v >>= \f -> iterateM p (p f)
23:03:31 <glguy> ?type let iterateM f x = liftM (x:) (f x >>= iterateM f) in iterateM
23:03:33 <lambdabot> Not in scope: `iterateM'
23:03:33 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> m [a]
23:04:42 <andrei> Thank you; I'll go try to figure out what's going on exactly
23:12:43 <dolio> If you notice, your original definition had the form 'iterateM p v = a:b', so you must be returning a list.
23:13:36 <dolio> It's not immediately clear why it isn't '(a -> m a) -> [a] -> [m a]', though
23:14:49 <dolio> Or, 'm a' instead of '[a]', I suppose.
23:14:58 <vincenz> > 736 / 393664
23:15:00 <lambdabot>  1.8696146967972687e-3
23:15:04 <vincenz> > 100*736 / 393664
23:15:06 <lambdabot>  0.18696146967972688
23:15:24 <dolio> That has to do with the expression with (>>=)
23:16:27 <ski> andrei : which monad 'm' do you have in mind using this for ?
23:18:09 <andrei> ski, No reason not to be able to use any monad with it
23:21:56 <ski> andrei : yes, but i wondered which monad(s) you wanted to use it with ..
23:22:46 <ski> since i think in many monads it will not give an answer (due to strictness)
23:23:14 <andrei> Yes, I'm working on something that will work with the IO monad
23:23:58 <ski> you could possibly get it to work in 'IO', using 'unsafeInterleaveIO'
23:24:41 <andrei> I was looking at that; but I'd rather see if I can find a version that doesn't require that
23:24:50 <ski> but e.g. in 'Maybe' or '[]', i think it will always give bottom
23:26:02 <eumenides> what's wrong with this code: http://hpaste.org/1364? i'm trying to make a client/server that talk back and forward but the client refuses to read
23:27:49 <stepcut> why doesn't this work ? catchError (error "whee" >>= return . Right) (return . Left) :: IO (Either IOError b)
23:29:12 <int-e> eumenides: can you receive the data in a separate thread? doing it in the same thread as sending is generally asking for trouble.
23:29:16 <Lemmih> Because 'error' doesn't throw an IOError?
23:29:31 <ski> > let iterateM f x = (x :) `liftM` (f x >>= iterateM f) in take 10 $ iterateM (\x rho -> 1 + x * rho) 0 2
23:29:32 <lambdabot>  [0,1,3,7,15,31,63,127,255,511]
23:29:37 <eumenides> int-e: ah okay
23:29:42 <ski> > let iterateM f x = (x :) `liftM` (f x >>= iterateM f) in take 10 $ iterateM (\x rho -> 1 + x * rho) 0 3
23:29:44 <lambdabot>  [0,1,4,13,40,121,364,1093,3280,9841]
23:30:41 <LeCamarade> @type iterateM
23:30:44 <lambdabot> Not in scope: `iterateM'
23:31:00 <LeCamarade> Oh. I see.
23:31:23 <LeCamarade> ?src unlines
23:31:24 <lambdabot> unlines = concatMap (++ "\n")
23:31:25 <int-e> eumenides: although hmm, your example should work. (the problem that I mean is that sockets have buffers of limited size on the OS side)
23:31:58 <eumenides> int-e: the server receives/sends, but the client only sends
23:35:44 <dmwit> ?src maximumBy
23:35:44 <lambdabot> Source not found. My mind is going. I can feel it.
23:36:08 <int-e> eumenides: ah, flushing is the first problem here - import System.IO and add  hFlush h  and  hFlush stdout  at appropriate places (or play with hSetBuffering)
23:38:14 <int-e> eumenides: and if you do that, uncommenting the reading works.
23:39:14 <int-e> without using additional threads actually.
23:40:31 <eumenides> int-e: yup, it does. thanks. should i use threads (STM?) anyway?
23:40:43 <dmwit> ?index maxBy
23:40:44 <lambdabot> bzzt
23:42:12 <int-e> eumenides: I can't give a clear answer. But it's not as important as I made it sound. (that was the C coder in me talking I guess)
23:47:05 <int-e> eumenides: if you have a request/response protocol then threads aren't necessary. if both sides can also send data without being asked then an extra thread for reading makes sense.
23:52:52 <eumenides> int-e: how would that work? if i use TChan it's practically the same since readTChan blocks until there's something in it
23:55:56 <int-e> eumenides: a Chan should suffice; the main purpose of the additional thread would be that the data actually gets read, even if it is not immediately processed.
