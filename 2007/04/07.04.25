00:00:41 <ddarius> johnnowak: And those cases can easily be explained by substituting equals for equals.
00:00:50 <Korollary> It's an implementation detail if you are sorting without caring.
00:00:52 <ddarius> Where as lacking TCO can not.
00:01:10 <Cale> johnnowak: When you're leaving a room, you never (or almost never) care about the continuation of that procedure, because it looks something like <process user input>; case <selection> of {1 -> go somewhere; 2 -> go somewhere else; ...}
00:01:45 <ddarius> Korollary: The problem is people essentially always care.
00:02:04 <johnnowak> Cale: aye, true
00:02:14 <Korollary> They care about pipeline stalls and cache misses too. Not at the beginner stage necessarily.
00:02:16 <whaleofconfusion> well, he does seem more reasonable in that article than he did before
00:02:42 <johnnowak> i'd like to see more things like Processing used to teach programming
00:03:04 <whaleofconfusion> he's not saying "bring the goto back" he's saying that it might help novices
00:03:11 <ddarius> Yes, but almost everybody always cares about asymptotic complexity whereas actual time/space usage is usually not cared about down to the level of cache misses etc.
00:03:36 <lispy> geez, i started a ghc build around...17:30, it's 00:02 now...still building
00:03:56 <ddarius> TCO and lacking TCO are only equivalent if you assume infinite memory.
00:04:37 <sjanssen> ddarius: strictness analysis changes the asymptotic space complexity, is it still okay to call it an "implementation detail"?
00:04:55 <sjanssen> changes the complexity in a lazy language like Haskell, that is
00:05:01 <ddarius> sjanssen: If it only makes it better, sure.
00:05:04 <johnnowak> lispy: with ghc, i prefer the term "steeping" too "building"
00:05:10 <whaleofconfusion> everything is an implementation detail
00:05:11 <ddarius> Making your code more efficient won't break it.
00:05:11 <johnnowak> s/too/to
00:05:19 <sjanssen> ddarius: TCO only makes space use better
00:06:07 <sjanssen> insisting that TCO isn't an implementation detail just because Scheme mandates it is a bit slippery
00:06:24 <ddarius> sjanssen: Where did I ever say that?
00:06:25 <sjanssen> should the standard insist on O(1) addition of machine integers?
00:06:50 <sjanssen> ddarius: I guess you didn't
00:06:55 <lispy> johnnowak: heh
00:07:03 <ski> (sjanssen : .. what would that mean ?)
00:07:13 <ddarius> Anyways, in my opinion, TCO isn't an "optimization", lacking it is a bug.
00:07:29 <johnnowak> lispy: there's something to be said for not writing language implementations in themselves :)
00:07:57 <ddarius> Also, without strictness analysis, you can still get the effect with strictness annotations.  TCO is not the same, not in any reasonable way.
00:08:20 <whaleofconfusion> funny thing, in that article he lists 2 authors who he claims did studies that say that goto is easier for beginners, but googling each of their names plus the word "goto" turns up nothing relevant
00:08:24 <lispy> i would agree here that without TCO scheme is silly to define
00:08:31 <ddarius> Ultimately, the difference to me is that lacking TCO affects your (possible) programming styles.
00:08:50 <ddarius> lispy: Scheme at least has do, it's good to go.  Haskell would be SOL.
00:09:23 <ddarius> whaleofconfusion: Then ask him to provide references.
00:09:25 <lispy> ddarius: ah yeah, i hadn't thought about haskell but yeah
00:09:27 <sjanssen> ddarius: note that Haskell doesn't require TCO in the report
00:09:37 <lispy> sjanssen: it doesn't?
00:09:47 <ddarius> sjanssen: Note that Haskell doesn't require lazy evaluation either.
00:10:06 <sjanssen> lispy: the report is quite liberal
00:10:26 <QtPlatypus> whaleofconfusion: Its interesting that he doesn't give cites for the studies.  I know its not needed for informal writing but normally refrences of some sort would be included.
00:10:39 <lispy> so, it dosn't require lazy eval explicitly, but the semantics dictate the requirement of compute by demand, right?
00:10:55 <sjanssen> ddarius: right, lazy evaluation is an implementation detail
00:11:25 <Lor> lispy, no, e.g. optimistic evaluation is a legit implementation method, too
00:11:33 <ddarius> sjanssen: Indeed.  One that can improve the asymptotic complexity no less.
00:12:06 <ddarius> lispy: The key point is that call-by-name (v. call-by-need) is, as far as I can tell, a legitimate implementation strategy for Haskell.
00:13:07 <lispy> ddarius: well, in some sense lazy eval ~= call-by-name + clever  caching to avoid recomputing things?
00:13:23 <kilimanjaro> yes, but it's not really that clever
00:13:31 <lispy> Lor: how is optimistic eval different than eager eval?
00:13:44 <ddarius> lispy: Hence it being an implementation detail, albeit one that leads to asymptotic space and time savings.
00:14:01 <LeCamarade> You know, I wrote this small app in Haskell that I tend to depend on a lot, because of its easy extensibility. It is called comma, and is called with a single comma on the shell. Need I go on?
00:14:01 <lambdabot> LeCamarade: You have 3 new messages. '/msg lambdabot @messages' to read them.
00:14:05 <ddarius> lispy: You give up after a while.
00:14:26 <pejo> lispy, the optimistic evaluation was work done by Ennals, that tried evaluating things and then gave up if they took 'too long'.
00:14:39 <lispy> okay
00:14:42 <kilimanjaro> lispy, what really matters is the termination properties of programs
00:15:24 <lispy> LeCamarade: i'm totally lost as to what you're getting at :)
00:15:55 <lispy> kilimanjaro: i can see that, i just sometimes get confused by how things affect termination
00:17:12 <LeCamarade> Well, what I am getting at is a shrewd chance to hpaste the damn thing and get you guys to see its utility...
00:17:14 <LeCamarade> For example, on my shell, when I type `, google.com' it runs this command `w3m google.com'. The comma program translates it. And it is portable across all shells. And it is extensible in any langauge.
00:17:47 <lispy> LeCamarade: cool, so hpaste it and let's see it!
00:18:08 <merus> hpaste! go!
00:18:16 <Cale> !hpaste
00:18:21 <lispy> !paste
00:18:22 <hpaste> Haskell paste bin: http://hpaste.org/
00:18:40 <LeCamarade> Because there is a .comma file that has a series of commands, each of which is called with the argument passed to ,. It is written in Haskell, of course.
00:18:48 <LeCamarade> If any of the commands returns a non-empty string, that is the command that will be executed. So, I have one called `runurl', and it translates all URLs I type into calls to w3m(1) with that URL. Nifty, no?
00:19:32 <ski> @where hpaste
00:19:33 <lambdabot> I know nothing about hpaste.
00:19:53 <ddarius> @where whyfp
00:19:53 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
00:20:03 <ddarius> @where+ hpaste !hpaste
00:20:03 <lambdabot> Done.
00:20:09 <ddarius> @where hpaste
00:20:09 <lambdabot> !hpaste
00:20:20 <ddarius> @where+ hpaste !paste
00:20:20 <lambdabot> Done.
00:20:22 <ddarius> @where hpaste
00:20:22 <lambdabot> !paste
00:20:22 <hpaste> Haskell paste bin: http://hpaste.org/
00:20:28 <lispy> nice
00:21:26 * LeCamarade slides off to hpaste.
00:22:43 <dolio> ?where zap
00:22:44 <lambdabot> ?where zap
00:23:15 <lispy> ?where botwar
00:23:16 <lambdabot> I know nothing about botwar.
00:23:25 <dmwit> ?quote dmt
00:23:26 <lambdabot> delicious-mailicious-test@quote says: dmt
00:23:45 <dmwit> Er?
00:23:47 <dmwit> ?quote dmt
00:23:48 <lambdabot> delicious-mailicious-test@quote says: dmt
00:23:53 <ddarius> @where corewar
00:23:53 <lambdabot> I know nothing about corewar.
00:24:04 <m4St3R_b41T3R> ?quote test
00:24:05 <lambdabot> Lemmih says: dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
00:24:17 <m4St3R_b41T3R> ?quote rep
00:24:17 <lambdabot> Kahdloc says: why's it called filter and not grep? :/
00:24:41 <dmwit> ?quote regex
00:24:41 <lambdabot> lambdabot says: <dmwit> ?quote ?quote <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
00:24:47 <dmwit> Bah!
00:25:10 <dmwit> ?quote vend
00:25:10 <lambdabot> sebazzz says: <elpolilla> y venden bulks y esas mierdas <sebazzz> bulks llenos de pastabase
00:26:04 <m4St3R_b41T3R> ?quote reppie
00:26:04 <lambdabot> No quotes match. Take a stress pill and think things over.
00:27:33 <hpaste>  LeCamarade pasted "comma - The Universal Extensible Shell Extension. A Lambda of Sorts." at http://hpaste.org/1563
00:27:52 <LeCamarade> Ahem.
00:28:11 * LeCamarade awaits the boos and hisses. Shivers to think he wrote code that may be spat at ...
00:30:00 <nominolo> LeCamarade: sequence . map = mapM
00:30:10 <nominolo> @src mapM
00:30:10 <lambdabot> mapM f as = sequence (map f as)
00:30:34 <LeCamarade> nominolo: Noted. Merci beaucoup.
00:32:16 <nominolo> @hoogle findBy
00:32:17 <lambdabot> No matches found
00:32:40 <dmwit> LeCamarade: Are you under Gnome or KDE?
00:33:38 <LeCamarade> dmwit: Neither. Both suck. xmonad. Kidding. :oD It's XFCE.
00:33:47 <dmwit> Ah, okay.
00:33:56 <nominolo> LeCamarade: regarding your home ++ [pathSeparator] ++ ...  there is a filepath operator for that:  </>
00:34:08 <dmwit> I asked because I have "alias o=gnome-open" in my .zshrc. =)
00:34:12 <LeCamarade> When I type a file that ends in .hs to comma, it opens in my editor. vi, of course. Nifty.
00:34:36 <ivanm> LeCamarade: what's , meant to do?
00:34:41 <dmwit> It does something similar to ,.
00:35:16 <ivanm> and ,. is?
00:35:40 <LeCamarade> ivanm: To figure out what I want to do. Laziness, Hubris, Impatience. I hate typing vi somefile.hs. I want some program to figure out that I want to vi the file, not to run it.
00:35:55 <dmwit> ivanm: I meant that , does a similar thing to gnome-open.
00:36:05 <ivanm> dmwit: heh
00:36:12 * ivanm has no idea what gnome-open is
00:36:19 <LeCamarade> dmwit: Yeah, I figured that kid of thing exists (XFCE has a similar thing), but I wanted a program I have written to do the choosing.
00:36:42 <LeCamarade> nominolo: Merci beaucoup! (This is pretty much why I post my stuff here.)
00:36:48 <ivanm> LeCamarade: *nod*, so its like how xfce has xfterm4, etc, which symlinks to the terminal program of your choice?
00:36:49 <LeCamarade> @karma+ nominolo
00:36:50 <lambdabot> nominolo's karma raised to 1.
00:37:15 <sjanssen> @tell sorear nevermind, I got your patch
00:37:15 <lambdabot> Consider it noted.
00:37:59 <LeCamarade> ivanm: Exactly. Only this time, when I say ', e file.jpg', it opens it in my image editor. And ', file.jpg' will add it to my mail. :oD
00:38:27 <ivanm> why ","?
00:38:38 <LeCamarade> It's all automated, of course. In Haskell. Perfomance could be better, but I can't set up daemons to do the choosing and still keep it useful.
00:39:09 <LeCamarade> ivanm: , is really easy to type, and is not part of POSIX shell syntax. It is a valid file name. :oD
00:39:21 <ivanm> fair enough
00:39:24 <Cale> LeCamarade: You might be interested in the program unp for unpacking arbitrary compressed files.
00:39:38 * ivanm uses unfoo
00:40:15 <ivanm> or there's atool, which also compresses/views arbitrary compressed file
00:40:17 <ivanm> *files
00:40:39 <LeCamarade> Cale: I am currently running apt-get install unp. yay!
00:41:37 <ivanm> Cale:  what's unp written in, do you know?
00:41:42 <ivanm> unfoo is just a bash script
00:41:53 <Cale> I don't know what it's written in
00:42:38 * LeCamarade goes off to write a program that will enable him to say ', file.tar.gz', and have the unpacked files there, with the original tar.gz file deleted. :oD Bless comma. Bless unp. Bless atool.
00:42:42 <ivanm> atool is done in perl
00:42:52 <ivanm> LeCamarade: atool
00:43:03 <ivanm> oh, wait, you mentioned it :s
00:43:06 <LeCamarade> ivanm: I am apt-getting it, too.
00:46:51 * LeCamarade puts comma under the knife. Adding a conf file, ".,". There will be two of them. Can't pass up the chance for some madness. :oD
01:00:21 <LeCamarade> @src liftM
01:00:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:20:44 <LeCamarade> The snobbish Haskell guy writes his module import list in alpahabetical order.
01:20:44 <LeCamarade> I feel sorry for whoever I'll be boss over.
01:22:30 <ivanm> LeCamarade: ?
01:24:07 <LeCamarade> ivanm: In that paste of mine, for example. I wrote the imported module in alphabetical order. And it will be a requirement for the people I'll employ. :oD
01:25:15 <ivanm> heh
01:25:15 * ivanm generally imports in terms of when he had to use it, and how important that library is
01:25:15 <ivanm> i.e. modules that I only use to get short-cut functions (like Arrow's ***) will generally go last
01:26:18 <dobblego> why does everyone say that a googol is the largest named number, while a centillion appears to be larger?
01:26:20 * LeCamarade feels his evil veins swelling about the head.
01:26:20 <kolmodin> :D
01:26:20 <kolmodin> a good IDE would help you with that. if we get any
01:26:23 <quicksilver> much better to group import lists logically than alphabetically, IMO
01:26:23 <quicksilver> I would do {haskell core libs} {3rd party libs} {other modules from this project}
01:26:31 <LeCamarade> Oops. System.IO came lower down. Not practicing what I preach ...
01:26:41 <quicksilver> Often I would split the haskell core libs further, into data structures and IO stuff
01:26:48 <quicksilver> dobblego: only silly people say that
01:26:55 <dobblego> quicksilver, say what?
01:27:02 <quicksilver> dobblego: graham's number is much larger, and there are other large named numbers
01:27:11 <quicksilver> dobblego: say that a googol is the largest named number
01:27:38 <LeCamarade> google ^ googol ^ graham's number ^ centillion. _C'est le numéro le plus grand!_
01:28:05 <ivanm> isn't googolplex > googol?
01:28:21 <dolio> googolplex = 10^googol
01:28:23 <dolio> So, yes.
01:28:25 <dobblego> I think I meant that anyway
01:28:45 <quicksilver> well googolplex > centillion
01:29:04 <quicksilver> centillion is 10^(101*3) or something like that
01:29:07 <ivanm> is aleph0 > googolplex?
01:29:19 <quicksilver> yes, ivan, although that's a different '>' now
01:29:22 <mux> it would be fun to make a #haskell team for ICFP 2007 programming contest
01:29:33 <ivanm> quicksilver: in what way?
01:29:38 <LeCamarade> If the largest number is unsigned, this is the largest number: 0 - 1.
01:29:44 <quicksilver> ivanm: the previous '>' was the total order on natural numbers
01:29:48 <merus> ?where mtl
01:29:49 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
01:30:53 <quicksilver> ivanm: your '>' is the total order on ordinals
01:30:53 <ivanm> *nod*
01:30:53 <ivanm> *nod*
01:30:53 * ivanm hasn't done much number theory, mainly just numerics
01:31:55 <quicksilver> ivanm: which is quite a bit more subtle
01:31:56 <quicksilver> aleph0 isn't a 'number' in the same sense
01:32:10 <ivanm> yeah, I know
01:32:16 <ivanm> its a countable infinity
01:33:25 <quicksilver> it's a specific order-type of countable infinities
01:33:50 <quicksilver> the simplest one
01:34:15 <quicksilver> No, that's backwards
01:34:17 <quicksilver> :)
01:34:29 <quicksilver> aleph0 is a cardinality
01:36:36 <ivanm> yeah, but its also an infinite value
01:36:37 <ivanm> and I've heard it called a "countable infinity", as opposed to aleph1
01:39:48 <Cale> googolplex is also a cardinality
01:40:07 <Cale> (but yeah, it's not the same > )
01:43:21 <Cale> aleph_1 is intended to be the next largest cardinal after aleph_0, but it's undecidable in ZFC whether aleph_1 is the cardinality of the real numbers, or a smaller uncountable cardinal.
01:43:23 * quicksilver looks the other way and hopes no one will draw attention to the way he got alephs and omegas switched around
01:44:25 <Cale> Well, it's common to identify cardinals with the smallest ordinals having that cardinality.
01:45:14 <Cale> Heh, some guy on reddit got really pissed that someone linked to xkcd via an outgoing redirect on fbi.gov.
01:45:33 <Cale> He claimed that it was an instance of phishing.
01:46:33 <eumenides> is there some way to express {-# NOINLINE fun1, fun2,..,funN #-} or do i have to write it for every function?
01:48:06 <roconnor> @pl \x y z -> f x (g y z)
01:48:06 <lambdabot> (. g) . (.) . f
01:48:27 <roconnor> @pl \x y z -> g (f x y) z
01:48:27 <lambdabot> (g .) . f
01:49:09 <Cale> Er, above that should have been "next smallest" of course :)
01:49:09 <Cale> eumenides: hmm
01:49:09 <Cale> I'll check the GHC documentation :)
01:49:10 <Cale> hmm, it doesn't look like it
01:50:02 <dmwit> Cale: Why is "smallest" wrong?
01:50:25 <Cale> dmwit: "next largest"
01:51:22 <Cale> I meant either "next larger" or "next smallest" :)
01:52:11 <dmwit> I don't understand.  Don't we associate aleph0 with omega?
01:52:11 <dmwit> Actually, scratch that question.  I just don't understand what you mean by "next".
01:52:11 <eumenides> Cale: oh right, ghc docs. i should take the time to read them sometime
01:52:11 <eumenides> the community here's so great there's been no need so far woo!
01:54:26 * merus <3 Control.Monad.Reader
01:54:48 <Cale> My ping time has been varying wildly between none at all and over a minute.
01:54:49 <quicksilver> I don't really understand Cale's correction either. I think his comment is fine as written.
01:54:49 <quicksilver> omega is the smallest ordinal of cardinality aleph0
01:55:33 <dmwit> quicksilver: Okay, so it's not just me. =)
01:55:33 <Cale> "aleph_1 is the next smallest cardinal after aleph_0"
01:55:56 <dmwit> AH!
01:56:06 <dmwit> We were talking about different sentences... =P
01:56:10 <Cale> okay
01:56:16 <quicksilver> ah, me too :)
01:56:43 <quicksilver> although in common english 'next smallest' and 'next largest' are interchangeable
01:56:48 <quicksilver> both mean 'next in order of size'
01:57:13 <quicksilver> and both are potential ambiguous in terms of whether you're going up or down :P)
01:57:19 <quicksilver> great language, isn't it?
01:57:25 <merus> no, not really.
01:59:27 <nominolo> i think, it's funny that in english not not x = not x
02:00:32 <nominolo> at least in many phrases ..
02:00:34 <dolio> In English it's typically x.
02:00:34 <dolio> Hence people complaining when others use double negatives.
02:00:34 <Cale> Yeah, yeah.
02:00:34 <LeCamarade> Oh, Dear Leader!
02:00:34 <LeCamarade> > take 5 $ show [1 ..]
02:00:34 <LeCamarade> > take 10 $ show [1 ..]
02:00:34 <quicksilver> I think it's funnier that and=rd
02:00:34 <quicksilver> and=or, even
02:00:37 <lambdabot>  "[1,2,"
02:00:37 <lambdabot>  "[1,2,3,4,5"
02:01:17 <dmwit> nominolo: For example?
02:01:17 <dolio> Spanish is different, I think. You might say "no hay nunca," which would be "there isn't nothing."
02:01:17 <LeCamarade> @bot
02:01:18 <dolio> Whereas in English you'd say, "there isn't anything."
02:01:18 <lambdabot> :)
02:01:25 <LeCamarade> LB is dead?
02:01:32 <LeCamarade> @slap lambdabot
02:01:32 <lambdabot> why on earth would I slap lambdabot
02:01:49 <dmwit> Wow, I am lagging out like crazy.
02:01:50 <nominolo> dmwit: "There ain't no difference."
02:01:53 <Cale> I'm having lots of lag issues too.
02:02:06 <Cale> and there's nothing on my end to explain it, so it must be freenode's fault :)
02:02:12 <dmwit> nominolo: Oh, come on...
02:02:15 <LeCamarade> @uptime
02:02:15 <lambdabot> uptime: 2d 2h 16m 40s, longest uptime: 5d 20h 57m 59s
02:02:25 * LeCamarade is back to sprint.
02:04:04 <dolio> nominolo: That's incorrect usage, though. Although people do say it.
02:04:04 <dolio> But, for instance, when Bill S. Preston Esquire says, "non-non-non-non-heinous," he really means "heinous."
02:04:04 <Cale> * Ping reply from Cale: 76.81 second(s)
02:04:05 <nominolo> dmwit: maybe those kinds of sentences are not so common in academic circles .. :)
02:06:12 <dmwit> Cale: ouch
02:06:13 <nominolo> oh, ok then
02:06:53 <dmwit> * Ping reply from dmwit: 96.71 second(s)
02:06:57 * dolio just got hit with the lag stick as well.
02:06:57 <dmwit> * Ping reply from dmwit: 0.17 second(s)
02:14:30 <matthew-_> errr, sorry, this is really off topic. Does anyone have an ipv6 link to the real world an can try pinging an address for me please?
02:16:46 <ToRA> matthew-_ : do i?
02:17:03 <matthew-_> No Tris, DoC only use ipv6 on the link layer for routers.
02:17:17 <snappy> 2001:470:1f00:3724:ffff::2
02:17:21 <snappy> oh
02:17:24 <matthew-_> yep, that'll do!
02:17:25 <ToRA> fair enough
02:19:45 <swiert> @tell ndm I haven't heard from Dimitry regarding TMR. Do you have any other way of getting in touch with him?
02:19:45 <lambdabot> Consider it noted.
02:34:47 * LeCamarade discovered F#, so he's doing Ocaml so he can program on .NET in Ocaml. F#, that is.
02:34:47 <LeCamarade> @google F# Microsoft
02:34:49 <lambdabot> http://research.microsoft.com/projects/ilx/fsharp.aspx
02:34:49 <lambdabot> Title: This page has been replaced
02:36:50 <LeCamarade> And I hope aja finishes the .NET/Haskell hack soon. And there is such fat latency here.
02:46:24 <LeCamarade> @seen LeCamarade
02:46:25 <lambdabot> You are in #haskell. I last heard you speak just now.
02:46:39 <Neil|Work_> smart bot
02:48:17 <LeCamarade> Carmethene: I thought she'd also note that I'm in #sml, as well. And a fight would break out between her and smlbot.
02:56:19 <Carmethene> are you anthropomorphising software?
02:56:19 <Carmethene> :)
02:57:10 <vali> hello. what does "Cons a b" mean?
02:58:42 <swiert> vali: apply the constructor "Cons" to two arguments, "a" and "b".
02:58:58 <swiert> Does anyone have a good link about associated types?
02:59:03 <MarcWeber> vali: Usually Cons a b means creating a list. Thus Cons 2 (Cons 3 (Cons 4 Nil)) or something like that gives you a kind of linked list containing 2 3 4. In haskell you usually don't use Cons but : thus 1:2:3:[]  (you can also write [1,2,3]
02:59:56 <vali> aaah. thank you. it's like a "Node a (Node b)" in a linked list
03:02:10 <MarcWeber> vali: Yes. But I haven't seen Cons in haskell often. You can find this in lisp and ml very often (I think, don't know those languages that well)
03:02:40 <vali> MarcWeber: oh, okay. i found it in a tutorial. i get it now
03:03:07 <Carmethene> Haskell doesn't have Cons does it?
03:03:26 <Carmethene> it's definitely in a few forms of Lisp and Scheme
03:03:49 <Carmethene> my understanding was that Haskell tutorials used it due to the similarities to Scheme, but you can put anything you like there
03:04:16 <Carmethene> ie: data List a = Nil | Cons a (List a)      or      data List a = Monkey | Squirrel a (List a)
03:05:30 <quicksilver> ':' is the name for Cons
03:05:35 <Cale> (:) is called cons
03:05:38 <Cale> yeah
03:05:43 <Carmethene> yeah, I meant the literal 'Cons'
03:05:44 <quicksilver> unlike a lisp-dialect, of course, it's a homogeneous cons
03:05:52 <Carmethene> ah now that bit I didn't know
03:05:52 <quicksilver> the literal 'Cons' is not part of the standard library, no
03:06:04 <Carmethene> quicksilver :: what do you mean by homogenous cons?
03:06:05 <earthy> is (,) the heterogeneous cons then? :P
03:06:13 <Carmethene> oh same type
03:06:18 <quicksilver> Carmethene: 1 : "foo" : [] is illegal
03:06:20 <Carmethene> (still haven't woken up)
03:06:30 <quicksilver> (but fine,  in lispen)
03:06:50 <Carmethene> sure, lisps don't tend to be strongly typed
03:07:09 <Carmethene> my functional programming teacher at uni used to say "strong types for weak minds"
03:07:16 <Carmethene> but then he had a 3ft beard
03:07:40 <earthy> ghe
03:07:41 <dmwit> > let cons = (,) in 3 `cons` 4 `cons` "hello"
03:07:44 <lambdabot>  ((3,4),"hello")
03:07:54 <dmwit> Whoops, that's snoc.
03:08:09 <quicksilver> Carmethene: long beards for short minds, I say
03:08:17 <Carmethene> :)
03:08:28 <Carmethene> I wish I was a student again :(
03:08:33 <quicksilver> > let cons = (,) in 3 `cons` 4 `cons` "hello" `cons` ()
03:08:36 <lambdabot>  (((3,4),"hello"),())
03:08:41 <earthy> would that be a teacher that eschews the use of cars, as cars are for weak bodies?
03:08:44 <quicksilver> > let cons = flip (,) in 3 `cons` 4 `cons` "hello" `cons` ()
03:08:46 <lambdabot>  ((),("hello",(4,3)))
03:08:59 <Carmethene> earthy :: you've met him!? ;)
03:08:59 <dmwit> > let infixr 7 cons; cons = (,) in 3 `cons` 4 `cons` "hello" `cons` ()
03:09:00 <lambdabot>  Parse error
03:09:08 <MarcWeber> Whe have that heterogenious Cons as well (see HList ...  ;) It's called HCons there.
03:09:09 <quicksilver> dmwit: you need something to stand in for 'nil', perhaps () is the right choice
03:09:28 <dmwit> quicksilver: Why? Just to detect the end?  The type checker will do it for you. ;-)
03:10:32 <earthy> > let infixr 7 <:>; (<:>) = (,) in 3 <:> 4 <:> "hi" <:> ()
03:10:32 <lambdabot>  (3,(4,("hi",())))
03:11:38 <quicksilver> dmwit: well, if you're trying to model a LISP-y list
03:11:48 <quicksilver> dmwit: if you're just tryign to store heterogenous data in tuples, then sure :)
03:22:00 <proski> ....
03:22:26 <proski> shit
03:23:02 <Cale> ?
03:24:03 <quicksilver> who knows. address harvesting maybe
03:24:07 <Botje> "oh no, this isn't the channel for #haskell brand soap"
03:25:55 <nominolo> if you want to model heterogenous lists, use [Dynamic] or HList
03:25:59 <merus> It was probably the fear of monads.
03:26:02 <nominolo> depending on requirements
03:26:15 <DRMacIver> Dynamic?
03:26:27 <nominolo> > toDyn 5
03:26:29 <lambdabot>  <<Integer>>
03:27:02 <nominolo> > fromDyn $ head [ toDyn 5, toDyn "foo" ]
03:27:03 <lambdabot>  Add a type signature
03:27:12 <nominolo> > fromDyn $ head [ toDyn 5, toDyn "foo" ] :: Int
03:27:13 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> a'
03:27:24 <dmwit>  > let data Loop a = Loop a deriving Dynamic in toDyn (Loop 3)
03:27:26 <nominolo> > (fromDyn $ head [ toDyn 5, toDyn "foo" ]) :: Int
03:27:27 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> a'
03:27:34 <dmwit>   <<Loop>>
03:27:49 <nominolo> > let x = x in x
03:27:50 <lambdabot>  Exception: <<loop>>
03:28:16 <nominolo> DRMacIver: basically it tags types
03:28:23 <nominolo> :t fromDyn
03:28:25 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
03:28:49 <nominolo> > 1 + fromDyn (toDyn 42)
03:28:50 <lambdabot>   add an instance declaration for (Num (a -> a))
03:28:50 <lambdabot>     In the expression: 1 + (...
03:29:06 <dmwit> > 1 + fromDyn (toDyn 42) 37
03:29:08 <lambdabot>  43
03:29:18 <dmwit> > 1 + fromDyn (toDyn "42") 37
03:29:20 <lambdabot>  38
03:29:36 <nominolo> ah, it takes a default value
03:29:40 <nominolo> ok, makes sense
03:30:01 <dmwit> I think I might have preferred a Maybe return type.
03:30:03 <nominolo> > hNil
03:30:04 <lambdabot>   Not in scope: `hNil'
03:30:32 <nominolo> :t fromDynamic
03:30:35 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
03:30:41 <nominolo> there it is
03:30:44 <dmwit> nice
03:31:12 <quicksilver> > (flip fromDyn (error "cast failed") . head $ [toDyn 5, toDyn "foo"]) :: Integer
03:31:12 <nominolo> @src fromDyn
03:31:13 <lambdabot> fromDyn (Dynamic t v) def
03:31:13 <lambdabot>   | typeOf def == t = unsafeCoerce v
03:31:13 <lambdabot>   | otherwise       = def
03:31:13 <lambdabot>  5
03:31:22 <quicksilver> that's how you do it :)
03:31:36 <quicksilver> fromDyn takes its args in the wrong order, imo
03:31:58 <quicksilver> > (flip fromDyn (error "cast failed") . head $ [toDyn 5.5, toDyn "foo"]) :: Integer
03:32:00 <lambdabot>  Exception: cast failed
03:32:12 <nominolo> you could write: (`fromDyn` (error "bla))
03:32:13 <dmwit> :t maybe
03:32:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:35:36 <araujo> morning!
03:36:04 <DRMacIver> nominolo: Cool.
03:37:02 <nominolo> DRMacIver: it's a bit messier than in dynamic languages though
03:37:13 <nominolo> since you need to tag and untag a lot
03:37:31 <int-e> @type typeOf
03:37:34 <lambdabot> forall a. (Typeable a) => a -> TypeRep
03:37:45 <quicksilver> it's really not a very good idea
03:37:52 <quicksilver> unless it is, actually, what you need
03:38:06 <nominolo> and you need to implement the Typable instance.  Though i think ghc can derive this
03:38:06 <Cheery> say, does there exist something like unwordsHtml ?
03:38:12 <Cheery> in Text.Html
03:38:22 <quicksilver> normally you're much better served by an algebraic type which expressed exactly what you mean
03:38:39 <merus> What is the @ in a pattern match called?
03:38:50 <quicksilver> data Atom = QInt Integer | QString String; foo = [QInt 3, QString "foo"]
03:39:09 <int-e> merus: hmm. 'as'?
03:39:09 <quicksilver> really 'Dynamic' is just the extension of this to 'every typeable storeable type'
03:39:17 <quicksilver> @info Dynamic
03:39:17 <lambdabot> Dynamic
03:39:45 <nominolo> merus: or "of shape"?
03:40:00 <merus> Oh, I see.
03:40:02 <merus> Thanks.
03:42:14 <quicksilver> I read it as 'as'
03:43:02 <dmwit> I like "as".
03:43:15 <dmwit> I always used to read it as "enveloping," but now that just seems to cumbersome.
04:37:25 <dons> re.
04:37:41 <Vq^> dons: wb
04:40:51 <matthew-_> hey dons. When's the next HWN coming out?
04:41:04 <dons> tomorrow, i reckon
04:41:14 <matthew-_> did DisTract make it in? ;)
04:41:19 <dons> i was hanging out for the next TMR issue, but its late, so i'll just put out HWN
04:41:22 <dons> it will, yes.
04:41:26 <matthew-_> many thanks.
04:41:33 <szabi_> LeCamarade: are you interested in a python to haskell conversion?
04:41:33 <dons> did you see it on reddit?
04:41:54 <matthew-_> dons: yeah, I was just googling to see if google had found the site yet, and it popped up on reddit first!
04:41:58 <swiert> dons: I'mm waiting for one or two authors to give me the green light.
04:42:10 <mux> dons: what do you think about creating a #haskell team for ICFP'07 programming contest? :-)
04:42:13 <mux> could be a lot of fun
04:42:22 <szabi_> LeCamarade: I've already started but I don't know haskell well, so I would like to see another solution
04:42:28 <szabi_> LeCamarade: it's aroung 150 lines
04:43:04 <dons> swiert: ok.
04:43:10 <dons> mux, i think we should have 2 or 3 teams
04:43:21 <szabi_> @seed LeCamarade
04:43:22 <lambdabot> LeCamarade is in #haskell. I last heard LeCamarade speak 1h 55m 4s ago.
04:43:27 <dons> we've got 300 people here, so that's 100 teams :-)
04:43:43 <mux> dons: I'm all for it :)
04:44:07 * SamB_XP is too slow
04:44:41 <matthew-_> sheesh, #haskell will be a ghost irc channel for those two days of July
04:45:32 * mux wants to be in dons and dcoutts' team, heheh
04:45:34 <SamB_XP> maybe I'll actually be able to find my name in the scrollback when the tab is blue... except, of course, that I wouldn't go to school to let the scrollback get so large anyway...
04:46:16 <SamB_XP> a job would be nice, though
04:47:26 <Carmethene> today's question... I think I understand the concept of a monad but I'd like some confirmation that I'm on the right lines ;)
04:47:41 <Carmethene> let's say I have a function with a side effect such as generateRandonNumber
04:48:12 <Carmethene> in order to do this in a functional way, I have to change the way it works such that the world state (which we'll call WS) is functional
04:48:48 <Carmethene> so instead of: grn :: Int, I have grn :: WS -> (WS, Int)
04:48:55 <matthew-_> yep
04:49:03 <Carmethene> and successive calls to grn must use the correct instance of WS
04:49:17 <Carmethene> so I have: ws' = grn ws
04:49:20 <matthew-_> the do syntax correctly routes that WS stuff around
04:49:21 <Carmethene> ws'' = grn ws'
04:49:22 <Carmethene> etc
04:49:40 <Carmethene> right, so a monad is just a way of packaging up WS so it's not explicitly in the syntax?
04:49:46 <matthew-_> yep, but the syntax you use would be do { rndNumber <- grn }
04:50:01 <Carmethene> oh sure, it was pseudocode
04:50:04 <matthew-_> yes, exactly.
04:50:27 <Saizan> Carmethene: yes, you are describing the State monad, other monads "hide"  different things :)
04:50:37 <Carmethene> ahhh
04:50:40 <quicksilver> Carmethene: Monad Hide Plumbing
04:50:47 <Carmethene> so what sort of monads are there?  or rather, what sort of things can you hide?
04:50:49 <quicksilver> damn, missed an 's' from the buzzphrase
04:50:50 <matthew-_> The way I think about it is that you're just simply not allowed to do side effectful computations. Every function must fully declare its inputs and outputs. If they happen to include snapshots of the real world then so be it.
04:51:08 <Carmethene> I assume the IO monad just hides some concept of IO state (although I'm not sure what that would actually be)
04:51:18 <quicksilver> Carmethene: you can hide an 'environment', multiple execution paths, possible failure
04:51:31 <quicksilver> Carmethene: restricted output, general IO
04:51:38 <quicksilver> or some mixture of the above
04:51:39 <Carmethene> what's restricted output?
04:51:49 <quicksilver> append-only
04:51:51 <quicksilver> (for example)
04:51:53 <Carmethene> ah
04:51:53 <quicksilver> like a log file
04:51:56 <Carmethene> gotcha
04:52:08 * Carmethene thinks
04:52:27 <Carmethene> 'possible failure'... could you elaborate a bit more please?
04:52:49 <Carmethene> can't get my head around that
04:52:50 <matthew-_> Carmethene: in GHC, IO looks like: newtype IO a = GHC.IOBase.IO (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
04:53:15 <Carmethene> *nods*
04:53:19 <Saizan> Carmethene: that would be the Maybe monad, where each function can return Just somthing, or Nothing
04:53:25 <matthew-_> Carmethene: look at the Maybe type or the Either type. Both are instances of Monad and are typically used for dealing with computation that can fail
04:53:37 <Carmethene> oh I understand the Maybe thing, but I didn't realise that was actually a monad
04:53:52 <quicksilver> Carmethene: the monad part lets you hide the nested case statements
04:54:03 <quicksilver> Carmethene: if you use maybe as failure, you end up with code like this:
04:54:03 <Carmethene> I understood Maybe to be a set of possible values
04:54:08 <Carmethene> so it was just the same as 1 and 2
04:54:09 <Saizan> try to write return and >>= for it :)
04:54:12 <Carmethene> fo example
04:54:34 <quicksilver> case x of Just y -> (case f y of Just z -> x ; Nothing -> Nothing) ; Nothing -> Nothing
04:54:35 <matthew-_> yeah, so the "hidden state" that gets passed around is kinda the success of the last operation : i.e. if it's Nothing then no further operations will be called.
04:55:02 <quicksilver> Carmethene: this rapidly gets a bit messy, and the Maybe monad hides all that crap
04:55:13 <Carmethene> oh hold on
04:55:27 <Carmethene> so the Maybe monad is different to: data Maybe a = Nothing | Just a
04:55:37 <Saizan> it's not
04:55:57 <matthew-_> that's the definition of the Maybe type. That type also implements a class called Monad.
04:56:08 <Carmethene> ahhhhh
04:56:11 <Saizan> well, the monad part is that return and >>= are defined for it
04:56:28 <Carmethene> so I can use Maybe in a non-monadic way, but what you're talking about is an extra level of syntactic sugar
04:56:38 <matthew-_> absolutely.
04:56:43 <Carmethene> right, with you now :)
04:56:52 <Carmethene> this isn't actually that complex
04:57:05 <Carmethene> the Haskell learning curve is like this: | then -
04:57:14 <mux> the Maybe monad is soooo usefu
04:57:27 <Carmethene> thanks for the information :)
04:57:36 <quicksilver> Carmethene: monads are really just syntactic sugar
04:57:39 <Saizan> quicksilver example can be written as do {  y <- x; f y }
04:57:44 <quicksilver> Carmethene: although the effect is more profound
04:58:00 <Carmethene> quicksilver :: that's what I'm finding :0
04:58:06 <quicksilver> Carmethene: but really, they're just anothing kind of abstraction
04:58:11 <Carmethene> I love this language
04:58:18 <quicksilver> they allow you to abstract things which procedural abstraction doesn't manage
04:58:24 <quicksilver> like common parameters and so on
04:58:30 <quicksilver> threaded variables
04:58:50 <Carmethene> looking forward to trying threading
05:00:40 <Carmethene> lunchtime (aka Guitar Hero 2), thanks again :)
05:02:06 * matthew-_ is miffed that Guitar Hero 2 wins out over Haskell hackery
05:03:04 <quicksilver> it will pass
05:03:12 <quicksilver> guitar hero is ephemeral
05:03:18 <quicksilver> haskell will always be here
05:06:44 <matthew-_> when they defined html, why did they think that people would only want to define tables in row-major order? It seems an odd thing to think.
05:07:05 <Botje> they didn't.
05:07:08 <quicksilver> why do you think they were thinking at all?
05:07:13 <quicksilver> that seems like a very odd thing to think...
05:07:14 <Botje> but row-based ordering *DID* speed up rendering
05:07:18 <norp> they choose the order most people would want i suppose
05:07:31 <quicksilver> no, they just didn't think, at all, in any way
05:07:36 <quicksilver> they just wrote something and wrote a browser
05:07:52 <quicksilver> and actually most browsers couldn't incrementally layout tables for a LONG time
05:07:59 <quicksilver> so if that was the reason, it didn't work :P
05:08:18 <Botje> they could if you gave the width and height in advance, no?
05:08:23 <matthew-_> nah, thought would have gone into 4.0 and probably 3.2 too. And the w3c have just restarted the HTML working group. So hopefully more thought will appear...
05:08:40 <quicksilver> matthew-_: right, thought did go in to 4.0, but it was too late then :)
05:08:57 <quicksilver> HTML is really only fit to be written by computer programs, not by humans
05:09:00 <mux> the future of HTML is now supposedly the WHATWG
05:09:06 <quicksilver> and how hard is it to prepend "transpose . "
05:09:08 <quicksilver> ? :)
05:14:42 <vick> data Tree a = Leaf a | Node (Tree a) (Tree a)
05:14:50 <vick> what is that 'a' ?
05:14:58 <quicksilver> 'some type "a";
05:15:24 <vick> quicksilver: what ?
05:15:34 <quicksilver> 'a' means "some type, called 'a'"
05:15:39 <savanni> It allows you to create a data type of "Tree Integer" or "Tree String", or whatever you want.
05:15:53 <quicksilver> or "some type, which we will call 'a'"
05:15:54 <savanni> So "Tree" can be applied with any data type at all.
05:16:08 <Saizan> it's called "type variable"
05:16:08 <vick> Do i need to define 'a' beforehand ?
05:16:12 <quicksilver> no
05:16:17 <quicksilver> it's any type
05:16:19 <vick> or is it something built in for 'any type' ?
05:16:20 <vick> oh ok.
05:16:20 <quicksilver> not a particular type
05:16:29 <vick> That's a nice feature.
05:16:33 <quicksilver> it's not special, you could use b or apple or giantkillermonkey
05:16:38 <savanni> Right, what you would do is, when you define a function, it might look like "func :: Integer -> Tree Integer"
05:17:06 <quicksilver> I normally define my types using giantkillermonkey and enormouspeacefulshrew as type variables
05:17:08 <matthew-_> quicksilver: no, it won't work if you call it giantkillermonkey.
05:17:14 <vick> but shouldn't it be data Tree = Leaf a | Node (Tree) (Tree)
05:17:16 <savanni> Very much so.  The sexy type system is why I am switching to Haskell.
05:17:49 <quicksilver> vick: no, because then you could tell the different types of Tree apart
05:18:06 <quicksilver> vick: 'data Tree a =' introduces the definition of a *family* of types
05:18:14 <quicksilver> vick: 'Tree a' for each possible type a
05:18:16 <vick> oh
05:18:23 <quicksilver> vick: so Tree Integer is a type, so is Tree String, etc
05:18:26 <vick> So Tree Integer is one type, Tree Double is another, etc.. ?
05:18:28 <vick> oh ok.
05:18:29 <quicksilver> right
05:18:35 <vick> quicksilver: Thanks a lot.
05:18:40 <vick> Thanks a lot everybody, brb.
05:19:14 <Saizan> Tree is also called type constructor because of this
05:19:36 <foxy-om> > let twins = (\(x1:x2:xs) -> if (x1 + 2 == x2) then (x1:x2:(twins (x2:xs))) else twins (x2:xs)) in nubBy (==) $ twins $ nubBy (\x y -> mod y x == 0) [2..]
05:19:38 <lambdabot>  [3,5,7,11,13,17,19,29,31,41,43,59,61,71,73,101,103,107,109,137,139,149,151,1...
05:20:42 <vick> What's the diffrence between Node (Tree a) (Tree a) and Node (Tree a, Tree a) ?
05:21:29 <matthew-_> The first is a constructor which takes two values, the second is a constructor which takes one value.
05:21:33 <foxy-om> @remember quicksilver I normally define my types using giantkillermonkey and enormouspeacefulshrew as type variables
05:21:34 <lambdabot> Done.
05:21:51 <foxy-om> @quote
05:21:51 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
05:21:54 <matthew-_> operationally, not much I guess. But the left version is the typically used version
05:21:59 <quicksilver> vick: semantically, nothing
05:22:08 <quicksilver> vick: just different syntax to access the components
05:22:11 <quicksilver> ehem
05:22:14 <quicksilver> not quite nothing :)
05:22:22 <quicksilver> you can put _|_ in one more place
05:22:27 <quicksilver> but for most purposes, nothing
05:22:51 <vick> My mind is dirty, what's the _|_ ?
05:22:52 <LeCamarade> szabi_: Sorry, I wasn't attentive. You still there?
05:23:06 <LeCamarade> vick: :oD It's called `ottom'.
05:23:15 <foxy-om> try typing data Tree a = Node a ; Node (Tree a, Tree a)
05:23:16 <quicksilver> vick: similarly, there is no difference between data Pair = Pair Int Int and newtype Pair = (Int,Int)
05:23:18 <LeCamarade> Bottom.
05:23:32 <quicksilver> vick: it's just a way of naming your tuple, really
05:23:38 <bakert> can this be done as a one liner?  		market_p = []
05:23:38 <bakert> 		[market_p.extend(self._market_pages(args)) for args in sport_p if args]
05:23:39 <vick> oh ok.
05:23:42 <quicksilver> vick: different places you can have divergence
05:23:43 <LeCamarade> Oh, so you knew.
05:23:47 <quicksilver> vick: but I wouldn't worry about that
05:23:50 <bakert> oops wrong window
05:23:52 <bakert> sorry
05:23:55 <vick> k thanks again :D
05:23:55 <LeCamarade> szabi_: Are you there?
05:24:12 * LeCamarade thinks it's his turn to wait on szabi_. :oD
05:24:17 <Saizan> bakert: in haskell it could :D
05:25:23 <bakert> i know THAT!
05:25:31 <bakert> sometimes we must write in python ...
05:26:26 <LeCamarade> szabi_: Gimme the code so I can do the conversion ... :oD
05:26:27 <LeCamarade> @seen szabi_
05:26:28 <lambdabot> szabi_ is in #haskell. I last heard szabi_ speak 43m 6s ago.
05:27:02 <szabi_> lambdabot: one sec
05:27:51 <LeCamarade> @tell szabi_ I wasn't attentive when you hit me. I'm back, now.
05:27:51 <lambdabot> Consider it noted.
05:28:12 <szabi_> LeCamarade: so, how do you want to get it?
05:28:13 <lambdabot> szabi_: You have 1 new message. '/msg lambdabot @messages' to read it.
05:29:27 <MarcWeber> Do you know of accessor function for tuples ? (Such as \ (_,_,x,_) -> x ) Are they already defined somewhere?
05:29:40 <quicksilver> except for fst and snd, they are not
05:29:54 <quicksilver> good style would seem to push you away from large tuples and into named types
05:30:29 <norpan> i almost only use tuples as return values from functions, and then you do let (x,y,z) = function ...
05:30:45 <eumenides> or use ((x,y),z)
05:31:17 <mahogny> which library for loading. saving and manipulating images is recomended?
05:31:49 <mahogny> speed is quite critical
05:31:49 <kolmodin> I didn't see this until now: http://osnews.com/story.php/17744/Xmonad-a-Tiling-Window-Manager-Written-in-Haskell
05:31:52 <lambdabot> Title: Xmonad: a Tiling Window Manager Written in Haskell - OSNews.com, http://tinyurl.com/yurcy5
05:32:29 <quicksilver> mahogny: I'm not at all sure there is a good one
05:32:43 <quicksilver> mahogny: gtk2hs contains image loading parts, I imagine
05:32:56 <mux> yeah, you can load images pretty easily through gtk
05:33:30 <mahogny> yeah, that pretty much sums it up. all these libraries are conneded to either SDL, wx, gtk or something else. I wouldn't mind avoiding dependencies if possible
05:33:41 <LeCamarade> szabi_: Ummm ...
05:33:47 <mahogny> since I have to make shitty binary distributions
05:33:48 <foxy-om> @src fst3
05:33:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:34:06 <foxy-om> @hoogle (a,b,c) -> a
05:34:07 <lambdabot> No matches, try a more general search
05:34:10 <LeCamarade> Maybe ... can you put it on some web location?
05:34:27 <matthew-_> mahogny: err, libgd or imagemagick I guess, but you'll probably have to write the haskell api yourself I'd guess.
05:34:36 <LeCamarade> szabi_: If you can upload it somewhere, I can pull it down and convert it.
05:34:46 <quicksilver> imagemagick is powerful but I don't know if it's particularly fast
05:34:49 <szabi_> LeCamarade: I have msgd the location
05:34:55 <Saizan> there's a gd binding on hackage
05:35:16 <LeCamarade> szabi_: Dunno if I'll get the msg, seeing as my nick is not registered,
05:35:25 <mahogny> hm. right. I gotta browse through hackage too
05:35:34 <szabi_> LeCamarade: http://roberta.obuda.kando.hu/szabi/torque.py
05:35:35 * LeCamarade notices a catch 22.
05:36:18 <LeCamarade> szabi_: Downloading ...
05:37:06 <quicksilver> you need to be regged to send messages but not to receive them
05:37:07 <quicksilver> AFAIK
05:37:21 <quicksilver> although if the receiver turns the feature off, then anyone can send him messages
05:37:27 <quicksilver> I believe I have it turned of myself
05:38:45 <nominolo> @where hlist
05:38:46 <lambdabot> http://homepages.cwi.nl/~ralf/HList
05:39:02 <LeCamarade> szabi_: Hmm ... Uses Scientific.Physics ... don't have that here. I'll give it a rag, all the same.
05:39:52 <szabi_> LeCamarade: you can remove that line and the PQ-s. next if something is not working just remove the method calls
05:40:42 <szabi_> LeCamarade: umm. not that easy. there will be at least one place where the unit will be wrong.
05:41:46 <LeCamarade> szabi_: It's all supposed to work. Because I can't figure out the goal if I don't see it run. It has no comment.
05:41:47 <szabi_> LeCamarade: but I don't really care about if it's not working well, I just want to see how would it look like in haskell if somebody else writes it.
05:42:23 <szabi_> LeCamarade: the variable names are very descriptive :)
05:43:18 <LeCamarade> szabi_: Yeah. Descriptive. Lemme give it a shot.
05:43:57 <szabi_> LeCamarade: it's about simulating a motorbike from the viewpoint of the engine (it's torque, acceleration and other properties are what I'm interested in)
05:45:40 <szabi_> LeCamarade: and it's not finished... It does not calculate the actual acceleration (some numbers are hacked in :) )
05:46:31 <LeCamarade> szabi_: Do I see the use of a time counter in there?
05:47:48 * LeCamarade thinks the code is quite lambda-happy ... you will spit at Py3000. :oD
05:48:21 <szabi_> LeCamarade: yes. the world starts at zero second. it's tick method updates the current time and simulates some physical interactions
05:48:57 <szabi_> LeCamarade: the only 'actor' here is the bike which includes the engine, drivetrain and wheel
05:49:28 <szabi_> LeCamarade: what do you mean by lambda-happy
05:49:29 <szabi_> ?
05:51:26 <LeCamarade> szabi_: It uses the lambda keyword a lot. And it is getting dropped. Go Haskell now. :oD Also, this depends on PQ for many basic things, but there is no PQ here, so I am driving blind ...
05:52:51 <szabi_> LeCamarade: ok. I can remove PQ. It's mainly there for checking
05:54:28 <LeCamarade> szabi_: Yeah, seems so. Mainly in assertions. Just give me the algorithm, if you can break it down like that, so that I don't have syntactical/library barriers. The algorithm looks basic enough. (Most of the code is class scaffolding).
05:59:32 <szabi_> LeCamarade: http://roberta.obuda.kando.hu/szabi/torque-pq.py
06:00:57 <szabi_> LeCamarade: algorithmically it's nothing. But that's ok. I can rewrite an algorithm in haskell. My main consern is the representation of the classes I'm using in python
06:01:15 <case> hello, what's wrong with this line? : filter ('(head s1)'/=) s2
06:01:19 <case> s1 and s2 are strings
06:01:24 <mahogny> cabal - I have some system headers in a non-standard directory. what is the best way of making cabal understand this?
06:02:19 <LeCamarade> szabi_: Okay, getting that.
06:02:32 <alan_> hi
06:02:37 <LeCamarade> case: You have those apostrophes in your code?
06:02:43 <case> yes
06:02:54 <case> i wan't to use the head of s1 for the boolean expression
06:02:58 <case> but i don't know how :)
06:03:03 <alan_> what language is used to write most modern DSL's?
06:03:12 <Saizan> just filter (head s1 /=) s2
06:03:15 <szabi_> alan_: java :D
06:03:25 <case> Saizan: let me try
06:03:46 <LeCamarade> > let trim s1 s2 = filter ((head s1) /=) s2 in trim "T should go" "This That Them"
06:03:47 <lambdabot>  "his hat hem"
06:03:57 <LeCamarade> case: No apostrophe.
06:04:12 <LeCamarade> case: Seen?
06:04:50 <case> it's still buggy here, let me clean up my script, hangon :)
06:05:00 <LeCamarade> case: Although it would give an error in case s1 is an empty string.
06:05:13 <case> ah ok, but that is catchable
06:05:25 <alan_> this sounds M$'y but who here likes powershell?
06:05:35 <dons> i like monads better :-)
06:05:41 <alan_> monads?
06:05:45 <alan_> oh
06:05:45 <mahogny> alan_, functional languages in general are The languages if are going to write a compiler/interpreter. haskell has very strong parsing libraries
06:05:49 <alan_> IO monad
06:05:50 <ddarius> case: Actually it's not in Haskell 98.
06:05:50 <LeCamarade> case: Forget catching. Just create a case that would take care of the empty s1.
06:06:11 <alan_> mahogny: yes i know, it sounds sad
06:06:21 <mahogny> sad? :(
06:06:36 * LeCamarade trundles off back to szabi_'s stuff.
06:06:39 <case> LeCamarade: oh, that's what i meant
06:06:46 <alan_> mahogny: yes, that they dont use functional
06:06:50 <LeCamarade> case: :oD
06:07:13 * LeCamarade thought you were thinking Java in Haskell. :oD
06:07:21 <case> it works!
06:07:38 <mahogny> alan_, well, if someone wants to waste time and money, let them. add some salt in their wounds by writing the same thing in less time using FP and make it available before them ;)
06:07:59 <alan_> mahogny: or just laugh
06:08:01 <alan_> :)
06:08:07 <dons> mahogny: that's the spirit!
06:08:31 <case> note to self, remember to connect the bouncer to this channel :)
06:08:38 <ccvp> hello fellow internet addicts - are we all looking forward to another long & glorious day of irc? yet again, eat, shit, wake up, rinse/repeat/recycle
06:09:08 <mahogny> which UI-libraries in haskell plays well with macosx? that is, native look and feel
06:09:24 <LeCamarade> I'll never be able to understand why FP hasn't yet conquered the world. Never. Except that Just $ the academics over-colonise and patronise it too much. else Nothing. -> Maybe.
06:09:27 <dons> mahogny: wxhaskell or gtk2hs, are it basically. there are some cocoa bindings too, i suspect
06:09:29 <mahogny> I have gotten extremely tired of c++ + qt so I think I'm gonna sell in another language
06:09:30 <LeCamarade> Maybe Why.
06:09:42 <mahogny> dons, so both work well?
06:09:51 <AStorm> ccvp: add "studying" to that :P
06:09:52 <dons> mahogny: gtk2hs would be the best bet
06:10:04 <mahogny> I know what Xchat looks like under macosx. but maybe the port is screwed
06:10:06 <dons> mahogny: its the best maintained, by quite a distance
06:10:21 <dylan> gtk doesn't ever look native.
06:10:24 <ccvp> A storm
06:10:30 <ccvp> we are nothing more then ants on an ant farm
06:10:35 <ccvp> we drive from point A to point B every day
06:10:38 <dons> ccvp: learning haskell?
06:10:40 <ccvp> and eat, shit, sleep, wake up
06:10:47 <alan_> I would like someone to write a gui framework using svg
06:10:48 <ccvp> goto work, come home, rinse/repeat/recylce
06:10:49 <ccvp> for 80 years
06:10:50 <ccvp> then we die
06:10:52 <dons> ccvp: because this is a "please stay on topic" channel
06:10:59 <mux> alan_: GTK+ is now fully vector-based
06:11:04 <mux> and has SVG support
06:11:09 <alan_> mux: oh wow
06:11:17 <mux> alan_: recent gtk engines use cairo for drawing widgets
06:11:18 <dons> yeah, and gtk2hs supports some of the vector stuff
06:11:19 <alan_> @hoogle svg
06:11:19 <LeCamarade> szabi_: I'm going to put as much classing as you have, in there...
06:11:23 <lambdabot> No matches found
06:11:33 <mux> alan_: I'm writing a chess game UI that extensively use Cairo and SVG
06:11:45 <mux> the board and the pieces are SVG files, the rest is drawn (very easily) using Cairo
06:11:54 <mahogny> I guess I can put it like this; can you see difference between a native macosx application and a gtk2hs application? I'm afraid my supervisor is a mac fanatic -_-
06:11:58 <szabi_> LeCamarade: ok. Do it as you like
06:12:01 <dons> mux, you should blog about your haskell graphics stuff :-)
06:12:34 <mux> dons: I'm not much of a blogger guy, and I've been busy with many stuff lately which prevented me from doing significant progress
06:12:41 <mux> but I'll soon have a 5 days week end :-)
06:12:41 <malcolmw> wxHaskell looks pretty native on a Mac
06:14:52 <ddarius> It should.
06:15:38 <alan_> is visual haskell any good?
06:16:17 <mahogny> doesn't work too well under BSD
06:16:43 <chessguy> hi all
06:17:01 <LeCamarade> chessguy: Hi.
06:17:09 <vali> hello chessguy
06:17:25 <chessguy> LeCamarade: how did your duel with your boss go?
06:17:57 * ddarius hears "The Dust Brothers".
06:19:07 <LeCamarade> chessguy: Not yet done. He still has some stuff to fix before both of us are allowed to draw guns. Of course I'll win.
06:19:38 <LeCamarade> I mean, it takes a map for everything in the spec. :oD A map and a monad.
06:20:35 <plutonas> sjanssen: what is the browser on the second screenshot of xmonad?
06:28:48 <LeCamarade> szabi_: Still on the interpolated_curve ... :o/
06:31:55 <szabi_> LeCamarade: it's purpose is to map rpm's to torque. So you give it a list of values and the step between the values, and you can query the value at any point because it interpolates
06:32:25 <LeCamarade> szabi_: I get it, already. Working on it.
06:32:25 <matthew-_> plutonas: it could be firefox with the emacs mode installed
06:32:40 <plutonas> firefox with emacs mode!!!
06:33:09 <plutonas> do you have a link?
06:33:23 <matthew-_> err, the last time I looked at that plugin was a few years ago and I couldn't make it work. So that's a rough guess!
06:33:41 <plutonas> oh
06:33:43 <LeCamarade> szabi_: Where you used a two-member constant-size array, Haskell uses a tuple. That way, the members can afford to be of different types, which maps well to Py.
06:33:56 <quicksilver> plutonas: http://conkeror.mozdev.org/
06:33:58 <lambdabot> Title: mozdev.org - conkeror: index
06:34:03 <quicksilver> plutonas: I imagine that's what matthew-_ is referring to
06:34:06 <plutonas> ah conkeror
06:34:08 <plutonas> i know that
06:34:11 <quicksilver> plutonas: I've no idea if it's what sjanssen uses
06:34:17 <LeCamarade> plutonas: At least there is no emacsearch.
06:34:24 <LeCamarade> @go visearch.com
06:34:27 <lambdabot> http://visearch.com/
06:34:27 <lambdabot> Title: vi search: using commands of vi to search
06:34:44 <plutonas> ok, i have to go, but i'll leave this buffer open to see his answer
06:34:45 <plutonas> :-)
06:34:52 * LeCamarade jumps about. `We win, we win!'
06:35:47 <LeCamarade> Okay, me too. I am redirecting into my IRC to my vi.
06:36:14 <matthew-_> quicksilver: yep, that's the one I meant. and the screenshots don't look much like that on the xmonad site so I guess it's not really the same.
06:36:46 <thorat> dons: in h4sh/DOC, there is "Following Oleg[ref], we require...", but there's no info on "[ref]" and I didn't find anything on Oleg's page.  So what's the reference?
06:37:23 <szabi_> LeCamarade: I don't think I'm using constant-size arrays. The lists given to the interpolated_curve constructor are just examples. When using real curves the size should be at least 100
06:38:13 <LeCamarade> szabi_: Oh! Oh, okay. I see it, now. Changing that ... was wondering why you skipped tuples... :oD
06:38:40 * LeCamarade sees it.
06:44:26 * Saizan is being attracted to the dark side of metaprogramming to solve rankN type problems ..
06:55:35 <vick> data Course = String Int, data Courser = Heh String Int, what's the diffrence between these two ?
06:55:43 <vick> Given that Heh is not defined.
06:55:54 <Saizan> you are definig Heh there
06:56:03 <int-e> vick: the first defines a data constructor called String
06:56:13 <Saizan> when you define a data type, you must define its constructors
06:56:19 <int-e> vick: which is allowed but will cause no end of confusion
06:56:52 <vick> data <My New Type Name> = <Constructor Name> String Int etc.. ?
06:56:53 <Saizan> in this case Heh :: String -> Int -> Courser
06:57:22 <Saizan> yep
06:57:26 <vick> What does the Constructor do ?
06:57:31 <LeCamarade> szabi_: Types are still eating me, but ... we keep going ...
06:57:53 <Saizan> it builds a value of your type given the argumets you are specifing
06:58:12 <szabi_> LeCamarade: I'm almost finished but it's looking bad. very, very bad :)
06:58:25 <LeCamarade> vick: Maybe you should do it like this.
06:58:35 <vick> Saizan: So latter if i want to use type Courser, i'd go Heh "Saizan" 4 ?
06:58:36 <LeCamarade> s/do it/look at it/
06:58:46 <Saizan> vick: yes
06:58:56 <LeCamarade> Yes.
06:59:00 <vick> Saizan: What about the case with 'Course' ?
06:59:13 * LeCamarade runs away, not to bother Saizan :oD
06:59:14 <int-e> vick: you could use  String 42  then
06:59:14 <vick> Saizan: How would i make a data of type Course ?
06:59:30 <int-e> vick: which would be of type Course.
06:59:32 <Saizan> vick: as int-e said :)
06:59:37 <vick> String 42 ?
06:59:42 <LeCamarade> szabi_: It is the elegance I'm trying for that is murdering me.
06:59:44 <vick> oh.
06:59:52 <vick> i see now.
07:00:07 <vick> So Course doesn't contain any string, it contains only integer
07:00:10 <Saizan> yes, you'll be using String as the name of your contructor in that case, and not as the name of the type we use for strings
07:00:18 <Saizan> vick: exactly
07:00:18 <int-e> vick: right
07:00:41 <vick> Doesn't that conflict with anything of the name 'String' in haskell ?
07:00:44 <szabi_> LeCamarade: I though so. I just don't know enough haskell to make it look nice, yet. But when it works I'll try to beautify it
07:00:56 <int-e> vick: no. String is only used for a type alias in Haskell
07:01:03 <vick> for [Char] , right ?
07:01:06 <int-e> vick: and types and data constructors are in different namespaces.
07:01:08 <Saizan> type names are in a different namespace
07:01:09 <int-e> vick: right
07:01:20 <vick> int-e: But shouldn't that give a conflict ?
07:01:40 <vick> String is defined once as type String = [Char] and another as a constructor name for the data type Course ?
07:01:50 <int-e> vick: this is allowed:   data Foo = Foo Int Int; in fact for simple tuples this is often a good choice
07:01:57 <vick> int-e: oh ok
07:02:03 <vick> i just got the namespaces thing now :d
07:02:09 <vick> Thanks a lot everybody.
07:02:26 <int-e> vick: it's always clear from the syntactical context whether the identifier is a type or a data constructor.
07:02:31 <LeCamarade> szabi_: Yes, that's the strategy. Worse is better. :oD
07:04:50 <Saizan> is ther a way to tell ghci to save .hi and .o in a different directory from your .hs? it's annoying to not be able to spoil tab completion..
07:05:05 <malcolmw> -hidir -odir
07:14:05 * LeCamarade swears mildly at his type problems ...
07:26:26 <szabi_> if I have 'data T1 = T1 Int deriving Show' how can I override the way 'show' represents it?
07:26:48 <dylan> remove deriving Show and write your own instance
07:26:57 <chessguy> ?src Show
07:26:58 <lambdabot> class  Show a  where
07:26:58 <LeCamarade> data T1 without the deriving part.
07:26:58 <lambdabot>     showsPrec :: Int -> a -> ShowS
07:26:58 <lambdabot>     show      :: a   -> String
07:26:58 <lambdabot>     showList  :: [a] -> ShowS
07:27:06 <LeCamarade> I see you are ahead of me.
07:27:18 <LeCamarade> next, you create an instance of show down there.
07:27:39 <LeCamarade> Should I give you a sample at hpaste?
07:27:51 <chessguy> do showsPrec and showList have default implementations?
07:28:12 <szabi_> LeCamarade: I think I can manage
07:28:17 <dblhelix> chessguy: they do
07:28:21 <chessguy> ?src showsPrec
07:28:22 <lambdabot> showsPrec _ x s = show x ++ s
07:28:23 <szabi_> LeCamarade: I have started some days ago :)
07:28:24 <LeCamarade> Good.
07:28:32 <LeCamarade> You're ahead of me, thougj. Way ahead.
07:28:44 <chessguy> ?src showList
07:28:45 <lambdabot> Source not found. You type like i drive.
07:29:01 * chessguy revokes lambdabot's driver's license
07:29:01 * LeCamarade just scrapped almost all his functions. Falling back to less-elgant stuff. :o(
07:29:18 <LeCamarade> chessguy: :oD
07:30:33 <chessguy> hm, that implementation of showsPrec doesn't even make sense
07:30:42 <Saizan> ?src showList
07:30:43 <lambdabot> Source not found. That's something I cannot allow to happen.
07:30:43 <chessguy> ?hoogle ShowS
07:30:44 <lambdabot> Prelude.ShowS :: type ShowS
07:30:44 <lambdabot> Prelude.shows :: Show a => a -> ShowS
07:30:44 <lambdabot> Numeric.showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
07:31:09 <chessguy> ?src ShowS
07:31:10 <lambdabot> type ShowS = String -> String
07:31:14 <chessguy> oh, ok
07:31:47 <greenrd> Is there any way to tell ghc-pkg list to _only_ look at one .conf file, and _not_ at the system or user package.conf file(s)?
07:47:46 <case> i want to group chars and ints in a string by doing this: groupBy (\x y -> isDigit x) s
07:47:53 <case> but that's not rite :)
07:49:01 <case> oh sorry, got it
07:49:10 <case> groupBy (\x y -> isDigit x && isDigit y) s
07:50:14 <dozer> afternoon
07:50:21 <ski> > groupBy (\x y -> isDigit x && isDigit y) "foo012bar345"
07:50:23 <lambdabot>  ["f","o","o","012","b","a","r","345"]
07:50:25 <kosmikus> case: don't you want == rather than && ?
07:50:27 <ski> > groupBy (\x y -> isDigit x == isDigit y) "foo012bar345"
07:50:28 <lambdabot>  ["foo","012","bar","345"]
07:59:36 <case> ski, hmm yes
08:02:00 <vincenz> augustss_: ping
08:08:06 <fasta> Do you know software that can draw binary trees with a given label? I would like to see a graphical presentation
08:08:19 <snappy> fasta: graphviz
08:08:35 <fasta> snappy: That's what I am using, but I don't know how to draw _trees_
08:08:37 <snappy> You'd have to handcode it.
08:08:59 <fasta> snappy: Since, AFAIK, graphviz doesn't know about left and right children.
08:09:09 <fasta> snappy: what do you mean by handcode in this case?
08:09:16 <snappy> Well a tree is basically an acyclic graph, so it should be the same as drawing a graph
08:09:27 <fasta> snappy: I know
08:09:35 <chessguy> fasta: have you seen the ASCII drawings in Data.Tree ?
08:09:38 <snappy> ohh i see what you're saying
08:09:41 <fasta> snappy: but .... for visualizing a tree there is an _ordering_.
08:09:45 <snappy> you want to give ordering to the children.
08:09:50 <fasta> snappy: yes
08:10:03 <fasta> chessguy: no, can it also produce labels?
08:10:22 <chessguy> fasta: i'm not sure what you mean by 'labels'
08:10:34 <chessguy> ?source Data.Tree
08:10:35 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
08:10:40 <chessguy> err
08:10:43 <chessguy> ?docs Data.Tree
08:10:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
08:10:55 <fasta> chessguy: say I have a tree filled with Strings, does it show the Strings too?
08:11:02 <chessguy> yes
08:11:13 <fasta> chessguy: ok, I will see. Thanks
08:11:19 <chessguy> it an draw any instance of Tree a
08:11:23 <chessguy> *can
08:13:57 <fasta> chessguy: the construction of a Data.Tree seems to be horrible
08:14:19 <fasta> chessguy: no, it isn't.
08:14:27 <fasta> chessguy: I see the constructors are exported.
08:14:49 <chessguy> Data.Tree only has one constructor, Node
08:15:15 <fasta> chessguy: right, by constructors I meant constructor
08:21:59 <dozer> I'm getting a compiler message: "Could not deduce (DescriptionExpansion rawDesc description) from the context ..."
08:22:13 <ndm> @tell sweirt i know Dimitry was going to be off for some time setting up a new machine and net connection, as long as you haven't changed too much, i'd just release
08:22:13 <dozer> I'm stumped - is there a way to go about tracing what's not getting unified?
08:22:13 <lambdabot> Consider it noted.
08:23:25 <ndm> @tell sweirt i'll send him an email
08:23:25 <lambdabot> Consider it noted.
08:30:57 <joelr1> howdy folks
08:55:58 <dmhouse> Woah, netsplit
08:57:39 <opqdonut> net, woahsplit
08:58:51 <dozer> hum, still can't get this code to compile :'(
09:07:49 <hpaste>  dozer pasted "typeclass resolution problem" at http://hpaste.org/1564
09:08:31 <dozer> well, that didn't go well
09:10:02 <hpaste>  dozer pasted "problem function" at http://hpaste.org/1565
09:10:12 <dozer> that's better
09:10:57 <hpaste>  dozer pasted "comiler error " at http://hpaste.org/1566
09:11:31 <dozer> so, I am compiling the code "problem function" and get the error "comiler error" (sp?) but can't find a way to convince the compiler that the types should all work out
09:11:40 <dozer> how do I go about fixing this?
09:11:46 <qebab> <dmhouse> Woah, netsplit <opqdonut> net, woahsplit <= That's the difference between FP and OOP? :)
09:12:09 <AStorm> Nope
09:21:39 <dozer> ah, fixed it (embarasingly soon after posting) - was some typoes in the signature of some methods on a class :/
09:23:52 <dpiponi> Is there a Haskell serial port library?
09:26:15 <roconnor> @type ap
09:26:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:27:05 <roconnor> @type (ap . return)
09:27:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
09:27:17 <roconnor> @type (liftM)
09:27:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:27:23 <xerox> ?djinn (e -> a -> b) -> (e -> a) -> e -> b
09:27:24 <lambdabot> f a b c = a c (b c)
09:27:25 <quicksilver> ap . return is liftM, yes
09:27:39 <roconnor> Is that one of the strong monad laws?
09:27:48 <quicksilver> it's true in all monads, not just strong ones
09:28:02 <roconnor> ap is only defined in strong monads.
09:28:10 <quicksilver> ?
09:28:14 <roconnor> am I wrong?
09:28:16 <quicksilver> ap is simply liftM2 ($)
09:28:21 <quicksilver> you can define that in any monad
09:28:32 <roconnor> all Haskell monads are strong monads.
09:28:36 <quicksilver> that's true :)
09:28:51 <roconnor> liftM2 is only defined in strong monads.
09:29:50 <quicksilver> but liftM2 f a b is only a >>= \x -> b >>= \y -> f x y
09:29:56 <quicksilver> where do I need strength for that?
09:31:19 <roconnor> @type (>>=)
09:31:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:32:06 <roconnor> @pl a >>= \x -> b >>= \y -> f x y
09:32:06 <lambdabot> (b >>=) . f =<< a
09:32:52 <ToRA> rconnor: there's a missing return before f
09:33:06 <quicksilver> oops, mea culpa :)
09:33:27 <ToRA> ooi, what's a strong monad?
09:33:31 <quicksilver> maybe my computational intuition is letting me down, since I don't have a computational picture of a non-strong monad
09:33:32 <ToRA> the wikipedia page has pictures
09:33:46 <ToRA> but no intuitive explanation
09:34:15 <ToRA> (I assume an intuitive explanation exists?)
09:34:17 <quicksilver> a strong monad is one with a canonical isomorphism between (a,m b) and m (a,b)
09:34:22 <roconnor> @type \f a b -> a >>= \x -> b >>= \y -> f x y
09:34:25 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
09:34:37 <quicksilver> i.e. the monad 'commutes' with the cartesian structure of types
09:34:41 <roconnor> @type \f a b -> a >>= \x -> b >>= \y -> return (f x y)
09:34:44 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
09:35:03 <ToRA> quicksilver: ok
09:35:45 <quicksilver> hmm
09:35:51 <quicksilver> maybe not an isomorphism
09:35:56 <quicksilver> just a canonical homomorphism
09:36:07 <quicksilver> since (3,Nothing) ---> Nothing
09:36:10 <quicksilver> information is lost
09:37:51 <quicksilver> I think it amounts to 'this monad fits in neatly with the CC structure you have'
09:38:04 <quicksilver> so it's a sensible requirement, computationally
09:38:34 <roconnor> quicksilver: I'm not sure I have a good answer, but if we look at the function in point free form (b >>=) . (f =<< a) we see that (f =<< a) is a function where bind normally returns an object.
09:38:52 <roconnor> So you are using the exponential at that point.
09:38:59 <roconnor> at that somehow is tied in with strong monads.
09:39:09 <quicksilver> roconnor: yes, I suspect you're right
09:39:23 <quicksilver> roconnor: the strong monad law is quote in terms of commuting with the product
09:39:31 <quicksilver> roconnor: but I'm sure it also implies commutting with the exponential
09:41:34 <ddarius> A strong monad preserves the environment across its computation.
09:41:40 <ddarius> s/computation/execution
09:43:02 <ddarius> :t \(a,mb) -> do b <- mb; return (a,b)
09:43:11 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t, t1 t2) -> t1 (t, t2)
09:43:14 <ToRA> @type (\(a,b) -> liftM (const a &&& id) b)
09:43:16 <lambdabot> forall t a1 (m :: * -> *). (Monad m) => (t, m a1) -> m (t, a1)
09:43:23 <ToRA> ddarius: gha, you beat me to it
09:43:30 <ToRA> ddarius: ;)
09:44:03 <quicksilver> :t \(a,mb) -> mb >>= return . (a,)
09:44:06 <lambdabot> parse error on input `)'
09:44:12 <quicksilver> stupid can't take sections of , rule :P
09:44:18 <ToRA> heh
09:44:21 <quicksilver> :t \(a,mb) -> mb >>= return . ((,) a)
09:44:23 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t, m a) -> m (t, a)
09:45:59 <ski> strength !
09:46:01 <plutonas> sjanssen: not here yet?
09:51:58 <sioraiocht> hello everyone
09:53:33 <sioraiocht> Okay, so I have a question -- I'm looking to write an evaluator for a small pathological programming language.  The interpreter have 3 queues and 3 registers that contain values at any given point in execution.  Would a State monad be a good way to store/modify those?
09:54:30 <ToRA> i'd go with state monad (possibly under a newtype / deriving), with lots of custom modify methods, yeah
09:55:11 <kilimanjaro> you could just pass all of the state as arguments to your evaluator. it might make things easier to debug
09:56:29 <ToRA> if you abstract it in the right way, you should be able to fairly transparently jump to a StateT IO if you want print statements for debugging tho
09:56:37 <sioraiocht> kilimanjaro: I thought of that, and then I would be evaluating recursively?
09:57:08 <sioraiocht> ToRA: The programming language does require I/O as part of its instruction set, I guess what would demand a State monad then, huh?
09:57:15 <kilimanjaro> sioraiocht, yes
09:57:40 <sioraiocht> kilimanjaro: you can't do that and have IO though, right?
09:57:43 <ToRA> sioraiocht, requiring IO does not necessarily require State
09:57:46 <kilimanjaro> sioraiocht, your haskell implementation will look very similar to a traditional operational semantics
09:58:01 <ToRA> though if you wanted to use State and IO, you'd need a StateT IO
09:58:14 <ToRA> (or a MonadIO m => StateT m ...)
09:58:21 <bos> you could also punt and use MVars inside IO for your state.
09:58:32 <sioraiocht> bos: punt?
09:58:56 <bos> if you're already tied to IO, there's no benefit to using State; you'll just be making more work for yourself.
09:59:04 <ToRA> or IORefs ...?
09:59:17 <bos> it's not generally a good idea to use IORefs.
09:59:32 <ToRA> i would hardly call using State more work if you want to keep things abstracted
09:59:43 <ToRA> what's wrong with IORefs?
09:59:55 <bos> not thread-safe.
10:00:06 <sioraiocht> bos: good point.  hrm, So I could just pass the state as a tuple to the evaluator, then use I/O?
10:01:17 <bos> you could. depends on what your goal is. as ToRA points out, if you want something that separates I/O from computation, you might want StateT. you'll end up writing a bit more boilerplate code.
10:01:42 <bos> if you just want to bang something out, be a bad guy and don't bother leaving IO :-)
10:02:38 <sioraiocht> bos: I think I'll do that at first, I'll go for StateT once I have something working.  StateT isn't intuitive to me so I'd rather not wrap my head around it doing this from scratch ;)
10:02:44 <sioraiocht> thanks for the help, guys
10:03:27 <ToRA> bos: (maybe I've been indoctrinated by State monads)...what boilerplate do you expect from them?
10:04:30 <bos> well, let's take sioraiocht's example of a machine with three registers. you'll need a state that's a 3-tuple. and so you'll need a separate function to read and write each of those registers, implemented in terms of State's get and put.
10:04:52 <bos> it's obviously trivial to write, just boilerplate.
10:05:24 <bos> whereas you could use STRefs in ST, or MVars in IO, and have the boilerplate eliminated.
10:05:41 <ToRA> i agree it's trivial, but you'd still have to write code to read and write those 3 normally, and thread them through, which is just as much boilerplate?
10:05:58 <sioraiocht> http://scienceblogs.com/goodmath/2007/01/a_pathological_challenge_prime.php
10:06:01 <lambdabot> Title: Good Math, Bad Math : A Pathological Challenge: Prime Programming in NULL, http://tinyurl.com/ypw4lp
10:06:09 <sioraiocht> that's the language, btw :)
10:08:36 <ToRA> that's quite neat
10:08:51 <sioraiocht> I think so
10:08:57 <sioraiocht> the parsing, obviously, is easy p
10:08:58 <sioraiocht> =p
10:10:29 <ski> roconnor : istr if you have exponentials, then every monad is strong
10:10:49 * ski ponders that
10:11:15 <ToRA> sioraiocht: i guess state monad would be overkill for that, since you don't have state going off everywhere in complicated ways
10:11:38 <ToRA> sioraiocht: tho it would be a good test-bed to integrate it into after you've done it the non-monad-crazy way
10:12:02 <sioraiocht> ToRA: that's what I'm thinking.  I would like to do it as an exercise in the State monad eventually, because I'm like, State-monad retarded
10:12:29 <ToRA> sioraiocht: are you using a record type for the state of the queues and the registers?
10:12:42 <ToRA> or are you just using very large arity tuples?
10:12:43 <sioraiocht> ToRA: just a tuple
10:12:51 * sioraiocht loves tupes
10:13:10 <sioraiocht> type Env = (Queue, Queue, Queue, Int, Integer, Integer)
10:13:30 <ToRA> i have a strong dislike for them, they often don't convey as much semantic information as a record with explicit names
10:13:48 <ToRA> but then again, i also like writing lots of {'s, so you're probably safe :)
10:14:12 <sioraiocht> ToRA: I would agree, tbh I go with whatever seems logical to me at the time
10:16:13 <fasta> How can I draw a simple circle on the screen with gtk2hs?
10:16:47 <ski> we want lightweight records !
10:17:00 <ToRA> ski: lightweight?
10:17:17 <ski> no need to declare them beforehand
10:17:33 <ddarius> For six components, a record is probably recommended.
10:17:39 <fasta> Ah, arc
10:17:51 <ToRA> what's the return type of a function returning a lightweight record?
10:18:06 <dylan> it would describe the members of the record
10:18:21 <ski> ToRA : a record type
10:18:22 <ToRA> and can't you already do this (c.f. the hlist paper?)
10:18:32 <ToRA> *do = fake
10:18:54 <ToRA> myFun :: { name :: Int, name2 :: String }
10:19:19 <sioraiocht> ddarius: are you trying to guilt me about using a tuple =p
10:19:57 * ToRA wonders if that allows subtyping too close to the back door
10:20:17 <ski> you could try out TREX if hugs still supports it ..
10:20:52 <ski> (that uses row polymorphism instead of subtyping)
10:22:14 <ski> http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex
10:25:27 <sioraiocht> is there anything that explains the syntax of records?
10:27:26 <ski> ordinary record syntax ?
10:27:31 <sioraiocht> aye
10:27:45 <sioraiocht> I'm getting errors that clearly tell me I'm not remember them correctly
10:27:56 <ski> paste ?
10:28:09 <ski> !paste
10:28:09 <hpaste> Haskell paste bin: http://hpaste.org/
10:28:43 <sioraiocht> n/m...
10:28:44 <sioraiocht> lol
10:29:13 <ToRA> sioraiocht: decl - data X = X { name :: Type }, pattern - (X { name = value } ), update - x { name = newValue } )
10:29:20 <sioraiocht> yeah, I got it ;)
10:29:25 <ToRA> gd gd
10:29:42 <sioraiocht> thanks, hehehe
10:29:50 * sioraiocht is too young to have such a bad long term memory.
10:30:17 <george> I hate to ask here, but any superconductor physicists here (I get better help here than any physics channel)
10:30:24 <Cheery> Do you guys have somewhere an extensive article about error handling?
10:31:20 <dmwit> Cheery: I guess you've read "Tackling the Awkward Squad," right?
10:31:28 <Cheery> nop
10:31:52 <ToRA> i recall this covered the basics: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
10:31:55 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
10:32:16 <dmwit> I'm not sure TtAS really qualifies as covering errors extensively, though.
10:33:01 <Cheery> I'm just wondering how to handle errors *properly*
10:33:12 <sjanssen> @tell plutonas http://vimperator.mozdev.org/
10:33:13 <lambdabot> Consider it noted.
10:33:47 <ToRA> Cheery, the point of that blog post is that no-1 seems to know
10:33:49 <plutonas> thansk sjanssen
10:33:50 <lambdabot> plutonas: You have 1 new message. '/msg lambdabot @messages' to read it.
10:34:35 * ToRA reflects that in ~9 months of aggressive haskell coding, he really hasn't thought about errors at all
10:34:49 <syntaxfree> there seem to be some syntactic additions to Haskell since I stopped following the community closely.
10:34:51 <Cheery> ToRA: true, actually, I've realized I never knew a proper way to handle errors even with imperative languages
10:35:11 <syntaxfree> what's with this "deriving (Typeable, Monad)"? Deriving was generalized?
10:35:23 <sjanssen> syntaxfree: that's an old extension
10:35:26 <syntaxfree> did they provide an introspective interface into the data type definition?
10:35:30 <sjanssen> since GHC 6.4 or so
10:35:40 <syntaxfree> well, I've started seeing it in code in blogs recently.
10:35:48 <syntaxfree> how does that work?
10:36:05 <sjanssen> it is called "generalized newtype deriving"
10:36:19 <syntaxfree> hmm. it doesn't work for sum types.
10:36:23 <Cheery> Do you guys have something to say on taking care of errors?
10:36:41 <syntaxfree> @google generalized newtype deriving
10:36:46 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
10:36:46 <sjanssen> a newtype of a data type can derive any instance it's parent type has
10:36:46 <lambdabot> Title: NewtypeDeriving - Haskell Prime - Trac
10:36:47 <ToRA> Cheery - depends about what you want to do when an error occurs
10:36:53 <syntaxfree> the type class hierarchy seems to be improving too.
10:36:59 <sjanssen> syntaxfree: it only works for newtypes
10:37:26 <syntaxfree> I've been looking at the latest ghc docs online.
10:37:39 <sieni> Cheery: well, a good strategy is to handle those errors from which you want to survive and abort() otherwise
10:37:43 <syntaxfree> the Traversable thing gives me the warm fuzzies.
10:37:45 <Cheery> ToRA: well, error is a common state in program, but I'd love to handle them transparently
10:38:13 <syntaxfree> It should have been like that all along.
10:38:26 <Cheery> ie. if I don't care about surviving from them, I don't need to think about them, but when I need to, I could then get the cat to the table somehow.
10:39:13 <sieni> Cheery: well, in a language that supports exceptions, you can just throw them in case of error and catch them where you want them to be handled
10:39:43 <Cheery> meaning that I could just use error -thing?
10:39:53 <Cheery> that's it?
10:40:47 <ToRA> error can only throw around strings though
10:41:03 <ToRA> do you need to pass extra data with your errors?
10:41:28 <rmulliga> Is there some standard tree type where a leaf can reference another branch or leaf in the tree?
10:41:52 <ski> how's that a leaf, then ?
10:42:01 <emu> (Tree, Map)
10:42:15 <dmwit> rmulliga: Do you want a graph data structure?
10:42:18 <dmwit> I'm sure there is one.
10:42:27 <rmulliga> dmwit: hmm maybe
10:42:46 <yiwin> Hello, cant build TypeCompose!
10:43:26 <Cheery> oh well, I guess I'll read those things you posted through first, then come back ask more if I need to.
10:43:53 <yiwin> Building TypeCompose-0.0...
10:43:54 <yiwin> [1 of 3] Compiling Control.Compose  ( src/Control/Compose.hs, dist\build/Control/Compose.o )
10:43:56 <yiwin> This application has requested the Runtime to terminate it in an unusual way.
10:43:57 <yiwin> Please contact the application's support team for more information.
10:44:43 <rmulliga> emu: so (Tree,Map) is a tuple, where each tree corresponds to a maping and that maping could be another tree?
10:45:46 <emu> it can reference another branch or leaf via the map, presumably
10:49:22 <bvd> Hello, is this the usual way of converting a String to a ByteString: fromString = pack . map (fromIntegral . ord) ?
10:49:48 <sjanssen> bvd: use Data.ByteString.Char8.pack
10:49:51 <emu> maybe you should be using ByteString.Char8
10:50:08 <bvd> Ah right, didn't see that module yet. Thaks
10:50:11 <emu> @quote stereo
10:50:12 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
10:50:22 <bvd> :-)
10:51:27 <syntaxfree> @quote emu
10:51:28 <lambdabot> emu says:  people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference
10:52:11 * syntaxfree loves playing quote golf.
10:58:58 <Cale> @tell ndm I just found this in a Google blog search http://forums.techguy.org/all-other-software/566277-winhugs-wont-uninstall.html#post4662133
10:58:59 <lambdabot> Consider it noted.
11:04:34 <dozer> still about?
11:05:20 <dozer> hehe - wrong chat, sorry
11:06:54 <Cheery> .ui! monad+fail
11:07:00 <Cheery> I think that'd be nice.
11:08:57 <Cale> http://computer61l.iiopy.com/The-Monads-Hidden-Behind-Every-Zipper/ -- huh, some spammer for whatever reason seems to have decided to plagiarize sigfpe's blog.
11:09:01 <lambdabot> Title: The Monads Hidden Behind Every Zipper, http://tinyurl.com/2hkjms
11:17:45 <vincenz> Cale: holy cow
11:18:22 <m4St3R_b41T3R> lol
11:18:23 <sjanssen> Cale: we saw that with one of tmoertel's blogs recently
11:19:00 <sjanssen> the plagiarized blog even made it to the HWN
11:19:13 <Cale> heh
11:20:56 <Cale> We need a reddit which is run by an oligarchy rather than being democratic :)
11:28:22 <DRMacIver> Democracy is for the weak anyway. :)
11:30:49 <astrolabe> for some reason, google ads has decided that the best matchs they have for ndm's blog are from obtain-your-degree-by-fraud companies. http://neilmitchell.blogspot.com/2007/04/more-hoogle-progress.html
11:30:52 <lambdabot> Title: Neil Mitchell's Haskell Blog: More Hoogle progress, http://tinyurl.com/ysdy9o
11:34:41 <Cale> I don't even see those ads. At least one of my firefox extensions strips google ads off of pages.
11:35:14 <bos> l/join #mercurial
11:38:36 <Cheery> I wonder, ErrorT -monad is excellent.
11:38:41 <Cheery> If you just use it.
11:39:36 <Cheery> now, if I want to render something else if my parsing process fails, I can just do it with catchError :)
11:40:05 <Cheery> thought, I'd still probably love those restarts and others from lisp
11:40:06 <fasta> How can I abstract the pattern if foo then bar a b c d else bar a b o p ?
11:40:25 <Cheery> I wonder whether I should implement them, then try them around a bit.
11:40:50 <Cheery> now there's only one way to handle errors coming from parsing the wiki syntax and user requesting a page.
11:41:01 <vincenz> fasta: let x = bar a b in if foo then x c d else x o p
11:41:04 <Cheery> - print a standard error of some sort
11:41:23 <fasta> vincenz: too bad it doesn't work in-line
11:41:47 <fasta> vincenz: i.e. bar a b (if foo then c d else o p
11:41:50 <fasta> )
11:41:52 <Cheery> ok, so, what if one would like to ignore the parsing error, and simply jump over?
11:42:43 <ski> (\k -> if foo then k c d else k o p) a b
11:43:06 <ski> er
11:43:12 <Cheery> or output a html -form there saying "you have errorneous syntax here! fix it asshole."?
11:43:20 <ski> (\k -> if foo then k c d else k o p) (bar a b)
11:43:20 <Saizan> (uncurry (bar a b)) if foo then (c,d) else (o,p)
11:44:07 <ski> bar a b >$ \k -> if foo then k c d else k o p
11:44:14 <ski> (>$) = flip ($)
11:44:25 <fasta> All those solutions use an intermediate variable
11:44:53 <fasta> (but that's all is possible)
11:46:08 <ski> bar a b >$ if foo then ($ c) >.> ($ d) else ($ o) >.> ($ p)
11:46:13 <ski> (>.>) = (flip (.)
11:46:26 <ski> (but this begins to get silly, methinks)
11:47:13 <fasta> ski: no shit ;)
11:47:59 <fasta> I read the Turing Award lecture from 1970. It seems that it could be given today too.
11:48:13 <ski> which was that ?
11:49:23 <fasta> http://web.media.mit.edu/~minsky/papers/TuringLecture/TuringLecture.html
11:49:26 <lambdabot> Title: 1970 ACM Turing Lecture, http://tinyurl.com/2z4gpb
11:50:43 <hpaste>  Saizan pasted "is there a way to make this work with only one where clause?" at http://hpaste.org/1567
11:50:44 <lambdabot> hpaste: You have 1 new message. '/msg lambdabot @messages' to read it.
11:51:35 <roconnor> I need a little gtk2hs help
11:51:47 <roconnor> I build the latest gtk2hs
11:51:58 <roconnor> I've fetched the latest haskell charting library
11:52:04 <roconnor> and built it
11:52:09 <roconnor> but the tests fail for me
11:52:36 <roconnor> roconnor@faris:~/shared/haskell/chart/tests$ runhaskell test2.hs
11:52:36 <roconnor> *** Exception: user error (
11:52:36 <roconnor> initGUI: Gtk+ is single threaded and so cannot safely be used from
11:52:36 <roconnor> multiple Haskell threads when using GHC's threaded RTS. You can ...
11:52:36 <roconnor> avoid this error by relinking your program without using the
11:52:36 <roconnor> '-threaded' flag.
11:52:58 <roconnor> How do a avoid the ``-threaded'' flag
11:53:07 <roconnor> I haven't myself used any flags.
11:53:14 <ventonegro> is there a way to get a capture with =~?
11:54:33 <fasta> roconnor: threaded is default
11:54:40 <roconnor> oh
11:54:53 <roconnor> ... that must make using gtk2hs annoying
11:55:08 <fasta> Using gtk2hs _is_ annoying
11:55:13 <roconnor> what flag do I use to disable threading?
11:55:29 <fasta> roconnor: I don't know by heart. Check GHC documentation
11:55:34 <roconnor> and how to I pass it into Setup.hs?
11:55:42 <bos> run your gtk code inside a bound thread using forkOS.
11:56:07 <fasta> Doesn't initGUI always gives that warning?
11:56:10 <fasta> er give
11:56:10 <bos> don't worry about disabling the threaded runtime.
11:56:28 <roconnor> fasta: not a warning, and exception!
11:56:29 <fasta> Oh, well, I am no GTK2HS expert (far from it)
11:56:50 <fasta> roconnor: there is also an unsafe initialization function
11:56:55 <fasta> roconnor: that doesn't do that.
11:57:03 <fasta> roconnor: it also ends with "GUI"
11:57:16 <fasta> roconnor: but you'd better listen to bos, I guess
11:58:05 <roconnor> !past
11:58:08 <roconnor> !paste
11:58:08 <hpaste> Haskell paste bin: http://hpaste.org/
11:58:42 <arcatan> !future
11:58:43 <hpaste>  roconnor pasted "relevent code from Haskell Charts" at http://hpaste.org/1568
11:59:12 <roconnor> bos: presumably I want to ammend that code with forkOS somehow?
11:59:22 <roconnor> @type forkOS
11:59:25 <lambdabot> Not in scope: `forkOS'
11:59:31 <roconnor> @hoogle forkOS
11:59:32 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
11:59:35 <fasta> roconnor: I think it takes an IO action
11:59:39 <bos> use forkOS to call that function.
11:59:42 <osfamero1> yay me! just finished chapter 2 of SOE
12:01:13 <osfamero1> well, i did give up on 2 of the exerises :-(
12:02:10 <fasta> osfamero1: then you don't collect 200 $ and go back to start
12:02:15 <fasta> ^^
12:02:50 <osfamero1> fasta: yeah i ws worried about that ;-)
12:03:09 <osfamero1> one is just coz i don't know trig
12:03:23 <fasta> osfamero1: then you look that up
12:03:42 <osfamero1> then exercise 2.4 i think is impossible at that stage of book
12:03:46 <fasta> osfamero1: Actually, I only read the exercises to see whether I could solve them.
12:04:20 <fasta> osfamero1: (because I programmed Haskell for a long time already when I read the book and the stuff I write is more complex than he treats)
12:04:54 <osfameron> fasta: heh, yeah
12:05:10 <fasta> I did finish reading the book
12:05:25 <fasta> All 300<something> pages of it
12:05:38 <osfameron> i have to slow myself down because i program for money... but not haskell and not much fp...
12:05:56 <osfameron> so /nothing/ is too basic for me
12:06:03 <fasta> osfameron: what language? Java?
12:06:16 <roconnor> bos, I now do forkOS $ renderableToWindow  in my main function but I still get the same error under runhaskell.
12:06:17 <osfameron> even the pipping proofs...
12:07:02 <osfameron> fasta: worse! perl! (but where i can, functional-ish perl)
12:07:27 <fasta> osfameron: the big difference between Haskell and other languages is that Haskell has value semantics only
12:07:54 <fasta> osfameron: so you construct a value and from that value you construct another value and so on.
12:07:58 <osfameron> fasta: sure
12:09:21 <bos> roconnor: to work around that, call unsafeInitGUIForThreadedRTS instead of initGUI
12:09:34 <bos> but all of your calls into gtk2hs have to happen in a single thread.
12:09:35 <Cale> http://sprott.physics.wisc.edu/Pickover/pc/cnn_shuttle.jpg
12:09:40 <osfameron> fasta: i've been reading around fp a couple of years but this is the first time i'm trying to through exerises nd really grok a functional language
12:09:47 <sjanssen> > length "unsafeInitGUIForThreadedRTS"
12:09:52 <fasta> osfameron: Have you read SICP?
12:09:56 <lambdabot>  27
12:09:58 <baucis> hi
12:10:04 <fasta> osfameron: if you read that, Haskell makes much more sense.
12:10:16 <osfameron> out of interest, does anyone have a sample answer to soe ex 2.4?
12:10:17 <fasta> osfameron: or you take a few university courses
12:10:34 <fasta> osfameron: I can look, I think.
12:11:03 <roconnor> bos: :(
12:11:05 <osfameron> fasta: yeah, i studied literature... but sicp is high on my next-to-read list
12:11:59 <bos> roconnor: it's not a problem; gtk2hs is just trying to make sure you don't shoot yourself in the foot by default.
12:14:25 <fasta> osfameron: In a convex polygon you can go "right" all the time, in a non-convex polygon, you will hit a "wall".
12:14:37 <fasta> osfameron: did you think of that?
12:15:52 <osfameron> fasta: yes, well  right or left, but same dir each time
12:16:03 <fasta> osfameron: right
12:16:23 <fasta> osfameron: so, when you just try that on the polygon and it doesn't work out, the answer is no
12:16:29 <fasta> osfameron: otherwise it's "yes".
12:16:49 <fasta> osfameron: this is the problem solving part of the problem.
12:17:09 <fasta> osfameron: the rest is now looking at some details (that I don't care about)
12:17:29 <osfameron> but then i'd want to map 3s of vertices to a left/right value and then do another higher order fn to chek all the same... but not done higher order fns yet in ch 2
12:18:15 <osfameron> also... i didn't kno maths for 'did we go left or right', but spose i can look that up
12:19:14 <fasta> osfameron: oh, well, I don't think you should worry too much about the use of higher-order functions.
12:19:22 <fasta> osfameron: authors of books make mistakes
12:19:23 <roconnor> bos, ah apparently I only get this problem when using runhaskell
12:20:18 <fasta> osfameron: you don't need higher-order functions, btw
12:20:22 <mux> http://mathworld.wolfram.com/TuppersSelf-ReferentialFormula.html
12:20:24 <lambdabot> Title: Tupper's Self-Referential Formula -- from Wolfram MathWorld
12:20:25 <mux> this is awesome :-)
12:20:31 <fasta> osfameron: you can always inline them
12:20:36 <osfameron> fasta: ok, i was wondering.. but what you said gave me idea for how o do recursivly
12:20:39 <bos> roconnor: oh, i didn't notice you were doing this inside a script.
12:20:56 <Cale> baucis: hello, are you new here?
12:20:57 <fasta> osfameron: is there any other way?
12:21:33 <fasta> mux: O.O
12:21:53 <fasta> osfameron: the only way to write a loop is with recursion directly or indirectly
12:22:13 <osfameron> fasta: later, hudak makes distnction between 'recursiv' and 'higher order'
12:22:28 <mux> fasta: ain't that incredible?
12:22:46 <fasta> mux: yes
12:22:50 <osfameron> yeah, i think meaning /explicit/ recursion
12:23:06 <jmelesky> mux: "The formula itself is a general purpose method of decoding a bitmap stored in the constant n, so it could actually be used to draw any other image, and does not in fact contain any reference to itself."
12:23:15 <jmelesky> (from http://en.wikipedia.org/wiki/Tupper%27s_self-referential_formula )
12:23:17 <Philippa> but also related to general vs primitive or structured recursion
12:23:23 <mux> ah, interesting
12:24:43 <fasta> osfameron: I think the book also tries to learn some problem solving skills.
12:25:07 <fasta> osfameron: so, grabbing a book too soon could spoil a learning moment (just like I did now for you)
12:25:13 <osfameron> fasta: yeah, tis a good book
12:25:38 <benja_> does anybody know a memoization library for haskell?
12:25:54 <kpreid> mux: it would only be interesting if its "output" included the big constant
12:25:56 <osfameron> fasta: yeh, but trade off with getting pissed off and giving up ;-)
12:26:09 <fasta> osfameron: learning hurts
12:26:30 <benja_> weak pointers, stable names and unsafePeformIO were allegedly added to support memoization, surely somebody must have made a library? =]
12:26:30 <osfameron> fasta: gonna go afk and give anothrr go, ta for suggestions
12:26:39 <osfameron> yeah, heh, it does
12:26:40 <fasta> osfameron: ok, good lu=uck
12:27:01 <mux> kpreid: yeah, well I find it nice nevertheless :-)
12:28:28 <fasta> benja_: what exactly would this memo library do?
12:29:32 <fasta> Hmm, now, I think about it, a general purpose memo library is possible.
12:29:39 <fasta> It's just _very_ hard to implement
12:29:50 <fasta> I.e. nobody did in any language
12:30:05 <sjanssen> I don't think it is very hard
12:30:09 <fasta> Problem would be bad performance, though.
12:30:28 <benja_> fasta: provide memo :: (a -> b) -> (a -> b)
12:30:28 <fasta> sjanssen: We are probably not thinking about the same.
12:30:37 <benja_> which puts values in a hashtable using weak pointers
12:30:47 <benja_> and doesn't recompute them if they're in the table already
12:31:03 <fasta> What are weak pointers?
12:31:53 <benja_> fasta: pointers that don't prevent garbage collection
12:31:54 <benja_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
12:31:57 <lambdabot> http://tinyurl.com/25thsv
12:33:04 <fasta> benja_: ok, so what happens when you look up such a value when it isn't there anymore?
12:33:17 <sjanssen> fasta: recompute it
12:33:32 <benja_> fasta: you get Nothing instead of (Just x). memo then recomputes the value and puts it in the table again
12:33:46 <fasta> sjanssen: ok, so, the universe doesn't explode? Ah, I suppose that's a good thing. :)
12:34:01 <benja_> :)
12:34:22 <benja_> clever googling finds a GHC regression test: http://darcs.haskell.org/testsuite/tests/ghc-regress/lib/should_run/Memo.lhs
12:34:23 <Cale> Hahaha! Appendix A: A pure waste of paper.
12:34:25 <lambdabot> http://tinyurl.com/2926oy
12:34:25 <fasta> benja_: ok, I can see the potential of such a memo function.
12:34:44 <fasta> benja_: but the performance problems would be in the hash table implementation.
12:35:04 <benja_> (or at least I assume so, from the directory name)
12:35:10 <fasta> benja_: there are no O(1) hash table implementation in any language that I know.
12:35:23 <fasta> implementations*
12:35:34 <fasta> benja_: http://research.microsoft.com/Users/simonpj/Papers/weak.htm
12:35:36 <lambdabot> Title: Simon Peyton Jones: papers
12:35:37 <sjanssen> O(log n) is probably good enough
12:35:39 <fasta> benja_: you did see that?
12:35:46 <benja_> yep
12:35:56 <benja_> but I want the code ;)
12:36:01 <benja_> I suppose the above link is that code
12:36:06 <sjanssen> I'm writing it right now
12:36:08 <fasta> if O(log n) is no problem it should be trivial to write one.
12:36:13 <benja_> (the one in the regression test directory, I mean)
12:36:25 <benja_> fasta: what is the problem with hashtable implementations?
12:36:51 <sjanssen> benja_: Data.HashTable is slow
12:37:14 <fasta> benja_: they all are implemented as E(O(1)) instead of O(1)
12:37:17 <sjanssen> and the complexity is actually O(log history)
12:37:23 <bvd> Hello, does there exist a GHC extension that allows partially applied type constructors. Like: type S a = String; instance Monad S where ... ? Or does type inference become undecidable if this can be done?
12:37:43 <fasta> bvd: not yet, AFAIK
12:37:45 <sjanssen> bvd: yes, type inference becomes undecidable
12:38:02 <bvd> crap!
12:38:13 <benja_> ?source Data.Hashtable
12:38:14 <lambdabot> Data.Hashtable not available
12:38:14 <fasta> sjanssen: isn't that available maybe in 6.8?
12:38:31 <sjanssen> fasta: I don't know
12:38:35 <fasta> benja_: ?
12:38:39 <fasta> sjanssen: ?
12:38:48 <fasta> sjanssen: ah, ok
12:39:04 <benja_> ?source Data.HashTable
12:39:04 <lambdabot> http://darcs.haskell.org/packages/base/Data/HashTable.hs
12:40:02 <fasta> If only every language came with real batteries...
12:40:11 <fasta> Not the Python fake batteries
12:40:26 <benja_> fasta: what's the E()?
12:40:28 <DRMacIver> Batteries?
12:40:31 <fasta> I mean things like Data.Finger :)
12:40:37 <DRMacIver> benja_: Expected.
12:40:42 <fasta> DRMacIver: google batteries included
12:40:53 <fasta> DRMacIver: maybe plus Python
12:41:12 <fasta> They make a big hype about how much "libraries" they have.
12:41:25 <DRMacIver> I see.
12:42:42 <Philippa> yeah, it's valuable though
12:42:47 <Philippa> how long've you been doing Haskell for?
12:42:56 <benja_> so what's the problem with expected O(1)?
12:43:03 <DRMacIver> Good lord. Python is reference countered? Ouch.
12:43:07 <Philippa> there's been a huge leap in the last few years, and it's made a big difference in what you can practically do with Haskell
12:43:15 <DRMacIver> benja_: The problem is that it's not O(1) in the worst case scenarios.
12:43:18 <benja_> fasta: Data.Finger? do you mean FingerTree or...
12:43:27 <fasta> Philippa: me?
12:43:34 <benja_> DRMacIver: sure, but why's that a problem?
12:43:36 <Philippa> fasta: yeah
12:43:44 <fasta> benja_: yes, I meant that, sorry
12:43:51 <benja_> ok
12:44:01 <fasta> IMO, Data.FingerTree is not general enough, though
12:44:01 <DRMacIver> benja_: It isn't neccessarily. It just means that you shouldn't count on it being O(1). :)
12:44:24 <benja_> DRMacIver: true :)
12:44:31 <fasta> Philippa: I think I used it for about 5 years
12:44:41 <fasta> Philippa: But the last few years more intensively.
12:45:25 <benja_> fasta: what would you like it to be like, then?
12:45:39 <fasta> benja_: O(1) of course
12:45:55 <DRMacIver> Hm. Is it actually possible to have an O(1) hash table implementation?
12:45:55 <Philippa> suppose all you had was the libraries in the Report, would you be able to use Haskell for everything you use it for without having to write the missing libs?
12:46:22 <fasta> Philippa: ? By definition no
12:46:37 <benja_> fasta, I meant the more general finger trees :)
12:46:49 <fasta> benja_: I want to have a reverse operation
12:47:05 <fasta> benja_: (one that works in O(log n)
12:47:06 <fasta> )
12:47:21 <Philippa> fasta: I don't think it's actually by definition, it just means that you use a significant proportion of the other libraries that're available
12:47:40 <fasta> Philippa: well, actually I don't use other libraries.
12:47:53 <fasta> Philippa: all the stuff included is next to useless.
12:48:12 <Philippa> fasta: so you actually completely misread my question and gave the wrong answer?
12:48:15 <shapr> Is there existing pure Haskell code to create a lockfile for a process, and to check and remove a stale lockfile and restart the app?
12:48:16 <benja_> fasta: ok
12:48:26 <Philippa> okay. I actually do use most of the stuff that comes with GHC
12:48:35 <Philippa> it's far from useless for me
12:48:45 <fasta> Philippa: I do use DiffArray
12:48:49 <fasta> Philippa: the lists
12:49:06 <fasta> Philippa: but where are for example the range trees?
12:49:11 <fasta> Philippa: the quad trees?
12:49:18 <Philippa> so you want bigger libs, not smaller ones
12:49:20 <fasta> Philippa: the balanced trees?
12:49:27 <fasta> Philippa: of course
12:49:46 <fasta> Philippa: I want that everything that's described in theory is available in practice
12:49:58 <fasta> Philippa: the current situation cannot possibly be any worse
12:50:00 <DRMacIver> I want a pony.
12:50:05 <fasta> DRMacIver: right
12:50:14 <ben_m_> omg ponies!
12:50:23 <Philippa> fasta: start writing, start convincing other people they want to help write
12:50:29 <Philippa> oh, or pay someone
12:50:35 <fasta> It's just that everyone keeps their own data structures for themselves (or are not skilled enough to write themselves)
12:50:58 <fasta> Deciphering how a complex data structure works takes serious time.
12:51:04 <Philippa> or don't have the spare hours to put into making them what they think of as 'release-worthy'
12:51:25 <DRMacIver> I like google code's release motto.
12:51:31 <DRMacIver> Release early, release often.
12:51:34 <Philippa> that's partly a culture issue, of course - quality levels're high enough that people feel embarassed putting up something that may be crap or doesn't feel like the more developed libs
12:51:39 <fasta> Since most of the time the authors had no space in their "precious journals" to write up a clear description.
12:51:53 * DRMacIver thinks more people should be willing to put out shitty code under permissive licenses
12:51:55 <vincenz> fasta: "precious journals"
12:52:01 <vincenz> fasta: page-count *is* limited
12:52:15 <fasta> vincenz: yes, I know. I think that concept is stupid.
12:52:21 <Philippa> right, there may be a cultural issue but it's not with the individual authors
12:52:30 <m4St3R_b41T3R> http://kaede.iichan.net/lol.jpg
12:52:33 <fasta> vincenz: as if everything is so simple to put it in under about 12 pages.
12:52:36 <Philippa> though technical reports are a good thing too
12:52:43 <vincenz> fasta: heh, 12 pages are a luxury, and Philippa has a point
12:53:10 <Philippa> if you can't fit the basic concepts in 12 pages, you don't have something that belongs in a single paper
12:53:27 <vincenz> Philippa: right 'concept' not 'implementation'
12:53:35 <Philippa> I do /mean/ "basic concepts" though - the rest's what technical reports are for
12:53:48 <fasta> Technical reports get lost in time, I guess.
12:54:06 <shapr> m4St3R_b41T3R: Is that more fitting for #haskell or #haskell-blah ?
12:54:10 <fasta> I never found one of the old articles I read.
12:54:19 <sieni> fasta: hmm... couldn't one do the DiffArray thing in some generic way for arbitrary (for suitable value of arbitrary) by storing sort of undo infromation in a list?
12:54:33 <Philippa> shapr: you might want to op up, people've been told not to use similar nicks in here
12:54:34 <m4St3R_b41T3R> shapr oops
12:54:46 <m4St3R_b41T3R> Philippa what exactly is wrong with my nick?
12:54:55 --- mode: ChanServ set +o shapr
12:54:59 <m4St3R_b41T3R> do you have something against baiting?
12:55:04 <fasta> m4St3R_b41T3R: it's long and looks like you are an idiot?
12:55:06 --- mode: ChanServ set +o vincenz
12:55:17 <Philippa> fasta: that and it's phonetic for masturbator
12:55:23 <shapr> m4St3R_b41T3R: It's clear that nick is not appropriate for #haskell, would you like to switch back to one of your earlier nicks?
12:55:27 <shapr> reppie, reffie, etc?
12:55:45 <shapr> Thank you.
12:55:55 <Saizan> why is Num a subclass of Eq and Show?
12:55:56 --- mode: vincenz set -o vincenz
12:56:04 <vincenz> Saizan: bad design
12:56:36 <Saizan> i hope there was a reason, though
12:56:47 <Philippa> yeah, they just weren't good reasons
12:56:52 <shapr> Is there some way to get the name of a process in Linux, and possibly something that's portable across both Linux and Windows?
12:56:53 <vincenz> Saizan: Num is a source of several bad design issues
12:57:00 <Philippa> it's a subclass of Eq because someone didn't think hard enough about the number types people actually use
12:57:04 <vincenz> Saizan: for instance it sshould be much smaller and split up
12:57:05 <fasta> sieni: I don't know and your question is a bit vague.
12:57:12 <Philippa> and Show because "I'd be pretty pissed off if I couldn't print it out in the REPL"
12:57:49 <Nafai> shapr: In Haskell, or in general?
12:57:57 <fasta> What numbers cannot be compared for equality?
12:58:03 <sieni> fasta: well, I mean DiffArray works basically so that you update the array in place and then store undo information for those who might need the old version
12:58:18 <fasta> sieni: yes, and where can you generalize that?
12:58:25 <kpreid> another flaw in the standard typeclasses is that they assume (iirc) that EQ ordering is the same as ==
12:58:36 <fasta> sieni: you could do it for every array, I guess
12:58:38 <shapr> Nafai: Er, I'd prefer Haskell code, but I'd survive with something Posix that I could use via the FFI
12:58:42 <sieni> fasta: well, e.g. binary trees and such
12:58:51 <fasta> sieni: but those already have that property
12:59:05 <mux> kpreid: but you can provide an implementation of compare _and_ (==) when defining Ord, thus allowing different semantics, unless I'm missing something
12:59:14 <fasta> sieni: ah, but maybe less efficient.
12:59:20 <fasta> sieni: I don't know about that.
12:59:21 <kpreid> mux: I forget what, but I had trouble when I considered doing that
12:59:38 <fasta> sieni: most of the functional data structures have efficient access to previous versions
13:00:04 <Saizan> fasta: (Arrow a, Num t) => a b t, can easily be an instance of Num but it's harder for Eq and Show
13:00:40 <augustss_> fasta: there are several kinds of numbers where equality doesn't make sense
13:00:53 <fasta> sieni: I seriously doubt the existence of a general useful function
13:01:24 <koala_man> augustss_: like which?
13:01:29 <fasta> augustss_: I like concrete examples too
13:01:51 <augustss_> koala_man: first, real numbers.  equality is a partial function for real numbers
13:02:06 <Philippa> it's rather questionably useful for floating point, too
13:02:13 <koala_man> ah, I was thinking math
13:02:13 <augustss_> indeed!
13:02:53 <fasta> augustss_: that's because of irrational numbers?
13:03:09 <augustss_> koala_man: second, if you let your numeric operations construct syntax trees instead of computing then equality makes no sense either (because it cannot construct a syntax tree)
13:03:21 <sieni> fasta: well, the general useful thingie would be that given a data structure, then for every operation you give a way to undo that operation.
13:03:47 <fasta> sieni: yes, but whether that actually helps something complexity wise, would be the question.
13:03:51 <augustss_> fasta: it's just a property of the reals.  and yes, if there were only rational numbers you would be able to compare
13:04:01 <sieni> fasta: it might help programmingwise
13:04:23 <fasta> sieni: yes, it might. Try it out, and you will know as I don't know :)
13:05:01 <fasta> augustss_: how many irrational numbers are there anyway?
13:05:28 <Saizan> aren't reals total ordered? and can't you infer equality from the order?
13:05:37 <fasta> Probably some well known result, but I don't know by heart, although it will probably be infinite
13:05:41 <augustss_> fasta: infinitely many, and what infinity depends on what your philosophical point of view is :)
13:06:06 <sieni> fasta: yes, that would be interesting. How would I handle the variable number of operations that an arbitrary data structure can admit. :-)
13:06:08 <fasta> augustss_: yes, I know about levels of infiniteness
13:06:10 <augustss_> Saizan: just because they are ordered doesn't mean the ordering is *computable*
13:06:26 <emu> instance Ord Real where compare = undefined
13:06:46 <augustss_> emu: yes, that's what you have to do.  not very satisfactory
13:07:07 <Saizan> augustss_: ah, right, a not so little detail :)
13:07:09 <emu> then again, our theory of computability is based on countable sets
13:07:12 <magnus_> Errh, how can the ruby programmers solve this problem in 121 bytes? http://golf.shinh.org/p.rb?maze+solving
13:07:14 <lambdabot> Title: anarchy golf - maze solving
13:07:24 <augustss_> fasta: if you take the classical real numbers there are many more of them than there are of the rationals
13:07:29 <emu> so reals are always a problem
13:07:31 <magnus_> I couldn't imagine a haskell solution anywhere near that
13:07:41 <vincenz> augustss_: happen to receive my pm?
13:08:09 <augustss_> vincenz: yes, but I have to log on as augustss to reply
13:08:28 <vincenz> augustss_: or do it here :P
13:08:56 <shapr> Is there any way (or posix way) to access information from ps like name and cwd values for all processes running?
13:09:06 <augustss_> Well, I recognize your problem very well. :)
13:09:22 <dmwit>  /proc?
13:09:38 <shapr> Yeah, won't be portable to windows though.
13:09:38 <dmwit> Oh, posix way.
13:09:48 <shapr> dmwit: But I did ask for any way, so that's progress :-)
13:10:27 <dmwit> There is a Cygwin version of ps; I wonder how they do it?
13:10:30 <magnus_> shapr: name as in executable name?
13:10:57 <magnus_> do you want to grab values from the output of ps?
13:11:14 <shapr> dmwit: good question
13:11:36 <magnus_> aha, you want posix calls.. no idea then.
13:11:57 <dmwit> shapr: It looks like they assign their own PIDs to processes -- separate from the Windows PIDs. =(
13:12:04 <shapr> magnus_: I want to a cron job that starts once a minute to restart my app if my app has died. If possible I'd like it to work on linux, win, and mac.
13:12:10 <shapr> dmwit: yow
13:12:27 <magnus_> shapr: Make a program that starts your app and waits for it to terminate
13:12:27 <fasta> augustss: Isn't there some finite set of irrational numbers that provide the base for all others?
13:12:35 <magnus_> shapr: if it terminates abnormally, start it again
13:12:52 <magnus_> shapr: would that work?
13:13:13 <fasta> augustss: if that is the case your assertion is false
13:13:25 <fasta> augustss: so, by deduction the answer should be no :)
13:13:32 <augustss> fasta: why do you say that?
13:13:56 <fasta> augustss: if that's the case I know a procedure that could decide the relation
13:14:03 <augustss> there's a finite set of symbols to build all Haskell functions, but you can't compare them for equality either
13:14:48 <fasta> augustss: Can you please answer the question?
13:15:23 <vali> hmm, are chars 'a', `a` or ´a´?
13:15:25 <augustss> fasta: I'm thinking about it.
13:15:35 <Philippa> fasta: I don't think there is, square roots of primes tend to be fun
13:15:38 <fasta> vali: 'a'
13:15:49 <vali> fasta: ah, thank you. i guess the typesetting on this tutorial is just weird
13:16:02 <augustss> fasta: what real numbers are we talking about?  classical or constructive?
13:16:05 <fasta> vali: `a` is an operator
13:16:37 <fasta> augustss: every dot on a line to keep things simple, I think that means classical.
13:16:42 <vali> fasta: it says: case command of ´q´:_ -> return ()
13:16:55 <fasta> vali: in that case it's 'q'
13:16:58 <sieni> fasta: think about real numbers, whose decimal or binary or whatever espansion is computable using a recursive functions. Then the equality predicate for these numbers is not computable
13:17:01 <vali> fasta: all right. thank you
13:17:16 <augustss> fasta: that I can't imagine it is true, they are not enumerable
13:17:58 <augustss> i guess it could be true if you allow descriptions that infinite sets that have high cardinality
13:18:38 <fasta> augustss: ok, but the fact that there are infinitely many irrational numbers doesn't mean there doesn't exist a base set that is finite.
13:19:06 <DRMacIver> The fact that there are uncountably many irrational numbers does though.
13:19:07 <fasta> (taking infinite even to mean not-enumerable)
13:19:18 <augustss> right, but the irrational numbers are enumerable
13:19:28 <DRMacIver> You mean not enumerable.
13:19:32 <sieni> fasta: base set in what sense?
13:19:36 <fasta> Oh, I made a mistake.\
13:19:41 <augustss> I was about to ask that
13:19:49 <fasta> It must be enumerable, indeed
13:20:30 <plediii> hmm? irrational numbers are not countable.
13:20:54 <augustss> sorry, a typo.  I mean rational
13:21:05 <joao> rational are enumerable, yes.
13:21:15 <joao> *rationals
13:21:15 <fasta> sieni: as in that those are the only numbers at your disposal for you to use to e.g. add or take sqrts from or multiply or whatever operation you want
13:21:41 <augustss> fasta: and how many of the sqrt, add, etc are you allowed?
13:21:57 <fasta> augustss: arbitrarily many
13:22:06 <augustss> uncountably many?
13:22:15 <fasta> augustss: but a finite number of them
13:22:39 <sieni> fasta: certainly the real numbers have an uncountable dimension, if your coefficient field has smaller cardinality than the reals.
13:23:33 <augustss> fasta: with a finite number of them you don't get far :)
13:23:47 <sieni> fasta: well, I guess that if the decimal expansions are computable, then any basic operations on them will be computable as well
13:24:10 <glen_quagmire> is haskell RAD?
13:24:16 <emu> not all real numbers are finitely representable
13:24:26 <emu> brb
13:24:26 <Saizan> RAD?
13:24:30 <fasta> sieni: I was implying that maybe you could implement a symbolic equality function
13:24:33 <augustss> but the decimal expansions is not unique, wherein lies the equality problem
13:24:36 <glen_quagmire> Rapid Application Development
13:24:40 <glen_quagmire> Agile technology
13:24:47 <glen_quagmire> next generation programming language
13:24:51 <DRMacIver> glen_quagmire: ITYM 'buzzword compliant'
13:24:53 <fasta> sieni: (for the irrational numbers)
13:25:07 <glen_quagmire> ITYM?
13:25:11 <DRMacIver> I Think You Mean
13:25:14 <Philippa> that, and RAD's about 10 years out of date as a buzzword
13:25:15 <glen_quagmire> it seems that it's for ph.d students only
13:25:25 <glen_quagmire> for smart people..not for the mass
13:25:27 <sieni> fasta: well, in the same sense that you can provide an symbolic equality function for all computable functions
13:25:29 <DRMacIver> I'm not a PhD student.
13:25:42 <DRMacIver> (Nor have I ever been)
13:25:45 <fasta> sieni: well, the question was whether there existed such a base set
13:25:48 <Philippa> I never graduated, and I'm mentoring a project in Haskell for Google
13:25:53 <glen_quagmire> but you are a Dr. DRMacIver
13:26:03 <hpaste>  vali pasted "parse error" at http://hpaste.org/1569
13:26:03 <DRMacIver> My initials are D R
13:26:16 <DRMacIver> I've nothing fancier than a masters. :)
13:26:17 <glen_quagmire> nice
13:26:23 <fasta> sieni: if there is, then you can decide equality, otherwise you cannot.
13:26:27 <DRMacIver> (David Ritchie MacIver)
13:27:23 <pizza_> glen_quagmire: haskell enables end-to-end networks, utilizes scalable e-business infomediaries and enhances turn-key interactive web-readiness.
13:27:38 <DRMacIver> ...
13:27:49 <DRMacIver> pizza_: Your sentence makes the baby jesus don his kitten stomping boots.
13:27:58 <glen_quagmire> so, it's Enterprise!
13:28:08 <DRMacIver> Enterprise Haskell Beans.
13:28:11 <pizza_> DRMacIver: that's the idea.
13:28:25 <glen_quagmire> http://omg.worsethanfailure.com/ enter this contest
13:28:27 <lambdabot> Title: OMGWTF Programming Contest
13:28:29 <DRMacIver> pizza_: Why do you hate kittens? :(
13:28:34 <augustss> fasta: well, people a lot smarter than I have proven that equality is undecidable for the constructive reals.  I don't remember how the proof goes
13:29:01 <fasta> augustss: ok, interesting.
13:29:03 <DRMacIver> augustss: Surely this is an obvious statement?
13:29:03 <fasta> augustss: Thanks
13:29:11 <DRMacIver> Take some undecideable proposition.
13:29:27 <fasta> What are constructive reals?
13:29:29 <DRMacIver> Define a to be the real number whose binary expansion is 1 for every integer which encodes a proof of that proposition and 0 elsewhere.
13:29:33 <DRMacIver> Done.
13:29:41 <DRMacIver> s/integer/natural/
13:29:56 <augustss> faste: the real numbers you get when using constructive logic.  the ones you can actually compute with
13:29:58 <DRMacIver> (Done because whether a == 0 is equivalent to whether that proposition is proveable)
13:30:27 <glen_quagmire> nevermind it's for C++/C only
13:30:42 <fasta> augustss: but any computed number eventually is finite
13:31:14 <fasta> I guess they aren't algorithms, then.
13:31:16 <DRMacIver> glen_quagmire: Clearly the solution is to use Haskell to write a compiler which generates insanely stupid C.
13:31:16 <augustss> fasta: on a finite machine, yes.  but we usually live in the dream world of inifinte memory here
13:31:33 <fasta> augustss: no, even then. Algoritms must terminate
13:31:34 <Philippa> DRMacIver: and call it GHC? :-)
13:31:47 <DRMacIver> Philippa: no. GHC generates very clever but non human readable C. ;)
13:31:59 <fasta> augustss: so, constructive logic allows non-terminating computations?
13:32:15 <augustss> fasta: the point of the description of reals is that they don't terminate.  they give you as much as you need
13:32:21 <DRMacIver> Philippa: This would generate C which is human readable but makes you want to track down the person who wrote it and feed them to the lions.
13:32:29 <DRMacIver> (Well, s/GHC does/GHC can/
13:32:31 <DRMacIver> )
13:32:34 <QtPlatypus> I thought the point was that constructive logic didn't allow nonterminating proofs
13:32:48 <chessguy> better to feed them to blunt-toothed piranhas
13:32:58 <sieni> QtPlatypus: even classical logic don't allow nonterminating proofs :-)
13:32:58 <vali> i get a parse error. am i not indenting properly? http://hpaste.org/1569
13:33:13 <DRMacIver> (Idle note: A company without a scorpion pit is a company that is probably producing rather bad code)
13:33:38 <augustss> Constructive logic has no problem dealing with undecidable statements.
13:33:43 <chessguy> ?remember DRMacIver A company without a scorpion pit is a company that is probably producing rather bad code
13:33:44 <lambdabot> Done.
13:33:56 <DRMacIver> Heh
13:34:02 <DRMacIver> My first quoted statement. I feel so proud. :)
13:34:10 <Saizan> vali: yes, you have to align everything with the first function after every do
13:34:13 <fasta> augustss: http://en.wikipedia.org/wiki/Constructivist_logic <- just these rules?
13:35:10 <augustss> fasta: those are probably ok
13:35:11 <kpreid> vali: you must align 'doRead' with 'putStrLn', either by moving the former right or putting the latter on a new line
13:35:37 <kpreid> hm.
13:35:39 <vali> aaaah. thanks
13:36:07 <augustss> statements in constructive predicate logic are no more decidable than they are in classical
13:36:23 <kpreid> if you prohibit that one case, Haskell's and Python's indenting rules are the same
13:36:26 <augustss> but if you do find a proof it corresponds to a program
13:36:43 <Saizan> constructive == intuitionistic?
13:37:02 <augustss> Saizan: that's how I normally use it.  Some people make a disctinction
13:37:40 <DRMacIver> Saizan: The rules are a little different.
13:37:47 <Saizan> oh
13:38:01 <DRMacIver> Saizan: Constructive logic is a strict subset of classical logic. Intuitionistic logic has some features which contradict classical.
13:38:34 <Saizan> contradict?
13:38:54 <augustss> DRMacIver: well, it depends who you talk to :)
13:38:54 <DRMacIver> In particular in constructive logic the law of the excluded middle is not true, but it's never false. In intuitionistic logic it's sometimese false. (I think. It's been a while since I've looked at it.)
13:38:56 <vali> augustss: hmm, i put putStrLn on the same level as the others and then it says:  The last statement in a 'do' construct must be an expression
13:39:23 <DRMacIver> augustss: Hm. Possibly. These are the definitions I'm familiar with anyway. :)
13:40:07 <Saizan> vali: paste again :)
13:40:12 <DRMacIver> Perhaps better stated would be 'constructive logic is a strict subset of classical logic. Depending on meaning, intuitionist logic may have some features which contradict classical.'
13:40:22 <chessguy> augustss: did you see the google tech talk the other day, featuring djinn?
13:40:28 <hpaste>  vali pasted "Indentation" at http://hpaste.org/1570
13:40:56 <augustss> chessguy: I did actually.  The guy mostly knew what he was talking about, even.
13:41:17 <chessguy> yeah, and yet it was pretty comprehensible to us newbs
13:41:27 <augustss> that's cool
13:41:46 <augustss> He did misspell Bool in his last Djinn example, and didn't get the expected answer
13:42:02 <chessguy> yeah, that was pretty funny
13:42:08 <augustss> @djinn a -> Bool
13:42:09 <lambdabot> f _ = False
13:42:25 <chessguy> i caught that too. and Wadler didn't even mention it in his critique
13:42:36 <augustss> right
13:43:00 <chessguy> he did mention that f _ = False could be considered sort of isomorphic to f _ = True
13:43:17 <augustss> And type classes don't really pose a problem.  I've added them to Djinn
13:43:29 <chessguy> yeah, Wadler did say that
13:43:34 <chessguy> overall, a nice talk though
13:43:43 <Saizan> vali: it compiles here
13:43:45 <augustss> chessguy: yes.  in this case they are, but that is not true in general for different proofs
13:43:46 <chessguy> i liked the historical context
13:44:22 <Ksero> I'm on Windows XP, using ghc. When I try to abort an infinite evaluation in ghci (eg. trying to show [1..]) with ctrl+c, the calculation is indeed aborted, but the program seems to hang. Is this a known bug? Is there another way of aborting calculations in ghci?
13:45:11 <augustss> Ksero: doesn't ghci warn you when it starts?
13:45:13 <vali> Saizan: yes, it compiles, but i get that warning
13:45:24 <vali> Saizan: saying that the last statement in a 'do' must be an expression
13:45:58 <Saizan> vali: i don't get it, and the time it happened to me it was an error, not a warning
13:46:01 <augustss> vali: do you have TAB vs. space problems?
13:46:16 <vali> augustss: i have set emacs to use only spaces, no tabs at all
13:48:00 <Saizan> Ksero: 1) it's the same for me on XP  2) i dunno
13:48:38 <vali> augustss: if i open my source file in e.g. firefox, it looks the same.
13:50:51 <augustss> vali: what you pasted above compiles fine for me
13:51:27 <vali> augustss: for me it stops with:  The last statement in a 'do' construct must be an expression
13:52:10 <augustss> try copying what you pasted into a new file
13:52:19 <augustss> btw, what line is it complaining about?
13:53:09 * vali hides in the corner
13:53:44 <vali> augustss: after i fixed what you said earlier, it's complaining about another do now
13:55:59 <chilavek> hello, can anybody tell me if it's possible to define a monad instance for a datatype with a definition like "data List a = Nil | Cons a (List a)"?
13:56:04 <chilavek> i can't seem to figure it out
13:56:42 <bos> yes, it is.
13:56:50 <bos> in fact, lists are monads.
13:57:17 <chilavek> bos: can you show me? i can do it with something like "data List a = Nil | Atom a | Cons (List a) (List a)", but that's not quite the right structure
13:57:23 <vali> augustss: everything works now. thanks
13:57:45 <capisce> chilavek: that's a tree :)
13:57:57 <chilavek> capisce: i know
13:58:16 <capisce> don't you think List is a bit misleading then? :)
13:58:26 <chilavek> capisce: yes, sorry about that
13:58:27 <Saizan> chilavek: you can substitute Atom using Cons a Nil
13:58:36 <sjanssen> chilavek: can you write the function: join :: List (List a) -> List a?
13:58:51 <sjanssen> (also known as concat)
13:58:55 <Saizan> ?src concatMap
13:58:56 <lambdabot> concatMap f = foldr ((++) . f) []
13:59:14 <chilavek> sjanssen: that's basically where i get stuck. i can't seem to come up with a definition for that
13:59:19 <chilavek> i can do the map part, but not the concat
13:59:27 <chilavek> when defining (>>=)
14:00:38 <Saizan> chilavek: try to define ++ first
14:01:02 <Saizan> the "equivalent of"
14:02:14 <monochrom> Suppose you give me a tree of X's, say t :: List X, and a function from X to tree, say f :: X -> List Y.  We are interested in t>>=f.
14:04:05 <monochrom> Take a leaf of t, it holds a datum of X.  Give this datum to f, you get the tree "f datum".  You can imagine going back to t and replace that leaf holding "datum" by the tree "f datum".
14:04:08 <ddarius> wtf tree /= List, no?
14:04:27 <monochrom> "List" is Martian for "tree". :)
14:05:01 <chilavek> ddarius: if you're talking about my example above, sorry, didn't mean "List" there
14:05:10 <monochrom> So, do this to all leaves of t.  You may then have a sensible result for t>>=f.  Prove that this definition satisfies the monad laws.
14:05:25 <monochrom> Do not be put off by names.
14:05:56 <ddarius> It's a free monad. QED. </jackass>
14:06:10 <hpaste>  bos pasted "listy monady thingy" at http://hpaste.org/1571
14:06:21 <dmead> hey channel
14:06:32 <chessguy> hi dmead
14:06:34 <monochrom> Interesting. It's free but is it a monad?
14:06:55 <monochrom> Or is it true that all free algebraic data definitions are monads?
14:07:08 <ddarius> Assuming List/Tree is more or less what I think it is, then yes.
14:07:19 <bos> chilavek: see paste above
14:07:47 <ddarius> I think the answer to your second question is yes, but not necessarily free monads.
14:07:56 <dmead> do arrays allow side effects?
14:08:06 <ddarius> Mutable ones do.
14:08:06 <bos> dmead: depends on the array.
14:08:15 <dmead> hmm
14:08:20 <bos> if you use an STArray inside the ST monad, then yes.
14:08:23 <monochrom> I'm thinking you need more parentheses, bos.
14:08:27 <dmead> ahh
14:08:30 <bos> monochrom: no, i don't.
14:08:31 <dmead> right
14:08:40 <monochrom> I see. Nevermind.
14:08:42 <dmead> i need to update a list structure when traversing a tree
14:08:57 <dmead> and have each branch of the tree have visability to the same list
14:09:13 <dmead> whats the variable library called?
14:09:21 <bos> variable library?
14:09:39 <monochrom> This question is a good digression.
14:09:49 <vick_> Sorry i was disconnected, does 'type' has consutrctor like 'data' do ?
14:09:53 <dmead> yea, i seem to recall that global variables are available via a library
14:10:00 <bos> not really.
14:10:03 <dmead> oh
14:10:09 <Cheery> http://dev.codeflow.org/svn/cheery/hikiwiki.project/
14:10:11 <lambdabot> Title: Revision 84: /hikiwiki.project
14:10:14 <bos> unless you're willing to live inside the IO or ST monad.
14:10:16 <chilavek> bos: thanks. "app" is append (or (++)), yes?
14:10:17 <sjanssen> vick_: no
14:10:22 <bos> chilavek: yes.
14:10:30 <bos> actually, it's concat, not append.
14:10:33 <Cheery> gn for now, thought
14:10:53 <vick_> sjanssen: ok thanks :D
14:11:06 <monochrom> I recall someone posted a small library for global variables. Uses unsafePerformIO and Typeable and a BST.
14:11:09 <chilavek> bos: right. i see
14:11:16 <dmead> and MVar can't be used for side effect stuff?
14:11:59 <bos> monochrom: yeah, i saw that, but don't remember it.
14:12:06 <bos> dmead: to use MVars, you have to be inside IO.
14:12:15 <dmead> ah
14:13:16 <ddarius> app = flip (foldr Cons) which is (++)
14:14:27 <bos> monochrom: there's john hughes's paper i can readily see online, but that's it.
14:17:25 <Saizan> ?type concat
14:17:28 <lambdabot> forall a. [[a]] -> [a]
14:19:10 <ddarius> (>>=) though, does work out to concatMap as it should.
14:19:52 <Saizan> yep
14:19:54 <joelr1> evening
14:19:59 <joelr1> where's the source code to hpaste?
14:20:31 <Saizan> there's a link on the main page
14:20:53 <ddarius> At the bottom.
14:20:56 <joelr1> Saizan: thanks!
14:20:57 <Saizan> even if it's for the old api of happs
14:21:17 <Saizan> add a -devel for a more updated one
14:21:33 <int-e> he left.
14:21:40 <Saizan> ..
14:22:10 <Saizan> he will return.
14:22:23 <ddarius> And when he does...
14:23:52 <int-e> there he is
14:23:56 <joelr1> is there a template system for use with HAppS?
14:24:09 <joelr1> wow! int-e already answered, even before i asked!
14:24:49 <ddarius> "there he is" /= "there is"   (?)
14:25:10 <joelr1> argh
14:25:18 <joelr1> i read "there is"
14:25:25 <joelr1> umm, sorry about that
14:25:35 <joelr1> i'm at a crossroads tonight
14:25:52 <Saizan> template system?
14:26:21 <joelr1> Saizan: well, yes, to be able to leave the html in files and use placeholders to insert the data
14:26:33 <Saizan> there are some macros, to infer StartState or define accessors/updators
14:26:43 <Saizan> ahh
14:26:53 <sjanssen> joelr1: I think xslt is the recommended approach
14:26:54 <joelr1> i'm so fed up with ast transformations in haskell that i want to go back to the ocaml version of my compiler/translator
14:26:58 <Saizan> mmh, no, xslt is reccomended
14:27:00 <joelr1> i consider the code rather ugly
14:27:19 <joelr1> sjanssen: isn't that ... a bit convoluted?
14:27:25 <joelr1> there must be simpler ways than xslt
14:27:47 <Saizan> you can use the xhtml package like hpaste
14:27:54 <joelr1> i think the monadic approach in haskell introduces too much noise into the code when AST transformations are concerned
14:27:56 <sjanssen> joelr1: have you already written the ast transformations in ocaml?
14:28:08 <joelr1> Saizan: hpaste generates the html
14:28:16 <joelr1> sjanssen: yep, a working compiler
14:28:25 <sjanssen> joelr1: then why did you switch?
14:28:36 <joelr1> sjanssen: then i got stuck with deploying it on the web and spent another month rewriting it in haskell :D
14:29:01 <Saizan> mmh, maybe ndm's Play class could make the ast transformation easier
14:29:28 <bos> joelr1: you have quite the on-again, off-again relationship with haskell :-)
14:29:31 <joelr1> don't ask me why, i always do this. with my poker server i went delphi -> c# -> c -> scheme -> lisp before finally settling on erlang. of course i didn't implement full poker servers in each, the most complete was the lisp version but it lacked a network layer. the last version had it all.
14:29:41 <joelr1> bos: true
14:30:03 <joelr1> Saizan: i'm not familiar with ndm's Play but i did ask lots of questions on cafe
14:30:15 <monochrom> I want joelr1's job. :)
14:30:35 <joelr1> so now i have an almost complete haskell version and a basically working ocaml version
14:30:53 <Saizan> ?where play
14:30:53 <lambdabot> I know nothing about play.
14:31:22 <joelr1> i even started writing in lisp today since lisp is the ultimate language for ast transformations. with lisp the problem is lack of parsing/lexing tools on the level of ocaml and haskell
14:31:34 <joelr1> monochrom: i don't have a job. i've been freelancing for the past 10 years
14:31:42 <ski> All work and no play makes Jack a dull boy.
14:31:44 <joelr1> monochrom: this is my startup (compiler)
14:31:49 <sioraiocht> is there a way to convert an Integer to an Int
14:32:02 <sjanssen> sioraiocht: fromInteger
14:32:05 <sioraiocht> thanks!
14:32:14 <sjanssen> or fromIntegral, the workhorse of the Num hierarchy
14:32:45 <joelr1> anyway, i'm at a crossroads this evening. do i finish up the transformation from "core" ast to c# ast, add tests and pretty printer for c# , then deploy on the web with HAppS?
14:32:53 <ski> @tell ndm maybe you could use 'All work and no play makes Jack a dull boy.' as some kind of slogan for 'Play' ?
14:32:53 <lambdabot> Consider it noted.
14:33:18 <joelr1> or do i add type-checking to the ocaml version (which already has a pretty printer and transforms directly into the c# ast) and deploy that?
14:33:18 <Saizan> http://www.cs.york.ac.uk/fp/darcs/play/play.htm <-- the examples in the manual use an AST, (it's unreleased btw)
14:33:21 <lambdabot> Title: Play With Your Boilerplate
14:33:56 <sioraiocht> is there anway to make this less hideous? putChar $ chr (fromIntegral (head ((queues env) !! (current env)))))
14:33:57 <joelr1> of course the ocaml version will need a day or two of refactoring given the knowledge that i picked up from writing the haskell version. this would include the type checker.
14:34:21 <joelr1> what's your advice folks?
14:35:02 <sjanssen> sioraiocht: reduce parens: putChar $ chr $ fromIntegral  $ head (queues env !! current env)
14:35:11 <ski> putChar $ chr . fromIntegral . head $ queues env !! current env
14:35:32 <monochrom> eww
14:35:48 <joelr1> ocaml has polymorphic variants that make ast transformations easier
14:35:53 <sjanssen> putChar . chr . fromIntegral . head $ queues env !! current env -- stick with the same style
14:36:00 <xerox> instance Show Env where ...
14:36:25 <sioraiocht> thanks :)
14:37:17 * ski refrains from inserting reader monadic operation
14:37:18 <Saizan> ?type ap
14:37:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:37:23 <Saizan> eh :D
14:37:34 <sioraiocht> ski: ?
14:38:01 <Saizan> putChar . chr . fromIntegral . head . ap (!!) queues current $ env
14:38:02 <ski> @pl \env -> queues env !! current env
14:38:02 <lambdabot> liftM2 (!!) queues current
14:38:13 <sioraiocht> ...
14:38:19 <bd_> Hm, in Data.Generics, is there a monadic equivalent to everything'? There's everythingM but that's traversing things in the wrong order for me...
14:38:50 <chessguy> @type liftM2
14:38:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:39:04 <sioraiocht> @src ap
14:39:04 <lambdabot> ap = liftM2 id
14:39:06 <bd_> wait, maybe I can just write it...
14:39:08 <sioraiocht> hah
14:39:17 <Saizan> mmh ap was wrong
14:40:10 <ski>  putChar . chr . fromIntegral . head $ return (!!) `ap` queues `ap` current
14:40:17 <kpreid> @src everywhereM
14:40:18 <lambdabot> Source not found. My pet ferret can type better than you!
14:40:24 <kpreid> @src Data.Generics.everywhereM
14:40:25 <lambdabot> Source not found. It can only be attributed to human error.
14:40:25 <ski>  putChar . chr . fromIntegral . head $ (!!) `liftM` queues `ap` current
14:40:36 <kpreid> @src Data.Generics.Schemes.everywhereM
14:40:37 <lambdabot> Source not found. stty: unknown mode: doofus
14:40:56 <xerox> ski, now with Control.Applicative :)
14:41:17 <ski> what's the difference ?
14:44:17 * ski wonders if partially applied coexponentials make nice comonads ..
14:44:23 <micahcowan> Book recommendations, anyone? Yes, I've read http://haskell.org/haskellwiki/Books_and_tutorials; considered buying Hutton, but I understand it's fairly incomplete.
14:44:25 <lambdabot> Title: Books and tutorials - HaskellWiki
14:44:44 <monochrom> coexponentials?!
14:44:50 <sioraiocht> gah, okay, So i have three queues represented as regular lists, and they are indexed 0, 1, 2.  is there anyway I can efficiently both a) keep them somehow indexed but b) not have to worry about all the queues at once (as I would with a list of lists)
14:45:10 <ski> monochrom : you know, the dual of exponentials ..
14:45:15 <monochrom> No book is complete.  Actually I also mean every book is fairly incomplete.
14:45:44 <monochrom> K&R doesn't teach you web server programming in C.
14:46:16 <dolio> A serious oversight on their part.
14:47:33 <capisce> :)
14:48:01 <sjanssen> micahcowan: I've heard good things about Hutton's book
14:48:19 <sjanssen> micahcowan: there will be a review of it in the next TMR
14:48:31 <chessguy> sioraiocht: Map Int [a] maybe?
14:48:46 <chessguy> or an array of lists
14:49:12 <micahcowan> monochrom, but, K&R does teach all of the C language (minus a good chunk of the library, if you include that in the "language" [as ISO does]). Hutton apparently leaves out monads and others...
14:49:24 <osfameron> tmr?
14:49:29 <micahcowan> But, if Hutton really is good, I suppose I can supplement my knowledge with more complete, online references
14:50:06 <sioraiocht> chessguy: the problem right now is they are part of a record, and I'd like to be able to be modify them individually, but if I make them separate fields I have a lot of ugly conditionals when reading them by index
14:50:07 <chessguy> micahcowan: i like HSOE, too
14:50:10 <chessguy> ?where hsoe
14:50:11 <lambdabot> I know nothing about hsoe.
14:50:14 <joelr1> bos: did you just shoot me that email?
14:50:18 <chessguy> ?where soe
14:50:19 <lambdabot> http://haskell.org/soe/
14:50:22 <monochrom> I see.  Bird's has monad transformers and parser combinators.
14:50:28 <bos> joelr1: huh?
14:50:37 <ddarius> @where tmr
14:50:38 <chessguy> sioraiocht: mmmm, you're going to have to be less vague
14:50:38 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
14:50:44 <joelr1> will the real bas van dijk please stand up?
14:50:50 <micahcowan> monochrom, is Bird's otherwise good?
14:50:57 <sioraiocht> @paste
14:50:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:51:00 <chessguy> joelr1: we need a ?whois
14:51:02 <monochrom> Yes. I compare it to K&R.
14:51:09 <joelr1> yeah
14:51:39 <ddarius> Luckily IRC has one that will tell you that bos is Bryan O'Sullivan.
14:51:43 <bvd> joelr1: no I send you the mail :-)
14:51:56 <joelr1> bvd: thanks! i just wanted to say that polymorphic variants are not the same as variantP :-(
14:52:04 <osfameron> ddarius: ta
14:52:14 <monochrom> Dry, linear, technical, rigorous.
14:52:29 <micahcowan> monochrom, hrm, I'm honestly not a huge fan of K&R (though it probably is the best C book on the market, regardless) :)
14:52:30 <chessguy> ?where bird
14:52:31 <lambdabot> I know nothing about bird.
14:52:34 <joelr1> bvd: or, at least, they are not as efficient
14:52:47 <bvd> joelr1: right
14:52:56 <joelr1> bvd: and using them is not as convenient. i appreciate the pointer, though!
14:53:03 <monochrom> I strongly believe in dry, linear, technical, rigorous.
14:53:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1572
14:53:29 * dolio wants a copy of the evil bird book, even though he wouldn't be able to read it.
14:53:44 <joelr1> bvd: i think i tried using HList for my previous haskell project, to be able to reuse constructors but that quickly turned out downright complex
14:53:47 <sioraiocht> chessguy: http://hpaste.org/1572
14:53:50 <micahcowan> monochrom, I believe in that, too. I'm not entirely certain that K&R passes that criteria.
14:53:51 <chessguy> sioraiocht: first of all, you know you don't actually want to represent a Queue with a list, right?
14:54:04 <sioraiocht> chessguy: why not? it works fine for what I want
14:54:21 <chessguy> last-entry-access is O(n)
14:54:27 <monochrom> If K&R adds a chapter on formally deriving programs from formal specifications, it will.  Bird's has that.
14:54:42 <micahcowan> monochrom, also, I require something somewhat /less/ dry than the actual language spec itself (otherwise, I'd just grab the Haskell report) :)
14:54:42 <chessguy> ?docs Data.Queue
14:54:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Queue.html
14:54:44 <monochrom> (Also if K&R adds monad transformers and parser combinators...)
14:55:13 <monochrom> Bird's is less dry than the report.
14:55:23 <sioraiocht> chessguy: that's handy
14:55:25 <micahcowan> monochrom, I think K&R could've been a tad more rigorous :)
14:55:26 <sjanssen> sioraiocht: if you're on ghc 6.6, Data.Sequence makes a nice queue (O(1) amortized for all queue like operations)
14:55:36 <chessguy> sioraiocht: indeed
14:55:45 <monochrom> Yeah. But it's already more rigorous than other C texts.
14:55:54 <sjanssen> chessguy, sioraiocht: note that Data.Queue is deprecated in favor of Data.Sequence
14:56:06 <micahcowan> monochrom, unfortunately, yes. As I said, it's the best, it's just not (IMO) good enough :(
14:56:11 <sioraiocht> @docs Data.Sequence
14:56:12 <monochrom> It's as rigorous as any programmer-who-don't-care-about-logic gets.
14:56:12 <lambdabot> Data.Sequence not available
14:56:13 <whaleofconfusion> this is just a thought--might it be possible in some cases to use static type inference to determine the type of data structure you want to use, based on the code you have written that uses it and what operations that code performs on the structure?
14:56:15 <chessguy> sjanssen: yeah, but i don't think Data.Sequence actually has a Queue writtein in it, does it?
14:56:22 <sioraiocht> orly, lambdabot?
14:56:39 <monochrom> OK, you will find Bird's more rigorous.  There are calculations proofs.
14:56:47 <monochrom> err calculational proofs
14:57:04 <chessguy> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
14:57:07 <lambdabot> http://tinyurl.com/yz86s7
14:57:18 <chessguy> sioraiocht: this is what sjanssen was referencing
14:57:24 <chessguy> sioraiocht: and trust him way more than me :)
14:57:24 <sjanssen> chessguy: it supports all the Queue ops (enqueue, dequeue, etc.)
14:57:35 <sjanssen> chessguy: they just have funny names
14:57:43 <sjanssen> enqueue is spelled <|
14:57:45 <micahcowan> monochrom, will Bird make a decent book to a brand-spanking-new learner, who has some experience with functional-ish programs (XSLT, Lisp) and is in possession of a brain (I have been known to learn languages via their technical specs [ISO], but usually much prefer a gentle, but complete, approach).
14:57:46 <chessguy> oh yeah, i forgot that
14:57:51 <sjanssen> dequeue is viewl
14:58:25 <chessguy> anyway, his design question is ulitmately different, and i'm not sure the best way to handle it
14:58:41 <monochrom> I can't swear I know.  I'll assign a high probability.
14:58:53 <bvd> Hello, is it true that GHC Head now support overloaded String literals?
14:59:12 <sjanssen> bvd: correct
14:59:16 <bvd> Great!
14:59:21 <monochrom> Oh, have you considered the wikibook on haskell too?
14:59:29 <micahcowan> monochrom, I'm assuming that you're referring to "Intro to FP using Haskell"?
14:59:43 <sioraiocht> chessguy: back to my original quesiotn, which do you favour, a list of queues for seperate fields?
14:59:49 <sioraiocht> *separate
14:59:53 <chessguy> sioraiocht: i'm not sure
14:59:57 <micahcowan> monochrom, I believe I've fished around for tutes on the web, and found them generally inadequate: either too easy or else too confusing an approach.
14:59:57 * ski . o O (hrm .. 'extract' for this comonad seems obvious enough .. just exceptional return .. but cobind is a bit strange ..)
15:00:07 <chessguy> sioraiocht: it probably depends on how you want to use it
15:00:18 <micahcowan> ("easy" read "slloooowwww, and incomplete")
15:00:18 <sjanssen> sioraiocht: are the number of queues static?
15:00:23 <sioraiocht> sjanssen: yes
15:00:32 <chessguy> an array would work
15:01:09 <monochrom> "Intro to FP using Haskell" by Bird I'm referring to, yes.
15:01:09 <chessguy> anyway, time for me to scuttle out of here. 'night all
15:01:24 <sjanssen> sioraiocht: how about data Queues = Queues {queue1, queue2, queue3 :: Queue}?
15:01:40 <sjanssen> sioraiocht: then use record update syntax when you want to modify one
15:01:51 <sioraiocht> nested records...that should be fun =p
15:01:55 <sjanssen> presumably you'd give them more descriptive names
15:02:07 <sjanssen> sioraiocht: that isn't nested, Queues /= Queue
15:02:22 <monochrom> have you seen http://en.wikibooks.org/wiki/Programming:Haskell ?  Some picky guy found it complete. (ok, it's also slow, but that guy liked slow. but complete.)
15:02:25 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
15:02:27 <sioraiocht> sjanssen: the problem is that there is a notion of a "current" queue
15:02:31 <sioraiocht> and it is an index from 0-2
15:02:40 <sioraiocht> i think an array woudl be better
15:04:43 <micahcowan> monochrom, thanks for that, I'll look into it.
15:09:16 <sioraiocht> so how do I CONSTRUCT an array?
15:09:20 <sioraiocht> listArray?
15:09:31 <monochrom> that's one way, yes.
15:09:40 <monochrom> Another is array.
15:10:19 <sjanssen> @docs Data.Array
15:10:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
15:10:36 <dolio> > listArray (1, 3) [1..3] :: Array Int Int
15:10:38 <lambdabot>  array (1,3) [(1,1),(2,2),(3,3)]
15:11:17 <dolio> > array (1, 3) [(3, 1), (2, 2), (1, 4)] :: Array Int Int
15:11:19 <lambdabot>  array (1,3) [(1,4),(2,2),(3,1)]
15:13:24 <dolio> > accumArray (+) 0 (1, 3) [(3, 1), (2, 2), (1, 4)] :: Array Int Int
15:13:26 <lambdabot>  array (1,3) [(1,4),(2,2),(3,1)]
15:13:33 <sioraiocht> heheh thanks,
15:13:54 <dolio> > accumArray (+) 0 (1, 3) [(3, 1), (2, 2), (1, 4), (1, 5)] :: Array Int Int
15:13:56 <lambdabot>  array (1,3) [(1,9),(2,2),(3,1)]
15:14:00 <dolio> There we are.
15:14:32 <syntaxfree> I wish the default definitions for foldr, etc. were the ones in Data.Foldable and Data.Traversable
15:14:43 <syntaxfree> import qualified Data.Set as Set is ugly.
15:15:03 <syntaxfree> I mean, why do we have type classes?
15:15:06 <sorear> hello.
15:15:07 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:16:53 <ski> > let tabulate ix f = accumArray (const f) undefined ix (join (,) `map` range ix) in tabulate (0,9) $ \x -> x * x + 1
15:16:55 <lambdabot>  array (0,9) [(0,1),(1,2),(2,5),(3,10),(4,17),(5,26),(6,37),(7,50),(8,65),(9,...
15:16:57 <monochrom> We have type classes because we do type-level Turing machines.
15:17:08 <sorear> @messages
15:17:08 <lambdabot> sjanssen said 15h 37m 26s ago: you forgot to send your property related changes to X11-extras
15:17:08 <sjanssen> syntaxfree: there is tension between flexibility and ease of use
15:17:09 <lambdabot> sjanssen said 14h 39m 51s ago: nevermind, I got your patch
15:17:11 <dolio> syntaxfree: To confuse newbies with our error messages? :)
15:21:59 <sioraiocht> sjanssen: what's the equivalent of popping off the first member of a queue?
15:22:06 <sioraiocht> (i.e. the head)
15:22:30 <sjanssen> sioraiocht: use viewl
15:22:36 <sioraiocht> sjanssen: thanks
15:24:48 <monochrom> ski: is there a reason you don't just use listArray (0,9) (map (\x -> x*x+1) [0..9])?
15:25:30 <sorear> @seen ndm
15:25:31 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 4h 45m 42s ago, and .
15:25:53 <twanvl> There should really be a buildin 'funArray' for those things
15:26:03 <sioraiocht> :t V viewl
15:26:06 <sioraiocht> :t viewl
15:26:12 <lambdabot> Not in scope: data constructor `V'
15:26:12 <lambdabot>  
15:26:12 <lambdabot> <interactive>:1:2: Not in scope: `viewl'
15:26:14 <lambdabot> Not in scope: `viewl'
15:26:26 <emu> @hoogle viewl
15:26:27 <lambdabot> No matches found
15:26:29 <emu> @hoogle viewL
15:26:30 <sioraiocht> @type Data.Sequence.viewl
15:26:30 <lambdabot> No matches found
15:26:32 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.ViewL a
15:26:47 <sioraiocht> sjanssen: WHY do i get a viewL a and not just a
15:27:18 <sorear> sioraiocht: read the haddocks!
15:27:23 <sorear> @docs Data.Sequence
15:27:24 <lambdabot> Data.Sequence not available
15:27:28 <sorear> boo!
15:27:29 <Saizan> a ViewL is ( a :< s) where s is the "tail" of the sequence
15:27:32 <sioraiocht> sorear: I am =p
15:27:46 <sorear>    data ViewL a
15:27:46 <sorear>    = EmptyL
15:27:46 <sorear>    | (:<) a (Seq a)
15:27:46 <monochrom> A view for a kill.
15:27:59 <sorear> sioraiocht: surely you don't want a crash!
15:28:05 <monochrom> @quote view
15:28:06 <lambdabot> lispy says: if you generate 1 billion patches per second, what maintainer will review them?
15:28:08 <sioraiocht> sorear: *sigh* I guess NOT =p
15:28:16 <monochrom> @quote enough
15:28:17 <lambdabot> ivanm says: no one thinks I'm quotable enough :'(
15:28:33 <monochrom> @quote 007
15:28:34 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
15:28:34 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
15:28:39 <monochrom> @quote Bond
15:28:40 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
15:28:40 * twanvl thinks ViewL ought to be generalized so it also works for lists, bytestrings, etc.
15:28:44 * monochrom cries
15:28:53 * sorear laughs evilly
15:29:13 <emu> @instances ViewL
15:29:14 <lambdabot> Couldn't find class `ViewL'. Try @instances-importing
15:29:18 <monochrom> @quote movie
15:29:19 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
15:29:21 <sorear> it's not a class!
15:29:31 <emu> @info ViewL
15:29:32 <lambdabot> ViewL
15:29:40 <emu> i could have told you that!
15:29:47 <sorear> emu: @inFO --> @inDEX
15:29:58 <emu> @index ViewL
15:29:59 <lambdabot> bzzt
15:30:01 <sorear> emu: read the haddock!
15:30:03 <emu> @slap lambdabot
15:30:04 * lambdabot smacks lambdabot about with a large trout
15:30:09 <sorear> <sorear>    data ViewL a
15:30:09 <sorear> <sorear>    = EmptyL
15:30:09 <sorear> <sorear>    | (:<) a (Seq a)
15:30:17 * emu slaps sorear around with a large haddock
15:30:24 <emu> actually I've used ViewL before, I'm just probing lambdabot
15:30:32 <matthew-_> stop hurting the fish!
15:30:50 <sioraiocht> it's just annoying, because it make me have to get the value out before I can use it
15:30:51 <sioraiocht> =p
15:31:18 <sioraiocht> @hoogle ViewL a -> a
15:31:20 <lambdabot> No matches, try a more general search
15:31:22 <sioraiocht> didn't think os
15:31:31 <vick> what does data Fruit = Kiwi | Apple | Banana mean ?
15:31:38 <vick> Constructors with no types ?
15:31:57 <monochrom> Have you heard of "enumerated types"?
15:32:02 <vick> Yep
15:32:12 <vick> Fruit is either kiwi or apple or banana
15:32:20 <vick> Is that correct ?
15:32:22 <monochrom> That is right.
15:32:28 <Saizan> yep
15:32:29 <vick> But aren't those constructors also ?
15:32:34 <Saizan> Kiwi :: Fruit
15:32:34 <monochrom> Yes.
15:32:40 <matthew-_> yes, parameterless constructors
15:32:43 <sorear> sioraiocht: can'y you just use `index 0`
15:32:45 <sorear> ?
15:33:01 <vick> Saizan: if i have a function that takes as input kiwi, but not apple nor banana
15:33:03 <sorear> @type Data.Sequence.index
15:33:05 <lambdabot> forall a. Data.Sequence.Seq a -> Int -> a
15:33:18 <matthew-_> if data Foo = Bar Baz which means Bar :: Baz -> Foo, then data Foo2 = Qux means Qux :: Foo2
15:33:19 <monochrom> You can't really do that.
15:33:27 <Saizan> vick: you can't express that with that type
15:33:35 <sorear> monochrom: (`index` 0) are you happy now?
15:33:36 <sorear> ;)
15:33:36 <vick> Saizan: but i can with data, right ?
15:34:01 <monochrom> Hrm, I forgot what (`index` 0) is for
15:34:08 <Saizan> if you make a data declaration for each fruit  yes
15:34:28 <vick> Saizan: can't i do something like func :: kiwi ?
15:34:29 <Saizan> than you can have a function :: Kiwi -> a
15:34:53 <monochrom> Can you do something like func :: 0 -> Bool?
15:34:53 <Saizan> given data Fruit = Kiwi | Apple | Banan, Kiwi is not a tye
15:34:56 <Saizan> *type
15:35:29 <vick> Saizan: i'm a little bit confused between the diffrence between type and data
15:35:47 <Saizan> not data, values
15:35:47 <monochrom> 0 is data. Int is type.
15:36:08 <monochrom> Oh, you get hung up on the choice of the word "data"?
15:36:23 <vick> Yeah
15:36:28 <vick> data something = heh
15:37:06 <monochrom> It defines a data type.  The bottom line is Fruit is type, Kiwi is a value.
15:37:27 <monochrom> Never, ever, read deep into names.
15:37:40 <monochrom> err, read deeply
15:37:56 <vick> monochrom: so for 'data' i can have a function that accept Kiwi but for 'type' i can't
15:38:13 <vick> data Fruit = Kiwi | Orange
15:38:19 <vick> func :: Orange -> Bool
15:38:31 <vick> But i can't do that with type
15:38:38 <vick> i though data was used for enumeration
15:38:46 <monochrom> God curse English.
15:38:52 <Saizan> you can't have func :: Orange -> Bool, only func :: Fruit -> Bool
15:38:55 <monochrom> I'm not going to play this word game anymore.
15:39:05 <Saizan> you can't use a data constructor in a type signature
15:39:21 <Saizan> you can only use type names, like Fruit is
15:39:33 <monochrom> Just pretend all keywords are from Japanese and Korean, never interpret as English, ok?
15:39:45 <vick> Saizan: when is 'data' used and when is 'type' used ?
15:39:48 <vick> monochrom: heh.
15:39:54 <monochrom> "data" is pronounced "dah tah", Japanese for "fertility"
15:40:09 <Saizan> vick, type as in type String = [Char] ?
15:40:22 <vick> that i get.
15:40:22 <monochrom> "type" is pronounced "tie pei", Korean for "light"
15:40:47 <vick> Saizan: Then later i could make something like func :: String -> Bool
15:40:55 <Saizan> yep
15:41:01 <vick> What about 'data' ?
15:41:27 <aFlag> data defines a new type, while type is just type renaming
15:41:32 <Saizan> well type as a kayword is used to introduce a type synonim, just an alias for a comples type
15:42:02 <Saizan> data instead introduces a whole different type, never seen before, that must have data contructors
15:42:36 <Saizan> when you have data Fruit = Kiwi | Orange, you are defining the type Fruit, so you can have func :: Fruit -> Bool
15:42:55 <sioraiocht> @type ord
15:43:01 <lambdabot> Char -> Int
15:43:24 <Saizan> the keyword type should be named typesynonim, as it's not the only way you can define a type
15:43:44 <vick> so type Fruit = Orange | Kiwi is invalid unless Orange and Kiwi are defined.
15:44:02 <bd_> type can't have an alternation there.
15:44:04 <monochrom> | is invalid in "type Fruit = ..."
15:44:10 <bd_> Do you mean: data Fruit = Orange | Kiwi ?
15:44:24 <bd_> type just gives a type a shorthand name
15:44:29 <vick> oh
15:44:34 <monochrom> bd_: vick is still learning "type" and "data".
15:44:38 <bd_> ah
15:44:50 <vick> i get it somehow.
15:44:57 <vick> i'll try to play it with a little.
15:45:01 <vick> Thanks a lot guys.
15:45:13 <Saizan> plus type Fruit = Orange would need Orange to be a type, instead in data Fruit = Orange | .. Orange is a data contructor, a value of type Fruit in this case
15:45:30 <bd_> and uh, what's with "dah tah" being japanese for fertility? >.>;
15:46:25 <monochrom> If you go by English interpretations of those words you get confused.
15:47:01 <monochrom> esp because sometimes English data also means English value
15:47:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1573
15:47:25 <bd_> Well, I mean, I'm actually studying Japanese, and 'dah tah'... well, I'd try looking it up but those syllables don't actually exist in Japanese :)
15:47:26 <monochrom> who is anonymous and why it has no title?
15:47:28 <AStorm> ?where yaht
15:47:28 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
15:47:34 <emu> sure they do
15:47:36 <emu> data
15:47:42 <monochrom> I'm making it up :)
15:47:49 <bd_> ah, fair enough then :)
15:48:08 <emu> almost the same kana too
15:48:23 <AStorm> Blah, I've to find a C function pointer replacement in Haskell.
15:48:29 <AStorm> :|
15:48:33 <emu> AStorm: a function
15:48:42 <monochrom> Foreign.Ptr
15:48:45 <bd_> emu: DE-TA for data; hanshokuryoku for fertility, I think?
15:48:56 <emu> possibly, i didn't look it up
15:49:02 <AStorm> monochrom: that won't work too well
15:49:06 <AStorm> and looks foreign :P
15:49:07 <emu> as for pronunciation of "data" well
15:49:12 <emu> english speakers sound funny anyhow
15:49:19 <nattfodd_> hi, any xmonad hacker/user around?
15:49:40 <AStorm> monochrom: something more Haskell-like, so I can bind a function to the number
15:49:48 <emu> deita? =)
15:49:53 <AStorm> yeah,I know, I can use an additional function with pattern-match
15:49:56 <bd_> AStorm: execute 2 state = ... ?
15:50:05 <bvd> nattfodd_: I'm a xmonad user
15:50:07 <AStorm> And some enum-like datatype
15:50:08 <bd_> AStorm: Or IntMap Int (MVar Env -> IO ())
15:50:19 <bd_> AStorm: Or IntMap Int (ReaderT (MVar Env) IO ()) ...
15:50:28 <AStorm> bd_: hmm
15:50:33 <AStorm> Nope.
15:50:35 <bd_> nope?
15:50:57 <nattfodd_> bvd: do you know of a way to have a permanent toolbar like in dwm?
15:50:59 <AStorm> Close though. I'll dig in a bit.
15:52:03 <AStorm> bd_: but that will look like imperative programming, blah :P
15:52:12 <AStorm> Anyway.
15:52:18 <bd_> AStorm: What will, the use of IntMap?
15:52:30 <bd_> join $ lookup id theMap :)
15:52:51 <bd_> using a MVar is plenty imperative already ;)
15:52:58 <AStorm> bd_: nope, the use of MVar and ReaderT
15:53:17 <AStorm> IntMap itself isn't that bad.
15:53:42 <bd_> ReaderT isn't really imperativeish imo
15:53:51 <bd_> StateT Env IO ()?
15:54:26 <AStorm> hmm, I'll have to be imperative anyway
15:54:39 <AStorm> either using list monads, or MArray for the VM registers :P
15:54:54 <bd_> DiffArray! ;)
15:55:04 <AStorm> Uhm, what?
15:55:15 <bd_> It's a pure array with O(1) updates
15:55:21 <bd_> @doc Data.Array.Diff
15:55:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Diff.html
15:55:24 <AStorm> :O
15:55:28 <AStorm> Oh really?
15:55:31 <AStorm> What's the catch?
15:55:47 <Saizan> lookup to older version gets slower
15:56:16 <AStorm> I don't need no steenkin' olde versions :P
15:56:23 <Gwern> so, uh, I'm having problems with the latest darcs of X11: "Couldn't match expected type `UserHooks'   against inferred type `Maybe UserHooks'"
15:56:26 <bd_> Yes; it basically keeps an undo list as you perform updates. If you let the old versions get GC'd, the list gets GC'd with it, but if you hold it around and access it, it's O(n) vs the number of updates.
15:56:34 <AStorm> Memory usage?
15:56:37 <bd_> And of course there's a little overhead from maintaining this
15:57:09 <bd_> AStorm: If you don't have a space leak from the older versions somewhere, it should be fairly small (it allocates extra storage of course, but that gets GC'd right away)
15:57:32 <AStorm> DiffUArray will suffice
15:57:54 <AStorm> I only have to keep some Bits there.
15:57:55 <Saizan> Gwern: you have to delete a type signature in Setup.hs i suspect
15:58:39 <bd_> AStorm: That said, you might want to consider doing things in a monad anyway, in case you want to optimize it later. You could use a type-alias of Identity for example :)
15:59:29 <AStorm> Uhm, I don't need identity between the functors
15:59:40 <AStorm> (right now, at least - and I think I won't)
15:59:42 <bd_> ?
15:59:48 <bd_> no, I mean Control.Monad.Identity :)
15:59:58 <bd_> It does nothing, but if you want to make it a 'real' monad later, you can
16:00:12 <AStorm> Too weak :>
16:00:13 <bd_> though... if you wanted to go to ST it won't help much :)
16:00:16 <Gwern> Saizan: ok, if I comment all the type sigs out, then configure at least seems to run
16:00:22 <AStorm> I need some arguments :P
16:00:32 <Gwern> but that can't be good, needing to do that for a package like X11 though, right?
16:00:57 * sieni hands x, y and z to AStorm 
16:00:58 <AStorm> The Bits class instance (esp. Int) will suffice
16:01:41 <AStorm> sieni: thanks, now I can go and implement those VM operations as functors :P
16:01:48 <Gwern> ack! that didn't fix my xmonad problem. :(
16:02:02 <Gwern> do error like 'ghc15331.hc:(.data+0x278): undefined reference to `GHCziBase_ZMZN_closure'' look familiar to anyone?
16:02:08 <Gwern> *errors
16:02:27 <AStorm> Gwern: yep, like a lack of main function
16:02:33 <AStorm> :>
16:02:33 <Saizan> mmh link problems
16:03:15 <AStorm> Gwern: if you want to do a lib, add -c option
16:03:21 <Gwern> AStorm: lack of main? dunno, Main.hs in xmonad seems to have that covered
16:03:34 <AStorm> Gwern: maybe not, check again :>
16:04:40 <Saizan> AStorm: why GHCziBase_ZMZN_closure would refer to main?
16:05:15 <AStorm> Saizan: I didn't say it's the exact message - it just looks like one
16:05:21 <AStorm> Maybe some -lxmonad is missing :P
16:05:47 <Gwern> oy. a runhaskell Setup clean later, and now it won't even compile. so I guess the link errors was because it was using the stale X11 library
16:06:35 <dmead> you can also use make
16:06:44 <dmead> which is probably better for portability, imo
16:07:45 <AStorm> Cabal is even better too :>
16:08:15 <Saizan> Cabal works on windows with just an haskell compiler, make does not
16:08:28 <Gwern> dmead: not like I have a choice: the xmonad maintainers use cabal, so...
16:08:56 <dmead> those crazy kids
16:09:28 <AStorm> The Cabal will have you, anyway.
16:09:54 <Gwern> there is no cabal
16:10:15 <AStorm> bd_: maybe I'll use the Functor interface directly
16:10:29 <AStorm> it has almost everything I need :P
16:11:46 <sioraiocht> is there a Byte type in haskell?
16:11:50 <dmead> yea
16:11:56 <sioraiocht> @docs Byte
16:11:57 <lambdabot> Byte not available
16:11:57 <dmead> there is
16:12:02 <sioraiocht> @docs Data.Byte
16:12:03 <dmead> @where bytestring
16:12:03 <lambdabot> Data.Byte not available
16:12:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
16:12:05 <AStorm> sioraiocht: it's called Int
16:12:08 <AStorm> or Char
16:12:20 <dmead> check out bytestring
16:12:21 <AStorm> Bits is a class
16:12:28 <sioraiocht> AStorm: Int is NOT only 8bits
16:12:39 <AStorm> @docs CTypes
16:12:40 <lambdabot> CTypes not available
16:12:41 <dmead> well there integer or Int
16:12:45 <dmead> integer is a class
16:12:52 <AStorm> @docs Data.CTypes
16:12:53 <lambdabot> Data.CTypes not available
16:12:53 <dmead> int is a primative
16:12:57 <dmead> IIRC
16:12:57 <AStorm> Gah.
16:13:05 <dmead> what are you trying to find?
16:13:20 <AStorm> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html
16:13:23 <lambdabot> http://tinyurl.com/2x9kwh
16:13:24 <sioraiocht> dmead: I just need a structure (maybe I need to make it) that will store only an 8-bit number, and guarantee it wont  larger
16:13:39 <sioraiocht> *be larger
16:13:41 <AStorm> sioraiocht: use one of these
16:13:42 <sioraiocht> without an error
16:13:45 <dmead> ah
16:13:47 <dmead> yea
16:13:49 <dmead> #Int
16:13:50 <dmead> i think
16:13:54 <dmead> err no
16:13:55 <dmead> xD
16:13:56 <AStorm> #Int is 32-bit
16:13:56 <dmead> hold on
16:14:30 <AStorm> CChar
16:14:32 <dmead> ah
16:14:33 <dmead> here it is
16:14:35 <AStorm> or CUChar
16:14:37 <dmead> http://haskell.org/haskellwiki/Examples/Read_Double
16:14:38 <lambdabot> Title: Examples/Read Double - HaskellWiki
16:14:42 <sjanssen> sioraiocht: see Data.Word and Data.Int
16:14:45 <dmead> import Data.ByteString.Lazy.Char8
16:14:47 <sioraiocht> thanks
16:14:51 <AStorm> Word is too large
16:14:55 <dmead> np
16:15:01 <AStorm> Oh yes, the ByteString one will work too :>
16:15:08 <sjanssen> AStorm: you should use the types in Foreign.C unless you're
16:15:14 <AStorm> :>
16:15:19 <AStorm> sjanssen: yeah, sure :P
16:15:20 <dmead> :^
16:15:22 <dmead> :V
16:15:24 <dmead> :>
16:15:25 <dmead> :<
16:15:27 <sjanssen> AStorm: you shouldn't use the types in Foreign.C unless you're interfacing with C
16:15:47 <sioraiocht> Data.Word.Word8 seems to work
16:15:54 * dmead wants non functional, good old side effect arrays in haskell
16:16:05 <sioraiocht> dmead: it wouldn't be haskell =p
16:16:13 <sioraiocht> @src !
16:16:14 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
16:16:17 <sjanssen> > 255 + 1 :: Word8
16:16:19 <lambdabot>  0
16:16:30 <AStorm> dmead: isn't it MArray :P
16:16:32 <sioraiocht> that's PERFECT
16:16:36 <dmead> > 6 :: Word*
16:16:37 <lambdabot>  Parse error
16:16:45 <dmead> AStorm, you have to be in io or a state monad
16:16:48 <sioraiocht> > 6 :: Word8
16:16:50 <lambdabot>  6
16:16:58 <AStorm> dmead: does that hurt at all? :P
16:17:17 <dmead> it might!
16:17:21 <AStorm> Shouldn't.
16:17:37 <sjanssen> dmead: you need to use a monad if you want mutable arrays
16:18:03 <dmead> yea, ive' figured out my problem (i think) but just using do notation and some tuples
16:18:08 <dmead> *by using
16:18:11 <sjanssen> dmead: programming with laziness and side effects is mind-bending and wrong
16:18:18 <Pseudonym> AStorm: It's perfectly natural, and people do it every day.
16:18:21 <dmead> oh it's not that
16:18:28 <AStorm> sjanssen: with being lazy, not laziness
16:18:34 <dmead> i've got an issue thats difficult in pure FP anyway
16:18:34 <AStorm> laziness is quite nice, actually :P
16:18:46 <AStorm> Pseudonym: I do know about it :P
16:18:48 <dmead> or at least with my knowledge of monads
16:19:12 <sioraiocht> @type ord
16:19:15 <lambdabot> Char -> Int
16:19:29 <sioraiocht> @hoogle Int -> Word8
16:19:30 <lambdabot> No matches, try a more general search
16:19:37 <AStorm> sioraiocht: uhoh
16:19:40 <AStorm> Bad idea.
16:19:43 <sioraiocht> orly?
16:19:46 <sioraiocht> y?
16:19:56 <sioraiocht> I want to be able to take the loweset 8 bits of an int
16:19:59 <dmead> bounds?
16:20:00 <sioraiocht> *lowest
16:20:18 <dmead> i've heard that problem before
16:20:19 <sioraiocht> yeah, I understand that much computer architecture, kthx ;)
16:20:28 <sjanssen> AStorm: 'and' is the key word.  The interactions between laziness and side effects are really tricky -- how do you know the order of your side effects?
16:20:29 <dmead> must be a homework question ;o
16:20:30 <Pseudonym> AStorm: I know, but for some reason, many young princesses are scared of kissing frogs.
16:20:31 <AStorm> Use the Bits class
16:20:40 <sjanssen> sioraiocht: use fromIntegral
16:20:47 <AStorm> sjanssen: ah, yes, that's unpredictable
16:20:51 <sioraiocht> @type fromIntegral
16:20:54 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:20:57 <sjanssen> > fromIntegral (257 :: Int) :: Word8
16:20:58 <lambdabot>  1
16:21:00 <sioraiocht> dmead: no, I'm just a n00b
16:21:01 <AStorm> sjanssen: fromIntegral will wrap :P
16:21:09 <dmead> sioraiocht, gotcha
16:21:12 <AStorm> Won't give lowest 8 bits
16:21:22 <sjanssen> AStorm: did you just read the above?
16:21:49 <AStorm> sjanssen: yep
16:22:17 <AStorm> > fromIntegral ( 65535 :: Int) :: Word8
16:22:19 <lambdabot>  255
16:22:21 <sioraiocht> dmead: I'm implementing http://scienceblogs.com/goodmath/2007/01/a_pathological_challenge_prime.php#more  It is for a uni project, but I asked about getting this sort of help, it's kosher because it's not solving the project itself
16:22:22 <sjanssen> AStorm: did you see how fromIntegral took the lowest 8 bits? :)
16:22:23 <dmead> > 10 ** 10
16:22:23 <lambdabot> Title: Good Math, Bad Math : A Pathological Challenge: Prime Programming in NULL, http://tinyurl.com/ypw4lp
16:22:24 <lambdabot>  1.0e10
16:22:29 <AStorm> sjanssen: ah, lowest
16:22:37 <AStorm> I think he asked for the highest :P
16:22:42 <AStorm> Blah me.
16:22:48 <Gwern> sjanssen: I can't compile the darcs xmonad with the darcs X11 :(
16:22:54 <monochrom> I understand laziness and side effects.
16:23:06 <AStorm> monochrom: not when combined - unpredictable :P
16:23:11 <sioraiocht> AStorm: I can do the binary arithmetic myself, really the typing part was the most important, heheh
16:23:14 <sjanssen> Gwern: are you using the latest X11-extras?
16:23:27 <dmead> sioraiocht, that looks pretty kewl
16:23:29 <Gwern> sjanssen: er... I'm not sure
16:23:33 * Gwern will go update that
16:23:49 <dmead> sioraiocht, are you just going to translate the python?
16:23:56 <sioraiocht> dmead: nope
16:24:01 <sioraiocht> dmead: I didn't even look at the python code
16:24:12 <dmead> well thats cool since the link is dead anyway
16:24:15 <sioraiocht> lol
16:24:37 <sioraiocht> I'm using MVars for the state right now, I might use a StateT monad later
16:24:38 <AStorm> :P
16:24:50 <dmead> that problem seems like it's a fancy way of saying "write a bytecode interpreter"
16:25:05 <AStorm> dmead: uhoh, I'm doing exactly that :P
16:25:14 <AStorm> (except the bytecode is actually MIPS machine code)
16:25:16 <monochrom> I do mean: I understand laziness and side effects combined.
16:25:19 <sioraiocht> dmead: the bigger challenge is "write a program in this language"
16:25:31 <sioraiocht> they CLAIM its turing complete
16:25:32 <dmead> oh im sure
16:26:02 <dmead> well it seems to have the basic instructions that assembler does
16:26:02 <sjanssen> monochrom: you've got to admit that it's tricky
16:26:08 <dmead> so i'd be inclined to believe that
16:26:18 <monochrom> Yes, it's tricky.
16:26:32 <monochrom> No, not tricky, just unfamiliar.
16:26:41 <Gwern> sjanssen: no, that didn't seem to do it: " Couldn't match expected type `Graphics.X11.Xlib.Types.Display'  against inferred type `Display'"
16:26:53 <sioraiocht> dmead: I would too.  The mere thought of writing anything of magnitude in it scares me
16:26:57 <AStorm> Tricky too - lack of structure means footshots
16:27:04 <Gwern> I think it may have something to do with my previous problem with X11 - I had to comment out all type sigs in Setup.hs
16:27:05 <dmead> sioraiocht, have you seen mindfuck?
16:27:10 <sioraiocht> no
16:27:13 <dmead> google for it
16:27:17 <AStorm> dmead: you mean brainfuck?
16:27:19 <dmead> it's a language written in !@#$%^&*(
16:27:21 <dmead> yes
16:27:22 <dmead> i do
16:27:23 <dmead> actually
16:27:43 <dmead> http://www.muppetlabs.com/~breadbox/bf/
16:27:43 <sioraiocht> oh dear
16:27:44 <lambdabot> Title: The Brainfuck Programming Language
16:27:58 <sjanssen> Gwern: do you have a good reason for running darcs X11?
16:28:25 <jcreigh> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
16:28:25 <lambdabot>  fd:21: hClose: resource vanished (Broken pipe)
16:28:35 <jcreigh> hmm. is @bf no more?
16:28:49 <AStorm> dmead: uhoh, DiffArray is non-portable :P
16:29:09 <dmead> =/
16:29:18 <dons> http://www.bluebytesoftware.com/blog/PermaLink,guid,60043b41-65c1-40d1-9339-5c87a03ed80a.aspx
16:29:22 <lambdabot> Title: Joe Duffy's Weblog, http://tinyurl.com/2bmwub
16:29:24 <Gwern> sjanssen: yes. I'm using a 64-bit AMD processor
16:29:30 <sjanssen> Gwern: ah, right
16:29:31 <AStorm> Is it ghc-only, or implemented somewhere else too?
16:29:34 <Gwern> according to the readme, one needs to run out of darcs in such a situation
16:29:35 <dons> "Haskell is the most underappreciated yet extraordinarily significant programming language in the world" hehe
16:29:36 <dmead> is what
16:29:59 <AStorm> underappreciated? Definitely
16:30:01 <sjanssen> Gwern: yes, that's correct
16:30:11 <dmead> o0
16:30:24 <dmead> AStorm, not sure if that would be different in hugs
16:30:42 <AStorm> dmead: hmm... you say.
16:30:46 <AStorm> I'll check that :P
16:31:45 <AStorm> Blah, still no ghc 6.6 in Gentoo portage :/
16:32:07 <Gwern> AStorm: you can get it, if you're willing to play games with portage
16:32:25 <Gwern> there's a darcs-ghc or something; you can unmask, and there's always the manual ebuild method I think
16:32:38 <AStorm> Gwern: there's the Haskell overlay, too :P
16:33:00 <AStorm> I wonder if the ghc-bin will work on amd64 non-multilib :P
16:33:08 <sjanssen> AStorm: ghc 6.6 is in portage, it's just hardmasked
16:33:16 <AStorm> sjanssen: ah, good then
16:33:22 <sjanssen> AStorm: visit #gentoo-haskell if you have questions
16:34:33 <jcreigh> sjanssen: so, are you boycotting #xmonad? :)
16:35:32 <monochrom> Gentoo is overrated
16:35:40 <AStorm> sjanssen: I've been there, thank you :P
16:35:41 <dmead> no =<
16:36:06 <sjanssen> monochrom: so is trolling
16:36:24 <dmead> no =<
16:36:26 <dmead> :P
16:36:30 <jcreigh> technically speaking, I don't think "trolling" is overrated. It's not as if anybody thinks it's a good thing. :)
16:37:31 <AStorm> Hmm, some dependencies are broken - the ghc doesn't dep on ghc-bin. Blah.
16:37:38 <AStorm> I'll install that myself.
16:38:22 <monochrom> I seriously recommend against Gentoo.
16:38:25 <sjanssen> AStorm: if you think deps are broken, you really should report that -- they want to unmask 6.6 soon
16:38:27 <aFlag> saying that trolling is not overrated is so overrated...
16:39:22 <sjanssen> Gwern: try unpulling the last few patches from igloo
16:39:24 <AStorm> sjanssen: no, it's that the 2007.0 profile is broken still, will inform :>
16:40:14 <monochrom> OK! forall x. "x is overrated" is overrated.  Happy?  (Now don't ask me what domain x ranges over, please.)
16:40:41 <sjanssen> Gwern: patches in X11, that is
16:41:00 <Gwern> sjanssen: not extras or xmonad?
16:41:30 <sjanssen> Gwern: correct
16:41:39 <AStorm> monochrom: that's recursive
16:41:43 <sjanssen> Gwern: but you'll need to rebuild and reinstall the lot of them
16:41:51 <AStorm> x ranges over all utterances
16:41:56 <sjanssen> Gwern: oh, actually the problem might be simpler than that
16:42:06 <AStorm> So, it _|_ out
16:42:10 <sjanssen> Gwern: try cleaning your xmonad directory and building again
16:42:39 <Gwern> sjanssen: ok. I tried some cleans and then builds, but I'll try it again
16:43:12 <Cale> Has anyone else seen this paper? http://iml.univ-mrs.fr/~girard/0.ps.gz
16:43:45 <Gwern> sjanssen: well, a clean/configure/build fails, so I guess I'll take the X11 route
16:49:32 <Amran> hello
16:49:44 <sioraiocht> @src toIntegral
16:49:44 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:49:49 <sioraiocht> dameet
16:49:53 <monochrom> There is no toIntegral
16:49:57 <sioraiocht> yeah
16:49:58 <sioraiocht> clearly
16:50:00 <sioraiocht> I was hopeful
16:50:05 <Amran> anyone have any haxml experience?
16:50:14 <Amran> trying to grok it, but having some trouble
16:50:23 <dmead> might want to try #happs
16:50:35 <Amran> dmead: ok
16:51:00 <notsmack> Amran: what's the trouble?
16:51:20 <Amran> trying to parse an xml (rss) feed and return text
16:51:28 <AStorm> sioraiocht: use fromIntegral
16:51:35 <sioraiocht> yeah, I realise that
16:51:39 <sioraiocht> heh
16:51:44 * sioraiocht is lamesauce.
16:51:47 <AStorm> @src fromIntegral
16:51:48 <lambdabot> fromIntegral = fromInteger . toInteger
16:51:50 <Amran> but can only return stuff if it consists of one element (e.g. the toplevel <channel> element)
16:52:08 <Amran> things like <item> give me a 'multiple output' error
16:52:19 <Amran> from processXmlWith
16:52:46 <Amran> because there are many items
16:53:55 <AStorm> @hoogle Word8 -> Integral
16:53:56 <lambdabot> No matches, try a more general search
16:53:58 <AStorm> :>
16:54:03 <AStorm> @hoogle Int -> Integral
16:54:04 <lambdabot> No matches, try a more general search
16:54:09 <Cale> I should probably learn HaXml just so that I'm prepared to help people with it :)
16:54:15 <AStorm> You know, it's because Integral is a base class.
16:54:22 <AStorm> @src toWord8
16:54:23 <lambdabot> Source not found. You type like i drive.
16:54:28 <Amran> Cale: waiting for you to :-)
16:54:38 <AStorm> Who enabled vixen mode? :P
16:54:57 <kpreid> Amran: souns like processXml isn't what you want.
16:55:05 <Amran> ok
16:55:14 <Amran> what should I use?
16:55:20 <Gwern> sjanssen: no dice. even reverting the last couple of changes to x11 so it compiles/installs without any tweaking still leads to compile errors on xmonad
16:55:23 <kpreid> I don't know, I've never used HaXml.
16:55:30 <kpreid> I just know a bit about XML.
16:55:38 <Amran> ok
16:55:39 <Cale> I already know HXT well enough
16:55:48 <kpreid> I might try using xmlParse.
16:56:07 <Amran> alright
16:56:25 <Cale> You're trying to process XML and turn it into text?
16:56:38 <Amran> yes - part of my 'learning haskell' project
16:56:51 <Amran> want to parse an rss feed, and put the textual results in a database
16:57:12 <Amran> so thought maybe HaXML for the rss, and something else for DB
16:58:53 <glen_quagmire> i want to learn about functional programming. is there a good document/book? preferrably without too much math
16:59:14 <Cale> glen_quagmire: Well, you might try the Haskell Wikibook.
16:59:36 <dons> its available from haskell.org, and seems to be getting a lot of attention
16:59:46 <glen_quagmire> yah i have that bookmarked
17:00:03 <AStorm> YAHT?
17:00:05 <AStorm> :P
17:00:21 <AStorm> BTW, math doesn't bite.
17:00:31 <glen_quagmire> i don't want haskell tutorial..more like theories behind haskell..without math symbols
17:00:40 <glen_quagmire> i have a good document..but it's hard
17:01:01 <glen_quagmire> http://www.scribd.com/doc/35191/Churchs-Thesis-and-Functional-Programming
17:01:04 <lambdabot> Title: Churchâs Thesis and Functional Programming, http://tinyurl.com/23n3mn
17:01:09 <AStorm> Heh, Haskell is based on lambda calculus and group, class and type theory
17:01:17 <AStorm> what would you expect else than math? :P
17:01:57 <glen_quagmire> i was wondering someone wrote about lambda calculus..etc in haskell terminology
17:01:57 <glen_quagmire> math books are so hard to read
17:03:04 <monochrom> I'm skeptical about theory without math symbols.
17:03:31 <glen_quagmire> well maybe i should just get used to math
17:05:31 <AStorm> glen_quagmire: well, try wikipaedia :>
17:05:31 <AStorm> Esp. the lambda calculus page
17:05:37 <Cale> Amran: yeah, looking at the documentation, xmlParse is definitely what you want, just to get hold of an xml tree which you can manipulate from there. processXmlWith is a wrapper for producing programs that act as commandline filters.
17:05:44 <glen_quagmire> yup
17:06:00 <monochrom> Suppose I write a tutorial on ring theory without math symbols.  "Multiplying an element with the result of multiplying a second element with a third element is the same as multiplying the first element with the second element and then multiplying that result with the third element."
17:06:07 <thorat> glen_quagmire: Types and Programming Languages is about types lambda calculus but it's very hands on.  Most topics are accompanied by an implementation in O'Caml.
17:06:11 <Amran> Cale: OK. Thanks. trying to get the source right now, via google code search
17:06:13 <monochrom> Compare that to "a*(b*c) = (a*b)*c".
17:06:20 <thorat> s/types/typed
17:06:27 <Amran> Cale: so I can look at xmlParse - it's not documented
17:06:33 <Cale> It is documented
17:06:44 <monochrom> If I write a tutorial on any theory without math symbols, I will never finish writing it, and you will never finish reading it.
17:06:45 <Cale> http://www.cs.york.ac.uk/fp/HaXml/HaXml/Text-XML-HaXml-Parse.html#v%3AxmlParse
17:06:45 <Amran> [sheepish grin]
17:06:48 <lambdabot> http://tinyurl.com/39twcn
17:06:53 <Amran> Cale: Thank you
17:07:36 <glen_quagmire> monochrom: that's ok. but lambda calc symbols are hard to read
17:08:00 <monochrom> You should ask for better symbols, not fewer symbols.
17:08:20 <AStorm> glen_quagmire: which ones? The lambda symbol?
17:08:28 <AStorm> alpha, beta or gamma transforms? :P
17:08:53 <glen_quagmire> like, S = lx.ly.lz.xz(yz)   : l == lambda
17:09:06 <AStorm> Simple, just add parens
17:09:12 <monochrom> Somehow I'm perfectly fine with that.
17:09:27 <AStorm> and you'll get LISP :P
17:09:49 <monochrom> It's just \x y z -> x z (y z)  in Haskell.  (Do you like Haskell? :) )
17:10:01 <glen_quagmire> S = lx.(ly.(lz.(xz(yz))))
17:10:43 * glen_quagmire practices
17:11:17 <dmead> do FOL predicates allow repeat variables?
17:11:19 <thorat> glen_quagmire: also, Essentials of Programming Languages is another book which is low on abstract mathematics.
17:11:33 <monochrom> dmead: such as?
17:11:49 <thorat> glen_quagmire: and where every topic is accompanied by working code
17:11:52 <dmead> Fyy
17:11:55 <dmead> Pxx
17:11:57 <dmead> etc
17:11:59 <monochrom> Yes.
17:12:09 <dmead> tks
17:12:23 <dmead> oh right
17:12:50 <dmead> only repeat constants fail occurs checks
17:13:06 <dmead> (x y z) and (a a c) wouldn't unify
17:13:22 <dmead> x binds to a
17:13:27 <dmead> y can't bind to a because x already is
17:14:13 <sjanssen> @seen ndm
17:14:13 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 6h 34m 24s ago, and .
17:17:10 <scsibug> dons: did you receive my patch for mkcabal? (my email has been buggy..)
17:18:48 <glen_quagmire> thorat: thanks
17:19:05 <dons> http://programming.reddit.com/info/1l19e/comments
17:19:07 <lambdabot> Title: Overloading Haskell Numbers: Part 3: Fixed Precision (reddit.com)
17:19:13 <dons> scsibug: hmm. no mail yet
17:20:00 <TomMD> @type tolist
17:20:09 <lambdabot> Not in scope: `tolist'
17:20:12 <scsibug> weird...i'll resend it.
17:23:13 <scsibug> i can always send to gmail, but most other domains act like a black hole :(
17:24:08 <dons> got it.
17:24:09 <scsibug> k, sent.  shortest patch ever, but it fixes a problem
17:24:32 <dons> looks good
17:25:39 <scsibug> I don't know how to describe that sort of runtime error...it's sort of like a failed pattern match
17:26:02 <scsibug> what do you call it when a variable in the type signature fails to bind?
17:26:56 <dons> a type error?
17:27:27 <scsibug> but it doesn't have any problem with the compiler
17:28:09 <dons> this is cute, http://programming.reddit.com/info/1l1bz/comments
17:28:10 <lambdabot> Title: Design Patterns are Higher-Order Datatype-Generic Programs (pdf) (reddit.com)
17:29:22 <scsibug> that's catchy
17:30:03 <dons> bah, this is a good article, http://programming.reddit.com/info/1l19e/details   (mod up ;)
17:30:03 <lambdabot> Title: Overloading Haskell Numbers: Part 3: Fixed Precision (reddit.com)
17:30:13 <dons> though we need to get lennart using hscolour for syntax highlighting
17:30:42 <dons> augustss: do you also have funny word wrapping in the article? http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-3.html
17:30:46 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2xbz94
17:34:51 <dons> augustss: and have you seen HsColour, for generating nice coloured html haskell, http://cgi.cse.unsw.edu.au/~dons/blog/2006/09/10#colours
17:34:52 <lambdabot> Title: Haskell hacking
17:37:13 <AStorm> TomMD: are you looking for (:) operator?
17:37:29 <AStorm> 'blah' : []
17:40:57 <Pseudonym> > (:[]) 3
17:40:59 <lambdabot>  [3]
17:41:01 <Pseudonym> > return 3 :: [Int]
17:41:03 <lambdabot>  [3]
17:41:31 <Pseudonym> It's interesting that the Robot Ninja Monkey Operator(tm) is only one character shorter than "return".
17:44:08 <AStorm> Pseudonym: forgot about type signature, have you? :P
17:44:18 <AStorm> *haven't you?
17:44:44 <Pseudonym> AStorm: Generally, the type signature is dealt with upstream.
17:44:51 <Pseudonym> You do put a type signature on all your functions, right?
17:44:57 <Pseudonym> Of course you do!
17:44:59 <AStorm> Yeah right, except when ambiguity ensues
17:45:01 <Pseudonym> So the type of return is inferred.
17:45:13 <AStorm> and the return isn't the last statement
17:45:17 <AStorm> :P
17:49:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1574
17:50:07 <dolio> :t delete
17:50:10 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
17:51:54 <AStorm> @src delete
17:51:54 <lambdabot> delete = deleteBy (==)
17:52:03 <AStorm> @src deleteBy
17:52:03 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:52:10 <AStorm> Haha :P
17:52:37 <AStorm> Now that's definition by non-definition.
17:55:22 <monochrom> @src Data.List.deleteBy
17:55:23 <lambdabot> Source not found. My mind is going. I can feel it.
17:55:29 <monochrom> @hoogle deleteBy
17:55:30 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
17:55:36 <monochrom> @src List.deleteBy
17:55:37 <lambdabot> Source not found. stty: unknown mode: doofus
17:55:44 <monochrom> OK, it is hard.
18:01:53 <fantasma> when I add a file to a darcs repository and I send the patch, do I also have to send the file that I added seperately?
18:03:18 <scsibug> nope
18:03:23 <scsibug> the patch has all that information
18:03:26 <dcoutts> fantasma: not if you recorded the add file change
18:03:52 <fantasma> what does the add file change exactly do then?
18:03:58 <fantasma> does it upload it to the repository?
18:04:03 * dcoutts departs .au heading for .uk
18:04:19 <dons> mmm. new papers! http://programming.reddit.com/info/1l1k6/comments
18:04:20 <scsibug> no, it marks it for addition with the next 'darcs record'
18:04:21 <lambdabot> Title: Faster laziness using dynamic pointer tagging (reddit.com)
18:05:02 <fantasma> scsibug: but how does the file get from my computer to the darcs server?
18:05:36 <scsibug> it's a distributed SCM, so you have to push it (either with darcs push over ssh, or by emailing a patch to the maintainer)
18:06:04 <fantasma> yeah I emailed the patch
18:06:18 <scsibug> and i'm not sure what you mean by "darcs server"... darcs is just a file layout and a client program
18:06:51 <fantasma> but how can that patch contain the file? I open the patch in a text editor and all there is just darcs stuff mentioning the file
18:07:12 <sproingie> darcs send will bundle the file too
18:07:18 <scsibug> there should be two patches... one to add the file, and another with the contents
18:07:36 <scsibug> when you do 'darcs record', you need to say yes to recording both of those changes
18:07:36 <fantasma> hmm, the email only included one file
18:07:45 <fantasma> yeah I did
18:07:48 <scsibug> sorry... the patch is one file
18:07:59 <scsibug> but it can contain multiple changes
18:08:14 <fantasma> but how is it possible that the contents of the file is hidden when I open the patch in a text editor?
18:08:20 <araujo> Anybody would know what key combination represents the characters '^H' ?
18:08:25 <scsibug> it shouldn't be
18:08:36 <dons> ctrl-h araujo ?
18:08:38 <araujo> I was guessing ESC-H
18:08:46 <Pseudonym> It's control-H.
18:08:54 <araujo> dons, ok, make sense, let me try
18:08:57 <fantasma> scsibug: well there is one weird thing
18:09:01 <araujo> Indeed
18:09:09 <araujo> Thanks dons Pseudonym
18:09:12 <Pseudonym> On a real shell, try typing control-V control-H and you'll see.
18:09:27 <scsibug> fantasma: there is no network communication going on outside your email, so if it isn't in the patch file you attached, it's not getting sent
18:09:28 <fantasma> scsibug: when I was recording the added file, the third patch requested adding some dollar signs in the file
18:09:44 <fantasma> I said no to the dollar signs
18:09:45 <scsibug> fantasma: those are just markers to indicate whitespace at the end of a line
18:09:57 <araujo> But, wait, how do i represent such a scape char from Haskell? '\CTRL' ?
18:10:05 <scsibug> fantasma: that is probably your problem, that was the file contents most likely
18:10:18 <fantasma> scsibug: ok that makes sense
18:10:31 <fantasma> scsibug: thanks, and sorry to put you through all that trouble
18:11:10 <scsibug> fantasma: not a problem :)
18:11:24 <Pseudonym> araujo: '\b'?
18:11:42 <Pseudonym> Or '\008'?
18:11:50 <araujo> Pseudonym, ok, let met try
18:11:55 <araujo> :-)
18:15:25 <shapr> SPJ is the peyton saint of functional programming
18:15:26 * shapr laughs
18:15:46 <Pseudonym> Saint Peyton-Jones.
18:15:58 <shapr> In my dialect, peyton sound almost like patron..
18:16:26 <dmead> > succ 'a'
18:16:26 <dons> heya shapr
18:16:29 <lambdabot>  'b'
18:16:35 <dmead> > prev 'b'
18:16:36 <dons> shapr: got xmonad ? :-)
18:16:37 <lambdabot>   Not in scope: `prev'
18:16:49 <dmead> whats char--?
18:16:52 <shapr> dons: Not in the last two weeks.
18:17:09 <dons> we have a nice website now, xmonad.org, you should update :-)
18:17:18 <shapr> truly
18:17:35 <dons> taking over the world is just that simple!
18:17:58 <Gwern> dons: I've been having problems with compiling xmonad, fwiw
18:18:11 <dolio> > pred 'b'
18:18:12 <dons> Gwern: ah yes? details?
18:18:12 <lambdabot>  'a'
18:18:19 <Gwern> because I'm running amd64, I need the darcs X11, but that causes compilation of xmonad to fail
18:18:19 <dons> and are you using X11-extras 0.1 ?
18:18:31 <dons> oh?
18:18:33 <Gwern> pretty sure I am
18:18:50 <dons> so darcs X11, but X11-extras builds fine?
18:18:59 <dons> and xmonad fails?
18:19:08 <Gwern> last I tried, yes
18:19:20 <dons> can you send this as a bug report to xmonad@haskell.org ?
18:19:31 <dons> with details about which version of Cabal, which X11, X11-extras and so on.
18:19:39 <dons> mm. we should set up a trac
18:19:40 <shapr> ow, I think I just broke a rib
18:19:51 <dons> serious, shapr ?
18:19:57 <shapr> Yeah, I was unicycling.
18:19:59 <Gwern> dons: I'd rather not until I'm absolutely sure everything is updated and everything. I hate filing and then retracting bug reports
18:20:10 <dons> Gwern: just an email to the list please :-)
18:20:19 <dons> then we have to deal with it. otherwise , we tend to forget
18:20:29 <scsibug> shapr: do you bother with any protective gear when on the uni?
18:20:36 <shapr> scsibug: Lots, that's why I only broke a rib.
18:20:42 <Gwern> dons: well, because I can't recompile, it causes me some problems with a new terminal, so I won't forget...
18:20:53 <scsibug> ya, i should really wear more than a helmet...don't want to break a wrist
18:20:56 <Gwern> shapr: is it really worth it to learn to unicycle?
18:21:02 <dons> ok. but make sure the xmonad guys don't forget either.
18:21:02 <shapr> Gwern: It is for me.
18:21:16 <araujo> > let prev c = (toEnum $ (fromEnum  c) - 1 :: Char) in prev 'b'
18:21:17 <lambdabot>  'a'
18:21:24 <Gwern> (interesting. does gentoo not have an ebuild for vty?)
18:21:33 <dolio> > pred 'b'
18:21:34 <lambdabot>  'a'
18:21:36 <fantasma> @seen sjanssen
18:21:37 <lambdabot> sjanssen is in #xmonad, #haskell, #ghc, #gentoo-haskell, #haskell-soc and #haskell-overflow. I last heard sjanssen speak 19m 25s ago.
18:21:47 <sproingie> saw a guy in sf on what must have been an 8 foot unicycle
18:21:56 <sproingie> i wonder how he gets on the thing in the first place
18:22:19 <shapr> sproingie: I've seen people free mount giraffes, it's amazing. It's like climbing up a free standing ladder.
18:22:26 <araujo> Pseudonym, it doesn't seem to work :-(
18:22:43 <araujo> Pseudonym, i am trying to 'catch' such a char
18:22:48 <sjanssen> fantasma: whats up?
18:22:55 <dmead> ah
18:22:59 <dmead> > pred pred 'x'
18:23:00 <lambdabot>   add an instance declaration for (Enum (Char -> Char))
18:23:01 <lambdabot>     In the expression...
18:23:06 <shapr> Gwern: Unicycling builds a lot of interesting skills that apply to other parts of life.
18:23:06 <dmead> > pred (pred 'x')
18:23:08 <lambdabot>  'v'
18:23:09 <fantasma> sjanssen: did you get the patch
18:23:29 <Pseudonym> araujo: What do you mean by "such a char"?
18:23:50 <araujo> Pseudonym, The special scape sequence , ^H
18:24:21 <Gwern> shapr: wha? what skills does unicycling build besides physical balance?
18:24:23 <araujo> Pseudonym, I am trying to get it from a String value
18:24:57 <sproingie> the secret unicyclist handshake opens the doors to the halls of power
18:25:06 <Pseudonym> > ''
18:25:07 <lambdabot>      lexical error in string/character literal at character '\b'
18:25:15 <araujo> > '\b'
18:25:15 <sjanssen> fantasma: applied
18:25:16 <Pseudonym> It's definitely '\b'.
18:25:17 <lambdabot>  '\b'
18:25:32 <stepcut> impressive giraffe mount -> http://www.youtube.com/watch?v=KyxxDRzV7Bc
18:25:52 <sproingie> one has to wonder whether that's safe for work
18:26:23 <scsibug> gwern: riding a unicycle anywhere in public is practically a guarantee you'll end up having conversations with an interesting person.
18:26:36 <scsibug> for some value of 'interesting'
18:28:58 <AStorm> scsibug: the conversation could be painful, I mean a fist in the face :P
18:29:13 <AStorm> (yes, some people)
18:29:42 <sjanssen> Gwern: I have a theory about your bug.  Can you run clean, configure, build, install in this order: X11, X11-extras, xmonad
18:30:30 <Smokey`> Hey guys, I've got a question... I'm wondering how would one go about creating a library in haskell which can be used from C?  (or how can C interface with Haskell libraries in general?)
18:32:13 <dons> it can be, but it tends not to be done very often
18:32:18 <dons> that is, C calling into Haskell.
18:32:26 <dons> however, it is certainly possible using the normal FFI
18:32:38 <Smokey`> can be :)   well that sounds promising :P
18:32:49 <dons> basically, Haskell functoins are "foreign export" ed, then you get a C header generated by GHC, which you include in your C program
18:32:49 <sjanssen> Gwern: oh, and repull the patches I said you should remove earlier :)
18:32:53 <shapr> @seen gwern
18:32:54 <Smokey`> FFI it is then.
18:32:54 <lambdabot> I saw gwern leaving #haskell 6m 50s ago, and .
18:32:55 <shapr> aww
18:33:19 <sjanssen> oh well
18:33:20 <Smokey`> too easy, way too easy.  Thanks dons :)
18:37:50 <araujo> Pseudonym, mmm.. \b != ^H
18:38:13 <araujo> Pseudonym, i am checking here, and it seems ^H is a single character
18:40:42 <dolio> > '\b' -- is a single character
18:40:43 <lambdabot>  '\b'
18:43:50 <jcreigh> is there any easy way to tell whether a patch you've sent someone had made its way into the remote repo, without doing a "darcs get"?
18:46:27 <kpreid> jcreigh: darcs send. if it shows up, it hasn't
18:46:43 <jcreigh> kpreid: thank you
18:56:04 <dmead> @where do-notation
18:56:05 <lambdabot> I know nothing about do-notation.
18:56:09 <dmead> @where do
18:56:10 <lambdabot> I know nothing about do.
18:56:16 <dmead> @hoogle do
18:56:17 <lambdabot> Prelude.do :: keyword
18:56:17 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
18:56:17 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
18:58:46 <dmead> > return [x]
18:58:47 <lambdabot>   Not in scope: `x'
18:58:50 <dmead> > return [1]
18:58:51 <lambdabot>   add an instance declaration for (Show (m [t]))
19:02:56 <dons> another new paper, everyone should read this (a new optimisatoin ghc is doing) -->
19:03:00 <dons> http://programming.reddit.com/info/1l1yf/comments
19:03:01 <lambdabot> Title: Constructor specialisation for Haskell programs (reddit.com)
19:06:24 <narain> "the programs it hits are well and truly knocked for six."
19:06:27 <narain> very british :)
19:06:54 <dons> heh
19:09:38 <dmead> can someone explain what this means?
19:09:46 <dmead> $ do return [1]
19:09:59 <dmead> > do return [1]
19:10:00 <lambdabot>   add an instance declaration for (Show (t1 [t]))
19:10:06 <dmead> > do 1
19:10:07 <lambdabot>   add an instance declaration for (Num (t t1))
19:10:07 <lambdabot>     In the expression: 1
19:10:07 <lambdabot>     I...
19:10:16 <dmead> > let x = 1 in do x
19:10:18 <lambdabot>   add an instance declaration for (Num (t t1))
19:10:18 <lambdabot>     In the expression: 1
19:10:18 <lambdabot>     I...
19:10:20 <dons> return [1] returns a singleton list in some monad
19:10:45 <thedward> do return [1] >>= putStrLn
19:10:46 <dons> > return [1] :: Maybe [Int]
19:10:47 <lambdabot>  Just [1]
19:10:49 <thedward> > do return [1] >>= putStrLn
19:10:50 <lambdabot>   add an instance declaration for (Num Char)
19:10:51 <lambdabot>     In the expression: 1
19:10:55 <dons> no io.
19:11:00 <dmead> if instead of 1 you put a user defined type, do you have to overload return?
19:11:01 <thedward> > do return [1] >>= putStrLn . show
19:11:03 <lambdabot>  <IO ()>
19:11:26 <dino-> I'm working on a command-line program, it's cabalized. And I want to write tests for it that will exercise what it's supposed to do..
19:11:35 <dons> > return [((),"no")] :: Maybe [((),String)]
19:11:36 <lambdabot>  Just [((),"no")]
19:11:39 <dmead> dino-, HUnit
19:11:50 <dons> dino-: QuickCheck :-)
19:11:53 <dino-> dmead: Executing the program from a shell, with args.
19:12:02 <dons> hunit is for those who don't know about QuickCheck :-)
19:12:06 <dons> ok. so proper black box testing?
19:12:19 <dino-> It's possible that I could unit test the code as well or instead.
19:12:24 <dons> hunit would be ok, QC would be a little harder, but also doable.
19:12:25 <dino-> But suppose that I want to do it from the shell.
19:12:29 <dino-> Can cabal get involved with this?
19:12:29 <dmead> :t $
19:12:32 <lambdabot> parse error on input `$'
19:12:35 <dino-> like ./Setup test
19:12:41 <dons> yep.
19:13:12 <fantasma> can Cabal handle man pages?
19:13:14 <dino-> I wasnt' sure what to make of this stuff yet: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple.html
19:13:16 <lambdabot> http://tinyurl.com/2gdjvr
19:13:26 <dino-> UserHooks runTests
19:18:39 <dmead> graw
19:18:43 <dmead> $ do
19:18:46 <dmead> creates a closure?
19:18:56 <dmead> someone hip to this monad stufff?
19:19:25 <dolio> do is part of the syntax sugar for monads.
19:19:29 <dino-> :t ($)
19:19:31 <lambdabot> forall a b. (a -> b) -> a -> b
19:20:09 <dolio> It lets you write: 'do { a <- m ; b <- n ; return (a, b) }' instead of 'm >>= \a -> n >>= \b -> return (a, b)'
19:20:35 <dolio> ($) is an operator that means function application.
19:20:46 <dolio> 'f $ a' is the same as 'f a'.
19:20:51 <dmead> ah
19:21:36 <dolio> However, ($) has a much lower precedence, which is useful when you're, for example, applying the composition of a bunch of functions to a value.
19:21:45 <dino-> u
19:22:28 <dolio> 'f . g . h $ x' instead of '(f . g . h) x' or 'f (g (h x))'
19:22:47 <dino-> @seen stepcut
19:22:47 <lambdabot> stepcut is in #haskell. I last heard stepcut speak 57m 14s ago.
19:23:06 <dolio> Similarly, if you're seeing '... $ do ...', the idea is to apply the stuff before the $ to the result of the do expression.
19:23:13 <dolio> It's a trick for avoiding parentheses.
19:24:58 <TomMD> I am too lazy to use lazy byte strings.  Does anyone have code that will s/LazyByteString/LBS/ on all of ghc and hackage? :-P
19:50:40 <ortmage> i'm trying to install the darcs version of X11... when i run runghc Setup.hs configure i get "Setup.hs:16:18: Not in scope: `buildHook'"
19:50:46 <ortmage> any pointers?
19:51:21 <dons> update your cabal version, I think.
19:51:34 <dons> the darcs version of X11 needs the darcs version of cabal
19:51:40 <dons> haskell.org/cabal
19:51:40 * ortmage will give that a try
19:51:46 <dons> ortmage: you're on a 64 bit system, are you?
19:51:55 <dons> (that's the only reason to update to darcs X11, iirc)
19:52:18 <ortmage> kernel 2.6.18.5-gg4-mixed64-32
19:52:29 <dons> ok. cool. running xmonad, I guess? (trying to?)
19:52:41 <ortmage> that's the plan :)
19:52:50 <dons> feel free to drop by #xmonad too
19:52:57 <ortmage> ooh, ok
19:53:19 <dons> otherwise we never talk about anything but tiling window managers in here :-)
19:55:30 <sproingie> is anyone working on wxhaskell now?
19:55:50 <dons> kowey is , sometimes,  Ithink
19:56:01 <sproingie> i saw someone took it over, but nada other than a code drop onto haskell.org in jan
19:58:10 <lispy> iirc that code drop was significant though
19:58:24 <lispy> a cleanup to work/build on recent versions of things
20:01:11 <dmead> anyone know why emacs freezes sometimes when loading a file to ghci?
20:01:44 <mwc> it's not freezing, it's just trying to consume another eighty megs and constantly swap ;)
20:02:17 <mwc> dmead, that being said, the only thing that occurs to me is that the macros are expecting some sort of feedback from ghci and aren't getting it
20:02:30 <mwc> and so it hangs waiting for it
20:02:31 <dmead> ah :P
20:04:12 <sproingie> hopefully i can build wxhaskell easily enough for ghc6.6
20:04:24 <sproingie> was hoping i could download it for win32 too tho :(
20:09:16 <lispy> sproingie: well, ask away if you hit a snag..people here tend to be helpful and friends
20:09:19 <lispy> er friendly
20:10:25 <Pseudonym> And friends, too!
20:10:36 <mwc> lispy, you're my friend
20:10:52 <dons> in case people didn't see this before, http://programming.reddit.com/info/1l1yf/comments
20:10:54 <lambdabot> Title: Constructor specialisation for Haskell programs (reddit.com)
20:11:10 <dons> this is the key optimisation needed for stream fusion to work, btw.
20:15:23 <thetallguy> dons: why is that?
20:15:46 <thetallguy> I suppose I should just read the papers
20:15:55 <sproingie> what is stream fusion?
20:16:24 <dons> a way of combining loops over sequence-like data structures to produce a single fast loop
20:16:39 <dons> used in pure languages. well, used in ghc haskell
20:16:39 <Pseudonym> I started implementing something that needed this for Mercury for my honours thesis, but I never got it working.
20:16:43 <Pseudonym> It never terminated.
20:16:44 <Pseudonym> :-/
20:16:47 <Pseudonym> Well...
20:16:48 <dons> heh
20:16:51 <Pseudonym> Sometimes didn't terminate.
20:17:07 <Pseudonym> Eventually, I had to do it by identifying the "induction argument".
20:17:13 <Pseudonym> This looks more general.
20:17:19 <dons> thetallguy: basically, stream fusion turns multiple logical states in a loop into a single recursive function with state as data.
20:17:29 <dons> specConstr turns the optimised single loops back into seperate workers
20:17:55 <dons> there's a nice example in the end of the recent stream fusion paper, of how crucial this is
20:18:22 <thetallguy> dons:  okay, thanks
20:18:35 <thetallguy> I'll queue up those papers
20:25:40 <ortmage> where can i get help installing cabal from darcs?
20:26:08 <fantasma> here
20:26:20 <fantasma> what do you need help with?
20:26:46 <ortmage> i did make build, and it fails with /bin/sh: line 0: cd: cabal-install: No such file or directory
20:27:06 <ortmage> (i take it long output shouldn't go in the chat room)
20:27:21 <fantasma> is the long output a bunch of error messages
20:27:49 <ortmage> that's the only thing that looks like an error to me
20:28:05 <fantasma> paste it on hpaste
20:28:09 <fantasma> ?hpaste
20:28:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:29:14 <hpaste>  ortmage pasted "cabal build trouble" at http://hpaste.org/1576
20:29:29 <ortmage> oops too much output
20:29:53 <ortmage> um should i annotate that paste with the tail of the output?
20:30:19 <hpaste>  ortmage annotated "cabal build trouble" with "(no title)" at http://hpaste.org/1576#a1
20:32:10 <fantasma> you know that you don't need cabal-install to use cabal right?
20:32:32 <brad_> hi, i have a question
20:32:50 <ortmage> beats me, i got that far just typing 'make'
20:32:56 <brad_> the function "any" works like: any (1==) [0,1,2,3,4,5] returning True
20:33:24 <brad_> but i would like something that applies a list of functions to one arg, sort of like an any with the args reversed
20:33:38 <brad_> any ideas?
20:33:45 <merus> flip any
20:33:54 <brad_> thanks merus!
20:33:55 <merus> oh, that's not what you want
20:34:00 <brad_> oh okay
20:34:01 <merus> I wasn't reading what you said.
20:34:01 <fantasma> ortmage: cabal-install is sort of like a "package manager", cabal itself is just a bunch of libraries
20:35:33 <fantasma> ortmage: simply by doing ``runhaskell Setup.lhs configure'' you are using cabal libraries
20:35:37 <notsmack> > any ($ 3) [(==3), (==4)]
20:35:39 <lambdabot>  True
20:36:06 <brad_> thanks notsmack!
20:36:17 <brad_> i forgot about function application ($)
20:36:19 <ddarius> > zipWith ($) [(+2), (*3)] (repeat 5)
20:36:21 <lambdabot>  [7,15]
20:36:21 <ortmage> i see... so getting this far in the build means i can use the darcs cabal to build X11?
20:36:25 * notsmack is mildly surprised it worked
20:36:40 <ddarius> map ($ 5) [(+2), (*3)}
20:36:48 <dino-> Ah! I finally found an example on somebody's site showing that the Distribution.Simple, main = defaultMainWithHooks yada stuff goes in your *Setup.[l]hs*
20:36:52 <ddarius> > map ($ 5) [(+2), (*3)]
20:36:54 <lambdabot>  [7,15]
20:37:25 <fantasma> ortmage: yes, as long as cabal itself got built then you can go ahead an install X11
20:38:36 <brad_> sounds like other people are having X11 build issues too!
20:38:46 <fantasma> yeah
20:38:54 <fantasma> it's all cabal's fault really
20:38:58 <ortmage> wow, it definitely works... that's surprising :) to ask a stupid question, do packages in --user always override those installed globally?
20:39:31 <brad_> yes
20:39:48 <brad_> well not sure if there is a version number check
20:40:47 <ortmage> runhaskell Setup.hs install --user doesn't do what i want...
20:41:07 <fantasma> what do you want?
20:42:09 <brad_> that should be added to the configure stage, shouldn't it?
20:42:18 * ortmage will try that
20:42:40 <sproingie> ok, so wxhaskell builds out of the box, but i can't make the examples work
20:42:46 <sproingie> chuck@doorstop:~/proj/wxhaskell/wxhaskell/samples/wx$ runhaskell BouncingBalls.hs
20:42:47 <sproingie> can't load .so/.DLL for: wxc-gtk2.6.3-0.10.1 (/usr/lib/libwxc-gtk2.6.3-0.10.1.so: undefined symbol: _ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette)
20:42:48 <ortmage> like this: runhaskell Setup.hs configure --user?
20:43:04 <fantasma> yes
20:43:12 <brad_> i do this: runhaskell Setup configure --user --prefix=$HOME/local
20:43:25 <brad_> the Setup captures both Setup.hs and Setup.lhs i think
20:43:45 <ortmage> hmm, what's the difference between --user and --prefix=$HOME/local
20:43:50 <brad_> i put it all in a bash script, get tired of typing all that!
20:44:23 <fantasma> brad_: are you on freebsd?
20:44:27 <brad_> there is no difference - --user says to register it in your local pkg dir, --prefix says where you actually want it to go
20:44:31 <brad_> yes fantasma
20:44:53 <fantasma> brad_: if you're going to have everything --user then you might as well make a jail
20:44:54 <brad_> i like $HOME/local, you cna choose something else!
20:45:14 <brad_> yes fantasma, i agree on that
20:45:17 <brad_> i am not the jail expert
20:45:23 <brad_> i should know that stuff better
20:45:31 <brad_> having used freebsd at work for 11 years!
20:45:32 <ortmage> it looks like cabal's libraries ended up in ~/.ghc, is that where i should point PREFIX?
20:45:36 <fantasma> jailing is an art
20:45:38 <brad_> no!
20:45:55 <brad_> you should probably not put them in a . directory, they will be hidden
20:46:03 <brad_> i would create $HOME/local
20:46:10 <brad_> add it to your $PATH
20:46:25 * ortmage will take brad_'s advice :)
20:46:28 <ortmage> glad i asked
20:46:40 <brad_> i think putting it in .ghc actually might harm you
20:46:42 <fantasma> cabal's libraries should eventually go somewhere like $PREFIX/lib/ghc-6.6/...
20:47:39 <ortmage> how much clutter will i get from putting it in $HOME?
20:48:03 <brad_> you will get all the top level dirs of your system replicated in your home dir
20:48:07 <brad_> lib bin man share etc
20:48:20 <brad_> better to create a dir called local, or something else
20:48:42 <ortmage> oh, that happens to match well with the state of things already
20:49:03 <fantasma> if you do it that way, I think you'd have to unregister the older version of cabal that's already on your system
20:49:23 <fantasma> unless ghc is smart enough to use the higher version on its own
20:50:09 <brad_> i didn't have to unregister anything
20:50:28 <brad_> hmmm, all of this makes me longing for perl -MCPAN -e shell
20:50:31 <brad_> so much easier
20:50:48 <brad_> would like to see hackage etc get a shell
20:51:01 <fantasma> yeah I agree, cabal isn't the nicest solution
20:51:14 <allbery_b> there is a cabal-install out there somewhere, I think
20:51:17 <fantasma> cabal-install might be worthwhile
20:51:45 <brad_> preferrably i would get them from /usr/ports, or whatever pkg system people use, but i suspect the rest of the world cares much less about haskell than us
20:52:15 <fantasma> ;)
20:54:27 <brad_> well thanks again for all the help and chat, take care folks!!
20:59:29 <mwc> Any advice on choosing between an algo that's omicron(N), Omega(N) in time and O(N^2) in space, and one that's Omega(NlogN) in time and Omega(N) in space?
21:00:45 <thetallguy> mwc: depends on what you're doing
21:00:55 <sjanssen> mwc: how much RAM do you have? ;)
21:00:57 <mwc> My gut tells me to go with the second since its worst asymptotic behaviour is NlogN, but I wonder if the space balloon in the other really matters.
21:01:06 <thetallguy> Big data sets?
21:01:08 <mwc> Well, it's probably easier to to the second anyways, just a sort + fold
21:01:14 <mwc> thetallguy, unknown
21:01:29 <mwc> and then I can implment the second later.
21:01:31 <thetallguy> In that situation, I always choose the easiest to implement
21:01:32 <mwc> sjanssen, 1.5 GB
21:01:54 <mwc> yeah, implementing the more complicated version later if need be make sense
21:02:01 <thetallguy> and if it turns out to be a problem, then I look at the other solutions
21:02:06 <mwc> but the siren of premature optimization calls
21:02:16 <thetallguy> If it needs to be fully automatic
21:02:35 <thetallguy> then implement both, chart the behaviors, find the cutpoint
21:02:50 <thetallguy> and implement a wrapper that looks at the size of the input and chooses the right one.
21:04:44 <mwc> That too, but I have the time to do one or the other  by noon tomorrow
21:06:54 <ortmage> mtl wants package base, where is it?
21:07:53 <ortmage> or wait, it wants Control.Monad.Instances, i mean
21:13:43 <pchiusano> hi
21:13:56 <JKnecht_> hi
21:14:25 <pchiusano> I have a question
21:14:28 <pchiusano> ...
21:14:40 <pchiusano> I have a recursive datatype
21:15:12 <sioraiocht> > 459 :: Word*
21:15:13 <lambdabot>  Parse error
21:15:15 <sioraiocht> > 459 :: Word8
21:15:17 <lambdabot>  203
21:15:23 <sioraiocht> that's the lowest 8 bytes, right?
21:15:30 <kc5tja> 8 bits
21:15:33 <sioraiocht> sorry
21:15:33 <sioraiocht> yes
21:15:38 <kc5tja> :)
21:16:25 <sioraiocht> > 14229 :: Word8
21:16:27 <lambdabot>  149
21:16:39 <sioraiocht> > chr 203
21:16:40 <lambdabot>  '\203'
21:16:46 <sioraiocht> ..so helpful
21:17:20 <hpaste>  ortmage pasted "regex-base needs base?" at http://hpaste.org/1577
21:17:28 <TomMD> > toEnum 149
21:17:30 <lambdabot>  149
21:17:40 <ddarius> > 459 `mod` 256
21:17:41 <lambdabot>  203
21:17:43 <TomMD> (toEnum 149) :: Char
21:18:02 <dolio> > 'Ë'
21:18:03 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
21:18:05 <ortmage> where is package base?
21:18:31 <dolio> Base comes with the compiler.
21:18:32 <Korollary> It comes with ghc. Do you have 6.6 or something older?
21:19:09 <ortmage> ooo 6.2... i should upgrade that...
21:19:56 <TomMD> ortmage: 6.4 and up have STM - just a random fact I think everyone should know and care about.
21:20:23 <sioraiocht> > -1 `mod` 3
21:20:25 <lambdabot>  -1
21:20:28 <sioraiocht> >:O
21:20:37 <sioraiocht> oh wait..don't parse that, lb
21:21:18 * ortmage will upgrade ghc and try again tomorrow
21:21:48 <hpaste>  pchiusano pasted "local override of Show/Eq" at http://hpaste.org/1578
21:22:11 <pchiusano> can somebody take a look at my paste and help
21:23:55 <jcreigh> pchiusano: if you "import Text.Show.Functions", you can solve the "Show" problem.
21:24:06 <pchiusano> ok
21:24:29 <Korollary> pchiusano: I think the Eq problem stays
21:24:30 <jcreigh> pchiusano: I don't know of any simple way to do Eq other than defining it manually, however.
21:25:01 <pchiusano> so, I have to define Eq manually for my entire datatype...?
21:25:16 <pchiusano> because there is a single ctor for which the default impl doesn't apply?
21:25:28 <Korollary> I dont think you can do it manually either. How are you going to prove that two functions are equal?
21:25:42 <jcreigh> well, you can define Eq for Expr -> Expr, and then derive Eq for Expr.
21:25:54 <jcreigh> (I assume you would just always return False?)
21:26:03 <pchiusano> jcreigh: yes
21:26:12 <dmead> sighface
21:26:24 <augustss> > (-1) `mod` 3
21:26:27 <lambdabot>  2
21:26:33 <Korollary> Why do you need Eq anyway? Is this for an interpreter?
21:26:51 <pchiusano> ya
21:26:52 <TomMD> let f = (\x -> sum (map fromEnum (x::String))) in f "Haskell" > f "Python"
21:27:00 <TomMD> > let f = (\x -> sum (map fromEnum (x::String))) in f "Haskell" > f "Python"
21:27:02 <lambdabot>  True
21:27:07 <TomMD> excellent.
21:27:56 <Korollary> pchiusano: You can implement the interpreter without the Eq instance. Why do you need Eq?
21:28:11 <dmead> pchiusano, you could make axiom a different type
21:28:50 <pchiusano> well, I need
21:29:02 <pchiusano> some way of comparing the equality of expressions
21:29:10 <dmead> i'll annotate
21:29:29 <pchiusano> ya, dmead, I was going to ask you to show me
21:30:05 <Korollary> You just rephrased it. I still don't know why you need equality between expressions.
21:30:17 <pchiusano> hehe
21:30:52 <campusblo> hi
21:31:01 <campusblo> is there a way to convert haskell to php?
21:31:15 <Korollary> I don't know of such a compiler.
21:31:17 <pchiusano> dude, just trust me, I need it! plus, that is not entirely the point
21:31:25 <dmead> pchiusano, what do you want from Expr -> Expr
21:31:31 <dmead> an actual mapping?
21:31:45 <dmead> or just to show an arrow
21:31:45 <pchiusano> er, what do you mean?
21:32:01 <dmead> you don't need to type -> i think
21:32:06 <pchiusano> you mean to display it?
21:32:08 <dmead> just Axoim Expr Expr
21:32:08 <dmead> yea
21:32:39 <pchiusano> sure, whatever
21:32:52 <pchiusano> just Axiom Expr Expr
21:33:30 <campusblo> so yea. haskell to php? is there a program that will do that kind of conversion?
21:33:48 <Korollary> campusblo: I don't know of such a compiler.
21:34:11 <hpaste>  dmead annotated "local override of Show/Eq" with "      " at http://hpaste.org/1578#a1
21:34:38 <dmead> cameron, why would you want that?
21:34:41 <dmead> err
21:34:43 <dmead> campusblo,
21:34:46 <dmead> why would you want that
21:35:47 <pchiusano> hmm, I am looking at paste
21:35:56 <campusblo> was just wondering. i saw some php projects and it occured to me that most php is push and pull from lists and
21:36:14 <campusblo> sorry php is to databases as haskell is for lists
21:36:17 <dmead> forgot an x after showAxiom, btw
21:36:19 <campusblo> and i wondered
21:36:25 <sproingie> bah.  wxhaskell isn't working for me
21:36:32 <sproingie> >>> can't load .so/.DLL for: wxc-gtk2.6.3-0.10.1 (/usr/lib/libwxc-gtk2.6.3-0.10.1.so: undefined symbol: _ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette)
21:36:38 <pchiusano> dmead, yah, nbd, I see
21:36:59 <pchiusano> so, you could do the same thing to handle the Eq case
21:37:16 <campusblo> gotta go
21:37:24 <pchiusano> you could say instance Eq Axiom where blah
21:37:35 <dmead> yes
21:37:45 <dmead> why do you want to?
21:37:52 <pchiusano> then you could have Expr deriving (Eq, Show)
21:38:04 <dmead> right
21:38:09 <pchiusano> cool
21:38:14 <dmead> thats what i put :P
21:38:20 <pchiusano> why do I want to...what?
21:38:29 <dmead> overload eq
21:38:33 <jcreigh> if Axiom is Axiom Expr Expr, you don't need to write your own Eq, unless you want something weird.
21:39:02 <jcreigh> if Axiom is Expr -> Expr, you *do* need to write you own Eq, because you comparing functions is weird.
21:39:14 <jcreigh> s/because you/because/
21:39:41 <pchiusano> right, I understand
21:39:48 <augustss> jcreigh: comparing functions is a slippery slope :)
21:40:28 <pchiusano> is there any way to compare functions based on the memory address? or does that not have any meaning in haskell?
21:40:44 <pchiusano> or any objects, for that matter
21:41:03 <dmead> thats not really something you do in  functional programming
21:41:07 <jcreigh> pchiusano: there's definitely no clean way to compare functions based on memory address. And it's a bad idea.
21:41:23 <pchiusano> what I figured
21:41:30 <pchiusano> :-/
21:41:36 <dmead> why do you ask?
21:41:38 <Korollary> YOu still wouldnt have the case where two equal functions are stored in different places.
21:41:44 <Korollary> +covered.
21:42:45 <pchiusano> well, sometimes it is handy to be able to compare just purely on memory address, I was just curious
21:42:58 <jcreigh> Practically speaking, my understanding is that it's impossible to check functions for equality.
21:43:15 * jcreigh has to qualify many of his statements in #haskell :)
21:43:50 <pchiusano> yeah, I was not thinking you would somehow test the functions like black boxes to see if they generate the same output
21:43:58 <pchiusano> that would be crazy
21:44:05 <dmead> well, you can compare the type of functions
21:44:09 <dmead> i think
21:44:29 <jcreigh> pchiusano: well, you can actually do that with QuickCheck, but it's more something you'd do for testing, not at runtime.
21:44:35 <TSC> If the input type is bounded, you could do it exhaustively
21:44:50 <pchiusano> hmm
21:44:54 <dmead> hey kids
21:45:00 <dmead> is there a nice way of getting side effects
21:45:03 <dmead> without doing IO?
21:45:06 <Korollary> Garden variety interpreters don't have expressions that are "axioms". Are you writing a theorem prover?
21:45:11 <TSC> What kind of side effects?
21:45:27 <dmead> ahh i'm not sure what the type is that i want
21:46:00 <dmead> i've got a tree
21:46:00 <dmead> and i want to update a list based both branches of a tree
21:46:06 <dmead> do the right side, get the updated list
21:46:09 <dmead> do the right side
21:46:10 <dmead> return
21:46:13 <TSC> And you're excluding unsafePerformIO, I guess?
21:46:15 <dmead> err
21:46:16 <dmead> *left
21:46:26 <dmead> no, i really don't know what i'm talking about actually
21:46:33 <TSC> State monad, it sounds like
21:46:36 <dmead> hmm ok
21:46:37 <pchiusano> Korollary:
21:46:47 <pchiusano> I am writing a term-rewriting language
21:46:50 <dmead> well, i don't really need i/o
21:46:57 <dmead> just the side effects
21:46:58 <dmead> so yea
21:47:00 <dmead> state monad
21:47:01 <pchiusano> for symbolic computation
21:47:02 <TSC> dmead: It sounds like you want to traverse the tree and keep same state around
21:47:03 <augustss> dmead: state monad
21:47:12 <dmead> kk
21:47:14 <TSC> (some, not same)
21:47:16 <pchiusano> like Q or mathematica
21:48:02 <pchiusano> I'm just calling an axiom any rewrite rule whose implementation is in the native language, in this case haskell
21:51:07 <augustss> pchiusano: you might want to include some string with those "axioms" so you can show them.  then you can use the string for comparison as well.
21:51:45 <pchiusano> k
21:51:46 <augustss> pchiusano: it will not be real equality on functions, but it will be something
21:52:05 <pchiusano> mm, that is not a bad idea
21:52:10 <Korollary> augustss: That sounds like manually tagging them to simulate types.
21:52:56 <augustss> well, to simulate something :)
21:53:25 <Korollary> augustss: how is hiring going?
21:53:37 <augustss> slowly
21:53:45 <pchiusano> hiring?
21:53:49 <augustss> we've had a few applicants
21:53:50 <hpaste>  Procyon112 pasted "Confused fmapping" at http://hpaste.org/1579
21:54:01 <Korollary> augustss: were they good?
21:54:14 <procyon112> ^^^ I need pointers :/
21:54:26 <pchiusano> augustss, are you actually hiring haskell programmers?
21:54:35 <augustss> of course
21:54:44 <augustss> not me personally, but Credit Suisse
21:54:49 <pchiusano> I didn't know there were actual haskell jobs
21:54:56 <jcreigh> procyon112: maybe (error "Failed") put (somefunc a b)
21:55:01 <jcreigh> I think
21:55:07 <jcreigh> @type maybe
21:55:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:55:13 <Heffalump> https://creditsuisse.taleo.net/servlets/CareerSection?art_ip_action=FlowDisp
21:55:13 <Heffalump> atcher&flowTypeNo=13&pageSeq=2&reqNo=53820&art_servlet_la
21:55:13 <Heffalump> nguage=en&selected_
21:55:15 <Heffalump> language=en&csNo=10020#topOfCsPage
21:55:15 <lambdabot> http://tinyurl.com/yv57p7
21:55:21 <Heffalump> bah, wrapped it, sorry
21:55:36 <dons> tinyurl++
21:55:45 <dons> ah, not quite.
21:55:46 <Heffalump> yeah, but it'll be broken cos I wrapped it
21:55:49 <dons> Heffalump: you can use @tiny-url
21:56:04 <jcreigh> oh, heck, go to tinyurl.com in your web browser. :)
21:56:09 <Heffalump> I'm just doing that.
21:57:04 <procyon112> jcreigh: That's the thing though.  The somefunc is just a generic monad, and it already called fail.. There should be no reason to make it a maybe, only to call fail again.  I should be able to fmap it, right?
21:57:10 <Heffalump> http://tinyurl.com/2lqoq9
21:57:13 <augustss> urls that long should be banned :)
21:57:23 <Heffalump> well, so should ClearCase :-)
21:57:43 <augustss> agreed!
21:57:45 <dons> Heffalump: is this the same one lennart mentioned on haskell-cafe@?
21:57:49 <Heffalump> yes
21:57:50 <Heffalump> well, I hope so
21:57:51 <Korollary> What does ClearCase have to do with it?
21:57:54 <dons> if so, maybe i should link to it for the HWN tomorrow
21:57:56 <Heffalump> it's the same one he was supposed to mention :-)
21:58:11 <dons> I got Howard's ok to do that. Actually, he asked me specifically to put it in :-)
21:58:13 <Heffalump> Korollary: it's the version control system we use. Bit annoying.
21:58:14 <augustss> dons: please do
21:58:30 <dons> ok
21:58:36 <sioraiocht> > 459 :: Word8
21:58:38 <lambdabot>  203
21:58:45 <Korollary> Heffalump: I sorta liked it actually.
21:59:16 <Heffalump> looking for a job? :-)
21:59:29 <Korollary> Not at the moment
21:59:42 <augustss> we didn't mention liking ClearCase as a prerequisite in the ad
22:00:00 <Heffalump> no, but it's got to be an advantage
22:00:04 <bos> there's no challenge in going to a place that already uses haskell. the challenge is in going to a place that doesn't :-)
22:00:11 <dons> hehe
22:00:18 <bos> must enjoy clearcase and long waits.
22:00:24 <jcreigh> procyon112: well, Functor *only* provides fmap, so I don't think there's a way to encode failure with that.
22:00:37 <augustss> bos: oh, there's s till the challange of getting all the non-haskell people to use haskell
22:00:49 <Korollary> Hmm. A quant job that doesn't require quant-level math skillz.
22:00:51 <bos> must particularly enjoy long waits and diffmerge. and did we mention the long waits?
22:01:02 <merus> I like long waits.
22:01:03 <Heffalump> yeah, there's 2 of us, 2 using Haskell, and 43,996 still not converted to using it.
22:01:08 <merus> Are you allowed to bring books to the office?
22:01:10 <procyon112> jcreigh: I think I got it... annotating
22:01:14 <augustss> bos: and then there are the long waits
22:01:39 <Korollary> Ok it's not a quant job per se.
22:01:40 <bos> augustss: all you need is a nice shiny book to convince them that haskell is practical.
22:01:47 <Heffalump> Korollary: well, you're very much part of a quant group. But as you say it's not a job being a quant.
22:02:18 <augustss> bos: these people are sceptics :)
22:02:25 <dons> bos, great idea!
22:02:38 <Heffalump> they are way less skeptical than every other commercial environment I've worked in
22:02:45 <augustss> true
22:03:00 <Korollary> Yes. Quants are used to throwing in exotic tech at difficult problems.
22:03:00 <hpaste>  procyon annotated "Confused fmapping" with "This should work.. Actually, I can make it alot simpler in this toy example" at http://hpaste.org/1579#a1
22:03:48 <hpaste>  procyon annotated "Confused fmapping" with "Simplest" at http://hpaste.org/1579#a2
22:03:58 <augustss> Heffalump: I think we have the quants much more on the Haskell side than the guys who will actually have to make sure it gets deployed etc.
22:04:11 <Heffalump> yeah
22:04:21 <jcreigh> @src modify
22:04:22 <lambdabot> Source not found. Wrong!  You cheating scum!
22:04:44 <pchiusano> going to sleep, thanks all for help
22:05:17 <jcreigh> procyon112: oh, right.
22:05:19 <procyon112> jcreigh: It's a monad, and functor, so it has fmap and fail... fmap will propegate failures.  I was just getting confused having my generic monad inside my state monad, and was making it too hard in my brain.
22:05:42 <Korollary> augustss: Are the quants worried about performance?
22:06:00 <augustss> Korollary: where performance matters, very much
22:06:59 <augustss> but as we know, performance is critical only in a small fraction of your code
22:13:07 <dolio> procyon112: I don't think you're going to get away with a return type of 'State b ()' unless you pick a monad to run the result of 'somefunc' in.
22:13:12 <AStorm> hehe, sproingie has Y combinator in his quit message
22:15:54 <procyon112> dolio: It works.  The state Monad's fail appears to be triggered, which looks like it's defined as error.
22:17:07 <dolio> procyon112: Oh, I see. You just didn't want to go through maybe.
22:18:00 <procyon112> dolio: right... one reason is that by using Maybe, I lose the underlying fail text that caused the failure in the first place.
22:18:36 <dolio> procyon112: Ah. In that case, you can use 'Either String a'
22:18:52 <dolio> Although, just staying in the state monad might be all you need.
22:18:56 <sioraiocht> if I've imported Data.Sequence and want to use that null function how to I say so explicitly
22:19:01 <procyon112> dolio: Yup.
22:19:06 <dolio> > fail "Nuts!" :: Either String Int
22:19:08 <lambdabot>  Left "Nuts!"
22:19:10 <sioraiocht> so that I don't get eth message Ambiguous occurrence `null'
22:19:10 <sioraiocht>     It could refer to either `null', imported from Prelude
22:19:10 <sioraiocht> 		          or `null', imported from Data.Sequence at /Users/rtharper/null.hs:4:0-19
22:19:10 <Heffalump> sioraiocht: Data.Sequence.null
22:19:15 <sioraiocht> Heffalump: thanks
22:19:25 <Heffalump> sioraiocht: but you should probably import Data.Sequence qualified in the first place
22:19:42 <procyon112> > fail "Nuts!" :: State [Int] ()
22:19:42 <Heffalump> otherwise you can't get list's null without using Prelude.null
22:19:43 <lambdabot>        add an instance declaration for (Show (State [Int] ()))
22:20:05 <Heffalump> if it's like Map and Set, the standard boilerplate is
22:20:13 <Heffalump> import qualified Data.Sequence as Sequence
22:20:20 <Heffalump> import Data.Sequence (Sequence)
22:20:33 <Heffalump> that brings the datatype into scope as Sequence, and all the operations as Sequence.foo
22:20:47 <Heffalump> but I've not used Sequence so I wouldn't swear to it being the same as Map/Set.
22:21:39 <procyon112> @src fail
22:21:40 <lambdabot> fail s      = error s
22:22:48 <dmead> this is neat
22:22:56 <dmead> get fetches the last state
22:23:02 <dmead> and put changes the current one?
22:23:07 <Heffalump> yep
22:23:10 <AStorm> mhm
22:23:48 <ski> (monochrom : i was pondering if i could avoid a list .. i just didn't think of 'listArray' at all)
22:24:07 <procyon112> dolio: OH!  I get it... the underlying fail is being put into the State... Then my computation goes on, as normal, until I try to do something with the state.  Goofy lazy error propagation :)
22:24:16 <ski> (but maybe it gets fused with 'range' .. hmm)
22:24:58 <Pseudonym> ?quote trippy
22:24:59 <lambdabot> Pseudonym says: Lazy evalution is really, really trippy.
22:25:08 <dolio> procyon112: If you want to mimic your original code, it's something like...
22:25:26 <monochrom> I see. I wouldn't know which is faster.
22:25:28 <dolio> procyon112: myfunc a b = somefunc a b >>= put
22:26:59 <procyon112> dolio: Yeah.. but in my actual code, the state is actually a tuple, and I'm using it, so the do notation is much nicer.
22:30:01 <sioraiocht> SUCCESS
22:30:05 <sioraiocht> *Main> run 15360939363786950397128283933599538624892174320483034857003355015791389885897612629870350403156745676936815818730836908075646108694411913908753341542249057283074613678144889367
22:30:05 <sioraiocht> Hello, world!
22:30:15 <sioraiocht> that's hello world in NULL =p
22:30:33 * dolio is confused.
22:30:48 <monochrom> Oh my God. A beast is unleashed.
22:31:04 <sioraiocht> dolio: http://scienceblogs.com/goodmath/2007/01/a_pathological_challenge_prime.php#more
22:31:07 <lambdabot> Title: Good Math, Bad Math : A Pathological Challenge: Prime Programming in NULL, http://tinyurl.com/ypw4lp
22:31:13 <monochrom> Are we going to program in GÃ¶del numbering?!
22:31:45 <sioraiocht> I just wrote an interpreter for that in haskell
22:32:47 <dolio> Now you need to write a compiler from Haskell to NULL.
22:33:10 <dmead> sioraiocht, good work :)
22:33:13 <dmead> you should post that
22:33:29 <sioraiocht> dmead: where? and it needs some refining first ;)
22:33:43 <dmead> on the wiki someplace
22:33:46 <sioraiocht> hehe
22:33:47 <dmead> or hackage
22:34:03 <dmead> how many lines did it take ?
22:34:17 <sioraiocht> 160
22:34:34 <sioraiocht> there is a fair amount of commenting, too
22:37:19 <dmead> cool
22:37:52 <sioraiocht> dmead: thanks for your help earlier
22:37:56 <sioraiocht> now it's time for me to SLEEEEEEP
22:38:05 <dmead> http://haskell.org/haskellwiki/Libraries_and_tools/Compilers_and_interpreters
22:38:08 <lambdabot> Title: Libraries and tools/Compilers and interpreters - HaskellWiki, http://tinyurl.com/ye98mq
22:38:13 <dmead> nn
23:12:11 <dons> ?yow
23:12:11 <lambdabot> Wait ... is this a FUN THING or the END of LIFE in Petticoat Junction??
23:13:38 <Korollary> Let's argue about something technical using analogies.
23:14:46 <dmead> is there a nice way to mix regular parameter passing with the state monad?
23:15:03 <dmead> i'm at a loss on how you'd put state in the type signature
23:15:40 <dons> State MyState a
23:15:49 <dons> and you can mix them by doing manual get/put
23:15:58 <dons> dmead: do you have a small example you're working on?
23:16:13 <dmead> ah not atm
23:16:19 <dmead> hmm
23:16:38 <dmead> hold on
23:19:54 <dmead> ack
23:20:03 <dmead> hmm
23:20:12 <dmead> i don't have anything simple to show
23:20:19 <dmead> mostly cause i'm not sure how to go about it :<
23:21:18 <dmead> let me throw something together...
23:21:18 <dons> can you describe the problem?
23:21:27 <dons> i've got about 20 minutes available here to help you :-)
23:25:13 <dmead> ah
23:25:13 <dmead> k
23:25:18 <dmead> i've got an expression tree
23:25:33 <dmead> which covers FOL
23:25:47 <dmead> i need to give each variable in the tree a unique name
23:26:04 <dons> ok.
23:26:15 <dons> so a standard renaming pass, using a unique supply monad?
23:26:26 <dons> and a gamma/symbol table to track names?
23:26:28 <dmead> unique supply?
23:26:34 <dons> a supply of unique names
23:26:43 <dmead> well, i thought about using a list
23:26:54 <dons> yeah, an infinite list of numbers is a good start
23:27:08 <dmead> but starting with z and decrementing each time a variable name is reassigned is probably fine
23:27:08 <dons> and a simple state monad.
23:27:19 <dmead> right
23:27:42 <dmead> i see how to give a state an initial condition, and retrieve/write to the state
23:27:50 <ddarius> You could use a "painting" approach, but that gives fairly ugly/deep names, though they can easily be flattened later.
23:27:53 <dons> so the state type would be something like:
23:27:54 <dons> data Rename = Rename
23:27:54 <dons>     { syms = [Int]
23:27:54 <dons>     , env  = Map String String }
23:28:13 <dmead> but how do you declare a type signature for a function that has a state and regular types
23:28:16 <dmead> oh
23:28:23 <dons> i used this for a complex rename recently:
23:28:25 <dons> data RnSt = RnSt { gamma  :: M.Map Var Var
23:28:25 <dons>                  , unique   :: [Var]
23:28:25 <dons>                  , uniquelist :: [Var]
23:28:25 <dons>                  , uniquefn :: [Var]
23:28:27 <dons>                  }
23:28:46 <dons> and generated names with:
23:28:47 <dons>         suggestionsVal = map (:[]) "xyzuvabcstdeilmnorw"
23:28:47 <dons>                             ++ [ 'x' : show i | i <- [1..] ]
23:29:06 <dons> so it starts off with 'xyz...' variable names, and when they run out, uses xN , where n is some int
23:29:18 <dmead> ahh
23:29:24 <dons> do you want to see the code?
23:29:27 <dmead> right, instead of doing something with primes
23:29:28 <dmead> sure
23:29:37 <dmead> i'm still quite shaky on monads
23:29:39 <dons> primes eh? :-)
23:29:42 <dons> ah yes.
23:29:48 <dons> '-primes
23:29:51 <dmead> prime quote i mean
23:29:54 <dmead> a'
23:29:55 <dmead> a'
23:29:59 <dmead> a''
23:30:00 <dmead> a'''
23:30:01 <dmead> etc
23:30:20 <dons> http://www.cse.unsw.edu.au/~dons/tmp/rename.hs
23:30:23 <dons> grep for XXX
23:30:38 <dons> so the renamer state monad is just, type RN a = State RnSt a
23:31:13 <dons> it just pulls names off the infinite list of possible names described by the generator above
23:31:18 <ddarius> type Name = [Int]
23:31:29 <dmead> ahhh
23:31:29 <dmead> hmm
23:31:45 <dons> and then keeps track of what renamings its seen using the Map
23:34:25 <dons> dmead: so is that enough for you to make forward progress?
23:34:30 <dmead> yes
23:34:32 <dmead> i think so
23:34:37 <dmead> i just have to understand it first :)
23:34:51 <dons> cool. let me know if you get stuck
23:34:57 <dmead> sure thing
23:35:07 <dons> its really rather beautiful writing renamers in haskell
23:35:13 <dons> the problem decomposes perfectly
23:35:14 <mauke> first you declare the regular type, e.g. :: a -> b -> c
23:35:21 <mauke> then you add the monad to the return type
23:35:32 <mauke> :: a -> b -> X c
23:37:31 <dmead> hmm
23:38:35 <dmead> when you update something in a state it behaves just like a variable in an imperative language?
23:38:51 <mauke> yes
23:42:16 <igli> er can i ask some n00b questions please? I'd like to know about generators, wrap and bind.. (not much, i know ;)
23:42:24 <aFlag> I'm trying to implement a lexer in haskell, what's probably the best way to go? On C I'd keep a buffer where I load a few bytes from the input and iterate over each character to get a lexeme. When I find one I could just write it to memory and return it along with the token identifier. I'm having a little trouble to do that in haskell, first off reading a input char into a string ends up giving me a inverted lexeme, and concatenating it to the end is probab
23:42:45 <mauke> igli: just ask
23:43:07 <aFlag> Also I think I'd have to use some state monad perhaps? for keeping the state of the lexer function after it exits, so it can start over where it stoped
23:43:40 <igli> thanks mauke; there is a wrap operator >>= ? or is that bind; also is bind the same as map?
23:43:55 <mauke> >>= is commonly called bind
23:44:04 <igli> ah
23:44:11 <dmead> the wrapper to bind is do
23:44:16 <dmead> and bind is not the same thing as map
23:44:21 <mauke> >>= in the list monad is concatMap
23:44:40 <igli> so >>= is a function to apply?
23:44:42 <mauke> the monadic map is called liftM
23:45:02 <mauke> it's an ordinary operator
23:45:25 <igli> i am just trying to get straight in my head what these do; i understand wrap is for sending stuff between functors?
23:45:39 <mauke> I don't know what wrap is
23:45:55 <mauke> do you mean return?
23:46:13 <igli> no, i might have it wrong; was something to do with nuclear waste (!)
23:46:29 <monochrom> aFlag: I suggest download and use "Alex".  It generates a lexer.
23:46:43 <igli> er that was the metaphor used in the tutorial.. let me find it
23:47:26 <mauke> bah, tutorials
23:48:06 <monochrom> OTOH, if you want to learn techniques of writing one yourself, take a look at the source code of the library functions "words" and "lines", and get ideas from there.
23:48:58 <igli> heh i like <- anyhow
23:49:10 <mauke> <- is an illusion
23:50:23 <Cale> <- could be real, if we wanted it badly enough
23:51:59 <igli> <- zip tail
23:53:44 <monochrom> Programmable <-
23:53:46 <igli> seems like for..in
23:54:33 <AStorm> uhm, nope?
23:54:49 <AStorm> It's for unpacking IO monads, right?
23:55:01 <mauke> > do { x <- [0 .. 9]; return (x * 2) }
23:55:03 <lambdabot>  [0,2,4,6,8,10,12,14,16,18]
23:55:11 <AStorm> or other monads too
23:55:14 <ddarius> do a <- ma; stmts <-> ma >>= \a -> do stmts
23:55:39 <monochrom> look ma, no <-  :)
23:55:45 <AStorm> :>
23:55:56 <AStorm> syntactic sugar, yep
23:56:13 <AStorm> same as the ;
23:56:20 <AStorm> in do statement
23:56:34 <igli> > [ x * x | <- [0..9] ]
23:56:34 <lambdabot>  Parse error
23:56:38 <igli> hehe
23:56:40 <AStorm> igli: uhm
23:56:48 <AStorm> > [ x *x | [0..9] ]
23:56:49 <lambdabot>   Not in scope: `x'
23:56:53 <igli> *shrug*
23:56:56 <AStorm> > [ x *x | x <- [0..9] ]
23:56:58 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
23:57:02 <igli> > [ x * x | x <- [0..9] ]
23:57:04 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
23:57:06 <igli> er yep
23:57:08 <igli> sorry
23:57:27 <AStorm> In that case, it's special syntax :P
23:57:37 <ddarius> [x*x | x <- [0..9]] <-> do x <- [0..9]; return (x*x) <-> [0..9] >>= \x -> return (x*x)
23:57:37 <mauke> > map (^ 2) [0 .. 9]
23:57:39 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
23:57:40 <monochrom> arrow notation (proc x -> do y <- f -< x; ...) is syntactic pepper.
23:57:49 <AStorm> ddarius: definitely
23:57:50 <ddarius> [0..9] >>= return . join (*)
23:57:52 <igli> x** for x in [0..9]
23:57:57 <ddarius> > [0..9] >>= return . join (*)
23:57:59 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
23:58:01 <AStorm> monochrom: yep, so write some larger function w/o it :P
23:58:05 <Cale> In the IO monad, I prefer to say that <- is for running IO actions.
23:58:09 <AStorm> wish you well :>
23:58:14 <monochrom> I like pepper
23:58:18 <mauke> > liftM (join (*)) [0 .. 9]
23:58:19 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
23:58:26 <igli> woah
23:58:30 <monochrom> When I eat a large steak I add pepper.
23:58:32 <Cale> r <- x will run the action x to produce the result r
23:58:33 <AStorm> mauke: this simple case doesn't count
23:58:43 <mauke> what
23:58:46 <AStorm> Cale: it actually unpacks the monad, somewhat
23:59:06 <Cale> In container-like monads it's quite a lot like unpacking
23:59:07 <AStorm> runMonad or sth
23:59:25 <igli> ddarius: i like that >>= thing as well
23:59:29 <AStorm> IO is the container too - contains toxic, unknown waste
23:59:33 <Cale> What you get from "unpacking" getChar is different every single time though.
23:59:47 <AStorm> ^
23:59:50 <igli> is there an unpack operator then?
23:59:58 <mauke> some monads have one, yes
