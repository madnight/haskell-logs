00:00:05 <pjd_> ish
00:00:51 <earthy> 'an special kind of'
00:00:53 <earthy> man. ;)\
00:01:00 <Korollary> There should be an online quiz about PLT. If you can't pass it, you should shut the #%&^ up.
00:01:20 <lucca> nmessenger: thanks!
00:01:23 <earthy> I didn't even make it through the second paragraph without being tripped up by an obvious mistake that *anyone* could catch. ;)
00:02:07 <mbishop> Heh, slava ripped him, but it's too true :P
00:03:12 <nmessenger> lucca: You're welcome. Wait, thanks for what?
00:04:10 <lucca> politely demonstrating a better way to search the web
00:04:58 <pjd_> earthy: the best bit is his proposed IO monad replacement
00:05:25 * earthy is getting to that. ;)
00:05:41 <earthy> with an amused smile around my lips
00:06:06 <pjd_> "just create a special representing the world, and write functions like main :: world -> output!"
00:06:13 <pjd_> "a special value", even
00:06:18 <earthy> it's just that all the freshman that will be taking haskell as of next week probably will not have the insight to dismiss this article
00:06:23 <earthy> pjd: oh, that's what Clean dus
00:06:24 <earthy> does
00:06:38 <earthy> so it's not all that stupid
00:06:55 <earthy> start :: *World -> *World
00:07:21 <earthy> (and yes, it's even called like that ;))
00:07:22 <nmessenger> with uniqueness types to prevent re-use of old Worlds.  It's not stupid, but it's less flexible than the IO Monad.  IO can be written that way.
00:07:23 <pjd_> earthy: the way he's proposing it *is* that stupid
00:08:40 <nmessenger> actually I'm not smart enough to assert it's less flexible, I'll suffice to say that it seems more tedious.
00:08:51 <dons> see, e.g., http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=clean&id=0
00:08:53 <lambdabot> Title: fasta Clean program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/ysq2tq
00:08:56 <earthy> he *really* really didn't understand it
00:09:04 <dons> Start world
00:09:05 <dons>         # n                             = argi
00:09:05 <dons>         # (io,world)    = stdio world
00:09:05 <dons>         # rng                   = makeRandomGenerator 42
00:09:29 * lispy waves at dons
00:09:41 <dons> hey lispy
00:10:18 <lispy> anyone know if happs has an apache module?
00:10:37 <lispy> dons: i had some reason i couldn't upgrade to ghc6.6, any chance you've delt with that?
00:10:44 <earthy> lispy: there is none. however, a few years ago there was a mod_haskell
00:10:45 <lispy> i think it was a lambdabot dependency...
00:10:49 <lispy> like hs-plugins
00:10:50 <earthy> it has bitrotted though.
00:11:03 <dons> lispy, yeah. that's done.
00:11:07 <dons> grab the darcs repo
00:11:14 <lispy> dons: awesome
00:11:19 * earthy hasn't had the heart to revive mod_haskell yet
00:11:19 <dons> (untested with lambdabot yet though!)
00:11:21 <dons> so i'd hold off
00:11:28 <lispy> i should try to find time to upgrade it this weekend
00:11:31 <lispy> dons: ah
00:11:36 <xic> would be cool if happs had fastcgi support
00:11:37 <lispy> yeah, i don't want to break lambdaweb
00:12:10 <pjd_> xic: why not proxy to it?
00:13:13 <xic> pjd_: don't know
00:17:25 * pjd_ boggles
00:19:12 <pjd_> in another post, karsten suggests changing Haskell so that all functions are implicitly monadized
00:19:52 <pjd_> so that foo :: a -> b is equivalent to foo :: Monad m => a -> m b
00:20:04 <Korollary> Ignorance is ...
00:20:21 <dons> I think he doesn't like monads or something ..
00:20:43 <lispy> Korollary: bliss!
00:20:54 <pjd_> dons: in which case monadizing everything seems like the very last thing you'd want to do
00:20:58 <lispy> many people dislike monads, this is not news right?
00:21:08 * nmessenger is still reading the Karsten post. I *want* to clearly--and friendlily--demonstrate that he describes nothing new, but the many outright false assertions are really wearing me down.
00:21:13 <earthy> many people think monads are hard.
00:21:40 <pjd_> earthy: everything simple is hard :)
00:22:14 <lispy> i work with people that have a hard time groking generics in C#
00:22:30 <pjd_> nmessenger: i think saying that he demonstrates anything is being generous
00:22:44 <lispy> i can't imagine holding their hand through the deep concepts of haskell
00:22:46 * earthy simply vocally agread with Slava
00:23:01 <Korollary> Then it's irrelevant.
00:23:06 * earthy has helped people understand Clean
00:23:22 <earthy> functional programming in my experience seperates wannabe programmers from true programmers
00:23:30 <nmessenger> I _really_ want to lash out and flame right now :(
00:24:12 <earthy> nmessenger: you wasted more than enough time on the previous article
00:24:13 <Korollary> nmessenger: Have some weed, mon!
00:24:23 <Korollary> Hakuna matata
00:24:33 <earthy> simply point to that in a comment and state that you will no longer waste time on him.
00:25:00 <lispy> Korollary: oh god, not Hakuna matata...my HS computer teacher used to play that EVERY morning
00:25:42 <Korollary> go back to your seat.
00:25:54 * earthy laughs
00:26:28 <nmessenger> earthy: trouble is, being dismissive like that will be viewed as "uppity Haskell-tard self-importance" by many, like the popular view of lispers
00:26:30 <hpaste>  xpika pasted "try out my haskell code!" at http://hpaste.org/256
00:27:20 <earthy> nmessenger: not if you point to the other article
00:28:17 <nmessenger> I want more than anything to *share* the delight that I've had learning Haskell
00:28:23 <earthy> )
00:28:26 <earthy> :)
00:30:35 <pjd_> nmessenger: right
00:31:50 <pjd_> should ignore it and worry about things that matter
00:32:13 <lispy> nmessenger: unfortunately if you evangelize or preach to others you turn them off...better to go out and be successful and spark their curiosity that way
00:32:36 <nmessenger> Yeah.  I suppose it's stupid taking offense if someone makes false claims about my hammer.  *I* know what it does, so that should be enough.
00:32:53 <mbishop> Your hammer is sooo gay
00:33:09 * nmessenger whistles
00:33:20 <nmessenger> nonchalantly*
00:33:27 <pjd_> lispy: no harm in some evangelism when you're answering questions or otherwise helping people out :)
00:33:41 <fatalis> you dorks
00:33:56 <nmessenger> fatalis: :P
00:35:05 <lispy> there is no dork, only do or do not
00:35:15 <lispy> yoda++
00:35:24 <nmessenger> @karma yoda
00:35:24 <lambdabot> yoda has a karma of 1
00:35:26 <therp> good morning
00:35:27 <xpika___> @karma yoda
00:35:28 <lambdabot> yoda has a karma of 1
00:42:01 <xic> what is the proof that newIORef is safe to use in unsafePerformIO for top-level IORefs?
00:46:13 <nmessenger> it's not safe unless you specifically tell ghc not to do it more than once with a NO_INLINE pragma.
00:46:31 <nmessenger> As for proof, well, um... *runs away*
00:53:49 <nmessenger> The IORef is just allocated the first time it's used during the evaluation phase, instead of during the more usual IO execution phase.
00:54:02 <earthy> there. I hope Karsten stops his unthinking shite.
00:56:48 <earthy> (this better, nmessenger? :))
00:57:22 <nmessenger> earthy: I doubt it'll have any effect :/
00:57:38 <earthy> I can dream, can I?
00:57:51 <Korollary> No
00:57:58 <earthy> I've been T/A'ing for 13 years already
00:58:00 <nmessenger> So long as you never revisit the page, sure
00:58:18 <Korollary> ta'ing for 13 years? Pursuing 4 PhD's in parallel?
00:58:18 <earthy> I'm used to not making my points clear ;)
00:58:38 <earthy> korollary: I already T/A'd during my bachelor's ;)
00:59:02 <xpika___> @index member
00:59:03 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set
00:59:10 <earthy> and I took quite some time getting my master's.
01:01:13 <earthy> oh well, time to grade stuff again.
01:16:31 * mux reads paper on open data types and isn't particularly excited
01:17:12 * nmessenger stares at his fingernails and is ecstatic!
01:39:21 * lispy thinks about another glass of wine and nearly wets himself
01:39:56 <dons> lovely!
01:39:58 <dons> ?users
01:39:59 <lambdabot> Maximum users seen in #haskell: 322, currently: 275 (85.4%), active: 32 (11.6%)
01:40:43 <nornagon> still no higher :(
01:41:40 <dons> earthy: reading the Clean code on the shootout, it seems to encourage a more mutable-state style of programming than I'm used to in haskell
01:41:54 <dons> or maybe its just the useful syntax for array indxing
01:42:17 <dons> types like this worry me, next_permutation :: !*{#Int} !*{#Int} !Int !Int -> (!*{#Int},!*{#Int},!Int)
01:44:18 <mnislaih> sfopen :: !{#Char} !Int !*f -> (!Bool,!File,!*f)
01:44:24 <mnislaih> not pretty..
01:44:43 <pjd_> this language's name was what again? :)
01:45:40 <earthy> :)
01:45:53 <earthy> Concurrent Language of East Anglia and Nijmegen.
01:45:59 <earthy> oh, no, sorry
01:46:24 <earthy> clean was a cleanup of lean which was Language of East Anglia and Nijmegen
01:46:29 <earthy> ;)
01:47:31 <dcoutts> dons, I think we need to eliminate the extra indirection in the lazy bytestring
01:47:33 <earthy> {#Char} is an array of unboxed characters.
01:47:40 <earthy> which really is Data.Bytestring
01:47:56 <dcoutts> dons, or rather try it and benchmark it
01:49:03 <dons> dcoutts: yeah. see the difference between these two programs
01:49:14 <dons> lazy bytestrings, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
01:49:15 <dcoutts> dons, I'm thinking of the difference in the sumfile for strict vs lazy
01:49:16 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/ys3ony
01:49:24 <dons> strict ones, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=5
01:49:27 <lambdabot> Title: sum-file Haskell GHC #5 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/298jph
01:49:27 <dons> :)
01:49:29 <dons> right
01:49:52 <dons> ghc generates perfect code for the strict one, turning it into a raw buffer traversal
01:49:57 <dons> but the lazy one is all hidden away
01:50:09 <dcoutts> dons, you mean it's a 10x difference ?!
01:50:12 <dons> i've submitted a combination entry, that's lazy over strict chunks
01:50:22 <dons> that should be a bit better, i think
01:50:46 <dons> note the strict one outperforms clean by 2x
01:50:50 <dons> and everything else..
01:50:51 <dcoutts> aye
01:51:25 <dons> here's the combination entry, (urgh), but i need my ptr Addr#, http://www.haskell.org/haskellwiki/Shootout/SumFile#Pending
01:51:26 <lambdabot> Title: Shootout/SumFile - HaskellWiki
01:51:39 <dons> it uses the very fast Addr# loop code, chunkwise
01:51:53 <dons> (so keeps the constant space requirement, essentially this is whta the lazy stuff should compile to)
01:52:33 <xpika___> @index lift
01:52:34 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
01:52:34 <lambdabot> ParserCombinators.ReadPrec, Text.Read
01:52:37 <dcoutts> dons, here's another trick: eliminate [] in the lazy representation
01:52:59 <dcoutts> dons, make [] = ByteString 0 0 0
01:53:09 <dcoutts> so that lazy bytestring has a single constructor
01:53:13 <mux> dons: why is the GHC #5 version only listed in the alternative programs?
01:53:16 <dcoutts> so it can be unpacked in inner loops
01:53:27 <dons> mux, its too strict for the spec
01:53:39 <dons> (which says linewise reading/constant space use)
01:53:50 <dons> its O(n) space, but .... whoohoo!
01:53:59 <mux> ok
01:54:33 <dcoutts> dons, and make Lazy.head have a branch prediction annotation on the end of chunk thing
01:55:02 <dcoutts> so when you use it in a tail recursive ...
01:55:30 <master_baiter> meh in my opinion branch prediction annotations are pretty useless
01:55:34 <master_baiter> (on x86)
01:55:54 <dcoutts> master_baiter, I don't mean cpu branch prediction annotations, I mean compiler ones
01:56:01 <master_baiter> oh
01:56:03 <dcoutts> so tell the compiler how to lay blocks out
01:56:21 <dcoutts> to say which are fast and slow paths
01:56:47 <dcoutts> eg failing some bounds check is the slow path that only happens once per chunk
02:11:10 * earthy reads through a few more of K. Wagner's articles
02:11:34 <earthy> damn, that guy needs to be taken out, dunked into a vat of ice water and taught what computer science really is all about
02:13:34 * earthy thinks mark-sweep is easier than refcounting
02:13:45 <earthy> and mark-sweep will find cycles.
02:15:07 <pjd_> easier in what way?
02:15:23 <amiddelk> earthy: trying to teach a frozen brain is somewhat difficult; a vat with hot coals is perhaps a better solution ;-)
02:15:26 <opqdonut> less to think while implementing
02:15:31 <magnus--_> mark-sweep thrashes much more when memory is limited
02:15:54 <earthy> yeah, but mark-sweep is *trivial* to explain
02:15:59 <opqdonut> refcounting is a pain to implement
02:16:04 <earthy> and implement
02:16:18 * earthy should stop reading Karsten's tripe
02:16:30 <pjd_> opqdonut: a pain to use, maybe;  there's hardly anything to implement
02:16:44 <opqdonut> well, yeah
02:16:50 <opqdonut> depends on your POV
02:16:52 <pjd_> (assuming you're not counting cycle-finding code)
02:16:55 <earthy> he's just a frigging energy creature
02:16:59 <earthy> aka TROLL
02:23:39 <magnus--_> I think he has good points many times even though he makes factual mistakes often i his articles
02:25:07 * earthy thinks he started as an enthousiast back in the 1980's, has managed to earn money with it ever since, formed strong convictions one way or the other, but has never been formally trained
02:25:27 <earthy> and is too dumb to see that that is a problem
02:26:16 <earthy> unfortunately, large parts of the professional programming community are like that
02:27:14 <velco> who's that ?
02:27:44 <pjd_> earthy: there's a difference between not being formally trained and just not learning
02:30:50 <MarcWebe1> Where can find some documentation about mod_php (php with apache?) on the apache site or on the php site?
02:31:29 <pjd_> MarcWebe1: the latter
02:39:56 <therp> sigh.. verbatim environments can't be used in latex's tabular.. making latex presentations is just a pita.
02:40:02 <earthy> pjd: true enough. but had he been formally trained he wouldn't be *this* bad...
02:40:15 <earthy> not even those that just won't learn that I've seen are
02:41:36 <Adamant> bite your tongue. you haven't seen some of the professors and TA's I have
02:42:12 <Adamant> there is all kind of nonsense that gets taught in a lot of places.
02:42:15 <earthy> adamant: I've seen some pretty bad ones. ;)
02:45:37 <pjd_> earthy: i dunno... formal training might just have the effect of increased self-confidence/righteousness
02:52:33 <earthy> it might, true enough
03:01:23 <JKnecht> well CS is unusual in that it is more or less a reaction to the success of practical electronic computing. To the extent it isn't I tend to think of it as a branch of applied math.
03:02:36 <opqdonut> yeah applied math basically
03:02:46 <opqdonut> the part of cs that isn't programming that is
03:04:52 <fatalis_> counter strike?
03:05:11 <opqdonut> Computer Science, har har
03:05:57 <fatalis_> I think I like you as a man
03:06:20 <opqdonut> man referring to you or to me
03:06:24 <opqdonut> or both?
03:06:30 <pejo> opqdonut, so are people in here doing programming or applied math?
03:06:47 <fatalis_> opqdonut, I meant me
03:06:51 <opqdonut> ok
03:07:06 <opqdonut> pejo: i'd say the more meta- the programming, the closer we are to math
03:07:17 <opqdonut> that is haskell is much closer than asm
03:07:35 <roconnor> I do consturctive math. ... but I'm not sure that is the same as applied math :)
03:07:54 <siti> I dislike math, but like programming :P
03:07:54 <opqdonut> imo algorithm and datastructure design are the most "math" in programming
03:08:03 <opqdonut> siti: then you don't know math
03:08:04 <siti> I don't think math = programming
03:08:26 <opqdonut> roconnor: hmm good point, constr. math is quite close to progamming in a way
03:08:28 <siti> don't know math? you like math?
03:08:35 <opqdonut> yeah
03:08:48 <opqdonut> there's so much to math you can't say you don't like it
03:08:49 * roconnor thinks (math - set theory) = programming
03:09:00 <siti> I used to like math, but not anymore :P
03:09:09 <JKnecht> MIX instead of asm would be more mathy
03:09:23 <opqdonut> siti: how come?
03:09:27 <Vq^> siti: programming ⊂ math
03:09:37 <roconnor> granted most math consists of investingating different ways of writing functions from the empty set to the empty set.
03:09:41 <opqdonut> Vq^: that ? a unicode symbol?
03:09:50 <Vq^> opqdonut: yes
03:09:52 <siti> pfft I am in a room of academics (haskell is run by the academic community) :(
03:09:56 <opqdonut> Vq^: which one?
03:09:59 <opqdonut> subset?
03:10:04 <Vq^> opqdonut: "subset of"
03:10:10 <opqdonut> siti: true :)
03:10:23 <opqdonut> Vq^: yep
03:10:26 <pejo> siti, doesn't mean they don't know how to program though.
03:10:34 <Vq^> opqdonut: not all of us is academics
03:10:38 <opqdonut> siti: so what put you off math
03:10:43 <siti> yeah, but alot would like math ;)
03:10:47 <roconnor> and when they do occasionaly create real functions, they tend to execute very slowly.
03:10:50 <Vq^> er, that was aimed at siti
03:10:55 <siti> and that's why learning haskell is so difficult ;)
03:11:04 <opqdonut> Vq^: well i'm not an academic, but probably becoming one
03:11:07 <siti> university math is rather, boring
03:11:23 <opqdonut> siti: too formal? too slow-paced? too abstract?
03:11:24 <siti> with programming you create something, you solve something (well useful)
03:11:25 <pejo> siti, a good tool though.
03:11:27 <Vq^> siti: what math is that?
03:11:41 <JKnecht> knowing how to program is one thing, knowing how to fit programming into other stuff is the trick
03:11:54 <siti> it's to formal, yet I think haskell makes more sense then math
03:12:01 <siti> I think they should scrap math, and just have haskell ;)
03:12:12 <opqdonut> there wouldn't be haskell w/o math
03:12:18 <opqdonut> and the mathematical mindset
03:12:25 <opqdonut> there'd just be lua and python and perl
03:12:29 <siti> yes, obviously alot of ideas come from math :P
03:12:34 <siti> but it's better :P
03:13:41 <Vq^> siti: whats your opinion on λ-calculus then?
03:13:43 <siti> e.g. java is better than objective c (debatable) yet java got lots of ideas from obj-c
03:14:04 <siti> how long did it take you to find that symbol ;)
03:14:09 <siti> or is it on your keyboard ;)
03:14:25 <bringert> dons: pushing to http: chmod: changing permissions of `./_darcs/patches/20070130235026-4c616-770c113acff1477478e30018f2b7c10a4b6606d0.gz'Finished applying...
03:14:25 <bringert> : Operation not permitted
03:14:25 <bringert> chmod: changing permissions of `./_darcs/patches/20070129230226-4c616-eb91265a06225719eb1a4f09084e9b6320bb1562.gz': Operation not permitted
03:14:26 <siti> I really have no idea what it is
03:14:35 <hpaste>  ramas pasted "parsinimas" at http://hpaste.org/257
03:14:40 <bringert> dons: I don't understand why those were wrong
03:14:48 <bringert> dons: they're owned by you
03:14:56 <siti> on the note of darcs, I use bzr for my haskell project :D
03:15:03 <siti> bzr is much more user friendly :P
03:16:09 <Saizan> bzr?
03:16:20 <opqdonut> bazaar
03:16:23 <opqdonut> a vcs
03:16:23 <earthy> bazaar-ng, IIRC
03:16:23 <siti> yep
03:16:27 <siti> yeah
03:16:40 <Vq^> siti: what ideas does Java get from obj-c?
03:16:52 <siti> immutable strings
03:16:52 <earthy> darcs is not ideal when you *want* to have a central repository
03:17:01 <siti> no multiple inhertiance
03:17:10 <siti> I can't remember exactly
03:17:13 <siti> have a look on wikipedia
03:17:18 <siti> I've heard it in a number of places ;)
03:18:09 <siti> http://www.cs.umd.edu/users/seanl/stuff/java-objc.html
03:18:11 <Vq^> ah wikipedia, the source of all knowledge :)
03:18:12 <lambdabot> Title: Java Was Strongly Influenced by Objective-C
03:18:23 <siti> @botsnack
03:18:23 <lambdabot> :)
03:18:28 <earthy> I'd call it the drain of all knowledge ;)
03:18:44 <siti> yeah I got a more original source ;)
03:29:40 <un-brice> hello world !
03:31:45 <JKnecht> hello un-brice!
03:32:06 <un-brice> hi JKnecht ^^
03:32:11 <hpaste>  ivanm pasted "Generating Partial Latin Squares" at http://hpaste.org/258
03:35:06 <ivanm> Hi everyone!  I've just put the Latin Square solving code I was talking about last night (well, night for me anyway) on hpaste if any of you want to have a look
03:35:46 <ivanm> Whoops, is there a character limit to what you can put into hpaste?
03:35:59 <legoscia> ?where tmr
03:35:59 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
03:36:22 <ivanm> Only 2 lines of code actually got put up.... is there anywhere else I can upload the code for people to look at?
03:42:13 <Saizan> ivanm yeah it's capped at 500 or so chars
03:42:28 <ivanm> damn!
03:42:51 <Saizan> well it's not meant as a repo
03:43:16 <Jaak> @hoogle getBounds
03:43:18 <lambdabot> No matches found
03:43:40 <Jaak> wh..
03:43:40 <ivanm> well, dons suggested I post my code there when I was done so people can have a look at it :s
03:43:58 <Eelis> ivanm: rafb.net/paste
03:43:58 <ivanm> And its just under 650 lines long :s
03:44:15 <Jaak> where is "getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)" defined?
03:44:35 <Saizan> you could trim the comments a bit
03:45:36 <ivanm> Thanks, Eelis!!!
03:45:47 <ivanm> OK, if people are interested in having a look its at http://rafb.net/p/c1cL9045.html
03:45:49 <lambdabot> Title: Nopaste - Latin Squares generator in Haskell
03:46:46 <Saizan> err it seems truncated
03:48:21 <ivanm> No it isn't: there's just a few lines I copied from nmessenger that I put down the bottom for me to work out how to use command line arguments, and I forgot to take them out again :s
03:55:15 <rahikkala> Hi. I'm trying to declare a class of types that index matrices (two-dimensional arrays), with (Ix a, Ix b) => (a, b) as an instance, but I'm getting type errors that I don't understand. I asked about this last night but nobody wanted to help :(.
03:55:19 <hpaste>  rahikkala pasted "MatrixIx Typeclass (yes, there will be more member functions, once I get this one to work)" at http://hpaste.org/260
03:56:02 <ivanm> rahikkala: thanks for helping me out last night, but in the end I didn't end up needing a comparison function
03:57:00 <ski> row :: (Ix a) => i -> a
03:57:01 <csci> Hi, does someone has a simple example for the use of Control.Monad.Reader? (I find the docs a bit short for a beginner)
03:57:02 <ski> there means
03:57:08 <ski> row :: forall a. (Ix a) => i -> a
03:57:48 <ski> i.e., you are promising that whatever type 'a' (in typeclass 'Ix') the caller of 'row' want you to return, you will return a value of that type
03:58:11 <ski> rahikkala : this is probably not what you want
04:00:08 <rahikkala> ski: Right... so is there a way of saying "I'll return whatever there actually is to return"?
04:00:38 <ski> possibly you want a multi-parameter type class
04:01:20 <dons> bringert: fixed, but looks like missing sticky bits?
04:01:57 <ski> (there is a way to express "i'll return a value of *some* type in class 'Ix'", yes .. but it's slightly awkward .. and then the caller may assume nothing except about that type except that it is in 'Ix')
04:02:12 <ski> (s/awkward/awkward to express/)
04:03:14 <ski> class Ix i => MatrixIx i row | i -> row
04:03:15 <ski>   where
04:03:30 <ski>   row :: Ix row => i -> row
04:03:30 <rahikkala> I'm not actually sure yet if that's what I need, but... *tries it out*
04:03:31 <ski> hm ..
04:03:39 <ski> maybe something like that
04:05:28 <dons> ?users
04:05:29 <lambdabot> Maximum users seen in #haskell: 322, currently: 282 (87.6%), active: 38 (13.5%)
04:05:56 <ski> (clarification : that code does to express the ".. *some* type .." variant)
04:06:05 <ski> (s/to/not/)
04:06:42 <AStorm> Hello. :-) (bumping activity)
04:09:05 <pjd_> csci: maybe this will help: http://www.alpheccar.org/en/posts/show/61
04:09:07 <lambdabot> Title: A newbie in Haskell land : The (->) monad
04:10:18 <ivanm> dons: Don't know if you saw my message about it before, but I've pasted the code for my Latin Square solver I was talking about yesterday at http://rafb.net/p/c1cL9045.html
04:12:19 <csci> pjd_, Thanks
04:15:43 <dons> ah great
04:16:25 <malebria> Good morning.
04:21:07 <hpaste>  michaelw pasted "Control.Monad.Reader example" at http://hpaste.org/261
04:21:55 <michaelw> csci: implementing scope is a pretty use case for MonadReader
04:22:58 <pjd_> csci: there's another example at http://www.alpheccar.org/en/posts/show/60
04:22:59 <lambdabot> Title: A newbie in Haskell land or another monad tutorial
04:23:11 <rahikkala> ski++
04:23:20 <rahikkala> Your solution worked and does what I need :)
04:23:24 <ski> oh
04:23:28 <ski> najs
04:24:08 <csci> michaelw, pjd_ Thanks again :)
04:25:00 <ski> (btw, i'm not sure if the 'Ix row' should be on the signature for 'row' .. or if it should be a superclass constraint, like 'Ix i')
04:55:37 <bringert> dons: yeah, it does look directory un-stickiness. I thought I had fixed that.
04:55:43 <bringert> dons: bringert@monk:/home/darcs/http/_darcs/patches$ touch foo
04:55:43 <bringert> bringert@monk:/home/darcs/http/_darcs/patches$ ls -l foo
04:55:43 <bringert> -rw-r--r--  1 bringert darcs 0 2007-02-02 04:50 foo
04:55:43 <bringert> bringert@monk:/home/darcs/http/_darcs/patches$ ls -ld .
04:55:43 <bringert> drwxrwsr-x  2 bringert darcs 4096 2007-02-02 04:50 .
04:55:50 <bringert> weird
04:56:09 <bringert> oh, right
04:56:19 <bringert> the sticky bit does not fix permissions
04:56:27 <bringert> only group ownership
04:56:40 <bringert> so it must have been a posthook problem
05:01:40 <matthew_-> how do I make an expression strict?
05:01:50 <bringert> seq
05:01:54 <bringert> or a bang pattern
05:01:58 <bringert> or case
05:02:43 <matthew_-> can you put bangs is method signatures?
05:02:48 <matthew_-> s/method/function/
05:04:08 <kolmodin_> matthew_-: no
05:04:10 <_roconnor> The lambda-bar-mu-mu-tilde calculus seems pretty cool.
05:04:47 <roconnor> mabye I'll stop using the lambda calculus
05:05:04 <roconnor> and start using more mu and mu-tildes
05:06:56 <xpika__> can anyone get this to work? grid = do (x,y,z) <- liftM3 (,) list list list
05:07:18 <xpika__> i dont mind it its changed to an []
05:07:32 <roconnor> xpika__: what do you want to do with x y and z?
05:08:08 <roconnor> (I assume you mean liftM3 (,,) ...)
05:08:12 <xpika__> before i had it:  grid = do (x,y) <- liftM3 (,) list list
05:08:22 <xpika__> ok ill try that
05:08:44 <roconnor> @type (,)
05:08:46 <lambdabot> forall b a. a -> b -> (a, b)
05:08:49 <roconnor> @type (,,)
05:08:51 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
05:08:56 <xpika__> thanks!!
05:10:07 <roconnor> normally I think I would write do x<-list; y<-list; z<-list ...
05:10:13 <xpika__> works life a charn
05:10:21 <roconnor> and just skip the tupples
05:10:32 <roconnor> @spell tupples
05:10:33 <lambdabot> tipples tuples topples tipplers tuple's
05:10:37 <roconnor> tuples
05:10:48 <xpika__> roconnor: thats what i hink but this is more concise
05:12:23 <xpika__> I snicker when i see java programmers write there algorithms with forloops in forloops in forloops
05:13:43 <roconnor> the list monad is pretty great for backtracking algorithms.
05:14:14 <xpika__> is there any function (\f x -> f x x x)
05:14:28 <xpika__> @pl (\f x -> f x x x)
05:14:28 <matthew_-> is newtype strict ? (newtype Foo = Foo Blah) == (data Foo = Foo !Blah) ?
05:14:29 <lambdabot> join . join
05:14:33 <xpika__> ooh
05:14:33 <ivanm> pl \ f x -> f x x x
05:14:37 <xpika__> sexy
05:14:41 <ivanm> @pl \ f x -> f x x x
05:14:41 <lambdabot> join . join
05:15:05 <ivanm> oh, xpika__ beat me to it :(
05:15:30 <xpika__> (join . join) ((+ .).(+)) 1
05:15:31 <roconnor> matthew_-: newtype is strict
05:15:34 <xpika__> > (join . join) ((+ .).(+)) 1
05:15:35 <lambdabot>  Parse error
05:15:59 <matthew_-> roconnor: tnx
05:17:05 <xpika__> @index join
05:17:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:17:13 <merritt> something unrelated: is it possible to define one function that takes the first element of a n-tuple, irregardless of what n is?
05:17:58 <merritt> (actually, i just need one with f (x,y,z) = x and f (x,y,z,w) = x ...)
05:18:20 <roconnor> merritt: nope
05:18:28 <merritt> :(
05:18:37 <roconnor> it's not so bad
05:19:00 <xpika__>  (join.join) (((+).).(+)) 1
05:19:02 <xpika__> >  (join.join) (((+).).(+)) 1
05:19:02 <roconnor> but you don't want to be using tuples anyways
05:19:04 <lambdabot>  3
05:19:09 <roconnor> best to make a new data type
05:19:10 <xpika__> @pl (join.join) (((+).).(+)) 1
05:19:11 <lambdabot> 3
05:19:17 <xpika__> @pl (join.join) (((+).).(+))
05:19:18 <lambdabot> join (((+) .) =<< (+))
05:19:47 * merritt hates windows...
05:20:04 <roconnor> but you don't want to be using tuples anyways
05:20:07 <roconnor> best to make a new data type
05:20:30 <merritt> i have only 3-tuples and 4-tuples of a fixed type
05:21:05 <merritt> i don't want to have a new data type for everything where i don't really need one..
05:21:43 <roconnor> merritt: Well, if you insist, you can make a function foo :: Either (a,b,c) (a,d,e,f) -> a
05:21:57 <roconnor> @djinn Either (a,b,c) (a,d,e,f) -> a
05:21:58 <lambdabot> f a =
05:21:58 <lambdabot>     case a of
05:21:58 <lambdabot>     Left (b, _, _) -> b
05:21:58 <lambdabot>     Right (c, _, _, _) -> c
05:22:10 <merritt> that's what i'm looking for :) thx!
05:22:42 <roconnor> Well, I still think you are making a mistake.  But give it a go anways.
05:23:51 <merritt> yup. (i often want to do dangerous things. it's good haskell doesn't allow them ;) anyway thanks again
05:24:21 * Botje is starting the ghc 6.6 build _now_
05:24:37 <Botje> let's see if it finishes before midnight (10 hours from now)
05:26:49 <merritt> (actually, doing dangerous things in undangerous contexts should be allowed..)
05:27:34 <Botje> unsafePerformIO should totally pop up a dialog asking if you're sure.
05:28:08 <roconnor> Botje: but the big question is, when does such a dialog appear?
05:28:11 <xpika__> Botje: what OS you running?
05:28:24 <Botje> xpika__: Gentoo Linux, atm
05:28:45 <Botje> roconnor: 5 seconds after you turn off the monitor while waiting for the job to complete, obviously.
05:29:43 <amiddelk> Botje: #gentoo-haskell
05:30:26 <Botje> is that channel specific for building ghc on gentoo?
05:30:35 <Botje> and/or modules?
05:30:43 <int-e> #gentoo-haskell
05:30:50 <int-e> I suppose.
05:31:29 <Botje> oh
05:31:45 <Botje> i'm going to finish SPJones' "implementation of functional programming languages" first, I think
05:31:49 <Botje> i'm down to the last 30 pafges
05:32:20 <xpika__> is mark the brother of Simon?
05:36:04 <njd> @users
05:36:04 <lambdabot> Maximum users seen in #haskell: 322, currently: 285 (88.5%), active: 45 (15.8%)
05:36:31 <Botje> @yow
05:36:31 <lambdabot> I'm young ... I'm HEALTHY ... I can HIKE THRU CAPT GROGAN'S LUMBAR
05:36:32 <lambdabot> REGIONS!
05:41:50 <pjd_> wow, nifty join composition
05:44:55 <matthew_-> how can I pursuade Ghc to pass values between functions unboxed given that they're not in a field?
05:45:55 <SamB> with seq in a guard on a fake body?
05:45:57 <int-e> hmm, make the argument strict.
05:46:21 <int-e> what SamB said, or use a bang pattern if you can rely on a recent enough ghc.
05:46:40 <matthew_-> err, bang pattern on a function? how?
05:47:33 <int-e> f :: Int -> Int -> Int; f !a !b = if a == 0 then b else a -- will make f strict in a and b; ghc will unbox the arguments.
05:47:59 <matthew_-> mmm. ghc doesn't seem to like me doing that
05:48:07 <matthew_-> 6.6
05:48:21 <matthew_-> Board.hs:125:15: Illegal bang-pattern (use -fbang-patterns)
05:48:23 <int-e> you need -fbang-patterns I think
05:48:26 <matthew_-> I guess that'd be the clue!
05:48:27 <int-e> as it says :)
05:48:49 <matthew_-> cheers
05:49:00 <matthew_-> is bang patterns dangerous in any way?
05:49:04 <int-e> more portably, you can use   f a b | a `seq` b `seq` False = undefined  as the first line of the function definition.
05:49:29 <int-e> they're strictness annotations, they can prevent lazyness.
05:49:34 <matthew_-> indeed
05:49:45 <matthew_-> any reason why it's not in glasgow-exts?
05:49:54 <int-e> otherwise, no they aren't dangerous
05:50:27 <int-e> because the glasgow-exts option is too coarse, I think, so newer features don't get added to that anymore
05:51:05 <matthew_-> right. ok. Thank you
05:52:37 <matthew_-> once it's unboxed, if you pass that value to another function which isn't banged, will ghc rebox it?
05:52:51 <int-e> of course
05:53:16 <matthew_-> ahh. So the bangs need to follow the value round then. ok, I guess that makes sense
05:53:30 <int-e> you could explicitely unbox the function (declare  f :: Int# -> Int# -> Int#) but that's less portable and you'd have to box and unbox yourself.
05:54:10 <matthew_-> but if it's an unexported function then ghc should be able to work out what calls the function receives and if they're all from unboxed sites then shouldn't it be safe to propogate the unboxedness?
05:54:16 <int-e> so relying on the compiler to do it for you seems to be the better approach.
05:55:30 <int-e> it's better to think in terms of strictness; the unboxing is just a consequence of that (an additional optimization by the compiler). the strictness analyser will propagate that if it's obvious that the function is indeed strict.
05:55:53 <int-e> I don't know how clever it is exactly :)
05:56:29 <int-e> in case of doubt you can try to decipher the generated core (-ddump-core) which will make clear (ahem) what's getting unboxed and what not.
05:56:38 <moonlite> could you make a Monad instance of the parser mentioned in Hughes Arrows paper? This is the type: newtype Parser s a = P ([s] -> Maybe (a, [s]))
05:56:54 <int-e> or is it -ddump-simpl? I forgot :)
05:57:43 <matthew_-> int-e: yeah, I'm using dump-simpl a lot right now to see where the unboxing is happening
05:58:29 <xpika__> @pl (\x y z -> (vertex (Vertex3 (x::GLfloat) y z))
05:58:30 <lambdabot> (line 1, column 47):
05:58:30 <lambdabot> unexpected end of input
05:58:30 <lambdabot> expecting variable, "(", operator or ")"
05:58:41 <xpika__> @pl (\x y z -> (vertex (Vertex3 (x::GLfloat) y z)) )
05:58:42 <lambdabot> ((vertex .) .) . Vertex3 . (:: GLfloat)
05:58:59 <xic> yay opengl :)
05:59:00 <xpika__> @pl (\x y z -> (vertex (Vertex3 (x::GLfloat) y z)) ) a a a
05:59:00 <lambdabot> vertex (Vertex3 (a :: GLfloat) a a)
06:00:20 <xpika__> to pl'fy or not to pl'fy. That is the question. hmmm.
06:05:12 <xic> is there a Text.Html for Html 4 transitional?
06:13:07 <xic> can Either be used like Maybe as a monad?
06:13:37 <roconnor> return 5 :: (Either Int String)
06:13:41 <roconnor> > return 5 :: (Either Int String)
06:13:42 <lambdabot>   add an instance declaration for (Num String)
06:13:48 <roconnor> > return 5 :: (Either String Int)
06:13:50 <lambdabot>  Right 5
06:14:02 <roconnor> > fail "boom" :: (Either String Int)
06:14:03 <lambdabot>  Left "boom"
06:14:22 <roconnor> (Either String) is a monad.
06:14:34 <chessguy> 'morning haskellers
06:14:41 <xic> hm.... I need Either a b
06:15:47 <roconnor> I think you will need to make your own monad instance then?
06:15:52 <roconnor> @instances Monad
06:15:54 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:16:06 <roconnor> > return 5 :: (Either Int Int)
06:16:07 <lambdabot>   add an instance declaration for (Error Int)
06:16:07 <lambdabot>     In the expression: return 5...
06:16:44 <roconnor> ah right (Error e) => (Either e) is a Monad I guess
06:16:49 <roconnor> @i Error
06:16:50 <lambdabot> Maybe you meant: id index instances instances-importing irc-connect . v
06:16:56 <roconnor> @info Error
06:16:57 <lambdabot> Error
06:17:01 <roconnor> thanks
06:17:14 <roconnor> @src Error
06:17:15 <lambdabot> class Error a where
06:17:15 <lambdabot>     noMsg  :: a
06:17:15 <lambdabot>     strMsg :: String -> a
06:18:49 <roconnor> @instances Error
06:18:50 <lambdabot> IOError, [Char]
06:19:08 <roconnor> > return 5 :: Either IOError Int
06:19:10 <lambdabot>  Right 5
06:19:20 <roconnor> > fail "boom" :: Either IOError Int
06:19:22 <lambdabot>  Left user error (boom)
06:25:42 <chessguy> @check 1 : [] == [1]
06:25:44 <lambdabot>  OK, passed 500 tests.
06:26:07 <roconnor> @scheck 1 : [] == [1]
06:26:08 <lambdabot>   Completed 1 test(s) without failure.
06:27:17 <chessguy> hmmm, since one of the benefits of haskell is the ease of reasoning about it (thanks to purity), would it be that hard to automate some formal proofs of equality certain kinds of expressions?
06:27:28 <chessguy> s/equality/equality of/
06:28:52 <chessguy> maybe it's too early in the morning to ponder such things
06:33:34 <chessguy> can't most everything be broken down to lambdas anyway?
06:34:16 <edwinb> chessguy: you mean something like 'Sparkle' does for Clean?
06:35:05 <chessguy> dunno
06:35:21 <chessguy> i don't know anything about clean
06:35:26 <pejo> chessguy, many program transformations are proven correct, and they usually take one expression and replace it with another one.
06:35:45 <pejo> (deforestation, short cut deforestation, Generalized partial computation, ..)
06:36:59 <pejo> chessguy, space leaks are still hard to reason about if you ask me, but others in this channel seem to think that it's not very hard.
06:37:37 <pejo> (Or you could use Sands improvement theory for call-by-need, that seems to guarantee asymptotic complexity doesn't get worse from my quick glance).
06:37:37 <xpika__> @index cube
06:37:38 <lambdabot> bzzt
06:38:12 <roconnor> lamba -> functions, mu -> callcc, mu-tilde -> let expressions
06:39:42 <roconnor> this paper I'm reading seems to suggest callcc is safe (pure) if you can only refer to the inner most context created.
06:40:00 <pejo> chessguy, Liu & Stoller have some work done on that too. Partly through incrementalization (maybe their work is just for cbv, I'm not sure), but they also have something across object boundaries.
06:40:30 <roconnor> of course, seq totally screw up everything in Haskell doesn't it?
06:40:31 <pejo> chessguy, think the object paper is from 2005, the incrementalization ones somewhat earlier (2003 and before?).
06:42:30 <edwinb> chessguy: sparkle is just a tool that allows equational reasoning about clean programs. Not that I've used it, but it sounds quite nice.
06:42:59 <pejo> edwinb, does the program prove operational equivalence, or is the user supposed to do that?
06:43:10 <edwinb> no, it's user directed
06:43:40 <edwinb> I imagine it could do some magic automated stuff. I don't know much about it though, other than its existence
06:44:55 <ski> roconnor : which paper ?
06:45:20 <roconnor> http://www.cs.unibo.it/~sacerdot/PAPERS/mkm2005_lambdabarmumutilde.pdf
06:45:24 <lambdabot> http://tinyurl.com/29a8a9
06:45:42 <roconnor> I suppose people who know that lambda-mu calculus already understand some of this stuff
06:46:22 <pejo> edwinb, hm. Is it the (informal) class of fold/unfold transformations you can do?
06:46:45 <xic> is ghc smart enough to eliminate array bounds checking?
06:47:39 <edwinb> pejo: not sure what you mean there...
06:47:51 <edwinb> ah, here it is. http://www.cs.ru.nl/Sparkle/
06:47:52 <lambdabot> Title: Sparkle: a theorem prover for Clean
06:48:29 <Igloo> xic: No
06:48:42 <roconnor> I suppose I won't be able to understand the main paper entitled: Séquents qu'on calcule: de l'interprétation du calcul des séquents comme calcul de lambda-terms et comme calcul de stratégies gagnantes.
06:48:49 <xic> Igloo: not in any case?
06:49:58 <pejo> edwinb, was thinking of the Burstall&Darlington article from the 70's.
06:50:04 <Igloo> xic: I don't think it would do it in any useful case
06:50:11 <ski> (roconnor : since it is french ??)
06:50:28 <roconnor> ski: that is my concern
06:50:46 <xic> Igloo: too bad :'( especially since there doesn't even seem to be an usafe read of pure arrays
06:51:03 <Igloo> There is one
06:51:07 <roconnor> @hoogle unsafeRead
06:51:09 <lambdabot> No matches found
06:51:19 <roconnor> @hoogle read
06:51:20 <lambdabot> Prelude.read :: Read a => String -> a
06:51:20 <lambdabot> Text.Read :: module
06:51:20 <lambdabot> Prelude.Read :: class Read a
06:51:24 <Igloo> :t Data.Array.Base.unsafeRead
06:51:24 <roconnor> hmm
06:51:27 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => a i e -> Int -> m e
06:51:44 <Igloo> Oh, sorry, that's the wrong one
06:52:03 <dblhelix> @hoogle (r -> m t) -> (t -> m s) -> r -> m s
06:52:04 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
06:52:04 <lambdabot> Control.Parallel.Strategies.(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
06:52:04 <lambdabot> Control.Parallel.Strategies.(-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
06:53:06 <Igloo> :t Data.Array.Base.unsafeAt
06:53:08 <lambdabot> forall e (a :: * -> * -> *) i. (Data.Array.Base.IArray a e, Ix i) => a i e -> Int -> e
06:55:17 <ski> roconnor : hm .. where in the paper did you think that it seemed "to suggest that callcc is safe if you can only refer to the inner most context created" ?
06:57:24 <roconnor> ``The “intuitionistic” fragment of the calculus, i.e. the fragment that is Curry-Howard isomorphic to the intuitionistic sequent calculus, is obtained by a simple syntactic restriction: only one environment variable is allowed''
06:57:53 <ski> page ?
06:58:00 <roconnor> 7
06:58:26 <roconnor> It is a bit of a leap from that statement to my statement
06:59:02 <roconnor> but it suggests that such sequent calculi proofs can be translated to natural deduction proofs
06:59:17 <roconnor> and natural deduction proofs are lambda terms
06:59:24 <ski> that seems to be more or less the same as LJ is the restriction of LK, where you allow at most one conclusion
06:59:32 <roconnor> Of course fix point operators, etc. could destroy everything
06:59:47 <roconnor> ski: exactly.
06:59:56 <xic> Igloo: what happens if i do go out of bounds with an unsafe read?
07:00:13 <roconnor> xic: segfault if you are lucky
07:00:17 <ski> (which i thought was wellknown)
07:00:24 <roconnor> xic: reformating your hard disk if you are not lucky
07:00:38 <Igloo> xic: The same as if you did in C
07:00:46 <roconnor> ski: it is well knows, but the connection to callcc isn't so well known I guess.
07:00:59 <roconnor> known
07:02:04 <glguy> !say still alive
07:02:05 <hpaste> still alive
07:02:06 <roconnor> variable binding becomes a lot easier when you are only allowed to have one variable name.
07:02:23 <ski> 'callcc' requires (right-)contraction .. and iirc, that calculus doesn't allow that, if you restrict to at most one conclusion
07:04:26 <roconnor> does right contraction make any sense when you have only one conclusion?
07:04:53 <ski> it doesn't
07:05:29 <ski> (hmmf .. s/conclusion/continuation variable/ i actually meant)
07:05:56 <roconnor> So the idea is that you may be able to add a restricted callCC that only allows calling back to the most recent context.
07:06:09 <roconnor> this wouldn't give you any additional programming power
07:06:12 <ski> (i was thinking it meant the same .. but there's a small difference .. don't recall if it makes a difference in this calculus, though)
07:06:21 <roconnor> but it would allow you to be more flexible in how to write your functions.
07:06:42 <ski> what type would you have for 'callCC' ?
07:07:08 <ski> peirce ?
07:07:15 <ski> double-negation elim ?
07:07:53 <ski> (my remark about contraction was for the 'peirce' variant)
07:07:56 <roconnor> ski, good question.  I assume the paper tells me.  I suppose contexts get their own class of types.
07:08:31 <ski> callCC_peirce :: ((a -> b) -> a) -> a
07:09:06 <ski> callCC_ElimNotNot :: Not (Not a) -> a
07:09:49 <ski> (the latter possibly isn't called 'callcc' so often .. but it's a bit related .. so you could have meant that)
07:10:40 <roconnor> So you would write u *:T .  ... <expr|| expr o *> ...
07:10:46 <roconnor> u is a binder like \
07:10:52 <roconnor> execpt the variable is always called *
07:11:07 <ski> is that 'mu' ?
07:11:09 <roconnor> and then there is this straing <expr||expr>
07:11:14 <roconnor> strange
07:11:19 <ski> hehe
07:11:23 <ski> it's a jump
07:11:41 <ski> <value||continuation>
07:11:46 <roconnor> oh
07:11:48 <ski> a cut, if you like
07:11:52 <roconnor> so there you go :)
07:12:29 <roconnor> so both lambda variables and mu variables have types, but they mean different things
07:12:37 <ski> they mean dual things
07:12:37 <roconnor> one is the type of the term, the other is the type of the hole
07:12:40 <ski> right
07:13:15 <roconnor> I want to practice programming like this, to get a feel for how it works.
07:13:23 <bakert> I have a String.  Associated with this String is a module.  I want to call the login function from the specified module.  Is there an easy, or even a difficult way?  What about if I have a list of String, something pairs somewhere?
07:14:16 <xerox> bakert: can't you use types directly instead of strings and module names?
07:14:29 <mux> bakert: I think you need hs-plugins in that case
07:14:30 <ski> Gamma |- e : tau | Delta   Gamma | c : tau |- Delta
07:14:31 <ski> ---------------------------------------------------
07:14:31 <ski> Gamma |-{c ^ e}- Delta
07:14:38 <bakert> Sadly no.  Ultimately it has come from the database.
07:14:43 <mux> bakert: unless of course you can do it like xerox suggests
07:14:46 <ski> roconnor : the cut rule probably looks something like that
07:14:56 <Cale> bakert: er... you mean you want to compile and load a module with that name, and get the string from it?
07:15:17 <bakert> That would be nice.  But I'm happy to aim simpler.
07:15:30 <bakert> What I really want is not to have to write this code once for each account:
07:15:34 <Cale> Look at hs-plugins.
07:15:35 <ski> roconnor : (with 'c ^ e' being their '<e || c>' and 'Delta' being a sequence of at most one continuation variable typing)
07:15:35 <bakert> website Account { acBookie = "wsex", acUsr = usr, acPwd = pwd } =
07:15:35 <bakert>     Website { wsLogin = Wsex.login usr pwd, wsFunds = Wsex.funds }
07:16:02 <Cale> Though that seems like a rather complicated way of  doing something which would otherwise be simple.
07:16:06 <bakert> That is, I want to go from the "wsex" (please ignore the unfortunate name) to Wsex,login and Wsex.funds
07:16:07 <roconnor> ski that seems more like thier o operation
07:16:36 <ski> (roconnor : though .. maybe you want to build in a weakening in the left part (i.e. s/e : tau | Delta/e : tau/) to avoid forcing 'Delta' to be empty)
07:17:10 <xerox> bakert: can't you put the string inside the Type?
07:17:18 <Cale> bakert: if you had a Map or list of them, then you could just do a lookup
07:17:22 <bakert> xerox, not quite sure what you mean?
07:17:38 <bakert> Cale, so I could have ("wsex", Wsex) and the Wsex would be a reference to the module?
07:17:40 <beelsebob> anyone with experience of Happy here?
07:17:43 <Saizan> he doesn't wont the string, he wants the login function
07:17:56 <Cale> bakert: no, the record
07:18:00 <ski> roconnor : hm .. their 'o' looks like a combination of a cut, together with left-implication
07:18:03 <xerox> emacs hid the =, sigh, nevermind.
07:18:04 <Cale> Modules aren't first-class.
07:18:15 <bakert> No I thought not.  That's my problem.
07:18:23 <Cale> They're just blocks of code which are compiled separately by the compiler.
07:18:28 <mux> I wish they were, spj has written a nice paper about a first-class module implementation in haskell
07:18:31 * edwinb hides from beelsebob
07:18:39 * beelsebob pokes edwinb in the ribs
07:18:43 <mux> s/haskell/ghc/ maybe
07:18:43 <Cale> If all you're storing are values though, and not types or instances, you should be okay.
07:18:47 <bakert> I think I will have to just write out those two lines with the module name change 23 times.
07:19:03 <bakert> (and the pattern match string)
07:19:05 <Cale> You can create a record type with definitions of the things you'd have put in the module.
07:19:31 <bakert> Cale, that sounds good.  How would I do that?
07:19:36 <beelsebob> edwinb: got any clue how to allow the parser to parse sub-parts of the syntax tree without just duplicating it?
07:19:36 <int-e> hmm, lambdabot (the non-dynamic version) has a preprocessor to create its module descriptions I think.
07:20:04 <bakert> mux, i think i'm still too much of a beginner to branch out into that kind of thing.  thanks for the info, though.
07:20:11 <Cale> well, it almost looks like you're already doing it.
07:20:16 <edwinb> beelsebob: you can give multiple starting rules, if that's what you mean
07:20:29 * ski ponders what a possible typing rule for 'o' could be ..
07:20:51 <edwinb> beelsebob: multiple %name, that is
07:21:22 <Cale> data Something = Something { login :: String -> String -> IO (); funds :: Funds }
07:21:25 <beelsebob> edwinb: but %name just specifies the name of the function, no?
07:21:34 <beelsebob> or does it parse whatever the first rule it gets is?
07:21:36 <bakert> Cale, oh!  Website is a record that has fields for login function and funds function.  I'm just trying to avoid having to type "wsLogin = Foo.login usr pwd" and "wsLogin = Bar.login  usr pwd" and "wsLogin = Baz.login usr pwd" once for each account.
07:21:57 <bakert> Cale, yes that's the definition I have basically.
07:21:59 <Cale> Oh, you might not be able to avoid that.
07:22:17 <edwinb> beelsebob: You can do %name [function] [rule]
07:22:35 <Cale> Modules aren't values, and the module path separator isn't an operator.
07:22:36 <beelsebob> ah, okay
07:22:38 <beelsebob> fair enough
07:22:44 <bakert> OK.  Well thanks Cale I'll go with what I've got.  Thanks for your help everyone at least I know it isn't dead easy now!
07:23:47 <hpaste>  beelsebob pasted "Parse error line 53" at http://hpaste.org/262
07:24:01 <beelsebob> edwinb: that causes happy to have a bit of a fit
07:24:21 <beelsebob> or does it need to be pre-%%
07:24:43 <edwinb> yes, you jsut do something like:
07:24:47 <edwinb> %name parse Program
07:24:52 <edwinb> %name parsePattern Pattern
07:25:19 <beelsebob> k
07:25:22 <beelsebob> yeh, that works
07:25:25 <beelsebob> thanks edwinb
07:25:35 <edwinb> hoorah
07:25:36 <xerox> bakert: you might use a typeclass, class Website a where login :: String -> String -> IO (); funds :: Funds; and define istances?
07:26:26 <bakert> xerox, Could do.  It doesn't allow me to automatically call login and funds from a particular module, though, does it?  In which case it's probably not worth the effort of changing.  I do need to get into typeclasses, though.
07:27:14 <xerox> It doesn't allow you to call login and funds from a particular module, but it does allow you to call login and funds for a particular type, which you can export from the module.
07:27:57 <bakert> Ah.  So have an instance declaration in each module for the overarching typeclass.  could be good.
07:28:00 <beelsebob> arse... apparently my code doesn't though... pimp: Out of cheese error, redo from start.
07:28:45 <bakert> ?hoogle maybe
07:28:46 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
07:28:46 <lambdabot> Maybe :: module
07:28:46 <lambdabot> Prelude.Maybe :: data Maybe a
07:30:27 <dcoutts> anyone want to try this for me before I announce it? : http://haskell.org/gtk2hs/gtk2hs-0.9.10.6.tar.gz
07:31:04 <dcoutts> (md5 8842898cb1f6b595b5a3a057e66a810b)
07:31:18 <trurl> dcoutts: I've compiled gtk2hs from darcs 15 minutes ago
07:31:36 <dcoutts> trurl, ok great, though that's not quite the same thing :-)
07:31:44 <dcoutts> this has another load of patches
07:31:49 <dcoutts> that I've not pushed yet
07:32:17 <trurl> ah, okay, I'll test it
07:32:30 <dcoutts> making split-objs and profiling and ghci .o versions of all libs work on all platforms isn't easy
07:33:02 <dcoutts> trurl, thanks v. much
07:34:04 <mux> dcoutts: are you interested in build-only testing?
07:34:11 <dcoutts> mux, sure
07:34:22 <mux> ok, I'll do this then
07:34:22 <dcoutts> that's were most of the recent problems have been
07:34:30 <dcoutts> generally if it links it works :-)
07:34:43 <mux> oh yeah, right, it's haskell ;-)
07:35:04 <dcoutts> ./configure --prefix=/tmp/ --with-user-pkgconf
07:35:13 <dcoutts> make; make install; make installcheck;
07:35:30 <dcoutts> that shouldn't need root perms ^^
07:37:00 <rc-1> http://blogs.nubgames.com/code/?p=15
07:37:03 <lambdabot> Title: Nub Games » Haskell &#8212; First Impressions
07:37:30 <xic> dcoutts: i can try this
07:37:42 <dcoutts> xic, cheers
07:38:35 <musasabi> How does one write a record-style GADT with class constraints?
07:39:00 <musasabi> data Foo a where C "Show t =>" { foo :: t } :: Foo t
07:39:15 <musasabi> where to put that "Show t"?
07:41:06 <xic> dcoutts: configure succeeded.... building.....
07:41:53 <musasabi> ah found it. Show t => C { foo :: t } :: Foo t
07:43:01 <musasabi> hmm. does not work.
07:43:36 <glguy> Did anyone else get a chance to watch the press conference from the guys that placed the mooninites around boston?
07:43:41 <musasabi> "data T a where forall a. Eq a => D { x,y :: a } :: T a" - this seems to be exactly what the GHC parser should take.
07:44:05 <zarvok> glguy: no, how was it?  That stuff has been making me laugh all week
07:45:25 <Igloo> dcoutts, dons: Am I being dopey, or if I toForeignPtr a packed string is there no way to fromForeignPtr it without doing some maths and BS.dropping?
07:46:25 <dcoutts> Igloo, erm, let me remind myself what they do
07:47:07 <dcoutts>         fromForeignPtr,         -- :: ForeignPtr Word8 -> Int -> ByteString
07:47:07 <dcoutts>         toForeignPtr,           -- :: ByteString -> (ForeignPtr Word8, Int, Int)
07:47:45 <dcoutts> Igloo, right, fromForeignPtr takes just the ptr and length
07:47:58 <dcoutts> but toForeignPtr gives you the ptr, offset and length
07:48:00 <mux> dcoutts: build done, it suceeded without a hitch
07:48:00 <cjeris> zarvok: it's less funny than very scary to me, to see how utterly out of control and common-sense-impaired our local law enforcement agencies are
07:48:28 <mux> dcoutts: this was on FreeBSD 6 / GHC 6.6
07:48:33 <dcoutts> mux, great, thanks, did you try the make installcheck btw?
07:48:40 <glguy> zarvok: the press conference was hilarious, they played the news media for the scaremongers they are and completely blew them off :)
07:48:50 <dcoutts> mux, ah BSD, excellent we were lacking coverage there.
07:49:06 <mux> dcoutts: I'll update the FreeBSD port as soon as I get the time
07:49:10 <dcoutts> Igloo, so actually I don't think you can round trip it.
07:49:11 <kolmodin_> I've been fighting with java and profiling all day, this weekend she sleeps on the couch! I'll meet her on monday again and hopes she'll be more reasonable. :/
07:49:16 <mux> err, I didn't do the installcheck thing, sorry :-)
07:49:30 <mux> and I already removed the build directory
07:49:38 <dcoutts> mux, no worry :-) it'll probably work
07:49:55 <dcoutts> mux, I mainly wanted to know that the splig-objs trickiness works
07:50:05 <glguy> Next week will be moving to a new release of Webtimesheet.
07:50:06 <glguy> We will not be moving the existing data into the new version.
07:50:06 <glguy> Please have you time entered in on Monday for W/E 2/3.
07:50:06 <glguy> If you enter you time in for next week 2/5, you will have to reenter it in the new system.
07:50:09 <glguy> The plan is to switch the link on the intranet on Tuesday.  If you have a shortcut, you will have to change it.
07:50:12 <glguy> Any questions, let me know.
07:50:14 <glguy> fawk
07:50:15 <kolmodin_> dcoutts: so it builds faster now?
07:50:16 <mux> dcoutts: what is that for ?
07:50:17 <glguy> sorry
07:50:20 <dcoutts> Igloo, since there's no way to set the offset with fromForeignPtr, it assumes 0
07:50:36 <glguy> we are switching to new TPS reports...
07:50:41 <dcoutts> mux, the split-objs? it makes the final binaries much much smaller
07:50:48 <mux> good
07:51:04 <dcoutts> mux, the gtk2hs hello world program is now only 30% bigger than the trivial console one.
07:51:25 <dcoutts> kolmodin_, no, mux just has a very fast machine I guess :-)
07:52:14 <Thunder> developers should have the slowest machines available.
07:52:20 <xerox> http://www.theregister.com/2007/01/25/single_photon_storage/
07:52:23 <xerox> :O
07:52:30 <dcoutts> it takes 25 min to build for me
07:52:41 <mux> core 2 duo with 2 gigs of RAM :-)
07:52:51 <mux> and SATA disks
07:52:52 <dcoutts> lucky you :-)
07:53:01 <mux> offered by new company :-P
07:53:06 <dcoutts> I've just got a new dual core amd64 but not installed it yet
07:53:14 <mux> (it's a laptop)
07:53:20 <dcoutts> Thunder, yeah, trying on slow machines can be a humbling experience
07:53:25 <mux> it kicks my home desktop big time
07:53:26 <pejo> mux, sounds like a mac? ;)
07:53:32 <mux> nope, dell
07:53:35 * Thunder works on a P133, 128MB
07:53:36 <glguy> What is a "functional pointer"
07:54:33 <dcoutts> Thunder, wow, that's even slower than my 500Mhz sparc
07:56:05 <tuukkah> dcoutts, could there be a ./configure option --user or --enable-private for passing --user to ghc-pkg?
07:56:38 <dcoutts> tuukkah, I called that --with-user-pkgconf
07:56:46 <Thunder> newest system for me. At home the modern thing is a NeXTStation, besides the Cisco down there.
07:57:10 <dcoutts> tuukkah, yeah, I'm not sure I picked the best name either :-)
07:57:11 <Thunder> Living with limits greatly improve programming output.
07:58:06 <tuukkah> dcoutts, thanks, i see the INSTALL file tells this
07:58:22 <dcoutts> tuukkah, and ./configure --help should do too
07:59:00 <dcoutts> though the INSTALL gives only the significant ones and in a more helpful order
07:59:31 <tuukkah> indeed. there was some confusion in the first gtk2hs version that i built
08:00:01 <Thunder> xerox: The real story does not tell anything about "single photon" but "single pulse of photons".
08:00:30 <xerox> Thunder: the "single photon" was really astonishing.
08:00:36 <dcoutts> tuukkah, aye, I only just updated the INSTALL and added the --with-user-pkgconf flag
08:00:58 <trurl> dcoutts: everything worked, including installcheck (ghc 6.6, Debian unstable, i686)
08:01:02 <Thunder> xerox: Nobody besides the press talks about such a thing.
08:01:09 <dcoutts> trurl, great, thanks.
08:01:46 <tuukkah> darcs version doesn't configure here (ghc 6.6, Debian testing)
08:02:37 <dcoutts> tuukkah, complaining about AC_PROG_GREP or AC_PROG_SED ?
08:02:59 <tuukkah> ./configure: line 3656: LD_X_FLAG: command not found
08:02:59 <tuukkah> ./configure: line 3672: syntax error near unexpected token `WIN32,'
08:03:00 <dcoutts> or is it just the normal debian problem of using the wrong version of automake ?
08:03:24 <tuukkah> it has worked before so i'm not sure what i'm doing wrong
08:03:33 <dcoutts> I added some stuff recently
08:03:45 <dcoutts> tuukkah, I'll look into the problems with autotools after the release
08:03:53 <dcoutts> so long as it works now with the tarball I'm happy
08:04:09 <tuukkah> i ran autoconf version 2.61
08:04:13 <dcoutts> tuukkah, but feel free to remind me about this after the release
08:04:16 <dcoutts> same here
08:04:45 <musasabi> hmm, I keep wanting a "sizeOf :: Proxy a -> (Int, Maybe Int)" in Binary - for minimum and maximum/infinite size for various types.
08:07:21 <tuukkah> dcoutts, oops, it was because i ran autoconf instead of autoreconf
08:07:40 <mux> @t minBound
08:07:41 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:07:49 <glguy> @type, or :t
08:07:51 <lambdabot> Not in scope: `t'
08:07:54 <mux> @type minBound
08:07:55 <lambdabot> forall a. (Bounded a) => a
08:07:59 <Saizan> is there a function for packing the binary representation of a number into a Word8?
08:08:02 <mux> > minBound Integer
08:08:03 <lambdabot>   Not in scope: data constructor `Integer'
08:09:03 <xerox> ?type fromInteger :: Int -> Word8
08:09:05 <lambdabot>     Couldn't match `Integer' against `Int'
08:09:05 <lambdabot>       Expected type: Int -> Word8
08:09:11 <allbery_b> > minBound :: Integer --- but Integer isn't bounded, I think
08:09:12 <lambdabot>   add an instance declaration for (Bounded Integer)
08:09:12 <lambdabot>     In the expression: mi...
08:09:13 <xerox> ?type fromIntegral :: Int -> Word8
08:09:15 <lambdabot> Int -> Word8 :: Int -> Word8
08:09:19 <xerox> Yeah.
08:09:26 <mux> oh ok
08:09:38 <mux> > minBound :: Int
08:09:41 <lambdabot>  -2147483648
08:10:08 <Saizan> xerox, i need more like an [Int] -> Word8
08:10:49 <allbery_b> that just looks odd.  you don't mean Int -> [Word8]?
08:11:01 <allbery_b> (yours seems kina lossy...)
08:11:30 <Saizan> ?type fromIntegral.snd . foldr (\x (i,acc) -> (i+1,x*2^i+acc)) (0,0) :: [Int] -> Word8
08:11:31 <lambdabot> [Int] -> Word8 :: [Int] -> Word8
08:11:50 <xerox> > (showHex (fromIntegral (minBound :: Int) :: Word8) "", showHex (fromIntegral (maxBound :: Int) :: Word8) "")
08:11:52 <Saizan> ?type fromIntegral.snd . foldr (\x (i,acc) -> (i+1,x*2^i+acc)) (0,0) [0,0,0,0,0,0,0,1]
08:11:53 <lambdabot>  ("0","ff")
08:11:54 <lambdabot>     Couldn't match `a1 -> (a, b)' against `(a2, b1)'
08:11:55 <lambdabot>       Expected type: a1 -> (a, b)
08:12:04 <Saizan> ?type fromIntegral.snd . foldr (\x (i,acc) -> (i+1,x*2^i+acc)) (0,0) $ [0,0,0,0,0,0,0,1]
08:12:07 <lambdabot> forall b. (Num b) => b
08:12:12 <xerox> Saizan: ah, I see.
08:12:12 <Saizan> > fromIntegral.snd . foldr (\x (i,acc) -> (i+1,x*2^i+acc)) (0,0) $ [0,0,0,0,0,0,0,1]
08:12:14 <lambdabot>  1
08:13:03 <Saizan> allbery_b: yes it would, but i've to pack 8 binary digit into 1 byte
08:13:19 <allbery_b> oh
08:13:41 <glguy> Has anyone read one of the anti-patterns articles on trevion.blogspot.com and enjoyed it (who then cares to help me see what I'm missing)
08:14:13 <chessguy> anti-patterns in haskell?
08:15:33 <glguy> Haskell is the language he uses in his seemingly lousy code examples
08:16:07 <xic> dcoutts: build finished
08:16:22 <emu> bad coding practices?
08:16:35 <emu> data Shape = ... | NoShape -- instead of using Maybe?
08:16:40 <glguy> yeah, that guy
08:16:54 <glguy> I wanted to hear someone say that it wasn't incoherent rambling
08:17:05 <emu> i don't think that's incoherent
08:17:17 <xerox> Saizan: you should roll up your own it seems
08:17:19 <emu> not really ground breaking
08:21:27 <allbery_b> > showHex (foldl (\a v -> (a `shift` 1) .|. (v .&. 1)) 0 [0::Word8,1,1,0,1,1,0,1]) "" -- no attempt at optimized or "nice"
08:21:29 <lambdabot>  "6d"
08:22:41 <allbery_b> @pl \a v -> (a `shift` 1) .|. (v .&. 1)
08:22:42 <lambdabot> (. (.&. 1)) . (.|.) . (`shift` 1)
08:23:24 <mauke> @hoogle a -> [a] -> Int
08:23:25 <lambdabot> No matches, try a more general search
08:23:42 <emu> one thing i really like about haskell is that oftentimes the most simple or natural way to write a functional program turns out to be the best way too
08:23:52 <mauke> @hoogle (a -> Bool) -> [a] -> Int
08:23:53 <lambdabot> No matches, try a more general search
08:23:55 <emu> he sorta points that out in a roundabout fashion
08:24:30 <xerox> ?type (length .) . filter
08:24:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
08:28:35 <emu> is ghc capable of figuring out that: ((([1] ++ [2]) ++ [3]) ++ [4]) is the same as 1:2:3:4?
08:28:48 <emu> 1:2:3:4:[] sorry
08:29:24 <rahikkala> > ((([1] ++ [2]) ++ [3]) ++ [4]) == 1:2:3:4:[]
08:29:26 <lambdabot>  True
08:29:29 <rahikkala> ;)
08:29:33 <xic> @seen dcoutts
08:29:34 <lambdabot> dcoutts is in #happs, #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 25m 6s ago.
08:29:35 <emu> i meant, compile-time
08:29:45 <emu> for any values
08:30:53 <glguy> are you intentionally putting the parentheses around the wrong way to make it harder for GHC?
08:31:16 <emu> yes, it's the order his getTokens' function does things
08:31:25 <emu> or whatever its called
08:32:17 <ski> :t getTokens'
08:32:24 <lambdabot> Not in scope: `getTokens''
08:32:33 <emu> we're talking about a silly blog post
08:32:57 <glguy> emu: that was just a poor way to write the function
08:33:02 <glguy> I don't think that GHC will compensate for it
08:34:21 <emu> i agree the function sucked
08:34:38 <emu> however i was curious if ghc could collapse those nested appends
08:35:13 <glguy> > let cleanEnd = flip (foldr aux (const [])) id; aux ' ' = (. (. (' ':))); aux x = flip id . (x :) . ($ id) in cleanEnd "I doubt that it could do that based on compile time inputs    "
08:35:18 <lambdabot>  "I doubt that it could do that based on compile time inputs"
08:39:48 <Saizan> do you think that comonadic zippers are prone to consume much memory?
08:49:21 <ski> Saizan : hm ?
08:49:53 <nomeata> Will ghc optimize something like “fromMaybe "default" . lookup ...” to not create the Maybe value, but return the default right away if nothing is found and the match if something is found?
08:50:12 <nomeata> And can I see what ghc does when it’s optimizing?
08:51:29 <Binkley> nomeata: that would be called "unboxing"
08:51:33 <emu> does darcs deal with line-ending conversion well?
08:51:39 <roconnor> nomeata: it's probably best not to sweat the small stuff.
08:51:43 <Binkley> GHC does it for types that only have one constructor, but not types like Maybe that have more than one constructor
08:51:58 <Binkley> roconnor: actually, that would probably be a significant optimization if we knew how to do it
08:52:08 <Saizan> ski: have you read sigfpe's "evaluating Cellular Automata is comonadic"? i'm basically doing that on a 500x300 plane, and it goes up to 200mb of ram
08:52:12 <roconnor> Binkley: agreed
08:52:24 <emu> Saizan: 200mb at once, or total?
08:52:26 <Binkley> nomeata: in any case, the manual talks about how to read the intermediate representation of your code. but I'd agree with roconnor in that it's best not to sweat it
08:52:38 <Binkley> or at least, not to sweat it until you know your code is correct and you're looking for bottlenecks
08:52:50 <Saizan> emu: at once, but it fluctuates much
08:53:04 <nomeata> roconnor: I’m just curious how much ghc does
08:53:12 <roconnor> Haskell isn't known for generating the fastest code in the world ... maybe it's just me
08:53:32 <Binkley> nomeata: GHC should do unboxing pretty well when it comes to single-constructor types. but it doesn't do the optimization you suggested at all, unfortunately
08:53:39 <Binkley> the implementation wouldn't be straightforward
08:53:39 <nomeata> maybe it’s just me. but maybe it’s just Maybe
08:53:41 <nomeata> (SCNR)
08:53:58 <Binkley> roconnor: well, we're working on it
08:54:10 <nomeata> Binkley: but it’s similar to list fusion, isn’t it?
08:54:21 <Binkley> nomeata: I don't think it is, but can you elaborate?
08:54:32 <Binkley> maybe it is similar and I'm not seeing how
08:54:40 <roconnor> fromMaybe is a catamorphism isn't it?
08:54:51 <roconnor> the foldr of the Maybe world
08:54:53 <nomeata> Binkley: maybe I don’t know what list fusion is :-). but one function generates a container, and the next is deconstructing it.
08:55:00 <Binkley> roconnor: true, but GHC only does shortcut deforestation for lists, as far as I know
08:55:03 <ski> Saizan : have read it briefly, but not digested it fully yet
08:55:07 <nomeata> so the container can be skipped.
08:55:08 <Binkley> nomeata: ah, yes, I think you have a point
08:55:22 <Binkley> but as it is, GHC only has rewrite rules that implement shortcut deforestation (fusion, that is) for lists
08:55:37 <roconnor> I'd use fromMaybe like you write, and then wait 10 years for an optimising compiler to make it go fast ;)
08:55:40 <Binkley> now, you *could* add your own rewrite rules that would do shortcut deforestation for other types
08:55:49 <Binkley> do you know the "Playing By The Rules" paper?
08:55:55 <nomeata> nope
08:56:00 <Binkley> roconnor: I don't think we're going to have to wait 10 years :-)
08:56:08 * nomeata is not yet into haskell compiler writing :-)
08:56:14 <roconnor> oh really?  How many years?
08:56:17 <Binkley> http://citeseer.ist.psu.edu/464822.html
08:56:19 <lambdabot> Title: Playing by the Rules: Rewriting as a practical optimisation technique in GHC - J ...
08:56:19 <roconnor> that's exciting
08:56:29 <nomeata> thx
08:56:32 <Binkley> nomeata: the point of the rules feature is that you don't quite have to be a compiler writer to use it
08:56:45 <pejo> roconner, Gill sketches on how to extend things in his thesis. Chitil has things there too. So basically we're just waiting for someone to implement it. ;)
08:56:54 <Binkley> roconnor: well, I guess I meant more in general; I think GHC is doing pretty well already
08:56:55 <nomeata> is it implemented or just a plan for the future?
08:57:08 <Binkley> nomeata: it's implemented, see the section on rewrite rules in the manual
08:57:16 <roconnor> Binkley: well, you know my experience with shift ;)
08:57:31 <ski> 'shift' ?
08:57:37 <Binkley> roconnor: well, yes. but I think there's a lot of progress happening, especially given that more people are working on GHC
08:57:37 <dmhouse> Morning everyone! :)
08:57:42 <roconnor> OTOH, GHC does really good given the language it must process.
08:58:07 <roconnor> ski: GHC doesn't remove the bounds checks on n `shift` 6
08:58:23 <roconnor> I do a lot of shifting in my SHA-2 implementation
08:58:33 <ski> k
08:58:40 <roconnor> That is a lot of checks that 6 < 32
08:58:48 <roconnor> (yep 6 is still less than 32)
08:58:55 <Binkley> heh
08:59:05 <roconnor> ... Unless that is lifted as a common subexpression
08:59:13 <roconnor> that probably doesn't happen
08:59:16 <Binkley> well, there's this issue with CSE and laziness
08:59:27 <Binkley> I don't quite understand why, but you can't do CSE the way you'd think, because it screws up laziness
08:59:36 <pejo> Binkley, do you have anything written / any numbers / etc from the work you were doing on ghc now? (Lost track of time since I last asked, sorry if it was yesterday).
08:59:58 <Binkley> pejo: heh. the demand analysis work, you mean? or my earlier work on deforestation?
09:00:13 <pejo> Binkley, I have no idea. Last time I asked if you had any draft and you said "Not yet". :-)
09:00:22 <roconnor> ski: I could always use uncheckedShiftL, but I feel I shouldn't have to.
09:00:29 <pejo> Binkley, but it was while you were in Cambridge I asked.
09:00:29 <Binkley> heh, probably the work I was doing in the fall
09:00:34 <Binkley> yeah
09:00:42 <Binkley> No, still "not yet", but I'm going back to it
09:00:47 <pejo> Binkley, I'm interested in anything that has to do with deforestation too though.
09:00:47 <nomeata> hmm. would inlining fromMaybe do what I want? I.e., would haskell then recognize that fromMaybe just pattern-matches the two constructors, and just skip Maybe?
09:01:03 <pejo> (Or any other fold/unfold transformation).
09:01:11 <Binkley> pejo: for that, I do have my master's thesis online - http://lafalafu.com/krc/Writing/chevalier_ms_2004_type_inference.pdf
09:01:15 <lambdabot> http://tinyurl.com/2xz3xp
09:01:30 <pejo> Binkley, thank you. Will read.
09:01:34 <Binkley> nomeata: inlining could potentially work, but you always have to be careful about inlining
09:01:47 <glguy> hpaste demonstrates some interesting lazy behavior... the accounts.txt file remains open until you try to login for teh first time and it has to read it and build the Map (checked with lsof)
09:02:02 <glguy> fun to login and see the file close :)
09:02:05 <Binkley> if fromMaybe got inlined, then the case-of-case transformation would probably happen. but it's kind of pointless to speculate until you look at the intermediate code :-0
09:02:23 <Binkley> and of course, if it's not a bottleneck for you, then there's not much point in looking, unless you do want to work on improving the compiler :-)
09:02:38 <nomeata> It’s curiosity, and maybe the latter.
09:02:39 <pejo> Binkley, that case-of-case transformation isn't a part of the short cut deforestation in ghc currently though, is it?
09:02:44 <nomeata> It’s not even part of any code :-)
09:03:25 <roconnor> heh, I read that as ``chevalier vs type inference'' for some reason.
09:04:09 <Binkley> roconnor: "chevalier vs. type inference" does describe my graduate career pretty succinctly :-)
09:04:40 <Binkley> pejo: well, I may be pulling this out of various orifices, but I think the simplifier does do case-of-case, even though certainly, it doesn't do Wadler-style deforestation
09:05:07 <pejo> Binkley, from just reading the title - how is your work related to Chitil's thesis?
09:05:35 <Binkley> nomeata: well, there's nothing wrong with curiosity. see http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
09:05:37 <lambdabot> Title: 4.16. Debugging the compiler, http://tinyurl.com/t96uq
09:05:48 <Binkley> pejo: I implemented the work that Chitil described in his thesis
09:06:54 <pejo> Binkley, ah, nice.
09:07:13 <Binkley> heh
09:07:37 <Binkley> many nights spent staring at Core code and profiling reports...
09:07:46 <Binkley> "nice" for certain values of "nice", anyway :-)
09:09:13 <Binkley> er, when I said "case-of-case" earlier, I think I meant "case-on-known-constructor"
09:11:56 <csci> Hi, after a couple of hours I still did not manage to make a simple Example of functions using Monad.State and using IO and State's. (I've read through some tutorials about monads and understand >>=, return, etc... enough (at least I think so) and can also use the IO monad w/o problems) The documentation is also not so helpful, so I'd appreciate any small example programs or links to them
09:12:30 <glguy> csci: Do you have an example of what you were trying to do
09:13:22 <csci> glguy, I just want to understand them, i.e. passing a State through some calls f -> g -> h -> ii, whereby f has some x which is used by ii, and some putStrLn on the way as an addtional problem
09:13:30 <csci> I don't know how to create an initial state
09:13:43 <csci> But I know how to get and set and return them
09:13:53 <ski> do you want to use state and I/O at the same time ?
09:14:03 <glguy> csci: use the "evalState" function to load the initial state
09:14:14 <glguy> and run the State a b  value
09:14:54 <csci> I'd really like to have to examples, one with state and one without. I've stared at the docs and tutorials for two hours now but did not succeed to find one with a simple, 20 line example of the "Hello World"-equivalent of States :)
09:14:56 <glguy> > runState (do { a <- get; put (a+5); return (a - 1) }) 4
09:14:58 <lambdabot>  (3,9)
09:15:03 <beelsebob> Igloo: poke
09:15:09 <ski> main = myMain `evalStateT` 42
09:15:16 <ski> myMain :: StateT Int IO ()
09:15:37 <csci> glguy, For example. Never found such a small example :D
09:16:02 <Igloo> beelsebob: ?
09:16:10 <beelsebob> setting up a buildbot for ghc
09:16:11 <glguy> beelsebob: when are you going to tell me your bug?
09:16:28 <beelsebob> oh glguy it's to do with HsApps I think
09:16:30 <ski> myMain = do {x <- liftM2 (,) tick tick; lift (print x)}
09:16:33 <beelsebob> it can't recieve large posts
09:16:41 <beelsebob> so if you dump too much into the input it silently drops it
09:16:48 <ski> tick = do {x <- get; put (x+1); return x}
09:16:51 <glguy> beelsebob: yup, i chop it off at 5000 chars
09:16:55 <beelsebob> Igloo: I take it it's you I need to poke with Username and password
09:17:01 <beelsebob> glguy: might be good if it didn't do it silently
09:17:02 <glguy> beelsebob: I'm not interested in hosting huge pastes
09:17:05 <csci> ski, Thanks. Will try this out now but this is perfectly what I've searched for!
09:18:03 <ski> (csci : hm .. you may need type signatures on 'myMain' and/or 'tick' though ..)
09:18:45 <Binkley> glguy: maybe what beelsebob's trying to get at is that if the input is too long, there should be an error message so the user knows that their input was truncated
09:19:02 <ski> tick :: (Num a,MonadState a m) => m a
09:19:07 <glguy> Binkley: I gathered as much :)
09:19:27 <csci> ski, ok, thanks
09:23:21 <pejo> Binkley, well, since I happen to be interested in work along those lines anything that brings a greater understanding to the world is nice in my book. ;)
09:25:35 <daniel_larsson> Anyone with some HAppS knowledge around?
09:26:11 <daniel_larsson> shapr: you here?
09:26:26 <shapr> yup
09:26:31 <shapr> But I'm hiding!
09:26:39 <Binkley> pejo: :-) Thanks, it's good to hear that
09:26:40 * shapr hides under a nearby lambda
09:26:59 <shapr> daniel_larsson: God morgon, hur kan jag hjälpa dig?
09:27:00 * csci thinks, where all these lambda came from
09:27:12 * xerox operates the lambda lifter, and finds shapr hidden!
09:27:15 <shapr> Gutentag csci
09:27:20 * ski converts the lambda into a ~mu, and a cut
09:27:23 * shapr is exposed!
09:27:24 <int-e> @unpl join (*)
09:27:24 <lambdabot> ((*) >>= \ a -> a)
09:27:35 * Binkley beta-reduces the lambda and watches shapr disappear in a puff of logic
09:27:42 * shapr puffs
09:27:59 <shapr> I'm beta than you are!
09:28:00 <int-e> @unpl ((*) >>= \ a -> a)
09:28:00 <lambdabot> ((*) >>= \ a -> a)
09:28:01 * shapr grins
09:28:03 <int-e> sniff.
09:28:09 * Binkley smacks shapr around a bit with a wet lambda
09:28:18 <shapr> ooh, I didn't know you were into that kind of thing ;-)
09:28:37 <Binkley> really? I didn't know anybody *didn't* know I was into that kind of thing ;-)
09:29:05 <Binkley> Oh well, I didn't mean to bring down the tone of the channel
09:29:11 <Binkley> let's talk about bottom lifting instead
09:29:50 * psnl evalutes binkley's bottom
09:29:55 <ski> (or it's dual)
09:30:31 <shapr> @quote bottom
09:30:32 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
09:30:36 <Binkley> does my bottom look too big in this constructor?
09:30:36 <amiddelk> that puts a "black hole" in a whole different perspective ;-) :o
09:30:43 <shapr> Binkley: hehe
09:30:47 <shapr> amiddelk: eww
09:30:50 <Binkley> yes, it really makes you wonder about eager blackholing
09:30:50 * shapr grins
09:30:56 <xerox> Sigh.
09:31:20 <psnl> lets return from the inuendo monad
09:31:33 <Binkley> psnl: that would be unsafe
09:31:57 <dmhouse> ?hoogle unsafeRemoveInnuendo
09:31:59 <lambdabot> No matches found
09:32:07 <Binkley> ;...-(
09:32:28 <dmhouse> psnl: In _your_ end-o! :) (Scrubs.)
09:33:01 <psnl> I'm not letting you near my endo
09:33:03 * syntaxfree is tempted to violate the fmap law.
09:33:03 <syntaxfree> Breaking tha law, breaking tha law.
09:33:24 <Binkley> well, I heard that the Supreme Court overturned that law lately
09:33:41 <Binkley> but in Georgia, your fmaps still have to obey the properties, or they'll get you on some other trumped-up charges
09:33:52 <psnl> SimonRC: give me my meal card, or I'll put a pox on your house
09:33:58 <syntaxfree> data Counter = Counter a Int; fmap f (Counter a b) = Counter (f a) (b+1)
09:34:01 <Binkley> like violating the monomorphism restriction
09:34:04 <syntaxfree> that is so damn convenient.
09:34:14 <dmhouse> syntaxfree: why do you have to use fmap?
09:34:23 <glguy> (_Ф_)
09:34:44 <dmhouse> syntaxfree: make up a new higher-order function, one that isn't fmap, with that definition.
09:35:19 <syntaxfree> I had a very good reason for this, but my brain is full of ideas I can't quite express. As soon as I finally define (>>=) I'll hpaste.
09:35:19 <xerox> syntaxfree: make it a monad?
09:37:11 <dmhouse> What medium do people use for backups? I'm currently using my unused 1GB memory stick because it's convenient, but I dunno... DVDs seem more permanent.
09:37:27 <dmhouse> I guess that's something of a fallacy, USB's likely to be around longer than DVDs.
09:38:00 <pejo> dmhouse, anything that I want to save I put in darcs/cvs, on a backed disk.
09:38:19 <pejo> Saves the trouble of desperately looking through backups for old revisions.
09:38:35 <dmhouse> pejo: even binary files?
09:38:37 <yaxu> i have my computers taking snapshots of each other with dirvish
09:38:49 <Binkley> dmhouse: the canonical solution seems to be to have two external hard drives that mirror each other
09:38:53 <Binkley> or I guess you could use RAID
09:38:58 <Binkley> if you're into that kind of thing
09:39:03 <Binkley> but I don't have backups
09:39:11 * Binkley knocks on the nearest wooden object
09:39:13 <pejo> dmhouse, don't have that many binary files, mainly a couple of pdf's and eps'.
09:39:18 <daniel_larsson> shapr: Hej hopp :) Försöker mecka lite med HAppS. Din tutorial som du skriver, är det den i darcs?
09:39:20 <pejo> dmhouse, but they're in there, yeah.
09:39:36 <Binkley> nothing wrong with using darcs or cvs for binary files, you just don't get diffs
09:39:48 <shapr> daniel_larsson: Nej, den är inte i darcs, men det kan bli.
09:40:29 <daniel_larsson> shapr: I want to do content negotiation, but am a bit unsure how to do it best. I only started looking at HAppS today
09:40:44 <pejo> (I'm more afraid that I will remove files by accident than of a double disk failure, I have to admit).
09:40:59 <dmhouse> My other reservation regarding sticking everything in darcs is that I like to do my file manipulation from Konqueror, and doing a bunch of darcs moves doesn't sound like fun every time I want to tidy my files up a bit.
09:41:11 <Binkley> well, if you're not afraid of a disk failure, maybe you should be... I've had it happen twice
09:41:15 <Binkley> but I still don't do backups
09:42:05 <yaxu> i think dirvish is nice, stores snapshots in a filesystem so easy to browse back, but uses hardlinks for identical files so efficient if most of your files don't change
09:42:10 <dmhouse> Solid state's more reliable than a hard drive, I guess.
09:42:21 * Syzygy- waves to yaxu before dropping offline again
09:42:28 <yaxu> hello Syzygy-
09:42:40 <syntaxfree> http://hpaste.org/263
09:43:02 <pejo> Binkley, *more afraid*, not not afraid.
09:43:30 <glguy> !say alive
09:43:36 <glguy> http://hpaste.org/264
09:43:39 <glguy> syntaxfree: ^^
09:43:46 <Binkley> heh
09:44:05 <dmhouse> !help
09:44:08 <syntaxfree> aw, shucks.
09:44:10 <glguy> hpaste: connect: does not exist (Connection refused)
09:44:13 <syntaxfree> anyway, did I break the monad laws?
09:44:45 <syntaxfree> (I did know the State monad was probably the easiest way to get here. I just wanted to blog an example of a simple monad that doesn't exist)
09:44:47 <dmhouse> syntaxfree: why not check them?
09:45:03 <syntaxfree> Well, I checked.
09:45:03 <glguy> I don't think that a >>= return   will hold
09:45:12 <syntaxfree> Or I think I did.
09:46:03 <syntaxfree> bah. you're right.
09:46:21 <glguy> syntaxfree: I think you'd be better off showing newtype deriving
09:46:31 <glguy> That would seem to be much more common
09:46:40 <glguy> and also generally more useful
09:47:39 <xerox> syntaxfree: type CountT m a = WriterT Int m a
09:47:47 <syntaxfree> glguy: I was kinda checking that I actually understood monads.
09:47:52 <glguy> ah
09:47:54 <syntaxfree> I used to know this stuff better.
09:48:00 <syntaxfree> My brain's turning to mush.
09:48:28 <syntaxfree> Can't focus on one thought for long.
09:48:34 <Binkley> syntaxfree: join the club :-)
09:49:05 <syntaxfree> I spent about a month or five weeks without writing any code.
09:49:29 <syntaxfree> (curiously, or maybe syntomatically, that's also when I began coming here everyday)
09:51:20 <glguy> :t WriterT
09:51:22 <lambdabot> forall a (m :: * -> *) w. m (a, w) -> WriterT w m a
09:51:23 <Binkley> haha
09:51:34 <Binkley> yes, it's pretty easy to spend time hanging out here instead of writing code :-)
09:51:53 <daniel_larsson> shapr: Where's the tutorial now?
09:52:29 <pejo> Binkley, lest contract it some - "easy to spend time without writing code".
09:52:51 <Binkley> pejo: quite true
09:52:56 <Binkley> work is hard
09:53:03 <Binkley> let's go shopping^HIRCing
09:53:49 <shapr> daniel_larsson: http://www.haskell.org/haskellwiki/HAppS_tutorial
09:53:51 <lambdabot> Title: HAppS tutorial - HaskellWiki
09:53:55 <glguy> shapr: how can there not be routes to any of the freenode servers from your webhost?
09:54:05 <daniel_larsson> shapr: Cool, thanks!
09:55:07 <shapr> glguy: I don't know. When in doubt I use irc.se.freenode.net. Sweden is cool.
09:55:12 <SyntaxNinja> y0
09:55:16 <glguy> shapr: that doesn't work now
09:55:17 <shapr> y0 y0
09:55:21 <glguy> shapr: that's why hpaste is absent
09:55:40 <shapr> glguy: oj, det suger. Jag ska reparara(?).
09:56:00 <glguy> no habla swedish
09:56:16 <shapr> heh
09:56:23 <shapr> irc.freenode.net works for me.
09:56:28 <Binkley> y0140
09:56:40 <glguy> shapr: on what port?
09:56:44 <shapr> 6666
09:56:51 <glguy> BAH
09:57:07 <shapr> What port were you using?
09:57:27 <glguy> I was testing with 6667, BUT hpaste was using 6666
09:57:29 <glguy> somehow
09:57:33 <glguy> I wonder who changed that
09:59:52 <shapr> I think I'm going to start eating vegan.
10:00:13 <Cale> I think I'm going to start eating vegans.
10:00:15 <shapr> Is anyone here vegan and won't mind being eaten?
10:00:25 <Cale> hehe
10:00:34 <shapr> Cale: Bah, I shouldn't have waited for the punchline ;-)
10:01:08 <Binkley> shapr: maybe you should take that question to #haskell-hottub
10:01:22 <dmhouse> shapr: how come?
10:01:30 <shapr> dmhouse: How come what?
10:01:39 <dmhouse> You're going vegan?
10:01:54 <shapr> Nah, more like the other end of the scale, I want to only eat vegans.
10:02:05 <Binkley> shapr: vegandating.com
10:02:39 <shapr> Searching for: vegan and suicidal?
10:02:51 <ookk> i dont eat vegans, but i drink their milk
10:02:54 * shapr gives it up and gets back on the topic.
10:02:54 <glguy> progexp: don't want your friends to know you are visiting a Haskell channel?
10:03:08 <shapr> progexp: Hiya!
10:03:54 <Nafai> Hey shapr
10:03:55 <glguy> caution, the underside of my desk is sharper than it appears
10:04:23 <shapr> hiya Nafai
10:06:56 <daniel_larsson> shapr: Go to Umeå, lots of vegans there :)
10:08:36 <jesusphreak> Hey guys, I was wondering about the possibilties of writing a cross-platform text editor in Haskell...is that realistic?
10:08:55 <Cale> jesusphreak: sure
10:09:07 <jesusphreak> I guess my real question is what is the state of GUIs in Haskell?
10:09:07 <shapr> tmoertel: hiya
10:09:15 <bakert> jesusphreak, there's something called yi that already exists
10:09:15 <tmoertel> shapr: hi!
10:09:21 <shapr> tmoertel: How's code?
10:09:36 <tmoertel> Fine here.  How's code with you?
10:09:44 <Cale> jesusphreak: There's Gtk2Hs, which is cross-platform, last time I checked.
10:09:49 <glguy> Wie geht es dir?
10:10:17 * tmoertel will be right back after updating to ERC 5.1.4 . . .
10:11:29 <shapr> re tmoertel
10:12:46 <tmoertel> does anyone think it would be worth rewriting Reddit (in Haskell, of course) just to get rid of the "<"-escaping bug?
10:13:14 <glguy> one of the draws of reddit is that it has users
10:13:20 <Binkley> tmoertel: not *just* for that reason
10:13:27 <Binkley> but it could be a good exercise
10:14:25 <tmoertel> "Haskit"? "Heddit"?
10:14:38 <glguy> someone suggested:
10:14:41 <glguy> "Understoodid"
10:14:43 <glguy> it*
10:15:01 <bos> memoizedit
10:15:02 <jesusphreak> if one was to rewrite Reddit, you might as well do something more than just a clone
10:16:06 <glguy> I'd like to see a feature where you are punished for posting garbage blog posts
10:16:22 <bos> now now. that's called modding down.
10:16:24 <jesusphreak> the main Reddit is going down the tubes, though
10:16:25 <jesusphreak> programming Reddit isn't so bad
10:16:33 <Binkley> imminent death of Reddit predicted: film at 11
10:16:48 <jesusphreak> but main Reddit's comments are starting to be way too Diggish for me...and I'm not a fan of all the 'PHOTOS' posts
10:17:00 <tmoertel> yeah, I never look at the main reddit anymore.  can't see the signal for the noise
10:17:21 <glguy> bos: no, I don't just mean "click the down arrow if you don't like it" I mean "remove posting rights after 3 garbage , content-free, blog posts"
10:17:42 <Binkley> glguy: that's more a policy issue than a mechanism issue
10:17:46 <jesusphreak> I'm that way with both Digg and Reddit; I barely even look at them anymore...people sure know how to screw up a good thing
10:18:10 <bos> glguy: does it get under your skin that much? golly.
10:18:32 <glguy> bos: yeah, I get tired of content-free blog posts...
10:18:55 <bos> i just don't read them, or move along.
10:19:29 <glguy> I feel that they reflect poorly on the language, or at least the effort to show the language
10:19:50 <glguy> especially when teh post is just blatently incorrect
10:20:07 <bos> shrug.
10:20:37 <Binkley> glguy: oh, you mean content-free blog posts about Haskell, in particular?
10:20:41 <glguy> I just have a personal interest in people learning postive and correct things about the languages I use
10:21:02 <bos> i figure bad blog postings are good exercise for the critical reading facilities that people lack.
10:21:31 <glguy> and I don't want new users getting turned off because some bonehead thinks that he knows what he's talking about and needs to write instructions for others
10:21:35 <bos> "here's my definition of foldr, which differs from the standard definition in folding to the right, instead of from the right."
10:21:40 <Binkley> glguy: yeah, I feel that way about the mailing lists lately
10:21:44 <Binkley> but then on the other hand
10:21:51 <Binkley> there's no such thing as bad publicity, right?
10:22:07 <glguy> when you are trying to sell something...
10:22:11 <mauke> huhu, welcome to Perl
10:22:36 <mauke> now we only need a matt's script archive
10:22:41 <glguy> I don't want to sell Haskell to anyone, I just want to provide correct information to new users expressing an interest
10:22:51 <tmoertel> I'm kinda convinced -- and have come to accept -- that Haskell is never going to be a mainstream language.
10:23:10 <glguy> I have no problem with that
10:23:11 <tmoertel> Just like mathematics is never going to be a mainstream language.
10:23:27 <Binkley> glguy: well, no one's making you sell Haskell :-)
10:23:33 <tmoertel> Both are powerful tools, but they require a serious investment to use well.
10:23:44 <glguy> Binkley: so... the all publicity is good publicity line doesn't work for me, that's all
10:24:30 <dylan> tmoertel: 2 + 4 used to be considered something you teach adults. ;)
10:24:56 <Binkley> glguy: true, but I think if you don't care about selling Haskell, then there's also not too much need to trouble yourself about people having bad information
10:25:12 <pejo> tmoertel, do you mean any lazy functional language could never be mainstream, or any functional language, or something else?
10:25:22 <Binkley> because in the end, what's the difference between someone having a bad opinion of haskell and someone not knowing what it is, if there was no chance of them using it anyway?
10:25:39 <dylan> material culture always advances faster than immaterial culture, and the average curriculum of a person depends on immaterial culture.
10:26:08 <glguy> Binkley: I'd rather someone will still open to being turned onto haskell later, than be turned off earlier
10:26:09 <gour> Binkley: preaching to others?
10:27:07 <Binkley> glguy: in my experience, though, there's bad information out there no matter what
10:27:24 <Binkley> five years ago, people believed blatantly wrong things about haskell, without blog posts to help them in the process
10:27:34 <Binkley> in the end, it all comes down to who you trust
10:27:39 <Binkley> smart people trust other smart people
10:27:50 <Binkley> and won't be fooled by J. Random Blogebrity from the Interblags
10:27:58 <tmoertel> pejo: I'm leaning toward the belief that the degree of abstraction offered by Haskell (and its ilk) is similar to that of higher mathematics and thus will probably never be approachable to the mainstream.
10:29:18 <glguy> oh well, lunch time :)
10:29:20 <dylan> mainstream is not a constant, though.
10:30:13 <pejo> tmoertel, shrug. How can mechanical engineers apply so much math after just a 4,5 year degree over here, and the CS/engineering people be so bad at it?
10:31:28 <glguy> because the CS courses focus on the wrong areas?
10:31:43 <Binkley> glguy: I'm not sure whether we know what the "right areas" to focus on are
10:31:49 <Binkley> CS hasn't been around that long as a field
10:31:54 <Binkley> there's no agreed-upon curriculum
10:31:58 <glguy> Binkley: I'm not arguing that I know the "right" way
10:31:58 <pejo> glguy, still close to a year of math in the CS programme.
10:32:00 <Binkley> sure
10:32:03 <tmoertel> pejo: because mechanical engineers *use* the math and become facile with it. A lot of "CS" programs these days are biased toward producing industry programmers, who don't need to know math because they don't use it when gluing together framework bits.
10:32:34 <glguy> I agree that too many CS programs should be a 2 year vocational degree
10:32:46 <beelsebob> tmoertel: yes, but I think the point is that those courses are not teaching CS, and they're certainly not teaching CS accademically (which being an accademic institution, they should be doing)
10:33:01 <beelsebob> universitys should leave it to collages to teach vocational qualifications in programming
10:33:06 <dcoutts> xic, everything worked ok ?
10:33:10 <dcoutts> jesusphreak, I'm just about to release the latest and greatest in the world of Haskell GUIs
10:33:33 <glguy> phooey?
10:33:46 <glguy> :-p
10:33:57 <jesusphreak> dcoutts: what is that?
10:34:02 <dcoutts> release candidate of gtk2hs of course!
10:34:16 <dcoutts> jesusphreak, gimme a few minutes to do the release announcements
10:34:18 * beelsebob thinks the next version should be called gtk3hs
10:34:19 <glguy> now with 100% more support for 6.6?
10:34:23 <beelsebob> just for ammusement's sake
10:34:23 <dcoutts> yep
10:34:38 <glguy> beelsebob: the one that works with gtk+ 3?
10:35:13 <pejo> tmoertel, so chicken and egg problem then. Lets hope for some useful formalisms for the CS people, so you don't need a phd in order to make an embedded system.
10:38:32 <tmoertel> pejo: I don't see it as so much of chicken-and-egg between industry and universities.  It's industry that seems to be influencing the direction of CS programs because universities want industry money and because students want industry jobs.  So until industry changes, the situation probably will not change.
10:39:46 <tmoertel> pejo: I am glad, however, to see modern CS fruits trickle down into more-mainstream languages, e.g., C#.
10:40:02 <pejo> tmoertel, correctness is an issue in industry. If academia could provide something that the industry could use with ordinary cs graduates to build bullet proof systems quickly they would embrace it for economical reasons.
10:40:22 <tmoertel> pejo: agreed.
10:40:45 <pejo> For some reason it's only Nasa, Airbus, and a few other places who have plenty of phd's hired that use much formal methods.
10:42:27 <tmoertel> pejo: That's because the cost of errors at those places is measured in human lives.  The cost of errors at most software houses is much lower -- reboots, glitches, the occasional corrupted word-processing document.
10:43:14 <tmoertel> pejo: Thus the incentive to aim for anything beyond "approximately correct" doesn't justify the cost.
10:43:58 <malebria> Is there a function that removes a file?
10:44:09 <malebria> @hoogle FilePath -> IO ()
10:44:10 <lambdabot> Directory.createDirectory :: FilePath -> IO ()
10:44:10 <lambdabot> Directory.removeDirectory :: FilePath -> IO ()
10:44:10 <lambdabot> Directory.removeFile :: FilePath -> IO ()
10:44:14 <malebria> =D
10:44:52 <mauke> @hoogle remove
10:44:52 <lambdabot> Directory.removeDirectory :: FilePath -> IO ()
10:44:52 <lambdabot> Directory.removeFile :: FilePath -> IO ()
10:44:52 <lambdabot> Distribution.PreProcess.removePreprocessed :: FilePath -> [String] -> [String] -> IO ()
10:45:12 <pejo> tmoertel, because CS isn't at the point where it is "easy" to guarantee correctness.
10:46:27 <hpaste>  Hunter_wow pasted "randomR in IO" at http://hpaste.org/265
10:46:31 <pejo> tmoertel, the fact that things are "leaking" to C# and others is a good sign though. We must be doing something right, and at the same time getting more mainstream acceptance.
10:46:47 <daniel_larsson> shapr: Does HAppS support content negotiation in some convenient manner?
10:46:55 <tmoertel> pejo: That might be a tough nut to crack.  Even if you had a magic way of easily guaranteeing correctness, just specifying what "correct" means may require more-than-mainstream-acceptable difficulty.
10:47:08 <glguy> :t newStdGen
10:47:10 <lambdabot> IO StdGen
10:47:18 <glguy> Hunter_wow: that's already defined...
10:47:28 <Hunter_wow> aha, ok, thx, will try again then ^^
10:47:50 <glguy> Hunter_wow: but that isn't why *your* code didn't work
10:47:50 * tmoertel is getting behind of his reading: TMR 6 and "Applicative programming with effects" are in the queue
10:48:17 <benja_> hmm, does anybody know a categorical concept that is like a functor except with the direction of the function argument to fmap reversed? like this:
10:48:24 <pejo> tmoertel, maybe. The control systems people seem to have a fair idea about timing constraints, for example. Memory availability is given by the hardware. And so on.
10:48:26 <benja_> fmap' :: (a -> b) -> f b -> f a
10:48:32 <Hunter_wow> glguy: thought so, and I guess you have no idea what Im trying to do right? ^^. Not very hot on this
10:48:55 <benja_> the point would be that (f a) would be a type in which a occurs to the left of a (->)
10:49:04 <glguy> Hunter_wow: right , I don't know what you are trying to do, there isn't much that is correct about that code yet
10:49:16 <pejo> tmoertel, and type systems are one step on the way - which has spread pretty nicely. :-)
10:49:40 <glguy> Hunter_wow: let x = randomR x -- the x on the left and right ar eteh same
10:49:56 <glguy> :t randomR
10:50:01 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:50:10 <glguy> randomR takes two arguments, a range, and a generator
10:50:20 <glguy> it returns a tuple
10:50:22 <Hunter_wow> glguy am thought so, but when I changed 'x' to 'a' it said "undefined a" or something
10:50:29 <glguy> putStrLn takes a string, and not a tuple
10:50:48 <glguy> String isn't an instance of RandomGen
10:50:54 <glguy> ?instances RandomGen
10:50:55 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
10:50:58 <benja_> (Applicative Programming with Effects was one useful paper. at least for me.)
10:51:03 <glguy> oh well, it's not :)
10:51:09 <chessguy> benja_, link?
10:51:09 <tmoertel> pejo: I guess I look at it from the industry-cost side of the picture and am not enthusiastic.  The industry move toward certification programs, for example, shows that large parts of industry are not even willing to pay the bill for a traditional four-year degree; they want a less-expensive standard of entry-level ability.
10:51:10 <glguy> Hunter_wow: what are you *trying* to do
10:51:21 <benja_> chessguy: http://www.soi.city.ac.uk/~ross/papers/Applicative.html
10:51:23 <lambdabot> Title: Applicative Programming with Effects
10:51:40 <chessguy> benja_, thanks
10:52:01 <glguy> tmoertel: maybe that's just because they don't need quality software for all their projects, and mediocrity will do just fine
10:52:16 <glguy> high quality stuff is expensive , and difficult to create :)
10:52:25 <Hunter_wow> glguy: to make randomR (a,b) gen returns a pair, consisting of a seemingly random integer between a and b and a
10:52:25 <benja_> (/me was reacting to tmoertel mentioning it)
10:52:28 <Hunter_wow> I think
10:52:44 <tmoertel> glguy:  Exactly!  Even "bad" software is *much* more efficient than the next-best non-software solution.
10:53:19 <Hunter_wow> romeove last 'and a'
10:53:25 <Hunter_wow> *remove
10:53:28 <chessguy> mmmmm, depends on the domain i guess
10:53:36 <tmoertel> benja_: Did you read Gibbons's "Design Patterns as Higher-Order Datatype-Generic Programs"?  Also a good read.
10:53:42 <glguy> > let g = mkStdGen 42 in randomR (0,10) g
10:53:44 <lambdabot>  (4,1720602 40692)
10:54:03 <benja_> btw, on the off chance that somebody is interested, http://antti-juhani.kaijanaho.fi/darcs/haskell-src-exts/ has a preprocessor for syntax for applicative functors (not the syntax of in the paper)
10:54:05 <lambdabot> Title: Index of /darcs/haskell-src-exts
10:54:05 <glguy> Hunter_wow: 4 is the number in range, and 1720602 40692 is the StdGen
10:54:19 <benja_> no documentation, though, but I could write some if someone wants me to :-)
10:54:22 <Hunter_wow> aha
10:55:00 <glguy> > let g = mkStdGen 42 in let (x,g') = randomR (0,10) g; (y,g'') = randomR (0,10) g' in (x,y)
10:55:02 <lambdabot>  (4,9)
10:55:21 <glguy> Hunter_wow: see how you have to wind the generator through each call?
10:55:50 <chessguy> sounds like it's begging for a monad
10:55:59 <benja_> the syntax is that #(800 * !x + !y) is (liftA2 (\x' y' -> 800 * x' + y') x y)
10:56:01 <glguy> This need can be obviated with a State monad, (or a specific State specialization monad like MonadRandom)
10:56:11 <Hunter_wow> glguy: trying, will just have to look at it a while I think
10:56:18 <benja_> tmoertel: that sounds interesting indeed! I shall put it on my reading list, thanks :)
10:57:22 <hpaste>  glguy annotated "randomR in IO" with "pasted example" at http://hpaste.org/265#a1
11:00:38 <dcoutts> http://haskell.org/gtk2hs/
11:00:39 <lambdabot> Title: Gtk2Hs
11:00:47 <dcoutts> yay the new RC is available ^^
11:00:53 <dcoutts> jesusphreak, ^^
11:01:06 <dcoutts> oh, already syndicated to http://planet.gnome.org/news/
11:01:10 <lambdabot> Title: GNOME News
11:01:16 <jesusphreak> hanks, I will scope it out :)
11:01:19 * dcoutts waits for planet.haskell.org to sync up
11:01:20 <Hunter_wow> whell, tons of thanks glguy. I should be capabel of solve it now. Or else I come back :)
11:02:23 <chessguy> so MonadRandom is a subclass of State?
11:02:37 <newsham> dcoutts:  does hs2gtk bin have the latest gtk+ (after gtk image loading vulnerability was fixed)?
11:02:41 <glguy> MonadRandom is a newtype of State
11:02:59 <dcoutts> newsham, what version of gtk+ was that fixed in ?
11:03:34 <newsham> gtk+2.0_2.8.6
11:04:02 <dcoutts> newsham, well then all you have to do is build gtk2hs against gtk+-2.8.6 or later
11:04:04 <chessguy> that's a weird version number
11:04:16 <dcoutts> newsham, the windows installer is using the latest gtk+ version
11:04:16 <glguy> chessguy: class (Monad m) => MonadRandom m where
11:04:30 <glguy> chessguy: I'm not sure if that is called a "subclass" or not
11:04:53 <benja_> oh ****, I still have not reported the bug in Graphics.Rendering.Cairo.Matrix.transformPoint
11:04:58 <chessguy> i think so.
11:05:02 <benja_> ought to do that now
11:05:33 <dcoutts> benja_, we've changed something in that module, check if it's still broken and report it
11:05:37 <chessguy> how the heck can you order a book on amazon with overnight shipping and have the estimated arrival date be almost a month away
11:06:07 <benja_> dcoutts: just checked http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=gtk2hs;a=headblob;f=/cairo/Graphics/Rendering/Cairo/Matrix.chs
11:06:10 <lambdabot> Title: darcs - gtk2hs, http://tinyurl.com/29zcpe
11:06:38 <dcoutts> newsham, we don't provide binaries, we leave that for distros etc (except for windows since windows users expect the hand holding)
11:07:03 <musasabi> @seen dons
11:07:04 <lambdabot> dons is in #happs, #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 6h 51m 18s ago.
11:07:10 <dcoutts> benja_, ok, and it's still wrong?
11:07:20 <benja_> yup
11:07:22 <dcoutts> benja_, darcs record; darcs send!
11:07:23 <dcoutts> :-)
11:08:28 <benja_> fair enough :)
11:08:40 <ski> benja_ : that's contravariant (as opposed to covariant) functor
11:08:57 <benja_> thanks
11:10:21 <ski> a contravariant functor from category 'C' to category 'D' is basically the same as a covariant functor from 'C^op' to 'D' (or from 'C' to 'D^op' if you like)
11:10:51 <ski> (where 'C^op', to opposite of 'C' is just like 'C', except every morphism is reversed)
11:10:58 <ski> (s/to/the/)
11:11:30 <dcoutts> benja_, though if you're not a darcs person then you can just send an ordinary email bug report :-)
11:11:42 <beelsebob> edwinb: you available to be prodded re parsers again?
11:12:25 <glguy> ?yow
11:12:26 <lambdabot> I am a jelly donut.  I am a jelly donut.
11:12:37 <chessguy> @quote donut
11:12:38 <lambdabot> No quotes match. That's something I cannot allow to happen.
11:14:41 <ski> benja_ : is that haskell-src-exts/src/purefun/ ?
11:17:27 <chessguy> @quote jelly
11:17:27 <lambdabot> shapr says: vincenz: Right. Santa Claus can have a bowl full of jelly, but it's not appealing on programmers.
11:17:59 <ski> @quite
11:18:00 <lambdabot> Maybe you meant: quit quote
11:18:01 <chessguy> i didn't think programmers were supposed to be appealing
11:18:06 <ski> @quote
11:18:06 <lambdabot> <lithyum> says: tentacle rulz ;>
11:18:12 <newsham> dcoutts: right, i was referencing windows.
11:20:43 <pesco> Lemmih, xerox: Why did you rename cabal-get to cabal-install?
11:22:07 <chessguy> @quote quit
11:22:08 <lambdabot> RunarJordahl says: Haskell has quite the following among the alpha geeks
11:22:21 <chessguy> @quote quit
11:22:21 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
11:26:07 <chessguy> @quote turing
11:26:07 <lambdabot> No quotes match. Wrong!  You cheating scum!
11:26:16 * chessguy hangs his head in shame
11:27:43 <Procyon_> lol
11:27:57 <Procyon_> @quote curry
11:27:58 <lambdabot> emu says: what would be the ingredients in a Haskell curry?
11:28:17 <int-e> @quote hoare
11:28:18 <lambdabot> hoare says: "There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there
11:28:19 <lambdabot> are no obvious deficiencies. The first method is far more difficult.  -C. A. R. Hoare"
11:29:09 <Procyon_> @quote vonneumann
11:29:10 <lambdabot> No quotes match. Take a stress pill and think things over.
11:29:14 <Procyon_> @quote von neumann
11:29:14 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
11:29:23 <chessguy> @go C. A. R. Hoare
11:29:26 <lambdabot> http://en.wikipedia.org/wiki/C._A._R._Hoare
11:29:27 <Procyon_> @quote neumann
11:29:28 <lambdabot> No quotes match. The more you drive -- the dumber you get.
11:30:56 <glguy> I'm encased in the lining of a pure pork sausage
11:31:39 <chessguy> glguy, thanks for sharing, but you really ought to seek professional help for tyhat
11:32:03 <glguy> Xerox your lunch and file it under "sex offenders"!
11:33:11 <Procyon_> wow.  I didn't know this: In 1948, Turing, working with his former undergraduate colleague, D.G. Champernowne, began writing a chess program for a computer that did not yet exist. In 1952, lacking a computer powerful enough to execute the program, Turing played a game in which he simulated the computer
11:33:48 <chessguy> yup
11:34:09 <Procyon_> And I complain when my puter is too slow to run my algorithm....
11:34:22 <chessguy> Procyon_, you lazy slob :)
11:34:34 <sjanssen> Turing++
11:34:44 <benja_> ski: haskell-src-exts/src/purefun is the Template Haskell code that does the actual processing of the functor syntax
11:35:05 <ski> 'the functor syntax' comprising what ?
11:35:56 <benja_> # and ! such that #(... !x1 ... !xn) is equivalent to liftAn (\x1' ... xn' -> ... x1' ... xn' ...) x1 ... xn
11:36:09 <ski> ok
11:36:14 <benja_> the way it works is that the preprocessor generates template haskell
11:36:31 <ski> ok
11:36:35 <benja_> and purefun is then the template haskell functions that generate the actual code
11:36:52 <ski> (istr liyang wanting to do something similar)
11:36:57 <benja_> what's your syntax idea related to Applicative, then? :-)
11:37:53 * ski thinks it would be better for him to try and implement it first ..
11:39:00 <benja_> ski: ok :)
11:40:36 <Lemmih> pesco: It's supposed to do more than getting.
11:42:26 <shapr> Lemmih: pong?
11:43:05 <kowey> http://www.haskell.org/haskellwiki/UTF-8 <-- is this ok as an example of working with UTF-8 in Haskell?
11:43:07 <lambdabot> Title: UTF-8 - HaskellWiki
11:43:44 <chessguy> shapr, was that a question or an ICMP packet? :)
11:44:11 <emu> type class q: i am defining a class and many of the member functions require the same class constraints on their type variables.  is there any way to say this without repeating (Eq s, Ord s ...) => over and over?
11:44:24 <shapr> chessguy: er, something like that.
11:47:22 <chessguy> shapr, :)
11:48:01 <musasabi> Anyone remembering how to do a selection from hlist like hasMaybeField :: SomeContext => res -> Record r -> label -> res; hasMaybeField defaultValue record label = ... ?
11:48:18 <benja_> emu: if you are willing to accept GHC extensions, yes
11:48:27 <benja_> like this:
11:48:30 <emu> which one
11:48:43 <musasabi> that is without going through the list in case it hasn't got the type.
11:48:46 <benja_> class (Eq s, Ord s, ...) => Foo s where {}
11:48:55 <benja_> instance (Eq s, Ord s, ...) => Foo s where {}
11:49:06 <benja_> (that's it)
11:49:25 <emu> it couldn't be Foo s
11:49:41 <benja_> it declares a class Foo and says that any s that is a member of (Eq s, Ord s, ...) is a member of Foo s
11:49:45 <emu> it's more like: class (Eq s, Ord s) => Foo a where f :: a s -> ...
11:50:00 <emu> would that work?
11:50:19 <benja_> emu: hm, I thought you just wanted an alias for the list of type constraints
11:50:32 <emu> the constraints are on the parameters to a
11:50:35 <emu> not on a
11:50:50 <Gotaku> Is there something like guard that work internal to functions? I don't want a big nesting of if else if statements...
11:50:54 <benja_> hmm
11:51:18 <emu> Foo a such that a is a parameterized algebraic type expecting an Eq, Ord type
11:52:08 <benja_> hmm, I don't know how to make it work, sorry :-/
11:52:11 <SamB> Gotaku: use "case () of _ | True -> doSomething"
11:52:20 <SamB> except with more interesting guards
11:52:26 <emu> np
11:53:14 <benja_> you could of course use my Foo and do, class Bar f where fn :: Foo a => f a -> ...
11:53:30 <emu> ah, perhaps
11:53:44 <benja_> at least I think so. I think it's a GHC extension that you can have type contexts on class members :)
11:55:19 <SamB> benja_: surely not!
11:55:49 <SamB> not sure if they are allowed to constrain the variables from the class head or not though...
11:56:56 <hpaste> boing
11:57:24 <Gotaku> Is there a function that converts a string to lowercase? Or will I just have to map toLower to it?
11:57:48 <glguy> map toLower
11:58:05 <glguy> no sense in having a specialized function to do what that can
11:59:12 <benja_> SamB: ok, right, it's only on the variables from the class head
11:59:14 <benja_> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#class-method-types
11:59:16 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
11:59:20 <SamB> unless you were thinking there should be a typeclass for recasing?
11:59:52 <beelsebob> yay for ghc compiling cleanly on OS X --> http://darcs.haskell.org:8010/
11:59:54 <lambdabot> Title: BuildBot: GHC
12:05:47 <Gotaku> SamB: I don't understand that code you posted.
12:06:02 <benja_> dcoutts: actually, it seems that the bug *has* been fixed! :-) my bad
12:06:20 <benja_> the fix was in a different place than I looked :)
12:06:47 <benja_> (swapped the parameters of the function on the lhs rather than on the rhs of the =)
12:15:18 <quicksil1er> the fmap instance for Maybe is insanely useful, but I sometimes find it obfuscating. Maybe I should rename it 'liftMaybe' or 'inJust' or something
12:16:44 <kowey> pesco: http://abridgegame.org/repos/darcs/UTF8.lhs <-- is this your handiwork?
12:17:18 <benja_> liftMaybe sounds like the less obfuscated of the two :-)
12:17:49 <kowey> pesco: if so, it might be worth it if you made it into a package, cabalised and all, something like a Data.Char.UTF8
12:17:53 <bd_> liftM?
12:18:19 <quicksil1er> benja_: but 'inJust' refers to it being a function 'inside Just', and it has the benefit of being a joke :P
12:19:07 <_roconnor> > liftM (+) (Just 1) (Just 2)
12:19:08 <lambdabot>  Couldn't match `(->) t' against `Maybe'
12:19:17 <_roconnor> > liftM (+1) (Just 1) (Just 2)
12:19:18 <lambdabot>  Couldn't match `(->) t' against `Maybe'
12:19:19 <_roconnor> > liftM (+1) (Just 1)
12:19:21 <lambdabot>  Just 2
12:20:11 <quicksil1er> _roconnor: + is a binary function, you need liftM2 for that
12:20:16 <thedward> > liftM2 (+) (Just 5) (Just 4)
12:20:18 <lambdabot>  Just 9
12:30:30 <emu> hpaste: url
12:30:31 <hpaste> Haskell paste bin: http://hpaste.org/
12:30:57 <sjanssen> lisppaste2: url
12:30:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:30:58 <glguy> emu: did you know it would respond to that already?
12:31:04 <sjanssen> mwahaha
12:31:17 <emu> yes
12:31:46 <hpaste>  emu pasted "existential types problem" at http://hpaste.org/266
12:32:11 <emu> is there a way to do what im trying?
12:32:49 <sjanssen> emu: the Orderable's might hold things of different types
12:33:00 <sjanssen> == doesn't know how to compare an Int and a Char, for example
12:33:10 <emu> ah yes
12:33:12 <emu> hmm
12:33:50 <Syzygy-> > fromInteger 35 == ' '
12:33:50 <lambdabot>   add an instance declaration for (Num Char)
12:33:53 <AStorm> emu, use x < y and y < x
12:33:56 <glguy> the only thing you'll be able to compare something stored in an Orderable is the thing stored in that same Orderable ;)
12:34:01 <AStorm> < should be StrictWeakOrdering :>
12:34:06 <AStorm> (as in STL)
12:34:14 <Syzygy-> > 35 == ord ' '
12:34:15 <lambdabot>  False
12:34:24 <sjanssen> emu: what should (Orderable 'c') == (Orderable (10::Int)) do?
12:34:30 <AStorm> Both false then they are equal
12:34:30 <emu> False!
12:34:31 <sjanssen> AStorm: that doesn't help
12:34:49 <pesco> kowey: Heh, yes, that's by me. ;)
12:34:54 <sjanssen> emu: so you want to first compare the types, then the contents?
12:34:59 <emu> yes
12:35:05 <pesco> kowey: Actually I was just recently thinking about doing so.
12:35:06 <sjanssen> I think this is possible . . .
12:35:17 <AStorm> sjanssen, why? There should be < in Orderable
12:35:18 <emu> rather OOish oO
12:35:30 <emu> class Eq a => Ord a
12:35:35 <sjanssen> AStorm: < can't compare items of two different types
12:35:57 <glguy> ?src Ord
12:35:57 <lambdabot> class  (Eq a) => Ord a  where
12:35:58 <lambdabot>     compare      :: a -> a -> Ordering
12:35:58 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:35:58 <lambdabot>     max, min         :: a -> a -> a
12:36:14 <AStorm> Hmm, yes :/
12:36:35 <AStorm> ?src Orderable
12:36:36 <lambdabot> Source not found. My mind is going. I can feel it.
12:36:39 <AStorm> :P
12:37:04 <emu> i'm basically trying to represent machine states abstractly so that i could construct new states out of old states and just need to know if two are in fact the same state
12:41:11 <emu> i should probably just map everything to integers somehow
12:41:36 <emu> nothin like godel numbering for working around type constraints!
12:41:38 <Gotaku> My first biggish Haskell program seems to work.
12:41:41 <hpaste>  sjanssen annotated "existential types problem" with "with Data.Dynamic" at http://hpaste.org/266#a1
12:44:33 <emu> interestin
12:44:58 <sjanssen> Ord is trickier
12:45:05 <sjanssen> because there is no instance Ord TypeRep
12:45:08 <Cale> emu: Just because a and b are separately instances of Ord and Eq doesn't mean they're the same instance
12:45:16 <emu> Cale: yea
12:46:35 <sjanssen> it looks like it can be done with unsafePerformIO, but that's a little scary
12:47:12 <emu> ugh, maybe i should just have every instance map itself to a range of Integers
12:47:23 <Cale> Basically, I think the real question is "why do you want to do this?"
12:47:32 <emu> i'm basically trying to represent machine states abstractly so that i could construct new states out of old states and just need to know if two are in fact the same state
12:47:41 <Cale> Okay
12:47:51 <Cale> But why does that involve existential types?
12:48:19 <emu> because i just want to talk about "states" and not whether they are (state,state) or just state, etc
12:48:55 <Cale> That sounds like the job of a type parameter to me.
12:49:49 <emu> except that i can't write things like "union" which takes two things with one kind of state and returns a thing with (state,state)
12:49:53 <Syzygy-> data State = MState Maybe StateT | PState (StateT,StateT) | ... -- something like this?
12:51:03 <emu> well i can, but it's going to be: m s -> m s -> m (s, s) which doesn't fit well with anything that's recursively constructing machines
12:52:49 <emu> mb i am just overcomplicating this
12:57:58 <Cale> emu: perhaps m [s] is the type you're looking for?
12:58:42 <chessguy> recursively constructing machines? sounds like an interesting problem
13:01:09 <emu> i think i might be able to do it by requiring that anything of class State be a recursive data type
13:01:16 <ndm> @seen dcoutts
13:01:16 <lambdabot> dcoutts is in #happs, #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 1h 48m 48s ago.
13:01:21 <Gotaku> Does haskell have a way to specify default arguments?
13:02:10 <ndm> @seen dcoutts__
13:02:10 <lambdabot> I haven't seen dcoutts__.
13:02:13 <ndm> @seen dcoutts_
13:02:14 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 23h 42m 15s ago.
13:02:28 <chessguy> Gotaku, you can do something like that with partial functions, i think
13:02:45 <sjanssen> Gotaku: there aren't default arguments per se in Haskell
13:03:27 <sjanssen> the typical pattern is to have two functions "foo" with default args filled in, and "fooWith" that has extra arguments for control
13:03:49 <Gotaku> I have a recursive function that uses a few arguments for control, but I don't want to have to specify them when I call the function for the first time.
13:04:01 <Gotaku> Ah.
13:04:51 <sjanssen> or if the extra function is an internal function, the worker-wrapper pattern is common too
13:05:06 <allbery_b> foo x = foo' x [] where foo' x xs = ...
13:05:18 <allbery_b> yeh that
13:05:31 <xic> @seen dcoutts
13:05:32 <lambdabot> dcoutts is in #happs, #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 1h 53m 3s ago.
13:05:43 <xic> dcoutts: yeah, everything worked great!
13:06:22 <xic> Cale: hey... i read your monad transformer article
13:06:32 <emu> chessguy: well, the class of regular languages is closed under union, concatenation, and kleene*, so why not?
13:06:40 <Cale> xic: cool
13:07:26 <Eighty> what do i have to import to use getBounds and forM?
13:07:34 <emu> @hoogle getBounds
13:07:35 <lambdabot> No matches found
13:07:39 <emu> forM is in Control.Monad
13:07:40 <chessguy> emu, why not what? i don't know what you're referring to
13:07:47 <emu> chessguy: constructing machines recursively
13:07:55 <Eighty> i imported Control.Monad but ghc doesn't find forM
13:08:01 <chessguy> oh, you're talking about finite-state machines?
13:08:03 <emu> @hoogle forM
13:08:04 <lambdabot> Text.Html.form :: Html -> Html
13:08:05 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
13:08:05 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
13:08:09 <emu> @hoogle forM_
13:08:10 <lambdabot> No matches found
13:08:17 <emu> hoogle db needs rebuilding
13:08:18 <emu> chessguy: yes
13:08:22 <allbery_b> database isn'tbased on 6.6
13:08:26 <chessguy> ah
13:08:49 <xic> Cale: i actually have a few questions. in my case i think i need my own >>= operator
13:08:56 <emu> forM :: (Monad m) => [a] -> (a -> m b) -> m [b]
13:08:56 <emu>   	-- Defined in Control.Monad
13:09:01 <allbery_b> Eighty: forM is new in ghc6.6, if you're using ghc6.4 it won't be there
13:09:15 <emu> anyhow, forM = flip mapM
13:09:22 <Cale> xic: that could be -- monad transformers don't get you everything
13:09:26 <Eighty> allbery_b: oh, thanks, i'll upgrade :)
13:09:41 <emu> getBounds sounds like the MArray bounds thing
13:09:42 <trurl> Gotaku: I found this thread useful: http://www.mail-archive.com/haskell-cafe@haskell.org/msg19207.html
13:09:45 <lambdabot> Title: [Haskell-cafe] Idiomatic Haskell equivalent of "keyword arguments" to fu, http://tinyurl.com/2cze9p
13:09:49 <allbery_b> no, it'
13:09:52 <allbery_b> s Bounded
13:10:17 <xic> Cale: well write now i am using: ReaderT MyData IO a
13:10:19 <allbery_b> ?src Bounded
13:10:19 <lambdabot> class  Bounded a  where
13:10:20 <lambdabot>     minBound, maxBound :: a
13:10:36 <emu> time flies when you're coding haskell
13:11:53 <mbishop> Why does the ACM have to lock up their papers? :(
13:12:10 <allbery_b> greed
13:12:14 <sjanssen> 'cuz they're jerks
13:12:39 <_roconnor> can we render cairo to SVG?
13:13:28 <glguy> I'm losing my mind at work! so tired, bored
13:13:32 <glguy> ?yow
13:13:33 <lambdabot> VICARIOUSLY experience some reason to LIVE!!
13:13:49 <glguy> Well said, lambdabot.
13:15:38 * roconnor builds gtk2hs
13:21:17 * roconnor plays with implementing the simply-typed lambdabarmumutilde calculus
13:21:33 <chessguy> glguy, you can't be more bored at work than i am
13:21:46 <glguy> chessguy: try me :-p
13:22:56 <chessguy> what do you do?
13:23:22 <glguy> You don't get to tailor your response, tel me what makes today so bad?
13:24:20 <chessguy> i had to come to work today, that's what makes it bad
13:24:34 <glguy> my project is in limbo
13:24:38 <glguy> I'm not supposed to work on it
13:26:09 <chessguy> at least when you can work on it you do programming
13:26:34 <glguy> I didn't say I have a worse job than you, just that I'm bored today :)
13:26:56 <chessguy> ok, fair enough
13:31:20 <zem> g'day
13:32:43 <astrolabe> hello zem
13:34:50 <hpaste>  (anonymous) annotated "broken monad code" with "(no title)" at http://hpaste.org/267#a1
13:35:24 <Daveman> Chessguy :)
13:35:29 <zem> gah, announce shouldn't reset when you annotate
13:35:39 <zem> anyway, could someone help me see why that isn't working?
13:36:16 <glguy> zem: you can't just "switch monads" whenever you want in a do-block :)
13:36:39 <zem> i need a new do-block to read l?
13:36:46 <glguy> i'm annotating
13:37:05 <roconnor> can I use GADT to make a type of simply typed lambda expressions?
13:37:16 <hpaste>  glguy annotated "broken monad code" with "using let" at http://hpaste.org/267#a2
13:38:19 <Cale> zem: I think you want   let a = map (splitAt 1 . words) l
13:38:42 <zem> cool, that worked :)
13:38:57 <Cale> map (splitAt 1 . words) l  isn't an action to be run, so you can't use it with <-
13:39:09 <zem> aaah
13:39:14 <zem> okay, i get it now
13:39:29 <zem> not that my head doesn't still hurt :)
13:39:30 <Cale> It could be an action to be run, but only in the list monad. In the list monad, you'd get a :: (String, String)
13:40:17 <Cale> (that is, it'd select each of the elements of the resulting list)
13:41:42 <zem> oh
13:41:58 <zem> so <- is strictly for the actions of the IO monad in this case
13:42:09 <Cale> Right, because you've already used it for an IO action
13:42:19 <Cale> All the actions have to match in type.
13:42:35 <Cale> (well, in type of monad, anyway, the result types can differ)
13:42:42 <zem> and let worked because l was a list within the context of the do block?
13:42:55 <Cale> let always works, but doesn't run anything
13:43:08 <glguy> let worked because the code inside has nothing to do with the monad
13:43:16 <zem> ah - so it's let ... in return, basically
13:43:32 <Cale> in do { <the rest> }
13:43:34 <allbery_b> let ... in do (whatever follows)
13:43:37 <zem> the let code uses the return value of readLines, though
13:43:41 <Cale> for instance, if you'd written   let l = readLines f, then l :: IO [String]
13:43:44 * allbery_b slow
13:43:56 <Cale> whereas  l <- readLines f  gives  l :: [String]
13:44:03 <zem> ah
13:44:05 <Gotaku> My first Haskell program works!
13:44:15 <glguy> ?yow
13:44:15 <lambdabot> What GOOD is a CARDBOARD suitcase ANYWAY?
13:44:21 <Cale> The let will just define l to be the same action as readLines f
13:44:24 <zem> so in the first case i'd need a <- to get the string from the IO string
13:44:31 <Cale> yeah, to run the action.
13:44:36 <zem> okay, got it :)
13:44:46 <zem> need to read the monad tutorial again, i think
13:45:02 <glguy> if you omit the <-, and just had "readLines f" on one line
13:45:07 <Cale> Yeah, it can help to reread things once you have a little experience :)
13:45:08 <glguy> it would run that action, and discard the result
13:45:14 <Cale> Might make some more sense now :)
13:45:19 <zem> :)
13:45:41 <glguy> normally you'd just write: do print something, but you could write: do a <- print something
13:45:47 <glguy> and a :: ()
13:45:51 <zem> last time i tried learning haskell i read a whole bunch of tutorials and never ended up writing any real code - trying it the other way around this time
13:45:55 <Gotaku> I'm not really impressed with my code though. It abuses the IO monad so the whole thing is almost completly imperative in appearence.
13:46:11 <glguy> Gotaku: how long is it
13:46:15 <Gotaku> I don't use any other monads other then IO because I don't understand them :(
13:46:24 <Gotaku> glguy, 100 lines.
13:46:29 <glguy> what does it do
13:46:51 * zem is pretty impressed with wxhaskell, i must say
13:46:54 <Gotaku> It just plays gnugo against itself through it's gtp protocol.
13:47:02 <Cale> For really IO-intensive things, writing things all in IO isn't so bad.
13:47:42 <Cale> But the general tactic is to take the real transformations on data that your program is performing and write those as pure code.
13:47:43 <Gotaku> Cale, I'm using it for mostly the sequencing.
13:47:59 <Cale> Yeah, for something like that, I can see how it might end up mostly in IO.
13:48:54 <Cale> At some point you might try representing the GTP protocol more abstractly somehow though, which would involve some pure transformations.
13:49:14 <Gotaku> I have no idea how.
13:49:32 <Cale> I don't really know anything about GTP
13:49:57 <zem> what's the compact way to say \x -> x - 1?
13:50:04 <mbishop> http://mudshark.cit.gu.edu.au/~arock/p1.98.2/
13:50:05 <lambdabot> Title: Index of /~arock/p1.98.2
13:50:08 <Cale> subtract 1
13:50:16 <Cale> Or (+ (-1))
13:50:36 <zem> yeah, i got as far as + (-1) but i figured at that point i might as well keep the lambda (:
13:50:37 <bd_> zem: pred?
13:50:42 <zem> pred it is :)
13:50:54 <Cale> Yeah, pred will work on Integer :)
13:51:07 <allbery_b> :t ((-) 1)
13:51:07 <bd_> @check \a -> (pred :: Int -> Int) a == (a - 1)
13:51:09 <lambdabot> forall a. (Num a) => a -> a
13:51:09 <lambdabot>  OK, passed 500 tests.
13:51:28 <Cale> (-) 1 means something else
13:51:37 <zem> also, is there a built in [1..10] -> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]] function?
13:51:52 <Cale> You could use  negate . (-) 1  but that's confusing :)
13:51:57 <zem> heh - yeah :)
13:52:07 <allbery_b> hm, right
13:52:08 <roconnor> @docs showsPrec
13:52:09 <lambdabot> showsPrec not available
13:52:13 <allbery_b> duh
13:52:13 <Cale> zem: no, but it's easy to write with iterate
13:52:20 * allbery_b still slow
13:52:25 <roconnor> @docs Show
13:52:26 <lambdabot> Show not available
13:52:37 * zem nods - wrote it, just wondering if i'd missed the prelude function
13:52:38 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..10]
13:52:39 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
13:52:56 <Gotaku> Cale, the gtp protocol is very simple. Commands are in the form "command_name arguments\n" and responces are "= response\n\n"
13:53:00 * allbery_b drugged up, bronchitis is fun, whee
13:53:04 <qwr> @src pred
13:53:05 <lambdabot> Source not found. I feel much better now.
13:53:12 <glguy> @src Enum
13:53:12 <lambdabot> class  Enum a   where
13:53:13 <allbery_b> @src Int pred
13:53:13 <lambdabot>     succ                     :: a -> a
13:53:13 <lambdabot>     pred                     :: a -> a
13:53:13 <lambdabot>     toEnum                   :: Int -> a
13:53:13 <lambdabot>     fromEnum                 :: a -> Int
13:53:14 <lambdabot> [3 @more lines]
13:53:16 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:53:49 * int-e wonders why lambdabot has such a potty mouth.
13:53:51 <int-e> i
13:55:26 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/268
13:55:45 <Gotaku> ^ if anyone wants to see the hack job I did.
13:56:27 <SamB> @poll-list
13:56:28 <lambdabot> ["Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
13:56:35 <SamB> @help poll
13:56:36 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
13:56:44 <SamB> int-e: voice your opinion!
13:57:30 <trurl> Gotaku: you can safely replace "if pass == True" with "if pass" :)
13:59:39 <int-e> SamB: oh fun. (done)
13:59:44 <Gotaku> trurl, that's a habit. I usually make my conditionals explicit.
14:00:22 <TomMD> When is Simon going to implement: sequence_ $ filter (elem desiredAction) allPossibleSideEffects  ???
14:01:03 <bd_> Gotaku: if pass :: Boolean? :)
14:01:05 <mbishop> Someone who already has an account on haskell.org want to add http://mudshark.cit.gu.edu.au/~arock/p1.98.2/ to the course learning stuff?
14:01:06 <lambdabot> Title: Index of /~arock/p1.98.2
14:01:08 <bd_> er Bool even
14:06:55 <Gotaku> Ok, fixed the pass == True silliness, now anything else?
14:07:14 <SamB> int-e: or you could maybe patch lambdabot...
14:07:56 * shapr boings cheerfully
14:09:44 <glguy> today is almost over!
14:09:52 <Gotaku> I'm looking mostly for criticism of my approach.
14:10:01 <glguy> that was a terrible approach
14:10:48 <Cale> Oh, you should never use  x == []
14:10:49 <Gotaku> That much is obvious.
14:10:52 <Cale> always use  null x
14:10:58 <Gotaku> Why?
14:11:52 <Cale> Because the latter just does a pattern match. The former causes an additional Eq constraint.
14:12:11 <Cale> @type null
14:12:13 <lambdabot> forall a. [a] -> Bool
14:12:16 <Cale> @type (== [])
14:12:18 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
14:12:33 <Cale> (also, it's just a style thing)
14:13:15 <glguy> just fyi: sendCommand (io white) $ "boardsize " ++ (show boardSize)
14:13:25 <glguy> is: sendCommand (io white) $ "boardsize " ++ show boardSize
14:13:35 <glguy> function application occurs before operators
14:14:49 <Gotaku> I do that other times as well, Thanks.
14:15:31 <cjeris> can anybody point me to an 'installing other people's possibly-cabalized-or-possibly-not haskell code, for dummies' doc?
14:15:58 <Cale> resignResult is only used once, you should probably move the definition down closer to the use
14:16:36 <zem> can i query ghci for operator fixity?
14:16:42 <glguy> :i
14:16:42 <allbery_b> use :i
14:16:44 <Cale> :info (.)
14:16:58 <glguy> :i (.) -- :-p
14:16:58 <zem> thansk
14:17:20 <glguy> Cale's the sort that types ":reload" rather than ":" ;)
14:17:36 <Saizan> the first time i approached haskell i was using parentheses as in imperative languages, like foo(arg1 arg2), i realized the right way only after many fights with the typechecker..
14:18:29 <norpan> i don't see exactly why foo(a,b) is imperative, but sure :)
14:18:31 <Gotaku> What's the difference between where and let in a do block?
14:18:51 <glguy> where exists at the definition level
14:18:51 <shapr> norpan: In lambda calculus it's ((foo a) b)
14:19:01 <shapr> norpan: At least, that's what I think Saizan is saying.
14:19:03 <glguy> it is like having a let as teh first line in the do
14:19:26 <norpan> has more to do with currying than with imperativeness
14:19:42 <Cale> let setup k = do mapM (sendCommand (io k)) ["boardsize " ++ show boardSize, "komi " ++ show komi]
14:19:42 <shapr> Are there imperative languages that can curry?
14:19:47 <Cale> setup black
14:19:49 <Cale> setup white
14:19:55 * glguy puts an "argumentative" sticker on norpan's forehead
14:20:06 <norpan> hey
14:20:07 <Cale> or:  mapM setup [black, white]
14:20:39 <Cale> Gotaku: let is an expression, or in the context of a do-block, a statement
14:20:51 <Cale> Gotaku: where is part of the function declaration as a whole
14:21:03 <Cale> and it scopes over multiple guards, if any
14:21:17 <Saizan> shapr: yeah, also that all imperative llanguages that i know have that style
14:21:40 <Cale> er, I didn't need the 'do' there.
14:21:49 <Cale> let setup k = mapM (sendCommand (io k)) ["boardsize " ++ show boardSize, "komi " ++ show komi]
14:22:26 <bos> @hoogle second
14:22:26 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
14:22:45 <Cale> bos: most likely, you're seeing that used with a = (->)
14:23:03 <Cale> In which case  second :: (b -> c) -> ((d,b) -> (d,c))
14:23:06 <bos> Cale: right
14:23:49 <Cale> > second (+1) ("Hello",1)
14:23:50 <lambdabot>  ("Hello",2)
14:25:01 <Gotaku> Hm, using mapM is a good idea.
14:25:54 <Gotaku> mapM_ is better though I think.
14:25:58 <hpaste>  bos pasted "what i'm using second for" at http://hpaste.org/269
14:27:27 <Gotaku> Actually, I'm not sure if mapM is a good idea or not. It's only sequencing two things after all.
14:27:56 * shapr grumbles at haskell-mode
14:27:59 <bos> i'm writing a PGM file parser. it obviously wants to be embedded inside a monad of some kind.
14:28:23 <shapr> haskell-mode synhl doesn't handle '\\' correctly
14:28:25 <bos> "pull some stuff out of a bytestring. using the residual bits, pull some stuff out of a bytestring. using some residual bits, ..."
14:28:39 <shapr> bos: Using BitSyntax?
14:29:00 <shapr> hi trane
14:29:03 <bos> shapr: no
14:29:12 <trane> hello
14:29:20 <shapr> trane: Learning Haskell?
14:29:24 <Saizan> BitSyntax?
14:29:35 <shapr> @where bitsyntax
14:29:36 <lambdabot> http://www.imperialviolet.org/binary/bitsyntax/
14:29:50 <Cale> Gotaku: even if it's only two items, it factors out that repetition without requiring a new function to be defined
14:29:53 <roconnor>  !paste
14:29:59 <roconnor> !hpaste
14:30:00 <trane> shapr: kind of, most interested in lambdabot and the way people interact with it right now
14:30:06 <shapr> Man, I want a postfix factoid lookup.
14:30:07 <mbishop> ?paste
14:30:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:30:32 <shapr> trane: What sorts of questions do you have about lambdabot? Are you interested in novel collaborative development approaches?
14:31:12 <shapr> bos: Sounds like a reader monad to me.
14:31:40 * shapr polymorphs Notostraca into a dragon.
14:31:48 <Notostraca> Rar?
14:31:55 <bos> shapr: yes, i think so.
14:32:12 <shapr> Notostraca: I thought dragons said rawr?
14:32:22 * Notostraca breathes fire
14:32:23 <Cale> bos: It's also rather like a restricted state monad
14:32:26 * shapr grins
14:32:28 <hpaste>  roconnor pasted "1 hour static lambda-bar-mu-mu-tilde implementation" at http://hpaste.org/270
14:32:44 <Cale> (where you don't expose the state, only the "pull off some bits" operation)
14:32:49 <trane> shapr well I'm working on an ai chatbot, eventually it's going to have to rewrite its own code or accept new code from users, lambdabot provides one model that I might be able to use...
14:33:10 <Notostraca> Does anyone know much about "camping" apps?
14:33:11 <bos> Cale: isn't the reader monad a restricted state monad?
14:33:14 <AStorm> rewrite itself? Strong AI? :>
14:33:26 <Cale> bos: yeah, but possibly not quite the restriction you want
14:33:46 <Cale> bos: Reader is essentially State without the ability to write the state, except locally.
14:34:13 <roconnor> using ShowS is messy.  If I use MonadWriter, will I get the same efficency?
14:34:28 <shapr> Notostraca: camping? For MMOGs? For organizing hiking gear? huh?
14:34:31 <Cale> roconnor: probably close
14:34:33 <trane> strong ai is the goal :) but until then you might be able to do useful things with weaker ai's.
14:34:33 <Notostraca> http://en.wikipedia.org/wiki/Camping_%28microframework%29
14:34:48 <monochrom> I think there is a way to use MonadWriter to get the same efficiency as ShowS
14:34:50 <Notostraca> would this be reasonable with Haskell?
14:34:51 <roconnor> @src Char Writer
14:34:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:34:56 <xic> i'm having trouble making an Either-like datatype be a monad
14:35:02 <roconnor> @src Writer Char
14:35:02 <lambdabot> Source not found. My mind is going. I can feel it.
14:35:10 <roconnor> @instance Writer
14:35:10 <lambdabot> Maybe you meant: instances instances-importing
14:35:17 <roconnor> @instances Writer
14:35:18 <lambdabot> Couldn't find class `Writer'. Try @instances-importing
14:35:19 <shapr> trane: Sounds like a blue-sky idea to me, but I hope you get somewhere interesting.
14:35:21 <Saizan> damn, where was BitSyntax hidden?
14:35:26 <roconnor> @instances MonadWriter
14:35:27 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
14:35:32 <monochrom> xic: it's going to look up "instance Monad (Either x)"
14:35:37 <monochrom> s/up/like/
14:35:48 <xic> data XEither a b = XLeft a | XRight a; instance Monad XEither    -- doesn't work
14:35:51 <xic> monochrom: that doesn't work either
14:35:54 <roconnor> @src Writer
14:35:54 <lambdabot> Source not found. stty: unknown mode: doofus
14:35:59 <bos> Cale: i think i want something more like Data.Binary's Get monad
14:36:07 <monochrom> "instance Monad (XEither a)"
14:36:08 <Cale> xic: instance Monad (XEither a)
14:36:28 <xic> Cale: when i do that then i get an error when i try to write >>=
14:36:36 <shapr> trane: I think that allowing users to arbitrarily extend a bot with sandboxed code is the easy solution right now. You'd end up with active code-wiki, or something like Second Life.
14:36:41 <roconnor> @fp Control.Monad.Writer
14:36:42 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Writer.hs
14:36:49 <trane> shapr: thanks, i'm just making hypotheses and trying to test them with code...
14:36:54 <Cale> xic: oh?
14:36:57 <allbery_b> ?src Either (>>=) -- wonder if this works
14:36:58 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:37:01 <shapr> trane: Good approach
14:37:06 <Cale> bos: that's quite likely, have a look at that :)
14:37:10 <allbery_b> ?src (Either String) (>>=) -- wonder if this works
14:37:10 <Saizan> bos: Get monad doesn't help much with residual Word8s if you have to see them to realize they are residual
14:37:11 <lambdabot> Source not found. Where did you learn to type?
14:37:18 <bos> Cale: in fact, Get is now a State
14:37:24 <xic> Cale: Couldn't match expected type `a1' (a rigid variable) against inferred type `a' (a rigid variable)
14:37:27 <Cale> yes, it ought to be
14:37:37 <roconnor> @instances Monoid
14:37:40 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
14:37:56 <Cale> xic: (XLeft x) >>= f = XLeft x; (XRight x) >>= f = f x
14:37:58 <roconnor> @src Monoid [a]
14:37:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:38:06 <Cale> xic: Does that work?
14:38:17 <shapr> Notostraca: Yeah, I think you'd be able to do a better job of building a camping app in Haskell.
14:38:31 <Notostraca> Hmmmm...
14:38:36 <xic> Cale: no
14:38:41 <roconnor> @fp Data.Monoid
14:38:42 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
14:38:44 <xic> Cale: that's what i tried
14:38:52 <shapr> Notostraca: But realize that 'camping app' assumes you already know all the libs.
14:39:03 <Notostraca> nooooooo!
14:39:13 <Notostraca> wait, what?
14:39:29 <Cale> xic: It works for me.
14:39:33 <Cale> !paste
14:39:34 <hpaste> Haskell paste bin: http://hpaste.org/
14:39:53 <hpaste>  Cale pasted "XEither" at http://hpaste.org/271
14:40:51 <shapr> Notostraca: The implication of a camping app is that the source code is tiny, and easy to read. But that's only true because people already know all the libs.
14:41:01 <monochrom> Makes me wonder what makes http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs work
14:41:24 <shapr> Notostraca: So you could make a very powerful app in a tiny amount of source code in Haskell, but it's still hard to read because the essential difficulty of a problem can still be quite high.
14:41:55 <shapr> Notostraca: For example, reading 20 pages of Python source takes 15-30 minutes, but 20 pages of Haskell can take days to understand.
14:41:59 <Syzygy-> Camping map?
14:42:04 <dcoutts> tuukkah, cheers for testing the Gtk2Hs profiling support, btw, what kind of app are you writing? I'm still looking for more screenshots and blurbs for the Gtk2Hs website. :-)
14:42:05 <Notostraca> true.
14:42:14 * zem staggers off to bed
14:42:14 <xic> Cale: weird, it's not work for me
14:42:15 <Syzygy-> Hrm. Camping app? I mean.
14:42:26 <Notostraca> Tenting flap?
14:42:29 <Cale> xic: copy and paste what I pasted into a new file and load it
14:42:34 <shapr> Syzygy-: From the wikipedia page, it just means an app that consistently keeps the source code at less than 4k.
14:42:53 <Syzygy-> So, basically, just a small app?
14:42:58 <Notostraca> http://code.whytheluckystiff.net/camping/wiki/CampingRulesOfThumb
14:43:01 <lambdabot> Title: CampingRulesOfThumb on Camping
14:43:03 <Notostraca> small web app
14:43:15 <Syzygy-> Oh. THAT webpage. *scrollsback*
14:44:03 <Gotaku> You guys ever hear about the Battle for Wesnoth? Hands down the most polished open source game I've ever seen.
14:44:06 <shapr> Notostraca: So I'd actually say that a big webapp that gets factored out into libs is just as much a camping app when all it does is call libs. What do you think?
14:44:29 <Notostraca> perhaps...?
14:44:39 <Notostraca> I need more XP
14:44:53 * shapr assigns Notostraca a quest...
14:45:06 <Notostraca> Sell dung to beetles as a monkey?
14:45:09 <shapr> Notostraca: This quest will give you 42 XP...
14:45:09 <monochrom> If the libs are easier to comprehend, that is not too bad.
14:45:54 <Notostraca> http://starmen.net/mother3/screenshots/024.gif
14:45:59 <shapr> Notostraca: Your quest is to write two different HAppS apps in two different modules, and then try to compose them according to the "Camping Rules of Thumb"
14:46:03 <roconnor> Cool, gtk/cairo works
14:46:33 <Notostraca> Now, what is HAppS?
14:46:34 <xic> Cale: thanks, i had a stupid typo!
14:46:38 <Notostraca> @where happs
14:46:39 <lambdabot> http://happs.org
14:46:45 <shapr> Notostraca: http://www.haskell.org/haskellwiki/HAppS_tutorial
14:46:47 <lambdabot> Title: HAppS tutorial - HaskellWiki
14:47:07 <monochrom> You do not want to know how many klocs of C are behind each http request.  But there is no problem considered one http request as one line of Perl/Python/Haskell code.
14:47:14 * roconnor tries out http://dockerz.net/software/chart.html
14:47:15 <lambdabot> Title: A haskell chart library
14:47:34 <shapr> roconnor: oooh pretty
14:48:08 <roconnor> I want to figure out how to use gtk to layout sequent caclulus deductions
14:48:27 <roconnor> But I know squat about gtk
14:48:31 <monochrom> I think you end up writing your own layout algorithm roconnor.
14:48:36 <Notostraca> Grr! I keep confusing web things for web things!
14:48:49 <tuukkah> dcoutts, me and benja_ are writing a (RDF) graph browser-editor. we don't have a release yet because we still have some profiling to do
14:48:52 <shapr> Notostraca: huh?
14:48:52 <roconnor> presumably I can use Cairo to layout text
14:48:53 * monochrom has done similar things in Java AWT.
14:48:53 <Notostraca> haXe, HaXML, HXML!
14:49:22 <dcoutts> tuukkah, oh, cool.
14:49:23 <Notostraca> haXe: great promises! terrible docs! www.haxe.org
14:49:28 <shapr> Notostraca: haXe is interesting, but it's a new language implemented in OCaml and designed to compile to javascript, flash, and nekovm backends transparently.
14:49:34 <dcoutts> tuukkah, what do you use to draw the graphs?
14:49:40 <shapr> Notostraca: I wrote some newbie docs for haXe, they're on the haXe wiki.
14:49:42 <dcoutts> tuukkah, graphvis? cairo? svg?
14:49:54 <Notostraca> OCaml? I thought erlang...
14:50:14 <shapr> tuukkah: Release is for users, you should give urls for pretty screenshots to us here on #haskell!
14:50:14 <dcoutts> roconnor, you want cairo, and you want to see the code we did for epigram.
14:50:19 <monochrom> Everything will eventually be implemented in Haskell.
14:50:36 <tuukkah> dcoutts, cairo yes
14:50:44 <roconnor> dcoutts: you have epigram layout?
14:50:56 <dcoutts> roconnor, and you might want to collaborate with the people implementing the epigram gui
14:50:58 <roconnor> using cairo?
14:51:02 <dcoutts> right
14:51:03 <shapr> monochrom: At that point Haskell will be the low level backend, and will be reached from type safe languages like Epigram.
14:51:13 <roconnor> dcoutts: since when?
14:51:50 <seliopou> Ok, who thinks the GHC wikipedia page is a mess right now?
14:51:56 * roconnor secretly wants to write his own proof assistent
14:52:00 * seliopou does
14:52:20 <dcoutts> roconnor, see: http://haskell.org/gtk2hs/archives/2006/03/06/introductory-presentation/
14:52:22 <lambdabot> Title: Gtk2Hs » Blog Archive » Gtk2Hs introductory presentation, http://tinyurl.com/29zoyq
14:52:45 <dcoutts> roconnor, the Gtk2Hs dev team went up to talk to the epigram folk about Gtk2Hs and cairo and formula layout.
14:52:54 <pbx> seliopou: Starting with History seems odd.
14:52:59 <dcoutts> lots of interesting discussion, a bit of demo code etc
14:53:18 <seliopou> pbx: the whole rewrite seems odd
14:53:35 <Notostraca> Could haXe source be dismantled to make beautiful Haskell code?
14:53:36 <monochrom> http://www.haskell.org/haskellwiki/GHC/  is clearly so empty that it cannot possibly be a mess.
14:53:38 <lambdabot> Title: GHC/ - HaskellWiki
14:53:54 <Notostraca> I mean the conversion to runtime parts
14:54:06 <seliopou> The author clearly wanted to incorporate some pieces of information from the Haskell history paper
14:54:09 <Notostraca> SWFmill and such
14:54:15 <monochrom> Oh nevermind.  The ending / makes a difference. :)
14:54:34 <monochrom> Well http://www.haskell.org/haskellwiki/GHC is not a mess either.
14:54:36 <lambdabot> Title: GHC - HaskellWiki
14:54:53 <seliopou> http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler
14:55:10 <dcoutts> roconnor, http://www.haskell.org/gtk2hs/albums/pango/formula_layout.png
14:55:43 <dcoutts> roconnor, it's all about box packing, that demo code is linked from the page I showed you a moment ago.
14:55:44 <roconnor> dcoutts: *l* that's pretty terse
14:55:55 <monochrom> Well all encyclopedia entries are messes, from my 20 years of experience in reading encyclopedia.
14:57:03 <dcoutts> roconnor, that was just the demo I hacked up on the train. When I last talked to Conor he said it should be a reasonably generic and reusable library, so I'd talk to him about collaborating.
14:57:23 <astrolabe> I think the wikipedia article is quite good :)
14:57:48 <roconnor> dcoutts: well, I'm not very serious at the moment
14:58:08 <roconnor> I just wanted to play around with illustrating this lamba-bar-mu-mu-tilde calculus
14:58:32 <dcoutts> roconnor, sure, well if you spend more than a couple hours on it then your stuff will be the most advanced :-)
14:58:39 <monochrom> That's a cool name for a calculus.
14:58:48 <roconnor> monochrom: it's totally awsome
14:59:01 <dons> dcoutts: oh, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
14:59:04 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
14:59:14 <roconnor> monochrom: http://hpaste.org/270
14:59:15 <monochrom> Is it a corner of the lambda cube?
14:59:17 <dcoutts> dons, !!! oh yes
14:59:21 <dons> dcoutts: lesson: manually getting the leading strict chunk out of a lazy bytestring is a big big win
14:59:42 <dcoutts> dons, yeah.
14:59:44 <roconnor> monochrom: it is to the LK sequent caculus as lambda calculus is to natural deduction
14:59:51 <dcoutts> dons, I think we could make that happen more automatically.
15:00:12 <dons> (i'm currently doing the same for the fasta benchmark, and getting similar results. i.e. do everything in lazy bytestrings, until the very end, when we unpack the strict bytestring, and strictify it enough for ghc to turn it into an Addr#)
15:00:15 <dcoutts> dons, by 1. unpacking the ByteString into the list and 2. possibly using spec constr
15:00:45 <dcoutts> dons, spec constr ought to be perfect for this
15:00:47 <Igloo> dons: DYM have a BS (prefix) and an LBS (suffix)?
15:01:18 <dons> well, not explicitly, but that's the way to get good code
15:01:44 <Gotaku> How does the printf function work?
15:01:45 <dons> since ghc really knows how to optimise :  !s :: Strict.ByteString
15:01:58 <dcoutts> dons, what is $MB_GHCRTS set to? we can usually push that quite low, like 1Mb
15:02:05 <dcoutts> dons, right, yes.
15:02:05 <dons> Igloo: don't you think that sum-file result is kind of amazing :)
15:02:18 <Notostraca> The "ghc" command doesn't work from windows cmd.exe, does it?
15:02:18 <dons> dcoutts: ah right, its just the default too
15:02:39 <monochrom> It does, Notostraca.  Note %path%.
15:02:40 <Igloo> dons: Yeah, looks nice. Why are there multiple GHC entries?
15:02:42 <dcoutts> dons, oh, that makes me want to hack on optimising the lazy bs representation.
15:02:49 <dons> Igloo: old entries not removed
15:03:02 <Notostraca> What is... %path% ?
15:03:18 <Igloo> dons: OK, and #2 is chosen because #5 is worse overall (due to memory)?
15:03:24 <monochrom> You have to learn Windows for that.
15:03:25 <dons> right
15:03:32 <Notostraca> nooooooo!
15:03:48 <monochrom> Very few Windows users know how to use Windows.
15:03:50 <dons> I quite like #3 though
15:03:55 <Notostraca> true dat.
15:04:18 <monochrom> Anyway, often I just type c:\ghc-6.6\bin\ghc --make xyz.hs
15:04:23 * Igloo reads the code and sees what dons means
15:04:36 <Igloo> dons: Are you saying that the !s in the second line of new makes a difference?
15:04:57 <roconnor> fellowship is an implementation of the lambda-bar-mu-mu-tilde calculus: http://www.lix.polytechnique.fr/Labo/Florent.Kirchner/fellowship/
15:05:00 <lambdabot> Title: Fellowship
15:05:12 <roconnor> but it looks ugly: http://www.lix.polytechnique.fr/Labo/Florent.Kirchner/fellowship/img/screenshot1.png
15:05:14 <lambdabot> http://tinyurl.com/2hvxak
15:05:21 <dons> Igloo: in general, strictifying a normal strict bytestring is the key to ghc unrolling it down to an Addr#, and when that happens you get amazing code
15:05:28 <roconnor> I thought I could do better, with a toy implemenation
15:05:39 <dons> the illegal #5 entry is compiled pretty much perfectly, for example
15:05:58 <Igloo> dons: but surely new is alreadys strict in s there?
15:06:00 <dons> but as soon as you switch to the lazy bytestring, you don't get that fast path on the strict chunks anymore
15:06:04 <Igloo> dons: Why is #5 illegal?
15:06:13 <dons> it uses O(n) space
15:06:41 <Igloo> Ah, there's a space requirement rather than just minimising an overall score
15:07:10 <dons> yeah
15:07:13 <flux-> I would say the other top contenders are much more idiomatic for their languages than for example Haskell #2 or #5 :-)
15:07:16 <dons> often there are those kind of constraints
15:07:35 <dons> flux-, but at least neither use any unboxed primops, eh?
15:07:37 <SamB> so how can the situation with lazy bytestrings be rectified?
15:08:00 <SamB> perhaps they shouldn't merely be lists of bytestrings?
15:09:05 <dons> SamB: yeah, i wonder if maybe it should be a LB !S.ByteString [S.ByteString]
15:09:20 * dons back in 10
15:10:11 <Igloo> dons: I'd be interested to know how many of those !s actually make a difference
15:10:15 <SamB> dons: well
15:10:27 <SamB> don't forget about the possiblity of an empty lazy bytestring
15:10:30 * Botje is now the proud owner of one (1) ghc 6.6 installation.
15:10:36 <Igloo> dons: (not that leaving redundant ones in for clarity is necessarily a bad idea)
15:10:47 <SamB> but that *was* pretty much what I was thinking
15:11:09 <dcoutts> dons, no it just needs to be: data Lazy.ByteString = Nil | LBS {-# UNPACK #-} !ByteString Lazy.ByteString
15:11:24 <SamB> dcoutts: or that
15:11:25 <ptolomy> hmm.. what is going on with the k-nucleotide entries..?
15:11:41 <SamB> but you definately need something like that Nil
15:11:43 <Igloo> dcoutts: Isn't there a penalty for > 1 constructor?
15:11:44 <SamB> either way
15:12:01 <SamB> Igloo: not as big as the one for not supporting empty lazy bytestrings!
15:12:16 <SamB> that one involves abuse of the authors
15:12:29 <SamB> and possibly a large paddle
15:12:57 <dcoutts> Igloo, what is a list?  currently Lazy.ByteString is a newtype of [ByteString]
15:13:07 <dcoutts> Igloo, spec constr should help with that
15:13:24 <Igloo> dcoutts: true
15:13:27 * monochrom wonders why in legal documents it is "one (1)" rather than "1 (one)".
15:13:33 <tuukkah> i'm bad att making cool screenshots :-/
15:13:34 <dcoutts> Igloo, the other possibility is to represent Nil by (BS nullPtr 0 0)
15:13:49 <sorear> tell fodder!
15:13:49 <dcoutts> right gotta go, g'night folks
15:14:03 <tuukkah> dcoutts, shapr, here are some snapshots of the animation: http://iki.fi/Tuukka/tmp/fenfire-hs_notes-2007-01-30.png
15:14:17 <dcoutts> tuukkah, hey, cool
15:14:21 <tuukkah> http://iki.fi/Tuukka/tmp/fenfire-hs_daisygraph-2007-02-03.png
15:14:23 * ptolomy goes off to submit a polite bug report about the k-nucleotide GHC stuff.
15:14:35 <dcoutts> oooh, pretty
15:14:35 <monochrom> k-nucleotide?
15:14:50 <int-e> monochrom: maybe because it's far more likely to miss a typo in digits than in full words.
15:14:57 <dcoutts> tuukkah, I'd love to get these and some blurb on the Gtk2Hs website :-)
15:15:09 <dcoutts> tuukkah, but anyway, g'night! :-)
15:15:14 <ptolomy> monochrom: For the shootout.
15:15:26 <tuukkah> dcoutts, we'll work on it :-)
15:22:35 <fourbissime> hi there. newbie question : I'd like to manipulate IDs of 160bits. namely, do a XOR between two and get the result as an integer. As i'm starting, I'm a bit lost between the possible integers. anyone can help ?
15:22:58 <sorear> use Integer, or Word256
15:23:06 <sorear> Integer is infty-bits (virtually)
15:23:20 <SamB> newtype it
15:25:57 <dons> ptolomy: hmm?
15:26:42 <dons> ptolomy: looks like our old efficient version was disqualified
15:26:50 <dons> and it fell back to an inefficient version
15:26:53 <dons> but fear not..
15:27:02 <ptolomy> Disqualified? Looks like they just failed to build to me.
15:27:20 <dons> ah, no. that's right. yeah, looks like a bug
15:27:29 <dons> i actually mentioned this to the shootout guys a month ago or so
15:27:40 <dons> ghc-6.6: failed to create OS thread: Cannot allocate memory
15:27:50 <monochrom> interesting
15:28:14 <monochrom> (how do I get that to happen?  way cool...)
15:30:58 <Saizan> are there low level binary operators?
15:31:28 <sjanssen> "low level"?
15:31:34 <sjanssen> @docs Data.Bits
15:31:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
15:31:40 <nominolo> hm, say i have a type C a b = Kleisli m [a] [b]
15:31:52 <Notostraca> where does ghc search for modules? namely, curses
15:32:36 <nominolo> i can't figure out how to write a function with this signature: liftA :: (Monad m, Arrow arr) => arr b c -> C b c
15:32:50 <nominolo> any ideas?
15:33:17 <Saizan> and that m?
15:33:26 <sorear> nominolo: define C -- that's a concrete type
15:33:43 <dons> nominolo: in the package system, or for C libs in standard locations
15:33:59 <nominolo> ok, let's call it Foo
15:34:05 <nominolo> the actual name is Circuit
15:34:22 <sorear> Notostraca: run 'ghc-pkg list'
15:34:22 <monochrom> I am not sure how "type C a b = Kleisli m [a] [b]" is even valid.
15:34:35 <nominolo> why not?
15:34:49 <nominolo> the idea is "stateful stream-functions"
15:34:55 <sjanssen> nominolo: that stray "m" makes the type decl incorrect
15:34:55 <monochrom> RHS has variable m, LHS has not.
15:35:00 <nominolo> but i didn't check all arrow lows
15:35:07 <sorear> Notostraca: ***remember*** -lcurses /= -package curses # many newbies refuse to accept this :(
15:35:20 <nominolo> oh, yeah
15:35:23 <nominolo> sorry, typo
15:35:37 <nominolo> type Circuit m a b = Kleisli m a b
15:35:38 <Notostraca> ...What?
15:35:58 <nominolo> liftA :: (Monad m, Arrow arr) => arr b c -> Circuit m b c
15:35:59 <sorear> Notostraca: if you don't have hscurses, ncurses won't help in the slightest.
15:36:04 <Notostraca> I'm using pdcurses
15:36:12 <monochrom> Nice.
15:36:19 <Notostraca> and I have hscurses, i think
15:36:22 <sorear> ok.
15:36:33 <sorear> then why can't ghc find it?
15:36:39 <sorear> what does ghc-pkg list say?
15:36:54 <monochrom> But I am not sure what liftA should intend.
15:37:00 <Notostraca> It lists neither pd or hs curses
15:37:12 <Notostraca> do I edit package.conf?
15:37:21 <sorear> Notostraca: it would never list pdcurses.
15:37:33 <sorear> Notostraca: pdcurses is not a haskell library.
15:37:43 <Notostraca> gurgle.
15:38:17 <nominolo> monochrom: hm
15:38:39 <mbishop> How can I print a string of type IO [Char]?
15:38:39 <sorear> dons: Should we set a policy to not allow packages named the same as the C lib?
15:38:50 <dons> sounds like maybe you didn't register hscurses?
15:38:54 <dons> if its not in the ghc-pkg list
15:38:59 <sorear> mbishop: (>>= putStr)
15:39:04 <dons> go and build it again
15:39:07 <Notostraca> register how?
15:39:14 <sorear> :t (>>= putStr) getLine
15:39:16 <lambdabot> IO ()
15:39:39 <dons> when you install a haskell library, it calls ghc-pkg to 'register' with the ghc package system
15:39:45 <dons> so that ghc then knows this library exists
15:39:54 <sorear> Notostraca: runhaskell Setup.*hs register --user --inplace
15:39:55 <dons> so , in the 'install' phase of building hscurses
15:40:08 <Notostraca> mage has Cuses.hsc and curses-wrapper.h in it.
15:40:19 <dons> ah mage everyone's looking at that
15:40:26 <sorear> Notostraca: then you don't need hscurses.
15:40:28 <dons> but no one's maintained the code for *years*
15:40:36 <mbishop> sorear: Couldn't match expected type `String'  against inferred type `IO [Char]'
15:40:43 <Notostraca> and I don't think hscurses works on non-nix systems
15:40:58 <sorear> mbishop: *gulp* with that code I showed?
15:40:59 <dons> Notostraca: mage doesn't depend on hscures
15:41:07 <dons> it seems to provide its on curses library
15:41:13 <dons> but its very very old code, from what i've seen
15:41:25 <sorear> Notostraca: get ncurses5-dev, or whatever your OS vendor calls it
15:41:29 <Notostraca> KOSMIKUS made a patch
15:41:40 <sorear> what is it?
15:41:49 <dons> ah good
15:42:14 <mbishop> sorear: yeah, well basically, I have the randomElem stuff from lambdabot, and am using it to grab a random string from a list, but if I go to use putStr or anything from main, it gives that error
15:42:14 <nominolo> monochrom: ok, maybe the problem is somewhere else.  I am trying to convert a "circuit" defined using stream-functions to using stateful stream functions
15:42:25 <Notostraca> ncurses does not have a windows version!
15:42:47 <Notostraca> no compatibility with the console!
15:43:06 <sorear> ick, windows :(
15:43:10 <mbishop> sorear: never mind, silly me
15:43:13 <mbishop> I figured it out heh
15:43:21 * sorear admits lack of experience and steps aside
15:43:41 <monochrom> Then the type is probably more specific.
15:43:48 <xic> does a monad have to be able to be a container for any type?
15:43:52 <sorear> yes
15:44:03 <SamB> which is kinda sad really
15:44:12 <sorear> well, maybe not a "container", but parametric
15:44:14 <Saizan> it has to be of kind * -> *
15:44:18 <sorear> oh wait
15:44:21 <sorear> xic: no
15:44:28 <sorear> data MyMonad x = MyMonad
15:44:31 <Exotics_user> EXOTICS ADULT FORUM ::::::::::: http://exotics.ezbbforum.com ....
15:44:33 <Exotics_user> EXOTICS ADULT FORUM ::::::::::: http://exotics.ezbbforum.com .....
15:44:33 <lambdabot> Title: EXOTICS :: Index
15:44:34 <lambdabot> Title: EXOTICS :: Index
15:44:37 <xic> what if i have something like Maybe, but i am only interested in Maybe Int?
15:44:54 <sorear> instance Monad MyMonad where return _ = MyMonad ; x >>= f = MyMonad
15:45:04 --- mode: ChanServ set +o Igloo
15:45:09 <sorear> xic: ^^^ this isn't a container for ANY type
15:45:19 <monochrom> "data MyMonad x = MyMonad" is still a generic container.  It just happens to be lossy.
15:45:22 <xic> sorear: right, and i can't seem to get it working
15:45:27 --- mode: Igloo set +b #haskell!*@*
15:45:31 <Igloo> Bah
15:45:42 --- mode: Igloo set +b-b *!*@88.232.48.162 #haskell!*@*
15:45:44 <Heffalump> oh no, I can't call myself #haskell !
15:45:44 <xic> monochrom: hm...
15:45:45 <mbishop> hehe, good old lambdabot
15:45:53 <hpaste>  jim pasted "TileDemo" at http://hpaste.org/272
15:46:42 <monochrom> Parametric polymorphism means it behaves uniformly over types.  That can be uniformly keep or uniformly lose.
15:46:42 <bos> speaking of Maybe, isn't >>= supposed to short-circuit if it gets Nothing?
15:46:58 <sorear> whois++
15:47:25 <xic> data XMaybe = XJust Int | XNothing -- can this be a monad the same way that Maybe is?
15:47:26 <sjanssen> bos: that is correct
15:47:35 <sjanssen> xic: no, it can't
15:47:38 <sorear> TurkTelekom
15:47:50 <ddarius> xic: no, it is not of kind * -> * as Saizan mentioned earlier.
15:47:52 <monochrom> Consider "data XMaybe a = XJust Int | XNothing"
15:48:58 <xic> i want to be able to use do-notation for my XMaybe type :|
15:49:00 <Cale> monochrom: that would be the trivial monad
15:49:17 <ddarius> xic: What do you want to do?
15:49:19 <Cale> Trying to hijack do-notation always ends in tears.
15:49:23 <Cale> Don't do it.
15:49:40 <Cale> (Unless of course, you really do have a monad)
15:49:47 <monochrom> What's wrong with using "Maybe Int"?
15:49:56 <SamB> or an almost-monad like what QuickCheck has
15:50:07 <Cale> Even QuickCheck is sort of pushing it :)
15:50:16 <xic> monochrom: i don't actually need Maybe Int, i need something slightly different. was just using this as an example
15:50:46 <sorear> @users
15:50:47 <lambdabot> Maximum users seen in #haskell: 322, currently: 283 (87.9%), active: 48 (17.0%)
15:51:18 <monochrom> "slightly" may be an understatement.
15:51:56 <SamB> Cale: yes I know
15:51:59 <xic> oops sorry, turns out i actually do want "Maybe" and not "Maybe Int" :)
15:52:08 <SamB> but since quickcheck results are random anyways...
15:58:24 <xic> Cale: what if in the XEither, the constructors would have their type variables swapped, could the type still be a monad?
15:58:41 <sorear> sure.
15:58:47 <sorear> trivial monad.
15:59:10 <sorear> nontrivially - no, you'd need type level lambdas with reduction.
15:59:54 <xic> sorear: i'm talking about this http://hpaste.org/271
16:00:38 <monochrom> "data XEither x y = XLeft y | XRight x"?  It can be made a monad.  I am not sure whether you want the result.
16:00:43 <Cale> xic: Well, the last variable will always be the type of "success"
16:01:09 <Cale> So in that case, XLeft would represent success, and be the result of return
16:01:19 <monochrom> It's difficult to discuss in handwaving terms.
16:01:26 <xic> Cale: is there a way to make it so that the first variable will be the type of "success"?
16:01:29 <Cale> no
16:01:55 <xic> do you believe that this is a limitation of the typeclass system?
16:01:57 <Cale> Because of the way that type parameters work. We don't have type-level lambda, which you'd need in order to define that instance.
16:02:11 <Cale> It's a limitation of the type system in general, but it's a reasonable one.
16:02:28 <Cale> Typechecking and inference become much much harder if you provide for it.
16:02:32 <SamB> you did want decidable typechecking, right?
16:02:34 <monochrom> "newtype YEither y x = XEither x y" or even "type YEither y x = XEither x y"
16:02:55 <Cale> the latter won't work
16:03:08 <Cale> the former would, but it needs a constructor
16:03:15 <monochrom> oops
16:03:19 <dons> ?users
16:03:20 <lambdabot> Maximum users seen in #haskell: 322, currently: 284 (88.2%), active: 47 (16.5%)
16:03:34 <monochrom> I think a GHC extension allowed the latter to be a class instance.
16:03:36 <xic> this is a long shot, but would arrows help at all here?
16:04:31 <monochrom> I think these are all very difficult questions.
16:04:59 <monochrom> If only we could set breakpoints in your brain and examine what you're thinking.
16:05:23 <monochrom> And they whine about most Haskell environments having no debugging support!
16:05:47 <Cale> Hey, that's improving in the next GHC though :)
16:05:50 <monochrom> Nothing, NOTHING, beats the human brain on lacking debugging support.
16:05:50 <xic> i hear that gdb will have brain support in version 7
16:06:04 <noTV> quit
16:06:35 <Gotaku> What function appends an element to the end of a list?
16:06:49 <monochrom> "Debug your mind, not your code."
16:07:11 <Saizan> ?type (++) . (:[])
16:07:12 <lambdabot> forall a. a -> [a] -> [a]
16:07:16 <SamB> @pl (\xs x -> xs ++ [x])
16:07:17 <lambdabot> (. return) . (++)
16:07:42 <monochrom> You can write xs ++ [new element]
16:07:53 <SamB> @pl flip ((++) . (:[]))
16:07:54 <lambdabot> flip (:)
16:08:11 <SamB> Saizan: something is wrong with your code...
16:08:18 <SamB> it is (:)!
16:08:42 <Saizan> mmh true
16:08:46 <Gotaku> ... ?
16:08:56 <Cale> Gotaku: if you have to do that repeatedly, then lists aren't the best idea.
16:09:08 <Cale> (\e x -> x ++ [e])
16:09:17 <Cale> To write it in pointed fashion
16:09:30 <SamB> I can't read mine
16:09:55 <Cale> Note that (xs ++ ys) takes length xs + 1 reduction steps.
16:10:08 <Cale> (assuming the whole resulting list is used)
16:10:23 <sorear> or more, if you redefine "reduction step" :)
16:10:57 <Cale> yeah, I'm just counting the replacement of something of the form u ++ v with the rhs of an equation in the definition of ++
16:12:38 <Cale> So if you have to do a lot of appends to the end of something, it's much much better to either reverse the thing and use cons, or work with functions of type [a] -> [a], which take the rest of the string and add to the start of it. You can then get concatenation of things like that using composition, and finish the job by applying the function to an empty list.
16:13:11 <monochrom> If you need a queue, find one from the Edison library or Okassaki's book.
16:13:18 <Cale> Or that, yeah.
16:13:22 <Cale> Or use Data.Sequence
16:14:04 <Cale> I'm only pointing this out in case you're building up a string with repeated ++'s though. Just one or two is fine.
16:15:08 <xic> how do i MonadTransform together Maybe and IO?
16:15:09 <Cale> Compare: foldr (++) [] (replicate 100000 "a") with foldl (++) [] (replicate 100000 "a")
16:15:29 <Cale> You need MaybeT, which unfortunately isn't in the libraries. Don't ask me why :)
16:15:49 <xic> is there a way to do it without MaybeT?
16:15:59 <Cale> Well, you can just use them together by hand.
16:16:08 <monochrom> Maybe (IO a) or IO (Maybe a).  Pick one.
16:16:13 <sorear> yes, but it's uglier than copying the defn of MaybeT.
16:16:24 <Cale> Probably you want IO (Maybe a)
16:16:30 <sorear> of course those two are different ... choose wisely
16:17:03 <monochrom> Cale: well from my experience in the past hour I say probably no one knows what xic wants. :)
16:17:08 <sorear> heh.
16:17:41 <emu> hm, does posix regex have "standard" ascii-ish notation for empty-string and null regex?
16:19:02 <xic> no, i want neither of those... i want combination of Maybe and IO: do { x <- Just 3; y <- liftIO (foo x); return y }
16:20:11 <user317> how come records arent checked at compile time, for example if i have, data Foo a = Foo { foo :: a } | Bar { bar :: a } .  putStr $ show $ bar (Foo 1) compiles?
16:22:10 <malsyned> so, anybody know how I can stop ghc from creating 3MB binaries for Hello World programs?
16:22:17 <int-e> user317: it's well-typed. it's valid Haskell. the compiler has to accept this.
16:22:26 <int-e> user317: you could argue that it should give a warning.
16:22:31 <emu> user317: because you can use the same accessor in different parts of the type
16:22:35 <ddarius> xic: Again, what is your ultimate goal with this?
16:22:42 <user317> but it knows that there is no foo in (Bar a)
16:22:50 <Igloo> @seen ndm
16:22:50 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 3h 3m 55s ago, and .
16:23:05 <Cale> user317: bar :: Foo a -> a
16:23:07 <ddarius> user317: show $ bar $ read userInput
16:23:09 <int-e> user317: but it's kind of hard to decide whether a failed pattern match (and that's what the compiler sees) is intentional or not.
16:23:12 <xic> ddarius: i'm trying to make my own mini language
16:23:17 <edwinb> beelsebob: I wasn't, as you might have guessed...
16:23:30 <beelsebob> edwinb: indeed, I kinda got that
16:23:35 <emu> that would require a more sophisticated record type
16:23:41 <sorear> malsyned: rm /usr/local/bin/ghc
16:23:43 <Cale> (which is perhaps confusing since you've named the type constructor the same as one of the data constructors)
16:23:52 <emu> data Foo a = Foo { foo :: a } | Bar { foo :: a } is perfectly legit
16:24:18 <user317> emu, i had  Foo { foo :: a } | Bar { bar :: a }
16:24:24 <malsyned> sorear: rm: cannot remove `/usr/local/bin/ghc': No such file or directory
16:24:25 <malsyned> :-P
16:24:29 <sorear> malsyned: strip makes ridiculously ridiculously big binaries into merely ridiculously big binaries - try it
16:24:31 <ddarius> Alternatively, you might as well ask why division by zero is not checked at compile time.
16:24:41 <emu> all haskell does is a simple transform: foo (Foo x) = x ; foo (Bar _) = fail
16:24:51 <emu> user317: yes, but my point is you COULD have written that
16:24:54 <sorear> you mean error, right?
16:25:03 <emu> user317: and there is NO way for the compiler to determine which one, it is not part of the type
16:25:04 <sorear> * error "foo"
16:25:05 <user317> emu, i want an error at compile time though, not a runtime exception
16:25:06 <int-e> user317: in the Haskell semantics, foo (Bar x) has a value. It's bottom.
16:25:25 <int-e> user317: (usually represented by error "some descriptive error message")
16:25:35 <int-e> user317: so you can't simply reject this as invalid.
16:25:57 <ddarius> xic: okay... so how does that relate to the questions you're asking?
16:25:57 <astrolabe> xic: looks like Maybe (IO) to me
16:26:07 <sorear> astrolabe: kind error!
16:26:34 <emu> user317: there's lots of ways to complain about records.  they're really just syntactic sugar.
16:26:40 <malsyned> sorear: you're right, strip cut the file size almost in half.  but still - is the Haskell runtime really that big?
16:26:46 <astrolabe> sorear: it was shorthand
16:26:56 <Cale> user317: basically, what you want involves dependent types.
16:26:59 <user317> the compiler knows that if it tries to run this code, it will give me an exception, that is not my intent, so it should give me an error
16:27:16 <Cale> In fact, that's almost the reason for dependent types' existence.
16:27:20 <emu> that's nice.  now go read Haskell semantics and tell me how the compiler is supposed to do this.
16:27:26 <Cale> To have that, you'd lose a lot of type inference.
16:28:01 <Cale> For instance...
16:28:05 <user317> well, it generated foo (Bar _) = fail, so wouldn't it know if it fails?
16:28:13 <ddarius> user317: The reason programming language implementations don't do that is: where do you draw the line?  When does the compiler not know?
16:28:35 <emu> user317: is it supposed to analyze arbitrary functions now to determine if they fail at runtime?
16:28:35 <sorear> malsyned: no, it's not specifically a haskell program. jhc and yhc both generate <4k of intermediate code (.c and .hbc respectively) for Hello World.
16:28:36 <user317> ddarius, i would want the compiler to do as much work as possible
16:28:41 <Gotaku> how do I convert a Char to it's ascii number and back again?
16:28:48 <sorear> malsyned: it's a ghc wontfix-bug
16:29:01 <sorear> or at least very-very-low priority
16:29:03 <Cale> If you can give me a compiler which can infer types and do that, then I'll be able to solve many open problems in mathematics :)
16:29:04 <malsyned> sorear: hah.  cute.  what's the actual source of all that extra cruft, then?
16:29:12 <sorear> and getting lower according to Moore's Law
16:29:13 <astrolabe> @hoogle Char -> Int
16:29:14 <lambdabot> Char.digitToInt :: Char -> Int
16:29:15 <lambdabot> Char.ord :: Char -> Int
16:29:30 <edwinb> I don't want a compiler to solve that sort of problem, or I'll be out of a job.
16:29:39 <astrolabe> @hoogle Int -> Char
16:29:39 <Cale> Because basically, I can write programs which will only ever produce values with a given constructor if some theorem is true.
16:29:40 <lambdabot> Char.chr :: Int -> Char
16:29:40 <lambdabot> Char.intToDigit :: Int -> Char
16:29:40 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
16:29:46 <sorear> malsyned: static linking IIRC - your program is statically linked to most of the standard libraries.
16:29:48 <Cale> and then try to apply some deconstructor
16:29:56 <sjanssen> user317: if you want to avoid writing code that fails at runtime, don't use partial functions
16:30:04 <Cale> and if the typechecker fails, then the theorem must be false, right?
16:30:19 <malsyned> sorear: ah.  I suspected as much.  one of my other questions was going to be about ghc and dynamic linking.  namely - does it ever do it?
16:30:36 <Cale> For instance, consider this:
16:30:53 <sjanssen> ie, never use that foo record accessor, use "getFoo :: Foo a -> Maybe a"
16:30:54 <emu> Cale: or rather, the proof is incorrect!
16:31:10 <sorear> malsyned: well, you'll get a dynamic libc. nothing else ATM except on OSX (where static linking is impossible, I'm told)
16:31:17 <Cale> emu: well, I'm supposing that the type inference is perfect
16:31:31 <user317> hmm, well, somehow it can give me a warning if i have a non exhaustive pattern, blah::(Foo a) -> a ; blah (Foo a) = a
16:31:45 <user317> this seems like the exact same problem to me
16:31:49 <malsyned> sorear: so any haskell packages that you depend on get statically linked into your binary all the time?
16:31:50 <Cale> sure, that's easy enough
16:31:57 <Cale> that's entirely different
16:32:22 <Cale> Or are you just saying you'd like that same warning for your deconstructors foo and bar?
16:32:27 <sorear> malsyned: as I understand it, yes.  see -split-objs too, to statically link less than one package.
16:32:31 <user317> how is it different?  i defined a field for only one constructor, and a function for only one constructor
16:32:41 <sjanssen> user317: you don't actually want that.  every use of "head" would emit an error too
16:32:43 <Cale> Okay, that much is easy
16:32:44 <sorear> malsyned: new HDs are *really cheap*
16:32:52 <astrolabe> Gotaku: did you get that?
16:32:58 <Cale> deciding that you've *used* those partial functions correctly is the hard part
16:33:10 <ddarius> user317: re to as much work as possible:  There is always more work that _could_ be done.
16:33:18 <Cale> Suppose we have  data FooBar a = Foo { foo :: a } | Bar { bar :: a }
16:33:44 <malsyned> sorear: yeah, I'm not worried about my hard drive space.  and as I'm not distributing any binaries to any people on slow links, I'm not actually worried about it at all right now, but small download size is a plus for classic small Windows GUI tools and stuff, and who knows where the future will take me.
16:33:45 <Cale> and I write a function  collatz :: Integer -> FooBar ()
16:34:25 <Cale> which gives Foo () if the collatz sequence is eventually 1, Bar () if it ends up in some other cycle.
16:34:29 <sorear> malsyned: what, you can't do source tarballs? :p  (seriously, sigh, EOT)
16:34:32 <Cale> (and doesn't terminate otherwise)
16:34:39 <user317> ok, i get it
16:34:51 <Cale> What happens when we try to typecheck  foo . collatz ?
16:35:26 <malsyned> There's another issue, though - with no opportunity to dynamically link, trying to work with LGPL code in a non-GPL project is kindof a non-starter using ghc.
16:35:35 <sjanssen> Cale: the compiler solves the Collatz conjecture, earning you great fame!
16:35:36 <sorear> Cale: what is the value of collatz if the sequence doesn't converge *at all*?
16:35:52 <Cale> sorear: _|_
16:36:00 <siti> well the binaries are not to aweful with the new gtk2hs :)
16:36:27 <sorear> malsyned: if you can stomach it, there should be nothing impossible about accessing libdl through the FFI
16:36:30 * emu wonders how far you could get using ghc as a theorem prover
16:36:32 <user317> well, in c++ you can define a baseclass that Foo and Bar will derive from, so the functions that operate on both will at least be type checked to work on both, this is all i want :)
16:36:48 <sorear> malsyned: Haskell can call through function pointers, so all the needed tools are there.
16:36:54 <jcreigh> Cale: hmm...wouldn't such a type system be like solving the halting problem?
16:37:02 <Cale> jcreigh: indeed it would
16:37:21 <Cale> Perhaps even harder problems than that.
16:37:37 <sjanssen> user317: but then you have to use a downcast to call ".get_foo()", so you have the same problem, yeah?
16:37:47 <malsyned> sorear: sure, if I'm linking to an LGPL C library.  but what if someone releases an LGPL haskell library?  they're basically saying "if you're planning on building your project with ghc, then the fact that we used LGPL instead of GPL is useless to you."
16:37:57 <sjanssen> with the downcast potentially resulting in error
16:38:07 <user317> sjanssen, why do you need to downcast
16:38:23 <jcreigh> aren't most Haskell libraries BSDish licensed anyway?
16:38:26 <Cale> user317: because otherwise the function isn't available
16:38:29 <sorear> malsyned: if you buy into the FSF's interpretation of linking :)
16:38:31 <Jenny_2> hi all
16:38:33 <Jenny_2> EXOTICS ADULT FORUM ::::::::: http://exotics.ezbbforum.com ...
16:38:34 <lambdabot> Title: EXOTICS :: Index
16:38:35 <Jenny_2> EXOTICS ADULT FORUM ::::::::: http://exotics.ezbbforum.com ...
16:38:36 <lambdabot> Title: EXOTICS :: Index
16:38:39 --- mode: ChanServ set +o Cale
16:38:49 <siti> lol
16:38:56 <emk> Bye bye!
16:38:57 <edwinb> too slow ;)
16:39:06 --- mode: Cale set +b *!n=Jenny_2@*
16:39:10 <sorear> Cale: both addrs are from Turkey
16:39:12 <int-e> *!*@88.232.105.76
16:39:18 <user317> a function that works on teh baseclass would never downcast
16:39:19 --- mode: Cale set +b *!*@88.232.105.76
16:39:24 <jcreigh> an adult forum? They found some way to keep the 13 year olds out? :)
16:39:41 <siti> turkish :S
16:39:48 <siti> whois 88.232.105.76
16:39:52 <sorear> Cale: *!*@88.232.0.0/17 will match the entire provider
16:39:56 <Cale> I wish bans could specify exact IP ranges
16:39:56 <user317> the benefit of that is that you can use common api's that work on teh baseclass within code that works on teh children, there is no downcast, only upcast
16:40:02 <Cale> ah, okay
16:40:05 <jcreigh> sorear: gah, but a /17 is big.
16:40:08 <Cale> I didn't know that worked.
16:40:20 <emu> user317: this isn't really the same thing
16:40:24 <siti> no tuks will be able to do haskell ;)
16:40:24 <sjanssen> user317: so get_foo() and get_bar() are in the base class?
16:40:25 <Cale> Yeah, that's all of TurkTelekom
16:40:32 <siti> turks*
16:40:53 <Cale> user317: after the upcast, you can't use get_foo and get_bar though.
16:40:56 <sorear> gah, dyn ips  :(((((((((
16:41:02 <Cale> We can manage that.
16:41:04 <sorear> gah, emacs
16:41:06 <user317> sjanssen, if they are then the compiler can inforce that the children implement them, thats the point, if they are not, the function that works on just the baseclass will not compile
16:41:12 <malsyned> sorear: that's a fair point.  really I'm just exploring the problem space.  deployment is an aspect of programming languages that often gets brushed under the rug by people trying to evangelize non-mainstream languages.
16:41:46 <sjanssen> user317: record accessors in Haskell and methods in C++ are totally different things
16:41:51 <sorear> malsyned: we have a deployment research force, join the Cabal now!
16:42:41 <user317> I guess i would need to use a haskell Class, if i want to enforce that a specific method is defined
16:42:55 <malsyned> As much as I love source tarballs, what does cabal do for people who prefer their programs pre-compiled?
16:43:16 <emu> malsyned: the executables?
16:43:21 <malsyned> (I haven't read much about cabal beyond the standard Setup.hs build recipe)
16:43:29 <emu> there's a dist target i think
16:44:31 <user317> but that takes way more code
16:47:00 <user317> so if i define a Class that has a function foo, can i use a record to implement it?
16:48:16 <sorear> yes
16:48:55 <astrolabe> 'The harder you work to make your language foolproof, the more ingenious the fools become'
16:48:57 <Cale> and you still can't *really* enforce that all the members of a class are defined, but you will get warnings about it
16:50:44 <Cale> Basically, leaving out a definition in a class instance is roughly equivalent to foo = undefined
16:51:14 <user317> you cant?  why not?  that seems easy to enforce
16:51:35 <user317> shouldn't you be able to verify that when the class is derived?
16:56:29 <MarcWebe1> malsyned: There is a debian rpm target I think..
16:57:04 <malsyned> MarcWebe1: yeah, I realized that that was a silly question as soon as I asked it.
17:01:21 <user317> Cale, well at leat you get a warning, i can live with that
17:06:37 <sorear> now ... how embarrased should I be using undocuemnted alex_* symbols? :)
17:08:05 <monochrom> Perhaps Alex should be embarrassed in undocumenting them.
17:08:43 <sorear> like alex_scan_tkn'.  very internal.
17:09:29 <monochrom> There is no embarrassment.  There is just risk.
17:10:01 <mbishop> and risk of embarrassment
17:10:05 <SamB> yeah
17:10:05 <sorear> the symbols in question haven't been changed in 6m ... alex hasn't been code changed in 6m ...
17:10:34 <SamB> sorear: what? my patch wasn't applied?
17:12:19 <sorear> according to "darcs changes | grep '^[^ ]' | cut -b '31-' | sort | uniq -c", Samuel Bronson has never patched alex.
17:13:05 <sorear> JaffaCake, ross paterson, sven panne, dcoutts, and "mthomas" have.
17:13:45 <sorear> noone else...
17:15:28 <freakazoid> Would writing flight control code for a rocket in Haskell be a good idea?
17:15:44 <freakazoid> I've been investigating Haskell, Erlang, and (obviously) Ada 2005 for the purpose
17:15:45 <sorear> yes
17:15:53 <sorear> maybe not a small rocket
17:16:03 <freakazoid> I can run a full OS on the flight control computers
17:16:13 <freakazoid> and even on the engine controllers if I need to
17:16:14 <sorear> a large rocket --> you want large system support
17:16:29 <freakazoid> Well, it's not an HPR rocket
17:16:34 <sorear> freakazoid: keep in mind that haskell doesn't do RT.
17:16:50 <sorear> freakazoid: I'm not an expert in rocketry - what's HPR?
17:16:51 <freakazoid> yeah, that was one of my concerns
17:17:06 <freakazoid> sorear: high power rocketry, the high end of the amateur range
17:17:15 <freakazoid> this is a rocket that will be going to 100-200km and landing vertically
17:17:53 <sorear> heh. shows how little I know. I thought "has flight control computer" implies "freakazoid is working for a defense contractor/NASA/ESA"
17:18:03 <freakazoid> http://masten-space.com/
17:18:05 <lambdabot> Title: Masten Space Systems, Inc.
17:18:19 <freakazoid> this is *not* an HPR rocket
17:18:46 <freakazoid> but I don't work for a defense contractor or a government agency
17:19:33 <sorear> freakazoid: if your brain is the kind that can unexplode on a schedule, you might look into building an Arrow-based DSEL for rt computation
17:20:35 <freakazoid> *that* would be cool
17:20:35 <sorear> arrows are good for tracking static data like time constraints, and can be abused to perform safe manual MM
17:20:36 <monochrom> Oh cool, there is opportunity for some form of Haskell in the civilian space travel industry.
17:20:54 <freakazoid> I want to use the right tool and we're not yet tied to any specific language
17:21:00 <sorear> good
17:21:12 <freakazoid> I am looking at scilab/scicos for the control law stuff, and that generates C code
17:21:30 <freakazoid> Our vendor uses Matlab+Simulink
17:21:30 <sorear> there isn't really much of a precedent I can point to for rocket programming in high level languages
17:21:46 <monochrom> You need a garbage collector with real-time properties.
17:21:48 <freakazoid> sorear: You don't consider Ada a high level language?
17:21:52 <SamB> hmm. I think FreeDOS may have eaten the lead developer for ZSNES...
17:22:04 <freakazoid> yeah the garbage collection is what concerns me the most
17:22:09 <SamB> this does not bode well for us putting the sound back in :-(
17:22:36 <freakazoid> so nobody has done realtime haskell stuff yet?
17:22:46 <sorear> freakazoid: only rocket I've played with was programmed by using thumbscrews to tilt the stand :p
17:23:07 <freakazoid> sorear: heh cool at least you've done rocketry
17:23:21 <sorear> once.
17:23:23 <malsyned> wasn't there something in that History of Haskell doc about someone doing RT stuff with it five, ten years ago?
17:23:23 <freakazoid> check out the latest videos under "News" on the site I mentioned
17:23:33 <SamB> you could use HLLs to write the rocket programs, maybe
17:23:35 <sorear> in a kindergarden (maybe it was YMCA) field trip program
17:23:51 <chessguy> hi haskellers
17:24:03 <sorear> hi chessguy
17:24:27 <chessguy> > mapWith (-) [1..5] [1..5]
17:24:27 <freakazoid> well, we're definitely not using C
17:24:28 <lambdabot>   Not in scope: `mapWith'
17:24:35 <chessguy> ?hoogle mapwith
17:24:36 <lambdabot> Data.IntMap.mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
17:24:37 <lambdabot> Data.Map.mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
17:24:38 <sorear> chessguy: zipWIth
17:24:41 <chessguy> err
17:24:41 <freakazoid> not that's not at least generated by something else we can trust
17:24:42 <sorear> chessguy: zipWith
17:24:42 <chessguy> duh
17:24:52 <chessguy> > zipWith (-) [1..5] [1..5]
17:24:53 <lambdabot>  [0,0,0,0,0]
17:25:04 <chessguy> > zipWith `-` [1..5] [1..5]
17:25:05 <lambdabot>  Parse error
17:25:17 <SamB> I'm not sure matlab qualifies as an HLL
17:25:28 <SamB> it is so damn UGLY...
17:25:48 <chessguy> > zipWith (\x y -> y - x) [1..5] [6..10]]
17:25:49 <lambdabot>  Parse error
17:25:50 <freakazoid> well, doing control law with a general purpose programming language can be a PITA
17:25:55 <freakazoid> you want a domain specific language
17:26:03 <chessguy> > zipWith (\x y -> y - x) [1..5] [6..10]
17:26:05 <lambdabot>  [5,5,5,5,5]
17:26:29 <chessguy> ugh
17:26:34 <mbishop> http://www.md.chalmers.se/Cs/Research/Functional/Fudgets/
17:26:37 <lambdabot> Title: Fudgets Home Page
17:26:47 <chessguy> is there a better way to do that last zipWith?
17:28:12 <sorear> > zipWith subtract [1..5] [6..10]
17:28:13 <lambdabot>  [5,5,5,5,5]
17:28:20 <chessguy> ?src subtract
17:28:20 <lambdabot> subtract x y = y - x
17:28:25 <chessguy> same thing
17:29:39 <chessguy> > zipWith (flip (-)) [1..5] [6..10]
17:29:40 <lambdabot>  [5,5,5,5,5]
17:30:26 <sorear> > zipWith subtract [1..5] [6..10]
17:30:27 <lambdabot>  [5,5,5,5,5]
17:30:31 <sorear> gah emacs
17:35:11 <trane> why isn't it zipWith subtract [1..5] from [6..10], just to make things clearer
17:36:08 <chessguy> because zipWith is a higher-order function, and sticking the 'from' in there might not make sense for other functions
17:36:11 <chessguy> e.g.
17:36:24 <chessguy> > zipWith (,) [1..5] [6..10]
17:36:26 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
17:36:47 <SamB> also...
17:36:52 <SamB> Haskell ain't english!
17:36:58 <SamB> though...
17:37:05 <chessguy> neither is "ain't"
17:37:14 <sorear> @web1913 ain't
17:37:14 <trane> subtract x from y then, forget the zipWith
17:37:15 <SamB> > let ain't = not in ain't False
17:37:17 <lambdabot>  True
17:37:19 <lambdabot> *** "Ain't" web1913 "Webster's Revised Unabridged Dictionary (1913)"
17:37:19 <lambdabot> Ain't \Ain't\
17:37:19 <lambdabot>    A contraction for are not and am not; also used for is not.
17:37:19 <lambdabot>    [Colloq. or illiterate speech]. See {An't}.
17:37:37 <sorear> see! it is english!  webster saz so!
17:37:38 <SamB> chessguy: you must be an english teacher or an SAT prepper
17:37:57 <chessguy> or just pedantic
17:38:04 <SamB> furthermore, a lame english teacher
17:38:05 <sorear> ain't IS english.
17:38:10 <trane> is lambdabot screenscraping definitions or is it in a local file?
17:38:11 <SamB> I'm more pedantic than you are
17:38:21 <chessguy> no you ain't
17:38:21 <malsyned> trane: subtract is a library function.  you're suggesting that part of describing a function should involve selecting other keywords to separate arguments with?
17:38:24 <sorear> chessguy:  it fails english -Wall, but it *does* pass english -pedantic
17:38:25 <SamB> ain't ain't not english
17:38:39 <chessguy> sorear, i knew someone was going to 'make' that joke
17:38:47 <SamB> you mean english -Wall -Werror?
17:38:50 <sorear> yes
17:39:27 <SamB> so what about english -Wall -Werror -Wno-ain't?
17:39:36 <trane> malsyned I just looked at the subtract example above and didn't understand what it was trying to do at first, and i thought a 'from' in there would have made it more intuitive
17:39:40 <SamB> nevermind that UNIX shells will require you to escape that apostrophe
17:40:05 <trane> haskell uses 'in' in let definitions...
17:40:06 <chessguy> trane, does it make more sense now?
17:40:19 <sorear>     Couldn't match kind `#' against `*'   --- gah...
17:40:23 <trane> chessguy yeah but unless i use it everyday i might forget next time
17:40:25 <malsyned> trane: it would, but the idea doesn't go very far given Haskell's symantics.
17:40:33 <SamB> trane: let is a special form!
17:40:38 <chessguy> trane, you can always do:
17:40:41 <chessguy> @type mapWith
17:40:42 <lambdabot> Not in scope: `mapWith'
17:40:47 <chessguy> @type zipWith
17:40:49 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
17:40:52 <chessguy> why do i keep doing that?
17:40:58 <SamB> trane: maybe you would like to try Inform 7
17:41:09 <SamB> chessguy: you want to call it map2 I guess?
17:41:10 <sorear> chessguy: are you an ex-schemer?
17:41:20 <SamB> pythonista maybe?
17:41:26 <chessguy> SamB, i think my brain's just fraid
17:41:28 <chessguy> fried
17:41:33 <chessguy> sorear, no
17:41:39 <sorear> frayed? :p
17:41:49 <chessguy> it's been a long week
17:42:03 <malsyned> heh.  Common Lisp actually does give you a warning that there's a function argument being used.  it'd be something like (zipwith #'subtract (enumfromto 1 5) (enumfromto 6 10))
17:42:20 <sorear> ech.  #' !
17:42:35 <chessguy> anyway
17:42:45 <chessguy> trane, do you understand what this means?
17:42:47 <malsyned> sorear: tell me about it.  it's enough to drive a man to scheme ;-)
17:42:55 <chessguy> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
17:42:57 <sorear> malsyned: why was lisp2 invented again?
17:43:45 <trane> chessguy: not really.
17:44:11 <chessguy> ok, it's the type signature for zipWith
17:44:16 <malsyned> what are the differences between lisp1 and lisp2?  I always forget.
17:44:50 <malsyned> it's not lexical scope, is it?  there were lisp2s that were still dynamic by default?
17:44:55 <chessguy> the "forall c b a." means that this type signature can be true of mapWith for any types you want to put in there for the a, b, and c
17:45:12 <monochrom> lisp2 - lisp1 = 1.
17:45:15 <chessguy> as long as you use the same type in every place you see an a, the same one for all the b's, and so on
17:45:39 <chessguy> the type after the last arrow is the return type
17:45:44 <chessguy> in this case, it's a list
17:45:47 <chessguy> [c]
17:46:18 <malsyned> monochrom: you're thinking of (lisp + 2) - (lisp + 1).
17:46:33 <monochrom> Yes.
17:46:37 <chessguy> the rest are the input parameter types. so zipWith takes three arguments: one of type (a -> b -> c), one of type [a], and one of type [b]
17:46:48 <SamB> a 2-lisp has seperate function and variable names
17:46:58 <SamB> a 1-lisp, such as python or Scheme, does not
17:47:03 <monochrom> Haha
17:47:13 <chessguy> (a -> b -> c) just means a function that takes two parameters and produces a third
17:47:25 <malsyned> the original lisp had a unified namespace, and then they moved away from it?!
17:47:42 <malsyned> (I'm showing my youth here, huh?)
17:47:45 <chessguy> in the example of zipWith (-) [1..5] [6..10], the first parameter is (-)
17:47:59 <chessguy> (-) takes two arguments and returns a third
17:48:04 <trane> right
17:48:11 <sorear> malsyned: don't worry, I learned the difference yesterday
17:48:15 <SamB> it does not return an argument!
17:48:20 <chessguy> the other two input parameters are the lists
17:48:24 <chessguy> SamB, bite me
17:48:29 <trane> :)
17:48:39 * SamB sinks his teeth into chessguy's leg
17:48:42 <chessguy> make a little more sense?
17:48:48 <trane> a little :)
17:48:56 <monochrom> One function's return value is another function's argument.
17:49:02 <SamB> malsyned: why are you complaining about showing your youth?
17:49:16 <SamB> lots of people keep complaining that they feel old!
17:49:17 <trane> obvioulsy the goal of haskell syntax is not to be intuitive in a natural-language-y way
17:49:26 <malsyned> not complaining.  just keeping track of which cards I'm showing ;-)
17:49:30 <sorear> I don't have to *feel* young.
17:49:34 <monochrom> natural language is not intuitive
17:49:46 <sorear> In fact I brag about it.
17:49:48 <SamB> sorear: merely dirt poor?
17:49:54 <sorear> :(
17:50:06 <sorear> well, by world standards obscenely rich
17:50:09 <SamB> I mean, if you aren't young, shouldn't you be able to afford a monitor?
17:50:10 <malsyned> sorear: but being young means I can't speak from experience when I tell trane to look to COBOL if he desires english-y programming.
17:50:28 <trane> gotta go, thanks for the discussion..
17:50:35 <SamB> malsyned: sure you can
17:50:56 <SamB> I could advise trane too look at Inform 7 *if he had not just left*
17:50:57 * sorear has only read about lisp ... and on paper at that
17:51:07 <Gotaku> Will hGetLine concider \r as an end of line marker in windows?
17:51:08 <monochrom> There is no need to speak from experience.  Just speak.  If you are speaking the truth, who cares about experience.
17:51:09 <sorear> 197x book
17:51:16 <chessguy> teaching newbies is fun. it makes me feel like just a hair less of a newbie
17:51:18 <malsyned> there was actually a somewhat reasonable justification for it.  since global variables in lisp2 are dynamically scoped, you could accidentally wreak havoc pretty easily by, say, creating a lexical variable named "list" holding an int and then calling other functions which expected list to be, you know, a function that creates a list.
17:51:24 <monochrom> Moreover experience gives falsehood too.
17:51:30 * SamB hits sorear over the head with CMUCL 
17:51:45 <sorear> bits... tasty...
17:51:45 <chessguy> @slap SamB
17:51:47 <lambdabot> why on earth would I slap SamB
17:52:04 <chessguy> on principle
17:52:04 <sorear> @shappr SamB
17:52:05 <lambdabot> Unknown command, try @list
17:52:22 <chessguy> @list
17:52:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:52:45 <chessguy> @yhjulwwiefzojcbxybbruweejw
17:52:46 <lambdabot> Just 'J'
17:53:31 <Gotaku> How do I drop the last element of a list?
17:53:34 <sorear> init
17:53:39 <sorear> > init "HELLO"
17:53:40 <dibblego> > init [1..10]
17:53:41 <lambdabot>  "HELL"
17:53:42 <lambdabot>  [1,2,3,4,5,6,7,8,9]
17:53:45 <mauke> if python is a lisp-1, perl is a lisp-5 or -6
17:54:05 <sorear> mauke: my 197x book describes a lisp-5
17:54:12 <monochrom> I don't understand 2-categories. :)
17:54:21 <sorear> variables, functions, macros, primitive functions, primitive syntax
17:54:30 <malsyned> mauke: is the lisp-scale measured by lisp-(1 + number of unnecessary namespaces) ?
17:54:35 <sorear> all as separate symbol properties.
17:54:49 <mauke> scalars, arrays, hashes, functions, filehandles
17:54:59 <mauke> and maybe directory handles and formats
17:55:34 <sorear> mauke: here, have a unlambda .. a lisp--1
17:55:48 <mauke> wait, how is unlambda lisp?
17:55:59 <SamB> malsyned: yes
17:56:09 <SamB> or, at least, I think so
17:56:14 <sorear> mauke: it's at least dominantly functional, unlike perl
17:56:18 <SamB> mauke: same way as Haskell I guess
17:56:29 <mauke> sorear: or unlike lisp
17:56:40 <SamB> mauke: you mean CL I assume?
17:56:45 <mauke> yes
17:56:55 <malsyned> so I could accuse Haskell of being a lisp-2 because it has the Type namespace?
17:57:09 <sorear> way more than that
17:57:11 <mauke> I wouldn't call haskell a lisp
17:57:59 <Cale> monochrom: basically, instead of Hom-sets, you have other categories -- so there are "arrows between arrows"
17:58:11 <monochrom> 1 + number of unnecessary namespaces = number of namespaces
17:58:50 <SamB> malsyned: but the names are different
17:58:54 <monochrom> Please don't try to explain to me.  I will forget after a night's sleep.
17:58:55 <SamB> they just *look* the same
17:59:31 <Cale> That is, for any pair of arrows (1-cells) f,g: A -> B, there may be a number of arrows between them (2-cells) a: f -> g
18:00:29 <malsyned> I'm sortof using the "lisp-" prefix facetiously - not as an indication of "lispiness" at all, just as a scale of namespace count.
18:01:08 <Cale> malsyned: In that sense, yeah, though merging the namespaces makes things strange.
18:01:42 <Cale> Whereas merging the namespaces of lisp-2 would not be nearly as strange.
18:01:49 <malsyned> Cale: agreed.  I wasn't suggesting that Haskell should try to unify them.  runtime types in general against the Haskell nature.  I was just trying to getting a rise out of people.
18:02:31 <Cale> Oh, you'd still want types to be compile time, it's just they might take some more time to evaluate than otherwise :)
18:03:52 <chessguy> ?where whyfp
18:03:53 <lambdabot> I know nothing about whyfp.
18:03:56 <chessguy> bah
18:03:57 <Cale> As far as I'm concerned, checking types at runtime almost seems to defeat the entire purpose of having them.
18:04:06 <chessguy> @google why functional programming
18:04:09 <lambdabot> http://en.wikipedia.org/wiki/Functional_programming
18:04:09 <lambdabot> Title: Functional programming - Wikipedia, the free encyclopedia
18:04:11 <sorear> yay!
18:04:15 * chessguy sighs
18:04:24 <chessguy> @google why functional programming matters
18:04:24 <sorear> yi+ haskell highlighting compiles!!
18:04:26 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
18:04:26 <lambdabot> Title: Why Functional Programming Matters
18:04:30 <chessguy> there we go
18:04:33 <Cale> @where whyfp
18:04:33 <lambdabot> I know nothing about whyfp.
18:04:38 <chessguy> ?where+ whyfp http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
18:04:39 <lambdabot> Done.
18:04:44 <Cale> beat me to it :)
18:05:04 <chessguy> great paper
18:05:08 <Cale> Indeed
18:05:23 <Cale> It gets better as you become more knowledgeable though.
18:05:56 <Cale> That is, it's better when it's preaching to the choir than explaining to people who don't know much about functional programming.
18:06:27 <Cale> It's actually more about why laziness is important than functional programming, in my mind.
18:06:38 <chessguy> agreed
18:06:57 <chessguy> the lazy alpha beta stuff is awesome
18:06:57 <sorear> ann: /home/stefan/yi/dist/build/yi/yi highlights Haskell.
18:09:43 <malsyned> is there a good doc for explaining why functional programming is good that really gets it across to the imperative folks effectively?
18:10:03 <monochrom> No.
18:10:22 <monochrom> And I say it as a corollary of the following.
18:10:31 <monochrom> There cannot be a good doc for that.
18:10:35 <sorear> malsyned: if it existed, @users would be >10000 :)
18:10:39 <dibblego> is there a proof that such a document cannot exist?
18:10:50 <malsyned> I second dibblego's question
18:10:56 <monochrom> Piaget's theory of intellectual development.
18:11:14 <SamB> can there be a document that convinces them?
18:11:31 <dibblego> have children, teach them Haskell - don't let them see Java
18:11:32 <malsyned> not that convinces them, necessarily, but that makes the point significantly better than the existing literature does.
18:11:35 <sorear> dibblego: such a proof cannot exist, because human minds are not abstract mathematical objects.
18:11:40 <dibblego> that's your best course of action - and one that I have taken
18:12:05 * sorear made the Switch at 15
18:12:08 <rc-1> dibblego, i agree java has forever corrupted me :(
18:12:22 <malsyned> sorear: you started using Haskell when you were 15?
18:12:24 <dibblego> my son turned 6 yesterday
18:12:26 <SamB> dibblego: why would I worry about them seeing Java?
18:12:30 <sorear> malsyned: yes.
18:12:30 <SamB> ADD is inheritable...
18:12:36 <SamB> they would probably have ADD too...
18:12:44 <SamB> so they wouldn't get anywhere with Java anyway
18:12:45 <jcreigh> It seems like people only listen if you can fix the pain they know. So, the question is, what is the #1 problem faced by imperative programmers (as seen by themselves), and how does functional programming fix it?
18:12:50 <chessguy_away> hmm, i would think SICP is as close as it comes
18:12:52 <rc-1> it would be neat if they started with functional in college (scheme is good for starting)
18:13:02 <dibblego> SamB, you don;t think Java does damage; induces cognitive dissonance?
18:13:03 <sorear> strict, ech
18:13:07 * malsyned tries to remember what he was programming in at 15...
18:13:29 <sorear> malsyned: I'm 16 now
18:13:42 <malsyned> OK, that explains it.
18:13:51 <SamB> dibblego: not for people who can't pay attention to tutorials on it for that long, no
18:13:54 <monochrom> In other words, it is the same question as "is there a good doc that gets algebra across to kindergarten pupils?"
18:13:55 <malsyned> you've probably only been using it a little longer than me then.
18:14:06 <SamB> monochrom: there isn't?
18:14:13 <monochrom> There isn't.
18:14:13 <sorear> malsyned: 6m or so, at most a year
18:14:14 <malsyned> I think chessguy_away's got a point about SICP.  At very least, it's a good book for clearing away the cobwebs that Java installs.  It was for me anyway.
18:14:16 <SamB> oh, well, maybe you have to teach them to read first...
18:14:32 <monochrom> Exactly my point!
18:14:34 <rc-1> SICP
18:14:34 <siti> pfft haskell is more important than reading ;)
18:14:35 <rc-1> ?
18:14:42 <dibblego> SamB, who doesn't have that attention?
18:14:52 <monochrom> If they lack some background, they lack some background.
18:15:03 <malsyned> rc-1: Structure and Interpretation of Computer Programs by Sussman and Steele
18:15:03 <jcreigh> "The Little Schemer" is good book turning on the recursion light.
18:15:19 <SamB> jcreigh: the number one problem faced by imperative programmers? "who is changing this data structure!"
18:15:25 <malsyned> it's the MIT 6.001 Introductory Computer Science textbook.
18:15:35 <monochrom> After you have had enough experience with concrete numbers, you are ready to start contemplating abstract numbers (i.e. variables).
18:15:35 <malsyned> or at least, was.  I hear they're switching to Python.
18:15:46 <malsyned> ?where sicp
18:15:46 <lambdabot> http://mitpress.mit.edu/sicp/
18:16:02 <rc-1> when i googled that i just found this :): http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/
18:16:02 <SamB> malsyned: hmm, not sure thats a good idea.
18:16:09 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/wpe3
18:16:15 <SamB> python is okay but it lacks macros and a simple AST datatype...
18:16:31 <monochrom> After you have had enough experience with imperative programming (it contains some first-order functional programming already), you are ready to start contemplating higher-order functional programming.
18:16:41 <SamB> (it is a lot harder to write micro-python interpreters)
18:16:49 <monochrom> It is your experience, not any good doc, that prepares you.
18:16:54 <rc-1> and http://mitpress.mit.edu/sicp/full-text/book/book.html
18:16:55 <lambdabot> Title: Structure and Interpretation of Computer Programs
18:17:10 <malsyned> SamB: I think a lot of people agree with you.  Myself among them.  Being taught Java in Intro CS instead of Scheme makes me feel like I misspent my college tuition.
18:17:34 <monochrom> And I also agree with jcreigh.  A solution to their problems speaks for itself.
18:17:46 <NichardRixon> I'm going for the advanced first year CS courses, so I'm going to be taught scheme next year :)
18:17:50 <SamB> malsyned: oh, well, Python is lightyears better than that...
18:17:58 <Cale> NichardRixon: At Waterloo?
18:18:02 <NichardRixon> yep
18:18:05 <rc-1> malsyned, at my college the told us NOT to use an IDE either; so i almost quit programming after notepadding java for 2 months
18:18:10 <NichardRixon> as long as I'm accepted :<
18:18:11 <Cale> cool, I recently graduated from there
18:18:21 <malsyned> rc-1: are vim and emacs considered IDEs?
18:18:23 <sorear> yes
18:18:24 <NichardRixon> it's an excellent place
18:18:25 <Cale> NichardRixon: Take advanced section mathematics as well
18:18:27 <siti> yeah but how many companies use scheme vs java?
18:18:33 <sorear> maybe not vim, but definitely emacs
18:18:33 <NichardRixon> Cale, how come?
18:18:35 <SamB> siti: bad question
18:18:41 <Cale> NichardRixon: Because it's so much better. :)
18:18:42 <rc-1> malsyned, it was my first computer also, so i was using windows
18:18:43 <malsyned> sorear: I didn't mean for real, I meant at his IDE-hating school.
18:18:46 <SamB> better to ask how well the companies that do do
18:18:47 <sorear> vim is a good editor.
18:18:59 <siti> SamB: yes I shouldn't have added the ? mark :P
18:19:17 <malsyned> SamB: agreed.  Fortunately, the AI teacher at UofR is a real hard-ass (in a good way), and assigned "learn Common Lisp" as the first two-week assignment for his class.
18:19:22 <Cale> NichardRixon: It's maybe a little bit harder, but the quality is way higher, and you'll get used to proving things, and won't have to put up with so many stupid calculations.
18:19:25 <siti> what I meant was, there's probably alot more jobs down the java path than the scheme path
18:19:29 <NichardRixon> hrm.
18:19:33 <NichardRixon> I'll see what my dad thinks
18:19:39 <NichardRixon> he's the head of math there :D
18:19:55 <monochrom> Many companies use Java.  This means you should learn Java some time.  This does not mean a school should teach Java at the very beginning.
18:19:55 <Cale> NichardRixon: Even if they don't recommend you for it, you can show up at the first lecture and get signed in.
18:19:57 <dibblego> because programming is an extension of mathematics
18:20:03 <Cale> (or try the first week or something)
18:20:08 <NichardRixon> true
18:20:17 <Cale> dibblego: That's especially true at Waterloo.
18:20:19 <monochrom> After learning Haskell, you learn and use Java better.
18:20:24 <Cale> CS is a school in the Mathematics faculty.
18:20:31 <SamB> ooooooh
18:20:33 <SamB> neato
18:20:41 <dibblego> Cale, they oughtta be applauded somehow
18:20:41 <SamB> they should ALWAYS do that
18:20:42 <rc-1> comp sci is effectively von-numan-sci at my college! :(
18:20:59 <Cale> Yeah, waterloo is one of the only places which has an entire department of combinatorics.
18:21:04 <monochrom> Most people drive to work.  This does not mean you learn driving at 3yo.
18:21:07 <siti> I hear that few unis use haskell as their introduction to programming!
18:21:31 <Cale> Waterloo is infected with the co-op program though.
18:21:35 <malsyned> rc-1: mine too.  great systems group, but very von-neumann oriented.
18:21:40 <NichardRixon> Cale, what's wrong with that?
18:21:41 <monochrom> You spend 18 years learning walking, then they finally let you try driving.
18:21:45 <Cale> So they teach Java to most students, unfortunately.
18:21:48 <Gotaku> Anyone know if python's readline function counts \r as a new line?
18:21:49 <NichardRixon> oh :<
18:22:00 <Cale> NichardRixon: Corporate pressure.
18:22:03 <dibblego> siti, a local uni here is interested in teaching Haskell first up
18:22:04 <monochrom> By the same token, you should probably spend 18 years learning Haskell, then they finally let you try Java.
18:22:05 <Gotaku> I'm trying to figure out why this code works in python but not haskell.
18:22:07 <SamB> Cale: that is a really dumb reason to teach people Java
18:22:12 <Cale> SamB: Indeed.
18:22:35 <Cale> It used to be Modula-3
18:22:38 <SamB> they could surely find co-ops where people would not be expected to know Java
18:22:47 <Cale> But that was a while before I got there.
18:23:28 <siti> I got talking to a friend of a friend and she said she learnt haskell, I think it was in berlin
18:23:30 <Cale> Well, at least at the time when I was there, Java was the big language for getting hired.
18:23:44 <Cale> Haskell is an appropriate first language in university.
18:23:45 <siti> although she didn't think you could make proper programs with it :(
18:24:00 <Cale> Yeah, it demands good professors though.
18:24:05 <monochrom> The companies are now waking up from their dream.
18:24:14 <siti> there's to many people that think OO is awesome
18:24:25 <Cale> I like SICP's take on OO.
18:24:30 <siti> that's why they go with an OO language :(
18:24:32 <siti> sicps?
18:24:35 <monochrom> Their dream was: get unis to teach kids Java, then the kids will do wonder.
18:24:43 <malsyned> Cale: "If you really need it, write it yourself in an afternoon"?
18:24:44 <Cale> Structure and Interpretation of Computer Programs.
18:24:45 <siti> heh
18:25:05 <Cale> malsyned: not so much that part, but the idea that it's a powerful abstraction with serious downsides.
18:25:06 <siti> pfft no ebook form ;)
18:25:14 <siti> what are books :S
18:25:14 <Cale> siti: It's available online.
18:25:18 <SamB> monochrom: they discovered that unis are not good for teaching things like Java?
18:25:19 <siti> free?
18:25:21 <Cale> yes
18:25:27 <Cale> and video lectures for it too
18:25:29 <monochrom> The reality after all these years is: unis teach kids Java 1st year, kids drop out after that, get hired, does a lot of idiotic damage.
18:25:29 <siti> oh awesome, 10 points for that person
18:25:35 <Cale> http://mitpress.mit.edu/sicp/full-text/book/book.html
18:25:36 <lambdabot> Title: Structure and Interpretation of Computer Programs
18:25:42 <Cale> http://twb.ath.cx/~twb/canon/sicp/book-Z-H-04.html
18:25:43 <lambdabot> Title: Structure and Interpretation of Computer Programs
18:25:46 <siti> -10 points for a crappy background
18:25:47 <Cale> (that's a reformat)
18:25:53 <siti> http://www-mitpress.mit.edu/sicp/
18:25:55 <lambdabot> Title: Welcome to the SICP Web Site
18:26:03 <Cale> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ -- there's the video lectures.
18:26:06 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
18:26:16 <malsyned> oh man, the video lectures are great.  I've got to go back and finish them sometime.
18:26:17 <jcreigh> (The reformat is better. Formulas in PNGs instead of ugly GIFs.)
18:26:28 <malsyned> Not only are they educational, but they're so deliciously old-school!
18:26:50 <monochrom> old-school is good
18:26:52 <Procyon_> siti: you cannot dock SICP points.  That's sacriledge
18:26:58 <Procyon_> SICP++
18:26:58 <Gotaku> Are they useful even though I don't use scheme?
18:27:03 <siti> hah
18:27:07 <Cale> Gotaku: yes
18:27:15 <SamB> Gotaku: just read the damn title
18:27:24 <monochrom> All knowledge is useful.  All perspectives are useful.
18:27:25 <malsyned> Gotaku: they teach you scheme.  in about 45 minutes.  and then they go on to teach you, like, everything else.
18:27:26 <sorear> old books are fun
18:27:26 <Cale> They're not really about scheme.
18:27:30 <siti> the reason I wanted to learn haskell is I saw how crap OO was, it's just a hack on a problem ;)
18:27:40 <sorear> does @siti exist yet?
18:27:42 <sorear> @siti
18:27:43 <lambdabot> Maybe you meant: gsite wiki
18:27:44 <Cale> They're about computation. It just happens that they're expressing that computation in scheme.
18:28:05 <Cale> A lot of what's talked about foreshadows many of the features of Haskell.
18:28:28 <Cale> Haskell's a language filled with features that formalise things that scheme programmers were doing by hand for years.
18:28:42 <Procyon_> Gotaku: They use scheme because 1) It can do pure functional 2) It can teach imperative concepts without wrapping (which confuses noobs) and 3) The whole language can be defined in about 5 keywords.
18:28:48 <siti> yeah and doesn't have an ugly syntax ;)
18:29:03 <mauke> but I have a lisp allergy :(
18:29:07 <monochrom> The problem with many schools is they teach you too specialized hiring skills.  You know nothing else and you tend to lose perspectives and creativity.  You can just think of one way of doing things.
18:29:21 <malsyned> man, why's everybody always so down on lisp's syntax?  we've all mastered harder things in our lifetimes.
18:29:26 <Cale> Meh, getting over your lisp allergy only takes about 5 minutes of actually writing lisp code.
18:29:38 <mauke> Cale: for me, it was the other way around
18:29:39 <siti> malsyned: our eyes don't like it ;)
18:29:40 <sorear> monochrom: what ever happened to general ed / vocational ed?
18:29:49 <SamB> Cale: I don't think that works for CL
18:29:59 <Cale> Oh, common lisp has more problems.
18:30:03 <malsyned> Get an editor that colors them a color similar to the background color.
18:30:05 <mauke> Cale: I started writing lisp programs, and the syntax got more and more in my way
18:30:21 <Cale> Common lisp has semantics issues, not just syntax issues.
18:30:28 <sorear> isn't common lisp basically "Functional COBOL"?
18:30:31 <siti> has anyone here learned haskell without being a declarative programmer before hand :P
18:30:33 <SamB> Cale: well, its the same really
18:30:35 <mauke> common lisp has issues everywhere
18:30:46 <sorear> siti: define ...
18:30:56 <sorear> siti: I declared things in C
18:31:02 <Cale> I agree that better syntax helps readability though.
18:31:13 <sorear> siti: before I came I was slowly gravitating toward purity
18:31:15 <siti> e.g. learnt haskell without knowing lisp, scheme, haskell predcessors
18:31:18 <Cale> I prefer Haskell's syntax by far, and not just for its semantics. :)
18:31:25 <malsyned> not me.  I hacked through CL, scheme, OCaml, and a day or two of Erlang before I got to Haskell.
18:31:32 <monochrom> sorear: I don't know.  But as soon as one defines education = getting jobs (most parents after 1970's do) it goes down the drain.
18:31:42 <SamB> Cale: I mean, the package system is broken on the syntactical level!
18:31:43 <malsyned> Cale: I agree about Haskell's syntax.  It's a dream.
18:31:49 <mauke> siti: C, Perl, OCaml, C++, Haskell here
18:31:58 <siti> ok
18:32:14 <siti> I have a strange programming path
18:32:21 <sorear> I never spent more than a day or two with Lisps
18:32:29 <malsyned> oh, I was just doing languages that could be considered "declarative" in more than a trivial sense.  or used declaratively anyway.
18:32:32 <Cale> SamB: Would you consider the "functions are not the same as other values" thing a semantics or syntax issue?
18:32:34 <sorear> and heard of ML/Erlang through haskell
18:32:35 <Procyon_> I like the perens.  It shows the syntax tree explicitly.  You never have a precidence issue because there is no such thing.
18:32:41 <siti> Basic (well a weird kind) -> c (lowish level imperative) -> java (highish level OO) -> haskell
18:32:50 <siti> other languages but they're the main ones
18:32:52 <sorear> Procyon_: on the Moon there are no murderers.
18:33:08 <Procyon_> yup
18:33:09 <malsyned> Cale: functions are the same as other values.  you just have to jump through a hoop to get them into the same namespace.
18:33:13 <SamB> Cale: I'm talking about the fact that if you import a symbol from a package because it is the name of, say, a function you want, and then you try to define it as a variable, that will change the value in the package you imported from!
18:33:15 <mauke> Procyon_: to me, non-lisp syntax is easier to parse
18:33:17 <emu> sorear: not even the Man in the Moon?
18:33:41 <monochrom> It is a strange but true fact that: there exists a declarative language such that you learn it before you have learned declarative programming.
18:33:42 <Procyon_> sorear: Scheme is just dynamically typed haskell :)
18:33:43 <malsyned> mauke: you just passed the Turing test
18:33:50 <siti> I learnt haskell because 1) I was fed up with OO, 2) It was so difficult and my brain suffered so badly that it must be good for me, it's like exercise you know :P
18:34:23 <Gotaku> Fed up with OO?
18:34:47 <Procyon_> everyone is fed up with OO.
18:34:49 <monochrom> It is kind of like: you have to learn both the idea of algebra and a notation for algebra at the same time, probably even the notation before the idea.
18:34:51 <siti> :P
18:34:51 <NichardRixon> I started learning haskell because functional programming looked so screwed up that I was interested
18:34:59 <siti> heh
18:35:22 <monochrom> If you ask around, "has anyone understood the idea of algebra before you meet the notation", the answer is probably no one.
18:35:28 <Gotaku> I think it's more that everyone is fed up with C++ and it's concept of OO, or lack thereof.
18:35:36 <pbx> If I'm curious about what things in Haskell are designed to fix problems (if that's not too loaded a term) in ML & friends, do I just need to read the history paper that recently came out, or is there something more concise?
18:35:53 <malsyned> Functional programming to me was a splinter in my mind.  Ever since I wrote my first function (in Pascal, I believe) I just felt that they could be more than they were being allowed to be.
18:35:56 <Procyon_> I started learning haskell because everyone and their brother is talking about monads and type theory and pointing to haskell as an example of doing it right and I wanted to find out WTF they were talking about
18:36:04 <siti> Gotaku: no, more pure OO languages still are bad :(
18:36:19 <malsyned> It took me a long, long time to find my people, though.
18:36:26 <Procyon_> Gotaku: nope.  Java is WORSE than C++, and it's more OO pure.
18:37:13 <pbx> ?users
18:37:14 <lambdabot> Maximum users seen in #haskell: 322, currently: 275 (85.4%), active: 38 (13.8%)
18:37:21 <siti> well it's debatable if java < c++ or java > c++ :P
18:37:26 <SamB> Smalltalk is better than Java I think...
18:37:33 <Gotaku> Saying that something is more OO then C++ is pretty vague.
18:37:59 <siti> java is more pure though, you can't program totally like c in java ;)
18:38:00 <sorear> Smalltalk is less OO than C++.
18:38:05 <emu> java has gc..
18:38:10 <Procyon_> siti: I mean, Java is worse in it's OO problems.  C++ is not an OO language and doesn't force you to use the concept exclusively.
18:38:17 <pbx> Hm, perhaps I should rephrase my question...
18:38:23 <sorear> there is less total code in smalltalk than OO in C++
18:38:29 <Cale> I learned Basic, then C++ and Pascal (in parallel), C, Mathematica, Java, Perl, PHP (ugh) and Python, Scheme, then Haskell, then picked up some Ruby, Prolog, Icon and Forth. Then I did some stuff in Common Lisp. There's probably some others in there, but they're either minor languages or things I didn't really spend too much time on.
18:38:37 <Gotaku> It's been so long since I last used Java I think I've forgotten most of it.
18:38:39 <SamB> sorear: strange definition
18:38:41 <mbishop> Hmm, how do I make a program see a module? I made a module, and it loads fine in ghci, but trying to import it from another file says it can't find it
18:38:43 <Cale> Oh, yeah, recently I picked up smalltalk via squeak.
18:38:49 <SamB> wouldn't java win by default then?
18:38:53 <Cale> Smalltalk is pretty fun :)
18:39:05 <malsyned> Smalltalk and Prolog are the two languages I haven't tried extensively yet (prolog not at all) that I really want to.
18:39:13 <Cale> Only I can't imagine how anything really large would manage to function without types.
18:39:32 <Cale> Though I suppose people get by :)
18:39:36 <malsyned> Smalltalk because after using C++, C#, and Java, I want to finally learn what OO is all about.
18:39:39 <monochrom> mbishop: both files in the same directory?
18:39:40 <siti> prolog is a funny language :)
18:39:40 <Procyon_> Cale: through unit tests ;)
18:39:43 <Cale> malsyned: indeed
18:39:52 <mbishop> monochrom: yep
18:39:53 <Cale> Procyon_: yeah
18:40:02 <monochrom> And you are also in the same directory?
18:40:22 <Procyon_> Cale: Complex typeless Scheme programs are actually much easier to reason about than complex Typed C++ or Java programs I find.
18:40:32 <Cale> The cool thing about smalltalk is the way the environments work, more than the language itself.
18:40:54 <Cale> C++ and Java barely have types ;)
18:40:55 <siti> oh yes, to keep this on topic, is there any good tutorial on how to implement an instance of read without using "deriving".  The example code I see is disturbing :(
18:41:02 <Procyon_> Cale: Closures allow you to greatly seperate concepts.
18:41:05 <sorear> siti: yes
18:41:09 <sorear> er, no
18:41:09 <Cale> Procyon_: that's true
18:41:15 <siti> sorear: woah?
18:41:26 <mauke> http://sc.tri-bit.com/images/c/c9/126_Verb.gif
18:41:46 <mbishop> monochrom: yes
18:41:51 <monochrom> The importee has file name XYZ.hs, and it begins with "module XYZ where", and the importer says "import XYZ"?
18:41:51 <sorear> site: http://haskell.org/onlinereport/derived.html#sect10.4
18:41:52 <lambdabot> Title: The Haskell 98 Report: Derived Instances
18:42:00 <sorear> most readable example code I've seen.
18:42:25 <sorear> it's parsec, 1988 style
18:43:07 <araujo> hello
18:43:12 <sorear> hi.
18:43:29 <siti> it's very scary
18:43:39 <mbishop> monochrom: yes...oh I figured it out, ghci wasn't being run in the same directory heh
18:44:03 <Cale> There's not that much to it really.
18:44:03 <monochrom> nice
18:44:16 <Cale> Actually, it might be easiest to use ReadP
18:44:28 <Cale> readP_to_S :: ReadP a -> ReadS a
18:44:28 <Gotaku> Those Haskell video lectures from Germany are great... or rather they were before he started on the topic of defining Haskell formally.
18:44:36 <Cale> Gotaku: yeah :/
18:44:38 <monochrom> I use ReadP to implement Read instances.
18:44:49 <sorear> I use deriving :)
18:45:06 <SamB> sorear: you mean you make the compiler do it
18:45:08 <Cale> Yeah, I basically always use the derived instance.
18:45:26 <SamB> that would be *so* ugly for Data.Map
18:45:39 <Cale> Oh sure, I can see for something like that.
18:46:09 <jao> m
18:46:19 <sorear> it's a nice letter.
18:46:27 <Cale> But on the other hand, if you can implement Data.Map, you can probably implement a Read instance :)
18:46:31 <sorear> jao: I prefer 'l' personally.
18:46:49 <monochrom> I prefer 'h'
18:47:16 <jao> sorear, i really prefer \alpha
18:47:51 <monochrom> I really prefer α
18:48:08 <siti> :S
18:48:57 <billsb> Hi
18:49:07 <siti> 'lo
18:49:10 <malsyned> hey
18:49:42 <sorear> monochrom: YAY!
18:50:01 <sorear> monochrom: I thought my system couldn't handle unicode at all!
18:50:24 <sorear> is that utf8 or 8859-1?
18:50:31 <monochrom> utf-8
18:50:50 <sorear> dons: haskell synhl works
18:51:49 <kfish> λ○.
18:52:02 <malsyned> kfish: what was the second character?  all I got was a box.
18:52:08 <sorear> I got ??.
18:52:09 <kfish> malsyned, oh, a circle
18:52:11 <siti> I got a small circle :S
18:52:23 <malsyned> man, I gotta go home and get back on a real platform.
18:52:23 <kfish> could be from the japanese character set
18:52:48 <kfish> i realised that i can type α and λ easily if i use japanese input (arufa, ramuda)
18:53:21 <dons> sorear: oh!
18:53:27 <dons> oi. i should install vty then :)
18:53:44 * sjanssen wants to try the synhl
18:54:00 <dons> sjanssen: i updated fasta, nsieve and partial-sums today (they're in the process now)
18:54:13 <dons> some *very* fast numbers for partial-sums (like 40% faster)
18:54:14 <sorear> don't worry, it's still quite slow (50% cpu scrolling through the file)
18:54:33 <nornagon> U+25CB ○ WHITE CIRCLE
18:54:39 <dons> sjanssen: i'm semi-confident we can catch clean now
18:54:57 <dons> (this is so much easier, writing fast haskell, than it was before ghc 6.6 came out!)
18:55:00 <sjanssen> dons: nice.  The results should be updated in a day or so?
18:55:03 <dons> yeah
18:55:14 <dons> yesterday's sum-file and binary-sums went up
18:55:17 <dons> we jumped about 6 places
18:55:38 <dons> (av. now is 2.1x C
18:55:41 <dons> (speed wise)
18:56:15 <dons> i'm still staring at this and grinning like a maniac, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all ;)
18:56:18 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
18:56:18 <sorear> gah, I type ^X^C into yi
18:56:48 <dons> basically every entry needs updating to bang patterns though
18:56:52 <sjanssen> dons: is that entry cheating?
18:56:55 <dons> nope
18:57:05 <dons> (note the constant space overhead)
18:57:05 <siti> lol
18:57:07 <sjanssen> outstanding
18:57:23 <siti> you're such a bunch of cheats, the shootout code is hardly haskell ;)
18:57:26 <dons> it just uses the lazy bytestring improve representation of T !Strict [LazyTail]
18:57:39 <sorear>    0.8   Haskell GHC #5          1.29            90,880        270
18:57:41 <dons> siti, that's what's changing. the fast stuff is now reasonable haskell
18:57:49 <dons> whereas it used to be haskell for immortals
18:57:50 <sjanssen> oh, the previous one was cheating because it loaded the whole thing in memory
18:57:53 <siti> oh ok nice :)
18:57:57 <dons> yeah
18:58:30 <dons> but ghc generates perfect code when handed a !p :: Strict.ByteString
18:58:31 <siti> is there a large amount of room for making ghc better
18:58:38 <dons> siti, there is, yes.
18:58:40 <siti> e.g. could in the future it generate twice as fast code?
18:58:41 <sorear> dons: heh, we're faster than the illegal C program
18:58:43 <siti> ok
18:58:46 <dons> we'll catch Clean I think, with just ghc 6.6
18:58:52 <dons> but improving the native gen would be better still
18:58:53 <siti> :)
18:58:53 <Gotaku> illegal C program?
18:59:03 <SamB> so my suggestion worked ;-)
18:59:10 <dons> the C program looked find to me
18:59:14 <dons> fine.
18:59:50 <sorear> dons: see Interesting Alternative ... there is a C program listed
19:00:01 <dons> ah that one.
19:00:17 <dons> i'll post you the code that ghc generates for the illegal #5 entry
19:00:32 <dons> its really really nice
19:00:59 <sorear> dons: can you submit the one-liner sum-file?  that should easily win gzip
19:01:08 <siti> heh
19:01:29 <Gotaku> The language shootout needs some new computers.
19:01:39 <sorear> siti: iirc: main = interact $ show . sum . map read . lines
19:01:42 <siti> yeah 64bit with quad procs :D
19:02:00 <siti> what does interact do :S let me look it up
19:02:24 <sorear> siti: naw, 30bit with 64 processors!
19:02:26 <chessguy_away> @type interact
19:02:28 <lambdabot> (String -> String) -> IO ()
19:02:56 <sorear> how slow would Java be on a 30-bit cpu? :)
19:02:56 <chessguy> ?src interact
19:02:57 <lambdabot> interact f = do s <- getContents; putStr (f s)
19:03:01 <sjanssen> siti: a multi core machine would be really nice for Haskell programs
19:03:05 <siti> yeah, they need scalability :)
19:03:07 <sorear> (with fixed 32-bit ints and all that)
19:03:07 <siti> yeah
19:03:22 <siti> although my tests with parallel haskell is it has a way to go
19:03:25 <sjanssen> we could `par` Haskell to victory
19:03:45 <sjanssen> siti: yeah, it's still a bit tricky to use par well
19:03:45 <sorear> parMap ?
19:03:59 <Gotaku> I actually have a Haskell program on the language shootout from a while ago... the last time I tried learning Haskell before monads pissed me off.
19:04:03 <siti> even with par, I didn't get more performance when it's strategically placed :(
19:04:42 <malsyned> is there no hope of getting a compiler that just compiles regular haskell to multiple threads, inserting parallelism wherever possible?
19:05:07 <sjanssen> malsyned: it's tough for a compiler to figure out when parallelism is advantageous
19:05:09 <siti> well it's pretty difficult, how do you know when it's advantageous to use a new thread?
19:05:19 <siti> sjanssen: hah nice timing :P
19:05:21 <sorear> malsyned: that could be done, but it would be very slow
19:05:23 <SamB> sorear: probably not much faster than on a 18-bit CPU
19:05:47 <mbishop> Haha oh man, I totally missed all the replies to my post to reddit the other day
19:05:50 <SamB> malsyned: wherever possible would be overkill
19:05:54 <sorear> SamB: huh?  I'm talking java v. haskell here, and Java ints are 2 bits bigger than Haskell Ints
19:06:03 <SamB> sorear: oh, that
19:06:09 <SamB> I think that was so you could do what Yhc does
19:06:11 <mbishop> http://programming.reddit.com/info/12kv8/comments
19:06:13 <lambdabot> Title: Why do we still use C? (reddit.com)
19:06:28 <sorear> hence they would need to be software on my 30-bit Haskell machine :)
19:06:45 <malsyned> OK, now all the blocking bugs are in software I didn't write, so it's time to go home.  I'll catch you guys later.
19:08:28 <hpaste>  dons pasted "ghc core" at http://hpaste.org/273
19:08:31 <Gotaku> When did the language shootout start using ghc 6.6?
19:08:36 <dons> about a month ago
19:09:44 <Gotaku> dons, remember when I was working on my mandelbrot entry some time ago?
19:10:07 <siti> lol - "And instead you want to rewrite legacy C code in Haskell? Are you mad? I work with PhDs who can't correctly write 3 lines of C++ code and you expect this kind of people to learn functional programming in Haskell? We still use C for a reason: it's easy to understand and to apply the usual concepts to this language."
19:10:14 <dons> Gotaku: yeah
19:10:42 <Gotaku> I hada different nick then though.
19:10:52 <siti> arg dynamic languages = crappy performance and unsafe :(
19:11:02 <siti> some one recommends ruby on that reddit site
19:11:17 <Gotaku> I should update it to use ByteString.
19:11:42 <monochrom> There are too many PhDs.
19:12:02 <monochrom> When anything becomes popular it goes down the drain.
19:12:21 <monochrom> There is some wisdom behind Haskell's "avoid success".
19:12:35 <siti> heh
19:12:47 <monochrom> Of course in that context "success" means "popular" nothing else.
19:13:06 <SamB> yeah
19:13:25 <SamB> how else has success been defined for general-purpose programming languages?
19:13:25 <monochrom> And of course we all want Haskell to be successful if it means most abstract code and best performance.
19:13:31 <Gotaku> Too many PhDs?
19:13:36 <siti> did someone here write this, http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html ?
19:13:39 <lambdabot> Title: The Perils of JavaSchools - Joel on Software, http://tinyurl.com/9ewrh
19:14:00 <siti> (people were complaining about java in schools)
19:14:15 <sjanssen> I think Haskell could stand to be more popular
19:14:24 <sorear> 322 is too many
19:14:33 <siti> my bet is it will take off in 5 years ;)
19:14:35 <monochrom> Yeah currently it's ok.
19:14:57 <siti> lots of people are seeing functional programming taking off, especially perl guys after pugs
19:15:28 <sjanssen> more popularity should correspond to more and better libraries
19:15:48 <siti> yeah, that's what I need now, the new gtk2hs solved all my problems
19:15:54 <siti> I just want more gnome bindings :D
19:15:55 <monochrom> Currently its popularity stays at "I want to learn Haskell, I know it's hard but I'll bite it!" which is good because such a person won't ask for watering down.
19:16:35 <sjanssen> siti: you want more bindings?  Then step up to the plate and write them :)
19:16:48 <siti> sjanssen: yes I will probably have to heh
19:17:24 <emk> I'm trying to represent infinity in Haskell, and I need to know whether I'm nuts:
19:17:27 <emk> http://www.randomhacks.net/articles/2007/02/02/divide-infinity-by-2
19:17:29 <lambdabot> Title: Haskell: What happens when you divide infinity by 2?, http://tinyurl.com/2lqg96
19:17:39 <sorear> emk: fix Succ ?
19:17:47 <sorear> note: unary is needed.
19:18:06 <emk> sorear: infinity = Succ infinity, which should be roughly equivalent.
19:18:48 <chessguy> that javaschools article is nice
19:18:52 <emk> I think I know what I'm talking about, but it's so hard to be sure some days...
19:19:09 <sorear> emk: one way to think of this:
19:19:15 <monochrom> Yes, to be sure your theory is consistent, you need to construct a model.
19:19:46 <sorear> emk: 0 -> _|_  1 -> Succ _|_  2 -> Succ (Succ _|_)   is a continuous function from naturals to haskell terms.
19:20:37 <sorear> emk: in this, fix Succ is the lub of map myFun [0..] , thus myFun (lub [0..]) = myFun infty, or something like that.
19:20:57 <siti> "It's hip, the recruiters who use "grep" to evaluate resumes seem to like it" talking about java
19:20:59 <siti> :)
19:21:03 <sorear> I understand stuff like this intuitively, but the formalism still goes over my head :(
19:21:52 <emk> sorear: I'm still trying to puzzle out ωCPO.
19:21:56 <sorear> s/continuous/monotonic/
19:22:10 <sorear> emk: I'm just *guessing* about ?CPU.
19:22:24 <sorear> is ? shorthand for category?
19:22:41 <monochrom> First, I must remind you that the problem with all naive questions like "what is infinity+1" is that you haven't thought about "what is infinity?"
19:22:44 <monochrom> It's like asking "what's STD" before you ask "what's diesease"?
19:23:02 <sorear> what is diesease? :p
19:23:15 <siti> hah
19:23:21 <SamB> is it a new kind of fuel?
19:23:47 <monochrom> Next, you do have some haskell code, so you have answered "what's infinity", at least you have one version.
19:23:56 <emk> monochrom: I'm defining infinity as the infinite total value Succ (Succ (Succ ...))) in category CPO.
19:24:11 <emk> Specifically, the cardinals.
19:24:19 <monochrom> Using your definition, "what is infinity+1" is like "what is (repeat True)++[False]"
19:25:11 <monochrom> There is probably no Haskell program that can distinguish between (repeat True) and (repeat True ++ [False])
19:25:17 <sorear> monochrom: was I talking nonsense?
19:25:20 <emk> monochrom: So it's the final coalgebra K_1+Id
19:25:47 <sorear> monochrom: (>14) . length :p
19:26:15 <emk> The final coalgebra 1+a -> a in CPO,
19:26:29 <emk> monochrom: Which seems like a natural match for Haskell.
19:26:38 <sorear> gah. coalgebras. why did it have to be coalgebras?
19:26:57 <sorear> I do not know what a coalgebra is yet.  More studying!
19:26:58 <monochrom> Because some kind of infinite stream is involved.
19:27:10 <emk> sorear: 'Cause they're infinite, and all these Haskell papers keep talking about them. ;-)
19:28:58 <monochrom> Your conclusion about your_infinity+1 and your_infinity div 2 is correct.
19:28:59 <emk> monochrom: I guess my question is something like, "Hey, am I so confused that I should just delete this code and crawl into a hole before anyone notices?"
19:29:14 <emk> monochrom: Many, many thanks for taking a look!
19:29:17 <monochrom> You are not confused.  Your theory is sound.
19:29:24 <sorear> emk: /agree monochrom
19:29:34 <SamB> emk: are you talking about ordinals?
19:29:59 <emk> SamB: Cardinals, I think. I'd love to see a Haskell version of the ordinals.
19:30:02 <sorear> SamB: AIEEE!  I do *not* understand ordinals :(
19:30:14 <SamB> sorear: me either
19:30:19 <SamB> but I think they were made for this
19:30:24 <Cale> Hi
19:30:24 <monochrom> I disagree with "infinity is a slippery thing".  infinity is an ambiguous term.  nothing slippery, just ambiguous.  ever heard anyone, even us, saying "OO is slippery"?  No, because it's an ambiguous term.
19:30:25 <sorear> 0... o< 0, o< 1, o< o< 0, I'm fine with...
19:30:43 <Cale> hm?
19:30:55 <Cale> What's up?
19:31:08 <SamB> monochrom: it means more than OO at least
19:31:17 <SamB> infinity means that something non-finite is going on!
19:32:02 <Cale> People need help understanding ordinals?
19:32:05 <SamB> there is no such negative statement for OO
19:32:07 <emk> monochrom: Dunno, I find diagonalization a little "slippery", if only because it keeps sliding away from me when I think I can explain it rigorously...
19:32:20 <Cale> Which diagonalisation?
19:32:22 <SamB> sorear: do you need to understand ordinals?
19:32:29 <Cale> The one for the real numbers is not so bad.
19:32:31 <SamB> diagonalization?
19:32:35 <SamB> how about...
19:32:43 <monochrom> OO means that some encapsulation is going on.
19:32:48 <beelsebob> siti: tis a good article that
19:32:58 <emk> http://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument
19:33:00 <beelsebob> sums up my thoughts on the subject reasonably accurately
19:33:05 <siti> that perils of java schools right?
19:33:11 <beelsebob> yeh
19:33:27 <siti> yeah it's quite true that >50% of people getting CS degrees are noobs :(I
19:33:48 <chessguy> siti, >>
19:33:50 <siti> you just know they'd actually do more harm to a project then good even if you payed them 0
19:33:59 <Cale> Suppose we had a list of all real numbers in the interval [0,1), using the convention that if a number has two possible expansions, then the one with all 9's at the end will be in the list. Construct a new number not in the list by making its kth digit equal to 3 if the kth digit of the kth number isn't 3, and 7 otherwise.
19:34:02 <siti> although they might supply coffee  ;)
19:34:05 <siti> or whatever
19:34:15 <monochrom> If you think "non-finite" is in any way less ambiguous than "encapsulation"...  Contemplate that the set {x | x is real, 1<=x<=2} is both a "non-finite" set and a "finite" interval.
19:34:21 <Cale> Then the number is not the kth number for any k, because it differs in the kth place.
19:34:30 <siti> I think we need a #haskell-ridiculous-formal channel?
19:34:35 <emk> s/slippery thing/subtle concept/
19:34:41 <sorear> SamB: no I don't *need* to.  but a nice explanation would be appreciated...
19:34:52 <sorear> is there a #mathematical-arcana ?
19:34:57 <SamB> hmm...
19:35:05 <SamB> @hoogle [[a]]->[[a]]
19:35:05 <emk> Yay, ordinals! Yay, arcana!
19:35:06 <lambdabot> List.transpose :: [[a]] -> [[a]]
19:35:09 <Cale> There are many infinities in mathematics. There is not really any universal concept which they all embody.
19:35:16 <emk> monochrom++
19:35:17 <sorear> and yes I've heard the 1st 2nd 3rd analogy
19:35:31 <Cale> Simply the idea that they are "large" in some way.
19:35:55 <SamB> hmm.
19:36:13 * SamB can't figure out how to do diagonalization in a one-liner without using !! :-(
19:36:27 <sorear> add an abstract object named "w" to the integers, and order the integers by (Finite i) > (Finite j) = i > j ; Infinite > Finite j = True ; Finite j >Infinite =  False ; Infinite > Infinite = False
19:36:44 <SamB> hmm, oh, wait, I can prove that diagonalization is O(n^2)!
19:36:49 <sorear> err, order Z U {w}
19:36:56 <Cale> For example, the point you add in the one-point compactification of the complex plane (turning it into a sphere), is often called infinity, but that doesn't really have anything at all to do with cardinal or ordinal infinities.
19:36:58 <SamB> also Omega(n^2)
19:37:00 <monochrom> emk: Have you heard of Hilbert's Hotel or something?  It has aleph0 rooms.  One day it is full, and some new customers arrive.  The manager says "no problem! just need to relocate existing residents..."
19:37:21 <SamB> monochrom: heh
19:37:31 <SamB> how about it has infinite customers...
19:37:38 <SamB> and just as many arrive...
19:37:38 <Cale> You can even accomodate countably infinite new customers.
19:37:45 <sorear> Cale: gah. I was thinking about the one-point compactification just then with my construction of infinity
19:37:50 <SamB> so it moves the existing ones to even-numbered rooms
19:37:59 <monochrom> After all my drivel, and you still say "infinite" ambiguously?
19:38:00 <emk> monochrom: Ouch, that hurts. :-)
19:38:15 <SamB> okay so it has n customers
19:38:22 <sorear> SamB: sure. it can even accomodate countably many countably infinite groups!
19:38:27 <SamB> s/n/aleph/
19:38:30 <monochrom> There is no problem even with aleph0 newcomers.
19:38:33 <chessguy> well, if you have a hotel with an infinite number of rooms....
19:38:45 <SamB> chessguy: yes. but they are all full already!
19:38:45 <sorear> does o< look like aleph to anyone but me?
19:38:47 <emk> I'd hate to make the beds...
19:38:53 <SamB> sorear: sure
19:38:57 <chessguy> :)
19:38:59 <SamB> it looks kinda similar
19:39:02 <monochrom> "Every existing resident, if you're in room x now, please move to room 2x".
19:39:12 <Cale> Even if the hotel already is full, it can accomodate a countable infinity of buses of new customers each packed full with a countably infinite number of seats.
19:39:15 <SamB> not that I know that the hell o< is, but I'm guessing it is an ordinal
19:39:20 <chessguy> map (\x -> 2*x) customers
19:39:22 <sorear> but what if for some x I'm *not* in room x?
19:39:41 <sorear> SamB: o< 0 is the smallest nonfinite cardinal
19:39:49 <SamB> sorear: you don't move to that x*2?
19:39:53 <SamB> sorear: oh.
19:39:55 <Cale> sorear: that's awfully strange notaton
19:39:57 <Cale> notation*
19:40:05 <sorear> SamB: it's what most people are talking about when they say infinity
19:40:06 <SamB> isn't aleph a cardinal too?
19:40:07 <monochrom> "for some x I'm *not* in room x" is tautologically true and irrelevant.
19:40:14 <maskd> but what if you have infinite buses, each with infinite passengers?
19:40:17 <Cale> Aleph_0 is the smallest infinite cardinal.
19:40:25 <SamB> yeah.
19:40:26 <Cale> ℵ
19:40:28 <SamB> so they are identical
19:40:36 <sorear> Cale: what is strange about my notation?
19:40:42 <Cale> o< 0 ?
19:40:43 <sorear> Cale: o< is an ascii aleph
19:40:59 <SamB> it doesn't much look like |\|
19:40:59 <Cale> That's odd :)
19:41:01 <monochrom> o< looks like a match man laid sideways.
19:41:14 <Cale> o< looks a lot more like an alpha
19:41:16 <Cale> α
19:41:17 <monochrom> o-<-<
19:41:19 <SamB> not that |\| looks much like aleph
19:41:26 <SamB> oooooh
19:41:28 <SamB> stick figure!
19:41:29 <Cale> |\| is closer than o< I think
19:41:38 <SamB> Cale: yes
19:41:43 <sorear> that's odd, my linear algebra teacher told me aleph looked like a fish
19:41:44 <monochrom> This is my father o-<-<   This is my mother o-<-<   This is me o<
19:41:50 <Cale> sorear: no, that's alpha
19:41:57 <Cale> not aleph
19:42:01 <SamB> sorear: ... don't take bio with him!
19:42:03 <Plareplane> how do you type in your alphas in irc? or do you just paste them in from elsewhere
19:42:05 <Cale> aleph is the first letter of the Hebrew alphabet
19:42:13 <Cale> Plareplane: SCIM
19:42:13 <sorear> Cale: well I know he was talking about infinite cardinals...
19:42:20 <Cale> I type \alpha
19:42:27 <SamB> Cale: woooooo!
19:42:29 <SamB> how do I do that?
19:42:35 <SamB> what package is it?
19:42:36 <Cale> or press both alt keys, which swaps my keyboard into Greek
19:42:49 <Cale> It's called SCIM, you need the SCIM-extras package.
19:42:59 <sorear> Cale: how does one enable decent (1Mchar) fonts in linux?
19:43:10 <sorear> not the 256char fonts I'm using now
19:43:11 <SamB> Cale: I'm not seeing a scim-extras package
19:43:28 <sorear> fbcon is used, no vga limits for me
19:43:32 <Cale> SamB: uhh... scim-tables-additional ?
19:43:35 <Cale> yeah
19:43:38 <Cale> hold on
19:43:50 <SamB> Cale: that one does exist
19:44:02 <SamB> ah. yes. LaTeX
19:44:26 <SamB> now all I have to do is get SCIM to start when I start X
19:44:41 <sorear> what? start X?
19:44:51 <SamB> sorear: yes!
19:44:53 <sorear> i'd rather switch to house!
19:45:00 <SamB> heh
19:45:22 <SamB> house doesn't have libc, and therefore can't run GHC
19:46:10 <sorear> I thought GHC was pure haskell?
19:46:17 <SamB> what about the RTS?
19:46:24 <SamB> oh
19:46:30 <SamB> GHC also requires a filesystem, you know?
19:46:57 <sorear> content: haskell reiser3, minimum LOC
19:47:10 <SamB> hmm?
19:47:12 <SamB> reiser?
19:47:14 <SamB> what?
19:47:29 <sorear> SamB: it's one of the standard linux filesystems
19:47:41 <SamB> house has a filesystem now?
19:47:44 <sorear> SamB: if you've reinstalled your system in the last two years
19:47:46 <mbishop> Halfs?
19:48:25 <sorear> I'd rather just have a good module system :)
19:49:24 <emk> Apparently reddit has spies in #haskell. My article is up already: http://programming.reddit.com/info/12mm7/comments
19:49:27 <lambdabot> Title: Dividing infinity by 2 (implemented in Haskell) (reddit.com)
19:49:33 * SamB wishes XMMS could tell how much he liked a song automatically
19:49:44 * emk looks around slowly
19:50:03 <SamB> emk: well it isn't like they are anonymous spies...
19:50:08 <pbx> I was gonna say.
19:50:23 <emk> SamB: ;-)
19:50:34 <SamB> wojtekk: hi spy!
19:51:19 <SamB> @seen wojtekk
19:51:19 <lambdabot> wojtekk is in #haskell. I don't know when wojtekk last spoke.
19:51:25 <SamB> okay, he never speaks?
19:51:26 <Cale> SamB: I basically never even drop specific songs on XMMS, I only listen to things at the album level.
19:51:36 <monochrom> dons is the number 1 spy for reddit
19:51:40 <SamB> Cale: that doesn't work for OCRemixes
19:52:29 <SamB> Cale: and I meant more based on how much head-bobbing and such I do
19:52:35 <SamB> or brainwaves or something
19:52:43 <Cale> hehe
19:52:49 <chessguy> zipWith (concatMap (,)) [[1,2],[3,4]] [1,2,3,4]
19:52:51 <Cale> Eye tracking behaviour.
19:52:54 <chessguy> > zipWith (concatMap (,)) [[1,2],[3,4]] [1,2,3,4]
19:52:55 <lambdabot>      Expecting a function type, but found `[b]'
19:52:55 <lambdabot>       Expected type: [a] -> b...
19:54:21 <beelsebob> chessguy: what's that supposed to do?
19:54:31 <chessguy> > zipWith (,) [[1,2],[3,4]] [1,2,3,4]
19:54:32 <lambdabot>  [([1,2],1),([3,4],2)]
19:55:02 <chessguy> i want the result to be [(1,1),(2,2),(3,3),(4,4)]
19:55:10 <chessguy> (for this input
19:55:32 <SamB> Cale: that might work if I looked at music
19:55:53 <dons> hey emk
19:56:02 <emk> dons: Hello!
19:56:12 <chessguy> wait
19:56:15 <chessguy> that's nit right
19:56:15 <beelsebob> > let f x y = zipWith (,) (concat x) y in f [[1,2],[3,4]] [1,2,3,4]
19:56:17 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
19:56:28 <Cale> SamB: it would probably be able to detect headbobbing
19:56:35 <chessguy> hmm, i'm confusing myself
19:56:41 <zebr> Hi. :)  Could someone out there help me with trying to get GHC to work on OS X 10.4?  I ran the installer but can't figure out what to do next.
19:57:04 <beelsebob> zebr: it should just work (TM) now
19:57:16 <beelsebob> zebr: did you already install the XCode tools?
19:57:19 <chessguy> sorry, what i gave isn't even valid input for what i want
19:57:52 <zebr> beelsebob: I think so?  XCode is up and running on my system, but when I go to make new projects and files with it it acts as if it knows nothing about Haskell.
19:58:07 <beelsebob> zebr: sure, XCode won't know about it
19:58:11 <sorear> dons: besides incrementalness and optionality, is anything else needed before synhl is considered working?
19:58:13 <beelsebob> you need to use it at the command line
19:58:33 <beelsebob> zebr: open /Applications/Terminal.app and type ghc, and it'll give you a usage string
19:58:42 <sjanssen> zebr: I believe there's some software that will let you use ghc in XCode
19:58:46 <sorear> in the sense of: 19:07:16 <dons> super mega karma if you get this working...
19:58:51 <sorear> greed admitted :)
19:58:52 <zebr> ah!  okay -- I tried that too and it pretended like it knew nothing about ghc.
19:59:08 <zebr> just says "command not found"
19:59:25 <allbery_b> ghc is a compiler, not an IDE.  I doon't thinkl there's anything publicly released to add haskell support to xcode
19:59:44 <allbery_b> if youw ant an IDE, best bet is Eclipse + http://eclipsefp.sourceforge.net
19:59:46 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
19:59:51 <zebr> sjanssen: I'm certainly not married to XCode (it kind of irks me, a bit, frankly -- I'd just as soon use a text editor) -- I just can't get the compiler to work.
20:00:11 <dons> sorear: hmm, it works and doesn't noticeably slow things down?
20:00:14 <allbery_b> where did you install it?  I think the default is /usr/local which might not be on your path by default
20:00:19 <beelsebob> zebr: I think I know what's up
20:00:26 <zebr> ooh, shoot, beelsebob :)
20:00:30 <beelsebob> in fact allbery_b just came to the same conclusion as me
20:00:35 <dons> sorear: and some screenshots running in the console/xterm :)
20:00:47 <chessguy> > map (\x -> (x,2)) [1..4]
20:00:48 <lambdabot>  [(1,2),(2,2),(3,2),(4,2)]
20:00:51 <beelsebob> export PATH=$PATH:/usr/local/bin
20:00:55 <zebr> aaah.  I have no flippin' idea where the installer put the binaries.
20:00:56 <zebr> okay.
20:00:57 <Notostraca> how do I get kosmikus 's attention...
20:01:01 <beelsebob> then try it
20:01:10 <beelsebob> and probably stick that line in your .bashrc
20:01:16 <zebr> that did it!
20:01:20 <zebr> beelsebob++
20:01:21 <sorear> dons: ok, will fix speed (100% cpu and noticably laggy scrollling down a 12K file)
20:01:34 <zebr> thanks so much!  now for all sorts of tutorial goodness.
20:01:47 <chessguy> is it possible to nest lambda functions ?
20:01:49 <sorear> yes
20:01:52 <beelsebob> zebr: np, I guess that the installer should adjust that for you
20:01:55 <beelsebob> chessguy: absolutely
20:01:59 <sorear> > (\x -> (\y -> x + y)) 2 3
20:02:01 <lambdabot>  5
20:02:03 <beelsebob> it's possible to nest all kinds of expressions
20:02:10 <beelsebob> mmm... curry
20:02:18 <dons> > (\x -> \y -> x + y)  2 2 -- expressions forever!
20:02:20 <lambdabot>  4
20:02:59 <beelsebob> > (\x -> (\y -> x ++ y)) "Mmmm... " "Curry"
20:03:01 <lambdabot>  "Mmmm... Curry"
20:06:52 <chessguy> hmm, i want foo [[1,2],[3,4],[5,6]] [1,2,3] = [(1,1),(2,1),(3,2),(4,2),(5,3),(6,3)]
20:07:46 <beelsebob> > zipWith (flip (map (,)) [[1,2],[3,4],[5,6]] [1,2,3]
20:07:46 <lambdabot>  Parse error
20:07:50 <beelsebob> oops
20:07:53 <beelsebob> what I do
20:07:59 <beelsebob> oh... missing bracket
20:08:06 <beelsebob> > zipWith (flip (map (,))) [[1,2],[3,4],[5,6]] [1,2,3]
20:08:07 <lambdabot>      Expecting a function type, but found `[b]'
20:08:07 <lambdabot>       Expected type: [a1] -> ...
20:08:10 <beelsebob> bugger
20:08:22 <dons> prize for the first list monad implementatoin
20:09:04 <beelsebob> > zipWith (\x y -> map ((,) y) x) [[1,2],[3,4],[5,6]] [1,2,3]
20:09:06 <lambdabot>  [[(1,1),(1,2)],[(2,3),(2,4)],[(3,5),(3,6)]]
20:09:13 <sjanssen> > (\xs ys -> do x <- xs; y <- ys; z <- x; return (y, x)) [[1,2],[3,4],[5,6]] [1,2,3]
20:09:13 <beelsebob> oops, missing a concat
20:09:14 <lambdabot>  [(1,[1,2]),(1,[1,2]),(2,[1,2]),(2,[1,2]),(3,[1,2]),(3,[1,2]),(1,[3,4]),(1,[3...
20:09:16 <sorear> dons: (1) the code as it exists is not fast enough to rehilight screen-sized blocks of text in real time; would a solution based on profiling and tuning be acceptable?  (after incrementalness fixes multi-screen perf of course); (2) my approach features a large time/space tradeoff; how important is memory use on large files?
20:09:20 <sjanssen> > (\xs ys -> do x <- xs; y <- ys; z <- x; return (y, z)) [[1,2],[3,4],[5,6]] [1,2,3]
20:09:22 <lambdabot>  [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2),(1,3),(1,4),(2,3),(2,4),(3,3),(3,4),(1,...
20:09:33 <beelsebob> > concat $ zipWith (\x y -> map ((,) y) x) [[1,2],[3,4],[5,6]] [1,2,3]
20:09:35 <lambdabot>  [(1,1),(1,2),(2,3),(2,4),(3,5),(3,6)]
20:09:58 <beelsebob> chessguy: good enough?
20:10:09 <beelsebob> oh no, back to front
20:10:18 <beelsebob> > concat $ zipWith (\x y -> map (y (,)) x) [[1,2],[3,4],[5,6]] [1,2,3]
20:10:19 <lambdabot>        add an instance declaration for (Num ((a1 -> b1 -> (a1, b1)) -> a -> b...
20:10:35 <beelsebob> > concat $ zipWith (\x y -> map ((flip (,)) y) x) [[1,2],[3,4],[5,6]] [1,2,3]
20:10:37 <lambdabot>  [(1,1),(2,1),(3,2),(4,2),(5,3),(6,3)]
20:10:40 <beelsebob> there we go
20:11:12 <sorear> > (\xs ys -> liftM2 (,) ys (join x)) [[1,2],[3,4],[5,6]] [1,2,3]
20:11:13 <lambdabot>   Not in scope: `x'
20:11:18 <sorear> > (\xs ys -> liftM2 (,) ys (join xs)) [[1,2],[3,4],[5,6]] [1,2,3]
20:11:19 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
20:11:24 <beelsebob> hehe, nice
20:11:28 <beelsebob> well no
20:11:29 <beelsebob> not nice
20:11:33 <beelsebob> really really really horrible
20:11:38 <beelsebob> but quite fun
20:11:41 <sorear> @pl (\xs ys -> liftM2 (,) ys (join xs)) [[1,2],[3,4],[5,6]] [1,2,3]
20:11:42 <lambdabot> liftM2 (,) [1, 2, 3] (join [[1, 2], [3, 4], [5, 6]])
20:11:46 <sorear> @pl (\xs ys -> liftM2 (,) ys (join xs))
20:11:47 <lambdabot> flip (liftM2 (,)) . join
20:11:51 <dons> sorear: hmm, just normal sized files is ok for now.
20:12:00 <dons> do a bit of tuning, if the algorithm isn't so optimal
20:12:16 <beelsebob> @pl concat $ zipWith (\x y -> map ((flip (,)) y) x)
20:12:16 <lambdabot> join (zipWith (flip (map . flip (,))))
20:12:21 <sorear> dons: tuning here == profiling informed strictness
20:12:35 <sorear> ie not algorithmic
20:12:42 <dons> right.
20:12:55 <dons> that's what i'm suggesting. get what you've got doing good-enough for files < 5k
20:13:18 <dons> use your judgement: would you be happy using it? if not, optimise and repeat
20:13:59 <chessguy> > flip (liftM2 (,)) . join [[1,2],[3,4],[5,6]] [1,2,3]
20:13:59 <lambdabot>  Couldn't match `(->) t' against `[]'
20:14:09 <sorear> dons: I suppose I could just try to hack using it for an hour and check for gum/lip damage :)
20:14:21 <chessguy> > (flip (liftM2 (,)) . join) [[1,2],[3,4],[5,6]] [1,2,3]
20:14:22 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
20:14:42 <chessguy> oh that's not right
20:16:28 <Gotaku> Hey dons, you around?
20:16:38 <beelsebob> chessguy: no, but join (zipWith (flip (map . flip (,)))) is
20:16:54 <beelsebob> or more nicely... concat $ zipWith (\x y -> map ((flip (,)) y) x)
20:18:43 <sorear> dons: Gotaku: dons only responds at bol.  Just like "Hey @ you around" doesn't work.
20:18:47 <SamB> S = { P | P ∉ P }
20:18:54 <SamB> Hmm. I guess it works?
20:19:08 <SamB> ℵ_0
20:19:13 <SamB> yeah
20:19:20 * SamB got LaTeX-mode to work
20:19:27 <sorear> hurray!
20:20:21 <Gotaku> sorear: uh, what?
20:20:29 <beelsebob> SamB: rofl, so what, you type in latex, and out comes nice unicode?
20:20:53 * sjanssen wonders if beelsebob really rolled on the floor
20:21:04 <beelsebob> wouldn't you like to know sjanssen
20:21:27 <emu> > map (\[a,b] -> (a,b)) $ sequence =<< zipWith (\a b -> [a,[b]]) [[1,2],[3,4],[5,6]] [1,2,3]
20:21:28 <SamB> beelsebob: well, stuff like \ni -> ∋
20:21:29 <lambdabot>  [(1,1),(2,1),(3,2),(4,2),(5,3),(6,3)]
20:21:34 <SamB> but I'm not too good at working it yet
20:21:46 <Korollary> ?seen dons
20:21:46 <lambdabot> dons is in #happs, #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 8m 28s ago.
20:21:53 <beelsebob> SamB: so what happens if you try to do \frac{1}{5}
20:22:16 <SamB> ⅕
20:22:18 <SamB> well.
20:22:35 <SamB> that was \frac15
20:22:55 <sjanssen> apparently 1/5 is a Unicode character?
20:23:05 <SamB> or somtehing like that!
20:23:21 <SamB> U+2155 VULGAR FRACTION ONE FIFTH
20:23:23 <SamB> how vulgar
20:23:29 <beelsebob> what about \frac{imafish(x)}{jam + \frac{1}{5}}
20:23:32 <SamB> % unicode ⅕
20:23:38 <SamB> is how I got that
20:24:04 <SamB> ⅟{1}{5} (thats from \frac15)
20:24:08 <SamB> er.
20:24:19 <SamB> \frac{1}{5}
20:24:19 <SamB> sorry
20:24:22 <beelsebob> heh
20:24:30 <SamB> hey, habbits die hard
20:24:30 <beelsebob> yeh, apple agree on the naming
20:24:37 <beelsebob> there must be some standard naming thing
20:24:39 <SamB> its a standard you know
20:24:55 <beelsebob> yeh, I just never expected the names to be standard
20:25:00 <chessguy> > (flip (liftM2 (,)) . join) [[1,2],[],[5,6]] [1,2,3]
20:25:02 <lambdabot>  [(1,1),(1,2),(1,5),(1,6),(2,1),(2,2),(2,5),(2,6),(3,1),(3,2),(3,5),(3,6)]
20:25:02 <SamB> there are like PDFs and PDFs of pictures and names
20:25:08 <SamB> also HTMLs of names
20:25:09 <chessguy> oops
20:25:14 <SamB> and text databases of names
20:25:25 <chessguy> concat $ zipWith (\x y -> map ((flip (,)) y) x) [[1,2],[],[5,6]] [1,2,3]
20:25:32 <SamB> not sure how standard the conscript stuff is...
20:25:35 <chessguy> > concat $ zipWith (\x y -> map ((flip (,)) y) x) [[1,2],[],[5,6]] [1,2,3]
20:25:37 <lambdabot>  [(1,1),(2,1),(5,3),(6,3)]
20:26:20 <beelsebob> chessguy: so essentially you want to encode a list of lists as a single list of items paired with which list they occured in?
20:26:27 <chessguy> beelsebob, yes
20:26:46 <beelsebob> good good, glad I implemented the right thing :P
20:27:28 <emu> > map (\[a,b] -> (a,b)) $ sequence =<< zipWith (\a b -> [a,[b]]) [[1,2],[3,4],[5,6]] [1,2,3] -- ?
20:27:30 <lambdabot>  [(1,1),(2,1),(3,2),(4,2),(5,3),(6,3)]
20:27:43 * SamB plays with the japanese input... ドキドキパニキ is the game that became SMB2, if I am not mistaken
20:28:00 <SamB> ｔｈｅｓｅ　ｆａｔ　ｌｅｔｔｅｒｓ　ａｒｅ　ｓｔｒａｎｇｅ...
20:28:14 * SamB is almost surprised unicode has those...
20:28:17 <emu> i really really need to sort out utf8 support
20:28:33 <SamB> emu: have I scrambled your screen?
20:28:38 * beelsebob pokes SamB wint some randomness... 龜鼭鼨鼷鮽
20:28:46 <SamB> whoa...
20:28:49 <beelsebob> in other news... my hovercraft is full of eels
20:28:56 <SamB> that first one looks white, the others look dark gray...
20:28:58 <emu> just your line
20:29:06 <chessguy> beelsebob, yes, thanks.
20:29:10 <chessguy> beelsebob++
20:29:20 <chessguy> was just testing your idea to make sure it really worked :)
20:29:22 <beelsebob> SamB: ah, you obviously don't have fonts supproting chinese characters yet
20:29:28 <beelsebob> chessguy: fair enough :D
20:29:52 <SamB> I have some
20:30:06 <beelsebob> oh? That should have come out nicely then
20:31:19 <beelsebob> *giggles at the fact that his computer takes about 10 times as long as the others to check ghc out, but makes up all the time in the compile phase
20:31:21 <SamB> but, apparantly that first part was in a different font than mthe other four...
20:31:42 <beelsebob> haha
20:32:01 <SamB> xterm does not like those four at all
20:32:57 * SamB wonders why the japanese input switches back to japenese so much, and how to get it to latin with the keyboard
20:36:57 <bd_> SamB: What input method are you using? S[CK]IM? I think the default binding is C-Space if so...
20:38:42 <SamB> hmm, that switches totally back to english mode, which suits me fine
20:39:00 * SamB wonders what the En mode is for anyway
20:39:57 <monochrom> SamB: In prehistoric times, the Chinese character set came with fat English letters to go well with Chinese characters (so that everyone has the same width).  In the process of adding Chinese to Unicode, they decided to include the fat letters so as to preserve certain compatibility.
20:40:01 <bd_> SamB: You should have a S.IM control thingy in the system tray (or whatever the correct term is). You can rebind things there :)
20:40:19 <SamB> system tray? heh.
20:40:29 <SamB> I haven't got one
20:40:41 * bd_ used to accidentally trigger it with screen hotkeys (C-a -> Space becmes C-a C-space) 
20:40:43 <monochrom> "notification area"
20:40:45 <bd_> ah... don't know then
20:40:52 <SamB> bd_: hmm
20:42:25 <monochrom> Hahaha buggy nofib for testing debuggers
20:50:17 <beelsebob> monochrom: it's really fucking useful that is
20:51:05 <monochrom> ?
20:51:13 <beelsebob> the buggy nofib suite
20:51:46 <monochrom> what does "fucking" mean in this context?
20:52:16 <beelsebob> it means generic expletive meant to increase impact
20:52:32 <beelsebob> as it is commonly used in Scotland
20:52:39 <SamB> bloody
20:52:42 <SamB> say bloody ;-)
20:52:42 <chessguy> it means that beelsebob isn't eloquent enough to express himself more forcefully in a more tasteful manner
20:52:45 <bd_> beelsebob: it /is/ generic expletive meant to increase impact; had it mearly meant that, it would've had to been used as a noun ;)
20:52:45 <sorear> and just about everywhere else
20:53:06 <beelsebob> bd_: excellent pedantry, good work
20:53:08 <monochrom> what have I started? :)
20:54:16 <bd_> beelsebob: Sorry, I just can't stand it when english fails to typecheck :)
20:54:31 <monochrom> I have seen so many uses that I have lost track: sarcasm, frustration, funny, ...
20:54:32 <beelsebob> *giggle*
20:54:53 <chessguy> ?remember bd_ Sorry, I just can't stand it when english fails to typecheck
20:54:54 <lambdabot> Done.
20:54:55 <beelsebob> monochrom: in general it means anything you want it to at the time
20:55:06 <beelsebob> a bit like thingamybob
20:55:18 <monochrom> Yeah, I guess that's why I am confused.
20:55:18 <SamB> except thingamybob is a nouner
20:55:56 <beelsebob> indeed
20:56:05 <bd_> monochrom: In most cases the meaning of the sentence is preserved should the word be removed; except when used as a noun or verb. In the former case, replace with an appropriate pronoun.
20:56:38 <bd_> The latter case is polymorphic and requires inferencing the use of the free verb from elsewhere in the sentence.
20:57:01 <SamB> what the fuck
20:57:33 <beelsebob> hahaha
20:57:59 <beelsebob> examples "I'll kill the fucker" <-- replace the fucker with appropriate pronoun for it to work
20:58:24 <SamB> yes, but how do you remove "fuck" from "what the fuck"
20:58:30 <beelsebob> hehe
20:58:34 <bd_> "I'll kill him/her/it" <-- the = ($)
20:58:36 <monochrom> I'm wondering about that too :)
20:58:41 <beelsebob> well, americans famously say "what the?????"
20:59:02 <SamB> probably because they can't figure out what the word is they want to put next?
20:59:15 <beelsebob> probably
20:59:17 <sjanssen> we also say "what the " and then a moderately high pitched sound
20:59:27 <beelsebob> or they can't bring themselves to say fuck
20:59:38 <SamB> or even hell
20:59:48 <SamB> and "what the heck" doesn't mean the same as "what the hell" does
20:59:51 <beelsebob> although for some reason a combination is fine... what the frell
20:59:55 <SamB> (it has a subset of the meanings)
21:00:12 <SamB> maybe "what the shit"
21:00:14 <SamB> would be good
21:00:25 <SamB> because you want to know what happened when the shit hit the fan?
21:00:36 <beelsebob> not really
21:00:52 <beelsebob> I used to have toilet paper taped to my fan for just such a situation
21:01:00 <beelsebob> or possibly just because it made nice streamers
21:01:04 <dons> um? #haskell-blah is that way -->
21:01:21 <SamB> oh, it is?
21:01:24 * chessguy agrees whole-heartedly with dons
21:01:26 <monochrom> No, <--- that way
21:01:26 <SamB> I thought it was <-- that way
21:01:41 <SamB> or maybe ^ that way or v that way
21:02:00 <chessguy> (find the door) >>= use
21:02:06 <monochrom> (<--) = flip (-->)
21:03:11 <beelsebob> chessguy: return ()
21:03:39 <chessguy> nah, i'd rather they stay there :)
21:04:27 <chessguy> at least with that conversation
21:04:36 * beelsebob giggles at how fast his machine is failing to build ghc
21:05:37 <monochrom> It took me five hours
21:05:54 <beelsebob> stage 1 just took 25 minutes
21:06:06 <beelsebob> but apparently the script igloo set up has buggered some paths
21:06:14 <beelsebob> http://darcs.haskell.org:8010/
21:06:16 <lambdabot> Title: BuildBot: GHC
21:06:26 <monochrom> Of course I mean it took my computer five hours.  I can't build ghc for my life.  Too much perl.
21:06:32 <beelsebob> lol
21:14:58 <sorear> gah. Yi.FastBuffer.insertN' :: FBuffer -> [Char] -> Int -> IO FBuffer  -- what's wrong with this picture?
21:16:38 <sjanssen> hmm, that's a little strange
21:16:45 <sjanssen> what does the N mean?
21:16:57 <sorear> count I assume
21:17:14 <sorear> insertN' buf str strlen  ==>  buf'
21:17:34 <sorear> anyway, I was pointing out the un-pipeline-ability
21:27:39 <sorear> ooh - never seen that color before
21:27:50 <sorear> bright red #haskell sounded important :)
21:28:41 <SamB> what?
21:28:51 <SamB> my /version did that?
21:29:08 <sorear> yes
21:30:05 <sorear> ==> CTCP request from SamB (i=naesten@216-15-104-38.c3-0.upd-ubr7.trpr-upd.pa.cable.rcn.com): VERSION [21:21]
21:30:28 <sorear> did anyone answer?
21:30:33 * SamB just wanted to make sure his connection was still active, as he had done "ifdown eth1" and "ifup eth1"
21:30:42 <SamB> -sorear- VERSION ERC Version 5.2 stable pre-release - an IRC client for emacs (http://emacswiki.org/cgi-bin/wiki/ERC (mailing list: erc-discuss@gnu.org))
21:30:44 <lambdabot> Title: EmacsWiki: ERC
21:31:04 <sorear> did you just version me, or the whole channel?
21:31:19 <SamB> just you
21:31:24 <SamB> you were handy to click on
21:31:35 <sorear> I feel honored.
21:31:36 <SamB> (I didn't actually use /version, I guess)
21:32:28 <SamB> anyway DNS wasn't working
21:32:56 <SamB> so I thought maybe re-leasing my IP address would give me new DNS server IPs, and it seems to have worked
21:36:02 * SamB wonders why electricsheep only uses bittorrent on windows
21:36:22 <dons> ok, well that wasn't too hard, SBCL is already slower on the shootout, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:36:25 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/lepfo
21:36:28 <dons> and only had to update 3 programs :)
21:38:18 <bos31337> dons: is there a good way to get data from a ByteString into a UArray, where the sizes differ?
21:38:27 <bos31337> i.e. I have a UArray Int Word16
21:38:43 <emk> dons: Are you a single human being, or are you a giant collective of Haskell hackers? ;-)
21:38:57 <bos31337> but i want to put bytes in there, and zero-extend the upper byte of each Word16
21:39:29 <bos31337> i.e. one byte from ByteString becomes one Word16 in UArray
21:39:39 <dons> bos31337: hmm, a loop should do the trick
21:41:01 <bos31337> ok, i don't know quite what you might be meaning there.
21:41:39 <bos> the only array constructors i know of take lists as parameters.
21:41:47 <sorear> I suspect dons may actually be a lambdabot.  it would explain why he notices his name mostly at BOL ...
21:42:19 <bos> as you might guess, diddling with arrays is a bit new to me.
21:44:33 <nmessenger> bos: I'm not familiar with the ByteString interface, but isn't there some function :: ByteString -> [Word8] in there?  You should then be able to pass that to an array constructor.  Maybe not ideal, but a first pass at an answer.
21:44:45 <sorear> unpack
21:44:55 <bos> yeah, that would work, but ugh.
21:45:04 <bos> i might as well not use ByteStrings, then :-)
21:45:11 <bos> i think i need an STUarray
21:45:27 * nmessenger wonders what an IOUArray owes him
21:45:41 * sorear checks if unpack uses build
21:46:20 * nmessenger also wonders how often that 'IOU' joke gets told
21:46:55 <sorear> nmessenger: first I've heard it (thought it before though)
21:46:56 <bos> great, now i get to learn how to use the ST monad.
21:47:02 <sorear> ST is easy!
21:47:13 <sorear> just avoid $ and everything will be fine.
21:47:27 <nmessenger> bos: that should be: "Great!  Now I get to learn how to use the ST monad!"
21:47:39 <bos> actually, it's fine by me. i'm not being grumpy.
21:47:41 <nmessenger> :P
21:47:49 <monochrom> I owe you a ray.
21:47:51 <bos> i wrote my first monad this evening, so i'm all for more bondage.
21:48:24 <dons> hmm. my code is compiling a bit too easily, and running a bit too quickly
21:48:29 <monochrom> @remember nmessenger nmessenger wonders what an IOUArray owes him
21:48:30 <lambdabot> Done.
21:48:31 <bos> my monad is the bastard stepchild of State and Maybe.
21:49:16 <sorear> MaybeT (State s) ?
21:49:57 <monochrom> stepchild means it has another natural parent?
21:50:02 <sorear> or StateT s Maybe ?
21:50:20 <sorear> @unmtl StateT s Maybe a
21:50:21 <lambdabot> s -> Maybe (a, s)
21:50:27 <sorear> bos: ^^^ ?
21:50:34 <bos> s -> (Maybe a, s)
21:50:48 <nmessenger> what does mtl stand for?
21:50:52 <sorear> ah, that would be MaybeT (State s)
21:50:59 <sorear> nmessenger: monad transformer library
21:51:09 <sorear> alas, MaybeT is nonstandard :(
21:51:34 <bos> sorear: yeah, i figured i could use monad transformers, but thought it would be better learning to construct a plain monad of my own first.
21:52:24 <bos> it went surprisingly well, once i got over the feeling that my brains were going to boil out through my ears.
21:52:25 <monochrom> Yup absolutely.
21:52:50 <monochrom> Part of my endeavour of learning Cont was I eventually wrote my own.
21:53:20 <sorear> are there any useful monads that *aren't* isomorphic to some MTL stack?
21:53:27 <bos> i don't understand things well until i pull them apart and put them back together. then i go "hey, what's this extra screw and backplate for?"
21:53:34 <sorear> dumbo.  IO
21:54:20 <sorear> also, can anyone refute my hypothesis that Cont is the free monad?
21:54:30 <bos> the free monad?
21:54:45 <sorear> bos: like [] is the free monoid
21:54:48 <bos> qu'est-ce que c'est, un free monad?
21:55:03 <bos> sorear: that does not clarify things in the mind of your simple correspondent.
21:55:55 <monochrom> Interesting.
21:56:03 <bos> i haven't tripped over a monoid enough yet to even know what one is, much less what a free one might be.
21:56:42 <sorear> free objects have no behaivor, they just record what happens, so you can implement any behaivor by postprocessing.  all monoids can be expressed as folds over lists, and lists are monoids, which makes lists of basic terms the free monoid.
21:56:42 * nmessenger has a rough idea of what a Monoid is: something with a 'zero' and a 'plus'-like operation
21:57:01 <ddarius> sorear: Freely generated from what?
21:57:08 <sorear> all monads, it seems, can likewise be expressed by appropriately parameterising Cont
21:57:09 <SamB> sorear: so aren't DLists also free monoids?
21:57:47 <sorear> SamB: yes ?
21:57:51 <nmessenger> thus [] and (++) for the [] monoid
21:57:53 <monochrom> A free monad is freely generated from return and >>=
21:58:06 <sorear> I don't really understand, that's why I'm asking!
21:58:14 <sorear> monochrom: not quite
21:58:38 <sorear> monochrom: Monoid [] follows the monoid laws structurally.
21:59:06 <bos> wow, some of the library docs are spectacularly hard to read.
21:59:09 <sorear> monochrom: your object with just the monad operations as constructors, isn't a monad.
21:59:09 <monochrom> Oh yeah.  A free monad is freely generated from return and >>=, and then subject to the monad laws.
21:59:32 <SamB> sorear: sure it is
21:59:37 <vagif> hello i'm a newbee, and i'm solving very simple exercises
21:59:42 <sorear> I want to know if there are any objects that are free and follow the monad laws, no moduloness needed.
21:59:46 <nmessenger> newbie! attack!
21:59:49 <sorear> I think Cont is that object.
21:59:52 <vagif> one of them is implement takeWhile
21:59:53 <SamB> as long as you define equality correctly
21:59:57 <nmessenger> (with kindness of course)
21:59:58 * monochrom attacks newbies
22:00:00 <vagif> i did it like this:
22:00:09 <vagif> takew _ [] = []
22:00:09 <vagif> takew f (x:xs)
22:00:09 <vagif>   | f x = x:takew f xs
22:00:09 <vagif>   | otherwise = []
22:00:13 <monochrom> oops I fail to attack newbees
22:00:18 <vagif> my question
22:00:26 <ddarius> sorear: What you're saying is ambiguous or simply non-sensical.
22:00:33 <vagif> is there other more short way ?
22:00:43 <sorear> takew = takeWhile :p
22:00:48 <sorear> er, um...
22:00:54 <nmessenger> vagif: sure takew = tak... darnit sorear!
22:01:04 <vagif> :) common guys
22:01:04 * monochrom giggles evilly after reading the recent The Monad Reader.
22:01:24 * monochrom evilly suggests "do it with foldr"
22:01:31 <sorear> must think of most arcane way possible ...
22:01:31 <vagif> i just want to be sure that i did not miss some crazy composition of curried functions
22:01:47 <Ytinasni> @src takeWhile
22:01:48 <lambdabot> takeWhile _ []                 =  []
22:01:48 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
22:01:48 <lambdabot>                    | otherwise =  []
22:01:51 <monochrom> Your code is ok.
22:01:51 <sorear> vagif: I'm sure you have.  no one expects the spanish foldr.
22:02:13 <Ytinasni> that's the ghc version :D
22:02:51 <sorear> > let takeWhile p = foldr (\x xs -> if p then x:xs else []) [] in takeWhile (>0) [1,2,3,-3,2,3,4]
22:02:52 <lambdabot>      Expecting a function type, but found `Bool'
22:02:53 <lambdabot>       Expected type: Bool
22:02:53 <lambdabot>   ...
22:03:10 <sorear> > let takeWhile p = foldr (\x xs -> if p x then x:xs else []) [] in takeWhile (>0) [1,2,3,-3,2,3,4]
22:03:11 <lambdabot>  [1,2,3]
22:03:41 <sorear> takeWhile p = foldr (\x xs -> if p x then x:xs else []) []
22:03:51 <vagif> ok i get it, i got reasonably good solution :)
22:03:52 <vagif> thx
22:03:58 <sorear> can it be made shorter ... obsess obsess
22:04:03 <monochrom> Now do it with foldl
22:04:09 <sorear> I once wrote a 590-char theorem prover
22:04:20 <monochrom> What does it prove?
22:04:20 <sorear> that was ... disturbingly fun
22:04:24 <nmessenger> @check (\p xs -> foldr (\x xs -> if p x then x:xs else []) [] xs == takewhile f xs) :: (Int -> Bool) -> [Int] -> Bool
22:04:25 <lambdabot>   Not in scope: `f'
22:04:52 <nmessenger> @check (\p xs -> foldr (\x xs -> if p x then x:xs else []) [] xs == takeWhile p xs) :: (Int -> Bool) -> [Int] -> Bool
22:04:53 <lambdabot>  OK, passed 500 tests.
22:05:28 <sorear> or, for extra fun: \p -> foldr (\x xs -> if p x then x:xs else []) []
22:05:37 <sorear> anonymous!
22:05:54 <emu> ?pl fix (\takeWhile p = foldr (\x xs -> if p x then x:xs else []) [] )
22:05:55 <lambdabot> (line 1, column 19):
22:05:55 <lambdabot> unexpected "="
22:05:55 <lambdabot> expecting pattern or "->"
22:06:01 <emu> ?pl fix (\takeWhile p -> foldr (\x xs -> if p x then x:xs else []) [] )
22:06:02 <lambdabot> flip foldr [] . flip flip [] . (flip .) . (`ap` (:)) . (((.) . if') .)
22:06:11 <nmessenger> meh, that's just manual lambda reduction, and it might suffer from MMR
22:06:15 <sorear> @pl \p -> foldr (\x xs -> if p x then x:xs else []) []
22:06:16 <lambdabot> flip foldr [] . flip flip [] . (flip .) . (`ap` (:)) . (((.) . if') .)
22:06:17 <emu> :t if'
22:06:19 <lambdabot> Not in scope: `if''
22:06:28 <emk> What's a good paper to learn about CPO?
22:06:29 <sorear> emu: @pl cheats
22:06:34 <nmessenger> @pl \b t f -> if b then t else f
22:06:35 <lambdabot> if'
22:06:43 <emu> figured
22:06:58 <newsham> the left script does not know what the right script is doing
22:07:07 <emu> blah, if shouldn't be special syntax anyhow
22:07:07 <bd_> @hoogle if'
22:07:08 <lambdabot> No matches found
22:07:20 * nmessenger agrees with emu
22:07:22 <emu> this is a lazy language!
22:07:25 <bd_> You could probably implement an equivalent using Cont and ListT... :)
22:07:36 <emu> also, i can never decide where to put the "then" and "else"
22:07:56 <newsham> if cond\n\tthen something\n\telse somethingelse
22:08:01 <nmessenger> emu: I either one-line, or indent then and else on their own lines
22:08:31 <nmessenger> if b then t
22:08:34 <nmessenger>      else f
22:08:36 <emu> i just avoid it and use guards
22:08:39 <nmessenger> if I'm feeling crazy
22:08:44 <newsham> case cond of\n\tTrue -> something\n\tFalse -> something else
22:08:45 <sorear> @pl \b t f -> fromMaybe f (guard b >> Just t)
22:08:46 <lambdabot> (flip fromMaybe .) . (. Just) . (>>) . guard
22:08:52 <sorear> if' = that
22:09:03 <ddarius> emk: What background are you coming from?
22:09:17 <nmessenger> ooh pretty!
22:09:36 <sorear> you like it?
22:09:38 <emk> ddarius: I can handle a little light category theory, but I'm a programmer.
22:09:48 <emu> not sure if pretty is the term
22:09:55 <nmessenger> I'm sure
22:10:52 <emk> ddarius: I have "Program Calculation Properties of Continuous Algebras".
22:11:13 <emu> > let tru = flip const; fls = const; if' x t e = x t e in if' tru 1 2
22:11:15 <lambdabot>  2
22:11:24 <emu> whoops
22:11:36 <emu> > let tru = const; fls = flip const; if' x t e = x t e in if' tru 1 2
22:11:37 <lambdabot>  1
22:12:29 <bos> wow, STUArray is completely opaque to me.
22:12:40 <emu> > let tru = const; fls = flip const; if' = id in if' tru 1 2
22:12:41 <lambdabot>  1
22:12:50 <emu> bos: why?
22:12:58 <emu> though that statement is True
22:13:05 <bos> because i don't know how to use it.
22:13:32 <bos> i grepped through the GHC library source looking for any code that used it, and struck out.
22:13:32 <emu> runSTArray (do a <- newArray (1,10) 1; writeArray a 1 0; return a)
22:13:50 <emu> check out the Arrays section of the wiki
22:14:03 <bos> ooh, aah. thanks.
22:15:22 <ddarius> emk: You may find http://www.cis.ksu.edu/~schmidt/text/densem.html useful.  Presumably you care about CPOs for the purposes of (denotational) semantics.
22:15:48 <monochrom> emk: I learned CPO and other lattice theory stuff from Davey & Priestley
22:15:49 <hpaste>  emu pasted "In place Quick Sort with STArrays" at http://hpaste.org/274
22:15:51 <SamB> bos: do not use STUArray
22:15:56 <SamB> it is a total PITA
22:16:22 <SamB> and you can't write library code that uses it if you value your parametricty!
22:16:44 <emu> eh?
22:16:50 <emk> ddarius: Actually, I'm looking at papers like "Fast and Loose Reasoning is Morally Correct", and various optimizer stuff, and less at the denotational semantics. But thanks for the pointers!
22:18:06 <emu> bos: having said that, DiffArrays are often going to give you what you want, with a nice convenient functional interface
22:19:21 <emk> monochrom: Thanks!
22:21:59 <bos> emu: thanks
22:24:08 <monochrom> http://www.haskell.org/haskellwiki/Modern_array_libraries  has an STArray example.  You can just replace it with STUArray.
22:24:09 <vagif> newbee here
22:24:10 <lambdabot> Title: Modern array libraries - HaskellWiki
22:24:20 <vagif> this time implementation of map
22:24:27 <vagif> i did it 3 ways
22:24:39 <monochrom> do it with foldr :)
22:24:43 <vagif> list comprehensions,
22:24:49 <vagif> recursive
22:24:57 <vagif> and
22:24:58 <vagif> mymap f = foldr ((:) . f) []
22:25:10 <monochrom> Ok, I need to think of a fourth way.
22:25:18 <vagif> is there any shorter and clearer version ?
22:26:21 <monochrom> @type liftM
22:26:23 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
22:27:59 <monochrom> let puzzle f xs = xs >>= (return . f) in puzzle Just [3,1,4,1,5,9]
22:28:03 <monochrom> > let puzzle f xs = xs >>= (return . f) in puzzle Just [3,1,4,1,5,9]
22:28:04 <lambdabot>  [Just 3,Just 1,Just 4,Just 1,Just 5,Just 9]
22:28:24 <monochrom> It is not shorter or clearer, but it's cheating. :)
22:28:54 <vagif> ok guys, thx.
22:30:19 <monochrom> I have not shown the arrow version. :)
22:38:00 <nmessenger> mymap = fmap, but since fmap (in []) = Prelude.map, that's also cheating :)
22:59:29 <emk> I was surprised to discover today that ((->) r) is a monad...
23:00:22 <sorear> Transmission acknowledged.
23:00:58 <mwolak> If I wanted to write a PNG library, what type should I use for raw images? Would Array (Int,Int) (Array Int Val) be OK?
23:01:14 <sorear> yes, but *very* slow
23:01:16 <mwolak> where Val depends on depth
23:01:35 <bd_> Why use a nested array?
23:01:41 <sorear> UArray (Int,Int,Int) Int --better
23:02:10 <sorear> UArray (Int,Int,Int) {Bool,Word8,Word16}
23:02:10 <mwolak> well, I'd use unboxed if possible, but I want to be able to have variable number of channels, and be able to choose depth
23:02:21 <sorear> mwolak: then your image is 3d ...
23:02:57 <mwolak> 2d image, third index is the channel
23:03:33 <mwolak> because I am lazy and don't want to write (Val,Val,Val) and (Val,Val,Val,Val) versions
23:03:54 <nmessenger> emk: are you Eric Kidd?
23:04:21 <emk> nmessenger: Yes.
23:04:22 <sorear> nmessenger: it says so on his blog
23:04:26 <nmessenger> I posted another response to that thread :)
23:04:50 <sorear> now we just need to find Eric Sessoms
23:05:00 <sorear> (by order of the great Dons)
23:05:34 <emk> nmessenger++
23:05:51 <nmessenger> yay!
23:06:20 <emk> I liked the ((->) r) solution because it taught me something twisted.
23:07:39 <mwolak> sorear: ahh, thanks, I like that second one
23:07:50 <emk> :t flip id
23:07:52 <lambdabot> forall b c. b -> (b -> c) -> c
23:08:06 <sorear> yw
23:08:08 <emk> :t id
23:08:08 <nmessenger> flip id x f = f x
23:08:09 <lambdabot> forall a. a -> a
23:08:50 <nmessenger> ($) = id, but is one character shorter
23:09:05 <nmessenger> (er, the other way around)
23:09:24 <emk> So a -> a => (b -> c) -> (b -> c) => (b -> c) -> b -> c =(flip)> b -> (b -> c) -> c...
23:09:40 <emk> Somebody stop nmessenger before he golfs again! ;-)
23:09:43 <nmessenger> ($ x) f = (flip ($) x) f = flip ($) x f = flip id x f
23:10:42 <sorear> =  f x :)
23:12:25 <emk> The worst part: These Haskell tricks are no more opaque than half the papers on F-algebras.
23:12:56 <emk> ...which tend to involve excessive point-free style.
23:13:55 <emk> ($ x) f => f $ x => f x
23:14:03 <emk> No need for the flips for that one...
23:15:34 <emk> Ow. Now I understand what that final version of conjoin and disjoin are doing.
23:17:19 <nmessenger> emk: yeah, I shoulda realized that and (map ($ x) fs) = all ($ x) fs, which is just pointfreed in the final
23:17:42 <nmessenger> @src all
23:17:42 <lambdabot> all p =  and . map p
23:18:53 <nmessenger> frankly I find (\fs x -> all ($ x) fs) the most lucid
23:21:24 <emk> Well, go ahead and add any versions you like. :-)
23:22:24 <emk> <typo:code lang="haskell"></typo:code> gets you the pretty grey boxes...
23:23:04 <nmessenger> link to a markup cheatsheet!  (more blogs should do this)
23:25:55 * nmessenger remarks that 'conjoin fs x = all ($ x) fs' has 3 fewer characters than the pointfree version
23:26:15 <nmessenger> Gahh!  Must! Not! Golf!
23:26:47 <emk> nmessenger: And it's the most elegant version, too.
23:27:05 * nmessenger runs away screaming
23:31:04 <nmessenger> wait, Ruby has a list.all?() and a function.call(), it should an analogue that doesn't need the inject
23:32:12 <nmessenger> just Peter Burns' version with the '2' abstracted into a lambda
23:32:51 <emk> nmessenger: Yup.
23:37:48 <sorear> gah.
23:38:01 <sorear> why is there no Data.Map.mapMonotonicWithKey?
23:38:12 <sorear> er, Data.Map.mapMonotonicWithValue
23:39:20 <emk> nmessenger: I'm going to post your improved versions to the comment thread.
23:40:14 <nmessenger> emk: right-o
23:40:57 <emk> I mean, you're trying to fight a golfing addiction, but I kinda liked the final ones... :-)
23:43:43 <emk> Done.
23:43:58 <nmessenger> heh, [:chunky, :bacon] :)
23:56:21 * sjanssen stares in horror at the "List syntax" trainwreck on the haskell-prime list
23:57:08 <nmessenger> @google haskell prime mailing list archives
23:57:13 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
23:57:13 <lambdabot> Title: Haskell Prime - Trac
