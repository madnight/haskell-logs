00:18:51 <opqdonut> ?src dropWhile
00:18:52 <lambdabot> Source not found. Are you on drugs?
00:23:24 <nmessenger> @index dropWhile
00:23:25 <lambdabot> Data.List, Prelude
00:23:29 <nmessenger> strange
00:30:56 <blackdog> hm. any idea how you'd serialise a regex?
00:36:58 <dons> just as a string
00:37:01 <dons> then construct it on startup
00:37:08 <dons> doesn't the existing code do that?
00:37:16 <blackdog> oh, this is for something else
00:37:55 <olliej> dons: i found http://citeseer.ist.psu.edu/14244.html which looks to be a good intro to type inference
00:38:01 <lambdabot> Title: Polymorphic Type Inference - Michael, Schwartzbach (ResearchIndex)
00:41:04 <blackdog> i'm trying to slot my code from vixen into HAppS without too much surgery
00:41:33 <blackdog> the darcs pull of lambdabot is still going, oddly enough
00:41:43 <blackdog> maybe i should wipe it and start from a clean darcs pull
00:55:12 <nornagon> what's haskell for bitwise shift-right?
00:56:00 <nornagon> @hoogle shiftR
00:56:01 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
00:56:01 <lambdabot> GHC.Exts.shiftRL# :: Word# -> Int# -> Word#
00:56:01 <lambdabot> GHC.Exts.iShiftRA# :: Int# -> Int# -> Int#
00:56:05 <nornagon> I see.
00:56:08 <nornagon> @instances Bits
00:56:09 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
00:56:22 <nornagon> @instances-importing Bits
00:56:23 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
00:56:24 <nmessenger> Karsten, don't mind Slava too much.  People are likely frustrated because of the numerous <i>completely false</i> assertions you make about Haskell, so it's very difficult to take your post seriously.  The most egregious is the repeated assertion that the IO monad breaks Haskell's referential transparency.  This is <i>false</i>.  The existance of IO doesn't break referential transparency, it in fac
00:56:25 <nmessenger> t <i>enforces</i> it.  The existance of a nonstandard function 'unsafePerformIO :: IO a -> a' is what breaks it.
00:56:25 <nmessenger> Consider the following:
00:56:25 <nmessenger> <code>main = x >>= y >>= z</code>
00:56:26 <nmessenger> When this program is executed, a dummy value that represents the state of the World, which I'll call world0, is created and passed to 'x'.  'x' then can call impure code, which from a functional standpoint is equivalent to creating a new value of the World type, world1.  'world1' is passed to y, creating 'world2', 'world2' to z, creating 'world3'.  Thus, this program is a transformation from world0
00:56:31 <nmessenger>  to world3.  Given the same world0, it will always produce the same world3.  This is referential transparency.
00:56:35 <nmessenger> From your replies, I gather that you don't <i>want</i> the IO monad to abstract away your World-passing.  You want more control over this World, to get access to it, to split it, to re-use old copies whenever you please.  This would require either: time-travel (an unsolved problem), or an <i>actual</i> representation of the state of the universe (an infinitely recursive task, not to mention memory-
00:56:39 <nmessenger> hogging).  If you send a character to stdout, it's not terribly difficult to simulate the old copy of the World in which you didn't, but if you send the LaunchMissle or NuclearMeltdown hardware signals, it gets more difficult.
00:56:40 <nornagon> uh.
00:56:43 <nmessenger> (an aside, to back my assertion about unsafePerformIO:) The reason unsafePerformIO is not referentially transparent is that it <i>destructively updates</i> whichever World value is currently in the main action chain, while posing as an ordinary function.
00:56:46 <nmessenger> gah! sorry
00:56:50 * nmessenger posted to Karsten's blog
00:57:43 <nmessenger> stupid copy-paste
00:57:56 <nmessenger> @instance-importing Data.Bits Bits
00:57:57 <lambdabot> Int, Integer
00:58:24 <norpan> nmessenger: that infernal middle-click
00:58:29 <nmessenger> @instance-importing Data.Bits Data.Word Bits
00:58:31 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
00:59:08 <geekagent> is there an efficient way to turn a list of [IO integer] to an IO [integer] ?
00:59:16 <nmessenger> @type sequence
00:59:18 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
01:00:38 <nmessenger> well, since it's here, what does anybody think of the post (:
01:01:52 <nmessenger> @google karsten wagner monads are evil
01:01:54 <lambdabot> http://kawagner.blogspot.com/2007/01/real-functional-programming-or-why-io.html
01:01:54 <lambdabot> Title: Karsten Wagner's Blog: Real functional programming or "Why the IO-monad is evil"
01:03:15 <nmessenger> @type sequence (replicate 5 (readLn::IO Integer))
01:03:17 <lambdabot> IO [Integer]
01:06:35 <pejo> nmessenger, is he worth your time?
01:07:44 <nmessenger> not really, I just had to do it to satisfy myself
01:07:51 <nmessenger> I don't plan to follow up
01:09:34 <geekagent> Hmm, can someone help me identify a space leak?
01:10:12 * nmessenger doesn't know enough about space behavior to help, but if geekagent uses hpaste, I'm sure someone can
01:10:15 <nmessenger> ?paste
01:10:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:11:02 <hpaste>  Kyle Butt pasted "rand01 Space Leak" at http://hpaste.org/334
01:12:13 <vkraeutler> > 1.0 / (length [1])
01:12:14 <lambdabot>   add an instance declaration for (Fractional Int)
01:12:19 <vkraeutler> what gives?
01:12:34 <geekagent> The leaks occur in the list of random number generations. I'v thrown as many strictness modifiers as I can fit
01:12:40 <nmessenger> > 1.0 / (fromIntegral (length [1]))
01:12:41 <lambdabot>  1.0
01:12:46 <vkraeutler> ah, thanks
01:16:25 <bringert> morning
01:16:28 <bringert> hi dons
01:16:34 <bringert> how's the http strike going?
01:22:36 <geekagent> The original papers on monads reference the IO monad as a way to wrap passing world around, I don't see how what wagner propoeses is any different
01:23:51 <nmessenger> apparently Wagner wants to play with a pure World, to duplicate it and reuse old versions, which is quite impossible
01:24:26 <nmessenger> Well, difficult anyway.  I'm not sure how the magic in those time-travel debuggers works.
01:25:45 <nmessenger> the only *useful* thing you can do with the World is destructively update it, which you can do in pure code, so long as you are guaranteed never to reuse an old version.
01:26:19 <nmessenger> Haskell abstracts away World-passing in IO to accomplish this, Clean uses uniqueness types.
01:26:35 <geekagent> Yeah, but If you look through (I think) peyton jones's papers, the IO Monad is described as IO a = World -> (a, World). This guy is up in the night
01:26:55 <nmessenger> @wiki IO_inside
01:26:55 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
01:27:08 <nmessenger> ^^ is where I first saw the explanation
01:30:20 <mauke> @src mfix []
01:30:21 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:30:31 <nmessenger> @src [] mfix
01:30:32 <lambdabot> mfix f = case fix (f . head) of
01:30:33 <lambdabot>            []    -> []
01:30:33 <lambdabot>            (x:_) -> x : mfix (tail . f)
01:34:32 <blackdog> dons: got an example of the new-style state?
01:34:36 <blackdog> (for lambdabot)
01:39:49 <mux> this miranda guy/girl is cool, finally someone who's asking questions that I can answer easily
01:40:32 <quicksil1er> i.e., her homework? :P
01:41:02 <mux> looks like it yeah :-)
01:41:07 <mux> it's in haskell-cafe
01:41:13 * quicksil1er nods, I read them too
01:45:40 <geekagent> I found the space leak
01:46:24 <kfish> whoohoo, http://lca2007.linux.org.au/talk/215 (Pat Z, "what does linux prove")  -- video is on the site
01:46:26 <lambdabot> Title: Computers, Programs and Logic: What Does Linux Prove? - linux.conf.au 2007
01:47:05 <hpaste>  Kyle Butt annotated "rand01 Space Leak" with "Fixed the space Leak" at http://hpaste.org/334#a2
01:49:18 <nmessenger> cool, not much of a change: http://hpaste.org/334/diff?old=0&new=2
01:49:19 <matthew-_> @src Pt
01:49:20 <lambdabot> Source not found. You speak an infinite deal of nothing
01:49:40 <matthew-_> mmm. where is the Pt data type in that code declared? And are the fields strict?
01:50:09 <matthew-_> and that diff feature of hpaste is staggaringly useful!
01:50:34 <mauke> what happened to nomaware.com?
01:50:40 <nmessenger> dead :(
01:52:43 <matthew-_> mmm. is there a strict tuple anywhere? Is it even possible to declare functions that have similar three-part syntax to tuples or is it a magic?
01:53:42 <nmessenger> tuples are sugary, yes, and GHC has strict tuples somewhere in its hierarchy
01:54:06 <nmessenger> something like (# a, b, c #)
01:54:50 <matthew-_> ahh! I thought that was just ghc dump-simpl output. I didn't realies you could actually use them in code
01:54:58 <matthew-_> realise, rather
01:55:18 <matthew-_> @type (#,#)
01:55:20 <lambdabot> parse error on input `,'
01:55:27 <matthew-_> oh, lb's only 98 isn't it?
01:57:04 <matthew-_> mmm. and the strict version isn't functional. oh well, close enough ;)
01:57:08 <nmessenger> look somewhere in GHC.Prim
01:57:13 <matthew-_> yeah
01:57:40 <matthew-_> > ( , ) 8 5 -- works, but > (# , #) 8 5 -- doesn't work
01:57:42 <lambdabot>  (8,5)
02:01:35 <dons> @type (# 1, 2 #)
02:01:36 <lambdabot> forall t t1. (Num t, Num t1) => (# t, t1 #)
02:02:04 <dons> @type (# 'x', (# 'u', 'z' #) #)
02:02:05 <lambdabot> (# Char, (# Char, Char #) #)
02:02:37 <nmessenger> @type (#,#) 8 5
02:02:39 <lambdabot> parse error on input `,'
02:03:28 <nmessenger> @type (\x y -> (# x, y #)) 8 5 -- ah, well
02:03:30 <lambdabot> forall t t1. (Num t, Num t1) => (# t, t1 #)
02:04:07 <matthew-_> yeah, I'm wondering if it's unavoidable because it's unboxed, but I'm guessing
02:04:28 <nmessenger> (\x y -> (# x, y #)) looks like the closest you can get to (,)
02:05:05 <matthew-_> indeed.
02:05:30 <mux> @pl (\x y -> (# x, y #))
02:05:31 <lambdabot> (line 1, column 11):
02:05:31 <lambdabot> unexpected "#"
02:05:31 <lambdabot> expecting lambda abstraction or expression
02:06:20 <matthew-_> mmm. the # has the feel of not being fully supported.
02:06:36 <nmessenger> I would suppose that's because it isn't.  :D
02:06:50 <matthew-_> could have something to do with it I guess ;)
02:07:52 <kzm> Good morning!  I'm working to convert an old program to compile with ghc-6.7.  Unfortunately, I have an operator named '?' -- is that no longer legal?
02:08:07 <matthew-_> agh. We're going to loose to new zealand AGAIN! Something's wrong in the state of English cricket.
02:08:36 <nmessenger> ?paste kzm
02:08:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:08:54 <kzm> que?
02:09:42 <nmessenger> You could put your code in the pastebin so we could check it.  I'm not sure if 6.7 reserves (?), though.
02:09:52 <hpaste>  kzm pasted "? as operator" at http://hpaste.org/335
02:10:16 <kzm> It's used (or disused?) for implicit parameters...
02:10:47 <kzm> But it used to work still - before implicit params, it was a perfectly legal symbol, I think.
02:11:04 <kzm> I should probably replace it, but of course, darcs doesn't like it much either.
02:11:27 <roconnor> Is there a wget implementation in haskell, so I can do txt <- wget "http://example.com/" ?
02:11:28 <nmessenger> implicit params are type-level syntax, though, right?  Also ? is a kind, but these should effect value-level.
02:11:30 <kzm> Guess that's what you get when you live on the syntactical fringe.
02:11:45 <nmessenger> *shouldn't
02:11:53 <kzm> roconnor, darcs incorporates curl, if that helps you any?
02:12:06 <kzm> Oh, you wanted a complete implementation, not a FFI?
02:12:17 <roconnor> yeah
02:12:33 <roconnor> it should be easy to write an imperfect version
02:12:36 <kzm> nmessenger, well, IIRC, you access an implicit param p by ?p or something.
02:13:02 <kzm> Didn't somebody just discuss a simple HTTP library?  ndm?
02:13:05 <roconnor> I'd be happy even if it ignores character set issues
02:13:20 <kzm> did you want recursion etc?
02:13:30 <nmessenger> oh, yeah, duh.  But you should still have to opt-in via -fglasgow-exts
02:13:57 <kzm> yes.  Well, it worked back in 6.4.1 -- or maybe 6.2.
02:14:09 <kzm> Sigh.  I guess I'll just get Emacs to replace them all.
02:14:28 <kzm> The big question now is whether I should call it '??' -- or am I asking for more trouble?
02:14:39 <nmessenger> 6.6 accepted my (?)
02:15:00 <nmessenger> perhaps (!), which seems oft-used for indexing
02:16:00 <mauke> !?
02:16:41 <matthew-_> err, might make a mess if you turn on bang-patterns
02:17:38 <nmessenger> wait, I tried yours and it didn't work.  I was refering to a (?) I defined outside a class.
02:18:39 <nmessenger> there's always getElementOfIndexed :P
02:19:48 <nmessenger> (wait again, that's because I didn't have MPTCs on, one sec...)
02:23:32 <dons> ? makes a great identifier
02:23:38 <dons> ?wiki Obfuscation
02:23:39 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
02:23:42 <dons> for a good example ;)
02:24:48 <nmessenger> heh.  I tried your code, and (?) works under 6.6, not sure of 6.7.
02:24:58 <nmessenger> s/your/kzm's/
02:25:55 <kzm> dons: what can I say, I was young, I was careless.
02:25:58 <blackdog> dons: am i just defining moduleSerialize to get vixen working?
02:26:59 <dons> yeah
02:28:24 <nmessenger> dons: I'm impressed that it aligns so neatly.  Did that take some reshuffling of ? counts?
02:28:43 <Elifant> @hoogle a -> [a] -> [a]
02:28:44 <lambdabot> List.intersperse :: a -> [a] -> [a]
02:28:45 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
02:28:45 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
02:29:03 <Elifant> @hoogle Char -> String -> String
02:29:04 <lambdabot> No matches, try a more general search
02:29:49 <kzm> Well - I now s/\?/\?\?/g'ed, and am eagerly awaiting the next rotation of the eternal wheel of syntactical invention.
02:30:33 <nmessenger> Elifant: what do you want your Char -> String -> String to do?
02:30:45 <Elifant> nmessenger: split
02:30:46 <xpika_> is there anyway of converting haddock to man?
02:31:17 <nmessenger> so 'f ',' "foo,bar,baz" = ["foo","bar","baz"]'?
02:31:22 <Elifant> nmessenger: split ',' "abc,def,gg,," = ["abc","def","gg","",""]
02:32:00 <nmessenger> @hoogle a -> [a] -> [[a]]
02:32:01 <lambdabot> No matches, try a more general search
02:33:07 <dons> nmessenger: a little, but it has padding ( ) 's
02:33:48 <nmessenger> > unfoldr (Just . span (==',')) $ "foo,bar,baz"
02:33:50 <lambdabot>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
02:33:54 <tessier> xpika_: Haddok to man? Is that like water into wine?
02:34:04 <blackdog> what flags do you need to pass to ghci to debug plugins in lambdabot? ghci keeps telling me i have a parse error in Hello.hs
02:34:17 <blackdog> (on the line with PLUGIN Hello)
02:34:51 <nmessenger> s/span/break/ gets closer
02:36:39 <nmessenger> > take 2 $ unfoldr (Just . (\(x,(_:y)) -> (x, y)) . break (==',')) $ "foo,bar,baz" -- closer still
02:36:40 <lambdabot>  ["foo","bar"]
02:42:31 <nmessenger> > take 3 $ let {f ([],_) = Nothing; f (x,y) = Just (x, drop 1 y)} in unfoldr (f . break (==',')) $ "foo,bar,baz"
02:42:32 <lambdabot>  ["foo","bar","baz"]
02:42:55 <nmessenger> now move 'f' into a where clause for prettiness
02:43:22 <mauke> > take 3 $ let {f ([],_) = Nothing; f (x,y) = Just (x, drop 1 y)} in unfoldr (f . break (==',')) $ ",,foo,bar,,"
02:43:23 <lambdabot>  []
02:43:27 <mauke> broken
02:43:31 <nmessenger> geh
02:45:29 <nomeata> Hi. I find these functions very useful and I alsways get them wrong the first time. Do you think they should go into Data.List? groupByLeader p = groupBy (\_ l -> not (p l)) and groupByLast p = groupBy (\l _ -> not (p l))
02:45:57 <nomeata> This is very handy when parsing data with segments that are marked either by a certain head, or a cartain tail.
02:46:07 <Elifant> split sep str = case break (==sep) str of
02:46:07 <Elifant>         (a, []) -> [a]
02:46:07 <Elifant>         (a, b) -> a : split sep (tail b)
02:46:12 <Elifant> this works
02:46:26 <Elifant> and it's more understandable for newbies :)
02:46:43 <nmessenger> I was thinking that 'unfoldr' was maybe too specific for this problem
02:46:57 <mauke> > let split sep str = case break (==sep) str of (a, []) -> [a]; (a, b) -> a : split sep (tail b) in split ',' ",,foo,bar,,"
02:46:59 <lambdabot>  ["","","foo","bar","",""]
02:47:22 <mauke> > let split sep str = case break (==sep) str of (a, []) -> [a]; (a, b) -> a : split sep (tail b) in split ',' ","
02:47:24 <lambdabot>  ["",""]
02:50:18 <pjd_> anyone know of a good reference about the difference between currying and partial application?
02:51:03 <nmessenger> hmm, partial application *is* currying, if I'm not mistaken
02:51:16 <dcoutts_> @type curry
02:51:18 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
02:51:21 <dcoutts_> @type uncurry
02:51:23 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
02:51:33 <nmessenger> rather, you can partially apply a curried function, so they're like compliments
02:51:43 <dcoutts_> nmessenger, right
02:52:09 <dcoutts_> (un)currying is a transformation on functions of multiple arguments
02:53:17 <nmessenger> @type uncurry map
02:53:19 <lambdabot> forall a b. (a -> b, [a]) -> [b]
02:53:43 <nmessenger> requires both a function and a list, but 'map' is curried, so:
02:53:49 <nmessenger> @type map toUpper
02:53:51 <lambdabot> [Char] -> [Char]
02:53:53 <pjd_> nmessenger: i mean more in the context of n-ary functions, and partial application of other than the first argument
02:54:01 <psi> so you can say that all haskell functions are curried? because you can partially apply them.
02:54:28 <pjd_> psi: well, it's more like they're curried, and you normally apply them
02:54:40 <nmessenger> well, you can curry all functions in any language with first-class functions, Haskell syntax just makes it terrifically convenient
02:54:58 <pjd_> with partial application, i mean like Scheme SRFI 26's cut/cute
02:55:45 <pjd_> or Python's partial()
02:56:04 <nmessenger> @src flip -- not quite sure what you mean, pjd_, but partial applicat of other than first can be accomplished by this, or by another lambda
02:56:05 <lambdabot> Source not found. Where did you learn to type?
02:56:11 <nmessenger> @src flip
02:56:12 <lambdabot> flip f x y = f y x
02:56:19 <psi> heh
02:56:32 <pjd_> nmessenger: with "other than the first argument", i mean things like (cut list 1 <> 3 <> 5) :)
02:56:43 <nmessenger> I'm not familiar with cut
02:57:02 <psi> \x -> \y -> ... -- a 'curried' function?
02:57:09 <pjd_> the <>'s stand for empty slots
02:57:25 <pjd_> so that cut means the same as (lambda (x y) (list 1 x 3 y 5))
02:58:58 <nmessenger> (cut list 1 <> 3 <> 5) = (lambda (x y) (list 1 x 3 y 5))?
02:59:04 <pjd_> yep
02:59:24 <pjd_> a Python example would be bluewindow = partial(window, color=blue)
02:59:28 <nmessenger> not sure if a macro like that is directly definable in haskell, but you could always use the lambda.
02:59:53 <quicksil1er> it's not definable in haskell, you can't define custom binders
03:00:04 <quicksil1er> still at least lambda in haskell is only one character long :)
03:00:07 <pjd_> quicksil1er: Template Haskell?
03:00:12 <nmessenger> you could probably use TH
03:00:13 <quicksil1er> I imagine you could do it in TH, yes
03:00:20 <nmessenger> heh
03:00:31 <quicksil1er> I've always thought that one-character-lambda was one of the best things about haskell :)
03:01:24 <pjd_> it will be the best thing as soon as you can actually say Î» in your source code :)
03:01:43 <nmessenger> is that a lambda character?  Can't read it.
03:01:48 <pjd_> nmessenger: yes
03:03:36 <nmessenger> I think some compilers (jhc or yhc or something) do allow lambdas and -> arrows and compose characters and stuff
03:03:46 <nomeata> ghc since 6.6 AFAIK
03:07:37 <mwc> pjd_, isn't epilogue going to have a latex-like input form?
03:07:45 <mwc> all the complicated math symbols you can imagine
03:07:50 <mwc> s/complicated/esoteric
03:08:31 <pjd_> epilogue?
03:08:38 <dcoutts_> epigram
03:08:42 <dcoutts_> @where epigram
03:08:42 <lambdabot> http://www.e-pig.org/
03:08:47 <pjd_> ah
03:08:58 <mwc> That's it
03:09:07 <mwc> My first guess was epiphany
03:09:11 <pjd_> heh
03:09:12 <dcoutts_> and yes, that's the plan
03:11:29 <bakert> How do I round a Double to 2 decimal places?  Doesn't matter if doing so makes it a String, that's what I want.
03:11:41 <dcoutts_> bakert, see the Numeric module
03:11:49 <bakert> dcoutts, thanks
03:11:54 <dcoutts_> @hoogle showFFloat
03:11:55 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
03:12:06 <dcoutts_> and there's a G and another variety too
03:12:21 <dcoutts_> > showFFloat (Just 2) pi ""
03:12:23 <lambdabot>  "3.14"
03:12:31 <bakert> brill.  just what i need.  ta.
03:12:38 <dcoutts_> I can't remember what the difference between the 3 versions are
03:12:51 <dons> > printf "%0.2f" (pi :: Double)
03:12:52 <lambdabot>  Add a type signature
03:12:52 <dcoutts_> something to do with scientific / exp notation
03:13:00 <dons> > printf "%0.2f" (pi :: Double) :: String
03:13:02 <lambdabot>  "3.14"
03:13:13 <dcoutts_> dons, I'm looking at the lps modules again, there's so much to improve!
03:13:37 <dons> fps or lps?
03:13:52 <dcoutts_> the lazy bytestring module in fps-unstable
03:13:59 <dons> right. yes.
03:14:13 <dons> yes, there's certainly a bit more work in there.
03:14:23 <dcoutts_> dons, so the plan is to make a shared Streams module right, and then make the experimental list lib use that
03:14:30 <dcoutts_> and perhaps port fps to it
03:14:31 <dons> right.
03:14:34 <dons> yes
03:14:37 <dcoutts_> ok
03:14:48 <dons> using what's current FusionStream.hs I think, as a start?
03:14:56 <dcoutts_> yep
03:15:08 <dcoutts_> should I start a new repo?
03:15:19 <dons> for the list library, yeah
03:15:26 <dons> but it will have to be a fork of base i think
03:15:32 <dcoutts_> for the share streams lib I mean
03:15:41 <dcoutts_> I don't see that it has to be related to base to start with
03:15:42 <dons> oh hmm.
03:15:45 <pejo> Would a magic optimisation pass in GHC be able to replace parts of the work you guys are doing?
03:15:48 <dons> yeah, maybe that's more flexible
03:15:52 <dcoutts_> just make Data.List.Fusible
03:15:56 <dcoutts_> no clashes
03:16:14 <dcoutts_> pejo, magic can do anything
03:16:16 <dons> I thought rl wanted Data.Stream
03:16:23 <mwc> pejo, the way I understand it, yes if magic=psychic
03:16:28 <dons> and if it ain't on hackage, its ours , as Igloo says
03:16:38 <dcoutts_> dons, for the streams bit, sure, for the new list lib we need another name to not clash
03:16:45 <dons> ah right.
03:16:45 <mwc> no if magic=result of 10^6 knuth-hours
03:16:51 <dons> Data.List.Something
03:17:09 <pejo> mwc, it's been years since he contributed anything to the programming language community!
03:17:11 <dons> Data.List.Fuse 
03:17:20 <dons> (i.e. its PrettyPrint not PrettyPrintable
03:17:36 <bringert> I wrote a hackage upload program
03:17:42 <dcoutts_> in classical formal program design they define: {True} magic {False}
03:17:45 <mwc> pejo, sure, but given the amount of stuff he has done, I'd say knuth-hours are still a superhuman unit
03:17:50 <bringert> should it be called cabal-upload or hackage-upload?
03:17:51 <dons> Data.Graph.Inductive not Data.Graph.Inductionable
03:17:58 <dcoutts_> hence magic can do anything, since it can establish the truth of False.
03:18:15 <mwc> assuming he's still up to coding without his arthritis killing him :)
03:18:16 <dons> br	so we have cabal-istall
03:18:21 <dons> wasn't there going to be cabal-put and cabal-get?
03:18:32 <dons> and we have cabal-get == cabal-install
03:18:33 <bringert> dons: I think that was a while ago
03:18:37 <bringert> ah
03:18:41 <mwc> cabal is gonna be a package install system too?
03:18:48 <dons> it is already
03:18:53 <mwc> Thought it was just BUILD
03:18:54 <dons> ?where hackage
03:18:55 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
03:18:59 <pejo> mwc, there's more than just code to be done for optimisation in GHC, I bet.
03:19:01 <dcoutts_> pejo, thing you've got to remember is that optimisations are not magic.
03:19:03 <bringert> dons: so cabal-upload then?
03:19:09 <dons> and then throw cabal-install at it
03:19:35 <dcoutts_> pejo, they're all designed, the involve analysis and transformation
03:19:40 <pejo> dcoutts, heh, yeah, I know. I was more using magic in the oracle/heureka-sense.
03:19:54 <therp> thinking in C doesn't feel right.
03:20:22 <bringert> dons: writing really made me want to fix the HTTP package
03:20:44 <therp> I'm just implementing a qtrle encoder for ffmpeg, to produce Liskell screencasts more economical, but.. I miss cons cells..
03:20:47 <bringert> dons: I made a new silly band-aid release of HTTP, it was missing some exports.
03:20:51 <Elifant> Is there any practical arrows tutorial anywhere? Those I've seen before just explains what arrows are and how they work, but not what they may be used for.
03:21:31 <pejo> dcoutts, (and starting out with an undeterministic algorithm might not be such a bad idea).
03:21:44 <dcoutts_> pejo, hmm?
03:23:29 <pejo> dcoutts, my usage of magic meant "having an oracle guide [some/the/an] transformation algorithm".
03:23:53 <pejo> Uh, an = a. Just noon and english is falling apart already!
03:24:20 <dcoutts_> I often think that having more library author annotations of which optimisations to apply at various points might help
03:24:38 <dcoutts_> eg "always use spec constr on this data type!"
03:25:22 <pejo> dcoutts, and that information can't be (possibly incompletely) inferred automatically?
03:25:44 <dcoutts_> pejo, it's a matter of knowing what transformations pay off
03:25:54 <dcoutts_> so possibly with a search
03:26:19 <nomeata> I use this to run an external command:
03:26:21 <nomeata> 	pid <- runProcess "pdftk" options Nothing Nothing Nothing Nothing Nothing
03:26:21 <nomeata> 	waitForProcess pid
03:26:30 <nomeata> But still I get zomies. What do I do wrong?
03:29:03 <bakert> There's not a handy function anywhere in the libraries (or elsewhere) for adding comma separators into numbers is there?
03:29:56 <pjd_> bakert: l10n?
03:30:24 <dcoutts_> @paste
03:30:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:30:42 <qwr> nomeata: on unix you could listen sigchild and collect zombis with wait. but i don't know whether haskell runtime does something of that automatically.
03:30:51 <hpaste>  dcoutts pasted "display a number using thousand seperators" at http://hpaste.org/336
03:31:01 <dcoutts_> bakert, ^^
03:31:19 <bakert> dcoutts, you are a wizard.  and serious more concise than the versions i could find on the web.  ta!
03:32:03 * dcoutts_ pulled it out of a gtk2hs demo prog
03:32:50 <qwr> nomeata: you could look at System.Posix.Process, System.Posix.Signal and man wait
03:34:41 <dons> nomeata: hmm, that should be fixed in ghc 6.6
03:35:01 <quicksil1er> bakert: note you'll need import Data.List for intersperse, I believe
03:36:10 <nomeata> oh, nevermind. I think the zombies are from this code:
03:36:10 <bakert> quicksil1er, just came across that one. thanks!
03:36:17 <nomeata> 	(inp, out, err, pid) <- runInteractiveProcess "pdftk" options Nothing Nothing
03:36:17 <nomeata> 	hClose inp
03:36:17 <nomeata> 	info <- hGetContents out
03:36:43 <nomeata> and because of the lazyness of hGetContents, I canâ€™t waitForProcess there.
03:38:43 <kzm> Compiled, tested, and everything in order.  ghc-6.6 gives a nice 10-20% speedup compared to the previous compile (6.4 or 6.2). Whee!
03:39:34 <dcoutts_> dons, for Lazy.ByteString it'd be great to be able to hint that functions that scrutinise that arg should always have specialised forms for the chunk case.
03:40:53 <dcoutts_> eg
03:40:53 <dcoutts_> head Nil         = errorEmptyList "head"
03:40:53 <dcoutts_> head (Chunk c _) = P.unsafeHead c
03:41:10 <dcoutts_> so obviously we always do the worker wrapper transform
03:41:15 <dcoutts_> so we get two versions anyway
03:41:33 <dcoutts_> but it's pretty obvious that often we'll know that we've got one constructor or the other
03:41:42 <dons> yeah
03:41:55 <dcoutts_> so we really always want to generate the specialised version for the Chunk case
03:42:00 <dons> kzm, great news!
03:42:07 <dcoutts_> and have that used in all user's code.
03:42:16 <dcoutts_> spec constr! spec constr! spec constr!
03:42:24 <dons> dcoutts_: right. that's what we need
03:42:32 <kzm> IME, ghc-6.6 is almost always an improvement along these lines.  There's some nice work in there.
03:43:12 <dcoutts_> kzm, yeah, ghc-6.6 does do spec constr.
03:43:28 <dons> a lot of improvements went in just before ghc 6.6 came out
03:43:34 <dons> and its still progressing though
03:43:41 <dons> we'll likely see another jump in 6.8
03:43:52 <dons> stream fusion lists anyone??
03:43:54 <dcoutts_> as well as the semi-tagging optimisation
03:44:06 <dcoutts_> which gets 10% across the board
03:44:06 <dons> yeah, all the PAPI stuff should help with the native codegen
03:44:10 <dons> we can actually get numbers
03:44:14 <dcoutts_> mmm
03:51:10 <bakert> ?hoogle a -> [a] -> [a]
03:51:11 <lambdabot> List.intersperse :: a -> [a] -> [a]
03:51:11 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
03:51:11 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:51:30 <bakert> ?src intersperse
03:51:31 <lambdabot> intersperse _   []     = []
03:51:31 <lambdabot> intersperse _   [x]    = [x]
03:51:31 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
03:51:55 <bakert> What's the function that drops everything from the end of a list after a successful match?
03:52:15 <bakert> So, dropThing 3 [1,2,3,4] == [3,4]
03:52:20 <bakert> sorry i mean [4]
03:52:20 <Lemmih> takeWhile?
03:52:27 <Lemmih> dropWhile?
03:52:33 <bakert> ?src dropWhile
03:52:33 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:52:42 <bakert> :t dropWhile
03:52:44 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:52:59 <mauke> > dropWhile (/= 3) [1,2,3,4]
03:53:00 <lambdabot>  [3,4]
03:53:13 <bakert> cool.  i think that's it then
03:53:24 <bakert> > dropWhile (/= '.') "89323892.3289"
03:53:25 <lambdabot>  ".3289"
03:53:33 <bakert> bada bing.  thanks folks
03:53:40 <Elifant> bakert: but if you need to drop from end, use 'reverse . dropWhile (...) . reverse'
03:53:51 <pjd_> Elifant: or takewhile :)
03:54:05 <mauke> that's not the same thing
03:54:13 <Elifant> pjd_: no, takeWhile won't help
03:54:31 <pjd_> oh, right, sorry
03:55:44 <bakert> What's the general type for a Float/Double?
03:55:58 <pbx> @users
03:55:59 <lambdabot> Maximum users seen in #haskell: 322, currently: 301 (93.5%), active: 38 (12.6%)
03:56:30 <bakert> > takeWhile (/= '.') "29389283.82932"
03:56:31 <lambdabot>  "29389283"
03:56:32 <mauke> @type sqrt
03:56:33 <lambdabot> forall a. (Floating a) => a -> a
03:56:55 <pjd_> bakert: they're instances of a number of type class
03:57:32 <malebria> Good morning.
03:58:57 <hpaste>  pbx pasted "(no title)" at http://hpaste.org/337
03:59:04 <pbx> Making my way through the "make yourself a scheme" tutorial, which is a bit beyond me in parts but still very interesting. In section 6.2 I came across a type thing I didn't get, though...
03:59:29 <pbx> Why does "List" need to be there (in what I just pasted)? Don't the brackets indicate that it's a list?
04:00:00 <nmessenger> List is a constructor that takes a Haskell list and turns it into a Scheme one.
04:00:06 <nmessenger> try ':t List'
04:00:10 <pbx> Ahh...
04:02:07 <SamB> What about improper lists?
04:02:39 <pbx> Thanks! I'm a Python guy but the "just try it in the interpreter" reflex hasn't yet carried over to Haskell yet.
04:02:58 <nornagon> ghci <3
04:02:59 * nomeata tries to use the type type FileProducer = ReaderT WikiInfo (WriterT [FilePath] IO) ()
04:03:26 <nomeata> But I have trouble getting the right combination of runReaderT and execWriterT
04:03:30 <nmessenger> pbx: so [Atom "if"] :: [LispVal], but List [Atom "if"] :: LispVal
04:03:42 <nmessenger> (read :: as "has type")
04:03:46 <nomeata> I tried: runFileProducer info = runReaderT info . execWriterT
04:03:50 <nomeata> Can someone give me a hint?
04:03:57 <pbx> nmessenger: Right, thanks.  Still learning to pay attention to case too!
04:04:34 <pbx> Gotta run now. Thanks #haskell
04:04:35 <bakert> ?hoogle fmt
04:04:36 <lambdabot> Data.FiniteMap.fmToList :: FiniteMap key elt -> [(key, elt)]
04:04:37 <lambdabot> Data.FiniteMap.fmToList_GE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
04:04:37 <lambdabot> Data.FiniteMap.fmToList_LE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
04:04:51 <Elifant> nomeata: since ReaderT is outside, you must unwrap it first
04:05:05 <SamB> nomeata: yeah, you have it inside out
04:05:23 <Elifant> nomeata: then you unwrap WriterT and get IO, which you can't unwrap and just returns :)
04:05:25 <nomeata> ah, I just found http://cale.yi.org/index.php/How_To_Use_Monad_Transformers which tried to do what I want
04:05:27 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
04:05:52 <nomeata> Iâ€™ll be back if that doesnâ€™t help me. Thanks so far.
04:08:50 <pejo> nomeata, or "Monad transformers step by step" by Grabmüller.
04:10:06 <bakert> > splitAt '.' "293892.82392"
04:10:07 <lambdabot>  Couldn't match `Int' against `Char'
04:10:23 <mauke> > splitAt 3 "foobar"
04:10:24 <lambdabot>  ("foo","bar")
04:10:27 <bakert> ?hoogle a -> [a] -> [a]
04:10:28 <lambdabot> List.intersperse :: a -> [a] -> [a]
04:10:29 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
04:10:29 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
04:10:43 <bakert> OK, good I'll stick with dropWhile and takeWhile
04:10:54 <bakert> hang on, i've already written split!
04:11:13 <bakert> well, kind of:
04:11:14 <bakert> split pattern s = splitRegex (mkRegex pattern) s
04:11:22 <pjd_> bakert: might want to look at span and break, too
04:11:24 <bakert> (pretty weak!)
04:11:56 <bakert> aha pjd_ those are my boys!
04:11:58 <bakert> thanks
04:12:42 <nmessenger> shouldn't hoogle say (Prelude.:) instead of Prelude.(:)?
04:12:58 <bakert> So how do I say "do this to the first bit and this to the second bit" on a single line?
04:13:33 <nmessenger> @type (f *** g)
04:13:35 <lambdabot> Not in scope: `f'
04:13:35 <lambdabot>  
04:13:35 <lambdabot> <interactive>:1:7: Not in scope: `g'
04:13:51 <nmessenger> @src (->) (***)
04:13:51 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
04:13:59 <bakert> ooooh like it
04:14:13 <bakert> what's the tilde for?
04:14:19 <nornagon> lazy match
04:14:20 <nmessenger> lazy match
04:14:23 <nmessenger> jinx!
04:14:23 <nornagon> jinx
04:14:26 <nornagon> lol
04:14:31 <nmessenger> JINXJINX!
04:14:35 <bakert> we only need one of you!
04:14:36 <bakert> !!!
04:14:42 <bakert> what does lazy match mean?
04:14:47 <mauke> o/` that makes me lazy, that makes me lazy ... o/`
04:15:18 <mauke> > let foo (x, y) = length [x,y] in foo undefined
04:15:20 <lambdabot>  Undefined
04:15:23 <mauke> > let foo ~(x, y) = length [x,y] in foo undefined
04:15:24 <lambdabot>  2
04:15:32 <bakert> aha.  crazy streets.
04:15:38 <nmessenger> it's irrefutable.  It'll always succeed, and x and y are only deconstructed when used.
04:16:03 <bakert> but i needn't include it if my two functions are going to have values?
04:16:27 <nmessenger> (***) is already defined in Control.Arrow
04:16:55 <ivanm> ?hpaste
04:16:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:17:14 <nmessenger> heh, spell corrector changed that to ?paste :)
04:17:30 <nmessenger> @botsnack
04:17:31 <lambdabot> :)
04:17:51 <mauke> @kale
04:17:52 <lambdabot> 99% of my book has been erased by faulty hdd's
04:18:36 <SamB> you mean keal?
04:18:53 <SamB> I think it is fortunate that keal has so much trouble with hard drives ;-)
04:19:50 <pjd_> bakert: partition sep xs = (pre, post) where (pre, _:post) = break (== sep) xs
04:20:25 <bakert> pjd_, thanks that's cool.  i'm trying to get this *** thing to work though and not having much luck: "pattern syntax in expression context"???
04:20:31 <bakert> that's from the tilde
04:20:49 <mauke> why are you using a tilde?
04:20:52 <nmessenger> just import Control.Arrow((***))
04:20:54 <bakert> ah it's ok i think i can see how to make it work without the tilde
04:20:54 <pjd_> bakert: i dunno, arrows still break my brain
04:21:24 <nmessenger> pjd_: but this is clear for the function arrow, right?
04:21:26 <bakert> nmessenger, yes i'm doing that.  i see, the tilde is from the definition of *** not from a usage of it.  got confused.
04:21:30 <nmessenger> ?src (->) (***)
04:21:30 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
04:22:05 <mauke> > (sqrt *** length) (2, "three")
04:22:06 <bakert> ok another stupid question.  how do i concatenate two lists that are the two parts of a pair?
04:22:07 <lambdabot>  (1.4142135623730951,5)
04:22:09 <nmessenger> you can use arrow operators in the function arrow as delightful tuple-hacking functions
04:22:20 <mauke> @type uncurry (++)
04:22:21 <lambdabot> forall a. ([a], [a]) -> [a]
04:22:26 <nmessenger> heh
04:22:27 <bakert> woo and a hoo.
04:22:30 <bakert> that's good stuff.
04:22:32 <bakert> thanks mauke
04:22:43 <nmessenger> you could always (\(x,y) -> x ++ y)
04:22:51 <nmessenger> if you didn't know uncurry
04:22:53 <bakert> no it must all go on one line!
04:23:23 <nornagon> > length "(\(x,y) -> x++y)" - length "uncurry (++)"
04:23:24 <lambdabot>  Illegal escape sequence
04:23:28 <nornagon> > length "(\\(x,y) -> x++y)" - length "uncurry (++)"
04:23:30 <lambdabot>  4
04:23:48 <nmessenger> EVERYTHING is the libs, you just have to know the right types :D
04:23:58 <pjd_> nmessenger: i'm not sure how to read that arrow definition
04:24:38 <nmessenger> when you apply the (***) operator to two functions f and g, you get a function from (x,y) to (f x, g y)
04:24:56 <hpaste>  ivanm pasted "Changing values in a matrix" at http://hpaste.org/338
04:25:07 <nmessenger> i.e., f is applied to the first, g to the second
04:26:06 <pjd_> nmessenger: i think this is the first time i've seen a binary operation in "operator position" in a definition like that
04:26:39 <pjd_> right, it makes sense
04:26:43 <mauke> heh
04:26:53 <nmessenger> (.) can be defined (.) f g x = f (g x) or (f . g) x = f (g x)
04:26:58 <pjd_> just parse it as (***) f g ~(x,y)
04:27:08 <mauke> f . g = \x -> f (g x)
04:27:22 <nmessenger> also that, modulo MMR
04:27:33 <mauke> (.) = fmap
04:27:37 <nornagon> heh
04:27:49 <bakert> wahey, it all works.
04:27:55 <bakert> fmt d = uncurry (++) $ (fmt' *** id) (span (/= '.') (printf "%0.2f" d)) where
04:28:15 <mauke> @hoogle mapFst
04:28:16 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
04:28:37 <pjd_> partition sep = (id *** tail) . break (== sep)
04:28:48 <nmessenger> mapFst f = (f *** id) I beleive
04:29:03 <nmessenger> s/ei/ie/
04:30:22 <bakert> nmessenger, interesting
04:30:46 <mauke> @type uncurry (***)
04:30:48 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
04:31:09 <nmessenger> ooh!  mapPair!
04:31:13 <nornagon> @src mapFst
04:31:13 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:31:27 <nmessenger> > uncurry (***) (+2) (5, 7)
04:31:28 <nornagon> @src Data.Graph.Inductive.Query.Monad.mapFst
04:31:28 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:31:29 <lambdabot>      Expecting a function type, but found `(a, b)'
04:31:29 <lambdabot>       Expected type: (b ->...
04:31:47 <mauke> @type join (***)
04:31:49 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:32:09 <nmessenger> > uncurry (***) ((+2), negate) (5, 7) -- silly me
04:32:11 <lambdabot>  (7,-7)
04:32:25 <mauke> > join (***) (+2) (5,7)
04:32:27 <lambdabot>  (7,9)
04:32:42 <nmessenger> :)
04:33:39 <mauke> hmm, if join goes m (m a) -> m a, then split should m a -> m (m a)
04:33:51 <ivanm> Last night, some people (I think AStorm was one) told me that Haskell didn't support memoization...
04:34:01 <nmessenger> is that definable for monads in general?
04:34:10 <ivanm> however, from what I've read online, does haskell support memoization of pre-defined functions?
04:34:30 <mauke> nmessenger: what, join?
04:34:36 <nmessenger> split
04:34:41 <pjd_> nmessenger: comonads
04:34:42 <mauke> split = return
04:35:08 <bakert> ?pl fmt d = uncurry (++) $ mapFst fmt' (span (/= '.') (printf "%0.2f" d))
04:35:08 <lambdabot> fmt = uncurry (++) . mapFst fmt' . span ('.' /=) . printf "%0.2f"
04:35:14 <pjd_> mauke: not exactly
04:36:26 <quicksil1er> ivanm: no, nobody told you haskell didn't support memoization
04:36:40 <quicksil1er> ivanm: what we told you was that haskell implementations are not required to automatically memoise
04:36:43 <quicksil1er> (this is quite different)
04:36:56 <quicksil1er> (a) an optimising compiler may choose to memoise some thigns if it wants to
04:36:56 <ivanm> OK, I explained myself badly then...
04:37:02 <bakert> hmm.  why did pl make (/= '.') into ('.' /=) ???
04:37:05 <quicksil1er> (b) you can explicitly memoise if you wish
04:37:12 <pjd_> nmessenger: instead of split, join's dual is usually called cojoin or extend
04:37:15 <ivanm> because a lot of (non-haskell-related-) sites seem to think that Haskell memoises...
04:37:16 <ihope> bakert: because they're the same thing?
04:37:45 <pjd_> sorry, duplicate, not extend
04:37:49 <bakert> is it stylistically preferred?  i've always seen it written the other way.
04:38:03 <SamB> bakert: don't take style points from @pl
04:38:03 <ihope> Anyway, what's a good implementation of reverse?
04:38:15 <bakert> SamB, Okey dokey!
04:38:17 <nmessenger> @src reverse
04:38:18 <lambdabot> reverse = foldl (flip (:)) []
04:38:20 <ihope> SamB: good advice! :-)
04:38:24 <nmessenger> ^^ that's one
04:38:31 <nmessenger> :P
04:38:33 <ihope> nmessenger: looks good.
04:38:34 <ivanm> quicksiller: e.g. http://paste.lisp.org/display/19498 mentions that - as part of the haskell quicksort function - it uses memoisation... is that true?
04:38:41 <ihope> Not bad, at least.
04:39:58 <ihope> @type foldl
04:40:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:40:20 <nmessenger> let snoc = flip (:) in foldl snoc [] (1:2:3:4:[]) = ([]`snoc`4`snoc`3`snoc`2`snoc`1) -- with correct fixity
04:40:46 <nmessenger> er, did I re-reverse that?
04:40:48 <mauke> ivanm: doesn't look memoized
04:40:51 <quicksil1er> ivanm: being a functional language, haskell specifies what the answr should be, not how it's computed
04:41:15 <quicksil1er> ivanm: the compiler is free to generate any code it wants to
04:41:24 <quicksil1er> (which meets the specifications)
04:41:44 <ivanm> mauke: I got confused, because a lot of sites (such as wikipedia) have articles or comments that mention in passing that haskell has memoisation, so I wrote some of my code thinking that that was the case
04:41:57 <nmessenger> in general, computing at compile-time is not a good idea 'x = [1..]' would diverge the compiler
04:42:03 <quicksil1er> ivanm: I imagine what they meant by 'that code is memoised' is that "xs" is shared between the two branches
04:42:23 <bakert> ?src uncurry
04:42:24 <lambdabot> uncurry f p = f (fst p) (snd p)
04:42:26 <ivanm> quicksilier: ahhh.... rather than results being stored somewhere in a lookup table...
04:42:29 <quicksil1er> ivanm: people confuse data-sharing with memoisation, sometimes
04:42:41 <bakert> ?src curry
04:42:41 <lambdabot> curry f x y = f (x, y)
04:42:58 <mauke> @. pl src curry
04:42:59 <lambdabot> (line 1, column 1):
04:42:59 <lambdabot> unexpected end of input
04:42:59 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
04:43:00 <skew> also, looking thing up in a lazily-evaluated data structure is pretty much memoization
04:43:10 <ivanm> quicksilier: so then, to make it explicitly clear, which is which?
04:43:16 <skew> because if you look it up again, it's already been computed
04:43:44 <quicksil1er> ivanm: memoization means this "a function which, when you call it for a second time, on the same arguments, doesn't need to recompute the result because it can remember it from the last time"
04:43:58 <hpaste>  lutz@iks-jena.d pasted "Finding squares where rows and columns are primes" at http://hpaste.org/339
04:43:59 <quicksil1er> ivanm: so it has the property that the actual code will only be executed once per unique set of arguments
04:44:10 <quicksil1er> skew: that happens to be the way ghc and the other compilers implement it
04:44:12 <mauke> whoa
04:44:18 <quicksil1er> skew: AFAIK it's not part of the haskell spec
04:44:21 <ivanm> skew: my problem was, I have a function that might be called on the same input multiple times that I thought would remember the results if it recognised the input, and there's no way that I can think of that I can share a common data structure...
04:44:31 <quicksil1er> ivanm: any function can be memoised
04:44:40 <bakert> ?hoogle String -> IO [String]
04:44:41 <lambdabot> System.Console.Readline.filenameCompletionFunction :: String -> IO [String]
04:44:41 <lambdabot> System.Console.Readline.usernameCompletionFunction :: String -> IO [String]
04:44:46 <quicksil1er> ivanm: in practice what you do is turn your function into a lazy array
04:44:50 <mauke> was that lutz donnerhacke?
04:44:56 <Thunder> Classical space complexity problem.
04:45:00 <Thunder> mauke: Yep.
04:45:00 <bakert> What's the function to read a file into a list of lines?
04:45:19 <quicksil1er> ivanm: erm, well it's rather hard unless your arguments are all (Eq) in fact :)
04:45:31 <Thunder> Probably the completly wrong algorithm.
04:45:32 <nmessenger> @type \name -> fmap lines (readFile name)
04:45:34 <lambdabot> FilePath -> IO [String]
04:45:35 <pjd_> bakert: getContents >>= lines ?
04:45:36 <mauke> Thunder: I recognize your name from usenet :-)
04:45:49 <bakert> ?hoogle getContents
04:45:50 <lambdabot> Prelude.getContents :: IO String
04:45:50 <lambdabot> IO.hGetContents :: Handle -> IO String
04:45:51 <ivanm> quicksilier: the function I wanted memoised is used as part of a testing routine... so unless I manage to work out some weird way using the State Monad (which involves me learning about Monads and State ones in particular)
04:46:00 <bakert> Cool.  Thanks
04:46:05 <quicksil1er> ivanm: that was probably an interesting learning experience
04:46:07 <ivanm> and my types are Eq
04:46:08 <pjd_> bakert: or readFile, or whatever, yeah :)
04:46:11 <quicksil1er> ivanm: arrays would probably have been simpler, though
04:46:11 <Thunder> mauke: Not that unusual.
04:46:48 <ivanm> quicksiller: I haven't learnt Monads yet... I was trying to work them out to see if I could use them this morning, but it got beyond me
04:46:51 <nmessenger> pjd_: though \x -> lines isn't in IO, so you'd need (>>= return . lines), or equivalently, fmap lines
04:46:59 <quicksil1er> blah, I'm sure there used to be a wiki page on memoization I could show you
04:47:07 <ivanm> nope, I looked
04:47:26 <ivanm> and I read through the paper by Peyton Jones on memoisation, and couldn't work out how to implement it
04:47:28 <nmessenger> @type fmap lines getContents
04:47:30 <lambdabot> IO [String]
04:47:31 <pjd_> nmessenger: right, thanks
04:47:36 <ivanm> so I'm just trying to reduce the need for it as much as possilbe
04:47:40 <nmessenger> @type getContents >>= return . lines
04:47:42 <lambdabot> IO [String]
04:47:44 <ivanm> hence my question on hpaste
04:48:04 <quicksil1er> ivanm: what's the hpaste number?
04:48:22 <nmessenger> http://hpaste.org/338 ?
04:48:26 <ivanm> 338, IIRC
04:48:31 <ivanm> yep, that's it
04:48:42 <mauke> @index mapM_
04:48:42 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:49:10 <ivanm> I found out that I was needlessly doing some of the function calls potentially twice (which is why I ask how I can generalise that function for any number)
04:49:47 <quicksil1er> ivanm: blah hpaste doesn't wrap your long lines :)
04:49:49 * quicksil1er reads
04:50:38 <ivanm> quicksiller: sorry, it was word-wrapping as I typed them in, I swear it!!! ;)
04:51:10 <quicksil1er> :)
04:51:23 <mauke> > let base = ["foo","bar"] in iterate (\ss -> [ c:s | s<-ss, c<-base ]) [[]]
04:51:25 <lambdabot>  [[[]],[["foo"],["bar"]],[["foo","foo"],["bar","foo"],["foo","bar"],["bar","b...
04:52:36 <quicksil1er> ivanm: incidentally, do you know for sure that you have a performance problem? Does the un-memo-ized code run too slowly?
04:52:38 <ivanm> mauke: was that meant to be for me? because I don't think that's what I want
04:53:05 <mauke> ivanm: no, just trying to understand some code
04:53:08 <ivanm> Well, I'm doing it on Latin Squares, which is O(n^(n^2)), so I need it to be as fast as possible
04:53:56 <quicksil1er> ivanm: *nod*
04:54:41 <ivanm> quicksiller: I was calling getsubsquares in a procedure f, and mapping function g over the results... part of g involves calling getSubSquares on its input and mapping function h on them
04:54:54 * quicksil1er nods
04:55:44 <ivanm> The function I wanted memoised was the one which solved a given Latin Square... f uses it as part of a predicate, as do g and h
04:56:39 <ivanm> and one problem is that since I'm eventually doing concat . map getSubSquares . getSubSquares, I end up generating each resultant matrix twice, so h is called twice as many times as it needs to be
04:57:34 <ivanm> As it stands, getSubSquares (and its two helper functions) are, IMHO, extremely ugly... but they work
04:58:59 <quicksil1er> ivanm: here's a short example of the standard memoization technique
05:00:00 <hpaste>  (anonymous) pasted "memoize with data.array" at http://hpaste.org/340
05:01:36 <bakert> > uncurry ("one", "two", "three")
05:01:37 <lambdabot>  Couldn't match `a -> b -> c' against `(a1, b1, c1)'
05:01:52 <bakert> > uncurry (++) ("one", "two", "three")
05:01:53 <lambdabot>  Couldn't match `([a], [a])' against `(a1, b, c)'
05:02:02 <bakert> > uncurry (++) ("one", "two")
05:02:03 <lambdabot>  "onetwo"
05:02:16 <quicksil1er> ivanm: see also http://groups.google.co.uk/group/fa.haskell/browse_thread/thread/92901e4f3b55e1dc/41dc38fda7cdc4f9?lnk=st&q=Data.Array+memoize&rnum=2#
05:02:18 <lambdabot> Title: fa.haskell | Google Groups, http://tinyurl.com/24pvqg
05:02:26 <bakert> I have a triple that I want to use as arguments to a function.  Is there a clever way?
05:03:22 <bakert> Actually, it's a list.
05:03:29 <ivanm> quicksiller: yeah, but from how I've written my code I don't think theres any way I can use that technique
05:04:08 <quicksil1er> ivanm: you could use Data.Map instead of Data.Array
05:04:23 <quicksil1er> ivanm: (incidentally, I believe you are suffering from premature optimization)
05:04:33 <ivanm> quicksiller: I meant as in I don't think I can pass a data object around to store the computed values
05:04:45 <quicksil1er> you don't have to pass anything around
05:04:48 <Igloo> bringert: Does cabal-upload use the web interface?
05:04:52 <quicksil1er> it's a top-level definition
05:05:00 <hpaste>  lutz@iks-jena.d annotated "memoize with data.array" with "classical memorization" at http://hpaste.org/340#a1
05:05:21 <ivanm> quicksil1er: in what way? wouldn't that then be a side effect?
05:05:27 <ihope> bakert: you have a list of three elements and you want to pass them to a function?
05:05:48 <bakert> ihope, i want them to be the three arguments to a constructor.
05:05:56 <mauke> let [x,y,z] = list in Cons x y z
05:05:58 <bakert> Account "company" "usr" "pwd"
05:06:09 <bakert> and I have ["company", "usr", "pwd"
05:06:10 <bakert> ]
05:06:22 <ihope> Yeah, pattern match on [x,y,z].
05:06:24 <ivanm> quicksil1er: though I don't see how lutz's example helps...
05:06:34 <bakert> ihope, i see yes of course. thank
05:06:36 <bakert> s
05:06:45 <ihope> @hoogle a -> a -> a -> b
05:06:47 <lambdabot> No matches, try a more general search
05:06:58 <ivanm> quicksil1er (not that I see how your's works, either)
05:07:13 <nmessenger> bakert: if that function is (++), there's concat
05:07:21 <nmessenger> > concat ["foo","bar","baz"]
05:07:23 <lambdabot>  "foobarbaz"
05:08:01 <nmessenger> @src concat
05:08:02 <lambdabot> concat = foldr (++) []
05:08:04 <mauke> > join ["foo", "bar", "baz"]
05:08:06 <bakert> nmessenger, it's a constructor for a type thingy
05:08:06 <lambdabot>  "foobarbaz"
05:08:19 <quicksil1er> ivanm: this is a tricky one to explain
05:08:29 <mauke> heh, @pl can transform code that doesn't typecheck
05:08:29 <quicksil1er> bakert: maybe you're looking for fold, also
05:08:48 <ivanm> @type array
05:08:50 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
05:08:57 <quicksil1er> ivanm: haskell is a language definition, which makes few promises about evaluation strategy
05:09:18 <ivanm> what is Ix?
05:09:20 <quicksil1er> ivanm: the compiler is free to substitute thunks for their partial or complete evaluations
05:09:26 <ivanm> quicksil1er: OK
05:09:27 <mauke> ivanm: an index typeclass
05:09:37 <ivanm> what is a thunk?
05:09:38 <quicksil1er> ivanm: the compiler is also free to share thunks
05:09:41 <nmessenger> so (\f [x,y,z] -> f x y z) for example?
05:09:44 <quicksil1er> a partially evaluated expression
05:09:55 <ivanm> OK
05:09:55 <quicksil1er> or decide to recompute them
05:10:03 <quicksil1er> keep them around for later, or throw them away
05:10:23 <quicksil1er> the language contains no facility to provide explicit instructions to the compiler about this kind of stuff
05:10:31 <ivanm> So thunks are potentially memoised, rather than results from functions?
05:10:32 <quicksil1er> HOWEVER people know how ghc does stuff
05:10:36 <ivanm> Yeah, I realise that
05:10:47 <quicksil1er> and so some people publish hacks which they happen to know have performance characteristics in ghc
05:10:53 <ivanm> OK, so most optimisations are compiler- rather than language-based?
05:11:03 <quicksil1er> in particular, an array is strict in its indices but lazy in its values
05:11:16 <quicksil1er> and GHC arrays, if they calculate the value ones, 'store' that calculated value for later
05:11:43 <ivanm> OK...
05:11:46 <quicksil1er> so, in GHC (and probably all other current haskell implementations) an array can act as a place which stores evaluated data
05:11:53 <quicksil1er> so you can use it for memoisation
05:12:01 <quicksil1er> although you are relying on an implementation detail for this
05:12:16 <ivanm> quicksil1er: let me try and explain my problem a bit more clearly: I have a solving function for Latin Squares, and I want to filter a list of Latin Squares that fit a certain criteria using function f.
05:12:31 <quicksil1er> ok
05:13:01 <ihope> @pl \x y -> foldl1' ($) (repeat x y)
05:13:02 <lambdabot> (foldl1' id .) . repeat
05:13:09 <araujo> morning
05:13:21 <ihope> @type foldl1' id
05:13:21 <ivanm> f tests the results of solve applied to its input: if it obeys a predicate, it then applies getSubSquares to its input and maps g onto each of them
05:13:23 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
05:13:23 <lambdabot>       Expected type: (t -> t1) -> (t -> t1) -> t -> t1
05:13:49 <ihope> You know, I once managed to get @pl to produce untypely code when given valid code.
05:14:11 <quicksil1er> ivanm: ok
05:14:15 <ivanm> g then uses a predicate based on the solution of its predicate, and if it passes calls getSubSquares onto its input and maps function h onto them
05:14:41 <ivanm> function h is just a predicate based on the solution of its input
05:14:58 <quicksil1er> ivanm: does your code actually work yet? does it do what it is supposed to do?
05:15:20 <ivanm> so: f m = (pf (solve m)) && (all g (getSubSquares m))
05:15:28 <ivanm> yeah, it works... just trying to speed it up
05:15:34 <ivanm> because its too slow
05:15:55 <quicksil1er> you could certainly memoise getSubSquares using Data.Map
05:16:10 <ivanm> continuing: g m = (pg (solve m)) && (all h (getSubSquares m))
05:16:12 <quicksil1er> whether it would help yuou any, I don't know
05:16:27 <ivanm> its not getSubSquares that needs to be memoised: its solve
05:16:37 <ivanm> finally, h m = ph (solve m)
05:16:45 * quicksil1er nods
05:16:52 <quicksil1er> you can memoise solve by replacing it with a Data.Map then
05:17:09 <ihope> Now, would this be a good place to ask Epigram questions?
05:17:19 <Thunder> ihope: Yes.
05:17:22 <ivanm> I can? How? (solve also takes in an Int value, which I haven't mentioned, but isn't that big a deal)
05:17:37 <nomeata> Hi. I want to cache results from a monadic function. Is there a Transformer like CacheT or MapT that can help me there?
05:18:29 <ihope> http://pastebin.ca/342633 <- the Epigram that doesn't work
05:19:52 <ivanm> qucksil1er: anyway, I worked out that if I could generalise getSubSquares to work for any Int value I pass through, I could halve the number of times I call h
05:21:35 <quicksil1er> ivanm: you can just make a map which looks like this: ((matrix,int) => solve matrix int)
05:21:39 <ivanm> s/fetch-only/fetch-restricted
05:21:48 <ivanm> sorry, wrong forum :s
05:21:55 <quicksil1er> ivanm: because haskell is lazy, solve won't be evaluated until you require it
05:22:06 <quicksil1er> but it will (probably) store the evaluated version at that point
05:22:11 <matthew_-> ihope: mmm. None of the epigram I've written has used => in the conclusion of a let declaration
05:22:45 <matthew_-> ihope: nor in fact used explicit universal quantification, so I doubt I can help.
05:22:46 <ivanm> quicksil1er: I was thinking of that, but I'm using f as a filter function... so how do I keep it updated whilst filtering all through the list?
05:22:55 <nomeata> @source ReaderT
05:22:55 <lambdabot> ReaderT not available
05:23:03 <nomeata> @source Control.Monad.ReaderT
05:23:04 <lambdabot> Control.Monad.ReaderT not available
05:23:06 <ivanm> has anyone worked out how I can generalise the code I put on hpaste?
05:23:25 <quicksil1er> ivanm: you don't "keep it updated"
05:23:29 <quicksil1er> ivanm: it's automatic
05:24:02 <ivanm> Ummm..... so wouldn't I need to pass this map to function f as a variable?
05:24:06 <quicksil1er> instead of calling solve explicitly, you just call (!)
05:24:10 <quicksil1er> no, you wouldn't
05:24:16 <quicksil1er> haskell doesn't have variables [*]
05:24:16 <ivanm> so it remains in the environment?
05:24:27 <quicksil1er> it's a top level definition
05:24:36 <quicksil1er> in a sense, that's the environment, yes
05:24:42 <ivanm> which means?
05:24:55 <quicksil1er> if my file has "pi = 3.1415" at the top level
05:25:01 <quicksil1er> then every function in that file can refer to pi
05:25:01 <ivanm> So how would I use this map?
05:25:14 <quicksil1er> you'd use (!) which is the lookup operator for maps
05:25:26 <quicksil1er> memoized_solve ! (matrix,int)
05:25:29 <ivanm> yeah, but I thought haskell disallowed mutable assignment? so how does the map get updated?
05:25:39 <quicksil1er> THERE IS NO ASSIGNMENT THERE ARE NO VARIABLES :)
05:25:46 <quicksil1er> excuse the caps :)
05:25:50 <quicksil1er> the map isn't being updated
05:25:53 <quicksil1er> there is no update
05:26:03 <quicksil1er> you are just exploiting a side effect of the implementation of the runtime system
05:26:08 <ivanm> so then how does it act as memoisation?
05:26:20 <nmessenger> for the usual programmer's definition of "variable", not the correct definition :)
05:26:23 <quicksil1er> the map stores pairs ((matrix,int),(answer))
05:26:24 <ivanm> I'm confused here...
05:26:35 <quicksil1er> however, because haskell is lazy, the answers aren't computed until you need them
05:26:44 <quicksil1er> (the answer is defined as "solve matrix int")
05:26:55 <quicksil1er> but this is just stored as an unevaluated thunk
05:26:57 <quicksil1er> until you ask for it
05:27:14 <quicksil1er> when you ask for it, it evaluates
05:27:22 <quicksil1er> once it's evaluated once, it probably saves it for later
05:27:28 <ivanm> if I paste the code for my solve function, can you show me what you mean by using a map, as it still isn't making sense to me?
05:27:31 <quicksil1er> nothing forces it to, but that's how the current RTS is believed to operate
05:27:36 <quicksil1er> ivanm: probably not, no
05:27:42 <quicksil1er> ivanm: since I don't think you understand what Data.Map is
05:27:55 <quicksil1er> ivanm: I think you need to do a little practise before you would understand my explanation
05:27:59 <ivanm> not by the looks of things, no :(
05:28:05 <Thunder> if you add an name to a expression, it will be kept evaluated. Due to the name it can't be destroyed.
05:28:19 <quicksil1er> go lookup the definition of Data.Map
05:28:23 <quicksil1er> and try some simple examples
05:28:38 <ivanm> that's why I pasted the code up on hpaste before... as if I can work that out, then I'll be able to minimize on computations
05:28:41 <nmessenger> ?let m = fromList [(1, 'a'),(2, 'b'), (3, 'c')] :: M.Map Int Char
05:28:42 <lambdabot> <local>:5:4: Not in scope: `fromList'
05:28:48 <nmessenger> ?let m = M.fromList [(1, 'a'),(2, 'b'), (3, 'c')] :: M.Map Int Char
05:28:49 <lambdabot> Defined.
05:28:51 <ivanm> so is Map a monad?
05:28:55 <nmessenger> > m ! 3
05:28:56 <lambdabot>  Couldn't match `Array i e' against `Data.Map.Map Int Char'
05:29:01 <ivanm> @doc Data.Map
05:29:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
05:29:05 <quicksil1er> ivanm: no, map is an associative array
05:29:16 <nmessenger> > m M.! 3
05:29:18 <lambdabot>  'c'
05:29:49 <ivanm> so how does the map get more values added to it then?
05:29:51 <nmessenger> > lookupWithDefault 'x' m 5
05:29:53 <lambdabot>   Not in scope: `lookupWithDefault'
05:30:00 <ivanm> and where can I find examples of using map?
05:30:01 <quicksil1er> ivanm: you define the map with all the values you could ever want
05:30:07 <dons> :t Data.Map.insert
05:30:09 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
05:30:12 <quicksil1er> ivanm: only the ones you actually ask for get evaluated
05:30:20 <quicksil1er> ivanm: this is the magic of lazy evaluation
05:30:23 <ivanm> but thats the thing... it needs to solve a Latin Square then remember the solution
05:30:28 <dons> > M.insert 22 'z' m
05:30:30 <lambdabot>  {1:='a',2:='b',3:='c',22:='z'}
05:30:37 <nmessenger> > M.insert 4 'd' m
05:30:38 <lambdabot>  {1:='a',2:='b',3:='c',4:='d'}
05:30:40 <quicksil1er> ivanm: and that's what it does, as a side-effect of teh way the RTS works
05:30:42 <dons> > M.insert 22 'x' (M.insert 22 'z' m)
05:30:44 <lambdabot>  {1:='a',2:='b',3:='c',22:='x'}
05:30:56 <ihope> ivanm: isn't your "solve" function going to be from Latin Square to solution?
05:30:56 <ivanm> what is RTS?
05:31:02 <quicksil1er> ivanm: run-time-system
05:31:11 <ivanm> well, from a Latin Square to a set of Latin Squares...
05:31:13 <quicksil1er> dons: what is that := notation?
05:31:29 <nmessenger> just what show someMap returns
05:31:30 <ihope> ivanm: LatinSquare -> [LatinSquare], essentially?
05:31:34 <ivanm> except that I don't particularly care about the solutions themselves, just how many there are (i.e. 0, 1 or more than 1)
05:31:39 <ivanm> ihope: yep
05:31:59 <ihope> So you solve the Latin Square and return the solution?
05:32:03 <nmessenger> show (M.fromList [(1,'a')])
05:32:11 <nmessenger> > show (M.fromList [(1,'a')])
05:32:13 <lambdabot>  "{1:='a'}"
05:32:35 <ivanm> yeah... except as it stands, I just never use the solution... I just need to know if there is 0 solutions, 1 solution or multiple solutions
05:33:09 <quicksil1er> nmessenger: isn't "show" syntax supposed to be valid haskell though?
05:33:16 <quicksil1er> nmessenger: is := bound as an operator somewhere?
05:33:33 <quicksil1er> nmessenger: or is this an exception? :)
05:33:48 <ihope> ivanm: then you put the output of the solve function through length and you have an Int.
05:33:51 <nmessenger> quicksil1er: derived Show is guaranteed to be, but I don't think it's a requirement
05:33:52 <ihope> @type length
05:33:53 <lambdabot> forall a. [a] -> Int
05:34:10 <resiak> The idea is that anything show produces, read can read, righT?
05:34:25 <ivanm> ihope: well, actually I use null and a function that returns true if the input matches [_] and false otherwise
05:34:28 <ivanm> but yeah
05:34:47 <ihope> Or you can use a case: case solve x of [] -> Zero; [_] -> One; _ -> Multiple
05:34:51 <ivanm> its just the whole map concept that confuses me
05:34:54 <nmessenger> resiak: that is usually a good idea, but there's no way to force it
05:35:02 <resiak> nmessenger: sure.
05:35:03 <ihope> A map is pretty much a function, isn't it?
05:35:06 <ivanm> ihope: they're different functions, meaning different things: I want them separate
05:35:32 <ihope> number [] = Zero; number [_] = One; number _ = Multiple
05:35:32 <nmessenger> ihope: a function is defined as a mapping from domain to range :P
05:35:42 <ivanm> and I might potentially want the solutions themselves down the track, so I don't want to get rid of them
05:35:55 <ivanm> (they're good for error-checking my code as well)
05:36:04 <quicksil1er> ivanm: do you know what an associative array is?
05:36:18 <ivanm> quicksil1er: that doesn't sound familiar to me :s
05:36:22 <quicksil1er> ivanm: perl hash?
05:36:27 <quicksil1er> ivanm: pyth dictionary?
05:36:48 <nmessenger> [(domain, range)] is an association list from 'domain' to 'range'
05:36:54 <ivanm> quicksil1er: never had to do much dictionary or hash-based stuff... I've used hashmaps in java though
05:37:08 <ivanm> yeah, I get that.... the term wasn't familiar though
05:37:08 <nmessenger> Data.Map.Map domain range is a more efficiently implemented version.
05:37:26 <nmessenger> (probably a hashmap)
05:37:28 <quicksil1er> ivanm: a java hashmap is the kind of map we're talking about
05:37:29 <ivanm> Yeah... but its the usage and how it works that confuses me...
05:37:55 <quicksil1er> nmessenger: no, it's a tree
05:37:59 <ivanm> as in, the fact that the values suddenly appear in it even though mutable state isn't allowed
05:38:10 <quicksil1er> ivanm: the values are always there, but they're lazily evaluted
05:38:28 <quicksil1er> ivanm: however, once they've been evaluated once, they stay there
05:38:29 <ivanm> nmessenger: from the docs "The implementation of Map is based on size balanced binary trees (or trees of bounded balance) as described by:"
05:38:50 <ivanm> OK.... but how do I use a map? are there any examples I can read online?
05:39:13 <nmessenger> ivanm: well, the default functions just create copies, so there's no mutation, but you could do something tricky by storing the map in an IORef and using unsafePerformIO
05:39:17 <quicksil1er> ivanm: nmessenger and dons just showed some examples
05:39:23 <quicksil1er> nmessenger: NO NO NO NO NO!
05:39:32 <quicksil1er> nmessenger: that's not what he wants or needs
05:39:52 <nmessenger> geh, nevermind then. :O
05:39:55 <quicksil1er> ivanm: just play in ghci/hugs
05:40:00 <quicksil1er> ivanm: with a simple map
05:40:14 <ivanm> I meant as in examples using a map for memoisation...
05:40:44 <nmessenger> for pure memoization, I'm not sure how you could avoid unsafePerformIO
05:41:11 <ivanm> but realistically, I think it would be enough if I could generalise the function I put up on hpaste, as that should remove most of the need to memoise
05:41:32 <ihope> If you want to be very fast, write it in C.
05:41:42 <ihope> Or something like that.
05:41:48 <ivanm> ihope: yeah, well, its a bit late for that ;)
05:41:57 <ihope> Indeed.
05:42:07 <nmessenger> I'm not sure how generalization relates to memoization, perhaps you meant refactoring?
05:42:11 <hpaste>  (anonymous) annotated "memoize with data.array" with "Map versio " at http://hpaste.org/340#a2
05:42:11 <Igloo> If you want to be very fast, submit it to the shootout
05:42:22 <matthew_-> ihope: do you have issues with how long Epigram takes to check programs?
05:42:28 <ivanm> besides, my mentors code written a few years ago was in C, and I just found bugs in it as my code produced values his didn't (and I'm not sure how to translate my algorithm to C)
05:42:43 <bringert_> cabal-install install cabal-upload
05:42:51 <quicksil1er> ivanm: map version pasted on same paste
05:43:00 <bringert_> if anyone wants to play with command-line upload to hackage
05:43:07 <ihope> matthew_-: no. Why?
05:43:10 <Igloo> bringert_: Does it use the web interface?
05:43:16 <bringert_> Igloo: yes
05:43:25 <ivanm> quicksil1er: thanks
05:43:39 <matthew_-> ihope: just wondering. I've had it churn on me for many hours before deciding if something's right or not
05:43:52 <bringert_> Igloo: it's a pretty quick hack
05:43:56 <ivanm> nmessenger: the reason being, due to how I'm using the code I pasted, I end up duplicating a whole lot of function calls
05:43:56 <bringert_> Igloo: code here http://darcs.haskell.org/packages/Cabal/cabal-upload/src/CabalUpload.hs
05:43:59 <lambdabot> http://tinyurl.com/34xpdr
05:44:06 <matthew_-> ihope: I assume I've not switched my brain over sufficiently to be talking to it in the right dialogue
05:44:21 <bringert_> Igloo: the user interface is pretty raw
05:44:26 <ivanm> nmessenger: so if I can generalise that function for any number, then that'll remove the need to do a lot of the memoisatioin (not all, but some)
05:44:33 <matthew_-> ihope: have you used omega?
05:44:48 <Igloo> bringert_: So long as it more or less works  :-)
05:44:48 <ihope> matthew_-: omega?
05:44:58 * ihope stops trying to tab-complete matthew_-'s name
05:45:24 <matthew_-> ihope: Tim Sheard's. It's index types rather than dependent types so it's a little more restrictive but compilation is much simpler and hence faster
05:46:15 <matthew_-> ihope: but you get much of Haskell with it so you don't have to reimplement a basic library of functions as you do with Epigram
05:46:19 <ivanm> quicksil1er: so, how would I get a particular value from the map?
05:47:00 <ivanm> quicksil1er: and would a key/value pair work for any x, f (x, f x)?
05:47:04 <nmessenger> ihope: I think the only way to generalize it for any number is to "pretend" it already has every number, then use unsafePerformIO to desctructively update on each new one.
05:47:20 <nmessenger> though I could be missing something
05:48:03 <nmessenger> and it would be icky-feeling
05:48:05 <matthew_-> what's wrong with the classical memoisation?
05:48:45 <ivanm> matthew_: as in?
05:49:09 <nmessenger> matthew-_: can you generalize it for any value in any domain, and not have it generate, for example, 1 through 49 if you only wanted 50?
05:49:37 <nmessenger> other than that, it works great
05:50:17 <matthew_-> err, ok, I must have missed something. For the function pasted, the 50th value depends on the 49th value... so what's the issue with generating the 49th value?
05:51:33 <quicksil1er> ivanm: you get a value using (1)
05:51:40 <nmessenger> well, 'f' doesn't call 'memoized_f' recursively, so unless the compiler memoizes, would it?
05:52:23 <quicksil1er> matthew_-: erm, factorial is a bad example
05:52:33 <quicksil1er> matthew_-: it was only 'an example of a slow function'
05:52:34 <Thunder> nmessenger: Exactly. You have to modify 'f' too, in order to use the memorization.
05:52:43 <matthew_-> ahh. so you want something like memoized_f = 1 : [x * (memoized_f !! (x-1)) | x <- [1..]]
05:52:48 <quicksil1er> Thunder: well I wasn't trying to exploit the recursive dependency
05:52:54 <Thunder> matt: Ack.
05:52:59 <quicksil1er> Thunder: it was only supposed to be an example of a 'slow' function
05:53:00 <nmessenger> matthew-_: which breaks the abstraction of 'f'
05:53:03 <matthew_-> ahh, gotcha
05:53:10 <matthew_-> ...was being slow
05:53:21 <quicksil1er> ivanm: (!) I mean
05:53:29 <nmessenger> don't worry, it's not an uncomplicated thing :)
05:53:35 <Thunder> matt: And if you do so, you can speed it up: fac = 1 : zipWith (*) [1..]
05:53:37 <matthew_-> so you want f to take a list which is a memoized version of itself
05:53:46 <Thunder>  ... missing fac
05:53:47 <ivanm> quicksil1er: that's better, (1) didn't work for some reason ;)
05:53:57 <nmessenger> heh
05:54:15 <Thunder> facs = 1 : zipWith (*) facs [1..]
05:54:19 <nmessenger> if (1) were a peano number...
05:54:40 <ivanm>  (memoized_f f) ! 1 ; <interactive>:1:15: Not in scope: `!'
05:54:51 <quicksil1er> ivanm: you need to import Data.Mapa
05:54:53 <quicksil1er> Data.Map
05:54:56 <quicksil1er> erm
05:55:02 <ivanm> quickSil1er: yep, I did...
05:55:08 <quicksil1er> odd
05:55:12 <quicksil1er> that should define (!)
05:55:20 <nmessenger> qualified?
05:55:31 <ivanm> yeah, to stop clashes with Map
05:55:36 <nmessenger> as?
05:55:41 <ivanm> Map
05:55:54 <nmessenger> try (memoized_f f) Map.! 1
05:56:06 <ivanm> so I changed memoized_f from using Data.Map.fromList to Map.fromList
05:56:26 <matthew_-> f :: [a] -> a -> a; memoized_f :: ([a] -> a -> a) -> [a]; memoized_f f = 0:[f (memoized_f f) x | x <- [1..]]
05:56:29 <ivanm> OK, that works!
05:56:46 <nmessenger> syntax is a nuisance when you don't know it sometimes
05:56:56 <ivanm> so, how could I adapt this to work for any function f?
05:57:15 <quicksil1er> ivanm: make a map from (argument types) to (result types)
05:57:41 <ivanm> quickSil1er: not following you
05:57:44 <nmessenger> you could replace [1..100] with (allValuesOf :: DomainType)
05:58:02 <quicksil1er> ivanm: in java, you can use ANY type as the key for the map
05:58:09 <ivanm> Ahhh... but I don't know all the values that I'm testing for.....
05:58:10 <quicksil1er> ivanm: any type which implements .hashCode()
05:58:24 <quicksil1er> ivanm: it's the same in haskell, any type which implements (Ord)
05:58:30 <ivanm> I want to memoise solve :: Int -> LatinSquare -> [LatinSquare]
05:58:50 <ivanm> LatinSquare was defined using newtype, and is an instance of show and Eq
05:58:55 <ivanm> *Show
05:59:11 <nmessenger> type LatinSquare = [[Int]] -- after the desugaring?
05:59:18 <ivanm> yep
05:59:54 <ivanm> the sugar was just the so that I could implement show directly, and hide definition details
06:00:30 <ivanm> plus, so that I could say that I defined my own type instead of just aliasing everything ;)
06:01:05 <hpaste>  matthew-_ annotated "memoize with data.array" with "Relies on rewriting f a bit" at http://hpaste.org/340#a3
06:01:14 <nomeata> Hmm. I want to create a new Monad Transfomer called CacheT, based on StateT. Is this the right way to go, or am I stuck there already?
06:01:16 <hpaste>  nomeata pasted "CacheT" at http://hpaste.org/341
06:02:28 <nomeata> Do I have to re-implement all chasses that StateT supports if my type CacheT is just an alias for a more complicatet StateT?
06:02:30 <ivanm> matthew_: that's for recursive f's I presume?
06:02:38 <dons> nomeata: newtype'd?
06:02:49 <matthew_-> err, yeah
06:02:50 <dons> nomeata: in which case, just use GHC's newtype deriving to inherit all the old classes
06:02:51 <quicksil1er> ivanm: yes, my choice of a recursive f was a really poor choice
06:03:04 <dons> (i.e. you can derive Monad if you want)
06:03:08 <quicksil1er> ivanm: of course if you do have a recursive function you probably want to make sure it memoises itself
06:03:18 <quicksil1er> ivanm: but really I was just looking for a function I could pretend was 'slow'
06:03:28 <nomeata> dons: strange, if I replace type by newtype, I get kind errors in a line before that
06:03:31 <quicksil1er> ivanm: the recursion is a side issue
06:03:42 <ivanm> quicksil1er: OK, got that
06:03:48 <hpaste>  nomeata annotated "CacheT" with "Type error (with newtype in the code)" at http://hpaste.org/341#a1
06:04:17 <ivanm> so if my type is defined as "newtype LatinSquare = LS [[Int]]", how can I decleare it to be an instance of Ord?
06:04:54 <nmessenger> [[Int]] is in Ord, right?  So deriving (Ord)?
06:04:57 <Syzygy-> ivanm: What, precisely, makes one LS less than another? i.e. what ordering are you using?
06:05:00 <dons> nomeata: did you remember to add the constructor for the newtype?
06:05:06 <Syzygy-> Deriving Ord should work.
06:05:27 <Syzygy-> > compare [[1,2],[3::Int]] [[1],[2],[3]]
06:05:28 <quicksil1er> Syzygy-: he doesn't care, he just wants Data.Map to work
06:05:29 <lambdabot>  GT
06:05:29 <nmessenger> that would use the usual order of lists
06:05:32 <nomeata> dons: eh, probably not. Let me try again
06:05:37 <ivanm> Syzygy: none, really... nmessenger just said that I should make it use Ord for the Map
06:05:46 <Syzygy-> ivanm: So make it deriving Ord.
06:05:58 <Syzygy-> quicksil1er?? Where is our beloved lambdabot?
06:06:20 <quicksil1er> it's here
06:06:23 <nmessenger> Syzygy-: she's probably sleeping
06:06:23 <quicksil1er> didn't you see it answer you?
06:06:27 <quicksil1er> < lambdabot>  GT
06:06:34 <nmessenger> oh yeah
06:06:55 <ivanm> Syzygy: and that would automatically set it up? (I knew there was a word that did that, but couldn't remember what)
06:07:01 <Syzygy-> quicksil1er: Sorry. Misread - it looked as if you were the lambdabot.
06:07:03 <Syzygy-> ivanm: Ayup.
06:07:21 <quicksil1er> Syzygy-: :)
06:07:32 <quicksil1er> newtype-deriving is a GHC extension isn't it?
06:07:42 <nmessenger> ivanm: yep, that would use the Ord for [a] where a is [b] where b is Int
06:07:44 <Syzygy-> ivanm: deriving makes sure that whatever can be reasonably guessed of typeclass implementations for other types is there.
06:08:02 <Syzygy-> It may be ghc though; I don't think about Haskell98 so much as I think about GHC6.6.... :P
06:08:16 <quicksil1er> ivanm: incidentally, although I'd hate to get distracted, using a newtype to mask a Show is possibly poor style
06:08:22 <ivanm> that lets me remove my "instance Eq" then!
06:08:26 <chessguy> 'morning, haskellers
06:08:29 <nmessenger> :)
06:08:33 <quicksil1er> ivanm: Show is intended to make machine-readable reps, if you want your own pretty printer make an explicit one
06:08:54 <ivanm> quicksil1er: well, I asked last night whether it was good practice to create new types, and people replied yes
06:09:06 * quicksil1er nods
06:09:12 <quicksil1er> it is, just not for that reason :)
06:09:16 <ivanm> (well, dons replied that he created new types for everything anyway) ;)
06:09:21 <Syzygy-> ivanm: Making decent types of your own is a good idea.
06:09:25 <quicksil1er> it's good practice because it gives clearer type signatures
06:09:26 <ivanm> quicksil1er: not just that
06:09:31 <hpaste>  nomeata annotated "CacheT" with "With newtype, second try" at http://hpaste.org/341#a2
06:09:35 <quicksil1er> and better type checking
06:09:42 <nomeata> dons: is that what you meant with newtype?
06:09:44 <ivanm> yeah, but I left my definition of Matrix as a type synonym
06:10:32 <ivanm> OK, so it derives Ord... how can I use that for Map?
06:10:57 <matthew_-> are clauses in lets definately evaluated?
06:11:07 <nmessenger> M.fromList [((1,[[0]]), solve 1 [[0]])]
06:11:26 <nmessenger> generate Ints and Matrices how you like
06:11:50 <quicksil1er> matthew_-: IIRC, they are WHNF, yes
06:11:51 <ivanm> btw, I was told that when redirecting output from a C program you need to flush the buffer... do I need to do the same with haskell? (i.e. can I read a file that I'm redirecting output to mid-way through a program)?
06:11:58 <quicksil1er> matthew_-: I alsways get confused
06:12:06 <quicksil1er> ivanm: you could hSetBuffering stdout NoBuffering
06:12:06 <ivanm> nmessenger: OK, I'll try that...
06:12:13 <nmessenger> s/[[0]]/LS [[0]]/g
06:12:25 <nmessenger> +parens of course
06:13:04 <ivanm> quicksil1er: what does that mean? how about if I manually write the stuff to file instead of using redirection?
06:13:14 <quicksil1er> ivanm: it turns off buffering
06:13:24 <quicksil1er> not desperately efficient but it solves your problem
06:13:34 <quicksil1er> you could also scatter explicit flushes around if you prefer
06:13:40 <ivanm> quicksil1er: how does it effect efficiency?
06:13:55 <chessguy> "<quicksil1er> ivanm: Show is intended to make machine-readable reps, if you want your own pretty printer make an explicit one"
06:14:02 <chessguy> ...i think you mean human-readable?
06:14:07 <Thunder> ivan: It's slower, but this is the price for Unix IPC.
06:14:10 <quicksil1er> chessguy: no, I mean machine readable
06:14:22 <nmessenger> ivanm: though if you want to keep your Row type, then newtype LatinSquares = LS [Row]; newtype Row = R [Int]
06:14:24 <ivanm> I'm printing my latin squares out using: printList (x:xs) do putStrLn (show x) ; printList xs
06:14:25 <quicksil1er> chessguy: by convention the output of show should be a valid haskell expression
06:14:50 <chessguy> but it's output as a string so that the human can read it
06:15:04 <quicksil1er> chessguy: but the particular choice of string format is also one that the machine can read
06:15:06 <Thunder> ivanm: You are not required to to Unix IPC unless you deal with unix processes.
06:15:20 <chessguy> ahh, i see now. thanks for the clarification
06:15:23 <ivanm> nmessenger: my row type is just used internally, and I use extraction/creation functions to get the matrices in/out of LatinSquares
06:15:41 <ivanm> Thunder: what is IPC?
06:15:43 <quicksil1er> ivanm: if you want to learn about buffering and how it affects performance I'm sure there are many books and web pages on the subject
06:16:01 <quicksil1er> ivanm: http://justfuckinggoogleit.com/search.pl?query=IPC
06:16:02 <Thunder> ivanm: Inter Process Communication. Read your Stevens.
06:16:03 <lambdabot> Title: Just Fucking Google It
06:16:16 <nmessenger> heh
06:16:22 <ivanm> Thunder: Stevens?
06:17:01 <Thunder> ivanm: Try it out. Google does not hurt.
06:17:40 <ivanm> yes, but what is this Steven's of which you speak?
06:18:05 <blsecres> is there set of functions in the base libraries for interacting with terminals at a specific baud rate?
06:18:10 <Thunder> http://en.wikipedia.org/wiki/W._Richard_Stevens  ... ISBN: 0201563177
06:18:25 <blsecres> or will I just have to use sequence, map and usleep?
06:18:31 <ivanm> and the IPC you are referring to is no. 5 on the google listing...
06:18:35 <quicksil1er> ivanm: amazingly, a google search for 'IPC Stevens' would have answered that exact query
06:18:38 <dons> blsecres: nope. you'll have to roll your own there.
06:18:49 <quicksil1er> ivanm: we are here to help but it would be nice if you used a little initiative
06:19:04 <blsecres> dons: alright, thanks
06:19:36 <chessguy> quicksil1er,let's not turn this channel into ##c++, please
06:19:38 <ivanm> sorry, but its been a long day for me, and I need sleep :s
06:19:45 <ivanm> mind not thinking much anymore :s
06:19:54 <nmessenger> @google  Google is not a programming teacher
06:19:56 <lambdabot> http://www.dzone.com/rsslinks/google_is_not_a_programming_teacher.html
06:19:57 <lambdabot> Title: Google is not a programming teacher
06:20:07 <nmessenger> :P
06:20:29 <ivanm> besides, i'm so used to having to look up stuff for everyone else who's too lazy or doesn't know how to search (i.e. my parents, or people at uni)
06:20:41 <nmessenger> :( it's down
06:20:44 <ivanm> that it didn't occur to me that that was what I was doing :(
06:21:06 <quicksil1er> chessguy: apologies
06:21:38 <quicksil1er> chessguy: I know #haskell is famous for being friendly, I'd hate to change that
06:22:02 <quicksil1er> chessguy: but if you browse back for the last couple of hours you can see I've been pretty helpful to ivanm, I jsut thought he'd crossed the line into laziness :)
06:22:32 <chessguy> quicksil1er, i'm not debating that
06:23:23 <ivanm> quicksil1er: sorry, though as another partial apology most of the IRC stuff is new to me as well, and I sometimes get confused if its an IRC convention or something else
06:23:45 * nmessenger demands that everyone hugs each other
06:23:56 <ivanm> Anyway, before I offend anyone else with my laziness, I'll get to bed and try and work on this (later) in the morning
06:24:05 <quicksil1er> :)
06:24:08 <quicksil1er> sleep is good!
06:24:15 * ivanm backs away slowly from nmessenger: "I don't know where you've been!!!"
06:24:18 <ivanm> g'night!
06:24:25 <nmessenger> :O
06:24:27 * ihope hugs nmessenger, ivanm, quicksil1er, chessguy, and lambdabot
06:24:32 <nmessenger> >:/
06:24:48 <ihope> (minus ivanm)
06:25:27 <nmessenger> @tell ivanm *hug!*
06:25:28 <lambdabot> Consider it noted.
06:25:53 <Thunder> http://209.85.129.104/search?q=cache:aDphxALww6oJ:request.reddit.com/user/Bogtha/%3Fs%3Dhot+%22Google+is+not+a+programming+teacher%22&hl=de&ct=clnk&cd=26&gl=de
06:25:56 <lambdabot> http://tinyurl.com/ytpusn
06:27:36 <nmessenger> @tell ivanm ... you bastard :P
06:27:37 <lambdabot> Consider it noted.
06:35:51 <ihope> @tell lambdabot You evil little... uh, bot, you. I want my hug back.
06:35:51 <lambdabot> Nice try ;)
06:36:05 * ihope throws pencils at lambdabot
06:36:13 <nmessenger> @slap ihope
06:36:13 * lambdabot slaps ihope
06:36:30 <ihope> D'oi.
06:36:31 * nmessenger hugs ihope
06:37:14 * ihope dies of confusion
06:38:24 * nmessenger becomes CAPTAIN LAMBDA! and eta-extends ihope back to life
06:38:27 <fasta> I have an algorithm implemented in a certain monad via a run_<my monad>. I would like to add user-defined state to the monad, sucht that if I slightly generalize the algorithm, the user can use any type for his state. Since the state must be initialized at some point and it must be able to hold any type, I thought using the value undefined would work. Does it?
06:39:01 <Botje> :t undefined
06:39:03 <lambdabot> forall a. a
06:39:10 <Botje> looks like it
06:39:16 <dcoutts_> fasta, or you can require the initial state as a parameter to run_<my monad>
06:39:32 <fasta> dcoutts_: I am doing that already.
06:39:44 <dcoutts_> fasta, then why the undefined?
06:39:45 <chessguy> @quote lambda
06:39:45 <lambdabot> JohnMeacham says: her name is lambda and she dances on the sand
06:39:52 <fasta> dcoutts_: But the idea is that the algorithms are parametrized with monadic actions.
06:40:01 <fasta> dcoutts_: one of these actions must be: fetch user state
06:40:08 <dcoutts_> fasta, better than undefined would be (error "you forgot to initialise the state!")
06:40:15 <nomeata> I get this error message:
06:40:15 <nomeata>     No instance for (CacheMonad Bool r (CacheT Bool Integer IO))
06:40:15 <nomeata>       arising from use of `callCache' at <interactive>:1:13-26
06:40:15 <fasta> dcoutts_: agreed
06:40:26 <nmessenger> where has shapr been?  I've missed the crazy.
06:40:27 <nomeata> But :  :i CacheMonad
06:40:28 <nomeata> class (Monad m, Ord a) => CacheMonad a b m where
06:40:28 <nomeata>   callCache :: a -> m b
06:40:28 <nomeata>         -- Defined at CacheT.hs:8:26
06:40:28 <nomeata> instance (Monad m, Ord a) => CacheMonad a b (CacheT a b m)
06:40:43 <nomeata> so the instance is defined, or what am I missing?
06:41:34 <fasta> dcoutts_: The problem is that the user state is not known by the general algorithm. Do you see that? I don't see another way than using undefined (or error)
06:42:36 <chessguy> nmessenger, he's been really busy. i talked to him yesterday
06:43:17 <dcoutts_> fasta, I don't quite see why the state can't be passed in initially, and hence the whole thing be parameterised by the user's state type.
06:43:56 <dcoutts_> evalStateT :: (Monad m) => StateT s m a -> s -> m a
06:44:04 <dcoutts_> for example
06:44:25 <ihope> So in Epigram, just what does <= rec foo do?
06:44:29 <sjanssen> nomeata: did you write the CacheMonad yourself?
06:45:12 <nomeata> sjanssen: Yes, I try at least
06:45:29 <hpaste>  nomeata annotated "CacheT" with "CacheT, current try" at http://hpaste.org/341#a3
06:45:38 <chessguy> ?seen shapr
06:45:38 <lambdabot> I saw shapr leaving #happs 13h 47m 20s ago, and .
06:45:54 <chessguy> hmm, shortly after i talked to him i think
06:46:12 <hpaste>  sjanssen annotated "CacheT" with "a fundep might help" at http://hpaste.org/341#a4
06:46:19 <nomeata> sjanssen: it is very similar to StateT, just that instead of a State, it keeps a cache of monadic function results
06:46:32 <sjanssen> nomeata: try that annotation
06:46:59 <nomeata> sjanssen: no, doesnâ€™t help
06:47:07 <fasta> dcoutts_: I don't really see what StateT has to do with it, but yes, I can parametrise it.
06:47:10 <nomeata> eh, nevermind, different erro
06:47:44 <dcoutts_> fasta, I was just using StateT as an example of a monad parameterised by some user's state and how it doesn't need any undefined.
06:48:00 <nomeata> sjanssen: thx, it seems that did the trick
06:48:19 <quicksil1er> fasta: the undefined trick is certainly not going to work ;)
06:48:46 <quicksil1er> fasta: haskell is a strongly typed language after all
06:48:49 <fasta> quicksil1er: why wouldn't it?
06:48:56 <fasta> quicksil1er: I think it does work.
06:48:59 <quicksil1er> because get_user_state has to have a type
06:49:07 <quicksil1er> otherwise the user can't do anything with it
06:49:12 <michaelw> fasta: I used undefined as initial value for a Reader monad, because it is guaranteed that the value passed in is not looked at (rather it is shadowed depending on the input data)
06:49:48 <quicksil1er> fasta: parameterising the monad sounds like a better plan to me
06:50:00 <nmessenger> quicksil1er: undefined can be typed
06:50:01 <quicksil1er> fasta: you could do something nasty with Data.Dynamic but I doubt that's what you want
06:50:07 <nmessenger> > undefined :: Int
06:50:09 <lambdabot>  Undefined
06:50:12 <quicksil1er> nmessenger: I know
06:50:22 <fasta> quicksil1er: I am pretty sure that my trick does work.
06:50:44 <quicksil1er> fasta: then probably we are talking as cross purposes
06:50:54 <fasta> quicksil1er: but I already said that parameterising it is better.
06:50:55 <nmessenger> > undefined :: Either () (Either (String, Bool) Char) -- heh
06:50:57 <lambdabot>  Undefined
06:51:01 <quicksil1er> fasta: if you are in fact paramterising by the type, and just using undefined as an initialiser
06:51:01 <nomeata> nice, itâ€™s working
06:51:03 <roconnor> @djinn (Either a (Not a)) -> (((a->b)->a)->a
06:51:04 <lambdabot> Cannot parse command
06:51:09 <roconnor> @djinn (Either a (Not a)) -> (((a->b)->a)->a)
06:51:10 <lambdabot> f a b =
06:51:10 <lambdabot>     case a of
06:51:10 <lambdabot>     Left c -> c
06:51:10 <lambdabot>     Right d -> b (\ e -> void (d e))
06:53:11 <resiak> @type void
06:53:13 <lambdabot> Not in scope: `void'
06:53:19 * resiak looks at @djinn
06:54:53 <roconnor> void is the empty type
06:55:00 <roconnor> er
06:55:03 <roconnor> Void is the empty type
06:55:10 <roconnor> void :: Void -> a
06:55:35 <nmessenger> so void = const undefined?
06:56:11 <roconnor> (void x) does a case analysis on x.  It returns a value of type a in all branches. ... there just happen to be no branches
06:56:36 <roconnor> void x = case x of {}
06:56:46 <nmessenger> ooooh.
06:57:27 <roconnor> even if there are not normal values of type Void, it is still a useful type
06:57:47 <roconnor> for example voidId :: Void -> Void can be written as voidId x = x
06:58:03 <swiert> roconnor: I have a quick Coq question...
06:58:39 <roconnor> ok
06:58:49 <swiert> Is there some way to apply a tactic to all subgoals?
06:59:19 <swiert> I want to define a eq_dec for a data type with a lot of constructors and kill the off diagonal cases.
06:59:40 <roconnor> The closest thing is ; .  So tac;[try trival] will try trivial for all subgoals generated by tac
06:59:48 <roconnor> er
06:59:56 <roconnor> tac;(try trival)
07:00:09 <roconnor> or something like that
07:00:17 <roconnor> BTW, you can also ask in #coq
07:00:25 <bakert> I'm getting Could not find module `System.Time.Parse':
07:00:25 <bakert>       it is a member of package parsedate-2006.11.10, which is hidden
07:00:26 <swiert> Yeah - but there aren't usually that many people around.
07:00:38 <swiert> Thanks - I'll give that a go.
07:00:41 <bakert> I've just installed it so it is there.  Am I doing something thick?
07:00:43 <roconnor> I have use that to prove eq_dec in the past
07:01:09 <Saizan> bakert: have you added it to the dependencies in cabal?
07:01:22 <Saizan> or is it in ghci?
07:01:43 <bakert> Saizan, aha.  yes that will be it.  i moved it.
07:02:02 <hpaste>  Elifant|home pasted "This program causes "Stack overflow" on 1.2M file. I need master of strictness!" at http://hpaste.org/342
07:02:04 <roconnor> swiert: hmmm, apparently there is also the decide equality tactic
07:02:18 <bakert> well, i moved the code that calls it.  from one module to a shared module.  hmm, wonder why it works locally.
07:02:19 <swiert> roconnor: what does that do?
07:02:22 <roconnor> that should work on simple inductive types
07:02:46 <roconnor> http://coq.inria.fr/doc/Reference-Manual010.html#@tactic78
07:02:47 <lambdabot> Title: Tactics
07:02:54 <roconnor> forall x y:R, {x=y}+{~x=y},
07:03:01 <roconnor> This tactic solves a goal of the form forall x y:R, {x=y}+{~x=y}, where R is an inductive type such that its constructors do not take proofs or functions as arguments, nor objects in dependent types.
07:03:42 <swiert> roconnor: Amazing - it works.
07:03:58 <roconnor> a lot faster than proving it yourself ;)
07:04:45 <swiert> roconnor: Yep. That saves me a lot of dull work.
07:04:53 <roconnor> yay for computers
07:05:43 <dblhelix>  /quit
07:06:13 * nmessenger makes /quit joke
07:06:34 * bakert laughs heartily at another's foolishness and another another's quip
07:10:53 <Elifant|home> can anybody help with my 'stack overflow'?
07:11:19 <nomeata> @djinn (Monad m) => [m ()] -> m ()
07:11:20 <lambdabot> Cannot parse command
07:11:37 <nomeata> ah, sequence_
07:11:58 <trurl> Elifant|home: there's a nice wiki page about stack overflows related to foldl/foldr
07:12:27 <Elifant|home> trurl: can you give me an URL?
07:12:49 <roconnor> heh, the typical solution to stack overflows is to replace foldl with foldl'
07:12:54 <trurl> http://www.haskell.org/haskellwiki/Stack_overflow
07:12:55 <lambdabot> Title: Stack overflow - HaskellWiki
07:13:05 <Elifant|home> trurl: tnx
07:13:28 <glguy> there are few places that foldl is appropriate :)
07:13:42 <roconnor> yep
07:14:13 <glguy> it is unfortunate that we need to consider that ourselves still
07:18:20 <glguy> !paste
07:18:20 <hpaste> Haskell paste bin: http://hpaste.org/
07:19:07 <nmessenger> +/new?
07:20:24 <sjanssen> @keal
07:20:24 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
07:20:51 <glguy> nmessenger: you are thinking of
07:20:55 <glguy> @paste
07:20:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:21:00 <nmessenger> @paste
07:21:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:21:51 <sjanssen> @past
07:21:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:21:59 <glguy> @losers
07:22:02 <lambdabot> Maximum users seen in #haskell: 322, currently: 303 (94.1%), active: 40 (13.2%)
07:22:08 <sjanssen> @spate
07:22:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:22:16 <chessguy> glguy, i resemble that remark
07:22:33 <glguy> I'm not going to dignify myself with a response!
07:22:34 * ihope looks at #haskell's banlist, then proceeds to not make that mistake again
07:23:04 <sjanssen> ihope: hmm?
07:23:29 <ihope> I got two screens of ban.
07:23:38 <ihope> Flooded myself.
07:23:49 <ihope> Or spammed, if you want to go that route.
07:24:09 <glguy> I don't think you can spam... yourself
07:24:31 <ihope> That's what "/mode #haskell +b" did.
07:24:36 <nmessenger> glguy: I can try!
07:24:48 <ihope> There, I did it again.
07:24:59 * resiak hands out crapbuster.pl
07:25:01 <ihope> Now, who's Palomer again?
07:25:02 <allbery_b> you've never had a periodic cron job go awry, I see :)
07:25:38 <ihope> I know I remember that name...
07:25:47 <sjanssen> palomer used to hang out in #haskell, but was frequently OT, so he was banned
07:26:04 <glguy> he was always whining
07:26:16 <sjanssen> ah yes, with the whining
07:26:21 <sjanssen> and refused to read the manual
07:26:23 <ihope> I see.
07:26:31 <glguy> he doesn't seem to mind being banned... it's a simple nick ban
07:26:40 <roconnor> @quote palomer
07:26:41 <lambdabot> No quotes match. Where did you learn to type?
07:26:45 <glguy> @palomer
07:26:46 <lambdabot> You're all nuts
07:26:49 <ihope> === ChanServ!ChanServ@services. banned *!*@ppp-71-128-92-216.dsl.pltn13.pacbell.net from #haskell on Monday, January 15, 2007 8:59:06 PM.
07:26:56 <ihope> Is that Palomer's?
07:27:07 <glguy> I think palomer's is palomer!*@*
07:27:24 <glguy> 09:23 (*) 9 - #haskell: ban palomer!*@* [by ChanServ!ChanServ@services., 1514292 secs ago]
07:27:46 <ihope> You sure that one's not also Palomer?
07:27:51 <glguy> I'm not sure
07:28:23 <ihope> My guess is it is.
07:28:49 <nmessenger> > shows (floor $ 1514292 / 86400) " days ago""
07:28:49 <lambdabot>  Improperly terminated string
07:28:54 <nmessenger> > shows (floor $ 1514292 / 86400) " days ago"
07:28:56 <lambdabot>  "17 days ago"
07:29:17 <glguy> > shows (1514292 `div` 86400) " days ago"
07:29:19 <lambdabot>  "17 days ago"
07:29:29 <nmessenger> silly me
07:30:33 <roconnor> @check \x y -> (x/y) == floor (x `div` y)
07:30:35 <lambdabot>  Add a type signature
07:30:59 <glguy> ?check \x y -> y /= 0 ==> div x y == floor (fromInteger x / fromInteger y)
07:31:01 <lambdabot>  OK, passed 500 tests.
07:31:01 <glguy> ?scheck \x y -> y /= 0 ==> div x y == floor (fromInteger x / fromInteger y)
07:31:03 <lambdabot>   Completed 169 test(s) without failure.  But 13 did not meet ==> condition.
07:32:11 <roconnor> ?check \x y -> y /= 0 ==> quot x y == floor (fromInteger x / fromInteger y)
07:32:13 <lambdabot>  Falsifiable, after 18 tests: 2, -4
07:32:29 <nmessenger> floor (1 / (0::Double))
07:32:34 <dcoutts_> @seen SyntaxNinja
07:32:35 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 14h 30m 8s ago, and .
07:32:38 <nmessenger> > floor (1 / (0::Double))
07:32:40 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:32:48 <nmessenger> eh?
07:33:09 <roconnor> that's a big number
07:33:18 <nmessenger> it shouldn't be finite
07:33:28 <glguy> > length . show . floor $ 1 / 0
07:33:29 <lambdabot>  309
07:33:36 <roconnor> oh
07:33:47 <roconnor> 309 sounds close to the exponent size of doubles?
07:34:08 <dcoutts_> hugs gives "arithmetic overflow" for floor inf
07:34:12 <dcoutts_> ghc doesn't
07:34:13 <nmessenger> > 1 / 0
07:34:15 <lambdabot>  Infinity
07:34:30 <glguy> > 2^1024
07:34:31 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:34:41 * nomeata notices that sometime, 6 month year old own haskell code can be as unreadable as 6 month year old perl code.
07:34:47 <glguy> > 2^1024 == floor (1/0)
07:34:49 <lambdabot>  True
07:34:52 <nmessenger> cool
07:34:53 <glguy> I am the win!
07:35:04 <quicksil1er> nomeata: for different reasons
07:35:12 <nmessenger> er, not so cool, bug! (?)
07:35:26 <glguy> > 2^1024+1 > floor (1/0)
07:35:28 <lambdabot>  True
07:35:31 <nomeata> quicksil1er: not really. Concice syntax and the possibility to do things in weird ways.
07:35:36 <roconnor> well, floor doesn't really work so well on large doubles, what do you expect.
07:35:45 <nomeata> actually, just programmer failure, I guess :-)
07:35:57 <quicksil1er> nomeata: a lot of the weird haskell ways involve names
07:36:05 <quicksil1er> nomeata: which you either know or you don't
07:36:05 <roconnor> The problem is using Doubles in the first place ;)
07:36:13 <roconnor> Doubles dont follow normal arithmetic laws
07:36:47 <nmessenger> > 1 % 0
07:36:49 <lambdabot>  Exception: Ratio.%: zero denominator
07:36:51 <roconnor> @check \a b -> (a + b)  -  b = (a::Double)
07:36:52 <lambdabot>  Parse error
07:37:00 <glguy> ==
07:37:04 <roconnor> @check \a b -> (a + b)  -  b == (a::Double)
07:37:06 <lambdabot>  Falsifiable, after 1 tests: 2.6666666666666665, 2.0
07:37:17 <roconnor> wow
07:37:18 <roconnor> 1 test
07:37:35 <hpaste>  nomeata pasted "Unreadable code (IMHO)" at http://hpaste.org/343
07:37:38 <bd_> @check \a b -> (a + b) - b /= (a::Double)
07:37:38 <nmessenger> 2/3 doesn't fit easily into base 2
07:37:40 <lambdabot>  Falsifiable, after 0 tests: -0.5, -1.0
07:37:55 <xerox> nmessenger: what?
07:37:57 <glguy> ?check \a b -> b /= 0 ==> a * b / (b :: Double)
07:37:59 <lambdabot>   add an instance declaration for (Testable Double)     In a lambda abstracti...
07:38:13 <glguy> ?check \a b -> b /= 0 ==> (a :: Double) * b / (b :: Double)
07:38:14 <lambdabot>   add an instance declaration for (Testable Double)     In a lambda abstracti...
07:38:25 <bd_> glguy: ==> expects boolean arcs on the right side
07:38:27 <bd_> args*
07:38:31 <glguy> oh :)
07:38:31 <roconnor> == a
07:38:33 <nmessenger> xerox: Doubles are bits when you get down to it.
07:38:39 <glguy> ?check \a b -> b /= 0 ==> a * b / (b :: Double) == a
07:38:40 <lambdabot>  Falsifiable, after 10 tests: 1.8571428571428572, -5.666666666666667
07:40:37 <nmessenger> 0.1 is 1/2, 0.01 is 1/4, 0.11 is 3/4, etc.
07:40:40 <xerox> nmessenger: (2/3)_10 = (10/11)_2
07:40:52 <glguy> nomeata: you might be cramming a bit too much into one function :-p
07:40:55 * roconnor uses default (Rational) in his financial code.
07:41:18 <glguy> ?check \a b -> b /= 0 ==> a * b / (b :: Rational) == a
07:41:20 <lambdabot>  OK, passed 500 tests.
07:41:22 <glguy> ?scheck \a b -> b /= 0 ==> a * b / (b :: Rational) == a
07:41:23 <lambdabot>  add an instance declaration for (Serial (Ratio Integer))
07:41:24 <lambdabot>     In the definiti...
07:41:39 <nmessenger> rather a finite number of digits.  It doesn't fit into base 10 either :P
07:43:15 <nomeata> glguy: I guess. But it made perfect sense when I wrote it
07:44:46 <gotaku> Where can I find some short examples of using the State monad?
07:45:20 <glguy> > runState ( do { a <- get; put (a+1); return (a*3) } ) 5
07:45:24 <lambdabot>  (15,6)
07:45:36 <ihope> So, the next big Epigram question thingy: http://pastebin.ca/342788
07:46:06 <quicksil1er> first couple of times I used it, I rolled my own state monad. That helped the understanding process for me. But glguy's answer is short + helpful.
07:46:32 <gotaku> glguy: I'm confused about how runState works.
07:46:42 <nmessenger> @src runState
07:46:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:46:53 <glguy> gotaku: it takes a computation of type State a b
07:46:55 <nmessenger> @src State
07:46:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:47:00 <glguy> gotaku: and an initial state value of type a
07:47:05 <ihope> Looks like it takes the initial state and returns (result, final state).
07:47:08 <fasta> @src Control.Monad.State
07:47:09 <lambdabot> Source not found. Take a stress pill and think things over.
07:47:12 <glguy> gotaku and returns the values of type (b,a)
07:47:15 <nmessenger> @vote cheeky-off "Goddammit Yes!"
07:47:16 <lambdabot> usage: @vote <poll> <choice>
07:47:17 <fasta> @src Control.Monad.State.runState
07:47:18 <lambdabot> Source not found. Where did you learn to type?
07:47:26 <glguy> ?type runState
07:47:28 <lambdabot> forall s a. State s a -> s -> (a, s)
07:47:44 <glguy> runState is just a field name on State
07:48:08 <glguy> runState ^^ take a computation and an initial state and return the new state and the result
07:48:12 <glguy> ?type evalState
07:48:14 <lambdabot> forall a s. State s a -> s -> a
07:48:16 <ihope> lambdabot's reminding me of sudo.
07:48:26 <glguy> take a computation and an initial state and just give me the result
07:48:31 <glguy> ihope: that is the source
07:48:47 <gotaku> Why is it type State s a -> s -> (a, s)? The definition says it's runState :: (\s -> (a, s)
07:49:05 <roconnor> > let task = do x <- get; put (x+1); manytasks = sequence_ (replicate 100 task) in runState manyTasks 55
07:49:05 <lambdabot>  Parse error
07:49:18 <glguy> because the (\s -> (a,s)) is a field on State { runState :: s -> (a,s) }
07:49:27 <roconnor> > let {task = {do x <- get; put (x+1)}; manytasks = sequence_ (replicate 100 task)} in runState manyTasks 55
07:49:28 <lambdabot>  Parse error
07:49:31 <Igloo> gotaku: It's a bit confusing because it's defined as a record field name
07:49:49 <rc-1> http://neilbartlett.name/blog/?p=11
07:49:51 <lambdabot> Title: Neil&#8217;s point-free blog Â» Haskell: Too Hard, or Just Hard Enough?
07:49:57 <Igloo> gotaku: So it implicitly takes a record as its first argument
07:50:01 <glguy> gotaku: the function "runState" extracts that function described from the constructor
07:50:13 <glguy> that function you described*
07:50:32 <glguy> With the state monad, you write you computations like the state already exists
07:50:48 <glguy> and at teh very outside layer, you specify what the starting value is
07:51:15 <nmessenger> @src State (>>=)
07:51:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:51:19 <nmessenger> darn
07:52:27 <glguy> m >>= k  = State $ \s -> let (a, s') = runState m s in runState (k a) s'
07:52:40 <roconnor> > let {task = do {x <- get; put (x+1)}; manytasks = sequence_ (replicate 100 task)} in runState manyTasks 55
07:52:41 <lambdabot>   Not in scope: `manyTasks'
07:52:46 <glguy> ?unmtl State Double Int
07:52:46 <lambdabot> Double -> (Int, Double)
07:52:47 <roconnor> > let {task = do {x <- get; put (x+1)}; manytasks = sequence_ (replicate 100 task)} in runState manytasks 55
07:52:49 <lambdabot>  ((),155)
07:52:53 <roconnor> we
07:52:55 <roconnor> wee
07:53:14 <glguy> roconnor: replicateM_
07:53:26 <roconnor> I need Dr. Haskell ;)
07:53:36 <roconnor> > let {task = do {x <- get; put (x+1)}; manytasks = replicateM_ 100 task} in runState manytasks 55
07:53:38 <lambdabot>  ((),155)
07:53:58 <bryanl> today i start my journey down the path to functional enlightenment
07:54:08 <xerox> it's up the path, sorry.
07:54:17 <bryanl> I bought "Hashell, The craft of functional programming" at bordes today
07:54:17 <glguy> every long journey begins with a one first long fall
07:54:22 <norpan> along the path
07:54:30 <bryanl> glguy: i don't doubt it
07:54:33 <nmessenger> grasshopper, it is a worthwhile parth indeed
07:54:42 <nmessenger> parth!  :)
07:54:49 <norpan> perth!
07:55:10 <glguy> bryanl: actually, this is Haskell, Hashell is down the hall and to the left
07:55:12 * nmessenger *totally* did not look cool there
07:55:22 <bryanl> glguy: lol
07:55:31 <bryanl> my keyboard is cold
07:55:36 * glguy recommends the new-comer pay no mind to nmessenger, we babysit him as a favor to his mom ;)
07:57:24 <opqdonut> :)
07:57:30 <nmessenger> :|
07:58:00 <nomeata> Is there something like IORef, i.e. type safe state variable, but independant of IO, as part of some Monad Transformer?
07:58:26 <xic> STRef?
07:58:26 <dcoutts_> nomeata, there's the ST monad which has STRefs
07:59:27 <roconnor> @hoogle STRef
07:59:28 <lambdabot> Data.STRef :: module
07:59:28 <lambdabot> Data.STRef.STRef :: data STRef s a
07:59:28 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
07:59:40 <gotaku> How do you load modules in ghci?
07:59:42 <glguy> nomeata: no
07:59:49 <nmessenger> :m + Data.Bits
07:59:56 <glguy> nomeata: There is no such Monad *transformer*
08:00:40 <glguy> just as there is no IO transformer
08:00:51 * roconnor feels that everyone knows way more about Monad Tranformers than he does
08:01:10 * nmessenger probably knows less than roconnor
08:01:12 <roconnor> I always just write my own monads by hand.
08:01:16 <nomeata> My CacheT works now, and allows me to make ceartain monadic (here IO) calls cheap. But the problem Iâ€™m having is that for every function that I want to cache, I have to add another layer of CacheT.
08:01:50 <nomeata> So Iâ€™m looking for a better way
08:02:05 <glguy> nomeata: maybe your cache type coudl be a record with many fields, one for each function
08:02:31 <glguy> and you could use a function to bring different fields into and out of focus
08:02:40 <glguy> like HAppS's localState function
08:03:08 <glguy> data D = D { f1, f2 :: YourCacheType }
08:03:37 <nomeata> hmm. Iâ€™ll think about that.
08:03:38 <Syzygy-> Igloo: Ping?
08:03:42 <P4W3R> hi
08:03:53 <Syzygy-> Igloo: About to setup a gentoo/x86_64 buildbot slave.
08:04:02 <glguy> withF1 m = do a <- get; modify f1; m; modify (\s -> setF1 x a)
08:05:32 <Syzygy-> Hmmm... Rereading the call for buildbots, it seems mine is a common platform.
08:05:43 <glguy> modify (\x -> setF1 x a)*
08:05:53 <nomeata> glguy: but then, both cached functions have to have the same type, right?
08:06:13 <glguy> nomeata: { f1 :: OneType, f2 :: AnotherType }
08:06:44 <nomeata> It would be extra-nice to find a way to add cached functions later, compareable to IOâ€™s IORef.
08:07:14 <sjanssen> you can do it with ST
08:08:09 <nomeata> Although ST is not a transformer, and I have to do IO?
08:08:32 <paolino> is there a project for a haskell shell to replace sh or csh ?
08:08:37 <sjanssen> ah, that would be a problem
08:08:39 <glguy> ST is a Monad, and not a Monad Transformer, and if you are already in IO, you should just use IORefs
08:08:57 <roconnor> @hoogle ST a -> IO a
08:08:59 <lambdabot> No matches, try a more general search
08:09:06 <glguy> unsafeSTtoIO?
08:09:20 <roconnor> is that unsafe?
08:09:26 <sjanssen> @hoogle ST RealWord a -> IO a
08:09:27 <lambdabot> No matches, try a more general search
08:09:33 * paolino wants arrow for parallel shell command piping
08:09:35 <sjanssen> @hoogle stToIO
08:09:35 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
08:09:42 <sjanssen> that functions is safe
08:09:49 <glguy> but doesn't buy you anything
08:10:08 <roconnor> but ST is parametric in its first parameter right?
08:10:13 <sjanssen> it takes advantage of the fact that the IO monad is actually ST
08:10:21 <roconnor> so it /could/ be RealWord
08:10:43 <roconnor> glguy: why doesn't that buy you anything?
08:10:49 * roconnor doesn't use ST himself.
08:10:58 <glguy> if you are writing the code in IO anyway
08:11:16 <glguy> ST is good because you an strip away the ST layer and get a pure functoin
08:11:20 <roconnor> glguy: but you know that foo : ST a Int doesn't reformat your hard drive.
08:11:29 <Syzygy-> > ( sum . join ) [[1,2],[3],[4]]
08:11:30 <lambdabot>  10
08:12:01 <glguy> roconnor: but if he needs to do IO while doing memoized functions, he can't be jumping into and out of ST
08:12:16 <sjanssen> the idea is to write code that can be executed with both runST and stToIO -- then you have proof that the ST stuff is safe
08:12:41 <roconnor> glguy: you could be right, I can't entirely imagine what he is trying to do.
08:12:52 <nomeata> I can try to explain my problem
08:13:12 <sjanssen> there should probably be a function :: IO a -> ST RealWorld a
08:13:13 <roconnor> but it seems good that you could write generic things with ST, and move them to IO in some situations.
08:13:16 <nomeata> My program takes a bunch of files and produces output, if the output is not already up to date.
08:13:27 <nomeata> Some of the input files (not all) are latex files
08:13:36 <roconnor> sjanssen: ah, maybe it goes that way.
08:13:50 <nomeata> So the latex producer looks into these files for dependencies, and recursive dependencies, to check if it has to do something.
08:14:09 <nomeata> My problem is that for each latex file, the file and all dependencies are looked at
08:14:27 <nomeata> And some dependencies are shared among many files.
08:14:42 <nomeata> So Iâ€™m trying to think of a good way of not wasting this time.
08:15:10 <nomeata> I already use ContT to cache the result of getModificatinTime and doesFileExist, but now I discovered this call to open...
08:15:16 <sjanssen> nomeata: are the sets of functions you're caching dynamic or static?
08:15:17 <nomeata> s/ContT/CacheT/
08:15:49 <nomeata> sjanssen: What do you mean by dynamic?
08:16:05 <nomeata> sjanssen: I expect the result to not change during the run of the program.
08:17:11 <sjanssen> but you know exactly which functions need caching at compile time?
08:17:18 <nomeata> sjanssen: yes
08:17:22 <sjanssen> okay
08:17:46 <nomeata> sjanssen: Itâ€™s just too many and in too many separated modules to put a CacheT for each of them into my Monad-Transformer-Stack
08:18:41 <nomeata> And Iâ€™d like to keep all Latex-related stuff in the Latex.hs module, even though the execution jumps in and out that module for each latex file to handle.
08:20:43 <nomeata> the code would be here: http://svn.nomeata.de/wsvn/latexki/
08:20:45 <lambdabot> Title: WebSVN - latexki - Revision 222 - /
08:22:13 <sjanssen> nomeata: glguy's record approach is looking the nicest
08:23:12 <sjanssen> or break down and use IORefs
08:24:58 <bryanl> ghc is taking forever to build
08:25:02 <nomeata> :-) ok
08:25:27 <sjanssen> bryanl: what sort of hardware do you have?
08:25:34 <bryanl> sjanssen: macbook pro
08:25:52 <bryanl> and when i say forever... its only been a few minutes :)
08:25:54 <sjanssen> it shouldn't take more than an hour
08:26:05 <quicksil1er> it takes quite a bit longer than a few minutes, from scratch :)
08:26:10 <bryanl> ok
08:26:19 <bryanl> gives me time to read the first few chapters of this book
08:26:21 <sjanssen> it was something like that last time I compiled ghc+extralibs on my macbook
08:26:26 <quicksil1er> it has to build some kind of bootstrap compiler. actually I'm not sure how it does work.
08:26:34 <quicksil1er> is there a simple version of ghc written in C?
08:26:39 <sjanssen> no
08:26:48 <quicksil1er> how does it bootstrap then?
08:27:13 <sjanssen> ghc can generate platform independent C code
08:27:31 <sjanssen> but, as I understand it, bootstrapping is a painful and error prone process
08:28:00 <quicksil1er> sjanssen: yes, but before ghc is compiled, something has to compile ghc
08:28:46 <sjanssen> quicksil1er: you start with a ghc binary on a platform that already has one
08:29:03 <sjanssen> and you use that ghc to generate C code to compile with the C compiler on the new platform
08:29:37 <CrewdenX> quicksil1er: you porting it or just wondering what they did "in the beginning."    if you're talking about the latter, maybe hugs?
08:31:18 <quicksil1er> CrewdenX: I'm wondering how you compile ghc on a machine for the first time
08:31:28 <quicksil1er> when I did 'port install ghc' I don't think it downloaded a binary
08:31:33 <quicksil1er> maybe it did, I wasn't watching it that closely
08:32:13 <CrewdenX> quicksil1er: assuming you're going to a platform that already supports c you'd do it as sjanssen says.
08:32:58 <quicksil1er> hmmm
08:33:08 <CrewdenX> http://web.mit.edu/ghc/www/users_guide/faq.html
08:33:10 <lambdabot> Title: Chapter 13. GHC FAQ
08:34:05 <gotaku> Does haskell have something like linked lists?
08:34:18 <sjanssen> gotaku: the standard list type is a linked list
08:34:42 <sjanssen> > [1, 2, 3] -- here, have a linked list
08:34:43 <lambdabot>  [1,2,3]
08:34:51 <mornfall> that was a great question
08:34:52 <mornfall> :)
08:34:59 <gotaku> sjanssen, How do I remove an element at an index?
08:34:59 * mornfall goes to look for some food
08:35:08 <mornfall> gotaku: you create a new list without that element
08:35:15 <mornfall> there's no such thing as mutation
08:35:26 <gotaku> That's not a linked list then.
08:35:31 <sjanssen> gotaku: yes it is
08:35:38 <gotaku> Internally maybe.
08:35:56 <mornfall> you aren't with haskell for long, are you? :)
08:35:56 <quicksil1er> gotaku: haskell is a functional language; mutable data types are not the natural idiom
08:36:06 <quicksil1er> (they exist, and you can use them, but they're not natural)
08:36:14 <sjanssen> mutability is an orthogonal issue
08:36:20 <gotaku> mornfall: Not really.
08:36:53 <mornfall> sjanssen: depends
08:36:55 <gotaku> I need an array that is mutable and able to grow in length.
08:37:03 <mornfall> gotaku: you don't :)
08:37:12 <mauke> gotaku: why?
08:37:20 <mornfall> and using linked lists for than in imperative language is usually a bad idea anyway :)
08:37:29 <sjanssen> gotaku: there aren't any growable arrays in the standard libs
08:37:50 <quicksil1er> gotaku: what people are trying to say is that there are better ways of doing it, very likely
08:37:57 <bd_> Data.Map?
08:38:03 <gotaku> I'm taking a shot at trying to implement the ICFP 2006's contest UM in Haskell.
08:38:07 <quicksil1er> gotaku: it is more helpful to focus on what you want to calculate, than *how* you want to calculate
08:38:13 <Jaak> > let sl [] = "[]"; sl (x : xs) = show x ++ " -> " ++ sl xs in sl [1,2,3] -- now it's linked list!
08:38:15 <lambdabot>  "1 -> 2 -> 3 -> []"
08:38:27 <sjanssen> gotaku: ahh, now your requests become clear :)
08:39:06 <quicksil1er> CrewdenX: thanks
08:39:10 <sjanssen> there was a grow instruction in the UM?  I don't really remember
08:39:25 <mauke> gotaku: just use malloc/realloc :-)
08:39:30 <mornfall> eh
08:39:32 <mornfall> --> food :)
08:39:33 <mornfall> laters
08:40:14 <int-e> no, just allocate and free.
08:40:46 <int-e> or, as they called it, abandon.
08:41:18 <gotaku> sjanssen, Well the arrays themselves don't grow but there is the ability to allocate more arrays.
08:45:07 <gotaku> I'm using an IOUArray to store each array and I'm wondering how to store all currently allocated arrays and have the ability to store more.
08:46:19 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
08:46:21 <lambdabot> http://tinyurl.com/yz86s7
08:48:34 <nomeata> how can this deadlock:
08:48:36 <nomeata> 	(inp, out, err, pid) <- runInteractiveProcess "pdftk" options Nothing Nothing
08:48:36 <nomeata> 	hClose inp
08:48:36 <nomeata> 	info <- hGetContents out
08:48:36 <nomeata>         forkIO $ waitForProcess pid >> return ()
08:48:42 <nomeata> the deadlock goes away if I remove the forkIO line
08:49:40 <nomeata> (This solution was suggested on haskell-cafe)
08:50:58 <sjanssen> nomeata: it can deadlock if the err pipe fills up
08:51:05 <sjanssen> or if the process is waiting on input
08:51:12 <xerox> > let delete n xs = fst (foldr (\x (xs,n) -> case n of 0 -> (xs,n-1); _ -> (x:xs,n-1)) ([],n) xs) in delete 3 "gotaku"
08:51:14 <lambdabot>  "goaku"
08:51:27 <nomeata> sjanssen: strace tells me that pdftk is writing on stdout, and the haskell program is running waitpid
08:51:40 <nomeata> does waitpid block a lightweight thread?
08:52:25 <dcoutts_> Heffalump, you know about the C grammar...  mind if I pick your brain some time. I'm rewriting the c2hs C parser again. I'm trying to do the ident/tyident thing correctly.
08:52:49 <dcoutts_> Heffalump, starting with porting the Roskind C grammar to happy.
08:53:13 <dcoutts_> (you don't happen to know of a better freely available C grammar)
08:53:40 <dcoutts_> erm, that was a question :-)
08:53:47 <dcoutts_> not a statement
08:57:04 <glguy> > let delete n xs = let (a,_:b) = splitAt n xs in a ++ b in delete 3 "gotaku"
08:57:06 <lambdabot>  "gotku"
08:57:23 <glguy> > let delete n xs = let (a,_:b) = splitAt (n-1) xs in a ++ b in delete 3 "gotaku"
08:57:25 <lambdabot>  "goaku"
08:57:51 <rahikkala> @src delete
08:57:52 <lambdabot> delete = deleteBy (==)
08:57:53 <dvekravy> df
08:57:56 <rahikkala> @src deleteBy
08:57:58 <lambdabot> Source not found. You type like i drive.
08:58:26 * rahikkala thinks and shrugs
08:58:30 <glguy> My function was in the spirit of something that was in the scroll back when I came back to my desk
09:05:48 * Cale wonders how long until Java gets an IO monad.
09:06:09 <glguy> Like I needed any more reasons to avoid ruby like a playground full of pungee sticks. a friend informs me that :symbol objects can never be garbage collected
09:06:21 <glguy> (ruby being his langauge of choice)
09:07:00 * resiak wonders how common a name "Gibbard" is
09:07:20 <sjanssen> gotaku: my UM kept a list of "free" array IDs.  When the the list was empty I allocated a new array (with double the size of the previous one) and copied the contents of the old array
09:07:28 <glguy> There has been a Gibbard in every channel that I've been a regular in
09:07:36 <sjanssen> (sorry for the late reply, I'm "working")
09:08:02 <resiak> glguy: has it always been Cale? :)
09:08:06 <glguy> resiak: shh
09:08:27 <resiak> Heh.
09:08:45 <Cale> resiak: Not that common, but not all that uncommon either.
09:08:48 <paolino> glguy, :symbol are objects ?
09:08:54 <glguy> aparently
09:09:00 <paolino> nah
09:09:01 <resiak> Cale: Okay.  Then it's unlikely that you're related to Ben Gibbard from The Postal Service ;)
09:09:02 <Cale> I'm not aware of any relation to the furniture people.
09:09:16 <paolino> they are names
09:09:43 <Cale> resiak: I am related to John Gibbard from Crowbar.
09:10:25 <glguy> paolino: either way, they are allocated into memory when used
09:10:35 <glguy> and removed from memory whe nthe application clsoes
09:11:32 <paolino> mmh, you cannot build them "runtime"
09:11:34 <resiak> Cale: neat
09:11:47 <paolino> like every object
09:11:49 <Cale> resiak: They were #1/#2 in Canada for a little while back in the 70's :)
09:12:41 <paolino> well you can probably , hacking eval , if ever useful
09:12:41 <resiak> Cale: So Wikipedia tells me.
09:17:50 <gotaku> Wow, I just added a few bang patterns to the mandelbrot shootout entry and now it's 20 seconds faster.
09:18:07 <matthew_-> mmm. what's that as a % ?
09:19:09 <matthew_-> I find bang patterns really useful. The unboxing you can get is *grrrreat*
09:19:14 <gotaku> Around 40% I think.
09:19:21 <matthew_-> that's impressive
09:19:26 <gotaku> On my computer anyway.
09:19:40 <matthew_-> mmm. paste it?
09:19:46 <sjanssen> gotaku: http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=mandelbrot&lang=ghc&id=3 that entry?
09:19:49 <lambdabot> Title: mandelbrot Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Th ..., http://tinyurl.com/22r99n
09:20:11 <gotaku> sjanssen: Yes.
09:20:25 <gotaku> I added the bang patterns to the lp function.
09:20:35 <glguy> gotaku:
09:20:36 <glguy> !paste
09:20:36 <hpaste> Haskell paste bin: http://hpaste.org/
09:20:37 <matthew_-> mmm. I wonder if with the bang patterns the back end is able to keep all the values in registers
09:21:03 <matthew_-> either that or the hit rate into some cache has massively improved
09:21:03 <gotaku> Why do I have to paste? I change takes 2 seconds.
09:21:16 <gotaku> The change.
09:21:53 <sjanssen> gotaku: did you just add bang patterns to every match?
09:21:59 <Cale> Oh, yes, that really does want strictness.
09:22:06 <Cale> lp is tail-recursive, that's evil.
09:22:10 <gotaku> sjanssen: Yes, just to see the effect.
09:22:24 <Cale> gb would also probably benefit
09:22:42 <Cale> in the first, third, and last parameters of gb
09:23:01 <Cale> and first, second and third parameters of lp
09:23:05 <matthew_-> can you get ghc to dump the assembly it's generated?
09:23:17 <sjanssen> Cale: what is so bad about tail recursion?
09:23:32 <sjanssen> as far as I can tell, lp should be tail recursive
09:23:37 <Cale> sjanssen: It doesn't get along very well with laziness.
09:24:08 <matthew_-> right - if it doesn't force the eval of the args until the base case then the memory use is as bad as non-tail-recursive I'm guessing?
09:24:14 <sjanssen> that code is not going to benefit from laziness
09:24:19 <sjanssen> lp, to be specific
09:24:27 <gotaku> I need to fix a lot of things about this program. Notice I'm calculating cr from scratch on every single pixel.
09:24:30 <Cale> Right, because it's tail recursive :)
09:24:39 <Cale> Now, wait a sec, pattern matching in lp is going to force some things already.
09:24:41 <sjanssen> Cale: no, because of the type of computation it does
09:24:50 <Cale> That too.
09:24:58 <Cale> It's collapsing information.
09:25:39 <Cale> r and i will already get evaluated, so they don't need bangs
09:25:48 <Cale> oh, and so will k
09:25:50 <Cale> hmm.
09:25:54 <glguy> is integer division generally faster than floating division?
09:26:08 <Cale> er, cr and ci aren't used?
09:26:21 <Cale> why are they getting passed around?
09:26:28 <matthew_-> Cale: even if they are evaluated, won't the bang encourage them to be unboxed?
09:26:29 <sjanssen> Cale: they're used but they don't change
09:26:45 <Cale> oh, I see
09:26:53 <Cale> In the recursive case, yes.
09:27:12 <Cale> Perhaps it would help to move them so they're first.
09:27:21 <glguy> ceiling $ w / 8       ((w-1) `shiftR` 3) + 1   --
09:27:26 <glguy> something like that?
09:27:40 <glguy> too slow?
09:28:18 <sjanssen> on my machine mandelbrot 3000 goes from 13.9s to 10.69s after wildly adding bang patterns to every pattern
09:29:05 <Cale> I wish things were named more descriptively.
09:29:10 <gotaku> I have a better version then the one posted on the shootout but for some reason it fails the check against mandelbrot-output.txt
09:29:48 <sjanssen> Cale: yeah :(, this code is totally opaque
09:30:08 <gotaku> What are you confused about?
09:31:13 <matthew_-> what it does, why, and how.
09:31:26 <ihope> !dijon (mustard -> ketchup -> mayo) -> (mustard -> ketchup) -> mustard -> mayo
09:31:41 <ihope> Right, right.
09:31:47 <ihope> @dijon (mustard -> ketchup -> mayo) -> (mustard -> ketchup) -> mustard -> mayo
09:31:48 <lambdabot> Unknown command, try @list
09:31:53 <ihope> Pff.
09:32:17 <glguy> ?check \x -> ceiling ((x :: Double) / 8) == (ceiling x-1 :: Int) `shiftR` 3 + 1
09:32:18 <lambdabot>  OK, passed 500 tests.
09:32:46 <matthew_-> @djinn (mustard -> ketchup -> mayo) -> (mustard -> ketchup) -> mustard -> mayo
09:32:47 <lambdabot> f a b c = a c (b c)
09:32:56 <glguy> I'm guessing that an addition, subtraction and shift are slower than one floating divide
09:33:11 <Cale> @. pl djinn (mustard -> ketchup -> mayo) -> (mustard -> ketchup) -> mustard -> mayo
09:33:11 <lambdabot> f = ap
09:34:08 <Cale> glguy: hmm... It might be worth trying though.
09:34:24 <sjanssen> glguy: that computation only happens once
09:34:30 <glguy> sjanssen: well then
09:34:35 <sjanssen> the change is too insignificant
09:34:37 <Cale> oh, that's true
09:34:45 <mwc> @seen SyntaxNinja
09:34:46 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 16h 32m 22s ago, and .
09:34:58 <mwc> Damn, I was gonna pester him about trac
09:35:01 <glguy> sjanssen: I'm still curious
09:35:12 <sjanssen> glguy: I tried it, no change
09:35:13 <gotaku> glguy, Actually I removed that part.
09:36:04 <Cale> Is dons around?
09:36:09 <mwc> glguy, re add + sub + shift vs fp divide? I suspect that the divide is slower, unless you have an Opteron or something with a comparitively insane FPU
09:36:16 <mwc> @seen dons
09:36:17 <lambdabot> dons is in #haskell, #happs, #ghc, #haskell.hac07 and #haskell-overflow. I last heard dons speak 3h 17m 43s ago.
09:36:24 <sjanssen> Cale: I think this is the middle of the night for him
09:36:24 <Cale> Hmm, he's probably asleep.
09:36:26 <Cale> Yeah
09:36:28 <Cale> It is.
09:37:15 <Cale> I can tell that by the little moon on my panel showing me the weather in Melbourne. :)
09:37:48 <gotaku> http://hpaste.org/329
09:38:04 <Cale> Oddly, Gnome doesn't have a panel widget for international clocks though.
09:38:05 <gotaku> For some reason that fails the diff check against the test data.
09:38:13 <glguy> In my ROUGH test, g x = (ceiling x - 1) `shiftR` 3 + 1 took 3 cursor blinks while f x = ceiling (x / 8) took 5
09:38:56 <glguy> however
09:39:04 <glguy> that was because the first run had to generate the list I was mapping over
09:39:10 <glguy> doing each test twice fixed that :)
09:39:26 <gotaku> ceiling was originally included because I thought this program had to work on all input sizes.
09:40:03 <glguy> what does it requrie for you to resubmit your program with added strictness
09:40:14 <gotaku> The shootout should change the input size to 3001 and see how many programs break.
09:40:16 <matthew_-> cursor blinks? :set +s ?
09:40:50 <glguy> that's handy :)
09:43:39 <sjanssen> from the shootout entry: "mapM_ putChar"?!  that's going to be slow
09:45:03 * malcolmw wonders if anyone in here has managed to get yhc to build on MacOS
09:45:07 <paolino> a profile could tell ?
09:45:45 <glguy> mapM_ putChar == putStr?
09:46:07 <glguy> ?type mapM_ putChar
09:46:09 <lambdabot> [Char] -> IO ()
09:46:20 <Syzygy-> ?type putStr
09:46:21 <lambdabot> String -> IO ()
09:46:26 <Syzygy-> ?src putStr
09:46:27 <lambdabot> putStr s  = hPutStr stdout s
09:46:34 <Syzygy-> ?src hPutStr
09:46:35 <lambdabot> Source not found. Are you on drugs?
09:46:52 <xerox> ?slap lambdabot
09:46:53 <lambdabot> why on earth would I slap lambdabot
09:47:51 <gotaku> sjanssen, I used mapM_ putChar on the advice of dons.
09:47:54 <matthew_-> ?djinn ReasonableQuestion -> Maybe OffensiveAnswer
09:47:54 <sjanssen> goes from 10.6s to 7.6s switching from mapM_ putChar to putStr
09:47:55 * matthew_- wonders if answer will be "lambdabot"
09:47:55 <lambdabot> f _ = Nothing
09:47:58 <sjanssen> gotaku: bad advice
09:48:13 <gotaku> sjanssen: Actually he thought using  putStr was illegal.
09:48:30 <sjanssen> or perhaps mapM_ putChar was needed for strictness
09:48:54 <sjanssen> gotaku: you are correct "Write output byte-by-byte"
09:49:10 <Igloo> Where's the spec?
09:49:24 <gotaku> sjanssen: Although the Lisp program uses write-sequence
09:49:25 <sjanssen> Igloo: http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=mandelbrot&lang=all bottom of the page
09:49:27 <lambdabot> Title: mandelbrot benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 The Sandbox, http://tinyurl.com/ynotqy
09:50:07 * Igloo would argue that laziness means putStr should be allowed
09:50:21 <Syzygy-> @remember matthew_- matthew_-: ?djinn ReasonableQuestion -> Maybe OffensiveAnswer  lambdabot: f _ = Nothing
09:50:21 <lambdabot> Done.
09:50:24 * bryanl patiently waits for ghc to finish compiling
09:50:31 * bringert_ is really happy about hackage
09:50:38 <matthew_-> mmm. this channel should rework one shootout benchmark a week.
09:50:57 <gotaku> Using putStr doesn't seem to make a difference anyway, at least on my machine.
09:51:03 <Nafai> matthew_-: It would be pretty cool to see that kind of collaboration
09:51:24 <glguy> The LISP solution writes a whole buffer at a time
09:51:30 <glguy> (write-sequence buffer stream)))
09:52:11 <ndm> matthew_-: that seems awfully slow progress, i'd say more like one an hour ;)
09:52:38 <mauke> hmm, what should the return type of runParserT be?
09:52:44 <matthew_-> ndm: yeah, but we want each one to go REALLY fast!
09:52:51 <timseves> if you set the buffer mode to NoBuffer and used putStr would that satisfy the spec?
09:53:35 <matthew_-> url for the spec?
09:53:50 <glguy> Each program should plot the Mandelbrot set [-1.5-i,0.5+i] on an N-by-N bitmap. Write output byte-by-byte in portable bitmap format.
09:53:53 <glguy> the spec ^^
09:53:56 <matthew_-> right
09:54:02 <matthew_-> yes, just read that last sentence
09:54:42 <glguy> that's seems like such an arbitrary requirement
09:54:44 <gotaku> Would using putStr on a lazy list mean byte-by-byte?
09:55:00 <matthew_-> is that to avoid working out the filesize in advance and then using mmap, writing it to memory and just closing the file?
09:56:26 <paolino> mmh, writig the file should not be the slow part anyway
09:56:38 <glguy> it was the difference of 3 seconds
09:56:50 <paolino> on 60 ?
09:57:07 <glguy> 11:44  sjanssen> goes from 10.6s to 7.6s switching from mapM_ putChar to putStr
09:57:08 <sjanssen> gotaku: no, putStr does chunks
09:57:40 <sjanssen> the problem is getting the lock on the handle n times instead of n/chunksize times
09:57:49 <gotaku> I really need a new computer.
09:58:01 <matthew_-> mmm. the C version does putc
09:58:01 <gotaku> I'm running it in the 50-ish second range.
09:58:30 <Syzygy-> You really have to look the handle n times? Sounds bloody stupid to me, but....
09:58:35 <timseves> sjanssen: unless you set the buffer mode to NoBuffer then does it per character (after checking the sources)
09:59:44 <matthew_-> also the C version compiles with sse flags to gcc. You might want to try for ghc -fglasgow-exts -fexcess-precision -optc-O3 -optc-ffast-math -optc-mfpmath=sse
10:01:39 <sjanssen> I'm now at 5.67s, using lazy bytestrings for output
10:01:58 <gotaku> sjanssen: Paste?
10:03:36 <ALVAN> hi all
10:03:45 <ALVAN> here there is coldfusion support?
10:03:49 <hpaste>  sjanssen pasted "mandelbrot -- strict and bytestring'd" at http://hpaste.org/346
10:04:12 <mauke> ALVAN: who sent you here?
10:04:12 <rahikkala> ALVAN: Unlikely :)
10:04:29 <matthew_-> yikes, the scala version out performs the java version. That's odd.
10:04:39 <ALVAN> i know haskell is a type of compiler ..ghc i guess ???
10:04:50 <ALVAN> or language :)
10:04:53 <Cale> ALVAN: Haskell is a programming language, GHC is a compiler for Haskell.
10:04:55 <ALVAN> language better
10:05:27 <Cale> ALVAN: It's a pretty cool programming language at that. It's certainly my favourite, of the 15 or 20 that I'm familiar with.
10:05:47 <ALVAN> :)nice
10:07:18 <gotaku> sjanssen: Your program fails the diff check.
10:07:38 <sjanssen> gotaku: hmm, I don't think I changed anything
10:07:47 <sjanssen> I'll double check
10:09:32 <bringert_> kolmodin: the current BNFC darcs version is now cabalized: http://www.cs.chalmers.se/Cs/Research/Language-technology/darcs/BNFC/
10:09:34 <lambdabot> Title: Index of /Cs/Research/Language-technology/darcs/BNFC, http://tinyurl.com/26fnwq
10:10:27 <sjanssen> gotaku: can you tell me the md5 checksum of mandelbrot 3000
10:10:38 <sjanssen> a working mandelbrot, that is
10:11:02 <Cale> Man, I couldn't keep up with these mailing lists if I tried.
10:16:28 <gotaku> sjanssen: Yes, hold on.
10:17:40 <fons> hi all
10:17:49 <sjanssen> gotaku: I accidentally flipped the print statements around
10:18:43 <gotaku> sjanssen: Oh I see ;)
10:19:04 <fons> where could I find a good tutorial about state monads? I'm confused with Control.Monad.State and Control.Monad.ST
10:19:17 <hpaste>  sjanssen annotated "mandelbrot -- strict and bytestring'd" with "mandelbrot 3000 gives md5 b81a92d242a6db5a7672101ea13e5c4f" at http://hpaste.org/346#a1
10:19:36 <timseves> fond:All about Monads is a good general turorial and has a section on State monads
10:20:18 <fons> thanks timseves
10:20:23 <sjanssen> gotaku: the version I just pasted seems to work over here.  Could you doublecheck it?
10:21:24 <sjanssen> I would like execution time figures from you too if it isn't any trouble
10:21:25 <fons> I've been using Haskell for years in colleges but never found a good text book which covered the advanced topics of Haskell it is annoying having to read through unfriendly spreaded documentation to understand them :S
10:21:40 <fons> college*
10:21:51 <sjanssen> the program has gone from 13.89s to 5.66s over here
10:23:44 <trurl> what does the "| m -> r" in "class Monad m => MonadReader r m | m -> r where" mean?
10:24:08 <ihope> trurl: I think it means if you know m, you can find r.
10:24:16 <ihope> For every m, there can be only one matching r.
10:24:25 <mauke> functional dependency
10:24:34 <fons> trurl, is a functional dependency
10:24:38 <trurl> thanks
10:24:58 <fons> trurl, it is not standard Haskell 98
10:25:02 <gotaku> sjanssen: Seems to work but still more changes can be done.
10:25:46 <fons> trurl, they are necessary to avoid certain problems with multiparameter classes
10:26:34 <timseves> sjanssen: I get 2.464s user for mandelbrot 3000
10:28:55 <sjanssen> gotaku: algorithm changes?
10:29:10 <gotaku> sjanssen: Yes.
10:29:35 <sjanssen> gotaku: I'll leave you to those changes :)
10:29:44 <gotaku> sjanssen: Heh, alright.
10:30:10 <ihope> fons: "certain problems"?
10:30:19 <sjanssen> I do recommend that you use Data.ByteString.Lazy for your output -- and unfoldr to generate the output
10:30:41 <mwc> @seen dons
10:30:41 <lambdabot> dons is in #haskell, #happs, #ghc, #haskell.hac07 and #haskell-overflow. I last heard dons speak 4h 12m 9s ago.
10:31:14 <sjanssen> gotaku: are you Trevor, the original author?
10:32:09 <gotaku> sjanssen: Yeah.
10:36:20 <paolino> @hoogle filter
10:36:20 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
10:36:21 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
10:36:21 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
10:36:32 <mosch> I am building a haskell buildbot, ran into a problem.  when I start it, it says: Failed to load application: cannot import name Interface
10:37:25 <mosch> anybody know how to proceed from there?  my python abilities are close to zero.
10:39:50 <mosch> as near as i can tell, Interface is properly installed...
10:40:17 <sjanssen> @tell dons improved mandelbrot http://hpaste.org/346#a1 -- testing on my machine says it's around 5x C's runtime
10:40:18 <lambdabot> Consider it noted.
10:44:56 <ndm> mosch: no idea, have you installed scons and Python?
10:45:17 <ndm> mosch: and newest versions of both, and Twisted is a dependancy as well, i think
10:45:32 <mosch> i installed...
10:45:49 <mosch> py24, py24-twisted(core|mail|names|web|words), py24-zopeInterface...
10:46:38 <mosch> i hadn't installed scons, though it dies the same way with it
10:47:03 <mosch> i had just installed it with cd /usr/ports/*/buildbot && make install
10:47:11 <mosch> and had hoped that the port was correct :-)
10:48:37 <mosch> the original death is..
10:48:38 <mosch> from twisted.python.components import Interface
10:48:40 <mosch> that line
10:51:07 <glguy> sjanssen: so is GHC smart enough to realize that cr and ci are being passed each time and never changed
10:51:16 <glguy> such that gb could be nested under ms
10:52:51 <paolino> sjanssen: that's a very nice enhancement :)
10:52:53 <ndm> mosch: woops, scons only required for Yhc buildbots
10:53:11 <ndm> mosch: can you upgrade twisted or zope?
10:53:54 <sjanssen> glguy: is that a statement or a question?
10:54:16 <glguy> "is" is used as a question there
10:55:09 <sjanssen> I'm not sure
10:55:35 <sjanssen> feel free to tinker and annotate your improvements
10:56:22 * sjanssen is off to lunch
10:59:40 <gotaku> sjanssen: Is there a way to tell unfoldr to skip adding an element?
11:01:37 <int-e> gotaku: not really. you can make the inner function call itself though
11:02:03 <gotaku> Oh that's right.
11:02:19 <Igloo> mosch: Is zope installed in the standard place?
11:02:41 <Igloo> mosch: If not you might have to set PYTHONPATH to point at it
11:03:34 <glguy> the code sjanssen pasted runs in 6.66 seconds for me
11:03:59 <int-e> > let filter p = let f p (x:xs) | p x = Just (x,xs) | otherwise = f p xs; f p [] = Nothing in unfoldr (f p) in filter odd [1..4] -- seems to defeat the purpose of unfoldr though. (for filter this could be done with dropWhile)
11:04:00 <lambdabot>  [1,3]
11:05:54 <glguy> err... 48 seconds that time, I wonder what happened the first time
11:09:22 <trurl> is there something like a sleep function?
11:09:55 <xic> @hoogle threadDelay
11:09:56 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
11:10:25 <trurl> thanks, I was searching only for "sleep"
11:12:13 <gvdm_other> could hoogle be improved so that "Num -> IO ()" matches "Int -> IO ()" and "Real -> IO ()"?
11:12:28 <gvdm_other> would be nice for searching
11:12:43 <gvdm_other> a more general types matches sub types...
11:12:43 <resiak> @hoogle Num a => a -> IO ()
11:12:44 <lambdabot> Prelude.print :: Show a => a -> IO ()
11:12:45 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
11:12:45 <lambdabot> Data.IORef.writeIORef :: IORef a -> a -> IO ()
11:12:51 <resiak> Hrm.
11:12:54 <magnus--_> Is there any handy s-expression parser library?
11:13:52 <mosch> igloo: it appears to be
11:14:01 <mosch> it's in /usr/local/lib/python2.4/site-packages/zope
11:14:20 * Igloo doesn't know if python will look in /usr/local by default
11:14:56 <Igloo> mosch: You could try stracing it and see where it's trying to open the file. If it's just not looking ni /usr/local then PYTHONPATH is probably the answer
11:16:23 <psnl> $PYTHON_PATH
11:17:22 <Igloo> PYTHONPATH is what I set
11:18:21 <mosch> (trying to determine if that is the problem...)
11:19:11 <mosch> well... when i look at twistd.log, it does show a bunch of stuff happening in the /usr/local/lib/python2.4/site-packages tree
11:20:02 <sjanssen> gotaku: unfoldr can't skip
11:20:34 <mosch> this is almost comic.  having trouble building a buildbot that i want, just because ghc doesn't work on one of my platforms
11:20:39 <sjanssen> you might be able to skip anyway
11:20:46 <gotaku> sjanssen: No but calling the function from inside of itself causes the same thing.
11:21:23 <Igloo> mosch: I'm a bit confused; if you can't build GHC then what do you want buildbot for?
11:21:42 <ndm> Igloo: he obviously wants to become a Yhc buildbot ;)
11:21:52 <mosch> well, I want buildbot, so it can report the ghc build brokenness, to make it easier to get it fixed
11:22:07 <ndm> the Yhc team have done quite a few ports through buildbot access only - its actually quite convenient
11:22:21 <mosch> looking at the ghc code, it's clear that whoever did the x86_64 port just never tried to make it work on FreeBSD
11:22:29 <Igloo> mosch: If you don't have a working ghc installed then buildbot isn't going to say anything useful though
11:22:32 <astrolabe> Why doesn't Data.Binary have an instance for Doubles?
11:22:41 <ndm> Igloo: it will help you debug where you missed stuff
11:22:47 <Cale> > let filter p = foldr (\x -> if p x then (x:) else id) [] in filter odd [0..10]
11:22:48 <mosch> oh... i thought it would say "failed initial build here..."
11:22:49 <lambdabot>  [1,3,5,7,9]
11:22:53 <mosch> which i figured might be useful
11:23:14 <ndm> mosch, Igloo: it will say where it failed to build, and can be prodded into working again by anyone then
11:23:17 <mosch> with a few minor changes i managed to get the build to the point where it had to turn Apply.cmm into an object
11:23:24 <sjanssen> gotaku: I was about to suggest exactly that :)
11:23:40 <mosch> and at that point i was utterly stuck, and figured maybe a buildbot would help somebody more knowledgeable about ghc
11:23:41 <Igloo> mosch, ndm: configure will print about 10 lines and then tell you it didn't find any compiler to build GHC with
11:24:00 <mosch> with about 10 characters added to configure.ac, it gets past that
11:24:04 <sjanssen> astrolabe: instance Binary Double is a TODO right now
11:24:17 <ndm> ah, the bootstrapping problem - one we don't have
11:24:21 <glguy> ?instances Bits
11:24:23 <Igloo> mosch: Are you talking about the porting-to-a-new-architeture instructions?
11:24:23 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
11:24:26 <mosch> then the next death is when it calls an mmap with some sort of 32BIT thing
11:24:29 <astrolabe> sjanssen: Ah, thanks.  I didn't know I was cutting edge :)
11:24:30 <glguy> ?instances Data.Bits Bits
11:24:31 <lambdabot> Couldn't find class `Data.Bits Bits'. Try @instances-importing
11:24:36 <mosch> well, it isn''t supposed to be a new architecture
11:24:42 <mosch> Linux-x86_64 works
11:24:42 <glguy> ?type shiftR
11:24:44 <lambdabot> forall a. (Bits a) => a -> Int -> a
11:24:46 <Igloo> mosch: But is that what you're doing?
11:24:47 <mosch> OpenBSD x86_64 works
11:24:54 <mosch> FreeBSD-x64_64 <kaboom>
11:24:54 <Igloo> freebsd-x86_64 is a new os/arch
11:25:12 <mosch> I was hoping to get it on Freebsd-x86_64, yes
11:25:15 * Igloo is surprised openbsd works
11:25:31 <sieni> it works like a train's toilet
11:25:32 <mosch> as it stands we're running a full IA32 compatibility lib... for just ghc
11:25:36 <Igloo> mosch: But are you trying to get it to work by following the porting-to-a-new-arch instructions?
11:25:38 <mosch> it's quite silly
11:25:50 <Igloo> Ah, so you do have a working GHC?
11:26:06 <mosch> we have a working 32-bit ghc
11:26:28 <mosch> it is our only remaining 32-bit app :-)
11:26:28 <Igloo> Hmm
11:27:20 * Igloo isn't sure if compiling a 64bit GHC with a 32bit GHC would work anyway
11:27:25 <mosch> i am honestly not sure how well the porting directions were followed.  i know that my partner was going through them
11:27:30 <mosch> for how to build our own bootstrap
11:27:46 <mosch> and we got to the point in the build where you need to turn Apply.cmm into an object
11:28:12 <glguy> rahikkala: still there?
11:28:23 <mosch> and there we felt dumb, and hoped that if we provided a buildbot, that somebody smarter than us would know how to fix it in 5 minutes
11:28:43 <Igloo> mosch: Do you have patches for the mmap stuff?
11:29:01 <rahikkala> glguy: Hm?
11:29:09 <mosch> I believe so.  my partner's at lunch, so I can't say for sure
11:29:15 <mosch> I know he got past that, so I assume he fixed it
11:29:15 <glguy> rahikkala: did anyone end up telling you Haskell's Boolean xor is /=
11:29:42 <mosch> though i'm not sure how, since the linux fix involved calling a flag that limited the available address pool to 31 bits
11:29:48 <mosch> and fbsd didn't have such a flag
11:29:55 <Cale> glguy: I felt pretty silly when I first found that out :)
11:30:15 <rahikkala> glguy: No, since I thought I didn't announce the paste on this channel, but thanks for pointing it out :)
11:30:40 <glguy> rahikkala: I read through recent pastes to see what people are putting on my pastebin
11:30:50 <bd_> Hm, why isn't Bool an instance of Bits?
11:30:54 <glguy> rahikkala: and I answer questions on the pastes every once in a while
11:31:01 <glguy> rahikkala: in case someone else is reading through them
11:31:06 <bd_> I mean, it's effectively a Word1 :)
11:31:17 <Igloo> mosch: Well, when he gets back, if you can send me any patches you have so far and let me know what instructions you are following then that would be great
11:31:21 <glguy> Bits instances are only defined for Int and Integer in Data.Bits
11:31:22 * rahikkala nods
11:31:25 <bakert> How can I get runhaskell/ghc/whatever to be more verbose and tell me what it's doing when I say
11:31:25 <bakert> -optl-Wl,-rpath=/opt/postgresql/lib -L/opt/postgresql/lib
11:31:27 <sjanssen> bd_: I've often wondered that, myself
11:31:32 <glguy> Cale: You ended up telling me
11:31:32 <bakert> (oooops no wrong paste!)
11:31:42 <bakert> when it is doing this: runhaskell Setup.lhs install
11:31:46 <Igloo> bakert: Does -v not work?
11:32:01 <bakert> Igloo, where do I put the -v?  I can't get it to work
11:32:03 <bd_> instances should exist wherever it is logical for them to do so, not merely when it is useful! >.>
11:32:06 <mosch> okay.  I'm hoping we can be of some use, since I'm sure we're not the only people who'd like to see it working on fbsd-amd64
11:32:11 <Igloo> bakert: After runhaskell
11:33:01 <sjanssen> bd_: I know why Bool isn't an instance of Data.Bits: "class (Num a) => Bits a where"
11:33:10 <bakert> Igloo, i tried that but it doesn't give me any extra info.
11:33:12 <bakert> hmm
11:33:34 <bd_> sjanssen: Bool could be an instance of Num... :)
11:33:46 <sjanssen> this is true
11:34:28 <Igloo> bakert: Oh, well, it does for me. It's not going to link anything though, so I'm not sure what you are hoping it will do with those flags?
11:34:49 <bakert> I'm trying to tell it where libreadline.so.5 is.
11:35:04 <Igloo> Ah, you need to set LD_LIBRARY_PATH then
11:35:17 <cjeris> so there's no way to write a disjunction, class (C a \/ C' a) => D a where... ?
11:35:20 <bakert> Aha!  Yes, that sounds right.  (I have had this problem before and forgotten the solution!)
11:35:25 <bakert> Thanks Igloo
11:35:25 <bakert> !
11:35:32 <Igloo> np
11:36:17 <Cale> cjeris: no
11:37:09 <bakert> Igloo, damn, it's already there.  some other problem!
11:37:23 <Igloo> bakert: Can you paste what's happening?
11:37:26 <astrolabe> http://www.cs.berkeley.edu/~flab/languages.html
11:37:27 <lambdabot> Title: Programming Language Usage Graph
11:37:32 <astrolabe> where is haskell?
11:37:38 <Cale> @where haskell
11:37:39 <lambdabot> http://haskell.org
11:37:49 <bakert> Igloo, thanks i will if i can't fix it with this next idea i've ha.d thanks
11:37:58 <astrolabe> Cale: thank you... that wasn't quite what I meant
11:38:05 <Cale> astrolabe: hehe
11:38:10 <astrolabe> :)
11:38:19 <Cale> astrolabe: It's not on that graph, that's where :)
11:39:12 <Igloo> Ooo, someone should sloccount Debian and gentoo and suchlike and see where Haskell comes
11:39:15 <gotaku> How can I compare two binary files and see where they differ?
11:39:47 <glguy> diff -a
11:40:04 <bakert> Igloo, thanks for your help.  it worked as root instead of with sudo.
11:40:06 <Cale> Data.ByteString and zipWith, elemIndices?
11:40:07 <mosch> solved the buildbot problem.  twisted had 'interface', buildbot was importing 'Interface'.  should have known it would be that simple.
11:40:52 <malsyned> How is "combinator" pronounced?
11:41:13 <sieni> kom-bi-nei-tör
11:41:56 <malsyned> sieni: hard or soft I in the second sylabel?
11:42:02 <opqdonut> kom-BI-na-tor
11:42:28 <opqdonut> or actually closer to kom-BI-nä-tor
11:42:36 <opqdonut> that ä/a is a schwa i think
11:42:38 <mosch> k&m-'bI-n&-"tor
11:42:48 <Igloo> More like "be" than like in "combine"
11:43:04 <Igloo> But it's shorter than in "be"
11:43:09 <malsyned> OK, now I've heard every theory I previously held validated.
11:43:11 <sieni> malsyned: bi would be like "buy"
11:43:14 <sieni> no
11:43:16 <sieni> sorry
11:43:24 <sieni> malsyned: bi as in "bit"
11:43:38 <cjeris> weird.  it never occurred to me to stress any syllable but the first (as combination, just with a different last syllable)
11:43:51 <glguy> ditto
11:43:57 <Cale> Uh, the first syllable is stressed
11:44:16 <glguy> KOM-bin-a-tor
11:44:21 <Igloo> I think I strees the first of combinator and the third of combination
11:44:23 <sieni> is some other syllable stressed in english?
11:44:24 <opqdonut> hmm on second thought yes
11:44:40 <opqdonut> Igloo: yes, exactly
11:44:45 <malsyned> I'm going to start emphasizing the last syllable, so that all possibilities can be found in the wild.
11:44:48 <cjeris> Igloo: you're right, I'm thinking sloppily
11:45:29 <Cale> I can't write all the symbols from the pronunciation guide the OED provides, but it shows a stress on the first syllable.
11:45:49 <malsyned> so, stress the first syllable.  long A or schwa on the third syllable?
11:46:05 <Cale> eI
11:46:22 <Cale> So, long A
11:46:36 <malsyned> Cale: that's all straight from OED?
11:47:43 <glguy> OE?
11:47:45 <glguy> D
11:47:59 <Cale> The online version. I could paste the pronunciation key for the word, but it's kind of gibberish ascii :)
11:48:08 <malsyned> glguy: Oxford English Dictionary
11:48:14 <mosch> Cale: k&m-'bI-n&-"tor  ?
11:49:16 <Cale> no
11:49:17 * allbery_b would say KAWM-bihn-ay-t'r (' = schwa) fwiw
11:49:24 <malsyned> mosch: you're stressing the second and fourth syllables, Cale is saying to stress the first and third.
11:49:30 <gotaku> I just can't figure out why this fails the diff check...
11:49:33 <mosch> i got mine from a dictionary too :-)
11:49:44 <mosch> just not a british one
11:49:54 <Igloo> http://dictionary.oed.com/cgi/display/50044570?keytype=ref&ijkey=n8h74fmg6KHMw is the OED entry if you want to look for yourself
11:50:02 <lambdabot> Title: Oxford English Dictionary combinator, http://tinyurl.com/yr4nzv
11:50:08 <malsyned> OK, yeah, my original question was ambiguous.  I suppose I should have added "in American English"
11:50:26 <sieni> who gives a flying fuck
11:50:48 <malsyned> I do. :-P
11:50:48 <sieni> no regular english speaker will even know what the word means and how it should be pronounced
11:51:20 * Igloo doesn't know how to pronounce words in foreign languages
11:51:20 <Cale> Igloo: yep
11:51:21 <malsyned> sure, but I've been pronouncing it all kinds of ways in my head, I just wanted to see if there was a consensus I could follow.
11:51:27 <sieni> I've been corrected many times in the states, because I've extrapolated the pronounciation quite randomly without any actual knowledge
11:51:29 <Heffalump> (in response to a question hours ago) dcoutts: I don't know much about parsing C, actually, at ARM we just used the EDG frontend
11:51:49 <bryanl> whats a good.... "so you wanna learn haskell" guide?
11:52:26 <sieni> so stress on first and third syllables would be the one for which I would vote for
11:52:28 <Cale> bryanl: I'd start with Yet Another Haskell Tutorial
11:52:30 <bakert> bryanl, "haskell for c programmers" if you come from an imperative background
11:52:41 <Cale> bryanl: Use that for the first few chapters to get you off the ground.
11:52:46 <Cale> The Wikibook is also not bad.
11:52:50 <beelsebob> edwinb: I think twig here has a competitor for whitespace as king of the pointless languages
11:52:56 <bryanl> thanks
11:53:16 <edwinb> beelsebob: oh?
11:53:17 <gotaku> sjanssen: Why did you add import Data.Typeable?
11:53:50 <bakert> How do you uninstall a package you installed with cabal?
11:53:53 <lucio__> hello everyone. Im just learning haskell and i cant figure out how should do this: Im trying to do a simple game. In imperative, i used to do (process events)->(update world state)->(render world). Im not sure how to do this in askell. World state is usually a big tree that suffers a lot of changes every time step and having a lot of iorefs inside the world datatype seems a bit ugly. how should i do this?
11:55:19 <allbery_b> bakert: ghc-pkg unregister, then carefully remove the files manually.  if you're lucky it installed into its own directory under /usr/local (or $prefix) and is therefore easy to remove
11:56:26 <lucio__> my main clues come from http://haskell.org/haskellwiki/IO_inside#Example:_emulating_OOP_with_record_types , but im not sure this works for bigged code or that this 'emulation' is a good idea
11:56:30 <lambdabot> Title: IO inside - HaskellWiki, http://tinyurl.com/37m73u
11:58:37 <Cale> lucio__: that sort of thing works fine
11:58:41 <sjanssen> gotaku: I wanted to print out the types of some of the "where" bound variables.  You can delete the import
11:59:21 <Cale> lucio__: what sort of tree is it?
11:59:26 <lucio__> Cale: and is that the 'haskell' way of doing it?
11:59:42 <Cale> Well, there's not just one "Haskell way"
12:00:06 <lucio__> some like world{score, players{weapons, speed, direction}, objects{position}, level... etc}
12:00:19 <Cale> ah, okay
12:01:35 <lucio__> doesnt that style require a lot of boilerplate code?
12:02:22 <SimonRC> hmm
12:02:27 <Cale> If you really want to have a state-based model of the universe, which seems relatively sane here, probably what I'd do is have objects consist of getters and setters for their variables.
12:02:44 <Cale> and perhaps use IORefs behind the scenes.
12:02:55 <Cale> (i.e. when creating them)
12:03:34 <Cale> Whether this is really the most elegant way to describe changes in state is up for discussion though.
12:03:43 <lucio__> and supposing i didnt want to have state based model of the universe... what should i do?
12:03:55 <lucio__> (im doing this mainly for learning! :)
12:03:57 <Cale> If you'd be interested in trying another way, read up on functional reactive programming.
12:04:15 <Cale> Let me look up some papers
12:04:18 <lucio__> will do. thanks!
12:04:23 <SimonRC> Is it possible to create new types at runtime and then create data of those types, all with type-safety?  What about creating instances?
12:04:41 <Cale> SimonRC: no
12:04:44 <SimonRC> :-(
12:04:47 <Cale> Types are a compile-time matter.
12:05:21 <emu> Dyn?
12:05:24 <Cale> You can think of types as information about the program which the compiler checks at compile time. Compilation destroys them.
12:05:26 <SimonRC> What about the funky stuff like "Data.Data" et al?
12:05:44 <sjanssen> Data.Dynamic can't create types at runtime
12:06:01 <Cale> There wouldn't be any point to creating types at runtime.
12:06:03 <SimonRC> but is it possible for the compiler not to know the types at cmpile-time but still to know that the program is type-safe?
12:06:12 <Cale> because at that point, it's already too late to check them
12:06:18 <SimonRC> hmm
12:06:24 <nominolo> is there a quick n dirty guide to the ST monad?
12:06:29 <sjanssen> SimonRC: there are some things you can do with existentials or Data.Dynamic
12:06:37 <Cale> Unless you're doing something like compiling new code at runtime.
12:07:01 <nominolo> i mean shorter than spj's paper
12:07:12 <Cale> Think about it -- how do I write code to create a value of a type which doesn't yet exist?
12:07:14 <glguy> What is the best of hugs and ghc to recommend to a friend with the SOE book doing Graphics.SOE stuff?
12:07:22 <Cale> What type does that code have?
12:07:37 <nominolo> ?where ST
12:07:38 <lambdabot> I know nothing about st.
12:07:42 <nominolo> ?doc ST
12:07:43 <lambdabot> ST not available
12:07:51 <sjanssen> nominolo: if you want really terse docs, look at the haddocks for Control.Monad.ST and Data.STRef
12:07:57 <Cale> @doc Control.Monad.ST
12:07:57 <SimonRC> presumably there are papers on "Proving the type-safety of runtime-generated code" or whatever
12:07:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
12:08:03 <Cale> @doc Data.STRef
12:08:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html
12:08:23 <Cale> If you could generate code at runtime, I agree, the situation would be different.
12:08:37 <nominolo> actually, I need to use STUArray, and I am not sure what to do with that "s" parameter
12:08:41 <Cale> Now, dons' library hs-plugins can do that, and it does typecheck the code it compiles for you.
12:08:54 <SimonRC> yeah, that might be what I am thinking of
12:09:04 <sjanssen> but hs-plugins is essentially a wrapper around GHC
12:09:08 <lucio__> Cale: thanks for the help!
12:09:19 <SimonRC> sounds like common lisp's stuff
12:09:24 <sjanssen> you can hand it type-incorrect code and it will result in a runtime error
12:09:39 <Cale> Or a Nothing rather than a Just x
12:09:43 <SimonRC> yes
12:09:49 * SimonRC <3 Nothing.
12:10:22 <SimonRC> IMO MS made a big mistake by making references nullable by default.
12:10:35 <emu> nominolo: keep it wrapped up
12:11:00 <SimonRC> .NET has a type that is very like Maybe, but you can't nest or apply it to references!
12:11:10 <emu> nominolo: use runSTArray .. it's simple.
12:11:35 <nominolo> emu: i have ST wrapped into ReaderT and WriterT .. and this monad is used inside an arrow type
12:11:37 <sjanssen> be careful with runSTArray and STUArray -- there are some tricky polymorphism issues
12:11:53 <nominolo> emu: so should my arrow type be MyArr s a b ?
12:12:04 <nominolo> or is there a way to call it MyArr a b ?
12:12:10 <glguy> ERROR file:{Hugs}\packages\Win32\System\Win32\Types.hs - Error while importing DLL "C:\Program Files\WinHugs\packages\Win32\System\Win32\Types.dll"
12:12:11 <emu> you may have to existentially qualify s
12:12:15 <glguy> anyone else get that when using SOE in Hugs?
12:12:17 <sjanssen> nominolo: you have to include the s somewhere
12:12:46 <nominolo> sjanssen, emu: k, thanks
12:12:50 <sjanssen> glguy: have you tried the gtk2hs implementation of SOE?
12:13:00 <glguy> sjanssen: that's what I'm doing now
12:14:05 <nornagon> ibid: hey, have you read that article on turning blurred numbers back into the original data?
12:20:53 <ibid> nornagon: no, but if there is enough information, i consider it possible :)
12:21:24 <ibid> nornagon: then again, when there is *not* enough information, it's csi fairytale :)
12:21:56 <nornagon> ibid: so those pictures you posted recently of your ID card...
12:22:05 <ibid> nornagon: if you can reverse-engineer them, let me know :)
12:22:20 <glguy> kQmbIneIt@(r) -- OED pronounciation usign OED defined symbol replacements :)
12:22:47 <ibid> the signature probably is somewhat reversible
12:23:05 <nornagon> the barcode is probably safe
12:23:18 <nornagon> i'm looking at the string of numbers down the bottom, though
12:23:28 <ibid> i would be surprised if any of the others in obverse are reversible
12:24:16 <nornagon> right.
12:24:24 <nornagon> I was only really looking at the signature.
12:24:43 <nornagon> i mean
12:24:49 <nornagon> the numbers down the bottom
12:24:55 <nornagon> not the actual signature :P
12:25:07 <ibid> the numbers in reverse i'm not sure about
12:25:18 <ibid> if i look at them in high mag, i can't make anything out of them
12:25:32 <glguy> somehow I'm logged into OED as Subscriber: Harcourt, Inc. - Elsevier Science
12:25:46 <ibid> well, you might be able to guess one or two of them
12:25:46 <sjanssen> @quote
12:25:47 <lambdabot> bringert says: psicho: so you are saying that your teacher gave you two days to do an assignment in a language you didn't know?
12:26:09 <nornagon> ibid: the method i read about was pretty much just density-checking
12:26:39 <nornagon> you get all the digits unblurred by themselves, blur them the same way as in the original, then match them up
12:26:45 <nornagon> based on the color
12:26:52 <ibid> nornagon: if you know the expected format of the numbers and if it's redundant enough, i suppose it could be reversible
12:28:21 <ibid> nornagon: not just color but shape :)
12:28:37 <ibid> nornagon: i note you can distinguish some shapes in that area
12:28:46 <ibid> nornagon: so it probably is possible
12:29:02 <ibid> nornagon: no matter, i just blurred them so that it won't be too easy to crack ;)
12:29:54 <nornagon> just saying, if you really care about those numbers, you should probably do something about it :P
12:30:09 <ibid> nornagon: actually, now that i look at that row of stuff, it contains nothing that isn't already visilble in the nonblurred areas :)
12:30:25 <ibid> well, except for the card number
12:30:53 <nornagon> oh, is it just a serialized form of the rest of the card?
12:30:54 <ibid> (which i blurred out for sheer paranoia, not knowing any attack vectors there:)
12:30:57 <ibid> yeah
12:31:30 <ibid> the card number, nationality, date of birth, sex, date of expiry
12:31:34 <ibid> as far as i can make out
12:31:51 <nornagon> i guess all the interesting stuff is on the smart-card bit
12:31:55 <nornagon> oh well :)
12:32:00 <nomeata> Hi. Can haddock create the type definitions when creating docs? I prefer to develop without all type definitions in the code, but it would be nice to have them in haddock.
12:32:29 <integral> I suppose when haddock uses the GHC API to parse the haskell, it could also run the type inferencer too...
12:32:34 <ibid> about the only sensitive stuff printed on the card is the part labeled "tunnus/kod", and that's only because some people mistakenly use it as a password :)
12:32:46 <ibid> and i suppose the barcode contains that too
12:32:57 <ibid> nornagon: the smart card contains just secret keys ;)
12:33:12 <nomeata> integral: sounds like it is not using the GHC API, or is it?
12:33:26 <integral> it's not, sadly
12:34:35 <nomeata> ok, thanks
13:02:08 <hpaste> *yawn*
13:06:03 <kolmodin> anyone know of syntax support for cabal in vim?
13:06:07 <kolmodin> dons: ^^
13:06:24 <kolmodin> I've started now 'cause I don't know of any
13:06:35 <Igloo> I haven't seen anyone mention any
13:06:49 <kolmodin> me neither, ok
13:07:18 <kolmodin> and since google doesn't find any, it doesn't exist
13:10:04 <DukeDave> Question: what is the correct way to 'cast' in Haskell?      Context: I am evaluating an Int but am using it in an enumFromTo which returns a list of Double
13:10:24 <DukeDave> and Thanks :)
13:10:26 <wolverian> fromInteger
13:11:00 <Cale> fromIntegral
13:11:14 <nomeata> hmm. enumFromTo should work with Ints, shouldnâ€™t it?
13:11:16 <Cale> > fromIntegral (5 :: Int) :: Double
13:11:18 <DukeDave> bows, thank you
13:11:18 <lambdabot>  5.0
13:11:39 <Cale> @type fromInteger
13:11:41 <lambdabot> forall a. (Num a) => Integer -> a
13:11:41 <Cale> @type fromIntegral
13:11:43 <lambdabot> forall b a. (Num b, Integral a) => a -> b
13:11:58 <wolverian> er, good point. :)
13:12:21 <nomeata> @type enumFromTo
13:12:23 <lambdabot> forall a. (Enum a) => a -> a -> [a]
13:13:03 <rahikkala> The annoying thing about taking the time to compose a well-researched and thought-out mailing list post about a problem you're having with Haskell is that you usually find the solution while doing research and analyzing it, and then nobody will ever know about all the trouble you went through to make the post look good on the mailing list :(
13:13:37 <nomeata> rahikkala: you have to write faster. I usually find the solution about two heartbeats _after_ I sent the mail to the list.
13:14:32 <nomeata> the following self-reply is then slightly embarrasing, but at least other learn from (or laugh at) my mistakes.
13:15:31 <_roconnor> rahikkala: I have a similar problem.  I was going to ask on #haskell how to write a certain function, but I decided I needed to be very clear about what I wanted the function to do, so I wrote a careful recursive specification ... which turned out to be the function.
13:15:56 <rahikkala> :D
13:16:36 <Vq^> :)
13:17:58 <nornagon> i read the wikipedia definition of the mandelbrot fractal, then i wrote it almost word-for-word in haskell, and it worked. That was pretty cool.
13:18:22 <DukeDave> nomeata: I personally thank you!          (Pet hate #23:  Unanswered mailing posts which *exactly* fit your problem :(
13:18:43 <roconnor> The computability of the mandelbrot fractal is an open problem.
13:20:02 <nomeata> DukeDave: true, these are just too tempting to send a unhelpful â€œme tooâ€ resonse.
13:20:39 <norpan> almond bread
13:21:24 <sjanssen> @where almond bread
13:21:25 <lambdabot> I know nothing about almond.
13:24:10 <shapr> dons: Hey, what's your suggested window manager again?
13:24:24 <xerox> shapr: ratpoison
13:24:26 <fasta> If I have a DiffArray with values v, then make a new diffarray based on v(e.g. v are trees and the new diffarray becomes (a,v)), and then refer to the original diffarray again. I assume this will only copy the pointers to the trees when I request for an explicit copy (by using //). In particular it's not going to copy the tree values. Is this correct?
13:24:34 <CosmicRay> I've heard a lot about ratpoison and ion lately
13:24:46 <fasta> There's a new release of ion.
13:24:50 <shapr> xerox: Well, I have been using ion3 for awhile, but the keybinding functions keep changing, so I want to try something else.
13:24:53 <CosmicRay> but ratpoison looks, well, too weird.
13:25:19 <shapr> Yeah, ratpoison is too extreme even for me.
13:25:32 <CosmicRay> it really does look like screen ported to X11
13:25:35 <CosmicRay> and I like screen
13:25:37 * shapr grins
13:25:39 <notsmack> new ion?  anything cool?
13:25:40 <CosmicRay> but I'm not sure this is a good thing.
13:25:56 <sjanssen> shapr: dons might use dwm
13:26:12 <shapr> Ah, I'll try that.
13:26:20 <shapr> Is there any WM that can be scripted with Haskel?
13:26:22 <shapr> Haskell*
13:26:23 <shapr> sheez
13:26:36 <xerox> oh, it can swap between tiling and floating dynamically.
13:26:40 <sjanssen> shapr: it's somewhat hardcore.  Configuration is editing a C header file and recompiling
13:26:45 <shapr> eek
13:26:52 <kep> xerox wmii :)
13:26:58 <shapr> I think I'll try wmii...
13:27:12 <fasta> There is a WM for Factor :)
13:27:20 <shapr> yow
13:27:37 <sjanssen> I wonder how hard it'd be to write a wm in Haskell
13:27:55 <CosmicRay> probably not too bad if dwm is less than 2000 SLOC in C
13:27:56 <sjanssen> dwm is shockingly small (less than 2000 lines of C)
13:28:06 <fasta> A basically one man show produces better development tools than the Haskell community.
13:28:17 <CosmicRay> and haskell X11 bindings already exist
13:28:19 <CosmicRay> fasta: eh?
13:28:24 <shapr> fasta: I don't think that Factor tools are better than Haskell tools.
13:28:46 <shapr> fasta: But if you'd like to establish quantifiable guidelines and write up a detailed comparison, I'm interested.
13:29:01 <shapr> Otherwise I'm calling that gezeik
13:29:04 <pejo> sjanssen, someone pasted a link to a wm written in Haskell a while ago. Mostly for demonstration purposes I think.
13:29:24 <kep> dons btw , do you have seen http://en.wikipedia.org/wiki/Acme_(text_editor) ?
13:29:31 <sjanssen> pejo: oh?  do you remember the 'someone'?
13:30:47 <kep> dons: http://cm.bell-labs.com/sys/doc/acme.html
13:30:51 <lambdabot> Title: Acme: A User Interface for Programmers
13:35:16 <fasta> shapr: Ok, I am exaggerating a little bit, but JEdit is or was easier to use for Factor than Emacs or VIM for GHC. The documentation is also integrated in Factor, something that's still not in GHC. For Factor there's also a stepper available (which is probably trivially programmable due to the nature of the environment). For GHC we only have a nice profiler (but even this could be better).
13:37:15 <shapr> fasta: Can you quantify how emacs or vim could be better for use with GHC?
13:37:30 <pejo> sjanssen, can't find it now. It's buried somewhere in the logs for last year I think, and I know I passed the link on. So grepping for "pejo" and ".hs" ought to give the result.
13:37:33 <fasta> shapr: There's already a work-in-progress.
13:38:26 <fasta> shapr: hovering over a value should give the type for example.
13:38:53 <shapr> Hm, that would be nice.
13:39:24 <fasta> shapr: An option that when one changes one name all references to that name in the project change.
13:39:31 <allbery_b> ?where shim
13:39:32 <lambdabot> http://shim.haskellco.de/trac/shim
13:39:41 <fasta> shapr: shim is a start.
13:39:43 <allbery_b> not quite there yet
13:39:54 <fasta> shapr: There are _tons_ of things that can be better.
13:39:57 <shapr> fasta: Have you tried HaRe? I haven't ... just read about it.
13:40:03 <fasta> shapr: no, URL
13:40:09 <fasta> ?
13:40:16 <shapr> @where hare
13:40:17 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
13:40:22 <shapr> Haskell Refactorer
13:42:27 <pejo> sjanssen, http://twb.ath.cx/~twb/hack/SCRATCHPAD/c/tinywm/tinywm-haskell.hs
13:42:53 <sjanssen> pejo: ah, tiny
13:43:20 <Nafai> Shim looks potentially nice
13:43:40 <pejo> sjanssen, well, it's a start.
13:43:42 <fasta> shapr: I think it would be more worthwhile to do something with structured editing.
13:44:05 <fasta> shapr: I have little concrete ideas on that topic, however.
13:45:09 <shapr> Type slicing would be nice.
13:45:24 <sjanssen> type slicing?
13:45:36 <shapr> Yeah, there's a web demo, google for it.
13:47:28 <fasta> If I have a DiffArray with values v, then make a new diffarray based on v(e.g. v are trees and the new diffarray becomes (a,v)), and then refer to the original diffarray again. I assume this will only copy the pointers to the trees when I request for an explicit copy (by using //). In particular it's not going to copy the tree values. Is this correct?
13:49:41 <fasta> How do you disable Google Suggest?
13:50:06 <siti> customize google extension?
13:50:15 <Procyon_> @where shim
13:50:16 <lambdabot> http://shim.haskellco.de/trac/shim
13:50:24 <fasta> siti: I am already using that.
13:50:30 <siti> ok
13:50:37 <fasta> siti: Oh, I see.
13:50:50 <fasta> siti: The Iceweasel upgrade broke _all_ my settings.
13:50:55 <siti> lol
13:53:51 <fasta> siti: Yes, I am glad it made a backup of my bookmarks, though. OTOH, an application that makes backups doesn't trust itself.
13:54:00 <siti> ok
13:54:41 <cjeris> fasta: Unload the gun before I shoot myself in the head? (yn) [y]
13:54:41 <fasta> It would be nice if someone would put that in the type system. :)
13:57:18 <rahikkala> I'd like to annotate my program's top-level function definitions with types automatically... preferably so that I run some script against it and all of the functions get annotated at once, since I've got a couple of dozen of them already, mostly unannotated. Would anyone happen to have already written something for this?
14:01:32 <xerox> rahikkala: dons has such a script
14:03:50 <allbery_b> ?where typeof
14:03:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/typeof/
14:03:59 <Procyon_> rahikkala: I saw one on the web just the other day
14:04:08 <Procyon_> no idea where though ;)
14:05:16 <glguy> sweet, my company is going to install cameras in all of its studio locations that record stuff when there is motion, and they are developing a system to track who is in which room when with which customer
14:05:50 <glguy> I'm sure the studio employees are going to be ecstatic
14:06:08 <xerox> :t Control.Exception.catch
14:06:10 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
14:06:15 <gotaku> Nested unfoldrs are interesting...
14:06:33 * rahikkala darcs gets
14:06:36 <xerox> :t System.Process.waitForProcess
14:06:38 <lambdabot> System.Process.Internals.ProcessHandle -> IO GHC.IOBase.ExitCode
14:09:03 <sjanssen> gotaku: nested unfoldrs?  sounds a little crazy
14:09:07 <sjanssen> this is for mandelbrot?
14:09:38 <Procyon_> glguy: I thought about doing that in my house and using some vision recognition and binding identifiers to objects so that in addition to home security, I could run a query like "where myKeys" and it would show a video clip of the last time it identified the object :)
14:13:15 <_matthew-> wow, it's been hours. Is haskell faster than the C++ for the mandelbrot yet?
14:13:22 <gotaku> sjanssen: Yeah. Doesn't work yet though.
14:16:16 <gotaku> _matthew: I haven't been working on it all day, but in any case no, no it's not.
14:30:48 <cjeris> glguy: what problem is the company with the studios trying to solve?
14:32:51 <glguy> > 3000 `div` 8
14:32:53 <lambdabot>  375
14:36:17 <glguy> ?hoogle shift
14:36:18 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
14:36:18 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
14:36:18 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
14:37:40 <glguy> what does C++'s norm() fucntion do to a complex?
14:38:39 <ookk> anyone built wxhaskell with ghc-6.6 and wxWidgets 2.8.0 ?
14:39:03 <ookk> glguy, probably calculates the norm?
14:39:05 <allbery_b> square of the magnitude
14:39:19 <xerox> glguy: the modulo of a complex number z is |z| = sqrt(z*(~z)) = sqrt(a^2 + b^2) (where ~z is the conjugate of z).
14:39:36 <ookk> isnt the norm defined as z/|z| ?
14:39:53 <glguy> is that Data.Complex.magnitude?
14:40:07 <ookk> norm != magnitude
14:40:40 <allbery_b> google finds some choice quotes about the choice of name for the operation
14:40:52 <allbery_b> (i.e. norm() is not the norm...)
14:42:39 <xerox> ...no Arbitrary Complex :(
14:48:41 <dons> moin
14:48:42 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
14:49:59 <rahikkala> <@Icebreaker> ari: http://hpaste.org/347 <@Icebreaker> I wonder what the #haskell people say when they read my code. ): <@Icebreaker> Probably something like "AGHHHH MY FUCKING EYYYYYYEEEEEES"
14:50:13 <Igloo> Yo dons, is www.cse.unsw.edu.au broken?
14:50:35 <glguy> is there any way to view the output generated by the mandlbrot algorithm?
14:50:54 <gotaku> glguy: >> ?
14:51:07 <glguy> to see if it's actually doing anything
14:51:20 <ookk> use hopengl?
14:51:27 <hpaste>  glguy pasted "I started translating the C++ solution. " at http://hpaste.org/348
14:51:35 <glguy> it runs in 1/4 the time
14:51:39 <glguy> and produces the wrong answer
14:51:45 <glguy> so I wondered if it was even close ;)
14:51:55 <ookk> http://ffconsultancy.com/free/fractal/index.html
14:51:57 <lambdabot> Title: Mandelbrot rendering using OpenGL
14:52:00 <gotaku> ./mandelbrot 200 >> test.png
14:52:14 <Igloo> glguy: Where's working code?
14:52:23 <dons> Igloo: looks like its up?
14:52:35 <glguy> http://hpaste.org/348
14:52:41 <dons> gotaku: the mandelbrot benchmark?
14:52:48 <dons> glguy: sorry.^^
14:52:57 <glguy> working: http://hpaste.org/346
14:52:58 <dons> its a .bmp
14:53:14 <Saizan> Icebreaker: your screen is too wide :)
14:53:25 <Icebreaker> ):
14:53:26 <dons> i note we've moved up another notch on the shootout :)
14:54:57 <gotaku> glguy, your program does something funny.
14:56:25 <glguy> [x8,x8+1..x8+7]
14:56:33 <glguy> needed to be changed for sure, but I have no diea if any of it is right now :)
14:56:39 <glguy> gotaku how do you mean?
14:57:18 <gotaku> glguy: It creates a 1 MB file with a tiny mandelbrot image in the top left corner.
14:57:46 <dons> glguy: you're not diffing against the expected output from the C program?
14:57:51 <dons> (its a good idea..)
14:58:10 <ookk>  /usr/bin/ld: can't locate file for: -lHSOpenGL_cbits
14:58:20 <ookk> i use ghc-6.6
14:59:42 <augustss> howdy
14:59:58 <dons> sjanssen: this looks much better now http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=clean
15:00:01 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2aslsn
15:00:09 <dons> just nbody, spectral-norm and mandelbrot to go
15:00:16 <dons> all the numerics problems...
15:00:33 <augustss> ghc needs a numeric overhaul
15:00:48 <sjanssen> dons: did you see the bang pattern'd/bytestring'd mandelbrot?
15:00:58 <dons> seems so. they're the hardest programs to write
15:00:59 <Gwern> dons: wait, isn't clean just haskell with a different syntax? how can it be doing so well?
15:01:03 <dons> sjanssen: is it ready to go?
15:01:20 <dons> Gwern: better native code generator
15:01:27 <dons> ghc's catching up pretty quickly though.
15:01:38 <Gwern> ah
15:01:43 <sjanssen> dons: http://hpaste.org/346#a1 -- it works, but it could use a clean up before submission
15:01:45 <dons> there's quite a few missing Clean entries too
15:01:50 <dons> sjanssen: you want me to do that today?
15:02:07 <sjanssen> I just hacked in the changes paying no heed to formatting :)
15:02:24 <dons> ok. i'll take a look, then submit it
15:02:24 <hpaste>  glguy annotated "I started translating the C++ solution. " with "gotaku does this work any better?" at http://hpaste.org/348#a1
15:02:27 <sjanssen> dons: I can clean it up in a bit -- an hour or so
15:02:34 <sjanssen> or you can, whatever
15:02:35 <glguy> gotaku: I found a place that was using a nubmer 8x too small
15:02:38 <sjanssen> I've got to go for now
15:02:39 <glguy> how are you viewing these images?
15:03:10 <gotaku> ./progname >> test.png
15:03:12 <dons> glguy: ./foo > x.bmp ; xv x.bmp
15:03:19 <glguy> ah, xv?
15:03:22 <glguy> I don't think I have that installed here
15:03:29 <dons> (maybe the extension doesn't matter?)
15:03:43 <SamB> dons: what format are they in?
15:03:45 <gotaku> It doesn't.
15:04:11 <dons> bmps, I thought
15:04:38 <SamB> do they have a little header with some odd fields in it?
15:04:42 <gotaku> dons: Before you submit sjanssen's mandelbrot program let me just quickly fix minor.
15:04:55 <dons> ok.
15:05:01 <dons> it'll be an hour or two
15:05:04 <glguy> gotaku my code simply isn't handleing the end of row condition
15:05:20 <glguy> but the logic is straight out of the C++ version...
15:05:45 <glguy> oh well, class time
15:05:49 * glguy &
15:05:59 <astrolabe> I'm reading through the java n-body entry.  Having to make everything a class seems so pointless.
15:06:40 <ookk> Anyone got an idea how i could fix this? /usr/bin/ld: can't locate file for: -lHSOpenGL_cbits
15:06:47 <ookk> when im compiling something with import Graphics.Rendering.OpenGL
15:06:48 <ookk> import Graphics.UI.GLUT
15:06:55 <ookk> in ghc-6.6 on a mac
15:07:06 <gotaku> glguy: Looks alright now.
15:07:14 <dons> hmm, looks like you're mising the OpenGL cbits stuff in your linker path
15:07:26 <dons> is the HSOpenGL_cbits in your ghc lib directory?
15:07:47 <allbery_b> it's there on mine, from the 6.6 OSX binary tarball
15:08:14 <ookk> hmm i wonder why it is missing
15:08:18 <ookk> i built ghc-6.6 myself
15:08:21 <allbery_b> also my 6.7 build
15:08:37 <ookk> maybe i should try the binary
15:09:03 <gotaku> glguy: It looks fine when viewing the image but when I set n to 25 it fails for some reason to pass the diff check.
15:10:26 <dons> ookk: maybe you didn't have the HOpenGL library isntalled at all?
15:11:34 <ookk> dons, well it doesnt complain about any other stuff
15:11:41 <ookk> but when i remove -package opengl
15:11:51 <ookk> it can ofc not find anything
15:12:08 <ookk> but when i do -package opengl, it find everything cept cbits
15:12:21 <dons> check if you have the cbits file then, lib/ghc-6.6/libHS*cbits*
15:13:10 <ookk> ~/Desktop > ls /usr/local/lib/ghc-6.6/libHS*cbits*
15:13:10 <ookk> -rw-r--r--   1 root  wheel     1K Oct 27 21:02 /usr/local/lib/ghc-6.6/libHSGLUT_cbits.a
15:13:10 <ookk> -rw-r--r--   1 root  wheel     1K Oct 27 21:02 /usr/local/lib/ghc-6.6/libHSX11_cbits.a
15:13:10 <ookk> -rw-r--r--   1 root  wheel    81K Oct 27 21:02 /usr/local/lib/ghc-6.6/libHSbase_cbits.a
15:13:10 <ookk> -rw-r--r--   1 root  wheel     1K Oct 27 21:02 /usr/local/lib/ghc-6.6/libHSunix_cbits.a
15:13:25 <dons> so its missing :)
15:13:29 <ookk> yeah
15:13:51 <ookk> hmm guess ill try to reinstall the binary distribution
15:15:27 <ookk> i was thinking of using hopengl with wxhaskell
15:15:32 <ookk> so i wont have to use x11
15:15:53 <ookk> but wxhaskell seems to be dead?
15:16:02 <ookk> doesnt work with 6.6 or wxwidgets 2.8
15:16:13 <hpaste>  gotaku pasted "mandelbrot" at http://hpaste.org/349
15:17:06 <allbery_b> darcs.haskell.org/wxhaskell
15:17:19 <allbery_b> the sourceforge one is dead
15:17:35 <allbery_b> that said, wxhaskell for osx uses x11 :)
15:17:42 <gotaku> dons: Ok, I made a few simple changes, but notice that cr is being calculated from scratch for every pixel... I don't like that but can't think of how to fix it without breaking the program.
15:18:01 <dons> hmm
15:18:07 <ookk> allbery_b, really? shouldnt it use wxMac?
15:18:22 <dons> let me know when you're done  and would like me to attack it
15:18:42 <allbery_b> ookk: may depend on where you ge the wxwindows base, the one I found used x11
15:18:43 <gotaku> dons: You can do so any time. http://hpaste.org/349
15:18:51 <ookk> http://wxhaskell.sourceforge.net/screenshots.html
15:18:52 <lambdabot> Title: wxHaskell
15:18:58 <allbery_b> maybe I'll dig around again as I had very poor luck with it
15:19:06 <ookk> but it looks really old
15:19:12 <ookk> osx hasnt looked like that in years
15:19:32 <sorear> tell fodder
15:19:33 <allbery_b> (test program compild, but on running crashed virtuedesktops, started classic for some unknown and unknowable reason, then died)
15:20:06 <ookk> i havent even got wxhaskell to compile
15:21:21 <dons> do you have the new ghc 6.6 wxHaskell release candidate?
15:21:34 <dons> the maintainership has recently been taken over
15:21:37 <ookk> i got the latest source from darcs
15:21:45 <ookk> i wouldnt compile
15:22:27 <ookk> im guessing its because i use wxWidgets 2.8
15:26:24 <ookk> dons, its missing from the binary tarball to
15:27:03 <allbery_b> huh
15:28:05 <ookk> libHSOpenGL_cbits.a is not in the binary tarball for ghc-6.6 on apple
15:28:06 <ookk> hmm
15:30:56 <allbery_b> odd, it was there in mine
15:31:56 <ookk> ~/Downloads/ghc-6.6 > ls lib/i386-apple-darwin/libHS*cbits*
15:31:56 <ookk> -rw-r--r--   1 ookk  ookk     1K Oct 11 15:21 lib/i386-apple-darwin/libHSGLUT_cbits.a
15:31:56 <ookk> -rw-r--r--   1 ookk  ookk     1K Oct 11 15:20 lib/i386-apple-darwin/libHSX11_cbits.a
15:31:56 <ookk> -rw-r--r--   1 ookk  ookk    81K Oct 11 15:19 lib/i386-apple-darwin/libHSbase_cbits.a
15:31:56 <ookk> -rw-r--r--   1 ookk  ookk     1K Oct 11 15:19 lib/i386-apple-darwin/libHSunix_cbits.a
15:32:08 <ookk> i wonder why it isnt
15:32:42 <allbery_b> http://www.ece.cmu.edu/~allbery/libHSOpenGL_cbits.a -- hopefully that will work for you
15:34:30 <ookk> allbery_b, thx but that one is for ppc
15:34:36 <bakert> ?paste
15:34:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:34:41 <allbery_b> oh, intel. sorry, missed that
15:34:49 <allbery_b> can't help with intel osx
15:35:03 <hpaste>  bakert pasted "Simplify?" at http://hpaste.org/350
15:35:03 <ookk> you are on a ppc mac?
15:35:10 <allbery_b> yeh
15:35:23 <bakert> Hello all.  I just pasted a function from my program that I'm pretty sure can be simplified.
15:35:28 <bakert> But I have no idea how.
15:35:33 <ookk> maybe i have to try the latest unstable ghc build
15:35:42 <ookk> see if its in there
15:35:56 <bakert> I'm doing a lot of <- stuff to get things out of IO and then packaging them up into a 4-tuple.
15:36:03 <audreyt> ookk: hm, I swear I repacakged to add it in...
15:36:10 <bakert> (I'm not sold on the 4-tuple, I can change it if necessary)
15:36:22 <Cale> liftM4 ?
15:36:27 <Cale> @type liftM4
15:36:29 <lambdabot> forall r (m :: * -> *) a4 a3 a2 a1. (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
15:36:39 <audreyt> ookk: http://perlcabal.org/~audreyt/tmp/libHSOpenGL_cbits.a
15:36:43 <bakert> ?type liftM
15:36:45 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
15:36:57 <Cale> > liftM4 (,,,) [1,2,3] [4,5] [6] [7,8]
15:36:59 <lambdabot>  [(1,4,6,7),(1,4,6,8),(1,5,6,7),(1,5,6,8),(2,4,6,7),(2,4,6,8),(2,5,6,7),(2,5,...
15:37:20 <Cale> that's the list monad, you could use the IO monad as well.
15:37:29 <bakert> Cale, that sounds good.  Can I do it if the types are not exactly the same (the first three are (String, Double) and the last is (String, Int))
15:37:31 <bakert> ?
15:37:39 <Cale> sure.
15:37:44 <ookk> audreyt, thx that works!
15:37:45 <Cale> > liftM4 (,,,) [1,2,3] [4,5] [6] "Hello"
15:37:47 <lambdabot>  [(1,4,6,'H'),(1,4,6,'e'),(1,4,6,'l'),(1,4,6,'l'),(1,4,6,'o'),(1,5,6,'H'),(1,...
15:38:02 <bakert> Cale, this could definitely be good!
15:38:44 <bakert> I actually apply the four functions to the same argument each time.  Is there some way to include that in the call to liftM4?
15:38:45 <audreyt> ookk: cool, though I wonder what's wrong with my packaging
15:39:03 <ookk> it compiles now but crashes
15:39:05 <ookk> 2007-02-07 00:35:14.986 test[21775] GLUT Warning: The following is a new check for GLUT 3.0; update your code.
15:39:06 <ookk> 2007-02-07 00:35:14.986 test[21775] GLUT Fatal Error: redisplay needed for window 1, but no display callback.
15:39:21 <ookk> audreyt, dont i need the .o file to?
15:39:23 <nomeata> bakert: maybe with mixing in the ((->) a) monad
15:40:00 <bakert> nomeata, ohhh dear this is getting heavy!  Where does ((->) a) live?
15:40:01 <Cale> That might be liftM4 again... hmm
15:40:14 <allbery_b> bakert: Control.Monad.Reader
15:40:27 <nomeata> > liftM4 (liftM4 (,,,)) ([]:) ([]:) ([]:) ([]:) True
15:40:28 <lambdabot>  Couldn't match `[[a]]' against `Bool'
15:40:35 <Cale> > liftM4 (,,,) (+1) (*2) (+10) (*3) 5
15:40:36 <lambdabot>  (6,10,15,15)
15:40:52 <audreyt> ookk: same url, HSOpenGL_cbits.o
15:41:13 <bakert> Cale, that looks good.
15:41:14 <Cale> er, then you have the problem of (IO a, IO b, IO c, IO d) -> IO (a,b,c,d)
15:41:20 <bakert> ah yes
15:41:25 <Cale> Let's just look at what you're actually doing.
15:41:42 <bakert> http://hpaste.org/350
15:41:54 <nomeata> > (liftM4.liftM4) (,,,) ([]:) ([]:) ([]:) ([]:) True
15:41:55 <lambdabot>  Couldn't match `[[a]]' against `Bool'
15:42:26 <ookk> audreyt, thx alot
15:42:33 <ookk> still crashes though
15:43:02 <nomeata> we want type (a -> b > (a,b)) -> (c -> IO a) -> (c -> IO b) -> c -> (a,b)
15:43:12 <nomeata> (for 2-tuples)
15:43:13 <nomeata> right?
15:43:24 <audreyt> ookk: may not be my problem...
15:43:31 <audreyt> ookk: do you have X running?
15:43:40 <ookk> yes ofc
15:43:54 <ookk> i have set DISPLAY
15:43:59 <ookk> and tried in the xterm also
15:44:03 <nomeata> @h ((a,b)->c) -> a -> b -> c
15:44:04 <lambdabot> Maybe you meant: help hitchcock hoogle hoogle+ . v
15:44:08 <nomeata> @hoogle ((a,b)->c) -> a -> b -> c
15:44:09 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
15:44:21 <bakert> nomeata, i'm not sure.  i take a [ClockTime] and apply four similar functions to it.  I then pass the result of that somewhere else.  So the core thing is that I want to do four IO functions on the same list as an argument.
15:44:25 <nomeata> @hoogle ((a,b,d)->c) -> a -> b -> d -> c
15:44:27 <lambdabot> No matches, try a more general search
15:44:39 <audreyt> ookk: dunno
15:44:48 <bakert> It's not important that the result me a 4-tuple although that seems sensible.
15:44:48 <audreyt> ookk: hpaste a sample script for me?
15:44:49 <Cale> bakert: if those functions had the same type, it wouldn't be too hard to use mapM here.
15:44:55 <chessguy> heh. this is pretty weird-looking:
15:44:57 <bakert> Cale, Well they kind of do
15:44:57 <Cale> for instance
15:45:00 <chessguy> type Foo = Char -> Int
15:45:00 <chessguy> foo :: Foo
15:45:00 <chessguy> foo _ = 3
15:45:00 <chessguy> main = print $ foo 'c'
15:45:09 <ookk> !paste
15:45:10 <hpaste> Haskell paste bin: http://hpaste.org/
15:45:21 <Cale> [ts,ps,ss,bs] <- mapM ($ times) [transactions, profits, stakes, bets]
15:45:31 <nomeata> bakert: if you can just put the results in a list, use mapM
15:45:32 <hpaste>  ookk pasted "opengl" at http://hpaste.org/351
15:45:55 <Cale> But I wouldn't be too unhappy with your existing code.
15:46:07 <bakert> Cale, nomeata, i'm not sure if I can or not.  They all give results of type Bucketed a = [(Key, a)]
15:46:12 <bakert> where type Key = (String, ClockTime)
15:46:16 <ookk> audreyt, that is what i am trying to get running  http://hpaste.org/351
15:46:25 <bakert> But a is sometimes a Double and sometimes an Int
15:46:31 <Cale> bakert: polymorphic like that?
15:46:44 <bakert> Cale, I'm not quite sure I understand your question, sorry!
15:46:45 <Cale> bakert: if you stick them all in a list, then the a's will all be the same.
15:47:31 <Cale> But I'm guessing you mean that they're for different a
15:47:58 <audreyt> ookk: you need a display callback
15:48:03 <bakert> Cale, Double for three and Int for the last one.
15:48:07 <Cale> yeah
15:48:10 <bakert> bummer.
15:48:10 <audreyt> before mainLoop
15:48:20 <Cale> So you could combine the three, but it's not so clean.
15:48:23 <bakert> I could pass it around as a Double and then round it!!!
15:48:28 <bakert> (naughty bakert)
15:48:42 <Cale> You could also write a sequence4 :: (IO a, IO b, IO c, IO d) -> IO (a,b,c,d)
15:49:00 <Cale> But that's just moving around the problem :)
15:49:11 <ookk> audreyt, aha so the problem was with the code, i just copied a hello-world program thinking it would work :P
15:49:33 <ookk> audreyt, tried it with another test source and it worked!
15:49:34 <bakert> Cale, yeah.  It is pretty clear how it is but I hoped there was a well known way of doing it in one line.  Those lines just look so similar and repetitious.
15:49:51 <bakert> Perhaps I will just do the mapM thing on the Double ones, reducing it to two lines.
15:50:07 <Cale> Or you could do a liftM4
15:50:21 <ookk> audreyt, now it actually works, thx to you!
15:50:23 <olliej> ?pl let p x y = \z -> z x y; x1 y = p y y; x2 y = x1 $ x1 y; x3 y = x2 $ x2 y; x4 y = x3 $ x3 y in x4 $ \z -> z
15:50:23 <bakert> I'm not quite sure how to use liftM4
15:50:28 <lambdabot> join (.) (join (.) ((flip =<< flip id) . (flip =<< flip id))) id
15:50:38 <ookk> audreyt, you are the guy making the ghc tarballs for mac?
15:50:43 <Cale> t <- liftM4 (,,,) (transactions times) (profits times) (stakes times) (bets times)
15:50:45 <olliej> wow, that's remarkably concise
15:50:50 <Cale> hmm
15:50:58 <Cale> @pl \times -> liftM4 (,,,) (transactions times) (profits times) (stakes times) (bets times)
15:50:59 <lambdabot> ap (ap (ap (liftM4 (,,,) . transactions) profits) stakes) bets
15:51:01 <nomeata> Cale: that gives again (IO a, IO b, IO c, IO d, doesnâ€™t it
15:51:03 <Cale> haha
15:51:04 <chessguy> olliej, welcome to Haskell :)
15:51:09 <audreyt> ookk: or gal, but yeah. I'm resending a tar.bz2 to HQ
15:51:11 <Cale> hmm
15:51:19 <audreyt> this time with the OpenGL files
15:51:31 <olliej> chessguy: hehe -- i was more curious because of the type of the expression
15:51:32 <nomeata> Cale: nevermind
15:51:41 <olliej> chessguy: which is the opposite of concise
15:51:42 <ookk> audreyt, nice, god this got sorted out then!
15:51:48 <ookk> good*
15:51:56 <nomeata> I guess we need a ((->) a)T monad, and then work in ((->) a)T IO :-)
15:51:56 <audreyt> ookk: care to hpaste the example that worked? just curious
15:51:57 <bakert> Cale, nomeata, surely there is an easy way to go fro (IO a, IO b ...) -> IO (a, b ...) ???
15:52:02 <chessguy> man, why is flip so important in haskell. it shows up everywhere
15:52:09 <Cale> bakert: not in the libraries.
15:52:13 <bakert> shame
15:52:15 <nomeata> bakert: yes, but you have to write it
15:52:16 <olliej> audreyt: are you the audrey who did intel macos binaries for ghc?
15:52:26 <Cale> bakert: there are no uncurry functions for more than pairs
15:52:28 <audreyt> olliej: I think I just said yes :)
15:52:28 <ookk> !paste
15:52:28 <hpaste> Haskell paste bin: http://hpaste.org/
15:52:31 <bakert> well i may go for my hybrid:
15:52:31 <bakert>     [ts,ps,ss] <- mapM ($ times) [transactions, profits, stakes]
15:52:31 <bakert>     bs <- bets times
15:52:38 <bakert> sorta wonky but OK.
15:52:41 <hpaste>  ookk pasted "worked" at http://hpaste.org/352
15:53:00 <olliej> audreyt: :D thanks -- it was annoying back in 6.4 when it didn't exist
15:53:11 <nomeata> is there an instance MonadIO ((->) a) ?
15:53:13 <sorear> is a newtype Attr = Attr Int always as fast as an Int?
15:53:18 <audreyt> well, 6.4 didn't build ;)
15:53:24 <audreyt> but glad to be of service
15:53:24 <sorear> nomeata: there SHOULD be
15:53:26 <olliej> audreyt: i know
15:53:29 <olliej> audreyt: i tried :D
15:53:31 <ookk> audreyt, ohh i cut the file in half
15:53:36 <sorear> nomeata: it's easy to check:
15:53:40 <sorear> @instances MonadIO
15:53:42 <olliej> audreyt: i had to build ghc for my thesis
15:53:42 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
15:53:52 <olliej> (that wasn't the goal, it was a intermediate step :D)
15:53:53 <sorear> @instances-importing Control.Monad.Instances MonadIO
15:53:54 <hyrax42> sorear: afaik newtypes are just plain as the types generally
15:53:54 <lambdabot> Couldn't find class `MonadIO'. Try @instances-importing
15:54:01 <sorear> @instances-importing MonadIO Control.Monad.Instances
15:54:03 <lambdabot> Couldn't find class `Control.Monad.Instances'. Try @instances-importing
15:54:05 <hyrax42> as far as representation
15:54:08 <hyrax42> so should be as fast
15:54:09 <hpaste>  ookk pasted "also worked" at http://hpaste.org/353
15:54:30 <ookk> audreyt, there is one that worked that fit in the paste
15:54:39 <sorear> hyrax42: well, my code is slow and I'm looking for a culprit.
15:54:50 <nomeata> the source code link on http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Trans.html is dead
15:54:53 <lambdabot> http://tinyurl.com/yqbbla
15:55:00 <sorear> hyrax42: profiling fingers a couple of zipWithM's that do equality on my newtype.
15:55:08 <Cale> nomeata: huh?
15:55:18 <sorear> nomeata: s/.raw-hs/.hs/
15:55:19 <Cale> nomeata: You can't do IO from (->) e
15:55:37 <audreyt> ookk: cool, thanks!
15:55:55 <sorear> Cale: I think he meant instance (MonadIO m) => ... oh duh, (->) isn't a transformer
15:56:20 <nomeata> but coudnâ€™t it be put into a transfomer
15:56:24 <sorear> nomeata: (->) e is a monad itself - you can't have IO under it, so it cxan't be IO
15:56:52 <sorear> nomeata: if it was put into a transformer IO couldn't be. a stack can only have one base monad.
15:57:08 <ookk> audreyt, its pretty booring though, just shows a black fullscreen :P
15:57:18 <audreyt> Igloo: .tar.bz2 re-sent with missing files added
15:57:32 <audreyt> ookk: yeah :) I gotta crash into sleep now
15:57:36 <ookk> audreyt, check this out if you want more examples http://projects.codersbase.com/repos/nehe-tuts/
15:57:38 <lambdabot> Title: Index of /repos/nehe-tuts
15:57:39 <nomeata> so that do { a <- f ; b <- g a ; return (a+b,) } z resolves to do {a <- f z; b <- g a z; return (a+b,z )} in the underlying monad
15:57:51 <Igloo> audreyt: Is this related to the os x problems on the mailing list?
15:57:52 <sorear> someone looking for HOpenGL code?
15:57:55 <ookk> audreyt, ok good night, thx for your help!
15:57:59 <olliej> chessguy: i take it you're writing a chess engine?
15:58:02 <bakert> Cale, nomeata, thanks for your help
15:58:11 <ookk> sorear, yeah sure
15:58:12 <sorear> I've got an abandoned fractal engine
15:58:14 <Igloo> audreyt: Oh, n/m, seen the e-mail now
15:58:19 <audreyt> :) &
15:58:20 <Igloo> audreyt: thanks
15:58:33 <sorear> (abandoned because of 5 year old Xorg crash bugs fume fume fume)
15:58:34 <newsham> mmm fractals
15:58:45 <ookk> hehe
15:58:57 <sorear> so if I hack it I have to restart my server every 5 minutes
15:59:12 * nomeata goes to bad. had enough struggle with monad transfomers today :-)
15:59:21 <newsham> more than meets the eyes
15:59:51 <allbery_b> sounds like a job for Xnest, actually
15:59:55 <sorear> it's a neat algorithm however ... realtime fractal flames!  no more downloading mpegs for electric sheep
16:00:13 <sorear> allbery_b: I believe Xnest delegates all GLX calls
16:00:28 <sorear> @users
16:00:28 <lambdabot> Maximum users seen in #haskell: 322, currently: 301 (93.5%), active: 46 (15.3%)
16:01:14 <humasect> i would like to send a file privately to simonpj for GHC Trac, does anyone know his email?
16:01:51 <psnl> its on his webshite
16:01:58 <dons> humasect: should be pretty easy to find. its on his web site
16:01:58 <humasect> ah thanks
16:02:21 <humasect> ah there we go, thanks. (i am not awake)
16:02:37 <sorear> dons: changing to newtype'd int alas had no effect on performance.
16:03:05 <dons> how about type T = Int :)
16:03:21 <sorear> that offends my sensibilities
16:03:30 <sorear> if it's faster, it's a compiler bug
16:03:52 <sorear> worth trying? *gulp*
16:04:06 <SamB> sorear: not everything can see straight through those coerce thingums, you know
16:05:01 <sorear> incidentally the api used to use Int and bitflags, jyp made me change it
16:07:40 <dons> yeah, it'd be a compiler bug if a netyped' Int doesn't optimise to an Int. but you better profile, and check the core for the key functions
16:12:18 <ookk> audreyt, i think the tarball is missing HSOpengl.h to
16:24:38 <mbishop> http://koweycode.blogspot.com/2007/01/think-of-monad.html
16:24:39 <mbishop> heh
16:24:40 <lambdabot> Title: koweycode: think of a monad...
16:24:56 <chessguy> :maxbound Int
16:25:05 <chessguy> ?maxBound Int
16:25:05 <lambdabot> Unknown command, try @list
16:25:28 <allbery_b> > maxBound :: Int
16:25:29 <lambdabot>  2147483647
16:25:33 <chessguy> ah
16:26:06 <mbishop> > minBound :: Int
16:26:08 <lambdabot>  -2147483648
16:26:32 <mbishop> > maxBound :: Integer
16:26:34 <lambdabot>   add an instance declaration for (Bounded Integer)
16:26:34 <lambdabot>     In the expression: ma...
16:26:36 <mbishop> heh
16:26:48 <allbery_b> @instances Bounded
16:26:49 <lambdabot> (), (a, b), (a, b, c), Bool, Char, Int, Ordering
16:27:01 <chessguy> an Integer can be infinitely large?
16:27:08 <sjanssen> yes
16:27:14 <chessguy> > (2^1000) :: Integer
16:27:16 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
16:27:17 <allbery_b> availabme memory, at least
16:27:22 <chessguy> wow
16:27:38 <chessguy> is there anything Haskell can't do?
16:27:43 <sjanssen> > product [1..365]
16:27:45 <lambdabot>  2510412867555873229292944374881202770516552026987607976687259519390110613822...
16:27:49 <Nafai> I'm trying to install shim...and I'm missing the dependency ghc-any...where would I get that?
16:28:22 <Igloo> It needs to come with GHC
16:28:36 <chessguy> > 13^64
16:28:37 <lambdabot>  196053476430761073330659760423566015424403280004115787589590963842248961
16:29:04 <chessguy> a very loose upper bound on the number of possible chess positions :)
16:30:55 <Nafai> Hrm
16:31:00 <Thomas2> surely it should be 12^64?
16:31:06 <jcreigh> empty squares
16:31:14 <Thomas2> heh, whoops
16:31:28 <Thomas2> > 12^64
16:31:30 <lambdabot>  1168422057627266461843148138873451659428421700563161428957815831003136
16:31:48 <jcreigh> that's a very rough estimate anyway.
16:31:51 <Thomas2> odd. I'd have expected that to be significantly smaller
16:31:56 <chessguy> > 2^256
16:31:58 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639936
16:32:03 <Daveman> ...
16:32:46 <Igloo> 64^32 is a smaller bound... 64!/32! smaller still
16:32:51 <rahikkala> @type 2^256
16:32:53 <lambdabot> forall a. (Num a) => a
16:33:04 * rahikkala slaps lambdabot 
16:33:06 <Igloo> Oh, 65, not 64
16:34:10 <jcreigh> Igloo: hmm...so you're saying each piece could be in any square, or captured?
16:34:18 <Igloo> Yup
16:34:24 <dibblego> dons, are you about?
16:35:18 <sorear> gah Performance/Strings is obsolete
16:35:33 <sorear> "Use the standard PackedString library"
16:35:54 <sorear> "or one of the newer libraries, such as ByteString"
16:36:32 <dons> dibblego: yeah
16:36:39 <dons> sorear: update it
16:36:57 <dibblego> dons, could you do me a favour and try to resolve witte-consulting for me please?
16:37:08 <dibblego> er, witte-consulting.com
16:37:08 <Procyon_> chessguy: just remember that Integer is likely to be significantly slower than Int.  Orders of magnitudes slower once your value exceeds maxint.
16:37:25 <dibblego> it seems that nobody in Australia can resolve it
16:37:29 <chessguy> Procyon_, goot to know, thanks
16:37:33 <dons> hmm...
16:38:01 <Igloo> Procyon_: Orders of magnitude more correct if you need values that exceed maxint, though!
16:38:02 <jcreigh> Igloo: hmm... but where do you get 64!/32!? That's not "64 choose 32", is it?
16:38:10 <DukeDave> I'm thinking the prelude doesn't contain a definition of e ?
16:38:10 <Igloo> (do you have numbers to back up "Orders of magnitudes slower"?)
16:38:21 <Procyon_> igloo: true :)
16:38:31 <jcreigh> > exp 1
16:38:33 <lambdabot>  2.718281828459045
16:38:34 <dons> dibblego: i can get at it from uni (on the .edu network), but not from home.
16:38:35 <DukeDave> as in: e = 1 + 1/1! + 1/2! + 1/3! + ...
16:38:44 <dibblego> dons, bizarre
16:38:46 <Procyon_> igloo: nope.  just going of past experience with how such things are implemented.
16:38:50 <DukeDave> woop, cheers jcreigh  :)
16:39:15 <dibblego> dons, thanks
16:39:26 <Igloo> jcreigh: There are 65 places the first piece can be, 64 the second, and so on. 65!/33! (after you remember about "off the board")
16:39:37 <Igloo> jcreigh: Because two pieces can't be on the same square
16:40:03 <chessguy> > 2^155
16:40:05 <lambdabot>  45671926166590716193865151022383844364247891968
16:40:16 <Procyon_> igloo: I played with a big prime sieve the other day with Integer, and the slowdown barrier at maxint was very noticeable.
16:40:17 <Igloo> jcreigh: It's actually better than that as pawns are interchangeable, but you can't just divide by 8!^2 as it doesn't work for off-the-board
16:40:33 <chessguy> if i recall correctly, this is the tightest known bound on the number of legal positions, give or take a few factors of 2
16:41:08 <ddarius> Procyon_: You'd think it would be.
16:41:23 <Igloo> Procyon_: Ah, I'd be interested in seeing the code and instructions for recreating that (not that I don't believe you, I'd just be interested, both generally and for benchmarking interger replacements)
16:41:46 <Nafai> Crud. :(
16:41:47 <dons> Procyon_: it would be, you're switching into GMP land
16:41:52 <Nafai> shim requires GHC 6.6
16:42:03 <Procyon_> dons: does GHC use gmp?
16:42:10 <allbery_b> yes, it uses ghc-api which is ghc 6.6+
16:42:14 <sorear> Procyon_: yes
16:42:15 <dons> for big integers, yeah
16:42:35 <sorear> we also have medium big integers
16:42:35 <Nafai> I guess I'll have to wait until I upgrade to feisty, unless someone has backported the ghc6.6 packages
16:42:44 <dons> sorear: we do?
16:42:46 <Igloo> chessguy: Interesting, that's higher than I'd have expected
16:42:48 <sorear> > (10000000000 + 300000000) :: Word256
16:42:51 <lambdabot>  10300000000
16:43:03 <Procyon_> igloo: Since it's using gmp, you're likely not going to go any faster than Integer.  gmp uses the super ultimate black magiks.
16:43:04 <dons> ah yes
16:43:08 <sorear> i don't recall if that's standard, however
16:43:12 <chessguy> Igloo, it's been a long time since i've read anything about it, so my memory could be faulty
16:43:13 <dons> its not
16:43:31 <jcreigh> Igloo: well, pawns aren't quite interchangable. There's a difference between a pawn that just moved forward two spaces and one that didn't. (en passant)
16:43:40 <dibblego> dons, who is your home ISP?
16:44:03 <sorear> Procyon_: GMP is optimized for HUGE numbers.  megabits.  small, like 65 bits, could do better.  iirc.
16:44:17 <coffee-mug> hey everyone
16:44:42 <sorear> hey.
16:44:48 <dons> dibblego: exetel
16:44:50 <Igloo> jcreigh: Oh, true, but that just means there really are 64 spaces a pawn can be on (8 pairs of which are actually the same square, and 8 squares they can't be on)
16:44:56 <dibblego> dons, thanks
16:44:56 <chessguy> jcreigh, well if you want to make that distinction, then you get into restrictions like "pawns that are blocking check, and thus can't move, and those that aren't"
16:45:03 <Procyon_> sorear: yes, but you would have to sacrifice arbitrary precision.
16:46:21 <jcreigh> chessguy: but you can tell that just by looking at the board. The only way to know whether en passant is legal or not is to record it out of band.
16:46:33 <ddarius> Procyon_: W.r.t what sorear most recently said, no you would not.  You'd have to sacrifice performance for larger numbers.
16:46:58 <ddarius> (relatively speaking)
16:46:58 <sorear> Procyon_: conditionals!  or rather lack thereof.  it makes sense to test for hugeness and switch in karatsuba/strassen for multing numbers that might be very big, but if the numbers are guaranteed to be smallish, it just wastes bpb space.
16:47:46 <chessguy> what sorts of things can be imported from another module?
16:47:53 <chessguy> (not to change the subject or anything)
16:47:59 <sorear> just about everything
16:48:08 <sorear> not comments :)
16:48:14 <sorear> not export lists
16:48:20 <Procyon_> I'd have to look again, but IIRC gmp does some weird switching already, depending on the native machine word length.  granted I haven't written to the gmp api in a few years, but it eats my compilers for lunch from weird alignment issues...
16:48:21 <chessguy> hmm, then maybe i should ask: what sorts of things CAN'T be imported
16:48:57 <sorear> chessguy: export lists and defaults are all that comes to mind
16:49:08 <chessguy> what do you mean by 'efaults'
16:49:10 <chessguy> +d
16:49:12 <olliej> ?seen ndm
16:49:12 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 5h 10m 8s ago, and .
16:49:25 <sorear> Procyon_: exactly - the point is the the switching just wastes bpb space for small numbers.
16:49:25 <olliej> dammit, i continually miss him
16:49:26 <olliej> :-/
16:49:31 <sorear> chessguy: default( Int )
16:49:51 <chessguy> sorear, sorry, i don't know what that does
16:50:01 <chessguy> pardon my ignorance
16:50:16 <sorear> no, it's widely acknowledged as  deep arcana
16:50:24 <sorear> basically consider
16:50:26 <sorear> > show 2
16:50:28 <ddarius> chessguy: Don't worry (too much) about it.  It's ugly but convenient.
16:50:28 <lambdabot>  "2"
16:50:33 <sorear> what is the type of 2?
16:50:41 <allbery_b> :ty 2
16:50:47 <sorear> it's ambiguous
16:50:48 <allbery_b> :t 2
16:50:50 <chessguy> mmm, looks like a String to me
16:50:50 <lambdabot> forall t. (Num t) => t
16:50:54 <chessguy> :t "2"
16:50:56 <lambdabot> [Char]
16:51:07 <jcreigh> chessguy: no, the argument to show
16:51:07 <allbery_b> hm, no, gets the wrong thing
16:51:10 <sorear> chessguy: look at the source, not the output :)
16:51:13 <chessguy> oh
16:51:25 <chessguy> ah, i see
16:51:27 <allbery_b> the argument to show.  it's ambiguous because constant 2 is Num a => a
16:51:29 <ddarius> Hmm, ? : defaulting :: type classes : ML eqtypes
16:51:37 <allbery_b> defaults tells it how to resolve the ambiguity
16:51:45 <sorear> but newbs would get confused if show 2 was illegal
16:51:57 <ddarius> :t []
16:51:58 <sorear> the default default (hah!) is default(Integer) iirc
16:51:59 <lambdabot> forall a. [a]
16:51:59 <chessguy> ?type Show
16:52:01 <lambdabot> Not in scope: data constructor `Show'
16:52:09 <olliej> ?type show
16:52:11 <lambdabot> forall a. (Show a) => a -> String
16:52:13 <Igloo> it's Integer, Int, Double, Float IIRC
16:52:13 <chessguy> bleah
16:52:13 <ddarius> >show []
16:52:14 <sorear> so the 2 in show 2 is an Integer
16:52:20 <sorear> ddarius: haha.
16:52:32 <sorear> > show []
16:52:33 <lambdabot>  Add a type signature
16:52:45 <sorear> ^^^ defaulting only works for numeric types
16:52:48 <sorear> hmm
16:53:04 <sorear> > {-# OPTIONS_GHC -fextended-default-rules #-} show []
16:53:05 <lambdabot>  Add a type signature
16:53:06 <ddarius> sorear: GHC extends the behavior
16:53:24 <chessguy> ok, so it's not likely something i'd be using. what else can't be imported?
16:53:36 <ddarius> But that was more to point out part of the motivation of my above incomplete analogy.
16:53:58 <hpaste>  DukeDave pasted "Instance of Integral Double required?" at http://hpaste.org/354
16:54:14 <DukeDave> Hey gang, could someone off a word of advice here, if you have  a moment :)
16:54:28 <DukeDave> I keep running into little problems like this and it's so frustrating
16:54:42 <allbery_b> :t (^^)
16:54:44 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
16:54:55 <Nafai> @shapr
16:54:56 <lambdabot> why on earth would I slap
16:55:06 <allbery_b> if you want a Double you need (**) IIRC
16:55:09 <allbery_b> :t (**)
16:55:11 <lambdabot> forall a. (Floating a) => a -> a -> a
16:55:23 <hpaste>  DukeDave annotated "Instance of Integral Double required?" with "(no title)" at http://hpaste.org/354#a1
16:56:08 <sorear> @get-shapr Nafai
16:56:09 <lambdabot> shapr!!
16:56:27 <Nafai> Thanks! :)
16:56:40 <DukeDave> allbery_b, still getting the error post (**) update
16:56:46 <allbery_b> DukeDave:  you are exponentiating by a Fractional, that doesn't work with (^^).  use (**) instead
16:56:53 <hpaste>  DukeDave annotated "Instance of Integral Double required?" with "(no title)" at http://hpaste.org/354#a2
16:57:10 <syntaxfree> is there a simple formula for max (xor (i,j)) where i,j <= n ?
16:57:28 <sorear> is there any truth to the rumor that MTL is slow?
16:57:35 <allbery_b> er, no.  you replaced the (*)
16:57:48 <sorear> syntaxfree: sounds like a fun problem. /me takes a break from studying topology.
16:58:03 <syntaxfree> sorear: I'm working on a funnier problem still.
16:58:16 <hpaste>  allbery_b annotated "Instance of Integral Double required?" with "should be correct" at http://hpaste.org/354#a3
16:58:22 <allbery_b> you need to replace the first (^^) with (**)
16:58:25 <syntaxfree> The distribution of xor (a, b) where a and b are randomly drawn integers between 1 and n.
16:58:29 <syntaxfree> There is definite pattern in it.
16:58:30 <dons> sorear: hmm, it doesn't unroll as well as it could
16:58:38 <syntaxfree> @paste
16:58:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:58:40 <sorear> mtl loops!?
16:58:42 <dons> sorear: so yeah, there's an overhead. depends on your situtation though
16:58:49 <dons> sorear: you have to check the core
16:58:58 <dons> since it really depends on what ghc does to the code, and how much it inlines
16:59:29 <dons> vty is very low level, its like binary, i'd avoid the mtl
16:59:34 <dons> since it has to run at C speed
16:59:49 <dons> at least the inner loops
16:59:51 <DukeDave> thanks allbery_b, it type checks now; but is it equivalent to the definition on the url posted there..?
16:59:56 <monochrom> instance Integral Double?!!
17:00:12 <sjanssen> what?!
17:00:19 <Procyon_> syntaxfree: what's your RNG?  There shouldn't be a pattern in truely random numbers.
17:00:31 <DukeDave> ah, yes, just pushed it thought my graph drawing function :)
17:00:37 <DukeDave> wow, that is confusing :)
17:00:42 <syntaxfree> I'm not working with a RNG. Im working with the distributions themselves.
17:00:48 <allbery_b> the difference between (^^) and (**)_ is that (^^) expects the second argument to be Integral while (**) expects Floating; it's otherwise conceptually the same operator
17:01:01 <allbery_b> there's also (^) where both arguments are Integral
17:01:03 <sjanssen> dons: have you fixed up the mandelbrot already?
17:01:24 <Procyon_> syntaxfree: ahh :) I thought you might have found a weak RNG
17:01:29 <allbery_b> someone else here can explain why you need three different operators :)
17:01:35 * allbery_b not really mathy
17:01:56 <syntaxfree> there is a pattern in the distribution of (A xor B) where A and B are uniformly drawn from the integers 1..n
17:02:06 <DukeDave> Ah no that's okay, I get (as much as I need to currently) now.. good trouble shooting :D
17:02:25 <DukeDave> although I thought they'd have gone for (^^^) for example!
17:02:37 <monochrom> I forgot why distinguish ^^ and ^.
17:02:53 <allbery_b> when you get something like (Inegral Double) it typically means you're using a Double where it wants an Int
17:03:40 * Gwern watches Ceiling_Cat
17:03:46 <Gwern> oops. mischan
17:03:52 <allbery_b> and vice versa (Floating Int) means you use an Int and it wants Double (but Floating may be Fractional or RealFloat, etc. -- the Haskell numeric typeclasses are somewhat complex)
17:04:01 <dons> sjanssen: nope. i'm ready to work on it now. which version should i start with?
17:04:15 <hpaste>  syntaxfree pasted "the distribution of xor(i,j)" at http://hpaste.org/355
17:04:21 <syntaxfree> sorear, procyon: look at that paste!
17:04:35 <sorear> syntaxfree: I've got a recurrence relation, or atleast the intuition to write one
17:04:52 <syntaxfree> for max (xor (a,b)) or for the statistical problem?
17:05:03 <sorear> the statistical problem
17:05:08 <syntaxfree> actually max . xor is a problem that came up designing some tests for the statistical problem.
17:05:11 <syntaxfree> hmm. explain! ; )
17:05:30 * sorear codes
17:05:59 <sjanssen> dons: I'm not sure.  gotaku pasted a new version an hour ago -- I haven't looked at it yet
17:06:01 <monochrom> syntaxfree: have you tried 0 to 2^k - 1 ?
17:06:07 <sorear> split the domain --> examine a possible extra case
17:06:15 <sjanssen> either http://hpaste.org/349 or http://hpaste.org/346#a1
17:06:37 <dons> ok. i'll see which one is faster and work on that :)
17:07:30 <syntaxfree> split the domain?
17:07:49 <syntaxfree> in the process, have you found a formula for max . sor?
17:07:52 <syntaxfree> s/sor/xor
17:08:45 <sorear> emergency chore call
17:08:52 <syntaxfree> okay.
17:08:55 <syntaxfree> any hints? :D
17:09:36 <dons> sjanssen: looks like yours is about 2x faster than 349
17:09:40 <sjanssen> dons: gotaku's sruns slower over here
17:09:55 <dons> right
17:10:03 <dons> now to see what we can tweak
17:10:30 <dons> anyway, should run better than the current one.its certainly a lot faster
17:10:34 <chessguy> hmm. so say I define data Foo = Foo { ... }, can i import foo :: Foo?
17:10:48 <dons> yeah? what's 'foo'?
17:10:51 <chessguy> from a different module?
17:11:01 <dons> sjanssen: so yours runs 4x faster than the existing entry, for N-2k
17:11:04 <chessguy> foo is an instance of type Foo
17:11:04 <dons> N=2k
17:11:39 <dons> sjanssen: any tricks you noticed in the code?
17:11:45 <chessguy> or is that just a bad idea
17:12:14 <dons> chessguy: seems harmless
17:12:33 <dons> sjanssen: a gzip tip, we can import H98 libs for Word and Bits
17:12:52 <dons> why does it import Typeable?
17:13:03 <sjanssen> dons: just delete the import
17:13:11 * Gwern is confused by something. is Yhc inspired by nhc or is it a fork?
17:13:11 <sjanssen> I wanted to see the types of the let bound functions
17:13:15 <dons> heh
17:13:19 <dons> ah right
17:13:36 <DukeDave> oh, my God, these Int/Integer/Double conversions are getting boring :(
17:14:11 <dons> :t ceiling
17:14:13 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:14:27 <gotaku> dons: Make any headway?
17:14:35 <dons> gotaku: getting there.
17:14:56 <dons> the shiftL could be an unchecked shift
17:15:01 <DukeDave> Integer -> Int   ?
17:15:12 <dons> fromIntegral
17:15:22 <dons> pick a type and stick to it! :)
17:16:05 <DukeDave> I need replicate (which takes Int) and also have to use fromInteger
17:16:33 <allbery_b> @hoogle genericReplicate
17:16:34 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
17:16:34 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
17:16:35 <olliej> dons: psh. haskell is so stupid... i should be free to treat float and int as the same thing, and then use thm as a pointer to some random location in memory
17:16:47 <dons> olliej: so true!
17:17:02 <olliej> dons: you can't make stable software without that ability
17:17:02 * dons passes olliej unsafeCoercE#
17:17:03 <olliej> ..
17:17:04 <DukeDave> lol, point taken :(
17:17:13 <olliej> maybe i have that the wrong way rounf
17:17:18 <olliej> dons: hehe
17:17:33 <dons> Prelude GHC.Base> unsafeCoerce# pi :: Int
17:17:34 <dons> 1413754136
17:17:35 <dons> :)
17:17:37 <allbery_b> DukeDave: the generic* functions from Data.List can help avpoid some Integer->Int conversion
17:17:44 <SimonRC> is there s neater way to say   ['0'..'9'] ++ ['a'..'z']
17:18:00 <allbery_b> > genericReplicate (3 :: Integer) 'x'
17:18:01 <lambdabot>  "xxx"
17:18:03 <olliej> dons: am trying to write a small version of haskell (eg. minus type classes and higher ranked/kinded types)
17:18:04 <SimonRC> I am doing    'r' : ((['0'..'9'] ++ ['a'..'z']) !! n)   and want fewer brackets
17:18:07 <monochrom> syntaxfree: if you use [0 .. power_of_2 - 1] you get uniform result, e.g., [0..15].
17:18:09 <sorear> "0123456789abcdefghijklmnopqrstuvwxyz" :)
17:18:15 <olliej> dons: the world will be my oyster.. or something
17:18:21 <dons> DukeDave: yeah, most int-constrained list functions have a generic* version
17:18:24 <syntaxfree> monochrom: what should be the chosen power?
17:18:35 <sorear> > filter isAlNum [minBound .. maxBound]
17:18:36 <lambdabot>   Not in scope: `isAlNum'
17:18:40 <sorear> > filter isAlphaNum [minBound .. maxBound]
17:18:41 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\178\179\...
17:18:47 <monochrom> any power of 2.  [0..15], [0..3], [0..65535], ...
17:18:59 <syntaxfree> hmm. Why is that?
17:19:21 <allbery_b> truth table for xor?
17:19:32 <syntaxfree> interestingly enough, what you say holds for 63, but not for 15
17:19:46 <syntaxfree> not for 7 too.
17:19:49 <monochrom> Things like [1..6] introduces biases at both ends 1 and 6.  0 is missing, 7 is missing.
17:20:01 <syntaxfree> AH, yes
17:20:02 <Procyon_> syntaxfree 16 is a naughty power of 2.. use the good ones ;)
17:20:07 <SimonRC> sorear: What an excellent argument to give people who think that any program that is correct in a typed language would be just as correct in a typed language.
17:20:18 <SimonRC> erm
17:20:26 <sorear> huh?
17:20:28 <SimonRC> you know what I mean
17:20:35 <syntaxfree> that's interesting, yes.
17:21:09 <SimonRC> Ok, so how would you create the "minBound" function in LISP?
17:21:28 <monochrom> What takes me aback is why after all these years programmers still start with 1.
17:21:33 <SimonRC> It can only work in Haskell because type inference can figure out what type must be returned.
17:21:50 <SimonRC> monochrom: which programmers?
17:22:05 <SimonRC> monochrom: occasionally, 1 is the right place to start.
17:22:16 <SimonRC> note that 0 is not a power of 2
17:23:13 <Procyon_> SimonRC 0 is 2**inf ;)
17:23:28 <syntaxfree> 2**(-inf) you mean.
17:23:36 <SimonRC> Numbering from 0 often comes from labeling the gaps between objects rather than the objects themselves.  Sometimes this is the Wrong Thing.
17:23:36 <Procyon_> right
17:24:02 <syntaxfree> Numbering from 0 breaks length x == # (last x)
17:24:11 <SimonRC> actually, in C:  ((unsigned int)2 << big_number) == 0
17:24:19 <syntaxfree> anyway, I'm going back to hacking.
17:24:25 <sorear> gah
17:24:30 <int-e> syntaxfree: 'breaks' is too strong, I think
17:24:32 <sorear> quickcheck sucks :)
17:24:37 <SimonRC> mh?
17:25:06 <glguy> ?shootout
17:25:07 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
17:25:53 <sorear> my elegent recurrence relation destroyed by "Falsifiable"
17:27:09 <gotaku> Only 4 points behind OCaml
17:28:56 <monochrom> > let {xs::[Word]; xs=[0..15]} in map length . group . sort $  [ xor x y | x<-xs, y<-xs ]
17:28:57 <lambdabot>  [16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16]
17:30:36 <Procyon_> gotaku: give mem usage any kind of weight and ghc blows OCaml away
17:31:31 <gvdm_other> is shootout using 6.6 across the board now?
17:31:38 <gotaku> Yes
17:31:44 <gvdm_other> yay!
17:31:56 <gvdm_other> did haskell jump up a few points?
17:32:48 <sorear> @karma quickcheck
17:32:48 <lambdabot> quickcheck has a karma of 1
17:32:54 <sorear> @karma QuickCheck
17:32:54 <lambdabot> QuickCheck has a karma of 11
17:32:57 <sorear> QuickCheck++
17:32:59 <sorear> QuickCheck++
17:33:03 <sorear> quickcheck--
17:34:57 <hpaste>  sorear annotated "the distribution of xor(i,j)" with "I can't explain myself in words; maybe code will help?" at http://hpaste.org/355#a1
17:35:21 <sorear> @tell syntaxfree <*hpaste> sorear annotated "the distribution of xor(i,j)" with "I can't explain myself in words; maybe code will help?" at http://hpaste.org/355#a1
17:35:21 <sorear>  
17:35:21 <lambdabot> Consider it noted.
17:37:01 <dons> gvdm_other: yeah, about 10 places on the rankings
17:37:36 <dons> ghc really only loses in the Double-based progs now. And we're fixing at least one of those.
17:39:09 <hpaste>  sjanssen annotated "mandelbrot -- strict and bytestring'd" with "cleaned up ByteString" at http://hpaste.org/346#a2
17:39:18 <sorear> dons: I just used quickcheck for the first time!
17:39:26 * sorear is excited
17:39:30 <dons> cool!
17:39:39 <sjanssen> s/ByteString/mandelbrot
17:39:43 <dons> sjanssen: ok, i'll merge that into my careful tweaks
17:39:47 <sorear> and it found a bug in my code!
17:39:56 <sorear> after 60 (!) tests
17:40:02 <dons> great
17:40:14 <dons> QuickCheck makes testing fun!
17:40:25 <sjanssen> dons: I ditched the infix type annotations because they're ugly and a real type signature cost only 2 gzipped bytes
17:40:42 <dons> yeah, did that too alread y :)
17:40:48 <monochrom> wow
17:40:52 <dons> the unchecked shiftL doesn't seem to buy us anything
17:41:18 <dons> i'l have to read the core to work out why
17:41:22 <monochrom> "new low price! type signatures for just 2 bytes!"
17:42:16 <Anon4888> Haskell needs more coersion
17:43:49 <int-e> sorear: so the code you pasted is correct, right?
17:44:08 <sorear> int-e: prop is satisfied for >300 tests
17:44:39 <sorear> (from memory) <Cale> that use of the word 'prove' annoyes me
17:44:45 <sorear> with reference to
17:44:48 <int-e> sorear: you had me looking for a bug that wasn't there.
17:44:50 <sorear> @help check
17:44:51 <lambdabot> check <expr>
17:44:51 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
17:45:19 <sorear> int-e: sorry.  the bug was in the second argument of the xor in the second case; the -1 was missing.
17:45:25 <Igloo> dons: BTW, there's no way to see which ones we most lose out on sizewise, is there?
17:45:35 <sjanssen> "Assert something beyond a reasonable doubt"?
17:45:36 <sorear> causing certian possibilities to be counted twice
17:45:49 <monochrom> don't worry about word play.
17:46:17 <dons> Igloo: not really. you can find out some size info
17:46:43 <sorear> dons: quickcheck is yours, right?
17:46:46 <int-e> Igloo: no way? you can set the weight for 'gzip bytes' to 1 and look at the ranking for single tests - it's awkward though. I don't know if there's a better way.
17:47:00 <dons> sorear: hmm?
17:47:21 <dons> and you can check the size against particular langauges
17:47:38 <Igloo> Oh, you can?
17:47:59 <sorear> as in you wrote it
17:48:03 <Igloo> OK, I'm an idiot
17:48:10 <Igloo> I just looked at the graph and assume the table had the same info in
17:48:11 <int-e> me too :)
17:49:11 <dons> sorear: no, John Hughes and Koen Claessen :)
17:49:34 <sorear> oh well
17:49:39 <sorear> no nicks, no karma :)
17:49:47 <Igloo> Do comments gets stripped before the size comparison?
17:49:56 <sorear> yes
17:50:05 <sorear> I forgot what kind...
17:50:27 <sorear> syntaxfree: is my annotation understandable?
17:50:36 <dons> yeah, only -- style
17:51:10 <syntaxfree> oh, I didn't see it.
17:51:11 <lambdabot> syntaxfree: You have 1 new message. '/msg lambdabot @messages' to read it.
17:51:16 <syntaxfree> I'll look at it.
17:51:33 <sorear> (just a @tell'd hpaste annonce, incase you waited more than 4 hrs)
17:52:46 <sorear> syntaxfree: quickcheck rocks! (wrt annotation and my uncertainty that the code was correct)
17:52:54 <syntaxfree> monads are freaking creepy.
17:53:03 <syntaxfree> the PFP library implements its homebrew joinWith
17:53:06 <monochrom> creepy things are freaking cool
17:53:08 <syntaxfree> but I just realized ...
17:53:16 <syntaxfree> it's liftM2!
17:53:24 <syntaxfree> I mean, FINANCIAL MODELLING AT LARGE.
17:53:30 <sorear> what do monads have to do with xor?
17:53:31 <monochrom> yeah I was wondering
17:53:32 <mbishop> @quote
17:53:32 <Igloo> Ah, I see, we're struggling in that area because we're putting entire regex libraries in our entries
17:53:32 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
17:53:34 <syntaxfree> It's *****ALL liftM2 ****
17:53:46 <monochrom> liftM2 is freaking cool
17:54:03 <dons> Igloo: what we need there is regex-tre or regex-pcre in the core libs
17:54:05 <syntaxfree> sorear: the Dist monad I was using for that code snippet. How did you check it without the PFP library?
17:54:08 <sorear> is ways_slow really THAT impressive ?
17:54:12 <dons> instead of / or next to/ regex-posix
17:54:13 <dino-> Does anyone know offhand if HaXml handles going from an HTML document to a plain text file? I want to ultimately end up with a not-tagged document as output.
17:54:30 <Igloo> dons: The rules would require it be a corelib?
17:54:38 <sorear> syntaxfree: the hard way. by enumerating all possibilities.
17:54:40 <monochrom> OK, you have reached that critical point of "oh wow everything is a monad!"  Welcome to the club.  You have begun a new era of haskell programming.
17:54:45 <dino-> I'm getting the 'produced more than one output' stuff when I do /> txt
17:55:06 <SamB> monochrom: but we already were in that era!
17:55:13 <sorear> dino-: that's not a core haskell error.  sounds like an XML lib thingy.
17:55:30 <dino-> sorear: yeah, it seems to be
17:55:45 <monochrom> Each person reaches that point at his own time.
17:56:01 <syntaxfree> sorear: the PFP library implements a distribution monad. That way you can use arbitrary probability distributions.
17:56:20 <syntaxfree> I mean, can I use a somewhat rude expletive?
17:56:29 <sorear> oh well.  your distribution was not arbitrary.
17:56:34 <chessguy> hmm. what happens if you're maintaining two separate states? can you be "in" both state monads at once?
17:56:39 * sorear loves higher order programming.
17:56:51 <syntaxfree> sorear: I wanted to keep the mathematics simple.
17:57:15 <chessguy> or would you have to use StateT just as if you were dealing with two different monads?
17:58:07 <sorear> I didn't even read the code :)  I just interpreted the description. in my own way.
17:58:29 <syntaxfree> the PFP library sucks, too. I mean, it implements joinWith the hard way, when it's only liftM2
17:58:36 <syntaxfree> ?src liftM2
17:58:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:58:56 <syntaxfree> can liftM2 be written in terms of fmap?
17:59:00 <sorear> no
17:59:17 <allbery_b> chessguy: StateT, or store your states in a record?
17:59:18 <sorear> but it can be written in terms of fmap + return + join!
17:59:28 <sorear> or `ap` and return
17:59:40 <sorear> or pair and fmap
18:00:01 <syntaxfree> I'm overwhelmed.
18:00:11 <int-e> what's pair?
18:00:12 <syntaxfree> I mean, the entire financial modelling industry = liftM2
18:00:14 <sorear> pair is to Applicative as join is to Monad
18:00:16 <int-e> liftM2 (,)?
18:00:19 * syntaxfree drops dead
18:00:20 <sorear> int-e: yes.
18:01:17 * allbery_b is very glad he didn't get hit by that when he was consulting for financial modeling folks
18:02:03 <chessguy> syntaxfree, how did you think SPJ did his analysis of Enron? :)
18:02:05 <allbery_b> cometo think of it that predated Haskell98 :)
18:02:20 <Cale> sorear: what's its type?
18:02:23 <sorear> int-e: it's more categorical than apply ... it is mentioned at the end of the applicative functor paper, and IMO glossed too much over.
18:02:24 <syntaxfree> jesus christ.
18:02:29 <syntaxfree> jesus h. christ.
18:02:37 * syntaxfree pulls all his hair out.
18:03:01 * chessguy gives syntaxfree a sedative
18:03:15 <syntaxfree>  I mean, I must have spent the better part of the year studying analytical solutions for stochastic calculus problems.
18:03:33 <Cale> @remember syntaxfree I'm overwhelmed. I mean, the entire financial modelling industry = liftM2
18:03:33 <lambdabot> Done.
18:03:36 <syntaxfree> (there's a general method, but it's too awkward in most cases.)
18:03:56 <syntaxfree> in particular. liftM2 (+) in that monad is a convolution.
18:04:22 <monochrom> Yes.
18:04:33 <monochrom> Now you see the light and understand monads.
18:05:04 <syntaxfree> I understood monads before. I think you don't understand how powerful this really is ; )
18:05:15 <syntaxfree> it's almost the holy grail of probability theory.
18:05:15 <sorear> Cale: Applicative f => f a -> f b -> f (a,b)
18:05:37 * syntaxfree thinks now that percolation systems might be comonadic.
18:05:40 <monochrom> No I had my own moment of enlightenment.  Not related to probability theory, but it was some other field.
18:06:42 <syntaxfree> jesus christ. I can't even code. My fingers are stuck.
18:06:57 <syntaxfree> most anything I'd want to code is foldM_ or something anyway.
18:07:00 <syntaxfree> @type foldM
18:07:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:07:07 <syntaxfree> @hoogle foldM
18:07:08 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
18:07:08 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:07:08 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
18:07:19 <chessguy> i wonder if everyone has their own personal "moment of enlightenment". i've had a few minor ones, but not any really big ones
18:07:23 <monochrom> The holy grail of programming is you don't code anymore.
18:07:37 <dino-> monochrom: Aw, that makes me sad. :(
18:07:48 <syntaxfree> bah.
18:07:56 <chessguy> dino-, we're not likely to get there any time soon
18:08:02 <syntaxfree> I wish I was hypocritical enough to silently build a career on top of this.
18:08:07 <monochrom> Perhaps this is too overwhelming for syntaxfree.
18:08:16 <allbery_b> heh
18:08:22 <syntaxfree> Instead, I'll get myself tangled into something more complicated, probably something I won't have the background for.
18:08:30 * chessguy slips syntaxfree another sedative, and sends someone to find a straitjacket
18:08:37 <dino-> chessguy: I had a guy argue with me in 2001 about how he believed Kurzweil's idea that eventually machines will program themselves and we'll just vaguely describe what we want to them in whiny natural language.
18:08:50 <dino-> I thought it sounded kind of like a bummer.
18:08:57 <chessguy> heh
18:09:04 <syntaxfree> dino-: except it's not whiny natural language, it's all in Control.Monad
18:09:10 <chessguy> dino-, ever heard a term called "The Singluarity"?
18:09:20 <chessguy> s/lu/ul/
18:09:32 * syntaxfree went nuts for the idea of the singularity for two weeks once.
18:09:39 * allbery_b is pretty sure by the time machines can pull that off they'll have realized humans are pointless and taken over
18:10:03 <dino-> chessguy: Yes. I pity the fool who knows who Kurzweil is and hasn't been exposed to singularity theories.
18:10:06 <chessguy> syntaxfree, it's an interesting idea
18:10:14 <monochrom> Please don't fear or doubt the machine.  It's our friend.
18:10:21 <dino-> Me becoming the machine is ok.
18:10:31 <dino-> But me no longer thinking about programming: not ok.
18:10:39 <syntaxfree> allbery_b: that's why some AI researchers are working in "friendliness".
18:10:50 <syntaxfree> liftM2, man.
18:11:09 <syntaxfree> liftM2 is the end of history.
18:11:26 * allbery_b rolls his eyes
18:12:32 <Gwern> syntaxfree: "some AI researchers"? who besides yudkowsky is even thinking about it?
18:13:00 <syntaxfree> Gwern: I'm not knowledgeable enough to know -- that's why I weaselworded it.
18:13:17 <syntaxfree> He does have enough funding though.
18:13:18 <Gwern> well, goeterzel maybe
18:13:43 <Gwern> yudkowsky has enough money to theorize, but his sole attempt at "running code", Flare, is a failure
18:14:15 <chessguy> .
18:14:16 <syntaxfree> there was one?
18:14:38 <Gwern> syntaxfree: yah. it was so much of a failure no one really mentions it anymore, even on sl4 :)
18:14:40 <syntaxfree> The only running code Ive seen is Mentifex/Mind.forth and frankly that is whack.
18:14:51 <Gwern> that wasn't yudkowsky, thank goodness
18:15:09 <syntaxfree> to quote Ali G, is it good or is it whack?
18:15:57 <monochrom> Why do you fear that machines become better programmers than us?
18:16:23 <monochrom> Machines has become better runners than us already.  That hasn't stopped people from running for fun and for games.
18:16:27 <Gwern> monochrom: because I fear being rewritten and debugged and constantly being built by a buildbot
18:16:39 <Gwern> imagine your mind crashing as often as we crash programs these days...
18:17:17 <syntaxfree> Gwern: so, the Mind.forth guy is really a crackpot as I suspected?
18:17:24 * sorear feels no loyalty to Homo sapiens
18:17:25 <chessguy> ?hoogle Rational
18:17:26 <lambdabot> Prelude.Rational :: type Rational
18:17:26 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
18:17:26 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
18:17:41 <Gwern> syntaxfree: a notorious one!
18:17:49 * sorear would be working for the machines if he had half a clue how
18:17:51 <chessguy> > 3::Rational
18:17:53 <lambdabot>  3%1
18:18:18 <int-e> > pi :: Rational
18:18:19 <lambdabot>   add an instance declaration for (Floating Rational)
18:18:19 <lambdabot>     In the expression: ...
18:18:27 <SimonRC> Am I going mad or does Data.List lack a cross-product function, i.e.: xs `cross` ys = [(x, y) | x <- xs, y <- ys]
18:18:29 <sorear> nice try
18:18:34 <int-e> > toRational (pi :: Double)
18:18:37 <lambdabot>  884279719003555%281474976710656
18:18:38 <sorear> SimonRC: it's in Control.Monad
18:18:44 <sorear> syntaxfree: this is your cue :)
18:18:47 <bd_> SimonRC: liftM2 (,) ?
18:18:53 <bd_> > liftM2 (,) [1,2,3] [1,2,3]
18:18:55 <sorear> bd_: bah.
18:18:55 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:19:26 <syntaxfree> it's ALL IN CONTROL.MONAD.
18:19:58 <syntaxfree> it's all liftM2.
18:20:00 <monochrom> Next year syntaxfree will be crazy about arrows.
18:20:00 <SimonRC> blech
18:20:10 <bd_> tsk, there's no ArrowPlus?
18:20:12 <syntaxfree> I've looked at arrows. I don't get why they're fun.
18:20:16 <bd_> oh, there is
18:20:17 <SimonRC> I will just define a cross operator: .*.
18:20:18 <sorear> bd_: there is too!
18:20:23 <mwolak> ooh, there's a tshirt idea: "Don't worry, I'm in Control.Monad"
18:20:28 * SimonRC <3 custom operators
18:20:31 <syntaxfree> @pl g f x = f x x
18:20:31 <lambdabot> g = join
18:20:37 <bd_> hmm
18:20:39 <sorear> bd_: and ArrowZero, and ArrowChoice, and ...
18:20:41 <Anon4888> *cartesian product... cross product is something else
18:20:45 <monochrom> IT IS ALL &&&
18:20:53 <SimonRC> @djinn [a] -> [b] -> [(a,b)]
18:20:54 <lambdabot> -- f cannot be realized.
18:20:58 <SimonRC> :-(
18:21:01 <sorear> SimonRC: zip!
18:21:04 <glguy> zip
18:21:06 <SimonRC> heh
18:21:07 <syntaxfree> > let  yupee = liftM2 (,) . join in yupee [1,2,3]
18:21:08 <lambdabot>   add an instance declaration for (Num [a])
18:21:08 <lambdabot>     In the list element: 3
18:21:13 <int-e> > (succ &&& pred) 0
18:21:15 <lambdabot>  (1,-1)
18:21:33 <SimonRC> Anon4888: you could be rigth there
18:22:12 <sorear> Emacs needs a mode to prohibit the creation of 1-char buffer names.
18:22:17 <sorear> siti: hi!
18:22:25 <int-e> sorear: uhm why?
18:22:42 <sorear> C-x b RET vs C-x b b RET
18:22:54 <siti> hello
18:23:25 <int-e> sorear: so C-x f b RET would still be ok? :)
18:23:35 <int-e> sorear: C-x C-f. sorry.
18:23:42 <SimonRC> Does ghc check for linearity of variables?  If so there is an obvious optimisation based on the way case-analysis can be "finished" *before* construction of results starts, allow re-use of memory without alloction or even better in-place updates.
18:23:47 <allbery_b> look at iswitchb?
18:24:05 <sorear> SimonRC: no. look at clean.
18:24:22 <sorear> oh, iswitchb, how un-obvious
18:24:36 <allbery_b> well, that's not its fundamental purpose
18:24:41 <SimonRC> sorear: I know about that.  Also linear lisp.
18:24:45 <allbery_b> it's just a convenient side effect
18:25:27 <SimonRC> ISTR that ghc tried to detect linear variables as an optimisation.
18:25:58 <SimonRC> I suppose linearity as a language feature comes down to whether you want to the compiler to help the programmer write easily-optimisable code...
18:25:59 <syntaxfree> ?src ap
18:26:00 <lambdabot> ap = liftM2 id
18:26:07 <sorear> ISTR?
18:26:13 <SimonRC> ?src unsafePerformIO
18:26:13 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
18:26:15 <allbery_b> "I seem to recall"
18:26:20 <SimonRC> !!!
18:26:23 <bd_> ?src lazy
18:26:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:26:31 <SimonRC> :-S
18:26:47 <sorear> bd_: it's not even a primop, it's baked into the code generator
18:26:52 <bd_> ah
18:26:55 <int-e> bd_: lazy :: a -> a  -- <wired into compiler>
18:27:08 <SimonRC> ?src IO
18:27:09 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
18:27:13 <SimonRC> eh?!
18:27:26 <SimonRC> :i RealWorld
18:27:31 <chessguy> remind me again, what's the difference between data Foo = Int, and type Foo = Int ?
18:27:37 <sorear> SimonRC: it's a dirty hack, get used to it or stop looking at @src
18:27:40 <SimonRC> the first is illegal
18:27:44 <bd_> data RealWorld  -- <wired into compiler>
18:27:46 <sorear> SimonRC: no
18:27:54 <chessguy> SimonRC, don't mind the RealWorld behind the curtain
18:28:06 <SimonRC> I am sure that "data Foo = Int" is illegal
18:28:10 <int-e> @src ST
18:28:11 <lambdabot> newtype ST s a = ST (STRep s a)
18:28:14 <sorear> chessguy: the first is a one-constructor enumeration, the second is an alias for Int
18:28:16 <SimonRC> unless you didn;t import the prelude
18:28:16 <int-e> @src STRep
18:28:17 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
18:28:36 <sorear> SimonRC: Int is a type constructor.  the predefined data con is called I#
18:28:43 <chessguy> SimonRC, i'm pretty sure you're wrong
18:28:51 <SimonRC> hmmm
18:28:55 <allbery_b> Int is a perfectly legitimate value constructor, easily disambiguated from a type
18:29:30 * allbery_b just compiled it, and is sure it works
18:29:45 <hpaste>  dons pasted "final mandel?" at http://hpaste.org/356
18:29:54 <allbery_b> just as Haskell manages data Foo = Foo Int and recognizes when Foo is a type and when it's a constructor
18:30:00 <dons> sjanssen, gotaku around ?
18:30:11 <SimonRC> ah, silly me, types/classes and functions/data constructors are in seperate namespaces
18:30:12 <gotaku> dons: Yep.
18:30:24 <dons> gotaku: can you give the above mandelbort a run through on your box?
18:30:29 <dons> with the flags specified
18:30:29 <SimonRC> presumably similar arguments apply as for a LISP-2
18:31:47 <gotaku> dons: Oh you were working off the old version and not my updated one?
18:32:03 <dons> gotaku: that was the fastest one as far as I could see
18:32:24 <dons> the other one sjanssen pointed me to was about 2x slower still
18:32:49 <gotaku> dons: This one I mean http://hpaste.org/349
18:32:57 <dons> yeah, this was 2x faster than that one
18:33:02 <dons> so I worked with this one instead.
18:33:07 <dons> do you get the same results?
18:33:09 <gotaku> dons: Really?
18:33:17 <dons> i'll double check...
18:33:29 <gotaku> dons: All I did was remove some things that aren't needed.
18:33:33 <dons> this program was very sensitive to code placement.
18:33:49 <dons> moving e.g. gb out to the top level makes it run 2x slower
18:34:24 <glguy> was it ever established if putStr was acceptable?
18:34:35 <dons> yeah, definitely, the above runs 2x slower
18:34:47 <dons> 20s for N=2k rather than 9s
18:34:59 <dons> glguy: I think it will be ok, since its lazily demanding bytes
18:35:07 <dons> this has been acceptable in the past
18:35:25 <gotaku> dons: The Lisp version uses write-sequence
18:35:38 <dons> is that a chunk-wise write?
18:35:54 <dons> gotaku: can you just confrim the version I pasted does run faster than http://hpaste.org/349 ?
18:35:54 <glguy> dons: I only asked because gotaku suggested you suggested to use mapM_ putChar
18:36:16 <dons> right, a long time ago :) now we have lazy bytestrings its a bit blurrier
18:36:29 <dons> since they're doing byte-at-a-time unfolding anyway
18:37:36 <gotaku> dons: I don't notice that much of a difference.
18:38:15 <dons> hehe, we can import Foreign instead of Bits && Word
18:38:22 <dons> gotaku: ok. what arch?
18:38:26 <chessguy> ?hoogle StateT
18:38:27 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
18:38:27 <lambdabot> Control.Monad.State.StateT :: newtype StateT s m a
18:38:27 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
18:38:40 <gotaku> dons: Not a pentium 4
18:38:41 <dons> and did yo uuse, -optc-ffast-math -optc-O3 -optc-march=pentium4 -fexcess-precision
18:38:59 <dons>   this stuff will be very sensitive to gcc / cache/ cpu issues
18:39:12 <gotaku> Ok, hold on.
18:41:52 <syntaxfree> hmm. Control.Monad.Reader employs fundeps.
18:42:44 <chessguy> i hate when vi does something mysterious to my code because i accidentally type something which invokes ModuleCodeMangler
18:43:11 <gotaku> dons: Ok, I compiled with those flags and even set march to my old althon-tbird and it's slightly better.
18:43:14 <monochrom> haha, why does it mangle, what is an application of a mangler?
18:43:52 <dons> gotaku: ok. that's good enough for me. i'll double check on a linux/gp4
18:44:06 <chessguy> monochrom, i'm sure it's something useful to those who know more than 3 keystroke-combinations in vi :)
18:44:27 <glguy> chessguy: do you know "diw"?
18:44:28 <gotaku> dons: Though it's about 100% better then the posted entry.
18:44:36 <chessguy> glguy, never heard of it
18:44:47 <glguy> chessguy: delete-in-word
18:44:54 <glguy> deletes the word you are in
18:44:57 <dons> gotaku: right :)
18:45:06 <dons> 4x better here
18:45:18 <dons> 1/4 the runing time
18:45:28 <chessguy> glguy, i'm sure i've accidentally invoked that a few dozen times
18:45:47 <gotaku> dons: Well I don't have an fancy new-fangled instructions to take advantage of ;)
18:46:21 <dons> its really sensitive in the lp loop though. if i tweak it, it goes twice as slowly with little effort
18:46:31 <dons> so gcc is spotting a loop, i think. something down at that level anyway
18:46:44 <chessguy> ?hoogle while
18:46:45 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
18:46:45 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
18:46:45 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
18:46:53 <vincenz> dons: chaotic coding, hmm?
18:47:17 <dons> once you reach a certain point, where its the hardware that dominates the performance
18:47:25 <dons> little things can make a big difference
18:47:37 <dons> avoiding touching the cache in the nsieve-bits is worth 50%
18:48:20 <chessguy> hmm, is there an idiomatic way to do something resembling a while loop when you're in a State monad?
18:48:29 <gotaku> dons: I notice cr is still being calculated every single pixel.
18:48:35 <glguy> so now that you have a decent mandelbrot replacement, how long until haskell moves up on the list?
18:48:40 <dons> gotaku: hmm. looking ...
18:48:43 <siti> chessguy: recurse?
18:48:52 <chessguy> ?hoogle recurse
18:48:53 <lambdabot> No matches found
18:49:02 <dons> glguy: about 12 hour or so
18:49:16 <siti> chessguy: write it tail recursivly:p
18:49:21 <siti> that'll work right?
18:49:36 <chessguy> umm
18:49:47 <dons> gotaku: but how can we avoid recalculating x*2 each time around in gb?
18:50:44 <allbery_b> foo = when someCondition $ do something; foo -- ?
18:50:45 <vincenz> dons: well one option is removing the division
18:50:48 <glguy> > [1 :+ 1 , 2 :+ 2 ..]
18:50:49 <lambdabot>   add an instance declaration for (Enum (Complex a))
18:50:49 <lambdabot>     In an arithmetic seq...
18:50:54 <chessguy> ?hoogle when
18:50:55 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
18:50:55 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
18:50:58 <vincenz> dons: precalculate 2/w
18:50:59 <gotaku> dons: If cr was in an argument we could just add a delta (2.0 / w) to cr every call.
18:51:09 <allbery_b> hm, not sure that flies as written
18:51:12 <vincenz> gotaku: beep :)
18:51:15 <dons> gotaku: oh, hang on, this is much better, 2s faster:
18:51:23 <dons>             where cr = (x + x) / w5
18:51:25 <dons> precalculated         w5 = w - 1.5
18:51:32 <vincenz> dons: what?
18:51:34 <dons> now, can we do better
18:51:39 <allbery_b> foo = when condition (do someWork; foo)
18:51:39 <vincenz> dons: erm..no?
18:51:42 <dons> vincenz: just foating w - 1.5 out :)
18:51:48 <vincenz> x * 2 / w - 1.5   !=  2/(w-1.5)
18:51:53 <dons> oh, oops
18:52:05 <dons> yes, we only get half the plane  then :)
18:52:06 <reilly> Is there a way to read a floating double with the new binary IO package?
18:52:07 <vincenz> I would float out 2/w
18:52:11 <vincenz> that's much bigger
18:52:25 <dons> yeah
18:52:35 <chessguy> allbery_b, you mean do { somework; foo } --?
18:52:36 <gvdm_other> how long does it take for the web page to update?
18:52:44 <dons> gvdm_other: once a day
18:52:52 <dons> reilly: not yet
18:52:59 <allbery_b> chessguy: that too --- there's some weird parsing there, it will work as I wrote it
18:53:03 <dons> (well, you could pack it into a bytestring)
18:53:09 <allbery_b> at least in theory :)
18:53:15 <chessguy> ah. evil do notation strikes again
18:53:25 <allbery_b> the evil happens with let too
18:53:37 <allbery_b> there's a truly evil parsing rule about insertion of braces
18:53:48 <vincenz> dons: additionally I am not certain I agree with the ms loop
18:53:52 <gvdm_other> dons: so this one will be #4?
18:54:05 <vincenz> dons: can I have the latest version for a mod?
18:54:14 <reilly> dons: coerce it to be a double somehow?
18:54:20 <dons> vincenz: yeah, hang on...
18:54:27 <dons> reilly: you could do that
18:54:30 <reilly> dons: I was assuming it would come in on a bytestring
18:54:44 <vincenz> dons: The problem is that you're comparing constantly against y==w instead of pregenerating an array from 0 .. w
18:54:56 <vincenz> s/array/list
18:55:15 <hpaste>  dons pasted "vincenz: mandel" at http://hpaste.org/357
18:55:22 <dons> hmm
18:55:49 <vincenz> hmm...crap...no 6.6
18:56:06 <chessguy> hmm. so i could write while condition action = when condition (do action; while condition action }
18:56:17 <dons> yeah
18:56:19 * vincenz tweaks some and will put it up
18:56:30 <dons> go a p | p == return () | otherwise = a >> go p
18:56:49 <chessguy> except, i'd need to put in there that it has to operate in a State monad, right?
18:57:31 <chessguy> or does the when take care of that?
18:57:40 <allbery_b> when expects a monad
18:58:00 <allbery_b> ?ty when
18:58:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:58:26 <chessguy> ?src when
18:58:27 <lambdabot> when p s = if p then s else return ()
19:00:32 <hpaste>  vincenz annotated "vincenz: mandel" with "small fix (factor out iw)" at http://hpaste.org/357#a1
19:01:18 <chessguy> while :: (Monad m) => Bool -> m a -> m ()
19:02:00 <vincenz> dons: is it possible to make the values in the tuple passed to ms strict?
19:02:13 <hpaste>  gotaku annotated "vincenz: mandel" with "Here is something, but it doesn't work." at http://hpaste.org/357#a2
19:02:45 <dons> vincenz: they're unboxed already
19:02:51 <dons> so they are already strict
19:03:04 <vincenz> ah ok
19:03:13 <gotaku> dons: Ok I just through that together but it doesn't seem to work... though it should.
19:03:40 <dons> weird, that floating out makes it half performance here
19:03:49 <dons> something funny is happening in gcc ...
19:04:09 <dons> need to check on a proper gp4....
19:05:34 <vincenz> gotaku: I see where you are going
19:05:34 <vincenz> dons: what about f, is that strict?
19:05:34 <vincenz> dons: or cr for that matter
19:05:34 <vincenz> (ack lag spike.....0
19:05:46 <vincenz> dons: floating out the iw?
19:05:58 <vincenz> dons: I think I know why
19:06:08 <dons> yeah, its 2x slower on a pentium M, and about 10% sloewr on the Pentium 4
19:06:11 <vincenz> dons: it's lazy so once evaluated a pointer-deref each time
19:06:17 <vincenz> dons: you'll probably have similar issues with cr and f
19:06:29 <hyrax42> which is the compiler project that aims not to include a huge runtime?
19:06:33 <dons> hmm. let me force them then
19:06:33 <hyrax42> yhc?
19:06:38 <dons> yeah
19:06:49 <reilly> ok, I am an idiot.  Where do i find the unsafeCoerce documentation?
19:07:01 <reilly> hoogle won't tell me
19:07:02 <vincenz> dons: actually this means that inlining cr and f should be beneficial :)
19:07:04 <hyrax42> ?index unsafeCoerce
19:07:04 <lambdabot> bzzt
19:07:16 <int-e> ?index unsafeCoerce#
19:07:16 <lambdabot> bzzt
19:07:21 <bd_> Is unsafeCoerce the sort of thing that really /should/ be documented? :)
19:07:24 <vincenz> dons: besides they're always only executed once per callpath, so why pull them out except for readability
19:07:29 <int-e> hehe. GHC.Base but you're on your own using it.
19:07:49 <bd_> also -fglasgow-exts
19:07:51 <bd_> for #
19:07:57 <reilly> well, I need to read binary floats
19:08:03 <Anon4888> Which language holds the record for this contest?
19:08:05 <reilly> and i'm using bytestrngs
19:08:21 <Anon4888> (for this particular problem)
19:08:22 <dons> reilly: there's code on hpaste.org for that
19:08:25 <dons> rei	have a look on the first or second paste I made on hpaste.org
19:08:31 <dons> you have to go back to the very last entries
19:09:33 <hpaste>  vincenz annotated "vincenz: mandel" with "Try this (inlined constants)" at http://hpaste.org/357#a3
19:09:36 <vincenz> dons: try that one
19:09:45 <dons> inling does seem to help
19:09:45 <vincenz> I also removed r2 and i2
19:09:52 <dons> looing...
19:10:25 <dons> and iw has to be strict
19:10:26 <reilly> this one? http://hpaste.org/26
19:10:41 <dons> is it one about readDouble ?
19:11:21 <int-e> aww, binary doesn't have a Binary instance for floats?
19:11:23 <reilly> yeah ... you're calling a stdlib function
19:11:43 <dons> reilly: that's it
19:11:51 <dons> int-e, show me how to pack them portably :)
19:12:22 <hpaste>  dons annotated "vincenz: mandel" with "best so far" at http://hpaste.org/357#a4
19:13:17 <reilly> yeah, it's not what i was looking for.  The file has doubles in it already (as 8 bytes)
19:13:18 <vincenz> dons: that's equivalent to the manually inlined one?
19:13:32 <dons> just checking that.
19:13:54 <slowriot> When I have a function that takes multiple arguments, should I pass them as a tuple, or make a curried function?
19:14:05 <vincenz> dons: heh something like hpaste but then for testing runtimes like this would be neat :)
19:14:06 <gotaku> dons: I'm not getting any variation on these.
19:14:18 <sjanssen> slowriot: curried
19:14:44 <slowriot> sjanssen: thanks, that seems like the standard. Why curried? It's more flexible?
19:14:56 <dons> gotaku: i think your hardware is funny ;)
19:15:10 <sjanssen> slowriot: you can partially apply curried functions, which is often handy
19:15:20 <sorear> tellfodder
19:15:51 <slowriot> sjanssen: ah, thought so
19:15:56 <slowriot> sjanssen: thanks
19:15:59 <sjanssen> I'm seeing a slight improvement with vincenz's version
19:16:12 <dons> vincenz: yeah, same result when inlined, or maybe tiny tiny bbit better
19:16:17 * vincenz nods
19:16:30 <vincenz> dons: might be a tradeoff there cause I included more computation with r2 and i2
19:16:36 <vincenz> dons: let me rewrite some more :)
19:16:50 <sjanssen> 15.6s for the original bytestring version vs. 15.2s for vincenz's
19:16:52 <vincenz> dons: for instance ... bw is not inlined
19:16:57 <sjanssen> when n = 1000
19:17:01 <dons> inlining iw makes it worse
19:17:03 <sjanssen> s/1000/5000
19:17:17 <vincenz> dons: ok strictifying then, strictify bw too
19:17:19 <dons> ah right. good
19:17:22 <dons> yes, we need large N now
19:17:29 * vincenz should get 6.6
19:18:36 <vincenz> Igloo: do the debian versions work for ubuntu you think?
19:18:59 <hpaste>  dons annotated "vincenz: mandel" with "best for me so far" at http://hpaste.org/357#a5
19:19:01 <dons> sjanssen: can you check the above is fastest ^^
19:19:17 <vincenz> sjanssen: wait
19:19:22 <dons> hmm, now mayne uncheckedShiftL will win...
19:19:24 <vincenz> sjanssen: before you do, rewrite bw = ... to !bw = ...
19:19:39 <vincenz> bw is used for every pixel, thats N*N pointer derefs
19:19:51 <nrb23> yargh.. has anyone tried using the pcap library?
19:20:06 <sjanssen> vincenz: strictifying bw actually made it a bit slower
19:20:16 <vincenz> hmm, odd
19:20:21 <dons> !bw seems better again
19:20:37 * vincenz is going to remove i2 and r2 ;)
19:20:50 <vincenz> is there a penalty for going from 4 args to 6 args functions?
19:21:02 <dons> depends...
19:21:08 <dons> its hard to say
19:21:10 <sjanssen> miniscule, I'd reckon
19:21:13 <gotaku> You guys know that the x==w line in gb is pointless right?
19:21:14 <vincenz> nod
19:21:20 <dons> note, most time is spent in lb
19:21:26 <vincenz> dons: lp
19:21:27 <dons> gotaku: ah.
19:21:32 <vincenz> dons: hence me wanting to remove r2 and i2
19:21:47 <sjanssen> dons latest paste is very slightly faster than vincenz's latest paste over here
19:21:48 <dons> gotaku: hmm?
19:21:51 <gotaku> Hence bw is also pointless.
19:22:06 <dons> gotaku: so what, kill that line completely?
19:22:18 <vincenz> gotaku: why is it pointless?
19:22:26 <vincenz> gotaku: bw can not be pointless!
19:22:31 <vincenz> gotaku: it defines the end of your list of pixels
19:22:43 <vincenz> erm wait, no that's w
19:22:46 * vincenz shuts up
19:22:48 <gotaku> dons: That still is for padding input sizes that are non-divisible by 8
19:22:55 <gotaku> THat stuff rather.
19:23:10 <dons>  oh. right.
19:23:12 <gotaku> The problem is that all the input sizes for the shootout are divisible by 8 by design.
19:23:17 <dons> which we're not tested on.
19:23:19 <vincenz> gotaku: ah interesting :)
19:23:23 <sjanssen> I can confirm that removing the x == w line did not change the output for n=3000
19:23:51 <vincenz> gotaku: so also remove the line of bx == bw?
19:24:22 <gotaku> vincenz: no... Well yes but you can't just remove it.
19:24:28 * vincenz nods
19:24:50 <dons> hmm. seems to run a tad slower after removing x == bw
19:24:55 <dons> that's odd
19:25:14 <int-e> dons: oh you want the resulting output to be portable, too, tricky.
19:25:20 <gotaku> You can replace the bx == bw line with: x == w = ms (0, y+1, (y+1) * 2.0 / w - 1.0)
19:25:56 <vincenz> gotaku: that's missing one parm
19:26:04 <gotaku> Although dons says this runs slower for some reason.
19:26:25 <vincenz> gotaku:  you mean (1,0, ..._) right?
19:27:12 <gotaku> vincenz, Yes but I also removed the bw param from the ms definition.
19:27:23 <vincenz> yes
19:27:28 <gotaku> You can see it here: http://hpaste.org/349
19:27:38 <vincenz> ah i see
19:29:21 <slowriot> I'm confused about Map.lookup
19:29:30 <vincenz> sjanssen: coming up with a new version
19:29:31 <slowriot> it returns a value with a monad type
19:29:45 <allbery_b> :t Map.lookup
19:29:46 <lambdabot> Couldn't find qualified module.
19:29:51 <bd_> :t M.lookup
19:29:53 <lambdabot> Couldn't find qualified module.
19:29:53 <slowriot> but it doesn't say which kind of monad
19:29:58 <allbery_b> :t Data.Map.lookup
19:30:00 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
19:30:02 <bd_> slowriot: It's any monad
19:30:05 <sjanssen> slowriot: it can result in any monadic type
19:30:06 <bd_> slowriot: Your choice :)
19:30:21 <slowriot> if it were an argument, it would be inferred
19:30:26 <slowriot> how do I tell it which type?
19:30:30 <sjanssen> slowriot: you probably just want to do "case lookup k m of Nothing -> stuff; Just v -> otherstuff"
19:30:37 <sjanssen> that will force it to be nothing
19:30:48 <sjanssen> s/nothing/Maybe
19:30:49 <slowriot> oh, I see
19:30:55 <bd_> slowriot: Either give it enough to infer the type, eg, using it as a Maybe or something, or in the very rare case that it isn't, use an explicit type signature
19:30:57 <hpaste>  vincenz annotated "vincenz: mandel" with "gotaku's suggestion + strictified iw and used in BOTH places + strictified i2 and r2" at http://hpaste.org/357#a6
19:30:57 <allbery_b> it calls the monad's fail if not found.  so, for Maybe it's Nothing, for [] it's [] (vs. [result]), Either String a gets Right result or Left errormsg, in IO it raises an exception, etc.
19:31:02 <vincenz> sjanssen: try that one?
19:31:02 <bd_> and case with Maybe is usually not nice :)
19:31:03 <bd_> :t fromMaybe
19:31:05 <lambdabot> forall a. a -> Maybe a -> a
19:31:05 <bd_> :t maybe
19:31:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:31:12 * vincenz hopes he doesn't have bus
19:31:14 <vincenz> +
19:31:14 <vincenz> g
19:31:26 <bd_> ^^^ use one of those instead of a case
19:32:26 <vincenz> actually you can strictify i2 and r2 without increasing the number of funargs by turning it into a nested if with a let up front, but ok
19:32:45 <vincenz> shoot
19:32:45 <vincenz> bug
19:33:18 <sorear> so it takes an entire committee to write fast haskell? :p
19:33:29 <hpaste>  vincenz annotated "vincenz: mandel" with "previous but bugfree" at http://hpaste.org/357#a7
19:34:19 <dons> sorear: to get the last 1%, yeah :)
19:35:11 <siti> :D
19:35:26 <sjanssen> vincenz: extra paren on 28
19:35:27 <vincenz> btw, since I joined late, why are the pixels processed by 8?
19:35:38 <vincenz> sjanssen: thx
19:35:48 <sjanssen> and the code doesn't typecheck after that fix
19:35:53 * vincenz sighs
19:36:05 <vincenz> ok
19:36:13 <vincenz> sjanssen: on lp?
19:36:42 <sjanssen> the number of args in lp's type signature is wrong
19:36:52 <vincenz> sjanssen: cause I bugfixed it after
19:36:58 <vincenz> sjanssen: the bug was in the last 2 lines
19:37:00 <vincenz> should be
19:37:04 <vincenz>           i' = ((r+r)*i+ci)
19:37:04 <vincenz>       in lp r' (r'*r') i' (i'*i') cr ci (k-1)
19:37:15 <vincenz> with a ! on i'
19:37:40 * vincenz is gonna focus on installing 6.6
19:37:57 <dons> that looks like the same code to me.
19:38:01 <sjanssen> vincenz: that's exactly what I've got here
19:38:08 <dons> and it doesn't type check :)
19:38:09 <sjanssen> you didn't update the type sig of lp
19:38:15 * vincenz palmslaps
19:38:16 <gvdm_other> how much faster is this version of mandel over the one on shootout?
19:38:31 <sjanssen> the type sig says 5 args, defn. says 7
19:38:35 <vincenz> yeah
19:38:38 <vincenz> forgot the typesig :/
19:39:13 <vincenz> two more doubles
19:39:23 <sjanssen> okay, the algorithm is still correct
19:39:43 <vincenz> it's just gotaku's with strictified iw and r2 and i2
19:40:03 <bos> C1an2001
19:40:11 <bos> heh.
19:40:38 <sjanssen> vincenz: slower
19:40:49 * sjanssen suspects the recursion in ms
19:40:54 * vincenz nods
19:41:37 <sjanssen> dons: won't that make the unfoldr loop slower?
19:41:54 <dons> i think so, yes. it'll break specConstr
19:42:01 <dons> so ghc won't be able to generate as nice a loop
19:42:03 <sjanssen> too bad Data.ByteString.FusionStreams isn't in base-2.0 :)
19:42:17 <sjanssen> ms could be rewritten as a stream producer
19:42:22 <dons> right
19:42:26 <coffee-mug> hey guys
19:42:31 <coffee-mug> I just finished a Haskell article
19:42:35 <coffee-mug> article/tutorial
19:42:44 <coffee-mug> could you take a look?
19:42:48 <coffee-mug> http://www.defmacro.org/ramblings/haskell-web.html
19:42:49 <lambdabot> Title: Haskell and Web Applications
19:43:07 <hpaste>  vincenz annotated "vincenz: mandel" with "no recursion in ms but with other changes kept" at http://hpaste.org/357#a8
19:43:08 <dons> it still runs slower when I remove the | x == w    = b `shiftL` n
19:43:08 <dons>  line
19:43:18 <vincenz> \o/ for lag
19:43:20 <dons> vincenz: have you checked it compiles and runs faster?
19:43:57 <vincenz> dons: compiling 6.6 as we speak
19:44:00 <dons> coffee-mug: sure!
19:44:28 <vincenz> dons: compile-wise it should work fine, it's the earlier code just with two extra 0's for lp and the new version of lp
19:45:08 <vincenz> on another note, the whole lp loop seems silly
19:45:11 <vincenz> it starts with 0
19:45:18 <vincenz> for which the first two conditions will never be true
19:45:24 <sjanssen> vincenz: missing part of the tuple on line 34
19:45:24 <vincenz> might want to jumpstart it one iteration later
19:45:33 * vincenz groans
19:45:39 <vincenz> ok, until I have 6.6 I'm no longer pasting
19:45:49 <hpaste>  dons pasted "Don't post it unless its faster than this :-)" at http://hpaste.org/358
19:46:05 <vincenz> dons: you missed the second iw
19:46:10 <vincenz> on the second line of ms
19:46:11 <coffee-mug> dons: I think the rumors that you're really five or six clones is true
19:46:12 <malsyned> Is there a utility which, given a call to a function with particular arguments, will expand that call into the definition with those arguments substituted?
19:46:16 <dons> that's the fastest version i've been able to get.oh, yes.
19:46:27 <malsyned> Haskell seems like one of the few languages where that sort of tool would be straightforward.
19:46:33 <dons> coffee-mug: we prefer the term 'cylon'
19:46:50 <Pseudonym> Actually, a bunch of us are remote-controlling dons.
19:46:54 * vincenz is pretty sure that r2 and i2 like that are awful
19:46:58 <coffee-mug> malsyned: you could easily write one using haskell's parser/pretty printer libraries
19:47:03 <dons> vincenz: have you checked the core
19:47:05 <bd_> Pseudonym: Is that like wiki IRC?
19:47:10 <dons> vincenz: why would it be bad, by the way?
19:47:16 <dons> malsyned: so just inlining?
19:47:20 <vincenz> dons: they're lazy variables
19:47:25 <Pseudonym> Something like that.
19:47:28 <vincenz> dons: so you're doing an extra pointer-deref
19:47:39 <malsyned> dons: yeah.  basically.  but in a way that made it readable.  maybe doing an unpoints conversion at the same time.
19:47:53 <dons> vincenz: not once the strictness analyser hits the code
19:47:53 <dons> but i'll double
19:47:54 <dons> check ....
19:47:56 <coffee-mug> malsyned: may be not TOO easy because you'll have to handle quite a few constructors
19:48:08 <coffee-mug> but it's still pretty simple
19:48:16 <vincenz> dons: why then did we get gains by strictifying iw and bw?
19:48:22 <coffee-mug> it's in Language.Parser I think
19:48:37 <dons> the strictness analyser isn't perfect :)
19:48:51 <malsyned> coffee-mug: oh, good point.  You think that could be simplified by always rewriting pattern-matching form definitions into simple definitions with a case statement on the right side?
19:48:55 <hpaste>  gotaku annotated "Don't post it unless its faster than this :-)" with "Very small change" at http://hpaste.org/358#a1
19:49:01 <vincenz> dons: I'm planning a major rehaul of lp
19:49:19 <dons> the second iw helped a tiny bit
19:49:29 <dons> (i guess its a 1 instructoin per loop improvement :)
19:49:30 <sorear> if dons is so open about being not-a-human, why does he deactivate 8hrs a day?
19:49:37 <vincenz> dons: woo, I get my name in there for adding iw :P
19:49:45 <gotaku> dons: I changed (y+1)*2/w-1) to iw+ci
19:49:47 <allbery_b> how do you knmow he's deactivated?
19:49:49 <malsyned> My thinking is this: the fact that haskell (and functional languages in general) give you so much power to remove patterns from code is a double-edged sword, and a tool like that could be very useful in understanding source code that used unfamiliar higher-order functions.
19:49:49 <siti> -funfolding-use-threshold1000 <-- that'll make you win ;)
19:49:55 <dons> gotaku: ok.
19:49:57 <sjanssen> dons: so any idea why removing that x == w line makes it slower?
19:50:08 <dons> no idea.
19:50:08 <dons> its very strange.
19:50:15 <dons> maybe it shrinks the size of the expression so it gets inlined badly?
19:50:24 <dons> or changes the default branch on the loop?
19:50:27 <vincenz> gotaku: that's incorrect
19:50:42 <gotaku> vincenz: What is?
19:50:42 <vincenz> gotaku: it should be (y+1)*iw -1
19:50:46 <sjanssen> the x == w is actually taken
19:50:53 <coffee-mug> malsyned: well, GHC rewrites that stuff anyway
19:50:54 <gvdm_other> Having some idea of what the compiler is doing would be useful, what profiling tools are you guys using?
19:50:55 * vincenz ponders
19:50:56 <vincenz> never mind
19:50:57 <sjanssen> insert branch in that statement ;)
19:51:04 <Pseudonym> coffee-mug++  -- Scrapped boilerplate, HTML combinators, pretty typeclass generics... what more could you need?
19:51:05 <coffee-mug> malsyned: its been a while since I looked at that library
19:51:28 <hpaste>  dons annotated "Don't post it unless its faster than this :-)" with "current best" at http://hpaste.org/358#a2
19:51:31 <gotaku> vincenz: Actually it passes the diff test. It works fine.
19:51:36 <vincenz> ok
19:51:44 <dons> gvdm_other: ghc -prof -auto-all
19:51:52 <dons> the rather excellent ghc profiler :)
19:51:53 <rc-1> http://blog.tmorris.net/folds-for-imperative-programmers/
19:51:55 <lambdabot> Title: Î» Tony&#8217;s blog Î» Â» Blog Archive Â» Folds for Imperative Programmers
19:51:56 <coffee-mug> Pseudonym: yeah, the article was a little longer to handle collections but I cut it
19:52:04 <gotaku> vincenz: I would somehow like to do the same with cr
19:52:10 <coffee-mug> that work wasn't really complete and I didn't want to confuse/scare people
19:52:16 <malsyned> coffee-mug: I'm sure compilers do all of these transformations internally, but I'm imagining they'd be a pretty useful pedagogical tool if they could be performed at the source level, like in an IDE.  I'm just daydreaming and riffing on some ideas that I got from this article on reddit.
19:52:19 <malsyned> http://cs.uni.edu/~wallingf/blog/archives/monthly/2007-02.html#e2007-02-05T20_46_38.htm
19:52:20 <vincenz> gotaku: *nods*
19:52:24 <lambdabot> Title: Knowing and Doing: February 2007 Archives, http://tinyurl.com/2gurja
19:52:37 <vincenz> as soon as I get 6.6 going I want to do some major changes :/
19:52:43 <coffee-mug> malsyned: but you could see the product of GHC's desugaring
19:52:47 <vincenz> but compiling 6.6 is taking ages
19:52:57 <coffee-mug> I'm just not sure about the flags
19:53:03 <gotaku> gb would work alot better if it built whole lines and not just bytes.
19:53:04 <dons> malsyned: hmm, yes, an inlining pugin for lambdabot would be nice
19:53:36 <malsyned> dons: lambdabot is an IDE trapped in an IRC bot's body ;-)
19:54:00 <sjanssen> gotaku: building by lines may be against the rules
19:54:01 <dons> it is.
19:54:04 * allbery_b has actually had that thought seriously
19:54:14 <sjanssen> we're already stretching it by using ByteString.putStr
19:54:20 <gotaku> I had a version that used nested unfoldr calls to build a list of bytestrings but I couldn't get it to work correctly.
19:55:36 <sorear> would it be legal/productive to use hs-plugins to inline the size of the image? (muahaha)
19:55:43 <vincenz> anyone can give me an estimate for the time it takes to compile 6.6?
19:55:58 <sorear> 90 min <-- for HEAD + extralibs
19:56:02 <dons> between 3 minutes and 90 minutes
19:56:08 <vincenz> alright, thanks
19:56:13 <sorear> 6.6 / 6.7 , close enough :)
19:56:18 <dons> here,   ghc = 90 / cores
19:56:20 <allbery_b> several hours on my lame osx/ppc :)
19:56:25 <sorear> dons: 3 minutes? from a cold tree?
19:56:26 * vincenz just downloaded the 6.6 targz from the ghc site
19:56:41 <sorear> dons: I'd only heard you got it down to 8 minutes, not 3
19:56:43 * vincenz is using a centrino....
19:56:43 <dons> sorear: i'm speculating based on 7 mins for 4 cores
19:56:51 <sorear> you need to update your blog!
19:56:51 <dons> sorear: to what happens if I use 16
19:56:51 <rc-1> 6.7? whens that come out sorear
19:56:54 <vincenz> dons: I have a single core laptop
19:57:07 <dons> 30+ hours on a m68k
19:57:08 <sorear> rc-1: never
19:57:28 <sorear> (have you actually tried on your new 16-core box?)
19:57:38 <sorear> (is your 16-core box unboxed yet?)
19:57:40 <vincenz> anyone have a box with 6.6 I could ssh to to test ?
19:57:42 <dons> its still in a box :)
19:57:51 <vincenz> while I wait for this to compile
19:58:18 <sorear> does it run on a standard 15-amp (or whatever the number is in .au) circuit? :p
19:58:18 <allbery_b> rc-1: 6.7 is a devel branch.  release will be 6.8, whenever that happens
19:58:31 <sjanssen> case (Cardboard# donsBox#) -> donsBox#
19:58:53 <vincenz> sjanssen: it seems he forgot to strictify his function
19:59:35 <rc-1> allbery_b, ah i see :) any really neat things to look forward to in it?
19:59:37 <dino-> I'm starting to wonder if I'm using the wrong API for this. I need to take an HTML document and product a plain text file from some of its content..
19:59:39 <bos> is there a list function that lets me chunk the list on an arbitrary predicate?
19:59:55 <bd_> @hoogle [a] -> (a -> Bool) -> [[a]]
19:59:55 <allbery_b> :t groupBy
19:59:55 <lambdabot> No matches, try a more general search
19:59:57 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
19:59:59 <allbery_b> oops
20:00:01 <dino-> I seem to only be able to produce another structured (like XML) document ith HaXml. Not plain old text.
20:00:04 <bd_> I was close :)
20:00:13 <allbery_b> oh, I was right, just interleaved :)
20:00:14 <dons> coffee-mug: could you use hscolour to pretty print the haskell code coloured?
20:00:27 <dons> coffee-mug: hscolour can generate css-ified markup
20:00:35 <glguy> !pate
20:00:36 <glguy> !paste
20:00:37 <hpaste> Haskell paste bin: http://hpaste.org/
20:00:41 <allbery_b> rc-1: what I know of:  ghci has a debugger; ByteString is overloaded, so you can use it directly instead of having to convert literal strings
20:00:57 <allbery_b> I'm sure there is more but I'm still kinda new to it
20:01:00 <dons> e.g. as we do in hpaste, http://hpaste.org/358
20:01:06 <rc-1> debugger :))))
20:01:10 <sjanssen> associated types are in HEAD too
20:01:23 <gotaku> Can you put function definitions  in a where expression?
20:01:24 <sorear> and System FC
20:01:29 <sorear> yes!
20:01:30 <vincenz> gotaku: yes
20:01:31 <dons> gotaku: of course
20:01:37 <gotaku> Hm..
20:01:45 <gotaku> I'm getting an error for some reason
20:01:52 <vincenz> gotaku == Trevor Mccort?
20:02:04 <gotaku> vincenz: Yes.
20:02:14 <sorear> gotaku: !paste it!
20:02:26 <sorear> or @paste, your choice :)
20:02:41 <sjanssen> @taste
20:02:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:03:19 <glguy> @waist
20:03:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:03:24 <slowriot> Does does maybe use >> and >>=?
20:03:31 <allbery_b> it can
20:03:41 <slowriot> what does it do?
20:03:42 <vincenz> anyone have a box with 6.6 I can ssh to?
20:03:51 <allbery_b> ?src Maybe (>>=)
20:03:51 <lambdabot> (Just x) >>= k      = k x
20:03:52 <lambdabot> Nothing  >>= _      = Nothing
20:03:56 <slowriot> woah
20:04:03 <hpaste>  dons pasted "Best effort. I'll submit this..." at http://hpaste.org/359
20:04:14 <allbery_b> basically causes Nothing to shortcircuit through a computation, while passing through actual (Just) values
20:04:14 <dons> i'm thinking i'll submit this ^^ and have some lunch
20:04:21 <dons> and then if we do any better, we can submit that later
20:04:22 <sorear> I have 6.6, 6.4.2, and HEAD.  no public ssh :(
20:04:22 <vincenz> dons: k, I'll get back to you soon
20:06:08 <malsyned> dons: if you or anyone else finds themselves sufficiently motivated to write that inlining plugin, the inverse operation would also be an interesting discovery tool.  You give some hacked up recursive function and it shows you how to write it in one line with foldr.  I imagine this would be considerably harder, though.
20:06:11 <dons> i get N=3k, in 7s on my laptop
20:06:16 <dons> so that's pretty good
20:06:35 <sorear> malsyned: we have the latter
20:06:45 <malsyned> sorear: yeah?  how do I do it?
20:06:50 <sorear> malsyned: it's rather unmaintained however :(
20:06:52 <vincenz> dons: as soon as I have my 10% gain I'll concact you :P
20:06:53 <sorear> malsyned: @pl
20:07:10 <sorear> @pl let foo x = x : foo x
20:07:10 <lambdabot> (line 1, column 22):
20:07:11 <lambdabot> unexpected end of input
20:07:11 <lambdabot> expecting variable, "(", operator, ":", "++", ";" or "in"
20:07:14 <sorear> @pl let foo x = x : foo x in foo
20:07:15 <lambdabot> fix (ap (:))
20:07:16 <malsyned> really?  @pl will go that far?  that's awesome.
20:07:39 <sorear> malsyned: it doesn't work extremely well
20:08:12 <dons> so by my calculatoin that should run at around 14.75s on the shootout box
20:08:14 <malsyned> it's better at it than I am ;)
20:08:17 <sorear> it's also not smart enough to generate code in the full lambda calculus
20:08:21 <dons> putting us at around 4x C
20:08:23 <dons> instead of 20
20:08:29 <sorear> it only uses the CL subset
20:09:34 <slowriot> ?src Maybe (>>)
20:09:35 <lambdabot> (Just _) >>  k      = k
20:09:35 <lambdabot> Nothing  >>  _      = Nothing
20:11:55 <bd_> :t maybe
20:11:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:12:06 <bd_> ?check \m f -> m >> (f :: Int -> Maybe Int) == maybe Nothing f m
20:12:07 <lambdabot>  Couldn't match `Int -> Maybe Int' against `Maybe a'
20:12:09 <slowriot> suppose that I want to see the source code to some standard function, but I don't want to annoy #haskell by asking lambdabot. Where do I look?
20:12:13 <bd_> ?check \m f -> m >>= (f :: Int -> Maybe Int) == maybe Nothing f m
20:12:14 <lambdabot>  Couldn't match `Int -> Maybe Int' against `Maybe a'
20:12:21 <coffee-mug> dons: I can use hscolor, I just didn't know about it
20:12:49 <coffee-mug> I could also use emacs' htmlize-buffer
20:13:01 <sorear> dons: sequence $ map $ zip3 [0..]  @ StateT IO is *slow*
20:13:11 <coffee-mug> I'm gonna look into producing prettier pages :)
20:13:19 <sorear> dons: vty has doubled in speed with an explicit loop
20:13:20 <sorear> doubled!
20:13:22 <bd_> ?check \m f -> (m >>= (f :: Int -> Maybe Int)) == maybe Nothing f m
20:13:23 <lambdabot>  OK, passed 500 tests.
20:13:42 <vincenz> @type shiftL
20:13:43 <lambdabot> forall a. (Bits a) => a -> Int -> a
20:13:57 <bd_> ?djinn (Maybe a) -> (a -> Maybe b) -> Maybe b
20:13:58 <lambdabot> f a b =
20:13:58 <lambdabot>     case a of
20:13:58 <lambdabot>     Nothing -> Nothing
20:13:58 <lambdabot>     Just c -> b c
20:14:05 <bd_> clever
20:14:05 <dons> sorear: great!
20:14:17 <slowriot> is there anywhere I should look for source, or should I just use lambdabot?
20:14:28 <bd_> slowriot: the library documentation has links to the source code
20:14:30 <bd_> ?docs
20:14:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:14:50 <slowriot> ah, cool
20:15:21 <TomMD> slowriot: darcs get darcs.haskell.org/ghc-6.6 (or whatever that url) will give you all the src to ghc - more than you will get through.
20:15:24 <thedward> slowriot: you can also /msg lambdabot with your requests if you don't want to disturb the channel
20:15:38 <dons> coffee-mug: tom moertel blogged about hscolour and blog integration: http://blog.moertel.com/articles/tag/haskell
20:15:45 <lambdabot> Title: Tom Moertel's Weblog - tag haskell
20:16:17 <dons> sjanssen, gotaku submitted: https://alioth.debian.org/tracker/index.php?func=detail&aid=304446&group_id=30402&atid=411646
20:16:18 <lambdabot> http://tinyurl.com/2fdf3o
20:16:48 <dons> now, onto nbody and spectral norm!
20:17:10 <coffee-mug> dons: cool, I'll take a look
20:17:11 <gotaku> dons: I'm trying one last thing with mandelbrot but it probably won't work.
20:17:12 <coffee-mug> thanks
20:22:46 <bos> how does one construct a list lazily, while being able to guarantee that nobody will be able to consume any of it until it's entirely constructed?
20:23:21 <bd_> Isn't the point of laziness to allow it to be consumed before it's fully constructed?
20:23:34 <dons> bos, hmm?
20:23:40 <dons> construct it strictly perhaps :)
20:23:42 <bos> well, in this case, the list contains elements that have forward pointers to other elements of the list.
20:23:49 <allbery_b> more specifically that it's consttructed as it's needed
20:23:59 <bos> i.e. the head might contain a structure that refers to list!!3
20:24:14 <bd_> bos: If they're forward pointers you shouldn't have to worry about loops
20:24:21 <sorear> bos: that's perfectly safe!
20:24:29 <sorear> bos: laziness rocks
20:24:57 <dons> yeah, i don't see what the problem is.
20:25:06 <dons> the list results will be demanded as needed
20:25:18 <bos> it doesn't seem to be safe. if i try to print the list, i get an "index too large" error.
20:25:34 <dons> sounds like an algorithm bug
20:25:38 <hpaste>  bos pasted "silly example" at http://hpaste.org/360
20:25:44 <sjanssen> bos: you aren't doing anything nasty with unsafePerformIO?
20:25:49 <bos> no, nothing odd.
20:25:53 <allbery_b> something is wrong then, it should be generating the list as nmeeded to satisfy it
20:26:02 * allbery_b lets the experts figure it out
20:26:15 <bd_> bos: ns !! s <-- this is referring to  thefirst part of the list, not the concatenated list
20:26:18 <bos> so run the example i just pasted with "runhaskell Silly.hs n1,2 lfoo lbar" and watch it barf
20:26:25 <bd_> bos: you can use a let-binding if you want it to refer to the full list
20:26:50 <dons> yeah
20:27:00 <dons> you want to refer to the full result
20:27:06 <svref> What's the most specific supertype of Float and Double?
20:27:19 <dons> Floating a => a ?
20:27:28 <dons> ?instances Floating
20:27:29 <lambdabot> Double, Float
20:27:45 <bos> hmm, ok
20:27:48 <svref> Thanks.  Man, I've been in JavaScript land and its melted my brain.
20:28:03 <dons> is the input just strings of ' and 'n' bos?
20:28:08 <dons> of 'l'
20:28:12 <bos> dons, yes.
20:28:29 <bos> i.e. "n1,2","lfoo","lbar"
20:28:48 <sorear> dons: RealFloat - Floating includes Complex Double
20:29:06 <sorear> dons: RealFloat also includes CDouble CFloat and CLDouble ...
20:29:22 <sorear> RealFloat is simply ordered, Floating isn't
20:29:25 <bos> bd_: i can't say i really understood your answer.
20:30:04 <hpaste>  bd_ annotated "silly example" with "untested: using let-binding to refer to our answer" at http://hpaste.org/360#a1
20:30:09 <bd_> bos: see paste :)
20:30:47 <dons> parse ns (c:cs) = case c of
20:30:47 <dons>     'l' -> let rest = ns ++ [Node [rest !! s | s <- map read (chunkWith (==',') cs)]]
20:30:50 <bos> bd_: didn't work.
20:30:50 <dons>            in rest
20:30:52 <dons> ?
20:30:54 <dons>     'n' -> ns ++ [Leaf (dropWhile isSpace cs)]
20:31:14 <bd_> bos: Can you give some sample input?
20:33:32 <bos> bd_: simply "runghc" "n1,2" "lfoo" "lbar"
20:33:46 <bos> but you'll need to change the module name from Silly to Main in the source
20:34:01 <bos> and dons's suggested change didn't work, either.
20:34:09 <vincenz> damn this is slow
20:35:02 <bos> but if you run it with "runghc" "Silly.hs" "lfoo" "lbar" "n0,1" it is fine.
20:35:02 <bd_> oh, I think I see...
20:35:38 <bd_> @hoogle fix
20:35:38 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
20:35:39 <lambdabot> Control.Monad.Fix :: module
20:35:39 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:35:55 <bos> so evidently print wants to pull on the first item on the list before the runtime has constructed the rest of the list.
20:36:10 <scw> @hoogle Void
20:36:11 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
20:36:12 <lambdabot> System.Win32.Types.LPVOID :: type LPVOID
20:36:12 <lambdabot> System.Win32.Types.MbLPVOID :: type MbLPVOID
20:36:36 <hpaste>  bd_ annotated "silly example" with "'fix'ed" at http://hpaste.org/360#a2
20:36:57 <hpaste>  bd_ annotated "silly example" with "wrong paste" at http://hpaste.org/360#a3
20:37:02 <bd_> there we go
20:37:12 <bd_> bos: You were using the wrong list :)
20:37:38 <bd_> bos: since you're folding, ns refers to the list of all the itemps before you
20:37:50 <dons> bos, that's not the problem. if the print wants more of the list, the rts computes it :)
20:37:53 <dons> ah righty
20:37:55 <bd_> in fact, folding's probably the wrong action...
20:38:39 <hpaste>  bd_ annotated "silly example" with "map is better" at http://hpaste.org/360#a4
20:38:48 <bos> bd_: oh!
20:38:59 <dons> cool
20:38:59 <dons> $ runhaskell A.hs "n1,2" "lfoo" "lbar"
20:38:59 <dons> [Node [Leaf "foo",Leaf "bar"],Leaf "foo",Leaf "bar"]
20:39:27 <vincenz> dons: how long does stage2 take wrt stage 1?
20:39:32 * dons wonders how on earth you'd write this ccode in any other language ...
20:39:42 <bd_> dons: A second fixup pass?
20:40:01 <bd_> bos: I can sort of see what you meant to do with the fold, but it's better to just say what you mean to do directly, no? :)
20:40:03 <dons> yeah i guess that' s the usual way. much cuter to refer to results from the future though :)
20:40:23 <bd_> bos: Also, maybe an array would be faster...
20:40:52 <bos> oh, sure. i just wanted to get the basic idea right.
20:41:01 <Cale> what's this?
20:41:01 <bos> pardon my silence. i'm contemplating Monad.Fix.fix
20:41:12 <dons> ?src fix
20:41:13 <lambdabot> fix f = let x = f x in x
20:41:29 <sorear> bos: mfix is cooler
20:41:32 <Cale> fix f = f (fix f)
20:41:33 <vincenz> sjanssen: you have any idea how long stage2 takes wrt stage1?
20:41:40 <dons> the essence of referring to your own result :)
20:41:45 <dons> vincenz: hmm. not as long
20:41:54 <sorear> > fix ( (1:) . scanl1 (*) )
20:41:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:42:00 <Cale> Why does src give such odd versions of things? That fix isn't so bad, but many things have strange implementations.
20:42:01 <sorear> > fix ( (1:) . scanl1 (+) )
20:42:03 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
20:42:06 <Cale> @src sequence
20:42:07 <lambdabot> sequence ms = foldr k (return []) ms
20:42:07 <lambdabot>     where
20:42:07 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
20:42:10 <Cale> like that.
20:42:12 <sorear> > fix ( (1:) . scanl (+) 1 )
20:42:13 <dons> Cale, it gives the defns as they appear in base/
20:42:13 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:42:28 <Cale> dons: ah. base is written strangely then :)
20:42:40 <vincenz> > fix dons' code
20:42:41 <lambdabot>   Not in scope: `code'
20:42:43 <sorear> bos: fibonacci: ^^
20:42:46 <Cale> sequence = foldr (liftM2 (:)) (return [])
20:42:51 <dons> the implementatoin of fix with let is fairly intuitive though
20:43:11 <hpaste>  bd_ annotated "silly example" with "arrows and arrays and laziness, oh my" at http://hpaste.org/360#a5
20:43:14 <sjanssen> lliftM2 isn't in scope in the Prelude
20:43:15 <dons> hehe
20:43:17 <bos> sorear: sure, i've seen fib defined in terms of fix.
20:43:22 <vincenz> dons: it recompiles everything for stage2?
20:43:25 <sorear> and Cale's is wrong, while @src is correct.
20:43:31 <Cale> sorear: huh?
20:43:34 <svref> {- how to make this work? -}
20:43:34 <dons> vincenz: no.
20:43:34 <svref> class JSON a where toJSON :: a -> String
20:43:34 <svref> instance JSON String {- String is type synonym-} where toJSON s = show s
20:43:47 <bd_> bos: fix passes a function's return value to itself :)
20:43:52 <dons> svref: with a newtype
20:44:05 <dons> oh, hang on. no, -fglasgow-exts will do
20:44:09 <sjanssen> @type foldr (liftM2 (:)) (return [])
20:44:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:44:16 <bos> bd_: sure.
20:44:17 <Cale> I suppose that liftM2 isn't in scope in the Prelude, that's fine. (Though probably all the stuff in Control.Monad ought to be in scope in the Prelude)
20:44:33 <dons> you just want to match a type synonym in an instance , so yeah, -fglasgow-exts
20:44:37 <bos> well, thanks for the help, bd_ and dons in particular! and sorear, too.
20:44:39 <sorear> Cale: GHC ought to handle recursive modules. (and packages)
20:44:53 <svref> dons: newtype is pesky because I have to explicitly convert from String to String', right?
20:44:57 <bos> i knew i was barking up the right tree, at least.
20:44:58 <Cale> sorear: How is my implementation wrong?
20:45:16 <sorear> Cale: it makes far too many passes over the input
20:45:33 <Cale> uhh, if so, then so does the @src version
20:45:39 <Cale> They're equal.
20:45:47 <sorear> fix (1:)  consumes finite space with @src's fix, infinite space with Cale's fix
20:45:52 <bd_> ?instances MonadFix
20:45:53 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:45:57 <Cale> I didn't write fix
20:46:03 <Cale> er, I did
20:46:10 <Cale> fix f = f (fix f)
20:46:27 <vincenz> that should work fine
20:46:32 <vincenz> (1:) (fix (1:))
20:46:40 <sorear> fix (1:) = 1 : fix (1:) = 1 : 1 : fix (1:) = ... infinite conses (lazy of course)
20:46:40 * vincenz peers at sorear 
20:46:41 <bd_> Cale: Isn't that possibly less efficient than binding the result?
20:46:56 <sorear> fix f = let x = f x in x
20:46:58 <bd_> Cale: After all, it's not required that the inner (fix f) share space with the outer
20:47:00 <vincenz> > let foo f = f (foo f) in foo (1:)
20:47:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:47:04 <sorear> fix (1:) = let x = 1 : x in x
20:47:19 <coffee-mug> > 1 + 2
20:47:20 <lambdabot>  3
20:47:29 <sorear> vincenz: show is lazy, so that's cheating ;)
20:47:32 <coffee-mug> lambdabot rocks :)
20:47:37 <bd_> > let 1 + 2 = "Impossible!" in 1 + 21
20:47:39 <lambdabot>   Non-exhaustive patterns in function +
20:47:39 <bd_> > let 1 + 2 = "Impossible!" in 1 + 2
20:47:40 <coffee-mug> I should really learn to use it
20:47:41 <lambdabot>  "Impossible!"
20:47:46 <coffee-mug> > [1..]
20:47:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:47:54 <Cale> How does fix (1:) take infinite space?
20:48:01 <Cale> (with my fix)
20:48:03 <coffee-mug> > [1..30]
20:48:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:48:10 <sorear> Cale: no full laziness
20:48:14 <Cale> What?
20:48:16 <coffee-mug> ah, so it takes the first 28 items
20:48:22 <bd_> Cale: In your implementation, we have: fix f = {- invocation 1 -} f ({- invocation 2 -} fix d)
20:48:26 <bd_> f*
20:48:32 <Cale> > let fix f = f (fix f) in fix (1:)
20:48:32 <vincenz> sorear: I am afraid I disagree
20:48:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:48:34 <bd_> coffee-mug: nah, it's based on characters in the result string
20:48:44 <vincenz> sorear: the tail-sharing is implicit
20:48:52 <coffee-mug> ah, I see
20:48:53 <bd_> Cale: Not all compilers are smart enough to determine the two invocations can have the same pointer location
20:49:03 <coffee-mug> does it maintain state? :)
20:49:05 <coffee-mug> > x = 5
20:49:06 <lambdabot>  Parse error
20:49:09 <Cale> fix (1:) = 1 : (fix (1:) = 1 : 1 : (fix (1:)) = ...
20:49:11 <bd_> @let x = 5
20:49:12 <bd_> > x
20:49:12 <lambdabot> Defined.
20:49:12 <coffee-mug> > let x = 5
20:49:13 <lambdabot>  Parse error
20:49:13 <lambdabot>  5
20:49:14 <vincenz> bd_: I think you might be confused
20:49:16 <coffee-mug> > x
20:49:17 <lambdabot>  5
20:49:29 <coffee-mug> how is that done?
20:49:30 <vincenz> sorear: they're equivalent
20:49:35 <bd_> vincenz: in Cale's implementation of fix f = f (fix f), what guarentees that the space will be shared between the two?
20:49:40 <vincenz> bd_: two what?
20:49:42 <coffee-mug> it just keeps a state monad
20:49:44 <vincenz> bd_: there is only one tail
20:49:51 <vincenz> bd_: while in the let x = f x in x
20:49:54 <vincenz> you have 2 x's
20:50:01 <vincenz> in this case, the x is implicit so you only have 1
20:50:01 <dons> coffee-mug: right. the defns are just kept in the Eval state, in compiled form
20:50:08 <Cale> bd_: f will be shared, because it's a duplicated parameter, is that what you're talking about?
20:50:12 <vincenz> let x = f _x_ in _x_
20:50:16 <sorear> vincenz: Cale is correct, in the same way that it is legal for list.sort to use unsafePerformIO . bogoSort
20:50:20 <vincenz> fix f = f _(fix f)_
20:50:27 <vincenz> one tail
20:50:34 <Cale> sorear: no, they perform the same.
20:50:43 <bd_> Cale: What I mean is, when it recurses with fix f, what is to prevent a dumb compiler from just invoking fix recursively, and not sharing space with the outer fix's invocation?
20:50:43 <coffee-mug> let x = (+) 1
20:50:44 <sorear> vincenz: haskell is not referentially transparent
20:50:50 <sorear> (performance wise)
20:50:53 <coffee-mug> > let x = (+) 1
20:50:54 <lambdabot>  Parse error
20:50:56 <vincenz> sorear: you're missing my point
20:51:03 <vincenz> sorear, Cale, bd_: let's move to #oasis for less spam?
20:51:09 <bd_> bah
21:01:48 <dons> the mandelbrot entry has been accepted.
21:01:55 <dons> so the numbers should update in 30 mins or so
21:02:09 <Gwern> dons: how much of a boost did you guys manage?
21:02:27 <dons> about 4x, from my estimates
21:02:47 <dons> which puts us at about 4x C (still slow, but Double math is hard in ghc for some reason :/
21:03:09 <Gwern> dons: still better than a lot of languages
21:03:15 <dons> this is a very sensitive little program though, so results might vary
21:03:24 <dons> Gwern: oh certainly, but we're competing with C here...
21:03:46 <bos> wow, thinking about fix is very interesting.
21:03:47 <dons> so beating lisp to death isn't any challenge ;)    hehe
21:04:23 <Gwern> dons: sure, now all we need is to get Liskell up to snuff so all the Lisp enthusiasts hae no excuse for not using Haskell :)
21:05:20 <Cale> dons: oh, right, I should ask you, how do I use passwd.rc ?
21:05:51 <sorear> Cale: create the file, and add "msg freenode:nickserv identify foobar"
21:05:57 <Cale> aha
21:06:09 <Cale> I was missing that freenode:
21:06:30 <sorear> yea, w/o a server tag it defaults to the current server
21:06:40 <glguy> sucks that BASIC FreeBASIC is beating GHC with all of the benchmarks included
21:06:42 <sorear> which is pretty useless from the context of an rc-file
21:08:11 <hpaste>  gotaku pasted "Interesting..." at http://hpaste.org/361
21:08:35 <dons> glguy: of the modern languages that you'd actually consider for a project though ... :)
21:08:39 <coffee-mug> Gwern: there's another component to Lisp that's missing from Liskell
21:08:45 <coffee-mug> Gwern: SLIME
21:08:45 <coffee-mug> :)
21:08:49 <vincenz> dons: what sort of times do you get for mandel on 3K?
21:08:55 <gotaku> dons: Check out the output of that hpaste... well it almost works ;)
21:08:56 <vincenz> woo
21:09:12 <dons> vincenz: 9s I think. i ppasted earlier.
21:09:20 <Gwern> coffee-mug: but slime's an application, not a part of the language - right?
21:09:20 <vincenz> dons: wow... I get like 13s on 1K
21:09:22 <sorear> coffee-mug: shim is based on slime iirc
21:09:31 <gotaku> Which program are you guys working on now?
21:09:42 <dons> gotaku: i was going to have a go at nbody
21:09:43 <vincenz> dons: that being said, my version is faster than yours by about
21:10:04 <dons> which version?
21:10:06 <vincenz> > (15.456 - 13.237)/ 15.456
21:10:09 <lambdabot>  0.14356884057971012
21:10:09 <vincenz> dons: your latest
21:10:09 <sorear> wow I can so understand that code
21:10:11 <sorear> not
21:10:14 <vincenz> dons: I get 15% gain :)
21:10:26 <dons> vincenz: show me your code
21:10:35 <vincenz> dons: however, like I said 1K takes 15s on mine with your version
21:10:50 <dons> yeah, i need to test any code on the p4 here
21:10:57 <vincenz> @paste
21:10:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:10:59 <dons> since that seems to fairly accurately model the shootout box
21:11:12 <sorear> dons: you can replace "P4\n" with "P4 ", it might help with gzip
21:11:13 <hpaste>  vincenz pasted "vincenz's latest mandel" at http://hpaste.org/362
21:11:23 <vincenz> dons: ps, your version borks on 100, it adds a funky artifact on the top
21:11:23 <sorear> (they're both legal in pbm(4))
21:11:37 <vincenz> dons: even though it's supposedly not-8-div-safe
21:12:00 <vincenz> ah never mind, that's my version...
21:12:02 * vincenz ponders
21:12:04 <dons> ok. its been a long day. what versions are ready for testing?
21:12:07 <vincenz> that being said, it compiles, equal output
21:12:08 <dons> vincenz: gotaku ?
21:12:20 <vincenz> dons: gotaku's small improvement on your "this is what I'm going to post"
21:12:29 <sorear> dons: does replacing "\n" with " " help on gzip?
21:12:42 <gotaku> vincenz: Hm?
21:12:45 <dons> i'd guess so, sorear by some tiny amount :)
21:13:14 <vincenz> heh, funky
21:13:32 <sorear> I'd also like more comments and longer variable names.  too bad there's no "Most Legible" category :)
21:13:34 <dons> sorear: its .bmp output
21:13:37 <dons> is that the same thing?
21:13:39 <glguy> no
21:13:45 <glguy> pbm -- portable bitmap format
21:13:53 <dons> ah
21:14:10 <olliej> glguy: the worlds most advanced image format :-/
21:14:18 <olliej> ;-) rather
21:15:11 <gotaku> On the plus side, the haskell mandelbrot program works on any input size, not just ones divisible by 8. I think we should get bonus points.
21:16:49 <procyon_`> @hoogle LanguageDef
21:16:50 <lambdabot> Text.ParserCombinators.Parsec.Language.LanguageDef :: String -> String -> String -> Bool -> CharParser st Char -> CharParser st Char -> CharParser st Char -> CharParser st Char -> [String] -> [
21:16:50 <vincenz> dons: how's it performing?
21:16:50 <lambdabot> String] -> Bool -> LanguageDef st
21:16:50 <lambdabot> Text.ParserCombinators.Parsec.Language.LanguageDef :: data LanguageDef st
21:17:13 <dons> vincenz: double checking, seems 14% slower
21:17:22 <dons> for =5k
21:17:22 <vincenz> slower??
21:17:37 * vincenz gets 15% faster for 1k
21:17:47 <glguy> what is -fexcess-precision
21:18:00 <dons> i'll check with 3k
21:18:14 <allbery_b> tells it to use full hardware precision instead of truncating to official IEEE specs
21:18:14 <vincenz> dons: then again, my version seems to be perfoming much slower so perhaps it's my arch... (centrino)
21:18:22 <allbery_b> since most FPUs generate a little extra precision
21:18:42 <glguy> truncating is slower?
21:18:55 <allbery_b> yes, it has to mask out the extra precision after each floating op
21:19:07 <dons> yes, definitely. 10% slower on N=3k
21:19:16 <vincenz> damn
21:19:17 <dons> (i.e. a whole second down)
21:19:23 <vincenz> dons: ok, I'll keep hacking :)
21:19:34 <vincenz> dons: probably due to the function generation
21:19:46 * vincenz goes back to the drawing board
21:20:25 <glguy> why isn't fortran doing better?
21:20:33 <glguy> I thought that it was > C for numeric programming
21:20:56 <dons> people who know how to write fast fortran don't subit? bad compilers?
21:21:01 <dons> submit.
21:21:27 <sorear> is fortran still better than C?
21:21:50 <dons> gotaku: you could try inlining that xor
21:21:50 <allbery_b> what compiler are they using?  I'd not expect as good results from gfortran than from the intel fortan compiler or other commercial compilers that optimize every last bit
21:21:55 <sorear> I mean, it might be a better language, but that means nothing if the authors of optimizing compilers don't use it
21:22:02 <dons> or floating out the function 1 level
21:22:43 <allbery_b> fortran is better not because of the language but because of the compilers
21:22:54 <bos> no, it is better because of the language.
21:23:05 <glguy> i thought it didn't suffer from aliasing issues introduced by pointers
21:23:06 <gotaku> Hah, it works.
21:23:09 <bos> i happen to work on fortran compilers sometimes :-)
21:23:19 <allbery_b> well, to the extent that the language is easier to optimize perhaps
21:23:31 <sorear> dons: with nornagon's mandel I made is significantly *faster* by floating a function *in* - don't assume out is always better!
21:23:41 <sorear> s/made is/made it
21:24:02 <svref> I'm implementing something like "show".  I want it to print most lists like [a,b,c], but I want it to print [Char]s like "abc".  How do Show's implementors specify compile-time-dispatch to the more specific function?
21:24:03 <gotaku> dons: Inline the xor?
21:24:03 <allbery_b> but it still needs good optimizing compilers, and commercial fortran compilers have been honed for a lot longer than C compilers, and specifically for numerics
21:24:06 <dons> floating it out didn't change any results this time.
21:24:18 <allbery_b> ?src Show
21:24:19 <lambdabot> class  Show a  where
21:24:19 <lambdabot>     showsPrec :: Int -> a -> ShowS
21:24:19 <lambdabot>     show      :: a   -> String
21:24:19 <lambdabot>     showList  :: [a] -> ShowS
21:24:24 <allbery_b> note the last entry
21:24:47 <sorear> allbery_b: commercial compilers count? :p
21:24:53 <bd_> ?src [] show
21:24:53 <lambdabot> Source not found. My mind is going. I can feel it.
21:24:56 <bd_> ?src String show
21:24:57 <lambdabot> Source not found. You speak an infinite deal of nothing
21:25:05 <sorear> ?src Char show
21:25:06 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:25:11 <sorear> gak!
21:25:14 <sorear> ?src Char showList
21:25:15 <lambdabot> Source not found. Take a stress pill and think things over.
21:25:30 <bd_> Hm, it occurs to me..
21:25:38 <sorear> dons: you need to rewrite your libscraper
21:25:39 <bd_> If we have Show Char, Show a => Show [a], and Show String...
21:25:48 <allbery_b> sorear: I'm talking in general
21:25:50 <bd_> How does this /not/ require -fallow-incoherent-instances?
21:26:02 <sorear> bd_: we don't have Show String
21:26:08 <bd_> oh?
21:26:12 <allbery_b> ?src String
21:26:12 <lambdabot> type String = [Char]
21:26:14 <sorear> bd_: we only have Show Char and Show a => Show [a]
21:26:15 <svref> > "abc"
21:26:16 <lambdabot>  "abc"
21:26:24 <bd_> sorear: How does this specialize for String though?
21:26:28 <allbery_b> can't do a typeclass on a type synonym
21:26:32 <svref> > ['a','b','c']
21:26:32 <sorear> bd_: it doesn't.
21:26:33 <allbery_b> showList on Char
21:26:34 <lambdabot>  "abc"
21:26:46 <sorear> bd_: a type specifies how lists of it display.
21:26:48 <bd_> sorear: but then why is show "x" /= "['x']" ?
21:26:59 <dons> gotaku: using this helped a little,
21:26:59 <dons> (W8# w) `xor'` (W8# y) = W8# (w `xor#` y)
21:27:00 <dons> {-# INLINE xor' #-}
21:27:09 <allbery_b> because showList is specialized for Char to use "" instead
21:27:17 <sorear> bd_: all types but Char use brackets (by the default instance), Char uses a ""
21:27:19 <allbery_b> > show ['x']
21:27:21 <lambdabot>  "\"x\""
21:27:25 <bd_> oh!
21:27:27 <glguy> > read "['x']" :: [String]
21:27:28 <bd_> I see now
21:27:29 <lambdabot>  Exception: Prelude.read: no parse
21:27:41 <glguy> er
21:27:42 <svref> ?src Show
21:27:42 <lambdabot> class  Show a  where
21:27:43 <lambdabot>     showsPrec :: Int -> a -> ShowS
21:27:43 <lambdabot>     show      :: a   -> String
21:27:43 <lambdabot>     showList  :: [a] -> ShowS
21:27:44 <glguy> > read "['x']" :: String
21:27:46 <lambdabot>  "x"
21:27:55 <int-e> > showList ['a', 'b', 'c']
21:27:57 <lambdabot>  <[Char] -> [Char]>
21:28:00 <int-e> > showList ['a', 'b', 'c'] ""
21:28:02 <lambdabot>  "\"abc\""
21:28:08 <int-e> > showList [1,2,3,4] ""
21:28:10 <lambdabot>  "[1,2,3,4]"
21:28:30 <svref> super thank you.
21:32:28 <sorear> @src Char
21:32:29 <lambdabot> data Char = C# Char#
21:32:42 <vincenz> dons: funky... by changing the code a bit I always get exactly 1 pixel difference on the first row :P
21:32:57 <vincenz> probably differnet rounding
21:35:51 <gotaku> Looks like you don't have to put parens around negative numbers when inside a tuple. That saves a few bytes.
21:35:59 <geekagent> How do I create an account for the haskell sequence?
21:37:14 <glguy> ?src digitToInt
21:37:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:37:24 <glguy> ?fptools Data.Char
21:37:25 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
21:37:44 <dons> geekagent: you have to ask the admin now, since we had some spammers
21:38:20 <glguy> dons: on the sickeningly fast sum-file entry, does ghc have to call ord '0' over and over in parse c  = ord c - ord '0'
21:38:21 <geekagent> Is remote authentication disabled? Because a note about that would save users frustration
21:38:25 <glguy> once for each char in the file?
21:38:27 <dons> i think you just try to register, and it goes into moderation.
21:38:34 <dons> glguy: nope
21:38:43 <dons> geekagent: we only did this yesterday
21:38:48 <geekagent> dons: there are no links to register
21:38:50 <dons> when CosmicRay noticed the spammers
21:39:17 <geekagent> and remote accounts for delphi leave a php error at the top of the page
21:40:31 <olliej> glguy: i would be surprised if ghc wasn't lifting the ord '0' call out
21:41:04 <glguy> dons: *!*@88.232.* is banned by Chanserv now, can I pull out the specific bans added by cale and igloo (specific ips in that range)
21:41:14 <geekagent> anyway, with the whole factor post:  map (^4) [1..3] is much cleaner and shorter
21:41:38 <olliej> @src []
21:41:39 <lambdabot> data [] a = [] | a : [a]
21:41:59 <olliej> @src (,,)
21:42:00 <lambdabot> Source not found. My pet ferret can type better than you!
21:42:11 <dons> glguy: yeah
21:42:23 --- mode: ChanServ set +o glguy
21:42:26 <dons> the ord '0' is just a _word 48 or whatever in the Core.
21:42:32 --- mode: glguy set -b *!*@88.232.73.189
21:42:38 <dons> glguy: you don't need ops to talk to chanServ, afaik
21:42:39 --- mode: glguy set -b *!*@88.232.105.76
21:42:43 <olliej> dons: which is what i would expect
21:42:48 <dons> oh, i guess to remove the local bans you do.
21:42:50 <glguy> dons, these are in the actual bans list
21:42:57 <glguy> dons, not chanserv autorem list
21:42:59 <dons> yeah
21:43:04 <dons> ok good
21:43:10 --- mode: glguy set -b *!*@88.232.48.162
21:43:15 --- mode: glguy set -o glguy
21:43:54 <glguy> chanserv does kickban on join for that range now
21:44:07 <dons> ok
21:44:29 <sorear> there are all of three turks on freenode, and none are haskellers
21:44:48 <dons> :(
21:44:58 <glguy> it is against turkish penal code 301 to denigrate turkishness
21:45:05 <dons> glguy: did you grep the logs first for the ip address?
21:45:24 <glguy> regarding which action?
21:45:27 * dons does so
21:45:47 <dons> ok. we've only had 3 people , all spammers, in 6 years from that range
21:45:48 <dons> seems ok
21:46:05 <glguy> in the last week or two?
21:46:19 <glguy> (all within?)
21:46:32 <dons> yeah, all since 07.02.02
21:46:49 <Pseudonym> Clearly, Haskell needs to concentrate on evangelism in Turkey.
21:47:30 <glguy> there was a turkish author on NPR today talkinbg about being prosecuted for discussing the turkish genocide of armenians today
21:47:58 <sorear> so THATS why there are no armenian haskellers...
21:48:01 <Pseudonym> that's a really sore point with some people for reasons I don't understand.
21:48:19 <glguy> she talked about how English and Turkish language made it easier to express different things
21:48:38 <glguy> I drew a lot of parallels to programming with what she was saying
21:48:54 <Pseudonym> Yeah.
21:48:55 <glguy> about how different languages affect personality and thinking as well
21:49:06 <svref> is the "deriving (Eq,Ord,Show)" feature of Data extensible to user-defined classes?
21:49:15 <sorear> svref: no
21:49:24 <Pseudonym> Anyone here old enough and nerdy enough to remember Serdar Argic?
21:49:32 <allbery_b> heh
21:49:35 <sorear> svref: you need to use an external preprocessor, such as DrIFT
21:50:05 <vincenz> dons: I guess for 5% it's not worth reposting?
21:50:35 <Pseudonym> Serdar Argic comes from the day when spam wasn't commercial.
21:50:53 <dons> vincenz: it is if it really does come up 5% faster
21:51:00 <dons> but i'd post it tomorrow
21:51:07 <dons> to not spam the poor shootout admins :)
21:51:14 <glguy> when does the shootout update??
21:51:17 <glguy> I was to see results!
21:51:18 <glguy> :)
21:51:31 <sorear> Pseudonym: didn't spam once refer to a type of comestable?
21:51:36 * allbery_b only vguely recall as he'd mostly given up usenet by then
21:51:44 <dons> glguy: soon soon...
21:51:46 <vincenz> dons: ok, let me play with it a bit more, the reason I did not see the earlier problems is cause the -O3 did not kick in, now t did and indeed inlining lp like that did make it slower, however the version I have now takes about 17.033s on 5K with your version and 16.300 on 5K with my latest
21:52:12 <dons> vincenz: I'd start using -ddump-simpl | less if I were you
21:52:18 <vincenz> thx
21:52:21 <dons> to gain an understanding of what is happening to the code
21:52:22 <Pseudonym> sorear: Yes.  And after that, there was a distinction between spam and velveeta.
21:53:03 <vincenz> dons: the transformations I have now tho are purely mathematical, so as such should not yield unrespected results
21:54:57 <dons> ok good
21:55:49 <vincenz> you can't type a locally defined func?
21:55:57 <vincenz> type-annotate that is..
21:56:06 <allbery_b> huh?  sure, same way you do a toplevel
21:56:15 <siti> but is there any point?
21:56:20 <siti> ghc should be smart enough :S
21:56:26 * allbery_b does it sometimes when trying to track down type errors
21:56:38 <allbery_b> ghc's plenty smart; *I'm* not...
21:56:57 <vincenz> allbery_b: nope...apparently not
21:57:17 <glguy> there ought to be a dual core shootout
21:57:21 <siti> yes :)
21:57:23 <allbery_b> hrm, pretty sure I've annotated both let and where
21:58:26 <siti> huh
21:58:26 <siti> where
21:58:26 <siti>     a :: Int
21:58:26 <siti>     a = 5
21:58:34 <sjanssen> vincenz: yes, you can give type declarations for let and where bound variables
21:58:38 <vincenz> oh
21:59:21 * allbery_b just tested both
21:59:26 <allbery_b> @paste
21:59:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:59:46 <allbery_b> not sure about lambdas
22:00:02 <sorear> lambda you can with glasgow fu
22:00:12 <sorear> lambda you MUST if you want rank-n
22:00:28 <vincenz> sjanssen: and inlining local let-bound functions?
22:00:49 <allbery_b> actually... ((\x -> x * 5) :: Int -> Int) 3
22:00:52 <allbery_b> works
22:00:54 <sjanssen> vincenz: they can be inlined like anything else (I believe)
22:00:57 <vincenz> thx
22:01:10 <vincenz> dons: that explains the earlier blowup: 1 no inlining, 2 lp was no longer typed
22:05:50 <dons> oh, did it guess a polymorphic type?
22:14:05 <dons> ah well, still not so hot :/ http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=all
22:14:27 <dons> looks like my laptop really does do something funny...
22:14:55 <lambdabot> Title: mandelbrot benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langua ..., http://tinyurl.com/q8e4f
22:15:09 <sjanssen> dons: I expected a bigger jump
22:15:56 <dons> interesting that it has identical memory usage...  hmm
22:16:35 <sjanssen> the Haskell entry runs in about 6s and the C in 3s on my machine -- I'm really not seeing a factor of ten difference
22:16:37 <dons> also, it wasn't compiled with -optc-ffast-math
22:16:48 <dons> i wonder if that's making much difference
22:16:56 <dons> yes, very strange
22:18:14 <sorear> are they using the right options?
22:18:23 <emu> speaking of annotating where and let-bound variables; is there a way to have "lexical type variable scope"?
22:18:33 <dons> looks like it, sorear
22:18:46 <sorear> no -optc-ffast-math ...
22:18:55 <emu> foo :: a -> ...; foo = ...; where bar :: a ...
22:19:02 <allbery_b> emu: types are only toplevel, I think
22:19:06 <dons> sorear: we're not allowed to use that
22:19:19 <sorear> dons: we're not !?
22:19:23 <dons> right.
22:19:34 <dons> i got an email about it just after i submitted
22:20:23 <dons> I really don't get why the memory usage is identical that's strange. one is unfolding bytestring chunks
22:20:23 <sorear> the build options for the C version include "-mfpmath=sse", maybe we should try that
22:20:26 <dons> the other is putting Chars out
22:20:37 <dons> sorear: yeah, didn't help (made things worse)
22:20:43 <dons> since we don't generate sse code
22:23:14 <dons> so nbody is the worst performing entry now
22:23:24 <dons> then mandelbrot, then spectral-norm
22:23:32 <siti> well on my athlon64 the c version is 1.1seconds haskell is 1.9 seconds
22:23:34 <siti> so it's pretty good
22:23:41 <dons> hmm
22:23:46 <dons> so why is it so slow on the shootout machine :/
22:23:52 <siti> crappy p4?
22:23:55 <dons> siti: can you try n=3k ?
22:24:01 <siti> it is 300
22:24:02 <siti> 3000*
22:24:10 <dons> even on a fairly crappy p4 i get 12s for n=3k
22:24:12 <hpaste>  vincenz annotated "final mandel?" with "strictifying lp and removing one loop iteration" at http://hpaste.org/356#a1
22:24:17 <dons> not 44s
22:24:20 <siti> yeah :S
22:24:24 <vincenz> dons: check that code?
22:24:26 * vincenz should get going
22:24:31 <dons> vincenz: does it run faster?
22:24:33 <siti> they need a 64bit machine!
22:24:34 <vincenz> yes
22:24:37 <vincenz> 5% or so
22:24:50 * vincenz tried using Double#'s but that didn't get me anywhere
22:24:55 <siti> can you paste your ultra optomized one I just grabbed: http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&id=0
22:25:12 <dons>  paste my what? runtime?
22:25:17 <sjanssen> siti: that's the one to test
22:25:32 <siti> ok, that's the new one that's been optimized right?
22:25:33 <sorear> dons: (vty) I'm starting to replace [[(Char,Attr)]] with (IOUArray Int Int -> IO (), Int, Int) and getting serious premature optimization vibes.  am I missing some better way?
22:26:36 * vincenz waves
22:26:40 <vincenz> time for a communication course
22:27:19 <sjanssen> dons: have you tried the C version on any of your machines?
22:27:23 <gotaku> Ah I see the shootout entry has been updated.
22:27:40 * vincenz prays his new versrion is indeed faster but it should definitely be, he's ran a lot of tests :)
22:27:57 <vincenz> gotaku: oddly enough doing the ci trick on cr gets one pixel difference on the first row
22:28:10 <dons> sjanssen: couldn't get them to compile
22:28:14 <dons> but not on the p4, no.
22:28:24 * dons tries this
22:28:32 <gotaku> vincenz: What trick?
22:28:46 <vincenz> gotaku: accumulating cr instead of doing (x*w - 1.5)
22:28:53 <siti> it's insane how on my machine haskell is only 40% slower
22:28:58 <vincenz> aka adding iw's whenever you increase x
22:29:01 <siti> yet on the shootout site it's insanely slower
22:29:17 <sjanssen> siti: my experience is similar
22:29:38 <vincenz> anyways my last version is correct to the pixel, compiles and gets me a constant 5% gain from 17.x to 16.3x
22:29:48 <vincenz> on 5K
22:29:59 <siti> oh I know why
22:30:06 <siti> the gentoo one still uses ghc 6.4 right?
22:30:15 <siti> I had to install gentoo-haskell overlay to get 6.6 ...
22:30:28 <sjanssen> siti: they upgraded to ghc 6.6
22:30:29 <dons> ah ok. 1.9s for the C program, 11s for the Haskell one...
22:30:29 <chessguy> man, what *are* you all on about tonight?
22:30:33 <siti> the debian shootout is using 6.6
22:30:35 <siti> sjanssen: oh ok
22:30:39 <dons> using -O3 -mfpmath=sse -msse2 -march=pentium4 -ffast-math -funroll-loops
22:30:47 <dons> for the C code..
22:30:49 <siti> wow 64bit machines make a huge difference to haskell!!!
22:31:15 <sorear> siti: yup. last I heard negatively :)
22:31:17 <chessguy> siti, example?
22:31:23 <dons> > 1.965 / 11.149 * 100
22:31:25 <lambdabot>  17.62489909408916
22:31:29 <allbery_b> wait, c gets to use -ffast-mah, haskell doesn't?
22:31:34 <siti> dons: well what machine do you ahve?
22:31:35 <siti> have*
22:31:50 <siti> sse math is different from -ffast-math
22:31:54 <dons> this is on a Pentium(R) 4 CPU 2.66GHz
22:31:57 <vincenz> dons: pm me if/when you get the results from that last paste?
22:32:31 <dons> the C program wasn't compiled with -ffast-math on the shootout
22:32:37 <dons> it just suggests to use that in the src
22:32:38 <siti> allbery_b: oops you are right
22:32:47 <allbery_b> ah
22:32:49 <siti> oops again, no you're not
22:32:52 <siti> it's in the comments
22:32:58 <siti> but the actual thing executed doesn't contain ffast-math
22:33:22 <dons> so without it runs in  2.373
22:33:23 <dons> the C program
22:33:31 <dons> > 2.373 / 11.149 * 100
22:33:33 <lambdabot>  21.284420127365685
22:33:52 <dons> > 2.373 / 11.149
22:33:53 <lambdabot>  0.21284420127365686
22:33:56 <sorear> night all
22:33:57 <siti> lol haskell rocks as a calculator :D
22:34:19 <dons> > 11.149 / 2.373
22:34:21 <lambdabot>  4.6982722292456796
22:34:28 <dons> so that's 4x, roughly what I though.
22:34:32 <dons> hmm. not 14x.
22:34:55 <vincenz>         for(x=0;x<w;x+=2)
22:34:57 <vincenz> o.O
22:36:12 <sjanssen> dons: I'm seeing about 3.3x
22:36:21 <siti> sjanssen: what cpu?
22:36:28 <sjanssen> siti: core duo
22:36:32 <siti> ok
22:36:46 <siti> is it the core2 or core that can do sse in one cycle?
22:36:55 <dons> i'm just suspicious that the memory usage is the same
22:37:12 <dons> almost like they ran the old program with different flags. but then the gzip numbers would be the same too. hmm
22:37:52 <siti> why do they have fputs with the c version :S
22:38:02 <siti> gcc optomizes printf to fputs anyway :S
22:38:06 <siti> and it's smaller :)
22:53:00 <mauke> @hoogle (a -> b) -> Either c a -> Either c b
22:53:01 <lambdabot> No matches, try a more general search
22:53:07 <mauke> @djinn (a -> b) -> Either c a -> Either c b
22:53:08 <lambdabot> f a b =
22:53:08 <lambdabot>     case b of
22:53:08 <lambdabot>     Left c -> Left c
22:53:08 <lambdabot>     Right d -> Right (a d)
22:55:14 * allbery_b thinks that looks suspiciously like (>>=)
22:56:04 <allbery_b> for the MonadError instance EIther String (or other Either a)
22:56:28 <allbery_b> actually I guess (=<<)
22:56:57 <mauke> don't you mean liftM?
22:57:17 <allbery_b> hm, yes
22:57:40 <mauke> @pl liftM (mapRight (map (\(a, b, _) -> (a, b))))
22:57:40 <lambdabot> (line 1, column 29):
22:57:41 <lambdabot> unexpected ","
22:57:41 <lambdabot> expecting letter or digit, operator or ")"
22:57:41 <lambdabot> ambiguous use of a non associative operator
22:57:46 <allbery_b> a would have to return the Either itself for (=<<)
22:58:02 <vincenz> dons: any news on my latest version?
22:58:17 <allbery_b>  @pl doesn't like tuples with n>2
22:59:22 <mauke> hey, it typechecks, so it must be correct
23:04:18 <newsham> isnt there some project to automate downloading haskell packages and deps?  is that working now?
23:05:00 <allbery_b> @where cabal-install
23:05:00 <lambdabot> I know nothing about cabal-install.
23:05:06 <newsham> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall ?
23:05:08 <lambdabot> Title: CabalInstall - Hackage - Trac
23:06:39 <newsham> is it working or too early?
23:12:08 <glguy> dons: looks like the mandelbrot improvements weren't enough to improve pole position :)
23:12:33 * glguy is printing his finished homework, and the inkjet printer is shaking his whole cheap desk
23:17:51 <siti> glguy: hah I remember when that used to happen with the desk I used to have and when I actually printed stuff ;)
23:18:54 <hpaste>  gotaku pasted "mandelbrot - someone try this." at http://hpaste.org/363
23:19:13 <gotaku> dons: If you're still around can you give that a try?
23:19:40 <mauke> @hoogle [m [a]] -> m [a]
23:19:40 <lambdabot> No matches, try a more general search
23:19:44 <gotaku> Or anyone else.
23:19:53 <newsham> hmm..  haskell support on win32 seems like an afterthought...
23:20:09 <newsham> portability leaves something to be desired :\
23:20:40 <siti> what unicode type is Char, utf8, 16 32?
23:20:52 <glguy> newsham: not like all those other highly portable languages :)
23:21:07 <mauke> siti: there are no unicode types
23:21:16 <glguy> you were expecting Java? :-p
23:21:22 <siti> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AChar
23:21:24 <lambdabot> http://tinyurl.com/ovjef
23:21:26 <siti> isn't char unicode :S
23:21:39 <glguy> the IO routines are not, however
23:21:46 <newsham> glguy: no, i just expect that a set of "normal" operations to exist across all platforms.
23:22:11 <siti> pffft who uses windows these days ;)
23:22:15 <glguy> oh, what operations are we talking about?
23:22:23 <mauke> siti: it stores unicode code points
23:22:23 <mauke> siti: but what does that have to do with UTF?
23:22:44 <newsham> I may have spoke too soon.. i'm looking at code that does thing like exit or detect the presence of files through the Posix APIs
23:22:49 <siti> I don't know, I was just wondering
23:23:11 <siti> does anyone know how you could internationlize your app? e.g. there's no gettext library in haskell :P
23:23:16 <newsham> but there may be some portable alternatives (doesFileExist, exitWith)
23:23:33 <siti> doesn't windows implement lots of posix?
23:24:14 <newsham> in this case the functions arent implemented.  i'm noticing because the compiler is telling me so :)
23:24:24 <glguy> internationalize??
23:24:34 <glguy> English was good enough for Jesus, it's good enough for you!
23:25:08 <newsham> how does exitImmediately compare with exitWith?
23:25:25 <siti> he spoke in hebrew ;)
23:25:37 <newsham> siti: then why is the bible in english?  dummy
23:25:49 <siti> lol
23:25:51 <mauke> normal exit runs atexit handlers, flushes output buffers, closes streams, etc
23:26:03 <mauke> _exit just terminates the program
23:26:46 <newsham> I take it exitImmediatel == _exit
23:27:09 <siti> so is there anyway to make an app in haskell that can select at runtime different languages.  E.g. every gnome app in existence :p
23:27:30 <glguy> newsham: my sentiments exactly ;)
23:27:32 <allbery_b> siti: Aramaic
23:27:33 <dons> use gettext?
23:28:00 <siti> is there gettext haskell bindings?
23:28:21 <siti> the issue is, people don't really want to be using the IO monad
23:28:36 <siti> to get some text in a different language
23:28:52 <allbery_b> why not?  it's going to be output anyway
23:29:27 <glguy> that's deep
23:30:14 <dons> gotau, nice it runs 14% slower than the current entry.
23:30:46 <glguy> what is the haskell version doing that is so much slower than the trivial C++ implementation that runs in 4 seconds?
23:31:03 <siti> http://www.mail-archive.com/haskell@haskell.org/msg19466.html
23:31:05 <lambdabot> Title: [Haskell] Re: I18N, external strings
23:31:18 <siti> oh yuck use unsafePerformIO
23:32:28 <dons> glguy: we don't know. it runs 4x C speed here, but 14x on the shootout
23:32:34 <dons> we've not been able to reproduced the shootout results
23:32:35 <dons> so its
23:32:36 <dons>  strange
23:32:49 <siti> dons: are you totally sure they're running 6.6?
23:33:01 * allbery_b wonders if one of the "slower" ones should be uploaded to see if it's faster on th shootout box
23:33:11 <glguy> bang patterns require 6.6 no?
23:33:14 <allbery_b> siti: can't do bytestrings without 6.6
23:33:23 <allbery_b> no external libraries, hence no fps
23:33:24 <siti> oh yep
23:33:37 <dons> siti, yeah.
23:34:50 <glguy> "The concept of Tao (from the Chinese philosophy of that name) is based upon the understanding that the only constant in the universe is change. ..."
23:34:58 <glguy> sounds like someone hasn't heard of "acceleration"
23:36:17 <glguy> and a zero change is still a constant change (and a constant universe)
23:36:18 <glguy> zomg
23:36:39 <glguy> hmm, no reason left to live then
23:36:41 <glguy> bye all
23:37:07 * allbery_b thinks treating philosophy as physics leads to error :)
23:37:24 <siti> :D
23:38:27 <glguy> I was possibly the only person in class today wearing a collared shirt
23:38:38 <glguy> and the prof asked if anyone *not* wearing a collared shirt
23:38:41 <glguy> had an answer to his question
23:38:46 <allbery_b> heh
23:40:33 <hpaste>  dons pasted "1% faster..." at http://hpaste.org/364
23:41:02 <dons> for n=5k, the haskell version does 30s , the C version does 6s
23:41:10 <dons> so 5x, not 14x.
23:41:21 <glguy> are you guys just trying to see how fast we can use all the ram on kakapo? :-o
23:41:40 <dons> good idea!
23:41:52 <glguy> :-p
23:42:44 <glguy> nearly to 50k requests and 1000 checkpoints
23:49:53 <dfranke> So I'm a month into my second semester of analysis...
23:50:15 <dfranke> It would really be truth in advertising if they renamed these courses MAS4311 Magic and MAS4312 More Magic.
23:52:04 * dfranke hugs Haskell and all other things algebraic
23:57:01 <glguy> There is a post on reddit about how developers don't click ads
23:57:12 <glguy> I didn't notice the ad however, because I use ad block plus
23:57:36 <dfranke> Reddit is actually good today.
23:57:56 <glguy> I almost wrote my response "what ad are you talking about??"
23:58:04 <glguy> and then I realized "oh, *that* ad :) "
23:58:33 <earthy> ;)
