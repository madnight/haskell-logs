00:00:16 <Botje> but i wouldn't know how to write it in haskell
00:00:25 <goltrpoat> the usual Y craziness.
00:00:26 <Botje> fix (\ f x -> ...) ?
00:00:26 <JoshTriplett> Botje: fac meaning factorial?
00:00:29 <Botje> yeah
00:01:13 <monochrom> If you have recursive function f x = .... f .....
00:01:39 <monochrom> just write: fix (\f x -> .... f .....).
00:02:00 <siti> I see
00:02:11 <JoshTriplett> Botje: Something like this?:
00:02:12 <siti> so it just applies the input to itself
00:02:13 <JoshTriplett> > let fac thefac x = if x == 0 then 1 else x * thefac (x-1) in let fac' = fix fac in fac' 5
00:02:14 <lambdabot>  120
00:02:15 <mauke> > let fac = fix $ \f x -> if x < 2 then 1 else f (x - 1) + f (x - 2) in fac 12
00:02:17 <lambdabot>  233
00:02:17 <siti> function(
00:02:49 <mauke> @src fix
00:02:49 <lambdabot> fix f = let x = f x in x
00:02:50 <Botje> mauke: yay! fib!
00:03:13 <JoshTriplett> Oh, nice; didn't know about @src.
00:03:18 <goltrpoat> josh:  i guess the reason i said that is that omega is rather illustrative when you switch to a strictly typed functional language from something that isn't.
00:03:46 <dufflebunk> Is there a good IDE for haskell, including debugging and stuff I'd expect to find in Java IDEs?
00:03:48 <JoshTriplett> goltrpoat: True.
00:04:02 <sorear> haha
00:04:04 <sorear> no.
00:04:10 <monochrom> If you have recursive list ns = 1 : scanl (+) 1 ns, just write fix (\ns -> 1 : scanl (+) 1 ns).  Then simplify to fix ( (1:) . scanl (+) 1 )
00:04:11 <fuzan> Visual Haskell?
00:04:19 <Botje> dufflebunk: the emacs environment is pretty good from what i hear
00:05:01 <goltrpoat> vshaskell is good, the haskell mode for kdevelop is good, and textpad is good (syntax highlighting-wise, if you need something lightweight)
00:05:19 <dons> hmm
00:05:25 <Botje> monochrom: is there a good guide on making functions point-free by hand?
00:05:27 <dons> today was our busiest day every in this channel!
00:05:28 <dons> http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html
00:05:29 <lambdabot> Title: #haskell @ freenode.org stats by dons
00:05:29 <siti> I am going to try kdevelop now
00:05:38 <Botje> (or anyone else, for that matter)
00:05:40 <monochrom> I don't know one.
00:05:42 <dons> by a crazy bizarre amount. i wonder why
00:05:55 <goltrpoat> dons:  oh, nuts
00:06:01 <siti> siti (838) <--- yes!!!
00:06:04 <siti> that was my aim ;)
00:06:09 <dufflebunk> goltrpoat: too bad visual haskell seems to require windows + msds
00:06:15 <siti> I am in the stats :D
00:06:19 <Botje> congratulations
00:06:24 <dons> $ wc -l 07.02.23
00:06:24 <dons> 9070 07.02.23
00:06:24 <dons> $ wc -l 07.02.22
00:06:24 <dons> 5804 07.02.22
00:06:27 <Botje> you have attained the rank of "pussywillow"
00:06:35 <goltrpoat> dufflebunk:  well, yeah, being a visual studio plugin and all, it'll require visual studio :)
00:06:55 <sorear> bah, dons is catching up
00:07:19 <therp> it looks like the unsafeCoerce operator can only be replaced by the more safer "cast" variant when the typeable interface is used... hm
00:08:16 <goltrpoat> well yah, you're replacing forall a. a -> b with (assumptions on a and b) => a -> b
00:08:17 <sorear> therp: cast is nowhere near as useful as unsafeCoerce# ...
00:08:40 <dons> ok, initial average performance results across all compilers, http://www.cse.unsw.edu.au/~dons/nobench/results.html
00:08:40 <lambdabot> Title: nobench: Haskell implementation shootout
00:08:53 <sorear> ooh, ejthecnar
00:08:54 <JoshTriplett> How do I bind a name in lambdabot?
00:08:55 <therp> sorear: but I thought one is supposed to use the safer variant
00:09:00 <dons> 1.00 20.45 1.25 41.63 N/A 14.14 20.12
00:09:09 <dons> sorear: currently rebuilding jhc
00:09:35 <monochrom> @define ns = fix ( (1:) . scanl (+) 1 )
00:09:35 <Botje> JoshTriplett:  > let x = 5 -- maybe?
00:09:36 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
00:09:36 <sorear> therp: when possible.
00:09:39 <goltrpoat> dons:  what happened to jhc?
00:09:46 <Botje> or not :)
00:10:10 <monochrom> I don't understand. :)
00:10:15 <sorear> goltrpoat: I assumed dons would upgrade faster
00:10:27 <dons> yeah, its just using flags from an old jhc build
00:10:32 <dons> the current jhc is building now.
00:10:38 <goltrpoat> oh i just mean, it had 5-6 tests it didn't fail in an older table
00:10:43 <sorear> goltrpoat: so I pushed a patch which (old versions) killed jhc (new versions) fixed jhc
00:10:44 <dons> yep.
00:10:49 <JoshTriplett> monochrom: I recall a syntax like that working before.
00:10:54 <goltrpoat> ahh
00:10:59 <dons> so, hugs is not doing very well
00:11:02 <sorear> goltrpoat: so the partial jhc support is dead until dons finishes upgrading
00:11:03 <dons> i think that's surprising
00:11:14 <dons> mostly dies with stack oflow
00:11:23 <sorear> nhc96 is slower than ghci, wow
00:11:28 <sorear> also suprising
00:11:34 <dons> no?
00:11:35 <sorear> er, faster I mean
00:11:42 <dons> yeah, not too surprising.
00:11:49 <dons> ghci is supposed to beat hugs.
00:11:53 <dons> and this code doesn't use many compiled libs
00:12:46 <goltrpoat> hbc looks like it's doing well.  off by a constant factor, more or less.
00:13:01 <sorear> dons: wanna give a ballpark figure for when we'll see jhc blaphohisu results?
00:13:09 <fons> hi all
00:13:13 <dons> goltrpoat: just doesn't handle very much
00:13:13 <sorear> hello fons
00:13:20 <dons> i.e. you can't really use any libraries with hbc
00:13:30 <goltrpoat> yah.
00:13:32 <dons> sorear: i don't have one. i expect around hbc though
00:13:37 <JoshTriplett> Hmmm.  Why does ** need Floating?
00:13:45 <dons> :t (**)
00:13:47 <goltrpoat> rhs.
00:13:48 <lambdabot> forall a. (Floating a) => a -> a -> a
00:13:49 <dons> :t (^)
00:13:49 <monochrom> because it uses logarithm
00:13:52 <dons> :t (^^)
00:14:01 <JoshTriplett> :t pow
00:14:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:14:05 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
00:14:05 <lambdabot> Not in scope: `pow'
00:14:37 <fons> what's the difference between the Control.Monad.State and Control.Monad.ST ?
00:14:44 <dons> very different
00:14:53 <goltrpoat> very little in common, really
00:14:53 <goltrpoat> hehe
00:14:54 <mauke> ST is evil on the inside
00:15:01 <dons> ones a state monad, for threading values through. ST is an interface to raw memory
00:15:39 <goltrpoat> State gives you the warm fuzzies.  ST gives you the IO heebiejeebies.
00:16:00 <monochrom> @src Control.Monad.ST.runST
00:16:00 <lambdabot> Source not found. Wrong!  You cheating scum!
00:16:09 <goltrpoat> told.
00:16:14 <monochrom> @src Control.Monad.ST.newSTRef
00:16:15 <lambdabot> Source not found. Do you think like you type?
00:16:33 <fons> I'm familiar with Control.Monad.State
00:16:48 <Botje> I was confused by ST being similar to "State Transformer" too.
00:16:50 <fons> but I don't really understand Control.Monad.ST
00:17:02 <mauke> @index STRef
00:17:03 <lambdabot> Data.STRef, Data.STRef.Lazy, Data.STRef.Strict
00:17:19 <fons> so ST is not a general purpose state trasnformer?
00:17:22 <fons> transformer
00:17:24 <timthelion> I feel soo stupid.  I can't figure out how to make a mult function that uses just addition without making it take 3 args (x x_initial y)
00:17:33 <goltrpoat> no.. StateT is what you're looking for probably
00:17:35 <fons> the state of ST is private?
00:17:40 <Botje> yes.
00:17:47 <Botje> to prevent the evil from leaking out.
00:17:57 <Botje> ST is basically a playpen where you can work destructively
00:17:59 <Botje> like IO
00:18:06 <Botje> but you don't need to be in the IO monad to use ST
00:18:13 <fons> ok, then what's the difference between IO and ST? IO supports references as well
00:18:29 <monochrom> IO do files, ST doesn't.
00:18:49 <bd_> and you can enter ST from pure code
00:18:56 <mauke> > let mult a b | b == 0 = 0; | b < 0 = - mult a (-b); | otherwise = a + mult a (b - 1) in mult 5 6
00:18:56 <lambdabot>  Parse error
00:19:18 <mauke> > let mult a b | b == 0 = 0 | b < 0 = - mult a (-b) | otherwise = a + mult a (b - 1) in mult 5 6
00:19:20 <lambdabot>  30
00:19:40 <fons> bd_, you can enter IO from pure code as well by simply returning
00:19:51 <bd_> fons: That's not what I mean :)
00:19:53 <bd_> :t runST
00:19:56 <lambdabot> Not in scope: `runST'
00:20:00 <bd_> ... okay well
00:20:08 <bd_> anyway, you can create a pure function
00:20:12 <bd_> which returns a pure valus
00:20:18 <bd_> but whose implementation uses ST
00:20:34 <fons> ok, that is a difference ..
00:20:41 <bd_> while you can theoretically do this with unsafePerformIO, ST gives a proof of purity
00:20:54 <fons> runST :: (forall s . ST s a) -> a
00:21:04 <monochrom> http://www.cs.toronto.edu/~trebla/Shuffle.hs  this illustrate both ST and how to shuffle a list randomly
00:22:53 <goltrpoat> > let mul n m = foldl (+) n (replicate n (m-1)) in mul 6 7
00:22:54 <lambdabot>  42
00:24:09 <goltrpoat> (by definition, more or less)
00:27:29 <timthelion> why can't I construct the infinite type: a = [a] in my_map p [x:xs] = p x : my_map p xs
00:27:48 <goltrpoat> what's the type of my_map?
00:27:55 <Botje> timthelion: you want (x:xs)
00:27:56 <sorear> (x:xs)
00:28:03 <siti> because you can create an infinite list but not actually a type that is infinite
00:28:08 <ibid> the smartass answer is "because it's not allowed" :)
00:28:23 <siti> when you get the error it's because of a mistake
00:28:40 <ibid> usually
00:28:52 <siti> :p
00:29:15 <monochrom> please don't construct an infinite type.  please.
00:29:40 <bd_> Think of the children.
00:30:06 <ibid> no, think of the kittens!
00:30:13 <goltrpoat> and then oleg comes around and writes fix in the type system.
00:30:20 <qwr> > ((sum .) . replicate) 6 7
00:30:21 <lambdabot>  42
00:30:35 <monochrom> unless you do: newtype X a = X [a]  :)
00:30:52 <goltrpoat> that's not an infinite type
00:31:47 <siti> data Type = Type ;)
00:31:56 <goltrpoat> that's not an infinite type either
00:31:57 <goltrpoat> hehe
00:31:59 <timthelion> and then the same problem here :( my_map p x = p x
00:32:01 <siti> I mean
00:32:06 <monochrom> Somehow you're right.
00:32:13 <siti> well something like that is :p
00:32:22 <goltrpoat> there's a distinction between a type constructor and a data constructor
00:32:28 <siti> yeah
00:33:45 <monochrom> newtype X a = X (X a)
00:33:55 <goltrpoat> that'll do it
00:34:13 <sorear> newtype Y f a = Y (f (Y a))
00:34:21 <sorear> er,
00:34:24 <monochrom> newtype X a = X (X [a])
00:34:38 <sorear> newtype Y f = Y (f (Y f))
00:35:34 <sorear> then fix (Y . (:[])) :: Y []
00:35:40 <sorear> type fix!
00:35:44 <monochrom> Wow, also newtype X a = X [X a]
00:36:25 <JoshTriplett> @type and
00:36:28 <lambdabot> [Bool] -> Bool
00:36:34 <goltrpoat> (it was while goltrpoat's head was exploding, splattering tiny chunks of brain matter all over his geometrically improbably couch, that he finally realized what howard and curry were on about)
00:36:43 <goltrpoat> improbable.  dammit.
00:37:29 <goltrpoat> (i do rather like my couch, though)
00:37:38 <monochrom> yeah, curry is about the sauce, howard is about the meat chunks, or your brain chunks, now you see.
00:38:36 <monochrom> A certain expensive Chinese dish is about monkey brain.
00:38:46 <monochrom> Now just add curry. :)
00:39:50 <goltrpoat> so now that i know that monochrom wants to eat my brains..
00:39:59 <goltrpoat> where were we.
00:40:28 <monochrom> infinite types
00:40:29 <JoshTriplett> So, I can use unfoldr to expand a sequence until a condition occurs; however, if I say "if that condition Nothing else ...", then I lose the last value.  How do I emit the element for which the condition first matched?
00:40:54 <goltrpoat> you could move the condition outside the unfoldr
00:41:23 <goltrpoat> i.e. takeWhile or some such, and always return Just inside
00:41:37 <monochrom> newtype X a = X [X a];  x = X (repeat x);   heeheehee!
00:41:53 <JoshTriplett> goltrpoat: Good point, but same problem; how do I say "takeWhileAndOneMore"?
00:42:07 <goltrpoat> write the oneliner that replaces takeWhile? :)
00:42:19 <goltrpoat> i actually just had that problem recently
00:42:30 <goltrpoat> i don't think there's a library function, there probably should be
00:43:16 <sorear> monochrom: Y is so much more fun!
00:43:28 <monochrom> I'm a newbie.
00:44:43 <JoshTriplett> @src takeWhile
00:44:44 <lambdabot> takeWhile _ []                 =  []
00:44:44 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
00:44:44 <lambdabot>                    | otherwise =  []
00:45:14 <JoshTriplett> @type (a -> Bool) [a] ([a],[a])
00:45:16 <lambdabot> parse error on input `->'
00:45:19 <JoshTriplett> @hoogle (a -> Bool) [a] ([a],[a])
00:45:20 <lambdabot> hoogle: scripts/hoogle/src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
00:45:20 <lambdabot>  
00:45:31 <JoshTriplett> Oooh, fun.
00:45:48 <JoshTriplett> Exception in lambdabot. :)
00:46:13 <bd_> nah, in hoogle :)
00:46:26 <timthelion> so is the show function just a generic cast to String?
00:46:45 <JoshTriplett> Looks like the web hoogle crashes on that too.
00:46:46 <bd_> the idea is read . show is the same as id
00:47:01 <bd_> in other words, show should produce haskell code to reconstruct your datastructure
00:47:04 <timthelion> id?
00:47:10 <JoshTriplett> bd_: Not quite.  read . show gives you safeCoerce. :)
00:47:14 <bd_> id is the identify function
00:47:16 <bd_> > id 42
00:47:18 <lambdabot>  42
00:47:22 <JoshTriplett> bd_: lexicalCoerce, specifically.
00:47:28 <bd_> JoshTriplett: read . show :: (a -> a) is the same as id, okay? :)
00:47:49 <bd_> er
00:47:50 <JoshTriplett> bd_: I only suggested the more general case because it proves rather useful. :)
00:47:50 <timthelion> id does nothing then,
00:48:15 <bd_> read . show :: ( (Show a, Read a) => a -> a) ) is the same as (id :: (Show a, Read a) => a -> a)) to be precise >.>
00:48:21 <bd_> timthelion: right, it returns what it's passed
00:48:30 <JoshTriplett> @src id
00:48:30 <lambdabot> id x = x
00:48:34 <timthelion> lol
00:49:15 <goltrpoat> i wonder how far read . show gets folded
00:51:07 <goltrpoat> i was writing a compiler for a loosely typed vm earlier, and after spending a day fighting with fundeps fighting gadts WITH KNIVES i almost ended up just writing Read instances for everything and dumping out strings
00:51:47 <sorear> @remember goltrpoat i was writing a compiler for a loosely typed vm earlier, and after spending a day fighting with fundeps fighting gadts WITH KNIVES i almost ended up just writing Read instances for everything and dumping out strings
00:51:47 <lambdabot> Done.
00:51:53 <goltrpoat> hattrick.
00:52:51 * JoshTriplett solved the "happy numbers" problem given earlier.
00:52:57 <goltrpoat> ah cool
00:52:57 <JoshTriplett> > let digits = map digitToInt . show in let sumsqr = sum . map (^2) . digits in let happyseq = unfoldr (\x -> Just (x,sumsqr x)) in let happybase = [0,1,4,16,20,37,42,58,89,145] in let happy = (==1) . head . dropWhile (`notElem` happybase) . happyseq in filter happy [1..100]
00:52:59 <lambdabot>  [1,7,10,13,19,23,28,31,32,44,49,68,70,79,82,86,91,94,97,100]
00:53:45 <fuzan> what's a factor of making ghc-generated executables so large? any quick flags reduce the size?
00:53:48 <goltrpoat> josh:  that's pretty close to my solution
00:53:58 <JoshTriplett> goltrpoat: I'd love to see your solution.
00:54:08 * fuzan is not looking at the solutions
00:54:14 <norpan> fuzan: i would guess static linking
00:54:17 <monochrom> static linking
00:54:18 <sorear> fuzan: the fact that the RTS is statically linked
00:54:26 <goltrpoat> sec, new laptop here, and it's on a different machine
00:54:27 <fuzan> sorear: oh, by default?
00:54:29 <monochrom> also the RTS is large
00:54:34 <sorear> fuzan: mandatory.
00:54:43 <fuzan> sorear: can't be done dynamically?
00:54:44 <sorear> fuzan: dynamic linking is NOT supported
00:54:48 <fuzan> oh snap.
00:54:49 <siti> strip is reduces size :p
00:54:52 <JoshTriplett> sorear: Due to non-stable ABI?
00:54:59 <monochrom> can be dynamic linking, still working on it
00:55:00 <siti> almost halves size sometimis
00:55:06 <siti> sometimes*
00:55:15 <sorear> JoshTriplett: more like lazy programers, and -fPIC, and assembly code generation.
00:55:25 <fuzan> siti: strip?
00:55:30 <sorear> fuzan: your best bet is to ditch ghc
00:55:35 <JoshTriplett> fuzan: from binutils
00:55:35 <sorear> fuzan: vvv
00:55:39 <sorear> @where yhc
00:55:39 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
00:56:06 <dobblego> evening
00:56:11 <fuzan> heh, yhc isn't in portage :)
00:56:13 <sorear> fuzan: yhc: fairly fast, very small bytecode files, portable dynamicly-linked runtime
00:56:15 <siti> fuzan: are you on a *nix machine?
00:56:20 <siti> yes gentoo
00:56:22 <siti> umm
00:56:24 <fuzan> siti: correct.
00:56:32 <siti> just run strip binary
00:56:42 <siti> it will get rid of debug symbols
00:57:02 <fuzan> i wrote a gimpy little (horribly coded) quizzer that i'd like to distribute to friends. and I'd rather not have them scoff at the file size :)
00:57:03 <siti> gentoo does it by default, I hate that for c progamming so I have FEATURES="-strip"
00:57:36 <siti> portage*
00:58:00 <qwr> fuzan: upx?
00:58:05 <sorear> fuzan: just get them to install ghci! :)
00:58:18 <dons> sjanssen: http://pywm.sourceforge.net/
00:58:19 <fuzan> ah, any way to easily pass the option to ghc? or will I have to manually link the object files after stripping?
00:58:19 <lambdabot> Title: PYWM - your Python-programmable X Window Manager
00:58:21 <dons> where's hwm!!
00:58:36 <sorear> -optl-s?
00:58:36 <fuzan> sorear: i've conned most into getting ghc/ghci. I'm a long ways away from getting htem to use Haskell at least :)
00:58:54 <qwr> fuzan: i have not tried it with ghc generated binaries but it might help... http://upx.sourceforge.net/
00:58:55 <lambdabot> Title: UPX: the Ultimate Packer for eXecutables - Homepage
00:58:57 <dobblego> is that grauenwolf guy on reddit serious? he seems to make horribly ill-informed comments - to stir people up?
00:58:59 <sorear> fuzan: but anyway yhc is probably a better option.
00:59:23 <sorear> fuzan: they call it 'unfinished' but it is h98, it just needs to catch up with ghc.
00:59:52 <sorear> fuzan: and yhi (the non-linked runtime) is fairly small
00:59:55 <fuzan> that looks cool! I'm interested in coding a WM in Haskell, yet i'm not up to par yet with Haskell :(
01:00:04 <dons> we've got most of one already written
01:00:07 <fuzan> sorear: can it generate win32 code?
01:00:09 <dons> sjanssen's in charge
01:00:32 <sorear> fuzan: no
01:00:41 <siti> oh yeah dons do you know frag segfaults on 64bit platforms?
01:00:42 <sorear> fuzan: it can't even generate linux code
01:00:57 <sorear> fuzan: yhi is ANSI C it runs on every platform.
01:01:18 <sorear> fuzan: yhc's output is slightly optimized bytecode.
01:01:30 <fuzan> what are its targets then?
01:01:46 <sorear> fuzan: anything with an ANSI C compiler (to compile yhi)
01:01:57 <goltrpoat> josh:  http://paste.lisp.org/display/37310
01:02:04 <fuzan> qwr: looking at upx
01:02:16 <sorear> fuzan: my yhi binary is 116k
01:02:42 <goltrpoat> (take n . filter happy) [1..] gives the first n happy numbers
01:03:32 <fuzan> hpaste.org :)
01:03:35 <goltrpoat> wrote it as a sort of expository type deal for someone else, so it's intentionally verbose
01:04:49 <JoshTriplett> goltrpoat: Nice.
01:05:36 <therp> does anyone know how is responsible for DNS at galois.com? the domain hackage is hosted at?
01:05:39 <goltrpoat> pretty much the same as yours, with some minor changes
01:06:49 <goltrpoat> notElem wouldve gotten rid of a few lines there though
01:06:49 <goltrpoat> hehe
01:07:15 <JoshTriplett> goltrpoat: Yeah.  Pretty much just the different digits using show, head.dropWhile rather than last.takeUntil, and unfoldr in iterateSquares/happy.
01:07:28 <goltrpoat> yah.
01:08:13 <JoshTriplett> goltrpoat: But you make up for all that by coming up with the name "happyTrap". :)
01:08:17 <goltrpoat> hahah
01:11:37 <goltrpoat> it looked like a normal group, but i spent about five minutes trying to come up with a group and couldn't
01:11:41 <goltrpoat> hence the "trap" bit
01:12:28 <JoshTriplett> Anyone familiar with HOpenGL?  If I want to bind to a new GL function that takes an array (glDouble vertices[][3]), should I make my wrapper take a [Vector3 GLdouble] and marshal to the array format?  That seems expensive...
01:13:08 <siti> I am not familar with it but you could look at the ghc source to see how they do it
01:13:14 <siti> it's probably the best way 0
01:13:16 <siti> ;)*
01:13:26 <goltrpoat> is it glDouble vertices[][3] or glVector [] ?
01:13:35 <goltrpoat> or glVector3 or whatever it is
01:13:40 <JoshTriplett> goltrpoat: The former.
01:13:48 <JoshTriplett> goltrpoat: At least, according to the documentation.
01:14:31 <dobblego> does anyone ever find themselves writing a data type with a single constructor without arguments, just so they can write a type-class instance?
01:14:46 <dons> usually i'd use a newtype for that
01:14:48 <goltrpoat> if you're worried about speed, can't you use mallocArray and friends?
01:14:56 <dons> or, do you mean, data T = T ?
01:15:03 <dobblego> dons, the latter
01:15:08 <dons> yeah, it happens.
01:15:12 <dobblego> ok
01:15:16 <dobblego> just felt funny
01:15:21 <dons> you can even have:   data T
01:15:25 <dons> undefined :: T
01:15:29 <dons> :-)
01:15:31 <goltrpoat> i find myself with quite a few class C t; instance C A; instance C B type deals
01:15:33 <JoshTriplett> goltrpoat: I want to provide a convenient and HOpenGL-like interface to this function.
01:15:47 <dobblego> yeah, that's prolly even better
01:16:03 <JoshTriplett> goltrpoat: And I just checked; glDouble point_array[][3]
01:16:40 <goltrpoat> josh:  you should be able to wrap pokeArray in the interface, no?
01:16:56 <JoshTriplett> goltrpoat: Yeah; it just seems wrong to make my wrapper linear in the length of the array...
01:17:15 <goltrpoat> my only exposure to HOpenGL is from doing some inverse kinematics stuff with automatic differentiation, so speed wasn't really an issue, i just wanted to see if the idea worked
01:18:14 <goltrpoat> well if it's marshalling an array across, it'll be linear no matter what you do, right
01:18:24 <goltrpoat> if you want direct memory access you'll be passing Ptr instances around
01:18:32 <goltrpoat> unless i'm missing something
01:18:46 <timthelion> how come filter is (a -> Bool)->[a]->[a] and not (a -> Bool)->[a]->[Bool]?  Why is a twice?
01:19:05 <TSC> Because it's filter, not map
01:19:05 <sorear> because filter filters, it doesn't map
01:19:08 <dobblego> timthelion, filter returns a list that has been filtered
01:19:20 <goltrpoat> tim:  because filter p takes a list and produces a list of the same type, after discarding everything that does not satisfy p
01:19:25 <JoshTriplett> timthelion: filter takes a function from a type to Bool, and a list, and returns a subset of the list; a subset of a list has the same type as the list.
01:19:26 <timthelion> oh, I see
01:19:34 <siti> lol 5 answers :D
01:20:04 <timthelion> the whole arrow thing seems rather stacky
01:20:07 <JoshTriplett> goltrpoat: Yeah, I guess it will end up linear in the length of the list regardless, since I don't want to make the caller use Ptr.
01:20:32 <timthelion> can I think of the arrow as a push onto the stack?
01:20:34 * JoshTriplett wonders if ghc can optimize away the marshalling and make the caller use Ptr anyway. :)
01:20:52 <goltrpoat> josh:  seems like it.. i doubt that'll ever be your bottleneck though
01:20:55 <JoshTriplett> timthelion: You can if you like, but that metaphor will get you into trouble later.
01:21:49 <JoshTriplett> goltrpoat: True.
01:22:24 <timthelion> it's soo hard for me, being a math brain I don't like the abstract, and I feal just like I do in precalc right now with haskell, right now it's abstract but calculus will make it all better... GRRRR
01:22:32 <goltrpoat> i'm not sure if there are any good metaphors there.  you basically have to realize that all functions have the type a -> b, where a and b are types, and every type is either a basic type or a function type.  you get the rest from there.
01:23:55 * sorear begins to wonder if it would be better just to rewrite vty's output layer in C
01:24:11 <siti> :o
01:24:49 <sorear> it's a giant bottleneck with lots of memory accessing loops
01:25:04 <sorear> ghc generates nearly pessimal code for such loops
01:25:13 <siti> ok
01:25:15 <sorear> even with -fvia-C
01:25:32 <dons> sorear: it makes perfect sense
01:25:35 * dufflebunk laughs at pessimal code
01:25:38 <sorear> since the generated code has lots of aliasing hazards
01:25:43 <dons> just as long as you can QC or at least test the C layer
01:26:03 <sorear> yeah.
01:26:17 <sorear> I'm more concerned about the loss of hackability
01:26:24 <goltrpoat> how hard would it be to port vty to windows, anyway
01:26:25 <dons> wouldn't be the inner loops that are the problem?
01:26:28 <sorear> when I need to make the Next Big Change
01:27:24 <sorear> goltrpoat: essentially impossible.  for vty 3.[12] I need to add multiple terminal type support (yes it currently uses hardcoded ansi :) ) and then windows will be (relatively) easy
01:28:10 <goltrpoat> you can do ansi in windows though, just not proper vt100
01:28:24 <sorear> dons: it's the diffing/cursor motion code.  from what I understand of ncurses, that's where all the clever algorithms are located.
01:28:32 <dons> yeah
01:29:11 <goltrpoat> and most of ncurses has win32 equivalents, if not dos equivalents
01:29:27 <goltrpoat> anyway, just a thought.
01:29:28 <sorear> right now I never use insert/delete/clear codes and cursor motion is shortest-of [[C [[H
01:30:18 <sorear> about how big is the overhead of an unsafe foreign call?
01:30:26 <dons> not much
01:30:32 <dons> 400 cycles?
01:30:34 <dobblego> why can't I declare a class without parameters?
01:30:44 <sorear> why would you want to?
01:30:45 <dons> dobblego: hmm?
01:30:49 <dons> class T where ?
01:30:58 <dons> i.e. a class that has no instances and can never be used?
01:31:02 <siti> 400, isn't that alot ?
01:31:03 <dobblego> class Foo where bar :: Int
01:31:12 <dons> siti: well, depends on what 'big' means :-)
01:31:25 <goltrpoat> dobblego:  that's a meaningless assertion though
01:31:41 <sorear> yay, I've finished compiling ghc for the second time today
01:31:44 <dons> dobblego: class Foo t where bar :: Int; bar = 7
01:31:51 <goltrpoat> 2 + bar   -- what should this evaluate to?
01:32:00 <dons> instance Foo A where ; instance Foo Int where ; ...
01:32:09 <dobblego> how do you pass a bazillion optional arguments?
01:32:24 <dons> in a structure. using records?
01:32:29 <dons> in a list of Maybe?
01:32:37 <nornagon> use the printf trick?
01:32:44 <dobblego> the printf trick?
01:33:00 <dons> well, probably not feasible unless you're trying to emluate varargs in a library
01:33:05 <nornagon> :t Text.Printf.printf
01:33:07 <lambdabot> forall r. (PrintfType r) => String -> r
01:33:07 <dobblego> no I'm not
01:33:08 <goltrpoat> map (unsafeCoerce Word32) a bytestring to your code segment?
01:33:08 <goltrpoat> hehe
01:33:15 <nornagon> @src PrintfType
01:33:15 <lambdabot> Source not found. My mind is going. I can feel it.
01:33:17 <sorear> stefan@stefans:~/vty/test$ ghc-6.7.20070223 -V
01:33:17 <sorear> The Glorious Glasgow Haskell Compilation System, version 6.7.20070223
01:33:17 <sorear> stefan@stefans:~/vty/test$
01:33:20 <sorear> YAY!!!
01:33:27 <dons> sorear: hmm.
01:33:32 <dobblego> I'll just use a data type
01:33:32 <dons> i notice the snapshot didn't work though
01:33:33 <sorear> (the last time I tried that I got a segfault)
01:33:44 <dons> sorear: so you built from darcs?
01:33:47 <sorear> yeah
01:33:50 <dons> ok. i'l ltry that
01:33:58 <sorear> super current, 1 patch behind head
01:34:10 <sorear> dons: define 'didn't work though'
01:34:20 <sorear> dons: 'Segmentation fault' on use?
01:34:40 <sorear> dons: do you have an older GHC-HEAD lying around called 'ghc'?
01:34:43 <dobblego> dons, your previous declaration fails because no functions use the type parameter
01:34:44 <sorear> that bit me
01:35:05 <dons> missing ghc binaries
01:35:08 <goltrpoat> 6.7.20070215 built/ran just fine for me
01:35:16 <dons> i was using 0222
01:35:17 <goltrpoat> just took the better portion of the year
01:35:34 <sorear> goltrpoat: that's a known defective version :)
01:35:45 <goltrpoat> seriously?
01:35:48 <sorear> goltrpoat: try compiling anything with -fvia-C
01:35:55 <goltrpoat> oh
01:36:07 <sorear> goltrpoat: you'll get a bunch of warnings, and the output will segfault immediately
01:36:12 <goltrpoat> ive done that about .. once
01:36:15 <sorear> goltrpoat: bug #1151
01:36:20 <dons> sorear: have you tried head jhc?
01:36:24 <goltrpoat> nuts.  thanks for the warning though
01:36:31 <dons> i get some new pattern match failures on nobench
01:37:08 <sorear> dons: no, the lack of laziness brings it from just-usably-lean to unusably-memory-hungry
01:39:28 <sorear> vty selfbenchmark, both times -fvia-C -O2 -funbox-strict-fields
01:39:47 <sorear> user    0m13.541s  -- GHC 6.7.20070223
01:40:00 <dons> better?
01:40:00 <sorear> user    0m14.165s  -- GHC 6.6
01:40:03 <dons> ok
01:40:13 <sorear> fairly big difference IMO
01:40:29 <goltrpoat> quite OT, but i don't suppose anyone knows of a decent squeak-oriented smalltalk book or tutorial?  everything i've come across seems to be either addressed to people who have never seen a computer before, or it's a morphic tutorial
01:42:19 <goltrpoat> i.e. i was trying to find something between "this is what a scrollbar looks like -- click on it!  congratulations, you've made your first step in UI navigation" and "this is an AJAX application written using MVC in Seaside with KDB on the backend with a small goat compiling queries in the back, you can see it through this Morphic class we're about to write."
01:43:44 <goltrpoat> (long story)
01:43:44 <sorear> dons: the scores are normalized against GHC now?
01:45:28 <siti> stmartin: what part of nz are you from?
01:45:34 <siti> I am a kiwi too :)
01:45:53 <stmartin> siti: Dunedin
01:46:01 <siti> ok I am up in chch :)
01:49:40 <dons> sorear: right
01:49:44 <JoshTriplett> Any way I can enforce, in the type signature of a function, that two lists or list-like structures must have the same arbitrary length?  (Without making them a single list of tuples.)
01:50:03 <dons> and the geometric mean computed on the total, and for each cateogry
01:50:23 <goltrpoat> josh:  have you read the 'faking it' paper
01:50:30 <JoshTriplett> A foreign function takes a length and two arrays as arguments.  I want to enforce that the two arrays have the same length.
01:50:36 <JoshTriplett> goltrpoat: No...
01:50:39 <JoshTriplett> goltrpoat: Looking it up.
01:50:54 <goltrpoat> you're asking for dependent types, so..  you'll need something along those lines
01:50:57 <JoshTriplett> goltrpoat: http://citeseer.ist.psu.edu/mcbride01faking.html ?
01:50:59 <lambdabot> Title: Faking It: Simulating Dependent Types in Haskell - McBride (ResearchIndex)
01:51:00 <goltrpoat> yes
01:51:35 <metaperl> could someone help me find the source for all? I clicked on the source code link here: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aall  ... and it did not exist in the file revealed
01:51:36 <lambdabot> http://tinyurl.com/ovjef
01:51:53 <goltrpoat> there was also a type-safe basic linear algebra package floating around somewhere
01:51:53 <sorear> @src all
01:51:54 <lambdabot> all p =  and . map p
01:51:57 <sorear> @src and
01:51:58 <lambdabot> and   =  foldr (&&) True
01:51:59 <sorear> @src map
01:52:00 <lambdabot> map _ []     = []
01:52:00 <lambdabot> map f (x:xs) = f x : map f xs
01:52:03 <sorear> @src foldr
01:52:03 <lambdabot> foldr k z xs = go xs
01:52:04 <lambdabot>     where go []     = z
01:52:04 <lambdabot>           go (y:ys) = y `k` go ys
01:52:25 <metaperl> sorear - thanks
01:52:31 <metaperl> now, is all short-circuiting?
01:52:34 <sorear> metaperl: it was probably imported from another package
01:52:35 <sorear> yes
01:52:36 <dons> ?source Data.List
01:52:36 <goltrpoat> i.e. A B would typecheck for A in F^{mxn}, B in F^{nxk}
01:52:37 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
01:52:49 <sorear> GHC.List and GHC.Base being the most likely suspects
01:53:20 <metaperl> I had been expecting a haskell implementation similar to this - P[x] for all x <==> not ((not P[x]) for some x)
01:53:37 <metaperl> supposedly that is a well-known math formula: http://www.factorcode.org/responder/browser/?word=all?&vocab=sequences
01:53:39 <lambdabot> Title: IN: sequences : all? ( seq quot -- ? ), http://tinyurl.com/ywmlhb
01:54:06 <dons> ?src (&&)
01:54:06 <lambdabot> True  && x = x
01:54:07 <lambdabot> False && _ = False
01:54:48 <goltrpoat> metaperl:  that's more useful when transforming first-order logic sentences into a particular normal form
01:55:08 <metaperl> oh
01:57:24 <de1337> dons: any progress on the hs-plugins?
01:57:54 <siti> I can see why dons is the most referenced nick name in this channel :)
01:57:58 <oklopol> ?src (+)
01:57:59 <lambdabot> Source not found. My mind is going. I can feel it.
01:58:10 <siti> how can you add then :S
01:58:11 <siti> ;)
01:58:28 <goltrpoat> lambdabot's losing it.
01:58:31 <oklopol>  > (+) 1 2
01:58:34 <oklopol> > (+) 1 2
01:58:36 <lambdabot>  3
01:59:27 <therp> siti: dons is a one-man army when it comes to Haskell support on this channel
01:59:57 <norpan> dons is the duracell rabbit of haskell
02:00:02 <Boney> daisy daisy...
02:00:07 <therp> @karma dons
02:00:07 <lambdabot> dons has a karma of 121
02:00:08 <therp> @karma therp
02:00:09 <lambdabot> You have a karma of 1
02:00:13 <therp> you see the difference? :)
02:00:15 <dons> de1337: it works with ghc 6.6
02:00:24 <Boney> @karma Boney
02:00:25 <lambdabot> You have a karma of 0
02:00:28 <Boney> YAY!
02:00:39 <siti> @karma lambdabot
02:00:39 <lambdabot> lambdabot has a karma of 42
02:00:44 <de1337> dons: ohh, how is that.. no update has been done to hs-plugins?
02:00:48 <Boney> @karma haskell
02:00:49 <lambdabot> haskell has a karma of 20
02:00:57 <siti> haskell++
02:01:00 <siti> @karma haskell
02:01:01 <lambdabot> haskell has a karma of 21
02:01:04 <siti> :)
02:01:24 <norpan> c++
02:01:34 <goltrpoat> dons is sort of like mother goose, feynman and mendeleev rolled into one.
02:01:43 <oklopol> ?src (*)
02:01:43 <lambdabot> Source not found. You speak an infinite deal of nothing
02:01:45 <metaperl> lol
02:02:02 <siti> @karma c
02:02:03 <lambdabot> c has a karma of 15
02:02:03 <oklopol> ?src (:)
02:02:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:02:24 <sorear> night.
02:02:36 <dons> de1337: in the darcs repo
02:02:45 <dons> you'll find an hs-plugins that works for ghc 6.6
02:03:27 <de1337> well i dont use darcs, im in win
02:03:55 <de1337> cant you link it on your page or some temp url or something?
02:05:30 <dons> you can download src ?
02:05:44 <dons> darcs works on windows
02:05:55 <goltrpoat> why is c catching up to haskell, karma wise
02:05:56 <goltrpoat> hehe
02:05:58 <dons> anyway, its online, wget http://www.cse.unsw.edu.au/~dons/code/hs-plugins
02:05:59 <lambdabot> Title: Index of /~dons/code/hs-plugins
02:06:08 <dons> c--
02:06:11 <dons> ;)
02:06:16 <goltrpoat> there we go.
02:06:30 <siti> hah, it's unfair because c-- and c++ are both languages :(
02:06:52 <goltrpoat> in a manner of speaking.
02:06:52 <siti> poor c gets shoved around like its a letter
02:07:03 <de1337> dons: what is it i need to get there, all files?
02:07:19 <dons> everything except under the _darcs repo.
02:07:24 <dons> you should just install a darcs windows binary
02:07:27 <dons> available from darcs.net
02:07:34 <dons> it'll make hacking haskell a lot easier
02:08:04 <de1337> well im not hacking haskell, i try it a little now and then.. just to find that something doesnt work and then i stop ;)
02:08:37 <goltrpoat> no no.  everything works.
02:08:40 <dons> hs-plugins is certainly on the more experimental end of things, remember.
02:08:50 <goltrpoat> oh libwise
02:08:56 <de1337> yes i know, had problems with it on win
02:09:10 <de1337> i might give it a shot on 6.6 though
02:09:59 <dons> i'd learn haskell thoroughly first ;)
02:10:35 <de1337> error on install.sh download
02:10:42 <de1337> file not found
02:11:03 <dons> i can't help you really, unless you use darcs.
02:11:17 <dons> its hard enough supporting windows, let alone custom installs that don't play by the rules
02:11:42 <de1337> nono, i mean on your web server, i can download most files, but you have linked the install.sh wrong
02:12:04 <dons> hmm. let me see.
02:12:33 <dons> its an empty, unused file
02:12:40 <timthelion> I don't get Exercise 4.6 of YAHT at all
02:13:24 <timthelion> I don't know what is wanted
02:13:33 <timthelion> or how to get what I think is wanted
02:14:01 <goltrpoat> sec, looking it up.
02:14:43 <goltrpoat> k, so there are two parts to the question
02:15:04 <goltrpoat> one wants you to define a type, the other wants you to write some functions to operate on it.  forget about the latter for the moment.
02:15:14 <timthelion> and I don't get the first part. how to create such a dataconstructor
02:15:24 <goltrpoat> it's more than one data constructor
02:15:43 <timthelion> when I tried making more than one with the name Tuple I got errors
02:15:46 <goltrpoat> keep in mind, you can say data MyType = S a | T b | ... | Z f
02:15:48 <timthelion> not supprisingly
02:16:23 <goltrpoat> so specifically, you want data constructors that take a, (a,b), (a,b,c), and (a,b,c,d)
02:16:32 <timthelion> data Tuple = a b | a b c | a b c d ?
02:16:40 <dons> you'll need a constructor there
02:16:42 <goltrpoat> no, you want to name them, and you want an a
02:16:47 <dons> T2 T3 T4
02:17:00 <dons> and the types are parameters to the type constructor
02:17:07 <dons> data Tuple a b c d = ....
02:17:10 <timthelion> data Tuple = T2 a b | T3 a b c | T4 a b c d ?
02:17:16 <dons> close. see above
02:17:23 <timthelion> data Tuple a b c d = T2 a b | T3 a b c | T4 a b c d ?
02:17:26 <dons> right.
02:17:31 <timthelion> now what does this accomplish?
02:17:44 <goltrpoat> you also want the single argument constructor
02:17:54 <norpan> @karma norpan
02:17:54 <lambdabot> You have a karma of -1
02:17:57 <norpan> wow
02:18:03 <goltrpoat> no love.
02:18:06 <norpan> nope
02:18:10 <goltrpoat> norpan++
02:18:30 <timthelion> norpan^2 ;/
02:18:31 <norpan> i wonder what i've done to deserve this
02:18:56 <timthelion> well, you are neither wine, nor bread
02:19:17 <norpan> no, i am flesh
02:19:19 <goltrpoat> speaking of those.
02:19:21 <goltrpoat> brb.
02:19:44 <timthelion> norpan, noting that pan is bread in spanish
02:20:09 <norpan> i see
02:20:12 <norpan> i knew that
02:23:54 <goltrpoat> tim:  do you see the point there?  T2, T3 and T4 are all data constructors for the same type
02:24:59 <goltrpoat> T3 is basically the function a -> b -> c -> Tuple a b c d
02:25:16 <timthelion> http://rafb.net/p/O1EOkL45.html
02:25:18 <lambdabot> Title: Nopaste - No description
02:26:21 <goltrpoat> well.. you didn't define T1
02:26:31 <timthelion> oh
02:26:39 <goltrpoat> tuple1 (T2 1 2) should work
02:27:45 <timthelion> ok
02:27:54 <goltrpoat> Tuple is a type constructor, not a data constructor, so Tuple 1 2 doesn't really make sense
02:28:08 <timthelion> why didn't we just define these as standalone datatypes?
02:28:28 <timthelion> like data T1 = T1 a
02:28:34 <goltrpoat> we didn't define those as standalone datatypes because you may want to write a function that operates on Tuple
02:28:45 <timthelion> and I can?
02:28:51 <timthelion> how would I do that?
02:29:18 <goltrpoat> eg, extractFirst :: Tuple a b c d -> b; extractFirst (T2 a b) = a; extractFirst (T3 a b c) = a; etc
02:29:41 <timthelion> so it still has to be exastive
02:29:49 <goltrpoat> no
02:30:04 <timthelion> so could you make one that squared a
02:30:11 <timthelion> and worked on all 4?
02:30:11 <goltrpoat> but you'll get a runtime error if it's not, and you pass in something that isn't pattern matched
02:31:08 <goltrpoat> sure.
02:31:14 <timthelion> now is the point because I couldn't have extractFirst (T2 a b) = a; extractFirst (T3 a b c) = a; etc if they where all standalone because the function has to have consistent type?
02:31:48 <timthelion> worked on all 4 without exahstivly writing functions to handle the 4 cases
02:31:58 <goltrpoat> right.  if T2 and T3 were data constructors from separate types, you'd end up having to define a typeclass that says, T2 and T3 expose the extractFirst interface
02:32:43 <goltrpoat> if you wanted a single function that operated on all of them, i mean
02:33:14 <goltrpoat> it's a fair bit like variants in other languages.
02:33:39 <timthelion> so I could write a mask that exposed a
02:33:53 <timthelion> and that, in haskell is called a typeclass
02:34:11 <timthelion> data's are kinda like struckts aren't they
02:35:35 <goltrpoat> sort of, and sort of not
02:36:08 <goltrpoat> the first difference between haskell data declarations and C structs is that the former is polymorphic
02:36:57 <timthelion> hmm, I wonder how many 15 year olds have ever asked that question before.
02:36:57 <goltrpoat> so then moving on to C++ template classes, one difference is that you can say that an instance of T is either D1, or D2, or D3, etc, where the Ds are data constructors
02:37:16 <goltrpoat> in C++, the closest equivalent is boost::variant
02:37:17 <siti> and you can use data to create enum like types too :)
02:38:03 <timthelion> I like enumeration
02:38:30 <timthelion> too bad haskell doesn't do the casting that C# does,
02:38:33 <siti> one good thing it haskells enums are strongly typed
02:38:44 <timthelion> (in c# you can cast a list to a combo box)
02:38:45 <goltrpoat> in the enum case, it's nice because you can endow individual enums with parameters, and you can do case analysis via pattern matching, etc
02:38:47 <siti> no it's a good thing it doesn't cast automatically :p
02:39:08 <timthelion> I can just imagine the combo box that enumerated as you scrolled through options
02:39:15 <goltrpoat> tim:  eh?  c# is fairly strict
02:39:39 <siti> are you actually talking about casting or a method in combo box that takes a list?
02:39:40 <timthelion> goltrpoat: the casting stuff is just candy
02:39:54 <timthelion> siti casting
02:40:04 <timthelion> which is just candy for calling the method
02:40:07 <timthelion> of course
02:40:09 <siti> sounds stupid :p
02:40:12 <goltrpoat> i'm pretty sure that casting a combo box to a List<> would be a pretty huge undertaking in c#
02:40:26 <goltrpoat> as in, you'd probably need to write a C++/cli layer for it
02:40:35 <goltrpoat> actually..  IntPtr, i guess.
02:40:41 <goltrpoat> still, certainly not "automatic"
02:41:09 <timthelion> I seem to remember doing that in VS2005
02:41:10 <goltrpoat> now, ComboBox.Items, that's a different story
02:41:10 <goltrpoat> heh
02:41:55 <goltrpoat> tim:  iirc, trying an implicit cast from byte to float will give you a compile error in c#
02:42:04 <goltrpoat> it's more typesafe than c++, if anything
02:43:53 <goltrpoat> every day, around 4:30am, the hdd on this machine goes insane.  nothing in the crontab, and ps -aux doesn't show anything.
02:44:07 <goltrpoat> it just sits there and spins for about half an hour
02:44:08 <nocturnal> check /etc/periodic/daily/
02:44:09 <goltrpoat> then stops.
02:44:30 <goltrpoat> no such beast.
02:44:40 <nocturnal> oops i thought iwas in ##freebsd
02:44:41 <nocturnal> sorry
02:44:44 <goltrpoat> hehe
02:49:39 <a-oXiDe> im trying to do a guarded statement that takes a list and returns a bool if something is an element, like this 'duplicateCheck (x:xs) | x==[]  = false' but i keep getting a not in scope error when i put in false and true, could anyone help?
02:50:10 <goltrpoat> are you sure about x == []
02:50:36 <a-oXiDe> yeah im using recursion, and want it to stop when the list is empty
02:50:49 <goltrpoat> yes, but "x == []" implies that x is a list itself
02:50:54 <goltrpoat> making x:xs a list of lists
02:51:41 <a-oXiDe> thats what i want, cause i want to compare x to every other element in the list then move onto the next element
02:51:45 <trurl> a-oXiDe: it's False, not false
02:52:29 <a-oXiDe> ah yeah, cheeers trurl
02:56:39 <void> Hi, How can I convert a Int to a Float? fromInt does not seem to work (ghc 6.6)
02:56:56 <stefanha> fromIntegral?
02:57:13 <void> well then I need to use Integral
02:57:23 <void> or hm, Integer
02:57:30 <ski_> instance Integral Int
02:57:54 <ski_> > fromIntegral (0 :: Int) :: Float
02:57:55 <lambdabot>  0.0
02:57:59 <void> yeah, fromIntegral works... thanks
03:01:34 <fuzan> Are there any amitted issues with GHC and IO with bytestring?
03:01:40 <fuzan> admitted, rather
03:06:02 <dons> fuzan, not that I know of
03:06:04 <dons> why do you ask?
03:06:15 <fuzan> I'm using putStrs, putStrLns, B.putStrLns, etc. It seems however that they don't work correctly after compiled. In ghci, they work fine.
03:06:33 <fuzan> for example,
03:06:34 <dons> what do you mean by "don't work correctly"
03:06:43 <dons> note that there are buffering differences between ghci and ghc
03:06:51 <dons> specifically, ghci is unbuffered, iirc.
03:06:59 <dons> but ghc requires you to set Nobuffered
03:07:07 <fuzan> ah
03:07:11 <fuzan> lets try that.
03:07:39 <dons> hSetBuffering NoBuffering
03:07:49 <dons> you're relying on strings to be printed before \n ?
03:08:37 <fuzan> yah. I"m using hFlush to force things out when I require input
03:09:02 <fuzan> but, for some odd reason, B.putStrLn's newline doesn't seem to do much.
03:11:24 <fuzan> NoBuffering performs as desired. I need to refresh myself on how IO works, heh.
03:14:48 <fuzan> dons: what is the deal with hmp3's ncurses binding?
03:15:02 <dons> more info please?
03:15:10 <fuzan> dons: is it used in anything other than hmp3?
03:15:26 <dons> nope. but its based on the one formerly used in yi
03:15:40 <dons> its actually quite a nice little curses binding. it should be split of and into its own lib
03:15:50 <dons> tinycurses or something
03:16:08 <fuzan> would you ever reccommend anyone to use it?
03:16:25 <dons> what?
03:16:33 <dons> the curses binding? yes.
03:16:37 <dons> needs work on refactoring
03:16:43 <dons> and vty might be easier to use these days
03:17:02 <dons> my next curses app would most likely tuse hmp3s's code
03:17:18 <der_igel> hi there, i need a little help: http://paste.lisp.org/display/37311
03:17:31 <der_igel> ghci 6.6 says:
03:17:40 <der_igel> `UnbalancedTree' is not applied to enough type arguments
03:17:50 <fuzan> it's odd that it isn't a little bit more supported/ developed though. I'd figure ncurses would be a bit more popular in the haskell crowd.
03:17:56 <der_igel> and i just can't see the mistake
03:18:25 <der_igel> btw, i started ghci with -fglasgow-exts
03:18:52 <dons> fuzan, there's hscurses
03:19:00 <dons> ?where hscurses
03:19:00 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
03:19:10 <dons> which is based on the one used by yi. hmp3's is also based on the yi one.
03:19:15 <dons> but yi now uses vty
03:19:20 <dons> as do some of the newer apps
03:19:47 <fuzan> Stefan O'Rear's vty?
03:20:18 <dons> yep
03:20:39 <fuzan> i'll look into it. havn't heard of vty at all before.
03:21:17 <dons> vty is a haskell termio lib
03:21:20 <dons> pure haskell all the way down
03:21:45 <dons> if you know curses though, hscurses should be fairly plug-n-play
03:23:25 <JohnMeacham> don't underestimate the need for looking at the terminfo.
03:23:25 <dons> der_igel: could you move the code to hpaste?
03:23:48 <dons> then at least it'll be tagged till someone is around to look at it
03:23:49 <der_igel> where is hpaste?
03:23:53 <fuzan> hpaste.org
03:24:13 <fuzan> it looks like youre missing an 'a' for Tree (Unbalanced) ...
03:24:52 <JohnMeacham> the important thing is that terminfo, stty, and your terminal agree on everything. there is no right value. it is a pet peeve of mine when sites tell you to set specific delete or F-key codes, the right answer is whatever your terminfo says. no matter what. sigh.
03:25:20 <der_igel> fuzan, yes thank you, but this leaves the same error message
03:26:01 <JohnMeacham> 'seven', a terminal emulator I wrote solves the issue by looking at the current systems terminfo and changing its behavior to match it, and modify the tty settings to match forcefully. makes everything work nicely. except when libraries ignore what they should... silly libraries. me drunk.
03:26:25 <dons> JohnMeacham: so i took the jhc libs from your site. haskell98 is only 4k?
03:27:19 <hpaste>  der_igel pasted "type sig error" at http://hpaste.org/638
03:27:58 <JohnMeacham> dons: yes. because it only re-exports names from base.
03:28:06 <dons> ok. good.
03:28:20 <trurl> der_igel: Tree (UnbalancedTree) a (UnbalancedTree a) -- here something is missing
03:28:27 <dons> JohnMeacham: i've taken the head jhc from darcs, and built it. the nobench suite is running now
03:28:58 <der_igel> trurl: yes, i already added the missing a, it didn't help
03:29:20 <der_igel> trurl: http://hpaste.org/638?lines=true
03:29:24 <JohnMeacham> cool. the head jhc should be good. I think. there is a major bug in the ghc back end dealing with error.. but it shouldn't make things any worse then they were before when it comes to how many compile.
03:30:06 <JohnMeacham> but nobench is good. it is getting me off my ass to actually write the mach 2 backend which I have been planning for a
03:30:09 <JohnMeacham> long time.
03:30:55 <dons> JohnMeacham: its worked better than I hoped, in that respect. we've had nhc, yhc, jhc and ghc patches :-)
03:31:10 <dons> and hbc is now in darcs
03:31:10 <JohnMeacham> dons: ah. did you standardize ghc as 1.0 now?
03:31:20 <dons> right. those are partial numbers from today
03:31:32 <JohnMeacham> dons: the compiler? awesome. it has been anoying that there was no 'central' place for it.
03:31:33 <dons> take ghc as 1.0, and then compute the geometric mean for each category, and overall
03:33:48 <JohnMeacham> ah. I have some stuff I want to use nobench for as a tool to help me develop. mainly some perl scripts that do things like let me choose what to run by regular expression, or set up various testing profiles and keep records of past runs... is that something you might want to see ported back to the main tree? I am not sure if it is geneally applicable unless another compiler writer would like them...
03:34:36 <JohnMeacham> or if you have moral objections to perl in the repo. (which I can understand. :) )
03:34:51 <dons> well , maybe :-)
03:35:02 <dons> there's no real reason to use perl ...
03:35:03 <trurl> der_igel: it works here
03:35:13 <dons> we store results now as .db files containing show/read structures
03:35:28 <dons> my plan is to then use those .db files to ananlyse previous runs and so on
03:35:59 <trurl> der_igel: (but i have to use -fglasgow-exts to allow multi-parameter classes)
03:36:02 <dons> running particular programs based on regex should be pretty easy
03:36:21 <JohnMeacham> dons: ah. well, this is stuff I just already wrote... actually, would it be possible to keep compile time (how long it took to compile) stats too?
03:36:42 <JohnMeacham> dons: seeing as how compile time is something I need to optimize more than run time at the moment :)
03:37:41 <JohnMeacham> hmm. hbc does well. are there some technical documents on its internals somewhere?
03:37:57 <dons> right. yes. i definitely want to add more statistics.
03:38:07 <dons> just modifying bin/bench.hs should be easy enough
03:38:22 <dons> it'd be 3 lines or so to add compile times. i'll do that
03:38:41 <dons> check the hbc site for all docs I know of. i imagine lennart wrote some papers too
03:38:58 <dons> we should really talk to him more about getting hbc into a state it can look after itself
03:39:31 <der_igel> turl: are you using ghc 6.6?
03:39:50 <trurl> der_igel: yes
03:39:55 <der_igel> i turned on -fglasgow-exts, too
03:40:01 <der_igel> hmm, me too
03:40:28 <pejo> dons, but who would maintai it? :-)
03:40:47 <dons> me
03:40:57 <dons> at least i'd try to keep it building
03:43:03 <Saizan> der_igel: if you comment all the class methods ghci can't know that s should be * -> *, so it defaults to *
03:43:45 <Saizan> it seems
03:44:13 <der_igel> ok...
03:44:31 <der_igel> uncommenting the emtpy-functions makes it work
03:44:46 <der_igel> but why didn't it work from the start?
03:45:41 <Saizan> at first you missed the "a" in the declaration of UnbalancedTree, then you commented.. maybe?
03:45:57 <der_igel> yes, that's true
03:46:01 <der_igel> you're right
03:46:09 <der_igel> it first was the missing a
03:46:22 <der_igel> and it happend to result in the same error message?
03:46:29 <Saizan> yes
03:47:01 <Saizan> well aside from the line number
03:47:53 <der_igel> ok then thank all of you :)
03:49:24 <Saizan> np :)
03:54:09 <a-oXiDe> is there anyway in haskell to map multiple numbers into a function eg a function that takes two parameters x+y and you have two lists [1,2][3,4] and want every combination of the two?
03:55:16 <Saizan> yes
03:55:44 <Saizan> > [ (x+y) | x <- [1,2] , y <- [3,4]]
03:55:46 <lambdabot>  [4,5,5,6]
03:57:07 <Saizan> > liftM2 (+) [1,2] [3,4] -- you need Control.Monad and Data.List for this
03:57:09 <lambdabot>  [4,5,5,6]
03:57:09 <nornagon> > do { x <- [1,2] ; y <- [3,4] ; x+y }
03:57:10 <lambdabot>   add an instance declaration for (Num [t])
03:57:10 <lambdabot>     In the expression: x + y
03:57:10 <lambdabot>     ...
03:57:23 <a-oXiDe> cheers saizan
03:58:00 <Saizan> > do { x <- [1,2] ; y <- [3,4] ; return $ x+y }
03:58:02 <lambdabot>  [4,5,5,6]
04:20:02 <ehird> who woke me from my infinite sleep
04:35:48 <emk> Morning.
04:36:21 <ehird> @src foldr
04:36:21 <lambdabot> foldr k z xs = go xs
04:36:23 <lambdabot>     where go []     = z
04:36:23 <lambdabot>           go (y:ys) = y `k` go ys
04:36:33 <ehird> infinitely useful function
04:52:21 <dons> JohnMeacham: so the nightly run is underway, jhc seems to be doing well so far, http://www.cse.unsw.edu.au/~dons/tmp/results.html
04:52:22 <lambdabot> Title: nobench: Haskell implementation shootout
04:52:24 <dons> great work!
04:57:05 <ehird> Exercises
04:57:05 <ehird> Write a foldr function treeFoldr for BinaryTrees and rewrite elements in terms of it (call the new one elements2). <-- isn't particularly specific...
04:57:46 <dons> so its asking you to walk a tree using a fold-like function.
04:57:59 <dons> and hmm, to modify elements of the tree, using the fold (instead of , say,  map)
04:58:02 <dons> i think.
04:58:05 <dons> :t foldr
04:58:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:58:27 <dons> so you want a,  (a -> b -> b) -> b -> Tree a -> b
04:58:40 <dons> where b is a Tree of some kind. does that sound right?
05:04:24 <astrolabe> ehird: what is the 'data' definition for your trees?
05:04:41 <ehird> data BinaryTree a = Leaf a
05:04:41 <ehird>                   | Branch (BinaryTree a) a (BinaryTree a)
05:04:41 <ehird>                   deriving (Show)
05:04:51 <astrolabe> dons: I don't think b should be a tree necessarily
05:05:05 <ehird> so - when folding a branch, do i do left and right, or include the value somehow? etc - it wasn't very specific, as you can see
05:05:28 <ehird> example definition would be Branch (Leaf 'H') 'e' (Leaf 'l')
05:05:46 <ehird> or: Branch (Branch (Leaf 1) 2 (Leaf 3)) 4 (Leaf 5) <-- for a nested tree
05:08:25 <astrolabe> I guess you need to pass your foldr a function b -> a -> b -> b for branches, and a function a -> b for leaves.
05:08:41 <Saizan> you can do that with only a function
05:09:03 <astrolabe> Saizan: how do you mean?
05:09:03 <ehird> hm, actually yes
05:09:20 <ehird> so pass the foldr <FUNCTION> blah <-- <FUNCTION> would get the whole branch?
05:09:26 <xpika> is there a predefined lift $ lift or do you roll your own?
05:09:27 <ehird> ah, it'd get left, x, right
05:09:38 <dons> xpika: you just rolled your own :-)
05:09:46 <Saizan> tfoldr f z (Branch l a r) = tfoldr f (f a (tfoldr f z right) left
05:10:15 <xpika> i just thought there might be something similar to the zips and liftM's
05:10:35 <Saizan> ehird: it should get the result of the foldr applied to left and right, not the tree themselves
05:10:44 <ehird> yes
05:11:16 <dons> there's some rather nice stuff in Data.foldable
05:11:17 <dons>     foldMap :: Monoid m => (a -> m) -> t a -> m
05:11:18 <dons>     foldMap f = foldr (mappend . f) mempty
05:11:19 <dons> and
05:11:24 <dons>     foldr :: (a -> b -> b) -> b -> t a -> b
05:11:25 <dons>     foldr f z t = appEndo (foldMap (Endo . f) t) z
05:11:43 <ehird> Saizan: thanks, it makes sense what he wanted now :P yaht is quite vague
05:12:39 <xpika> is there a backup of the nomaware site?
05:13:04 <astrolabe> I haven't found one
05:13:04 <xpika> i found one but its in japanese
05:13:57 <xpika> http://www.sampou.org/haskell/a-a-monads/html/
05:13:59 <lambdabot> Title: All About Monads
05:14:07 <xpika> at least the example files are in tact
05:14:08 <ehird> is there an official layout rule for wrapping?
05:14:14 <ehird> i.e. if my lines go above 80 characters
05:14:26 <ehird> or is it just "what looks best and is readable"
05:14:37 <astrolabe> ehird: I try to structure my code so that that doesn't happen
05:14:55 <astrolabe> where statements are useful in that regard
05:14:59 <ehird> don't think that's raelly possible in this case
05:15:15 <ehird> @src foldl
05:15:15 <lambdabot> foldl f z xs = lgo z xs
05:15:15 <lambdabot>     where lgo z []     =  z
05:15:15 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
05:15:21 <xpika> ehird: you can also use where{ } so it doesnt indent
05:15:33 <ehird> not even using `where` here
05:15:57 <astrolabe> ehird: I'd be interested to see an example where it wasn't possible (and a bit skeptical :) )
05:16:05 <astrolabe> @paste
05:16:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:16:22 <ehird> see Saizan's code :P
05:16:24 <ehird> above
05:17:02 <astrolabe> [13:07] Saizan: tfoldr f z (Branch l a r) = tfoldr f (f a (tfoldr f z right) left
05:17:05 <astrolabe> this?
05:17:12 <ehird> yes, except s/tfoldr/treeFoldr
05:17:30 <astrolabe> that's still a lot less than 80 chars
05:17:44 <ehird> treeFoldr k z (Branch left x right) = treeFoldr k (k x (treeFoldr k z right)) left <-- 83
05:17:46 <dons> ehird: in general, since you can break at arbitrary points in the code, and name arbitrary expressions, its rare to go past 80 columns :-)
05:18:35 <astrolabe> ehird: I may have misunderstood you when you said 'wrapping', but I don't think there is a standard
05:18:56 <ehird> wrapping, i.e. break at a certain point and indent to the same level
05:19:48 <astrolabe> I saw some comments about haskell layout style somewhere, maybe the wiki?
05:20:01 <astrolabe> @where wiki
05:20:02 <lambdabot> I know nothing about wiki.
05:20:04 <astrolabe> boo
05:20:12 <dons> treeFoldr k z (Branch left x right) = treeFoldr k (k x v)
05:20:13 <dons>     where v = treeFoldr k z right
05:21:07 <astrolabe> @where+ wiki http://www.haskell.org/haskellwiki/Haskell
05:21:07 <lambdabot> Done.
05:22:06 <ehird> oh boy, now i have to write a type signature
05:22:29 * ehird uses his inner understanding of brainfuck code to work out what it should be
05:24:25 <astrolabe> ehird: if you aren't sure, you can probably write the function and then ask an interpreter what the type is.
05:24:46 <ehird> it apparently guesses wrong, because it doesn't work
05:24:51 <ehird> and complains about types.
05:24:59 <nornagon> maybe you should've written the type first :)
05:25:02 <norpan> there is no guessing going on
05:25:24 <norpan> it's called inference
05:25:24 <astrolabe> ehird: you probably have a bug then, so it is a good idea to work out the type yourself.
05:26:32 <xpika> when is ghc 6.7 going to come out?
05:27:52 <astrolabe> or 6.8?
05:28:07 <astrolabe> It should have a debugger :)
05:28:50 <ehird> testing treeFoldr will be very hard without an empty binarytree creator, methinks...
05:30:58 <Saizan> isn't it treeFoldr :: (a -> b -> b) -> b -> Tree a -> b ?
05:31:23 <ehird> according to ghci, it's treeFoldr :: (t -> t -> t1) -> t1 -> BinaryTree t -> t
05:33:19 <Saizan> quite strange
05:33:52 <Saizan> how have you written the Leaf case?
05:34:51 <ehird> like this:
05:34:55 <ehird> treeFoldr k z (Leaf x) = x
05:35:01 <ehird> it's probably complaining about that, yes
05:35:06 <ehird> wait, it should be (Leaf x)
05:35:07 <ehird> doh
05:35:42 <astrolabe> Why should it be (Leaf x)?
05:36:00 <ehird> because it's being given a Leaf, therefore the place its in cannot hold simply x
05:36:47 <astrolabe> ehird: do you mean (Leaf x) on the right or the left of the '='?
05:36:51 <Saizan> shouldn't it be treeFoldr k z (Leaf x) = k z x?
05:37:03 <ehird> astrolabe: treeFoldr k z (Leaf x) = (Leaf x)
05:37:10 <ehird> Saizan: depends... possibly
05:37:31 <ehird> no, it doesn't like that - infinite type nonsense
05:37:36 <astrolabe> ehird: that could be right if you want to output a tree, but I don't think you do.
05:37:42 <ehird> astrolabe: yes, i do
05:37:47 <Saizan> ah right, it's k x z
05:37:52 <ehird> foldr takes a list and gives a list
05:38:01 <ehird> hm, well
05:38:01 <Saizan> foldr can give anything
05:38:03 <astrolabe> ehird: the standard foldr doesn't output a list.
05:38:05 <Saizan> ?type foldr
05:38:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:38:11 <ehird> hrm
05:38:33 <astrolabe> back to the drawing board!
05:38:55 <ehird> "write treeFoldr for something totally unlike a list" doesn't give for much drawing board space :P
05:39:13 <Saizan> a foldr recursively apply a funtion on all the elements inside a data structure
05:39:29 <ehird> yes
05:39:34 <syntaxfree> @instances Foldable
05:39:35 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
05:39:42 <Saizan> the "z" accumulator is just the recursive case
05:39:46 <syntaxfree> @instances Traversable
05:39:47 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
05:39:48 <ehird> but branches contain a left branch, a right branch, and a value
05:39:55 <ehird> which order? should you apply it to the value? ETC
05:40:07 <syntaxfree> @instances-importing Data.Traversable Traversable
05:40:08 <lambdabot> Maybe, []
05:40:25 <syntaxfree> @instances-importing Data.Traversable Foldable
05:40:27 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
05:40:43 <astrolabe> ehird: I agree, there is ambiguity.  I think you should choose one.
05:40:49 <Saizan> you can decide the order arbitrarly, but you have to apply to recurse on the branches and use the function on the value
05:41:08 <Saizan> s/to apply to recurse/to recurse/
05:41:22 <nornagon> @index fix
05:41:22 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
05:41:40 <ehird> wow, ghci, let me construct the goddamn infinite type just once, will you? this is a test function, it's MEANT to return its input
05:41:52 <nornagon> > fix (Just.)
05:41:53 <lambdabot>      Occurs check: cannot construct the infinite type: b = Maybe b
05:41:53 <lambdabot>       Expe...
05:41:55 <nornagon> aw.
05:43:09 <ehird> treeFoldr (\x t -> [x, t]) 0 (Branch (Leaf 1) 2 (Leaf 3) 4 (Leaf 5))  <-- stupid treeFoldr :P
05:43:17 <ehird> oh, wait, aha
05:43:23 <syntaxfree> @instances Data.Foldable Foldable
05:43:24 <lambdabot> Couldn't find class `Data.Foldable Foldable'. Try @instances-importing
05:43:32 <syntaxfree> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
05:43:35 <lambdabot> http://tinyurl.com/2xwe3t
05:43:36 <ehird> syntaxfree: the point was you're supposed to write your own.
05:43:49 <syntaxfree> :)
05:43:54 <ehird> tutorial excersize presumably doesn' mean "just add a line to make this foldable!" ;P
05:44:12 <syntaxfree> is map/foldr-build fusion performed on instances of Foldable already?
05:44:42 <syntaxfree> "Many of these functions generalize Prelude, Control.Monad and Data.List functions of the same names from lists to any Foldable functor. To avoid ambiguity, either import those modules hiding these names or qualify uses of these function names with an alias for this module." <-- when will this be fixed?
05:47:04 <Saizan> fixed?
05:47:07 <dons> syntaxfree: nope.
05:47:16 <dons> i don't think there is any general fusion on foldable for now
05:48:34 <allbery_b> seems to me the only way to "fix" that is to make the Prelude versions the more general Foldable ones, but that is almost certainly a nonstarter
05:48:43 <allbery_b> (cf the map / fmap arguments)
06:00:36 <hpaste>  (anonymous) pasted "newtype deriving + existential type + failure to derive" at http://hpaste.org/639
06:27:49 <ehird>     Couldn't match expected type `t1 -> BinaryTree t2 -> t'            against inferred type `BinaryTree t3'    In the expression: (Branch (Leaf 1) 2 (Leaf 3) 4 (Leaf 5))
06:27:50 <ehird> very odd
06:27:55 <ehird> worked a minute ago
06:29:16 <quicksilver> :t Branch
06:29:26 <lambdabot> Not in scope: data constructor `Branch'
06:30:17 <quicksilver> if it's binary tree how can it have 5 branches?
06:31:24 <quicksilver> surely you mean something like Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Branch (Leaf 4) (Leaf 5))
06:33:43 <chessguy> 'morning haskellers
06:33:47 <ehird> quicksilver: its in my code
06:33:49 <ehird> and it worked
06:33:54 <ehird> and i wrote hte type....
06:34:01 <ehird> so i don't know why it would di
06:34:05 <ehird> ah, i see
06:34:09 <ehird> wrong parantheses
06:34:50 <ehird> ok, treeFoldr works
06:35:03 <pjd> newtype (Integral a) => PrimalRatio a = [a]
06:35:07 <pjd> why doesn't that work?
06:35:30 <Saizan> you miss a constructor
06:35:39 <Saizan> newtype (Integral a) => PrimalRatio a = PR [a]
06:36:23 <chessguy> hmm. technically [] is a constructor
06:36:45 <allbery_b> yes, but it's already in use :)
06:36:59 <pjd> oh, so newtype must introduce a new constructor?
06:37:05 <Saizan> it's not a contructor of PrimalRation :)
06:37:10 <Saizan> yes
06:37:15 <Saizan> and only one
06:37:31 <pjd> ok, i was going along the logic that "type PrimalRatio a = [a]" works
06:38:09 <chessguy> that's because then PrimalRation is just a synonym for a lit
06:38:11 <chessguy> list
06:38:28 <chessguy> you're not constructing a new type
06:38:32 <pjd> (it's not possible to use "type" to declare something using a type class, right?)
06:40:16 <allbery_b> it is with -fglasgow-exts but it almost certainly won't do what you expect:  the scope of the typeclass will be restricted to the type declaration, so it won't unify with any other occurrences in a *use* of your type
06:41:37 <pjd> allbery_b: hmm, can you give an example of that?
06:42:34 <allbery_b> if I say:  type S = Foo a => [a]; f :: S -> S
06:42:59 <allbery_b> ghc sees:  f :: (forall a. Foo a => [a]) -> (forall a. Foo a => [a])
06:43:26 <allbery_b> (in haskell98 those forall-s are implicit...)
06:43:40 <pjd> oh, so they can have different instances
06:43:47 <allbery_b> right
06:44:42 <allbery_b> now, you may want that to happen, but generally you don't
06:45:06 <ehird> qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs) <-- now that's a small qsort
06:45:32 <xerox> It needs a previous |qsort [] = []| clause.
06:46:02 <pjd> hmm, it makes sense from the view that "type" declarations must be substitutable with their bodies, and vica versa
06:46:04 <quicksilver> and it's pathological on already sorted lists
06:46:14 <allbery_b> right
06:46:30 <pjd> @pl qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
06:46:34 <lambdabot> qsort = fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))
06:46:47 <xerox> That doesn't work.
06:46:57 <ehird> xerox: yes, i ommited the [] = [] claue
06:47:00 <ehird> to avoid flooding
06:47:13 <xerox> I mean the pl output.
06:47:31 * pjd runs off to the shop
06:47:37 <allbery_b> no?
06:48:02 <allbery_b> (well, it needs both -fno-monomorphism-restriction and `import Control.Monad.Reader'...)
06:48:13 <xerox> allbery_b: nope.
06:48:36 <ehird> what does pl do?
06:48:42 <ehird> @pl 1+1
06:48:43 <lambdabot> 2
06:48:51 <Saizan> @help pl
06:48:51 <lambdabot> pointless <expr>. Play with pointfree code.
06:49:07 <ehird> that totally tells you what it does :P
06:49:12 <ehird> it seems to convert args to .
06:49:13 <ehird> @pl fac n = product[1..n]
06:49:14 <lambdabot> fac = product . enumFromTo 1
06:49:15 <Saizan> :D
06:49:15 <xerox> ehird: it does reduce a given haskell expression to a combinator. That is, it eliminates its formal arguments.
06:49:21 <ehird> thought so
06:49:31 * ehird considers feeding it something complex, like ghc source
06:49:53 <ehird> @src getLine
06:49:54 <lambdabot> getLine = hGetLine stdin
06:50:00 <ehird> @src hGetLine
06:50:01 <lambdabot> Source not found. You speak an infinite deal of nothing
06:50:15 <ehird> @src putStr
06:50:15 <lambdabot> putStr s  = hPutStr stdout s
06:50:18 <ehird> @src hPutStr
06:50:19 <lambdabot> Source not found. I feel much better now.
06:50:19 <xerox> ehird: it's a theorem that every lambda-calculus expression can be translated in the SKI-calculus. Beautiful result.
06:50:20 <ehird> bah
06:50:27 <chessguy> so, anybody got a rose tree zipper lying around?
06:50:40 <allbery_b> ehird: there's a reason it's called "pointless" :)
06:50:55 <ehird> the whole bot is pointless, but that doesn't stop me trying to break it
06:51:10 <ehird> pointless + giving yourself a point - the point being to confuse the bot = bot now has point
06:51:15 <allbery_b> there *are* some arguments for using point-free code, but in general you don' want to bother when it produces something like that
06:51:27 <allbery_b> @quote flip-stream
06:51:28 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
06:51:57 <chessguy> allbery_b, sometimes it produces really good code
06:52:11 <quicksilver> just as a c programmer might transform a = b(x); c = d(y); return e(a,c)
06:52:23 <quicksilver> into return e(b(x),d(y))
06:52:33 <quicksilver> sometimes it's more elegant not to be forced to name intermediate values
06:52:35 <allbery_b> sure, sometimes
06:52:45 <quicksilver> othertimes it makes you code clearer if you do
06:53:14 <MarcWebe1> Have you ever seen this error message in ghc ? >>My brain just exploded.<< lol
06:53:30 <allbery_b> !
06:53:49 <allbery_b> shades of "lint's little mind is blown!"
06:56:42 <ehird> @pl fac = product . enumFromTo 1
06:56:43 <lambdabot> fac = product . enumFromTo 1
06:56:45 <ehird> heh.
06:57:39 <ehird> @src foldl
06:57:39 <lambdabot> foldl f z xs = lgo z xs
06:57:39 <lambdabot>     where lgo z []     =  z
06:57:39 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
06:57:58 <ehird> @pl foldl f z xs = lgo z xs where lgo z [] = z; lgo z (x:xs) = lgo (f z x) xs
06:57:58 <lambdabot> (line 1, column 40):
06:57:58 <lambdabot> unexpected "="
06:57:58 <lambdabot> expecting variable, "(", operator or end of input
06:58:01 <ehird> bah.
06:58:18 <ehird> @pl foldl f z xs = lgo z xs where { lgo z [] = z; lgo z (x:xs) = lgo (f z x) xs }
06:58:19 <lambdabot> (line 1, column 31):
06:58:19 <lambdabot> unexpected "{"
06:58:19 <lambdabot> expecting variable, "(", operator or end of input
06:58:22 <ehird> :/
06:59:06 <Saizan> @pl foldl f z xs = lgo z xs where lgo z [] = z
06:59:07 <lambdabot> (line 1, column 40):
06:59:07 <lambdabot> unexpected "="
06:59:07 <lambdabot> expecting variable, "(", operator or end of input
06:59:19 <Saizan> it doesn't like where
06:59:35 <Saizan> (nor triplets, btw)
06:59:38 <ehird> @pl foldl f z xs = let  lgo z [] = z; lgo z (x:xs) = lgo (f z x) xs in lgo z xs
06:59:38 <lambdabot> (line 1, column 14):
06:59:39 <lambdabot> unexpected "="
06:59:39 <lambdabot> expecting variable, "(", operator or end of input
06:59:43 <ehird> stupid thing
07:00:05 <EvilTerran> qsort [] = []; qsort (x:xs) = uncurry (++) . (qsort *** (x:).qsort) . partition (<x) $ xs in qsort [10,9.. -2]
07:00:23 <ehird> @pl qsort [] = []; qsort (x:xs) = uncurry (++) . (qsort *** (x:).qsort) . partition (<x) $ xs in qsort [10,9.. -2]
07:00:23 <lambdabot> (line 1, column 10):
07:00:24 <lambdabot> unexpected "="
07:00:24 <lambdabot> expecting variable, "(", operator or end of input
07:00:28 <ehird> useless
07:00:37 <EvilTerran> whups, left the "in" on
07:00:41 <EvilTerran> @pl qsort [] = []; qsort (x:xs) = uncurry (++) . (qsort *** (x:).qsort) . partition (<x) $ xs
07:00:42 <lambdabot> (line 1, column 10):
07:00:42 <lambdabot> unexpected "="
07:00:42 <lambdabot> expecting variable, "(", operator or end of input
07:00:50 <ehird> doesn't like multiple statements
07:00:51 <Saizan> it's for one liner, not for whole definitions
07:00:56 <ehird> @pl qsort (x:xs) = uncurry (++) . (qsort *** (x:).qsort) . partition (<x) $ xs
07:00:56 <lambdabot> (line 1, column 14):
07:00:56 <lambdabot> unexpected "="
07:00:56 <lambdabot> expecting variable, "(", operator or end of input
07:01:06 <ehird> @pl uncurry (++) . (qsort *** (x:).qsort) . partition (<x) $ xs
07:01:06 <lambdabot> (line 1, column 31):
07:01:06 <lambdabot> unexpected "."
07:01:06 <lambdabot> expecting variable, "(", "!!", white space, operator or ")"
07:01:06 <lambdabot> ambiguous use of a right associative operator
07:01:22 <MarcWebe1> What is a escaped type variable?
07:01:44 <EvilTerran> @pl \(x:xs) -> uncurry (++) . (qsort *** (x:) . qsort) . partition (<x) $ xs
07:01:45 <lambdabot> (line 1, column 43):
07:01:45 <lambdabot> unexpected "."
07:01:45 <lambdabot> expecting variable, "(", "!!", space, operator or ")"
07:01:45 <lambdabot> ambiguous use of a right associative operator
07:02:22 <Saizan> @pl \(x:xs) -> uncurry (++) . ((qsort *** (x:)) . qsort) . partition (<x) $ xs
07:02:23 <lambdabot> ap ((uncurry (++) .) . ap ((.) . (. qsort) . (qsort ***) . (:)) (partition . flip (<)) . head) tail
07:02:46 <Saizan> MarcWebe1: are you using existential types?
07:03:53 <EvilTerran> Saizan, ((qsort *** (x:)) . qsort) should be (qsort *** ((x:) . qsort)). and it seems that's how lambdabot's ">..." interprets it, too.
07:04:06 <EvilTerran> so i don't know why @pl can't cope.
07:04:37 <quicksilver> @pl doesn't have a real haskell parser
07:04:37 <lambdabot> doesn't have a real haskell parser
07:04:39 <quicksilver> it's a hack
07:04:52 <quicksilver> a surprisingly effective one :)
07:04:58 <EvilTerran> i see.
07:05:14 <EvilTerran> @pl \(x:xs) -> uncurry (++) . (qsort *** ((x:).qsort)) . partition (<x) $ xs
07:05:14 <lambdabot> ap ((uncurry (++) .) . ap ((.) . (qsort ***) . (. qsort) . (:)) (partition . flip (<)) . head) tail
07:05:16 <xerox> It's not a "hack".
07:05:24 <quicksilver> xerox: the parsing is a hack
07:05:35 <Saizan> however, reading the (line 1, column 31): just pointed to the guilty point :)
07:07:32 <xerox> The plugin does do a untyped transformation on the given expression. That is the same kind of process that the compiler performs on `do' blocks.
07:11:33 <hpaste>  Marc Weber pasted "My brain just exploded" at http://hpaste.org/640
07:12:41 <hpaste>  Marc Weber annotated "My brain just exploded" with " Cannot use record selector `ra' as a function due to escaped type variables" at http://hpaste.org/640#a1
07:13:41 <MarcWebe1> @ Saizan Thats my source ;) I'm beeing faced with never seen compiler errors again and again ;) I think this means my skills are enhancing step by step ;)
07:14:03 <MarcWebe1> Yes I'm using them.
07:14:28 <Saizan> what's ra?
07:15:08 <MarcWebe1> Saizan: have look at data ActionMonad { ra :: ...
07:15:40 <Cale> case f of ActionMonad r -> runReaderT r (HCons (D1 2) HNil)
07:15:41 <Cale> ?
07:17:13 <TomMD> > 1 + 1
07:17:14 <lambdabot>  2
07:17:18 <MarcWebe1> Cale, I don't get your question. I've introduced f to give an explicit type annotation
07:17:48 <Cale> MarcWebe1: that's as a replacement to the runReaderT (ra f) (...)
07:18:36 <Cale> It's saying you can't use ra as a record selector because it can't define a function of appropriate type to do that.
07:18:45 <allbery_b> seems t me this is like trying to peek inside an ST (and for the same reason; the point of existential qualification is to prevent you from doing so)
07:18:59 <Cale> So use case to get the thing out locally instead.
07:19:00 <MarcWebe1> All I want to have is a multi typed reader environment .. This way it would be easy to add / remove values..
07:19:24 <Cale> ah, there's a much simpler way to manage this
07:19:28 <xerox> :t Control.Monad.Reader.local
07:19:30 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
07:19:42 <xerox> Nevermind.
07:19:55 <Cale> local doesn't change the type, only the value locally.
07:20:10 <xerox> Just noticed. I thought it could.
07:20:31 <MarcWebe1> Cale: But that's not exactly what I want.
07:20:36 <Cale> But what you can do is to simply create your own record type, and add appropriate fields to it.
07:21:07 <Cale> (and don't pattern match on it, use the selectors)
07:21:51 <allbery_b> @ghc+ My brain just exploded.
07:21:51 <lambdabot> ghc says: My brain just exploded.
07:22:03 <ehird> @test+ test?
07:22:03 <lambdabot> Unknown command, try @list
07:22:06 <ehird> hmph
07:22:06 <allbery_b> hm, I assume that means it was already in there
07:22:09 <MarcWebe1> Cale: And what to do if I notice that I need another field? but not everywhere?
07:22:16 <allbery_b> and there is no @ghc+
07:22:17 <ehird> @help ghc+
07:22:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:22:20 <allbery_b> @list ghc
07:22:21 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
07:22:32 <ehird> @yhjulwwiefzojcbxybbruweejw
07:22:32 <lambdabot> "\"#$%&'()*+,\""
07:22:36 <ehird> what the
07:22:52 <fasta> "(the Coverage Condition fails for one of the functional dependencies)" What exactly is this condition?
07:23:23 <ehird> @yhjulwwiefzojcbxybbruweejw
07:23:23 <lambdabot> Exception: <<loop>>
07:23:26 <allbery_b> ehird: old story.  shrt version is:  there used to be a bug in lambdabot which provided some amusement
07:23:33 <ehird> ...... does it execute random code or something?
07:23:41 <allbery_b> @help v
07:23:41 <lambdabot> let v = show v in v
07:23:46 <quicksilver> cover condition: if you are claiming that a -> b, then all types in b must be explicitly (syntactically) mentioned in a
07:23:49 <sorear> hello
07:23:50 <ehird> @src v
07:23:51 <lambdabot> Source not found. My pet ferret can type better than you!
07:24:05 <allbery_b> @help yhjulwwiefzojcbxybbruweejw
07:24:05 <sorear> @where lambdabot
07:24:06 <lambdabot> V RETURNS!
07:24:06 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
07:24:09 <TomMD> sorear: I was wondering when you would get here.
07:24:13 <sorear> Plugin/Quote.hs
07:24:18 <allbery_b> mrrrrf.  think my server is biting the dust...
07:24:33 <sorear> @userws
07:24:34 <lambdabot> Maximum users seen in #haskell: 329, currently: 320 (97.3%), active: 31 (9.7%)
07:25:03 <ehird> Lambdabot is a Haskell development tool, written in Haskell. It operates as a command line tool, embedded in an editor, embedded in GHCi, via internet relay chat and on the web. <-- lambdabot runs in emacs?
07:25:06 <ehird> say it ain't so!
07:25:29 <hpaste>  Marc Weber annotated "My brain just exploded" with "adding another var to environment. This is how I 'd like it to have ;)" at http://hpaste.org/640#a2
07:25:55 <chessguy> xerox, this is weird
07:26:16 <xs> ehird, it's most likely to be talking about a yi embedding, no?
07:26:26 <ehird> xs: well i have no idea
07:26:32 <quicksilver> well lambdabot runs in ghci in emacs, at least
07:26:36 <ehird> @v
07:26:37 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
07:26:38 <quicksilver> since personally I always run ghci in emacs...
07:26:39 <xerox> Indeed!
07:26:49 <ehird> let v = show in show v should produce... more than that
07:26:54 <astrolabe> I expect if it says it runs in emacs, that it runs in emacs.
07:26:58 <xerox> > fix show
07:26:59 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:26:59 <ehird> s/show in show v/show v in v
07:27:18 <ehird> what does `fix' do?
07:27:20 <xerox> chessguy: what happens.
07:27:30 <xerox> ehird: it does general recursion
07:27:32 <xerox> @src fix
07:27:32 <lambdabot> fix f = let x = f x in x
07:27:32 <Saizan> ?src fix
07:27:33 <lambdabot> fix f = let x = f x in x
07:27:39 <ehird> > fix fix
07:27:40 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
07:27:40 <xerox> jinx!
07:27:41 <lambdabot>     Probabl...
07:27:52 <ehird> > fix (fix (fix show))
07:27:53 <lambdabot>  Couldn't match expected type `a -> a'
07:27:55 <ehird> aw
07:28:03 <xerox> ehird: you can lift every top-level defined function to its fixpoint very easily.
07:28:08 <chessguy> this Zipper has an implementation for a custom tree with arbitrary number of branches
07:28:19 <chessguy> why not just define it for Data.Tree then?
07:28:25 <xerox> chessguy: What is "this Zipper" ?
07:28:58 <xerox> ehird: want to see an example?
07:29:19 <chessguy> Zipper and ZipperBTree from the library at http://www.haskell.org/haskellwiki/Zipper_monad
07:29:20 <lambdabot> Title: Zipper monad - HaskellWiki
07:29:23 <xs> xerox, i presume huet's zipper. it allows you to mutate a data structure whilst sharing as much of the original structure with the new structure as possible
07:29:57 <fasta> xs: did he prove that?
07:30:16 <xs> fasta, what?
07:30:18 <xerox> chessguy: yeah, that one is a very thin layer.
07:30:30 <fasta> xs: "whilst sharing as much of the original structure with the new structure as possible"
07:30:52 <a-oXiDe> i am really confused and was wondering if anyone can help, if i have a list of lists and want to convert all the values in the list to a data type, how would i go about extracting the different values singularly from the list of lists and once ive converted putting all the values back in respective places to where they were extracted?
07:30:58 <Cale> MarcWebe1: well, in the course of a single ReaderT, you can have only one environment type anyway
07:31:01 <xs> fasta, i don't. didn't read the original paper. sorry. but most implementations seem to.
07:31:10 <Cale> a-oXiDe: map
07:31:16 <chessguy> a-oXiDe, map map
07:31:20 <sorear> map . map
07:31:20 <Cale> > map (*2) [1..10]
07:31:23 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
07:31:25 <xerox> xs - That's a good description. I just thought about it as a View on Trees.
07:31:29 <chessguy> Cale, [[a]]
07:31:38 <Cale> > map (+5) [[1..10],[2..20]
07:31:39 <lambdabot>  Parse error
07:31:44 <Cale> > map (map (+5)) [[1..10],[2..20]]
07:31:46 <lambdabot>  [[6,7,8,9,10,11,12,13,14,15],[7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,2...
07:31:47 <sorear> > (map . map) (*2) [[1,2,3],[4,5,6,7,8]]
07:31:49 <lambdabot>  [[2,4,6],[8,10,12,14,16]]
07:31:57 <xerox> Indeed.
07:32:01 <astrolabe> Did anyone understand a-oXiDe's question?
07:32:04 <allbery_b> lambdabot doesn't run in emacs normally but there are tools for interfacing it to emacs (and to vim)
07:32:12 <allbery_b> abnd to ghci (goa)
07:32:17 <chessguy> astrolabe, like 4 people just answered it :)
07:32:24 <a-oXiDe> yeah cheers for that
07:32:35 <Cale> a-oXiDe: but the basic thing you need to know about is map :)
07:32:36 <chessguy> xerox, i just don't get why you'd write your own custom Tree that's so close to a Data.Tree
07:32:38 <astrolabe> chessguy: ah :)
07:32:48 <Cale> map f [] = []
07:32:55 <Cale> map f (x:xs) = f x : map f xs
07:33:05 <sorear> @src map
07:33:06 <lambdabot> map _ []     = []
07:33:06 <lambdabot> map f (x:xs) = f x : map f xs
07:33:10 <Cale> It applies a function to each element of a list.
07:33:29 <sorear> :t map
07:33:32 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:33:38 <astrolabe> who needs lambdabot when you have Calebot?
07:33:43 <Cale> (I don't trust @src to give informative code, look what it does with foldr)
07:33:44 <chessguy> :t (map.map)
07:33:47 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
07:33:52 <xerox> chessguy: I am confused.  Do you think that is the whole code?
07:34:02 <ehird> Cale: what does it do with foldr?
07:34:03 <ehird> @src foldr
07:34:03 <lambdabot> foldr k z xs = go xs
07:34:04 <lambdabot>     where go []     = z
07:34:04 <lambdabot>           go (y:ys) = y `k` go ys
07:34:07 <ehird> seems right to me
07:34:18 <Cale> It's right, but it's not what you'd want to see.
07:34:21 <astrolabe> right but complicated
07:34:29 <Cale> foldr f z [] = z
07:34:38 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
07:34:38 <Orphi> "Haskell" and "complicated" in the same sentense... scary
07:34:39 <chessguy> xerox, in the library link there, there's a file called ZipperBTree.hs
07:34:42 <Cale> that's what you want.
07:34:53 <Cale> In order to understand foldr, anyway
07:34:57 <xerox> chessguy: AH, I have never seen the contents of the zip file.
07:35:08 <astrolabe> Orphi: I only meant relatively complicated :)
07:35:28 <chessguy> in that file he has data BTree a = Leaf a | Branch [BTree a] deriving (Show, Eq)
07:35:31 <resiak> Is there any real gain in making the first clause of map "map _ []" instead of "map f []"?
07:35:44 <xerox> Readability.
07:35:44 <Orphi> how does it go? "Haskell makes difficult things easy, and impossible things possible?"
07:35:48 <chessguy> which is so close to Data.Tree, it's silly
07:36:32 <astrolabe> Although looking more closely, I might prefer @src's definition.
07:36:51 <Orphi> @src mapM_
07:36:51 <lambdabot> mapM_ f as = sequence_ (map f as)
07:36:56 <chessguy> ?quote perl
07:36:56 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
07:36:57 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
07:36:57 <lambdabot> he was one of the pugs de
07:36:58 <xerox> chessguy: want to port it to Data.Tree?
07:37:01 <chessguy> yikes
07:37:06 <chessguy> xerox, that's what i'm thinking
07:37:07 <syntaxfree> Haskell makes algebraic things programmatical and categorical things monadic ; )
07:37:19 <chessguy> just type BTree a = Tree a
07:37:27 <chessguy> and see what breaks
07:37:31 <Orphi> OK, I'm in pain...
07:37:39 <sorear> type BTree = Tree -- much better
07:37:48 <xerox> chessguy: I think there's a difference
07:38:14 <chessguy> xerox, yes, there are a few
07:38:26 <xerox> Data.Tree carries a value and the subtrees in every branch, this has no value on the branches.
07:38:36 <chessguy> his trees only have labels on the leaves, and his leaves are defined the same way as the rest of his nodes
07:38:38 <xerox> I wonder why it doesn't.
07:38:59 <chessguy> err, Data.Tree's leaves are define the same way as the rest
07:39:04 <ehird> @pl mapM_ f as = sequence_ (map f as)
07:39:05 <lambdabot> mapM_ = (sequence_ .) . map
07:39:21 <ehird> that looks wrong?
07:39:28 <xerox> chessguy: what do you mean?
07:39:32 <chessguy> ?seen dmhouse
07:39:33 <lambdabot> I saw dmhouse leaving #happs, #haskell-blah and #haskell 16h 1m 2s ago, and .
07:39:40 <Orphi> Haskell == weapon of mass destruction
07:39:47 <chessguy> xerox, Data.Tree has a single constructor, iirc
07:39:57 <xerox> chessguy: A Data.Tree "Leaf x" is a |Node x []|.
07:40:06 <chessguy> right
07:40:18 <chessguy> whereas these BTrees have two different constructors
07:40:33 <xerox> Yes.
07:40:47 <xerox> I will try to write one.
07:40:56 <chessguy> one what?
07:41:13 <xerox> A zipper, one for Data.Tree.
07:41:22 <chessguy> oh, i'm working on porting this one
07:41:59 <chessguy> unless you particularly want to do it
07:42:11 <Orphi> hey guys... I have a kinda complicated question that's making my brain hurt
07:42:20 <Orphi> not sure if I can explain what I'm trying to do...
07:42:21 <sorear> ask it!!!
07:42:35 <Orphi> I have a list of predicates, each with an associated function
07:42:52 <sorear> it just gets on my nerves when people ask to ask :(
07:42:53 <Orphi> I want to take a list, find the first element to satisfy ANY predicate, and chop the list at that point
07:43:05 <Orphi> then I want to apply the associated function to what's left of the lsit
07:43:20 <Orphi> ...if that makes any sense!
07:43:29 <sorear> perfect sense
07:43:52 <sorear> what if no element satisfies any predicate?
07:43:52 <Orphi> I can think of ways to do it, but I can't think of a "good" way
07:44:07 <Orphi> the list is finite; if no predicate is satified, use a default answer
07:44:31 <sorear> a default function you mean?
07:44:33 <Cale> dropWhile (\x -> not (any (map ($ x) ps))) xs
07:44:44 <chessguy> xerox ?
07:44:51 <Cale> Where ps is the list of predicates, and xs is the list of values?
07:44:58 <Orphi> let me parse that...
07:44:58 <chessguy> ?pl  (\x -> not (any (map ($ x) ps)))
07:44:59 <lambdabot> not . any . flip map ps . flip id
07:45:02 <sorear> Cale: not with the last clause
07:45:13 <sorear> @ty find
07:45:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:45:24 <Cale> Okay, well, you'd have to do something else in the empty case.
07:45:40 <xerox> chessguy: working on it right now.
07:46:07 <hpaste>  fasta pasted "MPTCs + FDs + existential types + defining instance" at http://hpaste.org/641
07:46:12 <chessguy> xerox, oh, ok. i guess i won't write it then
07:46:33 <sorear> -fallow-undecidable-instances
07:46:38 <Orphi> hmm... I don't think that works
07:46:52 <fasta> I have no idea what else I can do to make it work. Please, have a look at it.
07:46:55 <sorear> wait no
07:47:12 <sorear> fasta: why do you have the fundeps?
07:47:34 <Orphi> takeWhile (\x -> not (any (map $ x) ps))) xs -- gives me the shortest list such that the next element satisfies any predicate (?)
07:47:54 <Orphi> but now how do I figure out WHICH predicate it satisfied, so I can find the right associated fn to apply? ;-)
07:48:47 <fasta> sorear: not a very fundamental reason, but lets say g is (MyGraph some_label_type some_edge_label_type), then a should be equal to some_label_type etc.
07:48:48 <sorear> fasta: sorry, it can't be made to work.  since EGraph is existential in a, there is no way for add_with_position_vertex to know what type of label to use.
07:49:17 <sorear> fasta: what are you trying to do (that motivated you to use existentials)?
07:49:28 <fasta> sorear: the real problem is that I want to be able to write:
07:50:27 <fasta> foo = do
07:50:27 <fasta>  put (undefined::EGraph Int String)
07:50:27 <fasta>  put (undefined::EGraph String Int)
07:50:27 <fasta>  
07:50:27 <fasta> I.e. changing the type of graph in the state of a state monad. (well, I really need it in my own monad, but that shouldn't be that difficult then.
07:50:28 <Orphi> I could do a takeWhile with each possible predicate and then figure out which list is shortest
07:50:29 <fasta>  
07:50:32 <Orphi> but it's not efficient.
07:51:08 <sorear> fasta: do all the graphs use the same label types?
07:51:16 <fasta> sorear: no
07:51:55 <Orphi> work :: [(t -> Bool, [t] -> u)] -> [t] -> u
07:51:57 <sorear> fasta: at any given point in your code, is the graph type fixed a-priori?
07:53:31 <Orphi> mmm... it's a kinda complicated problem. maybe I should try the maillling list...
07:54:03 <fasta> sorear: I am not sure what you mean
07:54:15 <fasta> sorear: I will give an example.
07:54:32 <fasta> --(\g-> ( Gen.set_constant_value_for_edges ("1"))   $ (Gen.set_constant_value_for_edges (1::Int))$ EGraph $ Gen.convert_undirected_graph_to_directed g) :: (Gr g) => g a b -> EGraph a [Char]
07:54:43 <fasta> This code works
07:54:47 <Orphi> x_x
07:55:04 <fasta> Problem is that the graph type is manually threaded
07:55:31 <Orphi> ok, this is getting scary... later peeps!
07:55:35 <fasta> So, I want a monadic solution in which graph is automatically threaded
07:55:48 <fasta> s/graph type/graph
07:56:20 <fasta> (this was with a different type class signature, but I am sure you can understand the reasoning)
07:56:29 <fasta> sorear: see?
07:57:07 <sorear> there was a discussion in the ml a couple weeks back about safe type-shifting state monads ...
07:57:32 <fasta> sorear: I know, but I tried to find the message two times already, and couldn't find it.
07:58:14 <fasta> I also believe that it's not a monad anymore then.
07:58:27 <sorear> right :(
07:58:43 <fasta> If there's no way to do without a monad, then so be it, though
07:59:36 <sorear> how about (.) ?
07:59:42 <SamB> well, it could be a monad family
07:59:42 <sorear> @ty (.)
07:59:44 <MarcWebe1> Cale of course I can have only one reader env type in monad. but I can write tronsformers and lift the others adding additional environment vars, can't I?
07:59:45 <SamB> couldn't it?
07:59:45 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:00:01 <sorear> > ((1:) . (2:)) [4]
08:00:02 <lambdabot>  [1,2,4]
08:00:15 <Cale> MarcWebe1: You mean wrapping readers in reader transformers?
08:00:16 <SamB> with a special function to join an action from one family with a continuation from another
08:00:42 <Cale> MarcWebe1: If it's a reader monad anyway, it might just be easier to use function parameters too.
08:00:45 <fasta> sorear: that was for me?
08:01:27 <sorear> yeah
08:01:52 <xerox> sorear: function composition / application is what is really behind monads too :)
08:02:05 <fasta> sorear: ok, but I also like to use callCC
08:02:06 <SamB> fasta: why do you want to do that?
08:02:19 <SamB> that stuff with the varying state types?
08:02:31 <Cale> Overusing this machinery can get you code which is actually less maintainable than writing it the plain way.
08:02:39 <chessguy> anybody know what time zone the timestamps on the logs are recorded in?
08:02:49 <fasta> SamB: because otherwise, I need to do run_graph everytime I want to switch type.
08:02:51 <sorear> fasta: http://www.haskell.org/pipermail/haskell-cafe/2006-December/020615.html
08:02:54 <lambdabot> Title: [Haskell-cafe] rebinding >>= for restricted monads, http://tinyurl.com/2523q2
08:03:01 <fasta> SamB: and I need to switch type quite a lot.
08:03:03 <Cale> If you're going to go about using monad transformers, you might want to read my article about how to do it effectively :)
08:03:11 <sorear> there's the post you were trying to find
08:03:28 <MarcWebe1> Cale: I've tried writing down what I had in mind in my last annotation (17:23). You are right. I could add parameters but I would have to add them anywhere again. This way I would have to add them using (HOccurs type record) =>  ...
08:03:28 <SamB> fasta: you might want to explain your higher-level goals?
08:04:02 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
08:04:04 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
08:04:19 <fasta> SamB: Did you see the put example?
08:04:39 <Cale> MarcWebe1: right, you'd have to add those annotations everywhere that they were passed down, wouldn't you?
08:04:47 <SamB> fasta: the one with "undefined"?
08:04:52 <fasta> SamB: yeah
08:04:53 <SamB> that did not look terribly useful
08:04:55 <SamB> somehow
08:05:34 <quicksilver> fasta: I have a feeling you're trying to be clever where there is a simple solution
08:05:36 <MarcWebe1> Cale I think so (I have to get the example working anyway) .. I think its more readable to annotate than passing around. But this is a matter of taste I think..
08:05:42 <Cale> hmm
08:05:56 <quicksilver> fasta: but I don't understand your problem clearly so I can't be sure
08:06:03 <Cale> It seems like it's about the same to me, but involves far more machinery.
08:06:05 <quicksilver> Often when people think they want type-varying statemonads
08:06:15 <quicksilver> they actually just want funciton composition
08:07:00 <quicksilver> "When you've got a haskell, everything looks like a monad?"
08:07:17 <fasta> Suppose you have some graph, then you decide you need to add a certain weight to every edge of this graph. This changes the type of the graph. Suppose you have lots of transformations that do these kinds of things. It is a pain to mention the value representing the "current graph" everywhere.
08:07:34 <fasta> function composition could work in this case.
08:07:42 <fasta> But I also want to do non-local exits.
08:07:44 <sorear> @remember quicksilver When you've got Haskell, everything looks like a monad?
08:07:44 <lambdabot> Done.
08:07:55 <fasta> How would that work?
08:08:12 <paolino> hi, is there a way to use existentials with binary functions ?
08:08:39 <sorear> I don't think so
08:09:18 <paolino> sorear you already tell me that, but I don't remember clearly
08:09:20 <sorear> @users
08:09:21 <lambdabot> Maximum users seen in #haskell: 329, currently: 321 (97.6%), active: 32 (10.0%)
08:09:24 <xerox> chessguy: the symmetry of the code is so elegant :-)  It's nearly ready.
08:09:46 <chessguy> xerox, sweet. are you using the zipper monad?
08:10:20 <paolino> oh, chessguy and xerox . Working at genetic algo ?
08:10:42 <syntaxfree> bah, type inference sometimes confuses me.
08:10:48 <chessguy> paolino, yes. working on a zipper monad to make cross-breeding easier
08:10:58 <Cale> MarcWebe1: rather than using HList, you could also go and create a few typeclasses which specify which fields are available from which record types
08:11:03 <syntaxfree> I can't figure out where ghci is picking up Integer from, it should be any a.
08:11:16 <syntaxfree>     runGraph xs = (map (arr (func xs)) (range xs))
08:11:16 <Cale> MarcWebe1: and of course, a few record types that satisfy those classes.
08:11:17 <sorear> defaulting? monomorphism?
08:11:19 <syntaxfree> type of runGraph is
08:11:27 <syntaxfree> runGraph :: ColoredArr a -> [Arr a]
08:11:37 <syntaxfree>                 toArrList  = unlines . map ((++";") . show) . runGraph
08:11:41 <sorear> @type range
08:11:43 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
08:11:44 <syntaxfree> what do you reckon the type of t
08:11:45 <Cale> MarcWebe1: But to know whether this is a really sane thing to do, I'd have to know more about the structure of your program
08:11:49 <chessguy> paolino, have you seen my code lately?
08:11:50 <syntaxfree> ahhhh. There is a range in the prelude.
08:11:53 <paolino> chessguy , xerox specialities
08:11:58 <syntaxfree> I was defining a range in a record.
08:12:01 <chessguy> paolino, indeed :)
08:12:09 <syntaxfree> I'll try and change that.
08:12:27 <Cale> MarcWebe1: I'd generally try to avoid using fancy type system extensions unless I have a specific problem in my code that I can see they're absolutely the right idea for.
08:12:37 <Cale> Ask fasta about it ;)
08:12:37 <syntaxfree> @hoogle space
08:12:38 <lambdabot> Text.PrettyPrint.HughesPJ.space :: Doc
08:12:38 <lambdabot> Text.ParserCombinators.Parsec.Char.space :: CharParser st Char
08:12:38 <lambdabot> Text.Html.spaceHtml :: Html
08:12:47 <syntaxfree> bah, the best-looking names are taken :P
08:12:48 <sorear> @hoogle+
08:12:48 <lambdabot> Text.ParserCombinators.Parsec.Char.spaces :: CharParser st ()
08:12:49 <lambdabot> Char.isSpace :: Char -> Bool
08:12:49 <lambdabot> Text.Html.hspace :: Int -> HtmlAttr
08:13:22 <Cale> It's really easy to end up using existentials and functional dependencies and typeclasses with 8 parameters when you really don't need them.
08:13:31 <paolino> chessguy , no :/  (grr) . I hope I find time soon
08:13:49 <fasta> Cale: nice number (8) :)
08:14:30 <chessguy> paolino, i'm hoping to be able to do basic symbolic regression with it within the next couple of days
08:14:47 <fasta> But how should "anything" which enables the use of continuations, state, and this "type changing" lok like?
08:14:56 <fasta> look*
08:15:59 <hpaste>  syntaxfree pasted "sorry to bother with such a large example." at http://hpaste.org/642
08:16:34 <hpaste>  syntaxfree annotated "sorry to bother with such a large example." with "(no title)" at http://hpaste.org/642#a1
08:16:47 <xerox> chessguy: *Data.Tree.Zipper> t == test t   ==>  True
08:17:28 <chessguy> test?
08:17:42 <xerox> Let's call it `trip' :-)
08:18:10 <xerox> I mean, it works.
08:18:24 <chessguy> sweet! ship it!
08:19:25 <chessguy> can you email it to me or put it on a darcs repo somewhere?
08:21:40 <xerox> modify :: (Tree a -> Tree a) -> Loc a -> Loc a
08:21:40 <xerox> modify = fmap
08:21:46 <xerox> This is sweet.  GHC 6.6++
08:21:49 <paolino>  I have a database of entries with (String1,String2,String3...) and I want let the user build a distance function for any two lines. I have implemented some basic distance functions which can work on one or more of those values (parsing them to their working types) I want him to give me a vector of weights for those bricks and the target columns for each of them. Which deign pattern should I use ?
08:22:08 <chessguy> hmm
08:22:17 <chessguy> how is that a 6.6 thing?
08:22:35 <xerox> chessguy: Loc is a tuple.
08:23:11 <Pastorn_> what's up with wxHaskell compatibility?
08:23:21 <xerox> actually it could be fmap . fmap
08:23:32 <Pastorn_> still giving segmentation fault all the time?
08:26:51 <SamB> Pastorn_: what is?
08:26:58 <xerox> chessguy: http://darcs.haskell.org/~paolo/darcs/tao/Zipper.hs
08:27:06 <chessguy> woohoo!!!!
08:27:09 <chessguy> xerox++
08:28:12 <ehird> @pl dummy a b c d e f g | g > 0 && h == 4 && 1 == 2 = a*(b/c)-d-f+(read "3")-g
08:28:12 <lambdabot> (line 1, column 49):
08:28:12 <lambdabot> unexpected "="
08:28:12 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`", "&&" or end of input
08:28:17 <ehird> fail
08:28:23 <opqdonut> lose and fail
08:28:37 <Pastorn_> i know that last time i tried wxHaskell i could only run one time each ghci-session... always got segmentetation fault the second time
08:29:21 <chessguy> oh, you didn't use the zipper monad
08:31:59 <Pastorn_> xerox: is that some darcs source code?
08:32:21 <SamB> Pastorn_: ah, that.
08:32:22 <ehird> darcs doesn't imply darcs source code =P
08:32:48 <SamB> Pastorn_: gtk2hs used to have the same issue (does it not have that anymore?)
08:32:53 <a-oXiDe> if i am map.map'ing something to a list of lists how exactly is it working? i am confused
08:33:14 <SamB> @type map . map
08:33:17 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
08:33:30 <xerox> Pastorn_: nope.
08:34:30 <Pastorn_> [ [1,2] , [3,4] , [5,6] ]
08:34:33 <Pastorn_> > [ [1,2] , [3,4] , [5,6] ]
08:34:34 <lambdabot>  [[1,2],[3,4],[5,6]]
08:34:37 <[M]erk> Using ghc, are you allowed to make multiple definitions for the same function, as long as there is a different signature for each new definition?
08:34:51 <Pastorn_> > map (map (*2)) [ [1,2] , [3,4] , [5,6] ]
08:34:52 <lambdabot>  [[2,4],[6,8],[10,12]]
08:35:00 <augustss> [M]erk: no
08:35:27 <Pastorn_> a-oXiDe: get it?
08:35:57 <[M]erk> augustss, then how would you implement a function that acts differently based on the type of the input it gets?
08:36:01 <a-oXiDe> so if i am applying map.map to a list of lists of ints, what should the function be expecting?  just one Int or a list?
08:36:01 <Pastorn_> > map (map (>5)) [[1,2],[3,4],[5,6]]
08:36:03 <lambdabot>  [[False,False],[False,False],[False,True]]
08:36:35 <augustss> [M]erk: you make a new class with that function, and the different instance declarations
08:36:36 <chessguy> ok, i really need to stop trying to get out of bed today
08:36:48 <Pastorn_> @type map.map
08:36:50 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
08:36:55 <allbery_b> > (map . map) (>5) [[1,2],[3,4],[5,6]]
08:36:56 <lambdabot>  [[False,False],[False,False],[False,True]]
08:37:03 <a-oXiDe> ah just a single int
08:38:02 <quicksilver> if you want something with expects a list of ints, you only want one map not two
08:38:16 <quicksilver> > map length [[1,2],[3,4,5],[6]]
08:38:17 <lambdabot>  [2,3,1]
08:40:03 <a-oXiDe> nah its a list of lists
08:40:05 <a-oXiDe> cheers
08:40:40 <nomeata> let @pl dummy a b c d e f g | g > 0 && h == 4 && 1 == 2 = a*(b/c)-d-f+(read "3")-g in dummy
08:40:45 <nomeata> @pl let dummy a b c d e f g | g > 0 && h == 4 && 1 == 2 = a*(b/c)-d-f+(read "3")-g in dummy
08:40:45 <lambdabot> (line 1, column 25):
08:40:45 <lambdabot> unexpected "|"
08:40:45 <lambdabot> expecting pattern or "="
08:41:21 <chessguy> xerox, right and left go to siblings?
08:41:38 <xerox> chessguy: no.
08:41:45 <xerox> Hm.
08:41:53 <xerox> @babel en it siblings
08:41:55 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
08:42:20 <nmessenger> @wn siblings
08:42:21 <chessguy> Tree 1 [Tree 2 [], Tree 3 []]
08:42:23 <lambdabot> No match for "siblings".
08:42:25 <chessguy> 2 and 3 are siblings
08:42:45 <nmessenger> "brothers and sisters", by extension with "children" and "parents"
08:43:36 <xerox> Yes.  |start >.> down >.> right >.> top| travels all of your example tree, chessguy.
08:44:09 <chessguy> xerox, but what happens if you do start >.> down >.> left
08:44:36 <xerox> boom.
08:44:41 <opqdonut> ?pl \ x -> ( f x , g x )
08:44:41 <lambdabot> liftM2 (,) f g
08:44:46 <chessguy> heh
08:44:47 <Pastorn_> @paste
08:44:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:44:50 <sorear> opqdonut: (&&&)
08:44:56 <opqdonut> sorear: yeah
08:44:56 <xerox> chessguy: I never decided what's the best way to handle that situation.
08:45:10 <chessguy> should be an error i guess
08:45:12 <nmessenger> @src (->) (&&&)
08:45:13 <lambdabot> Source not found. Do you think like you type?
08:45:33 <xerox> chessguy: but that does mean that who uses the library should inspect the context to know what to do?
08:45:36 <nmessenger> I think (***) would be what opqdonut wants
08:45:40 * sorear sets out to rewrite 100 lines of haskell in ? lines of C :(
08:45:42 <nmessenger> @src (->) (***)
08:45:42 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
08:45:50 <chessguy> hmm
08:46:04 <chessguy> i guess you should provide hasLeftSibling
08:46:05 <xerox> > (join (***)) (^10) (1,2)
08:46:07 <lambdabot>  (1,1024)
08:46:09 <opqdonut> :t (&&&)
08:46:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:46:14 <hpaste>  Pastorn pasted "permutation error" at http://hpaste.org/643
08:46:21 <xerox> chessguy: interesting.
08:46:35 <opqdonut> ah yes
08:46:43 <xerox> chessguy: that would enable one to use guards. I like that.
08:46:47 <opqdonut> > (id &&& (+2)) 1
08:46:49 <lambdabot>  (1,3)
08:46:50 <nmessenger> wait, no, sorear was right
08:46:52 <opqdonut> yep
08:47:03 <xerox> opeckojo: that's |second (+2)|.
08:47:11 <xerox> err, more or less.
08:47:43 <nmessenger> close, but needs a (1,1) as input
08:48:25 <opqdonut> yeah, and i just threw id in on the spur of the moment
08:48:53 <opqdonut> (g &&& f) x is so much nicer than liftM2 (,) f g x i have to admit
08:49:15 <nmessenger> :)
08:49:26 <xerox> chessguy: are you writing a patch?
08:49:48 <nmessenger> though (\x -> (f x, g x)) is good if Arrows scare you.
08:49:50 <chessguy> xerox, i can
08:49:59 <chessguy> if you want
08:50:17 <xerox> chessguy: okay (-:
08:51:39 <opqdonut> nmessenger: imo ***, &&& first and second can be used naively
08:51:56 <opqdonut> as long as they don't overly obfuscate the code
08:54:21 <chessguy> xerox, does this look right? (Branch _ _ (l:ls) _, _) = True
08:54:53 <chessguy> whoops
08:55:01 <chessguy> hasLeftSibling (Branch _ _ (l:ls) _, _) = True
08:55:55 <xerox> hasLeftSibling (Top,_)             = False
08:55:55 <xerox> hasLeftSibling (Branch _ _ [] _,_) = False
08:55:55 <xerox> hasLeftSibling _                   = True
08:56:16 <chessguy> ah, that works
08:57:12 * xerox ponders: pop = snd :: Loc a -> Tree a
08:58:17 <sorear> WOW! explicitly deforesting a putStr $ chgatt newatt and putStr $ movcsr ... in vty reduced selfbench time from 13.485s to 7.476s
08:58:54 <chessguy> xerox, so then your left/right/etc. can just have a new case left _ = error "Boom" -- right?
08:59:35 <xerox> :(
09:03:26 <sorear> ... and profiling it is 4x slower!
09:03:54 <chessguy> looks good!
09:05:18 <chessguy> hermm, not so good
09:07:49 <sorear> @tell dons vty self benchmark, output to terminal --> real 9.72   user 2.74   sys 6.91
09:07:50 <lambdabot> Consider it noted.
09:08:13 <sorear> now I just need to optimize the kernel :)
09:08:15 <chessguy> *Data.Tree.Zipper> t
09:08:15 <chessguy> Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = []},Node {rootLabel = 3, subForest = []},Node {rootLabel = 4, subForest = []}]}
09:08:15 <chessguy> *Data.Tree.Zipper> snd $ (start >.> left) t
09:08:15 <chessguy> *** Exception: Can't go left without a left sibling
09:08:19 <chessguy> xerox, ^^
09:11:46 <syntaxfree> small-time update: http://syntaxfree.wordpress.com/2007/02/24/a-slightly-better-function-dot-dsl/
09:11:49 <lambdabot> Title: A slightly better function-DOT dsl  Data.Syntaxfree, http://tinyurl.com/2bjunj
09:11:51 <syntaxfree> not really interesting.
09:11:53 <shapr> Good morning #haskell!
09:12:01 <syntaxfree> @get-shapr
09:12:02 <lambdabot> shapr!!
09:12:07 <chessguy> shapr!!
09:12:07 <syntaxfree> ; )
09:12:11 <shapr> yow!
09:12:15 <shapr> Wassup guys?
09:12:20 <chessguy> @yow
09:12:20 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
09:12:29 <sm> good morning shapr, all
09:12:40 <shapr> hiya sm
09:13:48 <xerox> chessguy: I am not sure I want to express failure with exceptions.
09:14:00 <chessguy> why not?
09:14:21 <xerox> chessguy: I think your idea of providing predicates is nicer.
09:14:44 <chessguy> well, you still have to do something when you fall off the tree
09:14:52 <chessguy> (i added the predicates too
09:15:08 <xerox> Right, having both makes sense :-)
09:15:26 <chessguy> i guess you could just not go anywhere if it would make you fall off the tree
09:16:00 <Pastorn_> could someone please take a peek at this: http://hpaste.org/643
09:16:18 <xerox> Pastorn_: yes?
09:16:18 <chessguy> as in, instead of left _ = error "...", do left x = x
09:16:31 <xerox> chessguy: yeah, I thought about that too.
09:17:03 <chessguy> i don't understand why you don't want an exception
09:17:04 <Pastorn_> xerox: are you just being annoying?
09:17:09 <chessguy> ?src head
09:17:10 <lambdabot> head (x:_) = x
09:17:10 <lambdabot> head []    = undefined
09:17:28 <Pastorn_> or was the sarcasm i read in misplaced?
09:17:41 <xerox> Pastorn_: oh sorry, I didn't see the comment behind the window.
09:18:09 <xerox> chessguy: yeah it's perfectly fine to have them.
09:18:29 <chessguy> but you don't like it?
09:18:51 <xerox> no no, I understand it's okay.
09:19:43 <Pastorn_> ?src map
09:19:43 <lambdabot> map _ []     = []
09:19:43 <lambdabot> map f (x:xs) = f x : map f xs
09:20:42 <Pastorn_> xerox: i got that code by doing this:
09:20:55 <Pastorn_> @google Koen Claessen permutations
09:20:57 <lambdabot> http://www.arcknowledge.com/gmane.comp.lang.haskell.cafe/2002-06/msg00036.html
09:20:57 <lambdabot> Title: Re: Generating the n! permutations in Haskell
09:22:42 <opqdonut> nice
09:23:31 <quicksilver> Pastorn_: the base case collapses
09:23:42 <quicksilver> Pastorn_: consider what happens on a 1-element list
09:23:51 <quicksilver> Pastorn_: it calls permutations recursively with an empty list
09:23:58 <Pastorn_> hmm...
09:24:10 <Pastorn_> so i need a base case for permutations?
09:24:10 <quicksilver> Pastorn_: and that returns no results (instead of 1 result, being [], which is what you want)
09:24:57 <quicksilver> Pastorn_: I believe you do
09:25:02 <quicksilver> Pastorn_: permutations [] = [[]]
09:25:20 <quicksilver> Pastorn_: given that, your code produces correct results for me
09:25:34 <Pastorn_> yay!!
09:25:41 <Pastorn_> thanks :D
09:26:47 <quicksilver> Pastorn_: this is a danger in converting mathematics to code. Informal definitions have a bad habit of being rather implict about base cases.
09:27:05 <Pastorn_> hehe
09:29:14 <chessguy> xerox, was there a particular reason you didn't use the zipper monad?
09:30:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/644
09:30:12 <xerox> chessguy: this is clearer for me.
09:30:32 <paolino> uhm
09:30:38 <paolino> it#s mine
09:31:01 <paolino> sometimes elinks jokes me
09:31:58 <Pastorn_> replicate n $ replicate n x <-- is there some other nice way to do this?
09:32:18 <paolino> if someone has ideas on how to do that kind of parsing runtime ...
09:32:32 <chessguy> @pl \x -> replicate n $ replicate n x
09:32:33 <lambdabot> replicate n . replicate n
09:33:06 <chessguy> @ty (replicate n . replicate n)
09:33:09 <lambdabot> Not in scope: `n'
09:33:09 <lambdabot>  
09:33:09 <lambdabot> <interactive>:1:25: Not in scope: `n'
09:33:21 <chessguy> @ty (replicate 2 . replicate 2)
09:33:23 <lambdabot> forall a. a -> [[a]]
09:33:24 <nmessenger> heh, could that be ((.) `on` replicate)?   :3
09:33:47 <xerox> nmessenger: yeah :-)
09:33:55 <augustss> the mind boggles
09:34:14 <chessguy> ?hoogle n
09:34:15 <lambdabot> List.nub :: Eq a => [a] -> [a]
09:34:15 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
09:34:15 <lambdabot> Prelude.newtype :: keyword
09:34:21 <chessguy> ?hoogle on
09:34:22 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
09:34:22 <lambdabot> System.Console.Readline.onNewLine :: IO ()
09:34:22 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
09:34:32 <Pastorn_> > replicate 2 $ replicate 2 "YES!!"
09:34:33 <lambdabot>  [["YES!!","YES!!"],["YES!!","YES!!"]]
09:34:44 <nmessenger> er, join ((.) `on` replicate) to repeat the 2
09:35:01 <nmessenger> but that's just crazy (o:
09:35:05 <Pastorn_> nmessenger: what do you mean?
09:35:06 <xerox> > let on f g x y = g x `f` g y in join ((.) `on` replicate) 2
09:35:07 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
09:35:07 <lambdabot>       Expected...
09:35:23 <nmessenger> oh
09:35:50 <nmessenger> the right arg to `on` has to return the same type
09:35:52 <augustss> oops, you need rank 2 types
09:35:56 <ddarius> Example where equirecursive types would be a problem .
09:36:16 <nmessenger> it was a good idea, though :D
09:36:30 <augustss> yes
09:36:44 <augustss> except i find it less clear than the original ;)
09:36:55 <nmessenger> clarity is for wimps!
09:37:13 <augustss> indeed
09:38:04 <Pastorn_> i was thinking that there must be some way to do it with only writing "replicate n" one time...
09:38:18 <Pastorn_> just for the heck of it :)
09:38:54 <xerox> :t join (.) . replicate
09:38:56 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
09:38:56 <lambdabot>       Expected type: Int -> b -> b
09:39:01 <xerox> Darn.
09:39:07 <Pastorn_> ?src join
09:39:07 <nmessenger> @type join (.)
09:39:07 <lambdabot> join x =  x >>= id
09:39:08 <ddarius> Pastorn_: There are tons of ways to write it with replicate n written only once.
09:39:09 <lambdabot> forall b. (b -> b) -> b -> b
09:39:22 <nmessenger> heh
09:39:29 <nmessenger> join (.) f = f . f
09:39:43 <Pastorn_> oh... okay
09:39:48 <xerox> Indeed.
09:39:49 <ddarius> The most obvious being let repN = replicate n in repN $ repN ".."
09:39:50 <petekaz> recently on cafe, someone asked how apply a list of functions to the same argument. I have a question related to it, is there a way I can move putStrLn . show to the first arg of map so I don't have to repeat it everytime in my list?
09:39:52 <paolino> anyone read my problem please ,  even threading with join (.)  :)
09:39:53 <petekaz> mapM ($ tree) [putStrLn . show . fringe2, putStrLn . show . treeSize2]
09:39:55 <Pastorn_> isn't join a stupid name for that
09:40:10 <ddarius> > join ($) (replicate 3) "."
09:40:11 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
09:40:11 <lambdabot>     Probabl...
09:40:18 <nmessenger> Pastorn_: join is generic to all monads
09:40:29 <nmessenger> > join [[1,2],[3,4]]
09:40:30 <lambdabot>  [1,2,3,4]
09:40:50 <ddarius> > let rep3 = replicate 3 in rep3 $ rep3 "."
09:40:52 <lambdabot>  [[".",".","."],[".",".","."],[".",".","."]]
09:40:53 <nmessenger> > join (Just (Just ()))
09:40:54 <lambdabot>  Just ()
09:41:07 <quicksilver> ddarius: that wouldn't be allowed in ML, would it?
09:41:19 <Pastorn_> ddarius: cheating!
09:41:21 <ddarius> quicksilver: Maybe not.
09:41:49 <quicksilver> ddarius: or maybe you can polymorphically let-bind, you just can't polymorphically function call
09:41:50 <ddarius> petekaz: Move it into the function being applied.
09:41:59 <nmessenger> quicksilver: would you have to add the third arg to rep3?
09:42:00 <quicksilver> I never quite got the hang of that restriction
09:42:10 <petekaz> ddarius: right .. but how?
09:42:18 * ddarius has never programmed in an ML.
09:42:23 <quicksilver> nmessenger: you can't pass a polymorphic function as a first-class value in ML
09:43:01 <Pastorn_> @type Just Nothing
09:43:01 <mattam> yes you can !
09:43:04 <lambdabot> forall a. Maybe (Maybe a)
09:43:08 <quicksilver> so it would resolve rep3 as String -> [String] or [String] -> [[String]] but not both
09:43:12 <ddarius> petekaz: Are fringe2 and treeSize2 the same type?
09:43:15 <xerox> petekaz: sure.
09:44:12 <petekaz> ddarius: no. one returns a list, the other an Int.
09:44:33 <ddarius> petekaz: Then you can still pull out the putStrLn
09:44:43 <xerox> aha.
09:44:53 <quicksilver> hmm haskell can't lambda abstract a polymorphic value, either
09:44:55 <ddarius> petekaz: You could make it so that you could pull out the show, but to do that would be as bad as just using show.
09:44:57 <quicksilver> or I'm doing it wrong
09:45:12 <quicksilver> :t \rep3 -> rep3 $ rep3 "."
09:45:15 <lambdabot> ([Char] -> [Char]) -> [Char]
09:45:30 <quicksilver> (\rep3 -> rep3 $ rep3 ".") (replicate 3)
09:45:37 <quicksilver> > (\rep3 -> rep3 $ rep3 ".") (replicate 3)
09:45:38 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
09:45:45 <quicksilver> who broke my eta-rule?
09:45:50 * quicksilver looks cross
09:46:06 <ddarius> :t \(rep3 :: forall a.a -> [a]) -> rep3 $ rep3 "."
09:46:08 <lambdabot> (forall a. a -> [a]) -> [[[Char]]]
09:46:17 <quicksilver> ddarius: ah, interesting
09:46:25 <xerox> ?type \f g -> join (***) print . (f &&& g)
09:46:28 <lambdabot> forall a c'. (Show c') => (a -> c') -> (a -> c') -> a -> (IO (), IO ())
09:46:40 <ddarius> quicksilver: This is using GHC extensions
09:46:41 <quicksilver> ddarius: so you can choose to explicitly give a polymorphic type more general than the one it infers?
09:46:45 <xerox> ?type \f g -> (print *** print) . (f &&& g)
09:46:47 <lambdabot> forall a c c'. (Show c, Show c') => (a -> c) -> (a -> c') -> a -> (IO (), IO ())
09:46:52 <petekaz> ddarius: this is what i tried: mapM ((putStrLn .) $ tree) [show . fringe2, show . treeSize2] ...
09:46:57 <xerox> this way you can specify two different things.
09:47:02 <ddarius> quicksilver: That's not even syntactically correct in H98
09:47:11 <quicksilver> ddarius: *nod* I realise that
09:47:32 <xerox> ?type \f g -> uncurry (>>) . (print *** print) . (f &&& g)
09:47:34 <lambdabot> forall a c c'. (Show c, Show c') => (a -> c) -> (a -> c') -> a -> IO ()
09:47:35 <quicksilver> ddarius: I didn't realise that extension allowed you to 'override' the type inference in this way, it's interesting
09:47:40 <xerox> Satisfying?
09:48:21 <Pastorn_> ?src replicate
09:48:21 <lambdabot> replicate n x = take n (repeat x)
09:48:28 <Pastorn_> thought so...
09:48:36 <ddarius> petekaz: (putStrLn . ($ tree)) if you want that, or just use a lambda abstraction.
09:48:49 <petekaz> thanks ...
09:49:30 <sorear> Gah.  I HATE scons.  Today, there is no -keep-tmp-files option.  kill -9 to the rescue!
09:49:31 <xerox> petekaz: the arrow version scales in some way like the list one.
09:49:56 <ddarius> quicksilver: GHC has always required you to provide type signatures when you need higher rank types, and H98 when you need polymorphic recursion.
09:51:04 <quicksilver> ddarius: but the first replicate 3 example is H98?
09:51:13 <sorear> ok
09:51:28 <sorear> it turns out I need killall -9 python, not killall -9 scons.
09:51:36 <sorear> python apparently sucks
09:52:26 <quicksilver> ddarius: seems like that means unrestricted eta isn't valid in H98
09:52:28 <ddarius> quicksilver: replicate 3 $ replicate 3 "." ?  Yes.  It just instantiates replicate 3 at two different types.
09:52:33 <petekaz> xerox: which version of the arrow one?
09:52:36 <sorear> and the tmp dir is STILL empty
09:52:36 <jcreigh> scons?
09:52:40 <ddarius> quicksilver: It isn't.
09:52:41 <xerox> ?type \f g -> uncurry (>>) . (print *** print) . (f &&& g)
09:52:41 <quicksilver> I meant the let rep3 = replicate 3 version
09:52:43 <lambdabot> forall a c c'. (Show c, Show c') => (a -> c) -> (a -> c') -> a -> IO ()
09:52:53 <sorear> jcreigh: the worst build system ever concieved *vent vent*
09:53:18 <sorear> jcreigh: the thing which some "bright" person over at yhchq thought would be better than make
09:53:40 <sorear> jcreigh: at least make is properly documented and supports normal command line options.
09:53:59 <sorear> jcreigh: thank god for man, since the scons devs didn't think to make --help or -h dtrt
09:54:18 <ddarius> quicksilver: And do you mean beta?
09:54:19 <jcreigh> what? no --help?
09:54:27 <sorear> jcreigh: right.
09:54:38 <quicksilver> ddarius: yes, sorry
09:54:46 <quicksilver> ddarius: my theory is much rustier than I like to admit
09:54:47 <sorear> jcreigh: or rather --help exists, but it prints information on the SConscript file
09:54:54 <quicksilver> ddarius: :)
09:55:11 <sorear> jcreigh: which is of course useless when you want to get scons to find said file :)
09:55:26 <ddarius> quicksilver: beta reduction may always be safe, but beta expansion is not.
09:55:38 <sorear> jcreigh: there is scons --help-commands, but come on - who'd guess to type that?
09:55:42 <quicksilver> ddarius: *nod*
09:56:01 <syntaxfree> I don't understand why Ada is so heavily criticized.
09:56:07 <ddarius> Anyways, let binds polymorphically
09:56:17 <ddarius> syntaxfree: In which way?
09:56:29 <allbery_b> for the same reason PL/1 was:  it tries to do way too much
09:56:34 <syntaxfree> I've always heard of Ada as a disaster example of a language designed by committee.
09:56:37 <sorear> now scons is complaining I don't have a working C compiler
09:56:51 <sorear> funny, since ghc -fvia-C doesn't seem to mind this lack
09:57:02 <syntaxfree> man, kill scons.
09:57:19 <Pastorn_> drop is faster than take, rigt?
09:57:44 <sorear> syntaxfree: doesn't work.  you need killall python.  when will they learn not to zap argv[0]?  python-- or maybe env--
09:58:08 <syntaxfree> ah, I didn't mean that.
09:58:16 <syntaxfree> I meant "screw" or "foque". : /
09:58:35 * syntaxfree blushes
09:58:58 * sorear greps the yhc history for the author of the patch that added Sconscript
09:59:52 <syntaxfree> ah, I failed to compile yhc because of scons as well.
09:59:53 <Pastorn_> quicksilver: about permutations... if i want to allow the same element to be repeated more than once?
09:59:55 <sorear> andrewjwilkinson--
09:59:58 <syntaxfree> buy scons keeps on getting in my way.
10:00:11 <sorear> make was better
10:00:16 <sorear> autotools even
10:00:30 <syntaxfree> s/buy/but
10:00:38 <Pastorn_> quicksilver: should i do concat . replicate ?
10:01:06 <xerox> petekaz: basically you want a function that given a list of functions, prints their results in sequence?
10:01:33 <quicksilver> Pastorn_: how long are the combinations supposed to be? same length as the original list?
10:01:34 <petekaz> xerox: yes.
10:01:37 <kc5tja> sorear: scons --help will print the defined Help() text if and only if it exists.  If it doesn't, then it will default to --help-commands.
10:01:38 <sorear> syntaxfree: yhc build the first time I tried to build it.
10:01:49 <Pastorn_> no, n long
10:01:51 <xerox> petekaz: the problem is that you would pass in an HList of functions.
10:01:55 <sorear> kc5tja: tell that to my failing configure.
10:02:22 <xs> sorear, try scons help, if you're using yhc
10:02:30 <sorear> syntaxfree: now no amount of scons clean will make it do the original easy build again
10:02:30 <quicksilver> Pastorn_: you can do that with sequence and replicate, I think
10:02:33 <sorear> xs: tried.
10:02:38 <sorear> xs: no luck.
10:02:38 <xerox> petekaz: there exist another interesting approach in fact....
10:02:45 <quicksilver> > sequence (replicate 3 [1,2])
10:02:48 <kc5tja> sorear: What would --help have to do with a failing configure?  Why are you using configure when scons has auto-configuration capabilities built-in?
10:02:54 <quicksilver> > Control.Monad.sequence (replicate 3 [1,2])
10:02:56 <lambdabot>  [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
10:03:14 <sorear> kc5tja: configure is a generic verb, and in this case is performed by scons.
10:03:25 <quicksilver> Pastorn_: sequence (for a list of lists) means 'every choice of one from each'
10:03:51 <quicksilver> Pastorn_: so you want to sequence 'n' of your list
10:03:51 <petekaz> xerox: is it easy to understand?  I'm still a newbie ...
10:03:55 <kc5tja> sorear: Do you have a darcs repo I can pull from to see what's happening?  Maybe I can take a peek.
10:04:01 <xs> sorear, which darcs repository did you pull from?
10:04:03 <xs> heh
10:04:10 <sorear> ah, rm .sconsign.dblite did the trick
10:04:12 <xerox> petekaz: it needs a bit of olegness in fact.
10:04:32 <sorear> can anyone give a good reason scons clean didn't delete that file?
10:05:25 <kc5tja> sorear: Bug.  That's actually on my list of things to submit a patch for.  But, with how I've been treated in patch submissions of late, I've got second thoughts on it.  :)
10:05:31 <Pastorn_> > (nub . map (drop 6) . permutations . concat .replicate 3) "abc"
10:05:32 <lambdabot>   Not in scope: `permutations'
10:05:37 <Pastorn_> whoops
10:05:53 <sorear> <thoughtbubble> finished recording patch 'Add autotools-based build system. The main advantage over the scons-based one is that this one works.' </thoughtbubble>
10:06:02 <Pastorn_> quicksilver: try that and give me a rough calculation time...
10:07:19 <quicksilver> Pastorn_: 30 seconds or so?
10:07:38 <Pastorn_> heh... my AMD 800 is still chewing :/
10:07:42 <quicksilver> sequence (replicate 3 "abc")
10:07:45 <quicksilver> is quite a bit faster :)
10:08:07 <Pastorn_> >sequence (replicate 3 "abc")
10:08:19 <quicksilver> > Control.Monad.sequence (replicate 3 "abc")
10:08:20 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
10:08:29 <quicksilver> needing Control.Monad there is a lambdabot bug
10:08:35 <quicksilver> you wouldn't need that in ghci
10:08:48 <Pastorn_> WTF!? i could have done that from the start!!
10:08:59 <Pastorn_> ?src sequence
10:08:59 <lambdabot> sequence ms = foldr k (return []) ms
10:08:59 <lambdabot>     where
10:08:59 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
10:09:13 <quicksilver> Pastorn_: well combinations are much easier than permutations :)
10:09:16 <Pastorn_> headache! come take me!!
10:09:18 <quicksilver> Pastorn_: you did the hard problem first
10:09:19 <sorear> > sequence (replicate 3 "abc")
10:09:29 <sorear> ah ok, still need to crash it
10:09:41 <sorear> bug fixed in source, but bot needs to reload
10:10:08 <Pastorn_> @type sequence
10:10:10 <lambdabot>     Ambiguous occurrence `sequence'
10:10:11 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
10:10:35 <Pastorn_> @type sequence.Control.Monad.Writer
10:10:38 <lambdabot>     Ambiguous occurrence `sequence'
10:10:38 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
10:10:46 <allbery_b> @type Control.Monad.sequence
10:10:49 <Pastorn_> @type Control.Monad.Writer.sequence
10:10:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:10:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:11:03 <petekaz> As a newbie, I really enjoy Tom Moertel's blog entries.  They are great, I'm working through his latest haskell equivalent of the command 'tree'.
10:11:23 <paolino> @tell dons Can I produce an instance of a class with hs-plugins ?
10:11:23 <lambdabot> Consider it noted.
10:11:28 <Pastorn_> @google Tom Moertel blog
10:11:30 <petekaz> http://blog.moertel.com/articles/2007/02/22/a-simple-directory-tree-printer-in-haskell
10:11:33 <lambdabot> http://blog.moertel.com/
10:11:33 <lambdabot> Title: Tom Moertel's Weblog
10:11:34 <lambdabot> Title: A simple directory-tree printer in Haskell, http://tinyurl.com/23um78
10:11:39 <sorear> paolino: easily!
10:11:52 <sorear> paolino: instance ... in the file loaded
10:12:10 <sorear> paolino: or did you want it in scope in the static part?
10:12:10 <quicksilver> Pastorn_: it's a bit subtle, to be honest
10:12:18 <quicksilver> Pastorn_: sequence works via the monad instance of lists
10:12:25 <sorear> paolino: if so, existentials (shudder) are right for you
10:12:39 <quicksilver> Pastorn_: basically the monad instance for lists is about nondeterminism: functions which return multiple results
10:12:52 <paolino> must be in scope
10:12:55 <quicksilver> Pastorn_: as you sequence calculations, the possibilities get 'multiplied up'
10:13:17 <quicksilver> > Control.Monad.sequence [[1,2],[20,40]]
10:13:18 <lambdabot>  [[1,20],[1,40],[2,20],[2,40]]
10:13:46 <quicksilver> Pastorn_: bit of a heavy piece of machinery, in theory. In practice sequence is just very handy for combinations :)
10:13:53 * paolino wonders what can be right with existentials
10:13:55 <Pastorn_> hehe
10:13:56 <allbery_b> > (\x -> do a <- x; return (a + 1)) [1..5] -- the list monad
10:13:58 <lambdabot>  [2,3,4,5,6]
10:14:06 <chessguy> xerox, ping
10:14:12 <xerox> pong
10:14:17 <Pastorn_>  > Control.Monad.sequence "abc"
10:14:17 <Cale> > sequence [(*2), (+1), (^2)] 10
10:14:25 <Cale> > Control.Monad.sequence [(*2), (+1), (^2)] 10
10:14:27 <lambdabot>  [20,11,100]
10:14:27 <Pastorn_> > Control.Monad.sequence "abc"
10:14:28 <lambdabot>  Couldn't match expected type `m a' against inferred type `Char'
10:14:28 <chessguy> xerox, i wonder, would up be hard to write with your code?
10:14:44 <Pastorn_> > Control.Monad.sequence ["abc"]
10:14:45 <lambdabot>  ["a","b","c"]
10:14:47 <Cale> > Control.Monad.sequence ["abc", "def"]
10:14:49 <lambdabot>  ["ad","ae","af","bd","be","bf","cd","ce","cf"]
10:15:19 <quicksilver> > Control.Monad.sequence [["hello","goodbye"],["Cale","Pastorn","world"]]
10:15:20 <lambdabot>  [["hello","Cale"],["hello","Pastorn"],["hello","world"],["goodbye","Cale"],[...
10:15:44 <Cale> > Control.Monad.sequence [["Algebraic", "Differential"], ["Geometry", "Topology"]]
10:15:45 <lambdabot>  [["Algebraic","Geometry"],["Algebraic","Topology"],["Differential","Geometry...
10:15:46 <chessguy> oh, you have it embedded in your top function
10:16:10 <Cale> > map unwords $ Control.Monad.sequence [["Algebraic", "Differential"], ["Geometry", "Topology"]]
10:16:12 <lambdabot>  ["Algebraic Geometry","Algebraic Topology","Differential Geometry","Differen...
10:16:24 <Pastorn_> Cale: that's better
10:16:41 <xerox> chessguy: I love the fact that I can write top as a fixpoint without troubles. |up| errors out like left,right,down, instead. But now that we introduced exceptions I think it's fine to have it as well.
10:17:28 <chessguy> and there you used the idea of just not going anywhere if you can't go up any more
10:17:47 <xerox> chessguy: indeed.
10:17:59 <chessguy> i wonder if that's better than exceptions
10:18:10 <Pastorn_> > Control.Monad.sequence ["a","b","cd"]
10:18:11 <lambdabot>  ["abc","abd"]
10:18:34 <ddarius> @google functional pearl weaving a web
10:18:37 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/TheWeb.ps.gz
10:18:39 <Pastorn_> > Control.Monad.sequence ["abc","abd"]
10:18:41 <lambdabot>  ["aa","ab","ad","ba","bb","bd","ca","cb","cd"]
10:19:09 <Pastorn_> hey! this is like multiplying parentheses!
10:19:32 <xerox> Cartesian product.
10:19:40 <chessguy> > zip "abc" "abd"
10:19:41 <lambdabot>  [('a','a'),('b','b'),('c','d')]
10:19:47 <xerox> Diagonal.
10:20:09 <xerox> Haskell is too fun.
10:20:15 <ddarius> > [(a,b) | a <- "abc", b <- "abc"]
10:20:16 <lambdabot>  [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c',...
10:20:55 <Pastorn_> ddarius: can you do that with lists and not tuples?
10:21:36 <ddarius> Pastorn_: I'm not understanding what you're asking for, but the answer is yes.
10:21:38 <quicksilver> > [[a,b]  | a <- "abc", b <- "abc"]
10:21:39 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
10:21:44 <quicksilver> is that what you meant?
10:21:49 <mux> is there a darcs repository for hs-plugins?
10:21:52 <mux> I only find tarballs
10:21:57 <allbery_b> @where hs-plugins
10:21:57 <mux> @where hs-plugins
10:21:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:21:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:21:59 <quicksilver> that's the same as sequence ["abc","abc"]
10:22:06 <mux> well it's not there
10:22:09 <Pastorn_> nevermind...
10:22:56 <ddarius> > Control.Monad.sequence (repeat "ab")
10:22:57 <lambdabot>  Exception: <<loop>>
10:23:01 <mux> @seen dons
10:23:02 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 4h 35m 45s ago.
10:23:29 <allbery_b> http://www.cse.unsw.edu.au/~dons/code/hs-plugins
10:23:30 <lambdabot> Title: Index of /~dons/code/hs-plugins
10:24:19 <Pastorn_> > map (take 4) . sequence $ replicate 4 "abc"
10:25:05 <mux> allbery_b: cheers
10:25:20 <Pastorn_> great! lambdabot ignores me!
10:25:32 <quicksilver> Pastorn_: it has a bug with 'sequence'
10:25:40 <quicksilver> Pastorn_: you have to use Control.Monad.sequence
10:25:41 <Pastorn_> oh... forgot that
10:25:45 <ddarius> > map (take 4) . Control.Monad.sequence $ replicate 4 "abc"
10:25:46 <lambdabot>  ["aaaa","aaab","aaac","aaba","aabb","aabc","aaca","aacb","aacc","abaa","abab...
10:26:04 <quicksilver> that map (take 4) is doing nothing, I think?
10:26:08 <Pastorn_> what's the other sequence
10:26:10 <quicksilver> all the elements will be 4 long anyway
10:26:28 <Pastorn_> quicksilver: just realised that X_X
10:28:17 <allbery_b> @ty Prelude.sequence
10:28:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:28:45 <allbery_b> same one I think but it leads to a conflict
10:29:55 <ddarius> @hoogle sequence
10:29:55 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
10:29:56 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
10:29:56 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
10:30:03 <ddarius> @index sequence
10:30:03 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:30:04 <chessguy> heh. so now that i've written up, top = fix up ;)
10:30:08 <chessguy> xerox, ^^
10:30:18 <xerox> chessguy: not true!
10:30:21 <ddarius> @type Data.Traversal.sequence
10:30:24 <lambdabot> Couldn't find qualified module.
10:30:27 <chessguy> no?
10:30:34 <xerox> chessguy: that's either boom or bottom.
10:31:05 <chessguy> even if up is written with Top -> t
10:31:07 <chessguy> ?
10:31:25 * ddarius plays guitar and meditates on pedagoguery.
10:31:40 <xerox> chessguy: did you try it?
10:31:46 <chessguy> no
10:31:49 <xerox> Try.
10:31:50 <sorear> damn gcc is fast
10:32:13 <sorear> 5 seconds for a 120k program (yhi)
10:32:19 <chessguy> oh, your up calls itself recursively
10:32:20 <sorear> too used to ghc :/
10:32:29 <xerox> Indeed.
10:32:33 <chessguy> i can't use that
10:32:53 <xerox> Well, you can, but you have to either boom or bottom. So I guess you can't.
10:33:11 <chessguy> but can't i just do up (c,t) =
10:33:11 <chessguy>     case c of
10:33:11 <chessguy>       Top -> t
10:33:11 <chessguy>       Branch c x ls rs -> (c, Node x (roll ls t rs)))
10:33:35 <chessguy> where roll ...
10:33:42 <chessguy> and then top = fix up?
10:33:50 <xerox> Try it.
10:34:42 <Pastorn_> quicksilver: i always get confused... when using that sequence method, did we get combinations or permutations?
10:35:04 <chessguy> doesn't work
10:36:40 <quicksilver> Pastorn_: combinations, I believe, although I get confused too
10:36:52 <quicksilver> Pastorn_: permutations I believe was your correctly named original function
10:36:58 <paolino> can#t have combinations without another argument
10:37:05 <Pastorn_> ok...
10:37:55 <Pastorn_> but aren't the difference in werther the order matters or not?
10:38:20 <quicksilver> I thought the difference was about repeats
10:38:26 <quicksilver> but you're right order is another factor
10:38:32 <Pastorn_> i think the difference has little to with repeating elements
10:38:34 <quicksilver> I'm not sure, go find a maths dictionary :)
10:38:49 <Pastorn_> hmm.... *checking BETA*
10:38:50 <chessguy> ?src fix
10:38:51 <lambdabot> fix f = let x = f x in x
10:39:09 <quicksilver> permutations is like shuffles and order obviously matters
10:39:15 <quicksilver> without order, they'd all be the same, after all
10:39:15 <dbremner> syntaxfree - Ada wasn't a committee design, Ichbiah had the deciding vote. On some decisions he overruled everyone else.
10:39:16 <xerox> chessguy: you either have to do |up (Top,t) = error "boom"; up (Branch c x ls rs, t) = up (c, Node x (roll ls t rs)|, which booms every time, or |up (Top,t) = (undefined,t); up (Branch c x ls rs, t) = up (c, Node x (roll ls t rs))| and prepend it with "snd ." every use.
10:40:13 <chessguy> xerox, hmm
10:40:40 <chessguy> right, left, and down always return Loc's, why can't up?
10:40:54 <xerox> chessguy: sure it can, that's the second case I wrote.
10:41:04 <xerox> Ah, oops. I am mixing two things there.
10:41:17 <Pastorn_> hmmm... here's a 2x2 table, one axis is with/out regard to order
10:41:18 <chessguy> i don't understand your "prepend it with 'snd .' every use
10:41:26 <xerox> chessguy: that is top, not up.
10:41:39 <chessguy> yes
10:41:42 <Pastorn_> and the other is with/out replacement (dunno what is meant by that though...)
10:41:45 <xerox> I'm sorry.
10:41:54 <xerox> That's the reason why you can't "fix up".
10:42:13 <allbery_b> Pastorn_: having selected an item, does it go back in the pool to be paired with something else or not?
10:42:27 <Pastorn_> oh, so repeating then...
10:45:53 <paolino> combination is a picking act, permutation is a shuffling
10:47:49 <quicksilver> so order can sensibly be ignored for combinations but clearly not for perms
10:49:17 <ddarius> quicksilver: "ab" and "ba" are two different combinations.
10:49:25 <quicksilver> ah, ok
10:51:41 <opqdonut> ddarius: of 'b' and 'a'?
10:52:26 <opqdonut> or rather, the set of - -
10:52:29 <Pastorn_> @paste
10:52:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:53:47 <ddarius> I am wrong. What am I thinking of though.
10:54:10 <allbery_b> "ab" and "ba" are different permutations but the same combination, IIRC
10:54:19 <opqdonut> exactly
10:54:38 <ddarius> Correct, but permutations is not what I'm thinking of.
10:55:00 <hpaste>  Pastorn_ pasted "where do i put flip?" at http://hpaste.org/645
10:55:19 <ddarius> I think I'm just thinking of lists.
10:55:39 <Pastorn_> in near somewhere...
10:55:53 <allbery_b> list vs. set?
10:56:35 <Pastorn_> in sets there are no order
10:56:50 <Pastorn_> and in sets an element may only occur once
10:57:26 <Pastorn_> at least in theory... you bend the first of those rules a little every now and then to prove stuff
10:57:50 <nmessenger> Pastorn_: (x :: Code)?
10:58:02 <allbery_b> so maybe a bag instead of a set?
10:58:08 <a-oXiDe> if i am testing for a data type which can take any value eg Number <range of Ints here> what would be the best way to check for it.  I have tried Number _ = _ to return just the number itself but get an error saying Pattern syntax in expression context?
10:58:18 <Pastorn_> oh... Code = [Colour]
10:58:28 <allbery_b> Number a = a
10:58:47 <a-oXiDe> lol oops, silly mistake
10:58:48 <allbery_b> _ is a placeholder, you're explicitly throwing the value away
10:58:50 <opqdonut> a-oXiDe: _ does not bind the argument
10:59:00 <a-oXiDe> ah rite
10:59:10 <nmessenger> @type \colour -> length . filter (==colour)
10:59:13 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
10:59:25 <augustss> Pastorn_: Don't you want 'count x ss' instead of 'map (count x) ss'
10:59:52 <Pastorn_> whoops... yeah i do
11:00:22 <augustss> Pastorn_: except, you don't really want that either, I think :)
11:00:24 <nmessenger> count c cs = length (filter (c==) cs)
11:00:50 <Pastorn_> augustss: but i do thet already... well, if it was working...
11:01:48 <Pastorn_> nmessenger: clever
11:02:05 <opqdonut> ?src count
11:02:05 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:05:04 <Pastorn_> ?src intersect
11:05:04 <lambdabot> intersect = intersectBy (==)
11:05:13 <Pastorn_> ?src intersectBy
11:05:14 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
11:05:23 <opqdonut> nmessenger: hmm i think a count c (x:xs) = foo + count c xs where foo ... would be faster
11:05:53 <opqdonut> or is length . filter optimized?
11:06:09 <nmessenger> opqdonut: I don't see why not.  We're lazy, remember?
11:06:24 <nmessenger> @src length
11:06:24 <lambdabot> Source not found. You type like i drive.
11:06:30 <opqdonut> hmm but won't taking the length force evaluation
11:06:33 <nmessenger> !?
11:06:40 <Pastorn_> @ty intersect
11:06:43 <opqdonut> nmessenger: i tried that earlier
11:06:43 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:07:00 <opqdonut> for example if we take
11:07:00 <nmessenger> length [] = 0; length (_:xs) = 1 + length xs
11:07:06 <opqdonut> > lengh [1..]
11:07:07 <lambdabot>   Not in scope: `lengh'
11:07:11 <opqdonut> > length [1..]
11:07:15 <lambdabot> Terminated
11:07:31 <nmessenger> opqdonut: his 'count' is strict in the length of the list anyway.
11:07:38 <opqdonut> yeah
11:07:55 <opqdonut> yeah actually i guess the methods are equal after all
11:08:10 <opqdonut> does lambdabot have a profile extension?
11:10:30 <Pastorn_> intersect [1..10] [5..200]
11:10:36 <Pastorn_> > intersect [1..10] [5..200]
11:10:37 <lambdabot>  [5,6,7,8,9,10]
11:11:00 <Pastorn_> and that won't work in hugs because...?
11:11:15 <nmessenger> @index intersect
11:11:15 <lambdabot> Data.List, Data.Set
11:11:21 <nmessenger> ^^ did you import?
11:11:24 <Pastorn_> yes
11:11:31 <nmessenger> hmmm
11:11:36 <ddarius> > interesect (repeat 'c') "abcedcdaecedcc"
11:11:36 <Pastorn_> hmm... might be another thing...
11:11:37 <lambdabot>   Not in scope: `interesect'
11:11:48 <Pastorn_> equals = length . intersect
11:11:53 <ddarius> > intersect (repeat 'c') "abcedcdaecedcc"
11:11:55 <lambdabot>  "ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
11:11:56 <Pastorn_> equals :: Code -> Code -> Int
11:12:12 <nmessenger> -> Int?
11:12:26 <Pastorn_> whoops
11:12:29 <Pastorn_> nevermind...
11:12:39 <ddarius> > intersect "abcdecacoeducaoeucd" (repeat 'c')
11:12:40 <mauke> @hoogle (m a -> m b) -> t m a -> t m b
11:12:41 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
11:12:41 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
11:12:41 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
11:12:43 <lambdabot> Terminated
11:12:44 <Pastorn_> they have to be in the some place...
11:13:58 <nmessenger> @type \xs ys -> length (filter id (zipWith (==) xs ys))
11:14:00 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
11:14:06 <Pastorn_> what can i use to compare two lists, one element from both at a time. I have written it but is there somethng that already exists?
11:14:17 <quicksilver> Cale: you about?
11:14:23 <nmessenger> > (\xs ys -> length (filter id (zipWith (==) xs ys))) "abcde" "acbdx"
11:14:24 <lambdabot>  2
11:14:56 <nmessenger> @src zipWith
11:14:57 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:14:57 <lambdabot> zipWith _ _      _      = []
11:16:06 <Pastorn_> nmessenger: that was nice =)
11:16:09 <mauke> > ((sum .) . zipWith ((fromEnum .) . (==))) "abcde" "acbdx"
11:16:10 <lambdabot>  2
11:16:19 <nmessenger> zipWith (==) compares corresponding elements, filter id gets the Trues, length counts them
11:16:36 <nmessenger> mauke: showoff :P
11:17:41 <quicksilver> nmessenger: I can never quite get used to that use of id
11:17:56 <quicksilver> nmessenger: I almost want to have let isTrue :: Bool -> Bool = id
11:18:02 <nmessenger> heh
11:18:27 <mauke> nah, isTrue = (True ==)
11:18:34 <nmessenger> geh
11:18:55 <nmessenger> isTrue True = True; isTrue _ = False
11:18:56 <quicksilver> nmessenger: I think I see filter id but I read 'map id' because in my head id doesn't look like a Bool so filter must be a mistake
11:19:17 <quicksilver> nmessenger: then I wonder why you're bothering to do 'map id' :)
11:19:39 <nmessenger> if we had a filter2...
11:20:04 <Pastorn_> > zipWith (\x y -> (x,y)) "abc" "123"
11:20:04 <quicksilver> well, maybe better to learn about zipWith, though
11:20:05 <lambdabot>  [('a','1'),('b','2'),('c','3')]
11:20:15 <quicksilver> filter2 wouldn't teach you the wonders of zipWith
11:20:18 <nmessenger> the name map2 strikes me as better than zipWith, anyway
11:20:19 <quicksilver> and zipWith is a powerful tool
11:20:20 <dmhouse> isTrue = not . not?
11:20:28 <mauke> > zipWith (,) "abc" [1,2,3]
11:20:30 <lambdabot>  [('a',1),('b',2),('c',3)]
11:20:38 <mauke> > zip "abc" [1,2,3]
11:20:39 <Pastorn_> oh... nice
11:20:40 <lambdabot>  [('a',1),('b',2),('c',3)]
11:20:42 <dmhouse> > zip "abc" [1..3]
11:20:44 <lambdabot>  [('a',1),('b',2),('c',3)]
11:20:49 <dmhouse> ?src zip
11:20:49 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:20:50 <lambdabot> zip _      _      = []
11:20:50 <Pastorn_> ?src (,)
11:20:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:20:58 <nmessenger> zip should = zipWith (,)!
11:21:12 <nmessenger> code duplication = doubleplusungood
11:21:20 <mauke> ?src zipWith
11:21:21 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:21:21 <lambdabot> zipWith _ _      _      = []
11:21:25 <dmhouse> Pastorn_: (,) is the pair constructor. In pseudo-Haskell, data (a, b) = (,) a b
11:21:28 <quicksilver> the prelude definition are specifications not implementations, though
11:21:36 <quicksilver> it doesn't mean that's really how it works
11:21:37 <Pastorn_> dmhouse: nice
11:22:00 <nmessenger> er, but zip is just zipWith where f = (,)
11:22:52 <nmessenger> also map = fmap = liftM, zipWith = liftM2
11:23:00 <Pastorn_> mauke: why fromEnum here and what does it do? ((sum .) . zipWith ((fromEnum .) . (==))) "abcde" "acbdx"
11:23:08 <nmessenger> > fromEnum True
11:23:10 <lambdabot>  1
11:23:10 <mauke> nmessenger: you forgot (.)
11:23:31 <mauke> Pastorn_: fromEnum converts from enumerations to integers
11:23:35 <nmessenger> mauke: where?
11:23:46 <Pastorn_> what's an enumeration?
11:23:49 <pjd> nmessenger: fmap
11:23:52 <mauke> Bool is an enumeration
11:23:53 <mauke> nmessenger: fmap == (.)
11:23:53 <nmessenger> oh, I was just talking about []
11:24:06 <Pastorn_> are there more?
11:24:11 <nmessenger> fmap is lots of things
11:24:14 <mauke> Pastorn_: a type of the form data X = A | B | C | D ...
11:24:25 <nmessenger> @instances Enum
11:24:27 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
11:24:28 <Pastorn_> oh! ok
11:24:32 <doserj> @src Enum
11:24:32 <lambdabot> class  Enum a   where
11:24:32 <pjd> nmessenger: as is liftM
11:24:32 <lambdabot>     succ                     :: a -> a
11:24:32 <lambdabot>     pred                     :: a -> a
11:24:32 <lambdabot>     toEnum                   :: Int -> a
11:24:32 <lambdabot>     fromEnum                 :: a -> Int
11:24:34 <lambdabot> [3 @more lines]
11:24:39 <nmessenger> > succ False
11:24:40 <lambdabot>  True
11:24:45 <mauke> Double isn't really an enum
11:24:53 <nmessenger> > succ 'a'
11:24:54 <lambdabot>  'b'
11:25:15 <apfelmus> dmhouse: hi
11:25:17 <mauke> > liftM2 (,) "abc" [1,2,3]
11:25:19 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
11:25:21 <a-oXiDe> is there a function to convert an Int to a String?
11:25:22 <nmessenger> pjd: of course, since liftM = fmap :P
11:25:26 <mauke> nmessenger: doesn't look like zipWith
11:25:29 <nmessenger> a-oXiDe: read
11:25:31 <Pastorn_> mauke: given that i have a non-recursiv type defined like that, can i make a list of all the stuff that that type may be?
11:25:33 <a-oXiDe> cheers
11:25:34 <nmessenger> er show
11:25:39 <nmessenger> @type show
11:25:41 <lambdabot> forall a. (Show a) => a -> String
11:26:12 <mauke> Pastorn_: if it's an instance of Bounded, yes
11:26:17 <nmessenger> mauke: I didn't say liftM2 = zipWith, I said zipWith = liftM2 :P
11:26:19 <Pastorn_> i have data Colour = Red | Blue | Green | Yellow | Black | White
11:26:30 <mauke> nmessenger: what's the difference?
11:26:30 <Pastorn_> how do i get [Red, Blue, Green, Yellow, Black, White]?
11:26:48 <nmessenger> zipWith is a special case of liftM2
11:26:56 <nmessenger> for the [] Monad
11:26:59 <mauke> Pastorn_: make that data Colour = Red | Blue | Green | Yellow | Black | White deriving (Eq, Show, Enum, Bounded)
11:27:09 <mauke> Pastorn_: then use [minBound .. maxBound] :: [Colour]
11:27:24 <Pastorn_> cool!
11:27:32 <mauke> > [minBound .. maxBound] :: [Bool]
11:27:34 <lambdabot>  [False,True]
11:27:38 <mauke> > [minBound .. maxBound] :: [Char]
11:27:40 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
11:28:11 <Pastorn_> that's some sweet code :D
11:28:22 <fantasma> i like haskell
11:28:27 <Pastorn_> ?src minBound
11:28:27 <LoganCapaldo> So is it common practice to write a lexer using parsec to then parse the token stream with parsec?
11:28:27 <lambdabot> Source not found. stty: unknown mode: doofus
11:28:34 <Pastorn_> oh... keyword...
11:28:34 <LoganCapaldo> Or do people skip lexing?
11:28:40 <nmessenger> Pastorn_: minBound is a method of Bounded
11:28:46 <nmessenger> ?src Char minBound
11:28:46 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:28:52 <nmessenger> @src Bounded
11:28:52 <lambdabot> class  Bounded a  where
11:28:53 <lambdabot>     minBound, maxBound :: a
11:29:01 <dmhouse> apfelmus: hey
11:29:23 <nmessenger> then instance Bounded Bool where minBound = False; maxBound = True, etc.
11:29:39 <AvengerX> guess who's back? (me!)
11:29:45 <Pastorn_> yay?
11:30:03 <nmessenger> AvengerX: Aw, darnit!  Why'd you give away the answer?  I wanted to guess.
11:30:18 <AvengerX> nmessenger: :))
11:30:36 <apfelmus> dmhouse: hey :) i've managed to update the article, you were right to complain about the meager explanations. is it better now?
11:30:37 <AvengerX> hey, isnt f (g x) the same of f . g x ?
11:30:39 <Pastorn_> > [minBound .. maxBound] :: Maybe Bool
11:30:40 <lambdabot>  Couldn't match expected type `Maybe Bool'
11:30:46 <nmessenger> AvengerX: close
11:30:53 <nmessenger> AvengerX: f (g x) = (f . g) x
11:30:57 <Pastorn_> oh, right... it isn't instanced
11:31:12 <dmhouse> apfelmus: I've been busy working on other things. I'll have a thumb through and send an email to the wikibook ML.
11:31:29 <nmessenger> @instances Bounded
11:31:30 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
11:31:33 <chessguy> hey dmhouse , i've been playing with your BTree Zipper today
11:31:34 <ddarius> Parsec comes with combinators to handle most lexing issues for you, so it's usually most convenient to just use Parsec for everything.
11:31:41 <AvengerX> hmm
11:31:54 <Pastorn_> @info All
11:31:54 <lambdabot> All
11:31:58 <Pastorn_> GREAT!
11:32:00 <fantasma> > let div a b = 1 + div (a-b) b in div 12 3
11:32:03 <nmessenger> @src All
11:32:04 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:32:04 <lambdabot> Terminated
11:32:08 <nmessenger> @index All
11:32:08 <lambdabot> bzzt
11:32:12 <nmessenger> :/
11:32:15 <dmhouse> chessguy: wow, that was a while ago :) What's on your mind?
11:32:20 <Pastorn_> :'(
11:32:22 <apfelmus> dmhouse: np. it won't run away :)
11:32:22 <AvengerX> heh
11:32:25 <nmessenger> Pastorn_: I think @info is spellchecked to @id
11:32:28 <ddarius> fantasma: You may want a base case.
11:32:28 <fantasma> > let div 0 b = 0; div a b = 1 + div (a-b) b in div 12 3
11:32:29 <AvengerX> i was groupin f . ( g x )
11:32:29 <AvengerX> :P
11:32:30 <lambdabot>  4
11:32:34 <chessguy> dmhouse, well, specifically, xerox and i have been working on porting it to Data.Tree
11:32:40 <AvengerX> lame me
11:32:50 <ddarius> > gcd 12 3
11:32:52 <lambdabot>  3
11:32:58 <dmhouse> chessguy: okay, cool.
11:33:02 <Pastorn_> nmessenger: what about the normal :i / :info?
11:33:10 <nmessenger> Pastorn_: not in LB :(
11:33:19 <chessguy> dmhouse, i'd like to use it for doing genetic crossovers of ASTs
11:33:24 <fantasma> > let div 0 b = 0; div a b = 1 + div (a-b) b in div (-12) 3
11:33:27 <lambdabot>  Exception: stack overflow
11:33:39 <chessguy> dmhouse, i'm not sure if i can do that though without rewriting the whole zipper monad :(
11:33:42 <dmhouse> Pastorn_: you can get elements of it, e.g. ?instances.
11:33:43 * fantasma hates having to use guards
11:33:44 <ddarius> fantasma: Counting how many steps in Euclid's algorithm?
11:34:02 <fantasma> ddarius, no, it's just a division function :D
11:34:17 <nmessenger> fantasma: you could always use 'if's if they offend you so.
11:34:39 <ddarius> Ah, yes. Counting subtractions.
11:35:02 * Pastorn_ goes out on a shopping spree
11:35:15 <ddarius> > length $ takeWhile (/=0) $ iterate (-3) 12
11:35:16 <lambdabot>   add an instance declaration for (Num (a -> a))
11:35:42 <ddarius> > length $ takeWhile (/=0) $ iterate (subtract 3) 12
11:35:43 <lambdabot>  4
11:35:49 <fantasma> ;)
11:35:57 <fantasma> that's awesome
11:36:06 <fantasma> not recursive though
11:36:10 <chessguy> dmhouse, if i'm understanding right, Zipper hides the plumbing if traversing around a single tree, but as soon as i want to start zippering two trees at once, i'm screwed
11:36:28 <ddarius> It's coiterative.
11:36:50 <nmessenger> ddarius: watch you mouth!  >:/
11:36:59 <nmessenger> :P
11:37:03 <fantasma> today is my second day using haskell :)
11:37:06 <dmhouse> chessguy: zippering two trees?
11:37:48 <nmessenger> fantasma: the recursive bits are in the functions iterate, takeWhile, etc.
11:38:14 <chessguy> dmhouse, yeah, the idea would be to use the zipper to traverse to a random place in one tree, take the subtree rooted at that node, zipper to a random place in the other tree, swap out that node for the one removed from the other, then put the new subtree back in the first one
11:38:14 <nmessenger> so it's still "recursive" in a real sense
11:38:25 <fantasma> nmessenger, and that is called coiterative?
11:38:40 <nmessenger> oh, I'm not sure
11:38:45 <nmessenger> @wn coiterative
11:38:46 <lambdabot> No match for "coiterative".
11:38:47 <ddarius> iterate is coiterative.
11:38:56 <nmessenger> @all-dicts coiterative
11:38:57 <lambdabot> No match for "coiterative".
11:39:04 <dmhouse> chessguy: why not zipper down to the node you want to swap in the first place?
11:39:11 <ddarius> Now you take that definition and apply foldr/unfoldr fusion to get a deforested version
11:39:13 <dmhouse> Why the arbitrary break?
11:39:29 <chessguy> hmmm
11:39:33 <chessguy> not sure what you mean
11:40:31 <dmhouse> Oh, wait. I misunderstood.
11:40:49 <fantasma> nmessenger, what is the guard for dividing less than 0?
11:40:53 <chessguy> my explanation wasn't the clearest. i can gry again if you'd like
11:40:55 <dmhouse> So you zipper to two places in two different trees then swap the nodes pointed to?
11:41:02 <chessguy> correct
11:41:05 <ddarius> div a b | a < 0 =
11:41:09 <jfoutz> i want a datatype that's something like data Num a => PairsSumTen  a = P10(a,a). but i want the values of P10 to sum to ten. is that something i can (or should) encode in the type?
11:41:09 <mauke> please cry again
11:41:11 <nmessenger> ... | divisor /= 0 = ...
11:41:35 <fantasma> ddarius, i know that, but what goes after
11:41:36 <xerox> chessguy: you want to swap two random subtrees?
11:41:40 <dmhouse> chessguy: I'm pretty sure you can do that with the current API.
11:41:47 <chessguy> xerox, yes
11:41:48 <xerox> Yuck, you should have said that before.
11:42:02 <ddarius> jfoutz: The sane way would be to make it abstract and dynamically check the invariant...
11:43:02 <jfoutz> ddarius: i'm not sure what you mean by abstract. but you're saying, don't try to put it in the type, and just check that stuff in code, right
11:43:03 <jfoutz> ?
11:43:30 <ddarius> jfoutz: I'm saying that that's the sane way yes.  However, if you don't want to be sane, there are other ways.
11:43:39 <chessguy> xerox, you don't think i should use a zipper for that?
11:43:44 <nmessenger> sanity is overrated
11:43:46 <nrb23> @src ask
11:43:47 <lambdabot> Source not found. You speak an infinite deal of nothing
11:43:54 <xerox> chessguy: well, you can.
11:43:57 <nmessenger> @src MonadReader
11:43:57 <lambdabot> Source not found. That's something I cannot allow to happen.
11:43:59 <ddarius> @src (->) ask
11:44:00 <lambdabot> ask = id
11:44:04 <nrb23> @src Control.Monad.Reader ask
11:44:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:44:08 <jfoutz> ddarius: my grip on sanity is tenuous at best, so i'll stick with the sane way. thanks. :)
11:44:13 <AvengerX> Checking the invariant is something like estimating input values and seeing if the output values are the expected (in a given piece of code)
11:44:16 <xerox> chessguy: but using the current approach, it will take three traversals.
11:44:30 <AvengerX> Invariants are present when we have loops
11:44:59 <chessguy> three traversals of each tree?
11:45:24 <nmessenger> invariant is just something that should not ever be false in correct code.
11:45:26 <AvengerX> soemthing like: {x=1} a=x; {a=1} (the simplest case)
11:45:28 <nrb23> @src (->) local
11:45:28 <lambdabot> local f m = m . f
11:46:05 <nmessenger> the "m" action gets a local copy of the environment, modified by "f"
11:46:24 <nrb23> yeah, makes sense
11:46:52 <nrb23> @src (->) runReader
11:46:53 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:47:02 <chessguy> xerox, if you have a better idea, i'm listening
11:47:06 <xerox> chessguy: one traversal find the first Int, which represents the first selected node, another traversal finds the second Int, the other random node, and then a navigation to swap them, and back to the top.
11:47:06 <nrb23> @src Control.Monad.Reader.runReader
11:47:07 <lambdabot> Source not found. Take a stress pill and think things over.
11:47:13 <xerox> That's the current approach, right?
11:47:28 <nmessenger> probably id for ((->) e), too :)
11:47:29 <ddarius> nrb23: runReader is not a member of a class and further there isn't one for (e->)
11:47:36 <nrb23> @src runReader
11:47:36 <lambdabot> Source not found. Where did you learn to type?
11:47:37 <chessguy> assuming we're talking about Tree Int's, yes
11:47:43 <nrb23> ddarius: yeah, but where is it?
11:47:49 <ddarius> @index runReader
11:47:49 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
11:47:52 <nmessenger> @source Control.Monad.Reader
11:47:53 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
11:47:55 <chessguy> and probably traversals to find the size of each tree, too
11:48:15 <xerox> chessguy: I thought earthy's algorithm avoided that.
11:48:18 <ddarius> It is just a newtype unwrapper.
11:48:40 <nrb23> hm
11:49:04 <chessguy> xerox, oh, right. yes
11:49:04 <Cale> quicksilver: yeah?
11:49:40 <nmessenger> the Reader type contains a simple function from r to a, which may have a bunch of complicated compositions and argument repeating in the middle
11:50:02 <xerox> chessguy: I'm working on something now, I'll think about it later, sorry.
11:50:15 <chessguy> ok
11:50:30 <dmhouse> xerox: but traversals are O(1) if you're using a Zipper.
11:51:04 <chessguy> dmhouse, not in the number of nodes
11:51:46 <chessguy> anyway, i still think this algorithm is fine. i'm just not sure how to make it work with the zipper monad
11:53:57 <jdrake> Does Haskell lend itself in any reasonable capacity to the creation of games involving 2d graphics and medium level frame rates?
11:54:37 <chessguy> jdev, you should get the book Haskell School Of Expression
11:54:55 <ddarius> jdrake: Sure.
11:55:22 <nmessenger> I'm not qualified to answer that question, but there are a few examples
11:55:26 <nmessenger> http://haskell.org/haskellwiki/Libraries_and_tools/Games
11:55:27 <lambdabot> Title: Libraries and tools/Games - HaskellWiki
11:55:50 <jdrake> chessguy, already have it.
11:56:50 <chessguy> jdrake, well, by the end of that book, you're basically ready to star writing 2d games
11:57:02 <chessguy> in fact, he uses his library to write a 20-line paddleball game
11:57:31 <jdrake> nice, I will have to go through it
11:57:43 <jdrake> I have wanted to do some haskell stuff for the last two months, but school kind of gets in the way
11:58:32 <chessguy> know that feeling
11:58:51 <jfoutz> hehe. it never gets easier.
11:58:52 <nrb23> jdrake: turns out that work gets in the way when you're done with school
11:59:30 <jdrake> The work that I am going into stays at work.
11:59:32 <chessguy> nrb23, that's why you have to get a job programming in Haskell!
11:59:52 <nrb23> chessguy: it would help to be able to program in haskell first.. something I'm not ready to claim
12:00:01 <jfoutz> chessguy: i think there are two of them, and simon has one...
12:00:53 <apfelmus> chessguy: you want to swap two subtrees of a tree? i think you can do so by a nice circular program
12:00:54 <nrb23> I'd love to get my company using it, but I'm not sure it'll happen
12:01:02 <chessguy> apfelmus, oh?
12:01:03 <jdrake> I decided about 5 years ago that I wasn't going to go into programming. That was when I was twenty, and just dropped out of a college programming program. Took me a few years, but I am back at another college studying intrumentation and control. Beautiful stuff, with layers of complexity bound in the physical realm rather than bits and bytes.
12:01:06 <hpaste>  dufflebunk pasted "GHC error from HaRe" at http://hpaste.org/646
12:01:14 <dufflebunk> I'm trying to build HaRe, and I'm getting an error I don't understand
12:01:37 <apfelmus> chessguy: i think so.
12:01:39 <apfelmus> ?paste
12:01:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:02:11 <chessguy> i haven't looked much into circular programs
12:02:15 <ddarius> apfelmus: Wouldn't it just be swap (Branch l x r) = Branch r x l
12:02:40 <jfoutz> nrb23: i've actually heard you can get quite a bit of leeway in odd places. I met a guy in school that uses ML to do testing of software his company sells. he sort of snuck it in the door.
12:02:50 <apfelmus> ddarius: i think he wants to swap subtrees that are not necessarily adjacent
12:02:59 <jfoutz> nrb23: I'm trying to use it for random admin tasks at work, like link checking
12:03:14 <chessguy> apfelmus, correct. and in two different trees
12:03:15 <jfoutz> where it is haskell, not ml
12:03:19 <nrb23> jfoutz: I use it for a script that reminds me to update pages on our wiki...
12:03:23 <ddarius> A bit trickier.
12:03:46 <jfoutz> yeah. perl got started this way. :)
12:03:55 <nrb23> jfoutz: but my company writes compilers and debuggers... so really getting haskell in the door would involve getting real support in those realms
12:03:58 <apfelmus> chessguy: aha, two different trees. you have to say that :)
12:04:30 <chessguy> well, i did. must have been before you caught the conversation
12:05:14 <apfelmus> yes
12:05:20 <jfoutz> nrb23: i read an article about using quickcheck to generate test cases for java programs... i'd bet you could write a grammar to generate really ugly code for your languages, and the expected results.
12:05:36 <chessguy> apfelmus, i take it that blows your circular program idea away?
12:06:03 <apfelmus> chessguy: no, i hope not
12:06:07 <jfoutz> testing is sooo important with compilers and debuggers, nobody really complains if you provide more tests (imho)
12:06:22 <nrb23> jfoutz: well, I work on embedded JTAG debugging hardware... not much room for unit testing
12:08:11 <jfoutz> nrb23: ah, i see. yeah, in circuit emulation is way beyond me. good luck with that :)
12:08:49 <nrb23> jfoutz: specifically, I'd like to see haskell used to write our target-dependent "templates", since I think it would be much cleaner than C
12:09:10 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = ungroup2 . bitRev . group2 $ xs where group2 [] = []; group2 (x:y:xs) = (y,x):group2 xs; ungroup2 [] = []; ungroup2 (x,y):xs = x:y:ungroup2 xs in bitRev [1..16]
12:09:10 <lambdabot>  Parse error in pattern
12:09:17 <nrb23> unfortunately, Haskell isn't exactly supported by our Debugger, nor by our OS
12:09:33 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = ungroup2 . bitRev . group2 $ xs where group2 [] = []; group2 (x:y:xs) = (y,x):group2 xs; ungroup2 [] = []; ungroup2 ((x,y):xs) = x:y:ungroup2 xs in bitRev [1..16]
12:09:35 <lambdabot>  [16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
12:10:14 <ddarius> hmm
12:10:23 <jfoutz> nrb23: a lot of lisp guys would use lisp to generate C. you might try a haskell program that writes those templates.
12:11:03 <nrb23> jfoutz: code generation is impossible to debug
12:11:10 <fantasma> is there anyway to direct the output from ghci to a file
12:11:31 * jfoutz scratches his head
12:11:32 <SamB> nrb23: I thought the point was to not have bugs
12:11:46 <jfoutz> nrb23: uh, your debugger pulls the assembly back to C right?
12:12:04 <nrb23> SamB: you wish...
12:12:08 <nrb23> jfoutz: of course
12:12:31 <jfoutz> nrb23: and the assembly is generated by the C?
12:12:42 <AvengerX> ;> let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int) find (id,desc,price) find_id = [ (str,num) | (str,num) <- (desc,price), id == find_id]
12:12:46 <AvengerX> is this readable? :)
12:12:55 <nrb23> jfoutz: yes, in a very straight-forward way
12:13:25 <AvengerX> (I am trying to make a comprehension list from a n-touple to pick items matching id == find_id)
12:13:35 <nrb23> jfoutz: in order to support a non-imperative language in an imperative debugger, lots of things need to happen
12:13:47 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int) find (id,desc,price) find_id = [ (str,num) | (str,num) <- (desc,price), id == find_id]
12:13:48 <lambdabot>  Parse error
12:14:10 <nrb23> jfoutz: I could probably make our compiler work with haskell... it's the debugger that's the hard part
12:14:13 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int) find (id,desc,price) find_id = [ (str,num) | (cc,str,num) <- (id,desc,price), id == find_id]
12:14:14 <lambdabot>  Parse error
12:14:16 <hpaste>  apfelmus pasted "swap 2 subtrees" at http://hpaste.org/647
12:14:32 <apfelmus> chessguy: ^^
12:15:35 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)] in bd
12:15:37 <lambdabot>  [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]
12:15:44 <jfoutz> nrb23: the point is, the genrated code is only as ugly as you make it. presumably you'd make up some specification use haskell to parse the specification and spit out C i'm not sure how much information you can recover from the assembly, but presumably if you can figure out what line the problem came from in the C file, you could figure out what line in your specification generated that.
12:15:52 <hpaste>  apfelmus annotated "swap 2 subtrees" with "correction" at http://hpaste.org/647#a1
12:16:19 <ddarius> apfelmus: [Either ()] (1) kind error (2) [Bool]
12:16:27 * jfoutz shrugs
12:16:34 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int) find (id,desc,price) find_id = [ (str,num) | (cc,str,num) <- (id,desc,price)]
12:16:35 <lambdabot>  Parse error
12:16:40 <AvengerX> hmmmmmm
12:16:40 <nrb23> jfoutz: yes, but the point of a debugger is to hide the low level issues... how do you set breakpoints in a haskell program?
12:17:06 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int) find (id,desc,price) find_id = [ snd z | z <- (id,desc,price)]
12:17:06 <lambdabot>  Parse error
12:17:11 <apfelmus> ddarius: oh, of course.
12:17:23 <ddarius> AvengerX: You are missing a ';' and you need 'in ..'
12:17:29 <AvengerX> screw this list by comprehesion :(
12:17:35 <ddarius> I think
12:17:38 <AvengerX> ddarius: i'm trying to make the 'let' go first :)
12:17:42 <AvengerX> a ; where?
12:17:44 * ddarius isn't exactly sure what > does.
12:17:53 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int); find (id,desc,price) find_id = [ snd z | z <- (id,desc,price)]
12:17:54 <lambdabot>  Parse error
12:17:54 <AvengerX> ah yes
12:18:04 <AvengerX> but yet
12:18:05 <nrb23> jfoutz: I'm not saying it's impossible to do this, I'm just saying it's a lot harder than it sounds
12:18:13 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int); find (id,desc,price) find_id = [ snd z | z <- (id,desc,price)]; in bd
12:18:15 <lambdabot>   (id, desc, price)
12:18:15 <lambdabot>     In the definition of `find':
12:18:15 <lambdabot>         find (id, desc, ...
12:18:23 * mux discovers the --user flag for cabal-ized builds and rejoices
12:18:26 <mux> it rocks
12:18:33 <AvengerX> now it's more specific
12:18:33 <mux> it just... works
12:18:41 <chessguy> yeah, there's some bugs in that code
12:18:45 <siti> what does the --user flag do?
12:18:54 <ddarius> > let x = 3
12:18:54 <lambdabot>  Parse error
12:19:04 <jfoutz> nrb23: i see. i wasn't thinking about it like you're thinking about it.
12:19:05 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int); find (id,desc,price) find_id = [ snd z | z <- (id,desc,price)] in bd
12:19:06 <lambdabot>   (id, desc, price)
12:19:06 <lambdabot>     In the definition of `find':
12:19:06 <lambdabot>         find (id, desc, ...
12:19:11 <mux> siti: registers packages to a private per-user db
12:19:24 <ddarius> AvengerX: z <- (x,y,z) is non-sensical.  The thing to the right of the <- must be a list.
12:19:38 <siti> oh nice :)
12:19:40 <gotaku> I'm trying to understand reversible computation, but I just don't get it.
12:19:41 <hpaste>  mux pasted "Cabal rocks!" at http://hpaste.org/648
12:19:50 <mux> siti: see that paste :)
12:19:52 <ddarius> Presumably you want, z <- bd
12:20:12 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int); find bd find_id = [ (snd z, fst z) | z <- bd] in bd
12:20:12 <nrb23> jfoutz: yeah, I've spent a lot of time thinking about how to pull in non C-like languages into our debugger, and I havent' come up with anything yet
12:20:13 <lambdabot>  Couldn't match expected type `(String, Int)'
12:20:16 <pjd> gotaku: nifty
12:20:30 <siti> ok
12:20:36 <AvengerX> snd z fst z is String,Int
12:20:54 <hpaste>  apfelmus annotated "swap 2 subtrees" with "working path" at http://hpaste.org/647#a2
12:20:57 <int-e> snd and fst don't work on triplets
12:21:07 <gotaku> pjd: If you understand what it means, maybe.
12:21:15 <AvengerX> ahhh! how am I to rip things apart from triplets?
12:21:22 <chessguy> ?hoogle (a,b,c) -> a
12:21:23 <lambdabot> No matches, try a more general search
12:21:28 <nmessenger> @type (\(x,_,_) -> x)
12:21:29 <ddarius> @type snd
12:21:31 <lambdabot> forall t t1 t2. (t, t1, t2) -> t
12:21:33 <lambdabot> forall a b. (a, b) -> b
12:21:43 <pjd> gotaku: the concept or the details?
12:21:45 <nmessenger> matching!
12:21:45 <int-e> AvengerX: pattern match. instead of  z <- bd  use (a,b,c) <- bd
12:21:46 <sorear> pattern matching
12:21:49 <sorear> \(a,b,c) ->a
12:21:50 <AvengerX> ahh, pattern matching... but...
12:21:51 <AvengerX> hmmm
12:22:07 <nmessenger> after all, fst and snd use pattern matching
12:22:10 <nmessenger> @src fst
12:22:10 <lambdabot> fst (x,_) =  x
12:22:12 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int); find bd find_id = [ (desc,price) | (id,desc,price) <- bd] in bd
12:22:13 <lambdabot>  Couldn't match expected type `(String, Int)'
12:22:27 <gotaku> pjd: The concept mostly... If you built a computer just using toffoli gates then wouldn't that be reversible?
12:22:48 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int); find bd find_id = head [ (desc,price) | (id,desc,price) <- bd] in bd
12:22:49 <lambdabot>   (id, desc, price) <- bd
12:23:09 <AvengerX> > let bd :: [(Int, String, Int)]; bd = [(1,"Rice",100),(2,"Bean",129),(3,"Sugar",245)]; find :: bd -> Int -> (String,Int); find bd find_id = head [ (desc,price) | (id,desc,price) <- bd] in find bd 2
12:23:10 <lambdabot>   (id, desc, price) <- bd
12:23:15 <mauke> wtf
12:23:16 <jfoutz> nrb23: One way to go is, you make up a new language to describe your "templates" it could be purely declarative, or a C like language or whatever. use haskell to parse the template and generate the C. you can write very tricky and guaranteed correct C, but the user only sees the simplified frontend. It's probably not worth it.
12:23:21 <nmessenger> wtf indeed
12:23:40 <AvengerX> isthere another chan I can experiment with lambdabot? :)
12:23:59 <jfoutz> AvengerX: /msg lambdabot @help
12:24:02 <nmessenger> #haskell-overflow or -blah, or you could /msg her
12:24:06 <AvengerX> ah cool
12:24:08 <apfelmus> chessguy: plugAt should compile now
12:24:13 <siti> @botsnack
12:24:13 <lambdabot> :)
12:24:28 <pjd> gotaku: should be, probably
12:24:32 <AvengerX> I prefer the channel as someone there might help me :P
12:25:04 <pjd> but there might be additional separate concerns
12:25:11 <nrb23> jfoutz: we don't have many problems with "incorrect" C... most of our problems are in that hardware is a pain in the ass
12:25:14 <pjd> there's also the question of physical versus logical reversibility
12:25:20 <mauke> AvengerX: drop the type signatures
12:25:34 <nrb23> jfoutz: but I agree.. if the user doesn't see the frontend, it's not worth it
12:26:59 <chessguy> apfelmus, are you still working on it?
12:27:09 <apfelmus> no, i'm done :)
12:27:36 <chessguy> oh ok. the [Either ()] should be [Bool] ?
12:28:00 <apfelmus> yes. or you can take the 2nd annotation
12:28:15 <chessguy> oh, i didn't see the second one
12:28:39 <apfelmus> i somehow thought "Left" and "Right" would be nice names.
12:29:07 <apfelmus> but it's probably better to redefine them than to mess with Either
12:29:23 <ddarius> apfelmus: What's wrong with just a [Bool] or a [Either () ()], why that complex data type?
12:29:26 <chessguy> well, eventually i'll want to write this for Data.Tree
12:29:42 <fantasma> is this channel constantly logged?
12:30:05 <fantasma> @where logs
12:30:06 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
12:30:07 <chessguy> fantasma, yes. lambdabot is always watching
12:30:24 <ddarius> @topic-tell
12:30:25 <lambdabot> Do not know that channel
12:30:47 <apfelmus> ddarius: nothing's wrong with that. i just temporarily got crazy ;)
12:31:03 <apfelmus> @topic-tell #haskell
12:31:04 <lambdabot> ["The Haskell programming language: tip over the vending machine!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","
12:31:04 <lambdabot> The language of ICFP winners 3 years running"]
12:31:15 <chessguy> hmm, i don't get what's going on with this cdoe
12:31:16 <chessguy> code
12:32:01 <apfelmus> swap is the circular function
12:32:15 <chessguy> i don't really know what a circular function is
12:32:53 <apfelmus> well, subx depends on suby which in turns depends on subx
12:33:15 <ddarius> or rather they appear to.
12:33:17 <chessguy> oh, like corecursion?
12:33:29 <apfelmus> ddarius: indeed, that's the point
12:33:37 <apfelmus> corecursion?
12:34:08 <chessguy> hm, maybe not
12:34:39 <dufflebunk> Does anyone have any experience building HaRe?
12:34:40 <chessguy> so how would you use this?
12:35:12 <apfelmus> x and y are your trees and p and q are paths to the subtrees you want to switch
12:35:52 <apfelmus> i should have called plugAt differently, maybe exciseAt or replaceAt
12:36:21 <doserj> chessguy: another example for circularity:
12:36:25 <doserj> > let evens = 0:map (+1) odds ; odds = map (+1) evens in odds
12:36:25 <chessguy> so in Bin (Bin (Leaf 1) (Leaf 2)) (Bin (Leaf 3) (Leaf 4)), what would a path to 2 look like?
12:36:27 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:36:52 <syntaxfree> man, mutually recursive definitions = <3
12:37:05 <apfelmus> chessguy: well, you go left and then right, i.e. [Left (), Right ()]
12:37:45 <apfelmus> or [True,False] or P $ Just $ Left $ P $ Just $ Right $ P $ Nothing
12:37:55 <chessguy> oh, humm. not easy to port to Data.Tree
12:38:17 <ddarius> With Data.Tree you'd have type Path = [Int]
12:38:27 <chessguy> yeah
12:38:28 <apfelmus> or Path = [[()]]
12:38:45 <int-e> @hoogle Bool -> x -> Maybe x
12:38:46 <lambdabot> No matches, try a more general search
12:39:10 <chessguy> heh. a tie-fighter Path :)
12:39:12 <int-e> @hoogle Bool -> x -> Either x x
12:39:13 <lambdabot> No matches, try a more general search
12:39:35 <apfelmus> :)
12:39:37 <mauke> if' Left Right
12:39:40 <ddarius> @let x |*| y = [x,y] in 1 |*| 2
12:39:41 <lambdabot>  Parse error
12:39:41 <LoganCapaldo> bah
12:39:45 <pjd> a subclass can't define default implementations of any superclass methods?
12:39:57 <apfelmus> @pl (\b x -> when b (return x)
12:39:57 <lambdabot> (line 1, column 27):
12:39:58 <lambdabot> unexpected end of input
12:39:58 <lambdabot> expecting variable, "(", operator or ")"
12:40:04 <apfelmus> @pl \b x -> when b (return x)
12:40:05 <lambdabot> (. return) . when
12:40:29 <LoganCapaldo> @type let f c x = if c then return c else fail "" in f
12:40:32 <lambdabot> forall t (m :: * -> *). (Monad m) => Bool -> t -> m Bool
12:40:36 <LoganCapaldo> erm
12:40:42 <LoganCapaldo> @type let f c x = if c then return x else fail "" in f
12:40:44 <lambdabot> forall a (m :: * -> *). (Monad m) => Bool -> a -> m a
12:40:59 <apfelmus> @type (. return) . when
12:41:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> () -> m ()
12:41:19 <LoganCapaldo> apfelmus, I wasn't paying attn. while I was writing :)
12:41:50 <apfelmus> yeah, (return .) . when is wrong :)
12:42:00 <chessguy> ugh, so to do this for Data.Tree, i'm going to have to figure out how to build a random path
12:42:20 <LoganCapaldo> > let f c x = if c then return x else fail "" in f True 1 :: (Num a) => Maybe a
12:42:20 <ddarius> chessguy: A list of random numbers... (?)
12:42:21 <lambdabot>  Just 1
12:42:27 <LoganCapaldo> > let f c x = if c then return x else fail "" in f False 1 :: (Num a) => Maybe a
12:42:28 <lambdabot>  Nothing
12:42:31 <ddarius> Of course, guaranteeing that the path is actually in the tree...
12:42:56 <chessguy> ddarius, and that also wouldn't make all the nodes equally likely
12:42:57 <chessguy> i think
12:43:16 <apfelmus> yeah, equally likely is the tricky point
12:43:38 <LoganCapaldo> > let f c x = if c then return x else fail "" in f False 1 :: (Num a) => Either a String
12:43:39 <lambdabot>   add (Error a) to the expected type of an expression
12:43:39 <lambdabot>     In the expression: ...
12:44:00 <LoganCapaldo> > let f c x = if c then return x else fail "" in f False 1 :: (Num a) => Either String a
12:44:02 <lambdabot>  Left ""
12:44:13 <LoganCapaldo> > let f c x = if c then return x else fail "" in f True 1 :: (Num a) => Either String a
12:44:14 <lambdabot>  Right 1
12:44:22 <paolino> if the tree is constant aperture maybe
12:44:49 * LoganCapaldo hugs classes and monads and overloading in group (category?) hug
12:44:58 <hpaste>  chessguy pasted "random node algorithm" at http://hpaste.org/649
12:45:04 <chessguy> i think i could still use this
12:45:15 <chessguy> but have a stack which i keep the path in
12:45:19 <chessguy> and then reverse it at the end
12:48:06 <ddarius> > map (\x -> sin (pi * x / 5 - 5)) [0 :: Double, 15]
12:48:08 <lambdabot>  [0.9589242746631385,-0.9589242746631383]
12:48:54 <ddarius> > map (\x -> sin (pi * x / 5 - 5)) [0 :: Double .. 15]
12:48:56 <lambdabot>  [0.9589242746631385,0.9425184837694855,0.5661026671009054,-2.65451272782538e...
12:49:45 <chessguy> hrmmm
12:49:47 <apfelmus> chessguy: why not. though it's not clear what distribution you get for the subtrees.
12:50:00 <chessguy> why not what?
12:50:22 <apfelmus> the code would do the job
12:50:35 <chessguy> yeah
12:50:57 <chessguy> so how does it deal with the fact that subx and suby depend on each other
12:51:10 <ddarius> chessguy: They don't.
12:51:34 <ddarius> plugAt just fuses two traversals together to share code.
12:52:00 <ddarius> (and computation)
12:53:30 <apfelmus> instead of having randomTree returning only the subtree, you can return a pair (Tree a, Tree a -> Tree a) of the subtree and function that rebuilds the hole tree around the subtree
12:53:36 <xerox> petekaz: ping.
12:54:34 <apfelmus> ddarius: yeah. plugAt really has the type Tree a -> Path -> (Tree a -> Tree a, Tree a)
12:54:41 <Blackfoot> are there docs for installing libraries, like Data.ByteString, on OS X?
12:55:00 * nmessenger wonders about writing an instance Num (a -> a) where 0 f = id, 1 f = f, 2 f = f . f, 3 f = f . f . f ...
12:55:32 <apfelmus> Blackfoot: most likely, Data.ByteString is already installed. otherwise, Cabal makes installing libraries easy
12:56:14 <ddarius> nmessenger: That would be easy.
12:56:16 <Blackfoot> apfelmus: so if i get errors like "Could not find module `Data.ByteString':", then i should look into cabal?
12:56:35 <nmessenger> Church Numerals!
12:56:37 <sorear> Blackfoot: upgrate to 6.6 -OR-
12:56:38 <xerox> petekaz: print'result :: (P a [String]) => a -> IO ()
12:56:40 <sorear> @where fps
12:56:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
12:56:49 <xerox> petekaz: and you can pass in whatever number of functions
12:56:50 <sorear> ^^^ you need this lib (included with 6.6)
12:57:37 <chessguy> > let replace _ _ [] = []; replace 1 y (x:xs) = y:xs; replace n (x:xs) = x:(replace (n-1) y xs in replace 5 4 [1..10]
12:57:37 <lambdabot>  Parse error
12:57:38 <apfelmus> Blackfoot: yes. i mean you don't need to know really much, just follow the install procedure from the corresponding readme
12:57:48 <chessguy> a very revealing error
12:57:58 <Blackfoot> ok, thanks apfelmus, sorear
12:58:01 <ddarius> nmessenger: It would let you do things like toThe8th = 3 (join (*))
12:58:13 <nmessenger> Though that doesn't feel exactly right.  Better would be instance Function Integer
12:58:15 <Blackfoot> i install ghc through finc, which doesn't have 6.6 yet, so i'll look into those two options
12:58:32 <Blackfoot> fink
12:58:32 <chessguy> > let replace _ _ [] = []; replace 1 y (x:xs) = y:xs; replace n y (x:xs) = x:(replace (n-1) y xs in replace 5 4 [1..10]
12:58:33 <lambdabot>  Parse error
12:58:44 <apfelmus> chessguy: you have a ( too much at x:(
12:58:49 <nmessenger> @unpl join (*) . join (*) . join (*)
12:58:50 <lambdabot> (\ c -> ((*) >>= \ g -> g) (((*) >>= \ i -> i) (((*) >>= \ k -> k) c)))
12:59:00 <chessguy> > let replace _ _ [] = []; replace 1 y (x:xs) = y:xs; replace n y (x:xs) = x:(replace (n-1) y xs) in replace 5 4 [1..10]
12:59:02 <lambdabot>  [1,2,3,4,4,6,7,8,9,10]
12:59:11 <chessguy> thanks
12:59:50 <sorear> yay!
12:59:58 <sorear> I found my first code bug in yhc!
13:00:05 <sorear> (and fixed it to boot!)
13:00:32 <nmessenger> ddarius: I could imagine writing fromInteger, but (==), show, and the like would probably have to be undefined.
13:00:36 <apfelmus> Blackfoot: i uninstalled fink and switched to macports for that reason. unfortunately, macports is a bit fragile
13:01:05 <siti> just delete OSX ;)
13:01:12 <ddarius> nmessenger: The simplest solution would be x == y = x succ 0 == y succ 0
13:02:07 <apfelmus> siti: ? macports won't get less fragile by that :)
13:03:04 <nmessenger> ddarius: ah!  I just now understand it!  But wouldn't that be less polymorphics than (==) expects?
13:03:10 <nmessenger> s/s//
13:04:03 <nmessenger> I wouldn't want to require (Enum a) =>
13:04:34 <ddarius> nmessenger: If it is, that's not the problem.  You may need instance Num ((a -> a) -> (a -> a))
13:06:51 <ddarius> > let (==) :: (a -> a) -> (a -> a) -> Bool; x == y = x succ 0 == y succ 0 in const id == id
13:06:52 <lambdabot>   (x succ 0) == (y succ 0)
13:07:05 <nmessenger> I think I understand.  In order to represent n-fold composition, it'd have to take a function.
13:07:23 <nmessenger> still crazy, though 8-)
13:07:32 <ddarius> > let (==) :: (a -> a) -> (a -> a) -> Bool; x == y = x succ 0 == y succ 0 in const id == id
13:07:33 <lambdabot>   (x succ 0) == (y succ 0)
13:07:40 <ddarius> ookay... ?
13:07:54 <nmessenger> strange, AvengerX had the same weirdness
13:08:15 <ddarius> Ah.  Still don't understand the response, but I see a problem.
13:08:33 <ddarius> > let (==) :: (a -> a) -> (a -> a) -> Bool; x == y = x succ 0 Prelude.== y succ 0 in const id == id
13:08:34 <lambdabot>   (x succ 0) == (y succ 0)
13:09:05 <nmessenger> const id == id ?
13:09:31 <SamB> @type const id
13:09:33 <lambdabot> forall a b. b -> a -> a
13:09:37 <SamB> @type id
13:09:40 <lambdabot> forall a. a -> a
13:09:43 <SamB> I think not!
13:09:50 <ddarius> > let (===) :: (a -> a) -> (a -> a) -> Bool; x === y = x succ 0 == y succ 0 in const id === id
13:09:51 <lambdabot>   (x succ 0) == (y succ 0)
13:10:08 <nmessenger> SamB: would it be for b = (a -> a)?
13:10:24 <SamB> dunno...
13:10:34 <sorear> wow.
13:10:37 <SamB> no, wait...
13:10:44 <nmessenger> ... and the right function definition, disregarding the halting problem of course :)
13:10:52 <ddarius> > (const id succ 0 , id succ 0)
13:10:53 <lambdabot>  Add a type signature
13:10:56 <sorear> My 1 line patch to yhc "awaits moderator approval because it is too big"
13:10:58 <ddarius> > (const id succ 0 , id succ 0) :: Int
13:10:59 <lambdabot>  Couldn't match expected type `Int' against inferred type `(a, b)'
13:11:05 <ddarius> > (const id succ 0 , id succ 0) :: (Int,Int)
13:11:06 <lambdabot>  Add a type signature
13:11:12 <SamB> > (const id 1, id 1)
13:11:13 <lambdabot>  Add a type signature
13:11:26 <SamB> > (const id 1, id 1) :: (Int, Int)
13:11:27 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> a'
13:11:46 <nmessenger> const id x f = id f
13:11:48 <sorear> SamB: you want seq
13:11:59 <SamB> ????
13:12:08 <nmessenger> agreed, ????
13:12:20 <sorear> flip const, but shorter and with slightly different semantics
13:13:12 <sorear> > (seq id 1, id 1)
13:13:13 <ddarius> > (const id (succ :: Int -> Int) 0 , id succ 0) :: (Int,Int)
13:13:14 <lambdabot>  (1,1)
13:13:15 <lambdabot>  (0,1)
13:13:26 <ddarius> It couldn't resolve the dropped succ.
13:13:44 <nmessenger> sorear: I don't understand the difference in semantics, you think you could dummy-talk it to me?
13:14:03 <sorear> > flip const undefined 1
13:14:04 <lambdabot>  1
13:14:09 <sorear> > seq undefined 1
13:14:10 <lambdabot>  Undefined
13:14:23 <nmessenger> > const id undefined 1
13:14:25 <lambdabot>  1
13:14:51 <nmessenger> oh, I thought you meant (flip const) /= (const id)
13:15:09 * sorear ponders
13:15:39 <sorear> methinks those are the same
13:15:41 <xerox> petekaz: you can pass in any number of functions to |print'result|, along with a parameter, and if you choose the [String] type it'll return a list of showed results, if you choose the IO () type it will return an action printing each showed result. http://darcs.haskell.org/~paolo/darcs/tao/PrintResult.hs
13:15:48 <nmessenger> hence my confusion :)
13:16:14 <sorear> @suers
13:16:15 <lambdabot> Maximum users seen in #haskell: 329, currently: 316 (96.0%), active: 47 (14.9%)
13:16:29 <siti> lol it's smart :S
13:16:49 <siti> @laps sorear
13:16:50 <lambdabot> Maybe you meant: map slap
13:17:08 <siti> @saps sorear
13:17:08 <lambdabot> Maybe you meant: map slap
13:17:20 <siti> @slp siti
13:17:21 * lambdabot smacks siti about with a large trout
13:17:21 <glguy> ?help map
13:17:22 <lambdabot> map. #haskell user map
13:17:29 <chessguy> @map sorear
13:17:29 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
13:17:42 <chessguy> oh, that kind of map :)
13:18:04 <nmessenger> chessguy: I thought that at first, too :P
13:23:10 <hyrax42> are ghc-specific libraries like SYB and Data.Dynamic likely to end up in other implementations?
13:23:19 <Darius> > let (===) :: (forall a. (a -> a) -> (a -> a)) -> (forall a. (a -> a) -> (a -> a)) -> Bool; x === y = x succ 0 == y succ 0 in const id === id
13:23:19 <lambdabot>  Parse error
13:23:49 <hpaste>  chessguy annotated "swap 2 subtrees" with "apfelmus, suitable replacement for plugAt?" at http://hpaste.org/647#a3
13:23:58 <sorear> Data.Dynamic is very portable, it even has #ifdef statements
13:24:04 <sjanssen> hyrax42: Data.Dynamic isn't ghc specific
13:24:15 <hyrax42> oh ok
13:24:25 <sorear> Data.Generics requires rank2 and typeable, both very common, but is itself non-magical
13:24:36 <Darius> Hmm, that worked in GHCi.
13:24:43 <hyrax42> ?docs Data.Dynamic
13:24:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
13:24:49 <mauke> what library do I need to write a screensaver-like program in haskell?
13:24:53 <sorear> Darius: lambdabot does NOT use -fglasgow-exts
13:24:59 <Darius> Bah.
13:24:59 <sorear> mauke: X11 probably
13:25:03 <hyrax42> my bad then
13:25:21 <siti> opengl if you want a good screensaver ;)
13:25:21 <sorear> Darius: I think it is to prevent primops from parsing :)
13:25:44 <mauke> url?
13:26:03 <hyrax42> ?where hgl
13:26:04 <lambdabot> http://haskell.org/graphics/index.html
13:26:15 <sjanssen> hgl /= x11
13:26:16 <xerox> Yeah go for HOpenGL.
13:26:22 <chessguy> oh, he left
13:26:40 <sjanssen> mauke: X11 is one of the standard libs
13:26:50 <chessguy> xerox, interesting discussion with apfelmus about the subtree-swapping problem. i don't think i need a zipper after all
13:27:48 <Darius> apfelmus' solution is similar to using a zipper.
13:28:30 <chessguy> but without the overhead
13:29:30 <Darius> okay...
13:29:50 <chessguy> you disagree?
13:30:08 <Darius> It's pretty much an inlined and specialized use of a zipper.
13:30:45 <labadaba> #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny
13:30:47 <labadaba> #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny
13:30:49 <labadaba> #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny
13:30:51 <labadaba> #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny #Funny
13:30:56 <bd_> @get-op
13:30:57 <lambdabot> Unknown command, try @list
13:30:57 --- mode: ChanServ set +o xerox
13:31:07 <nmessenger> >:/
13:31:15 <xerox> ...
13:31:19 <chessguy> heh
13:31:25 <chessguy> you scared him off :)
13:31:26 <nmessenger> I've a mind to spam #haskell in #Funny
13:31:56 <chessguy> * nmessenger quit (k-lined)
13:31:57 <Darius> nmessenger: In many ways, that sounds like a very bad idea.
13:31:58 <mauke> don't DDOS
13:32:11 <nmessenger> aye, I agree
13:32:15 --- mode: xerox set +b *!*@83.243.88.*
13:32:26 <nmessenger> chessguy: what's that mean?
13:32:47 <chessguy> nmessenger, that's what'd be likely to happen to you
13:33:18 * nmessenger googles k-lined
13:33:35 <bd_> k-lined = banned from the ircnet
13:33:42 <nmessenger> geh
13:33:45 <dufflebunk> Does anyone have any experience building HaRe?
13:33:54 <sorear> nope
13:34:17 <chessguy> ?where HaRe
13:34:17 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
13:35:03 <dufflebunk> I'm getting an error about pattern type signatures, and I've no idea what it means.
13:35:06 <dufflebunk> http://hpaste.org/646
13:36:50 <Darius> > map (\x -> sin (pi * x / 5 - 1)) [0 :: Double .. 15]
13:36:51 <lambdabot>  [-0.8414709848078965,-0.363182599814102,0.2538291941861282,0.773886863344254...
13:37:01 <Darius> > map (\x -> sin (pi * x / 5 - 1)) [0 :: Double,5 .. 15]
13:37:03 <lambdabot>  [-0.8414709848078965,0.8414709848078966,-0.8414709848078966,0.8414709848078967]
13:37:06 <nmessenger> dufflebunk: you should use `asTypeOf`, reusing 't' like that isn't supported
13:37:47 <Darius> > map (\x -> sin (pi * x / 5 - pi)) [0 :: Double,5 .. 15]
13:37:49 <lambdabot>  [-1.2246063538223773e-16,0.0,1.2246063538223773e-16,-2.4492127076447545e-16]
13:38:21 <mauke> HOpenGL requires GreenCard, which fails for lack of FiniteMap :(
13:38:22 <nmessenger> > fromDynamic dx `asTypeOf` Just x
13:38:23 <lambdabot>   Not in scope: `x'
13:38:55 <dmhouse> mauke: woah, HOpenGL must be oool.d
13:39:04 <dmhouse> GreenCard is somewhat dusty now.
13:40:13 <mauke> > "ping"
13:40:15 <lambdabot>  "ping"
13:40:48 <nmessenger> > (\(x:'i':xs) -> (x:'o':xs)) "ping"
13:40:49 <lambdabot>  "pong"
13:41:00 <ehird> This channel just passed 1234 unread messages
13:41:04 <dufflebunk> nmessenger: I get a similar error using asTypeOf
13:41:05 <ehird> Just thought I'd say
13:41:06 <SamB> AvengerX: you around?
13:41:12 <nmessenger> :/
13:42:04 <mauke> argh. ghc-6.4.2: unrecognised flags: -fno-prune-tydecls
13:42:23 <nmessenger> dufflebunk: did you remove the (x :: t)?
13:42:32 <dufflebunk> nmessenger: No, let me try that
13:43:18 <dufflebunk> I have no idea what pattern type signatures are, I'm jsut trying to get it to build
13:43:47 <dufflebunk> nmessenger: Not in scope: `x'
13:43:57 <nmessenger> (x :: t) --> x
13:44:01 <dufflebunk> which is try, x isn't mentioned anywhere no except in Just x
13:44:05 <dufflebunk> Ahh
13:44:14 <xerox> chessguy: so your code now work with Data.Tree '
13:44:15 <xerox> ?
13:44:46 <dufflebunk> nmessenger: Yay! Thanks, it compiled.
13:45:48 <nmessenger> dufflebunk: heh.  I really had no idea what I was talking about.  That was seat-of-the-pants helping :)
13:47:35 <nmessenger> therefore I take no responsibility for the horrible mess of broken code I've just made. :D
13:47:52 <dufflebunk> nmessenger: better than I could have done. I had no idea what the syntax was supposed to mean
13:48:21 <nmessenger> f (x :: a) = y :: b;  is another way to say f :: a -> b; f x = y
13:48:22 <dufflebunk> Now I have an even nicer mess of complaints involving overlapping instances
13:48:56 <dufflebunk> ookay... is that form useful for something other than obfuscation?
13:49:00 <chessguy> xerox, the tree-swapping code does
13:49:13 <chessguy> xerox, i need to modify my random-subtree code to build a path
13:49:14 <nmessenger> possibly the t was important, then.  I've no idea how to help you. :(
13:49:34 <mauke> ok, this is seriously weird
13:49:56 <mauke> the ghc-6.4.2 docs describe -fno-prune-decls but the compiler doesn't seem to accept it
13:50:17 <nmessenger> it's a useful form when you want to type arguments in a context where it'd be more awkward to do any other place
13:51:17 <JoshTriplett> Lemmih: Around?
13:52:10 <Lemmih> Yes!
13:52:49 <dufflebunk> nmessenger: it supposed to have tests which can be run, so if I ever manage to get it to all build I should be able to tell if it's broken
13:52:53 <JoshTriplett> Lemmih: I just started playing with hsSDL; glad to find a Haskell binding for SDL, as I ran into the same issues with GLUT that you did.  Thanks!
13:53:17 <siti> yeah GLUT < SDL :)
13:54:08 <JoshTriplett> Lemmih: One minor bugreport: GFX fails to build, because it lacks a Build-Depends on base.  It also lacks "License: BSD3".
13:54:57 <JoshTriplett> Lemmih: Same with Mixer.
13:55:19 <Lemmih> Right. I actually have some really old patches that I've forgotten to push.
13:55:55 <JoshTriplett> Lemmih: Ah.
13:56:32 <JoshTriplett> Lemmih: Any beyond the cabal file fixes?  (IOW, should I wait for these patches before playing with hsSDL, to avoid running into bugs?)
13:57:27 <Lemmih> I'm not sure. Pupeno wrote them. (:
13:57:50 <hpaste>  sjanssen pasted "all subtrees and their paths from the root" at http://hpaste.org/650
13:58:00 <sjanssen> chessguy: like that?
13:58:05 <chessguy> hm
13:59:12 <chessguy> i've got a headache, i can't really read that code right now. any guess what the run-time is?
14:00:10 <sjanssen> O(nodes), I think
14:00:12 <chessguy> it compiles
14:01:14 <SamB> @tell AvengerX there is a #zsnes channel -- and I found the code that keeps ZSNES on the primary screen
14:01:15 <lambdabot> Consider it noted.
14:01:33 <lispy> SamB: still a zness hacker aye?
14:01:40 <lispy> er zsnes
14:01:57 <SamB> lispy: so it would seem
14:02:04 <lispy> cool
14:02:12 <lispy> SamB: re-written it in haskell yet? ;)
14:02:15 <SamB> I apparantly just fixed the sound generation
14:02:32 <SamB> lispy: dude, we don't even plan to re-write it all in C yet
14:02:41 <chessguy> sjanssen, your paths use 0 for the first child?
14:02:42 <lispy> it's in asm or something?
14:02:47 <sjanssen> chessguy: yeah
14:02:49 <SamB> yeah
14:02:52 <SamB> lots of it
14:02:53 <nmessenger> :O
14:03:06 <SamB> we hope to get most of it into C
14:03:17 <lispy> SamB: but at this point it could be written in just about anything right?  I mean the chip you're emulating is not a fast one
14:03:23 <nmessenger> SamB: could you wager an asm/C ratio?
14:03:26 <chessguy> ok, just wanted to make sure. it required a minor tweak to my code
14:03:29 <hpaste>  sjanssen annotated "all subtrees and their paths from the root" with "the algorithm to select a tree given a path" at http://hpaste.org/650#a1
14:03:32 <SamB> lispy: and run on my PII 450?
14:03:33 <mauke> I hope you get it working again. snes9x destroyed my saved games :(
14:03:46 <JoshTriplett> lispy: The graphics take most of the time, I think.
14:03:50 <lispy> SamB: oh hm...that is a trick
14:04:04 <JoshTriplett> lispy: So perhaps Haskell with C framebuffer functions.
14:04:16 <lispy> i bet HOpenGL could do it well
14:04:18 <SamB> "ZSNES - The Super Nintendo Emulator which is 72.9944% x86 assembly"
14:04:21 <SamB> from the TOPIC
14:04:25 <nmessenger> heh
14:04:28 <nmessenger> scary
14:04:31 <lispy> but, maybe not all that well on SamB's PII
14:04:37 <sjanssen> who was writing a gameboy emulator in Haskell?
14:04:39 <SamB> lispy: no no no
14:04:49 <nmessenger> @google haskell game boy emulater
14:04:51 <lambdabot> http://www.mutantlemon.com/omegagb/devlog/
14:04:51 <lambdabot> Title: OmegaGB Devlog
14:04:53 <JoshTriplett> nmessenger: You want scary, consider that that 72% includes the GUI.
14:04:56 <SamB> lispy: you can't use GL to handle these old things
14:05:10 <nmessenger> D: !!!
14:05:15 <lispy> SamB: why not? opengl has a perfectly fine 2d mode
14:05:46 <SamB> well, see, the rendering is done on-the-fly
14:06:02 <SamB> that means it is interleaved with execution
14:06:12 <lispy> SamB: oh i see
14:06:24 <SamB> so you can *change* all kinds of things in the middle
14:06:32 <lispy> SamB: so you need direct access to wherever you're rendering?
14:06:39 <SamB> (at least during hblank)
14:06:56 <SamB> you need direct access, and you'd write the code in something low-level
14:07:42 <lispy> SamB: i still feel like you could do it just fine in opengl if you configured the rendering state correctly
14:07:44 <SamB> but, ZSNES already supports using OpenGL to display the rendered frames
14:08:14 <lispy> oh, so you render them to a buffer (using your own drawing primitives) and then tell opengl to display the frame?
14:08:51 <SamB> well, not on *my* system
14:09:02 <SamB> it still supports software drawing
14:09:17 <SamB> and opengl runs too slow on my system
14:09:49 <stefanha> q/quiy
14:11:09 <JoshTriplett> lispy: OpenGL mostly serves as a means to draw a 512x448 buffer and scale it to a large resolution like 1400x1050 without having to touch that many pixels with the CPU.
14:11:56 <SamB> (or a 256x224 buffer)
14:12:03 <hpaste>  fuzan pasted "quizzer " at http://hpaste.org/651
14:12:10 <JoshTriplett> SamB: True.
14:12:18 <JoshTriplett> SamB: I play a lot of high-res games. :)
14:12:30 <SamB> oh?
14:12:49 <fuzan> hey, this is a little quizzer I wrote (quizzes you on words)  I was hoping that perhaps some of you more experienced haskellers could give it a gander and mention instances where I could simplify redundent code with some elegant haskell sugar.
14:13:03 <JoshTriplett> SamB: Some SNES games use the 512x448 size.  (Or possibly just high-res in one of those directions, I don't remember.)
14:13:26 <SamB> ah, you mean they actually use interlacing?
14:13:38 <JoshTriplett> SamB: Right, they draw differently to each field.
14:13:45 <SamB> wait.
14:13:50 <SamB> does ZSNES even support that?
14:13:54 * JoshTriplett nods.
14:14:08 <JoshTriplett> SamB: If you run with sufficient resolution, it does.
14:14:11 <ddarius> fuzan: If you are going to abuse monads, then 1) do it all the way and 2) use the monad functions.
14:14:19 <SamB> I don't actually know much about the graphics....
14:14:31 <JoshTriplett> SamB: You have to run a "D" mode, meaning anything but 256x224.
14:14:48 <SamB> well yeah
14:14:51 <JoshTriplett> SamB: You can also have ZSNES use the extra resolution when rendering Mode7, which makes it look more impressive. :)
14:14:52 <SamB> I know that much ;-)
14:15:39 <ddarius> makeDefinition line = do Just i <- B.findIndex (==':') line; let (l,r) = B.splitAt i line; return (Definition l (B.tail r))
14:16:01 <ddarius> s/Just i/i/
14:16:39 <sorear> @users
14:16:39 <lambdabot> Maximum users seen in #haskell: 329, currently: 313 (95.1%), active: 45 (14.4%)
14:16:58 <ehird> my emacs doesn't appaer to have a haskell-mode..
14:17:13 <lispy> ehird: you might need to download it
14:17:16 <lispy> ?where haskell-mode
14:17:17 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
14:17:42 <fuzan> ddarius: looking.
14:18:27 <ehird> i'm an emacs noob - if i download it, where would i put the mode file?
14:18:49 <JoshTriplett> ehird: Random question: what distro do you run?
14:19:07 <ehird> JoshTriplett: I don't. :P
14:19:10 <ehird> (OS X)
14:19:12 <lispy> ehird: http://haskell.org/haskellwiki/Haskell_mode_for_Emacs#Minimal_setup
14:19:13 <JoshTriplett> Ah.
14:19:14 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/w7vnb
14:19:23 <lispy> ehird: you can put it anywhere you like
14:19:24 * JoshTriplett wonders if fink has haskell-mode.
14:19:26 <fuzan> ddarius: When implementing this I was thinking that this may be a bit pointless, but I got carried away with wrapping things in monads :)
14:19:34 <lispy> ehird: i keep mine in ~/code/elisp/
14:19:47 * JoshTriplett uses ~/.elisp
14:20:06 <ddarius> fuzan: It's fine, but you are not using it consistently.
14:20:53 <JoshTriplett> SamB: I learned about the graphics system some time ago, because I hacked ZSNES to add some higher-resolution graphics modes.
14:21:08 <JoshTriplett> SamB: Specifically, my laptop panel sizes at the time. :)
14:26:47 <shapr> /
14:26:49 * shapr boings cheerfully
14:27:10 * Botje galms in response
14:27:11 <mbishop> I heard something on the news about some guy "rediscovering unicycles"
14:27:38 <chessguy> did he invent them in haskell?
14:27:56 * nmessenger wonders if shapr has a backstory for that
14:28:14 <sorear> bing!
14:29:10 <dmhouse> mbishop: where were they hidden?
14:29:16 <LoganCapaldo> > let { ($) f v = v f ; uni = [1] } in uni $ cycle
14:29:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:29:49 <nmessenger> LoganCapaldo: don't flip ($)!  THAT'S INSANE!
14:29:53 <dmhouse> > let uni _ = repeat 1 in uni cycle
14:29:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:30:02 <mbishop> dmhouse: shapr's house?
14:30:45 <nmessenger> > let uni = [1] in flip ($) uni cycle
14:30:46 <LoganCapaldo> nmessenger, I almost wrote let ($) = flip ($), and then I realized the problem with that :)
14:30:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:31:09 <sorear> flip id
14:31:18 <dmhouse> > let uni _ = () in const (repeat 1) (uni cycle)
14:31:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:31:31 <dmhouse> ?type let ($) = flip ($) in ($)
14:31:33 <ehird> does haskell-mode do smart indentation by default?
14:31:34 <lambdabot> forall b c. b -> b -> c
14:31:36 <nmessenger> > repeat 1
14:31:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:31:43 <nmessenger> :)
14:31:47 <pejo> ehird, there's a cocoa emacs with all the packages you'll ever need. Just drop it in /Applications.
14:31:49 <dmhouse> ehird: yep, there's a supplied module.
14:31:53 <ehird> pejo: Carbon Emacs.
14:31:56 <ehird> Yes, i know.
14:31:57 <ehird> I use it ;)
14:32:09 <ehird> dmhouse: do I have to load it or something? emacs n00b
14:32:13 <pejo> Oh, good. I need an irc client with working scrollback. :-)
14:32:33 <dmhouse> ehird: I know, I spoke to you about 15 minutes ago on #emacs :)
14:32:39 <nmessenger> > let ($) = flip ($) in 1 $ 2
14:32:43 <lambdabot> Terminated
14:32:45 <dmhouse> ehird: most new Elisp libraries will contain some documentation in the .el file.
14:32:46 <ehird> dmhouse: har
14:33:01 <ehird> pejo: ERC? =P
14:33:20 <nmessenger> (flip (flip (flip (... ($))))) 1 2
14:33:22 * SamB wonders if maybe he has OCD and not ADD?
14:33:34 * sorear has SUB, MUL, ADD, and DIV
14:33:39 <shapr> SamB: Don't obsess about it ;-)
14:33:46 <lispy> lol
14:33:47 <dmhouse> ehird: in this case, try haskell-mode.el
14:33:47 <chessguy> > (flip (flip (flip (... ($))))) 1 2
14:33:48 <lambdabot>   Not in scope: `...'
14:33:51 <pejo> ehird, think I tried that a couple of years ago. Didn't take enough time, I'd rather have something that just works.
14:34:04 <chessguy> > (flip (flip (flip ($)))) 1 2
14:34:05 <lambdabot>   add an instance declaration for (Num (a -> b))
14:34:11 <SamB> shapr: well, pagefault is saying that it is bad to take ritalin when you actually have OCD and not ADD...
14:34:17 <SamB> in #zsnes
14:34:29 <dmhouse> ?type let f ... _ = fix f in flip ... ($)
14:34:32 <lambdabot> forall b c. b -> b -> c
14:34:38 <ehird> bah, there should be a way to open a file in load-path in emacs
14:34:40 <ehird> there probably is.
14:34:42 <shapr> SamB: I would agree with that, but that's one small point of data in a very large problem/solution set.
14:34:44 <dmhouse> Wow, ... is a valid identifier.
14:34:48 <dmhouse> ehird: find-library.
14:34:56 <nmessenger> why wouldn't it be?
14:35:08 <SamB> so, how do you tell the difference?
14:35:09 <dmhouse> nmessenger: I'd expected it clash with module syntax.
14:35:26 <nmessenger> > let ($%.&!?!$*$) = "happytime!" in ($%.&!?!$*$)
14:35:27 <lambdabot>  "happytime!"
14:35:35 <dmhouse> Like, M.. means the (.) function from module M.
14:36:02 <nmessenger> hm, I'm not sure how that resolution works
14:36:05 <ehird> haskell-indent-mode sucks
14:36:14 <ehird> doesn't auto-indent after "main = do ....C-j" :/
14:36:16 <dmhouse> ehird: just keep hitting TAB.
14:36:27 <ehird> i have to tab three times.
14:36:41 <shapr> SamB: OCD's most obvious symptom is unnecessary "rituals" that must be done to be personally secure.
14:36:45 <dmhouse> It starts at the deepest possible indentation, although three times seems over the top here.
14:36:56 <SamB> shapr: hmm.
14:37:15 <shapr> SamB: For example, if you have to check that the door is locked five or six times every time you go to sleep.
14:37:21 <SamB> not that, no
14:37:41 <lispy> or touch a wall a certain way whenever you walk past it
14:37:43 <SamB> and usually when I multiple-check it is because I'm so damn absentminded
14:37:56 <dmhouse> ehird: for me, main = do RET TAB only offers one indentation.
14:38:18 <SamB> I definately wouldn't bother with checking multiple times whether or not the door was locked
14:38:22 <SamB> on the inside
14:38:32 <heatsink> I'm doing assembly-level debugging of a GHC port.  Where can I find out what the contents of the stg stack are supposed to look like?
14:39:50 <ehird> dmhouse: hm
14:39:52 <ehird> same here
14:39:54 <ehird> i have to 3-tab
14:39:57 <ehird> which is annoying
14:40:03 <ehird> (no better than my prev-editor)
14:40:34 <shapr> SamB: I think that means it's very unlikely you have OCD.
14:40:49 <dmhouse> ehird: which levels of indentation does it offer for each TAB press?
14:41:20 <ehird> dmhouse: let me check
14:41:33 <SamB> well, why would I care if the door was locked or not?
14:41:36 <ehird> first up to =. then the space between = and do. then after the do
14:41:39 <ehird> er, no
14:41:43 <SamB> as long as I'm not leaving
14:41:46 <shapr> SamB: With OCD, it's about rituals
14:41:46 <ehird> =, d in do, p in putStrLn after do
14:41:48 <hpaste>  dmhouse pasted "ehird: my haskell-mode config" at http://hpaste.org/652
14:41:54 <SamB> oh. well, maybe I have some
14:41:56 <SamB> I don't know
14:42:06 <SamB> does clicking on all the red tabs in x-chat count?
14:42:16 * ddarius does that.
14:42:24 <ddarius> even the rust colored ones.
14:42:25 <dmhouse> ehird: ah, you didn't mention you had a putStrLn.
14:42:33 <ehird> well, yes, to test my indent :)
14:42:45 <SamB> sometimes I type in the wrong one because of it, I think
14:42:45 <ehird> Also, backspace does individual spaces.
14:42:54 <ddarius> None of those is the way I would want it indented.
14:42:58 <dmhouse> ehird: what exactly are you testing with, then?
14:43:07 <ddarius> No, I never do that.
14:43:14 <ehird> dmhouse: main = do putStrLn "hello world."
14:43:23 <ehird> C-j. Tab tab tab. Now in right indentation.
14:43:50 * ddarius has always been happy with vim and autoindent.
14:44:08 <dmhouse> ehird: by 'right', I assume you mean aligned with the 'p' of putStrLn?
14:44:08 <ehird> it doesn't smart-indent based on haskell's layout
14:44:12 <ehird> dmhouse: yes
14:44:18 <dmhouse> I get that after two TABs.
14:44:29 <ehird> I get it after 3. But it should be automatic.
14:44:37 * ddarius gets the right indentation after 0 tabs.
14:44:48 <ehird> ddarius: Is it fully according to Haskell's layout?
14:45:00 <ddarius> ehird: The way I write Haskell, yes.
14:45:16 <dmhouse> TAB: Under ". TAB: Under p. TAB: 'main' is inserted at the beginning of the line, and the point's afterwards (so I could insert another equation for 'main'). TAB: beginning of line.
14:45:37 <dmhouse> ehird: yes, haskell-indent should have a better heuristic.
14:45:40 <pjd> does Haskell have any divMod analogue for logarithms?
14:45:54 <dmhouse> At the moment, it just starts at the deepest level.
14:46:01 <ddarius> pjd: As in?
14:46:07 <nmessenger> logExp? :)
14:46:16 <SamB> Integral exponent and mantissa?
14:46:41 <SamB> or maybe I don't mean mantissa
14:46:48 <SamB> I'm not sure what that actually is
14:47:07 <pjd> nmessenger: hoogle finds no logExp
14:47:21 <nmessenger> er, I was joking a bit :)
14:47:35 <pjd> it sounded plausible :)
14:50:56 <nmessenger> > decodeFloat (2.498e28)
14:50:58 <lambdabot>  (5679794412571937,42)
14:51:06 <nmessenger> something like that?
14:51:26 <pjd> ddarius: foo b n = let l = truncate (logBase b n) in (l, b^l)
14:51:29 <pjd> something like that
14:52:10 <nmessenger> @type (logBase *** (^))
14:52:12 <lambdabot> forall a a1 b. (Floating a, Integral b, Num a1) => (a, a1) -> (a -> a, b -> a1)
14:52:25 <nmessenger> > (logBase *** flip (^)) 2
14:52:26 <lambdabot>   add an instance declaration for (Num (a, b))
14:52:47 <nmessenger> > (logBase &&& (^)) 2
14:52:48 <lambdabot>  (<Double -> Double>,<Integer -> Double>)
14:53:00 <nmessenger> > (logBase &&& (^)) 2 (5,5)
14:53:01 <lambdabot>  Couldn't match expected type `t1 -> t'
14:54:58 <nmessenger> @pl \b n -> let l = truncate (logBase b n) in (l, b^l)
14:54:58 <lambdabot> ap ((.) . ap (,) . (^)) ((truncate .) . logBase)
14:55:04 <nmessenger> that should do the trick :D
14:55:46 <mauke> @. unpl pl \b n -> let l = truncate (logBase b n) in (l, b^l)
14:55:47 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ m b c -> ((,) >>= \ r -> ((^) m) >>= \ q -> return (r q)) (b c)) (\ y aa -> truncate (logBase y aa))
14:55:58 <mauke> <3
14:56:27 <ehird> @pl (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ m b c -> ((,) >>= \ r -> ((^) m) >>= \ q -> return (r q)) (b c)) (\ y aa -> truncate (logBase y aa))
14:56:28 <lambdabot> (.) . ((,) >>=) . (. (return .)) . (>>=) . (^) >> join (join id) `fmap` ((truncate .) . logBase)
14:56:31 <ehird> hah!
14:56:35 <ehird> obfuscation
14:56:47 <ehird> dmhouse: what does (require 'inf-haskell) do?
14:56:59 <nmessenger> yes, @. pl . unpl pl = instaobfuscate
14:57:11 <dmhouse> ehird: see the comments at the top of inf-haskell.el
14:57:18 <nmessenger> @. pl . unpl pl \b n -> (\l -> (l, b^l)) (truncate (logBase b n))
14:57:19 <lambdabot> (.) . ((,) >>=) . (. (return .)) . (>>=) . (^) >> join (join id) `fmap` ((truncate .) . logBase)
14:57:23 <ddarius> > iterate (\(i, nfac, exp, ln) -> let t = 1.5^i/nfac in (i+1, -nfac*(i+1), exp + abs t, ln + t)) (0,1,0,0)
14:57:24 <lambdabot>  Add a type signature
14:57:40 <ddarius> > iterate (\(i, nfac, exp, ln) -> let t = 1.5^i/nfac in (i+1, -nfac*(i+1), exp + abs t, ln + t)) (0.0,1.0,0.0,0.0)
14:57:41 <lambdabot>  Add a type signature
14:58:08 <ehird> ;;; inf-haskell.el --- Interaction with an inferior Haskell process. <-- heh, inferior
14:58:19 <ddarius> > iterate (\(i, nfac, exp, ln) -> let t = 1.5^i/nfac in (i+1, -nfac*(i+1), exp + abs t, ln + t) :: (Double, Double, Double, Double)) (0.0,1.0,0.0,0.0)
14:58:19 <ehird> why did you comment out the ghci mode? surely it would do better
14:58:19 <lambdabot>   add an instance declaration for (Integral Double)
14:58:35 <ddarius> > iterate (\(i, nfac, exp, ln) -> let t = 1.5**i/nfac in (i+1, -nfac*(i+1), exp + abs t, ln + t) :: (Double, Double, Double, Double)) (0.0,1.0,0.0,0.0)
14:58:37 <lambdabot>  [(0.0,1.0,0.0,0.0),(1.0,-1.0,1.0,1.0),(2.0,2.0,2.5,-0.5),(3.0,-6.0,3.625,0.6...
14:59:02 * mux gets all happy about the latest MySQL benchmarks where latest FreeBSD code scales much better than Linux
14:59:07 <ddarius> > drop 10 $ iterate (\(i, nfac, exp, ln) -> let t = 1.5**i/nfac in (i+1, -nfac*(i+1), exp + abs t, ln + t) :: (Double, Double, Double, Double)) (0.0,1.0,0.0,0.0)
14:59:09 <lambdabot>  [(10.0,3628800.0,4.481670706612723,0.2231161934988839),(11.0,-3.99168e7,4.48...
14:59:37 <ddarius> > (exp 1.5, ln 0.5)
14:59:38 <lambdabot>   Not in scope: `ln'
14:59:43 <ddarius> > (exp 1.5, log 0.5)
14:59:45 <lambdabot>  (4.4816890703380645,-0.6931471805599453)
14:59:59 <ddarius> > (exp 1.5, log -0.5)
15:00:00 <lambdabot>   add an instance declaration for (Fractional (a -> a))
15:00:09 <ehird> dmhouse: hm
15:00:13 <ddarius> > (exp 1.5, log (-0.5))
15:00:15 <lambdabot>  (4.4816890703380645,-Infinity)
15:00:21 <ehird> -Infinity, whoa
15:00:31 <dmhouse> Yeah, shame.
15:00:31 <ehird> dmhouse: your code doesn't seem to work, i don't get haskell-indent auto loaded
15:00:41 <dmhouse> > 1/0
15:00:42 <lambdabot>  Infinity
15:00:46 <dmhouse> Sigh.
15:00:50 <ehird> > -(1/0)
15:00:51 <lambdabot>  -Infinity
15:00:58 <ehird> > -(1/0) + 1
15:01:00 <lambdabot>  -Infinity
15:01:06 <ehird> > -(1/0) + (1/0)
15:01:07 <lambdabot>  NaN
15:01:17 <ehird> wouldn't -Infinity + Infinity = 0?
15:01:24 <JoshTriplett> ehird: No, not in general.
15:01:25 <ddarius> ehird: no
15:01:30 <nmessenger> because it's not a number :P
15:01:35 <ehird> well, true
15:01:42 <nmessenger> NaN
15:01:48 <ehird> > NaN
15:01:48 <lambdabot>   Not in scope: data constructor `NaN'
15:01:54 <JoshTriplett> ehird: That forces you to ask questions like "how big an infinity".
15:02:03 <ehird> an infinitely big infinity
15:02:05 <dmhouse> ehird: if you allow things like that all kinds of intuitive things break.
15:02:11 <JoshTriplett> > -(10/0) + (1/0)
15:02:13 <lambdabot>  NaN
15:02:19 <nmessenger> ehird: but how big is *that* infinity?
15:02:26 <ehird> > let nan = -(1/0) + (1/0) in nan + 4
15:02:26 <JoshTriplett> ehird: Should the above become 0, or -(9/0), or ...?
15:02:28 <lambdabot>  NaN
15:02:28 <JoshTriplett> ehird: :)
15:02:47 <dmhouse> I.e. 1/0 - 10/0 = Infinity - Infinity = 0, but 1/0 - 10/0 = 1 - 10 = -9
15:02:49 <ehird> it should become 'head = gone'
15:02:53 <nmessenger> an infinitely big (infinitely bin infinity)?  but how big is *that*?  :P
15:03:06 <dmhouse> Yeah, what JoshTriplett said.
15:03:16 <thalassocrac> 1^(1/0)
15:03:30 <ehird> nmessenger: the nfinite bin infinity.
15:03:34 <ehird> the infinite bin of infinity.
15:03:39 <ehird> it holds trash of all kinds of infinity
15:03:43 <ehird> including infinity, -Infinity, and NaN
15:03:49 <ehird> and "head = gone"
15:03:51 <nmessenger> it's all down hill from here \o/
15:03:59 <dmhouse> Someone remind me again why this happens:
15:04:00 <dmhouse> 1/0
15:04:05 <dmhouse> > 1/0 -- even
15:04:07 <lambdabot>  Infinity
15:04:13 <ehird> division by zero?
15:04:14 <dmhouse> I think it's to comply with some standard.
15:04:23 <dmhouse> ehird: why not throw a wobbly there?
15:04:29 <JoshTriplett> dmhouse: 854?
15:04:32 <nmessenger> > 1 `div` 0
15:04:33 <lambdabot>  Exception: divide by zero
15:04:35 <ehird> because space flights might use it and you'd want a very big number
15:04:38 <ddarius> IEEE 754
15:04:40 <dmhouse> 1/0 = Infinity _just_ _isn't_ _true_.
15:04:45 <ehird> instead of the spaceship to crash
15:04:48 <JoshTriplett> sigh, offbyone.
15:04:48 <nmessenger> > 1/1e-100
15:04:49 <ehird> crap reason
15:04:50 <lambdabot>  1.0e100
15:04:52 <ehird> but it's the official one
15:04:58 <JoshTriplett> ddarius: Right.
15:05:04 <ehird> Personally I'd want it to use 0
15:05:19 <ddarius> dmhouse: You should be able to set the FPU to generate an exception.
15:05:21 <dmhouse> 1/0 = -Infinity is equally valid and convincing.
15:05:25 <nmessenger> the reciprocal of a small number is large, so the reciprocal of 0 is the largest :)
15:06:19 <dmhouse> I.e. picture the graph of 1/x. As you approach x = 0 from the right, y shoots off to infinity, indicating 1/0 = Infinity, but then as you approach x = 0 from the left, y shoots off to negative infinity, indicating 1/0 = -Infinity.
15:06:35 <nmessenger> true
15:06:45 <bd_> so set -infinity == infinity? :)
15:06:50 <LoganCapaldo> therefore, -Infinity == Infinitiy
15:06:51 <ddarius> dmhouse: IEEE 754 has signed zeroes.
15:06:52 <LoganCapaldo> QED
15:06:55 <mbishop> > 1/0
15:06:56 <nmessenger> but we're being a little informal, and I know not the theory very well.
15:06:57 <lambdabot>  Infinity
15:07:06 <dmhouse> bd_: actually, that's what some people do; the notion of an unsigned infinity has been formalised.
15:07:06 <LoganCapaldo> bd_ you are too quick for me :)
15:07:15 <mbishop> it should throw divide_by_zero
15:07:25 <LoganCapaldo> 0 is unsigned too, no?
15:07:29 <mauke> > div 1 0
15:07:31 <bd_> heh
15:07:31 <lambdabot>  Exception: divide by zero
15:07:36 <Vq^> hugs does only give infinity i believe
15:07:48 <dmhouse> You can formalise my above argument: lim_{x -> 0+} 1/x = infty, but lim_{x -> 0-} 1/x = -infty, so the limit lim_{x -> 0} 1/x doesn't exist.
15:07:49 <Vq^> 1/(-0) == infinity
15:08:06 <thalassocrac> (1/0)*0
15:08:21 <ddarius> The relevance of my comment being if a floating point value gets truncated down to 0 it will be signed relative to the side of zero it was on and thus generate the "correct" signed Infinity.
15:08:34 <LoganCapaldo> > (1/0) * 0
15:08:36 <lambdabot>  0.0
15:08:43 <LoganCapaldo> that's interesting
15:08:48 <ehird> infinity*0 = 0
15:08:50 <ehird> doesn't seem right
15:08:56 <nmessenger> x * 0 = 0
15:08:58 <Vq^> :/
15:08:59 <dmhouse> (lim_{x -> 0+} 1/x means 'The value that 1/x tends to as x tends to 0 from above.)
15:09:19 <LoganCapaldo> infinity * x = "infinity" no?
15:09:35 <mauke> > (1/0) * (-1)
15:09:37 <lambdabot>  -Infinity
15:09:45 <JoshTriplett> LoganCapaldo: Technically, Infinity * 0 should probably give a NaN.
15:09:54 <LoganCapaldo> sounds good to me
15:10:09 <mauke> > (1/0) * (1/(1/0))
15:10:11 <lambdabot>  NaN
15:10:14 <Vq^> > 0/0
15:10:15 <lambdabot>  NaN
15:10:24 <JoshTriplett> LoganCapaldo: Same reasoning.  You could have something approaching 0 and something approaching infinity; whether that goes to 0, infinity, or some constant depends on the rates they change.
15:10:34 <nmessenger> I don't really understand reasoning about infinities like this.  I never got to The Calculus
15:10:58 <LoganCapaldo> JoshTriplett, ah makes sense
15:11:02 <JoshTriplett> Lemmih: How do I build and install your hODE bindings?
15:11:13 <LoganCapaldo> Calculus is fun!
15:11:20 <LoganCapaldo> Mmmm
15:11:35 * LoganCapaldo never got to multivariable calculus
15:11:48 <JoshTriplett> Lemmih: And do you have any sample code using it?
15:12:35 <ehird> > /0
15:12:36 <lambdabot>  Parse error
15:12:45 <LoganCapaldo> > (/ 0)
15:12:46 <lambdabot>  <Double -> Double>
15:13:04 <ehird> > let nan = -(1/0) + (1/0) in nan/0
15:13:06 <lambdabot>  NaN
15:13:30 <LoganCapaldo> > let nan = 0/0 in nan
15:13:31 <lambdabot>  NaN
15:14:04 <mbishop> > let nan = repeat "Na" in nan
15:14:06 <lambdabot>  ["Na","Na","Na","Na","Na","Na","Na","Na","Na","Na","Na","Na","Na","Na","Na",...
15:14:25 <nmessenger> > cycle "Na"
15:14:26 <lambdabot>  "NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaN...
15:14:32 <LoganCapaldo> if you define 1 as const 1, 2 as const 2, etc. then you could make 0 / 0 be a function that diverges or something...
15:14:40 <LoganCapaldo> mbishop, get out of my head
15:14:46 <LoganCapaldo> I was humming to myself!
15:14:57 * nmessenger hums heavy metal
15:15:07 <nmessenger> NaNaNaNaNa Nah Nah!
15:15:27 <JoshTriplett> LoganCapaldo: If you define 1 as const 1, then 1 diverges. :)
15:15:31 <chessguy> ugh
15:15:47 <LoganCapaldo> JoshTriplett, I think I meant define 1 as <some function>
15:15:50 <chessguy> i'm so tired of opening like 5 windows to look at and run different code
15:15:52 <LoganCapaldo> instead of just a alue
15:15:54 <LoganCapaldo> *value
15:16:00 <JoshTriplett> LoganCapaldo: I know; just poking fun.
15:16:02 <LoganCapaldo> ala Church numerals
15:16:03 <chessguy> why is there still not a decent IDE out there?
15:16:16 <mbishop> > putStr ("Hey jude!" ++ (cycle "Na"))
15:16:18 <lambdabot>  <IO ()>
15:16:22 <nmessenger> 0 f = id; 1 f = f; 2 f = f . f; ...
15:16:50 <ehird> LoganCapaldo: #haskell and #ruby-lang? paradox
15:16:58 <mbishop> > putStr "Hey Jude " ++ (cycle "Na")
15:16:59 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
15:17:02 <mbishop> pfft
15:17:08 <LoganCapaldo> ehird, why?
15:17:12 <ehird> bceause =P
15:17:17 <Lemmih> JoshTriplett: You need zeroth.
15:17:18 * qwr . o O ( cycle . return seems to be same as repeat )
15:17:25 <JoshTriplett> > do putStr "foo" -- ?
15:17:27 <lambdabot>  <IO ()>
15:17:30 <LoganCapaldo> maybe I've got a secret strongly typed lazily evaluated ruby compiler in my basement :)
15:17:37 <sorear> bah.
15:17:57 <sorear> it seems 'cat /proc/self/maps' shows something different every time.
15:18:11 * sorear misses the deterministic linker
15:18:33 <sorear> and GC-on-SEGV needs deterministic SEGVs to work!
15:18:36 <sorear> :(
15:18:47 <LoganCapaldo> woah
15:18:51 <LoganCapaldo> GC on SEGV
15:18:55 <LoganCapaldo> thats crazy
15:19:01 <LoganCapaldo> crazy awesome
15:19:01 * allbery_b hands sorear an ancient Bourne shell
15:19:22 <augustss> sorear: static lionking, perhaps?
15:19:29 <augustss> linking, even
15:19:40 <LoganCapaldo> a frozen Simba?
15:19:58 <JohnMeacham> no matter what I name a AM.. it can never be as cool a name as 'spineless tagless g-machine'.
15:20:41 <sorear> @remember JohnMeacham no matter what I name a AM.. it can never be as cool a name as 'spineless tagless g-machine'.
15:20:42 <lambdabot> Done.
15:20:58 <shapr> LoganCapaldo: hah
15:21:00 <sorear> allbery_b: ? did olde bourne do that?
15:21:13 <sorear> augustss: also confused...
15:21:26 <sorear> but I have a culprit
15:21:30 <sorear> stefan@stefans:/tmp$ cat /proc/sys/kernel/randomize_va_space
15:21:30 <sorear> 1
15:21:37 <JohnMeacham> sorear: out of curiosity, have you tried the benchmarks with the grin back end?
15:21:48 <LoganCapaldo> echo 0 > /...
15:21:51 <LoganCapaldo> bwahahaha
15:22:03 <sorear> JohnMeacham: no, I need to get a RAM upgrade first :)
15:22:15 <JoshTriplett> echo 0 | sudo tee /...
15:22:36 <sorear> JohnMeacham: if you are sufficiently convinced it will work, it is a 1-line fix to re-enable jhc-grin in nobench
15:22:40 <LoganCapaldo> JoshTriplett, I salute your elaborateness
15:22:42 <allbery_b> sorear: not garbage collection, no, but SEGV was the memory manager.  shell took SEGV, expanded the process's data segment and went on doing whatever it was doing
15:22:55 <allbery_b> actually there probably was some kind of GC involved, at that'
15:23:16 <JoshTriplett> LoganCapaldo: Handy when you run as non-root and use sudo; easier than trying to quote the redirection for the subshell.
15:23:30 <LoganCapaldo> indeed
15:23:32 <allbery_b> they had to redo it when they moved it off of DEC hardware; the 68000 couldn't restart instructions reliably after an address trap
15:23:36 <JohnMeacham> sorear: I am not that convinced. which is why I was curious. I'll run it on my own machine then. I have a healthy 2G of ram.
15:23:53 <sorear> I discovered this randomization because I don't want a stack/heap collision ... and my test prog crashes randomly
15:23:56 <JohnMeacham> sorear: I am replacing it anyway soon.
15:24:36 <sorear> JohnMeacham: darcs get http://www.cse.unsw.edu.au/~dons/code/nobench ; edit header.mk and add ' jhc-grin' to the end of the COMPILERS list
15:24:37 <lambdabot> Title: Index of /~dons/code/nobench
15:24:46 <sorear> then 'make'
15:24:51 <allbery_b> (Sun2s actiually used dual 68000s with a bizarre interconnection to work around that; after a trap the other processor was launched on the faling instruction)
15:24:54 <JohnMeacham> sorear: SEGV is pretty deterministic, you can use it along with mprot for write-barriers when doing progressive GC.
15:24:54 <augustss> looks like I need to check why hbc fails to compile so many of the nobench programs
15:24:55 <sorear> you might want to delete some compilers fist
15:25:02 <LoganCapaldo> @hoogle (a -> b -> c -> d) -> (c -> a -> b -> d)
15:25:03 <lambdabot> No matches, try a more general search
15:25:12 <LoganCapaldo> what, no ROT?
15:25:26 <sorear> JohnMeacham: is progressive another name for incremental here?
15:25:43 <JohnMeacham> yeah. I already grabbed the nobench. it just brings my desktop to a crawl... but perhaps I will bring an old computer out of retirement as a dedicated testing machine.
15:25:49 <JohnMeacham> yes. that is what I meant.
15:25:49 <LoganCapaldo> @djinn (a -> b -> c -> d) -> (c -> a -> b -> d)
15:25:51 <lambdabot> f a b c d = a c d b
15:26:16 <LoganCapaldo> @. pl djinn (a -> b -> c -> d) -> (c -> a -> b -> d)
15:26:17 <lambdabot> f = flip . (flip .)
15:26:21 <chessguy> sjanssen, still around?
15:26:22 <sorear> JohnMeacham: anyway, since I am much better at tight asm coding than 'gcc -Os', I am experiencing major urge to rewrite yhi.  Explicit heap checks are so HLL.
15:26:52 <LoganCapaldo> Hmm
15:27:19 <JohnMeacham> sorear: indeed. there are quite a few interesting papers on the subject. It is certainly something i was planning on looking into for jhc at some point.
15:27:36 <LoganCapaldo> with @. and hoogle and djinn (and maybe pl) and decriptive enough types, you could so get lambdabot to write you a whole, useful, program :)
15:27:48 <sorear> JohnMeacham: what subject? eliminating heap checks?
15:28:04 <sjanssen> chessguy: yes
15:28:15 <JohnMeacham> sorear: yes. using operating system help, such as SEGV.
15:28:18 <LoganCapaldo> @botsnack
15:28:18 <lambdabot> :)
15:29:25 <JohnMeacham> sorear: though, you still need to make sure allocation happens at 'safe' points, and put a memory barrier in there. otherwise the compiler might move code past the allocation.
15:29:32 <chessguy> sjanssen, i'm trying to rewrite your code to get just the paths
15:29:46 <chessguy> (without just tacking on a (map snd)
15:29:52 <chessguy> i have treePaths' t = [] : [(i:is) | i <- [0..(length (subForest t))-1], u <- (subForest t), is <- treePaths' u]
15:30:05 <chessguy> but it's giving me duplicate paths
15:30:44 <sorear> JohnMeacham: GC is very rare.  you could just write tables, the way gcc -g -O2 does.  move code freely and access the (large but lazily loaded) tables to find your roots.
15:31:29 <JohnMeacham> sorear: how do you allocate memory now? in order to do it right, I would use an mmap of /dev/null to get some anonymous memory, then 'mprotect' the last page.. assuming you use a simple linear allocator...
15:31:50 <sorear> JohnMeacham: I haven't started writing ayhi yet :)
15:32:00 <sjanssen> chessguy: you need to use zip
15:32:23 <sorear> JohnMeacham: or were you asking wrt my last suggestion?
15:32:29 <JohnMeacham> but 'mprotect' is a pretty cool call.
15:32:32 <chessguy> oh really? even if i'm not collecting the subtrees?
15:32:56 <JohnMeacham> I was curious why yhc did now.
15:33:00 <JohnMeacham> what.
15:33:10 <JohnMeacham>  s/why/what/  I mean.
15:33:32 <sjanssen> chessguy: by writing "i <- ..." and "u <- ...", you're going to get cartesian product behavior
15:33:38 <sorear> JohnMeacham: (just going by what's on the wiki) it has a hp and hplim, "HEAP_CHECK bytes" bytecodes, and expands the heap with sbrk.
15:34:11 <JohnMeacham> sorear: ah. I'll look at the wiki then... are you planning on trying to make it incremental as well?
15:34:22 <JohnnyL> @users
15:34:23 <lambdabot> Maximum users seen in #haskell: 329, currently: 315 (95.7%), active: 43 (13.7%)
15:34:30 <sorear> JohnMeacham: sbrk is a legacy from nhc98 days - nhc98 was not 32-bit-clean, so sbrk was used to ensure memory was in the low 2GB.
15:34:32 <chessguy> hmm. i almost may as well go ahead and collect the subtrees then
15:34:40 <xpika> how can i specify the error message on a read of an integer?
15:34:54 <xpika> > read "22" :: Integer
15:34:55 <sorear> JohnnyL: I am almost not a yhc hacker.  the only patch I've submitted was to the Sconscript
15:34:56 <lambdabot>  22
15:34:59 <sjanssen> chessguy: why did you want to avoid collecting the subtrees?
15:35:03 <sorear> JohnMeacham: : I am almost not a yhc hacker.  the only patch I've submitted was to the Sconscript
15:35:04 <xpika> > read "22a" :: Integer
15:35:06 <lambdabot>  Exception: Prelude.read: no parse
15:35:16 <JohnMeacham> sorear: ack. don't use 'sbrk'. it messes up standard library routines that use 'malloc'.
15:35:26 <chessguy> sjanssen, with the swap code i have, i don't need them
15:35:31 <xpika> can i get it to say myread: no parse or something
15:35:37 <chessguy> i just thought it would make my code cleaner
15:35:42 <augustss> > case reads "22a" of [(x,"")] -> x; _ -> error "Help, help"
15:35:43 <lambdabot>  Exception: Help, help
15:35:56 <sjanssen> chessguy: treePaths t = [] : [i:is | (u, i) <- zip (subForest t) [0..], is <- treePaths u] -- is the correct code
15:36:10 <xpika> ok
15:36:15 <xpika> that worls
15:36:19 <xpika> works
15:36:23 <JohnMeacham> on linux, mmap has the MAP_32BIT flag, to ensure the mapped memory is in the low 2G.
15:36:25 <chessguy> ah, ok
15:37:10 <sorear> JohnMeacham: not my fault.  darcs says the patch was submitted by Malcolm Wallace.  also, I don't know yet if yhc uses sbrk too.
15:37:47 <JohnMeacham> it definitely caused all sorts of heisenbugs for me when I used it.
15:38:40 <sorear> JohnMeacham: according to the yhi source, neither sbrk nor malloc nor mmap is used at runtime.  heap expansion is simply not supported.
15:39:01 <JohnMeacham> that's another way to go. :)
15:39:21 <sorear> the initial 16M heap is allocated with malloc
15:39:33 <sorear> (but see -h option)
15:42:09 * sorear has seen enough, and goes to write ayhi ...
15:42:56 * Tchakkazulu fails at cabal.
15:43:32 <Tchakkazulu> You know something is wrong when you see "*** Exception: Line 32: Unknown field 'hs-source-dirs'"
15:53:33 * ddarius prepares for foulness.
15:54:37 <hpaste>  chessguy pasted "Where is it inferring [Path] from?" at http://hpaste.org/653
15:56:44 <chessguy> this is wierd. when giving chooseRand a [[Int]], it should return [Int], right?
15:57:15 <allbery_b> what/where is swap?
15:57:25 <chessguy> oh, whoops
15:58:15 <hpaste>  chessguy annotated "Where is it inferring [Path] from?" with "swap function " at http://hpaste.org/653#a1
16:01:37 <allbery_b> hm.  swap's not in the monad; return $ swap ... ?
16:02:00 <allbery_b> (I don't *think* that should fix it, but who knows, maybe it inferred a list monad or something weird like that)
16:03:26 <chessguy> no difference
16:03:32 <chessguy> swap shouldn't need to be in the monad, should it?
16:03:49 <allbery_b> your return type involves a MonadState, looks to me
16:04:16 <chessguy> oh, yes, i do need return $
16:04:17 <allbery_b> so swap itself doesn't need to be in the monad but the invocation of it in cross needs to be lifted into the monad via return
16:04:49 <chessguy> got it now
16:06:32 <allbery_b> and, come to think of it,. do you need to unwrap p1 and p2?
16:06:58 <allbery_b> that is, instead of where p1 = ... you need p1 <- ...?
16:07:03 <chessguy> hmm
16:07:07 <chessguy> it's the same monad
16:07:14 <allbery_b> yes, it is
16:07:49 <chessguy> so i shouldn't need to, right?
16:08:03 <Tchakkazulu> swap expects a tuple of (Path, Path), but you give it a tuple (m Path, m Path)
16:08:13 <allbery_b> exactly
16:08:31 <chessguy> oh good grief
16:09:27 <chessguy> there are times when i really hate this langauge
16:09:43 <chessguy> [1 of 1] Compiling GPLib            ( GPLib.hs, interpreted )
16:09:43 <chessguy> Ok, modules loaded: GPLib.
16:09:48 <chessguy> that did it, thanks
16:11:59 <chessguy> what a terrible error message
16:12:23 <chessguy> extremely deceptive
16:13:27 <allbery_b> yeh, I don't get it myself unless it for some strange reason put it in the list monad instead of obeying the type
16:14:42 <heatsink> I dont suppose anyone here knows how to clean only the stage2 part of a GHC build?
16:20:12 <heatsink> ...okay, I'll rebuild the whole thing.
16:23:10 <JohnMeacham> yay. smaller executables.
16:23:23 <sorear> I am trying to port nasm-mode.el from XEmacs to RMSMacs ... I came across the following code:
16:23:23 <sorear> (defun nasm-line-matches (pattern &optional withcomment) ; REEXAMINE
16:23:23 <sorear>   (save-excursion
16:23:23 <sorear>     (beginning-of-line)
16:23:29 <sorear>     (looking-at pattern)))
16:23:32 <sorear> I installed XEmacs just to C-h f pattern .  How dumb am I?
16:23:58 <sorear> how much smaller?  and how?
16:24:08 <chessguy> sorear, you are far from dumb
16:24:24 * sorear likes small executables ... 45 bytes preferably
16:24:26 * shapr boings cheerfully
16:24:43 <sorear> chessguy: in general, or is that a common mistake for lisp non-experts?
16:24:47 <JohnMeacham> heh I know someone that wrote a 23 byte starfield.
16:24:57 <chessguy> sorear, in general
16:25:03 <chessguy> i don't have a clue what you're talking about right now
16:25:47 <sorear> JohnMeacham: yay.  unfortunately I use ELF Linux, which imposes a hard lower limit of 45 bytes.
16:25:53 <allbery_b> I think it's forgivable if you're not familiar with lisp
16:26:34 <sorear> now, let's see how good Xemacs nasm-mode is for me ...
16:26:35 <JohnMeacham> hmm.. I can't find his code. but there is a reference here: http://www.modplug.com/resources/showresource.php3/source/demonews149.txt  search for os2man 23 byte
16:26:38 <lambdabot> Title: Free Music Resources | MODPlug Software, http://tinyurl.com/22q75u
16:26:59 <sorear> http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html <--- my source
16:27:01 <lambdabot> Title: A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux
16:27:06 <chessguy> > 55 div 2
16:27:07 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
16:27:07 <lambdabot>     I...
16:27:14 <chessguy> > div 55 2
16:27:15 <lambdabot>  27
16:27:55 <mauke> *Main> 55 div 2
16:27:55 <mauke> 55
16:28:08 <AvengerX> `div`
16:28:09 <lambdabot> AvengerX: You have 1 new message. '/msg lambdabot @messages' to read it.
16:28:18 <chessguy> mauke, ?
16:28:19 <AvengerX> I?
16:28:29 <chessguy> how does that work?
16:28:50 <mauke> magic
16:28:52 <chessguy> AvengerX, using `div` or putting div out front are equivalent
16:29:06 <mauke> and instance (Num a, Monad m, Eq (m a), Show (m a)) => Num (m a)
16:29:18 <AvengerX> but he tried 55 div 2
16:29:22 <AvengerX> w/out `s
16:29:47 <chessguy> i did that, yes, by mistake. but i immediately fixed it
16:29:51 <nmessenger> so '55' is a function that takes 'div' and '2', and somehow smooshes them together
16:29:59 <mauke> yes
16:30:09 <mauke>     fromInteger = return . fromInteger
16:30:19 <AvengerX> didnt see you doing this chessguy... but mauke.. ah forget it :P
16:30:26 <mauke> and ((->) e) return = const
16:31:08 <chessguy> AvengerX, ignore mauke, he's showing off :)
16:31:31 <nrb23> hmm... I don't see an unpack16 or unpack32 in Data.ByteString
16:31:41 <nrb23> should I write these?
16:31:45 <dons> why?
16:31:46 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
16:31:55 <dons> (use Data.Binary for this)
16:31:58 <nrb23> so I can get a list of Word16s
16:32:09 <dons> or Data.Bits
16:32:40 <dons> unpackWord16 s = (s `index` 0) `shiftL` 8 .|. (s `index` 1) -- or something like that
16:33:10 <dons> in general parsing arbitrary data packed in a bytestring is handled by Data.Binary
16:34:00 <sorear> hello dons!
16:34:35 <sorear> JohnMeacham was here a little bit ago, he is now testing jhc-grin again on his box - he thinks it may be fixed
16:34:45 <nrb23> dons: that just pulls out one, right?
16:35:16 <dons> yep
16:35:21 <dons> sorear: ok good.
16:35:37 <dons> augustss: do you know where to find the latest hbc src?
16:35:49 <dons> augustss: i have the 2004-june src, which i put in darcs
16:35:50 <dons> ?where hbc
16:35:51 <lambdabot> http://www.cs.chalmers.se/~augustss/hbc/hbc.html
16:35:59 <dons> but is there anything more recent?
16:36:28 <augustss> dons: funny that you should mention it.  I'm compiling hbc as we speak.  it has not been touch in a while, so it need a little work
16:36:50 <augustss> dons: I'll compare yours with mine, but that could be the most recent
16:37:04 <dons> great news!
16:37:29 <dons> most of the hbc compilation errors are due to missing hier modules, i think
16:37:42 <augustss> yeah.  I thought I might actually fix that.
16:37:45 <sorear> dons: John also said that no, JHC rules are not intended to be the same as GHC rules, it is merely a very unfortunate coincidence of syntax
16:37:46 <dons> you can see the bulid failures listed here, http://www.cse.unsw.edu.au/~dons/nobench/bench.results
16:37:56 <augustss> It seems that hbc still beat ghc on a number of benchmarks
16:37:58 <sorear> JohnMeacham: whaddya think about RULES_JHC?
16:37:59 <JohnnyL> what is the future of haskell?
16:38:00 <chessguy> what is this recent emphasis on compilers other than GHC all about?
16:38:07 <sorear> JohnnyL: vvv
16:38:09 <sorear> @brain
16:38:10 <lambdabot> Uh, I think so, Brain, but I get all clammy inside the tent.
16:38:17 <sorear> uh, bad example
16:38:21 <AvengerX> JohnnyL: ask an eightball game :P
16:38:26 <sorear> but generally take-over-the-world
16:38:29 <dons> chessguy: healthy competition
16:38:33 <AvengerX> lol
16:38:34 <dons> augustss: quite so.
16:38:35 <JohnnyL> lmao
16:38:54 <LoganCapaldo> Tip over the vending machine?
16:38:58 <chessguy> competition with GHC, or other languages?
16:39:06 <augustss> dons: I thought they would have caught up by now.  I've given them log enough ;)
16:39:09 <dons> augustss: last night's numbers are available now, http://www.cse.unsw.edu.au/~dons/nobench/results.html
16:39:10 <lambdabot> Title: nobench: Haskell implementation shootout
16:39:20 <dons> hbc is definitely still competitive for pure h98
16:39:32 <JohnMeacham> sorear: iffy. they are mostly compatable. though, jhc has CATALYSTS as well... will think about it.
16:39:34 <sorear> there are some benchmarks where hbc >> ghc >> jhc speedwise
16:39:35 <dons> does quite well in the spectral category
16:40:09 <JohnMeacham> it wouldn't be hard to make it accept multi-line RULES actually. just tweak FrontEnd/HsParser.y slightly.
16:40:12 <sorear> JohnMeacham: does the lexer run after the cpp, so I could add #ifdef __JHC__ to fps
16:40:37 <JohnMeacham> sorear: yes. cpp runs before anything.
16:40:52 <dons> JohnMeacham: also, I note some jhc failures are due to it erroring on OPTIONS_GHC
16:41:00 <JohnMeacham> sorear: but I'd rather fix any issues in jhc if possible.
16:41:06 <JohnMeacham> that should just be a warning, not an error.
16:41:16 <sorear> dons: is it possible to access the jhc-ghc.compile files remotely?
16:41:26 <dons> let me just do that now.
16:41:56 <augustss> Recompiling hbc, excluding libs takes 1:44 on my 1.5GHz Athlon.
16:42:24 <sorear> augustss: 0:01:44 or 1:44:xx ?
16:42:50 <sorear> so why'd glasgow even try?
16:43:03 <augustss> 1 minute 44s wall clock
16:43:29 <sorear> wow
16:43:41 <sorear> augustss: with what compiler?
16:43:56 <augustss> With the LML compiler, since it's written in LML.
16:44:45 <mbishop> LML?
16:44:50 <JohnMeacham> sorear: what do you need from jhc for fps to work? I will make it accept RULES_JHC right now. but I'd also like to accept RULES for ones that can help both ghc and jhc.
16:44:54 <mbishop> ?where lml
16:44:55 <lambdabot> I know nothing about lml.
16:45:06 <sorear> Lazy ML
16:45:14 <sorear> one of the prehaskells
16:45:24 <JohnMeacham> okay. now it accepts RULES_JHC.
16:45:36 <sorear> JohnMeacham: I forget, but multiline RULES was the biggest sticking point
16:46:18 <JohnMeacham> where is the source? I can take a look later.
16:46:18 <augustss> mbishop: indeed, one of the pre-haskells
16:46:46 <mbishop> ah
16:46:55 <sorear> @where fps
16:46:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
16:47:33 <JohnMeacham> sorear: actually, we should have a standard way to specify pragmas only are for certain compilers.
16:47:35 <augustss> And 1:20 to build the libraries (H98 + some stuff)
16:47:39 <dons> sorear, augustss, JohnMeacham: all the compilation and output files from last night's run are here, http://www.cse.unsw.edu.au/~dons/nobench/logs/
16:47:40 <lambdabot> Title: Index of /~dons/nobench/logs
16:49:00 <sorear> JohnMeacham: strawman: {-# JHC:foo #-}  or {-# foo #-} for any
16:49:04 <hyrax42> is return a natural transformation from the identity functor to the m functor (m is the monad instance)
16:50:30 <sorear> ./Data/ByteString/Base.hs:296:9: Parse error
16:50:45 <chessguy> ?ty forM
16:50:47 <lambdabot>     Ambiguous occurrence `forM'
16:50:47 <lambdabot>     It could refer to either `forM', imported from Data.Traversable
16:50:55 <chessguy> ?ty forM_
16:50:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
16:51:08 <augustss> Does anyone know how to turn of $ as a legal character in cpp these days?
16:51:13 <sorear> JohnMeacham: line 296 is a comment.  does JHC not properly handle # foo directives?
16:51:21 <augustss> legal in identifiers, I mean
16:51:39 <sorear> JohnMeacham: and is it JHC or Jhc ? :)
16:51:42 <mauke> -fno-dollars-in-identifiers or something like that
16:52:02 <JohnMeacham> sorear: what are '# foo' directives?
16:53:41 <JohnMeacham> sorear: are you compiling with -fcpp?
16:53:47 <nrb23> dons: I'm trying to get a list of Word16 out of my ByteString, but I don't quite see a good way (probably because I'm not good at this stuff yet)
16:54:33 <JohnMeacham> sorear: Either 'Jhc' or 'jhc' depending on how reverant towards it you happen to be feeling at the moment.
16:54:58 <sorear> JohnMeacham: yes, FPS uses Extensions: CPP
16:55:09 <dons> nrb23: write a loop that reads 2 bytes at a time, then .|. them together
16:55:12 <dons> using Data.Bits
16:55:16 <JohnMeacham> but are you passing it on the command line?
16:55:17 <sorear> (should I not be trying to use runhaskell Setup.hs configure --jhc?)
16:55:31 <sorear> JohnMeacham: no I'm using cabal. Is that my problem?
16:55:44 <JohnMeacham> I have no idea. I didn't do any of the cabal stuff.
16:55:48 <sorear> GHCRTS='-F1.2 -H300M -c' runhaskell Setup.hs build -v3
16:55:57 <nrb23> dons: yeah, I can do that
16:56:39 <JohnMeacham> pass  --build-hl foo.cabal as an argument to jhc. it builds libraries on its own and understands a subset of the cabal file format.
16:56:51 <sorear> cabal echos: /home/stefan/bin/jhc -c -fcpp --noauto -i- -i dist/build/autogen -i . -p base-1.0 Data.ByteString Data.ByteString.Char8 Data.ByteString.Base Data.ByteString.Fusion Data.ByteString.Lazy Data.ByteString.Lazy.Char8
16:57:28 <JohnMeacham> or just write a Main that does a 'import Data.ByteString' and compile that and let jhc do dependency following. that is probably best for debugging.
16:57:42 <sorear> ok, now using ... GHCRTS='-F1.2 -H300M -c' jhc -v --build-hl fps.cabal
16:57:45 <sorear> oh
16:57:48 <sorear> fine then
16:57:54 <sorear> I like better ideas
16:58:18 <sorear> ./Data/ByteString/Base.hs:42:1: Parse error
16:59:13 <sorear> #if defined(__GLASGOW_HASKELL__)
16:59:26 <sorear> so --build-hl doesn't process Extensions:
16:59:41 <sorear> now with -fcpp
17:00:41 <sorear> ./Data/ByteString/Base.hs:296:9: Parse error
17:01:32 <sorear> I can't see anything weird in the code there, cpp or no cpp
17:03:32 <JohnMeacham> what function is that error in?
17:04:05 <sorear> JohnMeacham: either a commment, or unsafeFinalize
17:04:28 <sorear> JohnMeacham: is there any kind of -E option for jhc? or another way to find the options it is passing?
17:04:47 <JohnMeacham> options it is passing to what?
17:04:55 <sorear> cpp
17:06:26 <JohnMeacham> -D__JHC__ -traditional -P
17:07:13 <sorear> -P, I've never heard of that one and it's not in cpp --help
17:07:24 <sorear> No manual entry for cpp
17:07:34 <sorear> No menu item `cpp' in node `(dir)Top'.
17:07:42 <mauke> info cpp works here
17:07:53 <mauke> -P means: omit stuff
17:08:00 <sorear> mauke: debianproject hits
17:08:01 <mauke> like source location annotations
17:08:05 <sorear> ah.
17:08:08 <sorear> 'k
17:08:19 <mauke> but why -traditional?
17:09:03 <sorear> JohnMeacham++ you just saved me a LOT of time
17:09:07 <sorear>    296  foreign import ccall unsafe "string.h strlen" c_strlen
17:09:07 <sorear>    297      :: CString -> IO CInt
17:09:11 <sorear> looks nice
17:09:21 <sorear> does jhc have ffi support?
17:09:23 <chessguy> @pl \p -> t p f
17:09:24 <lambdabot> flip t f
17:10:00 <sorear> :)
17:10:01 <sorear> -fffi
17:10:07 <JohnMeacham> yes. if you pass -fffi
17:10:29 * sorear tries AGAIN
17:10:44 * sorear adds an OPTIONS_JHC pragma
17:11:26 <sorear> ./Data/ByteString/Base.hs:1   - Warning: The pragma 'OPTIONS_GHC' is unknown
17:11:26 <sorear> ./Data/ByteString/Base.hs:101 - Warning: The pragma 'CFILES' is unknown
17:11:26 <sorear> ./Data/ByteString/Base.hs:119 - Warning: The pragma 'UNPACK' is unknown
17:11:26 <sorear> ./Data/ByteString/Base.hs:119 - Warning: The pragma 'UNPACK' is unknown
17:11:29 <sorear> ./Data/ByteString/Base.hs:120 - Warning: The pragma 'UNPACK' is unknown
17:11:32 <sorear> Found dependency: Data.ByteString.Base at ./Data/ByteString/Base.hs
17:11:35 <sorear> ./Data/ByteString/Char8.hs:1   - Warning: The pragma 'OPTIONS_GHC' is unknown
17:11:40 <sorear> Found dependency: Data.ByteString.Char8 at ./Data/ByteString/Char8.hs
17:11:40 <sorear> ./Data/ByteString/Fusion.hs:238:1: Parse error
17:11:47 <sorear> YES! Two entire files parsed!
17:12:05 * sorear realizes paste thresholding error
17:12:09 <chessguy> @pl \p -> (p, t p f)
17:12:09 <lambdabot> ap (,) (flip t f)
17:12:37 <sorear> sure enough that error is in a rules
17:13:31 <chessguy> :r
17:14:05 <xpika> is there anyway to download the fa.haskell archive?
17:16:17 <chessguy> ?ty sequence
17:16:20 <lambdabot>     Ambiguous occurrence `sequence'
17:16:20 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
17:16:26 <chessguy> ?ty Control.Monad.sequence
17:16:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:16:30 <sorear> @get-dons
17:16:30 <lambdabot> Unknown command, try @list
17:17:17 <sorear> JohnMeacham: it looks like jhc has code for multiline RULES. what are the "rules" for using it?
17:17:33 <chessguy> ?ty forM
17:17:35 <lambdabot>     Ambiguous occurrence `forM'
17:17:35 <lambdabot>     It could refer to either `forM', imported from Data.Traversable
17:17:42 <chessguy> ?ty Control.Monas.forM
17:17:44 <lambdabot> Couldn't find qualified module.
17:17:45 <chessguy> ?ty Control.Monad.forM
17:17:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
17:19:05 <sorear> JohnMeacham: I think I've found it.  Jhc and GHC apply the layout rule in different (bi-incompatible) ways inside RULES.
17:19:30 <sorear> JohnMeacham: now the RULES parse ... Error: Module not found: System.Environment
17:21:00 <sorear> fps wraps getArgs!?
17:22:55 <mauke> @type guard
17:22:57 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:23:01 <mauke> that sucks
17:25:15 <chessguy> woohoo! i can now evolve a new population from a given one!
17:25:53 <xpika> ok i found it
17:33:38 <chessguy> @type sort
17:33:41 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:33:49 <chessguy> @type sortBy
17:33:52 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
17:34:22 <chessguy> ?hoogle Double -> Double -> Ordering
17:34:22 <lambdabot> No matches, try a more general search
17:34:30 <mauke> @type compare
17:34:33 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
17:34:54 <chessguy> i was going there next :)
17:36:01 <chessguy> ?hoogle sortBy
17:36:02 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
17:36:50 <sorear> JohnMeacham: Control.Exception.assert is missing (but the whole lib parsed! woohoo!)
17:38:41 <chessguy> @pl \(a,b) -> compare a
17:38:41 <lambdabot> compare . fst
17:38:58 <chessguy> :t compare.fst
17:39:00 <lambdabot> forall a b. (Ord a) => (a, b) -> a -> Ordering
17:39:56 <chessguy> @pl \(a,b) (c,d) -> compare a c
17:39:56 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
17:40:48 <mauke> @hoogle (Ord a) => (b -> a) -> b -> b -> Ordering
17:40:49 <lambdabot> No matches, try a more general search
17:40:56 <chessguy> :t compare (fst a) (fst b)
17:40:59 <lambdabot> Not in scope: `a'
17:40:59 <lambdabot>  
17:40:59 <lambdabot> <interactive>:1:21: Not in scope: `b'
17:41:08 <nmessenger> @type let on f g x y = g x `f` g y in (compare `on` fst)
17:41:10 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
17:41:32 <chessguy> oh yeah, that's readable
17:41:49 <nmessenger> sarcasm or sincerity?
17:41:59 <chessguy> sarcasm
17:42:33 <nmessenger> the on function is in the HEAD, until then you can define it seperately
17:43:40 <chessguy> :type let on f g x y = g x `f` g y
17:43:51 <chessguy> @type let on f g x y = g x `f` g y
17:43:53 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
17:43:54 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
17:43:54 <lambdabot>  
17:44:04 <allbery_b> *blink*
17:44:05 <nmessenger> !?
17:44:11 <chessguy> hmm
17:44:15 <jcreigh> oo-kay...
17:44:21 <chessguy> i don't think that was supposed to happen
17:44:29 <nmessenger> @type on f g x y = g x `f` g y
17:44:31 <lambdabot> parse error on input `='
17:44:32 <JohnnyL> hey chessguy, what did you just do, compile haskell code?
17:44:39 <nmessenger> @type \f g x y -> g x `f` g y
17:44:42 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
17:44:42 <chessguy> JohnnyL, apparently so
17:44:58 <dons> that's just the L.hs file being loaded into the type checker
17:45:09 <dons> the regexes broke a little on the update to 6.5
17:45:16 <nmessenger> update?
17:45:16 <JohnnyL> there is a version of the bot that accepts compiles? Yet this is not possible with current interpreters?
17:45:19 <nmessenger> @let test = 1
17:45:22 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:45:27 <dons> JohnnyL: hmm?
17:45:36 <dons> > 1+2 -- compiled
17:45:38 <lambdabot>  3
17:45:50 <nmessenger> JohnnyL: LB includes a Haskell compiler
17:45:52 * JohnnyL is confused.
17:45:56 <nmessenger> hs-plugins
17:46:00 <JohnnyL> nmessenger, oh ok.
17:46:04 <chessguy> well, i got a good laugh out of it anyway :)
17:46:24 <nmessenger> @vixen Broken?
17:46:25 <lambdabot> <undefined>
17:46:29 <dons> it is. yes.
17:46:51 <JohnMeacham> what is a good unambiguous name for the size of a pointer on a given arch?
17:47:14 <sorear> sizeof(void*)
17:47:15 <sorear> :)
17:47:17 <jcreigh> archPtrSize?
17:47:19 <sorear> PTR_BITS?
17:47:27 <JohnMeacham> 'word' means 16 bits to intel folk, 'native' could refer to the 'int' or 'intptr_t' size.
17:47:36 <JohnMeacham> no. a nice psuedo-english word.
17:47:46 <chessguy> Ok, modules loaded: GPLib.
17:47:47 <mauke> ptrsize
17:47:53 <nmessenger> I don't think there's anything succinct+unambiguous
17:47:56 <sorear> i'd go for word
17:48:07 <chessguy> woohoooooooooo! i'm ready for my first test
17:48:07 <sorear> i386 people can suffer
17:48:10 <jcreigh> or "N bits", where N is the size of the pointer. :)
17:48:13 <nmessenger> machine-size word?
17:48:17 <mauke> the C programmer in me notes that different pointer types can have different sizes
17:48:19 <JohnnyL> who controls how big of what gets compiled on Lambdabot?
17:48:20 * sorear says this as a i386 user
17:48:25 <JohnMeacham> well, I don't know the number of bits is the point.
17:48:31 <chessguy> after like 2 solid weeks of hacking
17:48:33 <sorear> JohnnyL: Everything is compiled in Lambdabot
17:48:46 <sorear> JohnnyL: Lambdabot does not contain an interpreter
17:48:46 <JohnnyL> sorear, that wasen't the questoin.
17:48:49 <JohnMeacham> mauke: indeed. but they all need to support (void *)
17:48:56 <nmessenger> JohnnyL: you mean like an expression size limit?
17:48:59 <JohnnyL> what about overloads?
17:49:03 <JohnnyL> nmessenger, yeah
17:49:05 <JohnMeacham> though, it does allow for separate code and data pointers.
17:49:08 <nmessenger> > fix (+1) 0
17:49:08 <sorear> JohnnyL: 510 chars
17:49:09 <chessguy> ?hoogle evalState
17:49:10 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
17:49:10 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
17:49:10 <lambdabot>   add an instance declaration for (Num (t -> a))
17:49:12 <JohnnyL> sorear, pardon my honesty.
17:49:20 <sorear> JohnnyL: enforced by IRC - 510 char limit
17:49:29 <nmessenger> > fix (+1)
17:49:31 <lambdabot>  Exception: <<loop>>
17:49:35 <sciolizer> subRegex (mkRegex "(.*)first") "This is the first" "\\g<1>1st"
17:49:39 <nmessenger> > 10^10^10^10^10
17:49:41 <jcreigh> > last [1..]
17:49:44 <lambdabot> Terminated
17:49:45 <sciolizer> generates error... Prelude.read (no parse)  why?
17:49:47 <lambdabot> Terminated
17:49:56 <nmessenger> @. elite run last [1..]
17:50:01 <lambdabot> +ErmIna7ED
17:50:04 <sorear> > array (0::Int,maxBound) [(4,'x')]
17:50:06 <lambdabot> Terminated
17:50:12 <sorear> > array (0::Int,maxBound) [(-1,'x')]
17:50:14 <lambdabot>  Exception: Ix{Int}.index: Index (-1) out of range ((0,2147483647))
17:50:19 <sorear> > array (0::Int,maxBound) [(0,'x')]
17:50:20 <lambdabot> Terminated
17:50:23 <sorear> > array (0::Int,maxBound) [(1,'x')]
17:50:25 <lambdabot> Terminated
17:50:31 <sorear> anyway it crashes :)
17:50:32 <dons> whatcha looking for?
17:50:33 <gigamonkey> If I were going to read one book to learn Haskell (to start with anyway) which would folks here recommend?
17:50:36 <fasta> JohnMeacham: size_of_pointer?
17:50:36 <jcreigh> JohnnyL: short answer: lambdabot times out. <g>
17:51:04 <sorear> dons: the magic, run-variable number that makes ghc panic rather than just segfault.
17:51:07 <dons> chessguy: you forgot to escape the " in the regex string
17:51:13 <dons>  "(.*)first") "This is the first" "\\g<1>1st" -->
17:51:27 <dons> ah sorry.
17:51:28 <dons> no.
17:51:43 <chessguy> dons, what are you talking about?
17:51:51 <sciolizer> dons: Basically, I want to know how to do unambiguous group references.
17:52:02 <sciolizer> chessguy: subRegex (mkRegex "(.*)first") "This is the first" "\\g<1>1st"
17:52:14 <JohnMeacham> I think data Shape =  NativePtr | NativeInt | Sized Int  will work.
17:52:31 <dons> what are you talking about chessguy ?
17:52:48 <chessguy> what regex string are you guys talkign about? i'm so lost
17:52:59 <chessguy> oh
17:53:12 <chessguy> dons meant that for sciolizer, not for me
17:54:36 <sciolizer> I want "\\11st" to be (the first group) ++ "1st". (not the 11th group)
17:54:49 <sciolizer> In some regex's, you can do "\\g<1>1st"
17:54:58 <sciolizer> But that results in an error in Text.Regex
17:55:01 <dons> these are posix regexes
17:55:15 <sciolizer> dons: Oh... You mean Text.Regex.Posix is different?
17:55:16 <dons> if you want extended pcre ones, i'd suggest using regex-pcre
17:55:26 <dons> Text.Regex just binds to posix
17:55:32 <dons> ?where regex-pcre
17:55:33 <lambdabot> http://darcs.haskell.org/packages/regex-pcre/
17:55:39 <dons> for more flexible perl style regexes
17:55:46 <sciolizer> dons: ok, thanks
17:55:48 <dons> or ... use parsec :-)
17:55:55 <sciolizer> dons: lol
17:56:58 <dons> i'd probably not use subRegex for this. take/drop/Data.List would likely be more robust. depends on what you're comfortable with
17:58:46 <sciolizer> dons: Well, the patterns I'm using are eventually going to be stored in a database, and I don't know of any databases that can store arbitrary Haskell code. :)
18:00:00 <dons> fair enough
18:00:26 <sorear> regex-parsec!
18:00:37 <dylan> anyone have any experience installing pcf fonts onto X11.app on OSX?
18:00:37 <dons> but yes, if you're making heavy use of regexes, regex-pcre or regex-parsec is to be preferred over the slow, old fashioned Text.Regex
18:00:47 <dylan> err, wrong place. XD
18:04:06 <dons> augustss: how's the build going? is there some darcs src i can poke around it?
18:07:31 <dons> mmm. http://supertech.csail.mit.edu/~sukhaj/libxac/
18:07:32 <lambdabot> Title: Libxac Documentation
18:07:46 <dons> memory mapped transactions (for IO)
18:11:16 <chessguy> :ty show
18:11:20 <chessguy> @type show
18:11:22 <lambdabot> forall a. (Show a) => a -> String
18:11:54 <JohnnyL> @type filter
18:11:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:12:12 <hpaste>  vagif pasted "guards in where " at http://hpaste.org/654
18:12:21 <vagif> this code gives me error
18:12:41 <vagif> how can i declare local function with where using guards ?
18:13:16 <dons> where x | 1 == 2 = 7 | otherwise = 8
18:13:28 <mauke> what's the error message?
18:13:37 <dons> ?pretty f x = y where y | True = False | otherwise = undefined
18:13:38 <lambdabot>  f x = y
18:13:38 <lambdabot>    where y    | True = False
18:13:38 <lambdabot>               | otherwise = undefined
18:13:57 <vagif> parse error on input  '|'
18:14:24 <mauke> vagif: works here
18:14:26 <vagif> same code outside of where works just fine
18:14:32 <vagif> try my code
18:14:35 <mauke> I did
18:15:51 <hpaste>  dons annotated "guards in where " with "works for me" at http://hpaste.org/654#a1
18:15:52 <vagif> duh! bloody tabs!
18:15:59 <Korollary> tab--
18:16:02 <dons> no tabs
18:16:06 <dons> :set ts=8
18:16:08 <dons> at the very least
18:16:16 <mauke> I use :set ts=4
18:16:30 <dons> vagif: i pasted a sightly more efficient version, you might be interested
18:16:34 * allbery_b tells emacs t expand tabs to spaces
18:16:45 <vagif> why it is efficient ?
18:16:56 <dons> mauke: :set ts=4 isn't haskell though
18:17:00 * sorear exorcises mauke
18:17:01 <dons> so unless you expand tabs..
18:17:07 <mauke> dons: it looks better
18:17:17 <dons> sure. but it'll break haskell code
18:17:36 <dons> since the report says tabs are 8 spaces. so if you mix tabs and spaces, expect layout errors
18:17:37 * sorear convicts mauke of blasphemy
18:17:39 <mauke> it doesn't break my code
18:17:42 <vagif> i removed all tabs and it works fine now
18:17:58 <vagif> but i'm curious why case is more efficient than guards here ?
18:18:09 <dons> no. it just does one compare and pattern matches on the tags
18:18:15 <dons> better than doing the same comparison 3 times
18:18:22 <vagif> oh i see
18:18:25 <vagif> thx :)
18:18:58 <dons> also, the final default case in a guard should be | otherise = ...
18:19:03 <dons> rather than a redundant e < y
18:19:13 <LoganCapaldo> > otherwise
18:19:14 <lambdabot>  True
18:19:22 <LoganCapaldo> heheheh
18:19:45 <dons> vagif: code looks good. you getting into the lambda hacking then?
18:20:10 <sorear> JohnMeacham: ping, what did you find troublesome about Show System.Locale?
18:20:17 <mauke> vagif: here's how I'd format it: http://rafb.net/p/1gID1j80.html
18:20:19 <lambdabot> Title: Nopaste - No description
18:20:21 <mauke> (works with tabs :-)
18:20:37 <sorear> JohnMeacham: I tried to remove that instance a while back to shrink a dependency group...
18:23:00 <dons> cool. dwm is getting smaller with time,     1693 total
18:24:09 <vagif> mauke: thx! pattern matching is reaking cool :)
18:24:20 <sorear> dons window manager?
18:24:42 <LoganCapaldo> Is it written in Haskell?
18:24:44 <dons> nah
18:24:55 <dons> dwm is a window manager in C I use.
18:25:01 <dons> we've talked about rewriting it in haskell though
18:25:41 <mbishop> didn't someone say they were already doing that?
18:25:50 <sorear> sjanssen:
18:25:56 <sorear> er, s/: //
18:25:59 <dons> yep.
18:26:32 <JohnMeacham> sorear: the Show instance generates a huge table, which triggers some exponential time bug in the optimizer.
18:26:45 <JohnMeacham> sorear: so I temporarily got rid of it.
18:27:22 <sorear> ah. :)
18:27:31 <sorear> not my issue with Shows
18:30:48 <jcreigh> I don't know about those "under X lines of code" projects...seems like say "fewer LoC is better!" is almost as bad as saying "more LoC is better!"
18:31:03 <jcreigh> s/\<say\>/saying/
18:31:16 <P4W3R> haskell is haskell
18:31:37 <thalassocrac> heh
18:31:56 <P4W3R> yiihaa
18:34:04 <dons> jcreigh: it seems to help this project, at least, create a nice culture of refactoring
18:34:51 <allbery_b> @quote about.2
18:34:52 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
18:36:13 <shapr> Refactoring culture is GOOD.
18:37:29 <jcreigh> yeah...reducing LoC by removing duplication is a Good Thing. Reducing LoC by removing features May Or May Not Be A Good Thing. I just hope it doesn't end up like "oh, that would be a really cool feature. But we can't do it because it would put us over the cap."
18:38:23 <allbery_b> most haskell reduction of LoC is just using higher order functions instead of being forced to write it all out by hand
18:38:31 <jql> unless it's a javascript library, in which case you do think like that
18:39:28 <dons> yeah, the refactoring culture of dwm seems to mesh with my haskell sensibilities
18:39:41 <dons> though the author of dwm is a big C fan :}
18:39:47 <dons> i think he's a closet FP hacker
18:39:52 <newsham> hi
18:39:53 <dons> in denial
18:40:13 <mbishop> he also uses vim
18:40:15 <mbishop> what a weirdo :P
18:40:23 <dons> shapr: so have you seen our little haskell implementation shootout project?
18:40:34 <dons> shapr: some interesting lessons there in kick starting development ..
18:40:57 <newsham> mmm, vim and C
18:41:01 <dons> main less: have projects compete in public
18:41:02 <newsham> two great tastes that taste great together
18:41:08 * allbery_b should pay closer attention
18:41:08 <dons> hehe
18:41:21 * allbery_b should be less dizzy, darn it
18:41:21 <LoganCapaldo> @hoogle Num
18:41:21 <lambdabot> Prelude.Num :: class (Eq a, Show a) => Num a
18:41:22 <lambdabot> Numeric :: module
18:41:22 <lambdabot> Ratio.numerator :: Integral a => Ratio a -> a
18:41:26 <LoganCapaldo> @doc Num
18:41:27 <lambdabot> Num not available
18:41:40 <dons> ?index Num
18:41:41 <lambdabot> Prelude
18:41:58 <LoganCapaldo> @doc Prelude.Num
18:41:58 <lambdabot> Prelude.Num not available
18:42:13 <dons> ?docs Prelude
18:42:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
18:42:30 <shapr> dons: Oh? what lessons?
18:43:08 <dons> shapr: so the shootout is here, http://www.cse.unsw.edu.au/~dons/nobench/results.html
18:43:09 <lambdabot> Title: nobench: Haskell implementation shootout
18:43:35 <dons> but since putting up, we've had jhc, nhc, yhc, ghc and hbc patches/bugs identified, and devel effort revived
18:43:41 <shapr> Wow cool!
18:43:42 <shapr> That's great!
18:43:48 <dons> all because you've got a) concrete numbers and b) public results
18:44:00 <shapr> Tell me you're going to turn this into a research paper.
18:44:02 <dons> so its a natural hackers competition.
18:44:06 <dons> i wish :-)
18:44:06 <fnord123> dcoutts, do you know a good channel for glade/gtk stuff?
18:44:15 <dons> though there's a paper in a really good replacement for nofib, i think
18:44:16 <dons> maybe..
18:44:29 <LoganCapaldo> hrm thats funny
18:44:34 <shapr> dons: There's *lots* of "cultural computing" 'papers' coming out of the Agile world, why not FP too?
18:44:40 <LoganCapaldo> (/) isn't in Num
18:44:42 <dons> hehe
18:44:44 <LoganCapaldo> (nor is div)
18:44:49 <allbery_b> nope
18:45:00 <dons> right. so a software eng. paper on using public competition to drive productivity
18:45:07 <dons> some sort of 'agile' method
18:45:35 <allbery_b> div is in Integral, (/) in Fractional
18:45:50 <LoganCapaldo> yeah I know that now :)
18:46:05 <dons> shapr: see , my intuition was, that if we can put numbers on things, the compiler hackers will naturally want to make those numbers smaller
18:46:13 <dons> since that works for me.
18:46:18 <dons> (i.e. on the great language shootout).
18:46:44 <dons> but you've got to make the numbers public.
18:47:24 <newsham> fnord: there's a gtk+ channel isnt there?
18:48:02 <fnord123> ah, that has more people than #gtk which I tried; I also tried the irc.gnome.org network but it's a bit thin on people
18:59:38 <newsham> ?seen beschmi
18:59:39 <lambdabot> I saw beschmi leaving #haskell-overflow, #haskell-blah, #haskell and #darcs 19h 40m 26s ago, and .
19:00:47 <dons> @tell beschmi sml mode, might be interesting, http://www.smlnj.org/doc/Emacs/sml-mode.html
19:00:47 <lambdabot> Consider it noted.
19:02:58 <dons> mm. dwm 3.7 seems to be noticeably faster than 1.9
19:03:05 <dons> me likes
19:03:35 <dons> its like getting a cpu upgrade when your wm starts running faster
19:04:10 <fnord123> in os x land, it's called "snappy". e.g. its snappier.
19:04:11 <SamB> dons: how can you tell if it is running faster?
19:04:34 <dons> it just 'feels' faster.
19:04:51 <SamB> I would have thought that with a CPU like yours, it would be fast period
19:04:51 <dons> it could be entirely false. or due to other subjective issues
19:05:22 <dons> yeah, its already plenty fast.
19:19:57 <sorear> I can't seem to write ayhi.  I'm too busy imagining how wonderful it will be.
19:25:44 <LoganCapaldo> I can't do return if cond then v else v'  ?
19:25:48 <LoganCapaldo> :(
19:25:56 <sorear> return $ if ...
19:26:00 <allbery_b> paentheses?
19:26:08 <sorear> voodoo programming, but it Works For Me
19:26:15 <LoganCapaldo> $ works with if???
19:26:25 <beelsebob> LoganCapaldo: it works with anything
19:26:25 <jcreigh> LoganCapaldo: yeah, if is just an expression.
19:26:32 <jcreigh> $ is the answer to everything. :)
19:26:34 <beelsebob> it's a function that means "applied to"
19:26:51 <beelsebob> it essentially puts parentheses round the expression to the right
19:26:53 <LoganCapaldo> oh der
19:26:59 <LoganCapaldo> I'm being silly again
19:27:09 <LoganCapaldo> So wait
19:27:15 <LoganCapaldo> return if ...
19:27:25 <LoganCapaldo> should so work if $ if ....
19:27:30 <LoganCapaldo> works
19:27:33 <mauke> > return if True then 1 else 2
19:27:34 <lambdabot>  Parse error
19:27:40 <mauke> sucks
19:27:43 <beelsebob> > return $ if True then 1 else 2
19:27:44 <jcreigh> LoganCapaldo: no, "if" isn't a function. But return is.
19:27:44 <lambdabot>   add an instance declaration for (Show (m a))
19:27:59 <LoganCapaldo> I know
19:27:59 <mauke> > return $ if True then 1 else 2 :: Maybe Int
19:28:00 <lambdabot>        add an instance declaration for (Show (m (Maybe Int)))
19:28:09 <mauke> haha
19:28:22 <LoganCapaldo> but I'm saying the parser should make if huddle more closly together
19:28:34 <beelsebob> > (return $ if True then 1 else 2) :: Maybe Int
19:28:36 <lambdabot>  Just 1
19:28:38 <jcreigh> ah.
19:29:03 <beelsebob> LoganCapaldo: yeh, I've always wondered what would happen if you tried to stick a type checker in the parser
19:29:24 <beelsebob> i.e. rather than having associativity rules, get it to parse the way that the types match
19:29:38 <mauke> that doesn't help with 1 + 2 * 3
19:29:39 <jcreigh> gah! magic!
19:29:39 <LoganCapaldo> oooo
19:29:42 * jcreigh runs away
19:29:45 <LoganCapaldo> that's a cool idea
19:29:45 <hyrax42> ambiguity could occur no
19:29:54 <beelsebob> mauke: true that - but you could sort a lot of it
19:30:06 <jcreigh> isn't Haskell hard to parse already, what with user-defined fixity?
19:30:10 <beelsebob> yep
19:30:18 <beelsebob> Haskell is fucking awful to write a compiler for
19:30:22 <LoganCapaldo> well yeah
19:30:24 <sorear> beelsebob: your suggestion is easy
19:30:26 <SamB> yeah, generally it has to be parsed in two stages
19:30:27 <beelsebob> doesn't mean I don't want to make life more diffcult :P
19:30:29 <LoganCapaldo> but there would be none of that
19:30:33 <sorear> beelsebob: failure as list of suggestions
19:30:37 <LoganCapaldo> since it would be parsing based on the types <g>
19:30:41 <beelsebob> sorear: indeed
19:30:41 <SamB> the second stage needing the interface files
19:30:56 <beelsebob> sorear: what I really wondered is can it be done more efficiently than that
19:31:18 <beelsebob> what sort of errors would you report if there were more than one way of parsing it
19:31:28 <beelsebob> tbh, I think there's a lot of research that could be done there
19:31:29 <chessguy> sigh. why is my program generating the same result with different seeds for the RNG?
19:31:32 <sorear> beelsebob: when a yhc@haskell.org message goes to moderation, what hours are the person on the other end awake?
19:31:42 <sorear> @vera tbh>
19:31:44 <sorear> @vera tbh
19:31:45 <lambdabot> No match for "tbh>".
19:31:46 <lambdabot> No match for "tbh".
19:31:53 <beelsebob> sorear: uhh... when ndm, me or tom are up
19:31:58 <SamB> beelsebob: I'm guessing you'd run into that far more often with type-based precedence
19:32:12 <beelsebob> sorear: often it gets ignored because 99.999% of unregistered stuff is spam
19:32:12 <sorear> beelsebob: oh, so that really IS a disjunction!  how is it implemented?
19:32:28 <sorear> beelsebob: my message was too long
19:32:44 <beelsebob> sorear: let me go check if it ended up in my inbox
19:32:46 <sorear> beelsebob: read: you need to tag your repo, you are losing patches to the spamfilter
19:32:56 <sorear> I fixed a FTBFS
19:33:01 <sorear> I'm sure you want that
19:33:21 <sorear> but you didn't get it because 50k of patch context > 40k limit
19:33:22 <jcreigh> I think that Haskell error messages are confusing enough...I can't imagine trying to figure what was wrong if the compiler was magically parsing it in a different way depending on types...
19:34:05 <beelsebob> jcreigh: exactly why I think there's room to investigate what error messages would look like
19:34:06 <sorear> anyway please set _darcs/prefs/email to something that will accept patch-sized messages :)
19:34:50 <beelsebob> sorear: I don't see your email atm, and I have no control over it, you'll have to poke ndm
19:35:23 <sorear> beelsebob: how does the system decide whether to give my message to you or ndm?
19:35:36 <beelsebob> sorear: I suspect it's random
19:35:40 <sorear> @seen ndm
19:35:41 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 2d 5h 42m 34s ago, and .
19:35:48 <fuzan> > 1+2
19:35:50 <lambdabot>  3
19:36:28 <haskruby> > foldr (1/) [x^2 | x <- [1..100], even x]
19:36:29 <lambdabot>        add an instance declaration for (Fractional ([t] -> [t]))
19:36:56 <jcreigh> haskruby: foldr needs an initial value.
19:37:00 <beelsebob> > foldr1 (1/) [x^2 | x <- [1..100], even x]
19:37:01 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t
19:37:02 <lambdabot>     Probabl...
19:37:12 <sorear> beelsebob: /me re-sends patch directly to shackel
19:37:17 <haskruby> > foldr (1/) 1 [x^2 | x <- [1..100], even x]
19:37:18 <lambdabot>   add an instance declaration for (Integral (b -> b))
19:37:18 <lambdabot>     In a list comprehen...
19:37:33 <haskruby> > map (1/) [x^2 | x <- [1..100], even x]
19:37:34 <lambdabot>  Add a type signature
19:38:02 <haskruby> > [Int] -> [Int]
19:38:02 <lambdabot>  Parse error
19:38:14 <haskruby> ok
19:38:27 <hyrax42> > map (1/) [x^2 | x <- [1..100], even x] :: [Float]
19:38:28 <haskruby> how do I create a function and execute it with lambdabot?
19:38:28 <lambdabot>   add an instance declaration for (Integral Float)
19:38:29 <lambdabot>     In a list comprehensio...
19:38:29 <LoganCapaldo> GAH
19:38:39 <LoganCapaldo> where are the line numbers for the exceptions????
19:38:42 <hyrax42> oh woops
19:38:48 <beelsebob> haskruby: use a let
19:38:52 <LoganCapaldo> heck, tell me what function was calling it at least
19:38:54 <beelsebob> > let f x = x in f 5
19:38:55 <lambdabot>  5
19:39:05 <sorear> LoganCapaldo: nowhere, unless you use the ultra-secret -xc option
19:39:20 <sorear> LoganCapaldo: (compiling) -prof -auto-all  (running) +RTS -xc -RTS
19:39:25 <LoganCapaldo> Is it really ultra secret?
19:39:29 <beelsebob> yes
19:39:38 <beelsebob> using profiling for some reason is *really* hard in ghc
19:39:41 <nmessenger> haskruby: you can use the 'let' form to define a local function, like beelsebob did above
19:39:48 <hyrax42> what does +RTS, -RTS do?
19:39:53 <sorear> beelsebob: eh?  always quite easy for me
19:39:57 <beelsebob> hyrax42: it sets the run time system options
19:40:12 <hyrax42> why the + and -?
19:40:12 <beelsebob> sorear: hard as in hard to find the relevant bit of docs explaining how
19:40:15 <beelsebob> took me a day
19:40:24 <Pastorn_> what is it with ruby? does haskell and ruby like each other?
19:40:27 <LoganCapaldo> err is there a way to use this stuff from ghci?
19:40:44 <haskruby> > let squared_reciprocal (n:ns) = map (1/) [x^2 | x <- n:ns, even x]
19:40:44 <lambdabot>  Parse error
19:40:45 <sorear> beelsebob: that must be why :)  I've read the entire manual.
19:40:48 <LoganCapaldo> I don't think so
19:40:48 <beelsebob> hyrax42: it tells the runtime "stop looking for program arguments at the +RTS and start looking for run time system ones" then "stop looking for rts ones at -RTS"
19:41:06 <nmessenger> Pastorn_: It seems a lot of rubyers have tried Haskell.  I think Matz has mentioned it once or twice.
19:41:20 <hyrax42> beelsebob: oh ok.  So the -RTS could be omitted if there are no further args?
19:41:24 <allbery_b> > map (1/) [x^2 | x <- n:ns, even x]
19:41:25 <lambdabot>   Not in scope: `ns'
19:41:27 <beelsebob> hyrax42: yep
19:41:37 <hyrax42> and -xc?
19:41:40 <nmessenger> haskruby: you have to add an 'in' part and use the function in an expression
19:41:46 <beelsebob> hyrax42: enable stack tracing
19:41:51 <beelsebob> iirc
19:41:53 * allbery_b sighs --- still not tracking too well
19:41:56 <nmessenger> haskruby: lambdabot's @let command is currently borked
19:42:04 <hyrax42> hrm okie
19:42:12 <haskruby> Would this work? let squared_reciprocal (n:ns) = map (1/) [x^2 | x in n:ns, even x]
19:42:16 * allbery_b awishes the storm system would go through and get it over with, or his sinuses and ears would behave
19:42:16 <Pastorn_> is D a nice language? it seems to have a lot of the abilities that haskell has, well, if you wanna go imperative...
19:42:23 <haskruby> and then squared_reciprocal [1..100]
19:42:46 <nmessenger> let f = ... in ... f ...
19:42:53 <allbery_b> > let squared_reciprocal (n:ns) = map (1/) [x^2 | x <- n:ns, even x] in squared_reciprocal [1..100]
19:42:54 <lambdabot>  Add a type signature
19:43:00 <hyrax42> haskruby: note that squared_reciprocal will have to use fromIntegral in there I think
19:43:03 <allbery_b> > let squared_reciprocal (n:ns) = map (1/) [x^2 | x <- n:ns, even x] in squared_reciprocal [(1::Int)..100]
19:43:04 <lambdabot>   add an instance declaration for (Fractional Int)
19:43:05 <lambdabot>     In the expression:
19:43:05 <lambdabot>    ...
19:43:07 <hyrax42> :t [1..100]
19:43:10 <lambdabot> forall t. (Num t, Enum t) => [t]
19:43:10 <allbery_b> > let squared_reciprocal (n:ns) = map (1/) [x^2 | x <- n:ns, even x] in squared_reciprocal [(1::Double)..100]
19:43:11 <lambdabot>   add an instance declaration for (Integral Double)
19:43:12 <lambdabot>     In the expression:
19:43:12 <lambdabot>   ...
19:43:17 <allbery_b> hm, right
19:43:21 <beelsebob> Pastorn_: tbh, if you want some of the abilities of Haskell, and an imperative language then you probably want Python
19:43:24 <hyrax42> you can't enumerate doubles
19:43:28 <allbery_b> > let squared_reciprocal (n:ns) = map (1/) [x^^2 | x <- n:ns, even x] in squared_reciprocal [(1::Double)..100]
19:43:29 <lambdabot>   add an instance declaration for (Integral Double)
19:43:29 <lambdabot>     In the expression:
19:43:29 <lambdabot>   ...
19:43:31 <allbery_b> durr
19:43:51 <nmessenger> @type even
19:43:54 <lambdabot> forall a. (Integral a) => a -> Bool
19:43:57 <nmessenger> ^^ the culprit
19:44:00 <allbery_b> > let squared_reciprocal (n:ns) = map ((1/) . fromIntegral) [x^2 | x <- n:ns, even x] in squared_reciprocal [1..100]
19:44:02 <lambdabot>  [0.25,6.25e-2,2.7777777777777776e-2,1.5625e-2,1.0e-2,6.944444444444444e-3,5....
19:44:10 <allbery_b> there we go
19:44:40 <jcreigh> Pastorn_: well, the two basic schools of thought in language design seem to be "how nice can we make a fast language?" and "how fast can we make a nice language?" And I think premature optimization is a bad idea.
19:44:42 <hyrax42> :t (^^)
19:44:44 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
19:44:50 <haskruby> thanks allbery_b
19:44:54 <allbery_b> nmessenger: even without that I think (^) does it
19:45:08 <hyrax42> :t (^)
19:45:10 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:45:16 <vindalf> Hello.
19:45:17 <allbery_b> hm, ok
19:45:24 <nmessenger> greets, vindalf
19:45:25 <allbery_b> a is Num, not Integral
19:45:27 <hyrax42> I did not know about ^^
19:45:29 <haskruby> :t map
19:45:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:45:36 <nmessenger> hyrax42: there's also (**)
19:45:37 <allbery_b> there's also (**)
19:45:39 <allbery_b> heh
19:45:42 <nmessenger> hah
19:45:44 <allbery_b> :t (**)
19:45:47 <lambdabot> forall a. (Floating a) => a -> a -> a
19:45:48 <vindalf> I'm looking to start with Haskell.
19:46:10 <beelsebob> vindalf: right place to be then :P
19:46:12 <haskruby> vindalf: me too
19:46:13 <chessguy> ?where yaht
19:46:13 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:46:20 <vindalf> I was reading a tutorial when something puzzled me.
19:46:24 <chessguy> vindalf, haskruby ^^
19:46:26 <nmessenger> vindalf: how much do you know?  What have you read/tried?
19:46:28 <LoganCapaldo> sorear, <Main.CAF>a.out: Prelude.read: no parse ????
19:46:41 <beelsebob> yay for ghc's stack traces being shit
19:46:46 <hyrax42> > map ($3) [(2^^), (2**), (2^)] :: [Double]
19:46:47 <vindalf> nmessenger: I've read some tutorials and did some exercises in ghci.
19:46:47 <lambdabot>   add an instance declaration for (Integral Double)
19:46:47 <lambdabot>     In the expression: (2 ^)
19:46:48 <LoganCapaldo> I'm gonna cry
19:46:51 <beelsebob> bump into a data structure and all you get is Main.CAF
19:46:53 <sorear> LoganCapaldo: hit it harder. -caf-all (compiling)
19:47:03 <beelsebob> vindalf: what's troubling you?
19:47:11 <hyrax42> > map ($3) [(2^^), (2**)] :: [Double]
19:47:12 <lambdabot>   add an instance declaration for (Integral Double)
19:47:13 <lambdabot>     In the expression: (2...
19:47:18 <hyrax42> :t (**)
19:47:20 <lambdabot> forall a. (Floating a) => a -> a -> a
19:47:29 <allbery_b> (^^) wants an Integral second
19:47:33 <hyrax42> :t (^^)
19:47:35 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
19:47:40 <hyrax42> ah
19:47:42 <nmessenger> > (2^3, 2^^3, 2**3)
19:47:42 <hyrax42> oi see
19:47:43 <lambdabot>  (8,8.0,8.0)
19:47:47 <LoganCapaldo> do I change how I run it?
19:47:52 <LoganCapaldo> I got the same result?
19:48:08 <allbery_b> > map ($3) [((2^) . fromIntegral), ((2^^) . fromIntegral), (2**)]
19:48:09 <lambdabot>  Add a type signature
19:48:14 <allbery_b> > map ($3) [((2^) . fromIntegral), ((2^^) . fromIntegral), (2**)] :: Double
19:48:15 <lambdabot>  Couldn't match expected type `Double' against inferred type `[a]'
19:48:20 <hyrax42> nmessenger: a better way to do it...
19:48:20 <vindalf> beelsebob: I've read that functions like length are quantified over all (uniform) types of x. If I understand the documentation correctly, then is it possible to do length on a list that has different types in it?
19:48:22 <allbery_b> > map ($3) [((2^) . fromIntegral), ((2^^) . fromIntegral), (2**)] :: [Double]
19:48:23 <lambdabot>   add an instance declaration for (Integral Double)
19:48:37 <allbery_b> > map ($3) [((2^) . fromIntegral), ((2^^) . fromIntegral), (2**)] [1..10]
19:48:38 <lambdabot>  Couldn't match expected type `[t1] -> t'
19:48:39 <vindalf> In fact I'll check. :)
19:48:49 <beelsebob> vindalf: no, because a list is explicitly defined to have the same types in it
19:48:53 <hyrax42> vindalf: only inasmuch as such a list can exist
19:48:57 <nmessenger> vindalf: not without extensions.  Lists are homogenous
19:49:00 <hyrax42> i.e. no
19:49:00 <beelsebob> you cannot in fact have a list with multiple types in
19:49:05 <LoganCapaldo> erm, /tmp/ghc14577.s:20872:FATAL:Symbol _Mainmain_CAF_cc_ccs already defined. ????
19:49:20 <allbery_b> > (map ($3) [((2^) . fromIntegral), ((2^^) . fromIntegral), (2**)]) :: [Double]
19:49:21 <lambdabot>   add an instance declaration for (Integral Double)
19:49:22 <vindalf> nmessenger: What do you do if you want a heterogenous list? :)
19:49:39 <allbery_b> > (map ($3) [((2^^) . fromIntegral), (2**)]) :: [Double]
19:49:40 <lambdabot>   add an instance declaration for (Integral Double)
19:49:44 <allbery_b> feh
19:49:46 <hyrax42> vindalf: accept that you're wrong, and sit in a corner until you realise why
19:49:53 <hyrax42> ;)
19:49:53 <vindalf> hyrax42: Heh.
19:49:53 <nmessenger> uh, you might use something like HList, but I've never used it.
19:49:56 <beelsebob> vindalf: a list in Haskell is defined as: data [a] = (a:[a]) | [] -- the result of this is that all elements in the list must be of type "a" - whatever you chose a to be
19:49:58 <bd_> [Dynamic] >.>;
19:50:05 <jcreigh> vindalf: there's magic that let's you do it. But I haven't felt the need so far.
19:50:06 <vindalf> beelsebob: Ok.
19:50:10 <jcreigh> *lets
19:50:16 <haskruby> Would you say that, willing to write my own programming language, Haskell would be a great choice for writing the compiler?
19:50:25 <allbery_b> hrm.
19:50:29 <vindalf> haskruby: Could be.
19:50:36 <jcreigh> haskruby: compared to...?
19:50:38 <beelsebob> haskruby: quite often
19:50:40 <LoganCapaldo> can I have breakpoints?
19:50:43 <nmessenger> haskruby: many people do.  It seems a strength of Haskell
19:50:52 <haskruby> jcreigh: compared to C
19:50:57 <allbery_b> > let xs :: [Show a => a]; xs = [1, 2.4, "foo"] in xs -- probably no this easy
19:50:57 <lambdabot>  Parse error
19:50:58 <beelsebob> LoganCapaldo: in a Lazy language breakpoints make little sense
19:51:00 <allbery_b> heh
19:51:05 <dino-> There was something recently posted by that alpheccar character about existential types.
19:51:08 <vindalf> Perl 6 is implemented in Haskell.
19:51:09 <haskruby> nmessenger: I heard of Pugs and of Scheme in 24 hours
19:51:18 <allbery_b> er. duh again
19:51:18 <chessguy> ?poll-list
19:51:18 <lambdabot> ["OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","editor","jabberName"]
19:51:21 <vindalf> haskruby: Yeah.
19:51:27 <nmessenger> haskruby: also GHC :)
19:51:27 <dino-> Mising several types in the same list. But it seemed kind of voodooish to me.
19:51:32 <allbery_b> > let xs :: Show a => [a]; xs = [1, 2.4, "foo"] in xs -- probably no this easy
19:51:33 <lambdabot>   "foo"
19:51:34 <lambdabot>     In the expression: [1, 2.4, "foo"]
19:51:34 <lambdabot>     In the definition of `xs':...
19:51:34 <dino-> http://www.alpheccar.org/en/posts/show/67
19:51:36 <lambdabot> Title: Haskell Study Plan
19:51:37 <chessguy> ?poll-result Written_a_compiler_or_interpreter
19:51:37 <lambdabot> No such poll: "Written_a_compiler_or_interpreter"
19:51:41 <haskruby> nmessenger: Haskell compiler written in Haskell?
19:51:42 <dino-> Search for "existential types" in that page.
19:51:45 <LoganCapaldo> I guess I just can't screw up any more then :)
19:51:45 <chessguy> ?poll-result Written_a_compiler_or_interpreter?
19:51:46 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=4, Yes=20
19:51:47 <nmessenger> yep
19:51:51 <haskruby> nmessenger: my mind explodeds!
19:52:00 <chessguy> haskruby, ^^
19:52:01 * dfranke suspects a bit of response bias there.
19:52:10 <nmessenger> haskruby: what language do you think gcc is written in?
19:52:19 <dino-> My immediate feeling was: don't store shit like this
19:52:21 * LoganCapaldo agrees
19:52:22 * LoganCapaldo voted no :)
19:52:33 <vindalf> beelsebob: What you said makes sense---now that I think of it, lists I make in Python are rarely heterogenous as well.
19:52:34 <dfranke> but that said... yes.  Two of them.
19:52:41 <hyrax42> are there many languages where the compiler is not written in same?
19:52:47 <hyrax42> *in general use
19:52:47 <jcreigh> haskruby: yeah, Haskell is a good choice for that sort of thing.
19:52:48 <chessguy> dfranke, the bias is the point
19:52:54 <haskruby> nmessenger: C I know, but there are many C compilers... I didn't think Haskell had that many and I thought I saw lots of C when building from source.
19:53:04 <haskruby> jcreigh: great! :-)
19:53:11 <SamB> hyrax42: well, most compilers written in Haskell are not Haskell compilers...
19:53:17 <SamB> does that tell you anything?
19:53:19 <siti> parsing is awesome in haskell, parsec is amazing :)
19:53:24 <dfranke> but not in Haskell, though.
19:53:25 <vindalf> haskruby: You get the advantage (or disadvantage depending on how you see it) of strict typing which can generate very fast code.
19:53:28 <dfranke> Both were in Lisp.
19:53:39 <vindalf> Lisp is easy to parse. :)
19:53:48 <siti> yes but lisp is ugly
19:53:52 <siti> and slow
19:53:56 <hyrax42> SamB: I added the "general use" qualifer to cover that because I realised itt instantly
19:53:57 <dfranke> They weren't lisp interpreters.  They were interpreters written in Lisp.
19:54:07 <dfranke> One of them was Scheme, actually.
19:54:07 <beelsebob> vindalf: yeh -- so's xml, doesn't make it nice
19:54:10 <SamB> and you could probably write a Lisp implementation in forth
19:54:15 <SamB> without breaking a sweat
19:54:16 <dfranke> http://rpal.sf.net/oneday.html
19:54:18 <lambdabot> Title: How to Write an Interpreter in One Day
19:54:24 <vindalf> I like Lisp.
19:54:26 <Pastorn_> (no, (lisp (is(( very( beauty-(fu-(l))))))))
19:54:33 <beelsebob> and interpretter in one day?
19:54:34 <vindalf> I just don't care for the Lisp 'community'.
19:54:39 <beelsebob> I wrote 3 yesterday!
19:54:40 <SamB> beelsebob: Lisp is easier to parse than XML, I think
19:54:51 <beelsebob> SamB: it's a tight run thing
19:54:55 <vindalf> SamB: Yeah.
19:54:56 <SamB> if you don't count reader macros
19:55:02 <haskruby> someone mentioned Liskell... complex like Haskell, and ugly like Lisp. LOL
19:55:09 <vindalf> Hehe.
19:55:10 <SamB> heh
19:55:12 <beelsebob> hehe
19:55:26 <vindalf> I think Cambridge notation is cool and useful, honestly.
19:55:28 <LoganCapaldo> HUZZAH
19:55:29 <dfranke> Haskell isn't *that* complex.
19:55:31 <LoganCapaldo> I fixed it
19:55:33 <dfranke> More complex than Lisp, yes.
19:55:34 <nmessenger> it's a Lisp syntax over haskell
19:55:35 <Pastorn_> @ty length . filter (True==) . zipWith (==)
19:55:37 <lambdabot>     Couldn't match expected type `[Bool]'
19:55:37 <lambdabot>            against inferred type `[a] -> [Bool]'
19:55:38 <dfranke> But less than Ruby
19:55:44 <dfranke> and certainly less than C++.
19:55:53 <vindalf> dfranke: LOL @ C++.
19:55:57 <Pastorn_> can't i do zipWith (==)?
19:55:58 <SamB> dfranke: I take it you haven't tried CL
19:56:03 <vindalf> I have that in CISC 115 now. It's so boring.
19:56:03 <haskruby> dfranke: I hope so, I'm a well experienced Ruby hacker.
19:56:03 <dfranke> SamB: I have.
19:56:04 <fnord123> lolz as well
19:56:19 <Pastorn_> ?src zipWith
19:56:19 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:56:19 <lambdabot> zipWith _ _      _      = []
19:56:30 <SamB> vindalf: why don't they teach you about CISC in that course?
19:56:32 <Pastorn_> @ty (==)
19:56:34 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:56:36 <beelsebob> @type \x y -> length $ filter (True ==) $ zipWith (==) x y
19:56:37 <SamB> instead of about C++?
19:56:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
19:57:01 <jcreigh> CISC? I assume we're not talking about the type of instruction set...
19:57:10 <beelsebob> Pastorn_: using function composition only works for one argument
19:57:16 <vindalf> SamB: Actually, the professor is pretty good---we do learn about CISC, except that we use C++ as our platform. :)
19:57:17 <haskruby> Quick Survey for all: How long did  he take you to be productive in Haskell?
19:57:21 <Pastorn_> oh... right..
19:57:25 <beelsebob> @type \x -> length . filter (True ==) $ zipWith (==) x
19:57:27 <lambdabot>     Couldn't match expected type `[Bool]'
19:57:27 <lambdabot>            against inferred type `[a] -> [Bool]'
19:57:28 <beelsebob> fail
19:57:29 <beelsebob> . even
19:57:34 <hyrax42> ?quickcheck \l ->  filter (True ==) l == filter id l
19:57:34 <lambdabot> Unknown command, try @list
19:57:35 * SamB bets vindalf doesn't know what CISC actually stands for
19:57:37 <beelsebob> @type \x -> length . filter (True ==) . zipWith (==) x
19:57:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
19:57:51 <Pastorn_> beelsebob: no way to get around that?
19:57:53 <hyrax42> ?check \l ->  filter (True ==) l == filter id l
19:57:54 <lambdabot>  OK, passed 500 tests.
19:58:04 <beelsebob> Pastorn_: use a lambda
19:58:08 <vindalf> SamB: Complex Instruction Set Computer? :)
19:58:12 <SamB> yeah
19:58:14 <beelsebob> and yes, as hyrax says, you can use id in the filter
19:58:18 <Pastorn_> how would that look?
19:58:28 <jcreigh> am I the only one who feels like multi-line error messages from lambdabot are kind of annoying?
19:58:38 <beelsebob> @type \x y -> length $ filter id $ zipWith (==) x y
19:58:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
19:58:43 <vindalf> Heh.
19:58:45 <beelsebob> Pastorn_: like that
19:58:48 <SamB> jcreigh: you mean the way they tend to get cut off right when they were about to get usefull?
19:59:16 <jcreigh> SamB: well, no, I mean the way the make the channel scroll like crazy when a handful of people are hitting type errors concurrently.
19:59:33 <hyrax42> perhaps a better default if the error goes past oneline is to send it to the person who typed the command
19:59:34 <Saizan> ?pl \x y -> length $ filter id $ zipWith (==) x y
19:59:35 <lambdabot> ((length . filter id) .) . zipWith (==)
19:59:44 <SamB> hmm
19:59:45 <vindalf> hyrax42: By /msg ?
19:59:56 <hyrax42> vindalf: yeah
20:00:00 <beelsebob> Saizan: well that was pointless
20:00:01 <SamB> that would be annoying a lot of the time, though
20:00:01 <beelsebob> :P
20:00:14 <dons> jcreigh: indeed they are. submit a patch.
20:00:16 <vindalf> hyrax42: Or pastebin really long error messages. :)
20:00:21 <allbery_b> well, I think LB tries to strip the errors to a minimum, but it's slighhtlybroken
20:00:26 <hyrax42> SamB: yeah, not sure what is best
20:00:26 <SamB> oooh
20:00:29 <SamB> pastebin!
20:00:39 * vindalf <3 pastebin
20:00:41 <nmessenger> > sequence [print 1]
20:00:48 <vindalf> Or rafb, etc.
20:00:49 <hyrax42> that would clutter up hpaste pdq
20:00:50 <nmessenger> ^^ no error
20:00:53 <hyrax42> it'd need a special lb error section
20:01:08 <SamB> wouldn't it look so nice?
20:01:09 <dons> yeah. as i've said earlier, a few small text/regex based things broke when updating to ghc 6.6
20:01:21 <dons> but nothing at high enough priority for me to fix.
20:01:29 <dons> people should feel free to dive in.
20:01:51 * hyrax42 still needs to update to ghc 6.6
20:02:30 <vindalf> Oh yes, and shout-out to 'ray', who suggested Haskell to me in the first place. ^^
20:02:51 <Pastorn_> ray = t3h r0xx
20:03:14 <hpaste>  lambdabot pasted "a type error for beelsebob" at http://hpaste.org/655
20:03:20 <vindalf> Pastorn_: Yeah, he does rox.
20:03:32 <beelsebob> bastards!
20:03:42 <dons> vindalf: which ray is that?
20:03:52 * nmessenger wish he'd thought of that :3
20:03:59 <vindalf> The 'ray' ray here I guess.
20:04:03 <vindalf> Cult of Ray.
20:04:09 <dons> ray: hey?
20:04:30 <SamB> beelsebob: its called prototyping ;-)
20:04:37 <vindalf> He's doing cult initiation right now.
20:04:42 <dons> cool
20:04:42 <beelsebob> :P
20:04:45 <nmessenger> @quote cult
20:04:46 <lambdabot> nmessenger says: welcome to the cult. Have some koolaid
20:05:39 <SamB> @quote cult
20:05:39 <lambdabot> dons says: not sure that the irc culture outside happy lambda land is always so warm and tropical
20:05:45 <SamB> @quote cult
20:05:45 <lambdabot> shapr says: Academics are continually chewing pieces off of impossible and making them merely difficult.
20:05:57 <SamB> @quote cult
20:05:57 <nmessenger> diffi"cult" heh
20:05:57 <lambdabot> qwe1234 says: never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult.
20:06:07 <nmessenger> hahaha
20:06:14 <SamB> hmm.
20:06:16 <nmessenger> qwe's always good for a laugh
20:06:17 <SamB> @quote \bcult
20:06:18 <lambdabot> No quotes match. It can only be attributed to human error.
20:06:26 <SamB> @quote  cult
20:06:26 <lambdabot> nmessenger says: welcome to the cult. Have some koolaid
20:06:34 <SamB> @quote .cult
20:06:34 <beelsebob> @quote beelsebob
20:06:34 <lambdabot> dons says: not sure that the irc culture outside happy lambda land is always so warm and tropical
20:06:35 <lambdabot> beelsebob says: > filter isJuggler #haskell
20:06:46 <nmessenger> @quote \ cult
20:06:47 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
20:06:57 <SamB> ?
20:07:01 <SamB> @quote \\bcult
20:07:01 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
20:07:04 <beelsebob> @quote SamB
20:07:05 <lambdabot> SamB says: any list of application domains is either incomplete or depressing
20:07:05 <vindalf> Ok, so in Haskell, what are the idioms for building large, modular data structures? (Because I'm most familiar with OO.)
20:07:09 <SamB> @quote \\\bcult
20:07:10 <lambdabot> No quotes match. stty: unknown mode: doofus
20:07:23 <dons> vindalf: modules, monads, abstract data types
20:07:30 <SamB> @quote \\\\bcult
20:07:30 <lambdabot> No quotes match. That's something I cannot allow to happen.
20:07:37 <dons> existential types are used as well (which are basically objects in the OO sense)
20:07:45 <vindalf> dons: Cool!
20:07:47 <nmessenger> typeclasses=awesome
20:07:49 <SamB> (sometimes, I think you actually need to type that many slashes in Emacs!)
20:07:54 <haskruby> @quote haskruby
20:07:54 <lambdabot> No quotes match. Are you on drugs?
20:07:58 <haskruby> ahahah
20:08:01 <SamB> @quote fire
20:08:02 <lambdabot> No quotes match. Are you on drugs?
20:08:05 <SamB> @quote drugs
20:08:06 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
20:08:07 <nmessenger> @quote lambdabot
20:08:07 <lambdabot> lambdabot says:  lambdabot hasn't said anything memorable
20:08:14 <vindalf> I knew Haskell implements parametric polymorphism, so that's one important step.
20:08:21 <haskruby> who does collect the quotes?
20:08:22 <SamB> @quote lambdabot
20:08:22 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
20:08:26 <SamB> haskruby: we do
20:08:28 <dons> yep. and bounded parametric polymorphism via typeclasses
20:08:32 <nmessenger> LB does
20:08:32 <Pastorn_> > tail (1:[])
20:08:34 <lambdabot>  []
20:08:35 <SamB> @remember haskruby who does collect the quotes?
20:08:35 <lambdabot> Done.
20:08:38 <dons> SamB, maybe take the quotes to -overflow ...
20:08:39 <Pastorn_> > tail []
20:08:40 <lambdabot>  Exception: Prelude.tail: empty list
20:08:46 <vindalf> dons: What is bounded PP?
20:08:48 <SamB> @quote haskruby
20:08:48 <lambdabot> haskruby says: who does collect the quotes?
20:08:51 <haskruby> SamB: bastard :-)
20:08:54 <dons> typeclasses.
20:08:55 <haskruby> ahah
20:09:05 <dons> i.e. polymorphism restricted to a set of types
20:09:14 <dons> :t (+)
20:09:16 <dons> for example
20:09:17 <lambdabot> forall a. (Num a) => a -> a -> a
20:09:23 <nmessenger> @instances Num
20:09:25 <lambdabot> Double, Float, Int, Integer
20:09:36 <dons> so you often define interfaces that are polymorphic over a set of types
20:09:38 <beelsebob> @remember lambdabot forall a. (Num a) => a -> a -> a
20:09:38 <lambdabot> Done.
20:09:44 <dons> users then write an instance that satisifies that type class interface
20:09:45 <LoganCapaldo> what's like ^ but can do negative exponents?
20:09:49 <dons> beelsebob: thanks.
20:09:50 <SamB> ^^
20:09:50 <TSC> **
20:09:55 <vindalf> dons: That sounds almost like a mix-in.
20:10:01 <LoganCapaldo> thanks
20:10:09 <beelsebob> dons: hmm? I thought it was particularly appropriate for the poor bot
20:10:36 <nmessenger> vindalf: a class specifies a list of functions.  It's akin to a java interface
20:10:39 <nmessenger> @src Num
20:10:40 <lambdabot> class  (Eq a, Show a) => Num a  where
20:10:40 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:10:40 <lambdabot>     negate, abs, signum     :: a -> a
20:10:40 <lambdabot>     fromInteger             :: Integer -> a
20:10:40 <dons> beelsebob: so any thoughts on that numerics error i reported on the yhc mailing list?
20:10:45 <SamB> @vixen
20:10:46 <lambdabot> <undefined>
20:10:48 <vindalf> nmessenger: OK, OK.
20:10:56 <haskruby> @vixenmode
20:10:56 <lambdabot> Unknown command, try @list
20:10:58 <dons> SamB, you know its broken. fix it, or quit ;)
20:11:00 <haskruby> @list
20:11:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:11:10 <beelsebob> dons: uhhh... too much spam, sorry
20:11:22 <beelsebob> @vixen do you fancy haskruby
20:11:23 <lambdabot> <undefined>
20:11:26 <beelsebob> o.O
20:11:36 <SamB> dons: how about I threaten to <undefined> in the quotes?
20:11:39 <dons> beelsebob: you haven't seen the mail?
20:11:45 <beelsebob> @vixen what do you mean <undefined>
20:11:46 <lambdabot> <undefined>
20:11:46 <allbery_b> vixen is still b0rked
20:11:48 <dons> SamB, how about you fix the code?
20:11:57 <beelsebob> dons: nope
20:12:08 <SamB> ISTR not having a compatible compiler or something like that
20:12:11 <dons> beelsebob: is there a Trac for yhc i should use instead?
20:12:23 <SamB> or maybe it was just that the fully-dynamic build was not working?
20:12:28 <SamB> I don't remember really
20:12:35 <beelsebob> dons: poke ndm
20:12:44 <haskruby> lamdabot doesn't like me. That's it, I'm leaving the Haskell community ;-)
20:12:49 <dons> beelsebob: here's the error, http://www.haskell.org/pipermail/yhc/2007-February/000704.html
20:12:51 <lambdabot> Title: [Yhc] yhi error in nobench: wrong output for digits-of-e2
20:13:00 <dons> beelsebob: simple test program from nofib, wrong output for Double math
20:13:03 <SamB> dons: google code for yhc, I believe
20:13:05 <dons> nhc passes though
20:13:12 <SamB> @google yhc
20:13:14 <lambdabot> http://www.yhc.edu/
20:13:15 <lambdabot> Title: Young Harris College :: Here Youth Are Inspired
20:13:17 <SamB> hmm.
20:13:20 <beelsebob> dons: must be some bizare bug in the runtime at a guess
20:13:20 <SamB> @google yhc haskell
20:13:23 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
20:13:24 <lambdabot> Title: yhc - York Haskell Compiler
20:13:28 <SamB> @google yhc haskell site:google.com
20:13:31 <lambdabot> http://code.google.com/p/yhc/
20:13:31 <lambdabot> Title: yhc - Google Code
20:13:48 <haskruby> @remember haskruby A Gentle introduction to Haskell is as gentle as Mike Tyson
20:13:48 <lambdabot> Done.
20:13:56 <haskruby> @quote haskruby
20:13:57 <lambdabot> haskruby says: A Gentle introduction to Haskell is as gentle as Mike Tyson
20:14:15 <dons> beelsebob: do you have any yhc benchmark programs lying around?
20:14:16 <beelsebob> haskruby: why do you say that?
20:14:23 <dons> ones that would be nice to include in the nobench suite?
20:14:27 <vindalf> @google haskell yaml OR json
20:14:30 <lambdabot> http://www.stylusstudio.com/xmldev/200508/post80550.html
20:14:31 <lambdabot> Title: haskell json - Re: Python and JSON vs XML???
20:14:39 <SamB> beelsebob: well it sounds nicer than his other quote
20:14:39 <beelsebob> dons: not really - I mostly have a lot of broken programs for hat
20:14:50 <haskruby> beelsebob: it's an excellent guide but it's not "gentle" for most programmers. It's very mathematical.
20:15:07 <dons> beelsebob: and the yhi slowdown in relation to nhc has been reproduced at your end?
20:15:11 <vindalf> haskruby: It's easier to read if you have prior diverse experience.
20:15:19 <dons> (see the overal geometric mean here, http://www.cse.unsw.edu.au/~dons/nobench/results.html)
20:15:20 <lambdabot> Title: nobench: Haskell implementation shootout
20:15:37 <beelsebob> dons: I really don't do much with yhc at all these days
20:15:40 <haskruby> what would you say is the best guide to learn Haskell fast?
20:15:44 <beelsebob> concintrating too much on my own PhD
20:15:52 <beelsebob> haskruby: Colin Runciman
20:15:53 <SamB> why fast?
20:15:57 <nmessenger> haskruby: everyone recommends YAHT
20:15:59 <dons> beelsebob: hehe. ok. :-)
20:16:03 <nmessenger> @where yaht
20:16:04 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
20:16:07 * dons notes not to bug beelsebob about yhc
20:16:08 <vindalf> haskruby: See Learn How to Program in 10 Years by Peter Norvig. :)
20:16:18 <nmessenger> @google yaht wikibook
20:16:22 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
20:16:25 <haskruby> SamB: fast, because I'm amazed by Haskell and I want to start using it for serious stuff
20:16:27 <SamB> @google learn how to program in 10 years
20:16:29 <lambdabot> http://norvig.com/21-days.html
20:16:30 <lambdabot> Title: Teach Yourself Programming in Ten Years
20:16:37 * vindalf clicks on YAHT
20:16:37 <haskruby> vindalf: I'm aware of it :-)
20:16:40 <Pastorn_> near (x:xs) ss = sum $ count x ss : near xs ss <-- count :: a -> [a] -> Int
20:16:43 <SamB> why is there 21 days in the URL?
20:16:44 <dons> haskruby: yaht and the wikibook
20:16:47 <Pastorn_> what's wrong?
20:16:47 <dons> haskruby: you got ghc installed?
20:17:02 <haskruby> dons: yes, installed from source on Linux
20:17:10 <dons> haskruby: even better if you have a smallish program you need to get down
20:17:20 <dons> that could serve as a good motivating tool
20:17:48 <vindalf> dons: That's the best (and basically the only) motivating tool for me.
20:17:50 <haskruby> dons: right, but being it for work I don't want to screw it too much and leave a bad image of Haskell at work
20:17:57 <dons> yep.
20:17:59 <Pastorn_> it says near har the type [Colour] -> [Colour] -> [a] and not [Colour] -> [Colour] -> Int
20:18:02 <vindalf> haskruby: LOL.
20:18:06 <dons> build some things on your own. small scripts and so on.
20:18:08 <nmessenger> Pastorn_: near sums the result, so it ends up as a number, which can't be used on the right side of (:)
20:18:15 <dons> till you're confident to throw haskell at anything
20:18:17 <haskruby> dons: good idea
20:18:26 <haskruby> I've done some minimal stuff
20:18:29 <Pastorn_> huh?
20:18:30 <haskruby> but I can do much more
20:18:39 <nmessenger> Pastorn_: try mapping (\x -> count x ss) then summing that
20:18:41 <haskruby> are there good excercises somewhere?
20:18:43 <Pastorn_> nmessenger: but i use it before the list...
20:18:56 <dons> hmm. there's the h99 exercises on the wiki. and yaht has a set of problems
20:19:03 <vindalf> Yeah.
20:19:04 <Pastorn_> i don't exactly understand what the error is :(
20:19:08 <dons> that will take you pretty deep in to the language
20:19:10 <allbery_b> :t (:)
20:19:13 <lambdabot> forall a. a -> [a] -> [a]
20:19:25 <allbery_b> the right hand side of : must be a list, not an Int
20:19:39 <stmartin> Working through yaht chapter 4 (Datatypes), and am trying to write a datatype Quadruple which takes four elements, the first and last two must be the same. To my mind, I should be able to say    data Quadruple a a b b = Quadruple a a b b     but ghci complains about it (Conflicting definitions for `a'). What is happening, and how can I fix it?
20:19:46 <vindalf> dons: Is it a good way to learn practical idioms?
20:20:05 <nmessenger> stmartin: name clash?
20:20:21 <haskruby> dons: great advise. thanks
20:20:27 <dons> vindalf: probably not. there's blog articles, and i've written some things on practical aspects of haskell
20:20:36 <Pastorn_> but count gives an Int, so then )
20:20:39 <dons> but a good yaht-depth tutorial on the more  perlish/scripting end of haskell is needed
20:20:40 <Pastorn_> ahaaaaaaaaaaaa
20:20:42 <vindalf> dons: K thx. Blog link? ^^
20:20:49 <allbery_b> Quadruple a b = Q a a b b -- ?
20:20:50 <Pastorn_> i included sum in the recursion
20:20:52 <nmessenger> Pastorn_: aye, but the... did you figure it out?
20:21:02 <Pastorn_> well that's kinda stupid
20:21:15 <Pastorn_> 5:20 am coding does that to you...
20:21:24 <dons> vindalf: quite a few here, http://haskell.org/haskellwiki/Category:Tutorials
20:21:24 <stmartin> allbery_b: thanks, will look into it. I think I just recalled something in yaht that I think I need to re-read.
20:21:25 <lambdabot> Title: Category:Tutorials - HaskellWiki
20:21:39 <vindalf> dons: Dank u wel! ^^
20:21:49 <nmessenger> Pastorn_: no worries, you have to get a feel for the basic listy things.  It doesn't come immediately :)
20:22:00 <haskruby> is there a way of seeing the 99 Haskell problems without looking at the solutions right there?
20:22:04 <dons> for example, Roll your own IRC bot, and http://haskell.org/haskellwiki/Tutorials/Programming_Haskell
20:22:06 <lambdabot> Title: Tutorials/Programming Haskell - HaskellWiki
20:22:44 <Pastorn_> nmessenger: :p, i have... that's why it was stupid of me
20:24:26 <vindalf> Very, very good.
20:24:40 <vindalf> Haskell could use something like the Python Challenge.
20:24:46 <vindalf> @google pythonchallenge
20:24:48 <lambdabot> http://www.pythonchallenge.com/
20:24:48 <lambdabot> Title: The Python Challenge
20:24:55 <dons> ah nice.
20:25:01 <dons> that sounds like a great idea
20:25:12 <nmessenger> vindalf, haskruby: do you both have haskell implementations yet?  If not, I'd recommend:
20:25:20 <nmessenger> @wiki Haskell_in_5_steps
20:25:20 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
20:26:51 <haskruby> thanks nmessenger, I actually read that already and decided to install GHC 6.6
20:27:25 <dons> ok. i quite like this python challenge idea
20:27:35 <dons> you can even just solve it in haskell and walk through the puzzles
20:27:49 <Pastorn_> @ty map
20:27:50 <dons> (i've done a couple just now in haskell :-)
20:27:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:28:05 <vindalf> dons: Yeah. I did some with Perl back when I was fond of that ugly, ugly language.
20:28:36 <araujo> hello
20:28:55 <vindalf> Hi.
20:32:19 <nmessenger> @quote vending
20:32:20 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
20:32:20 <lambdabot> of insight hits and it all makes sense.
20:32:43 <vindalf> Sure.
20:32:57 <vindalf> Like a lot of other things worth learning.
20:33:18 <Pastorn_> > let count x ys = length $ filter (x==) ys in map (count 'a') "abcaba"
20:33:19 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
20:33:25 <vindalf> I can't help but admit that I'm still fond of a long and shallow learning curve. :)
20:33:56 <nmessenger> Pastorn_: no map, count expects a list
20:33:57 <allbery_b> Pastorn_: you don't need to map count there
20:34:34 <Pastorn_> nmessenger: why can't i use map? i can map take....
20:34:41 * beelsebob notes that ghc really doesn't like receiving lots of data
20:34:51 <allbery_b> because count wants a list
20:35:05 <allbery_b> when you map it, you're letting map handle the list
20:35:06 * Pastorn_ really thinks this should work :/
20:35:12 <allbery_b> no, no it really shouldn't
20:35:15 <beelsebob> Pastorn_: you give map a list
20:35:21 * Pastorn_ cries
20:35:22 <beelsebob> it devides that list into elements
20:35:30 <beelsebob> and passes each element to the function
20:35:40 <allbery_b> > let count x ys = length $ filter (x==) ys in count 'a' "abcaba"
20:35:41 <lambdabot>  3
20:35:46 <beelsebob> so count will be called as count 'a' 'a', count 'a' 'b'
20:35:47 <beelsebob> etc
20:35:51 <beelsebob> but count wants a list
20:35:54 <vindalf> Well, good morning folks, I'll be back if I need any help. Thank you all so much!
20:36:02 <nmessenger> count :: a -> [a] -> Int, it expects a list as a second argument, if you map count over the list, it tries to apply to each Char, not the whole list
20:36:36 <Pastorn_> oh... that might be it...
20:36:49 <allbery_b> > let count x ys = length $ filter (x==) ys in count 'a' "abcaba"
20:36:51 <lambdabot>  3
20:37:03 <Pastorn_> but if i have two lists and wanna do count for each elemint in xs on ys
20:37:08 <allbery_b> now, were you'd want t use map:
20:37:10 <Pastorn_> xs being first...
20:37:29 <allbery_b> > let count x ys = length $ filter (x==) ys in map (count 'a') ["abcaba","fhlarbiazgdyla"]
20:37:31 <lambdabot>  [3,3]
20:37:43 <beelsebob> > let count x ys = length $ filter (x==) ys in map ((flip count) "abcaba") "abc"
20:37:44 <lambdabot>  [3,2,1]
20:37:48 <nmessenger> > length (intersect "abc" "abd")
20:37:50 <lambdabot>  2
20:37:53 <nmessenger> :D
20:38:00 <nornagon> ... is that LCS?
20:38:07 <nornagon> @src intersect
20:38:07 <lambdabot> intersect = intersectBy (==)
20:38:12 <nmessenger> > length (intersect "cab" "abd")
20:38:13 <lambdabot>  2
20:38:33 <nornagon> > intersect "abcd" "axbcd"
20:38:35 <lambdabot>  "abcd"
20:38:41 <nornagon> aw
20:38:44 <nmessenger> @src intersectBy
20:38:44 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
20:38:48 <Pastorn_> > intersect "abababa" "axa"
20:38:49 <lambdabot>  "aaaa"
20:38:58 <nmessenger> :/
20:39:19 <Pastorn_> > intersect "axa" "abababa"
20:39:20 <lambdabot>  "aa"
20:39:29 <allbery_b> @src intersectBy
20:39:29 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
20:39:30 <Pastorn_> > intersect "axa" "a"
20:39:32 <lambdabot>  "aa"
20:39:32 <allbery_b> oh
20:39:33 <nornagon> how boring
20:40:07 <haskruby> how do I print more than once?
20:40:19 <nmessenger> do print 1; print 2
20:40:27 <nmessenger> @pretty do print 1; print 2
20:40:27 <lambdabot> "Parse error" at column 20
20:40:30 <haskruby> nmessenger and for new lines?
20:40:47 <nmessenger> putStrLn
20:40:54 <nmessenger> @src print
20:40:55 <lambdabot> print x = putStrLn (show x)
20:41:06 <nmessenger> show is toString
20:41:06 <jcreigh> :t print
20:41:07 <Pastorn_> near gs ss =  sum [ count g ss | g <- gs ] <-- could this be done with map?
20:41:08 <lambdabot> forall a. (Show a) => a -> IO ()
20:41:39 <jcreigh> "print" takes anything that's "Show"able, but putStr and putStrLn only take strings
20:42:36 <nmessenger> @type (\gs ss -> sum (map (\g -> count g ss) gs)
20:42:39 <lambdabot> parse error (possibly incorrect indentation)
20:42:43 <nmessenger> @type (\gs ss -> sum (map (\g -> count g ss) gs))
20:42:46 <lambdabot> Not in scope: `count'
20:42:52 <nmessenger> bleh
20:43:05 <nmessenger> @type (\gs ss -> sum (map (\g -> (undefined::a->[a]->Int) g ss) gs))
20:43:08 <lambdabot> forall a. [a] -> [a] -> Int
20:43:48 <Pastorn_> count y xs = length $ filter (y==) xs
20:44:59 <nmessenger> > sum (map (\g -> length (filter (g==) "abababa")) "axa")
20:45:01 <lambdabot>  8
20:45:35 <nmessenger> >  sum [ count g "abababa" | g <- "axa" ]
20:45:37 <lambdabot>   Not in scope: `count'
20:45:40 <nmessenger> geh
20:45:53 <nmessenger> >  sum [ length (filter (g==) "abababa") | g <- "axa" ]
20:45:55 <lambdabot>  8
20:46:06 <Pastorn_> let count y xs = length $ filter (y==) xs in sum (map (\g -> count g "axa")) "abc"
20:46:12 <Pastorn_> > let count y xs = length $ filter (y==) xs in sum (map (\g -> count g "axa")) "abc"
20:46:13 <lambdabot>  Couldn't match expected type `[a]'
20:46:27 <stmartin> @paste
20:46:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:46:51 <nmessenger> Pastorn_: put the "abc" inside the parens
20:47:04 <nmessenger> it's the list being mapped over
20:47:10 <Pastorn_> > let count y xs = length $ filter (y==) xs in sum (map (\g -> count g "axa") "abc")
20:47:12 <lambdabot>  2
20:47:15 <Pastorn_> yay!
20:47:57 <nmessenger> > let count y xs = length $ filter (y==) xs in sum (map (\g -> count g "abababa") "axa")
20:47:59 <lambdabot>  8
20:48:47 <nmessenger> it counts the 'a's in "abababa", then the 'x's, then the 'a's again, then sums the counts
20:49:01 <Pastorn_> yeah...
20:49:25 <Pastorn_> thanks for all the help... i think i need to sleep a little in order to complete this...
20:49:38 <ddarius>  > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = ungroup2 . bitRev . zip . group2 $ xs where group2 [] = []; group2 (x:y:xs) = ((x:) &&& (y:)) $ group2 xs; ungroup2 [] = []; ungroup2 ((x,y):xs) = x:y:ungroup2 xs in bitRev [1..16]
20:49:45 <Pastorn_> good night
20:49:50 <nmessenger> 'night
20:50:08 <haskruby> how do I check the type of a function in ghci?
20:50:15 <nmessenger> :t
20:50:16 <jcreigh> haskruby: :t
20:50:27 <haskruby> jrcreigh: I tried
20:50:27 <nmessenger> haskruby: use :help for a list of commands
20:50:29 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = ungroup2 . bitRev . zip . group2 $ xs where group2 [] = []; group2 (x:y:xs) = ((x:) &&& (y:)) $ group2 xs; ungroup2 [] = ([],[]); ungroup2 ((x,y):xs) = x:y:ungroup2 xs in bitRev [1..16]
20:50:30 <lambdabot>  Couldn't match expected type `[t]'
20:50:48 <haskruby> <interactive>:1:0: parse error on input `!!'
20:50:49 <jcreigh> haskruby: also, ghci has tab-completion. (which was non-obvious to me at first)
20:50:58 <nmessenger> parens around operators
20:51:00 <ddarius> :t zip
20:51:02 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
20:51:03 <nmessenger> :t (!!)
20:51:06 <lambdabot> forall a. [a] -> Int -> a
20:51:14 <haskruby> nmessenger: gotcha
20:51:15 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = ungroup2 . bitRev . uncurry zip . group2 $ xs where group2 [] = []; group2 (x:y:xs) = ((x:) &&& (y:)) $ group2 xs; ungroup2 [] = ([],[]); ungroup2 ((x,y):xs) = x:y:ungroup2 xs in bitRev [1..16]
20:51:16 <lambdabot>  Couldn't match expected type `[t]'
20:51:37 <nmessenger> jcreigh: not in Windoze :(
20:52:12 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = ungroup2 . bitRev . uncurry zip . group2 $ xs where group2 [] = ([],[]); group2 (x:y:xs) = ((x:) &&& (y:)) $ group2 xs; ungroup2 [] = []; ungroup2 ((x,y):xs) = x:y:ungroup2 xs in bitRev [1..16] -- better work this time
20:52:13 <lambdabot>  Couldn't match expected type `[t]'
20:52:29 <hpaste>  stmartin pasted "Quadruple" at http://hpaste.org/656
20:52:37 <ddarius> @type (&&&)
20:52:39 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:53:08 <ddarius> @type (***)
20:53:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:53:13 <stmartin> Could someone help me my typing problem (Quadruple). Should be fairly easy...
20:53:25 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = ungroup2 . bitRev . uncurry zip . group2 $ xs where group2 [] = ([],[]); group2 (x:y:xs) = ((x:) *** (y:)) $ group2 xs; ungroup2 [] = []; ungroup2 ((x,y):xs) = x:y:ungroup2 xs in bitRev [1..16] -- better work this time
20:53:26 <nmessenger> stmartin: the Quadruple type takes two type arguments, firstTwo should be :: Quadruple a b -> (a, a)
20:53:26 <jcreigh> nmessenger: oh, too bad. I'll have to qualify my praise of that feature in the future.
20:53:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
20:53:58 <stmartin> nmessenger: It should take four I should think.
20:54:02 <allbery_b> stmartin:  the type is Quadruple a b
20:54:10 <allbery_b> the data constructor is Quadruple a b c d
20:54:15 <nmessenger> stmartin: the *value* takes four, but the *type* takes two types
20:54:23 <allbery_b> it's clearer if you call the data constructor something else, maybe
20:54:39 * ddarius is being stupid.
20:54:55 <haskruby> solution 3 of H99 may be wrong
20:55:47 <jcreigh> haskruby: how so?
20:55:54 <LoganCapaldo> So does anyone want look at my calculator?
20:55:55 <glguy_> link?
20:56:12 <haskruby> Couldn't match expected type `t t1' against inferred type `Char'
20:56:12 <haskruby>     In the expression: elementAt "haskell" 5
20:56:39 <haskruby> glguy_: http://haskell.org/haskellwiki/99_questions/1_to_10
20:56:40 <lambdabot> Title: 99 questions/1 to 10 - HaskellWiki
20:57:38 <hpaste>  LoganCapaldo pasted "Woo, calculator in Haskell" at http://hpaste.org/657
20:57:41 <glguy_> haskruby: why do you believe that it's wrong?
20:57:52 <jcreigh> haskruby: works fine for me.
20:58:06 <haskruby> jcreigh: when I ran it I got an error
20:58:10 <jcreigh> @paste
20:58:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:58:10 <haskruby> let me check it again
20:58:14 <glguy_> > let elementAt list i = list !! (i-1) in elementAt "haskell" 5
20:58:15 <lambdabot>  'e'
20:58:27 <nmessenger> haskruby: looks Prelude> let elementAt xs i = xs !! (i-1)
20:58:27 <nmessenger> Prelude> elementAt "haskell" 5
20:58:27 <nmessenger> 'e'
20:58:33 <jcreigh> haskruby: paste the code you're having trouble with.
20:58:44 <nmessenger> oops, I meant to delete "haskruby: looks"
20:58:52 <jcreigh> (at hpaste, of course, not in-channel)
20:58:53 <hpaste>  haskruby pasted "3rd problem on H99" at http://hpaste.org/658
20:59:25 <glguy_> haskruby: you are using do notation wrong
20:59:37 <nmessenger> haskruby: oh!  you need to print the results, each 'do' line must be an action
20:59:42 <glguy_> elementAt isn't of type type IO a
20:59:47 <nmessenger> print (elementAt "haskell" 5);
21:00:46 <nmessenger> LoganCapaldo: parsec = awesome :D  Were there any errors you were asking about?
21:01:01 <haskruby> nmessenger: opss... sorry for this lack of Occam's razor. I was wrong. so I need one do only and 2 prints for each line... sorry guys
21:01:04 <LoganCapaldo> ope
21:01:07 <LoganCapaldo> *nope
21:01:13 <LoganCapaldo> well there were but I figured it out
21:01:31 * nmessenger <3 Parsec
21:02:23 <nmessenger> haskruby: usually you'd leave out the main, load it in ghci, and type the sample expressions at the toplevel.
21:02:46 <haskruby> hpaste is awesome. Is it written in Haskell Server Pages?
21:02:53 <haskruby> nmessenger: thanks... good tip
21:02:56 <nmessenger> @where hpaste
21:02:57 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
21:02:58 <jcreigh> LoganCapaldo: nice. I've only done RPN stuff because you don't have to have a parser.
21:03:00 <nmessenger> HApps
21:03:33 <LoganCapaldo> jcreigh, the last time I did this (in C++) I transformed the infix to postfix :)
21:03:54 <LoganCapaldo> but this was more fun
21:04:08 <nmessenger> @where happs
21:04:08 <lambdabot> http://happs.org
21:04:39 <brad__> a question, somewhat open-ended, feel free to ignore: why is it that lists are monads? must they be? what happens if they are not?
21:05:03 <haskruby> nmessenger: thanks
21:05:09 <jcreigh> LoganCapaldo: which you can do trivially by walking the expression tree in the some order, right? What is it, left, then right, then node value?
21:05:34 <jcreigh> or am I just confused?
21:05:34 <dons> the list data type is a monad because it is possible to provide an implementation of the monad laws that holds, using list functions
21:05:36 <LoganCapaldo> well the transformation was to avoid creating an expression tree
21:05:40 <allbery_b> they don't "have" to be, but the list monad lets you do backtracking
21:05:50 <LoganCapaldo> you have an operator stack and an operand stack
21:06:09 <LoganCapaldo> and an old and new precendence for ever operator
21:06:57 <LoganCapaldo> you'd either push an operator to the operator stack, or if it was higher prcendence you'd eval it
21:06:58 <glguy_> nmessenger: if you have HAppS questions, #happs is always open
21:07:18 <brad__> it seems somewhat vauge as to when you are "in" the list monad or not, maybe i just don't know enought yet
21:07:25 <haskruby> LoganCapaldo: nice calculator
21:07:28 <allbery_b> most of the time you're not
21:07:29 <LoganCapaldo> if the operator stacks top had higher prcendence then what you wanted to push
21:07:36 <nmessenger> glguy_: I don't, haskruby just wanted to know what hpaste was written in
21:07:48 <LoganCapaldo> you'd pop and eval, and repeat until the stack was empty or its top had lower prec then what you were going to push
21:08:14 <ddarius> brad__: That's because it is.  There is no formal/actual distinction.  It's just the way you are viewing the code.
21:08:26 <LoganCapaldo> haskruby, thanks
21:08:45 <jcreigh> LoganCapaldo: oh, that's really cool. I hadn't realize there was a clever algorithm for that.
21:08:54 <brad__> i know that the <- operator acts like a list comprehension in the list monad, but why? is it just because this is neat functionality, or does this constitute a monad law issue?
21:09:17 <nmessenger> @undo (do x <- xs; return (f x)}
21:09:17 <lambdabot> Plugin `undo' failed with: IRCRaised Internal error: empty context in popContext
21:09:30 <nmessenger> @undo do {x <- xs; return (f x)}
21:09:30 <lambdabot> xs >>= \ x -> return (f x)
21:09:33 <ddarius> brad__: They just happen to be the same thing.  (Incidentally, <- is not an operator)
21:09:38 <nmessenger> @src [] (>>=)
21:09:38 <lambdabot> m >>= k     = foldr ((++) . k) [] m
21:09:40 <allbery_b> list comprehensions are intentionally a simplicification of the list monad.  once upon a time haskell had general monad comprehensions, but they were removed due to confusion
21:09:44 <brad__> whoops, you are right ddarius
21:09:56 <nmessenger> brad__: no magic, just desugaring and the definition of (>>=)
21:10:10 <allbery_b> *simplification
21:10:24 <LoganCapaldo> jcreigh, yeah the same trick can be used to build the expression tree
21:10:42 <LoganCapaldo> you just push subtrees back on to the operand stack instead of evaling
21:10:50 <brad__> so when you are using list comperhensions you are in fact in the list monad (whatever "in" means)??
21:10:58 <ddarius> I tend to lean toward using Tree's for non-determinism, but that's just me.
21:11:11 <brad__> am i making too much out of this issue? is it really that fundamental?
21:11:15 <SamB> I did that once
21:11:19 <allbery_b> "in" is complicated; "using"
21:11:19 <nmessenger> "in" monad x usually means the do block operates on that monad.
21:11:31 <ddarius> brad__: No, not really, though you can look at it that way.  It's just the effect of list comprehensions is exactly what the monad instance also does.
21:11:34 <SamB> (I think that was my only nondeterministic program that ever worked)
21:11:55 <glguy_> ddarius: the list monad's backtracking looks like a tree when you draw it out ...
21:11:56 <allbery_b> you could say that comprehensions and do blocks are "in" monads, in the sense that you can work with what's inside the monad directly
21:12:06 <JohnnyL> What's a polymorphic type contructor ,a nd how does it differ from a regular type contructor?
21:12:14 <allbery_b> (if you think of a monad a s acontainer)
21:12:20 <allbery_b> *as a container
21:12:32 <ddarius> Gah.  A Monad Is Not A Container.
21:12:32 <brad__> hmmm, well thanks for the info!! i think i need to do some more reading of the better monad tutorials
21:12:43 <brad__> thanks everyone for being so helpful!
21:13:14 <allbery_b> JohnnyL: data Foo a = Foo a a -- a can be any type, hence Foo is polymorphic
21:13:24 <LoganCapaldo> Yeah, I'm starting to realize the whole Monad as container thing while not the worst analogy messes up my thinking for monads that don't act so containery
21:13:30 <allbery_b> data Foo = Foo Int -- this is monomorphic
21:14:00 <allbery_b> well, as I think about it they're all container-like but sometimes they contain behaviors instead of values
21:14:21 <allbery_b> (which, if you think about it, makes sense as the value being a function...)
21:14:55 <ddarius> To be pedantic, all type constructors are polymorphic, though I guess you could call a type a nullary type constructor.
21:15:35 <ddarius> allbery_b: Do you think of a fence as a container?
21:16:01 <allbery_b> either a container or part of one, sure
21:16:14 <nmessenger> to call a type constructor "polymorphic" suggests to me that it accepts different kinds.  The kind level is not very sophisticated
21:16:43 * sorear is having an unhealthy amount of fun overlapping instructions
21:16:44 <ddarius> allbery_b: You naturally think of it as a container?  I can see it being one as in it contains a yard or whatever, but...
21:16:59 <allbery_b> it is one way I think of fences, sure
21:17:20 <allbery_b> however note also my comment about "containing" a behavior
21:17:36 <ddarius> glguy: That's because it's a choice of a traversal of a tree.
21:17:40 <allbery_b> the analogy gets a bit stretched, but you can also think of a fence as "containing" the concept of separation
21:18:01 <allbery_b> (that's a really poor analogy for what I was getting at, though)
21:18:04 <ddarius> allbery_b: I chose a fence because they are typically used to keep things in (or out).
21:18:08 <dons> sorear: i have a job for you. how good is your ocaml?
21:18:20 <sorear> dons: nonexistant :)
21:18:24 <ddarius> allbery_b: And that is what I assume you mean by "contains behavior".
21:18:39 <sorear> dons: I think I've tried to read exactly one program in ML
21:18:49 <ddarius> At any rate, that is not how "Monads As Containers" reads.
21:18:50 <sorear> dons: and it was an Unlambda interpreter
21:18:50 <allbery_b> well, no, I do naturally think of fences as containing something, a "domain"
21:18:57 <sorear> s/ML/*any* ML/
21:19:11 <allbery_b> usually reflecting ownership of the domain and restricted access thereto
21:19:12 <dons> sorear: good! well, tell me what you think, anyway. i'd like to have some of the ocaml test suite translated to haskell, for nobench. e.g. FFT, http://camlcvs.inria.fr/cgi-bin/cvsweb.cgi/~checkout~/ocaml/test/fft.ml?rev=1.8.20.1;content-type=text%2Fplain
21:19:17 <lambdabot> http://tinyurl.com/yoyh9k
21:19:18 <dons> there's some really good numerics stuff in there
21:19:33 <dons> i think each translation is about an hour or so. and you get to learn ocaml :-)
21:19:40 <sorear> hehe.
21:19:49 <dons> ideally i'd like the FFT and Alma progs translated
21:19:52 <sorear> once you know one language you know them all
21:19:53 <dons> they look the most useful
21:20:04 <dons> well, once you know haskell, you've got a fair bit of ocaml for free
21:20:21 <ddarius> dons: What is he supposed to do about those bits you don't get at all?
21:20:31 <dons> ignore them and use monads ;)
21:20:40 <nmessenger> module functors sound like unfamiliar territory, though
21:20:43 <dons> (the benchmark progs don't use modules, for instance)
21:21:29 <glguy_> is it considered acceptable to use a direct translation of someone else's entry?
21:21:35 <allbery_b> the "containing behavior" thing is exemplified by Cont
21:21:43 <sorear> nmessenger: I'll try and understand it, and then I'll recognize it as something I invented a suspiciously small number of days ago.  that's the way it usually works with me and language features.
21:21:43 <dons> glguy_: hmm/
21:22:03 <nmessenger> @kind Cont
21:22:03 <sorear> (**) == {--}
21:22:04 <allbery_b> which encapsulates the behavior of escaping from a computation
21:22:06 <lambdabot> * -> * -> *
21:22:10 <sorear> (first obs)
21:22:14 <nmessenger> @unmtl Cont a b
21:22:15 <lambdabot> (b -> a) -> a
21:22:25 <sorear> blech, lets everywhere
21:22:27 <dons> i started on translating almabench,hs http://www.cse.unsw.edu.au/~dons/tmp/almabench.hs
21:23:21 <sorear> dons: another benchmarky idea I had:
21:24:07 <sorear> dcoutts has a C parser, so with little work I could write a haskell-targeting C compiler.  How much slower is it than GCC on $program?
21:24:15 <ddarius> allbery_b: I agree that that is a reasonable way of looking at it, but that is not the way "Monads As Containers" presents it nor is it comprehensive enough on its own.
21:24:24 <sorear> test of ability to optimize IO code
21:24:36 <nmessenger> @go Monads as Containers
21:24:38 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
21:24:39 <lambdabot> Title: Monads as containers - HaskellWiki
21:24:41 <dons> yeah good idea sorear
21:24:45 <allbery_b> I don't think I claimed "Monads as Conainers" was much of anything
21:25:20 <allbery_b> (I'm not sure I ever even read it)
21:25:51 <sorear> hehe
21:26:04 <sorear> I suppose there's no point in translating boyer.ml :)
21:26:40 <ddarius> Already one in nofib right?
21:27:06 <sorear> lol at last paragraph in first comment in almabench.ml
21:28:55 <siti> that would be very cool writing a c compiler in haskell :)
21:29:55 <sorear> type bdd = One | Zero | Node of bdd * int * int * bdd
21:29:55 <sorear> ==> data BDD = One | Zero | Node !BDD !Int !Int !BDD  -- ?
21:30:36 <ddarius> For a direct translation, it is possible being lazy might be beneficial but I guess that does not matter for benchmarks.
21:30:46 <LoganCapaldo> Node (!BDD, !Int, !Int, !BDD)
21:30:48 <sjanssen> sorear: yeah
21:30:57 <ddarius> LoganCapaldo: Too direct.
21:31:02 <LoganCapaldo> heh
21:31:08 <sorear> ddarius: SML code is strict.  I was trying to *avoid* people picking nits about the fact I changed the _|_-semantics.
21:31:10 <ddarius> And not syntactically valid.
21:31:26 <ddarius> sorear: You don't need to copy the semantics exactly.
21:31:59 <sorear> besides, if I was lazy the benchmarks would suddenly become a million times faster
21:32:07 <dons> sorear: i'd lave the ! pattern off the recursive part of hte structure
21:32:12 <dons> so just strict in the elem
21:32:16 <dons> (more idiomatic in haskell)
21:32:23 <sorear> gha!
21:32:56 <sorear> next time when I ask about equality I'll use things I know to be unequal, then :)
21:33:26 * sorear is amazed at how thouroughly his attempt to pacify the #haskell nitpickers backfired
21:34:42 <ddarius> The purpose is to give the compilers meat to grind on, not to compare against O'Caml.
21:35:51 <sorear> hey, who's idea was it to make cvs login -d ... fail?  :)
21:36:08 * sorear is trying to relearn CVS.  Darcs rots the brain, like Haskell.
21:36:20 <LoganCapaldo> Theres not a parsec parser for haskell is there?
21:36:25 <allbery_b> no, CVS really does suck that much:)
21:36:33 <allbery_b> @where hsx
21:36:34 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
21:37:07 <SamB> sorear: man, even SVN spoils you for CVS
21:37:08 <nmessenger> heh, "Don't learn Haskell!  You'll forget how to do all the mundane uninteresting little things!"
21:37:41 <sorear> int main = return $ ...
21:38:19 <sorear> the scary part is I spent half my life programming almost exclusively in C, and I've lost much of that in six months.
21:38:28 <nmessenger> haha
21:38:45 <nmessenger> er, I mean, condolences
21:38:59 <allbery_b> hm, I guess HSX uses its own parser, not Parsec.  sad
21:39:02 <ddarius> I've spent most of my programming life using C++, but I'm only rusty.  I still use it on occasion though.
21:39:20 <sorear> wtf?  .ml is associated with lisp-mode
21:39:35 * sorear didn't know standard ml was a syntactic lisp
21:39:41 <SamB> try .sml
21:39:45 <allbery_b> maclisp, I think
21:39:50 <ddarius> What?  Aren't all functional languages Lisps?
21:40:10 <SamB> ddarius: have you not noticed the horror that is haskell-mode?
21:40:13 <mbishop> .ml is the typical extension for ocaml programs, .sml for SML
21:40:19 <mbishop> and .aml for Alice ML
21:40:19 <allbery_b> (that is, the substrate for Macsyma, nothing to do with Macs)
21:40:20 <ddarius> SamB: No, I have not.
21:40:26 <sorear> no caml-mode, sml-mode, ml-mode, ocaml-mode
21:40:44 <SamB> sorear: install them?
21:40:54 <LoganCapaldo> let cons = (:); nil = [] in (cons (1 (cons 2 (cons 3 nil)))
21:40:58 <SamB> apt-get install sml-mode
21:40:59 <LoganCapaldo> > let cons = (:); nil = [] in (cons (1 (cons 2 (cons 3 nil)))
21:41:00 <lambdabot>  Parse error
21:41:05 <sorear> what, you mean emacs ISN'T monolithic? :)
21:41:08 <SamB> or ocaml-mode
21:41:08 <LoganCapaldo> > let cons = (:); nil = [] in (cons 1 (cons 2 (cons 3 nil)))
21:41:09 <lambdabot>  [1,2,3]
21:41:16 <SamB> sorear: yes it is
21:41:21 <SamB> but it is not all-encompassing
21:41:41 <SamB> and it is only monolithic because it comes with so much elisp ;-P
21:42:11 <sorear> sml-mode is in section 'editors'
21:42:16 <SamB> there is also an nxml-mode package
21:42:18 <sorear> ocaml-mode is in section 'devel'
21:42:25 <SamB> sorear: yeah
21:42:31 <SamB> not terribly consistant
21:42:45 <SamB> but nxml-mode *probably* isn't the sort of thing you want
21:43:02 <SamB> ocaml-mode apparantly also works for caml-light
21:43:08 <SamB> sml-mode works okay for rml ;-)
21:43:09 <mbishop> I prefer tuareg-mode to ocaml-mode
21:43:17 <mbishop> or caml-mode, whatever the other one is
21:43:29 <sorear> rml?
21:43:32 <LoganCapaldo> tuareg? that doesn't even have ml in the name!!!
21:43:39 <LoganCapaldo> HOw do you emacs people find anything? :)
21:43:44 * sorear prefers Haskell
21:43:49 <mbishop> LoganCapaldo: but it's named after a people who are good with camels :P
21:43:50 <sorear> haskell-mode + shim
21:44:01 <SamB> >>> 'tuareg'.decode('rot13')
21:44:01 <SamB> u'ghnert'
21:44:36 <ddarius> @help rot13
21:44:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:44:47 <ddarius> @list rot13
21:44:48 <lambdabot> No module "rot13" loaded
21:44:57 * allbery_b notes that perl mostly rotted his brain for writing C, although he still debugs and modifies C code semi-regularly
21:44:58 <SamB> maybe this tag: devel::lang:ocaml
21:45:17 <SamB> I've been hacking on ZSNES lately
21:45:20 <allbery_b> haskell hasn't caused me to swap out anything I use regularly
21:45:31 <SamB> I still don't know my condition codes very well...
21:45:48 <LoganCapaldo> @hoogle (Enum a, Num b) => a -> b
21:45:50 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:45:50 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
21:45:50 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
21:45:54 <SamB> at least now I have my intel manuals handy ;-)
21:45:57 <dons> my C has improved since learning haskell
21:46:03 <nmessenger> @type fromEnum
21:46:05 <LoganCapaldo> @hoogle (Enum a) => a -> Integer
21:46:05 <lambdabot> forall a. (Enum a) => a -> Int
21:46:06 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
21:46:06 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
21:46:06 <dons> even though i write less of it :-)
21:46:30 <SamB> dons: well, that is somehow appropriate
21:46:39 <dons> makes sense, doesn't it.
21:46:41 <SamB> the more experienced C programmer is more adept at avoiding it
21:46:55 <SamB> ;-)
21:47:06 <nmessenger> (makes a good quote out of context)
21:47:07 <LoganCapaldo> > let rot13 x = map (\x -> toEnum (fromEnum x + 13)) x in rot13 "tuareg"
21:47:09 <lambdabot>  [129,130,110,127,114,116]
21:47:11 <ddarius> Also the better you are as a programmer the less code you write.
21:47:22 <nmessenger> ?remember SamB the more experienced C programmer is more adept at avoiding it
21:47:22 <lambdabot> Done.
21:47:28 <dons> the more you delegate ;)
21:47:28 <LoganCapaldo> > let rot13 x = map (\x -> chr (fromEnum x + 13)) x in rot13 "tuareg"
21:47:30 <lambdabot>  "\129\130n\DELrt"
21:47:31 <dons> ddarius: eh? :-)
21:47:39 <LoganCapaldo> riiiight :)
21:47:45 <SamB> dons: you know how to write it in less code?
21:47:52 <SamB> or maybe you spend more time thinking
21:47:57 <ddarius> Well, per feature point at least.
21:47:58 <nmessenger> LoganCapaldo: fromEnum for Char is also ord
21:48:01 <SamB> heh
21:48:26 <SamB> ddarius: is that like a bullet point?
21:48:48 <LoganCapaldo> > let rot13 x = map (\x -> chr ((ord x - ord 'a') + 13 + ord 'a')) x in rot13 "tuareg"
21:48:49 <lambdabot>  "\129\130n\DELrt"
21:48:55 <ddarius> SamB: Actually, yes.  It is a bullet in some Powerpoint presentation somewhere.
21:49:06 <sorear> ayhi is very rapidly turning into a forth
21:49:15 <LoganCapaldo> > let rot13 x = map (\x -> chr (((ord x - ord 'a') `mod` 26) + 13 + ord 'a')) x in rot13 "tuareg"
21:49:16 <lambdabot>  "\129\130n\DELrt"
21:49:27 <nmessenger> LoganCapaldo: you also have to wrap around for characters that move past 'z'
21:49:30 <LoganCapaldo> I'm so obviously missing something
21:49:47 <LoganCapaldo> I thought the mod 26 would do it :)
21:51:01 <LoganCapaldo> > index 'a' ['a'..'z']
21:51:02 <lambdabot>  Couldn't match expected type `(a, a)' against inferred type `Char'
21:51:13 <sorear> funny emacs can't find the newly installed ocaml mode
21:51:23 <LoganCapaldo> @hoogle a -> [a] -> Int
21:51:23 <lambdabot> No matches, try a more general search
21:51:36 <LoganCapaldo> @hoogle a -> [a] -> Integer
21:51:36 <ddarius> @type find
21:51:37 <lambdabot> No matches, try a more general search
21:51:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:51:46 <ddarius> @type elemAt
21:51:49 <lambdabot> Not in scope: `elemAt'
21:51:51 <allbery_b> > let r13 s = map (\x -> let c = fromEnum x in if isUpper x then chr((c - 65 + 13) `mod` 26 + 65) else if ifLower x then chr((c - 97 + 13) `mod` 26 + 97) else x) s in r13 "tuareg"
21:51:52 <lambdabot>   Not in scope: `ifLower'
21:51:52 <nmessenger> > let m = M.fromList (zip (['a'..'z']++['A'..'Z']) (['n'..'z']++['a'..'m']++['N'..'Z']++['A'..'M'])) in map (\c -> maybe c id (M.lookup m c)) "tuareg"
21:51:53 <lambdabot>      Occurs check: cannot construct the infinite type:
21:51:54 <lambdabot>       a = M.Map (M.Map...
21:52:11 <allbery_b> > let r13 s = map (\x -> let c = fromEnum x in if isUpper x then chr((c - 65 + 13) `mod` 26 + 65) else if isLower x then chr((c - 97 + 13) `mod` 26 + 97) else x) s in r13 "tuareg"
21:52:13 <lambdabot>  "ghnert"
21:53:15 <LoganCapaldo> yeah well, I made a calculator :)
21:53:26 <nmessenger> oops, flipped M.lookup
21:54:12 * araujo notices that partial function application and 'where' is a nice way to create closure-like computations
21:54:42 * ddarius isn't really sure what araujo means by "closure-like computations".
21:54:42 <sorear> @localtime beschmi
21:55:19 <araujo> ddarius, just a bit of lisp terminology :-)
21:55:51 <LoganCapaldo> grr
21:56:09 <LoganCapaldo> every time I google parsec I fail because I forget the haskell part
21:56:15 <ddarius> araujo: The words make sense on their own but the combination is ambiguous or not very sensical.
21:56:44 <sorear> ! is dereference, right?
21:56:48 <ddarius> Yes
21:57:05 <ddarius> Damn those science people naming a unit of measurement after a Haskell parsing library.
21:57:15 <sorear> thing1.(thing2)  -- array access?
21:57:24 * ddarius hopes not.
21:57:56 <araujo> ddarius, ?
21:58:06 <sorear> whoa, ocaml has for loops!?
21:58:17 <ddarius> yes
21:58:22 <araujo> sorear, yeah, they are way ahead of us
21:58:38 <sjanssen> s/ahead/behind
21:58:42 <dons> sorear: and while loops :-)
21:58:44 <araujo> ;_)
21:58:45 <sjanssen> doh
21:58:47 <ddarius> araujo: Either what you noticed is blatantly obvious or I'm not really sure what you are talking about.
21:58:49 <sjanssen> "behind of us"
21:58:49 <dons> everything you need to write C
21:58:50 * nmessenger remarks that such an exclamation just wouldn't occur in many other channels :D
21:59:02 <dons> nmessenger: hah!
21:59:09 <nmessenger> "Haskell doesn't have for loops?!!"
21:59:12 <dons> WTF!?? no recursion??
21:59:16 <araujo> sjanssen, haha
21:59:20 <ddarius> nmessenger: Scheme only has do.
21:59:43 <dons> you mean i have to use special loop *syntax* suxors
21:59:56 <araujo> ddarius, i hope there isn't anything wrong with being obvious ;-)
22:00:11 <sorear> Is thing1.(thing2)  readArray thing1 thing2?
22:00:24 <dons> i think that's indexing. yes.
22:00:47 <sorear> ; is >>
22:00:50 * araujo goes and code a 'for' , 'while', and 'do .. while' function
22:00:56 <nmessenger> ?remember sorear whoa, ocaml has for loops!?
22:00:56 <lambdabot> Done.
22:01:03 <sorear> this syntax is making sense ...
22:01:12 <ddarius> Probably some crazy thing about arrays being integer labelled records.
22:01:42 <ddarius> sorear: Is it the revised syntax do you know? (Probably not.)
22:02:33 <dons> nah, its syntax pre 1995
22:02:45 <ddarius> Oi,
22:03:02 <sorear>     i := !i + !i;
22:03:14 <sorear> now that is ... something.
22:03:42 <ddarius> i <<= 1; // !!
22:04:09 <dons> sorear: welcome to C :-)
22:04:55 <ddarius> Haskell "syntax" is so bulky for bit twiddling.
22:04:56 <nmessenger> maybe (:=) is writeIORef
22:04:57 <sorear> " That line [ i := !i + !i; ] sets i to zero, right?  or is the LFP _|_ in this case? "
22:05:10 * araujo considers ocaml an 'imperatively functional' language
22:06:13 <dons> sorear: ocaml is not a lazy language ;)
22:06:46 <dons> you gotta love haskell-cafe@, someone asks a "Re: newbie question about denotational semantics", and Chung-chieh Shan answers
22:07:09 <sorear> == ccshan?
22:07:23 <nmessenger> @seen ccshan
22:07:23 <lambdabot> I saw ccshan leaving #haskell 7d 31m 6s ago, and .
22:07:25 <ddarius> Wouldn't simonpj and JaffaCake field newbie questions here as well when they were here?
22:07:50 <sorear> Igloo still does
22:07:59 <sorear> almost as bigshotty
22:08:12 <ddarius> *blink* *blink*
22:09:19 <ddarius> Igloo's a bigshot?  When did that happen? (No offense Igloo.)
22:09:38 <dons> Igloo works for ghc HQ now
22:09:41 <sorear> ddarius: when he was hired fulltime by MSFT to work on GHC?
22:09:58 <orbitz> why does MSFT show such interest in ghc?
22:10:16 <dons> they take the haskell ideas and add them to excel
22:10:19 <dons> and VB, and C#
22:10:39 <ddarius> 'Tis not untrue.
22:11:09 <LoganCapaldo> plus windows vista is written in Haskell
22:11:16 * LoganCapaldo lies blantantly
22:11:41 <nmessenger> @slap LoganCapaldo
22:11:42 <lambdabot> why on earth would I slap LoganCapaldo
22:11:50 <SamB> @slap LoganCapaldo
22:11:50 * lambdabot slaps LoganCapaldo
22:11:51 <sorear> dons: how literal a translation do you want?
22:11:53 <nmessenger> 'cause he lies blatantly
22:12:18 * araujo thinks there are more haskell applications written out there that people might think
22:12:39 * ddarius is fairly certain there are more Haskellers than people, including Haskellers, think.
22:12:48 <sorear> whoa!  this ocaml program has ACTUAL IO (print statements) in the middle of a COMPUTATIONAL function!!
22:12:59 <araujo> they just don't admit using haskell
22:13:13 <araujo> probably including ms :-)
22:13:19 <sorear> <> eh?
22:13:37 <ddarius> No, they just aren't active parts of the community so there's no way to know.
22:13:37 <sorear> (as in 1 <> 2)
22:13:55 <araujo> ddarius, hah
22:13:56 <orbitz> sorear: why is that so crazy? Ocaml allows side effects eosn't ti?
22:14:00 <nmessenger> sorear: heh, your just full of @rememberable quotes :)
22:14:18 <araujo> ddarius, that's what most people might think
22:14:50 <araujo> But companies and organizations usually got many reasons to not release that kind of information .....
22:15:14 <LoganCapaldo> wooo
22:15:17 <sorear> isn't company `subtypeOf` organization ?
22:15:17 <ddarius> araujo: One of those reasons being that there isn't any reason to.
22:15:19 <sjanssen> sorear: <> is /=, I think
22:15:25 <LoganCapaldo> parsec can parse context sensitive grammars
22:15:31 <araujo> ddarius, *sighs*
22:15:36 * SamB wonders how to get his Xv overlays to stop sticking around after the videos are through...
22:15:38 <sorear> sjanssen: yea, i've used Pascal. (once)
22:15:45 * araujo jumps to code again
22:15:52 <sorear> sjanssen: that's why it was , eh? and not , wtf?
22:16:04 * LoganCapaldo goes and writes a context sensitive programming language
22:16:06 <dons> sorear: not terribly literal
22:16:08 <SamB> or maye just hwo to keep lambdabot's nick from having pixels that match the color key
22:16:13 <dons> feel free to hack it to make it work
22:16:52 <orbitz> does ocaml allow side effects?
22:17:03 <sorear> dons: stuff like ... should I use complex numbers?  turn the refs (not arrays) into recursion varaibles?
22:17:08 <sorear> orbitz: yea.
22:17:17 <sorear> orbitz: this FFT, for instance, causes output.
22:17:21 * SamB tries working around it by putting his XMMS video on the right
22:17:24 <ddarius> sorear: Translate it to idiomatic Haskell.
22:17:25 <dons> sorear: yeah. feel free to do what ever you need to make it work
22:17:41 <dons> its a benchmark, so needs to be pretty simple (i.e. jhc-ghc should like it)
22:17:58 <dons> just as long as the essential numerics stuff remains
22:18:00 <orbitz> sorear: do bjects have setter sin them? or do you get anew objec when you modify it?
22:18:30 <SamB> sleep sleep sleep...
22:18:33 <ddarius> orbitz: You could do either.
22:18:36 <sorear> orbitz: I'm aware of the fundementals of CAML. the O is unknown and irrelevant.
22:18:47 <orbitz> hah
22:19:11 <ddarius> The O is about the only interesting part of O'Caml, that and the module system, but that's shared with Caml and similar to other MLs.
22:19:14 <orbitz> i haven't use CAML thouhg.
22:19:21 <araujo> sorear, haha
22:19:50 <mdmkolbe> lambdabot: help
22:19:51 <sorear> what's the difference between f x and f(x)?
22:19:55 <sorear> lambdabot: @help
22:19:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:19:59 <mdmkolbe> thx sorear
22:20:11 <sorear> I see both forms in this OCaml code :(
22:20:41 <ddarius> Inconsistent use of syntax?
22:20:41 <araujo> orbitz, it's just other imperative language ;-)
22:21:21 <orbitz> so nothing special to it?  it's not Pure in any respect?
22:21:29 <araujo> no pure
22:21:54 <sorear> float is analogous to fromIntegral?
22:22:39 * ddarius has just installed O'Caml, he hasn't actually used it.
22:22:41 <dons> I think so, yes.
22:22:47 <sorear> wait, do ocaml arrays automatically grow?!
22:23:03 <ddarius> The one thing I was going to use it for I'm thinking about reimplementing in Haskell anyways.
22:23:16 <sorear> @botsnack
22:23:17 <lambdabot> :)
22:23:23 <glguy> any dwm users have a recommendation for what they use to start applications? (other than opening a new xterm window)
22:23:30 <glguy> like a "run command"
22:24:10 <sjanssen> glguy: gmrun'
22:24:15 <sjanssen> minus the '
22:24:20 <glguy> (I was about to ask)
22:26:34 <dons> glguy: the alt-p command
22:26:39 <dons> which launches dmenu in the menu bar
22:26:41 * sorear begins to ask if ! binds more or less tightly than -, then suspects ocaml probably doesn't allow arbitrary pointer aritmetic
22:26:44 <dons> assuming you have dmenu
22:26:49 <glguy> ahhh, that's right
22:27:06 <glguy> gmrun looks pretty slick
22:27:15 <glguy> as run boxes go :)
22:29:01 <siti> @google gmrun
22:29:03 <lambdabot> http://www.bazon.net/mishoo/gmrun.epl
22:29:03 <lambdabot> Title: [Mishoo] CLI-like Interface to Run Programs
22:31:03 <mdmkolbe> is there already a standard function that does the equivalent of "scope get mid set = do x<- get; mid; set x"?  (I can write it myself, but I always prefer to use standard functions if they exist.  Finding them can be hard sometimes.)
22:31:19 <sorear> mdmkolbe: if you can, modify
22:31:34 <sorear> no sorry
22:31:42 <sorear> bracket?
22:31:47 <sorear> @type IO.bracket
22:31:49 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:32:01 <sorear> @type IO.bracket_
22:32:04 <lambdabot> forall a b c. IO a -> (a -> IO b) -> IO c -> IO c
22:32:10 <nmessenger> @src bracket
22:32:10 <lambdabot> bracket before after thing = block $ do
22:32:10 <lambdabot>     a <- before
22:32:10 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
22:32:10 <lambdabot>     after a
22:32:10 <lambdabot>     return r
22:32:30 <sorear> unfortunately bracket messes with exceptions, so it needs IO
22:33:15 <sorear> Frustrated, sorear picks up a book on digital coding theory and tries to find the FFT section.
22:34:41 <mdmkolbe> @src Control.Exception.bracket
22:34:41 <lambdabot> Source not found. I feel much better now.
22:34:47 <sorear> amusingly, the ocaml example uses a non-standard algorithm
22:35:00 <sorear> normal FFTs permute, then butterfly
22:35:06 <sorear> this one works backward
22:35:37 <sorear> I suppose it's just a matter of labelling :)
22:38:43 <ddarius> http://www.dspguide.com
22:38:45 <lambdabot> Title: The Scientist and Engineer's Guide to Digital Signal Processing
22:39:29 <ddarius> sorear: It's possible to do them either way.  I actually think O'Camls way is the one where you can save few ops.
22:39:37 <mr_tenor> ddarius: great book, that :)
22:39:40 <mdmkolbe> there used to be a way to browse the GHC sources online but I can't seem to find it right now.  is that still around?
22:39:42 <sorear> call me old fashioned, but given the choice I'd prefer the pound of paper in my hand
22:39:48 <sorear> @source
22:39:49 <lambdabot>  not available
22:39:52 <sorear> @source Prelude
22:39:53 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
22:39:59 <sorear> @source GHC.List
22:39:59 <lambdabot> GHC.List not available
22:40:05 <sorear> @source Data.List
22:40:06 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
22:40:10 <sorear> etc etc
22:40:14 <mdmkolbe> @source Control.Exception
22:40:15 <lambdabot> http://darcs.haskell.org/packages/base/Control/Exception.hs
22:40:19 <mdmkolbe> thx again sorear
22:40:27 <sorear> yw
22:41:27 <sorear> ddarius: vending machine moment.
22:41:36 <ddarius> sorear: So would I, but...
22:41:49 <sorear> ddarius: doing the 'other' FFT is the same as doing a IFFT in reverse.
22:42:24 <ddarius> The IFFT -is- the FFT essentially
22:42:31 <sorear> exactly
22:42:42 <sorear> which is what makes this work so brilliantly
22:42:49 <mdmkolbe> @source bracket
22:42:50 <lambdabot> bracket not available
22:43:06 <mdmkolbe> @src bracket
22:43:07 <lambdabot> bracket before after thing = block $ do
22:43:07 <lambdabot>     a <- before
22:43:07 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
22:43:07 <lambdabot>     after a
22:43:07 <lambdabot>     return r
22:43:08 <LoganCapaldo> @source of the river
22:43:09 <lambdabot> of the river not available
22:43:24 <sorear> @source TIME
22:43:25 <lambdabot> TIME not available
22:43:54 <ddarius> Sooner or later I'm going to give in and do something corny.
22:44:12 <sorear> @source /me is currently
22:44:12 * lambdabot is currently not available
22:44:31 <mdmkolbe> @source IO.bracket
22:44:32 <lambdabot> IO.bracket not available
22:44:37 <mdmkolbe> @source IO
22:44:37 <lambdabot> IO not available
22:44:59 <mdmkolbe> @src IO.bracket
22:45:00 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:45:11 <sorear> @src IO
22:45:12 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:45:17 <sorear> there.
22:45:35 <mdmkolbe> IO package, not IO type
22:48:20 <LoganCapaldo> @src IO return
22:48:20 <lambdabot> return x    = returnIO x
22:48:39 * LoganCapaldo how deep does the rabbit hole go?
22:48:43 <nrb23> huzzah! I finally figured out the TCP checksums
22:48:44 <LoganCapaldo> @src returnIO x
22:48:44 <lambdabot> Source not found. Where did you learn to type?
22:48:49 <LoganCapaldo> errps
22:48:53 <LoganCapaldo> @src returnIO
22:48:53 <lambdabot> Source not found. Are you on drugs?
22:49:08 <LoganCapaldo> Not a very deep rabbit hole :(
22:50:06 <LoganCapaldo> @type IO (\v s -> (# s, v#))
22:50:08 <lambdabot> parse error on input `)'
22:50:18 <LoganCapaldo> @type IO (\v s -> (# s, v #))
22:50:21 <lambdabot> Not in scope: data constructor `IO'
22:50:37 <LoganCapaldo> fiiiiine
22:50:45 <sorear> @type GHC.IOBase.IO (\v s -> (# s, v #))
22:50:48 <lambdabot>     The lambda expression `\ v s -> ...' has two arguments,
22:50:48 <lambdabot>     but its type `GHC.Prim.State# RealWorld
22:51:05 <sorear> @type \v -> GHC.IOBase.IO (\s -> (# s, v #))
22:51:08 <lambdabot> forall a. a -> IO a
22:51:21 <sorear> @type (# 1, 2 #)
22:51:24 <lambdabot> forall t t1. (Num t, Num t1) => (# t, t1 #)
22:51:41 <LoganCapaldo> Oh was that all I had to do?
22:51:47 <LoganCapaldo> sheesh
22:51:48 <sorear> now
22:52:04 <sorear> I don't think :t always used -fglasgow-exts
22:52:10 <mdmkolbe> what is the (# #) syntax?
22:52:18 <sorear> and that cannot be made to *parse* without -fglasgow-exts
22:52:23 <sorear> unboxed tuples
22:52:25 <LoganCapaldo> strict tuple IIRC
22:52:35 <sorear> @kind (# Int#, Int# #)
22:52:38 <lambdabot> Not in scope: type constructor or class `Int#'
22:52:38 <lambdabot>  
22:52:38 <lambdabot> <interactive>:1:9: Not in scope: type constructor or class `Int#'
22:52:43 <LoganCapaldo> IRIC
22:52:50 <sorear> @kind (# GHC.Base.Int#, GHC.Base.Int# #)
22:52:53 <lambdabot> (#)
22:53:13 <mdmkolbe> @kind (#,#)
22:53:16 <lambdabot> parse error on input `,'
22:53:22 <mdmkolbe> @kind (,)
22:53:25 <lambdabot> * -> * -> *
22:53:39 <mdmkolbe> @kind (# , #)
22:53:42 <orbitz> hrm, anyone plaeyd with judy tree's?
22:53:42 <lambdabot> parse error on input `,'
22:53:57 <sorear>   * add galois_raytrace benchmark -- nice!
22:58:54 <dons> generates a nice ray trace image in the .expected file
22:59:51 <sorear> dons: should I use language-provided Complex numbers (still on fft)?
23:00:12 <dons> sounds reasonable
23:00:17 <sorear> obviously UArray Int (Complex Double) will be a little hard to arrange :)
23:00:28 <dons> yes. that's no good.
23:00:48 <sorear> I ask mainly because the ocaml version does complex math 'the hard way'
23:01:01 <dons> yeah. i think its ok to use Complex
23:01:06 <sorear> does ocaml have complex numbers?
23:01:18 <sorear> in the spirit of portability ...
23:01:19 <dons> might need some strictness tricks, of couse. (i.e. seq)
23:01:23 <dons> not sure.
23:01:31 <sorear> Foreign or Data.Array.IO?
23:01:34 <sorear> :)
23:01:38 <LoganCapaldo> if they do, the operators must be pretty long :)
23:02:10 <LoganCapaldo> i+, i-, ietc?
23:02:50 <dons> hmm. i'd prefer not to use Foreign*
23:02:52 <dons> keep it pure
23:02:55 <dons> if possible
23:03:15 <sorear> dons: it can't be pure, it uses mutable arrays :(
23:03:22 <sorear> dons: oh, pure Haskell ... :)
23:03:25 <brad__> i have been reading through the functions in the Monad module, it seems there a monadic parallels to most of the key elements of the haskell language, but for monads. i ask this not as a troll but as a humble novice - isn't this hacky?
23:03:36 <sorear> brad__: yes.
23:03:38 <ddarius> And thus sorear begins his turn toward the dark side.
23:04:03 <sorear> ddarius: I've been abusing the FFI for pointer arith for about two weeks now.
23:04:13 <sorear> ddarius: makes a big difference in performance ...
23:04:26 <ddarius> What's wrong with that? Pointer arithmetic is your friend.
23:04:48 <sorear> "And thus sorear begins his turn toward the dark side."  -- I thought this was erroneous
23:05:44 <ddarius> Ironically, it was CPS that made/makes me not so interested in assembly any more.
23:05:53 <hpaste>  cragwolf pasted "guards for modified map" at http://hpaste.org/659
23:06:20 <cragwolf> Hi, newbie here, just added a question to hpaste.org, was wondering if someone could answer it. Not sure if I have followed the correct etiquette, so apologies in advance.
23:07:03 <bd_> cragwolf: if you want to use guards with that
23:07:04 <sorear> dons: ooh
23:07:09 <bd_> you'll need to use irrefutable patterns
23:07:15 <sorear> dons: you found a bug in the Jhc *parser*
23:07:35 <hpaste>  bd_ annotated "guards for modified map" with "with irrefutable patterns" at http://hpaste.org/659#a1
23:07:41 <dons> sorear: cool :-)
23:07:53 <dons> in what? jl_rsa or galois?
23:07:55 <bd_> the ~ means it won't try to actually do the match until you look at f, fs, x, or xs
23:08:03 <hpaste>  LoganCapaldo annotated "guards for modified map" with "with zipWith" at http://hpaste.org/659#a2
23:08:10 <bd_> cragwolf: that said, it's easier to write rmap = zipWith ($) :)
23:08:17 <ddarius> Oh my god that's ugly.
23:08:25 <sorear> dons: galois
23:08:35 <dons> oh, the UNPACK pragma?
23:08:37 <ddarius> Incidentally, use null not ==[]
23:08:37 <sorear> (Foo {}) is being errored.
23:08:46 * sorear tests this
23:08:49 <dons> (i had to remove an UNPACK prgam too when jhc barfed)
23:08:57 <hpaste>  bd_ annotated "guards for modified map" with "pointfree style" at http://hpaste.org/659#a3
23:10:02 <hpaste>  bd_ annotated "guards for modified map" with "or using parallel list comprehensions" at http://hpaste.org/659#a4
23:11:03 <sorear> @seen JohnMeacham_
23:11:04 <lambdabot> I saw JohnMeacham_ leaving #haskell and #haskell-blah 1d 18h 11m 24s ago, and .
23:11:07 <sorear> @seen JohnMeacham
23:11:07 <lambdabot> JohnMeacham is in #haskell and #haskell-blah. I last heard JohnMeacham speak 4h 44m 21s ago.
23:11:09 <ddarius> cragwolf: Incidentally, the idiomatic way to write that using guards would be along the lines of rmap xs ys | null xs || null ys = [] | otherwise = ...
23:11:17 <sorear> (finding nick to @tell)
23:11:36 <ddarius> cragwolf: What you were trying to do and bd_'s fix of it is absolutely hideous.
23:11:38 <bd_> ddarius: then you have ugly head and tails everywhere, though. or a where
23:11:41 <bd_> but I agree
23:11:43 <JohnMeacham> hello.
23:11:43 <bd_> zipWith is the best
23:11:48 <JohnMeacham> I have been summoned.
23:11:52 <hpaste>  sorear pasted "bug in jhc parser" at http://hpaste.org/660
23:11:52 <ddarius> bd_: Idiomatically, you wouldn't use guards.
23:11:59 <bd_> precisely :)
23:12:18 <JohnMeacham> hey, anyone with something other than a linux box want to check if /usr/include/endian.h exists? I am curious how portable it is.
23:12:19 <bd_> http://hpaste.org/659#a3 is I think the most idiomatic, but then again it's my paste too :)
23:12:29 <sorear> JohnMeacham: ah, I see my slip/wake predictor misfired :)
23:12:41 <sorear> JohnMeacham: I have one
23:12:45 <mdmkolbe> JohnMeacham: it exists on Cygwin
23:12:46 <cragwolf> :) Thanks everyone.
23:12:49 <sorear> oh wait I have linux
23:13:55 <dons> JohnMeacham: $ ls /usr/include/endian.h
23:13:55 <dons> colorls: /usr/include/endian.h: No such file or directory
23:13:55 <dons> $ uname -msr
23:13:56 <dons> OpenBSD 3.8 i386
23:14:26 <dons> $ ls /usr/include/machine/endian.h
23:14:27 <dons> /usr/include/machine/endian.h
23:15:14 <sorear> JohnMeacham: *((int*)"\0\0\0\001") == 1 :)
23:15:59 <mdmkolbe> sorear: lol
23:16:21 <sorear> hmm.  does that violate any strict-aliasing rules?
23:16:34 <dons> see. he has already been taken by the dark side
23:16:49 <sorear> muahahaha!
23:17:11 <jql> it's more likely to violate alignment than strict-aliasing. heh
23:17:21 <jql> thank intel for x86
23:18:46 <mdmkolbe> to get around allighment issues: int x = 1; *((char*)&x) == (char)1
23:20:41 <ddarius> #ifdef BIG_ENDIAN  #error Buy a computer designed to -compute- things    #endif
23:21:03 <siti> lol
23:21:17 <sorear> isn't the Blue Gene/L using powerpcs? (BIG_ENDIAN)
23:21:35 <siti> they don't compute they just use power ;)
23:22:00 <sorear> and money.  don't forget about the money.
23:22:21 <mdmkolbe> sorear: probably POWER5s
23:22:50 <siti> what a silly name now that people are power conscious :p
23:23:00 <jql> first, though, you have to get the sugar
23:23:26 <dons> that's true
23:29:11 <LoganCapaldo> @type zipWith (. id)
23:29:13 <lambdabot> forall c b. [b -> c] -> [b] -> [c]
23:29:52 <mdmkolbe> @pointless zipWith (. id)
23:29:53 <lambdabot> zipWith id
23:30:15 <mdmkolbe> @pointless zipWith ($)
23:30:16 <lambdabot> zipWith id
23:30:36 <LoganCapaldo> @type zipWith id
23:30:39 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
23:30:49 <LoganCapaldo> oh duh
23:30:54 <LoganCapaldo> LOL
23:30:57 <LoganCapaldo> currying makes for fun!
23:31:11 <ddarius> id . f = f
23:31:12 <mdmkolbe> @pointless (. id)
23:31:12 <lambdabot> id
23:31:28 <mdmkolbe> @pointless ($ id)
23:31:29 <lambdabot> ($ id)
23:31:44 <mdmkolbe> @pointless (id $)
23:31:45 <LoganCapaldo> I get it now
23:31:45 <lambdabot> id
23:31:47 <ddarius> (. id) = \f -> f . id = \f . f = id
23:31:50 <LoganCapaldo> really
23:31:54 <LoganCapaldo> I promise :)
23:33:28 <LoganCapaldo> > zipWith id [(*2), (+1)] [3, 4]
23:33:30 <lambdabot>  [6,5]
23:33:56 <LoganCapaldo> I <3 operator sections
23:34:46 <nrb23> @src .
23:34:46 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:34:51 <nrb23> @src (.)
23:34:51 <lambdabot> (.) f g x = f (g x)
23:35:04 <LoganCapaldo> (.) f g x = f (g x)
23:35:07 <careo> is anyone on ubuntu and has happened to get the SOE graphics stuff going? esp from the the debian package
23:36:13 <ddarius> type Exists f = forall r.(forall a.f a -> r) -> r; open :: Exists f -> (forall a.f a -> r) -> r; open package k = package k; pack :: f a -> Exists f; pack a k = k a
23:36:31 <ddarius> open = ($) pack = flip ($)
23:37:59 <deadbeef> hi dear friends
23:38:00 <deadbeef> sup
23:38:43 <ddarius> You know your water is hard when your ice doesn't float.
23:39:12 <deadbeef> o rly
23:40:24 <sorear> hello
23:40:26 <sorear> whoa
23:40:38 <sorear> this ocaml code uses 1-based arrays
23:41:34 <nrb23> ddarius: what, are you pulling water from the Ohio River or something?
23:41:40 <dons> patches you don't see everyday:
23:41:41 <dons> Sat Feb 24 09:06:22 EST 2007  jeanphilippe.bernardy@gmail.com
23:41:41 <dons>   * Added very simple interpreter for haskell expression (using GHC API)
23:41:43 <sieni> Whenever I code in Fortran, I prefer -1-based arrays.
23:41:51 <sieni> Not that I code in Fortran
23:42:06 <ddarius> Haskell is also probably the only language where newbie questions get answered by references to research papers... on a fairly regular basis now that I think of it.
23:42:12 <ddarius> nrb23: Texas.
23:42:16 <mdmkolbe> nrb23: even the ice on the Ohio river floats, he must be using something worse
23:42:33 <nrb23> mdmkolbe: yeah, but the ice on the Ohio river scares me too
23:42:51 <allbery_b> Ohio well water.  ugh, iron...
23:42:59 <allbery_b> <-- from Ohio
23:43:20 <sieni> ddarius: decents books about haskell would be nice
23:43:26 <nrb23> <--- from Western NY originally, CA now
23:43:44 <mdmkolbe> sieni: other than "The Haskell School of Expression"?
23:44:12 <nrb23> is that a good book?
23:44:28 <Korollary> http://www.amazon.com/gp/product/0521692695
23:44:30 <mdmkolbe> nrb23: for learning haskell it is a very good book.
23:45:52 <nrb23> mdmkolbe: this one? http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089/sr=1-1/qid=1172389370/ref=pd_bbs_sr_1/102-5835360-1578527?ie=UTF8&s=books
23:45:56 <lambdabot> http://tinyurl.com/262ppc
23:45:57 <mdmkolbe> nrb23: at the time I learned Haskell (~2-3 yr ago) it was the only decent way to learn Haskell (all the online tutorials just confused me by mentioning things like "class" and "constructor" without good explanations which comming from a C++ background made things bad)
23:46:16 <mdmkolbe> nrb23: yep
23:46:36 <nrb23> right now, I'm most confused by things like the state monad and monad transformers
23:46:49 <nrb23> I'm successfully using Data.Binary
23:47:01 <allbery_b> @go monad transformers step by step
23:47:03 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
23:47:03 <lambdabot> Title: Monad Transformers Step by Step
23:47:10 <nrb23> I should really "release" my current project
23:48:32 * nrb23 doesn't know where he put the how to make a haskell project page
23:48:39 <nrb23> I think dons wrote it
23:48:58 <allbery_b> @go how to write a haskell program
23:49:00 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
23:49:00 <lambdabot> Title: How to write a Haskell program - HaskellWiki
23:51:07 <nrb23> thanks allbery_b and lambdabot !
