00:06:47 <dons> ?where+ nobench http://www.cse.unsw.edu.au/~dons/code/nobench
00:06:48 <lambdabot> Done.
00:06:58 <dons> sorear: want to give it a whirl?
00:07:05 <dons> should just run with 'make', assuming you have hugs, ghc and ghci
00:07:20 <dons> timing results into bench.results and bench.log
00:07:30 <dons> Test: recursive (naive recursive functions)
00:07:30 <dons> ghc                  0.616 seconds
00:07:31 <dons> ghci                 12.421 seconds
00:07:31 <dons> hugs                 89.757 seconds
00:07:31 <dons> example
00:07:32 <sorear> sure!
00:07:47 <dons> currently just 5 or so shootout programs
00:07:50 <sorear> wow, I thought I'd uninstalled hugs
00:07:58 <dons> and no support for yhc or nhc yet.
00:08:03 <dons> though that's trivial to add
00:08:38 <dons> I think this might be a surprise for some people. ghc does a lot better than I thought.
00:08:45 <dons> well, hugs does a lot worse.
00:09:05 <sorear> suggestion, in addition to fast portable and fast nonportable - have naive (stresstest for ubercompilers like jhc) and C/assembly (the goal)
00:09:26 <dons> yeah
00:09:29 <dons> sounds reasoable
00:09:47 <dons> currently i only have fast portable
00:10:14 <sorear> dons: ooh, you hit #1151
00:10:20 <dons> oh?
00:10:22 <dons> a head bug?
00:10:41 <sorear> dons: how do I tell make to avoid my ghc-6.7.20070213?
00:10:44 <sorear> yes
00:10:49 <dons> set ghc in header.mk
00:11:08 <sorear> GHC HEAD miscompiles virtually everything when passed the -fvia-C option
00:11:10 <dons> though I might have hardcoded the string 'ghc' in a couple of other places
00:11:14 <sorear> -fasm works fine however
00:11:31 <dons> wow, /bin/sh: line 1: 24102 Segmentation fault
00:11:42 <dons> got ghc to segfault on partial sums. huh.
00:11:56 <sorear> and GHC HQ has decided that -fvia-C is never the default anymore, even with -O2, so -fasm should be OK in the benchmark
00:11:56 <dons> gcc cranked too high
00:12:07 <dons> sorear: yeah, i'd like to actually compare -fvia-C and -fasm
00:12:11 * sorear naively thought gcc was safe
00:12:21 <dons> nah, gcc can break things
00:12:26 <dons> above -optc-O2
00:12:44 <sorear> bad interaction with the mangler?
00:12:47 <dons> so are you getting reasonable results?
00:13:00 <dons> possibly. or maybe just bad gcc
00:13:02 <sorear> /bin/sh: line 1: 11481 Segmentation fault      ./partial-sums 2500000 </dev/null >partial-sums.ghc.actual 2>&1
00:13:08 <dons> right. same here
00:13:12 <dons> not on openbsd though
00:13:13 * dons peeks 
00:13:15 <sorear> yes, my results are not unexpected
00:13:55 <dons> do you have yhc or jhc on your box?
00:14:15 <sorear> both
00:14:29 <sorear> jhc is missing haskell98 and panics on large programs
00:14:48 <sorear> yhc is missing Directory (from haskell98), parsec, mtl, etc.
00:14:56 <dons> http://www.cse.unsw.edu.au/~dons/tmp/bench.results
00:15:10 <sorear> but both will compile and run "Hello world"
00:15:10 <dons> the timeout is too low
00:15:14 <dons> and some of the numbers are too big
00:15:27 <dons> well, nhc should be ok for most of these (all of them?)
00:15:47 <dbremner> dons- gcc VRP got smarter recently and it can break some code
00:15:48 <dons> and yhc too I hope.
00:16:19 <sorear> Vrp?
00:16:32 <dbremner> sorear- variable range propagation
00:16:35 <sorear> gak, my major mode map is broken again
00:17:53 <dons> ah, looks like the sse stuff breaking partial-sums
00:17:58 * dons fixes
00:18:15 <sorear> gah.
00:18:30 <sorear> haskell-mode-map is corrupted by a type error in .emacs
00:18:38 <sorear> and what do I have to do?
00:18:47 <sorear> save everything, kill ERC, and restart Emacs.
00:18:59 <sorear> I am sooo looking forward to a working yi.
00:19:11 <sorear> where working = feature-complete
00:19:13 <dons> heh
00:19:29 <sorear> /bin/sh: line 1: 11616 Segmentation fault      ./mandelbrot 3000 </dev/null >mandelbrot.ghc.actual 2>&1
00:19:50 <sorear> and the gcc warning pattern characteristic of #1151
00:20:13 <sorear> which file do I upload now?
00:20:22 <dons> try overriding the ghc flags in the Makefile in the mandelbrot dir
00:20:23 <sorear> bench.log ? bench.results ?
00:20:32 <dons> bench.results is the raw summary
00:20:37 * sorear feels stupid after reading the filename
00:20:41 <sorear> so both?
00:20:42 <dons> the other stuff is the build log
00:20:53 <dons> well, .results might be interesting
00:21:10 <sorear> http://members.cox.net/stefanor/bench.log
00:21:42 <sorear> http://members.cox.net/stefanor/bench.results
00:22:32 <sorear> so, modulo #1151, my results are similar.
00:23:02 <dons> ok. good. i'll tune the numbers now so most things can run to completion
00:23:11 <dons> and try to get nhc98 support working
00:23:15 <sorear> the constant factors are different but ghc > ghci > hugs is constant
00:23:57 <dons> can you work out what flags break mandelbrot ?
00:24:34 <sorear> all the ghc programs were broken by -fvia-C
00:24:43 <sorear> I'm trying again now with 6.6
00:24:59 <dons> ah ok
00:25:00 <dons> yes. please do
00:35:25 <sorear> dons: (as the author of AltData) can I assume that x == y iff show x == show y, for x, y :: TypeRep ?
00:35:42 <dons> yeah
00:36:06 <sorear> no more unsafePerforeIO . typeRepKey, yay
00:36:16 <sorear> (at least not until profiling)
00:41:35 <kolmodin> I'm writing a lib using the binary. the first thing I'm missing is counters in Get and Put to see how many bytes I've read/written -- which I need to implement aligning
00:41:54 <sorear> StateT Int Get!
00:41:57 <sorear> :)
00:42:18 <sorear> hmm, that will require wrapping the primitives
00:42:34 <kolmodin> well yes, naturally. but maybe it's a so common thing that binary should support it
00:42:42 <kolmodin> and I'm wrapping the primitives anyway
00:42:56 <kolmodin> to make sure they get aligned right
00:43:23 <kolmodin> I only need ~10 of them anyway
00:43:23 <sorear> "writing a lib"?  /me wonders whether that means Haskell ELF writer
00:43:32 <sorear> would be rather cool
00:43:32 <kolmodin> hah, no :)
00:43:50 <sorear> worth a thought :)
00:44:04 * allbery_b really thinks BFD is not something any sane person wants to reimplement :)
00:45:52 <kolmodin> morning bringert
00:46:15 <bringert> morning
00:47:15 <sorear> dons: I've re-run and re-uploaded.  It seems the only place you forgot $() was the version check, so ignore the header :)
00:52:31 <dons> ok. that looks better.
00:53:11 <sorear> (now rerunning with 4 more patches!)
01:05:16 <sorear> dons: poke, I've rerun and reuploaded again
01:08:36 <dons> ok
01:09:53 <dons> i've just pushed some more patches and another benchmark
01:10:14 <sorear> now I am running with 11
01:24:50 <sorear> > 'z' > 'a'
01:24:51 <lambdabot>  True
01:32:12 <sorear> what is the HHL name of Numeric?
01:32:53 <dmead> sup kids
01:33:08 * dmead finally got away from coding haskell to go out and party a little
01:33:14 <sorear> yay
01:36:46 <encryptio> are there any bindings to Quicktime for haskell? if not, how would i go about creating them?
01:37:10 <sorear> the FFI most likely
01:37:18 <sorear> what language is the qt interface?
01:37:35 <encryptio> quicktime is in vanilla C
01:37:41 <sorear> the FFI then
01:37:57 <sorear> you want most likely one of the binding generators
01:38:15 <sorear> c2hs, greencard, I'm sure there are others
01:38:22 <sorear> I haven't used any
01:38:51 <mahogny> sorear, QT is c++
01:38:57 <mahogny> likely a hell to port
01:39:05 <encryptio> yes, QT is c++. but quicktime is C.
01:39:07 <mahogny> you want to write a new utility for it
01:39:12 <mahogny> aha. duh
01:39:35 <mahogny> pure FFI is rather easy, I have installation problems with c2hs but it seems nice otherwise
01:39:56 <sorear> mahogny: oh yeah. if it wasn't 1:30am I would have recogniced the potential for confusion with trolltech's x toolkit
01:40:10 <mahogny> :)
01:40:40 <encryptio> i shall look up those programs then... thanks again.
01:41:02 <dons> ndm, this is really evil that the yhc build script downloads random repos :/
01:41:21 <mahogny> ...literally?
01:41:22 <dons>    and tries to run svn :/
01:41:38 <dons> svn co http://svn.python.org/projects/python/trunk/Modules/_ctypes/ depends/ctypes
01:41:39 <lambdabot> Title: Revision 53817: /python/trunk/Modules/_ctypes
01:41:46 * dons not happy
01:42:00 <dons> boo on that.
01:42:07 <sorear> dons: I've re-uploaded/run
01:42:22 <dons> cheer
01:42:38 * dons goes and tries nhc
01:42:43 <dons> since i bet it doesn't pull any evil tricks
01:42:43 <sorear> dons: really recent yhc can be persuaded to not depend on svn
01:46:11 <goltrpoat> heh, im building yhc as we speak
01:47:02 <dons> doing stuff on the network isn't nice to see when building a compiler :/
01:47:26 <fuzan> It's so sad having to redefine all my alex tokens again when using happy :(
01:47:39 <fuzan> Is this avoidable at all?
01:47:54 <sorear> yeah, well these are the same compiler folks that thought scons sounded like a good idea. sigh.
01:48:09 <sorear> fuzan: don't switch?
01:48:16 <dons> :/
01:48:30 <fuzan> sorear: don't switch
01:48:32 <fuzan> ?
01:48:50 <dons> i don't think there's an easy way, fuzan
01:48:53 <dons> without using a preprocesor
01:48:59 <dons> which might be reasonable for a large number of tokens
01:49:28 <fuzan> just seems like a maintainence nightmare
01:49:49 <fuzan> oo, Happy's parE error is so exhilirating as well!
01:50:04 <dons> its only two places. not really a nightmare
01:50:09 <dons> and you can render both with a script
01:50:18 <fuzan> yah... perhaps i'm exaggurating :)
01:52:17 <sorear> fuzan: apparently, I'm too tired to make witty comments.  bye!
01:52:19 <fuzan> three couting the Token datatype :)
01:52:43 <fuzan> sorear: get some rest; i'm dissapointed :\
01:54:25 <kolmodin> ?paste
01:54:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:59:08 <hpaste>  kolmodin pasted "Could not deduce (Marshall a) from the context (Marshall a2)" at http://hpaste.org/538
01:59:38 <bringert> fuzan: BNFC generates Alex and Happy files for you.
01:59:41 <kolmodin> any hints on that?
02:00:20 <fuzan> bringert: thanks, i'll take a look at it
02:00:56 <bringert> @google BNFC
02:00:59 <scriptdevil> hey whats the magic, suddenly haskell has climbed all the way up to the top 5 in the shootout
02:01:01 <lambdabot> http://www.bnfc.org/
02:01:07 <bringert> that's not the one
02:01:21 <bringert> "BNF for Children"?
02:01:35 <kolmodin> heh
02:01:41 <bringert> fuzan: http://www.cs.chalmers.se/~markus/BNFC/ is the one you want
02:01:43 <lambdabot> Title: The BNF Converter
02:01:43 <fuzan> http://www.cs.chalmers.se/~markus/BNFC/ ?
02:01:44 <lambdabot> Title: The BNF Converter
02:01:48 <bringert> right
02:01:50 <fuzan> :)
02:02:22 <bringert> we need a bit of google bombing here
02:02:47 <bringert> "Belfast Naturalists' Field Club"
02:02:48 <bringert> haha
02:02:58 <fuzan> argh
02:03:05 <fuzan> i was JUST going to say we couldn't compete against them
02:03:11 <fuzan> this time you beat me :\
02:04:05 <fuzan> time to sleep, night.
02:04:49 <bringert> kolmodin: your paste is missing the Endian type
02:05:12 <kolmodin> bringert: oh. well, data Endian = BigEndian | LittleEndian
02:05:23 <roconnor> > pi `mod` 1
02:05:24 <lambdabot>  Add a type signature
02:05:30 <roconnor> > pi `mod` 1 :: Double
02:05:31 <lambdabot>   add an instance declaration for (Integral Double)
02:05:32 <lambdabot>     In the expression: pi...
02:05:49 <roconnor> @info Integral
02:05:49 <lambdabot> Integral
02:05:56 <nornagon> @instanc Integral
02:05:57 <lambdabot> Maybe you meant: instances instances-importing
02:06:01 <roconnor> @src Integral
02:06:01 <lambdabot> class  (Real a, Enum a) => Integral a  where
02:06:01 <lambdabot>     quot, rem, div, mod :: a -> a -> a
02:06:01 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
02:06:01 <lambdabot>     toInteger           :: a -> Integer
02:06:03 <nornagon> @instances Integral
02:06:04 <lambdabot> Int, Integer
02:06:35 <bringert> kolmodin: I get: hpaste538.hs:46:17:
02:06:35 <bringert>     Ambiguous type variable `a' in the constraint:
02:06:36 <bringert>       `Marshall a'
02:06:36 <bringert>         arising from use of `alignmentOf' at hpaste538.hs:46:17-29
02:06:36 <bringert>     Probable fix: add a type signature that fixes these type variable(s)
02:07:06 <kolmodin> bringert: yup
02:07:15 <dons> scriptdevil, no magic. we just fixed the entries that broke on the update to ghc 6.6
02:07:32 <kolmodin> hmm
02:12:42 <kolmodin> bringert: I get your message with GHC 6.6, and mine with ghc head
02:13:51 <kolmodin> the thing is, as you can see in the code, I try to use the type of the return value to get the alignment of the return value
02:15:01 <kolmodin> so the function is of type :: DecM a, and I want to get a value of that 'a' to get the alignment of it with 'alignmentOf'
02:17:02 <roconnor> @type toDouble
02:17:04 <lambdabot> Not in scope: `toDouble'
02:17:07 <roconnor> @type toFloating
02:17:10 <lambdabot> Not in scope: `toFloating'
02:17:14 <roconnor> @hoogle to
02:17:15 <lambdabot> Char.toLower :: Char -> Char
02:17:15 <lambdabot> Char.toUpper :: Char -> Char
02:17:15 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
02:17:46 <roconnor> > fromRational (1/10) :: Double
02:17:47 <lambdabot>  0.1
02:17:51 <roconnor> > fromRational (6/10) :: Double
02:17:52 <lambdabot>  0.6
02:17:55 <roconnor> > fromRational (6/100) :: Double
02:17:56 <lambdabot>  6.0e-2
02:19:04 <roconnor> If I do show (fromRational (x%(10^n))::Double) will I always get a reasonable display of the number?
02:19:09 <roconnor> ? pi
02:19:12 <roconnor> > pi
02:19:13 <lambdabot>  3.141592653589793
02:19:51 <roconnor> > check \x n -> length (show (fromRational (x%(10^n))) <13
02:19:51 <lambdabot>  Parse error
02:19:54 <roconnor> @check \x n -> length (show (fromRational (x%(10^n))) <13
02:19:54 <lambdabot>  Parse error
02:20:01 <roconnor> @check \x n -> length (show (fromRational (x%(10^n)))) <13
02:20:02 <lambdabot>  Add a type signature
02:20:13 <roconnor> @check \x n -> length (show (fromRational (x%(10^n))::Double)) <13
02:20:13 <lambdabot>  Add a type signature
02:20:35 <roconnor> @check \x n -> length (show (fromRational (x%(10^(n::Int)))::Double)) <13
02:20:36 <lambdabot>  Exception: Prelude.^: negative exponent
02:20:45 <roconnor> @check \x n -> n >= 0 ==> length (show (fromRational (x%(10^(n::Int)))::Double)) <13
02:20:47 <lambdabot>  OK, passed 500 tests.
02:21:59 <hpaste>  bringert annotated "Could not deduce (Marshall a) from the context (Marshall a2)" with "One version that works" at http://hpaste.org/538#a1
02:24:04 <bringert> kolmodin: it's a bit hackish, but it should work
02:24:42 <kolmodin> it seems like the value I try to make up doesn't get the instances of the original value
02:25:52 <bringert> kolmodin: my thinking was that it's because of the order of alignmentOf and asTypeOf in the do block, that's why I switched the order in my version
02:26:20 <hpaste>  xpika pasted "writeIORef'ing in an IORefArray" at http://hpaste.org/539
02:26:24 <xpika> :)
02:26:31 <xpika> plz help
02:27:47 <kolmodin> brb, door bell
02:32:59 <bringert> xpika: try giving explicit type signatures to readIORefArray and writeIORefArray
02:33:41 <bringert> I think there is an error in writeIORefArray
02:33:46 <xpika> I think it infers it as ((->) Int) which i dont understand
02:34:03 <bringert> xpika: so write out the type you want writeIORefArray to have
02:34:29 <xpika> also, does >>= ensure pointfree the same as (.) ?
02:34:55 <bringert> ?
02:37:00 <Cale> writeIORef takes more than one parameter
02:37:32 <xpika> yep
02:37:51 <Cale> writeIORefArray array index value = readArray array index >>= (\r -> writeIORef r value)
02:38:00 <xpika> because i know not $ odd is non pointfree but not . odd is
02:38:42 <bringert> xpika: consider "not . (&&)"
02:38:53 <bringert> that doesn't do what you seem to think it does
02:39:30 <Cale> > (not . (&&)) True False
02:39:31 <lambdabot>  Couldn't match expected type `Bool'
02:39:51 <Cale> :t (not . (&&))
02:39:53 <lambdabot>     Couldn't match expected type `Bool'
02:39:54 <lambdabot>            against inferred type `Bool -> Bool'
02:40:01 <Cale> you can't even write that :)
02:40:08 <Cale> :t ((not .) . (&&))
02:40:10 <xpika> > ((not .) . (&&)) True False
02:40:12 <lambdabot> Bool -> Bool -> Bool
02:40:12 <lambdabot>  True
02:40:24 <xpika> beat me too it
02:43:25 <kolmodin> bringert: unGet isn't exported, but I got it to work
02:43:41 <kolmodin> thanks
02:44:22 <bringert> kolmodin: different unGet, I wrote it below the class declaration
02:44:24 <bringert> kolmodin: unGet :: B.Get a -> a
02:44:24 <bringert> unGet = undefined
02:44:34 <kolmodin> oh, right
02:44:56 <kolmodin> I do a 'runGet f undefined' now
02:45:00 <kolmodin> kind of hackish too :)
02:45:35 <bringert> kolmodin: oh, my comment about hackishness was about my code, not yours
02:47:54 <kolmodin> they're both hackish in my oppinion :)
02:48:30 <bringert> well, asTypeOf is in the prelude
02:48:58 <kolmodin> I ment my new code based on yours
02:49:03 <Cheery> http://en.wikibooks.org/w/index.php?title=Haskell/Concurrency&action=edit
02:49:05 <kolmodin> I inherited your hackishness
02:49:06 <lambdabot> http://tinyurl.com/2zb2ta
02:49:11 <matthew-_> @seen joelr1
02:49:11 <lambdabot> I haven't seen joelr1.
02:49:26 <Cheery> where could I find about concurrency?
02:50:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
02:50:36 <lambdabot> http://tinyurl.com/y2q5k2
02:51:29 <matthew-_> Cheery: there's also standard texts, eg J.Kramer and J.Magee's book on concurrency, C.A.R.Hoare's CSP, Milner's \pi etc
02:53:37 <goltrpoat> hmm.. is it just me, or does kdevelop not have block selection
02:54:21 <Cheery> can parsec only parse strings?
02:54:24 <goltrpoat> oh, ctrl-shift-b
02:56:54 <mahogny> Cheery, don't think so
03:02:41 <MarcWebe2> getM' is not a (visible) method of class `Get'   Why does ghc assume that getM should be a class of Get at all ?
03:03:04 <Cale> Parsec can parse any list of tokens, but many of the basic parsers only work with strings, so you need to create some basic parsers for your token type using the stuff in the Prim module.
03:04:31 <Cheery> I think that I'd like to combine IO and parsec.
03:04:35 <MarcWebe2> Cheery: If you need to parse different tokens.. I've extended parsec so you can customize errormessages.. (In some cases it just doesn't make sense to track line and col, eg command line parameters).. So if you are interested ..
03:05:13 <Cheery> MarcWebe2: sure.
03:07:42 <Cheery> is there ParserT or such?
03:11:57 <Cheery> I'm again thinking about using parser interactively to parse input.
03:12:04 <MarcWebe2> Cheery: I'm putting everything into a darcs repo...
03:12:37 <Cheery> it could be a quite simple thing if I'd understand the concurrency -module. :)
03:14:04 <Cheery> first you put the parser to infinite loop, and define 'action' -signals around the parser, then define the parser to block when there's not input.
03:16:06 <Cheery> then the hosting thread just provides that events goes to the parser -thread and asynchronously reads the signals coming from the parser thread.
03:17:11 <Cheery> if one would ensure yet that some branches from the parser thread terminates during certain time period, one could parse variety of things with it.
03:26:23 <MarcWebe2> Cheery: http://mawercer.de/marcweber/haskell/darcs/fparsec/ Argument.hs is an example on how to parse commandline arguments.. an test app can be found in argumentParserTest. But I haven't done to much serious testing yet.
03:26:25 <lambdabot> Title: Index of /marcweber/haskell/darcs/fparsec
03:30:47 <bringert> augustss: is there any special reason why there aren't PrintfArg instances for things like Int64?
03:31:24 <augustss> bringert: there was no Int64 when I wrote printf :)
03:31:29 <bringert> ah
03:31:45 <bringert> that would explain it
03:31:59 <augustss> printf needs some serious overhaul.  it's based on some old LML code from 85 or so.
03:37:08 <MarcWebe2> Cheery: If you end up getting something useful would you mind letting me know? I'm interested, too
03:37:57 <MarcWebe2> Wouldn't it be much more useful (and typesafe) to use a preprocessor to rewrite printf statements? (or template haskell which is only availible on ghc)
03:39:10 <ulfdoz> I fear the pure horror, when I see another printf implementation.
03:39:29 <titus> hi all
03:40:42 <hpaste>  titus pasted "How to write this as a fold?" at http://hpaste.org/540
03:41:48 <titus> I pasted a function to write a list of Ints representing a number in some base as a decimal number...
03:41:59 <titus> wondering how to write this as a fold...?
03:44:12 <EvilTerran> let base2dec b xs = foldr1 (uncurry (+) . ((b^) . length &&& base2dec b)) xs in base2dec 2 [1,0,1,1]
03:44:14 <ulfdoz> titus: Are you sure, that works for b < x?
03:44:15 <EvilTerran> > let base2dec b xs = foldr1 (uncurry (+) . ((b^) . length &&& base2dec b)) xs in base2dec 2 [1,0,1,1]
03:44:16 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
03:44:17 <lambdabot>       Expected...
03:44:20 <EvilTerran> hm
03:44:48 <ulfdoz> titus: err, sorry b > 10
03:45:02 <EvilTerran> oh, right, length xs, not length x. doh.
03:46:47 <titus> ulfdoz: I have only been thinking about binary -> dec to be honest
03:47:07 <titus> but I did want it to be general obviously...
03:47:25 <goltrpoat> hmm.. darcs-all in ghc head tries to get from http://darcs.haskell.org/ghc//packages/base/_darcs/inventory
03:47:27 <goltrpoat> which is a 404
03:48:09 <titus> I have always had a mental block about folds, and enjoyed Bernie Pope's bit in the last monad reader
03:48:18 <goltrpoat> anything in particular i should try changing the url to?
03:48:25 <jyp> goltrpoat: it should be http://darcs.haskell.org/packages/base/_darcs/inventory
03:48:45 <goltrpoat> ah thanks
03:48:59 <EvilTerran> let base2dec b xs = foldl1' (\n x -> x + b*n) xs in base2dec 2 [1,0,1,1]
03:49:04 <EvilTerran> argh
03:49:06 <EvilTerran> > let base2dec b xs = foldl1' (\n x -> x + b*n) xs in base2dec 2 [1,0,1,1]
03:49:08 <lambdabot>  11
03:49:36 <EvilTerran> @pl \n x -> x + b*n
03:49:37 <lambdabot> (+) . (b *)
03:49:59 <titus> ?src foldl1'
03:49:59 <lambdabot> Source not found. I've seen penguins that can type better than that.
03:50:14 <EvilTerran> ?ty foldl1'
03:50:16 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
03:50:47 <EvilTerran> titus, actually, it's probably better written as a foldl (...) 0 xs
03:50:58 <titus> foldl1 is for non-empty lists right? what is foldl1'?
03:51:12 <EvilTerran> maybe foldl' -- the prime means it's strict in its first argument
03:51:28 <titus> aah
03:51:30 <EvilTerran> so it averts a common case which'd otherwise cause the stack to get really big
03:51:39 <EvilTerran> (i'm not sure if it's appropriate here)
03:51:52 <EvilTerran> but, looking at it, that should definitely've been foldl (...) 0 xs
03:52:27 <titus> EvilTerran: thanks a lot, that's an elegant solution
03:52:54 <EvilTerran> you're welcome. problems i can understand are fun. ^^
03:53:21 * EvilTerran is away: food
03:55:02 <sabakas1> sorry for rejoining, couldn't figure the redirection for #haskel
04:10:43 <MarcWebe2> Having a function like this: test :: (A a, B a, Show a) => ....  Is there a way to introduce a synonym for (A a, B a, Show a) ? Is this done by creating a super class: class (A a, B a, Show a) => C a  ?
04:12:51 <MarcWebe2> Seems to work
04:15:17 <der_eq> MarcWebe2: How do you do that without undecidable instances?
04:17:49 <MarcWebe2> der_eq with the -fallow-undecidable-instances flag ;) works fine.
04:18:00 <der_eq> okay
04:31:33 <hpaste>  Marc Weber pasted "Why do have to tell ghc again that m is an instance of monad?" at http://hpaste.org/541
05:00:15 <ibid> MarcWebe2: sorry, the answer to the hpaste question is, "because that's how it is". as far as i can tell, it could be either way, and i can think of arguments for both sides
05:12:28 <dons> ?yow
05:12:29 <lambdabot> World War III?  No thanks!
05:28:52 <dons> ndm, around?
05:29:18 <tibbe> @src Network.HTTP
05:29:18 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:30:07 <Cale> @where http
05:30:08 <lambdabot> http://www.haskell.org/http/
05:30:24 <Cale> http://darcs.haskell.org/http/Network/HTTP.hs
05:32:26 <tibbe> ah
05:34:08 <fasta> Can I disable printing the "forall" part of a type?
05:34:16 <dons> yeah, turn off -fglasgow-exts
05:36:54 <fasta> dons: heh, but I want fglasgow-exts for other things, I guess.
05:37:12 <fasta> dons: e.g. functional dependencies.
05:39:46 <fasta> dons: That's not possible?
05:40:25 <dons> not that i know of. do tthe forall's bug you? :-)
05:41:52 <fasta> dons: It takes half of the screen and does not in any way make the type clearer
05:42:09 <matthew-_> bigger screen?
05:42:43 <fasta> matthew-_: no, foralls should die.
05:43:04 <dons> are you running in ghci or something?
05:43:12 <matthew-_> meh, it'd be fine if they used the unicode symbol
05:45:26 <fasta> dons: I run ghci in Emacs in Haskell-mode
05:45:30 <Cheery> do you know ways one could use to 'freeze' computation in haskell?
05:45:45 <fasta> Cheery: continuations?
05:45:55 <matthew-_> fasta: search for the string "forall" in the ghci source, replace it with the unicode symbol and recompile!
05:46:09 <fasta> matthew-_: Yes, I considered that.
05:46:18 <fasta> matthew-_: but it's probably slow
05:46:46 <matthew-_> mmm. or you could do some magic and put a sed in the pipe to emacs.
05:46:58 <matthew-_> somehow. I've no idea how to do that though
05:47:53 <fasta> matthew-_: that's a better idea
05:48:12 <matthew-_> if you can work out how to do that, I'd love to know
05:48:26 <matthew-_> whilst I use emacs, that kinda thing always seems utterly beyond me!
05:49:32 <tibbe> is Contrl-C throw as an exception?
05:49:38 <tibbe> s/throw/thrown
05:50:49 * EvilTerran is back (gone 01:57:27)
05:52:18 <gds> matthew-_: Something like this: http://groups.google.com/group/gnu.emacs.sources/msg/6588aefedcaa658e?oe=UTF-8&output=gplain  ?
05:52:20 <lambdabot> http://tinyurl.com/th2yf
05:52:56 <audreyt> what do I do with profile reports with cost centre names like "$f7" ?
05:52:59 <dons> Cheery: you mean, make the process sleep?
05:53:21 <audreyt> i.e., how do I uncover the actual site position of such centres? (GHC)
05:53:31 <dons> hmm.
05:53:37 <Cheery> dons: well, I want that I could make an algorithm incremental some way.
05:54:19 <Cheery> ie. store the computation which hadn't data to process.
05:54:20 <Igloo> audreyt: That sounds like a bug if it's autogenerated
05:54:37 <audreyt> Igloo: it's GHC head, running with simply +RTS -p
05:54:46 <audreyt> COST CENTRE                    MODULE               %time %alloc
05:54:46 <audreyt> $f7                            Pugs.AST.Eval         11.3    5.2
05:54:47 <audreyt> con2tag_VarCateg#              Pugs.Types             8.5    0.0
05:54:49 <audreyt> (etc)
05:54:58 <audreyt> the con2tag_ thing is also new to me.
05:54:58 <Cheery> I think continuations can help me, but I'm a bit confused.
05:55:06 <Igloo> audreyt: But the centres were all made with -auto-all?
05:55:17 <audreyt> correct
05:55:26 <audreyt> I wouldn't annotate my source with $f7 :)
05:55:26 <Igloo> audreyt: Looking at what called it and putting some SCCs in by hand might help
05:56:07 <audreyt> mm.
05:57:53 <gds> Is there a way of doing something like "data Set a = Set a", but restricting a to be in class Eq?
05:58:08 <gds> I'm probably being dense...
05:58:32 <audreyt> Igloo: also, GHC -head somehow fails compiling for me as of today; after stage1, -O2 on Data.List results in stack overflow; increasing the stack makes it appear to hang on Simplifier. not sure if it's known.
05:59:00 <audreyt> if I switch lib hc opts to -O0, all compiles fine.
05:59:02 <Igloo> audreyt: -O2 is broken as of Friday just over a week ago
05:59:11 <Igloo> -O should also be fine
05:59:19 <audreyt> but -O1 also fails
05:59:22 <audreyt> hm.
05:59:30 <audreyt> let me try again just to be sure
05:59:35 <Igloo> Oh, hmm
06:00:20 <audreyt> nope. stack overflow: use +RTS -K<size> to increase it
06:00:45 <audreyt> the relevant make:
06:00:49 <EvilTerran> gds: data Eq a => Set a = Set a
06:00:49 <audreyt> ../../compiler/ghc-inplace -H128m -O1 -fglasgow-exts -cpp -Iinclude -"#include" HsBase.h -funbox-strict-fields -package-name  base-2.0 -H128m -O1  -fgenerics    -c Data/List.hs -o Data/List.o  -ohi Data/List.hi
06:01:54 <audreyt> pity, because I really want the ghci speedups :)
06:03:48 <gds> EvilTerran: Yeah - I thought that too - but it doesn't seem to do what I want....
06:03:51 <gds> @paste
06:03:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:05:47 <matthew-_> gds: yep, I think that idea exactly
06:06:22 <hpaste>  gds pasted "restricting data Gds a to (Eq a) => a" at http://hpaste.org/542
06:06:32 <matthew-_> anyone here coming to the "fun in the afternoon" at notts on weds?
06:07:10 <gds> matthew-_: I think there's a full emacs mode for that kind of stuff now - but I can't quite remember the name... I'm googling ;)
06:07:20 <fasta> Does it matter whether I use recursion in my programs or whether I remember the recursion stack myself with an iterative algorithm? I suppose I only need to give the right flags to ghc s.t. it has more stack space, but otherwise it shouldn't make a difference.
06:08:32 <hpaste>  EvilTerran annotated "restricting data Gds a to (Eq a) => a" with "re: restricting data Gds a to (Eq a) => a" at http://hpaste.org/542#a1
06:08:58 <Saizan> gds: you can do that with gadt syntax and ghc 6.7, but you probably don't want to
06:09:47 <gds> EvilTerran: Ok - now now, say I want to do something like make my set into a Monad ;)
06:10:08 <dancor> > sort [3, 1, 2]
06:10:10 <lambdabot>  [1,2,3]
06:10:26 <dancor> > first sort ("hi", [3, 1, 2])
06:10:27 <lambdabot>  ("hi",[3,1,2])
06:10:28 <gds> So, I'd like to do instance Monad Gds - but I need to use "==" in the definition of bind...
06:10:39 <dancor> > second sort ("hi", [3, 1, 2])
06:10:41 <lambdabot>  ("hi",[1,2,3])
06:11:11 <gds> The problem is that I don't mention "a" in "instance Monad Gds", so I can't do "instance (Eq a) => ..."
06:12:47 <Cheery> now I understand continuations better.
06:12:54 <fasta> gds: Haskell has no associated types. So, unless you invent your own language or wait for version X of GHC, it doesn't work.
06:13:06 <EvilTerran> gds, can you annotate with what you _want_ to happen?
06:13:08 <gds> PIty - never mind :)
06:13:19 <nmessenger> I'm writing an interpreter for a small Forthlike.  Some of the commands are pure (State s a) and some are (StateT s IO a).
06:13:21 <EvilTerran> oh, ok. other people know better than me. :P
06:13:28 <nmessenger> Should I bother typing them differently or should I just use (StateT s IO a) for all of them?
06:13:30 <gds> lol - thanks though :)
06:13:43 <hpaste>  Saizan annotated "restricting data Gds a to (Eq a) => a" with "this works, but only with 6.7 " at http://hpaste.org/542#a2
06:14:03 <Cheery> continuations allow per-function control over such sequence: a (b (c (d (...
06:14:45 <gds> Saizan: Ah! Thankyou - I tried that with my 6.4 - but if it works in later versions, that's fantastic :)
06:15:16 <Cheery> turns to: d ... (c ... (b ... (a ...)))
06:15:40 <Cheery> which means that, f or example c can decide whether and how b and a affects the computation.
06:15:49 <Saizan> gds: discovered yesterday :)
06:15:55 <gds> Cool :)
06:16:03 <fasta> GADTs
06:16:15 <gds> @karma GADTs
06:16:16 <lambdabot> GADTs has a karma of 0
06:16:20 <fasta> Never used them
06:16:28 <fasta> But looks handy
06:16:32 <gds> GADTs++
06:16:35 <gds> @karma GADTs
06:16:35 <lambdabot> GADTs has a karma of 1
06:16:39 <Saizan> fasta: it's also a recent extension to gadts :)
06:16:42 <gds> There's the syntax...
06:16:45 <Cheery> @karma Cheery
06:16:46 <lambdabot> You have a karma of 0
06:18:03 <tibbe> how is StateT a monad plus?
06:18:16 <tibbe> @srcs Control.Monad.StateT.plus
06:18:17 <lambdabot> Source not found. I feel much better now.
06:18:19 * dcoutts is testing c2hs's new C parser on the linux kernel
06:18:58 <nmessenger> @source Control.Monad.State
06:18:58 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
06:19:16 <dcoutts> it uses struct initalisers like = { [0 ... n] = x }
06:19:42 <nmessenger> instance (MonadPlus m) => MonadPlus (StateT s m) where
06:19:42 <nmessenger> 	mzero       = StateT $ \_ -> mzero
06:19:42 <nmessenger> 	m `mplus` n = StateT $ \s -> runStateT m s `mplus` runStateT n s
06:20:23 <gds> Saizan++
06:20:50 <pejo> dcoutts, is that an array in a struct initialization?
06:20:55 <dons> dcoutts: want to run my new nobench haskell compiler benchmarks ?  :-)
06:20:57 <dons> ?where nobench
06:20:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/nobench
06:21:01 <dcoutts> pejo, yes
06:21:20 <tibbe> nmessenger, what does mzero in IO do?
06:21:21 <dons> should be as simple as typing 'make' in the top level, assuming you have ghc and hugs (comment out nhc if you don't have it)
06:21:31 <dcoutts> dons, so it's like nofib but ...  ?
06:21:48 <nmessenger> @src IO mzero
06:21:48 <lambdabot> mzero       = ioError (userError "mzero")
06:21:55 <dons> its nofib + the shootout, ported to the modern world. and it compares the same program on mulitple haskell compilers
06:22:02 <dons> i.e. ghci vs ghc vs nhc vs hugs so far
06:22:36 <dons> ghc is faster than I realised
06:22:48 <dons> dcoutts: how much slower than ghc do you reckon ghci is? on average/
06:22:56 <dcoutts> dons, 10x ?
06:23:02 <dons> i get between 40-80x
06:23:05 <dcoutts> wow
06:23:14 <dons> nothing gets close to ghc so far
06:23:23 <dons> ghci consistently beats nhc and hugs too
06:23:23 <dcoutts> dons, want a big alex + happy example ?
06:23:33 <dons> yeah, i'll solict more programs tomorrow
06:23:37 <dcoutts> ok
06:23:38 <dons> just running the full suite through now
06:23:51 <tibbe> could someone point me a tutorial for dealing with errors? I end up with code in StateT s IO with lots of "case" and "if:s"
06:24:04 <tibbe> nested cases that is
06:24:13 <dcoutts> dons, the c2hs C parser is quite big and stressful
06:24:23 <tibbe> in an imperative language I would do a return at those points
06:24:30 <dons> yeah. dcoutts, sounds good
06:24:32 <tibbe> I want something similar to shortcut the computation
06:24:35 <dons> is it h98-ish ?
06:24:36 <dcoutts> dons, though to be fair we'd have to turn off the ghc extensions for alex & happy
06:24:37 <Igloo> dons: What is nobench?
06:24:51 <pejo> tibbe, pattern guards might be a solution. Depends on how your code is formed.
06:25:00 <dons> Igloo: i just combined nofib and the shootout code, and rewrote the drivers to measure speed against different compilers
06:25:07 <dcoutts> dons, with alex and happy in h98 mode I think it's h98
06:25:10 <dons> Igloo: you should be able to darcs get that url and run it right now
06:25:27 <Igloo> Ah, right
06:25:31 <dons> some preliminary results, http://www.cse.unsw.edu.au/~dons/tmp/bench.results
06:25:38 <pejo> tibbe, http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/syntax-extns.html
06:25:40 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/yppt5j
06:25:41 <dons> but i've fixed a bunch of nhc and hugs errors since that run went through
06:25:50 <tibbe> pejo, I use that at the top level
06:25:51 <Cheery> there's something very important to learn about conversation on this channel: winning debate == lose, mutual satisfaction in debate == win.
06:26:24 <nmessenger> Cheery: No!  You're WRONG!
06:26:29 <Philippa> in this chan, you win the debate by convincing the other person
06:26:46 <Philippa> which tends to mean mutual satisfaction, 'cos pissing people off tends to mean they don't listen
06:27:12 <tibbe> is it wise to put a library and a binary in the same .cabal file?
06:27:19 <dons> yeah, it works.
06:27:22 <dons> you can do that.
06:27:29 <Igloo> It's probably not wise, though
06:27:53 <dons> @seen ndm
06:27:54 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 13h 3m 38s ago, and .
06:28:13 <Cheery> Philippa: what if you convince another something that is not true? Then everybody are pissed later.
06:28:36 <EvilTerran> folding a binary leaftree of n nodes is worst-case O(n), right?
06:28:43 <nmessenger> I have some (State s a) functions and some (StateT s IO a) functions, and I eventually want to compose them.  Should I just type them all as (StateT s IO a)?
06:28:45 <EvilTerran> s/nodes/leaves
06:29:06 <xerox> nmessenger: lift the State actions.
06:29:11 <Cheery> Philippa: I've seen such too many times. :) Many good ideas die this way.
06:29:13 <xerox> :t liftIO
06:29:23 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
06:29:27 <xerox> :t lift
06:29:37 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
06:29:44 <xerox> argh.
06:30:12 <nmessenger> @hoogle State s a -> StateT s m a
06:30:13 <xerox> I am not too sure.
06:30:14 <lambdabot> No matches, try a more general search
06:30:27 <emk> @seen syntaxfree
06:30:28 <lambdabot> I saw syntaxfree leaving #haskell-blah and #haskell 10h 18m 18s ago, and .
06:30:50 <xerox> nmessenger: no I think there is no such function.
06:30:51 <twanvl> nmessenger: You could use MonadState s m => m a
06:31:56 <Saizan> @instances MonadState
06:31:58 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
06:32:28 <Saizan> can't just have a polymorphic signature?
06:32:59 <Saizan> both s (State s) and s (StateT s m) are a MonadState afterall
06:33:21 <nmessenger> I've written it all as (st -> IO (a, st)) functions, and I'd like to rewrite it in the correct monads.  I haven't started yet.
06:33:40 <nmessenger> I'm still newish.
06:34:21 <Saizan> kk, i might sound a bit rude but that's not intended ^^
06:34:46 <nmessenger> :)  no rudeness detected on my end.
06:35:32 * nmessenger kicks his rudometer
06:37:22 <Saizan> so foo :: MonadState s m => a -> m b  when you don't need to use the IO monad should work, right?
06:37:30 <xerox> :t (undefined :: StateT s IO a) >>= (undefined :: \a -> State s b)
06:37:33 <lambdabot> parse error on input `\'
06:37:37 <xerox> :t (undefined :: StateT s IO a) >>= (undefined :: a -> State s b)
06:37:39 <lambdabot>     Couldn't match expected type `StateT s IO'
06:37:40 <lambdabot>            against inferred type `State s1'
06:38:17 <Saizan> mmmh
06:38:32 <nmessenger> well, I'd like to use a newtype to abstract my monad, so I'd have to use an existential for the polymorphic type, right?
06:38:54 <Saizan> well no, you must have at least one polimorphic, if you fix the type it won't work
06:39:37 <xerox> nmessenger: you own monad is either a newtype of of State s a or a newtype of StateT s m a, not both.
06:40:42 <nmessenger> I think I'll just use StateT s IO a then
06:40:58 <twanvl> :t let a :: StateT s IO a; a = undefined; b :: MonadState s m => a -> m b; b = undefined  in  a >>= b
06:41:01 <lambdabot> StateT s IO a; a = undefined; b :: MonadState s m => a -> m b; b = undefined  in  a >>= b :: forall s b. (MonadState s (StateT s IO)) => StateT s IO b
06:41:25 <dancor> i have M.map a (b, Int).  to find the key with the smalest Int there, i have to convert to a list and use minimumBy right?
06:42:27 <dancor> s/M.map/M.Map/
06:42:43 <EvilTerran> blah... trying to work out tight bounds in a functional language is harder than it looks
06:42:53 <EvilTerran> "er... is this value cached?"
06:45:33 <Saizan> dancor: you can also use foldWithKey i think
06:46:31 <pejo> EvilT, that must be due to lazy evaluation, not the functional language in itself.
06:48:19 <dancor> > minimumBy (compare `on` snd) [(1, 30), (2, 10), (3, 20)]
06:48:21 <lambdabot>   Not in scope: `on'
06:48:40 <nmessenger> @let on op f x y = f x `op` f y
06:48:43 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
06:49:14 <dons> let is broken for a little while
06:50:20 <tibbe_> @paste
06:50:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:53:07 <tibbe> @hoogle a -> m [a] -> m [a]
06:53:08 <lambdabot> No matches, try a more general search
06:53:11 <tibbe> mcons?
06:53:44 <nmessenger> @type liftM2 (:)
06:53:46 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
06:53:54 <nmessenger> not quite
06:54:40 <nmessenger> @type (\x -> liftM (x:))
06:54:42 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m [a] -> m [a]
06:54:48 <nmessenger> @pl (\x -> liftM (x:))
06:54:49 <lambdabot> fmap . (:)
06:59:06 <erider> good morning all
07:00:23 <dons> mm. it would be kinda fun to hook up the usb missle launcher to an unsafePerformIO
07:00:45 <dons> to really illustrate how the sequencing is all busted up, and missles will fly when you least expect them
07:01:18 <nmessenger> @remember dons mm. It would be kinda fun to hook up the usb missle launcher to an unsafePerformIO.
07:01:19 <lambdabot> Done.
07:02:39 <dons> ndm, there's something very wrong about a haskell compiler that does this on building, svn co http://svn.python.org/projects/python/trunk/Modules/_ctypes/ depends/ctypes
07:02:39 <lambdabot> Title: Revision 53817: /python/trunk/Modules/_ctypes
07:04:18 <xerox> :o
07:05:27 <dcoutts> dons, do yhc have a python implementation of their byte code interpreter or is the python used for the build infrastructure?
07:05:39 <dcoutts> I suppose really I should ask ndm
07:05:41 <dons> both, i think.
07:05:45 <tibbe> @pl \x -> \(xs,y) -> (x:xs,y)
07:05:45 <lambdabot> (`ap` snd) . (. fst) . ((,) .) . (:)
07:05:50 <tibbe> oh yes!
07:05:53 <tibbe> much clearer
07:05:59 * dcoutts goes back to parsing the Linux kernel
07:06:09 <dons> but the build infraststructure is getting kinda wacky in yhc.. :/
07:06:20 <nmessenger> @type \x -> first (x:)
07:06:22 <lambdabot> forall a d. a -> ([a], d) -> ([a], d)
07:06:31 <dons> checking out stuff over the network is NOT OK while building a compiler.
07:06:34 <nmessenger> @pl \x -> first (x:)
07:06:35 <lambdabot> first . (:)
07:06:49 <dcoutts> dons, aye, it's not ok for our ebuilds either, we noticed that.
07:07:01 <EvilTerran> ?ty first
07:07:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:07:08 <nmessenger> @src (->) first
07:07:09 <lambdabot> first f = f *** id
07:07:23 <nmessenger> @src (->) (***)
07:07:24 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
07:07:25 <dons> oh, are there prebuilt binaries for x86/linux yhc somwhere?
07:07:37 <dcoutts> dons, no idea
07:08:43 <nmessenger> first takes a function (a -> b) and applies it the the fst of a pair ((a,t) -> (b,t))
07:10:06 <nmessenger> (well actually it takes an Arrow t a b, but (->) is an easy and familiar Arrow)
07:12:04 <nmessenger> > (first . (:)) 1 ([2,3], 4)
07:12:05 <lambdabot>  ([1,2,3],4)
07:18:28 <dons> ?uptime
07:18:28 <lambdabot> uptime: 2d 10h 3m 32s, longest uptime: 2d 17h 27m 21s
07:18:30 <dons> ?users
07:18:30 <lambdabot> Maximum users seen in #haskell: 316, currently: 281 (88.9%), active: 35 (12.5%)
07:21:53 <EvilTerran> is there a canonical translation of list comprehensions into maps?
07:22:08 <dcoutts> EvilTerran, yep, in the H98 report
07:22:14 <dcoutts> and it's not map, it's concatMap
07:22:18 <nmessenger> @where report
07:22:19 <lambdabot> http://www.haskell.org/onlinereport/
07:22:26 <EvilTerran> [f x | x <- xs] is clearly map f xs, but i'm having trouble figuring out with multiple <-s
07:22:27 <EvilTerran> ah, ok
07:22:42 <nmessenger> http://www.haskell.org/onlinereport/exps.html#sect3.11
07:22:43 <lambdabot> Title: The Haskell 98 Report: Expressions
07:22:52 <dcoutts> EvilTerran, I've got a simple implementation of the transformation somewhere
07:23:17 <dcoutts> but you can do it by hand easily by following the rules in the report
07:23:37 <EvilTerran> thanks
07:23:39 <xerox> EvilTerran: cartesian product.
07:24:23 <xerox> > let xs = [1..3] in liftM3 (,,) xs xs xs -- [(x,y,z) | x <- xs, y <- xs, z <- xs]
07:24:24 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2,...
07:24:32 <EvilTerran> I just realised that my horrible O(...) wasn't actually that bad, because i had a [...| x <- xs, y <- ys], with ys not dependent on x (so presumably only evaluated once)
07:25:13 <EvilTerran> and that's equivalent to [...| (x,y) <- cartProd xs ys] in that case
07:25:40 <EvilTerran> > (,) `ap` [1,2] `ap` [3,4]
07:25:41 <lambdabot>  Couldn't match expected type `a -> b'
07:25:50 <EvilTerran> ?ty ap
07:25:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:25:56 <xerox> > return (,) `ap` [1,2] `ap` [3,4]
07:25:57 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
07:26:03 <EvilTerran> ahh
07:26:17 <nmessenger> > (,) `fmap` [1,2] `ap` [3,4]
07:26:19 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
07:26:31 <EvilTerran> even better
07:26:44 <nmessenger> > liftM2 (,) [1,2] [3,4] -- :P
07:26:46 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
07:26:56 * EvilTerran notes a sort of echo effect going on there... "fmap...ap...ap...ap..."
07:27:13 <nmessenger> heh
07:27:51 <Botje> be lglad it's not fap fap fap
07:27:51 <Botje> :p
07:28:01 * nmessenger slaps Botje upside da head with a hairy goldfish
07:28:12 <Botje> mmm, breakfast.
07:29:12 <Botje> ?t (,,,)
07:29:13 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:29:21 <Botje> :t (,,,)
07:29:24 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
07:29:36 <Botje> hurray for commas
07:29:39 <fasta> How can I hide every function that's in Data.List from Prelude in an import?
07:30:03 <Botje> you could qualify it.
07:30:04 <nmessenger> I think you'll have to "hiding (...)" each one
07:30:21 <fasta> That's the trivial solution.
07:30:38 <fasta> I don't like the module system if that's the only way to do it.
07:30:45 <EvilTerran> could you import Data.List () ?
07:30:46 <nmessenger> I usually import the non-Prelude functions from Data.List
07:31:16 <fasta> EvilTerran: what would that accomplish?
07:31:25 <Botje> :t let but = ((not .) . flip elem) in but[1..5]
07:31:28 <lambdabot> forall a. (Num a, Enum a) => a -> Bool
07:31:34 <fasta> EvilTerran: AFAIK, that imports nothing from Data.List
07:31:36 <EvilTerran> hang on... are they imported or re-implemented in the prelude?
07:31:43 <fasta> EvilTerran: imported, probably
07:32:16 <EvilTerran> in which case, i thought that might hide them again. just a thought.
07:32:23 <EvilTerran> probably wrong.
07:33:07 <nmessenger> It'd be nice if there were an "if I get a name clash between these two modules, prefer module A" feature.
07:34:53 <EvilTerran> why do you want to exclude the prelude list functions, anyway?
07:38:00 <fasta> EvilTerran: the names clash with names I want to use.
07:47:30 <dcoutts> so far so good, no parse failures while parsing linux (using default configuration)
07:49:33 <mwc> fasta, isn't it possible to import the prelude qualified?
07:50:04 <fasta> mwc: how does that solve the problem?
07:50:23 <fasta> mwc: it doesn't, unless I am widely mistaken.
07:50:36 <fasta> wildly*
07:50:59 <mwc> fasta, well, the prelude is only implicitly imported iff you don't explicitly import it
07:51:10 <mwc> so you could do import Prelude hiding (length)
07:51:19 <mwc> if you want to use Length for your own purposes
07:51:37 <fasta> mwc: That's not my problem.
07:51:47 <fasta> mwc: never mind it
07:51:54 <mwc> Sounded like you wanted to use names from the prelude
07:52:06 <mwc> <fasta> EvilTerran: the names clash with names I want to use.
07:52:26 <fasta> mwc: I want to use the union of Data.List and Prelude without some names.
07:52:38 <fasta> mwc: that idea cannot be expressed without writing a code generator
07:52:39 <dons> dcoutts: good sign!
07:52:54 <mwc> dcoutts, c2hs stress testing?
07:53:04 <dcoutts> yep
07:53:04 <fasta> mwc: cannot meaning without typing out every identifier by hand
07:54:46 <mwc> well that's impressive then
07:56:46 <dcoutts> yay, it finished, 2 parse failures
07:56:59 <dcoutts> both the same issue I think
07:59:03 <dcoutts> yep, same issue
07:59:25 <dcoutts> redeclaration of typedef'ed names in function parameter lists
08:01:18 <dcoutts> typedef char foo; void bar (int foo) { foo = foo + 1; }
08:02:23 <dons> Igloo: http://urchin.earth.li/~ian/cabal/base64-string/
08:02:28 <dons> 404?
08:02:44 <allbery_b> ah, C.  a language only K&R could love :)
08:03:12 <dcoutts> allbery_b, yep, though some non-K&R extensions are even worse :-)
08:03:25 * dcoutts curses __attribute__
08:05:02 * allbery_b mostly assumes any such extensions are poorly thought out anyway
08:09:40 <kolmodin> dcoutts: still fighting __attribute__, must be a real hard one
08:09:58 <dcoutts> kolmodin, I'm currently ignoring them all in the lexer
08:10:08 <kolmodin> heh, ok
08:11:22 <dcoutts> so the parser never sees them at all
08:11:46 <dcoutts> but that means we can't get the info out of them like packing/alignment attributes
08:12:08 <kolmodin> right. but you{-or anyone else-} can always come back to it
08:12:24 <kolmodin> does the other stuff work?
08:12:49 <kolmodin> I mean, after having cursed __attribute__ for a week, it might be time to move on before you throw out your computer throguh the window
08:12:53 <xerox> ?hoogle glob
08:12:54 <lambdabot> Language.Haskell.TH.global :: Name -> ExpQ
08:12:54 <lambdabot> System.Win32.Mem.globalAlloc :: GlobalAllocFlags -> DWORD -> IO HGLOBAL
08:12:54 <lambdabot> System.Win32.Mem.globalFlags :: HGLOBAL -> IO GlobalAllocFlags
08:12:55 <Igloo> dons: Yeah, I haven't made the latest webpages yet, but I also don't have anything interesting to put there
08:13:18 <hpaste>  paolino pasted "CPS parsing" at http://hpaste.org/544
08:13:53 <Igloo> dons: I should possibly start deleting all the homepage fields, or point them at hackage, or something
08:14:21 <paolino> hi, is it possible to use combinators or anyway factor up the pattern there in my paste?
08:15:44 <Cale> paolino: use a list comprehension
08:16:01 <nmessenger> you could factor the reads destruction into a function.
08:16:15 <dcoutts> kolmodin, yeah, we can come back to the attributes, but yeah having decided to ignore them I'm not so frustrated now. Being able to parse all of linux & glibc will be quite satisfying :-)
08:16:48 <dcoutts> kolmodin, actually I want to figure out how to make ebuild use my cc-wrapper for gcc so I can test it with emerge system.
08:16:58 <Cale> er, hmm...
08:17:04 <Cale> actually...
08:17:13 <kolmodin> dcoutts: that would be really cool
08:17:22 <nmessenger> maybeRead x = case reads x of {((y,_):_) -> Just y; _ -> Nothing} -- then use the maybe function to CPS
08:17:28 <dcoutts> kolmodin, it's probably something one can do in ebuild.sh
08:17:53 <Cale> case (vs1,vs2) of (x:xs, ys) -> ...; ([], y:ys) -> ...
08:18:00 <kolmodin> dcoutts: perhaps you could introduce a wrapper around gcc, like distcc does
08:18:11 <dcoutts> kolmodin, that's exactly what I do
08:18:34 <Cale> You don't have to have two lets like that either, you can combine them into a single let with two declarations.
08:18:58 <dcoutts> kolmodin, :
08:18:59 <dcoutts>   args <- getArgs
08:18:59 <dcoutts>   gccExitcode <- rawSystem "gcc" args
08:19:08 <kolmodin> dcoutts: nice. so the wrapper finds input files, runs your parser on them and log, then run gcc
08:19:12 <dcoutts> then I try and grok the args and run the parser and log the results
08:19:30 <dcoutts> so I always just run gcc, even if I can't grok the args
08:19:40 <kolmodin> a gcc command line parser might be useful too :)
08:19:54 <kolmodin> that would make it easier to implement wrappers :D
08:20:13 <paolino> where do I force the types ?
08:20:20 <kolmodin> for every argument, check if there is a file with that name, parse.. :D
08:20:25 <dcoutts> kolmodin, I look for the presence of a .c file in the args, and I strip out "-o foo.o"
08:20:38 <hpaste>  Cale annotated "CPS parsing" with "another option" at http://hpaste.org/544#a1
08:20:38 <kolmodin> right
08:20:42 <dcoutts> and I ignore it if it's got -E in the args
08:20:50 <kolmodin> right
08:20:56 <nmessenger> case ((reads :: ReadS Int1) t, (reads :: ReadS Int2) t) of ...
08:21:25 <Cale> Indeed
08:22:38 <paolino> mmh so if I put up another instance of (Summa a,Show a) I have to make a big refactoring...
08:22:55 <hpaste>  Cale annotated "CPS parsing" with "collapse let" at http://hpaste.org/544#a2
08:23:18 <Cale> I'm not completely sure if it's more readable like that.
08:24:19 <paolino> is there any way I can make that tuple a list ?
08:24:34 <Cale> The tricky bit is the fact that fn is being used polymorphically.
08:25:25 <nmessenger> which tuple?  The one in the case?  It's not worth it.
08:25:45 <Cale> why are you using reads?
08:25:45 <paolino> that's because a can't escape parse , right ?
08:25:59 <Cale> Oh, right, duh
08:26:05 <paolino> Cale , because I've never done any parsing :)
08:26:30 <Cale> What are Int1 and Int2 ?
08:26:45 <paolino> instances of Summa
08:27:20 <paolino> fn must made up of methods of Summa
08:27:47 <Cale> Well, yeah, that's what that rank-2 type means
08:28:43 <benja_> ?hoogle Maybe (Maybe a) -> Maybe a
08:28:44 <lambdabot> No matches, try a more general search
08:28:47 <paolino> nmessanger, but the there is a way ?
08:29:10 <nmessenger> @type join -- benja_
08:29:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:29:21 <benja_> ?hoogle join
08:29:22 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
08:29:22 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
08:29:22 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
08:29:27 <benja_> ok, thanks
08:30:00 <Cale> paolino: You can't make a list like [vs1,vs2]
08:30:30 <nmessenger> paolino: you wouldn't want to anyway.  The tuple is just there so you can pattern-match both terms.
08:30:36 <Cale> paolino: You could do something nutty like creating an existential type for Summa, projecting both vs1 and vs2 into it and sticking those in a list.
08:30:53 <nmessenger> ...but that would be nutty.
08:30:54 <Cale> It wouldn't buy you anything though.
08:32:17 <Cale> This code could be written in a simpler-to-refactor way using a proper parsing library.
08:32:48 <bos> @pl \(a,b)->a==x
08:32:49 <lambdabot> (x ==) . fst
08:33:34 <Cale> Actually, an existential type *might* buy you something depending on what Summa is.
08:33:54 <Cale> (In terms of the simplicity of handling more cases in the future)
08:34:34 <paolino> Cale, I'm looking a way for reading a value paired with its type from a config file, promised I will use only methods of its class on it
08:35:01 <Cale> Why won't you know its type?
08:35:18 <paolino> I know its class
08:35:31 <Cale> Will you know that it's at least a finite selection of types?
08:35:51 <paolino> well yes, I compiled them to work
08:35:55 <Cale> In that case, the standard thing to do is to create a union type for the selection of types that you offer.
08:36:30 <paolino> but each type implement the same methods in different ways
08:36:49 <Cale> So that when you parse values, they'll get tagged with constructors letting the functions you pass them to know which sort of thing they are.
08:37:16 <Cale> Doing this at the class level is something which is probably possible but awkward.
08:37:46 <Cale> Generally, types are things which you know *at compile time*.
08:38:01 <benja_> paolino: are you on GHC?
08:38:27 <paolino> my algorithm has pluggable politics, and user must be able to choose them via a config file, to test them without recompiling
08:38:32 <Cale> If you're reading things from a file, and they could be more than one "type", then you don't know their type at compile time unless you create a type that includes them all.
08:38:46 <paolino> benja_: yes
08:39:10 <Cale> You could use an existential type for Summa
08:39:14 <Cale> rather than a union
08:39:23 * benja_ wonders whether Data.Dynamic could be used
08:39:36 <Cale> Or yeah, maybe Data.Dynamic.
08:39:40 <paolino> existentials for a Class
08:39:42 <paolino> ?
08:39:46 <dmhouse> Does using Data.{Dynamic,Typeable,etc.} feel like a hack to anyone else?
08:39:50 <Cale> Yeah, like:
08:40:01 <dmhouse> Perhaps it's just because I've never used them fully.
08:40:17 <Cale> data Summa = forall a. (Summa a) => S a
08:40:25 <nmessenger> dmhouse: not really, it's just a (value, TypeRep) pair.  Nothing worse than runtime typing in an other language.
08:40:30 <Cale> Or with GADT syntax:
08:40:34 <Cale> data Summa where
08:40:38 <benja_> ...hmm, no, TypeRep doesn't even implement Read, just Show
08:40:47 <Cale>    (Summa a) => a -> Summa
08:40:52 <Cale> er
08:40:55 <Cale>    S :: (Summa a) => a -> Summa
08:40:59 <dmhouse> nmessenger: yep, but other languages don't have such advanced type systems.
08:41:08 <nmessenger> dmhouse:  :D
08:41:16 <Cale> But the usefulness of that depends on what you want to do with those values
08:41:30 <dmhouse> Cale: wouldn't it be great to see some sugar that essentially defined an existential box for every class we define?
08:41:35 <Cale> What are the types of the methods of Summa?
08:41:56 <Cale> dmhouse: sorta :)
08:42:23 <nmessenger> if I remember correctly Summa is Monoid, Int1 is (0,+) and Int2 is (1,*)
08:42:42 <paolino> mmhh. Cale this is not the real code :)
08:42:59 <Cale> For one, sometimes it's impossible, and secondly, you want it to be explicit, because it's an irreversible operation that throws away information. Other than that, it would be nice. :)
08:43:07 <paolino> You know the real code !
08:43:16 <Cale> (I mean the application of the existential constructor had better be explicit)
08:43:56 <Cale> paolino: what was the URL to your code again, and which class is this?
08:44:07 <Cale> Doing this with something like Monoid won't work.
08:44:17 <Cale> If Summa is anything like Monoid.
08:44:29 <Cale> You really just want a union type.
08:44:48 <paolino> catenova.org/~paolino/hancl/Net/Net.hs
08:45:18 <Cale> okay, which class, I don't see Summa :)
08:45:35 <paolino> classes to be parsed are Collect, Refine, Tag, Schedulig
08:45:50 <Cale> Scheduler won't work.
08:46:19 <Cale> Well, it sort of will, but probably not the way you want it to.
08:46:35 <Cale> The others would be okay having existential instances.
08:48:25 <paolino> what is wrong with Scheduling
08:48:35 <Cale> mediate has to take values of type h
08:48:43 <Cale> (well [h])
08:49:12 <Cale> and so when you go to write the existential instance, you'll be getting a list of existential boxes of things which could be any instance of Scheduler
08:49:21 <Cale> and there's no downcasting.
08:50:07 <paolino> also Tag is wrong then
08:50:22 <Cale> tag would be okay
08:50:33 <Cale> because you can unbox the thing, and apply its tag function
08:50:44 <Cale> since you know it's in the Tag class
08:50:57 <Cale> But there's only one of it :)
08:51:29 <Cale> It's when you have to combine things that it becomes an issue.
08:51:57 <Cale> Like, suppose I had some class Add a where (+) :: a -> a -> a
08:51:59 <nmessenger> @get-oleg
08:51:59 <lambdabot> Unknown command, try @list
08:52:09 <Cale> then I go to make an existential type for the class:
08:52:26 <Cale> data Addable = forall a. (Add a) => Addable a
08:52:31 <Cale> that's all fine
08:52:46 <Cale> only once I apply the Addable tag to a value, it becomes useless.
08:52:57 <Cale> I'd like to write:
08:53:01 <Cale> instance Add Addable where
08:53:15 <Cale>    (Addable x) + (Addable y) = Addable (x + y)
08:53:30 <Cale> but I could only do that if I knew that x and y had the *same* type
08:53:35 <Cale> and I don't know that
08:54:00 <Cale> all I know is that they're individually some types which are instances of Addable
08:54:07 <Cale> I could write something like:
08:54:17 <paolino> I refactor Scheduling
08:54:22 <Cale> double (Addable x) = Addable (x + x)
08:54:36 <Cale> Don't bother!
08:54:47 <Cale> What you really should do is something completely different
08:54:57 <Cale> I'm just explaining why existentials aren't the solution here.
08:55:06 <paolino> ah
08:55:21 * paolino undoes
08:55:23 <Cale> You create a type which is a union of all the types of values which you could possibly get from the config file.
08:55:44 <paolino> wait
08:55:45 <Cale> and then use the constructors of that type to guide what you do with the values later on.
08:56:10 <paolino> Net/Collectors.hs
08:56:13 <dmhouse> paolino: that means data MyUnion = F Foo | B Bar | Z Baz, where Foo, Bar, Baz are the types you might get from your config file.
08:56:30 <paolino> 3 politcs
08:57:04 <paolino> instances of Collect
08:57:32 <dmhouse> The advantage of using a union is that your constructors essentially become TypeReps. I.e., if you see "F <something>" in the config file, you know <something> :: Foo.
08:58:23 <paolino> user must be able to write
08:58:24 <paolino> KPath (4,8) --or
08:58:24 <paolino> KRPath [2,3,3] --or
08:58:24 <paolino> RandomCollector 5
08:58:29 <paolino> in the config file
08:58:49 <dmhouse> What are the types?
08:59:05 <benja_> data MyUnion = KPath ... | KRPath ... | RandomCollector ...
08:59:50 <Saizan> but even with MyUnion you need rank-2 polymorphism, right?
09:00:54 * paolino goes fixing the water pipe for the cows, be back in 5 minutes
09:00:58 <dmhouse> Saizan: why?
09:01:57 <Cale> Saizan: nope
09:02:12 <Saizan> ah, you can make MyUnion an instance of Collector?
09:02:32 <Cale> Sure, or whatever is needed :)
09:02:35 <Eighty> is there a way to catch undefined? so the program needn't necessarily end when undefined is reached?
09:02:53 <Cale> Eighty: from the IO monad, and it's a little tricky
09:03:10 <Eighty> tricky how?
09:03:12 <Cale> Eighty: it's a good question to ask yourself whether you could be representing failure explicitly
09:03:14 * Saizan sses lot of pattern mathing
09:03:39 <Cheery> Are monoids allowed to be self-referencing?
09:03:48 <Cale> Eighty: you have to get the error to happen inside a particular IO call, which means that you have to use Control.Exception.evaluate to sequence the evaluation of the value
09:03:50 <Cheery> like:
09:04:00 <Cale> (specifically, inside of the call to catch)
09:04:12 <Cheery> Funnylist = 1:2:3:Funnylist
09:04:31 <Cale> > let funnylist = 1 : 2 : 3 : funnylist in funnylist
09:04:33 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
09:04:56 <Cheery> :) So they are allowed to be.
09:05:01 <Cale> Cheery: absolutely :)
09:05:13 <benja_> Cheery: in general, why not? but with lists, mappend where the lhs is a infinite list will of course loop forever
09:05:19 <Cale> That's not monoids though, that's recursive data types in general.
09:05:33 <Eighty> Cale: okay. how do i catch it then?
09:06:08 <benja_> Cheery: if you have data Tree a = Branch (Tree a) (Tree a) | Leaf a
09:06:17 <Cale> Eighty: What's the type of the thing which might be undefined? Is there a data structure which might have some undefined values in it that you want to catch, or is it just a single thing?
09:06:53 <benja_> or more simply, Tree = Branch Tree Tree | Nil,
09:07:19 <benja_> and instance Monoid Tree where { mempty = Nil, mappend l r = Branch l r }
09:07:25 <benja_> then there is no problem with looping
09:07:39 <Eighty> Cale: i'm using error "you can't do that, sillypants!" in lots of places in pure functions, and when i later compose it into a program, i'd like to be able to catch undefined instead of just having the program exit abruptly
09:07:44 <Cale> catch (evaluate x) (\e -> ...)
09:08:04 <Cale> Eighty: if they're your own calls, you'd probably be better off using Either
09:08:09 <Cale> Either String a
09:08:18 <benja_> ...hmm, of course you would have to process the trees in a way that (a `Branch` b) `Branch` c is equivalent to a `Branch` (b `Branch` c)...
09:08:22 <Cale> Left "You can't do that sillypants!"
09:08:24 <Cale> Right 5
09:09:00 <Cale> But sure, if you want to catch it in IO, you use catch with evaluate like that.
09:09:19 <Eighty> cale: yeah, i know, but i'd rather not clutter down every single function to return a datatype like that
09:09:24 <Cale> Note that you have to apply evaluate to *the specific value* you want to check for undefined.
09:09:32 <Cheery> I think I like this thing.
09:09:37 <kaol> is Left always error?
09:09:51 <Cale> kaol: by convention, when one of them is an error, yes
09:09:53 <Eighty> Cale: what do you mean by "the specific value"?
09:09:55 <nmessenger> kaol: it's fail in its Monad instance
09:10:03 <Cheery> I can represent my state machine as simple transition rules to another statemachines.
09:10:11 <Cale> Eighty: If you apply it to a list, for instance, it won't catch errors in the elements.
09:10:15 <Cheery> S1 = [Transition C1 S2]
09:10:28 <Saizan> and it's also how (Error e) => MonadError (Either e) is defined
09:10:48 <Cale> nmessenger: sssh, we pretend that fail doesn't exist around here :)
09:10:54 <nmessenger> heh
09:10:56 <Eighty> Cale: hm, doesn't [undefined] reduce to undefined?
09:11:04 <Cale> Eighty: no, it's a different value
09:11:08 <allbery_b> only if something looks inside the list
09:11:10 <xerox> > length [undefined]
09:11:11 <Cale> > length [undefined]
09:11:12 <lambdabot>  1
09:11:13 <lambdabot>  1
09:11:15 <Cale> haha
09:11:18 <xerox> ;)
09:11:23 <Cale> > length undefined
09:11:25 <lambdabot>  Undefined
09:11:40 <Eighty> yeah, but when the program looks at the undefined value
09:11:48 <Cheery> > length [undefined, undefined]
09:11:50 <lambdabot>  2
09:11:51 <Cale> [undefined] = (:) undefined []
09:11:52 <xerox> > head [undefined]
09:11:53 <lambdabot>  Undefined
09:12:11 <allbery_b> if your program evaluator is script, then sure
09:12:15 <nmessenger> @src length
09:12:15 <allbery_b> er, is strict
09:12:15 <lambdabot> Source not found. Wrong!  You cheating scum!
09:12:15 <Cale> You can do:  foldr seq () xs
09:12:27 <Cale> to force lists with undefined values in them to be undefined
09:12:51 <Eighty> okay
09:12:54 <Cheery> thought with such S1 = [Transition C1 S2] I don't do much. :/
09:12:55 <Cale> > length (foldr seq xs xs)
09:12:57 <lambdabot>   Not in scope: `xs'
09:13:37 <Cale> > let strictList xs = foldr seq xs xs in length (strictList [undefined])
09:13:38 <nmessenger> > foldr seq () [1..5]
09:13:39 <lambdabot>  Undefined
09:13:39 <lambdabot>  ()
09:13:55 <benja_> note however, that if 'xs' evaluates to 'Not in scope: `xs'', then so does '[xs]' ;)
09:14:04 <Cale> benja_: hehe
09:14:11 <dancor> strict scoping
09:14:13 * paolino back
09:14:15 <Cale> Of course, it doesn't *evaluate* to that :)
09:14:43 <dancor> Cale: open your mind [mind]
09:14:59 <Cheery> It requires to be a combination of function and transition rules.
09:15:01 <Cale> The compiler evaluates to that when applied to your program.
09:16:45 <Cheery> S1 = Rule (\i l -> i) [Transition C1 S2]
09:16:48 <benja_> that's the problem with compiled languages: 'Not in scope' isn't first-class
09:17:18 <benja_> you could imagine a language where you could pass it around and catch it in IO :)
09:17:43 <Cale> I can imagine not using such a language out of principle.
09:17:49 <nmessenger> you just have to move the metaprogram into your program, i.e. have a runtime compiler.
09:17:52 <Saizan> well, i want the compiler to catch my typo :)
09:18:33 <nmessenger> then you get a strange loop c/o GEB
09:20:21 <paolino> data Collectors = KPath | KRPath | RandomCollector, right ?
09:22:07 <Saizan> paolino: those are yet the contructors of the "real" types?
09:22:12 <paolino> eh
09:22:25 <nmessenger> data Collectors = KPath TypeWhichImplementsKPath | KRPath KRPathType etc.
09:23:30 * allbery_b observes that in perl you can "use strict" and BEGIN { $SIG{__DIE__} = ... } to intercept undeclared variables.
09:24:16 <allbery_b> (I suspect you can't do much about it at comple time though; only a subset of perl may be functional at the time)
09:24:19 <paolino> nmessenger: TypeWhich.... is ?
09:25:24 <nmessenger> don't you know?  It's the type in the Collector class you want to use for KPath.
09:25:47 <nmessenger> Is it just called KPath?
09:26:00 * paolino start crying
09:26:31 <Saizan> heh :D
09:27:30 <Saizan> paolino, if you have something like KPathtype = KPath ... then you write data Collectors = ColKPath KPathtype | ...
09:27:56 <Saizan> KPathtype could possibly be just KPath
09:28:37 <allbery_b> paolino: I think you're not describing what you're trying to do sufficiently.  or possibly have not thought it through sufficiently
09:29:24 <Saizan> allbery_b: have you followed the previous discussion? like 30 minutes ago
09:29:37 <nmessenger> I notice in Collectors.hs you have "newtype KPath = KPath {unKPath :: (Int,Int)}", so Collectors should look like "data Collectors = KP KPath | KRP KRPath ..."
09:29:57 <allbery_b> I saw it, yes.  but there does seem to be a lot of confusion currently :)
09:30:06 <paolino> ok so data Collectors = Collectors KPath | Collectors KRPath| Collectors ...
09:30:12 <paolino> ah
09:30:14 <Saizan> no
09:30:24 <Saizan> you need a different contructor for each type
09:30:25 <nmessenger> close, the constructor must have different names
09:31:04 <paolino> bien
09:32:00 <nmessenger> so (KPath (1,5)) has type KPath and (KP (KPath (1,5))) has type Collectors
09:32:49 <paolino> then what the user should write in the config file ?
09:33:08 <Saizan> that depends on the Read instance of Collectors
09:33:39 <paolino> deriving Read ?
09:33:55 <nmessenger> however you want to parse it, if you just derive Read, then the first would require (reads :: ReadS KPath) the second (reads :: ReadS Collectors)
09:34:18 <Saizan> KP (KPath (1,5)) i suspect
09:34:53 <paolino> ok, how my library intercepts the right collect method ?
09:35:46 <gaal> Hi! Recent snapshot builds of GHC-6.7 seem broken. E.g. wget claims this to be a 16mb d/l: http://www.haskell.org/ghc/dist/current/dist/ghc-6.7.20070216-i386-unknown-linux.tar.bz2
09:35:49 <lambdabot> http://tinyurl.com/2g6tlu
09:36:12 <gaal> and the one from the following day yields a broken bzip2 file
09:36:18 <Saizan> well you can make Collectors an instance of Collector that just route the method to the type inside it
09:36:21 <nmessenger> you might do: instance Collector Collectors where collect x (KP kp) = collect x kp; collect x (KRP krp) = collect x krp; ...
09:36:39 <allbery_b> gaal: ghc 6.7 -fvia-C is known to be broken currently
09:37:02 <xerox> Hiya gaal.
09:37:16 <allbery_b> see ticket #1151 on ghc trac
09:37:16 <gaal> allbery_b: thanks, I mean the files themselves are broken
09:37:19 <gaal> xerox: hi!
09:37:21 <allbery_b> oh
09:37:53 * allbery_b doesn't know about snapshots, he builds from darcs
09:38:06 <allbery_b> and there's no snnaps for ppc anyway
09:38:46 <paolino> uhm, so when I add an instance I must add a line there, a type to the union with a constructor, and don't touch the parser ?
09:39:29 <paolino> isn't there a lift for types :) ?
09:40:48 * paolino misses the good thing of python metaclasses 
09:43:31 <paolino> for classes with many methods, routing is not so elegant
09:54:34 <Cheery> > \x -> x
09:54:35 <lambdabot>  Add a type signature
09:54:48 <Cheery> there was that module...
09:55:49 <Cale> @pl \x -> x
09:55:50 <lambdabot> id
09:56:32 <DynWind> hey, shim is pretty neat!
09:58:26 <Cheery> found it. :)
09:58:33 <Cheery> Text.Show.Functions
09:59:26 <emu> DynWind: ah its working? cool
10:00:12 <DynWind> its doing identifier completion, highlighting compiler warnings atleast
10:00:20 <paolino> uhm how do I route the collect function , it's not so immediate
10:00:40 <emu> how about types
10:00:58 <DynWind> yep, shows types too
10:01:07 <Cheery> I wonder.
10:01:14 <Cheery> Can you decompose function in haskell?
10:01:22 <Cheery> like, break it for printing?
10:01:32 <emu> break?
10:01:44 <emu> like debug?
10:01:49 <Cheery> yep.
10:01:52 <allbery_b> decompiling for display?  that's Hard
10:02:06 <emu> there is a nice new debugger for ghci
10:02:12 <allbery_b> oh, that.  dunno if ghci supports that
10:02:15 <emu> which you can set breakpoints
10:02:41 <emu> you need darcs head for that
10:02:54 <paolino> nmessenger,Saizan : the constructor  is not in the argument
10:03:15 <Cheery> emu: I'm just wondering whether one could put the Text.Show.Functions -thing show input and output of function it prints.
10:03:26 <emu> trace?
10:03:35 <Cheery> kind of, yes.
10:03:55 <Cheery> I guess that's hard because it's not done.
10:04:18 <emu> you can insert your own trace statements
10:04:31 <emu> Hat performs program-wide tracing
10:05:06 <allbery_b> ...but only n very simple programs
10:05:31 <emu> admittedly i never got Hat to work, it seems to be unmaintained
10:05:47 <emu> the new ghci-debugger is probably the thing to try
10:06:31 <emu> i gotta get shim though, just what i wanted to see (but never have time to try)
10:06:36 <astrolabe> Hat is sort-of maintained, but I found I had to make many changes to my code to get hat to accept it.
10:06:39 <allbery_b> @where shim
10:06:39 <lambdabot> http://shim.haskellco.de/trac/shim
10:07:16 * allbery_b has shim installed but it seems less than enchanted with xemacs
10:07:23 * paolino has been abandoned in the desert
10:07:35 <emu> yea he says its tested on gnu emacs 22
10:07:39 <emu> (works for me)
10:07:47 * DynWind is using bleeding edge CVS emacs
10:07:55 <allbery_b> it falls over a lot
10:08:55 <emu> DynWind: unicode branch?
10:09:08 <DynWind> yeah, for the XFT eye-candy :)
10:09:16 <emu> yea well that eye-candy kills me
10:09:23 <emu> (i often run over remote X)
10:09:38 <emu> otherwise, cool!
10:11:05 <DynWind> I've gone back to running it inside konsole, though. Feels nicer on the eyes
10:11:07 <emu> you know you're a haskell fanatic when su'ing to root and hitting C-p for the prev command brings up "runghc Setup.hs install"
10:11:18 <DynWind> :)
10:11:56 <emu> is putty unicode capable?
10:12:21 <DynWind> haven't a clue
10:12:56 <syntaxfree> yay for graphviz!
10:13:03 <emu> yes
10:13:04 <syntaxfree> I think I'm never going to write text again!
10:13:20 <syntaxfree> my mind maps so much better to graph form
10:13:34 <emu> spineless, tagless?
10:13:46 <syntaxfree> ?
10:14:37 <ddarius> Unfortunately, graphs are rarely a dense presentation of information.
10:14:59 <DynWind> speaking of mind maps, does anyone find those mind-mapping software useful?
10:15:09 <syntaxfree> dynwind: just use graphviz :)
10:15:35 <syntaxfree> I find myself developing theoretical ideas as I add nodes to a graph.
10:15:44 <EvilTerran> emu, i think putty does unicode.
10:15:52 <DynWind> I've recently started to use Muse (wiki inside emacs) to keep track of stuff
10:15:56 <EvilTerran> i've managed to get a +- character out of it, at least.
10:19:14 <DynWind> syntaxfree: you mean you write a dot file for every "topic"?
10:21:16 <syntaxfree> yes, basically.
10:21:36 <syntaxfree> I start out by mapping ideas in my head, and then I begin to find the connections are under-explained.
10:21:46 <syntaxfree> then as I expand the nodes I start to find new connections!
10:21:48 <DynWind> hmm, you have any sample I could perhaps see?
10:24:48 <syntaxfree> I'm working on one right now, but it's in portuguese.
10:25:19 <sm> good morning all
10:25:38 <sm> to profile my app, do I need to recompile every library with -prof ?
10:25:49 <DynWind> well, if I can watch Portuguese movies, I guess I can look at portuguese graphs as well ;)
10:27:02 <syntaxfree> okie!
10:27:04 <syntaxfree> just a min, then.
10:28:40 <syntaxfree> I'm uploading one to imageshack.
10:28:54 <syntaxfree> but imageshack is slow today!
10:29:26 <Lemmih> sm: Yes.
10:30:10 <syntaxfree> does "profile" mean "see what functions are taking so long"?
10:31:33 <syntaxfree> http://img114.imageshack.us/img114/7029/mindmapwf0.jpg
10:31:37 <syntaxfree> there's a mindmap graph.
10:32:26 <DynWind> thanks!
10:32:39 <sm> what's the easiest way to do that (reinstall all with -prof) ? I have the ghc source here
10:32:56 <sm> and will that impose a big penalty for normal use ?
10:33:12 <sm> syntaxfree: yes it does
10:33:29 <Saizan> the standard installation provides both normal and -prof binaries for the libs
10:33:54 <Lemmih> sm: There will be no penalty for normal use. You'll get two versions of the libraries.
10:34:38 <Lemmih> sm: You're missing profiling versions of the standard libraries?
10:35:44 <sm> well, I do ghc --make -prof myprog.hs and get Could not find module `Test.QuickCheck': Perhaps you haven't installed the profiling libraries for package QuickCheck-1.0?
10:36:10 <Lemmih> sm: Did you compile GHC yourself?
10:36:21 <sm> yes, I installed ghc from source and have been installing libraries as needed
10:36:49 <sm> gropingly
10:36:52 * syntaxfree fears for the day someone comes up with Gentoo for GHC.
10:37:09 <syntaxfree> I wonder whatever happened to entoo for MacOS X, btw.
10:38:01 <Lemmih> sm: Weird, profiling should be enabled by default.
10:40:17 <sm> hmm.. think I'll re-autoreconf/configure/make
10:42:19 <Lemmih> sm: Check GhcLibWays from mk/build.mk
10:42:28 <sm> will that install everything in libraries/ as well ? I'm not sure
10:42:53 <sm> Lemmih: oops, I think it's gone
10:43:28 <nrb23> someone should port Shim to TextMate
10:43:32 <Igloo> sm: How are you building libraries?
10:43:48 <nrb23> ?where TextMate
10:43:48 <lambdabot> I know nothing about textmate.
10:44:03 <nrb23> ?where+ TextMate http://macromates.com/
10:44:04 <lambdabot> Done.
10:44:21 <nrb23> ?where xcode
10:44:21 <lambdabot> I know nothing about xcode.
10:44:33 <emu> go ahead and port it ;)
10:45:02 <emu> a defacto standardized protocol for editor->haskell integration would be nice
10:45:05 <nrb23> ?where+ xcode http://www.hoovy.org/HaskellXcodePlugin/
10:45:06 <lambdabot> Done.
10:46:03 <DynWind> btw, do the developer(s) of shim hang-out here?
10:46:04 <sm> Igloo, I'm guessing I downloaded the extralibs, either the tarball or with darcs-all extra get, did make install to get ghc installed, and have been going into individual libraries/* and make install to get those installed
10:46:19 <emu> DynWind: beschimi i think
10:47:06 <DynWind> ?seen beschimi
10:47:06 <lambdabot> I haven't seen beschimi.
10:47:28 <emu> seen db is wiped
10:47:29 <nrb23> ?seen nrb23
10:47:30 <lambdabot> You are in #haskell. I last heard you speak just now.
10:48:13 <allbery_b> ?seen beschmi
10:48:14 <lambdabot> I saw beschmi leaving #haskell, #darcs and #ghc 16h 40m 35s ago, and .
10:48:23 <allbery_b> spelling counts :)
10:48:30 <DynWind> thanks :)
10:48:52 <nrb23> maybe lambdabot should have a spell checker:->
10:49:03 <sorear> @keen nrb23
10:49:04 <lambdabot> nrb23 is in #haskell. I last heard nrb23 speak 12s ago.
10:49:15 <sorear> @ysers
10:49:15 <lambdabot> Maximum users seen in #haskell: 316, currently: 295 (93.4%), active: 34 (11.5%)
10:49:20 <nrb23> so, it does
10:49:22 <DynWind> fuzzy matching
10:49:22 <nrb23> cool
10:49:44 <sorear> @spell maching
10:49:46 <lambdabot> marching matching machine mashing mac hing
10:49:49 <oklopol> @vtfst
10:49:49 <lambdabot> Unknown command, try @list
10:50:08 <sorear> @y
10:50:09 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . v
10:50:15 <oklopol> xD
10:50:40 <TomMD> ?remember sorear
10:50:40 <lambdabot> Incorrect arguments to quote
10:50:47 <TomMD> ?quote sorear
10:50:47 <lambdabot> sorear says: I can actually hold a conversation with chanserv [/talking about NOTICE]
10:51:03 <nrb23> so, generally, the answer to any time I think of something lambdabot should do, It already does it :->
10:51:12 <kaol> @yhjulwwiefzojcbxybbruweejw
10:51:12 <lambdabot> "\""
10:51:28 <DynWind> yeah
10:51:42 * DynWind blames irssi for confusing split-windows
10:51:52 <robert_|_> hi all. I want to compile haskell code (GHC) for an embedded platform, called GumStix. Anybody with any experience in any related field?
10:52:58 <NichardRixon> @yhjulwwiefzojcbxybbruweejw
10:52:59 <lambdabot> "\"#$%&'()*+,\""
10:53:15 <robert_|_> hmmmm
10:53:21 <sorear> there's the House group - compiling Haskell to i386 - not very interesting until they qualify "Ring 0, no OS"
10:53:27 <sorear> @where house
10:53:28 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
10:54:20 <sorear> yhc & nhc - haskell compilers designed for extremely low runtime memory use
10:54:38 <robert_|_> actually the problem is that i need to compile for Linux + ARM processors
10:54:55 <robert_|_> but the target hardware itself is too restricted to run the compile on
10:54:59 <sorear> jhc - theoretically produces portable C, but IME produces mostly error messages
10:55:08 <sorear> GHC can target Linux/ARM
10:55:17 <robert_|_> is it possible to create GCC compilable code using GHC?
10:55:32 <sorear> -fvia-C -keep-tmp-files
10:55:37 <robert_|_> ah!
10:56:05 <hpaste>  Eighty pasted "take'" at http://hpaste.org/545
10:56:10 <sorear> but the code is arch specific - don't try that on a PC and expect the generated C to work on ARM
10:56:17 <Eighty> why is that function 30 times slower than the built-in implementation of take?
10:56:31 <robert_|_> ok.... so I must build on an ARM
10:56:35 <sorear> Eighty: what is your benchmark
10:57:22 <Eighty> I use evaluate and rnf to calculate the result and use getCPUTime to measure the elapsed time
10:57:27 <sorear> @otsnack
10:57:28 <lambdabot> :)
10:57:45 <Eighty> and my test is take (10^7) [1::Int ..]
10:57:46 <sorear> Eighty: Specifically, I meant "where do you get your list"
10:57:46 <Philippa> robert_|_: if you can get debian running on it, you're sorted - there's a package
10:57:54 <Philippa> I need to get my zaurus running it sometime...
10:58:01 <sorear> Eighty: are you using -O2
10:58:06 <sorear> Eighty: or -O
10:58:20 <Eighty> i don't think so. can you use it in interactive mode?
10:58:22 <robert_|_> sorear: I also ready something bout unregistered compiler. Is "unregistered" code the same as processor indep. code?
10:58:53 <robert_|_> i.o.w.: could I (theoretically) build an unregistered i386 comp. and then create C-code, put that on the target hardware and there run a C compiler?
10:59:08 <sjanssen> hmm, hpaste is timing out for me
10:59:10 <sorear> robert_|_: not quite. it still depends on wordsize (doesn't arm use the unique wordsize of 29?) and maybe other things
10:59:18 <robert_|_> ok ic
10:59:32 <sorear> sjanssen: me too.
10:59:44 <robert_|_> the strange thing is, those GumStix guys gave me a C compiler to run on i386 that compiles binaries for ARM linux
10:59:50 <robert_|_> so that I compile on my own computer
10:59:54 <Eighty> sorear: adding {-# OPTIONS -O2 #-} to the top of the file didn't make it faster
11:00:01 <Eighty> but it might be because i'm using ghci?
11:00:06 <sjanssen> Eighty: are you using it in ghci?
11:00:12 <robert_|_> but I guess that the most promising way to go is just to ignore that, and compile on an ARM directory anyway
11:00:16 <robert_|_> directory = directly
11:00:20 <sorear> Eighty: the optimizer is disabled in ghci because it tickles bugs in the bytecode interpreter
11:00:27 <Eighty> okay
11:00:29 <sjanssen> Eighty: you need to compile the file for optimization
11:01:39 <nrb23> anyone used the xcode integration?
11:01:42 <fasta> Uhm, shouldn't the type of an expression in ghci be the same as that same expression in a file?
11:01:51 <sorear> Eighty: specifically, http://haskell.org/ghc/dist/current/docs/users_guide/ghci-faq.html
11:01:54 <lambdabot> Title: 3.10. FAQ and Things To Watch Out For, http://tinyurl.com/29dn9g
11:02:05 <sorear> fasta: yes, if you use all the same options
11:02:11 <allbery_b> hpaste.org unhappy here too
11:02:31 <sorear> fasta: notably, ghci has -fextended-default-rules on by default, so (show []) is well typed for instance
11:04:03 <fasta> sorear: the problem is that a type variable is narrowed to (). I hope I can get the same options in some way.
11:05:05 <sorear> Eighty: yech, look at http://darcs.haskell.org/ghc-6.6/packages/base/GHC/List.lhs halfway down /#ifdef USE_REPORT_PRELUDE
11:05:14 <fasta> set_flow =
11:05:14 <fasta>  (\ep g f -> Mut.modify_edge_label (\l -> l{flow=f}) ep g) :: (Gr g edge_position EKLabel) => edge_position -> g a EKLabel -> Int -> g a EKLabel
11:05:16 <sorear> #else /* Hack away! */
11:05:32 <fasta> In fact when I ask for the type of set_flow, I get a _different_ type!
11:05:51 <fasta> I completely gave the type as you can see.
11:06:25 <fasta> (This is ghci-6.6)
11:07:00 <fasta> set_flow :: forall (g :: * -> * -> *) a. (Gr g () EKLabel) => () -> g a EKLabel -> Int -> g a EKLabel
11:07:10 <fasta> This is the type I get when I do :t set_flow
11:07:30 <robert_|_> sorear: I now have a .hc file. Is it possible to compile that with gcc?
11:07:34 <sjanssen> sorear: the "Hack away!" phrase is my favorite
11:07:43 <fasta> sjanssen: you any idea?
11:07:45 <sjanssen> you find it all over the base package
11:08:20 <Eighty> sorear: USE_REPORT_PRELUDE isn't defined usually i guess? ghc uses some optimized variant?
11:08:54 <sorear> robert_|_: yes, but you might want to run ghc -v first to see and -D options ; aslo you may need to run the mangler manually
11:08:56 <Lemmih> fasta: You're hitting the monomorphism restriction.
11:09:11 <sjanssen> Eighty: USE_REPORT_PRELUDE isn't really used anymore, it's mainly for documentation purposes nowadays
11:09:13 <robert_|_> sorear: ok thanx...
11:09:34 <fasta> Lemmih: I also tried to put the arguments on the LHS
11:09:52 <fasta> Lemmih: that should get rid of the monomorphism restriction, right?
11:10:22 <sorear> Eighty: also pay note to the fact that with -O take (10^7) [0..] can fuse, but take' can't.
11:10:24 <fasta> Lemmih: And, don't you think that it's odd that it completely ignores the type I gave it?
11:10:48 <Eighty> sorear: what is fusing?
11:11:31 <Eighty> ghc optimizes it to [0..10^7-1] because it knows what take does?
11:12:11 <sjanssen> Eighty: it means the intermediate list between the generator and the consumer isn't produced at all
11:12:12 <sorear> Eighty: shortcut deforestatation.  it doesn't quite get optimized to that (I think) but the intermediate list can be turned into a lloop
11:12:52 <sjanssen> the code generated will be very similar to the code generated for [0 .. 10^7 - 1]
11:12:56 <fasta> Lemmih: How can I convince ghci to give the right type?
11:13:16 <Lemmih> fasta: Give it a type signature.
11:13:26 <Eighty> why doesn't it do it with take'?
11:13:26 <fasta> Lemmih: on the top-level, you mean?
11:13:46 <sorear> Eighty: because take' isn't a foldr.
11:14:03 <fasta> Lemmih: thank you very much
11:14:12 <Eighty> why is foldr so effective then?
11:14:13 <Lemmih> fasta: That's the only way of specifying a type signature. 'x = y :: T' is completely different from 'x :: T; x = y'.
11:14:18 <sorear> only functions defined with foldr can fuse as consumers, only functions defined with build can fuse as producers.
11:14:32 <sjanssen> Eighty: ghc has special rules that combine foldr and build
11:14:33 <sorear> Eighty: because there are special rules for optimizing it.  foldr/build
11:14:45 <sorear> @src build
11:14:46 <lambdabot> build g = g (:) []
11:14:52 <sorear> @src foldr
11:14:52 <lambdabot> foldr k z xs = go xs
11:14:53 <lambdabot>     where go []     = z
11:14:53 <lambdabot>           go (y:ys) = y `k` go ys
11:15:10 <sorear> the compiler knows that foldr k z (build g) === g k z
11:15:22 <Eighty> and this is hardcoded in ghc? if i wrote my own foldr and used that, there'd be no optimization?
11:15:36 <sorear> that's pretty much the only rule needed for the entire shortcut system
11:15:51 <sorear> Eighty: no, the rules are installed in GHC using special pragmas
11:15:52 <sjanssen> Eighty: it is implemented with a RULE pragma -- which you can define yourself
11:16:06 <Lemmih> fasta: Consider 'x = (\y -> show y) :: Show a => a -> String'. It's the same as 'x_ :: Show a => a -> String; x_ = show; x = x_'.
11:16:11 <Eighty> in haskell code?
11:16:51 <sjanssen> RULE is a ghc extension -- it uses pseudo Haskell to specify the transformation
11:16:51 <Lemmih> fasta: Therefore, ghc is not ignoring the type you gave it. You just gave it to the wrong entity.
11:16:58 <sorear> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Base.lhs  -- search for "fold/build"
11:17:37 <Eighty> haha, first thing i find is foldr = error "urk" :)
11:20:44 <nrb23> Eighty: search for {-# RULES
11:20:58 <nrb23> "fold/build" 	forall k z (g::forall b. (a->b->b) -> b -> b) .
11:20:58 <nrb23> 		foldr k z (build g) = g k z
11:21:03 <Eighty> i found it :)
11:21:13 <Eighty> what happens if you enter a false rule? :)
11:21:16 <Eighty> hilarity, i bet.
11:21:21 <emu> nasal demons
11:21:23 <nrb23> seems likely
11:21:28 <nrb23> (but I don't know)
11:21:50 * dcoutts tries parsing linux again with allyesconfig
11:21:50 <sjanssen> Eighty: the rule has to type check
11:21:54 <emu> > let 2 + 2 = 5 in 2 + 2
11:21:55 <lambdabot>  5
11:22:12 <emu> @let 2 + 2 = 5
11:22:13 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
11:22:27 <sjanssen> Eighty: but otherwise, you can write any rule you want (so be careful!)
11:22:46 <emu> it's not a bad idea to write a corresponding quickcheck rule ;)
11:22:57 <Eighty> cool
11:23:12 <araujo> morning
11:25:10 <robert_|_> sorear: thank you for your help!
11:26:34 <nrb23> :t augment
11:26:36 <lambdabot> Not in scope: `augment'
11:27:11 <nrb23> ?hoogle augment
11:27:12 <lambdabot> GHC.Exts.augment :: ((a -> b -> b) -> b -> b) -> [a] -> [a]
11:27:12 <lambdabot> Data.Graph.Inductive.Query.MaxFlow.augmentGraph :: (DynGraph gr, Num b, Ord b) => gr a b -> gr a (b, b, b)
11:27:48 <ddarius> @src GHC.Exts.augment
11:27:48 <lambdabot> Source not found. That's something I cannot allow to happen.
11:28:15 <ddarius> @ft ((a -> b -> b) -> b -> b) -> [a] -> [a]
11:28:18 <lambdabot>  There was an error in the type: (line 1, column 7):
11:28:18 <lambdabot>  unexpected "e"
11:28:18 <lambdabot>  expecting "->" or end of input
11:28:28 <ddarius> @ft f::((a -> b -> b) -> b -> b) -> [a] -> [a]
11:28:30 <lambdabot>  There was an error in the type: (line 1, column 4):
11:28:30 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
11:37:31 <nrb23> :t spac
11:37:33 <lambdabot> Not in scope: `spac'
11:37:36 <nrb23> ?hoogle spac
11:37:36 <lambdabot> Text.Html.spaceHtml :: Html
11:37:37 <lambdabot> Text.PrettyPrint.HughesPJ.space :: Doc
11:37:37 <lambdabot> Text.ParserCombinators.Parsec.Char.space :: CharParser st Char
11:41:25 <fasta> Lemmih: but shouldn't -fno-monomorphism-restriction solve that problem?
11:46:10 <ejt> hi
11:46:38 <sorear> hello
11:53:23 <ejt> in case anyone is interested; I've been teaching myself Haskell by working on the puzzles in the 'programming challenges' book.  About 20 programs are available on lambda-software.com
11:55:30 <Korollary> I too used some of those problems (from http://acm.uva.es/problemset/) when I first learned haskell.
11:55:32 <lambdabot> Title: online-judge.uva.es - PROBLEM SET ARCHIVE
11:55:40 <TomMD> ejt: what is your opinion thus far?
11:55:51 <ejt> of Haskell ?  I love it
11:56:37 <ejt> but there's a big difference between appreciating how beautiful something is, and being able to produce good code quickly
11:56:51 <ejt> it's the latter that I'm really trying to concentrate on
11:57:13 <ejt> Korollary: do you have any of your solution still ?
11:58:18 <Korollary> ejt: I don't. Sorry. You'll start writing quicker as you get used to the language more.
11:59:58 <sjanssen> http://www.spoj.pl is another nice programming problems source
12:00:04 <lambdabot> Title: Sphere Online Judge (SPOJ)
12:00:08 <sjanssen> you can even submit solutions in Haskell
12:00:12 * sm is interested in the latter also
12:00:19 <ejt> thx
12:03:55 <sm> defining some data models that reference each other, I find myself breaking them into somewhat awkward modules to get around the hassles of recursive import
12:04:45 <sorear> agreed
12:07:06 <astrolabe> maybe it's because of my idea of modules, but I've never wanted to make mutually recursive ones.
12:12:45 <sm> here's my example: ledger contains entries containing transactions containing accountnames. accounts have an accountname and transactions, which they find in a ledger.
12:13:49 <sm> I had to split account and accountnames modules. which is not too bad. I've seen other hassles, but actually I can't find a good example just now
12:14:35 <sm> it's forcing me to layer things carefully from the bottom up
12:14:56 <astrolabe> sm: That sounds like a good thing ;)
12:16:08 <sm> it does, doesn't it.. I'll see how things evolve
12:17:17 <sm> so anyway, this personal finance thing I said I was going to work on a while back.. it's coming together
12:17:47 <sm> back then someone pointed me to ledger (http://newartisans.com), for which thanks - it's just what I needed
12:18:26 <sm> so I've been porting bits of it to haskell
12:20:27 <sm> right now it can parse the ledger file format and print a balance report or a simple register report, matching on account or description
12:22:43 <sm> this is improving my haskell, for sure.. and I'd appreciate any code review, suggestions, help
12:23:07 <sm> http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=tree
12:23:08 <lambdabot> Title: darcs - hledger
12:25:12 <sm> so far, you could say it's roughly 10x fewer lines of code and 10x slower than the c++ version
12:25:58 <sm> (hence my interest in setting up profiling)
12:29:57 <Lemmih> sm: Did you resolve the problem?
12:30:50 <sm> Lemmih: not yet.. I kicked off a ghc rebuild, it's still going
12:30:54 <TomMD> Are there any good block diagrams about happs structure?  Similarly, is there any information available about where happs is going?
12:31:18 <fasta> Lemmih: can I get around that part of the monomorphism restriction in some way?
12:31:32 <sorear> hehe. I spent all of yesterday figurign out how happs works.
12:31:46 <sorear> I think I know enough to write a protocol module now ...
12:32:20 <Lemmih> fasta: -fno-monomorphism-restriction didn't work?
12:32:34 <TomMD> sorear: did you use the code, humans, or is there good documentation?
12:32:42 <fasta> Lemmih: I have OPTIONS_GHC -fno-monomorphism-restriction in the file
12:32:50 <fasta> Lemmih: In the correct format
12:33:05 <fasta> Lemmih: {-# OPTIONS_GHC -fglasgow-exts -fno-monomorphism-restriction -fno-implicit-prelude #-}
12:33:06 <sm> TomMD: I think there is no good documentation that you haven't already found..
12:33:23 <TomMD> ok
12:33:28 <sm> browse the list archives, for sure
12:33:33 <fasta> TomMD: Maybe there's a TODO file?
12:34:42 <sorear> TomMD: the code :(
12:38:24 <sorear> is there a typo in the newArray# documentation?  it looks like you need to know the wordsize to use it!
12:39:19 <sorear> not that I'm sure I should be using primops for this anyways :)
12:42:50 <sorear> there IS a typo ... either that or a bug in GHC.Arr.unsafeArray
12:45:30 <Cheery> http://www.wellingtongrey.net/miscellanea/archive/2006-12-18-why-go.png
12:45:32 <lambdabot> http://tinyurl.com/293rvx
12:49:08 <sm> darn, ghc-pkg: dependency OpenGL doesn't exist (use --force to override). I didn't have the opengl headers installed when I configured
12:49:27 <sm> how can I get it to finish building what I do have, without starting over ?
12:50:44 <Cheery> sm: could you ask it another way around?
12:52:18 <Cheery> or wait, sorry.
12:52:27 <Cheery> context blindness. :)
12:52:31 <sm> yup: I'd like to get this ghc & libs build to finish, so I can make install.. it has unexpectedly died because I didn't have opengl headers installed
12:52:38 <sorear> my code is turning into a solid mass of #
12:55:43 <Lemmih> sm: configure --disable-opengl && make?
12:56:04 <sm> that'll rebuild everything, right ?
12:57:09 <fasta> Lemmih: should it work with -fno-monomorphism-restriction without type annotations?
12:57:11 <sm> in the beginning it did say configure: WARNING: no OpenGL headers found, so this package will not be built, so I'm sad it didn't figure this out
12:57:32 <Pastorn_> can i map putStr over a list of strings?
12:57:42 <sorear> mapM_
12:57:58 <Pastorn_> @type mapM_
12:58:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
12:58:15 <sorear> Prelude> mapM_ putStr ["foo", "bar", "baz"]
12:58:15 <sorear> foobarbazPrelude>
12:58:28 <Pastorn_> yay!
12:58:49 <Lemmih> sm: Your sources are acting quite weird.
12:59:03 <sm> :(
12:59:15 <Lemmih> sm: Can't you use a binary package?
12:59:44 <sm> no, ubuntu edgy has only ghc 6.4
12:59:55 <Pastorn_> when writing IO, is this a correct line:
13:00:15 <Pastorn_> let foo = fun (bar)
13:00:23 <Lemmih> sm: Did you fetch the sources with darcs?
13:00:26 <sm> yup
13:00:28 <Pastorn_> to let me later adress fo
13:00:29 <Pastorn_> foo
13:00:36 <Pastorn_> ok, thanks
13:00:53 <Lemmih> sm: Going with a stable release might be a lot easier.
13:00:53 <Saizan> isn't there a linux package that works with any distro?
13:01:28 <sm> Lemmih: what are you suggesting :)
13:01:40 <sm> download a 6.6 release tarball and build that ?
13:01:48 <Lemmih> sm: Yes.
13:02:29 <sorear> sm: if you are building GHC HEAD on i386, be wary of #1151 - -fvia-C is quite broken atm (-fasm works fine)
13:02:39 <sm> thanks
13:03:03 <sorear> I suppose that's the cost of -O -/-> -fviaC ; -fvia-C has a chance to bitrot.
13:03:58 <Lemmih> sorear: Does that affect all programs that use -fvia-c?
13:04:19 <sm> is it possible I installed the 6.6 and extra-libs tarball, and then darcs updated to head ?
13:04:20 <sorear> Lemmih: hello world works, pretty much anything bigger is miscompiled.
13:04:32 <Pastorn_> @paste
13:04:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:04:43 <sorear> lots o gcc warnings, then a (runtime) segfault
13:04:56 <Lemmih> sorear: Do you know why it hasn't been catched by the testsuite?
13:05:29 <sorear> no, and I never thought of that.  thanks. /me goes looking for a -fvia-C test
13:06:02 <sorear> where is the testsuite in the ghc tree?
13:06:11 <sjanssen> sorear: have you gotten anyone else to reproduce that bug?
13:06:15 <sjanssen> it doesn't happen over here
13:06:19 <hpaste>  Pastorn pasted "what's wrong?" at http://hpaste.org/546
13:06:19 <sorear> (is it one of the things that isn't even downloaded with --extra?)
13:06:29 <sorear> sjanssen: yes
13:07:16 <sorear> .16 from the clog - 17:01:00 <allbery_b> fwiw, with 20070213 I also get the internal error with -fvia-C
13:07:17 <allbery_b> I got the same failure
13:07:34 <allbery_b> hpasted it onto sorear's example, even
13:09:12 * sm starts afresh with 6.6 release tarballs
13:09:18 <Saizan> Pastorn_: what's the error? btw you don't need return ()
13:09:24 <Pastorn_> nevermind...
13:09:28 <Lemmih> Pastorn_: Works for me (assuming toChar = undefined).
13:09:46 <Pastorn_> Saizan: Why don't i need return () ?
13:09:57 <Saizan> ?type mapM_
13:09:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:10:03 <Pastorn_> oh
13:10:07 <Pastorn_> ak
13:10:08 <Pastorn_> ok
13:10:59 <pejo> sorear, isnt' that darcs.haskell.org/testsuite nowdays?
13:21:04 <xic> hey...
13:21:42 <Vq^> hoy...
13:21:59 <thorat> xic: jegshemesh
13:24:30 <xic> i'm using hsc2hs, how can i create a c struct, or get the sizeof a c struct?
13:33:01 * jcreigh notes that nomaware.com is *still* down...
13:35:26 <hpaste>  Pastorn pasted "yay for consitency!!" at http://hpaste.org/548
13:36:00 <abz> ?poll-list
13:36:00 <lambdabot> ["OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
13:36:19 <abz> ?poll-results "OperatingSystem"
13:36:20 <lambdabot> No such poll: "\"OperatingSystem\""
13:36:30 <abz> ?poll-results OperatingSystem
13:36:31 <lambdabot> Poll results for OperatingSystem (Open): MacOS=0, House=0, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=3, Debian=5, Ubuntu=2, FreeBSD=2
13:36:48 <Pastorn_> i just can't see what can be wrong...
13:37:34 <Lemmih> Pastorn_: Indentation error.
13:37:40 <Pastorn_> fuck
13:37:46 <Pastorn_> sorry
13:37:48 <Pastorn_> "darn"
13:37:50 <Vq^> jcreigh: looking for this: http://web.archive.org/web/20060111062743/www.nomaware.com/monads/html/ ?
13:37:52 <lambdabot> Title: All About Monads, http://tinyurl.com/3yopul
13:38:59 <abz> Pastorn: bring the y back one space and add import Char
13:39:29 <hpaste>  (anonymous) annotated "yay for consitency!!" with "(no title)" at http://hpaste.org/548#a1
13:41:53 <abz> Pastorn_: working?
13:42:17 <Pastorn_> yes
13:42:27 <Pastorn_> thanks
13:43:06 <abz> you should look up how to use Maybe.maybe
13:44:44 <Saizan> any good tutorial on the Cont monad?
13:45:49 <allbery_b> hm, restrict to one vote would mix poorly with the OS poll, I think
13:45:59 <allbery_b> (MacOS/FreeBSD/SuSE)
13:46:51 <jcreigh> Vq^: Thanks. I know I can go to archive.org, I was just whining that I needed to.
13:47:44 <kolmodin> ?vote OperationSystem Gentoo
13:47:45 <lambdabot> No such poll:"OperationSystem"
13:47:55 <kolmodin> ?vote OperatingSystem Gentoo
13:47:55 <lambdabot> voted on "Gentoo"
13:48:04 <hpaste>  (anonymous) annotated "yay for consitency!!" with "(no title)" at http://hpaste.org/548#a2
13:48:59 <abz> ?vote OperatingSystem Gentoo
13:48:59 <lambdabot> voted on "Gentoo"
13:49:13 <Japsu> ?vote OperatingSystem Arch
13:49:14 <lambdabot> "Arch" is not currently a candidate in this poll
13:49:16 <Japsu> bah
13:49:18 <Japsu> ?vote OperatingSystem ArchLinux
13:49:19 <lambdabot> "ArchLinux" is not currently a candidate in this poll
13:49:23 <Japsu> :(
13:49:24 <abz> that last hpaste was incorrect
13:49:27 <Japsu> ?vote OperatingSystem Gentoo
13:49:27 <sorear> ?vote OperatingSystem Emacs
13:49:27 <lambdabot> voted on "Gentoo"
13:49:28 <lambdabot> "Emacs" is not currently a candidate in this poll
13:49:41 <Vq^> ?vote OperatingSystem Gentoo
13:49:42 <lambdabot> voted on "Gentoo"
13:49:46 <allbery_b> ?vote OperatingSystem MacOS
13:49:46 <lambdabot> voted on "MacOS"
13:49:51 <hpaste>  (anonymous) annotated "yay for consitency!!" with "(no title)" at http://hpaste.org/548#a3
13:49:51 <allbery_b> ?vote OperatingSystem FreeBSD
13:49:52 <lambdabot> voted on "FreeBSD"
13:49:54 <siti> ?vote OperatingSystem Gentoo
13:49:54 <araujo> ?vote OperatingSystem Gentoo
13:49:55 <lambdabot> voted on "Gentoo"
13:49:55 <lambdabot> voted on "Gentoo"
13:49:56 <allbery_b> ?vote OperatingSystem SuSE
13:49:57 <lambdabot> "SuSE" is not currently a candidate in this poll
13:49:59 <siti> lol
13:50:02 <dufflebunk> ?vote OperatingSystem SourceMage
13:50:02 <lambdabot> "SourceMage" is not currently a candidate in this poll
13:50:08 <siti> pfft
13:50:12 <sorear> ?vote-
13:50:12 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
13:50:13 <siti> poor dufflebunk :(
13:50:14 <abz>  ?poll-results OperatingSystem
13:50:19 <abz> ?poll-results OperatingSystem
13:50:19 <sorear> ?list poll
13:50:20 <lambdabot> Poll results for OperatingSystem (Open): MacOS=1, House=0, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=9, Debian=5, Ubuntu=2, FreeBSD=3
13:50:20 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
13:50:30 <abz> Go Gentoo
13:50:33 <sorear> ?choice-add OperatingSystem Emacs
13:50:33 <lambdabot> New candidate "Emacs", added to poll "OperatingSystem".
13:50:38 <sorear> ?vote OperatingSystem Emacs
13:50:39 <lambdabot> voted on "Emacs"
13:50:40 <Vq^> @help <vote-cmd>
13:50:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:50:45 <araujo> sorear, hah
13:50:52 <allbery_b> ?choice-add OperatingSystem SuSE
13:50:53 <lambdabot> New candidate "SuSE", added to poll "OperatingSystem".
13:50:57 <allbery_b> ?vote OperatingSystem SuSE
13:50:57 <lambdabot> voted on "SuSE"
13:50:59 <abz> Gentoo: If it moves, compile it!
13:51:05 <siti> lol
13:51:24 <Vq^> abz: we don't limit ourselves to moving code :P
13:51:25 <siti> gentoo has haskell overlay :D
13:51:32 <abz> lol
13:51:38 <rahikkala> If it compiles, add gcc flags until it breaks!
13:51:39 <jcreigh> hmm, distros != Operating systems.
13:51:47 <jcreigh> -fomit-sanity
13:51:48 <siti> yeah
13:51:57 <siti> maybe we need a new poll :p
13:52:02 <Vq^> jcreigh: right, but GNU wasn't on the list...
13:52:27 <araujo> ?choice-add OperatingSystem GNU/Hurd
13:52:27 <lambdabot> New candidate "GNU/Hurd", added to poll "OperatingSystem".
13:52:35 <siti> lol
13:52:37 <Vq^> or was that the Emacs choice? :)
13:52:41 <jcreigh> @vote OperatingSystem Debian
13:52:41 <lambdabot> voted on "Debian"
13:52:59 <Vq^> araujo: what if you use GNU without Hurd?
13:53:06 <jcreigh> Vq^: hmm? What do you mean?
13:53:09 <siti> GNU/OS?
13:53:14 <siti> ;)
13:53:18 <araujo> Vq^, specify the name of the kernel then
13:53:28 <araujo> :-P
13:53:46 <Vq^> GNU/MINT :o)
13:54:09 <Vq^> it's still GNU thought
13:54:33 <araujo> ?choice-add OperatingSystem House
13:54:33 <lambdabot> New candidate "House", added to poll "OperatingSystem".
13:54:42 <siti> :D
13:54:45 <araujo> ?vote OperatingSystem House
13:54:45 <lambdabot> voted on "House"
13:54:48 <araujo> :-)
13:54:53 <thorat> @vote OperatingSystem Debian
13:54:54 <lambdabot> voted on "Debian"
13:55:03 <sorear> ?poll-results OperatingSystem
13:55:03 <siti> I have to try house out, it must be cool making an OS in haskell :)
13:55:03 <lambdabot> Poll results for OperatingSystem (Open): House=1, GNU/Hurd=0, SuSE=1, Emacs=1, MacOS=1, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=9, Debian=7, Ubuntu=2,
13:55:04 <lambdabot> FreeBSD=3
13:55:12 <allbery_b> ?poll-results OperatingSystem
13:55:13 <lambdabot> Poll results for OperatingSystem (Open): House=1, GNU/Hurd=0, SuSE=1, Emacs=1, MacOS=1, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=9, Debian=7, Ubuntu=2,
13:55:13 <lambdabot> FreeBSD=3
13:55:15 <Vq^> two House on the list :=
13:55:17 <sorear> siti: note that house is listed twice
13:55:20 <Vq^> seems like a bug
13:55:22 <siti> hah
13:55:25 <siti> weird
13:55:38 <sorear> Vq^: the bug is in module "araujo"
13:55:52 <araujo> :-P
13:55:54 <sorear> House was already listed when he added it
13:55:55 <Vq^> sorear: what? we can't blame dons?!?
13:55:59 <araujo> argh!
13:56:08 <araujo> yes, let's better blame dons
13:56:11 <sorear> maybe.
13:56:26 <araujo> i thought it checked for duplicated
13:56:32 <sorear> since lambdabot is completely undocumented, we can't clame documentation inconsistency ...
13:56:42 <Vq^> heh
13:56:42 <araujo> well, any command for removing an entry?
13:57:05 <sorear> ?list poll
13:57:06 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
13:57:12 <arjanoosting> @vote OperatingSystem Debian
13:57:12 <lambdabot> voted on "Debian"
13:57:14 <siti> umm shouldn't it be MacOSX ;)
13:57:15 <sorear> ?help poll-remove
13:57:15 <lambdabot> poll-remove <poll>          Removes a poll
13:57:16 <araujo> Plus, House is listed twice because it is twice more cool than the other ones.
13:57:24 <siti> no one uses MacOS these days :p
13:57:27 <sorear> araujo: I'm fine with that!
13:57:31 <araujo> :-)
13:58:22 <Vq^> araujo: that makes sense :)
13:59:02 <fasta> Lemmih: I think there's some interaction between the monomorphism restriction, funcional dependencies, and classes.
13:59:38 <fasta> Lemmih: When I removed the functional dependency and made the code less general, the -fno-monomorphism-restriction did have effect.
14:07:17 <tibbe> is there a reason there are no MaybeT monad transformer in the standard libs?
14:07:33 <fasta> tibbe: no
14:07:41 <sorear> absolutely not
14:07:42 <allbery_b> someone was dumb? :)
14:07:49 <allbery_b> there's one in the wiki though
14:07:52 <tibbe> yes
14:08:04 <tibbe> if I would write a patch with one do you think it would get included?
14:08:15 <tibbe> is there any interesting design decisions to be made?
14:08:29 <kolmodin> there is ErrorT though
14:08:42 <tibbe> kolmodin, yes
14:08:56 <tibbe> although I find myself using Maybe a whole lot right now
14:09:04 <tibbe> since I don't want to abort on error
14:09:09 <tibbe> just ignore and move on
14:09:17 <tibbe> (with the next element in a list=
14:21:57 <xic> i'm getting errors: In function `sy5_info': (.text+0x25): undefined reference to `MyModule_myFunction_closure'
14:22:18 <JohnnyL> @user humasect
14:22:19 <lambdabot> Maximum users seen in humasect: 1, currently: 0 (0.0%), active: 0 (NaN%)
14:22:53 <syntaxfree> @user syntaxfree
14:22:53 <lambdabot> Maximum users seen in syntaxfree: 1, currently: 0 (0.0%), active: 0 (NaN%)
14:24:55 <syntaxfree> nonhaskell programmers are weird.
14:25:04 <siti> hah
14:25:22 <siti> if everyone else is weird then we must be weird :p
14:25:23 <Vq^> yeah, and so are Haskell nonprogrammers...
14:25:41 <syntaxfree> I mean, the way the rave on and on about closures.
14:25:45 <syntaxfree> So what, closures?
14:25:52 <siti> lol
14:26:01 <syntaxfree> Next thing you know, they're saying "We have VARIABLES!"
14:26:05 <qwr> what way? you don't agree, that every function shall be tied to object and have side effects? :P
14:26:52 <siti> it's funny we are seeing the other languages attempt to hack in functional ideas, e.g. the new c#, new perl, python etc :D
14:27:22 <syntaxfree> why is it funny?
14:27:27 <dancor> i think it's good
14:27:44 <syntaxfree> i think it's only natural.
14:27:54 <dancor> if they took list comprehensions out of python i would probably lead the fork project to keep them
14:28:03 <siti> well it's ugly mixing imperative and functional :p
14:28:06 <siti> IMO
14:28:22 <tibbe> @paste
14:28:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:28:34 <syntaxfree> while offtopicness abounds, and since #haskell-blah is dead:
14:28:34 <qwr> siti: actually, not very. not uglier than any OO code
14:28:36 <syntaxfree> http://www.youtube.com/watch?v=59ZX5qdIEB0
14:28:38 <dancor> i always recommend python as a first language
14:28:47 <syntaxfree> Scheme is a perfect first language.
14:28:51 <siti> qwr: yes, but OO is so beautiful ;)
14:28:57 * araujo recommends Scheme too
14:29:09 <syntaxfree> Scheme shows that procedural programming is really unnecessary./
14:29:21 <syntaxfree> While not dicking about too much about types in the beginning.
14:30:15 <dancor> syntaxfree: imperative programming?  or procedure call programming
14:30:37 <syntaxfree> 10 X= X+1; 20 PRINT X; 30 GOTO 10 programming
14:30:48 <sorear> xic: clean and recompile :(
14:30:53 <dancor> i tried to get into scheme at one time but ended up getting into haskell instead
14:30:56 <syntaxfree> Scheme encourages you to write "iterate" and be done with it.
14:31:36 <ftegularius> if i can chime in, i think scheme is probably the best teaching language
14:31:43 <syntaxfree> methinks "imperative" is the opposite of "declarative".
14:31:49 <sorear> Scheme has IO in the core and everything else is an ugly afterthought.
14:31:49 <hpaste>  tibbe pasted "is this a monad?" at http://hpaste.org/549
14:31:56 <ftegularius> at the very least, it was used to write one of the best compsci textbooks, SICP
14:32:01 <qwr> scheme is good - if you want to use macros extensively for creating dsl's
14:32:03 <syntaxfree> imperative programming can be procedural, OO, even functional if impure and strict.
14:32:15 <sorear> Haskell's core is IO-free, and everything else is a beautiful afterthought
14:32:17 <qwr> for beginners, its probably also good
14:32:33 <sorear> uck, macros
14:32:41 <qwr> ;)
14:32:41 <tibbe> it looks like the maybe monad but with Bools ^^
14:32:43 <syntaxfree> macros never sounded like such a great idea to me.
14:32:48 <syntaxfree> it sounds like a hack.
14:32:55 <sorear> macros are a terrible solution to the problem
14:33:05 <sorear> not that there exists a better one, in general
14:33:25 <qwr> sorear: they are quite practical
14:33:33 <sorear> lazy eval handles 40% of the cases, polymorphism handles 40% more
14:33:49 <sorear> note that those numbers do not add to 100
14:34:11 <syntaxfree> I find it amazing that some languages don't have the concept of parametric polymorphism at all.
14:34:16 <sorear> oh, right, TH handles 12%
14:34:43 <ftegularius> i don't think scheme has much merit for practical use anymore
14:34:48 <syntaxfree> most of why people are so fond of dynamic languages is lack of easy polymorphism.
14:34:59 <sorear> #define max(x,y) ((x)<(y):(x):(y))
14:35:18 <sorear> bah, c syntax
14:35:23 <syntaxfree> sorear: yeah. Why isn't that a function?
14:35:25 <sorear> #define max(x,y) ((x)<(y)?(y):(x))
14:35:41 * syntaxfree likes cond?then:else 
14:35:46 <Cale> ftegularius: I agree about SICP, it really is good.
14:36:23 <ftegularius> Cale: yeah, it really covers all the fundamentals, recursion, list, accumulating paramters, lazy evaluation and streams, etc.
14:36:38 <ftegularius> the essential foundation of functional programming basically
14:36:47 <goltrpoat> hmm.. yhc is steadfastly refusing to build.. bunch of linker errors on Front.o
14:37:05 <Darius> ftegularius: How can Scheme not have much merit for practical use -anymore-?
14:37:14 <JohnnyL> doe shaskell have the concept operator of 'not'?
14:37:24 <syntaxfree> @type not
14:37:25 <Cale> @type not
14:37:27 <lambdabot> Bool -> Bool
14:37:29 <lambdabot> Bool -> Bool
14:37:33 <JohnnyL> thanks
14:37:41 <Darius> @src not
14:37:42 <lambdabot> not True   =  False
14:37:42 <lambdabot> not False  =  True
14:37:44 <syntaxfree> lambdabot should handle neatly identical requests in a short period of time.
14:38:05 <ftegularius> Darius: well, as far as i know, and i may be wrong, it just can't compete w/ many modern functional languages, like haskell in a lot of ways
14:38:29 <ftegularius> there are other complications too i think
14:38:45 <ftegularius> too many incompatible implementations, lacking in libs for various applications
14:39:35 <Cale> Scheme almost isn't a language, but an idea about the construction of a certain class of languages.
14:40:01 <syntaxfree> Scheme is plagued by the idea that it's a teaching language.
14:40:08 <syntaxfree> Haskell should be wary of marketing itself that way.
14:40:34 <ftegularius> syntaxfree: nor should it market itself as an "industrial" language though, in my opinion
14:40:54 <syntaxfree> Erlang's marketing is interesting.
14:41:11 <Cale> Research language!
14:41:18 <Cale> Yay!
14:41:27 <syntaxfree> Charity is a research language.
14:41:39 <syntaxfree> Epigram is a research language.
14:41:51 <ddarius> Haskell was meant to be a research language, a practical application language, and a teaching language.
14:42:00 <syntaxfree> Haskell has already come further than these, or Eiffel, or Scala, or, dunno, Planner.
14:42:36 <ddarius> Scala hasn't been around nearly as long as Haskell and Planner got supplanted by Scheme.
14:42:43 <hpaste>  tibbe annotated "is this a monad?" with "(no title)" at http://hpaste.org/549#a1
14:43:16 <syntaxfree> well, maybe.
14:43:18 <qwr> what way scala is better than ocaml? other than running on jvm/.net?
14:43:27 <syntaxfree> But think of the general history of "research languages".
14:43:53 <syntaxfree> Which research language has come as far as Haskell has in real world mindshare? Smalltalk probably surpasses Haskell, yes. But what else?
14:44:00 <Cale> syntaxfree: There's lots of PL research still being done where the primary language of expression is Haskell or a Haskell-to-be
14:44:03 <syntaxfree> (Lisp, but that's unfair)
14:44:08 <goltrpoat> was about to say Lisp
14:44:30 <syntaxfree> ML, too.
14:44:43 <syntaxfree> anyway, research languages don't have half as much useful libraries as GHC does.
14:44:50 <qwr> syntaxfree: prolog?
14:44:50 <Cale> tibbe: Looks a bit like MaybeT IO
14:44:57 <ftegularius> i don't know if ML sees as much as haskell or erlang outside of research
14:45:02 <ftegularius> at least, i would be surprised if that were the case
14:45:08 <Cale> tibbe: MaybeT is conspicuously missing from the libraries.
14:45:09 <syntaxfree> I'm perfectly ignorant about real-world uses of Prolog.
14:45:13 <ftegularius> OCaml probably does, certianly not SML though
14:45:28 <goltrpoat> does fortran qualify as a research language?
14:45:31 <syntaxfree> OCaml isn't much of a research language.,
14:45:36 <syntaxfree> OCaml is more of a compromise.
14:45:42 <ftegularius> syntaxfree: that's exactly my point
14:45:44 <syntaxfree> goltrpoat: only in the sense Matlab is.
14:45:48 <syntaxfree> or LaTeX. Research gets done in it.
14:45:50 <goltrpoat> right, in that sense.
14:45:54 <ftegularius> and it's the only one that sees much popular use
14:46:09 <syntaxfree> well, research gets done in Flash, too.
14:46:22 <syntaxfree> I have a CS friend who does graph colouring stuff in Prolog.
14:46:28 <syntaxfree> He does all his slide presentations in flash.
14:46:53 <goltrpoat> heheh
14:47:47 <goltrpoat> someone needs to address the misconception that flash is purely a research platform, unsuitable for real-world tasks
14:48:06 <tibbe> Cale, I've needed it in three different computations now, I'm going to suggest it be included in the libraries
14:48:12 <Cale> Beamer for presentations!
14:48:19 <goltrpoat> hehe
14:49:12 <Gwern> hey all. I'm looking for a function generate all the permutations of a string w/r/t capitalization, so "Foo" would yield "FOo", "FOO", "FoO", "fOo" etc.
14:49:17 <syntaxfree> He wants animations beyond what Beamer does.
14:49:24 <syntaxfree> I find LaTeX very inconvenient, syntax-wise.
14:49:26 <Gwern> I've found some regular permutations but nothing for capitalization
14:49:29 <Cale> http://latex-beamer.sourceforge.net/beamerexample5.pdf -- just look how beautiful this presentation is :)
14:49:32 <syntaxfree> and Pandoc's S5 support is weird.
14:49:33 <goltrpoat> ok, i give up on yhc.  the thing just refuses to link.
14:49:35 <Gwern> any ideas?
14:49:43 <Cale> Gwern: sure
14:49:48 <syntaxfree> I'd like to be able to write presentations in a simple Markdown-ish format soon.
14:49:57 <sm> restructured text!
14:49:57 <syntaxfree> Anyway, have you seen SPJ's "How to give a talk?"
14:50:11 <syntaxfree> s/?"/"?/
14:50:12 <Cale> > mapM (\x -> [toUpper x, toLower x]) "Hello"
14:50:34 <syntaxfree> SPJ recommends writing slide presentations with a marker pen directly on film.
14:50:44 <Cale> er, where's lambdabot?
14:50:45 <Cale> @bot
14:50:46 <lambdabot> :)
14:50:48 <Cale> hmm
14:50:52 <mahogny> marken pen on film x_x
14:50:55 <Cale> > mapM (\x -> [toUpper x, toLower x]) "Hello"
14:50:55 <Gwern> Cale: maybe I'm misunderstanding, but wouldn't that just generate the lower case and uppercase versions?
14:50:59 <Cale> no
14:50:59 <Gwern> and not all permutations?
14:51:01 <Cale> mapM
14:51:09 <Cale> It's a computation in the list monad.
14:51:19 <Syzygy-> > mapM (\x -> [toUpper x, toLower x]) "Hello"
14:51:19 <Syzygy-> ["HELLO","HELLo","HELlO","HELlo","HElLO","HElLo","HEllO","HEllo","HeLLO","HeLLo","HeLlO","HeLlo","HelLO","HelLo","HellO","Hello","hELLO","hELLo","hELlO","hELlo","hElLO","hElLo","hEllO","hEllo","heLLO","heLLo","heLlO","heLlo","helLO","helLo","hellO","hello"]
14:51:31 <Cale> thanks :)
14:51:33 <Gwern> oh. I see. thanks!
14:51:35 <syntaxfree> someone needs to write a tutorial on permutations and the list monad.
14:51:45 <Gwern> guess I'll have to study up on the list monad then
14:51:54 <syntaxfree> > mapM (\x->[x+1, x-1]) [1..10]
14:52:06 <Cale> lambdabot is being delinquent
14:52:19 <syntaxfree> > mapM (\x->[x+1, x-1]) [1..10]
14:52:19 <Cale> > mapM (\x -> [toUpper x, toLower x]) "Hello"
14:52:25 <Cale> hehe
14:52:36 <syntaxfree> SPJ is my new idol.
14:52:37 <sorear> > mapM (sequence [toUpper, toLower]) "Hello"
14:52:38 <Cale> eval module failed in contextual handler: IRCRaised Data.ByteString.last: empty ByteString
14:52:48 <sorear> @botsnack
14:52:49 <lambdabot> :)
14:52:49 <mbot> :)
14:52:50 <syntaxfree> He managed to scrape himself in CS despite having no PhDs.
14:52:54 <Cale> > 1 + 1
14:52:55 <lambdabot>  2
14:52:56 <mbot>  2
14:53:00 <Cale> hrm
14:53:02 <ftegularius> syntaxfree: yes, that would be nice. when i was first learning haskell i was a bit puzzled about, for instance, using liftM in combination w/ HOFs to generate list permutations
14:53:06 <sorear> doh!
14:53:14 <sorear> > Prelude.mapM (Prelude.sequence [toUpper, toLower]) "Hello"
14:53:16 <lambdabot>  ["HELLO","HELLo","HELlO","HELlo","HElLO","HElLo","HEllO","HEllo","HeLLO","He...
14:53:17 <mbot>  ["HELLO","HELLo","HELlO","HELlo","HElLO","HElLo","HEllO","HEllo","HeLLO","He...
14:53:20 <mbishop> Anyone know this reddit guys "corentin" and what his last name might be?  I want to quote his wonderful reply to the "C is the language of the gods" post :)
14:53:20 <Cale> aha
14:53:22 <syntaxfree> well, liftM = fmap = map on the list monad.
14:53:24 <Cale> that's dumb
14:53:31 <sorear> Cale: it's the Data.Traversable problem again
14:53:33 <Cale> yes
14:53:33 <syntaxfree> > liftM (+1) [1..5]
14:53:35 <lambdabot>  [2,3,4,5,6]
14:53:35 <mbot>  [2,3,4,5,6]
14:53:39 <edwinb> that post is, er, fascinating
14:53:41 <Cale> That needs to be imported qualified.
14:53:49 <Cale> Or else the prelude versions hidden
14:53:52 <syntaxfree> > putStrLn "> 1+1"
14:53:52 <Cale> which is probably better.
14:53:54 <mbot>  No IO allowed
14:53:54 <lambdabot>  <IO ()>
14:54:00 <syntaxfree> > "> 1+1"
14:54:02 <lambdabot>  "> 1+1"
14:54:02 <mbot>  "> 1+1"
14:54:12 <Cale> @part #haskell
14:54:14 <Cale> oops
14:54:15 <syntaxfree> bah. so much for two-lambdabot-metaprogramming.
14:54:27 <sorear> > ap zip (map toUpper) "hello"
14:54:28 <allbery_b> um, ooops
14:54:29 <lambdabot>  [('h','H'),('e','E'),('l','L'),('l','L'),('o','O')]
14:54:35 <sorear> > sequence $ ap zip (map toUpper) "hello"
14:54:40 <ftegularius> syntaxfree: i know that now, but at the time, i found it somewhat confusing. perhaps i'm just dense though ;)
14:54:43 <sorear> > Prelude.sequence $ ap zip (map toUpper) "hello"
14:54:44 <lambdabot>   add an instance declaration for (Monad ((,) Char))
14:54:48 <syntaxfree> I love join on the reader monad.
14:54:51 <syntaxfree> it's perfect for obfuscation.
14:54:54 <syntaxfree> > join (*) 3
14:54:55 <lambdabot>  9
14:54:57 <Cale> wrong kind of pair :)
14:55:18 <sorear> > ap zipWithM (\a b -> [a, b]) (map toUpper) "hello"
14:55:19 <lambdabot>      The lambda expression `\ a b -> ...' has two arguments,
14:55:20 <lambdabot>     but its type...
14:55:32 <sorear> > ap zipWithM (\(a,b) -> [a, b]) (map toUpper) "hello"
14:55:33 <Cale> syntaxfree: It's no longer an obfuscation once you know what it does
14:55:33 <lambdabot>  Couldn't match expected type `a -> b -> m c'
14:55:34 <syntaxfree> @pl \a b -> [a,b]
14:55:34 <lambdabot> (. return) . (:)
14:55:42 <Cale> nor is ap, for that matter
14:55:44 <sorear> @ty zipWithM
14:55:47 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:56:01 <syntaxfree> What is ap on the reader monad again?
14:56:05 <Cale> S
14:56:05 <sorear> S
14:56:07 <Cale> heh
14:56:08 <syntaxfree> @unpl f = ap g
14:56:09 <lambdabot> f e = g >>= \ b -> e >>= \ a -> return (b a)
14:56:15 <Cale> S x y z = x z (y z)
14:56:28 <sorear> > ap (zipWithM (\a b -> [a, b])) (map toUpper) "hello"
14:56:29 <syntaxfree> ah. ap is really "apply".
14:56:30 <lambdabot>  ["hello","hellO","helLo","helLO","heLlo","heLlO","heLLo","heLLO","hEllo","hE...
14:56:32 <Cale> > ap (,) reverse "hello"
14:56:34 <lambdabot>  ("hello","olleh")
14:56:42 <syntaxfree> > ap (+) (+1) 2
14:56:43 <lambdabot>  5
14:56:47 <syntaxfree> cool.
14:56:54 <Cale> > map (ap (,) (join (*))) [1..10]
14:56:56 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
14:57:13 <syntaxfree> cool : D
14:57:24 <syntaxfree> someone needs to write a "neat Haskell tricks" tutorial.
14:57:33 <Cale> > [(k,k^2) | k <- [1..10]]
14:57:35 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
14:57:58 <syntaxfree> @. redo . unpl ap f
14:57:59 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "ap"
14:57:59 <Cale> that's still probably clearer, but ap and join can come in handy :)
14:58:03 <goltrpoat> syntaxfree:  more wackiness:  (ap const const) == S K K = I = id
14:58:05 <Japsu> @hoogle join
14:58:05 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
14:58:06 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
14:58:06 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
14:58:08 <syntaxfree> @. redo unpl ap f
14:58:09 <lambdabot> (\ e -> do { b <- f; a <- e; return (b a)})
14:59:07 <syntaxfree> @type ap
14:59:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:59:26 <syntaxfree> hmm. ap is like un-fmap
14:59:31 <syntaxfree> @type fmap
14:59:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:59:53 <syntaxfree> sounds good for currying monadic functions.
15:00:04 <syntaxfree> ap = liftM fmap?
15:00:12 <ddarius> @type liftM ($)
15:00:14 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
15:00:25 <syntaxfree> @type liftM fmap
15:00:28 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a -> f b)
15:00:38 <ddarius> @type liftM2 ($)
15:00:41 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
15:00:54 <ddarius> @type ap
15:00:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:01:10 <ddarius> Silly application; having two args.
15:01:38 <syntaxfree> uhhh.
15:01:49 <maskd> @type Text.ParserCombinators.Parsec.Prim.parse
15:01:52 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
15:01:57 <maskd> ugh
15:02:17 <syntaxfree> the type is the same, but the behaviour is different.
15:02:23 <syntaxfree> @. redo unpl ap
15:02:24 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b a)})
15:02:29 <syntaxfree> @. redo unpl liftM2
15:02:30 <lambdabot> (\ c d e -> do { b <- d; a <- e; return (c b a)})
15:03:06 <syntaxfree> liftM2 = \c -> c $ ap?
15:03:15 <sorear> syntaxfree: ap and liftM2 ($) are the same
15:03:28 <syntaxfree> source is clearly different.
15:03:39 <syntaxfree> ap looks like liftM2 id
15:03:49 <ddarius> ($) == id
15:03:50 <sorear> @pl ($)
15:03:51 <lambdabot> id
15:09:39 <syntaxfree> true.
15:12:43 <syntaxfree> Haskell needs a market niche.
15:13:06 <syntaxfree> a cleverly chosen one as well.
15:13:25 <syntaxfree> Erlang is making strides because its market niche of telephone networks has a "complex problems" ring to it.
15:13:36 <cybercobra> syntaxfree: isn't that already mathematics/academia?
15:13:57 <mbishop> Erlang and Haskell both have a niche for the upcoming "core races"
15:14:13 <syntaxfree> While Perl will never be taken seriously for much more than scripting, no matter how many features they add.
15:14:35 <syntaxfree> mbishop: the STM x message passing debate is a complex one.
15:14:53 <syntaxfree> I think Erlang has a nose ahead in the concurrent space.
15:15:16 <ctkrohn> do you think that's because Erlang is superior, or because Erlang has "buzz" as being better for concurrency?
15:15:17 <syntaxfree> too much of a "complex" ring to a market niche is bad too.
15:15:18 <ddarius> syntaxfree: It isn't an exclusive choice.
15:15:40 <syntaxfree> Lisp carries the AI curse.
15:15:41 <ftegularius> syntaxfree: haskell may start seeing use in computational lingustics. still, this is research/academia, not industry like erlang
15:16:05 <syntaxfree> yes. The thing is, the answer to "What is Erlang?" is "It's a concurrent language".
15:16:06 <Syzygy-> ftegularius: You already have references for that? Or is it a more or less wild prediction?
15:16:32 <Baughn> I just had the idea of using profiler output to rewrite code to fork execution (of pure functions) at whatever points seem like a good idea. The /idea/ is simple enough, so - has anyone else already done this, or would it be useful for me to try?
15:16:33 <ftegularius> Syzygy: a ph.d student friend of mine is using it for his cross computational linguists/cognitive science work, from what he tells me
15:16:36 <syntaxfree> ctkrohn: I'm talking about market spaces all along.
15:16:45 <goltrpoat> syzygy:  genl?
15:16:48 <Syzygy-> ftegularius: Oooooooooh. If you have an URL, I'd be VERY interested.
15:16:51 <Syzygy-> goltrpoat: Hmmmm?
15:16:51 <ftegularius> Syzygy-: and he claims people in his circles are interested in it
15:17:01 <mbishop> I personally don't want haskell to be involved in marketing in any way :)
15:17:05 <Syzygy-> ftegularius: I'm not surprised. I'm interested. :P
15:17:15 <goltrpoat> syzygy:  http://portal.acm.org/citation.cfm?id=1159842.1159858&coll=&dl=ACM&type=series&idx=1159842&part=Proceedings&WantType=Proceedings&title=Haskell&CFID=15151515&CFTOKEN=6184618
15:17:19 <lambdabot> Title: : Haskell '06, GenI: natural language generation ..., http://tinyurl.com/28lx45
15:17:25 <syntaxfree> I'd personally like Haskell to succeed as a mainstream language.
15:17:25 <Syzygy-> goltrpoat: Thanks!
15:17:29 * EvilTerran tries to resist the urge to leap to perl's defence
15:17:54 <syntaxfree> The computer revolution hasn't happened yet, and it seems to me that it's because of insufficient use of abstraction.
15:18:02 <syntaxfree> Current knowledge workers are manual workers with a mouse.
15:18:08 <EvilTerran> (hey, scripting is important; the featureset required for a good scripting language just isn't compatible with big complex projects)
15:18:23 <cybercobra> could anyone point me to something about how i/o via uniqueness typing works?
15:18:26 <syntaxfree> Haskell for teh win!
15:18:28 <Cale> I'm glad that Haskell's success is growing gradually.
15:18:30 <syntaxfree> for great justice!
15:18:34 <Cale> and not all at once
15:18:59 <ftegularius> Cale: for me, having only started with Haskell about a month ago, it seems fantastically popular already
15:19:10 <syntaxfree> Cale: do you feel it being a fad would detract from its long-term sustainability?
15:19:12 <ftegularius> countless article and tutorials and projects all over the place
15:19:14 <mbishop> "C is the language of the gods? Fine, I'm an atheist."  That quote made my day
15:19:17 <ddarius> @google Clean programming language
15:19:20 <Cale> syntaxfree: It would harm the community.
15:19:20 <lambdabot> http://clean.cs.ru.nl/
15:19:20 <lambdabot> Title: Home
15:19:22 <syntaxfree> I  jumped in the Haskell bandwagon about four months before its explosion.
15:19:33 <goltrpoat> cybercobra:  http://citeseer.ist.psu.edu/wadler90linear.html maybe
15:19:35 <lambdabot> Title: Linear Types Can Change the World! - Wadler (ResearchIndex)
15:19:39 <syntaxfree> Cale: isn't the community firmly rooted in academia anyway?
15:19:40 <ddarius> cybercobra: See Clean.
15:19:57 <Cale> syntaxfree: Currently, it's growing slowly enough that there are always a good number of expert users to spend time tutoring the beginners.
15:20:03 <syntaxfree> I feel the profusion of haskell-likes is harmful.
15:20:08 <syntaxfree> Gofer, Clean, Helium, etc.
15:20:23 <edwinb> I wouldn't call it a profusion...
15:20:23 <sorear> haskell is precariously balanced between too small for improvement and too large for improvement
15:20:24 <goltrpoat> gofer and clean were around before haskell98 though
15:20:25 <Cale> We never have to get fed up and say RTFM.
15:20:35 <ddarius> Actually, I would say it -has- roots in academia, but it has roots elsewhere.
15:20:37 <syntaxfree> Cale: ah, yes. But if it exploded suddenly, free tutoring wouldn't be an issue.
15:20:45 <syntaxfree> People would be taking expensive certification courses in Haskell.
15:20:49 <Cale> and can personally keep up with all the blog entries
15:20:55 <syntaxfree> Free tutoring is only an issue while you're in a grassroots level.
15:20:56 <sorear> Cale: it helps that Haskell is so terse that most helpful answers are *shorter* than RTFM
15:20:58 <syntaxfree> Like Ruby or us are.
15:21:12 <Cale> sorear: hehe
15:21:13 <sorear> like "yes" and "S" and "ap"
15:21:20 <ddarius> syntaxfree: There's Haskell and Clean, and Clean has been around longer than Haskell.
15:21:27 <ftegularius> Cale: that's a very, very good thing. i found that beginning to learn haskell on my own was extraordinarily difficult. rewarding, and certainly worth it, but difficult
15:21:27 <Cale> sorear: But look at the answers that we actually do provide most of the time.
15:21:40 <Cale> I've gone to the trouble of writing essays for single people.
15:21:42 <ftegularius> if there wasn't such an active community around it, i think a lot of people would give up
15:21:43 <syntaxfree> has it? I thought Clean was a haskell-like with monadless IO.
15:21:43 * ddarius has no problem saying RTFM when it is appropriate.
15:21:57 <syntaxfree> Gofer and Helium should go away.
15:22:10 <cybercobra> syntaxfree: yes, it uses whatever uniqueness types are
15:22:29 <Cale> Helium is a neat idea.
15:22:43 <goltrpoat> syntaxfree:  you say that as if there's someone out there actually using gofer
15:22:54 <ddarius> syntaxfree: Gofer is away.  Helium is Haskell. Clean was here first.
15:22:56 <syntaxfree> RTFPPPBYHTPEFI: Read the fucking pre-print paper before you have to pay Elsevier for it.
15:23:07 <Cale> ddarius: Helium doesn't have typeclasses
15:23:11 <syntaxfree> Helium is a crippled Haskell-like.
15:23:13 <ddarius> Cale: Not yet.
15:23:23 <Gwern> ah, permuteStrings f = foldr (++) [] (mapM (\x -> [toUpper x, toLower x]) f) and a main = interact permuteStrings. beautiful! usable in pipes now
15:23:37 <ddarius> But Helium isn't supposed to be an independent language and is not competing with Haskell at all.
15:23:47 <Cale> Right
15:23:57 <syntaxfree> Competition isn't bad.
15:23:58 <Gwern> isn't helium supposed to be a crippled version of haskell easier to teach with?
15:24:02 <Cale> Helium is a learning/teaching implementation of Haskell.
15:24:04 <syntaxfree> Poluting the Haskell-like space is.
15:24:18 <syntaxfree> I mean, I'm glad Charity and Epigram are out there.
15:24:21 <Cale> It's cool because it provides really really good error messages for beginners.
15:24:31 <syntaxfree> Don't let the Haskell boddhisatvas grow fat :)
15:24:32 <ddarius> syntaxfree: In what way?  No one is going to Helium that would be going to Haskell.  The people going to Helium go to Haskell.
15:24:38 <Cale> It would be cooler if we could figure out how to do this with GHC.
15:25:03 <thalassocrac> i tried to use the functino Char.toUpper in hugs; i tried it as that and as toUpper, but it didn't work; does anyone know how i can use that function?
15:25:06 <Cale> I think we need a --beginner
15:25:12 <Cale> -101 or some such :)
15:25:24 <ddarius> DrScheme-like language levels?
15:25:42 <mauke> thalassocrac: how did it not work?
15:25:43 <Cale> thalassocrac: You need to import the Char module. The modern name is Data.Char
15:25:49 <ddarius> Gwern: By the way, foldr (++) [] == concat
15:25:52 <Cale> thalassocrac: Try :also Data.Char
15:25:58 <Cale> and then just use  toUpper
15:26:01 <syntaxfree> as an economist, I feel the cohesiveness of the Java platform helps the language.
15:26:02 <Gwern> ddarius: really? thanks
15:26:13 <ddarius> @src concat
15:26:14 <lambdabot> concat = foldr (++) []
15:26:25 * ddarius pets foldr on the head.
15:26:31 <thalassocrac> thank you, i'll try that
15:26:35 <Gwern> so it does. excellent. some more saved characters
15:26:38 <Cale> sequence = foldr (liftM2 (:)) (liftM return)
15:26:46 <Cale> er
15:26:57 <Cale> sequence = foldr (liftM2 (:)) (return [])
15:27:03 <Cale> right :)
15:27:10 <Cale> liftM0 []
15:27:13 <Cale> hehe
15:27:15 <xerox> Gwern permute = concat . mapM (sequence [toUpper, toLower]))
15:27:20 <syntaxfree> Maybe we need a marketing organism.
15:27:22 <ftegularius> syntaxfree: well, all else being equal, cohesiveness and consistency is always a plus, if only because it reduces some of the incidental complexity for the users
15:27:34 <syntaxfree> Single Haskell Implementation Technology Council.
15:27:41 <syntaxfree> SHITc!
15:27:55 <mbishop> heh
15:28:04 <Gwern> xerox: too many parens there?
15:28:10 <syntaxfree> ftregularius: I'm thinking of what makes nonprogrammers support a language.
15:28:18 <Cale> I kind of like the idea that Haskell is not used by too many people yet. There are still things which we'd like to change which would break lots of code.
15:28:30 <syntaxfree> the standard after Haskell' should be called Single Haskell Implementation Technology ;)
15:28:34 <ddarius> syntaxfree: There is a quite dominant Haskell implementation, and also all of them play very nicely with each other to the point of sharing the same source tree for the libraries.
15:28:46 <syntaxfree> I know that.
15:28:49 <syntaxfree> You know that,
15:28:50 <Cale> I want at least a few more revisions of the Prelude.
15:28:56 <syntaxfree> But that basically depends on ndm being a nice fellar.
15:28:57 <goltrpoat> i'm not sure if there's any particular need to rush things
15:29:06 <syntaxfree> Try to convince a PHB that ndm is a nice fellar.
15:29:11 <Gwern> as a beginner, I'm kind of curious. Cale, what would you want to change?
15:29:37 <Cale> Gwern: I'd remove fail from Monad, Reinstate MonadZero, and create MonadOr
15:29:50 <syntaxfree> I'd like a better numeric prelude.
15:29:51 <Cale> I'd make Functor a superclass of Monad, perhaps insert Applicative
15:29:52 <ddarius> Gwern: The module system, some syntactical issues, some extensions need to be understood better, the record system.
15:29:56 <syntaxfree> I mean, let's wear type clases proudly.
15:30:07 <Syzygy-> syntaxfree: I'm working on that. ;)
15:30:09 <augustss> More power to Cale!
15:30:10 <Cale> Factor abs and signum out of Num into their own class.
15:30:18 <Gwern> just from my experience so far, I'd like a Natural type
15:30:29 <Syzygy-> Though dunno if the NumericPrelude effort'll get merged properly with a next generation Prelude.
15:30:33 <syntaxfree> Syzygy-: there are a few alternate preludes out there, yes, but they're not really being considered as the default.
15:30:33 <augustss> Remove Show (and Eq) as a superclass to Num
15:30:46 <Cale> augustss: I agree with that much :)
15:30:48 <Gwern> (in some numeric stuff I've done, it'd be nice to not have to keep include tests for negative numbers)
15:30:53 <syntaxfree> I mean, go Full Algebraic Ape Mode!
15:30:55 <syntaxfree> FAAP!
15:30:57 <Cale> I don't actually want a *huge* revision of the numerics.
15:30:58 <ddarius> The only thing I fear about an explosive growth in Haskell is the damage it could do to the community.
15:31:06 <Syzygy-> I'm all for full algebraic anything! I like algebra! :)
15:31:13 <Cale> Even though I come from a pure mathematics background
15:31:26 <Gwern> ddarius: there's a saying to the effect that if something isn't growing, its dying
15:31:26 <syntaxfree> if Haskell was to explode, a grassroots community wouldn't be as taxed.
15:31:39 <syntaxfree> We'd also be hired as highly-paid consultants, even the newbs who can't grok monads!
15:31:40 <augustss> Haskell numerics are a bit quirky, but it's mostly ok
15:31:41 <siti> BOOM!
15:31:43 * Syzygy- starts wondering whether a typeclass for Categories isn't a half bad idea. :P I find myself more and more often wanting to encode a category as a type; with conditionalized composition and everything.
15:31:44 <ddarius> Gwern: I didn't say not growing at all.
15:31:55 <cybercobra> yay, i think i get uniqueness typing!
15:31:59 <Syzygy-> There probably is some cooooool type hack to do that already though.
15:32:07 * mahogny thinks the haskell number system is good as is. if we wish to go further then there is a symbolic algebra library for haskell that shows how to organize things
15:32:16 <goltrpoat> cale:  yeah, either move abs and signum out of Num, or make it class (Ring a) => Num a
15:32:17 <syntaxfree> Many type classes are category-like.
15:32:22 <astrolabe> I don't like the fact that (+) has such specific semantics.
15:32:23 <Syzygy-> And how to handle invalid compositions should probably end up varying with application.
15:32:23 <syntaxfree> Ord is category-like
15:32:33 <Syzygy-> mahogny: Which symbolic algebra library are you thinking about?
15:32:40 <augustss> cybercobra: challenge Oleg to do uniqueness typing in Haskell ;)
15:32:42 <Syzygy-> syntaxfree: Isn't Ord a complete order?
15:32:42 <syntaxfree> for a while I thought type classes were very close to categories.
15:32:45 <Pastorn_> what is the lambdabot function that simplifies a function you've written?
15:32:46 <mbishop> Hmm, anyone here have "Introduction to Functional Programming" they are looking to sell/trade?
15:32:58 <cybercobra> augustss: and whom would Oleg be?
15:33:00 <Cale> The numeric classes look like a mess until you realise that they actually do quite well at dealing with practicalities of *computer* implementations of number systems.
15:33:01 <Syzygy-> Pastorn_: @pl ?
15:33:06 <Pastorn_> thanks
15:33:08 <ddarius> augustss: By embedding linear logic into Haskell it probably wouldn't be all that hard.
15:33:09 <Syzygy-> (simplify is a bit too much to say though)
15:33:10 <mahogny> Syzygy-, have it on my computer which currently run the wrong OS. if you can remind me about the names then I will know :)
15:33:17 <Cale> Which involve lots of things that we don't have to consider in mathematics.
15:33:20 <augustss> cybercobra: Oleg is Oleg
15:33:27 <astrolabe> augustss: Why would you ever not want a Num to be an Eq?
15:33:29 <Syzygy-> mahogny: If it's the NumericPrelude, then it's the one I'm contributing to.
15:33:29 <syntaxfree> Screw computers. We've got type classes, why not wear them proudly? :)
15:33:34 <syntaxfree> Full Algebraic Ape Mode!
15:33:36 <mahogny> Syzygy-, no no
15:33:45 <Syzygy-> mahogny: In that case I -really- want to know what it is.
15:33:51 <ddarius> Cale: It isn't -too- bad, but it could use some cleaning up
15:33:55 <Pastorn_> Syzygy-: what does it do then?
15:33:57 <augustss> astrolabe: how about real numbers?  they can't be compared for equality
15:33:57 <mahogny> Syzygy-, alright. hang ont
15:34:04 <ddarius> @where Oleg
15:34:05 <lambdabot> I know nothing about oleg.
15:34:14 <Syzygy-> Pastorn_: It replaces any function with a kind of normal form for it, where only function composition, and no lambdas, occurs.
15:34:16 <Cale> ddarius: yeah, there's just a few minor issues here and there which prevent it from being good for this and that :)
15:34:21 <Syzygy-> Any sufficiently nice function, that is.
15:34:26 <Syzygy-> @who Oleg
15:34:27 <lambdabot> Maybe you meant: echo ghc show what wn
15:34:30 <Syzygy-> Awwww.
15:34:40 <ddarius> @google Oleg Kiselyov
15:34:42 <lambdabot> http://okmij.org/ftp/
15:34:42 <lambdabot> Title: This FTP site
15:35:00 <Cale> Oh, some more controversial changes which I'd make if I were dictator
15:35:01 <astrolabe> augustss: Well, (==) isn't a total function for them.
15:35:10 <mahogny> Syzygy-, docon. came across it when I started writing my own symbolic math library. but docon does not do calculus
15:35:11 <goltrpoat> astrolabe:  because they describe different things.  Num describes a ring, with (for some reason) abs/signum tacked on.  Eq describes an equivalence relation.   one doesn't always imply the other
15:35:12 <Cale> ($) and ($!)'s associativity would flip
15:35:17 <Syzygy-> mahogny: Oooooooh, docon.
15:35:17 <augustss> astrolabe: I'd rather not require it then.
15:35:28 <Syzygy-> I think that's actually quite closely associated to the NumericPrelude.
15:35:36 <ddarius> Cale: Pseudonym is with you on that.
15:35:45 <mahogny> Syzygy-, got an url to numericprelude?
15:35:49 <augustss> astrolabe: furthermore, when doing DSELs it's sometimes makes no sense to define Eq for a Num class.  I have that problem at work.
15:35:51 <Syzygy-> ?where numericprelude
15:35:51 <lambdabot> darcs.haskell.org/numericprelude/
15:35:52 <Cale> (.) and map would become equivalent to the current fmap
15:35:53 <syntaxfree> Cale: use the euro symbol.
15:36:08 <Cale> syntaxfree: nah, that would be odd.
15:36:11 <Syzygy-> syntaxfree: Oh joy: get characterset dependent sourcecode. :P
15:36:18 <syntaxfree> $ is useful as it is.
15:36:28 <Syzygy-> latin1 and latin15 and utf8 all giving different values to that codepoint....
15:36:28 <Cale> Not as useful as it could be
15:36:34 <augustss> astrolabe: If the Eq type was such that the Bool type was overloaded, I'd be much happier
15:36:35 <syntaxfree> There was once a Haskell translation of a Ruby problem contest.
15:36:37 <astrolabe> goltrpoat: I think Eq 'means' equal in some sense, which philosophically at least is defined for elements of any sets, even if it isn't computable.
15:36:43 <Cale> and most of the uses I see can be replaced with (.)
15:36:55 <syntaxfree> They redefined (.) to be flip ($) so to have OO-ish syntax.
15:36:56 <syntaxfree> Uglee.
15:37:06 <Cale> syntaxfree: Oh, I don't mean flipping the parameters
15:37:06 <mahogny> Syzygy-, thanks. seems I might be able to put this to use :) need a symbolic math library for a commercial app
15:37:08 <ddarius> augustss: Yes! That's it! Make all the logical operators work in an arbitrary topos.
15:37:10 <Cale> Just the associativity
15:37:14 <syntaxfree> oh,
15:37:15 <Syzygy-> maho	Nieat.
15:37:21 <Cale> This only matters when you have more than one $ in a row.
15:37:37 <syntaxfree> I tend to think of $ as a quick syntactic shortcut, while (.) has to be treated more carefully.
15:37:45 <augustss> astrolabe: Haskell i about computing.  So we should not have it full of non-computable functions.
15:37:45 <syntaxfree> Yes, but $ only matters when you have more than one anyway!
15:37:50 <Syzygy-> mahogny: I'm very seriously considering expanding NumericPrelude to include an extensive computer algebra system, with support for non-commutative Grbner bases among other things.
15:38:12 <Cale> f $ g $ h $ k x can always be replaced by f . g . h $ k x
15:38:14 <Syzygy-> Would actually like comments on my growing project sketch: http://mpc723.mati.uni-jena.de/~mik/homhaskell.pdf
15:38:39 <Syzygy-> ddarius: Yes! Please!
15:38:56 <Syzygy-> ddarius: If we can figure out a good generic way to represent any topos computationally too, I wouldn't mind at all.
15:39:04 <mahogny> Syzygy-, will have a look at this for later. know any libraries that does calculus?
15:39:05 <Pastorn_> Cale: what is it that prevents that from being written f . g . h . k x ?
15:39:17 <Cale> Pastorn_: that's a different type
15:39:28 <syntaxfree> Cale: you have to think of function types, that's what.
15:39:36 <JohnnyL> :type ap
15:39:39 <Cale> syntaxfree: and you should!
15:39:41 <JohnnyL> @type ap
15:39:42 <syntaxfree> $ is a syntactic convenience that happens to be defineable in Haskell.
15:39:42 <augustss> But there's no need to whine about the Prelude being all bad.  At work I've told people that the rule is to start all modules with 'import Prelude(); import APrelude'
15:39:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:39:44 <Syzygy-> mahogny: Not straight off. Personally quite uninterested in it. :P
15:40:05 <Cale> $ would be more syntactically convenient if it had the other associativity
15:40:09 <mahogny> Syzygy-, bah :) is it just me or does docon seem a bit out of date?
15:40:09 <Syzygy-> augustss: Hehe.
15:40:15 <Syzygy-> mahogny: Probably slightly.
15:40:15 <Cale> we'd be able to remove parens we currently can't
15:40:20 <syntaxfree> breaking code is bad.
15:40:31 <syntaxfree> hey emk.
15:40:35 <Cale> f (long stuff) (long stuff2)
15:40:37 <syntaxfree> what kind of work is it that you're doing with PFP anyway?
15:40:38 <Cale> Would become
15:40:41 <Syzygy-> mahogny: And the NumericPrelude has had quite a bit rapid development the last half year or so, and will continue to be volatile for quite some time to come too.
15:40:46 <Cale> f $ long stuff $ long stuff 2
15:40:49 <Syzygy-> emk == PFP guy?
15:40:50 <Pastorn_> when is the a new haskell standard due?
15:40:50 <astrolabe> augustss: hmmm I don't know.  Better partial functions than broken semantics.
15:41:04 <Cale> Pastorn_: soon, but it standardises existing practice
15:41:05 <Pastorn_> Haskell 98 II - pure vengeance
15:41:11 <dcoutts> @vote OperatingSystem Gentoo
15:41:11 <lambdabot> voted on "Gentoo"
15:41:24 <Syzygy-> @vote OperatingSystem Gentoo
15:41:24 <syntaxfree> I'm torn between going full ape and replacing the current (== x) queries for (>=x) queries so to have proper continuous distributions or  turning it into a monad transformer like Cale suggested on my blog.
15:41:25 <lambdabot> voted on "Gentoo"
15:41:26 <mahogny> Syzygy-, I guess it would be possible to base my stuff on your code instead. at least the responsible guy is in the channel :) I need to add ability to solve ODEs, SDEs and integrals
15:41:28 <dons> does anyone remember if gavino is a troll?
15:41:28 <araujo> dcoutts, ya!
15:41:34 <Syzygy-> :P
15:41:35 <araujo> dons, ?
15:41:39 <Pastorn_> @vote OperatingSystem Ubuntu
15:41:39 <syntaxfree> I basically froze hacking while I think of it and find out about everyone else who's working on it.
15:41:40 <lambdabot> voted on "Ubuntu"
15:41:50 <Syzygy-> mahogny: Oooooooookay. That's quite a bit away from what I'll be doing.
15:41:53 <syntaxfree> @vote OperatingSystem OSX
15:41:53 <lambdabot> "OSX" is not currently a candidate in this poll
15:41:57 <mahogny> Syzygy-, no shit :)
15:41:59 <augustss> astrolabe: partial functions == broken semantics
15:42:05 <Syzygy-> I'm going to concentrate on chain complexes, homotopies and homological algebra. :P
15:42:06 <syntaxfree> @poll-list OperatingSystem
15:42:07 <lambdabot> ["OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
15:42:24 <mahogny> Syzygy-, but I need some of the basic crap anyway and your class system seem sensible
15:42:31 <syntaxfree> @tell emk hey. what kind of work is it that you're doing with PFP anyway?
15:42:32 <lambdabot> Consider it noted.
15:42:44 <allbery_b> ?poll-results OperatingSystem
15:42:44 <syntaxfree> @tell emk I'm torn between going full ape and replacing the current  (== x) queries for (>=x) queries so to have proper  continuous distributions or  turning it into a monad  transformer like Cale suggested on my blog.
15:42:44 <lambdabot> Poll results for OperatingSystem (Open): House=1, GNU/Hurd=0, SuSE=1, Emacs=1, MacOS=1, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=11, Debian=8, Ubuntu=3,
15:42:45 <lambdabot> FreeBSD=3
15:42:45 <lambdabot> Consider it noted.
15:42:53 <syntaxfree> @tell emk  I basically froze hacking while I think of it and find out  about everyone else who's working on it.
15:42:54 <lambdabot> Consider it noted.
15:43:01 <syntaxfree> @vote OperatingSystem MacOS
15:43:02 <lambdabot> voted on "MacOS"
15:43:04 <mahogny> Syzygy-, not looking into details yet, but how hard would it be to add metadata to the formulas as it is set up now?
15:43:05 <dons> http://lambda-software.com/?p=4 <-- asking for "Hopefully other Haskell programmers will take the time to point out improvements to my solutions"
15:43:07 <lambdabot> Title: lambda-software.com &rsaquo; Programming Challenges
15:43:07 <Syzygy-> mahogny: The class system is to a large part due to Henning Thielemann - and if you're going to work on it, you'll want to poke him about it anyway; he has quite a bit of thought put into how he builds the class/module system.
15:43:15 <Syzygy-> mahogny: For docon? Or for numprelude?
15:43:20 <mahogny> Syzygy-, numprelude
15:43:21 <astrolabe> augustss: I should never use the work 'semantics' when talking to computer scientists.
15:43:31 <Syzygy-> What kind of metadata did you have in mind?
15:43:32 <syntaxfree> parametrizeable modules!
15:43:35 <emk> syntaxfree: Hi!
15:43:36 <lambdabot> emk: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:43:52 <Syzygy-> emk: You the PFP guy?
15:44:00 <augustss> astrolabe: why not?  semantics is important.  I happen to think partial functions are bad.  not everyone agrees.
15:44:00 <syntaxfree> not the original one, no.
15:44:01 <mahogny> Syzygy-, I need to store down for example how to discretize differentials
15:44:08 <glguy> ?vote OperatingSystem OpenBSD
15:44:09 <lambdabot> voted on "OpenBSD"
15:44:22 <syntaxfree> mahogny: that almost sounds like a monad.
15:44:24 <goltrpoat> mahogny:  did you see that snippet on cafe a while back that solved nonlinear ODEs in terms of power series?
15:44:26 <Cale> ?vote OperatingSystem Ubuntu
15:44:27 <lambdabot> voted on "Ubuntu"
15:44:28 <augustss> ?vote OperatingSystem NetBSD
15:44:29 <lambdabot> voted on "NetBSD"
15:44:30 <Syzygy-> mahogny: I didn't understand that statement. :/
15:44:39 <augustss> ?vote OperatingSystem MacOS
15:44:39 <syntaxfree> emk: so, it eventually struck me that discrete distributions have very limited uses.
15:44:40 <lambdabot> voted on "MacOS"
15:44:41 <astrolabe> augustss: What I meant is that (==) should correspond as closely as possible to the mathematical sense of 'equals', which is a well defined notion for the reals.
15:44:41 <mahogny> syntaxfree, ...scary :o
15:44:42 <Syzygy-> goltrpoat: That sounds a little bit like Henning juggling.
15:44:51 <emk> Syzygy-: Just another random programmer.. :-)
15:44:51 <Cale> ?vote OperatingSystem Debian
15:44:52 <Syzygy-> He recently implemented power series in two variables, he told me.
15:44:52 <lambdabot> voted on "Debian"
15:44:53 <goltrpoat> -nod-
15:44:54 <mahogny> goltrpoat, no. but it sounds like I should look it up
15:45:00 <augustss> astrolabe: not for constructive reals
15:45:06 <syntaxfree> emk: I'd like to have staircase continuous distributions instead.
15:45:24 <siti> > 1.0 == 1.0000000000000001
15:45:24 <Cale> I just wish that Henning didn't have insane conventions.
15:45:25 <lambdabot>  True
15:45:34 <Syzygy-> Cale: What do you find insane?
15:45:50 <mahogny> Syzygy-, I guess I can disclose that I am writing a system to solve coupled (S)(P)DEs using numerical methods. so I want the ability to store down in more detail how the solver should attack the equations if needed
15:45:52 <Cale> Syzygy-: the whole "exactly one type per module and it's always named T" thing
15:46:01 <emk> syntaxfree: I gotta run in just a few minutes, but for starters, I'm looking at "A Probabilistic Language based upon Sampling Functions" by Park, et al.
15:46:07 <Cale> also, he's vehemently opposed to syntax sugar of any kind
15:46:08 <ddarius> astrolabe: A well defined uncomputable notion.
15:46:17 <Syzygy-> Cale: Ah, that.
15:46:19 <syntaxfree> hmm. sampling functions.
15:46:28 <syntaxfree> That's quite a different statistical background from mine.
15:46:42 <thorat> ?vote OperatingSystem Debian
15:46:43 <lambdabot> voted on "Debian"
15:46:45 <syntaxfree> I'm strictly likelihood-school with light bayesian overtones.
15:46:48 <ddarius> Cale: Was he an SML programmer at one time?
15:46:55 <Syzygy-> Cale: I might end up challenging him about it, possibly. Depends a little on how much that ends up trapping my own code.
15:46:55 <astrolabe> augustss: ok, maybe it's not, but I still think (==) should correspond to it.
15:47:01 <emk> There's a bunch of other work I'm not quite yet ready to release (there's bugs in my math, still), but basically, it involves generalizing over a whole zoo of probability monads.
15:47:11 <emk> A small zoo, granted. ;-)
15:47:13 <syntaxfree> I see.
15:47:17 <syntaxfree> We should work together.
15:47:26 <Syzygy-> :)
15:47:30 <emk> Agreed.
15:47:38 <Syzygy-> #haskell - where great minds come together
15:47:40 <emk> Is there a way I can reach you privately?
15:47:41 <syntaxfree> do you have google talk/jabber or MSN?
15:47:44 <Syzygy-> #haskell - code by consensus
15:48:01 <Syzygy-> #haskell - you'll never want -O3 again
15:48:03 <syntaxfree> I basically leave IM open all day, it's the easiest way to reach me.
15:48:20 <mahogny> Syzygy-, anyway, I will look into that pdf and your codebase. I'll keep in touch *zzz*
15:48:23 <syntaxfree> MSN = msn messenger.
15:48:27 <Syzygy-> mahogny: Sounds good.
15:48:32 <emk> syntaxfree: What's your Jabbar address?
15:48:38 <syntaxfree> dnavarro@gmail.com
15:48:44 <emk> Ah, thanks!
15:48:46 <Syzygy-> My codebase is basically already on darcs.haskell; the pdf will keep developing during the coming week.
15:48:52 <syntaxfree> ndm is for some reason there. Maybe because I sent him mail once.
15:48:56 <syntaxfree> emk: what's yours?
15:49:00 <augustss> astrolabe: There's no sensible way to use comparisons for real numbers on a computer (i.e., constructive reals)
15:49:14 <emk> syntaxfree: I'll e-mail it.
15:49:17 <emk> One sec.
15:49:42 <astrolabe> augustss: There is for a lot of cases, just not in the general case.
15:50:33 <sm> ack.. a where clause in an if-then clause after a let-in can't see the let assignments ?
15:50:34 <astrolabe> I mean, a computer can tell that  sqrt(5) > 2 for example
15:50:37 <augustss> astrolabe: and are you going to provide a proof that you'll never hit the general case?
15:50:48 <syntaxfree> emk: thanks!
15:50:59 <Syzygy-> Time to go home and sleep.
15:51:01 <astrolabe> augustss: shouldn't that be up to the caller of the function?
15:51:04 <Syzygy-> Or ... way past time, really.
15:51:06 <Syzygy-> ?time Syzygy-
15:51:09 <lambdabot> Local time for Syzygy- is Mon Feb 19 00:49:12 2007
15:51:30 <syntaxfree> astrolabe: that's why we have Maybe.
15:51:46 <augustss> astrolabe: Oh, I'd have no problem with a comparison that took a proof that the comparison would terminate as an extra argument.
15:52:15 <augustss> astrolabe: but that's not ==
15:52:23 <astrolabe> syntaxfree: I'm not sure Maybe is useful here
15:52:25 <Syzygy-> Partial order: compare :: a -> a -> Maybe Ordering ? :)
15:52:49 <astrolabe> augustss: So, do you think there should be no partial functions?
15:52:59 <augustss> Syzygy-: And when would you return Nothing?  When you've tried for a while with no result?
15:53:05 <augustss> astrolabe: yes
15:53:07 <syntaxfree> Maybe "sounds" wrong. You could always write
15:53:17 <syntaxfree> data Semicomputable a = ForSure a | Dunno
15:53:26 <Syzygy-> augustss: I'm talking about partial orders in the po-set sense; where you'd have welldefined pairs of elements that simply are not comparable.
15:53:28 <dons> ah, gavino is gschuett. and now he's trolling the happs mailing list.
15:53:54 <Syzygy-> Gone.
15:54:01 <augustss> astrolabe: Well, I'd allow partial functions, but probably in a monad or something to make sure non-termination doesn't leak.
15:54:06 <EvilTerran> s/Dunno/FileNotFound/ ;]
15:54:07 <astrolabe> augustss: I don't know if that is practical, I guess not with current technology, but it certainly doesn't seem to accord with the design decisions made for haskell.
15:54:58 <edwinb> I'd love to see a language like that - total, but with escapes for partiality
15:55:05 <augustss> astrolabe: you asked me what I'd like :)
15:55:08 <emk> syntaxfree: I sent off a short e-mail with my contact information and a pointer to the paper by Park, et al.
15:55:13 <edwinb> It's on my list of things to do in my Copious Free Time
15:55:16 <ddarius> sm: That's syntactical?
15:55:39 <emk> syntaxfree: More later, and I look forward to working with you on this stuff...
15:55:42 <sm> ddarius: how do you mean ?
15:55:58 <syntaxfree> thanks!
15:55:58 <astrolabe> augustss: true :),
15:56:04 <syntaxfree> talk to you later then. :)
15:56:26 <ddarius> sm: where is not an expression so it cannot occur in an if-then-else expression or a let expression.
15:56:37 <dcoutts> wow, failed to parse 7 out of 4406 files in the linux kernel and all those failures were due to the same reason which I think I've now fixed. :-)
15:56:58 <dons> wow. that's really cool
15:57:10 <dcoutts> @yarr!
15:57:11 <lambdabot> Aye Aye Cap'n
15:57:21 <Nafai> dcoutts: Awesome!
15:57:23 <dcoutts> dons, now to retry glibc
15:57:36 <dcoutts> that needs nested functions to parse fully
15:57:43 <dcoutts> but I'm not sure if I care about them
15:57:57 <dcoutts> no one uses nested functions in C
15:58:29 <EvilTerran> <_<  >_>
15:58:32 <SamB> mostly because they suck
15:58:36 <EvilTerran> I've used 'em...
15:58:40 <astrolabe> but they could
15:58:46 <astrolabe> see :)
15:58:52 <dcoutts> indeed, they don't outlast the call they're defined in them
15:58:52 <SamB> also, they are a rare feature...
15:58:52 <sm> ddarius: aha.. do you have a simple guideline for where I can use where ?
15:59:00 <augustss> astrolabe: but to return to Haskell and practical matters.  I have very good examples where I can define Num, but not Eq for a DSEL.  And Eq is a totally gratuitous superclass of Num.
15:59:04 <sm> only at the end of an equation ?
15:59:58 <astrolabe> augustss: On consideration, that seems sensible.
16:00:03 <EvilTerran> i think it was because i was being sloppy and it was mildly better than the alternative (being global variables)
16:00:41 <sm> ddarius: and also, would this mean that indentation of where doesn't matter ?
16:00:56 <ddarius> sm: Where scopes over guards and otherwise is attached to each case of a function definition.
16:01:21 * araujo had to abort the gtk2hs compilation again
16:01:32 <dcoutts> araujo, oh?
16:01:46 <araujo> dcoutts, don't know what happens :-(
16:01:52 <ddarius> sm: No the indentation of where itself doesn't really matter as long as it doesn't stop an earlier block, i.e. as long as it's at least as indented as the function it belongs to.
16:01:55 <augustss> dcoutts: No one uses nested functions in C because there are none. :)
16:02:14 <dcoutts> augustss, hmm?
16:02:24 <dons> ?where jhc
16:02:24 <lambdabot> http://repetae.net/john/computer/jhc/
16:02:37 <augustss> dcoutts: you said "no one uses nested functions in C"
16:02:43 <ftegularius> augustss: i think they were introduced into C89 or C90, but they only have partial compiler support
16:03:05 <dcoutts> augustss, GNU C has it as an extension, but it's rarely used
16:03:08 <EvilTerran> there aren't any in K&R C, that's true, but they're in GCC, and i'm pretty sure they're in C99
16:03:14 <mauke> not in C99
16:03:19 <dcoutts> EvilTerran, no, not C99
16:03:22 <augustss> dcoutts: I know it's a GNU C extension
16:03:27 <sm> ddarius: thank you.. I guess I'm still a little puzzled why it didn't work in this case then
16:03:44 <araujo> dcoutts, can i query where it gets stuck the installation?
16:03:51 <dcoutts> augustss, ok I should have said "(almost) no one uses nested functions in (GNU) C" :-)
16:03:51 <hpaste>  sm pasted "where doesn't see subaccts" at http://hpaste.org/550
16:04:03 <dcoutts> araujo, look at the build output
16:04:17 <ftegularius> augustss: yeah, on second thought, i think you're right, it is a GNU C extension i think
16:04:36 <EvilTerran> i stand corrected
16:04:41 <dcoutts> ftegularius, I've been reading the GCC C parser, they're definitely a GNU extension
16:04:48 <araujo> dcoutts, yes? ....
16:05:15 <dcoutts> araujo, you don't need me to tell you this, just look for where it first goes wrong
16:05:28 <xic> cool hsc2hs works
16:05:36 <dcoutts> araujo, do you have the full build output?
16:05:41 <araujo> dcoutts, that's what confuses me ..... because the output shows nothing
16:05:48 <araujo> dcoutts, yes
16:05:55 <hpaste>  ddarius annotated "where doesn't see subaccts" with "this is how it parses" at http://hpaste.org/550#a1
16:06:08 <araujo> dcoutts, the process just gets into kind of an infinite loop
16:06:37 <dcoutts> araujo, you mean the build loops? at what point?
16:06:41 <xic> dcoutts: do you know if it's possible that ghc can inline c functions?
16:06:48 <ddarius> dcoutts: I thought you could define local functions in standard C, there just was almost no point except keeping the namespace clean.
16:06:56 <dcoutts> xic, it can't, though gcc might
16:07:03 <dcoutts> ddarius, nope
16:07:16 <Saulzar> I don't think it would be possible unless it was the linker doing the inlining
16:07:38 <ddarius> dcoutts: Is it just C++ that lets you then?
16:07:53 <dcoutts> ddarius, perhaps, but I didn't know it was standard C++ either.
16:08:03 <mauke> no nested functions in C++
16:08:04 <xic> dcoutts: so i can't call a c function that is declared inline?
16:08:29 <dcoutts> xic, depends on if it has an external definition
16:08:42 <dcoutts> xic, there needs to be a linker name for it
16:08:45 <ddarius> Perhaps it was a Borland extension, but I'm pretty sure I did it in at least C++, but it was almost completely pointless because the local function didn't have access to any of the outer variables.
16:09:01 <xic> dcoutts: it doesn't it is declared inline with it's body in a header file
16:09:05 <dcoutts> ddarius, right, the gcc version allows access to the outer vars
16:09:05 <siti> I think with c99 it's meant to do function inlining with the inline keyword, but gcc only implements static inlining, e.g. same module inlining not cross module...
16:09:23 <ddarius> dcoutts: I know that standard C doesn't have local functions that close over variables.
16:09:29 <dcoutts> siti, if it's defined inline in the header file then gcc will inline
16:09:55 <siti> cross module?
16:10:00 <dcoutts> xic, in that case you can only call it if you compile -fvia-C
16:10:19 <dcoutts> xic, or if you compile your own version in a .c file and link to that
16:10:38 <xic> dcoutts: hm... if i compile -fvia-C will the function actually be inlined?
16:10:51 <dcoutts> xic, that depends on gcc, it might.
16:11:18 <ddarius> Incidentally, sm, why not just stick all those definitions in the let into the where and also use guards?
16:12:34 <syntaxfree> Is C really ideal in the intermediate-compiler-language space?
16:12:40 <goltrpoat> in c++, you can nest a class definition inside a function, and write methods for it
16:12:40 <goltrpoat> which indirectly provides nested functions
16:12:41 <sm> thanks.. I'd like to just grok why this where doesn't see subaccts first
16:12:50 <goltrpoat> eg, int fac(int n) { class fachelper { public: int operator (int k) { return (k <= 1) ? 1 : (*this)(k-1); } }; return fachelper(n); }
16:12:52 <xic> dcoutts: gtk2hs uses a code generator that generates haskell code, right?
16:12:53 <goltrpoat> or some such.
16:12:55 * sm stares at it
16:12:57 <goltrpoat> er.. insert k* somewhere in there
16:12:58 <dcoutts> xic, yep
16:13:12 <bd_> syntaxfree: probably not, but at least most platforms have a C compiler
16:13:16 <mauke> goltrpoat: but local classes can't be used in templates :(
16:13:17 <dcoutts> xic, well, it generates .chs files
16:13:26 <dcoutts> xic, so it still goes via c2hs
16:13:26 <xic> dcoutts: what's the difference between chs and hsc?
16:13:41 <dcoutts> xic, different FFI preprocessors, c2hs or hsc2hs
16:13:54 <xic> dcoutts: which one is better? i've started to use hsc2hs...
16:13:58 <syntaxfree> bd_: ah, I don't mean "language to write compilers in".
16:14:03 <syntaxfree> I mean, "language to compile to"
16:14:24 <dcoutts> xic, depends on what you're doing, hsc2hs is great for making Storable instances, c2hs is great for binding functions.
16:14:28 <augustss> syntaxfree: C is far from ideal as an intermediate language
16:14:28 <bd_> Right; with C you get a decent-ish machine-code generator on most platforms
16:14:29 <ftegularius> syntaxfree: i have heard good things about C-- for those sorts of applications
16:14:36 * syntaxfree dreams of a Haskell -> JavaScript compiler.
16:14:39 <bd_> Clearly your compiler should be written in the source language itself :)
16:14:43 <dcoutts> syntaxfree, see yhc
16:14:43 <sm> I had the wrong impression the where applied only to one of the in clauses, that's why I started the let. And I picked up that impression from seeing it apply only to one case clause. Now I see that a function/case clause are similar, and where applies to the one it's in
16:15:07 <syntaxfree> @see yhc
16:15:08 <lambdabot> I haven't seen yhc.
16:15:13 <dcoutts> @where yhc
16:15:13 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
16:15:27 <dcoutts> yhc has a javascript backend
16:15:45 <dcoutts> and ones for C, Java, Python etc
16:15:48 <xic> dcoutts: what's better for a library that has lots of functions that take function pointers, and i want to be able to pass in haskell functions?
16:15:54 <sm> ok I think get it.. where doesn't see what's in the let, because the let scope is contained within the where scope
16:15:55 <dcoutts> xic, c2hs.
16:15:55 <hpaste>  ddarius annotated "where doesn't see subaccts" with "how I would write it" at http://hpaste.org/550#a2
16:15:58 <syntaxfree> WHAT?
16:16:15 <syntaxfree> YOU MEAN THERE *IS* A WAY TO COMPILE HASKELL INTO JAVASCRIPT?
16:16:23 <xic> dcoutts: is this the reason you chose c2hs for gtk2hs, because of all of the callbacks?
16:16:33 <EvilTerran> whoa there, loud howard
16:16:55 <allbery_b> YES.
16:16:58 <allbery_b> :)
16:17:12 * syntaxfree drops dead
16:17:15 <mauke> I CAN'T HEAR YOU OVER THE SOUND OF HOW AWESOME I AM
16:17:19 <dcoutts> xic, c2hs enforces type safety on foreign calls
16:17:40 <allbery_b> he's just excitable, we already knew that :)
16:17:53 <dcoutts> syntaxfree, yes,  yhc compiles Haskell to bytecode and yhc has a bytecode interpreter written in javascript
16:18:18 <xic> dcoutts: hm... my library is a c++ library, so i'm making a c wrapper around it, and i'm interfacing that to haskell with hsc2hs.... but maybe this isn't the best approach :|
16:18:26 <allbery_b> thought there was also a js code generator
16:18:37 <dcoutts> xic, c2hs gives you more type safety on calls, that's a big win.
16:18:53 <allbery_b> I seem to recall runnng across a blog post showing sample javascript generated by it
16:18:56 <syntaxfree_dead> dcoutts: cool. What other bytecode interpreters are there?
16:19:33 <dcoutts> syntaxfree_dead, there's the standard C one, there's one written in Java and there's a yhc bytecode to .NET bytecode converter.
16:19:35 <syntaxfree_dead> hmm. is yhc written in Haskell?
16:19:37 <goltrpoat> doesn't gcc use some sort of a lisp-like RTL as the IL?  that kind of sounds like a nice build target
16:19:39 <dcoutts> yes
16:19:46 <syntaxfree_dead> wow. a Java interpreter.
16:20:02 <xic> dcoutts: what do you think of the idea of using a code generator to generate the c wrapper?
16:20:07 <allbery_b> lispish syntax, which doesn't say much.  *not* lisp-like
16:20:08 <syntaxfree_dead> how far are we from selling Haskell code as if it was written in Java?
16:20:18 <goltrpoat> allbery:  ah
16:20:22 <Pseudonym> List-like RTL sounds like a contradiction in terms.
16:20:30 <hpaste>  sm annotated "where doesn't see subaccts" with "version 2" at http://hpaste.org/550#a3
16:20:34 <Pseudonym> Assuming that means what I think it means.  RTL == register transfer machine.
16:20:38 <syntaxfree_dead> ndm++
16:20:41 <dcoutts> xic, tricky, what's the source for the generator to use? you don't want to have to parse C++ :-)
16:20:45 <Pseudonym> Sorry, lisp-like RTL.
16:20:56 <goltrpoat> pseudonym:  yeah.  register transfer language
16:21:02 <dcoutts> goltrpoat, Pseudonym it uses GIMPL iirc
16:21:04 * sm thinks: now for another sally on the guards
16:21:11 <Pseudonym> How can a RTL be lisp-like?
16:21:16 <xic> dcoutts: no, i'd probably write the source as either xml or directly in haskell as a haskell data structure
16:21:18 <Pseudonym> Unless it's encoded using s-expressions or something.
16:21:30 <dcoutts> xic, that makes more sense
16:21:48 <dcoutts> Pseudonym, they converted from an RTL style to this GIMPL thing
16:22:05 <Pseudonym> Ah, OK.
16:22:23 <dcoutts> http://gcc.gnu.org/onlinedocs/gcc-4.0.4/gccint/GIMPLE.html
16:22:25 <lambdabot> Title: GIMPLE - GNU Compiler Collection (GCC) Internals
16:23:38 <augustss> oh, is gcc no longer rtl?
16:24:22 <dcoutts> augustss, they've nearly exorcised rtl from gcc
16:24:28 <dcoutts> it's not quite gone, but very nearly
16:25:11 <dcoutts> they've been converting their various optimisation algorithms over from rtl to gimple + SSA stuff over the last few major releases
16:25:24 <Pseudonym> Looks like they've only got RTL for the truly low-level stuff.
16:25:31 <goltrpoat> ah
16:25:34 <Pseudonym> Like register allocation or branch scheduling.
16:25:41 <Darius> sm: Why bother having subs and subacctname that local?
16:25:51 <xic> dcoutts: btw, is it possible to call a c++ from haskell?
16:26:04 <dcoutts> xic, not easily due to name mangling
16:26:25 <xic> dcoutts: is there a module that can handle this?
16:26:25 <dcoutts> xic, if you can make a C++ function look like a C function then yes
16:27:03 <dcoutts> xic, no, there's no module, it'd have to be a FFI extension
16:27:12 <xic> :(
16:27:29 <dcoutts> but I think C++ can export C linker names
16:27:41 <dcoutts> so that C progs can call C++ libs
16:27:42 <Pseudonym> extern "C"
16:27:47 <dcoutts> yep, that :-)
16:27:58 <ddarius> sm: Incidentally, I'd also drop many of the superfluous parentheses.  Function application always has highest precedence.
16:28:01 <xic> yeah, but then you lose all of c++'s features :)
16:28:11 <dcoutts> xic, well only in the interface
16:28:19 <sm> Darius: they are going to be used only for the else clause, and might not be valid otherwise (branches would be empty and head would fail)
16:28:30 <dcoutts> xic, that's how you make a wrapper
16:28:31 <ddarius> sm: Haskell is lazy...
16:28:45 <xic> it would be really cool if there was a FFI extension that had good c++ support: classes, virtual functions, and exceptions. and templates would be a bonus
16:28:48 <Pseudonym> If you want C++, you know where you can find it.
16:28:58 <Pseudonym> Well, there's a COM binding.
16:29:05 <Pseudonym> Does it work nicely with XPCOM?
16:29:06 <orbitz> xic: sounds like it'd turn haskell to crap
16:29:09 <dcoutts> xic, you'd be lucky, that's a lot of stuff.
16:29:10 <Pseudonym> Anyone know?
16:29:14 <xic> orbitz: eh?
16:29:27 <syntaxfree_dead> are you from that orbitz company?
16:29:31 <orbitz> no
16:30:11 <ddarius> Talking to C++ is possibly one of the most painful things about it.  Even when you are trying to talk to it from C++.
16:30:23 <sm> ddarius: hmm, you're saying no need to confine that special case to the else clause, because it will never be evaluated if not needed
16:30:24 <mbishop> Anyone else think the "O" in the orbitz logo is an homage to the Eval Apply loop?
16:30:31 <ddarius> sm: Exactly.
16:30:49 <sm> excellent point
16:31:16 <Pseudonym> Modifying Haskell to work with C++ seems like a waste.  Much better for C++ and Haskell to meet half-way.
16:31:17 <sm> if a little weird-feeling.. it seems the logic loses a little clarity
16:31:30 <orbitz> or just od't use C++:)
16:31:33 <Pseudonym> Then if every language could do that, we'd be set.
16:31:44 <sm> I got used to it just now. :)
16:32:22 <sm> ddarius: so then, may I also ask how you'd apply guards here ?
16:32:25 * ddarius wonders how many times he writes code that wouldn't evaluate in a strict language without realizing it.
16:32:59 <ddarius> sm: I have an example on the page with how I'd write it (as far as coarse structure goes).
16:33:24 <sm> super.. thx
16:33:42 * ddarius rarely uses let of if.
16:33:51 <ddarius> s/of/or/
16:36:19 <iseff> hey guys, im a huge haskell n00b.. was wondering if there are any decently sized web sites running on some sort of haskell framework
16:36:54 <orbitz> iseff: will that help you learn haskell faster?
16:37:01 <bd_> @hoogle Int -> ByteString
16:37:02 <lambdabot> No matches, try a more general search
16:37:22 <dcoutts> bd_, pack . show  ?
16:37:31 <iseff> orbitz: nope, but i just want to know if it's even a decent idea
16:37:42 <bd_> dcoutts: yeah, I was wondering if there was an optimizing version like readInt
16:37:47 <dcoutts> bd_, nope
16:37:51 <bd_> iseff: hpaste.org runs on HAppS
16:39:25 <Pseudonym> iseff: It depends if you mean "decent amount of data handled", "decent amount of complexity" or "decent amount of traffic".
16:39:53 <Pseudonym> IME, most people who ask that question don't actually have a decent amount of anything to serve from their web site. :-)
16:40:11 <syntaxfree_dead> hmm.
16:40:15 <ftegularius> zing
16:40:20 <syntaxfree_dead> yhc needs scons. I installed scons, but where is it?
16:40:23 <fuzan> i'm looking for some decent parallelization tutorials, yet I can't find any. anyone have any favorites?
16:40:39 <iseff> sure, i was being intentionally vague because im just looking for very general examples.. like hpaste for example
16:40:50 <orbitz> fuzan: concurrency or parallezation?
16:41:00 <fuzan> orbitz: either.
16:41:11 <orbitz> fuzan: haskell.org has a few of varying quality
16:41:17 <fuzan> looking...
16:41:29 * syntaxfree_dead has scons problems!
16:41:36 <fuzan> syntaxfree_dead: what distro?
16:41:46 <i_have_scons_pro> fuzan: distro?
16:42:04 <fuzan> what distribution?
16:42:06 <orbitz> i_hate_scons: what OS?
16:42:10 <i_hate_scons> ah. OS X.
16:42:22 <fuzan> no idea... how'd you install?
16:42:25 <orbitz> how did you install scons?
16:42:29 <orbitz> did you put it in yoru path?
16:42:29 <fuzan> :)
16:42:29 <i_hate_scons> I ran setup.py install.
16:42:43 <fuzan> it's probably not in his path
16:42:47 <orbitz> well where did tha tinstall it? did you look at setup.py
16:43:00 <orbitz> have you made any slight attempt at problem solving?
16:43:06 <i_hate_scons> d'oh.
16:43:16 <i_hate_scons> setup.py just built a lot of files that are needed for building.
16:43:28 <fuzan> it's probably in /usr/local/bin/
16:43:34 <i_hate_scons> yes. I tried :t scons, to no avail ;)
16:43:44 <orbitz> huh?
16:43:45 <i_hate_scons> nah, it hadn't built it at all. It just built a lot of files needed for building.
16:43:51 <i_hate_scons> :t scons
16:43:53 <lambdabot> Not in scope: `scons'
16:44:02 <i_hate_scons> :t (s:)
16:44:05 <lambdabot> Not in scope: `s'
16:44:08 <allbery_b> it works like perl, setup.py then make and make install?
16:44:09 <fuzan> scons is an alternative to make written in python ^_^
16:44:16 <i_hate_scons> I know!
16:44:24 <i_hate_scons> I'm joking.
16:45:07 <orbitz> why not just install with darwin port
16:45:19 <fuzan> or spend 30 seconds looking in setup.py ?
16:46:27 <i_hate_scons> I shouldn't need to know python to install a Haskell compiler o__O
16:46:38 <i_hate_scons> Error. libgmp must be installed made accessible before you can compile Yhc.
16:46:43 <i_hate_scons> what *is* libgmp?
16:46:53 <ddarius> Meh. I have coded in Python without knowing it.
16:47:00 <mauke> swox.com/gmp
16:47:09 <ddarius> Arbitrary precision numbers.
16:47:33 <allbery_b> ghc usually has gmp hidden inside it, or requires libgmp to be installed
16:47:46 <i_hate_scons> yes, but, but, Python is evaluated *in order*
16:47:51 <fuzan> I've heard a lot of complaints about yhc lately :)
16:47:59 <i_hate_scons> how are you supposed to even *handle* that? ; )
16:48:14 <i_hate_scons> yay for normal order evaluation!
16:48:46 <ftegularius> i_hate_scons: well, take solace in the fact that at least you'll be familiar with one aspect of the language, list comprehensions ;)
16:50:47 <dons> syntaxfree: I'd just use ghc until they fix the build script
16:50:50 <dons> i could't get yhc built either
16:50:54 <dons> and I even had scons!
16:53:15 <goltrpoat> yeah, i kept getting linker errors towards the end of the build
16:53:33 <syntaxfree> dons: I'm interested in the javascript backend.
16:53:39 <syntaxfree> I mean, I'm learning javascript to get something done.
16:54:07 <syntaxfree> grrr. I even installed the latest libgmp.
16:54:27 <fuzan> sounds like you need a package manager.
16:55:31 <fuzan> dons: what's your favorite concurrent piece of haskell code?
16:55:57 <dons> hmm. the chameneos benchmark on the shootout is nice (fast!). for beauty, probably the stuff in the beautiful concurrency paper.
16:56:26 <yax1> i'm hacking some C to relax my poor brain
16:56:55 <dons> heh
16:57:00 <fuzan> dons: Simons?
16:57:09 <dons> fuzan: Simon's paper, yeah.
16:58:22 <fuzan> are semicolons coming back into popularity?
16:58:44 <fuzan> all of these concurrency papers are full of semicolon usage.
16:59:07 <dons> i'm not sure what the story with that is.
16:59:29 <dons> maybe it helps readers not worry about whitespace when writing the code out by hand?
16:59:35 <dons> (since its aimed at non-haskell readers)
16:59:51 <fuzan> i mean, if you're attempting to make your code C-like you'd place them on the right-hand side of the statement.
17:00:00 <fuzan> i suppose.
17:00:07 <fuzan> helps with refactoring too i'm sure
17:00:15 <fuzan> i do waste a lot of time re-indenting
17:00:24 <syntaxfree> I use semicolons all the time.
17:00:30 <syntaxfree> Significant whitespace is evil.
17:00:46 <fuzan> sounds like you do like syntax.
17:00:51 <allbery_b> no wonder he's allergic to python :)
17:01:14 <syntaxfree> I mean, significant whitespace is really evil.
17:01:24 <syntaxfree> I imagine a lot of people turn Haskell away because of SW.
17:01:26 <Pseudonym> A lot of the use of semicolons is to save vertical space in papers.
17:01:38 <dons> works for humans. works for me.
17:01:48 <Pseudonym> syntaxfree: As much as I respect your imagination, I'd like to see hard data on that.
17:01:52 <dons> i encourage my competitors to use { ;;;;; }
17:02:16 <araujo> SW might be hard to follow at first when learning it; but then it becomes very natural
17:03:09 <syntaxfree> SW is easy to follow and visually pleasing.
17:03:12 <syntaxfree> It's hard to produce!
17:03:16 <araujo> Something you don't need to worry about. Somethng you can't say about semicolons
17:03:17 <xpika> whats an easy example of constructing a datatype with records?
17:03:24 <syntaxfree> I dropped Haskell in frustration once because of YAHT's stupidity.
17:03:29 <xpika> More { foo,bar :: Int }
17:03:34 <xpika> More {foo = 2,bar = 10})
17:03:43 <syntaxfree> It (a) introduces IO too early with a contrived looping example and (b) that example has complex SWS.
17:04:09 <fuzan> xpika: that's correct.
17:04:18 <Pseudonym> I don't find SW hard to produce at all.
17:04:29 <Pseudonym> Both text editors that matter do it for you for the most part.
17:04:38 <syntaxfree> SEE does it too.
17:04:43 <syntaxfree> but I don't *see it*
17:04:45 <syntaxfree> it's *white*
17:04:50 <syntaxfree> bad, bad idea.
17:04:57 <dons> practice, syntaxfree. less noise, more code!
17:05:01 <Pseudonym> I see it because I use a fixed-width font.
17:05:08 <araujo> we need a good beginner tutorial
17:05:09 <syntaxfree> me too.
17:05:11 <fuzan> xpika: data Card = Card { value :: Integer, suit :: String }
17:05:17 <Pseudonym> See that column where everything starts?  That's a block.
17:05:19 <syntaxfree> araujo: we need better beginners, I think ;)
17:05:21 <araujo> Something that doesn't scare people away :-P
17:06:01 <araujo> syntaxfree, yes, but i doubt i can solve that :-)
17:06:22 <fuzan> We need to push elementary schools to teach Haskell.
17:06:24 <ftegularius> i wonder about that. does anybody have any idea about the demographics of new haskellers?
17:06:39 <syntaxfree> we need to teach Haskell in nursery.
17:06:46 <gotaku> araujo: I'm making a haskell tutorial and it starts with monads.
17:06:57 <araujo> DEclarative programming is easy. Ive seen many papers/tutorial making too complex for beginners
17:07:11 <fuzan> I'm probably the only student at WSU to use Haskell. I've been pushing it at my fellow students and none are biting :\
17:07:35 <ddarius> @oldwiki UsingRecords xpika
17:07:36 <lambdabot> http://www.haskell.org/hawiki/UsingRecords xpika
17:07:37 <ftegularius> since most of the haskell hype is from places like reddit and LTU, i'd expect the new users to be a fairly select bunch
17:07:52 <ftegularius> at the very least, they'd have to be genuinely interested, which is half the battle already
17:08:09 <araujo> gotaku, the putStrLn "Hello World" example?
17:08:12 <fuzan> another problem is that educational facilities teach it exclusively almost at the graduate level.
17:08:40 <dons> ftegularius: yeah. there has been some growth recently. but we don't have demographics
17:08:53 <hpaste>  xpika pasted "State and datatype " at http://hpaste.org/551
17:09:12 <ftegularius> i'm a highschool senior, so all my direction comes from lurking around places where i see smart people
17:09:16 <ftegularius> LTU and reddit are good examples
17:09:30 <dons> mm. that's interesting.
17:09:35 <mbishop> I hope you ment programming.reddit.com
17:09:41 <siti> lol, dons is the king reddit troll ;)
17:09:42 <ftegularius> mbishop: indeed ;)
17:09:45 <dons> we've a few new high school guys here.
17:09:55 <mbishop> the reddit mainpage hardly qualifies as a hotbed for "smart people" :P
17:09:55 * araujo actually came to know reedit because of haskell :-P
17:10:01 <syntaxfree> metoo.
17:10:04 <fuzan> ditto.
17:10:09 <ddarius> xpika: The error comes from your use of modiy, you need to select out the data you want to modify and rebuild the record.
17:10:10 <siti> araujo: me too :)
17:10:10 <syntaxfree> I'm a bigtime reddit troll.
17:10:11 <edwinb> reddit fascinates me
17:10:14 <fuzan> still don't read it too much :|
17:10:16 <gotaku> araujo: No, not really. Although IO is the easiest monad to understand I think. (Identity doesn't count)
17:10:22 <araujo> But i see it works the other way too :-)
17:10:47 <araujo> gotaku, so you are not starting with any specific monad at all?
17:10:53 <Pseudonym> I partially dissent on that.
17:11:07 <Pseudonym> I reckon [] is the easiest monad to understand if you've seen list comprehensions first.
17:11:11 <syntaxfree> Maybe is, by far, the easiest monad to understand.
17:11:15 <syntaxfree> then []
17:11:18 <dons> siti: its called PR, not trolling. and why should ruby and python have the monopoly on PR eh? :-)
17:11:22 <gotaku> araujo: IO, State and Reader.
17:11:34 <syntaxfree> IO, State and Reader happen to be the surprising ones.
17:11:36 <Pseudonym> I'd even choose [] over Maybe.
17:11:43 <ddarius> Pseudonym: That's pretty trivial.
17:11:48 <dons> hey nostrademons
17:11:54 <dons> what's new ?
17:11:57 <nostrademons> hey
17:11:59 <Pseudonym> With [], you don't start with any preconceptions about monads being about imperative programming.
17:12:00 <thorat> haskell needs a teachscheme-like initiative
17:12:02 * syntaxfree enjoys raising fire in reddit.
17:12:07 <nostrademons> not too much. have startup.  not haskell, alas
17:12:09 <ftegularius> in my experience so far, Maybe has been easiest, followed closely by the list monad.
17:12:11 <Pseudonym> I'd do [] first, then Id.
17:12:14 <nostrademons> where's the fire in Reddit?
17:12:23 <araujo> Maybe is easy and embodies in a clear way the monadic approach
17:12:25 <Korollary> upmod if you agree with me
17:12:48 <araujo> gotaku, i am not sure if that will be easy for beginners at first
17:12:57 <gotaku> Yes, Maybe is also good.
17:13:04 <nostrademons> if I could find a XSS vulnerability, I'd really like to do a "upmod if you want to downmod" post
17:13:14 <nostrademons> where the downmod arrow is reprogrammed to upmod the post
17:13:15 <ftegularius> araujo: no, they won't be easy for beginners. at least, they weren't for this beginner ;)
17:13:23 <Korollary> forget beginners
17:13:27 <ddarius> Pseudonym: Another benefit of [] is that you are doing something that isn't easy for typical imperative languages.
17:13:32 <xpika> I'm wondering how the functions in code know anything about the More datatype. I was using it to work on ints
17:13:32 <Pseudonym> Right.
17:13:44 <syntaxfree> "upmod if" entries freaking suck.
17:13:53 <gotaku> At least monads will be used all the way through the tutorial and not just tacked on at the end.
17:14:03 <Pseudonym> There's something nice about going from [ f x | x <- xs, y <- ys ] to do { x <- xs; y <- ys; return (f x) }
17:14:05 <syntaxfree> the [] monad still surprises me.
17:14:18 <araujo> ftegularius, we have many tutorials like that already :-P
17:14:21 <Korollary> it's all because of concatMap
17:14:27 <araujo> The idea is to include, not to exclude
17:14:30 <dons> mm, here's last night's results from my cross-haskell compiler shootout, http://www.cse.unsw.edu.au/~dons/nobench/bench.results
17:14:43 <ftegularius> araujo: of course, i'm just saying ;)
17:14:51 <syntaxfree> > mapM (\x->[x+i | i<-[-5..5]]) [1..5]
17:15:14 <syntaxfree> @seen lambdabot
17:15:14 <lambdabot> Yes, I'm here. I'm in #haskell, #haskell.es, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell-overflow and #
17:15:15 <lambdabot> haskell-blah
17:15:19 <syntaxfree> ?
17:15:22 <gotaku> Most of the available monad tutorials really lack simple examples.
17:15:29 <syntaxfree> > mapM (\x->[x+i | i<-[-5..5]]) [1..5]
17:15:54 <ddarius> xpika: That error message doesn't correspond to the code as posted.
17:16:04 <syntaxfree> I don't feel Haskell's popularity problem, if it's a problem, is due to bad free-instruction material.
17:16:11 <edwinb> I can't remember how I first grokked monads
17:16:20 <syntaxfree> someone needs to sell Haskell to PHB folk.
17:16:29 <edwinb> although I'm fairly sure I just didn't care and trusted to explanation of how to do IO in the gentle introduction
17:16:51 <gotaku> Even if they do have examples, there is no explaination about how they work.
17:16:52 <Korollary> syntaxfree: I find most of the free instruction stuff (excluding random Joe blogs) fairly good.
17:16:54 <sm> gotaku: seen http://kawagner.blogspot.com/2007/02/understanding-monads-for-real.html ?
17:16:57 <lambdabot> Title: Karsten Wagner's Blog: Understanding Monads. For real., http://tinyurl.com/2gslra
17:17:14 <syntaxfree> hey, I resent the "random Joe blogs" snide comment. Name names! ;)
17:17:22 <syntaxfree> haha.
17:17:33 <araujo> hah ok
17:18:14 <ddarius> Bah. Just read Moggi's original paper.
17:18:25 <syntaxfree> "mapM (\x->[x+i | i<-[-5..5]]) [1..5]" has to qualify as the "most surprisingly long output" line of all computer programming.
17:18:43 <gotaku> sm: Thanks, I'll check it out.
17:18:48 <Pseudonym> Only 25 entries, surely?
17:18:58 <maskd> does anyone have a haskell filetype plugin (for vim) that works? the upstream one is horrible
17:19:12 <ddarius> > mapM (\x -> [x+i | i <- [-5..5]]) [1..5]
17:19:17 <ftegularius> syntaxfree: wow, that was impressive
17:19:17 * syntaxfree hugs SubEthaEdit
17:19:20 <Saulzar> Looks like 50 to me :)
17:19:21 <gotaku> Haskell has a popularity problem?
17:19:33 <Pseudonym> Ah.
17:19:35 <fuzan> 5*10 should be 50 :)
17:19:35 <Pseudonym> Guess not.
17:19:49 <ddarius> gotaku: Yes, it's too popular for some.
17:19:50 <Korollary> 55
17:19:51 <dons> ?bot
17:19:52 <Korollary> ?
17:19:52 <lambdabot> :)
17:20:00 <dons> ddarius: hehe
17:20:07 <dons> ?users
17:20:07 <lambdabot> Maximum users seen in #haskell: 316, currently: 286 (90.5%), active: 61 (21.3%)
17:20:13 <Pseudonym> Hmmm.
17:20:16 <Pseudonym> Except it's not.
17:20:20 <thorat> methinks haskell could invade high schools via mathematics
17:20:23 <ddarius> dons: Does each message spawn a thread?
17:20:28 <fuzan> dons: where's yhc on that list? hehe
17:20:29 <ddarius> I'm not one of them.
17:20:31 <dons> ddarius: yeah
17:20:33 <ftegularius> thorat: not in the U.S.
17:20:37 <dons> ddarius: with a timeout attached
17:20:44 <dons> ddarius: so it should scale nicely to 16 cores ;)
17:20:50 <kfish> methinks mathematics could invade computer science via haskell!
17:21:58 <hpaste>  xpika pasted "more info" at http://hpaste.org/552
17:22:33 <ftegularius> thorat: the only compsci program at my school was a miserable online course on java, and that's still more than 90% of the country gets i think
17:22:49 <Pseudonym> D'oh.  Yes, it has 11^5 elements actually.
17:22:53 <thorat> when I learned pascal in high school I had to unlearn referential transparency
17:22:55 <thorat> from maths
17:22:56 <fuzan> I think that perhaps a general "syntax-ique" might help haskell as a whole as well.
17:23:22 <thorat> and the most confusing things in maths are the nonconstructive ones
17:23:34 <gotaku> I'd say a nice IDE.
17:23:40 <gotaku> (Don't say emacs)
17:24:10 <ftegularius> thorat: schools in the U.S. give a very bad mathematical foundation in general. things would have to change radically before any progress could be made
17:24:13 <Saulzar> Pseudonym  Why 11^5 and not 11*5 ?
17:24:58 <ddarius> xpika: Monomorphism on io maybe.  Try with -fno-monomorphism-restriction
17:25:03 <Pseudonym> Saulzar: Expand mapM.
17:25:09 <Pseudonym> @src mapM
17:25:10 <lambdabot> mapM f as = sequence (map f as)
17:25:11 <thorat> ftegularius: ok, have you checked out what drscheme has to offer for beginners?
17:25:25 <Saulzar> Oh right, mapM in the list monad :)
17:25:29 <ddarius> xpika: Or give io an explicit signature.
17:25:35 <augustss> xpika: or 'io x = liftIO x'  or a type signature
17:25:37 <Pseudonym> Yup.
17:25:47 <Pseudonym> That's a nice idiom, though.
17:25:49 <thorat> ftegularius: their ambition was to invade high schools I think
17:25:49 * Pseudonym must remember that.
17:25:59 <ftegularius> thorat: possibly
17:26:02 <thorat> @google teachscheme
17:26:04 <lambdabot> http://www.teach-scheme.org/
17:26:04 <lambdabot> Title: TeachScheme, ReachJava!
17:26:42 <ftegularius> thorat: but, whatever their ambition, and whatever the capabilities of the program, i have trouble believing that a programming curriculum could ever succeed in modern U.S. schools
17:27:13 <ftegularius> ftegularius: kids take year-long courses and barely learn to use excel, it's just not going to happen i think
17:27:23 <ftegularius> whoosp, thorat*
17:27:34 <kc5tja> Hello.  I'm learning Haskell on my own, and reading through the Yet Another Haskell Tutorial (nice document!).  I do have a question which the tutorial doesn't seem to address though.
17:27:46 <Saulzar> ftegularius That's only if they're unwilling
17:28:09 <Saulzar> There is always going to be a crowd of highschool kids at every school who are keen to learn programming
17:28:18 <kc5tja> I originally wrote a function to print a list of strings to the screen, and invoked it as "map putStrLn aListOfStrings"
17:28:26 <emu> kc5tja: mapM_
17:28:35 <ftegularius> Saulzar: there'll be a small crowd yes, but without a good teacher, they'll just end up flailing about i think
17:28:43 <Saulzar> ftegularius Right
17:28:46 <ddarius> @type map putStrLn []
17:28:48 <lambdabot> [IO ()]
17:28:53 <kc5tja> However, I must be missing something here, because the compiler spews a type error.  Why is this a type error, which it should be mapping [String] -> [IO String]?
17:29:04 <ftegularius> Saulzar: and no school is going to integrate a program that would attract at best a very small percentage of its students, and which would have trouble finding qualified instructors
17:29:05 <Saulzar> But a lot of math teachers can handle it I'm sure, though no doubt many can't ...
17:29:11 <emu> kc5tja: putStrLn :: String -> IO ()
17:29:18 <syntaxfree> kc5tja: you'll get a list of IO actions.
17:29:23 <kc5tja> emu: Sorry, I meant [IO ()]
17:29:42 <syntaxfree> not an IO action itself.
17:29:45 <syntaxfree> @type sequence
17:29:47 <lambdabot>     Ambiguous occurrence `sequence'
17:29:47 <emu> kc5tja: then you can run those IO actions through sequence_ to actually do them. mapM_ f = sequence_ . map f
17:29:48 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
17:30:01 <syntaxfree> @type Control.Monad.sequence
17:30:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:30:04 <kc5tja> syntaxfree: Correct; but that *should* still compile, even if it's not what I expected it to do.
17:30:17 <emu> kc5tja: what's the context
17:30:18 <syntaxfree> kc5tja: not if it's your main function!
17:30:23 <Pseudonym> @let factorial n = genericLength $ mapM (\x -> [x+i | i <- [0..x]]) [0..n-1]
17:30:25 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:30:25 <kc5tja> syntaxfree: It's not.
17:30:27 <Pseudonym> Damn.
17:30:27 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/19/the-gee-whiz-monad-i/
17:30:30 <lambdabot> Title: The Gee-Whiz Monad (I)  Data.Syntaxfree
17:30:30 <syntaxfree> hmm.
17:30:38 <syntaxfree> kc5tja: can we see code snippets please?
17:30:40 <xpika> > sequence_ $ map putStrLn ["a","b"]
17:30:41 <lambdabot>  <IO ()>
17:30:43 <syntaxfree> if it's long,  use hpaste.org
17:30:43 <kc5tja> Context is exercise 5.2 in Yet Another Haskell Tutorial.
17:30:53 <syntaxfree> which says...?
17:30:58 <emu> hpaste: url
17:30:59 <hpaste> Haskell paste bin: http://hpaste.org/
17:31:28 <ftegularius> Saulzar: even decent math teachers are hard to find. my 8th grade algebra teacher was also our school's wrestling coach. not to play on cliches, but you can imagine just how good he was at that job ;)
17:31:43 <kc5tja> writeFile name = do
17:31:43 <kc5tja>     bracket (openFile name WriteMode) hClose (\h -> do
17:31:43 <kc5tja>         putStrLn "Type the content below.  End with \".\" by itself."
17:31:43 <kc5tja>         linesOfText <- body
17:31:43 <kc5tja>         map putStrLn linesOfText
17:31:45 <kc5tja>         )
17:31:55 <kc5tja> oops, sorry, didn't see link to hpaste.org
17:31:58 <ddarius> ftegularius: Yeah.  Mathematicians are usually fairly scrawny.
17:32:07 <emu> @type bracket
17:32:10 <lambdabot> Not in scope: `bracket'
17:32:14 <emu> @hoogle bracket
17:32:15 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:32:15 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
17:32:15 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
17:32:37 <ftegularius> ddarius: well, naturally the body suffers when you spend all your time exercising the mind ;)
17:33:12 <Saizan> kc5tja: when you are in a do block all the expression must have the type of the monad you are using, so IO a in this case
17:33:16 <emu> [IO ()] doesn't work there
17:33:24 <emu> need IO ... something
17:33:35 <emu> @type sequence_
17:33:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
17:33:49 <emu> @type sequence
17:33:51 <lambdabot>     Ambiguous occurrence `sequence'
17:33:51 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
17:34:04 <Saizan> @type Prelude.sequence
17:34:05 <ddarius> @type Control.Monad.sequence
17:34:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:34:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:34:13 <emu> ah, well anyway, sequence takes a list of actions and turns it into an action on that list
17:34:39 <kc5tja> OK, so I'm new to Haskell -- I don't really see how quoting the type signatures of Monad is going to help me.  :)  I am not even fully aware of how to interpret it yet.
17:34:50 <Saizan> heh
17:34:54 <emu> in this case, substitute IO for m
17:35:06 <emu> [IO a] -> IO [a]
17:35:13 <Saizan> that's a problem of doing IO early, you don't know how it works yet ^^
17:35:48 <kc5tja> Chapter 5 is "early"?
17:36:12 <dons> i say do basic IO on the first page, explain the theory on the 2nd last page ;)
17:36:14 <emu> naw he's fine, just hasn't covered kinding, quantification, or type-classes really
17:36:19 <kpreid> kc5tja: "map putStrLn linesOfText" is indeed fine by itself, and has the type you think
17:36:24 <kc5tja> I ended up using a recursive function ("spew" -- heh) to get it working.  But, still, I was upset that I couldn't use map on it.
17:36:36 <kpreid> kc5tja: but it doesn't match the type the do block needs
17:37:10 <kpreid> I should say, the type of the rest of the do block
17:37:18 <emu> kc5tja: what you're doing is not only mapping, but expressing a "sequence of actions", hence sequence
17:37:26 <kc5tja> kpreid: OK, so that's what the compiler was complaining about.
17:37:36 <kc5tja> emu: Yeah, I hadn't come across "sequence" yet in the tutorial.
17:37:54 <ddarius> kc5tja: What about mapM_?
17:37:54 <JohnnyL> @type map putStrLn linesOfText
17:37:55 <Saizan> ?src sequence
17:37:56 <kc5tja> I expect to pop up around chapter 9, when they discuss monads.
17:37:57 <lambdabot> Not in scope: `linesOfText'
17:37:57 <lambdabot> sequence ms = foldr k (return []) ms
17:37:57 <lambdabot>     where
17:37:57 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
17:38:33 <emu> sequence composes a list of actions, much like sum composes a list of numbers
17:38:58 <gotaku> How is "map putStrLn linesOfText" fine by itself?
17:39:00 <emu> @src sequence_
17:39:00 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:39:25 <emu> gotaku: it doesn't do what he meant, but it could type-check
17:39:51 <kc5tja> gotaku: It puts together a list of actions-that-when-executed-returns-IO-().
17:40:13 <kc5tja> Theoretically, one could then iterate over the list executing those actions.  I think that's what sequence does.
17:40:34 <gotaku> Shouldn't you use mapM_ for that?
17:40:40 <emu> @src mapM_
17:40:40 <lambdabot> mapM_ f as = sequence_ (map f as)
17:40:45 * kc5tja <-- NEWBIE
17:40:51 <kc5tja> Not aware of mapM_.  :)
17:41:19 <emu> i prefer to think of it as composing actions.  (>>) and (>>=) compose 2 actions, sequence does it on a list
17:41:21 <kpreid> mapM_ is definitely what you want for the purpose
17:41:35 <kc5tja> Oh, yeah, but I was unaware of it.
17:41:40 <kc5tja> Instead, I replaced my bad code with:
17:41:51 <kc5tja> spew [] _ = return ()
17:42:13 <kc5tja> spew t h = hPutStrLn h text
17:42:22 <kc5tja> err
17:42:24 <kc5tja> oops
17:42:29 <kc5tja> Let me just paste from source (2 lines)
17:42:35 <kc5tja> spew [] _ = return ()
17:42:36 <kc5tja> spew (l:ls) h = do hPutStrLn h l; spew ls h
17:42:49 <emu> which is also: hPutStrLn h l >> spew ls h
17:43:23 <Saizan> if you factor out (hPutStrLn h) your spew is mapM_ :)
17:43:24 <syntaxfree> ?src sequence
17:43:25 <lambdabot> sequence ms = foldr k (return []) ms
17:43:25 <lambdabot>     where
17:43:25 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
17:44:14 <ReturnToZero> Bonne nuit a tous :x:x:x:x:x:x
17:45:11 <kc5tja> ?src mapM_
17:45:11 <lambdabot> mapM_ f as = sequence_ (map f as)
17:45:28 <kc5tja> ?src sequence_
17:45:28 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:46:01 <ddarius> @src foldr
17:46:01 <lambdabot> foldr k z xs = go xs
17:46:02 <lambdabot>     where go []     = z
17:46:02 <lambdabot>           go (y:ys) = y `k` go ys
17:46:12 <ddarius> Now just substitute equals for equals.
17:46:32 <kc5tja> I know what foldr does.
17:46:42 <gotaku> spew xs h = mapM_ (hPutStrLn h) xs
17:46:44 <Saizan> do you know what >> is?  a >> b === do { a; b }
17:46:46 <gotaku> Is that what you want?
17:46:56 <JohnnyL> @src mapM_
17:46:57 <lambdabot> mapM_ f as = sequence_ (map f as)
17:47:31 <JohnnyL> @src sequence_
17:47:32 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:47:40 <kc5tja> gotaku: High level problem: Print a listOfStrings to an outputFile (:: IO Handle).
17:47:44 <ddarius> @type \f -> foldr ((>>) . f) (return ())
17:47:46 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m ()
17:49:16 <ddarius> @type foldr
17:49:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:49:23 <ddarius> @free foldr
17:49:26 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
18:00:54 <mbishop> Anyone see my post on programming.reddit.com and wants to trade Bird for Norvig? :P
18:06:25 <SamB> mbishop: you want to trade norvig for bird?
18:06:34 * mbishop nods
18:06:51 * SamB didn't read reddit, and has no books to trade
18:07:23 <nrb23> dons: can you fix the topic so the URLs parse properly?
18:27:35 <kpreid> nrb23: what's wrong with them?
18:27:52 <kpreid> (the character " cannot occur in a URL)
18:28:01 <nrb23> can't it?
18:28:33 <kpreid> "The angle-bracket "<" and ">" and double-quote (") characters are excluded because they are often used as the delimiters around URI in text documents and protocol fields." -- http://www.ietf.org/rfc/rfc2396.txt
18:28:38 <nrb23> then it's a bug in Colloquy
18:30:31 * nrb23 goes to #colloquy to complain :->
18:30:57 <kc5tja> You can encode them using %-notation though.
18:51:40 <gotaku> dons: the mandelbrot and n-body benchmarks for the AMD box on the language shootout site use incorrect ghc options.
18:55:25 <jcreigh> hmm, what's the difference between Map.toList and Map.assocs?
18:56:12 <ivanm> assocs has the co-ords I think, whilst toList just gives the values in order
18:56:30 <jcreigh> :t Data.Map.toList
18:56:33 <lambdabot> forall k a. M.Map k a -> [(k, a)]
18:56:37 <jcreigh> :t Data.Map.assocs
18:56:40 <lambdabot> forall k a. M.Map k a -> [(k, a)]
18:56:41 <ivanm> i.e. [(1,1),(2,3),(3,0)] as opposed to [1,3,0]
18:56:46 <mbishop> haha oh god, ML vs. Lisp is still going on
18:56:49 <ivanm> then again, maybe not
18:57:12 <TSC> Maybe assocs is guaranteed to be in order
18:57:23 <jcreigh> TSC: yes, the docs say assoc gives them in "ascending key order".
18:57:24 <beelsebob_> > Data.Map.toList (Data.Map.fromList [(5,2),(2,5)]
18:57:25 <lambdabot>  Parse error
18:57:28 <beelsebob_> > Data.Map.toList (Data.Map.fromList [(5,2),(2,5)])
18:57:29 <lambdabot>   Not in scope: `Data.Map.fromList'
18:57:32 <beelsebob_> bah
18:57:40 <jcreigh> TSC: But it says they're both O(n)...
18:57:46 <TSC> Well, yeah
18:57:47 <sorear> jcreigh: they are exactly the same, see the source code link
18:58:08 <sorear> there's a line assocs = toList
18:58:14 <TSC> Perhaps assocs is the "natural" name, and toList is the "consistent" name
18:58:15 <sorear> or the other way around
18:58:31 <TSC> Becuase many data structures also have to/fromList
19:00:29 <dons> gotaku: yes. i've noticed
19:00:32 <dons> they've not been updated
19:00:38 <dons> the amd machine lags in updates
19:03:53 <gotaku> I'm having a hard time trying to program things without mutable arrays...
19:04:12 <ddarius> gotaku: What kind of things are you trying to do?
19:06:45 <allbery_b> re assocs vs. toList:  the lispers' name vs. the consistent name?
19:07:05 <allbery_b> (and/or haskellers' name :)
19:07:45 <gotaku> ddarius: Trying to code a simple emulator.
19:07:56 <sorear> gotaku: emulating what?
19:07:57 <jcreigh> *sigh* Whenever I make non-trivial changes to a Haskell program I have to go though the whole "Parse Error -> Fix -> Not in Scope -> Fix -> Type Error -> Fix -> ..." cycle.
19:08:20 <sorear> jcreigh: I've commented on that before
19:08:29 <TB> Hey :)
19:08:30 <allbery_b> shim? :)
19:08:31 <ddarius> jcreigh: Stop changing your code to erroneous code.
19:08:38 <sorear> jcreigh: usually phrased as "*sigh* GHC has far too many passes"
19:09:06 * allbery_b notes that, more or less, that has always characterized his programming in any language
19:09:07 <sorear> allbery_b: shim makes it faster but you still get the pain of forcing your code through GHC one pass at a time.
19:09:36 <TB> I just wrote this really inefficient function (itemInList list item = length (filter (\x -> x==item) list) > 0), and I wanted to optimize it, but then I wondered if there wasn't a function like that in the prelude :/?
19:09:38 <sorear> IMO GHC should ignore erroneous code, and only fail at the write-object-files step
19:09:48 <sorear> TB: elem
19:09:51 <allbery_b> most languages have trouble resynching enough after a syntax error to do correct semantic analysis IME
19:09:52 <sorear> @ty elem
19:09:53 <ddarius> @type elem
19:09:55 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:09:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:10:00 <gotaku> sorear: The UM from the 2006 ICFP Contest...
19:10:11 <jcreigh> ddarius: oh, right. Why didn't I think of that ? :)
19:10:17 <sorear> gotaku: not familiar enough. does it have RAM?
19:10:21 <gotaku> sorear: I can do it in C, but I'm having real trouble with Haskell.
19:10:40 <sorear> gotaku: if it has RAM, go ahead and use mutable arrays.  we won't fault you.
19:10:40 <TB> Oooh, thanks :)
19:10:58 <ddarius> @src elem
19:10:58 <lambdabot> elem x    =  any (== x)
19:11:29 <ddarius> Bah Haskell and it's simple and concise definitions.
19:11:30 <gotaku> sorear: Well it has an array of variable length arrays that can be created (allocated) and destroyed.
19:11:39 <TB> Heh, I used to be a die-hard imperative programmer, but I slowly begin to see the beauty behind haskell :)
19:11:59 <sorear> gotaku: ooh! just like INTERCAL!
19:12:14 <ddarius> > let elem = any . (==) in elem 3 [1..10]
19:12:16 <lambdabot>  True
19:12:27 * sorear has come frighteningly close to trying to bootstrap INTERCAL
19:13:06 <allbery_b> @intercal
19:13:06 <lambdabot> Unknown command, try @list
19:13:09 <allbery_b> :)
19:13:14 <syntaxfree> ddarius: concise definitions are achieved by HOFs.
19:13:18 <syntaxfree> @src any
19:13:18 <lambdabot> any p =  or . map p
19:13:34 <syntaxfree> @src or
19:13:34 <lambdabot> or    =  foldr (||) False
19:13:49 <allbery_b> @src (||)
19:13:50 <lambdabot> True  || _ =  True
19:13:50 <lambdabot> False || x =  x
19:14:01 <syntaxfree> elem would be a complex recursive function if the common recursion patterns "foldr" and "map" weren't available.
19:14:17 * ddarius is well aware of all this.
19:14:19 <allbery_b> and of course foldr and map for completeness :)
19:14:39 <gotaku> sorear: Intercal is somewhat before my time.
19:15:02 <sorear> gotaku: yeah, well it still hasn't been bootstrapped
19:15:33 <sorear> gotaku: there's a Perl compiler, a Java compiler, a C compiler, and a SPITBOL compiler, but no INTERCAL compiler
19:15:58 <syntaxfree> sorear: you mean a Perl compiler in Perl, etc?
19:16:23 <allbery_b> huh, I thought someone had done an intercal compiler
19:16:31 <gotaku> sorear: Is it not possible or something?
19:16:41 <sorear> syntaxfree: no, I meant a INTERCAL compiler in $LANG
19:16:44 <allbery_b> (as for spitbol, that's just a snobol compiler (vs. the orignal interpreter) isn't it?)
19:17:11 <sorear> allbery_b: the fact that spitbol is compilable is irrelevant for this excercise.
19:18:09 <allbery_b> ? my point is that spitbol *is* a compiler.  for snobol.  it's not a separate language, to my knowledge
19:18:32 <allbery_b> the original spitbol was just IBM's snobol4 compiler
19:18:48 <TB> Ok, this is going to be a dumb question, but what's the invert-bool-prefix-thingamajig in Haskell? (like what ! is in C) ?
19:18:53 <sorear> not
19:18:58 <sorear> > not (2 /= 3)
19:19:00 <gotaku> Yes, yes... anyway, about my problem?
19:19:00 <lambdabot>  False
19:19:11 <syntaxfree> is SNOBOL the dirty pun I'm thinking of?
19:19:19 <syntaxfree> (I know it's a language, and what the acronym stands for)
19:19:32 <sorear> gotaku: just use mutable arrays, we won't mind, Data.Array.ST
19:19:57 <gotaku> sorear: But how should I store the arrays themselves?
19:20:05 * allbery_b doesn't normally associate dirty puns with pinstriped IBM researchers, but who knows?
19:20:10 <sorear> ?
19:20:51 <gotaku> sorear: The arrays can be created and destroyed remember...
19:21:09 <sorear> a map then maybe?
19:21:34 <gotaku> sorear: The main program is loaded into array 0 and instructions read from that array can create new arrays.
19:36:51 <TB> is there a function in haskell that takes the average of a list ?
19:37:32 <dcoutts> > let avg xs = sum xs / length xs in avg [1.15]
19:37:33 <lambdabot>   add an instance declaration for (Fractional Int)
19:37:33 <lambdabot>     In the expression: 1.15
19:37:38 <dcoutts> > let avg xs = sum xs / length xs in avg [1..15]
19:37:39 <lambdabot>   add an instance declaration for (Fractional Int)
19:37:39 <lambdabot>     In the expression: (su...
19:37:44 <dcoutts> bah
19:37:45 <bd_> dcoutts: that has a space leak :)
19:37:46 <sorear> fromIntegral
19:38:00 <dcoutts> bd_, true
19:39:19 <bd_> > let (sum, ct) = foldl' (\(sum, ct) n -> let s' = sum + n; ct' = succ ct in s' `seq` ct' `seq` (s', ct')) (0,0) [1..5] in sum/ct
19:39:21 <lambdabot>  3.0
19:39:28 <bd_> > sum [1..5]/5
19:39:29 <lambdabot>  3.0
19:39:36 <bd_> > let (sum, ct) = foldl' (\(sum, ct) n -> let s' = sum + n; ct' = succ ct in s' `seq` ct' `seq` (s', ct')) (0,0) [1..50000] in sum/ct
19:39:37 <lambdabot>  25000.5
19:39:48 <sorear> @ty uncurry (/) . foldr (\x -> (+x) *** (+1)) (0,1)
19:39:51 <lambdabot> forall b'. (Fractional b') => [b'] -> b'
19:39:56 <sorear> bwahahah.
19:40:11 <Stinger> hmmm
19:40:14 <sorear> er, muahahahah.
19:40:15 <bd_> wouldn't foldr blow the stack?
19:40:25 <sorear> bd_: laziness! :p
19:40:37 <bd_> @ty uncurry (/) . foldl' (flip $ \x -> (+x) *** (+1)) (0,0)
19:40:39 <lambdabot> forall b'. (Fractional b') => [b'] -> b'
19:40:42 <bd_> sorear: Precisely the problem :)
19:40:46 <bd_> > uncurry (/) . foldl' (flip $ \x -> (+x) *** (+1)) (0,0) [1..5]
19:40:47 <lambdabot>  Couldn't match expected type `a -> (a1, a1)'
19:40:52 <bd_> > uncurry (/) . foldl' (flip $ \x -> (+x) *** (+1)) (0,0) $ [1..5]
19:40:54 <lambdabot>  3.0
19:41:16 <bd_> @hoogle average
19:41:17 <lambdabot> No matches found
19:41:17 <bd_> @hoogle avg
19:41:18 <lambdabot> No matches found
19:42:06 <ivanm> @hoogle av
19:42:06 <lambdabot> Distribution.Setup.compilerFlavor :: Compiler -> CompilerFlavor
19:42:07 <lambdabot> Distribution.Setup.configHcFlavor :: ConfigFlags -> Maybe CompilerFlavor
19:42:07 <lambdabot> Distribution.Setup.CompilerFlavor :: data CompilerFlavor
19:42:13 <ivanm> @hoogle mean
19:42:14 <lambdabot> No matches found
19:42:55 <ivanm> bd_: why does dcoutts solution have a space leak?
19:43:13 <dcoutts> ivanm, because it holds onto the beginning of the list
19:43:17 <bd_> ivanm: It first computes the sum, then the length (or vice versa) - meaning the entire list has to be held in RAM
19:43:29 <bd_> which is fine if the list does fit in RAM of course
19:43:41 <ivanm> Ah, whereas the folded versions only go through the list once?
19:43:46 <bd_> well, apart from the GC pain
19:43:46 <bd_> yeah
19:43:49 <Stinger> if I am getting overflows from simple manipulations of TimeDiffs and ClockTimes, would that be considered a bug?
19:44:16 <bd_> problem with foldr is it builds up a huge chain of thunks, so when it's finally forced, there'll be a stack overflow
19:44:21 <bd_> > uncurry (/) . foldl' (flip $ \x -> (+x) *** (+1)) (0,0) $ [1..1000000]
19:44:25 <lambdabot>  Exception: stack overflow
19:44:28 <bd_> ... hm
19:44:31 <bd_> maybe I'm wrong
19:44:37 <bd_> > uncurry (/) . foldr (\x -> (+x) *** (+1)) (0,0) $ [1..1000000]
19:44:41 <lambdabot>  Exception: stack overflow
19:44:41 <sorear> 0.00user 0.00system 0:00.00elapsed 200%CPU (0avgtext+0avgdata 0maxresident)k
19:44:45 <bd_> great
19:44:50 <sorear> ^^ on a 1p maching
19:44:55 <bd_> oh
19:45:00 <bd_> the pair isn't strict :/
19:45:13 <bd_> > let (sum, ct) = foldl' (\(sum, ct) n -> let s' = sum + n; ct' = succ ct in s' `seq` ct' `seq` (s', ct')) (0,0) [1..1000000] in sum/ct
19:45:13 <ivanm> well, doing a google code search reveals only the sum / length solution...
19:45:16 <lambdabot>  500000.5
19:45:25 <bd_> that's way too verbose
19:45:40 <sorear> sum/length is very easy
19:45:47 <bd_> > let (sum, ct) = foldl' (\(sum, ct) n -> (,) $! sum + n $! succ ct) (0,0) [1..1000000] in sum/ct
19:45:48 <lambdabot>  Couldn't match expected type `(a -> b, a)'
19:45:54 <sorear> > liftM2 (/) sum genericLengt [1..10000]
19:45:55 <lambdabot>   Not in scope: `genericLengt'
19:45:58 <sorear> > liftM2 (/) sum genericLength [1..10000]
19:46:00 <lambdabot>  5000.5
19:49:51 <orbitz> hrm, is thr ea point-free way to write sortBy (\(_, x) (_, y) -> compare y x) list
19:52:02 <allbery_b> orbitz: with ghc 6.6, (comparing snd)
19:52:30 <allbery_b> :t comparing
19:52:33 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:53:27 <orbitz> hrm, is there anyway i could pu a funcion before eh compare so i could emulate that?
19:53:54 <orbitz> almost like steraming the paremters throuhg a function
19:54:06 <allbery_b> @src comparing
19:54:07 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:54:09 <allbery_b> hm
19:54:22 <allbery_b> @source Data.Ord
19:54:23 <lambdabot> Data.Ord not available
19:54:24 <orbitz> writing comparing isn't hard, but i was thinkign of soemthig more general?
19:54:29 <bd_> comparing f a b = compare (f a) (f b)
19:54:51 <allbery_b> Arrow ((->) r?
19:55:08 <bd_> :t \f a b -> liftM2 compare ($a) ($b) f
19:55:09 <allbery_b> hm, no, liftM2?
19:55:11 <lambdabot> forall a b. (Ord b) => (a -> b) -> a -> a -> Ordering
19:55:13 <orbitz> i was thinkig more a long the lines of (compare . applyFunc snd)
19:55:17 <allbery_b> right
19:55:38 <bd_> orbitz: . only affects the first parameter
19:55:53 <orbitz> right, that's why i said a long the line sof:)
19:56:10 <bd_> :t local
19:56:13 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
19:56:14 <allbery_b> the generalization of liftM is ap, IIRC
19:56:25 <bd_> :t ap
19:56:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:56:32 <bd_> yeah, I don't think it's applicable
19:56:41 <bd_> liftM2 = ap . return
19:56:50 <bd_> er
19:56:54 <bd_> not quite, maybe
20:07:32 <ddarius> ivanm: A lot of papers on some forms of fusion use that example.
20:07:58 <ddarius> ivanm: I.e. they turn the naive algorithm into a one pass one.
20:08:14 <ivanm> ddarius: well, it is the simplest and pretty much the definition I suppose...
20:09:20 <araujo> hello
20:10:03 <syntaxfree> @vote cheeky-off Yes
20:10:03 <lambdabot> voted on "Yes"
20:11:24 <lambdabot>  @vote syntaxfree-reddit-trolling off Yes
20:11:35 <lambdabot> voted on "Yes"
20:12:39 * lambdabot curses the inventor of @msg
20:13:00 * ddarius doesn't remember who that was.
20:13:36 <allbery_b> har har
20:18:46 <dons> does anyone have 10 minutes, and a working install of yhc?
20:19:13 <sorear> eys
20:19:33 <sorear> well, a working build
20:19:38 <fuzan> the dons can't figure out how to install yhc? :)
20:19:40 <sorear> can't remember if I installed it :)
20:19:55 <sorear> fuzan: the dons WON'T install yhc
20:20:06 <sorear> fuzan: he thinks svn is too "evil"
20:20:42 <fuzan> keep him away from the internet then, he might get scared :(
20:21:08 <jcreigh> what's wrong with svn?
20:21:18 <dons> it shoudn't run during the configure stage of a compiler build...
20:21:27 <jcreigh> I think it does its job as "CVS replacement" quite well.
20:21:36 <dons> sorear: want to have a go at getting the nobench run for yhc done?
20:21:42 <dons> before I announce it today?
20:22:12 * sorear tests his yhc install quickly
20:22:15 <dons> its interesting, ghc6.6 seems to be uniformly producing faster code than ghc 6.4.2
20:22:18 <dons> good sign
20:22:48 <sorear> fun, yhc has -cpp but not -D
20:23:03 <dons> fuzan: actually, i tried to build both yhc and jhc, both failed with 404s :/
20:23:05 <TB> Is there a function to get the nth item in a List? (I've looked to some Prelude docs, but can't find it :()
20:23:07 <TB> ?
20:23:10 <dons> the svn checkout in yhc seems to break
20:23:23 <dons> that's what you get for including svn lines in your configure script. mhwhaha
20:23:24 <jcreigh> wait, the buld process of yhc does an svn checkout?
20:23:24 <ivanm> TB: lst !! (n-1)?
20:23:30 <dons> > [1..10] !! 2
20:23:32 <lambdabot>  3
20:23:32 <jcreigh> s/an/a/
20:24:02 <dons> ?hoogle [a] -> Int -> a
20:24:03 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
20:24:09 <dons> TB, ^^ hoogle is your friend :-)
20:24:11 <gotaku> Can you deallocate an array created with mallocArray?
20:24:14 <Stinger> binding something in a do doesnt force evaluation order does it
20:24:17 <dons> gotaku: yeah.
20:24:24 <allbery_b> fwiw, I'm running the ghc test suite on 6.7, all the C tests are failing
20:24:34 <dons> allbery_b: yeah, as of last week. something broke
20:24:39 <allbery_b> yes, I know
20:24:53 * sorear had the honor of reporting it
20:24:56 <allbery_b> someone asked earlier why the ghc regression testing wasn't catching it; turns out it is
20:25:34 <gotaku> dons: How?
20:25:41 <sorear> allbery_b: it wasn't catching it because noone bothered to run it :)
20:25:45 <sorear> gotaku: free
20:25:48 <sorear> @hoogle free
20:25:49 <lambdabot> Foreign.Marshal.Alloc.free :: Ptr a -> IO ()
20:25:49 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
20:25:49 <lambdabot> Foreign.StablePtr.freeStablePtr :: StablePtr a -> IO ()
20:25:55 <sorear> the first on
20:25:57 <sorear> +e
20:26:44 <allbery_b> (hm, ghci tests are also losing, I wonder if I did something wrong)
20:26:47 <sorear> dons: hehe. gsfib calculates the 100 millionth fib in effectively the same amount of time on ghc and yhc.  Three guesses why :)
20:27:33 <gotaku> sorear: Are you sure free works with mallocArray?
20:27:33 <allbery_b> but the other tests all seem to pass
20:27:48 <sorear> gotaku: pretty sure ...
20:27:55 <sorear> Haskell is not C++
20:27:57 <sorear> :)
20:28:11 <gotaku> sorear: The docs don't mention it...
20:28:46 <dons> sorear: yhc crashes?
20:28:48 <gotaku> Free a block of memory that was allocated with malloc, mallocBytes, realloc, reallocBytes, new  or any of the newX functions in Foreign.Marshal.Array or Foreign.C.String.
20:29:05 <dons> ?docs Foreign.Marshall.Array
20:29:06 <lambdabot> Foreign.Marshall.Array not available
20:29:09 <dons> ?docs Foreign.Marshal.Array
20:29:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html
20:29:20 <sorear> dons: no, they both succeed in 13s.
20:29:29 <sorear> dons: I'm guessing the answer is "GMP"
20:30:10 <sorear> I guess from now on I'll use Yhc for my FFI-bound performance critical programs :)
20:31:37 <dons> hehe. yeah. gmp-heavy stuff all comes down to gmp binding performance
20:31:42 <dons> i.e. ghci should produce the same results
20:32:19 <goltrpoat> GADT pattern match in non-rigid context for `AInt'   Tell GHC HQ if you'd like this to unify the context
20:32:21 <goltrpoat> haha
20:32:24 <goltrpoat> is the GHC HQ present?
20:33:02 <sorear> #ghc
20:33:23 <sorear> dons: so I should just have to edit {header,footer}.mk?
20:33:30 <goltrpoat> i was kidding mostly
20:33:36 <dons> right. you should be able to add yhc to header.mk
20:33:59 <dons> and then add compile-yhc and run-yhc targets to footer.mk
20:34:09 <dons> in the same style as the compile-nhc and run-nhc targets
20:34:32 <dons> you'll need to add variables for YHC, YHC_OPTS, YHC_RUN_OPTS
20:34:35 <dons> to header.mk
20:34:50 <sorear> dons: yhc doesn't do +RTS
20:34:59 <dons> that's fine. ditch it to start with
20:35:11 <dons> (i only needed it for nhc, since the default 4M heap was bugging out)
20:35:19 <sorear> yhi -h 32M Main.hbc 100000000   # seems to be the only way, ie before the filename
20:37:02 <dons> http://programming.reddit.com/info/15b2c/comments
20:37:03 <lambdabot> Title: Are bugs really important? (reddit.com)
20:40:21 <sorear> nobench is getting too many dependencies :)  /me su -c 'aptitude install nhc98'
20:40:46 <dons> you can edit the COMPILERS list though, if you don't want to run nhc98
20:41:14 <dons> now, the next step is to generate nice html from the test.db result ilfes
20:41:17 <sorear> no I don't install nhc, it has been removed from debian!
20:41:18 <dons> files. and plot in gnuplot
20:41:28 <dons> ah yes. talk to Igloo :-0
20:41:55 <sorear> so, I take it this means nhc is officially obsolete? :p
20:42:14 <dons> well. not so sure
20:42:19 <dons> malcolm's been comitting a few patches back
20:42:32 <dons> and it has a better build system than yhc ... ;)
20:42:49 <dons> where's ndm. i want to bug him .
20:43:03 * sorear make
20:43:23 <nornagon> @src mapM
20:43:23 <lambdabot> mapM f as = sequence (map f as)
20:43:28 <nornagon> :t sequence
20:43:31 <lambdabot>     Ambiguous occurrence `sequence'
20:43:31 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
20:43:39 <nornagon> :t Prelude.sequence
20:43:42 <dons> sorry. haven't resolved that one yet. use a qualified name
20:43:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:43:52 <sorear> dons: if you're going to support jhc, you'll need to add stdin to all the programs.
20:44:07 * dmead tried learning python
20:44:15 <dmead> and couldn't stand it for more than an hour
20:44:18 <dons> hmm, sorear, don't we do that already?
20:44:23 <dmead> dynamic languages = waste of time
20:44:24 <sorear> dons: otherwise, jhc's simplify-init-big-one will try to constant fold the entire program.
20:44:24 <dons> i.e. it takes /dev/null if there's no stdin
20:44:32 <dons> ah i see
20:44:43 <dons> so getArgs for anything that has a configured value of N
20:45:00 <sorear> (and lest I forget, take forever in the process0
20:45:04 <dons> i'm not sure there are any programs that don't take getArgs or stdin though
20:45:12 <dons> yeah, we can timeout the compiler too i suppose
20:46:15 <dons> any luck with yhc builds?
20:46:25 <johnnowak> dmead: it is always wise to make vast generalizations given an hour's worth of experience
20:46:28 <sorear> dons: nope, still building ghci.
20:46:45 <sorear> (I suppose for this I should disable all the non-yhc compilers?)
20:46:47 <dmead> i also tried ruby
20:46:54 <dmead> :p
20:47:17 <sorear> yhc: Error: File not found, Text.Printf
20:47:27 <sorear> yhc has no extralibs, it is a h98 compiler
20:47:31 <sorear> :(
20:47:32 * allbery_b strongly dislikes python but uses perl and ruby (and awk and tcl when he can't get out of it)
20:47:59 <dmead> isn't ruby nearly the same thing as python?
20:48:05 <allbery_b> er. no
20:48:13 * sorear uses perl, bash, and ghc -e.
20:48:22 <sorear> increasingly the last.
20:48:23 <allbery_b> very similar to perl with smalltalk grafted onto it
20:48:31 <dons> sorear: ok. so things that don't use printf should be ok then... maybe ...
20:48:34 <johnnowak> allbery_b: he used it for an entire hour, don't argue with him, it's pointless
20:48:35 <Pseudonym> I use ghci in preference to bc now.
20:48:40 <dmead> ah
20:48:47 <sorear> yhc                  ERROR: Compile error: "yhc: Error: File not found, Control.Monad.ST  /home/stefan/lib/yhc/packages/yhc-base
20:49:01 <sorear> yhc                  ERROR: Compile error: "Error: /usr/local/src/nobench/spectral/integer/integer.hs(9:4-9:3) Found {-ERROR 1-} but expected one of <string> <char> <rational> <integer> ( [ <varid> <conid> _case_ _if_ _do_ _let_ \\ ` <varop> <conop> ]Error: /usr/local/src/nobench/spectral/integer/integer.hs(9:4-9:3) Found {-ERROR 1-} but expected one of <string> <char> <rational> <
20:49:04 <dons> sorear: most things don't need printf. try imaginary/recursive / ?
20:49:14 * dons laughs
20:49:25 <dmead> o0
20:49:35 <dons> sorear: did you remember to use -O11
20:49:51 <sorear> dons: no
20:49:59 <sorear> dons: it should be optional anyway
20:50:05 <dons> its a bit sad that there's no competition for ghc anymore
20:50:08 <sorear> dons: ie try it every way imaginable
20:50:32 <sorear> jhc compiled programs run VERY fast
20:50:37 <sorear> ./a.out: file not found
20:50:47 <sorear> less than a centisecond
20:50:50 <ivanm> What is the difference between (a ||) . b and (|| a) . b ?
20:50:57 <dons> ok. jhc might be a better option. at least for 'recursive' ?
20:50:57 <sorear> ivanm: laziness
20:51:13 <ivanm> which one is lazy?
20:51:16 <dons> :t \a b -> (a ||) . b
20:51:19 <lambdabot> forall a. Bool -> (a -> Bool) -> a -> Bool
20:51:20 <dons> :t \a b -> (|| a) . b
20:51:23 <lambdabot> forall a. Bool -> (a -> Bool) -> a -> Bool
20:51:33 <sorear> ivanm: _|_ || True = _|_
20:51:43 <sorear> ivanm: True || _|_ = True
20:51:44 <dons> the secton is applied differently. so imagine the short circuiting behavour of ||
20:52:08 <sorear> yhc                  ERROR: Compile error: "yhc: Error: File not found, Data.ByteString.Char8  /home/stefan/lib/yhc/packages/yhc
20:52:21 <ivanm> so (a ||) . b is lazy? What about ((||) a) . b, is that the same thing?
20:52:25 <dons> sorear: can you try 'imaginary/recursive' ?
20:52:43 <kc5tja> huh, I'm curious how anyone can strongly dislike Python.
20:52:51 <sorear> dons: how? make is trying everything (currently succeeding on imaginary/sorting)
20:52:56 <shachaf> kc5tja: They have Ruby as an alternative. :-)
20:52:57 <dons> i'm happy to let yhc crash and burn without bytestring. good incentive for them to fix things
20:53:04 <dons> sorear: cd imaginary/recursive
20:53:05 <dons> make
20:53:11 <sorear> figures :(
20:53:21 <kc5tja> shachaf: Yeah, but ... that's Ruby.
20:53:21 <sorear> :( on me, not nobench
20:53:28 <dons> and you can ^C things you don't want to run , it should just skip them
20:54:21 <sorear> in progress: http://members.cox.net/stefanor/bench.results
20:54:48 <sorear> wait, it appends now !?
20:55:08 <sorear> hugs                 ERROR: Runtime error: "stretch tree of depth 17\t check: -1ERROR - Control stack overflowERROR - Control st
20:55:15 <sorear> control stack, eh?
20:55:29 <sorear> that anything like the >R R> R@ stack? :)
20:55:59 <sorear> sorting:  6538 stefan    25   0 39056  34m  612 R 99.1  9.2   4:42.28 yhi
20:56:19 <dons> i think t means hugs has a space leak there
20:56:24 <sorear> dons: what is the arg to timeout?
20:56:32 <sorear> ../../bin/timeout 400 "yhi -h 32M Main.hbc  < sorting.input > sorting.yhc.actual 2>&1" || v=$? ; echo $v > yhc.status ; exit $v
20:56:34 <dons> that's the seconds limiit
20:56:36 <dons> see header.mk
20:56:42 <dons> 400 second timeout limit
20:56:50 <sorear> doh
20:56:52 <sorear> my bad
20:57:06 <sorear> incorrect Seconds -> Minutes conversion there
20:57:19 <Stinger> are there any restrictions on the Picosecs fields of timedefs?
20:57:29 <Stinger> er not timedefs TimeDiffs
20:57:37 <kc5tja> sorear: That's "return stack"; in Forth, the control stack doesn't actually exist -- it's almost universally mapped to the data stack.
20:57:42 <Stinger> I am getting overflow exceptions
20:58:03 <ivanm> sorear: so (a ||) . b is lazy? What about ((||) a) . b, is that the same thing?
20:58:43 <sorear> kc5tja: I was referring to the return stack. in forth terminology, I've never heard of any but data, return, fp
20:58:50 <pjd> kc5tja: more accurately, the return and data stack together correspond to what's called the control stack in other languages
20:59:01 <sorear> what's a control stack?
20:59:07 <kc5tja> sorear: ANSI Forth defines the control stack formality (it's hardly a formalism).
20:59:09 <pjd> you could say forth has a decoupled control stack
20:59:18 <ivanm> Also, in general, for guard statements, is having several conditions (||)'d together the same as having multiple guard statements?
20:59:19 <sorear> data, return, fp - I've heard of these
20:59:34 <kc5tja> sorear: Words that affect control flow create or consume items on the "control stack" for the purposes of branch target resolution.
20:59:36 <sorear> control - never heard of it in any language, assumed it meant return
20:59:47 <sorear> oh yeah
20:59:56 <sorear> see, it's been a while! :)
20:59:58 <pjd> sorear: the control stack is generally what people mean when they talk about "the stack"
21:00:07 <kc5tja> So, BEGIN will post a "cs-orig" item on the control (usually data) stack.
21:00:13 <sorear> in !forth, what does "control stack" mean?
21:00:35 <sorear> dons: nobench errored out
21:00:37 <sorear> cp: target `/home/dons/www/nobench/' is not a directory: No such file or directory
21:00:45 <dons> set PUBLISH=NO
21:00:48 <pjd> sorear: other languages generally just have a single control stack which does the job of both forth's data and return stacks
21:00:51 <dons> but sounds like the build went through
21:01:08 <sorear> dons: http://members.cox.net/stefanor/bench.results
21:01:59 <allbery_b> in compilers it can mean that the internal stack of control constructs (if-then-else; in haskell, do and let blocks, in other languages loop constructs) overflowed
21:02:06 <allbery_b> or in interpreters
21:02:34 <dons> sorear: so no yhc?
21:02:43 <dons> ah sorry
21:02:57 <dons> sorear: can you edit bin/versions to print the 'yhc' version ?
21:03:42 <dons> hmm. so yhc doesn't have getArgs in System?
21:03:49 <sorear> Creating patch to "http://www.cse.unsw.edu.au/~dons/code/nobench"...
21:03:50 <sorear> What is the target email address?
21:03:53 <sorear> dons: correct.
21:03:58 <dons> http://www.cse.unsw.edu.au/~dons/code/nobench/spectral/ansi
21:03:58 <dons> yhc                  176.043    seconds            (1.0 x)
21:03:58 <lambdabot> Title: Index of /~dons/code/nobench/spectral/ansi
21:04:00 <dons> yay
21:04:12 <falconair> I'm trying to understand Johan Jeuring's paper "Incremental algorithms on lists."  This paper is from 1991, are there any more recent papers that discuss the same ideas ... perhaps with haskell examples?
21:04:12 <dons> looks like it has some parser bugs too
21:04:41 <dons> sorear: ok. looks good. want to send me the yhc support patch? and maybe find out where getArgs lives ?
21:05:41 <sorear> dons@cse.unsw.edu.au ?
21:05:44 <dons> yep
21:06:00 <dons> sorear++
21:06:13 <sorear> too bad I can't send a patch to addfile _darcs/prefs/email :)
21:06:19 <dons> good idea...
21:06:21 * sorear checks versions
21:06:40 <dons> fixed
21:07:03 <sorear> stefan@stefans:/usr/local/src/nobench$ yhc --version
21:07:03 <sorear> yhc: The York Haskell Compiler version (unversioned)
21:07:06 <dons> so it should be possible to get a couple more yhc things running
21:07:07 <dons> heh
21:07:10 <dons> that'll do i guess
21:07:10 <sorear> how's that for a version string!
21:08:52 * sorear ponders using yhc -help | cksum
21:09:25 <nornagon> $ apt-cache search yhc
21:09:27 <nornagon> $
21:09:28 <nornagon> :-(
21:09:48 <bd_> Isn't it not yet stable enough for production use?
21:10:05 <sorear> You know you've been a haskell too long when
21:10:08 <sorear> stefan@stefans:/usr/local/src/nobench$ last /usr/local/src/yhc/_darcs/patches/*.gz
21:10:08 <sorear>  
21:10:08 <sorear> wtmp begins Thu Feb  1 07:14:37 2007
21:10:22 <sorear> +er
21:10:32 <dons> heh
21:10:42 <dons> bd_, not even close by the looks of it.
21:10:53 <dons> in fact, i'd argue only ghc is suitable for 'production'
21:11:09 <sorear> dons: System.Environment btw
21:11:10 <orbitz> hrm i hav ethe code where size2 = size `div` 2; h = sqrt $ size^2 - size2^2 and i'm getting...No instance for (Floating Int)
21:11:14 <dons> sorear: ok. fixing.
21:11:19 <orbitz> i've tried a few things with no success, wha tis this error?
21:11:23 <dons> though must be a Yhc mis-import
21:11:43 <nornagon> orbitz: add more rounding :) (or fromInteger)
21:11:46 <nornagon> :t div
21:11:49 <lambdabot> forall a. (Integral a) => a -> a -> a
21:12:01 <sorear> dons: patch sent
21:12:02 <orbitz> what does sqrt not like that?
21:12:07 <nornagon> :t sqrt
21:12:09 <lambdabot> forall a. (Floating a) => a -> a
21:12:15 <bd_> :t div
21:12:16 <ddarius> @type fromIntegral
21:12:19 <lambdabot> forall a. (Integral a) => a -> a -> a
21:12:19 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:12:20 <nornagon> :t (^)
21:12:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
21:12:41 <nornagon> sqrt does not take Ints.
21:12:49 <nornagon> you have to fromIntegral.
21:12:56 <nornagon> use sqrt.fromIntegral.
21:13:06 <orbitz> i fi change to: h = sqrt $ fromInteger (size^2 - size2^2) I get, Couldn't match expected type `Integer' against inferred type `Int'
21:13:06 <ivanm> @type (^)
21:13:09 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
21:13:14 <orbitz> oh form Integral
21:13:23 <ivanm> @type (**)
21:13:26 <lambdabot> forall a. (Floating a) => a -> a -> a
21:13:33 <nornagon> :t (^^)
21:13:34 <pjd> falconair: these two posts by Dan Piponi might (or not) be interesting/relevant
21:13:34 <pjd> http://sigfpe.blogspot.com/2006/11/from-l-theorem-to-spreadsheet.html
21:13:34 <pjd> http://sigfpe.blogspot.com/2007/02/comonads-and-reading-from-future.html
21:13:36 <lambdabot> Title: A Neighborhood of Infinity: From L&ouml;b's Theorem to Spreadsheet Evaluation, http://tinyurl.com/22eoxu
21:13:37 <lambdabot> Title: A Neighborhood of Infinity: Comonads and reading from the future, http://tinyurl.com/2gjj3d
21:13:37 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
21:13:43 <nornagon> @botsmash
21:13:44 <lambdabot> Unknown command, try @list
21:13:46 <kc5tja> @src mod
21:13:47 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:14:20 <kc5tja> hmmm... I used 9 appendages to type that command -- I think lambdabot needs an abject lesson in cordiality.
21:14:42 <sorear> dons: I've sent another patch
21:14:51 <falconair> crap, comonads ... i have enough trouble getting through basic catamorphisms :)  thanks pjd, I'll go through your references
21:15:03 <dons> thanks sorear
21:15:50 <pjd> falconair: it's more the Lb's theorem that's relevant, not comomads :)
21:16:27 <falconair> good, let's see if i learn any thing :)
21:16:31 <orbitz> nornagon: hrmm, No instance for (Num (a -> b)) ?
21:16:32 <sorear> dons: you might want to delete /home/dons/www/tmp/index.html :)
21:16:55 <pjd> what are those data-flow variables in Common Lisp called again?
21:17:18 <dons> heh
21:17:56 <sorear> Latin1 bytestrings, eh?
21:18:02 <pjd> ah, "cells"
21:18:20 <dons> hmm. repo broken. hmm
21:18:46 <pjd> falconair: http://common-lisp.net/project/cells/
21:18:47 <lambdabot> Title: Cells: a dataflow extension to CLOS
21:20:19 <kc5tja> What is the modulo (remainder) operator in Haskell?
21:20:27 <ddarius> @type med
21:20:30 <lambdabot> Not in scope: `med'
21:20:30 <ddarius> @type mod
21:20:33 <lambdabot> forall a. (Integral a) => a -> a -> a
21:20:34 <ddarius> @type re
21:20:37 <lambdabot> Not in scope: `re'
21:20:37 <sorear> @type rem
21:20:38 <ddarius> @type rem
21:20:40 <lambdabot> forall a. (Integral a) => a -> a -> a
21:20:42 <lambdabot> forall a. (Integral a) => a -> a -> a
21:20:50 <kc5tja> OK.
21:21:00 <kc5tja> So 1 rem 2 ought to return 1 as the result.
21:21:08 <kc5tja> Hence, 1 /= 0
21:21:19 <sorear> kc5tja: no it returns "no instance for Num (a -> b)"
21:21:20 <kc5tja> And that ought to be a valid boolean function.
21:21:29 <ddarius> > 1 `rem` 2
21:21:31 <lambdabot>  1
21:21:33 <falconair> pjd, cells sounds similar to functional reactive programming
21:21:36 <kc5tja> OOOHHH
21:21:37 <sorear> > 1 rem 2
21:21:38 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
21:21:39 <lambdabot>     I...
21:21:40 <kc5tja> I was forgetting those stupid backticks.
21:22:01 <pjd> falconair: it might well be (i still have to read about FRP)
21:22:03 <dons> sorear: the repo got borked. you'll have to reget from scratch
21:22:30 <falconair> cool, enough material to last me a while, thanks
21:22:35 <sorear> wha?
21:22:35 <sorear> /me obeys, bewildered
21:23:04 <dons> hugs started my box swapping, and then X reset itself during a darcs commit
21:23:17 <dons> the repo was left in a state that meant 'repair' broke :/
21:23:25 <dons> so  just killed the _darcs dir, and reinited
21:23:30 <Stinger> "@src" only works for basic library i.e. prelude stuff eh?
21:23:34 <dons> yeah
21:23:38 <dons> the base lib
21:23:43 <dons> some things from mtl
21:24:02 <nornagon> > let rem = const.const 0 in 1 `rem` 2
21:24:03 <lambdabot>  0
21:24:19 <Stinger> dang, I wanna see some System.Time stuff, is there a repos with html browsing anywhere?
21:24:19 <dons> sorear: so you up for jhc support now? :-)
21:24:24 <dons> ?source System.Time
21:24:25 <lambdabot> http://darcs.haskell.org/packages/base/System/Time.hs
21:24:29 <sorear> bah.  my attribution is gone :)
21:24:34 <dons> sorry
21:24:51 <sorear> dons: darcs needs to use transactional writing!
21:24:57 <Stinger> hmm 404
21:25:10 <dons> sorear: yeah.
21:25:15 <dons> http://darcs.haskell.org/packages/time/
21:25:17 <lambdabot> Title: Index of /packages/time
21:25:23 <kc5tja> Or, at least maintain a journal of things to do.
21:25:39 <kc5tja> (so that the journal can be replayed)
21:25:39 <sorear> kc5tja: one valid implementation of transactions
21:26:00 <kc5tja> Well, it's not strictly transactions.  But it sure helps.  :)
21:27:05 <orbitz> grr now i'm getting: Couldn't match expected type `Integer' against inferred type `Int'
21:27:08 * orbitz scratche head
21:27:39 <dons> fromIntegral ?
21:28:02 <dons> means you're missing arbtrary precision Integers with the native Int type
21:28:05 <dons> pick one!
21:28:18 <orbitz> No instance for (Floating Int)
21:28:36 <dons> fromIntegral
21:28:43 <dons> you're doing a / or something?
21:28:50 <dons> > (7 :: Int) / (4 :: Int)
21:28:52 <lambdabot>   add an instance declaration for (Fractional Int)
21:28:52 <lambdabot>     In the expression: (7 ...
21:28:57 <dons> > fromIntegral (7 :: Int) / fromIntegral (4 :: Int)
21:28:59 <lambdabot>  1.75
21:29:29 <orbitz> dons: div
21:29:30 <JohnnyL> > (+) 1 2
21:29:31 <lambdabot>  3
21:30:02 <dons> something in there has type Float then.
21:30:11 <orbitz> hrm i guess thi sis what nornagon was trying to get me to do before, it seemsto ocmpile: h = sqrt.fromIntegral (fromIntegral (size^2 - size2^2))
21:30:22 <orbitz> actullay no
21:30:23 <orbitz> i get
21:30:29 <orbitz> Couldn't match expected type `Int' against inferred type `a -> b'
21:30:35 <dons> work out the type of each of your variables.
21:30:42 <dons> a -> b usually means missing arguments
21:31:08 <sorear> bah.
21:31:29 <orbitz> dons: size is an Int
21:31:31 <sorear> if you delete a directory while in another vt you are in the directory ...
21:31:40 <orbitz> and size2 is the reuslt of size `div` 2
21:32:05 <allbery_b> (sqrt . fromIntegral) ?
21:32:10 <goltrpoat> > (sqrt . fromIntegral) (3^2 + 4^2 :: Int)
21:32:12 <lambdabot>  5.0
21:32:21 <sorear> dons: why do you distinguish compile steps from run steps?
21:32:22 <goltrpoat> > sqrt $ fromIntegral (3^2 + 4^2 :: Int)
21:32:24 <lambdabot>  5.0
21:32:45 <nornagon> > sqrt . fromIntegral (3^2+4^2 :: Int)
21:32:46 <lambdabot>   add an instance declaration for (Num (a -> b))
21:32:53 <nornagon> needs more brackets.
21:33:26 <sorear> dons: nm, doh, separate timing
21:34:10 <sorear> dons: who gave you bin/timeout.hs? every line ends with ^M!
21:34:12 <sorear> :)
21:34:25 <orbitz> i don't get it, form iIntegral work sin aht example but when i do
21:34:33 <orbitz> h = (sqrt . fromIntegral) (size^2 - size2^2 :: Int)
21:34:35 <dons> oh, its from ghc/testsuite/timeout
21:34:41 <orbitz> i get No instance for (Floating Int)
21:34:43 <orbitz> what am i doign wrong?
21:34:53 <dons> you're using an Int where a Double is expected
21:35:14 <dons> fromIntegral is required to convert the Int to its Double representation
21:35:15 <orbitz> but didn't goltrpoat just od the same thing?
21:35:41 <dons> that fragment doesn't necessarily have the same type constraints as your code
21:36:43 <goltrpoat> it's not the same thing..  (f . g) x = f (g x), while f . g x = f . (g x)
21:37:17 <orbitz> goltrpoat: i have paren in my paste dont' i?
21:37:41 <goltrpoat> oh, sorry.. stepped away, didn't see the second paste
21:38:02 <orbitz> hrm, size shoudl be a Int, so should size2
21:38:31 <hpaste>  orbitz pasted "(no title)" at http://hpaste.org/553
21:38:33 <sorear> dons: your timing method is fishy.  Why don't you use wait4(2)?  (eqv. time(1))
21:38:55 <orbitz> http://hpaste.org/553 i must be doign something very silly wrong
21:39:04 <dons> yeah, its a quick hack.
21:39:17 <sorear> dons: my nobench results are suspect, I thought I could safely run it in the background.
21:39:26 <goltrpoat> orbitz:  i'm guessing y + h is the problem, not the definition of h
21:39:37 <goltrpoat> assuming polygon takes [Int]
21:39:42 <kc5tja> (++) = foldr (\a b -> (a:) . b) id ---- "This actually makes sense intuitively."   Uhh...   No --  it doesn't.
21:39:45 <kc5tja> :)
21:39:55 <orbitz> goltrpoat: teh error i'mg ettin gis on teh sqrt, althouhg perhaps that would change if I did osmethign else?
21:39:56 * kc5tja laughs at the tutorial
21:40:11 <sorear> kc5tja: sure it does. remember that . is dlist catenate.
21:40:17 <allbery_b> (sqrt . fromIntegral) ?
21:40:38 <kc5tja> sorear: No, it's function composition.
21:40:47 <goltrpoat> try h = (round . sqrt . fromIntegral) (size^2 - size2^2)
21:40:59 <goltrpoat> like i said i'm just guessing though, since i don't know what the type of polygon is
21:41:20 <orbitz> goltrpoat: Graphics.SOE.polygon :: [Graphics.HGL.Internals.Types.Point]
21:41:32 <orbitz> Point is (Int, Int) i ebelivie
21:41:35 <goltrpoat> ah ok
21:41:42 <orbitz> goltrpoat: your changes compiles
21:41:54 <orbitz> thank you
21:41:56 <goltrpoat> cool
21:41:57 <goltrpoat> np
21:47:36 <glguy> > flip (foldr (:)) "this is " "a test "
21:47:37 <lambdabot>  "this is a test "
21:49:06 <Gwern> hoogle flip
21:49:12 <Gwern> no?
21:49:15 <Gwern> > hoogle flip
21:49:16 <lambdabot>   Not in scope: `hoogle'
21:49:20 <jcreigh> @hoogle flip
21:49:21 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
21:49:21 <glguy> :t flip
21:49:24 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:49:35 * Gwern sees. the ways of lambdabot are subtle and divers indeed
21:50:27 <jcreigh> Gwern: yeah, kinda trying. AFAIK, > and :t are the only "special" commands. Everything else has to be preceed with a @ or ?
21:50:39 <allbery_b> also :k
21:50:39 <jcreigh> s/trying/tricky/
21:50:48 <jcreigh> ah, see? more special cases.
21:51:00 <allbery_b> I think that's it though
21:51:18 <Gwern> :k? what does that do?
21:51:24 <allbery_b> kinds
21:51:27 <allbery_b> :k Maybe
21:51:30 <lambdabot> * -> *
21:51:46 <allbery_b> basically, describes the parameters of a type
21:51:50 <allbery_b> :k RWST
21:51:53 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
21:52:03 <allbery_b> :k []
21:52:06 <lambdabot> * -> *
21:52:09 <allbery_b> :k Int
21:52:12 <lambdabot> *
21:52:13 <jcreigh> Kinds are like types *for* types.
21:52:15 <allbery_b> :k [Int]
21:52:18 <lambdabot> *
21:52:32 <allbery_b> :k Either
21:52:34 <lambdabot> * -> * -> *
21:52:40 <allbery_b> :k Either String
21:52:42 <lambdabot> * -> *
21:52:45 <allbery_b> :k Either String Int
21:52:48 <lambdabot> *
21:52:48 <dons> um..
21:52:53 <allbery_b> that's it :)
21:52:56 <dons> :-)
21:52:59 <bd_> jcreigh: And sorts are kinds for kinds, right? Though, that starts to make my head hurt >.>
21:53:06 <bd_> er, types for kinds
21:53:10 <bd_> or kinds for types, I guess
21:53:13 <pjd> heh
21:53:17 <dons> yeah, you can classify kinds in things like Twelf
21:53:18 <pjd> sorta kinda types of things
21:53:20 <allbery_b> haskell doesn't go beyond kinds, and has only limited supprt for kinds
21:53:23 <dons> :k 1#
21:53:26 <lambdabot> parse error on input `1#'
21:53:37 <dons> :k GHC.Base.Int#
21:53:37 <jcreigh> "sorts"? Now you've lost me.
21:53:40 <lambdabot> #
21:53:47 <dons> jcreigh: so you have values, like 7
21:53:56 <dons> and 7 can be classified by its type, int
21:53:58 <dons> and 7 can be classified by its type, Int
21:54:27 <dons> and Int itself has a 'kind', the kind of heap allocated objects, *
21:54:43 <dons> as opposed to unboxed values, which have type Int# (for example), and kind #
21:54:48 <dons> :k (->)
21:54:51 <lambdabot> ?? -> ? -> *
21:54:56 <dons> the function constructor is interesting
21:55:02 <dons> since its sort-of kind polymorphic
21:55:11 <dons> since you can pass an unboxed or boxed type to ->
21:55:14 <dons> e.g. Int# -> Int
21:55:16 <dons> or Int -> Int
21:55:20 <dons> so # -> *
21:55:23 <dons> or * -> *
21:55:28 <dons> so you need a superkind, ??
21:55:31 <dons>  ?? -> *
21:56:01 <jcreigh> hmm
21:56:04 <dons> so you could say that all kinds in haskell have sort ??
21:57:11 <dons> so the many many possible values in haskell have a few types
21:57:15 <dons> those types have even less kinds,
21:57:22 <dons> and all the kinds are of a single sort, ??
21:57:24 <dons> :-)
21:58:07 <pjd> off-topic: has anyone noticed that you could write the State monad bind as x >>= f = \s -> uncurry f (x s) ?
21:58:08 <bd_> wait, isn't (->) :: Kind -> Kind -> Kind? You seem to imply it can take both sorts and kinds...
21:59:02 <dons> well, ?? isn't really a sort
21:59:11 <dons> its kind's superclass :-)
21:59:25 <dons> so kind subtyping, in ghc
22:10:50 <dons> yay yhc is almost building!
22:15:11 <ddarius> pjd: Well, that monad does come from the adjunction that curry/uncurry is a part of.
22:15:51 <pjd> ddarius: tell me more!
22:16:31 <pjd> or, where can i read more?
22:17:35 <pjd> what exactly is the adjunction that curry/uncurry is a part of?
22:17:50 <ddarius> pjd: Any introduction to category theory that goes over adjunctions and monads will show the general construction.
22:17:57 <ddarius> Ax-
22:18:17 <ddarius> Ax- -| A -> -
22:18:53 <pjd> hmm
22:19:28 <ddarius> The isomorphism of the homsets is curry and uncurry.
22:20:10 <ddarius> The monad is composed from the right followed by the left functor, i.e. A -> Ax-
22:27:34 <abz> I just finished my first real site using a bit of Ajax and Haskell: sdrit.com
22:28:03 <abz> Just as I finished it though, I realised that I've broken the back button.
22:28:13 <abz> I feel sooo dirty
22:28:19 <bd_> What happens if javascript is turned off? :)
22:28:25 <abz> don't know
22:29:28 <abz> the site just doesn't work if you turn off JS
22:30:13 <Cheery> "Welcome to SDR IT, where Software is Done Right."
22:30:21 <Cheery> and you use javascript. :P
22:30:26 <bd_> Every time someone uses AJAX to cripple functionality, god kills a kitten. Please, think of the kittens. :(
22:30:46 <abz> I know...I feel so bad. I'll have to fix that tomorrow
22:30:54 <bd_> [same goes for XML, MVC, CORBA, XSLT, and nearly any other buzzword acronym one can think of]
22:31:58 <Cheery> bd_: Actually, every time somebody uses especially those to anything, god kills an eastern culture.
22:32:32 <goltrpoat> bd_:  i can see CORBA, but what's wrong with multivariable calculus?
22:32:41 <bd_> Cheery: There is the rare case where someone uses them in a useful manner, but I suppose that's just a statistical fluke.
22:33:27 <bd_> goltrpoat: Nothing, god just failed that class back in his college days and feels the need to take it out on someone, is all.
22:33:33 <abz> is anyone using IE out there and can tell me whether the site looks correct?
22:33:51 <bos> @hoogle assoc
22:33:52 <lambdabot> Control.Parallel.Strategies.Assoc :: data Assoc a b
22:33:52 <lambdabot> Text.ParserCombinators.Parsec.Expr.Assoc :: data Assoc
22:33:52 <lambdabot> Array.assocs :: Ix a => Array a b -> [(a, b)]
22:34:16 <nornagon> @hoogle Graph
22:34:17 <lambdabot> Data.Graph :: module
22:34:17 <lambdabot> Data.Graph.Inductive.Graph :: module
22:34:17 <lambdabot> Data.Graph.Graph :: type Graph
22:35:58 <encryptio> @where obsfucated
22:35:58 <lambdabot> I know nothing about obsfucated.
22:36:13 <encryptio> where can i find some obsfucated haskell code?
22:37:12 <kc5tja> Here's some:  :)    (.) . (:)
22:37:13 <kc5tja> :)
22:37:35 <bd_> @unpl (.).(:)
22:37:35 <lambdabot> (\ f b c -> ((:)) f (b c))
22:37:53 <bd_> encryptio: lambdabot will be happy to generate some for you. Just run virtually anything through @pl :)
22:38:03 <encryptio> lol
22:38:20 <bd_> @pl uncurry (/) . foldr (\x -> (+x) *** (+1)) (0,0) $ [1..1000000]
22:38:21 <Cheery> @pl (+ 2 3)
22:38:21 <lambdabot> uncurry (/) (foldr ((*** (1 +)) . (+)) (0, 0) [1..1000000])
22:38:21 <lambdabot> (2 3 +)
22:38:27 <bd_> hmm, too easy
22:38:44 <Cheery> > (2 3 +)
22:38:45 <lambdabot>   add an instance declaration for (Num (t -> a))
22:38:53 <bd_> @pl let (sum, ct) = foldl' (\(sum, ct) n -> let s' = sum + n; ct' = succ ct in s' `seq` ct' `seq` (s', ct')) (0,0) [1..50000] in sum/ct
22:38:54 <Cheery> @pl (2 + 3)
22:38:54 <lambdabot> (line 1, column 5):
22:38:54 <lambdabot> unexpected "("
22:38:54 <lambdabot> expecting natural, identifier or "in"
22:38:55 <lambdabot> 5
22:39:12 <bd_> @pl let x = foldl' (\(sum, ct) n -> let s' = sum + n; ct' = succ ct in s' `seq` ct' `seq` (s', ct')) (0,0) [1..50000] in (fst x / snd x)
22:39:14 <lambdabot> uncurry (/) (foldl' (uncurry (flip ((.) . flip (ap (ap . (seq .) . seq) (,)) . fix . const . succ) . (+))) (0, 0) [1..50000])
22:39:18 <bd_> there :)
22:39:21 <Cheery> @pl \x -> x
22:39:22 <lambdabot> id
22:39:22 <encryptio> eesh.
22:39:25 <Cheery> hm.
22:39:39 <Cheery> bd_: it does not work for anything. :>
22:39:52 <bd_> Cheery: Use some variables, tsk >.>
22:40:01 <bd_> I said virtually anything :P
22:40:28 <bos> any cabal people around?
22:41:02 <Cheery> bd_: so it turns that stuff into non-variable form.
22:41:15 <bd_> right :)
22:41:23 <Cheery> @pl \x y z g -> (y^2) + x * g
22:41:24 <lambdabot> (const .) . flip ((.) . (+) . (^ 2)) . (*)
22:41:31 <Cheery> >:D
22:41:54 <bd_> @pl \x g z -> (x^2) + x * (g ^ (x+g+z))
22:41:55 <lambdabot> ap ((.) . (.) . (+) . (^ 2)) (ap ((.) . (.) . (*)) (liftM2 (.) (^) . ((+) .) . (+)))
22:42:14 <sieni> O_O
22:42:18 <nornagon> :-D
22:42:23 <bd_> @. unpl pl \x g z -> (x^2) + x * (g ^ (x+g+z))
22:42:23 <encryptio> D=
22:42:24 <lambdabot> ((\ ae b c f -> (ae ^ 2) + (b c f)) >>= \ x -> ((\ au i j m -> au * (i j m)) >>= \ am -> (\ ba -> (^) >>= \ o -> (\ bg -> (+) (ba + bg)) >>= \ n -> return (\ u -> o (n u))) >>= \ al -> return (am al)
22:42:25 <lambdabot> ) >>= \ w -> return (x w))
22:42:30 <bd_> :D
22:42:44 <nornagon> @. . . unpl pl unpl pl
22:42:45 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "pl\n"
22:42:45 <nornagon> er.
22:42:49 <Cheery> haha, that looks already a lot like perl.
22:42:53 <nornagon> @. . . unpl pl unpl pl \x g z -> (x^2) + x * (g ^ (x+g+z))
22:42:54 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "SrcLoc"
22:42:56 <bd_> unpl, you see, tries to reverse @pl. With....... mixed success
22:43:05 <bd_> @. pl . unpl pl \x g z -> (x^2) + x * (g ^ (x+g+z))
22:43:07 <lambdabot> (((((^) >>=) . (. ((return .) . (.))) . (>>=) . ((+) .) . (+) >>=) . (return .) =<< (.) . (.) . (*)) >>=) . (return .) =<< (.) . (.) . (+) . (^ 2)
22:43:08 <encryptio> Cheery: $nah, there'd $be a $lot $more $s
22:43:12 <bd_> @. unpl . pl . unpl pl \x g z -> (x^2) + x * (g ^ (x+g+z))
22:43:13 <lambdabot> (\ aa -> ((\ r s t -> r (s t)) >>= \ aj -> (\ am -> ((\ j k l -> j (k l)) >>= \ at -> (\ aw -> (^) >>= \ br -> (\ bx -> (+) (aw + bx)) >>= \ bu -> return (\ e -> br (bu e))) >>= \ ca -> return (at
22:43:14 <lambdabot> ca)) (\ n o -> am * (n o))) >>= \ cd -> return (aj cd)) (\ v w -> (aa ^ 2) + (v w)))
22:43:24 <bd_> @. unpl . pl . unpl . pl . unpl pl \x g z -> (x^2) + x * (g ^ (x+g+z))
22:43:24 <kc5tja> @src pl
22:43:26 <lambdabot> (\ aa -> ((\ r s t -> r (s t)) >>= \ aj -> (\ am -> ((\ j k l -> j (k l)) >>= \ at -> (\ aw -> (^) >>= \ br -> (\ bx -> (+) (aw + bx)) >>= \ bu -> return (\ e -> br (bu e))) >>= \ ca -> return (at
22:43:26 <lambdabot> ca)) (\ n o -> am * (n o))) >>= \ cd -> return (aj cd)) (\ v w -> (aa ^ 2) + (v w)))
22:43:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:43:32 <bd_> aw, it converged
22:43:43 <sorear> @source lambdabot
22:43:44 <lambdabot> lambdabot not available
22:43:53 <sorear> @where lambdabot
22:43:53 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:43:55 <kc5tja> @src src
22:43:56 <lambdabot> Source not found. Wrong!  You cheating scum!
22:43:59 <sieni> sorear: trying to flood the channel? :-)
22:44:04 <sieni> @source linux
22:44:05 <lambdabot> linux not available
22:44:09 <kc5tja> @src src
22:44:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:44:19 <sieni> @source sex
22:44:20 <lambdabot> sex not available
22:44:21 <int-e> @source X11R3
22:44:21 <lambdabot> X11R3 not available
22:44:22 <sieni> damn
22:44:33 <kc5tja> So, the rude responses must be a newbie deterrent.
22:44:36 <sorear> @source /me
22:44:37 * lambdabot not available
22:44:43 <encryptio> =o
22:44:49 <nornagon> :-o
22:44:51 <kc5tja> @source source
22:44:51 <lambdabot> source not available
22:44:51 <bd_> @quote avoid success
22:44:52 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
22:44:53 <sorear> @source /me is
22:44:53 * lambdabot is not available
22:45:00 <sieni> @source /disconnect
22:45:00 <nornagon> @source /say wtf, I'm
22:45:00 <bd_> ooh
22:45:00 <lambdabot> /disconnect not available
22:45:01 <lambdabot> /say wtf, I'm not available
22:45:05 <nornagon> aww.
22:45:13 <sieni> @source /quit
22:45:13 <lambdabot> /quit not available
22:45:19 <Cheery> :D
22:45:26 <bd_> @source TIME
22:45:27 <lambdabot> TIME not available
22:45:31 <bd_> heh
22:45:32 <sorear> sieni: lambdabot doesn't have a full ircii-type command processor, it only handles /me
22:45:33 <nornagon> heh
22:45:46 <Cheery> @source /me smart bot
22:45:46 * lambdabot smart bot not available
22:46:01 <sorear> @part #haskell
22:46:09 <sorear> that works however
22:46:49 <Cheery> sorear: funny how partial command processor saves it. :)
22:46:59 <sorear> ?
22:47:04 <kc5tja> I don't want to kill it.  I just don't like the rude-insults-as-humor.
22:47:11 <sorear> I sent bothcommands
22:47:32 <sorear> @source foo
22:47:32 <sorear> bar
22:47:33 <lambdabot> foo not available
22:47:52 <sorear> hmm, did I just say "bar" ?
22:48:12 <kc5tja> Sure did.
22:48:13 <int-e> what happened to lambdabot2?
22:48:19 <sorear> muahahah
22:48:30 <sorear> erc may not have /quote
22:48:42 <sorear> <sorear> @source foo^MPRIVMSG #haskell :bar
22:48:54 <sorear> muahahah.
22:49:18 <sorear> @read "foo\013PRIVMSG #haskell bar"
22:49:19 <lambdabot>  fooPRIVMSG #haskell bar
22:49:27 <sorear> @read "foo\rPRIVMSG #haskell bar"
22:49:28 <lambdabot>  fooPRIVMSG #haskell bar
22:49:35 <sorear> @read "foo\r\nPRIVMSG #haskell bar"
22:49:36 <lambdabot>  fooPRIVMSG #haskell bar
22:49:50 <int-e> we've been there, sorear
22:53:18 <bd_> @source foo\nbar
22:53:19 <lambdabot> foo\nbar not available
22:53:25 <bd_> @. source read "foo\r\nbar"
22:53:26 <lambdabot> foobar not available
22:53:28 <bd_> tsk
22:54:43 <sorear> @. source read "foo\001bar"
22:54:44 <lambdabot> foobar not available
22:55:13 <sorear> @. source read "foo\013bar"
22:55:14 <lambdabot> foobar not available
22:56:08 <sorear> @. source read "foo\0bar"
22:56:08 <lambdabot> foo
22:56:13 <goltrpoat> yay for filter (not . isControl)
22:56:17 <sorear> hahah
22:56:43 <bd_> @read "\001ACTION tests\001"
22:56:44 <lambdabot>  ACTION tests
22:56:47 <sorear> does this get cut at the NUL? -->
22:56:54 <bd_> apparently
22:56:55 <sorear> anyone saw the foo?
22:57:01 <bd_> nope
22:57:12 * sorear teases the authors of hyperion
22:57:21 <bd_> could be in your client :)
22:57:57 <sorear> erc, written in lisp, probably uses lisp strings (sized vectors of char)
22:58:33 <bd_> ah, I see
22:59:11 <goltrpoat> xchat shows these 2x2 matrix determinants for \001.  of singular matrices.  it's quite special.
22:59:25 <nornagon> Dear IRC,
22:59:37 <nornagon> Please stop distracting me. I need to do some maths homework.
22:59:40 <nornagon> Love, nornagon.
23:00:14 <int-e> the trick is to /quit until the client disappears.
23:00:37 <int-e> or so I've heard.
23:02:21 <sorear> @read "I hope this \192\141\192\138 doesn't work, it would be so embarassing"
23:02:22 <lambdabot>  I hope this  doesn't work, it would be so embarassing
23:10:02 <nrb23> so, I have a function "next" that's () -> IO Foo
23:10:17 <nrb23> well, let's call it () -> IO (Maybe Foo)
23:10:23 <nrb23> and I want to turn it into [Foo]
23:10:32 <nrb23> lazily, if possible
23:11:30 <bd_> you mean IO [Foo]?
23:11:59 <bd_> also there's no need for () in the argument, just IO Foo or IO (Maybe Foo)
23:12:03 <bd_> in any case
23:12:06 <nrb23> sure, that work work
23:12:12 <bd_> if you want to build a lazy-list in IO
23:12:25 <bd_> first, keep in mind this is Unsafe - you'll never know when things will be evaluated
23:12:25 <nrb23> bd_: well, it's not actually (), but I decided to simplify things
23:12:35 <bd_> and in theory they might be evaluated more than once
23:12:51 <bd_> if this won't affect your program's behavior, take a look at unsafeInterleaveIO
23:12:54 <bd_> in System.IO.Unsafe
23:13:23 <nrb23> hm.. this function returns something different every time
23:13:39 <bd_> what do you mean by that?
23:13:58 <nrb23> well, it's a ffi-wrapping function
23:14:19 <nrb23> and each time you call it, it returns the next item from C-land
23:14:24 <bd_> ah
23:14:40 <bd_> well, you can use unsafeInterleaveIO for that, I think. getContents is implemented with it...
23:15:01 <bd_> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html#v%3AunsafeInterleaveIO
23:15:04 <lambdabot> http://tinyurl.com/2akd4n
23:15:07 <roconnor> :t ( . ) ( . )
23:15:10 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
23:15:11 <bd_> anyway, I must sleep now
23:15:16 <bd_> @unpl (.).(.)
23:15:16 <lambdabot> (\ i b c f -> i (b c f))
23:15:22 <nrb23> thanks bd_
23:15:37 <roconnor> :t ( . ) . ( . )
23:15:39 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
23:17:05 <nrb23> hmm.. the colloquy guys say they won't fix the improper parsing that's making the links in the #haskell topic useless
23:17:13 <nrb23> because sometimes people use quotes inside their urls
23:17:27 <encryptio> there's an easy way around that...
23:17:49 <nrb23> encryptio: get a new IRC client?
23:18:01 <encryptio> no, i mean to actually fix the problem in colloquy
23:19:12 <nrb23> encryptio: looks like they are going to fix it :->
23:19:20 <encryptio> coo.
23:23:18 <ddarius> @where foobar
23:23:18 <lambdabot> I know nothing about foobar.
23:23:31 <encryptio> @where foo
23:23:31 <lambdabot> I know nothing about foo.
23:24:09 * ddarius wonders if the obvious "joke" @where has been handled one way or another.
23:24:48 <encryptio> @where my socks
23:24:48 <lambdabot> I know nothing about my.
23:24:49 <kc5tja> @src when
23:24:50 <lambdabot> when p s = if p then s else return ()
23:24:52 <encryptio> =(
23:25:35 * encryptio goes to look for socks
23:26:14 <ddarius> I need to do laundry.  I guess that something for tomorrow (well today... the next waking cycle... hopefully)
23:27:40 <ddarius> Embedded concurrenct constraint handling rules. Sweet!
23:30:05 <ski_> ddarius : where ?
23:31:26 <dons> edwinb: cheers for blogging :-)   we need to take advantage of the good authors in the community
23:31:40 <ddarius> @google A Concurrent Constraint Handling Rules Implementation in Haskell with Software Transactional Memory
23:31:42 <lambdabot> http://www.cs.cmu.edu/~damp/finalPapers/lam.pdf
23:31:55 <ski_> cool! ty
23:31:56 <ddarius> wtf? Is that the same thing...
23:32:10 <ski_> same as what ?
23:32:11 <dons> http://programming.reddit.com/info/15bqg/comments   its about time, right? :-)
23:32:12 <lambdabot> Title: Ask Moggi: what is a monad? (ps.gz) (reddit.com)
23:32:19 <dons> :D
23:32:29 <pjd> Ask Moggi, haha
23:32:34 <ddarius> yep, ski_, I have a ps name chr-stm.ps
23:34:40 <nornagon> hm, a little OT, but are there any programs for a unix shell (netcat-alikes) that read/write from/to UNIX domain sockets?
23:35:04 <ski_> ddarius : sorry ?
23:35:19 <encryptio> nornagon: cat?
23:36:29 <ddarius> ski_: I wasn't sure that that was the same paper.  Also, this may be interesting http://www.cs.mu.oz.au/~gjd/haskellchr/ but I haven't looked at it.
23:36:30 <lambdabot> Title: HaskellCHR -- a simple CHR implementation for Haskell (GHC)!
23:36:33 <nornagon> encryptio: encryptio zsh: no such device or address: /tmp/irssi_socket
23:36:35 <nornagon> er
23:36:42 <nornagon> just one encryptio would've done.
23:36:59 <pjd> nornagon: socat!
23:37:13 * nornagon sagi
23:37:37 <pjd> http://www.dest-unreach.org/socat/
23:37:38 <lambdabot> Title: socat
23:37:41 <pjd> it's the Grand High netcat
23:38:33 <nornagon> nifty
23:38:35 <nornagon> ... hm
23:38:44 <nornagon> i did $ socat stdin unix-connect:/tmp/irssi_socket
23:38:50 <nornagon> and... then i couldn't type in irssi.
23:41:32 <nornagon> hm
23:41:37 <nornagon> turns out to be the script's fault
23:41:58 <ski_> ddarius : ok
23:44:55 <kfish> hmm, anyone got a bibtex reference for Mun's Frag thesis?
23:47:10 <ddarius> kfish: citeseer
23:47:51 <dons> kfish: don't think there is one
23:48:02 <dons> kfish: shouldn't be too hard to reconstruct
23:48:09 <kfish> dons, sure, doing so atm
23:48:18 <kfish> will add it to the wiki page
23:49:51 <kfish> hmm, poor guy's got no citations on that :-(
23:50:31 <encryptio> @unpl (.) . (>>=) . (:)
23:50:31 <lambdabot> (\ f b c -> (((:)) f) >>= (b c))
23:51:19 <dons> I don't know of any citations for Mun's work. actually ,not sure what he's up to now. he got a job straight after his honour thesis
23:51:23 <dons> and haven't heard from him since
23:52:13 <kfish> dons, bummer -- ah, I thought that was a master's thesis -- just noticed it wasn't (on the title page)
23:55:18 <kfish> dons: there's no @undergradthesis in bibtex ;-) was it published as a unsw tech report or anything? else I guess it's @misc
23:56:01 <Syzygy-> Can't you tweak the @phdthesis appropriately?
23:56:41 <kfish> Syzygy-, just choosing from the standard entry types, that's all
23:56:49 <dons> no, not techreport.
23:56:53 <kfish> dons, ok
23:56:54 <dons> i guess its roughly a master's thesis
23:57:17 <kfish> if it's just for latex formatting, that's probably ok
23:57:28 <kfish> coulda fooled me anyway
