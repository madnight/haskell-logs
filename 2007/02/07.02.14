00:00:13 <glguy> or does it become an Int?
00:00:38 <glguy> what about any other member of Num
00:00:45 <glguy> instance* rather
00:00:48 <glguy> ones you define
00:00:52 <glguy> how do they coerce?
00:01:01 <allbery_b> Rational?  Complex?  Fixed?
00:01:26 <glguy> Does the coersion cause you to lose information?
00:01:41 <glguy> if it does, do you want that to occur implicitly?
00:02:23 <siti> > 1.0 == 1.0000000000000000001
00:02:25 <lambdabot>  True
00:02:41 <siti> silly they should not allow comparisons of doubles ;)
00:02:44 <glguy> > floor (1/0::Double) == 2^2^10
00:02:46 <lambdabot>  True
00:03:19 <glguy> > floor (1/0::Double) < 2^2^10+1
00:03:21 <lambdabot>  True
00:03:42 <siti> silly smiley
00:03:51 <siti> put spaces there ;)
00:35:37 <robreim> is there anything like select() for non-blocking IO in haskell?
00:38:00 <musasabi> robreim: using Haskell threads is usually scalable enough.
00:38:10 <musasabi> robreim: with GHC they use select underneath.
00:39:50 <robreim> ah yes, thanks.
00:47:34 <dmead> ?src drop
00:47:34 <lambdabot> drop n xs     | n <= 0 =  xs
00:47:34 <lambdabot> drop _ []              =  []
00:47:34 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
00:47:44 <dmead> soo
00:47:50 <dmead> one of my pals wants to change to comp sci
00:47:54 <dmead> and i looked at his course list
00:48:03 <dmead> and all the upper level FP classes use haskell
00:48:05 <dmead> =)
00:49:16 <yogan> Can I use SOEGraphics from Hugs with GHC?
00:49:41 <siti> dmead: nice :)
01:16:44 <earthy> yogan: no, you can't, IIRC
01:17:10 <Elifant> Hello all. I'm reading ftphs documentation. Quote: 'All exceptions raised by this module have a string beginning with "FTP: ".' After C++,Python,Ruby,... where I can catch errors by type, detecting errors by string prefix is a bit... ugly. Why haskell does this, and Is this really the best way?
01:21:28 <dmead> Elifant: i think theres a catch in haskell
01:21:50 <dmead> chances are it looks just like a c++ catch
01:22:06 <Elifant> I know about catch.
01:22:37 <dmead> you'd use case
01:22:39 <Elifant> But inside catch I have to sort out FTP exceptions by string prefix.
01:22:53 <dmead> ah
01:22:59 <dmead> hmm
01:23:05 <dmead> so just string matching at that point?
01:23:27 <dmead> you could use the regex library
01:24:08 <Elifant> But it's hack! It's like old C functions which returns 0 if all is OK, or error code if there were error.
01:24:24 <dmead> well...
01:24:26 <Elifant> C++,Python,... exception have much more power
01:24:38 <dmead> sure, if it's done right the exception will all have a type you can pattern match to
01:24:42 <dmead> ?paste
01:24:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:24:53 <dmead> i'll paste you a sketch that might help
01:25:00 <Elifant> I know there is ErrorMonad, but it seems it isn't always used...
01:25:41 <dmead> eh
01:25:50 <dmead> do you really want a monad?
01:26:10 <Elifant> why not? at least I can then put any error information, not just plain string.
01:27:11 <hpaste>  dmead pasted "like this?" at http://hpaste.org/487
01:27:31 <Elifant> but then I have to lift every error monad from inner functions into error monad of outer function...
01:27:53 <dmead> o0
01:28:01 <dmead> wait
01:28:36 <dmead> link to ftphs?
01:28:38 <Elifant> so, one side packs all parameters to string, and then catching side have to parse this string to extract parameters?
01:28:45 <Elifant> I think it's just stupid
01:28:54 <Elifant> http://software.complete.org/ftphs/static/doc/Network-FTP-Client.html
01:28:56 <lambdabot> http://tinyurl.com/26s26s
01:29:37 <dmead> oh
01:29:41 <dmead> no lol
01:29:53 <dmead> you just have to pattern match
01:32:28 <dmead> in the catch statement, just have a case OR a call to a function to process the errors
01:32:39 <dmead> then you can pattern match to an error, ETC
01:36:40 <robreim> What's the difference between TVars and TMVars?
01:41:38 <Elifant> robreim: TMVar is synchronising, i.e. may be used from multiple threads
01:42:55 <robreim> TVar's not?
01:42:56 <ibid> isn't the point of TVars that they ca be used from multiple threads?
01:45:09 <Lemmih> TMVar a = TVar (Maybe a)
01:45:45 <int-e> Lemmih: except that you can truly block on it instead of busily failing when you find nothing?
01:46:06 <ibid> ah, so the point is that a TMVar can be empty, and thus is synchronising
01:46:09 <ibid> nice
01:46:18 <robreim> ah thanks
01:46:23 <Lemmih> int-e: Well, that's a property of STM, not TMVar.
01:46:32 <int-e> newtype TMVar a = TMVar (TVar (Maybe a)) ah. *looks at the rest of the implementation.*
01:46:54 <int-e> case m of Nothing -> retry   ... scary.
01:48:50 <ibid> int-e: i don't think it busyloops; iirc the thread will wait until one of the variables read earlier gets changed
01:48:52 <int-e> Lemmih: so unlike the interface suggests the scheduler still has no knowledge of that the operation is actually blocking at that point. :(
01:49:40 <Lemmih> int-e: It doesn't?
01:50:16 <int-e> maybe it does. ibid: thanks.
01:50:25 <ibid> int-e: in the docs of retry: "The implementation may block the thread until one of the TVars that it has read from has been udpated."
01:53:48 <int-e> ibid: thanks a lot, that point makes me feel a whole lot better about STM in general.
01:54:35 <ibid> int-e: the stm papers go into detail about how it can be implemented
01:56:13 <kaol> I still have to read that STM thread on LtU...
01:57:06 <kaol> what's the state of message passing concurrency in haskell?
02:02:55 <ibid> kaol: Control.Concurrent.Chan for mailboxes, not sure if there are standard facilities for rendezvous messaging
02:02:59 <Cale> kaol: You just implement it by hand. There's not a whole lot to message passing.
02:04:40 <int-e> ibid: MVars?
02:04:40 * Lemmih wonders what Conjure would look like if message passing were used instead of STM.
02:04:40 <int-e> ibid: hmm, not quite.
02:06:07 <dcoutts> dons, hah hah, I like this:
02:06:11 <dcoutts> alexInputPrevChar !s = w2c $! unsafeIndex s (-1) -- !!
02:06:38 <dons> well, , at least I wrote a comment, eh?
02:06:39 <ibid> int-e: exactly
02:06:39 <dcoutts> dons, sadly it'll fail for lazy ByteStrings on chunk boundaries :-)
02:06:41 <ibid> but you can build it if you want
02:06:46 <ibid> the primtives are there
02:06:55 <dcoutts> dons, note that his lexer doesn't need the prev char feature though
02:06:58 <dons> I was having  a hard time  getting ghc to unbox the ByteString into an Addr#
02:07:02 <dcoutts> dons, very few do
02:07:19 <dcoutts> dons, aye, the (,) was getting in the way I suppose?
02:07:26 <dons> yeah
02:07:33 <dons> ghc should know this
02:07:37 <int-e> ibid: for example you can use  MVar (a, MVar ()) -> message a, delivery notification to the passed MVar.
02:07:47 <dons> when I write (_,!s) i really have a trict pair
02:12:09 <benja_> dcoutts: ok... I suppose I'll try to get the color fields instead of the mysterious gc fields
02:12:13 <benja_> thanks :)
02:12:51 <dcoutts> benja_, I guess the existing functions that return GC's should have type Maybe
02:13:25 <dcoutts> benja_, if you want to add those colour-getting functions to the Gtk2Hs Style/Structs module then do send in patches
02:14:00 <benja_> first I'll have to see whether I can make it work :)
02:14:04 <benja_> if so, I will
02:22:31 <Laney> Is it possible to map to a function which returns IO() somehow?
02:22:50 <Cale> Laney: what would the type of what you mean be?
02:23:02 <Cale> @type sequence
02:23:04 <lambdabot>     Ambiguous occurrence `sequence'
02:23:05 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
02:23:10 <Cale> @type Control.Monadsequence
02:23:12 <Cale> @type Control.Monad.sequence
02:23:13 <lambdabot> Couldn't find qualified module.
02:23:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:23:39 <Laney> Well I have a list of tic-tac-toe boards and a function showBoard :: Board -> IO(), and I want to print out every board in the list.
02:23:40 <Cale> That takes a list of IO actions and gives an IO action returning a list.
02:23:50 <Cale> ah, you want mapM
02:23:55 <Cale> @type mapM
02:23:57 <lambdabot>     Ambiguous occurrence `mapM'
02:23:57 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
02:24:00 <Cale> grr...
02:24:04 <Cale> @type Control.Monad.mapM
02:24:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:24:09 <mux> what's up with lambdabot
02:24:17 <Cale> It's got new modules. :)
02:24:18 <mux> we need to qualify everything now?
02:24:24 <mux> heh
02:24:33 <Cale> Some which should be imported qualified...
02:25:18 <Laney> That was it, thanks Cale!
02:25:28 <Cale> Laney: Anyway, mapM your function over the list. Or mapM_, which will throw away the results, because you don't care about them.
02:25:40 <Cale> No problem :)
02:33:30 <nornagon> @src Reader
02:33:31 <lambdabot> Source not found. It can only be attributed to human error.
02:33:49 <nornagon> @hoogle Rea
02:33:49 <lambdabot> Control.Monad.Reader :: module
02:33:49 <lambdabot> System.Console.Readline :: module
02:33:49 <lambdabot> Text.ParserCombinators.ReadP :: module
02:33:50 <nornagon> er
02:33:52 <nornagon> oh.
02:33:58 <nornagon> @src Control.Monad.Reader
02:33:58 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:34:23 <nornagon> newtype Reader e a = Reader { runReader :: (e -> a) } -- this is what All About Monads says.
02:34:28 <nornagon> I don't get that runReader part.
02:36:52 <benja_> dcoutts: I seem to have it working! :-)
02:37:01 <dcoutts> benja_, cool
02:37:06 <ibid> nornagon: it's a named field. or are you asking why it is named like that?
02:37:29 <nornagon> ibid: oh.
02:37:36 <benja_> so now that I'm going to do the change, does it make sense at all to keep the GC versions?
02:37:46 <nornagon> ibid: how does it then work like a function?
02:37:49 <benja_> (the alternative being to turn them into returning Colors)
02:37:53 <nornagon> runReader some_reader
02:38:02 <ibid> nornagon: because it stores a function, notice the type
02:38:12 <ibid> nornagon: e -> a after the ::
02:38:17 <benja_> I don't think anybody can be using them, seeing as there hasn't been a funtion in gtk2hs to obtain an instance of Style :-)
02:38:17 <dcoutts> benja_, I'm not sure they will always be NULL, really I don't know.
02:38:19 <nornagon> how does it know that that's the function it's referring to..?
02:38:24 <dcoutts> benja_, true :-)
02:38:31 <ibid> nornagon: ah, sorry, misread the question
02:38:31 <nornagon> the record syntax still befuddles me
02:38:40 <dcoutts> benja_, well feel free to patch them to return the colour
02:38:49 <nornagon> @src runReader
02:38:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:38:51 <benja_> ok, I'll do that
02:39:19 <benja_> I don't know whether it always returns NULL either, but getting the Color seems like the saner interface to the same information :)
02:39:26 <ibid> nornagon: the field name acts as a function that you can give the record to as a parameter, and it returns the value of the field
02:39:36 <nornagon> oh, really?
02:39:40 <ibid> nornagon: yes
02:39:52 <nornagon> i thought you had to define such functions separately...
02:40:02 <ibid> nornagon: that's the reason why different records must have differently named fields
02:40:21 <ibid> nornagon: ... because they become functions in the module namespace :)
02:40:24 <nornagon> and could only do it by pattern matching, i.e runReader (Reader {runReader=a}) = a
02:40:47 <ibid> nornagon: yeah, a selector function is automatically defined
02:40:56 <nornagon> Okay then.
02:41:00 <nornagon> I guess that makes sense.
02:41:18 <ibid> nornagon: you do, however have to define a setting function if you need one
02:42:02 <ibid> nornagon: though most of the time just using the update syntax is easier
02:50:02 <kosmikus> ?seen ndm
02:50:02 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 12h 42m ago, and .
02:54:14 <benja_> dcoutts: I'm wrapping up the patch; wondering whether the rcGetStyle method should be called something else
02:54:30 <benja_> getStyle and widgetGetStyle would seem like natural candidates
02:54:42 <benja_> but I don't know the rules for gtk2hs naming :)
02:54:52 <dcoutts> benja_, the latter seems fine, since it's a method on widgets
02:55:01 <benja_> ok
02:55:18 <benja_> it should still be in General.Style, though?
02:55:44 <dcoutts> benja_, aye, I was going to say that it also suggests it should be in the Widget module
02:56:17 <benja_> ok :)
02:57:00 <dcoutts> benja_, hmm wait a moment
02:57:04 <dcoutts> let me check something
02:58:32 <dcoutts> benja_, there's already a gtk_widget_get_style
02:58:56 <dcoutts> benja_, this thing is for creating a new style for a widget
02:59:37 <benja_> meaning that we should actualy bind gtk_widget_get_style?
02:59:52 <dcoutts> benja_, depends what it is you're trying to do
03:00:17 <benja_> we're trying to get the Style for a widget :)
03:00:22 <dcoutts> benja_, apparently every 'realised' widget has a style
03:00:41 <benja_> I'll try using it
03:00:57 <benja_> does realized mean that it has to have beendrawn on the screen?
03:01:40 <dcoutts> benja_, right, so if you want to get the widget's style before it's been realised you need to call gtk_widget_ensure_style
03:01:41 <benja_> http://www.gtk.org/tutorial1.2/gtk_tut-6.html uses gtk_widget_get_style
03:01:41 <lambdabot> Title: GTK v1.2 Tutorial: The Button Widget
03:02:18 <benja_> oh, would it make sense to call that in widgetGetStyle?
03:02:30 <benja_> or should I makea separate binding?
03:02:38 <dcoutts> hmm
03:03:39 <dcoutts> benja_, yeah, from a quick peek at the source it looks cheap so might as well call that first.
03:04:11 <dcoutts> benja_, ie it checks if it's got a style already and if not calls gtk_widget_reset_rc_style
03:04:49 <benja_> ok
03:17:58 <profmakx> hm. why does lambdabot-build complain about arrows-any with ghc-6.6?
03:18:09 <profmakx> missing arrows-any that is
03:19:44 <Cale> profmakx: that's a library you can get from hackage
03:19:48 <Cale> @where hackage
03:19:48 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
03:19:53 <profmakx> yeah i know
03:20:00 <profmakx> but i thought it was included in ghc-6.6?
03:20:05 <profmakx> or am i missing something?
03:20:25 <Cale> I don't think so. Control.Arrow is, but I don't think arrow transformers are.
03:21:00 <profmakx> well i`ll try installing it ;)
03:23:03 <profmakx> well okay, i just missed that one ;) thanks anyway
03:24:05 <ejt> quickcheck or smallcheck ?
03:24:33 <Cale> ejt: hm?
03:25:28 <ejt> I was just about to add lots of quickchecks to a project I've been working on, then saw that smallcheck exists.  Was wondering if one was prefereable to the other ?
03:25:46 <Cale> They're complementary
03:26:09 <Cale> smallcheck is for when you want to do a bunch of tests against "small" values of a type which are likely to be boundary cases
03:26:16 <Cale> quickcheck is random testing
03:26:25 <ejt> k, thx
03:27:03 <Cale> Cute, I just noticed that Hackage is using my Cabal logo for bullets :)
03:34:55 <benja_> dcoutts: sent
03:35:05 <dcoutts> ta
03:35:24 <benja_> (awaits mod approval)
03:47:19 <Cale> haha
03:47:22 <Cale> http://www.google.com/
03:47:23 <lambdabot> Title: Google
03:47:29 <dcoutts> @seen aking
03:47:29 <lambdabot> aking is in #gentoo-haskell and #haskell. I don't know when aking last spoke.
03:47:51 <Cale> Google misspelled their logo.
03:48:44 <dcoutts> they've gone all gooye for valentines day :-)
03:53:43 <matthew-_> with gadts, is it possible to build a list structure which allows for a value of any type at each index in the list but is still typesafe?
03:54:33 <matthew-_> eg being able to build something like [1,'a',"the rain in Spain",True] have have the type of the list track the types of the elems in the list?
03:55:22 <Cale> That's the idea behind HList
03:55:45 <Cale> Which is really just a fancy way of managing nested pairs.
03:56:26 <matthew-_> ok. that's from the Strongly typed heterogeneous collections paper right?
03:56:34 <Cale> yeah
03:57:00 <Cale> Well, HList doesn't use GADTs, I'm not sure whether it could be simplified using them.
03:59:23 <matthew-_> ok. I dunno either. I've done it in Epigram - there it's very simple to parameterise the list type with a list of types which just happens to correspond to the types of the elems in the list-value
04:02:43 <Saizan> is there an haddock of HList?
04:04:21 <matthew-_> there's not a debian package. ;-(
04:05:17 <Cale> *Main> Cons 5 (Cons "Hello" (Cons (2,3) Nil))
04:05:17 <Cale> (Cons 5 (Cons "Hello" (Cons (2,3) Nil)))
04:05:17 <Cale> *Main> :t Cons 5 (Cons "Hello" (Cons (2,3) Nil))
04:05:17 <Cale> Cons 5 (Cons "Hello" (Cons (2,3) Nil)) :: (Num t, Num t1, Num t2) => HList (t, ([Char], ((t1, t2), ())))
04:05:28 <Cale> !paste
04:05:29 <hpaste> Haskell paste bin: http://hpaste.org/
04:05:45 <hpaste>  Cale pasted "(no title)" at http://hpaste.org/488
04:06:06 <Cale> There's a quick and easy implementation of such lists using GADTs.
04:06:23 <Cale> But it doesn't do all the cool stuff that HList does.
04:06:58 <edwinb> Hmm. What's the type of the lookup function for those lists?
04:07:15 <matthew-_> Cale: mmm. that's quite nice.
04:07:45 <edwinb> I'm not sure how that'd work with GADTs
04:08:36 <Cale> hLength :: HList a -> Integer
04:08:36 <Cale> hLength Nil         = 0
04:08:36 <Cale> hLength (Cons x xs) = 1 + hLength xs
04:09:05 <Cale> hmm, lookup, or even elem.
04:09:28 <edwinb> yeah, it's hard without being able to write a type level function somehow
04:09:41 <Cale> You need type level equality testing.
04:09:57 <Cale> actually, hmm...
04:10:53 <matthew-_> http://www.wellquite.org/non-blog/list.epi
04:11:01 <givi> hello. How can I perform the next operation in the most neat way: [1,2,3,4..] -> [1,1,2,2,3,3,4,4..] ?
04:11:13 <matthew-_> where Memory is the heterogeneous list type
04:11:58 <givi> doubling (or in general n-ning) each element in a list
04:13:21 <matthew-_> > foldr (\x t -> x:x:t) [] [1,2,3,4]
04:13:21 <Slarba_> givi: doublelist (x:xs) = x:x:(doublelist xs)
04:13:22 <lambdabot>  [1,1,2,2,3,3,4,4]
04:13:43 <Slarba_> and of course the empty list case doublelist [] = []
04:13:52 <quicksilver> > concatMap (\x -> [x,x]) [1,2,3,4]
04:13:53 <lambdabot>  [1,1,2,2,3,3,4,4]
04:14:23 <givi> thanx! I've already found a realization through replicate :)
04:14:44 * matthew-_ wonders if this is #perl given the tmtowtdi
04:14:47 <quicksilver> > concatMap (replicate 3) [1,2,3,4]
04:14:48 <lambdabot>  [1,1,1,2,2,2,3,3,3,4,4,4]
04:15:04 <givi> yes, it is! )))
04:15:08 <quicksilver> concatMap may not be the fastest, but IMO it's the clearest
04:15:22 <quicksilver> (and maybe you can trust the compile to do the optimisation)
04:15:30 <Cale> I can do it with -fallow-incoherent-instances
04:15:55 <hpaste>  Cale annotated "(no title)" with "elem" at http://hpaste.org/488#a1
04:16:14 <Cale> That's so evil though :)
04:17:00 <Cale> Lookup is trickier.
04:17:41 <quicksilver> @pl \x -> [x,x]
04:17:42 <lambdabot> ap (:) return
04:17:49 <quicksilver> cute
04:18:16 <Cale> because which type of value is returned may depend on the value in the list which matches
04:19:12 <matthew-_> yep
04:20:12 <quicksilver> @pl \x -> [x,x,x]
04:20:12 <lambdabot> ap (:) (ap (:) return)
04:20:14 <Cale> Heterogeneous lists are overrated though.
04:20:17 <Cale> ;)
04:20:26 <quicksilver> they are a very cute type system hack
04:20:37 <quicksilver> doesn't mean I'd choose to program in them very often.
04:20:37 <matthew-_> um, for my purposes they're still not powerful enough...
04:20:40 <edwinb> I'm using them loads in my dependently typed programs ;)
04:20:50 <edwinb> I'm using them to make sure environments have well-typed entries
04:20:54 <matthew-_> edwinb: which language ?
04:21:00 <edwinb> I can't think of any other uses off the top of my head
04:21:13 <edwinb> matthew-_: Ivor, my own hack
04:21:22 <edwinb> none of the existing systems do what I want yet
04:21:44 <matthew-_> edwinb: ooo! can I play?
04:22:00 <quicksilver> you only need (somethign like) that if you want environments to be able to contain variables from an infinite set of types
04:22:11 <edwinb> matthew-_: sure... http://www.dcs.st-and.ac.uk/~eb/ivor.php
04:22:13 <lambdabot> Title: Ivor
04:22:23 <edwinb> good luck with it though, there is a severe lack of documentation ;)
04:22:23 <matthew-_> st-and - st andrews?
04:22:28 <edwinb> yes
04:22:43 <matthew-_> edwinb: hey, I started on Linux back when there was a severe lack of documentation ;)
04:22:48 <edwinb> hehe
04:23:11 <edwinb> I only added pattern matching last week so that isn't documented at all yet...
04:23:41 <matthew-_> edwinb: who am I thinking of that's on the epigram team that's at st andrews?
04:24:01 <edwinb> James McKinna is here
04:25:31 <matthew-_> yep, that's the one.
04:28:31 <matthew-_> so, at a quick glance it seems to have a prolog feel how you're adding stuff into the universe at the top of LogicDemo.lhs
04:30:27 <edwinb> suppose it could be. They're just ordinary polymorphic data structures though.
04:39:49 <rindolf> Hi all.
04:41:09 <matthew-_> edwinb: you might want in the INSTALL to remove util dependency from the cabal
04:41:14 <matthew-_> for 6.6
04:49:32 <hpaste>  Marc Weber pasted "haskelldb ghc 6.6 comilation error" at http://hpaste.org/489
04:58:20 <MarcWebe1> Is this a common error on ghc 6.6 ?
04:58:46 <Lemmih> I think you need -fallow-incoherent-instances
04:59:03 * dcoutts_ agrees
04:59:03 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
04:59:41 <MarcWebe1> Lemmih: But this flag did exist in ghc-6.5 as well, didn't it? I'll try adding it.
05:02:22 <hpaste>  Marc Weber annotated "haskelldb ghc 6.6 comilation error" with "compliation still fails" at http://hpaste.org/489#a1
05:03:31 <Saizan> you can try to add that flag with the {-# OPTIONS ... #-} pragma directly in that file
05:03:59 <MarcWebe1> Saizan: But doesn't it suffice this way? Lets try
05:04:04 <Lemmih> MarcWebe1: Weird. I have haskelldb installed with ghc6.6
05:05:13 <Lemmih> MarcWebe1: You're not using Cabal?
05:06:02 <MarcWebe1> There is no setup.hs file.
05:06:36 <Lemmih> Where did you download haskelldb?
05:06:51 <MarcWebe1> I downloaded from here http://sourceforge.net/project/downloading.php?group_id=101095&use_mirror=ovh&filename=haskelldb-0.9.tar.gz&19457021
05:06:53 <lambdabot> Title: SourceForge.net: Downloading ..., http://tinyurl.com/2c5885
05:07:24 <Lemmih> MarcWebe1: Get it from the darcs repo. It should work with ghc6.6
05:07:42 <edwinb> matthew-_: mmm, good point...
05:08:50 <givi> I have to compute a[i]=max(i,a[i div 2]+a[i div 3]+a[i div 4]), but can't figure out how to force Huskell computing first million of velues only once and remember them for further use. Can you help with this?
05:09:00 <MarcWebe1> haskell.org -> libraries -> database support -> wiki -> chalmers  There is no link to darcs repo. I'll get it from darcs.haskell.org
05:11:41 <quicksilver> givi: put them in an array
05:11:43 <Lemmih> givi: What's a[0]?
05:11:49 <quicksilver> givi: that will have the effect of computing them only once
05:12:09 <givi> I mean that values a[1]..a[1000000] must be computed subsequently in O(n) and all others a[i] (for i from 1 to 100000000) computed recursively.
05:12:13 <givi> a[0]=0
05:12:23 <SamB> Lemmih: that looks to be something like C notation...
05:12:40 <SamB> in LaTeX it would be a_i
05:12:44 <matthew-_> surely you'll need the first 4 values specified manually given the `div`s there
05:13:17 <quicksilver> matthew-_: just the first one (zero) I think
05:13:21 <givi> quicksilver: so how can I dynamically fill this array?
05:13:31 <givi> (I'm a total newbie)
05:13:48 <givi> (got Lost in Huskell)
05:13:53 <quicksilver> if you just define the array using that formula, it should fill itself lazily, I believe
05:14:04 <quicksilver> arrays are strict in indices but lazy in values, right?
05:14:09 <SamB> givi: you could just make the array normally and fold over it to force the values
05:14:21 <quicksilver> SamB: I don't think he needs to force the values
05:14:30 <quicksilver> SamB: he just needs the values to be calculated at most once
05:14:38 <givi> yes
05:14:46 <givi> at most once
05:14:52 <quicksilver> @doc Data.Array
05:14:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
05:14:52 <SamB> quicksilver: it could be bad if he tried to read the last value in the array without forcing them in order...
05:15:32 <matthew-_> quicksilver: ahh yes, I was reading the div as flip'd
05:15:55 <quicksilver> SamB: *shrug* yes but let's give the man the simple answer before the complex one
05:16:01 <SamB> oh
05:16:14 <SamB> and then we tell him that *after* he blows his stack?
05:16:32 <givi> )))
05:18:00 <givi> I just need a tool for forcing Huskell compute something only once
05:18:16 <givi> and there's the example
05:19:07 <quicksilver> givi: I'm just building an example for you, one moment
05:19:13 <givi> So what I can't figure out is how to perform it with Array
05:20:42 <quicksilver> > let a = Data.Array.array (0,1000) ((0,0):[(i,max4 i (a!(i `div` 2)) (a!(i `div` 3)) (a!(i `div` 4)))| i <- [1..1000]]) where max4 a b c d  = foldr max 0 [a,b,c,d]
05:20:42 <lambdabot>  Parse error
05:20:58 <quicksilver> > let a = array (0,1000) ((0,0):[(i,max4 i (a!(i `div` 2)) (a!(i `div` 3)) (a!(i `div` 4)))| i <- [1..1000]]) where max4 a b c d  = foldr max 0 [a,b,c,d]
05:20:59 <lambdabot>  Parse error
05:21:06 <quicksilver> well that works in ghci
05:21:21 <quicksilver> I think I've forgotten how to do a 'let' in lambdabot
05:21:41 <quicksilver> givi: try that and play with it
05:24:38 <givi> quicksilver: thank you! :)
05:25:08 <quicksilver> givi: the thing in the [] is a list comprehension. If you don't know what they are you should also play with that, independently, for a minute or two
05:25:34 <quicksilver> > [(a,a*4) | a <- [1,5,8]]
05:25:35 <lambdabot>  [(1,4),(5,20),(8,32)]
05:26:03 <pjd_> givi: you can read the | as "for" and the <- as "in"
05:27:43 <givi> I know that. I was just looking for an example of constructing arrays the way I need
05:28:50 <matthew-_> pjd_: does that suggest that <- was chosen because if you squint it could look like ∈ ?
05:28:57 <Cale> *Main> a 100000000000
05:28:57 <Cale> 638767281911
05:29:30 <Cale> I'll give you my program. :)
05:29:37 <Cale> !paste
05:29:37 <hpaste> Haskell paste bin: http://hpaste.org/
05:30:07 <pjd_> matthew-_: oh, that's a nifty pun.  didn't notice it before
05:30:58 <hpaste>  Cale pasted "array memoisation" at http://hpaste.org/490
05:31:02 <matthew-_> pjd_: neither had I - I always read it as "generated by" but your suggestion of "in" makes sense
05:31:39 <hpaste>  Marc Weber pasted "givi, does this solve your problem ?" at http://hpaste.org/491
05:31:40 <pjd_> matthew-_: well, that's how Python translated it when they stole the syntax :)
05:32:28 <SamB> also, thats how you read set comprehensions
05:32:41 <pjd_> yeah
05:32:42 <matthew-_> yeah, true.
05:32:57 <SamB> and of course in those they do use ∈
05:32:58 * dcoutts_ implements the pure function: gcc :: [String] -> Lazy.ByteString -> Maybe String
05:32:59 <Cale> am and a are roughly equivalent in my code, I just wanted to separate the bit which decides whether to read from the memo table from the rest.
05:33:06 <matthew-_> or isElemOf or isIn
05:33:07 <SamB> dcoutts: as if
05:33:16 <Cale> You can compact that a bit if you try at it.
05:33:23 <dcoutts_> SamB, gcc is a pure function!
05:33:43 <SamB> I'll believe it when I find no unsafePerformIOs in its code
05:33:51 <dcoutts_> SamB, from input to status message
05:34:02 <givi> hpaste: yes, it does solve it. But not efficient enough
05:34:10 <dcoutts_> SamB, just because it uses unsafePerfomIO doesn't mean it isn't pure.
05:34:11 <Cale> hm?
05:34:17 <SamB> well, okay, but does it at least use ST?
05:34:39 <dcoutts_> SamB, no it has to execute gcc in a tmp file and catch the output
05:34:44 <dcoutts_> in/on
05:34:45 <givi> hpaste: I have to compute a[1e9] in less then 10 sec
05:34:49 <Cale> givi: It's only slow the first time
05:34:58 * SamB was talking about the compiler itself ;-P
05:35:14 <dcoutts_> SamB, it's only side effect is creating a temporary file and that's no more serious that memory usage as a side effect
05:35:22 <matthew-_> givi: hpaste is a bot that just announces posts to hpaste.org
05:35:39 <givi> )))
05:35:52 <Cale> cale@zaphod:~$ time ./arr
05:35:52 <Cale> 4243218150
05:35:52 <Cale> real    0m2.738s
05:35:52 <Cale> user    0m2.352s
05:35:52 <Cale> sys     0m0.116s
05:36:10 <Cale> Seems efficient enough to me :)
05:36:33 <givi> hmmmm...
05:36:42 <Cale> I compiled with -O2 though
05:36:43 * matthew-_ wonders about compile flags, strictness modifiers and sacrificial goats
05:36:49 <Cale> Let's try it without optimisations
05:37:04 <quicksilver> Cale: which value are you calculating in 3 seconds? 1e9?
05:37:08 <Cale> yes
05:37:11 <quicksilver> nice
05:37:16 <Cale> cale@zaphod:~$ time ./arr
05:37:16 <Cale> 4243218150
05:37:16 <Cale> real    0m8.719s
05:37:16 <Cale> user    0m6.536s
05:37:16 <Cale> sys     0m0.168s
05:37:22 <Cale> that's with no optimisation
05:37:27 <Cale> (well, the default ones)
05:37:35 <Cale> main = print (a (10^9))
05:37:41 <quicksilver> memoising all 1e9? or just memoising an initial fragment?
05:37:48 <Cale> memoising the first 10^6
05:37:51 * quicksilver nods
05:37:53 <quicksilver> nice!
05:38:18 <Cale> (and only those really needed, moreover :)
05:39:48 <givi> oh! I was talking about 491 - the program almost same as I wrote - it's slow
05:39:58 <Cale> ah
05:40:02 <Cale> http://hpaste.org/490
05:40:07 <givi> 490 - very nice! :))
05:40:47 <quicksilver> unoptimised on my machine it takes 49 seconds :)
05:41:11 <Cale> I'm on a 2.4 GHz P4.
05:41:29 <quicksilver> 1GHz G4 :(
05:41:39 <quicksilver> also, ghc 6.4
05:41:40 <givi> G4?
05:41:47 <Cale> givi: PowerPC
05:41:48 <quicksilver> givi: it's a powerPC chip
05:41:55 <SamB> Generation 4 PowerPC
05:42:06 <quicksilver> Cale: which optimisation flags did you give it?
05:42:07 <Cale> I wrote a pipeline scheduler for the G4.
05:42:10 <Cale> quicksilver: -O2
05:42:14 <givi> PowerPC = Apple? :-$
05:42:18 <Cale> yeah
05:42:22 <benja_> dcoutts_: there's apparently a bug with my patch :-(
05:42:23 <SamB> givi: not precisely
05:42:27 <MarcWebe1> Do you have any idea where Main.in should come from? I'm trying to run make test from HList.
05:42:28 <SamB> other things use it too
05:42:30 <benja_> we're working on it
05:42:32 <dcoutts_> benja_, oh?
05:42:39 <Cale> well, Motorola.
05:42:46 <benja_> didn't change 'index' correctly
05:42:48 <quicksilver> givi: and, all the currently macintosh lines use Intel chips
05:42:56 <quicksilver> this is an old laptop
05:43:01 <benja_> should I send an amended patch when we get it to work?
05:43:13 <SamB> but, before that they used PowerPC for everything since...
05:43:25 <SamB> oh, OS 7 or 8 was it?
05:43:30 <Slarba_> voi hevon vittu
05:43:31 <SamB> maybe 9...
05:43:33 <Slarba_> oh SORRY
05:43:36 <Slarba_> wrong channel :D
05:44:06 <Slarba_> I hope no finns are watching :D
05:44:14 <matthew-_> givi: actually, all the current gen games consoles have cpus which are in same way PPC derived
05:44:25 <dcoutts_> benja_, yes
05:44:30 <benja_> Slarba_: no dice :)
05:44:30 <givi> I love Motorola - my cellphone is Moto ;) And I used to be a great fan of Apple before it was bought by Microsoft...
05:44:35 <Cale> Slarba_: watch out, there are quite a few in this channel :)
05:44:43 <quicksilver> and IBM use PPC-based chips on a variety of their high end stuff
05:44:49 * benja_ isn't finnish but tuukkah is looking over my shoulder
05:44:54 <quicksilver> givi: bought by microsoft in what sense?
05:44:58 <benja_> dcoutts_: ok
05:45:01 <matthew-_> givi: plus PASemi and one or two other companies create PPC based chips
05:45:08 <benja_> pointer manipulation, not my forte, sorry =)
05:45:16 <Slarba_> heh :)
05:46:28 <givi> bought = Apple is owned by Microsoft nowadays to my concern...
05:47:05 <matthew-_> odd opinion. Apple and Microsoft don't exactly cooperate on much.
05:47:11 <givi> But being a fan of Apple in Ukraine is never see Apple :) but still be a fan
05:47:12 <Cale> By the way, this is one place where you absolutely do not want an unboxed array :)
05:47:47 <givi> unboxed array?
05:48:03 <quicksilver> givi: strange opinion. Apple is not owned by microsoft. Indeed in the UK and US at least they are running a high profile anti microsoft ad campaign.
05:48:09 <Cale> Yeah, Data.Array gives you an array of pointers to things which might be code or data, essentially.
05:48:15 <benja_> how can I convert a number to a hex string, anyone know?
05:48:29 <givi> so Motorola still makes their processors?
05:48:32 <SamB> @hoogle showHex
05:48:32 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
05:48:32 <Cale> Data.Array.Unboxed has a UArray type which gives you an "ordinary" array of memory.
05:48:38 <benja_> thanks
05:48:48 <SamB> > showHex 24 ""
05:48:49 <lambdabot>  "18"
05:48:51 <Cale> With no support for laziness.
05:48:53 <SamB> or...
05:49:00 <Cale> (but it's very compact by comparison)
05:49:04 <SamB> > printf "%x" (24 :: Int)
05:49:05 <lambdabot>  Add a type signature
05:49:07 <SamB> hmm.
05:49:11 <SamB> > printf "%x" (24 :: Int) :: String
05:49:12 <lambdabot>  "18"
05:49:19 <quicksilver> givi: at the moment, apple are buying all their processors for new models from Intel.
05:49:21 <Cale> The laziness of computing the array elements is essential to the way that I've defined things.
05:49:25 * dcoutts_ doesn't believe in printf
05:49:33 <Cale> The elements are defined in terms of one another.
05:49:47 <Cale> which is something you can't do with a UArray
05:49:50 <givi> I see it
05:50:00 <Cale> dcoutts: I don't either.
05:50:21 <givi> dcoutts_: )))
05:51:37 <givi> Cale: thanks for the detailed explanation!
05:51:44 <Cale> givi: no problem :)
05:51:49 <mauke> I'm starting to like monad transformers
05:52:00 <Cale> :)
05:52:21 <Slarba_> I hate that lifting stuff
05:52:25 <Cale> It takes a little time to warm up to them.
05:52:26 <Slarba_> with monad transformers
05:52:35 <hpaste>  Marc Weber annotated "givi, does this solve your problem ?" with "comparison array vs list list seems faster ? @givi" at http://hpaste.org/491#a1
05:52:55 <Cale> Slarba_: you should read my article. The idea is to do all the lifting you're going to have to do right away, and then write the majority of your program with no lifts.
05:53:09 <hpaste>  mauke pasted "monad transformer example" at http://hpaste.org/492
05:53:16 <Slarba_> Cale: ok
05:53:56 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
05:54:01 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
05:54:09 <mauke> I started with a parser for a simple language, then extended the 'number' part to keep track of how many times it's called
05:54:29 <mauke> three simple changes; the rest works as before
05:57:49 <malebria> Hello there.
05:58:14 <malebria> Is it possible to use haddocks #prune to show only the documenteds methods of a class?
06:07:14 <benja_> dcoutts_: sent amended patch
06:07:46 <benja_> basically the weird casting done by 'index' wasn't needed any more and was now actually harmful
06:08:01 <benja_> we checked and we do get the values that are in the Gtk theme file, now =)
06:08:07 <dcoutts_> benja_, great
06:12:40 <hpaste>  Andriy Makukha annotated "givi, does this solve your problem ?" with "f works faster :)" at http://hpaste.org/491#a2
06:12:49 <mightybyte> dcoutts_: When is the latest GHC going to be added to portage?
06:13:37 <dcoutts_> mightybyte, we're testing a new system of deps now, if you want to help joing #gentoo-haskell
06:13:59 <mightybyte> dcoutts_: Ok, thanks
06:14:34 <dcoutts_> mightybyte, it's in our haskell overlay right now if you want to try it
06:15:29 <givi> what is hpaste.org anyway?
06:16:16 <Cale> It's a haskell program which allows people to paste code, and optionally send #haskell notifications about it.
06:16:40 <bringert> MarcWebe1, how did you haskelldb problem work out?
06:17:45 <MarcWebe1> Had to talk to my sister. Is compiling currently.
06:17:59 <MarcWebe1> Did compile
06:19:14 <bringert> MarcWebe1, your sister fixed it then?
06:19:51 <MarcWebe1> No. Lemmihs advice to use darcs version ;)
06:21:33 <givi> "At the 1997 Macworld Expo, Steve Jobs announced that Apple would be entering into partnership with Microsoft. Settlement discussions regarding Apple's "Look and Feel" lawsuit and the "QuickTime piracy" lawsuit resulted in a five-year commitment from Microsoft to release Microsoft Office for Macintosh as well a US$150 million investment in non-voting Apple stock. It was also announced that Internet Explorer would be shipped as the default browser on the Mac
06:21:57 <givi> Yes! I'm a fan of Apple Computers again!
06:22:19 <twb> Is lambdabot's daddy around?
06:23:10 <mux> @seen dons
06:23:10 <lambdabot> dons is in #haskell. I last heard dons speak 4h 15m 22s ago.
06:23:16 <MarcWebe1> bringert: But it would be cool to have sister coding in haskell ;)
06:23:33 <givi> Apple WAS NOT bought by Microsoft FULLY
06:23:44 <givi> :-))))
06:24:14 <twb> dons: observe: http://twb.ath.cx/~twb/canon/profile
06:24:17 <lambdabot> Title: Index of /~twb/canon/profile/
06:24:18 <twb> Hmm.
06:24:38 <twb> dons: IMO, lambdabot shouldn't bother printing the title when the title is so trivial.
06:25:07 <hpaste>  int-e annotated "array memoisation" with "faster without memoization" at http://hpaste.org/490#a1
06:30:45 <MarcWebe1> On which ghc versions does HList work?
06:31:11 <MarcWebe1> I'v tried 6.5 and 6.6 but there is Main.in missing. Where does it come from?
06:31:14 <quicksilver> givi: $150 is a fairly small proportion of Apple. That was a long time ago. IE is no longer supported on that mac.
06:31:47 <givi> for real?
06:31:48 <Cale> int-e: well done :)
06:33:03 <Cale> int-e: No fair putting actual thought into it though ;)
06:33:06 <MarcWebe1> givi: You can find more information about hpaste by browsing haskell.org ... ;)
06:33:09 <int-e> Cale: hehe
06:34:27 <givi> int-e: (y) - genious :))
06:34:30 <int-e> Cale: but now with that code you can find crazy values like a[10^100] :)
06:38:02 <givi> but I don't get it yet... :(
06:40:24 <givi> actualy, the problem I wrote here is from https://www.spoj.pl/problems/COINS/
06:42:39 <givi> so now everybody can submit it on the server to raise Huskell's rating on https://www.spoj.pl/ranks/languages/
06:43:04 <givi> (a page that's not functional at the moment)
06:44:25 <quicksilver> Cale: you about?
06:44:35 <Cale> yeah?
06:44:50 <quicksilver> Is there a haskell proposal for subtyping algebraic types?
06:44:56 <quicksilver> (I don't know if I've got the terminology right)
06:45:13 <quicksilver> statically checking the fact that certain functions only ever return certain constructors
06:45:18 <Cale> No, I don't think so.
06:45:31 <ndm> @seen kosmikus
06:45:32 <lambdabot> kosmikus is in #darcs, #ghc, #gentoo-haskell and #haskell. I last heard kosmikus speak 2h 59m 21s ago.
06:45:39 <quicksilver> I hit that one all the time in evaluator-type programs
06:45:44 <Cale> Though ndm would be the one to talk with about that :)
06:45:49 <quicksilver> where, e.g. evaluate : Value -> Value
06:45:59 <quicksilver> but you can guarantee certain constructors are absent on the RHS
06:46:01 <int-e> givi: oh, another thing that I used: (a `div` b) `div` c == (a `div` c) `div b (because both are equal to a `div` (b*c))
06:46:08 <ndm> Cale: whats the question?
06:46:26 <quicksilver> ndm: statically checking (inferring?) subtyping over algebraic types
06:46:28 <Cale> ndm: <quicksilver> statically checking the fact that certain functions only ever return certain constructors
06:46:38 <int-e> givi: this is what allows combining all the paths with the same number of divisions by 2, 3 and 4, because they lead to the same leaf node in the tree.
06:47:47 <ndm> Cale, quicksilver - i'm currently writing a paper on that very topic
06:47:53 <ndm> with infering
06:47:57 <quicksilver> ndm: excellent
06:48:15 <quicksilver> ndm: I hit it all the time in work which transforms complex ASTs
06:48:25 <Cale> ndm: Yeah, that's why I said you'd be the one to talk to :)
06:48:32 <quicksilver> ndm: f : AST -> ASTButWithAllFoobarsCollapsed
06:49:31 <Cale> The general case is sort of impossible, but there's probably lots of middle ground there.
06:49:47 <Cale> Where by "sort of", I mean "completely"
06:49:51 <ndm> quicksilver: it is pretty hard, but if you read my earlier paper on Catch you'll see how it can be done, slightly
06:49:55 <quicksilver> yes, indeed
06:50:04 <ndm> quicksilver: if you read the paper i'm still writing, you'll see how to do it for all programs :)
06:50:18 <quicksilver> in practice you would hope to be able to separate by input constructor too
06:50:34 <Cale> Can I write my collatz tester and then check that it only produces True? :)
06:50:35 <ndm> yep, it does all that
06:50:46 <quicksilver> e.g. f : [] -> []; f : (:) -> (:)
06:50:49 <ndm> Cale: yes, you can, and you'll be told "can't prove"
06:50:54 <Cale> ah :)
06:50:54 <ndm> quicksilver: yep, it does exactly that
06:51:22 <quicksilver> ndm: hard to read it while you're still writing it unless I head up to york and look over your shoulder, though
06:51:45 <ndm> quicksilver: to take a concrete example, it can infer head (True|False:anything) -> True|False, head (True:anything) -> True, head (False:anything) -> False, head [] -> _|_
06:52:04 <ndm> quicksilver: indeed, if you have an email i can send you a preview copy in a few days
06:52:34 <ndm> quicksilver: i've done most of it, and hope to have most of the technical content written up in the next few days
06:52:44 <quicksilver> ndm: thank you, I'd be very interested. jules@jellybean.co.uk
06:53:20 <ndm> quicksilver: what is your particular reason for wanting this analysis?
06:53:40 <quicksilver> ndm: it's been an annoyance of mine every time I've written a program in ML or haskell
06:53:59 <ndm> quicksilver: you can't give stronger types, but it can infer them and check pattern matches with them#
06:54:01 <quicksilver> ndm: the program which brought it back to the surface on this particular occasion is a simple interpreter
06:54:33 <quicksilver> While we're talking about clever stuff which may or may not be possible, do any of the parser combinator libraries have the ability to build an implicit deparser?
06:55:09 <quicksilver> ndm: so it produces a strong version of the 'incomplete pattern match' check that ML implementations typically have?
06:55:32 <ndm> quicksilver: i'm writing a parser library which does such a thing, on the back burner
06:55:40 <ndm> quicksilver: yes, it produces a complete proof
06:55:44 <Cale> quicksilver: that's perhaps possible with arrow-based libraries.
06:56:06 <ndm> quicksilver: if it says so, it can guarantee you have no pattern match errors
06:56:13 <Cale> Monadic parsers probably won't be.
06:56:21 <Cale> (In general)
06:56:27 <quicksilver> ndm: are you in fact the complete solution to all interesting programming problems? :P
06:56:29 <kosmikus> ndm: I'm here.
06:57:26 <ndm> kosmikus: i've got lhs2tex working fine now, with the tweaks to those 2 files i mentioned in the email
06:57:49 <ndm> kosmikus: i'm now trying to figure out how to increase the blank line spacing and to reduce the indent of code blocks in polytable
06:57:57 <ndm> kosmikus: any subst/format's that help either of those two?
06:58:02 <cjeris> anybody know a good reference (textbook or expository article) for use of A-normal form in compilers?
06:58:14 <ndm> quicksilver: i'm trying ;)
06:58:29 <darrint> On monads: I'm familiar with python generators, and I recently noticed they required you to "take the function to the data," maybe like monads. Is my reasoning correct?
06:58:45 <ndm> @karma+ kosmikus -- for lhs2tex, very nice :)
06:58:45 <lambdabot> kosmikus's karma raised to 7.
06:59:31 <Cale> darrint: hmm, what do you mean by that?
06:59:58 <Cale> They certainly involve a more process-centric view of what would otherwise be data.
07:00:02 <quicksilver> darrint: I don't immediately see the connection, although a python generator is rather like a lazy list and you might very well put one into a reader monad or a variation
07:00:15 <kosmikus> ndm: yes, it's all configurable
07:00:30 <darrint> rats. :-)
07:00:37 <kosmikus> ndm: blank lines are given by \blanklineskip
07:01:20 <Cale> writer monad, more likely
07:01:39 <kosmikus> ndm: it defaults to 1mm; you can say \setlength\blanklineskip{\bigskipamount} or something similar
07:02:20 <kosmikus> ndm: the indentation of code blocks is given by \mathindent
07:02:49 <kosmikus> ndm: note that that's also used for the indentation of displayed math formulas if you use fleqn
07:04:05 <Cale> You can also use the continuation monad to get yield-like effects.
07:04:07 <kosmikus> ndm: btw, I've prepared http://www.iai.uni-bonn.de/~loeh/lhs2tex/lhs2tex-1.12.1.tar.bz2 ... it'd be great if you could verify that it fixes the problem with the line endings
07:04:11 <ndm> kosmikus: thanks, i'll have a play with those
07:05:11 <Cale> yield x = Cont (\c -> x : c ())
07:05:41 <quicksilver> Cale: that's *probably* a sledgehammer for a nut, though
07:05:46 <Cale> indeed
07:05:51 <pejo> Can one use pattern guards to match something, and then bind a bunch of variables? I'd like to do a lookup, and if that succeeds do a "ls <- ask".
07:05:51 <quicksilver> Cale: the generator examples I looked at were all lazy lists in content
07:05:55 <Cale> Writer does a much cleaner job of it
07:06:39 <Cale> well, yeah, lazy lists take care of most of what generators do
07:07:01 <quicksilver> yield is being used a 'stop evaluation here and keep the rest as a thunk'
07:07:05 <ndm> kosmikus: all works perfectly, thanks :) - i'll try that tarball later on
07:07:08 <quicksilver> well, not really. But the effect is rather similar.
07:08:24 <quicksilver> pejo: not sure I understand your question. Are you in a monad? If so, then yes, probably, if it's a monad that 'fail' works in the expected way
07:08:54 <pjd_> quicksilver: Python generators get used for other things too, though, like lightweight threading
07:09:31 <quicksilver> pjd_: 'threading'? surely not. It's just a slightly complex flow of control
07:09:35 <quicksilver> but still only one thread
07:09:50 <int-e> coroutines is the word I think
07:09:51 <pejo> quicksilver, I'm in a whole nest of monads, one we can call M, and then StateT and ReaderT.
07:09:51 <quicksilver> it's a producer/consumer flow control construct
07:10:00 <benja_> dcoutts_: hm, the mail with my amended patch doesn't seem to have reached the developers' list
07:10:10 <benja_> any idea what could have happened?
07:10:14 <kosmikus> ndm: are you using polycode.fmt ?
07:10:16 <quicksilver> pejo: if you just 'do' the pattern match
07:10:19 <dcoutts_> benja_, don't worry, axel is the moderator, he'll get it eventually
07:10:20 <ndm> kosmikus: yes
07:10:26 <kosmikus> ndm: ok
07:10:26 <pjd_> quicksilver: lightweight threading, not OS threading :)
07:10:28 <quicksilver> pejo: then if it fails, you will get "fail" in your monad
07:10:47 <pejo> quicksilver, basically I'd like to do "| Just b <- lookup n gf RET , ls <- ask = do ..
07:10:48 <quicksilver> pejo: exactly what that does depends on the definition of fail in M. It may not be what you want.
07:10:53 <benja_> ok, but I didn't get a moderation notification about the amended patch (I subscribed to the list in the meantime)
07:11:00 <benja_> I did get a notification about the first one...
07:11:27 <quicksilver> pejo: looks like the maybe monad, to me
07:12:02 <SamB> @hoogle ReadS a -> CharParser a
07:12:03 <lambdabot> No matches, try a more general search
07:12:05 <quicksilver> pejo: lookup n gf >>= .....
07:12:22 <SamB> @hoogle ReadS a -> CharParser st a
07:12:23 <lambdabot> Did you mean: ReadS a -> CharParser St a
07:12:26 <Cale> er, except there's that ask there :)
07:12:30 <SamB> @hoogle ReadS a -> CharParser () a
07:12:31 <lambdabot> No matches, try a more general search
07:12:37 <pjd_> quicksilver: in the sense of that "Unifying events and threads" Haskell paper
07:12:50 <quicksilver> Cale: yes, but his key question is about how to do something based on whether lookup succeed
07:12:50 <SamB> @hoogle readS
07:12:50 <lambdabot> Prelude.reads :: Read a => ReadS a
07:12:50 <lambdabot> Prelude.ReadS :: type ReadS a
07:12:50 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
07:12:59 <quicksilver> Cale: the fact that that something happens to be ask isn't the point
07:13:02 <Cale> there's case :)
07:13:13 <pejo> quicksilver, well, wont the entire pattern guard fail if the lookup fails, and the next pattern be tried?
07:13:18 <quicksilver> but the maybe monad encapsulate 'do something if lookup succeeds'
07:13:23 <Cale> pejo: yes
07:13:31 <quicksilver> pejo: I'm not sure you want a guard, here
07:13:36 <quicksilver> (but there's more than one way...)
07:13:47 <Cale> Pattern guards were meant for this sort of thing
07:13:53 <pejo> quicksilver, anything that doesn't make me run out of 80 columns is fine.
07:13:55 <Cale> but they're not all that commonly used
07:14:08 <quicksilver> pejo: i need to see more of your code to answer.
07:14:19 <quicksilver> (and Cale will produce a better answer even if I do :P )
07:15:32 <pejo> quicksilver, I can paste away, but not sure what parts you need. It's rather long as it is right now. (And not very functional).
07:16:16 <pejo> !paste
07:16:16 <hpaste> Haskell paste bin: http://hpaste.org/
07:17:14 <paolino> hi, my program is leaking space like hell. I suppose it's for I'm using updatable structures everywhere, I need a lesson :) . How can I be sure all the elements of a list are evaluated before I return it from a function ?
07:18:29 <Cale> foldr seq () ...
07:18:51 <Cale> that'll ensure that if any elements of the list are needed, all of them will be computed
07:19:17 <hpaste>  pejo pasted "Failed pattern guard attempt" at http://hpaste.org/493
07:19:22 <Cale> But have you run the profiler? :)
07:19:56 <quicksilver> pejo: why not just case?
07:19:58 <paolino> how it is  useful for space leaks ?
07:20:22 <quicksilver> case lookup n gfuncs of Just body -> .... ; Nothing -> error "bleh"
07:20:35 <Cale> pejo: the ls <- lift ask probably doesn't mean what you think it does
07:20:42 <pejo> quicksilver, I end up very far out to the right.
07:20:45 <pejo> Cale, no, it doesn't.
07:20:57 <Cale> the Just body <- lookup n gfuncs is fine, that's not the problem
07:21:34 <Cale> Since no pattern matchng is done on ls, it looks like perhaps you meant that to go into the do-block?
07:22:02 <paolino> Cale, does it help me finding out how the memory is used by types ?
07:22:27 <pejo> Cale, I'd actually like to have another ", pattern <- func ls (ctxt l).
07:22:48 <pejo> Cale, I'm aware that the ask can't fail though.
07:23:02 <Cale> paolino: yes -- the basic profile will tell you the places where most of the allocation is taking place, and there's also a heap profiler which can generate pretty graphs of how much memory different cost centres are using over time
07:23:18 <paolino> wow
07:23:55 <paolino> do I need to correct the cabal file to have it ?
07:24:55 <Cale> Well, you want to pass -prof -auto-all to GHC on the commandline
07:25:13 <Cale> I don't know the cabal for that, but there's probably an option to specify GHC parameters :)
07:25:35 <paolino> yes there is
07:26:07 <quicksilver> pejo: case lookup n gfuncs of Just body -> do { ls <- lift ask ; ... ; ... } | Nothing -> error "bleh" ?
07:26:09 <Cale> and then when you run your program, you run it with  +RTS -p -hc -RTS
07:26:38 <Cale> which will cause it to generate foo.prof and foo.hp
07:27:17 <Cale> the .prof is a report of time and raw allocation, the .hp is a report of what's using the heap at what time
07:27:42 <Cale> hp2ps will turn the .hp file into a nice graph
07:27:48 <pejo> quicksilver, case lookup n gfuncs of Just body -> do { ls <- ask; case lookup l ls of Just (_, n) -> ... ; Nothing -> ... }, and it goes on.
07:28:05 <quicksilver> pejo: ok, then you want the maybe monad
07:28:07 <ndm> kosmikus: seems like the problem is now fixed, thanks :)
07:28:21 <ndm> kosmikus: in the tarball you just posted
07:28:32 <kosmikus> ndm: great
07:28:38 <pejo> quicksilver, pattern guards is the wrong solution for my problem?
07:28:52 <Cale> Er, it looks like what he actually needs is a MaybeT transformed Reader monad.
07:28:57 <ndm> kosmikus: and btw, a zip would be easier for most windows users - there is no default .bz2 extraction tool or .tar tool on windows
07:28:57 <quicksilver> pejo: I'm not sure. Cale would know better. But the maybe monad is absolutely for that case
07:29:10 <Cale> but that's awkward, because there is no MaybeT in the libraries.
07:29:12 <quicksilver> pejo: the maybe monad is all about computations which all produce Just x or Nothing
07:29:16 <ndm> kosmikus: makes no difference to me though, since i have tools for both
07:29:25 <kosmikus> ndm: yes, can do
07:29:29 <quicksilver> pejo: and you 'keep going' when you get Just and 'abort' when you get Nothing
07:29:31 <Cale> what do the Nothing cases look like?
07:29:39 <Cale> Do they just propagate the Nothing?
07:29:41 <quicksilver> Cale: error "blah" I think
07:30:32 <Cale> The slightly tricky bit of this is that we're already using one monad. :)
07:30:56 <pejo> Cale, no, it updates some things and call drive recursively.
07:31:13 <Cale> ah, okay, then use case, I don't know if there's a better option than that.
07:31:34 <Cale> Does the code look somehow repetitive?
07:32:25 <pejo> Bummer. " | Just body <- lookup n gfuncs, ls <- ask, (_, n) <- lookup l ls  = would have been sweet.
07:33:00 <Cale> ah, I see what you wanted, yeah, that's not quite possible :)
07:33:26 <Cale> In your case, it looks like you're using Reader or something, which is a pretty safe monad to do that with.
07:33:42 <Cale> But if it worked in general, you could do IO in guards, which wouldn't be too good :)
07:33:49 <pejo> Cale, yeah, and StateT, and "M".
07:34:23 <quicksilver> can't you handle the monad layering by hand
07:34:31 <quicksilver> in this simple case
07:34:49 <Cale> quicksilver: It's just a notational issue.
07:34:57 <quicksilver> something like do { body <- lookup n gfuncs; (_,n) <- (ask >>= lookup l) }
07:35:19 <Cale> quicksilver: case will work just fine, and the Maybe monad is actually inappropriate, because he's doing something nontrivial with the Nothing case.
07:35:31 <quicksilver> ah was he? sorry. I missed that bit.
07:35:47 <Cale> Yeah, I just figured that out a minute ago :)
07:35:49 <quicksilver> :t maybe
07:35:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:35:59 * quicksilver slaps lambdabot 
07:36:15 <Cale> It's just that he wanted to stretch the pattern guard syntax a little farther than is allowed at the moment :)
07:36:19 <quicksilver> sometimes using chains of 'maybe' is prettier than nesting cases
07:36:34 <quicksilver> (all in the eye of the beholder etc etc)
07:36:48 <paolino> Cale , I think I can't get a clear information reading the profilings.
07:37:03 <Cale> paolino: can you hpaste them?
07:37:19 <paolino> !paste
07:37:20 <hpaste> Haskell paste bin: http://hpaste.org/
07:37:33 <Cale> paolino: there's a way in which we can add more cost centres to refine the locations it's giving you
07:38:18 <pejo> Cale, the "| Just body <- lookup n gfuncs, (_, n) <- (ask >>= \ls -> ..) " approach quicksilver suggested isn't possible either?
07:38:55 <Cale> pejo: no, because (ask >>= ...) is not going to be a pair
07:39:06 <Cale> It'll be in some monad.
07:39:13 <pejo> Duh.
07:39:44 <pejo> But nested case is the best I can do, basically?
07:39:47 <paolino> it will trucate them
07:40:04 <SamB> hmm, what is the easiest way to get a UArray from a file?
07:40:15 <Cale> paolino: ah
07:40:26 <Cale> paolino: just the .prof?
07:41:08 <SamB> a UArray i Word8, that is.
07:42:03 <Cale> that's interesting, there doesn't appear to be an instance of Read?
07:42:16 <SamB> oh, I wanted it to have the bytes from the file in it ;-)
07:42:17 <Saizan> SamB there's a Binary instance for UArrays
07:42:29 <Cale> ah
07:42:46 <SamB> or, specifically, *some* of the bytes from the file.
07:42:47 <Cale> yeah, probably the Binary library is your best bet
07:42:51 <pejo> (Or ditch the Reader monad, and pass the stuff along manually, I assume?
07:43:03 <Cale> pejo: yeah
07:43:24 <Saizan> well you can write your own quite easily for custom behaviour
07:43:31 <paolino> http://catenova.org/~paolino/hancl/net.ex1.prof
07:43:32 <paolino> http://catenova.org/~paolino/hancl/net.ex1.hp
07:43:34 <SamB> oh, it looks like Data.ByteString does what I want anyway...
07:44:40 <Cale> paolino: oh, that's interesting. The .hp file looks truncated
07:45:08 <paolino> retry ..
07:45:12 <SamB> I don't actually need to use the array interface
07:45:36 <paolino> now it finished scping
07:45:57 <paolino> I have 1 kbyte upload
07:45:59 <paolino> :)
07:47:46 <araujo> morning
07:50:21 <Cale> okay, lots of memory usage across the board there
07:50:48 <Cale> I wish it would keep longer labels, maybe there's an option for that
07:50:57 <Cale> evolveS/evolve/testM... seems to be the largest chunk
07:51:24 <paolino> it in Net/Net.hs
07:52:45 <pejo> Cale/quicksilver, thanks. Ditched the reader monad, it got a bit better.
07:56:25 <Cale> okay, evolveS on its own, not counting its children accounts for 36% of the allocation done by your program
07:57:00 <chessguy> hi paolino
07:57:12 <Cale> er, or 39, depending on what you trust. Also the heap profiler picks it out as having lots of active stuff on the heap, so let's look at what it's doing.
07:57:32 <paolino> hi chessguy
07:57:44 <paolino> depending on what you trust ??
07:57:55 <chessguy> paolino, how is your project going?
07:58:05 <paolino> leaking memory
07:58:13 <paolino> badly
07:58:35 <Daveman> chessguy :)
07:58:35 <chessguy> hmm. i didn't think haskell programs could leak memory
07:58:48 <Daveman> everything can leak, if you try hard enough ;)
07:58:49 <chessguy> Daveman !
07:58:55 <Daveman> or the garbagemen go on strike :p
07:59:50 <paolino> or Paolino has no knowledge on how to write a good haskell program
08:01:30 <paolino> also I should say using in place of leaking
08:03:03 <Cale> paolino: ah, it's just that evolveS is called from more than one place in your program, so the total across those is 39%, but the biggest instance is 36%
08:04:09 <paolino> mmhh, there is a ghost using it then
08:04:14 <Cale> that's a great big do-block, so maybe the best idea would be to insert cost centres before each line, and see if we can figure out which parts are causing the most trouble
08:04:54 <Cale> {-# SCC "name" #-}  before an expression will add a cost centre with name "name"
08:05:31 <Cale> you can either be descriptive or just use a, b, c, d,..
08:05:59 <Cale> they'd go just to the right of the <- 's
08:06:11 <paolino> ah
08:06:18 <Cale> or at the start of the line if it's just an action
08:07:45 <paolino> ok
08:13:46 <paolino> uhm now I have type errors
08:15:40 <malebria> @hoogle FilePath -> FilePath
08:15:41 <lambdabot> Distribution.Compat.FilePath.dropAbsolutePrefix :: FilePath -> FilePath
08:15:41 <lambdabot> Distribution.Compat.FilePath.changeFileExt :: FilePath -> String -> FilePath
08:15:41 <lambdabot> Distribution.Compat.FilePath.dropPrefix :: FilePath -> FilePath -> FilePath
08:15:45 <paolino> Cale , I think I followed instruction,, please have a look at the corrections, ad it dosn't compile
08:16:44 <paolino> ok, found the bug
08:19:16 <malebria> Is there a function that returns the name of a file without the directory name?
08:19:31 <malebria> /home/marcot/test.hs -> test.hs
08:20:14 <malebria> I'm using: reverse $ takeWhile (/= '/') $ reverse x, but it does not seem to be general enough and it's not very efficient.
08:20:28 <allbery_b> @where filepath
08:20:28 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
08:21:06 <allbery_b> rumor has it that's slated for base in the next release
08:21:42 <malebria> albthanks.
08:22:06 <malebria> allbery_b: thanks. =P
08:22:50 * shapr boings cheerfull
08:22:51 <shapr> y
08:22:54 <shapr> Good morning #haskell!
08:23:10 <ejt> hi
08:23:29 <dylan> good morning vietnam!
08:24:52 <ropine> good mornuuuuhhhh
08:25:16 <allbery_b> zzzzzzzzz. . .
08:25:54 <paolino> Cale I uploaded the new .prof
08:26:45 <chessguy> @get-shapr
08:26:45 <lambdabot> shapr!!
08:27:28 <shapr> YOW!
08:27:42 <shapr> chessguy: how's life?
08:27:59 <chessguy> hey, life is good. i get to be sick today
08:28:09 <glguy> > let remberLast x xs = flip runCont id . callCC $ \ out -> let aux y ys | y == x = out =<< ys | otherwise = fmap (y:) ys in foldr aux (return []) xs in remberLast '/' "/home/glguy/my.hs"
08:28:11 <lambdabot>  "my.hs"
08:28:25 * Nafai sighs
08:28:40 <chessguy> rember?
08:29:00 <glguy> "The Seasoned Schemer" naming convention
08:29:13 * dcoutts_ notes that c2hs parses C at roughly 10 kloc/s
08:29:19 <malebria> Is there a simple way to get the version from a Cabal file, something to parse it?
08:29:25 <malebria> Maybe using cabal libraries.
08:29:49 <chessguy> hm. i spent 4 weeks of 1 class studying scheme. guess that doesn't make me seasoned enough to get it
08:31:10 <Cale> paolino: oh, interesting, you're using foldl but not foldl'
08:31:25 <allbery_b> Distribution.Version?
08:31:40 <Cale> that doesn't look too bad though, by the profile
08:31:50 <allbery_b> @index parseVersion
08:31:50 <lambdabot> Data.Version, Distribution.Version, Distribution.Simple
08:32:26 <paolino> the Random Library is sucking energies !
08:32:55 <allbery_b> better'n sucking mud
08:33:14 <Lemmih> malebria: readPackageDescription, package and pkgVersion.
08:33:18 <Cale> It does look that way
08:33:31 <Cale> also, (Net s h g r q e w Int) looks like one hell of a monad :)
08:34:19 <paolino> Its an RWST (State StdGen)
08:34:23 <chessguy> @type (\xs -> 3)
08:34:26 <lambdabot> forall t t1. (Num t1) => t -> t1
08:34:40 <malebria> Lemmih: thansk a lot! =D
08:36:46 <paolino> Cale , using monads is a bad performance choice ?
08:37:07 <Cale> paolino: nah, I was just wondering
08:37:17 <Cale> It's not usually much of a problem
08:37:34 <Lemmih> malebria: And 'findPackageDesc'.
08:37:40 <Cale> You can end up carrying around more stuff than you need, but that's not so bad for space, anyway.
08:38:16 <Cale> unless maybe something is accumulating in that state and not getting forced
08:38:34 <malebria> Lemmih: hum...
08:38:38 <paolino> Can I ask the profiler what types are the most allocated ?
08:39:04 <paolino> Cale I'm pretty sure it's happening
08:39:22 <malebria> Lemmih: will pkgName allways be equal to the name of the file?
08:39:34 <Cale> yes
08:39:48 <Cale> -hy instead of hc
08:39:50 <Lemmih> malebria: No.
08:40:02 <Lemmih> malebria: The filename can be anything.
08:40:13 <Lemmih> (as long as it ends in .cabal)
08:40:48 <malebria> Lemmih: hum.. ok.
08:41:00 <Lemmih> malebria: You probably want something like this: fmap (pkgVersion.package) $ readPackageDescription =<< findPackageDesc "."
08:41:35 <paolino> One thing I know is , after each evolve, the state should be all evaluted, but I swear it isn't
08:42:03 <malebria> Lemmih: yes, that's what I want, but can I use defaultPackageDesc instead of findPackageDesc "."?
08:42:29 <malebria> @type liftM
08:42:30 <malebria> @type fmap
08:42:32 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:42:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:43:17 <Lemmih> malebria: Yes.
08:43:45 <paolino> Cale , there is a huge black fraction marked with "*"
08:44:19 <Cale> hmm
08:45:00 <Cale> maybe -hd ?
08:46:27 <paolino> there are also all other types , but that one is very big
08:47:14 <Cale> I'm not sure what that means
08:47:30 <Cale> maybe values with polymorphic type?
08:48:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html lists the options for heap profiling if you want to experiment
08:48:46 <lambdabot> Title: 5.4. Profiling memory usage, http://tinyurl.com/ycro5f
08:49:35 <Cale> This is a big application and I don't know how it all works, so it's hard for me to see what might be allocating memory which doesn't get thrown away.
08:50:03 <Cale> Retainer profiling might be an interesting thing to try.
08:51:19 <Slarba_> hm. what's wrong with my lambdabot... if I try to eval something with > 1+2 it says Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
08:51:49 <Cale> Slarba_: is RunPlugs compiled and installed?
08:52:07 <Slarba_> let's check
08:52:40 <Cale> er, runplugs
08:53:11 <paolino> Cale can I make \\ eager ?
08:53:44 <paolino> or a DiffArray strict ?
08:53:52 <Cale> paolino: well, it has to be strict in the second list.
08:54:25 <Cale> because before you can know what the first element of xs \\ ys is, you have to go through all of ys.
08:54:42 <Cale> Or are you talking about // ?
08:55:01 <Cale> You're using DiffArrays somewhere?
08:55:42 <Cale> ah, yes you are
08:56:22 <Cale> where is DA defined?
08:56:28 <paolino> Net.hs
08:56:38 <paolino> Lib.Matrix
08:57:16 <Cale> ah, there it is
08:57:27 <paolino> the state is made of 2 DiffArrays
08:57:49 <Cale> yeah
08:57:55 <Cale> how large are the arrays?
08:58:10 <chessguy> ?hoogle DiffArray
08:58:11 <lambdabot> Data.Array.Diff.DiffArray :: type DiffArray
08:58:11 <lambdabot> Data.Array.Diff.IOToDiffArray :: data IOToDiffArray a i e
08:58:11 <lambdabot> Data.Array.Diff.newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
08:58:18 <chessguy> ?source Data.Array.Diff
08:58:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/Diff.hs
08:58:33 <paolino> during ex1 300 pcs
08:58:40 <Cale> chessguy: the only useful thing in that library is the type, you use the IArray interface to work with them
08:58:56 <Cale> (just a heads up, because the haddock is confusing)
08:59:22 <paolino> and updated 5 to 10 times each evolveS
08:59:32 <paolino> but readed everywhere
08:59:57 <Cale> paolino: what happens to performance if you switch to ordinary arrays?
09:00:07 <paolino> Array ?
09:00:11 <Cale> yeah
09:00:15 <glguy> who started the -ista suffix? pythonista, for example?
09:00:31 <paolino> it's italian
09:00:33 <Cale> as a cheap hack, you could just edit the type decl in Lib.Matrix
09:00:36 * glguy hopes that person is in channel so that he can kick him
09:00:53 <Cale> glguy: hehe
09:00:55 <paolino> -ista is italian
09:01:05 <Cale> It was paolino! Get him!
09:01:06 <Cale> hehe
09:01:13 <paolino> (but I NEVER use it)
09:01:44 <glguy> I'll op hpaste and have hpaste kick the person! how's that for degrading
09:02:01 <chessguy> @slap hpaste
09:02:01 <lambdabot> why on earth would I slap hpaste
09:02:08 <glguy> @slap chessguy
09:02:08 * lambdabot beats up chessguy
09:02:14 * chessguy cries
09:02:35 <chessguy> @karma hpaste
09:02:36 <lambdabot> hpaste has a karma of 0
09:02:42 <glguy> hpaste++
09:02:51 <chessguy> @karma
09:02:51 <lambdabot> You have a karma of 3
09:02:52 <sjanssen> haskellista doesn't sound quite right
09:03:14 <chessguy> i've never even heard that suffix applied to languages
09:03:30 * allbery_b thought it made it into US English from various central and south american rebel groups' names
09:03:31 <sjanssen> I've only heard pythonista
09:03:34 <glguy> I saw "web standardista" on a blog comment just now
09:03:49 <glguy> I'd punch that person in the face, given the opportunity :-S
09:04:04 <chessguy> does foo-ista refer to a small version of foo?
09:04:16 <glguy> that's foo-chen
09:04:32 <glguy> (German)
09:04:40 <allbery_b> (and occasionally north american, e.g. Mexico's Zapatistas)
09:04:42 <chessguy> so what's foo-ista?
09:04:50 <Cale> A purveyor of foo?
09:04:50 <glguy> chessguy: a complete idiot
09:05:33 <chessguy> ok, i guess i'm not going to get a straight answer
09:05:51 <malebria> chessguy: I think it's a translation for the suffix ist.
09:06:04 <malebria> chessguy: zapatistas in english is zapatists.
09:06:08 <paolino> Cale it's much better
09:06:21 <paolino> memory grows logarithmically
09:06:21 <Cale> paolino: okay, then we know where the loss is :)
09:06:28 <chessguy> malebria, shoemakers?
09:06:52 <paolino> and it's faster
09:06:54 <paolino> mhh
09:07:00 <Cale> That can happen
09:07:02 <allbery_b> more like "boot-wielders" in that case
09:07:17 <Cale> The choice between DiffArray and Array is sometimes tricky.
09:07:39 <malebria> chessguy: in the zapatista case it's people who are influenced by Zapata.
09:07:58 <Cale> Your arrays have to be really large, and you need to be doing updates which are pretty small (i.e. not the whole array)
09:08:00 <malebria> Like Marxistas is Marxists.
09:08:04 <Slarba_> *lambdabot*      Failed to load interface for `ShowQ':
09:08:07 <chessguy> infulenced by a shoe?
09:08:09 <Slarba_> sigh
09:08:10 <Cale> (for DiffArray to pay off)
09:08:17 <chessguy> i'm really confused
09:08:27 <chessguy> oh, there's a person named Zapata?
09:08:27 <Slarba_> sauna ->
09:08:49 <paolino> in real problems anyway I'm going to have a very big array
09:08:54 <Cale> and really, you need to be throwing away all old copies of the array
09:09:17 <malebria> chessguy: yes...
09:09:21 <Cale> when you do the update, if anything is still holding on to a reference to the old version, then it'll also be holding on to a list of changes
09:09:26 <chessguy> ok, that makes more sense
09:09:30 <malebria> chessguy: an important person in Mexico history.
09:09:31 <Cale> which I suspect is what's happening in your program
09:09:52 <chessguy> ok. i barely know my own country's history, much less mexico's
09:10:42 <malebria> Is there a simple way to get the output of a program without input without using forkIO?
09:11:01 <Cale> paolino: but 300 pointers is not so bad to reconstruct :)
09:11:28 <Cale> malebria: you don't need forkIO, I don't think.
09:11:52 <Cale> You may have to close the input handle.
09:12:05 <malebria> Cale: I'm basing on dons typeOf code:
09:12:30 <sjanssen> malebria: you need to make sure that you read the stderr and stdout pipes
09:12:44 <Cale> Is there a reason to avoid forkIO ?
09:12:54 <sjanssen> if you don't read stderr, the program can block on writing it
09:13:02 <Cale> that's true
09:13:41 <sjanssen> malebria: I think that the typeof code is the simplest robust solution
09:14:42 <malebria> No reason to avoid it, I just wanted a simpler form.
09:14:45 <malebria> But that one is ok.
09:14:49 <Cale> The libraries need some really easy ways to do common things with regard to interfacing with other programs.
09:15:10 <malebria> system is a simple way.
09:15:15 <malebria> The problem is getting the output.
09:15:16 <Cale> System.Process is way better than what we had before
09:15:25 <Cale> which was basically nothing
09:15:41 <sjanssen> I suppose another way is to get at the filedescriptors inside the handles and use select
09:16:36 <malebria> hum..
09:16:37 <Cale> But it would be nice to have some combinators for constructing shell pipelines, specifically wanting to strip out stderr, or specify a String for input, and get Strings back for output, things like that.
09:17:17 <Cale> (I'm tired, that might have sounded jumbled)
09:18:35 <sjanssen> malebria: you could abstract the input grabbing code so you only have to write it once
09:19:13 <malebria> sjanssen: sure, but it would be good to have these abstractions in the libraries.
09:19:21 <Cale> Hmm, another cool thing would be to create a process, and use a String -> String function to talk to it, and get out a String transcript of everything.
09:19:47 <Cale> Like a version of interact which uses a process as the user.
09:20:19 <sjanssen> malebria: I agree 100%.  Once you write your nice abstraction, you should submit a patch to base :)
09:20:45 <sjanssen> or talk to dons about the process library he started writing
09:20:58 <Cale> I almost feel like doing it right now, only I haven't slept and my mind is getting cloudier by the minute :)
09:21:53 <malebria> sjanssen: I don't know much about these things, so I don't think I'll can add very much to the existing ways to do.
09:28:10 <glguy> *Cut a hole in a box*
09:28:16 <glguy> *Put your Lisp in that box*
09:30:45 <sjanssen> s/Lisp/thunk
09:30:56 <sjanssen> You make the RTS open that box
09:33:09 <glguy> Put your bottom in the box?
09:38:11 <fasta> Can you recommend a simple, but fast _pure_ matrix implementation?
09:38:22 <patrick22> I have a basic lambda calculus arithmetic question.... why is :  l yx. y ((l z.z) x) = l yx. y(x) ?
09:38:47 <fasta> patrick22:(lambda is denoted \ in ASCII)
09:39:00 <emu> ((\ z.z) x) = x
09:39:20 <fasta> aka identity function.
09:39:23 <emu> (\ z.z) should be recognizable as the I combinator "IDENTITY"
09:40:10 <Cale> and then by eta reduction, your whole function is the identity
09:40:36 <patrick22> yes, ok, but oops... the expression I was looking at, started with (\ yx.y(( \ sz. z) yx) = ... = 1
09:40:51 <patrick22> I don't understand where the second y goes to
09:42:49 <Cale> er...
09:42:59 <fasta> The complexity of array is O(length of associations), right?
09:43:00 <Cale> sure you didn't make a typo there?
09:43:29 <Cale> fasta: yes, but it doesn't evaluate them right away unless it's an unboxed array
09:43:37 <patrick22> the example is from a tutorial on lambda calculus explaining how to use it for making a succ function
09:43:51 <Cale> fasta: Well, actually, I'd say it's O(size of array)
09:43:53 <sjanssen> fasta: range size + length of associations
09:44:05 <fasta> sjanssen: oh, that's bad
09:44:30 <sjanssen> there's a fairly small constant factor on the range size part, though
09:44:39 <sjanssen> especially if the array is unboxed
09:45:24 <fasta> I tried to do (array (1,200000000) [(1,2)] ) ! 1 and that went very fast
09:45:38 <fasta> That's why I thought it was a simple malloc + one lookup
09:45:43 <fasta> + one set
09:45:44 <Cale> (\y x. y((\s z. z) y x) = (\y x. y((\s. y) x) = (\y x. y y)
09:46:15 <sjanssen> fasta: it has to set every box in memory to some default value
09:46:41 <sjanssen> if you're using a boxed array the default value is (error "array undefined at index") or something like that
09:46:48 <fasta> sjanssen: I can't use that. Is there a way around it?
09:47:04 <patrick22> Cale:  Thanks... this looks more clear to me
09:47:17 <sjanssen> avoid allocating huge arrays that you don't use?
09:47:26 <fasta> sjanssen: ...
09:47:40 <sjanssen> fasta: you're writing a matrix library?
09:47:45 <fasta> sjanssen: lots of algorithms use such tricks
09:48:01 <fasta> sjanssen: Well, I was hoping this would take only like 15 minutes.
09:48:29 <sjanssen> or just ignore the cost of the memset -- like I said, the constant factor is small
09:48:48 <fasta> sjanssen: It's not a constant factor
09:49:03 <fasta> sjanssen: It's independent of the number of elements to be set
09:49:10 <fasta> sjanssen: so, it's not a constant factor
09:49:13 <Cale> sjanssen: the constant factor associated with the number of elements
09:49:37 <Cale> It takes c * n + k time, where c and k are some constants :)
09:49:50 <Cale> He's saying that c is small
09:49:51 <sjanssen> I'm referring to c in c*rangeSize + d*assocSize
09:50:31 <fasta> Is it initializng everything to some default value or not?
09:50:38 <fasta> You earlier said it did
09:50:47 <sjanssen> yes, it must
09:51:03 <fasta> sjanssen: I don't think it "must".
09:51:15 <sjanssen> fasta: with a boxed array, it must
09:51:28 <fasta> sjanssen: I don't care whether it's boxed or not.
09:51:40 <fasta> sjanssen: Can I get what I want with an unboxed array?
09:51:47 <sjanssen> otherwise your program is likely to segfault when you index an undefined location
09:51:55 <fasta> I don't care about segfaults.
09:52:18 <sjanssen> fasta: there's a function to allocate a mutable unboxed array without a default element
09:52:25 <sjanssen> @hoogle newArray_
09:52:26 <lambdabot> Data.Array.MArray.newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
09:52:26 <lambdabot> Data.Array.MArray.newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
09:52:45 <fasta> Is there also a version based on DiffArray?
09:52:46 <sjanssen> @hoogle runSTUArray
09:52:47 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
09:52:54 <fasta> There's a DiffUArray
09:53:01 <fasta> That's "unboxed".
09:53:10 <sjanssen> not that I'm aware of
09:54:21 <sjanssen> note that this isn't pure either -- your program may return different results depending on what garbage is in memory
09:54:38 <fasta> sjanssen: if the program is correct, it's pure
09:56:43 <paolino> thanks Cale, I switch off for tonight (glguy is an haskellista)
09:56:51 <Cale> hehe
09:59:39 <malebria> sjanssen: about licensing, if I pick that code from dons and made some modifications in just that function, will it have a license restriction?
10:00:11 <sjanssen> malebria: yes, the code has whatever license dons put on it
10:00:28 <sjanssen> most of his code has a very permissive license
10:00:55 <malebria> sjanssen: yes, it's BSD3
10:05:07 <fasta> How about? newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
10:05:23 <sjanssen> @paste
10:05:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:05:32 <sjanssen> fasta: that's O(rangeSize)
10:05:55 <fasta> sjanssen: Ok, so I have to use newArray_
10:08:03 <hpaste>  sjanssen pasted "simple and reasonably quick matrix operations" at http://hpaste.org/494
10:08:39 <sjanssen> fasta: use that if you want
10:08:53 <sjanssen> I haven't tested it yet -- it's quite likely I flipped around an index
10:09:42 <fasta> sjanssen: that doesn't use uninitalized memory, AFAICT
10:10:18 <SamB> @where fps
10:10:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
10:10:50 <fasta> uninitialized*
10:11:03 <sjanssen> fasta: you are correct
10:11:21 <sjanssen> I think you're worrying to much about the cost of initializing memory
10:11:24 <sjanssen> s/to/too
10:11:49 <sjanssen> especially if you're just writing matrix multiplication and addition
10:12:18 <fasta> sjanssen: I never ever said I did multiplication or addition
10:12:21 <hpaste>  chessguy pasted "Not quite sure how to do this..." at http://hpaste.org/495
10:12:47 <fasta> sjanssen: I want to write an implementation with a certain complexity.
10:13:00 <fasta> sjanssen: I will just use the ST monad.
10:13:21 <chessguy> i want eval for each node to evaluate the children in the State Environment monad, and then apply the function in the root label to the [DataType] which results
10:14:16 <sjanssen> fasta: oh?  doing strassens or some other fancy method?
10:14:41 <chessguy> i think i want something like an fmap evalState?
10:14:52 <fasta> sjanssen: something like that.
10:15:11 <fasta> Anyway, more fancy than every other implementation I have seen.
10:15:39 <fasta> The algorithm exists for decades, but all the implementation don't follow the specification.
10:15:57 <fasta> implementations*
10:16:50 <sjanssen> what is the complexity?
10:17:01 <chessguy> @type fmap (runState)
10:17:03 <lambdabot> forall s a (f :: * -> *). (Functor f) => f (State s a) -> f (s -> (a, s))
10:18:40 <chessguy> @type fmap (evalState)
10:18:42 <lambdabot> forall s a (f :: * -> *). (Functor f) => f (State s a) -> f (s -> a)
10:19:15 <chessguy> @type map (evalState)
10:19:17 <lambdabot> forall s a. [State s a] -> [s -> a]
10:19:25 <fasta> @hoogle foldM
10:19:25 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
10:19:26 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:19:26 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
10:20:16 <chessguy> fasta, was that for me?
10:20:24 <fasta> chessguy: no, for me
10:25:29 <chessguy> ?hoogle ([d] -> m d) -> ([([d]->m d,Int)]) -> d
10:25:30 <lambdabot> No matches, try a more general search
10:26:59 <chessguy> ?hoogle ([d] -> m d) -> ([[d]->m d]) -> d
10:27:00 <lambdabot> No matches, try a more general search
10:27:05 <ndm> chessguy: hoogle dislikes higher kinds
10:27:27 <chessguy> kinds?
10:27:28 <ndm> chessguy: the website will find a few, but they'll be marked down harshly
10:27:40 <ndm> chessguy: m d, m is of kind * -> *
10:27:47 <ndm> constructor variables
10:27:56 <ndm> monads and functors are higher kinded
10:27:59 <chessguy> what should i try instead?
10:28:24 <ndm> giving me money to finish hoogle 4 ;)
10:28:42 <ndm> in fact money wouldn't have any effect, giving me time would help, but i can't see how anyone would be able to do that...
10:29:10 <SamB> ndm: by giving you money to buy stuff with
10:29:26 <SamB> so that you could survive without employment
10:29:29 <ndm> SamB: money cannot buy time, i have enough money to buy things like food which help make hoogle
10:29:42 <ndm> SamB: i do a phd, i can't stop even if i wanted to (and i don't want to)
10:29:47 <SamB> oh.
10:30:02 <SamB> well, in that case, I guess nobody can give you time until you get it?
10:30:05 <ndm> i could buy a faster computer, but i have the money to do that, but not the time to get it organised...
10:30:28 <ndm> i should end up doing hoogle 4 before my phd is over, its just finding the time to get it finished
10:30:54 <ndm> i guess if you used money to bribe the ICFP referees then i wouldn't have to spend as long on my paper and could spend more time on hoogle...
10:31:22 * chessguy slaps ndm back into reality
10:31:31 * ndm thanks chessguy
10:31:42 <ndm> chessguy: the website might give you an answer, its worth a try at least
10:31:43 <chessguy> any time
10:31:51 <SamB> or maybe we could bribe your supervisors and whatnot into letting you work on your phd at a more relaxed pace
10:31:51 <chessguy> ?where hoogle
10:31:52 <lambdabot> http://www.haskell.org/hoogle
10:32:32 <ndm> my supervisor is letting me be as relaxed as i want, i just happen to want a nice paper at ICFP which is my fault really
10:33:04 <SamB> oh
10:33:15 <SamB> so we could bribe *you* to give yourself more time?
10:33:22 <SamB> or maybe hijack is a better word?
10:34:04 <chessguy> sigh
10:34:12 <chessguy> i know there's an easy way to do this, but i can't work it out
10:34:46 <chessguy> i need something of type ([D] -> m D) -> ([[D]->m D]) -> D
10:34:52 <ndm> might work... - it will happen eventually
10:34:58 <ndm> chessguy: what does it need to do?
10:35:15 <ndm> chessguy: it returns undefined :)
10:35:18 <astrolabe> someone should ban ndm from #haskell :)
10:35:27 <ndm> chessguy: if you look at theorems for free :)
10:35:55 <ndm> (unless you have some inbuilt knowledge of D)
10:37:07 <chessguy> it needs to evaluate each of the [D]->m D in the second parameter, and turn each into a D, so now there's a [D], and then it should apply the first function to that
10:37:18 <chessguy> i guess the resulting type is m D
10:38:02 <sm> morning all
10:38:15 <ndm> chessguy: where does it get the initial [D] from?
10:38:56 <chessguy> oh, there's another function of type D -> [D]
10:39:02 <allbery_b> you can't do that for arbitrary monad m.  (consider IO)
10:39:49 <bd_> it could pass in [] for the first function, then shove the return value into a singleton list to iterate over the second list... wouldn't be particularly useful of course
10:40:52 <chessguy> well, in fact, in this case, the monad is State E
10:41:13 <chessguy> and if you want to see actual code: http://hpaste.org/495
10:45:06 <chessguy> sigh. every time i mention my code, it kills all conversation
10:49:12 <bd_> what are the semantics of the program?
10:49:30 <bd_> also, syntax error here: type Gene = ([DataType]->State Environment DataType, Int) <-- need parens around the (DataType, Int)
10:49:48 <chessguy> no
10:50:07 <bd_> ?
10:50:11 <chessguy> the first type in the tuple is [DataType] -> State Environment DataType
10:50:16 <bd_> oh
10:51:19 <chessguy> hmm, i think i should make it type Gene = [DataType] -> State Environment DataType   ;    type GeneWithArity = (Gene, Int)
10:51:22 <bd_> hmm
10:52:08 <bd_> execute (Tree (m, i) forest) = local (const i) (mapM execute forest) >>= m ?
10:52:17 <chessguy> an instance of Program is basically an s-expression
10:52:46 <chessguy> what's m?
10:53:07 <bd_> (m, i) is your Gene
10:53:22 <bd_> and, I guess it's not (const i) per se
10:53:32 <bd_> (const $ Environment i)
10:53:40 <chessguy> what if we change the datatypes as i suggested
10:53:44 <bd_> I'm just guessing from types
10:54:00 <bd_> Well, then GeneWithArity is never used :)
10:54:08 <chessguy> so we'd have execute (Tree m forest) = mapM execute forest) >>= m
10:54:09 <bd_> but if you alter Program as well, no change
10:54:10 <chessguy>  ?
10:54:19 <bd_> yeah, except you have a stray paren
10:54:31 <chessguy> oops
10:54:36 <bd_> :)
10:54:40 <chessguy> ?type execute
10:54:42 <lambdabot> Not in scope: `execute'
10:54:52 <chessguy> oh your execute is my eval?
10:54:53 <bd_> it's eval in your paste
10:55:11 <bd_> I was looking at Data.Tree's haddock at the time :)
10:55:36 <chessguy> (by the way, i'll use GeneWithArity somewhere else. the arity doesn't affect this function)
10:56:03 <xpika__> do you think there is any chance of Hackage having a commmon haddock repo so that it can be searched via hoogle?
10:56:23 <bd_> xpika__: I've heard it's #1 on the TODO... :)
10:57:52 <ndm> xpika__, hoogle 4 has been designed with that in mind
11:00:57 <chessguy> it doesn't like me using (Tree m forest) there
11:02:56 <bd_> er, (Node m forest), sorry
11:04:19 <xic> how can i test if an Integral value is outside of the range of Int?
11:04:37 <xic> cast it to Int and then back?
11:04:58 <allbery_b> or cast to Integer and compare against minBound :: Int and maxBound :: Int
11:05:26 <xic> ah cool thanks
11:05:26 <hpaste>  chessguy annotated "Not quite sure how to do this..." with "almost..." at http://hpaste.org/495#a1
11:05:37 <xic> > minBound :: Int
11:05:39 <lambdabot>  -2147483648
11:05:48 <emu> @info Bounded
11:05:49 <lambdabot> Bounded
11:05:56 <emu> @info minBound
11:05:57 <lambdabot> minBound
11:06:02 <emu> @yow
11:06:02 <lambdabot> Now KEN and BARBIE are PERMANENTLY ADDICTED to MIND-ALTERING DRUGS ...
11:06:06 <bd_> @src Bounded
11:06:06 <xic> allbery_b: is Int a different size in 64 bit haskell?
11:06:06 <lambdabot> class  Bounded a  where
11:06:06 <lambdabot>     minBound, maxBound :: a
11:06:22 <emu> xic: yes
11:06:32 <emu> Ints are machine-sized
11:07:25 <bd_> on amd64:
11:07:29 <bd_> Prelude Data.Int> (minBound, minBound) :: (Int, Int32)
11:07:30 <bd_> (-9223372036854775808,-2147483648)
11:07:44 <chessguy> bd_, it's seeing some kind of nested state
11:07:59 <xic> bd_: cool, does ghc work well on amd64?
11:08:19 <bd_> chessguy: don't return
11:08:46 <bd_> xic: as far as I can tell... memory usage is somewhat higher because all the info-table and etc pointers are 64-bit though
11:09:08 <chessguy> @redo execute (Tree (m, i) forest) = local (const i) (mapM execute forest) >>= m
11:09:09 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 30}) "Parse error"
11:09:14 <emk> Is there a MaybeT? Hoogle doesn't seem to think so.
11:09:24 <allbery_b> not standard, n
11:09:26 <allbery_b> no
11:09:28 <bd_> @redo local (const i) (mapM execute forest) >>= m
11:09:29 <lambdabot> do { a <- local (const i) (mapM execute forest); m a}
11:09:29 <chessguy> @redo execute mapM execute forest >>= m
11:09:30 <lambdabot> do { a <- execute mapM execute forest; m a}
11:09:30 <emk> I need to run some code in MaybeT IO...
11:09:37 <hpaste>  bd_ annotated "Not quite sure how to do this..." with "fixed :)" at http://hpaste.org/495#a2
11:09:42 <chessguy> ah
11:10:10 <bd_> emk: You can define it easily enough...
11:10:13 <chessguy> sweet mother of banana-splits!
11:10:31 <emk> bd_: Yeah, I'm headed off to do that right now..
11:10:38 <bd_> emk: http://www.cs.vu.nl/Strafunski/documentation/MonadMaybe.html
11:10:48 <bd_> the source is probably somewhere around there...
11:11:03 <allbery_b> @wiki New_monads/MaybeT
11:11:03 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
11:11:32 <bd_> Better to use a deriving clause
11:11:50 <bd_> for MonadFix anyway
11:12:26 <chessguy> now to figure out why it works :)
11:12:45 <bd_> :)
11:12:55 <bd_> @src mapM
11:12:56 <lambdabot> mapM f as = sequence (map f as)
11:14:28 <emk> allbery_b: Thanks! That's just what I was looking for.
11:14:30 <chessguy> ?sr sequence
11:14:31 <lambdabot> sequence ms = foldr k (return []) ms
11:14:31 <lambdabot>     where
11:14:31 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
11:14:48 <chessguy> riiiight
11:15:10 <chessguy> wait
11:15:21 <bd_> sequence just does a list of actions
11:15:23 <xic> bd_: are you using linux?
11:15:24 <bd_> and returns a list of results
11:15:25 <chessguy> bd_, what happens if the first child changes the State environment?
11:15:35 <bd_> xic: yeah
11:15:36 <chessguy> will the new environment be used to evaluate the next child?
11:15:40 <xic> bd_: how much ram do you have?
11:15:41 <bd_> chessguy: it'll affect the environment for the remaining children
11:15:42 <bd_> er
11:15:45 <bd_> not the environment
11:15:47 <bd_> the state
11:15:52 <bd_> the environment is local
11:15:55 <bd_> xic: 1G
11:16:09 <chessguy> i'm talking about the Environment
11:16:15 <chessguy> which is the state
11:16:22 <araujo> hello
11:16:52 <xic> bd_: i'm wondering how well 64 bit ghc would work for running an in-memory database program on 64-bit linux with like 10GB ram
11:17:31 <chessguy> bd_, what environment are you talking about that's local?
11:17:33 <bd_> presumably it'd work if you tweaked the GC parameters appropriately
11:17:34 <chessguy> araujo !
11:17:42 <bd_> chessguy: the environment is the reader environment
11:17:44 <bd_> wait
11:17:49 <araujo> chessguy!!!
11:17:49 <bd_> I was confused
11:17:50 <bd_> nevermind
11:17:54 <bd_> yeah it'd effect later children
11:18:00 <araujo> how things go over here?
11:18:27 <chessguy> araujo, cold and icy
11:18:31 <chessguy> but otherwise good
11:19:00 <araujo> hah, why?
11:19:19 <chessguy> why good or why cold and icy?
11:19:32 <araujo> cold and icy :-)
11:19:40 <chessguy> well, it is winter here :)
11:19:46 <araujo> ah, right
11:19:57 <araujo> i guess it's nice :-)
11:20:18 <chessguy> well, it's nice because i get to stay home and play with haskell today
11:20:31 <araujo> yay!
11:20:51 <bd_> hey, me too. what is it with everyone on the internet getting a snow day today?
11:21:59 <sm> snow day!
11:22:28 <chessguy> well, i'm actually sick today, according to my job
11:22:32 <qwr> what is snow day? it has been lot of snow over a month here...
11:22:35 <chessguy> they don't have "snow days"
11:22:49 <bd_> heh
11:22:56 <bd_> well, same thing
11:23:01 <araujo> hah
11:23:11 <bd_> It's just weird that the day all my classes are cancelled, I hear roughly the same from two other people
11:23:24 * sm 's car is in the shop.. no 2-hr commute today, such a shame :)
11:23:31 <chessguy> they told us "don't die coming into work. stay at home if you have to, but it's coming out of your sick time
11:23:47 <allbery_b> CMU didn't officielly close either
11:23:52 <allbery_b> de facto, though...
11:24:51 <gmh33> chessguy: same here.. only I'm an intern, so I don't get sick time :/
11:24:58 * araujo is also wondering if he should go to univ today
11:25:10 <glguy> araujo: what courses do you have today?
11:25:33 <araujo> glguy, stadistic for engineering
11:26:10 <araujo> but i got nothing important for today there an di need to fisnish some code fr other project
11:33:18 <mbishop> it must be really cold there araujo, your vowels are freezing and falling off :P
11:34:33 <pejo> mbishop, or he's just in the army.
11:36:00 <araujo> mbishop, it's actually very hot
12:15:12 --- mode: irc.freenode.net set +o ChanServ
12:16:02 <profmakx> hm
12:24:13 <chessguy> @pl filter (\x -> (snd x) == 0)
12:24:14 <lambdabot> filter ((0 ==) . snd)
12:31:26 --- mode: irc.freenode.net set +o ChanServ
12:31:41 <chessguy> @slap ChanServ
12:31:42 <lambdabot> why on earth would I slap ChanServ
12:32:02 <chessguy> teacher's pet
12:32:04 <chessguy> @users
12:32:05 <lambdabot> Maximum users seen in #haskell: 328, currently: 321 (97.9%), active: 38 (11.8%)
12:33:00 <chessguy> does haskell have the equivalent of something like assert in other languages?
12:33:27 <Lemmih> @type Control.Exception.assert
12:33:29 <lambdabot> forall a. Bool -> a -> a
12:33:41 <chessguy> nice
12:33:55 <chessguy> @type error
12:33:58 <lambdabot> forall a. [Char] -> a
12:36:09 <chessguy> > [1..5] !! 1
12:36:10 <lambdabot>  2
12:36:15 <chessguy> > [1..5] !! 0
12:36:17 <lambdabot>  1
12:36:22 <chessguy> > [1..5] !! (-1)
12:36:24 <lambdabot>  Exception: Prelude.(!!): negative index
12:37:30 <gvdm_other> [1..5] !! 6
12:37:38 <gvdm_other> > [1..5] !! 6
12:37:39 <lambdabot>  Exception: Prelude.(!!): index too large
12:37:57 <chessguy> > [1..5] !! 5
12:37:58 <lambdabot>  Exception: Prelude.(!!): index too large
12:38:41 <chessguy> picky, picky
12:40:35 <rashakil__> > [1..5] !! 4294967297
12:40:37 <lambdabot>  2
12:41:08 <chessguy> > 4294967297 :: Int
12:41:09 <lambdabot>  1
12:41:16 <chessguy> cute
12:41:33 <chessguy> > maxBound :: Int
12:41:34 <lambdabot>  2147483647
12:41:50 <rashakil__> [1..4294967297] :: [Int]
12:41:53 <rashakil__> > [1..4294967297] :: [Int]
12:41:55 <lambdabot>  [1]
12:41:59 <chessguy> lol
12:42:28 <chessguy> > length [1..4294967297]
12:42:32 <lambdabot> Terminated
12:42:39 <chessguy> bleah
12:42:42 <chessguy> that's bad
12:43:00 <chessguy> > length ([1..4294967297] :: [Int])
12:43:01 <lambdabot>  1
12:43:05 <chessguy> > length ([1..4294967297] :: [Integer])
12:43:09 <lambdabot> Terminated
12:43:16 <kaol> > [-4294967297..4294967297] :: [Int]
12:43:18 <lambdabot>  [-1,0,1]
12:43:43 <chessguy> (corner cases)--
12:43:50 <chessguy> @karma (corner cases)
12:43:51 <lambdabot> (corner has a karma of 0
12:45:30 <rahikkala> > maxBound + minBound :: Int
12:45:32 <lambdabot>  -1
12:46:04 <riwa> I'm trying to install ghc (glasgow haskell compiler?) but it asks for ghc while running the configuration. Am I totally out of the loop?
12:46:44 <kaol> self-hosting compilers are fun
12:46:44 <emu> in a way =)
12:46:49 <emu> it's all loopy
12:46:54 <chessguy> you'll probably want to get a binary for your platform
12:46:57 <emu> you need ghc to compile ghc
12:47:01 <chessguy> or build from C, which would not be fun
12:47:32 <riwa> emu: How is that possible?
12:47:46 <glguy> riwa: you need gcc to compile gcc
12:47:51 <glguy> you need ghc to compile ghc
12:48:09 <chessguy> riwa, what platform are you using?
12:48:34 <riwa> chessguy: Platform?? 386?
12:48:49 <chessguy> and OS
12:48:54 <riwa> chessguy: linux
12:49:04 <kaol> what distribution?
12:49:17 * chessguy gets out his tooth extractor
12:49:29 <riwa> kaol: slack
12:50:50 <riwa> Thinking about it it's probably a 486
12:51:33 <emu> riwa: i'd say 95% of compilers ever written are self-hosting like this
12:51:41 <emu> serious compilers
12:51:42 <chessguy> you probably want http://haskell.org/ghc/dist/6.6/ghc-6.6-i386-unknown-linux.tar.bz2
12:51:59 <Maddas> emu: You base your numbers on what?
12:52:21 <emu> the fact that if someone is committed to a language enough to write a compiler, then they want to write in that language
12:52:48 <Maddas> emu: Yes, but many languages are not limited to one compiler
12:52:57 <emu> so?
12:53:08 <thedward> can any of the haskell compilers besides GHC compile GHC?
12:53:09 <emu> there are multiple haskell implementations written in haskell each
12:53:17 <emu> no, sadly, it depends on ghc extensions
12:53:22 <thedward> I figured.
12:53:33 <xic> is there a haskell extension that lets you omit the "in" keyword after you drop a newline after "let"?
12:53:36 <emu> there might be a version you can compile with something else
12:53:41 <Maddas> emu: So writing it in a language doesn't mean that it can only be compiled by one compiler (i.e. self-hoisting)
12:53:47 <emu> xic: you can do that in do-blocks
12:54:03 <xic> emu: yeah, but do-block requires a monad value
12:54:06 <emu> Maddas: sorry, i meant self-hosting as in same-language
12:54:09 <Maddas> Ah, ok
12:54:23 <thedward> self-hosting doesn't mean you have to compile it with itself, only that you can
12:54:46 <emu> like SBCL is self-hosting, though you can technically use CLISP to compile it now (last time i tried)
12:54:52 <Cale> xic: let blocks are permitted to contain more than one declaration
12:54:52 <riwa> I still don't understand how you're ever to compile a the first compiler to haskell... written in haskell...
12:55:13 <emu> riwa: generally bootstrapping processes go through some throwaway compilers written in other languages
12:55:23 <emu> perhaps even direct assembler
12:55:24 <xic> Cale: yeah but if you have a new declaration on a new line then you must indent it
12:55:29 <Cale> riwa: you don't usually - if you had to, you'd do it by hand, but probably you'd go via another language
12:55:33 <emu> (or direct to machine code, if no assembler)
12:55:50 <Cale> xic: ah, I see what you mean
12:55:53 <emu> that's how the first compilers were bootstrapped -- hand-compiled programs
12:56:01 <Cale> xic: anyway, I think that'd be a bit confusing :)
12:56:16 <xic> Cale: i think it would save unnecessary indentation
12:56:23 <kaol> kids these days, they can bootstrap their compilers by writing haskell
12:56:28 <emu> isn't it grand
12:57:29 <thedward> I wonder if eventually perl6 will be written in perl, or if they'll stick with the haskell
12:57:29 <Cale> xic: er, but you'd be differentiating between indenting things more than the let but less than the thing after the let, which is only a few characters away
12:58:01 <Cale> xic: and really, what's so bad about indenting things by 3 extra spaces?
12:58:26 <Cale> thedward: there's a perl6 grammar in perl6 already.
12:58:52 <emu> let foo = 1
12:58:55 <emu>     bar = 2
12:58:57 <xic> Cale: i guess i'm the only one who is bothered by this *shrugs*
12:59:34 <chessguy> @type evalState
12:59:36 <emu> do-blocks don't actually require a monad value. only if you use monad combinators like return or <-
12:59:36 <lambdabot> forall s a. State s a -> s -> a
13:01:16 <xic> Cale: what bothers me even more though is that there is no good way to indent if-then-else constructs
13:01:23 <Cale> Sure there is
13:01:25 <Cale> if foo
13:01:28 <Cale>    then bar
13:01:32 <Cale>    else quux
13:01:37 <Cale> or
13:01:37 <chessguy> quux?
13:01:43 <Cale> if foo then bar
13:01:50 <Cale>        else quux
13:02:09 <xic> i'm aware of both of those ways, and don't like either. what i'd like to do is:
13:02:12 <xic> if foo then
13:02:16 <xic>     bar
13:02:17 <xic> else
13:02:19 <xic>     quux
13:02:21 <Cale> why?
13:02:32 <Cale> that looks messy to me :)
13:02:43 <Cale> the 'then' and 'else' are part of the 'if' expression
13:03:06 <xic> i think this looks good. and i think it could be made to parse ok also
13:03:18 <emu> i'm not a fan of if-then-else either. how about chained ones?
13:03:19 <Igloo> You can do that, as long as you aren't starting at first column of an implicit layout block (which I think can only be a problem in a do block)
13:03:24 <Cale> It probably does parse okay
13:03:34 <xic> no, i'm pretty sure that it doesn't work
13:03:34 <emu> i stick to using guards as much as possible
13:03:35 <Cale> Yeah, if you're not in a do-block
13:04:07 <Cale> But the usual Haskell way to indent it is much saner.
13:04:08 <emu> there is one rule which causes trouble for if-then-else like that in do-blocks, and i think there was discussion about changing it for haskell'
13:04:30 <Cale> yeah, there was something like changing the grammar to allow for an optional semicolon between the then and else parts
13:04:55 <emu> unfortunately the usual haskell way causes chained if-then-else-if to indent progressively further
13:05:00 <Cale> There are a few people opposed to that though, since then people don't learn to indent things properly
13:05:09 <emu> but somehow i've managed to write tons of haskell code without ever chaining if-then-else-if
13:05:14 <Cale> emu: and this alternative doesn't?
13:05:26 <Cale> Use guards if you need nested if's.
13:05:26 <emu> Cale: because the else starts at relative column 0, no
13:05:29 <Cale> (or lists :)
13:06:07 <Cale> emu: well, you're still going to indent the thing inside the else, aren't you?
13:06:16 <emu> by 4
13:06:22 <Cale> yeah
13:06:31 <emu> if ...
13:06:33 <emu> ....
13:06:35 <emu> else if
13:06:37 <emu> ....
13:06:37 <Igloo> You'd put "else if ... then" at the 0 level of indentation
13:06:50 <Cale> ah, okay
13:06:58 <Cale> I think that's pretty strange :)
13:07:05 <emu> this is how other languages typically do it
13:07:09 <Cale> I suppose it'd work.
13:07:23 <Cale> Yeah, but their if usually isn't an expression.
13:07:24 <emu> but yea, i always use guards or case expressions
13:07:29 <Cale> It's a statement.
13:07:34 <emk> (Monad transformers can be kinda strange...)
13:07:39 <emu> i just don't like if-then-else. it's clumsy.
13:07:49 <LordBrain> Does anyone use hugs to do shell-script type operations in haskell?
13:07:54 <emu> (I don't like the expression-style that much)
13:08:10 <Cale> case () of _ | ...
13:08:11 <emu> LordBrain: dons has written about doing so, maybe in ghc though
13:08:21 <Cale> :)
13:08:26 <emu> Cale: not that far! =)
13:08:47 <emu> also thanks to laziness you can combine nested cases into one case expression on a tuple
13:09:30 <emu> well, if-then-else really expands to case expr of True -> ...; False -> ... right? ;)
13:09:39 <LordBrain> laziness is indeed a virtue :)
13:11:36 <Cale> emu: yep
13:11:59 * sjanssen <3 case/guard idiom
13:13:12 <emu> actually, i've been wondering lately what the semantics of something like this is:  let foo | ... = 1 | ... = 2  where the ... depends on other things in the lexical scope but foo has no parameters
13:13:39 <xic> is there a shortcut for pattern-matching 'a':'b':'c':'d':x    hopefully something like "abcd":x ?
13:14:04 <mauke> xic: no :(
13:14:17 <emu> > let foo "abc" = 1 in foo "abc"
13:14:18 <lambdabot>  1
13:14:32 <emu> > let foo ("abc":x) = x in foo "abcdef"
13:14:33 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:14:41 <araujo> > "abcdef" !! 2
13:14:42 <lambdabot>  'c'
13:15:01 <emu> > let foo ("abc"++x) = x in foo "abcdef"
13:15:01 <lambdabot>  Parse error in pattern
13:15:04 <ropine> > let foo bar@("abc":_) = drop 3 bar in foo "abcdef"
13:15:05 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:15:19 <Cale> emu: it defines foo by the first guard which passes
13:15:34 <Eelis> is there a website maintaining a list of available Haskell libraries? i'm having difficulty finding libraries that deal with things like linear algebra and quaternions
13:15:35 <emu> yea that probably explains the behavior i saw
13:15:43 <ropine> > let foo bar@('a':'b':'c':_) = drop 3 bar in foo "abcdef"
13:15:44 <lambdabot>  "def"
13:15:52 <emu> Eelis: haskell.org
13:16:02 <araujo> Eelis, haskell.org is hte main site for haskell stuff
13:16:14 <Cale> http://haskell.org/haskellwiki/Libraries_and_tools
13:16:15 <lambdabot> Title: Libraries and tools - HaskellWiki
13:16:20 <Eelis> i see. thanks
13:16:24 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
13:17:37 <Cale> Only Haskell would have a library called cgi-undecidable
13:17:50 <xic> Eelis: the best module i've seen for 2d/3d vectors was the one in YAMPA
13:18:17 <Eelis> xic: i will certainly look at it. thanks
13:20:03 <chessguy> sigh
13:20:13 <chessguy> am i never going to grok random numbers in haskell?
13:20:27 <Cale> chessguy: do you understand the IO monad?
13:20:39 <chessguy> Cale, i have:
13:20:40 <chessguy> getRand :: (MonadState GlobalState m) => [a] -> m Int
13:20:40 <chessguy> getRand as = do
13:20:40 <chessguy>   s <- get
13:20:40 <chessguy>   let (r, g) = randomR (0,(length as) - 1) $ randomGen s
13:20:40 <chessguy>   put $ s {randomGen = g}
13:20:42 <chessguy>   return r
13:21:00 <chessguy> where GlobalState is a record with a randomGen :: StdGen
13:21:09 <Cale> okay
13:21:30 <chessguy> now i'm doing evalState (getRand list) (GlobalState { randomGen = (mkStdGen 4) })
13:21:53 <chessguy> but no matter what number i put in as the seed to mkStdGen, i'm getting the same integer back
13:22:02 <chessguy> s/integer/Int/
13:22:52 <Cale> let me try it
13:23:13 <mauke> well, that's what you get for using randomR and StdGens and stuff
13:23:26 <chessguy> mauke, instead of..>?
13:23:33 <mauke> randomIO
13:23:52 <chessguy> ?hoogle randomIO
13:23:53 <lambdabot> Random.randomIO :: Random a => IO a
13:24:18 <chessguy> oh
13:24:26 <chessguy> well, i don't particularly want to involve IO yet
13:24:42 <mauke> why not?
13:24:43 <hpaste> nickserv :identify beanbag
13:24:49 <glguy> :-/
13:24:54 <chessguy> mauke, purity
13:25:20 <mauke> you need a random seed anyway
13:25:29 <chessguy> yes, but i like that
13:25:32 <Cale> I don't get that behaviour
13:25:40 <Cale> I get different ints for different seeds.
13:25:46 <chessguy> really?
13:25:50 <Cale> *Main> evalState (getRand [1,2,3,4,5]) (GS { randomGen = (mkStdGen 4) })Loading package mtl-1.0 ... linking ... done.
13:25:50 <Cale> 4
13:25:50 <Cale> *Main> evalState (getRand [1,2,3,4,5]) (GS { randomGen = (mkStdGen 12) })
13:25:50 <Cale> 1
13:25:51 <Cale> *Main> evalState (getRand [1,2,3,4,5]) (GS { randomGen = (mkStdGen 13) })
13:25:53 <chessguy> wow, that's bizarre
13:25:53 <Cale> 0
13:26:26 <chessguy> i'm always getting 2
13:26:42 <chessguy> i just tried it with [1..5]
13:27:06 <Cale> map that as a function of the seed over a long range of integers and see what you get
13:27:18 <chessguy> hm?
13:27:28 <chessguy> i'm not sure what you mean
13:27:41 <Cale> [evalState (getRand [1,2,3,4,5]) (GS { randomGen = mkStdGen k }) | k <- [1..30]]
13:27:44 <Cale> like that
13:27:55 <bd_> @src [] mfix
13:27:55 <lambdabot> mfix f = case fix (f . head) of
13:27:55 <lambdabot>            []    -> []
13:27:55 <lambdabot>            (x:_) -> x : mfix (tail . f)
13:28:18 <Cale> [2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3] is what I get
13:28:22 <chessguy> [2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3]
13:28:28 <chessguy> lol
13:28:37 <Cale> see, so you are getting different results based on the seed
13:28:38 <kolmodin> dons: what's binary-broken?
13:29:33 <chessguy> *GP2> evalState (getRand [1..5]) (GlobalState { randomGen = (mkStdGen 66) }) 2
13:29:33 <chessguy> *GP2> evalState (getRand [1..5]) (GlobalState { randomGen = (mkStdGen 6) })
13:29:33 <chessguy> 2
13:29:33 <xic> if you get the error "The last statement in a 'do' construct must be an expression" then are you screwed. the error could be _anywhere_ :o
13:29:42 <Cale> xic: hm?
13:30:07 <Igloo> xic: I'm sure it tells you where it is
13:30:11 <Cale> xic: usually it's right next to the do, at the line and column the compiler tells you
13:30:21 <xic> Cale: wanna play a game? :) i'll paste a long sorce snippet and you try to find where the compile error is ;)
13:30:26 <Cale> okay
13:30:33 <Cale> paste the error too
13:30:40 <Cale> and keep the line numbers correct :)
13:30:49 <xic> ok give me a few min...
13:30:54 <chessguy> Cale, see? no matter what i put after the mkStdGen, i get the same result
13:31:11 <TSC> chessguy: Try 65 instead of 66
13:31:16 <Cale> chessguy: what?
13:31:30 <chessguy> that 2 at the end of the first line is a result
13:31:30 <Igloo> xic: If it's a tab/space problem then you'll need ot make sure they are maintained in the paste process too
13:31:37 <Cale> chessguy: you're using numbers which are congruent mod 5
13:31:39 <TSC> chessguy: The seeds have a pattern in them, they're the same if they're congruent mod 5
13:31:45 <chessguy> oh, wtf
13:31:48 <dibblego> ?where parallel
13:31:49 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
13:31:58 <chessguy> heh
13:32:13 <Cale> chessguy: think about the way that a pseudorandom number generator works :)
13:32:28 <chessguy> i don't have a clue how a pseudorandom generator works
13:32:30 <xic> Igloo: ok.... hang on.....
13:32:46 <xic> > let getRandom = 4 in getRandom
13:32:47 <lambdabot>  4
13:33:29 <Cale> well, okay, that's a little unfair, you have to know what kind of generator is being used by the Random library
13:33:44 <resiak> RFC1149.5!
13:33:48 <chessguy> so it's a simple function of modulus?
13:33:52 <chessguy> that doesn't seem very random
13:34:14 <Cale> well, it's a function with a long period under iteration
13:34:32 <chessguy> it's still not very random
13:34:43 <chessguy> [2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3]
13:34:45 <chessguy> that's awful
13:34:51 <Cale> and what you're doing after that is modding again in order to put the results in range
13:34:55 <TSC> That's not the random sequence
13:35:03 <Cale> that's why you don't pick seeds like that
13:35:43 <Cale> you use the new generator which it gives you
13:35:56 <Cale> (to get the next pseudorandom number)
13:36:23 <chessguy> ohhh, i see
13:36:24 <astrolabe> It would be nice if someone would port a better prng to haskell
13:36:36 <chessguy> so my actual program will be more random
13:37:11 <Cale> also, you should use newStdGen to create a generator initially
13:37:20 <TSC> I remember on haskell-cafe people were posting implementations of Mersenne Twister
13:37:22 <chessguy> instead of mkStdGen?
13:37:27 <Cale> yes
13:37:33 <chessguy> why is that?
13:37:43 <Cale> It'll unfortunately will use the time of day rather than system entropy, but that's better than a static number.
13:38:17 <Cale> If you pick a static number, you'll get the same sequence every time.
13:38:37 <chessguy> so every time i use the same seed, i'll get the same result?
13:38:42 <Cale> So if you're implementing a game, say, then the player will encounter the same random numbers every time they play.
13:38:45 <Cale> yes
13:38:46 <Cale> exactly
13:38:53 <chessguy> that's actually what i want
13:39:00 <Cale> well, okay then :)
13:39:08 <chessguy> at least for now
13:39:37 <chessguy> useful for testing purposes
13:39:39 <glguy> they will receive the same numbers for the same input at least :)
13:39:39 <Cale> http://www.augustsson.net/Darcs/MT/MersenneTwister.hs
13:39:48 <Cale> speaking of better PNRGs ;)
13:39:49 <tibbe> @where dons
13:39:49 <lambdabot> http://www.cse.unsw.edu.au/~dons
13:39:54 <tibbe> @seen dons
13:39:55 <lambdabot> dons is in #haskell. I last heard dons speak 11h 32m 6s ago.
13:40:21 <Cale> Too bad it doesn't use the Random interface.
13:40:31 <Cale> That shouldn't be too hard to hook up though.
13:40:40 <glguy> ?src RandomGen
13:40:40 <lambdabot> class RandomGen g where
13:40:41 <lambdabot>    next     :: g -> (Int, g)
13:40:41 <lambdabot>    split    :: g -> (g, g)
13:40:41 <lambdabot>    genRange :: g -> (Int,Int)
13:40:55 <glguy> does the mersenneTwister have a good concept of split?
13:41:08 <mbishop> Don's random element stuff from lambdabot should really be in the standard
13:41:12 <SamB> does anything?
13:41:26 <Cale> It ought to.
13:41:37 <glguy> SamB: some things definitely have better support than others, if that is what you were wondering
13:42:41 <Cale> It has 623-dimensional equidistribution
13:42:54 <Cale> So you should be able to split lots :)
13:43:27 <hpaste>  x pasted "try to find the error ;)" at http://hpaste.org/496
13:43:31 <xic> Cale: ^^^
13:43:55 <emk> ?src MonadTrans
13:43:55 <lambdabot> Source not found. Do you think like you type?
13:44:04 <emk> ?src Control.Monad.Trans
13:44:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:44:05 <Cale> xic: the error message?
13:44:23 <emk> ?src Control.Monad.Trans.MonadTrans
13:44:24 <lambdabot> Source not found. It can only be attributed to human error.
13:44:31 <xic> error.hs:12:4:
13:44:38 <emk> Wow, lambdabot is nasty today. :-)
13:44:40 <xic>     The last statement in a 'do' construct must be an expression
13:45:18 <Botje> xic: ehm.
13:45:22 <Botje> what's up with that big-ass let statement?
13:45:48 <xic> Botje: a standard haskell coding practice =]
13:45:54 <Botje> no it isn't.
13:46:06 <Cale> xic: why do you have all that stuff inside the let?
13:46:09 <resiak> xic: My guess is "you can't have the blank lines"
13:46:31 <Botje> at the very least you'd need an "in" all the way at the last statement
13:46:40 <xic> Cale: this is just a test case, to show the bug in ghc's error reporting
13:46:48 <chessguy> heh
13:46:52 <xic> Botje: no, it's a "do" block
13:47:03 <chessguy> most of ghc's errors have bugs in their reporting :)
13:47:33 <tibbe> how do I send a "message" to dons which he can read when he logs on?
13:47:44 <kolmodin> tibbe: use ?tell dons hia
13:47:46 <SamB>  @tell dons I love you
13:47:46 <TSC> xic: I found it easily by changing the let block to a where block, does that count?
13:47:47 <mbishop> @tell dons tibbe has a message to tell you
13:47:48 <lambdabot> Consider it noted.
13:48:37 <xic> TSC: i don't know, but don't you think that ghc should have given a better error message in the first place?
13:48:51 <TSC> Yes
13:49:28 <xic> i think this may be because of the fact that do notation was "bolted on" instead of properly integrated with ghc as a whole
13:49:48 <Cale> huh?
13:49:56 <Cale> How is it bolted on?
13:50:04 <tibbe> @tell dons mkcabal craches with "mkcabal: Prelude.read: no parse" when I enter my email like so: "Enter alternative: johan.tibell@gmail.com"
13:50:04 <lambdabot> Consider it noted.
13:50:15 <xic> ok i am probably wrong, it was just a guess :o
13:50:23 <JohnnyL> what are people in #haskell using haskell for?
13:50:42 <rahikkala> For showing it off to each other with lambdabot
13:50:51 <LoganCapaldo_> writing merge sort is what I did with haskell today :)
13:50:51 <chessguy> JohnnyL, what are people in ##c++ using c++ for?
13:51:12 <JohnnyL> chessguy, probably games or simulations.
13:51:18 <JohnnyL> two things haskell isn't good at.
13:51:18 <JohnnyL> haha
13:51:20 <xic> TSC: even though this is a contrived example, this issue actually screwed me earlier
13:51:25 * LoganCapaldo_ thinks an algorithms book would be good with Haskell as the pseudo code
13:51:33 <chessguy> JohnnyL, haskell is fine for games and simulations
13:51:46 <JohnnyL> chessguy, url?
13:51:51 <TSC> xic: Yeah, I can see how it would be a problem
13:51:51 <chessguy> ?where frag
13:51:51 <lambdabot> http://www.haskell.org/haskellwiki/Frag
13:52:25 <glguy> xic: was the error your indentation of if then else?
13:52:25 <xic> Cale: so what do you think?
13:52:32 <xic> glguy: no :P
13:52:34 <JohnnyL> well spank my heiney and call me charlie.
13:52:57 <LoganCapaldo_> Plus, its a thesis!
13:53:09 <Cale> I think the code is unreasonably poor :)
13:53:20 <chessguy> Cale, it's a proof-of-concept
13:53:21 <glguy> xic: doesn't help that there isn't an error message
13:54:18 <glguy> and what's with all the reimplementations of map
13:54:29 <hpaste>  x annotated "try to find the error ;)" with "ghc error message" at http://hpaste.org/496#a1
13:54:53 <Igloo> xic: OK, that is definitely a bad error message. Can you file it as a bug against GHC please?
13:55:02 <xic> woohoo, i win! :D
13:55:41 <xic> Igloo: ok, i'll see what i can do. did you find the error btw?
13:55:41 <glguy> xic: the volume' function?
13:55:47 <Cale> I had no trouble correcting the problem though.
13:56:03 <hpaste>  Cale annotated "try to find the error ;)" with "reindent." at http://hpaste.org/496#a2
13:56:24 <Igloo> xic: Yes
13:56:26 <Cale> er, that's odd
13:56:31 <Cale> are there tabs in this file?
13:56:42 <Igloo> Cale: No important tabs
13:56:47 <chessguy> uh
13:56:53 <chessguy> what a hideous program
13:57:13 <Cale> oh, I see, I was looking at the wrong one.
13:57:25 <Cale> I'd aligned things correctly :)
13:57:45 <glguy> 28-73746f34.cust.bredbandsbolaget.se] has quit [Remote closed the con
13:57:46 * chessguy makes xic write "i will use functions instead of a monolithic programming style" on the blackboard 100 times
13:57:47 <glguy> bah
13:57:50 <glguy> firstQuad ((Coord x y):cs)
13:58:03 <glguy> nope :)
13:58:06 <Cale> Yeah, you basically should not have that many things inside of a let, ever.
13:58:25 <glguy> so what was it then?
13:58:51 <xic> Cale: well, this error was very confusing to me even when my let was only 8 lines
13:59:10 <chessguy> xic, there's still a lot less to look at
13:59:26 <chessguy> xic, and your components can be tested independently
13:59:59 <xic> yeah, but when you make a small typo, you don't want to start testing all of your components. you want the compiler to tell you exactly where you made a mistake
14:00:04 <chessguy> e.g., how would you know if your implementation of, say, stirling's approximation, had a bug in it
14:00:14 <Igloo> Cale: Large lets are nice when you want to do something like   do x <- mk_x; let {f = ...; ...; g = ...} f   where f...g all use x and you don't want to pass it around by hand to all of the inter-function-calls
14:00:34 <chessguy> xic, well, you should test each function as you write it
14:00:40 <xic> Igloo: i use this style often
14:00:49 <chessguy> xic, it's very bad haskell style
14:01:02 <Cale> I usually just pass the thing as a parameter.
14:01:33 <chessguy> xic, and you're not doing what he said anyway (i don't think)
14:02:03 <Botje> xic: what do you hope to gain by using that style instead of properly putting everything into a function?
14:02:18 <glguy> more importantly, what was the secret error!
14:02:34 <Igloo> Botje: By "properly putting everything into a function" do you mean making everything a top-level function?
14:02:51 <Botje> Igloo: the things that don't have complex dependencies, at least
14:02:54 <chessguy> Igloo, look at http://hpaste.org/496
14:03:29 <chessguy> glguy, the "secret error" was there too:  The last statement in a 'do' construct must be an expression
14:03:34 <chessguy> s/was/is/
14:03:43 <Igloo> One advantage is that you don't have to worry about accidentally using a wrong definition
14:03:43 * chessguy teaches glguy how to use hpaste
14:03:49 <glguy> chessguy: no, that's the reported error
14:04:04 <glguy> chessguy: and Igloo is probably fully aware of what paste we are discussing
14:04:04 <Igloo> Also, you can use shorter names for things that are local
14:04:15 <chessguy> ok
14:04:17 * chessguy shuts up
14:04:46 <chessguy> it's still hideous style anyway
14:04:57 * Igloo isn't arguing for large lets in general, but I do think they sometimes have their uses
14:05:03 <Cale> It's the case expression
14:05:16 <Cale> the _ -> 0 is indented too far.
14:05:19 <glguy> ah
14:05:33 <Igloo> I'm also biased in favour of using where rather than let, but I don't think there's any good reason for that other than it's what I learnt first
14:05:51 <Cale> yeah, that really probably should trigger a syntax error inside the case.
14:05:57 <mahogny> mahogny@venus:~/hsallegro$ ghc HsAllegro.hs     =>    HsAllegro.chs:136:8: parse error on input `import'
14:06:08 <mahogny> can someone explain how it automagically starts looking at .chs?
14:06:24 <Cale> Igloo: it lets you say what is important first
14:06:48 <glguy> similar to list comprehensions
14:07:46 <dmhouse> Cale: on the other hand, let order makes better temporal sense.
14:07:54 <Cale> It does?
14:07:56 <glguy> I don't think (at first glance) that it would be a huge loss to eschew do-notation in favor of monad-comprehensions
14:08:03 <Cale> :)
14:08:05 <dmhouse> Also, it more similarly mirrors imperative code. I guess those two things are really the same thing.
14:08:20 <Cale> Usually the things in the let are going to be evaluated later than the things in your expression.
14:08:38 <Cale> > let a = a in const 5 a
14:08:40 <lambdabot>  5
14:08:58 <glguy> let notation doesn't imply any particular order, like imperative languages, it simply seems similar
14:09:19 <dmhouse> Cale: yes, but conceptually, if you say "compute x using y and z", I'd expect y and z to already be defined.
14:09:28 <LoganCapaldo_> > const 5 a where a = a -- whee
14:09:29 <lambdabot>  Parse error
14:09:30 <dmhouse> Although, when I just wrote that, I guess that's my imperative bias coming out.
14:09:33 <LoganCapaldo_> :(
14:09:44 <dmhouse> There doesn't appear to be any conceptual reason to require let or where style.
14:09:51 <Cale> LoganCapaldo_: where is part of declaration syntax
14:09:51 <glguy> let logancapaldo_ = const 5 a where a = a
14:09:59 <glguy> in logancapaldo_
14:10:44 <Cale> The "real" reason for where is that it scopes over guards, allowing you to stick an effective let where you otherwise couldn't.
14:11:01 <dmhouse> I guess, for example, when you set up an argument, you present your supporting reasons first, then lead on to your conclusion at the end. On the other hand, when you write a paper, your abstract at the beginning gives the conclusion away, which could be considered where-like structure.
14:11:01 <Cale> The even more real reason for where is that ISWIM had it.
14:11:10 <chessguy> ISWIM?
14:11:16 <chessguy> ?google ISWIM
14:11:18 <lambdabot> http://en.wikipedia.org/wiki/ISWIM
14:11:22 <LoganCapaldo_> ISWIM, USWIM We all SWIM for ISWIM
14:11:29 <LoganCapaldo_> I say What I mean IIRC
14:11:35 <Cale> @remember LoganCapaldo ISWIM, USWIM We all SWIM for ISWIM
14:11:35 <lambdabot> Done.
14:11:39 <glguy> when you write a function, you declare the result, if someone wants to know more they can read further, if they are satisfied, they've seen the result
14:12:38 <dmhouse> Okay, a disadvantage of where: assuming you read top-to-bottom, you read the conclusion before understanding what supports the conclusion, so you have to read the where bindings to fully understand the function, but then you have to pop back to the top to round it off.
14:12:41 <Cale> I like the fact that Haskell has its roots in a language that was never implemented.
14:12:58 <Saizan> one thing that i hate using monads/do-notation is that functions defined in "where" don't have the <- bindings in scope
14:13:06 <Cale> dmhouse: We use the style in mathematics a lot too.
14:13:11 <chessguy> Cale, from that article, it's apparently not unique in that respect
14:13:27 <dmhouse> But then, if you had a function written in let-style, you might start thinking 'why do you want to define that?', but with where-style, you think 'ah, that's the definition for that part, I see immediately why it's needed.'
14:14:00 <Cale> The square root of 2 is not rational. Indeed, suppose for purposes of contradiction that (p/q)^2 = 2 for some coprime integers p,q...
14:14:08 <dmhouse> Yeah.
14:14:42 <chessguy> Cale, you mean "where p and q are coprime integers"? :)
14:14:50 <Cale> chessguy: sure :)
14:15:06 <Cale> chessguy: I was really using the "Indeed" as my "where" :)
14:15:09 <LoganCapaldo_> where p :: (Coprime n) => n
14:15:23 <chessguy> i knew something like that was coming
14:15:24 <LoganCapaldo_> no that doesn't really work
14:15:25 <dmhouse> But you'd also see 'Assume sqrt(2) is rational. Let p and q be coprime integers such that sqrt(2) = p/q.'
14:16:05 * LoganCapaldo_ has started using :: in his math notes for properties of variables
14:16:30 <chessguy> dmhouse, yes. so the conclusion is....haskell supports lots of natural-feeling math-like syntax. which...we all knew already
14:16:37 <dmhouse> Right. :)
14:16:50 <LoganCapaldo_> y = x + 1, y :: Dependent variable, x :: Independant -- stuff like that
14:16:56 <chessguy> glad we clarified that :)
14:17:14 <LoganCapaldo_> Think it'll catch on? ;)
14:17:14 <chessguy> that sounds like an abuse of ::
14:17:15 <dmhouse> I think I just about convinced myself that there's no conceptual (dis-)advantages to seperate let/where, it's down to taste, which I also already knew, really. :)
14:17:58 <Cale> I hate how people regularly abuse the dependent/independent variable distinction.
14:18:11 <LoganCapaldo_> Did I pick a really bad example?
14:18:13 <LoganCapaldo_> Uh oh
14:18:23 <Cale> nah, it may have been okay
14:18:23 * LoganCapaldo_ hides under a safe rock
14:18:29 <fasta> What's the complexity of runSTArray?
14:18:34 <dmhouse> Cale: what's the technical distinction, then/
14:18:40 <chessguy> well, it's hard to say that either is really independent of the other
14:18:51 <chessguy> because you could just as easily write x = y - 1
14:18:55 <Cale> dmhouse: It's about how you set up your experiment.
14:19:01 <fasta> I.e. does it initialize every element when it converts to Array?
14:19:44 <Cale> dmhouse: It only applies to scientific experiments, and not just variables in general.
14:20:04 <dmhouse> chessguy: or even x - y + 1 = 0
14:20:23 <astrolabe> Cale: Isn't it standard nomenclature for ODEs/PDEs too?
14:20:24 <oklopol> what does "const" do?
14:20:32 <dmhouse> oklopol: returns its first argument.
14:20:40 <oklopol> okay, thanks
14:20:41 <chessguy> dmhouse, if you have a thing for homogeneity
14:20:45 <mauke> @src const
14:20:45 <lambdabot> const x _ = x
14:20:51 <dmhouse> > const "foo" 56905390
14:20:52 <lambdabot>  "foo"
14:20:53 <chessguy> if homogoeneity is even a word
14:20:58 <Cale> astrolabe: I haven't seen it used in that context, but I haven't really done much with differential equations.
14:20:59 <dmhouse> chessguy: yeah, it is.
14:21:11 * LoganCapaldo_ DE was were I was coming from
14:21:19 * LoganCapaldo_ goes back under the rock
14:21:38 <Cale> oh, okay, perhaps it is then :)
14:22:09 <Cale> The abuses that I've seen come mostly from analysis of data in science.
14:24:02 <fasta> Or rather the question boils down to: is unsafeFreezeSTArray O(1)?
14:24:29 <LoganCapaldo_> @src unsafeFreezeSTArray
14:24:30 <lambdabot> Source not found. Do you think like you type?
14:24:38 <LoganCapaldo_> So much for that method :)
14:25:13 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html#v%3AunsafeFreeze
14:25:15 <lambdabot> http://tinyurl.com/y2qz4l
14:25:27 <P4W3R> if you are alone, lambdabot always listens to you
14:25:29 <Cale> that says which pairs of types unsafeFreeze is O(1) for
14:25:49 <Cale> and you have to turn on optimisations to get O(1) performance
14:26:09 <fasta> Cale: just -0?
14:26:13 <fasta> Cale: thanks :)
14:26:22 <Cale> yeah, just -O
14:27:13 <P4W3R> ao
14:28:00 <LoganCapaldo_> unsafeFreezeSTArray should be lazier
14:28:01 <dibblego> Cale, have you looked at CAL? I only ask because you once spoke about Scala, so I figure you might have an opinion
14:28:07 <LoganCapaldo_> (COW)
14:28:42 <LoganCapaldo_> or rather freeze should be COW. Then you don't even need unsafeFreeze (I don't think anyway)
14:28:59 <Cale> dibblego: nope, haven't looked at CAL yet
14:29:40 <Cale> The fact that it's by a company called Business Objects made me put off looking at it. Is it cool?
14:29:58 <dibblego> looks very cool at first sight, but I agree with your opinion of the front cover :)
14:30:02 <bos> it's their haskell-alike for running inside a JVM.
14:30:18 <bos> lazy pure functional goes up to 11.
14:30:23 <dibblego> it's Haskell, for Java, with additional strictness annotations, but with semicolons and insignificant whitespace
14:30:29 <emu> what do people usually do to write randomized algorithms in pure code?
14:30:40 <dibblego> bos, 11? what does that mean?
14:30:42 <bos> emu: inside a monad.
14:30:44 <LoganCapaldo_> @hoogle RandomGen
14:30:45 <lambdabot> System.Random.RandomGen :: class RandomGen g
14:30:50 <emu> inside IO?
14:30:50 <bos> dibblego: see the movie "this is spinal tap"
14:30:59 <dibblego> bos, OK :)
14:30:59 <bos> no, ST usually.
14:31:04 <emu> oh, you can do it inside ST?
14:31:04 <LoganCapaldo_> emu or just State / ST
14:31:05 <Cale> emu: pass around StdGens or use my Random monad
14:31:05 <fasta> Cale: but this means that I can get uninitialized memory inside an Array value. Does it crash when I reference an invalid value? It would be marvelous if it does crash.
14:31:11 <bos> or State.
14:31:26 <emu> can you do it inside ST and avoid leaking the abstraction?
14:31:27 <Cale> fasta: good question. It probably segfaults.
14:31:33 <recht> hi... I'm messing around with the excersises from the SOE book, and have run into a small problem: I try to do a case match on getWindowEvent, like this: Button pt True False -> return () (or whatever), but hugs then tells me that there's a Type error in case pattern - any ideas why?
14:31:38 <fasta> Cale: that's what I am counting on.
14:31:47 <Cale> fasta: why would you count on that?
14:31:58 <bos> emu: what abstraction?
14:32:03 <bd_> fasta: Arrays elements are initalized to _|_ I thought? Unless you're using something unsafe*.
14:32:12 <fasta> Cale: because if it initialises the memory, I still didn't win anything.
14:32:15 <emu> bos: of whatever algorithm you are implementing. like randomized qsort.
14:32:18 <LoganCapaldo_> You can initialize things to bottom??
14:32:24 <fasta> bd_: unsafeFreezeSTArray
14:32:26 <bd_> LoganCapaldo_: sure, 'undefined'
14:32:28 <emu> LoganCapaldo_: if they are non-strict
14:32:34 <bos> emu: from the outside, it will still be pure.
14:32:34 <bd_> fasta: the STArray should have defined elements though.
14:32:45 <bd_> fasta: even if they're defined to _|_
14:32:55 <LoganCapaldo_> bd_, For some reason I thought there was a subtle difference between _|_ and undefined
14:32:57 <LoganCapaldo_> I guess not
14:33:19 <emu> bos: well, how?  suppose you supply a type with a misbehaved instance of Ord: non-transitive.  then the algorithm could give different results for different random numbers.
14:33:25 <Cale> recht: that's odd -- can you paste that code?
14:33:28 <Cale> !paste
14:33:29 <hpaste> Haskell paste bin: http://hpaste.org/
14:33:34 <bd_> LoganCapaldo_: undefined is a constant which happens to be _|_. Just like error is const _|_ ;)
14:33:40 <bos> emu: oh, i see what you're getting at.
14:33:45 <bd_> LoganCapaldo_: The end effect is it crashes, usually, of course
14:33:46 <emu> bos: or even something like a treap
14:33:51 <bos> i don't see what you can do about that.
14:33:51 <fasta> bd_: What makes you think that?
14:34:01 <emu> bos: where the relative levels of items in the treap depends on random numbers
14:34:05 <bos> that's not leaking an abstraction, it's leaking a bug.
14:34:07 <bd_> fasta: because you're not supposed to segfault :)
14:34:09 <Cale> recht: oh, are you writing case getWindowEvent of ?
14:34:14 <fasta> bd_: I just need an array that is _not_ initialized.
14:34:31 <Cale> or rather
14:34:34 <fasta> bd_: or just random bit-patterns.
14:34:39 <Cale> case getWindowEvent w of ...
14:34:41 <bd_> fasta: I think that can be done with unboxed arrays, but I'm not sure. Boxed arrays it's not safe, as the GC would barf on it.
14:34:41 <emu> bos: sure, but it violates referential transparency, so i wonder how random could ever be implemented inside ST or anything but IO.
14:34:43 <Cale> that would be wrong
14:34:56 <bos> emu: you'll be getting pseudo-random results back out. i.e. run the monadic algorithm twice, with the same seed, and get the same results back. it remains referentially transparent.
14:34:56 <hpaste>  recht pasted "soe exercise" at http://hpaste.org/497
14:35:08 <bd_> fasta: hm, though, it'd break referential transparency
14:35:16 <emu> yea, you have to include a seed
14:35:24 <fasta> bd_: I do use unsafe...
14:35:27 <Cale> what the...
14:35:33 <hpaste>  chessguy pasted "My monads aren't lining up" at http://hpaste.org/498
14:35:39 <bos> emu: if you really need a different seed on every run, you have to either thread that into whatever's calling in, or lift your entire computation into the monad.
14:35:42 <bd_> fasta: you need to use an unsafe function to /create/ the array. Not convert it later.
14:35:44 <fasta> bd_: Do you really _know_ this or are you guessing? I can't use the latter.
14:35:45 <Cale> recht: uh, that's nuts :)
14:35:55 <recht> Cale: that's what I thought :)
14:35:58 <Cale> recht: do you have a local definition of the Event type maybe?
14:36:01 <fasta> bd_: do you know of such a function?
14:36:09 <Cale> that's shadowing the other?
14:36:12 <fasta> bd_: sjanssen thougth newArray_ would work
14:36:26 <fasta> thought*
14:36:29 <bd_> fasta: newArray_ specifically syas all elements are initialized to undefined
14:36:29 <emu> bos: it seems like it might be possible to make it referentially transparent to use completely random numbers IF you hide it all behind an abstraction; treaps are a good example, suppose you used treaps to implement Data.Map?
14:36:35 <bd_> fasta: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html#v%3AnewArray
14:36:37 <lambdabot> http://tinyurl.com/257sl9
14:36:38 <fasta> bd_: I know
14:36:49 <recht> Cale: that was my 10th guess, but I can't find any declaration anywhere, and as far as I can see, I don't import any other modules which have the type
14:36:52 <fasta> bd_: but I interpreted it not as undefined the value.
14:37:09 <Cale> recht: can I have your whole file?
14:37:19 <fasta> bd_: crashing would semantically be the same
14:37:28 <bos> emu: you still wouldn't have a guaranteed order of traversal if you walked the contents of the map using map or fold
14:37:42 <bos> so you wouldn't have referential transparency.
14:37:43 <recht> Cale: you can, but you need more than one file to compile
14:37:48 <emu> bos: but in a treap, it doesn't matter what the random numbers are, the traversal is the same
14:37:54 <emu> if you walk it in order
14:38:06 <Cale> recht: Well, maybe try it in GHC. The SOE library is at Graphics.SOE
14:38:07 <emu> er, not "in-order" but in order of keys
14:38:28 <bd_> fasta: You /cannot/ have an uninitialized boxed array. The GC would be following pointers to nowhere.
14:38:32 <emu> bos: the fact that it is a treap would be hidden anyhow
14:38:32 <Cale> just load it in ghci, if you have that
14:38:41 <Cale> if you want to compile, you'll need --make
14:38:47 <emu> i just don't see how the typechecker could prove that the random numbers never leak
14:38:52 <monochrom> No FreeBSD binary for GHC 6.6?  Is it just because no one has bothered building?  Any known build problems?
14:38:54 <bd_> fasta: For an unboxed array, you could look at the initialization functions in http://darcs.haskell.org/ghc-6.6/packages/base/Data/Array/Base.hs . It doesn't look like there's a standard interface to create uninitialized stuff.
14:38:56 <fasta> bd_: ok, then an unboxed array. I don't care what type it is.
14:38:59 <bos> it can't.
14:39:21 <MarcWebe1> Are there still some tricks to speed this up ? main = putStrLn $ renderHtml $ simpleTable [] []  [map (\i -> toHtml $ show i ++ " " ++ show j) [1..1000] | j <- [1..1000]]
14:39:26 <Cale> bos: I just bumped into this: http://citeseer.ist.psu.edu/346751.html :)
14:39:28 <lambdabot> Title: Lazy Functional Quaternions (ResearchIndex)
14:39:56 <chessguy> so....any ideas about this? http://hpaste.org/498
14:40:14 <bos> Cale: wow.
14:40:20 <fasta> bd_: how do you mean it can't? Is it also impossible in the IO monad/
14:40:38 <fasta> bd_: or even using the FFI function.
14:40:41 <bd_> fasta: I just mean there's no factored-out function to just create the array without initializing it
14:40:43 <fasta> functions*
14:41:05 <Cale> chessguy: terminals is a list of Gene?
14:41:06 <bd_> fasta: If you don't want to delve into the GHC.Prim stuff, you could use Data.Storable and unsafeForeignPtrToStorableArray
14:41:14 <chessguy> yes
14:41:23 <Cale> chessguy: not a list of Program, like your code would seem to imply
14:41:36 <chessguy> ohh
14:41:37 <fasta> bd_: Can I convert that to an Array?
14:41:37 <Cale> er, not only that
14:41:42 <fasta> bd_: (probably not)
14:42:01 <Cale> But you're actually returning a  Tree (State GlobalState Gene)
14:42:04 <bd_> fasta: Only slowly. You'll need to use GHC.Prim methods to get an uninitialized array.
14:42:45 <bd_> fasta: does it really matter that it's initializing it ahead of time? It's O(n) - and your algorithm must also be O(n) at least to be able to overwrite all of the elements
14:42:50 <Cale> chessguy: One hint for handling these situations is to try erasing the signature and see what gets inferred.
14:43:16 <fasta> bd_: the point is that the algorithm doesn't use O(n)
14:43:33 <chessguy> Cale, so i'd have to enter a do block and get the gene?
14:43:35 <fasta> bd_: I skimmed the GHC.Prim interface, but I didn't see it.
14:43:49 <chessguy> and then return $ Node gene []
14:43:50 <bd_> fasta: http://darcs.haskell.org/ghc-6.6/packages/base/Data/Array/Base.hs take a look at the instance MArray (STUarray ...
14:43:57 <chessguy> except i don't want to return a gene
14:44:09 <xic> is there something like Data.List.find, but that lets me modify the found element in the list?
14:44:24 <chessguy> ?src Data.List.find
14:44:25 <lambdabot> Source not found. You type like i drive.
14:44:26 <Cale> chessguy: yeah, if that's what you're looking for
14:44:30 <chessguy> Cale, ok
14:44:32 <chessguy> thanks
14:44:37 <bd_> fasta: note that your array in this case will NOT be referentially transparent, since many of its elements will be initialized randomly
14:44:53 <Cale> chessguy: you might want to make your Tree type Traversable, if you're up for learning the new 6.6 libraries :)
14:44:57 <xic> something like findAndModify :: (a -> Bool) -> (a -> a) -> [a] -> Maybe (a, [a])
14:45:00 <fasta> bd_: That's exactly what I need.
14:45:05 <Cale> @type Data.Traversable.sequence
14:45:07 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Traversable t, Monad m) => t (m a) -> m (t a)
14:45:11 <recht> Cale: ok, I switched from a custom version of Graphics.SOE for hugs (SOEGraphics) to Graphics.SOE and ghc, and then it worked
14:45:12 <fasta> bd_: I want it to crash when I have a bug.
14:45:17 <bd_> fasta: it won't :)
14:45:29 <fasta> bd_: ?
14:45:34 <Cale> recht: okay, then it's just some kind of library insanity, or a hugs bug.
14:45:39 <bd_> fasta: the only way to do that reliably is with newArray_ initializing all of your elements to _|_.
14:45:54 <bd_> fasta: If you create a boxed array with uninitialized elements, the GC may crash even if your code is correct
14:46:05 <ddarius> @hoogle (a -> Bool) -> [a] -> ([a],[a])
14:46:06 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
14:46:06 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:46:06 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
14:46:12 <bd_> fasta: If you create an unboxed array with uninitialized elements, your code won't crash, it'll just have bad data
14:46:23 <fasta> bd_: Ok, so, what was the point of showing that module?
14:46:25 <bd_> fasta: Therefore, you must initialize the array to bottom.
14:46:30 <bd_> fasta: I thought you were micro-optimizing.
14:46:45 <ddarius> xic: It could be made easily with one of those functions.
14:46:57 <Cale> fasta: are you absolutely sure that allocating that array is taking over 10% of your time profile?
14:47:02 <fasta> bd_: I understand your point with the GC somewhat.
14:47:09 <Cale> If not, then I wouldn't worry about it.
14:47:11 <fasta> Cale: That is of completely zero interest.
14:47:32 <fasta> Cale: This is not some "business application".
14:47:38 <bd_> fasta: if you're not concerned with time, and want a crash on incorrect accesses, use newArray_ which will initialize to undefined in O(n).
14:47:49 <fasta> bd_: that's too slow
14:48:02 <bd_> fasta: Are you sure?
14:48:06 <Cale> fasta: If you're writing this for academic interest, then that's even more reason to avoid low-level junk :)
14:48:06 <fasta> bd_: yes, I am sure.
14:48:12 <bd_> fasta: Have you profiled?
14:48:22 <fasta> bd_: not relevant
14:48:26 <SamB> ... if O(n) is too long to take to initialize an array, don't use arrays
14:48:29 <bd_> fasta: I fail to see how it's not relevant.
14:48:32 <Cale> Assume that the compiler can optimise its initialisation of the array.
14:48:41 <fasta> 23:46 <Cale> fasta: If you're writing this for academic interest, then
14:48:41 <fasta>              that's even more reason to avoid low-level junk :)
14:48:46 <bd_> fasta: If your array is /that/ sparse, use Data.Map :)
14:49:08 <bd_> and fromJust for your crash behavior
14:49:26 <Cale> bd_: That's what I would do :)
14:49:37 <fasta> ...
14:49:37 <bd_> or Data.IntMap even, since you've obviously got Ix
14:50:01 * Cale advocates the use of soft-O to measure runtime complexity anyway.
14:50:12 <fasta> soft-O?
14:50:17 <Cale> Let's all ignore logarithmic factors!
14:50:43 <bd_> fasta: I'm not really seeing why you need a truly uninitialized array anyway... you won't get reliable failure behavior, and you will end up littering your code with #s, and probably breaking it when the next version of GHC comes
14:51:44 <bd_> what are you trying to use this for anyway?
14:51:48 <Cale> I've never run into a case where the difference between O(n log n) and O(n) was of practical relevance.
14:52:07 <fasta> bd_: You are essentially saying that all algorithmic tricks that rely on this or similar mechanisms are useless.
14:52:08 <Cale> The constant factor was always way way larger than log n
14:52:23 <bd_> fasta: What 'algorithmic tricks' are you talking about?
14:52:40 <dons> fasta, so you have the code you need?   /me tries to work out if fasta's problem has been solved
14:52:40 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:52:50 <dons> newArray_ for bare metal buffers with no initialisation
14:52:55 <bd_> fasta: I'm not even sure what you want. First you're concerned about performance, next you want it to crash on uninitialized access?
14:52:57 <Cale> What's the runtime complexity of allocation of n bytes at the OS level?
14:53:23 <Cale> (In the worst case)
14:53:49 <dons> memset and friends to fill them quickly.
14:53:55 <bd_> dons: newArray_ initializes to undefined/0 I thought? Or does it leave things undefined in unboxed?
14:53:56 <Botje> worst case: your memory manager starts thrashing around and recollecting bits & pieces
14:54:09 <bd_> Cale: O(n) for swapping? :)
14:54:16 <dons> its garbage values if its a UArray
14:54:18 <dons> or IOUArray
14:54:20 <bd_> ah
14:54:24 <dons> i.e. whatever was in memory
14:54:25 <fasta> dons: newArray_ within runSTArray is constant time?
14:54:33 <JohnnyL> ARe there any large projects (or medium sized (would you believe small?)) that have a tutorial description of each line/function.
14:54:45 <Cale> Indeed, I would think that it would be O(n) at least, because if memory is horribly fragmented, it'll have to move things out of the way.
14:54:51 <bd_> fasta: how spase is the array you're allocating, btw?
14:54:56 <Cale> Maybe O(n) things :)
14:55:00 <fasta> bd_: not relevant.
14:55:08 <bd_> fasta: ... it's very relevant
14:55:10 <Cale> It's very relevant.
14:55:10 <ulfdoz> How can I access a darcs repo via ssh?
14:55:20 <bd_> Cale: If you have sufficient virtual memory free, you can just allocate a chunk of pages
14:55:27 <fasta> bd_: no, it's not.
14:55:50 <bd_> fasta: ... why isn't it? There may be a much more efficient way than to build a huge array you're only going to use a dozen elements from.
14:55:53 <dons> and you can always call, memset p 0 (fromIntegral n)
14:56:07 <dons> to fill the Ptr you get back from a Foreign.Marshall.Array
14:56:23 <Cale> (like for example, building a Map)
14:56:36 <dons> ulfdoz: darcs get you@host:/path/to/repo
14:56:54 <ulfdoz> manpage should mention this.
14:57:01 <fasta> dons: doesn't memset 0 already initialize to 0?
14:57:04 <dons> fasta, STUArray or STArray?
14:57:25 <fasta> dons: Currently STArray, but I can change to STUArray easily.
14:57:39 <fasta> dons: I don't care what it's named. :)
14:57:40 <dons> if you care about speed, you should.
14:57:47 <dons> STArray leaves things undefined, STUArray is bare metal
14:58:05 <dons> both should only allocate the space needed on newArray_
14:58:27 <fasta> dons: Ok, and what happens when I convert an STUArray to an UArray and reference an unset index?
14:58:49 <bd_> fasta: garbage data
14:58:52 <dons> you'll get back whatever was in that slot
14:59:06 <dons> for an STArray, you get back bottom
14:59:06 <fasta> dons: fantastic
14:59:21 <fasta> Then STUarray were the magic words I needed to hear.
14:59:35 <Cale> You can't put just anything in an STUArray though
14:59:37 <dons> sounds like you want an IntMap though ;)
15:00:07 <fasta> dons: semantically it's an IntMap, theoretically it's faster.
15:00:07 <Cale> Or just Data.Map, and wait for the compiler to get good enough to specialise it for you :)
15:00:24 <Cale> (that's really not so far off :)
15:00:31 <fasta> dons: I want to give an example of how to correctly implement a specific algorithm.
15:00:54 <fasta> dons: it has been implemented a lot of times, but everyone isn't using this "trick".
15:01:32 <fasta> dons: this could of course be, because it's faster in that way or for other reasons, but I think it's because they don't know how the original algorithms works.
15:01:43 <Cale> Which algorithm?
15:02:07 <fasta> algorithm*
15:02:13 <dons> wht's the key and element type of your array though?
15:02:18 <dons> Int -> Int ?
15:02:56 <fasta> dons: Int -> (Int, Int), but I can change it to Int -> Int, relatively easy.
15:04:27 <fasta> Cale: Is soft-O something other people use too?
15:04:42 <Cale> fasta: yeah
15:04:53 <fasta> Cale: I already found a page describing it.
15:05:03 <fasta> I vaguely remember it.
15:05:43 <Cale> it's written as Õ, if you can see that :)
15:05:52 <Cale> (an O with a tilde)
15:06:03 <monochrom> Perl and Python programmers use "sloppy O".
15:06:19 <monochrom> "sloppy O" means you identify O(n) with O(1).
15:06:30 <Cale> heh
15:06:36 <fasta> Cale: yes, I could see it.
15:07:04 <monochrom> E.g., "hash table is O(1)".  They mean O(n) ie sloppy-O(n) = sloppy-O(1).
15:07:22 <Cale> haha
15:07:31 <fasta> heh
15:08:21 <fasta> I suppose they also use the sloppy programming style as popularized by Mr. Wall?
15:08:31 <monochrom> Their excuse: "oh but on average it's O(1)"
15:09:13 <monochrom> OK, the average is more interesting, I agree.  On average, you cause your hash table to become so big that you get into disk swapping, which means O(1,000,000).
15:09:19 <Cale> maybe they just identify average case with worst case?
15:09:33 <chessguy> Cale, i don't understand why it's a problem that terminals is a list of Gene
15:10:17 <Cale> chessguy: it's not, it's just that the type signature you gave indicated that the value should have Programs in it.
15:10:53 <chessguy> Cale, the returned type is a Program, which is a Tree of Genes
15:11:18 <Cale> ah, see, I didn't know that :)
15:11:32 <chessguy> oh, i forgot to include that in the paste
15:11:34 <chessguy> sorry
15:11:59 <chessguy> i cut too much in making a test case
15:12:27 <Cale> in that case, your only problem is in swapping the monad and tree structure
15:12:43 <Cale> You can do that in general (for any monad), and so you should write it that way :)
15:13:17 <chessguy> Cale, in general?
15:13:44 <Cale> sequenceTree :: (Monad m) => Tree (m a) -> m (Tree a)
15:14:01 <chessguy> well, doesn't Tree derive that?
15:14:14 * monochrom 's eyes come out
15:14:25 <Saizan> poll: a multichannel hpaste should enforce annotations to be announced on the same channel as their main paste? (if silent is not checked)
15:14:35 * chessguy accidentally steps on one of monochrom's eyes
15:15:07 <chessguy> Cale, hmm
15:15:13 <Cale> not automatically.
15:15:14 <monochrom> Saizan: I go for "default to"
15:15:15 <chessguy> ?hoogle sequenceTree
15:15:15 <lambdabot> No matches found
15:15:27 <Cale> Which Tree are you using?
15:15:30 <Cale> the one in the libraries?
15:15:31 <chessguy> Data.Tree
15:15:35 <Cale> Is it 6.6?
15:15:37 <chessguy> yes
15:15:41 <monochrom> "you should write it" means it's not on hoogle yet :)
15:15:48 <Cale> Traversable Tree
15:16:01 <monochrom> Ah, the Traversibles.
15:16:05 <Cale> So import Data.Traversable, and just use sequence from there :)
15:16:07 <dibblego> the prognosis of a disease is a 50% chance of survival; you and one other person has the disease; the other person dies - does your chance of survival increase? (what is the problem called?)
15:16:34 <chessguy> i'm not seeing how i would use sequence
15:16:49 <monochrom> There is a Moggi paper on that. :)
15:16:57 <dibblego> monochrom, link?
15:17:05 <xic> cool, my haskell blog engine sort of works!
15:17:08 <monochrom> I'm referring to the Traversables.
15:17:08 <shapr> yay!
15:17:09 <chessguy> ?google Moggi sequence
15:17:11 <lambdabot> http://cat.inist.fr/?aModele=afficheN&cpsidt=8282330
15:17:11 <lambdabot> Title: CAT.INIST.FR
15:17:15 <chessguy> ?google Moggi Traversable
15:17:16 <shapr> xic: Got sources? demo?
15:17:17 <lambdabot> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/iterator.pdf
15:17:34 <xic> shapr: no, not yet
15:17:45 <shapr> I'd like to see it when you get something.
15:17:55 <chessguy> doesn't look like it
15:18:00 <xic> shapr: ok, but it's using my own haskell web framework
15:18:01 <monochrom> As for the probability question, that's something along the line of some gambler misconception.
15:18:24 <shapr> xic: That's okay, I'd still like to see it.
15:18:27 <chessguy> ?hoogle Data.Traversable.sequence
15:18:27 <lambdabot> No matches, try a more general search
15:18:28 <dibblego> monochrom, yeah, I'm sure I've heard something like it before
15:18:33 <chessguy> ?hoogle sequence
15:18:34 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
15:18:34 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
15:18:34 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
15:18:46 <monochrom> Perhaps you can bet on "Gambler's Paradox"
15:18:55 <monochrom> ("bet", hehehe!)
15:19:00 * dibblego takes a punt
15:19:02 <xic> shapr: one thing it's missing though is persistent state, so you lose all of your blog posts when you shutdown the server :O
15:19:38 <Cale> @type sequence
15:19:40 <lambdabot>     Ambiguous occurrence `sequence'
15:19:40 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
15:19:47 <Cale> @type Data.Traversable.sequence
15:19:50 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Traversable t, Monad m) => t (m a) -> m (t a)
15:20:00 <Cale> btw, that's going to get really annoying :)
15:20:02 <sorear> hi
15:20:09 <chessguy> Cale, how would i use that?
15:20:15 <monochrom> xic: "after you have finished reading this blog, it will self-destruct" :)
15:20:15 <chessguy> sorear, 'evening
15:20:23 <sorear> Cale: @tell, before anyone forgets :)
15:20:37 <Cale> t = Tree, m = YourStateMonad
15:20:55 <Cale> @tell dons @type sequence
15:20:56 <lambdabot> Consider it noted.
15:21:01 <monochrom> It's a very useful feature in Inspector Gadgets :)
15:21:03 <dons> ah
15:21:04 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
15:21:19 <monochrom> Is someone spamming dons? :)
15:21:32 <chessguy> so it turns a tree of states into a state with a bunch of trees?
15:21:32 <dons> lookks like it
15:21:37 <sorear> @. paste print-notices
15:21:38 <lambdabot> Plugin `compose' failed with: IRCRaised Privledged commands cannot be composed
15:21:41 <sorear> aww
15:22:12 <Saizan> @help paste -- is there?
15:22:12 <lambdabot> paste. Paste page url
15:22:18 <Saizan> aah
15:22:27 <tibbe_> what does haskell's record syntax look like, googling and trying to crawl through haskell.org didn't help :/
15:22:43 <sorear> data Foo = Bar { baz :: Int, quuz :: !Double }
15:22:50 <tibbe_> it's something like: data Foo = Foo { name :: String } right?
15:22:51 <sorear> ^^^ complete example
15:22:53 <tibbe> thanks
15:23:09 <sorear> note the !Double - can be hard to remeber
15:23:18 <tibbe> for a newbie it must be frustrating that that particular piece of syntax is hard to find
15:23:29 <tibbe> for the strict field right?
15:23:38 <tibbe> most tutorials I found on google didn't include it
15:23:57 <sorear> tibbe: yes
15:23:58 <Saizan> yaht does
15:24:06 <ddarius> @oldwiki UsingRecords
15:24:06 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
15:24:13 <sorear> (don't use it too often, but when you need it it is frustrating)
15:24:20 <dons> the !Double isn't required though, of course
15:24:30 <dons> that's a separate issue entirely
15:24:40 <tibbe> Saizan, the yaht link I got from google was a pdf so I didn't click
15:24:48 <dons> ddarius: so when are you going to write some popular tutorial/blog articles :-)
15:24:55 <tibbe> dons, I know but thanks :)
15:25:16 <dons> ddarius: on coming back to #haskell/Haskell?
15:25:23 <chessguy> Cale, i need to treat the leaves of the tree differently from the rest of the tree anyway
15:26:01 <ddarius> dons: A tutorial on coming back to #haskell?
15:26:44 <xic> man, i just got the strongest urge to look through my old junk, find the cd, and play some starcraft!
15:26:45 <dons> well, a haskell tutorial or many, is what i'm hinting at
15:26:55 <fasta> dons: how was that article you wrote on IRC + Haskell + monads + bot called?
15:27:04 <dons> ?go roll your own irc bot
15:27:06 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
15:27:06 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
15:27:23 <fasta> dons:  thanks
15:27:28 <chessguy> very cool tutorial by the way
15:27:35 <dons> cheers
15:27:37 <chessguy> i was just playing with that last night
15:27:41 <chessguy> again :)
15:27:46 <ddarius> dons: I have a bunch of informational pages on the old wiki.  Some are fairly popular.  I tend to promulgate my information more indirectly.
15:27:46 <sorear> who was it who was cabalizing UTF8.lhs?
15:28:07 <ddarius> dons: I'm formatting and revising a paper on category theory, but that won't be popular.
15:28:33 <ddarius> dons: I'm also thinking about an article perhaps for the Monad Reader that I should get around to writing.
15:28:46 <sorear> algebraic topology still makes more sense to me than category theory :(
15:29:00 <dons> ddarius: sounds good. TMR would be a good thing to contribute to
15:29:13 <Cale> sorear: I think that's natural
15:30:13 <ddarius> Something that I want to do or see done sooner or later is a HtDP like book using Haskell that displays typeful programming (among other Haskelly things).
15:30:28 <chessguy> Cale, would i still be able to use sequence if i need to treat the leaves of the tree differently?
15:30:36 <xic> dons: shouldn't the code in that ircbot tutorial use withSocketsDo?
15:30:42 <Cale> chessguy: differently how?
15:30:51 <ddarius> dons: What prompted that question by the way?
15:31:02 <chessguy> mm, let me right the rest of this function, and i'll show you
15:31:10 <Cale> chessguy: all it's going to do is run the actions on every one of the nodes and put the results in their place
15:32:29 <tibbe> where can I find an URL -> host, port, path parser?
15:32:44 <monochrom> Network.URI
15:33:01 <chessguy> sigh
15:33:07 <chessguy> vi is being belligerent
15:34:35 <siti> vi sucks :p
15:34:39 <dons> xic, yes, it should
15:34:49 <ddarius> siti: Indeed. Use vim.
15:34:49 <dons> ddarius: oh, just pondering the lack of content on reddit today :)
15:35:55 <chessguy> @pl \x -> ((fst x) == g)
15:35:56 <lambdabot> (g ==) . fst
15:36:34 * ddarius has never gone to reddit before and now thinks he'll stick to his previous behaviour.
15:36:54 <xic> is it good practice to write a >> implementation for your Monads?
15:37:33 <chessguy> ?src forM
15:37:33 <lambdabot> forM = flip mapM
15:37:38 <chessguy> that's what i thought
15:38:15 <Saizan> you should if you have something better than x >>= \_ -> f
15:38:20 <sjanssen> xic: I usually don't define it
15:38:38 <sorear> me neithne
15:39:03 <Cale> there's usually nothing better than x >> y = x >>= const y
15:39:46 * ddarius got bit by the fact that C# isn't lazy today.
15:39:51 <Cale> :)
15:41:07 <chessguy> ugh
15:41:38 <chessguy> Cale, suffice it to say that where i currently have:
15:41:39 <chessguy> randomProgram 0 = Node (chooseRand terminals) []
15:42:12 <chessguy> there will be a randomProgram n = Node (chooseRand list) someList
15:42:50 <Cale> I think I've determined another reddit rule: if it takes longer than 1 second for me to read your article name, it's getting modded down.
15:43:22 <dons> heh
15:43:22 <Cale> (unless it has some pretty good words in that first second anyway :)
15:43:25 <dons> that' a pretty good rule
15:43:52 <sieni> Cale: try to get "How much wood would a woodchuck chuck if a woodchuck could chuck wood?" as the top topc
15:43:55 <sieni> +i
15:44:14 <Cale> How much wood would a woodchuck chuck if a woodchuck could chuck monads?
15:44:20 * dibblego writes a post "How to increase the efficiency of your reading so that you can read *all* reddit titles in less than 1 second" :)
15:44:39 <Cale> See, it might be good, but probably modded down, because the "monads" is all the way at the end.
15:44:48 <dibblego> yeah, it's a bit annoying
15:45:02 <tibbe> @hoogle (a->b) -> (a->c) -> a -> (b,c)
15:45:03 <lambdabot> No matches, try a more general search
15:45:06 <Cale> dibblego: sorry, downmod for long title
15:45:08 <chessguy> ?remember Cale How much wood would a woodchuck chuck if a woodchuck could chuck monads?
15:45:08 <lambdabot> Done.
15:45:09 <Cale> hehe
15:46:25 <chessguy> Cale, pluse, i'm generating a tree. so i don't see how sequence could be used to do that
15:46:42 <oklopol> > 1
15:46:43 <lambdabot>  1
15:46:44 <sorear> tibbe: hoogle sucks, the function exists and is called (&&&)
15:46:52 <oklopol> > >
15:46:52 <lambdabot>  Parse error
15:46:55 <tibbe> sorear, ah, thanks
15:47:01 <tibbe> sorear, in Arrows?
15:47:02 <sorear> > (+1) &&& (*2) $ 10
15:47:03 <lambdabot>  (11,20)
15:47:06 <oklopol> > (>4)
15:47:07 <lambdabot>  <Integer -> Bool>
15:47:20 <mbishop> We need a new redditalike just for programming, and banning all the trolls and losers
15:47:21 <oklopol> &&& ?
15:47:23 <JohnnyL> does haskell use a stack or an inline counter?
15:47:33 <sorear> tibbe: it is generalized over arrows, but like ap it is often used at (->)
15:47:35 <dons> hmm?
15:47:35 <sorear> JohnnyL: ???
15:47:42 <oklopol> > 1 &&& 2
15:47:42 <lambdabot>   add an instance declaration for (Show (a b (c, c')))
15:47:47 <dons> a stack and a heap, in the runtime. but what do you mean by 'inline counter'?
15:47:48 <sorear> JohnnyL: haskell has no implementation
15:47:57 <oklopol> > (&&&) 1 1 1
15:47:58 <lambdabot>   add an instance declaration for (Num (b -> c'))
15:47:58 <dons> sorear: not sure that's helpful :P
15:48:01 <oklopol> > (&&&) 1 1 1 1
15:48:02 <lambdabot>  Couldn't match expected type `t1 -> t'
15:48:03 <oklopol> :D
15:48:12 <sorear> JohnnyL: haskell has many implentations, none is endorsed my the standard
15:48:19 <allbery_b> :t (&&&)
15:48:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:48:22 <JohnnyL> sorear, it'd make sense if distributions used a counter, especailly given that it's highly recursive.
15:48:27 <allbery_b> how's that for useless? :)
15:48:28 <chessguy> ohh, wait!
15:48:36 <chessguy> can i use unfoldTree or something to generate a tree?
15:48:57 <dons> JohnnyL: recursion is compiled into a jmp instruction, is that what you wanted to know?
15:49:09 <dons> so you won't blow your stack with tail recursive code
15:49:26 <JohnnyL> dons, ok i sorta figured that , i just wanted to validate.
15:49:27 <JohnnyL> thanks
15:50:13 <xic> dons: how does ghc emit the jmp instruction when compilation is done through c?
15:50:30 <sorear> NCG! NCG! NCG! :p
15:50:39 <allbery_b> evil mangler? :)
15:50:41 <sorear> seriously, it emits 'goto'
15:50:53 <sorear> yeah, COWER!!
15:50:57 <xic> goto can't jump between functions
15:50:58 <rahikkala> NCG?
15:51:16 <siti> gotos rock :)
15:51:21 <chessguy> ?instances Traversable
15:51:22 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
15:51:28 <siti> I think haskell should have them
15:51:28 <chessguy> ?instances-importing Traversable
15:51:29 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
15:51:36 <dons> the output of gcc is postprocessed
15:51:49 <dons> to fix it
15:52:14 <xic> dons: which output, the object files?
15:52:21 <dons> the asm
15:52:23 <tibbe> @hoogle [a->b] -> a -> [b]
15:52:24 <lambdabot> No matches, try a more general search
15:52:29 <tibbe> bah!
15:52:34 <tibbe> it's a reverse map
15:52:36 <rahikkala> sequence
15:52:37 <sorear> xic: using a perl script!
15:52:45 <tibbe> :t sequence
15:52:48 <lambdabot>     Ambiguous occurrence `sequence'
15:52:48 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
15:52:54 <allbery_b> appropriate for an evil mangler, no? :)
15:52:55 <sorear> ha ha
15:53:03 <tibbe> :t Control.Monad.sequence
15:53:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:53:20 <xic> dons: hm... i guess this explains why ghc is so slow to compile things :|
15:54:18 <tibbe> > sequence [const "hi", const "there"] "foo"
15:54:37 <sorear> ha ha
15:54:49 <tibbe> what's up with lambdabot?
15:54:52 <rahikkala> tibbe: Well, that is, either sequence, or \v -> map ($ v)
15:54:54 <sorear> > Monad.sequence [ const "hi", const "there" ] "foo"
15:54:55 <lambdabot>   Not in scope: `Monad.sequence'
15:55:01 <rahikkala> > map ($ 0) [(+1), id, subtract 1]
15:55:01 <sorear> wtf!?
15:55:02 <lambdabot>  [1,0,-1]
15:55:06 <sorear> > Control.Monad.sequence [ const "hi", const "there" ] "foo"
15:55:07 <lambdabot>  ["hi","there"]
15:55:13 <dons> sorear: Monad.* has never been in scope.
15:55:44 <rahikkala> dons: Then how did that work before?
15:55:59 <sorear> dons: how did > sequence work pre-hier-mods?
15:56:16 <sorear> oh duh
15:56:20 <allbery_b> previously sequence was unambiguously Cntrol.Monad.sequence.  with 6.6 there are a few more versions of sequence in scope now
15:56:23 <sorear> > Prelude.sequence [ const "hi", const "there" ] "foo"
15:56:25 <lambdabot>  ["hi","there"]
15:56:34 <allbery_b> hm, or that
15:59:44 <augustss> > ["hi", "there"]
15:59:45 <lambdabot>  ["hi","there"]
15:59:59 <Cale> > words "hi there"
16:00:00 <lambdabot>  ["hi","there"]
16:00:18 <augustss> > lines "hi\nthere"
16:00:19 <lambdabot>  ["hi","there"]
16:00:26 <sorear> @msg #haskell  ["hi","there"]
16:00:26 <lambdabot> ["hi","there"]
16:00:52 <sjanssen> am I the only one that read this post's title as an implicit dig at Paul Graham? http://programming.reddit.com/info/14fmn/comments
16:00:54 <lambdabot> Title: Upvote if you want to know how Paul Graham&#39;s Arc is coming along (reddit.com ...
16:00:57 <augustss> > takeWhile (/='t') "hithere"
16:00:59 <lambdabot>  "hi"
16:01:04 <augustss> oops
16:01:29 <xic> do i remember correctly that someone was working on a haskell rss aggregator?
16:01:34 <sorear> Cale
16:01:37 <Cale> sjanssen: not at all
16:01:41 <sorear> @where HRSS
16:01:41 <lambdabot> I know nothing about hrss.
16:01:43 <xic> no, not Cale's, i mean a gtk2hs one
16:01:51 <augustss> > span (/='t') "hithere"
16:01:52 <lambdabot>  ("hi","there")
16:01:56 <chessguy> > unfoldTree (\x -> (x,[x])) 3
16:01:56 <Cale> I'm barely "working" on that :)
16:01:57 <lambdabot>  Node {rootLabel = 3, subForest = [Node {rootLabel = 3, subForest = [Node {ro...
16:02:01 <augustss> close ;)
16:02:06 <Cale> I wrote it to learn HXT
16:02:17 <Cale> I probably should work on it.
16:03:14 <Cale> sjanssen: wow, 531 points. That's one which I modded down. :)
16:04:20 * sorear often gets Paul and Billy Graham confused ... how embarrasing
16:04:57 <chessguy> i don't get it
16:05:07 <chessguy> how can i use unfoldTree to generate a non-infinite tree?
16:05:22 <sorear> > typeOf unfoldTree
16:05:23 <lambdabot>  Add a type signature
16:05:25 <SamB> @hoogle unfoldTree
16:05:26 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
16:05:26 <lambdabot> Data.Tree.unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
16:05:26 <lambdabot> Data.Tree.unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
16:05:26 <sjanssen> I assumed that the article title was poking fun at arc's vaporware status
16:05:43 <SamB> chessguy: make the [b] be []
16:05:46 <ddarius> > unfoldTree (\x -> (x,[])) 3
16:05:47 <lambdabot>  Node {rootLabel = 3, subForest = []}
16:05:47 * Cale often gets Paul Graham confused with someone who writes using poor analogies to things he clearly doesn't know much about. Oh wait.
16:05:47 <chessguy> oh
16:06:03 <sjanssen> Cale: :)
16:06:08 <chessguy> hmm
16:06:20 <siti> who is paul graham?
16:06:29 <bos> a millionaire blowhard.
16:06:32 <ddarius> paulgraham.com
16:06:33 <sorear> I think he's a preacher
16:06:35 <siti> lol
16:06:35 <chessguy> Cale, you don't like his Blub article?
16:06:53 <chessguy> Paul Graham is the lisp proponent. Billy and Franklin are the preachers
16:07:01 <siti> ok
16:07:03 <Cale> chessguy: The one which he uses to justify his idea that lisp is better than any other possible language?
16:07:23 <chessguy> yes, i found it entertaining, at least
16:07:27 <Cale> hehe
16:07:34 * mbishop still likes using lisp...well, scheme anyway
16:07:35 <ddarius> Lisp isn't bettor than any other possible language?!
16:07:47 <sorear> @quote 1866
16:07:48 <lambdabot> xic says: and i imagine that lisp hasn't changed since it's creation in 1866
16:08:15 <chessguy> so, how would i use unfoldTree to create an interesting tree?
16:08:21 <oklopol> what's wrong with
16:08:21 <oklopol> subst :: String -> String
16:08:21 <oklopol> subst s = map s (\a -> case a of 'a' -> 'b'; 'b' -> 'a')
16:08:30 <mbishop> I thought lisp was created in 1066, at the Battle of Lispings :)
16:08:39 <sorear> oklopol: flip the arguments to map
16:08:40 <allbery_b> @ty map
16:08:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:08:44 <Cale> What else happened in 1866 which is identified with the creation of lisp?
16:08:47 <oklopol> :P
16:08:52 <sorear> subst s = map (\a -> case a of 'a' -> 'b'; 'b' -> 'a') s
16:08:55 <sorear> BUT
16:09:03 <sorear> > let subst s = map (\a -> case a of 'a' -> 'b'; 'b' -> 'a') s in subst "aabaa"
16:09:03 <oklopol> ?
16:09:04 <lambdabot>  "bbabb"
16:09:05 <Cale> I've heard people say that Gödel invented lisp due to Gödel numbering.
16:09:08 <sorear> > let subst s = map (\a -> case a of 'a' -> 'b'; 'b' -> 'a') s in subst "aaxaa"
16:09:10 <lambdabot>   Non-exhaustive patterns in case
16:09:15 <oklopol> i know
16:09:19 <ddarius> > unfoldTree (\n -> (n,if n < 10 then [n+1] else [])) 0
16:09:20 <lambdabot>  Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {ro...
16:09:25 <Cale> Which is a pretty stupendously ridiculous claim :)
16:09:27 <sorear> > let subst s = map (\a -> case a of 'a' -> 'b'; 'b' -> 'a'; x -> x) s in subst "aaxaa"  -- oklopol I think you want this
16:09:28 <lambdabot>  "bbxbb"
16:10:11 <svref> what's the name of the division-like operation where 45.4 ??? 15.0 -> 4
16:10:17 <chessguy> ddarius, a very imbalanced tree :)
16:10:39 <oklopol> i don't, actually, i'm doing a more complicated thing, i can't figure the error msg's out it seems :P
16:10:43 <chessguy> though i like the end:
16:10:46 <chessguy> ...[Node {rootLabel = 10, subForest = []}]}]}]}]}]}]}]}]}]}]}
16:10:46 <dons> > ceiling (45.4 / 15)
16:10:47 <lambdabot>  4
16:10:51 <oklopol> thanks though
16:11:33 <svref> dons: can never spell that well enough to remember it.  ;)
16:12:47 <sorear> @users
16:12:47 <lambdabot> Maximum users seen in #haskell: 328, currently: 309 (94.2%), active: 50 (16.2%)
16:12:52 <sorear> ooh!
16:13:02 <sorear> new high water, even!
16:13:19 * sorear goes to check and/or update the @wiki
16:13:20 <dons> oh cool
16:13:27 <dons> sorear: yeah, update please
16:13:39 <chessguy> define "new"
16:13:48 <ddarius> You haven't taught the bot to automatically do that?
16:13:49 <bos> world domination is at hand, if only we can escape from IO!
16:13:54 <chessguy> it's been that high at least most of today
16:14:14 <dons> to update the wiki. no. does anyone know of mediawiki libraries
16:14:19 <dons> for writing bots to update pages?
16:14:27 <dons> i've got a few uses for that kind of thing
16:14:34 <dons> (i.e. publishing the HWN automagi call)
16:15:27 <sorear> dons: do you know why the spanish haskellers defected?
16:16:38 <mbishop> I haven't used haskell for much lately, too much IO aggrevation, just use ocaml instead :\
16:16:40 <sorear> (spanish)Canal En espanol para latinoamerica En la red Undernet eu.undernet.org -- I don't speak the language but it sure doesn't sound like "#haskell.es at freenode"
16:17:07 * sorear doesn't know ocaml
16:19:04 <chessguy> "Spanish channel for latin-americans in the Undernet network eu.undernet.org"
16:19:24 <dons> i don't know. not sure they defected, i think it might just be a fork.
16:19:28 <JohnnyL> http://www.pastebin.ca/356289
16:19:35 <dons> i.e. they already had a channel going over there, and a ocmmunity
16:19:41 <ddarius> @paste
16:19:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:19:42 <chessguy> araujo, ping
16:19:52 * araujo looks in
16:19:55 <araujo> chessguy, pong
16:19:55 <dons> mbishop: trolling eh? ;)
16:20:11 <chessguy> araujo, estamos hablando de tu y tus amigos :)
16:20:21 <araujo> chessguy, :-)
16:20:29 <chessguy> sabes algo de esto?
16:20:33 <araujo> chessguy, anything good at all? :-)
16:20:34 <araujo> mmm...
16:20:45 <ddarius> Riastradh finally decide to stick to Scheme?
16:20:52 <sorear> JohnnyL: why didn't you use hpaste?  we need to know your motivation so that we can eliminate it!
16:20:55 <araujo> chessguy, about what?
16:21:11 <mbishop> dons: indeed :[
16:21:16 <JohnnyL> sorear, I'll use it next time.
16:21:23 <chessguy> araujo, el wiki dice: Canal En espanol para latinoamerica En la red Undernet eu.undernet.org -- I don't speak the language but it sure doesn't sound like "#haskell.es at freenode"
16:21:28 <chessguy> err
16:21:34 <chessguy> sin el ingles :)
16:21:39 <araujo> ooh..
16:21:43 <araujo> that's wrong
16:21:46 * araujo checks
16:21:55 <JohnnyL> sorear, how functional of you.
16:21:56 <JohnnyL> hehe
16:22:11 <mbishop> I just don't see haskell being as useful for me, probably because I don't totally understand the IO monad, or monads in general heh
16:22:23 <araujo> mmm...
16:22:27 <mbishop> I know what monads are...just not why they would be useful...I like my side effects :P
16:22:37 * araujo checks how added such a thing
16:22:39 <dons> mbishop: are you serious? IO is just like IO anywhere else, just that we try to understand its effect precisely
16:22:44 <dons> but you use it just the same.
16:22:50 <chessguy> araujo, hay mucha gente alla? sabes?
16:22:58 <JohnnyL> iter n 1, seems to hit a literal, i would think that this gets evaluted first, but logically it doesn't make sense that it does depending on the code. My question is what's the order of evaluations of that example.
16:23:08 <sorear> JohnnyL: iter n 1 is a call
16:23:10 <sorear> oh
16:23:28 <sorear> fac 3 -->
16:23:38 <sorear> iter 3 1 -->
16:23:51 <sorear> (3 is forced by pattern matching) -->
16:24:05 <dons> and anyway, IO is first class in Haskell, you can do things like: sequence_ . reverse $ [putChar 'x', putChar 'y']
16:24:09 <sorear> iter (3-1) (1*3) -->
16:24:10 <mbishop> dons: Perhaps? like I said, my lack of understanding is probably why I get frustrated with doing IO in haskell, always have type errors I don't know how to fix, because I don't understand it heh
16:24:11 <dons> who wouldn't wnat that kind of control :)
16:24:13 <sorear> (3-1 is forced by pattern matching) -->
16:24:17 <sorear> iter 2 (1*3) -->
16:24:35 <sorear> iter (2-1) ((1*3)*2) -->
16:24:38 <sorear> (2-1 is forced by pattern matching) -->
16:24:44 <JohnnyL> oh ok, i see it now.
16:24:46 <sorear> iter 1 ((1*3)*2) -->
16:24:47 <JohnnyL> thanks sorear!
16:24:53 * JohnnyL big hugs to sorear!
16:24:54 <JohnnyL> :)
16:26:11 <jcreigh> hmm, so it's possible to write:
16:26:15 <jcreigh> forceInt 0 = 0
16:26:19 <jcreigh> forceInt x = x
16:26:39 <jcreigh> ???
16:26:54 <xic> Cale: does HXT support xml namespaces?
16:27:09 <bd_> jcreigh: that's the same as forceInt x = x :)
16:27:37 <mbishop> dons: not sure if it's even possible, but could IO (and all monads, really) be abstracted away, and when you do regular printing etc, it would not bother you with types, and handle all the IO stuff on the inside?
16:27:53 <jcreigh> bd_: right, wouldn't there be a difference with forceInt <some huge thunk>?
16:27:55 <sorear> jcreigh: forceInt x will force x, but only when forceInt x is itself evaluated, so it won't help
16:28:00 <chessguy> sorear, araujo is looking into it
16:28:21 <xic> mbishop: haskell already does that sort of with type inference
16:29:16 <mbishop> xic: indeed, but I wish there wasn't a distinct type for IO, I mean I imagine there would need to be...but if it acted like their wasn't, and just handled the conversion to from IO for you
16:30:01 <jcreigh> oh, does a pattern match like "x" force evaluation just as much as a pattern match like "0"? Not, as sorear points out, that it will make much of a difference.
16:30:12 <sorear> jcreigh: no
16:30:18 <sorear> @where report
16:30:18 <lambdabot> http://www.haskell.org/onlinereport/
16:30:42 <mbishop> to/from*
16:30:44 <sorear> basically there are two kinds of patters, refutable and irrefutable
16:30:55 <mbishop> anyway, my head hurts, I'm going play mindless video games or something :P
16:31:23 <sorear> refutable patterns force evaluation, examples : 1, (x : xs), x@refutable_pattern, etc
16:31:36 <qwr> mbishop: you can write almost all you're code in IO if you wish - with similar result to allowing side effects everywhere
16:31:38 <sorear> irrefutable patterns dont: x, ~any_pattern
16:31:45 <sorear> be warned
16:31:58 <sorear> you are going into deep confusing territory
16:32:22 <sorear> even the people who wrote Control.Monad.State got an irrefutable annotation backward
16:32:40 <dons> mbishop: like 'interact' ?
16:32:49 <dons> main = interact reverse  --- the 'tac' program
16:32:55 <bd_> f 0 = 0; f x = x <-- f _|_ = _|_, since the first match is irrefutable. g x = x <-- g _|_ = _|_ since it's just identity. They're equally strict :)
16:33:20 <mbishop> dons: Hmm, I never did look at what interact does heh
16:33:31 <sorear> interact is fun
16:34:57 <sorear> like 10 messages on the entire mailing list (of which something like 7 were from yhc buildbots), all of 2 patches in my collection of pulls, even the channel is virtually silent
16:39:13 <ddarius> jcreigh: forceInt 0 x = x;forceInt _ x = x
16:40:14 <jcreigh> ddarius: why two arguments?
16:40:49 <sm-afk> that seems an interesting idea for haskell newbies.. start them off being always in the IO monad, hiding any other possibility
16:41:19 <sorear> <sm-afk> seems oxymoronic :p
16:41:28 <jcreigh> sm: naw, functions are cooler.
16:41:30 <sm> is it ?
16:42:15 <sorear> @where hlist
16:42:15 <lambdabot> http://homepages.cwi.nl/~ralf/HList
16:42:16 <sm> haskellscript.. a gentle half-way step
16:42:37 <jcreigh> it's called "Ruby" :)
16:44:01 <sm> an implicit "module Main where main :: IO (); main =" at the top..
16:44:57 <ddarius> jcreigh: For the same reason seq has two arguments.
16:45:00 <sm> tell people it's just like a sh/perl/python/ruby script, only you get to use the awesome haskell function library..
16:45:50 <sorear> sm: the prelude isn't that awesome :(
16:46:08 <jcreigh> gah, no. Haskell is *not* an imperative programming language. Everything interesting and worth learning in Haskell has nothing to do with the IO monad. (As far as I can tell, anyway. It's nice that actions are first-class, so you can compose them and whatnot, but you can do that in, eg, scheme, too with side effects)
16:46:56 <jcreigh> ddarius: ah, good point.
16:48:48 <sm> most haskell newbies have an awful lot to learn before being productive.. I'm thinking it wouldn't hurt to have a partial haskell you can master before climbing higher
16:49:24 <sm> people argue that haskell can be a good imperative language, so why not let people start out that way
16:49:37 <araujo> mmm...
16:49:48 <araujo> sorear, this all looks more like a confusion from one user
16:50:06 <Gwern> sm: like the helium compiler?
16:50:07 <siti> I enjoyed the haskell tutorial for c programmers
16:50:09 <araujo> sorear, the other channel doesn't look about Haskell at all
16:50:11 <Gwern> I hear its good for beginners
16:50:12 <bos> sm: because then they won't take the trouble to do the hard but rewarding work?
16:50:38 <araujo> sorear, so don't worry, you know the official mafia is on #haskell.es ;-)
16:50:53 <sm> bos, I don't agree.. once they get hooked, they'll do the work
16:51:07 * araujo will nevertheless try to avoid dividing our community
16:51:58 * ddarius considers rereading the QuotesPage.  It always gives him a laugh.
16:52:10 <dons> araujo: so what's the story behind the split channel?
16:52:18 <dons> is the new #haskell.es a haskell channel?
16:52:33 <Gwern> speaking of beginners, why is it that when you go x:xs where x = "foo" and xs = "bar, you get ["foo", "bar"]? shouldn't it be ["foobar"] since it's 'f':'o':'o'....:[]?
16:52:40 <dons> if not, it shouldn't be listed on the IRC page, imo. do we know who those guys are?
16:52:58 <dons> though already the russians have moved to their own jabber server
16:53:08 <Saizan> > "foo":"bar" -- type error
16:53:09 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
16:53:18 <dons> > "foo":"bar":[]
16:53:20 <lambdabot>  ["foo","bar"]
16:53:28 <dons> :t (:)
16:53:30 <dons> is why ^^
16:53:30 <lambdabot> forall a. a -> [a] -> [a]
16:53:30 <araujo> dons, it is called #haskell on other server. It has less people than our channel here; most of them look like bots; and i don't know anybody there but its founder; who is somebody that visited us on #haskell.es a few months ago
16:53:42 <dons> ok.
16:53:46 <araujo> dons, i will try to know his reasons about this.
16:54:00 <dons> maybe we should place that channel in less prominent position on the page then
16:54:06 <dons> since #haskell.es is the official channel
16:54:07 <araujo> dons, Yes.
16:54:14 <araujo> dons, i am doing that atm.
16:54:15 <dons> the other #haskell.es should go down with the list of alternative channels
16:54:20 <dons> like #perl6 and so on
16:54:22 <araujo> dons, i will actually remove it until i talk to him
16:54:26 <dons> ok.
16:57:24 <augustss> jcreigh: It's not true that you can use first class actions as easily in Scheme as in Haskell.  You have to either thunk or quote the action in Scheme to stop it from being executed.  And the you need to force or eval it.  So yes, it can be done in Scheme, but it's more elegant in Haskell.
16:59:29 <xic> augustss: you think that fail should be removed from Monad?
16:59:40 <augustss> Absolutly!
17:00:02 <araujo> Done.
17:00:06 <araujo> Ok, hot dog time
17:00:12 * araujo back in a sec
17:00:17 <Pseudonym> My opinion on whether or not fail should be in Monad changes weekly.
17:00:53 <xic> who's idea was it to put it in there in the first place?
17:00:59 <augustss> The reasons for including it fail are very weak, imo.
17:01:03 <Pseudonym> The 98 committee, I think.
17:01:03 <sorear> araujo: it's also on the main @wiki IRC_channel
17:01:16 <Pseudonym> It was introduced along with do-notation.
17:01:16 <augustss> xic: I think the idea came from John Hughes.
17:01:30 * sorear searches the wiki for other occurences of undernet
17:01:31 <augustss> Pseudonym: no, fail came after
17:01:32 <allbery_b> blame the removal of monadzero and monad comprehensions!
17:01:35 <xic> that bugger has caused us nothing but trouble
17:01:52 <ddarius> If you don't know what Just x <- foo translates to then the case is very weak.
17:01:55 <augustss> I say, use MonadZero when you need fail.
17:02:23 <ddarius> But if you do, then I'm with Pseudonym and change my mind upon occasion but tend to lean toward not having it.
17:03:14 <augustss> I think it's just ugly.  No mathematical justification.
17:03:40 <SamB> I sorta like having it, but if someone can put it somewhere *else* without the compiler authors committing ritual suicide, I'm all for it ;-)
17:03:59 <Pseudonym> Right.
17:04:12 <augustss> It worked fine when it was in MonadZero.  It was just some error messages that were worse.
17:04:28 <SamB> augustss: dynamic or static error messages?
17:04:38 <Pseudonym> I find it very useful to use refutable patterns when I happen to know that it won't fail.
17:04:41 <augustss> Dynamic.
17:04:41 <Pseudonym> Or shouldn't. :-)
17:04:46 <SamB> augustss: nasty.
17:04:52 * SamB was hoping static
17:05:22 <augustss> SamB: But I think they can be improved without such drastic measures.
17:05:36 <SamB> okay ;-)
17:11:21 <sorear> hiya!
17:13:20 <augustss> yo!
17:23:32 <dons> @tell dcoutts hehe, Per is submitting to the shootout now, https://alioth.debian.org/tracker/index.php?func=detail&aid=304476&group_id=30402&atid=411646
17:23:32 <lambdabot> Consider it noted.
17:25:12 <sorear> who is Per?
17:25:39 <sorear> I'm an idiot, right? ;)
17:26:06 <araujo> sorear, http://haskell.org/haskellwiki/IRC_channel ?
17:26:07 <lambdabot> Title: IRC channel - HaskellWiki
17:26:25 <sorear> araujo: that's the page I meant
17:26:25 <sorear> ?
17:26:52 <araujo> -_-
17:26:55 * araujo sighs
17:26:56 <sorear> araujo: in the Getting there section (at least)
17:27:22 * araujo doesn't like this now
17:27:46 <xic> what happens if i call a c function that segfaults?
17:28:04 <sorear> xxihaskell dies
17:28:05 <sorear> ?
17:28:22 <araujo> not anymore
17:28:23 <lucca> a fairy gets its wings
17:28:42 <araujo> thanks sorear
17:28:58 <sorear> according to Wikipedia, Per Gustafsson is a hockey player !?
17:30:08 <sjanssen> sorear: all I know about him is that he posted to the Haskell ml a while back
17:30:59 <sjanssen> looking for Haskell bit twiddling programs to compare against Erlang's new bit syntax
17:31:00 <sorear> google says he works on HiPE and Dialyser
17:31:15 <sorear> and yea wrote bit syntax
17:31:30 <ddarius> http://user.it.uu.se/~pergu/
17:31:32 <lambdabot> Title: Per Gustafsson's homepage
17:31:41 <sjanssen> sorear: I bet dons and dcoutts met him at PADL
17:31:41 <sorear> wow, JHC is a LOT faster with +RTS -M360M -RTS
17:31:58 <augustss> sorear: how is jhc coming along?
17:32:28 <sorear> augustss: coming along, eh?  well I'm not a jhc hacker yet, if that's what you mean :)
17:32:50 <sjanssen> sorear: so you finally managed to compile it?
17:33:21 <sorear> augustss, sjanssen: the April 1 + X-ray thing about "still compiling the standard prelude" is no longer funny for me.
17:34:27 <sorear> and jhc prints these cryptic progress messages like "-- Simplify-Init-Big-One"
17:34:48 <sjanssen> :)
17:34:49 <sorear>  4422 stefan    18   0  405m 341m 5700 R 24.5 90.5   3:58.27 jhc
17:35:03 * sjanssen reboots to try yet another kernel build
17:35:06 <sorear> WTF? I KNOW I USED +RTS -M360M !!
17:35:18 <sorear> 405M virt!?!?!?!?
17:35:44 <master_baiter> !??!?!?!?!?
17:36:11 <SamB> sorear: well, there is some overhead beyond what the RTS tracks
17:36:23 <SamB> 40MB extra isn't bad
17:36:46 <sorear> SamB: It'd be nice if that was documented
17:37:08 <sorear> SamB: I figured on 360MB for Jhc + 24MB for linux = 384MB total core
17:37:17 <siti> virt is diff from resdent :P
17:37:44 <SamB> does virt include code?
17:37:45 <siti> it looks like it's only using 341MB
17:37:47 <sorear>  4422 stefan    18   0  416m 352m 5776 D  7.6 93.2   4:52.27 jhc
17:37:53 <lucca> sorear: /proc/n/maps may have enlightening information
17:38:19 <siti> the best is gnome-system-monitor and show writeable memory :p
17:38:26 <sorear> siti: I only HAVE 384M of ram.  does it still surise you that not all of JHC is resident?
17:38:54 <lucca> siti: perhaps, but more of us have cat than have gnome ^_^
17:39:02 <siti> lol
17:39:21 <sorear> besides, gnome takes more than 384 MB of ram to run :)
17:39:22 <siti> only 384MB poor you :p
17:39:28 <siti> false
17:39:35 <sorear> cat only needs 382
17:39:50 <siti> it's about 120MB with no programs on 32bit...
17:39:59 <JohnnyL> what's the url for the prelude?
17:40:16 <JohnnyL> i want to find out the rec operator.
17:40:41 <siti> @hoogle +
17:40:42 <lambdabot> Prelude.(+) :: Num a => a -> a -> a
17:40:42 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
17:40:42 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
17:40:45 <sorear> @source Prelude
17:40:46 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:40:47 <siti> umm
17:40:50 <JohnnyL> thanks
17:40:59 <ddarius> @where report
17:40:59 <lambdabot> http://www.haskell.org/onlinereport/
17:41:13 <siti> it would be nice if it used links for the hoogle...
17:41:23 <sorear> JohnnyL: you freom ML?  talking abougt fix?
17:41:23 <sorear> @src fix
17:41:24 <lambdabot> fix f = let x = f x in x
17:42:10 <bd_> @src fixIO
17:42:10 <lambdabot> Source not found. Where did you learn to type?
17:42:21 <ddarius> @src IO mfix
17:42:21 <lambdabot> mfix = fixIO
17:42:25 <sorear> too bad you can't change RTS options at runtime
17:42:27 <ddarius> helpful
17:44:20 <JohnnyL> ok which page provides a search into haskell keywords?
17:44:25 <JohnnyL> @help rec
17:44:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:44:29 <JohnnyL> @help list
17:44:30 <lambdabot> list [module|command]
17:44:30 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:44:38 <sorear> JohnnyL: rec isn't a haskell keyworkd
17:44:39 <JohnnyL> show all rec
17:44:54 <wolverian> @where hoogle
17:44:54 <lambdabot> http://www.haskell.org/hoogle
17:44:55 <JohnnyL> i'm looking at the source to quake.
17:44:59 <JohnnyL> thanks
17:45:06 <sorear> quake is written in haskell!?
17:45:09 <sorear> omg
17:45:20 <sorear> I refust to believe we're that popular
17:45:29 <sorear> anyway, look at
17:45:34 <sorear> @where hasktags
17:45:35 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
17:45:46 <glguy> By using VMWare Server, I can run my openbsd instance as a service in the background, yea!
17:45:48 <allbery_b> rec sounds like ML to me
17:46:11 <ddarius> There is a rec keyword in arrow syntax if I remember correctly.
17:46:21 <wolverian> glguy, the vmware workstation 6 beta supports that too, btw
17:46:29 <wolverian> though what else it is missing I dunno.
17:46:32 <glguy> wolverian: is that free like vmware servr?
17:46:48 <JohnnyL> sorear, that looks cool thanks.
17:47:11 <wolverian> glguy, the beta is, but the license will expire at some point.
17:47:17 <wolverian> anyway, I didn't know server is free. :)
17:47:34 <glguy> server and player are free
17:47:42 <glguy> I'm a big fan of not paying for stuff I don't have to pay for
17:48:35 <JohnnyL> as compensation for help in haskell: www.youtube.com/watch?v=pqQh8wFLWOcc
17:49:23 <Cale> The url contained a malformed video id.
17:49:45 <JohnnyL> http://www.youtube.com/watch?v=pQh8wFLWOcc
17:49:56 <sorear> besides, most vieos I try too watch look like #**#*@82828**@*$#*##(@(@&!
17:51:06 <glguy> sorear: do you ever use aalib?
17:51:11 <siti> lol
17:54:06 <xic> man, i'm having a big problem understanding HXT
17:55:48 <xic> like the deep function, it's supposed to take a predicate, but it's argument has the form: Tree t => a (t b) (t b)
17:56:07 <xic> how am i supposed to create such a predicate?
18:03:59 <sorear> Heap exhausted;
18:03:59 <sorear> Current maximum heap size is 299999232 bytes (286 Mb);
18:03:59 <sorear> use `+RTS -M<size>' to increase it.
18:04:08 <sorear> ^^^ JHC is finally finished!
18:04:26 <sorear> (note, that according to ps and top jhc was using 500Mb at the time)
18:06:50 <ctkrohn> I take it jhc is a haskell compile targeted at fast binaries/slow compile time?
18:06:56 <ctkrohn> s/compile/compiler
18:06:58 <sorear> yes
18:07:30 <ctkrohn> any benchmarks showing how much faster it is than ghc?
18:07:46 <sorear> especially slow, since there are no working precompiled preludes :p
18:08:06 <ctkrohn> oh, I see... that could make it take a while...
18:08:20 <sorear> now tyring again with +RTS -sstderr -H340M -c -F1.1 -RTS
18:08:44 <sorear> it wants about twice as much RAM as I have with the default GC settings...
18:08:46 <int-e> sorear: what are you compiling?
18:08:52 <sorear> int-e: Data.Char
18:08:56 <sorear> int-e: hello world
18:09:08 * sorear > dinner, be back 1 h
18:09:21 <int-e> sorear: yes, because of the two-space garbage collector that ghc uses
18:14:36 <chessguy> ?seen Cale
18:14:36 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 25m 12s ago.
18:20:46 <Gwern> kind of curious: does haskell have a type for the natural numbers? I tried Natural, but that didn't work
18:22:10 <chessguy> ?instance Num
18:22:10 <lambdabot> Maybe you meant: instances instances-importing
18:22:13 <chessguy> ?instances Num
18:22:15 <lambdabot> Double, Float, Int, Integer
18:22:35 <chessguy> ?src Num
18:22:36 <lambdabot> class  (Eq a, Show a) => Num a  where
18:22:36 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:22:36 <lambdabot>     negate, abs, signum     :: a -> a
18:22:36 <lambdabot>     fromInteger             :: Integer -> a
18:22:41 <Gwern> hmm. what *is* the difference between Int and Integer anyway?
18:22:50 <chessguy> Gwern, the size
18:22:59 <chessguy> > maxBound :: Int
18:23:00 <lambdabot>  2147483647
18:23:00 <Gwern> in bytes, you mean?
18:23:05 <chessguy> correct
18:23:11 <allbery_b> Int is a machine word; Integer is unbounded
18:23:16 <Gwern> ah. I see.
18:23:17 <chessguy> Int is bounded, Integer isn't
18:23:44 <chessguy> i guess i shouldn't compare sizes of two things when one is unbounded
18:24:17 <chessguy> hey allbery_b, are you familiar with unfoldTreeM?
18:24:23 <allbery_b> nope
18:24:37 <chessguy> bah
18:24:48 <chessguy> i've almost got it worked out anyway :)
18:25:54 <hpaste>  chessguy pasted "almost worked out..." at http://hpaste.org/499
18:25:59 <chessguy> i'm building a random tree
18:26:21 <chessguy> the Int to be passed to randomProgram is the max depth of the tree
18:26:50 <chessguy> i stuck the type signature of unfoldTreeM in there too
18:26:56 <chessguy> i think for me it's going to be: unfoldTreeM :: (Int -> State ProgramState (Gene, [Int])) -> Int -> (Tree Gene)
18:28:39 <int-e> chessguy: looks reasonable (except for the missing monad in the result of course)
18:28:52 <chessguy> what?
18:28:54 <allbery_b> re naturals:  the "natural" representation would be a ranged type, which Haskell doesn't do well.
18:29:07 <chessguy> oh yes, the result is State GlobalState (Tree Gene)
18:29:20 <chessguy> aka State GlobalState Program
18:29:46 <chessguy> oops
18:30:01 <chessguy> i think for me it's going to be: unfoldTreeM :: (Int -> State GlobalState (Gene, [Int])) -> Int -> State GlobalState (Tree Gene)
18:30:11 <allbery_b> on the other hand, it's not that hard to define something like data Nat = Zero | Succ Nat
18:30:32 <allbery_b> (just a bit painful to specify literals...)
18:34:28 <e_e_coli> hello
18:34:32 <e_e_coli> working through SOE
18:34:59 <e_e_coli> had already installed WinHugs, but see that SOE web site has older version
18:35:02 <e_e_coli> of Hugs
18:35:10 <e_e_coli> with pre-instlled SOEGraphics, etc.
18:35:20 <e_e_coli> any way to get latest WinHugs to work with SOEGraohics?
18:36:25 <chessguy> > iter (1 :) []
18:36:26 <lambdabot>   Not in scope: `iter'
18:36:31 <chessguy> > iterate (1 :) []
18:36:32 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
18:36:43 <chessguy> hm. not what i wanted
18:36:50 <chessguy> @type Prelude.sequence
18:36:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:37:00 <chessguy> @type Prelude.seq
18:37:02 <lambdabot> forall a t. a -> t -> t
18:37:34 <chessguy> @hoogle a -> (a -> a) -> [a]
18:37:35 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
18:37:35 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:37:35 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
18:37:58 <chessguy> @hoogle fix
18:37:58 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
18:37:59 <lambdabot> Control.Monad.Fix :: module
18:37:59 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
18:38:28 <chessguy> @hoogle repeat
18:38:29 <lambdabot> Prelude.repeat :: a -> [a]
18:38:39 <chessguy> > repeat 1
18:38:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:41:15 <chessguy> @pl \gene -> return $ (fst gene, take (snd gene) (repeat (n-1)))
18:41:16 <lambdabot> return . liftM2 (,) fst (flip take (repeat (n - 1)) . snd)
18:41:30 <chessguy> cute
18:43:38 <chessguy> ok, let's have a vote. which of thow two is more readable?
18:47:44 <Saulzar> I'd go for the first, but use pattern matching instead of fst and snd
18:49:04 <int-e> chessguy: take (snd gene) (repeat (n-1)) == replicate (snd gene) (n-1)
18:51:00 <chessguy> replicate!
18:51:03 <chessguy> that's what i was looking for
18:51:26 <Saulzar> Or even, return . second (flip replicate (n - 1))   :)
18:51:37 <chessguy> @pl \gene -> return $ (fst gene, replicate (snd gene) (n-1))
18:51:37 <lambdabot> return . liftM2 (,) fst (flip replicate (n - 1) . snd)
18:51:55 <chessguy> ?hoogle second
18:51:55 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
18:52:39 <Saulzar> > second (*3) ('a', 6)
18:52:40 <lambdabot>  ('a',18)
18:53:04 <JohnnyL> @type zip
18:53:06 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
18:53:24 <sorear> int-e: I was using +RTS -c.  does your statement about two-space collectors stand?
18:55:17 <int-e> sorear: hmm. I think a two-space gc is still used for the youngest generation, but I have to admit that I'm not sure.
18:55:47 <sorear> sjanssen, augustss: Hello world just compiled!!!!
18:56:42 <dons> sorear: re. Per Gustafsson, yeah, he took duncan and I to dinner at PADL, he had his bitstreams for erlang paper at the same event
18:56:45 <int-e> sorear: ghc is a moving target :)
18:56:48 <dons> and we talked about shootout code :)
18:57:02 <sorear> sjanssen, augustss: in 18 seconds no less!
18:57:12 <dons> sjanssen: so do we have a repo for haskell-dwm yet?
18:57:26 <sorear> dons: the right +RTS flags turn compiling base in jhc from >>4 hrs to 15 mins
18:57:44 <sjanssen> dons: I have one more bug I want to track down
18:57:49 <dons> hehe wow, sorear
18:57:52 <dons> GC isues?
18:57:59 <dons> sjanssen: and what, its done?
18:58:18 <sorear> dons: JHC wants 500mb of core (default opts).  I have 384.
18:58:26 <sorear> JHC is rather slow when swapping.
18:58:31 <sjanssen> dons: 1 more bug until I'm ready for contributors :)
18:58:35 <dons> hehe ok
18:58:50 <sjanssen> the bug is fairly catastrophic: the window manager blows up when you close certain windows
18:59:22 <dons> ah ok. that's reasonable ;)
18:59:39 * dons desperately tries to clear desk space for a 16 core monolith
18:59:46 <gravity> geez
18:59:48 <sorear> I'm now compiling the rest of base
19:00:03 <dons> hey gravity.
19:00:08 <dons> how's the haskell hacking coming along?
19:00:09 <gravity> dons: Hiya
19:00:23 <sjanssen> dons: you're keeping that machine on your desk?!
19:00:30 <sorear> dons: how big is it?  how heavy is it?  will it run on a 15 ampere (or whatever is std in .au) circuit?
19:00:32 <dons> sjanssen: have to
19:00:34 <gravity> dons: Slow, although I think I had my first basic monad epiphany the other night. Now all I need is the time to write something :-)
19:00:37 <dons> until the clean room comes into service
19:00:52 <dons> sorear: supposedly..
19:00:58 <dons> gravity: yeah!
19:00:59 <dons> dive in !
19:01:11 <sjanssen> hopefully dons doesn't go deaf from the fan noise
19:01:21 <dons> so i've got 3 alphas stacked up, they can get chucked...
19:01:39 <dons> argh . ide drives falling everywhere
19:01:48 <gravity> dons: :-)
19:01:48 <dons> ok .now . 2 powerpcs hmm..
19:01:55 <sorear> so, will lambdabot get a +RTS -N16?
19:02:07 <dons> yeah!
19:02:46 * edwardk waves hello.
19:03:26 <sorear> now these 16 cores ... vintage 4004s? :p
19:03:38 <dons> amd64 2Ghz
19:03:46 * dons gets a teensy bit excited 
19:04:29 <sorear> > length (showBin (toInteger (maxBound :: Word)) "")
19:04:30 <lambdabot>   Not in scope: `showBin'
19:04:41 <sorear> > length (showAtBase 2 (toInteger (maxBound :: Word)) "")
19:04:42 <lambdabot>   Not in scope: `showAtBase'
19:04:48 <sorear> @hoogle Numeric
19:04:49 <lambdabot> Numeric :: module
19:04:54 <sorear> @hoogle Numeric.showBin
19:04:55 <lambdabot> No matches, try a more general search
19:06:00 <sorear> > length (showIntAtBase 2 Char.toDigit (toInteger (maxBound :: Word)) "")
19:06:01 <lambdabot>   Not in scope: `Char.toDigit'
19:06:06 <sorear> > length (showIntAtBase 2 toDigit (toInteger (maxBound :: Word)) "")
19:06:07 <lambdabot>   Not in scope: `toDigit'
19:06:25 <sorear> > length (showIntAtBase 2 intToDigit (toInteger (maxBound :: Word)) "")
19:06:26 <lambdabot>  32
19:06:39 * sorear supposes asking might have been easier :)
19:08:22 <int-e> sorear: if compacting GC is done that should save memory. so the answer depends on how old the live data actually is (i.e. if copying or compacting GC is done for it)
19:09:19 <JohnnyL> fibs = 0:1:[x+y|(x,y) < zip fibs (tail fibs)]   is interpreted as a function zip return a a list element of tuples into (x,y)?
19:09:25 <JohnnyL> is that correct?
19:09:28 <sorear> +RTS -sstderr -H340M -c -F1.1 -RTS -- the option I'm using now
19:09:51 <sorear> err, that won't work
19:10:04 <sorear> the first item in a comprehension must be a list
19:10:11 <sorear> (x,y) < zip ... is a filter
19:10:21 <sorear> you want (x,y) <- zip ...
19:12:40 <JohnnyL> what's <- stand for?
19:13:09 <sjanssen> in list comprehensions, you could pronounce "<-" as "drawn from"
19:13:14 <JohnnyL> oh ok.
19:13:18 <JohnnyL> thanks
19:14:21 <glguy> In ViM if I wanted to add a U to the beginning of a couple of lines I'd type IU^[ and then go to each line and press . to repeat, does emacs have something like this? (the repeating of an action)
19:15:40 <sorear> yes, but there's a better way
19:16:07 <sorear> put the mark at the first line, the point at the second, C-x r t, the string to insert
19:16:32 <sorear> but if you insist on repeat, C-x z and C-x ( might be wanted
19:17:17 <glguy> the ^x r t works :)
19:17:30 <glguy> I don't mind learning better ways to use emacs
19:17:56 <sorear> FTR, you can do that in Vim too
19:18:28 <sorear> use Control-V to enter VISUAL BLOCK mode, select the lines, and 'I' to insert at the beginning of all
19:18:39 <sorear> <-- ex vimmer
19:18:46 <glguy> is there a better way to close a buffer than ^x k
19:18:49 <glguy> and then typing yes
19:18:57 <glguy> or is that the correct way
19:20:00 <sorear> that is the correct way IIRC
19:20:08 <sorear> @botsnack
19:20:08 <lambdabot> :)
19:20:17 <TSC> Isn't it just C-x k RET ?
19:20:21 <sorear> I just C-g C-g'd emagc
19:20:31 <sorear> it is for me
19:20:37 <glguy> C-x k RET yes RET
19:20:50 <sorear> "garbage colection in progress! cannot auto-save! Abort?"
19:21:29 <sorear> The functions in `kill-buffer-query-functions' are called with BUFFER as
19:21:29 <sorear> the current buffer.  If any of them returns nil, the buffer is not killed.
19:21:51 <sorear> ^^^ hmm, is this set to something besides nil for you?
19:22:06 <sorear> (I'm guessing it is set to ('yes-or-no-p) )
19:22:24 <sorear> BTW, have you found C-h k yes?
19:22:25 <TSC> You have to confirm a kill if there are unsaved changes
19:22:26 <sorear> s/yes/yet
19:23:00 <glguy> I read about C-h k in the tutorial
19:23:03 <glguy> Just don't use it much
19:23:05 <glguy> forgot
19:27:02 <chessguy> @type replicate
19:27:04 <lambdabot> forall a. Int -> a -> [a]
19:27:12 <chessguy> replicate 1
19:27:21 <chessguy> > replicate 1 1
19:27:22 <lambdabot>  [1]
19:28:20 <sorear> @src replicate
19:28:20 <lambdabot> replicate n x = take n (repeat x)
19:30:43 <TSC> @paste
19:30:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:31:02 <glguy> hmm, is there a setting so that emacs will reload a field when it has changed?
19:31:26 <sorear> what's a field?
19:31:49 <sorear> (if "file" then see auto-revert-mode)
19:32:50 <hpaste>  TSC pasted "Name this function" at http://hpaste.org/500
19:32:51 <allbery_b> fields are the things in "custom" buffers.  as far as I know there's no auto-reload for those :)
19:33:01 <TSC> Can someone think of a good name for that function?
19:34:06 <sorear> everywhere I go, it's called "chunks"
19:34:14 <TSC> Ah, that's not bad
19:36:35 <dons> Igloo: I'd like headTail to be called 'uncons'
19:36:57 <sorear> Writing haskell object file: base-1.0.hl  -- woot!!!
19:42:12 * sorear sics jhc on vty ... muahahaha
19:44:57 <sorear> that's funny
19:45:03 <sorear> jhc doesn't seem to come with fps
19:45:47 <sjanssen> fps is a fairly big library, how long will jhc take to compile it?
19:46:59 <sorear> it only took half an hour for base :)
19:47:45 <sjanssen> you just had to find the correct heap limitations?
19:47:53 <dons> Cale: seems like all the fp whingers crawled out for some reason on this 'fp is too hard' article :/
19:48:17 <dons> sorear: i didn't know jhc could actually handle fps, without ForeignPtr support
19:49:35 <sorear> jhc supports 'import Foreign.ForeignPtr' . I dunno if that module has useful contents.
19:52:19 <sorear> ./Data/ByteString.hs:463:1: Parse error
19:52:23 <sorear> oh well.
19:52:35 <sorear> Data.ByteString.Fusion <-- ooh!
19:53:39 <dons> more info please
19:54:52 <sorear> oh, you actually want to try and FIX the problem?
19:55:08 <dons> bizarre, I know!
19:55:31 <sorear> ... in a development compiler neither of us knows much of anything about, at that!
19:56:18 <sorear> it's the blank line that separates unpackFoldr from unpackList, right after a {-# INLINE [0]
19:56:57 <dons> does INLINE [0] get parsed accidentally?
19:57:09 <dons> since that's probably not going to look like a proper inline pragma
19:57:35 <sorear> ok, {-# INLINE [0] unpackFoldr #-}
19:57:51 <sorear> that look proper :)
19:58:20 <sorear> hm, it's the first numbered INLINE in the file
19:59:30 <dons> the fusible stuff should be commented out for non-ghc though
20:00:36 <dons> so the main comments on the 'fp is too hard' article are to the effect that easy things in imperative languages are too hard in haskell
20:00:42 <dons> IO being the example, and GUIs
20:01:01 <SamB> methinks these people don't use C much
20:01:06 <dons> I think I can make a pretty good case that IO is no harder, and is more flexible in Haskell
20:01:16 <dons> but are there other things that really are still harder in Haskell?
20:01:21 <dons> I can think of a lot of things that are easier
20:02:05 <allbery_b> ...is it even worth bothering to respond?
20:02:22 <dons> well, i'm thinking of writing a general article on 'things that are harder/things that are easier'
20:02:45 <dons> i.e. easier: threads, data structures, IO (well, it can go on both sides), .. um more things in here..
20:03:08 <sorear> dons: yes, the erroring line is ifdefed out.
20:03:18 <dons> sorear: so its another line then?
20:03:26 <dons> check the preprocessor output for the real line
20:03:41 <dons> some things are harder only due to lack of libraries
20:04:25 <Saulzar> Space leaks are the only thing I have really found harder in Haskell, they can be really subtle in a larger program
20:04:26 <dons> mutable arrays are harder
20:04:36 <int-e> sorear: Hmm, I've digged around in the GC code a bit; it looks like if a program uses constant memory for a while and then starts to allocate like crazy, it'll overshoot the suggested heap size by a factor of up to two, due to extrapolating the survival rate in the youngest generation (which would change from close to 0% to close to 100% in that scenario). Note, I'm not sure that this is what's happening, it's just a theory that fits nicely. (
20:04:37 <int-e> see ghc/rts/sm/GC.c, around line 930)
20:05:05 <dons> Saulzar: hmm. yes. I see again and again that people have trouble with space leaks. I find them pretty easy to spot (there's usually only one, and its obvious), but maybe the tools for spotting them need to be better taught
20:05:11 <dons> Saulzar: thanks. /me tweaks list
20:05:13 <sorear> int-e: quite plausible.  Jhc has very bursty allocation.
20:05:21 <dons> reasoning about space use is harder
20:05:35 <sorear> dons: where would I find this "preprocessor output" ?  Cabal isn't keeping it.
20:06:06 <dons> run cpp over the src, look at the result. find the line that fails
20:06:10 <dons> though this seems a bit heavy
20:07:04 <Saulzar> For small programs I think space leaks are generally easy enough to find, but when it gets larger (and possibly using an external framework)...
20:07:42 <sorear> dons: line 463 of the cpp output is a different but equally blank line
20:07:44 <dons> so hard, even when using -prof -auto-all ?
20:08:29 <sorear> hm, a few lines further down is an unterminated {-# RULES #-}
20:08:33 <Saulzar> Yeah. I've spend days and days looking at programs using Yampa, with all the profiling tools
20:09:42 <sorear> this is fps 0.7 fwiw
20:09:53 <sorear> not darcs
20:11:04 <chessguy> @pl \x -> (x,3)
20:11:04 <lambdabot> flip (,) 3
20:11:11 <chessguy> @pl \x -> (3,x)
20:11:12 <lambdabot> (,) 3
20:11:37 <LoganCapaldo> @unpl flip . flip (,) 3
20:11:38 <lambdabot> (\ i b c -> (,) i 3 c b)
20:11:49 <LoganCapaldo> Mmm
20:11:58 <chessguy> wtf
20:12:04 <LoganCapaldo> @type flip . flip (,) 3
20:12:06 <lambdabot>     Couldn't match expected type `a -> b -> c'
20:12:07 <lambdabot>            against inferred type `(a1, b1)'
20:12:21 <LoganCapaldo> @type (flip . flip) (,) 3
20:12:24 <lambdabot> forall a b. (Num a) => b -> (a, b)
20:12:34 <LoganCapaldo> I never put enough parens
20:12:48 <LoganCapaldo> @unpl (flip . flip) (,) 3
20:12:49 <lambdabot> (\ c -> (,) 3 c)
20:13:12 <LoganCapaldo>  I feel like . should bind more
20:13:58 <chessguy> there are professionals you can talk to about those kinds of feelings
20:14:12 <LoganCapaldo> @ (.) flip flip (,) 3
20:14:20 <LoganCapaldo> @type (.) flip flip (,) 3
20:14:23 <lambdabot> forall a b. (Num a) => b -> (a, b)
20:14:31 <LoganCapaldo> prefix notation ftw
20:14:50 <chessguy> i can't imagine making a change like that to the language at this point anyway, even if it were necessary
20:15:29 <LoganCapaldo> I'm assuming I can change its precendence in some module though right, if I chose?
20:15:32 <glguy> ?where binary
20:15:33 <lambdabot> http://darcs.haskell.org/binary
20:15:49 <coffee-mug> > foldl (+) [1..]
20:15:50 <lambdabot>   add an instance declaration for (Num [t])
20:15:51 <LoganCapaldo> import Prelude hiding (.). infixr ...
20:16:05 <sjanssen> LoganCapaldo: you can't fix this particular problem
20:16:06 <coffee-mug> > foldl1 (+) [1..]
20:16:10 <lambdabot> Terminated
20:16:23 <chessguy> LoganCapaldo, that's not changing the language
20:16:33 <LoganCapaldo> sjanssen: Well it's only a "problem" for me
20:16:48 <sjanssen> function application is higher precedence than any operator
20:16:57 <LoganCapaldo> Ahhh
20:17:13 <chessguy> coffee-mug, infinity still can't be computed :)
20:17:15 <glguy> ?where hlist
20:17:15 <lambdabot> http://homepages.cwi.nl/~ralf/HList
20:17:18 <coffee-mug> > foldl1 (+) [1..]
20:17:22 <lambdabot> Terminated
20:17:44 <coffee-mug> chessguy: I know, it's just extremely amusing to me how lambdabot knows to terminate
20:18:03 <coffee-mug> the magic has been shattered when dons explained it simply kills the process after a timer
20:18:04 <allbery_b> what's so special about a timeout?
20:18:09 <allbery_b> heh
20:18:11 <LoganCapaldo> "Knows"? I always assumed there was a timeout?
20:18:12 <chessguy> @quote terminate
20:18:13 <lambdabot> greentea says: it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
20:18:21 <sjanssen> > let x = x in x -- better error message?
20:18:23 <lambdabot>  Exception: <<loop>>
20:18:41 <coffee-mug> but I still like to pretend that it can bypass the laws of mathematics and figure out at constant time whether something terminates or not :)
20:18:43 <sjanssen> coffee-mug: now, isn't that example magical?
20:18:44 <LoganCapaldo> Yes the loop detection is way more interesting in my mind
20:19:03 <coffee-mug> oh
20:19:07 <coffee-mug> I didn't know about that :)
20:19:20 <chessguy> @quote terminate
20:19:20 <lambdabot> greentea says: it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
20:19:23 <coffee-mug> > let x = y where y = x
20:19:23 <lambdabot>  Parse error
20:19:23 <chessguy> @quote loop
20:19:24 <lambdabot> No quotes match. stty: unknown mode: doofus
20:19:57 <sjanssen> > let a = b; b = c; c = a in a
20:19:58 <lambdabot>  Exception: <<loop>>
20:19:58 <LoganCapaldo> > let x = y, y = x in x
20:19:59 <lambdabot>  Parse error
20:20:05 * chessguy cries. lambdabot called me a doofus. waaaaaaaahh!
20:20:09 <allbery_b> @quote infini
20:20:09 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
20:20:10 <LoganCapaldo> > let x = y; y = x in x
20:20:11 <lambdabot>  Exception: <<loop>>
20:20:20 <allbery_b> @quote infini
20:20:20 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
20:20:21 <sorear> @quote speling
20:20:21 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
20:20:26 <sorear> @quote azi
20:20:27 <lambdabot> ghc says: Plugin/Spell.hs:35:31: Not in scope: `spellineNazi'
20:20:45 <coffee-mug> > let (x, y) = (y, x)
20:20:45 <lambdabot>  Parse error
20:20:49 <coffee-mug> hmm
20:20:50 <LoganCapaldo> @type let x = y; y = x in x
20:20:51 <coffee-mug> what about state?
20:20:53 <lambdabot> forall t. t
20:20:55 <coffee-mug> > let x = 5
20:20:55 <lambdabot>  Parse error
20:20:59 <sorear> > let (x, y) = (y, x) in x
20:21:00 <coffee-mug> nope :(
20:21:00 <lambdabot>  Exception: <<loop>>
20:21:08 <sjanssen> coffee-mug: you're forgetting "in"
20:21:10 <coffee-mug> > x = 5
20:21:10 <lambdabot>  Parse error
20:21:10 <sorear> ain't blackholing grand!
20:21:15 <sorear> @let x = 5
20:21:17 <allbery_b> actualy I think he's looking fr @let
20:21:18 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:21:25 <sorear> @get-dos
20:21:25 <lambdabot> Unknown command, try @list
20:21:32 <sorear> AAARGH!!! :)
20:21:34 <coffee-mug> sjanssen: yeah, I'm just thinking it's like ghci let
20:21:45 <coffee-mug> @let (x, y) = (y, x)
20:21:46 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:21:50 <sorear> @get-dons
20:21:51 <lambdabot> Unknown command, try @list
20:21:57 <coffee-mug> @list
20:21:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:22:14 <sorear> well, we have @get-shapr
20:22:47 <LoganCapaldo> @get-dullr
20:22:48 <lambdabot> Unknown command, try @list
20:22:51 <coffee-mug> > putStr "hello!"
20:22:53 <lambdabot>  <IO ()>
20:23:00 <coffee-mug> hehehe
20:23:03 <coffee-mug> no IO :)
20:23:09 <chessguy> @quote coffee-mug
20:23:09 <lambdabot> No quotes match. Do you think like you type?
20:23:13 <chessguy> @quote coffee
20:23:14 <lambdabot> No quotes match. stty: unknown mode: doofus
20:23:26 <coffee-mug> security in Haskell is so painfully easy
20:23:28 <LoganCapaldo> grooooan
20:23:29 <coffee-mug> just turn off IO
20:23:32 <coffee-mug> and you're done :)
20:23:42 <allbery_b> "the Master does not wish to be disturbed..."
20:23:48 <coffee-mug> @quote chessguy
20:23:48 <lambdabot> chessguy says: [in regards to #haskell] man, it's amazing the difference between what happens when someone asks for help here, and what happens when they ask for help in another language channel
20:23:54 <chessguy> coffee-mug, that's why i think glguy should build GHC into hpaste
20:24:08 <LoganCapaldo> well and unsafePerformIO
20:24:19 <sorear> coffee-mug:
20:24:24 <LoganCapaldo> unsafePaste
20:24:26 <chessguy> ?hoogle unsafePerformIO
20:24:27 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
20:24:30 <coffee-mug> yeah, unsafePerformIO kind of sucks :)
20:24:34 <sorear> > array (0::Int, maxBound) [(0,'x')]
20:24:36 <chessguy> ?hoogle unsafe
20:24:36 <lambdabot> Terminated
20:24:37 <lambdabot> Language.Haskell.TH.unsafe :: Safety
20:24:37 <lambdabot> System.IO.Unsafe :: module
20:24:37 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
20:24:40 <sorear> > array (0::Int, maxBound) [(1,'x')]
20:24:40 <glguy> chessguy: I think *you* should submit a patch :)
20:24:41 <lambdabot> Terminated
20:24:43 <chessguy> ?hoogle+
20:24:43 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
20:24:44 <lambdabot> Foreign.ForeignPtr.unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
20:24:44 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
20:24:44 <sorear> > array (0::Int, maxBound) [(2,'x')]
20:24:46 <lambdabot> Terminated
20:24:48 <sorear> > array (0::Int, maxBound) [(4,'x')]
20:24:53 <sjanssen> you also have to disallow Ix instances
20:24:54 <chessguy> ?hoogle+
20:24:54 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
20:24:54 <sorear> > array (0::Int, maxBound) [(3,'x')]
20:24:54 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
20:24:54 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
20:25:04 <chessguy> that's a lot of unsafe stuff to turn off :)
20:25:06 <sorear> > array (minBound::Int, maxBound) [(-1,'x')]
20:25:08 <lambdabot> Terminated
20:25:11 <sorear> > array (minBound::Int, maxBound) [(0,'x')]
20:25:13 <lambdabot> Terminated
20:25:21 <sorear> c'mon, internal panic!
20:25:23 <coffee-mug> ok ok, but the unsafe stuff is hacky
20:25:25 <coffee-mug> it doesn't count :)
20:25:26 <sorear> > array (minBound::Int, maxBound) [(5,'x')]
20:25:27 <lambdabot> Terminated
20:25:28 <chessguy> i wonder how much of it you'd have to actually turn off
20:25:31 <sorear> > array (minBound::Int, maxBound) [(25,'x')]
20:25:33 <lambdabot> Terminated
20:25:36 <sorear> > array (minBound::Int, maxBound) [(2500000,'x')]
20:25:38 <lambdabot> Terminated
20:26:04 <chessguy> glguy, you're much more of a guru than i am. and its your code. therefore, clearly, you should write it. QED
20:26:09 <sorear> coffee-mug: incidentally, Terminated means SIGSEGV here, not SIGXCPU.
20:26:11 <LoganCapaldo> So I was thinking that maybe the real numbers are a monad with e^x as bind and join
20:26:18 <LoganCapaldo> err return and join
20:26:32 <chessguy> say what?
20:26:33 <coffee-mug> > Foreign.unsafePerformIO $ do putStr "test"
20:26:34 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
20:26:46 <coffee-mug> what does it mean not in scope
20:26:48 <LoganCapaldo> whenever I see SEGV I think Segment 5
20:26:50 <coffee-mug> of course it's in scope :)
20:26:57 <chessguy> > unsafePerformIO $ do putStr "test"
20:26:58 <lambdabot>   Not in scope: `unsafePerformIO'
20:27:03 <chessguy> apparently not
20:27:10 <LoganCapaldo> @type unsafePerformIO
20:27:12 <lambdabot> Not in scope: `unsafePerformIO'
20:27:16 <LoganCapaldo> see
20:27:23 <LoganCapaldo> not in scope
20:27:29 <chessguy> @type Foreign.unsafePerformIO
20:27:31 <lambdabot> forall a. IO a -> a
20:27:39 <coffee-mug> hmm
20:27:42 <sorear> chessguy: @type and @run use completely different code
20:27:42 <LoganCapaldo> gasp
20:27:45 <coffee-mug> so why would it say it's not in scope?
20:27:53 <sorear> coffee-mug: because it's not
20:27:56 <coffee-mug> @run 5
20:27:56 <sorear> (in @run)
20:27:57 <chessguy> coffee-mug, ^^
20:27:57 <lambdabot>  5
20:28:09 <chessguy> @run === >
20:28:09 <lambdabot>  Parse error
20:28:16 <chessguy> oops
20:28:23 <sorear> @type foo --> echo ':t foo' | ghci
20:28:24 <coffee-mug> @run Foreign.unsafePerformIO $ putStr "test"
20:28:25 <lambdabot> Not in scope: `foo'
20:28:25 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
20:28:26 <LoganCapaldo> lambdabot is lying to us
20:28:32 <LoganCapaldo> it is in scope
20:28:41 <allbery_b> not in @run it's not
20:28:43 <sjanssen> LoganCapaldo: no, it isn't
20:28:46 <allbery_b> @run has a custom environment
20:28:47 <lambdabot>   Not in scope: `environment'
20:28:48 <allbery_b> heh
20:28:54 <sorear> @run foo --> (to a first approximation) ghci -fno-implicit-prelude -e 'import L; foo'
20:28:54 <lambdabot>  Improperly terminated character constant
20:29:03 <LoganCapaldo> > let unsafePerformIO = "Not in scope: `Foreign.unsafePerformIO'
20:29:03 <lambdabot>  Improperly terminated string
20:29:09 <LoganCapaldo> > let unsafePerformIO = "Not in scope: `Foreign.unsafePerformIO'"
20:29:10 <lambdabot>  Parse error
20:29:20 <LoganCapaldo> > let unsafePerformIO = "Not in scope: `Foreign.unsafePerformIO'" in unsafePerformIO
20:29:21 <lambdabot>  "Not in scope: `Foreign.unsafePerformIO'"
20:29:22 <coffee-mug> hmm
20:29:26 <LoganCapaldo> See
20:29:27 <coffee-mug> that's one interesting thing to do
20:29:29 <LoganCapaldo> lies!
20:29:32 <coffee-mug> trying to hack lambdabot :)
20:29:47 * lambdabot glares at LoganCapaldo
20:29:50 <coffee-mug> hack as in crack
20:29:58 <sjanssen>  @type runs inside ghci -- which automatically imports modules when you use their full qualified name.  @run treats the text as a plain old Haskell expression (no automatic importing)
20:30:11 <siti> > forkIO ("5")
20:30:12 <lambdabot>   Not in scope: `forkIO'
20:30:27 <sorear> siti: no instance IsString (IO ())
20:30:41 <coffee-mug> > map (+1) [1..]
20:30:42 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
20:30:51 <allbery_b> hacking lambdabot is old hat
20:30:53 <allbery_b> @help v
20:30:53 <lambdabot> let v = show v in v
20:31:19 <coffee-mug> > [[1..]. [1..]]
20:31:20 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
20:31:22 <allbery_b> ...that was, originally, more or less how @run worked.
20:31:23 <allbery_b> @v
20:31:23 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
20:31:25 <allbery_b> @v
20:31:25 <lambdabot> Just 'J'
20:31:27 <allbery_b> @v
20:31:28 <lambdabot> "\"#$%&'()*+,\""
20:31:42 <coffee-mug> > [[1..10], [1..10]]
20:31:43 <allbery_b> @v
20:31:43 <lambdabot> "\""
20:31:44 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]]
20:31:56 <allbery_b> bah, not getting the interesting ones
20:31:57 <allbery_b> @v
20:31:57 <lambdabot> "\"#$%&'()*+,\""
20:31:59 <allbery_b> @v
20:31:59 <lambdabot> Exception: <<loop>>
20:32:01 <allbery_b> @v
20:32:01 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
20:32:02 <coffee-mug> > [[1..10], [1..10], [1..10], [1..10], [1..10], [1..10], [1..10]]
20:32:03 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3...
20:32:04 <allbery_b> @v
20:32:05 <lambdabot> Exception: <<loop>>
20:32:11 <allbery_b> @list v
20:32:11 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
20:32:13 <coffee-mug> hmm
20:32:13 <sjanssen> ah yes, v
20:32:15 <coffee-mug> smart beast :)
20:32:18 <sorear> so where did @v come from?
20:32:19 <sjanssen> that was a fun mystery to decipher
20:32:26 <allbery_b> @yhjulwwiefzojcbxybbruweejw
20:32:27 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:32:30 <LoganCapaldo> > fix ([1..10]++)
20:32:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,...
20:32:43 <LoganCapaldo> > fix ([1..10]:)
20:32:44 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3...
20:32:48 <coffee-mug> @type fix
20:32:50 <lambdabot> forall a. (a -> a) -> a
20:32:51 <allbery_b> ...when people discovered how to hack LB with v, it was renamed to that yh... thing
20:32:55 <allbery_b> but it got rediscovered :)
20:32:58 <allbery_b> @yhjulwwiefzojcbxybbruweejw
20:32:58 <lambdabot> Exception: <<loop>>
20:32:59 <allbery_b> @yhjulwwiefzojcbxybbruweejw
20:33:00 <lambdabot> "\""
20:33:03 <sorear> sjanssen: aiui, the bug is still there
20:33:11 <coffee-mug> hmm
20:33:13 <coffee-mug> what's fix?
20:33:14 <sorear> sjanssen: it has a random name every time
20:33:17 <sjanssen> sorear: runplugs turns expression E into let <somerandomvar> = show E in E
20:33:17 <glguy> anyone here ever used one of these $300 Kinesis keyboards?
20:33:17 <sorear> coffee-mug: y
20:33:18 <allbery_b> these days it invents a new identifier each time now
20:33:25 <lucca> @v for vendetta
20:33:25 <lambdabot> Exception: <<loop>>
20:33:29 <sjanssen> sorear: but back in the day, the name wasn't random
20:33:37 <LoganCapaldo> Shoulda used some character than can't be transmitted over IRC as the identifier
20:33:42 <coffee-mug> ah
20:33:42 <LoganCapaldo> if there be such a character
20:33:50 <allbery_b> if you need LB a syntax error in a /msg you can see the variable it rolls for that run
20:33:58 <LoganCapaldo> @src fix
20:33:59 <lambdabot> fix f = let x = f x in x
20:33:59 <sorear> coffee-mug: you knew what I was talking about!?
20:34:21 <coffee-mug> sorear: combinator?
20:34:26 <sorear> yes
20:34:31 <sorear> allbery_b: doesn't work :(
20:34:43 <allbery_b> hm, broken in the last set of changes?
20:34:44 <allbery_b> sad
20:34:48 <allbery_b> I used to get them
20:34:57 <coffee-mug> sorear: why would it be so surprising then? :)
20:35:07 <sjanssen> sorear: the channel spent an entire day trying to figure out what v is
20:35:07 <allbery_b> oh, not syntax error.  type error
20:35:27 <LoganCapaldo> > fix (\f n -> if n == 0 or n == 1 then 1 else (f (n - 1)) + (f (n - 2))) 9
20:35:28 <lambdabot>      precedence parsing error
20:35:28 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
20:35:52 <LoganCapaldo> > fix (\f n -> if n == 0 || n == 1 then 1 else (f (n - 1)) + (f (n - 2))) 9
20:35:53 <lambdabot>  55
20:35:58 <allbery_b> hm, nope, it strips them out in /msg to now.  oh well
20:36:33 <chessguy> @v
20:36:33 <lambdabot> Exception: <<loop>>
20:36:36 <chessguy> @v
20:36:37 <lambdabot> "\""
20:36:41 <chessguy> @v
20:36:41 <lambdabot> "\"#$%&'()*+,\""
20:36:46 <LoganCapaldo> @. run v
20:36:47 <lambdabot>  "\""
20:36:55 <LoganCapaldo> @. run v
20:36:57 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\"
20:37:00 <coffee-mug> hmm
20:37:06 <chessguy> @v
20:37:06 <lambdabot> "\""
20:37:14 <chessguy> ?list
20:37:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:37:22 <sorear> @msg #haskell !say @v
20:37:22 <lambdabot> !say @v
20:37:28 <LoganCapaldo> @. run v
20:37:28 <sorear> !say @v
20:37:29 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\"
20:37:36 <siti> > fix (\f n -> if (n == 0 || n == 1) then 1 else (f (n - 1)) + (f (n - 2))) 20
20:37:38 <lambdabot>  10946
20:37:41 <coffee-mug> I've grown to find an awesome OS, awesome programming languages, and awesome dev environment
20:37:48 <siti> > fix (\f n -> if (n == 0 || n == 1) then 1 else (f (n - 1)) + (f (n - 2))) 25
20:37:49 <lambdabot>  121393
20:37:49 * chessguy considers cracking open LB's source for that one
20:37:53 <coffee-mug> there should be nothing stopping me from doing something useful with all this knowledge
20:37:56 <siti> > fix (\f n -> if (n == 0 || n == 1) then 1 else (f (n - 1)) + (f (n - 2))) 30
20:37:57 <lambdabot>  1346269
20:37:58 <coffee-mug> yes something is :)
20:38:04 <siti> > fix (\f n -> if (n == 0 || n == 1) then 1 else (f (n - 1)) + (f (n - 2))) 33
20:38:06 <lambdabot>  5702887
20:38:15 <siti> > fix (\f n -> if (n == 0 || n == 1) then 1 else (f (n - 1)) + (f (n - 2))) 37
20:38:18 <sorear> fibonacci--
20:38:19 <lambdabot> Terminated
20:38:22 <coffee-mug> all I need to do now to take over the world is remove that barrier :)
20:38:23 <siti> ohh
20:38:24 <LoganCapaldo> siti: What are you trying to say, your numbers are bigger than mine?
20:38:30 <siti> it's a smarty
20:38:45 <chessguy> coffee-mug, are you thinking what i'm thinking?
20:38:51 <sorear> I can name a number bigger than ANY fibbonacci number.
20:38:56 <sorear> Aleph-one.
20:39:04 <sorear> beat that with fib.
20:39:12 <coffee-mug> chessguy: it depends entirely on what you're thinking :)
20:39:17 <siti> > 1/0::Integer
20:39:18 <lambdabot>   add an instance declaration for (Fractional Integer)
20:39:18 <lambdabot>     In the expression:...
20:39:19 <allbery_b> but what can you do with it? :)
20:39:20 <sorear> @brain
20:39:20 <LoganCapaldo> What if I were to say fib(Aleph-one) ?
20:39:20 <lambdabot> Wuh, I think so, Brain, but isn't Regis Philbin already married?
20:39:30 <siti> >1`div`0::Integer
20:39:32 <sorear> siti: Aleph 1 > 1/0 :)
20:39:38 <sorear> 1/0 = Aleph 0
20:39:40 <siti> > 1`div`0::Integer
20:39:40 <chessguy> ooooh, LB has a pinky-and-the-brain feature!
20:39:41 <lambdabot>  Exception: divide by zero
20:39:42 <chessguy> @brain
20:39:43 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
20:40:08 <chessguy> @brain
20:40:08 <lambdabot> Has it ever occurred to you, Pinklet, that your scarf is
20:40:08 <lambdabot> constricting the bloodflow to your head?
20:40:13 * chessguy could get addicted to this
20:40:23 <coffee-mug> haha
20:40:25 <coffee-mug> @brain
20:40:25 <lambdabot> I think so, Brain, but Lederhosen won't stretch that far.
20:40:28 <LoganCapaldo> @fjord
20:40:29 <lambdabot> Unknown command, try @list
20:40:30 <chessguy> @pinky
20:40:30 <lambdabot> Plugin `pointful' failed with: IRCRaised Lib/Pointful.hs:38:24-51: Non-exhaustive patterns in lambda
20:40:39 <sorear> LoganCapaldo: last time I checked fib was defined using ordinary countable induction, and Aleph-one is uncountable
20:40:48 <coffee-mug> @pinky
20:40:49 <lambdabot> Plugin `pointful' failed with: IRCRaised Lib/Pointful.hs:38:24-51: Non-exhaustive patterns in lambda
20:40:51 <LoganCapaldo> sorear: Untrue
20:40:59 <coffee-mug> @somethingweird
20:40:59 <lambdabot> Unknown command, try @list
20:41:04 <coffee-mug> hmm
20:41:05 <sorear> LoganCapaldo: which clause/?
20:41:06 <LoganCapaldo> I forget what its called but theres the on-recursive defn
20:41:15 <LoganCapaldo> *non-recursive
20:41:16 <siti> > foldr1 (**) (repeat $ 1`div`0)
20:41:17 <lambdabot>  Add a type signature
20:41:19 <LoganCapaldo> So hah!
20:41:26 <siti> beats aleph ;)
20:41:39 <allbery_b> gamma function?
20:41:39 <coffee-mug> chessguy: what are we going to do tomorrow night, chessguy? :)
20:41:51 <LoganCapaldo> what allbery_b said
20:41:56 <sorear> allbery_b: that's Aleph{Aleph0}
20:42:06 <sorear> that's Eta-0 right?
20:42:06 <chessguy> > let undefined = "nullity" in foldr1 (**) (repeat $ 1`div`0)
20:42:07 <lambdabot>  Add a type signature
20:42:15 * allbery_b doesn't recall the defn of it so doesn't know how it compares there...
20:42:17 <chessguy> > let undefined = "nullity" in (foldr1 (**) (repeat $ 1`div`0))::String
20:42:18 <lambdabot>   add an instance declaration for (Integral String)
20:42:21 <chessguy> bah
20:42:28 <chessguy> coffee-mug, let's ask the bot!
20:42:29 <chessguy> @brain
20:42:30 <lambdabot> I think so, Brain, but I didn?t know 90210 was a real zip code! Will Tori be there?
20:42:40 <chessguy> woohoo! road trip!
20:42:48 <coffee-mug> heh
20:42:53 <sorear> @brawn
20:42:54 <lambdabot> Now, Pinky, if by any chance you are captured during this mission,
20:42:54 <lambdabot> remember you are Gunther Heindriksen from Appenzell. You moved to Grindelwald
20:42:54 <lambdabot> to drive the cog train to Murren.  Can you repeat that?
20:43:26 <LoganCapaldo> > "a" :: (MonadPlus m, Monad m) => m Char
20:43:27 <lambdabot>   m Char
20:43:27 <lambdabot>       Inferred type: [Char]
20:43:27 <lambdabot>     In the expression: "a"
20:43:27 <lambdabot>     In the ex...
20:43:30 <chessguy> ouch, that's gonna suck. my first time seeing my girlfriend in a month, and i've gotta fly to california to check out 90210
20:43:48 <siti> (yournumber<yournumber+1) = true ;)
20:43:49 <allbery_b> heh
20:44:06 <sorear> siti: Aleph_0 < Aleph_0 + 1 = False
20:44:13 <LoganCapaldo> > "a" :: (MonadPlus [], Monad []) => [] Char
20:44:14 <lambdabot>      Non type-variable argument in the constraint: MonadPlus []
20:44:14 <lambdabot>     (Use -fgl...
20:44:14 <siti> lol
20:44:16 <siti> hax
20:44:50 <chessguy> ack!
20:44:52 <sorear> > {-# OPTIONS_GHC -fglasgow-exts #-}
20:44:53 <lambdabot>  Parse error
20:44:56 <chessguy> s/girlfriend/fiancee/
20:45:04 <LoganCapaldo> Bah!
20:45:05 * chessguy checks to make sure she isn't looking over my shoulder
20:45:16 <sorear> chessguy: how long has that edit been true? <5 minutes? :p
20:45:20 * LoganCapaldo sends a d/dy after your aleph_1
20:45:32 <chessguy> the girlfriend/fiancee edit?
20:45:36 <sorear> yes
20:45:37 <sorear> :)
20:45:41 <chessguy> 6 weeks or so
20:46:03 <LoganCapaldo> > {- Lambda bot must like comments -}
20:46:03 <lambdabot>  Parse error
20:46:13 <coffee-mug> all right
20:46:23 <coffee-mug> I'm going to have a wonderful journey
20:46:25 <LoganCapaldo> > {-- Lambda bot must like comments --} 0
20:46:27 <lambdabot>  0
20:46:29 <coffee-mug> until I wake up tomorrow morning
20:46:31 <coffee-mug> night everyone
20:46:32 <chessguy> hm, almost 8 weeks
20:46:50 <LoganCapaldo> > -- No pragmas eh?
20:46:50 <lambdabot>  Parse error
20:47:00 <chessguy> >
20:47:02 <LoganCapaldo> > 0 -- Or just no empty strings?
20:47:04 <lambdabot>  0
20:47:22 <chessguy> > {- Foo -} 3
20:47:23 <lambdabot>  3
20:47:32 <allbery_b> >
20:47:37 <LoganCapaldo> > 0 {-# OPTIONS -fglasgow-exts #-}
20:47:39 <lambdabot>  0
20:47:52 <allbery_b> >
20:48:01 <allbery_b> guess it's too smart for that
20:48:09 <chessguy> > {-# OPTIONS_GHC -fglasgow-exts #-}  "a" :: (MonadPlus [], Monad []) => [] Char
20:48:10 <lambdabot>      Non type-variable argument in the constraint: MonadPlus []
20:48:10 <lambdabot>     (Use -fgl...
20:48:14 <chessguy> boo!
20:49:08 <chessguy> @what
20:49:08 <lambdabot>  @where <key>, return element associated with key
20:49:43 <chessguy> @what haskell
20:49:43 <lambdabot> http://haskell.org
20:49:59 <chessguy> what is that, a programming language? :)
20:50:19 <allbery_b> @whirr click
20:50:20 <lambdabot> I know nothing about click.
20:50:34 <nornagon> @whirr+ buzz
20:50:34 <lambdabot> Done.
20:50:34 <LoganCapaldo> @groan
20:50:35 <lambdabot> Unknown command, try @list
20:50:36 <nornagon> er.
20:50:42 <nornagon> @whirr+ click buzz
20:50:43 <lambdabot> Done.
20:50:47 <nornagon> @whirr click
20:50:47 <lambdabot> buzz
20:50:49 <chessguy> @where stat
20:50:49 <lambdabot> I know nothing about stat.
20:50:51 <chessguy> @where stats
20:50:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
20:51:19 * sorear acts proud
20:53:18 <chessguy> heh. random quote from Cale: "> let loop | loop == loop = loop in loop"
20:53:28 <chessguy> > let loop | loop == loop = loop in loop
20:53:29 <lambdabot>  Exception: <<loop>>
20:53:54 <LoganCapaldo> > let loop = [ loop | loop <- loop ] in loop
20:53:55 <lambdabot>  Exception: <<loop>>
20:54:11 * sorear likes being the best human in #haskell
20:54:17 <SamB> @remember Cale > let loop | loop == loop = loop in loop
20:54:17 <lambdabot> Done.
20:54:22 <SamB> @quote
20:54:22 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
20:54:23 <LoganCapaldo> @type let loop = [ loop | loop <- loop ] in loop
20:54:25 <lambdabot> forall t. [t]
20:55:07 <LoganCapaldo> Today I was writing some code and I got a type of (Ord t) => [t] -> [t1]
20:55:17 <chessguy> It seems that Syzygy-'s shift-key is hanging: 2.4% of the time he/she wrote UPPERCASE.
20:55:17 <chessguy> For example, like this:
20:55:17 <chessguy>      <Syzygy-> BWAHAHAHAHAHAHAHA!
20:55:19 <LoganCapaldo> and I was like, that can't be right
20:55:36 <sorear> LoganCapaldo: that's a legitamite type
20:55:36 <SamB> LoganCapaldo: it *does* sound rather useless
20:55:59 <LoganCapaldo> sorear: It was supposed to sort ;)
20:56:04 <sorear> LoganCapaldo: \ a -> if (monotonicallyIncreasing a) then [undefined] else []
20:56:14 <chessguy> interesting list of most-used words
20:56:21 <sorear> LoganCapaldo: that must mean your sort is nonterminating!
20:56:23 <SamB> I'm guessing it actually returned a []
20:56:30 <SamB> or something like that?
20:56:32 <chessguy> haskell, think, would, monad, function, should, right, which, maybe, where
20:56:32 <LoganCapaldo> indeed it did
20:56:48 <LoganCapaldo> Someone forgot their one element base case
20:56:58 <sorear> LoganCapaldo: one paper preaching strong typing to a Perl audience wrote (in ML) a sort function
20:57:26 <sorear> ... but it didn't terminate, because of a missing base case, and the typechecker raised the alarm
20:57:41 <sorear> wait ... are you reading the paper I'm talking about?
20:57:49 <LoganCapaldo> No
20:58:00 <LoganCapaldo> I wanted to write merge sort
20:58:03 <dons> re. @let not working. I'm aware of it, and just haven't had time to fix it ;)
20:58:06 <LoganCapaldo> without doing length / 2
20:58:12 <sorear> dons: I've found the Problem
20:58:23 <sorear> dons: JHC doesn't like multi-line {-# RULES #-}
20:58:30 <dons> oh, that's interesting
20:58:32 <dons> JHC bug then
20:58:41 <dons> does JHC even know what 'RULES' are?
20:59:00 <sorear> dons: yes, lib/base has them
20:59:08 <LoganCapaldo> and then I realized I could split (as, bs) (x:y:zs) = split (x:as, y:bs) zs
20:59:12 <sorear> also, cpp is munging whitespace
20:59:23 <dons> are they rewrite rules in the ghc sense?
20:59:29 <sorear> I have quite a few violations of the layout rule
20:59:33 * dons is scared the whole rewrite rule system is going to attempt to be used by jhc...
20:59:35 <sorear> yes - same syntax even
20:59:43 <LoganCapaldo> No one ever said it had to be the first half of the list and the second half of the lsit in order right?
20:59:43 <dons> hmm. i wonder how well they work
21:00:00 <LoganCapaldo> So that was fun
21:00:31 <sorear> well if I don't have rewrite rules how will my bytestrings fuse? :)
21:00:48 <SamB> well
21:00:51 <dons> i'd be surprised if the rewrite rules system was portable
21:00:52 <SamB> cases!
21:01:00 <dons> considering how much of ghc simon had to fix to make them work
21:01:14 <dons> i mean, maybe they'd work a little, more likely they just won't match/refuse to fire
21:01:20 <SamB> JHC does a lot of work with cases, doesn't it?
21:01:57 <sorear> also JHC kinda uses a different type system internally
21:02:14 <sorear> full lambda cube (isomorphic to the CoC, w/ dependant types)
21:02:23 <LoganCapaldo> @where JHC
21:02:23 <lambdabot> http://repetae.net/john/computer/jhc/
21:02:32 <sorear> atleast that's what the Features: list says :)
21:03:08 <sorear> jhc doesn't support nondecreasing do indentation
21:03:38 <LoganCapaldo> oooo
21:03:59 <LoganCapaldo> SO jhc is like the MLton of Haskell compilers?
21:04:02 <sorear> jhc it seems has a very different interpretation of the layout rule from ghc.
21:04:06 <sorear> LoganCapaldo: exactly
21:04:25 <sorear> BTW, anyone who wants a working precompiled base-1.0.hl, ask
21:06:08 <dons> sorear: you should look into how the shootout code runs with jhc
21:06:19 <dons> i'm acutally considering setting up a shootout-style nofib repo
21:06:26 <dons> which will do nightly runs of hugs, ghc, yhc and jhc
21:06:30 <dons> and publish the speed results
21:06:39 <dons> get a bit of healthy competition back in the game
21:06:39 <sorear> cool!
21:06:44 <dons> any thoughts on this?
21:07:00 <sorear> yes, where can I get bytestring-free shootout entries :p
21:07:03 <sorear> sounds nice
21:07:18 <sorear> I imagine a few still don't use bs
21:07:28 <dons> jhc only, i think
21:07:30 <sorear> but jhc works on my system now
21:07:49 <dons> cool
21:07:58 <sorear> and after the thrashing I've seen, 18 seconds for hello world feels damn fast
21:08:12 <sorear> (compile time)
21:08:30 <sorear> @where shootout
21:08:30 <lambdabot> http://shootout.alioth.debian.org/
21:09:03 <sorear> should I (a) use nofib (b) use the shootout code (c) solve the shootout probs myself
21:09:30 <master_baiter> (d) get laid
21:09:44 <dons> sorear: to do what?
21:09:51 <sorear> master_baiter: not much of an option at my age :)
21:09:54 <dons> master_baiter: how's the haskell hacking coming along?
21:10:08 <sorear> dons: misunderstand
21:10:12 <master_baiter> sorear how old are you?
21:10:20 <sorear> 16
21:10:29 <sorear> pidigits looks good ... testing
21:10:31 <dons> sorear: you want to benchmark ghc v jhc?
21:10:35 <master_baiter> how is it not an option?
21:10:36 <dons> some of them should just be h98
21:10:56 <dons> sorear: the nsieve entry too, I think
21:11:07 <dons> (though maybe with bang patterns, jhc has those, right?)
21:11:22 <chessguy> master_baiter, take it to -blah
21:11:27 <sorear> I think so.  if not, it's obvious how to rewrite it
21:13:47 <sorear> oouch
21:13:57 <sorear> JHC complains:......X.hs:11  - Warning: defaulting:  t280 => Jhc.Basics.Integer
21:14:00 <sorear> (pidigits)
21:14:27 <chessguy> ?remember merlyn maybe time really goes in reverse, and we all have almost no memory and really good precognition
21:14:28 <lambdabot> Done.
21:15:00 <sorear> whqt channel was that on?
21:15:05 <chessguy> #perl
21:15:17 <sorear> (you can tell from my spelling that JHC is running now :) )
21:15:49 <dons> sorear: but we want Integer there
21:15:52 <dons> (I think)
21:16:10 <chessguy> by the way, they just mentioned this book over there: http://hop.perl.plover.com/
21:16:12 <lambdabot> Title: Higher-Order Perl
21:16:15 <chessguy> looks really interesting
21:17:07 <dons> from what I recall, the higher-orderness wasn't terribly intuitive, was it?
21:17:22 <chessguy> "the" higher-orderness?
21:17:30 <dons> i guess any higher orderness is pretty amazing in perl5 (though worth a book??)
21:17:52 <sorear> dons: subrouting references!!
21:17:55 <Pseudonym> The rest of the book is probably examples.
21:18:15 <Pseudonym> Higher-order programming is probably new to most Perl programmers.
21:18:18 <Pseudonym> Despite Pugs.
21:18:19 <chessguy> there's an outline here: http://hop.perl.plover.com/#toc
21:18:21 <lambdabot> Title: Higher-Order Perl
21:18:40 <dons> Pseudonym: sometimes I think oreilly et all just publish the kinds of things that would make good email posts on haskell-cafe@
21:18:43 <sorear> dons: it only took 5 minutes to compile pidigits :)
21:18:47 <dons> hehe
21:18:51 <dons> but how fast does it run!
21:19:58 <vagif> hi, anyone knows a haskell sftp library ?
21:20:20 <dons> is that the ssh-based ftp?
21:20:23 <dons> or a binding to it?
21:20:24 <Pseudonym> http://perl.plover.com/classes/fp/samples/slide025.html
21:20:28 <lambdabot> Title: Syntactic Difficulties
21:20:42 <Pseudonym> Actually, the entire talk is good.
21:20:53 <chessguy> what's the link to the talk?
21:20:55 <dons> ah nice.
21:21:16 <vagif> yes, it is ssh based ftp, and bindings will be good too
21:21:21 <Pseudonym> http://perl.plover.com/classes/fp/
21:21:26 <lambdabot> Title: Functional Programming in Perl
21:21:34 <Pseudonym> I like the picture on the right.
21:21:37 <dons> vagif: so you want a haskell binding to sftp? I don't know of any such library
21:21:47 <Pseudonym> I can only assume that the pure maiden is Haskell and the evil demon is Perl.
21:21:49 <dons> vagif: though wouldn't be too hard to write if you'd like to dive in.
21:22:18 <Pseudonym> http://perl.plover.com/classes/fp/samples/slide006.html  -- This is a typical MJD comment.
21:22:19 <lambdabot> Title: Why functional programming?
21:22:52 <dons> ah nice
21:24:42 <sorear> hmm, JHC actually panicked
21:24:47 <chessguy> "Lazy evaluation is perhaps the most powerful tool for modularisation in the functional programmer's repertoire."
21:24:48 <sorear> Grin.FromE.toType: ELit (Jhc.Order.Bool#::ESort #)
21:24:49 <chessguy> hmmm
21:29:11 <LoganCapaldo> Lazy --> Modularisation?
21:29:12 <sorear> @users
21:29:13 <lambdabot> Maximum users seen in #haskell: 328, currently: 283 (86.3%), active: 27 (9.5%)
21:29:21 <sorear> sure!
21:29:25 <LoganCapaldo> Perhaps you need the context but I don't follow
21:29:46 <dons> chessguy: yeah, laziness lets you decouple components
21:29:52 <dons> much as message passing does
21:30:09 <dons> functions can just stream data between each other, demanding only as much as they need
21:30:10 <chessguy> yeah, but the most powerful?
21:30:15 <chessguy> more so than monads?
21:30:20 <dons> yeah
21:30:25 <dons> you need laziness to do monads properly
21:30:29 <LoganCapaldo> More so than functions?
21:30:35 <dons>  (>>=) x y
21:30:40 <dons> no good if 'y' is demanded strictly now...
21:30:57 <dons> functions don't do much of modularity
21:30:58 <sorear> really!?
21:31:17 <bd_> It's not an issue if y is demanded strictly; after all, y is a function, not a value
21:31:26 <bd_> now if x is demanded strictly, dependingo n the monad, that can be a problem
21:31:27 <sorear> dons: what f >>= is strict in its second arg?
21:31:30 <chessguy> " Monadic programming appears to be impractical in Perl...Only because of syntactic issues"
21:31:37 <dons> ah yes sorry.
21:31:47 <dons> its possible to break the monad laws with particular strictness
21:32:01 <dons> we hit that the other day with a modified State monad
21:32:09 <dons> using (# a ,b #) instead of (a,b)
21:32:29 <LoganCapaldo> functions don't provide modularity? I must be thinking of a different modularity :)
21:33:30 <sorear> modules preovide modulartity!!
21:34:05 <LoganCapaldo> So modules must be more important than laziness :)
21:34:09 <Pseudonym> ?remember GuidoVanRossum Closures aren't important.
21:34:10 <lambdabot> Done.
21:34:28 <LoganCapaldo> Unless you are suggesting we need lazy modules for true modularity? :)
21:34:35 <SamB> modules don't work without laziness...
21:35:17 <jcreigh> Pseudonym: is that an exact quote?
21:35:29 <Pseudonym> Yup.
21:35:34 <Pseudonym> Probably an out-of-context one, but yes.
21:36:08 <sorear> ... now was he talking about closures, thunks, or lambdaforms?
21:36:11 <JohnnyL> in '"data Point = Pt Float Float" :type Pt :: Float -> Float -> Point.... so "data Point =..." really means resulting in Point, correct?
21:36:21 <sorear> right
21:37:03 <Pseudonym> He was talking about closures, but if his actions are anything to go by, lambdaforms aren't important, either.
21:37:32 <LoganCapaldo> I want someone to convince me of this "laziness is the most powerful tool for modularity business"
21:37:36 <Pseudonym> (Closures make sense in imperative languages.)
21:37:49 <LoganCapaldo> err, business should be outside the quotes
21:38:16 <Pseudonym> Well that, of course, is nonsense.  Laziness is the most powerful tool for the modularity, all other things being equal.
21:38:28 <sorear> Pseudonym: wgeb you say "closures", you mean scheme-style functions with lexically captured bindings?
21:38:30 <Pseudonym> You may now say "duh".
21:38:39 <SamB> Pseudonym: duh!
21:38:44 <Pseudonym> sorear: More or less, yes.
21:39:15 <Pseudonym> Lasiness is not the most powerful tool.  Namespaces are kinda important, too.
21:39:43 <Pseudonym> But pretty much every modern language has that.  (C is not a modern language.)
21:40:29 <LoganCapaldo> Pseudonym: C has namespaces. Haven't you heard of the namespace resolution operator? It's spelt "_" ;)
21:40:45 <Pseudonym> :-)
21:40:58 <Pseudonym> I thought it was moduleStudlyCaps
21:41:31 <sorear> M-x customise-group [No match]
21:41:35 <sorear> Help!! :)
21:41:45 <sorear> (I fixed it, but still, ...)
21:43:04 <LoganCapaldo> Pseudonym: Depends on if you're using ANSI namespaces or K&R namespaces ;)
21:43:32 * LoganCapaldo goes to sleep
21:45:14 <Pseudonym> Night.
21:47:20 <newsham> ?quote monad
21:47:21 <lambdabot> Cale says: How much wood would a woodchuck chuck if a woodchuck could chuck monads?
21:47:42 <sorear> ?quote 1866
21:47:43 <lambdabot> xic says: and i imagine that lisp hasn't changed since it's creation in 1866
21:47:49 <Pseudonym> ?quote scheme
21:47:49 <lambdabot> ghc says: Cannot unify a type variable with a type scheme
21:48:03 <Pseudonym> ?quote scheme
21:48:04 <lambdabot> PaulPotts says: Haskell is an even "redder" pill than Lisp or Scheme
21:48:11 <Pseudonym> ?quote ml
21:48:12 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
21:48:19 <Pseudonym> ?quote keal
21:48:20 <lambdabot> No quotes match. You speak an infinite deal of nothing
21:48:34 <jcreigh> On an unrelated note, I really liked Russ Cox's paper on regexes that was recently linked to from LtU. I never really "got" how a non-backtracking regex engine could work until now.
21:48:38 <sorear> haskell has mandatory sanity collection.
21:48:57 <sorear> ?keal
21:48:57 <lambdabot> i just got banned from math because i not have good ability to convey thoughts
21:49:30 <Pseudonym> ?remember sorear haskell has mandatory sanity collection.
21:49:30 <lambdabot> Done.
21:49:55 <jcreigh> so this "keal" fellow...was he/she a troll, or just weird?
21:50:04 <Pseudonym> Just weird.
21:50:10 <Pseudonym> A serious kooj.
21:50:12 <Pseudonym> kook
21:50:13 <Pseudonym> ?keal
21:50:13 <lambdabot> the [nsa] even make light green both ways once
21:50:23 <jcreigh> oh, like xahlee?
21:50:24 <Pseudonym> See?
21:50:27 <Pseudonym> ?xahlee
21:50:28 <lambdabot> Unknown command, try @list
21:50:31 <Pseudonym> Who?
21:50:32 <newsham> ?vixen
21:50:32 <lambdabot> <undefined>
21:50:34 <sorear> @dict-all kooj
21:50:34 <lambdabot> Unknown command, try @list
21:50:41 <sorear> @all-dicts kooj
21:50:43 <lambdabot> No match for "kooj".
21:50:46 <dons> ?help keal
21:50:47 <lambdabot> keal. Talk like Keal
21:50:59 <dons> jcreigh: like xah lee, but funnier
21:51:04 <Pseudonym> ?vixen I am you and you are me and we are all together.
21:51:05 <lambdabot> <undefined>
21:51:06 <sorear> dons: Grin.FromE.toType: ELit (Jhc.Order.Bool#::ESort #)
21:51:41 <dons> ok. bool literal.
21:51:42 <sorear> dons: took me a good ten minutes to notice that was an error call and I have no pidigits binary after all :(
21:51:57 <dons> oh that's an error call ??
21:52:21 <sorear> well, jhc aborts at that point
21:52:24 <dons> and this is why it bugs me when Bulat tells people to use jhc "for the speed"
21:52:44 <dons> i think a nightly shootout run would end all pointless compiler advocacy ;)
21:53:08 <newsham> cron it up ;-)
21:53:09 <jcreigh> isn't GHC the most production-ready Haskell implementation?
21:53:11 * sorear caricatures ndm
21:53:17 <dons> jcreigh: very much so.
21:53:53 <dons> i'll just set it up on a linux x86 box I've got down here
21:53:54 <sorear> oh yeah well yhc -O11 will make jhc obsolete
21:54:00 * sorear stops caricaturing ndm
21:54:06 <dons> and we can compare hugs/ghc/jhc/yhc
21:54:15 <dons> on the shootout examples to start with
21:54:21 <dons> and then we can add more as time goes on
21:54:31 <dons> should be able to hack it up to get a ghc v hugs run tonight
21:54:44 <sjanssen> can yhc and jhc even compile shootout programs?
21:54:47 <dons> i've got an nhc and hbc build on that box
21:54:54 <dons> sjanssen: probably less than half of them
21:55:04 <dons> jhc might have the advantage there
21:55:05 <sorear> just for laughs, how about adding hbc, nhc, yalehc, ..
21:55:12 <dons> yeah, i've got hbc and nhc
21:55:24 * allbery_b can't help but think "ours goes up to eleven"...
21:55:26 <dons> no yale haskell though
21:55:34 <sjanssen> dons: ancient ghc releases would be fun too
21:55:47 <dons> yeah. ideally i'd like to compare nightly ghc snapshots against the stable branch
21:55:48 <sjanssen> if you can manage to compile them
21:55:57 <dons> to give simon's some numbers to keep them motivated ;)
21:56:11 <sorear> yeah, I got to tell someone on the ML that upgrading through 10 years of GHC would help with performance
21:56:20 <dons> heh
21:56:30 <sorear> they were having performance problems with "GHC 2.6"
21:56:33 <sjanssen> good old ghc 2.6
21:56:35 <allbery_b> that was on cafe, no?
21:56:38 <dons> looks like the oldest ghc i've got installed atm is 6.0
21:56:46 * allbery_b doesn't read any ML lists
21:56:47 <dons> but i should be able to get 4.08.2 up
21:57:03 <sorear> what language is 0.29 written in?
21:57:06 <allbery_b> but "2.6" was mildly amusing
21:57:07 <dons> haskell
21:57:32 <dons> there was a bit of miranda, i think, back in the early days
21:57:53 <dons> the story is a bit cloudy before 1990
21:58:21 <sorear> were there any haskell 98 compilers back before 1998?
21:58:33 <sorear> :)
21:58:33 <dons> there were haskell B compilers
21:58:59 * jcreigh is waiting for Haskell 98SE :)
21:59:01 <sorear> get LML back on the shootout!!
21:59:23 <dons> sorear: that's hbc though (still comes with an lml binary)
21:59:37 <jcreigh> Operating systems get patches. Why not languages?
21:59:51 <sorear> ooh.  is the source to lml still extant/compilable?
22:00:02 <sorear> (or to you need a copy of lml to build lml?)
22:00:08 <sorear> s/to/do/
22:06:20 <Pseudonym> I believe that GHC was bootstrapped with Gofer.
22:06:35 <Pseudonym> But I'm not 100% certain.
22:07:22 <skew> I'm wondering about functional graph data structures. If you have a designated current node, can you support some editing around the node and moving to a neighbor in constant time?
22:07:31 <allbery_b> hm, I recall a past mention somewhere that it was bootstrapped from miranda.  otoh I am but an egg
22:07:33 <Pseudonym> ?where FGL
22:07:34 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
22:07:37 <Pseudonym> skew: Look there.
22:07:40 <allbery_b> (and a braindead on at the moment)
22:07:55 <Pseudonym> Might have been Miranda, yes.
22:08:15 <skew> I'm pretty sure that's log time.
22:08:21 <Pseudonym> Mercury was actually bootstrapped with Goedel.
22:08:29 <Pseudonym> The first code was a Mercury-to-Goedel translator.
22:08:33 <dons> huh
22:08:36 <Pseudonym> And it was only to use Goedel's typechecker.
22:08:45 <Pseudonym> The code itself was executable Prolog.
22:09:05 <Pseudonym> But the translator was to get a working typechecker. :-)
22:12:29 <sjanssen> skew: you could probably do it with DiffArray
22:15:40 <skew> One of Matin Erwig's papers describes something like that
22:15:50 <SamB> leet!
22:17:01 <skew> I'm simulating a graph reduction machine, using IORef for now, but building on a persistent graph type would be nice.
22:18:39 <sjanssen> however, once you start using diffarrays persistently you lose O(1) lookups and updates
22:19:09 <dmead> leeeeet
22:20:09 <sjanssen> > "l" ++ replicate 40 ++ "t"
22:20:10 <lambdabot>  Couldn't match expected type `[Char]'
22:20:29 <sjanssen> I fail
22:20:36 <skew> let
22:23:20 <skew> > let lt e = "l" ++ replicate e 'e' ++ "t" in lt 3
22:23:21 <lambdabot>  "leeet"
22:33:35 <dons> ?yow!
22:33:35 <lambdabot> Send your questions to ``ASK ZIPPY'', Box 40474, San Francisco, CA
22:33:35 <lambdabot> 94140, USA
22:33:55 * dons `ap` (bus home)
22:38:55 <SamB> ?yow!
22:38:55 <lambdabot> Now KEN and BARBIE are PERMANENTLY ADDICTED to MIND-ALTERING DRUGS ...
22:39:49 <Cheery> ?yow!
22:39:50 <lambdabot> UH-OH!!  I put on "GREAT HEAD-ON TRAIN COLLISIONS of the 50's" by
22:39:50 <lambdabot> mistake!!!
22:41:34 <JohnnyL> can anyone give me an example of how to call : absPoint::Point -> Float     absPoint (Pt {pointx = x, pointy = y}) = sqrt (x*x + y y*y)       ?
22:43:51 <JohnnyL> It works in GHC, but not hus.
22:43:58 <JohnnyL> absPoint (Pt 4 5)
22:45:32 <JohnnyL> nevermind it was a comma
22:47:11 <dmead> ?src elem
22:47:12 <lambdabot> elem x    =  any (== x)
22:47:18 <dmead> ?src any
22:47:18 <lambdabot> any p =  or . map p
22:51:05 <dmead> anyone else notice upon emerging haskell-mode for emacs, the ghci binds are gone?
22:51:26 <dmead> ?quote
22:51:26 <lambdabot> sebazzz says: violancia y mutilacion sins sentido gratuitamente
22:51:29 <dmead> ?quote
22:51:30 <lambdabot> S.Behrens says: or maybe she is the Queen of Sciences and he is the Mack Daddy.
22:51:32 <dmead> ?quote
22:51:33 <lambdabot> mauke says: also, int *(*where_is_your_god_now[123])[42];
22:51:37 <dmead> ?quote
22:51:37 <lambdabot> Taral says: But I can do DP in C, which has no RT
22:51:42 <dmead> ?quote
22:51:43 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
22:51:47 <dmead> ?quote
22:51:47 <lambdabot> xic says: and i imagine that lisp hasn't changed since it's creation in 1866
22:51:52 <dmead> ?quote
22:51:53 <lambdabot> twb says: But, I love my job. It's like being in a rock band. i.e. no pay, but fun.
22:52:15 <SamB> ?quote
22:52:15 <lambdabot> beelsebob says: dons: no - just use neil's back end. mmm... neil's arse [don] yes, ndm's back end is the source of all good things
22:52:51 <SamB> ?quote
22:52:52 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
22:53:02 <SamB> ?quote
22:53:02 <lambdabot> GuidoVanRossum says: Closures aren't important.
22:53:07 <SamB> ?quote
22:53:08 <lambdabot> kilimanjaro says: glguy: Maybe shapr will make you a historical landmark and you will get your own preservation society!
22:53:16 <SamB> ?quote
22:53:16 <lambdabot> beelsebob says: dons: no - just use neil's back end. mmm... neil's arse [don] yes, ndm's back end is the source of all good things
22:53:21 <SamB> !
22:53:23 <SamB> ?quote
22:53:24 <lambdabot> bringert says: psicho: so you are saying that your teacher gave you two days to do an assignment in a language you didn't know?
22:53:27 <sieni> argh, guido van rossum is evil
22:53:39 <SamB> ignorant
22:53:41 <Cheery> hehe
22:53:44 <dmead>  ha
22:54:15 <dmead> ?quote
22:54:15 <lambdabot> <erg0t> says: @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
22:54:26 <dmead> ?quote
22:54:26 <lambdabot> adept says: Tried to co-read and co-understand comonads, but got co-re dump
22:54:30 <dmead> ?quote
22:54:30 <lambdabot> math says: 2^20 ~= 10^6
22:54:35 <dmead> ?quote
22:54:36 <lambdabot> huschi_ says: programing in haskell seems a bit frustrating. i'm missing searching for errors :(
22:54:41 <dmead> ?quote
22:54:42 <lambdabot> cjeris says: instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
22:54:45 <dmead> ?quote
22:54:45 <lambdabot> Philippa says: the ivory tower isn't meant for use as a dildo! I stated lazy and not another scheme :-)
22:54:50 <dmead> ha
22:54:52 <dmead> wargames
22:54:53 <dmead> :>
22:57:08 <Cheery> hmm, there's clear method how to convert lambda expressions into combinatorial graphs, anybody knows whether it can be done in reverse with some nifty way?
22:58:31 <dmead> whats a combinatorial graph?
22:58:47 <skew> how about applying the combinators to free variables?
22:59:18 <skew> (S K K) => \x -> S K K x == \x -> (K x) (K x) == \x -> x
22:59:36 <dmead> ?src elem
22:59:37 <lambdabot> elem x    =  any (== x)
22:59:44 <Cheery> hmm, that's nifty.
23:05:46 <sjanssen> @unpl ap const const
23:05:46 <lambdabot> ((\ a _ -> a) >>= \ d -> (\ b _ -> b) >>= \ c -> return (d c))
23:24:29 <Cheery> hmm, virtual machine, registers, data... Hey! Couldn't one see vonNeumann machine as one kind of hilbert space?
23:26:27 <sieni> well, you could embed the tape of a turing machine into a hilbert space
23:26:36 <sieni> actually probably R^2 would be enough
23:27:20 <skew> R is enough
23:27:41 <MarcWebe1> Have you tried webfunctions yet? When running those examples I'm getting Log ThreadId 19, Error: Unneatly closed a thread: <socket: 4>: hWaitForInput: end of file
23:28:49 <MarcWebe1> And when using a tool dog the page appears as expected, but the end of file isn't sent and the connection stays open. Is this a bug or a feature?
23:28:51 <Cheery> so one could translate random-access machine code into a turing tape in hilbert space.
23:29:46 <skew> you could think of the state transition rule as being defined on a subset of hilbert space, but I don't see why
23:33:25 <Cheery> skew: I'm wondering how a program could be turned into a form you can modify with known effects.
23:35:52 <Cheery> side-effects of an usual programs seems so 'random' that there must be simpler form where modifying them would be more mechanical.
23:36:41 <skew> purity really helps there
23:37:51 <skew> Even without purity, algebra seems to help
23:51:33 <cjs> Hey, I have a question about playing with the interpreter. If I want to write an expression using functions from the Prelude and functions from the List module, how can I do this?
23:51:56 <sieni> with which interpreter? ghci?
23:52:15 <cjs> It seems in Hugs that if I ":load List" I lose access to the Prelude functions, and then when I ":module Prelude" I lose access to  the list functions.
23:53:20 <sieni> Prelude is loaded automatically in ghci and you can add List functions by :m +List
23:54:32 <cjs> ":m+ List" gives me, "ERROR - Cannot find module "+List""
23:54:43 <sieni> well, hugs is not ghci
23:54:49 <sieni> .'. Use ghci
23:55:33 <cjs> Ah. Is there any way to make ghci give me the nice type output that Hugs gives me when I type something wrong, or just a bare function name?
23:56:02 <cjs> Oh, I guess it's that type description in between the parens after "Show"?
23:57:55 <dons> Hugs.Base> :l List
23:57:55 <dons> List> intersperse ' ' (reverse  "haskell")
23:57:55 <dons> "l l e k s a h"
