00:08:46 <dons> boo, upmod! http://programming.reddit.com/info/15bqg/details
00:08:47 <lambdabot> Title: Ask Moggi: what is a monad? (ps.gz) (reddit.com)
00:10:38 <earthy> sorry, I didn't think that paper was terribly good, from the point of view of wanting to practically program using monads
00:12:22 <dons> yeah, i know ;)
00:15:34 <xpika> can someone explain the effective difference between 'io x = liftIO x' and 'io = liftIO'
00:16:10 <dons> there are some type inference issues that can kick in
00:16:38 <xpika> what is actually happening?
00:16:51 <ski_> in the latter, if no type signature is given, monomorphism restriction kicks in any denies it from being overloaded
00:16:53 <dons> is the point that io = liftIO doesn't type check?
00:17:01 <ski_> (s/any/and/)
00:17:45 <pjd> weird:
00:17:45 <pjd> foo x = print x -- :: (Show a) => a -> IO ()
00:17:45 <pjd> bar = print -- :: Integer -> IO ()
00:17:54 <ski_> defaulting
00:18:07 <ski_> it defaults the overloading to 'Integer'
00:18:48 <ski_> (there's a 'default' keyword one can use to specify what defaults to try, but i can't remember how to use it)
00:18:48 <kfish> dons: bibtex entry added to http://www.haskell.org/haskellwiki/Frag
00:18:50 <lambdabot> Title: Frag - HaskellWiki
00:18:51 <xpika> why is it that the former is more polymorphic than the latter
00:19:42 <ski_> xpika : because they thought it could be unintuitive (especially to beginners) if the latter wasn't cached
00:20:19 <xpika> CAF?
00:21:37 <ski_> with the dictionary-passing implementation of overloading, assuming no monomorphism restriction, the latter would be expanded to something like 'io dictMonadIO = liftIO dictMonadIO'
00:22:45 <ski_> assume you had 'io = ...' where '...' is a big expensive thing to compute, with no monomorphism resitriction, (and using this implementaion) this would become 'io dict = ...'
00:22:49 <xpika> ski_: i dont understand how thats a problem
00:23:17 <xpika> ah, i see
00:23:17 <ski_> so the result of computing this expression wouldn't be cached since this would act as a function, and not as a lazy cached thunk
00:24:07 <ski_> so, solely to get the "expected" result, i.e. cached, when you have a binding with no arguments, they imposed the monomorphism restriction
00:24:10 <ski_> clear ?
00:24:14 <xpika> thanks ski_, i believe that all bindings should be dynamic and explicitly being told not is intuitive.
00:24:34 <ski_> 'dynamic' meaning 'not cached' ?
00:24:40 <xpika> yep
00:24:51 <xpika> like virtual
00:25:26 <xpika> it requires a table lookup
00:25:46 <ski_> i think Clean has something in that way .. or at least it is similar .. they use ':=' (or maybe ':==' or '::=' for cached binding) otherwise it acts as function binding, i.e. no cache of result  (iirc, at least)
00:26:02 <xpika> interesting.
00:29:48 <xpika> do most haskell experts get their info from reading papers? or reading source code.
00:33:59 <araujo> xpika, easy question
00:34:03 <araujo> xpika, from both
00:34:04 <araujo> :-)
00:34:55 <sorear> muahaha ... writing GMP bindings in haskell is fun
00:35:44 <sorear> reading rts/PrimOps.cmm is suprisingly easy
00:38:09 <ddarius> Usually most of the source is in the papers.  But, for me, I only really go to the source for specific technical things, usually the things I'm interested in wouldn't be too well served by source code.-
00:39:02 <sorear> unsafeCoerce# :: Int# -> ByteArray#  -- what fun!
00:39:29 <araujo> sorear, :-)
00:39:33 <araujo> FFI?
00:39:51 <sorear> araujo: I am using the FFI, but that's a GHC primop
00:40:07 <sorear> unsafe memory cast - the ultimate hacker's tool
00:40:24 <sorear> who needs types?
00:41:11 <sorear> anyway - fib :: Int -> Integer
00:41:21 <sorear> write that, the fastest way possible.
00:41:32 <sorear> we've had a half dozen proposals
00:41:58 * ddarius wanted to make a program that did some crazy thing when using a type unsafeCoerce#'d from some other incompatible type for IOHCC.
00:42:01 <Saizan> and you are going to use GMP?
00:42:16 <sorear> yes.
00:42:55 <ddarius> sorear: Incidentally, the "closed form" is still O(log n)
00:43:09 <sorear> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022647.html  -- would also make a good "unportable haskell" entry
00:43:11 <lambdabot> Title: [Haskell-cafe] speeding up fibonacci with memoizing, http://tinyurl.com/2edg3o
00:43:15 <sorear> ddarius: heh?
00:43:17 * kc5tja wonders how Haskell would function on a typical 8-bit home computer of the 1982-1989 era.  Assuming at least 32K of available RAM of course.  :)
00:43:25 <sorear> ddarius: fib(n) requires O(n) bits
00:43:43 <sorear> ddarius: are you telling me you've written a sublinear memcpy?
00:44:28 <kc5tja> Oh well -- I'm just being silly.  Too tired.  Going to bed.
00:45:10 <ddarius> Calculating only the nth not all the ones up to then.
00:46:00 <sorear> ddarius: fib(n) takes log(fib(n)) bits =~ n * log(phi) = O(n)
00:46:25 <sorear> shapr has "ran IOHCC" on resume, wow.
00:47:46 <ddarius> I'm counting arithmetic operations.
00:49:15 <pjd> heh
00:49:18 <pjd> O measures should always be qualified
00:51:04 <Saizan> and count operations with homegeneus cost
00:59:21 <Stinger> @paste
00:59:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:59:39 <sorear> what's the progress of that project (Phd?) to add uniquess types to GHC?
00:59:55 <dons> hmm? benl's thesis?
01:00:04 <hpaste>  Stinger pasted "time bug?" at http://hpaste.org/554
01:00:45 <dons> hey, sorear does that gmp binding actually work??
01:00:53 <Stinger> can someone test that, see if you get an exception?
01:01:14 <sorear> dons: if you're lucky
01:01:37 <sorear> dons: == have a 32-bit machine and miss the garbage collector
01:02:04 <dons> oh, you mean as long as GC doesn't happen?
01:02:04 <sorear> you're referring to the code I sent to the ml?
01:02:11 <dons> or i have to compile out the GC?
01:02:15 <dons> yeah, the libgmp code
01:02:41 <sorear> dons: yeah.  since the gc might move the array before I have a chance to tell the gc I have a pointer.
01:02:57 <goltrpoat> http://ofb.net/~wnoise/haskell/IOHCC/ulfn/doc.ps -- "all haskell programs are alpha-equivalent"
01:02:57 <goltrpoat> hehe
01:03:10 <sorear> I'll have to study the primop code closer to see how the gc is neutralised
01:10:23 <Stinger> hmmm where can I use case of?
01:12:04 <pjd> Stinger: any expression?
01:12:28 <Stinger> yeah I had to put parens around it
01:13:12 <Stinger> I figured you should be able to somehow, haskell being totally functional
01:18:08 <Stinger> yeah seems addToClockTime doesnt like TimeDiffs with large negative picoseconds, at least on windows under ghc 6.6
01:24:25 <edwinb> dons: was just bored again last night ;)
01:25:46 <sorear> fun quotes from the RTS code: /* ToDo: this is shockingly inefficient */
01:26:08 <sorear> on the fact the ghc uses a small collection of static global mpz_t's
01:30:58 <EvilTerran> http://www.google.com/codesearch?q=shocking
01:31:00 <lambdabot> Title: shocking - Google Code Search
01:38:02 * sorear thinks he's found a bug in the storage manager (looking at the code) ... I hope it exists, else I don't understand it
01:38:59 <xpika> can you lift IO in an ST monad?
01:39:12 <sorear> unsafely
01:39:24 <xpika> thought so
01:41:52 <xpika> is there any efficiant way of emulating globals in haskell?
01:42:31 <Baughn> xpika: Why do you want to?
01:43:42 <Saizan> mmh closures of IORefs?
01:44:39 * osfameron starts to journal learning haskell at http://osfameron.vox.com/library/post/on-learning-haskell.html
01:44:59 <osfameron> (sorry - I should have asked if it's ok to pimp a link, but it's on topic at least :-)
01:47:34 <hpaste>  xpika pasted "emulating globals" at http://hpaste.org/555
01:48:13 <xpika> can anyone improve on that?
01:50:19 <xpika> basically just a big data type with a bunch of IORef records in it
01:50:39 <Baughn> xpika: Why not make the global an IORef Global instead?
01:51:05 <Baughn> Mind you, this isn't a lot of data; I'm curious as to why you feel you need a mutable variable at all.
01:51:29 <xpika> unfortunantly that works for reading well but really bad for updating
01:52:42 <Saizan> osfameron: i concur that yaht is often confusing :)  i think i've started to grok haskell only when i came to this channel and followed discussions and code snippets
01:53:27 <Baughn> xpika: It just means that you have to update all of them at once instead of just one
01:54:42 <Baughn> xpika: Looks to me like the whole thing is smaller than even an L1 cache-line, which makes that a nonissue
01:56:40 <hpaste>  xpika annotated "emulating globals" with "(no title)" at http://hpaste.org/555#a1
01:56:54 <osfameron> Saizan: I remember the first discussion of Monads, where has say something like "Obviously when you see a type like IO Integer, the first thing you want to do is get rid of the "IO", which wasn't at all clear :-)  Having said that, the exercises were very good, as far as I followed them.
01:59:49 <sorear> must sleep, bye
01:59:56 <Baughn> @type (newIORef 0)
01:59:59 <lambdabot> Not in scope: `newIORef'
02:01:02 <xpika> i dont think lambdabot likes us declaring IORef's
02:01:05 <Saizan> that reminds me that i've never finished it, the CPS chapter was quite foreign for me at the time and i got bored on the array,list,map comparisnon..
02:01:10 <xpika> > x <- 1
02:01:10 <lambdabot>  Parse error
02:01:35 <vvv> > 7 * 6
02:01:37 <lambdabot>  42
02:01:48 <Baughn> xpika: You forgot the do. Anyhow, you might be right, but I remember reading something about IORefs not being typesafe, once upon a time.
02:02:07 <xpika> > newIORef 3 >>= readIORef
02:02:08 <lambdabot>   Not in scope: `readIORef'
02:02:31 <xpika> > runST ( newIORef 3 >>= readSTRef )
02:02:32 <lambdabot>   Not in scope: `readSTRef'
02:02:42 <xpika> :(
02:02:44 <sorear> Baughn: unsafePerformIO is typesafe. IORef is typesafe.  the combination is *not*
02:02:50 <xpika> now that's just mean
02:03:07 <sorear> xpika: dons declared that State is good enough for anybody
02:03:37 <sorear> xpika: and he doesn't seem to think not importing unsafeIOtoST is enough
02:03:41 <xpika> runStateT ( get ) 3
02:03:51 <xpika> > runStateT ( get ) 3
02:03:52 <lambdabot>   add an instance declaration for (Show (m (s, s)))
02:04:02 <sorear> > runState get 3
02:04:04 <lambdabot>  (3,3)
02:04:17 <Baughn> @type runState
02:04:20 <lambdabot> forall s a. State s a -> s -> (a, s)
02:04:26 <sorear> Baughn:
02:04:36 <sorear> @docs System.IO.Unsafe
02:04:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
02:04:38 <xpika>  > runStateT ( get ) 3
02:04:52 <sorear> Baughn: ^^^ read the haddock for unsafePerformIO
02:05:03 <xpika> > runStateT ( put 4 >> get 3 ) 3
02:05:04 <lambdabot>   add an instance declaration for (Show (m (a, s)))
02:05:15 <xpika> > runStateT ( do { put 4 ; get 3 }) 3
02:05:16 <lambdabot>   add an instance declaration for (Show (m (a, s)))
02:05:50 <Baughn> @docs runStateT
02:05:51 <lambdabot> runStateT not available
02:06:48 <fuzan> i've been frustrating myself with bncf for the past couple hours. i'm trying to define the grammar for a c-like language in which you have to variables must be defined before any expressions/functions. my problem however is that functions and variables both consume a "Type" terminal, in which case if I define any variables before a function my parser dies upon reaching the '(' (since it's trying ot make a variable )
02:07:07 <xpika> > runStateT ( put 4 >> get ) 3
02:07:08 <lambdabot>   add an instance declaration for (Show (m (s, s)))
02:07:31 <xpika> > runState ( put 4 >> get ) 3
02:07:33 <lambdabot>  (4,4)
02:07:39 <xpika> what does the T do?
02:07:44 <quicksilver> Transformer
02:07:58 <quicksilver> StateT is a monad transformed, you apply it to another 'base' monad
02:07:59 <xpika> as apposed to ?
02:08:08 <xpika> such as IO?
02:08:11 <quicksilver> that's what the 'm' in in the show m (s,s) was
02:08:15 <Baughn> xpika: As opposed to State, for example
02:08:16 <mux> runStateT (modify (+1) >> liftIO $ putStrLn "incremented") 3
02:08:17 <quicksilver> yes, for example
02:10:58 <xpika> mux:   No instance for (MonadState s ((->) (IO ())))
02:11:48 <pjd> osfameron: SoE?  great stuff :)
02:12:22 <int-e> xpika: runStateT (modify (+1) >> (liftIO $ putStrLn "incremented")) 3 >>= print
02:16:52 <osfameron> pjd: yeah
02:17:29 <xpika>  runStateT (modify (+1) >> (liftIO $ putStrLn "incremented")) 3 -- yep extra brackets needed
02:18:47 <xpika> i really need to understand the diff between () and $
02:19:16 <Lemmih> @type ($)
02:19:19 <lambdabot> forall a b. (a -> b) -> a -> b
02:19:19 <Lemmih> @type ()
02:19:22 <lambdabot> ()
02:19:22 <xpika>  runStateT (modify (+1) >> liftIO ( putStrLn "incremented") 3
02:19:31 <pjd> foo (bar ...) <=> foo $ bar ...
02:19:32 <pjd> sort of
02:20:06 <int-e> xpika: the problem is that (modify (+1) >> liftIO $ putStrLn "incremented") gets parsed as  ((modify (+1) >> liftIO) $ putStrLn "incremented")
02:20:16 <int-e> xpika: because >> binds stronger than $.
02:20:59 <pjd> everything binds more strongly than $, innit?
02:21:17 <xpika> int-e: and () binds the strongest?
02:21:19 <osfameron> pjd, anyone else who has a second: http://osfameron.vox.com/library/post/chapter-1-of-hudaks-haskell-school-of-expression.html  (I know that this is rather a dull entry, but my question is... do you think this is reasonable in terms of "Fair use" quoting?  I think it's respectful, and I'm promoting the book, but please let me know if you think I'm exaggerating)
02:21:22 <lambdabot> http://tinyurl.com/2flw6s
02:21:48 <xpika> ok, now all i have to do is remember the precendence levels
02:21:49 <int-e> xpika: for (...), binding is irrelevant - ( groups until the matching closing ).
02:22:15 <quicksilver> best thing is to use () when unsure
02:22:28 <quicksilver> $ is an overused hack for reducing the number of (), that's all
02:22:43 <quicksilver> I use it too much myself :) but if you're feeling doubtful, bracket by hand
02:22:53 <pjd> osfameron: about the ghci thing, you have to prefix definitions with "let"
02:22:58 <pjd> as in: let simple x y z = x * (y + z)
02:23:08 <int-e> quicksilver: do you lean towards   a . b $ c, a $ b c or a $ b $ c?
02:23:10 <pjd> the reason for this is that ghci is in an implicit do block
02:23:13 <xpika> its funny because thats maths aswell
02:23:18 <quicksilver> a . b $ c
02:23:21 <quicksilver> or (a . b) c
02:23:22 <xpika> bracket when unsure
02:23:24 <pjd> so it's not exactly like top-level haskell
02:23:54 <osfameron> pjd: Ah!  I even remember working that out at one point.  Thanks!  I'll update it
02:24:12 <siti> I love $ :D
02:24:27 <pjd> hmm, the ghci let thing needs to be in some FAQ
02:24:52 <vincenz> meurning
02:25:23 <xpika> whats the default precedence of an infix function?
02:25:32 <fuzan> anyone play with bncf much?
02:25:38 <fuzan> left is generally preferred.
02:26:10 <fuzan> 1 - 3 - 4 = -6
02:26:36 <Thunder> siti: a . b $ c has the advantage to abstract to foo = a . b, which is not possible with $
02:26:43 <Thunder> :t id . id
02:26:45 <lambdabot> forall a. a -> a
02:26:50 <Thunder> :t id $ id
02:26:53 <lambdabot> forall a. a -> a
02:27:07 <Saizan> id is a bad example of this :)
02:27:23 <fuzan> ohh, you said precedence...
02:27:25 <fuzan> i'm too tired ^_^
02:27:26 <Thunder> Of course. But it work differnet.
02:27:54 <Thunder> :t (+1) . (+1)
02:27:55 <pjd> osfameron: heh, who says you can't type those symbols? that's what combining keys are for :)
02:27:56 <lambdabot> forall a. (Num a) => a -> a
02:28:01 <Thunder> :t (+1) $ (+1)
02:28:03 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a
02:29:05 <pjd> for example, "C-K ->" for ‚Üí in vim
02:32:23 <osfameron> pjd: heh.  And whaddaya know, I can't see the "nice" symbol in irssi/screen/putty
02:32:48 <pjd> well, you should be using UTF-8 :P
02:33:30 <psnl> is ghc in darcs on darcs.haskell.org?
02:33:36 <osfameron> right, I've just changed putty session to utf8 and I still can't see that
02:33:45 * osfameron hates utf8...
02:33:51 <psnl> ok, silly question
02:33:56 <pjd> osfameron: you'll need to change screen to utf8 as well
02:33:58 <osfameron> it will surely take over the world WHEN IT ACTUALLY JUST-WORKS
02:34:09 <osfameron> pjd: I startted it with screen -U or whatever
02:34:17 <osfameron> this worked yesterday... I'm sure
02:34:33 <pjd> hate the bad implementations, not the concept!
02:34:42 <osfameron> √®√†√≤
02:34:53 <osfameron> ok, I can see those.  Can you hit me with another arrow?
02:35:03 <int-e> ‚áí
02:35:04 <pjd> ‚Üí
02:35:05 <earthy> it does here. Œª x y z ‚Üí x z ( y z )
02:35:28 <osfameron> gah.  Can't see those.  I can see the lambda, but not the arrows
02:35:33 <earthy> ‚Üê ‚Üë ‚Üì ‚Üí ‚Üî ‚áê ‚áî ‚ûî ‚û§
02:35:38 <osfameron> yeah, it's the implementation that sucks
02:35:39 <osfameron> non of those
02:35:45 <earthy> those were all arrows.
02:35:47 <int-e> ‚Üó ‚Üò ‚Üô ‚Üñ :)
02:36:01 <earthy> ‚â§ ‚äÇ ¬¨ ‚àà
02:36:01 <xpika> is there any way i can get GHC to proccess  ‚Üê as <- ?
02:36:07 <osfameron> then again I see them as [box]FW, [box]FX etc.
02:36:22 <earthy> xpika: use CPP to transform ‚Üê into <-
02:36:23 <osfameron> so maybe it's just that my font doesn't include them
02:36:29 <xpika> CPP?
02:36:38 <earthy> the C preprocessor. :)
02:36:39 <quicksilver> the C Pre Processor
02:36:49 <earthy> yes, it's a nasty hack
02:36:54 <xpika> how can i envoke it?
02:36:56 <osfameron> either way, I think it's insane to use unicode in programming language source until all of these just work transparently and nicely everywhere
02:36:59 <JohnMeacham> anyone have some hidden markov model code for haskell?
02:36:59 <dons> get your haskell benchmarks, http://www.cse.unsw.edu.au/~dons/nobench.html
02:37:00 <lambdabot> Title: nobench : benchmarking Haskell implementations
02:37:02 <pjd> earthy: ick
02:37:08 <xpika> gcc file.hs ?
02:37:14 <JohnMeacham> or anything that will aid in handwriting recognition actua
02:37:30 <earthy> nope, ghc -cpp
02:37:38 <JohnMeacham> actually. I have this tablet pc thing that is annoying the hell out of me.
02:38:02 <pjd> isn't there a GHC option or patch for unicode symbols?
02:38:17 <xpika> umm.. has anyone got a pre made header file for the chars :)
02:38:22 <xpika> plz.
02:38:26 <JohnMeacham> I am thinking a personally trained HMM could make it decent. I don't mind training it. if it improves accuracy to the point I don't have to double check everything it does.
02:38:30 <osfameron> JohnMeacham: run Maemo Internet Table OS on it!  Oh, wait, the handwriting recognition on that is probably even worse...
02:38:40 <JohnMeacham> so funny.
02:38:41 <doserj> John: http://citeseer.ist.psu.edu/goblirsch94software.html
02:38:42 <lambdabot> Title: A Software System for Training Phonetic Hidden Markov Models - Version 2.0 - Gob ...
02:38:47 <JohnMeacham> i am talking about my nokia 770.
02:39:10 <osfameron> JohnMeacham: ah!  You said tablet PC :-)  I have an N800, the recognition is terrible
02:39:34 <JohnMeacham> I already wrote a better keyboard for it. and I ported jhc specifically to it to write haskell programs for it. now I want to write some better UI for the thing.
02:40:02 <pjd> xpika: aha: http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
02:40:05 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
02:40:13 <osfameron> JohnMeacham: is your jhc port packaged anywhere?  Oh, for 770, don√'t suppose that'll work unmodified on N800
02:40:22 <JohnMeacham> sort of like graffiti, but actally based on reporters shorthand, they used to tecah it in schools, it is designed to be damn fast to scribble atd I think it would be an excellent tablet input language.
02:40:29 <pjd> xpika: apparently jhc supports it, and ghc with -fglasgow-exts
02:41:19 <JohnMeacham> should work on the N800. I don't have one. I think I might have had to tweak the headers a little. but it pretty much just worked.
02:41:59 <osfameron> ok, I'll have to play with scratchbox in my CFT
02:42:29 <JohnMeacham> the N800 has a floating point unit. you don't know how important a floating point unit is until you dont' have one. sigh.. hey, what sort of XInput events does the N800 give you? does it do tilt? or just pressure?
02:43:02 <osfameron> no idea, sorry.  Are you on #maemo ?
02:43:02 <JohnMeacham> can you send me the output of /proc/cpuinfo? I am really curious. john@foo.net
02:43:11 <JohnMeacham> no. I'll join.
02:44:27 <JohnMeacham> ooh. that paper looks interesting. am reading.
02:45:33 <JohnMeacham> I already have a basic recognizer. but it is not aethetically pleasing. and I always wanted to get into the guts of hidden markov models. seems like a good excuse.
02:48:01 <xpika> #define ‚Üê <-
02:48:10 <xpika> new.hs:1:0:  error: macro names must be identifiers
02:51:39 <pjd> so much for cpp :)
02:51:50 <pjd> have you tried -fglasgow-exts ?
02:52:46 <xpika> i cant get -fglasgow-exts to work with runhaskell
02:52:56 <xpika> or runghc
02:55:11 <xpika> pjd: but yes ghci -fglasgow-exts does work
02:55:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/556
02:55:57 <abz> I got -fglasgow-exts to work with runhaskell
02:56:09 <abz> see hpaste
02:57:43 <abz> I not sure that that proves that the flag was used though
02:57:59 <xpika> ok that works but i was envoking it through the command line
02:58:27 <abz> what command were you running?
02:58:38 <abz> I use: >./test.hs
02:58:41 <xpika> runhaskell -fglasgow-exts new.h
02:59:00 <xpika> abz: ?
02:59:09 <xpika> oh yea
02:59:24 <abz> I just put that in a file and ran the file at the command line
02:59:25 <xpika> she bang shell script
03:01:28 <JohnMeacham> she bang zsh script.
03:02:30 <goban> > mapM (\x->[x+i | i<-[-5..5]]) [1..5]
03:05:50 <xpika> where can i find math symbols in GNOME character map?
03:06:43 <abz> xpika: what do you need then for?
03:06:48 <pjd> xpika: View -> By Unicode block, then search for "math"
03:06:48 <abz> them
03:06:56 <pjd> (in the left list)
03:07:56 <xpika> ùêâ
03:08:02 <xpika> can you see it?
03:08:05 <xpika> I cant
03:08:09 <abz> no.
03:08:16 <xpika> ùêÄùêÅùêÇùêÉùêÑùêÖùêÜùêá
03:08:28 <abz> stop swearing
03:08:33 <xpika> lol
03:08:56 <xpika> i didnt think the  ÔøΩ word was a swear word
03:09:12 <abz> looks like it from here...
03:10:06 <xpika> think the  # word was a swear word
03:10:15 <xpika> ‚ü≤
03:10:18 <pejo> Could we please stop playing with the high characters?
03:10:25 <xpika> ok then
03:11:11 <xpika> I was just thinking how cool it would be to program in dingbats characters
03:13:56 <xpika> ok
03:13:58 <xpika> bye
04:32:36 <goltrpoat> @pl \x (a,b) -> x >= a && x <= b
04:32:37 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (&&)) .) . (>=)) (<=)
04:32:47 <goltrpoat> MY EYES
04:33:55 <Syzygy-> Haha
04:34:05 <Syzygy-> Welcome to pointless obfuscation. ;)
04:34:25 <earthy> @unpl (`ap` snd) . (. fst) . ap (flip . (((.) . (&&)) .) . (>=))
04:34:25 <lambdabot> (\ l -> (\ ag -> ((\ x d e h -> (x >= e) && (d h)) >>= \ q -> l >>= \ p -> return (q p)) (fst ag)) >>= \ al -> snd >>= \ ak -> return (al ak))
04:34:37 <earthy> damn. that makes it worse :)
04:35:26 <quicksilver> well the reason that makes it worse is that @pl hides the monad
04:35:37 <quicksilver> then unpl has to 'unpl for general monad'
04:35:42 * earthy nods
04:35:44 <quicksilver> :t \x (a,b) -> x >= a && x <= b
04:35:46 <lambdabot> forall a. (Ord a) => a -> (a, a) -> Bool
04:35:55 <quicksilver> :t (`ap` snd) . (. fst) . ap (flip . (((.) . (&&)) .) . (>=))  (<=)
04:35:57 <lambdabot> forall a. (Ord a) => a -> (a, a) -> Bool
04:36:59 <goltrpoat> i just used unsafeCoerce three times in a row, maybe i should add the unpl (pl (\x (a,b) -> x >= a && x <= b)) to it to top it off
04:37:05 <quicksilver> well unpl doesn't "have to"
04:37:23 <quicksilver> but it does, since it is doesn't have the full inferrer built in
04:37:36 <quicksilver> so it doesn't infer the monad (although it could in principle)
04:37:47 <goltrpoat> which monad?
04:37:59 <quicksilver> it was the reader monad (r ->) I think
04:38:39 <goltrpoat> where though
04:38:54 <quicksilver> in the `ap`
04:38:56 <goltrpoat> :t (`ap` snd)
04:38:59 <lambdabot> forall b a b1. ((a, b1) -> b1 -> b) -> (a, b1) -> b
04:39:10 <goltrpoat> no monad :)  the snd restricts it to Reader
04:39:13 <quicksilver> right
04:39:17 <quicksilver> but unpl can't see that
04:39:38 <quicksilver> so, unpl is using the generic unpacking of `ap`
04:39:43 <quicksilver> @src ap
04:39:43 <lambdabot> ap = liftM2 id
04:39:49 <goltrpoat> oh i see what you mean
04:40:01 <quicksilver> that's where the returns and >>= come from
04:40:45 <goltrpoat> i thought you were saying that the inferred type of the result of pl was less general than it should be
04:40:47 <goltrpoat> makes sense now.
04:41:23 <quicksilver> no, I was saying that unpl doesn't notice when the inferrable type is constraints, and uses general rules for reasoning about 'ap' even when it could use specific expansions for the monad in question
04:41:29 <goltrpoat> -nod-
04:43:43 <ivanm> I'm passing through (^2) as an (Int -> Int) function, but when compiling with -Wall it says that its defaulting to Integer constraints... how can I resolve this?
04:43:44 <syntaxfree> suppose I want to do some very basic HTML parsing.
04:43:50 <syntaxfree> I want to extract title tags and links.
04:44:07 <syntaxfree> Should I use HaXML or roll my own in Parsec?
04:44:19 <Cale> syntaxfree: I'd use HXT.
04:44:25 <syntaxfree> HXT.
04:44:28 <syntaxfree> okie!
04:44:29 <syntaxfree> thanks.
04:44:45 <Cale> It's a little strange at first, but once you know it, it's very nice.
04:45:03 <syntaxfree> yeah. my use will be very light anyway.
04:45:24 <Cale> The documentation is a little scary at first, you're better off not reading it all and just looking for the relevant bits. There's a tutorial on HXT on the wiki.
04:45:32 <resiak> @where HXT
04:45:33 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
04:45:41 <syntaxfree> hmm. an arrow interface. Scary.
04:45:56 <Cale> It's really a monad disguised as an arrow for the syntax.
04:46:07 <Cale> Because most of the time, you
04:46:14 <Cale> are putting things together with >>>
04:46:31 <syntaxfree> I can't get my head around proc syntax yet.
04:46:59 <Cale> It's easier if you don't think too hard about it :)
04:47:11 <syntaxfree> too many arrow thingies.
04:47:18 <syntaxfree> proc >- do this <- do that
04:47:29 <Cale> You just understand it in terms of flow of data, and not how it actually is going to desugar.
04:47:58 <syntaxfree> I understand dataflow better in comonadic form
04:48:11 <Cale> http://haskell.org/arrows/syntax.html -- this has pretty diagrams which I made :)
04:48:12 <lambdabot> Title: Arrow syntax
04:48:31 <Cale> Perhaps they'll help to understand :)
04:48:34 <ivanm> @t (^2)
04:48:34 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
04:48:41 <ivanm> @type (^2)
04:48:43 <lambdabot> forall a. (Num a) => a -> a
04:49:32 <Cale> ivanm: If you're having trouble with defaulting, you might just try the -fno-monomorphism-restriction tag.
04:49:47 <ivanm> Cale: what does that do?
04:50:02 <syntaxfree> it lifts the monomorphism restriction ; )
04:50:31 <Cale> It turns off a silly restriction which forces pattern bound variables to be monomorphically typed unless their types are explicitly given as polymorphic.
04:50:48 <Cale> so if you wrote:
04:50:51 <Cale> square = (^2)
04:51:02 <syntaxfree> Cale: jesus, this HXT thing is a monster.
04:51:13 <syntaxfree> I just wanted to get title and href tags.
04:51:21 <ivanm> Cale: I have (^2) being passed as a parameter to a function that expects (Int -> Int), but the compiler seems to default it to Integral...
04:51:23 <Cale> The MR would say "that has to be monomorphic", and then defaulting would kick in, and it would get Integer -> Integer as type.
04:51:33 <Cale> syntaxfree: hehe
04:51:39 <ivanm> I would have thought that it would have worked out that its meant to be Int, not Integral
04:51:41 <Saizan> there's a specific example on getting them in the tutorial
04:51:51 <Cale> syntaxfree: Let me write you an example.
04:51:55 <syntaxfree> this HXT thing basically cures cancer with XSLT transformations, it seems.
04:52:19 <syntaxfree> There's a general interface to XML, for which a cancer cell interface can be built, and then you just morph it into a healthy cell.
04:52:50 <Syzygy-> syntaxfree: ??
04:53:06 <syntaxfree> Syzygy: http://en.wikipedia.org/w
04:53:09 <syntaxfree> Syzygy: http://en.wikipedia.org/wiki/Humor
04:53:10 <lambdabot> Title: Humour - Wikipedia, the free encyclopedia
04:53:10 <EvilTerran> syntaxfree, i know exactly what you mean
04:53:46 <Saizan> http://www.haskell.org/haskellwiki/HXT#Selection_examples <-- ah, no, it's text and alt
04:53:48 <lambdabot> Title: HXT - HaskellWiki
04:54:02 <syntaxfree> Saizan: yes, but it's better than what it initially seemed, yes.
04:54:34 <syntaxfree> http://www.haskell.org/haskellwiki/HXT#Selecting_text_and_ALT_attributes_values_.282.29
04:54:37 <lambdabot> Title: HXT - HaskellWiki, http://tinyurl.com/277hfo
04:54:40 <syntaxfree> that's almost what I need.
04:54:56 <syntaxfree> well, let me see if HXT builds, first.
04:55:41 <syntaxfree> I already have HaXml-1.13.2 and HAppS-0.9.0. Could it be pickier than that?
04:56:19 <ivanm> OK, even defining it as  ((^2) :: Int -> Int) still makes Haskell think it's of type Integer
04:57:27 <quicksilver> :t ((^2) :: Int -> Int) $ (4 :: Integer)
04:57:29 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
04:57:29 <lambdabot>     In the second argument of `($)', namely `(4 :: Integer)'
04:57:32 <quicksilver> not for me
04:57:36 <quicksilver> and apparently, not for lambdabot
04:57:59 <syntaxfree> nothing like some dependency chasing early in the morning to kickstart my monday.
04:58:17 <ivanm> @type ((^ 2) :: Int -> Int)
04:58:20 <lambdabot> Int -> Int
04:59:01 <ivanm> Well, I tried that flag Cale suggested... and it ignored the one in my library module, but then complained about the one in my Main module instead :(
04:59:14 <Cale> syntaxfree: you want the hrefs?
04:59:35 <syntaxfree> and title tags. The HXT tutorial in the wiki seems to cover something very close to that.
04:59:36 <ivanm> To be fair, it is n^2, not the function (^2)
04:59:41 <syntaxfree> (it picks the alt tags in imgs)
04:59:51 <quicksilver> ivanm: and, what is n?
05:00:00 <ivanm> quicksilver: an Int
05:00:07 <syntaxfree> apparently HXT is building. Let us pray to the Oh God of Hangovers.
05:00:09 <ivanm> ubCriticalSets n = n^2 - 3*n + 3
05:00:23 <ivanm> with an Int -> Int signature
05:00:38 <quicksilver> what's the exact warning?
05:01:06 <Saizan> ?type  (^)
05:01:10 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
05:01:32 <Saizan> it's that 2 that is defaulting as an Integer
05:01:33 <ivanm> quicksilver:  Defaulting the following constraint(s) to type `Integer',   `Integral t' arising from use of `^'...
05:01:41 <syntaxfree> Cale: I've just learned DOT language and want to draw some link structure graphs with Graphviz.
05:01:53 <ivanm> actually, it still occurs in both cases, the library file was just compiled so it didn't compile it again
05:02:12 <Saizan> in n^i   i isn't forced to have the same type of n
05:02:14 <ivanm> Saizan: oh, yeah, didn't think of that... how can I fix that?
05:02:26 <Saizan> n^(2::Int)
05:02:50 <Cale> Hold on while I build HXT :) I switched to 6.6 since I last used it.
05:03:19 <Cale> I have some code already, but I'd like to actually run it before I give it to you :)
05:03:37 <ivanm> Saizan: thanks! a pity it makes the code busier though...
05:04:04 <syntaxfree> hey, thanks.
05:04:07 <syntaxfree> I'm building it too right now.
05:04:09 <Saizan> ivanm: actually i wouldn't worry of it being a Integer
05:04:40 <ivanm> Saizan: it was just trying to get rid of the warnings from -Wall, that's all... trying to get my code warning free! ;)
05:04:42 <syntaxfree> Maybe I should go hack up the other part of the program, but I'm not sure what data structure to begin with for the DOT compilation. I'd need to know what HXT spits out.
05:04:54 <Cale> syntaxfree: anything that you like.
05:05:07 <Cale> Basically, it'll probably give you a title and list of URLs.
05:05:30 <syntaxfree> Intuition says, "start from Map Title [URL]".
05:05:49 <syntaxfree> oh cool. That's basically what I need.
05:06:01 <Cale> haha, gcc is eating almost 300MB compiling this file.
05:06:44 <syntaxfree> here it's eating a measly 139MB.
05:07:11 <Cale> XmlDTDParser was pretty large
05:07:12 <syntaxfree>  Compiling Text.XML.HXT.Parser.ProtocolHandlerUtil
05:07:29 <syntaxfree> Now it dropped to 22.
05:07:33 <vincenz> Anyone know anything about Ivor?
05:08:03 <psnl> edwinb: ^^^
05:08:17 <syntaxfree> hmm. I saw a GetHTTP  module fly by in HXT.
05:08:24 <syntaxfree> does it handle that part?
05:08:29 * earthy grumbles at compiling wxHaskell with profiling support
05:08:51 <Cale> syntaxfree: yes
05:09:03 <earthy> wxHaskell *really* *NEEDS* to be cabalized
05:09:04 <syntaxfree> oh cool. I was already reading the Network.HTTP docs
05:09:07 <Cale> syntaxfree: You can pass it a filename or a URL and it'll just handle that.
05:09:26 <syntaxfree> that sure makes my job easier.
05:09:34 <syntaxfree> Maybe I should switch to some Haskell graph structure.
05:09:43 <syntaxfree> and write a generic Haskell graph -> DOT file processor.
05:09:45 <Cale> It's a really cool library, it just needs some paring down in places, and the documentation needs more organisation.
05:10:55 <edwinb> vincenz: I know a little about it
05:11:27 <vincenz> edwinb: how does it compare to other such frameworks as I had never heard of it before, and it's based on a separate parser, cause the webpage mentions an interface to be used from haskell
05:13:41 <edwinb> vincenz: interesting question... I suppose the most similar thing would be Coq
05:13:52 <edwinb> The main difference is that coq has several man years of development behind it ;)
05:14:36 <edwinb> The advantage of Ivor from my PoV though is that it's easy for me to embed domain specific tactics in a Haskell program, and that I'm free to mess about with the type theory
05:14:52 * vincenz nods at edwinb 
05:14:54 <edwinb> for example, it was really useful to be able to add dependent pattern matching
05:15:07 <vincenz> why a separate language?
05:15:11 <vincenz> why not a combinator-based approach
05:15:24 <edwinb> there are combinators for making tactics, if that's what you mean
05:15:38 <edwinb> the separate language is because it can be handy just to write the program text directly
05:15:41 <vincenz> I mean to fully embed it within haskell as a DSL instead of having a parser
05:16:18 <edwinb> just seems to me that if you can make something a library, then you should...
05:16:25 <edwinb> because programs can then be users as well
05:16:37 <syntaxfree> bah. building HXT choked with a weird error resembling a core dump.
05:17:49 <vincenz> edwinb: well yes, you're notr contradicting me there
05:17:55 <hpaste>  syntaxfree pasted "now, *this* is a bizarre compilation error" at http://hpaste.org/557
05:18:01 <edwinb> maybe I'm misunderstanding your question...
05:18:25 <vincenz> edwinb: it uses a separate front-language instead of it being an embeddable DSL through the use of combinatorsr
05:18:49 <vincenz> at least that's what my impression waas from a webpage that showed a usage of it (that is how I found out about it
05:20:03 <syntaxfree> oh. HXT simply won't build.
05:20:06 <Cale> syntaxfree: hmm, it looks like possibly the commandline is too long?
05:20:18 <edwinb> vincenz: ah, you can do both...
05:20:22 <Cale> I got the same thing perhaps?
05:20:28 <edwinb> (It is not remotely adequately documented...)
05:20:34 <Cale> It chokes on running ar with a huge huge list of parameters
05:20:51 <syntaxfree> hmm.  That's what cabal is doing.
05:21:25 <Cale> Yeah. If it was just split into multiple commands, perhaps it'd work.
05:21:40 <syntaxfree> I have HaXML installed.
05:21:58 <Cale> that's odd, I had no problems compiling this before.
05:22:15 <syntaxfree> I retried, and got the exact same error.
05:22:50 <vincenz> edwinb: ah ic
05:23:02 <Cale> Any cabal gurus around?
05:26:03 <Lemmih> Cale: I think they're all to modest to say yes.
05:26:31 <quicksilver> TINC
05:26:52 <syntaxfree> HaXML does look simple to use, even if poorly documented.
05:26:55 <Cale> syntaxfree: Okay, I wrote a script which finishes it okay
05:26:59 <Cale> It's hacky, but it works.
05:27:09 <Cale> !paste
05:27:09 <hpaste> Haskell paste bin: http://hpaste.org/
05:27:28 <syntaxfree> okie :)
05:27:33 <hpaste>  Cale pasted "bar.sh" at http://hpaste.org/558
05:27:33 <syntaxfree> thanks!
05:27:47 <edwinb> vincenz: I'm curious to know where you saw it. I wasn't really planning on publicising it until/unless I write enough documentation to make it usable!
05:27:53 <Cale> The problem is just that the commandline to ar is too long.
05:28:03 <vincenz> edwinb: it was on this page on reddit regarding correct-by-construction ripple-carry address
05:28:06 <vincenz> adders
05:28:42 <edwinb> oh, that was on reddit?
05:28:59 <edwinb> I didn't realise people read my blog until today ;)
05:29:04 * vincenz shrugs
05:29:04 <quicksilver> I thought I could make lists into a Comonoid, but after some pondering I don't think they'd be associative
05:29:05 <vincenz> on reddit
05:29:07 <vincenz> or on planet haskell
05:29:20 <vincenz> yeps, reddit
05:29:22 <quicksilver> I now think only stuff like random and unique supply can be comonoids
05:29:31 <vincenz> people will drop all sorts of stuff on reddit, it's great for karma-whoring :)
05:29:42 <edwinb> hehe
05:30:10 <edwinb> I use reddit to keep me occupied when I'm bored. There's usually something there which irritates or entertains me enough.
05:30:20 <Saizan> even the hxt darcs repo is a bit strange: darcs: ./examples/w3ctest/xml-test-suite/xmlconf/xmltest/not-wf/sa/nul-0: renameFile: already exists (File exists)
05:31:28 <Cale> hrm, grumble, now I'm getting errors about magic number mismatches.
05:33:34 <syntaxfree> Cale: I'm getting an even more elementary error: your script looks for a directory that I don't have (dist/build/src/...)
05:33:55 <syntaxfree> if I try to change it to dist/build/..., which I have, it starts looking for .o files I haven't produced yet apparently.
05:33:58 <Cale> Oh, that should be hanging off the main HXT directory.
05:34:04 <Cale> hmm
05:34:05 <syntaxfree> yes, I know.
05:34:13 <syntaxfree> ahh.
05:34:13 <Cale> what's your HXT directory itself called?
05:34:18 <syntaxfree> Maybe my .o files are .dylib or .so
05:34:27 <Cale> oh, that would be even more confusing :)
05:34:48 <syntaxfree> nah, they're really .o
05:34:54 <ndm> @seen dons
05:34:55 <lambdabot> dons is in #haskell. I last heard dons speak 2h 57m 54s ago.
05:35:04 <syntaxfree> I understand relative path names.
05:35:10 <syntaxfree> Hey, thanks for trying to help :)
05:35:24 <swiert> @seen dcoutts
05:35:24 <lambdabot> dcoutts is in #haskell, #ghc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 4m 32s ago.
05:35:32 <syntaxfree> But, well, I didn't expect the spanish inquisition. HaXML was installed with HaPPS, I'll just use it.
05:35:37 <dcoutts> swiert, hia
05:35:38 <Cale> okay
05:35:44 <ndm> @tell dons please do your nobench-marks with type=release as an argument to scons - should double the performance at least
05:35:44 <lambdabot> Consider it noted.
05:35:49 <syntaxfree> Cale++
05:36:03 <Cale> I'll see if I can work this out, since I really want HXT to work. Another option would be to download 7.0, since I know that it compiles okay.
05:36:06 <dons> ndm, yo!
05:36:07 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:36:15 <dons> ndm, currently rerunning with a 'release' yhc
05:36:16 <Cale> I just realised that I'd never tried 7.1
05:36:19 <swiert> dcoutts: I take it you haven't heard anything from CUP yet...
05:36:20 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
05:36:21 <dons> seems hmm, 10% faster?
05:36:32 <dons> ndm, have you had a go running the benchmarks on your machine?
05:36:45 <dcoutts> swiert, I'm just heading into the dept now so I'll check my mail
05:36:50 <ndm> dons: thats got to be wrong... if you look at the logs for the Yhi builder is -O2 being passed?
05:36:55 * dcoutts -> office
05:36:56 <ndm> dons: you may need a quite recently Yhc build
05:37:30 <dons> so i grabbed todays darcs yhc, and just built it with the 'release' way. its about 20%of the way through now
05:37:51 <dons> i'll inspect the logs in the morning. but you should be also able to just darcs get the benchmark suite and run it on yhc
05:37:55 <ndm> dons: i think the makefile would not work on my machine
05:38:03 <dons> oh, windows. hmm
05:38:08 <ndm> dons: cool, i'll check logs later
05:38:08 <swiert> @tell dcoutts If you're coming to Fun in the Afternoon, you can borrow my copy of Graham's book.
05:38:09 <lambdabot> Consider it noted.
05:38:26 <dons> ndm, anything other than building it with type=release  required?
05:38:32 <dons> or that should be it?
05:38:55 <Cale> Well, that's a shame. I'm going to install 7.0 and see if it still goes okay.
05:39:21 <ndm> dons: not as far as i know, unless we are beating nhc though something is wrong...
05:39:28 <Cale> dons: any idea about what to do when cabal runs ar with too many parameters?
05:39:40 <dons> Cale, hmm. xargs ar ?
05:39:48 <dons> ndm, ok. and you've confirmed this on a linux box?
05:39:52 <Cale> I tried splitting the commandline into two.
05:40:09 <Cale> With ar q libname.a ...; ar q libname.a ...
05:40:10 <ndm> dons: yes, i've not seen an example where we are slower than nhc
05:40:24 <ndm> dons: unless you did loads of FFI, but i think thats unlikely
05:40:25 <Cale> But then I got magic number errors, I'm not sure if they're related.
05:40:27 <dons> ndm, could you maybe get the benchmarks, and compile some of them by hand?
05:40:36 <dons> any that look odd to you
05:40:46 <ndm> dons: i can't compile them against nhc, which is where the oddness looks most obvious
05:40:51 <ndm> dons: i'll get Tom to take a look
05:40:53 <dons> oh, you don't have an nhc build?
05:41:02 <ndm> nhc /= windows :)
05:41:38 <dons> yeah, nhc is definitely ahead, but doing type=release did help somewhat.
05:41:54 <dons> Test: recursive (naive recursive functions)
05:41:54 <dons> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/recursive
05:41:54 <dons> ghc                  2.334    seconds            (1.0 x)
05:41:54 <dons> ghc-old              2.353    seconds            (1.0 x)
05:41:54 <dons> ghci                 99.580    seconds            (42.7 x)
05:41:55 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/recursive
05:41:56 <dons> nhc98                111.865    seconds            (47.9 x)
05:41:59 <dons> yhc                  143.878    seconds            (61.6 x)
05:42:02 <dons> for example, just ran
05:42:07 <dons> whereas it was hugs                 208.266    seconds            (72.7 x)
05:42:07 <dons> yhc                  242.875    seconds            (84.8 x)
05:42:08 <dons> before
05:42:23 <ndm> i find it hard to believe that Yhc is slower than nhc...
05:42:26 <ndm> i'll check with Tom
05:42:55 <Igloo> Does nhc compile to bytecode or machinecode?
05:42:56 <dons> sorry, before I did a 'release' build, yhc ran recursive at yhc                  172.517    seconds            (73.6 x)
05:43:01 <dons> now it runs it at yhc                  143.878    seconds            (61.6 x)
05:43:24 <dons> isn't nhc producing object code here? it is.
05:43:49 <Igloo> And yhc is compiling to bytecode, right?
05:44:00 <dons> yeah running in yhi
05:44:14 <Cale> syntaxfree: what platform are you on?
05:44:14 <ndm> nhc produces bytecode, puts it in a C array, then compiles it
05:44:23 <dons> ah right.
05:44:31 <ndm> thats basically a bytecode interpretter, which has expensively compiled an array :)
05:44:41 <Cale> okay :)
05:44:43 <Igloo> Ah, OK
05:45:12 <dons> ndm, if you have access to a machine with gnu make installed, it'd be worth confirming the results yourself. or having Tom do that.
05:46:31 <ndm> dons: i'll get Tom to check it
05:46:50 <syntaxfree> Cale: OS X.
05:47:21 <dons> ndm, can i complain again about the svn checkout that runs on configure?
05:47:27 <syntaxfree> this looks like an interesting, alternate solution: http://repetae.net/~john/computer/haskell/DrIFT/
05:47:28 <lambdabot> Title: DrIFT Homepage
05:48:11 <ndm> dons: if you don't have svn installed, it doesn't do it anymore, it grabs a tarball - i want to make that the default shortly
05:48:16 <vvv> /disconnect
05:48:49 <dons> hmm. do i have the right darcs repo?
05:48:52 <syntaxfree> jesus. I'll just roll a simple one in Parsec.
05:48:55 <dons> the one listed on the yhc homepage?
05:49:00 <ndm> dons: haskell.org or www.cs. ?
05:49:01 <dons> since it certainly tried to do svn co today
05:49:25 <dons> http://darcs.haskell.org/yhc
05:49:29 <lambdabot> Title: Index of /yhc
05:49:33 <ndm> oh no, if you have svn installed it tries, but if you don't then it doesn't
05:49:39 <dons> ah i see.
05:49:46 <dons> i had svn installed, but i was behind a proxy, so it failed
05:49:53 <dons> so i had to read the svn manual
05:49:57 <ndm> dons: fair point, i'll raise a bug
05:50:05 <quicksilver> syntaxfree: I'm not really sure your gee-whiz expression calculates what you think it calculates
05:50:08 <dons> you can't just bundle your own libfffi?
05:50:24 <ndm> dons: we have it on a website and it wget's it as necessary, just as good really
05:50:31 <syntaxfree> quicksilver: yes, I noticed that.
05:50:40 <ndm> dons: if you do scons help, it says how to turn off the svn getting
05:50:46 <syntaxfree> I should write a rebuttal. Later.
05:50:49 <quicksilver> syntaxfree: :)
05:50:55 <quicksilver> syntaxfree: replace the second 'x' by a zer0
05:51:01 <quicksilver> syntaxfree: I think. Or remove it.
06:00:17 <dcoutts_> Cale, it must be happening because Cabal is guessing wrongly about how many args it can fit into the space allowed. Cabal already has logic to call ld and ar multiple times when there are 1000's of little .o files.
06:00:43 <Cale> What's the correct way to do it?
06:01:05 <Cale> Do you know what the magic number mismatch thing means?
06:01:44 <Cale> I just tried doing ar q libname.a <first half of .o's>; ar q libname.a <second half>
06:02:25 <Saizan> the 7.1 tarball compiled fine on win32+msys btw
06:03:05 <Saizan> (ah ghc has it's own ar..)
06:03:25 <dcoutts_> Cale, yep, calling ar on the same .a file is the right thing to do (btw, 'q' does nothing
06:04:04 <Cale> dcoutts_: okay, then the problem was something else.
06:04:09 <Cale> I got:
06:04:23 <Cale>     Bad interface file: /usr/local/lib/hxt-7.1/Text/XML/HXT/Arrow.hi
06:04:23 <Cale>         magic number mismatch: old/corrupt interface file?
06:04:49 <Cale> Oh, great, now it's happening with 7.0 as well.
06:05:02 <Cale> Perhaps this is a GHC 6.6 thing?
06:05:06 <dcoutts_> Cale, that's nothing to do with ar
06:05:26 <Cale> okay, I was misled by that being the point in the install where things failed.
06:05:35 <Cale> What does that message actually mean?
06:05:49 <dcoutts_> it means ghc can't read the .hi file
06:06:23 <dcoutts_> it's trying to compile something that uses that module and so reads the .hi file
06:06:54 * dcoutts_ -> off to teach
06:07:19 <Cale> hmm
06:14:45 <Eighty> is there an assert function in the standard libraries?
06:14:51 <ndm> @hoogle assert
06:14:51 <lambdabot> Control.Exception.assert :: Bool -> a -> a
06:14:52 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
06:14:52 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
06:14:59 <ndm> Eighty: yes, the first one :)
06:15:16 <Eighty> okies
06:16:01 <Cale> syntaxfree: http://syntaxfree.wordpress.com/2007/02/13/ugh-such-a-proud-display-of-sheer-irrationality/#comment-408
06:16:04 <lambdabot> http://tinyurl.com/25zktu
06:16:07 <syntaxfree> I don't understand wht Parsec doesn't seem to have a simple "negate" parser combinator.
06:16:29 <syntaxfree> succeed if the parser argument fails, return empty string.
06:16:59 <syntaxfree> Cale: great comment!
06:17:06 <syntaxfree> I'll respond in place for posterity.
06:17:17 <twanvl> syntaxfree: negate a = try (a >> fail) `mplus` return () ?
06:17:34 <syntaxfree> twanvl: hmm.
06:17:38 <syntaxfree> 11:15 < syntaxfree> Cale: great comment!
06:17:42 <syntaxfree> 11:15 < syntaxfree> I'll respo)] [Act: 1,2]] [Act: 1,2]
06:17:45 <syntaxfree> oops.
06:17:50 <Cale> whoa :)
06:17:51 <syntaxfree> my terminal got into some drag-and-drop funniness.
06:18:00 <allbery_b> erm.  notFollowedBy?
06:18:02 <syntaxfree> I was trying to select text.
06:18:28 <syntaxfree> well, direct problem:
06:18:30 <syntaxfree> I have a parser.
06:18:43 <syntaxfree> I want to return whatever it succeeds at, and discard the rest.
06:21:56 <allbery_b> "succeed if the parser argument fails, return empty string" --- notFollowedBy actually returns (), but is otherwiise that, as I understand it
06:22:33 <allbery_b> e.g. the eof combinator is notFollowedBy anyToken
06:25:03 <Saizan> can record syntax affect performance?
06:25:18 <ndm> Saizan: unlikely
06:26:40 <Saizan> i've a zipper that actually run faster with it, it's a record with 5 field, and i make many of them that differs only for 2
06:27:03 <Saizan> s/2/2 field/
06:27:41 <TB> :src minimum
06:27:50 <TB> > :src minimum
06:27:50 <lambdabot>  Parse error
06:27:52 <allbery_b> ?src minimum
06:27:53 <lambdabot> minimum [] = undefined
06:27:53 <lambdabot> minimum xs = foldl1 min xs
06:27:58 <TB> Ah, thank you :)
06:30:41 <xerox> Saizan: cool.
06:33:44 <syntaxfree> Cale: http://syntaxfree.wordpress.com/2007/02/13/ugh-such-a-proud-display-of-sheer-irrationality/#comment-409
06:33:46 <lambdabot> http://tinyurl.com/25zktu
06:52:18 <vincenz> yay for paper compression
06:55:00 <syntaxfree> ?
06:55:09 <syntaxfree> Paper compression?
06:57:15 <earthy> hm. -prof -auto-all doesn't really give any useful information in programs with extensive graphical user interfaces
07:05:44 <Eighty> @hoogle join
07:05:45 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
07:05:45 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
07:05:45 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
07:06:15 <Eighty> is there a difference between the first two?
07:06:19 <mauke> no
07:06:36 <allbery_b> the first is just the haskell98 namespace name for the second
07:07:08 <Eighty> different namespaces?
07:07:27 <allbery_b> haskell98 doesn't have a hierarchical module namespace
07:07:49 <EvilTerran> ie you're only allowed one dot in your identifiers
07:08:25 <ndm> Eighty: Use Control.Monad, in the next version of Hoogle it won't even suggest Monad.join
07:09:06 <Eighty> so the Monad file would basically consist of "module Monad (join) where import Control.Monad (join)"?
07:09:51 <EvilTerran> well, module Monad (Control.Monad(..)) where import Control.Monad , but yeah.
07:10:11 <ndm> Eighty: http://darcs.haskell.org/packages/haskell98/Monad.hs - thats the actual soruce code
07:10:22 <allbery_b> module Monad (module Control.Monad) where import Control.Monad -- I think
07:10:29 <EvilTerran> ok, there's a bit more too it than i thought.
07:10:35 <EvilTerran> *to
07:10:40 <ndm> not a whole lot more!
07:10:46 <EvilTerran> but it's the same concept.
07:10:47 <ndm> its just restricting the export list
07:11:39 <Eighty> why should i use Control.Monad instead then? will Monad go away? isn't hoogle just a bot in here?
07:12:27 <EvilTerran> @where hoogle
07:12:28 <lambdabot> http://www.haskell.org/hoogle
07:12:32 <ndm> @seen dons
07:12:32 <lambdabot> dons is in #haskell. I last heard dons speak 1h 22m 23s ago.
07:12:54 <allbery_b> Control.Monad will be in Haskell' I think
07:12:54 <EvilTerran> not just a bot. but, that aside, heirarchical modules are The Way Forward.
07:13:24 <maskd> does anyone have solutions to "write yourself a scheme in 48 hours" exercises? some of them are rather difficult
07:13:53 <allbery_b> think of the old namespace (things like Monad) as backward compatibility with ancient versions of Haskell, most of which no longer exist in the real world :)
07:14:33 <Eighty> okay
07:20:51 <boegel> dons: great work on nofib!
07:20:59 <boegel> or nobench, rather :-)
07:24:47 <ndm> dons: none of the Yhc developers have working copies of nhc - it doesn't work on 64 bit, the distro in our department, or windows - which pretty much covers us all...
07:24:50 <Eighty> ndm: you made hoogle? could you make a text link "next" in addition to the arrows? then fast-forwarding would work in opera
07:25:18 <Igloo> ndm: Why do you think yhc is faster, then?
07:25:19 <ndm> Eighty: doesn't opera use the link type="next" field?
07:25:58 <ndm> Igloo: because way back when we were able to benchmark it, on one developers machine (before he got a 64bit processor), we were reliably 20% faster - the code is sufficiently similar that we know why we are faster
07:26:05 <Eighty> i don't know... fast-forwarding doesn't work as it is. adding "next" there made it work.
07:26:36 <ndm> Eighty: yes, i did make hoogle, and i'll add the appropriate link tags when i get a chance - probably for hoogle 4 though since i've pretty much broken hoogle 3, and can't rebuild working copies...
07:27:14 <ndm> Igloo: we share the same front end, and hte same basic code generator - we just use less instructions, and each instruction is simpler - there is no where we could potentially be slower (in theory...)
07:27:32 <Eighty> okay
07:28:45 <dino-> Do the arrow functions like (>>>), (<+>), (***), (&&&) have names? Like how we call (>>=) "bind"
07:29:21 <dino-> I'm finding them hard to read and discuss with people out loud without names.
07:30:14 <dons> ndm, i'll do a full build of yhc in the morning, and give you the log?
07:30:45 <ndm> dons: that would be handy, and let us know when you have a complete benchmark set with yhc type=release done, so we can check it
07:31:08 <ndm> dons: Tom thinks the numbers you are giving suggests you have got -O2 specified - but he'd like to see all the comparative numbers
07:32:23 <dons> all i've done is a scons type=release;  scons install. so should i have set other flags?
07:33:07 <ndm> dons: that should be plenty, you might need scons fullclean or scons clean beforehand if its an existing repo
07:33:35 <ndm> dons: are the numbers on the web now with type=release?
07:33:37 <vincenz> anyone know how hard it is to build ghc under cygwin?
07:33:48 <kombinator> dino-, (>>>) is serial composition, (***) is parallel composition for instance
07:33:56 <dons> ndm, nope. let me copy across the results so far
07:34:17 <dino-> vincenz: No, but somebody came here a week or so asking stuff like that. Turned out that all he needed to do was install the Windows ghc and it can be run from cygwin like anything else.
07:34:29 <dons> ndm. ok. those are the current numbers now
07:34:40 <TB> ?src foldl1
07:34:41 <lambdabot> foldl1 f (x:xs) = foldl f x xs
07:34:41 <lambdabot> foldl1 _ []     = undefined
07:34:46 <vincenz> dino-: ah thx, cause a colleague of mine has gotten interested in haskell and was trying to get ghgc working
07:34:50 <dino-> kombinator: But those are so not nice for conversation like "bind". :)
07:34:51 <ndm> @karma+ dons for the nobench work
07:34:51 <lambdabot> dons's karma raised to 121.
07:34:53 <vincenz> dino-: so.... do you remember the nick of that person?
07:34:56 <xerox> :O
07:34:59 <dons> ndm, note that since the reinstall yhc has started saying "Found file multiple times" for missing modules
07:35:03 <dons> any idea what that is?
07:35:15 <dons> its the same modules that previously were not found at all, e.g. bytestring and Monad.ST
07:35:18 <dino-> vincenz: I don't, someone new to the big H, I think. But you can run any program from cygwin.
07:35:37 <ndm> dons: you might need to completely clean all the old stuff off first
07:35:38 <dino-> vincenz: It's as good as (well better than) the cmd shell.
07:36:12 <dino-> vincenz: One thing that I remember having to do was put programs binary dirs into the system's PATH environment variable.
07:36:25 <dino-> vincenz: Which, in Windows, is inexplicably hidden in My Computer tabs somewhere.
07:36:35 <dons> ndm, remove lib/nhc* ? and start over?
07:36:48 <dino-> Instead of a proper startup script like autoexec.bat and config.sys used to be.
07:37:10 <ndm> dons: lib/nhc shouldn't be there, but yeah, remove all and start over
07:37:40 <dons> ok. i'll try that tomorrow. note that yhc did speed up after the type=release build
07:38:01 <ndm> dons: yeah, i guess there is somewhere we've screwed up which is making it slower, i'll get Tom to look into it
07:38:09 <dino-> vincenz: It's probably not helpful to say this: but perhaps colleague would be happily surprised with Linux or BSD.
07:38:25 <dons> i reckon we need nightly runs of this stuff to keep on top of what the compilers are doing
07:38:59 <vincenz> dino-: not really no :)
07:39:09 <vincenz> dino-: especially since he knows about linux and uses it for other reasons
07:39:45 <Igloo> dons: Graph animations would be cool (but you need to filter out bad data)
07:39:58 <dons> animations?
07:40:10 <dons> i was thinking html would be enough :)
07:40:12 <dons> maybe some gnuplot
07:40:16 <Igloo> Over time
07:40:31 <dons> a lot of work ;)
07:41:02 <Igloo> Shouldn't be too bad once you have graphs. Need to wait a year or so for them to be interesting, though
07:41:24 <dons> ah i see. yes.
07:41:31 <dons> need to hook this up to the nightly build runs
07:41:33 <ndm> dons: its fantastic, part of my phd is going to be speeding up Yhc, so it gives me some nice concrete targets
07:41:49 <ndm> i want to beat GHC as my target :)
07:41:51 <Igloo> Nightly build of what, though?
07:42:00 <Igloo> Just ghc only helps for, well, ghc
07:42:07 <ndm> dons: what platform/machine is this on?
07:42:11 <dons> Igloo: ghc, run this after nofib each night. keep track of if ghc is getting better or worse
07:42:18 <Igloo> I guess you could collect results from the nightly builds of verything and then collate them
07:42:21 <dons> ndm, says at the top of the file
07:42:24 <SamB> Igloo: I assume he meant of the benchmarks...
07:43:15 <SamB> for all the compilers that can run any of them
07:43:42 <SamB> at least, all the ones that are not dead
07:43:58 <dons> i've got a working hbc on that machine too.
07:44:06 <dons> so should be able to get numbers for hbc and hbi
07:44:15 <SamB> yes but the results won't change for those ;-)
07:44:22 <dons> should be interesting though
07:44:31 <SamB> so no need to run *nightly*
07:45:49 <matthew_-> not unless the machine has random cpu frequency scaling "features"...
07:49:20 <dons> right. no need to ever rerun the hbc benchmarks once they're done
07:59:43 <pejo> dons, is hbc still usable?
07:59:49 <dons> hey. got hbc to compile recursive.hs just then!
07:59:57 <dons> $ time ./a.out 9
07:59:57 <dons> Ack(3,9): 4093
07:59:57 <dons> Fib(36.0): 24157817.0
07:59:58 <dons> Tak(24,16,8): 9
07:59:58 <dons> Fib(3): 3
08:00:00 <dons> Tak(3.0,2.0,1.0): 2.0
08:00:03 <dons> ./a.out 9  13.80s user 0.08s system 99% cpu 13.943 total
08:00:05 <dons> woow
08:00:18 <dons> hmm. that's pretty fast...
08:02:14 <dons> yeah, that's a fair bit faster than yhi.
08:02:22 <dons> ok. so i need to add in more hbc support
08:02:32 <osfameron> what's hbc?
08:02:43 <dons> ndm, can you commit a patch today to fix the import System /= import System.Environment issue?
08:02:53 <dons> needing to specify the non-h98 path is bad :/
08:03:04 <dons> osfameron: one of the first haskell compilers
08:03:11 <ndm> dons: will give it a shock
08:03:29 <osfameron> ah!  I only really know about ghc and hugs (and the york one)
08:03:33 <vvv> /quit
08:03:36 <swiert> dons: Will you finish your article for the next issue of TMR?
08:03:44 <ndm> dons: not really surprised, hbc is an optimising compiler, Yhc isn't (yet)
08:04:10 <dons> swiert: when's the deadline?
08:04:20 <swiert> dons: after ICFP deadline.
08:04:38 <swiert> dons: 13 april IIRC.
08:05:16 <dons> wow. hbc -O beats ghc -O by 25% or so..
08:05:16 <Eelis> when i compile  main = usleep 1000000  (where usleep is imported from System.Posix.Unistd) using ghc without -threaded, the program nicely sleeps for one second, as expected. however, when i compile the same code with -threaded, the program seemingly sleeps forever. any clue as to what might be going on? (i'm using linux x86_64, ghc 6.6)
08:05:19 <pejo> osfameron, there can't be that many users of it, unfortunately.
08:05:20 <dons> for this one little benchmark
08:06:04 <hpaste>  nominolo pasted "Monadic Stream Functions, Take 2, still not working ..." at http://hpaste.org/559
08:06:23 <Igloo> dons: Doesn't that equal a bug according to the GHC docs?
08:06:39 <dons> Igloo: I believe so. lennart's quite a good compiler writer, I think.
08:06:51 <dons> I'll try to get a full hbc run tomorrow
08:06:54 <dons> very exciting
08:07:04 <dons> now all we need is the hbc source!
08:07:05 <dons> ;)
08:07:05 <ndm> dons: what GCC are you using? we can't get nhc compiling with gcc 4....
08:07:21 <ndm> dons: and i've got a patch for getArgs, just putting it in
08:07:24 <dons> its an nhc from 2005-03, so probably 3.35 at the time?
08:07:28 <dons> great!
08:07:32 <dons> ndm++
08:07:34 <nominolo> can someone give me a hint why i get List-monad like bahaviour, in my pasted code?
08:08:52 <nominolo> oh .. hm. i guess my mapML is wrong
08:09:07 <ndm> typical, nhc won't even compile generated code with gcc 4, so we're having real difficulties here
08:09:17 * mux hears GCC4 compilation problems and gets interested
08:09:24 <mux> got bitten by strict aliasing maybe?
08:10:15 <pejo> dons, http://www.cs.chalmers.se/pub/haskell/chalmers/0.9999.3/hbc-0.9999.3.src.tar.gz?
08:10:17 <lambdabot> http://tinyurl.com/2f4j4s
08:10:53 <pejo> dons, hm, looks like .4 exists: http://www.cs.chalmers.se/pub/haskell/chalmers/hbc/hbc-0.9999.4.src.tar.gz
08:10:55 <lambdabot> http://tinyurl.com/2dn5fe
08:15:24 <dons> i wonder if that's the one i have
08:15:30 <dons> or is that a newer version?
08:16:51 <pejo> dons, I have no idea. There exists a .5 obviosuly, since there are binaries for it - but no src.
08:16:53 <ndm> mux: nhc writes out an array in a source code file, and then prods it and does evil things to it - its basically a broken nhc, not gcc's fault
08:17:26 <ndm> dons: patch committed, give it 20 minutes to buildbot test itself then you can have getArg's in System
08:17:32 <mux> ndm: ah okay.
08:17:56 * mux wonders if we got the full FreeBSD source tree GCC 4 clean by now or not
08:26:34 <dons> ndm, the full benchmark run has gone through, 
08:26:51 <dons> that's the version using type=release
08:27:17 <ndm> dons: cheers, i don't suppose you could get instruction counts out of nhc on teh queens benchmark?
08:27:28 <ndm> dons: we really can't get it to compile anywhere, so are having issues debugging it
08:27:44 <dons> no linux/x86 box?
08:28:01 <dons> i'm most of the way though an nhc darcs build atm.
08:28:10 <dons> from darcs get --partial http://darcs.haskell.org/nhc98
08:28:12 <lambdabot> Title: Index of /nhc98
08:28:25 <ndm> dons: recently C compilers or recent linux distro's have issues with nhc...
08:28:36 <ndm> dons: our dev has GCC 4, which is incompatible
08:28:57 <dons> mm, i'm using $ gcc --version
08:28:58 <dons> gcc (GCC) 4.0.3 20051201
08:31:55 <ndm> we can't get it working with a modern GCC, its very unreliable
08:32:44 <ndm> dons: pull the new Yhc version, rebuild the libraries etc and you should have getArgs in System
09:10:23 <xic> sup
09:10:49 <manu_> Anybody knows who's managing the Haskell Bundle for TextMate ?
09:15:47 <vincenz> Anyone know how to display a $ symbol in latex?
09:15:59 <kc5tja> Depends on what context you're in.
09:16:05 <kc5tja> For normal text, it's \$
09:16:13 <vincenz> hmm, doesn't seem to like that
09:16:21 <kc5tja> I think that will also work for math context too.
09:16:24 <kc5tja> Not sure about others.
09:16:40 <matthew_-> there could be a \dollar
09:17:09 <quicksilver> kc5tja, now there is a name from the past
09:17:21 <quicksilver> I used to follow a certain project called dolphin, some 10-12 years ago
09:17:23 <quicksilver> or was it longer
09:17:30 <matthew_-> there's some package I can't remember the name of that gives real names to all the symbols
09:17:59 <kc5tja> quicksilver: Heh, well, ideas from Dolphin still rear their ugly head, although this time for my Kestrel project.
09:18:35 <kc5tja> quicksilver: Although it has to have been a long time, because I don't remember you.  :)
09:18:53 <quicksilver> kc5tja: I hadn't adopted this nickname back then. Well certainly I never used it in email.
09:19:02 * kc5tja nods
09:19:15 <quicksilver> kc5tja: I was plain old 'Jules Bean', we were introduced by a mutual friend in Billy Tanksley
09:19:19 <vincenz> \dollar does not work in lst-environments
09:19:45 <kc5tja> huh, Billy and I have remained in contact consistently.  Still are.  :)  I'll let him know that we hooked up on IRC.  :)
09:20:12 <quicksilver> #haskell is clearly were cool people hang out, anyway
09:20:16 * quicksilver pats everyone on the back
09:20:18 <quicksilver> (all 300 of us)
09:20:23 <kc5tja> Hehehe
09:20:31 * kc5tja is only just learning it, and finding an excuse to use it on something.
09:20:54 <vincenz> @users
09:20:59 <lambdabot> Maximum users seen in #haskell: 316, currently: 301 (95.3%), active: 48 (15.9%)
09:21:15 <vincenz> > return "lambda-cookie" >>= replicate 301
09:21:16 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
09:21:45 <vincenz> > ["lambda-cookie"]>>= replicate 301
09:21:46 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
09:21:56 <vincenz> cause [.]>>= looks neater :)
09:22:24 <quicksilver> (:[]) "lambda-cookie" >>== replicate 301
09:22:31 <quicksilver> cookie monster combinator for the win!
09:22:43 <quicksilver> > (:[]) "lambda-cookie" >>= replicate 301
09:22:44 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
09:23:24 <matthew_-> @hoogle (>>==)
09:23:25 <lambdabot> Did you mean: (>>==)
09:23:25 <lambdabot> Prelude.undefined :: a
09:23:25 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:23:28 <matthew_-> O.o
09:24:17 <vincenz> > ((>>=) . (:[])) "lambda-cookie" (replicate 301)
09:24:18 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
09:24:26 <ndm> malcolmw: is there a working nhc build in the department?
09:24:50 <malcolmw> ndm: does /grp/haskell/bin/nhc98 not work on Linux?
09:24:50 <ndm> malcolmw: Tom is trying to debug the performance of Yhc vs nhc, and we can't find a working copy of nhc or build one...
09:24:56 <int-e> @type (((>>=) . (:[])), flip id)
09:24:58 <lambdabot> forall b a b1 c. (a -> (a -> [b]) -> [b], b1 -> (b1 -> c) -> c)
09:25:14 <ndm> malcolmw: no idea, not a linux person, i'll get Tom to try it
09:25:21 <vincenz> @pl ((>>=) . (:[]))
09:25:22 <lambdabot> flip id
09:25:24 <vincenz> :P
09:25:36 <Botje> how macho.
09:25:43 <malcolmw> ndm: I'm pretty sure it works for me on venice
09:26:01 <vincenz> Botje: thx, I aim to please
09:26:50 <ndm> malcolmw: i've passed on the message, thanks
09:27:10 <quicksilver> vincenz: it's that the cookie monster in traditional head dress combinator?
09:28:13 <Botje> :t fix (&&&)
09:28:16 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> c'
09:28:16 <lambdabot>     Probable cause: `&&&' is applied to too few arguments
09:28:24 <Botje> :t (fix &&&)
09:28:26 <ndm> malcolmw: any idea how to get the instruction count out of nhc?
09:28:27 <lambdabot> forall a c'. ((a -> a) -> c') -> (a -> a) -> (a, c')
09:28:36 <Botje> heh. that's a nice type.
09:29:08 <mauke> looks like a combination of fix and id
09:29:32 <mauke> @djinn ((a -> a) -> c') -> (a -> a) -> (a, c')
09:29:33 <lambdabot> -- f cannot be realized.
09:29:34 <malcolmw> ndm: need to recompile the Kernel of the runttime system with -DBYTECODE_PROF
09:29:42 <Botje> :t first fix
09:29:44 <lambdabot> forall a d. (a -> a, d) -> (a, d)
09:30:34 <malcolmw> ndm: no, actually it is #define INSCOUNT 1 in include/runtime.h
09:30:36 <int-e> @free first fix
09:30:36 <lambdabot> Extra stuff at end of line
09:30:38 <kpreid> > (fix &&&) (1:) fix
09:30:39 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[t]'
09:30:58 <kpreid> @type (fix &&&) (1:)
09:31:00 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `[t]'
09:31:00 <lambdabot>       Expected type: (a -> a) -> c'
09:31:33 <int-e> kpreid: do you mean ***?
09:32:07 <kpreid> > (fix &&&) fix (1:)
09:32:08 <lambdabot>  ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:32:31 <kpreid> that's what I meant
09:33:19 <int-e> fix ((1:) . map succ)
09:33:51 <kaol> @source fix
09:33:52 <lambdabot> fix not available
09:34:00 <kaol> @type fix
09:34:03 <lambdabot> forall a. (a -> a) -> a
09:34:41 <int-e> @index fix
09:34:41 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
09:34:55 <int-e> fix f = let res = f res in res
09:35:30 <ndm> malcolmw: is that hte lastest stable version, or the cvs version in /grp/haskell ?
09:37:12 <shapr> So, what sort of exciting stuff is happening guys?
09:37:30 <malcolmw> ndm: /grp/haskell has last night's nightly build
09:37:53 <malcolmw> ndm: (I installed it just to be sure...)
09:38:16 * nomeata is letting his fantasy run wild: Wouln‚Äôt it be interesting to use Haskell with some nice functions and modules as a DSL to replace LaTeX...
09:38:18 <TomMD> shapr: I can't say it's exciting, but I've just moved from FC5 to Ubuntu and now I need to continue my Haskell hacking.
09:38:29 <shapr> TomMD: Hey, that's cool.
09:38:46 <Cale> syntaxfree: you around?
09:38:46 <nomeata> I very much prefer haskell syntax to latex syntax
09:38:59 <TomMD> Installing ghc6.7 now.
09:39:03 <Cale> I prefer Haskell syntax to latex syntax for programming.
09:39:07 <matthew_-> nomeata: are you planning to use the tex engine?
09:39:16 <nomeata> I‚Äôm not planning at all, just brainstorming.
09:39:27 <Cale> But for writing mathematics documents, I think I'd go with latex :)
09:39:27 <nomeata> But that would be the easiest option, yes.
09:39:48 <nomeata> True, for formulas, even haskell‚Äôs syntax might be too verbose.
09:40:03 <malcolmw> ndm: I think you need to add a -O option to yhc that switches on your cool specialisation stuff
09:40:08 <kc5tja> TeX syntax is *almost* ideal for textual markup {\keyword content content ...} is almost perfect.
09:40:16 <matthew_-> nomeata: what don't you like about latex?
09:40:19 <syntaxfree> Cale: hey. Just arrived.
09:40:29 <ndm> malcolmw: i do, just trying to figure out where the obvious performance has gone, before i start working from Yhc
09:40:31 <Cale> Ah, I upgraded Cabal and it started working.
09:40:37 <nomeata> matthew-_: that a lot of needed things are just hacks in modules
09:40:44 <syntaxfree> yhc or hxt?
09:40:44 <Cale> I'm running Cabal 1.1.7
09:40:47 <Cale> hxt
09:40:59 <nomeata> I need a module to have a table that spans the whole width, and I need a module that allows tables to span several tables.
09:41:00 <syntaxfree> I have such a bad luck with getting things compiled.
09:41:00 <ndm> malcolmw: and Matt next to me is working on Hacle+Clean as a benchmark, beats GHC in one test (looses in the others)
09:41:07 <malcolmw> ndm: I noticed that nhc98 compiles its RTS with -O3, maybe yhc needs to do the same
09:41:15 <nomeata> I can‚Äôt have both, and if, it doesn‚Äôt work with multiple columns...
09:41:17 <syntaxfree> I can't count on my fingers the number of things I wanted to try or hack on and couldn't get to build.
09:41:25 <Cale> There's another command after the ar, it runs ld and it wasn't doing that because it stopped :)
09:41:42 <Cale> Yeah, probably a good idea to upgrade Cabal then :)
09:41:56 <syntaxfree> lambdabot has been a frustration for months.
09:42:10 <syntaxfree> time and again I try to build it, to no avail.
09:42:14 <matthew_-> nomeata: it helpfully constrains you to presenting data piece by piece and not bombarding the user with data ;-)
09:43:03 <nomeata> mathrick: yes, but sometimes (only sometimes) I know what‚Äôs better than latex. And then I think, that some things with LaTeX are just not right.
09:43:14 <nomeata> sorry
09:43:18 <nomeata> matthew-_: ^
09:44:02 <matthew_-> nomeata: yeah, the problem is that in this case, reinventing the wheel is close to a life-time's work
09:44:40 <nomeata> Yes, I guess that‚Äôs why we are stuck with LaTeX since a long while.
09:44:54 <nomeata> I mean, I like it a lot. But a little reform here and there would be nice.
09:47:16 <ndm> malcolmw: how recently did nhc switch to -O3?
09:47:19 <Cale> !paste
09:47:20 <hpaste> Haskell paste bin: http://hpaste.org/
09:47:42 <malcolmw> ndm: a long time ago - years.
09:48:32 <emu> what does need fixing in latex is the absurd difficulty of creating style files and documentclasses
09:48:52 <hpaste>  Cale pasted "link collector (for syntaxfree)" at http://hpaste.org/560
09:50:17 <Cale> If anyone's thinking of writing a new document preparation system, please make it have a TeX backend :)
09:51:53 * tfs wonders if malcolm is around
09:52:07 <malcolmw> tfs: pong
09:52:18 <tfs> hi malcolm, I can't get nhc98 cvs compiling on venice ...
09:52:28 <Cale> syntaxfree: you can see the basic idea there -- deep is used to traverse XML trees recursively, searching for matches to a query, and listA will collect the results obtained into a single list.
09:52:39 <malcolmw> tfs: do you mean CVS? or darcs?
09:52:49 <tfs> oh is there a darcs repo for it now?
09:52:51 <Cale> (normally, they're treated like in the list monad)
09:53:12 <malcolmw> tfs: darcs get --partial http://darcs.haskell.org/nhc98
09:53:15 <lambdabot> Title: Index of /nhc98
09:53:26 <tfs> malcolmw: ah, the nhc98 website needs updating :-)
09:53:31 <malcolmw> tfs: then "sh start; ./configure; make basic"
09:53:35 <ndm> malcolmw: if the cvs isn't in sync, wouldn't it be better to delete it, so people don't get stale copies?
09:53:42 <malcolmw> ndm: yup
09:53:45 <ndm> (we need to delete the www.cs Yhc repo as well!)
09:55:48 <syntaxfree> Cale: yes, I kinda got that from the wiki :)
09:56:20 <malcolmw> tfs: sorry about that.  there has been a webpage about darcs for nhc98 for a long time, I just forgot to upload it.
09:56:51 <syntaxfree> Cale: thanks!
09:56:57 <malcolmw> ndm: the page about CVS for nhc98 has now gone.
10:00:26 <nomeata> Hmm. Can we give one of the Haskell-Compilers a TeX-Backend? I mean, we aleady have Javascript...
10:00:56 <emu> lhs2TeX ;)
10:00:58 <ndm> nomeata: probably, i want to implement a generic backend for Yhc which targets a big variety of languages
10:01:08 <therp> what library would you use to access an SQL databases from haskell?
10:01:09 <bos31337> with ghc, what does -split-objs do?
10:01:11 <shapr> nomeata: What about functional metapost?
10:01:14 <ndm> nomeata: i.e. Python, Javascript, C at least
10:01:54 <nomeata> Hmm. Or postscript, then we can run haskell code on a printer.
10:02:10 <pjd> ndm: PyPy?
10:02:24 <pjd> that could be interesting
10:02:46 <ndm> we already have a Python bytecode interpreter, so having Python as an output language seems a natural extension...
10:02:59 <ndm> I also want C# and Java output, for trusted environments
10:03:39 <xic> do you guys think that a good programmer should know regular expressions?
10:03:44 <emu> yes
10:03:46 <nomeata> Even better: haskell output that is guaranteed to be shorter than the input :-)
10:03:56 <emu> they are a convenient notation for finite automata
10:04:35 <emu> at least, a good programmer should know how to describe a regular language
10:05:06 <malcolmw> tfs: any problems with building nhc98, drop me an email, I'm heading home now
10:05:16 <tfs> malcolmw: okay thanks for your help :-)
10:07:56 <mwc> Do we have a good option parsing library? Something like getopt or popt?
10:08:26 <emu> yep, GetOpt
10:09:57 <mwc> Is it in Base or what?
10:10:08 <ndm> @hoogle GetOpt
10:10:08 <lambdabot> Distribution.GetOpt :: module
10:10:08 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
10:10:08 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
10:10:09 <emu> search GetOpt in the  standard library page
10:10:57 <pjd> ndm: wait, what?  who's we, and what Python bytecode interpreter do they have?
10:11:17 <ndm> pjd: the Yhc team, we have Pyhi, which can run Haskell bytecode files with a Python runtime
10:12:05 <kc5tja> DAMN -- all out of Coke, all out of Oreos, and all out of pizza.  Time to get some food!!
10:12:06 <pjd> ndm: nifty!
10:12:25 <ndm> pjd: we have a lot of nifty things, that we've never told anyone about...
10:12:32 <syntaxfree> @hoogle oreo
10:12:33 <lambdabot> No matches found
10:13:36 <Saizan> is jhc still developed?
10:15:52 <bos31337> Saizan: yes.
10:16:17 <ndm> @tell dons http://www.cse.unsw.edu.au/~dons/images/commits/community/ - does that refer to Yhc at www.cs.york.ac.uk? It should be the darcs.haskell.org/yhc one
10:16:17 <lambdabot> Consider it noted.
10:17:51 <kc5tja> clear
10:17:53 <kc5tja> oops
10:18:51 <vincenz> Anyone know any literature on how to ensure that your denotaitonal semantics keeps a static environment, even in the presence of explicitly allocated and deallocated stack variables?
10:23:44 <dcoutts_> @seen sweirt
10:23:45 <lambdabot> I haven't seen sweirt.
10:24:37 <dcoutts_> @seen swiert
10:24:37 <lambdabot> I saw swiert leaving #haskell 1h 50m 38s ago, and .
10:24:46 <dcoutts_> @tell swiert got the book!
10:24:46 <lambdabot> Consider it noted.
10:45:21 <glguy> !paste
10:45:21 <hpaste> Haskell paste bin: http://hpaste.org/
10:54:45 <fons> hi all
10:55:16 <fons> how can instantiations be restricted when importing/exporting them from/to modules?
10:55:41 <norpan> fons: i think they cannot
10:56:01 <sjanssen> that is correct
10:56:18 <fons> :(
10:56:28 <fons> so they are all implicitly exported?
10:56:36 <sjanssen> fons: perhaps you want to use a newtype?
10:56:46 <fons> sjanssen, not really
10:56:49 <sjanssen> yes, implicitly (and transitively) exported
10:56:52 <fons> but thanks, I'll cope with it :)
10:56:55 <norpan> if they are you're own you can put them in a separate module
10:57:02 <norpan> youre
10:57:04 <norpan> your
10:57:13 <norpan> i'm sorry for the error
10:57:32 <norpan> i normally don't make that kind of error but i have jetlag
10:58:16 <sjanssen> instances should encapsulate fundamental operations on a type
10:59:07 <sjanssen> for example, if you instance Eq for a type, then it should be the One True Way to compare two values of that type
11:00:12 <norpan> maybe that is true for trivial types
11:00:15 <glguy> some instances are more complicated, like HAppS Matcher class, where (String [String]) (String String) (String ()) (() ())
11:00:17 <norpan> trivial classes
11:01:58 <sjanssen> I'd say that if there isn't One True Way to write an instance for a certain class and type, you should probably use newtypes
11:02:15 <sjanssen> the newtype wrappers in Data.Monoid are a good example
11:03:34 <fons> even with that, it would be expressive to show what instantiations are imported
11:03:59 <sjanssen> perhaps
11:04:10 <fons> it would be clarifying for someone browsing the code
11:04:31 <fons> import InstantiationModule (Foo (show))
11:04:53 <dcoutts> @tell malcolmw I'm happy to do SoC again
11:04:54 <lambdabot> Consider it noted.
11:05:09 <sjanssen> but what if you omit the class export?
11:05:46 <sjanssen> s/class/instance
11:06:23 <fons> sjanssen, then it shouldn't be exported (I don't know if it's feasible though)
11:06:54 <sjanssen> fons: I've read that there are implementation issues with multiple instances per type, but I can't remember the specifics
11:07:42 <fons> sjanssen, anyway, that's what I have so I'll stick to it
11:14:09 <fons> sjanssen, well, you can actually restrict the import and export of class methods
11:14:13 <fons> sjanssen, that should do
11:15:20 <fons> sjanssen, although it doesn't seem to be possible to restrict to what instances that method applies when exporting them
11:31:49 <shapr> shazam!
11:36:51 <svref> is there some way to specify a "timeout" for a computation?
11:38:22 <kowey> svref: http://portal.acm.org/citation.cfm?id=378795.378858 <-- i use this
11:38:24 <lambdabot> Title: Asynchronous exceptions in Haskell
11:46:15 <fasta> *** Exception: thread blocked indefinitely <- What does this mean?
11:50:57 <sorear> fasta: deadlock
11:51:20 <sieni> cool, deadlock detection
11:51:22 <sorear> just like <<loop>>, ghc can detect a small subset of threading locks
11:51:44 <fasta> sorear: "threading", I use one thread.
11:51:44 <sorear> in this case, one of your threads was waiting on an MVar with no writers
11:52:01 <fasta> sorear: I am not using MVars
11:53:13 <fasta> sorear: is the exception also thrown when single-threaded code is deadlocked?
11:54:22 <Syzygy-> Hmmmmmmm. Who's juggling the buildbots at darcs.haskell.org? And why is it that my box only ever builds head, even though I have two builds defined there?
11:54:36 <resiak> sorear: What loops can ghc detect?
11:55:06 <fasta> resiak: Hugs has better loop detection, in my experience.
11:55:32 <fasta> resiak: and the analysis is simple from what I remember.
11:56:11 <sorear> resiak: if a closure is re-entered
11:56:20 <sorear> > let f x = f (x + 1) in f 0
11:56:24 <lambdabot> Terminated
11:56:33 <sorear> > let f = f in f
11:56:35 <lambdabot>  Exception: <<loop>>
11:56:47 <sorear> where "Terminated" means SIGXCPU
11:57:06 <resiak> Ah, see, I've been thrying the latter in ghci, but I guess that I would have better results if I actually compiled something :)
11:57:11 <fasta> sorear: but any idea on how why that exception is thrown? I am not using multiple-threads.
11:57:58 <sorear> if no library is using MVars, than the only culprit is throw :(
11:58:01 <resiak> Hrm, I seem to have broken ghc :(
11:58:16 <sorear> try recompiling with -prof -auto-all and rerunning with +RTS -xc -RTS
11:58:41 <sorear> yow, the -fvia-C bug I reported:   * owner:  => simonpj
11:58:48 <sorear> must be serious
11:59:03 <sorear>  Simon PJ is looking into this.  HEAD is currently miscompiling itself, leading to the observed behaviour.
11:59:16 <Igloo> Syzygy-: What do you mean by juggling?
11:59:17 <SamB> ouch!
11:59:25 <Syzygy-> Igloo: I probably mean you.
11:59:28 <SamB> what is it miscompiling itself to do?
11:59:45 <Syzygy-> Igloo: There are two builds defined for mnemosyne, but only on ever runs. Is this deliberate?
12:00:52 <Igloo> Syzygy-: We haven't got around to making them alternate yet
12:01:00 <Syzygy-> Ah. Ok.
12:11:44 <fasta> Ok, this is not good. GHC and ghci produce different out comes....
12:12:41 <sorear> eh?
12:12:48 <shapr> shazam!
12:12:49 <sorear> what does -xc say?
12:14:03 <fasta> sorear: I was only working in ghci "mode" first, I will compile it with the right options now.
12:14:53 <fasta> Perhaps you haven't installed the profiling libraries for package EdisonAPI-1.2.1? <- ARG
12:15:08 <fasta> Build profiling libraries by default, please...
12:15:15 <sorear> oh, that could be a problem ...
12:15:41 * fasta builds edison with profiling libs...
12:15:44 <sorear> (./Setup.lhs configure -p btw)
12:19:58 <fasta> sorear: Ok, I ran as you specified. It doesn't give any extra output.
12:20:21 <fasta> sorear: in other words: GHC runs the code correctly, ghci doesn't.
12:20:23 <sorear> wow
12:20:40 <sjanssen> fasta: how does ghc react with -threaded?
12:20:53 <sorear> (compile time option)
12:20:57 <sjanssen> ghci uses the threaded RTS iirc
12:20:59 <fasta> sorear: thanks
12:21:39 <fasta> ghc-6.6: combination not supported: Threaded/Profiling
12:21:44 <fasta> Disable profiling?
12:21:51 <sjanssen> yeah
12:23:08 <fasta> No difference
12:23:28 <sorear> unfortunately -xc only works with profiling (it uses the cost-centre stacks), so you won't get a backtrace
12:24:02 <sjanssen> so ghci is reporting deadlock, but ghc isn't (with and without -threaded)?
12:24:13 <fasta> sjanssen: yes
12:24:38 <fasta> sjanssen: I am not catching any exceptions.
12:24:46 <fasta> sjanssen: maybe that matters
12:25:26 <fasta> sjanssen: The exception only gets thrown when I do C-c C-c at the moment the computation uses zero CPU
12:25:47 <sjanssen> can you paste the code?
12:26:03 <fasta> sjanssen: no :(
12:26:55 <fasta> sjanssen: I could try to produce a simpler instance.
12:27:39 <fasta> Ok, that's cool. I let ghci segfault
12:28:31 <fasta> Probably some .o files are reused by ghci incorrectly and then it dies.
12:28:53 <fasta> Not good
12:29:53 <sjanssen> that sounds likely
12:30:01 <fasta> Ok, that's cool. Suddenly, it works.
12:30:24 <fasta> I don't like not understanding what the hell is going on.
12:30:35 <sjanssen> heisenbug :)
12:30:58 <mux> did you guys hear that the Drupal guys are intending a rewrite in Haskell for the next version?
12:30:59 <fasta> That's a shiny name for human error.
12:31:09 <fasta> mux: no
12:31:13 <sorear> @whatis drupal
12:31:14 <lambdabot> I know nothing about drupal.
12:31:17 <sorear> @where drupal
12:31:17 <lambdabot> I know nothing about drupal.
12:31:18 <mux> it's a CMS
12:31:19 <fasta> some blog thing?
12:31:25 <mux> one of the most popular ones
12:31:29 <mux> if not the most popular
12:31:30 <fasta> What I said :)
12:31:44 <fasta> It's Python now?
12:32:03 <sjanssen> mux: very nice!  Any links about it?
12:32:07 <fasta> Did you read the paper by Sussman that was on Reddit?
12:32:38 <fasta> Not very technical, but does show at least a few ways for software to become better.
12:32:49 <fasta> (28 pages)
12:33:07 <mux> sjanssen: drupal.org
12:33:11 <mux> it's in the latest news IIRC
12:34:04 <fasta> Heh, PHP
12:34:19 <fasta> Well, I don't think Haskell is a bad choice when you only have PHP.
12:34:26 <mux> certainly
12:34:47 <fasta> OTOH, the rewrite does take an experienced Haskell developer
12:35:36 <sjanssen> mux: looks more like a year old April fools joke to me
12:35:55 * fasta agrees with sjanssen 
12:36:16 <fasta> Good joke
12:36:19 <mux> you're making me want to actually read the news item; I was told by a friend :-)
12:36:33 <fasta> mux: where's the news item?
12:36:38 <fasta> mux: I don't see it
12:36:53 <mux> let me look for it
12:37:12 <fasta> http://drupal.org/node/56815
12:37:13 <lambdabot> Title: Drupal rewrite from the ground up | drupal.org
12:37:17 <fasta> That's it
12:37:29 <mux> http://drupal.org/node/56815/
12:37:30 <lambdabot> Title: Drupal rewrite from the ground up | drupal.org
12:37:31 <mux> yeah
12:37:33 <fasta> chx - April 1, 2006 - 09:52
12:37:37 <fasta> Last year
12:37:42 <fasta> April Fools Day
12:37:50 <fasta> I missed it last year.
12:37:57 * mux nods
12:37:59 <mux> too bad :-)
12:39:03 <fasta> It could be that they are doing the same joke this year.
12:39:19 <fasta> Remember, it is PHP afterall ;)
12:39:44 <mux> PHP sucks so bad it sounded like a good idea to me when my friend told me about it
12:41:15 <fasta> Websites mostly have simple logic, and the problem sizes are so small that good algorithms aren't necessary.
12:41:28 <fasta> PHP has lots of bindings
12:41:31 <fasta> => practical
12:41:44 <fasta>  /=> it's good
12:41:46 <mux> I'd rather use Perl in that case
12:41:56 <mux> much more bindings/modules => more practical :-P
12:42:08 <fasta> mux: PHP is for a different generation, I think
12:42:35 <mux> if you mean the generation that doesn't really want to code, I agree with you
12:42:37 <dylan> PHP is a worse language than perl. :P
12:42:46 <fasta> Says dylan... ;)
12:42:48 <abz> Haskell rules
12:42:51 <dylan> give me lambdas, or give me death!
12:43:14 <dylan> I consider languages without lambdas to be crippled.
12:43:18 <bd_> dylan: I've heard PHP has a horrible hack involving passing code as a string... >.>
12:43:34 <dylan> bd_: that is not a lambda...
12:43:37 <fasta> I consider languaes without call-with-current-continuation crippled.
12:43:44 <fasta> languages*
12:44:04 <dylan> there's a perl module for call/cc, I think. :)
12:44:18 <fasta> dylan: I am sure it's implemented in a Perl-like way
12:44:31 <fasta> dylan: and if it isn't, I am interested
12:44:44 <dylan> I find I now implement (.) in most languages I use.
12:44:52 <Eighty> i keep writing (take n (repeat e)), is there a shorter way?
12:45:00 <fasta> Eighty: replicate
12:45:16 <bd_> http://search.cpan.org/~mlehmann/Coro-2.5/ :)
12:45:18 <lambdabot> Title: Marc Lehmann / Coro-2.5 - search.cpan.org
12:45:22 <fasta> > replicate 1 100
12:45:23 <lambdabot>  [100]
12:45:26 <fasta> > replicate 122 100
12:45:27 <lambdabot>  [100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100...
12:45:28 <Eighty> thanks
12:45:35 <bd_> it looks more like coroutines than continuations as such, but maybe you can capture it somehow
12:45:41 <dylan> @pl \n e -> take n (repeat e)
12:45:42 <lambdabot> (. repeat) . take
12:45:52 <dylan> hmm, thought pl would've caught that.
12:46:00 <Eighty> what does @pl do?
12:46:08 <bd_> is there a @check predicate to see if two functions have the same behavior? :)
12:46:09 <sorear> not much
12:46:13 <bd_> Eighty: Removes variables :)
12:46:22 <sorear> old bitrotted refactoring engie
12:46:28 <sorear> bd_: yeah!
12:46:35 <pjd> bd_: that provides generators and coroutines, yes, not continuations
12:46:53 <ddarius> @check \n -> take n (repeat 'a') == replicate n 'a'
12:46:55 <lambdabot>  OK, passed 500 tests.
12:46:57 <sorear> @check (\n e -> take n (repeat e) == replicate n e) :: Int -> Int -> [Int]
12:46:58 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `Bool'
12:47:03 <sorear> @check (\n e -> take n (repeat e) == replicate n e) :: Int -> Int -> Bool
12:47:05 <lambdabot>  OK, passed 500 tests.
12:47:34 <Eighty> is @check a specific thing for this channel?
12:47:34 <sorear> @check (\n e -> take n (repeat e) == replicate e n) :: Int -> Int -> Bool
12:47:36 <lambdabot>  Falsifiable, after 1 tests: -1, 1
12:47:58 <bd_> sorear: That's not really a predicate, you have to bind the arguments manually...
12:48:11 <sorear> Eighty: it's a lambdabot command, but it's a thin wrapper over Test.QuickCheck
12:48:13 <bd_> I was thinking more (. repeat) . take =:= replicate or something
12:48:42 <Eighty> @hoogle QuickCheck
12:48:42 <lambdabot> Test.QuickCheck :: module
12:48:43 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
12:49:11 <Eighty> it's not a standard library?
12:49:14 <sorear> Prelude> :m + Test.QuickCheck
12:49:14 <sorear> Prelude Test.QuickCheck> quickCheck $ \ n m -> n+m == (m :: Int)+n
12:49:14 <sorear> Loading package QuickCheck-1.0 ... linking ... done.
12:49:14 <sorear> OK, passed 100 tests.
12:49:22 <bd_> Eighty: define 'standard' :)
12:49:25 <bd_> It's in extralibs I think
12:49:27 <Eighty> comes with ghc
12:49:44 <bd_> which is very nearly 'comes with ghc'...
12:49:55 <Eighty> what's extralibs?
12:50:35 <sorear> everything other than 'base', IIRc
12:50:53 <sjanssen> Eighty: libraries packaged with ghc in the 6.4 era, but are now an optional additional install with the advent of 6.6
12:51:14 <hyrax42> in ghc head, "abc" :: IsString a => a?
12:51:16 <Eighty> how do i get them now?
12:51:35 <sjanssen> Eighty: what's your platform?
12:51:39 <Eighty> xp
12:52:10 <sjanssen> check ghc's download page, I think there might be several installers to choose from
12:52:19 <sjanssen> hyrax42: correct
12:52:55 <hyrax42> thanks
12:52:59 <ddarius> That's been a long requested feature if it means what I think it does.
12:53:04 * hyrax42 still runs 6.4.2 :/
12:53:06 <sjanssen> hyrax42: but it will default to String when monomorphism kicks in (just like numeric literals)
12:53:13 <Eighty> groan, no binaries. :(
12:53:39 <Igloo> sjanssen: Are you sure?
12:53:55 <sjanssen> Igloo: am I incorrect on the defaulting part?
12:54:24 <sorear> sjanssen: hm, hm 20070213 doesn't do it :(
12:54:24 <Igloo> I don't remember any special defaulting for IsString, but I might just have forgotten it
12:54:40 <sorear> s/hm /my /
12:54:48 <sorear> Prelude> :t "ab"
12:54:48 <sorear> "ab" :: [Char]
12:54:49 <Igloo> You only get generalised strings with a flag, incidentally
12:54:58 <sjanssen> sorear: -foverloaded-strings
12:54:59 <Igloo> s/generalised/overloaded/
12:55:11 <sorear> nice
12:56:40 <sjanssen> Igloo: yes, defaulting does work for IsString
12:57:08 <Igloo> sjanssen: In programs or just at the ghci prompt?
12:57:16 <sorear> sjanssen: :info IsString and :info [] don't tell me where the instance is
12:57:40 <sorear> Prelude GHC.Exts> :set -fno-extended-default-rules
12:57:40 <sorear> Prelude GHC.Exts> show "abc"
12:57:40 <sorear> "\"abc\""
12:58:15 <sjanssen> Igloo: in programs
12:58:22 <Igloo> OK, cool
12:59:02 <Syzygy-> > length $ mapM (\x->[x+i | i<-[-5..5]]) [1..5]
13:00:06 <sorear> Syzygy-: Prelude.mapM
13:01:26 <sorear> replicateM maxBound [0..] :: [[Int]]
13:01:56 <sorear> ~ 2^2^31 results !
13:02:35 <Syzygy-> Ah.
13:02:48 <Syzygy-> The prelude got relegated out of lambdas normal namespace?
13:02:53 <sorear> Syzygy-: no
13:03:19 <sorear> Syzygy-: but there's a conflict between Data.Traversable.mapM and Prelude.mapM
13:04:45 <Syzygy-> Ah.
13:05:10 <sorear> let ack [] n = ():n ; ack (_:m) [] = ack m [()] ; ack (_:m) (_:n) = ack m (ack (():m) n) in ack [()] [()]
13:05:10 <sorear> > let ack [] n = ():n ; ack (_:m) [] = ack m [()] ; ack (_:m) (_:n) = ack m (ack (():m) n) in ack [()] [()]
13:05:12 <lambdabot>  [(),(),()]
13:05:49 <sorear> > let ack [] n = ():n ; ack (_:m) [] = ack m [()] ; ack (_:m) (_:n) = ack m (ack (():m) n) in join ack [(),(),()]
13:05:51 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
13:07:07 <sorear> > let ack [] n = ():n ; ack (_:m) [] = ack m [()] ; ack (_:m) (_:n) = ack m (ack (():m) n) in join (.) (join ack) [(),(),(),()]  -- try this for long output contest
13:07:12 <lambdabot> Terminated
13:08:24 <fasta> http://www.mail-archive.com/perl6-language@perl.org/msg20426.html <- incorrect mail address protection
13:08:25 <lambdabot> Title: Non-deterministic programming in Perl 6
13:10:05 <vincenz> For all compiler people, #oasis is a good spot right now
13:10:37 <vincenz> In fact I made the following observation: ReaderT = statically scoped, StateT = dynamically scoped
13:10:40 <vincenz> :)
13:11:50 <pejo> vincenz, what channel is that, and what are they discussing?
13:11:59 <vincenz> denotational semantics
13:12:36 <pejo> (And who?)
13:13:36 <ddarius> @type let d x = (x,x);a = d (); b = d a; c = d b in c -- merely exponentially large types
13:13:38 <lambdabot> ((((), ()), ((), ())), (((), ()), ((), ())))
13:18:49 <ddarius> @seen pjd-
13:18:49 <lambdabot> I haven't seen pjd-.
13:18:54 <ddarius> @seen pjd
13:18:54 <lambdabot> pjd is in #haskell. I last heard pjd speak 32m 19s ago.
13:19:03 * pjd waves
13:21:40 <ddarius> Did you find the info re monads, adjunctions, and the state monad (and actually some other computational monads arise that way).
13:22:15 <pjd> sort of
13:22:25 <dino-> @seen monochrom
13:22:26 <lambdabot> I saw monochrom leaving #haskell 2d 1h 9m 34s ago, and .
13:22:37 <sorear> @seen monomorph
13:22:38 <lambdabot> I haven't seen monomorph.
13:22:39 <pjd> "adjunctions" has been high on my "scary words to understand" list for a while now
13:22:59 <xerox> anybody is a \bot administrator and can have her joining #haskell.it?
13:23:31 <sjanssen> lambdabot: @join #haskell.it
13:23:35 <xerox> thank you.
13:23:43 <pjd> so the state monad thing is tacked on to that
13:26:20 <pjd> ddarius: if you can recommend any good tutorialish literature in that category-theory-basics direction i'd be grateful :)
13:26:29 <matthew-_> ?hoogle Maybe a -> Maybe a -> Maybe a
13:26:30 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
13:26:45 <matthew-_> ok, I want an "and" equivalent of msum
13:27:01 <bd_> mplus?
13:27:19 <matthew-_> > mplus (Just 4) (Just 5)
13:27:20 <lambdabot>  Just 4
13:27:32 * matthew-_ thinks
13:28:11 <matthew-_> I want \a b -> if isJust a && isJust b then f a b else Nothing
13:28:38 <ddarius> pjd: Give me a sec.  There is at least one and probably two that I'd recommend for starters.
13:28:41 <matthew-_> or better yet; \a b -> if isJust a && isJust b then f (fromJust a) (fromJust b) else Nothing
13:28:57 <matthew-_> some sort of lift or fmap which combines two monads
13:28:58 <sjanssen> matthew-_: I think you want liftM2 f
13:29:00 <sorear> matthew-_: liftM2
13:29:06 <matthew-_> many thanks
13:29:12 <matthew-_> you guys are great
13:29:15 <sorear> > liftM2 (+) (Just 3) (Just 4)
13:29:17 <lambdabot>  Just 7
13:29:20 <sorear> > liftM2 (+) (Just 3) Nothing
13:29:22 <lambdabot>  Nothing
13:29:31 <sorear> > liftM2 (+) [1,2,3] [10,20,30]
13:29:32 <lambdabot>  [11,21,31,12,22,32,13,23,33]
13:29:42 <sorear> > liftM2 (+) (*2) (*3) 10
13:29:44 <lambdabot>  50
13:29:50 <ddarius> pjd: Depending on your math background the easiest thing (if it's not all the great) would be to ask about certain things here.  E.g. monoids are very simple, but when you have no idea what they are it can be confusing.
13:30:21 <pjd> i know what they are, yeah
13:30:39 <pjd> and monads, and functors
13:31:05 <ddarius> pjd: I didn't know/remember what they were when I started reading CT literature.
13:31:14 <JohnnyL> @type liftM2
13:31:17 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:31:19 <ddarius> Anyways, one of my favorites is http://www.let.uu.nl/esslli/Courses/barr-wells.html
13:31:19 <pjd> also some basic abstract algebra ideas
13:31:21 <lambdabot> Title: Courses: Barr / Wells
13:31:25 <JohnnyL> @src liftM2
13:31:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:31:35 <ddarius> There's a pdf version of that paper that can be found if you'd prefer.
13:33:24 <pjd> the lecture notes?
13:35:11 <dino-> I'm reading the Hughes paper _Generalising Monads to Arrows_, at some point he's discussing class MonadPlus, showing the function to impl as (++). Is that just old? That's not really the operator notation used (except for the [] monad).
13:37:45 <sorear> dino-: that sounds like the kind of thing in the 1.4 prelude ... things were alot more polymorphically useful back then
13:38:24 <Cale> Right, (++) was the monadic plus in 1.4
13:38:34 <ddarius> pjd: Yes.  Also, these http://www.brics.dk/~mcaccamo/ are very close to how I would (and do in a paper I'm working on) present CT.
13:38:35 <lambdabot> Title: Mario Jos&eacute; C&aacute;ccamo
13:38:49 <ddarius> @google Categorical Manifesto
13:38:52 <lambdabot> http://citeseer.ist.psu.edu/goguen91categorical.html
13:38:52 <lambdabot> Title: A Categorical Manifesto - Goguen (ResearchIndex)
13:38:55 <ddarius> Finally, that is a good read.
13:40:00 <ddarius> Albeit, not an introduction or tutorial.
13:40:18 <dino-> sorear, Cale: Interesting. Thank you.
13:40:25 <pjd> much thanks
13:40:28 <pjd> those are all new to me
13:40:36 <nominolo> @impl init
13:40:36 <lambdabot> Maybe you meant: pl unpl
13:40:45 <nominolo> @src init
13:40:45 <lambdabot> init [x]    = []
13:40:46 <lambdabot> init (x:xs) = x : init xs
13:40:46 <lambdabot> init []     = undefined
13:41:03 <nrb23> hm.. I have a foreign ptr function, and I need to force some evaluation, and then return the forced evaluation
13:41:04 <dino-> Cale: BTW, I would be very interested in a short arrows document a-la _Monads as Container_ (nudge, nudge)
13:41:08 <nrb23> due to scoping issues
13:41:21 <dino-> Trying to use HXT lately for something actually practical has got me up to my ass in arrow studies.
13:41:36 <nrb23> Cale, dino-: yes, I'd be interested in that too :->
13:41:57 <dino-> And yes, I have been reading the wikibooks stuff on arrows. It's good.
13:42:00 <Cale> The best way to think about HXT is to forget that it's got anything to do with arrows, and just try to understand what >>> is doing in the specific context.
13:42:01 <pjd> ddarius: where/when should i look for the paper you're working on? :)
13:42:35 <dino-> Cale: I may be making it too difficult, but now I need to number things I'm creating in the course of the >>> with HXT.
13:42:51 <dino-> And I'm unsure how to go about this stateful business with it. :/
13:42:58 <ddarius> pjd: I'm not going to publish it in anything, I'm not sure how I will make it available.  The layout needs to be worked on and I need to revise quite a bit.
13:43:22 <ddarius> pjd: Also, I'm considering making it be self-contained rather than requiring the basics of category theory.
13:43:33 <ddarius> pjd: This site you'll probably also find useful http://www.cs.le.ac.uk/people/akurz/books.html
13:43:35 <lambdabot> Title: Electronically Available Books and Other Sources (mainly Category Theory)
13:46:31 <pjd> whew
13:48:33 <nrb23> ?where pcap
13:48:34 <lambdabot> http://www.haskell.org/networktools/src/pcap/
13:49:15 <nrb23> could someone take a look at the 'next' function in Pcap.hsc (http://www.haskell.org/networktools/src/pcap/Pcap.hsc)
13:49:23 <nrb23> I think it may have a memory leak
13:49:36 <nrb23> but my knowledge of pointers and finalizers in haskell is poor
13:50:07 <mauke> where's the allocation?
13:50:19 <nrb23> allocaBytes
13:50:36 <nrb23> the PktHdr members aren't strict
13:50:48 <nrb23> so it seems that allocaBytes would go out of scope by the time the result of that function is used
13:51:39 <mauke> doesn't the IO monad sequence this stuff?
13:52:06 <Cale> dino-: hmm. As in, number them according to the sequence in which they're found?
13:53:24 <dino-> Cale: Yes, I will have a group of sibling tags and I want to output text lines numbered like 1 <first text>\n2 <second text>\n3 <third...
13:53:53 <dino-> seems tricky
13:54:08 <Cale> It's probably simplest to just use listA, and then zip the result with [1..]
13:54:34 <Cale> listA lets you collect all the results of an arrow up into a list.
13:54:48 <Cale> (an ArrowList, not a general arrow :))
13:55:21 <Syzygy-> ?index listA
13:55:21 <lambdabot> bzzt
13:55:28 <Syzygy-> Cale: Where is listA?
13:55:33 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-ArrowList.html
13:55:35 <lambdabot> http://tinyurl.com/upyok
13:55:36 <dino-> It's in Control.Arrow.ArrowList
13:55:40 <Syzygy-> Ah. Ok.
13:56:04 <Syzygy-> > :m + Control.Arrow.ArrowList
13:56:04 <Syzygy-> Could not find module `Control.Arrow.ArrowList':
13:56:04 <lambdabot>  Parse error
13:56:09 <Syzygy-> I seem to be missing something.
13:56:21 <Cale> HXT
13:56:33 <dino-> Cale: Ok, I'll take a look at that. Normally, each of these arrows is making a list anyway, but then the subsequent arrows operate on each item in that list.
13:56:49 <dino-> This must do something different, what you're suggesting with the listA.
13:57:12 <dino-> Syzygy-: Yeah, I see it in the Haddock docs for HXT.
13:57:30 <dino-> Syzygy-: http://www.ugcs.caltech.edu/manuals/libs/haskell-libraries/HXT-5.5/index.html
13:57:32 <lambdabot> http://tinyurl.com/275bhu
13:57:37 <Cale> 5.5?
13:58:00 <Cale> That's a couple major version numbers old.
13:58:06 <dino-> Er, that's the docs I found somewhere.
13:58:19 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/
13:58:24 <dino-> Yeah, what I have here compiled and installed is 7.1 :o
13:58:40 <Cale> That's always the current documentation.
13:59:06 <Syzygy-> There. hxt 6.1 on its way in.
13:59:35 <dino-> Don't know how I got those docs.
13:59:58 <Syzygy-> Mmmmmm. Network.HTTP.Base64 -- I might end up liking that.
14:00:33 <dino-> Cale: Thank you, about the listA. I'll take a look at that.
14:00:35 <sorear> nrb23: what does pcap_next return?
14:00:57 <nrb23> foreign import ccall pcap_next :: Ptr PcapTag -> Ptr PktHdr -> IO (Ptr Word8)
14:01:10 <Cale> Syzygy-: You mean 7.1?
14:01:18 <Syzygy-> No, I think I mean 6.1.
14:01:26 <Syzygy-> gentoo, emerge hxt, let it do what it likes...
14:01:33 <Syzygy-> Building hxt-6.1...
14:01:37 <Cale> ah, okay
14:01:54 * Syzygy- doesn't want to think unless really necessary. :P
14:02:16 <Syzygy-> Hmmmm. Building 36 of 107: it may take a while before I have it all here.
14:02:24 <Syzygy-> Cale: Did I poke you about my specification yet btw?
14:02:34 <Cale> Specification?
14:02:37 <sorear> nrb23: does pcap_next return or save a pointer into the header?
14:02:52 * Syzygy- is supposed to write a project specification for a CAS in Haskell till ... well ... friday next week.
14:02:54 <nrb23> sorear: it returns a pointer
14:03:03 <Syzygy-> After that we'll decide whether I should actually write the CAS too.
14:03:13 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/homhaskell.pdf
14:03:39 <sorear> nrb23: well, I can tell that much from the signature.  but the only manpage doesn't say what it points *to*
14:03:46 <matthew-_> how do I prevent ghci from reading compiled output?
14:03:59 <matthew-_> after ghc has compiled stuff, I often find that if I load the said compiled files into ghci then data constructors are missing
14:04:17 <matthew-_> so I want ghci to ignore the compiled stuff and interpret the .hs directly
14:04:18 <sorear> find . -name '*.o' -delete
14:04:34 <matthew-_> no, as compilation takes about 2 mins and I don't want to do endless make clean
14:04:40 <sorear> :set -fforce-recomp might also work
14:05:05 <sorear> in GHC it says to ignore .o files, I've never tried in in ghci
14:05:44 <matthew-_> cool, that works
14:05:46 <matthew-_> thanks
14:06:19 <sorear> nrb23: next won't leak memory from allocaBytes, but if pcap_next returns a pointer to malloced memory it might still leak
14:06:20 <nrb23> sorear:  a good point.. I'm not sure
14:06:34 <nrb23> sorear: hmm, allright
14:06:50 <nrb23> sorear: my program seems to do different things depending on where I print the packet I'm getting back
14:07:17 <Cale> Syzygy-: that's a value-level implementation of Peano arithmetic
14:07:24 <sorear> nrb23: gak! maybe it's a static buffer and you'll need to read it inside next?
14:07:43 <sorear> @ty Data.ByteString.copyCString -- nrb23
14:07:45 <nrb23> here's a C demo: http://www.tcpdump.org/pcap.htm
14:07:46 <lambdabot> Foreign.C.String.CString -> IO Data.ByteString.Base.ByteString
14:07:51 <lambdabot> Title: Programming with pcap
14:08:03 <sorear> @ty Data.ByteString.copyCString . Foreign.Ptr.castPtr -- nrb23
14:08:06 <lambdabot> forall a. GHC.Ptr.Ptr a -> IO Data.ByteString.Base.ByteString
14:08:26 <sorear> ^^ that will turn a Ptr Word8 (nul-terminated) into a ByteString, copyingly
14:08:32 <nrb23> sorear: not null terminated ;-<
14:08:46 <sorear> @ty Data.ByteString.copyCStringLen
14:08:49 <lambdabot> Foreign.C.String.CStringLen -> IO Data.ByteString.Base.ByteString
14:08:50 <nrb23> ok
14:09:07 <sorear> CStringLen === (Ptr CChar, CSizeT
14:09:14 <sorear> type synonym
14:10:33 <nrb23> in the C examples, they never free the packet from that function.. which is weird
14:11:01 <Syzygy-> Cale: I'm still not convinced I even want that Peano arithmetic there: I'm very much uncertain as to what I want to do with the matrix question at all...
14:11:22 * sorear checks the source
14:11:42 <sorear> gak! apt has 2 versions of libpcap
14:11:46 <Cale> Syzygy-: arrays will already keep track of their sizes at runtime.
14:11:49 <sorear> which are you using?
14:11:57 <sorear> or are 0.7 and 0.8 compatible?
14:12:01 <Cale> and you can ensure that they're rectangular more easily.
14:12:26 <Syzygy-> Cale: That's a point...
14:12:55 <nrb23> sorear: I would assume they're compatible
14:13:03 <sorear> nrb23: wow, debian's libpcap0.8 is version 0.9.5 !
14:13:15 <nrb23> sorear: go debian :->
14:13:25 <Cale> I wonder if GAP has any sort of FFI.
14:13:37 <Cale> Well, really I'm more interested in exporting.
14:13:44 <nrb23> I have whichever version comes with Mac OS X 10.4
14:14:22 <sorear> stefan@stefans:/usr/src/libpcap0.8-0.9.5$ find . -name '*.c' | xargs ctags  # go unix!
14:14:58 <mauke> ctags -R .
14:15:06 <sorear> that's no fun!
14:15:48 <Syzygy-> Cale: I checked: it doesn't seem to do FFI. :(
14:15:54 <Syzygy-> Or ... I think I checked...
14:15:58 <SamB> sorear: but how well does yours deal with files who's names contain \n
14:16:36 <SamB> and what happens when there are too many files to pass on one command line?
14:16:39 <nrb23> sorear: it looks to me like the caller doesn't have to free the packet
14:17:49 <Syzygy-> SamB: For that, you'll want a -print0 and a -0 in there too... :P
14:19:41 <nrb23> sorear: actually, it looks like everyone uses pcap_loop, and just uses it from within the callback, which is what I was doing until I decided I wanted a list of packets
14:20:31 <sorear> hehe.  I think lazy-list-of-packets is a better idiomatic haskell interface ...
14:20:35 <dylan> ctags **/*.c
14:20:40 <dylan> (later)
14:20:55 <sorear> what's the difference between ** and *?
14:20:59 <nrb23> sorear: me too
14:21:05 <dylan> ** recurses directories
14:21:56 <dylan> doesn't have the newline/space problem of xargs, but does have the line limit problem.
14:22:02 <sorear> nrb23: and by lazy I mean unsafeInterleaveIO (possibly with a packet-at-a-time interface a la getChar)...
14:22:18 <nrb23> sorear: interesting.. I'll take a look
14:22:29 <shapr> dylan: I use hasktags **/*hs~_darcs
14:22:53 <dylan> shapr: ah, a zsh (ab)user. :)
14:23:54 <shapr> dylan: heck yeah :-)
14:24:23 <nrb23> @src getChar
14:24:23 <lambdabot> getChar = hGetChar stdin
14:24:31 <nrb23> @src hGetContents
14:24:32 <lambdabot> Source not found. That's something I cannot allow to happen.
14:24:41 <nrb23> @src hGetChar
14:24:42 <lambdabot> Source not found. It can only be attributed to human error.
14:24:53 <nrb23> @src IO.hGetContents
14:24:53 <lambdabot> Source not found. My pet ferret can type better than you!
14:25:36 <nrb23> lambdabot has a pet ferret?
14:25:43 <dylan> apparently.
14:25:44 <nrb23> I hope it's not in California
14:25:52 <mauke> @quote ferret
14:25:52 <lambdabot> No quotes match. Just what do you think you're doing Dave?
14:26:30 <nrb23> grr.. where is hGetContents?
14:26:45 <edwinb> @hoogle hGetContents
14:26:46 <lambdabot> IO.hGetContents :: Handle -> IO String
14:26:47 <mauke> @index hGetContents
14:26:47 <lambdabot> System.IO
14:26:53 <mauke> @source System.IO
14:26:54 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
14:27:12 <edwinb> looks like we've ferretted it out
14:27:20 <nrb23> yes, but it's not there
14:27:22 <sorear> getContents = liftM2 (:) getChar (unsafeInterleaveIO getContents)
14:27:32 <sorear> GHC.IOBase / Handle / IO
14:27:38 <nrb23> ah
14:27:42 <sorear> those three contain the rts io impl
14:27:51 <sieni> <insert the canonical ferret joke from `fierce creatures` here>
14:29:30 <lambdabots_pet_f> Hello, I am lambdabot's pet ferret, I can type very well.
14:29:42 <shapr> wow
14:29:47 <Syzygy-> BWAHAHAHAHA!
14:29:50 <Syzygy-> > 1+2
14:29:51 <lambdabot>  3
14:29:59 <Syzygy-> @ferretsnack
14:29:59 <lambdabot> Unknown command, try @list
14:30:02 <lambdabots_pet_f> :)
14:30:06 <Syzygy-> @petsnack
14:30:06 <lambdabot> :)
14:30:10 <Syzygy-> BWAHAHA!
14:30:12 <Syzygy-> I like that.
14:31:18 <nrb23> what does getChar return when there aren't any more characters?
14:31:31 <xic> @docs getChar
14:31:31 <lambdabot> getChar not available
14:31:36 <xic> @hoogle getChar
14:31:37 <lambdabot> Prelude.getChar :: IO Char
14:31:37 <lambdabot> IO.hGetChar :: Handle -> IO Char
14:31:49 <xerox> @index getChar
14:31:50 <lambdabot> System.IO, Prelude
14:31:54 <xerox> @docs System.IO
14:31:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
14:32:00 <nrb23> fails with isEOFError?
14:32:05 <nrb23> hm
14:32:07 <nrb23> ok
14:33:18 <augustss> yes
14:33:43 <nrb23> and liftM2 turns that into []
14:34:03 <sorear> nrb23: no, my impl was a gross simplification
14:34:18 <nrb23> ah
14:35:24 <sorear> nrb23: http://darcs.haskell.org/ghc-6.6/packages/base/GHC/IO.hs
14:38:46 <sorear> whoa ... 2002:452c:8843:1:20e:a6ff:fe66:c5a3
14:38:52 <nrb23> so, it seems to work
14:39:01 <sorear> I think that's the first real ipv6 addr I've seen
14:39:30 <nrb23> but, since next returns nullPtr, I had to make a "mynext"
14:39:34 <Saizan> real as in public?
14:40:11 <sorear> real as in not invented
14:40:15 <nrb23> how can return something from "mynext" to make liftM stop ?
14:40:16 <siti> ping6 ::1
14:40:16 <siti> PING ::1(::1) 56 data bytes
14:40:16 <siti> 64 bytes from ::1: icmp_seq=1 ttl=64 time=0.041 ms
14:40:16 <siti> OS
14:40:20 <siti> :D *
14:40:40 <bos31337> @hoogle a -> [a] -> Bool
14:40:41 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
14:40:41 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
14:40:59 <sorear> nrb23: liftM2 will never stop - you'll need a more verbose explicit recursion
14:41:11 <nrb23> sorear: okay
14:42:10 <sorear> @ty let lazyUnfoldIO fn = unsafeInterleavIO $ fn >>= maybe (return []) (\x -> liftM (x:) (lazyUnfoldIO fn)) in lazyUnfoldIO
14:42:12 <lambdabot> Not in scope: `unsafeInterleavIO'
14:42:16 <sorear> @ty let lazyUnfoldIO fn = unsafeInterleaveIO $ fn >>= maybe (return []) (\x -> liftM (x:) (lazyUnfoldIO fn)) in lazyUnfoldIO
14:42:18 <lambdabot> Not in scope: `unsafeInterleaveIO'
14:42:26 <sorear> @ty let lazyUnfoldIO fn = System.IO.Unsafe.unsafeInterleaveIO $ fn >>= maybe (return []) (\x -> liftM (x:) (lazyUnfoldIO fn)) in lazyUnfoldIO
14:42:29 <lambdabot> forall a. IO (Maybe a) -> IO [a]
14:42:40 <sorear> although pointy would probably be better here :)
14:43:42 <nrb23> pointy?
14:44:05 <sorear> opposite of pointless
14:44:13 <nrb23> heh
14:44:20 <sorear> @help pointy
14:44:21 <lambdabot> pointful <expr>. Make code pointier.
14:44:46 <nrb23> yeah, I don't quite understand what you wrote :->
14:44:49 <sorear> @pointy (2:) . (3:)
14:44:50 <lambdabot> (\ e -> 2 : (3 : e))
14:45:07 <nrb23> fn is p -> Maybe p ?
14:45:39 <nrb23> ?where paste
14:45:39 <lambdabot> http://kakapo.scannedinavian.com:8000
14:45:42 <Saizan> fn is IO (Maybe a)
14:45:46 <nrb23> ?where hpaste
14:45:46 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
14:46:09 <sjanssen> @paste
14:46:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:46:12 * beelsebob_ pokes about for people who are interested in Haskell benchmarks
14:46:12 <sorear> @paste -- if you don't care about the source code
14:46:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:46:22 <nrb23> ahh
14:46:24 * sorear yelps
14:46:34 <sjanssen> @where+ paste http://hpaste.org/new
14:46:35 <lambdabot> Done.
14:46:51 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/561
14:46:55 <nrb23> doh
14:47:06 <nrb23> forgot to say my nick there
14:48:05 <nrb23> (I still don't quite have this whole monad thing down :-< )
14:48:14 <hpaste>  sorear annotated "(no title)" with "unsafeInterleaveIO keeps things in IO ... so you need binding, not application" at http://hpaste.org/561#a1
14:49:13 <nrb23> of course!
14:49:15 * nrb23 is an idiot
14:49:30 <sorear> we all are, don't feel lonely
14:50:24 <nrb23> it builds!
14:50:25 <nrb23> ship it!
14:52:58 <sorear> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
14:53:00 <nrb23> woot!
14:53:00 <lambdabot> Title: How to write a Haskell program - HaskellWiki
14:53:03 <nrb23> it even works and stuff
14:53:32 <sorear> that page has instructions on how to get cabal working, where to announce, etc
14:53:34 <nrb23> sorear: nice... I wish I had seen that when I first started
14:53:38 <bos31337> @hoogle filterM
14:53:39 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
14:53:39 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
14:53:39 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
14:54:05 <sorear> if you announce the normal way you'll be automatically added to HWN
14:54:25 <nrb23> HWN?
14:54:28 <sorear> well, it's really more of HQN (poke, poke, taunt, taunt)
14:54:35 <sorear> Haskell "Weekly" News
14:54:40 <nrb23> ah
14:54:49 <nrb23> well, I should probably have it do more stuff before I announce it to the world
14:59:07 <gotaku> Any ideas how I can write a neural network in Haskell?
14:59:34 <xic> i guess a good way to start would be figuring out a good data structure for your neural net
14:59:55 <sorear> \ inp1 inp2 inp3 inp4 -> (inp1+inp2 ,. ...) :P
14:59:55 <xic> which depends on what kind of neural network you want to make
15:00:29 <gotaku> Again I'm having trouble trying to do things in Haskell I can do in other languages...
15:01:15 <xic> gotaku: it would be awesome to have a NEAT implementation in haskell
15:01:16 <xic> http://www.cs.ucf.edu/~kstanley/neat.html
15:01:18 <lambdabot> Title: NeuroEvolution of Augmenting Topologies
15:03:30 <xic> gotaku: which other languages?
15:06:55 <chessguy> 'evening, haskellers
15:07:08 <chessguy> ?hoogle unzip
15:07:09 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
15:07:09 <lambdabot> List.unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
15:07:09 <lambdabot> List.unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
15:07:29 <gotaku> xic: C++ for one.
15:07:34 <resiak> I demand that someone add folds to Java Collections :(
15:08:09 <xic> gotaku: writing neural network code in haskell should be muh more pleasant then c++
15:08:48 <gotaku> xic: If I could figure out how.
15:08:56 <edwinb> you're not allowed to call it a fold, you have to call it a Visitor Pattern. or something.
15:09:07 <resiak> an Origami Pattern?
15:09:07 <siti> lol
15:09:19 <siti> visitor patterns are so clean ;)
15:09:28 <edwinb> yes, because they're folds ;)
15:11:31 <xic> gotaku: have you learned to program in haskell already?
15:12:56 <chessguy> xic, writing _ code in haskell should be much more pleasant than c++
15:13:01 <gotaku> xic: Kind of...
15:17:37 <Axioplas1> @index usleep
15:17:37 <lambdabot> System.Posix.Unistd, System.Posix
15:18:12 <sorear> Axioplas1: I think you want Control.Concurrent.threadDelay
15:18:37 <Axioplas1> sorear: I don't think yet :)
15:19:10 <Axioplas1> I just want to delay some operation, with a certain precision. I'll check your pointer.
15:19:11 <xic> warning: usleep will block all of your threads!
15:19:20 <Axioplas1> ha, well, indeed :)
15:35:41 <abz> ?poll-list
15:35:41 <lambdabot> ["OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","editor","jabberName"]
15:35:51 <abz> ?poll-results OperatingSystem
15:35:52 <lambdabot> Poll results for OperatingSystem (Open): House=1, GNU/Hurd=0, SuSE=1, Emacs=1, MacOS=4, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=2, OpenBSD=2, Gentoo=11, Debian=10, Ubuntu=4,
15:35:52 <lambdabot> FreeBSD=3
15:36:21 <chessguy> wow, gentoo and debian getting a lot of votes
15:36:33 <xic> wow, someone actually uses House?
15:36:46 <chessguy> i've never heard of it
15:37:04 <xic> you're not missing out
15:37:13 <abz> House?
15:37:23 <chessguy> what kernel is it?
15:37:28 <sorear> House
15:37:36 <xic> it's only a kernel
15:37:37 <sorear> or rather, GHC
15:37:44 <abz> http://programatica.cs.pdx.edu/House/ ?
15:37:46 <lambdabot> Title: House
15:37:53 <sorear> they ported the GHC RTS to i386 ring0
15:37:55 <chessguy> GHC is not a kernel
15:39:25 <sorear> the GHC RTS is much of a kernel; it has a scheduler, a memory allocator, and a interrupt-driven IO subsystem
15:39:58 <qwr> ?vote OperatingSystem Debian
15:39:59 <lambdabot> voted on "Debian"
15:39:59 <sorear> normally it gets a block of memory from a host OS, runs virtual CPUs as OS threads, and implements IO interrupts as SIGIO
15:40:27 <siti> how do you list poll results>
15:40:30 <siti> ?*
15:40:31 <lambdabot> Maybe you meant: . v
15:40:31 <abz> ?seen Cheery
15:40:31 <lambdabot> I saw Cheery leaving #haskell 1h 53m 14s ago, and .
15:40:35 <sorear> @poll-results OperatingSystem
15:40:36 <lambdabot> Poll results for OperatingSystem (Open): House=1, GNU/Hurd=0, SuSE=1, Emacs=1, MacOS=4, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=2, OpenBSD=2, Gentoo=11, Debian=11, Ubuntu=4,
15:40:36 <lambdabot> FreeBSD=3
15:40:53 <araujo> hello
15:41:18 <sorear> hello!
15:41:25 <mbishop> ?vote OperatingSystem Debian
15:41:26 <lambdabot> voted on "Debian"
15:41:55 <araujo> :-)
15:42:01 <abz> ?help tell
15:42:02 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
15:42:33 <sorear> ?tell abz Hello!
15:42:34 <lambdabot> Consider it noted.
15:42:59 <abz> so then how to you leave a message for someone next time they login?
15:42:59 <lambdabot> abz: You have 1 new message. '/msg lambdabot @messages' to read it.
15:43:27 <sorear> abz: we don't do that, because of autologin systems it isn't reliable
15:43:43 <abz> right.
15:45:09 <abz> ?seen bd
15:45:10 <lambdabot> I haven't seen bd.
15:45:12 <abz> ?seen bd_
15:45:13 <lambdabot> bd_ is in #haskell. I last heard bd_ speak 2h 18m 11s ago.
15:45:54 <bd_> hm?
15:45:58 <abz> bd: hey
15:46:18 <abz> bd: Every time someone uses AJAX to cripple functionality, god kills a kitten. Please, think of the kittens. :(..... Well I fixed it
15:46:30 <bd_> :)
15:46:33 <jer> forgive the stupid question, but i'm used to mutable data. if i've got a string that i'd build up in peices imperatively in my usual language, how might one suggest i go about the same thing (from a good style perspective) in haskell?
15:46:37 <abz> I used WASH in the end
15:46:46 <sorear> "difference lists"
15:46:56 <sorear> for a concrete example:
15:47:01 <mauke> collect the pieces and concat them
15:47:13 <sorear> that works too
15:47:51 <jer> hrmmm ok
15:47:58 <sorear> > let allNums low hi xs = if (low == hi) then xs else show low ++ " " ++ xs in allNums 1 10 ""
15:48:00 <lambdabot>  "1 "
15:48:09 <chessguy> jer, can you give us a concrete example of something you'd like to be able to do?
15:49:43 <jer> chessguy, i'm building up assembly language peice by peice, and for instance; i'm checking if the type of a label is an object/data/subroutine/etc and applying the appropriate .type <name>,@object/@function then sticking in the function alignment based on a flag, and then inserting the label name afterwards
15:49:50 <jer> i could give some code, but it's not done yet =]
15:54:43 <chessguy> jer, well, there's a lot of different approaches to building up strings in haskell, just like there's a lot of ways to do it in imperative languages
15:55:06 <chessguy> function composition is important: e.g., (foo . bar) myString
15:55:36 <chessguy> functions like words, filter, map, and all the other [a] -> Foo functions
15:55:50 <chessguy> of course concatenation
15:55:58 <jer> right; i was more looking for a suggested way because i feel like i'm abusing haskell =]
15:56:08 <jer> (and infact, i was told this by a friend too heh)
15:56:19 <chessguy> well, haskell is inherently high-level
15:56:36 <chessguy> so you may have to abuse it to do something so low-level
15:57:08 <chessguy> on the flip-side, domain-specific languages and parsers are its specialty
15:57:25 <chessguy> or one of them anyway
15:57:58 <jer> i have generally done all my DSL stuff in Io (the antonym of Haskell i must say)
15:58:22 <sorear> Haskell is a reaserch language that accidentally found a niche.
15:58:31 <sorear> It shouldn't be at all practical.
15:58:34 <jer> highly dynamic, unable to reason about a program w/o seeing the whole program, pure object-oriented, ast manipulation at runtime... all the "fun" stuff =D
15:58:42 <sorear> but it is ...
15:58:52 <chessguy> sorear, what are you talking about?
15:58:56 <sorear> Haskell
15:59:15 <sendark> hello there
15:59:17 <chessguy> "It shouldn't be at all practical. but it is..."?
15:59:21 <edwinb> practical? pah.
15:59:30 <edwinb> Some people seem to think you want to run programs after you write them too.
15:59:35 <mbishop> how can I get the time in seconds since the epoch in haskell?
15:59:50 <chessguy> that doesn't even make sense
16:00:07 <sm> jer: how about printf
16:00:30 <mbishop> ?hoogle time
16:00:31 <lambdabot> System.Time :: module
16:00:32 <lambdabot> Time :: module
16:00:32 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
16:00:34 <sorear> mbishop: System.Time, getEpochTime (I think)
16:00:45 <sorear> ?hoogle+
16:00:46 <lambdabot> System.Locale.timeFmt :: TimeLocale -> String
16:00:46 <lambdabot> System.Time.timeDiffToString :: TimeDiff -> String
16:00:46 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [(String, String)] -> String, String -> String -> String -> String -> String -> TimeLocale)
16:00:49 <sorear> ?hoogle+
16:00:49 <lambdabot> System.Locale.TimeLocale :: data TimeLocale
16:00:50 <lambdabot> System.Time.TimeDiff :: Int -> Int -> Int -> Int -> Int -> Int -> Integer -> TimeDiff
16:00:50 <lambdabot> System.Time.TimeDiff :: data TimeDiff
16:00:51 <chessguy> ?hoogle getEpochTime
16:00:52 <lambdabot> No matches found
16:00:57 <sorear> ?hoogle poch
16:00:58 <chessguy> ?hoogle epoch
16:00:58 <lambdabot> System.Posix.Types.EpochTime :: type EpochTime
16:00:59 <lambdabot> System.Posix.Types.EpochTime :: type EpochTime
16:01:07 <sorear> ?hoogle EpochTime
16:01:08 <lambdabot> System.Posix.Types.EpochTime :: type EpochTime
16:01:14 <chessguy> non-case-sensitive++
16:02:04 <jer> sm, that'd be a really long printf statement littered with conditionals ... i'm just going to append my strings to a list, then concat them
16:02:09 <jer> see how that works out
16:02:11 <jer> thanks everybody
16:02:14 <sm> sounds good
16:02:30 <sm> b
16:02:44 <mbishop> ?hoogle toClockTime
16:02:45 <lambdabot> Time.toClockTime :: CalendarTime -> ClockTime
16:02:45 <lambdabot> Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
16:03:22 <sendark> what does the operator ! exactly do with arrays?
16:03:29 <pejo> jer, what do you have, a data type for statements, and the statement can be a label, and... uh, what are you trying to do?
16:03:41 <mauke> sendark: []
16:04:55 <gotaku> Why does Control.Exception and the Prelude both have catch?
16:05:06 <sendark> awright, so if i have an array and i want it turned into a list, i just go my_array!
16:05:16 <sendark> and then a range or an index?
16:05:20 <twanvl> :t (!)
16:05:22 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
16:05:36 <jer> pejo, i have several datatypes; but this in particular is my module for adding labels to the assembly output
16:05:37 <mauke> array ! index
16:05:51 <mbishop> Hmm
16:05:55 <twanvl> (!) is to arrays as (!!) is to lists
16:06:00 <sendark> allright i see
16:06:08 <mauke> @hoogle Array i e -> [e]
16:06:09 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
16:06:10 <lambdabot> Data.Array.elems :: Ix i => Array i e -> [e]
16:06:12 <pejo> jer, have you looked at the NCG in GHC by the way? Doesn't sound totally unrelated to what you're doing.
16:06:18 <mbishop> sorear: any idea how to do this? Time.getClockTime returns a formatted day/date/time
16:06:29 <jer> pejo, it's not totaly unrelated, it's actually quite realted =]
16:06:32 <jer> but no i havn't looked at it
16:06:41 <jer> figure i should try and fail first, before looking at other peoples code
16:06:47 <jer> =]
16:08:11 <sorear> @hoogle IO TOD
16:08:12 <lambdabot> No matches, try a more general search
16:08:15 <sorear> @hoogle IO ClockTime
16:08:16 <lambdabot> Time.getClockTime :: IO ClockTime
16:08:16 <lambdabot> Directory.getModificationTime :: FilePath -> IO ClockTime
16:08:39 <SamB> is anyone here running powerpc64-unknown-linux-gnu?
16:08:44 <mbishop> :t Time.getClockTime
16:08:46 <lambdabot> IO System.Time.ClockTime
16:08:52 <SamB> or able to run it?
16:09:00 <xic> jer: Writer monad might be a good choice
16:09:10 <sorear> mbishop: in GHC the constructor for ClockTime is exported, it is called TOD, it contains a epoch time and picoseconds ... it's a haskell struct timespec
16:09:34 <mbishop> I have no idea what that means :)
16:09:42 <mbishop> ?hoogle TOD
16:09:43 <lambdabot> System.Time.TOD :: Integer -> Integer -> ClockTime
16:09:43 <lambdabot> Data.Dynamic.toDyn :: Typeable a => a -> Dynamic
16:09:43 <lambdabot> Char.intToDigit :: Int -> Char
16:10:15 <SamB> anyone have PowerPC linux at all?
16:10:23 <jer> SamB, yup
16:10:28 <jer> 32 though not 64
16:10:33 <SamB> ah.
16:10:42 <xic> jer: maybe this kind of structure is good for you:
16:11:06 <chessguy> mbishop, that's a typical reaction when sorear talks :)
16:11:15 <mbishop> sorear: apparently TOD takes the epoch time as an argument
16:11:16 <SamB> I heard that GMP doesn't work right on typical powerpc64 systems...
16:11:26 <xic> > execWriter $ do { tell "hello, "; tell "world!" }
16:11:27 <lambdabot>  "hello, world!"
16:11:29 <mbishop> or two, to be exact
16:11:32 <mbishop> to give you a specific date
16:11:37 <mauke> do tell!
16:11:52 * chessguy rolls his eyes at mauke 
16:11:58 <mbishop> Prelude System.Time> TOD 0 0
16:11:58 <mbishop> Wed Dec 31 18:00:00 CST 1969
16:12:06 <mauke> chessguy: you rolled a 7!
16:12:06 <jer> xic, hrmm... that does actually seem like it might be helpful
16:12:52 <chessguy> shame i don't have that much luck at the casinos
16:13:54 <sorear> > TOD 1000000 0
16:13:55 <lambdabot>   Not in scope: data constructor `TOD'
16:14:01 <sorear> > System.Time.TOD 1000000 0
16:14:03 <lambdabot>   Not in scope: data constructor `System.Time.TOD'
16:14:07 <chessguy> ?hoogle Bounded
16:14:08 <lambdabot> Prelude.Bounded :: class Bounded a
16:14:15 <jer> xic, thanks
16:14:20 <chessguy> ?instance Bounde
16:14:20 <lambdabot> Maybe you meant: instances instances-importing
16:14:21 <sorear> anyway, one is seconds, the other pico seconds
16:14:22 <chessguy> ?instance Bounded
16:14:22 <lambdabot> Maybe you meant: instances instances-importing
16:14:27 <chessguy> ?instances Bounded
16:14:28 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
16:14:46 <sorear> dons: awake?
16:14:49 <chessguy> ?hoogle All
16:14:49 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
16:14:49 <lambdabot> Foreign.Marshal.Alloc :: module
16:14:49 <lambdabot> Distribution.Extension.AllowIncoherentInstances :: Extension
16:37:49 <dons> sorear: ?
16:37:49 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:37:51 <mbishop> sorear: figure out the time thing yet? :\
16:37:57 <dufflebunk> How is Haskell normally pronounces? Like Pascal?
16:38:23 <mbishop> just like it's spelled
16:38:50 <mbishop> "Has-skull" or "Has-skell" or "Has-call"
16:39:45 <sorear> Ha-sk-ell for me
16:40:01 <xic> ha-skull
16:40:03 <jer> Torture for me =D
16:40:28 <sorear> dons: I decided against what I was going to ask about, sorry.
16:40:50 <sendark_> yea, the second syllable is a schwa
16:41:18 <JohnnyL> the question is how do you pronounce Dr. Haskell's name?
16:41:28 <sorear> cuh-rie
16:41:42 <sorear> you don't call doctors by their first names
16:41:49 <edwinb> http://www-fp.cs.st-andrews.ac.uk/~eb/spj-says-haskell.wav :)
16:41:54 <mbishop> http://www.cs.aau.dk/~normark/prog3-03/html/notes/higher-order-fu.html
16:41:58 <lambdabot> Title: Higher-order Functions, http://tinyurl.com/2hx2b8
16:41:59 <edwinb> (I think I got that from shapr...)
16:45:45 <sendark> i'm writing a sudoku solver with constraint satisfaction, and it needs a lot of work on arrays, can u guys point me out to some doc about arrays?
16:49:02 <sorear> @wiki Modern array libraries
16:49:03 <lambdabot> http://www.haskell.org/haskellwiki/Modern array libraries
16:49:12 <sorear> @wiki Modern_array_libraries
16:49:13 <lambdabot> http://www.haskell.org/haskellwiki/Modern_array_libraries
16:49:47 <sendark> cheers
16:51:01 <mbishop> sorear: figure anything out about getting time in seconds since the epoch?
16:51:36 <sorear> (\(TOD x _) -> x) `fmap` getClockTime doesn't work?
16:51:56 <dancor> what library do i use to manipulate x11 windows
16:52:12 <sorear> @docs Graphics.X11
16:52:13 <lambdabot> Graphics.X11 not available
16:52:20 <Darius> @index X11
16:52:21 <lambdabot> bzzt
16:52:25 <dancor> i want to make a little expos√© thing
16:52:27 <emu> @hoogle X11
16:52:28 <lambdabot> No matches found
16:52:41 <sorear> http://haskell.org/ghc/dist/current/docs/libraries/X11/Graphics-X11.html
16:52:42 <allbery_b> I'm not sure Graphics.X11 has enough fu in it
16:52:44 <lambdabot> http://tinyurl.com/yo8b9j
16:53:18 <allbery_b> mbishop: System.Posix.Time has some useful stuff in it
16:53:43 <dancor> allbery_b: fu?
16:54:00 <sorear> Prelude> :m + System.Time
16:54:00 <sorear> Prelude System.Time> (\(TOD x _) -> x) `fmap` getClockTime
16:54:00 <sorear> 1171932719
16:54:00 <sorear> Prelude System.Time>
16:54:03 <allbery_b> last I checked it was pretty lame
16:54:04 * Darius starts a paper on the Riemann Hypothesis.
16:54:06 <sorear> mbishop: ^^^
16:54:10 <emu> kungfu
16:54:11 <mbishop> ugh
16:54:15 <mbishop> that looks paintful heh
16:54:18 <mbishop> -t
17:00:08 <dancor> do i really want to use xlib instead of like gtk?
17:00:13 <siti> no
17:02:27 <xic> yes
17:02:52 <dancor> do any (all?) of the high level gui libraries get you like a list of all windows and the ability to move/resize them
17:03:32 <siti> well there's a library called libwnck that can do it but there's haskell bindings :p
17:03:48 <dancor> there's no haskell bindings you mean?
17:04:30 <siti> yeah that's what I mean
17:04:31 <siti> oops
17:04:37 <sorear> dancor: look at the mailing list - there is a project to create a full X11 Haskell Binding directly from the protocol spec
17:04:58 <sorear> dancor: which is easier than it sounds, since the protocol spec is machine readable :)
17:05:37 <sorear> if you can do it with Network.Socket, you'll be able to do it with XHB
17:08:01 <sorear> dons: my todo wrt nobench: (a) create templates $(eval foo) so that adding new compiler option sets is a one-line affair  (b) get it using time(1) so I can safely run it in the background  (c) have anacron do a daily nobench run!  (d) parser-friendly XML output
17:08:42 <dons> re. d) the output is dumped into a .db file for each test
17:08:54 <dons> that's just a 'show/read' structure that is easy enough to parse
17:08:59 <dons> the other things all sound good
17:09:09 <dons> i want to add hbc support today, and port the rest of nofib
17:09:36 <xic> dancor: you mean just windows from your application, or all of the windows from all applications?
17:09:43 <sorear> dons: where are the .db files?  are they not created until the very end?
17:10:04 <sorear> er, found em.  find(1) saves the day.
17:13:30 <sorear> xic: he specified "writing an expose-like thing", so all apps
17:14:40 <xic> oh...... don't do that. "expose" is shit
17:15:51 <dons> ;2A
17:15:53 <Cale> Expos√©?
17:16:08 <Cale> It's better than nothing, it's not a replacement for multiple desktops.
17:16:49 <dancor> xic: all windows
17:17:12 <xic> a replacement for multiple desktops would be a window manager with tagging support, like wmii :)
17:17:37 <xic> dancor: i'm not even sure that you can do this with xlib
17:18:32 <dancor> Cale: i just want a better alt+tab
17:18:58 <dancor> Cale: bringing all window into view and numbering them for selection seems good to me
17:19:30 <sorear> Alt-Fn forever!
17:19:44 <sorear> C-x b is also handy, esp with iswitchb
17:20:02 <Cale> The only problem with the Expos√© way to do it is that often you have lots of windows which look similar when scaled down.
17:20:32 <dancor> yeah
17:20:41 <sorear> I don't like windows.
17:21:02 <dancor> Cale: so you just don't overlap and remember which desktop different things are on?
17:21:18 <sorear> dons: gah, on partial-sums yhc is >33% slower than hugs!
17:21:39 * ddarius should get Ubuntu on the web so he can use ion in a friendly environment.
17:21:43 <Cale> Yeah, I mostly organise things into desktops, and I have a taskbar in my panel that shows the windows on the current desktop.
17:21:58 <xic> dancor: my window manager doesn't let me overlap windows, and it lets me tag windows
17:22:18 <sorear> And I don't use windows at all.
17:22:50 <Cale> I liked Enlightenment's pager, back when I used it. It showed a snapshot of each of your desktops, and the windows were actually draggable in the pager.
17:22:51 <sorear> I can, I have a system supporting them ... but I never want to use it.
17:23:21 <sorear> Fitt's law can be completely subverted by eschewing mice.
17:23:30 <Shammah> Cale: I do however find the expose approach a really useful adjunct to virtual desktops - especially on a v.small screen.
17:23:51 <Cale> When combined with multiple desktops, it's nice
17:24:07 <Cale> because there are probably only a few windows to look through on each desktop
17:24:16 <sorear> yhi executes very different instructions from ghc or hugs
17:24:47 <Shammah> Cale: exactly - I personally find expose invaluable given I'm using a 12" display here.
17:24:56 <sorear> I have the kind of computer that makes perceptibly different noises depending on the instruction mix :)
17:25:04 <Cale> Hehe, when I was using it, I had a 23" display :)
17:26:03 <Shammah> I can have 4-6 overlapping windows per desktop over 4 desktops gives me up to 24 windows open and I don't really notice the smaller display that much as expose allows me to quickly get a handle on any given desktop.
17:26:53 <Shammah> and because there are only 6 windows per desktop even the terminals are still legible when shrunk.
17:28:31 <zbrown> Any suggestions on a preferred haskell implementation?
17:29:00 <xerox> ?where ghc
17:29:00 <lambdabot> http://haskell.org/ghc
17:29:54 <zbrown> xerox: thank you.
17:29:58 <sorear> seriously, hugs and nhc and hbc are obsolete, jhc is slow and extremely buggy, yhc is incomplete
17:30:09 <sorear> only ghc works reliably and is current
17:30:23 <kc5tja> Is GHC GPLed?  Just curious.
17:30:32 <sorear> kc5tja: IIRC it's BSD3
17:30:32 * kc5tja is currently trying to track down a bug in Firefox.  >:(
17:30:37 <kc5tja> sorear: Nice!
17:31:16 <sorear> /usr/share/doc/ghc6/copyright contains a standard berkely license.  go debia.
17:32:08 * sorear wonders how many of the bugs in firefox would not exist if it was written in a default memory safe language
17:32:23 <nostrademons> probably a lot of them
17:32:35 <sorear> eg Java, Haskell, Perl, PHP, ..
17:32:40 <nostrademons> then again, wonder how much more of a memory hog it would be
17:32:44 <xic> actually, most of firefox is already written in a memory safe language: javascript
17:32:54 <nostrademons> a Java-based Firefox is a rather disgusting thought
17:32:56 <nostrademons> HotJava?
17:33:19 <sorear> xic: how so?
17:33:22 <zbrown> I'm gonna go noob style here and ask what kinds of things are programmed in haskell? Or if anyone has a doc that could give me that kind of info, I'd be greatly appreciative :).
17:33:30 <Darius> xic: That's not the impression I got looking at the source base a few years ago.
17:33:40 <nostrademons> zbrown: Pugs, GHC, and Darc are the main ones.  Epigram too
17:33:46 <nostrademons> a lot of compilers
17:33:59 <sorear> zbrown: stuff that is (a) hard (b) !performance critical (c) written in acadamea
17:33:59 <nostrademons> it's common for several other small language projects
17:34:05 <nostrademons> Galois uses it for high-assurance software
17:34:23 <gvdm_other> how aggressive is GHC in terms of concurrency? (due to the nature of haskell and the ease in figuring out where you can safely make operations parallel)
17:34:26 <sorear> hard is the main qualifier
17:34:32 <sorear> gvdm_other: not very.
17:34:39 <xic> gecko is a huge stinky pile of c++, but most of the user interface code is javascript
17:34:53 <sorear> gvdm_other: it turns out making everything concurrent, while safe, is a very dramatic pessimization.
17:35:07 <nostrademons> sorear: Hard is a relative term.  Web development in Java is *hard*, and it has nothing to do with the problem domain...
17:35:10 <zbrown> sorear nostrademons thanks :). I got curious about it, I do a pretty good amount of programming and some of the stuff I'll be doing as I get to higher level mathematics (i do research as well) may require a bit more 'umph'.
17:35:10 <dons> hehe "  Conor's Rule
17:35:10 <gvdm_other> wouldn't this be a good thing to put effort into (now that everyone is talking muilticore)
17:35:10 <dons>   Any sufficiently complicated Haskell or ML program contains an ad hoc, informally-specified,
17:35:13 <dons>   bug-ridden, half-completed simulation of dependent types"
17:35:21 <sorear> gvdm_other: but adding concurrency is very easy - parList [x,y]  computes x and y in parallel
17:35:22 <Darius> sorear: There are plenty of easy things written in Haskell and Haskell is also good at easy things
17:35:41 <xic> gvdm_other: there is lots of research going on
17:35:58 <dons> concurrency and parallelism is very very hot in ghc right now.
17:36:04 <Pseudonym> dons: I disagree with that.  It's usually not bug-ridden.
17:36:07 <dons> in particular, the data parallel arrays library. thanks MS for funding that
17:36:11 <gvdm_other> I was thinking that the big win would be that when programming in haskell you don't even have to think about concurrency and the compiler figures it all for you
17:36:23 <Pseudonym> dons: The rest is true, though.
17:36:29 <dons> gvdm_other: well known, intractible problem....
17:36:30 <sorear> gvdm_other: you still have to think about concurrency ...
17:36:31 <Darius> Pseudonym: At the rate they go, they're usually not informally-specified or ad-hoc either.
17:36:37 <Pseudonym> Not true.
17:36:38 <Darius> Half-completed, yes.
17:36:38 <dons> you can give hints though, that the compiler will figure out
17:36:43 <xic> gvdm_other: lots of research right now trying to make that a reality, but it's harder then it seems
17:36:46 <sorear> gvdm_other: but you don't have to think about concurrency *bugs*
17:36:51 <Pseudonym> Generally speaking, you just need a couple of dependent type thingies.
17:36:52 <gvdm_other> would make haskell well suited to the future (once again, the concentration on multi core stuff)
17:37:07 <dons> gvdm_other: right. have you seen the multicore ghc paper?
17:37:09 <SamB> Pseudonym: how do you informally specify types in Haskell?
17:37:11 <gvdm_other> nope
17:37:14 <gvdm_other> link me?
17:37:23 <Pseudonym> SamB: As a matter of fact, I removed one such example from Edison.
17:37:25 <gvdm_other> ?where multicore
17:37:25 <lambdabot> I know nothing about multicore.
17:37:27 <sorear> gvdm_other: `par` never makes your program nondeterministic or buggy.  It only affects performance.
17:37:33 <Pseudonym> That was the first thing I did.
17:37:40 <sorear> gvdm_other: unlike threading, which introduces bugs.
17:37:48 <Pseudonym> Patricia tries only work on integer types.
17:38:11 <dons> gvdm_other: tart here, http://haskell.org/haskellwiki/Libraries_and_tools/Concurrency_and_parallelism
17:38:13 <lambdabot> Title: Libraries and tools/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/wvlsw
17:38:35 <Darius> sorear, gvdm_other: Hence the typical distinction between concurrency and parallelism (as is likely discussed on that page).
17:38:42 <dons> the paper I referred to, for the new magical parallel arrays, is , http://www.cse.unsw.edu.au/~chak/papers/CLPKM06.html
17:38:42 <lambdabot> Title: Research Papers of Manuel Chakravarty
17:38:46 <Pseudonym> Because H98 doesn't even have fundeps, Chris Okasaki typed this by adding a polymorphic key as a phantom type, created one typeclass instance (for Int), and added a comment that you really shouldn't add any other instances.
17:38:49 <Pseudonym> That's pretty informal.
17:39:07 <dons> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 20
17:39:09 <lambdabot>  10946
17:39:12 <dons> ^^ parallel, pure code!
17:39:25 <dons> gvdm_other: note the `par` annotation to fork a thread..
17:39:32 <gvdm_other> i see it
17:39:59 <xic> gvdm_other: another interesting thing about haskell is STM
17:40:05 <sorear> gvdm_other: soon lambdabot will move to a 16-core machine - then the difference will be obvious
17:40:23 <dons> sorear: yeah, we found a kernel bug. have to update the kernel first
17:40:23 <LoganCapaldo_> Is there a quick little example set for ReadP?
17:40:24 <gvdm_other> sorear: well, there will at least be wins over stuff like C, where you have to think about concurrency fully to do it at all
17:40:46 <dons> unlike here, where you can write concurrent code in one line, in an irc channel...
17:40:53 <dons> and who says concurrency's hard?! :-)
17:41:19 <dancor> i do all my concurrency coding in-channel
17:41:36 <xic> gvdm_other: haskell is probably the best language for doing concurrency, with it's main competitor probably being erlang. but haskell beats erlang :)
17:42:03 <nostrademons> xic: I prefer Erlang for concurrency, actually
17:42:08 <sorear> dons: kernel bug!?  I'm ... suprised and amazed.
17:42:08 <Darius> Concurrent constraint/logic languages are pretty slick.
17:42:13 <gvdm_other> I've been told erlang whips all when it comes to light weight threading
17:42:23 <nostrademons> I think message-passing is a more intuitive way to design programs than STM
17:42:33 <Darius> Doing message-passing concurrency in Haskell is pretty clean as well.
17:42:35 <dons> sorear: really? 16 cores is going to stress and old kernel. something about it saying "oops...smp"
17:42:42 <nostrademons> yeah, Haskell's no slouch
17:42:43 <xic> nostrademons: you can build a message-passing system on top of STM
17:42:49 <nostrademons> it's just not designed for concurrency like Erlang
17:42:58 <dons> or just use Chan
17:43:05 * Darius likes Chan.
17:43:13 * nostrademons likes Chan too
17:43:43 <xic> gvdm_other: ghc's light weight threads are damn good
17:44:27 <Cale> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 30
17:44:30 <lambdabot>  1346269
17:44:35 <ddarius> I don't think I ever really stressed them with my embedding of pi-calculus into Haskell.
17:45:21 <Cale> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 32
17:45:24 <lambdabot>  3524578
17:45:32 <dancor> how slow will he go?!
17:45:34 <Cale> It is fast :)
17:45:51 <Cale> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 40
17:45:52 <ddarius> > let nfib 0 = 1; nfib 1 = 1; nfib x = nfib (x-1) + nfib (x-2) in nfib 32
17:45:55 <lambdabot>  3524578
17:45:57 <lambdabot> Terminated
17:46:07 <dancor> Burninated
17:46:11 <Cale> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 34
17:46:15 <lambdabot>  9227465
17:46:43 <Cale> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 36
17:46:47 <lambdabot> Terminated
17:47:32 <Cale> Only one more to try :)
17:47:34 <Cale> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 35
17:47:38 <lambdabot> Terminated
17:47:41 <Cale> nope
17:48:08 <dancor> haskell the language of choice for all your n <= 34 problems
17:48:35 <Cale> It is exponential time though.
17:49:04 <chessguy> three strikes, you're out
17:49:05 <dons> mm. remember that number once i switch on to the 16 core box
17:49:14 <dons> hoepfully we can compute a few more fibs
17:49:16 <sorear> dons: it won't change.
17:49:23 <Cale> n=34 takes a significant amount of time on my uniprocessor machine :)
17:49:24 <sorear> dons: RLIMIT_CPU is total
17:49:55 <Cale> about 36 seconds without compiling.
17:50:25 <sorear> Cale: note that lambdabot compiles. (I don't think it uses -O however)
17:50:31 <xerox> ?index par
17:50:31 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
17:50:45 * LoganCapaldo_ tries again, more specifically
17:51:00 <LoganCapaldo_> How does one "run" a ReadP parser?
17:51:01 <dons> it uses -O now
17:51:03 <sorear> > let psum [] = 0; psum [x] = x ; psum xl = psum (psum2 xl) where psum2 (x:y:s
17:51:04 <lambdabot>  Parse error
17:51:10 <sorear> LoganCapaldo_: readP_to_S
17:51:26 <chessguy> dons, come on. what do you know about lambdabot?
17:51:30 <sorear> > readP_to_S (many1 (char 'a')) "aaaab"
17:51:31 <lambdabot>   Not in scope: `many1'
17:51:33 <Cale> yeah, it's significantly faster when compiled
17:51:34 <LoganCapaldo_> sorear, yes I know :) Ok baby steps
17:51:41 <LoganCapaldo_> ok
17:52:06 <sorear> 7 down, 17 to go ... (nobench tests)
17:52:34 <ddarius> @type readP
17:52:36 <lambdabot> Not in scope: `readP'
17:52:41 <ddarius> @index readP
17:52:41 <lambdabot> bzzt
17:52:56 <sorear> after 1h roughly
17:53:04 <dons> sorear: yeah, the timeout could be lowered
17:53:10 <sorear> dons: how fast is nobench for you? :)
17:53:15 <dons> hey, have you noticed hugs really thrashes memory on parsing?
17:53:25 <sorear> nope
17:53:26 <dons> i get like 250M consistenly on hugs startup when it sucks in all the src
17:53:42 <dons> yeah, about an hour. or a bit more.
17:54:02 <sorear> well, I've 384mb of core, and normally use 8m of it, so I didn't notice :)
17:54:08 <dons> sorear: i'd like to generate a table something like http://www.antoniocangiano.com/articles/2007/02/19/ruby-implementations-shootout-ruby-vs-yarv-vs-jruby-vs-gardens-point-ruby-net-vs-rubinius-vs-cardinal
17:54:10 <lambdabot> Title: Ruby Implementations Shootout: Ruby vs Yarv vs JRuby vs Gardens Point Ruby .NET  ..., http://tinyurl.com/2eu9e3
17:54:25 <sorear> dons: It has been running for an hour, and I have 7/24 .dbs
17:54:42 <sorear> so it gets 24/24 in an hour for you?
17:54:44 <dons> mostly hugs timing out?
17:54:50 <dons> sorear: not sure. its at least an hour
17:55:06 <LoganCapaldo_> sorear, imposing some more, so what's wrong with readP_to_S (sepBy (string ",")) "hello,world" ?
17:55:06 <xerox> dons: ah, I know the guy who wrote that.
17:55:27 <sorear> dons: hugs and yhc
17:55:32 <LoganCapaldo_> Since the type errors are making my eyes bleed
17:56:56 <chessguy> "You've changed clothes, Mr. Bond. I hope we're not causing you to perspire." "A little, but I won't consider myself in trouble until my eyes start to bleed."
17:57:23 <siti> lol
17:57:30 <sendark> bond is class.
17:57:34 <siti> yeah
17:58:56 <sorear> readP_to_S (sepBy (many get) (string ",")) "hello,world"
17:59:15 <sorear> you were missing one of the args to sepBy
17:59:35 <dons> i like this idea of adding hacle+clean to the runs
17:59:39 <LoganCapaldo_> Of course I was
17:59:51 <LoganCapaldo_> well thanks
18:00:21 * LoganCapaldo_ contemplates -warn-arity-on-typecheck-failure option
18:00:54 <sorear> dons: did he send the patch, or are you just playing mailing list catchup?
18:01:32 <dons> just playing catch up
18:01:44 <jcreigh> LoganCapaldo_: that would be pretty nice. Just a hint: "Function 'foo' takes X arguments, but is only given X-1 here. Is that what you meant?"
18:01:57 <LoganCapaldo_> yeah
18:02:05 <LoganCapaldo_> not all the time
18:02:09 <chessguy> hmm, then you'd get that for every partial application
18:02:12 <LoganCapaldo_> jsut if it doesn't compile anyway
18:02:14 <dons> ?where hbc
18:02:15 <lambdabot> I know nothing about hbc.
18:02:20 <dons> ?where+ hbc http://www.cs.chalmers.se/~augustss/hbc.html
18:02:21 <lambdabot> Done.
18:02:37 <dons> augustss: what's the chances of getting the hbc src into darcs?
18:02:58 <LoganCapaldo_> chessguy, I was thinking only if the program failed to type check
18:03:09 <LoganCapaldo_> and around those associated type errors
18:03:59 <chessguy> i dunno, i still suspect you'd run into a lot of partial-application confusion
18:04:06 <sorear> dons: heh. Google "yale haskell" --> FOLDOC #1
18:04:28 <dons> yeah, i'd need lisp for that. too hard
18:04:33 <sorear> no wait #2, blindme
18:04:37 <LoganCapaldo_> chessguy, well that's why its an (imaginary) option :)
18:04:41 <dons> not even sure if the yale src was ever available for free anyway?
18:07:34 <sendark> how do you go away on irssi?
18:07:41 <sendark> is it /away
18:09:17 <dancor> /help /away
18:10:54 <glguy> anyone know where gtk2-theme-switch is in FreeBSDs ports system?
18:11:24 <glguy> nvm, i might have found it
18:11:29 <chessguy> dons, did you see Eric Kidd's Planet Haskell blog on map fusion? looks very interesting
18:11:39 <dons> yeah, very nice
18:12:28 <chessguy> he kind of lost me when he got to the rule-rewriting stuff
18:13:22 <chessguy> err, rewriting-rules, i should say
18:15:37 <chessguy> > mapM (\x->[x+i | i<-[-5..5]]) [1..5]
18:16:01 <chessguy> @bot
18:16:02 <lambdabot> :)
18:16:07 <chessguy> hmm
18:16:17 <chessguy> > mapM (\x->[x+i | i<-[-5..5]]) [1..5]
18:16:23 <jcreigh> > 2 + 2
18:16:24 <lambdabot>  4
18:16:33 <jcreigh> chessguy: you're cursed. :)
18:16:35 <JohnnyL> ok
18:16:39 <chessguy> > 2 + 2
18:16:40 <lambdabot>  4
18:16:43 <chessguy> whew
18:16:49 <allbery_b> bot's still having trouble reporting some failures, I think
18:16:55 <chessguy> the bot doesn't hate me, it just doesn't like that code
18:17:00 <xerox> > Control.Monad.mapM (\x->[x+i | i<-[-5..5]]) [1..5]
18:17:01 <lambdabot>  [[-4,-3,-2,-1,0],[-4,-3,-2,-1,1],[-4,-3,-2,-1,2],[-4,-3,-2,-1,3],[-4,-3,-2,-...
18:17:16 <xerox> (Name clash with Foldable/Traversable.)
18:17:20 <chessguy> ah
18:17:31 <chessguy> > length $ Control.Monad.mapM (\x->[x+i | i<-[-5..5]]) [1..5]
18:17:32 <lambdabot>  161051
18:19:41 <sorear> 10/24
18:19:48 <sorear> > 10 / 24
18:19:50 <lambdabot>  0.4166666666666667
18:20:06 <chessguy> > 10/24
18:20:07 <lambdabot>  0.4166666666666667
18:20:26 <sorear> > 10%24
18:20:27 <lambdabot>  5%12
18:22:56 <sorear> 12/24
18:22:57 <dons> ok. hbc support in the repo now
18:23:01 <sorear> yay!
18:23:01 <dons> this should liven things up
18:23:09 <Cale> dons: Perhaps import the Prelude hiding things like sequence?
18:23:12 <sorear> dons: 50% through nobench ...
18:23:25 <dons> Cale, yeah. needs some tweaks
18:24:31 <chessguy> dons, have a moment to answer a question about the map fusion article?
18:24:41 <dons> maybe :)
18:24:56 <chessguy> (we're talking about http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance for those who haven't seen it)
18:25:28 <dons> ?where hbc
18:25:29 <lambdabot> http://www.cs.chalmers.se/~augustss/hbc.html
18:25:35 <dons> ?where+ hbc http://www.cs.chalmers.se/~augustss/hbc/hbc.html
18:25:35 * sorear poisons his nobench results with elinks startup CPU
18:25:35 <chessguy> why can't he just write a new function treeMap' f g = treeMap (f . g)
18:25:36 <lambdabot> Done.
18:25:51 <dons> chessguy: he could. but then what about fusing folds/ filters/ ... ?
18:26:08 <dons> and he'd then have to manually find all occurences of treeMap f . treeMap g
18:26:14 <dons> even is users of the libraries...
18:26:31 <chessguy> ah, i see
18:26:33 <dons> also, ghc might move two maps together, even if they're not together in the src
18:26:43 <dons> which will now fuse, given a rewrite rule
18:26:48 <chessguy> interesting
18:27:00 <dons> so the rewrite rules tells ghc how to optimise specific uses of the library api
18:27:11 <dons> meaning a simpler api, you don't have to provide treeMap' for example
18:27:14 <chessguy> gotcha
18:27:34 <chessguy> thanks
18:28:45 <Cale> Providing treeMap' is kind of silly anyway, as it only saves about 1 character of typing to use it.
18:28:53 <chessguy> hmm, i bet such optimizations would do a lot for chess engines
18:30:44 <chessguy> by the way, Cale unfoldTreeM worked like a charm in my program-tree generation code
18:31:33 <sorear> 14/24
18:31:54 <chessguy> > "Get a calculator"
18:31:56 <lambdabot>  "Get a calculator"
18:32:50 * ddarius still has to read dons' paper,  but then he has about 60 others in his queue.
18:35:48 * sorear won't read dons' paper until nobench finishes, but will concurrent implement time(1) support.  Emacs, strangely enough, uses far less CPU than X.
18:36:53 <dons> sor	yeah, time support sounds good.
18:37:23 <Cale> > map (chr . fromIntegral) . unfoldr (\x -> guard (x > 0) >> return  (x `mod` 256, x `div` 256)) $ 152110696948989857750358645756541560135
18:37:25 <lambdabot>  "Get a calculator"
18:37:47 <LoganCapaldo_> LOL
18:37:53 <sorear> dons: sor\t eh?
18:38:23 <sorear> funny, time(1) is missing a PORTABILITY section
18:38:33 <dons> sorry. benchmark made things kind of slow on my laptop. :)
18:38:42 <sorear> nice!
18:38:45 <sorear> :)
18:38:48 <mwc_> Is there a clean way to use read and handle bad input?
18:38:53 <dons> so the key is getting proper cpu usage from the bench.hs' fork of the program
18:39:00 <ddarius> mwc_: reads
18:39:01 <dons> mwc, catch/handle/reads ?
18:39:16 <mwc_> I'm trying to use catchJust errorCalls inside an ErrorT String IO monad
18:39:24 <mwc_> and i can't bash the types into line
18:39:29 <ddarius> I would say you have too much free time Cale, but I'm working on writing an article about the Riemann Hypothesis just for the heck of it.
18:39:34 <chessguy> @remember Cale [Cale] > map (chr . fromIntegral) . unfoldr (\x -> guard (x > 0) >> return  (x `mod` 256, x `div` 256)) $ 152110696948989857750358645756541560135 [lambdabot]  "Get a calculator"
18:39:34 <lambdabot> Done.
18:40:36 <chessguy> even when there's discussions of abstract algebra and category theory in #math, he's in here playing with lambdabot. tut tut
18:41:00 <Cale> I'm too sleepy to do actual thinking right now :)
18:42:06 <Cale> I'm only awake because I'm sort of hoping that the weekly Heroes torrent might pop up soon.
18:42:18 * LoganCapaldo_ is watching it right now
18:42:26 <LoganCapaldo_> You too cool for actual tv?
18:42:29 <Cale> Yep
18:43:01 <Cale> Good, if it's on right now, there ought to be someone transcoding it shortly :)
18:44:31 <mwc_> Hmm, isn't ErrorT e m a supposed to be equivalent to m (Either e a)
18:45:10 <sorear> Prelude GHC.Exts GHC.Prim Data.ByteString> copyCStringLen (case 152110696948989857750358645756541560135 of J# x y -> ((Ptr (unsafeCoerce# (unsafeCoerce# y +# 8#))),(I# (x *# 4#))))
18:45:10 <sorear> "Get a calculator"
18:45:10 <sorear> Prelude GHC.Exts GHC.Prim Data.ByteString>
18:45:19 <sorear> no division for me
18:45:36 <Cale> heh
18:46:00 <LoganCapaldo_> Has "Get a calculator" been around for a while? I can see it turning into the new JAPH
18:46:14 <sorear> having just written a GHC GMP binding, I still remembered the magic number 8#
18:46:36 <sorear> 16/24
18:46:54 <chessguy> 0.66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666667
18:47:00 <chessguy> approximately
18:47:11 <jcreigh> man, if only the x86 had as many registers as it does jmp instructions...
18:47:43 <sorear> heh
18:48:02 <kc5tja> jcreigh: x86-64 does.
18:48:34 <jcreigh> kc5tja: oh, how many general purpose regs does the x86-64 have?
18:48:38 <kc5tja> 16
18:48:58 <sorear> EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, CS, DS, SS, ES, FS, GS, EFLAGS, CR0,  -- all 386 registers
18:49:05 <kc5tja> Well, 15, since QSP is still the hardware stack pointer.  But
18:49:19 <jcreigh> sorear: yeah, but you can really only use E[ABCD]X, AFAIK.
18:49:30 <kc5tja> EAX=R0, ECX=R1, EDX=R2, EBX=R3, ESP=R4, EBP=R5, ESI=R6, ESI=R7, then R8..R15 are new.
18:49:37 <SamB> jcreigh: wow
18:49:44 <sorear> CR1, CR2, CR3, DR0, DR1, DR2, DR3, DR6, DR7, TR4, TR5,
18:49:50 <sorear> don't remember the MSRs
18:49:56 <kc5tja> sorear: He's looking for general purpose registers.
18:50:01 <kc5tja> Most of those registers are special purpose.
18:50:03 <ddarius> Incidentally, noone happens to know how to typeset a character over an operator in LaTeX off hand?
18:50:15 <LoganCapaldo_> All registers are general purpose with enough creativity ;)
18:50:25 <SamB> how are "JMP r/m16" and "JMP r/m32" distinguished...
18:50:43 <kc5tja> SamB: $66 or $67 prefix opcode byte, I forget which.
18:50:44 <ddarius> SamB: The assembler knows...
18:51:04 <kc5tja> $66 is the operand size override byte, and $67 is addressing mode operand override byte.
18:51:15 <kc5tja> But they're not used consistently for those purposes.
18:51:26 <SamB> ddarius: they both have $FF for an opcode
18:51:38 <kc5tja> $FF is another prefix byte.
18:51:54 <kc5tja> You do realize that some x86 instructions can be up to 15 (!!) bytes long, yes?
18:52:00 <ddarius> SamB: Okay, I thought you meant at the assembler level, but at the opcode level, it is as kc5tja says.
18:52:01 <SamB> wow
18:52:03 <jcreigh> kc5tja: what? seriously?
18:52:04 <jcreigh> whoa
18:52:06 <kc5tja> Yup.
18:52:23 <LoganCapaldo_> 15 double facorial byte long instructions?
18:52:25 <SamB> you didn't know that x86 was VLIW-capable?
18:52:26 <LoganCapaldo_> Amazing
18:52:35 <kc5tja> Using every override prefix, one segment override prefix, SIB-based addressing modes with 32-bit offsets, you can really rack'em up.  :)
18:52:36 <LoganCapaldo_> I didn't think you could address that much memory :)
18:52:37 <SamB> LoganCapaldo: arggg
18:53:18 <kc5tja> Fortunately, not many instructions require so many bytes.  :)
18:53:24 <sorear> no, instructions cannot be longer than 15 bytes iirc
18:53:27 <kc5tja> Gotta love CISC.
18:53:32 <kc5tja> sorear: Wrong.
18:53:37 <sorear> there are longer instructions, but they are illegal
18:53:41 <kc5tja> sorear: Modern CPUs have prefetch buffers that are 18 bytes long.
18:53:44 <ddarius> Bah, \mathcal is ugly except that it works very well for the Fourier transform.
18:53:45 <mbishop> sorear: I am using your code from earlier, to get epoch seconds, but it outputs IO Integer, which doesn't lend itself well to doing math on it...
18:53:55 <kc5tja> But that's only because the longest possible instruction *is* 15 bytes, so they leave 3 bytes left over for "the next instruction."
18:54:25 * kc5tja detests the x86 architecture.
18:54:32 <kc5tja> 16-, 32-, or 64-bit, doesn't matter.
18:54:40 <kc5tja> The market should have gone PowerPC.
18:54:41 <SamB> what about 8-bit?
18:54:42 <kc5tja> *sighs*
18:54:45 * sorear detests all von neumann architecturs
18:54:55 * zbrown likes sparc :)
18:54:57 <kc5tja> SamB: True, the 6502 thoroughly kicks its ass there too.
18:54:58 <SamB> um, pardon me, but PPC doesn't have 16-bit
18:55:08 <kc5tja> SamB: So?
18:55:13 <kc5tja> Who said it did?
18:55:25 <SamB> and, back then, that market segment was using 68k
18:55:37 <SamB> or earlier...
18:55:45 <SamB> anyway...
18:55:49 <kc5tja> I'd be happier with 68K, but that's still a CISC architecture, and prone to obnoxiously long instructions.
18:56:04 * kc5tja grew up with the Amiga, and even worked for Amiga at one point.  I know all about the 68K.  :)
18:56:09 <SamB> they are all finite-length though
18:56:16 <kc5tja> SamB: Bzzt -- nope.
18:56:21 <SamB> what?
18:56:24 <SamB> which one is not?
18:56:26 <kc5tja> 68K instructions are variable length, but in chunks of 16 bits.
18:56:33 <SamB> I said finite length
18:56:40 <jcreigh> lol
18:56:49 <kc5tja> I took that to mean uniform length (as with RISC).
18:56:51 <SamB> meaning, as far as I know, there are no prefix words
18:56:58 <kc5tja> But Intel's instructions are also all finite-length.
18:56:58 <sorear> 17/24
18:57:18 <LoganCapaldo_> > let fac n 0 = n; fac n x = fac (n * x) (x - 1) in fac 1 (fac 1 15)
18:57:22 <lambdabot> Terminated
18:57:29 <LoganCapaldo_> What, no get a calculator?
18:57:31 * mbishop pokes sorear
18:58:36 <kc5tja> LoganCapaldo_: If I'm not mistaken, wouldn't 15!! = (15!)! ?  Your fac definition doesn't appear to evaluate that.
18:58:51 <LoganCapaldo_> Sure it does
18:59:22 <LoganCapaldo_> > let fac n 0 = n; fac n x = fac (n * x) (x - 1) in let fac15 = fac 1 15 in fac 1 fac15
18:59:26 <lambdabot> Terminated
18:59:43 <glguy> lol, you might start a bit smaller
18:59:44 <sorear> double factorial is NOT factorial . factorial
18:59:44 <sorear>  
18:59:59 <sorear> 15!! = product [1,3..15]
19:00:14 <LoganCapaldo_> [1,3 ??
19:00:19 <glguy> http://mathworld.wolfram.com/DoubleFactorial.html
19:00:20 <lambdabot> Title: Double Factorial -- from Wolfram MathWorld
19:00:21 <sorear> (at least that's what wikipedia said a few months ago)
19:00:36 <sorear> > product [1,3..15]
19:00:38 <lambdabot>  2027025
19:00:41 <LoganCapaldo_> :(
19:00:48 <LoganCapaldo_> That number is far too small
19:00:52 <sorear> > [1,3..15]
19:00:53 <lambdabot>  [1,3,5,7,9,11,13,15]
19:00:58 <glguy> double factorial of an even number is product [2,4..n]
19:01:01 <dancor> hm is an XQueryTree analogue just missing from http://darcs.haskell.org/packages/X11/Graphics/X11/Xlib/Window.hs
19:01:03 <LoganCapaldo_> > product [1..15] -- more fun
19:01:05 <lambdabot>  1307674368000
19:01:34 <sorear> mbishop: don't expect to get non-IO clocktime anywhere, since time returns different values every time you call it
19:01:43 <kc5tja> > let fac n = if n == 0 then 1 else n * fac(n-1) in fac(fac 15)
19:01:47 <lambdabot> Terminated
19:01:48 <sorear> readFile returns IO String, not String
19:02:29 <mbishop> sorear: then how can I do, say, check the difference of two times?
19:02:48 <sorear> > product [1..1307674368000]
19:02:52 <lambdabot> Terminated
19:02:59 <glguy> > 2^2^10 -- is huge on its own, why wouild you think > fac . fac $ 15 would be calculable
19:03:00 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
19:03:02 <sorear> > product [1..2000]
19:03:03 <lambdabot>  3316275092450633241175393380576324038281117208105780394571935437060380779056...
19:03:38 <kc5tja> glguy: Because it's fun to try.
19:03:49 <kc5tja> Although, if it succeeded for any reason, we'd all be in a world of flood.  :)
19:04:08 <LoganCapaldo_> No one thought it be calculable. I just wanted lambdabot to tell me to get a calculator :)
19:04:08 <glguy> hardly... it world time to the same length as my previous line
19:04:22 <glguy> would trim*
19:06:22 <sorear> kc5tja: lambdabot puts a 15s timeout on all commands. within that interval it can send 5 + 15/2 = 12 lines of 490 chars each.  not much flood.
19:06:34 <sorear> @list-all
19:06:35 <lambdabot> activity provides: activity
19:06:35 <lambdabot> babel provides: babel
19:06:35 <lambdabot> base has no visible commands
19:06:35 <lambdabot> bf provides: bf
19:06:35 <lambdabot> check provides: check
19:06:37 <lambdabot> compose provides: . compose
19:06:39 <lambdabot> dice provides: dice
19:06:41 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
19:06:43 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
19:06:45 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools
19:06:47 <lambdabot> elite provides: elite
19:06:49 <lambdabot> eval provides: run let undefine
19:06:51 <lambdabot> Plugin `system' failed with: IRCRaised thread killed
19:06:59 <sorear> see?
19:07:05 <glguy> @
19:07:14 <chessguy> i count 13
19:10:19 <LoganCapaldo_> that page uses an n+k pattern to define !! in terms of gamma
19:10:24 <LoganCapaldo_> booooo
19:10:31 <LoganCapaldo_> down with n+k patterns
19:10:34 <LoganCapaldo_> ;)
19:10:38 <jcreigh> wait, IA-64 is different than x86-64?
19:10:42 <jcreigh> weird.
19:10:43 <chessguy> n+k patterns used to be in vogue
19:13:32 <LoganCapaldo_> IA-64 is/was the Itanic no?
19:13:58 <ddarius> Merced then Itanium
19:14:08 <ddarius> The Itanium has some cool stuff in it.
19:14:12 <ddarius> Not new, but cool.
19:14:26 <ddarius> Also, yay \Gamma functions!
19:14:55 <LoganCapaldo_> What's Intel's version of x86-64 called?
19:15:00 <kc5tja> jcreigh: Yup.  IA-64 is Itanium (sometimes called Itanic for humorous reasons) architecture.
19:15:02 <LoganCapaldo_> 64x?
19:15:02 <sorear> EM64T
19:15:06 <LoganCapaldo_> right
19:15:08 <LoganCapaldo_> that's it
19:15:22 <kc5tja> EM64T is Intel's tradename for x86-64.
19:16:55 <allbery_b> "amd64"
19:17:02 * allbery_b gets struck by lightning
19:17:25 * sorear doesn't get it
19:17:35 <sorear> 21/24
19:17:59 <kc5tja> 1+2
19:18:02 * ddarius just now realizes why sorear keeps spouting fractions.
19:18:05 <gvdm_other> > 21/24
19:18:06 <lambdabot>  0.875
19:18:56 <allbery_b> CMU ECE is kinda beholden to Intel
19:18:56 <kc5tja> > let a (+) b = if a == 1 && b == 1 then 3 else a+b in 1+1
19:18:57 <lambdabot>      Occurs check: cannot construct the infinite type:
19:18:57 <lambdabot>       t = (t -> a -> t...
19:19:14 <beelsebob_> why is he?
19:19:27 <kc5tja> Bummer -- it didn't like that statement for some reason.
19:19:30 <kc5tja> Oh well.
19:19:36 <kc5tja> Ahh, that would do it.
19:19:57 <ddarius> let a + b = ...
19:20:03 <gvdm_other> > map (/24) [1..24]
19:20:05 <lambdabot>  [4.1666666666666664e-2,8.333333333333333e-2,0.125,0.16666666666666666,0.2083...
19:20:05 <LoganCapaldo_> > let a + b = if a == 1 && b == 1 then 3 else Prelude.(+) a b in 1+1
19:20:06 <lambdabot>   Not in scope: data constructor `Prelude'
19:20:10 <ddarius> beelsebob_: Number of nobench tests completed.
19:20:17 <beelsebob_> heh
19:20:35 <beelsebob_> sorear: if you want benchmarking doom, poke me will you
19:21:11 <kc5tja> > let ($+$)=(+) in let a (+) b = if a == 1 && b == 1 then 3 else a ($+$) b in 1+1
19:21:12 <lambdabot>  2
19:21:17 <kc5tja> Hah...
19:21:34 <kc5tja> See?  There's no convincing it that 1+1=3.  Next, it'll tell you that the world is round too.
19:21:59 <LoganCapaldo_> It's only because Haskell doesn't make you follow up your lets with recs
19:22:16 <kc5tja> I'm not trying to be recursive though.
19:22:19 <ddarius> > let ($+$) = (+); a+b | a == 1 && b == 1 = 3 | otherwise = a $+$ b in 1+1
19:22:20 <lambdabot>  3
19:22:21 <sorear> > let 1 + 1 = 3 in 1 + 1
19:22:23 <lambdabot>  3
19:22:23 <LoganCapaldo_> exactly
19:23:10 <sorear> > let a + b | a == 1 && b == 1 = 3 | True = a Prelude.+ b in 1 + 1  -- ddarius, you're making it too hard
19:23:12 <lambdabot>  3
19:23:46 <beelsebob_> > let a + b = error "Out of cheese error, redo from start" in 1+1
19:23:47 <ddarius> sorear: I'm trying to match kc5tja's example more closely.
19:23:48 <lambdabot>  Exception: Out of cheese error, redo from start
19:23:51 <LoganCapaldo_> So I guess i should have said (Prelude.+) a b and not Prelude.(+)
19:23:54 <beelsebob_> :)
19:24:17 <kc5tja> sorear: For a 1-liner, I find ddarius' solution easier to read.  Yours would be easier on multiple lines though.
19:24:35 <ddarius> > 1 `Prelude.elem` []
19:24:36 <lambdabot>  False
19:24:45 <kc5tja> Heheh -- out of cheese error.  Awesome.
19:25:35 <beelsebob_> `He [the Archchancellor] called me in and asked me what I did, exactly. Have you ever heard of such a thing? What sort of question is that? This is a university!'
19:26:07 <ddarius> @hoogle (a -> b) -> a -> (b,b)
19:26:07 <lambdabot> No matches, try a more general search
19:26:19 <kc5tja> Hmmm....the out of cheese exception is defined in the Wallace.lhs module, right?  ;)
19:26:32 <beelsebob_> really?
19:26:49 <beelsebob_> surely in the Pratchet.lhs module
19:26:58 <beelsebob_> along with divide by cucumber
19:27:43 <kc5tja> Perhaps there too, I dunno -- I never read Pratchet.  I only know that many of Wallace and Grommit's travails revolve around cheese or its lack thereof in some capacity.
19:28:15 <beelsebob_> ah, I see
19:28:32 <beelsebob_> see the out of cheese error comes from the computer build from an ants nest and some honey by the librarian
19:28:45 <beelsebob_> (who is an orangutan, hence the language Ook!)
19:29:09 <beelsebob_> the ants need feeding
19:29:13 <beelsebob_> (obviously with cheese)
19:29:43 <beelsebob_> "And therefore education at the University mostly worked by the age-old method of putting a lot of young people in the vicinity of a lot of books and hoping that something would pass from one to the other, while the actual young people put themselves in the vicinity of inns and taverns for exactly the same reason." [Pratchet]
19:30:32 <kc5tja> Is this in the Discworld series by any chance?  I vaguely remember a wizard recognizing a passing ant that he once knew, and the ant wanted nothing to do with him any more (or that walking chest).  God, maybe I did read some -- but it was YEARS ago.
19:30:56 <beelsebob_> that sounds about right
19:31:00 <SamB> beelsebob_: sounds oddly familiar...
19:31:29 <beelsebob_> I think it's from the science of the disk world
19:31:55 <jcreigh> @hoogle [Maybe a] -> [a]
19:31:56 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
19:32:06 <jcreigh> ha! Does it do what I think it does?
19:32:13 <jcreigh> > catMaybes [Just 2, Nothing, Just 42]
19:32:15 <lambdabot>  [2,42]
19:32:18 <jcreigh> nice
19:32:44 <sorear> dons: poke, http://members.cox.net/stefanor/bench.results
19:33:29 <kc5tja> > z <- [2, 42]; putStrLn (if z == 42 then "Nice -- now what is the question?" else "hrmph.")
19:33:29 <lambdabot>  Parse error
19:33:34 <kc5tja> doh
19:33:38 <kc5tja> I borked something.
19:33:46 <sorear> s/>/> do/
19:33:50 <Cale> @palomer
19:33:51 <lambdabot> Hrmph, looks like I killed the channel
19:33:53 <kc5tja> doggone it.
19:34:01 <Cale> @palomer
19:34:02 <lambdabot> I think vim is good for the rubbish bin
19:34:09 <kc5tja> > do z <- [2, 42]; putStrLn (if z == 42 then "Nice -- now what is the question?" else "hrmph.")
19:34:10 <lambdabot>  Couldn't match expected type `[]' against inferred type `IO'
19:34:11 <siti> ^^
19:34:15 <Cale> @keal
19:34:16 <lambdabot> it is very easy to go off topic
19:34:44 <kc5tja> > do z <- [2, 42]; putStrLn (if z == 42 then "Nice -- now what is the question?" else "hrmph."); return []
19:34:44 <lambdabot>  Couldn't match expected type `[]' against inferred type `IO'
19:34:50 <kc5tja> shucks.
19:34:55 <kc5tja> Worth a shot.  needs a transformer.
19:34:56 <Cale> > sequence $ do z <- [2, 42]; return (putStrLn (if z == 42 then "Nice -- now what is the question?" else "hrmph."))
19:35:09 <jcreigh> Why do in(famous) in-channel trolls get their own lambdabot command? Hardly seems fair. :)
19:35:27 <sorear> not just trolls
19:35:32 <SamB> jcreigh: so we can poke fun at them
19:35:33 <sorear> KEAL is real
19:35:44 <jcreigh> sorear: "real"?
19:35:50 <jcreigh> sorear: as in, composed of matter? :)
19:35:53 <SamB> sorear: most trolls are
19:35:56 <beelsebob_> kc5tja: doesn't need a transformer, needs it to be nicer and more pure
19:36:03 <Cale> It sort of seems bad to poke fun at him, I really think he is schizophrenic.
19:36:04 <SamB> there is the occassional autotroll
19:36:14 <SamB> but those don't have enough quotable material, generally, anyway
19:36:35 <sorear> @v -- wasn't even human
19:36:36 <lambdabot> Exception: <<loop>>
19:36:42 <Cale> @v
19:36:43 <lambdabot> "\""
19:36:45 <Cale> @v
19:36:45 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
19:36:48 <Cale> @ghc
19:36:49 <lambdabot> ghc says: Occurs check: cannot construct the infinite type
19:36:52 <Cale> @ghc
19:36:53 <lambdabot> ghc says: In a case expression, type of scrutinee does not match patterns
19:36:57 <beelsebob_> > putStrLn $ unlines $ map (\z -> if z == 42 then "Nice -- now what is the question?" else "hrmph.") [2,42]
19:36:59 <lambdabot>  <IO ()>
19:37:03 <sorear> @list quote
19:37:03 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
19:37:23 <Cale> @yhjulwwiefzojcbxybbruweejw
19:37:24 <lambdabot> "\"#$%&'()*+,\""
19:37:40 <Cale> @protontorpedo
19:37:41 <lambdabot> can haskell do data transfer from box to box over sockets?
19:37:50 <pbx> I'm installing GHC 6.6 via FreeBSD ports... it's not still broken is it ?
19:37:52 <Cale> @protontorpedo
19:37:53 <lambdabot> how fast is the haskell web serve for dynamic content? siriam from scheme says the scheme one si FAT AS HEK
19:37:58 <emk> Does anyone know a good paper on commutative monads?
19:38:44 <pbx> Heheh, he said commutative monads
19:38:50 <kc5tja> OK, I can see that I'll be compiling Firefox pretty much all night long.  :)
19:39:07 <dons> the sad thing about gschuett/gavino/proton* is that he has been doing that kind of script for several years now
19:39:09 <Cale> kc5tja: why are you compiling it?
19:39:12 <jcreigh> kc5tja: yeah, Firefox does seem to take a while to build, which is why I try to avoid it.
19:39:16 <dons> and even pops up on the happs mailing list with the troll script
19:39:21 <beelsebob_> @. elite vixen is cale hot
19:39:22 <lambdabot> <UNd3phinED>
19:39:37 <sorear> dons: done - http://members.cox.net/stefanor/bench.results
19:39:38 <dons> its possible he's a bot  guess. since the script doesn't vary much
19:39:40 <Cale> Compiling things for which there are binaries is for suckers.
19:39:57 <kc5tja> Cale: Trying to fix a bug in nsLocalFileUnix -- it calls realpath(), but that function is deprecated and, well, causes Firefox to bork hard when invoking helper applications that are referenced via symlinks and proper helper operation depends on it.
19:39:58 <dons> sorear: looking. thanks.
19:40:16 <Cale> ah, okay, legitimate reasons then :)
19:40:38 <sorear> dons: hehe.  I added one line of code to use time(1), deleted ~20 lines of haskell.  type correct now testing.
19:41:01 <kc5tja> Plus, the bug in question has been open and no patches submitted against it since 2002.  It's about time this bug is revisited.  >:)
19:42:44 <jcreigh> kc5tja: Thanks for your efforts. There are too many bugs in Mozilla that have been open for multiple election cycles.
19:42:59 <kc5tja> Well, I'm not a mozilla developer.
19:43:12 <kc5tja> I'm just a really pissed-off-at-firefox-for-causing-zombie-processes user.  :)
19:43:24 <jcreigh> kc5tja: doesn't matter. You're hacking on it. I assume you're going to submit your patch, yes?
19:43:31 <kc5tja> Oh, definitely.
19:43:36 <jcreigh> there you go.
19:43:37 <kc5tja> I don't know who to submit the patch TO though.
19:43:44 <SamB> submit it to the bug
19:43:53 <SamB> you can attach files to bugzilla bugs
19:43:54 <sorear> what, darcs send doesn't Just Work?
19:43:56 <sorear> :p
19:44:14 <SamB> sorear: since when is darcs send integrated with bugzilla?
19:44:21 <kc5tja> Hopefully they'll *see* it though.
19:44:30 <SamB> nevermind that they aren't using darcs for mozilla (which is a good thing!)
19:44:35 <jcreigh> I just hate seeing the exact bug I'm running into with a "Bug opened: 1972" date next to it. :) (Okay, not really, but I have run into some bug in Firefox that had been open for a couple years...seems stupid to have bugs open that long.)
19:44:41 <SamB> because mozilla is too big for darcs to work reasonably
19:44:46 <kc5tja> Darcs would probably work for Mozilla just fine.
19:45:05 <jcreigh> so I just think it's cool that somebody is working on pushing back the tide.
19:45:06 <kc5tja> It manages my website of 167MB just fine; the source tree for Mozilla is only 343MB -- just a hair over twice that size.
19:45:19 <SamB> hmm.
19:45:21 <sorear> jcreigh: Nobody (i.e. me) uses software 3d.  I have a 2001 *crash bug* which regularly encounters me.
19:45:23 <dons> the atom (numerical classical atom simulator) is really interesting
19:45:23 <SamB> I thought it was bigger...
19:45:34 <sorear> (in X.org)
19:45:37 <kc5tja> I think what darcs chokes on are big patches.
19:45:44 <SamB> but, mozilla gets probably a lot more revisions?
19:45:45 <kc5tja> If the patches are kept small, it is quite zippy.
19:46:04 <allbery_b> mozilla gets some pretty big patches though
19:46:12 <sorear> dons: now running a GHC-only test ...
19:46:14 <dons> @tell ndm yhc now fails on build with an error about System.Environment
19:46:15 <lambdabot> Consider it noted.
19:46:22 <kc5tja> You pretty much have to when you (still) use CVS.  :)
19:46:47 <sorear> even X.org uses a non-CVS system now.
19:46:50 <SamB> no svn yet?
19:47:00 <SamB> sorear: X.org used to use version control?
19:47:13 <allbery_b> I gather most converson utilities curl up and die when faced with mozilla :)
19:47:20 <araujo> hello here!
19:47:21 <sorear> SamB: they used to use CVS.
19:47:33 * SamB thought they just released tarballs back before they actually maintained a usable X distribution
19:47:37 <Nafai>  X.org uses git, IIRC
19:47:46 <sorear> now it does, IIRC
19:47:49 <SamB> yes it does
19:47:52 <sorear> before git was CVS
19:48:01 <sorear> before CVS was I-dont-know-what
19:48:12 <SamB> tar.Zs?
19:48:13 <kc5tja> git looks cool, I have to admit.  Might be better for repos that get MASSIVE quantities of submissions.
19:48:17 <kc5tja> But darcs is still my favorite.  :)
19:48:27 <sorear> but there was a CVS phase, as witnessed by the ConversionFromCVS pages on wiki.x.org
19:48:35 <SamB> yeah
19:49:07 <SamB> they were presumably in that phase when they forked XFree86
19:49:27 <SamB> or should I say pwn3d
19:49:31 <pbx> Golly this Haskell takes a while to compile doesn't it
19:49:44 <kc5tja> pbx: Took 6 hours on my box when I did 6.4.1
19:49:51 <pbx> kc5tja: Wow!
19:49:55 <kc5tja> (never upgraded since)
19:50:07 <kc5tja> My box is an 800MHz Athlon Slot-A box.
19:50:12 <kc5tja> So it's pretty old.
19:50:26 <sorear> kc5tja: Took 90 minutes when I did 6.7.20070213
19:50:31 <sorear> with extralibs
19:50:36 <allbery_b> ghc 6.7 takes about 6 hours on my machine... from source, full stage1+stage2+libs+profiled libs
19:50:39 <kc5tja> sorear: Based on those figures, you have a 3200MHz machine, right?
19:50:44 <allbery_b> G4 mac mini
19:51:09 <sorear> kc5tja: 2000 actually.  with an ungodly fast hard drive. 100MB/s, only 40x slower than RAM.
19:51:19 <sorear> (assuming you don't seek)
19:51:36 <kc5tja> SATA drives?
19:51:57 <kc5tja> I've got 166MBps EIDE cables on mine, but the drives themselves aren't that fast.  :)
19:52:15 <kc5tja> I think they might be 100MBps, but that speed is nullified by the slow FSB.
19:52:16 <sorear> dd if=/dev/zero of=/dev/hda makes anything look fast :)
19:52:20 <pbx> I'm on a VPS that usually rips through things pretty fast, so I'm curious. Not curious enough to stay up and wait for it though. That's what GNU screen is for :)
19:52:39 <sorear> no computation, no seeking
19:52:47 <sorear> track staggering ftw
19:53:56 <sorear> dons: meteor fails here, can't find foldl' - List?
19:54:06 <dons> Data.List eh
19:54:11 * dons patches
19:54:28 <dons> over-eager h98 hacking ;)
19:55:12 <pbx> I'm curious -- what are all the lines in the build like this?  <<ghc: 220478812 bytes, 101 GCs, 4943272/14522424 avg/max bytes residency (8 samples), 31M in use, 0.00 INIT (0.00 elapsed), 1.36 MUT (3.52 elapsed), 0.55 GC (0.67 elapsed) :ghc>>
19:55:25 <sorear> pbx: GC stats
19:55:31 <sorear> -sstderr
19:55:32 <abz> ?seen Cheery
19:55:33 <lambdabot> I saw Cheery leaving #haskell 6h 8m 15s ago, and .
19:55:44 <dons> pushed.
19:55:49 <sorear> dons: sent patch: 'use time(1) rather than System.Time - makes backgrounding safe'
19:55:58 <dons> great!
19:56:11 <dons> want to attempt jhc support?
19:56:20 <dons> i've added a lot more h98 stuff now
19:57:05 <sorear> dons: sure.  maybe JohnMeacham will notice the problem :)
19:57:16 <sorear> dons: how much RAM do you have?
19:57:33 <sorear> (with 384M I need special RTS flags to make jhc run at all)
19:57:43 <sorear> +RTS -sstderr -H340M -c -F1.1 -RTS
19:57:56 <sorear> I guess the -sstderr isn't necessary :)
19:58:09 <sorear> but -c -F1.1 makes a huge difference
19:58:39 <sorear> 4h-before-I-gave-up --> 30mins to compile all of base, 18 *s* to compile the testsuite (hello world)
19:59:01 <kc5tja> jhc -- is that the Haskell to C compiler?
19:59:14 <sorear> jhc w/ libs compiles in 40minutes (remember to spec -fasm), GHC w/ libs takes 90m :)
19:59:24 <sorear> kc5tja: yes, but ...
19:59:36 <sorear> kc5tja: ghc, nhc96, jhc : all Haskell->C
19:59:50 <kc5tja> o_O?  I thought ghc compiled to object files directly.
19:59:58 <sorear> kc5tja: jhc is whole program mega optimizing, first order, pointsto analyser, all that fun stuff.
20:00:26 <emk> I'm trying to find out if any interesting monad laws apply to commutative monads.
20:00:27 <sorear> kc5tja: GHC generates C--, then either prettyprints C (-fvia-C) or compiles it using a builtin C-- compiler (-fasm)
20:01:01 <kc5tja> Is it GNU-specific C, or portable ANSI C?
20:01:07 <sorear> worse
20:01:14 <sorear> GNU specific + arch deps
20:01:35 <sorear> ghc -fvia-C -unreg gives you "ANSI" C, but still wordsize specific.
20:01:40 <kc5tja> Is it possible to bolt on another C-- backend?
20:01:46 <kc5tja> Oh, that's fine.
20:01:48 <sorear> jhc generates wordsize independent ANSI C
20:02:19 <kc5tja> I was just wondering because I'd like to run some code through a C compiler for the 65816 processor, to see how it runs on that platform.  Just an experiment -- nothing production.
20:02:20 <sorear> the reg in -unreg stands for global register variables - very archdep
20:02:58 <zbrown> i see
20:03:01 <zbrown> oops.
20:03:01 <sorear> I *believe* ghc has an emit-c-- option, but its not exactly formal C--.  pretty close, but...
20:03:46 <kc5tja> If it is specified well enough to make an independent backend for it, then that'll do.
20:04:03 <kc5tja> brb -- laundry, and food.
20:04:14 <sorear> @where commentary
20:04:15 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary
20:04:21 <sorear> ^^^ your reference
20:04:57 <kc5tja> kc5tja: ^^ marker for when I get back
20:05:05 <kc5tja> Dammit, it didn't highlight my name.
20:05:08 <kc5tja>  
20:05:08 <kc5tja>  
20:05:08 <kc5tja>  
20:05:11 <kc5tja> There we go.  :)
20:06:12 <sorear> I see a bunct of bright red spaces :)
20:06:31 <sorear> Emacs warn-trailing-whitespace mode interracts funnily with erc.
20:06:35 <nrb23> I se a bunch of blank lines
20:08:26 <ddarius> emk: Basically,you have the monad laws plus a law asserting the two implementations of liftM2 are equivalent.
20:09:11 <emk> ddarius: Hmm. I need to think about that for a second...
20:09:29 <sorear> bah. somehow I had the impression commutativity referred to m1 (m2 a) vs m2 (m1 a)
20:10:02 <sorear> commutative applicative functors FTW!
20:10:04 <emk> ddarius: Basically, if I swap the first two binding forms, I should get the same result?
20:10:48 <emk> do { x <- a; y <- b; return (x,y) } <=> do { y <- b; x <-a; return (x,y) }
20:10:50 <sorear> liftM2 f a b = liftM2 (flip f) b a
20:11:12 <ddarius> emk: Yes, or more categorically, uncurry (liftM2 (,)) . swap = fmap swap . uncurry (liftM2 (,))
20:11:26 <sorear> @pl do { x <- a; y <- b; return (x,y) } === do { y <- b; x <-a; return (x,y) }
20:11:27 <lambdabot> (line 1, column 4):
20:11:27 <lambdabot> unexpected "{"
20:11:27 <lambdabot> expecting variable, "(", operator or end of input
20:11:31 <sorear> @. pl undo do { x <- a; y <- b; return (x,y) } === do { y <- b; x <-a; return (x,y) }
20:11:32 <lambdabot> (b >>=) . flip flip (const (join (,) `fmap` a)) . ((>>=) .) . flip flip b . (((===) . return) .) . (,) =<< a
20:11:40 <sorear> bah
20:11:56 <emk> ddarius: Thanks! That's what I was looking for.
20:15:27 <dons> sorear: only -l and -p are portable for /usr/bin/time
20:15:33 <dons> not -o %s
20:15:40 <dons> (is that the output file?)
20:15:54 <sorear> yes :(
20:15:59 <dons> > resuse
20:16:00 <lambdabot>   Not in scope: `resuse'
20:16:09 <sorear> res use
20:16:16 <sorear> resource_usage
20:16:24 <dons> sorry, i meant 'pipe' into resuse
20:16:28 <dons> rather than -o
20:16:34 <dons> time foo > resuse , yeah?
20:16:45 <allbery_b> depends on the shell
20:16:52 <sorear> resuse is a variable, containing eg "ghc.time"
20:17:04 <dons> allbery_b: not if we're using /usr/bin/time
20:17:06 <allbery_b> some put the timing putput on fd 2; some put it on ther *shell's* stdout, which can't be redirected that way
20:17:09 <allbery_b> ah
20:17:37 <allbery_b> might stil lverify /usr/bin/time doesn't output timing foo on stderr
20:17:43 <sorear> dons: where does POSIX time send its output?
20:17:52 <sorear> allbery_b: it does, according to the manpage
20:18:20 <sorear> allbery_b: but my manpage describes GNU time and appears unique in lacking a PORTABILITY section
20:18:39 <dons>      time executes and times utility.  After the utility finishes, time writes
20:18:39 <dons>      the total time elapsed, the time consumed by system overhead, and the
20:18:39 <dons>      time used to execute utility to the standard error stream.
20:18:44 <allbery_b> on OSX /usr/bin/time is documented as outputting to stderr
20:18:45 <dons> stderr
20:19:12 <sorear> -o has the advantage we don't need to separate output types ...
20:19:23 <dons> right. but its no good, since i can't run it.
20:19:25 <sorear> there goes my LOC advantage over the manual method.
20:19:46 <sorear> I suppose BSD time has a half-dozen other extremely useful flags?
20:19:48 <sorear> :(
20:19:53 <sorear> that I can't use.
20:20:03 <dons> nope, just -l and -p
20:20:10 <dons> bsd is not gnu ;)
20:20:16 <allbery_b> generallly shells have builtin time commands with lots of useful foo, and I think /usr/bin/time is POSIX
20:20:27 <sorear> I don't have a -l :)
20:20:32 <allbery_b> although on a linux system who knows what /usr/bin/time is
20:20:44 <sorear> I do!
20:20:48 <dons>      -l      The contents of the rusage structure are printed.
20:20:49 <dons>      -p      The output is formatted as specified by IEEE Std 1003.2-1992
20:22:08 <sorear> while on MY system, /usr/bin/time has a half-gazillion features and the builtin time does next to nothing.
20:26:10 * sorear decides to implement time measurement in bin/timeout
20:26:47 <sorear> System.Posix.Process ...
20:27:11 <allbery_b> next you get to deal with the systems that don't do useful things with most of (struct rusage)
20:27:18 * allbery_b is looking at *you*, Linux...
20:30:12 <sorear> bah, this is a lot harder than /usr/bin/time made it look
20:30:58 <sorear> dons: I can't just use /usr/bin/time -p because I can't mess with stderr because it is being captured by compiler specific code in footer.mk
20:31:47 <allbery_b> you can at the price of a subshell
20:32:20 <dons> sorear: this is why I used bench.hs to time
20:32:51 <dons> might be easier to use our own rusage binding (or System.Posix.* ) ?
20:33:00 <allbery_b> mress:15043 Z$ (echo bar; echo foo >&2) 2>&1 >xx
20:33:01 <allbery_b> foo
20:33:10 <allbery_b> mress:15044 Z$ cat xx
20:33:10 <allbery_b> bar
20:33:44 * sorear contemplates rewriting the whole makefile web in haskell
20:33:45 <allbery_b> hm, well, except you can't catch just time's stderr.
20:34:08 <dons> sorear: well. you could move pieces at a time into bech.hs
20:34:11 <dons> such as the rules
20:34:22 <sorear> "rules" ?
20:34:36 <dons> the build targets for each compiler
20:34:45 <dons> i.e make calls bench, bench calls make ghc/make yhc and so on
20:34:48 <dons> there's no need for that though
20:34:54 <sorear> ?
20:34:55 <dons> bench could just run system $ yhc ...
20:34:58 <dons> itself
20:35:09 <sorear> ah right.
20:35:40 <dons> i'll unrecord your time patch for now
20:35:48 <sorear> dons: rollback!
20:36:02 <ddarius> "Why did God create time? So everything wouldn't happen all at once."  What's so bad about everything happening all at once?
20:36:17 <dons> ok.
20:36:58 <sorear> unrecord interacts badly with send etc, since you can't send/pull the lack of a patch
20:37:08 <dons> done.
20:37:22 <sorear> woah, the UNDO: came authored by "Stefan O'Rear"
20:37:32 <dons> interesting
20:37:36 <SamB> ddarius: well, actually happening is impossible with no time
20:37:50 <SamB> as far as I can see
20:38:11 <allbery_b> time is more or less defined in terms of things happening
20:38:12 <sorear> dons: how much is different between all the makefiles? and how much do we want to be differentable?
20:39:05 <dons> hmm. ok. what are you planning on doing?
20:39:17 <sorear> rewriting them in bench.hs ?
20:39:27 <dons> hmm.
20:39:47 <dons> why?
20:39:48 <sorear> stefan@stefans:/usr/local/src/nobench$ for x in */*/Makefile ; do echo $x ; cat $x ; done | less
20:40:01 <dons> i need more thought about this. and a plan for how to do it. before i'll be ok with this.
20:40:41 <sorear> ...
20:40:47 <dons> since we'd be reimplementing make ...
20:40:47 <dons> i'm much more inclined to just fix
20:40:51 <dons> the timing issue. as nofib does
20:41:02 <dons> rather than try to reimplement all the variable handling
20:41:58 <sorear> ah, nofib has a solution to the timing problem?  what is the difference between nofib and nobench then, if they both do timing?
20:41:58 <dons> just getting the -run targets moved into bench.hs is going to require environment munging to get info from the Makefiles and header.mk
20:42:14 <dons> nofib is tied to the ghc build system
20:42:18 <dons> so doesn't support the other compilers
20:42:44 <sorear> there is a yhc nofib, I imagine it's tied to yhc...
20:43:12 <dons> the nofib time works by:  time runtests
20:43:18 <dons> where runtests is roughly bench.hs
20:43:44 <sorear> hm.
20:43:54 <sorear> we want it broken down by test/compiler
20:45:29 <dons> i'd just how about we just replace start <- getClockTime with a time call that measures child process elapsed time too
20:45:46 <dons> i.e. a custom getCPUTime
20:45:51 <sorear> (no intention to change this but)  what advantage does make have over, say, sh?
20:46:05 <dons> build targets
20:46:24 <dons> but yeah, you could write this stuff a few different ways
20:46:26 <sorear> since we demand repeatability, dependency analysis is no use to use
20:46:33 <dons> as long as it stays pretty simple, it should stay in make
20:46:45 <dons> if it gets any more commmmplex, a dsl might be better.
20:48:34 <kc5tja> back
20:50:45 <bo_> hi guys
20:50:56 <bo_> I have a question
20:51:05 <bo_> on builtin data types
20:51:12 <bo_> such as Integer
20:51:49 <bo_> what's the native machine/c type it's using under the hood?
20:52:00 <bd_> Integer isn't a native type. It's unlimited precision.
20:52:05 <dons> Integer uses libgmp byte arrays
20:52:18 <bo_> ah. my mistake
20:52:24 <bd_> Int, on the other hand, can be anything that can hold at least -2^29 to 2^29-1
20:52:40 <bo_> still a newbie. thanks
20:52:50 <bo_> emm sorta like ocaml?
20:52:51 <bd_> If you need a specific width, Data.Int and Data.Word provide eg Word64 (uint64_t) or Int32 (int32_t)
20:53:00 <bd_> I don't know what ocaml does, sorry :)
20:53:05 <bd_> note that Int may have a wider range
20:53:13 <bd_> you can get the specific range with minBound and maxBound
20:53:19 <bd_> > (minBound, maxBound) :: (Int, Int)
20:53:21 <lambdabot>  (-2147483648,2147483647)
20:53:25 <bd_> the precise values may vary from machine to machine
20:53:45 <bo_> 2^29
20:53:52 <bd_> > 2 ** 29
20:53:53 <lambdabot>  5.36870912e8
20:53:58 <bd_> er
20:53:58 <sorear> > 2^29
20:53:59 <bd_> > 2 ^ 29
20:54:00 <lambdabot>  536870912
20:54:01 <lambdabot>  536870912
20:54:09 <bo_> emm?
20:54:24 <bd_> right, in GHC on x86, Int is a bit wider than 2^29, but this isn't required by the standard :)
20:54:43 <bo_> oh I see
20:54:57 <SamB> > maxBound :: Int
20:54:58 <lambdabot>  2147483647
20:55:05 <SamB> > minBound :: Int
20:55:06 <bd_> > maxBound :: Int512
20:55:07 <lambdabot>   Not in scope: type constructor or class `Int512'
20:55:07 <lambdabot>  -2147483648
20:55:10 <bd_> > maxBound :: Int256
20:55:11 <lambdabot>   Not in scope: type constructor or class `Int256'
20:55:13 <bd_> hmm
20:55:21 <SamB> > minBound :: Int128
20:55:22 <lambdabot>   Not in scope: type constructor or class `Int128'
20:55:24 <bd_> oh, that was in the crypto package, wasn't it?
20:55:24 <SamB> > minBound :: Int64
20:55:26 <lambdabot>  -9223372036854775808
20:55:26 <dons> Word128
20:55:27 <SamB> heh
20:55:34 <bd_> builtins only do 8, 16, 32, 64
20:55:39 <bo_> is Data.Int or Data.Word efficient?
20:55:39 <dons> > maxBound :: Word1024
20:55:43 <lambdabot>  ghc: failed with error code 9
20:55:47 <dons> yeah, they're just the raw machines
20:55:51 <bd_> bo_: Data.Int and Data.Word will use machine ints where possible
20:56:00 <bd_> so eg in an x86 platform Int64 will have to be emulated
20:56:02 <SamB> my machine doesn't have raw 64-bit ints
20:56:09 <bd_> but on x86_64, Int64 will be nice and speedy :)
20:56:14 <dons> its emulated by libgmp though
20:56:17 <dons> so that's ok :-)
20:56:18 <SamB> heh
20:56:22 <bo_> cool
20:56:26 <bd_> dons: Int64 is? Wouldn't it be faster to inline?
20:56:28 <SamB> dons: I think I like GCC's emulation better
20:56:40 <bo_> float and double are same?
20:56:50 <sorear> dons: slight problem.  I can get the cumulative user time as a CClock, but there appears to be no way to find the clock_t/seconds ratio.
20:56:58 <sorear> no binding for _sysconf.
20:57:00 <bd_> I noticed that some Int64-using code I was running earlier was going... quite slow on a 32-bit machine :/
20:57:31 <sorear> bd_: no. Float is slower and less accurate.
20:57:37 <bd_> sorear: bo_ you mean? :)
20:57:39 <sorear> er, bo_:
20:57:49 <bo_> I mean
20:58:12 <bo_> is Float same to float in c/c++
20:58:16 <bd_> bo_, if you're working with Float or Double, you may want to put {-# OPTIONS_GHC -fexcess-precision #-} at the top of the file for a measurable speed gain :)
20:58:34 <bo_> what does it do?
20:58:35 <bd_> bo_ the only types guarenteed to equate to C types are the types in the Foreign.C module
20:58:53 <SamB> sorear: I doubt Float is slower than GMP...
20:58:53 <sorear> bo_: yes.  but don't use it without a very good reason.
20:58:56 <bo_> oh gotcha
20:59:05 <bd_> normally GHC will truncate certain intermediate results in order to stick to the letter of the standard regarding how much precision is to be kept
20:59:13 <bo_> is ther any doc on this stuff?
20:59:13 <SamB> also, I bet Double is faster
20:59:16 <bd_> using that flag will skip this truncation
20:59:19 <allbery_b> sorear:
20:59:23 <allbery_b> @hoogle getSysVar
20:59:24 <lambdabot> No matches found
20:59:25 <bd_> bo_, the haskell report, and the ghc user guide? :)
20:59:26 <allbery_b> hrm
20:59:37 <bd_> oh, and the FFI documentation for the C-equivalent stuff
20:59:39 <allbery_b> System.Posix.Unistd
20:59:46 <bd_> ?where report
20:59:46 <lambdabot> http://www.haskell.org/onlinereport/
20:59:47 <allbery_b> since hoogle is being annoying
20:59:53 <bd_> ?where ffi
20:59:54 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:00:06 <bo_> thanks guys
21:00:07 <bd_> and finally http://haskell.org/ghc/docs/latest/html/index.html :)
21:00:08 <lambdabot> Title: GHC Documentation
21:00:17 <allbery_b> specifcally, getSysVar ClockTick
21:01:23 <bo_> I'm thinking doing some numerical calulation in haskell hence those questions
21:02:36 <bo_> nothing too fancy. I won't do mathematical optimiztions in haskell
21:04:08 <chessguy> suppose you had written a Stack monad, with just two operations, push and pop. now you somehow want to do something with a whole bunch of stacks. how would you do that?
21:04:23 <Pseudonym> What does a Stack monad do?
21:04:33 <bd_> Sounds like the wrong monad for the job...
21:04:37 <chessguy> just maintains the state
21:05:03 <bd_> one option would be to use ST, and STRef s [StackElement]s for stacks, if you need them mutable.
21:05:09 <Pseudonym> You mean a state monad, then.
21:05:18 * allbery_b wonder why not Data.Sequence.Seq
21:05:19 <Pseudonym> ST, State, StateT etc.
21:05:45 <bd_> once you start messing with the state like that, you're broken the abstraction of the monad, and it's getting in the way more than helping. So get rid of it and use a different one :)
21:06:29 <chessguy> so as soon as you need multiple instances of something, you can't just implement the 'something' with a monad?
21:06:30 <Pseudonym> Sorry, "broken the abstraction of the monad"?
21:06:34 <Pseudonym> What does that mean?
21:06:37 <sorear> allbery_b: Seq is probably much slower than [] ... remember stacks can only be accessed from the top
21:06:39 <Pseudonym> In this context?
21:06:41 <bd_> Well, if he's going to be swapping out one stack for another.
21:06:54 <Pseudonym> That's hardly breaking the abstraction.
21:06:55 <chessguy> well, in truth, this is just an example
21:07:01 <bd_> then there'll be this dance of x <- get; put y; m; y' <- get; put x...
21:07:28 <Pseudonym> chessguy: If you have a state monad, there's nothing preventing you from having a state which is a bunch of things.
21:07:42 <Pseudonym> A State/StateT with a record as the state is a popular choice.
21:08:12 <Pseudonym> Another, if you want IO, is a ReaderT with IORefs stacked on top of IO.
21:08:25 <chessguy> ok, but what if i want to have an arbitrary number of these objects with state
21:08:28 <Pseudonym> Or a ReaderT of STRefs on top of ST, for that matter.
21:09:20 <bd_> chessguy: ST if you can arrange  for it to be at the bottom of your monad stack.
21:09:31 <Gwern> so there's something that the error messages aren't making clear to me: how does foo . bar . baz *really* differ from foo $ bar $ baz?
21:09:32 <Pseudonym> Same thing as if you want an arbitrary number of these things not in a monad.
21:09:33 <bd_> is probably the best choice
21:09:51 <bd_> Gwern: foo . bar . baz = \x -> foo $ bar $ baz $ x
21:10:07 <bd_> Gwern: however, foo . bar $ baz is equivalent to foo $ bar $ baz
21:10:13 <bd_> and some argue that the former is more readable
21:10:17 <Gwern> auggh
21:10:26 <sorear> dons: ok, use of getProcessTimes implemented
21:10:31 <Pseudonym> foo . bar . baz $ x = (foo . bar . baz) x
21:10:48 <sorear> dons: extra + - old impl kept #ifdef mingw32_host_OS
21:11:45 <chessguy> so if i had a monad called Stack, what would be the type of a monad which, say, popped one item off every stack in a list of stacks?
21:11:57 <chessguy> (popped and discarded)
21:11:57 <Gwern> so... . builds functions on top of each other, but $ is equivalent to parens?
21:12:03 <sorear> yea
21:12:17 * Gwern will meditate further on this
21:12:50 <chessguy> ?src ($)
21:12:50 <lambdabot> f $ x = f x
21:12:53 <chessguy> ?src (.)
21:12:53 <lambdabot> (.) f g x = f (g x)
21:13:43 <ddarius> Assuming by "monad called Stack" you mean a State monad (or equivalent) with stacks as the state, the type of the operation would simply be Stack ().
21:14:21 <chessguy> but it's a list of stacks
21:14:40 <ddarius> chessguy: What is a list of stacks?
21:14:52 <Pseudonym> [Stack a] ?
21:15:03 <bd_> chessguy: Why would that be a monad? map tail :)
21:15:11 <sorear> dons: cpu time will not do:  9793 stefan    18   0  733m 327m   60 R  4.3 86.7   0:17.78 clausify
21:15:31 <chessguy> hmm, i don't know, my brain is too muddled
21:16:14 <chessguy> yeah, i guess it would be what Pseudonym said
21:16:27 <ddarius> chessguy: You don't use a monad to simulate a data structure, you use it to simulate a computational effect, e.g. mutation, non-determinism, exceptions.
21:16:48 <Pseudonym> Or carrying along a data structure, in this case.
21:17:00 <dons> sorear: point being that you're swapping?
21:17:03 <bd_> or implicit state, in which case you build a monad upon a data structure, and wrap the data structure's operations, typically
21:17:09 <Pseudonym> (Nit: That's not the ONLY use of a monad.)
21:17:10 <chessguy> well, in this case, the monad would be combining the stateful actions on a stack
21:17:16 <chessguy> not technically the stack itself
21:17:23 <ddarius> Pseudonym: I was going to qualify.
21:17:29 <Pseudonym> Sure.
21:17:30 <sorear> dons: yeah, but I have a better idea
21:17:36 <Pseudonym> That's why I didn't expand on the details. :-)
21:17:52 <ddarius> chessguy: Okay, so you'd have State [Stack e] a
21:18:15 <ddarius> chessguy: pop :: Stack (); pop = modify (map tails) >> return ()
21:18:29 <chessguy> mm, but we just said Stack e isn't an object
21:18:44 <sorear> dons: -M`grep MemTotal /proc/meminfo | sed 's/ kB//; s/.* //'`k  # or whatever bsd needs :(
21:18:51 <ddarius> Oh, and type Stack e = [e]
21:19:11 <ddarius> Er and pop :: State [Stack e] ()
21:19:12 <dons> no /proc thanks
21:19:14 <chessguy> i *know* stack can be implemented without a monad
21:19:17 <chessguy> it's an example
21:19:31 <dons> so you want to poll for memory usage?
21:19:35 <dons> that's really a separate issue
21:19:40 <bd_> popall :: State [[e]] (); popall = modify (map tail) ?
21:19:41 <ddarius> chessguy: You don't use the monad to encapsulate the data structure you use the monad to deal with the operations on the data structure.
21:19:47 <dons> the shootout guys have a binding to libgtop for this
21:19:54 <dons> which checks a) if you're swapping, and b) the memory use
21:19:56 <chessguy> ddarius, then why are you writing [Stack e]
21:20:03 <dons> *but* just get cpu time working.
21:20:08 <sorear> I have
21:20:11 <dons> *then* we workout how to error out of swapping starts
21:20:17 <allbery_b> BSD: sysctl hw.physmem
21:20:20 <dons> so i'd look at libgtop for this then.
21:20:28 <sorear> now I'm just using +RTS -M350M -RTS
21:20:35 <ddarius> chessguy: You said you wanted multiple stacks, but if you want one then pop :: State (Stack e) (); pop = modify tail >> return ()
21:20:46 <sorear> this is way more complicated than I ever thought :(
21:21:00 <bd_> ddarius: modify already is (a -> a) -> State a (), I thought? No need for return ()...
21:21:02 <ddarius> sorear: Everything is... except monads.
21:21:03 <bd_> :t modify
21:21:06 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
21:21:23 <dons> sorear: yeah. memory is hard. that's why i didn't do it. the shootout binding to libgtop is pretty hacky too
21:21:24 <ddarius> bd_: Ah, I thought it also returned the state.
21:21:36 <bd_> ddarius: That would be convenient in many cases, yes :)
21:21:38 <dons> kind of surprising there's no standard way to get memory usage across posix
21:21:41 <bd_> but no, it doesn't :)
21:22:34 <chessguy> ddarius, i do want multiple stacks. but on the one hand, you're saying that "Stack e" encapsulates the actions on a stack, and not the stack itself. and on the other hand you're saying "Stack e" is a list of stacks
21:22:40 * sorear ponders using UML/qemu/etc
21:22:47 <kc5tja> BAM -- Firefox bug is teh fixed!  I just need to bundle up a patch for them.
21:22:49 <dons> too hard
21:23:00 <bd_> chessguy: how about this: type StackM e a = State (Stack e) a? :)
21:23:12 <dons> you could use /proc
21:23:16 <ddarius> chessguy: No I'm saying you use a monad (in this case I used State (Stace e)) to encapsulate the operations on the data structure (in this Stack e)
21:23:17 <dons> and then we use the sysctl interface on bsd
21:23:18 <bo_> dons: is this what you looking for CPUTime http://www.reed.edu/~carlislp/ghc6-doc/libraries/haskell98/CPUTime.html
21:23:21 <lambdabot> http://tinyurl.com/yqdqjj
21:24:11 <dons> that's a funny url. but no :-) thanks for looking :)
21:24:14 <dons> ?docs System.CPUTime
21:24:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-CPUTime.html
21:24:36 <dons> its not cputime though. i need subprecoess cpu time. which sorear has sorted out, I think
21:24:51 <dons> by the looks of the patch in my mailbox
21:25:25 <sorear> http://members.cox.net/stefanor/bench.results <-- rerun (Ghc only)
21:25:27 <bo_> you need individual threads' cpu utiiztions?
21:26:21 <dons> just a subprocess forked by system()
21:26:38 <dons> measured on the haskell side of things
21:27:04 <chessguy> !paste
21:27:04 <hpaste> Haskell paste bin: http://hpaste.org/
21:27:23 <hpaste>  chessguy pasted "a stack monad" at http://hpaste.org/562
21:27:41 <bo_> emm I think you can use posix function getrusage
21:27:53 <dons> right that's what we're using now (I think, sorear?)
21:27:58 <sorear> yes
21:28:01 <hpaste>  Steven Ashley pasted "What happened to my generic types :(" at http://hpaste.org/563
21:28:10 <sorear> actually, I think we're using times
21:28:14 <chessguy> ddarius, ok, so here's code for a stack monad.
21:28:26 <dons> sorear: ok. running the suite now with the new timer, and hbc
21:28:36 <glguy> chessguy: is that the *state* monad parameterized for a stack?
21:28:48 <ddarius> chessguy: Which is equivalent to State [a] b.
21:28:54 <chessguy> ddarius, i know it is
21:28:59 <chessguy> that's not the point
21:29:07 <ddarius> just verifying
21:29:08 <chessguy> glguy, no, look at the code
21:29:22 <steven_ashley> Hello, could someone have a look at http://hpaste.org/563 and point me to where I went wrong?
21:29:27 <glguy> chessguy: it's still a state monad
21:29:34 <Pseudonym> Right.
21:29:36 <chessguy> glguy, i know it is
21:29:40 <Pseudonym> It's a state monad with a stack as the state.
21:29:43 <chessguy> yes
21:29:51 <glguy> chessguy: I was just correcting it being called a stack monad
21:30:01 <chessguy> sigh
21:30:16 <chessguy> it says right in it "instance Monad (Stack a)..."
21:30:18 <bd_> so, er, what was the question about this stack monad? XD
21:30:25 <chessguy> i think that qualifies as a stack monad
21:30:59 <chessguy> so, this encapsulates the stateful side effects of stack operations on a single stack
21:31:09 <sorear> steven_ashley: monomorphism I think ... things bound by lambdas (or eqv <-) are forced to have a specific type
21:31:23 <Pseudonym> steven_ashley: Sorry, what's p in your code?
21:31:24 <glguy> it encapsulates state, the stack nature of it has nothing to do with it's beinga monad :-p
21:31:29 <ddarius> steven_ashley: What sorear said minus the I think.
21:31:32 <chessguy> but what if, for some reason, i wanted to use this on a higher-order data structure, which was, in fact, a list of stacks
21:31:45 <ddarius> Pseudonym: It's in the GHCi session, though I too was lost for a bit.
21:31:46 <dmead> mista blooo skyyyy
21:31:51 <sorear> steven_ashley: it's a slightly quirky limitation of the original haskell type system, but we can't fix it now because the soundness of IORef depends on it.
21:31:53 <steven_ashley> p = proxy
21:31:54 <Pseudonym> Ah, I see.
21:32:01 <steven_ashley> miss-paste ;)
21:32:06 <steven_ashley> ok :)
21:32:06 <chessguy> (using the term 'higher order' loosely)
21:32:17 <steven_ashley> :p
21:32:21 <sorear> steven_ashley: w/o monomorphic lambda bindings : cast x = do r <- newIORef ; writeIORef r x ; readIORef r
21:32:23 <glguy> chessguy: there isn't a natural way to use that to support many stacks
21:32:31 <Pseudonym> steven_ashley: Put in type declarations eagerly and see what happens.
21:32:31 <sorear> cast :: a -> IO b, and WILL SEGFAULT
21:32:31 <bd_> chessguy: You might be able to do some sort of hack by making it a transformer over List... but it's not going to work very well.
21:32:52 <Pseudonym> Actually, chessguy, there's a very Oleg-esque way to do this.
21:33:19 <Pseudonym> If your Stack monad was a transformer, you could stack Stack on top of Stack.
21:33:22 <chessguy> so, i can't encapsulate actions like adding a stack to my list, mapping pop across my list of stacks, etc.
21:33:34 <Pseudonym> And use Peano numbers to say which stack you want to get to.
21:33:52 <chessguy> wow, that's really ugly
21:33:56 <Pseudonym> Yup.
21:34:01 <steven_ashley> sorear: thanks, that clears things up a lot
21:34:01 <bd_> chessguy: Not with your current monad. If you were using ordinary State over a list of stacks, it'd be easy - modify (map pop)
21:34:04 <ddarius> Pseudonym: Or more cleanly simply use the coproduct monad.
21:34:06 <glguy> chessguy: it's a state monad... doesn't relaly have anything to do with a stack
21:34:07 <sorear> dons: ooh, Malcolm Wallace is contributing now! we have attention!
21:34:07 <bd_> or similar
21:34:11 <glguy> chessguy: so it's hard to do what you want
21:34:23 <chessguy> but why?
21:34:30 <Pseudonym> The thing is, chessguy, think about how you'd express it if there was no monad.
21:34:41 <Pseudonym> The monad is actually a distraction.
21:34:55 <Pseudonym> Think of push :: a -> Stack a -> Stack a
21:34:55 <Pseudonym> etc
21:35:05 <chessguy> ok
21:35:15 <ddarius> (where Stack a == [a] I assume/assert)
21:35:16 <Pseudonym> Then think about how you'd pass around a bunch of those.
21:35:29 <Pseudonym> ddarius: Yes, though thinking about it in the abstract helps, I find.
21:35:43 <ddarius> Yeah.
21:35:54 <Pseudonym> I'd prefer a newtype to a type synonym here.
21:36:17 <ddarius> I was going to throw, "or isomorphic to"
21:36:23 <Pseudonym> Yeah.
21:36:26 <chessguy> so addStack :: Stack a -> [Stack a] -> [Stack a]
21:36:26 <Pseudonym> Anyway.
21:36:41 <Pseudonym> chessguy: That's right if all of your stacks hold the same type.
21:36:45 <Pseudonym> Is that a correct assumption?
21:36:54 <chessguy> sure
21:36:54 <ddarius> Incidentally, mixing multiple pieces of state from multiple State monads is a good use case for coproduct monads I believe.
21:37:04 <Pseudonym> chessguy: OK then.
21:37:09 <Pseudonym> Make [Stack a] your state.
21:37:39 <ddarius> Pseudonym is depressed by the lack of need for Oleg-esque type hackery.
21:37:46 <Pseudonym> :-)
21:37:52 <chessguy> but this still doesn't answer the question of why monads make it so much harder
21:38:05 <Pseudonym> chessguy: They don't, as you will soon see.
21:38:22 <Pseudonym> You have what is, essentially, an ugly prolem.
21:38:32 <Pseudonym> What monads buy you is the ability to hide the ugliness.
21:38:52 <Pseudonym> What you should NOT do is expose the [Stack a] in the interface to your monad.
21:39:02 <Pseudonym> Rather, add your-monad-specific meaningful operations.
21:39:13 <Pseudonym> e.g.: push :: Int -> a -> MyMonad ()
21:39:19 <Pseudonym> e.g.: push :: Int -> a -> MyMonad a ()
21:39:36 <Pseudonym> Which pushes an element onto a specific stack, indexed by an Int.
21:40:15 <Pseudonym> Of course, you don't need to index with an Int.
21:40:19 <Pseudonym> It could be anything.
21:41:21 <chessguy> i'm following so far i think...
21:43:10 <chessguy> not really sure what your point is yet...
21:44:28 <chessguy> you're saying i can, internally, have a [Stack a], as long as i don't expose it?
21:44:31 <Pseudonym> Right.
21:44:37 <Pseudonym> And then, the client doesn't see anything ugly.
21:44:44 <Pseudonym> Your problem is that you think it makes it "so much harder".
21:44:58 <Pseudonym> No it does not.  It lets you be modular, and modular is easier.
21:45:02 <chessguy> uh
21:45:10 <chessguy> you guys were the ones that said it was so much harder
21:45:14 <chessguy> with a stack monad
21:45:38 <Pseudonym> But now we're talking about something built on top of a State monad.
21:45:56 <Pseudonym> You let State (or StateT) deal with the propagagion of state, and you just add a small layer which handles a bunch of stacks.
21:46:11 <Pseudonym> And then the client of THAT code deals with an abstraction which provides a bunch of stacks.
21:46:17 <dons> sorear:
21:46:18 <dons> Test: gen_regexps (expansions of a generalised regular expression)
21:46:18 <dons> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/gen_regexps
21:46:18 <dons> ghc                  0.000    seconds            (NaN x)
21:46:18 <dons> ghc-old              0.010    seconds            (Infinity x)
21:46:20 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/gen_regexps, http://tinyurl.com/2bob8g
21:46:20 <dons> hbc                  0.020    seconds            (Infinity x)
21:46:24 <dons> :-)
21:46:33 <dons> might need to tweak that test
21:46:46 <chessguy> thanks for flooding in the middle of an interesting conversation, dons
21:46:53 <dons> sorear: seems to measure only to 2 decimal points?
21:46:59 <dons> e.g.
21:47:00 <dons> hbc                  3.020    seconds            (1.3 x)
21:47:00 <dons> nhc98                5.530    seconds            (2.4 x)
21:47:00 <dons> ghci                 46.160    seconds            (19.6 x)
21:47:10 <Pseudonym> dons: Actually, I was done until you had another question.
21:47:18 <chessguy> flooding to a particular person instead of the channel, no less
21:47:32 <dons> ah sorry chessguy.
21:47:42 <Pseudonym> dons: This seems like the sort of thing for #haskell-overflow.
21:47:46 <Pseudonym> Just a suggestion.
21:47:47 <dons> yep
21:47:50 <chessguy> or just /msg
21:48:07 <Pseudonym> chessguy: Not everyone's IRC client makes it easy to paste into a /msg
21:48:09 <sorear> well, if bsd has a more accurate timer ... #ifdef anyone?
21:48:21 * araujo fixing some bugs and cleaning a bit the gui interface of himerge
21:48:27 <Pseudonym> dons: Clearly your machine is too fast.
21:48:34 <Pseudonym> I have a 300MHz machine hanging around.
21:48:38 <chessguy> Pseudonym, so is this a good way to build things up? abstract concepts into monads, and then monads into more monads?
21:48:43 <Pseudonym> Right.
21:48:46 <Pseudonym> I think so.
21:49:02 <Pseudonym> The monads that, say, MTL provides, are building blocks.
21:49:12 <chessguy> Pseudonym, are you familiar with genetic programming?
21:49:19 <Pseudonym> Yup.
21:49:27 <Pseudonym> I break ciphers in Haskell.
21:49:35 <Pseudonym> Classical ciphers, not DES.
21:49:40 <chessguy> i'm thinking of having a monad for an individual member of the population
21:49:49 <chessguy> and then a monad for a population of individuals
21:49:54 <Pseudonym> Why?
21:49:54 <chessguy> and so on
21:50:07 <chessguy> why what?
21:50:17 <Pseudonym> Why do you want to structure it that way?
21:50:28 <Pseudonym> I think of a breeding pool as a collection of individuals.
21:50:41 <chessguy> because evaluating an individual requires stateful actions
21:50:45 <Pseudonym> I'm not saying you're wrong.
21:50:48 <Pseudonym> Ah.
21:50:49 <Pseudonym> I see.
21:50:53 <Pseudonym> OK, I have another suggestion.
21:50:59 <chessguy> i'm listening
21:51:06 <Pseudonym> This is where monad transformers come into their own.
21:51:20 <Pseudonym> You can stack on additional monads for a small part of the code.
21:51:50 <Pseudonym> So, for example, you can stack an individual-transformer-monad on top of a whole-population-transformer-monad.
21:51:58 <Pseudonym> Just while you modify one individual.
21:52:11 <chessguy> huh?
21:52:11 <dmead> hey guys
21:52:16 <dmead> whats () mean?
21:52:18 <dmead> in a nutshell?
21:52:24 <Pseudonym> dmead: It's the no-element tuple.
21:52:24 <chessguy> the empty tuple
21:52:34 <dmead> as in IO()
21:52:35 <dmead> ?
21:52:44 <Pseudonym> it's also the type with only one thing in it (apart from bottom).
21:52:45 <steven_ashley> yep
21:52:51 <dmead> hmm
21:52:55 <dmead> thats the type of a print function
21:52:56 <Pseudonym> So it's the identity for Cartesian product.
21:52:59 <dmead> so if it read something in
21:53:06 <dmead> it's be IO(some stuff)
21:53:08 <dmead> right?
21:53:09 <Pseudonym> ((), A) is isomorphic (more or less) to A
21:53:15 <Pseudonym> Correct.
21:53:17 <dmead> ahh
21:53:19 <dmead> k
21:53:26 <Pseudonym> ?t getChar
21:53:26 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
21:53:30 <Pseudonym> :t getChar
21:53:33 <lambdabot> IO Char
21:53:33 <chessguy> Pseudonym, i don't follow your individual-transformer-monad on top of a whole-population-monad
21:53:34 <Pseudonym> As an example.
21:53:46 <Pseudonym> chessguy: Yes, I know.  I'm trying to think of a good way to explain it.
21:53:47 <ddarius> dmead: () is 'void' in C.
21:53:54 <Pseudonym> Hang on, let me just visit the water cooler.  Be back in a minute.
21:53:55 <ddarius> (or rather the other way around)
21:54:13 <dmead> C?
21:54:15 <dmead> never heard of it.
21:54:17 <dmead> :P
21:54:27 <siti> lets have a void pointer, now that's one thing that confused me in c, how can you have a pointer to nothing?
21:54:53 <ddarius> It's nothing it's something. "void" is a very wrong word for it.
21:54:53 <dmead> it's just a memory address to something that returns nothing
21:54:58 <nrb23> siti: it's not like the C type system makes any sense
21:55:18 <dmead> it's technically sound, not conceptually sound
21:55:26 <sorear> dmead: () is 'unit' in ML
21:55:43 <dmead> the difference of which is debatable ^^
21:55:51 <dmead> sorear: i gathered :P
21:56:02 <Pseudonym> chessguy: Back.
21:56:09 <chessguy> i'm here
21:56:17 <Pseudonym> OK, think of it this way.
21:56:20 <dmead> hmm
21:56:28 <Pseudonym> main is of type IO something.
21:56:28 <ddarius> A void * is actually both technically and conceptually sound.  Or at the worst, it's not technically sound, but still conceptually sound.
21:56:31 <dmead> i've noticed how writting type signatures speeds up runtime
21:56:37 <Pseudonym> So at the outer layer you have IO.
21:56:49 <Pseudonym> For some of the program, you might stack something on top of IO.
21:56:51 <Pseudonym> e.g. StackT.
21:56:52 <chessguy> main has to be of type IO ()
21:56:57 <Pseudonym> StateT, whatever.
21:57:10 <dmead> void main (void*)
21:57:10 <dmead> etc
21:57:13 <dons> dmead: sometimes it can remove excessive polymorphism
21:57:20 <dmead> yea
21:57:24 <dons> i.e. constraining some code to Int or [Int]
21:57:24 <Pseudonym> So you can think of the program as being in the IO monad, but for some of it, you can add on extra monad functionality.
21:57:32 <dons> rather than slower Integer, or even fully polymorphic code
21:57:35 <sorear> dmead: the compiler can't do much with overloaded + - etc.
21:57:36 <Pseudonym> Make sense?
21:57:41 <dmead> my test run went from 36/100 second to 22/100
21:57:52 <sorear> dmead: Int isn't much faster than Num a => a, BUT
21:57:55 <chessguy> i think so
21:58:01 <Pseudonym> chessguy: OK.
21:58:02 <dmead> for 25 or so theorems
21:58:03 <dmead> hmm
21:58:06 <dons> dmead you can confirm why this is by checking the type in ghci
21:58:08 <sorear> dmead: Int can be optimized easily to Int#, which is a native C int
21:58:11 <dons> i.e. ask ghci :t to infer the type
21:58:21 <dons> if it is Integer, and you can get by with Int, add a constraint
21:58:21 <Pseudonym> Now imagine that you have some monad which carries around your whole state.
21:58:25 <Pseudonym> Say:
21:58:36 <dmead> ahh
21:58:37 <dmead> well
21:58:44 <Pseudonym> data WorldState = WorldState { population :: [Individual] }
21:58:44 <dmead> i don't really have much computation going on per say
21:58:48 <ddarius> dmead: On comp.lang.functional some years ago there was an example showing Haskell being a lot slower than C or something on factorial or some such.  The picture was much different when an Int -> Int type signature was added.
21:58:51 <dmead> it's just characters getting tossed around
21:58:53 <geekagent> Anyone ever tried to link to an ffi function that calls lapack?
21:58:57 <Pseudonym> I'm using a record here because you're gonna add something in the future.
21:58:58 <chessguy> ok
21:58:59 <dmead> ahh
21:59:02 <chessguy> right
21:59:18 <dmead> yea when i first read about the language i heard it can compete with C in most cases
21:59:19 <Pseudonym> OK.  So the guts of your program might be of type:
21:59:36 <Pseudonym> type MainMonad a = StateT WorldState IO a
21:59:43 <ddarius> geekagent: I'm pretty sure someone has done it.
21:59:52 <sieni> dmead: returning nothing in Haskell means that your computation fails to return a value, i.e. the computation diverges. So this "returning nothing" thingie in Haskell is the more sensible "return the canonical value that you return, when you don't care, what's returned"
22:00:01 <Pseudonym> (Slight nit: I'd actually personally use newtype to hide the fact that you're using StateT.)
22:00:10 <dmead> :o
22:00:12 <Pseudonym> (Especially if I thought the program was going to get complicated.)
22:00:29 <dylan> I am back, baby!
22:00:36 <ddarius> Especially with deriving Monad.
22:00:40 <dons> hi dylan
22:00:46 <dons> ?users
22:00:47 <lambdabot> Maximum users seen in #haskell: 317, currently: 274 (86.4%), active: 34 (12.4%)
22:01:08 <Pseudonym> chessguy: OK.
22:01:21 <Pseudonym> But for some of your program, you'd like to concentrate on an individual.
22:01:31 <chessguy> so you're saying main would delegate the main execution of the program to this MainMonad, which does some IO and other stateful stuff?
22:01:51 <Pseudonym> Perhaps: type IndividualMonad a = StateT Individual IO a
22:02:09 <Pseudonym> Or: type IndividualMonad a = StateT Individual MainMonad a
22:02:32 <dmead> oof
22:02:32 <Pseudonym> So you stack on some functionality, if you need to concentrate on something for a bit.
22:02:33 <dmead> so tired
22:02:54 <Pseudonym> chessguy: Yeah.
22:03:14 <Pseudonym> You might do some setup in IO, of course, but then the guts of the program are in some specialised monad.
22:03:22 <dmead> odd
22:03:29 <dmead> i have a little test function setup
22:03:37 <chessguy> but you're stacking the specialized monad on top of IO anyway
22:03:41 <dmead> to map my prover over a list of test data
22:03:50 * ddarius suspects that gestures will be very convenient with a touchpad. He is about to try it out.
22:03:51 <Pseudonym> chessguy: That's just an example.
22:03:54 <dmead> it's just do mapM_ prover [list of stuff]
22:03:59 <Pseudonym> If you don't need IO, you don't have to have it.
22:04:02 <dmead> adding a type sig made it run slightly slower
22:04:16 <Pseudonym> It's often useful for debugging.
22:04:36 <chessguy> yeah, i want to be able to do some logging type stuff
22:04:36 <Pseudonym> You can liftIO $ putStrLn "Diagnostics" if you need to.
22:04:51 * sorear is a big fan of ghci debugging
22:05:09 <sorear> Main> myFunction input == rightAnswer
22:05:16 <dmead> gg, etc
22:05:45 <ddarius> graggle!
22:05:55 <chessguy> hmm
22:06:03 <dmead> :o
22:06:22 <sorear> night.
22:06:34 <chessguy> Pseudonym, so...you still have a monad for an individual member of the population, and one for the population and other assorted state
22:06:39 <Pseudonym> Right.
22:06:52 <chessguy> which...is what i suggested to start with
22:07:14 <Pseudonym> And you have an operation on the population/state monad which pulls out an individual member and works on that.
22:07:49 <Pseudonym> workOnMember :: IndividualIndex -> IndividualMonad a -> MainMonad a
22:07:59 <Pseudonym> (IndividualIndex is probably just Int.)
22:08:20 <chessguy> actually, i'll want to have a function in there to select an Individual
22:08:44 <chessguy> based on the RNG in the MainMonad and some other things
22:08:51 <Pseudonym> workOnMember will pull out an Individual, munge it, then put it back into the MainMonad state.
22:09:06 <Pseudonym> Where the munging is expressed in the IndividualMonad.
22:10:04 <chessguy> so i can have selectMember :: MainMonad a -> IndividualMonad a, right?
22:10:14 <Pseudonym> No.  Wrong type.
22:10:31 <Pseudonym> selectMember is going to be an operation in the MainMonad.
22:10:39 <Pseudonym> That's where it will be called from.
22:10:47 <ddarius> selectMember :: MainMonad Individual
22:10:48 <chessguy> yes
22:11:01 <Pseudonym> Or:
22:11:08 <Pseudonym> selectMember :: IndividualMonad a -> MainMonad a
22:11:17 <Pseudonym> Randomly select an individual, munge it, and then put it back in.
22:11:45 <chessguy> mmmm
22:11:48 <Pseudonym> And even return something else if you want to.
22:12:06 <chessguy> but that signature requires that you have the individual already, doesn't it?
22:12:30 <Pseudonym> I guess that shouldn't be called selectMember.
22:12:35 <Pseudonym> Maybe modifyMember, or mutateMember.
22:12:36 <ddarius> chessguy: IndividualMonad a would be the operations you wish to perform on the member
22:13:52 <ddarius> chessguy: However, ignoring all this, my impression is that you are connecting monads to instances of data structures (Individuals in this case).
22:14:24 <ddarius> chessguy: One way to think of monads (as they are usually used in Haskell) is to think of them as extending Haskell with some kind of effect.
22:15:08 <Pseudonym> Using that approach, monad transformers extend effects with other effects.
22:16:10 <ddarius> chessguy: IndividualMonad in this case makes a language to talk about manipulation of Individuals and as such it does not make sense to think about it as a per Individual thing.
22:16:57 <chessguy> so IndividualMonad is like mutate, cross-breed, etc.
22:17:11 <Pseudonym> Well cross-breed would presumably require two individuals.
22:17:19 <chessguy> yes
22:17:41 <Pseudonym> I just tend to write breed :: Individual -> Individual -> MainMonad Individual
22:17:49 <Pseudonym> But my genetic code tends to be simple.
22:19:20 <dibblego> how do you write subtract for data Nat = Zero | Succ Nat ?
22:20:26 <Pseudonym> subtract n Zero = n
22:20:40 <Pseudonym> subtract (Succ n) (Succ m) = subtract n m
22:20:42 <Pseudonym> Done.
22:21:04 <davidmccabe> I'm looking for a very succinct example that shows the stateless nature of haskell; perhaps a comparison of idioms.
22:21:04 <dibblego> of course, thanks
22:21:05 <dmead> oof
22:21:12 <dmead> that hurts me
22:21:12 <dmead> inside
22:21:15 <dmead> makes dan sad
22:21:20 <Pseudonym> I gotta go.
22:21:22 <Pseudonym> Nytol.
22:21:45 <Pseudonym> Cya.
22:21:49 <dmead> night
22:21:56 <Pseudonym> chessguy: Gotta go.  Good luck.
22:21:56 <dmead> hi netsplit
22:22:30 <chessguy> ddarius, is that where transformers come in? when i'm in one monad but use operations from another?
22:22:41 <ddarius> chessguy: Maybe, probably not the way I see it, but it depends on what state. (re your first response)
22:23:19 <dmead> is there a standard way of printing help output with command line apps in haskell?
22:23:40 <ddarius> chessguy: As Pseudonym said, a monad transformer extends a given "language" defined by one monad.
22:23:44 <dmead> i haven't seen a clear way of controling execution inside a do ...
22:24:53 <chessguy> ddarius, are you familiar with genetic programming?
22:24:59 <ddarius> chessguy: Yes.
22:25:08 <chessguy> ok, good
22:25:40 <chessguy> so would you agree that cross-breeding two individuals should be done in the population monad?
22:26:02 <ddarius> Yes, I agree with that.  I don't see you needing IndividualMonad to do it though.
22:26:18 <bd_> it could be done in the coproduct of the two IndividualMonads
22:26:28 <chessguy> well, if IndividualMonad contains operation like choosing a random point within an individual
22:26:41 <chessguy> and getting the subtree rooted there
22:26:57 <bd_> if we have dependent types, we can then parameterize the new IndividualMonad on the result of the joined monad, then
22:27:33 <chessguy> ddarius, wouldn't you need some kind of operations like that?
22:27:52 <chessguy> though maybe they wouldn't be monadic
22:27:52 <ddarius> chessguy: To be honest, I don't see a point for IndividualMonad except for "executing" the Individuals.  Otherwise these are just normal (non-monadic) functions.
22:28:45 <chessguy> true
22:29:40 <chessguy> but they have to be created in the Individual monad too, i think
22:29:49 <chessguy> because they are composed of monad actions
22:29:57 <ddarius> Also, unless the Individuals needed access to, say, other members while executing I would not have IndividualMonad be a monad transformer over MainMonad.
22:30:14 <sieni> dmead: you can just say do {...; if a then do {...} else do {...}; ...}
22:30:25 <ddarius> chessguy: Presumably, an Individual is just a data structure representing the program.
22:30:33 <dmead> oh
22:30:35 <chessguy> ddarius, yes
22:30:38 <chessguy> a tree
22:30:50 <dmead> i wasn't aware if-then-else is valid in a do
22:31:11 <ddarius> dmead: Do is very thin syntactic sugar.
22:31:50 <chessguy> ddarius, hmm. so you're saying even constructing the individuals shouldn't be done in the Individual monad?
22:31:51 <dmead> right right
22:31:55 <dmead> hmm
22:32:43 <ddarius> chessguy: Correct.  As I said earlier, the only reason I see for IndividualMonad is for executing them.
22:33:18 <ddarius> chessguy: To build and manipulate Individuals, you are just building and manipulating trees.
22:33:42 <bd_> coprod (executePerson alice) (executePerson bob) copulate :: IO Person
22:33:43 <chessguy> hmm
22:34:03 <chessguy> but the nodes of the trees are monadic actions
22:34:16 <bd_> chessguy: Trees are monads, too.
22:34:17 <chessguy> or, will be when executed
22:34:41 <bd_> data Tree a = Branch (Tree a) (Tree a) | Leaf a
22:35:07 <ddarius> chessguy: Okay.  In the former case, fine, you have a Tree (IndividualMonad Result).  In the latter case, you have eval :: Individual -> IndividualMonad Result.
22:35:14 <bd_> join (Leaf x) = x; join (Branch x) = ... somehow merge the branches XD
22:35:23 <bd_> well, I guess just recurse, come to think of it
22:35:35 <bd_> join (Branch x y) = Branch (join x) (join y)
22:35:59 <ddarius> bd_: The tree monad is a free monad.  (>>=) simply replaces leafs with trees.
22:36:07 <bd_> 'free monad'?
22:36:26 <Japsu> @hoogle tree
22:36:26 <lambdabot> Data.Graph.Inductive.Tree :: module
22:36:26 <lambdabot> Data.Tree :: module
22:36:26 <lambdabot> Data.Tree.Tree :: data Tree a
22:36:43 <chessguy> so even though it's a tree of monad actions, the actions on the tree itself don't need to be monadic. right?
22:36:48 <ddarius> http://lambda-the-ultimate.org/node/1183#comment-12896
22:36:49 <lambdabot> Title: The Haskell Programmer&#039;s Guide to the IO Monad --- Don&#039;t Panic | Lambd ...
22:36:57 <dmead> ?paste
22:36:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:37:07 <ddarius> chessguy: Correct. E.g.
22:37:07 <abz> whats the situation with the Haskell weekly new letter? sequence.complete.org is up to the 31st.
22:37:14 <abz> news
22:37:29 <ddarius> @type putStr "Hi":[putStrLn "foo"]
22:37:31 <lambdabot> [IO ()]
22:37:46 <hpaste>  dmead pasted "if-else in a do?" at http://hpaste.org/564
22:37:59 <chessguy> a list of IO actions
22:38:00 <ddarius> abz: It's really the Haskell Whenever Cale Updates It News Letter.
22:38:35 <dmead> ddarius: i get bad layout with that
22:38:37 <ddarius> chessguy: And that expression is a pure function (well value)
22:38:58 <ddarius> dmead: Yeah, the if's in do's are annoying.
22:41:06 <abz> ddarius: So, nothing to worry about then.
22:41:52 <ddarius> abz: The previous one was Jan 09
22:42:26 <chessguy> ddarius, i'll have to ponder this some more. thanks
22:43:38 <abz> ddarius: in true haskell style... no deterministic order of execution
22:43:53 <ddarius> abz: Just lazy or more likely busy.
22:45:13 <ddarius> abz: Actually, I think dons is responsible for it now, not Cale.
22:46:17 <Korollary> Hah. All About Monads is down.
22:47:25 <davidmccabe> I asked this right before the netsplit, so I'm not sure if anyone saw it:
22:47:27 <abz> Speaking of sites down, updike.org has been down for a while now....
22:47:31 <davidmccabe> I'm looking for a very succinct example that shows the stateless nature of haskell; perhaps a comparison of idioms. Any pointers?
22:48:30 <dmead> haskell.org/tutorial
22:48:39 <davidmccabe> other than quicksort.
22:48:55 <davidmccabe> er, wrong url.
22:49:11 <davidmccabe> thanks :)
22:49:26 <ddarius> davidmccabe: Practically all code shows the stateless nature of Haskell...
22:49:28 <dmead> http://haskell.org/tutorial/indextutorial.html
22:49:29 <lambdabot> Title: Haskell 98 Index
22:49:53 <dmead> if you read the tutorial theres a running example of a binary tree implementation
22:50:01 <dmead> seems like thats pretty decent
22:50:22 <dmead> anyone got a quick way to print a list?
22:50:33 <dmead> in list form that is
22:50:58 <Japsu> dmead: just show it
22:51:04 <dmead> ah
22:51:04 <dmead> k
22:51:09 <Japsu> > show [1,2,3]
22:51:10 <lambdabot>  "[1,2,3]"
22:52:24 <dmead> i'm doing
22:52:28 <dmead> s <- getArgs
22:52:36 <dmead> and i want to print s, which is a string list
22:52:44 <Japsu> > show ["a","list","of","strings"]
22:52:45 <lambdabot>  "[\"a\",\"list\",\"of\",\"strings\"]"
22:52:51 <dmead> hmm
22:53:02 <dmead> Provermain.hs:18:9:
22:53:03 <dmead>     Couldn't match `IO' against `[]'
22:53:03 <dmead>       Expected type: IO t
22:53:03 <dmead>       Inferred type: String
22:53:23 <Japsu> yeah well, you main has to return an IO monad
22:53:27 <Japsu> *your
22:53:45 <ddarius> print [1,2,3]
22:54:03 <dmead> ahhh
22:54:04 <dmead> there we are
22:54:07 <Japsu> oh, that works too
22:54:10 <dmead> added the sig for main
22:54:20 <Japsu> no need for explicit "show"
22:55:59 <pjd> davidmccabe: context for the example?
22:59:17 <pjd> fibs = 1 : 1 : zipWith (+) fibs (tail fibs) ?
22:59:38 <Japsu> :o
23:01:38 <ddarius> It's interesting to note that no one claims Haskell is getting more like some other language.
23:01:38 <pjd> or map f $ map g $ map h xs ?
23:01:55 <pjd> what sense of "stateless" do you want to illustrate?
23:02:05 <ddarius> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
23:02:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
23:02:44 <pjd> ddarius: it's the other way around, of course :)
23:03:27 <Japsu> hmm
23:03:35 <Japsu> is ocaml worth learning?
23:03:37 <ddarius> pjd: Exactly.
23:04:08 <kc5tja> pjd: Meanwhile, the Lisp folks will look at you baffled, and wonder, "What took Haskell so long?  We were here decades ago!"  :)  j/k
23:04:26 <pjd> kc5tja: no, it's the other way around :)
23:04:35 <kc5tja> pjd: You obviously never dealt with a Lisper.
23:04:42 <pjd> kc5tja: i *am* a lisper
23:05:01 <pjd> (well, Schemer, anyway)
23:05:19 <kc5tja> No, if you don't believe that "All Languages Are Inferior Dialects of Lisp," you're not a true Lisper.  :)
23:05:41 <Japsu> :D
23:06:04 <kc5tja> I've run into these folks all too often.
23:06:14 <pjd> kc5tja: No True Scotsman, eh?
23:06:24 <ddarius> kc5tja: Haskell is gaining some lispy things, but isn't evolving towards Lisp.
23:06:26 <pjd> kc5tja: they probably weren't lispers
23:06:49 <ddarius> Schemers are different from Lispers.
23:06:52 <kc5tja> pjd: Tell that to the more "esteemed" company in #lisp.  :)
23:07:06 * pjd shrugs
23:07:08 <kc5tja> ddarius: Haskell has always been able to do nearly everything Lisp can do.
23:07:16 <kc5tja> "evolving" isn't necessary.
23:07:19 <ddarius> c.l.s is bearable, enjoyable even, c.l.l on the other hand...
23:08:04 <kc5tja> pjd: It was humor.  I think the Lisp community has gotten to be so inbred that they're legally a cult now.  :)
23:08:38 <pjd> Japsu: i'm not really familiar with ocaml, but it does some really nifty meta-linguistic things as far as i know/hear
23:08:47 <Patty01> "A life wiothout macros is a life not lived"
23:09:30 <ddarius> "A lift without laziness, is a life not worth having."
23:10:15 <kc5tja> Since a lift is an elevator, it should read something like, "A lift without laziness is in need of repair."
23:10:18 <Japsu> pjd: yeah well, once I ran into some ocaml code in some tutorial that implemented a mathematical expression parser using some interesting syntax provided by some module
23:10:33 <pjd> Japsu: there was this very interesting tutorial on reddit a while ago that did some really impressive language translation hackery in ocaml
23:10:42 <Japsu> hmm.
23:10:42 <ddarius> camlp4 is pretty cool.
23:12:37 <zarvok> camlp4 is kind of scary
23:12:43 <pjd> i can't find the URL :/
23:13:28 <Japsu> yeah, camlp4 must be just what that tutorial I read was using
23:13:49 <zarvok> it can (and is by default) used to do something that seem to make little syntactic sense when considering a normal compilation model
23:13:57 <zarvok> string.escaped is a good example
23:14:32 <pjd> IIRC, it was translating a make language to C
23:15:14 <ddarius> @google One day compiler
23:15:16 <lambdabot> http://www.venge.net/graydon/talks/mkc/html/mgp00001.html
23:15:17 <lambdabot> Title: MagicPoint presentation foils
23:15:42 <pjd> that was it, thanks!
23:16:02 <dmead> kc5tja: sounds like some people i know
23:16:10 <dmead> they <3 lisp
23:17:00 <araujo> Lisp is nice. Just not as nice as Haskell.
23:19:37 <pjd> arasinen: nice in a different way
23:20:19 <dmead> "A lift without laziness, is a life not worth having."
23:20:24 <dmead> i love that motto every day
23:20:26 <dmead> *live
23:20:29 <dmead> live/love
23:20:31 <dmead> etc
23:20:52 <pjd> i like the lift version too :)
23:24:37 <xpika> can someone help me with this
23:24:42 <xpika> do { x <- newIORef (Foo {a=1,b=2,c=3}) ; modifyIORef x {b=99} ; readIORef x >>= print}
23:26:41 <xpika> if only field updates were first class :(
23:27:26 <dmead> ;/
