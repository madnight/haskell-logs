00:01:11 <calvins_> Anybody have any experience with gtk2hs? I can't get a 'quit' menu item to work. In glade, I mapped the 'activate' signal for that menuitem to a handler called 'onQuitActivate', and I defined a function by that name that calls prints a debug and calls mainQuit, but the handler function is never called.
00:06:12 <Lemmih> calvins_: libglade won't call Haskell functions.
00:06:21 <xic> calvins_: i'm not sure that you can automatically have signal connected like that. i think that only works in c
00:06:26 <calvins_> ah, that explains it
00:06:42 <calvins_> so you have to manually register for an event with the menuitem in haskell code..
00:06:46 <calvins_> ?
00:06:48 <xic> yes
00:07:00 <calvins_> thanks a lot.
00:07:08 <xic> maybe with template haskell you could have automatic signal wiring
00:07:16 <xic> Lemmih: btw, how is hIDE coming along?
00:18:19 <Lemmih> xic: I got it building again. But then real-life came to kick me in the butt and tell me that I haven't the time for such pet projects /-:
00:18:33 <xic> Lemmih: :'(
00:18:44 <xic> Lemmih: does it as least work with the latest ghc and gtk2hs?
00:26:20 <Lemmih> Well, it's like the chassis of a car. It's not broken but there's not much to play with.
00:26:40 <xic> i see....
00:30:49 <hachiya> wow, this channel is larger than i expected it to be!
00:31:21 <Lemmih> ?users
00:31:21 <lambdabot> Maximum users seen in #haskell: 322, currently: 270 (83.9%), active: 18 (6.7%)
00:32:43 <hachiya> hmm not bad
00:32:49 <hachiya> what do you guys here use haskell for?
00:34:04 <sorear> everything, more or less
00:34:28 <xic> what is the eta-reduction property?
00:34:37 <xic> google isn't too helpful
00:34:46 <sorear> A language has the eta-reduction property if:
00:34:52 <sorear> \x -> f x  <==>  f
00:35:03 <sorear> Haskell does *not* have the eta-reduction property.
00:35:16 <sorear> > undefined `seq` 2
00:35:17 <lambdabot>  Undefined
00:35:23 <sorear> > (\x -> undefined x) `seq` 2
00:35:25 <lambdabot>  2
00:36:04 <xic> hm...
00:39:14 <hachiya> sorear: what does the first statement mean in english?
00:39:29 <hachiya> the haskell statement
00:40:44 <sorear> \x -> f x is a lambda form, an anonymous function, which takes a value and returns what f returns when applied to the value.
00:41:02 <sorear> it's not really that confusing, it's just hard to linearize
00:42:02 <Heffalump> hachiya: whatever I feel like at the time. At work currently, translating XML into C++. At home currently, reading a database of my personal finances and presenting them to me.
00:42:36 <xic> sorear: where did you learn what the eta-reduction property is? school?
00:42:48 <sorear> definitely not school
00:43:08 <sorear> I don't remember, probably some website...
00:43:30 <hachiya> Heffalump: cool, what do you use for the presentation part of it?
00:43:34 <hachiya> text or some gui?
00:43:51 <sorear> they don't teach *any* programming or non-numeric math at my school.
00:44:06 <Heffalump> hachiya: just text atm, will move to CGI when I get round to it
00:44:24 <hachiya> that is pretty cool, so haskell can read db's like mysql?
00:44:41 <Heffalump> yes
00:44:42 <sjanssen> sorear: there isn't even a BASIC / C++ programming elective?
00:44:58 <sorear> nope
00:45:05 <sjanssen> that's unfortunate
00:45:05 <hachiya> sorear, thanks for the explanation btw
00:45:10 <Heffalump> it has an SQL based interface and a higher level relational interface called haskelldb (I'm planning on having another look at that this weekend)
00:45:17 <sorear> hachiya: it actually made sense !?
00:46:07 <hachiya> kind of, does <==> mean equivalent?
00:47:25 <sorear> yes
00:48:03 <hachiya> ok so basically eta-reduction means an anon function containing an existing function, f  should return the same value as f?
00:48:10 <hachiya> i know i must have something a bit off..
00:48:17 <sorear> just a bit.
00:48:42 <sorear> a function that delegates *everything* to another function, behaives the same as that function.
00:48:47 <sorear> for instance:
00:48:51 <Korollary> <==> means observationally the two terms must lead to the same normal form
00:48:56 <sorear> (counterexample)
00:49:10 <sorear> > (\x -> (+) x x) 2
00:49:12 <lambdabot>  4
00:49:15 <sorear> > (+) 2
00:49:16 <lambdabot>  Add a type signature
00:49:46 <nmessenger> @type (+) 2
00:49:47 <sorear> the first func uses (+), but is distinguishable from (+), because it does more than just call (+)
00:49:48 <lambdabot> forall a. (Num a) => a -> a
00:50:16 <nmessenger> @type (\x -> (+) x x) 2
00:50:42 <nmessenger> @bot
00:50:46 <Korollary> is dead?
00:50:46 <sorear> dons: yi now has selectable syntaxes - :set ft=haskell, :set ft=none
00:51:32 <nmessenger> show $ typeOf (\x -> (+) x x) 2 = "forall a. (Num a) => a"
00:51:53 <nmessenger> s/typeOf/typeOf $/
00:51:54 <lambdabot> forall a. (Num a) => a
00:51:54 <lambdabot> :)
00:52:02 <Korollary> major lag
00:52:10 <nmessenger> LB you kidder ;)
00:52:16 <xic> i'm having trouble understanding MaybeT
00:52:34 <xic> x :: MaybeT IO ()
00:52:34 <hachiya> ok sorear that helps
00:52:38 <sorear> wow
00:52:41 <xic> x = return Nothing >> return ()
00:52:54 <xic> how come when i runMaybeT x i get Just () and not Nothing?
00:53:14 <sorear> xic: you need to use fail
00:53:26 <sorear> return Nothing :: MaybeT IO (Maybe a)
00:53:35 <sorear> succeeds with value 'Nothing'
00:53:57 <xic> how come with regular Maybe i don't need fail?
00:54:51 <sorear> with regular Maybe: return Nothing >> return ()   returns Just ()  too!
00:54:54 <sjanssen> > (return Nothing >> return ()) :: Maybe ()
00:54:55 <lambdabot>  Just ()
00:55:22 <xic> > (Nothing >> Just ()) :: Maybe ()
00:55:24 <lambdabot>  Nothing
00:55:38 <xic> this is the behaviour i want with MaybeT, but i can't seem to get it
00:56:04 <nmessenger> > (return Nothing >> return (Just ())) :: Maybe (Maybe ()) -- should be Nothing?
00:56:06 <lambdabot>  Just (Just ())
00:56:22 <sorear> xic: replace Nothing with fail
00:56:39 <sorear> xic: just 'Nothing' is a Maybe, not a MaybeT
00:57:04 * nmessenger gets horribly confused
00:57:06 <sorear> you *could* use MaybeT (return Nothing), and it would work ... but fail is shorter and clearer
00:57:15 <allbery_b> return Nothing means Just Nothing
00:58:09 <xic> sorear: cool, MaybeT (return Nothing) seems to work
00:59:02 <xic> hm... apparently that is the definition of fail
00:59:36 <nmessenger> > Nothing >> return (Just ()) :: Maybe (Maybe ()) -- here we are
00:59:38 <lambdabot>  Nothing
01:00:30 <nmessenger> so when (>>) acts directly on a Nothing, it's Nothing, when on another monad, it behaves how that monad defines it
01:00:52 <nmessenger> ?index MaybeT -- in the libs anywhere
01:00:52 <lambdabot> bzzt
01:00:54 <nmessenger> ?
01:01:12 <nmessenger> shoot, I wanted @src MaybeT (>>)
01:02:54 <hachiya> is one nice advantage of haskell that it has a compiler to machine code, unlike ruby?
01:03:17 <sjanssen> yes, compilation is a nice feature
01:03:21 <dibblego> if it is an advantage, it is a relatively small one
01:03:33 <sjanssen> Haskell can beat the pants off Ruby in performance
01:03:34 <dibblego> the language craps all over ruby is a less small one
01:03:42 <Korollary> ruby is at a disadvantage out there. machine code or bytecode.
01:04:14 <nmessenger> It's well known that Ruby performance isn't spectacular, but it's a good language.
01:04:50 <xic> is there any popular language that is slower then ruby?
01:05:06 <nmessenger> I just delight in the cool stuff I've learned while learning Haskell
01:05:09 <hachiya> dibblego: you prefer the language to ruby then?
01:05:17 <hachiya> dibblego: it seems less intuitive, at least at the moment
01:06:22 <sorear> xic: lua
01:06:45 <xic> i think lua might be faster then ruby
01:06:45 <nmessenger> hachiya: do you remember how long it took you to *really* understand destructive update and side-effects?  Those things are so ingrained in most programmers that they feel kinda lost without them.
01:08:02 <dibblego> hachiya, yes, but I was exaggerating a little; I have to put up with Ruby-hype at work - where the language is severely over-stated
01:08:21 <nmessenger> Haskell allows you to play with function definitions that prohibit such things, but there are interesting (and foreign to Joe Random Programmer) ways of introducing them on top of Haskell.
01:09:13 <hachiya> hmm well i'll have to learn more about haskell then, because i don't see how the "destructive update" thing applies
01:09:16 <nmessenger> by "on top of", I mean "using plain-ol' ordinary"
01:09:39 <dibblego> hachiya, destructive update is a property of imperative languages; Haskell is "purely functional" meaning, no updates
01:09:46 <dibblego> hachiya, f(x); x = y; f(x);
01:09:58 <hachiya> ah yes i was reading that in the tutorial... like there is no a := 3
01:09:58 <nmessenger> x = x + 1 -- the old value of x is destroyed, regardless of who else was using it.
01:09:59 <dibblego> the two occurrences of f(x) are *not* equivalent because of x = y (destructive update)
01:10:20 <dibblego> in Haskell, all f(x) are equivalent, because there is no x = y
01:10:25 <hachiya> wow
01:10:31 <hachiya> yeah that is much different a way of thinking
01:10:42 <hachiya> i thought functional languages were like pascal and fortran, without objects
01:10:44 <dibblego> and nmessenger's point is that many people feel lost without x = y
01:10:46 <hachiya> but that is procedural ig uess
01:10:49 <hachiya> and haskell is functional
01:10:53 <hachiya> dibblego: yes i do :)
01:11:07 <dibblego> hachiya, it takes time, but nobody I know yet has gone back :)
01:11:22 <hachiya> don't you miss the encapsulation of objects
01:11:29 <hachiya> it feels like a nice way of organizing things
01:11:33 <dibblego> that's not encapsulation
01:11:34 <nmessenger> do {x <- newIORef 1; print =<< readIORef x; modifyIORef (+1) x; print =<< readIORef x} -- not sure of the exact syntax
01:11:36 <dibblego> it's horrible
01:12:41 <dibblego> pure functional allows you to 'reason' about your code *far* better
01:12:47 <hachiya> hmm
01:12:55 <dibblego> and reasoning is the whole (failed) point of OO in the imperative setting
01:13:03 <nmessenger> hachiya: some people have a different working definition of "functional", but a good one is "pure" or "without side-effects"
01:14:02 <nmessenger> f x = blah, 'blah' is *entirely equivalent* to 'f x', and can be freely substituted back and forth
01:14:08 <dibblego> of course, without x = y, this means you have no loops
01:14:24 <dibblego> it is replaced (corrected?) by recursion
01:14:40 <dibblego> the map function is the canonical example
01:14:43 <nmessenger> but loops can always be replaced by recursion, and are done so in the standard libraries
01:14:49 <sorear> goodnight.
01:14:50 <dibblego> > map (+10) [1..10]
01:14:52 <lambdabot>  [11,12,13,14,15,16,17,18,19,20]
01:14:59 <dibblego> bye sorear
01:15:05 <nmessenger> 'night.
01:16:09 <nmessenger> the substitution thing means you can reason about and transform programs more freely, without side effects to worry about
01:16:39 <nmessenger> The compiler does this furiously, turning naive-looking code into a usually pretty fast equivalent
01:17:09 <hachiya> dibblego: ok i understand that example with map.. how would you explain that line though? how is it recursive?
01:17:17 <nmessenger> @src map
01:17:18 <lambdabot> map _ []     = []
01:17:18 <lambdabot> map f (x:xs) = f x : map f xs
01:17:31 <nmessenger> the second equation uses 'map' recursively
01:17:34 <dibblego> > let mapp _ [] = []; map f (x:xs)
01:17:36 <lambdabot>  Parse error
01:17:43 <dibblego> bleh, didnt know about @src
01:18:00 <xic> hachiya: i suggest you start going through one of the haskell introduction/tutorial articles
01:18:01 <dibblego> hachiya, what language do you know the most?
01:18:12 <hachiya> dibblego: c and ruby
01:18:23 <nmessenger> @learn
01:18:24 <lambdabot> http://www.haskell.org/learning.html
01:18:48 <dibblego> hachiya, have you ever wanted to transform all the elements of a list in a constant manner?
01:18:53 <dibblego> (Ruby has map afaik?)
01:20:22 <nmessenger> quick google turned up the 'collect' function, which looks like 'map'
01:20:22 <dibblego> let f 1 = "one"; f 2 = "two" in map f [1,2,2,2,1,2,1,2,1,1]
01:20:24 <dibblego> > let f 1 = "one"; f 2 = "two" in map f [1,2,2,2,1,2,1,2,1,1]
01:20:25 <lambdabot>  ["one","two","two","two","one","two","one","two","one","one"]
01:21:21 <hachiya> sorry looking at hte learnign page, that's got a lot of sites, awesome
01:21:34 <hachiya> nmessenger: yes collect and map are actually the same in ruby
01:21:37 <dibblego> ok have fun, and ask any time!
01:22:10 <nmessenger> @wiki Haskell_in_5_steps
01:22:11 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
01:22:18 <nmessenger> ^^ is good for absolute starting
01:22:24 <hachiya> awesome, thanks man
01:22:37 <hachiya> just thought it was time to learn another language, to think differently
01:22:48 <xic> haskell is the right choice
01:23:07 <dibblego> what you learn in Haskell can applied to all the less powerful languages
01:23:08 <nmessenger> aye!  It will be painful!  Enjoy it!
01:23:19 <hachiya> as one of the haskell tutorials i started looking at said, why learn different languages if you think the same but they just differ syntactically
01:23:25 <hachiya> that resonated with me
01:23:40 <dibblego> hachiya, the big difference is "pure functional" and "lazy evaluation" - and that is *very* big difference
01:23:51 <nmessenger> it's very easy to write imperative code in lisp, less easy in Haskell
01:24:08 <hachiya> i first thought of looking into it today when i saw an article on a rails blog about a guy who uses rails for the web app but haskell behind the scenes to analayze data because it's faster as it could be compiled
01:24:12 <xic> and the additional big difference is "awesome type system"
01:24:38 <xic> hachiya: where is that article?
01:24:52 * nmessenger saw it on reddit
01:25:09 <hachiya> http://www.dzone.com/rsslinks/ruby_vs_haskell_choose_what_works.html
01:25:12 <lambdabot> Title: Ruby vs. Haskell: Choose what works, http://tinyurl.com/yufnsf
01:25:44 <pstickne> Ruby is nifty.
01:25:55 <hachiya> he also wrote another article on haskell
01:25:58 <hachiya> http://notes-on-haskell.blogspot.com/2007/01/haskell-open-secret.html
01:26:01 <lambdabot> Title: Notes on Haskell: Haskell: the open secret, http://tinyurl.com/3dktxf
01:26:10 <hachiya> heh that's cool, is lambdabot in haskell?
01:26:23 <nmessenger> @where lambdabot
01:26:24 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:26:31 <nmessenger> yep
01:26:48 <nmessenger> @botsnack
01:26:49 <lambdabot> :)
01:29:48 <xic> a year isn't enough to learn haskell
01:30:08 <dons> mm, faster, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ruby
01:30:11 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/veo3w
01:30:17 <nmessenger> I've only been toying with it for a few weeks
01:30:27 <hachiya> does whitespace matter
01:30:35 <xic> hachiya: yes
01:31:09 <nmessenger> hachiya: for lists of declarations or 'do' blocks, you can use whitespace instead of {...;...;...}
01:31:23 <nmessenger> (and most people do)
01:31:37 <dibblego> aka 'the off-side rule'
01:31:44 <csci> Hello, if I have Module A (exporting 1,2,3,...) and Importing B and in B I need A.1 how do I import it. Whenever I try import A, import A(1), ... I get a cycle (obviously ;-))?
01:32:01 <hachiya> ok , well thank you very much for the very friendly introduction guys
01:32:06 <hachiya> i'm going to read through one of these tutorials
01:32:19 <dibblego> csci, A needs B and B needs A?
01:32:41 <csci> dibblego, Quite ;-). A needs B and B needs just one function from A
01:32:42 <nmessenger> hachiya: come back with questions!
01:33:12 <dibblego> csci, I had that once and I had to dick around with a GHC option - I forget the details though sorry (I vaguely recall adding a pragma?)
01:33:22 <csci> dibblego, actually, a constant from A is needed
01:33:30 <allbery_b> push that function into a new module C?
01:33:40 <csci> dibblego, There's no standard way to mess with it?
01:33:58 <csci> allbery_b, Sounds like a hack ;) but if it's not possible otherwise :-/
01:34:06 <dibblego> csci, I don't believe so - but I do think it's scheduled for change in GHC (vague memories)
01:34:07 <allbery_b> there's a .hs-boot hack when all else fails
01:34:18 <allbery_b> see the ghc manual
01:34:35 <csci> dibblego, allbery_b, ok, thanks.
01:34:52 <allbery_b> (if you think mine was a hack, waity until ou see .hs-boot :)
01:35:31 * nmessenger wonders how that 'y' travelled a whole word to the left
01:35:58 <allbery_b> typing blind to a vnc session over an occasionally slow link
01:36:22 <csci> allbery_b, *g* I just created a module Configuration. At least it looks elegant and non-hackish ;-)
01:38:30 <allbery_b> csci: the standard says it should work.  actual Haskell implementations tend not to obey the standard in that regard :/
01:46:16 <csci> allbery_b, As long as we have workarounds we don't need any standards
01:48:28 <Heffalump> 5.7 seems clear on the issue
01:48:53 <Heffalump> "separate compilation of mutually recursive modules may require that imported modules contain additional information so that they may be referenced before they are compiled"
01:49:04 <Heffalump> I'd say that could include making a .hi-boot file
01:49:20 <_roconnor> Where's Oleg when you need him
01:50:09 <_roconnor> I have a inductively defined dependent in Coq.  I bet Oleg can use his magic to get the same results in Haskell.
01:50:22 <_roconnor> inductively defined dependent type
01:51:05 <nmessenger> does Oleg frequent #haskell?
01:51:15 <hpaste>  roconnor annotated "1 hour static lambda-bar-mu-mu-tilde implementation" with "Coq declaration for lambda-bar-mu-mu-tilde" at http://hpaste.org/270#a1
01:51:30 <roconnor> nmessenger: maybe not
01:51:55 <roconnor> I can almost imagine doing it with GADTs
01:52:07 <allbery_b> wouldn't you have to implement IRC in the type system first?
01:52:20 <roconnor> but the vvar constructor doesn't fit
01:52:21 <roconnor> IRC?
01:52:31 <Heffalump> yes, like #haskell
01:53:12 <roconnor> vvar : forall x:X, Value X Xt G (Xt x)
01:53:50 <roconnor> The problem is that you can't use functions to compute a type for a GADT
01:54:05 <roconnor> But maybe with enough type classes magic it can be faked
01:54:22 <roconnor> The function is supposed to be really simple.
01:57:13 * allbery_b was talkingabout summoning Oleg...
01:57:54 * roconnor groans
02:04:04 * roconnor has an idea
02:04:37 * mattam has none
02:06:30 <roconnor> I can try to use the nested tuples pattern to implement a stack of types
02:08:27 * nmessenger wonders if (a,b,c,d) were syntax sugar for (a,(b,(c,d))), if the many tuply functions could be generalized
02:08:59 <allbery_b> what would be the difference between that and lists?
02:09:20 <allbery_b> hm, arbitrarty types I guess
02:09:25 <allbery_b> but that sounds like trouble
02:09:34 <nmessenger> [Int] vs. (Int,(Char,String)), i.e. arbitrary types + fixed size
02:10:35 <goltrpoat> but you can do that with existential quantifiers and lists, no?
02:10:39 * allbery_b suspects that syntactic sugar alone would be insufficient, and making it sufficient would turn it into a list
02:11:12 <goltrpoat> oh fixed size
02:11:27 <goltrpoat> more type hackery there (eg the faking it paper)
02:11:35 <nmessenger> technically there would be only one product type: the pair.
02:12:01 * allbery_b is, however, (a) not especially smart about types and (b) not thinking too well due to being kept awake by bronchitis (and fuzzed out by medications)...
02:12:10 <nmessenger> (,,,) is semantically convertible to and from (,(,)), so there shouldn't be any problems
02:12:47 <nmessenger> I *seriously* doubt that I'm the only one who's though of this
02:13:25 <pstickne> nmessenger, looks like of like cons-lists in lisp
02:13:42 <pstickne> s/like/kind/
02:16:05 <nmessenger> though we could rename (a,b) to a * b and go all the way to ML ;-)
02:16:30 <goltrpoat> nm/allbery/roconnor:  what are you guys talking about?
02:17:10 * allbery_b just babbling...
02:17:19 <nmessenger> (:) = cons, type List a = Nil | Cons a (List a)
02:19:10 <nmessenger> it's type-level consing!  () type <=> [] value, and (a,b) type <=> a : b value
02:19:37 <ivanm> Hey everyone, I'm trying to split my program up into modules
02:19:41 <nmessenger> consing together type instead of values
02:19:52 <nmessenger> types*
02:19:54 <allbery_b> @get-oleg :)
02:19:55 <lambdabot> Unknown command, try @list
02:19:57 <ivanm> To define a module, I just have to have "module <blah> where" up the top, don't I?
02:20:11 <allbery_b> where <blah> is in title case
02:20:26 <nmessenger> ivanm: yes, if you leave it out, it defaults to "module Main(main) where"
02:20:30 <ivanm> first letter is upper case, yeah
02:20:43 <ivanm> What do I have to do then to compile the module?
02:20:58 <ivanm> ghc complained about undefined references :s
02:21:09 <goltrpoat> nmessenger:  data List a = ... you mean?
02:21:16 <ivanm> But all I did was remove my main function and add the module line up the top
02:21:18 <goltrpoat> and isn't that just a plain homogenous list
02:21:19 <allbery_b> and the compiler searches for modules assuming the filename is related to the module name, so you want mpodule Foo to live in Foo.hs
02:21:21 <nmessenger> goltrpoat: oops, of course
02:21:31 <nmessenger> ivanm: does it work in ghci?
02:21:35 <roconnor> omg, it worked
02:21:41 <ivanm> yeah, it does
02:21:53 <roconnor> the GADT inference engine is pretty smart
02:22:06 <ivanm> unless its because I have other files floating around from when I compiled it to an executable?
02:22:09 <nmessenger> ?paste it!
02:22:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:22:26 <ivanm> nmessenger: you mean me?
02:22:36 <nmessenger> @roconnor
02:22:36 <allbery_b> you sometimes need to remove .hi files if you make radical changes
02:22:36 <lambdabot> Unknown command, try @list
02:22:36 <goltrpoat> GADTs are a beautiful thing.  i'm just now starting to realize how ridiculously powerful that is.
02:23:03 <Heffalump> except Oleg seems to think they are pointless
02:23:37 <allbery_b> I thought he said "they're great, but not necessary for what you're doing"
02:23:42 <ivanm> allbery_b: tried that, its complaining about main functions in libHSrts, but I'm not importing that library in :s
02:24:01 <allbery_b> hrm.  your compiler is confused
02:24:09 <allbery_b> libHSrts is the ghc runtime
02:24:22 <goltrpoat> heffalump:  pointless how?
02:24:24 <ivanm> The error message is: undefined reference to `__stginit_ZCMain'
02:24:24 <hpaste>  roconnor annotated "1 hour static lambda-bar-mu-mu-tilde implementation" with "implemented using GADT" at http://hpaste.org/270#a2
02:24:31 <allbery_b> ah
02:24:41 <Heffalump> well, he keeps showing ways of doing the same things without them
02:24:42 <allbery_b> use -c to compile without linking
02:24:51 <allbery_b> (produces a .hi file and a .o file)
02:25:23 <ivanm> allbery_b: thanks!  That worked!!!
02:25:44 <allbery_b> if you omit .c, ghc assumes you gave it a complete program and tries to link it all together as such; if you don't have a module Mail then it'll produce that error
02:25:47 <goltrpoat> heffalump:  oh.  don't you end up having to replace data constructors with type constructors, and GADT-style constraints on the former with constraints on the latter though?
02:25:47 <ivanm> So, when I define my main module, then I just put them both on the same line to get them to automatically link?
02:25:52 <allbery_b> er, omit -c
02:25:58 <allbery_b> yes
02:26:01 <ivanm> yeah, i meant that
02:26:15 <allbery_b> or compile them separately and pass only the .o files to ghc to link
02:26:30 <Heffalump> goltrpoat: I don't know, I didn't read it. It was just an off-hand remark based on what his emails say.
02:26:35 <Heffalump> s/read it/read the code/
02:26:35 <goltrpoat> heffalump:  i'm guessing the latter is more general, but seems like swatting a fly with an anti-aircraft cannon in the cases where i've found them to be particularly cool.
02:26:38 <ivanm> OK, I've been mainly using Java or interpreted languages mainly, and I was so used to doing "javac *.java" that I forgot about linking
02:26:44 <goltrpoat> ah.
02:26:49 <Heffalump> and yeah, that sounds very plausible
02:26:54 <Heffalump> and I like GADTs :-)
02:27:03 <allbery_b> java doesn't really link, it sucks in class files as it needs them
02:27:13 <pejo> Heffalump, is there a consensus whether they're needed or not?
02:27:17 <allbery_b> er, .class
02:27:25 * allbery_b as usual can't type
02:27:35 <allbery_b> worse when tired & fuzzy...
02:27:42 <Heffalump> pejo: no idea. As I said, I like them. And I've seen quite a few distinct cool uses of them.
02:27:46 <ivanm> class, .class, same diff
02:28:33 <Heffalump> e.g. the canonical example of type-safe interpreters, the stuff Henrik Nilsson did to optimise Yampa, the prototype darcs use for enforcing patch ordering
02:28:34 <pejo> Heffalump, nods, lots of people seem to like them. Some give the impression that it's the best thing since sliced bread. Guess one should bite the bullet and understand them.
02:29:04 <pejo> Heffalump, wasn't Nilsson's optimisation in combination with rewrite rules in ghc?
02:29:06 <nmessenger> i'm guessing the latter is more general, but
02:29:07 <nmessenger>                    seems like swatting a fly with an anti-aircraft cannon in
02:29:14 <Heffalump> pejo: I can't remember
02:29:16 <nmessenger> oops
02:29:16 * allbery_b thinks the point is that GADTs make things easier, bt are only *necessary* in a relatively small number of cases
02:29:35 <allbery_b> and, well, that does seem rather Oleg-y :)
02:29:39 <Heffalump> the point was that without GADTs he couldn't express the thing that could be optimised in a sufficiently precise manner
02:30:00 <Heffalump> they certainly are very convenient and elegant
02:30:17 <allbery_b> (but since we're not all Oleg...)
02:30:20 <Heffalump> and I'm sure that any alternative encoding in H98 or whatever would be quite hard to actually use
02:30:25 <goltrpoat> one nice use i ran into recently was modelling an imperative compiler backend in a toy project.  at some point, i realized i could use dummy classes to specify "readable" or "writable" memory (eg, immediate values aren't writable, but are readable, certain parts of the real world interface might be writable but not readable, etc), *and* have typed instructions at the same time
02:30:30 <nmessenger> ?remember goltrpoat [on GADTs] i'm guessing the latter is more general, but seems like swatting a fly with an anti-aircraft cannon in the cases where i've found them to be particularly cool.
02:30:31 <lambdabot> Done.
02:30:36 <goltrpoat> and the whole thing is defined in a single line
02:30:51 <xic> goltrpoat: i did something similar with GADT
02:31:07 <pejo> allbery_b, actually that was what I was looking for - when are they necessary. Rather unspecific question from me though.
02:31:19 * allbery_b is the wrong one to ask about that
02:31:30 <goltrpoat> in retrospect, it's probably the first thing that comes to mind when you say GADT, but i just thought that was cool as hell.
02:31:57 <pejo> Heffalump, well, some progress in the type system since H98 have occured.
02:32:06 <allbery_b> I'm not really all that type-clueful, and in fact have yet to run into anything in my own random hacking that requires them (or advanced non-GADT hackery)
02:32:40 <allbery_b> I just read Oleg's messages and try to understand (and usually fail :)
02:33:03 <xic> the oldest post of my devlog, where i make a gameboy emulator in haskell describes how i use GADT: http://www.mutantlemon.com/omegagb/devlog/
02:33:05 <allbery_b> <-- bear of very little brain
02:33:05 <lambdabot> Title: OmegaGB Devlog
02:34:10 <goltrpoat> ooh.  cool project idea
02:34:49 <xic> goltrpoat: i got to the point where i was just able to emulate a few games and show their title animations
02:34:52 <nmessenger> s/cool/extremely cool/
02:34:55 <xic> goltrpoat: i really should finish this project someday
02:35:41 <goltrpoat> nice
02:38:49 * goltrpoat carefully digs the sudden desire to write a SNES emu out of his ear with a fork.
02:38:55 <goltrpoat> better now.
02:39:40 <nornagon> :D
02:40:32 <xic> well, the hurdle that caused me to put the project on hold was performance. i just couldn't get it to run fast enough. i imagine that doing SNES in haskell would be quite a challenge
02:43:07 <Saizan> is there a deque implementation in haskell?
02:43:14 <goltrpoat> well..  yeah.  but good lord does that sound fun.
02:43:40 <xic> gameboy was plenty fun for me :)
02:44:20 <allbery_b> Saizan: Data.Sequence?  (may require 6.6)
02:44:52 <goltrpoat> well.. ive programmed on the snes a bit, but not on the gameboy, so it'd be mostly the nostalgia factor.  the snes was one weird architecture.
02:45:34 <xic> the reason i went with gameboy and not NES, is because gameboy is much simpler, NES has dozens of different mappers and shit
02:45:51 <goltrpoat> -nod-
02:46:00 <xic> but NES has a slower cpu and should be much easier to get decent performance
02:46:12 <goltrpoat> so what's the performance bottleneck in your project?
02:47:00 <xic> goltrpoat: i don't remember the details, it was a year ago. i do remember that i re-implemented everything in C, because i wanted to compare haskell vs c speed
02:47:37 <AStorm> xic, well, haskell will be slower than that currently... nothing new
02:47:39 <goltrpoat> a good friend of mine wrote a semi-popular gba emulator way way back when, so he'd know more about it than i do.  he's basically c/c++ only though.
02:48:24 <xic> AStorm: yeah, but i wanted to know just how much slower, to see if i even had a chance. i was hoping that my c version would be 10-times faster then realtime, and then i would figure "ok, if my haskell is 10 times slower then c, then i'll still be good"
02:48:39 <AStorm> Yes, should work.
02:48:44 <goltrpoat> xic:  well..  there's quite a number of ways to go wrong even on the rendering side, so i was just curious if there was anything in particular
02:48:49 <AStorm> If you use some strictness here and there :>
02:49:14 <AStorm> The most important is the GPU emulation and CPU emulation next.
02:49:14 <ivanm> nmessenger: you were helping me out a couple of nights ago by giving me examples of how to read an Int value from the command line, but I can't work out how to extract the int value and use it :s
02:49:29 <goltrpoat> it seems like the sort of thing where haskell should be comparable to c with enough effort
02:49:31 <xic> AStorm: i tried adding strictness everywhere, and eventually moved to IOUArray and IORef for everything, and was still too slow
02:49:48 <AStorm> xic, maybe some "design" problem?
02:50:06 <AStorm> or your timers were broken :>
02:50:19 <xic> AStorm: yes, my rendering algorithm could have been highly optimized, but i think cpu emulation speed was still a major bottleneck
02:50:48 <xic> ghc just didn't seem to be optimizing bit fiddling and integer math fast enough
02:51:16 <allbery_b> extract from what?  read will get the Int from a String; if you mean IO, you're doing it wrong (you can't, or at least shouldn't, extract stuff from IO; you lift stuff into IO)
02:51:58 <AStorm> xic, wrong structures probably
02:51:59 <goltrpoat> switching to ByteString should help, no?  otherwise you're allocating ten bajillion gazillobytes per instruction.
02:52:01 <allbery_b> e.g. do { n <- readLn; return (somefunc n) } -- and somefunc can be written purely
02:52:13 <allbery_b> but it needs to be invoked within IO
02:52:23 <AStorm> xic, should have used something of Bits then
02:52:35 <AStorm> ?src Bits
02:52:36 <lambdabot> Source not found. Are you on drugs?
02:52:39 <AStorm> :P
02:52:48 <AStorm> Abusive as ever.
02:52:51 <AStorm> ?type Bits
02:52:53 <lambdabot> Not in scope: data constructor `Bits'
02:53:04 <AStorm> It's a class, dammit :>
02:53:07 <goltrpoat> :t (.&.)
02:53:08 <allbery_b> ?source Data.Bits
02:53:08 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
02:53:09 <lambdabot> forall a. (Bits a) => a -> a -> a
02:53:30 <AStorm> ?instances Data.Bits
02:53:31 <lambdabot> Couldn't find class `Data.Bits'. Try @instances-importing
02:53:40 <xic> AStorm: here was my initial implementation: http://www.mutantlemon.com/omegagb/devlog/snapshots/20060414/Cpu.hs
02:53:42 <lambdabot> http://tinyurl.com/29lcgk
02:53:50 <xic> AStorm: i even used Data.Bits
02:53:55 <allbery_b> ?instances-importing Data.Bits Bits
02:53:56 <lambdabot> Int, Integer
02:54:26 <allbery_b> ?instances-importing Data.Bits Data.Word Bits
02:54:28 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
02:54:40 <AStorm> xic, executeInstruction is too long
02:55:10 <goltrpoat> astorm: ?
02:55:26 <xic> AStorm: yeah, i wrote that code thinking only of code clarity. not performance
02:55:43 <nmessenger> AStorm: take it up with Nintendo :P
02:55:44 <goltrpoat> should it matter
02:55:56 <AStorm> Also...
02:56:06 <AStorm> maybe add: where s = splitNibbles n'
02:56:09 <goltrpoat> hopefully something that big will get turned into a jump table -- it definitely will if you compile down to C and it turns into a switch statement or a bunch of nested ifs
02:56:14 <AStorm> Or even cache the data :>
02:56:21 <nmessenger> ivanm: what's your code?
02:56:26 <AStorm> Should be, -ddump-cmm
02:57:01 <xic> goltrpoat: i was also hoping that the mcti function would be totally inlined away
02:57:01 <goltrpoat> (definitely will, as in, any C compiler in its right mind will turn a large switch statement into a jump table)
02:57:04 <allbery_b> hm, Z80
02:57:11 <AStorm> xic, swapNibbles is slow
02:57:20 <ivanm> main = do; [sizeStr] <- getArgs ; [(n,s):ss] <- reads sizeStr :: [(Int,String)] ; ..... do some stuff using n as an Int
02:57:20 <AStorm> Use a true bit shift of Data.Bits
02:57:44 <nmessenger> @ty reads
02:57:46 <lambdabot> forall a. (Read a) => ReadS a
02:57:54 <xic> AStorm: you mean shiftL and shiftR?
02:58:09 <nmessenger> let ((n,_):_) = reads sizeStr
02:58:14 <AStorm> Yes.
02:58:15 <nmessenger> it's pure
02:58:18 <xic> AStorm: i am using those
02:58:26 <AStorm> But just not there, right?
02:58:41 <AStorm> 2 shifts and sum instead of rotating :P
02:58:47 <goltrpoat> i suspect it's more of an issue with the fact that Instruction is a relatively large type, and a stream of those is doing unpleasant things to the cache
02:58:48 <nmessenger> though if you're just failing a pattern match on bad format, you should use 'read'
02:58:52 <ivanm> ummm...... I haven't used any let expressions and I've tried to avoid them in favour of where.... what's the syntax for let?
02:58:59 <xic> AStorm: where do you see that?
02:59:07 <goltrpoat> if you were decoding it byte by byte (and using ByteString accordingly), i suspect you'd see a major performance improvement
02:59:16 <AStorm> xic, swapNibbles
02:59:27 <AStorm> Should be using what I said.
02:59:37 <nmessenger> do {[sizeStr] <- getArgs; let size = read sizeStr; ...}
02:59:46 <xic> AStorm: well, even so, swapNibbles is barely used
02:59:53 <AStorm> No, quite a lot
03:00:16 <ivanm> then indent everything after the let?
03:00:44 <nmessenger> all statements belonging to the 'do' should start on the same column
03:01:10 <ivanm> So what is the region in which the let works? everything after it in the same functioin?
03:01:11 <nmessenger> all *names* being bound with let should start on the same (further indented) column
03:01:11 <goltrpoat> astorm:  ?  swapNibbles is only used in SWAP and friends
03:01:17 <ivanm> *scope, not region
03:01:27 <AStorm> and SWAP is used for blitting!
03:01:28 <nmessenger> ivanm: for a 'do' block, yes
03:01:40 <AStorm> Check profiling maybe?
03:02:02 <ivanm> nmessenger: that worked, thanks!!
03:02:04 <goltrpoat> oh, crap.  that suddenly makes sense.
03:02:26 <ivanm> One other question: what happens if I try and pass it more than value at the command prompt?
03:02:33 <goltrpoat> although i still stand by my Instruction bit.
03:02:51 <nmessenger> ivanm: the [sizeStr] pattern will fail.
03:03:00 <ivanm> should I do something like (sizeStr:_) instead?
03:03:09 <xic> AStorm: one of these days i'll resume work on the project, and put everything in a public darcs repository and hope for contributions :)
03:03:28 <nmessenger> ivanm: you could do {strs <- getArgs; let sizes = map read strs; ...}
03:03:36 <goltrpoat> xic:  that'd be cool.
03:04:05 <xic> but i am so proud of this animation :) http://img189.imageshack.us/img189/7697/omegagb00068nv.gif
03:04:19 <nmessenger> [sizeStr] = (sizeStr:[]), it's just a cons pattern
03:04:23 <goltrpoat> !!
03:04:24 <ivanm> nmessenger: yeah, but I only want one value.... I meant in terms of stopping the program from crashing in case of bad input (even though I'm likely to be the only one using it)
03:04:35 <goltrpoat> hehe
03:05:36 <nmessenger> ?let readMaybe s = case reads s of {[(x,_)] -> Just x; _ -> Nothing}
03:05:38 <lambdabot> Defined.
03:06:02 <nmessenger> > map readMaybe ["1","blah","2.0","5","foo"] :: [Int]
03:06:03 <lambdabot>  Couldn't match `Int' against `Maybe a'
03:06:10 <nmessenger> > map readMaybe ["1","blah","2.0","5","foo"] :: [Maybe Int]
03:06:12 <lambdabot>  [Just 1,Nothing,Nothing,Just 5,Nothing]
03:06:25 <nmessenger> > catMaybes $ map readMaybe ["1","blah","2.0","5","foo"] :: [Int]
03:06:27 <lambdabot>  [1,5]
03:06:46 <ivanm> :t catMaybes
03:06:48 <lambdabot> forall a. [Maybe a] -> [a]
03:07:10 <nmessenger> @index catMaybes
03:07:10 <lambdabot> Data.Maybe
03:07:52 <nmessenger> readMaybe "5" :: Maybe Float
03:07:56 <nmessenger> > readMaybe "5" :: Maybe Float
03:07:58 <lambdabot>  Just 5.0
03:08:09 <nmessenger> > readMaybe "blah!" :: Maybe Char
03:08:11 <lambdabot>  Nothing
03:08:12 <ivanm> :t getArgs
03:08:14 <lambdabot> Not in scope: `getArgs'
03:08:22 <nmessenger> @hoogle getArgs
03:08:23 <lambdabot> System.getArgs :: IO [String]
03:08:36 <nmessenger> @index getArgs
03:08:37 <lambdabot> System.Environment
03:08:51 <nmessenger> (I usually import System.Environment)
03:09:20 <ivanm> @hoogle reads
03:09:20 <lambdabot> Prelude.reads :: Read a => ReadS a
03:09:21 <lambdabot> Prelude.ReadS :: type ReadS a
03:09:21 <lambdabot> Prelude.readsPrec :: Read a => Int -> ReadS a
03:09:28 <nmessenger> @src ReadS
03:09:29 <lambdabot> Source not found. Take a stress pill and think things over.
03:09:33 <ivanm> :t reads
03:09:35 <lambdabot> forall a. (Read a) => ReadS a
03:09:50 <nmessenger> type ReadS a = String -> [(a, String)]
03:10:03 <ivanm> OK, that's what I was looking for ;)
03:10:31 <nmessenger> @type reads "blah!" -- hence the following
03:10:33 <lambdabot> forall a. (Read a) => [(a, String)]
03:10:49 <ivanm> So, if I used your readMaybe code, I'd then do catMaybe and take the head?
03:11:06 <nmessenger> if you just wanted the first number that parsed correctly ;)
03:11:31 <ivanm> Yep!
03:11:40 <AStorm> lambdabot, why are you so abusive?
03:11:45 <ivanm> @src readMaybe
03:11:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:12:01 <nmessenger>  @src doesn't know @let names
03:12:16 <AStorm> @src lambdabot
03:12:16 <ivanm> Ahhhh
03:12:16 <lambdabot> Source not found. My mind is going. I can feel it.
03:12:17 <goltrpoat> so uh, half-baked thought.  partial interpreters are useful.  what about partial compilers?  say a backend that produces compiled, platform-specific code, paired up with a list of associations between input variables and memory locations, and the bootstrap code takes a list of associations and moves it into the specified spots
03:12:18 * AStorm ducks
03:12:36 <ivanm> OK, I'll look it up manually through the postings then ;)
03:12:56 <allbery_b> goltrpoat: sounds like ld.so to me:)
03:13:03 <AStorm> @undo readMaybes
03:13:03 <lambdabot> readMaybes
03:13:07 <ivanm> Ohhh..... is the code for lambdabot in a @let expression? ;)
03:13:10 <AStorm> Hmm.. too smart :P
03:13:12 <allbery_b> heh
03:13:26 <nmessenger> ivanm: that'd be one monster of an @let
03:13:29 <AStorm> @undo L.readMaybes
03:13:30 <lambdabot> L.readMaybes
03:13:36 <AStorm> @src L.readMaybes
03:13:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:13:54 <ivanm> yeah, I realised that ;)
03:14:04 <AStorm> Give her a pill, or something...
03:14:16 <goltrpoat> allbery:  well yeah, it's just late binding, on the surface.  i was thinking with uniqueness typing, you get a rather quick and dirty way of compiling functional code to imperative code, though.
03:14:26 <goltrpoat> and the composability seems useful.
03:14:44 <goltrpoat> and if any of futamura's stuff applies, that's probably useful too, heh.  not sure how it applies though.
03:14:44 <ivanm> Out of curiosity, what would the biggest (in terms of number of lines of source) project in haskell be (with the exception of ghc)?
03:14:50 <nmessenger> @vote cheeky-off YES
03:14:51 <lambdabot> "YES" is not currently a candidate in this poll
03:15:03 <nmessenger> @vote cheeky-off Yes
03:15:03 <lambdabot> voted on "Yes"
03:15:14 <xic> ivanm: HXT is pretty big i think
03:15:27 <allbery_b> HAppS?
03:15:38 <goltrpoat> (i just say uniqueness typing because i can wrap my brain around how that would work, a bit easier)
03:15:39 <allbery_b> darcs?
03:16:04 <Heffalump> pugs?
03:16:16 * Heffalump dunno at all
03:16:21 <pejo> goltrpoat, is partial compilers the same as partial computation? If so, Futamura has patented it. ;)
03:17:03 <ivanm> :google HXT
03:17:08 <goltrpoat> pejo:  well, i was actually just curious if it sounded as useful as partial interpreters do in futamura's stuff
03:17:12 <ivanm> @google HXT
03:17:14 <lambdabot> http://filext.com/detaillist.php?extdetail=HXT
03:17:14 <lambdabot> Title: File Extension Details for .HXT
03:17:27 <goltrpoat> pejo:  you ARE joking about the patented bit, right
03:17:27 <goltrpoat> hehe
03:17:31 <ivanm> That wasn't very helpful :s
03:17:43 <pejo> goltrpoat, upon re-reading your first comment, I'm now convinced that I don't understand what you mean.
03:17:45 <allbery_b> @go HXT Haskell
03:17:48 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
03:17:48 <lambdabot> Title: Haskell XML Toolbox 7.1
03:18:05 <ivanm> Ahhh.... so _that's_ what HXT is!
03:18:17 <pejo> goltrpoat, no, look for articles by Glück and Futamura about WSDFU, they contain references to the patents.
03:18:27 <goltrpoat> oh, nuts.
03:18:45 <AStorm> @vote cheeky-off yes
03:18:46 <lambdabot> "yes" is not currently a candidate in this poll
03:18:49 <AStorm> @vote cheeky-off Yes
03:18:50 <lambdabot> voted on "Yes"
03:18:51 <pejo> goltrpoat, but as I said, I don't understand what you initially said, so it might be something completely different.
03:19:15 <nmessenger> @poll-results cheeky-off
03:19:15 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=3, Yes=16
03:19:21 <dcoutts> calvins_, the glade named signal handler thing only works for C. You've got to get the widget by name and attach the handler. See the glade demos included with gtk2hs, eg the ProfileViewer has a quit menu item.
03:19:38 * nmessenger wants to vote for the CowboyNeal thing :D
03:20:16 <Saizan> ?where HXT
03:20:17 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
03:20:23 * nmessenger checks if you can vote more than once
03:20:25 <AStorm> @vote cheeky-off MakeItAbuseCowboyNeal
03:20:25 <lambdabot> voted on "MakeItAbuseCowboyNeal"
03:20:34 <nmessenger> @poll-results cheeky-off
03:20:35 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=1, AddFlag=0, No=3, Yes=16
03:20:39 <nmessenger> yep
03:20:40 <AStorm> :P
03:21:26 <dcoutts> siti, what gnome bindings do you want in particular?
03:21:43 <ivanm> @index catMaybe
03:21:44 <lambdabot> bzzt
03:21:54 <siti> I don't know yet, me and a friend are writing a gtk app
03:22:05 <siti> and it might be useful to have dbus/avahi and other things
03:22:08 <siti> we'll see...
03:22:11 <allbery_b> @index catMaybes
03:22:11 <lambdabot> Data.Maybe
03:22:39 <goltrpoat> pejo:  alrighty.  i'm not fully sure if i understand what i mean yet, this is sort of off the top of my head.  say we have a type, CodeSnippet, that takes some set of inputs, executes some number of instructions, and produces some output.  we can do weird things with that, like make CodeSnippet an instance of Num:  a + b composes the two sets of instructions, matches inputs to outputs, assigns registers or memory to temporaries, a
03:22:47 <ivanm> thanks allbery_b! Don't you _love_ typos ;)
03:23:05 * allbery_b world class when it comes to typos :)
03:23:08 <dcoutts> @whre hdbus
03:23:08 <lambdabot> I know nothing about hdbus.
03:23:18 <dcoutts> @where+ hdbus http://neugierig.org/software/hdbus/
03:23:18 <lambdabot> Done.
03:23:20 <dcoutts> @whre hdbus
03:23:21 <lambdabot> http://neugierig.org/software/hdbus/
03:23:28 <dcoutts> siti, ^^
03:23:32 <ivanm> @hoogle case
03:23:32 <siti> yeah, but it looked rather in progress :P
03:23:33 <lambdabot> Prelude.case :: keyword
03:23:33 <lambdabot> Language.Haskell.TH.caseE :: ExpQ -> [MatchQ] -> ExpQ
03:23:33 <lambdabot> Test.HUnit.Base.cases :: Counts -> Int
03:23:40 <ivanm> @index case
03:23:41 <lambdabot> bzzt
03:23:41 <pejo> goltrpoat, it cut your line right after "memory to temporaries, a".
03:23:41 <goltrpoat> pejo:  if we have a+b, we can define (a+) -- it's the process that, when given a b, does the matching/coloring/peephole/SSA/etc magic from earlier.
03:23:44 <nmessenger>  @hoogle is good for when you're not sure of the name
03:23:46 <goltrpoat> doh.
03:23:51 <goltrpoat> ... matches inputs to outputs, assigns registers or memory to temporaries, and possibly does some peephole and SSA on the result.
03:24:16 <ivanm> so how do I get a link to the docs on a particular function/keyword (i.e. case)?
03:24:56 <nmessenger> first @index to find its module, then @docs ThatModule
03:25:07 <nmessenger> @docs Data.Bits
03:25:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
03:25:26 <allbery_b> for keywords you would need
03:25:29 <allbery_b> @where report
03:25:30 <lambdabot> http://www.haskell.org/onlinereport/
03:25:49 <pejo> goltrpoat, are you trying to design a one-pass compiler from some functional language -> optimized assembly?
03:26:18 <ivanm> Thanks!
03:26:19 <goltrpoat> pejo:  so then the idea is that if we continue defining operations on CodeSnippet in that manner, we end up with a single CodeSnippet in the end.  it consists of three things:  memory mapped inputs, platform-specific assembly, and memory-mapped outputs.
03:26:29 <goltrpoat> pejo:  not quite
03:27:11 <goltrpoat> pejo:  well, close.  i'm trying to see if there's anything interesting that falls out of having these composable compiler outputs that you can apply the usual greedy algorithms to on a small scale
03:27:16 <ivanm> So is case similar to a guarded function?
03:27:39 <xerox> ivanm: yep.
03:28:14 <ivanm> nmessenger: so for your readMaybe function, I could just as easily code it as a pattern-matching function?
03:28:20 <nmessenger> yep
03:28:43 <dcoutts> siti, yeah, I guess so
03:28:47 <nmessenger> er, you'd have to pattern-match the result of 'reads x'
03:28:55 <goltrpoat> pejo:  it's not necessarily one pass, since we're talking on operating on chunks of native code, really.  it's more like a way to formalize a backend, really.
03:29:00 <ivanm> Yeah, I just worked that out myself :s
03:29:11 <nmessenger> aux (reads x) where aux ...
03:29:11 <ivanm> so either using a case or a guarded function with a let/where
03:29:15 <goltrpoat> one too many "reallys" in there, really.
03:29:25 <nmessenger> really?
03:29:29 <goltrpoat> really.
03:29:36 <ivanm> I think I'll stick with your case form, nmessenger
03:29:36 <nmessenger> NO WAI!
03:30:47 <allbery_b> ivanm: if you check the report you'll find that pattern matching gets turned into case anyway
03:30:53 * nmessenger has no idea why he thinks that's still funny, but he does
03:31:29 <ivanm> allbery_b: yeah, but pattern matching is easier to read, IMHO
03:31:38 <MarcWebe2> When using foreign import "header.h func" <name> :: <haskell type> ghc doesn't even look for header.h. Is this the case anytime? Did I miss something?
03:32:11 <nmessenger> ivanm: you do know that 'case x of {...}' can use the layout rule?
03:32:13 <allbery_b> did you use hsc2hs?
03:32:25 <ivanm> nmessenger: the layout rule?
03:32:27 <goltrpoat> pejo:  actually, scratch the one-pass thing entirely.  what sounds more interesting is making it a backend for like.. even a TIM.  replacing the built-in types, essentially.
03:32:31 <ivanm> as in indentation?
03:32:35 <nmessenger> yeah
03:32:49 <ivanm> I'm trying that now, but it keeps complaining about the "->"
03:33:19 <ivanm> In particular, it doesn't like the line "_ -> Nothing"
03:33:22 <goltrpoat> so a run of the interpreter produces compiled code.  potentially an infinite amount of compiled code, but eh.  technicalities.
03:33:25 <nmessenger> ?paste ivanm, it's probably something simple
03:33:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:33:50 <pejo> goltrpoat, oh. That's just the old halting problem. ;)
03:33:54 <ivanm> ummm.... hpaste seems to be down :s
03:33:55 <nmessenger> does the second-line '_' line up with the first-line '['?
03:34:01 <nmessenger> o.O
03:34:20 <ivanm> No, its up... firefox requires the "www." part in the URL
03:34:31 <goltrpoat> pejo:  "oh, that old thing?"
03:34:33 <nmessenger> bigger o.O
03:34:40 <MarcWebe2> allbery_b: No.
03:34:49 <allbery_b> works for me without the www
03:35:02 <nmessenger> ivanm: works on my FF, maybe a DNS burp?
03:35:26 <allbery_b> ghc doesn't understand that stuff directly.  you write FFI stuff in a .hsc file (instead of .hs) and run hsc2hs to convert it
03:35:34 <ivanm> nmessenger: yeah, the "_" was indented by an extra space :s
03:35:35 <MarcWebe2> I think firefox does try with and without, doesn't it? The same way as it tries /index.htm /index.html /start.... doesn't it?
03:35:52 <allbery_b> mope
03:35:55 <allbery_b> er, nope
03:35:58 <goltrpoat> one would hope not
03:36:00 <allbery_b> web server does that stuff
03:36:01 <nmessenger> MarcWebe2: the index.htm is server-side I thought
03:36:02 <MarcWebe2> allbery_b: It did compile fine ;)
03:36:06 <ivanm> and I don't know why ff needed the www... and it doesn't seem to want to get a new paste up
03:36:22 <ivanm> Actually, I can't even view old pastes :s
03:36:22 <pejo> MarcWebe, it's usually the webserver that gives the right file for index if the browser requests whatever.com/.
03:36:49 <MarcWebe2> pejo: Thanks
03:37:05 <allbery_b> firefox tries www in limited cases when what you feed it isn't a full hostname, but if you give it something with a dot it takes it as is
03:37:06 <ivanm> nmessenger: must of been a cache problem: I cleared it and ff worked fine again
03:37:45 <allbery_b> the index.htm etc. is definitely server-side
03:38:25 <allbery_b> IIRC Apache calls it WelcomeFile or something similar
03:38:36 <nmessenger> the browser just sends a 'GET / HTTP/1.0' or something
03:38:53 <nmessenger> DirectoryIndex if I recall
03:39:05 <allbery_b> hm, probably
03:39:17 <allbery_b> tghere's a bunch f weird stuff, welcomefile probably appends to the index
03:39:37 <allbery_b> sometimes used to tack a README onto a generated index (directory listng)
03:39:52 <Saizan> however firefox tries adding www. if it can't find a domain.ext
03:40:01 * allbery_b getting even fuzzier, waiting out drugs before trying the sleep thing yet again :/
03:40:20 <nmessenger> @google no-www
03:40:21 <lambdabot> http://no-www.org/
03:40:22 <lambdabot> Title: www. is deprecated.
03:40:29 <ivanm> saizan: well, it wasn't for me.  Who knows, maybe I've got too many extensions ;)
03:40:36 <goltrpoat> actually.  crap.  i guess this might end up as just a trivial improvement on the naive peephole scheme.
03:41:07 <nmessenger> ivanm: does your layout-using code work now?
03:41:26 <ivanm> yep!!!
03:41:28 <goltrpoat> i do feel this unnatural desire to put algebraic structures on chunks of assembly though.
03:41:46 <ivanm> except that when I try testing it maliciously in ghci using :main, it doesn't seem to like it :s
03:41:58 <nmessenger> ?remember goltrpoat i do feel this unnatural desire to put algebraic structures on chunks of assembly though.
03:41:59 <lambdabot> Done.
03:42:03 <goltrpoat> haha
03:42:12 <nmessenger> you're on a roll :)
03:42:30 <wilx> ?dice
03:42:31 <lambdabot> unexpected end of input: expecting number
03:42:37 <wilx> ?dice 1d6
03:42:37 <lambdabot> 1d6 => 4
03:42:51 <nmessenger> c'mon twenty!
03:42:54 <nmessenger> @dice 1d20
03:42:55 <lambdabot> 1d20 => 1
03:42:58 <wilx> Hahahaha.
03:43:00 <nmessenger> damnit!
03:43:01 <nornagon> @ghc
03:43:02 <lambdabot> ghc says: Can't reify a non-Haskell-98 data constructor
03:43:17 <nornagon> CRITICAL FAIL
03:44:40 * nmessenger sulks over his one.
03:47:26 <MarcWebe2> allbery_b: It does compile unless sepecifing -keep-hc-file withoun -I option pointing to my header file ..
03:47:56 <nmessenger> ivanm: paste!
03:50:34 <goltrpoat> that whole "why do we still use C" thread on reddit just baffles me.  the last time i was on a C project was in 2000-2001, and just about everyone involved with it, sans Babbage era leads, was complaining about the fact that we weren't doing it in C++
03:51:18 <goltrpoat> i have no particular affinity for C++ these days, it pays my bills, so that makes it ok.  but jesus.  why anyone in their right mind touches C these days is just beyond me.
03:51:51 <nmessenger> C : C++ :: hammer : jackhammer
03:52:25 <ivanm> nmessenger: I would, but for some reason ff keeps complaining...
03:52:30 <ivanm> I'll try and use my wine'd IE
03:54:29 <goltrpoat> i mean, forget concurrency, forget par-uh-dig-um shifts, forget usability, extensibility, whatever.  at this point, i just honestly want to know why on earth anyone in their right mind would subject themselves to having to go out of their way to *fake*, *poorly*, freaking *virtual functions*.
03:55:39 <goltrpoat> sorry, i'll shush now.
03:56:05 * nmessenger was enjoying being below goltrpoat's soap box
03:56:11 <goltrpoat> haha
03:56:58 <nmessenger> ivanm: try another paste site: http://pastebin.com/ http://paste.lisp.org/ http://rafb.net/paste/
03:56:59 <hpaste>  ivanm pasted "Trying to read an Int off the command line" at http://hpaste.org/275
03:57:30 <nornagon> > read "123" :: Int
03:57:31 <lambdabot>  123
03:57:38 <nornagon> :t read "123" :: Int
03:57:40 <lambdabot> Int :: Int
03:57:45 <nmessenger> catMaybes gets rid of the 'Just's, the 'let Just ...' is unneccesary
03:57:57 <nmessenger> @spell unneccesary
03:57:57 <ivanm> Oh, duh :s
03:57:58 <lambdabot> unnecessary necessary unnecessarily intercessory accessory
03:58:25 <ivanm> (I had to go to my brothers windows computer and use IE, because firefox wouldn't work let me use hpaste either :s)
03:59:13 <ivanm> now it tells me "Not in scope: `n'"
03:59:31 <nmessenger> let n = ..., no Just
04:00:29 <trurl> why does haddock tell me "Warning: Classify: the following names could not be resolved: FilePath String"? (debian unstable, ghc6 and ghc6-doc 6.6-3, haddock 0.8-1)
04:00:37 <ivanm> Yeah, that's what I did
04:00:43 <nmessenger> (though that error doesn't seem to apply)
04:01:06 <ivanm>  let n = head . catMaybes . map readMaybe $ input :: Int; putStrLn (show (* n n))
04:01:24 <ivanm> And it complains:  Couldn't match expected type `Int -> a' against inferred type `Int'
04:01:43 <ivanm> Oh, duh, I was thinking in scheme for a minute there :s
04:01:53 <nmessenger> heh
04:01:58 <Saizan> :D
04:02:05 <nmessenger> @src print
04:02:05 <lambdabot> print x = putStrLn (show x)
04:02:11 <Saizan> ivann, you could like liskell :)
04:02:17 <nmessenger> that could be useful too
04:02:27 <ivanm> @google liskell
04:02:32 <lambdabot> http://www.langreiter.com/space/2007-02-01-liskell
04:02:32 <lambdabot> Title: langreiter.com plain, simple: 2007-02-01-liskell
04:02:53 <goltrpoat> let Just n = ... is fine.  you'll want main to evaluate to something, though
04:02:59 <goltrpoat> in that you'll want a return in there at some point
04:03:29 <nmessenger> ?where+ liskell http://clemens.endorphin.org/weblog/archives/2007-01.shtml
04:03:29 <lambdabot> Done.
04:03:43 <ivanm> goltrpoat: I've got that... I think the problem now is that I've got a where down the bottom, and it uses n in some of them
04:04:04 <nmessenger> @where+ liskell http://clemens.endorphin.org/liskell
04:04:04 <lambdabot> Done.
04:04:06 <nmessenger> better
04:04:32 <goltrpoat> ivanm:  oh.  you want to paste that code then?
04:04:43 <goltrpoat> what you pasted compiles if you add a return () to main
04:05:01 <nmessenger> ivanm: oh.  'where' scopes over the whole equation, so it can't see inside of 'let' expressions
04:05:04 <goltrpoat> (although then n isn't terribly useful)
04:05:26 <nmessenger> ivanm: you might move the definitions inside that 'let'
04:05:29 <ivanm> so how do I go about adding those expressions to the let expression?
04:05:42 <nmessenger> let n = ...
04:05:46 <nmessenger>     f x = ... n
04:05:54 <nmessenger>     blah = ... n ...
04:07:10 <ivanm> thanks nmessenger!!!!!
04:07:26 * nmessenger proposes that '...' be a syntax special case, prefix form = undefined
04:07:36 <ivanm> but I still can't load up your (updated) link about liskell...
04:07:39 <nmessenger> @help karma+
04:07:40 <lambdabot> karma+ <nick>. Increment someone's karma
04:08:00 <nmessenger> :)
04:08:01 <ivanm> what does karma do?
04:08:07 <nmessenger> @karma nmessenger
04:08:08 <lambdabot> You have a karma of 3
04:08:10 <nmessenger> @karma lambdabot
04:08:11 <lambdabot> lambdabot has a karma of 43
04:08:22 <ivanm> @karma ivanm
04:08:25 <lambdabot> You have a karma of 0
04:08:26 <Zyroth> I am doing the YAHT and when I try to build my first program, it says "/usr/bin/ld: can't locate file for: -lHSbase". Anyone has an idea where to point me to?
04:08:28 <nmessenger> ivanm++
04:08:32 <nmessenger> @karma ivanm
04:08:32 <lambdabot> ivanm has a karma of 1
04:08:34 <ivanm> obviously it hates me :(
04:08:54 * ivanm is so happy that he has some karma now ;)
04:09:08 * nmessenger looks beggingly at ivanm
04:09:10 <goltrpoat> ivanm:  wait..  i just read your error message, finally
04:09:29 <ivanm> @karma nmessenger
04:09:30 <lambdabot> nmessenger has a karma of 3
04:09:30 <goltrpoat> ivanm:  you realize you need to :set args 1234 or something to get your main to do anything useful, right?
04:09:35 * ivanm reciprocates
04:09:43 <nmessenger> er, @karma+
04:09:51 <ivanm> oh, that helps, doesn't it ;)
04:09:55 <ivanm> @karma+ nmessenger
04:09:56 <lambdabot> nmessenger's karma raised to 4.
04:09:57 <goltrpoat> ivanm:  otherwise getArgs sends out an empty list, and, eh.  things happen.
04:09:58 <goltrpoat> hehe
04:10:02 <pejo> Zyroth, your linker is missing information about where libHSbase.a is stored.
04:10:22 <goltrpoat> ivanm:  (in ghci, i mean)
04:10:33 <goltrpoat> no idea what those ghc errors are talking about.
04:10:34 * nmessenger asks AStork how the baby-pushing business is going
04:10:36 <ivanm> goltrpoat: I was doing something along the lines of ":main 1 2 this is a test 3 4"
04:10:40 <Zyroth> pejo: hm, how can I tell him?
04:11:46 <ivanm> OK, thanks everyone, I think my program is working now!!!
04:11:55 <nmessenger> also, nick++ is a shorthand for @karma+, but it's silent
04:12:10 <nmessenger> welcome :D
04:12:18 <nornagon> @karma nick
04:12:18 <lambdabot> nick has a karma of 3
04:12:22 <pejo> Zyroth, I would guess -L/usr/local/lib passed to ghc, or wherever you stored it. Can you compile any program at all?
04:12:42 <goltrpoat> ivanm:  coolness.
04:12:46 <nmessenger> hmm, *tests to see if nick++ works in the middle of a line*
04:12:49 <nmessenger> @karma nick
04:12:49 <lambdabot> nick has a karma of 4
04:12:55 <Zyroth> It's the first program I ever tried, since I'm just starting with the tutorial.
04:13:39 * nmessenger sends a bunch of /msg lambdabot nick--
04:13:54 <nornagon> @karma nick
04:13:54 <lambdabot> nick has a karma of 4
04:13:59 <nornagon> @karma aoeua.pyeiaoeuaoeu
04:14:00 <lambdabot> aoeua.pyeiaoeuaoeu has a karma of 0
04:14:10 <nmessenger> @karma nick
04:14:11 <lambdabot> nick has a karma of 0
04:14:20 <pejo> Zyroth, hm. Something fishy with your ghc installation then, I think. But I have no idea what. "ghc --make Something.hs" usually works for me.
04:14:42 <Zyroth> I installed it via fink on mac os x. perhaps I will try to get it from somewhere else.
04:14:45 <Zyroth> but thanks anyway =)
04:15:17 * ivanm wonders who nick is, that his karma is the subject of so many experiments ;)
04:15:32 <pejo> Zyroth, oh. I run darwinports (macports?) and it works like a charm there.
04:16:03 <Zyroth> Hm. perhaps I try that one out next.
04:16:04 <nmessenger> @karma nickname
04:16:05 <lambdabot> nickname has a karma of 0
04:16:08 <nmessenger> @karma name
04:16:09 <lambdabot> name has a karma of 0
04:16:20 <nmessenger> @karma someone
04:16:21 <lambdabot> someone has a karma of 0
04:16:48 <iah> @karma everyone
04:16:49 <lambdabot> everyone has a karma of 0
04:16:57 <nmessenger> D:
04:17:43 <gour> @karma God
04:17:44 <lambdabot> God has a karma of 0
04:18:03 <nmessenger> @karma Haskell
04:18:03 <lambdabot> Haskell has a karma of 9
04:18:09 <goltrpoat> (Data.Map.findWithDefault is sure getting a workout)
04:18:27 <nmessenger> @karma haskell
04:18:27 <lambdabot> haskell has a karma of 20
04:19:07 <nmessenger> haskell++
04:20:43 <evil_nmess> @karma+ nmessenger
04:20:46 <lambdabot> nmessenger's karma raised to 5.
04:20:47 <nornagon> @karma should aggressively lowercase.
04:20:47 <lambdabot> should has a karma of 0
04:21:01 <nmessenger> :}
04:21:42 <gour> @karma Jesus
04:21:42 <lambdabot> Jesus has a karma of 0
04:21:48 <gour> just see...
04:22:16 * nmessenger feels guilty
04:22:23 <nmessenger> someone nmessenger--
04:22:41 <nmessenger> WAIT! Not all at once!
04:22:49 <earthy> nmessenger--
04:22:57 <earthy> :P
04:23:02 <earthy> @nmessenger--
04:23:03 <lambdabot> Unknown command, try @list
04:23:12 <earthy> @karma- nmessenger
04:23:13 <lambdabot> nmessenger's karma lowered to 3.
04:23:14 <earthy> !sigh
04:23:27 <earthy> @karma+ nmessenger
04:23:28 <lambdabot> nmessenger's karma raised to 4.
04:23:31 <earthy> that's better.
04:23:35 <nornagon> @karma @nmessenger
04:23:35 <lambdabot>  @nmessenger has a karma of 0
04:23:50 <nmessenger> @karma @karma
04:23:51 <lambdabot>  @karma has a karma of 1
04:24:31 <nmessenger> hmm...
04:24:33 <dons> so its 'lets mess with the karma system' season again? :)
04:24:38 <nmessenger> @karma @karma+ nmessenger
04:24:39 <lambdabot>  @karma+ has a karma of 0
04:24:47 <nmessenger> @karma has
04:24:48 <lambdabot> has has a karma of 0
04:24:59 <goltrpoat> all of this probably ends up in our fbi files and is then taken into account when they consider you for jobs that require security clearance.
04:25:16 <dons> to think of all the code that could be written when people are instead trying to break lambdabot
04:25:43 <nmessenger> :)
04:28:40 <dons> i hope everyone's noticed we've jumped about 10 spots back up in the shootout rankings :) http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
04:28:43 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/lepfo
04:28:50 <dons> just a few more low lying fruits to pick now
04:30:22 <Igloo> dons: What's the x column?
04:30:35 <nmessenger> tests failed or unwritten?
04:30:52 <Igloo> ah
04:33:01 <nmessenger> wow, D does seem like a cool C
04:37:41 <Igloo> dons: There's no way to compare Haskell to the best solutions, right?
04:46:00 <goltrpoat> is there a readable version of the n-body one floating around somewhere?
04:46:34 <goltrpoat> i.e. one that isn't 75% unsafeRead/unsafeWrite
04:49:28 <Eelis> dons: did you get my message about Yi on x86_64
04:49:31 <Eelis> ?
04:51:59 <xic> does ghc have support for 64 bit?
04:53:19 <goltrpoat> as of 6.4.1, iirc.  don't know to what extent
04:55:02 <xic> are all pointers internally 64 bit, so my haskell process can use shitloads of memory?
04:55:41 <goltrpoat> that appears to be the case, yes
04:57:36 <Heffalump> that's usually what happens when you move to 64 bit, yes
04:58:28 <ivanm> dons: Just looked at the shootout link you posted, and it doesn't look that much different from the last time I looked at it :s
04:59:02 <dons> nah, we jumped another 8 or so points today
04:59:41 <dons> this guy, in particular, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
04:59:43 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ..., http://tinyurl.com/ncjpk
04:59:44 <goltrpoat> is there any sort of sse2 support in ghc, btw?
04:59:46 <ivanm> I meant the relative rankings of the various languages
05:00:11 <dons> yesterday we were behind lisp sbcl (the shame of it!) and today we're not :)
05:00:48 <goltrpoat> FreeBASIC though :)  tsk.
05:01:01 <goltrpoat> jk
05:01:04 <Igloo> dons: Dude, we're behind Java. Java!
05:01:17 <dons> right, work to do!
05:01:25 <dcoutts> oh dear oh dear
05:02:04 <dcoutts> Igloo, if you include startup then we're one ahead
05:02:14 <xic> dons: is there anyone besides you who works on the rankings?
05:02:34 <Igloo> heh, true
05:02:36 <dons> i haven't touched them in over a year
05:02:57 <dons> so yeah, there's a couple of others (sjanssen for example), but not many
05:03:01 <musasabi> dons: btw do you think a patch for the binarySize to Binary would be accepted?
05:03:16 <dons> musasabi: i saw that. haven't thought hard about it yet.
05:03:22 <dcoutts> dons, so what do you think the best lazy bytestring representation should be, given your recent experiment?
05:03:47 <dcoutts> dons, we could make it a single constructor data type
05:03:59 <dons> data LBS = Nil | Chunk !Strict LBS -- something ike that
05:04:06 <dcoutts> or see how well spec constr deal with that style ^^
05:04:11 <trurl> how can I get haddock to produce a hyperlink for e.g. the String type?  I get: "Warning: Classify: the following names could not be resolved: FilePath String"? (debian unstable, ghc6 and ghc6-doc 6.6-3, haddock 0.8-1)
05:04:13 <dons> same trick as the ForeignPtr Addr# ForeignPtrContents almost
05:04:47 <dons> trurl: the error msg is harmless, to actually link to the docs for String needs the haddock binaries for String on your system, I think
05:05:01 <Igloo> dons: Which benchmark did it make a difference for again?
05:05:09 <dcoutts> dons, spec constr ought to be able to do that transform that you did manually.
05:05:12 <dons> sum-file and fasta so far
05:05:21 <liyang> trurl: --read-interface=../rel-path-to/ghc-docs/...,base.haddock
05:05:23 <dons> dcoutts: right, that's what i was wondering
05:05:24 <dcoutts> dons, ie change it to keep the current and remaining chunks
05:05:52 <dons> so its a standard trick i'm doing now :) (s:ss) = toChunks ; then foo !s ss
05:06:05 <liyang> trurl: unfortunately base.haddock comes with ghc6-doc gzipped. You'll have to unpack it somewhere.
05:06:35 <dcoutts> dons, sure, always has been, we should just have noticed it earlier. :-)
05:06:40 <trurl> liyang: ah that explains why I could not find it
05:06:49 <trurl> dons, liyang: thanks
05:06:56 <dcoutts> dons, it's the transform that kolmodin is currently doing to the Get monad
05:07:02 <dons> yes, exactly
05:07:16 <pejo> dons/dcoutts, did you, or anyone else document these tricks anywhere?
05:07:25 <dcoutts> pejo, not yet
05:07:33 <dons> pejo, well, only really worked it out yesterday :) but it should go on the Performance wikipage
05:07:35 <pejo> (Or could GHC do it automatically?)
05:07:41 <liyang> Igloo: *wave* Any chance you could leave base.haddock as it is in the next release? :)
05:07:50 <dons> you can see the trick here, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
05:07:52 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
05:07:54 <dcoutts> pejo, that's what we're wondering, I think the spec constr could do it
05:08:19 <dons> dcoutts: so we could show the difference code between the unwrapped and wrapper lazy bytestring to simon
05:08:23 <Igloo> dons: And you're claiming the '!'s before the 's's are significant, right?
05:08:26 <Igloo> (in sumfile)
05:08:47 <dons> Igloo: there might be a few too many, i didn't prune all of them away
05:08:52 <dons> some of them matter, yes :)
05:09:30 <dons> in particular, !s :: Strict.ByteString seems to really help
05:09:46 <dons> since that'll turn into an Addr#
05:09:52 <dcoutts> dons, yes, making the list element-strict should make a big difference
05:10:07 <dcoutts> and yeah, we should demo this an example of spec constr
05:10:18 <dons> right.
05:10:25 <Igloo> dons: If you literally mean a variable called s then I can only see 2, and the core looks identical without the '!'s
05:10:25 <dons> so a simple version of sum file might do the trick
05:10:32 <dons> just ignoring the negative numbers
05:10:56 <Igloo> It's a bit hard without type signatures when you don't know the code, but nothing else looks obviously like a bytestring to me
05:11:04 <dcoutts> dons, SPJ said I should think about doing stuff about spec constr for my thesis, eg improving / extending the optimisation and doing some examples
05:11:31 <dons> well, if you could fix ghc to unwrap our lazy bytestrings... :)
05:11:45 <Igloo> liyang: I'll look into what exactly should happen (if you know, please let me know). Currently it's debhelper compressing it, but the right thing might be to move it somewhere else rather than stopping the compression happening
05:14:42 <dcoutts> dons, spec constr is -O2 only
05:14:58 <dcoutts> and some ofthe newer spec constr extensions are only in HEAD
05:15:27 <dons> oh, that's interesting. hmm, we should check these examples into nofib :)
05:15:29 <trurl> Igloo: I would put it in /usr/share/ghc-6.6/haddock/
05:34:47 * dcoutts notes that there have been ~40 downloads of gtk2hs-0.9.10.6 in the 18 hours since it was announced
05:34:53 <dcoutts> (distinct ip addresses)
05:35:22 <dons> coo
05:35:24 <dons> l
05:35:25 <dons> !
05:35:26 <dons> :)
05:36:18 <dcoutts> and the ratio of .tar.gz to .exe was about 7:3
05:36:31 <dcoutts> I'll go announce it on the libraries list too
05:36:35 <dons> huh. there's a lot of secret windows users out there
05:36:54 <dcoutts> then the final announce will be on the main haskell list
05:36:58 <dcoutts> dons, yeah, lots
05:37:00 <augustss> secret? :)
05:37:05 <dcoutts> that's what the ghc survey discovered
05:37:11 <dons> well, some not so secret, augustss :)
05:38:15 <dons> hey augustss , yay for compiled pure lazy fp eh? --> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
05:38:18 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
05:39:45 <augustss> cool!  But why is the (gzipped) program so huge compared to the others?
05:40:15 <dons> it implements its own read for strict bytestrings
05:40:59 <dons> so things that should be in libraries , basically :)
05:41:30 <augustss> fair enough
05:42:02 <dons> that problem has been quite a challenge over the last couple of years. summing a 20M+ file. we're just about there, but still have to manually do some high perf tweaks that ghc or libraries could provide
05:42:22 <augustss> are all the ! necessary?  Is the ghc strictness analyzer that poor?
05:42:30 <dons> nah, they're not all necessary
05:42:52 <dons> but its easier to sprinkle them around than 'seq' was
05:43:00 <augustss> true
05:44:26 <dons> the generated code is pretty good, for the fast path, it looks like: http://hpaste.org/273
05:45:08 <dons> dcoutts: reminds me, we should have md5sums on hackage
05:45:28 <dcoutts> dons, oh yeah, right.
05:46:02 <augustss> bah!  Unreadable.  Show me the assembly code.
05:46:09 <dons> heh
05:46:37 <dons> 'ghc core: its just a simple functional language'
05:50:42 <dons> the asm is pretty good too
05:51:34 <hpaste>  dons pasted "asm for add()" at http://hpaste.org/276
05:57:50 <augustss> So the subtraction of ord '0' and the multiply by 10 is clever, but otherwise the code looks a bit crappy.  gcc isn't as good as it should.
05:58:18 <pejo> Is the strictness analysis in ghc "as good as it can be" or has some strength been sacrifized for simplicity?
05:58:19 <chessguy> 'morning, haskellers
06:02:49 * chessguy crosses his fingers and tries to install gtk2hs RC2
06:03:10 <dcoutts> pejo, the latter
06:03:11 <fasta> Suppose I have a data type Foo a = Foo (Baz a) (Zork a) [a] [a], how can I define a function "convert" that converts this into a value of type Foo b (also assume that the type parameter a given to many other data types below Baz)? I know of one way to do it, but it seems _very_ awkward. The idea of splitting up the problem is smaller subproblems doesn't work anymore.
06:03:35 <hpaste>  dons annotated "asm for add()" with "asm produced by ghc directly" at http://hpaste.org/276#a1
06:03:39 <dcoutts> pejo, however apparently the limitation is having anything useful to do with the more detailed info you get from better analyses
06:03:54 <fasta> Essentially I will have to write a fold.
06:03:59 <dcoutts> dons, nice
06:04:21 <fasta> (but that only supports my point :( )
06:05:20 <dons> this is what ghc's native code gen produces, http://hpaste.org/276#a1
06:05:20 <dons> at least it gets the jumps right
06:06:33 <robreim> IIRC the 07 hackathon resulted in some binary libraries or something, yeah?
06:06:44 <pejo> dcoutts, oh, so it's the optimizations that are too weak in some sense, not that they lack information?
06:06:44 <dons> ?where binary
06:06:45 <lambdabot> http://darcs.haskell.org/binary
06:06:53 <dons> and on hackage
06:06:53 <robreim> thanks :)
06:06:56 <dons> ?where hackage
06:06:56 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
06:07:08 <dons> docs at http://www.cse.unsw.edu.au/~dons/binary iirc
06:07:13 <chessguy> fasta, i'm not quite sure what the difficulty is. can't you write 4 functions Baz a -> Baz b, Zork a -> Zork b, [a] -> [b], and [a] -> [b]
06:07:18 <dcoutts> pejo, so I've heard. If you can find anything useful to do with the extra strictness then I'm sure people will be interested.
06:07:57 <fasta> chessguy: I will post some code to illustrate.
06:08:05 <chessguy> fasta, good idea :)
06:08:25 <dcoutts> dons, we should put the hackage db on the hackage.haskell.org front page (which currently is quite useless)
06:08:40 <pejo> dcoutts, hm, yeah. I'll pile that up on things to do, just after I understand laziness.
06:08:47 <dcoutts> dons, http://hackage.haskell.org/packages/hackage.html should be the front page.
06:08:49 <lambdabot> Title: HackageDB: introduction
06:08:55 <hpaste>  fasta pasted "example of too restricted type" at http://hpaste.org/277
06:09:08 <dcoutts> dons, and that can link to the current cabal wiki thing that the font page redirects to,
06:09:23 <fasta> chessguy: The problem I want to solve is that I want to convert every edge label to a constant value.
06:09:38 <fasta> chessguy: AFAIK, this code would work in e.g. Scheme.
06:10:03 <dons> yes
06:10:03 * dons `put` sleep :: Put a
06:10:20 <dcoutts> g'night dons :-)
06:10:34 <fasta> chessguy: The problem arises from the fact that you can't distributedly _change_ a type in this way.
06:11:22 <fasta> chessguy: The type inferenced is b -> Graph a b -> Graph a b, instead of the more general c -> Graph a b -> Graph a c
06:12:07 <fasta> chessguy: I am not claiming the type inferencer is doing anything wrong, it's just that it's posing a restriction now.
06:12:26 <chessguy> fasta, what happens if you give it the type signature yourself?
06:12:44 <fasta> chessguy: Probably that it doesn't work out. I will try.
06:13:42 <fasta> chessguy:  Couldn't match expected type `c' (a rigid variable)
06:13:42 <fasta> 	   against inferred type `b' (a rigid variable)
06:13:51 <fasta> chessguy: That's what I expected.
06:14:03 <chessguy> dcoutts, what's an average amount of time required to make gtk2hs
06:14:41 <chessguy> fasta, then it would seem to me that there's something wrong with your code, not the type inference
06:15:06 <fasta> chessguy: I am not saying the type inference algorithm is incorrect, just that it could be smarter.
06:15:34 <fasta> chessguy: I am pointing out a case where this type inference algorithm isn't helping me.
06:15:40 <dcoutts> chessguy, if you build without optimisations then about 15min, with optimisations about double that.
06:15:51 <Saizan> faste: can't it be that your code is imposing that restriction?
06:15:59 <dcoutts> chessguy, and that's if you build all the packages.
06:16:30 <fasta> Saizan: If you can point out a way that doesn't use something like a fold to do what I mean here...
06:16:55 <fasta> Saizan: by definition in Haskell my code is incorrect (if that's what you mean)
06:17:31 * fasta goes to write a fold....
06:18:39 <fasta> The type system cannot understand independent pieces of code together satisfying the typing requirements.
06:19:51 <chessguy> fasta, i think you're going to need a simpler test case to really prove that
06:22:32 <Igloo> dcoutts: I've put a redirect in for hackage.h.o
06:22:44 <dcoutts> Igloo, oh ta.
06:23:13 <dcoutts> Igloo, yes, much better, thanks.
06:24:54 <dcoutts> Igloo, heh, we need to sort out the cabal / hackage web pages / wiki's bug trackers etc. It's a twisty little maze of confusing names and links.
06:31:37 <chessguy> sweet! gtk2hs works here!
06:31:40 <chessguy> dcoutts++
06:48:52 <dcoutts> yay, first reports of successfully building Gtk2Hs on OSX intel
06:51:18 <dcoutts> xerox, you use osx, what does Gtk+ look like there? is it any good?
06:57:04 <gour> dcoutts: is it with native port?
06:57:21 <dcoutts> gour, I don't know
06:57:45 <gour> it would be noce to hear about native port
06:57:53 <dcoutts> from the Gtk+ OSX page it still looks less usable than the X11 version
06:58:25 <gour> having it 'buildable' would be encouraring, though
07:10:36 <GeoBesh> New Compiler Hacker Question: on a debian x86-64 system with debian ghc6.6 installed I am getting a segmentation violation when compiling the darcs sources (pulled about 14 hours ago).  I am not seeing a bug in the bug list for this.  My question is, if the bug was fixed recently where would I get the latest 'semi-stable' snapshot?
07:11:10 <Igloo> GeoBesh: When compiling GHC from darcs, you mean?
07:11:38 <Igloo> @paste
07:11:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:11:56 <Igloo> GeoBesh: Can you paste the error, including the preceeding lines, please?
07:11:57 <GeoBesh> Igloo yes
07:12:04 <GeoBesh> Moment
07:14:02 <GeoBesh> <<ghc: 980813128 bytes, 1663 GCs, 15949394/38425016 avg/max bytes residency (12 samples), 99M in use, 0.00 INIT (0.00 elapsed), 1.57 MUT (8.58 elapsed), 1.34 GC (1.36 elapsed) :ghc>>
07:14:02 <GeoBesh> /usr/bin/ghc -H16m -O  -istage1/utils  -istage1/basicTypes  -istage1/types  -istage1/hsSyn  -istage1/prelude  -istage1/rename  -istage1/typecheck  -istage1/deSugar  -istage1/coreSyn  -istage1/specialise  -istage1/simplCore  -istage1/stranal  -istage1/stgSyn  -istage1/simplStg  -istage1/codeGen  -istage1/main  -istage1/profiling  -istage1/parser  -istage1/cprAnalysis  -istage1/ndpFlatten  -istage1/iface  -istage1/cmm  -istage1/nativeGen -Ista
07:14:02 <GeoBesh> make[1]: *** [stage1/rename/RnNames.o] Segmentation fault (core dumped)
07:14:03 <GeoBesh> make: *** [stage1] Error 1
07:14:06 <GeoBesh> thunderbolt:/mnt/raid/Haskell/ghc# /usr/bin/ghc --version
07:14:07 <GeoBesh> The Glorious Glasgow Haskell Compilation System, version 6.6
07:14:45 <Igloo> GeoBesh: Hmm. That's from a clean checkout of GHC?
07:14:55 <GeoBesh> Yes
07:15:17 <Igloo> GeoBesh: Is it reproducible?
07:15:31 <GeoBesh> Have not tried yet.
07:15:45 <GeoBesh> Will do a fresh pull now.
07:18:01 <Eighty> is there a way to invoke the gc in code?
07:18:18 <matthew-_> why do you want to?
07:18:37 <Igloo> @index performGC
07:18:37 <lambdabot> System.Mem
07:18:51 <Eighty> i'm trying to time how long certain evaluations take, and i'm afraid that if i do them in the wrong order, the later ones will be affected because of memory issus
07:19:53 <Eighty> Igloo: thanks
07:21:04 <Igloo> Eighty: I don't think the GC will be done by the time performGC returns, though
07:21:15 <Eighty> oh, i was just going to ask about that.
07:21:15 <Eighty> :(
07:21:24 <Eighty> there's no way to guarantee that, then?
07:22:31 <musasabi> Eighty: how about do the computations N times on M runs and do some statistical analysis?
07:22:48 <musasabi> first time is usually slower than the rest due to cache etc
07:23:12 <Eighty> well, that would take a long time
07:23:41 <Eighty> also, ghc usually spontaneously exits after a few times because i'm using so much memory
07:25:26 <hpaste>  csci pasted "Using gtk2hs and drawingArea (?)" at http://hpaste.org/278
07:26:03 <csci> Hi, I think I forgot one small thing, but don't see what ;-)
07:26:04 <Saizan> Eighty: how much?
07:26:18 <hpaste>  jim annotated "TileDemo" with "TileDemo - fixed hit-detection" at http://hpaste.org/272#a1
07:26:23 <Eighty> lists with 256^2 elements
07:26:55 <Eighty> with lots of intermediate calculations
07:27:01 <Saizan> aah, you beat me
07:28:31 <Saizan> or maybe not, i've grids 500x300 of grids of 500x300, so 250+ mb of ram
07:28:56 <Eighty> hm, are you using the -Hxxm flag?
07:29:11 <Saizan> what is it?
07:29:37 <dcoutts> csci, what's wrong?
07:29:51 <csci> dcoutts, it does not display anything
07:29:52 <matthew-_> mmm. presumeably it's pointless to try to unbox something that's not in GHC.Prim ?
07:30:05 <Eighty> i dunno what it actually does... it's supposed to give you more memory, but if i give it too much (though less than my total of ram on my comp) it exits immediately
07:31:05 <csci> dcoutts, ...which is quit bad and I don't find the error
07:31:35 <hpaste>  dcoutts annotated "Using gtk2hs and drawingArea (?)" with "use onExpose" at http://hpaste.org/278#a1
07:31:53 <Eighty> how do people usually decide  how to do something the fastest way in haskell?
07:32:00 <Eighty> without already "knowing" what you should or should not do
07:32:04 <dcoutts> Eighty, profiling
07:32:08 <csci> dcoutts, Thanks. Learning haskell *and* gtk at the same time can be hard sometimes ;-)
07:32:26 <Eighty> dcoutts: is that easy to do?
07:32:47 <Eighty> well wait, that's for finding bottlenecks in a program, right?
07:32:50 <dcoutts> csci, the point is that a window/widget needs to be able to redraw itself whenever it gets hidden and exposed. It's not persistent, so you can't just do it once.
07:33:02 <fasta> Eighty: what do you mean by "fastest"?
07:33:04 <dcoutts> Eighty, right, but that's half the problem
07:33:18 <dcoutts> Eighty, then it's a matter of using the right data structures and algorithms
07:33:24 <fasta> Eighty: fast code or fast having a program up and running?
07:33:37 <csci> dcoutts, Ah, like paint() in Java.
07:33:38 <Eighty> dcoutts: yeah, i'm having problems already with slow datastructures
07:33:52 <Eighty> fast code, and not using too much memory
07:34:14 <dcoutts> Eighty, and right at the bottom level it can be about some low level issues and then looking in detail at what the compiler produces can help. But the biggest gains are to be had at the higher levels of course.
07:34:44 <Saizan> when you have an unexpectedly high memory usage is generally cause of too much laziness or too much strictness? (wavy question, i know)
07:35:27 <Saizan> s/cause/effect/
07:36:38 <Eighty> well what i'm trying to do is to implement strassen's matrix mult algo, but i can never make it faster than the O(n^3) algo for any matrices which are small enough to not crash ghc
07:36:55 <Eighty> is it stupid to use lists for matrices then?
07:37:21 <Botje> pretty much so.
07:37:26 <Botje> use Data.Array instead
07:37:40 <Eighty> Array was much slower for me
07:37:59 <fasta> Eighty: you need to understand the properties of the data structures you are working on.
07:38:03 <chessguy> Eighty, have you looked at existing libraries for matrices in haskell?
07:38:14 <fasta> Eighty: if you fail that step, you already lost.
07:38:15 <Eighty> chessguy: no.
07:39:18 <fasta> I think there's a library calling out to some heavy optimized C lib.
07:39:23 <Eighty> fasta: well, yeah, but I don't know what I need to know. I don't know what it is that makes it slow
07:39:31 <chessguy> Eighty, http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
07:39:34 <lambdabot> Title: Libraries and tools/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
07:39:47 <fasta> Eighty: how do you know it's slow?
07:40:07 <fasta> Eighty: and profiling is about the only way to see what's taking a lot of time.
07:40:11 <Eighty> because the O(n^3) algo is faster for all sizes of matrices
07:40:27 <fasta> Eighty: that's not true (strictly speaking)
07:40:33 <Eighty> i know!
07:41:05 <jemfinch> what's the best/easiest paper to learn about GADTs?
07:41:23 <Eighty> fasta: that's why i know my implementation is too slow
07:42:36 <fasta> Eighty: I am not following you.
07:42:45 <fasta> An overloaded operator for matrix products, matrix-vector and vector-matrix products, dot products and scaling of vectors and matrices. Type consistency is statically checked. Alternatively, you can use the specific functions described below, but using this operator you can automatically combine real and complex objects.
07:42:53 <fasta> From GSLHaskell
07:43:23 <Eighty> i know my implementation of strassen is too slow because it is always slower (for all matrices that are not so big that they immediately crash ghc) than my implementation of naive matrix mult
07:43:27 <fasta> Seems that your problem has already been solved and far better than you would do in a few days.
07:43:48 <Eighty> this is an assignment.
07:43:56 <Eighty> so i can't use a library :)
07:44:04 <fasta> Eighty: you should state that next time.
07:44:27 <chessguy> preferably before 10 minutes of wrangling
07:44:44 <Eighty> well, 'pologies then.
07:44:49 <hpaste>  jim annotated "TileDemo" with "removed unnecessary readIORef" at http://hpaste.org/272#a2
07:45:11 <Eighty> but being able to implement something seemingly simple like this would come in handy regardless.
07:45:30 <fasta> chessguy: I "solved" my earlier problem, btw, by delaying the array operations.
07:47:39 <fasta> Eighty: also, not posting any code often results in massively ignoring your messages.
07:48:54 <Eighty> fasta: what would i post? i don't think anyone wants to read and analyze one hundred lines of crappy code
07:49:27 <Eighty> if i had three lines i was having problems with, i'd post that.
07:49:40 <fasta> Eighty: I think that happens often enough.
07:49:48 <Eighty> what?
07:49:57 <fasta> Eighty: posting 100 lines of code.
07:51:01 <fasta> Eighty: You should also post a profiling report, etc.
07:51:12 <fasta> Eighty: you should help people to help you.
07:51:12 <Eighty> how do i profile?
07:51:20 <fasta> Eighty: it's documented in the manual.
07:51:27 <fasta> Eighty: assuming you use GHC
07:51:38 <Eighty> well i'm not having a specific problem right now, so there's no code to post
07:51:53 <Eighty> i just wanted to know how to accurately time a calculation
07:52:21 <fasta> Eighty: I think the profile report gives an accurate number.
07:52:44 <fasta> Eighty: for my own project I will be parsing the profile reports for a number of results.
07:53:08 <chessguy> Eighty, http://www.haskell.org/haskellwiki/Timing_computations
07:53:09 <lambdabot> Title: Timing computations - HaskellWiki
07:53:11 <Eighty> i want to compare different implementations, all using entirely different data structures, and i want to automate that.
07:53:32 <Eighty> chessguy: that's what i'm using, but i can only use it for one calculation at a time
07:54:01 <fasta> chessguy: that's a relatively simple solution.
07:54:27 <fasta> chessguy: I don't want to measure IO time, but other people might.
07:54:38 <fasta> Eighty: it's called abstraction.
07:55:04 <Eighty> abstract what?
07:55:45 <Eighty> my problem is i believe that running that timing thingy for different calculations in sequence, it would get unreliable.
07:56:06 <fasta> Eighty: you are mixing problems.
07:56:15 <fasta> Eighty: you are right on that last point, though.
07:58:46 <Eighty> fasta: that measures IO time?
07:59:08 <fasta> Eighty: what measure IO time?
07:59:33 <Eighty> you said the timing computations-snippet measures IO time
07:59:44 <fasta> Eighty: it included IO time.
07:59:50 <fasta> Eighty: includes*
08:00:04 <Eighty> is that significant?
08:00:28 <fasta> Eighty: that depends on your application, but it's better to separate it.
08:01:58 <fasta> Eighty: is this an undergraduate assignment?
08:02:32 <Eighty> 3rd year university class
08:02:50 <fasta> Eighty: and you have to use Haskell?
08:02:53 <Eighty> i don't know exactly what undergraduate means. is that before you're done?
08:02:53 <Eighty> yes
08:03:22 <fasta> Eighty: in that case, I'd not worry too much about it.
08:03:39 <GeoBesh> Igloo -- worked fine this time.  I am on a dual core machine, but everything else should be normal.  Go Figure.
08:04:45 <Eighty> a requirement is that the matrix mult is faster than O(n^3). i'd then like an implementation which isn't just asymptotically faster, but actually faster for some feasible input
08:04:49 <Igloo> GeoBesh: It sounds like dodgy hardware, although I'm a bit surprised it managed a complete build if that's the case
08:05:20 <fasta> Eighty: heh, that's normal.
08:05:26 <Igloo> Eighty: Are you doing random lookup on the lists that make up your arrays?
08:05:40 <fasta> Eighty: it only gets faster from about 1 billion elements, IIRC.
08:05:41 <Eighty> absolutely not
08:06:09 <fasta> Eighty: (At least the classical improvement. )
08:06:24 <GeoBesh> Igloo --- yeah, its a brand new system so something may not be quite right.
08:06:35 <Eighty> the problem is that in strassen's algo, i have to split the matrix in four smaller matrices. i think that's the bottleneck. i've tried some clever tricks, but still the O(n^3) is faster
08:06:53 <Eighty> because in splitting a matrix, i have to create so much new data
08:07:28 <Eighty> fasta: i read on wikipedia about the fastest known algorithm being better only for matrices which can't fit on any existing computer :)
08:08:33 <fasta> Eighty: I am not sure about that, but it was either that the dimensions were 1 billion or the number of elements.
08:08:48 <fasta> Eighty: also, it could be that the information on Wikipedia is dated.
08:09:10 <Eighty> possibly, i'll check it again
08:21:04 <Zyroth> Can I use ghc to create .so libraries?
08:21:17 <dcoutts> Zyroth, not yet
08:21:38 <Zyroth> is there a way to create .so out of haskell source code?
08:21:55 <SamB> dcoutts: you can't?
08:22:11 <SamB> I thought you could -- just as long as they were for use with C
08:22:20 <dcoutts> SamB, I don't think it's supported yet on Linux
08:22:55 <dcoutts> SamB, oh, hmm. I'm less sure about that
08:23:06 <SamB> I think you can make C-compatible .sos (but they would contain the entire GHC RTS and all needed libraries)
08:23:17 <dcoutts> I've never seen it done
08:23:17 <SamB> I'm not sure GHC has flags for it...
08:23:31 <dcoutts> I've seen people talk about doing that with .dlls on win32
08:23:33 <SamB> but you can use the gcc/ld flags
08:23:52 <dcoutts> there is certainly a plan to build ghc packages into .so libs rather than .a libs
08:23:57 <dcoutts> it works on OSX already
08:24:00 <dcoutts> but not linux
08:24:04 <SamB> quite so
08:24:16 <Zyroth> so how do I do it on OS X?
08:24:30 <SamB> Zyroth: what did you want a .so for?
08:24:42 <Zyroth> use it with the python ctypes library
08:24:46 <SamB> ah.
08:25:07 <SamB> yeah, I think you can do that in Linux too...
08:25:58 <SamB> you need to use FFI to export your functions to "C"
08:26:26 <dcoutts> Zyroth, and you need to use -fPIC
08:26:37 <Zyroth> okay
08:26:43 <dcoutts> and probably -dynamic
08:26:44 <Zyroth> I will try to google my way through ;)
08:26:54 <dcoutts> Zyroth, check the ghc users guide
08:27:12 <Zyroth> will do, thanks
08:27:24 * SamB wonders who you have to pass each of these flags to
08:27:38 <SamB> c compiler? assembler? linker?
08:28:28 <AStorm> linker
08:28:33 <SamB> you also need the -no-hs-main flag for GHC, since your .so obviously won't have a "main" function
08:28:39 <AStorm> compiler need -fPIC
08:28:45 <AStorm> linker needs -dynamic or -shared
08:29:40 <Zyroth> aren't all the pars that I pass to ghc passed on to the linker, compiler etc.?
08:29:54 <AStorm> Should be.
08:30:28 <SamB> ghc --make -o libfoo.so -no-hs-main -fvia-C -optc -fPIC -optl -shared TopModule.hs
08:30:31 <SamB> would that do it?
08:30:56 <SamB> I suppose you might want -fffi ;-)
08:31:08 <SamB> but you could also stick that in the module itself
08:31:09 <Zyroth> woops.
08:31:38 * chris2 recently tried to build haskell .sos, too, until he noticed he only had a static RTS :/
08:31:49 <SamB> oh, wait...
08:31:54 <SamB> how is -fPIC going to help?
08:32:14 <Zyroth> "ghc-6.6: unrecognised flags: -shared"
08:32:15 <SamB> ... the RTS isn't built with that...
08:32:31 <chris2> use ghc -v to see what it really calls
08:32:37 <Zyroth> what's RTS?
08:32:44 <SamB> the runtime system
08:32:51 <chris2> and -fpic is for ghc, it will be passed to gcc automatically
08:33:09 <SamB> oh...
08:33:19 <SamB> hmm...
08:33:29 <SamB> my GHC manpage doesn't list any "pic" things
08:33:53 <chris2> ls /opt/local/lib/ghc-6.4.1/libHSrts*
08:34:06 <chris2> i *think* you need a _dyn version there
08:34:29 <chris2> i tried all others at least, and every contained nonrelocatable sections
08:34:46 <SamB> hmm
08:35:11 <Zyroth> seems my installation misses a library for dynamic linking: "/usr/bin/ld: can't locate file for: -lHSbase_dyn"
08:35:19 <SamB> what is a nonrelocatable section? I am but a simple x86 user, and do not know of such things!
08:35:19 <chris2> yeah, exactly
08:35:33 <chris2> you need to build ghc with support for dynamic libraries
08:36:00 <Zyroth> ah okay
08:36:08 <chris2> SamB: PIC code can be loaded at every memory address, which is required for dynamic loading.  nonrelocatable code has fixed addresses and can only statically linked
08:36:29 <SamB> hmm, actually I guess even x86 has nonrelocatable code...
08:37:00 <chris2> yeah
08:37:19 <chris2> but i think gcc builds pic code there even if you dont tell it, or something long that
08:37:39 <SamB> or at least nonrelocatable data
08:40:07 <SamB> I think -fPIC gives you different code on x86
08:40:26 <SamB> but that plain relocations work fine in .sos, too
08:44:40 <SamB> anyway, all the control-flow instructions use relative addresses
08:45:00 <SamB> well, the ones that use immediate addresses, that is
08:48:54 <slowriot> where can I find IO stuff (putStrLn, putChar, getLn, etc...) in the standard library reference?
08:49:13 <SamB> @doc Prelude
08:49:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
08:49:33 <slowriot> ah, thanks
08:50:52 <Igloo> You might want System.IO too
08:57:10 <hpaste>  eighty pasted "timing" at http://hpaste.org/279
08:57:34 <chessguy> ?hoogle putStrLn
08:57:35 <lambdabot> Prelude.putStrLn :: String -> IO ()
08:57:35 <lambdabot> IO.hPutStrLn :: Handle -> String -> IO ()
08:57:41 <chessguy> slowriot, that's how you can tell
08:57:55 <Zyroth> after having read this <http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking> I have no idea how to build GHC with support for dynamic libraries. there is no "build.mk" In the distribution folder I downloaded and I have no idea how to interrupt the build process.
08:58:29 <Eighty> why does my code act the way it does? :/
08:58:40 <sorear> Zyroth: (2) ^C (1) copy mk/build.mk.sample
08:59:51 <Eighty> nevermind!
09:00:02 <Eighty> dammit, i wrote 10*22 in one place and 10**12 in the other :)
09:04:01 <Zyroth> sorear: I don't have a mk/build.mk.sample, either
09:04:13 <hyrax42> ?src sequence
09:04:13 <lambdabot> sequence ms = foldr k (return []) ms
09:04:14 <lambdabot>     where
09:04:14 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
09:06:57 <sorear> Zyroth: ack! this is a head source tre?
09:07:03 <sorear> er tree
09:07:30 <Zyroth> No, it's this link: http://www.haskell.org/ghc/download_ghc_66.html
09:07:31 <lambdabot> Title: GHC: Download version 6.6
09:07:40 <Zyroth> the 6.6 source
09:09:33 <sorear> oh, well. I'm not familiar with the 6.6 build system.
09:10:37 <SamB> is foldr' usefull?
09:12:09 <sorear> no, all it does is generate an "undefined symbol" error :p   (seriously - no clue)
09:12:36 <SamB> Data.List.foldr'
09:18:17 <sorear> @users
09:18:18 <lambdabot> Maximum users seen in #haskell: 322, currently: 293 (91.0%), active: 24 (8.2%)
09:19:28 <Gotaku> How do I always recompile with ghc?
09:19:45 <ookk> how can i fix this: let f = (do a <- [1..10]; print a)
09:20:06 <ookk> how can i get the [1..10] into the IO monad?
09:20:59 <Igloo> Gotaku: -fforce-recomp
09:21:16 <Igloo> ookk: a <- return [1..10], or let a = [1..10]
09:22:01 <ookk> Igloo, that will print [1..10] not print 1, print 2, ...
09:23:15 <allbery_b> sounds like you want ListT IO
09:23:40 <ookk> what is that and where can i find it?
09:23:49 <SamB> or mapM_ print [1..10]
09:24:44 <ookk> SamB, yeah that is good and well untill you want to nest such statments
09:25:01 <ookk> it does not look nice to nest alot of mapM_
09:25:01 <SamB> hmm?
09:25:04 <allbery_b> Control.Monad.List
09:25:05 <ookk> there must be a better way?
09:25:13 <SamB> ookk: what are you actually trying to do?
09:25:28 <allbery_b> it's basically a variant of the list monad (for your automatic splitting) that sits on top of another monad (in this case IO)
09:25:42 <allbery_b> but I agree, hard to tell what you're actually looking for
09:26:01 <ookk> SamB, i need to be in the IO-monad to use and IOArray, but everything else i do in that funciton is not in the IO-monad
09:26:17 <SamB> ah.
09:26:27 <SamB> what monad is it in?
09:26:45 <ookk> the list monad
09:26:55 <SamB> okay, yeah, try ListT IO
09:26:57 <ookk> i do stuff like i <- indexes;
09:27:03 <SamB> but...
09:27:09 <SamB> you'll need to change stuff.
09:27:49 <ookk> hmm what do you mean?
09:28:10 <SamB> well. actually I have no clue what you are trying to do...
09:29:21 <ookk> i do this: do i <- alist; doIO; j <- alist; doIO; returnIO
09:29:59 <ookk> you could say i want to do nested for loops
09:30:07 <allbery_b> I think your IO-doing stuff needs to be lifted if you use ListT IO (e.g. lift $ putStrLn ...)
09:30:32 <pejo> ookk, what you are describing is your solution though, which leads to this strange problem.
09:32:33 <ookk> maybe forM could be used?
09:35:22 <hpaste>  eighty pasted "nested for loops" at http://hpaste.org/280
09:35:28 <Eighty> ookk: you can do that
09:35:42 <Eighty> if you want it to look like loops in c
09:36:16 <ookk> i dont want it to look in any special way, i just want it to work :)
09:36:25 <ookk> i am trying to rewrite it like that now
09:37:30 <Eighty> if you want to do stuff at different "levels" (ie not just in the innermost loop) you'll need parantheses
09:38:22 <ookk> and i want the whole package to return IO [String]
09:38:46 <ookk> so ill have to smack a join $ infront of all the forM
09:43:33 <ookk> monads is really what pisses me off about haskell :P
09:45:29 <AStorm> ookk, uh?
09:46:30 <ookk> AStorm, when i start to use then, ghc tends to fill my display with cryptic error messages :P
09:46:56 <AStorm> :P
09:47:09 <AStorm> Because you do not know yet, how to use them.
09:47:34 <chessguy> if you want to learn haskell, you better take them on and either understand them thoroughly or quit
09:47:57 <ookk> i want to be able to use monads smoothly
09:48:04 <ookk> because i like the rest of haskell
09:48:42 <AStorm> They are simple to use smoothly, yes.
09:49:34 <ookk> ok let me write an example of something i want to be able to do
09:49:41 <ookk> !paste
09:49:42 <hpaste> Haskell paste bin: http://hpaste.org/
09:52:22 <augustss> ookk: don't worry about monads.  once you get the rest you'll see that a monad is nothing special
09:54:03 <hpaste>  ookk pasted "hmm" at http://hpaste.org/281
09:54:37 <abz> ?doc Data.Map
09:54:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
09:54:38 <SamB> the specialist thing about monads is that do { x <- p; f x } = p >>= \x -> f x
09:54:51 <chessguy> augustss, hmm. i don't know if that's fair. it may not require special syntax, but they're special in how flexible they are, and how important
09:55:04 <ookk> i know monads, its just that when i mix in the IO monad with other stuff it fucks up
09:55:21 <nostrademons> what other stuff?
09:55:25 <nostrademons> pure functions, or other monads?
09:55:28 * Beelsebob|Mini pokes about for an Igloo 
09:55:28 <glguy_> !say alive
09:55:33 <augustss> chessguy: many things in haskell are flexible
09:55:37 <ookk> nornagon, pure functions
09:55:42 <glguy_> !paste
09:55:43 <hpaste> Haskell paste bin: http://hpaste.org/
09:55:46 <chessguy> augustss, but perhaps none more so
09:56:12 <ookk> nornagon, for instance a pure function that gives a list of indexes
09:56:25 <ookk> i <- purefunction x; writeArray i x
09:56:27 <ookk> for instance
09:56:45 <nostrademons> you need to use 'return' to lift the result into the monad
09:56:47 <emu> you don't use bind on pure functoins
09:56:48 <augustss> chessguy: monads are a useful computation pattern, and it's amazing that so many things fit into monads.  but I don't think they should be glorified
09:56:58 <chessguy> augustss, i mean, even lists, which some would say are themselves fundamental to haskell, are merely an instance of monad, with a little syntactic sugar
09:57:05 <emu> let i = puref x
09:57:07 <nostrademons> i <- return $ purefunction x; writeArray i x
09:57:08 <ookk> i <- purefunction x; writeArray i x; s <- iofunction x; return s
09:57:14 <ookk> what if wanted to do that
09:57:32 <chessguy> ok, but "amazing" and "nothing special" are not the same to me :)
09:57:37 <allbery_b> you can only be "in" one monad at a time
09:57:45 <nostrademons> i <- return $ purefunction x; writeArray i x; s <- iofunction x; return s
09:57:53 <allbery_b> but there are monad transformers, which let you "stack" monads (as with ListT IO)
09:57:54 <Igloo> Beelsebob|Mini: ?
09:57:54 <Beelsebob|Mini> anyone remember where the ghc buildbot page is?
09:57:58 <emu> do people really use return like that all the time?
09:57:58 <Beelsebob|Mini> ah, an igloo
09:58:13 <Beelsebob|Mini> Igloo: I have a osx-ppc-6.6 box for you
09:58:19 <augustss> chessguy: well, i find many things in fp amazing :)
09:58:26 <Beelsebob|Mini> although it's a bit odd in the respect that it's 10.5 beta
09:58:31 <nostrademons> sometimes yes, emu.  depends on context & their particular coding style
09:58:32 <allbery_b> so you start out in ListT but can lift stuff into IO
09:58:34 <Igloo> Beelsebob|Mini: Ah, excellent, thanks!
09:58:38 <ookk> nostrademons, wont work, i <- return $ purefunction x does not set i to 1,2,3,4 it sets i to [1,2,3,4]
09:58:46 <ookk> if purefunction x gave [1,2,3,4]
09:58:47 <Beelsebob|Mini> Igloo: but could you point me at the wiki page so I can get buildbot
09:58:52 <nostrademons> right.  so what do you want it to be?
09:58:59 <sorear> Beelsebob|Mini: it's just called BuildBot iirc
09:59:07 <emu> you are trying to combine List and IO?
09:59:07 <sorear> http://hackage.haskell.org/trac/ghc/wiki/BuildBot
09:59:09 <lambdabot> Title: BuildBot - GHC - Trac
09:59:13 <allbery_b> he wants to be simultaneously in the list and IO monads
09:59:18 <sorear> Beelsebob|Mini: ^^^
09:59:19 <emu> ListT IO
09:59:21 <ookk> nostrademons, i want it to be like if it said i <- [1,2,3,4]
09:59:31 <Igloo> Beelsebob|Mini: I think I know what the linker problem is, BTW, although I'm surprised no-one else has noticed it yet. I've set tatd2 to do a 6.6 branch build tonight to see if that works
09:59:34 <emu> > do i <- [1,2,3,4] ; return $ i + 1
09:59:38 <lambdabot>  [2,3,4,5]
09:59:53 <emu> ookk: use mapM for now i'd say
10:00:15 <Beelsebob|Mini> Igloo: okay, cool
10:00:16 <ookk> emu,i <- [1,2,3]; writeArray i x; s <- iofunction x; return s
10:00:17 <Beelsebob|Mini> what was it?
10:00:24 <sorear> Beelsebob|Mini: http://hackage.haskell.org/trac/ghc/wiki/BuildBot
10:00:27 <lambdabot> Title: BuildBot - GHC - Trac
10:00:29 <emu> mapM_ (flip writeArray) $ purefunction x
10:00:33 <Beelsebob|Mini> sorear: yeh, thanks, got it
10:00:39 <ookk> emu, that is what i want to do, and [1,2,3] should be the result of a purefunction
10:00:52 <Igloo> Thanks sorear, I was just failing to find it  :-)
10:01:02 <emu> ookk: what's wrong with mapM_ or forM_?
10:01:18 <ookk> emu, what you said doesnt do this: i <- [1,2,3]; writeArray i x; s <- iofunction x; return s
10:01:32 <Igloo> Beelsebob|Mini: I suspect it never worked with -fasm, but the HEAD recently changed to using that by default (rather than -fvia-C)
10:01:36 <ookk> after i have written the array i call antother iofunction which result i return
10:01:44 <emu> and is there a reason you have to do things bass-halfwards?
10:02:01 <ookk> the array is a board
10:02:04 <Beelsebob|Mini> Igloo: okay, makes sense I guess -- just producing the wrong binary format?
10:02:06 <ookk> and i write a piece to the board
10:02:18 <ookk> then i try to solve the board for the rest of the pieces
10:02:42 <ookk> and after i have tried to solve it for the rest of the pieces i remove the piece from the board
10:02:56 <nostrademons> so, basically your purefunction returns a list of indexes that you want to set to a certain value (x)?
10:02:57 <Igloo> Beelsebob|Mini: Based on http://lists.apple.com/archives/xcode-users/2006/Oct/msg00578.html it looks like it was following incorrect docs
10:03:00 <lambdabot> Title: Re: What is the meaning of "missing indirect symbols for section (__TEXT, __symb ..., http://tinyurl.com/27c6vm
10:03:09 <ookk> board[i] = piece; solve(); board[i]=0; in an imperative language
10:03:38 <emu> except that i is a list
10:03:39 <ookk> nostrademons, my pure function returns the types of pieces i can place on the board
10:04:28 <ookk> i have already solved the problem i am trying to solve with calling solve $ board \\ piece
10:04:32 <ookk> where board is a list
10:04:34 <ookk> but it was slow
10:04:41 <emu> did you try DiffArrays?
10:04:45 <ookk> so i am trying to speed it up by using a "global" array
10:04:47 <chessguy> ookk, what are you trying to do?
10:05:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/282
10:05:21 <ookk> http://hpaste.org/282
10:05:33 <ookk> i am solving a meteor puzzle
10:05:52 <chessguy> meteor puzzle?
10:06:06 <ookk> http://shootout.alioth.debian.org/gp4/benchmark.php?test=meteor&lang=all#about
10:06:08 <lambdabot> Title: meteor-contest (new) benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/38xbh9
10:06:41 <ookk> i have "colors" [1..9] and in every step of the solver i place a piece with that color
10:07:00 <emu> DiffArrays provide a referential transparent interface to in-place updateable arrays.  the trade-off is that if you save older copies of the array, it takes progressively longer to access them.
10:07:00 <ookk> now i do call the solver with: colorsLeft \\ [colorPlaced]
10:07:05 <ookk> but i want to speed it up
10:07:15 <ookk> so i though i have an array with 9 elements
10:07:34 <ookk> that i set to 0 or 1 depending on if the color has been placed or not
10:08:02 <ookk> emu, what do you mean with "save")
10:08:04 <ookk> ?
10:08:52 <emu> ookk: let x = array (1,2) [(1,1)]; y = x // [(1,2)] in (x,y)
10:09:06 <emu> x is still the "older" copy of the array
10:09:26 <ookk> but i will have to save the array
10:09:29 <chessguy> ookk, i don't get what they mean by the "size" of a solution
10:09:37 <ookk> because i branch off a new array for each color
10:09:54 <ookk> chessguy, you make a string out of a full board
10:10:00 <ookk> where each cell contains 1..9
10:10:03 <ookk> 0..9
10:10:07 <chessguy> won't every solution be 50 characters though?
10:10:07 <ookk> and then sort it
10:10:10 <emu> right, but you are going to have to restore those if you destructively update the array
10:10:10 <ookk> yeah
10:10:17 <ookk> but "001" < "111"
10:10:22 <chessguy> ohhhh
10:10:45 <ookk> emu, that is what i want to do
10:10:58 <emu> so why not use DiffArrays?
10:10:59 <ookk> updateIOarray; call solve; restoreIOarray;
10:11:25 <ookk> i was not familiar with them until you mentioned it
10:11:36 <hyrax42> nomaware.com is dead :/
10:11:42 <emu> i think you should learn about them. you may be able to just drop them in to your functional code.
10:11:44 <hyrax42> is there a mirror of all about monads?
10:11:48 <ookk> emu, what will be the performace loss of using them?
10:12:24 <emu> ookk: the worst case is if you perform lots of updates to an array, then access a really old copy only once, then do more updates, access once, etc
10:12:43 <ookk> emu, well that is whats happening
10:12:47 <emu> not quite
10:12:56 <emu> because of this: x // [] will give you an array which is constant-time again
10:12:58 <Syzygy-> http://209.85.129.104/search?q=cache:UJ2spam_St4J:www.nomaware.com/monads/+&hl=en&ct=clnk&cd=1&client=firefox-a
10:13:00 <lambdabot> http://tinyurl.com/22755r
10:13:12 <ookk> for a lot of values do: solve (update arrray value);
10:13:14 <emu> x // <any thing> really
10:13:20 <ookk> that is whats happening in pseude code
10:13:29 <Syzygy-> You may need to do funky googly stuff to get the caching through for the rest of it.
10:13:31 <emu> yes, but the moment you backtrack, you are updating the array, and it's ok again
10:14:01 <emu> accessing older copies of the arrays without updating them causes log(n) access i believe
10:14:12 <emu> where (n) is the number of updates you performed
10:14:38 <hyrax42> emu: I think linear?
10:14:42 <ookk> will they be updated when solve returns?
10:14:58 <emu> sure. and you can always update them by doing x // [] if nothing else.
10:15:09 <hyrax42> emu: actually pretty sure it's linear... I was looking through the implementation the other day
10:15:14 <emu> yea it probably is linear, sorry
10:15:21 <emu> linaer in the number of changes you made
10:15:26 <hyrax42> yeah
10:15:30 <ookk> emu, ok i will try that out, then i can avoid the uglyness of the IO monad :O
10:15:31 <emu> (not the size of the array)
10:15:42 * allbery_b thought DiffArray was in IO
10:15:45 <ookk> Data.Array.?
10:15:48 <emu> ookk: it's very possible. i use them successfully in some array-graph implementation
10:15:52 <emu> DiffArray
10:15:53 <hyrax42> Data.Array.Diff
10:15:57 <emu> oops
10:16:05 <ookk> ok thx i will try them out
10:16:08 <glguy> I think that array updates are linear in the size of the array..
10:16:13 <hyrax42> allbery_b: it uses IO under the hood but presents functional interface
10:16:22 <hyrax42> glguy: not for Diff
10:16:31 <ookk> hyrax42, it uses IO?
10:16:33 <glguy> oh, I didn't see that you guys have moved to those
10:16:38 <ookk> so then i still have to be in teh IO-monad?
10:16:40 <hyrax42> hyrax42: behind the cutrains
10:16:46 <hyrax42> ookk: no
10:16:50 <emu> ookk: completely abstracted.  you don't touch IO
10:17:08 <ookk> ok good
10:17:36 <ookk> im gonna go eat now then try it out, thx for the help
10:17:44 <hyrax42> it silently updates the array in place, and changes old versions to be a pointer to the new version + a list [(i,e)] that represents changes
10:17:59 <hyrax42> *changes needed to get back the old version
10:18:11 <sorear> kinda like RCS
10:18:11 * Beelsebob|Mini pokes Igloo until he looks at his screen
10:18:29 <hyrax42> if you use the array in a single-threaded way, it'll be just like using an MArray of some kind, performancewise
10:19:07 <hyrax42> i.e. a//l will be O(length l)
10:19:37 <chessguy> ?type execStateT
10:19:39 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
10:20:55 <hyrax42> it would be nice if there was a way to tell it that the new version will no longer be needed so it could just do the inverse diffs
10:21:00 <hyrax42> but that wouldn't be terribly functional
10:22:14 <Syzygy-> What. The. F***?
10:22:18 <Syzygy-> http://www.randomhacks.net/articles/2007/02/02/divide-infinity-by-2
10:22:18 <chessguy> hmm. dons introduced me to this idiom the other day:
10:22:20 <lambdabot> Title: Haskell: What happens when you divide infinity by 2?, http://tinyurl.com/2lqg96
10:22:22 <Syzygy-> I'm following this
10:22:23 <chessguy> main = print =<< execStateT code initialState
10:22:23 <chessguy> code = forM_ [1..5] $ const $ do
10:22:23 <chessguy>   ...
10:22:26 <Syzygy-> And my ghci segfaults!
10:22:27 <Syzygy-> !paste
10:22:28 <hpaste> Haskell paste bin: http://hpaste.org/
10:22:57 <ookk> hyrax42, if its O(n) then i might as well use list
10:23:07 <chessguy> the const here simply discards the constant, since we just wnat to 'do ...' 5 times
10:23:09 <hyrax42> ookk: ?
10:23:12 <hpaste>  Syzygy- pasted "segfault ghc6.6" at http://hpaste.org/283
10:23:13 <ookk> hyrax42, because delete from a list is \\n
10:23:21 <hyrax42> not O(size of array), O(number of updates)
10:23:23 <ookk> O(n)
10:23:26 <chessguy> is there a way to use the number in the do loop?
10:23:41 <ookk> hyrax42, O(nr of updates) will be O(size of array) in my case
10:23:55 <hyrax42> ookk: then how could anything save you?
10:24:01 <hyrax42> if you need to do n update, you need n time
10:24:05 <hyrax42> no matter what structure you use
10:24:08 <hyrax42> *at least n time
10:24:15 <emu> ookk: restoring the arrays will take you time.. let diffarrays do the work
10:24:36 <ookk> hyrax42, yeah but setting array[color] = 0 is O(1)
10:24:42 <ookk> list \\ color is O(n)
10:24:57 <emu> diffarray // [(color,0)] is O(1)
10:25:03 <hyrax42> emu: ++
10:25:08 <hyrax42> ookk: just wrist it and profile
10:25:10 <hyrax42> *write
10:25:26 <chessguy> ?seen dons
10:25:26 <lambdabot> dons is in #happs, #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 4h 15m 25s ago.
10:25:44 <chessguy> oh, it's probably the middle of the night for him
10:25:44 <ookk> emu, ok then its good
10:25:47 <chessguy> ?localtime dons
10:25:50 <lambdabot> Local time for dons is Sun Feb  4 05:20:50 2007
10:26:08 <ookk> emu, so that datastructure understands that it should do inverse updates?
10:26:10 <ookk> when i return?
10:26:33 <emu> it's completely referential transparent
10:26:35 <hyrax42> ookk: no it doesn't
10:27:05 <emu> let x = array; y = fiddle with x; now x is still the original array
10:27:05 <ookk> im confused because hyrax42 says it will be O(nr of updates) and emu says it will be O(1)
10:27:17 <emu> ookk: accessing x will be O(nr of updates)
10:27:21 <Beelsebob|Mini> @seen Igloo
10:27:21 <lambdabot> Igloo is in #haskell.hac07, #ghc, #darcs and #haskell. I last heard Igloo speak 18m 47s ago.
10:27:26 <emu> accessing y will be O(1)
10:27:31 <hyrax42> ookk: O(nr of upates) as in if you change 11 entries in the array, it'll be O(11)
10:27:45 <emu>  ... and you accses the original array
10:28:02 <hyrax42> you can have more than one update in the list array\\[(i1, e1), (i2,e2),...]
10:28:03 <ookk> emu, so if i access it after my solver has called itself 10 times?
10:28:16 <emu> access the original?
10:28:34 <emu> but if you do z = fiddle with x, then z is O(1) access and update
10:29:25 <emu> forall x that are diffarrays. (x // [...]) has O(1) access and update
10:29:32 <Eighty> if i have a function f::a->IO a, and a value x::IO a that i want to feed it with, i can write do x'<-x; f x', or much much rather, x>>f. can i do something similar if i wanted to do the same with a function g::a->a->IO a?
10:29:50 <Eighty> i meant of course >>=
10:29:59 <hyrax42> ookk: you may prefer to look at STUArray and runSTArray if you want to handle inverse updates yourself
10:29:59 <bos> @hoogle liftM_
10:30:00 <lambdabot> No matches found
10:30:06 <bos> @hoogle liftM
10:30:07 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
10:30:07 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
10:30:07 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
10:30:12 <emu> @src liftM2
10:30:13 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:30:24 <Eighty> emu: thanks
10:30:38 <emu> in Control.Monad
10:30:58 <cinimod> Does anyone have any advice on fixing a space leak? http://www.haskell.org/pipermail/haskell-cafe/2007-February/022098.html
10:31:00 <lambdabot> Title: [Haskell-cafe] Space Leak Help, http://tinyurl.com/ytokbr
10:31:28 <cinimod> lambdabot never ceases to amaze me
10:34:13 <sorear> cinimod: the problem isn't that the list is eagerly evaluated, the problem is 'l' holds a ref to the beginning of the list.
10:34:44 <sorear> this is one of those space leaks best fixed with optimistic evaluation strategies ... too bad they don't exist
10:35:20 <dcoutts> cinimod, I might do a direct recusive solution
10:35:21 <cinimod> sorear: thanks but I know what the problem is but I'm not sure how to fix it
10:35:27 <Igloo> Beelsebob|Mini: Are you prodding me re messages or something else?
10:35:49 <Beelsebob|Mini> Igloo: yes
10:35:50 <dcoutts> cinimod, recurse down the list counting the length and then emit the right number of 0's when you get to the end.
10:36:06 <cinimod> dcoutts: ok I'll go and see what I can come up with
10:36:24 <dcoutts> cinimod, that should be lazy and not hold onto the head of the list
10:36:41 <cinimod> dcoutts: that's similar to my idea of using zipWith [1..]
10:36:48 <Gotaku> I can't seem to get my list to use bytestring without losing it's tail recursion...
10:36:50 <dcoutts> cinimod, I guess so
10:36:53 <sorear> gah.  why does higher order + polymorphic = space leak :(
10:37:26 <dcoutts> sorear, it doesn't necessarily, eg it could be done with a foldr
10:37:42 <chessguy> !paste
10:37:42 <hpaste> Haskell paste bin: http://hpaste.org/
10:37:48 <cinimod> and I thought I was clever by using foldl'
10:38:44 <dcoutts> cinimod, for this case I think you want foldr because you're producing a list, otherwise you'll force the whole list immediately
10:39:34 <cinimod> dcoutts: my foldl' is ok. I don't use it for padding. I should have said.
10:39:40 <dcoutts> ok
10:40:20 <chessguy> @tell dons You showed me this idiom the other day: http://hpaste.org/284 . To modify this to use the Int from the [1..n] list, would i do something like this? code = forM_ [1..5] $ \x -> do { somethingWithx }
10:40:21 <lambdabot> Consider it noted.
10:40:27 <yaRcimsoC> hi
10:40:33 <cinimod> dcoutts: I think your solution of recursion is a better bet than mine of using zipWith. I'll have a go and see how I get on.
10:41:10 <hyrax42> chessguy: I've seen that commnoly recently
10:41:30 <chessguy> with the do inside the lambda?
10:41:36 <hyrax42> forM_ [1..n] $ \i -> do { -- use i as loop variable }
10:41:40 <hyrax42> chessguy: pretty sure
10:41:57 <hyrax42> that I saw it somewhere either in some of dons's code or in some of the hpaste code
10:42:03 <yaRcimsoC> Is this a successor to Miranda?
10:42:27 <hyrax42> yaRcimsoC: I think in some sense... miranda and gofer :?
10:42:28 <chessguy> yaRcimsoC, you mean haskell?
10:42:38 <yaRcimsoC> yes, I mean haskell
10:42:43 <emu> i think the miranda people moved to haskell over 10 years ago
10:42:43 <augustss> Haskell predates gofer
10:43:00 <hyrax42> augustss: I did not know that
10:43:00 <yaRcimsoC> omg
10:43:09 <sorear> it's not really a "successor", but it has killed miranda the way C killed Pascal
10:43:12 <yaRcimsoC> I think I still list Miranda on my CV
10:43:20 <SamB> yes
10:43:21 <yaRcimsoC> hehehe
10:43:27 <SamB> miranda is like gone...
10:43:28 <chessguy> yaRcimsoC, the short answer is what hyrax42 said: yes, to some extent. there's a "history of haskell" linked from the main www.haskell.org page
10:43:33 <hyrax42> augustss: but monads were introduced to gofer first?
10:43:34 <yaRcimsoC> I'm going to have to look into this Haskell malarkey
10:43:37 <SyntaxNinja> @seen shapr
10:43:37 <lambdabot> I saw shapr leaving #happs and #haskell 18h 59m 4s ago, and .
10:44:03 <Heffalump> why do we have a backwards CosmicRay?
10:44:08 <yaRcimsoC> I wrote some pretty awesome stuff in Miranda, back in the day
10:44:14 <augustss> hyrax42: the special syntax for monads came in gofer (hugs?) first.  but not the concept
10:44:17 <yaRcimsoC> Heffalump: someone has my nick already
10:44:26 <yaRcimsoC> I'm a visitor from the planet ircnet
10:44:30 <emu> > forM [1..10] $ do \i -> i + 1
10:44:31 <Beelsebob|Mini> Igloo: that appears to be working now, I'll check on it later
10:44:31 <lambdabot>   Not in scope: `forM'
10:44:36 <emu> whoops
10:44:36 <hyrax42> hmmm
10:44:44 <hyrax42> I did not know that hugs came from gofer
10:44:47 <Heffalump> yaRcimsoC: /whois suggests both are you
10:44:55 <Heffalump> oh, that's a whowas
10:45:03 <yaRcimsoC> Yes, I changed my name
10:45:04 <Heffalump> and you're not John Goerzen :-)
10:45:08 <sorear> yaRcimsoC: heh. CosmicRay, John Georzen, is a very veteran Haskeller
10:45:24 <yaRcimsoC> I am sooo annoyed someone stole my nick before I even used this network
10:45:41 <yaRcimsoC> I even have the domain name to prove it (www.cosmicray.co.uk - don't laugh at the pic)
10:45:48 <cinimod> hugs = haskell users gofer system
10:45:49 <yaRcimsoC> grrr
10:45:53 <hyrax42> augustss: thanks for clarification.  I should skim the history paper at some point
10:45:53 <dcoutts> @:paste
10:45:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:46:02 <emu> perhaps go for InterstellarParticle?
10:46:04 <sorear> @seen CosmicRay
10:46:05 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 1d 22h 44m 42s ago, and .
10:46:33 <yaRcimsoC> The thief
10:46:40 <yaRcimsoC> hmmph
10:46:46 <Heffalump> yaRcimsoC: how could we not laugh at that picture? :-)
10:46:47 <hyrax42> cinimod: for some reason I just assumed it was golfer as it is in pugs
10:47:02 <hyrax42> and just though it was some quirky name handed down in history for some strange reason
10:47:06 <hyrax42> and that pugs was an hommage
10:47:26 <hyrax42> *golfing
10:47:29 <hpaste>  dcoutts pasted "hopfully non-leaking version of cinimod's pad function" at http://hpaste.org/285
10:47:46 <yaRcimsoC> I want my nick :-(
10:48:55 <_roconnor> @type readFile
10:48:56 <lambdabot> FilePath -> IO String
10:49:06 <cinimod> dcoutts: thanks. I'm going to have a beer now. I'll try it out tomorrow.
10:49:14 <_roconnor> @docs readFile
10:49:14 <lambdabot> readFile not available
10:49:26 <_roconnor> readFile isn't lazy is it?
10:49:35 <sorear> _roconnor: it reads a file (lazily, but that's not important now)
10:49:48 <hyrax42> ?. docs index readFile
10:49:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:49:51 <roconnor> will readFile /dev/urandom work?
10:49:53 <emu> but only if you yell at it
10:49:54 <sorear> roconnor: yes
10:49:59 <roconnor> oh nice
10:50:13 <hyrax42> ?index raedFile
10:50:14 <lambdabot> bzzt
10:50:21 <hyrax42> ?index readFile
10:50:22 <lambdabot> System.IO, Prelude
10:50:33 <hyrax42> ah, that's why the composition didn't work
10:50:47 <sorear> roconnor: it uses some nasty tricks with unsafeInterleaveIO to be lazy, and bites newbies frequently with locking problems
10:50:53 <hyrax42> ?index groupBy
10:50:54 <lambdabot> Data.List
10:51:08 <hyrax42> ?. docs index groupBy
10:51:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:51:17 <sorear> and it's slow - use Data\.ByteString\.(Lazy\.)?\.readFile instead
10:51:18 <hyrax42> d'oh :/
10:51:37 <abz> does anyone know of a key-value map implementation in GHC?
10:51:42 <sorear> Data.Map
10:51:49 <sorear> @source Data.Map
10:51:50 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
10:51:51 <emu> Data.Map is very nice
10:52:04 <emu> i use Data.Set and Data.Map a lot
10:52:11 <abz> arrr...thanks.
10:52:12 <hyrax42> IntMap is also there
10:52:12 <sorear> it's in the standard libs, just import qualified Data.Mapas M
10:52:20 <hyrax42> for when your keys are Ints
10:52:22 <emu> yes, if your keys are ints, use IntMap
10:52:29 <abz> when would you use Set of Map?
10:52:29 <roconnor> can I use readFile "/dev/urandom" from the GHCi prompt?
10:52:30 <Igloo> Beelsebob|Mini: OK, cool, thanks
10:52:44 <sorear> abz: Set a == Map a () , just faster.
10:52:53 <sorear> err, Map a Void
10:52:57 <hyrax42> sorear: is it really faster?
10:53:04 <sorear> laziness can be a little confusing :)
10:53:08 <abz> ?doc Data.Map
10:53:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
10:53:17 <abz> right.
10:53:19 <sorear> hyrax42: why would it be slower?
10:53:19 <hyrax42> that seems wrong to me :?
10:53:48 <hyrax42> I would expect at best Map a () is same as Set a no?
10:53:54 <emu> roconnor: if you like garbage spewing
10:53:58 <hyrax42> ?src Data.Set
10:53:59 <lambdabot> Source not found. stty: unknown mode: doofus
10:54:04 <roconnor> it works great!
10:54:05 <emu> roconnor: try, do s <- readFile; putStrLn (take 1 s)
10:54:06 <hyrax42> ?fptools Data.Set
10:54:07 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
10:54:11 <newsham> http://sat.inesc-id.pt/~pocm/minority/index.php/2007/02/03/religious-cults-are-never-enough/
10:54:15 <roconnor> Prelude> x <- readFile "/dev/urandom"
10:54:15 <roconnor> Prelude> head x
10:54:15 <roconnor> 'B'
10:54:16 <lambdabot> Title: The Minority Blog Â» Religious Cults are Never Enough&#8230;, http://tinyurl.com/2mmsoe
10:54:21 <sorear> hyrax42: it's more specialized, so intuitively Set should be faster - however I haven't benchmarked it
10:54:24 <newsham> (yes, it is relevant)
10:54:41 <emu> oh ok, i thought you might type readFile by itself=)
10:54:57 <hyrax42> I'm thinking that the limited set of operations could allow a different implemenation
10:55:00 <hyrax42> that may be faster
10:55:04 <SamB> emu: doesn't print un-garbage it anyway?
10:55:08 <SamB> also...
10:55:14 <emu> i guess. \123 etc
10:55:22 <SamB> doesn't ghci by default not print the value returned from an IO expression?
10:55:35 <emu> no;)
10:55:38 <emu> try it
10:55:38 <chessguy> ?hoogle (a,b) -> (c,d)
10:55:38 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:55:49 <chessguy> ?hoogle (a,b) -> (a,b)
10:55:50 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
10:55:51 <lambdabot> Data.Graph.Inductive.Query.Monad.mapSnd :: (a -> b) -> (c, a) -> (c, b)
10:55:51 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:55:57 <sorear> hyrax42: Set implements the same operations Map does, and vice versa
10:55:57 <emu> ghci by default prints the result of an IO expr, i think
10:56:07 <sorear> emu: correct for newish ghci
10:56:09 <SamB> Prelude> readFile "/dev/urandom"
10:56:09 <SamB> Prelude>
10:56:16 <hyrax42> chessguy: a function of that type cannot exist
10:56:31 <emu> i'm using 6.6
10:56:35 <chessguy> hyrax42, say what?
10:56:42 <hyrax42> (a,b) -> (c,d)
10:56:46 <sorear> emu: my 6.7 and 6.6 do, my 6.4.2 doesn't.
10:56:54 <chessguy> hyrax42, why on earth not?
10:57:03 <hyrax42> well not polymorphically anyway
10:57:07 <sorear> sure it can. unsafeCoerce#
10:57:23 <hyrax42> sorear: cheater
10:57:28 <chessguy> \p -> ((fst p), (snd p))
10:57:35 <emu> parametrickity
10:57:40 <sorear> hyrax42: undefined --cheating?
10:57:41 <chessguy> @type \p -> ((fst p), (snd p))
10:57:43 <lambdabot> forall a b. (a, b) -> (a, b)
10:58:01 <chessguy> hyrax42, ^^
10:58:14 <emu> i don't see c,d
10:58:15 <hyrax42> chessguy:  that's (a,b)->(a,b)
10:58:31 <hyrax42> :t \(a,b) -> (undefined, undefined)
10:58:31 <chessguy> well, fine, but the c,d just means they don't HAVE to be the same type
10:58:33 <lambdabot> forall a b a1 a2. (a, b) -> (a1, a2)
10:58:38 <emu> chessguy: no, this is important
10:58:48 <chessguy> emu, i'm trying to understand
10:58:58 <sorear> chessguy: you want Control.Arrow.***
10:59:09 <emu> just think of it naturally: if you could have a function (a,b)->(c,d) where would c and d  come from?
10:59:28 <sorear> > (***) (\x -> x ++ x) (\y -> 3 + y) ("foo", 10)  -- chessguy
10:59:29 <lambdabot>  ("foofoo",13)
10:59:38 <chessguy> emu, a function (a->c) and a function (b->d
10:59:39 <chessguy> (
10:59:49 <sorear> chessguy: *** wanted?
10:59:55 <hyrax42> but you don't have those, you only have an (a,b)
11:00:00 <emu> chessguy: then the type is (a->c,b->d) -> (a,b) -> (c,d)
11:00:15 <chessguy> hyrax42, well, they could be built into the function
11:00:26 <chessguy> besides, what about currying
11:00:33 <emu> chessguy: how bout this: Premise, A and B are true.  Prove propositions C and D.
11:00:34 <hyrax42> or (a -> c) -> (b -> d) -> (a,b) -> (c,d)
11:00:37 <sorear> chessguy: is (***) what you want?
11:00:46 <chessguy> emu, take that type and pass it an initial tuple
11:00:56 <chessguy> emu, what type does the resulting curried function have?
11:01:13 <chessguy> sorear, i don'tknow anything about arrows
11:01:22 <hyrax42> it has type (a,b) -> (c,d) but they are not universally quantified
11:01:37 <chessguy> i never said it had to be universally quantified
11:01:48 <sorear> chessguy:
11:01:49 <emu> chessguy: that's like saying: A->C, B->D are true, now assume A and B are true.  Prove C and D.
11:02:22 <chessguy> emu, so what's the problem?
11:02:24 <rjseagraves> Does Haskell have a set of standard String functions beyond the words/unwords/lines/unlines functions in the Prelude?
11:02:29 <sorear> /# @let function_chessguy_seems_to_want = (***) :: (a -> b) -> (c -> d)
11:02:30 <hyrax42> chessguy: type variables are implicitly universally quantified
11:02:32 <emu> chessguy: you can't prove C and D without the context
11:02:32 <chessguy> use A->C to prove C, and use B->D to prove D
11:02:33 <sorear> rjseagraves: nope
11:02:40 <hyrax42> sorear: :p
11:02:40 <rjseagraves> oh
11:02:46 <emu> chessguy: the second statement is ok. the first is not.
11:02:49 <sorear> @let function_chessguy_seems_to_want = (***) :: (a -> b) -> (c -> d) -> (a,c) -> (b,d)
11:02:51 <lambdabot> Defined.
11:03:02 <chessguy> ok, so maybe what i want is:
11:03:14 <sorear> > function_chessguy_seems_to_want (*2) (++"foo")  (12, "bar")
11:03:16 <lambdabot>  (24,"barfoo")
11:03:19 <chessguy> ?hoogle (a,b) -> (a -> c) -> (b -> d) -> (c,d)
11:03:20 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:03:22 <hyrax42> chessguy: I think what you want is (***) fro Control.Arrow
11:03:30 <augustss> @djinn  (a -> b) -> (c -> d) -> (a,c) -> (b,d)
11:03:31 <lambdabot> f a b (c, d) = (a c, b d)
11:03:49 <roconnor> wow, it's true
11:03:54 <emu> ?pl \a b (c , d) -> (a c, b d)
11:03:55 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
11:04:03 <emu> there you go. the function you want ^
11:04:07 <sorear> hyrax42: he's already said that won't do, because: <chessguy> sorear, i don'tknow anything about arrows
11:04:19 <roconnor> if you bet too much money, even when the odds are in your favour, you can still end up with your funds going to 0.
11:04:23 <hyrax42> but that's a stupid reason
11:04:34 <roconnor> (betting as a fraction of your bankroll)
11:04:39 <roconnor> I'm surprised
11:04:43 <hyrax42> I don't know anything about arrows, but I (ab)use (***) (&&&) &c. all the time
11:04:44 <chessguy> sorear, don't twist my words
11:04:49 <emu> roconnor: variance?
11:05:05 <chessguy> i was responding to your question of whether that was what i wanted. i don't know, because i don't know arrows. i didn't say i refused to use it
11:05:09 <hyrax42> the only arrow I understand is (->)
11:05:15 <roconnor> http://en.wikipedia.org/wiki/Kelly_criterion
11:05:20 <chessguy> sorear, i'd appreciate if you didn't put words in my mouth
11:05:31 <roconnor> ``Over-betting beyond that suggested by Kelly is counter-productive as the long run return will fall, dropping to zero (with the loss of all the bankroll) when the Kelly bet is doubled.''
11:05:43 <roconnor> I just ran some haskell simulations
11:05:59 <roconnor> Prelude Data.Bits> let f z x = if x then (1+(z*(1.1))) else (1-z)
11:05:59 <roconnor> Prelude Data.Bits> (scanl (*) 1 (map (f 0.1) bits))!!60000
11:05:59 <roconnor> 3.864815465285859e-21
11:05:59 <roconnor> Prelude Data.Bits> (scanl (*) 1 (map (f 0.05) bits))!!60000
11:05:59 <roconnor> 3.9274482822923435e25
11:06:01 <sorear> oops
11:06:18 <hyrax42> > (+3) *** (*7) $ 8
11:06:19 <lambdabot>   add an instance declaration for (Num (b, b'))
11:06:22 <roconnor> (bits is an infinite stream of random bools generated from /dev/urandom)
11:06:29 <sorear> hyrax42: &&&
11:06:34 <hyrax42> d'oh
11:06:48 <hyrax42> yeah I confuse them :/
11:06:51 <roconnor> The game is fair, and pays 1.1x when you win
11:06:55 <sorear> me too
11:07:07 <hyrax42> ?type (***)
11:07:09 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:07:23 <roconnor> if you bet 10% of your bankroll after 60000 round you have < 1e-20 left
11:07:25 <hyrax42> right yeah
11:07:36 <hyrax42> which is the one chessguy is after, it seems like
11:07:38 <roconnor> if you bet 5% of your bankroll after 60000 round you have > 1e25 left
11:07:40 <nomeata> Hmm. Can we extend ghc to replace a function thatâs called djinn by djinnâs output for the expected type of that function? :-)
11:07:45 <roconnor> crazy!
11:08:07 <sorear> nomeata: google "untypechecker", Oleg's done it
11:08:14 <sorear> @google detypechecker
11:08:15 <lambdabot> No Result Found.
11:08:18 <sorear> @google untypechecker
11:08:20 <lambdabot> No Result Found.
11:08:23 <Cale> rjseagraves: It has Data.List
11:08:31 <sorear> gah, I forgot the name
11:08:40 <Cale> rjseagraves: and Data.Char
11:08:56 <chessguy> anyway, what i actually want is (a,a) -> (a->b) -> (b,b)
11:08:59 <Cale> and taken together, you can write lots of string functions with those
11:09:10 <sorear> flip (join (***))
11:09:16 <Cale> @type join (***)
11:09:18 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:09:27 <Cale> right :)
11:09:41 <chessguy> that's meaningless to me
11:09:52 <chessguy> what the heck is a (b, b) (c,c)?
11:09:55 <Cale> a = (->)
11:10:16 <sorear> (->) (b,b) (c,c)  ==>  (b,b) -> (c,c)
11:10:20 <Cale> > join (***) (+1) (10,20)
11:10:22 <lambdabot>  (11,21)
11:10:23 <chessguy> ?hoogle (a->b)
11:10:26 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
11:10:26 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
11:10:26 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
11:10:29 <chessguy> ?hoogle a->b
11:10:31 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
11:10:31 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
11:10:31 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
11:11:11 <chessguy> @type join
11:11:13 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:11:13 <hyrax42> chessguy: pretty much every function has type a -> b
11:11:38 <Cale> Oh, and we're using join in the (->) e monad.
11:11:38 <sorear> chessguy: join in (->) monad :: (a -> a -> b) -> (a -> b)
11:11:42 <chessguy> join is the arrow equivalent of >>= ?
11:11:47 <Cale> no
11:11:52 <sorear> @djinn (a -> a -> b) -> (a -> b)
11:11:53 <lambdabot> f a b = a b b
11:11:59 <Cale> join is monadic, doesn't have anything to do with arrows
11:12:13 <Cale> x >>= f = join (fmap f x)
11:12:21 <hyrax42> sometimes I think haskell's problem is it's too polymorphic
11:12:28 <sorear> somehow I think we shouldn't be playing golf with chessguy
11:12:32 <emu> SML is thatta way
11:12:33 <Cale> hehe
11:12:43 <Cale> @djinn (a,a) -> (a->b) -> (b,b)
11:12:43 <lambdabot> f (_, a) b = (b a, b a)
11:12:46 <chessguy> sorear, golf?
11:12:50 <Cale> haha
11:12:57 <hyrax42> emu: hey I said "sometimes"
11:13:09 <Cale> That result could be improved.
11:13:11 <sorear> chessguy: dunno why they call it that, but - optimizing code for brevity.
11:13:18 <Cale> @djinn a -> a -> (a->b) -> (b,b)
11:13:19 <lambdabot> f _ a b = (b a, b a)
11:13:20 <hyrax42> and problem as regards people learning it
11:13:23 <Cale> interesting
11:13:41 <chessguy> whatever, you guys are obviously more interested in pointing and laughing than helping newbies today
11:13:43 <hyrax42> you have all these super general functions that do all sorts of different things (especially the stuff in Control.Monad) depending on context
11:13:44 <sorear> Cale: associativity
11:13:46 <emu> @djinn a -> a -> a -> a -> a
11:13:46 <lambdabot> f _ _ _ a = a
11:13:49 <Cale> I thought it tried to maximise the number of things which it used.
11:14:40 <Cale> Er, I hope he didn't take my laugh as being directed at him.
11:15:10 <Cale> It was directed at djinn's half-cleverly ignoring the first element of the pair.
11:17:52 <fasta_> Is there any way to see what instances for MonadCont there are in scope? In particular I want to see whether the newtype deriving actually works.
11:18:48 <int-e> sorear: the objective of golf is to minimize the number of strokes over a golf course; minimizing the number of characters to accomplish a certain programming task is not that different ;)
11:18:49 <abz> Is there a way to build a Map from a list at compile time? This Map doesn't change through the entire execution of the program.
11:19:36 <Heffalump> the compiler doesn't really give any guarantees of what it'll do
11:19:36 <dcoutts> abz, not really
11:19:53 <abz> not even using TH?
11:19:56 <Heffalump> make it a CAF (i.e. a top level definition) will mean it _could_ do it at compile time, but I don't think it will.
11:20:15 <dcoutts> abz, the Map data constructors are not exported, so no.
11:22:12 <abz> Thanks.
11:22:56 <dcoutts> abz, what type of Map is it?
11:23:47 <hpaste>  Abz pasted "key value map" at http://hpaste.org/286
11:24:31 <dcoutts> abz, of if it's your own map then you can certainly use TH to make a constant one
11:24:58 <abz> reallly...
11:24:59 <emu> that reminds me, i wanted to import a dictionary (set of words) at compile-time, but i couldn't figure out how to do that
11:25:22 <Heffalump> if TH builds a structure at compile-time, surely you could find some way to turn that into a splice?
11:25:24 <dcoutts> abz, the only reason you can't do it with Data.Map is that it doesn't export the constructors
11:25:41 <sorear> Data.Map really should
11:25:47 <emu> Map.fromList ? =)
11:25:48 <Heffalump> no it shouldn't!
11:26:05 <dcoutts> sorear, being able to mess with the map isn't a good idea
11:26:10 <dcoutts> it has invariants
11:26:17 <sorear> for instance yesterday I had a use for mapMonotonicWithValues, which doesn't exist and cannot be written in a sufficiently lazy manner using the API
11:27:10 <nomeata> Hi. Does anyone know of a library or program that I can use to read out a PDF fileâs table of content (which usually appears in the sidebar)? Haskell libraries preferred :-)
11:27:27 <dcoutts> nomeata, parsec? :-)
11:27:38 <nomeata> :-)
11:27:40 <sorear> ByteString.readFile !
11:27:47 <dcoutts> nomeata, there are Haskell libs for writing but not reading pdfs
11:28:02 <emu> hmm, PDF spec is open =)
11:28:07 <SamB> it wouldn't be too hard to do it yourself
11:28:19 <nomeata> Well, I aready downloaded the spec, but I havenât looked into it yet.
11:28:20 <sorear> dcoutts: I suppose the Preferred Way would be to submit a patch adding mapMonotonicWithValues? :)
11:28:27 <abz> Thank guy. I'm going to try improving my mapper with TH.
11:28:33 <dcoutts> sorear, perhaps yes.
11:29:27 <SamB> ... except I'm not sure how you duplicate a handle (can you?) in Haskell...
11:29:50 <allbery_b> @go haskell pdf library
11:29:52 <lambdabot> http://www.alpheccar.org/en/posts/show/57
11:29:52 <lambdabot> Title: Haskell, PDF and Penrose Tilings
11:30:02 <sorear> SamB: join (,) will do the trick :)
11:30:10 <SamB> sorear: silly
11:30:32 <sorear> @hoogle dup
11:30:33 <lambdabot> Control.Concurrent.Chan.dupChan :: Chan a -> IO (Chan a)
11:30:33 <lambdabot> Control.Concurrent.STM.TChan.dupTChan :: TChan a -> STM (TChan a)
11:30:33 <lambdabot> Language.Haskell.Syntax.HsFieldUpdate :: HsQName -> HsExp -> HsFieldUpdate
11:30:46 <SamB> @hoogle Handle -> IO Handle
11:30:47 <lambdabot> No matches, try a more general search
11:30:53 <SamB> @hoogle Handle -> IO (Handle, Handle)
11:30:54 <lambdabot> No matches, try a more general search
11:31:03 <SamB> @where hoogle
11:31:04 <lambdabot> http://www.haskell.org/hoogle
11:31:05 <sorear> SamB: system.posix.io.dup      dup :: Fd -> IO Fd
11:31:13 <SamB> sorear: that won't do it!
11:31:20 <SamB> well.
11:31:26 <SamB> depends, I guess...
11:31:43 <sorear> SamB: also see fdToHandle and handleToFd
11:31:48 <SamB> hmm.
11:31:56 <SamB> now, do you really think Parsec is the best way?
11:32:01 <allbery_b> you can use System.Posix.IO to change a Handle to an Fd, dup it, and convert both back to Handles
11:32:11 <allbery_b> not sure that's especially *wise*
11:32:30 <nomeata> data PDF = ... deriving (Read, Show) â would be cool :-)
11:32:37 <allbery_b> especially if you're writing
11:32:39 <SamB> allbery_b: well, if you want to lazilly read from different offsets in the same file at the same time...
11:33:03 <sorear> SamB: dup'd handles share offsets iirc.
11:33:12 <allbery_b> tht would be safe, might lose out on buffering if they happen to be at nearby offsets
11:33:15 <SamB> sorear: really?
11:33:23 <allbery_b> whch is at most a slight waste of space
11:33:33 <sorear> SamB: dup(2) saz:        refer to the same open file description (see open(2)) and thus share file offset and file status flags; for  example,
11:33:35 <allbery_b> (well, and rereading the same thing)
11:33:36 <SamB> ohl
11:33:38 <SamB> true
11:33:50 <allbery_b> but you'd have that problem in any language
11:33:56 <fasta> How can I see what instances of MonadCont there are defined in the current module manually?
11:34:06 <SamB> what did I want then?
11:34:40 <sorear> SamB: see ndm's DeferredBinary perhaps?
11:34:52 <sorear> (it does lazy random access too)
11:34:56 <SamB> oooh
11:35:01 <SamB> does it support text?
11:35:17 <sorear> SamB: text `isASubtypeOf` binary
11:35:40 <SamB> @where DeferredBinary
11:35:41 <lambdabot> I know nothing about deferredbinary.
11:35:47 <SamB> neither does google
11:35:51 <SamB> @spell DeferredBinary
11:35:52 <lambdabot> Deferred Binary Deferred-Binary Defrauding
11:36:05 <SamB> hmm.
11:36:19 * sorear greps logs
11:36:23 <SamB> well, it does find one log entry
11:36:47 <SamB> thankfully not this one
11:39:18 <SamB> @google ndm deferred binary
11:39:21 <lambdabot> http://neilmitchell.blogspot.com/
11:39:22 <lambdabot> Title: Neil Mitchell's Haskell Blog
11:39:30 <SamB> apparantly not yet released?
11:44:36 <beelsebob> impressive
11:45:40 <beelsebob> ghc's config script thinks my mac mini is an i386-unknown-mingw32
11:45:40 <beelsebob> when it's a PPC machine
11:45:40 <beelsebob> running OS X
11:46:17 <monomorph> you've been downgraded :)
11:46:44 <beelsebob> Igloo: it buggered up with impressive style -- it thinks it's windows!
11:48:32 <Igloo> beelsebob: Oh, that's interesting
11:48:43 <monomorph> It's impressive to get both cpu and os wrong :)
11:49:28 <Igloo> beelsebob: Do you know why it isn't finding ghc?
11:50:52 <Igloo> Oh, I see why. Bah.
11:51:02 <beelsebob> Igloo: not sure, it's in the path
11:51:18 <beelsebob> might be trying to find a version that works for that system
11:51:21 <Igloo> (I see why it's trying to build as Windows, not why it can't find ghc)
11:51:32 <beelsebob> why's that?
11:51:47 <beelsebob> it could be looking for ghc on the cygpath
11:52:00 <Igloo> beelsebob: You can see the path it's using in http://darcs.haskell.org:8010/tatd2-osx-ppc-6.6-6.6/builds/0/step-configure/0
11:52:03 <lambdabot> Title: Log File contents, http://tinyurl.com/2dzbbp
11:52:09 <nomeata> Great! pdftk file.pdf dump_data give nicely parsable information about the PDF
11:52:25 <beelsebob> I wonder
11:52:33 <beelsebob> it may need a restart
11:53:48 <beelsebob> Igloo: feel free to try again once you fix it thining it's windows
11:53:52 <beelsebob> it should have the right path now
11:57:11 <Igloo> beelsebob: re "why's that?": Mutable state - we need a Haskell buildbot  :-)
11:57:14 <astrolabe> Igloo: could you explain how to create a proposal for this please?  ie who should I send it to? http://hackage.haskell.org/trac/ghc/ticket/1120
11:57:16 <lambdabot> Title: #1120 (randomR is non-uniform for most ranges) - GHC - Trac
11:57:35 <beelsebob> Igloo: lol
11:59:22 <Igloo> astrolabe: There's a wiki page somewhere describing the process, but I am incapable of finding anything on the wiki
11:59:40 * Igloo can't even find this page with google any more
11:59:52 <astrolabe> Igloo: on haskell.org?  I'll have a browse, thanks
12:01:03 <astrolabe> http://www.haskell.org/haskellwiki/Category:Proposals  I guess
12:01:05 <lambdabot> Title: Category:Proposals - HaskellWiki
12:01:43 <Igloo> Hmm, that's not the one I'm thinking of
12:01:59 <Igloo> Although now I think about it I might have been searching the wrong wiki
12:02:08 <Igloo> astrolabe: Aha, http://www.haskell.org/haskellwiki/Library_submissions
12:02:10 <lambdabot> Title: Library submissions - HaskellWiki
12:02:55 <astrolabe> Igloo: thanks again
12:06:16 <rjseagraves> Anybody up for a monad question?
12:06:58 <astrolabe> They probably will be if you ask it
12:07:08 <rjseagraves> I have a [Maybe(Data.Map String Foo)] that I want to take the union of (or return Nothing if any member is nothing)
12:07:20 <rjseagraves> and I'm wondering if there is a way to do this with foldl & >>=
12:07:28 <rjseagraves> rather than totally hand-coding it
12:08:08 <monomorph> foldM will probably get you far
12:08:47 <monomorph> @type Control.Monad.foldM
12:08:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:09:06 <monomorph> Darn.
12:09:54 <monomorph> @type Control.Monad.ap
12:09:56 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
12:11:25 <int-e> @type sequence
12:11:27 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:11:37 <int-e> > sequence [Just 1, Just 2]
12:11:39 <lambdabot>  Just [1,2]
12:11:45 <int-e> > sequence [Just 1, Nothing, Just 3]
12:11:47 <lambdabot>  Nothing
12:12:00 <rjseagraves> cool
12:12:02 <rjseagraves> thanks
12:12:06 <monomorph> Actually foldM is not too bad.  use b = m a
12:12:09 <cinema> +-+
12:13:08 <SamB> > length "cpu/spc/spcbind.obj"
12:13:10 <lambdabot>  19
12:19:11 <Cale> @djinn ((((p -> k) -> k) -> ((q -> k) -> k)) -> ((p -> k) -> k)) -> ((p -> k) -> k)
12:19:12 <lambdabot> f a b = a (\ c _ -> c b) b
12:21:04 <monomorph> reading the The Monad Reader article on boolean logic? :)
12:22:55 <Cale> Nope, I've just been talking with my friend about continuations all morning.
12:36:10 <mwolak> is it tricky to get the zlib bindings to work on windows?
12:37:25 <dcoutts> mwolak, I've not tried, but I expect it's not that hard
12:37:37 <dcoutts> all you'd need is the header files and lib etc
12:37:58 <mwolak> thanks... *crosses fingers*
12:38:14 <dcoutts> grab a windows dev zlib .zip file that contains the .dll .lib/.a and .h files
12:38:30 <dcoutts> mwolak, tell me how you get on
12:38:50 <mwolak> unfortuntely, I don't have a windows box to test on here, but I'll try on monday
12:39:23 <mwolak> worst comes to worst, zlib format has a setting for non-compressed data, right?
12:41:04 <glguy> ?seen dons
12:41:05 <lambdabot> dons is in #happs, #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 6h 31m 7s ago.
12:41:19 <Korollary> Bulat developed his compression libs on windows iirc
12:41:58 <monomorph> yeah, I'm wondering why you're doing it yourself
12:43:13 <beelsebob> Igloo: http://darcs.haskell.org:8010/tatd2-osx-ppc-6.6-6.6/builds/3/step-darcs/0 <-- ERQ!
12:43:16 <lambdabot> Title: Log File contents, http://tinyurl.com/29x4yx
12:46:02 <sjanssen> dcoutts: did I mention the strange race condition I encountered with zlib while attempting to implement parBuffer?
12:46:23 <dcoutts> sjanssen, ah, locking.
12:46:44 <sjanssen> http://hpaste.org/235
12:46:48 <sjanssen> that test case, to be specific
12:47:04 <dcoutts> sjanssen, it's the lack of locking on unsafeInterleaveIO again I presume?
12:47:26 <dcoutts> when used with the smp runtime
12:47:43 <sjanssen> dcoutts: maybe?  my test case uses seq and par only
12:47:47 <dcoutts> sjanssen, didn't you have a test case for that with ordinary hGetContents
12:48:36 <dcoutts> sjanssen, doesn't matter, if there are multiple OS threads pulling the list out of Zlib.(de)compress then there's the unsafeInterleaveIO problem.
12:48:52 <sjanssen> okay
12:49:00 <sjanssen> so it's a ghc bug?
12:49:03 <dcoutts> sjanssen, because the zlib bindings use unsafeInterleaveIO internally
12:49:05 <dcoutts> sjanssen, yes.
12:49:20 <SamB> I knew this would happen!
12:49:26 <dcoutts> sjanssen, in the smp runtime unsafeInterleaveIO and unsafePerformIO need to lock.
12:49:39 <glguy> dcoutts: that's probably why hpaste was crashing with -threaded then
12:49:56 <dcoutts> glguy, quite possibly
12:50:13 <dcoutts> has this bug been filed? I'm sure someone demonstrated it with ordinary readFile :: IO String
12:50:29 <dcoutts> Igloo, are you familiar with this one?
12:50:34 <sjanssen> dcoutts: "need to lock"?  meaning ghc currently does lock?
12:50:45 <dcoutts> sjanssen, it currently does not lock.
12:50:49 <dcoutts> hence the problem
12:50:51 <sjanssen> ah, okay
12:51:06 <sjanssen> I remember mentions of this issue in the paper describing the threaded rts
12:51:24 <dcoutts> the point is that for pure computations it doesn't need locking
12:51:27 <glguy> what does -threaded do to the application?
12:51:40 <dcoutts> glguy, it's -smp that's the issue
12:52:17 <dcoutts> but unsafePerformIO and unsafeInterleaveIO present pure values but internally they can have side effects.
12:52:33 <sjanssen> right
12:52:46 <dcoutts> and at the same time we should add unlockedPerformIO and inlinePerformIO for the other cases
12:53:10 <dcoutts> of when locking and preventing cse are unnecessary
12:53:49 <bos> is there a simple function that turns a lazy into a strict ByteString?
12:54:02 <sjanssen> bos: toChunks, then concat
12:54:08 <dcoutts> bos, Strict.concat . Lazy.toChunks
12:54:22 <bos> ok, thanks.
12:55:00 <dcoutts> bos, you probably only want to do that if you know your lazy bytestring is short, because that forces and copies the whole lot.
12:55:16 <Gotaku> Is there a way to print a lazily implemented list to the screen without the IO bottlenecking?
12:55:43 <bos> dcoutts: sure.
12:55:43 <dcoutts> Gotaku, what do you mean "IO bottlenecking"?
12:55:53 <sjanssen> Gotaku: you could force the list before you print it
12:56:28 <Gotaku> sjannsen, that uses too much memory I think.
12:57:06 <paolino> hi, I'm trying to implement a walk function to recursive descend files hierarchy, where are functions to check entryu types ?
12:57:27 <Gotaku> I would like an element of the list to be printed while at the same time evaluating the next element of the list.
12:58:50 <allbery_b> Control.Parallel.Strategies?
13:01:36 <allbery_b> @hoogle getFileStatus
13:01:37 <lambdabot> No matches found
13:01:42 <allbery_b> @hoogle getFile
13:01:43 <lambdabot> System.Console.Readline.getFilenameCompletionDesired :: IO Bool
13:01:43 <lambdabot> System.Console.Readline.getFilenameQuoteCharacters :: IO String
13:01:43 <lambdabot> System.Console.Readline.getFilenameQuotingDesired :: IO Bool
13:01:48 <allbery_b> hm, wrong one
13:01:50 <paolino> how I check if a FilePath is a directory ?
13:01:54 <sjanssen> @paste
13:01:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:02:35 <allbery_b> huh.  hoogle doesn't have t?
13:02:40 <allbery_b> @index getFileStatus
13:02:41 <lambdabot> System.Posix.Files, System.Posix
13:03:10 <hyrax42> > let fac n = if n > 0 then n * fac (n-1) else 1 in fac -7
13:03:11 <lambdabot>   add an instance declaration for (Num (a -> a))
13:03:17 <allbery_b> that's what you're looking for
13:03:18 <aking> dcoutts: gtk2hs-0.9.10.6 is failing to compile (*.5 compiled fine with the ebuild you supplied.  Updated it to .6 and it fails near the end I think)
13:03:19 <AStorm> Haha.
13:03:22 <hpaste>  sjanssen pasted "parPrint" at http://hpaste.org/287
13:03:24 <hyrax42> > let fac n = if n > 0 then n * fac (n-1) else 1 in fac (-7)
13:03:26 <lambdabot>  1
13:03:32 <sjanssen> Gotaku: something like that?
13:03:37 <dcoutts> aking, oh, can you @paste
13:03:40 <dcoutts> @paste
13:03:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:03:49 <hyrax42> > let fac 0 = 1; fac n | n > 0 = n * fac (n-1) in fac (-7)
13:03:51 <lambdabot>   Non-exhaustive patterns in function fac
13:03:55 <aking> sure
13:04:04 <hyrax42> the wikipedia article on haskell is not too good
13:04:11 <dcoutts> aking, oh wait a sec, I've not pushed the updated ebuild ! :-)
13:04:44 <paolino> thanks allbery_b
13:04:58 <paolino> is windous posix ?
13:05:09 <dcoutts> aking, oh, hmm, the changes I've got here shouldn't affect whether it compiles correctly. So go ahead @paste.
13:05:18 <Gotaku> Is there a tutorial somewhere about using concurrency in Haskell?
13:05:21 <allbery_b> hm, not sure those are ther eon windws
13:05:24 <hpaste>  aking pasted "gtk2hs-0.6.10.6 compile failure under gentoo AMD64" at http://hpaste.org/288
13:05:26 <allbery_b> dunno how you'd do it
13:05:38 <AStorm> paolino, no, windows doesn't support POSIX
13:05:52 <bos> Gotaku: look for "tackling the awkward squad"
13:05:58 <bos> @google "tackling the awkward squad"
13:06:00 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
13:06:01 <lambdabot> Title: Simon Peyton Jones: papers
13:06:03 <sjanssen> Gotaku: I don't know of a tutorial, but the library docs are okay
13:06:09 <paolino> great
13:06:15 <dcoutts> aking, ah, that bug.
13:06:36 <dcoutts> aking, I didn't think that happened on linux.
13:06:38 <aking> dcoutts: ah - good - you've seen it before :)
13:06:54 <ddarius> Gotaku: The Awkward Squad paper should be a start
13:07:06 <aking> yeah - I was surprised to the that as well.  DOn't think .5 and .6 would have changed that much
13:07:13 <dcoutts> aking, can you annotate that last paste with the output of "xargs --show-limits"
13:07:29 <ddarius> Gotaku: If you want to use STM, then there is pretty much just the papers.
13:07:33 <allbery_b> hm.  pugs uses some win32 modules to get at that kind of thing but I guess it's not standard (or at least not odcumented in the online hierarchical libs)
13:07:38 <dcoutts> aking, you must be using ghc-6.4.2 ?
13:07:45 <aking> dcoutts: yup
13:07:57 <dcoutts> aking, I changed the way that the .o files get built from the _split/*.o files.
13:08:04 <paolino> then there is no way to make a portable walk
13:08:43 <allbery_b> @where filepath
13:08:44 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
13:08:49 <allbery_b> wonder if that helps
13:08:55 <monomorph> The STM papers have sample code.
13:09:16 <aking> dcoutts, annotated
13:09:28 <dcoutts> ta
13:09:53 <dcoutts> aking, ok thanks.
13:09:59 <SyntaxNinja> I love the "build with cabal" logo on hackage :)
13:10:18 <allbery_b> nope
13:10:19 <allbery_b> fej
13:10:22 <allbery_b> feh
13:10:30 <sorear> tell fodder
13:10:37 <dcoutts> SyntaxNinja, where's that?
13:10:53 <gotaku> How do I force a lazy list to be completely evaluated?
13:10:55 <dcoutts> SyntaxNinja, we've made the hackage.haskell.org front page direct to http://hackage.haskell.org/packages/hackage.html
13:10:57 <lambdabot> Title: HackageDB: introduction
13:11:38 <dcoutts> SyntaxNinja, btw, we need to tidy up the twisty little maze of links, names and pages that is the hackage/cabal websites/trackers
13:11:57 <dcoutts> to a new user it's a bit confusing I thing
13:12:30 <monomorph> gotaku: last xs will do wonder
13:12:52 <Igloo> mwolak: I've almost finished tidying up my pure Haskell gzip compression stuff if that's any use to you
13:12:56 <sjanssen> Gotaku: see rnf in Control.Parallel.Strategies
13:12:56 <allbery_b> hm?  that evaluates the list but not the items in ut
13:13:12 <dcoutts> I think http://hackage.haskell.org/packages/hackage.html should *be* the hackage.haskell.org front page and all references to HackageDB should point there, not to the HackageDB trac wiki
13:13:13 <lambdabot> Title: HackageDB: introduction
13:13:35 <monomorph> dropWhile (\x -> seq x False) xs   will do more wonder :)
13:13:44 <goedel> can a haskell lib be easily used in C and vice versa?
13:13:47 <mwolak> Igloo cool... does it to zlib format too? (I'm trying to write a PNG library)
13:13:52 <monomorph> err s/False/True/
13:14:03 <Igloo> dcoutts: There's a bug report open on unsafePerformIO and multiple threads
13:14:09 <dcoutts> Igloo, ok great.
13:14:10 <monomorph> But rnf is probably more general.
13:14:12 <gotaku> sjannsen, that isn't too helpful.
13:14:27 <allbery_b> @where ffi
13:14:28 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
13:14:37 <dcoutts> mwolak, gzip is a simple wrapper format for zlib format, so if Igloo's got gzip then he's got zlib format.
13:14:50 <mwolak> nifty
13:15:10 <sjanssen> Gotaku: yeah, the docs suck
13:15:20 <Igloo> mwolak: If that uses inflate/deflate then it would be trivial to write
13:15:46 <sjanssen> @type \xs -> Control.Exception.evaluate (Control.Parallel.Strategies.rnf xs) -- this is how you can force the list in IO
13:15:48 <lambdabot> forall a. (Control.Parallel.Strategies.NFData a) => a -> IO Control.Parallel.Strategies.Done
13:15:55 <dcoutts> Igloo, zlib format is raw inflate/deflate with no header or checksum
13:15:58 <SyntaxNinja> dcoutts: built with cabal link can be seen here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bzlib-0.3
13:16:01 <Igloo> OK
13:16:01 <lambdabot> http://tinyurl.com/24sqjy
13:16:10 <SyntaxNinja> dcoutts: yeah, it's confusing.
13:16:13 <Igloo> beelsebob: Any idea why that happened?
13:16:21 <dcoutts> SyntaxNinja, nice logo :-)
13:16:28 <SyntaxNinja> dcoutts: I don't know where it came from :)
13:16:29 <beelsebob> Igloo: not a clue - borkened is all I can say
13:16:35 <SyntaxNinja> it just appeared.
13:16:37 <monomorph> gotaku: a usage is probably rnf xs
13:16:42 <beelsebob> I installed happy and alex
13:16:45 <beelsebob> to try to fix the error
13:16:47 <beelsebob> forced a build
13:16:49 <beelsebob> and got that
13:17:17 <Igloo> beelsebob: You didn't change the path or anything in the meantime?
13:17:22 <beelsebob> nope
13:17:24 <monomorph> rnf (repeat True) hangs my ghci.  it doesn't even respond to ctrl-c  :)
13:17:28 <goedel> ghc seems to be integratable with C
13:17:44 <allbery_b> goedel: see the FFI link
13:17:48 <allbery_b> @where ffi
13:17:48 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
13:17:54 <monomorph> ghc is very integrable with C
13:18:03 <goedel> thanks allbery_b
13:19:27 <monomorph> rnf [undefined,True] is also _|_
13:20:06 <monomorph> nice, rnf is the standardized "deeqSeq"
13:22:31 <fberthold> Is anyone aware of a relatively simple way to connect LambdaBot to AIM?
13:23:19 <sorear> fberthold: no.  you'll have to do it yourself :(
13:23:26 <lispy> fberthold: there was (or still is?) a way to make lambdabot talk jabber
13:23:45 <lispy> fberthold: so if you had a jabber <---> aim proxy you'd be golden
13:24:08 <sorear> fberthold: lambdabot's multiproto support is non-existant :(  newsham has a silc-lamdbabot fork, ADept and stepcut both have xmpp-lambdabot forks
13:24:30 <fberthold> sorear: Such is life, I'm happy to work on it as time permits.
13:24:31 <lispy> fberthold: or maybe you'd just like to use lambdabot from a webpage (or as a webservice) check out http://lambdabot.codersbase.com
13:24:33 <lambdabot> Title: Lambdabot Web Interface
13:25:09 <fberthold> lispy: Really? Do you know where the Jabber connection is?
13:25:26 <lispy> fberthold: it's the xmpp that sorear mentioned
13:25:46 <lispy> i thought it was in the standard lambdabot distro but maybe not
13:25:55 <fberthold> lispy: Ah, I missed it, thank you both.
13:26:09 <lispy> yw!
13:29:50 <hpaste>  slowriot pasted "to and fro" at http://hpaste.org/290
13:29:58 <slowriot> https://www.spoj.pl/problems/TOANDFRO/
13:31:15 <goedel> can you gimme some points to use haskell for a FOL theorem prover versus ML (please no flaming)
13:31:41 <user317> is there a way to pattern match just on the name of the constructor?  so data Foo = Foo Int Int; blah ff@(Foo) = doFoo ff;
13:31:56 <glguy> ff@(Foo _ _)
13:31:57 <user317> instead of having to type (Foo _ _)
13:31:57 <sjanssen> user317: blah ff@(Foo {})
13:32:05 <user317> thanks
13:32:15 <lispy> goedel: from my weak understanding, i think FDs make it easier to express some things in Haskell than in ML
13:32:18 <sjanssen> little known fact that {} works on non record style constructors
13:32:19 <glguy> sjanssen: does that work even if records aren't being used?
13:32:23 <glguy> cool
13:32:41 <goedel> what are FDs?
13:32:41 <user317> sweet, that workd, thanks sjanssen
13:33:06 <lispy> goedel: functional dependencies
13:33:14 <goedel> thanks lispy
13:33:21 <lispy> goedel: they let you use the type system sort of like prolog programming
13:33:41 <goedel> that'S really fine
13:35:08 <sorear> goedel: what's an FOL prover?
13:35:25 <sorear> I've only written one prover :(
13:35:34 <goedel> sorear: First-Order Theroy
13:35:45 <goedel> s/Theroy/Theory
13:35:51 <tibbe> is there any haskell documenation integration for emacs?
13:35:54 <sorear> ah right , firstorder logic
13:36:11 <sorear> tibbe: for extremely limited definitions of "documenation", yes.
13:36:18 <tibbe> sorear, like?
13:36:22 <lispy> tibbe: i think so...at least the Prelude functions show their type signature in the mini buffer for me
13:36:27 <tibbe> at least types for all functions or something
13:36:29 <tibbe> oh
13:36:31 <sorear> tibbe: haskell-mode will echo syntax rules and prelude types
13:36:32 <tibbe> for me too
13:36:38 <tibbe> ok
13:36:45 <sorear> but for me it doesn't happen in the minibuffer :(
13:36:49 <tibbe> i read something about hoogle integration
13:36:53 <sorear> for me it's in the echo area
13:37:05 <lispy> er, that's what i meant then
13:39:14 <goedel> what are the best tools under Linux/UNIX to use Haskell (editor, compiler, interpreter, gui-integration, lexer-, and parser-generator etc.?
13:39:44 <lispy> goedel: it's all about personal preference, i enjoy emacs, ghc and parsec
13:39:55 <tibbe> goedel, I use emacs, ghc, happy, alex
13:40:06 <tibbe> or parsec instead of happy
13:40:28 <goedel> thanks lispy and tibbe
13:40:57 <lispy> oh for gui-integration two popular ones are wxhaskell and gtk2hs
13:41:31 <sorear> gui-integration is for wimps.  terminals forever!
13:41:49 <opqdonut> true
13:41:50 <allbery_b> if by gui-integration you mean an IDE, eclipse + http://eclipsefp.sourceforge.net
13:41:51 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
13:42:01 <opqdonut> bah, emacs is all the ide you'll need
13:42:03 <opqdonut> and more
13:42:21 <lispy> oh i thought gui-integration meant making guis
13:42:28 * allbery_b uses emacs :)
13:42:28 <fasta> Oh no, another IDE discussion. We have logs, you know?
13:42:31 <goedel> sorry allbery; eclispe needs too much performance
13:42:35 <lispy> i usually make guis in the blender
13:42:47 <opqdonut> i usually don't make guis
13:42:59 <lispy> er wait, maybe i'm thinking of smoothies
13:43:06 <opqdonut> :P
13:44:18 <gotaku> What is the most useful monad besides Maybe and IO?
13:44:52 <TomMD> Either State or ... humm...
13:44:58 <Korollary> state, error, etc
13:44:58 <sorear> (->)
13:44:59 <glguy> []
13:45:16 <sorear> > ap zip tail "Reader forever!"
13:45:17 <lambdabot>  [('R','e'),('e','a'),('a','d'),('d','e'),('e','r'),('r',' '),(' ','f'),('f',...
13:45:34 <lispy> useful?
13:45:39 <lispy> that's too subjective!
13:45:44 <goedel> I've heard Perl6 is devoloped in Haskell
13:46:04 <lispy> goedel: pugs
13:46:32 <goedel> lispy: what is pugs?
13:46:38 <fasta> ...
13:46:40 <lispy> http://www.pugscode.org/
13:46:41 <lambdabot> Title: Pugs - pugscode
13:46:58 <lispy> Pugs is an implementation of Perl 6, written in Haskell. It aims to implement the full Perl6 specification, as detailed in the Synopses. For more information, please see the overview and this interview.
13:49:00 <goedel> thanks lispy
13:50:17 <goedel> A very important Question for me: is compiled Haskell code fast? How much slower than C-code?
13:51:09 <lispy> goedel: look at this site: http://shootout.alioth.debian.org/
13:51:10 <lambdabot> Title: The Computer Language Shootout Benchmarks
13:51:10 <augustss> goedel: that depends :)
13:51:20 <lispy> goedel: it's full of worthless microbenchmarks to wrap your brain around
13:51:38 <lispy> goedel: includes quite a few languages really
13:52:23 <Igloo> Does anyone know if OS X has anything like strace/truss?
13:52:29 <sorear> Igloo: ktrace
13:52:47 <Igloo> Aha, thanks!
13:52:49 <gotaku> Speaking of which I just found out that I made my mandelbrot shootout entry alittle TOO good... it works on all input sizes not just those divisible by 8.
13:53:14 <bos> am i correct in thinking that a DiffArray has to be used from within the IO monad?
13:53:22 <sorear> bos: not at all!
13:53:26 <bos> whew!
13:53:29 <sorear> bos: why do you think that?
13:53:56 <bos> i'm new to arrays, and the documentation is not the best for newbies.
13:54:12 <bos> new to haskell arrays, that is :-)
13:54:32 <sorear> bos: the library uses unsafePerformIO internally, but does it in such a way that you can't hurt yourself with it.
13:54:44 <fasta> bos: documentation is pretty good, imho
13:54:53 <fasta> bos: and you are incorrect.
13:54:59 * allbery_b had the same issue, documentation seems to show constructors in IO
13:55:15 <allbery_b> it's not made clear that for normal usage it's transparent
13:55:38 <fasta> allbery_b: if you use the IArray documentation it is.
13:55:47 <fasta> allbery_b: it specifically mentions DiffArray
13:55:58 <fasta> allbery_b: and all its interesting properties.
13:56:26 <allbery_b> maybe the DiffArray docs should say "you probably don't want this documentation, go  look at IArray"
13:56:46 <allbery_b> it's not very obvious if you're not familiar with it already
13:56:47 <bos> allbery_b: right.
13:57:25 <fasta> "Diff arrays have an immutable interface"
13:57:35 <fasta> That seems pretty clear to me.
13:57:50 <mauke> that just means you can hack the interface
13:57:54 <mauke> er, can't
13:58:08 <gotaku> Is this tail recursive? ms x y ci = gb x ci 0 8 : ms (x+8) y ci
13:58:24 <sjanssen> gotaku: no, it isn't
13:58:35 <sjanssen> but it will be efficient if the result is lazily consumed
13:58:45 <gotaku> It is.
13:58:54 <sjanssen> then you're good to go
13:59:16 <ddarius> @wiki StackOverflow
13:59:17 <lambdabot> http://www.haskell.org/haskellwiki/StackOverflow
13:59:26 <fasta> Who is a C++ expert in this channel and knows Haskell?
13:59:28 <gotaku> sjanssen: Why will it be efficient though?
14:00:02 <sjanssen> gotaku: when the result is consumed lazily, only one cons cell will be in memory at a time
14:00:06 <mauke> fasta: well, I know some C++ ...
14:00:07 <sorear> <-- haskell expert, knows C++ -- good enough?
14:00:31 <fasta> Ok, are you familiar with the Boost Graph Library?
14:00:38 <Eelis> i am familiar with it
14:00:38 <sorear> No.
14:01:05 <fasta> It has a mechanism called visitors that users can use to extend generic algorithms.
14:01:07 <jlouis> fasta, ask the goddamn question rather than hooking people on the demonologic languages ;)
14:01:20 <fasta> I am trying to do something similar in Haskell.
14:01:31 <fasta> But I wonder what's the best way to do it.
14:01:54 <qwr> fasta: give example code of these visitors
14:02:08 <sjanssen> fasta: I've used the visitor pattern in Java, and it struck me that they're quite similar to folds
14:02:41 <Eelis> the Visitor design pattern is quite different from BGL visitors
14:03:08 <sjanssen> in that case, please disregard my comment
14:03:41 <fasta> The main problem is how I give access to the "variables" for every algorithm, and how the users can create their own data structures.
14:03:46 <qwr> "The BGL introduces the notion of a visitor, which is just a function object with multiple methods."
14:03:52 <qwr> http://www.boost.org/libs/graph/doc/index.html
14:03:53 <lambdabot> Title: The Boost Graph Library
14:03:59 <gotaku> sjanssen: When I use the ByteString.Lazy cons function instead of (:) my stack overflows.
14:04:10 <qwr> just (bunch of) function parameters wouldn't work?
14:04:17 <fasta> qwr: doesn't scale
14:04:24 <dcoutts> gotaku, ByteString.Lazy.cons is strict in it's second arg
14:04:25 <Igloo> gotaku: It's not really lazy
14:04:37 <sjanssen> gotaku: that function is strict on the second argument.  You can use (singleton x) `append` xs
14:04:50 <Igloo> append isn't really lazy either
14:04:53 <dcoutts> gotaku, it also indicates you probably don't want to be using it in that way anyway since it'll be really slow
14:05:04 <Igloo> (unless you are using the latest from the fps repo)
14:05:11 <sjanssen> gotaku: but constructing bytestrings with cons is generally a bad idea.  Can you use unfoldr?
14:05:33 <Korollary> http://www.international-lisp-conference.org/2007/~111b2bf3b593abc6bcc9fbe1~/contest
14:05:37 <lambdabot> Title: ILC 2007 > Programming Contest, http://tinyurl.com/2yl4os
14:06:11 <gotaku> Well I have a lazy [Word8] list, what would be the best why to make a ByteString?
14:06:12 <Igloo> dons: ^^ FYI: someone else suffering from strict cons in fps
14:06:23 <dcoutts> goedel, pack
14:06:24 <sjanssen> gotaku: pack
14:06:43 <gotaku> Is pack lazy?
14:06:49 <dcoutts> Igloo, I think the solution is to not provide cons, since people obviously misuse it :-)
14:07:01 <dcoutts> Igloo, and by that I mean that the use it.
14:07:24 <dcoutts> can you think of any use that isn't a misuse ?
14:07:38 <Igloo> dcoutts: I sent dons a patch for cons and cons' a few days ago
14:07:42 <sjanssen> not including cons is a bad idea
14:07:50 <dcoutts> sjanssen, I'm mostly joking
14:08:01 <Igloo> dcoutts: I use it in deflate
14:08:17 <sjanssen> a strong negative comment in the docs is a good idea, though
14:08:19 <dcoutts> Igloo, why? you know it's slower than [] and :
14:08:30 <yaxu> anyone know who i should ask about haskell.org mailing lists?
14:08:46 <dcoutts> but the docs probably need a big fat warning saying "don't use this in a loop, it's really slow! it makes a highly fragmented bytestring"
14:08:50 <yaxu> i tried mailing haskell-admin a week ago but didn't get a reply
14:08:59 <yaxu> i guess that address gets spammed a lot
14:09:27 <ddarius> @wiki Stack overflow
14:09:27 <lambdabot> http://www.haskell.org/haskellwiki/Stack overflow
14:09:29 <Igloo> Hmm, I guess it would be
14:09:52 <gotaku> Still not lazy... pack is converting my whole list to a ByteString.
14:09:55 <ddarius> hmm... it looks like the @wiki plugin could be smarter
14:09:56 <dcoutts> Igloo, we have a monoid for lazy ByteString
14:09:58 <Igloo> Maybe I should make a [Word8] and pack it at the top level
14:10:09 <sorear> gotaku: are you using .Lazy ?
14:10:13 <dcoutts> gotaku, if you're making a strict bytestring then yes
14:10:26 <sorear> gotaku: how long is your list ?
14:10:34 <dcoutts> Igloo, I think you'd find that's faster. Or use Builder.
14:11:09 <Igloo> dcoutts: Where is Builder?
14:11:13 <JKnecht> yaxu: I think it's haskell-cafe at haskell.org.
14:11:15 <gotaku> sorear: When I tried it on a longer list now it's acting lazy...
14:11:21 <dcoutts> Igloo, it's currently included in the binary lib.
14:11:32 <dcoutts> Igloo, though it's useful generally.
14:11:51 <yaxu> JKnecht: i mean getting in contact with the admin
14:11:54 <sorear> gotaku: checking the @source .Lazy.pack seqs 32KB at a time.
14:11:58 <JKnecht> yaxu: anyway there's: http://www.haskell.org/mailman/listinfo/haskell-cafe
14:11:59 <lambdabot> Title: Haskell-Cafe Info Page
14:12:36 <dcoutts> Igloo, it's much like the ([a] -> [a]) way of doing efficient ++ for lists, but for lazy bytestrings.
14:12:50 <yaxu> a couple of us were thinking of suggesting a mailing list about making music/art with haskell
14:13:18 <fasta> Eelis: how would you solve it? I thought of using a field in the output data structure of every algorithm called user_specified_data and calling a monadic action on every "variable" that might possibly be of interest. It would even be better if I could add the IO monad somewhere too, but I haven't thought about integrating IO yet.
14:13:49 <yaxu> maybe i should host such a mailing list myself and see about transferring it if it gets useful
14:14:41 <dcoutts> Igloo, I'd not noticed before that the (a -> a) style gives you single threading and thus allows for mutable data structures.
14:15:16 <Igloo> dcoutts: Hmm?
14:15:48 <dcoutts> Igloo, Ross (re-)wrote the binary Put monad into that Builder monoid. Internally it uses a mutable buffer. Check out the code, it's quite terrifying.
14:16:01 <dcoutts> try and convince yourself that it's externally pure
14:16:24 <Igloo> Ah, right
14:17:13 <Eelis> fasta: BGL visitors are a scheme of informing client code of a sequence of events (in particular vertex discovery). perhaps a neat way of doing this in Haskell and exploiting laziness is to have things like depth-first-search algorithms generate a stream [Event] where Event = Enter Vertex | Leave Vertex | etc .
14:18:04 <Eelis> fasta: this immediately takes care of the scenario where client code is "done" and is no longer interested in future events, which in BGL is awkwardly (and notoriously) dealt with by having client code throw an exception
14:19:23 <Eelis> fasta: this event-stream interface would achieve the same separation between graph data structure representation and client code that BGL visitors achieve
14:19:40 <glguy> SyntaxNinja: You there?
14:20:06 <Eelis> fasta: but i'm just making this stuff up as i go. the sensible thing to do would be to take a look at existing Haskell graph libraries :)
14:20:10 <ddarius> @seen shapr
14:20:11 <lambdabot> I saw shapr leaving #happs and #haskell 22h 35m 43s ago, and .
14:21:47 <defcon8> which is the best printed book for haskell? (come on, the site says that YAHT is the BEST free online one)
14:23:42 <augustss> maybe Graham Hutton's new book
14:26:05 <fasta> Eelis: existing Haskell graph libraries are not impressive.
14:26:54 <fasta> Eelis: a nice idea, though. (The streams) I had thought of it myself too a few weeks ago, but it slipped and wasn't immediately a problem at the time.
14:28:12 <Heffalump> augustss: what's better about that book than existing ones?
14:28:42 <Eelis> fasta: ok, i haven't looked at any of them (existing Haskell graph libraries). anyway, i'm having fun implementing a prototype of the streams thing already as we speak ;)
14:28:50 <augustss> I don't know.  I've just heard people say good things about it.
14:29:57 * augustss is reading the Wikipedia entry on Canary Wharf.  Very interesting.  Well, if you work there.
14:30:01 <Eelis> fasta: i'd be interested to see what other kinds of approaches work well for graphs, so drop me a note if you've settled or stumbled upon something interesting
14:30:10 <Heffalump> augustss: :-)
14:30:24 * Heffalump thinks the DLR is more interesting
14:30:48 <augustss> Did you know that it was CSFB that came up with the idea for Canary Wharf?
14:30:52 <Heffalump> yes
14:31:00 <Heffalump> (cos I read that article some time ago :-)
14:31:06 <augustss> :)
14:32:23 <ddarius> fasta: FGL is supposed to pretty good
14:33:08 <fasta> Eelis: I do have implemented a simple Graph monad, such that you don't need to specify all the time about what graph you are talking. Most of the algorithms implemented look like pseudo-code now :)
14:33:20 <Heffalump> the DLR is one of the few railways in the world using moving block signalling
14:33:25 <fasta> ddarius: FGL is _slow_
14:33:58 <fasta> ddarius: A large number of operations that should be constant time aren't.
14:34:39 <fasta> Eelis: you are also building a graph library?
14:34:51 <fasta> Eelis: or just for fun now?
14:35:34 <ddarius> I haven't looked at the paper(s) in a while, I had thought that it had done fairly good in that respect though.
14:37:23 <Eighty> if you pass an ioarray into a function, or return it, or use the function writeArray on it, will it copy the array and make a new one?
14:37:38 <sorear> no
14:37:45 <Eelis> fasta: your Graph monad idea sounds interesting. i'd love to read more about it (or see some code). i'm not building a graph library, i'm just having a bit of fun
14:37:54 <sorear> ioarrays are just like c arrays - they mutate
14:40:37 <dcoutts> and they have slightly more bounds checks
14:41:29 <hpaste>  eighty pasted "slow iomatrix!" at http://hpaste.org/291
14:41:37 <Eighty> yes, that's what i thought too
14:42:10 <Eighty> however, when i run test 128 (multiplies two 128x128 matrices) it takes up an awful lot of memory
14:42:12 <Eighty> and i don't know why
14:42:39 <Eighty> and yes i apologise for the c-looking code. it's just a test
14:44:46 <fasta> Eelis: still there?
14:44:58 <Eelis> fasta: yes, reading the code :)
14:49:36 <Eighty> any ideas on why that takes up 180 MB of memory?
14:50:28 <augustss> Eighty: try forcing the computation of value+a*b before storing it
14:50:46 <dcoutts> are you using IOUArrays?
14:50:52 <dcoutts> ie unboxed, strict
14:51:25 <Eighty> no, should i?
14:51:36 <sorear> yes!
14:51:59 <sorear> always use IOUArrays unless you need circularity or element computation is slow.
14:52:03 <hpaste>  Saizan pasted "a nice way to write this?" at http://hpaste.org/292
14:52:05 <Eighty> i'll try both, thanks
14:52:25 <sorear> since arrays are always "spine"-strict, element laziness rarely helps.
14:52:34 <sorear> and often hurts.
14:52:50 <SyntaxNinja> hi glguy
14:53:00 <sorear> (there are a few notable exceptions, e.g. glguy's memoizing diff)
14:54:07 <dcoutts> some dynamic programming algorithms can be expressed nicely with lazy arrays
14:54:16 <monomorph> Yes.
14:54:24 <Eighty> sorear: what do you mean by spine?
14:55:06 <allbery_b> the array itself is strict, even if the elements aren't
14:55:23 <hpaste>  bos pasted "confused by this odd type signature" at http://hpaste.org/293
14:55:28 <allbery_b> compare to lists, which can be lazy both in the list structure and in their elements
14:55:58 <Igloo> bos: Which bit of it confuses you?
14:56:02 <bos> i find the signature of runLength in the above paste quite counterintuitive.
14:56:28 <bos> i would have expected the "c" to be an "RL a", for example.
14:56:34 <Eighty> evaluating (value + a * b) strictly made sure the memory stayed constant
14:57:24 <allbery_b> bos: you may be confused by the "foldr" which is an arbitrary function
14:57:46 <bos> yes, but i tried to make the foldr have a foldr-like signature.
14:58:13 <bos> and it wouldn't typecheck.
14:59:39 <bos> i think "c" is hiding something like "[a] -> RL a", only using that instead would make typechecking fail if i used a foldr over a non-list.
14:59:54 <bos> so i have to have the more generic type. or something.
15:00:46 <bos> ah, that's what it was, all right.
15:01:06 <bos> i finally made a tidier signature: (Eq a) => ((a -> RL a -> RL a) -> RL a -> c -> RL a) -> c -> RL a
15:08:48 <augustss> has anyone tried gtk2hs on the mac?
15:08:56 <dcoutts> augustss, yep
15:09:09 <dcoutts> I got a successful build report today
15:09:28 <augustss> good!  i'm building gtk for my mac now
15:09:49 <allbery_b> hm.  bos:  maybe you want Foldable?
15:09:53 <dcoutts> augustss, it worked on "Mac OS X (Tiger) 10.4.8 on Intel with GHC 6.6 and GTK 2.10.6_0" apparently.
15:10:23 <dcoutts> augustss, so tell me how it goes, because we don't have much coverage yet on Mac
15:10:26 <augustss> hmmm, did it mention if it was gtk for x11 or native gtk?
15:10:27 <bos> allbery_b: you mean to declare such a class? or are you saying there exists one?
15:10:36 <dcoutts> augustss, it was X11
15:10:37 <allbery_b> Data.Foldable, in 6.6
15:10:40 <bos> ooh, new in 6.6!
15:10:47 <dcoutts> augustss, are you tring x86 or ppc btw?
15:10:50 <augustss> dcoutts: i see.  i'm trying the native one
15:10:55 <augustss> x86
15:11:05 <dcoutts> augustss, oh cool. I'd love to see some screenshots of that.
15:11:15 <bos> allbery_b: hmm, Data.ByteString isn't Foldable
15:11:29 <augustss> dcoutts: if it works, i'll send you some
15:11:31 <dcoutts> augustss, my impression was that the native port was still a little immature.
15:11:42 <bos> allbery_b: in fact, Foldable is for typeclasses, not types
15:12:03 <dcoutts> bos, do you mean type constructors
15:12:10 <bos> sorry, yes./
15:12:10 <allbery_b> @instances.importing Data.ByteString Foldable
15:12:12 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
15:12:16 <augustss> dcoutts: that's my impression too
15:12:20 <allbery_b> @instances-importing Data.ByteString Foldable
15:12:21 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
15:12:44 <dcoutts> allbery_b, it can't be made an instance of Foldable sadly because ByteString is not polymorphic in the element type.
15:12:45 <bos> allbery_b: lambdabot only speaks 6.4
15:12:54 <bos> right.
15:14:48 <gotaku> Does ++ depend in any way on the length of either list?
15:14:57 <bos> no.
15:15:14 <bos> but its performance depends on the length of the LHS.
15:15:49 <gotaku> Performance was what I meant.
15:15:55 <bos> ok.
15:16:35 <bos> gotaku: if you want decent concatenation performance, use Data.Sequence or something else similar.
15:17:07 <gotaku> I'll look into it, thanks.
15:17:27 <titus> Hi all, I have a question about Network.HTTP
15:18:04 <titus> After a POST request, I get an apparent 303 error, but really the post worked...
15:18:23 <titus> How to parse the address that the form has submitted to?
15:24:48 <gotaku> Is appending two bytestrings efficient?
15:25:59 <SamB> gotaku: sorta
15:26:00 <dcoutts> gotaku, for strict ones it has to copy, for lazy ones, yes it's very efficient.
15:26:53 <SamB> (Python does no better than that)
15:27:00 <SamB> than strict ones, I mean
15:27:48 <bos> gotaku: for lazy bytestrings, you don't start paying a big price until you have lots of them.
15:27:52 <fax> h
15:27:53 <fax> hi
15:28:05 <fax> hmm, how do you explain currying to someone who doesnt program?
15:28:07 <gotaku> bos, define lots.
15:28:16 <fax> or even, to someone who isnt used to functions as variables
15:28:30 <fax> it seems to be difficult to explain or grasp.
15:28:59 <bos> gotaku: lazy bytestrings are stored in 64k strict chunks.
15:29:34 <SamB> fax: use algebra?
15:29:41 <fax> hmm?
15:29:50 <SamB> well.
15:30:25 <sorear> fax: topology
15:30:25 <SamB> hmm.
15:30:27 <SamB> dunno!
15:30:33 <bos> so if you append two lazy bytestrings, you pay the cost of appending the lists that hold the strict chunks.
15:30:34 <SamB> teach them lambda calc first?
15:30:38 <gotaku> fax: Why do you ask?
15:30:39 <fax> f
15:30:50 <SamB> bos: yeah. but those costs are pretty cheap...
15:30:56 <fax> I dont think they will listen long enough to understand lambda calculus
15:31:02 <sorear> fax: (I[1]^I[1])^I[1] is homeomorphic to I[1]^(I[1]*I[1])
15:31:03 <bos> now, if you have oodles of tiny lazy bytestrings, and you append them, performance goes bad.
15:31:04 <fax> gotaku: I tried to explain it to 3 people today
15:31:05 <Korollary> Then why are you trying to explain?
15:31:07 <SamB> fax: tell them it makes tasty food
15:31:18 <fax> gotaku: nobody understands
15:31:18 <sorear> fax: do they understand function spaces?
15:31:25 <fax> sorear: no
15:31:32 <SamB> what is a function space?
15:31:46 <bos> so if e.g. you're constructing a big string of little teeny pieces, lazy bytestrings will be slow.
15:31:50 <sorear> er, um, er, um, ...
15:32:06 <bos> for that, you'd need a Data.Sequence or balanced tree, like a rope.
15:32:12 <fax> maybe I have it wrong..
15:32:18 <sorear> it's a space whose points are functions!
15:32:22 <augustss> SamB: It's the tiny corner in the attic that holds all functions that are not being used.
15:32:22 <fax> what is currying, in the most basic way?
15:32:24 <gotaku> bos, what if I'm constructing a huge string of large pieces?
15:32:38 <titus> So no Network.HTTP users around...?
15:33:15 <bos> if the pieces are large, then there won't be as many lists to concatenate, so performance will be better.
15:33:17 <augustss> fax: it's a way to use a function so you don't have to give it all the arguments in one place.
15:33:29 <gotaku> bos: Each piece is 3000 elements and the whole string has 3000 pieces
15:33:29 <sorear> fax: in logic: A implies (B implies C) is the same proposition as (A and B) implies C
15:33:35 <dcoutts> gotaku, if you're building in explicit chunks then you might want to use a list of strict ByteString and if you ever need to, use Lazy.fromChunks
15:34:17 <fax> augustss: I think that made sense (to my friend)
15:34:19 <ddarius> fax: Explaining via partial application is probably easier.
15:34:22 <monomorph> a function space is a set of functions
15:34:37 <fax> can you give an example of when its _really_ useful?
15:34:42 <fax> (anyone :D )
15:34:46 <dcoutts> gotaku, that can be helpful if you need to build the whole stream by appending, if you're pre-pending then the ordinary lazy bytestring is fine since append is linear in the number of chunks in the LHS, so if you're always prepending 1 chunk at a time it's O(1).
15:34:50 <monomorph> "space" is used because "set" may be replaced by topology, partial order, algebra, ...
15:35:13 <dcoutts> gotaku, so it really depends on if you need to build your stream from the front or the back.
15:35:13 <ddarius> fax: In some ways it isn't, in other ways it absolutely crucial.
15:35:16 <sorear> fax: function spaces are quite useful.  see fex the Stone-Cech compactification
15:35:23 <augustss> fax: map (div 100) [1..10]
15:35:56 <csci> Hi, I have a small type problem which I was able to the following code snippet not working :D: [foo | foo <- printf "foo\n"] (The printf becomes more complicated later, but why does even this small example not work?)
15:36:09 <csci> insert "reduce" somewhere above
15:36:19 <ddarius> @type printf
15:36:21 <lambdabot> forall r. (PrintfType r) => String -> r
15:36:32 <monomorph> divide_100_by_everyone = map (div 100)    -- more use of currying
15:36:34 <ddarius> Bah
15:36:38 <csci> I tried to do the ":: String" -stuff ;)
15:36:39 <augustss> csci: help printf along by giving it a type
15:37:03 <monomorph> It would suck if div expected "div (x,y)" and map expected "map (f,list)".
15:37:04 <csci> augustss, thought about this, but how do I write it. Tried many combinations of :: String
15:37:04 <fax> is div an infix function?
15:37:08 <monomorph> No.
15:37:16 <monomorph> > div 100 20
15:37:17 <lambdabot>  5
15:37:21 <augustss> > [foo | foo <- (printf "abc") :: String]
15:37:21 <fax> so how is that dividing by 100 and 100 by
15:37:22 <fax> Oh..
15:37:23 <lambdabot>  "abc"
15:37:27 <gotaku> If you want to make them understand currying, teach them haskell.
15:37:30 <fax> how would you do everything / 100
15:37:36 <csci> augustss, Oh, Thanks, forgot the brackets
15:37:43 <monomorph> > flip div 20 100
15:37:45 <lambdabot>  5
15:37:56 <fax> what exactly does flip do?
15:37:59 <monomorph> divide_everyone_by_100 = map (flip div 100)
15:38:09 <xerox> map (`div` 100)
15:38:17 <augustss> > [foo | foo <- printf "abc" :: String]
15:38:19 <lambdabot>  "abc"
15:38:35 <csci> augustss, Oh, Thanks, forgot the brackets
15:38:48 <monomorph> flip exactly transforms flip div 20 100 to div 100 20
15:38:54 <augustss> fax: it flips the argument order of a function
15:38:58 <ddarius> @type flip
15:39:00 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
15:39:11 <csci> augustss, double comment, sorry. Hmm, Whatever, I forgot something essential ;-)
15:39:33 <heatsink> In my heap retainer profile, the biggest culprit is SYSTEM.  Can anyone here tell me what SYSTEM is?
15:41:37 <fax> im sort of confused by what "flip div 100" means exactly
15:41:50 <fax> I can tell what it would do, but I dont see how its parsed/recognized and applies
15:42:07 <augustss> @src flip
15:42:08 <lambdabot> flip f x y = f y x
15:42:14 <mauke> flip div 100 == ((flip div) 100)
15:42:36 <fax> Aha
15:42:43 <fax> I get it now, cheers ma
15:42:46 <fax> mauke: .
15:42:47 <mauke> == ((\x y -> div y x) 100) == (\y -> div y 100)
15:44:22 <sorear> wow. I'm reading the boehm rope paper now ... the pseudocode example can be made valid Haskell by adding a 'then' to the if/else  and changing concat(foo,bar) to (Concat foo bar) (in a pattern).  never realized the similarity before... (aside: is that ML syntax?)
15:44:44 <mauke> oh, not "boehm rape paper"
15:44:48 <fax> sorear: is that paper online?
15:46:28 <augustss> concat(foo,bar) could be ML
15:46:54 <fax> sorear: I mean to freely download
15:46:57 <sorear> wikipedia saz: http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf
15:46:59 <lambdabot> http://tinyurl.com/yq85ua
15:47:11 <sorear> augustss: does ml use 'then'?
15:47:32 <augustss> Hmmm, yes, as far as I can remember
15:47:32 <fax> thanks sorear
15:48:56 <mauke> sorear: where do you need to add 'then'?
15:49:28 <siti> ouch that MS video doesn't understand haskell
15:50:29 <siti> haskell is very practical for writing real apps, and how is an IO monad like asm :S
15:52:32 <gravity> A simple, stupid question: I'm trying to use getArgs to get all the arguments passed to my program. It returns IO [String]. I want to take 3 args from that, but take expects [String] rather than IO [String]. Do I have to use unsafeIO to do this?
15:53:09 <mauke> no, you should lift your code into IO
15:53:13 <allbery_b> do args <- getArgs; return (take 3 args)
15:53:26 <bd_> liftM (take 3) getArgs
15:53:41 <bd_> better yet, use a case in a do block to handle error cases nicely
15:53:43 <allbery_b> or if you want ot be fancy:  getArgs >>= return . take 3
15:53:55 <gravity> Aha, I didn't realize I could use return like that.
15:54:09 <gravity> bd_: Why would I use liftM instead of return?
15:54:19 <allbery_b> shorter way to say the same thing
15:54:20 <gravity> allbery_b: I'm nowhere near ready for fancy yet :-)
15:54:24 <gravity> Ah, ok
15:54:30 <bd_> gravity: liftM f m is equivalent to m >>= return . f, is equivalent to do { x <- m; return (f m) }
15:54:32 <fax> what other interesting features are there than currying?
15:55:02 <gravity> bd_: Aha, ok. Thank you.
15:55:07 <nomeata> ghc-6.6: panic! (the 'impossible' happened)
15:55:07 <nomeata>   (GHC version 6.6 for i386-unknown-linux):
15:55:07 <nomeata>         hptRules
15:55:07 <nomeata>     DepMapT [(Common, False), (DepMapT, False), (Dependencies, False),
15:55:07 <nomeata>              (FilePath, False), (HtmlStyle, False), (WikiData, False)]
15:55:09 <bd_> gravity: I like liftM (which is also the same as fmap) because it makes it more clear that I'm using a pure function to process the result of a monadic action
15:55:18 <siti> impossible happened awesome! :D
15:55:21 <bd_> but it's all up to your personal preference which to use
15:55:28 <gravity> bd_: I see. Ok, thank you again.
15:55:38 <gravity> Thank you everyone. I've been trying to puzzle that out for far too long.
15:55:48 <bd_> You need to import Control.Monad for liftM, note.
15:56:04 <fax> is currying about the most interesting?
15:56:09 <bd_> [it would be nice if it was in the prelude though...]
15:56:12 <nomeata> but ârm *.hiâ fixes ghcâs panic. A bit like restating an OS to fix misbehaviour
15:56:20 <gravity> I'll get to the non-IO monads later :-)
15:56:30 <bd_> nomeata: Clock drift maybe?
15:57:08 <nomeata> bd_: donât think so: DepMapT wasnât used by any module any more, but some modules still had their .hi files from when DepMapT was used by some other module
15:57:28 <nomeata> bd_: I guess for some reason they had a reference to it, maybe through inlining or something.
15:57:38 <allbery_b> that seems like it'd be hard to detect automatcally
16:02:46 <ddarius> fax: No it isn't.  Laziness, purity, typeclasses, monads, the entire type system etc.
16:03:30 <fax> type system>?
16:04:47 <gotaku> My program is now 3 whole seconds faster.
16:05:02 <ddarius> Haskell has one of the most sophisticated type systems of any practical programming language currently available.
16:05:37 <fax> what
16:05:51 <fax> I find that hard to beleive, with prolog around
16:06:04 <ddarius> fax: Prolog doesn't have a type system.
16:06:08 <sorear> prolog has a type system!?
16:06:08 <siti> :P
16:06:30 <fax> yes..
16:06:37 <nominolo> @src mfix
16:06:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:06:47 <bd_> nomeata: it's a typeclass function
16:06:56 <bd_> @src MonadFix IO
16:06:57 <lambdabot> Source not found. stty: unknown mode: doofus
16:07:01 <bd_> @src IO mfix
16:07:02 <lambdabot> mfix = fixIO
16:07:06 <bd_> @src fixIO
16:07:07 <lambdabot> Source not found. My pet ferret can type better than you!
16:07:09 <bd_> :/
16:07:18 <nominolo> @src Writer mfix
16:07:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:07:26 * csci likes lambdabots comments
16:07:29 <fax> in prolog a type is like an atom, number, symbol, or a compound term
16:07:32 <xic> what languages have type systems more powerful then haskell? only cayenne and epigram?
16:07:40 <nominolo> hm ..  i guess i need to figure it out myself
16:07:45 <monomorph> also clean
16:07:45 <fax> you can make types as complex as you want, and do pattern matching on them
16:08:04 <xic> monomorph: what kind of type system does clean have?
16:08:05 <fax> what are the differences between that and haskell?
16:08:25 <monomorph> clean is similar to ml and then there is uniqueness type
16:08:55 <Philippa> xic: a whole pile of theorem provers
16:08:59 <monomorph> One can also say that a dynamic type system is more powerful/complex/...
16:09:21 <xic> monomorph: i don't think so
16:09:53 <ddarius> fax: Prolog calls those terms... so do computer scientists.
16:10:04 <fax> yes
16:10:05 <fax> terms
16:10:05 <ddarius> Types classify terms.
16:10:16 <fax> predicates
16:10:17 <fax> etc
16:10:18 <ddarius> They are not terms themselves (usually...)
16:10:18 <monomorph> If you ask: how much is inferred and checked before running?  a static type system does more.
16:10:30 <Philippa> fax: Haskell could trivially embed Prolog's type system
16:10:38 <fax> Philippa: how?
16:10:47 <fax> Philippa: I would be really interested to see that
16:10:53 <monomorph> If you ask: how much is inferred and checked before finishing?  a dynamic type system does more.
16:11:01 <Philippa> data PrologType = Atom String | Number Integer | ...
16:11:09 <fax> er
16:11:12 <ddarius> Philippa: It's pretty easy to trivially embed a trivial type system...
16:11:14 <fax> is that a complete definition?
16:11:25 <Philippa> fax: aside from filling in the ..., yes
16:11:32 <sorear> fax: wikipedia says: "Prolog's single data type is the term."
16:11:32 <sorear> haskell has more than two types
16:11:32 <sorear> haskell has conjunctions, disjunctions, exponentiations, typeclasses, universal quantification, type lambdas (with explicit proofs of equality), etc.
16:11:33 <vincenz> Philippa: not sure about terms...
16:11:42 <titus> How do I get a formatted timestamp using Data.Time?
16:12:01 <Philippa> vincenz: yeah, I didn't do that :-) OTOH, it wouldn't be that hard to implement a (slow) prolog in Haskell
16:12:03 <sorear> gah, lag sucks.
16:12:10 <vincenz> Philippa: a limited set..
16:12:21 <vincenz> Philippa: not sure how easy it'd be to do the meta-prolog stuff
16:12:43 <Philippa> fax: for comparison, a minimalistic lisp's type would look thus:
16:13:09 <Philippa> data Lispy = Atom AtomIdentifier | Cons Lispy Lispy
16:13:27 <SamB> oh, right, nil's value is ... nil...
16:13:30 <Philippa> oh, and define AtomIdentifier
16:13:32 <Philippa> for example:
16:13:34 <fax> you missed functions
16:13:37 <Philippa> type AtomIdentifier = String
16:13:39 <Philippa> no, I didn't
16:13:40 <ddarius> Philippa: I implemented an okay prolog interpreter in about 85 lines of Haskell in it's first cut.
16:13:45 <vincenz> Philippa: I think you're overtrivializing
16:13:46 <ddarius> It's about 300 some now.
16:13:57 <SamB> vincenz: she said a trivial lisp
16:14:06 <Philippa> vincenz: I meant it when I said minimalistic. You can implement McCarthy's 1960 paper with that
16:14:08 <SamB> e.g. the original lisp
16:14:14 <augustss> exactly
16:14:17 <fasta> That's LISP
16:14:19 <fax> Philippa: I dont think thats true
16:14:23 <Philippa> fax: I did it
16:14:30 <fax> Philippa: do you have the code?
16:14:36 <sorear> gah - prolog is impure!!
16:14:37 <fax> (and willing to show>?)
16:14:50 <Philippa> not to hand, unfortunately. It's a pretty direct translation of the rules in the paper though
16:14:52 <augustss> sorear: of course!
16:14:55 <fax> :(
16:15:00 <xerox> ?go Scheme.hs
16:15:02 <fax> would have loved to see that
16:15:03 <lambdabot> http://www.healthscotland.com/documents/795.aspx
16:15:03 <lambdabot> Title: Race equality scheme - HS paper 28/04
16:15:07 <Philippa> I imagine if someone in here's bored they can write you another tonight though
16:15:16 <fax> heh
16:15:20 <fax> I wouldnt ask that of someone
16:15:20 <mbishop> Riastradh has Scheme.hs on his site
16:16:00 <mbishop> http://mumble.net/~campbell/tmp/Scheme.hs
16:16:23 <augustss> We should collect some of these simple implementations and put them on the wiki
16:16:44 <vincenz> Philippa: ah alright :)
16:16:49 <Anon4888> Philippa: That embeds the terms of lisp into haskell, right?
16:16:55 <Anon4888> Not the types?
16:17:07 <fax> does indentation make any difference to anything in haskell?
16:17:16 <augustss> Anon4888: what types?
16:17:17 <siti> fax: yes
16:17:23 <ddarius> That time stamp can't be right... I didn't write that interpreter three and a half years ago... did I?
16:17:26 <Anon4888> augustss: yes exactly :)
16:17:39 <Philippa> Anon4888: right :-)
16:17:49 <Philippa> though if you /have/ types it does those too ;-)
16:17:56 <fax> gah
16:18:08 <siti> (13:12:27) siti: fax: yes
16:18:13 <Philippa> fax: importantly, if you have both prolog and lisp values floating around in your app, the type system will prevent you mixing them up
16:18:17 <Philippa> and it'll prevent it statically
16:21:36 <dons> ?users
16:21:37 <lambdabot> Maximum users seen in #haskell: 322, currently: 298 (92.5%), active: 54 (18.1%)
16:21:46 <dons> morning #haskell!
16:21:47 <sorear> hiya!
16:21:47 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:22:04 <dons> Let's hack some lambdas!!
16:22:16 <sorear> just today a Mirandaite and a Prologician showed up
16:22:26 <dons> huh
16:22:31 <dons> a Mirandaite, wow.
16:22:38 <dons> that's a rare specimen
16:22:54 <sorear> curiously the Mirandaite was ircnet CosmicRay, rather irked his name was taken ... what a coincidence
16:23:26 <dons> strange
16:23:49 <fax> hey am I being called a prologician? :D
16:23:52 <fax> or is that someone else
16:24:04 <vincenz> better than a contralogician
16:24:07 <sorear> fax: yes you are :)
16:24:31 <sorear> fax: we don't normally see this many newbies this quickly
16:25:08 <fax> sorear: I take is a complement, though I have read more lines of prolog than ive written
16:25:31 <fax> but I kind of only came here in desperation of being unable to describe currying to anyone
16:25:34 <siti> fax: I'll be smart, and say that's usually the case with everything ;)
16:25:41 <siti> all languages*
16:25:47 <Thomas2> pssh, as if prolog isn't awesome
16:26:03 <fax> Thomas2: who said it wasnt!?
16:26:15 <ddarius> Prolog is horrid.
16:26:23 <ddarius> Important. But horrid.
16:26:27 <fax> ddarius: no ;(
16:26:33 <fax> ddarius: its beautiful
16:26:45 <fax> er 'can be' should probably be in there
16:26:57 <ddarius> It could've been.  It needs some cleaning up.  Luckily, some of it's successors did so.
16:27:18 <sorear> ddarius: why have I never heard of prolog's successors, then?
16:27:28 <Thomas2> hmm, prolog is awesome not so much for what it acheives as a practical language but what it tries to do
16:27:37 <ddarius> Because Prolog is still the archetypical logic language.
16:27:38 <fax> hmm well when you leave _pure_ prolog, things get a little hairy
16:27:49 <fax> i.e. you have to know what you are doing to write correct code
16:28:10 <Anon4888> as opposed to more advanced languages where you needn't have any idea what you're doing
16:28:18 <siti> :D
16:28:25 <fax> Anon4888: exactly!
16:28:45 * fax is able to program in these advanced languages
16:28:48 <sorear> hmm - how about prolog with a compositional IO system, a la Haskell's (IO, returnIO, bindIO) ?
16:29:02 <Thomas2> well, the idea is that any monkey can sit at the keyboard and later on if someone looks at it the semantics approximate the expression
16:29:18 <ddarius> sorear: Cut needs to be better handled.
16:30:05 <sorear> ddarius: cut?  (is that prolog term? I've only been studying prolog for about 5 minutes, from the wikipedia entry no less :( )
16:30:22 <Thomas2> sorear: cut is ! is what makes prolog hard to understand
16:30:35 <fax> cut is what I was referring to particularly
16:30:44 <fax> being careful to make green cuts, and not red cuts
16:30:45 <fax> etc..
16:30:49 <Thomas2> it sort of gives you implementation level hackery in what's otherwise a purish language
16:30:59 <ddarius> Thomas2: It's part of what makes even the "pure" parts hard to understand.
16:31:12 <sorear> hmm... if I may give a totally ridiculous guess... call/cc related?
16:31:49 <allbery_b> if backtracing crosses a cut, the expression fails
16:31:51 <allbery_b> IIRC
16:31:52 <fax> Thomas2: cuts, and metalogical-predicates and so on are when you have left ure prolog
16:31:54 <Anon4888> Since it's called 'cut', and it's a logic language, I'd guess it's something to do with cut elimination?
16:32:05 <fax> Anon4888: yeah
16:33:10 <fax> cut can be used to define negation (approximatly)
16:33:23 <augustss> Anon4888: I don't think so.  There is nothing logical about cut.
16:33:32 * fax realises hes made everyone in #haskell talk about prolog :S
16:33:47 <dons> better than talking about pascal
16:33:51 <fax> hehe
16:33:56 <ddarius> fax: It's not hard to get everyone in #haskell to talk about anything
16:34:07 <ddarius> Unless that changed in the last year or so...
16:34:13 * ddarius severly doubts that.
16:34:17 <augustss> when you write C code in Prolog, every other term is a cut.
16:34:31 <Philippa> there're things that'll go to #haskell-blah instead
16:34:40 <Philippa> I'm less frequently responsible for that now than in the past, at least
16:35:44 <ddarius> Philippa: Hmm, what has changed to make that true?
16:36:08 <Philippa> which statement? :-)
16:36:31 <Philippa> for the latter, I talk here less but also fewer of my quips turn into off-topic conversation
16:37:00 <sorear> ah, okay, I understand cuts now.  like I'll ever use it :)
16:37:07 <sorear> wikipedia++
16:37:53 <Philippa> ddarius: did you miss my response?
16:38:15 <ddarius> Yes, unfortunately.
16:38:33 <Philippa> okay
16:38:36 <Philippa> which statement? :-)
16:38:40 <Philippa> (in response to what's changed...)
16:38:51 <Philippa> for the latter, I talk here less but also fewer of my quips turn into off-topic conversation
16:39:18 <ddarius> That was the one I was asking about.
16:40:15 <ddarius> sorear: You have no choice but to use cuts in real Prolog.
16:41:58 <augustss> ddarius: well, when some of your 'predicates' write to files then what do you expect :)
16:42:21 <ddarius> augustss: Even for "pure" Prolog you have no choice.
16:42:52 * allbery_b hasn't touched Prolog in over 10 years.  he will be happy to keep it that way...
16:43:06 <augustss> ddarius: true, the depth-first search needs to be controlled
16:43:32 <ddarius> There are cleaner versions of cut than the one Prolog uses.
16:44:40 <tennin> anyone here in the Portland, OR area?
16:45:38 <dons> tennin: yeah, there are some. not sure they're up atm
16:46:45 <Nafai> It's 4:40 PM in Portland now, I think
16:47:08 <sorear> droundy etc
16:47:42 <tennin> I'm wondering if there's some kind of functional-language user group or enthusiast group here
16:48:05 <tennin> a cursory web search didn't turn up anything
16:49:22 <ddarius> There are ones for specific languages, at least Scheme.
16:49:47 <ddarius> (Assuming you mean real life meet and drink coffee user groups)
16:49:53 <tennin> Yeah.
16:50:19 <ddarius> I'm not aware of any Haskell/*ML ones though.
16:51:24 <tennin> ICFP was here, and Galois was here... it would be nice to have something like the half-hour Saturday-morning-cartoon version of ICFP (where the original is the trilogy three-hour serious movies)
16:51:46 <tennin> "trilogy of"
16:52:05 <tennin>  "Galois is"
16:52:13 <zarvok> tennin: ICFP was a lot of fun - you have good beer out there in portland :)
16:57:33 <augustss> tennin all the FP users in Portland work at Galois anyway ;)
17:03:05 <bos> wish we had some functional programmers in san francisco.
17:03:18 <bos> unfortunately, it's all ruby on rails here now.
17:03:32 * sjanssen wishes there were functional programmers in Lincoln, NE
17:03:42 <sjanssen> that is a much longer shot :)
17:03:47 <bos> you can't get a cup of coffee without tripping over someone fiddling with ActiveRecord.
17:03:50 * fax wishes he knew at least 1 person in real life that could program
17:03:58 <fax> :(
17:04:05 * mbishop wishes there were ANY programmers in Thibodaux Louisiana
17:04:05 <mbishop> ;/
17:04:12 <Heffalump> augustss: not true, droundy is in Portland
17:04:13 <fax> no one I can can code!
17:04:43 <augustss> Heffalump: ok, I was generalizing a little :)
17:04:55 <Heffalump> oh, no, I'm wrong, he's 80 miles from Portland :-)
17:05:19 <augustss> Oh, he's not at PSU?
17:05:23 <Heffalump> no, OSU.
17:05:26 <augustss> Ah
17:05:33 <bos> cosmic ray error.
17:05:48 <Heffalump> I wonder if there are any other Haskellers in Canary Wharf.
17:06:05 <bos> Heffalump: you bet.
17:07:35 <Heffalump> bos: oh yes?
17:08:55 <edwinb> there are plenty of FPers at PSU...
17:09:05 <edwinb> Mark Jones is there
17:09:07 <bos> at least one on this channel.
17:09:24 <Heffalump> bos: who?
17:09:34 <mbishop> The House guys are from PSU
17:11:19 <edwinb> they seemed to have a nice big group there
17:11:50 <pbx> Hullo #haskell
17:11:58 <Heffalump> hello pbx
17:12:44 <augustss> well, I'm not sure how many there are at PSU, actually.  Mark Jones and Iavor, and?
17:13:38 <edwinb> Tim Sheard and his students
17:14:14 <augustss> right, Tim.  Sorry Tim, I forgot you :)
17:14:39 <edwinb> there seemed to be a good few anyway
17:14:50 <edwinb> I can't name most of them ;)
17:14:54 <augustss> yeah, i think they have critical mass
17:14:54 <pbx> I'd been wanting codegolf.com to add Haskell support, but just found out that one of the #codegolf regulars is building his own that supports Haskell (and 30+ others... Cobol even). It's not exactly the Debian shootout but... http://programming.reddit.com/info/12qpf/comments
17:14:56 <lambdabot> Title: New (under construction) code golf site supporting 35 languages including Haskel ...
17:15:04 <pbx> Sorry, direct link is http://shinh.org:81/
17:15:06 <lambdabot> Title: anarchy golf
17:17:24 <edwinb> hmm, it even supports whitespace...
17:19:43 <nominolo> ?where cabal-install
17:19:44 <lambdabot> I know nothing about cabal-install.
17:19:52 <nominolo> ?
17:20:31 <sorear> hackage.haskell.org
17:20:51 <sorear> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
17:20:53 <lambdabot> Title: CabalInstall - Hackage - Trac
17:20:59 <sorear> reminds me
17:21:45 <nominolo> hm, no documentation there
17:22:12 <sorear> dons: what is the status of vty --> hackage upload?
17:22:46 <hpaste>  nominolo pasted "cabal-install build error" at http://hpaste.org/298
17:23:06 <nominolo> does anyone know what this means?
17:28:25 <dons> sorear: if you hand me a url i'll upload it today
17:30:29 <sorear> http://members.cox.net/stefanor/vty/dist/vty-2.0.2.tar.gz
17:30:52 <dons> ok. let me finish what i'm doing here. if i've not done it by the time you head to bed, ping me
17:31:03 <sorear> 'k
17:33:07 <moconnor> I've been writing a lot of code using the State monad, my only purpose in using the state monad is so I can do things like this:  do_some_action `usingSome` resource.  And using some is defined as:  usingSome a r = do r' <= get_r; set_r r; rv <- a; set_r r'; return rv.  While this works well, it seems like I'm cheating or something.
17:33:49 <moconnor> Does that make enough sense to comment on?
17:33:52 <sorear> gah!
17:33:57 <sorear> dynamic scoping!
17:34:02 * sorear flees
17:34:33 <sorear> you'd be much better off using the Reader monad.  or parameters, for that matter.
17:35:21 <sorear> (or maybe you should be using runState?  runState :: State s a -> s -> (a,s) )
17:35:53 <iron32> Anyone have an opinion about the best haskell book ?
17:36:47 <pbx> Just to jump on that one, any opinions especially on the new Hutton book?
17:37:19 <moconnor> sorear: I was using the Reader monad, but then I decided sometimes I wanted those settings to stick around.  Not having to have all my methods have this state parameter is what I was trying to avoid.  I'm not sure what you mean about runState().
17:38:04 <iron32> pbx : I was looking at that one as well thinking about buying it
17:39:00 <sorear> moconnor: your solution is legit, then.
17:39:12 <fasta_> moconnor: I am doing something similar.
17:39:21 <fasta_> moconnor: imho, it's a very nice solution.
17:39:24 <sorear> as long as you're just using State (single threaded, no exceptions) it should be safe.
17:39:54 <moconnor> sorear: thank you
17:40:49 <mbishop> http://people.bath.ac.uk/cs3nb/Prog4/Primaryapplications.html
17:40:51 <lambdabot> Title: Haskell: Primary Application Domains
17:40:56 <moconnor> fasta_: Cool, I still don't have a good sense of proper Haskell idioms.  It's good to know other people do what I'm doing, it makes it seem more legit.  I was curious if there was an obviously better way.  Thank you.
17:41:56 <pbx> iron32: As best I can tell, it's the only Haskell book that has come out in the last six or seven years. People have said good things about the Hudak book, but the multimedia angle kind of weirds me out.
17:44:31 <pbx> The other common recommendation I've gotten is the Thompson book (The Craft of Functional Programming), which is generally well reviewed.
17:45:38 <fasta_> moconnor: I am not some Haskell Oracle, but if you are doing it wrong rest assured here's someone else doing the same thing :)
17:46:00 <mbishop> http://www.ffconsultancy.com/free/bunny/
17:46:03 <lambdabot> Title: Stanford bunny using OpenGL from OCaml
17:47:40 <iron32> pbx: Actually Paul Hudaks book is the only haskell book I enjoyed it but my FP knowledge isn't that great so I ordered  Introduction to Functional Programming using Haskell by Richard Bird hoping I will have better luck with that
17:47:46 <iron32> sorry for the slow responses
17:48:04 <pbx> No rush, I was learning about the Bunny
17:49:41 <iron32> I guess a lot of people who are into haskell already have a solid base in FP
17:50:57 <mbishop> iron32: I too have SOE, and want to get Bird's book
17:51:54 <sjanssen> @seen dcoutts
17:51:55 <lambdabot> dcoutts is in #happs, #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 2h 16m 45s ago.
17:52:06 <fasta_> Is this code a GHC extension? [ black, red, green, yellow, blue, magenta, cyan, white ] = map Color [0..7]
17:52:33 <fasta_> That is top-level pattern bindings?
17:52:35 <iron32> mbishop : Well I like a lot of what Paul Hudaks writes about DSL's but I find it a little advanced for a novice to FP like myself
17:52:50 * mbishop nods
17:53:40 <mbishop> I'm waiting on reviews for that new haskell book to see if I should perhaps get that one instead
17:55:25 <iron32> mbishop : How long have you been coding in haskell/FP
17:56:04 <mbishop> Not very long, I got SOE like, a month ago maybe?
17:56:38 <fasta_> mbishop: Already read SICP?
17:56:44 * mbishop nods
17:56:46 <mbishop> well, most of it
17:57:03 <mbishop> I should probably finish it before moving on heh
17:57:05 <fasta_> mbishop: I can't really recommend Algorithms, a functional approach.
17:57:21 <sjanssen> fasta_: top level pattern bindings are standard Haskell
17:57:50 <fasta_> sjanssen: it was new for me.
17:58:02 <sjanssen> yeah, you don't see it very often
17:59:32 <mbishop> fasta_: why is that? (about the book)
18:00:32 <fasta_> mbishop: it only contained a somewhat interesting discussion about graph reduction and that even was very short. The rest was pretty basic.
18:00:59 <fasta_> mbishop: like proving equivalence between two reverse implementations.
18:01:08 <fasta_> mbishop: via the calculation method.
18:01:08 <mbishop> ah
18:01:24 <mbishop> fasta_: Do you have a book (haskell based) that you recommend?
18:02:14 <fasta_> mbishop: I think SOE can be interesting if you are new to programming, but otherwise no.
18:02:17 <gotaku> Where can I find a description of each of the standard monads included in ghc?
18:02:34 <fasta_> gotaku: tried Google?
18:02:46 <fasta_> gotaku: All about monads.
18:02:57 <fasta_> (those are keywords)
18:03:01 <mbishop> Well I already have SOE, and I've got SICP and CLRS, all the other books are either language specific or just general (like GEB...dunno what category that fits into)
18:03:23 <fasta_> mbishop: GEB?
18:03:30 <mbishop> Godel, Escher, Bach
18:03:34 <fasta_> Ah, ok
18:04:04 * mbishop is listening to Bach right now :o
18:04:15 <fasta_> mbishop: the next step is reseach papers, I think.
18:04:34 <bos> @where all about monads
18:04:35 <lambdabot> I know nothing about all.
18:04:41 <bos> @google all about monads
18:04:43 <AStorm> @where monad
18:04:45 <fasta_> mbishop: well, there are some other algorithms books.
18:04:46 <lambdabot> http://www.nomaware.com/monads/
18:04:46 <lambdabot> I know nothing about monad.
18:04:52 <AStorm> @where monads
18:04:52 <lambdabot> http://www.nomaware.com/monads/html/index.html
18:05:05 <mbishop> Well I've been reading alot of SPJ's stuff, if that counts as research papers :)
18:05:36 <fasta_> mbishop: well, and it would also be nice if you actually implement something someday.
18:05:37 <iron32> bishop : CLRS ?
18:06:04 <fasta_> iron32: Introduction to Algorithms
18:06:12 <fasta_> iron32: I have the book next to me :)
18:06:42 * mbishop has a stack of books up to his waist
18:06:43 <iron32> Ok haven't tread that one
18:07:12 <jancker> chakravarty book?
18:07:15 <fasta_> mbishop: TAOCP?
18:07:15 <mbishop> fasta_: Well, I did make a little haskell program to pick a random fast food place for me to eat at, does that count? :)
18:07:22 <mbishop> fasta_: only volume 1, but yeah
18:07:33 <fasta_> mbishop: did you make the exercises?
18:07:41 <mbishop> in TACOP? no
18:08:16 <iron32> hmm TACOP ?
18:08:41 <fasta_> It's spelt TAOCP
18:08:47 <orbitz> is there a nicerway to write: productAll' n xs ((reverse (sort (take n l)))):acc)
18:08:56 <dons> @tell sorear vty doesn't build out of the box on my machine
18:08:57 <lambdabot> Consider it noted.
18:09:00 <dons> let me send you some patches...
18:09:18 <dons> ?where vty
18:09:18 <lambdabot> http://members.cox.net/stefanor/vty/
18:09:40 <mbishop> Haha whoops I typo'd it
18:09:44 <jancker> orbitz: nicer or more efficient way?
18:09:45 <jancker> hehe
18:09:49 <mbishop> iron32: The Art of Computer Programming by Knuth
18:09:50 <iron32> Your taking about Knuths book
18:10:51 <orbitz> jancker: i'll take both
18:11:18 <sjanssen> orbitz: you should consider "sortBy (flip compare)" instead of "reverse (sort"
18:11:19 <orbitz> (i ahve 1 too many ) in there btw)
18:11:28 <orbitz> sjanssen: oh indeed
18:12:14 <orbitz> anything else I can do?
18:13:56 <orbitz> i can use $ instead of lto sof () right?
18:13:59 <pbx> Well, I think I'm going to buy the Hutton book and see how that goes.
18:14:06 <dons> @tell sorear the darcs version builds though. let's upload that on the next release
18:14:07 <lambdabot> Consider it noted.
18:15:05 <iron32> pbx : How long you been coding haskell/FP
18:15:10 <orbitz> hrm if i have
18:15:31 <orbitz> t = ["13223", "231"]  i want to do: map (List.product . read :: Int) t but that isnt' right
18:15:41 <orbitz> oh duh
18:15:43 <orbitz> List.product is wrong
18:15:51 <orbitz> silly me sorry
18:16:19 <orbitz> well ther eis mreo wrong with that
18:16:23 <orbitz> but i don't wna tot do taht anyways
18:16:23 <pbx> iron32: Well, I chose it as my language-to-learn for 2007 and have read several of the popular tutorials, but that's about it.
18:16:37 <augustss> orbitz: yes, the ::Int isn't right
18:16:52 <xic> pbx: are you one of those ruby dudes who every year has a "language-to-learn"?
18:16:55 <orbitz> augustss: how would i suggest which read to us?
18:17:14 <pbx> xic: Not a Ruby dude, but yeah.  It's a Pragmatic Programmers thing.
18:17:21 <allbery_b> it's String -> Int; read is a function :)
18:17:25 <augustss> orbitz: read doesn't have type Int, it has type String->Int
18:17:26 <allbery_b> </pedant>
18:17:40 <allbery_b> sadly ghc is more pedantic than anyone here...
18:17:41 <hyrax42> the hutton book is nicely cheap
18:17:42 <xic> pbx: after you learn haskell, you won't want to learn any other language :)
18:17:57 <hyrax42> I think I will buy it to see how well it continues after chapter 5
18:18:05 <augustss> orbitz: but it's still wrong.  what are you trying to do?
18:18:07 <xic> pbx: you'll want to keep learning more and more haskell. and then even more haskell. it never ends :)
18:18:14 <orbitz> augustss: ohh wonderufl thank you
18:18:15 <pbx> xic: Could happen! I really like it. I'm a web guy so I hope do be doing some Happs apps by summer.
18:18:43 <augustss> > product (map read ["13223", "231"]) :: Int
18:18:44 <lambdabot>  3054513
18:18:51 <orbitz> augustss: well what i really want do is atke that list of stringsa nd tutrn it into [[Int]]  and then ge tte product
18:19:11 <dons> Igloo: re. newArray_ and garbage, a memset in there would be a reasonable solution
18:19:22 <orbitz> and in teh end i'd have a result of [List.product [1,3,2,2,3], List.proudct [2,3,1]]
18:19:25 <dons> (I had to do exactly this today, for a shootout entry)
18:19:27 <augustss> orbitz: do you want each digit to be an Int
18:19:33 <orbitz> augustss: yes
18:19:37 <iron32> pbx : I agree with prag about knowing several languages but knowing a language per paradigm is more than sufficient knowing 12 dozen imperative languages will only hurt you not help you
18:19:40 <augustss> oh, ok
18:20:09 <orbitz> augustss: so my resut will be an [Int] but i guess firs ti need to producea  [[Int]] and then List.product that inner list
18:20:20 <augustss> > map (product . (read :: String -> Int) . (:[])) ["13223", "231"]
18:20:21 <lambdabot>  Couldn't match `[a]' against `Int'
18:20:28 <ddarius> iron32: Knowing 12 dozen imperative languages won't hurt you.  The wasted learning most of them will.
18:20:29 <Igloo> dons: Perhaps, but I'm not convinced it wouldn't make more sense not to have newArray_ for strict arrays
18:20:33 <csci> Simple'n'stupid question: how do I convert an Int to a Double?
18:20:51 <augustss> > map (product . (read :: String -> Int) . map (:[])) ["13223", "231"]
18:20:52 <lambdabot>  Couldn't match `Char' against `[a]'
18:20:57 <pbx> iron32: Totally agree -- that's why I chose Haskell and not Ruby for 2007. Next year will probably be CL or Scheme.
18:21:00 <augustss> arg
18:21:37 <orbitz> csci: is ther a toDouble?
18:21:59 <csci> orbitz, hoogle did not found one
18:22:20 <csci> I'd also take a toReal, but neither :-/
18:22:23 <allbery_b> > map (product . map (subtract 48 . ord)) ["13223", "231"]
18:22:25 <lambdabot>  [36,6]
18:22:29 <xic> csci: try fromIntegral
18:22:39 <augustss> > map (product . map ((read :: String -> Int) . (:[]))) ["13223", "231"]
18:22:40 <lambdabot>  [36,6]
18:22:44 <orbitz> csci: fromIntegeral?
18:22:51 <csci> xic, Thanks
18:22:59 <orbitz> csci: fromIntegral 1 :: Double
18:23:02 <orbitz> give sme 1.0
18:23:34 <ddarius> @hoogle Char -> Int
18:23:35 <lambdabot> Char.digitToInt :: Char -> Int
18:23:35 <lambdabot> Char.ord :: Char -> Int
18:23:46 <augustss> map (product . map digitToInt)  ["13223", "231"]
18:23:47 <orbitz> allbery_b: eep that looks a bit ugly with teh acii dependencie?
18:23:56 <iron32> pbx : Well I am not a big ruby fan since SmallTalk is better in everyway
18:24:01 <allbery_b> > map (product . map digitToInt) ["13223", "231"]
18:24:02 <lambdabot>  [36,6]
18:24:07 <ddarius> iron32: Ever look at Self?
18:24:09 <orbitz> ohh i like that one
18:24:10 <allbery_b> I keep forgetting about digitToInt
18:24:28 <allbery_b> @slap allbery_b
18:24:29 <lambdabot> why on earth would I slap allbery_b
18:24:36 <allbery_b> because he's a doof?
18:24:54 <iron32> Yes I have looked at self looks interesting but did not delve into yet do you like it ?
18:25:20 <pbx> iron32: Have you played with Io at all?
18:25:21 <orbitz> in ghci, can i remove 1 variable, for instnace if i realize i assigned a value to it wrong so i wantot modify it but keep all my other values there still
18:25:39 <iron32> Pbx: Haskell IO you mean
18:25:55 <iron32> or an language called Io
18:26:07 <pbx> iron32: No, iolanguage.COM
18:26:16 <augustss> orbitz: you can make a new binding, but you can't change what you've done before
18:26:23 <pbx> (sorry for the caps)
18:26:31 <iron32> No never heard of it even
18:26:43 <orbitz> augustss: i know :load and :reload wipe out altl eh bindigns i have but i can't just remove 1 binding ?
18:26:48 <pbx> It's pretty neat. Prototype-based OO, very light syntax
18:26:51 <orbitz> in erlang i'd do liek f(Foo)
18:26:56 <iron32> ddarius : What did you think of self ?
18:27:17 <augustss> orbitz: why would you want to?
18:27:31 <pbx> iron32: I mentioned Io because it uses a message-passing model and claims to take certain concepts from Self
18:27:39 <ddarius> It seems/seemed a lot better than Smalltalk in both design and implementation.
18:27:55 <fax> io is really really cool btw
18:27:56 <orbitz> augustss: i have established some bindings already but i amd ea mistake one calculauting one so i'd like ot simply rebind it then hit up until I have teh function i wan tto call again wiht the othe rbindigns
18:28:02 <fax> ive used it quite a bit
18:28:31 <augustss> orbitz: so why not just bind it again?
18:29:02 <orbitz> augustss: err that works i wa sunder the impression it wouldn't be modifyable
18:29:05 <orbitz> but of ocure si works, hanks
18:29:15 <iron32> pbx: Thanks thats interesting
18:29:17 <ddarius> iron32: But I tend to be a fan of prototype or lambda based object orientation as opposed to class-based systems.
18:29:57 <augustss> orbitz: you're not modifying the old one.  you are just making a new one that shadows the old one.
18:30:43 <orbitz> augustss: ok
18:31:12 <orbitz> hrm this question on projecteuler was oddly simple, even my unefficent algorithm solved it in a blink, that's kind ofa letdown
18:32:15 <calvins> orbitz: which question number?
18:32:31 <orbitz> 8
18:32:31 <orbitz> ind the greatest product of five consecutive digits in the 1000-digit number.
18:32:40 <iron32> ddarius : I see well I never used a language like self that is prototype based oo but what I have seen of lambda based oo ( I assume you mean the kind of polymorphic behaviors offered in FP ) I really like more then class based OO
18:33:00 <orbitz> head $ List.sortBy (flip compare) $ map (product . map Char.digitToInt) $ productAll 5 largenum
18:33:03 <orbitz> was my solution
18:33:32 <bos> is there a predefined list chunking function?
18:33:38 <calvins> yeah, a lot of the problems are too easy to do poorly and still do in very quickly.
18:33:46 <bos> i.e. chunksOf 3 "foobarbaz" => ["foo","bar","baz"]
18:33:52 <ddarius> iron32: E uses a lambda-based OO system.  To me prototype-based OO and lambda-based OO systems are very similar.
18:34:00 <calvins> i wish more of them had such large numbers that they required a good algorithm..
18:34:04 <augustss> bos: i wish!  I use it a lot
18:34:25 <bos> augustss: i thought i wasn't being careful enough in looking through Data.List :-()
18:34:42 <ddarius> chunksOf = map . take
18:34:58 <ddarius> Er
18:35:04 <pbx> G'night all
18:35:20 <iron32> ddarius : Well unfortunately I don't think I know what lambda based OO is then I have read papers on self so I understand a little bit about its prototype system
18:35:58 <ddarius> @type unfoldr
18:36:00 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
18:36:19 <ddarius> @type split
18:36:20 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
18:36:53 <orbitz> hrm if i want to find all the Nth prime, all i really need to divide by are all the primes I know right?
18:37:08 <augustss> bos: a function I'd like to see is chopList.  then chunksOf n = chopList (splitAt n)
18:37:29 <dons> ok. let's see if this yi syntax highlighting works
18:37:45 <augustss> orbitz: yeah, not even all of them
18:38:09 <orbitz> augustss: all those > sqrt ?
18:38:12 <orbitz> sqrt X
18:38:44 <augustss> yes, except the fast test is p*p <= n
18:38:59 <orbitz> augustss: hrm?
18:39:10 <augustss> not p < sqrt(n)
18:39:21 <orbitz> oh of coures
18:39:22 <bos> augustss: yes, would be nice
18:39:26 <dons> ok . wow. yi with syntax highlighting. works!
18:39:46 <augustss> dons++
18:39:48 <sorear> tell fodder!
18:39:49 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:39:57 <dons> augustss: no, sorear wrote it!
18:40:01 <orbitz> dons: i saw that paper you wrote on yi/lambdabot looks pretty interesting, like a nice way of getting that wonderufl erlang ocde replacement in haskell
18:40:02 <dons> sorear: ok. very very happy right now :)
18:40:12 <augustss> sorear++
18:40:14 <dons> sorear: i note that in general it feels slower than it used ot?
18:40:25 <dons> yi used not to have any noticeable delay (w/o syntax hl)
18:40:34 <dons> but it scrolls with noticeable lag now?
18:41:11 <dons> but, ok. this is very good. now maybe we can get yi==vim out the door
18:41:47 <sorear> @messages
18:41:47 <lambdabot> dons said 32m 51s ago: vty doesn't build out of the box on my machine
18:41:47 <lambdabot> dons said 27m 41s ago: the darcs version builds though. let's upload that on the next release
18:41:50 <dons> mmm :) the 2 features I didn't get immplemented have now been added: line wrapping and syntax highlighting
18:41:57 <dons> thanks sorear and jyp
18:42:05 <dons> i can use yi for my editing now, I think.
18:42:18 <bos> augustss: as in, chop :: ([a] -> ([a], [a])) -> [a] -> [[a]]  ?
18:42:25 <dons> sorear: so what's the src of this laggy scrolling?
18:42:27 <sorear> dons: yes, *big* lag ... i'm working on incremental now and actually have a workable (if ram hungry) solution
18:42:29 <bos> yes, would be nice.
18:42:30 <dons> is it vty, or some unprofiled overhead ?
18:42:41 <dons> (and why do we pay the cost even when syntax is off?)
18:42:52 <sorear> dons: the screen is rerendered every time you scroll
18:43:04 <dons> ah ok. is that vty's fault?
18:43:10 <augustss> bos: yes.  and it stops when the second component is empty
18:43:13 <dons> and is it true that there is no curses support now?
18:43:19 <sorear> dons: there SHOULD be no noticable change with syntax off
18:43:24 <sorear> there is?
18:43:24 <dons> ok.
18:43:45 <dons> its just as laggy with syntax off
18:43:52 <dons> which surprised me. but that's expected?
18:43:52 <sorear> dons: so, curses-yi didn't rerender the whole screen?
18:44:02 <sorear> dons: no, very unexpected
18:44:04 <dons> curses just updates the lines you touch
18:44:29 <dons> curses goes to great lengths to do that, in fact
18:44:37 <dons> with the whole double buffering window thingy
18:44:51 <sorear> dons: I added a test to rerendering for Just v. Nothing ... that should be the only slowdown with :set ft=none
18:45:07 <dons> ok. checking..
18:45:23 <sorear> dons: vty goes *much* further than ncurses to avoid redundant wire refreshes;
18:45:36 <dons> ah ok. it does seem less laggy, yes
18:45:36 <sorear> the question is about application-level recomputation.
18:45:48 <sorear> but it still seems lagging?
18:45:51 <dons> scrolling feels slower than it used to be
18:45:56 <dons> but its definitely faster than with syn on
18:46:23 <dons> its acceptable though
18:46:44 <dons> though we don't get a prompt from the curses in the cmdline at the bottom of the screen ?
18:46:51 <dons> soryr, cursor
18:47:00 <sorear> I notice that too
18:47:22 <sorear> I think it's a bug in jyp's ui code, not setting curser in the minibuffer correctly
18:47:55 <dons> otherwise, looks in good shapee
18:48:17 <sorear> dons: woah - scrolling around with syn off takes 100% cpu :( :( :(
18:48:49 <sorear> with yi/vty it recalculates the entire screen to see that nothing changed
18:49:05 <sorear> what state was yi/curses in wrt recalculation avoidance?
18:49:14 <dons> it was highly tuned
18:49:26 <dons> i.e. you could scroll faster than in vim
18:49:31 <dons> so we need to pay attention to these usability issues
18:49:34 <sorear> oh, wait, I'm also using a profiling build - would that slow things down?
18:49:42 <dons> it would
18:49:47 <dons> but there still seems to be some careful tuning needed
18:50:47 <sorear> dons: I've read the profile ... scarily, after a minute of scrolling ~10 cost centers each carry ~9% of the cost.  so it won't be an easy tune.
18:51:06 <sorear> I also have no experience interpreting ghc profiles ...
18:51:12 <dons> the important thing is to avoid copying the screen around.
18:51:31 <dons> hence all the effort to do zero-copying buffer views in the old curses ui
18:52:02 <sorear> gah
18:52:05 <dons> i think i spent 3 days optimising the scrolling in curses yi :)
18:52:19 <sorear> yi/vty does VAST amounts of copying the screen around
18:52:29 <dons> it'd be worth getting a curses build of yi just for comparision
18:52:42 <dons> since i wouldn't like to release until we had back that level of performance
18:52:45 <sorear> also, vty itself uses [((Char,Attr))]
18:52:50 <dons> urgh
18:52:52 <sorear> er [[(Char,Attr)]]
18:53:04 <dons> wouldn't [(Token,Attr)] be better
18:53:09 <dons> oh, lines , I see
18:53:18 <dons> at least Token could be T !ByteString though
18:53:33 <dons> and then you could just set the attr and do a zero-copying pass of the bytestring chunk to the ui
18:55:48 <sorear> also, vty receives a [[(Char,Attr)]] and keeps an old one, and does all comparison itself.
18:55:53 <sorear> this could be Optimized.
18:56:04 <sorear> ie with hints
18:56:24 <sorear> but just not using a last list could help if this is a bottleneck
18:58:21 * sorear reads profiler docs
18:59:15 <dons> yeah, at least the code works. we can always profile and improve
18:59:26 <mbishop> http://www.dadgum.com/james/shootout.html
18:59:28 <lambdabot> Title: Erlang and the Great Computer Language Shootout
19:00:55 <sorear> well, I don't understand the profiler, so it is beneficial for me to read the docs even if I don't need the info now.
19:01:03 <dons> hmm "Updated October 28, 2002" mbishop
19:01:17 * mbishop shrugs
19:01:24 <mbishop> just thought it might be interesting :P
19:01:30 <dons> most of the benchmarks don't exist anymore :)
19:01:40 <dons> and erlang still does badly ;)
19:02:08 <dons> the shootout is quite fun for hitting your langauge in nasty ways though
19:02:22 <dons> since you just wouldn't write programs in haskell the way they require you to in the shootout in some cases
19:02:46 <dons> hehe http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=hipe
19:02:48 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/28d6h2
19:08:16 <sorear> gah.  I can't believe it took me this long to notice a file named "Yi.hs"
19:08:58 <dons> heh
19:09:46 <sorear> these profiles are really starting to make sense ...
19:10:38 <sorear> Yi.UI.start uses 45% cpu, for instance
19:11:12 <mbishop> http://video.google.com/videoplay?docid=-5830318882717959520
19:11:13 <lambdabot> Title: Erlang: The Movie - Google Video
19:11:16 <mbishop> heh
19:11:32 <dons> sorear: ah, now we're getting somewhere
19:12:01 <sorear> gah.  all start does (loopily) is read keystrokes!
19:12:16 <sorear> dons: there are no vty functions in this profile
19:12:52 <sorear> how do I get cabal to pass -auto-all?
19:13:21 <mbishop> There needs to be a Haskell - The movie
19:14:06 <chessguy> hi haskellers
19:14:18 <sorear> hi!
19:15:29 <dons> sorear: in the ghc-optoins
19:15:33 <dons> this is a cabal bug, inmo
19:15:38 <sorear> dons: ick
19:15:45 <sorear> dons: oh...
19:16:29 <sorear> so now I need to make vty 2.0.3!
19:17:24 <chessguy> hey dons, did you get my @tell ?
19:17:28 <chessguy> ?hoogle StateT
19:17:29 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
19:17:29 <lambdabot> Control.Monad.State.StateT :: newtype StateT s m a
19:17:29 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
19:17:40 <sorear> chessguy: dons got 1 tell
19:17:54 <sorear> @help print-notices
19:17:55 <lambdabot> print-notices. Print the current map of notes.
19:18:03 <chessguy> @print-notices
19:18:04 <lambdabot> Not enough privileges
19:18:40 <sorear> I wondered if it allowed a name and forgot about /msg.
19:18:48 <sorear> it's next to useless for spyign
19:18:51 <sorear> @print-notices
19:18:52 <lambdabot> {"TreyHarris:":=(Nothing,[Note {noteSender = "markstos", noteContents = "Thanks for the unspecced clarification.", noteTime = (1159042987,796842000000), noteType = Tell}]),"agentzh:":=(Nothing,[Note
19:18:52 <lambdabot> {noteSender = "markstos", noteContents = "I've made several links to L<S16>, which is described in S29, but doesn't exist. Perhaps these shouldn't be considered errors now since we know the document
19:18:52 <lambdabot> will eventually exist.", noteTime = (1158062003,104344000000), noteType = Tell}]),"andara:":=(Nothing,[Note {noteSender = "audreyt", noteContents = "does webterminal server actually spawn children?
19:18:52 <lambdabot> it doesn't look like it", noteTime = (1161059780,744336000000), noteType = Tell}]),"augustss:":=(Nothing,[Note {noteSender = "astrolabe", noteContents = "Just a sketch http://hpaste.ath.cx:8000/23",
19:18:55 <lambdabot> noteTime = (1169425156,589759000000), noteType = Tell}]),"dcoutts:":=(Nothing,[Note {noteSender = "dons", noteContents = "random public complaint about gtk2hs on freebsd, http://programming.reddit.
19:18:58 <lambdabot> [110 @more lines]
19:19:29 <sorear> see? nothing but stale notes.  and would taek 5 minutes to read the whole thing at flood-control rates.
19:19:31 <chessguy> sorear, well dons will know whether he got it or not, perhaps you should just let him answer
19:24:57 <sorear> gah...
19:25:12 <sorear> I wish there were a -hs-ext=".hs~" option
19:25:40 <sorear> i've just rendered yi unbuildable by implementing half of incremental highlighting.
19:29:56 <csci> What can I take when I want some kind of IO NoOp, e.g. if something then IO NoOp else do-some-IO-with-return-type-() ?
19:30:38 <allbery_b> return () -- ?
19:30:57 <moconnor> Is there a way to export a module B from module A *and* export all of module A's symbols w/o manually listing them?  I.e. I wish this worked: "module A (module B, ...) where" and the ... was stand in place of all the symbols that'd get exported had I just done "module A where"
19:31:00 <csci> allbery_b, but doesn't the programm return then and does not execute the rest of the do-statements?
19:31:32 <allbery_b> csci: returbn doesn't mean procedural return, it means wrap its argumnt in the monad
19:31:45 <allbery_b> moconnor: that works as long as you didn't import qualified
19:32:06 <allbery_b> if you did import qualified, I'm not sure what works; at least, import qualified ... as ... seems t not re-export
19:32:09 <csci> allbery_b, doh ;-) Thanks
19:32:26 <chessguy> return is such a terrible name
19:32:34 <hyrax42> for haskell packages, debian or ubuntu or no real difference?
19:32:37 <allbery_b> yeh, I kinda wish it'd been called unit
19:32:39 <allbery_b> or something
19:32:44 <hyrax42> *or other distributions?
19:33:40 <chessguy> hyrax42, i've had a good experience so far with FC5
19:33:53 <moconnor> allbery_b: If I put ... in the export list I get a syntax error
19:33:57 <hyrax42> hmm I will consider
19:34:03 <allbery_b> just put "module A"
19:34:04 <moconnor> allbery_b: I'm not importing qualified
19:34:08 <hyrax42> I have a "bad feeling" about rpms though
19:34:12 <hyrax42> for whatever reason
19:34:16 <allbery_b> module Foo (mdule Bar) where ...
19:34:20 <ddarius> chessguy: Usually you write return in the same places you would in a language with C-style syntax.
19:34:25 <chessguy> hyrax42, i install most things from scratch
19:34:32 <allbery_b> module Foo (module Bar) where ...
19:34:39 <chessguy> or use the package installer
19:34:42 <hyrax42> chessguy: haskell things or all things?
19:34:51 <chessguy> hyrax42, haskell things
19:34:56 <hyrax42> ok
19:35:14 <hyrax42> hackage needs to get done :(
19:35:28 <chessguy> it ships with ghc 6.4.2 though, so you'll have to upgrade it
19:35:47 <hyrax42> ack I still run 6.4.2 on here
19:35:47 <allbery_b> csci: one way to think about return there is that each leg of the if-then-else is a local function, so you're "returning" from that
19:35:48 <moconnor> allbery_b: hmm, if I do that: "module A (module B) where c=1" then c is not exported from module A.
19:35:59 <allbery_b> sure, list c in the export list as well
19:36:01 <hyrax42> I'm loath to upgrade, because I'm not sure I want to deal with the 10 hours comiple
19:36:19 <moconnor> allbery_b: ahh, see that was my original question.  I didn't want to manually list things.
19:36:21 <allbery_b> module Foo (a, module Bar, c, {- mroe here if you want -}) where ...
19:36:35 <chessguy> hyrax42, geez, how bad is your hardware
19:36:40 <moconnor> allbery_b: ok, thanks.
19:36:41 <allbery_b> oh, you want complete export of yur module plus some other one
19:36:42 <allbery_b> not sure
19:36:43 <hyrax42> iBook G4
19:36:45 <hyrax42> pretty bad
19:36:52 <csci> allbery_b, ah ok, thanks
19:37:13 <hyrax42> chessguy: did you end up solving your earlier problem?
19:37:33 <chessguy> hyrax42, which one?
19:37:43 <sorear> csci: btw, you can use 'when'
19:37:45 <hyrax42> turning a function into a function on tuples
19:37:45 <sorear> @ty when
19:37:48 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:37:50 <ddarius> chessguy: It didn't take that long when I was compiling on a Pentium 2 200Mhz with 64MB of ram
19:38:03 <sorear> so e.g when True (print "True")
19:38:03 <chessguy> hyrax42, ah. that became irrelevant
19:38:10 <sorear> unless also exists
19:38:13 <hyrax42> ddarius: but iBook G4 is a special flavour of slow
19:38:23 <ddarius> chessguy: It did take in that vicinity though.
19:38:27 <hyrax42> reserved for people like me who can't afford macbooks
19:38:36 <hyrax42> but still want os x
19:38:40 <siti> pfft osx
19:38:46 <ddarius> er: s/chessguy/hyrax42
19:38:47 <allbery_b> enh.  I still find mine useful... but I don't do compiles on  it :)
19:38:50 <chessguy> ddarius, 10 hours? it tooke me maybe an hour on my AMD Turion
19:38:52 <allbery_b> (then again, I do on the g4 mini)
19:39:00 <hyrax42> ddarius: it's ok, I have built-in error correction :)
19:39:09 <chessguy> hyrax42, CRC?
19:39:20 <csci> sorear, Great :D
19:39:43 <hyrax42> chessguy: not just detection
19:40:09 <chessguy> hyrax42,  hmm. i thought CRC did both
19:40:14 <hyrax42> oh
19:40:16 <hyrax42> could be
19:40:43 <hyrax42> I just unfolded the acronym, and it seems more like just a detection sounding thing no?
19:40:49 <hyrax42> ?google wikipedia crc
19:40:51 <lambdabot> http://en.wikipedia.org/wiki/Cyclic_redundancy_check
19:40:52 <lambdabot> Title: Cyclic redundancy check - Wikipedia, the free encyclopedia
19:41:11 <sorear> CRC *can* do error correction, but it's impractical.
19:41:48 <hyrax42> hm
19:43:59 <hpaste>  csci pasted "(still) not working: using return in if-statement" at http://hpaste.org/299
19:45:55 <csci> Anyone has an idea?
19:46:02 <hpaste>  chessguy pasted "Almost-working Store" at http://hpaste.org/300
19:46:57 <sorear> dons: profiling++ it's all vty's fault
19:46:57 <sorear> intMkVty                       Graphics.Vty          44.3   29.5    125 194377474
19:47:15 <sorear> the #1 cost center
19:47:15 <chessguy> i don't know why it's not matching the type in main
19:47:28 <hyrax42> :t execStateT
19:47:29 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
19:47:51 <hyrax42> I think you want evalState?
19:47:58 <hyrax42> :t evalStateT
19:48:00 <lambdabot> forall a (m :: * -> *) s. (Monad m) => StateT s m a -> s -> m a
19:48:15 * allbery_b agrees, execStateT returns the final State which is not ()
19:48:29 <hyrax42> (I never remember which is which, but the types tell you)
19:48:40 <hyrax42> eval returns the value in, exec returns the state
19:48:44 <hyrax42> and run returns both
19:48:47 <hyrax42> :t runStateT
19:48:49 <lambdabot> forall s a (m :: * -> *). StateT s m a -> s -> m (a, s)
19:48:53 <chessguy> oh, i had main = print =<< execState...
19:49:00 <chessguy> ?type print
19:49:02 <lambdabot> forall a. (Show a) => a -> IO ()
19:49:15 <chessguy> so that should've worked
19:49:46 <allbery_b> csci: not sure there, I've only used if at the end of a do-block (well, might be a large else, but noting following at the level of the original do)
19:50:05 <allbery_b> *nothing
19:50:06 <chessguy> but that gives the same error
19:50:42 <hpaste>  csci annotated "(still) not working: using return in if-statement" with "Working a bit -> killThread - problem :)" at http://hpaste.org/299#a1
19:50:49 <hyrax42> chessguy: do you actually need it to be StateT  on top of IO?
19:51:04 * hyrax42 was messing with MonadRandom the other day
19:51:06 <hyrax42> from wiki
19:51:23 <chessguy> hyrax42, hmmm
19:51:25 <hyrax42> anyway that's not direclty relevant
19:51:34 <csci> allbery_b, Hmm, I see. According to my laste paste I think it has something to do with the killThread, which makes it even more obfuscated ;)
19:51:43 <chessguy> hyrax42,  you mean simulate?
19:51:44 <csci> :t killThread
19:51:46 <lambdabot> Not in scope: `killThread'
19:52:04 <hyrax42> well I meant you don't actually do any IO, you just use randomRIO
19:52:11 <asoko> csci: weren't you killing myThreadId ?
19:52:17 <chessguy> oh
19:52:26 <chessguy> but isn't that in the IO monad?
19:52:28 <hyrax42> which can be gotten around with either having an StdGen in the state as well or using the MonadRandom form wiki
19:52:29 <asoko> oh, never mind
19:52:31 <csci> asoko, No, I checked that it's not myThreadId but the ID from the forked one
19:52:45 <asoko> right
19:52:48 <hyrax42> chessguy: yeah, you can just thread a pnrg through
19:52:51 <hyrax42> either way works
19:52:59 <chessguy> ok
19:53:03 <chessguy> so why doesn't this code compile?
19:53:35 <hyrax42> what is the type of simulate? StateT StoreState IO ()?
19:53:40 <allbery_b> I see you don't have a type signature for simulate.  comment out main, ask ghci what the type of simulate is
19:54:24 <chessguy> hyrax42, i think so
19:54:26 <chessguy> oh wait
19:54:30 <chessguy> that can't be right
19:54:32 <hyrax42> or do what allbery_b said
19:55:09 <chessguy> i think it needs to be StateT StoreState IO StoreState
19:55:13 <hpaste>  csci annotated "(still) not working: using return in if-statement" with "Problem solved, new one arised: is killThread blocking?" at http://hpaste.org/299#a2
19:55:15 <chessguy> which means it needs a return
19:55:19 <chessguy> (i think)
19:55:31 <asoko> csci: it looks like killThread may block until the killed thread gets the ThreadKilled exception
19:55:33 <hyrax42> chessguy: ask what ghci thinks it is
19:55:47 <asoko> oops, too slow
19:55:49 <hyrax42> you shouldn't need the StoreState as value if you're using execStateT
19:56:10 <chessguy> hmm, ghci thinks it's a 20-line error
19:56:16 <csci> asoko, which leads to the total blocking. Never worked with exceptions and thought I can just kill any thread I forked?
19:56:21 <hyrax42> even with main commented out?
19:56:28 * allbery_b was wondering if it knew what monad you were in
19:56:32 <chessguy>  No instance for (MonadState StoreState IO)
19:56:33 <chessguy>       arising from use of `modify' at Store.hs:46:4-33
19:56:52 <asoko> csci: I'm a newbie, so all i know is what I just read here
19:56:54 <asoko> http://cvs.haskell.org/Hugs/pages/libraries/base/Control-Concurrent.html#v%3AkillThread
19:56:57 <lambdabot> http://tinyurl.com/25k3e4
19:56:57 <hyrax42> mm that is strange
19:57:08 <hyrax42> ?instances-importing Control.Monad.State MonadState
19:57:09 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
19:57:13 <csci> asoko, Yes, reading it atm. But there's nothing about blocking
19:57:48 <asoko> csci: "throwTo does not return until the exception has been raised in the target thread. "
19:58:24 <csci> asoko, Hmm, I see. Ok, then I have to deal with exception handlling. Thanks for your help!
19:58:26 <asoko> could that be it?
19:58:29 <asoko> no prob!
19:59:21 <csci> asoko, I'm quite sure that is/was the problem.
19:59:37 <asoko> cool
19:59:50 <allbery_b> chessguy: it seems to me you need t lift getRandoms
20:00:07 <hyrax42> allbery_b: that is what I was thinking but was undecided
20:00:17 <hyrax42> :t lift
20:00:19 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:00:19 <chessguy> hmm
20:00:20 <hyrax42> :t liftIO
20:00:22 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
20:00:29 <hyrax42> I have not messed with monad transformers very much
20:00:31 <chessguy> from IO into StateT?
20:00:32 <allbery_b> since getRandoms is in IO, simulate is in IO nd the later modify fails to typecheck
20:00:35 <hyrax42> esepcially not on top of IO
20:00:50 <allbery_b> stateT is the bottom of the stack, you need to lift to get into IO from StateT
20:00:56 <allbery_b> where getRandoms can run
20:01:09 <allbery_b> otherwise it assumnes you're in IO, and the modify fails
20:01:26 <allbery_b> rephrase
20:01:33 <chessguy> so lift $ getRandoms ...
20:01:37 <allbery_b> the convntional view is StateT is the top of the stack, I guess
20:01:38 <allbery_b> yes
20:01:43 <chessguy> same error
20:03:23 <hyrax42> Ã©trange
20:03:35 <allbery_b> huuuh
20:03:50 <allbery_b> "Urk! Inventing strangely-kinded void TyCon"
20:04:00 * allbery_b switched to local browser so he could play with it
20:05:04 <chessguy> so i want simulate :: StateT StoreState IO () right?
20:05:21 <allbery_b> yes
20:05:22 <hyrax42> yeah I think so
20:05:31 <hyrax42> stick that in and see what it complains about
20:05:49 <allbery_b> interestingly, that makes it work
20:05:53 <chessguy> lol
20:05:54 <chessguy> so it does
20:06:31 <allbery_b> apparently the type inferencer fails strangely without a signature
20:06:40 <allbery_b> do you also get the "Urk!" with the old one?
20:06:45 <allbery_b> "Urk! Inventing strangely-kinded void TyCon"
20:06:55 <allbery_b> (ghc6.6, OSX PPC)
20:06:57 <chessguy> allbery_b, are you talking to me?
20:07:00 <allbery_b> yes
20:07:05 <chessguy> no, i didn't get that
20:07:13 <allbery_b> before I get the StoreState error I get that "Urk!"
20:07:15 <chessguy> oh!
20:07:16 <chessguy> yes, i did
20:07:19 <hyrax42> I have never seen/heard of the Urk
20:07:23 <allbery_b> which implies that ghc is getting lost/confused
20:07:45 <chessguy> lol, what a ridiculous error
20:07:49 <allbery_b> might be worth writing that up and mailing to the ghc folks
20:08:03 <sorear> allbery_b: no
20:08:06 <chessguy> i'll have to try to make a test case
20:08:08 <allbery_b> hm?
20:08:09 <sorear> allbery_b: i've seen it before
20:08:19 <chessguy_phone> thanks
20:08:23 <sorear> allbery_b: it is documented as a "warning bug"
20:08:32 <sorear> ie it generates correct bytecode
20:08:59 <allbery_b> except it's not, it's followed by a type error which indicates it thinks StoreState is some type with a kind other than *
20:09:16 <allbery_b> if you add the correct type signature, both the Urk! and the type error go away
20:09:21 <sorear> allbery_b: http://hackage.haskell.org/trac/ghc/ticket/959
20:09:24 <lambdabot> Title: #959 (Debugging info(?) leaks out: &#34;Urk! Inventing strangely-kinded void TyC ...
20:09:25 <allbery_b> http://hpaste.org/300
20:09:43 <allbery_b> ignore the bug in  main (comment it out)
20:10:32 <allbery_b> the Urk!'s tycon kind matches the bizarre kind it came up with for StoreState
20:11:17 <allbery_b> (which ...hm
20:11:31 <allbery_b> on second thught, without main (fixed) it doesn't know there's a StteT involved, never mind
20:12:18 <allbery_b> that makes sense, then, it has to assume the StoreState is some kind of monad
20:13:39 <chessguy_phone> why would it have to assume that?
20:15:03 <sorear> gah I hate bash redirection syntax
20:15:08 <sorear> wow scrolling through a non-incrementally highlighed 1M file in yi is very slow
20:15:13 <sorear> on the flip side...
20:15:46 <allbery_b> chessguy_phone: you used modify, therefore there must be a MonadState.  the only thing there it could ossibly be is StoreState, in the absence of the runStateT
20:15:49 <chessguy_phone> ?type side
20:15:51 <lambdabot> Not in scope: `side'
20:15:52 <dons> sorear: you got a curses yi handy for comparision?
20:16:00 <dons> you should aim to match that, I reckon
20:16:07 <allbery_b> (invoked on simulate)
20:16:11 <chessguy_phone> allbery_b, so it assumed that from the name?
20:16:14 <allbery_b> no
20:16:38 <allbery_b> lemme look at it again
20:16:54 <allbery_b> hrm,need to restart ths mozilla, it's slooooow
20:17:06 <sorear> dons: on the flip side, yi can highlight 1M of tex in <1s
20:17:25 <dons> great!
20:17:26 <sorear> of course vty yi does it *every movement character*
20:17:31 <dons> heh
20:17:37 <sorear> that's non-incremental too
20:17:44 <dons> so you're not using the line-based caching from Lexer.x ?
20:17:50 <sorear> no
20:17:55 <allbery_b> it's inferring it from the argument to modify, specifically the signature of nextState
20:17:57 <dons> any chance to use that eventually?
20:18:01 <dons> or do you have a different plan?
20:19:19 <mauke> > minBound `div` (-1) :: Int
20:19:20 <lambdabot> Terminated
20:19:26 <sorear> Yes, I need to look at doing line-based highlighting, with all the associated perks like line-based HL.
20:19:36 <sorear> mauke: Terminated after <3s means signal
20:19:42 <sorear> (usually SIGSEGV)
20:19:47 <mauke> it's SIGFPE
20:19:52 <mauke> it killed my ghci :-)
20:19:57 <sorear> yup
20:20:02 * sorear can explain
20:21:08 <sorear> dons: my Ultimate Plan is a measured cord buffer, with highlighting cached by arbitrary 100-200 char blocks, able to handle 1000000 x's as gracefully as 1000000 newlines.
20:22:06 <sorear> dons: also, the buffer is not the bottleneck now.  profiling scrolling through a 30K file says ~50% vty update code, ~50% jyp's linewrapping code.
20:23:03 <sorear> incidentally the 1M file that was highlighted in <1s was the result of cabals_build_vty_command -fforce-recomp -ddump-everything-i-could-think-of >compile.log 2>&1
20:23:34 <sorear> mg, unsuprisingly, loads it in milliseconds.
20:23:52 <SamB> -ddump-everything-i-could-think-of -- is that an actual flag?
20:24:09 <allbery_b> heh
20:24:10 <sorear> SamB: no more than cabals_build_vty_command is an actual command.
20:25:49 <sorear> dons: another of my Grand Plans is that with lexer combinators it will be *very easy* to reuse terms.  vim has nasty hackery for lex/yacc/c, we can do MMM quite cleanly.
20:26:00 <dons> right
20:27:03 <sorear> yi will support haskell archhackers very well.  even the mighty emacs doesn't do alex.  we will do alex, and happy, and -ddump-simpl, and ...
20:27:49 <sorear> wow
20:28:00 <SamB> ... the "mighty emacs" uses simple regexes to find things
20:28:04 <sorear> -ddump-tc shows you the code of derived instances ...
20:28:13 <sorear> !?
20:28:29 <sorear> wow
20:28:30 <allbery_b> emacs uses regexes for everything
20:28:43 <allbery_b> it's as bad a perl :)
20:28:45 <SamB> I'm just commenting on your strange choice of words
20:36:11 <hyrax42> is yi moving again?
20:37:04 <Anon4888> yi is a Haskell editor in the works?
20:37:21 <hyrax42> it's something dons did to showcase hs-plugins afaik
20:37:29 <hyrax42> "Plugging Haskell In"
20:37:40 <sorear> hyrax42: slowly.
20:38:45 <hyrax42> ah I see it
20:38:47 <hyrax42> http://www.cse.unsw.edu.au/~dons/yi.html
20:38:47 <lambdabot> Title: yi text editor
20:38:51 <hyrax42> project activity graph
20:40:07 <sorear> Gah. Is there no Bool# ?
20:40:25 <SamB> there is no Bool#
20:40:35 <sorear> -funbox-strict-fields + record with 5 strict bools -> record with 5 string bools.   Arggh.
20:40:37 <SamB> you know that Bool is an ADT
20:41:07 <sorear> how do I get ghc to pack my strict bits?
20:41:32 <SamB> this is when it might be nice if GHC let you give it packing advice
20:45:03 <sorear> SamB: worst part: if I do it myself, I won't be able to use record syntax :(
20:45:14 <SamB> yeah
20:45:17 <SamB> exactly
20:45:28 <SamB> GHC should let you tell it how to really represent the data
20:46:38 <Anon4888> I think the right way to fix that is to eliminate types
20:47:06 <Anon4888> (in favor of classes)
20:49:38 <bd_> Does {-# UNPACK #-} not work with records?
20:50:43 <sorear> bd_: i'm using -funbox-strict-fields, isn't that the same?
20:50:54 <sorear> bd_: and I suspect the true culprit is Bool.
20:50:59 <bd_> {-# UNPACK #-} forces a /particular/ field to unpack
20:51:00 <bd_> as in...
20:51:25 <sorear> bd_: {-# UNPACK #-} doesn't work on 2-constructor data types :(
20:51:37 <bd_> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8)
20:51:42 <bd_> [..]
20:51:53 <bd_> oh
20:52:12 <bd_> You could hack the typesystem, so you can do (fieldName x) :: Bool as well as (x `fieldName`) :: Bool -> YourType
20:52:29 <allbery_b> chnage your Bools to Word8s?  mightnot be able to get it down to bits, but perhaps better than boxed Bools
20:55:49 <sorear> allbery_b: that's just ugly. remember this type is part of a library API
20:56:08 <sorear> user code goes ... attr{ fg = reg } ...
20:56:18 <sorear> user code goes ... attr{ fg = red, rv = True } ...
20:59:45 <sorear> dons: when would I find the "best" curses-yi?
21:02:10 <bd_> sorear: ... `fg` reg `rv` True ?
21:02:28 <bd_> haddock might make it ugly though :)
21:05:57 <sorear> dons: I now am studying a Sep 2006 yi
21:17:54 <chessguy> so, i've got three programs which are sketched out (not quite fully written, but most of the type signatures worked out)
21:18:23 <jcreigh> type signatures is (more than?) half the battle.
21:18:33 <chessguy> they're all very similar in structure, and i'm trying to work out how to abstract them so that i can write a single program that will enable me to solve many problems of this type
21:19:03 <sorear> good
21:19:48 <chessguy> i think this is the really hard part though
21:20:08 <chessguy> maybe if i haven't come up with anything tomorrow, i'll pastebin all three
21:21:17 <orbitz> what are the problems?
21:22:46 <chessguy> glguy!
21:22:54 <glguy> whoa!
21:22:57 <glguy> !paste
21:22:58 <hpaste> Haskell paste bin: http://hpaste.org/
21:23:02 <glguy> looks up :)
21:23:02 <chessguy> i have a new idea for pastebin
21:23:07 <glguy> oh?
21:23:23 <chessguy> an upload function, to just upload a whole haskell file
21:23:32 <glguy> ok
21:23:40 <sorear> what is cat2hpaste?
21:23:42 <glguy> a whole small file?
21:23:48 <chessguy> sure
21:23:54 <glguy> cat2hpaste?
21:24:00 <orbitz> taht is what our ##c pastebin use dot do back int eh day
21:24:05 <orbitz> could upload a scrap or a whole file
21:24:14 <sorear> glguy: look at recent pastes
21:24:28 <chessguy> seems like an easy and useful feature to add
21:24:44 <sorear> glguy: I took the liberty of deleting 2 pastes with only "test" as content. hope you don't mind.
21:25:05 <glguy> sorear: I wouldn't give you an account if I didn't want you to use it :)
21:44:10 <LoganCapaldo> err
21:44:20 <LoganCapaldo> @type let a = undefined in fst a == a
21:44:21 <lambdabot> Bool
21:44:32 <LoganCapaldo> I know undefined can have any type
21:44:54 <LoganCapaldo> but shouldn't all occurences of a in that expression have the same type?
21:45:16 <LoganCapaldo> and therefore shouldn't it explode with an infinite type error?
21:45:20 <bd_> tsk, undefined can't have type Int# :)
21:45:26 <allbery_b> yu're getting the result type of (==)
21:45:34 <allbery_b> hm
21:45:37 <bd_> hmm
21:45:43 <mbishop> hmmm
21:45:45 <bd_> > let a = undefined in fst a == a
21:45:46 <lambdabot>  Add a type signature
21:45:50 <bd_> :)
21:45:53 <allbery_b> that is odd, come to think of it, youd'; think the let would freeze a
21:45:56 <allbery_b> maybe not
21:46:05 <sorear> LoganCapaldo: that which is bound by let can be polymorphic
21:46:14 <sorear> that's a big deal in HM
21:46:19 <sorear> let-bound polymorphism
21:46:21 <bd_> @type must not be using the monomorphism restriction
21:46:23 <lambdabot> Not in scope: `must'
21:46:23 <lambdabot>  
21:46:23 <lambdabot> <interactive>:1:9: Not in scope: `be'
21:46:32 <allbery_b> I'd expect MR there, yeh
21:46:37 <LoganCapaldo> bd_: but it works in ghci
21:46:44 <LoganCapaldo> as well
21:46:47 <sorear> bd_: @type uses ghci, > uses ghc.
21:46:51 <bd_> hmm
21:47:09 <bd_> Prelude GHC.Prim> :type let a = undefined in (fst a == a, a)
21:47:09 <bd_> let a = undefined in (fst a == a, a) :: forall a. (Bool, a)
21:47:10 <bd_> heh
21:47:15 <sorear> (> uses runplugs uses hs-plugins calls ghc and loads the result)
21:48:01 <bd_> Why doesn't the type signature up there have an Eq a context?
21:48:27 <LoganCapaldo> bd_: Please make it stop, now i'm even more worried than I was before
21:48:33 <allbery_b> heh
21:48:50 <bd_> LoganCapaldo: I'm afraid I must respectfully decline to abandon this line of inquiry :)
21:49:03 <allbery_b> just accept that undefined is one of the weird little corners of H-M :)
21:49:04 <bd_> hmm
21:49:06 <allbery_b> I guess
21:49:10 <bd_> but even then
21:49:20 <bd_> > let a = undefined :: IO () in a == a
21:49:21 <lambdabot>   add an instance declaration for (Eq (IO ()))
21:49:21 <lambdabot>     In the definition of `uzk'...
21:49:27 <sorear> bd_: because the two occurences of undefined have different types.
21:49:27 <bd_> but that matches a!
21:49:36 <bd_> hmm
21:49:41 <jcreigh> Only Haskell programmers would want well-defined behavior for "undefined" :)
21:49:42 <sorear> bd_: within the let, a has type forall a. a.
21:49:44 <bd_> Prelude GHC.Prim> :type let a = undefined in (fst a == a, a, fst a)
21:49:44 <bd_> let a = undefined in (fst a == a, a, fst a) :: forall a a1. (Bool, a, a1)
21:49:45 <allbery_b> :ty let a = undefined :: IO () in a == a
21:49:53 <allbery_b> @ty let a = undefined :: IO () in a == a
21:49:54 <lambdabot>     No instance for (Eq (IO ()))
21:49:55 <sorear> it does not have a specific type, it *is* polymorphic.
21:49:55 <lambdabot>       arising from use of `==' at <interactive>:1:32-33
21:49:57 <bd_> but there's no (==) :: a -> a1 -> Bool!
21:50:18 <sorear> bd: exactly.
21:50:25 <allbery_b> I think the forall means it mutates as needed, so it is automatically Eq
21:50:28 <bd_> So, the type signature should be:
21:50:37 <sorear> bd_: the two a's in fst a == a have DIFFERENT types
21:50:37 <bd_> forall a. Eq a => (Bool, a, a)
21:50:48 <bd_> sorear: But that should fail to unify with the type of ==
21:50:55 <bd_> wait
21:50:57 <bd_> ic
21:51:03 <glguy> Saizan: ping!
21:51:06 <glguy> ?seen Saizan
21:51:06 <lambdabot> Saizan is in #happs and #haskell. I last heard Saizan speak 8h 53m 55s ago.
21:51:12 <bd_> okay, so a should be (a1, b) ?
21:51:19 <LoganCapaldo> @type let a = [undefined] in head a == a
21:51:21 <lambdabot> Bool
21:51:27 <glguy> oops, I was looking for syntax ninja
21:51:29 <bd_> I can posit an a, a1 matching that type signature for which unification will fail
21:51:31 <sorear> bd_: the two a's are not constrained to have the same type, because the non-recursive let-bindings generalize.
21:51:33 <bd_> for example, () and ()
21:51:34 * LoganCapaldo does not compute
21:51:49 <allbery_b> undefined does not compute
21:51:55 <allbery_b> then again, that's kinda the point of it :)
21:51:58 <bd_> oh
21:51:59 * sorear "understands" perfectly but feels somehow inarticulate
21:51:59 <bd_> I think I see now
21:52:11 <bd_> a and a1 are different from the types in the ==?
21:52:25 <sorear> correct
21:52:29 <LoganCapaldo> @type let a = [a] in head a == a
21:52:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
21:52:31 <lambdabot>       Expected type: a
21:52:37 <sorear> or at least they need not be the same.
21:52:40 <LoganCapaldo> yay
21:52:46 <bd_> :type let a = undefined in (\a -> (fst a == a, a, fst a)) a
21:52:47 <LoganCapaldo> an error that makes sense
21:52:49 <bd_> :t let a = undefined in (\a -> (fst a == a, a, fst a)) a
21:52:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
21:52:51 <lambdabot>       Expected type: a
21:52:52 <bd_> yay!
21:53:13 <bd_> okay, my faith in the stability of the fabric of the universe has been restored :)
21:54:01 <allbery_b> hm, is the lambda actually forcing a concrete type there, or is it the MR at work?
21:54:10 <allbery_b> or rather, a single type
21:54:20 <bd_> when you apply a function, you can only pass in one value
21:54:23 <LoganCapaldo> Ok, what might help is if someone could let a = <blank> in fst a == a fill in the blank with something other than undefined that still worked
21:54:24 <bd_> not a polymorphic expression
21:54:33 <allbery_b> absent MR I'd expect it to get forall a. a as the type still
21:54:34 <sorear> LoganCapaldo: yes.
21:54:39 <bd_> LoganCapaldo: You'd need to define a new typeclass
21:55:04 <sorear> bd_: right.
21:55:20 <LoganCapaldo> where fst was overloaded?
21:55:23 <LoganCapaldo> :(
21:55:27 <LoganCapaldo> I feel like thats cheating
21:55:33 <sorear> why a typeclass?
21:55:56 <bd_> sorear: To produce a polymorphic expression which may or may not be a tuple
21:55:56 <sorear> it just has to satisfy both FOO and (FOO,BAR), for some foo and bar
21:56:05 <bd_> though... I think you'll need to annotate the types in that case
21:56:34 <sorear> @ty let bah = (undefined,undefined) in bah
21:56:36 <lambdabot> forall a a1. (a, a1)
21:56:47 <sorear> @ty let bah = (undefined,undefined) in [bah , fst bah]
21:56:49 <lambdabot> forall a a1. [(a, a1)]
21:57:03 <sorear> bah does not have the type of undefined.
21:57:58 <sorear> @ty let bah = [] in [ map fst bah , bah ]
21:58:00 <lambdabot> forall a. [[a]]
21:58:16 <sorear> bah doesn't even USE undefined
21:58:24 <sorear> look ma, no typeclasses!
21:58:38 <LoganCapaldo> alrigth
21:58:43 <LoganCapaldo> that last one kindof works for me
21:59:16 <sorear> LoganCapaldo: type-wise, a nonrecursive let binding works kinda like a macro.
21:59:40 <bd_> Why not a recursive one?
22:00:13 <bd_> because they're defined with fix?
22:00:15 <sorear> bd_: recursive ones need lambda and fix, as well as macroiness
22:00:33 <LoganCapaldo> alright
22:00:36 <LoganCapaldo> I got this
22:00:38 <LoganCapaldo> I think
22:00:50 <sorear> type inference is awesome
22:00:59 <LoganCapaldo> My mistake was equating let a = b in c to (\a -> c) b
22:01:02 <bd_> sorear: As long as you don't think too hard about it :)
22:01:07 <LoganCapaldo> when it's not
22:01:14 <bd_> LoganCapaldo: the other way works :)
22:01:21 <sorear> LoganCapaldo: operationally, it is.
22:01:32 <sorear> LoganCapaldo: it's just the types that don't work.
22:02:42 <LoganCapaldo> So the type gets determined at the use site
22:02:49 <LoganCapaldo> "use" site
22:03:41 <LoganCapaldo> [map fst a, a] is like [(\q -> map fst q) a, id a]
22:03:54 <bd_> the monomorphism restriction usually prevents this, but ghci relaxes it
22:04:10 <sorear> @tell dons yi will not more than double in speed without changes in vty :(
22:04:10 <lambdabot> Consider it noted.
22:04:19 <glguy> ?seen Cale
22:04:20 <lambdabot> Cale is in #haskell, #haskell-overflow, #ghc and #oasis. I last heard Cale speak 8h 6m 6s ago.
22:05:59 <LoganCapaldo> and since its []
22:06:16 <LoganCapaldo> [(\q -> map fst q) [], id []]
22:06:19 <LoganCapaldo> is perfectly fine
22:07:00 <LoganCapaldo> Its like being vague makes it work
22:09:06 <hpaste>  glguy pasted "Cale's RSS Ag + HAppS (and caching)" at http://hpaste.org/301
22:12:32 <sorear> @localtime ndm
22:12:43 <sorear> @seen ndm
22:12:44 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 8h 54m 4s ago, and .
22:12:52 <bd_> and?
22:13:05 <sorear> bd_: .
22:13:13 <bd_> oh.
22:13:22 <bd_> Makes sense.
22:14:10 <glguy> @tell SyntaxNinja like you asked for :) http://hpaste.org/301
22:14:11 <lambdabot> Consider it noted.
22:28:40 <Cale> glguy: nice
22:29:24 <glguy> I think if nothing else, it serves as an example of how to use the SimpleHTTP2 API with Blocking IO
22:29:34 <glguy> (not much differently than the old api)
22:29:35 <glguy> i think
22:31:20 <hpaste>  nmessenger pasted "another name for the oft-asked-for "if'" function" at http://hpaste.org/302
22:37:11 <LoganCapaldo> nmessenger, I like it
22:37:36 <nmessenger> \o/
22:46:18 <nmessenger> ?let (c?t)f = if c then t else f
22:46:20 <lambdabot> Defined.
22:46:43 <nmessenger> > let x = 2 in x == 1 ? "one" $ x == 2 ? "two" $ "else"
22:46:44 <lambdabot>      Expecting a function type, but found `Bool'
22:46:44 <lambdabot>       Expected type: a -> b
22:46:44 <lambdabot> ...
22:47:01 <nmessenger> (shoot, infixr 1 ?)
22:47:22 <sorear> nmessenger: now, petition dons to add those to Pristine.hs
22:48:21 <nmessenger> sorear: what, the def of (?)?
22:48:43 <nmessenger> wouldn't Haskell' be a better place :)
22:59:35 <hyrax42> d'oh
22:59:41 <hyrax42> foldable is 6.6 only right?
23:00:23 <sorear> iirc yes
23:35:57 <sorear> @users
23:35:58 <lambdabot> Maximum users seen in #haskell: 322, currently: 267 (82.9%), active: 26 (9.7%)
