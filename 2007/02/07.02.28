00:00:13 <dons> so why do you want to parallelise the ghc build system?
00:00:36 <max22> i just want the graph out..once this is done..i can probly..distrrribute it
00:00:40 <max22> 2 reduce the build time..
00:00:54 <dons> ok. you can use the -M option to ghc then.
00:01:10 <dons> that creates a Makefile stub with the dependency graph layed out
00:01:13 <dons> start there.
00:01:26 <dons> and come back once you've got the graph of a test program generated.
00:01:49 <dons> you'll need the ghc src, and the ghc users manual.
00:01:58 <max22> ok..
00:02:14 <max22> ya i hav the stuff..
00:02:25 <max22> hey dons is it possible 2 contact u thru mail??
00:02:36 <max22> u seem 2 b really helpful
00:02:39 <dons> if you're going to attempt this, try asking on glasgow-haskell-users@ first.
00:02:42 <max22> :)
00:02:50 <max22> ya..well i did ask simon marlow
00:03:33 * earthy looks at max22 and wonders why he's not speaking english
00:03:59 <glguy> earthy: English?
00:04:18 <glguy> ;)
00:04:38 * earthy does not necessarily capitalize everything correctly, true. :)
00:04:43 <glguy> @max22
00:04:44 <lambdabot> Unknown command, try @list
00:04:46 <glguy> weird
00:05:37 <max22> hey..guys ..wat exactly dya mean by dat?
00:05:53 <glguy> 02:02 (*) max22 [n=root@203.197.150.189]
00:06:09 <dons> yeah, i wonder.
00:06:24 <glguy> it's the whole package
00:07:51 <max22> wats happenin?
00:08:07 <dons> max22, ssssh! come back with code, or stay quite please.
00:09:12 <max22> ok ok..
00:09:27 <earthy> max22: you could also run ghc -M to make a makefile-fragment that contains the dependencies between your modules
00:09:53 <bos> whew.
00:10:10 <dons> i initially thought it was gschuett/gavino
00:10:14 <dons> though the script was a bit different
00:10:44 <dons> the other possibility is its a (very) newbie who wants to do the distghc project for summer of code ..
00:10:53 <earthy> dons: you *don* know about ghc -M, right? :)
00:10:58 <earthy> (- n)
00:11:02 <dons> hey, i suggested it above
00:11:15 <dons> "18:58  dons> ok. you can use the -M option to ghc then." :-)
00:11:20 <earthy> ah, it must've gotten lost in all the max22 sputtering. :)
00:15:11 --- mode: ChanServ set +b *!*=root@*
00:15:32 --- mode: ChanServ set +o glguy
00:15:42 --- mode: glguy set -b *!*=root@*
00:15:45 --- mode: glguy set -o glguy
00:16:00 <dons> heh. ok.
00:16:16 <Cale> uh, why?
00:16:23 <glguy> All of the entries in chanserv's autorem list without the *= in the server_name field are invalid
00:16:29 <glguy> and just taking up space , i think
00:16:31 <dons> glguy: before you do that, let me just check the logs for how often this happens
00:16:46 <dons> much better to find prededent/data to justify that kind of action
00:17:01 <yozora> anyone here comfortable with category theory?
00:17:16 <dons> sorear logs in as root.
00:17:23 <yozora> just want to confirm my understanding of the co-exponent in lambda calc
00:17:30 <dons> as does chessguy
00:17:48 <glguy> sorear is faking it though
00:17:51 <dons> Cale: 06.10.16:00:05:01 --- mode: Cale set +b %*!*=root@*
00:18:07 <dons> there's only been 3 people this year log in as root, sorear, max22 and GeoBesh
00:18:34 <dons> i think it is rare enough that we don't need to block it, glguy
00:18:44 <glguy> I just thought of it as a public service
00:18:46 <malcolm_> dons: I see that happy and alex have joined the nobench suite.  I wonder if we need a flag in the results to indicate non-H'98 programs, so they shouldn't necessarily be expected to compile anywhere other than ghc.
00:19:05 <dons> malcolm_: yeah. that's a good idea. though happy is supposed to be h98 (sez Simon ;)
00:19:13 <dons> but we can indeed do that.
00:19:35 <dons> just add a H98=True to the core tests
00:19:39 <dons> how'd that be?
00:19:50 <dons> or NotH98=True ;)
00:20:28 <malcolm_> happy used to have a h'98 mode, but the version in nobench uses Control.Monad.ST
00:20:57 <dons> ah, it generates h98 src, but itself isn't using h98 libs
00:21:05 <dons> which is a problem in general.
00:21:20 <dons> so how about we split it into true h98, and everything else
00:21:24 <dons> including hier lib imports..
00:21:40 <malcolm_> In fact, I'm pretty sure that nhc98 can compile the official distribution of happy - at least it did a couple of years ago
00:21:50 <dons> mm. ok. well maybe i can fix that then
00:22:13 <malcolm_> well, H'98 + blessed addenda perhaps, so permit FFI and hierarchical libs
00:22:36 <dons> so bytesting?
00:22:38 <earthy> man, do we need haskell'. ;)
00:22:47 <dons> but not ST, or mtl stuff
00:22:52 * malcolm_ will check whether it is still the case that nhc98 can build the official happy
00:23:08 <malcolm_> yup
00:23:12 <dons> i think a rule saying: h98 + hier libs + ffi (and libs that use those)
00:23:14 <dons> seems good
00:26:55 <JohnMeacham> fgrin is now as fast as grin on many benchmarks. soon it will be time to switch over for good.
00:27:06 <dons> malcolm_: i added a nice feature to the web interface now. you can click on an error to see the log
00:27:09 <dons> JohnMeacham: great!
00:27:10 <earthy> interestingly hirearchical libs is not mentined as an extension in Language.Haskell.Extensions in Cabal 1.1.6.1...
00:27:13 <glguy> hmm, looks like the stock market took a record hit today
00:27:19 <earthy> the FFI is though.
00:27:20 <glguy> good thing I don't have any stock
00:27:42 <dons> earthy: i think it just assumes everything supports hier libs .. (not true for hbc, i think)
00:27:51 * earthy nods
00:28:00 <earthy> obviously, cabal doesn't work without
00:28:07 <malcolm_> dons: hey, cool feature.  I like being able to see the error log
00:28:12 * earthy notes he has to fix up the Dazzle cabal file ;)
00:28:25 <dons> yeah, makes it ridiculously easier to work out why things failed , malcolm_ :)
00:29:01 <dons> malcolm_: when is -package base needed for nhc?
00:29:08 <dons> when using hier libs?
00:29:13 <malcolm_> yup
00:29:20 <dons> ah! now it is clear.
00:29:55 <boegel> dons: are you aware @vixen is broken?
00:30:11 <malcolm_> actually, there is a bit of a snafu in the nhc98 driver script - it always has the -package base interface available, but you have to ask for -package base explicitly if it links against any of it.
00:30:13 <dons> boegel: yes.
00:31:05 <JohnMeacham> then it is separate compilation time.
00:31:17 <malcolm_> really -package base should either be automatic for both compiling and linking, or manual for both, but not this irritating half-of-one, half-of-t-other
00:31:49 <JohnMeacham> well. I need to write some segmented file stuff for lazy bytestrings... so I can just load the bits of the ho I want. right now it is taking a signifigant part of the build time just to load in the ho files.
00:31:59 <dons> mm.
00:32:08 <boegel> dons: and are you (or anyone else) planning to fix it? or is it intentional?
00:32:15 <JohnMeacham> then it is perhaps separate compilation time. though.. I am not sure how to actually do it.
00:32:19 <dons> boegel: it'll get fixed if someone fixes it :)
00:32:27 * dufflebunk snickers at the mention of loading hos
00:32:27 <boegel> dons: oh ok
00:32:29 <dons> (you have to convert the regex file from the old format to the new format)
00:32:34 <dons> boegel: its about 5 mins work
00:32:36 <JohnMeacham> the best idea i have so far is to open the same file multiple times for reading to get various bytestrings out at different locations.
00:32:54 <boegel> dons: I wish I had 5 mins (or the knowledge) ;-)
00:33:08 <JohnMeacham> glguy: too bad I trade stocks for a living.
00:33:30 <glguy> everyone knows it's going to go back up... it always does
00:33:45 <glguy> seems like now would be the time to buy at clearance prices
00:33:45 <dons> malcolm_: so i'm getting a weird error msg:
00:33:48 <dons> malcolm_:
00:33:49 <dons> nhc98   -package base   -c  -o perfectsquares.o perfectsquares.hs
00:33:49 <dons> nhc98comp: infoDepend InfoUsed 60 [(Type class,Control.Arrow.ArrowZero,"evitacilppA.lortnoC"
00:33:53 <dons> hmm!?
00:34:11 <malcolm_> dons: ooh, I don't see that on my machine
00:34:17 <JohnMeacham> glguy: actually it is not that bad. the clients pay to reduce risk, so when the market goes down, we tend to make the most money as our clients don't lose money like everyone else does.
00:34:31 <dons> this is on the amd64
00:34:32 <malcolm_> why is it using Control.Arrow.* at all?
00:34:45 <dons> i've no idea
00:34:48 <dons> let me check the x86
00:36:07 <dcoutts> liyang, ping
00:36:28 <dons> malcolm_: same error on x86
00:36:31 <dons> bizarre
00:36:34 <JohnMeacham> I noticed somethnig very strange today. I have a function that is basically static void foo(int *x,int y) { *x = y} - it was not being inlined. inlining it on amd64 made no difference at all, inlining it with the P4 doubled performance. I am not sure what to make of that, are call's free on amd64? I can't believe that... very strange.
00:37:23 <malcolm_> dons: will investigate on an x86 box here
00:48:02 <glguy> can one regex every have an input dependent number of match groups?
00:48:26 <glguy> > matchRegex (mkRegex "(test)") "test"
00:48:28 <lambdabot>   Not in scope: `mkRegex'
00:48:32 <glguy> > matchRegex (makeRegex "(test)") "test"
00:48:33 <lambdabot>   Not in scope: `makeRegex'
00:52:50 <malcolm_> dons: yes, I can reproduce the "infoDepend" error on an x86 box, but not on my laptop (which admittedly has a slightly older version of nhc98 installed)
00:55:14 <dons> ah ok. that's today's nhc from darcs
00:55:19 <dons> wasn't there 3 or 4 patches back
00:55:41 <dons> i like the backwards Control.Applicative, that's eat
00:55:45 <dons> 'neat'
00:57:21 <quicksilver> JohnMeacham: pipelining might make a call appear free, if no stack frame was needed and the jmp was local
00:57:40 <quicksilver> JohnMeacham: I'm not a microcode expert but I believe pretty clever tricks happen
00:57:53 <bos> whoa! i fixed a laziness bug, and my brains didn't leak all over the floor!
00:58:22 <quicksilver> my boss fixed a laziness bug! He fired me.
00:59:26 <dons> bos, cool
00:59:34 <JohnMeacham> quicksilver: yeah. as far as I can tell the athlon 64 is pretty robust when it comes to optimizer flags, but the various pentiums can vary widly.
01:00:04 <bos> i'm layering socket multiplexing on top of my existing typed network channels.
01:01:15 * boegel has noticed various people seem to do performance analysis on different machines these days
01:01:19 <bos> my two stacked layers of unsafeInterleaveIO weren't playing nice, but now they have kissed and made up.
01:01:39 <boegel> I've seen this passing by on the Haskell mailinglist, but also GCC is doing regression tests on a huge number of machines...
01:01:45 <boegel> and then there's me off course ;-)
01:01:47 <quicksilver> JohnMeacham: the AMD has a *lot* of registers, so it's easier for the compiler to find spare registers to use for function parameters, which makes cheap function calls easier
01:02:35 <dons> boegel: oh, url?
01:02:42 <boegel> dons: on what?
01:02:45 <boegel> dons: my work?
01:02:49 <dons> gcc regressions
01:02:55 <boegel> dons: it doesn't involve Haskell though
01:03:19 <JohnMeacham> quicksilver: but it seems to be true even when compiling with -m32
01:03:50 <boegel> dons: oh, well, I'm subscribed to the mailinglist, and they are having issues regarding the upcoming gcc-4.2 (due to some bug fix which resulted in a 5% regression for the SPEC benchmarks)
01:04:01 <boegel> dons: lemme see if I can find the thread for you
01:05:39 <malcolm_> dons: funny how ghc gets about 3x slower on spectral/atom on x86_64 than x86
01:06:27 <boegel> dons: http://gcc.gnu.org/ml/gcc/2007-02/msg00587.html , http://gcc.gnu.org/ml/gcc/2007-02/msg00547.html, http://gcc.gnu.org/ml/gcc/2007-02/msg00390.html, http://gcc.gnu.org/ml/gcc/2007-02/msg00427.html (the last one is the discussion on whether or not to release gcc 4.2 with the perf. regression or not)
01:06:29 <lambdabot> Title: Serge Belyshev - spec2k comparison of gcc 4.1 and 4.2 on AMD K8
01:06:44 <boegel> dons: that's a lot of reading material btw ;-)
01:07:14 <bos> i should benchmark our compiler at work against gcc for -fvia-c
01:09:09 <dons> malcolm_: yeah, untouched on x86. a bit odd.
01:09:21 <dons> i was going to investigate that some more before filing a report though
01:18:16 <dons> JohnMeacham: who do I speak to about this ;)   --> 2.3g 8352 R  100 14.7  10:46.19 jhc
01:19:16 <gaal> hi, the binary snapshots at http://www.haskell.org/ghc/dist/current/dist/ are broken again
01:19:18 <lambdabot> Title: Index of /ghc/dist/current/dist
01:19:24 <gaal> who do I speak about this ;)
01:19:42 <gaal> specifically the latest i386 bz2 loos truncated
01:19:52 <gaal> *looks
01:19:55 <malcolm_> gaal: try asking on #ghc
01:20:03 <gaal> thanks
01:21:45 <JohnMeacham> dons: hrm.. you might be better off compiling to 'ho' files with -c, then restarting to do the final build.
01:27:12 <dons> oh, good idea
01:27:28 <dons> gaal: the one fomr 0224 is good
01:28:33 <gaal> dons: thanks, trying that
01:28:43 <dcoutts> dons, how do I find out if some package in in OpenBSD's ports collection?
01:30:10 <dcoutts> dons, do you know if gtk2hs-0.9.10 was ever in OpenBSD ports?
01:30:18 * dcoutts is writing release notes
01:30:33 <dons> nope, hasn't been in ports
01:32:19 <dcoutts> dons, ok ta
01:32:30 <dcoutts> dons, any idea how I poke them to add it ?
01:32:48 <dcoutts> does it have much other Haskell stuff?
01:33:30 <dons> hmm. they don't have an active haskell maintainer atm
01:33:39 <dcoutts> ok, I'll leave it for the mo
01:33:42 <dons> and the only way to get something in is to port it yourself :)
01:33:42 <dcoutts> ta
01:33:46 <dcoutts> heh
01:34:01 <dons> yeah, i think the 5 of us who use openbsd can be expected to use cabal
01:34:04 <dons> or make
01:34:12 <gaal> dons: the 0224 doesn't work for me either: tar xjvf dies at libHSX11.a, and bunzip2 fails too.
01:34:36 <gaal> maybe my bzip2 is broken? recent debian unstable
01:35:59 <dcoutts> gaal, more likely it's truncated
01:36:33 <gaal> that's what I thought too...
01:40:50 <siti> dcoutts: I have done a little bit of work updating the cairo bindings, one question should I expose a patternFinish function (similar to surfaceFinish), this could be need to make sure the reference gets cleaned up promptly if using: http://www.cairographics.org/manual/cairo-cairo-t.html#cairo-pop-group
01:40:53 <lambdabot> Title: cairo_t, http://tinyurl.com/2hasuh
01:41:24 <dcoutts> siti, we try to make that kind of thing automatic, eg see the various withFoo functions
01:41:32 <siti> ok
01:41:42 <siti> most people will use: cairo_pop_group_to_source
01:42:11 <siti> but it might be needed in some cases to use patternDestroy
01:42:14 <siti> I mean finish
01:42:39 <siti> personally I don't think it should be exposed, but I am just wondering your opinion
01:43:11 <siti> also gtk2hs has some annoying build problems, first it can't be built with -j2 or more
01:43:27 <siti> and also if I change files it does not build what changed
01:43:30 <siti> any ideas
01:45:55 <dcoutts> siti, right -j2 does not work, if you change deps you may need to rm */*.deps
01:46:05 <siti> ok
01:46:37 <dcoutts> other than that it should built *at least* what changed :-)
01:47:04 <siti> ok
01:47:14 <Syzygy-> Hmmm... Do we even have contravariant functors in Haskell? Is it possible?
01:47:42 <siti> with my small and horrible experiences with automake
01:48:04 <siti> I found a fix for the -j problem
01:48:09 <siti> I will try and look it up
01:48:11 <dcoutts> siti, yes it's fairly horrible, we'll move to cabal eventually.
01:48:17 <siti> ok
01:48:31 <dcoutts> siti, I think the -j thing is just terminally broken. I've no hope to make that work.
01:48:33 <siti> you made cabal didn't you?
01:48:37 <siti> ok
01:49:06 <dcoutts> siti, I help maintain it, but it needs lots of work to be able to build gtk2hs. And gtk2hs needs lots of work to build with Cabal. :-)
01:49:17 <siti> hehe :)
01:49:34 <siti> yeah gtk2hs is pretty complex
01:49:42 <siti> and cabal is simple in a good way though
01:49:43 <siti> :)
01:49:47 <dcoutts> @arr
01:49:48 <lambdabot> Keelhaul the swabs!
01:53:05 <Syzygy-> 979.15-279.15
01:53:10 <Syzygy-> Ooops, sorry
01:53:29 <quicksilver> Syzygy-: you mean functors in the same sense as the existing 'Functor' class (rather than the ML module class)
01:53:37 <Syzygy-> I think I do, yeah.
01:53:45 <quicksilver> Syzygy-: I can't see any problem with defining them
01:54:12 <quicksilver> class ContraFunctor f where contramap : a -> b -> f b -> f a
01:54:20 <Syzygy-> Do we have any examples of this behaviour though?
01:54:36 <quicksilver> I don't recall having seen one
01:54:38 <Syzygy-> quicksilver: (a -> b) -> f b -> fa, you mean.
01:54:44 <quicksilver> yes :)
01:58:23 <beelsebob> o.O #haskell splode
02:30:48 <xpika> do anyone here have an opinion on nvidia cuda?
02:31:36 <beelsebob> xpika: what sort of opinion are you wanting?
02:32:15 <dcoutts> if it doesn't have open source drivers I'm not interested :-)
02:32:29 <beelsebob> it doesn't
02:32:33 <beelsebob> it has closed linux ones
02:32:46 <dcoutts> bah
02:33:07 <beelsebob> I do have to ask though -- why do you really care if the drivers are open or not?
02:33:23 <beelsebob> ability to self-fix?
02:33:30 <dcoutts> open ones work
02:33:30 <xpika> beelsebob: wheather or not it will take off?
02:33:59 <beelsebob> dcoutts: sure, but often can't contain all the wiz bang features because they expose someone's smelly IP
02:34:06 <dcoutts> open ones work with no fiddling and don't break your box when you upgrade things.
02:34:13 <hpaste>  KingJackaL pasted "FizzBuzz PHP/Ruby" at http://hpaste.org/703
02:34:17 <beelsebob> xpika: it looks like a nice idea, no idea whether that implementation will or not though
02:34:18 <dcoutts> I don't really care, I want it to "Just Work"tm
02:34:29 <beelsebob> dcoutts: http://www.apple.com/
02:34:30 <lambdabot> Title: Apple
02:34:31 <beelsebob> :P
02:35:15 <hpaste>  Growly pasted "FizzBuzz in C++" at http://hpaste.org/704
02:35:18 <dcoutts> hmm, it doesn't run gentoo yet
02:35:42 <dcoutts> well unless you run linux on your apple box but that'd seem to defy the point :-)
02:35:52 <hpaste>  muhahahaha pasted "fuck you fuckers in irc." at http://hpaste.org/705
02:36:14 <dcoutts> hmm, time to ban muhahahaha ?
02:36:33 <dcoutts> oh he's not here
02:36:45 <hpaste>  beelsebob annotated "FizzBuzz PHP/Ruby" with "Haskell damn you" at http://hpaste.org/703#a1
02:36:53 <dcoutts> dons, do we have ip logs of hpaste ?
02:37:02 <xpika> dcoutts: I disagree. i think he should be s-listed.
02:37:10 <beelsebob> dcoutts: my point was that OS X "just works" (tm)
02:37:33 <hpaste>  Growly pasted "FizzBuzz in C++, with apples" at http://hpaste.org/706
02:37:35 <hpaste>  siti pasted "[23:33:40] <siti> muhahahaha pasted "fuck you fuckers in irc." at http://hpaste.org/705 STOP IT!" at http://hpaste.org/707
02:37:49 <siti> yeah another irc channel
02:37:54 <siti> they are being idiots
02:38:07 <siti> I used hpaste, and they thought it was a normal one :S
02:38:10 <dcoutts> beelsebob, and you'll note that the video drivers are bundled and are not separate annoying downloads. Apple customers would not stand for it, why should we?
02:38:16 <xpika> beelsebob: "Just works" sounds so sad. its something a person with erection problems would say
02:38:37 <beelsebob> xpika: I was quoting dcoutts
02:39:15 <xpika> beelsebob: right.
02:39:16 <beelsebob> dcoutts: indeed I do note that - so pettition your repo maintainer to put at least some optional binary "just works" (TM) drivers in there
02:39:36 <dcoutts> beelsebob, but sadly that'd be illegal
02:39:44 <beelsebob> dcoutts: really?
02:40:05 <dcoutts> beelsebob, you can't distribute binary only kernel drivers along with the kernel
02:40:09 <dcoutts> it breaks the GPL
02:40:23 <xpika> hpaste doesnt even have a search facility :(.
02:40:27 <beelsebob> dcoutts: I didn't say with the kernel
02:40:31 <beelsebob> I said in the package repository
02:40:44 <dcoutts> beelsebob, but distros also distribute kernels, nvidia do not
02:41:05 <dcoutts> that's why nvidia can do it and no one else can
02:41:14 <beelsebob> dcoutts: sure they do - but what you're saying is essentially "you can't have a download system that includes both GPL and binary only stuff"
02:41:22 <beelsebob> in which case the whole WWW breaks the GPL
02:41:27 <beelsebob> because it distributes both
02:41:42 <dcoutts> beelsebob, but it's a single organisation distributing both
02:41:47 <dcoutts> and one is a derivative of the other
02:41:54 <dcoutts> it's not mere aggregation
02:41:57 <matthew_-> this is a very very grey area. lkml has often discussed whether binary only modules are "derivatives" of the kernel and thus must be covered by the GPL. it's not a simple case
02:42:01 <beelsebob> the drivers aren't in any way a derivitave of the other
02:42:26 <beelsebob> if they were then userland apps would equally be derivatives of it
02:42:44 <dcoutts> but those have a specific exemption
02:42:49 <dcoutts> what's a linux kernel driver for if you can't use it without a kernel?
02:42:50 <siti> well in nvidia's case they have a binary blob (generic and multi OS), which is opened by the gpled layer
02:43:01 <siti> so how is that a deravative
02:43:17 <matthew_-> you're not saying anything that hasn't been said before. this has been done to death on lkml and other places too.
02:43:23 <beelsebob> indeed
02:43:34 <beelsebob> and the conclusions are mostly "binary modules are just fine"
02:43:43 <matthew_-> not really.
02:43:45 <dcoutts> well the point is that distros don't feel they can distribute them
02:43:51 <matthew_-> indeed.
02:43:52 <dcoutts> not without the danger of being sued
02:43:53 <beelsebob> I mean damn - the spirit of this is to let people do what the hell they want
02:44:00 <beelsebob> if nVidia want closed, then let them get on with it
02:44:07 <dcoutts> beelsebob, that's BSD, not GPL
02:44:11 <matthew_-> beelsebob: that's linus' attitude. it is not the attitude of the gpl
02:44:17 <hpaste>  (anonymous) annotated "fuck you fuckers in irc." with "(no title)" at http://hpaste.org/705#a1
02:44:38 <beelsebob> matthew-_: true that
02:44:43 <xpika> noooo.
02:44:51 <dcoutts> who runs hpaste? can we get iplogs?
02:45:00 --- mode: ChanServ set +o dons
02:45:02 * mux wonders who's the idiot who did that paste
02:45:04 --- kick: hpaste was kicked by dons (dons)
02:45:07 --- mode: ChanServ set -o dons
02:45:09 <matthew_-> the last time this came up in lkml, there was a patch posted that would have prevented *all* binary modules from working. Linus' arguement was that accepting that patch turned the linux kernel into the RIAA
02:45:09 <dons> yeah, we have logs
02:45:13 <dons> just have to ask glguy
02:45:26 <beelsebob> my suggestion then is that you should be pettitioning for a change in the gpl, not for a change in nVidia's terms
02:45:29 <xpika> glguy owns hpaste
02:45:44 <mux> dons: hi! got my last mail?
02:46:00 <dons> hang on. trying to remember my hpaste passwd :)
02:46:05 <dcoutts> dons, perhaps the hpaste thingy ought to require that the nick given as author match a name of someone in #haskell and that the ip addresses should match
02:46:14 <matthew_-> beelsebob: you watched the gplv3 evolve? It's highly unlikely that the changes that are going to be in there are going to push the gpl in the direction you want.
02:46:19 <dons> dcoutts: yeah good idea.
02:46:25 <dcoutts> dons, ie that they have a real presence in #haskell
02:46:33 <beelsebob> matthew-_: I know - which is what's so stupid about it
02:46:47 <dcoutts> dons, though some people have irc masks (like myself I think)
02:46:49 <mux> licences troll in #haskell
02:46:54 <ivanm> dcoutts: what happens if its pasted about someone who doesn't use IRC but wants to paste Haskell code up there for someone to look at?
02:46:54 <beelsebob> the comunity seems to have tottaly forgotten that the idea is to let people do whatever you want
02:46:55 * mux shakes head deceiptively
02:47:10 <beelsebob> not to MAKE people do what you want to enforce them to want
02:47:15 <dcoutts> ivanm, it doesn't get announced that's all, they can still use it
02:47:17 <siti> announce should not be default
02:47:21 <matthew_-> the gpl is not an "anything goes" license and never tried to be. It's a political statement that seeks to protect very specific freedoms. Personally I think it's great, but for my own work, I do tend to use the apacheV2 license more.
02:47:32 <dcoutts> siti, perhaps not
02:47:33 <ivanm> dcoutts: OK
02:48:40 <beelsebob> matthew-_: that's the point though -- the gpl *should* be an anything goes licence - it should essentially be "use it, give credit for it, keep it open" it shouldn't be "anything related in any tiny way to this must be open and you must have the same opinion as us or you can't use our software"
02:49:21 <matthew_-> beelsebob: the lgpl might be closer to what you want then - that's certainly designed to cater more liberally for linking against libraries etc.
02:49:28 <dcoutts> beelsebob, but that license already exists and yet people choose something stronger, you can't tell them they're wrong to want that.
02:49:38 <beelsebob> true
02:49:42 <dcoutts> well you can but it will not change anything :-)
02:49:50 <dons> so who invited the idiots on to hpaste :)
02:49:53 <xpika> i think gpl serves the purpose of its creators
02:49:55 <beelsebob> dcoutts: but you can tell them that it's inconveniant to use that licence
02:50:09 <beelsebob> because it stops you having the freedom to have nice easy binary drivers
02:50:26 <dcoutts> beelsebob, true, but the inconveniences are often seen as illegitimate anyway, eg the nvidia case
02:50:44 <matthew_-> mmm. that combination of "nice easy" and "binary drivers" makes me feel distinctly uneasy.
02:50:45 <siti> dons: I pasted a link to hpaste with some haskell code, then some people in the same channel started abusing it :(
02:50:49 <beelsebob> but it's really not illegitimate -- nVidia gets to make it's own choices
02:51:02 <dcoutts> beelsebob, and I choose to ignore them :-)
02:51:16 <beelsebob> just because they're different choices to the people who licenced the code doesn't mean that it's not a valid choice
02:51:18 <dcoutts> and buy their competitors' hardware
02:51:41 <xpika> i hope it wasnt the c++ chatroom ;o
02:51:44 <beelsebob> dcoutts: which is interesting -- because most linux people I know buy nVidia because ATi's driver support is so abismal
02:51:59 <dons> siti, ah well.
02:52:03 <dcoutts> end users can chose to use the nvidia drivers, the gpl does not prevent uses, however it's (probably) not allowed to distribute the combination
02:52:08 <dons> i forgot the !quiet command.
02:52:11 <siti> I think they have stopped now :p
02:52:13 <siti> ok
02:52:21 <dcoutts> beelsebob, I use either old ATI or new Intel gfx
02:52:30 <dons> siti, what channel?
02:52:31 <matthew_-> beelsebob: if someone came round to your house and entered and then ignored your request to take their shoes off, and generally made an arse of themselves then you'd be annoyed, right? well it's the same with nVidia. If they want to sell their products into the open source community, then they really should play by the established rules.
02:53:03 <siti> it's on a diff server, just a new zealand computer one
02:53:24 <dons> ok
02:53:34 <dons> all good.
02:54:14 <beelsebob> matthew-_: that's a really bad leaky screwdriver -- it's more like you sitting at home making scarves, and giving away the knitting patterns, then banning people selling the scarves along with wellies for which you can't get the designs because you think that all clothing should be able to be made by everyone
02:55:00 <beelsebob> jumping up and down on it with muddy footprints would be equivalent to taking the source, buggering about with it, making it crap and then passing it off as your own
02:55:27 <matthew_-> beelsebob: yep, analogies suck. When people start making analogies with cars, you know you're in trouble. ;-) But I think the product they're making must depend on the scarf in some way - scarf broaches or something rather than wellies.
02:55:43 <dcoutts> beelsebob, but it's not even as if we want nvidia's secret IP in their drivers, we don't need nvidia to take on patent liability on our behalf, we just need them to tell us how to program the hardware we buy from them.
02:55:46 <JaffaCake> dons: oops, I forgot that Happy used the ST monad
02:55:59 <beelsebob> true, that makes sense -- but still - why should you not sell the broaches with the scarve?
02:56:21 <matthew_-> cos of the license agreement on the distribution of the scarf nitting patterns?
02:56:24 <beelsebob> it is very similar to hardware manufacturers (*cough* sony *cough*) who try to dictate what you can or can't do with your hardware
02:56:33 <matthew_-> sheesh, this is geting complex!
02:57:23 <beelsebob> dcoutts: but that's the point - nVidia don't have to tell you anything about it, sure, I'd agree that you should be able to work it out and write your own drivers, but they have no responsibility to tell you how to do it
02:57:41 <beelsebob> that would be like expecting the broach maker to tell you how to do your own jewel setting
02:57:47 <dcoutts> beelsebob, when I buy anything else it comes with some documentation
02:57:47 <beelsebob> if you can figure it out, go for it
02:57:49 <beelsebob> if you can't
02:57:51 <beelsebob> then don't
02:57:51 <matthew_-> dcoutts: from what I hear, most graphics hardware is the flakiest, most tempremental and disgusting creation imaginable. That's why nVidia and ATi employ more software engineers than hardware engineers, to try and wallpaper over the cracks. We'd probably feel ill if we ever got the documentation about how to program the damn things.
02:58:10 <beelsebob> dcoutts: sure, it comes with documentation, as much documentation as the manufacturer chose to give you
02:58:13 <dcoutts> beelsebob, it's not about getting a blueprint of the device, I just need to know how to use the device
02:58:23 <beelsebob> the broach for example might come with instructions on how to pin it on
02:58:29 <beelsebob> but not how to modify it
02:58:37 <dcoutts> I need enough to use it for its intended purpose, not too much to ask I think
02:58:56 <dcoutts> I don't need to modify the device, I need to use it
02:59:22 <beelsebob> well, it's intended purpose according to nVidia is to do some graphics rendering on your computer, specifically "if your computer runs Windows, MacOS or Linux"
02:59:29 <beelsebob> and they provide everything necessary to do that
02:59:45 <beelsebob> their stated purpose does not include "allowing people to tinker with it"
02:59:55 <beelsebob> sure it would be nice if it did, but it doesn't
02:59:56 <dcoutts> except that they do not, eg I've got non-x86 hardware
03:00:15 <beelsebob> right, so their purpose does not include running it on non-x86 systems
03:00:21 <beelsebob> sorry, you bought the wrong card
03:00:25 <malcolm_> once I've bought it, it's my hardware, why shouldn't I tinker with it?
03:00:27 <matthew_-> dcoutts: err, so have I, and my nvidia card works fine.
03:00:28 <beelsebob> and they shot themselves in the foot selling to you
03:00:38 <dcoutts> so that's why I don't buy it
03:00:45 <beelsebob> malcolm_: you're free to tinker, just don't expect them to help you
03:01:19 <Adamant> Trade Secrets are lame
03:01:21 <matthew_-> the real issue is that there are enough people out there who just don't care about these issues to keep nVidia and the status-quo happy for a long long time.
03:01:32 <Adamant> patent it or open it.
03:01:53 <beelsebob> matthew-_: exactly -- I really don't care at all - I have a Mac, it has a graphics card in it, I don't care who made it, because it does the job I require it to
03:02:05 <beelsebob> if you have other requirements you may care
03:02:27 <beelsebob> but there are not many people with the requirement of "must be able to tinker with it"
03:02:37 <beelsebob> and thus not many products that meet those requirements
03:02:50 <matthew_-> a condemnation of the spirit of the human race if ever I heard one! ;-)
03:03:11 <dcoutts> almost all hardware makers tell people how to use their stuff, it's just ati and nvidia that are the exceptions
03:03:18 <Adamant> open hardware will be getting a lot more popular when people can't get their porn torrents thanks to DRM.
03:03:22 <kolmodin> dcoutts: the drivers are part of what you buy, and perhaps parts of that is patented too. you don't just buy the card, you buy everything
03:03:25 <dcoutts> it's not that much to ask, it's not tinkering, it's just wanting to use it
03:03:40 <beelsebob> dcoutts: they do tell you how to use their stuff -- you plug it into an x86 board, you install an OS, you install their supplied driver
03:03:42 <beelsebob> done
03:03:44 <robreim> Why is there no getLine for lazy bytestrings?
03:04:04 <beelsebob> you can't complain if the how to use it is different from your requriments
03:04:17 <swiert> does ghc have polymorphic kinds hidden in some flag I don't know about?
03:04:17 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
03:04:41 * beelsebob goes to teach
03:04:53 * mux got fed up with nvidia when they incorporated some of his fixes into their latest driver for FreeBSD without a thank you, and broke his old GPU at the same time
03:05:46 <kolmodin> dcoutts: but yes, not saying how it works restricts its use
03:12:38 <kolmodin> http://www.kde-look.org/CONTENT/content-files/53129-Windows_Vista_Aero_WOW.jpg
03:12:41 <lambdabot> http://tinyurl.com/yq7kvj
03:13:19 <kolmodin> ^^ quite funny
03:15:45 <dons> JaffaCake: all good. we'll just tag non h98 stuff. i think its still very useful to have these other program in the suite
03:16:19 <JaffaCake> ok, thanks
03:16:37 <dons> JaffaCake: interesting slowdown in 'perfectsquares' only on amd64, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
03:16:37 <lambdabot> Title: nobench: Haskell implementation shootout
03:16:39 <JaffaCake> at one stage there was an H98 version of that bit of code, but it seems to be gone now
03:16:50 <dons> the head is slower than stable, but on x86 they're the same
03:17:02 <dons> i added alex to the suite today too
03:17:09 <Igloo> Is this about happy using ST? If so, can't you make a poor-man's ST that just aliases everything to IO equivalents?
03:17:21 <JaffaCake> Igloo: yeah, that would work
03:17:41 <dons> yeah that's an interesting idea. might solve a few other compilation issues on nhc and yhc
03:17:48 <dons> even to FFI things
03:17:48 <JaffaCake> except it uses STArrays, so you'd still need IOArrays (which hbc doesn't have, I bet)
03:18:29 <JaffaCake> dons: hmm, that *is* interesting
03:18:59 <dons> that's an Int64 benchmark, mostly.
03:19:28 <JaffaCake> I'll look into it sometime
03:19:46 <JaffaCake> we'll do a performance sweep before the 6.8 release anyhow
03:20:21 <dons> yeah, my goal is to try to identify these now, so they don't slip through later
03:21:09 <gaal> :pl fix (\f -> 1 : 1 : [ x+y | (x, y) <- zip f $ tail f ])
03:21:14 <gaal> @pl fix (\f -> 1 : 1 : [ x+y | (x, y) <- zip f $ tail f ])
03:21:15 <lambdabot> fix ((1 :) . (1 :) . return . ap ((x +) . ((y | (x, y)) <-) . zip) tail)
03:21:39 <gaal> that broken-down list comprehension doesn't really work, does it?
03:21:47 <gaal> (sorry if this is a faq...)
03:22:28 <kolmodin> gaal: @pl doesn't play well with list comprehensions
03:23:12 <wolverian> works here
03:23:27 <wolverian> er... I pasted the list comprehension into ghci
03:23:39 * wolverian smacks forehead, etc
03:31:44 <dcoutts> kolmodin, heh, that's nice :-)
03:32:47 <kolmodin> :)
03:32:51 * kolmodin goes on lunch
03:36:21 <apfelmus> @seen jbone_
03:36:21 <lambdabot> I saw jbone_ leaving #haskell 11h 29m 48s ago, and .
03:40:08 <dons> ?users
03:40:09 <lambdabot> Maximum users seen in #haskell: 332, currently: 298 (89.8%), active: 30 (10.1%)
03:40:29 <apfelmus> does anybody know of the whereabouts of jbone_?
03:41:15 <apfelmus> he proposed a nice programming problem http://www2.rgmadvisors.com/public/problems/orderbook/
03:41:16 <lambdabot> Title: Order Book Programming Problem
03:56:03 <araujo> hello
03:56:32 <apfelmus> > reverse "hello"
03:56:34 <lambdabot>  "olleh"
03:56:59 <kaol> > cycle "hello"
03:57:01 <lambdabot>  "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohello...
04:02:25 <apfelmus> concatMap (\n-> mapM (replicate n) "hello") [1..]
04:02:30 <apfelmus> > concatMap (\n-> mapM (replicate n) "hello") [1..]
04:02:52 <apfelmus> > mapM (replicate 4) "hello"
04:02:59 <quicksilver> mapM is broken
04:03:16 <quicksilver> > concatMap (\n-> Control.Monad.mapM (replicate n) "hello") [1..]
04:03:16 <apfelmus> ah.
04:03:17 <lambdabot>  ["hello","hello","hello","hello","hello","hello","hello","hello","hello","he...
04:03:34 <apfelmus> > Control.Monad.mapM (replicate 4) "hello"
04:03:35 <lambdabot>  ["hello","hello","hello","hello","hello","hello","hello","hello","hello","he...
04:05:24 <apfelmus> > concatMap (\n -> concatMap (replicate n) "hello") [1..]
04:05:26 <lambdabot>  "hellohheelllloohhheeellllllooohhhheeeelllllllloooohhhhheeeeellllllllllooooo...
04:05:44 <apfelmus> ?pl concatMap (\n -> concatMap (replicate n) "hello") [1..]
04:05:45 <lambdabot> ("hello" >>=) . replicate =<< [1..]
04:22:31 <mb2> > last [1..
04:22:32 <lambdabot>  Parse error
04:22:40 <mb2> > last [1..]
04:22:44 <lambdabot> Terminated
04:23:56 <ivanm> lol
04:24:27 <rag3> mb2: you can't blame lambdabot for this one. can you? :-)
04:24:31 <Lemmih> {-# RULES "last/inf" forall x. last [x..] = (1/0) #-}
04:34:47 <dcoutts_> Lemmih, surely you just mean error nontermination !
04:44:57 <apfelmus> int-e: hi
05:10:28 <beelsebob> > reverse $ cycle "hello"
05:10:32 <beelsebob> caboom
05:10:32 <lambdabot> Terminated
05:12:29 <ivanm> stop trying to kill lambdabot!
05:13:01 <beelsebob> :P
05:13:13 <opqdonut> ?die
05:13:13 <lambdabot> unexpected end of input: expecting number
05:13:18 <opqdonut> ?die 6
05:13:18 <lambdabot> 6 => 6
05:13:23 <opqdonut> ?die 5
05:13:23 <lambdabot> 5 => 5
05:13:28 <opqdonut> wtf? :D
05:13:39 <opqdonut> ?help die
05:13:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:13:47 <opqdonut> ?list
05:13:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:13:50 <allbery_b> @help dice
05:13:51 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
05:14:14 <opqdonut> ahh
05:14:23 <opqdonut> and die is an alias for dice, np
05:14:35 <kolmodin> ?die motherf****r, die!
05:14:35 <lambdabot> unexpected "m": expecting number
05:14:43 <opqdonut> ?dice 200d2-100
05:14:43 <lambdabot> unexpected "-": expecting digit, "+" or end
05:14:46 <kolmodin> hmm
05:14:49 <opqdonut> ?dice 200d2
05:14:49 <lambdabot> 200d2 => 297
05:14:50 <opqdonut> bah
05:14:51 <opqdonut> ?dice 200d2
05:14:51 <lambdabot> 200d2 => 292
05:16:22 <araujo> dons, there?
05:25:15 <SamB> hmm...
05:25:25 <SamB> I think HaskellWiki should use google for searches...
05:30:07 <araujo> SamB, you have access to lambdabot ?
05:30:45 <dcoutts_> SamB, yeah, it should.
05:33:17 <beelsebob_> damn it -- what's the LaTeX environment that acts like verbatim in that it keeps leading spaces, but doesn't in that it allows you to apply styles like bold/italic
05:33:41 <Igloo> alltt
05:35:00 <beelsebob_> ah, cheers
05:51:50 * alaiyeshi slaps alaiyeshi around a bit with a large trout
05:55:45 <pejo> Hennessy's book on Pi calculus seems very good from a quick glance, if anyone is into that kind of stuff.
06:00:23 <pitecus> Is it possible to use Parsec with bytestrings?
06:00:57 <chessguy> g'mornin' haskellers
06:01:49 <chessguy> @quote morning
06:01:50 <lambdabot> therp says: good morning. I think I have been dreaming of shift/reset continuations...
06:01:57 * beelsebob_ pokes chessguy in the spleen
06:01:58 <quicksilver> pitecus: parsec makes no assumption about the input stream at all, I think
06:02:15 <quicksilver> pitecus: you should be able to use it with lists of anything
06:02:27 <chessguy> ugh. i hate winblows
06:02:28 <pitecus> ya but bytestrings arent lists...
06:02:42 <quicksilver> yes, you'd have to conver them to lists
06:02:48 <quicksilver> but that can be done lazily
06:02:50 <dcoutts_> unpack
06:02:51 <quicksilver> and hence efficiently
06:03:08 <pitecus> doesnt that defeat the point of bytestring tho?
06:03:13 <quicksilver> constant-space unpacking even on arbitrarily length bytestrings
06:03:23 <dcoutts_> pitecus, only partially
06:03:27 <quicksilver> not really, no
06:03:36 <quicksilver> you're just using unpack as a way to get an element of the front
06:03:38 <dcoutts_> pitecus, a 'native' parsec could be made a tad faster, yes.
06:03:46 <quicksilver> you're not actually *converting* to a list, wholesale
06:03:55 <quicksilver> just sticking a : constructor between the first elt and the rest
06:04:04 <pitecus> aha
06:05:14 <chessguy> sigh
06:05:28 <chessguy> that's the second time in two days i've had to hard-reboot this machine
06:05:39 <beelsebob_> winblows suck
06:05:50 <beelsebob_> as apparently does my typing
06:08:28 <Jaak> @type let s = ap; k = const; i = id in s i i (s i i)
06:08:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
06:08:31 <lambdabot>     Probable cause: `i' is applied to too few arguments
06:09:12 <ddarius> And thus Jaak discovers why type systems were originally invented.
06:09:49 <ddarius> dcoutts_: Yay! Another Haskell-Cafe question best answered by a reference to a research paper.
06:10:02 <dcoutts_> ddarius, hmm?
06:11:39 <dcoutts_> ddarius, heh, oh I see
06:12:07 <dcoutts_> "Bulat, you know I'm very glad you asked that because ..."
06:13:58 <chessguy> i thought most haskell questions were best answered by research papers
06:15:43 <ddarius> chessguy: Indeed.  Even newbie questions are.  Fairly unusual.
06:15:59 <chessguy> i would point to:
06:16:01 <chessguy> ?where stats
06:16:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
06:16:18 <chessguy> the "most commonly used words" list is telling
06:16:42 <arcatan> haskell weekly news isn't very weekly
06:16:57 <beelsebob_> wow, 14th largest channel
06:17:07 <beelsebob_> does that imply we're nearing chucking people into #overflow?
06:17:15 <chessguy> arcatan, dons has a lot on his plate. i'm sure a volunteer would be welcome
06:17:50 <arcatan> oh, dons writes the weekly news? he does, like, everything
06:17:59 <chessguy> arcatan, exactly
06:21:08 <Jaak> ddarius: i don't quite understand what you mean
06:21:42 <kombinator> dcoutts_: hello
06:21:49 <dcoutts_> hia kombinator
06:21:54 <ddarius> Jaak: Type systems were originally introduced precisely to disallow code such as the code you tried to write.
06:21:58 <kombinator> dcoutts_: what could this mean: "demo0: gtk2hs_closure_marshal: interrupted" ?
06:22:24 <dcoutts_> kombinator, it means that a signal handler caught an unhandled exception I think
06:22:27 <ddarius> Back at the beginning of the 20th century.
06:22:40 <dcoutts_> kombinator, eg you ^C'ed the prog?
06:22:59 <earthy> arcatan: dons has been busy
06:23:00 <kombinator> dcoutts_: this is possible, but I cannot reproduce it...
06:23:00 <beelsebob_> Jaak: what code were you trying to write?
06:23:09 <earthy> plus, it's been a bit slow
06:23:22 <earthy> however, the CfP for the ICFP could be mentioned
06:23:31 <Jaak> it should be (\x.x x) (\x.x x) in s k i
06:23:34 <earthy> especially the call for experience reports
06:23:35 <kombinator> dcoutts_: ok, now I know how to trigger it
06:24:17 <dcoutts_> kombinator, if you want to really see what's going on, see glib/System/Glib/hsgclosure.c:118
06:24:20 <chessguy> ddarius, type systems have existed that long?
06:24:30 <kombinator> dcoutts_: i hit '^C' in the terminal and nothing happens, but if I try to enter something to my application then it dies
06:24:57 <dcoutts_> kombinator, aye, I guess that's because the app was stuck in 'C' land
06:25:20 <ddarius> chessguy: The earliest manifestation was the system used to disallow Russel's Paradox in Set Theory.
06:25:25 <dcoutts_> kombinator, and so the exception didn't actually occur until you pressed a key which caused the Haskell threads to start running again.
06:25:48 <dcoutts_> kombinator, this would be better if we were using the threaded rts, but that brings it's own set of problems.
06:26:05 <ddarius> Then of course Church at the very least in the 20s(?)/30s.
06:26:07 <earthy> duncan, do you have any experience with the FFI introducing slowness in code?
06:26:10 <Orphi> hello Haskell
06:26:21 <int-e> kombinator: pressing ^C twice seems to work for me.
06:26:24 <dcoutts_> earthy, what kind of code?
06:26:36 <chessguy> wow.
06:26:46 * chessguy resolves again to get a copy of Pierce
06:26:56 <earthy> dcoutts: I have an iterator in C-land that I need to copy the entire contents of to haskell land
06:26:58 <kombinator> int-e: so it does for me
06:27:02 * ddarius wonders why his watch says 12:44 am.
06:27:26 <Orphi> anybody know why HGL works in Hugs, but not in GHC?
06:27:33 <dcoutts_> int-e, I expect that's because the first time the rts takes the ^C signal and tries to deliver it but fails since we're stuck in C land and then the second signal gets caught by readline/glibc or whatever
06:27:35 <earthy> walking the iterator is easy but seems almost prohibitively expensive.
06:27:39 <beelsebob_> kombinator: I've had that problem too
06:27:49 <dcoutts_> Orphi, because HGL makes unreasonable assumptions about threading
06:27:52 <beelsebob_> you happen to be compiling with ghc on Mac?
06:27:57 <Orphi> oh dear.
06:28:00 * earthy doesn't know if that's due to the FFI overhead or due to the lib being slow
06:28:04 <earthy> that's why I ask
06:28:19 <dcoutts_> earthy, ok, so you can't just memcpy ?
06:28:37 <Orphi> so... what would be the best thing to use for drawing lots of lines?
06:29:51 <earthy> nope, I'm bound to an iterator object
06:30:14 <earthy> and I want to get a list of Double out of it
06:30:29 <dcoutts_> earthy, so you have to call this iterator repeatedly to get the values
06:30:31 <earthy> currently, that's 2 FFI calls per Double
06:30:48 * earthy nods
06:30:51 <earthy> afaict at least
06:31:01 <chessguy> ?where Pierce
06:31:01 <lambdabot> I know nothing about pierce.
06:31:01 <dcoutts_> earthy, so have you marked the iter_next function as 'unsafe'?
06:31:13 <earthy> nope
06:31:17 <earthy> should I?
06:31:22 <dcoutts_> earthy, if it's 'safe' then it's more expensive. Are you using the threaded rts?
06:31:30 <earthy> nope.
06:31:43 <dcoutts_> earthy, can this iter_next function ever possibly call back into your app?
06:31:52 <chessguy> http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091/ref=pd_sim_b_4/104-0009163-6568732
06:31:55 <lambdabot> http://tinyurl.com/282m6x
06:31:56 <pierre1> ?where gtk2hs
06:31:57 <lambdabot> http://haskell.org/gtk2hs/
06:31:59 <earthy> this is Dazzle. wxHaskell and threaded rts do not play well together
06:32:01 <dcoutts_> earthy, if it can't then you can mark it 'unsafe'
06:32:03 <earthy> dcoutts: no, it can't
06:32:06 <chessguy> ?where+ Pierce http://tinyurl.com/282m6x
06:32:07 <lambdabot> Done.
06:32:21 <earthy> and marking it unsafe does what? remove some of the overhead?
06:32:27 <dcoutts_> earthy, right.
06:32:50 <dcoutts_> earthy, it's then just a C call rather than saving thread/scheduler state
06:33:09 <earthy> hm. so I'd add a foreign import unsafe ccall "DSL_sysCoordinates_Next" unsafeSysCoordinatesNext :: SysCoordinatesObject a -> IO Int
06:33:27 <dcoutts_> right
06:33:42 <dcoutts_> though you don't need to call your Haskell function unsafe*
06:33:46 <earthy> and this would also work for getter functions, right?
06:33:50 <dcoutts_> right
06:33:52 <ddarius> @where TAPL
06:33:53 <lambdabot> I know nothing about tapl.
06:34:05 <dcoutts_> but be careful, you can break everything if you get it wrong
06:34:09 * earthy nods ;)
06:34:11 <dcoutts_> if the function can call back to your app
06:34:14 <chessguy> ?where+ tapl http://tinyurl.com/282m6x
06:34:15 <lambdabot> Done.
06:34:16 <earthy> that's why I add the unsafe. :)
06:34:30 <dcoutts_> (this is obviously more of an issue in gui toolkits which are full of callbacks)
06:34:32 <earthy> just to be on the well documented side
06:35:09 <dcoutts_> earthy, we usually use the unsafe* prefix if there's a proof obligation on the user of the function. Here there is none.
06:35:26 <dcoutts_> and you're already in the sin bin / IO :-)
06:35:38 <earthy> hm. true enough.
06:35:47 <earthy> lemme check the requirements the lib gives me
06:36:07 <earthy> but 'saving and restoring thread/scheduler state' sounds mighty expensive
06:36:22 <earthy> especially if you're doing it 3000 times in a row. :)
06:36:29 <kpreid> arg, Orphi left
06:36:52 <dcoutts_> earthy, aye
06:37:10 <kpreid> drawing lots of lines from ghc sounds like a good use of the OpenGL bindings
06:41:27 <earthy> okay, right, according to the lib's docs I'm in the clear. here goes nothing.
06:45:17 <dcoutts_> vooom!  ? :-)
06:46:39 <earthy> sorry, was reading up a few more details :)
06:46:45 <earthy> compiling as we speak :)
06:48:10 <earthy> (my machine is somewhat busy doing something else as well)
06:52:08 <earthy> right. it used to take 40 minutes. let's see. :)
06:53:14 <Orphi> Hi guys... I'm back again.
06:53:19 <kpreid> Orphi: I'd use GHC's OpenGL bindings, to draw a lot of lines.
06:53:38 <Orphi> I just downloaded and installed Gtk2hs... and it doesn't work.
06:54:17 <Orphi> specifically, it says it can't find Graphics.UI.Gtk
06:54:33 <Orphi> tried both GHC and GHCi, both claim that no such module exists
06:54:58 <mux> what does ghc-pkg list say?
06:56:07 <Orphi> C:/ghc/ghc-6.6\package.conf:
06:56:09 <Orphi>     Cabal-1.1.6, GLUT-2.0, HUnit-1.1, OpenGL-2.1, QuickCheck-1.0,
06:56:10 <Orphi>     Win32-2.0, base-2.0, cgi-2006.9.6, fgl-5.2, (ghc-6.6),
06:56:12 <Orphi>     haskell-src-1.0, haskell98-1.0, html-1.0, mtl-1.0, network-2.0,
06:56:13 <Orphi>     objectio-1.0, parsec-2.0, readline-1.0, regex-base-0.71,
06:56:15 <Orphi>     regex-compat-0.71, regex-posix-0.71, rts-1.0, stm-2.0,
06:56:16 <Orphi>     template-haskell-2.0, time-1.0, xhtml-2006.9.13
06:56:45 <Orphi> what does that command do anyway?
06:59:22 <mux> it lists the available packages :)
06:59:28 <mux> did you really install gtk2hs ?
06:59:33 <mux> it looks like not
06:59:47 <Orphi> well, Windoze claims it's there, and there's a whole bunch of files under C:\Program Files\Gtk2hs
07:00:00 <mux> well, the package isn't registered
07:00:09 <Orphi> *sigh* I see...
07:00:22 <Orphi> can I do that manually?
07:00:34 <mux> yes, there should be a Setup.hs file somewhere
07:00:46 <mux> you can try to do "runhaskell Setup.hs register"
07:02:03 <Orphi> ...actually, I'm noticing a distinct lack of .hs files here...
07:02:25 <mux> well it makes sense if it's not in the binary distribution :/
07:02:50 <Orphi> according to the website, you just download the Windows Installer package, let it run, and it's done.
07:02:56 <Orphi> well I've done that twice now; it don't work.
07:05:13 <Orphi> *sigh* maybe I need to reboot or something...
07:05:22 <Orphi> I'll be back(tm).
07:05:24 <mux> that would be surprising
07:05:28 <mux> good luck :-)
07:07:31 <earthy> drat. no 'voom' experience.
07:08:14 <Orphi> ...and yes, that didn't fix it.
07:09:10 <kpreid> Orphi: so use my suggestion :-)
07:09:21 <Orphi> ...what, GLUT?
07:09:25 <kpreid> yeah
07:09:32 <Orphi> oh... deep... joy :S
07:09:42 <mux> gtk2hs should Just Work (TM)
07:09:46 * mux prods dcnstrct 
07:09:47 <mux> oops
07:09:47 <kpreid> if you just want to draw lines...:)
07:09:50 * mux prods dcoutts_ 
07:09:55 <kpreid> heh
07:10:04 <Orphi> I would also like to have, like, text input boxes and stuff
07:10:16 <Orphi> and have it work on WinNT, which doesn't have GLUT.
07:10:21 <mux> Orphi: maybe you could more easily compile gtk2hs by hand?
07:10:23 <kpreid> Orphi: Oh, okay. So wait for dcoutts_, I suppose.
07:10:37 <mux> I don't know how hard this is under windows, but it was reasonably easy to do for me under unix
07:10:58 <Orphi> well I _wanted_ to use wxHaskell... but that requires a UNIX emulator to build it :S
07:11:30 <Orphi> Gtk2hs however comes in a nice Windows Installer package which you just double-click and it works instantly....
07:11:40 <Orphi> ......ha.....hahaha....ahahahaoowww... :(
07:12:35 <earthy> hm. well, wxHaskell could in theory be packaged more nicely
07:12:52 <earthy> but there's less manpower behind wxHaskell than behind gtk2hs
07:13:06 <earthy> which makes that suck more
07:13:18 <Orphi> yeah, I figured.
07:13:22 <Orphi> so I thought I'd go with Gtk2hs
07:13:35 <Orphi> you know, that makes this the 3rd Haskell package I've failed to install
07:13:45 <kpreid> Orphi: by the way, my experience is that non-mainstream GUI frameworks are *always* tricky to get running...
07:13:47 <Orphi> it seems installing packages in Haskell is just an inherantly impossible thing to do
07:14:24 <Saizan> Orphi: actually i find installing them quite simple, even on windows
07:14:57 <Orphi> well HaXmL wouldn't install, Gtk2hs won't install, and some other thing that I foget didn't install either
07:15:08 <Orphi> so far I have successfully installed 0 packages.
07:15:22 <Orphi> thank God Parsec comes with GHC! ;)
07:15:29 <dcoutts_> Orphi, what went wrong with Gtk2Hs ?
07:15:30 <Saizan> which error did you get from HaXmL?
07:15:40 * dcoutts_ is obsessive about making Gtk2Hs install properly
07:15:49 <Orphi> no error from HaXmL - it just didn't work
07:16:05 * malcolmw likes to keep HaXml working too, but doesn't use Windows
07:16:30 <Orphi> I've run the Gtk2hs Windows Installer package, but GHC claims no such modele exists
07:16:36 <Saizan> did it  configure/build/install ?
07:17:02 <Ogedei> Can someone recommend a paper or piece of code that could help give me some ideas about how to approach using a relational database (or similar) in Haskell?
07:17:07 <Orphi> Saizan: I downloaded the HaXmL source, did runghc Setup.hs configure/build/install, and...
07:17:13 <Orphi> ...it all seemed to work perfectly
07:17:22 <Orphi> except that I still couldn't use HaXmL in any code
07:17:22 <kpreid> Orphi: did the Gtk2hs installer leave an installation log?
07:17:26 <dcoutts_> Orphi, hmm, can you run the installer exe from a command line window and use gtk2hs-0.9.11.exe /LOG=gtk2hs.log and then paste or send me the log
07:17:39 <malcolmw> Orphi: perhaps you just need to add -package HaXml to the ghc command-line?
07:17:42 <kpreid> Orphi: Did you install an odd GHC?
07:17:54 <Orphi> dcoutts_: OK, hold on
07:17:56 <dcoutts_> Orphi, the bit where it registers is right at the end of the log file
07:18:09 <dcoutts_> Orphi, I assume you've only got one version of GHC installed
07:18:13 <kpreid> Orphi: I'm wondering if your ghc is using a package configuration in an different place than the package installers expect
07:18:23 <Orphi> dcoutts_: yeah. GHC 6.6 only
07:18:30 <dcoutts_> kpreid, they always call ghc-pkg to do it
07:18:31 <Orphi> the installer seemed to find it
07:18:40 <kpreid> dcoutts_: okay
07:20:38 <Orphi> ok, I've got a log file... let me see what I can find
07:20:41 <dcoutts_> Orphi, then the next thing after that to investigate is to run this from a command line: ghc-pkg list and see if any packages were registered or just a subset or something.
07:21:05 <dcoutts_> Orphi, in the log file there's a bit at the end after it's copied all the files where it runs ghc-pkg.exe
07:21:16 <earthy> hm. right. still running. so it seems to not be in the ffi overhead.
07:21:36 <earthy> damn. now I need to go think about the problem. :P
07:21:39 <Orphi> ...should the exit code be 1?
07:21:59 <mux> an exit code != 0 usually means an error
07:22:05 <dcoutts_> Orphi, nope
07:22:09 <Orphi> that's what I thought
07:22:12 <dcoutts_> Orphi, so they're all '1' then
07:22:26 * mux haskell-ize his last sentence: s/!=/\/=/
07:22:26 <Orphi> hang on, let me try running ghc-pkg myself with the same params to see what it says...
07:22:33 <dcoutts_> Orphi, so ghc-pkg list doesn't include any of glib gtk etc?
07:22:39 <dcoutts_> Orphi, yes, and that's the next step :-)
07:22:44 <malcolmw> Orphi: maybe you don't have the right permissions on the ghc-pkg database then
07:22:47 <dcoutts_> Orphi, try glib first.
07:23:06 <dcoutts_> since all the other packages depend on that one
07:23:55 <dcoutts_> @paste
07:23:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:24:06 <Orphi> E:\>ghc-pkg update "C:\Program Files\Gtk2Hs\gtk.package.conf"
07:24:08 <Orphi> Reading package info from "C:\\Program Files\\Gtk2Hs\\gtk.package.conf" ... done.
07:24:09 <Orphi> ghc-pkg: dependency glib-0.9.11 doesn't exist (use --force to override)
07:24:20 <dcoutts_> Orphi, so if ghc-pkg complains, paste the message at the above address
07:24:43 <dcoutts_> Orphi, do glib first and use hpaste so we don't flood here :-)
07:24:47 <dcoutts_> @paste
07:24:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:24:55 <earthy> ah. it's done calculating
07:25:03 <earthy> now to write out the profile ;)
07:25:13 <Orphi> who or what is hpaste?
07:25:35 <dcoutts_> Orphi, see the url, all will become clear :-)
07:25:39 <earthy> a paste bin, so that you can put up snippets of code on a website without polluting the IRC channel
07:25:45 <earthy> makes it a lot easier to communicate about code
07:26:00 <dcoutts_> and they get saved so we can refer back to them
07:26:18 <Orphi> http://hpaste.org/709
07:26:26 <earthy> dcoutts: *THANKS*!
07:26:41 <Orphi> well anyway, that's what it says
07:26:50 <dcoutts_> Orphi, so do glib first, what does that one complain about?
07:27:05 <dcoutts_> Orphi, you can annotate your existing paste with extra info
07:27:06 <earthy> from 2693.20 secs down to 1015.55 secs is not to be sneezed at
07:27:13 <dcoutts_> earthy, oh good
07:27:26 <dcoutts_> earthy, just from that one change?
07:28:17 <dcoutts_> earthy, if so, it makes it seem like that iterator interface is quite expensive, you can't get direct access to the data in some way?
07:28:41 <earthy> I might
07:28:56 <dcoutts_> earthy, because it can't be doing much each iteration if the calling overhead was such a large portion of the time taken.
07:28:58 <earthy> but there's some more code that might benefit from adding 'unsafe' ;)
07:28:59 <Orphi> ...ok, so now I am no longer confused by Gtk2hs, but also by hpaste :S
07:29:06 <dcoutts_> Orphi, heh :-)
07:29:21 <Orphi> anyways, any idea what the error message means?
07:29:40 <dcoutts_> Orphi, so you've tried the gtk one twice now, are you going to do the glib one?
07:29:53 <dcoutts_> Orphi, we expect the gtk one to fail to register if glib isn't registered first
07:30:03 <Orphi> oh... I thought I did...
07:30:04 <earthy> duncan: it's just copying 1 double each call, and incrementing a pointer
07:30:10 <dcoutts_> Orphi, and the installer does the glib one first so that'll be the one that's interesting
07:30:17 <earthy> so yeah, the overhead was indeed massive
07:30:21 <dcoutts_> if that one fails all the others will fail since they depend on glib
07:30:32 <dcoutts_> earthy, doh!
07:30:51 <dcoutts_> earthy, you want a storable array and then access it in Haskell
07:30:59 <earthy> yeah, duh
07:31:17 <earthy> the problem is that I'm not keen on refactoring all 14000 loc.
07:31:38 <dcoutts_> earthy, so the C lib doesn't provide the underlying array? :-(
07:31:44 <earthy> plus, the array in the foreign lib is a somewhat weird matrix array object
07:31:57 <earthy> which allows adding and removing dimensions and shit like that
07:32:05 <dcoutts_> I'm sure you could index it with a special index type
07:32:15 <dcoutts_> Ix instance
07:32:26 <earthy> yeah, in fact, that's exactly what the current code is doing, but the special index type is in C land :)
07:32:31 <Orphi> http://hpaste.org/710
07:32:32 <dcoutts_> heh
07:33:09 <earthy> but, currently, 60% of the runtime is spent on other calls
07:33:14 <earthy> so I'll try to shave there first
07:33:15 <dcoutts_> Orphi, hmm, odd ok. So does "C:\Program Files\Gtk2Hs" exist? what subdirs does it have?
07:33:25 * earthy hugs the profiler
07:33:29 <Orphi> C:\Program Files\Gtk2hs exists
07:33:37 <Orphi> \imports exists
07:33:47 <Orphi> has two subfolders: imports and includes
07:33:49 <dcoutts_> Orphi, can you paste the content of "C:\\Program Files\\Gtk2Hs\\glib.package.conf" ?
07:34:11 <dcoutts_> (using hpaste of course since that's not a small file)
07:34:25 <Orphi> so C:\Program Files\Gtk2hs\imports\imports\glib exists
07:35:51 <Orphi> glib.package.conf => http://hpaste.org/711
07:37:08 <Orphi> ...any ideas?
07:39:27 <Orphi> ...that sounds like a 'no'.
07:40:22 <dcoutts_> Orphi, not yet...
07:40:37 <Orphi> personally, I'm guessing the extra subfolder level shouldn't be there
07:40:55 <Orphi> but... why would it only be doing that on my PC?
07:41:23 <pjd> in case there are any stumblers in the audience: http://haskell.group.stumbleupon.com/
07:41:25 <lambdabot> Title: SU: Haskell
07:42:17 <dcoutts_> Orphi, what extra subfolder level?
07:42:30 <dcoutts_> Orphi, I don't see that in the error message or glib.package.conf file
07:42:39 <Orphi> like I said, C:\Program Files\Gtk2hs\imports\imports\glib exists
07:42:42 <chessguy> @type (=~)
07:42:44 <lambdabot> Not in scope: `=~'
07:42:48 <Orphi> but C:\Program Files\Htk2hs\imports\glib doesn't
07:42:52 <dcoutts_> Orphi, oh!
07:42:56 <chessguy> @type Text.Regex.Posix.(=~)
07:42:58 <lambdabot>     Not in scope: data constructor `Text.Regex.Posix'
07:42:59 <lambdabot>  
07:43:08 <chessguy> @slap lambdabot
07:43:08 * lambdabot smacks lambdabot about with a large trout
07:43:19 <Orphi> ...fishy
07:43:27 <dcoutts_> Orphi, ok, that's bad, lemme investigate if I messed something up at the last moment when making the installer
07:43:46 <Orphi> ...don't tell me I'm the very first person to try to install it? heh
07:44:35 <dcoutts_> Orphi, lots of people tried the RC1 and RC2 but the final was only out today
07:44:45 <Orphi> oh... I didn't know that.
07:44:53 <dcoutts_> so it's possible I messed something up
07:44:56 <Orphi> didn't look at the release date. heh.
07:45:14 <Orphi> so I'm sitting here thinking "hey, if the installer was broken, somebody would have noticed months ago"...
07:46:07 <dcoutts_> nope, only this morning :-)
07:46:11 <Orphi> riiiight
07:46:28 <Orphi> well it looks like there's an extra redundant subfolder in there by mistake ;)
07:49:34 <Orphi> would you like me to remove 1 subfolder and see if it will register properly?
07:49:40 <chessguy> very nice regex intro by Bryan O'Sullivan
07:49:49 <chessguy> does he come on #haskell?
07:50:05 <dcoutts_> Orphi, sure, try that
07:50:16 <Orphi> dcoutts_: ok, stand by...
07:50:35 <dcoutts_> Orphi, yeah, I broke it. Damn, I should never change things at the last minute. I'll upload a new .exe.
07:51:12 <mux> bad duncan, no cookies
07:51:14 <Orphi> yups, glib registers now.
07:51:20 <dcoutts_> great
07:51:25 <Orphi> seems that's all it was
07:51:30 <dcoutts_> good good
07:51:38 <mux> last minute changes < *
07:51:45 <dcoutts_> doh!
07:51:54 <Orphi> ...so now you fixie?
07:51:55 <Orphi> ;)
07:51:58 <dcoutts_> yep
07:52:06 * dcoutts_ feels foolish now
07:52:07 <dcoutts_> :-)
07:52:19 <Orphi> ok. uh... hmm... the uninstaller will probably not like it that I just moved stuff
07:52:37 <Orphi> maybe I should put it back how it was, cleanly uninstall, and wait for the new upload.
07:53:39 <dcoutts_> Orphi, doesn't matter to much
07:53:45 <Orphi> no? ok.
07:53:52 <dcoutts_> Orphi, you can run the uninstaller and just del the stuff it leaves
07:53:58 <Orphi> right.
07:54:05 <dcoutts_> the only thing it really does to your system is register the packages with ghc
07:54:29 <Orphi> ok. so it just deletes the whole folder without really looking at what's in there?
07:56:33 <Orphi> right, well, Gtk2hs is gone.
07:56:43 <Orphi> let me know when the new installer is uploaded. ;-)
07:56:49 <dcoutts_> will do
07:57:39 <earthy> !sigh
07:57:48 <Orphi> is that a 10 minute job or a few hours job?
07:59:52 <dcoutts_> Orphi, 1/2 hour maybe
08:00:01 <Orphi> okies.
08:04:38 * malcolmw is sure that Orphi's problem with installing HaXml is not the same as with Gtk2Hs
08:04:53 <dcoutts_> yeah, wouldn't be the same
08:06:33 <earthy> interesting, how ghc's recompilation checker only recompiles dependent modules if the interfaces changes
08:07:08 <glguy> LoL @ slava's reddit question getting 254 comments, "Why Can't Programmers.. Program?"
08:12:04 <dcoutts_> earthy, sure, what would you expect?
08:12:25 <dcoutts_> earthy, actually it's slightly more subtle since it has to look at the .hi files of things that are not directly imported
08:13:10 * earthy nods
08:13:23 <earthy> but most other building systems don't know to do that
08:13:34 <earthy> so it's still interesting :)
08:14:32 <yip> dcoutts_: hey... you remember my gameboy emulator?
08:14:52 <dcoutts_> yip, not sure I do
08:15:03 <dcoutts_> yip, a full cpu emulator?
08:15:16 <yip> dcoutts_: yes, plus most of the graphics hardware
08:15:36 <dcoutts_> I vaguely remember now you mention it
08:15:58 <malcolmw> hmake knew how to do smart recompilation checking many years before ghc --make even existed
08:16:13 <yip> http://www.mutantlemon.com/omegagb/devlog/images/omegagb-0003.png
08:17:40 <dcoutts_> yip, looks nice
08:17:52 <yip> dcoutts_: i'm cleaning it up a bit and then i'm gonna put a darcs repos online
08:17:56 <dcoutts_> yip, so what's new with it? does it work :-)
08:17:57 <dcoutts_> cool
08:18:07 <yip> it still is only barely working
08:18:11 <dcoutts_> yip, then you can write a bit about it for the Gtk2Hs website :-)
08:18:16 <yip> i'm hoping that others can help me optimize it so it will run realtime
08:18:26 <yip> dcoutts_: ok that sounds like a good idea
08:18:31 <dcoutts_> cool
08:19:03 <yip> i forgot that i used glade though, so now i need to figure out how to install glade on this distro, and then reinstall gtk2hs :(
08:19:18 <dcoutts_> ah yes
08:19:21 <dcoutts_> what distro?
08:19:25 <yip> crux
08:19:25 <CosmicRay> does anybody know of any haskell library for setting up shell-like pipelines between commands?
08:20:00 <dcoutts_> CosmicRay, there are a few I think, though I can't recall the names off the top of my head
08:20:08 <dcoutts_> yip, never even heard of it! :-)
08:20:18 * kolmodin is going home
08:20:21 <kolmodin> ciao
08:20:48 <dcoutts_> @arr
08:20:49 <lambdabot> Yeh scurvy dog...
08:20:55 <dcoutts_> later kolmodin :-)
08:21:02 <kolmodin> crux, a dirstro for power users, I've heard
08:21:08 <kolmodin> *distro
08:21:13 <yip> dcoutts_: i'm been using it for almost a year now i think... pretty solid. only problem is that it's glade packages seem to be broken. but i'll try them now again, hopefully it's fixed already
08:21:44 <dcoutts_> kolmodin, I thought that was Gentoo!
08:22:30 <yip> gentoo used to be hard, when it was still small and you had to make your own emerge scripts for packages. but now you can emerge anything
08:23:19 <yip> i still find it amazing though that the trend for number of distros available continues to go up, always faster and faster
08:31:51 <allbery_b> cute ghc 6.6 failure modes:  an out of date .hi file can cause ghc to consume all available VM
08:32:29 <Igloo> allbery_b: Can you reproduce it from a clean directory?
08:32:50 <allbery_b> nope, that was how I fixed it
08:33:51 <allbery_b> possibly should have tarred everything up first to try to identify what exactly caused it, but (a) it was pugs.  good luck. (b) was trying to get ready for work while my machien was trying to melt down :)
08:34:23 <Igloo> :-)
08:34:47 <Igloo> Even with a tarball it's a pain to try to work out what happened and why, though
08:38:01 <dcoutts_> glguy, yeah that FizzBuzz thing is funny, the way everyone feels compelled to code a solution - the Haskell solution is very neat of course ;-)
08:39:18 <yip> what do you guys recommend for bug tracking?
08:39:50 <dcoutts_> trac is ok except for spam problems
08:40:00 <dcoutts_> Igloo, any luck with the upgrade btw?
08:40:17 <dcoutts_> what are we waiting for atm?
08:40:41 <Orphi> ...and just like the prodical son, I'VE RETURNED! :D
08:40:44 <Igloo> Waiting for monk to be upgraded to Debian etch
08:41:30 <Orphi> does anybody else here think "functional programming" should be renamed "function-oriented programming"?
08:41:46 <Igloo> Or for someone to work out how to make it work with what we have
08:42:17 <norpan> no, it dissonates nicely with nonfunctional
08:42:44 <norpan> or dysfunctional :)
08:42:59 <Orphi> "...so C is a non-functional language?"
08:43:14 <Orphi> [I feel no further comment is necessary here.]
08:44:08 <Orphi> FWIW, a while back a posted a very long "intro to Haskell" type post to a newsboard I regularly hang out at
08:44:18 <Orphi> I got a range of responses
08:44:28 <Orphi> "wow - you wrote all that yourself? it's really good!"
08:44:39 <wkh> "tl;dr"
08:44:45 <Orphi> "Haskell sounds cool, but... I don't know... monads look really complicated, and all my programming is IO."
08:45:14 <Orphi> "sounds nice, but I doubt you can do any serious stuff with it."
08:45:56 <yip> i think that most haskell programmers have heard these arguments a million times, and probably even acknowledge that there is at least a tiny bit of truth to them
08:46:16 <Orphi> one guy (who's a part-time LISP programmer (!!)) said it was "the best introduction to actually USING monads that I've ever seen"
08:46:25 <pejo> The IO one is mostly just wrong. People even bring up compilers as examples of those "Just IO"-programs.
08:46:41 <Orphi> I did Maybe first, then [], and IO last ;-)
08:46:51 <quicksilver> well IO isn't the best word for it
08:47:04 <quicksilver> all functions have inputs (parameters) and outputs (results) after all
08:47:07 <yip> i think haskell could still use a lot of work in the IO area... like having a debugger
08:47:11 <quicksilver> in some sense all calculatoin is IO
08:47:20 <quicksilver> this causes confusion
08:47:35 <Orphi> in some sense, the entire POINT of running a program is to cause side-effects ;)
08:48:14 <mux> well yeah, this is why main has type IO () :-)
08:48:17 <dcoutts_> na, it's to calculate the answer! :-)
08:48:18 <Orphi> I tried to point out that only actual input/output needs to happen in the IO monad
08:48:26 <Orphi> but nobody seemed to understand the distinction
08:48:57 <mux> I found monads to be quite understandable once I stopped trying to make analogies with other stuff, and concentrated on the do rewriting rules
08:48:58 <Orphi> for example, a compiler is going to have a tiny bit that looks like "do x <- readFile blah; writeFile blah (compile x)"
08:49:14 <Orphi> and the "compile" is just pure code
08:49:18 <Orphi> it's really not hard
08:50:32 <DynWind> speaking of monads ...
08:50:37 <Orphi> ...hahaha
08:50:52 <DynWind> consider a Haskell which used strict evaluation
08:51:01 <DynWind> would the IO monad be necessary even then?
08:51:10 <Cale> DynWind: yes
08:51:27 <Cale> DynWind: (if you want the guarantee of referential transparency still)
08:51:44 <Orphi> a while ago, I had a look at Clean
08:51:54 <Orphi> it's basically like Haskell, except impure
08:52:00 <DynWind> but any function that does IO is *not* referentially transparent, is it?
08:52:03 <Orphi> and that seems to make it *drastically* more complicated.
08:52:10 <Cale> DynWind: right.
08:52:29 <mux> Clean is purely functional
08:52:32 <DynWind> so even if you put it inside a monad, it doesn't become ref-transparent
08:52:49 <Cale> DynWind: Monads work by explicitly representing side-effects.
08:52:53 <Orphi> it's much lower-level tho
08:53:00 <DynWind> it seems to me that the IO monad does two things:
08:53:11 <Cale> The evaluation of a value of type (IO a) doesn't create side effects.
08:53:17 <Cale> Only its execution does.
08:53:17 <DynWind> (1) sequence IO actions (necessary because of laziness)
08:53:26 <DynWind> (2) separate IO and non-IO code
08:53:33 <Cale> Well, yes.
08:53:51 <yip> Cale: would the IO monad still work if haskell weren't lazy? how would you do an infinite loop?
08:53:52 <Cale> #1 is also desirable even in a strict language though.
08:54:11 <pejo> yip, why would a infinite loop require laziness?
08:54:19 <mux> I like to think of monads as a way to type side-effects
08:54:20 <Cale> yip: Tail recursion, no?
08:54:33 <yip> oh right... i was thnking of something else....
08:54:40 <icarroll> > maximum [1..10^6]
08:54:41 <lambdabot>  1000000
08:55:14 <DynWind> Cale: evaluation/execution ... can you elaborate on the distinction b/w the two?
08:55:41 <Orphi> for me, I think the biggest thing that gets in the way with Haskell is when you have a working program, and then you decide to make one utterly tiny change to it, and find you must redesign the entire program to do this.
08:55:49 <njd5> @users
08:55:50 <lambdabot> Maximum users seen in #haskell: 332, currently: 318 (95.8%), active: 39 (12.3%)
08:55:59 <njd5> @hoogle Char -> Word9
08:56:01 <lambdabot> No matches, try a more general search
08:56:03 <njd5> @hoogle Char -> Word8
08:56:04 <lambdabot> No matches, try a more general search
08:56:06 <Cale> DynWind: Evaluation is pure, and has no side effects. In the case of (IO a), it simply produces a value which internally represents those effects somehow.
08:56:10 <pejo> Orphi, that might happen with other languages as well. Just look at the aspect oriented people.
08:56:18 <mux> Orphi: well I would state the exact opposit
08:56:21 <Cale> Execution actually carries out those effects.
08:56:41 <Orphi> oh, sure, it happens elsewhere
08:56:56 <Orphi> but Haskell's type system is so powerful that you can often tell what a funtion does just by its type
08:57:07 <Orphi> and then means that if you make it do something else, its type must change
08:57:21 <Orphi> now, fortunately that same powerful type system makes it quite easy to change types around
08:57:24 <Orphi> but not always
08:57:33 <quicksilver> DynWind: the fact they don't break referential transparency is to some extent the point of monads
08:57:36 <mux> that's why you don't always give types to your functions but let the type system infer it
08:57:52 <glguy> woohoo, "click" and "here" are among the top words in external links to my company site
08:57:56 <DynWind> Cale: that is, all the (IO a)'s sit there waiting until main kicks them into doing their job (which is execution)
08:57:57 <Orphi> well, sure (when it works), but other code still needs to call it ;-)
08:58:05 <Cale> DynWind: right
08:58:06 <quicksilver> DynWind: all kinds of previoius attempts to add side effects to functional languages worked fine, but broke transparency
08:58:15 <quicksilver> Monads don't, though
08:58:29 <mux> uniqueness typing doesn't too, if I'm not mistaken
08:58:34 <pejo> Orphi, I'd boldly say that the majority of functions people write don't need a type annotation for the type systems sake.
08:58:44 <Orphi> mux: makes the type system psychotic tho
08:59:05 <mux> Orphi: what does? uniqueness typing?
08:59:11 <Orphi> mux: yeah
08:59:21 <DynWind> Cale, quicksilver: referential transparency means that I can rewrite something like (f x y) with 42 (which is the result), right?
08:59:23 <Orphi> pejo: I agree (though it's useful for other reasons)
08:59:40 <Cale> DynWind: yeah, if 42 was its result, then it will always be.
09:00:00 <Cale> Alternately, if f x == g x for all x, then you can replace f with g wherever it occurs.
09:00:05 <pejo> Orphi, well. That's mainly an engineering problem, or people need to stop writing type-incorrect programs. :-)
09:00:06 <DynWind> right
09:00:15 <Orphi> but I mean, like, you have some code that uses map to process a list somehow...
09:00:32 <Orphi> ...and then you decide you want to process the elements *slightly* different if the element before was a particular one
09:00:38 <Orphi> now it's not a map. it's a fold.
09:00:41 <icarroll> > let collatz n = if n == 1 then [1] else n : collatz (if even n then n `div` 2   else 3 * n + 1) in let ns = [1..10^6-1] in maximumBy (\x y -> (snd x) `compare` (snd y)) (zip ns (map (length . collatz) ns))
09:00:43 <Orphi> EEEP! you loose.
09:00:45 <lambdabot> Terminated
09:00:50 <DynWind> Cale: so what can I replace something like getChar with?
09:00:53 <dcoutts_> Orphi, try downloading and installing again now, though you probably want to use this SourceForge mirror since the others take a while to sync: http://downloads.sourceforge.net/gtk2hs/gtk2hs-0.9.11.exe?use_mirror=osdn
09:00:56 <quicksilver> DynWind: and you can calculate common sub expressions once
09:01:00 <lambdabot> http://tinyurl.com/2b93b4
09:01:07 <Orphi> dcoutts_: OK...
09:01:16 <Cale> DynWind: well, it's a primitive -- that would be like trying to replace 42 with something.
09:01:28 <DynWind> ah
09:01:31 <Cale> DynWind: you can only replace it with something more complicated
09:02:06 <DynWind> so all the functions that do IO are special, residing somewhere inside the compiler/run-time system?
09:02:27 <sjanssen> DynWind: not every function that does IO
09:02:42 <Orphi> just the IO primitives, presumably
09:02:59 <sjanssen> but yes, there are certain functions that are, by necessity, internal compiler things
09:03:00 <Cale> DynWind: well, yes, though I hesitate to refer to them as functions
09:03:08 <Orphi> this is something I have wondered about myself - the IO monad looks pretty "monolithic"
09:03:18 <Orphi> doesn't look easily extensible
09:03:48 <Cale> Orphi: The FFI lets you import C programs, if that's what you want.
09:03:51 <sjanssen> Orphi: IO has all the building blocks to make new operations
09:03:59 <DynWind> that was my mistake. I was considering IO primitives the same as usual functions
09:04:06 <sjanssen> FFI, mutable references, raw memory access, ...
09:04:11 <Orphi> Cale: so... each IO primitive is an FFI call somewhere?
09:04:24 <quicksilver> They are 'ordinary functions' which happen to have types in the IO monad
09:04:28 <quicksilver> or 'ordinary values' if you like
09:04:30 <Cale> Orphi: It could be, but in practice, the compiler handles most of them.
09:04:37 <Orphi> right.
09:04:49 <quicksilver> for example 'a' is pretty special
09:04:54 <quicksilver> you can't decompose 'a' any further
09:04:58 <sjanssen> Orphi: you could certainly implement all the IO actions in the prelude with FFI
09:05:02 <quicksilver> there isn't much you can do with it
09:05:02 <CosmicRay> ARGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
09:05:09 <quicksilver> but that doesn't mean that Char is a special type :)
09:05:10 <CosmicRay> it seems like ghci is interfering with forks
09:05:13 <CosmicRay> or pipes
09:05:23 <CosmicRay> I just spent a day trying to figure out why my code keeps hanging in ghci
09:05:26 <CosmicRay> only to find it working in ghc.
09:05:50 <sjanssen> CosmicRay: ghci uses -threaded by default, is that the difference?
09:06:02 <CosmicRay> quite possible indeed.
09:06:13 <CosmicRay> but I'm not asked it to create any threads
09:06:17 <CosmicRay> though it is true that ps shows that it has
09:06:28 <dcoutts_> CosmicRay, if you're using FFI it may use threads
09:06:30 <CosmicRay> how can I turn that off?
09:06:34 <CosmicRay> I'm not using FFI myself
09:06:36 <DynWind> ah! I think I've got it now. getChar :: (IO a) is simply a *value*, not a function. Therefore no trouble with referential transparency
09:06:40 <dcoutts_> can't ghci is built with -threaded
09:06:42 <Cale> DynWind: indeed
09:06:43 <DynWind> doh
09:06:51 <norpan> DynWind: you've got it!
09:06:59 <sjanssen> DynWind: now you know, and knowing is half the battle :)
09:07:03 <DynWind> thankies, gentlemen :)
09:07:07 <CosmicRay> dcoutts: ah.
09:07:09 <CosmicRay> sigh.
09:07:40 <CosmicRay> well then, my code actually works.
09:07:46 <dcoutts_> CosmicRay, is this the ordinary fork in the base libs? if so you could post your issue to the ghc-users list
09:07:56 <Cale> DynWind: one cool thing about doing things this way is that it's rather easy to write "control structures", and you have little worry about things getting executed accidentally before they should.
09:08:05 <dcoutts_> CosmicRay, if you compile your app with -threaded and it doesn't work then you might want to report that as a bug.
09:08:12 <CosmicRay> dcoutts: it's the one in System.Posix.Process
09:08:30 <dcoutts_> CosmicRay, that should be ok. It'll stop all other Haskell threads appropriately.
09:08:58 <DynWind> Cale: yes. The way I think of monads is that they let you control the "function application" operation. Lets you replace plain application (which is the Identity monad) with something that does a bit extra on the side
09:09:35 <DynWind> like CPS, in fact
09:09:44 <dcoutts_> Orphi, tell me when you hit success/failure and I'll either post the announcement of the update or fix the next bug :-)
09:10:18 <CosmicRay> yes, indeed -threaded breaks it
09:10:38 <Orphi> dcoutts_: unbelievably, I am *still* downloading it :|
09:10:50 <Cale> DynWind: yeah
09:10:54 <Orphi> getting about 3kb/sec
09:10:55 <dcoutts_> Orphi, the osdn mirror is slow but it is at least up to date
09:11:02 <Orphi> lol. okies.
09:11:16 <dcoutts_> Orphi, the other mirrors take up to an hour to sync
09:11:20 <Orphi> Cale: I got called away, was just trying to type something...
09:11:25 * CosmicRay posts
09:11:48 <Orphi> Cale: suppose, for example... *thinks*... you wanted to implement an interface to a hardware RNG
09:11:55 * CosmicRay is hacking on his shell again
09:11:55 <Orphi> clearly that's got to be in the IO monad
09:12:07 <CosmicRay> runS $ "ls -l" -|- wcL
09:12:10 <Orphi> but then you'd have to alter the internal structure of the IO monad :S
09:12:11 <Cale> Orphi: indeed
09:12:23 <Cale> er
09:12:24 <Cale> no
09:12:26 <CosmicRay> runs the given command, and pipes it to the haskell [String] -> [String] function to count its lines, and puts the result in a string
09:12:26 <sjanssen> Orphi: why do you have to alter the IO monad?
09:12:41 <Cale> Because most likely the primitives you need to access the hardware are already present
09:12:48 <Orphi> well, main :: IO ()
09:12:51 <Cale> You would just write a wrapper around them
09:12:57 <yip> Orphi: you can read from /dev/random or call a C function
09:13:09 <Orphi> so presumably what happens is that main returns some datastructure representing the IO actions to be performed, and the RTS then performs them
09:13:19 <Orphi> you'd need a new structure to represent accessing the hardware
09:13:26 <Cale> You might have to use the FFI if there was some syscall which you needed that there was no equivalent for.
09:13:35 <yip> Orphi: this "structure" includes a primite that allows you to call C functions
09:13:43 <sjanssen> Orphi: no, the ffi primitives should be enough
09:13:47 <Orphi> ah, ok.
09:13:59 <sjanssen> if you can write it in C, you can write it in Haskell
09:14:14 <quicksilver> Orphi: no, that's actually not what happens
09:14:15 <Orphi> OOC, can you use FFI to talk to something that isn't C?
09:14:16 <matthew_-> ++s ?
09:14:17 <Cale> Even without the FFI, it's quite likely you could access it.
09:14:20 <quicksilver> Orphi: but it could be
09:14:24 <matthew_-> you can write that in haskell? ;-P
09:14:32 <quicksilver> Orphi: that's a reasonable model for how it *might* be implemented
09:14:38 <Cale> Orphi: yeah, I've succeeded in calling fortran code.
09:14:54 <Orphi> presumably asssebly is easy too
09:14:57 <Cale> yeah
09:15:08 <quicksilver> well assembly is C, in the modern toolchain
09:15:12 <Cale> It's also awkwardly possible to interface with C++ code
09:15:20 <quicksilver> it's compiled as C, and you use C to give assembly 'function names'
09:15:41 <sjanssen> Orphi: there's a fork of ghc for the jvm that can FFI normal Java functions
09:15:45 <Cale> The awkwardness having to do with name mangling.
09:15:58 <Orphi> interesting...
09:16:02 <icarroll> Can anyone help me fix my stack overflow? http://hpaste.org/712
09:16:06 <Orphi> I don't know if anybody will care, but...
09:16:12 <Cale> icarroll: I'll have a look
09:16:19 <Orphi> I'm working on a Haskell compiler that targets Java
09:16:23 <icarroll> Cale: thx
09:16:27 <sjanssen> icarroll: have you tried compiling with -O
09:16:31 <icarroll> no
09:16:40 <Cale> oh, do that first.
09:16:44 <sjanssen> that should fix the problem where
09:16:47 <sjanssen> s/where/here
09:17:03 <Orphi> dcoutts_: 44% downloaded
09:17:16 <dcoutts_> Orphi, ugg ok :-)
09:17:23 <icarroll> ok, no stack overflow yet
09:17:45 <Cale> icarroll: If you're using 6.6, you can import Data.Ord, at which point cmpSnd = comparing snd
09:17:55 <icarroll> cool, thx
09:18:09 <icarroll> why does maximum overflow on a list of a million items?
09:18:22 <sjanssen> icarroll: it isn't maximum's fault
09:18:43 <Orphi> God bless lazy evaluation! lol
09:18:46 <Cale> It kind of is, actually.
09:18:50 <sjanssen> icarroll: you aren't strict in the parameter to collatz
09:19:12 <Cale> ah, perhaps not here :)
09:19:12 <sjanssen> scratch that, you are strict in that parameter
09:19:38 <Cale> @src maximumBy
09:19:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:19:46 <Cale> @src Data.List.maximumBy
09:19:47 <lambdabot> Source not found. I feel much better now.
09:19:50 <Cale> hmm
09:19:55 <Cale> @src maximum
09:19:55 <lambdabot> maximum [] = undefined
09:19:56 <lambdabot> maximum xs = foldl1 max xs
09:20:00 <Cale> Well, that'll do
09:20:13 <Orphi> um... isn't fold1 _ [] = undefined anyway?
09:20:13 <Cale> If that were a foldl1', it'd do better here.
09:20:27 <Cale> Orphi: yes
09:20:37 <Orphi> Cale: ok. just @src being silly then?
09:20:43 <Cale> > foldl1 (+) []
09:20:45 <lambdabot>  Exception: Prelude.foldl1: empty list
09:20:56 <Cale> You wouldn't want that message. :)
09:21:12 <glguy> > maximum []
09:21:13 <quicksilver> although strictness annotations are somehow a hack around an imperfect optimiser
09:21:14 <lambdabot>  Exception: Prelude.maximum: empty list
09:21:24 <Orphi> someone should implement a patch to GHC where all calls to error print a full stacktrace :-P
09:21:29 <Cale> Actually, I'm surprised that it doesn't say error "Prelude.maximum: empty list"
09:21:40 <glguy> Orphi: Haskell doesn't have conventional "stack traces"
09:21:49 <Orphi> true
09:21:53 <Cale> Orphi: Compile with profiling support and run the program with +RTS -xc -RTS
09:21:54 <quicksilver> in an ideal world I'd rather use a built-in stricness analyzer than have to define strict versions of functions
09:22:05 <Cale> You'll get a cost-centre trace.
09:22:17 <sjanssen> quicksilver: usually strictness analysis is enough
09:22:27 <Orphi> Cale: doesn't that mean I need to define some cost centers first?
09:22:38 <quicksilver> sjanssen: right
09:22:41 <sjanssen> quicksilver: I mean the strictness analysis in ghc
09:22:45 <Cale> Orphi: Well, compiling with -prof -auto-all will add lots.
09:22:56 <Orphi> Cale: ok.
09:23:03 <Orphi> Cale: I know naff all about GHC.
09:23:11 <Orphi> Cale: I just use it to compile stuff, really...
09:23:58 <Cale> That's not really perfect -- if the error occurs in a module not compiled with profiling support, it doesn't produce particularly helpful results.
09:25:14 <Orphi> I really wish there was some way to evaluate Haskell code 1 reduction at a time! :S
09:25:16 <Saizan> i thought you need the -prof version of all the modules you are importing to build with profiling support
09:26:01 <Orphi> dcoutts_: 70% and counting...
09:26:22 <dcoutts_> ...
09:26:36 <icarroll> sjanssen++
09:26:38 <icarroll> Cale++
09:26:38 <Orphi> I'm still downloading Gtk2hs ;)
09:27:14 <Cale> Orphi: there have been tools written to do that, but they tend not to work with all available libraries.
09:27:14 <DynWind> @type (:=)
09:27:17 <icarroll> so is there any way to get ghci to optimize?
09:27:17 <lambdabot> forall a b. a -> b -> Assoc a b
09:27:36 <Cale> icarroll: compile the relevant modules with -O, and then load them in ghci
09:27:42 <Orphi> Cale: really? I just got about 8% through writing one myself...
09:28:10 <Saizan> i can't know if a type instances a typeclass with TH, right?
09:28:20 <Cale> http://www.haskell.org/hat/
09:28:22 <lambdabot> Title: Hat - the Haskell Tracer
09:28:24 <DynWind> what module does (:=) come from?
09:28:50 <Cale> http://www.cs.mu.oz.au/~bjpop/buddha/
09:28:51 <lambdabot> Title: A declarative debugger for Haskell 98
09:29:05 <xerox> ?index (:=)
09:29:06 <lambdabot> Control.Parallel.Strategies
09:29:18 <Cale> DynWind: I think that one would be from Control.Parallel.Strategies -- yeah
09:29:43 <Orphi> Cale: I know about Hat
09:29:46 <yip> dcoutts_: you use glade 3?
09:29:52 <DynWind> Control.Parallel? this is the same (:=) that is used in gtk2hs? [ labelText := "hello" ] etc?
09:29:53 <Orphi> Cale: not going to help for a program that doesn't typecheck
09:29:54 <Cale> It's a sign of the Strategies module needing a clean-up.
09:29:55 <dcoutts_> yip, sometimes
09:30:01 <dcoutts_> DynWind, nope
09:30:10 <Cale> Orphi: evaluation doesn't happen before typechecking.
09:30:20 <araujo> hello
09:30:28 <araujo> Cale, hi there
09:30:33 <Cale> araujo: hello
09:30:34 <araujo> Cale, you got access to lambdabot ?
09:30:35 <DynWind> dcoutts_: ah, ok
09:30:37 <yip> dcoutts_: and othertimes glade 2?
09:30:39 <Orphi> Cale: sure, I know that. It would just be useful when you have some complicated function that won't compile, and you want to figure out why
09:30:44 <Cale> araujo: what kind of access?
09:30:54 <araujo> Cale, to join it to a channel
09:31:00 <dcoutts_> yip, right. glade 3 has been getting much better recently, fewer bugs, better UI.
09:31:01 <Cale> Orphi: ah, a step-by-step typechecker then?
09:31:05 <Cale> araujo: yep
09:31:07 <Cale> I think so
09:31:16 <Orphi> Cale: well, that would be useful too.
09:31:17 <araujo> Cale, it isn't on #haskell.es
09:31:19 <yip> dcoutts_: so if i can choose only one of them, which should it be?
09:31:26 <Cale> @join #haskell.es
09:31:30 <yip> dcoutts_: glade2 used to crash and freeze on me all the time
09:31:33 <araujo> thanks Cale
09:31:34 <araujo> :-)
09:31:37 <Orphi> Cale: but if you could run the program step by step without any checking at all, you'd presumably soon see where it's going wrong
09:31:42 <quicksilver> i generally fake out step-by-step typechecking by copy-pasting into ghci
09:31:51 <Cale> Orphi: uh, that's kind of impossible
09:31:55 <quicksilver> Orphi: "running without typechecking" doesn't make a lot of sense ;)
09:31:57 <Cale> Orphi: due to typeclasses
09:32:08 <quicksilver> Orphi: the types tell the compiler what to do, in some cases
09:32:09 <dcoutts_> yip, whichever you choose, get the latest version
09:32:23 <Orphi> Cale: yeah, that's true... I hadn't thought of that ;)
09:32:42 <quicksilver> editor integration which could try to run the type inferrer automatically on subexpressions and show you the result would be handy. though
09:32:45 <Orphi> well... if you're running the thing interactively to see where it explodes, you could just "tell" the interpreter "plz use this"
09:33:03 <dcoutts_> Orphi, also, a type error doesn't mean that the program *would* have got that type error at runtime.
09:33:15 <dcoutts_> Orphi, eg if True then 'a' else 1
09:33:33 <Orphi> usually my type errors are "you missed out a level of indirection"
09:33:50 <Orphi> e.g., forgetting that something is a Maybe Int rather than an Int
09:34:02 <DynWind> quicksilver: it'd be a nice feature to add to shim
09:34:08 <quicksilver> DynWind: shim?
09:34:12 <Orphi> if you ran through that a step at a time, you'd notice
09:34:26 <DynWind> @where shim
09:34:26 <lambdabot> http://shim.haskellco.de/trac/shim
09:34:36 <DynWind> Superior Haskell Interaction Mode
09:35:02 <Cale> Orphi: why go to all that trouble though, when the compiler is going to tell you exactly where it's happening?
09:35:31 <Orphi> Cale: when you've got a 12-line function that does something intricate, it can be hard to figure out
09:35:32 <quicksilver> DynWind: ah looks neat
09:35:34 <glguy> bah, static typing is like intellisense, it rots the mind!
09:35:45 <quicksilver> Orphi: copy and paste subexpressions into ghci
09:35:51 <Cale> glguy: hehe
09:35:53 <quicksilver> Orphi: and get their types or evaluate them
09:36:07 <glguy> does it compile? no, does it now? no, does it now? yes! sweet, moving on
09:36:13 <Orphi> ...doesn't work when the whole module won't compile because of it (and hence no datatype decls)
09:36:37 <Orphi> dcoutts_: download completed. let me go try it...
09:36:53 <dcoutts_> Orphi, sorry for making you wait :-)
09:37:32 <quicksilver> Orphi: generally I comment out the offending definition
09:37:35 <Orphi> oh, it's ok, it's only been... what... a few hours ;-)
09:37:37 <quicksilver> Orphi: and load the rest into ghci
09:37:51 <Orphi> quicksilver: now try when every function calls every other function :(
09:38:14 <Orphi> dcoutts_: I'm seeing new packages in ghc-pkg... :D
09:38:24 <dcoutts_> Orphi, yay
09:38:25 <quicksilver> Orphi: hmm
09:38:30 <quicksilver> Orphi: that sounds like bad design :P
09:38:45 <Orphi> quicksilver: maybe.
09:38:56 <Orphi> dcoutts_: ok, let's compile something...
09:39:00 <dcoutts_> Orphi, try the noughts & crosses demo
09:39:10 <Orphi> yeah, that's what I'm going for
09:39:51 <Orphi> w00t!
09:39:53 <Orphi> it works
09:39:53 <quicksilver> Orphi: I generally 'build up' my programs testing as I go
09:39:59 <quicksilver> Orphi: so I don't end up in that situation
09:40:15 <quicksilver> when it gets big, I split some parts into modules, etc
09:40:41 <Orphi> quicksilver: as with all things, the Hard Part is finding good ways to split the code...
09:40:58 <Orphi> that was true with Pascal, it's true in OOP, and it seems it's still true in functional programming ;)
09:41:17 <Cale> Orphi: for purposes of typechecking, it's possible to replace things with undefined
09:41:32 <Orphi> Cale: yeah - I only just discovered that trick
09:41:34 <Orphi> very useful
09:41:39 <quicksilver> Orphi: yes, true
09:42:07 <Orphi> Cale,quicksilver: the other problem is that Hugs seems to be hellishly buggy now :(
09:42:44 <quicksilver> I must admit I always use ghci
09:42:46 <glguy> I thought that Hugs was deprecated for #haskell now
09:43:47 <Orphi> did you guys here about the killer function I tried to create the other day?
09:44:12 <Orphi> work :: [(a -> Bool, [a] -> b)] -> [a] -> b
09:44:21 <Orphi> that ended out being about 6 lines
09:44:28 <Orphi> made my brain hurt :S
09:44:44 <sjanssen> Orphi: what's it do?
09:45:03 <Orphi> sjanssen: look closely at the type
09:45:19 <Orphi> it finds the shortest prefix of the 2nd arg that satisfies any predicate (easy)
09:45:32 <Orphi> and then applies the corresponding function to that sublist (hard)
09:45:45 <Syzygy-> Orphi: Which function?
09:45:56 <Syzygy-> It picks any predicate where it satisfies, and applies that?
09:46:07 <quicksilver> the function 'paired with' the winning predicate
09:46:15 <Orphi> quicksilver: indeed
09:46:18 <Syzygy-> Oh, right.
09:46:22 <glguy> a -> Bool doesn't take a prefix of [a]
09:46:29 <glguy> unless you mean the head of
09:46:37 <Orphi> glguy: well spotted
09:46:41 <quicksilver> glguy: I believe it's takeWhile segment
09:46:53 <Orphi> quicksilver: more like takeUntil, but yes
09:47:08 <Orphi> btw... takeUntil. not defined anywhere. hmm.
09:47:17 <yip> @type undefined
09:47:19 <lambdabot> forall a. a
09:47:20 <glguy> takeWhile (not . f)
09:47:30 <Orphi> well, yeah
09:47:57 <Orphi> hold on, let me find the code...
09:48:33 <icarroll> are you sure it's :: [(a -> Bool, [a] -> b)] -> [a] -> b
09:48:53 <icarroll> wouldn't [([a] -> Bool, [a] -> b)] -> [a] -> b make more sense?
09:48:59 <Orphi> I'm gonna past the running code
09:49:14 <glguy> Orphi: is [] the shortest possible prefix?
09:49:26 <Orphi> glguy: yes
09:50:15 <Orphi> ok guys: http://hpaste.org/713
09:50:49 <Orphi> that make any sense?
09:51:02 <sjanssen> Orphi: what's the point of the last function?
09:51:19 <Orphi> what, in the argument list?
09:51:21 <sjanssen> oh, the case where nothing satisfies?
09:51:29 <Orphi> it is applied if no predicate is ever satisfied
09:51:50 <Orphi> the input list is finite (but LARGE and EXPENSIVE)
09:52:08 <Orphi> I really want to use lazyness to compute as little of it as possible
09:52:17 <glguy> Orphi: what about on a tie
09:52:19 <Orphi> but... I couldn't find a more ellegant way than this
09:52:23 <glguy> Orphi: first in the tie wins?
09:52:27 <Orphi> yups
09:52:37 <Orphi> tie should be highly unlikely btw
09:52:42 <sjanssen> @type \xs ys -> [f x | x <- inits xs, (p, f) <- ys, p x]
09:52:44 <lambdabot> forall a t. [a] -> [([a] -> Bool, [a] -> t)] -> [t]
09:52:55 <icarroll> I still don't get the shortest prefix part
09:53:01 <glguy> Orphi: that doesn't much matter, however
09:53:10 <sjanssen> Orphi: that function produces all satisfying prefixes, by order of their length
09:53:24 <dcoutts_> Orphi, I've posted an update message on the Gtk2Hs site, thanks for helping diagnose the bug.
09:53:34 <Orphi> dcoutts_: np
09:53:37 <sjanssen> Orphi: you can use case on the result of the list comprehension to handle the zero matches case
09:53:41 <Orphi> dcoutts_: thanks for fixing it! :S
09:54:04 <dcoutts_> Orphi, np :-)
09:54:16 <Orphi> dcoutts_: was it just the Windoze version?
09:54:24 <dcoutts_> Orphi, yes
09:54:31 <Orphi> ah well ;)
09:54:46 <Orphi> now all I have to do is...learn the entire Gtk+ API :}
09:56:13 <sjanssen> glguy: is hpaste announcing down?
09:56:44 <glguy> !say maybe
09:56:45 <dcoutts_> sjanssen, yes, due to abuse
09:56:51 <glguy> abuse?
09:56:52 <Orphi> what *is* hpaste anouncing?
09:57:18 <sjanssen> Orphi: I think my annotation does the right thing (you should double check): http://hpaste.org/713#a1
09:57:50 <Orphi> *bends mind to fit*
09:57:51 <glguy> dcoutts_: so I should not rejoin the bot?
09:58:08 <Orphi> @type inits
09:58:11 <lambdabot> forall a. [a] -> [[a]]
09:58:20 <Orphi> > inits [1..12]
09:58:21 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
09:58:22 <sjanssen> > inits [1..5]
09:58:24 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
09:58:43 <dcoutts_> glguy, it's probably ok now, but we should work out a way so that only people in #haskell can make hpaste announce, perhaps my matching nicks & ip addresses or something
09:59:04 <dcoutts_> glguy, it was annoying to have people anonymously post abusive stuff with now way to identify them
09:59:10 <dcoutts_> now/no
09:59:14 <sjanssen> IP addresses would be annoying
09:59:37 <sjanssen> how about a user can say !cookie in channel
10:00:05 <sjanssen> and hpaste will respond in a personal message with a generated URL that allows announcing
10:00:44 <Orphi> sjanssen: ouch... ow, my head... x_x
10:01:13 <Orphi> sjanssen: so, take all prefixes of the list, find only ones which satisfy the predicate, return the first?
10:01:42 <sjanssen> Orphi: the list comprehension returns every match, but the case part only takes the first
10:01:51 <Orphi> right.
10:02:09 <Orphi> given the type of the predicate, should presumably be "p (first x)" ?
10:02:17 <Orphi> eeps! no - "p (last x)"
10:02:29 <hpaste>  glguy annotated "The monster function" with "first revision" at http://hpaste.org/713#a2
10:02:40 <sjanssen> Orphi: doesn't your function take an entire prefix?
10:02:56 <sjanssen> oh, no it doesn't
10:03:04 <Orphi> I ment the predicate only looks at ONE list element at a time
10:03:10 <Orphi> not the whole prefix
10:03:12 <glguy> Orphi: look what where I was going then
10:03:24 <Orphi> glguy: okes
10:03:28 <quicksilver> :t all
10:03:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:03:35 <glguy> :t find
10:03:36 <quicksilver> just need one of those I think
10:03:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:03:41 <glguy> you need find
10:03:44 <quicksilver> to make sjanssen's one work
10:04:09 <quicksilver> all p x
10:04:13 <quicksilver> instead of p x
10:04:21 <sjanssen> quicksilver: but that's gonna be sloooow
10:04:27 <glguy> no sense in rechecking every prefix!
10:04:28 <Orphi> quicksilver: ah yes, you're probably right.
10:04:31 <quicksilver> :t [f x | x <- inits xs, (p, f) <- rs, all p x]
10:04:34 <lambdabot> Not in scope: `xs'
10:04:34 <lambdabot>  
10:04:34 <lambdabot> <interactive>:1:32: Not in scope: `rs'
10:04:34 <glguy> just keep searching until one of the tests passes
10:04:42 <glguy> and the first time a test passes, that's the winner
10:04:54 <quicksilver> :t \xs rs d -> [f x | x <- inits xs, (p, f) <- rs, all p x]
10:04:57 <lambdabot> forall t a t1. [a] -> [(a -> Bool, [a] -> t1)] -> t -> [t1]
10:05:02 <glguy> if you are using inits, you are doing it wrong
10:05:24 <glguy> you are turning a search linear in the length of the search list to quadratic then
10:05:30 <Orphi> the guy's got a point... the list we're scanning could be several million items
10:05:38 <nmessenger> reverse . tails . reverse?
10:05:54 <glguy> my paste shows why you should use all or inits in this function
10:05:58 <glguy> shoud not!
10:06:04 <glguy> *
10:06:13 <hpaste>  sjanssen annotated "The monster function" with "with the correct type" at http://hpaste.org/713#a3
10:06:38 <emu> > tails [1..]
10:06:40 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:07:39 <Orphi> did anybody spot that my implementation turns the list backwards as it scans it?
10:09:07 <Orphi> at any rate, it looks like there isn't any much cleaner way to do it than what I already have. :(
10:10:08 <Orphi> @src find
10:10:09 <lambdabot> find p          = listToMaybe . filter p
10:10:18 <Orphi> @src listToMaybe
10:10:19 <lambdabot> listToMaybe []        =  Nothing
10:10:19 <lambdabot> listToMaybe (a:_)     =  Just a
10:10:28 <Syzygy-> > heads [1..]
10:10:29 <lambdabot>   Not in scope: `heads'
10:10:40 <Syzygy-> > inits [1..]
10:10:41 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
10:11:02 <mbishop> http://haskell.group.stumbleupon.com/
10:11:03 <mbishop> :o
10:11:04 <lambdabot> Title: SU: Haskell
10:11:24 <Orphi> it seems a few people stumbled across that one...
10:11:43 <nmessenger> :D "Is that a banana in your pocket, or are you just programming with catamorphisms?"
10:11:46 <bos31337> nice.
10:11:54 <Orphi> 0wned
10:12:04 <hpaste>  glguy annotated "The monster function" with "better still" at http://hpaste.org/713#a4
10:13:33 <Orphi> ouch... Haskell really hurts sometimes! lol
10:13:41 <Botje> @pl \(a,b)-> a b
10:13:42 <lambdabot> ap fst snd
10:13:53 <Botje> O_O
10:13:54 <Botje> that's neat.
10:13:59 <xerox> > app ((+2),1)
10:14:00 <lambdabot>  3
10:14:09 <xerox> (-;
10:14:14 <chessguy> @type app
10:14:16 <nmessenger> @index app
10:14:17 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
10:14:17 <lambdabot> Control.Arrow
10:14:22 <chessguy> figures
10:14:36 <Botje> app ne ap.
10:14:43 <Botje> @index ap
10:14:44 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
10:14:44 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
10:14:55 <Botje> bugger.
10:14:56 <chessguy> Botje, nobody said they were the same
10:14:57 <Botje> :t ap
10:14:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:15:04 <Botje> oh.
10:15:10 <Botje> myeah
10:15:25 <Botje> I have to switch off my #perl-induced reflexes sometimes.
10:15:27 <xerox> app = ap fst snd -- in instance ArrowApply (->).
10:15:32 <Botje> heh
10:15:34 <Botje> pretty
10:16:51 <Orphi> ok ppl, I have to go lay down or something, the monster function is killing my brain! haha
10:16:54 <Orphi> laterz
10:17:00 <xerox> Yeah, it's nice. If the circuit makes a function you can short-circuit it and get it applied.
10:20:32 <xerox> > foldr ((*** (+1)) . (+)) (0,0) [1..10]
10:20:33 <lambdabot>  (55,10)
10:20:49 <xerox> Trying to came up with an example but this other thing has born.
10:23:25 <chessguy> @pl \xs -> (sum xs, last xs)
10:23:25 <lambdabot> liftM2 (,) sum last
10:23:28 <chessguy> :)
10:23:28 <nmessenger> > foldr (\x -> (+x) *** (+1)) (0,0) [1..10]
10:23:30 <lambdabot>  (55,10)
10:23:36 <xerox> chessguy: it's actually "length".
10:23:52 <chessguy> > (liftM2 (,) sum length) [1..10]
10:23:53 <lambdabot>  (55,10)
10:24:00 <xerox> chessguy: I am not sure that fuse, though.
10:24:32 <chessguy> fuse shcmuse
10:24:50 <DynWind> apropos the Reader monad. Is it actually useful in many situations?
10:25:44 <DynWind> I can't seem to think of any applications for it
10:26:01 <DynWind> if you wanted to pass some global state (read-only), why not just pass a record?
10:26:18 <chessguy> i'm thinking of using it for passing a bunch of parameters to a long complicated action
10:26:24 <Cale> DynWind: It's good for local bindings.
10:26:37 <Cale> (in evaluators)
10:26:46 <Cale> @type local
10:26:48 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
10:27:40 <DynWind> hmm, it is a rather specialized monad, right?
10:28:14 <ddarius> DynWind: Using a reader monad allows you to ignore the fact that you are passing around stuff.
10:28:39 <DynWind> ok
10:28:59 <yip> man, compiling gtk2hs takes forever
10:29:04 <Cale> It's a very simple monad, and it's always a question whether you really don't want to just pass things around explicitly.
10:29:10 <dcoutts_> yip, yeah
10:29:23 <nmessenger> all the monads I've seen are "rather specialized".  That's what makes them useful.
10:29:37 <Cale> The "unwrapped" version of the reader monad, ((->) e), is rather handy for rewriting things into points-free form.
10:29:43 <yip> dcoutts_: i'm using --enable-profiling, will this take even longer?
10:29:54 <bos31337> more than 2x as long.
10:29:54 <DynWind> @type (->)
10:29:54 <dcoutts_> yip, about twice as long
10:29:56 <lambdabot> parse error on input `->'
10:30:02 <yip> oh man :'(
10:30:03 <Cale> @kind (->)
10:30:06 <lambdabot> ?? -> ? -> *
10:30:18 <Cale> (->) is a type constructor
10:30:23 <DynWind> ah
10:30:29 <yip> this is a big problem of ghc... i'm not really interested in profiling gtk2hs, but in order to profile my own code, i must have a profile version of gtk2hs
10:30:33 <Cale> ((->) e) is the type constructor for functions from e to some other type
10:30:43 <chessguy> bos, are you the one that wrote the intro to regexes?
10:30:44 <bos> yip: yes, it's annoying.
10:30:45 <DynWind> type constructors can have funky characters like that?
10:30:49 <Cale> yeah
10:30:49 <bos> chessguy: yep
10:30:57 <chessguy> bos++ very nice, thanks
10:30:58 <Cale> It's usually written infix
10:31:04 <Cale> For instance, in Int -> Char
10:31:05 <bos> np
10:31:06 <yip> bos: are they going to fix it?
10:31:12 <nmessenger> = (->) Int Char
10:31:15 <bos> yip: no idea.
10:31:16 <DynWind> Cale: ah :)
10:31:23 <chessguy> how much overhead does that library carry?
10:31:28 <dcoutts_> yip, that's because profiling changes the abi by adding extra data to every heap object. You don't want to pay that cost all the time.
10:31:57 <Cale> > join (*) 25
10:31:59 <yip> dcoutts: ok but i am not interseted in the gtk2hs heap objects, only my own
10:31:59 <lambdabot>  625
10:32:09 <chessguy> ?src join
10:32:10 <lambdabot> join x =  x >>= id
10:32:12 <dcoutts_> yip, but they're linked in memory
10:32:13 <Cale> > ap (,) (^2) 5
10:32:15 <lambdabot>  (5,25)
10:32:22 <chessguy> @type join
10:32:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:32:37 <chessguy> oh, that join. duh
10:32:40 <nmessenger> join (f :: e -> e -> a) :: (e -> a)
10:32:41 <Cale> so, in the specific case of ((->) e), we have
10:32:46 <Cale> ... that
10:32:50 <glguy> dcoutts_: do you know any of the abuse-paste ids?
10:32:50 <Cale> er
10:32:59 <Cale> join :: (e -> e -> a) -> e -> a
10:33:34 <DynWind> ok, I need to do some reading about this, thanks
10:33:35 <bos> chessguy: i hadn't tried to use the regex library before i wrote the tutorial. i was quite surprised by it:-)
10:33:50 <Cale> > sequence [(*2), (+1), (^2)] 5
10:33:58 <chessguy> bos, i'm wondering about the possibility of using it for pattern-matching bit-strings
10:33:59 <Cale> > Control.Monad.sequence [(*2), (+1), (^2)] 5
10:34:00 <lambdabot>  [10,6,25]
10:34:02 <yip> dcoutts_: but in C it's possible to link profile-able code with non-profile-able code
10:34:17 <chessguy> i'm not sure if it's possible or practical or not
10:34:24 <dcoutts_> yip, that doesn't change the heap structures so it measures different things
10:34:30 <bos> it's possible, but not practical.
10:34:31 <nmessenger> using the ((->) e) monad directly is mostly for showing off.  I think most people use Reader to abstract the craziness
10:34:34 <nmessenger> @src Reader
10:34:34 <lambdabot> Source not found. You speak an infinite deal of nothing
10:34:44 <Cale> nmessenger: I don't know about that
10:34:47 <chessguy> @source Reader
10:34:47 <lambdabot> Reader not available
10:34:51 <dcoutts_> glguy, you mean the paste numbers or the ids of people pasting?
10:34:56 <Cale> nmessenger: It's genuinely handy to have those things around.
10:35:02 <yip> dcoutts_: what if i am only interested in time profiling?
10:35:06 <nmessenger> newtype Reader e a = Reader { runReader :: e -> a }
10:35:10 <bos> chessguy: it's logically equivalent to this: http://sigfpe.blogspot.com/2007/02/modular-arithmetic-with-regular.html
10:35:12 <lambdabot> Title: A Neighborhood of Infinity: Modular arithmetic with regular expressions, http://tinyurl.com/2lovce
10:35:27 <chessguy> bos, hmm
10:35:33 <Cale> The wrapped reader monad is too heavy for lots of things.
10:35:47 <chessguy> ewww
10:35:55 <dcoutts_> yip, well, it's hard that's all I'm saying, not that it'd be impossible. You know, there are priorities.
10:35:58 <Cale> But it is good in interpreters.
10:36:18 <yip> dcoutts_: so the ghc team is working on this issue?
10:36:21 <Cale> The unwrapped Reader is good just for manipulating functions.
10:36:32 <glguy> 65.254.53.221 -- ip address of the hpaste abuser
10:36:32 <dcoutts_> yip, no, it's not a high priority.
10:36:54 <glguy> ERR
10:36:54 <glguy> shit
10:36:56 <glguy> that's the proxy
10:37:03 <yip> dcoutts_: is adding more optimizations a priority?
10:37:08 <dcoutts_> yip, yep
10:37:13 <yip> ok :)
10:37:20 <Cale> glguy: abuser?
10:37:25 <glguy> ("x-forwarded-for","129.12.249.211")
10:37:30 <glguy> hpaste abuser this morning
10:37:32 <glguy> there is the ip
10:38:08 <nmessenger> Cale: I've been thinking about TheOtherPrelude's overloading of (.) for fmap, and I'm not sure it's a spectacular idea.  (.) was chosen specifically for its resemblance to the compose operator.
10:38:24 <glguy> Go figure, it's from Amsterdam
10:38:29 <Cale> nmessenger: right, which is what it is in the case of ((->) e)
10:38:40 <Cale> (.) is still composition :)
10:38:48 <glguy> inetnum:        129.12.0.0 - 129.12.255.255
10:38:48 <glguy> netname:        UKC
10:38:48 <glguy> descr:          University of Kent at Canterbury
10:38:50 <Cale> It's just lots of other things as well.
10:38:52 <nmessenger> Cale: though I do like the idea of having an infix fmap, perhaps Control.Applicative's <$> to emphasize its "fancy application"
10:39:11 <dcoutts_> glguy, I guess matching a hpaste user's ip address to that of a #haskell user with the same nick is hard. Since we can't find the ip of everyone in #haskell.
10:39:14 <Cale> ((*2) `fmap` (+1)) 5
10:39:16 <Cale> > ((*2) `fmap` (+1)) 5
10:39:18 <lambdabot>  12
10:39:22 <dcoutts_> glguy, any ideas?
10:39:35 <Cale> see? :)
10:39:36 <glguy> dcoutts_: send a complaint to the university techincal contact?
10:39:56 <dcoutts_> glguy, well, in general there's nobody to complain to
10:40:07 <Cale> nmessenger: The idea is to have both (.) and map for functor application, and treat function composition as a special case of that.
10:40:12 <nmessenger> Cale: yes I understand, its just that (.) was chosen to look like the compose operator so (negate . [1,2,3]) shouldn't make sense notationally.
10:40:28 <shapr> glguy: What happened? abuser?
10:40:43 <Cale> It kind of makes sense from the point of view that lists are like functions from an initial prefix of the naturals to values.
10:40:44 <dcoutts_> morning shapr :-)
10:41:10 <shapr> Good morning dcoutts! How's the wheel treating you?
10:41:19 <dcoutts_> shapr, oh good good.
10:41:29 <nmessenger> Cale: kind of a weak argument, though.
10:41:58 <Cale> nmessenger: I think it's rather clear what's going on there, don't you? :)
10:42:10 <Cale> Once you know that (.) is functor application, anyway.
10:42:14 <nmessenger> > (*2) <$> [1,2,3]
10:42:14 <apfelmus> argl, how does ReadPreac work?
10:42:15 <lambdabot>  [2,4,6]
10:42:25 <apfelmus> * ReadPrec
10:42:36 <chessguy> (.) is fmap?
10:42:43 <Cale> chessguy: Yes it is :)
10:42:43 <nmessenger> @src (->) fmap
10:42:44 <lambdabot> fmap = (.)
10:43:07 <apfelmus> > let x = do { 1 <- readPrec; readPrec} :: ReadPrec Int in readPrec_to_S x 0 "12"
10:43:07 <lambdabot>   Not in scope: `readPrec_to_S'
10:43:15 <chessguy> > negate . [1..5]\
10:43:15 <lambdabot>  Parse error
10:43:17 <Cale> chessguy: though it's given a restricted type in the current prelude
10:43:17 <chessguy> > negate . [1..5]
10:43:18 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
10:43:23 <nmessenger> fmap :: (a -> b) -> (eReader a) -> (eReader b) where type eReader = ((->) e)
10:43:28 <Cale> so that code won't work right now
10:43:36 <chessguy> @type (.)
10:43:39 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:43:50 <Cale> @type fmap
10:43:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:43:59 <Cale> use f = ((->) e)
10:44:15 <Cale> So you get  fmap :: (a -> b) -> (e -> a) -> (e -> b)
10:44:28 <Cale> and look at that, it's the same as composition :)
10:45:33 <nmessenger> chessguy: though in Haskell as it stands, (.) is NOT fmap, (.) is a special case only for functions.
10:45:35 <chessguy> hmm, i don't really have a clue what you're talking about
10:45:50 <Cale> And of course it is! Functions (e -> a) are like giant indexed containers, where for each value of type e, they hold some value of type a
10:46:05 <chessguy> nmessenger, yeah, i meant in TheOtherPrelude
10:46:15 <Cale> Composition simply applies a function from a -> b to each of those values, which is just what fmap does.
10:46:29 * nmessenger should at least add instance Functor ((->) e) to TheOtherPrelude
10:46:33 <chessguy> i don't really like the functions-as-containers analogy. i understand it, but it just seems unweildy
10:46:43 <Cale> It's nice in this case.
10:46:44 <chessguy> ?spell unweildy
10:46:45 <lambdabot> unwieldy unwilled unwieldier unwed unveiled
10:46:54 <chessguy> *unwieldy
10:47:00 <nmessenger> :)
10:47:25 <Cale> Since the most common uses of fmap are in applying a function to all the elements of a container.
10:47:33 <DynWind> I wish I was as smart as lambdabot. It can do so many things!
10:47:46 <yip> what ever happened to MegaMonad?
10:47:48 <chessguy> @quote smart
10:47:49 <Cale> Another way to picture it is using the containers-as-functions analogy :)
10:47:49 <lambdabot> JaffaCake says: gcc is getting smarter, so we need to hit it with a bigger stick
10:48:01 <nmessenger> Cale: a proposal, perhaps rename liftM2, liftM3, etc. to map2, map3, by analogy with liftM = fmap
10:48:53 <Cale> nmessenger: probably sane
10:48:57 <nmessenger> > liftM2 (+) [1,2] [3,4] -- map2 (+) [1,2] [3,4]
10:48:59 <lambdabot>  [4,5,5,6]
10:49:12 <jyasskin> That's zipWith, isn't it?
10:49:14 <Cale> though it's sort of different from zipWith
10:49:26 <nmessenger> jyasskin: nope, it's product
10:49:26 <Cale> jyasskin: no
10:49:28 <jyasskin> oh, right
10:49:37 <nmessenger> > zipWith (+) [1,2] [3,4]
10:49:38 <lambdabot>  [4,6]
10:49:53 <Cale> zipWith just takes the "diagonal"
10:49:59 <nmessenger> > unZipList $ liftA2 (+) (ZipList [1,2]) (ZipList [3,4])
10:50:00 <lambdabot>   Not in scope: `unZipList'
10:50:05 <nmessenger> > getZipList $ liftA2 (+) (ZipList [1,2]) (ZipList [3,4])
10:50:06 <lambdabot>  [4,6]
10:50:11 <nmessenger> :D
10:50:33 <jyasskin> > liftA2 (+) [1,2] [3,4]
10:50:35 <lambdabot>  [4,5,5,6]
10:50:51 <nmessenger> liftA2 = liftM2
10:51:04 <bd_> :t liftA2
10:51:06 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:51:12 <nmessenger> (with different contexts, since Monad doesn't subclass Applicative)
10:51:37 <jyasskin> Yeah, just wanted to see that I have no intuition about the list monad. ;)
10:51:54 <nmessenger> Cale: do you know if ZipList is a monad?  What would join look like?
10:52:57 <Cale> nmessenger: it's not
10:53:12 <Cale> It's the canonical example of an applicative functor which isn't a monad.
10:55:57 <glen_quagmire> oh i thought it was #hashkell
10:56:25 <nmessenger> @topic-tell #hashkell
10:56:25 <lambdabot> Do not know that channel
10:56:53 <glen_quagmire> i've been saying about hashkell with sh sound
10:57:18 <glen_quagmire> didn't know haskell rhymes with pascal
10:57:31 <chessguy> it doesn't
10:57:39 <nmessenger> eh /= ae
10:57:45 <chessguy> pascal has emphasis on the second syllable, haskell on the first
10:58:01 <chessguy> AFAIK
10:58:03 <nmessenger> chessguy: oh?  I'd always stressed the second
10:58:05 <glen_quagmire> someone upload how to pronounce it
10:58:08 <dmhouse> You can either say 'Haskull', with emphasis on the first syllable, or 'Hask-ell', with emphasis on the second.
10:58:24 <dmhouse> The first is good to distinguish it from Pascal.
10:58:39 <dmhouse> There's a soundbite of SPJ saying how to pronounce Haskell somewhere.
10:58:49 <nmessenger> "Why are you pronouncing Pascal so strangely?" :D
10:59:10 <glen_quagmire> it should be haSHkell and no more confusion
10:59:31 <glen_quagmire> we hash functions. so hash-kell
10:59:52 <dmhouse> Well it's named after Haskell Curry.
11:00:03 <dmhouse> And 'hashing functions'? What's that?
11:00:06 <chessguy> then people will just think you're saying pascal, but you've had a few too many
11:01:31 <glen_quagmire> no diea. i was trolling
11:01:41 <glen_quagmire> i'm gonna learn haskell though
11:01:58 <nmessenger> glen_quagmire: how much do you know?  Have you read any tutorials?
11:02:19 <nmessenger> @wiki Haskell_in_5_steps
11:02:20 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
11:02:22 <DynWind> 'I was trolling' is that a meta-troll? :D
11:02:34 <mbishop> self referencial trolls?
11:02:46 <glen_quagmire> no. i just found this  link: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html  and it uses haskell
11:02:48 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
11:03:11 <nmessenger> transparent trolling = saying that you're a troll = not trolling = paradox!
11:03:47 <nmessenger> the 5 steps things takes you through getting a compiler/interpreter and starting out, check it out.
11:04:11 <glen_quagmire> thanks
11:07:43 <nmessenger> > ZipList [1,2,3]
11:07:44 <lambdabot>   add an instance declaration for (Show (ZipList t))
11:07:58 <nmessenger> why isn't ZipList in Show?
11:12:50 <apfelmus> > read "- - - - 1" :: Int
11:12:52 <lambdabot>  1
11:13:23 <apfelmus> > (- - - -1) + (- - - 1) + (- - 1) + (- 1)
11:13:23 <lambdabot>  Parse error
11:13:45 <nmessenger> interesting
11:16:50 <chessguy> > (negate negate negate negate 1) + (negate negate negate 1) + (negate negate 1) + (negate 1)
11:16:51 <lambdabot>   add an instance declaration for (Num (a -> a))
11:17:11 <nmessenger> negate negate doesn't type
11:17:15 <Vq^> (read::Int) seems to be quite forgiving
11:17:19 <chessguy> > (negate $ negate $ negate $ negate 1) + (negate $ negate $ negate 1) + (negate $ negate 1) + (negate 1)
11:17:21 <sjanssen> @type negate negate
11:17:21 <lambdabot>  0
11:17:23 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a
11:17:30 <chessguy> :)
11:17:34 <sjanssen> nmessenger: sure it does :)
11:17:35 <chessguy> @type negate
11:17:38 <lambdabot> forall a. (Num a) => a -> a
11:17:45 <glguy> > 713 - 679 + 1
11:17:47 <lambdabot>  35
11:17:51 <nmessenger> sjanssen: not without Num (a -> b) :P
11:18:06 <glguy> 10 pastes have had to be deleted off the front page of hpaste
11:18:27 <chessguy> on that note...real work calls :(
11:18:37 <nmessenger> glguy: total ever, or just today?
11:19:03 <glguy> there are 10 holes on the front page, which should cntain the last 25
11:19:17 <glguy> it contains the last 35 now that the garbage has been removed
11:20:12 <nmessenger> so ?offset= just counts by id number?
11:20:31 <glguy> nope
11:20:43 <glguy> offset=1 skips the first 25 non-deleted pastes
11:22:04 <nmessenger> glguy: what kinda garbage was it?
11:23:27 <glguy> nmessenger: the vulgar pastes and the fizzbuzz in c++ and ruby and whatnot
11:23:40 <glguy> and the ones without nicks and titles
11:28:48 <bew> is there a tiff lib for haskell, or a wrapper for libtiff?
11:30:00 <CosmicRay> bew: the gtk stuff may have that
11:30:33 <bew> that's an idea, but a little overkill
11:34:04 <glguy> last time:
11:37:01 <mbishop> I'm 7 reddit karma points away from 300 :)
11:37:34 <DynWind> :P
11:37:46 <cjay> "older" doesn't work now
11:37:55 <glguy> oh?
11:38:07 <glguy> bah, ok
11:38:19 <glguy> the happs library on hpaste.org is older than I thought
11:39:57 <shapr> glguy: Want me to update kakapo?
11:40:03 <glguy> shapr: no no no :)
11:40:18 <glguy> that would *really* break the live version of hpaste
11:40:29 <glguy> I'm going to sync everything up soon
11:40:32 <glguy> but not just yet
11:40:43 <shapr> heh, ok
11:40:50 <tibbe> @pl f x y = y x
11:40:51 <lambdabot> f = flip id
11:41:20 <glguy> hpaste.org has "Average top position" of 18 for "scary things to do" on google
11:41:29 * glguy is toying with the webmaster tools
11:42:19 <Botje> "I could go on about monadic contexts and encapsulation and how once you enter a monad you dont come out but I wont, because Id like you to continue reading." .. heh :)
11:43:01 * shapr boings cheerfully
11:43:05 <shapr> Yay virtual pair programming!
11:43:07 * nmessenger just finished reading that post.  'Tis awesome!
11:43:16 <nmessenger> :D  ""Before proceeding please allow yourself to consider the possibility that IO in Haskell might not be difficult.""
11:43:33 <dskloet> @pl f xy = y x
11:43:33 <lambdabot> f = const (y x)
11:43:45 <tibbe> dskloet, yay!
11:43:46 <dskloet> @pl f x y = y x
11:43:46 <lambdabot> f = flip id
11:44:10 <jfoutz> @type flip
11:44:12 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:44:15 <dskloet> @pl something
11:44:16 <lambdabot> something
11:44:24 <tibbe> heh
11:44:25 <mauke> @. djinn type flip
11:44:28 <lambdabot> f a b c = a c b
11:44:29 <nmessenger> dskloet: ($) = id, so flip ($) is slightly more transparent
11:44:36 <nmessenger> "flipped apply"
11:44:55 <dskloet> why not just flip? id doesn't do anything, does it?
11:45:09 <kaol> nmessenger: URL please? /me is curious
11:45:36 <nmessenger> http://blogs.nubgames.com/code/?p=22
11:45:37 <lambdabot> Title: Nub Games  Haskell IO for Imperative Programmers
11:45:50 <tibbe> @type flip id
11:45:53 <lambdabot> forall b c. b -> (b -> c) -> c
11:45:56 <tibbe> @type flip
11:45:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:46:32 <shapr> glguy: Oh, I got the next bill for kakapo, and there weren't any added bandwidth charges, so I guess it's all okay.
11:48:10 <glguy> > flip id 4 succ
11:48:11 <lambdabot>  5
11:48:16 <glguy> > flip 4 succ
11:48:18 <lambdabot>        add an instance declaration for (Num (a -> (a1 -> a1) -> c))
11:49:23 <shapr> Lemmih has possessed my computer!
11:50:31 <bos> @hoogle Int32
11:50:32 <lambdabot> Data.Int.Int32 :: data Int32
11:51:08 <nmessenger> dskloet: f $ x = f x; so x `flippedapply` f = f x where flippedapply = flip ($)
11:51:58 <tibbe> > [1..]
11:51:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:53:06 <nmessenger> ($) takes a function and an argument, flip ($) takes an argument and a function, since flip just flips argument order
11:54:52 <Botje> Hello, I'm here for an argument?
11:55:03 <nmessenger> Botje: no you're not!
11:55:11 <Botje> Yes I am!
11:55:19 <nmessenger> liar!
11:55:37 <Botje> Look, i'm here to have an argument. Is this the right room or not?
11:55:48 <bos> @type succ
11:55:50 <lambdabot> forall a. (Enum a) => a -> a
11:56:04 <nmessenger> oh, this is abuse, arguments are down the hall
11:56:10 <Botje> oh. thanks!
11:56:24 <Botje> (monty python)++
11:56:34 <nmessenger> python)-- monty_python++
11:56:50 <kaol> @karma python)
11:56:51 <lambdabot> python) has a karma of 0
11:57:10 <Botje> oh.
11:57:18 <Botje> doesn't \bot support that syntax?
11:58:29 <xerox> Nope, but you can patch it (-:
11:58:36 <xerox> Err... her.
11:58:42 * nmessenger hypocritically points at the monty python xkcd
11:58:58 <Botje> I don't like fibbling with womany-bits, especially once they've been through ghc.
11:59:07 <Botje> haven't even read it yet
12:00:05 <nmessenger> http://xkcd.com/c16.html
12:00:06 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
12:02:27 <ndm> @seen dons
12:02:27 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 8h 22m 17s ago.
12:03:10 <ndm> @tell dons i fixed the "GHC is buggy" behaviour, but it was the expected behaviour when you reported it - entirely because GHC treats the semantics of error as pretty random
12:03:10 <lambdabot> Consider it noted.
12:03:24 <astrolabe> Perhaps dons isn't really Austrailian.  Perhaps he's an owl.
12:04:48 <Saizan> ?where binary
12:04:48 <lambdabot> http://darcs.haskell.org/binary
12:07:20 <shapr> Hey, can I use two cpus with runghc Setup.hs build?
12:07:37 <shapr> I vaguely remember JaffaCake telling me that it could work, but I'm not sure if I'm misremembering.
12:07:40 <ndm> @tell dons I have no idea what that guy is on about, when you hit open you browse to where the file is and it loads it - dead simple, really obvious. I've replied telling him to email haskell-cafe
12:07:40 <lambdabot> Consider it noted.
12:07:56 <allbery_b> GHCRTS envar?
12:08:24 <shapr> allbery_b: I thought it was something like that, or +RTS -cpu 2 -RTS but some other param/arg
12:09:09 <allbery_b> GHCRTS=-N2, I think
12:09:50 <tibbe> @localtyme
12:09:54 <lambdabot> Local time for tibbe is Wed Feb 28 21:07:10
12:10:48 <shapr> allbery_b: Thanks, we'll try it.
12:12:30 <hpaste>  fasta pasted "Referential transparancy? Where?" at http://hpaste.org/715
12:13:01 <fasta> ^^ seems a bit like a Heisenbug to me.
12:14:57 <bos> @hoogle ap
12:14:58 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
12:14:58 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
12:14:58 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
12:16:20 <Botje> fasta: that code is absolutely positively fugly.
12:17:01 <fasta> Botje: Suggestions?
12:17:36 <Botje> well
12:17:46 <Botje> not really, no :)
12:18:00 <fasta> I had a version with multiple function names, before.
12:18:08 <Botje> split stuff out into versions, i'd say
12:18:15 <fasta> I don't think the logic is any easier.
12:18:20 <fasta> "versions"?
12:18:25 <fasta> You mean cases?
12:18:43 <fasta> Yep, that's what I had before, but at some point I considered it a bad idea.
12:19:10 <Botje> functions, even ..
12:19:12 <fasta> Botje: can you explain the output?
12:19:14 <Botje> i'm a bit confused today
12:19:38 <fasta> Botje: since it seems "obvious" that what happens, should never happen.
12:20:08 <Botje> myeah, odd.
12:20:16 <Botje> have you tried printing the list with Debug.Trace?
12:20:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/716
12:21:26 <fasta> Botje: I didn't because the situation is "impossible".
12:21:38 <fasta> Botje: I will do now.
12:24:17 <hpaste>  mux annotated "(no title)" with "(no title)" at http://hpaste.org/716#a1
12:24:36 <CosmicRay> @hoogle absolute
12:24:37 <lambdabot> System.IO.AbsoluteSeek :: SeekMode
12:24:37 <lambdabot> Network.URI.isAbsoluteURI :: String -> Bool
12:24:37 <lambdabot> Network.URI.parseabsoluteURI :: String -> Maybe URI
12:24:56 <CosmicRay> bah.  is there truly no function in the ghc libraries to transform a filename into an absolute path?
12:25:47 <fasta> CosmicRay: Not that I know of.
12:30:04 <mux> @join #haskell.fr
12:30:04 <lambdabot> Not enough privileges
12:30:09 <mux> I guess
12:30:21 <mux> would it be possible to get lambdabot on #haskell.fr ?
12:30:31 <mux> we frogs sorely miss it there
12:30:50 <allbery_b> not sure theey're addingh channels until dons finishes the move
12:30:56 <allbery_b> pretend I can type :>
12:30:58 * mbishop is hungry for some frog legs
12:31:07 <mux> hmm, this is so good
12:31:16 <mux> it's been a while since I last ate some
12:31:31 <mux> allbery_b: what do you mean by "the move"?
12:31:44 <fasta> Botje: I added trace, but it seems that that value is evaluated _multiple_ times... another wth...
12:31:59 <allbery_b> dons is busy bringing up a multicore AMD monster which will, among other things, be the new home of LB
12:32:12 <fasta> Botje: I added at the top in in the lower if expression
12:32:22 <fasta> s/in in/in
12:32:24 <mux> allbery_b: oh, cool
12:33:31 <fasta> Botje: another "fun" thing is that every such evaluation shows a different list.
12:35:03 <Botje> your functions getting called multiple times, maybe?
12:38:31 <CosmicRay> is there a tutorial somewhere on the new regexp library in ghc 6.6?
12:39:48 <t4> isn't the one at planet haskell for 6.6?
12:40:10 <fasta> Botje: no
12:40:22 <fasta> Botje: Hmm, I mean yes :)
12:40:52 <fasta> Botje: it calls itself
12:41:34 <CosmicRay> ah, nice.
12:41:43 <njd> @users
12:41:44 <lambdabot> Maximum users seen in #haskell: 332, currently: 320 (96.4%), active: 55 (17.2%)
12:42:05 <fasta> Botje: thanks
12:44:09 <fasta> It appears that I temporarily am breaking the invariant. I.e. the test for validity only applies on the first call.
12:51:07 <mm> can mutual exclusive classes be defined in haskell?
12:53:15 <fasta> mm: what is a mutual exclusive class?
12:54:19 <Orphi> wait... why are there... two... dcoutts?
12:54:21 <mm> I want to convince the compiler that if something is instance of class A it cannot be an instance of class B
12:55:04 <mauke> but it can!
12:55:51 <mm> ... fasta: In order to avoid a "duplicate instance" problem
12:56:45 <fasta> mm: An instance expresses that a type is a member of a family of types. Relations between these are not in Haskell.
12:57:23 <CosmicRay> wow, haskell is going to kick ass as a shell scripting language.
12:57:31 <fasta> mm: But you might be able to define a class MutualExclusive A B
12:57:33 <CosmicRay> this is exciting.
12:58:28 <fasta> mm: That would be a run-time solution then, not compile time
12:58:28 <Orphi> I'm still hoping to make Haskell into an awesom scene construction language ;)
12:59:30 <Moony> is there a (standard) function to get the highest number from a list?
12:59:34 <mm> fasta: a pity, because i need it typechecking-runtime
12:59:41 <earthy> moony: max ? :)
12:59:43 <mauke> @type maximum
12:59:45 <lambdabot> forall a. (Ord a) => [a] -> a
12:59:53 <fasta> mm: You mean at compile-time?
13:00:19 <mm> fasta: yes.
13:02:09 <mm> fasta: So i guess there also is no negation of the 'instance'-relation
13:02:43 <fasta> mm: You can use TH to do this, I think.
13:03:04 <fasta> mm: You can lookup all instances and check whether the arbitrary relation you are interested in holds.
13:03:36 <fasta> mm: This is a high-level description of something that is most-likely a lot of work.
13:03:43 <jyasskin> I wonder if functional dependencies could do something like that: class Exclusive a r | a -> r; instance Class1 a => Exclusive a (); instance Class2 b => Exclusive b ()
13:04:00 <Orphi> @list
13:04:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:04:12 <jyasskin> But then those 2 instances are probably outlawed, rather than the instances of Class1 and Class2.
13:04:24 <Orphi> ...ok, that mades no sense at all.
13:04:33 <glguy> This seems quite telling! http://cod.quisition.com/results/1/111/
13:04:35 <lambdabot> Title: Cats or Dogs
13:05:06 <Orphi> "that mades no sense at all"... man, that's almost a meta-joke! :S
13:05:35 <glguy> You can guess almost all of these
13:13:32 <mm> fasta: are typeclass relations implemented somewhere else than in haskell?
13:13:53 <fasta> mm: I don't know
13:19:31 <cjeris> glguy: what is perhaps more telling is the result of visiting the root http://cod.quisition.com/
13:19:33 <lambdabot> Title: Cats or Dogs
13:19:47 <cjeris> oh, nemmind.  (I got "Unhandled Exception")
13:21:44 <glguy> cjeris: those linked polls from what I pasted paint a bleak picture of mysql users
13:22:11 <glguy> or maybe it's just that newbs that don't use either have mysql name recognition
13:25:15 <glguy> If anyone else beside from fasta thinks that they might try telling me that legally I have to delete their pastes for them (if they might want to do that in the future), please spare me the warning and refrain from using hpaste at all
13:25:47 <shapr> glguy: er wtf?
13:25:55 <glguy> yeah, I don't know
13:26:05 <alexj> glguy: you really should put a T&C in hpaste.
13:26:11 <glguy> apparently
13:26:50 <glguy> got any good "your paste goes into the public domain" boilerplate?
13:27:15 <nmessenger> lisppaste's?
13:27:27 <glguy> "fear comprehensively?"
13:27:37 <SamB> glguy: you could say "unless otherwise noted in the text"...
13:28:06 <glguy> I'm not interested in people putting licenses on their pastes
13:28:07 * nmessenger adds compile-time vs. runtime typechecking to cars or dogs
13:28:31 <nmessenger> cats*
13:28:36 <SamB> what if I were hacking something GPL'd?
13:28:46 <glguy> then ... don't paste it I guess
13:28:58 <SamB> thats not a nice restriction
13:29:38 <ADEpt> evening
13:29:49 <ADEpt> are there any haskell libraries for peeking inside zip files?
13:30:56 <Orphi> any knowledgable gtk2hs peeps around?
13:30:56 <alexj> glguy: use the t&c from a discussion site like slashdot? alternatively, who owns the content of : http://tunes.org/~nef/logs/haskell/%22,%22History
13:31:09 <glguy> "Lisppaste pastes can be made by anyone at any time. Imagine a fearsomely comprehensive disclaimer of liability. Now fear, comprehensively."
13:31:15 <JohnMeacham> if I were to give myself advice now about writing jhc. I think the main one would be 'integrate unboxed values and tuples from the start' and in particular, 'make unboxed tuples a built in part of the syntax'
13:32:23 <cjeris> nmessenger: how do you add things?
13:32:40 <nmessenger> cjeris: I came up randomly after I voted a bunch
13:32:48 <nmessenger> It*
13:33:06 <tp76> xb
13:33:23 <nmessenger> eh?
13:33:26 <tp76> Uhm, that was supposed to be C-x-b.  Sorry ;-)
13:33:28 <mm> fasta ... thanks for the help. i will just read http://arkiv.netbsd.se/?ml=haskell-cafe&a=2006-09&m=2582681
13:33:31 <lambdabot> Title: archive.netbsd.se
13:33:49 <SamB> glguy: how about you just put something about not pasting things that should not be seen by anyone and everyone?
13:33:59 <nmessenger> "Return of the Jedi  or Return of the King" :D
13:35:16 <Orphi> *sigh* this isn't going smoothly...
13:35:54 <Orphi> yesterday some guy on a newsgroup I inhabit posted a little function plotter program he wrote
13:36:15 <Orphi> so I thought it would be amusing to implement something 100x better in Haskell in 20 seconds flat, to prove how cool Haskell is
13:36:23 <Orphi> ....but...it's...not...happening :(
13:36:47 <SamB> heh
13:37:27 <alexj> anyone know what happenned to ECT?
13:37:38 <Orphi> first the Windoze installation package for Gtk2hs was damaged
13:37:39 <alexj> eternal compatibility in theory?
13:37:48 <Orphi> then I finally got that fixed...
13:37:56 <Orphi> ...but how I need to learn the entire Gtk+ API :S
13:38:05 <Orphi> *now
13:38:09 <SamB> it was a bad theory?
13:38:47 <Orphi> I was going to use Glade... but apparently there isn't a Windoze binary
13:38:52 <Orphi> just source tarballs x_x
13:39:15 <yip> the new glade 3 is pretty nice
13:39:35 <Orphi> so I hear
13:39:42 <Orphi> doesn't help me much if I can't run it, eh? ;)
13:40:34 <Orphi> hmm... I guess I'll have to reboot using a Live Linux CD, run Glade to produce the GUI XML, then reboot to Windoze and develop the rest of the app... that could work.
13:42:12 <Orphi> if you use Gtk2hs, does the computer you run the executable on have to have Gtk installed?
13:44:03 <yip> Orphi: i think so
13:44:11 <Orphi> right, ok.
13:44:32 <Orphi> I guess I figured as much; the GIMP requires you to install it.
13:45:02 <yip> yep. or gaim
13:45:08 <Orphi> or Ethereal
13:45:32 <yip> it doesn't seem to be any trouble for those progs. so it shouldn't be a problem for any haskell prog
13:45:32 <Orphi> unfortunately, the only Gtk2hs tutorial I can find assumes you're using Glade...
13:45:59 <Orphi> if you're on Linux, the Gtk libs are practically guaranteed to be installed; I'm thinking about Windoze
13:47:54 <Orphi> eeewww ick... looking at the C API for Gtk is just not fun :S
13:48:25 <Orphi> ah heck, I'm tired, I'll sort this out some other time...
13:48:29 <yip> it's actually not too bad
13:48:37 <Orphi> yeah... if you can read C
13:48:45 <yip> gtk2hs seems to mirror it pretty closely
13:49:21 <Orphi> the silly thing is, the app I want to make is graphically trivial
13:49:26 <Orphi> just a text box and a function plot
13:49:32 <Orphi> but I can't figure out how...
13:50:02 <Orphi> I even tried using the SOE interface to it - but that doesn't appear to work properly
13:50:10 <TSC> I think the GTK tutorial should cover something that simple
13:50:19 <Orphi> it does - IF YOU USE GLADE
13:51:13 <Orphi> I think ultimately that's what I'll have to do - use Glade on a supported platform, and then copy the generated XML description.
13:51:19 <Orphi> it's the only way I'm going to get anything done.
13:52:17 <Orphi> ah well, for tonight, I think it's time for sleep.
13:52:19 <Orphi> laterz.
14:13:20 * glguy tries to remember if design-pattern-bashing goes over well on reddit
14:14:55 <yip> mm.... singleton
14:15:11 <glguy> that one is obviously a dirty work around
14:15:27 <glguy> there are some that I think are harder to argue about
14:16:29 <dibblego> the standard at reddit is getting pretty bad
14:16:47 <glguy> Oh, when I say "reddit" I mean programming.reddit
14:16:52 <dibblego> yeah me too
14:16:56 <glguy> oh ok :)
14:17:05 <glguy> because reddit.com is no better than digg :)
14:19:05 <Saizan> hey, i've found out of haskell because of digg! :)
14:21:50 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/718
14:22:16 <jberg> hi. im having a little problem with the paste above. the data structures and function type can not be changed, since it's part of some old assignment code that im trying to do..
14:22:32 <glguy> swear to god people, put your nick or a title on it
14:22:58 <xerox> glguy: have the app ask for it again, if empty (-:
14:23:11 <dibblego> glguy, force it
14:23:13 <glguy> xerox: I don't want people to type garbage in the field because it is requiring it
14:23:18 <glguy> I want them to type their nick in there
14:23:35 <jberg> ok sorry
14:23:57 <dibblego> glguy, make it a nick that is currently in the channel
14:24:16 <glguy> until I get Protocols.IRC working
14:24:25 <glguy> I don't have a good way for the bot to talk to the webserver
14:24:25 <jberg> anyway im sure this is a real simple problem, i just suck
14:25:08 <glguy> I can do some blockingIO call
14:25:13 <glguy> but it starts to turn into a hack
14:25:21 <glguy> (more so than the bot already is)
14:25:30 <glguy> as the bot is kind of grafted on
14:25:37 <Saizan> lc pt (Node voxel octs)      | isInVoxel pt voxel =  <-- does this mean that the leaf you are searching ofr is in octs?
14:25:57 <jberg> yep
14:25:57 <nmessenger> glguy: if you allow them to have empty nicks, you delete them.  If you force them to put in a nick, some will put garbage, so you'll have to delete them anyway, but some will put their nicks, and you won't :)
14:26:15 <nmessenger> It's a win-tie situation :)
14:26:35 <glguy> they *both* require some work on my part :-p
14:26:43 <nmessenger> true :D
14:26:50 <glguy> and I can't make any important changes to the code from work
14:26:57 <glguy> I don't have my files here
14:27:05 <Saizan> jberg: so you have to recurse lc on octs and take the result
14:27:10 <glguy> but work is when it bothers me most :)
14:27:11 <nmessenger> do you agree with my argument?
14:27:18 <glguy> nmessenger: I know I need to fix it
14:27:28 <glguy> I shouldn't have it though :)
14:27:31 <glguy> to*
14:27:49 <Cale> jberg: er, did you make another paste? That link seems dead.
14:28:02 <Saizan> something like head . map (lc pt) $ octs
14:28:21 <jberg> cale, no
14:28:30 <jberg> Saizan: ah thanks
14:28:31 <SamB> glguy: what kinda editor do you use that you can't ssh in?
14:28:49 <glguy> SamB: my computer at home is turned off
14:28:57 <glguy> SamB: which is where I do most hpaste stuff
14:29:15 <SamB> oh
14:29:38 <glguy> But if you have an editor that does remote wakeup across the Internet, I'd be sold!
14:29:51 <SamB> I'm afraid not
14:30:10 <SamB> my computer is serving as a router right now, though, so it never goes off...
14:30:19 <glguy> that machine is actually hosting a vmware instance
14:30:22 <glguy> where I do the work
14:30:52 <glguy> also, hpaste.org has an older version of the happs library
14:30:57 <glguy> which the new hpaste code doesn't use
14:31:16 <glguy> too much hassle to do from work
14:31:51 <SamB> oh
14:31:54 <Saizan> jberg: btw, you don't need pass around pt, it's just in scope from the toplevel pattern matching
14:32:06 <Saizan> s/pass/to pass/
14:32:07 <dibblego> don't you use darcs anyway?
14:32:26 <glguy> dibblego: I'd have to darcs get a ton of libraries that I don't use for C# dev at work
14:32:35 <dibblego> oh right
14:32:44 <glguy> and I like to test before I push
14:34:38 <glguy> There , I added a warning to the top with the 5K limit warning
14:36:19 <jberg> Saizan: yeah good poing
14:36:23 <jberg> point*
14:36:27 <bos> @hoogle select
14:36:27 <lambdabot> Text.Html.select :: Html -> Html
14:36:28 <lambdabot> Text.Html.selected :: HtmlAttr
14:36:33 <hpaste>  glguy annotated "is this in the prelude?" with "using standard functions" at http://hpaste.org/688#a1
14:38:34 <nmessenger> I have precisely that function in my "accumulated simple functions" module.
14:39:15 <bos> @pl \f xs -> and . zipWith f xs $ tail xs
14:39:15 <lambdabot> (`ap` tail) . ((and .) .) . zipWith
14:39:24 <bos> yum.
14:39:48 <bos> @type (`ap` tail) . ((and .) .) . zipWith
14:39:49 <nmessenger> @pl \f xs -> zipWith f xs (tail xs)
14:39:50 <lambdabot> forall b. (b -> b -> Bool) -> [b] -> Bool
14:39:51 <lambdabot> (`ap` tail) . zipWith
14:40:30 <Botje> heh.
14:40:38 <nmessenger> @type and . (`ap` tail) . zipWith
14:40:41 <lambdabot>     Couldn't match expected type `[Bool]'
14:40:41 <lambdabot>            against inferred type `[b] -> [c]'
14:40:50 <nmessenger> @type (`ap` tail) . zipWith
14:40:52 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
14:41:04 <nmessenger> @type (and.) . (`ap` tail) . zipWith
14:41:06 <lambdabot> forall b. (b -> b -> Bool) -> [b] -> Bool
14:41:27 <nmessenger> less evil
14:41:51 <mbishop> only 2 more reddit karma points to 300 :o
14:41:55 <nmessenger> > ((and.) . (`ap` tail) . zipWith) (<=) [1..6]
14:41:56 <lambdabot>  True
14:42:03 <mbishop> @karma mbishop
14:42:04 <lambdabot> You have a karma of 1
14:42:06 <nmessenger> > ((and.) . (`ap` tail) . zipWith) (<=) [1,2,5,3,4,6]
14:42:07 <lambdabot>  False
14:42:14 <mbishop> lambdabot: lend me that karma :)
14:42:26 <Saizan> is /msg lambdabot @run broken?
14:42:39 <nmessenger> not for me
14:43:00 <nmessenger> did you use a Control.Monad function?
14:43:12 <Saizan> yes
14:43:19 <nmessenger> qualified?
14:43:26 <Saizan> no
14:43:42 <Saizan> mapM (\x -> if even x then [x] else []) [1..10]
14:43:55 <nmessenger> > Control.Monad.mapM (\x -> if even x then [x] else []) [1..10]
14:43:57 <lambdabot>  []
14:44:24 <Saizan> oh ok, the Data.Foldable/Traversable issue?
14:44:50 <nmessenger> I don't know of that issue, so I couldn't say
14:45:34 <nmessenger> > (=<<) (\x -> if even x then [x] else []) [1..10]
14:45:35 <lambdabot>  [2,4,6,8,10]
14:46:29 <xerox> ?src [] (>>=)
14:46:30 <lambdabot> m >>= k     = foldr ((++) . k) [] m
14:46:34 <xerox> (aka concatMap)
14:46:44 <nmessenger> or paMtacnoc
14:47:01 <nmessenger> (flipped)
14:49:39 <nmessenger> concatMap f = foldr ((++) . f) [] where (++) = foldr ((.) . (:)) id -- foldr ftw!
14:50:13 <Saizan> ?src msum
14:50:14 <lambdabot> msum =  foldr mplus mzero
14:50:22 <glguy> ?type (and .) . (flip ap tail . zipWith)
14:50:24 <lambdabot> forall b. (b -> b -> Bool) -> [b] -> Bool
14:50:30 <glguy> ?type (and .) . flip ap tail . zipWith
14:50:33 <lambdabot> forall b. (b -> b -> Bool) -> [b] -> Bool
14:50:54 <nmessenger> well yes, since (flip ap tail) = (`ap` tail) :P
14:51:24 <glguy> I didn't read through the backlog
14:51:29 <glguy> is that what you typed?
14:51:37 <nmessenger> yerp
14:51:44 <glguy> I was doing some hand plin in hugs
14:52:51 <nmessenger> well, I asked @pl for (`ap` tail) . zipWith
14:53:14 <nmessenger> and dropped in (and .)
14:57:04 <glguy> ?type (. ap zip tail) . all . uncurry
14:57:07 <lambdabot> forall b. (b -> b -> Bool) -> [b] -> Bool
14:58:03 <nmessenger> :D
14:58:08 <nmessenger> glguy++
14:58:53 <glguy> ?karma
14:58:54 <lambdabot> You have a karma of 48
14:58:57 <glguy> huzzah!
14:59:00 <glguy> thanks :)
14:59:42 <mbishop> heh nice karma you got there
14:59:42 <nmessenger> huzzah!
14:59:47 * mbishop tries to steal some
14:59:58 <peti> Hi.
15:00:16 <nmessenger> Greetings earthling!
15:00:29 <glguy> peti: ..lo
15:00:48 <eshear> so I have a question about how you'd best write something in Haskell. I want to write a function that gets a collection of objects from a table in a database. In lisp, I'd write something like (find (> posts 2)). In python, something like find("posts > 2" ) or find(posts = gt(2)). What would I write in Haskell?
15:01:20 <glguy> :t find
15:01:23 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:01:26 <nmessenger> posts :: [(Int, blah)] ?
15:01:36 <glguy> > find (> 2) [1..10]
15:01:37 <lambdabot>  Just 3
15:01:47 <ddarius> bugger
15:01:52 <glguy> > filter (> 2) [1..10]
15:01:54 <lambdabot>  [3,4,5,6,7,8,9,10]
15:01:56 <Saizan> posts is a field of a record-like, i suppose
15:02:00 <eshear> right
15:02:14 <nmessenger> find ((>2) . posts)
15:02:31 <nmessenger> or find (\record -> posts record > 2)
15:02:33 <glguy> or: find (\thing -> posts thing > 2)
15:02:41 <glguy> :-p
15:02:41 <nmessenger> :}
15:02:43 <eshear> hehe, those are the same!
15:03:07 <eshear> and find would compile that lambda down to SQL somehow?
15:03:16 <nmessenger> er, no
15:03:19 <nmessenger> @type find
15:03:19 <eshear> hm
15:03:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:03:24 <eshear> ah
15:03:29 <eshear> maybe I used the wrong word
15:03:33 <nmessenger> find takes an ordinary list
15:03:35 <eshear> find_object_in_database_table
15:03:51 <Saizan> eshear, have you seen haskelldb?
15:03:52 <dons> moin
15:03:53 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:03:55 <dons> ?users
15:03:55 <glguy> eshear: just like in lisp, that depends on what library you are using
15:03:55 <lambdabot> Maximum users seen in #haskell: 332, currently: 304 (91.6%), active: 50 (16.4%)
15:03:55 <nmessenger> there are a couple database libraries in Haskell, but I've not used 'em.
15:04:01 <eshear> no, is that the mapping layer?
15:04:09 <eshear> a mapping layer, I should say
15:04:33 <Saizan> i think so, never used it personally
15:04:39 <Saizan> ?where haskelldb
15:04:40 <lambdabot> http://haskelldb.sourceforge.net/
15:05:57 <nmessenger> http://haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
15:05:59 <lambdabot> Title: Libraries and tools/Database interfaces - HaskellWiki, http://tinyurl.com/3xb8dd
15:06:01 <Saizan> http://haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces <-- heh
15:06:03 <lambdabot> Title: Libraries and tools/Database interfaces - HaskellWiki, http://tinyurl.com/3xb8dd
15:07:00 <nmessenger> @karma george
15:07:00 <lambdabot> george has a karma of -8
15:07:32 <eshear> ah, cool
15:07:36 <eshear> yeah this is what I was asking about
15:08:09 <jfoutz> @karma jfoutz
15:08:10 <lambdabot> You have a karma of 0
15:09:14 <bd_> @karma
15:09:15 <lambdabot> You have a karma of 3
15:09:33 <bd_> george--++
15:09:37 <bd_> @karma george
15:09:38 <lambdabot> george has a karma of -8
15:09:41 <bd_> @karma george--
15:09:41 <lambdabot> george-- has a karma of 1
15:09:43 <bd_> @karma george
15:09:44 <lambdabot> george has a karma of -8
15:09:57 <astrolabe> Who is george?
15:10:36 <astrolabe> What is she, that all our swains adore her?
15:11:08 <nmessenger> astrolabe: "*** george-- quit ("Leaving" )", so I thought: "huh, must not want any karma :)"
15:12:57 <astrolabe> heh.  That'll teach him I suppoe
15:28:07 <sorear> can the current Yhc Bytecode-API be used to *read* bytecode?
15:29:30 <dancor> how do you convert number bases
15:29:36 <dancor> i need octal -> decimal
15:29:55 <dancor> nothing is prelude?
15:31:20 <Cale> @type readIntAtBase
15:31:22 <lambdabot> Not in scope: `readIntAtBase'
15:31:31 <Cale> er, no
15:31:36 <Cale> @type readInt
15:31:39 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
15:31:44 <Cale> @type readOct
15:31:47 <lambdabot> forall a. (Num a) => String -> [(a, String)]
15:32:37 <Cale> > readOct "70341"
15:32:39 <lambdabot>  [(28897,"")]
15:32:44 <Cale> > readOct "70341 hello"
15:32:46 <lambdabot>  [(28897," hello")]
15:33:27 <dcoutts> @tell Orphi I think it's quite easy to deploy gtk apps, you just bundle all the dlls. I'll do a demo and write some instructions some time.
15:33:27 <lambdabot> Consider it noted.
15:34:53 <dcoutts> @tell Orphi btw you can get installers for glade on windows, see gladewin32.sf.net
15:34:54 <lambdabot> Consider it noted.
15:46:03 <zbrown> What does it mean when a type definition says something like "distXYZ :: Pos -> Pos -> Double" ?
15:46:15 <zbrown> I understand if it says like "Pos -> Double"
15:46:22 <zbrown> but what does the arrow mean when its in there twice
15:46:24 <nmessenger> give it a Pos, it'll give a (Pos -> Double)
15:46:25 <sorear> -> is right associative
15:46:32 <sorear> Pos -> (Pos -> Double)
15:46:34 <sorear> OR
15:46:34 <nmessenger> give it another Pos, it'll give a Double
15:46:45 <sorear> distXYZ takes two args.
15:46:59 <zbrown> sorear: ok thats what i was looking for
15:46:59 <sorear> there are two ways to look at this, you have to pick one :(
15:47:06 <zbrown> I like the secon
15:47:08 <zbrown> second*
15:47:18 <zbrown> it means more to me coming from a C background lol
15:47:25 <zbrown> err C/Java/Python rahter
15:47:32 <nmessenger> I've confidence your opinion will change :)
15:48:27 <zbrown> nmessenger: well I already like Haskell better than any of those languages just from what littleI know now.
15:48:59 <siti> :)
15:49:11 <nmessenger> UNRELATEDLY!  (Num a => a -> (Char->Maybe Int) -> ReadS a) would seems a clearer type for readInt, instead of a seperate (Char -> Bool) and (Char -> Int)
15:49:13 <zbrown> im a math major, haskell tends to make more sense to me :-D
15:49:30 <zbrown> or well math/cs major
15:50:05 <siti> I dislike math, but enjoy haskell for some reason :)
15:50:18 <yip> => is not haskell98?
15:50:24 <sorear> sure it is
15:50:30 <nmessenger> typeclass implication
15:50:37 <yip> forall a. is not haskell98?
15:50:41 <nmessenger> nope
15:50:45 <sorear> correct.
15:50:59 <yip> but it's supported in all existing haskell compilers, right?
15:51:05 <sorear> nowhere close
15:51:07 <Pseudonym> CS is just maths + toolsmithing.
15:51:19 <Pseudonym> Some people lean more towards one end than the other.
15:51:27 <falconair_> is there an editor for haskell which has some sort of 'intellisense' ability? (popup suggestions)
15:51:34 <sorear> @check const True ((+) :: Num a => a -> a -> a) -- check only spports h98
15:51:36 <lambdabot>  OK, passed 500 tests.
15:51:42 <sorear> @check const True ((+) :: forall a. Num a => a -> a -> a) -- check only spports h98
15:51:42 <lambdabot>  Parse error
15:51:53 <siti> haskell is like math 2.0 ;)
15:52:03 <sorear> falconair_: what does intellisense do?
15:52:09 <sorear> falconair_: we have shim
15:52:21 <nmessenger> name completion and type hints
15:52:28 <sorear> falconair_: C-c TAB --> list of completions of identifier at point, with types
15:52:29 <falconair_> yes, name completion :)
15:52:32 <mbishop> intellisense is a wannabe emacs
15:52:40 * sorear <3 dabbrev
15:52:42 <nmessenger> there's VisualHaskell
15:52:55 <siti> intellisense (MS) = autocompletion (everyone else)
15:53:03 <nmessenger> = Visual Studio + embedded GHC
15:53:17 <falconair_> actually i'm a user of eclipse for java, but i couldn't think of the name
15:53:20 <sorear> there's SHIM = Emacs + GHC
15:53:26 <sorear> falconair_: look at EclipseFP
15:53:43 <siti> it does no have autocompletion though
15:53:50 <siti> it's a decent editor
15:53:53 <falconair_> so emacs understands haskell syntax and types and suggests applicable functions/types?
15:53:56 <sorear> falconair_: I use emacs+shim+haskellmode, but EclipseFP and VsHaskell are supposed to be good
15:54:02 <falconair_> what about this Yim
15:54:06 <sorear> not quite
15:54:10 <falconair_> yi
15:54:16 <sorear> Yi == nvi clone
15:54:21 <siti> it has very preliminary autocompletion in the latest svn
15:54:25 <sorear> it doesn't even do block selection
15:54:29 <falconair_> what does shim do?
15:54:31 <sorear> siti: Yi uses svn!?
15:54:34 <dons> sorear: yes it does :)
15:54:47 <siti> I am talking about eclipse fp :p
15:54:47 <dons> at least jyp added block selection
15:55:08 <brad____> a question: if i have a haskell function that takes a list as its arg, is it automatically assumed i am in the list monad? or is it more accurate to say that the list monad is only induced by a do block or by using functions from the Monad module (filterM, etc)?
15:55:30 <sorear> falconair_: a few new commands.  complete identifier in scope (no type analysis), when you save it background-typechecks, ...
15:56:00 <nmessenger> brad____: the list monad is just the functions (:[]), map, and concat.  You can use those on any list, so I suppose you could say you're in the list monad.
15:56:11 <sorear> brad____: it's not really correct to talk about being 'in a monad'.  the do-notation is overloaded to work at all monadic types.
15:56:39 <sorear> it's just syntax sugar for a set of overloaded functions named return and (>>=)
15:56:57 <sorear> overloaded just the way + works at Int, Integer, Double, etc
15:56:58 <brad____> hmmm, i am a little confused, then what is the fundamental diff to using filter or filterM on this function arg?
15:57:05 <norpan> nothing
15:57:07 <falconair_> did any of you get a chance to look at a research editor called Citrus (I pasted a link here a couple of days ago)?  with haskell's type information, it should make for an amazing combination
15:57:11 <dons> :t filterM
15:57:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:57:18 <nmessenger> To say you are "in a monad" usually just means you're using a do block that desugars to binds of the list monad type
15:57:34 <dons> > filterM (\c -> if c == 'x' then return True else return False) "haxekslx"
15:57:35 <lambdabot>   add an instance declaration for (Show (m [Char]))
15:57:47 <dons> > filterM (\c -> if c == 'x' then return True else return False) ["haxekslx"]
15:57:48 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
15:58:04 <dons> brad____: well, the types are different for one, m [a] v [a]
15:58:19 <dons> so you can't just drop filter in when you want a monadic filter
15:58:37 <brad____> dons: why would i want a monadic filter?
15:58:42 <brad____> sorry for being pedantic :(
15:58:47 <yip> dons: hey, you remember that gameboy emulator?
15:58:49 <dons> if you were filtering based on the result of some IO action
15:58:51 <dons> for exapmle
15:58:53 <brad____> AH
15:58:56 <brad____> okay
15:59:08 <dons> filterM doesFileExist listoffiles
15:59:13 <nmessenger> to say you are "in the list monad" would probably mean you are using the version of filterM where the 'm' type variable = []
15:59:14 <brad____> so the "inducement" might be a requirement from somewhere else in my program....
15:59:46 <dons> basically, you use filterM if the predicate you use to filter on is monadic
15:59:58 <brad____> its about being able to do list operations when employing monads (?)
16:00:01 <brad____> i think i see now
16:00:04 <dons> now, if your predicate used the list monad, then you could use filterM in the list monad. but that's weird
16:00:08 <nmessenger> i.e. results in an IO action, a list, a Maybe thing, etc.
16:00:14 <dons> no need for monads to hack lists
16:00:22 <dons> > filter (/='x') "haxdkexlel"
16:00:24 <lambdabot>  "hadkelel"
16:00:30 <sjanssen_> yip: are you still hacking on that emulator?
16:00:50 <brad____> hmmm, i get it now, i really need the mythical 500 page "ultimate haskell" book that beats these items into me!
16:00:53 <yip> sjanssen_: i'm about to put a darcs repos online, i'm hoping that people will help me optimize it so it will run in realtime
16:01:04 <brad____> thanks so much!
16:01:23 <dons> @remember dcoutts Apparently that's only 200x faster than the faster of two common python serialisation libs, so we've got some way to go yet.
16:01:24 <lambdabot> Done.
16:01:31 <brad____> as usual, this group is very helpful!
16:01:35 <dcoutts> dons, heh ;-)
16:01:36 <dons> e try
16:01:37 <nmessenger> > filterM (\v -> [v/='x',v/='e']) "haxdkexlel"
16:01:38 <lambdabot>  ["hadkelel","hadkelel","hadkell","hadkell","hadkelel","hadkelel","hadkell","...
16:01:38 <dons> ^w
16:01:52 <dons> as we say, the list monad is weird :)
16:02:13 <dons> brad left too soon
16:02:22 <dons> nat/yahoo/ * ?
16:02:38 <yip> dons: remember you asked for a darcs repos?
16:02:42 <dons> right.
16:02:50 <yip> well you are about to get one =]
16:03:10 <sorear> dons: I notice in your recent make just patch that you've completely bypassed the per-test general rule.  is this intended to become the norm?
16:03:12 <dons> good! is everyone about to get one?
16:03:29 <dons> sorear: hmm? the 'run' rule?
16:03:35 <yip> dons: whether they like it or not
16:03:46 <dons> its an alternative to the general rule.
16:04:00 <dons> for the case we want to update the .db file with just a specific new value
16:04:03 <sorear> dons: the one on top, I'd be tempted to call it 'all' :) in the */*/Makefile
16:04:25 <dons> there's no rule in */*/Makefile
16:04:26 <sorear> but make just doesn't use that rule, it goes directly to bin/bench
16:04:35 <sorear> OK footer.mk ;)
16:04:35 <yip> dons: according to the profile of a very short run, total alloc = 24,892,045,460 bytes
16:04:41 <sorear> mm.
16:04:46 <sorear> not bad
16:04:53 <dons> yes, it duplicates 'run'
16:05:10 <sorear> only an order of magnitude worse than what I regularly achieve
16:05:12 <yip> i don't understand
16:06:16 <dons> neither do i
16:07:36 <sorear> I can't believe it.  I just started a line of haskell with 'void '.
16:07:44 <sorear> usually it's the other way around
16:10:07 <LordBrain> Are existential types a feature i should try to avoid using or are they just groovy? what's the down side to existential types?
16:10:23 <Pseudonym> Question.  Does anyone have a more-than-two-core machine with GHC 6.6 on it that they would be willing to let me run some tests on?
16:10:33 <Pseudonym> It's for a JFP paper.
16:10:43 <Pseudonym> Well, not submitted yet, obviously, since tests not run yet.
16:11:10 <sorear> Pseudonym: probably dons
16:11:10 <Cale> LordBrain: They solve a very specific concern.
16:11:17 <sorear> dons: ping?
16:11:24 <SamB> MORE than two?
16:11:34 <Cale> LordBrain: and one which you can always write in another way, but sometimes it's handy to have them.
16:11:40 <Pseudonym> Yes.
16:11:43 <sorear> Pseudonym: dons has 16 cores and not much to do with them
16:11:46 <SamB> sorear: nono
16:11:48 <Pseudonym> Excellent!
16:11:50 <Pseudonym> 16 cores == good
16:11:55 <Pseudonym> The more the merrier.
16:12:00 <SamB> foo :: blah -> blah -> Void
16:12:06 <Pseudonym> We're trying to work out how scalable a certain data structure is.
16:12:10 <Pseudonym> Using STM.
16:12:18 * SamB waits for someone to point out how silly that is
16:12:53 <Igloo> You'll only find out how scalable GHC is when working with that datastructure and its STM implementation, of course
16:13:00 <Pseudonym> Of course.
16:13:05 <sorear> SamB: a load avg of 15 is like having a whole idle computer!
16:13:32 <SamB> sorear: I meant, that type signature
16:14:24 <sorear> SamB: I never typed it. why did you direct the sig at me?
16:14:41 <sorear> SamB: from a CH standpoint it is isomorphic to foo -> Void
16:14:44 <sorear> ie Not foo
16:15:16 <SamB> I mean, clearly it should be foo :: blah -> blah -> IO Void
16:15:28 <sorear> ?
16:15:41 <sorear> why do I care?
16:15:49 <bd_> Void = ()?
16:16:04 <SamB> hmm... actually that can never return...
16:16:05 <sorear> <SamB> sorear: nono -- ?
16:16:20 <SamB> sorear: I you mentioned starting a line of Haskell with "void" ;-P
16:16:31 <sorear> @ty let x = x in x
16:16:33 <lambdabot> forall t. t
16:16:44 <sorear> SamB: oh yeah.  It All Makes Sense Now.
16:16:51 <SamB> sorear: funny
16:16:55 <SamB> it was supposed to be nonsense
16:17:03 <sorear> SamB: and anyway I'm using unsafePerformIO to write this function :)
16:17:39 <nmessenger> bd_: nope, Void is the empty type.  It has no values other than _|_.
16:18:44 <dons> Pseudonym: yeah, we have a 16 core box for data parallel haskell hacking. email my supervisor and you can probably get access. or, if you want me to run the tests, send me the url of the src
16:19:09 <Pseudonym> dons: Thanks.  It's not finished yet.  And I don't mind if you run them.
16:19:21 <Pseudonym> Oh, we'll need a few Gb of disk space, too.
16:19:42 <Pseudonym> Hang on, I'll take this private.
16:19:48 <sorear> Pseudonym: it is amd64 - will this matter?
16:19:54 <Pseudonym> Nope, that's fine.
16:20:00 <Pseudonym> There's only a small amount of FFI.
16:20:15 <Pseudonym> I'll explain in haskell-overflow.
16:20:31 <sorear> I suppose I don't need to listen?
16:20:38 <Pseudonym> Up to you.
16:21:04 <mux> dons: hey! any way we can get lambdabot on #haskell.fr ?
16:21:16 <sorear> @join #haskell.fr
16:21:19 <sorear> is it there?
16:21:22 <sorear> @seen lambdabot
16:21:23 <lambdabot> Yes, I'm here. I'm in #haskell.fr, #happs, #haskell.es, #montevideolibre, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #
16:21:23 <lambdabot> haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
16:21:26 <mux> now yes :)
16:21:28 <mux> thanks!
16:21:30 <siti> :D
16:21:42 <mux> lambdas for frogz!
16:21:52 <sorear> @part #haskell.hac07
16:21:57 <zbrown> lambdabot: FTW!
16:22:02 <sorear> is that chan still used at all?
16:22:21 <zbrown> there's like 3 ppl
16:22:33 <sorear> they haven't spoken in weeks
16:24:10 <augustss_> @users
16:24:11 <lambdabot> Maximum users seen in #haskell: 332, currently: 290 (87.3%), active: 50 (17.2%)
16:24:59 <sorear> hello augustss_!
16:25:28 <augustss_> hola sorear!
16:37:41 <ddarius> PLUGIN Quote? cpp magic or somesuch?
16:38:00 <sorear> scripts/BotPP.hs
16:38:28 <sorear> muahahaha
16:38:50 <hyrax42> ?hoogle Random a => IO [a]
16:38:50 <lambdabot> Control.Concurrent.Chan.getChanContents :: Chan a -> IO [a]
16:38:50 <lambdabot> Control.Concurrent.nmergeIO :: [[a]] -> IO [a]
16:38:50 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
16:39:00 <sorear> hmm.
16:39:07 <hyrax42> ?docs System.Random
16:39:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
16:39:12 <sorear> @ty randomsIO
16:39:14 <lambdabot> Not in scope: `randomsIO'
16:39:21 <sorear> @ty getStdRandom randoms
16:39:23 <lambdabot>     Couldn't match expected type `(a, StdGen)'
16:39:24 <lambdabot>            against inferred type `[a1]'
16:39:37 <sorear> @ty fmap randoms getStdGen
16:39:40 <lambdabot> forall a. (Random a) => IO [a]
16:39:47 <hyrax42> sorear: ta
16:39:50 <hyrax42> nks
16:39:54 <sorear> h?
16:39:55 <sorear>  :)
16:40:03 <hyrax42> and for that
16:40:59 <nmessenger> getStdGen will use the current global generator, replace with newStdGen to update it as well.
16:42:09 <hyrax42> nmessenger: you mean it will yield same values in repeated calls?
16:42:53 <nmessenger> (do let rs = fmap randoms getStdGen; xs <- rs; ys <- rs; ...) xs and ys will be the same
16:43:03 <augustss_> ugh, i really need to write some new generators for haskell.  the ones we have are not great
16:43:29 <dons> augustss_: so any word on hbc?
16:43:47 <dons> augustss_: its the only compiler i haven't got on my amd64, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
16:43:48 <lambdabot> Title: nobench: Haskell implementation shootout
16:43:55 <augustss_> i've been internetless at home this whole week
16:44:00 <nmessenger> (do let rs = fmap randoms getStdGen; xs <- rs; y <- randomIO; zs <- rs; ...) xs and zs will NOT be the same, since the call to randomIO updates it
16:44:33 <augustss_> dons: so i need to write a new code generator.  haven't done that in 10 years :)
16:45:37 <augustss_> can't let ghc get away with being in the lead on just about all benchmarks on amd64
16:45:46 <dons> right!
16:45:55 <dons> though we'd also need an lml binary for amd64 too?
16:46:10 <augustss_> of course, that's step 1
16:46:25 <augustss_> porting is a bit involved
16:46:30 <dons> can we translate lml to haskell in step 0, then compile with ghc? :)
16:47:03 <augustss_> there was an lml-to-haskell translator that did 95% of the job
16:47:30 <dons> oh, nice.
16:47:45 <augustss_> yeah, but the last 5% are a pain
16:48:46 <sorear> how about letting lml2haskell do the first 95%, and having augustss finish the job?
16:48:53 <augustss_> nah, if i get around to it, i'll just port it the good old way.  write a code generator, cross compile to assembly, move assembly files across, ...
16:49:21 <augustss_> sorear: if i was serious about keeping hbc alive, maybe
16:49:53 <augustss_> i'm a little bit surprised hbc is still faster on as many programs as it is
16:50:09 <dons> i think just a plan for keeping the src around would be good.
16:50:18 <dons> getting it into a repo on darcs.haskell.org
16:50:31 <dons> and maybe some more docs on getting and using it.
16:50:48 <sorear> does it make smaller binaries than ghc? :)
16:50:50 <zbrown> hmmm
16:51:05 <augustss_> sorear: most likely
16:51:19 * zbrown likes haskell
16:51:30 * augustss_ likes haskell too
16:51:30 <sorear> yay!    lblz <- atomicModifyIORef nextLabel (join (,) . (+1))
16:51:30 <sorear>  
16:52:27 <zbrown> hmmm this will definitelky be suitable for my project :)
16:52:46 <dons> what kind of project, zbrown ?
16:53:12 <zbrown> dons: Modeling of infectious vectors, specifically in this case Malaria
16:53:22 <zbrown> research at a University
16:53:24 <dons> oh, that sounds interesting.
16:53:51 <dons> so you have some nice math and a simulator to write?
16:54:07 <zbrown> I want a language thats more suited towards mathematical expression than C is since in C i have to use a crapload of libraries
16:54:30 <Pseudonym> You're modelling the spread over a population?  Or inside a person?
16:54:40 <zbrown> dons: the heavy calculation will be done in haskell, the modeling will be done in NetLogo, which I have a prelim model up already at http://zacbrown.org/netlogo-malaria
16:54:42 <lambdabot> Title: malaria
16:54:43 <zbrown> Pseudonym: through population
16:54:51 <Pseudonym> Right.
16:55:26 <zbrown> Pseudonym: the goal is to develop a better mathematical formula for the model, there's a fairly decent 'macro' formula, but no good 'micro' formula
16:55:36 * Pseudonym nods
16:55:59 <zbrown> NetLogo is not suited for mathematical expression so I need something else to analyze data
16:56:02 <dons> seems a reasonable choice to use haskell then. i've used it for some polymer chemistry simulation, and it worked rather well
16:56:23 <zbrown> I'd prefer to stay away from things like MATLAB since they're proprietary and I don't want to be bound to using an IDE (so to speak)
16:56:34 <Pseudonym> Yeah, I've done a bit of fluid dynamics in it, and it works very nicely.
16:56:42 <dons> and in the end you can write a paper on using haskell for this, and submit it to the haskell workshop :)
16:57:13 <zbrown> C was proposed for its speed, but that wasn't suitable either since I didn't want to have to incorporate 2.4 million libraries just to get the mathematical expression correct
16:57:17 <Pseudonym> Though one of these days I'm planning to try implementing multigrid methods as comonads.
16:57:28 <zbrown> Someone in #math pointed me in this direction so here i am :)
16:57:35 <dons> zbrown: yes. and if you need it, you can use haskell to generate the C code.
16:58:13 <zbrown> dons: shouldn't be of great worry, there's a supercomputer at the medical school's campus that the simulation will get run on if it becomes to daunting for a typical desktop
16:58:13 <dons> let us know how you go, and if you run into any troubles
16:58:40 <dons> note you can also consider using, say, multicore processing, in haskell
16:58:43 <zbrown> dons: i will :) this will be a long project, its only just starting in terms of the simulation, and im the only programmer :)
16:58:49 <dons> so if you can parallelise the core work
16:58:58 <zbrown> dons: ah ill have to look into that
16:59:12 <zbrown> we have a new Power Mac with the dual quadcore cpu's in it
16:59:27 <sorear> @remember zbrown C was proposed for its speed, but that wasn't suitable either since I didn't want to have to incorporate 2.4 million libraries just to get the mathematical expression correct
16:59:28 <lambdabot> Done.
16:59:41 <zbrown> lol
16:59:46 <dons> so for our polymer chemistry simulator we use 4 different approaches, a single core haskell model, a haskell model running on a 20 node cluster, a multicore haskell model, and a single core haskell model that generates C code at runtime
16:59:58 <zbrown> interesting
17:00:08 <dons> so you can consider a number of techniques for squeezing out more speed
17:00:28 <zbrown> definitely will look into it
17:00:58 <zbrown> Oh and we also considered Fortran... but Fortran was just so... Fortranish. lol
17:01:06 <dons> depending on how far you get, the very use of haskell to such an interesting domain would make an interesting paper for the haskell community (for some conference like the haskell workshop or PADL)
17:01:11 <dons> just something to keep in mind ;)
17:01:44 <zbrown> dons: hehe, well I'm a freshman at UMiami now and I'm the only person working in Functional Programming here or rather beginning work in it.
17:01:52 <sorear> zbrown: how does a Haskell DSL for writing fortran sound :P
17:01:58 <zbrown> And its likely that if this takes off as I hope it does, this will become my researhc :)
17:02:09 <zbrown> sorear: define 'DSL'?
17:02:10 <dons> cool! welcome aboard then
17:02:16 <ddarius> www.sac.org
17:02:27 <sorear> @hdict DSL -- should exist :)
17:02:27 <lambdabot> Supported dictionary-lookup commands:
17:02:27 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
17:02:27 <lambdabot> Use "dict-help [cmd...]" for more.
17:02:29 <ddarius> or is it a .com?
17:02:33 <Pseudonym> @foldoc DSL
17:02:35 <lambdabot> *** "dsl" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
17:02:36 <lambdabot> DSL
17:02:36 <lambdabot>  
17:02:36 <lambdabot>         1. <communications> {Digital Subscriber Line}.
17:02:36 <lambdabot>  
17:02:37 <lambdabot> [6 @more lines]
17:02:39 <Pseudonym> @more
17:02:40 <lambdabot>         2. <language> {Digital Simulation Language}.
17:02:41 <lambdabot>  
17:02:43 <ddarius> @google Single-Assignment C
17:02:43 <lambdabot>         3. <language> {Denotational Semantics Language}.
17:02:46 <lambdabot>  
17:02:47 <lambdabot>         (1996-10-13)
17:02:49 <dons> zbrown: a DSL is a domain specific language. in haskell we often write 'embedded' domain specific languages as library directly in haskell
17:02:50 <lambdabot>  
17:02:51 <Pseudonym> Good heavens.
17:02:53 <lambdabot> http://www.sac-home.org/
17:02:53 <lambdabot> Title: SAC-Home [Home]
17:02:58 <zbrown> dons: oic
17:02:59 <Pseudonym> Three definitions, all of them irrelevant.
17:03:22 <LordBrain> lol
17:03:24 <ddarius> "Denotational Semantics Language"?  How could that be there and I never heard of it?
17:03:50 <zbrown> dons: ya I asked around everywhere and apparently everyone here pretty much uses C
17:03:54 <Pseudonym> Probably because a) it's archaic, b) it's obsolete, and c) we've all dropped denotational semantics for categorical semantics.
17:04:04 * sorear is developing a dsl for assembly language
17:04:19 <ddarius> Also known as a compiler.
17:04:21 <dons> zbrown: hopefully you'll be able to at least produce working code faster than your C rivals
17:04:30 <dons> not having to deal with segfaults should be one major benefit
17:04:44 <zbrown> dons: well most of my C rivals don't work in near as daunting a field of programming as I do.
17:04:57 <ddarius> Pseudonym: There aren't too many categorical semanticians.
17:05:15 <LordBrain> hmm it would be nice if there was a grad program in florida for functional programming
17:05:17 <zbrown> dons: I'll be honest, I've hacked with C for 4 or 5 years now and I still HATE touching memory.
17:05:21 * sorear is preparing to write a just in time superspecializing optimizer in Haskell.
17:05:29 <Pseudonym> zbrown: You've definitely come to the right place, then.
17:05:48 <sorear> zbrown: sure you can access memory in Haskell!  but only if you want.
17:05:56 <zbrown> Java == bloated, slow, and unsuitable for any type of scientific programming so haskell seemed appropriate since python isn't near fast enough nor expressive enough for what I want to do.
17:06:02 <zbrown> sorear: well I don't want to ;)
17:06:05 * ddarius merely wants a reasonably quick JIT compiler to machine code.
17:06:27 <LordBrain> i agree that haskell is definitely your best option zbrown.
17:06:30 <dons> btw guys, i've started a wiki page on the best-of-the-best blog articles out there, on haskell.  http://haskell.org/haskellwiki/Blog_articles
17:06:31 <lambdabot> Title: Blog articles - HaskellWiki
17:06:40 <sorear> ddarius: quick? runtime | optimization time?
17:06:41 <dons> if there's some article you particularly like, please add it and categorise it
17:07:01 <ddarius> sorear: It generates passable code quickly.
17:07:09 <dons> so far i just picked a few of the top rated ones fromreddit. but we know of a lot of others
17:07:13 * sorear expects to have the most difficulty with the optimizing x86 codegen, hl optimizations will be easier
17:07:28 <ddarius> sorear: So, e.g. a graph-coloring register allocator is out.
17:08:01 <nmessenger> dons: I notice all the links are via reddit :)
17:08:02 <augustss_> ddarius: you can approximate optimal register allocation pretty fast
17:08:19 <Pseudonym> Even a stack-based register allocator is pretty good.
17:08:24 <zbrown> dons: any books you recommend for dealing with mathematical programming in haskell?
17:08:55 <ddarius> dons: Any reason you aren't giving direct links?
17:09:03 <dons> hmm. there's 'The Haskell Road to Maths and Logic'
17:09:11 <SamB> augustss_: yeah you just put everything on the stack
17:09:12 <dons> ddarius: i was going to dereference them. please feeel free to do so
17:09:31 <dons> nmessenger: i started by finding the 'top'rated articles on reddit, as my initial filter
17:09:35 <LordBrain> anyone here read 'the fun of programming' ?
17:09:38 <augustss_> dons: but 'The Haskell Road ...' isn't really about traditional mathematical programming
17:09:40 <dons> then i was too lazy to dereference the links :)
17:09:45 <dons> no. so hm..
17:10:12 <dons> zbrown: we have a bit of a maths page here, http://haskell.org/haskellwiki/Haskell_and_mathematics
17:10:13 <lambdabot> Title: Haskell and mathematics - HaskellWiki
17:10:23 <Pseudonym> But really, zbrown, the main thing is to know how to program in Haskell.
17:10:49 <ddarius> Unfortunately, I'm about to start some spaghetti and am too tired to figure out and write a simple lambdabot module.  It will be done soon though.
17:10:59 <yip> how can i put a darcs repos on a web server that doesn't have darcs installed?
17:11:04 <SamB> zbrown: the other part is to know mathematics
17:11:10 <dons> yip, scp?
17:11:48 <yip> dons: just copy the entire repository?
17:11:56 <zbrown> SamB: well I try ;). I'm a math and computer science major so i like to think im familiar
17:11:58 <dons> yep.
17:12:10 <yip> dons: hm... can i use something like rsync so i don't have to copy the entire thing every time?
17:12:24 <dons> yes. you can use rsync
17:12:40 <yip> dons: i only really need to copy the _darcs directory, right?
17:13:06 <dons> i'd start by copying the lot. then rsync later. then i'd just install darcs on the server :-)
17:13:30 <sjanssen_> yip: _darcs is the only part that is absolutely required
17:13:45 <sjanssen_> but it's nice to have the rest for online browsing
17:13:53 <yip> sjanssen: ah, makes sense ok thanks man!
17:14:14 <dons> isn't there a trick for reproducing the top level from the prisine subdir?
17:15:06 <sjanssen_> dons: just cp, or use hardlinks
17:15:29 <sjanssen_> hardlinks could be dangerous, though
17:15:39 <dons> i seem to recall darcs repair or something, could repopulate
17:20:08 <yip> hm... when i do darcs send, is it supposed to ask: What is the target email address?
17:20:31 <Igloo> Only if the repo you are sending to doesn't tell it
17:20:32 <sorear> only if the repo owner forgot to set it
17:20:44 <yip> how does the repo owner set it?
17:20:54 <Igloo> _darcs/prefs/email IIRC
17:21:07 <sorear> IIRC too
17:21:31 <icarroll> @hoogle IO [String] -> IO String
17:21:32 <lambdabot> No matches, try a more general search
17:21:50 <icarroll> @pl IO [String] -> IO String
17:21:50 <lambdabot> (line 1, column 13):
17:21:51 <lambdabot> unexpected ">" or "-"
17:21:51 <lambdabot> expecting variable, "(", operator or end of input
17:21:54 <sorear> @ty liftM concat
17:21:56 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
17:22:02 <sorear> icarroll: ^^
17:22:49 <icarroll> sorear: thx. I'm trying to feed the output of getArgs through head to readFile. Any suggestions?
17:23:11 <sorear> @ty readFile =<< head `liftM` getArgs
17:23:14 <lambdabot> Not in scope: `getArgs'
17:23:20 <sorear> @ty readFile =<< (head `liftM` System.getArgs)
17:23:23 <lambdabot> IO String
17:24:05 <oren> Quick newbie question: if I have a record with named fields, I can write (field record) to access a field value. I can also easily define my own an operator (say '#') and write (field#record). Is there a built in operator like that?
17:24:10 <sorear> I like ($<<) = fmap; (>>$) = flip fmap, then it's just:
17:24:18 <sorear> readFile =<< head $<< getArgs
17:24:23 <LordBrain> hmmmm i would have used liftM as a prefix operator there
17:24:54 <icarroll> sorear: cool, thx. I had an extra =<< in there
17:24:55 <oren> Sorry, I meant (record#field)
17:25:09 <sorear> oren: not in Haskell ... F# uses |>
17:25:43 <oren> sorear: any deep reason, or matter of taste by the standard lib implementors? That is, if I define my own, am I doing something bad?
17:26:37 <sorear> matter of taste I think
17:27:04 <yip> Igloo: hm... i can't seem to find this in the docs
17:27:06 <oren> Ok, thanks! I like the '|>' notation.
17:28:08 <oren> Ok, a bit less newbie question: is there a standard combination of foldl and find? That is, go through the list like foldl, but stop if a certain condition (that uses the foldl computed value!) is reached?
17:28:17 <oren> For doing foldl on infinite lists?
17:28:37 <bd_> :t mapAccum
17:28:39 <lambdabot> Not in scope: `mapAccum'
17:28:43 <bd_> :t mapAccumL
17:28:46 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:28:46 <sorear> mapAccumL and filter might help
17:28:51 <sorear> er, find
17:28:52 <bd_> mapAccumL and takeWhile
17:28:55 <bd_> ?
17:28:57 <bd_> :t find
17:29:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:29:12 <sorear> maybe mapM on the contmonad
17:29:24 <oren> The problem with separating the fild and the find is that the find needs to use the fold result.
17:30:03 <sjanssen_> oren: last . takeWhile p . scanl f z
17:30:11 <sorear> > foldM (\ac l -> if (ac + l > 100) then Cont (\_ -> ac) else return ac + l) [1..]
17:30:12 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
17:30:12 <lambdabot>       Expected...
17:30:16 <sjanssen_> for suitable definitions of p f and z
17:30:20 <sorear> > foldlM (\ac l -> if (ac + l > 100) then Cont (\_ -> ac) else return ac + l) [1..]
17:30:21 <lambdabot>   Not in scope: `foldlM'
17:30:25 <sorear> @ty foldM
17:30:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:30:37 <sorear> > foldM (\ac l -> if (ac + l > 100) then Cont (\_ -> ac) else return ac + l) 0 [1..]
17:30:38 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
17:30:39 <lambdabot>       Expected...
17:30:47 * oren is getting dizzy
17:31:01 <dons> more articles please! --> http://haskell.org/haskellwiki/Blog_articles
17:31:02 <lambdabot> Title: Blog articles - HaskellWiki
17:31:05 <bd_> sorear: I don't think Cont is needed directly here - can't this be done just with map
17:31:05 <sorear> > flip runCont id $ foldM (\ac l -> if (ac + l > 100) then Cont (\_ -> ac) else return (ac + l)) 0 [1..]
17:31:06 <sjanssen_> > last . takeWhile (< 100) . scanl (+) 0 $ [0..] -- like this, oren
17:31:08 <lambdabot>  91
17:31:08 <lambdabot>  91
17:31:08 <bd_> mapAccum*
17:31:15 <sorear> ick, last
17:31:37 <sorear> @ty until
17:31:40 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:32:05 <oren> Hmmm... I see...
17:32:16 <siti> @seen dcoutts
17:32:16 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 30m 39s ago.
17:32:18 <sorear> > until ((>100) . fst) (\(x,(y:xs)) -> (x+y,xs)) $ [0..]
17:32:19 <lambdabot>  Couldn't match expected type `(a, [a])'
17:32:29 <oren> Easiest would be to do takeWhile . mapAccumL, I think
17:32:30 <sorear> > until ((>100) . fst) (\(x,(y:xs)) -> (x+y,xs)) $ (0,[0..])
17:32:31 <oren> Thanks!
17:32:32 <lambdabot>  (105,[15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,3...
17:33:17 <zbrown> x xs map foldl' <--- in that statement, what does the ' mean?
17:33:22 <sorear> strict
17:33:34 <zbrown> err strict?
17:33:43 <zbrown> and now... what does 'strict' mean ?
17:33:44 <zbrown>  lol
17:33:48 <siti> hehe
17:33:59 <siti> just use foldr it's better ;)
17:34:03 <Pseudonym> zbrown: Do you know what "lazy" means?
17:34:09 <zbrown> yes
17:34:16 <Pseudonym> In the context of Haskell?
17:34:18 <zbrown> yes
17:34:29 <Pseudonym> Well "strict" is what everyone else does, where Haskell does lazy.
17:34:30 <zbrown> as in it only evaluates what it needs to in order to get the answer yes?
17:34:40 <Pseudonym> Yes.
17:34:43 <zbrown> ok
17:34:48 <zbrown> i understand now
17:34:53 <zbrown> thank you :
17:34:54 <zbrown> )
17:35:04 <Pseudonym> Sometimes you need strict.
17:35:09 <zbrown> oic
17:35:12 <Pseudonym> But you, personally, do not right now. :-)
17:35:38 <zbrown> Pseudonym: in the statement i showed above, i dont understand why there's two variables then two calls to functions?
17:35:48 <zbrown> i guess i need an explanation of what that statement means?
17:36:06 <sorear> a type error
17:36:16 <sorear> I assumed you wrote it backward :)
17:36:17 <Pseudonym> Incidentally, ' is a symbol which can be part of a symbol.
17:36:26 <Pseudonym> So f and f' are different identifiers.
17:36:32 <zbrown> oic
17:36:34 <siti> math people seem to like ' so that's good :p
17:36:41 <Pseudonym> In a language based on maths, having prime is good, yes.
17:36:44 <dibblego> zbrown, the ' in the function above is just the name of the identifier; the difference between foldl and foldl' is that the latter is strict - there is nothing special about ' since it could have been called foldlStrict instead
17:36:44 <zbrown> no i just copied and pasted from a web page
17:36:49 <Pseudonym> f x = x*x
17:36:51 <Pseudonym> f' x = 2*x
17:36:52 <Pseudonym> For example.
17:37:08 <zbrown> Pseudonym: ya
17:37:27 <Darius> Bah! foldl should be called foldlLazy or foldl' and foldl' should be called foldl.  Everyone would be happier that way.
17:37:50 <dibblego> but then the naysayers would have ammunition against the statement, "Haskell is lazy"
17:38:14 <zbrown> lol
17:38:40 <LordBr4in> why wouldnt you want your fold to be lazy?
17:39:09 <Pseudonym> LordBr4in: It depends.  Sometimes you do, sometimes you want.
17:39:11 <Pseudonym> don't
17:39:16 <zbrown> strings are lists too in haskell right?
17:39:21 <Pseudonym> zbrown: Yes.
17:39:23 <dibblego> yes
17:39:24 <Pseudonym> String = [Char]
17:39:37 <zbrown> ok
17:39:49 <LordBr4in> yes zbrown, unless you use Data.ByteString which makes faster code.
17:39:55 <siti> Prelude Data.List> foldl' (+) 0 [1..10000000]
17:39:55 <siti> 50000005000000
17:39:55 <siti> (1.78 secs, 964691960 bytes)
17:39:55 <siti> Prelude Data.List> foldr (+) 0 [1..10000000]
17:39:55 <siti> *** Exception: stack overflow
17:40:15 <allbery_b> "unsafeFoldl" :)
17:40:44 * zbrown notes he should probably be working on his discrete math hw right now... but there's always the weekend for that ;)
17:40:46 <yip> sorear: i can't find anything in the docs about this email file
17:41:15 <sorear> yip: it's there ... but so simple I can easier explain than refer.
17:41:35 <sorear> yip: echo 'my_email@host.com' > _darcs/prefs/email, in each of your repos.
17:42:33 <yip> sorear: aha, out of the dozens of repositories i've looked in, i see that gtk2hs has this file
17:42:55 <yip> sorear: but they have a name as well as an email address is <brackets> in the file
17:43:25 <sorear> Stefan O'Rear <example@bar.com> IS an email address.  the whole thing.
17:43:25 <jyasskin> I've kinda informally found that foldr and foldl' are the only useful folds. When would anyone use foldl or foldr'?
17:43:26 <zbrown> Is there an operating system of choice for haskell programmers or is it pretty much whatever haskell will run on ;)?
17:43:33 <Pseudonym> zbrown: You'll learn more discrete maths doing Haskell than you'll learn in a year of lecturers.
17:43:41 <Pseudonym> First off, there is no foldr'.
17:43:44 <dons> zbrown: it runs on anything, so no, not really. linux is well supported
17:43:45 <Pseudonym> :t foldr'
17:43:47 <lambdabot> Not in scope: `foldr''
17:43:52 <sorear> zbrown: OpenBSD it seems :(
17:43:59 <sjanssen_> jyasskin: your intuition is primarily right
17:44:00 <dons> :)
17:44:02 <sorear> <-- persecuted linux user
17:44:11 <zbrown> sorear: guess that makes two
17:44:16 <dons> you mean linux luser, sorear ;)
17:44:25 <dons> unlike us unix users
17:44:28 <Pseudonym> jyasskin: Secondly, you use foldl if it doesn't make sense for the accumulator to be strict.
17:44:32 <jyasskin> :t Data.Foldable.foldr'
17:44:33 <zbrown> actually i use everything, was just curious about the others ;)
17:44:33 <sjanssen_> jyasskin: there are very few uses for foldl (last is the only one that comes to mind)
17:44:34 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
17:45:00 <kc5tja> Me three.
17:45:11 <LordBrain> openbsd is better supported than linux?
17:45:21 <sorear> > foldr1 (const id) "foo"
17:45:22 <lambdabot>  'o'
17:45:23 <Pseudonym> The usual case where you don't need foldl' is where you know that the accumulator is going to be evaluated anyway.
17:45:24 <dibblego> I use GHC fine on linux
17:45:40 <Pseudonym> maximum is one example, though that's technically foldl1 not foldl.
17:46:02 <Pseudonym> foldl avoids the seq of foldl'.
17:46:08 <sjanssen_> Pseudonym: foldl max still builds a giant thunk
17:46:25 <Pseudonym> Hmm.
17:46:27 <Pseudonym> Oh, you're right.
17:46:36 <Pseudonym> reverse is the canonical example./
17:46:43 <Pseudonym> ?source reverse
17:46:43 <lambdabot> reverse not available
17:46:48 <Pseudonym> ?src reverse
17:46:48 <lambdabot> reverse = foldl (flip (:)) []
17:47:01 <zbrown> Is there an advantage to using 'let' over 'where'
17:47:01 * allbery_b uses ghc on OSX, FreeBSD, and Linux
17:47:21 <zbrown> in the 'Tour of Haskell Syntax' it says both can be used to define local functions...
17:47:28 <zbrown> is there a preferred method for each?
17:47:34 <nmessenger> zbrown: 'where' scopes over all equations that have a guard.
17:47:43 <zbrown> nmessenger: ah i see
17:47:51 <Pseudonym> There's a technical difference that you really do not want to know about.
17:48:01 <nmessenger> 'let' is an expression and can be used in subexpressions
17:48:01 <zbrown> ok ill just not know aobut it :)
17:48:05 <Pseudonym> Really, it's wahtever is more readable.
17:48:51 <resiak> Pseudonym: what is the technical difference?
17:49:23 <jyasskin> Pseudonym: Is there a reason reverse and last should not be defined with foldl'? Or did people just not bother?
17:49:25 <nmessenger> I prefer using where whenever possible, and using 'let' whenever I need a local name inside a subexpression.
17:50:12 <allbery_b> well, you'd have to special-case the empty list
17:50:16 <Pseudonym> jyasskin: It's because the seq is unnecessary.
17:50:19 <sjanssen_> jyasskin: in the case of last, foldl' will seq the last value of the list
17:50:22 <Pseudonym> Right.
17:50:41 <Pseudonym> That's unnecessary since the last value of the list will be tail-called anyway.
17:51:09 <sjanssen_> actually, it's even worse
17:51:19 <sjanssen_> foldl' would seq every value in the list
17:51:45 <Pseudonym> Ah, yes.
17:51:50 <Pseudonym> It wouldn't in reverse.
17:51:52 <Darius> @oldwiki StackOverflow -- jyasskin
17:51:52 <lambdabot> http://www.haskell.org/hawiki/StackOverflow -- jyasskin
17:52:03 <Pseudonym> There, it would just be an unnecessary expense.
17:52:25 <Darius> @src reverse
17:52:26 <lambdabot> reverse = foldl (flip (:)) []
17:52:46 <nmessenger> @src (++)
17:52:47 <lambdabot> (++) []     ys = ys
17:52:47 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
17:53:05 <Darius> xs ++ ys = foldr (:) xs ys
17:53:12 <Darius> er switch xs and ys
17:53:24 <nmessenger> tsk, that should be foldr ((.) . (:)) id
17:53:29 <ddarius> (++) = flip (foldr (:)
17:53:38 * ddarius tortures Lispers
17:53:40 <nmessenger> @type foldr ((.).(:)) id
17:53:42 <lambdabot> forall a. [a] -> [a] -> [a]
17:55:08 <glen_quagmire> main = do args <- getArgs
17:55:13 <glen_quagmire>     putStrLn("hello, " ++ args !! 0)
17:55:16 <glen_quagmire> why is it bad?
17:55:18 <ddarius> > let (!) a = 'a' in 1 ! 3
17:55:19 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Char'
17:55:42 <ddarius> glen_quagmire: Your layout looks wrong.
17:55:47 <allbery_b> 1. indentation is technically wrong (but ghc will accept it)
17:55:54 <jyasskin> @src last
17:55:55 <lambdabot> last [x]    = x
17:55:55 <lambdabot> last (_:xs) = last xs
17:55:55 <lambdabot> last []     = undefined
17:56:05 <allbery_b> 2. "hello" ++ (args !! 0)
17:56:36 <sjanssen_> 2. "hello" ++ head args
17:56:48 <ddarius> With overloaded string literals the type error probably would've been a heck of a lot more confusing.
17:57:04 <glen_quagmire> i'm following : http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/firststeps.html
17:57:06 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/uto4h
17:57:35 <nmessenger> @pretty do {args <- getArgs; putStrLn("hello, " ++ args !! 0) }
17:57:36 <lambdabot> "Parse error" at column 56
17:57:54 <glen_quagmire> i think that tutorial is outdated
17:57:59 <glen_quagmire> i'll read up on new tutorials
17:58:45 <jyasskin> Heh: "A case where it makes a difference is if the function is conditionally strict in its first argument depending on its second" which think is true in (last = foldl (\_ b -> b) (error "no last"))
17:59:11 <allbery_b> hm, actually, works with your parentheses in ghci
17:59:25 <jyasskin> > let  last = foldl (\_ b -> b) (error "no last") in last [2,error "strict",4,5]
17:59:27 <lambdabot>  5
17:59:32 <jyasskin> > let  last = foldl' (\_ b -> b) (error "no last") in last [2,error "strict",4,5]
17:59:33 <lambdabot>  Exception: strict
18:00:05 <sjanssen_> (in Paul Harvey voice) and now you know the rest of the story
18:00:51 <mbishop> wee 300 reddit karma
18:01:03 <allbery_b> okay, it's your indentation
18:01:15 <jyasskin> Thanks for the link, ddarius.
18:01:28 <allbery_b> I thought ghc was loose on the way it handled layout in do, but apparently it's nto *that* loose
18:01:30 <sjanssen_> mbishop-- I'm just keeping the karmic balance :)
18:01:35 <sjanssen_> mbishop++
18:02:04 <ddarius> sjanssen_: One Haskell karma point = 300 reddit ones
18:02:15 <mbishop> heh
18:02:21 <sjanssen_> @karma dons
18:02:21 <lambdabot> dons has a karma of 123
18:02:25 <mbishop> well that's good I guess, since I have 1 karma point here ;P
18:02:26 <sjanssen_> > 300 * 123
18:02:27 <lambdabot>  36900
18:02:29 <mbishop> ?karma
18:02:30 <lambdabot> You have a karma of 1
18:03:02 <nmessenger> IT IS MISTAKEN!  http://programming.reddit.com/user/dons
18:03:04 <lambdabot> Title: overview by dons (on programming.reddit.com)
18:04:14 <nmessenger> dons is rather a prolific redditor.  I haven't used it much lately.
18:05:03 <mbishop> that showoff
18:05:56 <ddarius> jyasskin: Your definition of last falls under the last few sentences in the *'ed part.
18:06:03 <dons> > 1620 / 123
18:06:05 <lambdabot>  13.170731707317072
18:06:14 <dons> 1 #haskell point = 13 reddit points
18:06:43 <SamB> @karma me
18:06:43 <lambdabot> me has a karma of 0
18:06:50 <sorear> @karma SamB
18:06:50 <lambdabot> SamB has a karma of 23
18:06:50 <dons> 13x as many people read reddit, i guess ;)
18:06:57 <sorear> @karma /me
18:06:57 * lambdabot has a karma of 0
18:06:58 <ddarius> dons: No. It equals 300.  You just haven't converted them yet.
18:07:04 <dons> ah right!
18:07:55 <sjanssen_> @karma xs
18:07:55 <sjanssen_> @karma i
18:07:55 <lambdabot> xs has a karma of 1
18:07:56 <lambdabot> i has a karma of 0
18:08:22 <ddarius> Let's see. Divide 1620 by 300 and we get 5 and some so all your redditing will sooner or later get you five instances of dons++. dons--
18:08:43 <ddarius> @karma MegaMonad
18:08:43 <lambdabot> MegaMonad has a karma of 0
18:08:44 <sorear> dons++ the . kills it
18:08:51 <sorear> @karma dons
18:08:51 <SamB> sorear: how did you do that?
18:08:52 <lambdabot> dons has a karma of 123
18:09:00 <sorear> SamB: ?
18:09:08 <SamB> <sorear> @karma /me
18:09:08 <SamB> * lambdabot has a karma of 0
18:09:11 <dons> hmm. reading my comments, it seems like reddit is getting dumber. i'm doing more frustrated explaining than 3 months ago
18:09:15 <sorear> SamB: easily!
18:09:17 <dons> more readers.
18:09:27 <SamB> I didn't ask "how hard was it"
18:09:30 <sorear> SamB: the lb output filter translates /me into action
18:09:33 <SamB> oh.
18:09:40 <SamB> @read "/me"
18:09:41 <lambdabot>  /me
18:09:41 <sorear> @karma TIME
18:09:42 <lambdabot> TIME has a karma of 0
18:09:44 <SamB> hmm.
18:09:45 <dons> also, i no longer need to submit haskell articles. the reddit bots do that for us
18:09:49 <dons> sorear: are you giong to fix that?
18:09:55 <ddarius> dons: Yeah.  That's part of why I was getting ready to leave www.programmersheaven.com a long time ago.  Then Haskell came along and swept me away.
18:09:57 <SamB> reddit bots?
18:10:10 <sorear> dons: do you consider it a bug?
18:10:11 <LoganCapaldo> its not a bug, its a feature
18:10:15 <dons> sorear: yes.
18:10:28 <nmessenger> @karma /me
18:10:29 * lambdabot has a karma of 0
18:10:29 <dons> filter printables only
18:10:30 <SamB> dons: but it looks fun
18:10:33 <nmessenger> @karma lambdabot
18:10:34 <lambdabot> lambdabot has a karma of 41
18:10:46 <SamB> dons: it isn't harmful
18:10:47 <sorear> @where prod
18:10:47 <lambdabot> I know nothing about prod.
18:10:50 <sorear> @where poke
18:10:51 <lambdabot> I know nothing about poke.
18:10:59 <sorear> hmm, lambdabot ate it
18:11:09 <sorear> HAppS!
18:11:11 <ddarius> Incidentally, that's part of why I have no interest into getting into reddit now.  Though neelk posting there is enticing.
18:11:18 * sorear thinks lb/happs would be fun
18:11:54 <dons> SamB: it is annoying, and trying not to be annoying is one of lambdabot's guiding principles
18:12:08 <dons> the fact that it is only ever used to point out that it is possible is a hint that it should be fixed
18:12:29 <SamB> dons: yes, it should be made easier to use
18:12:40 <dons> thanks for your help and patches
18:12:46 <zbrown> http://pastebin.ca/376494 <--- Can anyone look at that and tell me why i keep getting an error
18:12:52 <SamB> @smack dons
18:12:52 <lambdabot> Unknown command, try @list
18:12:57 <SamB> @hit dons
18:12:58 <lambdabot> No match for "dons".
18:13:05 <sorear> @slap SamB
18:13:06 <lambdabot> why on earth would I slap SamB
18:13:16 <SamB> @slap sorear
18:13:17 * lambdabot smacks sorear about with a large trout
18:13:31 <nmessenger> zbrown: add print (...) to line 9
18:13:33 <LoganCapaldo> zbrown: it doesn't type check
18:13:34 <dons> kids, stop fighting and help zbrown
18:13:37 <SamB> @tell lambdabot to read a thesaurus
18:13:38 <lambdabot> Nice try ;)
18:13:40 <sorear> @msg zbrowk hpast
18:13:44 <Cale> threeXconject 2*x = (threeXconject 2) * x
18:13:51 <dons> zbrown: good idea to use hpaste.org in future, and to submit the type error as well
18:13:52 <LoganCapaldo> main must to result in IO ()
18:13:54 <dons> ?paste <-- here
18:13:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:14:01 <sorear> !msg zbrown hi.  why don't you like me?
18:14:09 <sorear> !msg sorear test
18:14:11 <nmessenger> !say
18:14:12 <zbrown> dons: ok
18:14:13 <dons> zbrown: the line should be:   return $ threeXconject (read num)
18:14:21 <sorear> gah, it forgot my ops *again*
18:14:21 <SamB> !list
18:14:36 <dons> SamB, sorear: feel free to answer questions instead of mucking about with bots :-)
18:14:37 <Cale> dons: you mean print -- that's main after all
18:14:37 <sorear> he needs to use HAppS :)
18:14:40 <sjanssen_> zbrown: threeXconject will loop forever given any even number
18:14:43 <dons> sorry. print $ ...
18:14:49 <gravity> Why return $? Why not return ( threeXconject (read num) )?
18:14:57 <nmessenger> gravity: same thing
18:14:57 <sorear> no reason
18:15:00 <SamB> dons: are you misquoting a work of literature again?
18:15:01 <gravity> Heh, ok.
18:15:04 <LoganCapaldo> We likes our dollar signs
18:15:05 <bd_> style :)
18:15:16 <dons> @pl return ( threeXconject (read num) )
18:15:17 <lambdabot> return (threeXconject (read num))
18:15:20 <dons> hehe
18:15:24 <allbery_b> using $ saves on parentheses.  if we liked parens we'd be doing lisp, after all :)
18:15:30 <gravity> Ha!
18:15:38 * nmessenger wubs his parens
18:15:39 <dons> SamB: focus.
18:16:03 <gravity> That reminds me... someone wrote a rogue-alike recently named lambdarouge. It's written in Pascal.
18:16:09 <gravity> I nearly choked.
18:16:17 <dons> hah
18:16:28 <zbrown> sjanssen_: i just noticed that, i had the expressions backwards
18:17:05 <SamB> well, lambdamoo (the interpreter) is written in C...
18:17:21 <SamB> and the MOO language it implements has nothing remotely resembling closures
18:17:34 <LoganCapaldo> Is lambdamoo a MOO with a functional languae?
18:17:36 <LoganCapaldo> oh
18:17:37 <LoganCapaldo> nvm
18:17:41 <LoganCapaldo> I got excited
18:18:04 <LordBrain> whats a MOO?
18:18:42 <LoganCapaldo> MUD variant with more cows
18:18:43 <SamB> its like moonix, except with OO instead of unix
18:19:04 <LordBrain> oh well.. i gtg
18:19:13 <zbrown> Is there a way to use 2 diff evaluations in a list comprenhension?
18:19:23 <SamB> actually it isn't called moonix
18:19:28 <bd_> zbrown: What do you mean by different evaluations?
18:19:48 <zbrown> bd_: say if x is even, then do '3*x +1' and if its odd do '2*x'
18:19:59 <bd_> oh, hm
18:20:07 <bd_> :t even
18:20:09 <lambdabot> forall a. (Integral a) => a -> Bool
18:20:15 <allbery_b> "if" is an expression
18:20:21 <bd_> map (\x -> if even x then 3*x+1 else 2*x) ?
18:20:24 <bd_> > map (\x -> if even x then 3*x+1 else 2*x) [1..10]
18:20:26 <lambdabot>  [2,7,6,13,10,19,14,25,18,31]
18:20:32 <LoganCapaldo> > [ if even x then 3 *x + 1 else x | x <- [1..] ]
18:20:34 <lambdabot>  [1,7,3,13,5,19,7,25,9,31,11,37,13,43,15,49,17,55,19,61,21,67,23,73,25,79,27,...
18:20:45 <zbrown> hrm, i need a better way to write this function...
18:21:01 * zbrown is working furiously to break his mind of its imperative chains
18:21:13 <LoganCapaldo> you should test it with quickcheck
18:21:17 <bd_> if is ugly :(
18:21:30 <LoganCapaldo> 500 iterations should be enough for anyone :)
18:21:37 <dino-> Could write it out longer with guards.
18:21:51 <zbrown> has got to be a better way to write this function
18:21:59 <zbrown> or at least one that actually verifies that the code worked
18:22:17 <bd_> @check \x -> (x - 895834 `div` x - 895834 :: Int) == 0
18:22:19 <lambdabot>  Falsifiable, after 0 tests: -1
18:22:23 <bd_> @check \x -> (x - 895834 `div` x - 895834 :: Int) == 1
18:22:25 <lambdabot>  Falsifiable, after 0 tests: -1
18:22:35 <bd_> @check \x -> ((x - 895834) `div` (x - 895834) :: Int) == 1
18:22:37 <lambdabot>  OK, passed 500 tests.
18:22:44 <bd_> failure to test edge case ;)
18:22:51 <LoganCapaldo> those parens i'll kill ya
18:22:51 <dons> @check \x -> x >= 0 ==> (x - 895834 `div` x - 895834 :: Int) == 1
18:22:53 <lambdabot>  Exception: divide by zero
18:22:54 <bd_> @scheck \x -> ((x - 895834) `div` (x - 895834) :: Int) == 1
18:22:56 <lambdabot>   Completed 13 test(s) without failure.
18:23:14 <dons> @check \x -> x > 0 ==> (x - 895834 `div` x - 895834 :: Int) == 1
18:23:15 <lambdabot>  Falsifiable, after 0 tests: 1
18:24:12 <nmessenger> x - (895834 `div` x) - 895834 /= 1
18:24:18 <LoganCapaldo> @botsnack
18:24:19 <lambdabot> :)
18:24:33 <Cale> > map (length . takeWhile (/= 1) . iterate (\x -> if even x then x `div` 2 else 3 * x + 1)) [2..50]
18:24:34 <lambdabot>  [1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7,7,15,15,10,23,10,111,18,18,18...
18:24:36 <LoganCapaldo> the mental image I get from doing that is priceless
18:25:01 <Cale> > map (length . takeWhile (/= 1) . iterate (\x -> if even x then x `div` 2 else 3 * x + 1)) [1..]
18:25:03 <lambdabot>  [0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7,7,15,15,10,23,10,111,18,18,...
18:25:35 <nmessenger> any isInfinite (map (length . ...)) -- :)
18:25:39 <yip> good news, my haskell gameboy emulator darcs repository is online!
18:25:44 <yip> http://www.mutantlemon.com/omegagb/
18:25:45 <lambdabot> Title: OmegaGB - Game Boy Emulator
18:25:49 <LoganCapaldo> sweet
18:25:53 <dons> yay. is it tagged and cabalised?
18:25:56 <Cale> > nubBy (>) $ map (length . takeWhile (/= 1) . iterate (\x -> if even x then x `div` 2 else 3 * x + 1)) [1..]
18:26:00 <lambdabot> Terminated
18:26:00 <dons> ready for release and uploading to hackage for all time?
18:26:06 <Cale> > nubBy (>) $ map (length . takeWhile (/= 1) . iterate (\x -> if even x then x `div` 2 else 3 * x + 1)) [1..100]
18:26:07 <lambdabot>  [0,1,7,8,16,19,20,20,23,111,112,112,115,118]
18:26:12 <yip> dons: no, the project is not complete
18:26:12 <dons> ?where hackage
18:26:13 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
18:26:25 <dons> yp, we should try to get it o nhere, once you release ^^
18:26:43 <yip> first it needs to be shaped into a usable state...
18:27:10 <vermious> So, in search of something more fun than PHP or .NET, I built myself a nice new hxweb
18:27:29 <vermious> Just can't find a a M to RTF
18:28:00 <Cale> Hmm, is Lemmih around?
18:28:15 <Cale> Doesn't look like it. He'd be the one to talk to.
18:28:22 <vermious> I remember seeing some examples somewhere, but it wa late at night, I'd had some gin, and now I cna't find any uasage examples
18:29:01 <vermious> He was the one I'd hoped to talk to
18:29:04 * LoganCapaldo thinks that the gin snuck out and wrote the examples
18:29:12 <LoganCapaldo> that sneaky gin
18:29:16 <vermious> guess I'll have to lurk for a while
18:29:21 <Cale> He's usually around, not sure which times of day are best.
18:29:24 <LoganCapaldo> @seen lemmih
18:29:24 <lambdabot> I saw lemmih leaving #haskell 1h 50m 19s ago, and .
18:29:31 <LoganCapaldo> and . ?
18:30:17 <vermious> thanks folks.
18:30:45 * ddarius will solve that problem.
18:32:52 <TomMD> Is there a way to make an infinate lazy list from an IPC channel?
18:33:05 <dibblego> is it Jane St. Capital that is moving more toward Haskell from OCaml?
18:33:10 <bd_> TomMD: using unsafeInterleaveIO, sure. Be careful about deadlocks though.
18:35:01 <LoganCapaldo> @type unsafeInterleaveIO
18:35:03 <lambdabot> Not in scope: `unsafeInterleaveIO'
18:35:17 <LoganCapaldo> @type GHC.Base.unsafeInterleaveIO
18:35:19 <lambdabot> Not in scope: `GHC.Base.unsafeInterleaveIO'
18:35:25 <LoganCapaldo> fine
18:35:34 <LoganCapaldo> I probably didn't want to know anyway
18:35:36 <TomMD> I would like to have a pure (non-monadic function) take an infinite/lazy list as an argument, but the list isn't File IO or any such, so getContents doesn't work.  unsafeInterleaveIO.... I don't see any deadlock issues for my case.  Is there a trival example of common deadlock cases?  Are you just talking about if the IO blocks?
18:35:39 <LoganCapaldo> it sounds unsafe
18:36:03 <TomMD> unsafeInterleaveIO :: IO a -> IO a
18:36:03 <TomMD> Well, now you know anyway.
18:36:38 <nmessenger> er, unsafeInterleaveIO :: IO a -> a
18:36:55 <nmessenger> it's like unsafePerformIO, except lazy
18:37:00 <LoganCapaldo> lol
18:37:14 <LoganCapaldo> Doesn't want to get up off the couch and Perform eh?
18:37:17 <nmessenger> no really, that's what it does
18:37:40 <nmessenger> it's the magic that enables getContents, for example
18:37:47 <LoganCapaldo> I woulda thunk unsafePerformIO was lazy
18:37:51 <LoganCapaldo> its strict?
18:38:13 <TomMD> so is getContents written in Haskell using this function, or is it still a STG/C implimentation?
18:38:16 <kpreid> LoganCapaldo: unsafePerformIO performs the entire IO action when evaluated.
18:38:28 <kpreid> LoganCapaldo: unsafeInterleaveIO may perform the action in little pieces at a time.
18:38:31 <bd_> ?src getcontents
18:38:32 <lambdabot> Source not found. You speak an infinite deal of nothing
18:38:33 <bd_> ?src getContents
18:38:34 <lambdabot> getContents = hGetContents stdin
18:38:38 <bd_> ?src hGetContents
18:38:39 <lambdabot> Source not found. You type like i drive.
18:38:40 <bd_> tsk
18:38:41 <LoganCapaldo> fascinating
18:39:06 <TomMD> ?src main
18:39:06 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:39:16 <nmessenger> LoganCapaldo: like kpreid says, unsafeInterleaveIO will only do a getChar whenever you match on the first element of the list, etc.
18:39:33 <bd_> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/IO.hs implementation here
18:39:39 <LoganCapaldo> Ha!
18:39:45 <LoganCapaldo> I'm not gonna click that link
18:39:58 <bd_> Gasp! Why not?
18:40:01 <vermious> that way lies madness
18:40:05 <LoganCapaldo> You guys just want to destroy my mind so I don't ask anymore annoying questions
18:40:09 <nmessenger> @quote innocence
18:40:09 <lambdabot> LoganCapaldo says: You guys are destroying my innocence
18:41:18 <bd_> LoganCapaldo: It's not that bad! Only about 50 lines, six functions, a few worrying uses of Dark Magic...
18:44:55 <ddarius> @hoogle unsafeInterleaveIO
18:44:56 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
18:45:28 <LoganCapaldo> oh thats not so bad
18:45:36 <LoganCapaldo> @type id :: IO a -> IO a
18:45:38 <lambdabot> IO a -> IO a :: forall a. IO a -> IO a
18:45:51 <ddarius> @src System.IO.Unsafe.unsafeInterleaveIO
18:45:52 <lambdabot> Source not found. Do you think like you type?
18:46:32 <ddarius> unsafeInterleaveIO action = let a = unsafePerformIO action in return a -- more or less
18:47:08 <bd_> ?src unsafeInterleaveIO
18:47:09 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
18:47:17 <dibblego> is it possible to pattern match a (a, a) tuple without concern for ordering?
18:47:38 <bd_> dibblego: what do you mean by that?
18:47:58 <bd_> usually one puts the fields in a tuple in some specific order...
18:48:09 <bd_> @pl \a b -> [a,b]
18:48:09 <lambdabot> (. return) . (:)
18:48:14 <dibblego> (True, False) means the same as (False, True)
18:48:15 <mbishop> well, (a, a) wouldn't matter anyway, right?
18:48:25 <mbishop> unless you ment (a, b)
18:48:29 <bd_> mbishop: well, there could be some semantic difference
18:48:44 <dibblego> in this case, ordering is unimportant (and there is more than just 2)
18:48:45 <LoganCapaldo> (a, b) | a `xor` b == True =
18:48:52 <bd_> dibblego: oh, a /large/ tuple?
18:48:56 <LoganCapaldo> if theres an xor
18:48:56 <dibblego> and they are not boolean, but my own type
18:48:59 <bd_> Data.Generics may be helpful
18:49:21 <ddarius> a `xor` b == True = a `xor` b
18:49:31 <LoganCapaldo> thats true
18:49:43 <dibblego> I was thinking I might have to use a Data.Set and order the elements instead
18:49:44 <LoganCapaldo> haskell makes me make silly mistakes
18:49:58 <ddarius> It's not a mistake per se, it's just redundant.
18:50:00 * LoganCapaldo has never written == True in any other language
18:50:09 <bd_> dibblego: Can you use lists?
18:50:11 * ddarius has seen it quite a bit in VB.
18:50:16 <LoganCapaldo> I think I'm afraid of the type checker
18:50:20 <LoganCapaldo> :)
18:50:26 <dylan> == True? is that needed?
18:50:31 <dibblego> bd_, I could, but then the length is not fixed - which I would like if I could
18:50:32 <bd_> (== True) = id
18:50:43 <araujo> hello
18:50:50 <siti> hi
18:50:51 <dylan> LoganCapaldo: you don't need == True
18:50:51 <bd_> dibblego: Okay, you can use Data.Generics to iterate over elements in the tuple
18:50:58 <bd_> read the paper on it, it's better than the haddock
18:51:01 <dibblego> ok thanks
18:51:02 <LoganCapaldo> dylan: yes I know
18:51:09 <LoganCapaldo> we just discussed that fact :)
18:51:15 <bd_> dibblego: http://www.cs.vu.nl/boilerplate/
18:51:17 <lambdabot> Title: Scrap your boilerplate ... in Haskell
18:51:27 <bd_> the research papers have a nice tutorial style
18:51:49 <ddarius> @google Quotient Types programming containers
18:51:52 <lambdabot> http://cdc.ioc.ee/appsem04/webproc/short/abbott-altenkirch-ghani-mcbride.ps.gz
18:51:54 <nmessenger> LoganCapaldo: also xor = (/=)
18:52:14 <LoganCapaldo> truuuuuue
18:52:26 <bd_> not = (== False) ofc
18:52:50 <bd_> and = curry (== (True, True)) ;)
18:52:52 <nmessenger> > (do x <- [True,False]; y <- [True,False]; return (x, y, x/=y))
18:52:53 <lambdabot>  [(True,True,False),(True,False,True),(False,True,True),(False,False,False)]
18:53:02 <nmessenger> :D
18:53:20 <bd_> > [ (x, y, x/=y) | x <- [True, False], y <- [True, False] ]
18:53:22 <lambdabot>  [(True,True,False),(True,False,True),(False,True,True),(False,False,False)]
18:54:09 <LoganCapaldo> it would be funny if you could use list comprehension syntax as an alternative for do notation for any monad
18:54:27 <dylan> that's the way it used to be
18:54:39 <LoganCapaldo> arrroooo?
18:54:55 <nmessenger> @google monad comprehensions
18:54:57 <lambdabot> http://www.haskell.org/onlinereport/exps.html
18:54:57 <lambdabot> Title: The Haskell 98 Report: Expressions
18:55:04 <nmessenger> nah
18:56:46 <ddarius> @type getBounds
18:56:48 <lambdabot> Not in scope: `getBounds'
18:57:03 <ddarius> @type Data.Array.MArray.getBounds
18:57:06 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Data.Array.Base.MArray a e m, Ix i) => a i e -> m (i, i)
18:59:20 <LoganCapaldo> So why isn't ~pat the default?
19:00:03 <bd_> LoganCapaldo: because then this would be wrong:
19:00:04 <bd_> map f [] = []
19:00:10 <bd_> map f (h:t) = (f h):map f t
19:00:16 <bd_> because ~[] matches any list, right? :)
19:00:22 <bd_> > let ~[] = [1,2,3] in 4
19:00:24 <lambdabot>  4
19:00:28 <bd_> > let [] = [1,2,3] in 4
19:00:30 <LoganCapaldo> aha
19:00:30 <lambdabot>  4
19:00:33 <bd_> ... hm
19:00:37 <LoganCapaldo> erm
19:00:42 * LoganCapaldo confused
19:00:42 <bd_> > (\[] -> 4) [1,2,3]
19:00:44 <lambdabot>   Non-exhaustive patterns in lambda
19:00:45 <bd_> > (\~[] -> 4) [1,2,3]
19:00:45 <lambdabot>  Parse error
19:00:47 <bd_> bah
19:00:51 <LoganCapaldo> LOL
19:00:57 <bd_> > (\(~[]) -> 4) [1,2,3]
19:00:59 <lambdabot>  4
19:01:02 <bd_> here we go!
19:01:07 <LoganCapaldo> yay
19:01:16 <ddarius> bd_: let is always lazy (irrefutable)
19:01:21 <bd_> *nod*
19:01:31 * LoganCapaldo didn't realize ~[] would match any list
19:01:35 <bd_> :)
19:01:38 <TSC> Until it is evaluated, then it gets refuted with a vengeance (:
19:01:55 <bd_> TSC: ah, but [] doesn't bind to a variable, so it'll never be evaluated
19:02:25 <TSC> Indeed
19:02:37 <LoganCapaldo> (\(a, _) -> a) (1, undefined)
19:02:45 <LoganCapaldo> > (\(a, _) -> a) (1, undefined)
19:02:46 <lambdabot>  1
19:02:58 <nmessenger> not very interesting since (,) only has one constructor
19:03:00 <LoganCapaldo> > (\(a, ~b) -> a) (1, undefined)
19:03:02 <lambdabot>  1
19:03:08 <LoganCapaldo> > (\(a, b) -> a) (1, undefined)
19:03:09 <lambdabot>  1
19:03:14 <LoganCapaldo> mmm
19:03:23 <LoganCapaldo> gah what am I doing?
19:03:31 <LoganCapaldo> I should be writing a philosophy paper
19:03:34 <nmessenger> > (\(~Left x) -> 1) (Right 2)
19:03:35 <lambdabot>  Parse error in pattern
19:03:39 * ddarius has made a first cut at a new lambdabot module, now to figure out how lambdabot builds.
19:03:43 <nmessenger> > (\(~(Left x)) -> 1) (Right 2)
19:03:45 <lambdabot>  1
19:04:11 <LoganCapaldo> Now I'm starting to feel like ~ is useless with these examples
19:04:25 <ddarius> > (\(~(Left x)) -> x) (Right 2)
19:04:27 <lambdabot>   Irrefutable pattern failed for pattern (Data.Either.Left x)
19:04:43 <nmessenger> > (\(~(x,y)) -> x) undefined
19:04:44 <lambdabot>  Undefined
19:04:57 <LoganCapaldo> heh
19:05:01 <LoganCapaldo> > fst undefined
19:05:03 <lambdabot>  Undefined
19:05:15 <ddarius> LoganCapaldo: You would want to use it, but when you do it's much more convenient then the alternative usually.
19:05:38 <ddarius> + rarely
19:05:42 <LoganCapaldo> ah
19:05:48 <LoganCapaldo> that makes more sense now
19:06:40 <ddarius> It seems most useful when you are working with circular data structures.
19:06:48 <LoganCapaldo> (\(~(n+1)) -> 2) undefined
19:06:57 <LoganCapaldo> > (\(~(n+1)) -> 2) undefined
19:06:57 <lambdabot>  Parse error in pattern
19:07:11 <LoganCapaldo> > (\~(n+1) -> 2) undefined
19:07:12 <lambdabot>  Parse error
19:07:21 <LoganCapaldo> No ~n+k eh?
19:12:09 <mdmkolbe> I want a function that partitions a list into equivalence classes given an equivalence function.  groupBy is almost right but it only considers neighbors.  for example, I want [1, 2, 1, 2] to map to [[1, 1], [2, 2]].  is there already a function for this?
19:12:46 <ivanm> mdmkolbe: groupBy f . sortBy f
19:12:47 <LoganCapaldo> you could groupBy . sort
19:13:20 <nmessenger> groupBy ((EQ==) . f) . sortBy f
19:13:40 <ddarius> All of those imply an ordering that may not exist.
19:13:58 <mdmkolbe> sortBy needs a comparison operator not just an equality operator right?  (I might be able to rewire my code for that, but it would be better without a comparison operator)
19:14:17 <nmessenger> @type \f -> groupBy ((EQ==) . f)
19:14:20 <lambdabot>     Couldn't match expected type `a -> Bool'
19:14:20 <lambdabot>            against inferred type `Bool'
19:14:22 <ivanm> mdmkolbe: yeah, something like a -> a -> Ord
19:14:27 <nmessenger> @type \f -> groupBy (((EQ==).) . f)
19:14:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [[a]]
19:14:37 <ivanm> I don't think you need the EQ==...
19:14:46 <mdmkolbe> @type EQ==
19:14:49 <lambdabot> parse error (possibly incorrect indentation)
19:14:53 <nmessenger> @type (EQ==)
19:14:56 <lambdabot> Ordering -> Bool
19:14:57 <ivanm> @type (EQ==)
19:14:59 <lambdabot> Ordering -> Bool
19:15:05 <mdmkolbe> @type (==)
19:15:08 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:15:19 <mdmkolbe> what is EQ==?
19:15:21 <ddarius> \xs -> nub $ map (flip (filter . (~=)) xs) xs
19:15:40 <ddarius> @pl \xs -> nub $ map (flip (filter . (~=)) xs) xs
19:15:41 <lambdabot> (line 1, column 35):
19:15:41 <lambdabot> unexpected "~"
19:15:41 <lambdabot> expecting lambda abstraction or expression
19:15:49 <ivanm> mdmkolbe: Ordering functions have either LT, GT or EQ
19:15:55 <ivanm> less than, greater than or equal
19:16:01 <ddarius> @src Ordering
19:16:02 <lambdabot> data Ordering = LT | EQ | GT
19:16:07 <TSC> mdmkolbe: It's an operator section, (\x -> EQ == x)
19:16:14 <ddarius> @type \xs -> nub $ map (flip (filter . (~=)) xs) xs
19:16:16 <lambdabot> Not in scope: `~='
19:16:22 <ddarius> @type \xs -> nub $ map (flip (filter . (==)) xs) xs
19:16:23 <mdmkolbe> TSC: thx
19:16:25 <lambdabot> forall a. (Eq [a], Eq a) => [a] -> [[a]]
19:16:27 <nmessenger> @type compare
19:16:29 <ivanm> ddarius: \=?
19:16:29 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:16:34 <nmessenger> @type ((EQ==).) . compare
19:16:37 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:17:29 <mdmkolbe> @pl \xs -> nub $ map (flip (filter . (==)) xs) xs
19:17:29 <lambdabot> nub . (map =<< flip (filter . (==)))
19:17:43 <mdmkolbe> @type filter
19:17:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:18:09 <LoganCapaldo> ?check (\x y -> (((EQ==).) . compare x y) == (x == y))
19:18:10 <lambdabot>  Couldn't match expected type `a -> a1 -> Ordering'
19:18:39 <LoganCapaldo> ah well
19:19:20 <nmessenger> ?check (\x y -> (EQ == compare x y) == (x == y)) :: I -> I -> Bool
19:19:21 <lambdabot>  OK, passed 500 tests.
19:19:38 <nmessenger> @pl \x y -> EQ == compare x y
19:19:39 <lambdabot> ((EQ ==) .) . compare
19:19:47 <nmessenger> QED.
19:19:54 <ddarius> @src I
19:19:54 <lambdabot> Source not found. stty: unknown mode: doofus
19:19:59 <nmessenger> type I = Int
19:20:03 <LoganCapaldo> 500 tests == QED? :)
19:20:39 <ivanm> proof by exhaustion ;)
19:21:33 <ddarius> ivanm: Except that even for small domains (e.g. Bool) since QuickCheck is randomized there is no certainty that you have made an exhaustive case analysis.
19:22:34 <LoganCapaldo> ?check (\x y -> ((((EQ==).) . compare) x y) == (x == y))
19:22:35 <lambdabot>  Add a type signature
19:22:46 <LoganCapaldo> ?check (\x y -> ((((EQ==).) . compare) x y) == (x == y)) :: I -> I -> Bool
19:22:47 <lambdabot>  OK, passed 500 tests.
19:22:48 <SamB> @scheck (\x y -> (EQ == compare x y) == (x == y)) :: I -> I -> Bool
19:22:48 <ivanm> 1.15 Proof by accumulated evidence
19:22:49 <ivanm> Long and diligent search has not revealed a counterexample.
19:22:50 <lambdabot>   Completed 169 test(s) without failure.
19:23:05 <SamB> @scheck (\x y -> (EQ == compare x y) == (x == y)) :: Bool -> Bool -> Bool
19:23:06 <LoganCapaldo> @help scheck
19:23:07 <lambdabot>   Completed 4 test(s) without failure.
19:23:07 <lambdabot> scheck <expr>
19:23:07 <lambdabot> You have SmallCheck and 3 seconds. Test something.
19:23:19 <LoganCapaldo> @help check
19:23:19 <lambdabot> check <expr>
19:23:19 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
19:23:29 <SamB> heh
19:23:32 <SamB> that is backwards
19:23:36 <LoganCapaldo> whatsa diff. between small and quick?
19:23:42 <SamB> small is not random
19:23:55 <SamB> but it does not do a complete check of all types
19:23:59 <LoganCapaldo> ah
19:25:24 <LoganCapaldo> > typeOf (\x -> x + 1)
19:25:25 <lambdabot>  Integer -> Integer
19:25:28 <LoganCapaldo> wooo
19:25:29 <mdmkolbe> @eval 1+1
19:25:49 <LoganCapaldo> Is that how quick/small check figure out what to feed the function?
19:25:54 <mdmkolbe> does lambdabot have an eval?
19:26:01 <LoganCapaldo> @run 1 + 1
19:26:03 <lambdabot>  2
19:26:06 <LoganCapaldo> > 1 + 1
19:26:06 <mdmkolbe> cool, thx
19:26:07 <lambdabot>  2
19:26:32 <mdmkolbe> > (\xs -> nub $ map (flip (filter . (==)) xs) xs) [1, 2, 1, 2]
19:26:34 <lambdabot>  [[1,1],[2,2]]
19:26:54 <mdmkolbe> @filter
19:26:55 <lambdabot> Unknown command, try @list
19:26:57 <mdmkolbe> @type filter
19:27:00 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:27:12 <mdmkolbe> @type filter . (==)
19:27:14 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
19:27:40 <mdmkolbe> @nubBy
19:27:41 <lambdabot> Unknown command, try @list
19:27:45 <mdmkolbe> @type nubBy
19:27:48 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
19:29:43 <LoganCapaldo> @check (\x -> (nubBy (==) x) == nub x)
19:29:44 <lambdabot>  Add a type signature
19:30:02 <LoganCapaldo> @check (\x -> (nubBy (==) x) == nub x) :: [I] -> Bool
19:30:04 <lambdabot>  OK, passed 500 tests.
19:30:04 <ddarius> (\xs -> map (flip (filter . (==)) xs) xs) [1,2,1,2]
19:30:11 <ddarius> > (\xs -> map (flip (filter . (==)) xs) xs) [1,2,1,2]
19:30:12 <lambdabot>  [[1,1],[2,2],[1,1],[2,2]]
19:30:54 <ddarius> Note that my solution is really stupid (efficiency-wise)
19:32:21 <LoganCapaldo> @check (\x -> putStr x >>= (return . (== ()))) :: String -> IO Bool
19:32:22 <lambdabot>   add an instance declaration for (Testable (IO Bool))     In the expression:...
19:32:38 <mdmkolbe> :t \xs -> nub $ map (flip (filter . (==)) xs) xs
19:32:41 <lambdabot> forall a. (Eq [a], Eq a) => [a] -> [[a]]
19:33:04 <mdmkolbe> :t \eq xs -> nub $ map (flip (filter . eq) xs) xs
19:33:06 <lambdabot> forall a. (Eq [a]) => (a -> a -> Bool) -> [a] -> [[a]]
19:33:19 <mdmkolbe> \eq xs -> nubBy eq $ map (flip (filter . eq) xs) xs
19:33:31 <mdmkolbe> :t \eq xs -> nubBy eq $ map (flip (filter . eq) xs) xs
19:33:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
19:33:34 <lambdabot>       Expected type: [a]
19:33:51 <LoganCapaldo> @instances Testable
19:33:52 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
19:33:54 <mdmkolbe> :t nubBy
19:33:57 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
19:34:01 <LoganCapaldo> @instances-importing Testable
19:34:02 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
19:34:04 <mdmkolbe> :t nub
19:34:06 <ddarius> nubBy (all . zipWith eq)
19:34:07 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:34:09 <LoganCapaldo> @hoogle Testable
19:34:10 <lambdabot> Test.QuickCheck.Testable :: class Testable a
19:34:10 <lambdabot> Test.HUnit.Base.Testable :: class Testable t
19:34:52 <mdmkolbe> \eq xs -> nubBy (all . zipWith eq) $ map (flip (filter . eq) xs) xs
19:34:57 <mdmkolbe> :t \eq xs -> nubBy (all . zipWith eq) $ map (flip (filter . eq) xs) xs
19:35:00 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[c]'
19:35:00 <lambdabot>     In the second argument of `(.)', namely `zipWith eq'
19:35:34 <sorear> hello
19:35:43 <mdmkolbe> greetings
19:35:47 <ddarius> two-to-one arg compose needed, but that's the rough idea.
19:35:58 <LoganCapaldo> hey look its everyone's favorite sorear
19:36:02 <ddarius> \xs ys -> all (zipWith eq xs ys)
19:36:31 <mdmkolbe> :t \eq xs -> nubBy (\xs ys -> all $ zipWith eq xs ys) $ map (flip (filter . eq) xs) xs
19:36:32 <ddarius> sorear: You want a lambdabot module that may or may not compile?
19:36:33 <lambdabot>     Couldn't match expected type `a -> Bool'
19:36:34 <lambdabot>            against inferred type `[c]'
19:37:21 <sorear> "everyone's favorite" *pattern match failure Brain"
19:37:25 <ddarius> Actually zipWith eq xs ys would be wrong, we first need to guarantee that they are the same size.
19:37:34 <sorear> ddarius: ? test it, darcs send it
19:37:55 * ddarius doesn't feel like trying to get lambdabot to build.
19:38:07 <sorear> ddarius: sh build; ./dist/build/lambdabot/lambdabot -e offline
19:38:43 <sorear> you'll need GHC 6.6, Binary, GZip, and hs-plugins, cabal packages all
19:38:47 <ddarius> That would require installing cygwin and hoping for the best or booting to linux
19:38:56 <sorear> ah.
19:39:05 * mdmkolbe goes for a walk to think about the problem some more.
19:39:12 <sorear> so you want me to test it?
19:40:08 <ddarius> Maybe. I'm not sure.  It's pretty simple, but I don't even have the benefit of a passing type check.
19:43:31 <LoganCapaldo> > () :: () -- type checks and proves that is () inhabitated
19:43:33 <lambdabot>  ()
19:43:40 <LoganCapaldo> whose the man?
19:43:54 <sorear> () *is* inhabitated
19:44:03 <sorear> noone said it wasn't
19:44:15 <sorear> or if someone did, that someone was very dumb in matters CH
19:45:26 <newsham> you can build lambdabot without gzip with a few minor hacks
19:45:47 <newsham> you do not need cygwin.
19:49:35 <dons> newsham: i've had several people ask about lambdabot on windows
19:49:53 <dons> maybe you could either put up a wiki page, or add a readme/patch the repo so i can tell people what to do?
19:50:12 <Nafai> I want to do 'unwords' but without the spaces between the words...how do I do that?
19:50:19 <sorear> concat
19:50:28 <newsham> > concat (words "this is a test")
19:50:30 <dons> > concat (words "this is fun")
19:50:30 <sorear> > concat [ "foo", "bar", "baz" ]
19:50:30 <lambdabot>  "thisisatest"
19:50:32 <lambdabot>  "thisisfun"
19:50:32 <lambdabot>  "foobarbaz"
19:50:33 <dons> jinx!
19:50:53 <sorear> > concat [ [1,2,3], [5,6,7], [10,20,30] ] -- it even works on non-a
19:50:55 <lambdabot>  [1,2,3,5,6,7,10,20,30]
19:50:59 <sorear> er, non-Char
19:51:06 <Nafai> Thanks
19:51:11 <sorear> > join [ [1,2,3], [5,6,7], [10,20,30] ] -- more general version
19:51:13 <lambdabot>  [1,2,3,5,6,7,10,20,30]
19:51:23 <LoganCapaldo> @type "Hello" :: [Char]
19:51:26 <lambdabot> [Char] :: [Char]
19:51:37 <sorear> @type "Hello"
19:51:40 <lambdabot> [Char]
19:51:48 <LoganCapaldo> oh hey look at that
19:51:52 <sorear> @type {-# OPTIONS_GHC -foverloaded-strings #-} "Hello"
19:51:53 <rag3> @type @type
19:51:55 <lambdabot> [Char]
19:51:57 <lambdabot> parse error on input `@'
19:52:02 <sorear> aww
19:52:15 <rag3> @type 1/0
19:52:17 <lambdabot> forall t. (Fractional t) => t
19:52:23 <ddarius> Oh, I'm not assuming it's all that difficult (though I'm not assuming it's straight forward either).  I just don't want to do it.
19:52:29 <sorear> @type "foo!"#
19:52:32 <lambdabot> GHC.Prim.Addr#
19:52:37 <rag3> @type [1..]
19:52:38 <newsham> @type faster
19:52:40 <lambdabot> forall t. (Num t, Enum t) => [t]
19:52:42 <lambdabot> Not in scope: `faster'
19:52:46 <LoganCapaldo> No, stop with the hash symbol
19:52:49 <LoganCapaldo> it means evil
19:53:03 <sorear> @type ?evil
19:53:06 <lambdabot> forall t. (?evil::t) => t
19:53:07 <sorear> @type (+) %evil %evil
19:53:08 <newsham> "dont touch it, its pure evil!"
19:53:09 <lambdabot> forall a. (GHC.Exts.Splittable a, %evil::a, Num a) => a
19:53:18 <Pseudonym> ?where evil
19:53:18 * lambdabot 0wnZ j00!!!1!eleven
19:53:38 <rag3> > let f x = 1:1: ZipWith (+) x (tail x) in f 10
19:53:38 <lambdabot>   Not in scope: data constructor `ZipWith'
19:53:47 <newsham> dons: no @farber :(
19:53:47 <sorear> LOWERCASE z
19:53:49 <dons> why hasn't anyone sent me a patch yet
19:53:54 <LoganCapaldo> LOL
19:53:56 <LoganCapaldo> eleven
19:54:12 <rag3> > let f x = 1:1: zipWith (+) x (tail x) in f 10
19:54:12 <lambdabot>   add an instance declaration for (Num [a])
19:54:15 <ddarius> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in f!!10
19:54:16 <lambdabot>   Not in scope: `f'
19:54:20 <ddarius> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs!!10
19:54:22 <lambdabot>  89
19:54:31 <rag3> thanks ddarius
19:54:52 <rag3> isn't insane that a language allows you to work with infinity?
19:54:58 <sorear> ddarius: tsk tsk.  you can't serialize an IOUArray in pure code.  better to use a (Int,Nick)
19:55:07 <newsham> rag3: i dont see any infinities
19:55:28 <sorear> newsham: that's because you are thinking lazily.
19:55:33 <sorear> @quote whnf
19:55:33 <lambdabot> bd_ says: If a graph is reduced in a forest, and no one is around to pattern match the resulting WHNF, does it cause a space leak?
19:55:44 <rag3> newsham: [1..]
19:55:50 <newsham> am I thinking lazily when I write  "while(1) { ... }" ?
19:55:55 * ddarius didn't change the serialize code at all, just hoped for the best.  To just see if it compiles and does what it's supposed to do you could have it return Nothing.
19:55:57 <LoganCapaldo> wow
19:56:05 <newsham> rag3: wheres the infinity?
19:56:05 <LoganCapaldo> best koan ever
19:56:28 <mdmkolbe> I found my solution.  let groupBy' eq (x:xs) = (x:x'):groupBy' eq xs' where (x', xs') = partition eq x xs
19:56:52 <rag3> newsham: in the fact that [1..] represent a list of all integers greater or equal to one, and that you can treat it in Haskell just like if it was a finite value
19:57:08 * mdmkolbe now tried to go on that walk again (last time he only got 2 steps out the door before solving the problem)
19:57:09 <newsham> rag3: nah, it just represents as many integers as I need.
19:57:14 <newsham> i dont need them all.
19:57:59 <newsham> x = 1; while 1 : { print x; x += 1 }
19:58:07 <newsham> also represents many integers
19:58:47 <nmessenger> Haskell just allows you to pass around infinite loops and choose not to evaluate them all the way through if you don't want to.
19:58:49 <dons> i updated this page a great deal, http://haskell.org/haskellwiki/Blog_articles
19:58:51 <LoganCapaldo> I guess he had to go do some spice
19:58:51 <lambdabot> Title: Blog articles - HaskellWiki
19:59:00 <dons> now, the question is: who's going to step up and write the missing articles :-)
19:59:04 <ddarius> > unfoldr (const (Just 1)) undefined
19:59:05 <lambdabot>   add an instance declaration for (Num (a, b))
19:59:28 <ddarius> > unfoldr (const (Just (undefined,1))) undefined
19:59:29 <lambdabot>  Undefined
19:59:47 <newsham> > unfoldr (\x y -> Just 1) 1
19:59:48 <rag3> nmessenger: thanks, that's what I had in mind, but I didn't know how to express it
19:59:48 <lambdabot>      The lambda expression `\ x y -> ...' has two arguments,
19:59:48 <lambdabot>     but its type...
20:00:43 <sorear> ddarius: should I be trying to fix this?
20:01:00 <newsham> > unfoldr (\x -> Just (1,2)) 1
20:01:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:01:16 <newsham> i should learn haskell better :(
20:01:28 <nmessenger> > unfoldr (\x -> Just (x,succ x)) 1
20:01:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:01:50 * nmessenger hugs unfoldr
20:02:31 <bd_> > unfoldr (join (,) >>> right succ) 1
20:02:33 <lambdabot>  Couldn't match expected type `(b, b)'
20:02:43 <bd_> :t ((>>>) right succ)
20:02:45 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a, Enum (a (Either d b) (Either d c))) => a b c -> a (Either d b) (Either d c)
20:02:51 <bd_> > unfoldr (join (,) >>> second succ) 1
20:02:52 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
20:02:58 <bd_> :t second
20:03:00 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
20:03:11 <bd_> oh
20:03:12 <ddarius> sorear: No.  You can if you want, obviously.
20:03:15 <bd_> > unfoldr (fmap Just $ join (,) >>> second succ) 1
20:03:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:03:54 <newsham> > iterate (+1) 1
20:03:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:03:58 <nmessenger> > unfoldr (ap (,) succ) 1
20:03:59 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
20:04:04 <nmessenger> > unfoldr (Just . ap (,) succ) 1
20:04:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:04:07 <newsham> > iterate succ 1
20:04:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:04:10 <nmessenger> ap++
20:04:21 <dino-> @seen Cale
20:04:22 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 35m ago.
20:04:29 <Cale> hello
20:04:34 <dino-> Cale: hey
20:04:40 <dino-> Cale: I was just looking at your hrss.
20:04:55 <Cale> cool
20:05:04 <dino-> Cale: Did you explicitly need to re-store the title/link/desc into your Item data type?
20:05:15 <dino-> Because it's difficult to grab that data down in buildPage?
20:05:18 <Cale> No, I could have just used pairs.
20:05:37 <Cale> But this way is a bit cleaner, I think.
20:05:44 <dino-> Pairs of what?
20:05:49 <newsham> > scanl (+) 1 (repeat 0)
20:05:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:05:56 <newsham> > scanl (+) 0 (repeat 1)
20:05:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:06:20 <Cale> dino-: (String,(String,String)), most likely
20:06:28 <Cale> By just using ***
20:06:29 <nmessenger> > [1..] -- :P
20:06:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:06:38 <nmessenger> I win!
20:06:39 <dino-> Hm. I see. The arrow stuff.
20:07:09 <dino-> Having a great deal of trouble getting it with the arrows. And it's making the HXT difficult.
20:07:17 <newsham> > [0x7ffffffc..]
20:07:19 <lambdabot>  [2147483644,2147483645,2147483646,2147483647,2147483648,2147483649,214748365...
20:07:19 <LoganCapaldo> Someone needs to turn arrows into a video game
20:07:26 <LoganCapaldo> for easier explanation
20:07:35 <Cale> Have you seen the diagrams on haskell.org/arrows?
20:07:35 <LoganCapaldo> You could be an archer
20:07:45 <LoganCapaldo> and use various arrows to solve problems
20:08:12 <dino-> So, at every location where you did something like 'pure link', you couldn't just have done some kind of atTag .. thing.
20:08:20 <dino-> it's not that simple, I gather
20:08:31 <nmessenger> I cast +5 Phooey Arrow of UI on this application
20:08:32 <dino-> Cale: I read some of what's in the wikibooks.
20:08:38 <LoganCapaldo> exactly!
20:08:59 <Cale> dino-: Oh, I certainly could have done that.
20:09:01 <LoganCapaldo> Urban Combinator Warfare
20:09:03 <dino-> I read as much of Hughes as I could before getting lost, somewhere deep in the middle of explaining how the monadic parsing is a problem.
20:09:25 <Cale> dino-: That's just not how it came out, because the construction of the page was actually sort of an afterthought.
20:09:47 <Cale> I suppose one idea would be to try refactoring it like that.
20:10:10 <Cale> The way it's currently written makes it simpler to output other representations though.
20:10:35 <dino-> Yeah, like a reading and storing step happens.
20:10:36 <Cale> It's separated cleanly into input and output.
20:10:46 <nmessenger> Phunctional ooser ynterfaces ftw!
20:11:30 <LoganCapaldo> Functional UI :: (Oxymoron a, Pun a) => a ;)
20:11:30 <dino-> The truth is, this isn't even really my biggest point of trouble. You may remember I was asking about how to go about numbering data from some group of elements.
20:11:41 <monochrom> Learning is unlearning.
20:11:49 <Cale> ah
20:11:50 <nmessenger> parse error on token: `;)'
20:11:54 <Cale> yeah
20:12:03 <dino-> you had actually said something about using listA
20:12:05 <newsham> ?seen alexj
20:12:06 <lambdabot> alexj is in #happs and #haskell. I don't know when alexj last spoke.
20:12:08 <Cale> yeah
20:12:34 <dino-> I don't really understand what it does, though, yet.
20:12:40 <dino-> the listA
20:12:49 <bd_> :t listA
20:12:52 <lambdabot> Not in scope: `listA'
20:13:25 <dino-> :t Control.Arrow.ArrowList.listA
20:13:28 <lambdabot> Couldn't find qualified module.
20:13:30 <Cale> It takes a nondeterministic Arrow(List), a b c, that is, one which may return 0 or more results
20:13:44 <Cale> and gives a deterministic arrow a b [c]
20:13:55 <Cale> that is, it produces a list of results
20:14:35 <Cale> Did I talk with you about the list monad and LA last time?
20:14:37 <dino-> Having trouble getting what that means. Is it similar to something non-arrow-ic?
20:14:39 <Cale> Or was that someone else?
20:14:45 <dino-> Someone else, I think.
20:14:48 <Cale> okay
20:14:59 <Cale> Are you at all familiar with the list monad?
20:15:09 <dino-> A little. Probably moe than a little.
20:15:13 <dino-> s/moe/more/
20:15:19 <Cale> (I know we're dealing with arrows here, but monads are probably simpler to start with)
20:15:40 <Cale> Well, in the list monad, the basic idea is that "computations" produce 0 or more results.
20:15:59 <dino-> Although this still confuses me: filterM (const [True, False]) "abc"
20:16:02 <Cale> > do { x <- [1..10]; y <- [x..10]; return (x,y) }
20:16:04 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,2),(2,3),(2...
20:16:27 <Cale> > do { x <- [1..10]; y <- [x..10]; z <- [y..10]; guard (x^2 + y^2 == z^2); return (x,y) }
20:16:29 <lambdabot>  [(3,4),(6,8)]
20:16:33 <Cale> > do { x <- [1..10]; y <- [x..10]; z <- [y..10]; guard (x^2 + y^2 == z^2); return (x,y,z) }
20:16:35 <lambdabot>  [(3,4,5),(6,8,10)]
20:17:22 <dino-> Ok, so you're generating values of 3-tuples and putting them into a result list.
20:17:27 <Cale> A function (a -> [b]) can be thought of as a function which has 0 or more results.
20:17:48 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
20:18:34 <Cale> Bind takes a list of a's, alternately thought of as a "nondeterministic value", and one of these "nondeterministic" functions, and collects all the possible results.
20:20:00 <dino-> Ok. And part of it is they get joined together into one [b], the potentially many [b]s
20:20:18 <dino-> map then join, from your containers document.
20:20:22 <Cale> right
20:20:26 <sorear> ! seems to be broken at the repl ...
20:20:34 <sorear> @report sorear
20:20:34 <sorear-lambdabot> 0 0 0 0 @0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20:20:34 <lambdabot> sorear
20:20:36 <sorear> foo
20:20:42 <sorear> @report sorear
20:20:42 <sorear-lambdabot> 0 0 0 0 @0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20:20:42 <lambdabot> sorear
20:20:49 <sorear> @help reportj
20:20:50 <sorear-lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:20:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:20:53 <sorear> @help report
20:20:53 <sorear-lambdabot> report. Report the statistics for the given nick.
20:20:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:20:59 <sorear> sorear-lambdabot: @quit
20:21:00 <Cale> sorear: uh, what?
20:21:08 <sorear> ok, it is track that is broken.
20:21:11 <ddarius> Ah spell checking.
20:21:28 <Pseudonym> @report Pseudonym
20:21:29 <lambdabot> Pseudonym
20:21:32 <Pseudonym> Woo, nothing!
20:21:36 <Cale> dino-: Okay, so now, to the arrows view.
20:21:37 <Pseudonym> @report foo
20:21:38 <lambdabot> foo
20:21:53 <Pseudonym> @report TIME
20:21:54 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Illegal character ''\SOH''
20:22:01 <Pseudonym> Damn.
20:22:11 <Pseudonym> @report ACTION cries
20:22:12 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Illegal character ''\SOH''
20:22:16 <Pseudonym> Oh well.
20:22:17 <Cale> Most of HXT is based on an arrow called IOSLA, but there's a much simpler arrow which has all the important part for what we're talking about, called LA
20:22:21 <nmessenger> @report /me to the authorities
20:22:21 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
20:22:30 <sorear> @where+ echo VERSION
20:22:30 <dino-> IO State List Arrow?
20:22:31 <lambdabot> Done.
20:22:35 <sorear> @where echo
20:22:53 <dino-> Is this kind of like a super amazing tranformer of all of these things?
20:23:04 <Cale> newtype LA a b = LA { runLA :: a -> [b] }
20:23:32 <Cale> That is, a ListArrow from a to b is just a function from a's to lists of b's
20:23:33 <dino-> So, this LA (list arrow) is an arrow around a computation that goes from a to list of b.
20:23:46 <dino-> ok
20:23:58 <Cale> So it's rather like these nondeterministic functions I was talking about a moment ago
20:24:30 <Cale> You put things in one end of the arrow, and out comes 0 or more things for each that you put in.
20:24:39 <Pseudonym> http://en.wikibooks.org/wiki/Haskell/Understanding_monads
20:24:41 * ddarius doesn't think C# 3.0's local type "inference" stuff would help him with the usage of his HXT like library (not that it would help him anyways).
20:24:42 <Pseudonym> Quote from there:
20:24:48 <Pseudonym> Also, if you're not convinced that dollar is a useful thing to have, compare:
20:24:48 <Pseudonym> i ((h z) ((g y) (f x))) vs.
20:24:49 <Pseudonym> i $ h z $ g y $ f x
20:24:56 <Pseudonym> Erm.
20:25:12 <Pseudonym> I'm not convinced that you ever want to write either.
20:25:16 <dino-> Ok, like (isElem >>> hasName), may produce none, or one or all children that are elements with that name.
20:25:36 <Cale> Well, that alone is just going to give 0 or 1
20:25:52 <sorear> foo!
20:25:59 <sorear> sorear-lambdabot: @report sorear
20:25:59 <sorear-lambdabot> 0 0 0 0 @1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20:26:10 <sorear> it works?
20:26:13 <sorear> sorear-lambdabot: @report sorear
20:26:14 <sorear-lambdabot> 0 0 0 0 @2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20:26:20 <chessguy> 'evening haskellers
20:26:21 <ddarius> bar
20:26:26 <sorear> sorear-lambdabot: @flush
20:26:28 <ddarius> sorear-lambdabot: @report ddarius
20:26:28 <sorear-lambdabot> 0 0 0 0 @1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20:26:29 <nmessenger> baz!!
20:26:30 <Cale> It checks that the tree you pass it is an element, and that it has a given name. If that's true, you end up with just the same thing, if not, you get an empty list.
20:26:33 <sorear> sorear-lambdabot: @quit
20:26:38 <ivanm> sorear: did we really need another lambdabot on #haskell?
20:26:46 <Cale> Now, wrap that in deep, and things get more interesting.
20:26:52 <Pseudonym> Dammit, I was just about to get them into an infinite loop with each other.
20:27:00 <ddarius> UI-issue: Associating the hour with the count will probably be a heck of a lot more readable.
20:27:03 <dino-> Ok, I didn't realize that construction is for one.
20:27:22 <dino-> deep will get you all the siblings, but not go any further.
20:27:25 <sorear> ivanm: lambdabot has serious infrastructure porblems, we need a new one for testing.
20:27:28 <chessguy> ivanm, it's 1.) a backup, and 2.) (i suspect) a prototype for new ideas
20:27:41 <Cale> What deep does is to apply the given arrow to every subtree recursively, trying the children of a node when the node fails to give results.
20:27:44 <ivanm> oh, OK... my mistake
20:27:46 <Pseudonym> We don't prototype ideas on a TEST bot.
20:27:47 <Pseudonym> Hell no.
20:27:54 <Pseudonym> It compiles, ship it!
20:28:09 <ivanm> sorear: are you implementing independently of dons, or just testing out his code?
20:28:31 <Cale> Perhaps we should move to #haskell-overflow?
20:28:40 <dino-> sure
20:28:48 <monochrom> sad
20:29:01 <ddarius> sorear: Hmm. If you are not using IOUArrays, then you probably essentially completely rewrote my code.  Not that -any- of it is difficult.
20:29:34 <ddarius> Hmm, another feature might be @lively <hour> -> list of people
20:29:54 <newsham> how robust is hasktags?  I'm using it and it missed one of the symbols.  Worth reporting?
20:30:37 <sorear> ivanm: I pull from him, send him patches.  it's a branch.
20:30:58 <ivanm> Ahh, OK
20:31:07 <ivanm> two head are better than one, etc?
20:31:17 <ivanm> so what differences are you looking at implementing in yours?
20:31:23 <sorear> ivanm: none atm
20:31:25 <ddarius> lively :: Map Nick Int {- or whatever -} -> [Nick]; lively = map fst . sortBy (compare `on` snd) . toList
20:31:36 <sorear> ivanm: in the past I rewrote the protocol handling system
20:31:48 <sorear> ivanm: that diff no longer exists, dons took the patch
20:32:26 <ivanm> sorear: OK
20:32:44 <sorear> after ayhi loses my interest I'm probably going to adapt lambdabot to the happs architecture
20:33:03 * ddarius conjures up idea of semi-automagic #haskell -> wiki tutorial transformer.
20:33:21 <ttmrichter> OK, I'm tired.  Can anybody recommend to me a good general survey textbook of modern mathematics for computer science?
20:33:43 <sorear> @wikied HAppS_Tutorial 12-14s/foo/b\&ar/g
20:33:44 <lambdabot> http://www.haskell.org/haskellwiki/HAppS_Tutorial 12-14s/foo/b\&ar/g
20:33:47 <ddarius> @google modern mathematics for Computer science
20:33:48 <ivanm> ttmrichter: what part of maths?
20:33:50 <lambdabot> http://www.amazon.com/Algorithms-Modern-Mathematics-Computer-Science/dp/0387111573
20:34:23 <dons> ddarius: ?
20:34:48 <ddarius> dons: What's that ? with regards to?
20:36:47 <newsham> what's the proper place to report hasktags bug?  ghc bug tracker?
20:42:57 <dons> ddarius: you mentioned something about a wiki interface?
20:44:17 <ddarius> Basically have lambdabot log a channel to a wiki page.  I.e. the kind of stuff Cale and dino- are doing in #haskell-overflow.
20:45:12 <sorear> lambdabot already logs to a file...
20:45:21 <sorear> dons, ddarius: get the patches?
20:45:31 <dons> yep
20:45:32 <ddarius> sorear: Yes.
20:47:00 * sorear <3 parser combinators
20:47:13 <sorear> I have a yhc bytecode parser almost done on one screen.
20:47:15 <ddarius> I was thinking of something like @start-wiki-log <channel> @end-wiki-log [<channel>].  The former causing lambdabot to join and log <channel> the latter causing it to write the log to (f <channel>) on haskellwiki.
20:53:59 <chessguy> ?vera ISR
20:54:03 <lambdabot> *** "isr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
20:54:03 <lambdabot> ISR
20:54:03 <lambdabot>      Interrupt Service Routine
20:54:03 <lambdabot>  
20:54:03 <lambdabot> *** "isr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
20:54:05 <lambdabot> [7 @more lines]
20:54:15 <chessguy> @more
20:54:16 <lambdabot> ISR
20:54:16 <lambdabot>      Interrupt Service Register (IC)
20:54:16 <lambdabot>  
20:54:16 <lambdabot> *** "isr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
20:54:16 <lambdabot> ISR
20:54:18 <lambdabot>      Interrupt Service Request
20:54:20 <lambdabot>  
20:54:21 <chessguy> bah
20:54:29 * zbrown is happy now :)
20:54:35 * zbrown got his 3x+1 conjecture program to work
20:54:59 <monochrom> That there are infinitely many composite numbers of the form 3x+1?
20:55:34 <zbrown> monochrom: no, if the number is even, you divide it by 2, if its odd, you multiply by 3 and add 1, and eventually you will reach the number '1'
20:55:38 <sorear> zbrown: it has a name :)  collatz
20:55:50 <zbrown> sorear: it has many names ;)
20:55:55 <sorear> @google Collatz conjecture
20:55:57 <zbrown> Okasaki
20:55:57 <lambdabot> http://en.wikipedia.org/wiki/Collatz_conjecture
20:56:20 <zbrown> sorear: see, "3n+1 conjecture" ;_)
20:56:28 <sorear> I didn't know that.
20:56:43 <chessguy> n is a much better variable name than x for this
20:56:44 <monochrom> I need to think of a better joke.
21:01:19 <hpaste>  zbrown pasted "3x+1 Conjecture" at http://hpaste.org/719
21:01:38 <zbrown> monochrom: ^^ there you go
21:01:48 <zbrown> though no one tell me how to optimize it or make it shorter...
21:01:52 <zbrown> ill figure it out on my own :)
21:03:11 <ddarius> zbrown: You have a love of parens and a disdain for syntactic sugar.  Also the answer can be a one-liner.
21:04:24 <zbrown> ddarius: hehe i know, and i figured it could be a one-liner
21:04:33 <zbrown> im just learning how to get it that way :)
21:05:43 <zbrown> ddarius: the parantheses are more for me than anything
21:06:52 <hpaste>  dons annotated "3x+1 Conjecture" with "for zbrown" at http://hpaste.org/719#a1
21:07:14 <dons> zbrown: just a little refactor, to give some hints on idiomatic/cuter code
21:08:36 <zbrown> dons: what is 'liftM'?
21:08:55 <dons> that lifts read into the monad. so instead of writing:
21:09:00 <dons> x <- getLine
21:09:02 <dons> let y = read x
21:09:04 <dons> you can write
21:09:09 <dons> y <- liftM read getLine
21:09:10 <dons> or
21:09:12 <zbrown> oic
21:09:15 <dons> y <- getLine >>= return . read
21:09:23 <dons> y <- getLine >>= \x -> return (read x)
21:09:48 <dons> I always forget readLn though!
21:09:51 <dons> :t readLn
21:09:53 <lambdabot> forall a. (Read a) => IO a
21:09:54 <nmessenger> @src liftM
21:09:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:10:00 <nmessenger> @. undo src liftM
21:10:01 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
21:10:09 <dons> @undo do { x1 <- m1; return (f x1) }
21:10:10 <lambdabot> m1 >>= \ x1 -> return (f x1)
21:10:15 <dons> @. pl undo do { x1 <- m1; return (f x1) }
21:10:16 <lambdabot> f `fmap` m1
21:10:25 <dons> liftM f m1 == f `fmap` m1
21:10:31 <rahikkala> @type return . read =<< getLine
21:10:33 <Pseudonym> @src liftM
21:10:34 <lambdabot> forall b. (Read b) => IO b
21:10:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:10:36 <nmessenger> pl thinks Monad should subclass Functor, too :)
21:10:42 <fantasma> is there a way to change the case of the letters in my username on the wiki?
21:10:45 <dons> so actually,     num <- readLn
21:10:46 <dons> is better
21:11:00 <dons> fantasma: hmm. create a new account?
21:11:17 <dons> zbrown: so how's the first 5 hours of haskell been? :-)
21:11:24 <fantasma> dons, i want the same username, just different case
21:11:29 <Pseudonym> zbrown: Written a compiler yet?
21:11:39 <zbrown> dons: well not so much the first five hours as the first five hours or actually writing code ;)
21:11:40 <Pseudonym> Or at least a monad tutorial?
21:11:40 <dons> zbrown: btw, I started collecting math+haskell blog articles, http://haskell.org/haskellwiki/Blog_articles#Maths
21:11:42 <lambdabot> Title: Blog articles - HaskellWiki
21:11:43 <zbrown> Pseudonym: working on it
21:11:55 <zbrown> dons: ah cool
21:11:57 <dons> fantasma: hmm. i'm not sure that's possible
21:12:20 <dons> zbrown: one nice one, in particular, http://sigfpe.blogspot.com/2006/01/eleven-reasons-to-use-haskell-as.html
21:12:23 <lambdabot> Title: A Neighborhood of Infinity: Eleven Reasons to use Haskell as a Mathematician, http://tinyurl.com/2dufqz
21:12:32 <fantasma> dons, I entered it all lowercase at creation and then it made the 1st one uppercase
21:12:35 <dons> you can send that to your C programming buddies :)
21:12:45 <dons> fantasma: ah ok. that's MediaWiki for you
21:12:52 <Pseudonym> What we really need here is some kind of trackback system.
21:12:57 <dons> Pseudonym: right.
21:12:59 <Pseudonym> To update the list automaticaly.
21:13:02 <dons> too hard to maintain manually.
21:13:12 <dons> at least though, i can generate the page from the HWN archives
21:13:17 <Pseudonym> True.;
21:13:25 <dons> the categorisation is the main thing.
21:13:33 <dons> and i doubt any trackback system is up to that task
21:14:03 <monochrom> I want to use Haskell as a mathematician.  But Haskell is dead.  I can't use him anymore.
21:14:22 <fantasma> dons, do you have administrative access to the wiki?
21:14:41 <zbrown> dons: thanks :)
21:15:12 <dons> fantasma: nope.
21:15:29 <dons> monochrom: you can dig up his corpse and use that, "weekend at bernie" style
21:16:03 <ddarius> He's been dead long enough that I think it would be noticable.
21:16:16 <Pseudonym> I'm not sure that he'd appreciate the language, personally.
21:16:22 <Pseudonym> Turing would not have appreciated Turing.
21:16:30 <Pseudonym> And I think it's arguable that Goedel would not have appreciated Goedel.
21:16:42 <Pseudonym> And don't get me started about Ada on Ada.
21:18:34 <LoganCapaldo> MMm, hot Ada on Ada action
21:23:37 <fantasma> who here has the highest authority when it comes to the wiki?
21:24:05 <rag3> fantasma: God
21:24:13 <sorear> AsheleyYakeley
21:24:16 <rag3> fantasma: just kidding :-)
21:24:36 <fantasma> thanks sorear
21:24:45 <sorear> dunno her nic
21:25:14 <rag3> who are the creators of Haskell?
21:25:25 <sorear> the Haskell Committee
21:25:34 <sorear> yes, this is a committee lang
21:26:01 <sorear> Wadler, Augustsson (augustss), Simon PJ, etc etc
21:26:13 <LoganCapaldo> eek
21:26:24 <LoganCapaldo> famous people hang out in here?
21:26:25 <Pseudonym> A few of them are out now.
21:26:30 <sorear> http://haskell.org/onlinereport/  down to the bottom
21:26:32 <lambdabot> Title: The Haskell 98 Language Report
21:26:36 <Pseudonym> Phil Wadler doesn't get involved any more, I think.
21:27:50 <rag3> so do we ever see Simon PJ in chat?
21:27:54 <sorear> I'm reading the implementation of functional programming languages and it seems like every third citation is "Augustsson [1984]"
21:28:00 <rag3> I know he's a guru working at microsoft research
21:28:08 <Pseudonym> rag3: Not here, no.
21:28:20 <sorear> Marlow and Lyagnh are here often, however
21:28:27 <sorear> (JaffaCake/Igloo)
21:28:32 <rag3> thanks
21:28:44 <rag3> is there a Haskell Conf 2007
21:28:48 <sorear> er, Lynagh
21:28:52 <sorear> sorry
21:29:54 <dibblego> what was the name of that game written in haskell?
21:30:00 <sorear> @where Frag
21:30:01 <lambdabot> http://www.haskell.org/haskellwiki/Frag
21:30:01 <Pseudonym> Tetris?
21:30:05 <dibblego> ah thanks
21:30:05 <Pseudonym> Tic-Tac-Toe?
21:30:15 <Pseudonym> Hunt the Wumpus?
21:30:16 <sorear> we've also got a nethack clone IIRC
21:30:23 <Pseudonym> Actually, Wumpus would make a fun game.
21:30:35 * Pseudonym wants to see a FPS version of Hunt the Wumpus.
21:32:25 <rag3> are there examples that concisely show the full power of haskell versus well versed languages like python, ruby or perl?
21:33:35 <rufius> well versed?
21:33:53 <rag3> I mean, it's easy to show power over low level languages (C), or verbose crappy ones (Java)... but how about Ruby that has OO and Functional aspects as well.
21:34:27 <rag3> are there concrete examples that shows: look in Ruby is a mess to accomplish this. In Haskell is 3 lines.
21:34:55 <sorear> rag3: how easily can you print the entire list of fibonacci numbers in Ruby?
21:34:59 * rufius wonders how one would write a prog to calculate fibonacci numbers in ruby?
21:35:02 <rufius> lol
21:35:10 <sorear> > fix ((1:) . scanl (+) 1)
21:35:12 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:35:19 <Boney> rag3: It really depends what you want to do with said languages.
21:35:19 <sorear> shorter than that?
21:35:26 <Boney> they are all tools for a job.
21:35:41 <Boney> See.  Haskell is brillient for computing the fibonacci sequence.
21:35:55 <rufius> haskell is far superior if you're trying to preserve mathematical foundations... as i am in my work  :-D
21:36:30 <Boney> Java can,  urr.  XML something.  um, Enterprise ready..  Bingo?
21:36:30 <ddarius> @where whyfp
21:36:31 <lambdabot> I know nothing about whyfp.
21:36:41 <ddarius> @google Why Functional Programming Matters
21:36:44 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
21:36:45 <lambdabot> Title: Why Functional Programming Matters
21:37:35 <fantasma> what time is Ashely usually on?
21:38:14 <ddarius> That question and more will be answered by Track module
21:39:16 <sorear> first we need to know her nick
21:39:42 <sorear>  /whois *ake* *ely* give nil
21:40:06 <jcreigh> rag3: I'm not entirely convinced that language comparisions can be make simple and small. Anything that's only a couple lines is not going to show any overpowering advantage.
21:40:18 <jcreigh> s/make/made/
21:40:18 <rag3> @where pastie
21:40:19 <lambdabot> I know nothing about pastie.
21:40:24 <jcreigh> @paste
21:40:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:40:33 <dons> jcreigh: how about the ICFP contest? :-)
21:40:47 <ddarius> jcreigh: Unless it cannot be written in a couple of lines in the other language.
21:40:53 <dons> it shows one thing: given 3 days you're less likely to produce code that crashes on testing in Haskell, than in C
21:40:56 <sorear> er, oops
21:41:17 <ddarius> Hopefully, even given a lot more time that remains true.
21:41:24 <hpaste>  rag3 pasted "Fibonacci in Ruby" at http://hpaste.org/720
21:41:28 <sorear> google found Ashley Yakeley's website
21:41:47 <LoganCapaldo> def fib(n) if n == 0 or n == 1 then 1 else fib(n - 1) + fib(n - 2) end # the lame recursive version
21:41:58 <fantasma> that's a fast algorithm ;)
21:42:00 <LoganCapaldo> I forget an end
21:42:37 <rag3> that's not mean to be fast fantasma. In Ruby it will particularly slow as well.
21:42:49 <LoganCapaldo> super duper slow :)
21:43:05 <LoganCapaldo> and eat your stack like candy
21:43:26 * LoganCapaldo yells at ruby to stop using the C stack
21:43:37 <hpaste>  jcreigh annotated "Fibonacci in Ruby" with "ruby fib, with blocks" at http://hpaste.org/720#a1
21:43:56 <fantasma> > let x = fix ((1:) . scanl (+) 1) in length . show $ x !! 2^15
21:43:57 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
21:43:58 <lambdabot>  5
21:43:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:44:04 <monochrom> are you saying ruby should use the ruby stack instead?
21:44:08 <sorear> LoganCapaldo: what's wrong with the C stack?  ayhi uses the hardware stack!
21:44:09 <dons> rag3: ruby is too verbose! ;)
21:44:31 <rag3> dons: eheheh
21:44:35 <fantasma> > let x = fix ((1:) . scanl (+) 1) in length . show $ x !! 2^20
21:44:36 <lambdabot>  7
21:44:41 <fantasma> ......
21:44:50 <LoganCapaldo> I want my green threads and my callccs not to copy the whole freaking stack
21:44:59 <dons> all those 'end' blocks. grr. you'd think the ruby guys had never seen haskell's layout when they came up with that ;)
21:44:59 <rag3> jcreigh: your version is much nicer
21:45:07 <LoganCapaldo> also it would nice if exception weren't implemented in terms of setjmp and longjmp
21:45:33 <LoganCapaldo> dons: you want we should write it in python? :)
21:45:34 <dons> > unfoldr (\(f1,f2) -> Just (f1,(f2,f1+f2))) (0,1)
21:45:36 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:45:46 <fantasma> what's wrong with this code
21:45:48 <fantasma> > let x = fix ((1:) . scanl (+) 1) in length . show $ x !! 2^20
21:45:50 <lambdabot>  7
21:45:56 <jcreigh> rag3: well, it's nicer for printing out the sequence. Calculating some arbitrary fib(n) is harder...
21:46:11 <rag3> jcreigh: agreed
21:46:19 <dons> fantasma: hmm, integer overflow?
21:46:24 <fantasma> you can use phi to calculate fib(n)
21:46:31 <jcreigh> of course, you can always go with the Hash default value trick for memoization...
21:46:34 <dons> > let x = fix ((1:) . scanl (+) 1) in x !! (2^20)
21:46:37 <lambdabot>  Exception: stack overflow
21:46:39 <ddarius> > iterate (\(a,b) -> (b,a+b)) (0,1)
21:46:40 <lambdabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89),...
21:46:42 <monochrom> > let fib = array (0,10) ( (0,1) : (1,1) : [ (i, fib!(i-1) + fib!(i-2)) | i<-[2..10] ] ) in fib
21:46:44 <lambdabot>  array (0,10) [(0,1),(1,1),(2,2),(3,3),(4,5),(5,8),(6,13),(7,21),(8,34),(9,55...
21:46:46 <dons> > let x = fix ((1:) . scanl (+) 1) in show (x !! (2^20))
21:46:49 <lambdabot>  Exception: stack overflow
21:46:57 <rag3> small survey of the Haskell community here... how many of you are studying for a PhD or have a PhD?
21:47:00 <fantasma> ah
21:47:05 * ddarius isn't.
21:47:07 * dons raises hand
21:47:12 <monochrom> Yes.
21:47:19 <TSC> Me too
21:47:25 <dons> rag3, its something like 5% of the channel.
21:47:29 * sorear is far too young to easily get one
21:47:34 <dons> > 5/330
21:47:36 <lambdabot>  1.5151515151515152e-2
21:47:49 <dons> well, ok. 1.5%
21:47:55 <sorear> yay! my .hbc parser in ~50 lines works
21:48:00 <monochrom> 330 is hardly the real size of the channel.
21:48:06 <dons> monochrom: no?
21:48:26 <sorear> @users
21:48:27 <lambdabot> Maximum users seen in #haskell: 332, currently: 283 (85.2%), active: 42 (14.8%)
21:48:27 <jcreigh> almost everybody is just idling.
21:48:31 <dons> explain why, after the big freenode shutdown a month ago or so, we had 310 people rejoined the next day :-)
21:48:31 <nmessenger> classical logic *is* a monad!
21:48:37 <monochrom> I am more comfortable counting just those who have spoken in the past 30 days or something.
21:48:38 <rag3> dons: is it normal that moving the first steps with Haskell made me question my programming abilities? I feel like I need to go back and study the basics. :(
21:48:42 <sorear> nmessenger: duh! :)
21:48:48 <hpaste>  LoganCapaldo annotated "Fibonacci in Ruby" with "Now with more state" at http://hpaste.org/720#a2
21:48:50 <ddarius> autojoin
21:48:59 <monochrom> Everything is a monad.
21:49:04 * nmessenger head a splode
21:49:15 <jcreigh> LoganCapaldo: couldn't resist, eh? :)
21:49:16 <dons> rag3, yeah, that's normal. it makes you wonder what on earth they were teaching you at uni :-)
21:49:27 <dons> and why they didn't mention, you know, types, recursion, monads, ... ;)
21:49:29 <monochrom> But how is classical logic a monad?  Who are return and bind/join?
21:49:50 <monochrom> Learning is unlearning.
21:49:54 <sorear> monochrom: cont!
21:50:02 <dons> we could tweak the @active plugin to report active over a specified period of time
21:50:08 <rag3> dons: do you think having the pdf of A Gentle Introduction to Haskell and the SICP open on my pc, is a good starting setup?
21:50:08 <dons> e.g. @active 1month
21:50:12 <monochrom> Oh, cont, yeah, now I remember.
21:50:17 <dons> ?where yaht
21:50:17 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:50:20 <LoganCapaldo> fyi, my code is invalid syntax
21:50:21 <dons> is maybe even better to start
21:50:22 <LoganCapaldo> err
21:50:26 <LoganCapaldo> not invalid syntax
21:50:26 <jcreigh> @where YAHT
21:50:27 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:50:27 <dons> + SICP + the haskell wikibook
21:50:30 <LoganCapaldo> just broken :)
21:50:43 <sorear> newtype Classical a = Classical (Cont Void a) deriving (Monad)
21:50:47 <jcreigh> rag3: ^^ "Yet Another Haskell Tutorial" is good, if you're just starting out in Haskell.
21:50:49 <dons> rag3, and hang out here for 6 months, try to answer questions that pop up, and you'll be a guru :-)
21:50:50 <LoganCapaldo> stupid scope
21:51:25 * dons tries to work out who's spoken in the last month
21:51:29 <dons> i suspect around 300 people :-)
21:51:42 <siti> @where stats
21:51:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
21:51:44 <monochrom> 100 is my guess.
21:51:58 <siti> there can't be that many lurkers!
21:52:05 <rag3> dons:I'm kind of attracted by the idea of founding a company one day based on Haskell
21:52:08 <hpaste>  nmessenger pasted "#haskell-overflow log pt. 1 for monochrom" at http://hpaste.org/721
21:52:37 <hpaste>  nmessenger annotated "#haskell-overflow log pt. 1 for monochrom" with "pt 2" at http://hpaste.org/721#a1
21:52:40 <siti> I need 700 more to be in the top 25 :)
21:53:16 * jcreigh pictures legions of lambdabots...
21:53:24 <monochrom> When I was young I was devious.  I and my friend would guess numbers of the form "how many ___ are there?"  Say he guessed first and he guessed "300".  If it was clear to both of us that most probably the correct answer was to be a bit below 300, I would then guess "299". :)
21:53:47 <dons> monochrom: 771 unique nicks have spoken in the last month
21:53:57 * monochrom 's head explodes
21:54:07 <dons> http://www.cse.unsw.edu.au/~dons/tmp/uniq_names.txt
21:54:09 <rag3> dons: those are the funniest statistics I've ever seen
21:54:33 <siti> dmead has quite a potty mouth.  0.1% words were foul language.
21:54:39 <siti> siti brings happiness to the world.  28.3% lines contained smiling faces.  :)  yay
21:54:54 <nmessenger> does it count big smilies :D
21:54:58 <jcreigh> but that counts, eg, both jcreigh and jcreigh_
21:54:59 <monochrom> This is very counterintuitive because every day I'm seeing essentially the same 30 or even just 15 people.
21:55:01 <siti> I don't think so :(
21:55:21 <dons> 422 unique nicks in the last week
21:55:31 <rag3> @quote monochrom
21:55:32 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
21:55:32 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
21:55:36 <dons> so, how about people who've said more than 10 things?
21:55:46 <monochrom> Are you sure you are just counting #haskell and no other channels?
21:56:08 <dons> 253 people in #haskell have said more than 10 lines of text in the last week
21:56:16 <dons> monochrom: i'm using my #haskell logs
21:56:19 <dons> ?where darcs-logs
21:56:20 <lambdabot> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/irc-logs
21:56:34 <dons> so 253 active users a week
21:56:36 <dons> sounds reasonable, no?
21:56:47 <dons> now, who's buying me that beer?
21:57:07 <hpaste>  bos pasted "typechecking horror" at http://hpaste.org/722
21:57:17 <dons> really, its kinda intuitive, there's between 40-60 active people in each four hour period, 24 hours a day.
21:57:30 <dons> and not many are here for more than 4 hours at a stretch
21:57:38 <dons> maybe just the top 20 or so users
21:57:49 <monochrom> Damn. I need to watch this channel more.
21:58:12 <bos> the compiler spews about inability to deduce context for each of the functions in the generic function
21:58:17 <rag3> would be possible to create a Haskell on Rails, or it would be extremely complex?
21:58:28 <monochrom> And hunt down these other 660 people.  And eliminate them!
21:58:36 <dons> should be easy,rag3. a DSL for building web apps, yeah?
21:58:46 <dons> so like HApps, (e.g. hpaste.org built on haskell) but with more sugar?
21:58:48 <bos> rails is a lot more than that, though.
21:58:50 * qwr wishes that ruby/python would fix their scoping. for a start...
21:58:59 <dons> bos, right. do you have any thoughts on this?
21:59:02 <dons> what would it take?
21:59:16 <dons> DSL + fast threads + bytestring network IO == rails profit?
21:59:21 * rahikkala looks at the most used words list
21:59:26 <qwr> haskelldb too?
21:59:44 <dons> ah right. db backends. persistence via Data.Binary
21:59:45 <rahikkala> "lambda" isn't there :( ... I guess we're all just too used to \
21:59:46 <rag3> dons: and shit lots of Marketing
21:59:48 <dons> xml
21:59:51 <dons> and marketing
22:00:06 <dons> the technical aspects are pretty easy, as far as I can see.
22:00:14 <bos> decent database integration, automated derivation of code with TH, good networking.
22:00:18 <dons> and should in fact be nicer in haskell, given fast concurrency, and good DSL support
22:00:25 <LoganCapaldo> and clever screencasts that create blogs in short periods of time
22:00:29 <LoganCapaldo> thats the most vital part
22:00:42 <Cale> bos: It's possible that some functional dependencies would help it infer the desired types there.
22:01:00 <Cale> bos: One problem is that it can't possibly know which s to use.
22:01:06 <rag3> ok so here I've a question. Does Haskell uses multiple processors available? Ruby doesn't really.
22:01:21 <monochrom> rag3: I particularly like "Bottoms Are Forever", "iterate Never Dies", and "unsafePerformIO Is Not Enough". :)
22:01:31 <bos> Cale: hmm, don't know enough about fundeps to cause things to work.
22:01:42 <dons> rag3, yes. smp support is built into ghc 6.6
22:01:49 <Cale> rag3: yes. You can even adjust the number of processors to use on the commandline to your compiled app.
22:01:52 <dons> rag3, so e.g. run your app on a 16 core box with +RTS -N16
22:01:54 <bd_> rag3: yes, if you use GHC 6.6, build with -threaded, and run with +RTS -N<number of processors> . And code in such a way that it has work for them :)
22:01:56 <dons> and you get 16 cores :-)
22:02:04 <monochrom> It is arguable that "RealWorld# Is Not Enough" is even better. :)
22:02:13 <Cale> bos: perhaps something like e -> r s
22:02:15 <dons> haskell's supported multiple processors since around 1990 in one form or another
22:02:22 <rag3> damn! You don't want me to get any sleep, do you?
22:02:27 <bos> Cale: whoa!
22:02:29 <Cale> bos: Which means that there's a single r and s for each endpoint type e.
22:02:37 <bos> it works. but i don't know why! ah.
22:02:51 <dons> rag3, I run my threaded haskell apps on a 16 way machine, which works rather nicely
22:02:56 * LoganCapaldo continues to successful procrastinate
22:02:57 <rahikkala> From IO With Love
22:03:03 <LoganCapaldo> I need to disable irc
22:03:04 <Cale> It will not let you write multiple instances of Endpoint for a given e though.
22:03:16 <LoganCapaldo> @slap LoganCapaldo
22:03:16 <lambdabot> why on earth would I slap LoganCapaldo
22:03:19 <bos> that would be bad.
22:03:24 <LoganCapaldo> @slap LoganCapaldo
22:03:24 * lambdabot slaps LoganCapaldo
22:03:35 <rag3> rag3: I'm speechless. That's going to be 100 times faster than a typical Ruby on Rails application
22:03:36 <bd_> @slap lambdabot
22:03:37 <lambdabot> why on earth would I slap lambdabot
22:04:05 <rag3> @slap > id
22:04:06 <lambdabot> why on earth would I slap > id
22:04:23 <monochrom> @botsnack
22:04:23 <lambdabot> :)
22:04:28 <monochrom> @slap > id
22:04:29 * lambdabot smacks > id about with a large trout
22:04:36 <monochrom> That does the trick.
22:04:48 <Cale> @slap why on earth would I slap
22:04:48 * lambdabot beats up why on earth would I slap
22:05:06 <bos> Cale: i think that's a fine restriction.
22:05:18 <rag3> @slap lambdab0t
22:05:18 * lambdabot smacks lambdab0t about with a large trout
22:05:20 <dons> rag3, I shouldn't keep pointing this out, but say you had to choose between two high level languages, one with smp support starting with 'H', and another starting with 'R'. Both had fun communities, and then you saw this graph:  http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ruby
22:05:22 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/veo3w
22:05:25 <dons> :-)
22:05:26 <Cale> bos: okay, cool :)
22:05:27 <bos> i wish there existed fundep documentation that didn't cause instantaneous cranial expansion.
22:05:35 <bos> Cale: thank you!
22:05:59 <dibblego> is there something like Data.Set that permits duplicates?
22:06:04 <dons> Data.List
22:06:05 <rag3> dons: :-P
22:06:15 <dibblego> but has an ordered traversal
22:06:21 <Cale> bos: That's sort of "all there is to it" -- you specify which types uniquely determine which other types, and it uses that information to help type inference go smoothly.
22:06:34 <dons> rag3, I guess you can tell that I think we've a better product :-)
22:06:41 <rag3> dons: also... we're going towards processors with always more cores. smp is fundamental. isn't it?
22:06:41 <monochrom> Oh! Someone needs to implement "MultiSet"
22:06:42 <Cale> dibblego: Map a Nat
22:06:49 <dons> rag3, i think so.
22:06:56 <dons> so does the 16 core amd64 on the desk next to me.
22:06:58 <nmessenger> Haskell on Highways? :)
22:06:59 <Cale> (or, Map a Integer, for convenience)
22:07:09 <monochrom> Haskell on Crack.
22:07:22 <rag3> nmessenger: do you release the name in case I decide to build something in 6 months?
22:07:23 <LoganCapaldo> Wouldn't MultiSet just be Set (a, Integer) ?
22:07:23 <dons> rag3, really, if everyone has, say, 8 cores, they're not going to be happy with 12% cpu utilisation
22:07:23 <nmessenger> not very marketable
22:07:25 <dibblego> yeah could do that
22:07:35 <dibblego> LoganCapaldo, Set has only one type parameter
22:07:40 <nmessenger> rag3: consider it released
22:07:42 <Cale> fix (Haskell `on`)
22:07:50 <LoganCapaldo> yeeeees?
22:07:50 <rag3> nmessenger: thanks :-P
22:08:13 <nmessenger> so its a set of a/Integer pair
22:08:14 <monochrom> MultiSet can be implemented by a Map _ Integer.  The API looks a bit different.
22:08:14 <LoganCapaldo> I only gave it one type as far as I know
22:08:24 <dibblego> oh sorry, my bad
22:08:48 <dibblego> I've only just switched back to haskell from another language - tricky
22:09:05 <LoganCapaldo> Map is probably the better way to do it
22:09:25 <Cale> What we really need and don't have is Data.Relation. I happen to know Wolfram Kahl has a great implementation of it, but I'm not sure if he's planning on Cabalising it or releasing it at all or what. :)
22:09:34 <LoganCapaldo> Cause if you do Set (Int, Integer) you could end up with (2,3) and (2, 4)
22:09:59 <monochrom> Ha, actually, if (==) on "a" is just an equivalence relation and not full equality, MultiSet a is not going to be isomorphic to Map a Nat.
22:10:02 <siti> @where Data.Relation
22:10:03 <lambdabot> I know nothing about data.relation.
22:10:09 <dons> ?where yhc-bugs
22:10:10 <lambdabot> http://code.google.com/p/yhc/issues/list
22:11:02 <LoganCapaldo> monochrom: I wish you would speak english for us slow people :)
22:11:27 <monochrom> There is no english counterpart for this concept.
22:11:43 <monochrom> But since you all know haskell I can speak Haskell.
22:12:11 <Cale> http://www.di.uminho.pt/~joostvisser/software/UMinhoHaskellSoftware-1.0/index.html -- oh look
22:12:16 <lambdabot> http://tinyurl.com/2btmnh
22:13:12 <monochrom> If you re-define (==) so that ("mono", "foo") == ("mono", "bar")  (there are many applications for this kind of thing), inserting both into a MultiSet is not the same as inserting ("mono","foo") twice.
22:13:59 <dibblego> > ("mono", "foo") == ("mono", "bar")
22:14:00 <lambdabot>  False
22:15:01 <nmessenger> newtype FstEq a b = FE (a, b); instance Eq FstEq where FE x == FE y = ((==) `on` fst) x y
22:15:15 <LoganCapaldo> monochrom: Why not?
22:15:44 <LoganCapaldo> Won't the MultiSet effectively ignored the second member of the tuple?
22:15:54 <LoganCapaldo> s/ignored/ignore/
22:16:54 <monochrom> The usual expectation and application of MultiSet is, if you insert FE("mono","foo") and FE("mono","bar"), then later when you ask for all elements, you will get FE("mono","foo") and FE("mono","bar").
22:17:11 <LoganCapaldo> Ah
22:17:24 * nmessenger was useful :D
22:17:39 <LoganCapaldo> Could you not then leave == alone and define equiv in addition to == ?
22:18:05 <monochrom> OK, then you tell MultiSet to use equiv rather than ==. Same difference.
22:18:28 * LoganCapaldo is not getting it
22:18:44 <LoganCapaldo> Aren't you going out of your way to make it difficult on yourself?
22:19:24 <monochrom> OK, yes, this is too complicated for MultiSet.
22:19:43 <dancor> what kind of things are the slowest in haskell
22:19:44 <monochrom> MultiSet may as well just keep counts.
22:19:52 <dancor> that are fast in like c
22:19:56 <ddarius> dancor: stupid things
22:20:04 <dancor> ddarius: how stupid
22:20:12 <monochrom> Now, MultiMap is completely another story, and I have all along been having MultiMap in mind.
22:20:14 <jcreigh> dancor: O(n^2) is slow in Haskell. :)
22:20:17 <dons> dancor: you mean: identical data structure and code?
22:20:27 <LoganCapaldo> heh
22:20:31 <ddarius> I was answering your first part.  How stupid?  Insanely stupid.
22:20:37 <dons> one could argue that naive mutable arrays are slower in haskell than C.
22:20:53 <dons> then again, things like binarytrees and threads are faster in haskell than C.
22:20:57 <dons> oh, [Char] is slower than char *
22:21:01 <bos> also, haskell's native strings aren't winners.
22:21:01 <jcreigh> segfaults are slower.
22:21:02 <monochrom> Crashing the computer is fast in C, slow in Haskell.
22:21:04 <dons> so you should use char * :-)
22:21:15 <ddarius> Of course, a lot of things that make idiomatic Haskell slow simply aren't doable in C in any sane way.
22:21:30 <dons> idiomatic haskell isn't so slow these days though.
22:21:40 <dons> and its cheaper now to make it fast, than it used to be
22:21:41 <nmessenger> the cool thing, though, is that composing O(foo) and O(bar) isn't necessarily O(foo*bar)
22:21:50 <dons> yeah, yay for fusion
22:21:58 <ddarius> Yes, but the things that -do- make it slow usually aren't doable in C.
22:22:03 <dons> right.
22:22:33 <dons> dancor: do you have a flavour now for why your question is hard to answer?
22:22:50 <dons> maybe we should ask: what kinds of things are the slowest in C, that aren't slow in Haskell?
22:22:51 * LoganCapaldo asks the same question, backwards
22:23:03 <LoganCapaldo> Or dons could ask it :)
22:23:19 <dancor> well i'm looking at the c vs ghc shootout
22:23:20 <nmessenger> LoganCapaldo: C is slow at producing readable code :D
22:23:23 <dancor> and thinking about life
22:23:30 <dons> apprently threads are much slower in C.
22:23:35 <dufflebunk> Whoa, A search for haskell on yahoo gave man an add for ebay titled "Haskell for Less"
22:23:36 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=gcc&lang2=ghc
22:23:38 <dons> here?
22:23:38 <lambdabot> Title: C gcc benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ..., http://tinyurl.com/2eybmm
22:23:45 <jcreigh> Programming is really slow in C. Write a linked list library for Nth time. Gah.
22:23:47 <bos> Cale: i have another question.
22:23:56 <dons> i think that page gives a pretty reasonable picture of what writing high perf haskell in ghc 6.6 can get you
22:24:02 <dons> compared to high perf C.
22:24:14 <dons> apparently, strings and threads are haskell's advantage :-)
22:24:15 <siti> jcreigh: that's a library issue, glib provides linked lists
22:24:18 <alexj> dons: or ask how many lines of code it takes to achieve the same performance for a particular algorithm.
22:24:29 <dons> yeah, that's really a more important issue
22:24:35 <dons> since only that can explain the rise of Ruby ;)
22:24:49 <dons> speed clearly doesn't matter
22:24:57 <dons> think how many people use python for numerics
22:25:11 <siti> glib provides basically everything that c needs as a base, it's just very verbose and repetitive compared to other languages
22:25:23 <bos> Cale: in that recv declaration, i'm saying "recv :: e -> IO (e, r)" but i'd like the second e to be any instance of Endpoint, not necessarily just e. can i express this at all?
22:25:37 <siti> space leaks are easy in haskell and hard in c :p
22:25:40 <dancor> like why is k-nucleotide 4.5x slower, is there any broader thing that i can learn from that
22:26:03 <monochrom> C is very verbose and repetitive when it comes to real-world data structures.
22:26:10 <siti> yep
22:26:13 <ddarius> siti: No. They're fairly easy in C too.
22:26:23 <dons> dancor: yes. that's a mutable hashtable benchmark
22:26:23 <siti> how do you do them in c?
22:26:30 <monochrom> Real-world people don't admit it.
22:26:30 <emu> just run Firefox
22:26:35 <ddarius> siti: Forget to free.
22:26:38 <dons> dancor: so you can argue that its hard to do mutable arrays in haskell, and be competitive with C
22:26:39 <emu> and watch the space leaks pile up
22:26:41 <dons> i think that's reasonable.
22:26:52 <siti> lol, firefox is not that bad, if you have lots or ram it will use more as a cache
22:27:01 <dons> in fact, if you rewrite that haskell entry to use a Trie instead, it runs a lot faster than C.
22:27:12 <emu> well, in any case, space aka memory leaks are quite common in C programs. i think the term was invented there ;)
22:27:14 <siti> silly people with 2GB of memory are alarmed that firefox is using 200MB :p
22:27:31 <dons> dancor: seem reasonable?
22:27:34 <monochrom> Rightfully alarmed.
22:27:42 * sorear doesn't use firefox.  Far too big, far too buggy, far too many deps.
22:27:54 * sorear uses elinks, *very begrudgingly*
22:27:54 <emu> siti: yep, they are typing a post on reddit with firefox using 200MB about emacs taking Eight Megabytes and Constantly Swapping
22:27:59 <monochrom> They bought 2GB for building ghc, not for running a web browser. :)
22:28:19 <dons> so, across a wide range of problem domains, ghc 6.6 haskell can be expected to run between 2x faster and 2x slower than C, on small programs
22:28:20 * sorear would rather use a web browser written in a memory safe language, like PHP.
22:28:35 <dons> given the right situation, it might be up to 10x faster, or 10x slower, in rare cases
22:28:45 <dons> more typically, you'll be around 1.5-2x slower than C
22:28:56 <siti> I only have firefox take up about 120MB and I have 2GB of ram, and run a 64bit OS...
22:28:57 <dons> in 1/2 to 1/4 the code
22:29:00 <sorear> (archetypical example of a very bad, but still memsafe, language)
22:29:17 <dancor> dons: yes
22:29:21 * LoganCapaldo would like to see the php webbrowser (that didn't cheat and use GtkMozEmbed or similar)
22:29:27 <siti> sorear: they write lots of it in javascript :p
22:29:32 <dons> i think that's a reasonable summary, above, of my experience this year writing those entries
22:29:46 <monochrom> Since you typically have perpetual ghc re-building, you would rather reserve all 2GB for that and not spare 200MB for the web browser. :)
22:29:58 <sorear> Ideally, I'd see a Haskell browser.
22:30:10 <LoganCapaldo> sorear: Smalltalk is a memory safe, and Squeak has a webbrowser
22:30:13 <dons> for the specific case of k-nucleotide, I'd use a Trie. and we'd beat C. if I was *forced* to use a hashtable, I'd use an ffi binding to a hashtable in C, if it was critical
22:30:24 <monochrom> Ideally, ghc would let you do web browsing while it rebuilds ghc. :)
22:30:26 <LoganCapaldo> I dunno if it has as many features as elinks though
22:30:46 <sorear> LoganCapaldo: all I use is html rendering and F4 ...
22:30:53 <dancor> dons: yeah it seems like there should be some kind of repository of useful information like that
22:30:55 <siti> lol, ghc does not take up that much memory :p, also I like having back and forward instant another feature that takes up memory...
22:31:36 <dons> ?wiki Performance
22:31:36 <siti> @where Trie
22:31:36 <lambdabot> I know nothing about trie.
22:31:37 <lambdabot> http://www.haskell.org/haskellwiki/Performance
22:31:41 <dancor> dons: i mean lessons like that dumbed down for me since i someone couldn't extract it from the shootout proper
22:31:50 <dons> ah ok. hmm.
22:31:57 <dons> maybe i should write up my experience on this.
22:31:59 <dons> i keep meaning to.
22:32:09 <dons> since i learnt a fair bit from the shootout this year too.
22:32:14 <monochrom> ghc+gcc building ghc takes up a lot of memory.  mainly gcc does because ghc hands it humongous c-- code.
22:32:42 <dons> yeah, its much faster / smaller to use the native code gen, -fasm, for a 3% performance drop
22:32:53 <dons> (i should try to get some nobench numbers on that, hm...)
22:33:09 <siti> it will be nice when -fasm is faster than gcc in generated code
22:33:38 <siti> I bet it could make it much faster, with lots of optomizations :0
22:34:15 <dons> right.
22:34:16 <monochrom> If you say, ghc+gcc building ghc takes up max 0.5GB from your experience, yes ok but you're single-threading.  But these days you parallelize it the dons way.  You do "make -N 10" and it will be 0.5GB*10 easily.
22:34:40 <LoganCapaldo> man reading that page was weird
22:34:49 <dons> yeah, 16G becomes small
22:34:59 <dons> monochrom: that's a good point. more cores means more ram too
22:35:17 <dons> since you need 1G per core
22:35:29 <dons> to make any headway, and you better have decent bandwidth
22:35:30 <LoganCapaldo> ghc doesn't do most of the optimizations I expected it to do, and does do some weird optimizations I didn't think of
22:42:02 * dons does so more make -j16
22:42:25 <dons> mm. ghc -fasm is much faster building
22:43:10 <monochrom> Yeah. gcc takes forever. Then again can't blame it.
22:44:03 <encryptio> is a purely haskell-based os kernel a possible/feasible idea?
22:44:10 <nmessenger> @unmtl Cont r (Cont r a)
22:44:10 <lambdabot> (Cont r a -> r) -> r
22:44:25 <nmessenger> @. unmtl unmtl Cont r (Cont r a)
22:44:25 <lambdabot> err: No applications
22:44:52 <dons> encryptio: yeah, been done a couple of times.
22:44:53 <dons> ?where House
22:44:54 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
22:44:59 <dons> and the L4 Haskell prototype kernel
22:45:25 <dons> its a reasonably active research area, since the kernel guys these days like to have high assurance about the bug-free-ness of their kernels
22:45:37 <dons> at least for embedded system-y kernels
22:46:01 <encryptio> cool.
22:47:09 <dons> monochrom: http://www.cse.unsw.edu.au/~dons/tmp/results.html
22:47:10 <lambdabot> Title: nobench: Haskell implementation shootout
22:47:19 <dons> wow, Simon always said the -fasm way was a 3% penalty
22:47:24 <dons> that's *exactly* what I just got
22:48:06 <monochrom> I'm amused. ghc-asm not shabby at all.
22:48:23 <dons> couple of compile errors i need to look at
22:48:27 <dons> simonM will be happy
22:48:37 <dons> on the 'real' class of programs, it exactly matches ghc -fvia-C
22:48:43 * dons suspects gcc isn't so hot on amd64
22:49:10 <dons> that's a pretty good argument for -O -fasm being the default, I thin
22:49:11 <dons> k
22:49:18 <sorear> bye.
22:49:26 <dons> night sorear
22:49:51 <monochrom> OK, I'll do that henceforth.
22:50:09 <siti> and -fasm getting tested more will mean it can only improve :)
22:50:20 <dons> yeah
22:50:28 <dons> the plan is to switch entirely to -fasm, of course.
22:50:33 <dons> since that's the only way to really beat gcc
22:50:43 <siti> yep
22:50:44 <siti> :D
22:50:46 <dons> since our native code gen knows what its eating for breakfast better than gcc does
22:52:09 <LoganCapaldo> bah
22:52:18 <LoganCapaldo> who cares about better gcc
22:52:31 <LoganCapaldo> s/better/beating/
22:52:41 <LoganCapaldo> aim for like icc or something cool like that :)
22:52:49 <siti> it would be funny having such a highlevel language beating a low level language
22:53:03 <siti> people have always predicted it but it's never really happened
22:53:09 <siti> java/c# have always been slower
22:53:11 <LoganCapaldo> esp. if you did it on like intel
22:53:23 <siti> icc is much harder :p
22:53:29 <LoganCapaldo> "Lazy, GCed language beats icc at its own game"
22:53:33 <LoganCapaldo> bwhahahaha
22:53:34 <siti> hehe
22:53:50 <siti> well D can do well in benchmarks because it's garbage collected
22:54:07 <siti> but I think in reality garbage collection is a bit slower
22:54:45 <dons> well, Clean beats C fairly regularly on small tasks
22:54:50 <dons> basically due to the native code gen
22:55:02 <LoganCapaldo> Is Clean propietery?
22:55:10 <dons> used to be, now its just weird
22:55:12 <ivanm> its dual-licensed
22:55:26 <ivanm> lgpl for educational/personal, plus commercial if you want it
22:55:34 <siti> weird
22:55:59 <LoganCapaldo> Cause way back when I looked into this functional programming thing I came across Clean and it looked cool, but it seemed lke Id have to fork over $
22:56:00 <monochrom> heh
22:56:24 <LoganCapaldo> And I got scared off of Haskell the first time around by the whole IO thing
22:56:27 <monochrom> $ is evil
22:56:36 <ivanm> no, you won't... but I had a look at clean, and the latest release of the clean report is a draft from 2001 IIRC
22:56:38 <dons> uniqueness types for IO aren't so easy either ;)
22:56:42 <monochrom> and you didn't mind uniqueness types?
22:56:50 <LoganCapaldo> "This is overly elaborate! Not pragmatic enough" I said
22:56:51 * dons guesses LoganCapaldo didn't get that far
22:57:00 <monochrom> ok I guess.
22:57:00 <LoganCapaldo> monochrom: I didn't even get that far
22:57:26 <LoganCapaldo> So I puttered around with O'Caml and SML for a while
22:57:36 <LoganCapaldo> (liked SML better in general)
22:57:40 <dons> there we go, monochrom, much better results: http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
22:57:41 <lambdabot> Title: nobench: Haskell implementation shootout
22:57:48 <dons> all the compilation errors were missing flags
22:57:51 <dufflebunk> I stopped playing with Clean when they decided not to update the neat GUI stuff for linux
22:57:56 <dons> i note some good wins for ghc -fasm in fact
22:58:06 <dons> the 'loop' benchmark!
22:58:34 <monochrom> evil mangler is not evil enough? :)
22:58:36 <ivanm> dons: what's ghc-asm? playing with assembler as well?
22:58:40 <dons> ghc -fasm
22:58:42 <LoganCapaldo> its funny what attracted me a lot to both Haskell and Clean was the list comprehensions
22:58:46 <dons> its ghc generating direct assembly
22:58:52 <LoganCapaldo> but now I don't use em so much
22:58:59 <dons> rather than producing C, asking gcc to compile that to asm, then post processing the asm
22:59:00 <LoganCapaldo> (like at all)
22:59:17 <siti> yeah I like map better
22:59:27 <ivanm> dons: is it meant to be much different from the C backend in terms of performance?
22:59:40 <siti> see the link :p
22:59:50 <siti> 1.02 * slower
23:00:05 <siti> but faster to compile
23:00:43 <ivanm> siti: looking at the link... speeds look mostly similar...
23:00:50 <ivanm> but where is the compilation time speeds?
23:00:51 <siti> yep
23:00:56 * nmessenger imagines list comps like the sugary scent of a venus fly trap the Logan falls into
23:00:58 <s1> evening all.. what package provides binary-any, required by HAppS ?
23:01:01 <siti> oh they aren't there
23:01:23 <ivanm> so what's the advantage/use of asm? If you don't have gcc installed?
23:01:24 <LoganCapaldo> lol
23:01:30 <siti> dons: can your benchmarking thing do complimation times too?
23:01:41 <dons> not yet. but would be 2 lines of code to add
23:01:47 <siti> ok cool
23:02:06 <s1> is it http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.2 ? or is that obsolete ? I can't tell
23:02:09 <lambdabot> http://tinyurl.com/25xp35
23:02:17 <dons> that's good
23:02:23 <dons> that's the most recent release
23:02:38 <dons> there's a darcs version with a couple of improvments, but probably not enough to warrant an update
23:02:42 <s1> great, thanks
23:03:00 <ivanm> dons, siti: so what's the advantage/use of asm? If you don't have gcc installed?
23:03:02 <dons> let me know if you have any trouble with it, s1
23:03:14 <dons> ivanm, much faster compilation times, at the moment.
23:03:18 <dons> and yeah, no need for ghc or perl
23:03:24 <s1> hmm, now I'm looking for HList-any
23:03:31 <ivanm> perl? what part of haskell uses perl?
23:03:32 <dons> in a year or two, it'l be for faster code too
23:03:42 <dons> the mangler that post-processes gcc's asm output
23:03:51 <dons> to fixup the shoddy code it produces ;)
23:03:54 <siti> woah crazy
23:03:56 <ivanm> lol
23:04:01 <dons> all from the days before C--
23:04:17 <LoganCapaldo> Does it run under pugs? <g>
23:04:20 <ivanm> and they haven't fixed that yet?
23:04:30 <ivanm> LoganCapaldo: lol
23:04:32 <dons> no, they're particular special situations you can't add to gcc
23:04:48 <dons> domain specific optimiations like fixing tailcalls, moving code next to data
23:05:09 <siti> does gcc actually have c-- support, or is this only internally used by ghc?
23:05:27 <ivanm> I though C-- was a subset of C...
23:05:28 <dons> the latter
23:05:34 <siti> ok
23:05:35 <dons> ivanm: not at all
23:05:46 <siti> it's an intermediate language :p
23:05:46 <ivanm> well, shows how little I know ;)
23:05:51 <siti> @google c--
23:05:52 <lambdabot> http://en.wikipedia.org/wiki/C_(programming_language)
23:05:52 <lambdabot> Title: C (programming language) - Wikipedia, the free encyclopedia
23:05:56 <siti> oopps
23:06:00 <dons> well, a backend language
23:06:05 <siti> hard to google for names like that
23:06:05 <LoganCapaldo> @google c minus minus
23:06:08 <lambdabot> http://www.cminusminus.org/
23:06:08 <lambdabot> Title: C-- Home
23:06:13 <dons> Core is an intermediate language, C-- is more a target language for a backend
23:06:20 * s1 finds it
23:06:20 <LoganCapaldo> I don't think thats the same C-- though
23:06:24 <siti> ok
23:06:31 <ivanm> I think it might be...
23:06:40 <ivanm> looks like its the same thing...
23:06:45 <dons> a data structure that looks like a subset of C-- is used as the intermediate imperative language in ghc's backend
23:06:46 <ivanm> hang on, its from harvard though...
23:06:51 <dons> that structure is then translated to asm and C
23:06:58 <ivanm> C-- could be of SPJ's website
23:06:58 <dons> that's the right page.
23:07:00 <nmessenger> so .hs -(ghc)-> .cmm -(perl)-> .c -(gcc)-> .exe ?
23:07:04 <dons> cminusminus.org
23:07:27 <dons> hs -> Core -> Cmm.   cmm then to C->asm->perld-asm.         cmm -> asm
23:07:42 <dons> asm -> exe
23:08:02 <nmessenger> kinda indirect :)
23:08:06 <ivanm> lol
23:08:16 <dons> well, the direct path is pretty clear
23:08:22 <ivanm> so what's the asm direct route like?
23:08:40 <LoganCapaldo> .hs -> asm of course :)
23:08:44 <dons> Hs -(ghc)-> Core -(ghc)-> optimised Core -(ghc)-> Cmm -(ghc)-> asm -> exe
23:08:57 <siti> "     The Evil Empire     refuses even to consider registering a domain name that ends     with a dash."
23:08:58 <siti> lol
23:09:03 <dons> the plan though is to add a new phase
23:09:04 <nmessenger> the last one -(ghc)-> too?
23:09:17 <dons> no, that's gcc I think
23:09:24 <dons> i.e. just asm and link
23:09:44 <dons> the new phase is:   Cmm -> SSA -> Cmm -> Asm -> exe
23:09:53 <nmessenger> SSA?
23:10:03 <LoganCapaldo> single static assignment
23:10:05 <dons> where we do some traditional imperative optimiations on the SSA form.
23:10:17 <dons> a traditional data type for representing imperative code
23:10:24 <dons> lots of optimisatoins written to work on it
23:10:24 * LoganCapaldo thought Haskell was already SSA <g>
23:10:35 <dons> yeah, Core basically is.
23:10:49 <dons> well, ANF, a subset of core/lambda calc, is equivalent to SSA
23:10:58 <dons> SSA is really a simple functional language
23:11:06 <dons> the SSA guys just didn't realise it til Appel pointed it out
23:11:33 <siti> I bet it's going to be so much easier to make changes to ghc over gcc :p
23:11:49 <dons> yeah, just pattern matching on the data type makes life about 100x easier than C
23:12:05 <dons> let alone type safe optimisations, where you type check the result before and after each pass
23:12:11 <dons> to make sure you didn't corrupt your code
23:12:23 <LoganCapaldo> Come for the list comprehensions, stay for the pattern matching and the type safe optimizations ;)
23:13:55 <dons> oh, sigfpe piece, mod up!! http://programming.reddit.com/info/1761q/comments
23:13:56 <lambdabot> Title: Monads in C, pt. II (reddit.com)
23:14:32 <monochrom> Will he also write "Monads in ASM"?!!
23:14:33 <encryptio> the thing that drew me to haskell was the type system. having only done realbasic, c, and perl, haskell's type system was a dream
23:14:57 <dons> monochrom: no type system to lean on ;)
23:15:32 <dufflebunk> doesn't asm have two types, code and data?
23:15:51 <monochrom> Monads in COBOL may be funny.  BIND X TO Y AND RETURN Z. :)
23:16:05 <dons> i really like the code reuse.
23:16:14 <dons> redefine bind, your C code does something different, but still safe.
23:17:31 <nmessenger> but plain C doesn't really have useful overloading, does it?
23:17:54 <dons> none whatsoever
23:18:02 <dons> but native support for do notation!
23:18:07 <nmessenger> :D
23:18:09 <siti> lol
23:18:31 * monochrom dies
23:19:00 * nmessenger EXPLODES!!
23:19:16 * dons `throwTo` home
23:20:58 * nmessenger `needs` sleep
23:21:04 <nmessenger> 'night all
23:24:11 <encryptio> i need a large multidimensional Num accumulator. what should i use?
23:25:37 <dufflebunk> hashtable with the key being a tuple?
23:26:53 <encryptio> i should be more specific... an array of Nums, three dimensional - n by n by m. all values in the array will be used.
23:27:10 <dufflebunk> Oh, then dno't use a hashtable ;)
23:28:03 <monochrom> Num a => Array (Int,Int,Int) a
23:28:05 * LoganCapaldo hasn't actually used arrays in Haskell yet, but is pretty sure you can have n-dimensional arrays
23:28:38 <encryptio> @hoogle Data.Array
23:28:39 <lambdabot> No matches, try a more general search
23:28:44 <encryptio> @hoogle Array
23:28:44 <lambdabot> Array :: module
23:28:45 <lambdabot> Data.Array :: module
23:28:45 <lambdabot> Foreign.Marshal.Array :: module
23:28:54 <encryptio> now that's weird.
23:29:18 <LoganCapaldo> @doc Array
23:29:19 <lambdabot> Array not available
23:29:25 <LoganCapaldo> @doc Data.Array
23:29:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
23:29:48 <monochrom> > listArray ((0,0,0),(2,2,2)) [1..8]
23:29:49 <lambdabot>  Exception: (Array.!): undefined array element
23:30:03 <monochrom> Oh!
23:30:07 <monochrom> > listArray ((0,0,0),(2,2,2)) [1..27]
23:30:09 <lambdabot>  array ((0,0,0),(2,2,2)) [((0,0,0),1),((0,0,1),2),((0,0,2),3),((0,1,0),4),((0...
23:30:19 <monochrom> That is a 3x3x3 array.
23:30:56 <encryptio> i see...
23:31:28 <monochrom> There are also mutable arrays (STArray and IOArray) of course.  There are also unboxed arrays if you want speed and you fix the number type.
23:32:00 <LoganCapaldo> > listArray (0, 10) [1..]
23:32:02 <lambdabot>  array (0,10) [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(...
23:32:14 <LoganCapaldo> > listArray (0, 8) [1..]
23:32:16 <lambdabot>  array (0,8) [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)]
23:32:16 <encryptio> i think accumArray should do the trick
23:32:36 <LoganCapaldo> > listArray (0, 8) [1..] ! 3
23:32:38 <lambdabot>  4
23:32:50 * LoganCapaldo has now used arrays in Haskell
23:32:58 <LoganCapaldo> ;)
23:33:12 <monochrom> Have you done fibonacci using arrays?
23:33:46 <LoganCapaldo> in haskell, or like ever?
23:33:51 <monochrom> in haskell
23:34:00 <LoganCapaldo> no
23:34:36 <monochrom> You will be surprised that the "slow formula f n = f (n-1) + f(n-2)" works and is fast.
23:35:06 <LoganCapaldo> why am I not surprised?
23:35:08 <LoganCapaldo> err
23:35:13 <LoganCapaldo> wait
23:35:24 <LoganCapaldo> I'm supposed to be surprised :)
23:35:37 <monochrom> > let fib = listArray (0,8) ( 0 : 1 : [ fib!(n-1)+fib!(n-2) | n<-[2..8] ] ) in fib
23:35:39 <lambdabot>  array (0,8) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21)]
23:36:01 <LoganCapaldo> lazy array
23:36:07 <LoganCapaldo> err
23:36:13 <LoganCapaldo> lazy is not tjhe word
23:36:23 <encryptio> memoizing
23:36:24 <LoganCapaldo> recursively defined array
23:36:25 <monochrom> If you are unsurprised, it's still ok.  Learned people are unsurprised.
23:36:37 <LoganCapaldo> neat
23:37:15 <LoganCapaldo> its the dynamic programming way written "naturally" and it just works :)
23:37:22 <s1> latest happs seems to be missing the plain function ?
23:37:29 <monochrom> dynamic programming for dummies
23:37:38 <LoganCapaldo> Haskell: optimized for the fibonacci sequence :)
23:39:12 <LoganCapaldo> thats actually a really neat trick
23:41:14 * monochrom <3 haskell
23:44:11 <hpaste>  3AbE|/| pasted "(no title)" at http://hpaste.org/725
23:44:12 <hpaste>  3AbE|/| pasted "A" at http://hpaste.org/726
23:44:59 <monochrom> why are there two separate pastes?
23:45:11 <LoganCapaldo> that was new and excting
23:45:17 <LoganCapaldo> also, C++
23:54:35 <Cale> Who is that? Are they even in the channel?
23:54:49 <ivanm> I was trying to work that out myself
23:55:02 <ivanm> not by the looks of things, they're not...
