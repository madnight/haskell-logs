00:12:36 <nornagon> hm... what's a smart way to turn [a,b,c] into [f a b, f a c, f b c]?
00:13:11 <nornagon> :t zipWith (\_ _ -> 1)
00:13:14 <lambdabot> forall a b t. (Num t) => [a] -> [b] -> [t]
00:13:26 <nornagon> :t zipWith (*)
00:13:29 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
00:13:46 <TSC> nornagon: Do you want all pairs in the list?
00:13:54 <nornagon> TSC: not all the pairs
00:14:07 <nornagon> [a,b,c,d] would be [ab,ac,ad,bc,bd,cd]
00:14:10 <nornagon> well
00:14:14 <nornagon> i guess that's all the pairs
00:14:27 <nornagon> i'd also like it to be easily generalisable to do groups of three
00:14:34 <nornagon> all the unique pairs.
00:14:43 <nornagon> or groups of three, or four, or whatever.
00:15:10 <nornagon> can you tell i'm learning about factorising polynomials? :P
00:15:49 <dons> so permute the list, then zip
00:15:53 <dons> zip 'f' ?
00:16:14 <nornagon> permute the list?
00:16:18 <nornagon> :t sequence
00:16:21 <lambdabot>     Ambiguous occurrence `sequence'
00:16:21 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
00:16:22 <TSC> > let xs = [1,2,3,4] in [(a,b) | (a:as) <- List.tails xs, b <- as]
00:16:23 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
00:16:34 <nornagon> hmm :)
00:16:44 <TSC> Then (map (uncurry f))
00:16:48 <TSC> or thereabouts
00:16:59 <nornagon> easily generalisable to do groups of three?
00:17:15 <nornagon> :t sequence_
00:17:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
00:17:42 <TSC> let xs = [1,2,3,4] in [(a,b,c) | (a:as) <- List.tails xs, (b:bs) <- List.tails as, c <- bs]
00:17:52 <nornagon> that's not generalised :P
00:17:52 <TSC> Not really "easily"
00:20:32 <dons> > sequence_ [[1,2,3],[3,2,1]]
00:20:34 <lambdabot>  [(),(),(),(),(),(),(),(),()]
00:20:43 <dons> > sequence [[1,2,3],[3,2,1]]
00:20:43 <nornagon> heh
00:21:09 <nornagon> doesn't quite work
00:21:34 <dons> > [replicate k ['a'..'c'] | k <- [1..]] >>= Control.Monad.sequence
00:21:36 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
00:22:07 <dons> > [replicate k [1..4] | k <- [1..]] >>= sequence -- list monad fun
00:22:10 <nornagon> still not quite right... i don't ever want "ba"
00:23:52 <TSC> @paste
00:23:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:23:56 <dons> > Control.Monad.sequence [[1..4],[1..4]]
00:23:57 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,...
00:24:36 <hpaste>  TSC pasted "Pairs and co" at http://hpaste.org/670
00:24:52 <TSC> I think that's reasonable
00:25:07 <nornagon> mm
00:25:12 <nornagon> that's exactly what i wanted :)
00:25:37 <TSC> The first pattern isn't necessary
00:26:19 <TSC> Hooray for "tails"
00:26:43 <TSC> And sensible pattern failure, etc
00:27:46 <astrolabe> > let c = [1..4] in [(head a,b)|a<-tails c,not (null a),b<-tail a]
00:27:48 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
00:28:14 <astrolabe> Ah, I see TSC has beaten me.
00:42:23 <astrolabe> > let {takeC 0 as = [[]];takeC n [] = [];takeC n (a:as) = map (a:) (takeC (n-1) as) ++ takeC n as} in takeC 3 [1..5]
00:42:24 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,...
00:42:30 <astrolabe> @more
00:43:37 <astrolabe> Why did lambdabot truncate the answer?
00:43:55 <siti> so people can't spam the channel
00:44:00 <siti> > repeat 1
00:44:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:44:22 <astrolabe> siti: I'm sure the answers used to be longer
00:44:31 <siti> ok
00:45:33 <astrolabe> Too late for nornagon I'm afraid
01:14:48 <blackdog> ... are you all just being extremely quiet, or is my choice of a new IRC client seriously misguided?
01:15:41 <siti> we are quiet
01:15:46 <quicksilver> we're using a frequency your ears are not attuned to
01:15:51 <quicksilver> sorry about that, it's a bit rude of us
01:16:21 <blackdog> jeez, it's just like that year i spent trying to learn echolocation from the fruit bats
01:16:24 <blackdog> squeaky little bastards
01:28:10 <Baughn> blackdog: You should try learning from a human instead
02:54:03 <spookylukey> I need to parse text in a very tolerant way i.e. will correct various kinds of user mistakes.  Am I right in thinking that Parsec will not be very suitable for this?  If so, does anyone know of a library that would be suitable?
02:57:44 <quicksilver> tolerant parsing is always going to be fiddly
02:57:53 <quicksilver> I don't see that parsec would be worse at it than anything else
02:58:50 <spookylukey> Would you reckon that parsec would be better than doing it 'by hand'?  It's not massively complicated stuff
02:59:45 <quicksilver> no, not really
02:59:53 <quicksilver> I often do parsing-type stuff by hand
02:59:59 <quicksilver> since then I can play with the API a bit
02:59:59 <spookylukey> OK, cheers.
03:00:16 <quicksilver> There's a good paper on it. Was it Launchbury? I'm not sure.
03:00:25 <quicksilver> Good chapter in that ML book, as well
03:00:30 <quicksilver> Paulson's ML book
03:02:44 <ivanm> I need to write a short paragraph or two summarising what Haskell is and why its good for math programs.  What should I include?
03:04:09 <malcolmw> spookylukey: http://eprints.nottingham.ac.uk/archive/00000237/
03:04:11 <lambdabot> Title: Monadic Parser Combinators - Nottingham ePrints - IS - The University of Notting ...
03:05:24 <DynWind> ivanm: you might want to look at "History of Haskell", by Simon Peyton Jones, and the "Haskell Road to Logic, Math, and Programming"
03:06:22 <ivanm> @google "history of haskell"
03:06:24 <lambdabot> http://www.haskell.org/haskell-history.html
03:06:24 <lambdabot> Title: The History of Haskell
03:06:42 <ivanm> @google "haskell road to logic, math and programming"
03:06:47 <ivanm> DynWind: thanks!
03:06:49 <lambdabot> http://www.cwi.nl/~jve/HR
03:06:50 <lambdabot> Title: The Haskell Road
03:06:53 <DynWind> oh, the "haskell road to" is no longer available online :(
03:07:16 <ivanm> yeah, just noticed that... :(
03:07:49 <thalassocrac> i found it via google once
03:08:12 <DynWind> I have a pdf of it (draft, prolly) on my disk
03:08:39 <quicksilver> Hutton an Meijer looks nice. Although personally I have a possibly irrational fondness of setting up the combinators so that the terminals 'look like' the BNF grammar, as far as possible
03:08:41 <thalassocrac> someone had it on some university website (along with a bunch of other stuff)
03:10:02 <DynWind> @google "haskell road logic programming filetype:pdf"
03:10:03 <lambdabot> No Result Found.
03:10:06 <ivanm> thalassocrac: this it? http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HRshort.pdf
03:10:29 <DynWind> http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HRshort.pdf
03:10:32 <DynWind> yeah
03:10:59 <ivanm> actually, it isn't: only has the first 38 pages :(
03:11:09 <thalassocrac> no, i think it was at usc or something; some directory for some scientific research group
03:11:25 <thalassocrac> if i recall correctly
03:12:45 <ivanm> well, google revealed nothing :(
03:13:35 <thalassocrac> lnc.usc.edu/~brannon/haskell/HR.ps
03:16:28 <thalassocrac> http://www-lnc.usc.edu/~brannon/ <-- what i was thinking of
03:16:29 <lambdabot> Title: Index of /~brannon
03:16:51 <ivanm> seems to be a slow site... the ps is still downloading
03:16:53 <thalassocrac> i don't know about the legality though
03:17:16 <kaol> ?users
03:17:17 <lambdabot> Maximum users seen in #haskell: 332, currently: 297 (89.5%), active: 20 (6.7%)
03:17:50 <resiak> I demand that someone package zlib for Debian!
03:19:29 <doserj> http://packages.debian.org/stable/source/zlib ?
03:19:31 <lambdabot> Title: Debian -- zlib
03:19:53 <ivanm> thalassocrac: that's the full thing, thanks!
03:20:12 * ivanm now just has to find someone willing to print a 450 page document for him...
03:20:16 <ivanm> for free, that is
03:20:47 <resiak> doserj: I mean the Haskell bindings for it
03:22:19 <dons> we have a zlib binding
03:22:21 <dons> a rather good one
03:22:26 <dons> if in doubt, always check hackage first
03:22:27 <dons> ?where hackage
03:22:28 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
03:24:31 <resiak> dons: No no no, I know that it exists, and is awesome; I'm just complaining that it's not in Debian Etch :-)
03:24:41 <dons> ah right!
03:24:48 <dons> we need cabal2deb
03:24:50 <dons> oh, we have that already
03:26:17 <resiak> @where cabal2deb
03:26:18 <lambdabot> I know nothing about cabal2deb.
03:31:56 <hpaste>  ivanm pasted "Brief summation of what is Haskell, and why I used it" at http://hpaste.org/671
03:32:38 <ivanm> Can people please tell me what they think of the short haskell intro I just hpasted?
03:32:53 <ivanm> its for the paper on the project I've been annoying everyone with ;)
03:33:33 <cragwolf> :t tail
03:33:36 <lambdabot> forall a. [a] -> [a]
03:34:04 <cragwolf> cool. carry on. :)
03:34:17 <araujo> morning
03:34:19 <quicksilver> ivanm: I think you miss the important observation that it is possible to be much more confident that a haskell program is correct
03:34:37 <quicksilver> ivanm: since its encoding is close to normal mathematical formalisms
03:36:37 <DynWind> ivanm: minor thing: the word you want is 'statically' typed
03:40:58 <kaol> resiak: "demand" a package, huh? ok, I'll see if I'm going to be bored enough to put one together sometime this week. Turning cabalised libs to Debian packages is quite trivial.
03:45:45 <resiak> kaol: My choice of words was a joke.  I was kinda hoping that there was a semi-automatic way to do it, and it seems that it's trivial, as you say
03:46:14 <kaol> I do recognize it as a joke ;-)
03:47:03 <resiak> Cool :-)
03:47:09 <kaol> though even if I were to upload it to unstable now, it still wouldn't make it to Etch since it's been frozen since mid-December
03:48:42 <ivanm> quicksilver, dynWind: thanks!
03:49:08 <kaol> and it would wait in the NEW queue for weeks before you could apt-get install it
03:50:54 <doserj> -> backports.org?
03:51:04 * kaol nods
03:52:27 <hpaste>  ivanm annotated "Brief summation of what is Haskell, and why I used it" with "a bit more on correctness, and use of statically" at http://hpaste.org/671#a1
03:52:38 <ivanm> quicksilver, dynWind: better?
03:53:25 <quicksilver> dons: name lookups down for www.cse.unsw.edu.au I think
03:53:35 <resiak> kaol: sure, I know.
03:54:08 <ivanm> with regards to the correctness of haskell programs, I just started a course on using the B Method for software specification
03:54:50 <ivanm> the lecturer said we could any language we wanted, but preferably an imperative rather than functional language
03:55:02 <ivanm> is that because turning B into haskell would be too easy? ;)
03:55:10 <quicksilver> yes
03:55:14 <quicksilver> basically
03:55:28 <quicksilver> the 'interesting part' is trying to specify imperative languages
03:57:20 <ivanm> yeah... from what I could see of B, it looks kinda haskellish in its logic and notation
03:58:57 <ivanm> quicksilver: did you have a look at my update version on hpaste?
03:59:36 <DynWind> ivanm: looks ok
03:59:45 <ivanm> DynWind: thanks
04:00:23 <ivanm> I just know that when my supervisor first heard I was wanting to use a functional language, he went "oh no, its' not like scheme, is it?"
04:01:29 <opqdonut> :D
04:01:45 <DynWind> its definitely not like scheme ;)
04:07:46 <quicksilver> it's more like scheme than it is like C, arguable
04:10:17 <ttmrichte1> ivanm: I could get onside with hating Scheme.  The fingernail-parings of Lisp code really... bother me.
04:10:54 <ivanm> ttmrichte1: I liked scheme...
04:11:10 <ivanm> and its because I said I liked scheme that someone told me about Haskell :D
04:12:48 <ttmrichte1> ivanm: I like many of the ideas behind scheme, but hate the fact that it, effectively, forces me to mutate my thoughts into its syntax.  I just really don't like the reversed-reverse-Polish-notation and the plethora of parentheses.
04:13:02 <ivanm> each to their own
04:13:07 <ttmrichte1> Exactly.
04:13:27 <ttmrichte1> Learning Scheme was a valuable experience, but it is not something I will ever work with willingly again.
04:13:35 <ivanm> but before it, the only language I ever really used was pascal/delphi with a little bit of java, so the concept of functions being data was really cool to me
04:13:51 <ttmrichte1> Oh, yes.  That was one of the central concepts of Scheme I loved.
04:13:53 <ivanm> besides, I used to be obsessed with AI, so I always wanted to learn LISP ;)
04:14:25 <beelsebob> has anyone got a good example of something that can be done in Untyped Lambda Calculus + simple syntactic additions that neatly demonstrates higher order functions?
04:15:14 <Philippa> what counts as simple additions?
04:15:18 <dons> map?
04:15:18 <Philippa> you can write all the usual suspects
04:15:27 <dons> fold?
04:15:33 <dons> callCC?/
04:15:33 <Philippa> church encodings're themselves higher order functions
04:15:34 <beelsebob> this is true
04:15:41 <beelsebob> I'm already writing map and fold etc
04:15:48 <dons> thisProgramHalts ?
04:15:50 <dons> ok. maybe not that one
04:15:54 <beelsebob> lol
04:16:04 <beelsebob> hang on - I'll show you what my language looks like
04:16:04 <Philippa> you can't do callCC with only syntactic additions, you'd need to write a complete interpreter or a monad
04:16:22 <psi> the only instance where I find that the lisp syntax is problematic is when you're using operators that usually are infix.
04:18:53 <hpaste>  beelsebob pasted "These simple additions" at http://hpaste.org/672
04:18:53 <beelsebob> Philippa: those additions
04:18:53 <beelsebob> basically enough to make it look pretty
04:18:53 <beelsebob> but it's still basically lambda calculus
04:18:53 <Baughn> dons: How about thisOtherProgramThatDoesNOTReferToThisProgramHalts ?
04:18:53 <ttmrichte1> psi: Exactly.
04:18:53 <psi> ttmrichte1: but I find that a minor issue.
04:18:53 <ttmrichte1> psi: I just don't like having to manually sort out the algebraic notation that I've had hammered into me since I was about 6 to suit the machine.
04:18:53 <ttmrichte1> psi: I'm a hard-liner: I think the machine should be working for my convenience, not the other way around.  ;)
04:18:53 <psi> using sexprs is convenient with the right tools (like emacs).
04:19:06 <nornagon> how come haskell can't take expressions between ``?
04:19:06 <nornagon> > 1 `flip (-)` 3
04:19:06 <nornagon> @bot
04:19:07 <lambdabot>  Parse error
04:19:07 <lambdabot> :)
04:19:23 <Baughn> > 1 (flip (-)) 3
04:19:24 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
04:19:24 <lambdabot>     I...
04:19:36 <Baughn> > 1 `(flip (-))` 3
04:19:36 <lambdabot>  Parse error
04:20:10 <Baughn> ..oh, DWIM already.
04:20:13 <Cheery> ?where hIDE
04:20:15 <lambdabot> http://haskell.org/haskellwiki/HIDE
04:20:27 <Cheery> ?where gtk2hs
04:20:28 <lambdabot> http://haskell.org/gtk2hs/
04:20:33 <Cheery> ?where dazzle
04:20:34 <lambdabot> I know nothing about dazzle.
04:20:51 <Philippa> beelsebob: those additions appear to imply a case statement, that's a slightly more than syntactic addition IMO
04:21:06 <beelsebob> Philippa: no case statement
04:21:09 <beelsebob> only pattern matching
04:21:46 <Philippa> beelsebob: same difference
04:26:20 <hpaste>  syntaxfree pasted "sometimes I  get stuck on stupid, stupid places" at http://hpaste.org/673
04:26:40 <syntaxfree> :'(
04:27:41 <beelsebob> YAY!
04:27:42 <syntaxfree> that's pretty simple, I reckon.
04:27:45 <beelsebob> Out of cheese error!
04:28:28 <syntaxfree> I guess the real question is "how do I express the implicit parameters to a type variable that's supposed to be a parametrized type itself".
04:28:37 <syntaxfree> am I making sense?
04:30:35 <int-e> syntaxfree: no. the type checker makes sense though.
04:30:45 <syntaxfree> yes, I know.
04:30:51 <syntaxfree> I'm evidently using the wrong syntax.
04:31:05 <nornagon> aren't you SYNTAX FREE?
04:31:09 <int-e> syntaxfree: do you mean   enq, deq :: a -> a ?
04:31:27 <syntaxfree> int-e: what's the type of front, back then?
04:31:56 <syntaxfree> I mean, the type of front, back depends on the implicit parameter in the tyvar a.
04:32:04 <int-e> syntaxfree: actually you probably want  classs Enq a q where front, back :: q -> a; enq, deq :: q -> q
04:32:23 <earthy> me nods
04:32:31 <int-e> syntaxfree: and a fundep,  class Enq q a | q -> a
04:32:48 <syntaxfree> gah. Please tell me fundeps aren't gonna be removed in Haskell'.
04:32:50 <int-e> syntaxfree: (not sure which order of  q and a is more convenient)
04:32:50 <earthy> look as though it's a double ended queue class with a type variable for the queuetype and a type variable for the element type
04:32:54 <syntaxfree> Everything I do becomes a fundep.
04:33:04 <earthy> I'd say   class Enq q a | q -> a
04:33:28 <earthy> so that  Enq []   would make sense in and of itself
04:33:56 <earthy> otoh, maybe you don't even want the fundep...
04:34:22 <syntaxfree> fundeps are fun, fundeps are fair.
04:35:36 <int-e> earthy: you mean you could have heterogeneous queues? maybe with   front :: q -> Maybe a ?
04:35:51 <syntaxfree> It's not clear to me how to instance that either.
04:36:11 <MarcWebe1> Do you know any php weaving tools? (Kind of preprocessor. I want to add echo statements to each function because I'm getting a segfault and want to know where)
04:36:57 <earthy> int-e: well, hm.
04:36:59 <int-e> syntaxfree: erm, maybe your enq  type is wrong?
04:37:05 <ADEpt> @hoogle Array i e -> [(i,e})
04:37:06 <lambdabot> Hoogle Error: Parse Error: Unexpected character '})'
04:37:52 <hpaste>  (anonymous) annotated "sometimes I  get stuck on stupid, stupid places" with "(no title)" at http://hpaste.org/673#a1
04:37:56 <int-e> syntaxfree: anyway.  instance Enq [a] a where front = head; back = last; deq = init ...
04:38:31 <syntaxfree> my enq type is wrong. true.
04:38:45 <MarcWebe1> Not again. Why did I paste to the wrong channel again? Sorry.
04:39:06 <syntaxfree> anyway, my question remains. look at that last annotation, please?
04:39:45 <int-e> syntaxfree:  instance Enq ((Queue a) a)where ==> instance Enq (Queue a) a where
04:40:21 <syntaxfree> yippee.
04:40:24 <syntaxfree> thanks!
04:40:45 <syntaxfree> it's weird that useless parens screw associativity there.
04:41:25 <syntaxfree> do fundeps risk being removed from the next Haskell standard?
04:42:48 <TomMD> Fundeps are part of the standard?  I thought they weren't going to make it in.
04:42:49 <Syzygy-> So ....
04:43:02 <Syzygy-> I'm getting done with the mathematics part of my CAS design proposal.
04:43:03 <amiddelk> syntaxfree: it is an extension now, so why can't it be an extension then?
04:43:17 <MarcWebe1> But aren't they used a tremendous lot everywhere?
04:43:18 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/homhaskell.pdf
04:44:25 <TomMD> It is in a standard - a more advanced standard, the SIMON standard - what ever the two Simons decide to implement in GHC
04:45:14 <syntaxfree> amiddelk: uh, it's true.
04:45:30 <Igloo> AIUI something roughly equivalent to FDs will be in Haskell', but it may not actually be FDs
04:45:31 <syntaxfree> well, monad comprehensions were completely removed from any interpreter's reach.
04:47:21 <hpaste>  int-e annotated "sometimes I  get stuck on stupid, stupid places" with "working example (using MPTC and fundeps)" at http://hpaste.org/673#a2
04:48:37 <syntaxfree> @pl         move snake func = deq (enq (func snake))
04:48:38 <lambdabot> move = ((deq . enq) .) . flip id
05:02:49 <beelsebob> hmmm... I need a name for a small very theoretical version of hat
05:03:14 <syntaxfree> hmm. there's a standard prelude function equivalent to reverse . tail . reverse ?
05:03:16 <int-e> beelsebob: cap?
05:03:22 <beelsebob> current names are... pimp (because it manipulates the Theoretical ART), cap (small hat), wig (like a hat)
05:03:29 <beelsebob> well... there's a good vote for cap
05:04:06 <beelsebob> I also have one vote for badger
05:04:15 <beelsebob> simply because my finacÃ© likes them
05:04:30 <Pastorn> given a position n, is there an easy way to replace the element at that position?
05:05:07 <Pastorn> i wrote myself a primitive recursion, but maybe this is a common task?
05:05:08 <Syzygy-> If I want a parametrized type definition to depend on typeclass implementations, what's the precise syntax? Say, data Monomial a = [a] -- but with a required to implement Show?
05:05:23 <beelsebob> anyone else got any ideas?
05:05:31 <beelsebob> any votes for currently suggested names?
05:05:43 <Pastorn> beelsebob: name for what?
05:05:56 <beelsebob> Pastorn: a small theoretical version of Hat
05:06:00 <Philippa> beelsebob: your financé? ;-)
05:06:07 <beelsebob> current names are... pimp (because it manipulates the Theoretical ART), cap (small hat), wig (like a hat)
05:06:09 <Pastorn> Hat?
05:06:17 <SamB> beelsebob: would this one also be more reliable than windows?
05:06:19 <beelsebob> Pastorn: Haskell debugger -- haskell.org/hat
05:06:23 <beelsebob> SamB: no chance
05:06:24 <SamB> ... than windows 98, at least?
05:06:40 <beelsebob> it's written by me
05:06:47 <beelsebob> Philippa: yes, what's your point?
05:07:09 <Syzygy-> ?doc
05:07:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
05:07:10 <SamB> beelsebob: did you mean fiance?
05:07:13 <quicksilver> syntaxfree: init?
05:07:17 <beelsebob> SamB: it's looking significantly more reliable so far, I've had 5 bugs so far, and 4 of them have been to do with the parser
05:07:41 <beelsebob> SamB: entirely plausable
05:07:43 <beelsebob> I fale
05:07:44 <Philippa> SamB: right, I was just joking about the typo
05:07:45 <beelsebob> fail too
05:07:48 <beelsebob> lol
05:08:08 <beelsebob> @list
05:08:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:08:10 <int-e> beelsebob: \cap is âˆ© in LaTeX, if you want a nice symbol ;)
05:08:16 <SamB> except probably with that wierd e
05:08:19 <beelsebob> int-e: that's quite nice
05:08:25 <Syzygy-> What weird e?
05:08:31 <beelsebob> I wonder why it would be set intersection though
05:08:36 <SamB> Ã©
05:08:46 <SamB> Syzygy-: can't you see it?
05:09:00 <beelsebob> @help poll-add
05:09:00 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
05:09:01 <Syzygy-> Yeah, I can see it.
05:09:17 <beelsebob> @poll-add mini-hat-name
05:09:18 <lambdabot> Added new poll: "mini-hat-name"
05:09:30 <beelsebob> @help choice-add
05:09:31 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
05:09:45 <beelsebob> ...
05:09:45 <beelsebob> wake up lambdabot
05:10:01 <beelsebob> @help choice-add
05:10:02 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
05:10:20 <int-e> beelsebob: because the symbol looks like a cap; union is \cup (âˆª)
05:11:17 <int-e> beelsebob: it's funny, and the names are short. I can't complain :)
05:11:39 <beelsebob> @choice-add mini-hat-name pimp
05:11:39 <lambdabot> New candidate "pimp", added to poll "mini-hat-name".
05:11:46 <beelsebob> @choice-add mini-hat-name cap
05:11:46 <lambdabot> New candidate "cap", added to poll "mini-hat-name".
05:11:52 <beelsebob> @choice-add mini-hat-name badger
05:11:52 <lambdabot> New candidate "badger", added to poll "mini-hat-name".
05:12:03 <beelsebob> @choice-add mini-hat-name toupe
05:12:04 <lambdabot> New candidate "toupe", added to poll "mini-hat-name".
05:12:18 <beelsebob> @vote mini-hat-name toupe
05:12:18 <lambdabot> voted on "toupe"
05:12:25 <beelsebob> can you pls vote int-e
05:12:33 <osfameron> @vote mini-hat-name cap
05:12:34 <lambdabot> voted on "cap"
05:12:59 <doserj> Syzygy-: topdecl -> ... | data [context =>] simpletype = constrs [deriving] ...
05:13:15 <int-e> (you can vote in privmsg. I've just done that)
05:13:16 * Philippa suggests Simple Hat, abbreviated "shat" :-)
05:13:46 <nornagon> @choice-add mini-hat-name top
05:13:46 <lambdabot> New candidate "top", added to poll "mini-hat-name".
05:13:54 <nornagon> @choice-add mini-hat-name bowler
05:13:55 <lambdabot> New candidate "bowler", added to poll "mini-hat-name".
05:14:01 <nornagon> @choice-add mini-hat-name trilby
05:14:01 <lambdabot> New candidate "trilby", added to poll "mini-hat-name".
05:14:27 <beelsebob> Philippa: I don't think Olaf will be happy with that
05:14:33 <beelsebob> he wasn't happy with pimp
05:15:16 <earthy> Philippa: that's quite close to 'shit'
05:15:19 <beelsebob> @choice-add mini-hat-name shat
05:15:20 <lambdabot> New candidate "shat", added to poll "mini-hat-name".
05:15:34 <beelsebob> earthy: I believe that's the point
05:16:12 <Syzygy-> doserj: I don't think I'm even capable of parcing that.
05:16:15 <edwinb> I approve of 'wig'...
05:16:18 <cperfumo> I'm having this problem compiling GHC: http://paste.lisp.org/display/18640
05:16:27 <edwinb> it's something that's under a hat after all
05:16:28 <beelsebob> edwinb: excellent - that's two votes for either wig or toupe
05:16:34 <cperfumo> anyone could help me?
05:16:48 <edwinb> if you can get an implausible acronym you get extra points
05:16:50 <beelsebob> @choice-add mini-hat-name wig
05:16:51 <lambdabot> New candidate "wig", added to poll "mini-hat-name".
05:16:53 <beelsebob> @vote wig
05:16:54 <lambdabot> usage: @vote <poll> <choice>
05:17:03 <beelsebob> @vote mini-hat-name wig
05:17:03 <lambdabot> voted on "wig"
05:17:09 <beelsebob> edwinb: can you add your vote
05:17:13 <nornagon> @vote mini-hat-name trilby
05:17:13 <lambdabot> voted on "trilby"
05:17:22 <edwinb> beelsebob: I'm still trying to think of other names ;)
05:17:55 <beelsebob> I'm somewhat disapointed that pimp didn't get accepted
05:18:05 <beelsebob> what's the small cap that jews wear called?
05:18:21 <edwinb> given that I saw a language called Sausage recently, I don't see what's wrong with pimp
05:18:39 <beelsebob> edwinb: my dad wrote a language called banana
05:18:47 * quicksilver considers a weblog called Pimp My Combinator
05:18:53 <beelsebob> lol
05:19:03 <osfameron> because pimp's subject women, sometimes immigrant children, to sexual abuse for profit, wherease sausages don't ?
05:19:11 * beelsebob goes for the moment, keep voting
05:19:13 <beelsebob> and I'll be back
05:19:14 <nornagon> quicksilver: lol
05:19:19 <ttmrichte1> beelsebog, Yamulka?
05:19:33 <quicksilver> osfameron: depends on the sausage
05:19:34 <earthy> @choice-add mini-hat-name tiara
05:19:34 <lambdabot> New candidate "tiara", added to poll "mini-hat-name".
05:19:46 <Pastorn> cperfumo: haha :p "Could not find module `System.Directory':"
05:20:09 <ttmrichte1> Beeslebob, Sorry.  Turns out it's called a Kippah.
05:20:31 <cperfumo> Pastorn: what's funny?
05:20:38 <psi> ?yhjulwwiefzojcbxybbruweejw
05:20:39 <earthy> why tiara: because it's shiny! :)
05:20:39 <lambdabot> "\"#$%&'()*+,\""
05:20:43 <Pastorn> that ghc can't find it
05:20:56 <cperfumo> Pastorn: any suggestion?
05:21:00 <nornagon> @help yhjulwwiefzojcbxybbruweejw
05:21:01 <lambdabot> V RETURNS!
05:21:10 <Pastorn> nope
05:21:15 <Pastorn> sorry :(
05:22:08 <cperfumo> Pastorn: then, if you don't have anything useful to say, please shut up. We're here to cooperate, not to make fun of other's problems
05:22:23 <Pastorn> ?src (>>=)
05:22:24 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:22:30 <Pastorn> ?src Prelude.(>>=)
05:22:31 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:22:44 <Pastorn> ?src Monad.(>>=)
05:22:44 <lambdabot> Source not found. Are you on drugs?
05:22:46 <nornagon> @poll-results cheeky-off
05:22:47 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=1, AddFlag=2, No=4, Yes=14
05:24:35 <ttmrichte1> @vote mini-hat-name Kippah
05:24:35 <lambdabot> "Kippah" is not currently a candidate in this poll
05:24:52 <ttmrichte1> @poll-results mini-hat-name
05:24:53 <lambdabot> Poll results for mini-hat-name (Open): tiara=1, wig=1, shat=0, trilby=1, bowler=0, top=0, toupe=1, badger=0, cap=3, pimp=0
05:25:07 <Pastorn> could someone please show me the source for bind?'
05:25:18 <nornagon> Pastorn: It depends on the monad.
05:25:24 <nornagon> @src [] (>>=)
05:25:25 <lambdabot> m >>= k     = foldr ((++) . k) [] m
05:25:29 <Pastorn> oh...
05:25:31 <nornagon> @src Maybe (>>=)
05:25:32 <lambdabot> (Just x) >>= k      = k x
05:25:32 <lambdabot> Nothing  >>= _      = Nothing
05:25:36 <Pastorn> it's one of those...
05:25:43 <nornagon> @src State (>>=)
05:25:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:25:53 <nornagon> @src Reader (>>=)
05:25:54 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:26:02 <Pastorn> ?src IO (>>=)
05:26:02 <lambdabot> m >>= k     = bindIO m k
05:26:28 <Pastorn> ?src bindIO
05:26:28 <lambdabot> bindIO (IO m) k = IO ( \ s ->
05:26:28 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
05:27:05 <Pastorn> oh, right... you have to make an instance of >>= if you write a new Monad...
05:27:27 <nornagon> yup.
05:27:42 <nornagon> You probably don't need to write your own monads for a while yet :)
05:27:47 <Pastorn> @instance >>=
05:27:48 <lambdabot> Maybe you meant: instances instances-importing
05:27:56 <Pastorn> @instances >>=
05:27:56 <nornagon> @instances (>>=)
05:27:57 <lambdabot> Couldn't find class `>>='. Try @instances-importing
05:27:58 <lambdabot> Couldn't find class `(>>=)'. Try @instances-importing
05:28:05 <Pastorn> @instances Monad
05:28:05 <nornagon> @instances Monad
05:28:06 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:28:07 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:28:09 <nornagon> jinx
05:28:56 <Pastorn> what's ((->) r)?
05:29:44 <nornagon> @src ((->) r) (>>=)
05:29:44 <lambdabot> Source not found. Wrong!  You cheating scum!
05:29:49 <quicksilver> Pastorn: the reader monad
05:30:00 <quicksilver> Pastorn: aka functions expecting a parameter of type r
05:30:06 <quicksilver> which is provided by the evironment
05:30:23 <Pastorn> now i'm getting confused
05:30:30 <Pastorn> quicksilver: reading as in
05:30:33 <quicksilver> > do { x <- (+2) ; y <- (*3); return (x,y) } $ 10
05:30:34 <lambdabot>  (12,30)
05:30:38 <quicksilver> reading from the environment
05:30:39 <Pastorn> >read "1"
05:30:45 <quicksilver> no, nothing to do with that
05:31:07 <quicksilver> it's like 'having a global settings object alwyas present'
05:31:28 <Pastorn> a global variable?
05:31:29 <quicksilver> or, in other cases it's just like 'doing a whole bunch of calculations on a particular value'
05:31:48 <quicksilver> it's certainly one way to do things which, in a language with variables, you'd use a global variable for, yes :)
05:32:18 <Pastorn> ok
05:32:37 <quicksilver> it's also just used for clever function tricks, though
05:32:43 <Pastorn> hehe
05:32:45 <quicksilver> these may be more confusing than they are educational :)
05:32:59 <quicksilver> e.g. the mapping from (*) to 'square' is join in this monad
05:33:02 <quicksilver> > join (*) 3
05:33:04 <lambdabot>  9
05:33:24 <quicksilver> so join in the reader monad amounst to 'use the environment twice'
05:36:32 <beelsebob> @poll-result
05:36:33 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
05:36:45 <beelsebob> @poll-result mini-hat-name
05:36:46 <lambdabot> Poll results for mini-hat-name (Open): tiara=1, wig=1, shat=0, trilby=1, bowler=0, top=0, toupe=1, badger=0, cap=3, pimp=0
05:37:40 <beelsebob> any further ideas edwinb?
05:41:48 <edwinb> no, I think I'd just reel off a list of hat types which isn't really useful...
05:41:55 <beelsebob> no
05:42:27 <beelsebob> I was trying to find a nice small kind
05:42:37 <beelsebob> but couldn't really think of any that are always small
05:42:42 <beelsebob> looks like it's a run off between cap and wig
05:43:59 <Syzygy-> ?index (!!)
05:44:00 <lambdabot> Data.List, Prelude
05:44:08 <Syzygy-> ?doc Data.List
05:44:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
05:44:22 <beelsebob> o,qejuidbh
05:44:29 <beelsebob> with thanks from squisihe
05:44:32 <beelsebob> sorry 'bout that
05:45:03 <Syzygy-> ?index (!)
05:45:04 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
05:49:40 <syntaxfree> @pl \x -> q == apply x p
05:49:41 <lambdabot> (q ==) . flip apply p
05:55:52 <nornagon> ouch.
05:55:57 <nornagon> fissures.
05:56:19 <emk> syntaxfree: I'm starting to package up my probability stuff in Cabal format. If you'd like, we can use that as a starting point for a new version of PFP.
05:56:34 <quicksilver> nornagon: the tubes are breaking up
05:56:48 <nornagon> tuebz r clogg0red
06:00:37 <chessguy> g'morning haskellites
06:01:07 <Cheery> ?where hsdl
06:01:08 <lambdabot> I know nothing about hsdl.
06:01:13 <Cheery> ?where hSDL
06:01:14 <lambdabot> I know nothing about hsdl.
06:01:19 <Cheery> ?where SDL
06:01:20 <lambdabot> I know nothing about sdl.
06:01:25 <Cheery> ?where DSL
06:01:26 <lambdabot> I know nothing about dsl.
06:01:47 <nornagon> Cheery: it's a standard library these days, no?
06:02:05 <Lemmih> @where hssdl
06:02:06 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
06:03:33 <chessguy> ?seen Cale
06:03:33 <lambdabot> Cale is in #oasis, #haskell, #haskell-overflow and #ghc. I don't know when Cale last spoke.
06:12:58 <chessguy> hrmm
06:13:04 <chessguy> weird boot
06:13:16 <hpaste>  syntaxfree pasted "type synonym won't apply?" at http://hpaste.org/674
06:14:31 <hpaste>  syntaxfree annotated "type synonym won't apply?" with "ghc error" at http://hpaste.org/674#a1
06:20:45 <mightybyte> @users
06:20:45 <lambdabot> Maximum users seen in #haskell: 332, currently: 309 (93.1%), active: 25 (8.1%)
06:20:51 <allbery_b> syntaxfree:  the problem is that type synonyms need to be standalone; one side effect of this is that a class constraint as part of one generates a new type variable which won't unify with anything else, IME
06:20:53 <int-e> Hrm, what is ghc's interpretation of  type Snake = (Grid p) => [p] ?
06:21:15 <int-e> I would expect the compiler to complain about that synonym.
06:21:40 <allbery_b> basicaly Snake -> Snake translates as (forall p. Grid p => [p]) -> (forall p. Grid p => [p])
06:21:53 <int-e> (because p is free on the right side but is not mentioned in the synomym)
06:21:53 <syntaxfree> int-e: it doesn't. if you remove the movelist function, all compiles well.
06:22:46 <int-e> so we have an implicit forall there. then foldr1 just isn't polymorphic enough to cope with that type.
06:22:49 <hpaste>  mightybyte pasted "Simple TicTacToe Player" at http://hpaste.org/675
06:23:33 <syntaxfree> so, um removing the class constraint on the type synonym should fix it?
06:23:47 <mightybyte> If anyone has comments on my TicTacToe program, I'd like to hear them so I can improve my Haskell.
06:25:06 <allbery_b> yes, the constraint needs to be on each final. type, not the synonym else it gets implicitly forall-ed.  (ugly and annoying but I understand why it works that way)
06:25:57 <int-e> syntaxfree: I'd use  type Snake p = [p]
06:26:43 <hpaste>  metaperl pasted "why did I have to put fringe (Leaf a) instead of just fringe Leaf a" at http://hpaste.org/676
06:27:17 <quicksilver> metaperl: because fringe Leaf a means (fringe Leaf) a
06:27:38 <quicksilver> metaperl: juxtaposition == function application has highest priority and is left associative
06:27:53 <metaperl> oh ok thanks quicksilver
06:28:31 <hpaste>  syntaxfree annotated "type synonym won't apply?" with "this works" at http://hpaste.org/674#a2
06:28:42 <quicksilver> or, if you prefer this answer "Because constructors aren't 'special' but are just parsed as function applications"
06:28:55 <quicksilver> if the thing that surprised you was to do with Leaf being a constructor
06:29:06 <wkh> ?type liftA2
06:29:09 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
06:29:10 <narain> what's the canonical definition of a function that splits a list into chunks of size n?
06:29:18 <narain> is it this: chunks n list = takeWhile (not . null) $ map (take n) $ iterate (drop n) list
06:29:21 <syntaxfree> I'm trying to keep the snake logic representation-independent, because I don't know what graphic toolkit I will use.
06:29:23 <metaperl> I like the function application binds tighest and is left-associative answer
06:29:43 <chessguy> mightybyte, looks like a nice start. i would make sure all your functions have explicit type signatures, and start thinking about how to use monads to separate logic and IO
06:29:55 <Pastorn> how do i overload == for Maybe Int?
06:30:05 <bla123> @quicksilver: why do i have to write "f (do foo)" or "f $ do foo" instead of "f do foo"?
06:30:05 <lambdabot> Unknown command, try @list
06:30:20 <quicksilver> Pastorn: by defining a newtype
06:30:31 <quicksilver> Pastorn: Maybe has a built in instance for EQ
06:30:37 <quicksilver> Pastorn: so you can't override that
06:30:42 <Pastorn> ok
06:30:42 <syntaxfree> foldD should be defined for general Enum types.
06:30:58 <syntaxfree> I wonder if that's doable in Haskell.
06:31:08 <narain> bla: same thing metaperl just asked
06:31:14 <quicksilver> narain: well it's not, really
06:31:19 <narain> function application binds tightest
06:31:20 <quicksilver> narain: because 'do' isn't actually a function
06:31:21 <chessguy> bla123, same reason quicksilver just gave metaperl
06:31:24 <int-e> syntaxfree: what's the point of foldD?
06:31:31 <mightybyte> chessguy: Ok.  I don't really have a good idea of how I should use monads in it.  I would like to have something that lets me know how many nodes were searched by negamax.  I was thinking that monads might be useful there, but I don't know where to start.
06:31:36 <bla123> is "do" really a function?
06:31:41 <quicksilver> bla123: I imagine just because it's simplest for everyone if 'do' behaves syntactically like a function
06:31:53 <quicksilver> bla123: no, it isn't, it's a sugaring at the front-end
06:31:54 <chessguy> mightybyte, certainly they could be used for that
06:32:00 <bla123> ok
06:32:14 <narain> quicksilver: didn't think of that, thanks
06:32:18 <Pastorn> @paste
06:32:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:32:35 <chessguy> mightybyte, how much do you know about monads?
06:32:38 <quicksilver> but I think it's sanest if everything that looks liek a function behaves syntactically like one
06:32:45 <quicksilver> otherwise you get special cases :)
06:32:53 <mightybyte> chessguy: Not a whole lot yet.  I recently started going through a monad tutorial.
06:32:59 <quicksilver> (of course 'if' doesn't behave like a function, which some people have criticised)
06:33:14 <mightybyte> chessguy: That's where I got the idea that they could be used to help me count the nodes.
06:33:16 <chessguy> mightybyte, ah. state monads are probably the easiest to start with
06:33:24 <bla123> hm, a do-block with braces around it looks a bit strange to me
06:33:25 <syntaxfree> if should definitely be a function.,
06:33:46 <syntaxfree> I mean, who is crying for "then" and "else"?
06:33:51 <mightybyte> I was using the "All About Monads" tutorial at http://www2.lifl.fr/~boulet/formation/CALP/man/monads/html/
06:33:54 <lambdabot> Title: All About Monads
06:33:55 <chessguy> mightybyte, another thing you could try to do with this code is to try to generalize the negamax search
06:34:01 <syntaxfree> it should be just if (pred) (this) (that)
06:34:21 <resiak> syntaxfree: bleh, proliferation of brackets!
06:34:42 <narain> syntaxfree: that looks awfully lispy
06:34:47 <mightybyte> chessguy: Yes, I have thought about that.
06:35:22 <chessguy> personally, i'd like to see a class GameTree to capture searching/traversing operations on any game tree
06:35:23 <syntaxfree> the added benefit of having one less special construct pays off.
06:35:39 <mightybyte> Right
06:36:05 <int-e> 'then' and 'else' are useful visual clues though
06:36:07 <bla123> syntaxfree: interesting nickname, are you a lisp guy? ;-)
06:36:28 <int-e> and you *can* define a function if' if you want it.
06:36:36 <hpaste>  Pastorn pasted "is this a correct overloading of Eq for Maybe Int?" at http://hpaste.org/677
06:36:52 <narain> syntaxfree: what's the payoff?
06:37:20 <narain> syntaxfree: sounds interesting but i can't quite see it myself
06:37:48 <int-e> @source Maybe (==)
06:37:48 <lambdabot> Maybe (==) not available
06:38:08 <mightybyte> chessguy: There are two approaches one could take for that.  One would be create a new board each time a move is made, and the other would not.  The first option only requires a makeMove function.  The second requires a makeMove and an unmakeMove.  Both options have their uses and efficiency benefits.
06:38:37 <metaperl> how could you call the data constructor for the type Char and pass it a value and get back a result?
06:38:44 <allbery_b> Pastorn: you can't override (==) for Maybe.  you could create your own Maybe or use a newtype
06:39:00 <int-e> Pastorn: no, it's not correct. You have  Nothing == Just x (did you want that?), but you haven't defined the result of Just y == Nothing  at all. Also, Maybe comes with its own instance of Eq.
06:39:01 <Pastorn> what's a newtype?
06:39:33 <Pastorn> int-e: that is precisely why i want it :)
06:40:03 <int-e> Pastorn: well, don't use Maybe then, please.
06:40:03 <mightybyte> chessguy: But it also should be possible to make the searching operations independant of those methods.
06:40:29 <allbery_b> you also need to think about whether you care about Ord
06:40:43 <chessguy> mightybyte, from my perspective of chess programming, i've always kept the same board and had make and unmake
06:40:57 <mightybyte> chessguy, same here (in my chess programming)
06:41:11 <int-e> Pastorn: and that Eq instance will likely break things - your (==) isn't transitive.
06:41:24 <quicksilver> Pastorn: a newtype is a way of making a new type which is the same as an old one, but has different name
06:41:31 <chessguy> oh? what engine?
06:41:35 <quicksilver> Pastorn: it has the side effect that you redefine instances on it, though
06:41:53 <quicksilver> Pastorn: equally Maybe is so simple that you could simply define a brand new type which was similar :)
06:41:59 <narain> metaperl: does Char even have a data constructor?
06:42:06 <Pastorn> so:
06:42:18 <Pastorn> newtype Cell = Maybe Int
06:42:33 <metaperl> narain - I dont know... but i'm reading Gentle and it says that all syntactic sugar is just a cover-over for the "built-in" types. so I wanted to try it
06:42:36 <allbery_b> narain: it does internally but it's private
06:42:42 <allbery_b> @src Char
06:42:43 <lambdabot> data Char = C# Char#
06:42:49 <Pastorn> and then i do the instance of Eq?
06:42:53 <quicksilver> Pastorn: right
06:43:00 <Pastorn> cool
06:43:06 <quicksilver> narain: well logically 'a' and friends are all unary constructors
06:43:16 <quicksilver> narain: although the syntax is slightly different
06:43:34 <quicksilver> allbery_b: that's really specific to one implementation of Char, rather than part of the standard
06:43:38 <allbery_b> yes
06:43:45 <narain> quicksilver: oh yeah
06:43:56 <allbery_b> but on some level it'll still invlve a private constructor, possibly built into the compiler
06:44:14 <allbery_b> in any case it'll be inaccessible as such
06:44:18 <allbery_b> that said:
06:44:20 <allbery_b> :t chr
06:44:23 <quicksilver> allbery_b: I could say that 'a' is just sugar for __Char_LowercaseA
06:44:25 <lambdabot> Int -> Char
06:44:36 <quicksilver> allbery_b: and so on... large family of nullary constructors
06:44:44 <allbery_b> (also, toEnum :: Int -> Char)
06:44:45 <quicksilver> allbery_b: which would be rather different from the c# approach
06:45:01 <allbery_b> quicksilver: "possibvly built into the compiler"
06:45:23 <quicksilver> allbery_b: don't really agree, but I take your point
06:45:26 <allbery_b> although arguably that might be taken as built into the runtime instead
06:45:31 <quicksilver> I think the C# way is only one way to do it
06:45:40 <quicksilver> I think the huge family of nullary constructors is 'simpler'
06:45:45 <quicksilver> mathematically
06:46:08 <narain> i always liked the fact that the SML spec explicitly defines ..., -1, 0, 1, ... to be an infinite set of nullary constructors for ints
06:47:06 * allbery_b isn't very mathematicaly oriented :)
06:48:37 <quicksilver> narain: yes, exactly
06:53:50 <narain> quicksilver: ah, the Haskell 98 Report says the same about chars
06:54:04 <narain> "character literals are nullary constructors in the datatype Char."
06:54:15 <narain> so you're right
06:54:58 <bakert> ?pl (bq ("a" "b")) (map x t)
06:54:58 <lambdabot> bq "b" (map x t)
06:55:24 <bakert> ?pl bq "a" "b" $ map x t
06:55:24 <lambdabot> bq "a" "b" (map x t)
06:55:43 <narain> i had asked something before but didn't get a response, is it ok to ask again?
06:55:54 <bakert> ?pl f t = bq "a" "b" $ map x t
06:55:54 <lambdabot> f = bq "a" "b" . map x
06:56:58 <quicksilver> narain: sure
06:56:58 <narain> ?pl F f g h x = f (g x) (h x)
06:56:59 <lambdabot> F = liftM2
06:57:53 <narain> ok... what's the canonical definition of a function that splits a list into chunks of size n, is it the following?
06:58:14 <narain> chunks n list = takeWhile (not . null) $ map (take n) $ iterate (drop n) list
06:58:24 <quicksilver> not sure if that's canoncial or not but it looks OK
06:58:47 <narain> i was just wondering if there is a stunningly elegant solution everybody knows about
06:58:48 <quicksilver> does it handle the dangling few items ok?
06:58:55 <narain> it does
06:59:44 <quicksilver> you could probably pull off something with split, instead
06:59:46 <quicksilver> :t split
06:59:48 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
06:59:51 <quicksilver> erm not that
06:59:58 <quicksilver> :t splitAt
07:00:01 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:00:04 <quicksilver> yes, that one
07:00:09 <quicksilver> I'm not sure it would be any neater though
07:01:08 <narain> hmm ive never managed to come up with elegant solutions involving tuples
07:03:06 <narain> chunks n list = first : chunks n rest where (first, rest) = splitAt n list
07:03:24 <narain> that'll make an infinite list though :(
07:03:37 <narain> how do i run things using lambdabot?
07:04:02 <DynWind> @2+2
07:04:03 <lambdabot> Unknown command, try @list
07:04:08 <quicksilver> > 2+2
07:04:09 <DynWind> er, not like that
07:04:10 <lambdabot>  4
07:04:11 <earthy> > let chunks n list = first : chunks n rest where (first, rest) = splitAt n list in chunks 2 [1,2,3,4,5,6,7]
07:04:13 <lambdabot>  [[1,2],[3,4],[5,6],[7],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
07:04:41 <chessguy> @run 2+2
07:04:42 <lambdabot>  4
07:04:53 <quicksilver> let chunks n list = takeWhile (not.null) chunks' n list where chunks' n list = first : chunks' n rest where (first,rest) = splitAt n list in chunks 2 [1,2,3,4,5,6,7]
07:05:01 <quicksilver> > let chunks n list = takeWhile (not.null) chunks' n list where chunks' n list = first : chunks' n rest where (first,rest) = splitAt n list in chunks 2 [1,2,3,4,5,6,7]
07:05:02 <lambdabot>  Couldn't match expected type `[[a]]'
07:05:06 <quicksilver> blah
07:05:16 <quicksilver> narain: I think you could argue for that version  being clearer
07:05:27 <quicksilver> narain: you'll still need to put the takeWhile not.null in there somewhere
07:05:35 <quicksilver> narain: and ultimately clearness is subjective
07:05:38 <earthy> > let chunks n l = takeWhile (not . null) $ chunks' n l where chunks' n list = first : chunks' n rest; (first, rest) = splitAt n list in chunks 2 [1,2,3,4,5,6,7]
07:05:39 <lambdabot>   Not in scope: `list'
07:05:46 <narain> quicksilver: i agree! that's a lot of wheres though :) i like it though
07:05:53 <earthy> > let chunks n l = takeWhile (not . null) $ chunks' n l where chunks' n list = first : chunks' n rest where (first, rest) = splitAt n list in chunks 2 [1,2,3,4,5,6,7]
07:05:54 <lambdabot>  [[1,2],[3,4],[5,6],[7]]
07:06:40 <quicksilver> narain: I'd probably make one of both of them a 'let' in practice
07:08:09 <chessguy> so who's next up to get stumped by my non-random problem? http://hpaste.org/666#a1
07:08:29 <narain> > let chunks n [] = [] | chunks n list = first : chunks n rest where (first, rest) = splitAt n list in chunks 3 [1..10]
07:08:30 <lambdabot>  Parse error
07:08:44 <narain> ugh... that's my ML showing
07:09:11 <chessguy>  let chunks n [] = [] ; chunks n list = first : chunks n rest where (first, rest) = splitAt n list in chunks 3 [1..10]
07:09:14 <chessguy> > let chunks n [] = [] ; chunks n list = first : chunks n rest where (first, rest) = splitAt n list in chunks 3 [1..10]
07:09:16 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:09:28 <narain> success!
07:09:47 <quicksilver> yes, that's quite nice and idiomatic, IMO
07:09:54 <quicksilver> pattern match >> not.null test
07:10:18 <chessguy> narain, just needed a ; instead of a |
07:10:36 <narain> chessguy: yes, i see. thanks
07:11:15 <ephemient> > let chunks n = unfoldr (\l -> if null l then Nothing else return $ splitAt n l) in chunks 3 [1..10]
07:11:17 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:11:19 <ephemient> *shrug*
07:11:33 <quicksilver> ephemient: cute but not clear, IMO
07:11:46 <quicksilver> ephemient: if you're going to use return, and not Just, you might as well use fail and not Nothing :)
07:11:54 <ephemient> true :)
07:12:00 <narain> :t unfoldr
07:12:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:12:07 <ephemient> hmm. darn. Just is shorter to type than return, huh?
07:12:10 <quicksilver> I tend to use Just instead of return
07:12:13 <int-e> quicksilver: you mean guard :)
07:12:17 <metaperl> ephemient - that is some beautiful code
07:12:17 <quicksilver> and also (:[]) instead of return
07:12:51 <quicksilver> it's basically a coincidence that 'splitAt' returns exactly data in the shape unfoldr is looking for it
07:13:02 <quicksilver> well maybe it's a little stronger than a coincidence, but still
07:13:14 <quicksilver> normally using unfoldr is much clumsier-looking than taht
07:13:23 <narain> that's quite a neat hack (in a good way)
07:13:40 <ephemient> I wonder, though...
07:14:13 <ephemient> @pl \n l -> if null l then Nothing else Just $ splitAt n l
07:14:13 <lambdabot> ap (flip if' Nothing . null) . (Just .) . splitAt
07:14:21 <ephemient> whoa.
07:14:38 <quicksilver> can't you use the pattern match?
07:15:02 <quicksilver> do { x:xs <- l; return splitAt n l }
07:15:11 <quicksilver> that fails automatically if l is null
07:15:16 <ephemient> hey, that's really cute!
07:15:17 <quicksilver> instead of having to test it explicitly
07:15:55 <ephemient> :t \n -> unfoldr (\l -> do { _:_ <- l; Just $ splitAt n l })
07:15:58 <lambdabot>     Couldn't match expected type `[a]'
07:15:58 <lambdabot>            against inferred type `Maybe [t]'
07:16:08 <ephemient> bah.
07:16:12 <quicksilver> hmm what did I mean
07:16:12 <ephemient> :t \n -> unfoldr (\l -> do { _:_ <- Just l; Just $ splitAt n l })
07:16:15 <lambdabot> forall t. Int -> [t] -> [[t]]
07:16:17 <quicksilver> yes, that's it
07:18:22 <ephemient> @pl \l -> do { _:_ <- Just l; Just $ splitAt 0 l }
07:18:23 <lambdabot> (line 1, column 10):
07:18:23 <lambdabot> unexpected "{"
07:18:23 <lambdabot> expecting variable, "(", operator or end of input
07:18:40 <thartman> I thought you ghc 6.6 came with Quickcheck. But seems no. Do I need to install this from darcs repo?
07:18:43 <ephemient> @pl \l -> if null l then Nothing else Just $ splitAt 0 l
07:18:43 <lambdabot> ap (flip if' Nothing . null) (Just . splitAt 0)
07:18:55 <ephemient> hmm. so it doesn't really get better
07:19:23 <ephemient> :t \n -> unfoldr (ap (flip if' Nothing . null) (Just . splitAt n)) -- not so readable :)
07:19:25 <lambdabot> Not in scope: `if''
07:20:09 <allbery_b> if' is @pl's way of saying it can't deal with if
07:21:04 <emu> @src if'
07:21:04 <lambdabot> Source not found. My pet ferret can type better than you!
07:21:18 <emu> if' x y z | x = y | otherwise = z
07:25:42 <narain> > let f = \(x:xs) -> x in f [1,2,3]
07:25:43 <lambdabot>  1
07:25:53 <narain> sweet, you can pattern match in lambdas
07:26:41 <narain> > let chunks n = unfoldr (\(x:xs)@list -> Just $ splitAt n list) in chunks 3 [1..10
07:26:41 <lambdabot>  Parse error
07:26:52 <narain> > let chunks n = unfoldr (\(x:xs) -> Just $ splitAt n (x:xs)) in chunks 3 [1..10
07:26:52 <int-e> > ([1|False], [2|True])
07:26:53 <lambdabot>  Parse error
07:26:54 <lambdabot>  ([],[2])
07:26:56 <narain> > let chunks n = unfoldr (\(x:xs) -> Just $ splitAt n (x:xs)) in chunks 3 [1..10]
07:26:58 <lambdabot>   Non-exhaustive patterns in lambda
07:27:17 <narain> :(
07:27:23 <Cheery> Is there anything which is not an instance of Ord ?
07:28:07 <int-e> > let chunks n = takeWhile (not . null) . unfoldr (Just . splitAt n) in chunks 3 [1..10]
07:28:09 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:29:40 <narain> is there any way to do multiple clauses of pattern matching in a lambda?
07:29:57 <ndm> narain: you can use a case expression
07:30:09 <narain> ok
07:30:24 <ndm> > case [] of {[] -> error "here1"; (_ : _) -> error "here2"}
07:30:25 <lambdabot>  Exception: here1
07:30:34 <Cheery> case expr of { cond1 -> a1 ; cond2 -> a2 ; ... }
07:30:34 <ndm> > case "test" of {~[] -> error "here1"; (_ : _) -> error "here2"}
07:30:36 <lambdabot>      Warning: Pattern match(es) are overlapped
07:30:36 <lambdabot>              In a case alterna...
07:31:41 <emu> yea but you can't use guards or multiple patterns
07:34:18 <narain> well you could use multiple patterns by putting them in a tuple, right?
07:34:40 <emu> i mean disjunction
07:35:15 <narain> i don't follow
07:35:26 <narain> you'll have to excuse me, i'm kinda new at haskell
07:36:12 <emu> if the pattern fails to match you cannot specify an alternative, in a lambda
07:37:23 <narain> > case 1 of {0 -> "foo"; otherwise -> "bar"}
07:37:25 <lambdabot>  "bar"
07:37:32 <narain> i assume that's not what you meant?
07:37:33 <emu> disjunction is not a haskell term, it just means logical OR
07:37:43 <emu> you have to use case explicitly, yes
07:38:01 <hpaste>  Cheery pasted "non-haskell-98 constructor(s)" at http://hpaste.org/678
07:40:22 <allbery_b> shouldn't the constraint go on the other side?
07:41:29 <allbery_b> hm, no
07:42:26 <allbery_b> actually, yes
07:42:45 <allbery_b> data Ord a => Quantity a = Quantity a String deriving (Show) -- works
07:43:02 <hiker> hello, all... is this the proper place to ask qeustion about HOpenGL?
07:43:02 <quicksilver> that will throw an exception when it hits the null list though
07:43:13 <quicksilver> oops, replying to old message, sorry
07:46:00 <Cheery> allbery_b: so, why there is that another way of doing it?
07:46:39 <allbery_b> hm?  the one I wrote is valid Haskell98.  the way you tried it is a GHC extension; what it's suppose dto mean, I'm not sure
07:47:12 <allbery_b> I'm barely H98-conversant, never mind ghc extensions
07:47:50 <glguy> data Quantity a = (Ord a) => Quantity a String
07:47:55 <glguy> doesn't do what you probably expect that it does
07:48:04 <allbery_b> but, at a guess, the H98 way applies to the type; the extension applies only to the data constructr
07:48:55 <allbery_b> which implies that referring to the type *doesn't* get you an Ord constraint automatically
07:49:16 <allbery_b> even if what you construct has the Ord constraint
07:51:19 <allbery_b> er, even if what you feed to the constructor ...
07:52:27 <allbery_b> hrm, darcs ghc is still producing a bogus ghci :/
07:53:27 <Cheery> allbery_b: urgh. I see.
07:53:36 <Cheery> :) I understand what's going on there now, thanks.
07:54:24 <glguy> Cherry, what you wanted only exists in GHC HEAD, data Quantity a where Quantity :: Ord a => Quantity a String
07:56:13 <glguy> err, Ord a => a -> String -> Quantity a
07:56:54 <allbery_b> I'm not sure that's what he wanted, he just had confuson over syntax
07:57:22 <glguy> That's what you have to do if you want the Ord instance to be carried around
07:57:44 <glguy> so that functions that use that instance won't have to re-declare that you are using an instance of Ord
07:57:56 <glguy> s/instance/constructor
07:59:44 <glguy> data ExampleA a where ExampleB :: Ord a => a -> a -> ExampleA a; example :: ExampleA a -> ExampleA a -> Bool; example (ExampleB x)(ExampleB y) = x < y
08:00:10 <glguy> the Ord gets carried along and doesn't need to be explicitly declared in the "example" function
08:00:15 <glguy> that wasn't what he was trying to do?
08:00:35 <glguy> (that and the fact that I did that wrong
08:00:40 <allbery_b> data Ord a => Quantity a = Quantity a String deriving (Show) -- this is what he wanted
08:00:43 <glguy> example (ExampleB x y ) = x < y
08:00:59 <allbery_b> he then asked why ghc accepted the other syntax but wouldn't derive Ord
08:00:59 <glguy> allbery_b: what I'm saying is that he *doesn't* want that Ord constraint there
08:01:07 <glguy> because it doesn't do much useful
08:01:21 <allbery_b> hrm
08:01:37 * allbery_b meant deriving (Ord)
08:01:38 <allbery_b> durr
08:03:24 <glguy> then he wants: data Quantity a = Quantity a String deriving (Eq, Ord)
08:03:42 <allbery_b> yeh
08:04:08 <glguy> I wonder if he even sees this
08:04:18 <allbery_b> Cheery?
08:04:22 <glguy> yeah :)
08:04:34 <allbery_b> eep.  no, was askingif he was still around :)
08:08:24 <quicksilver> this is (a/the) problem with some of these type systems extensions
08:08:35 <quicksilver> people think they need them when they don't actually even want them :)
08:09:03 <allbery_b> or just get confused by them
08:09:34 <xic> @hoogle renameFile
08:09:35 <lambdabot> Directory.renameFile :: FilePath -> FilePath -> IO ()
08:10:09 <Cheery> allbery_b: yes?
08:10:56 <Cheery> data Quantity a = Quantity a String deriving (Eq, Ord) is not exactly what I wanted. :) I just wanted that a implements Ord.
08:11:40 <Cheery> argh, instances.
08:12:41 <Cheery> possibly, after that, It'd usually go that you instance Ord (Quantity a)
08:16:59 <norpan> do you want instance (Ord a) => Ord (Quantity a) where ...?
08:24:52 <Cheery> norpan: that's one way btw. :)
08:26:18 <glguy> Cheery: if you want to guarantee that the a in Quantity a is an instance of Ord and you want functions to be able to assume that, you'll need a development version of GHC
08:27:15 <chessguy> hey glguy, feel like looking at a snippet of code that seems to be stumping a lot of people? http://hpaste.org/666#a1
08:27:59 <int-e> chessguy: 666, eh?
08:29:10 <chessguy> int-e, yeah, go figure
08:29:20 <nmessenger> It's the paste of the beast!
08:29:36 <chessguy> it's definitely a beastly paste
08:29:49 <chessguy> even stumped sorear
08:30:03 <glguy> well, it's also a partial paste
08:30:30 <int-e> chessguy: the result doesn't look very random *g*
08:30:37 <glguy> so if you've assumed something wasn't a problem that was , no one will find it
08:30:55 <chessguy> int-e, that's why it's broken
08:31:09 <chessguy> glguy, i can paste the whole thing if you really want
08:31:21 <chessguy> i think it's fairly self-contained though
08:32:34 <chessguy> i thought test cases were a good thing
08:35:28 <glguy> take (arity gene) (repeat (max-1)) -- is -- replicate (arity gene) (max - 1)
08:35:41 <glguy> (still looking)
08:35:48 <int-e> chessguy: hmm. looks reasonable.
08:35:50 <glguy> oh, sorear got that
08:36:22 <glguy> I think it's probably something like your gene list is [] or terminals are [] or you aren't using an actual RandomGen instance :)
08:37:50 <int-e> genes = [Double], terminals = [Three]. that would fit (and maxDepth = 2)
08:42:13 <cperfumo> hi all, i'm having this problem when I try to compile GHC http://paste.lisp.org/display/18640
08:42:22 <cperfumo> any suggestion?
08:42:42 <cperfumo> basically, the error is Could not find module `System.Directory':
08:44:30 <chessguy> genes and terminals are definitely not []
08:44:41 <Cale> cperfumo: I recommend using the binary release unless you really need to compile it (for instance, if you're making modifications to it)
08:44:41 <chessguy> i'm not sure what you mean by not using an actual RandomGen instance
08:45:00 <int-e> chessguy: ok, I tried the code with genes = terminals = [Single, Double, Triple] and arity _ = 1 and it produces different trees
08:45:28 <int-e> chessguy: (note that my Gene type is different from yours)
08:45:35 <chessguy> hmm
08:45:35 <Cale> cperfumo: which platform are you running?
08:45:45 <chessguy> what did you do, type Gene = Double ?
08:46:01 <int-e> chessguy: data Gene = Single | Double | Triple deriving Show
08:46:29 <chessguy> int-e, can you annotate your results?
08:48:05 <hpaste>  int-e annotated "getting the same "random" program every time..." with "foo" at http://hpaste.org/666#a3
08:49:36 <chessguy> hmm, interesting
08:49:51 <chessguy> i don't understand why yours works and mine doesn't
08:50:44 <nmessenger> chessguy: paste your Gene, GlobalState, genes, terminals, and arity
08:54:25 <hpaste>  chessguy annotated "getting the same "random" program every time..." with "more info" at http://hpaste.org/666#a4
08:54:31 <chessguy> nmessenger, ^^
08:56:20 <nmessenger> instance Show Gene where show = name ?
08:56:22 <int-e> chessguy: that doesn't match your results at all.
08:56:57 <Cale> chessguy: where are you getting your StdGen from?
08:57:16 <Cale> (Ignoring all your code, and just looking at the title)
08:57:27 <chessguy> int-e, instance Show Gene where  show = name  -- if that's what you're confused about
08:57:44 <nmessenger> Cale: in his sample repl output, he did "GlobalState { randomGen = mkStdGen 42 }"
08:57:48 <Cale> If it's that mkStdGen 42
08:57:54 <int-e> chessguy: naa, I could guess that.
08:57:59 <Cale> then your problem is that you're passing in the same random seed.
08:58:19 <chessguy> Cale, yes, but i'm using the seed multiple times, and updating it
08:58:27 <chessguy> and different seeds don't help either
08:58:39 <chessguy> int-e, what isn't matching up then?
08:58:41 <Cale> ah, okay.
08:58:46 <nmessenger> Cale: the problem isn't that it produces the same result each run, but that the generated tree doesn't seem to be random
08:59:15 <int-e> chessguy: and I can't reproduce your result either.
08:59:40 <quicksilver> Cale: ah, I know what I was going to mention to you
08:59:49 <hpaste>  int-e annotated "getting the same "random" program every time..." with "using chessguy's definitions" at http://hpaste.org/666#a5
08:59:50 <wkh> people thought they could sell a lazy pure functional programming with a trademarked name in the 80s?!
08:59:59 <quicksilver> Cale: Re: the List monad not working well on infinite lists
09:00:07 <Cale> wkh: yes, Miranda
09:00:11 <wkh> computers are > 100 times more powerful and you still can't get them to use Haskell, whcih is free!
09:00:18 <int-e> chessguy: the rest of the code that I'm using is from the second annotation (i.e. your code, not sorear's refactor)
09:00:30 <chessguy> wtf
09:00:32 <quicksilver> Cale: it would be better to replace 'concat' with something which does fair infinite choice
09:00:35 <Cale> wkh: Miranda had some educational users
09:00:45 <quicksilver> Cale: a diagonal striping for example
09:01:10 <Cale> quicksilver: you have to be careful though, that whatever you pick still satisfies the monad laws
09:01:13 <nmessenger> chessguy: it's official, your box is infested with voodoo fairies.
09:01:29 <chessguy> i'm so confused
09:01:32 <quicksilver> Cale: sure, but I think it would
09:01:39 <hpaste>  int-e annotated "getting the same "random" program every time..." with "for the sake of it, my complete code" at http://hpaste.org/666#a6
09:01:49 <quicksilver> Cale: I'm viewing lists as a concretion of sets
09:01:58 <quicksilver> Cale: and sets were in Moggi's paper as an example
09:02:19 <quicksilver> Cale: hmm on reflection I think Moggi was talking about finite sets, though.. I wonder if something breaks
09:03:32 <mattam> quicksilver: give me your monad, I can prove the laws in Coq if you like :)
09:03:38 <int-e> chessguy: note that in order to produce the result you got, arity must return 1 - that smells extremely fishy.
09:04:22 <quicksilver> mattam: it's just list, with bind redefined
09:04:30 <quicksilver> mattam: so that concat does diagonal striping
09:04:40 <nmessenger> chessguy: I copy/pasted your code and used int-e's example repl expression and got int-e's result.
09:04:47 <quicksilver> mattam: so that a single infinite set of options doesn't block all other possibilities
09:04:48 <chessguy> GRRRR
09:05:09 <chessguy> int-e, you used arity _ = 1 and got that non-random result?
09:05:32 <mattam> Hmm, and you have unit = ?
09:05:59 <mattam> I'd like to see the code
09:06:25 <int-e> chessguy: I used arity _ = 1 in the first test which produced uniformely shaped trees (but still with different labels)
09:06:28 <cperfumo> Cale: I DO need to recompile... i'm doing several modifications. In fact I've been modifying it for longer than one month but now, after I don't know what it broke. The platform: Pentium Dual Core, Suse 10.1
09:06:41 <chessguy> sigh
09:06:51 <chessguy> i'm going to have to try this again when i get home. i'm so confused
09:07:17 <glguy> I look forward to the day when every link submitted to reddit is about how to access a database, run a query and fill out a form.
09:07:20 <glguy> Let's go shopping!
09:07:23 <glguy> -- dons
09:08:11 <allbery_b> <Cheery> data Quantity a = Quantity a String deriving (Eq, Ord) is not exactly what I wanted. :) I just wanted that a implements Ord.
09:08:11 <glguy> next up for reddit: News Flash! -- Programming is Hard!
09:08:12 <quicksilver> mattam: unit = :[] as normal
09:08:15 <allbery_b> (delayed response)
09:08:21 <allbery_b> the problem here is that Ord *requires* Eq
09:08:44 <int-e> glguy: and the only way that I can explain your results is that  genes = [Double], terminals = [Three] and arity Double = 1. (using 'Double' as a placeholder for Gene double ? "Double")
09:08:56 <allbery_b> that is, the definition of Ord relies on the existence of Eq
09:08:59 <glguy> int-e: my results?
09:09:18 <chessguy> glguy, that was meant for me
09:09:29 <int-e> glguy: sorry. I meant chessguy
09:09:50 <int-e> (the other 'guy')_
09:09:52 <mattam> quicksilver: Can you show bind ?
09:10:17 <chessguy> int-e, but i gave you what my genes are
09:10:29 <quicksilver> mattam: I haven't written in down in haskell. Do you know what I mean by diagonal stripes?
09:10:38 <int-e> chessguy: yes, I hope you'll figure out how this went wrong once you get home :)
09:10:45 <quicksilver> mattam: the standard bijection between N x N and N
09:11:12 <int-e> chessguy: it's sorta pointless to try to debug working code *g*
09:11:49 <chessguy> maybe my REPL input was bad?
09:14:03 <chessguy> never has "working code" sounded so annoying :)
09:14:35 <chessguy> ?remember nmessenger it's official, your computer is infested with voodoo fairies.
09:14:35 <lambdabot> Done.
09:14:52 <nmessenger> :)
09:15:16 <mattam> Yes, but i do not see how you strip
09:15:22 <nmessenger> but I said *box*, thats much cooler.
09:15:27 <chessguy> heh
09:15:38 <chessguy> i thought that sans-context, 'computer' would be clearer
09:15:48 <wkh> genetic programming is an inherently stateful thing
09:15:53 <wkh> why not use an impure language?
09:16:05 <nmessenger> *grumble*,  *reluctant agreeing*
09:16:46 * wkh had a quite good experience implementing new particle swarm optimization algorithms in OCaml
09:16:48 <chessguy> wkh, just because something is stateful doesn't mean haskell {c,sh}ouldn't be used for it
09:17:05 * nmessenger considers @remember chessguy int-e, but i gave you what my genes are
09:17:14 <nmessenger> :P
09:17:22 <chessguy> heh
09:17:43 <chessguy> i knew that was going to come back to bite me
09:18:28 <glman> hpaste is highly stateful :)
09:19:39 <chessguy> glman, yeah, but everybody knows that hpaste's programmer is a schmuck
09:19:58 <glman> which has nothing to do with Haskell :)
09:20:07 <nmessenger> gl*man*!?
09:20:11 <wkh> when prototyping optimization algorithms, you want a minimum of distraction, you want to express the intent of the algorithm as clearly as possible
09:20:15 <mattam> quicksilver: I mean, where do you say no i don't want to try that value ? How do you strip the result, with which test on the input list ?
09:20:19 <glman> nmessenger: to help int-e out
09:20:21 <wkh> lazy evaluation and purity don't really buy you anything as i see it
09:20:50 <glman> wkh: if you can't see the benefits, then don't use Haskell for it :)
09:21:06 <pejo> wkh, purity makes it easier to reason about things. I'd say that is a benefit.
09:21:40 <wkh> i guess if all you ever want to use is a hammer, everything looks like a nail
09:22:13 <glman> so you've got extensive Haskell experience that helps you back up the assumption?
09:22:55 <paperbot> wkh: Au contraire, see http://www.cs.hmc.edu/~oneill/papers/Combinators-ASPGP.pdf
09:23:29 <quicksilver> mattam: I was giving you the definition for join, not bind
09:23:36 <quicksilver> mattam: because that happens to be easier to formulate
09:23:39 <quicksilver> mattam: sorry, I wasn't clear :)
09:23:41 <chessguy> wkh, the idea here is to allow maximum flexibility in experimenting with different genetic operators, selection, and other parameters. purity makes it easier to reason about such things, i think
09:23:58 <quicksilver> mattam: defining bind directly without reference to join is slightly harder to describe
09:23:59 <shapr> Good Morning #haskell!
09:24:04 * shapr boings cheerfully
09:24:12 <glman> heya!
09:24:51 <quicksilver> wkh: 'express the intent of the algorithm as clearly as possible' is generally easier in a pure language
09:25:10 <shapr> glman: Are you using a new more mature nickname? :-)
09:25:36 <glman> shapr: I've grown up
09:25:39 <glman> :-D
09:25:51 <nmessenger> 12:09 <int-e> glguy: sorry. I meant chessguy
09:25:52 <nmessenger> 12:09 <int-e> (the other 'guy')_
09:26:00 <zarvok> Does anyone have examples of projects that have used parsec? I just need examples of monadic parser combinators being useful
09:26:22 <mattam> quicksilver: ok
09:26:23 <int-e> for the record I didn't mean that any of the two, chessguy and glguy, should change their nick
09:26:28 <shapr> glman: Yay!
09:26:44 <gldude> :P
09:26:49 <bos31337> zarvok: they're useful anywhere you'd need a parser.
09:27:03 <sehute> yo
09:27:03 <zarvok> bos31337: I agree, I just need some examples for something I'm writing
09:27:04 <shapr> zarvok: Nearly everything ends up using parser combinators.
09:27:14 <chessguy> int-e, yeah, we're quite distinctive. glguy is a  haskell pro, and i'm a haskell schmuck
09:27:18 <glman> int-e: oh, you didn't??
09:27:20 <shapr> zarvok: I wrote an RFC822 parser with Parsec.
09:27:29 <int-e> glguy: nope.
09:27:39 <glguy> :-p
09:27:41 <glguy> ok
09:27:46 <zarvok> shapr: cool, do you have a link?
09:27:54 <shapr> zarvok: Peter Simons picked it up, rewrote it to be RFC2822 (Is that the RFC822 update?) and turned it into hsemail.
09:28:01 <bos> i parse gcc tree dumps wit parsec.
09:28:02 <shapr> Yeah, I can get you a link..
09:28:05 <zarvok> ah, cool, that's great, thanks
09:28:10 <zarvok> I can find it now, thanks
09:28:22 <shapr> zarvok: http://cryp.to/hsemail/
09:28:24 <lambdabot> Title: Parsers for the Internet Message Standard
09:28:47 <zarvok> shapr: this is perfect, thanks
09:29:03 <sehute> If any of you should write a real-time raytracer, would you choose GHC (Haskell), Stalin (Scheme), GCC (C) or some other language/compiler?
09:29:20 <bos> depends on the need.
09:29:28 <zarvok> clearly 2D is the language of choice for raytracers
09:29:30 <shapr> hsemail is especially cool because it uses RFC2234 combinators. It's almost like a real DSL!
09:29:50 <bos> presumably nobody writes realtime raytracers without a purpose.
09:30:11 <zarvok> shapr: yeah, I was just looking at it, it does seem cool
09:30:24 <sehute> zarvok: what is "clearly 2D"?
09:30:38 <zarvok> sehute: it was a joke referencing the 2006 ICFP contest
09:30:50 <zarvok> www.boundvariable.org
09:31:49 <zarvok> participants had to write a 1 dimensional ray tracer in a crazy language that consisted of laying out ascii art circuits in a text file
09:32:13 <zarvok> called 2d
09:32:18 <sehute> zarvok: oh
09:32:33 <nmessenger> @google 2d programming language
09:32:36 <lambdabot> http://flourish.org/orthogonal.html
09:32:36 <lambdabot> Title: Excel Orthogonal
09:32:38 <int-e> and people cheated *g*
09:32:49 <zarvok> heh, true
09:32:55 <sehute> zarvok: I see. Well, other cool obscure languages I can think of are: brainfuck and shakespeare
09:33:07 <nmessenger> whitespace!
09:33:19 <DynWind> unlambda, ofcourse
09:33:22 <araujo> malborge!
09:33:34 <nmessenger> = brainfuck with whitespace as the commands
09:33:38 <int-e> the Unlambda road to Haskell ...
09:33:43 <Saizan> ?hoogle String -> [Word8]
09:33:44 <lambdabot> No matches, try a more general search
09:33:46 <araujo> petit ftw
09:34:04 <Saizan> ?docs Data.ByteString
09:34:05 <lambdabot> Data.ByteString not available
09:34:06 <zarvok> heh
09:34:09 <zarvok> I like Lazy K
09:35:12 <nmessenger> @type fromEnum
09:36:06 <zarvok> sehute: anyway, I didn't mean to distract people from your question with my joke, sorry!
09:36:08 <nmessenger> > map (fromEnum :: Char -> Word8)
09:36:09 <lambdabot> forall a. (Enum a) => a -> Int
09:36:10 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Int'
09:36:22 <nmessenger> > map (toEnum . fromEnum :: Char -> Word8)
09:36:23 <lambdabot>  <[Char] -> [Word8]>
09:36:54 <sehute> zarvok: no stress :)
09:37:02 <nmessenger> Saizan: that work?
09:37:21 <sehute> zarvok: Stalin seems like a good choice
09:37:39 <Saizan> nmessenger: ah, right!
09:37:41 <nmessenger> Saizan: though I think there should be a (String -> ByteString) somewhere
09:37:45 <nmessenger> pack?
09:38:11 * nmessenger not used ByteString
09:38:35 <Saizan> i've even a name for that, id'
09:38:37 <zarvok> sehute: I don't know much about it, except that it's some sort of scheme compiler.  But may I recommend: types!
09:39:27 <nmessenger> http://www.cse.unsw.edu.au/~dons/fps/
09:39:35 <zarvok> or at least, better types
09:39:35 <Saizan> nmessenger: there is, but i don't need ByteString
09:42:36 <sehute> Ah, I'm a convert. Chicken seems like a very good choice for Scheme.
09:43:01 <sehute> (Mainly based on a glance of the supported libraries)
09:43:21 <sehute> oups, wrong channel
09:44:42 <sehute> thanks for the answers, see you around
09:44:57 <glguy> !say uncle
09:44:58 <hpaste> uncle
09:45:16 <nmessenger> @id card, please
09:45:17 <lambdabot>  card, please
09:45:55 <glguy> !say @id card, please
09:45:56 <hpaste> @id card, please
09:45:57 <lambdabot>  card, please
09:46:01 <nmessenger> :D
09:46:29 <glguy> ?losers!
09:46:30 <lambdabot> Unknown command, try @list
09:46:32 <glguy> ?losers
09:46:33 <lambdabot> Maximum users seen in #haskell: 332, currently: 322 (97.0%), active: 46 (14.3%)
09:46:37 <glguy> zomg!
09:46:41 <glguy> ;0)
09:46:43 <nmessenger> @yow!
09:46:45 <lambdabot> I wish I was a sex-starved manicurist found dead in the Bronx!!
09:46:50 <wkh> internet
09:48:10 <dylan> is waiting on, say, five TVars slow?
09:48:35 <glguy> dylan: it is if they never change!
09:48:48 <dylan> well, if they change at some interval.
09:49:22 <dylan> I'm writing a status-display widget, which basically prints out a line of things like: procs(97) :: Mon 12:46 :: 85%
09:49:59 <dylan> each bit of text is produced by a seperate thread that only wakes up when it feels like it (say, sleeping 30 secs for the battery percentage one)
09:50:05 <audreyt> is there a Data.SkipList implementation in haskell somewhere?
09:50:10 * shapr hugs audreyt 
09:50:13 <shapr> Hiya!
09:50:17 <audreyt> heya!
09:50:27 <dylan> and I'd only like to output a new line of text when it's going to be different.
09:50:27 <shapr> How's life in the exciting east?
09:50:45 <dylan> I suppose a better question is: can one do a non-busy wait on TVars?
09:50:45 <audreyt> shapr: I just survived from a close encounter with liver failure
09:50:55 <shapr> Yikes!
09:51:14 <glguy> *CLICK HERE* IS NOT AN APPROPRIATE HYPERLINK
09:51:24 <audreyt> # http://pugs.blogs.com/pugs/2007/02/intermission_ov.html
09:51:24 <bos> audreyt: i've looked for skiplists, but not found any. and eek! re liver.
09:51:25 <lambdabot> Title: Pugs: Intermission over.
09:51:43 <bos> audreyt: have you considered using a finger tree instead?
09:51:56 <audreyt> bos: mere curiousity, actually.
09:52:21 <shapr> @google skiplist filetype:lhs
09:52:25 <lambdabot> http://darcs.brianweb.net/hsutils/src/Brianweb/Data/List.lhs
09:52:37 <shapr> Hm, that doesn't look like the right thing.
09:52:40 * wkh doesn't want any leet lambda hax0rs to die :(
09:52:42 <osfameron> do skiplists do something similar to Enfilads ?
09:52:45 <audreyt> not at all (I've googled.)
09:53:13 * glguy sets out to delete all files with ">Click Here</a>" on the Internet
09:53:35 <shapr> audreyt: I'm glad you're better!
09:53:37 <bos> osfameron: a skiplist is a probabilistic tree-like, list-like thingy.
09:53:59 * nmessenger is impressed at glguy's ability to delete things on server to which he hasn't access.
09:54:07 <shapr> Speaking of leet hax0rs
09:54:20 <glguy> nmessenger: people that do shit like that use windows 98 fileservers, I'm winnuking them
09:54:47 <osfameron> bos: ah, ok, the skipping is random, that's not what I was thinking of with enfilades, thanks
09:55:27 <nmessenger> glguy: just don't get caught :)
09:55:52 * nmessenger also campaigns against the dreaded "Click Here!"
09:56:25 <bos> osfameron: the skipping isn't random during a traversal; it's random during the construction.
09:56:56 <chessguy> glguy, i'd be willing to bet that similarly stupid people have infiltrated the windows 2000 server realm, and more
09:56:59 <bos> having to use a data structure where all of the building has to happen inside a monad would be a mite annoying.
09:57:23 <shapr> Wait, I think I have seen skiplist code in one of Rabhi & Lapalme's Algorithms or Okasaki's Algorithms books.
10:04:43 <shapr> But I don't have time to look up more about SkipLists at the moment.
10:05:25 <bos> okasaki doesn't cover skiplists.
10:05:44 <shapr> oh, too bad.
10:06:14 <bos> they're easy to use, but you have to be able to generate a random number for each insertion.
10:08:16 <glguy> that doesn't sound so bad if the random seed is stored in the list
10:19:28 * shapr boings happily
10:32:13 <rme> Excuse me.  I'm on an amazon.com binge, and was wondering if there is a canonical Haskell book?
10:32:39 <chessguy> ?where book
10:32:40 <edwinb> Graham Hutton's new one is very nice :)
10:32:40 <lambdabot> I know nothing about book.
10:32:42 <chessguy> ?where books
10:32:43 <lambdabot> I know nothing about books.
10:33:01 <chessguy> rme, it really depends on your level
10:33:29 <chessguy> many of these are good: http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
10:33:31 <lambdabot> Title: Books and tutorials - HaskellWiki
10:33:34 <chessguy> ?where+ books http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
10:33:35 <lambdabot> Done.
10:33:38 <rme> How about for a reasonably competent lisper?
10:34:20 <Philippa> edwinb: I should have a decent flick through it sometime, might get a copy for teaching other people with
10:34:28 <chessguy> well, i've only read two haskell books, so i really can't make any specific recommendations
10:34:46 <chessguy> my understanding of the Hutton book is that it's fairly basic, but i've not read it
10:34:57 <edwinb> it covers quite a lot
10:35:15 <edwinb> in a nice concise but readable way
10:35:24 <dcoutts_> edwinb, so you made it back then :-)
10:35:27 <edwinb> but I h aven't read it vwery closely either yet ;)
10:35:29 <rme> Not too elementary?
10:35:56 <edwinb> dcoutts_: I'm still on the train!
10:36:03 <edwinb> hoorah for gner and their wireless
10:36:08 <chessguy> i've been impressed with HSOE. it starts very basic, but by the end you're doing some pretty cool stuff
10:36:13 <dcoutts_> edwinb, hah hah hah
10:36:41 <Philippa> ouch. I thought I had fun getting back from manchester yesterday
10:38:51 <glguy> > let { tabulate bounds f = array bounds [(i,f i) | i <- range bounds]; dp bounds f = (memo!) where memo = tabulate bounds (f (memo!)); fib n = dp (1,n) f n where {f g 1 = 1; f g 2 = 1; f g i = g (i-2) + g (i-1)}} in fib 10
10:38:52 <lambdabot>   Not in scope: `fib'
10:38:56 <glguy> what am I doing wrong here?
10:40:00 <edwinb> I'll be home in an hour or so...
10:40:14 <xerox> glguy: fib is local to tabulate.
10:40:20 <glguy> OOH
10:40:23 <edwinb> Philippa: I'm prepared for Brussels to St Andrews to take a while really ;)
10:40:33 <glguy> > let { tabulate bounds f = array bounds [(i,f i) | i <- range bounds]; dp bounds f = (memo!) where {memo = tabulate bounds (f (memo!))}; fib n = dp (1,n) f n where {f g 1 = 1; f g 2 = 1; f g i = g (i-2) + g (i-1)}} in fib 10
10:40:35 <lambdabot>  55
10:40:38 <glguy> > let { tabulate bounds f = array bounds [(i,f i) | i <- range bounds]; dp bounds f = (memo!) where {memo = tabulate bounds (f (memo!))}; fib n = dp (1,n) f n where {f g 1 = 1; f g 2 = 1; f g i = g (i-2) + g (i-1)}} in fib 200
10:40:40 <lambdabot>  280571172992510140037611932413038677189525
10:40:45 <Philippa> edwinb: fair enough :-)
10:40:53 <Philippa> I just got stuck on coaches instead of trains
10:41:09 <glguy> behind a horse?
10:41:23 <Philippa> was Brussels fun? Manchester definitely was, although for reasons that belong in -blah
10:42:06 <edwinb> Brussels was good. We need a haskell booth at FOSDEM next year ;)
10:42:53 <Philippa> heh. I'm just going to have to go back to Manc to collect a sock :-)
10:49:39 <quicksilver> mattam: monad definition for you
10:49:43 <hpaste>  quicksilver pasted "new list monad with better enumeration of infinite choices" at http://hpaste.org/680
10:50:02 <quicksilver> Cale: that's what I was talking about
10:53:21 <fons> hi all
10:54:36 <fons> is there a tutorial or cookbook chapter wich deals with regular expressions in Haskell? I'm a bit lost with the generic way in which regular expressions are included in the standard library
10:56:12 <bos> fons: just use compile to compile a regex, then execute to run it.
10:56:51 <fons> bos, does that imply getting into the IO monad?
10:57:02 <bos> yes.
10:57:16 <bos> you can see that by looking at the type signatures of the functions in the module.
10:57:18 <tibbe> @srcs foldr
10:57:18 <lambdabot> foldr k z xs = go xs
10:57:19 <lambdabot>     where go []     = z
10:57:19 <lambdabot>           go (y:ys) = y `k` go ys
10:57:31 <bos> they mostly end with "-> IO foo" for some foo
10:57:57 <fons> then that's not an option :S, in order to see if a string matches a regular expression I don't see why do I have to enter IO
10:58:26 <xerox> ?hoogle regexp
10:58:27 <lambdabot> No matches found
10:58:28 <nmessenger> eh?
10:58:31 <nmessenger> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
10:58:33 <lambdabot> http://tinyurl.com/2z87jz
10:58:37 <nmessenger> I see no IO.
10:58:43 <bos> you could also just use Text.Regex.Posix directly, and =~ and friends
10:58:53 <bos> nmessenger: depends on the interface you use.
10:58:57 <fons> I don't understand why match a regular expression can cause side effects
10:58:59 <bos> =~ is pure.
10:59:00 <shapr> bos: Hey, I saw your name on LWN.net in the kernel contributors. Or is there another person with your name?
10:59:15 <fons> good, thanks you then
10:59:42 <bos> shapr: no, that's me.
11:00:44 <shapr> bos: That's way cool :-)
11:00:50 <bos> shapr: :-)
11:02:08 <fons> bos, the interface is not really intuitive, that's why I asked for a tutorial :S
11:02:41 <bos> fons: it's easy enough to use, just the haddock is hard to read because of the lengths of the type names involved.
11:03:06 <fons> ok, Text.Regex seems easy enough to use
11:04:05 <fons> matchRegex must be what I want
11:04:25 <bos> fons: "foo" =~ "bar"
11:04:41 <nmessenger> @index (=~)
11:04:41 <lambdabot> bzzt
11:04:49 <bos> the thing that's a bit confusing is that it's polymorphic in the return type.
11:05:03 <Lemmih> dons: Why are people mailing me with hs-plugins bug reports? (:
11:05:36 <bos> so you can get it to return Bool (did this match?), String (where did this match?), etc
11:05:51 <fons> were foo is the regular expression?
11:06:03 <SyntaxNinja> can anyone clean out the spam on the SoC wiki?
11:06:13 <nmessenger> bos: so String is in the RegexMaker class?
11:06:27 <bos> nmessenger: yeys
11:06:46 <bos> fons: the regex is on the RHS
11:06:55 <bos> just as if it was perl, only different
11:06:58 <bos> :-)
11:07:06 <nmessenger> much magic
11:07:28 * wkh has a job interview tomorrow in the hopes of getting paid to hack VB and C++
11:07:30 <bos> so: "foobar" =~ "foo" :: String ==> "foo"
11:07:35 <wkh> better than Starbucks.
11:07:50 <bos> but "foobar" =~ "foo" :: Bool ==> True
11:08:53 <quicksilver> I dunno, getting paid to hack starbucks could be fun
11:09:00 <quicksilver> as long as they give you a big enough axe
11:09:36 <bos> btw, the built-in regex support in base haskell is very slow.
11:09:43 <bos> it's slower than a truly slow thing.
11:09:57 <bos> it's also stricter than it ought to be.
11:11:09 <bos> @hoogle regex-tdfa
11:11:10 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-tdfa'
11:11:20 <bos> @where regex-tdfa
11:11:20 <lambdabot> I know nothing about regex-tdfa.
11:11:23 <bos> eek
11:11:48 <nmessenger> @google regex-tdfa haskell
11:11:48 <bos> @where+ regex-tdfa http://darcs.haskell.org/packages/regex-tdfa/
11:11:49 <lambdabot> Done.
11:11:52 <lambdabot> http://lambda-the-ultimate.org/node/2064
11:11:52 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast | Lambda the Ultimate
11:12:03 <fons> bos: well, the problem with the haddock documentation are not only the polymorphic types ... for instance ~= is not documented at all, there's not comment saying what it does for the newcomer
11:12:19 <bos> yeah, the haddocks are often cryptic, crap, or both.
11:13:34 <bos> fons: i'll write up a regexp tutorial later today, then :-)
11:14:58 <quicksilver> It's not 100% clear to me that using multiparameter typeclasses like that simply to acheive perl-style overloading is A Good Thing
11:15:16 <quicksilver> but I could be being a fuddy duddy, or there could be other reasons to do that too
11:15:48 <nmessenger> heh, from the Text.Regex.Posix.Wrap haddock: "2^63 should be enough bytes for anyone"
11:17:23 <Philippa> quicksilver: it's not 100% clear to me that perl-style overloading is A Good Thing...
11:17:30 <fons> bos, are you serious? that would be awesome! the wikibook would be the perfect place where to put it
11:17:40 <quicksilver> Philippa: right, that was part of what I was getting at :)
11:17:43 <yuten> hello, is anyone use vim for writting haskell code?
11:18:57 <bos> fons: yeah, it won't take long.
11:19:09 <paolino> @hoogle ([a] -> [[a]])
11:19:10 <lambdabot> List.inits :: [a] -> [[a]]
11:19:11 <lambdabot> List.tails :: [a] -> [[a]]
11:19:11 <lambdabot> List.group :: Eq a => [a] -> [[a]]
11:19:19 <fons> actually the wikibook is the only well writen friendly Haskell book which covers the new "de facto standard" features
11:19:30 <paolino> :t groupBy
11:19:32 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
11:20:22 <paolino> mmhh, is there a function to split a string at a character ?
11:20:43 <nmessenger> > break ' ' "blah barf"
11:20:44 <lambdabot>  Couldn't match expected type `a -> Bool'
11:20:52 <nmessenger> > break (==' ') "blah barf"
11:20:53 <lambdabot>  ("blah"," barf")
11:20:56 <fons> In fact I'm really looking forward to see a Haskell cookbook, covering the awkward squad and practical matters
11:20:57 <tibbe> > foldr (+) 0 (take 5 [1..])
11:20:59 <lambdabot>  15
11:21:03 <tibbe> > foldl (+) 0 (take 5 [1..])
11:21:05 <lambdabot>  15
11:21:10 <paolino> :)
11:21:41 <nmessenger> > takeWhile (not . null) . unfoldr (Just . break (==' ')) $ "blah barf puke"
11:21:43 <lambdabot>  ["blah"]
11:21:56 <fons> Having to read papers and so different pointers is not really friendly for the newcomer
11:22:05 <nmessenger> > takeWhile (not . null) . unfoldr (Just . second (drop 1) . break (==' ')) $ "blah barf puke"
11:22:07 <lambdabot>  ["blah","barf","puke"]
11:22:34 <nmessenger> > unwords "blah barf puke" -- :)
11:22:36 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
11:22:50 <nmessenger> > words "blah barf puke" -- oops
11:22:52 <lambdabot>  ["blah","barf","puke"]
11:23:11 <nmessenger> > takeWhile (not . null) . unfoldr (Just . second (drop 1) . break (=='a')) $ "blah barf puke"
11:23:12 <lambdabot>  ["bl","h b","rf puke"]
11:26:47 * paolino is unfoldr scared
11:26:50 * nmessenger writes unfoldrUntilNull f = takeWhile (not . null) . unfoldr (Just . f)
11:27:19 <bos> practical programming in haskell is very easy. it's just not well documented in one place.
11:27:31 <shapr> bos: How do we fix that?
11:27:52 <bos> shapr: someone with motivation and knowledge writes a book :-)
11:28:30 <shapr> What should be in that book?
11:29:26 <bos> introduction to the language *for people who can already program*. there are plenty of cs 101 books.
11:29:51 <Vq^> bos: isn't the gentle introduction for them? :)
11:30:16 <bos> introduce I/O early. walk through monads via the maybe and state monads. build a new monad using the maybe and state monads. introduce monad transformers by pulling the maybestate monad apart.
11:30:17 <Vq^> not that practical maybe...
11:30:53 <Vq^> bos: what about Hitchhikers guide to Haskell?
11:30:54 <bos> add network programming. how to do xmlrpc. json. xml processing.
11:31:06 <fons> shapr, Monads, FFI, existentials, and practical examples of any module (or at least the most important ones) which is not properly documented in the haddock documentation
11:31:16 <bos> discuss the ffi. show how to use it.
11:31:23 <shapr> Sounds pretty good.
11:31:31 <siti> use malloc in haskell ;)
11:31:50 <bos> develop new apps along the way: a barcode recogniser. use the ffi to plug it into a firewire camera. add database support. hey look, we built delicious library in haskell!
11:32:06 <tibbe> how to extract xml into a structure is what I need
11:32:18 <tibbe> highly untrivial for me
11:32:22 <tibbe> in haskell
11:32:30 <bos> so i have a book outline in my head, but an incomplete book i need to finish first.
11:32:30 <fons> and among all, introduces Monads properly, make clear they are not only used to deal with side effects in Haskell
11:32:35 <fons> entroduce*
11:32:45 <fons> bloody keyboard, introduce*
11:33:26 <bos> also cover a teeny weeny bit of category theory, so that things like monoids and functors make some kind of sense.
11:33:46 <siti> learn colemak :p
11:33:47 <bos> keep the whole thing fairly concrete.
11:34:41 <fons> shapr, a good goal for the writer could be "Make sure that once the reader goes through the book, he or she will be ready to understand most of the code written by the Haskell community and be able to extend it"
11:35:03 <shapr> fons: We'd have to add some interesting appendices.
11:35:14 <shapr> Appendix A: Notes on Oleg code.
11:35:20 <alexj> bos: just read the regex link you posted.  Is Text.Regex bad?
11:35:20 <Vq^> heh
11:35:22 <fons> The way in which haskell is introduced in College courses is way to different from how it is used in practice
11:35:24 <shapr> Appendix B: How to comport yourself on #haskell
11:35:27 <Cale> > (-2147483648::Int) `div` (-1::Int)
11:35:29 <siti> is someone writing a book or thinking about it?
11:35:29 <lambdabot> Terminated
11:35:37 <bos> alexj: it's slow. otherwise ok.
11:35:38 <Saizan> tibbe: with HXT is not so hard if you know how to use arrows
11:35:43 <fons> shapr, I wrote most :P
11:35:48 <shapr> :-)
11:36:04 <bos> dons mentioned that someone is allegedly writing a book, but i've never heard who, what, or when.
11:36:16 <siti> everyone that is taught it in uni, thinks you can't make real apps in it :(
11:36:28 <shapr> I know that CosmicRay has Haskell V8, but that hasn't really gone anywhere lately.
11:36:35 <siti> well not everyone, but many people
11:36:37 <tibbe> Saizan, I'm using HXT
11:36:37 <shapr> siti: Yeah, I met a bunch of people like that in north Sweden.
11:36:40 <fons> the most complete and friendly Haskell book I know about is Thomsons book, which doesn't say much
11:36:52 <siti> I met a german that thought the same
11:37:10 <siti> and all the people at my uni as well pretty much
11:37:14 <tibbe> Saizan, but the order of the elements is not known and some are optional and can appear nested in unrelated elements (like in HTML)
11:37:18 <shapr> The Swedes thought that both Lisp and Haskell were about taking the head of the head of the ...
11:37:44 * shapr waits for HAppS to rebuild...
11:38:09 <fons> shapr, there are some swedes which don't :P There's lots of good Haskell work being done at Chalmers
11:38:10 <Saizan> tibbe: ah, so deep won't work eh?
11:38:11 <siti> I don't know what you mean
11:38:25 <fons> shapr, I'll probably get a Phd position there
11:38:36 <fons> (hopefully)
11:38:46 <shapr> Yeah, I've spent some time it Chalmers, it's a great place.
11:39:01 <paolino> CSV format is escaping ',' in any way ?
11:39:14 <tibbe> Saizan, I'm not sure, if I can get a list of Maybe String back where the order of the values has a known correspondens to the tags, I guess I could tag them with something
11:39:45 <tibbe> it feels like much work though
11:40:32 <pejo> fons, any idea how many applicants/positions chalmers has?
11:40:44 <fons> pejo, let me show you the link
11:40:44 <shapr> I think it's about 25 applications per position.
11:40:56 <shapr> Or more
11:41:08 <shapr> If you mean the FP part of Chalmers.
11:41:14 <tibbe> shapr, is it important to have publish many papers?
11:41:22 <shapr> Don't know that.
11:41:31 <fons> http://chalmersnyheter.chalmers.se/chalmers03/english/eng_vacanciesarticle.jsp?article=8730
11:41:34 <lambdabot> http://tinyurl.com/2u2lwh
11:42:01 <fons> tibbe, what for?
11:42:11 <mahogny> getting a position at chalmers in FP is difficult. prepare a huge recommendation list :o
11:42:28 <pejo> fons, doens't say how many positions though, does it?
11:42:53 <tibbe> fons, for the phd position
11:43:28 <shapr> If I ever go for a PhD, I'll try hard to get into Chalmers.
11:44:07 <metaperl> @seen glguy
11:44:08 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 38m 57s ago.
11:44:10 <nmessenger> @pl \(x:xs) -> (x,xs)
11:44:11 <lambdabot> liftM2 (,) head tail
11:44:11 <fons> tibbe, well, probably that's the best recommendation letter you can have, but I don't think that's a must. They are accepting undergraduate students, and having published papers is not a common thing
11:44:15 <ray> if i do args <- getArgs, what's the first element of args?
11:44:19 <tibbe> I wonder if it helps having your MS from chalmers
11:44:39 <pejo> tibbe, it helps to know people. :-)
11:44:42 <shapr> Jah trÃ¤ffade en Alabamsk kvinna som talar Svenska i apoteket! Jar var sÃ¥ fÃ¶rvÃ¥nade!
11:44:45 <tibbe> I know some of CS staff quite well
11:44:46 <shapr> Jag*
11:45:01 <tibbe> as I've done teaching assistance
11:45:08 <tibbe> shapr, !!
11:45:27 <siti> @type getArgs
11:45:30 <lambdabot> Not in scope: `getArgs'
11:45:34 <nmessenger> ray: run your program with "yourprog foo bar" and args will = ["foo","bar"]
11:45:37 <shapr> Yeh, the people around us looked confused when we broke out into Swedish in this tiny little town outside of Birmingham.
11:45:42 <siti> @hoogle getArgs
11:45:42 <lambdabot> System.getArgs :: IO [String]
11:45:46 <ray> ah, thanks
11:45:55 <ray> so how do i get the executable name then
11:46:01 <siti> umm
11:46:06 <nmessenger> @type getProgramName
11:46:09 <lambdabot> Not in scope: `getProgramName'
11:46:12 <siti> withProgName
11:46:18 <siti> @hoogle withProgName
11:46:18 <lambdabot> System.Environment.withProgName :: String -> IO a -> IO a
11:46:20 <nmessenger> @type getProgName
11:46:22 <lambdabot> Not in scope: `getProgName'
11:46:26 <siti> or
11:46:29 <siti> @hoogle getProgName
11:46:30 <lambdabot> System.getProgName :: IO String
11:46:35 <ray> ah, merci!
11:47:37 <shapr> hiya stepcut!
11:47:43 <stepcut> hiya shapr!
11:47:43 <lambdabot> stepcut: You have 1 new message. '/msg lambdabot @messages' to read it.
11:47:49 <shapr> stepcut: How's code?
11:47:52 <stepcut> good!
11:48:54 <metaperl> @seen glguy
11:48:55 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 43m 44s ago.
11:49:00 <stepcut> I want to move a directory out of the way by renaming it. So, I am trying to figure out the best way to generate the new name
11:50:21 <stepcut> mkstemp is close, but it creates a file and returns the filehandle, which is not quite what I want
11:51:26 <hpaste>  Gwern annotated "A CLI tool to generate possible capitalizations of a name" with "Fix module business" at http://hpaste.org/668#a1
11:51:44 <Gwern> I have an evaluation question with regard to the previous question
11:52:04 <Gwern> what it does is generate all permutations and then filters out the ones it doesn't want
11:52:22 <Gwern> so how can it run *faster* than the full permutations?
11:52:30 <Gwern> doesn't every value need to be generated and tested?
11:54:13 <stepcut> how do you know it is faster ?
11:54:14 <emu> > negate (maxBounds :: Int) `div` (-1 :: Int)
11:54:14 <lambdabot>   Not in scope: `maxBounds'
11:54:20 <emu> > negate (maxBound :: Int) `div` (-1 :: Int)
11:54:22 <lambdabot>  2147483647
11:54:41 <emu> > negate (maxBound :: Int) - 1 `div` (-1 :: Int)
11:54:43 <lambdabot>  -2147483646
11:54:56 <emu> > (-2147483648::Int) `div` (-1::Int)
11:54:57 <pejo> stepcut, mktemp() returns a char*. But that opens up for race conditions.
11:54:57 <lambdabot> Terminated
11:55:04 <emu> nice
11:55:07 <nmessenger> you're filtering by (map tail . words $ line)?  So you're only permute the word-first case?
11:55:30 <pejo> stepcut, or tmpnam/tempnam.
11:56:11 <Gwern> nmessenger: the idea behind the map tail is so we can match against their internals and only let through variations on the first letter, yes
11:56:33 <apfelmus> why is it called "permute"? there's nothing permuted here, isn't it?
11:56:38 <Gwern> (if I know haskell, there's probably a better way)
11:56:46 <stepcut> pejo: ok, it looks like I will have to write some bindings, thanks
11:56:52 <Gwern> apfelmus: it's permuting by capitalization
11:57:01 <emu> > filterM (const [True,False]) [1,2,3,4]
11:57:03 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
11:57:33 <Botje> wth?
11:57:36 <Botje> ?src filterM
11:57:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:57:37 <apfelmus> ?? for me, "to permute" = "to reorder". but you don't change the order of characters?
11:57:58 <stepcut> "The  tmpnam()  function  returns  a pointer to a string that is a valid filename, and such that a file with this name did not exist at some point in time, so that naive programmers may think it a suitable name for a temporary file."
11:58:05 <Gwern> apfelmus: fine, fine. what would you call generating the set of all possible unique capitalizations of a string?
11:58:25 <Gwern> (I couldn't think of anything better than 'permute', and it's relatively short and easy to spell)
11:58:33 <apfelmus> possibleCaps ?
11:58:58 <Gwern> apfelmus: too long
11:59:18 <apfelmus> > length "permuteStrings" > length "possibleCaps"
11:59:20 <lambdabot>  True
11:59:22 <apfelmus> :)
11:59:25 <nmessenger> it seems you're generating *all* strings with flIpPEdcApS and filtering out those that cap non-initial letters, right?
11:59:31 * Gwern is betrayed by lambdabot!
11:59:40 <alexj> is there a convention for when {-#OPTIONS .... #-} is used and when it isn't?
11:59:46 <Gwern> nmessenger: I think so
12:00:07 <alexj> it seems like something that should be required inside the modules that need it.
12:00:20 <nmessenger> It would seem to be better to split into words, map each word to a ["word","Word"] pair, and then sequence.
12:00:32 <alexj> having it passed on the command line or in cabal files adds confusion because you can't tell by the file itself what is going on.
12:00:44 <glguy> metaperl: hi
12:00:49 <Gwern> nmessenger: Hmm. sequence?
12:00:54 <nmessenger> @src mapM
12:00:55 <lambdabot> mapM f as = sequence (map f as)
12:00:59 <metaperl> glguy - hi, I was wondering my hpaste has the same type signature as fmap
12:01:02 <metaperl> @type fmap
12:01:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:01:13 <metaperl> s/my/why
12:01:21 <metaperl> hpaste :: (a -> b) -> f a -> f b
12:01:37 <nmessenger> Gwern: that mapM function call you have is just "map to ["word","Word","wOrd"...], then sequence"
12:01:59 <Gwern> nmessenger: that might be a good idea, but if I'm understanding you, I would no longer have any way of generating all caps, although I'd still have the subset, right?
12:02:01 <apfelmus> metaperl: hpaste is not only functional, it's functorial
12:02:15 <metaperl> that comment is lost on me apfelmus
12:02:22 <glguy> metaperl: dons did that when he created the header graphic
12:02:27 <allbery_b> hm.  any chance lambdabot can be convinced to join irc.perl.org:#haskell?
12:02:32 <glguy> metaperl: I don't know if there is any special reason
12:02:45 <metaperl> i see
12:02:47 <glguy> metaperl: you could say that hpaste is a container for pastes...
12:02:51 <nmessenger> Gwern: if I understand, all the caps would have to be generated in order to test if they should be filtered out, so it should be better.
12:03:00 <metaperl> glguy - i like that interpretation!
12:03:10 <Gwern> nmessenger: well, speed isn't the point of this app.
12:03:25 <Gwern> I intend to use it as the guts of a Wikipedia bot, so actually speed is not very helpful
12:03:43 <pejo> stepcut, that is a good description. There was a reason mkstemp was invented. :-)
12:04:07 <Gwern> what's more helpful is flexibility - I plan to start with just generateCaps, but in the longrun I hope to be able to switch to using permuteStrings
12:05:05 <Gwern> so my current scheme of filtering to achieve 'specialization', as it were, is better in the longrun for me.
12:05:18 <Gwern> still don't understand the speed issues, but tI guess that's lazy evauation for you
12:05:21 <apfelmus> i'm quite puzlled. why do you create all capitalizations, like "fOo" and so on? don't you just want those that capitalize the first letter, like "Foo" and "foo"?
12:05:54 <nmessenger> 14:51 <Gwern> so how can it run *faster* than the full permutations?
12:05:54 <nmessenger> 14:52 <Gwern> doesn't every value need to be generated and tested?
12:06:01 <Gwern> apfelmus: see previous posts
12:06:28 <oklopol> www.google.com
12:06:33 <apfelmus> you mean you want to be able to switch to that later?
12:06:44 <Gwern> nmessenger: my reasoning is that generating all caps and then throwing away the unwanted ones should be slower than just generating all caps, but in fact it seems to be the opposite, which rather puzzles me
12:06:54 <nmessenger> apfelmus: in this case, he doesn't, but he wants to use permuteCaps elsewhere.
12:07:38 <apfelmus> ah.
12:08:06 <apfelmus> but you know that generating all possible capitalizations is exponential
12:08:08 <nmessenger> Gwern: if you want to go faster, don't generate all the permutations.  If you don't care, then this is fine.
12:08:59 <nmessenger> the filtering equality test is what forces the evaluation of all the unused permutations, if I understand correctly.
12:09:16 <apfelmus> > length $ mapM_ (\x -> [toUpper x, toLower x]) "this is a rather long string"
12:09:19 <Gwern> apfelmus: yeah, which is why I'm testing some longer strings to see whether I am imagining it or not
12:09:20 <lambdabot> Terminated
12:09:33 <nmessenger> apfelmus: words
12:09:53 <nmessenger> oh, you wanted to demonstrate the exponential behavior
12:10:11 <apfelmus> indeed.
12:10:14 <nmessenger> > length $ mapM_ (\x -> [toUpper x, toLower x]) "even short"
12:10:16 <lambdabot>  1024
12:10:29 <nmessenger> > length $ mapM_ (\x -> [toUpper x, toLower x]) "even short1"
12:10:31 <lambdabot>  2048
12:10:35 <nmessenger> > length $ mapM_ (\x -> [toUpper x, toLower x]) "even short12"
12:10:36 <lambdabot>  4096
12:10:46 <nmessenger> bad.
12:10:57 <Gwern> it's just 2^numer of alphabetic characters, isn't it?
12:11:09 <apfelmus> "just" is an euphemism
12:11:16 <nmessenger> *just* 2^?!!
12:11:22 <allbery_b> @ask dons can you have lambdabot join irc.perl.org:#haskell?
12:11:23 <apfelmus> > 2^100
12:11:23 <lambdabot> Consider it noted.
12:11:24 <lambdabot>  1267650600228229401496703205376
12:12:06 <apfelmus> > 2^100 / (60*60 * 24 * 1000 * 365)
12:12:07 <nmessenger> > length . map unwords . mapM_ (\x -> [toUpper x, toLower x]) $ words "this is a rather long string"
12:12:08 <lambdabot>  Couldn't match expected type `[String]' against inferred type `()'
12:12:08 <lambdabot>  4.0196936841331474e19
12:12:11 <Gwern> nmessenger: sure. we could be in a crazy alphabetical system where case varies by gender as well, so it could be 4^num :)
12:12:33 <nmessenger> > map unwords . mapM_ (\x -> [toUpper x, toLower x]) $ words "this is a rather long string"
12:12:35 <lambdabot>  Couldn't match expected type `[String]' against inferred type `()'
12:12:47 <apfelmus> ?type toUpper
12:12:50 <lambdabot> Char -> Char
12:13:03 <jyasskin> > map unwords . mapM (\x -> [toUpper x, toLower x]) $ words "this is a rather long string"
12:13:13 <nmessenger> > map unwords . mapM (\(x:xs) -> [toUpper x : xs, toLower x : xs]) . words $ "this is a rather long string"
12:13:43 <nmessenger> > map unwords . Control.Monad.mapM (\(x:xs) -> [toUpper x : xs, toLower x : xs]) . words $ "this is a rather long string"
12:13:45 <lambdabot>  ["This Is A Rather Long String","This Is A Rather Long string","This Is A Ra...
12:14:07 <nmessenger> > length . map unwords . Control.Monad.mapM (\(x:xs) -> [toUpper x : xs, toLower x : xs]) . words $ "this is a rather long string"
12:14:09 <lambdabot>  64
12:14:15 <apfelmus> Gwern: a string of 100 characters will take 4.0196936841331474e19 years if you generate a capitalization per millisecond
12:14:26 <nmessenger> that's only exponential in the number of words, not characters.
12:14:46 <apfelmus> yeah, firsts words then capitalize
12:15:14 <apfelmus> *first
12:15:37 <Gwern> apfelmus: for which kind of caps, all variants or just by word?
12:15:56 <apfelmus> Gwern: the 4e19 years are for all caps, of course
12:16:00 <Gwern> wait, that's a stupid question anyway
12:16:06 <Gwern> the number of spaces wasn't specified
12:16:27 <nmessenger> oh, I forgot about spaces-preserving
12:17:04 <nmessenger> perhaps an alternative words that keeps following whitespace at the end of end word
12:17:11 <nmessenger> then concat
12:17:35 <nmessenger> s/end of end/end of each/
12:18:17 <beelsebob_> @poll-result mini-hat-name
12:18:18 <lambdabot> Poll results for mini-hat-name (Open): tiara=1, wig=1, shat=0, trilby=1, bowler=0, top=0, toupe=1, badger=0, cap=3, pimp=0
12:18:34 <nmessenger> "shat"?
12:18:44 <nmessenger> "pimp"?!
12:18:47 <beelsebob_> that was Philipa's suggestion
12:18:49 <beelsebob_> small hat
12:18:55 <beelsebob_> pimp because it manipulates the tart
12:19:00 <beelsebob_> (theoretical ART)
12:21:02 <Philippa> I should point out that my suggestion was... not entirely serious :-)
12:22:02 <allbery_b> @choice-add mini-hat-name kippah
12:22:02 <lambdabot> New candidate "kippah", added to poll "mini-hat-name".
12:22:16 <wkh> mini-hat-name? what the fuck is that?
12:22:17 <allbery_b> @vote mini-hat-name kippah
12:22:17 <lambdabot> voted on "kippah"
12:22:21 <allbery_b> :)
12:24:54 <beelsebob_> why kippah?
12:25:17 <fax> hi
12:25:23 <shapr> @vote mini-hat-name cap
12:25:23 <lambdabot> voted on "cap"
12:25:52 <Gwern> what, no fedora?
12:26:00 <nmessenger> is it mini?
12:26:25 <fax> what is GHC written in?
12:26:26 <Gwern> it could be
12:26:32 <nmessenger> fax: GHC
12:26:35 <beelsebob_> fax: Haskell
12:26:39 <fax> *phew*
12:26:41 <fax> ok thanks :D
12:26:44 <beelsebob_> nmessenger: it's 6 files :P
12:27:15 * wkh thinks the time it takes for a language to compile itself is a pretty informative metric
12:27:42 <fax> so they write a simple haskell interpreter in some pre-existing language, then write the compiler and use the interpreter to compile itself
12:27:48 <fax> is that approximatly right?
12:27:51 <int-e> wkh: so languages with a stupid but fast compiler will win?
12:28:13 <beelsebob_> fax: ghc 4 or before can be had in a C version
12:28:22 <shapr> What about something like Forth that compiles itself at runtime of the program?
12:28:24 <beelsebob_> the C version is used to compile GHC 5
12:28:29 <beelsebob_> which is used to compile 6
12:28:34 <beelsebob_> which is used to compile 6.6
12:28:39 <fax> ohh
12:28:42 <fax> hm
12:28:43 <beelsebob_> which is used to compile 6.6 again (to optimise it)
12:28:53 <beelsebob_> which is used to compile 6.6 (to check it produces the same thing)
12:29:04 <wkh> and then boobs
12:29:10 <int-e> and on the 7th day, we rest *g*
12:29:11 <nmessenger> which is used to compile 6.6 (just to be sure :D)
12:29:34 <fax> lol
12:29:34 <shapr> And then you get to make ghci
12:29:40 <beelsebob_> int-e: lol
12:29:46 <beelsebob_> rofl
12:29:55 <wkh> omg computers
12:29:56 <Igloo> GHC has been self-hosting since before GHC 5
12:30:15 <Igloo> I believe hbc was used to compile the first self-hosting GHC
12:30:37 <shapr> Wow, that's neat. I didn't know that.
12:31:16 <nmessenger> couldn't one use a GHC binary to translate 6.6 to C, then move the source to the unsupported platform?
12:31:26 <fax> so it compiles to machine code for the computer you are on?
12:31:45 <beelsebob_> Igloo: I was refering to a modern process - in that you need to use 4 because it's the last version that doesn't need you to already have a Haskell compiler
12:31:45 <shapr> nmessenger: Yup, that's how unregistered builds are made.
12:31:48 <beelsebob_> or am I mistaken?
12:31:51 <Igloo> nmessenger: It's a little more complicated than that, but that's roughly how ports to new machines are done
12:32:26 <Igloo> beelsebob_: I don't think GHC 5 is any better than 6.6 for that
12:32:33 <beelsebob_> kk
12:33:07 <Igloo> Err, or 4, whichever it was you said
12:33:24 <fax> abny ideas why GHC chose to write in C first of all, because there was already haskell interpreters wasnt there?
12:33:55 <shapr> Was GHC ever written in C?
12:34:14 * shapr is confused
12:34:27 <nmessenger> chessguy: any luck with the devil paste?
12:34:29 <chessguy> hi haskellers
12:34:47 <chessguy> nmessenger, i can't really do much with it until i get home
12:35:29 * edwinb wonders what it was written in first. C would surprise me...
12:36:02 <wkh> wikipedia says it was prototyped in lazy ml but that was scrapped
12:36:04 <shapr> fax: I don't understand your question.
12:36:16 <mbishop> it was written in lisp!
12:36:23 <DynWind> "in the autumn of 1989, ... a complete implementation of Haskell in Haskell ... [the parser was written in Yacc and C"
12:36:44 <wkh> on a lisp machine. at MIT. in 2 days.
12:37:14 <nmessenger> ... with their hands tied behind their backs, in the snow, 15 miles uphill both ways
12:37:24 * shapr throws lambdas
12:37:32 * nmessenger is thrown
12:37:40 <wkh> blindfolded. and actually they wrote most of it in an afternoon, the rest of the time was adding helpful error messages and libraries for IDIOT LUSERS
12:37:44 <mbishop> ?
12:37:45 <nmessenger> AHH!
12:37:49 * edwinb tries to catch one but gets the pointy end
12:37:52 <edwinb> yowch
12:38:36 * xerox hands edwinb a monadfix
12:38:49 <mbishop> lambda fight! ????
12:38:51 <edwinb> ah, first aid, thanks
12:39:03 <xerox> np
12:40:10 <nmessenger> @quote lambda
12:40:11 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
12:40:26 <nmessenger> haha
12:41:52 <chessguy> edwinb, that's first _order_ aid
12:42:17 <nmessenger> @type mfix
12:42:20 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
12:42:24 <nmessenger> looks second order to me
12:42:36 <beelsebob_> edwinb: sorry, looks like cap won
12:44:20 <chessguy> first order with respect to monads...dunno, i'm just making stuff up now
12:45:16 <nmessenger> @quote 6969489898577
12:45:17 <lambdabot> Cale says: [Cale] > map (chr . fromIntegral) . unfoldr (\x -> guard (x > 0) >> return  (x `mod` 256, x `div` 256)) $ 152110696948989857750358645756541560135 [lambdabot]  "Get a calculator"
12:46:59 <nmessenger> > foldr (\u t -> t*256+u) . map ord $ "Get a calculator"
12:47:00 <lambdabot>   add an instance declaration for (Num [Int])
12:47:01 <lambdabot>     In the expression: (t * 256...
12:47:02 <Saizan> nmessenger: do you remember that portion of the number?
12:47:14 <nmessenger> nah, copy/pasted from /msg
12:47:50 <nornagon> @index unfoldr
12:47:51 <lambdabot> Data.List
12:48:03 <nornagon> @index guard
12:48:04 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:48:04 <chessguy> @quote et.a.calculator
12:48:05 <lambdabot> Cale says: [Cale] > map (chr . fromIntegral) . unfoldr (\x -> guard (x > 0) >> return  (x `mod` 256, x `div` 256)) $ 152110696948989857750358645756541560135 [lambdabot]  "Get a calculator"
12:48:12 <chessguy> most people would['ve just done that ;)
12:48:30 * nmessenger is not most people
12:48:43 <chessguy> :)
12:48:45 <nornagon> >  map (chr . fromIntegral) . unfoldr (\x -> guard (x > 0) >> return  (x `mod` 256, x `div` 256)) $ 152110696948989857750358645756541560135
12:48:47 <lambdabot>  "Get a calculator"
12:49:23 <int-e> hmm. > echo 152110696948989857750358645756541560135P | dc --> rotaluclac a teG
12:50:29 * nmessenger likes "rotaluclac" as a nick
12:50:55 <Saizan> =type unfoldr
12:50:59 <Saizan> ?type unfoldr
12:51:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:51:47 <nmessenger> > unfoldr (let f [] = Nothing; f (x:xs) = Just (succ x,xs)) "blah"
12:51:47 <lambdabot>  Parse error
12:51:51 <nmessenger> > unfoldr (let f [] = Nothing; f (x:xs) = Just (succ x,xs) in f) "blah"
12:51:53 <lambdabot>  "cmbi"
12:52:27 <nmessenger> > unfoldr (let f [] = Nothing; f (x:xs) = Just (replicate 5 x,xs) in f) "blah"
12:52:29 <lambdabot>  ["bbbbb","lllll","aaaaa","hhhhh"]
12:52:59 <nmessenger> ... though that's just map
12:53:32 <nornagon> > map (replicate 5) "blah"
12:53:34 <lambdabot>  ["bbbbb","lllll","aaaaa","hhhhh"]
12:54:50 <nmessenger> > let justSplit _ [] = Nothing; justSplit n xs = splitAt n xs in  unfoldr (justSplit 3) "jackdaws love 'em"
12:54:51 <lambdabot>  Couldn't match expected type `Maybe a'
12:54:55 <apfelmus> > unfoldr (\x -> if x == 0 then Nothing else Just (if even x then 0 else 1, x `div` 2)) 255
12:54:57 <lambdabot>  [1,1,1,1,1,1,1,1]
12:55:10 <nmessenger> > let justSplit _ [] = Nothing; justSplit n xs = Just(splitAt n xs) in  unfoldr (justSplit 3) "jackdaws love 'em"
12:55:12 <lambdabot>  ["jac","kda","ws ","lov","e '","em"]
12:56:00 <apfelmus> i don't get regular expressions. i mean why i would need them in haskell at all
12:56:19 <chessguy> same reason you would need them in any other language?
12:56:34 <wkh> how would you, e.g., extract phone numbers from a large collection of text files without regexes?
12:56:58 <kc5tja> Compile them into a parser, then pass the text to the parser for processing.
12:57:06 <kc5tja> Like how Python does it.
12:57:09 * kc5tja runs!
12:57:33 <apfelmus> i'd build a quick parsec to parse the file
12:59:11 <dylan> a regexp library is useful for an application that has a search interface.
12:59:37 <dylan> e.g. so I, the user, may type /<regexp gibberish> to find something.
12:59:50 <Saizan> well if your grammar is simple enough a regular expression can execute faster
13:00:01 <dylan> but programming with regexps seems a little bit not-useful in haskell.
13:00:08 <wkh> regexes are kind of unsustainable when it gets complicated
13:00:16 <wkh> e.g., aaron swartz's implementation of markdown in python
13:00:39 <apfelmus> dylan: the interface is a good point. indeed, regexes are mostly useful for users, not for programmers
13:01:19 <Cale> There's almost no point to regexes when you have things like parsec
13:01:41 <apfelmus> yeah, that's what i'm thinking, too
13:01:48 <Philippa> I'm not sure I'd go quite that far with current implementations
13:01:55 <dylan> hmm, I should implement that postfix stack-based language that is in the back of my head.
13:02:06 <Philippa> but certainly the eventual ideal'll look a lot more like parsec than like regexes
13:02:09 <dylan> err
13:02:15 <dylan> prefix, prefix stack language.
13:03:57 <apfelmus> Philippa: you're alluding to the fact that parsec has it's quirks?
13:04:41 <Philippa> apfelmus: to the fact that it's possible to produce faster parsers
13:05:06 <Philippa> parsec's certainly not ideal in terms of its ability to self-analyse - that's the cost of having higher-order parsers
13:05:22 <apfelmus> yeah. parsec parses context-sensitive languages
13:05:54 <apfelmus> also, ReadP has a symmetric choice
13:05:55 <Philippa> more specific than that
13:06:14 <Philippa> you can have a parsing arrow that's ArrowChoice but not ArrowApply, for example
13:06:27 <Philippa> so you can make context-sensitive decisions but not build new parsers based on the context
13:07:31 <apfelmus> doesn't a missing ArrowApply disallow context-sensitive languages and restrict you to context-free ones?
13:07:42 <Philippa> no
13:07:53 <apfelmus> interesting. example?
13:08:03 <Philippa> ArrowChoice != ArrowPlus, basically
13:08:25 <Philippa> you can encode things like a layout rule with ArrowChoice
13:08:47 <Philippa> because you can make decisions based on indentation level (which comes from the context)
13:09:29 <apfelmus> and you're sure that you cannot encode this in a context-free way?
13:09:33 <wkh> what should i read about if i want to ues Haskell to create embedded domain-specific languages?
13:09:54 <Cale> wkh: How familiar are you with monads?
13:10:09 <Cale> Actually, regardless, check out Parsec
13:10:29 <Cale> The documentation for Parsec is fairly tutorial in nature, and it's a good example of what can be done.
13:10:38 <wkh> i spent all weekend reading about them. i can follow the tutorials out there, but i think id' have a hard time explaining it to someone else (e.g., myself a week ago), so I don't think i really understand.
13:10:59 <wkh> sweet.
13:11:01 <Philippa> apfelmus: not one that doesn't have a hellish AST
13:11:03 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
13:11:07 <Philippa> and then require a second pass over it
13:11:24 <Cale> (the import names have changed since it was written, but otherwise, it's up to date)
13:11:31 <Philippa> CFGs correspond to ArrowPlus, ArrowChoice is strictly stronger
13:12:02 <Philippa> you don't use Parsec for /embedded/ DSLs though, you just use combinators
13:12:22 <Cale> I'm treating Parsec as an example of an EDSL.
13:12:27 <Philippa> fair enough :-)
13:12:53 <Cale> Another good example is Haskore, which is an EDSL for expressing music.
13:13:17 <Cale> Or HXT, which is an arrow library/EDSL for manipulating XML.
13:13:39 <pxfont> is there a newer benchmark than pseudoknot for GHC?
13:14:31 <apfelmus> you also have the classical pretty printers
13:16:01 <apfelmus> Philippa: mh, i've to look this up. anyway, what would a parser be as an arrow? Stream ~> a ?
13:16:28 <apfelmus> in this case, (Stream ~>) is an applicative functor.
13:16:53 <Philippa> apfelmus: no, the stream's carried about by the ~>. The input's the context
13:17:05 <apfelmus> context?
13:18:34 <Philippa> in the sense of "context-sensitive language"
13:18:43 <Philippa> non-text input to the parser, if you prefer
13:18:52 <Philippa> but once you've fired it off, that amounts to context
13:19:22 <Philippa> if you've got ArrowPlus but not ArrowChoice you just can't make any parsing decisions based on that context - only alterations to the AST you produce afterwards
13:20:10 <Cale> wkh: Basically DSLs in Haskell are just well-designed libraries, there's very little magic you have to do.
13:20:26 <Philippa> if you don't have ArrowPlus, you can't make any decisions while parsing at all - you don't have any concept of alternative
13:21:05 <Cale> wkh: Monads/Comonads/Arrows/Applicative functors/etc. are all ways of structuring combinator libraries, so that different EDSLs can share control structures.
13:21:15 <apfelmus> Philippa: yes. you mean (a ~> b) is a thing that parses a part of a suffix given a value a that arises from parsing the prefix?
13:21:35 <pxfont> do you use (# #) and Int#   a lot?
13:21:44 <Philippa> that probably arose from parsing the prefix, yeah. It may be that the prefix was empty and it's just what you were called with
13:21:48 <Cale> pxfont: who?
13:21:57 <wkh> whta are comonads and applicative functors?
13:22:11 <pxfont> Cale, unboxed values
13:22:29 <Cale> pxfont: Who are you asking about though? I don't use them too often.
13:22:40 <nmessenger> @src Applicative
13:22:40 <lambdabot> class Functor f => Applicative f where
13:22:41 <lambdabot>     pure  :: a -> f a
13:22:41 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:22:55 <pxfont> Cale, yes I'm vague sorry
13:22:56 <nmessenger> @google cellular automata comonadic
13:22:59 <lambdabot> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
13:22:59 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
13:23:23 <Cale> wkh: there's the Applicative class, Comonads are a sort of dual to monads, and unfortunately not included in the Hierarchical libraries yet.
13:23:25 <nmessenger> wkh: an applicative functor is a functor + return and ap
13:24:16 <Cale> Applicative is somewhat more general than Monad, and emphasizes a slightly different way of using the DSL than monads usually do.
13:24:23 <wkh> and i can use this stuff to create beautiful libraries that do awesome stuff, right?
13:24:31 <wkh> in other words there is some kind of practical benefit to learning about these things
13:25:02 <apfelmus> Philippa: ok, makes sense. and the arrow choice allows choices.
13:25:10 <nmessenger> > [negate, (*3)] <*> [2,3,5] -- not sure about practicality myself :D
13:25:12 <lambdabot>  [-2,-3,-5,6,9,15]
13:25:29 <Cale> wkh: Well, they're really ideas to help you structure your code nicely, and if you pick one, then you get a library full of code automatically.
13:25:39 <Cale> (Control.Monad is the best example of this right now)
13:26:36 <Cale> If you write a monad, then you automatically get things like sequence/mapM/filterM/etc.
13:26:59 <Philippa> apfelmus: it allows choices based on context. ArrowPlus allows something that could be a notion of choice but has to be independant of the context
13:28:04 <apfelmus> yeah. according to the paper i've in front of me, Plus has been introduced to allow a notion of failure. so to allow parsers to fail.
13:28:24 <bd_> isn't that ArrowZero?
13:29:02 <Cale> Both :)
13:29:23 <apfelmus> bd_: you're right, though Zero is not enough for combining. i mean, you have only failure, not composition then.
13:29:28 <Cale> ArrowZero captures failure, and ArrowPlus lets you do something about it
13:29:35 <apfelmus> exactly
13:30:11 <fons> I have a higher order function, which gets functions working with "State s a" as input and which internally makes IO operations, The simplified interface could be  f :: (State s a -> State s b) -> StateT s IO ()
13:31:10 <fons> the only way I managed to code it is internally transforming State s a to StateT s IO a /which is quite ugly)
13:31:35 <Philippa> fons: why not State s a -> State s b -> State s (IO ()) ?
13:31:56 <fons> Philippa, I considered that as well
13:32:07 <Cale> (State s a -> State s b) -> State s (IO ())
13:32:15 <Philippa> d'oh, yes
13:32:37 <fons> but on the way to produce such I solution I gave up cause it was tricky to work with the IO and State monads at the same time
13:32:52 <ejt> hi
13:32:57 <Cale> ejt: hello
13:33:03 <fons> let me remake it
13:33:09 <ejt> does anyone here get the Journal of Functional Programming ?
13:33:57 <bos> is there a way to declare a typeclass as an instance of a more general typeclass?
13:34:09 <Cale> ejt: Which article are you looking for? Have you checked CiteSeer, it often has articles.
13:34:37 <Cale> bos: class A t => B t where ...
13:34:44 <ejt> I was just wondering about subscribing to it, and wondered if it was as good as it looks
13:34:59 <bos> i.e. given class General a, can I somehow make Specific a b an instance of General a?
13:35:01 <Cale> bos: that'll ensure that any instances of B are also instances of A
13:35:10 <Cale> oh
13:35:19 <fons> Cale, If I use the interface you proposed how should I work with the IO monad at the same time as State ? the solution I get to cannot be more ugly
13:35:28 <Cale> ejt: ah, I don't know :)
13:35:41 <Cale> ejt: (I'm not actually a subscriber)
13:36:10 <Cale> fons: you construct an IO action and return that as you would any other value.
13:36:28 <fons> eyp that's celar
13:36:30 <fons> clear
13:36:51 <bos> jfp is bought pretty much exclusively by institutional libraries.
13:36:51 <fons> the problem comes when passing the internal values of IO to different IO actions
13:36:52 <Cale> bos: instance General a => Specific a b where ... -- you might have to turn on various GHC extensions to get this to work.
13:37:04 <apfelmus> Philippa: strangely enough, applicative functors can encode choice as well.
13:37:22 <pxfont> Is there a new benchmark comparing GHC and GCC?
13:37:29 <pxfont> what can we expect since 1995?
13:37:40 <nmessenger> pxfont: there's the shootout
13:37:42 <Cale> pxfont: things are getting pretty good
13:37:46 <chessguy> ?where shootout
13:37:47 <lambdabot> http://shootout.alioth.debian.org/
13:37:52 <chessguy> pxfont, ^^
13:38:23 <Cale> Performance lately has ranged from acceptable to excellent, depending on how hard you work on it. :)
13:38:24 <chessguy> ?quote stereo
13:38:24 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:38:26 <apfelmus> Philippa: say, do you have a pointer to the parser combinators with arrows? i only have the LL(k) ones
13:38:29 <bos> Cale: yeah, i doubt it's possible.
13:38:51 <pxfont> cheers, I had already located that one, but thanks for bringing it to my attention as a good one. But it is not easy to know which program one should compare, and how they are really implemented.
13:38:56 <Cale> bos: Do you have -fallow-undecidable-instances ?
13:39:17 * shapr boings cheerfully
13:40:08 <Cale> bos: It's sort of trouble to do it regardless.
13:40:10 <pxfont> (this looks much worse than 1995 !!)
13:40:11 <metaperl> stereo? pump it up!
13:40:23 <Cale> pxfont: what does?
13:40:51 <pxfont> the shootout seems to show GHC as worse now than the 0.22 version in 1995 when compared to GCC
13:41:00 <Philippa> apfelmus: google "Swierstra and Duponcheel parser"
13:41:46 <pxfont> There should be a new pseudoknot benchmark!
13:42:02 <nmessenger> ghc/gcc = 1.4 in: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
13:42:05 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/lepfo
13:42:07 <shapr> apfelmus: Wouter Swierstra and Einar Karttunen both made implementations of the arrow parsers.
13:42:16 <pxfont> In 1995 the score was: GNU C 2.7 seconds vs. GHC 3.9 seconds
13:42:21 <pxfont> for pseudoknot program
13:42:42 <Cale> What's pseudoknot?
13:43:03 <apfelmus> shapr: yes. i mean i'm looking for a paper where the arrow interface is described
13:43:04 <pxfont> it s a molecular biology very intensive computation involving backtracking search etc
13:43:20 <pxfont> millions of floating points ops, careful test with many researchers involved
13:43:39 <pxfont> I do not trust this shootout .... OK.
13:43:59 <Cale> I don't think there's a current implementation of that, or else I'd probably have heard about someone working on it :)
13:44:41 <pxfont> Is there any chagne to GHC implementationwise since 0.22 ??
13:44:43 <shapr> apfelmus: Is it on the bibliography part of http://www.haskell.org/arrows/ ?
13:44:44 <lambdabot> Title: Arrows: A General Interface to Computation
13:44:54 <pxfont> (of significance for efficiency)
13:44:57 <shapr> pxfont: No of course not! six major versions mean nothing!
13:45:02 <emu> monoids in stereo = steroids?
13:45:06 <bos> Cale: it looks like what i want to do involves nasty typeclass extensions that cause sudden cranial expansion and a big mess on my shirt.
13:45:10 <pxfont> (the abstract machine might be the same)
13:45:10 <Cale> pxfont: Uh, yes, I'd expect almost everything would have changed.
13:45:20 <pxfont> it is still STG etc
13:45:23 <pxfont> ?
13:46:07 <Cale> I think that's stayed the same, but I'm not sure about whether the implementation of the STG has changed.
13:46:11 <shapr> Ok, I admit. Some parts of GHC have changed from 0.22 to 6.6
13:46:22 <apfelmus> shapr: thanks, i missed this page. there is nothing there directly, but "Polytypic compact printing and parsing" looks good
13:46:28 <Cale> Yeah, you're talking about 6 major revisions.
13:46:40 <pxfont> shapr, yes, but what parts from a abstract machine point of view (various higher level features of course...)
13:46:57 <pxfont>  (gadts etc etc etc)
13:47:05 <shapr> apfelmus: Paterson's Fun of Programming chapter is a good overview of arrows, and Hughes' paper has more details after that. That's my suggested approach to arrows.
13:47:11 <Cale> There are people working on things like the inliner and strictness analysis and all sorts of things, even now.
13:47:32 <pxfont> Cale, yes I see. Perhaps less of the pseudoknot manual annotations are now needed
13:47:40 <apfelmus> shapr: yeah, i know both. i'm after the parsers+arrows
13:47:42 <pxfont> The pseudoknot was probably a very well written prgoram
13:47:53 <Cale> Is the code available?
13:47:56 <shapr> apfelmus: Oh, there's also a category theory paper that Wouter Swierstra mentioned to me where arrows are connected to monads in some very simple way, but I forget the details.
13:48:15 <pxfont> Yes I think so, search google for pseudoknot functional benchmark or something
13:48:25 <shapr> apfelmus: I probably have two arrow-style parsers in my collection, you want 'em?
13:48:38 <Cale> pxfont: what makes you so interested in this particular benchmark?
13:48:44 <Philippa> some of the STG implementation's changed. The shift to eval/apply, for example
13:49:04 <pxfont> is it now a Krivine machine of some sort?
13:49:09 <shapr> Cale: ooh, you improved the arrows artwork!
13:49:16 <Cale> shapr: yes :)
13:49:19 <pxfont> (like Leroy's work for Caml Light etc )
13:49:23 <shapr> Looks much better now.
13:49:32 <apfelmus> shapr: premonoidal categories? about the parsers, that would be nice.
13:49:52 <edwinb> pxfont: I think the best paper now is Peyton Jones & Marlow's "Making a fast curry"
13:49:53 <shapr> apfelmus: I don't remember, and I don't have time to dig through my papers and find it. I have a lot of papers.
13:49:59 <edwinb> unless anyone has any advance on that...
13:50:09 <pxfont> cheers edwinb
13:50:14 <Cale> Yeah, it started out as me drawing some sketches to explain stuff to metaperl, and then he submitted them to the arrows page maintainer, and so I decided to help out the consistency.
13:50:35 <Cale> pxfont: http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz
13:50:40 <Cale> pxfont: http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
13:50:41 <lambdabot> Title: Rewriting Haskell Strings
13:51:01 <Cale> There's a good example of an area that's undergone lots of improvement.
13:51:06 <apfelmus> shapr: np. but i'd be happy if you could lend me the arrow parsers
13:51:15 * Philippa goes
13:51:26 <apfelmus> Philippa: bye
13:51:40 <apfelmus> see you later
13:51:58 <shapr> apfelmus: I can't find my local copy of either, but here's the ones from musasabi: http://www.cs.helsinki.fi/u/ekarttun/
13:52:00 <lambdabot> Title: random stuff
13:52:03 <Cale> Don has successfully processed terabyte-long strings in a reasonable timeframe with lazy bytestrings.
13:52:08 <shapr> apfelmus: see PArrows there
13:52:21 <apfelmus> shapr: ah, thanks a lot
13:52:33 <shapr> Those parsers are especially cute. Their Show instance gives their regex equivalent :-)
13:53:03 <shapr> Cale: pxfont appears to have a particular agenda in mind...
13:53:21 <Cale> He's sort of reminding me of protontorpedo :)
13:53:35 <shapr> heh
13:53:36 <shapr> yup
13:53:47 <wkh> http://weblogs.java.net/blog/thejavafinch/archive/2007/01/mark_reinhold_a_1.html how the mighty have fallen
13:53:49 <lambdabot> Title: Juggy The Java Finch's Blog: Mark Reinhold and Heather VanCura - discussing the  ..., http://tinyurl.com/yogup8
13:55:17 <wkh> the JCP: innovation by committee
13:59:53 <shapr> wkh: Are you sure you got the right channel for that?
14:01:40 <bos> damn, the type system makes my brain hurt.
14:02:47 <apfelmus> shapr: mh, they're not ArrowChoice, though
14:03:21 <hpaste>  bos pasted "(no title)" at http://hpaste.org/681
14:04:01 <shapr> apfelmus: Should they be?
14:04:02 <bos> i have a perfectly good "Chan" type, and don't know how to abstract it into a typeclass.
14:04:09 <bos> see the paste above
14:04:11 <shapr> apfelmus: Fix it and post a blog entry!
14:04:45 <bos> anyone got any hints?
14:05:32 <apfelmus> shapr: :) guessing from the implementation, i think they cannot be. but i'd like see ones that are ArrowChoice.
14:06:22 <apfelmus> in particular, i'm wondering why they use arrows as interface whereas applicative functors might do as well
14:06:58 <shapr> apfelmus: I almost understand what you just said, and would very much like to see code to demonstrate both alternatives.
14:08:17 <shapr> apfelmus: Could you write a twenty line demo of an ArrowChoice parser?
14:08:32 <apfelmus> i mean, if applicative is possible, then it's likely to be a nicer interface.
14:08:55 <shapr> Try it!
14:09:16 <shapr> If you can make parsers even nicer to use in Haskell, people will be happy.
14:09:48 <apfelmus> shapr: well, it's no problem to put parsec into an ArrowChoice but that's not the point.
14:10:07 <apfelmus> the question is whether the Duponcheel parsers need arrows.
14:10:38 <apfelmus> i doubt so, simply because they didn't develop them with arrows first hand
14:10:56 <apfelmus> they're actually using applicative functors without coining them as such
14:10:58 <nmessenger> bos: should you maybe move the '(Binary r, Binary w) => ' context into the 'instance Channel (Chan r w)' declaration?
14:11:16 <shapr> apfelmus: Write a paper!
14:11:32 <RemiTurk> hi everyone
14:11:36 <shapr> hoi RemiTurk
14:12:11 <apfelmus> but the rumors about "arrows needed for duponcheel" made me wonder. unfortunately, i could not track down the rumors as of now
14:12:19 <bos> nmessenger: no, that creates more problems.
14:12:24 <shapr> The details are in Hughes' paper.
14:12:57 <shapr> "Generalizing Monads to Arrows"
14:16:01 <apfelmus> aah, thank you. i had "Programming with Arrows" in front of me
14:19:25 <apfelmus> ok, i have to go. thanks again :)
14:22:03 <wkh> > if True then 1/2 else 1/0
14:22:04 <lambdabot>  0.5
14:22:08 <wkh> omg lazy evaluation!
14:22:29 <nmessenger> > 1/0
14:22:31 <lambdabot>  Infinity
14:22:41 <nmessenger> omg infinity!
14:23:25 <dibblego> wtf?
14:23:32 <eyeris> I am learning Haskell. I really don't like the tutorials on haskell.org because, interspersed with the description of how something works is usually a handful of paragraphs about why this is so unbelievably better than the imperitave analog. Are there any resources on the Web with small 15-50 line programs with a breakdown of each part? The tutorials all seem to have 1-2 line snippets, but it's hard to learn the full syntax that way.
14:23:37 <wkh> why does it say it's infinity when 1/0 is undefined? lim n->0 1/n = inf is no excuse
14:24:04 <RemiTurk> wkh: because that's the way the Double datatype is defined..
14:24:27 <wkh> eyeris: i don't know. http://haskell.org/haskellwiki/Gallery ?
14:24:29 <lambdabot> Title: Gallery - HaskellWiki
14:24:33 <Saizan> wkh: that's the IEEE 754 standard
14:24:35 <RemiTurk> wkh: if you want integral-division you can use div or quot (and mod or rem)
14:24:38 <nmessenger> > 1 `div` 0 -- wkh
14:24:39 <lambdabot>  Exception: divide by zero
14:24:59 * wkh stands corrected
14:25:30 * shapr boings cheerfully
14:25:35 <eyeris> wkh: That's almost extactly what I am looking for. Thanks. I'm going to go print these off.
14:25:40 <shapr> hiya greenrd, how's code?
14:26:05 <shapr> Isn't 336 a new high water mark for #haskell?
14:26:11 <wkh> ?stats
14:26:12 <lambdabot> Unknown command, try @list
14:26:18 <wkh> how do you do the stats thingie
14:26:20 <wkh> @stats
14:26:20 <lambdabot> Unknown command, try @list
14:26:27 <dibblego> ?users
14:26:28 <lambdabot> Maximum users seen in #haskell: 336, currently: 322 (95.8%), active: 51 (15.8%)
14:26:31 <wkh> ah
14:27:06 <nmessenger> @where stats
14:27:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
14:36:50 <shapr> Is there a standard name for a style document? Maybe they're usually called STYLE in the repo?
14:37:27 <glguy> nmessenger: wrt ?where stats: read 'em and weep ;)
14:37:36 <JohnMeacham> anyone have a good 'multiprecision' arithmetic library for haskell. it need not be fast.
14:37:55 <xic> Rational?
14:38:10 <shapr> glguy: I'm down to 15th for 2007
14:38:14 <JohnMeacham> not arbitrary precision. multiprecision.
14:38:37 <JohnMeacham> like 'multiply these two numbers as if they were 24 bit modular' or '80 bit IEEE floats'
14:38:42 <shapr> glguy: You're in fourth place! w00!
14:39:03 <shapr> glguy: But look at the all time rankings ;-) I'm beating lambdabot!
14:39:06 <JohnMeacham> to get exact results for operations that may not be native to the arch you are running on.
14:39:07 * nmessenger wonders what to weep at
14:41:07 <pejo> JohnMeacham, gcc just integrated that kind of stuff, but that is a C library.
14:41:38 <JohnMeacham> pejo: yes. I was thinking of linking agaist that library. but would rather find a pure haskell solution.
14:41:49 <nmessenger> I'm really surprised that I'm #8.  I just started a couple months ago and I've not really written much of anything, just toying around.
14:42:08 <nmessenger> Perhaps I should should spend more time coding and less time ircing. :)
14:42:10 <shapr> heh
14:42:14 <shapr> Me too!
14:42:20 <shapr> But I haven't been on #haskell much this year.
14:42:29 <shapr> Not compared to previous years, yow!
14:42:42 <sieni> shapr: what an accomplishment :-)
14:43:05 <shapr> hej ohmega!
14:43:09 <ohmega> shapr!
14:43:25 <shapr> sieni: Well, I talked enough that people joined #haskell and stayed :-)
14:43:32 <shapr> ohmega: How's the wheel treating you?
14:43:34 <MarcWebe1> Can I tell ghc to use an instance if one type is not an instance of class HList?
14:43:38 <hpaste>  Marc Weber pasted "overlapping instances." at http://hpaste.org/682
14:44:24 <MarcWebe1> HListAppendArbitrary should create an HList by appending a to b no matter wether a and b are already a HList.
14:46:11 <chessguy> i don't know when Cale does all his talking. he has 1100 more lines than i do. i wouldn't have guessed that
14:46:20 <Cale> Hehe
14:46:49 <Cale> I do plenty of talking here.
14:46:49 <chessguy> Cale, shhh!
14:47:00 * chessguy slaps tape over Cale's mouth
14:47:19 * chessguy dusts his hands off. that takes care of that problem!
14:47:38 <MarcWebe1> chessguy: About which lines are you talking? Is there a who gets highest score competition where score = lines of haskell code written this yeat + hours spent on irc?
14:48:02 <chessguy> MarcWebe1, i'm talking about http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html
14:48:02 <lambdabot> Title: #haskell @ freenode.org stats by dons
14:48:49 <nmessenger> I think (haskell locs / #haskell hours) would be the most salient metric. :3
14:48:59 <siti> "many Haskell coders have been known to state that Haskell is their favourite imperative language" from a wiki
14:49:01 <siti> :D
14:49:06 <Cale> I might even have a more even distribution of times than lambdabot.
14:49:30 <chessguy> heh. that's pretty bizarre, Cale
14:49:37 <nmessenger> Cale: about as even as mine and mauke's
14:49:43 <Cale> Not if you knew my sleep schedule :)
14:50:01 <MarcWebe1> Cale: How does it look like?
14:50:02 <Cale> Half the time, I behave as if I'm in Australia. This has been noticed :)
14:50:34 <nmessenger> Cale: didn't you have tape on your mouth?
14:50:53 <Cale> Oh, right, mMMmmMmmnmnmMmm Mmm.
14:51:20 <int-e> Hmm. I've become really really quiet it seem.
14:51:21 <int-e> s
14:51:26 * chessguy considers @remember'ing that one
14:51:29 <nmessenger> just
14:51:31 <nmessenger> send
14:51:32 <nmessenger> one
14:51:33 <nmessenger> word
14:51:33 <nmessenger> at
14:51:34 <nmessenger> a
14:51:35 <nmessenger> time
14:51:38 <int-e> nmessenger: grr.
14:51:39 <Cale> Yeah, I've been surpassed by glguy in lines.
14:51:53 <nmessenger> You'll quickly rise! :P
14:51:54 <chessguy> by quite a lot
14:52:02 <Cale> and number of words, as well.
14:52:15 <glguy> I was going to say, what are you implying! :)
14:52:30 <MarcWebe1> O r  w h a t  a b o u t  t h i s ? W e  m i g h t  w r i t e  a n  i r s s i  s c r i p t  t o  d o  t h i s ;-)
14:52:45 <glguy> MarcWebe1: I have an irssi script to /kickban
14:52:47 <glguy> :-D
14:52:51 <mbishop> burn
14:53:02 <chessguy> heh. allbery_b has 10,000 more words than me, but less lines
14:53:50 <Cale> fewer lines :)
14:53:53 <Cale> hehe
14:54:01 <wkh> when you worry about what your stats are in a channel, you're using IRC too much
14:54:02 <chessguy> augh! yes
14:54:23 <chessguy> yikes, i usually don't mix those up
14:54:28 <chessguy> chessguy--
14:54:48 <Cale> It's odd that there isn't a corresponding distinction for 'more'.
14:55:05 <chessguy> indeed
14:55:52 <chessguy> ok, time to go home
14:55:59 <chessguy> see ya'all on the other side
14:56:12 <LoganCapaldo> Does irssi suppost Haskell irc srcripts? :)
14:56:19 <LoganCapaldo> type safe lazy kick banning!
14:56:48 <nmessenger> meh.  I spend time here but I've learned *oodles*.
14:56:54 <sieni> somebody should make an irc client plugin to yi ^_^
14:57:05 <Saizan> will it kickban only when the user does say something?:)
14:57:28 <MarcWebe1> (LoganCapaldo :: Man)  this kind of type ?
14:57:40 <ddarius> sieni: Canabalizing from lambdabot or Hircules, that shouldn't actually be that hard.
14:58:08 <LoganCapaldo> MarcWebe1: I don't get it
14:58:52 <glguy> Saizan: haven't we been over this before? :)
14:59:25 <MarcWebe1> type safe lazy kick banning .. which type of type? type of user ? ( eg flooder :: Spammer ) ? Never mind. Forget it.
14:59:35 <Saizan> glguy: with the chanserv's one?:D
14:59:56 <glguy> oh yeah chanserv was on join
15:05:44 <RemiTurk> goodnight to all
15:06:52 <greenrd> hi shapr
15:07:01 <dons> moin!
15:07:02 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
15:07:21 <stepcut> moin!
15:07:27 <dons> hey stepcut !!
15:07:34 <dons> ?users
15:07:34 <lambdabot> Maximum users seen in #haskell: 336, currently: 313 (93.2%), active: 53 (16.9%)
15:07:35 <greenrd> shapr: I'm writing a parser for Coq theories, using Frisby, right now
15:07:40 <dons> whoa. new record again
15:08:00 <stepcut> whoa! It was only 200 last time I was here :p
15:09:03 <dons> we seem to b undergoing a period of community growth
15:09:11 <shapr> greenrd: Cool, why Frisby over Parsec or something else?
15:09:14 <bos> it's all the bloggers.
15:09:25 <dons> good.
15:09:35 <dons> we had too little publicity for the first 15 years
15:09:49 <bos> boy, it really sucks to drop back from haskell to linux kernel hacking.
15:09:53 <dons> heh
15:10:13 <bos> on the other hand, at least i can beat up the type system whenever and however i like.
15:10:18 <shapr> bos: heh
15:10:34 <shapr> bos: I've had some thoughts about that, is it possible to post-process kernel code to check invariants?
15:10:37 <nmessenger> bos: careful it doesn't fight back :)
15:11:12 <bos> shapr: there's a tool called sparse that does some limited checking by enforcing stricter type rules.
15:11:30 <greenrd> shapr: The linear time parsing and lack of lexer/parser split appealed to me - also the approach of using mdo sounds mind-bending ;)
15:11:42 <bos> you can annotate variables as living in different address spaces, being of different endianness, etc.
15:12:05 <bos> it's pretty wimpy, but better than nothing. the industrial-strength stuff is all closed source.
15:12:29 <pejo> shapr, Coverity does some checking too. Not sure how often they perform runs on the kernel source nowdays though.
15:12:45 <greenrd> I like the idea of Kernel Mode Linux
15:13:03 <greenrd> I wonder if anyone has got haskell code running in the kernel with KML
15:13:17 <siti> isn't called UML :p
15:14:43 <greenrd> no no, KML is the opposite of UML
15:14:51 <greenrd> In UML you take a kernel and run it in userspace
15:15:18 <greenrd> in KML you take a userspace process and run it in kernel mode (ring 0 or whatever)
15:15:39 <bos> i've been thinking about writing a kernel source checker in haskell.
15:15:39 <bos> but that would require, how do they put it, free time.
15:16:12 <bos> coverity does automated runs every day.
15:21:18 <siti> greenrd: oh ok
15:22:35 <sorear> hello
15:22:36 <stepcut> bos: there is a tool, splint, that is open source. Pretty powerful, but hard to use if you don't use it from day 0 of the project.
15:25:45 <bos> splint is ansi c only, which isn't very useful. nobody uses ansi c.
15:25:55 <mauke> splint isn't even ansi c
15:25:55 <siti> splint is dead isn't :(
15:26:22 <mauke> I don't trust splint since it gave me a parse error for valid C code
15:26:27 <bos> splint also relies on lots of in-source annotations.
15:28:41 <SamB> @quickcheck (\a b -> ((a - b) >= 0) /= (a >= b))
15:28:42 <lambdabot> Unknown command, try @list
15:28:47 <sorear> <troll> haskell typecheckers also need in-source annotations </troll>
15:28:50 <SamB> @check (\a b -> ((a - b) >= 0) /= (a >= b))
15:28:51 <lambdabot>  Add a type signature
15:29:04 <sorear> @check \a b -> ((a - b) >= 0) /= (a >= b)
15:29:05 <SamB> @check (\a b -> ((a - b :: I) >= 0) /= (a >= b))
15:29:06 <lambdabot>  Add a type signature
15:29:07 <lambdabot>  Falsifiable, after 0 tests: 0, -1
15:29:09 <dons> type of a and b, since check doesn't compile with -fextended-defaulting
15:29:18 <sorear> hello dons
15:29:30 <nmessenger> :: I?
15:30:10 <dons> hey sorear
15:30:14 <SamB> @check (\a b -> ((a - b :: I) >= 0) ==> (a >= b))
15:30:16 <lambdabot>  OK, passed 500 tests.
15:31:20 <psi> what is I?
15:31:24 <SamB> @qcheck (\a b -> ((a - b :: I) >= 0) /= (a >= b))
15:31:25 <lambdabot> Maybe you meant: check scheck
15:31:29 <SamB> reg/
15:31:39 <SamB> @scheck (\a b -> ((a - b :: I) >= 0) ==> (a >= b))
15:31:41 <lambdabot>   Completed 169 test(s) without failure.  But 78 did not meet ==> condition.
15:32:07 <LoganCapaldo> Err, what does ==> mean?
15:32:11 <glguy> implies
15:32:12 <sorear> @src (==>)
15:32:12 <LoganCapaldo> implication?
15:32:12 <nmessenger> "implies"
15:32:13 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:32:16 <glguy> it's a precondition
15:32:38 <bos> if i have a polymorphic datatype, such as data Spud t, is there an easy way of saying that it is an instance of a typeclass, or do i have to go down the -fundecidable-instances slippery slope?
15:32:41 <sorear> yay! #1086 is FIXED! vty will work on HEAD now!
15:32:42 <nmessenger> @type (==>)
15:32:45 <lambdabot> forall a. (Testable a) => Bool -> a -> Property
15:32:55 <dons> ?seen ndm
15:32:56 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 5h 18m 9s ago, and .
15:33:19 <sorear> dons: what's the difference between the 3 nobench results pages?
15:33:34 <sorear> dons: i686/x86_64 makes sense, but what's the third?
15:34:21 * SamB is defending his choice of x86 condition codes ;-)
15:34:30 <stepcut> sorear: when you said 'Your website has multiple strongly connected components :(', what did you mean ?
15:35:09 <nmessenger> SamB: so what's this I type?
15:35:19 <SamB> Int
15:35:22 <chessguy> never fear, i am here!
15:35:22 <SamB> type I = Int
15:35:28 <nmessenger> :O
15:35:28 <sorear> a scc in a directed graph is a collection of nodes where every node is reachable from every other node
15:35:40 <nmessenger> where's that defined?
15:35:50 <sorear> so with multiple scc's, getting from here to there requires guessing URLs
15:36:56 <sorear> stepcut: if you haven't already, you may wish to communicate with newsham; he is also working on porting lambdabot (to SILC) and wants to know what needs to be abstracted
15:37:03 <dons> sorear: what's the third?
15:37:10 <dons> there's only 2 results pages, afaik.
15:37:19 <sorear> http://www.cse.unsw.edu.au/~dons/nobench/results.html
15:37:20 <lambdabot> Title: nobench: Haskell implementation shootout
15:37:30 <sorear> or is that a symlink?
15:37:31 <dons> that's a ln -s to x86, isn't it?
15:37:42 <dons> since i didn't want to break the link that got submitted to reddit
15:38:05 <ddarius> sorear: Are you trying to say stepcut's site has multiple disconnected components?
15:38:05 <sorear> same size and modtime, but I don't see any "symlink" data :)
15:38:18 <alexj> sorear: what is SILC?
15:38:41 <sorear> ddarius: no. disconnected components would mean you can't go either way.  stepcut's site has trapdoors.
15:39:02 <sorear> alexj: some obscure IRC varient designed for use with TLS
15:39:32 <sorear> @users
15:39:32 <lambdabot> Maximum users seen in #haskell: 336, currently: 315 (93.8%), active: 53 (16.8%)
15:46:26 * sorear laughs at yhc bug #127
15:46:33 <dons> hehe
15:46:41 <dons> they need some QuickChecks!
15:47:09 <sorear> dons: did you see the size of the fix?
15:48:01 <stepcut> trapdoors! :(
15:48:18 <dibblego> sorear, yhi computes [1,1..] as [1,1,3,7,17,41,99,239,577,1393 ... ?
15:48:35 <sorear> dibblego: yeah!
15:48:43 <dibblego> cool
15:48:46 <dibblego> I want one
15:49:29 * stepcut needs to update his site for real
15:49:31 <dons> sorear: wasn't it teensy?
15:49:49 <matthw> hello
15:49:58 <dons> i note that yhc is suddenly creating foo.hbc instead of Main.hbc
15:50:03 <matthw> can i ask a (perhaps silly) question about syntax
15:50:11 <nmessenger> mattam: certainly!
15:50:12 <dons> of course
15:50:19 <matthw> why is it that in a lot of haskell code i see
15:50:23 <dibblego> only if it really silly
15:50:30 <sorear> because you're not blind? :)
15:50:31 <matthw> a comma is used at the start of a line to separate items of a list
15:50:39 <matthw> rather than at the end
15:50:43 <matthw> it looks really odd!
15:50:48 <dons> ah, its a convention that makes it easier to add new elements to a list
15:50:49 <dons> after the fact
15:50:53 <matthw> does haskell not parse the usual form correctly?
15:50:53 <sorear> because the h98 fools used comma-as-separator
15:50:57 <matthw> ah ok
15:51:01 <dons> since you don't have to go and add a , to the *end* of the line above as well
15:51:16 <dons> [ a
15:51:17 <dons> ]
15:51:19 <dons> for exampel
15:51:19 <stepcut> dons, matthw: but you pay the penalty in that it is harder to remove the first  line of a list
15:51:31 <dons> who removes lines of code!? ;)
15:51:36 <sorear> terminators ftw!
15:51:40 <dons> [ a
15:51:44 <dons> , b
15:51:44 <dons> ]
15:51:55 <dons> so i just change one line there. instead of two
15:52:00 <matthw> yeah that makes adding things to the end easier at the expense of adding things at the start
15:52:13 <matthw> and also the expense of making the syntax look strange :)
15:52:17 <nmessenger> discriminating hackers use (x:y:z:[]) over [x,y,z]
15:52:18 <matthw> but anyway i have my answer i guess
15:52:28 <dons> i used not to like it, but i quite appreciate it now
15:52:31 <dons> after several years
15:52:36 <matthw> haha
15:52:39 <stepcut> of course, in the module export list, you can have an unnecessary trailing , but not in lists
15:52:50 <dons> stepcut: not in hugs though
15:52:50 <stepcut> [a,b,c,]
15:53:03 <dons> ghc sloppiness ;)
15:53:08 <nmessenger> > [1,2,3,]
15:53:09 <lambdabot>  Parse error
15:53:23 <sorear> stepcut: fixed in HEAD. used in 6.4.2.
15:53:24 <stepcut> i think python allows that -- not sure if I like it though
15:53:40 <dons> matthw: you see a similar style used for explicit do-notation
15:53:40 <sorear> stepcut: almost all modules in 6.4.2 fail to compile in head
15:53:43 <dons> do x
15:53:45 <dons>    ; y
15:53:49 <dons>    ; z
15:53:52 <dons>   }
15:54:04 <sorear> stepcut: so I had two working ghcs and needed to install 6.4.2 as a BINARY.  sheesh.
15:54:05 <dons> well, i missed a brace at the start
15:54:12 <stepcut> sorear: haha
15:54:26 <ndm> dons: thanks for finding that Yhc bug, with Integer Enums
15:55:10 <matthw> so it's purely a matter of taste, rather than something forced by the rules of a particular parser
15:55:12 <matthw> ?
15:55:15 <dons> ndm, no worries. now, i've built yhc head..
15:55:23 <dons> and it seems yhc now creates foo.hbc from foo.hs?
15:55:28 <ndm> dons: did it work?
15:55:33 <dons> but when I run yhi foo.hbc
15:55:34 <ndm> dons: oh yeah, we checked that change in
15:55:40 <ndm> dons: yeah, and it won't run :)
15:55:42 <siti> @seen dcoutts
15:55:42 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I don't know when dcoutts last spoke.
15:55:45 <nmessenger> mattw: yep
15:55:45 <dons> it asks for Main.hbc still
15:55:49 <dons> ndm, ok.
15:55:55 <siti> it has a short memory :p
15:55:57 <dons> my quick fix is to mv $(TEST).hbc Main.hbc
15:56:06 <dons> ndm, just checking now if it works.
15:56:08 <ndm> dons: thats actually a very high priority bug, i'll do it now
15:56:16 <nmessenger> geh, too many mat(.*)'s in this channel
15:56:20 <ndm> dons: did one half of the change on a computer without a C compiler :)
15:56:24 <sorear> ndm: how stable is the byecode format?
15:56:26 <dons> ndm, also, i suspect I have a couple of other bugs for you.
15:56:34 <dons> ndm, is it best to mail, or is there a Trac ?
15:56:42 <ndm> sorear: pretty stable, why? we have a Bytecode API which guarantees more stability
15:56:45 <sorear> no trac, google code
15:56:54 <ndm> dons: there is a google code - do you hvae a gmail?
15:57:15 <dons> i do.
15:57:15 <dons> url?
15:57:19 <sorear> ndm: oh, I've been tempted to rewrite my own yhi.
15:57:28 <ndm> sorear: in what?
15:57:33 <ndm> http://code.google.com/p/yhc/issues/list
15:57:35 <lambdabot> Title: yhc - Google Code
15:57:55 <sorear> mostly haskell, i386 asm for the bytecode interpreter proper
15:57:56 <dons> ?yhc-bugs http://code.google.com/p/yhc/issues/list
15:57:56 <lambdabot> Unknown command, try @list
15:58:03 <dons> ?where+ yhc-bugs http://code.google.com/p/yhc/issues/list
15:58:03 <lambdabot> Done.
15:58:17 <ndm> sorear: yeah, its pretty stable, not changed in a while
15:58:36 <sorear> I want to get ayhi running well in <2048 bytes :)
15:58:44 <ndm> sorear: the bytecode structure may change at some point, so we can support lots of files in one module etc, but hte actual bytecodes will stay the smae
15:58:48 <ndm> sorear: that would be impressive!
15:58:56 <dons> ndm, as you can see, there's some other output errors, http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
15:58:57 <lambdabot> Title: nobench: Haskell implementation shootout
15:59:07 <dons> primes is probably the same as the one you fixed, I suspect
15:59:18 <ndm> dons: if you give me your gmail, i'll add you as a project member, so you can set flags etc
15:59:19 <dons> i'll let you know if i uncover any others
15:59:24 <dons> dons00@
15:59:25 <sorear> ndm: actually stability-wise I'm more concerned about implementing the Prelude.  rewriting yhc-base sounds much less fun than a JIT optimizer :)
15:59:46 <dons> ndm, any news on the slowdown wrt. nhc?
15:59:59 <ndm> sorear: you only have to implement a few primitives, and those are stable, and will remain so even as the prelude changes
16:00:19 <ndm> dons: alas no, darcs --tag doesn't work, so its hard to benchmark Yhc against old Yhc, which is holding us back
16:00:22 <sorear> ndm: yay!
16:00:23 <dons> ndm, also, is it worth a bug report? the calendar programs runs in 0.04s in nhc, and 100s in yhc
16:00:51 <ndm> dons: nhc beats ghc, something funny is going on there, but yeah, i guess
16:01:19 <dons> yeah, there's a ghc bug simon found
16:01:23 <dons> nhc is doing the right thing
16:01:32 <dons> so is hbc
16:01:34 <ndm> dons: i'm curious if thats in the runtime (which are pretty equivalent) or the generated code (which are the same...)
16:01:39 <sorear> dons: I will of course be using nobench to performance-test ayhi
16:01:51 <dons> i think malcolm suggested that the io monad implementatoin might be different in yhc?
16:01:51 <stepcut> dons: did you get my email about nobench ? Our corporate mail has been offline all day, so I am not sure if the message made it out..
16:02:04 <dons> stepcut: i have, and will be "actioning" your request today
16:02:17 <sorear> should nobench have a trac?
16:02:27 <stepcut> dons: spiffy!
16:02:29 <sorear> so we can see the requests etc?
16:02:39 <dons> ndm, yah
16:02:39 <dons> $ diff -u digits-of-e2.yhc.actual digits-of-e2.expected
16:02:39 <dons> $
16:02:39 <dons> :-)
16:02:39 <ndm> dons: its pretty similar, although we did improve it in the last few days, so should be even faster
16:02:53 <ndm> sorear: we'll have -O soon for Yhc, so that should give you a boost as well
16:02:56 <dons> ok. i've got today's yhc, that'll update this time tomrrow.
16:02:57 <ndm> sorear: are you doing JIT?
16:03:13 <sorear> ndm: not yet, and it will be subject to an %ifdef.
16:03:24 <ndm> sorear: funky!
16:03:26 <sorear> ndm: right now I'm not doing bytecode loading :)
16:03:28 <CosmicRay> @paste
16:03:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:04:33 <ndm> dons: i just did a sample, and yhi Test.hbc works fine...
16:04:38 <siti> I know dcoutts is not here, but is there anyone else that would know why I can't get the latest darcs gtk2hs compiling
16:04:50 <siti>  Failed to load interface for `System.Glib.GType':
16:04:54 <sorear> ndm: I've figured out how to have almost all of ayhi in Haskell.  basically I'll add a few more nonportable primops (create function info, etc) in a Ayhi.Primitive module, and pre-seed the heap in the executable image with bytecodes for the bytecode loader.
16:04:59 <dons> ndm, lower case perhaps?
16:05:40 <dons> $ yhc   bernouilli.hs
16:05:40 <dons> Compiling Main             ( bernouilli.hs )
16:05:42 <ndm> dons: i'm on windows, no difference
16:05:44 <dons> $ yhi bernouilli.hbc 500
16:05:44 <dons> ERROR: couldn't find module named 'Main'
16:05:44 <dons> tried:
16:05:44 <dons>         Main.hbc
16:05:44 <dons>         /tmp/bin/../lib/yhc/packages/yhc-base/1.0/Main.hbc
16:05:49 <sorear> ndm: two fringe benefits: (a) bytecode is smaller than GCC-generated asm (I hope) (b) the bytecode loader is trivially available to haskell code.  hs-plugins could support ayhi very easily.
16:06:02 <dons> $ yhi Main.hbc 500
16:06:04 <dons> happy
16:07:11 <araujo> siti, it works fine here
16:07:15 <ndm> dons: i just tried, and it works perfectly...
16:07:16 <siti> hmm
16:07:20 <araujo> hello haskellers
16:07:30 <siti> araujo: what configure options did you use?
16:07:40 <siti> what ghc
16:07:47 <araujo> siti, ghc 6.6
16:07:48 <ptolomy> I'm doing a 'diffClockTime' between two clock times, and the seconds value increases (as expected), but the picoseconds value alternates between negative and positive. Any ideas?
16:08:05 <dons> ndm, that's yhc on linux, as of 5 mins ago.
16:08:07 <araujo> and i am using firefox, gnome support
16:08:09 <dons> any new patches since then?
16:08:38 <dons> ndm, is it possible the build didn't rebuild everything ?
16:08:40 <siti> hmm, I will look at what configure options the ebuild does...
16:08:53 <ndm> dons: mine is yhi as of half an hour ago, on windows - but windows always used to have the problem...
16:09:08 <araujo> siti, you use gtk2hs-darcs?
16:09:13 <dons> ndm, can I  yhc -o Main.hbc bernouilli.hbc
16:09:14 <dons> ?
16:09:16 <ndm> dons: no idea why it isn't happening on mine....
16:09:18 <sorear> ndm: did YOU get my buildsystem fix?  the listserver sent to moderator, and beelsebob didn't get it...
16:09:19 <siti> I am doing it manually
16:09:26 <siti> I am trying to update cario bindings
16:09:29 <ndm> sorear: i'm not a mod :(
16:09:30 <siti> cairo*
16:09:39 <araujo> siti, ok , try the ebuild
16:09:41 <sorear> ndm: who else is?
16:09:41 <dons> ah, no, $ yhc -o Main.hbc bernouilli.hs
16:09:42 <dons> yhc: Unknown flag: o
16:09:48 <ndm> sorear: send it directly to me, ndmitchell  -at- gmail.com
16:09:57 <siti> yeah if that fails I'll know what it is :p
16:10:09 <ndm> sorear: just bob, he added me as an admin, but with my wrong email address...
16:10:20 <sorear> ndm: the patch might already have been applied, after beelsebob said he didn't have it I sent it to tomshackell
16:10:40 <sorear> ndm: and he can't fix it!?
16:10:44 <ndm> sorear: darcs patch? if so reapplying isn't an issue
16:10:57 <ndm> sorear: he had forgotten the password last time i asked, will ask again though
16:11:09 <sorear> ndm: yeah darcs patch
16:11:34 <sorear> ndm: 2 line fix, fixes a FTBFS (I'm sure you care about THOSE), 50kb of context.  40kb list limit.
16:11:57 <sorear> ah, still not in the repo.
16:11:58 <matthw> i have a more interesting query also
16:12:00 <sorear> sending to you ...
16:12:19 <ndm> ftbfs ?
16:12:29 <sorear> debian acronym
16:12:35 <ndm> we should also up the list limit, everyone has gmail accounts now, so no one cares :)
16:12:35 <sorear> failure to build from source
16:12:38 <matthw> is there any structure which is like a monad but with extra restrictions to ensure they are more composable
16:12:51 <ndm> sorear: the alternative is to open a bug and attach to that, which always works (good old google!)
16:12:51 <matthw> ive been wondering about this
16:13:34 <sorear> ndm: I don't have gmail.  I have fetchmail and an 80 gig hard drive and 500kb/s inet, so I still don't care about message sizes ....
16:13:45 <sorear> that means I can't open bugs, right?
16:13:55 <sorear> anyway, patch sent
16:14:14 <ndm> dons: it appears my last yhi build didn't do as much as it could, so am having another go
16:14:22 <ndm> sorear: received
16:14:48 <sorear> I trust it is Obviously Correct, this is my first encounter with scons
16:15:19 <sorear> ... and hating every minute :(  why can't we have a decent haskell build system?
16:15:43 <SamB> sorear: I didn't like SCons even when I was a Python user
16:15:53 <dons> it seems like yhc could just about run in cabal..
16:15:56 <ndm> sorear: i must say i hate scons too
16:16:08 <ndm> dons: building yhi? and ensuring ctypes and gmp?
16:16:18 <ndm> dons: we'd welcome a patch though :)
16:16:20 <siti> cabal seems good :p
16:16:21 <xic> scons worked pretty well for me on c++ projects
16:16:32 <siti> beats all the build systems I have used
16:17:09 <ndm> but is still in constant flux and not that reliable
16:17:14 <ndm> all build systems are crap, to be fair
16:17:18 <siti> lol
16:17:25 <ndm> apart from hmake, that was actually pretty solid
16:17:26 <siti> automake being the worst :p
16:17:34 <chessguy> ?hoogle replicateM
16:17:34 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
16:17:35 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
16:17:36 <ndm> sorear: pushed
16:17:44 <chessguy> ?src replicateM
16:17:44 <lambdabot> replicateM n x = sequence (replicate n x)
16:17:54 <ndm> sorear: are you going to develop ayhi in the Yhc tree?
16:18:21 <chessguy> @pl \n x -> s (r n x)
16:18:21 <lambdabot> (s .) . r
16:18:48 <nmessenger> @pl \f g x y -> f (g x y)
16:18:48 <lambdabot> (.) . (.)
16:19:04 <sorear> ndm: good question  (obviously not ATM)
16:19:27 <ndm> sorear: its the natural place for it, and that suits us
16:19:32 <sorear> ndm: if you think it'd be a Good Idea I'll certainly consider it
16:19:35 <ndm> sorear: do you have a haskell.org account?
16:19:44 <sorear> nope
16:19:50 <ndm> sorear: do you have a public key?
16:20:12 <MarcWebe1> sorear: I'm working on a cabal alternative.. But I think I still need some days before releasing anything. I want to make it compile some projects first..
16:20:16 <sorear> no, mainly for want of docs on how to make one
16:20:28 <sorear> man openssl was just Too Confusing
16:20:59 <ndm> The GHC CVS cheat sheet used to have the answer, no idea where that has gone now though
16:21:38 <sorear> ndm: how do you feel about NASM (as a dependency/assembler syntax)
16:22:02 <ndm> sorear: the windows tool?
16:22:12 <sorear> netwide assembler
16:22:24 * sorear didn't know there was a windows tool by that name
16:22:30 <ndm> does it come with gcc?
16:22:38 <ndm> or a full gcc package etc.
16:22:44 <ndm> or can it be compiled with GHC?
16:22:48 <sorear> it's a very portable assembler (one one target but runs on anything)
16:22:49 <ndm> or something else similar?
16:22:55 <sorear> compiled with GCC
16:23:04 <ndm> if it compiles with gcc, thats a plus
16:23:14 <ndm> but whatever is the best tool for the job, really
16:23:30 <ndm> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html - 2.1.2
16:23:31 <lambdabot> Title: 2. Using the CVS repository
16:23:39 <sorear> not so much "the best tool for the job" as "the tool I've always used for this job"
16:24:01 <ndm> sorear: instructions on how to generate the necessary key, email it to me, and tomorrow i'll add you in, then scons send will work for you (if you have your key loaded)
16:24:07 <ndm> thats as good a reason as any
16:24:11 <sorear> haven't given gas enough time to learn it (and the nasm manual says it is much more programmer-friendly than gas)
16:24:36 * ndm takes a guess at what the gas manual says
16:25:14 <sorear> well, nasm is designed for programmers.  gas is designed for GCC.  not entirely overlapping niches.
16:25:28 * sorear installs the gas manual
16:27:43 <SamB> the gas manual doesn't say otherwise
16:27:45 <SamB> afaik
16:27:56 <SamB> but, who would know?
16:28:08 <sorear> wtf? binutils-doc is in MAIN!
16:28:11 <SamB> Here is a brief summary of how to invoke `as'.  For details, *note
16:28:11 <SamB> Command-Line Options: Invoking..
16:28:11 <SamB>      as [-a[cdhlns][=FILE]] [-D] [-defsym SYM=VAL]
16:28:11 <SamB>       [-f] [-gstabs] [-gstabs+] [-gdwarf2] [-help]
16:28:35 <SamB> thats pretty much the first thing in the manual
16:28:44 * sorear expects all gnu documentation to be in non-free
16:28:54 <siti> why?
16:28:55 <SamB> I don't think you are going to find any claims to user-friendliness in there
16:29:16 <SamB> siti: the GFDL isn't DFSG compliant
16:29:36 <siti> lol
16:29:45 <SamB> and presumably doesn't meet the Open Source definition, either
16:30:16 <SamB> apparantly, the stuff that is GNU's idea of Free Documentation is not Debian's idea of Free Software
16:31:01 <SamB> which, given GNU's ideas about free documentation, isn't particularly surprising
16:31:09 <siti> http://en.wikipedia.org/wiki/GNU_Free_Documentation_License#Criticism_of_the_GFDL
16:31:12 <lambdabot> http://tinyurl.com/6phpc
16:31:35 <wolverian> (stabbing dwarfs)++
16:31:43 <SamB> heh
16:32:14 <SamB> oh, its okay to use the GFDL as long as you haven't got any invariant sections
16:32:38 <SamB> that makes sense
16:32:39 <sorear> wolverian: nice try
16:32:43 <sorear> dwarfs)--
16:32:49 <sorear> stabbing_dwarfs++
16:32:55 <wolverian> not my fault it's not as smart as purl
16:33:09 <sorear> STABS vs DWARF debugging formats?
16:33:37 <SamB> since the invariant sections are the only trouble spot I remeber...
16:33:54 <beelsebob> sorear: I was under the impression that dwarf supported everything stabs did, and more
16:36:17 <sorear> I don't see anything in the GAS manual akin to nasm's -f bin
16:36:42 <sorear> which is a pretty big deal
16:36:53 <beelsebob> what does that do?
16:36:53 <SamB> sorear: you don't need it there
16:36:59 <SamB> use a linker script
16:37:06 <sorear> ayhi, build as an object file and linked, is 14KB
16:37:22 <sorear> ayhi, with a handmade elf header, is ~500b
16:37:34 <SamB> stripped it yet?
16:37:40 <sorear> (it's missing a lot of features now, like half the opcodes)
16:37:40 <SamB> anyway...
16:38:07 <SamB> read the ld manual
16:38:13 <ndm> sorear: that doesn't do module loading, i guess?
16:38:48 <sorear> ndm: I've made it to opcode 84/136, skipping over APPLY.
16:39:07 <sorear> ndm: ie a bytecode loader woulnd' even RUN yet
16:39:30 <sorear> (apply seems very nasty to write, I'm gonna have to spill at least three regs)
16:39:41 <SamB> sorear: do you copy?
16:40:10 <sorear> SamB: make an object file, then use a linker script to build my custom size-tuned ELF header?
16:40:20 <SamB> or maybe objcopy can do it
16:41:07 <ndm> sorear: so you can load from a .hbc file already?
16:41:07 * lispy wishes he had time these days to idle in #haskell, such good discussions
16:41:11 <SamB> basically, you'd use the ASM to write the elf header as usual, but it would just come out with an extra one...
16:42:06 <sorear> ndm: not even close...
16:42:33 <sorear> ndm: currently I have a hardcoded prog using custom opcodes to read a char, echo it, and segfault.
16:44:16 <siti> cool segfault :)
16:44:42 <SamB> I suppose you'd do objcopy -O binary doubleelf.o ./ayhi
16:44:58 <SamB> sorear: does that make any sense?
16:45:01 <sorear> yeah
16:45:08 <SamB> ... does it work?
16:45:35 <sorear> sounds like what I'd do for x86_64 when I'm forced to use gas :)
16:45:47 <bos> dons: ping
16:45:49 * sorear doesn't want to switch from Intel syntax
16:46:39 <dons> bos : pong
16:46:40 <ddarius> gas supports Intel syntax.
16:46:45 <SamB> what? there is no x86_64 NASM-alike?
16:46:52 * ddarius dislikes gas though.
16:46:56 <SamB> I thought YASM handled that or something
16:46:57 <sorear> it's not tagged in debian
16:47:14 <sorear> ddarius: so, should I switch to gas for ayhi?
16:47:21 <dons> ndm, you seem to have fixed at least two programs on the nobench :-)
16:47:30 <SamB> Description: modular assembler with multiple syntaxes support
16:47:30 <SamB>  Yasm is a complete rewrite of the NASM assembler. It supports multiple
16:47:30 <SamB>  assembler syntaxes (eg, NASM, GAS, etc.) in addition to multiple
16:47:30 <SamB>  output object formats (binary objects, COFF, Win32, ELF32, ELF64) and
16:47:31 <bos> dons: for fun, i've been measuring Binary performance over a network implementation of Chan i've written.
16:47:31 <SamB>  even multiple instruction sets (including AMD64). It also has an
16:47:33 <SamB>  optimiser module.
16:47:38 <ddarius> sorear: What's wrong with nasm?
16:47:56 <bos> i'm seeing about 220MB/sec of throughput, end to end.
16:48:01 <dons> whoa. nice.
16:48:10 <dons> is that fast enough?
16:48:23 <dons> (we've still not optimised the reader side fully yet..)
16:48:32 <sorear> ddarius: ndm is concerned about deps
16:48:42 <bos> it's 100% cpu-limited on the reader side, with 12KB messages.
16:48:55 <dons> ok. so we could improve that a bit
16:49:09 <ddarius> nasm is pretty lightweight.
16:49:12 <dons> is it fast enough for now?
16:49:48 * dons tries to imagine where  220MB/sec would be too slow
16:50:36 <SamB> sorear: nasm is perhaps less of a dependancy than gcc
16:50:38 <SamB> or gas
16:50:40 <xic> dons: over a network?
16:51:01 <bos> dons: no, that's a good number.
16:51:04 <sorear> ok, then, fear removed.
16:51:05 <hpaste>  dibblego pasted "How would I memoise this?" at http://hpaste.org/684
16:51:24 <dons> ok. if the reader becomes an issue, ping kolmodin and me, we can look into it some more
16:51:41 <siti> araujo: I think the problem was that make was automatically doing a parallel build because I have a dual core...
16:51:59 <SamB> sorear: if you are writing a program in x86 ASM, *don't* use gas please
16:52:04 <SamB> it is so ugly
16:52:40 <Olathe> Gas is explosive, too.
16:52:49 <bos> dons: pushing the message size up, i can get 462MB/sec
16:52:50 <siti> what about xeon?
16:52:59 <siti> and helium
16:53:22 <sorear> gaseous xeon is useless
16:53:29 <bos> oops, no i can't.
16:53:49 <sorear> xenon otoh...
16:53:57 <bos> 233 is more like it.
16:54:17 <bos> that's about 1/3 the speed of C code over this network.
16:54:26 <warmenhoven> is there a way to poll on multiple Handles without resorting to forkIO?
16:54:39 <sorear> no
16:54:43 <sorear> forkIO is *cheap*
16:54:51 <sorear> it uses select/poll for IO
16:55:06 <sorear> and N threads, where N is no larger than your processor count
16:55:39 <sorear> realisticly, if you were capable of writing a better scheduler I would have immediately recognized your name
16:55:51 <warmenhoven> heh.
16:56:13 <warmenhoven> i'm just trying to learn how to do networking in Haskell after having done it in c for seven years.
16:56:14 <dons> bos, that sounds about right
16:56:28 <dons> we get 1/3 .. 1/2 C for disk writes
16:56:32 <warmenhoven> i was sort of confused about not having select() available to me
16:56:49 <bos> dons: yep.
16:57:28 <bos> warmenhoven: it's possible to plumb in your own select code, but it's a pain in the painful place.
16:57:45 <bos> e.g. http://www.seas.upenn.edu/~lipeng/homepage/unify.html
16:57:46 <lambdabot> Title: Unifying events and threads
16:57:49 <dons> and if you're on linux, you can use the 'unify' lib for epoll
16:57:52 <dons> yeah that stuff :-)
16:57:53 <sorear> @botsncak
16:57:53 <sorear> LAG!
16:57:53 <lambdabot> :)
16:58:03 <dons> no lag!
16:58:49 <sorear> dibblego: http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Util.hs , grep for ^levenshtein
17:00:14 <dibblego> the 'Translated from an Erlang version by Fredrik Svensson and Adam Lindberg' version?
17:00:22 <dons> dibblego: but be careful, that's an algorithm!
17:00:29 <dons> dibblego: that's the efficient one
17:00:36 <dons> ?holp help
17:00:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:00:40 <dibblego> why is it String and not Eq a => a ?
17:00:47 <dons> no good reason, afaik
17:00:49 <dibblego> ok
17:01:04 <dons> other than that lambdabot doesn't tend to do levenshtein on [a] ;)
17:01:13 <dibblego> could it be used to backtrack and create a list of deltas?
17:01:27 <dons> so accumulate the edit changes as you go?
17:01:30 <dibblego> yes
17:01:34 <sorear> also check out the hpaste source, there's a diff in there
17:01:39 <dons> i think so. though there might be better algos there.
17:01:55 <dibblego> yes there are block move algorithms for it
17:02:01 <dibblego> but I just want to do a LCS one for now
17:02:04 <warmenhoven> ok. obviously i need to read more on how forkIO works. thanks for the help all.
17:02:10 <sorear> http://www.scannedinavian.com/~eric/hpaste/DiffHtml.hs
17:02:13 <dibblego> thanks sorear
17:02:54 * sorear wonders how many people thought hpaste's diff worked by system "diff -u"
17:03:12 <dons> not me.
17:03:19 <dons> though it probably should ;)
17:03:28 <dibblego> to get an edit list, I'd have to reverse each argument, then call the levenshtien function along the lists - would this recompute everything again?
17:04:42 <chessguy> > 8388608 * 2
17:04:43 <lambdabot>  16777216
17:05:56 <sorear> ndm: ok, I have .ssh/id_dsa{,.pub} - now what?
17:06:03 <sorear> just a couple binary files
17:06:09 <dibblego> they should be text
17:06:19 <dibblego> id_dsa should be chmod 600
17:06:31 <dibblego> ssh with pubkey auth?
17:06:59 <dibblego> s/text/pem3 text
17:07:46 <sorear> do I need to create a second set of keys for gpg?
17:08:01 <dibblego> I'm not sure
17:08:05 <sorear> dibblego: I don't distinguish opaque uuencoded text from opaque unencoded binary
17:08:42 <Olathe> Is there a decent Haskell compiler for Linux PPC ?
17:09:07 <sorear> ghc
17:09:27 <sorear> I'm pretty sure it supports linux ppc
17:09:46 <dons> sure does
17:09:57 <Olathe> I can only see Debian for PPC, but I'm using Yellowdog, which is like Red Hat.
17:10:15 <siti> gentoo has a ppc port too :D
17:10:19 <dons> just means no one built it. the same src is used though.
17:10:20 <sorear> Olathe: debian isn't binary only
17:10:29 <sorear> Olathe: s/debian/ghc/
17:10:38 <siti> lol
17:10:40 <sorear> Olathe: you can get the source code *shock awe*
17:10:45 <dons> so if possible, grab a powerpc binary from some other linux/ppc system, use that to bootstrap
17:10:48 <Olathe> I know, but the source download page says I need a working ghc.
17:10:54 <dons> right.
17:11:01 <siti> noooo
17:11:05 <siti> @we are all dead
17:11:15 <dons> you'll need a binary/powerpc ghc from say, debian or redhat?
17:11:19 <siti> @botsnack
17:11:23 <sorear> Olathe: you need GHC 5.04.  GHC 5.04 needs 4.something  .  4.x needs 3.x ... ... ... what does 0.29 need?
17:11:31 <lambdabot> :)
17:11:33 <dons> sorear: that's not helpful :-)
17:12:14 <dons> Olathe: so do you know how to take a binary from say, debian, and get it running on your yellowdog linux? (is that possible?)
17:13:22 <sorear> alien?
17:13:29 <sorear> debootstrap?
17:16:29 <sorear> ndm: how soon do you want ayhi in the tree? ASAP? as soon as it works?
17:20:15 <dons> ?where yhc-bugs
17:20:16 <lambdabot> I know nothing about yhc-bugs.
17:20:49 <sorear> <dons> ?where+ yhc-bugs http://code.google.com/p/yhc/issues/list
17:20:49 <sorear> <lambdabot> Done.
17:20:51 <lambdabot> Title: yhc - Google Code
17:20:54 <sorear> whoa
17:21:35 <sorear> dons, we really need to use a robust state backend :)
17:21:38 <dons> ?where+ yhc-bugs http://code.
17:21:39 <lambdabot> Done.
17:21:43 * sorear is envisioning lambdabot-happs
17:21:44 <dons> ?where+ yhc-bugs http://code.google.com/p/yhc/issues/list
17:21:44 <lambdabot> Done.
17:21:57 <dons> yeah, checkpointing should be *trivial* to add, given @flush
17:21:58 <stepcut> sorear: me too
17:21:58 <lambdabot> stepcut: You have 1 new message. '/msg lambdabot @messages' to read it.
17:22:14 <bd_> @help flush
17:22:15 <lambdabot> flush. flush state to disk
17:22:20 <sorear> > bitSize (0::Word)
17:22:21 <lambdabot>  32
17:22:24 <sorear> :(
17:22:52 <dons> you want amd64 bot eh?
17:22:58 <dons> ok. i've got most of the deps on the box now.
17:23:03 <dons> we can have a crack at it later
17:23:10 <sorear> bot builds in what, 10s? :)
17:23:17 <dons> hehe
17:23:22 <dons> need ghc -jN
17:23:23 <dons> ;)
17:23:40 <dons> maybe if I complain loudly enough to JaffaCake
17:24:20 <sorear> how about full parallelism in ghc with fifo scheduling policy
17:24:33 <sorear> same as before, until you add +RTS -N16 -RTS
17:24:45 <dons> yeah. i think there's a patch for that already
17:24:53 <dons> when the smp runtime was being tested
17:25:20 <dons> ndm, ok, your patch fixed two output errors on nobench, http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
17:25:21 <lambdabot> Title: nobench: Haskell implementation shootout
17:26:07 <sorear> why don't we have yhc/jhc/nhc98 on x86_64? guilt em some
17:26:16 <mwolak> multidimensional arrays are C-order, right? (as opposed to fortran order)
17:26:22 <sorear> ?where yhc-bugs --paranoia
17:26:23 <lambdabot> http://code.google.com/p/yhc/issues/list
17:26:27 <dons> i did use jhc, but everything broke
17:26:29 <dons> nhc won't work
17:26:32 <dons> and yhc needs scons ;)
17:26:41 <sorear> "guilt em some"
17:26:45 <dons> hbc doesn't have a code gen
17:26:50 <dons> so yeah, it would guilt em
17:27:00 <sorear> compile error | compile error | compile error | compile error
17:27:18 <dons> jhc is compiler error for some, runtime error for everything else
17:27:31 <dons> yhc is an option though
17:27:35 <dons> i should install scons
17:27:59 <sorear> ayhi will work perfectly assuming your os supports 32 bit code
17:28:03 <sorear> it doesn't even use libc
17:28:25 <sorear> but, it needs to work first :)
17:28:44 <dons> but i don't want to support 32 bit code!
17:30:15 <sorear> well the x86_64 supports a per-process 32-bit mode, so it is a very small and quite possibly non-conditional feature for an os to allow 32 bit binary loading
17:30:32 <sorear> everything else needs a 32 bit libc, which you can delete
17:31:37 <falconair_> it looks like the ByteString library only has a char8 data type, is there a way I can read write integers and floats (but not have to convert between text .. for best performance) ?
17:31:46 <sorear> nope
17:31:57 <dons> falconair_: Data.Binary
17:31:57 <sorear> we need to write that however
17:32:15 <dons> that's a layer over bytestrings supporting serialisation of arbtirary data types
17:32:20 <dons> sorear: no?
17:32:28 <sorear> I'm pretty sure String :: * -> * is on dons' todo list
17:32:33 <dons> ?where hackage
17:32:33 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
17:32:35 <sorear> oh, serialization!
17:32:44 <sorear> beh, I was thinking strings of em
17:32:58 <dons> falconair_: you can get Data.Binary from hackage
17:33:06 <allbery_b> char8 is the implementation.  you only care about that if you need unicode support.  Data.Binary handles serialization.
17:33:08 <dons> so you can say something liek:     encode pi
17:33:20 <dons> gives you a bytestrings, pi = decode s
17:33:22 <falconair_> cool, thanks dons, sorear ... is hackage  a repository for external libraries?
17:33:24 <dons> reads it back
17:33:30 <sorear> yeah
17:33:32 <sorear> like CPAN
17:33:32 <dons> falconair_: right. its our cpan
17:33:48 <falconair_> wow, hadn't heard of it until now, again thanks
17:35:53 <dons> building lambdabot on amd64x16 :-)
17:36:15 <dons> need:   hackage-get arrows
17:37:21 <dons> and you should be able to say:   cabal-add arrows-0.2.tar.gz
17:37:23 <sorear> woohoo, my first oleg reply
17:37:25 <dons> which does the unpacking and building
17:38:09 <dons> sorear: you got served ;)
17:38:13 <dons> oleg-style
17:38:55 <dons> but yeah, seems like $!! is needed for a lot of these (or a strict kind)
17:39:32 <dons> anyone remember what the cpp flag to hugs is?
17:40:37 <allbery_b> -F/path/to/cpp ?
17:40:49 <allbery_b> or maybe just -Fcpp
17:41:12 <dons> ah yes, i think that's it
17:42:25 <dons> cpphs-hugs is easier
17:45:58 <dons> lambdabot> version
17:45:58 <dons> lambdabot 4p512, GHC 6.6 (Linux x86_64 870)
17:45:59 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
17:46:00 <lambdabot> Title: Index of /~dons/code/lambdabot
17:46:04 <chessguy> holy hairballs
17:46:06 <chessguy> it works
17:46:13 <chessguy> !!!
17:47:16 <dons> amd64bot: @quit
17:47:25 <dons> i guess we want -N16
17:47:48 <sorear> what you can't change that at runtime? :)
17:47:51 <dons> and we have it :-)
17:47:54 <sorear> > bitSize (0::Word)
17:47:55 <amd64bot>  64
17:47:56 <lambdabot>  32
17:48:04 <dons> sweet
17:48:09 <sorear> dons++ dons++ dons++ HURRAY!
17:48:41 <dons> amd64bot: @version
17:48:42 <amd64bot> lambdabot 4p512, GHC 6.6 (Linux x86_64 870)
17:48:42 <amd64bot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
17:48:42 <lambdabot> Title: Index of /~dons/code/lambdabot
17:48:53 <dons> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 35
17:48:57 <amd64bot> Terminated
17:48:57 <lambdabot> Terminated
17:49:01 <dons> heh
17:49:08 <dons> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 30
17:49:10 <amd64bot>  1346269
17:49:10 <lambdabot>  1346269
17:49:14 <dons> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 34
17:49:18 <amd64bot>  9227465
17:49:18 <lambdabot>  9227465
17:49:34 <dons> ah, but the runplugs code isn't run with +RTS -N16!
17:49:46 <sorear> dons: restart with GHCRTS=-N16
17:49:47 * dons tweaks
17:49:50 <dons> yeah
17:49:52 <sorear> dons: envvar will inherit
17:49:53 <dons> in the env eh?
17:50:00 <dons> let's hope so anyway
17:50:03 <dons> amd64bot: @quit
17:51:17 * ddarius doesn't even want to know how many pages his new To Read list comprises.
17:52:48 <dons> hmm. Prelude.init: empty list if I set env GHCRTS
17:54:59 <falconair_> ok, i downloaded the Data.Binary package and installed it according to instruction, but I'm getting a weird library load error:
17:55:02 <hpaste>  falconair pasted "Data.Binary error" at http://hpaste.org/685
17:55:40 <dons> falconair_: missing --make
17:55:42 <dons> or -package binary
17:56:11 <falconair_> oh, i can't just include?  i have to do a -package binary when i use ghc to compile?
17:56:22 <dons> --make is better
17:56:23 <dons> but yes,
17:58:32 <sorear> any yhc bytecode experts awake?
17:59:28 <falconair_> done: oh, cool, thanks, so if i write out huge lists of numbers/strings, and i later want to process them (use them in list comprehensions or something) ... do those large files get optimization like mmap?  (I'm thinking of a mini-monetdb type database test here)
17:59:57 <dons> how large?
18:00:07 <dons> > 1G?
18:00:07 <lambdabot>  Parse error
18:00:19 <falconair_> let's say > 1G
18:00:32 <dons> well, they're lazy bytestrings, so it'll only pull in what you evaluate anyway
18:00:54 <dons> you could also consider using zlib or bzlib to 'compress . encode' and 'decode . decompress'
18:01:05 <dons> so yes, i think this is doable
18:01:15 <dons> you should be able to lazily read and process such data
18:01:19 <dons> as long as your careful
18:01:28 <dons> it should run in constant space
18:02:13 <falconair_> that solves a bunch of my problems
18:02:21 <dons> hopefully.
18:02:31 <dons> if you run in to any trouble, please consult me or dcoutts
18:02:45 <dons> since you should really be able to do this with lazy bytestrings, and get ~C like speed
18:03:22 <falconair_> so dons, i think you should write a books, not about haskell, but about GHC haskell, your 'wc -l' series of posts was very informative ... and i didn't have to think about monads :)
18:04:52 <xic> falconair_: where are those posts?
18:05:23 <falconair_> http://cgi.cse.unsw.edu.au/~dons/blog
18:05:23 <lambdabot> Title: Haskell hacking
18:09:10 <dons> falconair_: hmm. thanks for the encouragement.
18:09:30 <dons> i'm reasonably tempted to have a go at 'Practical (GHC) Haskell'
18:09:50 * wkh encourages dons to write stuff about using haskell in practical situations
18:09:53 <sorear> @ask ndm I assume it is illegal to pass something that might be an indirection to anything other than EVAL etc and APPLY?
18:09:54 <lambdabot> Consider it noted.
18:09:55 <falconair_> oh man, that would be awesome, make sure you read Practical O'Caml to learn what NOT to do
18:10:04 <dons> yeah, have done so :-)
18:10:10 <dibblego> is it really that bad?
18:10:10 <wkh> practical o'caml?
18:10:25 <dibblego> that book has had the worst review I've ever seen
18:10:32 <dons> it wouldn't be till at least the end of the year though. i've got to finish my thesis first
18:10:33 <sorear> @ask ndm When do you want me to push ayhi?  When it works?  ASAP?
18:10:34 <lambdabot> Consider it noted.
18:10:34 <wkh> what's so bad about it?
18:10:53 <dibblego> dunno, haven't read it - but nobody has said anything good about it that I've seen
18:11:06 <dibblego> wkh, http://blog.merjis.com/2006/11/08/practical-ocaml/
18:11:13 <lambdabot> Title: Merjis blog » Blog Archive » Practical OCaml
18:11:21 <falconair_> well, one of the amazon reviews was mine, it really is a terrible book: the sentence structure, the content ....
18:11:31 <wkh> a book with the title "practical ocaml" could talk about lots of stuff. for instance, there's quite a good set of FFI stubs for using LAPACK produced by people at St Janes Capital
18:11:39 <falconair_> any one can write a bad book, no problem there, but it seems there was no effort put into it
18:11:44 <Olathe> OK, I finally slapped around the .deb file and figured out how to unpack it.  What is package.conf.inplace and how do I get one ?
18:12:12 <dons> falconair_: yeah, i think you have to be right in the middel of the community and the current hacking to do it properly.
18:12:13 <dibblego> is there a .deb for GHC 6.6? I spent 3 hours compiling it yesterday
18:12:15 <dons> otherwise you just miss to much of the 'best practice'
18:12:43 <jcreigh_> the GHC in etch (testing) is 6.6
18:13:30 <ndm> sorear: whenever suits you
18:13:31 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:14:01 <sorear> ndm: do UNPACK, etc etc auto-force?
18:14:09 <chessguy> > negate 3
18:14:09 <ndm> sorear: the indirection restriction is reasonable, not sure if its true or not - but i assume, Tom is the only person who would know
18:14:10 <lambdabot>  -3
18:14:27 <sorear> I'm amazed at the quality of the bytecode docs ...  who wrote them?
18:14:44 <dons> ndm, i'm having a go at yhc on amd64
18:14:47 <dons> that should be ok, right?
18:14:55 <dons> ?where hackage
18:14:55 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
18:15:07 <ndm> dons: should be pretty perfect, Tom and Andrew both develop it on amd64
18:15:18 <ndm> 32 bit is a legacy arch for us :)
18:15:32 <dons> ok. we'll see what we shall see
18:15:36 <dons> any magic flags for 16 core builds?
18:15:42 <dons> scons -j16?
18:15:57 <ndm> sorear: send me hte public part of your key, whichever part that might be... - .pub i think
18:15:58 <sorear> ndm: who wrote the bytecode docs?
18:16:01 <ndm> dons: should do
18:16:04 <ndm> sorear: Tom
18:16:13 <sorear> ndm: oh well.  No nick, no karma :)
18:16:21 <ndm> tomshackell++
18:16:32 <dons> ndm, FilePath isn't on hackage?
18:16:35 <dons> ?where FilePath
18:16:36 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
18:16:41 <ndm> sorear: if there are any bits that are even slightly unclear, email tom and then update the docs
18:16:44 <sorear> ndm: I thought I already sent the pubkey?
18:16:48 <ndm> dons: no, i should get round to that
18:16:57 <ndm> sorear: just got upstairs, not checked emails - checked IRC first :)
18:17:32 <ndm> sorear, i'll install your key tomorrow
18:17:47 <ndm> (i need help from the guy sitting next to me)
18:19:53 <ndm> dons: i see no reason that scons shoudln't support multi-core compilation, i just have no idea how
18:19:58 <falconair_> btw, I think the haskell community needs to produce an editor like this: http://www.cs.cmu.edu/~marmalade/citrus.html (see the video) ... with all the type information haskell has, the programs should write themselvs
18:19:59 <lambdabot> Title: project marmalade
18:20:34 <glguy> Any guitar hero II players?
18:20:54 * glguy just finished Beat and the Harlot and Misilou on expert, woohoo!
18:21:27 <glguy> Beast*
18:21:35 <iron33> Anyone use Vim to edit there Haskell programs ?
18:21:53 * wkh stares at iron33 for a really long time
18:21:59 <wkh> we don't serve your kind here.
18:23:26 <Olathe> I think I finally got ghc working :D
18:23:37 <jcreigh> iron33: yeah, I do
18:24:00 <jcreigh> And I think dons uses vim, so I'm not the only heretic here. :)
18:24:05 <dons> yeah
18:24:10 <iron33> jcreigh : Which haskell mode do you recommend ? Especially since I went to use HARE
18:24:56 <iron33> Well actually I am using eclipse but refactoring is just to much of a useful feature so I thought I would give HARE a try
18:25:05 <iron33> went = want
18:25:38 <jcreigh> I'm just using the syntax highlighting that ships with vim, and this indent script: http://tokyoenvious.xrea.jp/vim/indent/haskell.vim
18:25:53 <jcreigh> probably not the ideal setup, but it's worked for me so far.
18:26:02 <siti> @where HARE
18:26:02 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
18:26:02 <jcreigh> dons: how do you have your vim setup?
18:26:06 * glguy uses the default vim mode
18:26:13 <glguy> with softtabstop=2
18:27:10 <dons> ndm, is type=release still the way to get a fast compiler?
18:27:17 <iron33> I see I was hoping to be able to run hugs and ghc inside Vim. Plus I least need good indentation support
18:28:06 <SamB> iron33: noone has seen such a thing
18:28:11 <SamB> as good indentation support
18:28:17 <dons> jcreigh: my .vimrc is here, and I use the 'typeof' program to insert types automagically
18:28:25 <Ulfalizer> iron33: it's pretty easy to create bindings that execute shell commands. i don't know if there's any explicit support (like compiler message parsing) for ghc in vim yet.
18:28:29 <jcreigh> dons: "here"?
18:28:32 <iron33> SamB : Eclipse is not bad actually
18:28:57 <dons> http://www.cse.unsw.edu.au/~dons/tmp/.vimrc
18:29:11 <dons> sorry, http://www.cse.unsw.edu.au/~dons/tmp/vimrc
18:30:48 <Ulfalizer> :nmap <F5> :!ghc %<CR>   , or however ghc is used.. i've mostly used hugs so far
18:31:22 <Ulfalizer> % is replaced by the file name of the active buffer
18:32:13 <jcreigh> iron33: when I'm working some something, I usually have the source open in gvim and a terminal open to the file in gvim. Make a change, save it, switch to terminal, :r to reload in ghci.
18:32:29 <iron33> My lack of knowledge of Haskell is only superceded by my ignorance of all things Vim I am only resrting to it since I haven't found the ideal enviroment yet
18:32:43 <Ulfalizer> yeah, that's the way i usually work as well
18:34:00 <Ulfalizer> iron33: just read through the first section of :he user-manual. you'll find 95% of what most people use regularly there.
18:34:01 <jcreigh> s/\<some\>/on/
18:34:53 <Ulfalizer> oh, and in case you're really new you might wanna look at "vimtutor" :)
18:35:01 <iron33> jcreigh : I am spoiled Java Eclipse, Small-Talker and Slime I need a good development environment
18:35:07 <jcreigh> iron33: also, once you get your bearings in vim, take a look through http://rayninfo.co.uk/vimtips.html for many "cool! I didn't know vim could do that!" tips.
18:35:09 <lambdabot> Title: Best of VIM Tips, gVIM's Key Features
18:37:32 <iron33> jcreigh : I will first I have to establish that vim can an all in one enviroment for Haskell
18:39:36 <dino-> typeof program?
18:40:27 <allbery_b> @where typeof
18:40:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/typeof/
18:40:55 <dino-> allbery_b, dons: thank you
18:46:46 <xic> jcreigh: best vim tip :q!
18:48:23 <dons> scons -j3 seems to work at least, ndm
18:48:54 * dons tries -j8
18:49:23 <dons> oh. ok. yhc built
18:49:25 <dons> that was fsat
18:49:33 <xic> does scons have native haskell support?
18:49:57 <dons> doubt it. the only project i know that uses scons is yhc
18:50:06 <dons> though it seems to work well for yhc
18:50:42 <dons> ok. what the hey, lets try -j12
18:50:59 <iron33> @where scons
18:51:00 <lambdabot> I know nothing about scons.
18:52:37 <siti> @google scons
18:52:39 <allbery_b> yet another failed make replacement
18:52:40 <lambdabot> http://www.scons.org/
18:52:40 <lambdabot> Title: SCons: A software construction tool
18:52:55 <ohmega> iron33: what's good about eclipse?
18:53:32 <ohmega> *with even ;)
18:54:54 <dons> ndm, good. getting reasonable numbers on amd64
18:54:59 <dons> yhc++
18:55:13 <dino-> I don't want to start an editor/IDE war here or anywhere. I don't care if people love Eclipse or something else. I just don't like to get treated like a problem at Eclipse-centric companies for preferring Vim.
18:55:18 <iron33> ohmega : It be easier to answer whats not good
18:55:31 <ohmega> ok, what's that then?
18:56:00 <iron33> ohmega: The memory it consumes but if your machine has a lot of ram then nothing
18:56:30 <ohmega> my experience with such tools is that if something doesn't work there is no way to figure out what's wrong since it's basically a black box.
18:57:16 <iron33> ohmega : Well if all you have is a simple text editor with syntax highlighting then there isn't anything to figure out I agree :)
18:57:24 * zbrown bows in favor of the great vim :)
18:58:29 <dibblego> my experience with anything associated with IBM is that it costs lots, does nothing and is written poorly
18:58:32 <Ulfalizer> iron33: i wouldn't call vim "simple" though. i use it for most of my development, even though i have a lot of experience with different IDEs.
18:58:53 <Ulfalizer> often it works quite well to use vim to edit source code and still use the IDE for building and debugging as well
19:00:07 <dons> ndm, interesting, yhc                  CompileError "\"yhc: GHC is buggy!yhc: GHC is buggy!\""
19:00:54 <dons> > realToFrac (7 :: CDouble) :: Double
19:00:56 <lambdabot>   Not in scope: type constructor or class `CDouble'
19:01:24 <dons> :t realToFrac (7 :: Foreign.C.Types.CDouble) :: Double
19:01:26 <lambdabot> Double :: Double
19:01:42 <iron33> Ulf: I am not down on Vim or Xemacs just sometimes I don't like to hack elisp to get my language mode to work in a "winduhs/cygwin" enviroment
19:04:47 <ohmega> Having to hack elisp is of course bad. Things should work. But if they for some reason don't work, it should ideally be possible to figure out what's going on too.
19:05:46 <dons> ndm, around?
19:06:44 <iron33>  ohmega: Eclipse has a plugin architecture and a good one, Just like Emacs has elisp just depends on what your use too. like many programmers make a living Coding in Java so figuring out Eclipse isn't hard for me
19:07:36 <iron33> ohmega : As much as I wish it wasn't the case my knowledge of Java is much much greater then my knowledge of lisp
19:07:55 <iron33> Simple because I work in it everyday
19:15:43 * iron33 thinks I shouldn't use the J word in here everyone has gone quiet
19:15:54 <ohmega> :)
19:16:02 <chessguy> @quote java
19:16:02 <lambdabot> shapr says: [on causing trouble in #java] I told a java newbie to use a parser monad...
19:16:06 <ohmega> In fact.. I am writing java code.
19:16:14 * ohmega suffers
19:16:36 <chessguy> @quote java
19:16:36 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
19:16:36 * iron33 feels ohmega pain
19:16:51 <SamB> @quote java
19:16:52 <lambdabot> shapr says: [on causing trouble in #java] I told a java newbie to use a parser monad...
19:17:03 <ohmega> Haven't they heard of JParsec? :)
19:17:29 <iron33> ohmega : Have you tried any of the functional programming libs for java like JFP
19:17:32 <SamB> iirc, someone was asking about a Java parser and he suggested something that came with Parsec
19:17:57 <iron33> I am going to use it one day although I will probably take flak in code review
19:18:20 <SamB> wear a flak jacket?
19:18:35 <iron33> Samb: Good call
19:18:49 <ohmega> iron33: interesting approach ;)
19:20:41 <iron33> I want to go TFP especailly to hear the lecture on how JFP was designed doubt I will get authorization from my top boss code named wife
19:22:08 <iron33> I figure JFP and FC++ are my best bet to get paid to do FP
19:24:19 * iron33 tries to stop saying the J and C words people are getting offended
19:24:22 <ddarius> If C# had TCO and (local) type inference it would be really nice.
19:24:40 <siti> it has the var keyword doesn't?
19:24:46 <dons> this is what we pay sigfpe for:   http://programming.reddit.com/info/16rm1/comments
19:24:48 <lambdabot> Title: Implementing monadic IO in C: taint your side effects! (reddit.com)
19:24:57 <SamB> hmm, if you just say JFP I think "journal of functional programming"
19:25:52 <wkh> see, C is just as extensible as any other language.
19:25:58 <ddarius> siti: C# 3.0?
19:26:08 <siti> I don't know, I don't use c#
19:26:09 * ddarius is only really familiar with 2.0
19:26:12 <siti> I just read it somewherhe
19:26:27 <dons> wkh, the only problem is there's no enforcement of the no-IO requirement
19:26:40 <dons> I guess that makes C more flexible!
19:26:44 <SamB> dons: heh
19:26:47 <siti> problem is, is all these hybrid functional + whatever will become as ugly as c++ has :(
19:26:55 <dons> its like unsafePerformIO by default
19:26:57 <wkh> dons: like garbage collection, that is a pedantic propellerhead criticism taht doesn't matter
19:27:00 <SamB> there is almost no way to do anything without doing IO or mutating some global state
19:27:19 <iron33> SamB: Oh sorry your right
19:27:25 <wkh> you need to be more pragmatic. i write code with buffer overflows and core dumps. can't you see i'm busy being productive?
19:27:35 * kpreid notices someone in need of help: http://undefined.com/ia/2007/02/26/woke-up-this-morning-had-a-blue-moon-in-my-eyes/
19:27:38 <lambdabot> Title: Indefinite Articles » Woke up this morning, had a blue moon in my eyes, http://tinyurl.com/2ezafd
19:27:39 <dons> oh, sorry! yes, better get back to work
19:27:42 <kpreid> (with Haskell, yes)
19:27:49 <wkh> i actually _ship_ code. it causes security holes that cost customers billions of dollars a year but i ship it!
19:27:56 <wkh> and god dammit that's what matters
19:28:08 <dons> that's true. keep up the good work!
19:28:10 <SamB> I send it out in paper airplanes
19:28:19 <wkh> will do, egghead.
19:28:22 <iron33> wkh : Have to pay the bills :)
19:28:24 <dons> if it wasn't for code like that, we wouldn't need haskell!
19:28:53 <wkh> why am i not suing for royalties?
19:29:08 <wkh> i am clearly failing to optimally monetize the situation
19:29:12 <dons> kpreid: ok. yes. that guy needs help
19:29:14 <dons> is he here?
19:29:22 <kpreid> not a clue
19:29:31 <kpreid> just appeared in my feeds
19:30:02 <kpreid> the first is the "REPL doesn't take definitions" thing, and the second is WinHugs-specific which I don't know about
19:33:51 <dons> ok i replied.
19:34:43 <dons> i wonder how many people give up because hugs behaves the way it does
19:35:06 <dons> i think we should deprecate hugs now
19:35:19 <dons> since anyone with hugs has to go and install ghc on day 3 anyway
19:36:17 <kpreid> hm, moderated comments? I don't see your response
19:36:19 <dino-> Just curious, what is this Open command from within winhugs for if not to navigate to a file?
19:36:29 <dons> @tell ndm can you work out what this guy has done wrong with the 'Open' command, http://undefined.com/ia/2007/02/26/woke-up-this-morning-had-a-blue-moon-in-my-eyes/
19:36:30 <lambdabot> Consider it noted.
19:36:42 <dons> kpreid: must be moderated.
19:36:53 <dons> kpreid: it says 'No comments' for me, and displays my 1 comment
19:36:54 <glguy> dino-: it is to load the definitions
19:37:53 <dino-> I see. Not the same thing as :load
19:38:09 <glguy> ?seen SyntaxNinja
19:38:09 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 20m 25s ago, and .
19:39:19 <sorear> hello
19:39:33 <dino-> sorear: hi
19:39:57 <dons> ?bugs
19:39:58 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:40:15 <dibblego> glguy, at http://www.scannedinavian.com/~eric/hpaste/DiffHtml.hs -- what is (memo!) ?
19:40:31 <glguy> dibblego: a slice
19:40:37 <iron33> Newb Haskell syntax question in do syntax I always thought you had to have a return statement as the last statement but it seems you ca also just construct a monad as the last statement too is this correct ?
19:40:49 <glguy> dibblego: aka: (!) memo
19:41:22 <dibblego> ah right
19:41:43 <dino-> iron33: Not exactly. return puts a value into the monad. The do block must evaluate to some monadic type. So sometimes you need to use return to wrap something.
19:41:54 <glguy> iron33: return doesn't end a do-block, it's just one thing that can
19:41:58 <glguy> :t return
19:42:00 <ddarius> avocados? joke?
19:42:01 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:42:09 <sorear> left operator section
19:42:09 <sorear> (memo!) = (!) memo
19:42:09 <sorear> @ty (Data.Array.!)
19:42:09 <sorear> @botsnack
19:42:09 <sorear> *drumroll*
19:42:12 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
19:42:12 <lambdabot> :)
19:42:13 <allbery_b> note thst return is *not* a transfer of control, it just wraps something in a monad
19:43:06 <iron33> so return (Just 5) is the same as Just 5 ?
19:43:07 <glguy> > do { return 1; return 2; return 3; return 4; [5] }
19:43:08 <lambdabot>  [5]
19:43:10 <ddarius> @src mapM_
19:43:11 <lambdabot> mapM_ f as = sequence_ (map f as)
19:43:22 <ddarius> @src sequence
19:43:22 <lambdabot> sequence ms = foldr k (return []) ms
19:43:22 <lambdabot>     where
19:43:22 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:43:28 <allbery_b> no, return (Just 5) encloses "Just 5" in the monad
19:43:28 <ddarius> bah
19:43:36 <allbery_b> whatever monad you're currently working with
19:43:39 <dino-> > Just 5 >>= return
19:43:41 <lambdabot>  Just 5
19:43:49 <allbery_b> > return 5 :: Maybe Int
19:43:50 <lambdabot>  Just 5
19:44:05 <allbery_b> > return 5 :: [Int]
19:44:07 <lambdabot>  [5]
19:44:12 <dino-> do { x <- Just 5; return x; }
19:44:17 <dino-> > do { x <- Just 5; return x; }
19:44:19 <lambdabot>  Just 5
19:44:43 <allbery_b> > return 5 :: Either String Int -- otherwise known as MonadError
19:44:44 <lambdabot>  Right 5
19:45:09 <allbery_b> > return 5 :: IO Int -- returns a 5 wrapped in an IO action
19:45:11 <lambdabot>  <IO Int>
19:45:28 <allbery_b> no magic involved
19:45:37 <chessguy> > return 5 :: IO ()
19:45:38 <lambdabot>   add an instance declaration for (Num ())
19:46:11 <iron33> I think I understand the final value in the do notation must be a monad so you use return ( non moand ) to wrap it in a monad or just use a monad constructor Just 5 or [5] since a list is a monad
19:46:31 <allbery_b> right.  or invoke some function which already returns a monadic value
19:46:42 <dino-> Which describes the print functions.
19:46:44 <dino-> :t print
19:46:47 <lambdabot> forall a. (Show a) => a -> IO ()
19:46:52 <dino-> :t putStr
19:46:55 <allbery_b> (so, you can end something in the IO monad with a functiion like putStrLn which returns IO ()
19:46:55 <lambdabot> String -> IO ()
19:47:34 <allbery_b> you can of course use the monadic constructor directly but it's considered bad style
19:47:42 <iron33> Of course the mnad return must type check
19:48:04 <iron33> great a little further on my haskell journey
19:48:14 <allbery_b> one of the nice things about monads is that if you use the monad operations (>>=, join, return, etc.) you can switch the monad you're using more easily
19:48:18 <iron33> thx all
19:49:09 <allbery_b> so if you're using the Maybe monad to deal with something that might fail, and later you want an error message, you can easily switch to MonadError.  or if you decide you need multiple return values with backtracking you can swap out the Maybe for a list
19:49:22 <icarroll> lambdabot ?pl (a->b) -> (a,a) -> (b,b)
19:49:47 <allbery_b> with minimal changes to your existing code --- ideally none, if you used the generic monad interface correctly
19:49:58 <icarroll> lambdabot @pl (a -> b) -> (a,a) -> (b,b)
19:50:26 <allbery_b> 1. no need fo rthe "lmabdabot" prefix (but if you use it it needs a colon after it)
19:50:26 <sorear> icarroll: join(***)
19:50:28 <iron33> does Haskell 98 have a standard Monad than handles backtracking
19:50:33 <allbery_b> 2. @pl doesn't take types
19:50:38 <mauke> iron33: []
19:50:48 <sorear> > join (***) (+2) (10,20)
19:50:50 <lambdabot>  (12,22)
19:50:51 <allbery_b> @hoogle (a->b) -> (a,a) -> (b,b)
19:50:51 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:50:58 <allbery_b> unuseful :)
19:51:18 <allbery_b> @ty join (***)
19:51:21 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
19:51:26 <icarroll> thanks
19:51:33 <allbery_b> lambdabot: @bot
19:51:33 <lambdabot> :)
19:51:49 <sorear> @bsnack
19:51:49 <lambdabot> :)
19:51:54 <iron33> mauke so list support backtracking ?
19:51:57 <dino-> sorear: Is that the arrow (***) ?
19:51:58 <allbery_b> (that form's only useful if for some reason there are multiple lambdabots in channel, such as when dons was testing earlier)
19:52:00 <mauke> well, kind of
19:52:24 <mauke> it's just multiple values, but as long as you don't look at them they're not computed
19:52:26 <sorear> dino-: no, it's the arrow (->) . (***) isn't even a type, let alone properly kinded.
19:52:41 <icarroll> @hoogle join
19:52:42 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
19:52:43 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
19:52:43 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
19:53:03 <dino-> sorear: I meant is that the (***) function of arrows.
19:53:03 <sorear> icarroll: in this context ((->) monad), join f x = f x x
19:53:04 <mauke> @pl \f x -> f x x
19:53:04 <lambdabot> join
19:53:07 <sorear> dino-: yeah
19:53:47 <icarroll> @hoogle (***)
19:53:48 <lambdabot> Did you mean: (***)
19:53:49 <lambdabot> Prelude.undefined :: a
19:53:49 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:53:59 <sorear> @type (Control.Arrow.***)
19:54:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:54:03 <sorear> @src Arrow
19:54:04 <lambdabot> class Arrow a where
19:54:04 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:54:04 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:54:04 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:54:04 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:54:06 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:54:06 <allbery_b> @index (***)
19:54:08 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:54:10 <lambdabot> Control.Arrow
19:54:35 <sorear> @src (->) (***)
19:54:36 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
19:54:59 <iron33> mauke : Thats lazy eval backtracking is something you use in search problems mostly like your searching thorugh a tree and then you bbackup to search another branch. Languages like Prolog do this by default a very useful feature
19:55:29 <allbery_b> lazy evaluation in the list monad has similar effects
19:56:44 <iron33> Hmm not sure that I see how lazy eval would work like back tracking but I am an FP newb
19:57:05 <sorear> @goo list of successes
19:57:08 <lambdabot> http://sbir.nasa.gov/SBIR/success.htm
19:57:08 <lambdabot> Title: NASA SBIR and STTR - Success Story Gateway
19:57:12 <sorear> ^^^ IIIRC it's in there
19:57:14 <mauke> lazy evaluation turns breadth first into depth first
19:57:16 <sorear> er, :)
19:57:26 <sorear> @goo how to replace failure by a list of successes
19:57:29 <lambdabot> http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=5288
19:57:30 <lambdabot> Title: How to replace failure by a list of successes
19:57:50 * ddarius doesn't like the list monad for non-determinism.
19:58:41 <iron33> mauke :  breadth first or depth first search both use backtracking
19:59:32 <mauke> that doesn't sound right
20:01:51 <slowriot> > ?Data.Map.alter
20:01:51 <lambdabot>  Parse error
20:01:59 <iron33> mauke : I may not be a Haskell guru but I took an AI graduate level course and know all about AI search problems bfs and dfs and Prolog
20:02:08 <sorear> > typeOf Data.Map.alter
20:02:09 <lambdabot>   Not in scope: `Data.Map.alter'
20:02:14 <sorear> > typeOf M.alter
20:02:15 <lambdabot>  Add a type signature
20:02:21 <glguy> iterative-deepening depth first search??
20:04:14 <iron33> glguy : iterative deeping is basically the same as dfs except tjat you limit the max deepth to certain number if your depth limit is one then it becomes breadth first search
20:04:21 <slowriot> sorear: Why can't I get lambdabot to display alter's documentation?
20:04:47 <glguy> iron33: I'm aware :)
20:05:14 <iron33> glguy : Ok I mis interpreted your quesion mark
20:05:36 <glguy> best of both worlds at only twice the cost of depth first search to the correct level
20:06:23 <icarroll> @hoogle alter
20:06:24 <lambdabot> System.Win32.DLL.lOAD_WITH_ALTERED_SEARCH_PATH :: LoadLibraryFlags
20:06:42 <icarroll> @hoogle Data.Map.alter
20:06:43 <lambdabot> No matches, try a more general search
20:06:56 <sorear> slowriot: lambdabot does'nt do docs.  only types and (sometimes) source code.
20:06:56 <sorear> you can ask it for a pointer to the online haddocks however
20:06:56 <sorear> @docs Data.Map
20:06:56 <sorear> ...
20:06:56 <sorear> @botsnack
20:06:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
20:06:57 <lambdabot> :)
20:06:59 <sorear> *drumroll*
20:07:01 * sorear kicks his TCP stack
20:07:03 <sorear> apologies for the unquestionably duplicate answer
20:07:03 <iron33> glguy : Most intersting search problem require heuristic / informed search methods
20:07:13 <slowriot> okay
20:07:15 <slowriot> thanks
20:07:29 <sorear> lag--
20:07:58 <slowriot> It seems like the docs often reference named arguments without defining them.
20:08:26 <sorear> they are named ... but often only in the source :(
20:08:35 <slowriot> ah
20:08:55 <sorear> the stdlibs aren't THAT pointless :)
20:11:52 <sorear> @users
20:11:52 <lambdabot> Maximum users seen in #haskell: 312, currently: 304 (97.4%), active: 28 (9.2%)
20:12:05 <sorear> > bitSize (0::Word)
20:12:06 <lambdabot>  32
20:12:10 <dibblego> something wrong with that maximum
20:12:12 <sorear> @uptime
20:12:13 <lambdabot> uptime: 3h 1m 15s, longest uptime: 2d 17h 27m 21s
20:12:28 <sorear> bot needs happs
20:12:29 <SamB> perhaps documentation tools should pick up on this?
20:12:35 <SamB> names for arguments...
20:13:13 <dibblego> Feb 27 09:37:06 <lambdabot>     Maximum users seen in #haskell: 336, currently: 315 (93.8%), active: 53 (16.8%)
20:13:20 <dibblego> > 336 < 312
20:13:22 <lambdabot>  False
20:14:11 <sorear> @flush
20:14:22 <ddarius> > max 336 312
20:14:24 <lambdabot>  336
20:14:41 <sorear> @src max
20:14:42 <lambdabot> max x y = if x <= y then y else x
20:15:43 <sorear> @where yhc-bugs
20:15:44 <lambdabot> http://code.google.com/p/yhc/issues/list
20:15:54 <dons> ?bug
20:15:54 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:28:02 <mlh> @src nub
20:28:02 <lambdabot> nub = nubBy (==)
20:28:06 <slowriot> say I want to alter two different keys in a map. Should I give the intermediate map (with one key altered) a name using let, or is there a less awkward way to do this?
20:28:10 <mlh> @src nubBy
20:28:10 <lambdabot> nubBy eq []             =  []
20:28:10 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:30:51 <sorear> M.alter k1 f1 . M.alter k2 f2 $ myMap
20:31:59 <glguy> Â‰"The more i hear about orcas, the more i want to build a bunker....have you ever seen them beach themselves so they can catch baby sealions sitting on the beach sand?"
20:32:15 <glguy> It wasn't but yesterday that I thought the same thing w.r.t. orcas and bunkers"
20:32:20 <glguy> -"
20:32:33 <sorear> what's \211?
20:33:37 <mauke> U+00D3 (0xc3 0x93): LATIN CAPITAL LETTER O WITH ACUTE [Ã“]
20:34:24 <allbery_b> hm, I see U+0089 CHARACTER TABULATION WITH JUSTIFICATION
20:36:47 <allbery_b> I'm guessing you're seeing the octal code(s) for the UTF8, which my app says is \302\211
20:38:30 <allbery_b> (actually I see a square containing "0089" but that made it easy to cut and paste into a unicode search dialog...)
20:38:44 <sorear> guy> \211"Th
20:38:46 <sorear> erc
20:39:04 <allbery_b> so it stripped the first byte, or maybe just the high bit on it
20:39:24 <allbery_b> hm, no, stripping high bit would have killed the \211 too
20:39:30 <glguy> ?bot
20:39:31 <lambdabot> :)
20:40:02 <sorear> M-: (following-char) says that \211 was octal
20:40:23 <allbery_b> yeh.  so your client ate the \302
20:45:41 <hpaste>  slowriot pasted "fix this horrible code" at http://hpaste.org/686
20:46:24 <allbery_b> doesn' surprise me much; I see that maps to uppercase A-hat --- which I see when people paste UTF8-encoded text containing characters that map to ISO8859/1, you get the stray A-hat, so I suspect they just strip it and hope it's valid ISO8859-1
20:46:57 <slowriot> giving the lambda a name could shrink the code a little bit
20:47:25 <allbery_b> useless use of "do" on the first line
20:47:37 <allbery_b> (and the where can be outdented quite a bit)
20:49:20 <slowriot> yeah, I'll get rid of the do
20:50:48 <slowriot> when I outdent the where, do you think I should put hikeEdges' 1 1 down one line at the same indentation level?
20:51:03 <slowriot> (down one line from its original place, same indentation as where)
20:52:19 <slowriot> I will, it seems like the right thing to od
20:52:27 <slowriot> do
20:52:51 <hpaste>  sorear annotated "fix this horrible code" with "use Functors to shrink cases" at http://hpaste.org/686#a1
20:53:37 <ddarius> @type maybeToList
20:53:39 <lambdabot> forall a. Maybe a -> [a]
20:53:49 <hpaste>  allbery_b annotated "fix this horrible code" with "better?" at http://hpaste.org/686#a2
20:54:14 <allbery_b> hm, that works too
20:54:17 <hpaste>  sorear annotated "fix this horrible code" with "reindent" at http://hpaste.org/686#a3
20:55:06 <ddarius> Get rid of those superfluous parens while you're at it.
20:55:40 <lispy> and clean your room! ;)
20:55:55 <hpaste>  sorear annotated "fix this horrible code" with "munge allbery's slightly" at http://hpaste.org/686#a4
20:56:12 <slowriot> much better
20:56:17 <allbery_b> was just doing that :)
20:56:51 <ddarius> @type Data.Map.alter
20:56:53 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
20:58:08 <ddarius> The original code type checks or does it use a different Map library.
20:59:55 <slowriot> I think it type checks. It uses Data.Map. I'm kind of a newb.
21:00:42 <allbery_b> looks like you return a list instead of a Maybe to me\
21:00:55 * dons starts tossing around -h2G like candies
21:01:04 <slowriot> It should return a Maybe []
21:01:11 <slowriot> a Maybe list
21:01:24 <lispy> -h2G?
21:01:31 <allbery_b> then you need Just (x : lst)
21:01:37 <dons> 2G heap ;)
21:01:40 <lispy> whoa
21:01:43 <lispy> dons: cool!
21:01:49 <allbery_b> but, I think the fmap handles that for you
21:01:58 <lispy> dons: is this using that multicore machine?
21:01:59 <dons> you mised amd64bot earlier today
21:02:01 <dons> yeah
21:02:04 <lispy> nice
21:02:05 <dons> http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
21:02:06 <lambdabot> Title: nobench: Haskell implementation shootout
21:02:31 <slowriot> allbery_b: ah, I see
21:02:37 <hpaste>  sorear annotated "fix this horrible code" with "refactor recursion pattern (hope this works!!)" at http://hpaste.org/686#a5
21:03:09 <lispy> dons: why all the run-time errors on the ghci stuff?
21:03:26 <lispy> and why was calendar faster in ghci...that seems wrong
21:03:30 <dons> i see 3 runtime errors , all due to stack overflows
21:03:35 <hpaste>  sorear annotated "fix this horrible code" with "fix scope error" at http://hpaste.org/686#a6
21:03:39 <dons> yes, that is wrong. ghc beats ghci easiley with -Onot
21:03:39 <lispy> ah, that makes some sense
21:04:02 <lispy> dons: so this is a version of the shootout just between haskell implemenations?
21:04:03 <sorear> lispy: #1179
21:04:07 <sorear> yeah
21:04:21 <dons> lispy: basically
21:04:32 <lispy> sorear: #1179? sorry, i'm not understanding
21:04:34 <dons> giving yhi a 2G heap seems to help it
21:04:41 <dons> is that a bug? ;)
21:05:01 <hpaste>  sorear annotated "fix this horrible code" with "as a foldr" at http://hpaste.org/686#a7
21:05:10 <sorear> bug number
21:05:24 <sorear> and submitter dons, I'd expect he'd know about it
21:05:28 <lispy> sorear: oh the ghci run-time errors have a bug # already?
21:05:33 <lispy> okay
21:05:33 <dibblego> is const a the same as \_ -> a for all a?
21:05:36 <sorear> #1179: 20x slow down with -O or -O2
21:05:36 <sorear> -------------------------+--------------------------------------------------
21:05:36 <sorear>     Reporter:  dons      |       Owner:
21:05:52 <slowriot> can't find munge in the index
21:05:55 <slowriot> what's munge?
21:05:57 <dons> i'm just walking through the results identifying the real bugs
21:06:01 <mauke> @src const
21:06:01 <lambdabot> const x _ = x
21:06:03 <lispy> :t \a _ -> a
21:06:05 <lambdabot> forall t t1. t -> t1 -> t
21:06:19 <sorear> slowriot: a local function, you'll see it is defined in a whereblock
21:06:27 <slowriot> oh, heh, oops
21:06:37 <allbery_b> @djinn a -> b -> a
21:06:38 <lambdabot> f a _ = a
21:07:07 <sorear> you may need to import Ix, I used one of its functions
21:07:08 <allbery_b> munge was just abstracting away the duplicate code
21:07:40 <slowriot> ah, okay... yeah, I was thinking about making a munge function
21:08:38 <allbery_b> any time I find myself repeating something that's obviously a near duplicate like that, I refactor it into a separate function.  (haskell makes that much easier than C/perl/etc.  yay!)
21:08:40 <sorear> so in this one code block, I managed to define a HOF, use foldr, use a function from Ix, and use fmap.
21:08:58 <sorear> I expect it is NOT newbie frienly
21:09:45 <allbery_b> as you and glguy noticed, I'm, still pretty bad at recognizing cases where I could use fmap :)
21:10:54 <allbery_b> although admittedly if I'd realized that the result of what I called munge' needed to also be Just ... I'd've probably realized t really wanted some higher order foo and gotten to fmap :)
21:12:00 <glguy> allbery_b: i said you are bad with fmap?
21:12:33 <allbery_b> you yell at me every time I do x >>= return . f :)
21:13:13 <sorear> I usually just use x >>$ f
21:13:57 <allbery_b> which is liftM aka fmap
21:14:44 <sorear> actually the longer I use haskell the more I think >>= shouldn't exist
21:14:50 <sorear> we should have =<< only
21:15:02 <glguy> i rarely use >>= over =<<
21:17:36 <hpaste>  sorear annotated "fix this horrible code" with "shorten a bitmore" at http://hpaste.org/686#a8
21:17:45 <sorear> @quote melt
21:17:46 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
21:17:55 <slowriot> sorear: why call "tail" ?
21:17:55 <allbery_b> hm, I should check if the ghci problem I'm seeing is known or if I'm not cleaning sufficiently
21:18:54 <sorear> slowriot: you are looping througth the points (0,0) to (n,n) lexicographically, but you start at (1,1).  so I take all but the first of lexicographic (1,0) to (n,n).
21:19:17 <sorear> slowriot: I suspect this may be a bug in the original code, exposed by higher-order-ness
21:20:30 <allbery_b> don't see it.  *sigh*
21:20:53 <slowriot> http://www.spoj.pl/problems/HIKE/
21:20:57 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem HIKE
21:21:53 <hpaste>  allbery_b pasted "ghci 6.7 unhappy on ppc - broken, or me being dumb?" at http://hpaste.org/687
21:22:12 <slowriot> oh
21:22:17 <slowriot> yeah
21:22:40 <slowriot> It the zeroes should be replaced with ones
21:23:04 <sorear> > range ((1,1),(4,4)) -- so the xys should be like this?
21:23:06 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
21:23:09 <slowriot> yep
21:24:11 <bdash> allbery_b: looks kinda broken
21:24:25 <slowriot> thanks a lot for the help. this has been very educational
21:24:31 <hpaste>  sorear annotated "fix this horrible code" with "fix bug" at http://hpaste.org/686#a9
21:24:46 <allbery_b> well, I've had failures that were due to my not doing enough of a cleanup in my tree first
21:25:01 <sorear> allbery_b: you need more RAM! :P
21:25:02 <allbery_b> was wondering if this was a known "oh, you need to zap *mumble* first"
21:25:16 <sorear> failed to allocate 10MB
21:25:27 <sorear> are you trying to run ghci on a palmpilot?
21:25:56 * sorear actually smells something rather closer to arena corruption
21:26:00 <bdash> sorear: it's trying to call realloc on a pointer that wasn't allocated, it's not out of RAM
21:26:28 <sorear>  malloc: failed on request for 10331948 bytes; message: ocAllocateJumpIslands  <---  oh, I meant ths one.
21:26:35 <allbery_b> yeh, it's blowing chunks after the bad free
21:26:47 <bdash> sorear: right, that's a result of the previous messages
21:26:47 <allbery_b> so the second one is essentially just fallout
21:27:57 <hpaste>  allbery_b annotated "ghci 6.7 unhappy on ppc - broken, or me being dumb?" with "buildscript, fwiw, in case I'm missing a cleanup step" at http://hpaste.org/687#a1
21:30:27 <dons> @tell ndm when formerly yhc would say "module not found Control.Monad.ST", now it reports "GHC is buggy!". Is that the expected behaviour
21:30:28 <lambdabot> Consider it noted.
21:32:00 <dons> > let _1 = x in _1
21:32:01 <lambdabot>   Not in scope: `x'
21:32:15 <dons> > let _1 = 7 in _1
21:32:17 <lambdabot>  7
21:32:34 <sorear> @pl \fix -> let a = 2 in a
21:32:35 <lambdabot> ($ const 2)
21:33:01 <sorear> what's the _1 thing?
21:33:07 <dons> valid haskell I think
21:33:08 <sorear> that the new v?
21:33:13 <dons> that yhc barfs on ;)
21:33:37 <sorear> reportabug! :)
21:33:56 * dons is doing so
21:33:59 <dons> #3 for the day
21:34:22 <sorear> suddenly remined of this, and I can't recall if I told you - there's a name capture bug in @pl
21:34:26 <sorear> @pl \fix -> let a = 2 in a
21:34:27 <lambdabot> ($ const 2)
21:34:31 <sorear> @pl \foo -> let a = 2 in a
21:34:32 <lambdabot> const 2
21:39:05 <allbery_b> hmmm.  setting a breakpoint in szone_error doesn't actually accomplish anything
21:40:14 * ddarius is liking this Adam Dunkel's kid.
21:41:40 <ddarius> I've run across him before, but he's done some more stuff in the past few years.
21:42:32 <allbery_b> I wonder if this is some platform strangeness
21:50:51 <allbery_b> oh well, bug reported, along with full build & selftest log
21:51:01 <allbery_b> although I seem to fail at trac's wikiformatting :)
21:51:28 <sorear> I do too :)
21:51:43 <sorear> #1151 was mangled badly by me
21:59:44 <ddarius> http://www.sics.se/~adam/miniweb/
21:59:46 <lambdabot> Title: Miniweb - TCP/IP stack and web server in 30 bytes
22:30:03 * ddarius needs to make a persistent tree-like document viewer.
22:38:59 <icarroll> @hoogle average
22:39:00 <lambdabot> No matches found
22:39:04 <icarroll> @hoogle avg
22:39:05 <lambdabot> No matches found
22:40:05 <mauke> @type liftM2 (/) sum (fromIntegral . length)
22:40:07 <lambdabot> forall b. (Fractional b) => [b] -> b
22:52:22 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . group2 $ xs where group2 [] = []; group2 (x:y:xs) = (x,y):xs in bitRev [1..16]
22:52:23 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t)
22:52:23 <lambdabot>       Expec...
22:52:52 <ddarius> @type unzip
22:52:54 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
22:53:00 <ddarius> @type uncurry (++)
22:53:03 <lambdabot> forall a. ([a], [a]) -> [a]
22:53:27 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . group2 $ xs where group2 [] = []; group2 (x:y:xs) = (x,y):group2 xs in bitRev [1..16]
22:53:28 <lambdabot>  [1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]
22:53:43 <ddarius> That was it.
22:54:06 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . group2 $ xs where group2 [] = []; group2 (x:y:xs) = (x,y):group2 xs in bitRev [0..15]
22:54:07 <lambdabot>  [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
23:08:22 <sjanssen> dons: is hs-plugins 1.0-rc0 the version that works with GHC 6.6?
23:10:41 <ClaudiusMaximus> sjanssen: last time i tried hsplugins-1.0-rc0 with ghc-6.6 it didn't work much, that was in mid-january...
23:10:46 <ddarius> @version
23:10:47 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
23:10:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:12:12 <sjanssen> ClaudiusMaximus: okay, must be the darcs version that is 6.6 compatible
23:17:30 <dons> sjanssen: nope, darcs version
23:17:38 <dons> also seems to work on 64 bit , which is nice
23:17:42 <dons> :-)
23:17:55 <sjanssen> dons: gonna release it any time soon? :)
23:18:10 <dons> hmm. good idea.
23:19:08 * dons notes the incestuous reddit link to sigfpe's reddit comment in #3
23:19:44 <Korollary> which?
23:19:54 <dons> http://programming.reddit.com/info/16rm1/comments
23:19:56 <lambdabot> Title: Implementing monadic IO in C: taint your side effects! (reddit.com)
23:21:02 <dons> Korollary: thought up a bitter comment to add to the page, yet?   ;-)
23:22:11 <Korollary> It's an utterly stupid question.
23:22:23 <Korollary> I have no good reddit karma anyway.
23:23:04 <dons> why's that?
23:23:14 <sjanssen> Korollary: the "Please show me monads in C." is a stupid question?
23:23:21 <dons> ah, no sbmissions I guess?
23:24:18 <dons> I find sigfpe's C example fairly straightforward. I hope it helps some people get a concrete grip on how simple these thingamies are
23:25:53 <dons> sjanssen: i installed dwm 3.7 today. very nice after using dwm 1.9 for a few months
23:26:07 <dons> and i note the code base has gone down a bit
23:26:29 <dons> sjanssen: so... where's our repo :-)
23:26:47 <dons> 500 lines of haskell should surely do it. .. its almost a shootout problem ;)
23:28:32 <sjanssen> 500 lines not including the extra xlib bindings should be doable
23:29:03 <dons> right.
23:29:17 <sjanssen> dons: it is taking longer than I anticipated, but I'm getting close to a point where I can share it
23:29:44 <dons> woo!
23:30:04 <sjanssen> of course if Sven Panne comes up with xcb bindings, I'd be a happy man :)
23:30:07 <dons> i'm keen. the niceness of dwm indicates we can do very well, with very little code
23:31:12 <sjanssen> dwm is really nice -- you can practically use it as a "howto write an x11 window manager" guide
23:31:20 <sjanssen> the code is that simple and small
23:31:24 <Korollary> Oh no, more window managers.
23:31:27 <jtokle> you're working on a wm in haskell?
23:32:03 <sjanssen> jtokle: yeah
23:32:19 <jtokle> that's funny -- i've just been playing with configuring wmii via haskell
23:32:24 <dons> its step #3 in the take over the world transitional phase
23:32:35 <dons> jtokle: oh! i've a config script for that
23:32:35 <jtokle> what step have we been stuck on?
23:32:46 <dons> the main wmii driver  in haskell, you mean?
23:33:08 <jtokle> dons: yeah
23:33:44 <jtokle> i've got the basic functionality; it's been a learning experience
23:33:46 <dons> i used this with wmii 4 for a few weeks, http://www.cse.unsw.edu.au/~dons/tmp/key-handler.hs
23:33:52 <dons> then switched to dwm
23:34:50 <dons> it was a complete rewrite of wmiirc, but doesn't do anything useful besides :-)
23:35:30 <dons> i think its maybe more profitable to rewrite dwm , rather than the wmii driver since there's a real advantage if we can get the code down to say, 1/4 the code base, and strongly typed
23:36:04 <jtokle> that's what i was going for
23:36:48 <dons> sjanssen: and i've been tossing these ideas around for a year or so. hopefully we can get something done this year
23:36:59 <dons> once a basic core is done, the project should just drive itself
23:37:12 <sjanssen> dons: yes, sometimes C takes it's toll on dwm's beauty
23:37:31 <sjanssen> for example, all the code dwm uses to keep a simple linked list of windows is a bit ridiculous
23:37:50 <sjanssen> C doesn't have Data.Sequence ;)
23:37:51 <jtokle> sounds cool -- i'd love to take a look at it once you've got something running
23:37:53 <dons> right. data structures and list processing
23:38:25 <dons> we should be able to then think hard about ensuring correctness, imo
23:38:53 <dons> it would make a great honours thesis project :-)
23:38:59 <dons> but all our students want to hack on Frag instead
23:39:12 * dons *shrugs*
23:39:34 <sjanssen> ha, "proved correct" would be a really nice bullet point for a WM
23:40:49 <dons> well, that might be a bit hard ;) but we could QuickCheck a pure core. that's one thing. and state properties of it.
23:41:00 <dons> hmm. almost the bare bones of a haskell workshop paper in fact
23:41:08 <dons> a bit like the halfs filesystem demo
23:41:42 <dons> combinators for specifying window layout would be fun
23:42:29 <sjanssen> yeah, I've thought about: data Layout = Stack [Window] | Float [(Position, Window)] | SplitHoriz Layout Layout ...
23:42:52 <dons> right. there's pretty printer combinators to be had
23:46:56 <fuzan> Are there any prevailent encryption libraries providing (sha1) ?
23:47:16 <sjanssen> @where crypto
23:47:16 <lambdabot> http://www.haskell.org/crypto
23:47:31 <fuzan> hmm, how come that doesn't pop up when googling sha1 haskell :(
23:48:24 <sjanssen> fuzan: that webpage is really dry on keywords
23:48:53 <fuzan> makes sense!
23:49:11 <dons> is crypto on hackage?
23:49:13 <dons> ?where hackage
23:49:14 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
23:49:43 <sjanssen> indeed
23:53:04 <ttmrichter> Would anybody mind looking over a blog entry and critiquing it for me?
23:53:32 <dons> of course!
23:53:50 <dons> just view #haskell as a multi-headed blog checking server
23:54:49 <osfameron> like a distributed monkey cluster, with screeching simians at the ready to look at blogs and fling poo at them
23:58:14 <ttmrichter> OK, dons has convinced me.  http://snakeratpig.blogspot.com/2007/02/hmt0-what-fudge-is-monad.html
23:58:17 <lambdabot> Title: Snake, Rat, Pig: HMT0: What the Fudge is a Monad?, http://tinyurl.com/ytffmm
23:58:29 * ttmrichter blinks.
23:58:36 <ttmrichter> OK, lambdabot can be pretty scary sometimes.
23:58:38 <dons> so, everyone, dive in an comment!
23:59:06 <ttmrichter> I look forward to being smeared with faeces.
23:59:22 <ttmrichter> I'd prefer the feedback on the comments page if possible -- it lets me edit when I have the time.
23:59:27 <dons> btw, did you know that SPJ has suggested monads be called "warm fuzzy things"
23:59:39 <dons> as a better marketing term :)
23:59:46 <ttmrichter> BTW, dons?  Your reddit thing about how many different ways monads can be used?  Nice.
