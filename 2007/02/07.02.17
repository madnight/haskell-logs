00:00:01 <abz> right.
00:00:08 <dons> i.e. ask on haskell-cafe@ about how to do symbol reflection with SYB techiques
00:00:08 <coffee-mug> well, I did something else
00:00:09 <sorear> hmm, it's not the page I wanted, anyway.
00:00:23 <dons> state the problem you have, and try to get kosmikus or oleg or someone to solve it :-)
00:00:37 <dons> since that'll drive development
00:00:47 <coffee-mug> I basically parsed the source code using the standard parser, generated a symbol table mapping, and merged it back into the code using dons' library
00:00:51 <skew> Sounds like you're trying to do something around the intersection of global variables and reflection - not the best supported stuff.
00:00:55 <coffee-mug> or actually I didn't use don's library, just the parser
00:01:34 <coffee-mug> yeah, this stuff isn't so well supported
00:01:37 <dons> so you wrote a preprocessor?
00:01:42 <dons> that's how I would have done it
00:01:45 <coffee-mug> dons: yep
00:01:57 <abz> dons, sorear: wrt to the soc page hahahha I see now.
00:02:46 <coffee-mug> in fact
00:02:47 <coffee-mug> http://sources.defmacro.org/weblocks/src/Weblocks/Scripts/Transformer.hs
00:02:49 <lambdabot> http://tinyurl.com/3bgq5b
00:02:54 <coffee-mug> this is the monstrosity I wrote
00:03:14 <gmh33> hmm.. I wonder how keen a lot of haskellers are to make web apps in haskell
00:03:22 <coffee-mug> to take a file, grab all functions that start with "on", create a symbol table for them, and merge the result into a generated file
00:03:48 <dons> gmh33, there's some, notably at chalmers
00:03:56 <dons> i.e. bringert has written half the web infrastructure.
00:04:04 <dons> and one of the commerical haskell ventures is a web app, happs
00:04:07 <gmh33> dons: what about projects like links?
00:04:15 <dons> so there's interest, and its growing.
00:04:26 <dons> i guess that's peripherally prat of the haskell world too, yeah
00:04:27 <gmh33> dons: nifty :)
00:04:31 <dons> xml is pretty hot too
00:04:43 <coffee-mug> wow that code is monsterous now that I look at it
00:04:52 <sorear> must sleep, bye
00:04:57 <dons> since transforming ASTs is really the first niche haskell had
00:05:03 <dons> and xml is all about transforming ASTs
00:05:27 <gmh33> dons: I do a lot of web based programming for work, the projects that really interest _me_ are ones that reduce the amount of language switching
00:05:45 <gmh33> like links, haXe and hop
00:05:52 <dons> ok. so everything can be done in the one language?
00:05:52 <gmh33> something similar in haskell would be neat :)
00:06:03 <dons> that's interesting. you want everything you need in a box?
00:06:22 <gmh33> dons: it makes it easier at times
00:06:30 <dons> yeah, sounds very reasonable
00:06:48 <gmh33> dons: that last statement wasn't sarcastic at all :P
00:07:19 <bos> http://paste.lisp.org/display/36975
00:07:36 <coffee-mug> all right
00:07:41 <coffee-mug> time to sleep
00:07:52 <coffee-mug> night everyone
00:07:59 <abz> gmh33: what languages are you currently using for your web base programming?
00:08:10 <bos> that paste missed the crucial lines: i produced that output using "runghc Setup.lhs rpm"
00:08:20 <Korollary> rpm?
00:08:29 <gmh33> at work, I'm forced to use coldfusion/sql for the back end junk, and hand code the rest
00:08:30 <gmh33> :/
00:08:46 <bos> i'm hacking cabal to build RPM packages. it's about 90% done now.
00:08:59 <gmh33> in a mix of html/css/javascript/VB/etc
00:09:17 <dons> nasty
00:09:33 <abz> gmh33: right and have your try Happs, HSP or WASH?
00:09:46 <abz> have you tried
00:09:52 <dons> so you could have a single expressive language with html/css/javascript all as EDSLs
00:10:12 <abz> and haskelldb
00:10:23 <gmh33> dons: probably couldn't convince my coworks in that direction
00:10:35 <gmh33> it's a big nasty government contract that's been around for quite a few years now
00:10:39 <dons> right.
00:10:59 <gmh33> I've only been around for the last 7 months and will be leaving in 2 months
00:13:17 <Korollary> ah. neat.
00:13:19 <Korollary> er
00:13:22 <Korollary> bos: ah, neat.
00:14:37 <gmh33> oh well, g'night all
00:25:12 <beschmi> newsham: xemacs/cygwin mostly works for me now. i haven't added the translate-to/from-cygwin everywhere
00:45:02 <dcoutts> @tell fnord123 did you get your issue with gtk2hs and the glade tutorial figured out?
00:45:02 <lambdabot> Consider it noted.
00:48:51 <dmead> dcoutts: is gtk2hs intended to be written by hand
00:48:58 <dmead> or should we always use glade?
00:49:10 <dcoutts> dmead, I'd use glade whenever I can
00:49:21 <dcoutts> because it's easier to design GUIs visually
00:49:27 <dmead> right
00:49:37 <dmead> i was just trying to do something trivial
00:49:44 <dmead> and its hard to tell whats really going on
00:49:56 <ibid> i found glade irritating when i tried it
00:50:02 <ibid> was much easier to just write the code :)
00:50:06 <dmead> yea
00:50:18 <ibid> (i've done this in both c and haskell now)
00:50:19 <dcoutts> ibid, the glade GUI itself isn't that great, though glade 3.x is a big improvement
00:50:58 <dmead> gtk requires one container per window right?
00:51:24 <dcoutts> dmead, well a window itself is a one-place container
00:51:48 <dcoutts> so if you want to add multiple things to a window then you'll need some sub-container
00:51:58 <araujo> ibid, you are not the only one :-P
00:52:25 <dmead> dcoutts: last night i tried in vain to replicate a gui i had written in java
00:52:26 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/provergui.png
00:52:36 <dmead> but to no avail
00:53:39 <dcoutts> dmead, looks like a VBox with 2 rows, the first of which has an HBox with an Entry and a Button, and the second row has a Entry
00:54:14 <dmead> ahh
00:54:33 <dcoutts> both row bits are set to *not* expand to fill the space available
00:55:33 <dmead> Hmm
00:55:46 <dmead> gtk makes my head hurt
00:56:00 <dmead> i'm so used to retard guis with swing
00:57:22 <dcoutts> dmead, the model is quite similar to swing, with the containers/layout-managers
00:57:46 <dcoutts> swing has horazontal, vertical and table layout managers
00:57:51 <dmead> it's the bit about one child per container that gets me
00:58:10 <dmead> seems like it adds complexity
00:58:18 <dcoutts> dmead, it's not one child per container
00:58:36 <dmead> o0
00:58:56 <dcoutts> there are one or two widgets which are single place containers (like windows, buttons)
00:59:23 <dcoutts> but there are vertical, horizontal and table containers
00:59:30 <dmead> ah
01:06:41 <dmead> yar
01:06:44 <dmead> this is a bit confusing
01:06:45 <dmead> :s
01:32:54 <newsham> ?hoogle (a -> b) -> (a -> a -> a) -> (b -> b -> b)
01:32:55 <lambdabot> No matches, try a more general search
01:33:17 <ulfdoz> Am i the only one, having connection timeouts via ipv6?
01:36:59 <dmead> dcoutts: i see whats going on now
01:37:05 <dmead> very nice job
01:37:08 <dcoutts> good good
01:37:42 <dmead> i just think code inside a do construct should resemble java or something
01:38:01 <dmead> probably gonna write an article or something on it
01:38:11 <dmead> so i can get trashed by the community
01:38:23 <newsham> dmead: does it matter what it resembles?
01:38:33 <dmead> yes
01:38:38 <dmead> i can say that for certain
01:38:46 <newsham> sounds like religeon.
01:38:54 <dmead> well
01:39:00 <dmead> i know that it matters what it resembles
01:39:14 <dmead> but what it should actually look like is what people have different ideas about
01:39:23 <newsham> "java bad, therefore things that resemble java bad"
01:39:29 <dmead> :p
01:39:35 <dmead> well, C family syntax
01:39:43 <dmead> with control structures and whatnot
01:39:48 <newsham> well, thats kinda my point.. syntax is only skin deep.
01:39:50 <dmead> JUST at the top level after main
01:39:55 <newsham> superficial argument.
01:39:59 <dmead> i'm not saying make it an impure language
01:40:00 <dmead> hehe
01:40:52 <dibblego> if syntax were only skin deep, you could argue that Java is a pure functional language
01:41:08 <newsham> i couldnt argue that.
01:41:16 <newsham> maybe you're better at arguing than me :)
01:41:22 <dmead> lol
01:41:24 <dmead> :P
01:41:37 <dibblego> typically, the 'syntax' is missing a few IO declarations
01:41:59 <dmead> all i'm sayin is a regular imperative syntax is more useful at the top level
01:42:03 <Kaji> Good evening. Holy crap, are there a lot of people on this chan.
01:42:16 <dibblego> ?users
01:42:16 * dmead waves
01:42:16 <lambdabot> Maximum users seen in #haskell: 307, currently: 276 (89.9%), active: 22 (8.0%)
01:42:26 <newsham> i think things like first class functions, nested functions (and closures), lambdas, non-strict, pure, etc..
01:42:41 <newsham> those are the things that distinguish languages
01:42:51 <newsham> anyone can learn a new syntax in short order
01:43:06 <Kaji> I don't mean to interrupt any convo ongoing, but is anyone here really knowledgable about WinHugs? In specific, I'd love to know a quick and dirty way to time how long a function takes to run.
01:44:13 <dmead> it's really fast
01:44:16 <dmead> hugs
01:44:17 <dmead> i mean
01:44:20 <dmead> in general is really fast
01:44:32 <dmead> but useless
01:44:35 <dmead> you might want to use ghci
01:44:35 <Kaji> Hehehe.
01:44:49 <dmead> hugs is useful for learning haskell
01:44:56 <dmead> and banging out functions to the compiler
01:45:00 <Kaji> Well, what I'm doing is useless, so that's a perfect match. Yes, I've been told that ghci is the only way to go for real performance code.
01:45:09 <dmead> to see where you screwed up, etc
01:45:35 <dmead> are you stuck in an infinite recursion perhaps?
01:45:36 <Kaji> But I'm not doing anything that needs to be fast; I'm just doing this for kicks, seeing how long different things take, comparatively, under any interpreter.
01:45:44 <dmead> ah
01:45:46 <newsham> i like how nobody answers the question but insteads tries to pick apart the question
01:45:57 <Kaji> No, no infinite recursion, I have a very well defined upper bound.
01:46:11 <dmead> newsham: i did say really fast...
01:46:17 <Kaji> I'm working through a tutorial, one of the first things was "isPrime".
01:46:24 <Kaji> So you can guess what I'm doing.
01:46:27 <dmead> ah
01:46:36 <dmead> typing in a really huge number  i suppose
01:47:00 <Kaji> Actually, WinHugs seems to illegal op for numbers much larger than 2^48.
01:47:03 * Kaji shrugs.
01:47:04 <newsham> have you checked the hugs manual?
01:47:08 <newsham> might have some profiling support
01:47:13 <Kaji> Ah, duh... no, I will go do that. Thanks!
01:47:45 <newsham> dmead: the question was hot to time something, not what the time was :)
01:47:53 <dmead> ;p
01:48:11 <dmead> Kaji: if you paste your code and input i'll try running it
01:48:24 <dmead> ?paste
01:48:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:48:30 <Kaji> Sure, though that won't really answer my question, since I'm curious about MY computer.
01:48:43 <Kaji> isqrt :: Integral a => a -> a
01:48:43 <Kaji> isqrt = floor . sqrt . fromIntegral
01:48:43 <Kaji> hasFactors :: Integer i => i -> i -> i -> Bool
01:48:43 <Kaji> hasFactors sqrtn n m | m > sqrtn = False | n `mod` m == 0 = True | True = hasFactors sqrtn n (m+2)
01:48:47 <Kaji> isPrime :: Integer -> Bool
01:48:49 <Kaji> isPrime x | x < 4 = True
01:48:52 <newsham> ?paste
01:48:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:49:15 <Kaji> I'm not sure if I can get away with an Integer as opposed to an Integral on isqrt, but since it only runs once I don't care.
01:49:32 <dons> Kaji: do you have the lastest hugs?
01:49:50 <dons> there were some illegal-op related bugs fixed in the Nov 2006 release
01:49:56 <dons> (though, yeah, i'd still use ghc or ghci)
01:50:03 <Kaji> I'm not sure; I downloaded it a couple of days ago. Sept 2006 version?
01:50:08 * Kaji goes to look...
01:50:18 <Kaji> -- Hugs Version Sep 2006
01:50:21 <dons> yeah, that'd be it
01:50:33 <dons> if you have a reproducible failure case, please report it to hugs bugs
01:50:46 <dons> let me find the bug reporting url
01:51:16 * Kaji thinks it's http://hackage.haskell.org/trac/hugs
01:51:18 <newsham> i dont think he's reporting a bug (unless i missed something)
01:51:18 <lambdabot> Title: Hugs - Trac
01:51:32 <dons> Kaji: yep, thats it
01:51:39 <newsham> he just wants to know how to time his code
01:51:51 <dons> newsham: an illegal instruction error sure sounds like a bug to me.
01:52:06 <dons> Hugs.Base> :set +s
01:52:06 <dons> Hugs.Base> 1+2
01:52:06 <dons> 3
01:52:06 <dons> (28 reductions, 64 cells)
01:52:06 <newsham> oh, i missed that
01:52:16 <dons> is also useful for timign things, if you don't use the cputime function
01:52:38 * Kaji tries to find a large enough number that it will guarantee an illegal op... I think 2^65 - 59 was one that did it every time.
01:52:43 <dons> Prelude> :set +s
01:52:44 <dons> Prelude> 1+2
01:52:44 <dons> 3
01:52:44 <dons> (0.04 secs, 2254096 bytes)
01:52:46 <dons> in ghci
01:53:00 <Kaji> Wow, that's nice. I may have to get ghci after all.
01:53:14 <newsham> ghc is where its at :)
01:53:19 <dons> the reductions one is hugs, the secs/bytes is ghci
01:53:53 <dons> and if you ever want to compile the code and ship it to some one :-) or use any libraries...
01:53:56 <dons> then ghc is a better option
01:54:09 <Kaji> Ye gods, keep newbie me the heck away from the libs.
01:54:24 <newsham> libs are your friend
01:54:37 <Kaji> Hm, doesn't like "hasFactors :: Integer i => i -> i -> i -> Bool
01:54:45 <Kaji> Is Integer not a class?
01:55:06 <dons> nope. its a data type
01:55:14 <dons> for unbounded integers
01:55:17 <dons> you're thinking of Num ?
01:55:20 <dons> ?instances Num
01:55:22 <Kaji> Okay, have to type it out every time then...
01:55:22 <lambdabot> Double, Float, Int, Integer
01:55:29 <dons> ?instances Integral
01:55:31 <lambdabot> Int, Integer
01:55:47 <dons> the compiler will infer the most general type, btw.
01:56:03 <Kaji> Cool, thanks.
01:57:06 <dmead> oof
01:57:08 <Kaji> My scrollback has gone, tell me about this "systime"... uh, function? again.
01:57:22 <dmead> couldn't match [Char] against IO String
01:57:40 <dmead> whats the function that patches this up?
01:57:47 <dmead> unsafePerformIO>
01:57:48 <dmead> ?
01:57:52 <newsham> dmead: one is an IO and one isnt.
01:57:58 <newsham> whats your code?
01:58:13 <dmead> some gtk2hs stuff
01:58:37 <newsham> ?type liftM
01:58:37 <dmead> trying to wire up my prover function to a button
01:58:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:58:55 * Kaji ... 2^64 - 59 = 18446744073709551557
01:59:01 <Kaji> Illegal op in a second or two...
01:59:04 * Kaji goes to the tracker.
01:59:31 <newsham> > liftM (++"foo") getContents
01:59:32 <lambdabot>  <IO [Char]>
01:59:38 <newsham> ?type getContents
01:59:41 <lambdabot> IO String
01:59:47 <newsham> ?type (++"foo")
01:59:50 <lambdabot> [Char] -> [Char]
01:59:57 <Kaji> ?Instances Num
01:59:58 <lambdabot> Double, Float, Int, Integer
02:00:08 <Kaji> Hm...
02:00:34 <Kaji> ?Instances Ord
02:00:35 <newsham> dmead: is that anything like what you want to do?
02:00:35 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
02:01:01 <dmead> ahh
02:01:02 <dmead> yes
02:01:03 <dmead> i think so
02:01:10 <dons> > 2^64 - 59
02:01:12 <lambdabot>  18446744073709551557
02:01:28 <newsham> you could also use do-notation.
02:01:33 <dons> Kaji: that would make a reasonable bug report
02:01:44 <dons> though it works with my hugs,
02:01:45 <dons> Hugs.Base> 2^64 - 59
02:01:45 <Kaji> Right, let me do that...
02:01:45 <dons> 18446744073709551557
02:01:57 <Kaji> Well, actually, I can generate the number too, oddly enough.
02:02:04 <dmead> wheres liftm?
02:02:06 <Kaji> It when I try and isPrime it that it blows up.
02:02:07 <dmead> what package
02:02:13 <newsham> Control.Monad
02:02:18 <dmead> ah
02:02:19 <dons> can you paste tehe code so I can test it?
02:02:22 <dons> ?paste <--
02:02:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:02:26 <Kaji> isqrt :: Integral a => a -> a
02:02:26 <Kaji> isqrt = floor . sqrt . fromIntegral
02:02:26 <Kaji> hasFactors :: Integer -> Integer -> Integer -> Bool
02:02:27 <Kaji> hasFactors sqrtn n m | m > sqrtn = False
02:02:27 <Kaji>                      | n `mod` m == 0 = True
02:02:29 <Kaji>                      | True = hasFactors sqrtn n (m+2)
02:02:32 <Kaji> isPrime :: Integer -> Bool
02:02:35 <Kaji> isPrime x | x < 4 = True
02:02:37 <Kaji>         | x `mod` 2 == 0 = False
02:02:40 <Kaji>         | True = not(hasFactors (isqrt x) x 3)
02:03:21 <newsham> kaji doesnt get ?paste
02:03:31 <Kaji> No I don't. Tell me about it. (G)
02:03:35 <dmead> ?paste
02:03:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:03:42 <dmead> put your code in a webform
02:03:44 <dmead> press submit
02:03:47 <dmead> and we can see it
02:03:57 <dons> Kaji: and how do I run it to reproduce?
02:04:01 <dmead> so you don't have to paste in the channel
02:04:14 <hpaste>  Kaji pasted "isPrime" at http://hpaste.org/523
02:04:57 <dmead> ?type liftM
02:05:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:05:06 <newsham> ?src liftM
02:05:06 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:05:35 <newsham> (looks like java?)
02:05:39 <Kaji> Run as "isPrime (2^64 - 59)" or "isPrime 18446744073709551557"
02:06:03 <Kaji> Platform is Win98SE, WinHugs Sept 2006 version.
02:06:27 <Kaji> 512 megs of ram, if that matters.
02:06:31 <hpaste>  dons annotated "isPrime" with "shorter" at http://hpaste.org/523#a1
02:06:32 <Kaji> P2 850 MHz.
02:06:59 <Kaji> No, wait... P3. I think.
02:07:09 <newsham> 850 seems a bit fast for p2 :)
02:07:14 <Kaji> Yeah...
02:07:39 <dons> ok. works for me
02:07:45 <dons> Main> isPrime 18446744073709551557
02:07:45 <dons> True
02:07:56 <dons> on openbsd. so you'll have to report the OS version
02:08:29 * Kaji nods.
02:09:32 * Kaji looks at dons's shorter code, "Is isPrime calling hasFactors and I just can't tell?"
02:10:03 <dons> ah no. the original code you pasted didn't either :/
02:10:04 <dons> oops
02:10:13 <dons> ~ah my fault
02:10:16 <dons>  I forgot the 3rd case :D
02:10:24 <dons> when copy'n'pasting
02:10:59 <Kaji> Should isPrime look like " ... || ... || not(hasFactors(etc))" ?
02:11:13 <dons> nah, if you've got 3 cases may as well use guards
02:12:31 <hpaste>  augustss annotated "isPrime" with "Using qsrt is slooooow" at http://hpaste.org/523#a2
02:13:38 <dons> yeah
02:16:08 <augustss> actually, for very large numbers the sqrt will be faster
02:16:42 <Kaji> Totally. Doing m*m every iteration is a killer.
02:17:05 <dons> though you're not going to be using hugs if you care about large number speed ;)
02:17:13 <augustss> Kaji: but not for numbers in the range where you want to use this algorithm
02:17:20 <dmead> alright
02:17:26 <Kaji> It's that C programmer blood, I have to write everything optimal as I know how.
02:17:29 <Kaji> Bad habit.
02:17:32 <dmead> i've got a function returning an IO String
02:17:37 <skew> what range is that anyway?
02:17:40 <dmead> that needs to be converted to a [Char]
02:17:54 <dmead> is this where liftM works?
02:17:54 <dons> dmead: so in the function that calls your code:   do s <- myFun
02:17:59 <dcoutts> dmead, us do notation
02:18:01 <Kaji> skew: Since I'm using WinHugs, my limit seems to be about 15-17 digits. About 2^48
02:18:07 <augustss> Kaji: sqrt is a little less costly in C since you convert to/from int, not Integer
02:18:08 <skew> don't you want to switch over to something like Miler-Rabin if you start getting to really big numbers?
02:18:09 <dons> dmead: nope, do notation. assign the result of the action to a variable, in a do block, in the calling code
02:18:42 <dmead> aahh
02:18:44 <dmead> paste time
02:18:45 <newsham> dmead doesnt like do-notation because its like java.
02:18:53 <augustss> Kaji: you could save a lot by only testing divisibility by primes rather than all odd numbers
02:19:02 <Kaji> Yeah, this is a VERY naive algorithm.
02:19:08 <Kaji> I'm so new that I haven't learned to pass lists yet!
02:19:18 <augustss> Kaji: aha! :)
02:19:20 <Kaji> Or else this would have been a seive of erastosthenes days ago.
02:19:29 <dmead> i don't like it because it's like another language all it's own
02:19:43 <dmead> ?paste
02:19:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:20:06 <newsham> dmead: the intent of "IO" is that you dont ever convert "IO x" to "x"
02:20:28 <dons> dmead: you got your code hooked into gtk2hs yet?
02:20:41 <dons> if not, ping dcoutts, he's the gtk2hs maintainer. so might have some clues
02:20:45 <dmead> yea
02:20:54 * Kaji ponders if doing the old "take log, divide by 2, antilog" trick to get a sqrt would make isqrt faster. Well, I only call it once anyway, so what the hell...
02:20:55 <dcoutts> @arr
02:20:55 <lambdabot> Yeh scurvy dog...
02:20:57 <dmead> yep, he helped me out a bit
02:21:03 <dmead> this problem is more about types
02:21:14 <newsham> dmead: you construct a new IO action that makes use of other IO results.
02:21:14 <dmead> i've grasped out the gtk bindings work
02:21:27 <newsham> using do-blocks or (>>=) to group together actions
02:22:35 <hpaste>  dmead pasted "type problem" at http://hpaste.org/524
02:22:36 <newsham> kaji: if you're really worried about sqrt, you can skip it for small numbers
02:22:40 <dmead> there
02:22:41 <newsham> or make a cheap approximation
02:22:41 <Kaji> When you're doing guards, what's the reason to use "| otherwise" as opposed to "| True" ?
02:23:02 <Kaji> What's a cheap approximation for sqrt?
02:23:07 <dmead> with a click event on the button, it should take the first entry's contents
02:23:12 <dons> Kaji: its idiomatic to use 'otherwise'
02:23:12 <dmead> run it through the prover
02:23:20 <dmead> and put the output in the second entry box
02:23:20 <Kaji> Oh, okay.
02:23:24 <newsham> kaji: in your case you just need any function that returns a value >= sqrt n
02:23:42 <newsham> you can use a piecewise linear equation, or just use n
02:23:43 <dmead> i'm not sure where you guys are saying i should put a new do block
02:24:03 <newsham> dmead: hard to say without knowing what your code is like.
02:24:09 <dons> dmead: what's the type of onClicked, please?
02:24:13 <dmead> ^^paste
02:24:25 <dmead> http://hpaste.org/524
02:24:28 <dons> and does entryGetText , is that your IO String function?
02:24:42 <augustss> Kaji: otherwise is defined to be True.  It just reads nicer than True
02:24:43 <dmead> onClicked is part of gtk2hs
02:25:07 <augustss> @src otherwise
02:25:07 <lambdabot> otherwise = True
02:25:17 <Kaji> I guess I could run one iter of a Newton-Rapheson ...
02:25:20 <dons> dmead, yeah, what's its type,
02:25:28 <dons> but anyway, I'm assuming the types here, but I suspect:
02:25:29 <Kaji> Hard to know if that will turn out to be > the root though...
02:25:29 <dons> onClicked button $ do
02:25:30 <dons>     s <- entryGetText entry
02:25:30 <dons>     let v = prove s
02:25:30 <dons>     entrySetText entry2 v
02:25:35 <dons> dmead: ^^
02:25:37 <Kaji> I could do two iters, and take the larger...
02:25:37 <newsham> dmead: for small n, aproximating sqrt n = n is probably fine for your purposes
02:25:40 <dmead> oh
02:25:42 <newsham> and only doing full sqrt if n is large
02:25:46 <dcoutts> dmead, or: entrySetText entry2 . prove =<< entryGetText entry
02:25:50 <dmead> not me ^^
02:25:52 <dons> dmead: i'm assuming the type of prove is :: String -> String ?
02:25:56 <dmead> yes
02:26:01 <dons> dmead: and entryGetText and entrySetText are monadic
02:26:06 <dmead> aye
02:26:12 <dons> ok. then there you go.
02:26:33 <dons> ?undo do s <- entryGetText entry ; let v = prove s in entrySetText entry2 v
02:26:33 <lambdabot> entryGetText entry >>= \ s -> let { v = prove s} in entrySetText entry2 v
02:26:35 <dmead> is it also workable to arrow that do block to a variable?
02:26:43 <dons> ?. pl undo do s <- entryGetText entry ; let v = prove s in entrySetText entry2 v
02:26:43 <lambdabot> (line 1, column 35):
02:26:44 <lambdabot> unexpected "{"
02:26:44 <lambdabot> expecting natural, identifier or "in"
02:26:46 <dons> dmead: yeah,
02:26:51 <dmead> ah
02:27:03 <dmead> dons++
02:27:06 <dons> you could just give that do block a name, and call it
02:27:14 <dmead> right right
02:27:32 <dons> IO is easy :D
02:27:37 <dmead> =P
02:27:38 <newsham> thats what i say!
02:27:49 <dmead> sorry, i'm a cin/cout fanboy
02:28:00 <dons> ?pl entryGetText entry >>= \ s ->  let v = prove s in entrySetText entry2 v
02:28:01 <lambdabot> entrySetText entry2 . fix . const . prove =<< entryGetText entry
02:28:08 <dons> well, that fix is a bit redundant
02:28:19 <dons> i'd write it as:  entrySetText entry2 . prove =<< entryGetText entry
02:28:41 <dons> but i'd probably abstract that whole thing out anyway
02:28:53 <dons> set f = entrySetText entry2  . f =<< entryGetText entry
02:29:02 <dons> then you just call, onClicked .. (set prove)
02:29:54 <dmead> o0
02:30:04 <dmead> too subtle for me
02:30:59 <Kaji> Hm... Bhaskara-Brouckner approximate for square root. That looks easy. Dunno if it's guaranteed to be an overshoot, though. I guess I could add 10% of the original number.
02:31:26 <newsham> kaji: you only need the aproximation for small n (where the cost of sqrt is high compared to the cost of your code)
02:31:32 <newsham> for big n, the othe rparts of your code dominate
02:31:51 <newsham> and for small n, overshooting sqrt n by a lot doesnt matter too much
02:32:04 <Kaji> Yeah, I know. And frankly, anything small enough to be worth optimizing the sqrt is already so small it takes no human-perceptible time anyway.
02:32:47 <dmead> ghci keeps telling me the last statement in a do construct must be an expression
02:33:54 <dmead> rawr
02:34:31 <skew> Well, there's no point binding something that isn't going to be used
02:34:58 <skew> ah, and more importantly where is it going to get the result type/value?
02:35:34 <dmead> who ya talkin to?
02:35:36 <dmead> me?
02:35:37 <dmead> o0
02:35:38 <skew> yep
02:35:41 <newsham> dmead: perhaps your code isnt blocked how you expect it to be?
02:35:42 <dcoutts> dmead, it's the equivalent of a java compiler complaining about the lack of a 'return' at the end of a function.
02:35:57 <dmead> yea sorry
02:36:08 <skew> like, you'd have to come up with some ad-hoc way to patch the function up to make it work.
02:36:12 <dmead> i had some crap messing up me layout
02:36:20 <skew> and then if you did that and it wasn't right, it would be even more confusing
02:36:47 <skew> it sounds kinda like the compiler is just being picky and complaining about something that might indicate busted layout, but it's not quite the same
02:37:33 <dmead> no really
02:37:44 <skew> Maybe the error should suggest it might be a layout problem
02:37:48 <dmead> i had "do =" sitting there
02:37:50 <dmead> for no reason
02:37:55 <dmead> anyways
02:37:59 <dmead> it works now
02:38:00 <dmead> :)
02:38:02 <skew> oh
02:38:17 <skew> that gives me "Empty 'do' construct"
02:38:29 <dons> dmead, isn't it cool just having arbitrary unnamed do blocks as arguments to functions? :-)
02:38:48 <dmead> it is indeed
02:39:14 <dmead> but it's different from a closure right?
02:41:42 <skew> () -> a in e.g. ML is pretty similar to IO a
02:41:50 <dons> well, the do block is a closure. its a code chunk, with closed over variables captured from its environment
02:41:59 <dmead> ah
02:42:53 <skew> but it doesn't have to be IO, the syntax is convenient, you don't confuse things thunked for side effects with things thunked for laziness with things that are really functions
02:42:54 <dons> now you want closures in Java, right? ;)
02:43:01 <dmead> ooohhh
02:43:05 <dmead> i don't know
02:43:08 <dmead> java looks like it's done
02:43:15 <dmead> and i tried python and ruby
02:43:23 <dmead> which are both ridiculous
02:43:26 <dons> heh
02:43:40 <dmead> C++ and haskell for me
02:44:15 <tibbe> if I have a list of URIs and want to use them with simpleHTTP to create a lazy list of Responses that I could write to file before all URIs have been fetched, how would I do that?
02:44:21 <newsham> i like python
02:44:29 <newsham> I also like do-blocks
02:45:08 <newsham> i'd rather java than c++
02:45:29 <dons> tibbe, a list comprehension, perhaps?
02:46:12 <dons> mapM_ write [ getResult xuri | uri < allMyURIs ] , the write will force the responses in order
02:46:23 <dons> sorry, bad network
02:46:28 <dons> 2 typos at least in that abvoe code
02:51:09 <dmead> check it out
02:51:18 <dmead> heres the java
02:51:35 <Rule> Hi, I have a small problem with kinds and instances
02:51:54 <Rule> I made this 2d vector data type and made it an instance of Functor
02:51:59 <Rule> Which worked out fine
02:52:02 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/provergui1.png
02:52:08 <Rule> But now I decided I want it to be a 2 tuple
02:52:10 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/gtkgui.png
02:52:18 <Rule> But I can't make the 2 tuple an instance of Functor
02:52:22 <Rule> Here's some code
02:52:25 <hpaste>  Rule pasted "Kind problem" at http://hpaste.org/525
02:52:26 <dmead> ?paste
02:52:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:52:28 <dmead> ah
02:52:29 <dmead> nm
02:52:31 <dmead> :P
02:53:03 <Rule> Why is the kind of (a, a) * ?
02:55:25 <dmead> mm
02:55:27 <dmead> in your instance
02:55:29 <dmead> instance Functor Vector2_B where
02:55:29 <dmead>     fmap f (x, y) = (f x, f y)
02:55:34 <dmead> i think it needs
02:55:45 <dmead> instance Functor Vector2_B <arguments> where
02:56:37 <Rule>     Kind mis-match
02:56:37 <Rule>     Expected kind `* -> *', but `Vector2_B a' has kind `*'
02:56:38 <Rule>     In the instance declaration for `Functor (Vector2_B a)'
02:57:24 <dmead> ahh
02:57:25 <dmead> yea
02:57:28 <dmead> i got the same error
02:57:29 <dmead> hmm
02:57:50 <paolino> :t listen
02:57:52 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
02:58:55 <Rule> dmead: I'm gonna think about it a bit whilst drinking some coffee :-)
02:59:02 <Rule> I'll be back shortly
02:59:33 <paolino> mhh , nomaware is not responding, anyone can point me to some docs on the listen Writer method ?
02:59:57 <dmead> Rule: what type do you expect a to be?
03:00:54 <tibbe> >>= return Nothing in the Maybe monad, if I would like a monad that returns [] on nothing do I have to roll my own?
03:02:02 <newsham> > do { x <- [1]; y <- []; return (x+y) }
03:02:03 <lambdabot>  []
03:02:24 <dons> ?src Functor
03:02:24 <newsham> ?hoogle Maybe a -> [a]
03:02:24 <lambdabot> class  Functor f  where
03:02:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
03:02:25 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
03:02:45 <newsham> > maybeToList (Just 3)
03:02:47 <lambdabot>  [3]
03:02:51 <dons> Rule, so your instance isn't applied to the element type of the functor, just, Functor Vector2
03:02:51 <newsham> > maybeToList Nothing
03:02:53 <lambdabot>  []
03:02:58 <newsham> do you want something like those?
03:04:55 <encryptio> i need a function that takes a list and returns a list of unique parings. something like [a] -> [(a, a)]
03:05:31 <encryptio> is there a library function (or an easily partially applied one) that already exists to do this?
03:05:50 <newsham> how do you get a pairing from a list?  any two elements?  adjacent elements?
03:05:58 <encryptio> any two elements
03:06:16 <newsham> > [(x,y) | x<-"foo", y<-"bar"]
03:06:17 <lambdabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o',...
03:06:30 <newsham> > nub "remove duplicates"
03:06:31 <lambdabot>  "remov duplicats"
03:07:06 <newsham> like so?
03:07:44 <encryptio> yep.
03:08:26 <encryptio> uniquePairs list = nub [(x,y) | x <- list, y <- list] -- no?
03:08:36 <newsham> thats what i'm thinking
03:09:03 <encryptio> well .. (x,y) and (y,x) should also be trimmed out
03:09:28 <newsham> ?type nubBy
03:09:31 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
03:09:53 <Kaji> Okay, stupidest question ever... kill me if you have to... getCPUTime returns an IO Integer. How can I print that integer out. I expected (getCPUTime) to do it, but it doesn't.
03:10:26 <encryptio> getCPUTime >>= print -- for the one-liner
03:10:31 <Kaji> Thanks!
03:10:43 <newsham> cartesian xs ys = [(x,y) | x<-xs, y<-ys];  samePair (a,b) (c,d) = (a,b)==(c,d) or (a,b)==(d,c)
03:10:52 <newsham> nubBy samePair (cartesian xs xs)
03:11:36 <newsham> kaji: also   do { t <- getCpuTime; print t }
03:11:51 <skew> or, like do start <- getCPUTime; doStuff; end <- getCPUTime; print (end-start)
03:11:56 <Kaji> Thanks again.
03:12:38 <Kaji> Prints out "0" every time, I must have to run something before it... or something. Any clues for me here?
03:12:44 <Kaji> Oh, duh, thanks.
03:14:10 <tibbe> is there a good reason for MaybeT to not be in the standard libs?
03:19:59 <Rule>   Kind mis-match
03:20:00 <Rule>     Expected kind `* -> *', but `Vector2_B a' has kind `*'
03:20:00 <Rule>     In the instance declaration for `Functor (Vector2_B a)'
03:20:02 <Rule> oops
03:20:08 <dons> Kaji: here's a ittle tut on it, http://haskell.org/haskellwiki/Timing_computations
03:20:10 <lambdabot> Title: Timing computations - HaskellWiki
03:20:20 <Kaji> Thanks. I'm going nuts here.
03:20:22 <Rule> dmead: I expect a to be a Float or some other Floating type
03:20:38 <Kaji> It tells me "ERROR - Type error in generator
03:20:52 <Kaji> when I try and do do { isPrime 17; t <- getCPUTime; print t }
03:21:06 <dons> Rule: instance Functor Vector2_B where ...
03:21:39 <newsham> isPrime :: Int -> Bool?
03:21:48 <newsham> do { let x = isPrime 17; t <- ..
03:21:57 <Rule> dons: fmap f (x, y) = (f x, f y)
03:22:19 <Kaji> Does everything inside a do block have to return the same type, or what?
03:22:45 <newsham> they all hae to be the same monad.
03:22:55 <Kaji> Oh boy...
03:23:25 <newsham> isPrime isnt any monad, but you can use "let"
03:23:29 <Kaji> Don't suppose I can coerce isPrime's result to an IO with isPrime 17 (::IO) can I?
03:23:39 <newsham> you could do   "return (isPrime 17)"
03:23:40 <Kaji> Main> do { let x = isPrime 17; t <- getCPUTime; print t }
03:23:40 <Kaji> ERROR - Syntax error in declaration (unexpected `<-')
03:24:00 <newsham> return x   makes an action whose result is x
03:24:16 <dons> Rule, that's not a valid definition of fmap for pairs
03:24:22 <dons> the instance of Functor for pairs is
03:24:28 <dons> ?src Functor (,)
03:24:29 <lambdabot> Source not found. Do you think like you type?
03:24:32 <dons> bah
03:24:35 <newsham> in a do block  "let x = expr"  is sort of like "x <- return expr"
03:24:41 <Rule> hehe
03:24:45 <dons> instance Functor ((,) a) where
03:24:45 <dons>     fmap f (x,y) = (x, f y)
03:25:03 <Kaji> Return seems to have done the trick, thanks!
03:25:26 <Rule> dons: Aaah. But I want 'f' to be applied to both values in the tuple.
03:25:28 <dons> ?src (,) fmap
03:25:29 <lambdabot> fmap f (x,y) = (x, f y)
03:26:12 <dons> Rule: then you can't use a tupe, you'll have to newtype it. and it will have to be a tuple of the same type for both its components
03:26:15 <dons> yeah?
03:26:23 <dons> newtype T a = T (a,a)
03:26:45 <dons> instance Functor T where fmap f (T (a,b)) = T (f a, f b)
03:26:57 <newsham> how about a two-element list?
03:27:08 <Rule> dons: Aha. I used a data type before trying the tuple and that worked. But I wanted to be able to use the tuple construtor instead of my own.
03:27:29 <dons> right. but then the existing instances for Functor (,) and so on will get in the way
03:27:53 <dons> so you can use newtype to create a new type with the same representation as (,)
03:28:16 <dons> but it will have its own instances, that you can write
03:28:46 <dons> you could declare your own infix type and data constructor too
03:28:57 <dons> data T a = a :,: a
03:29:11 <dons> fmap f (a :,: b) = f a :,: f b
03:29:16 <dons> or something like that
03:29:58 <Rule> dons: That's an interesting idea, but I think I'll use my old Vec2,3,4 data constructors for clarity.
03:30:13 <dons> probably a good idea ;)
03:30:20 <Rule> dons: Thanks for all the advice anyway :-)
03:30:29 <Kaji> Okay, so now I'm doing do { return (isPrime 1689542430967); t <- getCPUTime; print t }
03:30:39 <dons> Kaji: ok. you're close now.
03:30:42 <Kaji> This returns instantly (normally takes ~50 seconds) and says 0 CPU time.
03:30:49 <Kaji> Is it not running isPrime ?
03:30:49 <dons> right.
03:30:51 <dons> do you know why?
03:31:10 <Kaji> I'm guessing it's not running the action returned by 'return' ...
03:31:11 <dons> its a lazy language. so the evaluation won't happen till you need the result of isPrime
03:31:29 <dons> and here you never actually use the result of isPrime
03:31:38 <dons> so it is never computed
03:31:41 <dons> now, with 'seq' you can force evaluation
03:31:58 <Kaji> could I do junk <- return (isPrime 17) ?
03:32:15 <newsham> yes, but you dont need the "junk <-"
03:32:20 <dons> nope. here's a good ilustration:
03:32:22 <dons> System.CPUTime> do { return [1..]; t <- getCPUTime; print t }
03:32:22 <newsham> err.. sorry, i didnt read :)
03:32:23 <dons> 187499000000
03:32:31 <dons> note that the infinite list is never computed, obviously
03:33:30 <dons> so you use 'seq' like so:
03:33:31 <dons> System.CPUTime> do a <- getCPUTime ; length [1..99999] `seq` do b <- getCPUTime; print (a,b)
03:33:35 <dons> (1007812000000,3085937000000)
03:33:43 <dons> on a list, to force the list to be fully evaluated
03:33:53 <Kaji> I think getCPUTime is broken... I just tried the "return [1..]" and it still says 0.
03:34:01 <Kaji> Unless Hugs is realllly optimizing something crazy-like,
03:34:04 <dons> or on your isPrime, it would be:
03:34:08 <dons> do a <- getCPUTime ; (isPrime x) `seq` do b <- getCPUTime; print (a,b)
03:34:14 <dons> Kaji, no, return doesn't force evaluation
03:34:23 <Kaji> Well, you suggested it. ;D
03:34:31 <newsham> why dont you just print the result of isPrime?
03:34:38 <dons> so that's just Haskell deciding that since you never actually look at the value, you don't need it computed
03:34:43 <Kaji> Using "show"?
03:34:51 <dons> 'seq' is really the required function here
03:34:54 <dons> see my code above
03:35:00 <dons> do a <- getCPUTime ; (isPrime x) `seq` do b <- getCPUTime; print (a,b)
03:35:26 <dons> 'seq' will force the evaluation of the integer result of isPrime, before proceeding
03:35:50 <Kaji> getCPUTime is definitely broke! That returned (0,0) !
03:35:57 <dons> laziness is fun, but it makes timing execution hard, since you can't guarantee (without seq) that some fragment of code will actually be evaluated
03:36:11 <dons> Kaji: how long did it run for in real life?
03:36:19 <Kaji> About eh... maybe 6 or 7 seconds?
03:36:28 <dons> System.CPUTime> do a <- getCPUTime ; (sum [1..10000]) `seq` do b <- getCPUTime; print (a,b)
03:36:31 <dons> (3265625000000,3421875000000)
03:36:38 <dons> ah ok, 0 eh? maybe it is broken on your system.
03:36:40 <dons> can you use ghci?
03:36:49 <Kaji> Let me try that just for kicks...
03:37:05 <Kaji> (0,0) again. Wonder if I imported wrong.
03:37:18 <diffbavis> does anyone know of any lecture webcasts where they use haskell? (kinda like the mit/berkeley scheme thing)
03:37:23 <dons> does getCPUTime print anything reasonable,
03:37:24 <dons> System.CPUTime> getCPUTime >>= print
03:37:24 <dons> 3468750000000
03:37:32 <dons> i.e. the actual cpu time on your machine, Jak
03:37:42 <Kaji> I'm inside module Main instead of System.CPUTime, but I do have module Main where
03:37:45 <Kaji> import CPUTime
03:37:46 <dons> diffbavis: there's one series of lectures on haskell.org's tutorials page
03:37:46 <Kaji> No, it always prints 0.
03:37:55 <dons> Jaak: ok. its broken.
03:37:59 <dons> is this with hugs? on windows?
03:38:04 <Kaji> Yes, Hugs on windows.
03:38:13 <dons> could you report that, quite possibly no one has noticed.
03:38:17 <Kaji> Hahaha.
03:38:22 <Kaji> Time to get GHCI and quit this crap. ;D
03:38:23 <dons> and now fire up ghci, and actually make it work
03:38:26 <dons> right.
03:38:30 * Kaji shoots WinHugs in the head.
03:38:36 <dons> ndm, around?
03:38:56 * Kaji will get GHCI tomorrow... time to sleep now. Thanks everyone!
03:39:01 <dons> @tell ndm does getCPUTime return anything sensible in WinHugs ?
03:39:01 <lambdabot> Consider it noted.
03:39:14 <dons> Kaji: good luck. should be trivial to get working once ghci is up
03:43:00 <diffbavis> dons: great. thanks
03:56:05 <Igloo> Has anyone got an e-mail address for heatsink?
03:56:27 <dons> Igloo: btw, the readInt issue is definitly no bug, its the same behaviour as read
03:56:36 <dons> Igloo: email, yeah. let me see..
03:56:54 <Igloo> dons: You could argue read is buggy, though
04:04:16 <dons> hmm, don't seem to have his mail.
04:04:25 <Igloo> OK, thanks for looking
04:14:08 <Syzygy-> ?type compare
04:14:10 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
04:22:30 <Syzygy-> ?type ListT
04:22:33 <lambdabot> forall (m :: * -> *) a. m [a] -> ListT m a
04:23:25 <Syzygy-> How do I write a datatype that consists of a function?
04:23:53 <Syzygy-> Say, I want data MonomialOrdering = <something>, where <something> will have the signature a -> a -> Ordering
04:24:18 <Saizan> you either want a type or you need to put a contructor there
04:24:36 <Syzygy-> Saizan: Either a type or constructor?
04:24:41 <Saizan> like data MonomialOrdering a = MO (a -> a -> Ordering)
04:24:46 <Syzygy-> I should hope that when I declare a type I'll want a constructor.
04:24:55 <Syzygy-> Ah. That looks quite like what I'll want.
04:25:11 <dons> data T = T ([] a)
04:25:16 <Syzygy-> (to be specific, I'll want data MonomialOrdering = MO (Monomial -> Monomial -> Ordering)
04:25:17 <dons> data F = F (a -> b)
04:25:20 <Saizan> mmh i should have said type synonim
04:25:25 <dons> well, float the type vars out
04:25:31 <Syzygy-> float?
04:25:44 <dons> ?src ShowS
04:25:44 <lambdabot> type ShowS = String -> String
04:26:17 <dons> (->) is just another type type constructor, so use it as you would [] or (,)
04:26:24 <Syzygy-> Ah.
04:26:33 <dons> type T a = [a] -- [] a
04:26:39 <dons> type X b = (,) b b
04:26:44 <Syzygy-> Btw, dons: Care to take a quick look at what I'm doing? http://mpc723.mati.uni-jena.de/homhaskell.pdf
04:27:01 * dons takes a quick lock
04:27:07 <dons> ?time
04:27:10 <lambdabot> Local time for dons is Sat Feb 17 23:25:28 2007
04:27:10 <dons> ?time dons
04:27:14 <lambdabot> Local time for dons is Sat Feb 17 23:25:32 2007
04:27:20 <Syzygy-> Want to have that fleshed out to a full specification by next friday...
04:27:22 <dons> 23:24:35 ERROR 404: Not Found.
04:27:28 <Syzygy-> Oh, damn.
04:27:39 <Syzygy-> I forgot the ~mik: http://mpc723.mati.uni-jena.de/~mik/homhaskell.pdf
04:27:43 <Syzygy-> That should work better
04:33:29 <pejo> Syz, how did you end up in germany, if I may ask?
04:34:08 <Heffalump> anyone used GHC's heap profiling recentlyish? (I asked this last night but got no reply :-)
04:34:33 <dons> yeah
04:34:39 <dons> Heffalump: why?
04:35:06 <Heffalump> I tried it on Thursday and had a lot of trouble
04:35:48 <Heffalump> should I be reading anything other than the GHC manual to do it?
04:36:07 <dons> Syzygy-: looks promising.
04:36:16 <dons> Heffalump: more info please. the user manual should be all that is requied
04:36:22 <dons> in fact, -O2 -prof -auto-all
04:36:24 <dons> then +RTS -p
04:36:26 <dons> that's it.
04:36:58 <dons> OH,  were you using one of the funny profiling switcheds?
04:36:59 <Heffalump> heap profiling
04:37:01 <Heffalump> so -hc etc
04:37:04 <Heffalump> not time profiling
04:37:05 <dons> right. hmm. used it last year.
04:37:28 <dons> had issues with making the measuring rate small enough to work.
04:37:34 <dons> but got it working with the manual.
04:37:45 <dons> however, it could be broken in ghc 6.6, check the trac bug lists
04:37:55 <Heffalump> most of my profiles seemd to be sampled every 0.5 or 1 second or something
04:38:07 <Heffalump> rather than the 0.1 it claims in the manual - but even -i0.1 didn't change the blockiness of the profile
04:38:29 <Heffalump> also, the .hp file truncates the names of the things being profiled
04:39:15 <Syzygy-> pejo: I finished my master, and got a summer job with a mobile phone software consulting company in N√ºrnberg.
04:39:33 <Syzygy-> Then it turned out I didn't get a PhD position, so I stayed on in N√ºrnberg and kept on searching for PhD positions.
04:39:42 <Syzygy-> And finally, one opened in Jena which fit me like hand to glove.
04:42:09 <Heffalump> (oh, I also managed to get a segfault, but I'll turn that into a proper bug report if that's not already reported)
04:42:44 <dons> Heffalump: ok. so the sampling rate issue (i've seen that too), truncated strings (just a ui bug?)
04:42:55 <dons> but that should still be usable, or you can't get the sample rate fine enough?
04:43:36 <dons> but yeah, heap profiling is the evil twin, like the compacting GC is to normal GC
04:44:48 <Heffalump> dons: no, the strings are truncated in the .hp file
04:45:06 <Heffalump> I also couldn't understand what the strings meant.
04:45:28 <Heffalump> (this is work stuff so I can't check the details very easily right now, and I can't IRC from work :-( )
04:45:59 <paolino> matchRegexAll (mkRegex "[:alnum:]+")  is the way to match first string in a text?
04:47:45 <Heffalump> my conclusion in the end was that I didn't have any more of a space leak than I did in the thing I had a performance regression over, so I gave up and moved onto to time profiling. But in general I would like to understand how to do this properly :-)
04:48:36 <Syzygy-> dons: Suppose I define (as in the now updated pdf in my link) an element of a finitely presented algebra to be a pair of a "polynomial" in the generators, and an fpalgebra structure (carrying things like a gr√∂bner basis, and a monomial ordering); can I be reasonably certain that all different element I juggle within the same fpalgebra will end up having the common structure really common?
04:48:37 <dons> Heffalump: oh, yes. I remember that too now. the prefix has to be unique :/
04:48:42 <dons> definite bug there too then.
04:48:43 <Syzygy-> Or is this a space leak waiting to happen?
04:48:58 <dons> Heffalump: I think you're doing it properly :)
04:49:14 <dons> Syzygy-: sounds reasonable
04:49:20 <dons> and you can be explicit about the sharing
04:49:23 <Syzygy-> How?
04:49:24 <dons> just write it and see.
04:49:28 <Heffalump> dons: Is there some documentation of how the strings are derived?
04:49:42 <dons> Syzygy-: it depends on what you mean by 'juggle'. I'd need to see the code
04:49:49 <pejo> Syz, men du ‰r svensk va?
04:49:51 <Syzygy-> There is no code yet. Not by far. :P
04:49:53 <Syzygy-> pejo: Jad√•.
04:49:58 <dons> Heffalump, not sure.
04:50:00 <Heffalump> in some cases it was obvious, but there were some that weren't entirely obvious what precisely it meant
04:50:17 <Syzygy-> I'm still trying to design and specify it; code won't come until I'm convinced I have a pretty detailed specification.
04:50:21 <dons> ah yes. there should be in the heap prof docs, no?
04:50:35 <dons> Syzygy-: you could write pseudocode in haskell though, i would :-)
04:51:13 <dons> there's no fundamental reason I can see that you can't share values
04:51:18 <Syzygy-> But I'd want to instantiate Num for my FPAlgebras; with the multiplication doing something funky with the Maps storing each polynomial, and then reducing the result using the (expectedly common) Gr√∂bner basis structures.
04:51:23 <Syzygy-> For one example.
04:52:00 <Heffalump> well, unless there's something other than http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html to look at, or I've missed something, I don't think there is any explanation.
04:52:02 <lambdabot> Title: 5.4. Profiling memory usage, http://tinyurl.com/ycro5f
04:52:14 <Syzygy-> And once again I find myself wishing for a Category typeclass in Haskell, so that occasional composition would make sense.
05:10:49 * dcoutts is testing c2hs's C parser by compiling gcc using c2hs's cc-wrapper
05:12:47 <Heffalump> cool
05:16:40 <dcoutts> Heffalump, I've decided that standard C isn't that hard to parse, but some of the GNU extensions...
05:16:54 <dcoutts> especially ***** __attribute__ extensions
05:17:10 <dcoutts> as if C declarations and declarators wern't hard enough to parse already
05:17:57 * dcoutts goes away to implement gcc's __builtin_offsetof syntax
05:18:16 <ibid> well, __attribute__ ought to be fairly easy to ignore in the scanner
05:18:28 <dcoutts> ibid, true, but eventually we'll need them
05:18:36 <ibid> or does it provide something that you want to parse?
05:18:42 <dcoutts> to decide the sizes of types and offsets of struct members
05:18:44 <dcoutts> eg packing
05:18:47 <ibid> ah
05:19:38 * Heffalump is not particularly interested in parsing C but would like a standard C++ AST with pretty printing.
05:21:56 <dcoutts> Heffalump, I could do with someone redesigning c2hs's C AST so if anyone ever does a C++ one I'd like to know so I can steal the C subset
05:23:16 <dcoutts> and c2hs's C pretty printing is no good
05:33:13 <Igloo> Heffalump: I think the HEAD won't truncate the names, c/o Ravi
05:33:28 <Igloo> Heffalump: Where the strings z-encoded? If not I'm not sure what you mean
05:33:30 <Heffalump> ah, cool
05:33:43 <Heffalump> no, but some had .s and some had /s
05:34:00 <Heffalump> I remember there was one that was /functionName/execmain or something like that
05:34:07 <Heffalump> and I had some trouble working out what execmain was about
05:34:45 <Igloo> Oh, I think /s are the call stack
05:34:53 <Igloo> .s are just to show truncation AFAICR
05:35:02 <Heffalump> no, it was . as a separator too
05:35:07 <Heffalump> but I think that was just module names
05:35:13 <Igloo> If you also use -p then the numbers in the heap legend correspond to the numbers in the .prof file
05:35:14 <Heffalump> it was the /s that were confusing
05:35:21 <Heffalump> ahh
05:35:35 <Heffalump> that could be very useful, ta
05:35:52 <Heffalump> is the name you provide with -hcfoo etc the same as the one in the output?
05:37:33 <Igloo> I think I've always just used the leftmost bit (i.e. the function name); I don't know if being more precise works
05:38:04 <Heffalump> fully qualified function name?
05:39:24 <Igloo> I don't think I've ever tried qualified names
05:41:04 <Igloo> I don't think the cost centre names use the qualified name, actually
05:43:05 <emk> Does anyone know how to get in touch with syntaxfree (Diego Navarro)?
05:43:18 <emk> I want to discuss some theoretical stuff with him.
05:43:51 <dons> @seen syntaxfree
05:43:51 <lambdabot> I haven't seen syntaxfree.
05:44:00 <dons> he's usually around here. not the last couple of days
05:44:44 <rahikkala> emk: Just @tell syntaxfree your message
05:45:08 <emk> rahikkala, dons: Thanks!
05:45:46 <tibbe> kan you write strings over multiple lines somehow?
05:45:53 <tibbe> like "adsadas" "asdsadas"
05:46:01 <tibbe> to get them concatenated at compile time
05:46:10 <nmessenger> > "hello\              \ world!"
05:46:12 <lambdabot>  "hello world!"
05:46:19 <nmessenger> you can put newlines in there
05:49:53 <Syzygy-> .irssi/logs/#haskell.Freenode.2007-02-15.log:21:32 ( syntaxfree) :)
05:49:58 <Syzygy-> My last sighting of syntaxfree.
05:50:10 <Syzygy-> Times are CET.
06:34:03 <fasta> Can I disable the printing of "Compiling <module> ( <filename>" in ghci?
06:35:08 <Lemmih> fasta: -v0?
06:35:11 <dons> -v0
06:35:18 <fasta> thanks
06:35:32 <dons> i actually have alias ghci='ghci -v0'
06:35:38 <dons> in my .zshrc
06:35:54 <dons> and that's not a blackhole! crazy zsh
06:36:18 <dons> > let ghci = ghci ++ " -v0" in ghci
06:36:22 <lambdabot>  Exception: <<loop>>
06:36:24 <Syzygy-> Hehe
06:36:26 <fasta> Heh, gravity joins
06:36:37 <fasta> Coincidence, I think not!
06:36:39 <Syzygy-> alias ls = 'ls --color' is one of my standards.
06:36:45 <gravity> ?
06:36:56 <dons> 01:34  dons> and that's not a blackhole! crazy zsh
06:36:57 <dons> 01:34 -- gravity [n=david@dsl092-079-075.bos1.dsl.speakeasy.net] has joined #haskell
06:36:58 <fasta> I always rlwrap everything that doesn't have read line.
06:37:06 <gravity> Hehe
06:38:53 <fasta> Can I also get rid of "Loading package <foo> ... linking ... done"?
06:43:50 <pierre1> ?where haxml
06:43:50 <lambdabot> http://haskell.org/HaXml
06:46:41 <dons> fasta ghci -v0 should remove all those messages, afaik
06:46:57 <dons> do you have an example where that's not the case?
06:47:24 <fasta> dons: I will try to reproduce it
06:47:41 <dons> $ ghci -v0
06:47:41 <dons> Prelude> 1+2
06:47:41 <dons> 3
06:47:41 <dons> Prelude> :q
06:47:42 <dons> $
06:53:54 <erider> good morning
07:10:06 <MarcWebe2> Do you know where I can find proposals for a new Prelude introducing things like eg class Empty ?
07:13:17 <Heffalump> what would class Empty do?
07:14:48 <dons> MarcWebe2: there's some stuff on the wiki for new prelude extensions
07:14:52 <dons> but better to just write a library imo
07:15:15 <emk> @tell syntaxfree Hello! I'm working on various generalizations of the Probability module, and would love to get in touch with you. I can be reached via IRC or http://www.randomhacks.net/contact/ .
07:15:15 <lambdabot> Consider it noted.
07:16:11 <ray> sif your shell not have referential transparency
07:34:09 <paolino> how can I make a Parser value from a Read one ?
07:35:22 <paolino> btw, does it make any sense ?
07:47:55 <sorear> @users
07:47:55 <lambdabot> Maximum users seen in #haskell: 307, currently: 298 (97.1%), active: 23 (7.7%)
07:48:02 <sorear> @uptime
07:48:03 <lambdabot> uptime: 1d 10h 33m 11s, longest uptime: 2d 17h 27m 21s
07:48:21 <sorear> @messages?
07:48:21 <lambdabot> Sorry, no messages today.
07:52:25 <MarcWebe2> paolino: readP_to_S and vs ?
07:53:03 <MarcWebe2> I wanted to say and vice versa..
08:02:21 <dino-> @seen Cale
08:02:21 <lambdabot> I saw Cale leaving #oasis, #ghc, #haskell-overflow and #haskell 3h 23m 14s ago, and .
08:03:50 <ndm> @messages
08:03:51 <lambdabot> dons said 4h 24m 49s ago: does getCPUTime return anything sensible in WinHugs ?
08:04:44 <ndm> @tell dons getCPUTime seems to return something that goes up as i do more processing, so i guess the answer is yes
08:04:44 <lambdabot> Consider it noted.
08:05:08 <ndm> @tell dons but no idea if it counts Hug's CPU Time etc
08:05:09 <lambdabot> Consider it noted.
08:08:14 <paolino> MarcWebe2: I have some instances of a common class , I want the user to select one of them from a configuration file. How do I think about this thing ?
08:10:27 <sorear> ndm: how well does mitchell defunctionalization handle higher order constructors? (eg State, if it wasn't a newtype and therefore gone in yhccore)
08:10:28 <Cheery> I've been thinking one thing for a whiel.
08:10:39 <Cheery> It's about operating systems' drivers.
08:10:41 <sorear> go ahead
08:11:16 <ndm> sorear: higher order constructors? please explain (I can't remember the type of state)
08:11:37 <ndm> sorear: data State = State (a -> b) kind of thing?
08:11:37 <sorear> (s -> (a, s)) -> State s a, modulo return value order-
08:11:45 <Cheery> most drivers are such that operating systems have their own protocols and some operating systems even have whole of their own interfaces.
08:11:45 <ndm> yeah, it gets those fine
08:12:04 <sorear> it would be Very Bad if you had to fallback to reynolds-style for MTL code
08:12:31 <Cheery> what I've understood, combinator calculus allows you to transform interfaces if you have rules on transforming them.
08:12:52 <ndm> sorear: nah, it gets those fine - the one issue it has is with functions stored in a recursive data structure used in an accumulating manner
08:13:47 <sorear> huh?
08:13:48 <ndm> i.e. a list of functions, which you process using a foldl
08:13:54 <MarcWebe2> paolino I'm not sure I understand what you want to do? Something like if config then let (Impl1 val) = do stuff in val   else  let (Impl2 val) = do stuff in val ?
08:14:01 <Cheery> so, by defining a database of interfaces and various transformers between them, one lambda calculus description of a driver interface could fit multiple operating systems without refitting.
08:14:07 <sorear> that sounds really esoteric
08:14:13 <ndm> data List = C List | N (Int -> Int)
08:14:13 <Syzygy-> ?index SHA
08:14:14 <lambdabot> bzzt
08:14:17 <Syzygy-> ?hoogle SHA
08:14:18 <lambdabot> Text.Html.shape :: String -> HtmlAttr
08:14:18 <lambdabot> System.Win32.File.ShareMode :: type ShareMode
08:14:18 <lambdabot> GHC.Dotnet.marshalObject :: Object a -> (Addr# -> IO b) -> IO b
08:14:27 <Syzygy-> ?doc
08:14:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:14:29 <ndm> and then you would have to recurse over those with something like:
08:14:39 <pejo> Cheery, except most interfaces don't have very clear semantics, and often undocumented assumptions.
08:14:41 <ndm> f (C a) = f (C (C a))
08:14:53 <ndm> sorear: in practice, all the things in the nofib suite go through just fine
08:15:06 <allbery_b> ...and often involve asynchronous events
08:15:31 <Cheery> can they be fixed?
08:16:00 <allbery_b> not really
08:16:18 <pejo> For all operating systems on the market? Doubtful.
08:16:22 <Cheery> allbery_b: what prevents that you can't fix them?
08:16:49 <allbery_b> drivers have the problem that they usually have to eke out as much speed as possible, so you end up complicating clean interfaces in the name of performance
08:17:15 <sorear> how did you ever figure out that mitchell defun had trouble with that?
08:17:34 <paolino> MarcWebe2: my algorithm has a pluggable politic expressed as some instances of an class. To make it run , one and only one must be specified and I would like to do that in a configuration file.
08:17:39 <sorear> where do you get all these pathological cases?
08:17:48 <sorear> @where ArrayRef
08:17:50 <lambdabot> I know nothing about arrayref.
08:17:55 <pejo> sorear, he's like Feynman!
08:18:04 <allbery_b> e.g. you *must* respond to a device interrupt within some number of microseconds
08:18:44 <Cheery> interesting.
08:20:05 <allbery_b> and while you can have a fast interrupt handler queue data, you then need to deal with a queue that, if your interface isn't fast enough, could grow without bound (which, at interrupt time, is even more problematic than in user code:  no allocation)
08:20:12 <MarcWebe2> paolino Can you rephrase politic expressed?
08:20:21 <ndm> sorear: doing proofs about it
08:21:06 <allbery_b> lots of folks have designed nice clean driver interfaces and had real world concerns force them t o become byzantine
08:21:34 <ndm> sorear: i have a completeness proof (apart from a few little bits), and was doing a termination proof when i came accross that
08:22:19 <allbery_b> and the cleanest ones (e.g. early mach and minix) had terrible performance
08:22:50 <uccus> performance is overrated
08:23:10 <ndm> sorear: its annoying that it isn't complete, otherwise i'd have a nice pretty theory result - as it is i just have a practical result :(
08:23:15 <Cheery> uccus: performance is not overrated.
08:23:19 <allbery_b> (of course in those cases they kinda brought on their own problems by using the slowest interface they could come up with in the name of cleanness :)
08:23:29 <paolino> MarcWebe2, politics == way of computing one aspect of the overall computation
08:23:43 <allbery_b> performance is essential if you drop data without it
08:23:56 <pejo> allbery, wasn't that from copying data all over the place, mainly? I think L4 had some articles published about it.
08:24:14 <allbery_b> <allbery_b> (of course in those cases they kinda brought on their own problems by using the slowest interface they could come up with in the name of cleanness :)
08:24:14 <sorear> ndm: what does completeness mean in this context?
08:24:35 <ndm> sorear: defunctionalising everything - i.e. will never leave a higher order function present
08:24:46 <allbery_b> copying data is certainly an aspect of that
08:24:59 <ndm> without termination, the completeness proof is not valid - so it isn't complete
08:25:14 <allbery_b> also compare String vs. ByteString :)
08:25:24 <Cheery> allbery_b: I wonder whether they lacked necessary speed because their interfaces weren't fluid.
08:25:30 <allbery_b> or concatentation vs. composition
08:25:34 <Cheery> ie. fluid on machine level.
08:26:05 <sorear> ndm: so there are some programs, that if I ran catch on them, catch would panic on discovering a hof in the hill?  or does incompleteness apply only to mitchell style w/o fallback?
08:26:38 <ndm> sorear: only applies to mitchell style without fallback
08:26:44 <sorear> ah good.
08:26:46 <pejo> Cheery, L4 and K42 projects have quite a few publications relating to this, iirc
08:26:46 <allbery_b> chorus is an example of an OS which does message passing quickly enough to keep up with the real world, but internally it's a *horrible* mess --- they violate cleanness and abstraction barriers *everywhere* to get the performance
08:26:48 <ndm> sorear: once you have fallback, you have completeness easily
08:27:09 <Cheery> what are L4 and K42 projects?
08:27:13 <ndm> sorear: although in practice catch would crash and give the error "Note to self, implement reynolds defunctionalistion if anything ever actually needs it"
08:27:16 <sorear> microkernels iirc
08:27:22 <allbery_b> (realtime OS, performance is sine qua non)
08:27:24 <pejo> Cheery, L4 is a microkernel, K42 is some OS research project by mainly IBM I think.
08:28:11 <Cheery> lets see whether I can find their publications.
08:28:55 <allbery_b> cheery: fluidity has its own problems, the more fluid the interface the harder it is to make guarantees about it
08:29:01 <Cheery> ok, I think I found them.
08:29:36 <allbery_b> btw some of the K42 work was done here :)
08:29:37 <Cheery> allbery_b: true.
08:30:00 <allbery_b> (not that I could tell you anything mroe than that :)
08:30:40 <Cheery> thank you anyways. If I find something I'll read them. ;)
08:30:57 <allbery_b> but yu might be able to find some papers off of www.ece.cmu.edu
08:31:47 <Cheery> ok.
08:34:33 <uccus> @seen kowey
08:34:33 <lambdabot> I saw kowey leaving #darcs and #haskell 6h 32m 34s ago, and .
08:35:45 <dons> i used to be associated with the os group at uni, and every meeting was about making message passing in the L4 (and related) kernels faster :)
08:35:45 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
08:38:42 * sorear wonders aloud what a clean modular (but monolithically compiled) kernel would look like ... after a close encounter with a whole-program optimizing compiler
08:39:48 <dcoutts> sorear, incomprehensible?
08:40:30 <flux-> why not recompile the whole system when you install new software, with whole-operating-system-and-applications optimizing compiler ;)
08:40:46 <dcoutts> sorear, but the thing with L4 etc is that they are binary apis so you can't do compiler optimisations across them
08:40:48 <flux-> (gentoo on steroids?)
08:41:03 <dcoutts> I don't think it'd help much
08:41:28 <ndm> dcoutts, if you could take all the executing programs and the OS and compile them and cross-optimise, that would be very cool!
08:41:40 <LoganCapaldo> WEOOS
08:41:43 <flux-> well if the user could only perform binaries that were produced by such means, everything could run in kernel-mode
08:41:44 <LoganCapaldo> lol
08:42:05 <flux-> and the apis would no longer need to be binary
08:42:06 <dcoutts> ndm, I don't honestly see that it'd make things faster
08:42:28 <LoganCapaldo> It would be great for making claims that it went faster though
08:42:36 <ndm> dcoutts, whole program analysis has the potential for massive speed ups - you can remove error checking paths etc.
08:42:45 <LoganCapaldo> the marketing opportunities would be glorious :)
08:42:57 <allbery_b> <flux-> why not recompile the whole system when you install new software, with whole-operating-system-and-applications optimizing compiler ;)
08:43:28 <allbery_b> not quite that level, but svr3 and mach did a subset of that (ever wonder about that "optmimizing performance" step?)
08:43:51 <syntaxfree> any idea where I might find a programmer-friendly introduction to JavaScript?
08:43:51 <lambdabot> syntaxfree: You have 1 new message. '/msg lambdabot @messages' to read it.
08:44:48 <MarcWebe2> syntaxfree: Perhaps start at Wikipedia?
08:45:19 <int-e> @seen cale
08:45:19 <lambdabot> I saw cale leaving #oasis, #ghc, #haskell-overflow and #haskell 4h 6m 12s ago, and .
08:45:33 <syntaxfree> google yields all kinds of "kewel visual effects with js!"-type sites.
08:45:59 <uccus> ECMAScript language definition perhaps?
08:46:56 <syntaxfree> well, I know there's an ECMAScript that defines the language common to, say, JavaScript and Flash's ActionScript.
08:47:14 <syntaxfree> I also need to write a simple "interact" with a text form and a button, though.
08:47:39 <syntaxfree> (That's basically all the DOM I need. I just want a portable thing that runs some maths over user-inputted numbers)
08:48:18 <ndm> syntaxfree: http://www.nmitchell.co.uk/code/javascript_test.htm
08:48:20 <lambdabot> Title: Neil Mitchell - Javascript Test
08:48:40 <syntaxfree> oh. cool.
08:49:52 <ndm> i also recommend http://w3schools.com/ - i haven't checked their Javascript reference, but their DOM one is quite good
08:49:54 <lambdabot> Title: W3Schools Online Web Tutorials
08:50:04 <uccus> http://www.w3schools.com/js/js_intro.asp
08:50:05 <lambdabot> Title: JavaScript Introduction
08:50:15 <uccus> I see Neil already mentioned it
08:51:05 <syntaxfree> oh. can I just steal your test page?
08:51:19 <ndm> syntaxfree: sure
08:51:21 <uccus> BTW, that's the first link that comes up if you google "javascript introduction" ;)
08:51:58 <syntaxfree> hey, thanks.
08:52:14 <syntaxfree> (I kinda dismissed the w3schools thing)
08:53:48 <nmessenger> http://javascript.crockford.com/ has some very smart articles on the language, but I'm not sure how much is tutorial-esque.
08:53:49 <lambdabot> Title: Douglas Crockford's Javascript
08:54:33 <hpaste>  Marc Weber pasted "bad interface file? " at http://hpaste.org/527
08:55:38 <syntaxfree> I know it's probably very different from Haskell. How different from Scheme is it, semantics-wise?
08:56:02 <syntaxfree> (I mean, it evaluates in order, and has lambdas. What else can I shoot myself in the foot with?)
08:56:22 <sorear> MarcWebe2: bad interface means (a) compiler bug -OR- (b) 'find . -name "*.hi" -delete" and try agin.
08:56:41 <LoganCapaldo> You might "shoot yourself in the foot" with the prototype based inheritance if you are used to a class based OO
08:57:16 <uccus> syntaxfree: what Logan is saying is quite new to JavaScript so you might as well ignore it for the moment
08:57:40 <uccus> crap, I misread it
08:57:54 <LoganCapaldo> uccus: Huh? JavaScript has been prototype based from the get go. Now they are adding classes, thats the new thing L)
08:57:57 <nmessenger> talking of the "Prototype" library?
08:58:01 <LoganCapaldo> no
08:58:13 <LoganCapaldo> prototype as in Self
08:58:15 <nmessenger> LoganCapaldo: that was @uccus
08:58:21 <LoganCapaldo> oh
08:58:24 <LoganCapaldo> lol
08:58:26 <syntaxfree> I read something about prototype-based IO.
08:58:36 <uccus> LoganCapaldo: you are right. I misread it.
08:58:52 <syntaxfree> like you don't write formal class definitions like in other OO languages, you just implement a prototype.
08:58:58 <uccus> yes
08:59:03 <syntaxfree> Then again, I don't have the slightest idea of what OO classes are.
08:59:14 <syntaxfree> (some idea I have. Objects inherit structure from it)
08:59:28 <uccus> syntaxfree: it's a very easy language so nothing much to shoot yourself with
09:00:07 <nmessenger> I'm not sure how easy it is for someone who says he's not used many imperative-style languages before.
09:00:39 <uccus> nmessenger: any imperative language will do for JavaScript :D
09:00:52 <LoganCapaldo> That's so foreign to me. I'm trying to imagine someone sitting there going "What do you mean this code executes in sequential order!?!?!"
09:00:55 <syntaxfree> I've done a course in Scheme. But it basically covered, what, one third of SICP.
09:00:59 <LoganCapaldo> ;)
09:01:12 <syntaxfree> LoganCapaldo: well, that's basically it, yes ; )
09:01:47 <nmessenger> x = x + 1???? WTF?!
09:01:55 <sorear> basically it means all your lines are stuck together with >>
09:02:13 <syntaxfree> nmessenger: huh? :P
09:02:13 <LoganCapaldo> and the = is writeIORef and x is readIORef ;)
09:02:17 <sorear> also, you run in ReaderT (IORef (Map String Dynamic)) IO
09:02:41 <syntaxfree> @quickcheck (\x->x == x+1) :: (Int->Bool)
09:02:42 <lambdabot> Unknown command, try @list
09:02:55 <LoganCapaldo> Also, the webpage its running on (if you are doing that) is a huge massive global :)
09:02:55 <MarcWebe2> sorear: I did clean and rm -fr dist .. then its a compiler bug.. I'll try to track it down
09:03:01 <uccus> there was this "proper translation" of a C code in the haskell-cafe list that cracked me up
09:03:15 <allbery_b> bulat?
09:03:21 <uccus> Simon
09:03:30 <uccus> I think
09:03:37 <sorear> Simon Ziganshin!?
09:03:44 <allbery_b> heh
09:05:36 <uccus> yep, from S. Marlow
09:05:43 <uccus> http://blog.gmane.org/gmane.comp.lang.haskell.cafe/month=20040301/page=7
09:05:56 <lambdabot> Title: gmane.comp.lang.haskell.cafe, http://tinyurl.com/25g7oz
09:09:27 <int-e> uccus: thanks. very nice :)
09:09:46 <uccus> hehe
09:18:29 <nmessenger> @let x = 1
09:18:31 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
09:21:28 <LoganCapaldo> woah
09:21:35 <LoganCapaldo> @let y = 2
09:21:36 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
09:21:48 <LoganCapaldo> The lambdabot is dead!!!! Nooooooo!
09:22:36 <dmhouse> Such dramatic error messages. I love it.
09:22:48 <allbery_b> yeh @let got broken in the upgrade to 6.6
09:22:56 <nmessenger> :(
09:23:30 <nmessenger> @vixen Is that when you broke?
09:23:31 <lambdabot> <undefined>
09:23:55 <allbery_b> no, vixen broke with Data.Binary upgrade
09:24:02 <allbery_b> 6.6 was a couple days ago
09:24:28 <allbery_b> I think dons is concentrating on his new machine now and will fix LB afterward, but don't quote me on that
09:24:52 * nmessenger considers @remembering that
09:27:33 <sorear> > bitSize (0 :: Word)
09:27:35 <lambdabot>  32
09:27:42 <sorear> still waiting
09:30:04 <glguy> any of you used Factor? (know of some good example code?)
09:30:45 <LoganCapaldo> glguy: As you may be aware theres #concatenative
09:30:55 <glguy> LoganCapaldo: noted
09:30:55 <sorear> syntaxfree I believe
09:31:12 * sorear remembers to darcs send
09:32:43 <sorear> echo 'emertens@gmail.com' > ~/public_html/hpaste/_darcs/prefs/email
09:33:08 <sorear> glguy: the repo default email for hpaste isn't set
09:33:13 <glguy> ah
09:34:02 <glguy> might be now
09:34:59 <sorear> it is
09:39:26 <glguy> sorear: there ya go :)
09:40:12 <glguy> sorear: how often do you clean up the pastes?
09:40:30 <glguy> maybe you deleting them is why I hardly seen any junk pastes
09:40:43 <sorear> not often enough to remember the trailing slash :)
09:40:50 <glguy> heh
09:40:53 <sorear> I don't see many either
09:41:07 <sorear> I delete test pastes - haven't seen a single spam yet
09:41:16 <glguy> i delete dups
09:41:45 <Saizan> there's another hpaste out there?
09:42:21 <glguy> ?
09:42:23 <sorear> my Greater Plan atm is to remake the bot as a HAppS.Protocol.IRC, with only app logic in hpaste
09:42:49 <glguy> ah, that'd be nifty
09:42:50 <sorear> http://127.156.223.83:8000/ is another last I checked
09:43:09 <sorear> :p
09:43:20 <glguy> 127/8 :)
09:43:21 <sorear> not globally visible however
09:44:47 <dmhouse> sorear: why would your average HAppS user want a Protocol.IRC module?
09:45:16 <dmhouse> I think HAppS has too many Protocol.* modules already. I'd love to see a stripped-down version with only a minimum set of modules needed to make a working HTTP server.
09:45:55 <Saizan> well CGI:IRC is a nice perl(?) module, for example
09:46:10 <dmhouse> Saizan: sure, but why include it in HAppS?
09:46:37 <Saizan> so you can easily make a web-based irc client?
09:46:51 <allbery_b> maybe HAppS needs a plugins repo?
09:46:57 <Saizan> and hpaste :)
09:46:59 <dmhouse> allbery_b: that'd be ideal.
09:47:27 <Saizan> (i wonder what Protocol.IRC would contain)
09:47:29 <Cheery> What are infinite types?
09:47:41 <dmhouse> One of my long-term plans is to fork HAppS with a minimum set of modules needed to write your standard web app, then bundle some Rails-style SYB on top.
09:47:53 <dmhouse> Cheery: is this from an error message you're getting?
09:48:20 <allbery_b> :t undefined --- infinite type :)
09:48:20 <Cheery> haskell can't construct those, they come from things like: anyw x = anyw
09:48:23 <lambdabot> forall a. a
09:48:23 <Saizan> my long term plan on happs is hot-swap and decentralized state.
09:48:38 <dmhouse> allbery_b: I'm not sure that's what's meant by an infinite type.
09:48:42 <allbery_b> I know
09:48:50 <dmhouse> ?type \a -> a a
09:48:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:48:53 <lambdabot>     Probable cause: `a' is applied to too many arguments
09:49:01 <dmhouse> Cheery: that's the kind of thing?
09:49:27 <Cheery> anyw x = anyw?
09:49:37 <dmhouse> ?type anyw x = anyw
09:49:39 <lambdabot> parse error on input `='
09:49:45 <dmhouse> ?type let anyw x = anyw in anyw
09:49:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
09:49:49 <lambdabot>     Probable cause: `anyw' is applied to too few arguments
09:50:05 <dmhouse> The type of anyw would be a -> a -> a -> a -> a -> ...
09:50:39 <nmessenger> anyw is a function that when given a value, produces itself, so when given another value, produces itself...
09:51:25 <dmhouse> You can sum up that infinite type by saying it's a type t such that t = a -> t (which is what that error message means).
09:51:27 <Cheery> would it help if I'd describe it a way how it can terminate?
09:52:04 <dmhouse> To convince yourself that they describe the same type: t = a -> t, so t = a -> (a -> t) (which is called 'unfolding'). Repeating this process yields our original infinite type.
09:52:12 <ski_> # let rec anyw x = anyw;;
09:52:12 <ski_> val anyw : 'b -> 'a as 'a = <fun>
09:52:36 <nmessenger> there's an ML bot?
09:52:44 <ski_> (that's 'ocaml -rectypes')
09:52:50 <nmessenger> oh, nevermind, silly me :)
09:53:27 <ski_> # fun a -> a a;;
09:53:27 <ski_> - : ('a -> 'b as 'a) -> 'b = <fun>
09:53:30 <nmessenger> Cheery: I'm not sure it would help, there's still the infinite type error.
09:53:43 <sorear> fix b. a -> b
09:53:59 <dmhouse> Cheery: have you got a specific error you'd like help with? If so, paste your code:
09:54:00 <dmhouse> ?paste
09:54:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:54:09 <LoganCapaldo> > fix fix
09:54:10 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
09:54:11 <lambdabot>     Probabl...
09:54:21 <nmessenger> heh
09:54:34 <ski_> Cheery : hm .. what way for it to terminate did you have in mind ?
09:54:49 <LoganCapaldo> Out of stack space? ;)
09:54:55 <sorear> Expr> yy
09:54:55 <sorear> (fix a . a -> a)
09:55:52 <LoganCapaldo> Is there a type that to check it would cause ghc not to terminate?
09:56:04 <Cheery> dmhouse: I've a specific thing where the error occurs, but I'd like to try it out on my own for a change.
09:56:06 <LoganCapaldo> Infinite compile time loop!
09:56:18 <sorear> LoganCapaldo: yes
09:56:31 <LoganCapaldo> do it! ;)
09:56:34 <sorear> not exactly - it's the optimizer that crashes
09:56:54 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/bugs.html#bugs-ghc
09:56:56 <lambdabot> Title: 12.2. Known bugs or infelicities, http://tinyurl.com/2je84p
09:57:05 <LoganCapaldo> Well moving infinite loops to compile time is definetly an optimization ;)
09:58:06 <nmessenger> you just have to wait a while for your object code :D
09:59:24 * LoganCapaldo solves the halting problem
09:59:33 <LoganCapaldo> > let _|_ = 2
09:59:33 <lambdabot>  Parse error in expression
10:00:22 <nmessenger> s/2/42/ obviously
10:01:02 <nmessenger> That is the ultimate question of life, the universe, and everything!  What is the answer to the halting problem?
10:01:08 <LoganCapaldo> nmessenger: no, that's what haltp returns
10:01:39 <LoganCapaldo> > let haltp program = 42 in haltp (fix (1+))
10:01:40 <lambdabot>  42
10:01:44 <Cheery> Huh, It's really exhausting when one hits a hard problem.
10:02:07 <nmessenger> then put your code in hpaste and exhaust others!
10:02:08 <Cheery> or just ends up trying a way which is not a way. :)
10:04:03 <emu> nmessenger: you'll know it when you see it
10:04:12 <Cheery> nmessenger: but then I'd need to listen and understand, which is exhausting as well.
10:04:31 * LoganCapaldo optimizes
10:04:52 <LoganCapaldo> > let haltp = const 42 in haltp (fix (1+))
10:04:54 <lambdabot>  42
10:05:11 <nmessenger> eta-reduction is hardly an optimization :P
10:05:32 <LoganCapaldo> nmessenger: what, you didn't know about const-fusion? ;)
10:06:27 <dcoutts> don't you get that optimisation by eta-expansion and beta-reduction?
10:07:44 * dcoutts can now parse all of gnu binutils with the new c2hs C parser
10:08:06 <dcoutts> oh, except for long long integer constants
10:09:21 <Nafai> dcoutts: Cool!
10:10:35 <dcoutts> Nafai, though sadly I still can't parse some linux kernel header code :-(
10:10:44 <Nafai> :(
10:10:53 <dcoutts> it uses "extern __typeof(blah) foo() {}"
10:11:10 <pejo> dcoutts, shouldn't userspace stay away from the kernel headers?
10:11:21 <dcoutts> I can parse typeof fine but my current grammar doesn't expect the storage qualifier
10:11:41 <dcoutts> pejo, yeah, I was trying to parse the whole kernel as a test of the parser
10:12:09 <dcoutts> but there's a particular header I can't parse that just about everything #includes
10:12:50 <LoganCapaldo> Is it named evil.h? ;)
10:13:02 <dcoutts> heh
10:14:05 * LoganCapaldo goes thru the GHC source and s/unsafe/evil/
10:14:10 <LoganCapaldo> evilPerformIO ;)
10:14:24 <dmhouse> That'd be so much cooler.
10:14:29 <ndm> dcoutts, submit a patch to the kernel :)
10:14:37 <dcoutts> ndm, heh
10:15:48 <hpaste>  Saizan pasted "typeclass restriction" at http://hpaste.org/528
10:16:24 <Saizan> is there a way around that error that doesn't involve putting another parameter to the Comonad class?
10:20:56 <nmessenger> should Comonad have 'a' in its parameter list?  Shouldn't it be (* -> *)?
10:22:31 <Saizan> nmessenger: yes, that's the standard way, but then i could'nt even specify anything on the type a
10:25:18 <ndm> woohoo, i've just made every single one of the imaginary nofib suite first order!
10:26:52 <dcoutts> @yarr!
10:26:52 <lambdabot> Ahoy mateys
10:27:36 <sorear> yay!!
10:28:04 <ndm> it looks like Catch won't be able to prove much about arrays
10:28:19 <ndm> they are a unsafe data structure, when it comes to pattern matching
10:28:35 <ndm> why array is the primitive operation, and listArray isn't, isn't something i understand
10:29:11 <dcoutts> LoganCapaldo, hah ha! I can now parse evil.h too! :-)
10:29:42 <dcoutts> ndm, the first convenient random indexing
10:30:21 <dcoutts> so you can initialise the array elements in any order
10:30:23 <ndm> dcoutts, but arrayList is implemented in terms of array, that sounds inefficient, and a bit pointless
10:30:36 <dcoutts> not really
10:30:50 <ndm> plus the preconditions on array are way too complex for catch to get :)
10:30:52 <Igloo> Implementing array in terms of arrayList would certainly be worse
10:30:52 <dcoutts> you'd only be saving the calulation of +1
10:31:19 <dcoutts> ndm, s'ok we don't expect you to figure out the array bound checking :-)
10:31:27 <ndm> dcoutts, future work :)
10:31:43 <ndm> (although i do have a plan, using the Catch framework, just not going to get to implement it this PhD)
10:31:44 <sorear> ndm: can you make it so listArray works at least?
10:32:07 <ndm> sorear: i can write an abstract version of listArray which will guarantee safety, (!) will always be unsafe though
10:32:45 * sorear suddenly imagines a {-# CATCH_UNSAFE_DESCRIBE_PRECONDITION (hd*) . foo. {blah #-}
10:33:39 <ndm> sorear: that's more an ESC Haskell type thing :)
10:34:01 <sorear> ESC?
10:34:10 <ndm> although version two would allow explicit preconditions and axioms to be defined
10:34:13 <ndm> @where eschaskell
10:34:13 <lambdabot> I know nothing about eschaskell.
10:34:19 * sorear sees catch as a lint for haskell, so source annotations would make sense
10:34:19 <pejo> ndm, heh, planning to do another PhD? ;)
10:34:28 <ndm> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
10:34:42 <ndm> pejo: i don't think so :)
10:34:56 <pejo> "One PhD ought to be enough for anybody".
10:35:08 <ndm> sorear: they basically do, but my goal is to check haskell without any annotations - stage two would be to allow the user to annotate to help through the really complex bits
10:35:33 <ndm> although in practice Catch is substantially cleverer than me already at spotting pattern matches and proving them, so i'm not sure how much use a user is in the process
10:40:08 <pejo> ndm, is the planned icfp-paper about catch?
10:40:16 <ndm> pejo: yep
10:40:52 <syntaxfree> that 'The best language to teach programming" is funny.
10:41:01 <syntaxfree> s/is funny/article on reddit is funny
10:41:03 <pejo> ndm, please holler if/when there's a draft. :-)
10:41:50 <sorear> so, if dcoutts' c2hs can parse all of GNU C, and ndm can turn Yhc.Core into uber-efficient machine code - should someone/I write :: C_AST -> Yhc.Core.Type  now? :)
10:41:53 <ndm> pejo: email address? (i can't remember it off hand, although i'm sure i've got it somewhere)
10:42:06 <dcoutts> sorear, heh
10:42:11 <ndm> sorear: if C was lazy...
10:42:25 * sorear thinks he'll wait for the non-NDA version :p
10:42:37 <sorear> well, monadic code
10:42:43 <sorear> with lots o Ptrs
10:43:32 <Igloo> ndm: Why will laziness matter?
10:43:51 <ndm> Igloo: otherwise you're likely to end up throwing awway most of the clever bits in the optimiser
10:43:59 <sorear> @where c2hs
10:43:59 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
10:44:21 <sorear> strict haskell exists, we'll need to optimize it too
10:44:54 <ndm> hmm, i wonder how my transforms work on strict code - not something i've really looked at...
10:45:29 <Igloo> ndm: Are you talking about purity rather than laziness?
10:45:39 <ndm> Igloo: i guess, yes
10:45:40 <sorear> it'll still be haskell, just not taking advantage of laziness
10:46:29 <pejo> sorear, if the core language is anything close to what Marlow's thesis has in Chapter 2 I'll happily ponder the strict haskell some.
10:46:47 <Igloo> That would just be the responsibility of the person writing the convertor, then
10:46:57 <sorear> main = \argc argv -> do { _t1 <- return (B.pack "Hello, World\n") ; _t2 <- puts _t1 ; return 0 }
10:46:57 <dmhouse> What do 'Inferred type is less polymorphic than expected' errors mean?
10:47:10 <sorear> dmhouse: it usually means you wrote  'runST $ ...'
10:47:13 * dmhouse wishes there were a glossary of GHC errors.
10:47:14 <sorear> ditch the $
10:47:16 <dmhouse> sorear: not here.
10:47:20 <sorear> runST (foo bar)
10:47:24 <dmhouse> I am using existentials, though.
10:47:27 <allbery_b> well, sometimes it means monomorphism restriction
10:47:30 <Igloo> dmhouse: You told it it was polymorphic, but it thinks that it isn't
10:47:53 <sorear> @google Simon Marlow thesis
10:47:55 <lambdabot> http://research.microsoft.com/~simonpj/Papers/papers.html
10:47:55 <lambdabot> Title: Simon Peyton Jones: papers
10:48:10 <sorear> ooh, PJ wrote M's thesis? :)
10:49:02 <ndm> does PJ have a thesis - i never found it
10:49:20 <sorear> PJ doesn't even have a PhD
10:49:33 <ndm> thats what i thought, although its not mentioned explicitly
10:49:39 <pejo> sorear, www.haskell.org/~simonmar has his thesis somewhere among the publications.
10:49:46 <pejo> Simon Marlow's, that is.
10:50:06 <syntaxfree> hmm. PJ has no PhD?
10:50:39 <sorear> pejo: I found it *finally*, no link however
10:50:42 <sorear> syntaxfree: correct.
10:50:58 <sorear> lots of people want to give him one, I'm told
10:50:58 <syntaxfree> Simon Peyton Jones (born in South Africa in 1958) is a British computer scientist who does research on the implementation and applications of functional programming languages, particularly lazy functional languages. He is an honorary Professor of Computer Science at the University of Glasgow and supervises PhD Students at the University of Cambridge.
10:51:03 <syntaxfree> Peyton Jones graduated from Trinity College, Cambridge in 1980, and worked in industry for two years before serving as a lecturer at University College London and as a professor at the University of Glasgow, where he also served as subsequently Head of Department of Computer Science.
10:51:08 <syntaxfree> wow.
10:51:15 <syntaxfree> (well, yeah, he was 22 in 1980. That's a MS at most)
10:51:18 <syntaxfree> sorry for the large paste.
10:51:52 <syntaxfree> how did he land as the head of Glasgowland? Sheer research coolness?
10:52:21 <sorear> I believe so
10:52:33 <ndm> syntaxfree: in some places HoD is an admin thing given to senior professors, generally those who couldn't find a way to get out of it
10:52:37 <pejo> syntax, Glasgow had lots of great people there at one time.
10:52:44 <ndm> (at York that seems to be the general way things are done)
10:52:44 <syntaxfree> yes, I know.
10:53:00 <hpaste>  paolino pasted "existentials can resolve ?" at http://hpaste.org/529
10:53:31 <syntaxfree> http://www.newsforge.com/print.pl?sid=01/07/03/0117248
10:53:33 <lambdabot> Title: Articles
10:53:54 <bringert> SPJ's parents have lived in Marlow
10:53:58 <bringert> interesting
10:54:01 <syntaxfree> "He then tacked on a post-graduate year in computer science. That last year constitutes the entirety of his formal training in computers."
10:54:08 <syntaxfree> oh man. There's hope for me ;)
10:54:13 <syntaxfree> man, I'm inspired.
10:54:16 <sorear> paolino: this is not a existensial
10:54:27 * sorear fixes
10:54:33 <paolino> :)
10:54:34 <pejo> I think it's a lot harder to get any serious research position today without a phd compared to 25 years ago.
10:54:57 <ndm> i'd have thought it was completely impossible
10:55:14 <pejo> Well, why do we call the halting problem hard? :-)
10:55:19 <syntaxfree> who cares about research positions?
10:55:28 <ndm> things have changed, people need more qualifications
10:55:31 <syntaxfree> I'm talking more about coming up with something great.
10:55:39 <pejo> syntaxfree, how do you think SPJ can do so many cool things, if not for his work?
10:55:56 <ndm> my mum is a chartered accountant with a handful of GCSE's - nowadays you can't get on the training program without a degree
10:56:21 <syntaxfree> pejo: I thought he had a more traditional career, with a B.Sc, a MSc and a PhD in CS.
10:56:21 <ndm> syntaxfree: you generally don't get paid to do cool things without the qualifications
10:56:34 <syntaxfree> well, who cares about getting paid? :)
10:56:39 <syntaxfree> I can get a day job.
10:56:48 <pejo> syntaxfree, my point was that you need a research position, otherwise you have to struggle with working 40 hours every week instead of researching.
10:56:56 * Nafai sighs
10:57:24 <hpaste>  sorear annotated "existentials can resolve ?" with "two fixes - pick one" at http://hpaste.org/529#a1
10:57:39 <Nafai> Are advanced degrees really *that* critical?
10:57:43 <syntaxfree> pejo: I might be able to land a research position in economics if I keep this route.
10:57:58 <syntaxfree> Then I can just pretend FP research is relevant to economics somehow :P
10:58:10 <sorear> paolino: ^^^
10:58:14 <pejo> And having a good research environment is a big advantage, I bet.
10:58:28 <bringert> syntaxfree: ask Jane Street Capital and Credit Suisse
10:58:35 <ndm> Nafai: only for research at a university, not much else
10:58:54 <Philippa> Nafai: a bachelor's doesn't really say anything about ability to do research, so an actual research degree is the equivalent in box-ticking power
10:59:05 <ctkrohn> syntaxfree: If you're into financial economics at all, SPJ did some interesting work with using combinators to model certain types of derivatives
10:59:06 <syntaxfree> bringert: yes, I was meaning to send Jane St. a CV before depression struck.
10:59:12 <syntaxfree> I did read that paper.
10:59:28 <sorear> kowey: 2.5 h ago: <*uccus> @seen kowey                        [08:32]
10:59:37 <syntaxfree> I'm more interested in getting something done with PFP and econometric inference right now. But I'm really not able to work much somehow.
10:59:44 <syntaxfree> My brain's screwed up.
10:59:51 * dcoutts can parse all the glibc ./configure C tests (mostly testing thread local storage)
10:59:54 <ctkrohn> I wonder if anyone on Wall Street is actually using that methodology... it would seem to clean things up quite a bit compared to how things are done now
11:00:00 <dcoutts> now for glibc proper...
11:00:02 <ctkrohn> sorry to hear that, syntaxfree
11:00:18 <uccus> are you here, kowey?
11:00:25 <kowey> yes I am
11:00:36 <uccus> [thanks sorear]
11:00:40 * syntaxfree is about to get on an off-topic rant.
11:00:47 <syntaxfree> Maybe I should take this to #haskell-blah
11:00:49 <kowey> (thanks sorear... uh... bot?)
11:00:58 * sorear rescues the channel
11:01:28 <sorear> paolino: you uses a universally quantified type.  you seemed to have wanted an existentially quantified type.
11:01:30 <kowey> hey, uccus, you should join the wikibook mailing list if you haven't already
11:01:58 <sorear> kowey: not a bot, sorry.  I have to sleep sometimes.
11:02:06 <uccus> can you suggest how to improve this: http://en.wikibooks.org/wiki/Haskell/Higher-order_functions_and_Currying
11:02:09 <lambdabot> http://tinyurl.com/uuqak
11:02:19 <uccus> there's a mailing list? :|
11:02:33 <paolino> sorears yes, thanks I was not finding my way through existentials
11:03:20 <kowey> uccus: there is indeed - http://www.haskell.org/mailman/listinfo/wikibook
11:03:21 <lambdabot> Title: Wikibook Info Page
11:03:49 <uccus> kowey: the last section, not much text, but I need directions
11:04:18 <kowey> types of higher order functions?
11:06:16 <kowey> uccus: i don't think i understood the sentence 'So what do you do, given an Ordering, with a list? You sort it!'
11:06:36 <uccus> alright... rephrasing it
11:08:20 * LoganCapaldo contemplates an antisort function
11:09:28 <uccus> LoganCapaldo: you need some form of quantum mechanics... I suppose
11:09:33 <LoganCapaldo> eh it would be O(n!) i think
11:09:37 <LoganCapaldo> sucks
11:09:47 * sorear points out that there are uncoundably many functions of type [a] -> [a]
11:10:17 <uccus> kowey: rephrase, subscribed
11:10:23 <Igloo> I don't supose anyone uses ghci from within emacs? Ideally on Windows?
11:10:38 <sorear> I do - not on widnows
11:10:55 <LoganCapaldo> sorear: I was thinking an ordering that would have the shortest possible sorted subsequences where ascending sequences or descending sequences would both count as sorted
11:10:57 <sorear> actually I use shim more now, but I used to use inf-haskell
11:10:59 <Igloo> sorear: Can you let me know whether or not you can reproduce http://hackage.haskell.org/trac/ghc/ticket/1139 please?
11:11:01 <lambdabot> Title: #1139 (Error when running ghci in emacs buffer) - GHC - Trac
11:11:29 <kowey> uccus: also, i believe that this bit might be confusing: 'so (a -> a -> Ordering) -> [a] -> [a] is not the same as, for examples, a -> a -> Ordering -> [a] -> [a]'
11:12:01 <kowey> in that -> being right associative isn't the principle reason that it's not the same... (uh... i think)
11:12:14 <kowey> see what i mean?
11:12:17 <uccus> I thought so... initially I was trying to make my point using the map function. then thought good pedagogy would force me to be on topic
11:12:46 <uccus> it's not the _reason_, it's a hint
11:12:47 <kowey> ok, well it's a good thought; I think we can work with it though...
11:13:12 <kowey> for example, we could start with a -> a -> Ordering -> [a] -> [a]
11:13:31 <paolino> sorear how do I summa 2 Int1 or Int2 with the CPS ?
11:13:44 <sorear> Igloo: no reproduce, 6.7.20070213, 22.0.93.1, shell-mode - trying other permutations
11:13:50 <uccus> kowey: ?
11:13:53 <kowey> or for example, we could say something like "what would happen if we didn't put the parentheses?"
11:14:03 <uccus> yeah got it
11:14:12 <kowey> well, -> is right associative, so writing a -> a -> ... etc
11:14:13 <sorear> paolino: I believe you can't. existensial types don't let you determine which they are
11:15:09 <Igloo> sorear: OK, thanks. Don't waste more time on it - I can't reproduce it on Windows not under emacs, and I can't see that the emacs bit could matter anyway
11:16:18 <sorear> too late
11:17:12 <sorear> Igloo: I've tried liftM2 (,) [6.7.20070213, 6.6, 6.4.2] [shell-mode, term-mode] , no success in any of the 6 combinations
11:17:32 <Igloo> sorear: Heh, wow, thanks!
11:17:45 <Igloo> sorear: no success == no reproduce, right?
11:17:53 <kolmodin> anyone running ghc head? does 'ghci -package unix' work for you?
11:17:54 <sorear> yes
11:18:05 <sorear> kolmodin: it's a reported bug (and btw, no(
11:18:15 <kolmodin> sorear: oh, ok. thanks
11:18:31 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1086
11:18:33 <lambdabot> Title: #1086 (unix package cannot be compiled with -fasm, due to lstat()) - GHC - Trac
11:19:07 <paolino> sorear then any function with the existential in the return value can be computed ?
11:19:14 <sorear> ?
11:19:35 <paolino> summa :: r -> r -> r
11:19:41 <paolino> the r escapes ?
11:20:06 <sorear> case parse str of SummaBox s -> summa s s  -- works, since both 's' are the same type
11:20:38 <sorear> case parse str1 of SummaBox s1 -> case parse str2 of SummaBox s2 -> summa s1 s1  -- won't work, since GHC can't prove the types match
11:20:49 <sorear> er, summa s1 s2 of course
11:22:11 <kolmodin> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2006-December/007992.html <-- fix
11:22:13 <lambdabot> Title: Building HEAD with -fasm: error in package 'unix', http://tinyurl.com/2yjrnx
11:23:21 <kolmodin> nice, it works.. :)
11:24:34 <sorear> Igloo: #1151 is my first nontrivial (== no patch) bugreport .. any glaring errors?
11:24:34 <uccus> kowey: I hope you haven't been working on it, I just rephrased it a little, could you have a look?
11:25:13 <newsham> kungheefatchoy
11:25:40 <sorear> is that a jhc tag name?
11:26:05 <newsham> ?babel cn en kung hee fat choy
11:26:05 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language cn not supported
11:26:24 <tibbe__> how can you catch ctrl+c in your program and use that close your program gratiously?
11:26:26 <Igloo> sorear: How do you mean?
11:26:47 <sorear> tibbe__: look at System.Posix.Signals
11:29:05 <tibbe__> sorear, thanks
11:29:55 <Igloo> sorear: Nice report, thanks; one thing I'm not clear on, though - does it also happen with 6.6?
11:30:20 <sorear> no
11:30:29 <kowey> uccus: maybe we could try moving the 'what happens if we omit the parentheses' up, even before 'note that the paren...'
11:30:45 <uccus> ok
11:30:48 <Igloo> sorear: (Or better still the 6.6 branch, but if you don't have one handy then don't worry, it's probably the same as 6.6)
11:31:03 <sorear> Igloo: on 6.7 in happens with 'almost every' program longer than a few lines
11:31:18 <kowey> what i was thinking was along the lines, 'what happens if...' 'since -> is right associative, a -> a -> Ordering... would be equivalent to...'
11:31:19 <Igloo> sorear: OK, thanks
11:31:35 <sorear> but a short concrete case seemed like a good thing to find for the reporting
11:32:06 <Igloo> sorear: Yeah, that's great
11:35:00 <uccus> kowey: better?
11:36:42 <tibbe__> if I have an infinite lazy list of Ints and want to write them to files in groups of 100 each how would I do that? Like: takeAndWrite 100 "filename" list
11:36:46 <kowey> uccus: yeah... now a couple more thoughts :-)
11:37:00 <uccus> sure
11:37:21 <kowey> 'It indicates that there is only one argument involved, an argument that happens to be a function.' <-- maybe this might confuse somebody ("but i thought quickSort took 3 arguments?"
11:37:49 <kowey> you could maybe say that it indicates that a -> a -> Ordering altogether form one single argument...
11:38:42 <kowey> also, I think we could push for a slightly smoother transition between the paragraph 'Coming back to...' and the one before it
11:38:49 <kowey> uccus: please yell if i'm being too picky
11:39:48 <uccus> I suppose this bit is what most new-comers will find hardest-to-grasp, so you have every right to be so
11:40:47 <uccus> but unfortunately I can't think of a trasition paragraph!
11:40:51 <uccus> help me out
11:41:01 <sorear> tibbe__: zipWithM (\n ct -> writeFile ("foo" ++ show n) ct) [0..] $ map unlines $ chunk 100 $ map show list
11:41:01 <sorear> where chop n [] = [] ; chop n xs = take n xs : chop n (drop n xs)
11:41:04 <kowey> we could say something like this... 'We need to insist to Haskell that the a -> a -> Ordering all form a single argument"
11:41:05 <sorear> good?
11:41:24 <ulfdoz> oh, 48:39h, I see progress, some more files have been compiled.
11:41:39 <kowey> (so then, we repeat that we would write it with the parens)
11:41:47 <tibbe__> sorear, thanks again
11:42:12 <kowey> and maybe something like "if you're following closely, you'll notice that _with_ the parentheses, our new type signature is actually equivalent to"
11:42:25 <sorear> tibbe__: chop and chunk should be the same - change the name in the definition or the name in the use
11:42:45 <uccus> kowey: please rewrite the whole section, and let's see if it logically leads to currying... that's what I really wanted to do
11:43:24 <tibbe__> sorear, what if the ints are in IO? ie IO [Int] ?
11:43:55 <uccus> and I guess I'm off to bed now... will write currying section tomorrow
11:44:09 <kowey> good night, uccus
11:44:19 <uccus> :)
11:44:39 <uccus> it's more like morning here ;)
11:45:19 <tibbe> sorear, lazyness + IO makes me confused about what's lazy and what's not :)
11:45:19 <sorear> tibbe__: zipWithM (\n ct -> writeFile ("foo" ++ show n) ct) [0..] . map unlines . chop 100 . map show =<< list
11:45:19 <sorear> where chop n [] = [] ; chop n xs = take n xs : chop n (drop n xs)
11:45:43 <tibbe> thanks again :)
11:45:50 <tibbe> I'll go ponder that for a minute
11:45:52 <sorear> note I changed the $-pipeline into a .-pipeline, and replaced one $ with a  =<<
11:46:04 <sorear> @type (=<<)
11:46:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:46:09 <sorear> @src =<<
11:46:09 <lambdabot> Source not found. It can only be attributed to human error.
11:46:12 <sorear> @src (=<<)
11:46:13 <lambdabot> f =<< x = x >>= f
11:46:14 <tibbe> sorear, right
11:46:33 <malsyned> Hey, is there a prettier print function?  a >>= print gets difficult to read for sufficiently large values of a (say, an HXT parse tree)
11:46:42 <sorear> no
11:46:48 <ski_> Saizan : maybe .. with recent ghc extension
11:46:58 <sorear> because Show only provides flat printign
11:47:09 <sorear> you need a less-polymorphic pretty printer
11:47:15 <sorear> @where HXT
11:47:16 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
11:47:35 <Saizan> ski_: which?
11:48:38 <sorear> malsyned: there is however a library for making it easier to write pretty printers
11:48:41 <michaelw> the Hughes pretty printing library is in libraries, isn't it?
11:48:48 <sorear> @docs Text.PrettyPrint.HughesPJ
11:48:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
11:52:15 <malsyned> hah.  OK, thanks guys.
11:53:27 <araujo> hello
11:54:09 <sorear> hello.
11:55:46 <nmessenger> hello!
11:57:01 <araujo> :-)
11:57:12 <araujo> how things go in haskell land?
11:57:22 <kolmodin> hia araujo
11:57:31 <araujo> kolmodin!!!1
11:57:32 <kolmodin> slept well? :)
11:57:36 <araujo> yes!
11:57:37 <kolmodin> ?localtime araujo
11:57:38 <lambdabot> Local time for araujo is Sat Feb 17 15:52:54
11:57:39 <araujo> haha
11:57:40 <Cheery> the lambda wheel is a bit too high.
11:57:42 <araujo> :-}
11:57:44 <kolmodin> nice :)
11:57:58 <araujo> kolmodin, i got almost a week of vacation :-)
11:58:09 <kolmodin> oh! that's very nice
11:58:13 <kolmodin> I'd like som vacation too :)
11:58:16 <kolmodin> som/some
11:58:57 <araujo> :-)
11:58:59 <Cheery> araujo: or did you possibly mean haskell land from including kernel land and user land?
11:59:47 <araujo> Cheery, haskell land like in, all the lambda monkeys in this channel
11:59:49 <araujo> ;-)
12:00:19 <ski_> Saizan : hm .. i was looking for a link but i didn't find it ..
12:01:07 <ski_> anyway, istr there's a recent ghc extension (in HEAD ??) that could possibly allow
12:01:11 <ski_> data Z a
12:01:12 <ski_>   where
12:01:19 <ski_>   Z :: IArray UArray a => Int -> Int -> Int -> Int -> UArray (Int,Int) a -> Z a
12:01:46 <sorear> gadts
12:01:55 <sorear> 6.6 even I htink
12:01:55 <ski_> (i don't recall how/if one could use record syntax with this ..)
12:01:57 <ski_> yep
12:05:53 <ski_> hm, from what i can see, it is not in 6.6 .. prolly HEAD, then
12:06:11 <allbery_b> er?  GADTs are in 6.6
12:06:25 <ski_> yes, but this was an extension to GADTs
12:06:29 <tibbe> @srcs
12:06:30 <lambdabot> src <id>. Display the implementation of a standard function
12:06:48 <sorear> @source Prelude -- you want thiss?
12:06:48 <lambdabot> Prelude -- you want thiss? not available
12:06:52 <sorear> @source Prelude
12:06:52 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
12:07:00 <ski_> (or "normalization" or whatever you want to call it)
12:07:47 <ski_> (istr it was related to the new intermediate language http://cvs.haskell.org/trac/ghc/wiki/IntermediateTypes)
12:07:50 <lambdabot> Title: IntermediateTypes - GHC - Trac
12:08:31 <tibbe> @prelude
12:08:32 <lambdabot> Unknown command, try @list
12:08:55 <tibbe> sorear, thanks, I always forget the right @cmd to use
12:09:02 <tibbe> @source System.IO
12:09:02 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
12:10:16 <hpaste>  sorear annotated "existentials can resolve ?" with "I think I'm solving the right problem this time" at http://hpaste.org/529#a2
12:10:29 <sorear> paolino: ^^^
12:11:23 <sorear> note that the parameter to myParametrisedFun is a "phantom type", it exists only to resolve overloading
12:12:37 <sorear> @users
12:12:37 <lambdabot> Maximum users seen in #haskell: 316, currently: 315 (99.7%), active: 39 (12.4%)
12:13:49 <sek> woohoo 3 more and its a new limit
12:15:32 <paolino> @amiactive
12:15:32 <lambdabot> Unknown command, try @list
12:16:14 <sorear> paolino: spoken in last 4h
12:16:17 <sorear> (so yes)
12:16:45 <sorear> (and if you haven't seen already, note the annotation)
12:17:30 <paolino> sorear, that is a bit more difficult for me
12:19:46 <paolino> shouldn't summa have the forall annotation ?
12:20:06 <tibbe> sorear, the function you gave me for chunked IO had type .... -> IO [()], is there a reason not to call sequence or something on it to get IO () ?
12:20:32 <sorear> yes.  and the reason is "I forgot"
12:20:46 <sorear> @ty zipWithM_  -- does it exist?
12:20:48 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
12:20:56 <sorear> that would work too
12:22:01 <sorear> paolino: the type of summa is forall s. Summa s => s -> s -> s.  but because of class syntax, you can't do it explicitly.
12:22:47 <sorear> paolino: myParametrisedFun needs the forall because only explicit quantification brings type variables into scope.  implicit quantifications have no scope, for compatibility with H98
12:22:57 <LoganCapaldo> @type hPrint
12:23:00 <lambdabot> Not in scope: `hPrint'
12:23:11 <sorear> @type System.IO.hPrint
12:23:13 <lambdabot> forall a. (Show a) => GHC.IOBase.Handle -> a -> IO ()
12:23:28 <sorear> @type Text.Printf.hPrintf
12:23:31 <lambdabot> forall r. (HPrintfType r) => GHC.IOBase.Handle -> String -> r
12:23:41 <sorear> @botsnack -- lagging I seem to be?
12:23:42 <lambdabot> :)
12:23:52 <sorear> ah good it's ghci's fault
12:24:21 <LoganCapaldo> So zipWithM_ hPrint [list of handles] [list of things to print] kind of thing
12:24:46 <LoganCapaldo> (that's a really contrived example)
12:46:24 <Saizan> ski_: should that work with 6.7.20070129?
12:48:58 <sjanssen> @quote
12:48:59 <lambdabot> nocotigo says: if you can't tell what encoding the code is in, i'd say you've gone too far
12:49:22 <sorear> @quote
12:49:22 <lambdabot> huschi_ says: programing in haskell seems a bit frustrating. i'm missing searching for errors :(
12:49:30 <sorear> @quote
12:49:31 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
12:50:11 <sorear> I wonder what lambdabot would look like as a HAppS program
12:50:56 <glguy> each msg from the IRC server would be a unique "request"
12:51:25 <glguy> you could defined a matching system like: h "/admin/?$" GET
12:51:37 <glguy> irc "?example" PRIVMSG
12:51:38 <glguy> maybe?
12:51:50 <sorear> yeah, yeah, I figured out that much from my musings wrt hpastebot
12:51:53 <glguy> ah
12:52:02 <sorear> i'm wondering wrt lambdabot's own architecture
12:52:12 <glguy> ah, I don't know enough about lb's internals
12:53:18 <sorear> (since dmhouse etc believes (and I agree) that the market for HAppS.Protocols.IRC is extremely small, how would you feel about it living in hpaste? wrt the current non-happs-integrated irc setup)
12:54:29 <glguy> I think that would be a wonderful development
12:54:31 <sorear> @users
12:54:31 <lambdabot> Maximum users seen in #haskell: 316, currently: 305 (96.5%), active: 40 (13.1%)
12:54:40 <glguy> I don't see why it would make sense to not include it in HAppS
12:54:48 <glguy> the demand is small because no one has really considered it
12:54:50 <glguy> :-p
12:54:57 <Cheery> I just started to wonder one thing, why some of you are so willing to help me? I've never yet seen anyone asking me to paste my programming problems on other channels I've been.
12:55:01 <glguy> but I'd love to do something like that with hpaste
12:55:21 <glguy> Cheery: it's just a part of the culture of the channel
12:55:29 <glguy> people that don't think like that keep quiet
12:55:30 <EvilTerran> half the people in here have tenure, Cheery. they've got nothing better to do. :P
12:55:36 <glguy> because the rest of us do
12:55:55 <sorear> @quote tropical
12:55:56 <lambdabot> dons says: not sure that the irc culture outside happy lambda land is always so warm and tropical
12:56:34 <therp> then lisp isn't part of lambda land for sure
12:56:38 <sjanssen> :)
12:57:05 <Cheery> it's odd but I feel it very friendly and helpful.
12:57:16 <hpaste>  nominolo pasted "How to implement monadic SF arrows?" at http://hpaste.org/531
12:57:17 <allbery_b> that's sad lambda land :)
12:57:22 <malsyned> I wonder if part of it has to do with the fact that programs tend to be more readable per line of code in Haskell.  I've noticed that, no matter how hard it is to come up with the program in the first place, the end result is always one I can understand later.
12:57:39 <nominolo> i'd appreciate any comments on the above paste
12:57:42 <therp> cheery: you are not the first to recognize that. #haskell is indeed a great place to hang out.
12:58:20 * glguy has started playin with Factor, they seem pretty friendly over in #concatenative (so far :) )
12:58:36 <pejo> EvilTerran, my impression is that most people in here don't have tenure.
12:58:51 <TomMD> So, I'm moving back to a Debian based distro because I am tired of yum.  I was thinking of trying Ubuntu (having used FC, Slackware, Debian, TSL in the past), but figured I'd ask for any opinions.
12:58:54 <EvilTerran> pejo, it was a joke :P
12:59:44 <pejo> TomMD, feels like debian, but with modern applications. :P
13:00:15 <malsyned> TomMD: Once you enable the Universe and Multiverse repositories, it'll feel like Debian with a default-usable desktop environment and newer packages.
13:01:14 <sorear> TomMD: I've used debian sid for several months now.  The worst problem I've experienced so far is ...
13:01:21 <sorear> a misspelled startup message.
13:01:27 <TomMD> I'm downloading 6.10 right now.  Anyone know about support for.... ipw2200, haskell, or cryptfs?
13:01:31 <sorear> (yes, I reported it as a bug)
13:01:47 <glguy> TomMD: openbsd ought to handle those things
13:01:51 <sorear> and yes sid has modern programs
13:02:05 <sorear> (sid == unstable, for those curious)
13:02:08 <TomMD> lol - glguy - I know, but there are other issues with using *BSD right now.
13:02:17 <glguy> has linux integrated it's iwconfig and ifconfig yet?
13:02:26 <TomMD> glguy - No
13:02:31 <glguy> :(
13:02:45 <sorear> TomMD: then again, I'm also a hardcore console freak.
13:02:45 <glguy> do all the wireless devices use the same config program at least?
13:02:50 <sorear> yes
13:03:18 <malsyned> TomMD: The latest Ubuntu comes with ghc 6.4.2.  That hasn't been a problem for me yet.
13:03:23 <malsyned> but it's not the newest.
13:03:50 <sorear> glguy: actually if you use the high level interface (referring to debian-unstable's ifupdown here) the wired and wireless configuration IS unified.
13:03:50 <pejo> X allows you to multiplex more x-terms though.
13:04:04 <glguy> sorear: ah, that's a start then
13:04:10 <sorear> I've never used more than 6
13:04:24 <TomMD> I'll darcs get 6.6 and probably have to d/l the firmware for my wireless.  It shouldn't be too bad, better than dealing with yum sillyness.
13:04:35 <sorear> (the debian default count of vt's)
13:04:37 <pejo> sorear, hm, Are you running everything in Emacs, including your irc-client?
13:04:50 <hpaste>  (anonymous) annotated "gensort" with "(no title)" at http://hpaste.org/530#a2
13:04:54 <sorear> pejo: getting there
13:05:18 <TomMD> ?users
13:05:18 <lambdabot> Maximum users seen in #haskell: 316, currently: 307 (97.2%), active: 43 (14.0%)
13:05:18 <sorear> pejo: ERC + Haskellmode/shim + shell-mode
13:05:31 <sorear> pejo: I still use elinks and mutt however :(
13:05:33 <pejo> sorear, suddenly it makes sense that you manage with 6 vtys.
13:05:36 <sorear> and nethack
13:06:03 <sjanssen> sorear: so you don't run X at all?
13:06:08 <malsyned> refresh me: is "arr" for Arrows analogous to "return" for monads?
13:06:16 <sorear> malsyned: yes
13:06:21 <malsyned> thx
13:06:25 <sorear> sjanssen: basically
13:06:43 <sorear> sjanssen: I have X installed, and I run it when I need to read a .p{s,df}
13:06:47 <Cheery> I've not yet understood arrows.
13:07:04 <sorear> sjanssen: spj is too interesting to shun :)
13:07:07 <sjanssen> sorear: you weren't kidding when you said "hardcore" :)
13:07:26 <Cheery> where they came from in the first place?
13:07:26 <pejo> sorear, are you aware of the pdf2txt program?
13:07:29 <malsyned> Cheery: I'm trying to.  There aren't nearly as many tutorials as there are for Monads, and the wikibook isn't as fleshed out as I'd like, so I'm trying to get hands-on with the HXT libraries.
13:08:19 <sorear> pejo: yes.  IME it generates results sufficiently bad to, all by itself, justify installing, configuring, and keeping updated X.org
13:08:46 <coffee-mug> using haskell with ruby is nirvana
13:09:29 <pejo> sorear, don't you ever leave a "task" that you want to return to later, to jump on to something else that you need fresh windows for?
13:09:46 <araujo> mmm...
13:09:50 <araujo> sorear, hi there
13:10:07 <araujo> sorear, how do i change the address of a project for the 'where' command on lambdabot ?
13:10:17 <sorear> pejo: sure!  SysV job control rocks
13:10:27 <sorear> (or C-x b for things in emacs
13:10:34 <glguy> araujo: ?where+ what where
13:10:35 <malsyned> sorear: it's a fine line between l33tness and madness.
13:10:38 <sorear> araujo: @where+ nname address
13:10:54 <sorear> (unprivileged btw)
13:10:56 <pejo> And people call me old fashioned for running twm.
13:10:58 <malsyned> and that line is located at or around "SysV job control rocks".
13:10:59 <araujo> @where himerge http://www.fmap.us/himerge.html
13:10:59 <lambdabot> http://www.haskell.org/~luisfaraujo/himerge/
13:10:59 <sorear> malsyned: agreed.
13:11:08 <araujo> @where+ himerge http://www.fmap.us/himerge.html
13:11:08 <lambdabot> Done.
13:11:16 <araujo> btw, anybody uses it here?
13:11:24 * araujo needs help catching a bug
13:11:36 <malsyned> what is it?
13:11:47 <araujo> A GUI front-end for portage
13:11:54 <sorear> nominolo: you should look into the ListTDoneRight
13:12:02 <glguy> I bet sorear uses it then
13:12:03 <glguy> ;)
13:12:05 <malsyned> ah.  no longer a Gentoo user
13:12:45 <malsyned> I got a real job and didn't have enough free time to wait for programs to build, so I switched to Ubuntu.
13:12:52 <sorear> glguy: no, I use ion3.
13:13:04 <pejo> malsyned, heh. That's a quote worht keeping.
13:13:06 <glguy> sorear: no, I meant the portage front-end
13:13:11 <glguy> sorear: the Gentoo GUI app
13:13:13 <nominolo> sorear: thanks
13:13:16 <sorear> nah, debian here
13:13:23 <glguy> :-p it's a "joke"
13:13:38 <araujo> we all know gentoo has the best support for haskell anyway :-}
13:13:42 <malsyned> pejo: it's all yours.
13:13:48 <sorear> funny how the person with the most stick-in-the-mud tendencies is one of the youngest
13:14:40 <malsyned> sorear: Seriously.  I was 20 before I started shunning all technology developed after 1990.  You've got quite the head-start.
13:15:11 <ddarius> sorear: That is not surprising to me at all.
13:15:22 <ddarius> sorear: Also, you may be mistaken.
13:15:40 <dmead> :>
13:19:28 <malsyned> Is there a function f such that (>>=):(>>>)::(>>):f ?
13:19:48 <malsyned> (my knowledge of arrows is shakey at best, so apologies if that question is nonsensical)
13:20:04 <sorear> Arrow a => a b c -> a b d -> a b d, keeping the effects of the first?
13:20:18 <sorear> @ty \a b -> (a &&& b) >>> arr snd
13:20:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b c'
13:20:25 <sorear> @pl \a b -> (a &&& b) >>> arr snd
13:20:26 <lambdabot> flip flip (arr snd) . ((>>>) .) . (&&&)
13:20:37 * sorear checks the docs
13:20:50 <malsyned> sorear: what docs?  I'm hungry for info about Arrows.
13:21:10 <sorear> @docs Control.Arrow
13:21:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
13:21:19 <sorear> @pl \a b -> (a &&& b) >>^ snd
13:21:19 <lambdabot> flip flip snd . ((>>^) .) . (&&&)
13:21:43 <EvilTerran> huh. flip flip.
13:22:00 * sorear flips
13:22:14 <sorear> @quote flip
13:22:15 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
13:22:17 <Cheery> I love flip. ^^
13:22:22 <sorear> @ty flip flip
13:22:25 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
13:22:28 <EvilTerran> ?type flip flip flip
13:22:30 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
13:23:00 <sorear> @ty flip flip flip flip
13:23:02 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:23:05 <EvilTerran> this could rapidly become incomprehensible
13:23:17 <Cheery> if you love flip, you also may like dig and bury.
13:23:18 <sorear> @ty flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
13:23:21 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:23:37 <sorear> @ty flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
13:23:39 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:23:45 <Cheery> dig f x y z = f z x y
13:23:52 <sorear> @ty flip flip flip flip flip flip
13:23:55 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:23:56 <Cheery> bury f x y z = f y z x
13:23:58 <sorear> @ty flip flip flip flip flip
13:24:01 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:24:16 <sjanssen> @djinn (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:24:17 <lambdabot> f a b = a b (\ c d e -> c e d)
13:24:39 <sorear> @pl flip . flip
13:24:40 <lambdabot> id
13:24:42 <Cheery> I personally have these in my mind as a joke, but sometimes they feel as useful as flip.
13:25:27 <Cheery> > let dig f x y z = f z x y in dig foldr 20 [1,2,3] (*)
13:25:29 <lambdabot>  120
13:25:42 <sorear> @let is it working yet = 0
13:25:43 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:25:54 <Cheery> hmm, wait, that was bury.
13:26:08 <EvilTerran> with template haskell, could one devise something :: (a1 -> ... -> aN -> b) -> aN -> a1 -> ... -> aN-1 -> b ?
13:26:08 <sorear> > bitSize (0::Word) -- is it moved yet?
13:26:10 <lambdabot>  32
13:26:13 <Cheery> dig would be like:
13:26:21 <sorear> EvilTerran: ooh! roll!
13:26:25 <EvilTerran> yeah!
13:26:30 * sorear was a forther once
13:26:42 <sorear> or I should say ROLL
13:26:52 <EvilTerran> i write postscript by hand, so to me it's lowercase.
13:27:08 <sjanssen> EvilTerran: that might even be possible with typeclasses
13:27:31 <sorear> EvilTerran: you can't, it's ambiguous
13:27:33 <EvilTerran> sjanssen, surely there'd be kinding problems?
13:28:17 <EvilTerran> it wouldn't just be roll :: <that type>, i was thinking more of roll :: Integer -> <that type>
13:28:43 <EvilTerran> (roll n f) would roll the first n arguments of f
13:29:27 <nominolo> ?ty rofl
13:29:28 <sorear> EvilTerran: you can't do dependant programming on the value level like that.
13:29:30 <lambdabot> Not in scope: `rofl'
13:29:58 <EvilTerran> okay... i'm not familiar with template haskell beyond the basic premise
13:30:02 <sorear> EvilTerran: you CAN do dependant programming on the type level - http://hpaste.org/522#a1
13:30:04 <sjanssen> but n could be a type integer
13:30:26 <sorear> EvilTerran: but I'm not sure how to do HOFs in the context of that paste
13:30:46 * sorear is overly proud of that paste
13:32:46 <tibbe> @paste
13:32:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:33:00 <Cheery> or hmm, dig is actually ambiguous thing.
13:33:22 <hpaste>  (anonymous) annotated "gensort" with "(no title)" at http://hpaste.org/530#a3
13:33:32 <Cheery> or wait, it isn't I just put them wrong way around.
13:33:38 <hpaste>  (anonymous) annotated "gensort" with "(no title)" at http://hpaste.org/530#a4
13:34:00 <Cheery> > let bury f x y z = f z x y n bury foldr 20 [2,3] (*)
13:34:01 <lambdabot>  Parse error
13:34:14 <Cheery> > let bury f x y z = f z x y n in bury foldr 20 [2,3] (*)
13:34:15 <lambdabot>   Not in scope: `n'
13:34:23 <Cheery> huh
13:34:29 <Saizan> do you think is reasonable that using _ instead of a pattern match with a contructor gives a type error?
13:34:30 <Cheery> > let bury f x y z = f z x y in bury foldr 20 [2,3] (*)
13:34:32 <lambdabot>  120
13:34:47 <hpaste>  tibbe pasted "Reading serialized lists" at http://hpaste.org/532
13:34:52 <xerox> Saizan - How does that happen?
13:35:04 <Cheery> > let dig f x y z = f y z x in dig foldr [2,3] (*) 20
13:35:05 <lambdabot>  120
13:35:07 <tibbe> input on reading serialized lists is greatly appreciated
13:35:12 <ndm> Anyone want a challenge? Prove that http://darcs.haskell.org/nofib/imaginary/digits-of-e1/Main.lhs doesn't crash with a division by zero error in ratTrans
13:35:13 <Saizan> @paste
13:35:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:35:28 * ndm is way not clever enough to proove that!
13:36:03 <hpaste>  tibbe annotated "Reading serialized lists" with "Type error" at http://hpaste.org/532#a1
13:36:03 * sorear accepts ndm's challenge
13:36:18 <ndm> sorear: after taking a look at the code?
13:36:21 <Cheery> btw, my bury and dig does very little sense here.
13:36:39 <Cheery> it's like they would work reverse ways. :)
13:37:00 <Cheery> the funniest thing is that my brains wired them same way.
13:37:11 <Cheery> intuitive haskell.
13:37:18 <hpaste>  Saizan annotated "typeclass restriction" with "strange type error with phantom parameter" at http://hpaste.org/528#a1
13:38:17 <Saizan> xerox: there
13:38:41 <tibbe> could someone please have a look at my type error? it's only two lines of code: http://hpaste.org/532#a1
13:39:30 <sjanssen> Saizan: ghc isn't smart enough to use the class dictionary packaged in the "Z b" to create a new "Z b"
13:40:03 <Saizan> sjassen: but if i pattern match on the first Z b, it is
13:40:10 <Saizan> see the last line
13:40:17 <Cheery> > foldr (*) 20 [2,3]
13:40:18 <lambdabot>  120
13:40:37 <sjanssen> Saizan: oh, I guess it is
13:41:01 <Saizan> well only with HEAD
13:41:04 <sjanssen> Saizan: by pattern matching against it, you're showing that the dictionary is really there -- because the Z b isn't bottom
13:41:10 <Cheery> ah, now I understand why it makes no sense. :)
13:41:19 <sorear> ndm: ratTrans only crashes (because of the first term in the guard) if both C and D are zero, a property which is preserved by recursion, and the only non-recursive call site doesn't provide such values.  Within my normal definition of self-convincement, that function cannot crash.
13:42:08 <Cheery> f y z x = dig f x y z
13:42:20 <sorear> ndm: of course my first experiment in machine-"checked" formalism showed that proving (N,0,+) formed a monoid was quite difficult
13:42:47 <Cheery> my brains write the code different than my brains read it.
13:42:55 <ndm> sorear: ah yes, i see that - the weird signum and abs checks that d can't be zero...
13:43:02 <sorear> ndm: it might have been easier if I had a proper (esp. strongly normalizing, but UI issues also) proof system
13:43:08 <Saizan> sjanseen: so there's no way around this?
13:43:26 <Cheery> reading reduction error.
13:43:28 <sjanssen> Saizan: I don't there _can_ be a way around this
13:43:32 <sorear> ndm: LoganCapaldo asked if Haskell could prove + was commutative, so I did so as a curry-howard expiriment
13:43:53 <sjanssen> Saizan: what if I called: foo x undefined f ?
13:44:02 <ndm> sorear: indeed, proof is still harder than it should be#
13:44:05 <sorear> (and I just mentioned strong normalisation, so you don't need to)
13:44:06 <Cheery> gah, good night.
13:45:03 <Saizan> sjassen: heh, right, it's just that threading around dictionaries doesn't map nicely with the way a think about types..
13:45:31 <tibbe> chunkDecodeFiles fs = ((mapM decodeFile fs) :: Binary a => IO [[a]]) >>= return . concat
13:45:42 <tibbe> is there a way to avoid the type declaration ^^ ?
13:45:43 <sjanssen> Saizan: is it strictly necessary to use UArrays here?
13:45:58 <sjanssen> all of your troubles disappear if you use normal arrays
13:46:34 <sorear> ndm: I imagine CaTCH took less than five minutes and considerably fewer neurons on that file? :)
13:47:09 <ndm> sorear: it wasn't able to proove it for the division by zero, but it got the other two pattern match errors
13:47:37 <ndm> sorear: i think the reason it doesn't get the remaining one is due to the abstract intrepretation over abs not being defined yet - i have it returning anything, which is clearly not true!
13:48:47 <sorear> is the reason you have an abstract abs something fundamental, or do you just not want to manipulate arbitrary subsets of [-2^29-1..2^29]?
13:49:04 <ndm> i abstract Int into Negative | Zero | Positive
13:49:14 <ndm> (although I'm currently mullling over adding in One)
13:49:41 <ndm> the analysis works on algebraic data structures, so having millions of elements in one is infeasible
13:50:22 <ndm> i abstract data Char = Char as well, everything else remains identical
13:51:37 <sorear> mm, Word64! :p
13:51:53 <sorear> oh wait that's not H98
13:51:57 <LoganCapaldo> Now with 32 more word processyness
13:52:04 <sorear> Double it then
13:52:11 <ndm> everything is + | 0 | -, Double included
13:52:24 <ndm> int/double conversion is just id :)
13:52:29 <sorear> which category is NaN?
13:53:06 * sorear supposes 0/0 = "+0-" would do just as well as having NaN
13:53:07 <ndm> none
13:53:27 <ndm> i haven't thought about NaN at all
13:53:31 <ndm> > 0 / 0
13:53:33 <lambdabot>  NaN
13:53:39 <ndm> ah, i make it a pattern match error
13:53:43 <dmhouse> ?hoogle NaN
13:53:44 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
13:53:53 <ndm> conservative, so thats ok :)
13:54:21 <sorear> foo x | x == x = ()   -- does this function have preconditions in CaTCH?
13:54:58 <sorear> > let foo x | x == x = () in foo (0/0)
13:55:00 <lambdabot>   Non-exhaustive patterns in function foo
13:55:37 <ndm> foo, yes, that x == x = True
13:55:52 <ndm> if you call it on bools, it will succeed, if you call it with an int it will fail
13:55:56 <sorear> can't be too clever now :)
13:56:04 <sorear> int?
13:56:06 <orbitz> is Hudak's books source online?
13:56:15 <sorear> oh right + == + = ?
13:56:21 <ndm> indeed :)
13:56:39 <dmhouse> > let foo x = x in foo (0/0)
13:56:41 <lambdabot>  NaN
13:57:22 <dmhouse> > let foo x = x == x in foo (0/0)
13:57:24 <lambdabot>  False
13:57:37 <dmhouse> > (0/0) == (0/0)
13:57:38 <lambdabot>  False
13:57:45 <ndm> yeah, x == x = False :)
13:57:56 <dmhouse> Conclusion: (==) is not reflexive.
13:57:59 <sorear> @src isNan
13:58:00 <lambdabot> Source not found. You speak an infinite deal of nothing
13:58:04 <sorear> @src isNaN
13:58:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:58:12 <ndm> although i bet some algorithms will fail on that, if your == is not all 3 properties then Data.Map can loop
13:58:13 <dmhouse> > let x = 0/0 in x == x
13:58:15 <lambdabot>  False
13:58:26 <sorear> isNaN x  is normally defined as  x /= x
13:58:30 <sorear> join (/=)
13:58:39 <rahikkala> 0/0 does sound like an infinite deal of nothing to me...
13:59:09 <sorear> @check join (==) :: Float -> Float -> Bool
13:59:11 <lambdabot>  Couldn't match expected type `Float -> Bool'
13:59:18 <sorear> @check (join (==) :: Float -> Float -> Bool)
13:59:19 <lambdabot>  Couldn't match expected type `Float -> Bool'
13:59:26 <sorear> @check (join (==) :: Float -> Bool)
13:59:28 <lambdabot>  OK, passed 500 tests.
13:59:30 <sorear> @scheck (join (==) :: Float -> Bool)
13:59:32 <lambdabot>   Completed 79 test(s) without failure.
13:59:41 <sorear> hmm, @check doesn't make nans
13:59:45 <sorear> bad @check!
14:00:11 <dmhouse> ?check (\x y -> x/y == x/y :: Float -> Float -> Bool)
14:00:12 <lambdabot>  Couldn't match expected type `Float -> Float -> Bool'
14:00:24 <dmhouse> ?check (\x y -> (x/y) == (x/y) :: Float -> Float -> Bool)
14:00:26 <lambdabot>  Couldn't match expected type `Float -> Float -> Bool'
14:00:41 <sorear> dmhouse: let lambda meta rule
14:00:41 <hyrax42> ?src interact
14:00:42 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:00:50 <nmessenger> ?check (\x y -> (x/y) == (x/y)) :: Float -> Float -> Bool
14:00:51 <lambdabot>  Falsifiable, after 0 tests: 0.0, 0.0
14:00:52 <hyrax42> that's what I thought
14:00:52 <dmhouse> sorear: ?
14:00:57 <dmhouse> Ah.
14:01:39 <dmhouse> ?check (\x y -> (x::Float)/(y::Float) == x/y)
14:01:41 <lambdabot>  Falsifiable, after 3 tests: 0.0, 0.0
14:04:14 <hyrax42> last paragraph here makes little sense? http://cod3po37ry.blogspot.com/2007/02/more-on-haskell-io-and-interact.html
14:04:17 <lambdabot> Title: Code Poetry: More on Haskell IO and interact, http://tinyurl.com/3aaqbc
14:04:23 <hyrax42> or am I ignorant of history?
14:05:24 <augustss> hyrax42: I think the last paragraph is nonsense
14:05:27 <ndm> hyrax42: read the history of haskell post, in the topic of this channel
14:05:39 <ndm> i think thats what he's referring
14:06:05 <augustss> it's true that interact predates monadic IO, but I still think it's a relevant function
14:06:23 <hyrax42> but he makes it sound like it doesn't use monadic io
14:06:49 <ndm> it didn't, when there wasn't monadic IO
14:06:51 <augustss> I know.  someone should show him how it's defined
14:06:55 <augustss> @src interact
14:06:56 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:07:02 <sorear> hyrax42: interact cannot be written using Haskell 98 monadic IO
14:07:14 <augustss> huh?
14:07:16 <dmhouse> sorear: ?
14:07:22 <sorear> (ignoreing getContents)
14:07:32 <dmhouse> Why would you ignore getContents?
14:07:52 <sorear> because it has special magic behavior
14:07:56 <dmhouse> It's in the report: http://haskell.org/onlinereport/io-13.html
14:07:57 <lambdabot> Title: The Haskell 98 Report: Basic Input/Output
14:07:59 <sorear> @src getContents
14:08:00 <lambdabot> getContents = hGetContents stdin
14:08:11 <dmhouse> "Input Functions" section on that page.
14:08:30 <augustss> yep, hGetContents has special magic.  as does accumArray, and other functions
14:08:35 <ndm> sorear: it just uses unsafeInterleaveIO - all the array code uses unsafePerformIO underneath - they are just implementation details
14:09:02 <ndm> (at least the Yhc array code)
14:09:35 <sorear> well, unsafeInterleaveIO isn't in the report
14:09:46 <augustss> no, but hGetContents is
14:09:55 <sorear> H' monadic IO is more powerful than H98 monadic IO
14:10:49 <dmhouse> sorear: so you're saying it's impossible to write hGetContents using, say, getChar and putChar?
14:10:55 <dmhouse> Because of laziness?
14:11:00 <sorear> right
14:11:09 <augustss> yes, it is
14:11:16 <augustss> impossible
14:12:16 <sorear> " with the right configuration of bad sectors, a lazy getContents can have a whnf while a strict one doesn't "
14:12:47 * sorear supposes _|_ is fairly nonsensical in the context of IO
14:13:00 <dmhouse> And how does it change in the context of haskell-prime?
14:13:21 <sorear> System.IO.Unsafe ?
14:13:22 <ndm> are they speccing libraries, or just ignoring that whole issue?
14:13:40 <sorear> I thought they were.  my bad.
14:13:43 <nmessenger> I've never understood unsafeInterleaveIO before, does it just perform the IO as the constructors are requested lazily?
14:13:50 <sorear> yes
14:13:59 <sorear> exaclty what it does
14:14:18 <dmhouse> ndm: they are involving libraries, I think.
14:14:27 <dmhouse> It's certainly on the status report.
14:14:36 <ndm> dmhouse: and they were finishing within a year when they first started :)
14:14:40 <sorear> ch <- unsafeInterleaveIO getChar -- read at most 1 char if ch is demanded, if ch is never demanded a character might not be read
14:14:53 <nmessenger> the documentation was a little vague iirc
14:15:15 <ndm> augustss: am looking forward to your talk next week :)
14:15:32 <sorear> confrencey-thing?
14:15:50 <ndm> Fun In The Afternoon - slightly conferency, but free to go to, and just an afternoon
14:15:52 <augustss> ndm: dunno, I've not decided what to talk about yet
14:15:52 <steven_ashley> sorear: is it perfectly safe to use unsafeIO to create an MVar provided that you explicitally type it?
14:15:54 <EvilTerran> if you want to force evaluation of an expression in the middle of an IO do{}, but don't care about the value, how do you do that?
14:16:06 <dmhouse> ?hoogle evaluate
14:16:07 <lambdabot> Control.Exception.evaluate :: a -> IO a
14:16:07 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
14:16:10 <dmhouse> EvilTerran: use that.
14:16:11 <sorear> do { .. ; evaluate x ; .. }
14:16:33 <EvilTerran> k. i've been using do { ...; x `seq` return (); ... }...
14:16:34 <dmhouse> steven_ashley: as long as the MVar has a monomorphic type.
14:16:46 <dmhouse> EvilTerran: I don't think that'd work if x were an IO action.
14:16:56 <sorear> steven_ashley: Yes, *grimace*, but don't do that if you can avoid it - it violates the zero-infinity rule hard
14:17:13 <dmhouse> Evaluating x to whnf (i.e., seqing it) wouldn't evaluate the action.
14:17:28 <steven_ashley> okay, thanks :)
14:18:27 <augustss> ndm: did you go to the previous Fun in the Afternoon?  How many people attendending?
14:18:48 <edwinb> they filled a big room
14:18:49 <ndm> augustss: i went to the last one, about 60+ perhaps
14:18:55 <sorear> steven_ashley: my voodoo knowledge says that {-# NOINLINE myGlobalMVar #-} is needed to prevent debugging fun
14:18:59 <dmhouse> augustss: what are you speaking on?
14:19:38 <tibbe_> is there a nice way to do logging in haskell? more than the usual inline: log level msg statements in IO like imperative languages
14:19:43 <augustss> dmhouse: I've not decided yet.  guess I talk about something work related without revealing anything :)
14:19:56 <dmhouse> tibbe_: Writer.
14:20:00 <sorear> @where HsLogger
14:20:00 <lambdabot> http://software.complete.org/hslogger
14:20:01 <edwinb> I'm fascinated by this talk by Nils Anders Danielsson...
14:20:13 <steven_ashley> sorear: heh, I think I will come up with another solution
14:20:23 <augustss> edwinb: yes, that sounds very interesting
14:20:53 <ndm> @where fita
14:20:53 <lambdabot> I know nothing about fita.
14:21:18 <tibbe_> dmhouse, right, I should have remembered that
14:21:53 <augustss> ndm: 60 people, huh.  that's pretty big
14:22:19 <ndm> augustss: that was the first one, so may have dropped off a bit - but yeah, pretty big
14:22:24 <ndm> @quote Colin
14:22:24 <lambdabot> No quotes match. My pet ferret can type better than you!
14:22:42 <ndm> @remember Colin Yes, people don't write lazy functional programs in Haskell any more.  In the Era of Monadic Enlightenment, obfuscated imperative programming is the Way To Go.   :-\   :-)
14:22:43 <lambdabot> Done.
14:22:46 <ndm> @quote Colin
14:22:47 <lambdabot> Colin says: Yes, people don't write lazy functional programs in Haskell any more.  In the Era of Monadic Enlightenment, obfuscated imperative programming is the Way To Go.   :-\   :-)
14:23:12 <augustss> which colin is this?
14:23:47 <ndm> Colin Runciman
14:24:04 <augustss> I thought it sounded like grumpy Runciman :)
14:24:29 <sorear> @ysers
14:24:30 <lambdabot> Maximum users seen in #haskell: 316, currently: 302 (95.6%), active: 49 (16.2%)
14:24:43 <augustss> But I think he's right.  People seem far to obcessed with monads.
14:24:46 <edwinb> heh
14:25:00 <ndm> he's my supervisor :)
14:25:21 <augustss> ndm: I thought he might be.
14:27:32 <Korollary> augustss: what would you offer an example for that obsession?
14:27:38 <Korollary> +as
14:28:03 <augustss> 5 gazillion monad tutorials
14:28:55 <Korollary> That's not an obsession in code form, though. I thought he meant programs obsessed with monads.
14:29:59 <augustss> Well, I see plenty of code that is done in the IO monad that doesn't belong there at all.
14:30:40 <Korollary> But I doubt that it's because the author truly loved monads. He probably just didn't know better or didn't care.
14:31:20 <augustss> Probably.
14:31:50 <Korollary> augustss: How is work going? Any more people who know haskell?
14:33:18 <augustss> hmmm, not that many yet.  we're expecting more users in a month or so.  we are deliberately holding back so we can get the infrastructure working
14:36:12 <hpaste>  malsyned pasted "RSS interpreter, returns [] instead of a list of pairs" at http://hpaste.org/533
14:36:38 <malsyned> Would anybody mind taking a look at that and helping me figure out why it's doing what it's doing instead of what I want it to do? ;)
14:38:26 <hpaste>  malsyned annotated "RSS interpreter, returns [] instead of a list of pairs" with "(no title)" at http://hpaste.org/533#a1
14:39:14 <sorear> ooh ...
14:39:32 <sorear> curious about this "work" thing, google, #2
14:39:53 <sorear> Lennart Augustsson - Wikipedia ...
14:41:30 <augustss> wikipedia doesn't know about my current job :)
14:42:09 <edwinb> heh, I see dependent-types.org/ gets me Cayenne ;)
14:42:15 <augustss> I'm developing a DSEL for describing pricing models at Credit Suisse
14:42:24 <augustss> edwinb: yep :)
14:43:52 <sorear> talk about google karma.  top three hits in order: staff page, wikipedia page, personal page.
14:44:27 <_frederik_> hello!
14:44:49 <_frederik_> what paper do we recommend to non-FP, non-category-theory people for learning monads?
14:44:50 <augustss> I like that you can google my first name and get a hit :)
14:45:00 <_frederik_> Wadler, "Comprehending Monads"?
14:45:47 <augustss> _frederik_: I like sigfpe's tutorial
14:45:51 * sorear tries that on his own
14:46:02 * edwinb tries it too ;)
14:46:24 <edwinb> hmm, 29th. Needs work!
14:46:26 <augustss> the trick is to have an unusual name
14:46:31 <edwinb> I do...
14:46:36 <sorear> Stefan-Bolzmann law comes higher... twice
14:46:50 <_frederik_> i'm about 75th
14:46:58 <sorear> awful lot of slavs
14:47:22 <TomMD> I don't have a prayer
14:47:56 <sorear> I suppose it "helps" that I don't have a canonical homepage, just a bunch of references to me in random IRC logs and mailing list archives
14:49:28 <augustss> oh, you need a home page.
14:49:32 <sorear> my first name is quite unusual here (SD), but not elsewhere
14:49:35 <augustss> sorear: you don't have a blog?
14:49:49 <edwinb> everyone and his dog has a blog...
14:50:01 <augustss> not me! ;)
14:50:13 <ndm> cool, I get 1, 2, 5, 6, 7, 8, 9 :)
14:50:15 <edwinb> well done!
14:50:34 <sorear> is that for "neil" ?
14:50:39 <edwinb> ndm: not on your first name you don't...
14:50:50 <ndm> edwinb: oh, yeah, no chance of that
14:50:57 <_frederik_> augustss: thanks
14:51:46 <pejo> If you get to select name - make sure you don't get one which is already taken by a professor in a similar subject elsewhere.
14:52:20 <sorear> for someone with a very common Irish surname and #1 google on fullname, I am not in #300 firstname
14:52:51 <sorear> then again common Slav firstname + common Irish surname /= common fullname
14:52:55 <_frederik_> pejo: in that situation i think i would at least change the spelling of my name
14:53:04 <malsyned> anybody here have any experience with HXT?
14:53:16 <sorear> Cale
14:53:24 <ndm> I'm 65 on Neil alone, not bad - given there are real famous Neil's
14:53:25 <malsyned> @seen Cale
14:53:26 <lambdabot> I saw Cale leaving #oasis, #ghc, #haskell-overflow and #haskell 10h 14m 17s ago, and .
14:53:33 <pejo> _frederik_, or put in a middle name!
14:53:41 <augustss> There are two John Hughes in computer science.  And two David Turner.
14:54:09 <pejo> And two David Walker. Explains his long dblp-entry.
14:54:11 <_frederik_> pejo: yeah. i count myself lucky that as a teenager i started using the scandinavian 'frederik' instead of 'frederick', which is much commoner
14:54:11 <malsyned> wow.  bug in lambdabot there.
14:54:24 <sorear> at least three david wheelers
14:54:49 <malsyned> OK, anyone familiar with the List Arrow, then?
14:55:07 <sorear> >420, "stefan"
14:56:10 <sorear> >520
14:56:28 <malsyned> *sigh*, oh well.
14:56:48 <augustss> malsyned: I generally stay away from arrows :)
14:57:20 <sorear> stefan wehr #576
14:57:24 <malsyned> augustss: this is my first encounter with them, and it is not all smooth sailing.  although it wasn't with monads, either.
14:58:01 <sorear> stefan holdermans #599
14:58:09 <augustss> malsyned: arrow syntax confuses me.  and the transformation to non-arrow syntax is not local
14:58:50 <malsyned> I don't think I'm using any arrow syntax.  Just the operators, like >>> and &&&.  although &&& isn't cooperating for me right now.
14:59:01 <augustss> oh, ok
14:59:19 <augustss> :t (&&&)
14:59:22 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:59:35 <sorear> >700
15:01:19 <sorear> >850
15:02:30 <sorear> I don't match ANY google result for "stefan"
15:02:37 <sorear> end of list:     Web                                                     Results 921 - 925 of about 128,000,000 for stefan. (0.33 seconds)
15:03:28 <sorear> hmm. "stefan o'rear" -> all top 10
15:03:32 <sorear> haskell stuff
15:03:57 <edwinb> there is an 'Edwin Brady Construction' company who I have been trying to defeat for a while, and have finally succeeded ;)
15:04:09 <augustss> sorear: you must be in the remaining 127999000 entries :)
15:04:10 <pejo> edwinb, heh, how did you do it?
15:04:28 <edwinb> I think putting more junk on the web helped ;)
15:05:01 <augustss> edwinb: you need to make a proff, or something, "The Edwin Brady Construction"
15:05:01 <sorear> "stefan orear" -> top 5, incl. family personal, 2x debian-user, 2x USAMO qualifiers list
15:05:51 <augustss> "This looks like a multi-fibrular divergence, we must use the Edwin Brady construction".
15:06:11 <edwinb> I'll get right onto it, just as soon as I work out what a multi-fibrular divergence is
15:06:13 <tibbe_> I find Data.Sequence very cumbersome to use as a queue, pehaps I'm doing something wrong, how do I dequeue an element and get the tail of the queueu?
15:06:35 <sorear> headView, tailView
15:07:21 <sorear> my father is #17 for "orear"
15:07:29 <tibbe_> sorear, they're not in the docs!?!
15:07:33 <tibbe_> @docs Data.Sequence
15:07:34 <lambdabot> Data.Sequence not available
15:07:40 * ddarius could probably beat out Derek Elkins of derekelkins.com if he makes some webcontent like a blog, or some ridicularity like that.
15:08:13 <tibbe_> @paste
15:08:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:08:26 <sorear> I'm not in top100 for o'rear or orear
15:08:54 <tibbe_> @hoogle headView
15:08:54 <lambdabot> No matches found
15:09:07 <sorear> gah, I am 9 of the top 10 for "sorear"
15:09:25 <sorear> oh, hpaste is on google
15:10:48 <EvilTerran> hm. I have a top-level expression of the form sequence_ [print $ ... | i <- [0..]] ; does this sort of thing get cached?
15:11:22 <EvilTerran> because it seems to be
15:11:59 <malsyned> hah.  My father and I have the same name name, and you have to read through three pages of me on Google to get to him.  pwned.
15:12:07 <sorear> top level expressions w/o arguments are called "CAFs" and are cached
15:12:08 <malsyned> s/name name/name/
15:12:12 <tibbe_> sorear, sorry but I can't find those functions
15:12:34 <sorear> I probably have the names wrong.
15:12:52 <EvilTerran> sorear, even ones with side-effects?
15:12:54 <sorear> viewl, viewr
15:13:00 <tibbe_> sorear, and then?
15:13:15 <sorear> EvilTerran: if you aren't using unsafePerformIO, you have no side effects.
15:13:35 <sorear> (and yes, cafs with side effects are cached)
15:13:54 <tibbe_> sorear, I think I get it
15:13:57 <EvilTerran> sorry, i should elaborate. i'm loading this into hugs and then evaluating it by requesting it by name.
15:14:11 <EvilTerran> if that affects anything
15:14:50 <xpika> does anyone know anything stronger than an "SCC", ie like a full mesh components?
15:14:54 <EvilTerran> ah, never mind, i think i've figured out what i want to be doing.
15:15:17 <sorear> xpika: connected components
15:15:32 <sorear> a -> b : two SCCs, one connected component
15:15:52 <sorear> a->b  c : three SCCs, two CCs
15:15:59 <xpika> i thought connected was < SCC
15:16:20 <sorear> SCCs are smaller than CCs
15:17:04 <xpika> :(
15:17:19 <pejo> sorear, smaller result, stronger condition, no?
15:17:26 <sorear> right
15:17:56 <sorear> xpika: oh, so you want the set of maximal complete subgraphs of a given graph?
15:18:38 <RemiTurk> good morning
15:18:46 <sorear> morning.
15:18:48 <xpika> if maximal complete means 'a full topology' then yes
15:18:54 <astrolabe> sorear: Aka clique
15:18:58 <sorear> maximal - nothing is bigger
15:19:09 <sorear> complete - like pentagram
15:19:22 <xpika> pentagram = evil
15:19:37 <xpika> but yes.
15:19:48 <sorear> sorry, no idea how to do it.
15:19:53 <xpika> thought so
15:19:55 <abz> does anyone use upx regularly?
15:20:16 <xpika> but at least i now know what it's called
15:20:19 <sorear> rm > upx :)
15:20:23 <astrolabe> spika: look up clique and 'junction tree'
15:20:34 <astrolabe> ooops  xpika I mean
15:20:41 <sorear> yhc > upx
15:22:25 <EvilTerran> good grief, ghc -v produces a lot of output
15:22:44 <sorear> try -v5
15:22:51 <sorear> :/
15:23:05 <EvilTerran> I'd rather not. i suspect my screen may catch fire.
15:23:40 <EvilTerran> I only enabled it to make sure ghc was actually running, not just sitting there
15:25:51 <xpika> has anyone thought of the idea of creating a custom "haskell machine"?
15:27:38 * ddarius considers making a diffraction grating with a mirror and some flour.
15:27:51 <ddarius> xpika: Many people have.  It's a bad idea.
15:39:48 <EvilTerran> what's the deal with the +RTS and -RTS options? i can't find them defined anywhere
15:39:56 <malsyned> ddarius: can you elaborate on why?  is it more than just the fact that good strategies for compiling Haskell to conventional architectures have been developed?
15:40:26 <sorear> they say options for the RTS
15:40:30 <sorear> ghc Foo.hs
15:40:30 <Syzygy-> http://web.mit.edu/ghc/www/users_guide/profiling.html
15:40:32 <lambdabot> Title: Chapter 5. Profiling
15:40:40 <sorear> ./a.out +RTS -c -RTS
15:41:00 <Syzygy-> Or better yet. Listen to sorear...
15:41:07 <EvilTerran> I'm looking at that, Syzygy-. it seems to assume you know what they are
15:41:09 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html
15:41:11 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/2hoaa9
15:41:29 <EvilTerran> aaahhh
15:41:31 <EvilTerran> sorear++
15:41:33 <ddarius> malsyned: It's the fact that practically every machine, including ones designed for lazy functional languages, have not outperformed stock hardware.
15:41:47 <nohope> Hello all!
15:41:53 <sorear> hello nohope
15:41:54 <malsyned> hey!
15:42:15 <thalassocrac> hi
15:42:22 <ddarius> +every machine designed to support a high level language
15:42:49 <sorear> wasn't the i386 designed to support Pascal?
15:43:01 <ddarius> malsyned: The only partial counter example is stack machines, but then a) Forth isn't all that high-level and b) it still didn't outperform speed-wise.
15:43:44 <sorear> I thought the stack machines were more about efficiency (power and silicon) than speed?
15:44:30 <malsyned> ah, ok.
15:47:38 <ddarius> sorear: They were also supposed to be faster at least at Forth-like languages, but they aren't.  They were (are?) still better about power and chip space.
15:47:50 <ddarius> And implementation complexity.
15:48:35 <goltrpoat> there is a cpu out there that runs java bytecode natively, iirc.. intended for embedded applications.  can't remember the name of it, other than it was some scandinavian company, and the chip name was some common word with an h replaced by a j
15:48:53 <_frederik_> augustss: it seems sigfpe's tutorial depends on knowing Haskell/ML syntax?
15:49:18 <_frederik_> augustss: Wadler, "Comprehending Monads" looks better because it defines the syntax it uses
15:49:25 <sorear> ddarius: I find it very interesting that the PIC-family embedded processors have a accumulator`o`memory -> accumulator ISA straight out of the 70s.
15:50:04 <abz> ?doc System.Environment
15:50:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
15:50:33 <goltrpoat> ah right, the Imsys stuff.  Cjip is the name.
15:50:50 <goltrpoat> http://www.sasktelwebsite.net/jbayko/cpu7.html
15:50:51 <lambdabot> Title: The Great CPU List, Section 6
15:51:28 <abz> ?src getContents
15:51:29 <lambdabot> getContents = hGetContents stdin
15:52:52 <abz> ?doc Network.URI
15:52:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html
15:54:15 <bos31337> @seen dons
15:54:15 <lambdabot> dons is in #haskell. I last heard dons speak 7h 18m 17s ago.
15:54:42 <sorear> dons is quite likely to be asleep now
15:54:48 <bos31337> yeah
15:54:52 <bos31337> @nick bos
15:54:52 <lambdabot> Maybe you meant: dice dict
15:55:02 <sorear> @seen bos
15:55:02 <lambdabot> bos is in #haskell. I last heard bos speak 15h 46m 12s ago.
15:55:17 <bos> better.
15:55:22 <sorear> @seen bos31337
15:55:22 <lambdabot> bos31337 has changed nick to bos.
15:55:22 <lambdabot> bos is in #haskell. I last heard bos speak 4s ago.
15:55:58 * ddarius considers getting rid of the unisons in this tab.
15:56:16 <sorear> unisons?
15:56:41 <ddarius> The same note played simultaneously.
15:57:42 <JohnnyL> @seen humasect
15:57:43 <lambdabot> I saw humasect leaving #haskell 14h 45m 13s ago, and .
16:03:22 <dropdrive> What is a monad transformer, in terms of category theory?
16:04:16 <sorear> most monad transformers (not sure about ContT) induce natural transformations
16:04:27 <dcoutts> in what category?
16:05:30 <Cale> I think it would just be a natural transformation between monads
16:05:55 <dropdrive> dcoutts, do you mean monad transformers are natural transformations between not just functors but on the whole monad?
16:06:09 <Cale> Monads are functors
16:06:34 <dropdrive> Cale, monads are functors, but they're more than just a functor, right?
16:06:59 <Cale> Well, functors together with some additional natural transformations between their powers.
16:08:08 <malsyned> Cale: I hear you are fluent in Arrows?
16:08:18 <Cale> malsyned: reasonably so
16:08:40 <malsyned> Would you mind taking a look at my paste http://hpaste.org/533 and letting me know if you can see where I'm being braindead?
16:09:18 <sorear> arrows /= HXT
16:10:01 <malsyned> sorear: I know, but the problem I'm having is with the &&& operator behaving surprisingly.  I can (attempt to) field questions RE: the HXT-specific parts of the problem.
16:10:28 <sorear> &&& produces a tuple
16:10:49 <sorear> so it produces ("someXml", "someMoreXml")
16:10:54 <malsyned> yes.  a tuple is what I want.
16:11:01 <sorear> I think you want "someXmlsomeMoreXml" ?
16:11:48 <malsyned> nope.  "item" elements contain one each of "title" and "link" elements, which represent the title and link of the elements.
16:11:52 <sorear> @where HXT
16:11:52 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
16:13:11 <malsyned> oh!  I think I figured it out.  maybe.  brb.
16:13:39 <Cale> What's the isRoot for?
16:14:27 <malsyned> HXT builds its rose tree under a root node named "/", which contains some metadata about the XML document.
16:14:52 <Cale> right
16:15:35 <malsyned> and operates as filters on that, so isRoot is just there to be the right hand side of the /> operator.  It'll always result in exactly one element, the "/" element.
16:15:46 <malsyned>  /> is defined as...
16:16:23 <Cale> It seems unnecessary to check that you're at the root, since you will be anyway, but I suppose it's fine :)
16:17:00 <malsyned> it is unnecessary.
16:17:06 <malsyned> strictly.
16:17:46 <malsyned> ah, here it is:  f /> g = f >>> getChildren >>> g
16:17:57 <Cale> yeah
16:20:21 <ddarius> If C# enumerators were persistant, I would have HaXml in C#.
16:22:57 <malsyned> Cale: I think I fixed it.  I moved the getChildren inside of both sides of the &&&, and now it's returning something at least.  I'm checking to see if its' the right thing now.
16:23:54 <malsyned> yeah.  it did.  now I just have to spend some time figuring out why it worked.
16:38:28 <jeeves_bond> Evening all, I have yet another stupid question (it's a bit hard to Google for, so will ask in here...) Could you define what => does/means?
16:39:47 <araujo> You can think of it as a context restriction operator.
16:39:48 <mbishop> @hoogle =>
16:39:49 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
16:41:05 <jeeves_bond> And what would a context restriction operator do?
16:41:17 <astrolabe> jeeves_bond: It is part of a type signature.  On the left of => go the classes that things type variables need to be in.
16:41:21 <jeeves_bond> (sorry you're not dealing with someone with much of a brain here :) )
16:41:27 <astrolabe> @where report
16:41:28 <lambdabot> http://www.haskell.org/onlinereport/
16:41:53 <jeeves_bond> Hmmm, so Num => a means that type a is of class Num?
16:42:12 <astrolabe> Sec 1.4.1
16:42:17 <astrolabe> jeeves_bond: yeah
16:42:22 <jeeves_bond> Or would it be better to say an instance of class a? :)
16:42:23 <astrolabe> er
16:42:26 <astrolabe> not quite
16:42:34 <astrolabe> here is an example
16:42:40 <astrolabe> @type (+)
16:42:43 <lambdabot> forall a. (Num a) => a -> a -> a
16:42:50 <Cale> jeeves_bond: that's right
16:43:18 <astrolabe> that means for all types a in Num, (+) takes two as and returns an a
16:43:18 <Cale> jeeves_bond: x :: (Num a) => a means that x is of any type which is an instance of Num
16:44:13 <astrolabe> And my reference in the report should have been 4.1.4.   Sorry :)
16:44:17 <jeeves_bond> Wow, that's baking my noodle
16:44:31 <astrolabe> Is that a good thing?
16:45:15 <malsyned> @type (==)
16:45:18 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:45:20 <jeeves_bond> Ah, got the report and correct section loaded, thanks. I don't know if baking my noodle is good. It hurts a bit. :)
16:45:32 <astrolabe> :)
16:46:22 <Cale> @type 5
16:46:25 <lambdabot> forall t. (Num t) => t
16:46:34 <Cale> > 5 :: Integer
16:46:35 <lambdabot>  5
16:46:38 <Cale> > 5 :: Double
16:46:40 <lambdabot>  5.0
16:46:44 <sorear> What does 'return mean in the context of Template Haskell
16:46:45 <Cale> > 5 :: Rational
16:46:45 <sorear> ?
16:46:47 <lambdabot>  5%1
16:47:01 <jeeves_bond> Also, why the () around the Eq a ?
16:47:18 <Cale> jeeves_bond: It's only necessary when there's more than one class involved
16:47:18 <Igloo> sorear: The name of return
16:47:34 <sorear> Igloo: so it's like Lisp 'foo?
16:47:41 <sorear> Igloo: where is this documented?
16:47:43 <ddarius> Chunks of cheese, some broccoli, some bread crumbs and some appropriate spices and baked noodle would sound good.
16:47:44 <Cale> jeeves_bond: It's to help make the grammar easier to parse.
16:48:09 <Igloo> sorear: No idea to either
16:48:27 <jeeves_bond> Ok, think I'm getting it. Thanks all of you. :)
16:48:40 <sorear> Igloo: ty.
16:50:29 <jeeves_bond> Thanks Cale
16:50:37 <sorear> wow, some of the code in Language.Haskell.TH.Lib is massively antiidiomatic
16:50:39 <Cale> Quite welcome :)
16:51:43 <sorear> appsE is a 3 line weird function, not even structurally a fold, took me a minute to understand the recursion patter, but its definition can be written "appsE = foldl1 appE"
16:52:40 <ray> :t foldl1
16:52:43 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:54:22 <ray> and here i was using foldl (head list) (tail list) for that
16:55:07 <EvilTerran> it's most likely defined that way.
16:55:17 <sorear> @src foldl1
16:55:18 <lambdabot> foldl1 f (x:xs) = foldl f x xs
16:55:18 <lambdabot> foldl1 _ []     = undefined
16:55:26 <sorear> close enough
16:55:35 <ray> yeah
16:57:50 <EvilTerran> altho i would've expected the [] case to be = error "foldl1: cannot operate on an empty list" or something
16:58:02 <sorear> Igloo: what's ''foo (th again)
16:58:44 <Igloo> The name of some other sort of thing. Does it really exist for things starting with a lower case letter?
16:59:05 <sorear> ghci -fth to the rescue!
16:59:15 <Igloo> Ah, type variable foo according to the error
16:59:32 <nmessenger> EvilTerran: from an evaluation standpoint 'error "some message"' is equivalent to 'undefined'.  The difference is an implementation detail.
17:00:19 <EvilTerran> nmessenger, i know. i expect the standard libraries to use descriptive error messages, is all
17:00:31 <ray> it does error "empty list"
17:00:40 <ray> but error and undefined are the same thing
17:01:07 <nmessenger> I'm not sure where @src gets its sources, but it doesn't seem to be exactly to standard libraries.
17:01:11 <sorear> @src error
17:01:11 <lambdabot> error s = throw (ErrorCall s)
17:01:17 <sorear> @src throw
17:01:17 <nmessenger> s/to/the/
17:01:18 <lambdabot> throw exception = raise# exception
17:01:23 <EvilTerran> nmessenger, yes, quite
17:01:24 <sorear> @src raise#
17:01:25 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:02:23 <malsyned> what's the difference between data and newtype?
17:02:34 <sorear> newtypes are unlifted
17:02:38 <ray> @src undefined
17:02:39 <lambdabot> undefined =  error "Prelude.undefined"
17:02:49 <ray> that seems fairly standardish
17:03:04 <sorear> e.g. State is a newtype, Maybe is a data -- malsyned: vvv
17:03:11 <sorear> > State undefined `seq` 2
17:03:13 <lambdabot>  Undefined
17:03:14 <nmessenger> I prefer undefined = undefined :)
17:03:16 <sorear> > Just undefined `seq` 2
17:03:18 <lambdabot>  2
17:03:25 <sorear> malsyned: ^^^ example
17:03:40 <ddarius> @oldwiki NewTypeVsStrictData ?
17:03:41 <lambdabot> http://www.haskell.org/hawiki/NewTypeVsStrictData ?
17:03:46 <ray> undefined = undefined is cooler, but it doesn't have a nice error message!
17:03:48 <malsyned> huh.  OK.  thanks.
17:03:56 <ray> and it's equivalent anyway :P
17:04:33 <ddarius> http://www.haskell.org/pipermail/haskell-cafe/2002-January/002529.html
17:04:35 <lambdabot> Title: newtype/datatype (was efficiency), http://tinyurl.com/2gby82
17:09:14 <ndm> ray: they aren't equivalent, since we now have catch in the langauge
17:09:57 <ray> ooh, where?
17:10:26 <ndm> @hoogle catch
17:10:27 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
17:10:27 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
17:10:27 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
17:10:35 <ray> thanks
17:10:41 <ray> not up on my lambdabot commands :)
17:10:47 <ndm> ray: the Control.Exception one can catch pattern match errors, the Prelude one can't
17:11:04 <ndm> > catch (head []) (putStrLn "12")
17:11:05 <lambdabot>  Couldn't match expected type `IOError -> IO a'
17:11:12 <ndm> > catch (head []) (\ _ -> putStrLn "12")
17:11:13 <lambdabot>  <IO ()>
17:11:58 <ndm> > Prelude.catch (head []) (\ _ -> putStrLn "12")
17:12:00 <lambdabot>  <IO ()>
17:13:41 <bd_> ndm: IO isn't allowed in lambdabot :)
17:14:07 <ndm> bd_: no, but a pattern match error shows up, hence showing that the exception was caught
17:14:10 <ndm> > head []
17:14:11 <lambdabot>  Exception: Prelude.head: empty list
17:14:55 <encryptio> where can i read about multithreaded haskell techniques for ghc? (automatic multithreading using sparks, rather than explicit threads)
17:15:37 <sorear> @google Algorithm + Strategy = Parallelism
17:15:38 <bd_> ndm: Doesn't really show anything besides that catch isn't strict on its first argument :)
17:15:42 <lambdabot> http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
17:15:43 <lambdabot> Title: Algorithm + Strategy = Parallelism
17:15:45 <steven_ashley> ndm:
17:15:46 <steven_ashley> Prelude> Control.Exception.catch (head []) (\ _ -> putStrLn "12")
17:15:46 <steven_ashley> 12
17:15:46 <steven_ashley> Prelude> Prelude.catch (head []) (\ _ -> putStrLn "12")
17:15:46 <steven_ashley> *** Exception: Prelude.head: empty list
17:16:16 <ndm> bd_: true, but i know better :)
17:16:35 <steven_ashley> remind me not to paste into gaim :(
17:16:36 <ndm> steven_ashley: yes, thats what i was expecting to happen... - is that with you using GHC 6.4 or 6.6?
17:16:42 <steven_ashley> 6.6
17:16:52 <ndm> @seen dons
17:16:52 <lambdabot> dons is in #haskell. I last heard dons speak 8h 40m 54s ago.
17:17:31 <ray> putting a hoogle search in my web browser might be useful
17:17:45 <ndm> @tell dons Prelude.catch at a lambdabot > prompt catches pattern match errors - it shouldn't do, i.e. Prelude.catch (head []) (\ _ -> putStrLn "12") behaves differently in GHCi vs Lambdabot
17:17:45 <lambdabot> Consider it noted.
17:18:09 <ndm> ray: if you are a firefox user there is a quicksearch feature, and the search bar as well
17:18:24 <ray> i'm an opera user, but we have a quicksearch thing too
17:18:29 <fth> :|
17:18:40 <christine_c> hello people
17:18:51 <ndm> yes, i was an opera user for years, before firefox
17:18:52 <ray> seems slightly nicer than spamming the channel :)
17:19:09 <ndm> i much prefer the web interface, and it also returns more results
17:19:15 <ndm> christine_c: hello!
17:19:24 <steven_ashley> ray: you could pm lambdabot
17:19:25 <christine_c> what this channel all about? i hope you people dont mind, im new here
17:19:37 <ndm> christine_c: Haskell, http://haskell.org/
17:19:38 <lambdabot> Title: Haskell - HaskellWiki
17:19:44 <sorear> @topic-tell #haskell
17:19:45 <lambdabot> ["The Haskell programming language: we know when to use callCC!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The
17:19:45 <lambdabot> language of ICFP winners 3 years running"]
17:20:08 <ray> i could, true
17:20:16 <christine_c> ok thanks ill read about, this is my first time hearing that word haskell
17:20:26 <ndm> hmm, does Opera have a way to automatically add things to the search bars/quick search?
17:20:39 <ray> yeah, a right click thingy did it
17:20:43 <ndm> Firefox does, and IE 7 does (although Hoogle doesn't yet feature that, but will)
17:20:48 <araujo> christine_c, it's about lambdas
17:20:51 <araujo> :-)
17:20:53 <mbishop> heh
17:21:05 <malsyned> araujo: everything's all about lambdas.
17:21:07 <Cale> christine_c: Haskell is a general purpose functional programming language
17:21:11 <christine_c> mathematics? lambda calculus?
17:21:14 <christine_c> ok
17:21:17 <Eighty> are there any higher-order functions i can use to express (... $ f r3 $ f r2 $ f r1 $ x) where rs=[r1,r2,r3,...]?
17:21:30 <araujo> christine_c, yes!
17:21:44 <malsyned> christine_c: if you like learning programming languages, and enjoy challenging ideas that pay off once you've mastered them with increased productivity, stick around.  I'm glad I have.
17:21:55 <bd_> Eighty: foldr
17:21:57 <araujo> malsyned, let them know about it
17:22:04 <bd_> Eighty: er, wait, that's foldl
17:22:05 <Cale> Eighty: first of all, you should notice that what you're really doing is a big composition of functions
17:22:13 <Cale> Eighty: ($) kind of hides that fact
17:22:19 <christine_c> ok, do you some ebooks here? about haskell
17:22:23 <twanvl> ?type foldr ($) x . map f
17:22:25 <lambdabot> Not in scope: `x'
17:22:26 <lambdabot>  
17:22:26 <lambdabot> <interactive>:1:18: Not in scope: `f'
17:22:26 <Cale> @where wikibook
17:22:27 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:22:30 <Cale> @where yaht
17:22:31 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:22:41 <malsyned> is the gentle introduction in lambdabot?
17:22:43 <twanvl> ?type \x f -> foldr ($) x . map f
17:22:46 <lambdabot> forall b a. b -> (a -> b -> b) -> [a] -> b
17:22:46 <malsyned> @where gih
17:22:47 <lambdabot> I know nothing about gih.
17:22:50 <malsyned> :/
17:23:10 <bd_> ?t foldl
17:23:10 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
17:23:14 <bd_> :t foldl
17:23:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:23:18 <christine_c> hehehe, it seems that all of you people are so brilliant
17:23:24 <christine_c> love to explore things
17:23:26 <malsyned> http://www.haskell.org/tutorial/
17:23:27 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
17:23:29 <bd_> foldl (flip f) x [r1,r2,r3,...]
17:23:41 <araujo> christine_c, it's the lambda effect
17:23:44 <bd_> ^^^ I think that's the appropriate function, Eighty
17:23:56 <christine_c> ok
17:23:59 <Cale> Eighty: foldr (.) id (map f (reverse rs)) x
17:24:03 <araujo> :-)
17:24:12 <Cale> Or sure, foldl :)
17:24:30 <christine_c> what mostly are your products here, if you dont mind
17:24:36 <sorear> ghc-6.6: /usr/local/src/HList/dist/build/HSHList-0.1.o: unknown symbol `base_TextziReadziLex_a120_info'  -- aieee!
17:24:44 <Eighty> yeah that worked, thanks bd_ :)
17:24:46 <Cale> sorear: compile with --make ?
17:24:50 <sorear> any clue what broke?  it works in ghc --make
17:24:52 <christine_c> could we make some ai projects?
17:25:05 <Cale> sorear: missing -package
17:25:11 <steven_ashley> christine_c: lambdabot :)
17:25:12 <sorear> Cale: sure, but I want to call functions and whatnot, I need --interactive
17:25:32 <Cale> sorear: ah, hmm, that's happening in GHCi?
17:25:41 <sorear> yeh
17:25:48 <malsyned> actually, that's an interesting question.  There are some AI programs written in Haskell, right?
17:25:50 <araujo> christine_c, if you are looking for ai stuff ; haskell might help you there
17:25:50 <sorear> here, have a little more of the error.
17:25:53 <malsyned> I saw some mentioned in the History paper.
17:25:54 <sorear> ghc-6.6: /usr/local/src/HList/dist/build/HSHList-0.1.o: unknown symbol `base_TextziReadziLex_a120_info'
17:25:54 <sorear> Loading package HList-0.1 ... linking ... ghc-6.6: unable to load package `HList-0.1'
17:25:55 <christine_c> lamdabot....machine learning program to do some lambda things? is that the one? hehehe
17:26:04 <christine_c> ok, alright, i appreciate it
17:26:10 <sorear> lambdabot doesn't learn
17:26:18 <Cale> > foldr (+) 0 [1..10]
17:26:19 <lambdabot>  55
17:26:21 <christine_c> uh!
17:26:22 <araujo> he already knows it all
17:26:23 <siti> it's just plain smart :)
17:26:24 <christine_c> i see
17:26:26 <sorear> it gets taught by hackers and editors
17:26:26 <araujo> erh, seh
17:26:30 <araujo> she* :-)
17:26:32 <sorear> @where+ this that
17:26:32 <bd_> > foldl' (+) 0 [1..10]
17:26:32 <lambdabot> Done.
17:26:34 <lambdabot>  55
17:26:35 <sorear> @where this
17:26:36 <lambdabot> that
17:26:51 <christine_c> can it do some nlp thing?
17:26:52 <bd_> @where+ this Right there, where you left it.
17:26:53 <lambdabot> Done.
17:27:12 <sorear> not really, we haven't needed it
17:27:14 <Cale> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1..5]
17:27:15 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
17:27:20 <steven_ashley> christine_c: personally, I am making a draughts game with siti. It has some simple AI :)
17:27:25 <sorear> everyone here speaks fluent lambdabot
17:27:34 <Cale> > foldl (\y x -> concat ["(f ", y " ", show x, ")"]) "z" [1..5]
17:27:35 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
17:27:38 <sorear> lambdabot doesn't speak english
17:27:47 <sorear> which is just as well, since:
17:27:51 <sorear> @seen lambdabot
17:27:52 <lambdabot> Yes, I'm here. I'm in #haskell.es, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell-overflow, #haskell-blah
17:27:52 <lambdabot> and #haskell
17:28:14 <Cale> > foldl (\y x -> concat ["(f ", y, " ", show x, ")"]) "z" [1..5]
17:28:16 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
17:28:24 <sorear> spanish, dutch, swedish, whatever they speak in uruguay, english
17:28:30 <christine_c> ok
17:28:43 <christine_c> hehehe, ill read the websit
17:28:47 <jcreigh> Cale: oooh, nice way of showing that.
17:28:49 <jcreigh> Cale++
17:29:27 <christine_c> people its seem that its like prolog
17:29:37 <christine_c> as i looked the example
17:30:19 <siti> lol
17:31:23 * dcoutts makes c2hs parse structs/unions that have anonymous structs & unions as members
17:31:24 <christine_c> people, im just curios, how long has this language exists
17:31:36 <ddarius> Ich bin froehe.
17:31:41 <dons> check the 'History' page of haskell.org, christine_c
17:31:42 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:31:44 <Cale> christine_c: since around 1990, depending on when you count from
17:31:52 <malsyned> christine_c: This paper: http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm, section 11.5 on page 40 tells about uses of Haskell in NLP.
17:31:54 <lambdabot> Title: A History of Haskell, http://tinyurl.com/yowkle
17:31:58 <dcoutts> christine_c, since early 90's roughly but it derived from earlier languages
17:32:11 <siti> it was always around people just needed to find it ;)
17:32:28 <christine_c> i really love people here very hospitable...thanks
17:32:30 <Cale> It's only recently started to gain practicality and some level of popularity.
17:32:33 <sorear> dons: how's the upgrade project
17:32:37 <sorear> coming?
17:33:17 <dons> the machine has some instability. it will have to wait till tomorrow
17:34:36 <malsyned> christine_c: how did you hear about haskell?
17:35:39 <Eighty> is there a map function for tuples?
17:35:48 <sorear> join (***)
17:35:49 <malsyned> Cale: What happened recently that caused the jump in practicality?
17:35:57 <sorear> @ty join (***)
17:35:59 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
17:36:07 <malsyned> Eighty: what would you want it to do?
17:36:24 <Eighty> malsyned: get (f x, f y) from (x,y)
17:36:25 <sorear> @ty join (***) :: forall a b. (a -> b) -> (a,a) -> (b,b)
17:36:28 <lambdabot> forall a b. (a -> b) -> (a,a) -> (b,b) :: forall a b. (a -> b) -> (a, a) -> (b, b)
17:36:39 <sorear> Eighty: join (***) will do that
17:36:45 <Eighty> what module?
17:36:49 <dcoutts> malsyned, I think it started with the FFI, an increase in people writing decent libs and improved ghc optimisations.
17:36:53 <sorear> > join (***)  (*2) (12,13)
17:36:55 <lambdabot>  (24,26)
17:36:56 <malsyned> Eighty: that would only work for tuples where the types of both elements were the same.
17:37:07 <malsyned> sorear: is *** an arrow operator?
17:37:11 <jcreigh> is that limited to a 2-tuple?
17:37:11 <sorear> Eighty: join is from Control.Monad, (***) is from control.arrow
17:37:12 <Eighty> malsyned: that's the case here.
17:37:15 <Cale> malsyned: Lots of stuff that dons has been doing, for one. Also, lots of new libraries.
17:37:34 <Cale> malsyned: The number of Haskell libraries has exploded since I started learning it.
17:37:54 <sorear> Eighty: w/o join : (f *** g) (x,y) = (f x, g y)
17:37:54 <Cale> http://torrentfreak.com/mpaa-steals-code-violates-linkware-license/ -- hahahaha
17:37:57 <lambdabot> Title: MPAA Steals Code, Violates Linkware License | TorrentFreak, http://tinyurl.com/2ykgan
17:38:11 <ddarius> malsyned: Haskell has been on a steady rise since I started using it about four years ago due to a variety of things.
17:38:18 <sorear> Cale: any clue what could break only ghci?
17:38:49 <Eighty> okay
17:39:06 <Cale> sorear: Normally ghci seems to behave as if --make is always on. I'm not really sure.
17:39:19 <sorear> Cale: bwah? deleting all the -package options, and -hide-all-packages, fixed it.
17:39:34 <sorear> Cale: even though with the options ghc --make worked.
17:40:44 <sorear> Cale: -fforce-recomp, or any dump option, rebreaks it.
17:40:50 <Cale> sorear: --make will add any necessary -package options automatically
17:41:03 <sorear> Cale: even with -hide-all-packages?
17:41:33 <dons> ?users
17:41:33 <lambdabot> Maximum users seen in #haskell: 316, currently: 294 (93.0%), active: 47 (16.0%)
17:45:30 <sorear> Cale: ghc -e is also affected
17:47:27 <Cale> sorear: I've never used -hide-all-packages, I don't know
17:48:29 * sorear invokes the sleghammer 'recompile HList'
17:53:46 <MechaBlue> I'm having trouble converting a non-ASCII UTF Char to an Int using ord.  Is there another way to get the value?
17:54:34 <sorear> Chars have no encoding
17:54:41 <dcoutts> hmm, looks like I'll be able to parse glibc though I'll need to add support to parse nested functions.
17:54:45 <sorear> Char is a character, not a sequence of bytes
17:54:56 <sorear> UTF applies only to sequences of bytes
17:55:03 <sorear> your sentence is ill typed
17:55:19 <Botje> http://repetae.net/repos/jhc/UTF8.hs
17:55:22 <Botje> this might help?
17:55:34 <dcoutts> > fromEnum '\678'
17:55:35 <lambdabot>  678
17:56:08 <MechaBlue> Botje: It might.  I'll take a close look at it.  Thanks
17:57:45 <MechaBlue> Botje: I don't think so.  The problem I'm getting is that the ord function is giving me (I'm assuming) incorrect values.
17:58:53 <allbery_b> hm?
17:58:54 <sorear> I notice a strong daily oscilation in the population of the channel, peaking arount 1600 GMT
17:59:00 <ddarius> @src Char fromEnum
17:59:00 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:59:32 <dons> we need some tutorials on the use of `par`
17:59:44 <dons> and the whole Parallel modules
17:59:52 <sorear> dons: reading scrollback again, are you?
17:59:58 <dons> sorear: no, just reddit.
18:00:50 <sorear> dons: thishour:13, someone asked about implicit paralelism
18:01:17 <sorear> I responded with @google Algorithm + Strategy = Parallelism
18:01:50 <dons> ok. that's probably our best ref. we need some tuts though!
18:08:25 <dons> hi thorat. we don't get many people from .is here. welcome!
18:08:59 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
18:09:00 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:09:20 <EvilTerran> wow. that's a new one.
18:09:30 <sorear> very old actually
18:09:31 <thorat> hi, thanks
18:09:41 <dons> mm. someone should buy up the :   unsafe.perform.io domain (.io is 'british indian ocean territory' )
18:09:44 <thorat> thank ltu
18:09:47 <thorat> i suppose
18:09:50 <sorear> it's been the stardard example of fix for as long as I can remember
18:09:51 <Botje> > let fibs = 1: scanl (+) 1 fibs in fibs
18:09:52 <EvilTerran> okay, let me rephrase: "that's a cunning one"
18:09:53 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:10:02 <dons> EvilTerran: yeah, it is a bit cunning
18:10:13 <dons> thorat: so you know some haskell?
18:10:14 <sorear> thorat: do you know Haskell (the PL)?
18:10:34 <dons> sorear: want to try to get hold of the perform.io domain?
18:10:39 <thorat> well, been following plt via ltu for some 2 years
18:10:42 <dons> i wonder if .io is even freely available. hmm
18:10:57 <thorat> oleg fan
18:10:59 <thorat> etc
18:11:10 <dons> ?quote oleg
18:11:11 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
18:11:14 <dons> so are we :-)
18:11:15 <ddarius> The usual implementation I've seen is let fibs = 1:1:zipWith (+) fibs (tail fibs)
18:11:33 <ddarius> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
18:11:34 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:11:37 <thorat> also a huge perl and vim fanatic
18:11:37 <dons> ddarius: that's the old fashioned way ;) fix is just so *now*
18:11:43 <sorear> dons: note title: http://unsafe.perform.io
18:11:45 <edwinb> I'm scared of Oleg ;)
18:11:48 <lambdabot> Title: This name availabe to BUY!
18:11:53 <dons> mm!
18:11:54 <thorat> haven't used haskell yet for anything useful
18:12:16 * EvilTerran notes that whoever wrote this question somewhat missed the concept of multi-dimensional arrays
18:12:17 <sorear> we define useful in weird ways, don't worry
18:12:18 <thorat> waiting for an idea
18:12:33 <dons> what kind of code do you usually write? what area?
18:12:53 <thorat> worket at a genetics company for a few years
18:12:59 <EvilTerran> thorat, we seem to have a remarkable amount of common ground. I am also fanatical about perl and vim (and haskell)!
18:13:02 <thorat> now, embedded programming
18:13:03 <mbishop> heh, an .io domain for non EU residents is 60 pounds
18:13:39 <thorat> and just dropped back into uni to finish BS in maths
18:13:40 <dons> right. so they're all 60 pounds
18:13:56 <sorear> it's a one time cost!?
18:14:02 <ray> per year
18:14:05 <dons> per year
18:14:07 <ddarius> dons: The now way would be to use comonads to implement a data flow EDSL then fibs = 1 `fby` (fibs + (1 `fby` fibs))
18:14:19 <thorat> what about you guys, dons I've seen a lot of course
18:14:26 <dons> so 1 pound/ week for unsafe.perform.io
18:14:31 <dons> thorat: oh?
18:14:37 <ray> that's expensive
18:14:41 <ray> i would have to give up coffee
18:14:45 <mbishop> heh
18:14:45 <dons> heh
18:14:59 <sorear> @remember ddarius The now way would be to use comonads to implement a data flow EDSL then fibs = 1 `fby` (fibs + (1 `fby` fibs))
18:14:59 <lambdabot> Done.
18:15:06 <thorat> dons: I mean, you're active in the community
18:15:19 <MechaBlue> thorat: I use
18:15:25 <dons> ah, not on ltu so much though
18:15:37 <thorat> wiki
18:15:39 <EvilTerran> "foo = array (a,b) [bar i | i <- [a..b]] where bar i = array (c,d) [baz i j | j <- [c..d]]; baz i j = array (e,f) [eek i j k | k <- [e..f]]"
18:15:45 <dons> bos: should we buy up unsafe.perform.io ?
18:16:03 <edwinb> yeah!
18:16:04 <thorat> speaking about ltu, I used to be a Franka fan as well
18:16:04 <MechaBlue> thorat: I use Haskell to produce data sets with certain properties for testing.  Mostly straightforward stuff, but easier to do thaan by hand.
18:16:11 <sorear> inline.perform.io ftw!
18:16:12 <Botje> EvilTerran: eek! that's indeed evil
18:16:17 <EvilTerran> or, more succinctly (albeit with a different interface), "foo = array ((a,c,e),(b,d,f)) [ eek i j k | etc ]"
18:16:19 <dons> system.io
18:16:41 <dons> thorat: yeah, franka sometimes hangs out here, though not recently
18:16:41 <EvilTerran> Botje, blame my data structures+algos lecturer
18:16:47 <ddarius> thorat: What changed?
18:17:14 <thorat> haven't seen him post on ltu in a while, that's what I meant
18:17:16 <edwinb> thorat: interested in embedded programming and fp?
18:17:16 <dons> sorear: or andorra, control.mon.ad
18:17:39 <thorat> well, I'm interested in logic, maths, CT, etc
18:17:48 <sorear> ategory heory?
18:18:06 <thorat> yup, all the stuff from ltu
18:18:09 <thorat> got hooked
18:18:14 <sorear> I support omputed omography would also be fun to program in Haskell
18:21:23 * EvilTerran ponders buzzing an FYI off to the guy named in the footer of the guidance document
18:22:08 <EvilTerran> "'scuse me, your '{arrays of} arrays' approach to multi-dimensional arrays sucks"
18:27:25 <Cale> EvilTerran: which guidance document?
18:27:54 <thorat> has anybody read Tim Sheard's papers on Omega?
18:27:58 <edwinb> yes...
18:27:59 <Cale> Arrays of arrays can be the right approach at times, because if the outer array is lazy, the inner arrays won't be allocated unless needed.
18:28:19 <Cale> You could have a boxed array of unboxed arrays, for instance.
18:28:23 <EvilTerran> Cale, it's on our intranet, i'm afraid, so you won't be able to see it
18:28:46 <EvilTerran> and this is for uni fresher level stuff, it's not worrying about unboxedness
18:28:52 <thorat> do you know if the project is dead or how much is considered for Haskell
18:28:58 <thorat> ?
18:29:05 <edwinb> thorat: it's not dead, and it's not considered for haskell, is my understanding
18:29:40 <dons> Omega is a research project, and somewhat being subsumed by the associated types and indexed type families stuff, which is in ghc
18:29:51 <EvilTerran> (also the arrays will be of fairly small sizes; 3*(length of a given line of text)^2
18:29:53 * ddarius forgot about MegaMonad.
18:29:55 <dons> some of the omega examples at least can be done that way
18:29:56 <thorat> right
18:30:16 <thorat> ok
18:30:39 <edwinb> Omega is much more powerful that what ghc can do, though
18:30:50 <sorear> EvilTerran: sniff sniff sniff, levenschtein?
18:30:51 <edwinb> it is basically type theory, even if the syntax hides it
18:32:32 <EvilTerran> sorear, 'fraid not. given a string in {A,B,C}*, and a binary operator on {A,B,C}, we have to find ways of pairing up the string to give a certain result
18:33:01 <EvilTerran> "ABCAA" --> "(AB)(C(AA))" or whatever
18:33:54 <EvilTerran> it's fairly easy stuff, but the framework we've been given to build into could use a bit of polish :P
18:34:30 <dbremner> EvilTerran- Sisal used arrays of arrays and the performance suffered because of it
18:40:56 <sorear> > let ac op [x] = [x] ; ac ls = map (uncurry (liftM2 op) . join (***) (ac op)) . init . tail . liftM2 zip inits tails . ls in length $ filter (==6) $ ac (-) [1,2,3,4,5]
18:40:57 <lambdabot>  arity mismatch for 'ac'
18:41:02 <sorear> > let ac op [x] = [x] ; ac op ls = map (uncurry (liftM2 op) . join (***) (ac op)) . init . tail . liftM2 zip inits tails . ls in length $ filter (==6) $ ac (-) [1,2,3,4,5]
18:41:03 <lambdabot>  Couldn't match expected type `a -> [a1]'
18:42:00 <sorear> > let ac op [x] = [x] ; ac op ls = concatMap (uncurry (liftM2 op) . join (***) (ac op)) . init . tail . liftM2 zip inits tails . ls in length $ filter (==6) $ ac (-) [1,2,3,4,5]
18:42:01 <lambdabot>  Couldn't match expected type `a -> [a1]'
18:42:12 <sorear> > let ac op [x] = [x] ; ac op ls = concatMap (uncurry (liftM2 op) . join (***) (ac op)) . init . tail . liftM2 zip inits tails $ ls in length $ filter (==6) $ ac (-) [1,2,3,4,5]
18:42:14 <lambdabot>  0
18:42:21 <sorear> > let ac op [x] = [x] ; ac op ls = concatMap (uncurry (liftM2 op) . join (***) (ac op)) . init . tail . liftM2 zip inits tails $ ls in ac (-) [1,2,3,4,5]
18:42:22 <lambdabot>  [3,-7,1,3,11,-5,5,3,-3,-7,1,-5,-7,-13]
18:42:48 <sorear> > let ac op [x] = [x] ; ac op ls = concatMap (uncurry (liftM2 op) . join (***) (ac op)) . init . tail . liftM2 zip inits tails $ ls in ac (+) [1,2,3,4,5]
18:42:50 <lambdabot>  [15,15,15,15,15,15,15,15,15,15,15,15,15,15]
18:42:51 <EvilTerran> !
18:43:00 <sorear> haskell rocks
18:43:16 <siti> code obsufcation rocks ;)
18:44:21 <sorear> > let ac op [x] = [x] ; ac op ls = uncurry (liftM2 op) =<< (join (***) (ac op) . init . tail . liftM2 zip inits tails $ ls) in ac (+) [1,2,3,4,5]
18:44:22 <lambdabot>  Couldn't match expected type `([t], [t])'
18:45:08 <sorear> > let ac op [x] = [x] ; ac op ls = (uncurry (liftM2 op) . join (***) (ac op)) =<< (init . tail . liftM2 zip inits tails $ ls) in ac (+) [1,2,3,4,5]
18:45:10 <lambdabot>  [15,15,15,15,15,15,15,15,15,15,15,15,15,15]
18:45:40 <Saizan> > replicate 14 15
18:45:42 <lambdabot>  [15,15,15,15,15,15,15,15,15,15,15,15,15,15]
18:47:40 <mbishop> > replicate 8 "Buffalo"
18:47:42 <lambdabot>  ["Buffalo","Buffalo","Buffalo","Buffalo","Buffalo","Buffalo","Buffalo","Buff...
18:48:23 <sorear> > let ac op [x] = [x] ; ac op ls = (\(a,b) -> liftM2 (ac op a) (ac op b)) =<< (init . tail . liftM2 zip inits tails $ ls) in ac (+) [1,2,3,4,5]
18:48:24 <lambdabot>  Couldn't match expected type `a1 -> a2 -> r'
18:48:31 <sorear> > let ac op [x] = [x] ; ac op ls = (\(a,b) -> liftM2 op (ac op a) (ac op b)) =<< (init . tail . liftM2 zip inits tails $ ls) in ac (+) [1,2,3,4,5]
18:48:32 <lambdabot>  [15,15,15,15,15,15,15,15,15,15,15,15,15,15]
18:48:46 <sorear> unpfing made it shorter, wow
18:53:05 <EvilTerran> > uncurry take $ ((-1+).head &&& tail) $ fix (15:)
18:53:06 <lambdabot>  [15,15,15,15,15,15,15,15,15,15,15,15,15,15]
18:54:26 <Saizan> > uncurry take $ ((-1+).head &&& id) $ fix (15:)
18:54:27 <lambdabot>  [15,15,15,15,15,15,15,15,15,15,15,15,15,15]
18:55:06 <siti> > take 14 $ repeat 15
18:55:07 <lambdabot>  [15,15,15,15,15,15,15,15,15,15,15,15,15,15]
18:55:45 <Saizan> however, would you have anything against class Comonad w a b where cobind :: w a -> (w a -> b) -> w b; coreturn :: w a -> a ?
18:56:05 <Saizan> notice the 3 parameters
18:56:32 <sorear> > let ac op [] = [] ; ac op (x:xs) = (x,xs) : [ (op t1 t2, xs'') | (t1,xs') <- ac op xs , (t2,xs'') <- ac op xs' ] in ac (-) [1,2,3,4,5]
18:56:34 <lambdabot>  [(1,[2,3,4,5]),(-1,[4,5]),(3,[]),(-6,[])]
18:57:35 <sorear> > let ac op [] = [] ; ac op (x:xs) = (x,xs) : [ (op t1 t2, xs'') | (t1,xs') <- ac op xs , (t2,xs'') <- ac op xs' ] in ac (-) [1,2]
18:57:37 <lambdabot>  [(1,[2])]
18:59:41 <sorear> > let ac op [] = [] ; ac op (x:xs) = (x,xs) : [ (op t1 t2, xs'') | (t1,xs') <- ac op (x:xs) , (t2,xs'') <- ac op xs' ] in ac (-) [1,2]
18:59:44 <lambdabot>  Exception: stack overflow
18:59:51 <sorear> oh well.
19:06:05 <EvilTerran> yaay, my version outperforms the "specification program"
19:06:40 <Cale> Saizan: The problem with that is that you no longer get any insurance of naturality
19:07:10 <sorear> EvilTerran: choose your metric.  I pick character count.
19:07:19 <Saizan> naturality as?
19:07:34 <Cale> join and return have to be natural transformations
19:07:53 <Cale> (as are split and extract)
19:08:29 <Saizan> so they should work with any type?
19:08:37 <Cale> in the same way with any type
19:09:23 <sorear> well, noone complains about the writability of EvilIx :)
19:09:27 <Saizan> mmh but the point in that i want to define the comonad only for some types
19:09:34 <Cale> Well, right.
19:09:41 <Cale> That's a problem
19:10:01 <EvilTerran> sorear, i've reduced an exponential-time problem to n^2. i consider that worth the slight gain in verbosity
19:10:10 <Cale> You want a way to express that it's only definable for some types, but that it has to be defined in the same way for all the types that it is defined for.
19:10:19 <sorear> EvilTerran: nice
19:10:38 <sorear> EvilTerran: I see a factoral time way and an exponential (4^n) way
19:10:47 <hpaste>  oren pasted "Scope problem" at http://hpaste.org/537
19:10:49 <Saizan> can this be done in haskell?
19:11:41 <Cale> No. Also, without those extra parameters, it can be hard to ensure that things aren't abused.
19:12:02 <oren> Hi guys - anyone has an idea how to access a variable nested inside a lambda (specifically in a "do")?
19:12:03 <hpaste>  sorear annotated "Scope problem" with "fixed (use diff)" at http://hpaste.org/537#a1
19:12:14 <Cale> oren: hm?
19:12:29 <Cale> oren: you simply type its name inside its scope :)
19:12:50 <Cale> > (\x -> x + 1) 5
19:12:52 <lambdabot>  6
19:13:07 <Saizan> Cale: abused as in trying to use incompatible types?
19:13:19 <EvilTerran> sorear, you can form an array (('A',1,1),('C',n,n)) = [can_produce c i j | c <- ['A'..'C'], i <- [1..n], j <- [i..n]], where n is the length of your string, for memos
19:13:29 <EvilTerran> s/=//
19:13:32 <Cale> Saizan: yeah, you can hide incompatible uses of types inside things which look like they ought to work
19:13:43 <oren> cale: no, I need to access it ouside it. Closure-like. See http://hpaste.org/537
19:13:53 <EvilTerran> and then you've got 3n^2 cells, and you'll calculate each one at most once
19:14:03 <allbery_b> oren: see sorear's paste
19:14:15 <allbery_b> <hpaste>  sorear annotated "Scope problem" with "fixed (use diff)" at http://hpaste.org/537#a1
19:14:28 <EvilTerran> (can_produce c i j) being whether the substring [i..j] can be bracketed so as to produce c.
19:14:37 <Saizan> with a HEAD gadt extension i've got as far as removing the "a" parameter, for the "b" is harder, given that cobind has to produce w b..
19:14:41 <Cale> oren: Are you trying to create a fixed point?
19:14:58 <sorear> EvilTerran: ah! I didn't notice that your alphabet was restricted.
19:15:09 <sorear> EvilTerran: makes a BIG difference.
19:15:12 <EvilTerran> heh. that would tend to make things easier.
19:15:13 <oren> sorear: mdo?
19:15:20 <sorear> oren: GHC extension
19:15:28 <Cale> oren: Yeah, mdo is probably the solution for you.
19:15:35 <EvilTerran> you can't memo so well on an infinite alphabet...
19:15:41 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/syntax-extns.html#mdo-notation
19:15:44 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/yp3yy9
19:15:50 <oren> Ok, I'll look into it. Thanks!
19:16:02 <EvilTerran> (i have visions of something involving a self-balancing tree, but it would eat memory at a terrifying rate)
19:18:20 <oren> Hmmm... -fglascow-exts makes it compile, but I then get "exception: loop"
19:18:45 <oren> The funny part is that the pure version works fine
19:18:56 <oren> Its adding the trace that kills it
19:20:17 <allbery_b> well, yes, looks like you're trying to trace an infinite list
19:20:54 <allbery_b> hm, no, maybenot
19:21:01 * allbery_b recognzes that expression...
19:21:13 <oren> I'm trying to set up a client/server thing
19:21:18 <oren> This is a distilled example
19:21:31 <oren> Like two threads talking with each other
19:21:53 <oren> If you rin the pure version you see it stops after a few iterations
19:22:06 <oren> At any rate, I get the exeption immediately, after the first step
19:22:34 <oren> Seems like the system somehow detects the *potential* for an infinite loop and freaks out
19:23:03 <allbery_b> IIRC <<loop>> means it reentered a thunk that is currently being evaluated
19:23:14 <oren> That's exactly what should happen
19:23:25 <oren> Isn't it supported to work?
19:23:50 <allbery_b> not like that
19:23:52 <sorear> <<loop>> means there is definitely an infinite loop - it's very conservative
19:24:17 <allbery_b> a thunk is a calculation frozen *at a particular place* --- you are,m quite definitely, in an infinite loop if you re-enter it
19:24:49 <oren> Hmmm... the pure version doesn't enter an infinite loop... the impure version should be identical.
19:24:51 <regecks> SeanWt mom wants you in the kitchen
19:25:28 <oren> Any way I can trace it?
19:25:35 <oren> Stack dump? Something like that?
19:25:37 <allbery_b> well, except that the pure version can order calculations to avoid it --- when you use IO, you force things
19:25:40 <EvilTerran> so it's as if a pure function's called itself with all the same arguments, and by its purity it's certain to do it again?
19:26:06 <oren> Good point.
19:26:40 <oren> Except I'm just tracing one of the lists. I don't see a reason it shouldn't be able to avoid a loop
19:26:41 <allbery_b> in particular, you're trying to force the whole list, when generating the whole list will try to force the whole list
19:26:51 <oren> Perhaps I'm stretching the runtime beyond its design goals
19:26:54 <allbery_b> I *think* if yu  only trace the list head you might be okay
19:27:07 <oren> Yes, it dies after the head. Exactly
19:27:43 <oren> Why do I force the whole list though? I expected the 'mapM' to be lazy, even if it is IO
19:28:33 <allbery_b> I don't think so, the IO makes it strict
19:28:51 * EvilTerran is away: zzz
19:29:05 <allbery_b> but I'm no expert in this stuff
19:29:28 <oren> Ah. That's what I'm missing.
19:29:34 <Cale> mapM f = sequence . map f; sequence = foldr (liftM2 (:)) (return [])
19:29:51 <oren> So it is impossible in general? If I have co-routines/co-threads/client-server etc. they must be pure?
19:30:08 <Cale> You can use unsafeInterleaveIO to do IO lazily.
19:30:21 <Cale> But as the name suggests, you should be careful :)
19:30:24 <allbery_b> they don't have to be, but you have to be very careful.  as in this case where you can afely force the list head but not the rest
19:30:55 <oren> Hmmm... I'm trying to trick it. Not using mapM...
19:31:49 <Cale> @type System.IO.Unsafe.unsafeInterleaveIO
19:31:51 <lambdabot> forall a. IO a -> IO a
19:32:18 <Cale> It takes an IO action and returns one which will complete immediately, and only perform the IO if the resulting value is forced.
19:32:24 <oren> I guess that in general it is always possible to feed the IO stuff to a single main thread, which would avoid the problem
19:32:46 <oren> Might be cleaner code come to think of it. Haskell has a tendency to force you to do the right thing :-)
19:32:53 <Cale> Yeah, you can also do explicit concurrency, which is probably easier to reason about.
19:33:11 <Cale> Perhaps use a Chan
19:33:28 <oren> Chan?
19:33:57 <Cale> It's a FIFO channel for thread communication
19:34:21 <allbery_b> @doc Control.Concurrent.Chan
19:34:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
19:34:29 <nornagon> can't haskell do erlang-style concurrency magic? :-)
19:34:45 <oren> No, that wouldn't help... I need to keep the client and server threads pure. Chan is IO.
19:35:08 <oren> Well actually what I'd love to see is a "future" pattern in haskell
19:35:22 <oren> That would be simpler than what I'm forced to do here
19:35:31 <Cale> "future"?
19:36:07 <Cale> What are you tracing for? Is this just for debugging?
19:36:23 <oren> This is just an example
19:36:31 <oren> The actual system is something else
19:36:47 <Cale> You can also make the pure code return lazy lists of things to print
19:36:54 <oren> Future is when you have a variable x whose value is the result of a computation "somewhere else"
19:36:55 <Cale> or actions to execute, even.
19:37:01 <oren> And you can wait until it is available
19:37:21 <oren> Yes - lazy evaluation is almost exactly the same thing
19:37:31 <oren> Which is why the pure cycle works
19:37:48 <oren> You are right, the best way would be for the pure threads to generate lists of actions for the main IO function
19:37:56 <oren> Which could trace/debug/etc.
19:38:12 <oren> Also it could collect events from the outside world and feed it to them
19:38:21 <Cale> Then you could just apply sequence to them, or interleave other actions.
19:38:29 <oren> Right
19:39:04 <oren> The place where it gets hairy is if I have "threads" that require outside world, I'll have to split them to pure and impure parts. Probably a good idea anyway.
19:39:05 <Cale> impureCycle = map (\x -> putStrLn (show x) >> return x) pureCycle
19:39:15 <oren> Right
19:39:23 <Cale> or mapM, if you want to perform all that
19:39:31 <oren> Yeah.
19:39:42 <oren> Well... many thanks people! This really helped
19:39:50 * oren gets back to the drawing board
19:40:07 * oren vanishes in a puff of logic
19:40:09 <Saizan> won't mapM try to force things that are not yet ready?
19:40:34 <Cale> Saizan: if you can compute pureCycle, then you can compute mapM f pureCycle
19:41:24 <Cale> If you need some intermediate values from whatever pure algorithm, just have it return them.
19:41:39 <Cale> Then you can do the IO "after"
19:41:53 <Cale> even though laziness will ensure that things will be properly interleaved.
19:43:27 <Saizan> uhm, yes, i was thinking of interacting threads, but pureCycle doesn't interact, being pure
20:14:22 <malsyned> is there, somewhere, a list of the research papers which completely describe the current "core" features and libraries for a modern Haskell implementation (like ghc)?
20:15:01 <sorear> not iirc, but there is a superset
20:15:13 <sorear> http://haskell.org/haskellwiki/Research_papers
20:15:14 <malsyned> yeah?  where?
20:15:15 <lambdabot> Title: Research papers - HaskellWiki
20:15:17 <malsyned> awesome.
20:15:40 <malsyned> I ask because I'm reading the original Arrow research paper and realizing that it's teaching me how Arrows work better than the three tutorials I read did.
20:15:42 <jcreigh> Haskell culture is kinda funny. It's just assumed that any useful documentation will be in the form of a research paper. :)
20:15:50 <sorear> malsyned: that made a couple weeks of reading for me, be prepared for a lot a hay
20:16:05 <malsyned> yeah, I've noticed that.  It's unusual in a programming language.
20:16:17 <sorear> @remember jcreigh Haskell culture is kinda funny. It's just assumed that any useful documentation will be in the form of a research paper. :)
20:16:18 <lambdabot> Done.
20:17:02 <sorear> malsyned: I think I was being too obscure - the reference was to needles in haystacks
20:17:46 <malsyned> I didn't quite get the reference, but I got the gist.
20:18:39 <malsyned> it's that haystack that it would be nice to be able to cut through.
20:21:03 <malsyned> someone (who isn't me) should go through and pull out only the needles used to sew the current implementations.
20:21:11 <malsyned> to stretch the analogy to its breaking point.
20:26:43 <dibblego> does a access/update to a diff array take O(1) while an access to 'older versions' of that array take longer?
20:26:58 <allbery_b> yes
20:27:04 <dibblego> allbery_b, answering me?
20:27:07 <allbery_b> yes
20:27:11 <dibblego> allbery_b, thanks
20:28:40 <dibblego> why does the documentation say that // take O(length d)?
20:30:17 <allbery_b> the docs I have is linear in the number of updates
20:30:44 <dibblego> "So if a diff array is used in a single-threaded style, i.e. after // application the old version is no longer used, a'!'i takes O(1) time and a // d takes O(length d)."
20:32:24 <allbery_b> at a guess, O(1) * length d, because it can't just keep scanning the array or it'll be working with an old one?  (DiffArrays are kinda weird)
20:34:06 <dibblego> is there a type with fast access/update at the (possibly large) expense of access/update on older versions?
20:34:13 <sorear> DiffArray
20:34:33 <dibblego> mk then
20:34:35 <allbery_b> DiffArray is it.  but (//) is no different frm multiple single updates, which is why the O(lengh d)
20:34:56 <sorear> O(length d) means that if you make ten thousand *changes* (length d), it will take ten thousand times longer than a single change
20:35:06 <dibblego> oh
20:35:07 <sorear> length d is NOT the length of the array
20:35:12 <dibblego> righto thanks
20:35:14 <Cale> / is slightly different from multiple single updates though, IIRC.
20:35:15 <nrb23> huh...
20:35:15 <Cale> er
20:35:16 <allbery_b> right
20:35:18 <Cale>  // is slightly different from multiple single updates though, IIRC.
20:35:19 <nrb23> > let (--.) = (+) in 1 --. 2
20:35:21 <lambdabot>  3
20:35:33 <nrb23> my editor marks that as a comment
20:35:49 <allbery_b> your editor probably isn't smart about parsing.  (emacs?)
20:35:58 <nrb23> TextMate
20:36:07 <sorear> dibblego: also look at STUArray, which gains a very large constant factor in performance by outright forbidding access to older versions
20:36:18 <dibblego> ?where STUArray
20:36:19 <lambdabot> I know nothing about stuarray.
20:36:23 <nrb23> I had no idea that was allowed
20:36:38 <dibblego> sorear, ok thanks
20:36:47 <allbery_b> whynot?  it's just a token
20:37:03 <nrb23> didn't realize that the comment needed to be a separate token
20:37:26 <nrb23> I'm used to the comment start character(s) being always the beginning of a comment
20:42:01 <mbishop> http://www.ninebynine.org/Software/Learning-Haskell-Notes.html
20:42:03 <lambdabot> Title: Learning Haskell Notes
20:43:44 <nrb23> ?hoogle Port
20:43:45 <lambdabot> Network.PortNumber :: PortNumber -> PortID
20:43:45 <lambdabot> Network.PortID :: data PortID
20:43:45 <lambdabot> Network.PortNumber :: data PortNumber
20:44:27 <dropdrive> Is it possible to write a quaternion data structure such that I can do things like (H 1 2 3 4)*(2 :+ 3)?
20:44:42 <sorear> no
20:45:21 <sorear> ((1 :+ 2) :* (3 :+ 4)) * (2 :+ 3) might be possible however
20:45:41 <dropdrive> sorear, so the fact that one can do things like 4*(2 :+ 3) is a behaviour is unique?
20:46:14 <sorear> (disclaimer: it's been many months, and I can't remember if quaterions are Cayley (Complex Double))
20:46:31 <sorear> dropdrive: * *always* takes two args of the same type.
20:47:08 <sorear> 4 can have any numeric type, so 4 * (4.0 :: Double) is 4.0 * 4.0 is 16.0 :: Double
20:47:37 <sorear> haskell is basically unique in overloading literals rather than up-coercing operations.
20:47:39 <dropdrive> sorear, yeah, I just realized that (4::Integer)*(2:+3) doesn't work.
20:48:04 <bd_> dropdrive: (fromInteger 4 :: Quaternion) * (<some quaternion>) could however
20:48:05 <dropdrive> sorear, Ah, so there's no up-coercing operations?
20:48:26 <sorear> dropdrive: there are, but you must invoke them explicitly.
20:48:34 <dropdrive> bd_, yes, agreed.
20:48:38 <sorear> > (fromInteger (4 :: Integer)) :: Double
20:48:39 <lambdabot>  4.0
20:48:55 <dropdrive> > (4 :: Integer) * 4.0
20:48:56 <lambdabot>   add an instance declaration for (Fractional Integer)
20:48:58 <bd_> well, 4 will desugar to (fromInteger (4::Integer)) or similar in the compiler
20:49:51 <sorear> which is such a circular definition :)
20:51:10 <sorear> > map (\(a,b) -> a ++ "4" ++ b) $ iterate ((++"(fromInteger (") *** (" :: Integer))"++)) ("","")
20:51:12 <lambdabot>  ["4","(fromInteger (4 :: Integer))","(fromInteger ((fromInteger (4 :: Intege...
20:52:19 <allbery_b> :t 4
20:52:21 <lambdabot> forall t. (Num t) => t
20:52:59 <sorear> dropdrive: auiu, Complex a == Cayley a; Quaternion a = Cayley (Cayley a) ?
20:53:04 <sorear> aiui rather
20:54:04 <dropdrive> So it's not that 4*(2:+3) has 4 "up-coerced" from an integer to a complex number, it's that the compiler immediately sees the 4 as a complex number?
20:54:14 <sorear> correct
20:55:40 <dropdrive> Looking at the GHC docs, Data.Complex doesn't implement fromInteger...or does it?
20:56:00 <sorear> > 2 :: Complex Float
20:56:02 <lambdabot>  2.0 :+ 0.0
20:56:04 <sorear> it does
20:56:38 <allbery_b> it declares an instance Num, so it must
20:56:38 <dropdrive> sorear, whoops.
21:04:19 * sorear looks into having procmail eat Andrew J Wilkenson
21:04:27 <bos> qui?
21:04:31 <sorear> er, +'s buildbot failures
21:05:06 <sorear> may have made a bit of a deliberate typo there
21:08:23 <sorear> * ^Subject: [Yhc] buildbot failure in
21:08:24 <sorear> /home/stefan/Mail/spam-in
21:08:30 <sorear> muahahaha.
21:08:41 <allbery_b> oh, yhc buildbot
21:09:23 * allbery_b keeps thinking about joining the ghc buildbot, but that wouldmean he'd need to be more careful about keeping the external drive connected when not otherwise in use
21:09:25 <sorear> annoying, isn't it?  esp if emacs lets you know when you have mail
21:09:40 * sorear has only one hard drive
21:10:09 <sorear> also, my computer runs 8 hrs a day 5 days a week, 16 the other 2
21:10:11 <allbery_b> I'm on OSX, the extrenal drive is for backups but I had a spare partition on it and decided to make it case-dependent HFS
21:10:29 <allbery_b> and both OSX and freebsd boxen run 24x7
21:11:12 <allbery_b> as for receiving automated messages, work does that to me :)
21:11:19 <allbery_b> some of them I do to myself, even
21:12:47 <sorear> yech, case independant HFS
21:12:48 <encryptio> @where conjure
21:12:48 <lambdabot> http://darcs.haskell.org/~lemmih/conjure/
21:13:28 <sorear> "how can ANYONE tolerate a case insensitive fs?"
21:13:41 <bos> whee! i just got cabal to build an rpm of itself! "runghc Setup.lhs rpm"
21:13:56 <sorear> bos++ yay
21:13:57 <allbery_b> enh.  so far it's only beena problem for darcs projects :)
21:14:27 <sorear> not like I use anything rpm - so just imagine how many ++s the next rpm user will give you
21:15:00 <dons> bos, very nice!
21:15:02 * sorear can't remember the last time darcs used an uppercase letter 
21:15:14 <dons> i've almost got my nofib-shootout running now.
21:15:22 <sorear> dons++ very cool
21:15:23 <dons> hugs is about 2x slower than ghci across all the tests i've added so far
21:15:26 <dons> and ghc is like 100x fsater again
21:15:28 <bos> it obviously needs some work, but it's a big step. it should be usable as an example for building debs, too.
21:15:30 <allbery_b> several darcs projects, apparently including ghc, have some case-dependent filename renames buried in their diffs
21:15:38 <dons> now, just to measure memory, and print pretty graphs
21:15:43 <dons> and then build yhc and jhc
21:16:01 <allbery_b> ghc wouldn't get even with --partial until I moved it to casedep
21:16:22 <sorear> dons: is it set up as a darcs repo, so people who want to help you can shoulder more of the burden?
21:16:54 <dons> yes. it will be. its in darcs, and I intend to solicit patches
21:16:56 <dons> but want to get the basic graphs working first
21:18:20 * sorear resumes bothacking  .  .  .
21:23:41 <lokamlat> nice
21:26:11 <sorear> image based systems make it very easy to shoot yourself in the foot
21:26:34 <sorear> for instance, by defining 'erc-send-line to \ret in haskell-mode-map
21:27:52 <mnnclub> \x90
21:31:41 <sorear> testign
21:32:00 <sorear> testing
21:32:10 <sorear> good
21:32:41 <sorear> I'm not a fan of emacs configuration, with all the redundancy and unchecked type errors
22:05:32 <malsyned> Why is Haskell so freaking addicting!
22:06:11 <sorear> ccshan was here?!
22:06:23 <dons> yeah, a couple of times now
22:06:46 <sorear> well, if oleg won't come...
22:06:49 <sorear> :)
22:07:28 <sorear> ccshan of implict configurations, I assume?
22:10:57 <TomMD> Is this connection working, or did I mess up the config?
22:11:15 <sorear> pong!
22:11:28 <sjanssen> TomMD: you messed up the config
22:11:28 <TomMD> :) Thanks
22:11:56 <TomMD> I am now running Ubuntu.  Hello fresh OS.
22:12:24 <sorear> I'd like to stop running Debian and start running Haskell/Yi.
22:13:02 <TomMD> Once Osker lets me join IRC sessions && can use all my hardware && misc other stuff... yeah... I'll use that.
22:13:47 <sorear> when yi achieves parity with Emacs, it will have 4 irc clients
22:56:28 <goban> Bored by those lemmings who use wildly popular operating systems such as the HURD? http://lambda-the-ultimate.org/node/299
22:56:29 <lambdabot> Title: House , hOp - the Haskell Operating System | Lambda the Ultimate
23:00:40 <Cale> @where house
23:00:40 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
23:00:46 <Cale> @where hop
23:00:46 <lambdabot> http://www.macs.hw.ac.uk/~sebc/hOp/
23:11:00 <lokamlat> malsyned: cause you believe it is ;)
23:37:48 <sorear> Symbol's function definition is void: shim-buffer-filename-maybe-translated
23:38:01 <sorear> @seen beschmi
23:38:01 <lambdabot> I saw beschmi leaving #haskell, #darcs and #ghc 5h 30m 24s ago, and .
23:58:31 <dons> @time sorear
23:58:32 <lambdabot> Local time for sorear is Sat Feb 17 23:56:41 2007
