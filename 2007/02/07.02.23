00:01:43 <bhauth> Ever heard of Q?
00:02:29 <Japsu> the channel services bot in quakenet? ^^
00:02:37 <bhauth> The language.
00:02:51 <Japsu> heh
00:28:50 <dons> ok. cool. buitl ghc in 6 mins
00:28:54 <dons> yay for cores
00:29:15 <dons> doesn't get much above load avg of 5 though. need to break up the ghc module graph a bit
00:29:17 <therp> that's nice
00:29:37 <therp> what cpu?
00:29:55 <dons> amd64 2Ghz  x 16
00:30:31 <therp> one is not able to buy one of these right?
00:32:04 <yozora> anyone know what the dual of a categorical exponent is?
00:35:27 <dons> therp: sure you can
00:35:43 <dons> its just a commodity 16 core / 8 socket amd motherboard
00:35:49 <dons> not cheap though. but not too bad
00:36:06 <dons> let me find the url
00:36:14 <therp> nevermind, I'm scared.
00:36:32 <dons> heh
00:36:39 <dons> its certainly very hot and noisy
00:37:02 <araujo> hello
00:39:13 <fuzan> i can't seem to find htons /htonl equivalents. are they implemented in any module?
00:39:32 <dons> therp: here, nice desktop box, http://www.ipspty.com.au/index.php?comp=op3
00:39:33 <lambdabot> Title: PC Builder & Configuration - IPS Intelligent Systems Pty Ltd
00:40:51 <therp> dons: a bit over my budget for the moment :)
00:41:11 <dons> hehe. just don't buy a car :-)
00:41:19 <therp> but GHC in 6 mins? that would be really nice.
00:41:24 <dons> damn straight.
00:42:08 <ski_> yozora : coexponential
00:43:53 * dons tries -j64 just to see what happens
01:23:34 <hpaste>  fuzan pasted "learning state monad" at http://hpaste.org/599
01:24:04 <hpaste>  (anonymous) annotated "learning state monad" with "(no title)" at http://hpaste.org/599#a1
01:24:19 <fuzan> I've appended the error.
01:33:06 <quicksilver> fuzan: I can see a few surprising things about that code
01:33:22 <quicksilver> fuzan: have you build it up in stages? which definitions definitely work?
01:34:05 <fuzan> quicksilver: i had a small section working at one point, then I added the entire questionaire system to no avail :\
01:34:46 <quicksilver> fuzan: I would recommend building things up step by step especially when inexperience at haskell :)
01:35:10 <quicksilver> fuzan: I'll have a poke at your code, but one thing stands out immediately: those case statements are very odd
01:36:34 <ski_> yes
01:37:12 <ski_> 'case set of { correctWords   -> ...; ... }' will always choose the first alternative
01:38:09 <quicksilver> ski_: will it even compile? surely correctWords is not a pattern, it's a function?
01:38:12 <fuzan> you sure? set is a function from askQuestion
01:38:21 <quicksilver> fuzan: case is for matching constructors
01:38:30 <quicksilver> fuzan: or, rather, patterns
01:38:35 <quicksilver> fuzan: correctWords is not a pattern
01:38:42 <ibid> quicksilver: yes it is
01:38:50 <quicksilver> ibid: how is it a pattern?
01:39:01 <ibid> quicksilver: because it's a variable
01:39:11 <quicksilver> ah
01:39:14 <quicksilver> of course
01:39:15 <ibid> fuzan: the first alternative is creating a local variable correctWords that shadows the toplevel definition
01:39:22 <quicksilver> ibid: thanks :)
01:39:45 <quicksilver> Allow me to rephrase 'correctWords meaning what fuzan wanted it to mean is not a pattern' :)
01:39:51 <ibid> quicksilver: true :)
01:40:00 <ibid> fuzan: and that variable gets as its value the value of set
01:40:25 <quicksilver> having said that, that isn't hte cause of fuzan's actual error
01:40:33 <ibid> fuzan: you probably want to have Quiz be a variant and not a record
01:40:36 <quicksilver> although it does mean his code would behave surprisingly
01:40:43 <ibid> quicksilver: true. it's strange though
01:41:02 <quicksilver> ibid: no, his Quiz is definition is correct, I believe. A quiz is a 3 lists of words
01:41:19 <quicksilver> ibid: ones you got wrong before, ones you got right before, and ones you haven't tried yet
01:41:24 <ibid> quicksilver: well, then the case is wrong :)
01:41:28 <quicksilver> agreed
01:41:31 <ibid> but i need to go, bbl
01:44:42 <fuzan> alright, refactoring :) thanks.
01:47:02 <dcoutts> chessguy: that Xlib error is because you're using threads unsafely, eg by using SOE in GHCi.
01:47:02 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:47:13 <dcoutts> @seen chessguy
01:47:14 <lambdabot> I saw chessguy leaving #haskell 4h 19m 4s ago, and .
01:47:24 <dcoutts> @tell chessguy that Xlib error is because you're using threads unsafely, eg by using SOE in GHCi.
01:47:25 <lambdabot> Consider it noted.
01:58:02 <huschi> i've got a function that is polymorphic in it's return type and need a dummy variable of that type in the body.
01:58:16 <huschi> something like "undefined :: a" does not work.
01:58:30 <huschi> how can i achieve that behaviour?
01:59:00 <ski_> foo x y :: a = ..a..
01:59:33 <dons> a lexically scoped type variable, yeah
01:59:41 <huschi> ??
01:59:47 <huschi> i don't understand.
01:59:50 <dons> foo x (y :: a) = ... (z :: a) ...
01:59:51 <dons> ?
01:59:57 <dons> can you show us the function?
02:00:01 <quicksilver> return type, he said
02:00:04 <quicksilver> so
02:00:14 <quicksilver> foo x y :: a = ..... (undefined :: a) ....
02:00:18 <dons> (undefined :: a) should be ok if 'a' is bound in the type decl
02:00:20 <notsmack> hmm, how do i convert CFloat to Float?
02:00:29 <dons> realToFrac ?
02:00:34 <huschi> mhm, i will put it into hpase.
02:00:42 <notsmack> dons: oh, easy enough, thanks :-)
02:01:36 <hpaste>  huschi pasted "(no title)" at http://hpaste.org/600
02:01:50 <huschi> oops, i forgot the title.
02:02:08 <dons> and it is 'x' you need a type for?
02:02:19 <huschi> yes.
02:02:32 <hpaste>  apfelmus annotated "(no title)" with "GHC 6.6 - type variables are introduced with forall" at http://hpaste.org/600#a1
02:02:38 <dons> `asTypeOf` is better written as a lexically scoped tyvar
02:03:01 <dons> asTypeOf is really a legacy from the days before we could bind tyvars everywhere
02:04:27 <dons> what's the type of 'return x' ?
02:04:33 <dons> XMLParser a ?
02:04:42 <huschi> wow.
02:04:45 <huschi> now it works.
02:04:46 <quicksilver> why is it needed anyway?
02:04:57 <huschi> why is what needed?
02:04:58 <quicksilver> surely with the explicit type annotation the `asTypeOf` isn't required?
02:05:09 <dons> i'd think so, yes.
02:05:10 <apfelmus> @google ghc user's guide 7.4.10
02:05:12 <lambdabot> http://www.reed.edu/~carlislp/ghc6-doc/users_guide/users-guide.html
02:05:20 <huschi> i've throws the asTypeOf away.
02:05:23 <dons> apfelmus++ quick fix
02:05:38 <huschi> thank you very much!
02:05:54 <apfelmus> it's described in section 7.4.10 of the user's guide
02:06:10 <quicksilver> huschi: astypeof and scoped type variables are only need for very exotic tricks
02:06:28 <quicksilver> most of the time the inferrer gets it right; and with an explicit type annotation on the function it has no excuse
02:07:03 <huschi> i don't know what scoped type variables are, for now.
02:07:06 <apfelmus> note that ghc 6.6 treats type variables differently than ghc 6.4
02:07:11 <quicksilver> 'a' in apfelmus's soltuion
02:07:20 <quicksilver> but I don't think you need it :)
02:08:26 <huschi> quicksilver: you mean i don't need it generally?
02:08:36 <huschi> but for this problem i need it.
02:10:16 <xerox> huschi: the "forall a." defines the 'a' used in "x = undefined :: a" so that they are actually the same type variable.
02:10:45 <huschi> xerox: ah, now i understand. thx.
02:10:53 <xerox> You're welcome.
02:11:57 <xerox> (The 'a' used in both the toplevel type signature, and in that binding.)
02:13:02 <quicksilver> huschi: I wouldn't have thought you needed asTypeOf
02:13:14 <quicksilver> huschi: and hence, I wouldn't have thought you needed undefined :: a at all
02:13:47 <quicksilver> oh hangone
02:13:53 <ibid> why won't undefined work?
02:13:55 <quicksilver> you're using x in the toHType
02:13:56 <ibid> damn
02:13:58 <ibid> sorry :)
02:14:03 <quicksilver> I didn't see that
02:14:11 <huschi> quicksilver: :)
02:14:14 <ibid> ETEMPORAL :)
02:14:39 <quicksilver> huschi: now I understand :)
02:14:47 <huschi> quicksilver: the polymorphic type of toHType was what made the problem.
02:15:13 <quicksilver> I would argue that the problem is that toHType is 'morally' a function on types, not values
02:15:27 <quicksilver> and we use (undefined :: a) as a way to embed types into our value language
02:15:38 <quicksilver> because we dont' have type-valued functions
02:16:15 <huschi> quicksilver: yeah, that sounds goog.
02:16:18 <huschi> good, i mean.
02:17:05 <OneSadCookie> hi all... is this an appropriate place to ask newbie-ish questions?
02:17:13 <notsmack> OneSadCookie: yep
02:17:19 <OneSadCookie> cool
02:17:32 <OneSadCookie> I learned haskell a while ago, and just today decided to try my hand at it again
02:17:43 <OneSadCookie> wrote me a simple brute-force recursive sudoku solver
02:17:57 <OneSadCookie> but I have a thing going on I don't understand with I/O
02:18:07 <OneSadCookie> the source is here: http://onesadcookie.com/trac/browser/Sudoku/Main.hs
02:18:10 <lambdabot> Title: /Sudoku/Main.hs - OneSadCookie - Trac
02:18:25 <OneSadCookie> on line 57 I'd "like" to close the puzzle file
02:18:55 <OneSadCookie> but when I uncomment that line, the s that was "assigned" on the line above is always the empty string
02:19:11 <OneSadCookie> I thought the do construct / IO monad was supposed to guarantee ordering?
02:19:50 <notsmack> laziness still happens i believe
02:19:53 <OneSadCookie> also peculiarly, if I insert a putStrLn s before the hClose f, then it still works despite the close
02:20:01 <huschi> OneSadCookie: the poblem is that hGetContents is lazy.
02:20:32 <huschi> OneSadCookie: and hGetContents closes the handle on it's own afaik.
02:20:40 <OneSadCookie> that's OK then :)
02:21:00 <OneSadCookie> I was wondering where I was going to need to put the hClose if I had to do the return s first, or something
02:21:32 <huschi> OneSadCookie: but Prelude.readFile should do the same as your readWholeFile.
02:21:42 <OneSadCookie> oh, that'd be handy :)
02:21:57 <OneSadCookie> don't have a good idea of what the standard libraries do and don't have yet
02:22:16 <huschi> @hoogle FilePath -> IO String
02:22:17 <lambdabot> Prelude.readFile :: FilePath -> IO String
02:22:30 <OneSadCookie> cool
02:22:31 <OneSadCookie> thanks
02:22:33 <huschi> OneSadCookie: hoogle is your friend.
02:24:16 <dons> ?docs System.IO
02:24:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
02:26:55 <quicksilver> OneSadCookie: it's a common misconstruction that monads guarantee ordering
02:27:09 <quicksilver> OneSadCookie: they only guarantee 'enough' ordering to satisfy the data dependencies
02:27:15 <quicksilver> (so some will be read before its used)
02:27:28 <quicksilver> they don't guarantee complete ordering, or command completion, or suchlike
02:29:55 <roconnor> quicksilver: still, you'd think that if you do a read, followed by a delete, you would still have access to the data you ``read''.
02:30:14 <OneSadCookie> the docs explain why it happens this way... the weird semi-closed state
02:31:08 <huschi> OneSadCookie: i think it happens because hGetContents does't read the contents immediatly but lazy.
02:31:24 <huschi> so if you close the handle, hGetContents can't read anymore.
02:31:41 <quicksilver> roconnor: agreed. That's an infelicity with the current implementation.
02:31:48 <OneSadCookie> yeah, reads lazily, and the file is semi-closed, and when a semi-closed file is actually closed, its content is frozen
02:32:09 <OneSadCookie> seems wacky, but it's possible to see why it works that way :)
02:32:14 <huschi> OneSadCookie: the semi-closed state has the effect that you can't read using hGetChar from the handle.
02:35:00 <roconnor> quicksilver: I suppose once haskell is integrated into the operating system, all will be fine. ;)
02:35:07 <dons> you can also read strictly. Data.ByteSTring.readFile is a strict op
02:35:19 <dons> so is hGetContents >>= \s -> length s `seq` s
02:35:34 <dons> but actually needing strict IO is pretty rare
02:35:53 <dons> usually readFile is a better choice (unles you're using files as mutable variables)
02:35:57 <dons> (i.e. reading and writing the same file)
02:36:09 <quicksilver> dons: ideally you'd want hGetContents to be lazy but 'sensitive' so that if something else tried to write to, or delete, the file it was slurped in.
02:36:24 <dons> or just provide strict hGetContents
02:36:27 <dons> as well
02:36:35 <quicksilver> dons: of course it couldn't be sensitive to other processes without flock, which probably wouldn't be desired, but within the haskell RTS at least
02:36:39 <dons> since some programs need that. so we should make it easy
02:37:03 <dons> i usually use Data.ByteString.readFile >>= return unpack
02:37:06 <dons> when i need strict io
02:37:10 <quicksilver> :t unpack
02:37:12 <lambdabot> Not in scope: `unpack'
02:37:16 <quicksilver> unpack?
02:37:18 <dons> :t Data.ByteString.unpack
02:37:21 <lambdabot> Data.ByteString.Base.ByteString -> [Word8]
02:37:24 <quicksilver> ah, gotcha
02:37:28 <dons> :t Data.ByteString.Char8.unpack
02:37:30 <lambdabot> Data.ByteString.Base.ByteString -> [Char]
02:37:34 <quicksilver> is that a lazy unpack?
02:37:39 <dons> yep
02:37:45 <quicksilver> Data.ByteString+
02:37:48 <quicksilver> Data.ByteString++
02:37:49 <quicksilver> :)
02:38:04 <dons> its surprising how rare strict IO is needed
02:38:16 <dons> i only need it maybe 3 or 4 times a year
02:38:17 <xerox> :t Data.ByteString.unpack `fmap` Data.ByteString.readFile
02:38:20 <lambdabot>     Couldn't match expected type `Data.ByteString.Base.ByteString'
02:38:20 <lambdabot>            against inferred type `IO Data.ByteString.Base.ByteString'
02:38:29 <quicksilver> dons: mainly for people concerned about concurrent access or read/write access, I imagine
02:38:34 <dons> yeah
02:38:42 <quicksilver> dons: implementing an RDBMS in haskell you'd need strict IO sometimes, for example
02:38:49 <dons> right.
02:39:01 <xerox> ?type Data.ByteString.unpack `fmap` Data.ByteString.readFile undefined
02:39:02 <dons> you need to know sometimes that an action has been evaluated, for its effect on the outside world
02:39:04 <lambdabot> IO [Word8]
02:40:42 <dons> some more interesting shootout numbers, http://www.cse.unsw.edu.au/~dons/nobench/results.html
02:40:42 <lambdabot> Title: nobench: Haskell implementation shootout
02:40:56 <dons> the first two categories i've vetted for bugs, so should be pretty accurate
02:41:04 <dons> the 'real' category still has some bogus failures
02:41:29 <dons> some real bugs have been identified.which is nice
02:45:04 <dcoutts> dons, very nice summary page!
02:46:27 <dcoutts> nice colours too :-)
02:49:02 <dons> gimp has a nice colorwheel
02:50:14 <dons> dcoutts: [dons@serenity ~]$ cat /proc/cpuinfo   | grep processor  | tail -1
02:50:15 <dons> processor       : 15
02:50:16 <dons> :-0
02:50:28 <dons> its alive!
02:50:32 <dcoutts> mmm
02:50:49 <dcoutts> but ghc builds don't parallelise enough! :-)
02:51:05 <dons> right.
02:51:14 <dons> we could get all 16 cores occupied briefly
02:51:17 <dons> but the best load avg was 5
02:51:26 <dons> things like Parser and GHC.Handle are bottlenecks in the build
02:51:30 <dons> Cpu15 :  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
02:51:30 <dons> Mem:  16141292k total,  2052328k used, 14088964k free,   146428k buffers
02:51:45 <dons> top has settings for smp i've never used before :)
02:52:19 <dcoutts> heh :-)
02:52:42 <dcoutts> dons, so what was the total GHC build time ?
02:52:55 <dons> 6 mins
02:53:00 <dcoutts> wow
02:53:07 <dons> so a little bit better than the 4 core box
02:53:21 <dcoutts> so if we could make full use of the cores then it'd be 2 min ?
02:53:23 <roconnor> HBC is pretty good
02:53:25 <dcoutts> 3x faster
02:53:37 <dons> i reckon. we could build the extra libs concurrently with staaage2
02:53:45 <dons> currently each package is built in order
02:54:16 <dons> roconnor: yeah, but purely h98 and not maintained
02:54:18 <dcoutts> dons, so you need to tell JaffaCake that if only he can eek a bit more parallelism out of the build system then you'll enable him to do 2min builds :-)
02:54:20 <dons> we need to get the src into darcs
02:54:25 <dons> dcoutts: right!
02:54:29 <dcoutts> dons, that'd be a nice buildbot :-)
02:54:30 <dons> i think we just give him an account
02:55:50 * dcoutts pushes more c2hs C parser patches
02:55:51 * dcoutts -> office
02:56:02 <roconnor> there are a suprising number of output errors.
02:56:06 <roconnor> :(
02:56:08 <pjd> s/eek/eke/
02:56:38 <dons> ?docs System.Process
02:56:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
02:56:44 <roconnor> heh, HBC does nothing the fastest
02:57:01 <roconnor> Hugs is the slowest at doing nothing
02:57:28 <dons> so we'll have to bug ndm about why he uses hugs of ghci..
02:57:32 <dons> s/over/
02:58:05 <mrchebas> roconnor: isn't hbc doing well in the spectral ones (modulo the failed ones)?
02:58:17 <dons> mm. yes.
02:58:30 <dons> though mandelbrot is a bit of a standaout
02:59:07 <dons> pretty good for a compiler that hasn't been patched in 10 years :-)
02:59:11 <mrchebas> yes, totally
02:59:22 <mrchebas> i thought it was bitrotted or something
02:59:41 <dons> its just not maintained and not available. that's all
02:59:50 <dons> though we should be able to get the src i think
03:00:00 <dons> failing that, i have a copy of the 2004 src
03:02:26 <mrchebas> for the programs that compile at all, jhc does a good job
03:02:39 <dons> also, most of hugs programs fail due to stack overflow
03:02:48 <dons> so if anyone knows how to tweak the stack size on hugs..
03:03:10 <dons> hugs pays somewhat for not using libgmp too
03:03:24 <dons> it produces some odd floating output, and also just plain runs slow in things like pidigits
03:04:54 <dblhelix> help! I'm trying to build GHC  HEAD from darcs...:
03:04:55 <dblhelix> ghci/InteractiveUI.hs:69:7:
03:04:55 <dblhelix>     Could not find module `System.Console.Readline':
03:04:55 <dblhelix>       Use -v to see a list of the files searched for.
03:04:56 <dblhelix> <<ghc: 319697704 bytes, 52 GCs, 4121969/9458180 avg/max bytes residency (4 samples), 26M in use, 0.02 INIT (0.00 elapsed), 2.60 MUT (18.50 elapsed), 0.38 GC (0.49 elapsed) :ghc>>
03:04:56 <dblhelix> make[2]: *** [depend] Error 1
03:04:58 <dblhelix> make[1]: *** [stage2] Error 2
03:05:00 <dblhelix> make: *** [bootstrap2] Error 2
03:05:04 <dons> no readline installed
03:05:07 <dons> ?
03:05:24 <dblhelix> perhaps the wrong version?
03:06:06 <dblhelix> $ ls /usr/local/lib/libreadline*
03:07:10 <dblhelix> /usr/local/lib/libreadline.5.0.dylib /usr/local/lib/libreadline.a
03:07:21 <dblhelix> /usr/local/lib/libreadline.5.2.dylib /usr/local/lib/libreadline.dylib
03:07:31 <dblhelix> /usr/local/lib/libreadline.5.dylib
03:09:14 <ulfdoz> dblhelix: are the paths to the headers in  $(INCLUDE)?
03:09:45 <notsmack> sweet, segfault.
03:10:17 * notsmack grumbles and reads the FFI docs more
03:10:18 <dblhelix> ulfdoz: they are
03:10:56 <JohnMeacham_> hello! someone said my name, but my buffer doesn't go back far enough to see whom.
03:10:57 <lambdabot> JohnMeacham_: You have 1 new message. '/msg lambdabot @messages' to read it.
03:11:05 <dons> ?logs ?
03:11:06 <lambdabot> ? not available
03:11:11 <dons> ?where logs
03:11:11 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
03:13:39 <dcoutts_> dons, btw, did you get my patches when I re-sent them ?
03:13:57 <JohnMeacham_> jhc's new backend is turning out to be vastly more promising than I expeted. I am pleased.
03:14:26 <JohnMeacham_> I am calling it 'fgrin' for fast-grin.
03:14:28 <dcoutts_> dons, I think my local mail must be working as when I did darcs send --cc myself I got the mail.
03:14:53 <dcoutts_> JohnMeacham_, what's the major difference vs the last grin style backend?
03:15:43 <dblhelix> dons, ulfdoz: it's a mac issue... wrong readline api, i.e., libedit :-S
03:16:33 <JohnMeacham_>  dcoutts_: a complete rewrite. more based on the STG of ghc, but utilizing as much of the grin optimizations as possible. it is nicer because it doesn't _need_ full program analysis, it just benefits from it. so separate compilation isn't an issue.
03:17:05 <dcoutts_> JohnMeacham_, oh nice, so you'll be able to do separate compilation?
03:17:12 <dcoutts_> JohnMeacham_, currently you're using ghc as a backend right? just to give you something working while you hack on the front/middle ?
03:17:27 <JohnMeacham_> dcoutts_: yes.
03:18:05 <dcoutts_> JohnMeacham_, perhaps you need to get JaffaCake to extend that keyboard-eating offer to you too! :-)
03:18:21 <JohnMeacham_> dcoutts_: no, there is a grin backend. the ghc backend was just a hack for testing. I am working on a third backend now. testing without -fvia-ghc would be intesesting.
03:18:27 <mrchebas> JohnMeacham_: I understand that grin defunctionalizes programs, fgrin does not do it anymore?
03:18:42 <JohnMeacham_> dcoutts_: that jhc works as an optimizing front end for ghc was a bonus.
03:19:33 <dons> dcoutts_: no patches yet!
03:19:36 <dcoutts_> JohnMeacham_, well, I hope you keep us posted on your progress, I'm especially interested in performance of tight loops these days (ByteStrings, Binary, fused list code etc)
03:19:37 <dons> got a repo online?
03:19:40 <dcoutts_> dons, hmmm
03:19:48 <dcoutts_> dons, yeah, I'll put it online
03:19:54 <JohnMeacham_> no. it does. but it can fall back on a function pointer if it can't prove where a thunk came from. it turns out, most thunks are generated locally, so this isn't much of an issue.
03:20:37 <dcoutts_> JohnMeacham_, sounds very sensible, fall back to STG style when the analysis can't tell you the source/shape of the value.
03:20:51 <JohnMeacham_> the old back end had no reocurse. every function call needed to be resolved at complie time. the new one 'fgrin' is more of a hybrid.
03:20:59 <mrchebas> JohnMeacham_: that's a nice balance: defunctionalize locally but retain closures at a global level. Is it a reasonable summary?
03:21:31 * malcolmw is sure he has a copy of the hbc sources somewhere
03:22:52 <malcolmw> dons: can i complain that k-nucleotide is not written in Haskell, so it is unfair to include in a benchmark? :-)
03:24:09 <JohnMeacham_> mrchebas: more or less. but globally and locally arn't terribly well defined. i have considered something like this before as a 'hack' but now it is looking like a promising main back end. inner loops are still reallly fast, but separate compilation and the flexability of not having to accumulate everything at once is preserved. tyye classes are still an issue though. I will worry about them later.some serious benchmark
03:24:09 <JohnMeacham_> ing will be needed bedore making decisions about them.
03:25:54 <dons> malcolmw: totally. I think it has some 'kill this' comments in it
03:26:05 <dons> its just an inner loop that can be knocked on the head
03:26:17 <dons> malcolmw: i've got a copy of the 2004 src
03:26:31 <dons> but surely lennart has some scraps we can beg for
03:26:38 <mrchebas> JohnMeacham_: nice work
03:26:54 <malcolmw> dons: lennart told me on Weds that we wasn't sure he still had a copy of the sources himself
03:27:02 <dons> yikes
03:27:10 <dons> hmm. ok.
03:27:17 <malcolmw> dons: but I think I might have persuaded him to adopt hierarchical module names
03:27:18 <dons> maybe i should stick my src in darcs and be done with it
03:27:22 <dons> hehe.
03:27:33 <malcolmw> dons: I think my sources were last fixed in 2005
03:27:47 <malcolmw> dons: Sven Panne did some resurrection work then
03:27:51 <dcoutts_> dons, darcs get http://haskell.org/~duncan/bytestring/fps-unstable
03:27:53 <lambdabot> Title: Index of /~duncan/bytestring/fps-unstable
03:27:55 <dons> ah good.
03:28:00 <dons> dcoutts_: cheers
03:28:12 <dons> malcolmw: so i've gone through the output errors for imaginary and spectral
03:28:19 <dons> any that are left seem legitimate
03:28:26 <JohnMeacham_>  dcoutts_:  well , jhc alwasy has rocked at tight loops. I ahve a few examples that turn into SSE vectorized instructions. leading to a hundredfold increase over even C code (with a new version of gcc and a SSE enabeled cpu). but for many benchmarks, other aspects of jhc overtook the nice inner loops. the new backend should take care of that, the old one was absurdly great when it worked, but pessimsal when it didin't.
03:28:26 <JohnMeacham_> the new one should be at least as fast as ghc always, but can take advantage of my crazy optimizations  when it can.
03:28:31 <JohnMeacham_> at least. that is the theory.
03:28:58 <dons> JohnMeacham_: hmm. you should have a poke at mandelbrot then
03:29:01 <dcoutts_> JohnMeacham_, I look forward to it! :-)
03:29:06 <JohnMeacham_> If you could run the nobench without the -fvia-ghc as well, that would be cool.
03:29:09 <dons> that's all double math, and benefits from sse on ghc/gcc
03:29:25 <dons> JohnMeacham_: ok. need to get the new jhc src
03:29:26 <malcolmw> dons: so the current results on the webpage allow for floating-point differences.  good
03:29:42 <dons> yeah, i fixed two I think.
03:30:13 <dons> spectral-norm is odd though. ghc and C produce the same results as other things on the shootout, but hugs and nhc produce identical, wrong results
03:30:17 <JohnMeacham_> but. I just designed it recently. so am suffering from honeymoon bias. but I think it will hold up.
03:30:33 <malcolmw> dcoutts was telling me yesterday that giving -optc-fpmath=sse to ghc does not cause the code to be vectorised, merely to use a different (faster) FP implementation on chip
03:30:34 <JohnMeacham_> if nothing else, the separate compilation will be nice for developers.
03:30:42 <dons> yeah
03:31:01 <dons> you get the sse fp math subsystem, not the vector instructions
03:31:21 <dcoutts_> malcolmw, in general, yes. gcc has some very very primitive autovectorisation I believe in very recent versions.
03:31:42 <dons> the C and C++ guys go to great length to get proper vectorised loops on the great language shootout, seems non-trivial
03:31:49 * malcolmw is hoping to get a student to write a nice vectorised library in haskell
03:31:54 <dons> they use libs that provide native sse_float_t i think
03:31:59 <mrchebas> dons: what's so nice about mandelbrot? a tight inner loop?
03:32:04 <dcoutts_> the point being you're only going to get gcc to do auto vectorisation if you write your C code very carefully and in an idiomatic way
03:32:30 <dons> mrchebas: well, its not so nice. it just shows nicely any problems with fp math in tight loops
03:32:44 <JohnMeacham_> the new gcc is great at auto vectorizing actually. -fauto-vectorize. really good. you just need to be sure to get things aligned propenly, and state yoru loops in terms of array offsets instead of pointer arithmetic.
03:32:52 <malcolmw> was spectral-norm in nofib?
03:33:00 <dons> nope. that's another shootout program
03:33:12 <dons> the ones i included because they were particularly stressful to write
03:33:53 <xerox> What does `vectorizing' mean exactly?
03:33:57 <JohnMeacham_> I ran some numbers recently. on my Athlon 64, I got a 2.5x speedup. on my pentium 3, I got a 53x (!!!) speedup by aligning things properly. you need at least gcc 4.1.
03:34:09 <dons> JohnMeacham_: hmm!
03:34:10 <JohnMeacham_> using SIMD instructions.
03:34:32 <dons> ok. so what do i have to do on the nobench now? fix k-nuc to be haskell. get new jhc. and walk through the 'real' category
03:34:33 <JohnMeacham_> thinhs like 'multiply the 4 numbers here with the 4 numbers there' rather than doing one thing at a time.
03:35:10 <JohnMeacham_> dons: well you do  jhc-ghc. the only difference would be to not put the -fvia-ghc flag on to do jhc grin proper.
03:35:16 <dons> ah right.
03:35:23 * dons takes down some notes
03:35:34 <malcolmw> I wonder if spectral-norm is sensitive to any float<->double casting errors
03:35:57 <dons> malcolmw: do you see the slightly-off results?
03:36:14 <dons> ah, reminds me. need to tar up the output files too and publish them
03:36:19 <malcolmw> 1.274224148
03:36:19 <malcolmw> 1.273732581
03:36:28 <dons> that's it
03:36:31 <malcolmw> the former from ghc, the latter from nhc98
03:36:36 <dons> i have a C program too if you'd like
03:37:10 <dons> http://www.cse.unsw.edu.au/~dons/tmp/t.c
03:37:17 <dons> it produces the same output as ghc.
03:39:15 <malcolmw> I feel the use of type Reals = Ptr Double with lots of peeks and pokes is rather unidiomatic haskell :-)
03:40:28 <JohnMeacham_> hey. what do you think when you say the haskell standard only guarentees 30 bits for Int? do you assume 30 bit modular arithmetic or numbers beyon +/-2^29 are undefined?
03:41:16 <quicksilver> dons: slightly-off? ouch! a difference in the 3rd dp is more than 'slightly off'!
03:41:20 <dons> malcolmw: very much so. it was really too hard to get this program to compete with C
03:41:51 <dons> suggestions welcome :-)    lennart rewrote a version of it to use STUArray
03:41:55 <dons> but there was a 10% slowdown
03:42:02 <malcolmw> I think the standard says Int must be at least 30 bits.  But in any case, your implementation must declare its bounds (instance Bounded Int).  Beyond the declared bounds, behaviour is undefined, but within them, it must be normal arithmetic
03:42:10 <earthy> John: I assume I can go up to 2^29-1 and down to -2^29
03:42:38 <JohnMeacham_> earthy: but you wouldn't assume modular arithmetic beyond that?
03:42:45 <earthy> nope.
03:42:56 <earthy> it might just blow chunks
03:43:07 <earthy> but I've been indoctrinated by MIX. :)
03:43:29 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
03:43:32 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/bruf8
03:43:37 <dons> clean does a bit better, but has types like, aloop :: !Real !Int !Int !{#Real} !*{#Real} -> .{#Real}
03:43:40 <dons> i.e. Ptr Double ;)
03:43:42 <JohnMeacham_> becaus. I am thinking about making ints 30 bits on 32 bit arches. but only when they are boxed. so, beyond 30 bits would be truely undefined rather than mod 30.
03:44:01 * malcolmw is considering rewriting spectral-norm to use lists :-) 
03:44:05 <earthy> no problems there, john
03:44:12 <earthy> I'd expect that
03:44:19 <dons> malcolmw: i think i've got some old versions around. let me see..
03:44:31 <earthy> (in fact, if I'd get 30 bits ints on a 32 bit arch, I'd expect the other 2 to be tags)
03:45:22 <dons> malcolmw: there's an STUArray entry, http://haskell.org/haskellwiki/Shootout/Spectral#Current_entry_2
03:45:24 <lambdabot> Title: Shootout/Spectral - HaskellWiki
03:45:51 <malcolmw> hmm, nhc98 doesn't have STUArrays
03:45:55 <earthy> damn this freaking slowness in Dazzle.
03:45:56 <dons> maybe i should just submit a bug report: this program is too hard to write
03:46:09 <JohnMeacham_> yeah. I am not going to be tagging things in general. but it would be nice to be able to clobber a couple bits without guilt every now and again.
03:46:19 <earthy> I only have 3300 tuples of 69 elements! stupid program!
03:47:09 <araujo> morning
03:47:16 <dons> hey araujo
03:47:24 <araujo> hello dons :-)
03:49:13 * dons runs nobench on the amd64 16 core box
03:49:24 <dons> pity it will only use 1 core :}
03:49:45 <sendo_> anyone know anything about arc-consistency algorithms?
03:50:22 <araujo> dons, nice
03:51:16 * dons gives up and types $ make -j16
03:51:29 <araujo> haha
03:51:43 * earthy grins
03:51:58 * earthy obviously has more patience. ;)
03:52:38 <earthy> (profiling a program that runs for 20 minutes just to know where exactly the problem is that with some rewriting will bring that runtime down to 13s)
03:53:17 <dons> mmm :-)
03:53:51 * earthy hugs the ghc profiler
03:54:03 * xerox ghc the hugs profiler    o_0
03:54:30 <dons> hehe
03:55:34 * sieni profiles the ghc hugs
03:56:12 * dons hugs the gofer
03:56:37 <malcolmw> dons: I've found a file called hbc-20030211.src.tar.gz - maybe yours is newer?
03:56:51 <earthy> it's obviously friday afternoon
03:57:58 <dons> hbc-2004-06-29.src.tar.gz
03:58:54 <dons> and lennart's not sure he has some src eh? hmm.
04:00:37 <malcolmw> the sources are still available at http://www.cs.chalmers.se/pub/haskell/chalmers/hbc/
04:00:39 <lambdabot> Title: Index of /pub/haskell/chalmers/hbc
04:00:43 <dons> ah ha!
04:01:01 <malcolmw> but not as recent as yours, latest is 2003-02-11
04:02:06 <dons> ok. darcs time.
04:03:27 <malcolmw> I see a win95hbc.tar.gz.  That will please ndm.
04:03:58 <dons> hehe
04:05:21 <xerox> http://www.cs.chalmers.se/pub/haskell/chalmers/hbc/hbc/hbc/hbc/hbc/hbc/
04:05:23 <lambdabot> Title: Index of /pub/haskell/chalmers/hbc/hbc/hbc/hbc/hbc/hbc, http://tinyurl.com/23codz
04:06:50 <rahikkala> Forbidden: You don't have permission to access /pub/haskell/chalmers/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc/hbc on this server.
04:06:55 <rahikkala> :(
04:07:20 <xerox> o_o
04:13:55 <dons> $ darcs get http://www.cse.unsw.edu.au/~dons/code/hbc
04:13:56 <lambdabot> Title: Index of /~dons/code/hbc
04:14:00 <dons> not sure if that will compile though. untested!
04:20:15 <stmartin> I'm a beginner, working through the exercises in a Haskell tutorial, but I'm having difficulty interpreting this error from Hugs:
04:20:23 <stmartin> ERROR "NumStats.hs":29 - Unresolved top-level overloading
04:20:23 <stmartin> *** Binding             : mygetNum
04:20:23 <stmartin> *** Outstanding context : Read (IO b)
04:20:36 <dons> would you like to paste your src here:
04:20:37 <dons> ?paste
04:20:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:20:55 <dons> that's the best way. once we can see the code its often clear what the problem is.
04:21:06 <dons> Read (IO b)
04:21:14 <dons> hints that you're trying to apply 'read' to an IO action
04:21:21 <dons> and not the result of the IO action.
04:21:23 <ehird> hm, someone mentioned improving the haskell textmate bundle last night - i think i could rebind tab to do layout
04:21:42 <dons> so, possibly, read getLine instead of say, do s <- getLine ; return (read s)
04:22:22 <hpaste>  stmartin pasted "getNums" at http://hpaste.org/601
04:23:08 <dons> ah, easy :-)
04:23:13 <dons> return (read numStr)
04:23:38 <dons> you need to return the result in the IO monad.
04:23:57 <dons> stmartin: does that help?
04:23:59 <stmartin> I'm confused. Why does this matter? Doesn't it just return the last value?
04:24:38 <stmartin> I mean, what is the diff between return .... and .... as the last thing executed in a function?
04:25:55 <quicksilver> stmartin: return (foo) is if foo is a plain value
04:26:06 <quicksilver> stmartin: (foo) alone is if foo is in fact an IO action
04:26:17 <quicksilver> (more generally any monad, but your particular program is running in IO)
04:26:45 <quicksilver> so it would be (return "hello") but (getLine)
04:26:55 <quicksilver> because "hello" is a string, but getLine is an IO string
04:26:55 <beschmi> @where shim
04:26:56 <lambdabot> http://shim.haskellco.de/trac/shim
04:27:07 <quicksilver> the brackets are just to make my comment easy to read, they aren't needed in haskell code :)
04:27:11 <beschmi> @where shim http://shim.haskellco.de/
04:27:11 <lambdabot> http://shim.haskellco.de/trac/shim
04:27:13 <ski_> (dons : hm, do you know where one can find lml, then ?)
04:27:18 <beschmi> @where+ shim http://shim.haskellco.de/
04:27:18 <lambdabot> Done.
04:27:26 <dons> ski_, ah we need lml too then. hmm.
04:27:30 <dons> i have all these on disk somewhere
04:27:31 <dcoutts_> dons, I'm sure this isn't the fastest implementation of concatMap f = foldr ((++) . f) []
04:27:46 <dons> ski_: what about from the chalmers url?
04:27:47 <dcoutts_> dons, that's from GHC.List
04:27:51 <dons> hmm.
04:28:04 <malcolmw> hbc seems to lack a powerpc code generator
04:28:24 <ski_> dons : from a cursory glance there, i didn't see it
04:28:30 <stmartin> Ok... with  return (read numStr), the error message is the same, with the exception that the "Outstanding context" is Read b, instead of Read (IO b)
04:28:52 <dons> stmartin: you need to provide a type signature here
04:29:00 <dons> so that 'read' knows what value it is trying to parse
04:29:00 <malcolmw> ski_: the hbc darcs repo contains a directory called lmlc
04:29:07 <dons> e.g. getNum :: IO Integer
04:29:12 <ski_> (dons : .. istr augustss mentioning something about security nazis disabling anonymous ftp, though ..)
04:29:15 <stmartin> No fair, the tutorial hasn't mentioned that yet :(
04:29:22 <JohnMeacham_> off to bed. ttyl.
04:29:53 <quicksilver> stmartin: often it can work it out from context
04:29:57 <JohnMeacham_> btw. mercury the language has been doing a lot of cool implementation stuff. that is what I plan on dreaming about tonight.
04:30:23 <ski_> malcolmw : and it is empty ..
04:30:24 <quicksilver> stmartin: as soon as you 'did something obviously numbery' with the result of that read
04:30:29 <quicksilver> stmartin: it would work it out
04:30:42 <quicksilver> stmartin: but since you never use the result of the read, it can't decide what you wanted
04:30:48 <dons> right. if you use the result as a number, it will act like a number :-)
04:31:21 <ehird> yaht likes using syntax not introduced yet...
04:31:37 <ehird> my_length [] = 0, my_length (x:xs) = 1 + my_length xs <-- what does (x:xs) represent here?
04:32:06 <dons> ah right. that's a list cons node :-)
04:32:11 <dons> :t (:)
04:32:12 <ski_> > 2 : [3,1]
04:32:15 <lambdabot>  [2,3,1]
04:32:15 <stmartin> Which begs the question; is there a good Haskell tutorial out there that you might recommend? Something I can work through in the weekend?
04:32:15 <lambdabot> forall a. a -> [a] -> [a]
04:32:26 <dons> yaht and the haskell wikibook are both good
04:32:28 <dons> ?where yaht
04:32:29 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
04:32:33 <dons> and the wikibook is found on haskell.org
04:32:39 <ski_> > let x = 2; xs = [3,1] in x:xs
04:32:41 <lambdabot>  [2,3,1]
04:32:41 <dons> and install ghci/ghc
04:33:06 <stmartin> ghci/ghc 6.6 is compiling as I type.
04:33:14 <ski_> > let x = 2; xs = [3,1]; f (y:ys) = (ys,y) in f (x:xs)
04:33:15 <lambdabot>  ([3,1],2)
04:33:23 <ski_> > let f (y:ys) = (ys,y) in f [0,1,2]
04:33:25 <lambdabot>  ([1,2],0)
04:35:44 <stmartin> Ah, yes I'm currently working through yaht
04:35:55 <ehird> yeah, i know list cons
04:36:03 <ehird> but i don't see how it works as a parameter
04:36:10 <dons> so that's a pattern match on the list constructor
04:36:10 <ehird> surely just "x" would work?
04:36:14 <ehird> oh, wait
04:36:15 <dons> ?src []
04:36:16 <lambdabot> data [] a = [] | a : [a]
04:36:17 <ehird> it ignores the first item,
04:36:22 <dons> (a : xs)
04:36:23 <ehird> then does itself on the rest
04:36:27 <ehird> losing an item each time
04:36:30 <dons> right
04:36:31 <stmartin> The exercises are good, but the Haskell errors are quite hard to work through without help.
04:36:31 <ehird> that's clever, very clever
04:36:39 <dons> it takes apart the structure
04:37:04 <dons> stmartin: the type errors. yes. its informing you about bugs in the code, after all. they get quite easy to read with practice, as you saw above
04:37:45 <stmartin> Perhaps a good tutorial would also walk you through the interpertation of such messages.
04:37:54 <dons> that's a good idea.
04:38:00 <dons> at least a catalog of common messages
04:38:01 <ehird> good thing i'm used to obscure error messages
04:38:03 <dons> and their likely causes
04:38:12 <ehird> generally, error messages are entirely unrelated to their causes
04:38:14 <ehird> in any language
04:38:21 <ehird> i.e., cascading errors
04:39:20 <dons> i think the haskell story (for common type errors) is a bit better than that. they're usually pretty accuately placed
04:39:25 <dons> at least that's my experience
04:39:39 <dons> of course, its possible to do quite advanced type tricks that lead to very difficult messages
04:39:39 <ehird> i'd imagine functional languages are better, yes
04:39:42 <dons> ?ghc
04:39:43 <lambdabot> ghc says: ld64: WARNING 47 : This module contains branch instruction(s) that might degrade performance on an R4000 processor.
04:39:48 <dons> well, that's not a type error.
04:39:50 <dons> ?ghc
04:39:51 <lambdabot> ghc says: Exception: kevind stub
04:39:56 <dons> heh. that's a good one
04:40:08 <dons> ?quote type error
04:40:09 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
04:40:18 <ehird> but i haven't actually run into many errors yet, heh
04:40:21 <ehird> code seems to... work
04:40:24 <dons> good1
04:40:35 <dons> the idea is to pay up front with type errors, and avoid broken code later
04:40:41 <quicksilver> dons: haskell locates type errors reasonably well if you explicitly type all your functions
04:40:49 <ehird> rewriting map was easy :/
04:40:52 <dons> quite so. yes, that's good practice
04:40:54 <ehird> certainly shorter than other languages
04:41:01 <dons> ?src map
04:41:02 <lambdabot> map _ []     = []
04:41:02 <lambdabot> map f (x:xs) = f x : map f xs
04:41:06 <quicksilver> dons: in the presence of polymorphism, without explicit typing, the error message can slide quite a long way :)
04:41:23 <dons> yeah. and don't even think about adding implicit parameters
04:41:29 <hpaste>  ehird pasted "the most inefficient implementation of map that can exist, i'd bet" at http://hpaste.org/602
04:41:55 <dons> ehird: see above for the library implementation
04:42:03 <ehird> hah!
04:42:06 <dons> you've reimplemented the most efficient version :-)
04:42:19 <ehird> i officially write the haskell standard library
04:42:20 <ehird> without knowing it
04:42:21 <sieni> one could easily do worse
04:42:28 <ehird> well, apart from _ in place of f
04:42:44 <dons> and some extra parens
04:42:46 <Cale> ehird: everyone does this with almost half of the standard library functions as they learn :)
04:43:01 <ehird> is the whole library written in haskell?
04:43:08 <dons> i wonder how many people exactly reimplement, say, strlen() in C by accident
04:43:09 <Cale> yeah, pretty much
04:43:17 <ehird> pretty fast, then
04:43:20 <Cale> There's some lower level primitives of course
04:43:28 <Cale> But they're mostly to do with IO
04:43:35 <Thunder> ehird: Of course. The compiler was wirtten in Haskell from the very first version, too.
04:43:44 <dons> ehird: right. its hard to imagine how you could be faster, right? you're doing the minimal work required to do a map
04:43:44 <Cale> Thunder: haha
04:43:49 <ehird> Thunder: i hate ghc for that
04:43:50 <ehird> honestly
04:43:58 <ehird> it takes longer than X11 to compile
04:44:01 <dons> you should be glad it wasn't written in c
04:44:04 <Cale> There was obviously a version written in another language :)
04:44:11 <ehird> Cale: well yes ;)
04:44:13 <TomMD> There is still plenty of C in ghc
04:44:23 <ehird> unless you made something bootstrappable...by itself
04:44:26 <dons> there's the runtime, of course.
04:44:44 <Thunder> Cale: No, there was a translation of some parts to LML which compiles the real one.
04:44:50 <Cale> ehird: You don't compile GHC unless you're intent on modifying it.
04:44:52 <Thunder> The translation was done by hand.
04:44:52 <JaffaCake> ehird: ghc was bootstrapped using hbc
04:45:25 <ehird> Cale: if you use fink's source distribution, yep, you compile it. using a precompiled bootstrap.
04:45:28 <JaffaCake> hbc is/was written in LML
04:45:31 <TomMD> Thompson didn't work on HBC, did he? :-)
04:45:40 <dons> JaffaCake: and we learnt today that lennart's not got the hbc src. so ghc is free floating :-)
04:45:54 <JaffaCake> wow
04:46:00 <JaffaCake> what did he do with it?
04:46:03 <dons> so we need to be sure that all copies of ghc in the world are not simultaneously deleted
04:46:04 <ehird> is there a another way of saying "fib 1 = 1, fib 2 = 1" without redundancy?
04:46:05 <Cale> ehird: Yeah, that's a bad idea :) There are binaries for almost every platform you'd want.
04:46:22 <ehird> dons: you can compile a minimal ghc with a c compiler according to its website
04:46:24 <dons> JaffaCake: well, i've got a copy, and so does shapr. :-) and the chalmers website
04:46:26 <ehird> presumably, its full enough to compile ghc itself
04:46:40 <dons> JaffaCake: but lennart's not gone one. i guess he just didn't bring it across to his current machines
04:46:51 <Cale> fib x | x `elem` [1,2] = 1
04:46:52 <JaffaCake> right
04:47:02 <sieni> > let {m _ [] = []; m f x = m f (reverse $ tail $ reverse x) ++ [f (head $ reverse x)]} in m (+1) [1..10]
04:47:03 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
04:47:04 <Cale> fib x | (x <= 2) = 1
04:47:10 <sieni> that's pretty inefficient
04:47:44 <Cale> hehe
04:48:00 <Cale> Not only is it inefficient, but it's broken with respect to strictness.
04:48:12 <sieni> > let {m _ [] = []; m f x = m f (init x) ++ [f (last x)]} in m (+1) [1..10]
04:48:13 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
04:49:23 <sieni> Cale: yeah, it's very inefficient on infinite lists
04:49:37 <dons> hehe
04:50:33 <quicksilver> your second one could work on infinite lists with appropriate compiler rules
04:50:33 <Cale> > let {m f xs = [f (xs !! n) | n <- [0..length xs - 1]]} in m (+1) [1..10]
04:50:35 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
04:50:55 <quicksilver> you'd just need the compiler to understand the rule (x : xs) ++ y === (x : xs ++ y)
04:51:03 <ski_> apropos bootstrapping, the Melbourne Mercury Compiler (sole implementation) was written in Mercury
04:51:22 <quicksilver> then you'd be able to pattern match past the ++
04:51:27 <quicksilver> ski_: and, clearly, gcc is written in C :)
04:51:46 <quicksilver> well in fact, gcc is written in gcc, not C
04:51:53 <Thunder> quicksilver: At least the C compiler of the collection, Yes.
04:51:56 <quicksilver> but gcc contains a subset written only in C
04:52:04 <quicksilver> which is sufficient to compile the rest
04:52:16 <ski_> (.. it was written in the intersection of Mercury, NU-Prolog, and some other i forgot)
04:52:45 <ehird> hmmmmmm,
04:52:52 <Cale> My version takes O(length xs^2) time.
04:52:53 <ehird> in a | thingy
04:52:54 <ehird> i.e.
04:53:00 <ehird> blah a | a < 0
04:53:03 <Cale> a guard
04:53:05 <ehird> is there a way to specify multiple conditionals?
04:53:06 <quicksilver> a 'guard'
04:53:10 <ehird> a guard, alright
04:53:11 <Cale> using &&
04:53:22 <quicksilver> the part after the | is any boolean expression
04:53:27 <quicksilver> all boolean things are permitted
04:53:32 <quicksilver> including &&, for example
04:53:35 <ehird> well, i wasn't sure it would use && as haskell decides to not use != and instead /= or whatever it is, so :P
04:53:52 <Cale> hmm, can we come up with a plausible factorial time map...
04:54:54 <quicksilver> ehird: you can always try things in ghci/hugs :)
04:54:57 <Cale> ehird: yeah, remember that /= is xor :)
04:55:07 <quicksilver> > 3 > 4 && 4 < 5
04:55:08 <lambdabot>  False
04:55:39 <ehird> mult a b | a < 0 || b < 0 = False <-- Error
04:55:56 <hpaste>  Marc Weber pasted "Illegal polymorphic or qualified type" at http://hpaste.org/603
04:55:57 <ehird> maybe i should stop denying minus numbers and jsut let them fail for simplicity
04:56:45 <MarcWebe1> Can I fix this somehow?
04:56:50 <ski_> (ehird : sorry, no disjunctive patterns in haskell ..)
04:56:57 <ehird> ski_: =P
04:57:50 <ski_> (that was re "fib 1 = 1, fib 2 = 1")
04:57:53 <ehird> hmm, what's the lambdabot command to get source from the standard library?
04:58:02 <ehird> ski_: it's clearer that way anyway
04:58:09 <ehird> @source (*)
04:58:10 <lambdabot> (*) not available
04:58:15 <ehird> @source *
04:58:15 <lambdabot> * not available
04:58:17 <ehird> :
04:58:19 <ehird> *:/
04:58:23 <ehird> (heh)
04:58:45 <ski_> @src take
04:58:45 <lambdabot> take n _      | n <= 0 =  []
04:58:46 <lambdabot> take _ []              =  []
04:58:46 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
04:58:56 <ski_> @source Prelude
04:58:57 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
04:59:03 <Cale> @src (*)
04:59:04 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:59:11 <Cale> @src (*) Integer
04:59:12 <lambdabot> Source not found. I feel much better now.
05:00:52 <ski_> (ehird : well, i'd like it in some larger examples)
05:01:01 <ehird> @src *
05:01:02 <lambdabot> Source not found. My mind is going. I can feel it.
05:01:23 <ski_> @src Maybe (>>=)
05:01:24 <lambdabot> (Just x) >>= k      = k x
05:01:24 <lambdabot> Nothing  >>= _      = Nothing
05:01:38 <ski_> @src Int (*)
05:01:39 <lambdabot> Source not found. You type like i drive.
05:01:41 <ski_> bah
05:02:36 <dons> code you don't see everyday,
05:02:37 <dons> #if __HASKELL1__ >= 5
05:02:37 <dons> #define fail ioError
05:02:37 <dons> #endif
05:03:35 <chessguy> what's the correct syntax for multiple record updates? s { foo=bar; baz=bah} --?
05:03:35 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
05:03:41 <ehird> @paste
05:03:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:04:09 <hpaste>  ehird pasted "i somehow suspect that the (*) func is slightly more efficient" at http://hpaste.org/604
05:04:33 <kolmodin> ?tell waern minihackathon i helgen?
05:04:33 <lambdabot> Consider it noted.
05:04:36 <ehird> hmm, i should probably do "mult a 1 = a"
05:04:45 * ehird does that
05:05:26 <hpaste>  ehird annotated "i somehow suspect that the (*) func is slightly more efficient" with "not that it speeds it up or anything..." at http://hpaste.org/604#a1
05:08:39 <ski_> chessguy : s {foo = bar,baz = bah}
05:09:26 <ehird> http://darcs.haskell.org/packages/base/Prelude.hs doesn't seem to have source to *
05:09:39 <chessguy> ah, got it. thanks
05:10:06 <ski_> (chessguy : nested record update is painful, though)
05:10:33 <chessguy> nested?
05:11:41 <hpaste>  chessguy pasted "one-pass solution to my random subtree problem?" at http://hpaste.org/605
05:11:58 <chessguy> Cale, it's untested but ^^
05:12:03 <chessguy> i'll be back in a little bit
05:12:11 <ski_>     (*)   = timesInt
05:13:21 <ehird> @src timesInt
05:13:21 <lambdabot> Source not found. My mind is going. I can feel it.
05:13:34 <ski_> (I# x) `timesInt` (I# y) = I# (x *# y)
05:13:50 <dons> a lot of the low level stuff isn't in @src, but you can find the actual src for the libraries here:
05:13:57 <dons> ?source Prelude
05:13:58 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
05:14:02 <dons> http://darcs.haskell.org/packages/base/
05:14:04 <lambdabot> Title: Index of /packages/base
05:15:47 <ehird> @src randmRIO
05:15:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:15:49 <ehird> @src randomRIO
05:15:49 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:16:02 <ehird> you're a very kind bot
05:16:06 <ehird> @src Random.randomRIO
05:16:06 <lambdabot> Source not found. Do you think like you type?
05:16:08 <ski_> @arr
05:16:09 <lambdabot> Aye
05:16:55 <ski_> @vixen you're a very kind bot
05:16:55 <lambdabot> <undefined>
05:17:06 <ski_> eh ?
05:17:06 <ehird> (1::Int, 100) <-- why is Int required here?
05:17:33 <ski_> it probably isn't required exactly there
05:17:34 <velco> so the type is (Int, Int)
05:18:10 <velco> Num a => (Int, a) actually
05:18:22 <ski_> @type randomRIO
05:18:25 <lambdabot> forall a. (Random a) => (a, a) -> IO a
05:18:48 <ski_> @type do {(x,y) <- randomRIO; return [x,y]}
05:18:50 <ehird> let guessNum = read guess <-- what does this do?
05:18:51 <lambdabot>     Couldn't match expected type `IO a' against inferred type `(a1, b)'
05:18:51 <lambdabot>     In the pattern: (x, y)
05:18:58 <ehird> i cant find what read would do
05:19:01 <ski_> er
05:19:02 <ehird> where guess is guess <- getLine
05:19:15 <ski_> @type do {x <- randomRIO (1,5); return x}
05:19:18 <lambdabot> forall t. (Num t, Random t) => IO t
05:19:23 <ski_> @type do {x <- randomRIO (1 :: Int,5); return x}
05:19:26 <lambdabot> IO Int
05:19:29 <dons> > read "1" :: Int
05:19:31 <lambdabot>  1
05:19:34 <ski_> @type do {x <- randomRIO (1,5); return (x :: Int)}
05:19:37 <lambdabot> IO Int
05:19:49 <ski_> @type do {x <- randomRIO (1,5); return (x + length [])}
05:19:51 <dons> ehird: its reads a string representing a haskell value into a haskell value
05:19:52 <lambdabot> IO Int
05:19:56 <dons> > read "()" :: ()
05:19:58 <lambdabot>  ()
05:20:05 <dons> > read "'x'" :: Char
05:20:07 <lambdabot>  'x'
05:20:24 <ski_> if we want it to generate an 'Int', then *something* should force it to be an 'Int'
05:20:52 <ehird> dons: aha
05:21:10 <ski_> often this is the context, e.g. passing it to a function which expects an 'Int' .. but otherwise a type ascription such as above can also do the job
05:21:32 <dons> ehird: its counterpart is the 'show' function
05:21:36 <dons> > show 1.2
05:21:38 <lambdabot>  "1.2"
05:21:40 <dons> > show ()
05:21:41 <lambdabot>  "()"
05:21:41 <ehird> yeah i know about show
05:21:47 <quicksilver> ehird: note that, e.g. "5" is not a number, it's the string rep of the number
05:21:53 <ehird> yeah i get it now
05:21:53 <quicksilver> (read "5") :: Int
05:21:57 <dons> so we have a nice property, which we can express with quickcheck
05:22:04 <ehird> > show "i'm fairly sure show could be used for a quine fairly easily"
05:22:05 <dons> prop_read_show n = n == read (show n )
05:22:05 <lambdabot>  "\"i'm fairly sure show could be used for a quine fairly easily\""
05:22:18 <ehird> > show "show \"show\"'
05:22:18 <lambdabot>  Improperly terminated string
05:22:20 <ehird> > show "show \"show\""
05:22:21 <lambdabot>  "\"show \\\"show\\\"\""
05:22:22 <dons> ?check \n -> let _ = n :: Int  in     n == read (show n)
05:22:24 <lambdabot>  OK, passed 500 tests.
05:22:25 <ehird> not quite :/
05:22:30 <dons> ehird: quickcheck ^^ :-)
05:22:37 <ehird> wow, that was fast
05:22:39 <ehird> :P
05:22:44 <dons> (haskell test library (and test generator))
05:22:48 <ski_> > let x = show x in x
05:22:49 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
05:22:59 <dons> sort of subsumes unit tests, in that the library generates the unit tests based on the type
05:23:19 <dons> > fix show
05:23:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
05:23:32 <dons> laziness is a virtue
05:23:32 <ehird> Guess.hs:19:20: parse error (possibly incorrect indentation) <-- Oh crap
05:23:42 <ehird> did i get the indentation wrong :<
05:23:46 <dons> sounds like it
05:23:50 <dons> usually pretty easy to fix.
05:24:00 <ehird> i take it 'else's aren't meant to be on the same column as 'ifs'?
05:24:02 <dons> just indent subexpressions further to the left. statements in do-blocks line up
05:24:08 <dons> if x
05:24:10 <dons>    then ...
05:24:11 <quicksilver> dons: erm no :) quickcheck does not replace unit tests
05:24:14 <dons>   else ...
05:24:20 <dons> sorry, one more space on the 'else' :-)
05:24:22 * ehird lines up the else with the then, then (heh)
05:24:33 <dons> quicksilver: "sort of subsumes"
05:24:33 <quicksilver> dons: quickcheck is clever and helpful but if your failing values are 'rare' then you have a non-deterministic test
05:24:38 * ehird (then aligns the next then do with the condition... yada, yada)
05:24:38 <ski_> 'fix error' is also fun
05:24:45 <dons> quicksilver: but that's just a zero-arity quickcheck
05:24:51 <dons> prop_bug = f "foo"
05:24:55 <ehird> doesn't complain now, yay
05:24:57 <quicksilver> true
05:25:27 <dons> which is how i proceed to write code. quickcheck properties where possible, zero-arity quickcheck properties, i.e. specific cases, where needed
05:25:59 <ehird> is there a strict checker for layout?
05:26:01 <dons> ?pretty if True then 1 else 2
05:26:01 <lambdabot> "Parse error" at column 1
05:26:11 <dons> ?pretty f = if True then 1 else 2
05:26:11 <lambdabot>  f = if True then 1 else 2
05:26:12 <ehird> so i don't have to remember the rules all the time =P
05:26:35 <dons> ehird: the rules are pretty simple. otherwise you can just use  { ;;; } notation till you learn them by osmosis
05:26:41 <quicksilver> dons: yes, and that's very sensible
05:26:53 <quicksilver> dons: an old-fashioned part of me worries that quickcheck encourages laziness though
05:26:56 <ehird> > 1..100
05:26:56 <lambdabot>  Parse error
05:26:59 <ehird> > [1..100]
05:27:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:27:11 <ehird> now that i've written Guess.hs, i do believe I can write Cheat.hs
05:27:13 <quicksilver> dons: assuming that quickcheck will find the problem rather than trying to think of and test the edge cases independently
05:27:26 <dons> quicksilver: i think it encourages a more general approach. since once you string together a few specific cases, its easy to turn that into a general property. and general properties help make apis nicer
05:27:31 <dons> yes. that's important.
05:27:34 <dons> don't rely on the test generators to be correct
05:27:49 <dons> you certainly have to ensure your Arbitrary instances produce good cases
05:28:01 <quicksilver> dons: mind you, if it encourages some kind of testing that is surely better than no testing
05:28:12 <quicksilver> dons: and in my experience 'no testing' is rather common :)
05:28:19 <dons> and i'm yet to meet the person who has worse code using QuickCheck :-)
05:29:05 <ehird> hm, it's complaining about a "let blah = ..." after a if, then do
05:29:17 <ehird> maybe it's because i put a return () in there? but it's behind a conditional...
05:29:26 <ehird> (yes, i'm randomly guessing trying to get this cheat to work :P)
05:29:32 <dons> quite possibly, ehird .
05:29:41 <ehird> wrong, it complains anywhere :/
05:29:45 <ehird> *anyway
05:29:46 <MarcWebe1> ehird: If you paste the code somewhere we can help (eg hpaste.org)
05:29:48 <ehird> even without the return
05:29:50 <ehird> yeah, i will
05:29:50 <ehird> @paste
05:29:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:29:52 <dons> ?paste is the only way to proceed
05:29:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:30:19 <MarcWebe1> lol @ dons
05:30:31 <JaffaCake> dons: I'm taking a look at spectral/calendar... what inputs are you running it with?
05:30:45 <hpaste>  ehird pasted "tried with "do" as well, nope" at http://hpaste.org/606
05:30:58 <dons> TEST_ARGS  = 1993 2000
05:31:04 <JaffaCake> ta
05:31:25 <dons> JaffaCake: actually, i've upped that, TEST_ARGS  = 1993 10000
05:31:32 <dons> the current page uses the larger value
05:31:37 <quicksilver> ehird: that return looks wrong
05:31:37 <dons> http://www.cse.unsw.edu.au/~dons/nobench/results.html
05:31:38 <lambdabot> Title: nobench: Haskell implementation shootout
05:31:47 <JaffaCake> thanks
05:31:48 <ehird> quicksilver: it probably does.
05:31:51 <quicksilver> ehird: and if statements always need an else
05:31:53 <ehird> considering it won't compile and all ;)
05:31:56 <ehird> aha, that'll be while
05:31:59 <ehird> *why
05:32:10 <ehird> is there an "else then continue executing"?
05:32:10 <quicksilver> well, it's a functional language
05:32:23 <quicksilver> > if 3>4 then 1 else 2
05:32:24 <lambdabot>  2
05:32:31 <ehird> yes, but this is in a "do" block
05:32:36 <quicksilver> if I'd missed of the 'else' part what would you expect that to do?
05:32:44 <ehird> good point
05:33:00 <quicksilver> maybe you mean "else return ()"
05:33:07 <quicksilver> that is one case where return () can be useful
05:33:31 <quicksilver> ehird: haskell remains a functional language even inside a do block :)
05:33:42 <dons> ehird: its a good idea in future to paste the entire top level function definition
05:33:47 <quicksilver> the do block is only some strange sugar for the >>= operator, after all....
05:33:50 <dons> so we can get a sense of the types for the values
05:34:07 <ehird> guess is just "guess <- getLine", and that's all that comes before
05:34:25 <dons> what's the type of 'doGuessing' ?
05:34:36 <quicksilver> dons: you have to guess that type, that's why it's called that :)
05:34:41 <dons> (in general, posting more code is better than posting less :-)
05:34:44 <ehird> this tutorial hasn't got on to defining types for stuff yet...
05:34:46 <ehird> (yaht)
05:34:59 <ehird> so it's just "doGuessing num = do..."
05:35:07 <dons> ok, so its monadic
05:35:17 <ehird> oh THAT's why it doesn't work
05:35:23 <ehird> excuse me, i'm stupid :)
05:35:24 <quicksilver> you probably want mapM and not map, as well
05:35:25 <quicksilver> :t map
05:35:26 <quicksilver> :t mapM
05:35:27 <dons> and you want to apply it to a bunch of different numbers.
05:35:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:35:29 <lambdabot>     Ambiguous occurrence `mapM'
05:35:29 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
05:35:37 <ehird> no, the thing is doGuessing takes the TARGET number
05:35:40 * quicksilver glares at lambdabot 
05:35:41 <ehird> the input is got from IO :/
05:35:50 <ehird> i'm stupid, then
05:35:55 <quicksilver> dons: can you make it import Control.Monad.Writer hiding mapM? that's annoying
05:36:16 <ehird> guess <- getLine, let guessNum = read guess <-- Hmm
05:36:20 <dons> yes. i need to do that.
05:36:20 <hpaste>  dons annotated "tried with "do" as well, nope" with "one attempt" at http://hpaste.org/606#a1
05:36:26 <ehird> would let guessNum read (<- getLine) or something work?
05:36:42 <quicksilver> ehird: no
05:36:43 <dons> ehird: nope. can you paste the larger fragment of code please?
05:36:46 <dons> more context is required
05:36:52 <quicksilver> :t getLine
05:36:55 <lambdabot> IO String
05:37:00 <quicksilver> getLine returns an IO value
05:37:08 <quicksilver> the effect of the '<-' notation is to 'unwrap' that
05:37:14 <ehird> dons: no, it'd actualyl have to feed IO input to the function to make it work i just raelised, so i've given up on that, heh
05:37:15 <quicksilver> so after guess <- getLine
05:37:20 <ehird> ah, i see
05:37:22 <quicksilver> we have 'guess' as a 'String'
05:37:26 <quicksilver> rather than an IO string
05:38:10 <quicksilver> in the particular case of IO, <- means something rather like 'actually perform some IO, and then give me the result'
05:39:14 <ehird> aha
05:42:33 <chessguy> 'morning haskellers
05:43:59 <ehird> mapM (putStr (show .) ++ " ") words <-- it doesn't like this :P
05:44:11 <ehird> oh, wait
05:44:12 <ehird> i need the ()
05:44:31 <ehird> nope, (putStr ((show .) ++ " ")) doesn't work either
05:44:45 <ehird> aha
05:44:49 <ehird> show isn't needed
05:45:08 <quicksilver> true
05:45:08 <ehird> though (putStr (. ++ " ")) is a parse error on ++
05:45:17 <ski_> mapM (putStr . show . (++ " ")) words
05:45:18 <ski_> ?
05:45:20 <quicksilver> yes, you can't just put a . there
05:45:22 <dons> could you possibly be trying to much in one go? :-)
05:45:27 <ski_> mapM (putStr . (++ " ")) words
05:45:27 <ski_> ?
05:45:32 <quicksilver> he means this:
05:45:37 <dons> mapM (print . (++ " ")) words
05:45:50 <quicksilver> mapM (\x -> putStr ((show x) ++ " ") )
05:46:07 <dons> ?pl mapM (\x -> putStr ((show x) ++ " ") ) -- for the amusing
05:46:08 <lambdabot> mapM (putStr . (++ " ") . show)
05:46:18 <quicksilver> right
05:46:27 <quicksilver> but I don't think that's the right thing to teach ehird just at this stage :)
05:46:39 <quicksilver> ehird: generally if you have a 'function with a hole'
05:46:43 * ehird 's head is dying round about now
05:46:44 <dons> ehird: less there is don't try to write in pointfree by yourself. just use @pl, and then don't do it.
05:47:04 <quicksilver> ehird: like putStr ((show <stuff goes here>) ++ " ")
05:47:19 <quicksilver> ehird: you're trying to put each value of words in turn where I wrote <stuff goes here>, right?
05:47:27 <ehird> where words is
05:47:33 <ehird> ["blah", "de", "blah"]
05:47:33 <quicksilver> where words was some list
05:47:37 <quicksilver> which you were mapM'ing over
05:47:39 <quicksilver> right
05:47:40 <ehird> i'm aiming for "blah de blah" being displayed
05:47:48 <dons> oh!
05:47:50 <quicksilver> the way you put <stuff in a hole> like that
05:47:53 <dons> > intersperse " " ["blah", "de", "blah"]
05:47:54 <lambdabot>  ["blah"," ","de"," ","blah"]
05:47:56 <quicksilver> is by 'naming the hole'
05:48:01 <dons> >  concat (intersperse " " ["blah", "de", "blah"])
05:48:02 <lambdabot>  "blah de blah"
05:48:04 <ehird> dons: aha
05:48:06 <MarcWebe1> ehird: print . unwords . ["blah", "oh"]
05:48:08 <quicksilver> grrr
05:48:16 <dons> > putStr . concat . intersperse " " $ ["blah", "de", "blah"]
05:48:17 <quicksilver> dons, MarcWebe1 both your solutions are good
05:48:18 <lambdabot>  <IO ()>
05:48:37 <ehird> intersperse isn't in scope :/
05:48:38 <quicksilver> but there is value in trying to explain to ehird how to do the way he was trying
05:48:41 <dons> i always forget unwords
05:48:44 <quicksilver> before showing him other ways
05:48:46 <dons> import Data.List
05:48:47 <ski_> @index intersperse
05:48:47 <lambdabot> Data.List
05:49:11 <MarcWebe1> dons: It didn't exist when you learned haskell, eh?
05:49:19 <quicksilver> ehird: the way you do what you were trying is by 'naming the hole' and then doing a lambda absrtraction
05:49:21 <dons> sure it did. i just always forget about it
05:49:28 <ehird> i had to import Data.List
05:49:31 <quicksilver> ehird: so (1*(<hole> + 3))
05:49:31 <ehird> and then use Data.List.interperse
05:49:37 <ehird> quicksilver: indeed
05:49:40 <quicksilver> ehird: becomes \x -> (1*(x+3))
05:49:41 <ehird> gets a bit complicated, there, though
05:49:50 <ehird> \x -> (x) makes sense though
05:49:54 <ehird> thanks :)
05:50:06 <quicksilver> your example was mapM (\x -> putStr ((show x) ++ " ")) words
05:50:14 <quicksilver> that should work
05:50:17 <dons> when an anonymous function like that becomes a bit too unwieldy, its a good idea to drop it into a where clause
05:50:27 <dons> i often call these printing functions "draw"
05:50:42 <dons> so we'd have:   mapM draw words where draw x = putStr ((show x) ++ " ")
05:50:54 <dons> so we'd have:   mapM draw words where draw x = putStr (show x ++ " ")
05:51:18 <ehird> oo, that's clever
05:51:27 <ehird> @paste
05:51:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:51:34 <dons> its good to name parts of the code that become tricky :-)
05:51:42 <pjd> naming is everything
05:51:57 <kombinator> dcoutts_: hello
05:52:02 <hpaste>  ehird pasted "for some reason, the word> only gets displayed at the end, when i enter an empty word, and they all " at http://hpaste.org/607
05:52:05 <dcoutts_> kombinator, hia
05:52:28 <chessguy> dcoutts_, 'morning
05:52:43 <kombinator> dcoutts_: long time ago I told you that I'm going to write my master's project on GUIs
05:52:45 <dcoutts_> chessguy, you got my note
05:52:52 <dcoutts_> kombinator, oh right
05:52:59 <kombinator> dcoutts: I'm starting it right now
05:53:08 <chessguy> i think my gtk2hs problems are better. i realized last night i needed to actually compile the files
05:53:10 <quicksilver> ehird: typically output is line-buffered
05:53:20 <quicksilver> ehird: your word> probably isn't getting printed because it's not a whole line yet
05:53:23 <ehird> quicksilver: oh, yes, i remember that
05:53:31 * ehird finds the command needed for earlier in the tutorial
05:53:34 * quicksilver nods
05:53:36 <quicksilver> hSetBuffering
05:53:37 <ehird> magick incantation (TM)
05:54:12 <chessguy> kombinator, what about GUIs?
05:54:19 <dcoutts_> kombinator, cool
05:54:22 <hpaste>  ehird annotated "for some reason, the word> only gets displayed at the end, when i enter an empty word, and they all " with "still happens... very odd" at http://hpaste.org/607#a1
05:54:38 <kombinator> dcoutts_: I will try to start with what Conal Eliott has done (Phooey)
05:54:46 <dcoutts_> kombinator, you'll keep us posted on your progress I'm sure. What's the general idea then?
05:54:53 <quicksilver> ehird: stdout
05:54:54 <ehird> oh, wait,
05:54:57 <quicksilver> ehird: stdin is input :)
05:54:58 <ehird> yep
05:55:01 <ehird> figured that out now ;)
05:55:01 <kombinator> dcoutts_: that is GUIs based on arrows
05:55:05 <ehird> i'll have to do both
05:55:34 <quicksilver> ehird: incidentally, 'concat  . (Data.List.intersperse " ")' has a name in the Prelude
05:55:38 <quicksilver> ehird: it's called 'unwords'
05:55:39 <dcoutts_> kombinator, is Conal's stuff using arrows? I've not been paying enough attention.
05:55:46 <hpaste>  ehird annotated "for some reason, the word> only gets displayed at the end, when i enter an empty word, and they all " with "would you believe it still happens? i would" at http://hpaste.org/607#a2
05:55:55 <ehird> @source unwords
05:55:56 <lambdabot> unwords not available
05:55:58 <ehird> @src unwords
05:55:58 <lambdabot> unwords [] = ""
05:55:59 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
05:56:07 <ehird> well, not quite ;) but yay, good enough
05:56:07 <quicksilver> ehird: you're turning *on* line buffering
05:56:07 <kombinator> dcoutts_: now, right in the beginning I would like to make a text entry that is editable both by the user and the program
05:56:12 <quicksilver> ehird: you want to turn it off
05:56:14 <ehird> quicksilver: crap
05:56:17 <ehird> shoot me please
05:56:17 <kombinator> dcoutts_: yes, it uses arrows
05:56:23 <quicksilver> ehird: NoBuffering
05:56:34 <ehird> (unwords words) <- hehe
05:56:38 <hpaste>  dons annotated "for some reason, the word> only gets displayed at the end, when i enter an empty word, and they all " with "small refactor" at http://hpaste.org/607#a3
05:56:58 <dons> but the problem is your accumulating all input before you begin processing
05:57:16 <kombinator> dcoutts_: I might extend Phooey, which uses WX, but I might as well cook a small example using gtk2hs
05:57:21 <ehird> i just had to change stdout's buffering to NoBuffering
05:57:21 <dons> ah sorry. you had a prompt/line buffering problem
05:57:23 <ehird> it works nice now
05:57:27 * JaffaCake has a theory about spectral/calendar
05:57:42 * ehird reads the code, though, for info
05:57:44 <dons> JaffaCake: ah yes?
05:57:51 <dons> hbc and nhc are being too clever?
05:57:57 <dcoutts_> kombinator, aye, the high level arrows stuff ought to be able to map onto any of the lower level toolkits
05:58:00 <JaffaCake> no, GHC is being too clever :)
05:58:07 <ehird> hm, i thought do was meant to be lined up?
05:58:08 <dons> that's usually the problem
05:58:34 <JaffaCake> we have a mis-optimisation for the IO monad, where we can possibly end up recomputing things sometimes
05:58:45 <dons> mm!
05:58:45 <malcolmw> JaffaCake: so, why is ghc 60x slower than a bytecode interpreter? :-)
05:58:56 <dcoutts_> kombinator, as you know, we have infrastructure for generating code from descriptions of the GUI api, so the same could extend to generating a very high level api, so you don't have to do it all by hand (since there are a lot of widgets)
05:58:57 <JaffaCake> because GHCi isn't doing this mis-optimisation
05:59:00 <kombinator> dcoutts_: now I found a small problem. In order to make a text entry like that, I must have control from the outside over what appears in it
05:59:16 <JaffaCake> basically the optimiser allows itself to  eta-expand IO operations
05:59:22 <kombinator> dcoutts_: no, I don't know
05:59:23 <dons> malcolmw: i wonder why yhc is 2000x slower there.
05:59:26 <dons> they broke something
05:59:26 <ehird> putStr ((unwords words) ++ "\n") words where words <- askForWords <-- I wasn't expecting for that to work :P
05:59:27 <dcoutts_> kombinator, meaning that you want to be able to intercept user's input.
05:59:27 <JaffaCake> which isn't always safe, but is often a significant win
05:59:57 <erider> good morning
06:00:01 <kombinator> dcoutts_: yes, and suppress automatic updating of the text entry
06:00:13 <kombinator> dcoutts_: I want to update it by hand
06:00:18 <JaffaCake> I bet hbc is spotting the CSE in calendar, too
06:00:52 <kombinator> dcoutts_: that is, if the user presses 'b' I will insert it into the entry myself
06:01:04 <malcolmw> dons: my guess is that yhc must have a different implementation of the IO monad, so it is doing the same work 10000 times, whilst nhc98 does it once
06:01:28 <kombinator> dcoutts_: but I don't have any idea if I could do this in gtk2hs (or WXhaskell)
06:01:42 <dcoutts_> kombinator, I think you can
06:01:50 <JaffaCake> malcolmw: that sounds like a bug, not a different implementation
06:01:58 <malcolmw> JaffaCake: can you tell when the optimisation will be a loser and when a winner?
06:02:17 <JaffaCake> it's a winner when the IO is only executed once
06:02:23 <quicksilver> always a winner, if it's an optimisation! In those other cases it's a pessimisation!
06:02:31 <kombinator> dcoutts_: and what is this infrastructure for generating GUIs? I have never heard of it
06:02:41 <JaffaCake> roughly speaking; it's probably a win more often than that in fact
06:02:57 <JaffaCake> in this case we lose a large amount of sharing, so it's a big loss
06:02:58 <dcoutts_> kombinator, we have an xml description of the Gtk API and we generate Haskell code from that.
06:03:11 <hpaste>  ehird annotated "for some reason, the word> only gets displayed at the end, when i enter an empty word, and they all " with "probably the smallest i can get while still being understandable" at http://hpaste.org/607#a4
06:03:11 <kombinator> dcoutts_: glade?
06:03:15 <dcoutts_> kombinator, it's the apiGen in the Gtk2Hs darcs repo, under tools/
06:03:15 <malcolmw> quicksilver: we all know that an optimisation is rarely optimal, so the name is pretty meaningless
06:03:16 <JaffaCake> it's always been a bit of a worry, in fact
06:03:21 <dcoutts_> kombinator, glade is different
06:03:39 <quicksilver> malcolmw: yes, my comment was not intended seriously. I am rather facetious sometimes.
06:03:47 <kombinator> dcoutts_: ok, I'll take a look
06:03:51 <ehird> @src fac
06:03:51 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:04:02 <ehird> hm, isn't there a factorial in prelude? =P
06:04:10 <dcoutts_> kombinator, so doing what you want is possible but a little tricky, and here's why... when you pragmatically insert text into the text Entry you still get a signal!
06:04:21 * JaffaCake creates a ticket
06:04:23 <dcoutts_> kombinator, so if you were not careful you'd get infinite recursion.
06:04:33 <quicksilver> Although some people might argue that you should resolve 'optimisation' for things which are unconditional imporvements, and refer to the others neutrally as 'transformations'
06:04:33 <dons> optimis-(tic)-isation , not optimal-isation :)
06:04:42 <kombinator> dcoutts_: yes, that's one of the problems...
06:04:50 <dcoutts_> kombinator, so the trick is to suppress the signal emission, then set the text yourself and then re-enable the signal emission.
06:05:16 <dcoutts_> kombinator, see in the Gtk+ C docs the example for GtkEditable.
06:05:16 <dons> JaffaCake: this is fun. i'll hunt for some more unusual programs/results over the weekend
06:05:31 <kombinator> dcoutts_: but can I also suppress the automatic updating of the entry?
06:05:43 <dcoutts_> kombinator, yes
06:06:09 <Cale> chessguy: One thing I don't really understand is why you want to use the state monad for this, but let's see...
06:06:10 <JaffaCake> dons: it's nice to see hbc results, we haven't raced hbc for quite a while
06:06:11 <ehird> which is faster, foldr or fldl?
06:06:22 <MarcWebe1> foldr
06:06:23 <quicksilver> ehird: that depends what you're doing, but foldr tends to be
06:06:40 <ehird> thanks, MarcWebe1
06:06:41 <dons> JaffaCake: john's just fixed jhc up a bit too, so it should pass a lot more tests tomorrow
06:06:48 <kombinator> dcoutts_: "Forcing entry to uppercase" - this?
06:06:49 <dons> there might be some competition
06:06:49 <chessguy> Cale, you wouldn't have to, but it makes easier to maintain the current node number, the random generator, etc
06:06:55 <dcoutts_> kombinator, yep.
06:07:07 <ehird> i can safely say that haskell is the only language that has suprised me when learning it that it's this good
06:07:08 <Cale> ehird: http://en.wikipedia.org/wiki/Foldr
06:07:22 <ehird> everything i write mostly seems to "just work"
06:07:47 <dons> ehird: that's the plan! :-)
06:07:49 <quicksilver> chessguy: are you aware of the technique of producing an infinite lazy list of non-monadic random numbers?
06:07:53 <Cale> chessguy: okay, so the initial state to this algorithm will have node initialised to 1?
06:08:01 <MarcWebe1> ehird: Thats why we all like haskell ;)
06:08:05 <dons> ehird: we really don't like bugs at runtime round these parts
06:08:06 <chessguy> Cale, correct.
06:08:09 <quicksilver> chessguy: sometimes that's lighterweight than carrying a generator around everywhere you go
06:08:29 <Cale> chessguy: so, r <- getRand 1 1 the first time around
06:08:37 <ehird> dons: runtime bugs are ugh
06:08:38 <chessguy> Cale, yes
06:08:41 <ehird> compile-time bugs are ok ;)
06:08:43 <chessguy> quicksilver, hmmm.
06:08:47 <ehird> @src factorial
06:08:48 <lambdabot> Source not found. stty: unknown mode: doofus
06:08:55 <ehird> okay, fine, i'll write my own
06:09:03 <dons> hehe
06:09:04 <chessguy> quicksilver, does it take a seed and give repeatable results?
06:09:07 <quicksilver> chessguy: yes
06:09:13 <chessguy> link?
06:09:15 <dons> > product [1..100]
06:09:17 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
06:09:35 <Cale> and so the first branch of the if is taken, the tree is set to t, and the node incremented, and then you mapM_ this over the subtrees.
06:09:45 <chessguy> actually, i don't see that it's much of a savings, quicksilver
06:09:55 <chessguy> quicksilver, you just carry the infinite list around instead :)
06:10:00 <JaffaCake> dons: geometric mean code is in nofib-analyse... pretty please ;-)
06:10:11 <Cale> The second tree will get switched to with probability 1/2, the third with probability 1/3, and so on
06:10:24 <chessguy> Cale, correct
06:11:02 <quicksilver> chessguy: right :)
06:11:03 <Cale> In order to choose the first tree then, none of these switches can happen, which has probability (1/2)*(2/3)*(3/4)*...*((n-1)/n)
06:11:28 <JaffaCake> dons: you'd have to designate one column as the baseline (e.g. ghc) and normalise everything with respect to that, but then we can get a ballpark figure for the relative speeds of each implementation
06:11:46 <Cale> Massive cancellation occurs, and that's 1/n, which looks good :)
06:12:10 <chessguy> heh
06:12:51 <dons_> ?bot
06:12:52 <lambdabot> :)
06:12:56 <dons_> hmm.
06:13:08 <ehird>     Couldn't match expected type `[a]' against inferred type `IO ()' <-- Hm.
06:13:21 <dons> JaffaCake: ah thanks for the hint.
06:13:34 <Cale> ehird: you're using an IO action where a list is needed, or a list where an IO action is needed.
06:13:45 <dons> JaffaCake: yep. ok. will do.
06:14:02 <ehird> Cale: numbers <- getNumbers, where putStrLn "The sum is " ++ (foldr (+) numbers)
06:14:14 <JaffaCake> dons: that'd be great :)
06:14:20 <chessguy> ehird, meet the type checker. your best friend and worst enemy
06:14:34 <ehird> chessguy: yep...
06:14:44 <ehird> the io distinction, i think, is taken a little too seriously ;)
06:14:51 <ehird> teeny little bit.
06:14:57 <Cale> ehird: You'll get used to it :)
06:15:08 <chessguy> ehird, you have much to learn, grasshopper
06:15:14 <ehird> tap tap let numbers = read input..
06:15:14 <chessguy> ?quote IO
06:15:15 <lambdabot> bakert says: i think it's a question of where you are looking from.  from the magician's point of view no one got sawn in half and from the audience's point of view someone did and they both like it
06:15:15 <lambdabot> that way around.
06:15:29 <ehird> welll
06:15:31 <Cale> ehird: It's actually a pretty good distinction to make, because it lets you write your own control structures with no fear of things going off too early.
06:15:32 <ehird> that doesn't work either.
06:15:39 <ehird> @paste
06:15:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:15:59 <hpaste>  ehird pasted "See annotation for my tried fix that still dies" at http://hpaste.org/608
06:15:59 <Cale> ehird: foldr (+) 0 numbers  ?
06:16:15 <dons> ehird: hey, the only reason we let people evaluate arbitrary haskell code in an irc channel is because we rule out the IO in the type :-)
06:16:16 <Cale> You forgot the base case for foldr
06:16:18 <hpaste>  ehird annotated "See annotation for my tried fix that still dies" with "fix that doesn't work" at http://hpaste.org/608#a1
06:16:24 <ehird> Cale: ... crap
06:16:27 <ehird> ok, shoot me
06:16:28 <dons> > readFile "/etc/passwd" -- not safe in your everyday language
06:16:29 <lambdabot>  <IO [Char]>
06:16:37 <chessguy> @quote shoot
06:16:37 <lambdabot> foot says: You shoot yourself in the foot very elegantly, and wonder why the whole world isn't shooting itself this way.
06:16:45 <ehird> foot says, heh
06:17:18 <chessguy> Cale, so you think it's right?
06:17:22 <Cale> ehird: another problem is that your putStrLn lines aren't being parsed the way you think they are
06:17:31 <ehird> Cale: oh, yes
06:17:33 <ehird> just realised that
06:17:45 <Cale> chessguy: let's try the second element, and if that works, we can probably convince ourselves there's a general argument :)
06:17:59 <ehird> haskell looks a hell of a lot like lisp now
06:18:09 <Cale> ehird: you can use $ to avoid parens there
06:18:19 <ehird> how? :/
06:18:24 <Cale> putStrLn $ "The sum is " ++ sum numbers
06:18:26 <Cale> er
06:18:30 <Cale> putStrLn $ "The sum is " ++ show (sum numbers)
06:18:36 <ehird> aha, there's a sum function
06:18:40 <ehird> why is everything too easy :(
06:18:41 <Cale> sum and product
06:18:43 <ehird> :P
06:18:45 <ehird> @src sum
06:18:46 <lambdabot> sum = foldl (+) 0
06:18:53 <ehird> wellllllll that's what i'm doing heh.
06:18:57 <ehird> @src product
06:18:57 <lambdabot> product = foldl (*) 1
06:19:02 <ehird> stop reading my mind
06:19:03 <Cale> Yeah, don't ask why it uses foldl
06:19:04 <earthy> !autolart
06:19:14 <ehird> Cale: for infinite lists
06:19:17 <Cale> It would actually be better off using foldl'
06:19:20 <ehird> am i right?
06:19:29 <Cale> foldr is the one which works with infinite lists
06:19:31 <earthy> I let my computer calculate for over an hour to generate a profile
06:19:40 <earthy> and then by mistake throw it away...
06:19:45 <ehird> oh.
06:19:56 * earthy hates himself
06:20:02 <ehird>     No instance for (Num Char)      arising from the literal `0' at Calculator.hs:16:29
06:20:06 <ehird> the hell..
06:20:41 <dylan_> @hoogle (a -> bool) -> [a] -> a
06:20:42 <lambdabot> Did you mean: (a -> Bool) -> [a] -> a
06:20:42 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
06:20:42 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
06:20:50 <dylan_> @hoogle (a -> Bool) -> [a] -> a
06:20:51 <lambdabot> No matches, try a more general search
06:20:59 <Cale> chessguy: So, let's see, regardless of whether the first tree is chosen, the probability that the second one is picked on its round is (1/2), and then all the further ones have to fail, so it's (1/2) * (2/3) * ... * ((n-1)/n) again.
06:21:03 <Cale> But hang on :)
06:21:07 <ehird> hoogle, heh
06:21:09 <Cale> Let's look at the third case :)
06:21:29 <ehird> so why is if number == 0 wrong
06:21:31 <dylan_> @pl \x l -> head (filter x l)
06:21:32 <lambdabot> (head .) . filter
06:21:38 <chessguy> ok
06:21:56 <Cale> The probability that the third element is chosen is (1/3) * (3/4) * (4/5) * ... * ((n-1)/n)
06:21:58 <chessguy> Cale, we could just look at the k'th case :)
06:22:04 <Cale> right
06:22:08 <hpaste>  dons annotated "See annotation for my tried fix that still dies" with "for ehird" at http://hpaste.org/608#a2
06:22:11 <Cale> it works exactly the same way
06:22:11 <dons> ehird: ^^
06:22:19 <Cale> you get nice telescoping cancellation every time
06:22:32 <chessguy> indeed
06:22:37 <ehird> why doesn't the factorial work with the .?
06:22:53 <dons> ehird: have a look at my refactor of your last paste
06:23:02 <ehird> yes
06:23:21 <Cale> (fac .) is a function which composes factorial with whatever function it's applied to
06:23:30 <dons> note that you were calling read both in the getNumbers loop, and again on the result, before.
06:23:32 <Cale> In particular, it's not a list.
06:23:38 <Cale> So you can't use ++ with it
06:23:52 <Cale> same goes with (show .)
06:23:55 <chessguy> Cale, do  you still think it could be written better without state?
06:24:04 <Cale> chessguy: yes, I think so
06:24:21 <Cale> chessguy: Even though this does work, it requires a sort of tricky argument to see that it does.
06:24:24 <ski_> chessguy : foo {bar = (bar foo) {baz = (baz (bar foo)) {quux = ... }}}
06:24:53 <Cale> (compared to the one which simply collects the subtrees and picks one randomly)
06:25:42 <chessguy> ski_, ah
06:25:53 <chessguy> Cale, but it is more efficient, no?
06:25:58 <Cale> I don't know.
06:26:15 <Cale> I can't really tell. It would be interesting to see.
06:26:42 <chessguy> the other thing is, i have to modify this next to take two trees, choose random subtrees, and swap them
06:26:50 <Cale> Your algorithm generates lots of random numbers, and does a whole lot of rewriting of the state parameter
06:27:12 <hpaste>  ehird annotated "See annotation for my tried fix that still dies" with "this seems to be the cleanest i can come up with" at http://hpaste.org/608#a3
06:27:23 <Cale> Oh, so this is going to get odd. :)
06:27:35 <chessguy> yeah
06:27:45 <chessguy> i thought having the state hanging around could get useful
06:27:50 <ehird> i like how "where" works
06:27:51 <Cale> What you really want is not just the subtree, but the original tree where that subtree is replaced with a hole.
06:28:02 <ehird> and the $ thing is nifty, whatever the $ is meant to represent
06:28:07 <chessguy> yes, an easily-findable hole
06:28:45 <Cale> So we need a new datatype, I think.
06:28:47 <chessguy> and the ability to put a new subtree in the whole
06:28:51 <chessguy> *hole
06:29:01 <Cale> right.
06:29:30 <apfelmus> i guess you want a zipper?
06:29:34 <chessguy> mmm, i need to use Data.Tree, or at least i'd really like to
06:29:34 <Cale> yes
06:29:45 <Cale> Well, we can keep using Data.Tree
06:30:05 <chessguy> oh is there a zipper written for Data.Tree?
06:30:27 <apfelmus> @where zipper
06:30:27 <lambdabot> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
06:30:58 <apfelmus> the wikibook recently got an article about zippers as well
06:31:11 <Cale> I always think of zippers as derivatives. The exact same idea was covered in my combinatorics class under another guise :)
06:31:40 <apfelmus> which one?
06:32:12 <chessguy> Cale, you have some strange ways of thinking about things :)
06:32:42 <Cale> Which class, or which guise? We differentiated sets of combinatorial structures, which, on the generating series side of things, results in differentiating their generating series.
06:33:17 <chessguy> wow, that sounds interesting
06:33:30 <Cale> The simplest way to get a transformation which does that is to delete a subobject in all possible ways. (for a thing with weight n, this results in n new things of weight n-1)
06:33:40 <Cale> That is, differentiating x^n gives n x^(n-1)
06:33:52 <chessguy> heh
06:34:24 <chessguy> so, has a zipper for Data.Tree been written?
06:34:25 <jacobian> d( X^2 ) => d( X * X) => 1*X + X*1 => 2*X
06:34:34 <Cale> jacobian: yes, exactly :)
06:34:48 <Cale> chessguy: Not in the libraries.
06:34:57 <Cale> I'm sure it's been done before.
06:34:58 <chessguy> boo!
06:35:13 <Cale> Another easy way would just be to record the path.
06:35:24 <Cale> But the zipper way is cooler :)
06:35:41 <chessguy> hmm, a monadic zipper would be nice
06:35:44 <hpaste>  ehird annotated "See annotation for my tried fix that still dies" with "teeny tiny cleanup" at http://hpaste.org/608#a4
06:35:48 <Cale> (and possibly more efficient)
06:35:54 <chessguy> generalized to functors :)
06:36:07 <ddarius> @google Weaving a Web Haskell
06:36:09 <lambdabot> http://osdir.com/ml/gmane.comp.lang.haskell.libraries/2004-02/msg00016.html
06:36:09 <lambdabot> Title: Re: Weaving the Web with Haskell
06:36:10 <chessguy> ok, maybe that's overkill
06:37:24 <ddarius> @google functional pearl weaving a web
06:37:26 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/TheWeb.ps.gz
06:37:36 <apfelmus> ah. is there a "coordinate invariant formulation" the generating series differentiation? one that doesn't refer to particular n?
06:37:38 <Cale> Urk! This article has both Haskell and JSON in its name. Do I mod it up or down? :)
06:37:59 <chessguy> haha
06:38:33 <ehird> Dup, Cale
06:39:00 <ehird> hah! my code is smaller than the tutorial's
06:39:09 <ehird> and uses more where
06:39:10 <ehird> :P
06:40:25 <ddarius> ehird: Now make getNumbers tail recursive
06:40:33 <ehird> whu whut
06:41:03 * ehird stares blankly
06:41:22 * ddarius assumed you were talking about the thing in paste.
06:44:06 <ehird> i have just progressed past Language Basics, remember
06:44:20 <ehird> i am not hip with the names for anything :P
06:45:09 <chessguy> heh
06:45:23 <chessguy> you haven't gotten past language basics until you can write your own monads :)
06:45:49 <ddarius> ehird: Use another program to generate a large file (terminated by a 0) and pipe it into your program.
06:46:00 <ehird> ddarius: oh dear, does it break it
06:46:09 <ehird> or am i misunderstanding
06:46:45 <ddarius> ehird: Your program will fail on a large number of inputs.  More than most users would enter at the commandline.
06:47:03 <ehird> Right, and why? Just wondering what's wrong with the design
06:47:31 <ddarius> ehird: You have programming experience with other languages, say, C-like languages?
06:47:57 <ehird> not C-like languages, no - but Ruby, Python, etc - yes
06:48:01 <ehird> no functional languages though
06:48:07 <ehird> i tried C a while ago but didn't like it.
06:48:27 <ddarius> ehird: You know about stack overflow caused by recursion?
06:50:51 <ddarius> (Also, just for the heck of it, one way I might write getNumbers is, getNumbers = liftM (takeWhile (/=0) . map read . words) getContents)
06:50:59 <Cale> ddarius: are you referring to his use of sum and product?
06:51:08 <Cale> rather than foldl' (+) 0 ?
06:51:11 <ehird> Sorry for the delay. Lost all my RAM
06:51:12 <ehird> and CPU
06:51:13 <ddarius> Cale: I'm referring to getNumbers.
06:51:21 <Cale> ah
06:51:28 <ehird> By feeding it 348957934579348579348578934759348 or so when it tries to get the factorial
06:51:31 <ehird> Bad idea.
06:51:46 <ehird> the 'force quit' butotn barely worked
06:52:06 <Cale> hehe
06:52:33 <ehird> i always do stupid things and freeze my computer when a song playing decides to go haywire in the madness of noise
06:52:41 <ehird> apparently i need the atmosphere
06:53:02 <ddarius> Yeah 348957934579348579348578934759348! is a mite large.
06:53:24 <ehird> It froze on minus numbers, too, before I added fac n | n < 0 = 1
06:53:53 <ddarius> @type readLine
06:53:58 <lambdabot> Not in scope: `readLine'
06:54:43 <ehird> everything's going slow now, ugh
06:54:52 <ehird> you've got two bloody cores, machine, use them
06:55:05 <ehird> ddarius: it's getLine?
06:55:26 <ddarius> @hoogle Read a => IO a
06:55:27 <lambdabot> Prelude.readLn :: Read a => IO a
06:55:27 <lambdabot> System.exitFailure :: IO a
06:55:27 <lambdabot> Prelude.readIO :: Read a => String -> IO a
06:56:29 <chessguy> Cale, one idea that someone suggested was to create a zipper and an infinite number of random 'steps' to walk around the tree. but it's hard to guarantee equal probability if i take that approach, i think
06:58:01 <chessguy> s/number/list/
06:58:03 <Cale> chessguy: yeah
06:58:39 <hpaste>  ehird annotated "See annotation for my tried fix that still dies" with "idiot checks" at http://hpaste.org/608#a5
07:00:29 <chessguy> i think with a zipper i'm going to lose the single-pass approach to finding a random subtree though
07:03:37 <chessguy> hmm, maybe not
07:03:55 <chessguy> i could do something similar
07:04:08 <fantasma> I am just beginning to learn haskell, is there any way to limit a funtion to all positive integers without using IF commands?
07:04:39 <chessguy> *cough* n+k patterns *cough*
07:04:51 <jcreigh> chessguy: n+k patterns do that?
07:05:31 <chessguy> n+1 only matches natural numbers, yes
07:05:32 <jcreigh> foo n | n < 1 = error "foo can't take a non-positive integer"
07:05:39 <jcreigh> foo n = whatever
07:05:40 <ehird> > show x where x = show x
07:05:40 <lambdabot>  Parse error
07:05:44 <ehird> oops
07:05:55 <ehird> > let x = show x in show x
07:05:57 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:06:00 <ehird> :D
07:06:25 <fantasma> putStrLn "hi"
07:06:31 <ehird> > putStrLn "hi"
07:06:33 <lambdabot>  <IO ()>
07:06:40 <jcreigh> fantasma: lambdabot doesn't do IO
07:06:44 <fantasma> oh
07:06:54 <fantasma> that's an awesome bot regardless :)
07:06:55 <ehird> infinite variables are weird
07:07:16 <chessguy> ehird, you mean infinite data structures
07:07:26 <chessguy> and they're not so weird
07:07:45 <ehird> > let x = (let x = show x in show x), y = show (show (show x) ++ x) in show y ++ x
07:07:45 <lambdabot>  Parse error
07:07:47 <quicksilver> 10 PRINT "hello" 20 GOTO 10
07:07:49 <ehird> crap.
07:07:53 <quicksilver> that's an infinite data strucutre too :P
07:08:14 <chessguy> no, that's an infinite loop. in BASIC, code is not data :)
07:08:21 <fantasma> I have the fibonacii sequence: fib n = fib (n-2) + fib (n-1) and it still takes negative values
07:08:27 <chessguy> man, i haven't seen BASIC code in years
07:08:29 <ehird> let x = (let x = show x in show x)\ny = show (show (show x) ++ x) in show y ++ x
07:08:29 <jcreigh> > let x = 1 : x in x
07:08:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:08:46 <ehird> run it in ghci, lambdabot doesn't like multi statements :(
07:09:17 <fantasma> > foldr (+) 1:2:3:[]
07:09:18 <lambdabot>   add an instance declaration for (Num ([a] -> a))
07:09:22 <jcreigh> fantasma: yeah, I would just use a gaurd to error on negative numbers.
07:09:35 <ehird> show func doesn't work :(
07:09:37 <ehird> so no quines
07:09:38 <ski_> > let x = (let x = show x in show x); y = show (show (show x) ++ x) in show y ++ x
07:09:38 <quicksilver> > let {x = (let x = show x in show x) ; y = show (show (show x) ++ x)) in show y ++ x
07:09:39 <lambdabot>  Parse error
07:09:39 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:09:54 <quicksilver> ehird: that's how you do 'multi statements'
07:09:58 <ehird> ah
07:10:06 <ehird> > let x = putStrLn "Hello, quine!" in show x
07:10:11 <lambdabot>  "<IO ()>"
07:10:11 <ehird> :/
07:10:19 <ehird> > let x = \t -> putStrLn "Hello, quine!" in show x
07:10:20 <lambdabot>  Add a type signature
07:10:25 <ehird> shut the hell up, bot
07:10:29 * fantasma reads the tutoral more :\
07:10:29 <ski_> (quicksilver : though you forgot a '}')
07:10:34 <chessguy> hudak has a nice quine in SOE
07:10:37 <ehird> fantasma: doing the same :P
07:10:37 <ehird> > let x = x
07:10:38 <lambdabot>  Parse error
07:10:42 <ehird> > x = x
07:10:43 <lambdabot>  Parse error
07:10:44 <quicksilver> ehird: the let syntax really involves { ; }
07:10:48 <jcreigh> @paste
07:10:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:10:53 <ehird> hah, let a = a works
07:11:04 <chessguy> @quote hudak
07:11:04 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
07:11:06 <quicksilver> ehird: the layout rule allows you to avoid them using newlines instead
07:11:12 <chessguy> @quote hudak
07:11:12 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
07:11:15 <ehird> let a = a in show a <-- the new way to end with "!
07:11:18 <chessguy> @quote hudak
07:11:18 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
07:11:20 <chessguy> bah
07:11:22 <hpaste>  jcreigh pasted "fantasma: I mean something like this" at http://hpaste.org/610
07:11:27 <jcreigh> fantasma: ^^
07:11:27 <chessguy> where'd my hudak quote go?
07:11:34 <chessguy> @quote currying
07:11:34 <lambdabot> Hudak says: It was actually Schonfinkel who first called attention to this idea [of currying], but the word "schonfinkelling" is rather a mouthful!
07:11:39 <chessguy> theree it is
07:11:40 <quicksilver> ehird: also, lambda bot does 'expressions', and let x = x isn't and expression
07:11:59 <fantasma> jcreigh, thanks!
07:12:14 <ehird> let a = a; let x = a ++ x  <-- Stack overflow, yay
07:12:18 <pjd> schonfinkelling sounds dirty
07:12:21 <quicksilver> lambdabot used to do top level lets as well, but dons broke it
07:12:47 <jcreigh> yeah, I don't know if I want to go around telling people that I like automatic schonfinkelling.
07:12:49 <quicksilver> ehird: that's not a stack overflow unless you try to actually do something with one of the values
07:12:55 <ehird> well, es
07:12:56 <ehird> *ye
07:12:57 <ehird> s
07:13:03 <quicksilver> > let {a = a; x = a ++ x} in x
07:13:05 <lambdabot>  Exception: <<loop>>
07:13:10 <fantasma> > let x = 1..
07:13:10 <lambdabot>  Parse error
07:13:17 <fantasma> > let x = [1..]
07:13:17 <lambdabot>  Parse error
07:13:19 <quicksilver> fantasma: expressions
07:13:25 <quicksilver> fantasma: that's not an expression
07:13:30 <ehird> does haskell let you access the infinite number? ;)
07:13:31 <quicksilver> > let x = [1..] in x
07:13:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:13:36 <quicksilver> or simply
07:13:39 <quicksilver> > [1..]
07:13:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:13:45 <fantasma> ah
07:13:48 <quicksilver> :t Infinity
07:13:49 <ehird> foldl (+) [1..] maybe
07:13:50 <lambdabot> Not in scope: data constructor `Infinity'
07:14:07 <jcreigh> ehird: yeah. last $ iterate (+1) 0 :)
07:14:28 <ehird> it doesn't print out when i try and print it :(
07:14:29 <Japsu> hehe
07:14:33 <quicksilver> > 1/0
07:14:35 <lambdabot>  Infinity
07:14:48 <chessguy> :t (1/0)
07:14:51 <lambdabot> forall t. (Fractional t) => t
07:15:23 <ehird> putStrLn (show (1/0)) produces Infinity
07:15:23 <ehird> lame
07:15:32 <quicksilver> why is that lame?
07:15:36 <chessguy> yeah, it should give nullity
07:15:37 <jcreigh> ehird: what do you want it to produce? :)
07:15:39 <ski_> @. read run (\x -> "@. read run " ++ x ++ ' ' : show x) "(\\x -> \"@. read run \" ++ x ++ ' ' : show x)"
07:15:40 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
07:15:45 <ehird> jcreigh: the value of infinity!
07:15:47 <ehird> :D
07:15:50 <qwr> > Infinity * 0
07:15:51 <lambdabot>   Not in scope: data constructor `Infinity'
07:15:57 <qwr> > 1 / 0 * 0
07:15:58 <fantasma> ehird, you cant use foldl with infinity, only foldr
07:15:59 <lambdabot>  0.0
07:16:11 <ehird> > let inf = (0/1) in inf * 0
07:16:13 <lambdabot>  0.0
07:16:13 <ski_> strange .. it worked in '/msg'
07:16:15 <ehird> > let inf = (0/1) in inf * 1
07:16:16 <lambdabot>  0.0
07:16:18 <ehird> > let inf = (0/1) in inf * 2
07:16:19 <lambdabot>  0.0
07:16:22 <fantasma> > 1+1
07:16:23 <lambdabot>  2
07:16:24 <ehird> infinity times 2 is 0.0 :/
07:16:27 <jcreigh> ehird: it's a little known fact that infinity is actually, when you get right down to it, just 8 ASCII characters. :)
07:16:30 <ehird> that somehow seems wrong
07:16:46 <ehird> > let inf = (0/1) in 1*inf
07:16:47 <lambdabot>  0.0
07:16:59 <ehird> load of crap
07:17:07 <quicksilver> ehird: erm
07:17:10 <ehird> =P
07:17:11 <fantasma> > 2^10
07:17:11 <apfelmus> > let x `plus` y = x ++ y; one = [()]; infinity = one `plus` infinity in infinity
07:17:11 <quicksilver> ehird: 0/1 is 0, you know?
07:17:13 <lambdabot>  1024
07:17:13 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
07:17:15 <ehird> oops
07:17:19 <ehird> i typo'd there :(
07:17:22 <fantasma> > 2^1000
07:17:23 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
07:17:29 <quicksilver> > let inf = (1/0) in inf * 2
07:17:31 <lambdabot>  Infinity
07:17:35 <ehird> > let inf = 1/0 in inf * 0
07:17:37 <lambdabot>  0.0
07:17:43 <ehird> at least it gets that right
07:17:46 <ehird> > let inf = 1/0 in inf/inf
07:17:47 <lambdabot>  NaN
07:17:49 <quicksilver> "right"
07:18:01 <quicksilver> it's a possible answer, certainly
07:18:04 <ehird> the answer to life the universe and everything is
07:18:07 <ehird> NaN
07:18:12 <jcreigh> lol
07:18:14 <quicksilver> although personal I'd argue for inf * 0 being naN
07:18:15 <ehird> computer not powerful enough :(
07:18:29 <jcreigh> @remember ehird the answer to life the universe and everything is NaN
07:18:30 <lambdabot> Done.
07:18:47 <fantasma> >2^(1/0)
07:18:55 <fantasma> > 2^(1/0)
07:18:56 <lambdabot>  Add a type signature
07:18:58 <ehird> what does @remember do? make the bot fondly remember someone forever?
07:19:06 <jcreigh> ehird: yeah
07:19:09 <jcreigh> @quote ehird
07:19:09 <ehird> > let 1 = 0 in 1
07:19:10 <lambdabot> ehird says: the answer to life the universe and everything is NaN
07:19:12 <lambdabot>  1
07:19:14 <ehird> :(
07:19:26 <qwr> @quote quicksilver
07:19:26 <lambdabot> quicksilver says: paolino: it can be used to proof various deep theorems about stuff
07:19:27 <ehird> no redefining literals?! lame language!
07:19:29 <ehird> :D
07:19:36 <fantasma> @quote rootkit
07:19:36 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
07:19:37 <jfoutz> quicksilver, i think the payoff for optimizing 0* anything = 0 outweighs the niceness of Inf * 0 = Nan
07:19:43 <ehird> @quote haskell
07:19:44 <lambdabot> scodil says: dcoutts: rad. i'm actually using gtk2hs quite a bit now. its one of those deals where I'm writing prototype software for people who aren't really paying for it, so it will end up being
07:19:44 <lambdabot> the production software, so you'll probably be getting emails in 5 years asking "what is haskell and how do I install it?"
07:19:44 <jcreigh> > let 2+2 = 5 in 2+2
07:19:45 <fantasma> @quote fantasma
07:19:45 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
07:19:46 <lambdabot>  5
07:19:59 <ehird> @quote lambdabot
07:19:59 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
07:20:02 <ehird> heh
07:20:30 <quicksilver> > let 2+2 = 5 in 2+3
07:20:31 <lambdabot>   Non-exhaustive patterns in function +
07:20:33 <quicksilver> boom :)
07:21:16 <ehird> > let (+) 2 2 = 5 in 2+2
07:21:18 <lambdabot>  5
07:21:20 <ehird> GASP
07:21:23 <quicksilver> same thing
07:21:32 <ehird> well whatever
07:21:35 <quicksilver> let (+) 2 2 is exactly the same as let 2+2
07:21:41 <quicksilver> two ways of writing the same thing
07:22:02 <quicksilver> let {2+2 = 5 ; 5+2 = 12} in 2+2+2
07:22:10 <quicksilver> > let {2+2 = 5 ; 5+2 = 12} in 2+2+2
07:22:11 <lambdabot>  12
07:22:12 <ehird> let 2 + 2 == 5 = True in 2 + 2 == 5
07:22:17 <ehird> > let 2 + 2 == 5 = True in 2 + 2 == 5
07:22:17 <lambdabot>  Parse error in pattern
07:22:19 <ehird> :(
07:22:30 <ehird> you should be able to redefine blocks of code, hehe
07:22:33 <quicksilver> you can't redefine two functions at once
07:22:37 <quicksilver> you can redefine ==
07:22:40 <quicksilver> or redefine +
07:22:45 <quicksilver> but not both in one statement
07:23:10 <ehird> > let a==b = if 2 + 2 == 5 then True
07:23:10 <lambdabot>  Parse error
07:23:14 <jfoutz> oooooohhhhhhhh that's what's happening. that's cool
07:23:17 <ehird> > let a==b = if 2 + 2 == 5 then True in 2+2==5
07:23:17 <lambdabot>  Parse error
07:23:20 <ehird> oh forget it :P
07:23:33 <glguy> ehird: if...then...else....
07:23:38 <ehird> oop
07:23:39 <ehird> s
07:23:55 <chessguy> ?seen xerox
07:23:56 <lambdabot> xerox is in #happs, #perl6, #haskell.it, #haskell-overflow, #haskell-blah and #haskell. I last heard xerox speak 3h 16m 34s ago.
07:23:58 <ehird> > let let = False in let a = 2
07:23:58 <lambdabot>  Parse error
07:23:59 <ehird> aw
07:24:06 <chessguy> ?localtime xerox
07:24:08 <lambdabot> Local time for xerox is 2007-02-23 16:21:53 +0100
07:24:09 <ehird> i want to redefine let :(
07:24:10 <earthy> > let a==b = if 2 + 2 == 5 then True else False in 2+2 == 5
07:24:11 <lambdabot>   add an instance declaration for (Num Bool)
07:24:11 <lambdabot>     In the expression:
07:24:11 <lambdabot>         l...
07:24:17 <earthy> ghe. ;)
07:24:17 <chessguy> hmm, slacker :)
07:24:21 <quicksilver> > let a+b = ((show a) ++ "<>" ++ (show b)) in 2+2
07:24:22 <lambdabot>  "2<>2"
07:24:35 <ehird> > let 2 = a in 2
07:24:36 <lambdabot>   Not in scope: `a'
07:24:43 <ehird> > let a = 2; 2 = a in 2
07:24:43 <jfoutz> let let = 5 in let
07:24:44 <lambdabot>  2
07:24:56 <jfoutz> > let a let =5 in let
07:24:57 <lambdabot>  Parse error
07:24:58 <ehird> > let a = 3; 2 = a in 2
07:24:59 <lambdabot>  2
07:25:01 <ehird> aww
07:25:18 <jfoutz> > let let = 5 in let
07:25:19 <lambdabot>  Parse error
07:25:56 <ehird> > let 42 = True in 42 == True
07:25:57 <lambdabot>   add an instance declaration for (Num Bool)
07:25:59 <ehird> no.
07:26:08 <quicksilver> numeric literals are special
07:26:08 <Saizan> ehird, numeric literals are implemented as fromInteger x  e.g. 2 === fromInteger (2::Integer)
07:26:13 <quicksilver> they aren't symbols
07:26:19 <quicksilver> so you can't redefine them
07:26:24 <quicksilver> whereas '+' isn't special
07:26:26 <quicksilver> it's just a symbol
07:26:27 <ehird> > let fromInteger = True in 42 == True
07:26:28 <lambdabot>   add an instance declaration for (Num Bool)
07:26:30 <quicksilver> so you can redefine it
07:26:34 <ehird> > let fromInteger _ = True in 42 == True
07:26:34 <lambdabot>   add an instance declaration for (Num Bool)
07:26:41 <quicksilver> ehird: no, because it's lexical scope
07:26:48 <Saizan> ?type fromInteger
07:26:51 <lambdabot> forall a. (Num a) => Integer -> a
07:26:52 <quicksilver> ehird: you're only *locally* redefining fromInteger there
07:26:58 <ehird> bah
07:27:12 <quicksilver> ehird: whereas '2' is interpreted using the true definition of fromInteger
07:27:29 <quicksilver> let b = 2+2 in let 2+2 = 5 in b
07:27:34 <quicksilver> > let b = 2+2 in let 2+2 = 5 in b
07:27:35 <lambdabot>  4
07:27:43 <quicksilver> notice that I redefine + locally
07:27:45 <ehird> > let the true definition of fromInteger = True in 42
07:27:45 <lambdabot>  Parse error
07:27:47 <ehird> :P
07:27:49 <quicksilver> and it doesn't affect the definition of b
07:27:49 <jfoutz> let (==) 42 _ = True in 5 == 42
07:27:59 <quicksilver> which was already defined
07:27:59 <jfoutz> > let (==) 42 _ = True in 5 == 42
07:28:01 <lambdabot>   Non-exhaustive patterns in function ==
07:28:10 <jfoutz> let (==) 42 _ = True in 42 == 5
07:28:16 <jfoutz> grr.
07:28:19 <quicksilver> > let (==) 42 _ = True in 42 == 5
07:28:19 <ehird> > let 42 == _ = True in 42 == True
07:28:21 <lambdabot>  True
07:28:21 <lambdabot>  True
07:28:23 <quicksilver> :)
07:28:25 <jfoutz> me and my typos sorry
07:28:45 <ehird> > let a == a = False in 1 == 1
07:28:46 <lambdabot>      Conflicting definitions for `a'
07:28:48 <lambdabot>     In the definition of `=='
07:28:48 <ehird> aww
07:28:59 <ehird> you can't pattern match "param1 param1" to check for equality?
07:29:01 <jfoutz> ehird, just one function at a time
07:29:18 <Saizan> ehird: no
07:29:25 <ehird> > let a b | a == b = False in 1 == 1
07:29:26 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
07:29:26 <lambdabot>     Probab...
07:29:34 <ehird> you must construct... THE INFINITE TYPE
07:29:43 <Saizan> > let a == b = False in 1 == 1
07:29:45 <lambdabot>  False
07:29:53 <ehird> no, that overrides everything
07:30:00 <ehird> i'm trying to override only things that are equal
07:30:02 <ehird> wait.
07:30:03 <ehird> same thing.
07:30:18 <fasta> Is there a state monad somewhere implemented that can change the type of state while it's running?
07:30:34 <chessguy> ?hoogle zipper
07:30:34 <lambdabot> No matches found
07:30:50 <ski_> fasta : 'ST' ?
07:30:56 <ehird> > let let let let let let
07:30:56 <lambdabot>  Parse error
07:31:13 <ehird> > let fac = product [1.. .] in fac 645654654561564654654564
07:31:14 <lambdabot>  Parse error
07:31:21 <ehird> > let fac n = product [1..n] in fac 645654654561564654654564
07:31:21 <ski_> (fasta : otherwise i think i requires more power than the monad interface gives ..)
07:31:25 <lambdabot> Terminated
07:31:29 <ehird> bah.
07:32:15 <allbery_b> well, you could make it a State (Either Int String) and switch from Left to Right mid-stream
07:32:35 <quicksilver> fasta: that wouldn't be a (fixed) monad
07:32:46 <ehird> > let x = do let x = "a" ++ x ++ "a" in show x in x
07:32:47 <lambdabot>  "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:32:53 <fasta> quicksilver: and what is "fixed" monad?
07:32:53 <quicksilver> fasta: that would be a bunch of different monads, with special combinators at the state-type-change points
07:33:16 <quicksilver> fasta: you could do that, although you wouldn't be able to do the sexy do syntax at the state-type-change-points
07:33:21 <fasta> I think the easiest is to just run different monads.
07:33:22 <ehird> > let x = do let x = x in [show x]:x in x
07:33:24 <lambdabot>  Exception: <<loop>>
07:33:29 <ehird> you lie!
07:33:30 <ehird> it is [["
07:33:52 <quicksilver> or build a big state which includes all the stuff you need
07:34:02 <quicksilver> using an appropriate data type
07:34:35 <fasta> "all the stuff you need"... heh
07:34:42 <quicksilver> or don't use a monad at all
07:34:45 <quicksilver> just a function on tuples :P
07:34:54 <quicksilver> monads aren't the answer to everything
07:35:00 <ehird> > let x = do let x = x in ["[]"]:[[]]:[[]]:[show x]:x in x
07:35:01 <lambdabot>  Exception: <<loop>>
07:35:06 <ehird> bah. [["[]"],[""],[""],["
07:35:28 <ehird> is there a quine in haskell?
07:35:31 <ehird> presumably yes
07:35:32 <quicksilver> of course
07:35:37 <ehird> i imagine it involves show
07:35:41 <quicksilver> any turing complete language has a quine
07:35:42 <ehird> and mapM
07:35:47 <ehird> well, yes.
07:35:50 <quicksilver> (and probably many which aren't)
07:36:26 <Cale> http://xkcd.com/ -- haha
07:36:27 <quicksilver> googling for haskell quine will find you quite a few
07:37:48 <ehird> http://www.nyx.net/~gthompso/self_hask.txt this sucks.
07:37:50 <ehird> really.
07:37:50 <greenrd> Is it possible to have a ReadP a where a is something other than Char or String?
07:38:23 <greenrd> I mean let's say I have a BNF grammar for a language and I want to parse that language with ReadP
07:38:28 <ehird> is there a 'show' that shows the name of a funciton?
07:38:39 <ehird> i.e. fShow putStrLn == "putStrLn"
07:38:42 <Cale> ehird: no
07:38:47 <greenrd> Can I have a ReadP Expr and a ReadP StringLiteral and a ReadP Variable, etc.?
07:38:48 <ehird> aw
07:39:00 <Cale> ehird: names of functions are thrown away by compilation
07:39:01 <dylan_> ehird: such a functional is not possible.
07:39:14 <ehird> so much for an easy quine then
07:39:25 <Cale> there is an easy one liner quine
07:39:35 <quicksilver> greenrd: yes
07:39:49 <quicksilver> greenrd: it wouldn't be much otherwise, would it?
07:39:53 <greenrd> ok
07:40:08 <quicksilver> wouildn't be much use, I mean to say :)
07:40:18 <greenrd> so, can you show me an example?
07:40:34 <greenrd> I haven't been able to find one
07:40:43 <quicksilver> greenrd: it's a bit obfuscated in the haddock
07:40:50 <quicksilver> greenrd: basically you use the fmap instance :)
07:41:14 <quicksilver> they don't really spell this out for you, though
07:42:24 <greenrd> @t fmap
07:42:24 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:42:31 <greenrd> @type fmap
07:42:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:43:16 <ehird> Hey, a quine producing function.
07:44:15 <Cale> putStrLn $ ap (++) show "putStrLn $ ap (++) show "
07:44:41 <Cale> (that requires Control.Monad and Control.Monad.Instances)
07:44:41 <ehird> Current prototype of quine producing function:
07:44:43 <ehird> let (+-.) a b = putStrLn $ show a ++ show " +-. " ++ show b
07:45:00 <Cale> > (\a -> a ++ show a) "(\\a -> a ++ show a) "
07:45:01 <lambdabot>  "(\\a -> a ++ show a) \"(\\\\a -> a ++ show a) \""
07:45:10 <ehird> Used like "let (+-.) a b = putStrLn $ show a ++ " +-. " ++ show b". All I have to do is duplicate it, one time without ""s, and duplicate it in the string, and... shit we're getting infinite here aren't we
07:45:52 <Cale> (\a -> putStrLn $ a ++ show a) "(\\a -> putStrLn $ a ++ show a) "
07:46:06 <Cale> That one doesn't require the extra modules
07:47:00 <quicksilver> arguablyt there are two 'types' of quines, being String and IO ()
07:47:11 <Cale> yeah
07:47:25 <Cale> ap (++) show "ap (++) show "
07:47:34 <Cale> is a pretty elegant string quine :)
07:47:38 <Cale> > ap (++) show "ap (++) show "
07:47:40 <lambdabot>  "ap (++) show \"ap (++) show \""
07:48:19 <ehird> what does ap do?
07:48:31 <quicksilver> function application lifted into a monad
07:48:37 <Cale> Well, it's really more general, but in this case,  ap f g x = f x (g x)
07:49:01 <quicksilver> \f a b = do { a' <- a; b' <- b; return f a' b' }
07:49:10 <quicksilver> that's ap
07:49:23 <quicksilver> erm
07:49:25 <quicksilver> that's liftM2
07:49:29 <quicksilver> ap is the unary version :)
07:49:29 <kc5tja> Morning folks.
07:49:32 <Cale> So  ap (++) show x = x ++ (show x)
07:49:45 <chessguy> hi kc5tja
07:49:45 <Cale> @src ap
07:49:46 <lambdabot> ap = liftM2 id
07:49:48 <chessguy> ?losers
07:49:48 <lambdabot> Maximum users seen in #haskell: 328, currently: 322 (98.2%), active: 45 (14.0%)
07:49:56 <Cale> haha
07:50:18 <Cale> Wow, we're well over 300, I didn't even notice
07:50:37 <ehird> agh, this quine hurts me
07:50:40 <ehird> @paste
07:50:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:50:52 <hpaste>  ehird pasted "current thign i'm trying to get compile :P" at http://hpaste.org/611
07:51:04 <Cale> ehird: perhaps you'd be more comfortable with the pointed version
07:51:15 <ehird> no, the one i'm trying to write
07:51:15 <Cale> (\a -> a ++ show a) "(\\a -> a ++ show a) "
07:51:22 <ehird> writing a quine is the funnest thing you can do as a language noob
07:51:25 <ehird> because you can only fail
07:52:04 * ski_ 's quine above sadly only worked in '/msg lambdabot' for some reason :(
07:52:24 <quicksilver> greenrd: did you work it out?
07:52:48 <Cale> ehird: +-. takes two strings and gives an IO action
07:53:02 <Cale> ehird: thus, you can't pass its result to itself
07:53:18 <Cale> (your main has two +-.'s in it)
07:53:23 <ehird> ah
07:53:29 * ehird changes it to produce strings instead
07:54:20 <glguy> does a data type exist in the base library for storing a Directory/File tree?
07:54:42 <quicksilver> glguy: not as such, as far as I know
07:54:42 <Cale> glguy: No.
07:54:53 <Cale> That would be quite interesting though.
07:55:27 <quicksilver> data DirTree = File String | Directory String [DirTree]
07:55:28 <quicksilver> ?
07:55:38 <Cale> What about attributes? :)
07:55:43 <glguy> sure, I just don't want to reinvent a wheel if it exists
07:55:49 <glguy> and I didn't see it in System.Directory
07:55:51 <Cale> and file contents?
07:56:01 <Cale> or do you just want the filenames
07:56:07 <quicksilver> replace String with something more functional if you like
07:56:12 <quicksilver> FilePath, possibly
07:56:18 <quicksilver> I was reducing data redundancy :)
07:56:21 <glguy> I was presently just thinking about names at the moment
07:56:22 <Cale> Tree FilePath perhaps
07:56:33 <hpaste>  ehird annotated "current thign i'm trying to get compile :P" with "I will crack this, but damn if i know how" at http://hpaste.org/611#a1
07:56:48 <quicksilver> Cale: isn't Tree binary, and what we really want here is n-ary?
07:56:56 <chessguy> sigh.
07:57:00 <Cale> Tree is n-ary
07:57:03 <chessguy> haskell has me so spoiled
07:57:04 <quicksilver> ah
07:57:12 <Cale> chessguy: haha
07:57:20 <Cale> chessguy: what are you trying to write in now?
07:57:22 <glguy> Binary trees are binary :)
07:57:32 <chessguy> it makes my job so much more excruciating when i have to do basically the same thing over and over again
07:57:38 <ehird> aha stray putstrl
07:57:38 <ehird> n
07:57:44 <chessguy> they need to just abstract
07:58:03 <chessguy> i swear they could lay off half the company if they were smarter
07:59:40 <chessguy> Cale, sadly i'm not even really doing programming right now at my job
07:59:59 <chessguy> i'm not sure why they hired a programmer to not program
08:00:17 <zbrown> chessguy: what do they have you do?
08:00:31 <Cale> chessguy: hmm, that's interesting -- time to start your own company? :)
08:00:34 <chessguy> set stuff up on their internal web app
08:01:11 <Cale> I really wish I had some insights into the inefficiencies of some major businesses.
08:01:32 <hpaste>  ehird annotated "current thign i'm trying to get compile :P" with "It's getting there" at http://hpaste.org/611#a2
08:01:39 <Altair^> what conclusions should one draw from error Numbers.hs:14:1: Parse error in pattern
08:01:55 <Cale> The best thing to look for are things like what you're doing -- where companies hire people who are highly trained to do very repetitive things.
08:01:56 <allbery_b> you forgot a set of parentheses?
08:02:06 <allbery_b> (common, but not the only possibility)
08:02:16 <Cale> Altair^: go to that line of your source file, and look at any patterns that occur on it.
08:02:16 <allbery_b> @paste
08:02:17 <chessguy> Cale, yeah, it's ridiculous. my mom could just about do my job
08:02:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:03:10 <Cale> chessguy: Would it be reasonable to start a business where you have a computer program doing what you're doing (but don't tell anyone that), where you provide the service of what you're doing?
08:03:31 <chessguy> i don't really k now enough about the domain
08:04:04 <Altair^> but it is an if-statement
08:04:11 <chessguy> their non-technical, domain-specific training is atrocious
08:04:29 <Altair^> and it seems to me that there cannot in any way be an error
08:04:39 <allbery_b> @paste it
08:04:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:04:40 <Altair^> lol what a sentence
08:06:40 <hpaste>  Altair pasted "Very primitive" at http://hpaste.org/612
08:07:29 <beelsebob|mini> interesting... it would appear that OS X.5 uses darcs for it's magical time machine backup thing
08:07:48 <dylan_> it does?
08:08:00 <beelsebob|mini> well... I just caught darcs running as a child process of backupd
08:08:07 <beelsebob|mini> so it looks like it
08:08:14 <beelsebob|mini> can't swear to it though
08:08:46 <allbery_b> Altair^: your else clause needs a do
08:08:52 <Altair^> ah, lol
08:08:54 <Altair^> thanks
08:09:10 <quicksilver> Altair^: although actually, it won't work then either
08:09:16 <quicksilver> Altair^: givenNum is a number
08:09:20 <malcolmw> beelsebob|mini: seems a bit unlikely, given how darcs can hang so easily
08:09:31 <quicksilver> Altair^: I'm not sure what 'rest <- givenNum' is trying to do
08:09:34 <hpaste>  allbery_b annotated "Very primitive" with "do it" at http://hpaste.org/612#a1
08:09:46 <beelsebob|mini> malcolmw: when does it hang?
08:09:58 <glguy> @fptools Data.Tree
08:09:59 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
08:10:04 <malcolmw> beelsebob|mini: well ndm is always telling me how it hangs for him
08:10:14 <beelsebob|mini> I don't think I've ever seen it hang
08:10:16 <hpaste>  ehird annotated "current thign i'm trying to get compile :P" with "Fruitless. Anyone want to try and fix it? :P" at http://hpaste.org/611#a3
08:10:23 <beelsebob|mini> nor heard anyone else complain about it
08:10:28 <beelsebob|mini> maybe it's a windows only problem
08:10:37 <hpaste>  allbery_b annotated "Very primitive" with "wrong function? (use diff)" at http://hpaste.org/612#a2
08:10:38 <malcolmw> beelsebob|mini: got any idea when Leopard will be released officially?
08:10:39 <Altair^> lol, I saw that too quicksilver
08:10:52 <Altair^> I have done something wierd
08:10:54 <quicksilver> :)
08:11:21 <beelsebob|mini> malcolmw: my guess is June 11th, based on this... http://developer.apple.com/wwdc/
08:11:22 <lambdabot> Title: Worldwide Developers Conference 2007
08:11:23 <ketil_> I seem to have a strictness issue with lazy bytestring unfoldr.  Tried to strictify the unfoldr'ed function, but to no avail.  How do I debug this?
08:11:25 <quicksilver> Altair^: I strongly suspect you want a recursive call to askForNumbers somehwere in the else case
08:11:35 <beelsebob|mini> although there are reports of it being in late March... which seems a bit weird
08:11:52 <malcolmw> beelsebob|mini: that's a long way off.  How about iLife'07?
08:12:13 <beelsebob|mini> malcolmw: the best guesses is that they rely on CoreAnimation and hence would be released along with 10.5
08:12:48 <Altair^> I of course wanted to type rest <- askForNumbers
08:13:25 <Altair^> and now it works \o/
08:13:35 <quicksilver> Altair^: that sounds much more plausible :0
08:13:40 <malcolmw> beelsebob|mini: hmm, I was wondering what they could do to make people want to pay for iLife'07, when iLife'06 already does pretty much everything you could want
08:14:05 <beelsebob|mini> malcolmw: good question - but then consider that I thought that about iLife 05 and iLife 04
08:14:09 <malcolmw> beelsebob|mini: but I suppose more eye candy effects might be it.
08:14:10 <ehird> > main = putStrLn $(\a -> a ++ show a) "main = putStrLn $(\\a -> a ++ show a) "
08:14:11 <lambdabot>  Parse error
08:14:15 <ehird> > let main = putStrLn $(\a -> a ++ show a) "main = putStrLn $(\\a -> a ++ show a) " in main
08:14:16 <lambdabot>  <IO ()>
08:14:19 <ehird> blah.
08:14:24 <quicksilver> malcolmw: better photo albums
08:14:34 <quicksilver> malcolmw: more freedom in designing them but still all loking professional :)
08:14:45 <beelsebob|mini> malcolmw: tbh... I'm guessing that most of the core animation stuff is for iWork -- decent animated transitions in Keynote and the like
08:14:52 * allbery_b didn't see the point in upgrading from iLife'05
08:15:01 <beelsebob|mini> like being able to move graphics about in an animated way rather than have them fade in and out
08:15:15 <allbery_b> but then I never use most of it.
08:15:21 * malcolmw still has iLife'05 on his laptop
08:15:24 <allbery_b> iWork might be worth the upgrade though
08:15:38 <beelsebob|mini> it really depends on whether they release this spreadsheets app
08:15:50 <quicksilver> Altair^: Instead of 'do {rest <- askForNumbers; return givenNum:rest} you could amuse yourself with askForNumbers >>= return . (givenNum:)
08:15:54 <beelsebob|mini> because from the screenshots I've seen it looks like it has the feature that I've wanted for a long time
08:16:05 <beelsebob|mini> i.e. having multiple tables that can be aranged on one sheet
08:16:20 <quicksilver> Altair^: I dont' really recommend this style very much, but it's interesting to look at/think about
08:16:22 <malcolmw> Keynote already has pretty good transitions, but I agree that pretty movement of objects within a single slide would be nice
08:16:28 <quicksilver> Altair^: basically you avoid having to name 'rest'
08:17:04 <malcolmw> How can we confirm whether leopard runs darcs internally?   locate darcs | less  ??
08:17:14 <Cale> fmap (givenNum :) askForNumbers
08:17:20 <beelsebob|mini> good plan... *goes to run that*
08:17:43 <allbery_b> alos verify that darcs is darcs, and not some Apple thing that hapens to have the same name :)
08:17:55 <beelsebob|mini> indeed
08:17:56 <quicksilver> Cale: good point. I always forget about using fmap/liftM in this way
08:18:53 <beelsebob|mini> the file format of the change logs looks significantly different
08:19:01 <beelsebob|mini> *considers what's going on*
08:19:59 <fantasma> > pi
08:20:00 <lambdabot>  3.141592653589793
08:22:20 <fantasma> it is invalid to do n = 0,1 = 1? do i have to do n=0=1 and n=1=1?
08:23:23 <Saizan> what n=0=1 would mean?
08:23:29 <quicksilver> fantasma: is that comparison or assignment?
08:23:33 <quicksilver> fantasma: what are you trying to do?
08:23:50 <fantasma> it's fac n | n=0=1
08:23:58 <fantasma> i guess comparison
08:24:11 <Saizan> fac n | n==0 || n==1
08:24:21 <quicksilver> better is
08:24:24 <quicksilver> fac 0 = 1
08:24:26 <quicksilver> fac 1 = 1
08:24:34 <fantasma> why's that better
08:24:40 <quicksilver> doesn't use ==
08:24:47 <quicksilver> uses pattern matching directly
08:25:07 <quicksilver> looks nicer, too :)
08:25:20 <fantasma> i can do fac n | n = 0 = 1 and that works too
08:25:21 <glguy> If you are doing a factorial, there is no need for the fac 1 case :)
08:26:02 <Cale> tmoertel: I find it funny that someone actually modded down your rebuke of that C++ code.
08:26:07 <fantasma> glguy, ah yes :)
08:26:16 <Cale> (I modded it back up to 1)
08:26:23 <quicksilver> Cale: how does fantasma's code parse?
08:26:28 <glguy> fantasma: and it's not: fac n | n=0=1, it is: fac n | n == 0 = 1
08:26:46 <Cale> quicksilver: sorry, I haven't been following too closely -- which code?
08:27:23 <quicksilver> Cale: < fantasma> i can do fac n | n = 0 = 1 and that works too
08:27:27 <Cale> that won't parse
08:27:29 <fantasma> nvm
08:27:34 <quicksilver> good, that's what I thought :)
08:27:43 <glguy> Cale: for that article, I'd rather he created a Data.Tree.Tree with IO and demonstrated the use of library functions on it :)
08:27:44 <quicksilver> fantasma: you want to distinguish 'definition' from 'equality'
08:27:46 <tmoertel> Cale: I wasn't so much trying to rebuke it as much as make sure that people don't over-credit its claims.
08:27:47 <glguy> with drawTree
08:27:52 <quicksilver> fantasma: with one = sign, it's a definiotn
08:27:59 <quicksilver> fantasma: with two == it's a test for equality
08:28:15 <Cale> tmoertel: well, yeah. I thought it was pretty appropriate. :)
08:28:17 <fantasma> yah I know I was looking at my code wrong
08:28:24 <nmessenger1> @type (==)
08:28:26 <lambdabot> forall a. (Eq a) => a -> a -> Bool
08:28:45 <glguy> ?djinn a -> a -> Bool
08:28:45 <lambdabot> f _ _ = False
08:28:50 <quicksilver> '=' is a fundamental part of the language
08:28:50 <nmessenger1> heh
08:28:54 <glguy> I like that definition better
08:28:57 <quicksilver> '==' is just a function like any other
08:29:16 <Cale> well, it's a class method
08:29:25 <quicksilver> yes :)
08:29:27 <Cale> but yeah, class methods are fairly ordinary :)
08:29:45 <quicksilver> assuming sometihng in the context has fixed the dictionary, it's a function
08:30:22 <fantasma> it is more common to use == or to do it directly?
08:30:31 <quicksilver> I would pattern match
08:30:38 <quicksilver> using == is relying on the type supporting Eq
08:30:39 <beelsebob|mini> I would pattern match too
08:30:40 <quicksilver> which it might not
08:30:48 <quicksilver> pattern matching works on any data type
08:30:55 <beelsebob|mini> plus... pattern matching is more powerful
08:30:55 <quicksilver> (I know you're working with numbers here, but it's a habit)
08:31:04 <nmessenger> any data type with expose constructors, anyway :)
08:31:09 <nmessenger> exposed*
08:31:11 <quicksilver> jeje
08:31:12 <beelsebob|mini> how would you do f (Succ x) = ... using equality
08:31:29 <quicksilver> beelsebob|mini: f y | y == x+1
08:31:39 <beelsebob|mini> quicksilver: no, I mean the ADT version
08:31:45 <quicksilver> beelsebob|mini: f y | y == Succ x
08:31:54 <beelsebob|mini> quicksilver: and what's x bound to
08:32:01 <quicksilver> erm
08:32:03 <beelsebob|mini> that wouldn't compile
08:32:04 <quicksilver> good point!
08:32:08 <quicksilver> beelsebob|mini wins!
08:32:11 <beelsebob|mini> :DD
08:32:13 <beelsebob|mini> :P
08:33:01 <fantasma> can you use pattern matching with inequalities?
08:33:07 <glguy> no
08:33:43 <beelsebob|mini> well, you can... on finite types
08:33:49 <nmessenger> pattern matching will give you just the data you match.  I'm not sure how you could get around (/=) for inequalites.
08:33:50 <beelsebob|mini> you just wouldn't want to do it that way
08:34:28 <nmessenger> Int is a finite type :)  You'll just have a few cases :D
08:34:28 <glguy> beelsebob|mini: an example?
08:34:59 <beelsebob|mini> glguy: data FiniteIntegers = One | Two | Three, f y | y > 2 becomes f Three
08:35:11 <glguy> beelsebob|mini: that isn't pattern matching
08:35:15 <beelsebob|mini> f y | y >= 2 becomes f Two ... f Three
08:35:17 <beelsebob|mini> yes it is
08:35:24 <nmessenger> Bool is tiny: f False = doThingWhenNotTrue
08:35:33 <glguy> beelsebob|mini: no, those are guards
08:35:37 <nmessenger> f Three is
08:35:50 <beelsebob|mini> glguy: no - I'm showing how to do the guard with an inequality *as* pattern matching
08:35:58 <beelsebob|mini> you can do it with finite types
08:36:02 <glguy> beelsebob|mini: and, it's not pattern matching
08:36:07 <beelsebob|mini> glguy: f Three is
08:36:12 <glguy> I'm not arguing that functions can't use inequalities
08:36:16 <nmessenger> glguy: he's talking about the latter examples
08:36:29 <beelsebob|mini> note f y | y > 2 becomes f Three
08:36:38 <nmessenger> the guard f y | y >= 2 can be replaced with the pattern matches f Two and f Three
08:36:51 <glguy> sure, but the guard isn't pattern matching is all
08:36:54 <glguy> but the f Tree is
08:36:56 <beelsebob|mini> exactly
08:36:56 <glguy> Three*
08:37:11 <glguy> the fact that they do the same thing doesn't have anything to do with it
08:37:20 <beelsebob|mini> my point is that you can do the same as the guard with inequality by using pattern matching
08:37:25 <beelsebob|mini> iff the type is finite
08:37:36 <xerox> ?logs
08:37:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:37:41 <xerox> ?where logs
08:37:41 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
08:37:44 <glguy> I'm not arguing you can't do the same thing, just that that wasn't actually pattern matching
08:37:54 <beelsebob|mini> glguy: yes it was
08:38:15 <nmessenger> any place you can guard against cases you don't want (in a finite type), you can replace that with patterns for the cases you do want.
08:38:17 <beelsebob|mini> can you do inequalities as pattern matching... yes
08:38:20 <beelsebob|mini> f Three = blah
08:38:43 <glguy> that's not an inequality
08:38:47 <beelsebob|mini> yes it is
08:39:04 <beelsebob|mini> it's operationally equivalent to f y | y > 2
08:39:17 <nmessenger> glguy: you are violently agreeing, beelsebob|mini is saying the same thing
08:39:18 <chessguy> hey Cale, here's a paper you might enjoy: http://www.prism.gatech.edu/~gtg365v/Buzz/research/magic/Bitboards.pdf (you might need the background of the first link or two from http://www.cis.uab.edu/hyatt/pubs.html )
08:39:21 <lambdabot> http://tinyurl.com/37p4p8
08:39:29 * glguy fixes the issue with his irc client
08:39:52 <hpaste>  ehird pasted "actually readable quine" at http://hpaste.org/613
08:40:01 <fantasma> what would the best factorial function look like?
08:40:10 <beelsebob|mini> fantasma: that's very depadable
08:40:40 <chessguy> ?spell depadable
08:40:42 <lambdabot> dependable debatable decidable datable degradable
08:40:46 <ehird> fantasma: personally? i'm a newb, but:
08:40:48 <glguy> fantasma: fac n | n >= 0 = product [1..n] -- rather good
08:40:50 <beelsebob|mini> debatable
08:40:57 <quicksilver> fantasma: this channel is more likely to find you the worst than the best
08:40:57 <ehird> fac n | n <= 0 = 1
08:41:02 <ehird> fac n = product [1..n]
08:41:07 <quicksilver> we're better at pessimising here
08:41:10 <beelsebob|mini> glguy: neat, but incorrect
08:41:11 <chessguy> > prod [1..0]
08:41:14 <lambdabot>   Not in scope: `prod'
08:41:14 <glguy> ehird: that's not true for negative numbers
08:41:21 <chessguy> > product [1..0]
08:41:22 <glguy> chessguy: that will be product [] with is 1
08:41:23 <lambdabot>  1
08:41:27 <beelsebob|mini> or not
08:41:29 <beelsebob|mini> bizare
08:41:35 <nmessenger> > [1..0]
08:41:37 <lambdabot>  []
08:41:37 <beelsebob|mini> why is product [1..0] not 0?
08:41:37 <chessguy> ?src product
08:41:38 <lambdabot> product = foldl (*) 1
08:41:40 <beelsebob|mini> ah, I see
08:41:40 <xerox> > [1..0]
08:41:42 <lambdabot>  []
08:41:42 <ehird> fac 0 = 1, fac n = product [1..n] <-- very simple one
08:41:42 <lambdabot> xerox: You have 1 new message. '/msg lambdabot @messages' to read it.
08:41:45 <beelsebob|mini> it doesn't go down
08:41:46 <chessguy> ah
08:41:46 <ehird> fac 0 = 1, fac n = product [1..n] <-- very simple one, should work fine
08:41:47 <ehird> oops
08:41:57 <glguy> ehird: you don't need the fac 0 case
08:42:05 <ehird> i guess
08:42:14 <nmessenger> > [1,0..-20] -- you can make it go down, though
08:42:16 <lambdabot>   Not in scope: `..-'
08:42:19 <beelsebob|mini> that's somewhat nonintuative that you don't though
08:42:23 <fantasma> why dont you need the 0 case?
08:42:26 <nmessenger> > [1,0..(-20)] -- bleh
08:42:27 <lambdabot>  [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20]
08:42:29 <ehird> fantasma: cause it handles it itself
08:42:31 <beelsebob|mini> fantasma: becaue [1..0] is []
08:42:32 <ehird> [1..0] == []
08:42:38 <glguy> > product []
08:42:39 <fantasma> ohhh
08:42:39 <lambdabot>  1
08:42:40 <nmessenger> fantasma: the product of no numbers is defined as 1
08:42:46 <ehird> So:
08:42:50 <ehird> fac n = product [1..n]
08:42:54 <fantasma> > null * null
08:42:55 <lambdabot>   add an instance declaration for (Num ([a] -> Bool))
08:42:56 <lambdabot>     In the expression: ...
08:43:04 <glguy> negative number factorials shouldn't go to 1, however
08:43:05 <Cale> > 0^0
08:43:07 <lambdabot>  1
08:43:12 <sek> hah
08:43:14 <ehird> > let fac n = product [1..n] in fac 45
08:43:15 <lambdabot>  119622220865480194561963161495657715064383733760000000000
08:43:17 <beelsebob|mini> fantasma: null is a function that tests whether you have the empty list
08:43:34 <nmessenger> @src product
08:43:35 <lambdabot> product = foldl (*) 1
08:43:35 * fantasma is not used to functional programming
08:43:42 <ehird> fantasma: neither am i
08:43:44 <ehird> didn't stop me :P
08:43:50 <nmessenger> that uses a '1' for the fold bottom case
08:43:59 <quicksilver> length . sequence . tail . inits $ [1..n]
08:44:07 <quicksilver> let fac n = length . sequence . tail . inits $ [1..n] in fac 10
08:44:10 <quicksilver> > let fac n = length . sequence . tail . inits $ [1..n] in fac 10
08:44:11 <ehird> (i'd say a quine on the second day of learning is pretty good..)
08:44:15 <ehird> (but i'm biased)
08:44:32 <ehird> @src foldl
08:44:33 <lambdabot> foldl f z xs = lgo z xs
08:44:33 <lambdabot>     where lgo z []     =  z
08:44:33 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
08:44:36 <Cale> The show function makes quines much simpler to write.
08:44:36 <ehird> @src foldr
08:44:37 <lambdabot> foldr k z xs = go xs
08:44:37 <lambdabot>     where go []     = z
08:44:37 <lambdabot>           go (y:ys) = y `k` go ys
08:44:40 <ehird> Cale: indeed
08:44:52 <ehird> @src go
08:44:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:44:55 <ehird> :(
08:44:57 <nmessenger> someone wrote a quite without show?
08:45:00 <Cale> ehird: go is defined in the where
08:45:04 <glguy> > let doublefactorial n = product [n,n-2..1] in map doublefactorial [0..9]
08:45:04 <quicksilver> > let fac n = length . sequence . tail . inits $ [1..n] in fac 5
08:45:05 <lambdabot>  [1,1,2,3,8,15,48,105,384,945]
08:45:06 <ehird> aha
08:45:13 <quicksilver> > 1+1
08:45:15 <lambdabot>  2
08:45:24 <quicksilver> > let fac n = length . sequence . tail . inits $ [1..n] in fac 3
08:45:30 <Cale> > foldr (\x xs -> concat ["(f ",show x," ",xs,")"]) "z" [1..5]
08:45:32 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
08:45:33 * quicksilver growls at lambdabot 
08:45:46 * beelsebob|mini pokes lambdabot in the spleens
08:45:53 <nmessenger> > let fac n = length . sequence . tail . inits $ [1..n] in fac 3
08:45:55 <ehird> isn't there a factorial func in the stdlib?
08:45:56 <Cale> > foldl (\y x -> concat ["(f ",y," ",show x,")"]) "z" [1..5]
08:45:57 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
08:46:04 <ehird> it looks like lisp
08:46:04 <quicksilver> > length . sequence . tail . inits $ [1..3]
08:46:26 <quicksilver> > inits [1..3]
08:46:27 <lambdabot>  [[],[1],[1,2],[1,2,3]]
08:46:32 * ehird tries to write quine without show
08:46:36 <ehird> @src show
08:46:36 <lambdabot> show x = shows x ""
08:46:39 <nmessenger> ehird: unfortunately, the parens are just for grouping.  They're not actually lists of anything.
08:46:39 <quicksilver> > length . sequence . tail . inits $ [1..3]
08:46:47 <ehird> @src shows
08:46:48 <lambdabot> Source not found. Do you think like you type?
08:46:50 <Cale> ehird: no factorial, not sure why. It's pretty simple though.
08:46:51 <glguy> > let multifactorial d n = product [n,n-d..1] in map multifactorial 3 [0..9]
08:46:52 <lambdabot>  Couldn't match expected type `[t1] -> t'
08:46:57 <quicksilver> > sequence . tail . inits $ [1..3]
08:47:04 <glguy> > let multifactorial d n = product [n,n-d..1] in multifactorial 3 `map` [0..9]
08:47:05 <lambdabot>  [1,1,2,3,4,10,18,28,80,162]
08:47:07 <Cale> > let fac = product . enumFromTo 1 in fac 5
08:47:08 <lambdabot>  120
08:47:29 <nmessenger> ehird: you want to see lispy? :)  http://paste.lisp.org/display/33494
08:47:41 <ehird> wow
08:47:43 <quicksilver> > tail . inits $ [1..3]
08:47:43 <ehird> Wow.
08:47:43 * beelsebob|mini slaps nmessenger with a large hammer
08:47:44 <lambdabot>  [[1],[1,2],[1,2,3]]
08:47:52 <quicksilver> > sequence [[1,2],[3,4]]
08:47:59 <quicksilver> :t sequence
08:48:02 <lambdabot>     Ambiguous occurrence `sequence'
08:48:02 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
08:48:09 <quicksilver> ah is that the problem?
08:48:18 <beelsebob|mini> nmessenger: not lispy enough - I don't see any car or cdr in there
08:48:22 <quicksilver> > Control.Monad.sequence [[1,2],[3,4]]
08:48:23 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
08:48:31 <nmessenger> quicksilver: should at least show the error though :/
08:48:41 <ehird> how do you do multiple lets in lambdabot again?
08:48:50 <bd_> > let x = 1; y = 2 in x + y
08:48:50 <glguy> let a = b; c = d
08:48:51 <lambdabot>  3
08:49:05 <quicksilver> ehird: there is notthing special about lambdabot
08:49:09 <nmessenger> > let x = sequence in x
08:49:09 <ehird> well, you know
08:49:10 <ehird> in one line
08:49:14 * quicksilver nods
08:49:16 <quicksilver> separate with ;
08:49:22 <quicksilver> group with {} if necessary
08:49:44 <ehird> > let car = fst; \' x = x  in (car '(1, 2))
08:49:45 <lambdabot>  Parse error
08:49:47 <ehird> bah
08:49:50 <ehird> no assigning to ' :P
08:49:51 <nmessenger> ehird: in ordinary haskell you'd use the layout rule to define multiple names in a let, the layout inserts the ';'s for you.
08:50:00 <ehird> nmessenger: yes.
08:50:08 <nmessenger> car = head, cdr = tail
08:50:17 <ehird> yes, but that stops me from using ()
08:50:23 <nmessenger> nil = []
08:50:24 <quicksilver> ehird: the report is very precise about which chars are lexed as operators and which are not
08:50:34 <ehird> > let car = fst; '(1 2) = (1, 2)  in (car '(1 2))
08:50:35 <lambdabot>  Improperly terminated character constant
08:50:44 <ehird> > let car = fst; (1 2) = (1, 2)  in (car (1 2))
08:50:44 <lambdabot>  Parse error in pattern
08:50:54 <quicksilver> ehird: ' and " and [,] and (,) are all 'special'
08:50:58 <bd_> 1 is not a function :)
08:51:04 <nmessenger> > let cons = (:); nil = [] in (cons 1 (cons 2 (cons 3 nil)))
08:51:06 <lambdabot>  [1,2,3]
08:51:14 <quicksilver> ehird: most other punctuation chars are allowed, except '=' on its own
08:51:18 <ehird> > let (a b) = (a, b) in (1 2)
08:51:18 <lambdabot>  Parse error in pattern
08:51:23 <ehird> > let _(a b) = (a, b) in (1 2)
08:51:23 <lambdabot>  Parse error in pattern
08:51:24 <nrb23> @src fixedWidth
08:51:25 <lambdabot> Source not found. My mind is going. I can feel it.
08:51:28 <xerox> :kind 1
08:51:37 <quicksilver> ehird: any symbol beginning with : is a constructor, otherwise it's a symbol. '::' is special though
08:51:37 <ehird> > let ' a b = (a, b) in '(1 2)
08:51:38 <nmessenger> @kind ()
08:51:38 <lambdabot>  Improperly terminated character constant
08:51:41 <lambdabot> *
08:51:42 <nrb23> oh well, off to work
08:51:43 <ehird> blaw
08:51:50 <ehird> > let x = 4 in 4 = x
08:51:50 <lambdabot>  Parse error
08:51:57 <ehird> > let -1 = -3
08:51:58 <lambdabot>  Parse error
08:52:09 <nmessenger> > let 1 + 1 = 5 in 1 + 1
08:52:11 <lambdabot>  5
08:52:14 <bd_> ehird: (f g) will always be f g. If f is a number, you'll have problems. Inless you declared an instance Num (a -> b) where ... :)
08:52:44 <nmessenger> > let 1 + 1 = 5; x + y = x Prelude.+ y in 3 + 2
08:52:46 <lambdabot>  5
08:53:42 <ehird> > let x = "let x = " in putStrLn $ x ++ show x
08:53:44 <lambdabot>  <IO ()>
08:53:47 <ehird> > let x = "let x = " in x ++ show x
08:53:48 <lambdabot>  "let x = \"let x = \""
08:54:25 <nmessenger> > fix (("let x = " ++) . show)
08:54:27 <lambdabot>  "let x = \"let x = \\\"let x = \\\\\\\"let x = \\\\\\\\\\\\\\\"let x = \\\\\...
08:54:30 <ehird> > let x = "let x = "; a = "in x ++ show x"; in x ++ show x ++ "; a = \"in x ++ show x;\"" ++ x
08:54:32 <lambdabot>  "let x = \"let x = \"; a = \"in x ++ show x;\"let x = "
08:54:33 <ehird> > let x = "let x = "; a = "in x ++ show x"; in x ++ show x ++ "; a = \"in x ++ show x;\"" ++ a
08:54:35 <lambdabot>  "let x = \"let x = \"; a = \"in x ++ show x;\"in x ++ show x"
08:54:50 <bd_> > fix show
08:54:52 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
08:54:53 <ehird> > let x = "let x = "; a = "in x ++ show x\" ++ a"; in x ++ show x ++ "; a = \"in x ++ show x;\"" ++ a
08:54:55 <lambdabot>  "let x = \"let x = \"; a = \"in x ++ show x;\"in x ++ show x\" ++ a"
08:54:56 <ehird> forget it
08:55:57 <beelsebob|mini> what are you trying to do?
08:56:02 <ehird> lambdabot quine
08:57:13 <beelsebob|mini> heh
08:57:19 <nmessenger> @let quine = putStr "> quine"
08:57:22 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
08:57:55 <glguy> that's been broken for a while,  Iwonder if it is intentionally being left alone
08:58:17 <nmessenger> I doubt that.  dons has just seemed busy.
08:58:55 <ehird> let x = head $ ":[]":[] in putStrLn (show x ++ x)
08:58:57 <ehird> :D
08:59:02 <allbery_b> dons has been working on his new toy, so LB is a bit unloved at present
08:59:14 <quicksilver> lambdabot: we love you still
08:59:40 <nmessenger> @botsnack
08:59:41 <lambdabot> :)
09:00:01 <glguy> > map concat $ mapM (([]:).(:[]).(:[])) [1..3]
09:00:16 <mauke> mapM is borked, try Control.Monad.mapM
09:00:21 <nmessenger> qualify mapM
09:00:26 <glguy> > map concat $ Control.Monad.mapM (([]:).(:[]).(:[])) [1..3]
09:00:27 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
09:00:49 <quicksilver> what is in Control.Monad.Writer which is hiding them? Why does it have conflicting defns?
09:00:54 <beelsebob|mini> > let o = (\x . x x) (\x . x x) in o
09:00:54 <lambdabot>  Parse error
09:00:57 <beelsebob|mini> bah
09:01:05 <nmessenger> @where imports
09:01:05 <lambdabot> I know nothing about imports.
09:01:07 <mauke> @index mapM
09:01:08 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:01:09 <beelsebob|mini> > let o = (\x -> x x) (\x -> x x) in o
09:01:10 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
09:01:10 <lambdabot>     Probab...
09:01:14 <beelsebob|mini> bah
09:01:14 <mauke> hmm
09:01:21 <apfelmus> Cale: ah, there's something I wanted to ask. do you know another example where a composition f . g has less asymptotic complexity than g due to laziness? i think there was something with inits . tails but i don't know anymore
09:01:46 <fantasma> how many digits does the 50th fibonacci number have?
09:01:47 <apfelmus> one example is (head . mergesort)
09:01:48 <quicksilver> apfelmus: any number of trivial cases where most of the result of g is ignored
09:01:59 <quicksilver> apfelmus: are you looking for something deeper?
09:02:15 <apfelmus> quicksilver: yeah, i mean something deeper :)
09:02:23 <quicksilver> apfelmus: g could be 'flatten'
09:02:23 <ehird> let a = "x = "; x = "in putStrLn (\"let a = \" ++ show a ++ \"; \" ++ a ++ show x ++ \" \" ++ x)" in putStrLn ("let a = " ++ show a ++ "; " ++ a ++ show x ++ " " ++ x)      <-- ghci quine! yay
09:02:28 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 50
09:02:30 <lambdabot>  20365011074
09:02:31 <quicksilver> apfelmus: then if f doesn't demand all the elements...
09:02:34 <beelsebob|mini> > let fibs x y = x:(fibs y (x + y)) in fibs 1 1 !! 50
09:02:34 <apfelmus> :t flatten
09:02:36 <ehird> :D
09:02:38 <lambdabot>  20365011074
09:02:38 <lambdabot> forall a. Tree a -> [a]
09:02:41 <chessguy> fantasma, ^^
09:02:45 <quicksilver> apfelmus: this is roughlyt the generalisation of your mergesort example
09:02:51 <fantasma> chessguy, that's the number of digits?
09:02:54 <beelsebob|mini> chessguy: my deff is nicer
09:02:58 <beelsebob|mini> fantasma: no, that's fib 50
09:03:03 <chessguy> fantasma, no, that's the 50th one
09:03:08 <glguy> fantasma: no, but he wants you to use your finger and count them :)
09:03:08 <fantasma> hmmmm
09:03:14 <quicksilver> apfelmus: I meant flatten generically, as in flatten : BigType a -> [a]
09:03:19 <nmessenger> > let fac = 1 : 1 : zipWith (+) fac (tail fac); x = fac !! 50 in length show x
09:03:20 <fantasma> mine crashed in fib 50
09:03:20 <lambdabot>  Couldn't match expected type `[a]'
09:03:27 <chessguy> beelsebob|mini, why would you want to have to specify the first two numbers?
09:03:27 <ehird> fantasma: what's your fib
09:03:37 <ehird> func
09:03:38 <quicksilver> apfelmus: consider breath-first flatten, when you think you will find what you need in the top few levels
09:03:38 <glguy> fantasma: don't write an exponential definition
09:03:41 <beelsebob|mini> chessguy: because fibs 1 1 is not the only interesting sequence
09:03:43 <nmessenger> geh, fac/fib confusion again
09:03:43 <quicksilver> apfelmus: then most of g will not be needed
09:03:51 * nmessenger bangs self on head
09:03:54 <quicksilver> apfelmus: like a chess-playing checkmate finder, perhaps
09:04:02 <fantasma> glguy, the def is "fib n = fib(n-1) + fib(n-2)"
09:04:05 <chessguy> quicksilver, hmm?
09:04:08 <chessguy> did someone say chess?
09:04:11 <beelsebob|mini> fantasma: yours has exponential complexity
09:04:11 <glguy> fantasma: right, that's the wrong way to go about it
09:04:16 <beelsebob|mini> ours have linear complexity
09:04:22 <glguy> > 2 ^ 41
09:04:23 <lambdabot>  2199023255552
09:04:24 <glguy> > 2 ^ 51
09:04:25 <lambdabot>  2251799813685248
09:04:32 <mauke> > let q = "> let q = %s in printf q (show q) :: String" in printf q (show q) :: String
09:04:34 <lambdabot>  "> let q = \"> let q = %s in printf q (show q) :: String\" in printf q (show...
09:04:35 <glguy> fantasma: you'll have that many functio ncalls
09:04:45 <chessguy> beelsebob|mini, whatever. my implementation is the canonical fibs example in haskell
09:05:08 <nmessenger> mauke++
09:05:09 <fantasma> how should it be done then
09:05:16 <apfelmus> quicksilver: yes, kind of. taking g = head is fine, but the point about f is that it should do some "real" calculation. i mean, breath first flattening simply copies what's already there
09:05:17 <beelsebob|mini> chessguy: actually, I've seen mine a lot more often than your
09:06:09 <glguy> fantasma: you need to be sure to reuse previous computations
09:06:12 <chessguy> whatever
09:06:20 <glguy> fantasma: the traditional haskell way is with a lazy list
09:06:28 <ehird> is using -fglasgow-exts disacouraged?
09:06:39 <beelsebob|mini> ehird: yes
09:06:46 <mauke> beelsebob|mini: whoa, why?
09:06:48 <apfelmus> quicksilver: i.e. with flattening, head . f is likely to take O(1) or so.
09:06:50 <beelsebob|mini> you don't know what you're gonna get
09:06:55 <ehird> beelsebob|mini: uh, what
09:06:56 <glguy> chessguy: you'll save yourself the trouble if you just ignore him
09:07:02 <chessguy> glguy, apparently so
09:07:08 <nmessenger> ehird: you'd like to do all you can in H98, but most people do use -fglasgow-exts
09:07:13 <chessguy> two ridiculous statements in a row
09:07:16 <nmessenger> for some problems
09:07:32 <ehird> it's just that hugs has something too, letting you do:
09:07:34 <allbery_b> well, there is the argument that using the more fine-grained options is preferable to the -fglasgow-exts sledgehammer
09:07:39 <ehird> myfunc (typesig) = blah
09:07:42 <allbery_b> but there are some things that you can't get at that way
09:07:43 * nmessenger quietly mentions that he's seen the zipWith example a lot, too
09:07:46 <glguy> allbery_b: I like that song
09:07:47 <ehird> instead of typesig\nmyfunc = blah
09:07:54 <beelsebob|mini> ehird: most people use it, but in general you can do everything you need in H98, and using glasgow extents just means that if the two simons go under a bus you're screwed
09:08:12 <xerox> ehird: <name> <args> = <expr> :: <type>
09:08:18 <allbery_b> er.  haskell' is standardizing most of -fglasgow-exts
09:08:28 <apfelmus> i think there was something like inits . tails or isSubstring = any isPrefixOf . tails.
09:08:29 <apfelmus> Cale?
09:08:33 <beelsebob|mini> allbery_b: no, Haskell' is standardizing a small subset of glasgow exts
09:08:35 <allbery_b> and I think ghc will survive the simons
09:08:38 <glguy> ?where stats
09:08:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
09:08:48 <beelsebob|mini> and I would have no problem with using standard Haskell'
09:08:49 <nmessenger> @src isInfixOf
09:08:50 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
09:08:53 <beelsebob|mini> (although there's no standard yet)
09:08:54 <mauke> beelsebob|mini: I need hierarchical modules. those aren't H98
09:09:15 <beelsebob|mini> mauke: you don't *need* them -- but I do agree that they're very very nice
09:09:25 <mauke> I also need Control.Monad.*
09:09:46 <glguy> beelsebob|mini: Being a constant troll is a way to earn a spot need to palomer
09:09:50 <glguy> next*
09:09:58 <emu> is there a way to get at some of those extensions grouped under -fglasgow-exts individually?
09:10:18 <mauke> yes, e.g. -fffi enables just the FFI stuff
09:10:22 <beelsebob|mini> glguy: considering a the standard to be a better option to the non-defined version that contains whatever the two simons chose is not trolling
09:10:24 <nmessenger> glguy: eh?  My trollometer hasn't gone off yet.
09:10:43 <beelsebob|mini> I agree that the two simons have done nice things
09:10:47 <mauke> beelsebob|mini: but it's not entirely sane either
09:10:49 <beelsebob|mini> but using the standard has huge benefits
09:10:50 <ehird> let search needle haystack = map (\i -> i == needle) haystack <-- I just wrote this even though I don't need it, to see if i rewrote the standard lib
09:10:51 <ehird> Did I? :P
09:11:19 <pitecus> is there an implementation of tries in the haskell libraries?
09:11:31 <mauke> ehird: whoa, why do you need a list of bools?
09:11:32 <nmessenger> ehird: that'd give you a list of Bool, where Trues are places the needle is at.
09:11:37 <ehird> mauke: no idea
09:11:37 <mauke> @hoogle trie
09:11:38 <lambdabot> Test.HUnit.Base.tried :: Counts -> Int
09:11:40 <ehird> nmessenger: yes, it would
09:11:42 <ehird> i just wrote it for fun :P
09:11:44 <emu> mauke: yea that's one. but multi-param typeclasses, existential types, etc?
09:11:45 <nmessenger> @src find
09:11:46 <lambdabot> find p          = listToMaybe . filter p
09:11:51 <mauke> emu: dunno
09:11:51 <ehird> well...that's faster.
09:12:04 <mauke> @src elem
09:12:05 <lambdabot> elem x    =  any (== x)
09:12:09 <emu> those 2 in particular, i think, they should be in haskell'
09:12:14 <apfelmus> ehird: needle `elem` haystack = any (needle ==) haystack
09:12:26 <beelsebob|mini> emu: I don't remember - have MPTCs actually been decided on?
09:12:38 <beelsebob|mini> last I heard they couldn't decide what to do with FDs
09:12:43 <emu> hm
09:12:51 <nmessenger> @src any
09:12:51 <lambdabot> any p =  or . map p
09:12:58 <nmessenger> @src or
09:12:58 <lambdabot> or    =  foldr (||) False
09:13:24 <apfelmus> beelsebob|mini: i don't know exactly, but i think they're waiting on associated types to go into the next ghc release
09:14:15 <ehird> /= isn't definable :(
09:14:18 <nmessenger> ehird: though (\x -> x == needle) can be written as a section: (== needle)
09:14:29 <nmessenger> ehird: in what context
09:14:34 <mauke> ehird: what do you mean?
09:14:38 <ehird> (/=) = False
09:14:40 <ehird> oh, oops
09:14:48 <ehird> forgot the let
09:14:51 <ehird> (in ghci)
09:14:53 <nmessenger> @src Bool (/=)
09:14:54 <lambdabot> Source not found. Take a stress pill and think things over.
09:14:56 <jfoutz> any is a really sneaky definition. lazy is ... hard to come to grips with
09:14:56 <mauke> wha?
09:15:08 <mauke> ehird: why do you want to override (/=)?
09:15:19 <ehird> mauke: because, languages are made to be broken
09:15:23 <nmessenger> heh
09:15:25 <beelsebob|mini> ehird: re my original statement -- I frown upon using the glasgow exts, thus, yes, -fglasgow-exts is frowned upon
09:15:29 <pitecus> i guess that means no tries
09:15:35 <beelsebob|mini> whether it is by the majority or not is a different question
09:16:03 <nmessenger> but "is frowned upon" in general implies "by the majority"
09:16:28 <beelsebob|mini> nmessenger: one of my particular pedantries is that I always try to answer the question asked, not the question implied
09:16:39 <beelsebob|mini> ask what you meant to ask and you should get an accurate answer
09:16:39 <mauke> using spaces for indentation is frowned upon
09:16:42 <nmessenger> gotcha, no harm no foul
09:16:51 <mauke> tabs are preferred
09:16:52 <ehird> \x c <-- what does this do?
09:17:02 <nmessenger> \x -> \c -> ...
09:17:02 <mauke> ehird: same thing as \x -> \c
09:17:04 <kc5tja> mauke: Damn, you beat me to the punch.  :-)
09:17:07 <beelsebob|mini> ehird: it creates a lambda expression with two arguments
09:17:22 <kc5tja> (however, I'm a pro-space guy, learned from all the issues encountered over the years with Python coding)
09:17:45 <ehird> count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l <-- ok i don't get this
09:17:45 <mauke> I use tabs only
09:17:46 <beelsebob|mini> yeh - python is nasty that way
09:17:50 <beelsebob|mini> no, use space only
09:17:53 <beelsebob|mini> :P
09:17:55 <mauke> beelsebob|mini: why?
09:17:58 <beelsebob|mini> I'm very pro space and anti-tab
09:18:02 <ehird> mauke: i like tabs. but i guess they kinda suck with layout
09:18:08 <mauke> ehird: works for me
09:18:19 <beelsebob|mini> mauke: because using tabs breaks when someone's editor indents them by a different amount
09:18:20 <ehird> especially because i use 4-space tabs when using tabs
09:18:28 <beelsebob|mini> you have to guess what the original coder's editor was set ot
09:18:29 <beelsebob|mini> to*
09:18:34 <ehird> beelsebob|mini: hee, no, they are more robust than spaces in that area
09:18:34 <quicksilver> there is an elegant solution involving a mixture of spaces and tabs
09:18:35 <mauke> beelsebob|mini: how does that break anything?
09:18:36 <glguy> ehird: with Haskell code, you have to use 8-space tabs
09:18:38 <ehird> quicksilver: yes
09:18:38 <mauke> ehird: me too :-)
09:18:40 <nmessenger> ehird: c is the count held on the right of the fold, the lamda is the function stuck between each element.
09:18:42 <ehird> tabs until first non-whitespace
09:18:44 <mauke> glguy: no, I don't
09:18:44 <quicksilver> unfortunately, it requires editor support
09:18:46 <ehird> then whitespace after
09:18:52 <quicksilver> and editors don't have it :)
09:19:06 <ehird> nmessenger: that doesn't really help... what is c passed as by fold
09:19:07 <ehird> r
09:19:09 <beelsebob|mini> mauke... suppose you have jam\t= 5\n hamm\t=5
09:19:16 <beelsebob|mini> that lays out nicely on something with tab width set to 8
09:19:20 <ehird> ah i see.
09:19:21 <mauke> ehird: c is the accumulator, initially 0
09:19:24 <beelsebob|mini> but not on something with tab width set oto 4
09:19:38 <ehird> is there a benchmarking thing in prelude?
09:19:41 <mauke> beelsebob|mini: so don't do that, duh
09:19:44 <jfoutz> > \x y -> x+ y $ 1 2
09:19:45 <lambdabot>   add an instance declaration for (Num (t -> a))
09:19:49 <ehird> like, benchmark 500 myFunc
09:19:55 <beelsebob|mini> mauke: problem is - 99% of coders like to line up definitions like that
09:19:57 <ehird> would call myFunc 500 times then print stats
09:20:03 <nmessenger> ehird: it starts as zero (because 0 is the second arg to foldr), and it is increased-or-not each time the lambda is invoked
09:20:03 <mauke> beelsebob|mini: they can use spaces
09:20:13 <beelsebob|mini> mauke: hence why I'm a space man - not a tab man
09:20:17 <glguy> mauke: the point was the ghc reads your tab as 8 spaces
09:20:21 <mauke> beelsebob|mini: but that's not indentation
09:20:32 <glguy> mauke: but if you use them highly consistently, you wouldn't notice the difference
09:20:37 <nmessenger> ehird: (re: tabs) that's sensible enough, but beware tabs-are-evil pundits :)
09:20:38 <mauke> glguy: irrelevant, my tabs are "variable width" :-)
09:20:40 <beelsebob|mini> mauke: no, but when you start getting spaces and tabs mixed up in a file you end up with really really weird erros
09:20:50 <beelsebob|mini> errors*
09:20:54 <kc5tja> The problem with any applicative language is that you tend to indent multiple times in a single definition.
09:20:56 <mauke> beelsebob|mini: that's never happened to me
09:21:04 <a-oXiDe> hi, im new to haskell and trying to work out the syntax for a function.  i have made a function that goes mg a (b,c) = get3 (row a b) (b,c) but i want 'b' to increment 3 times and was thinking list recursion eg [d | d <- [0..2] but dont exactly know where to put it in my function
09:21:05 <kc5tja> So, an 8-space tab becomes _incredibly_ wasteful of screen space.
09:21:09 <ehird> kc5tja: yeah.
09:21:11 <ehird> i like 4-space tabs.
09:21:15 <kc5tja> Thus, why all the 2- 3- 4- ... space tabs came about.
09:21:19 <ehird> but unix tools dont interpret t that way
09:21:21 <beelsebob|mini> mauke: unfortunately - it's happened to me many times, it usually happens when you get several programmers working on the same code
09:21:25 <ehird> so it doesn't work
09:21:30 <mauke> beelsebob|mini: kill them
09:21:35 <ehird> anyway, anyone?
09:21:36 <glguy> In vim I use 8-space tabs with 2-space softtabs
09:21:37 <beelsebob|mini> mauke: I wish that were a solution
09:21:48 <kc5tja> That's why I use tab-expansion in my editor.  I physically do use the tab key; but it's encoded as spaces.
09:21:48 <Botje> a-oXiDe: what do you want to do with the resulting list?
09:21:52 <mauke> glguy: eww
09:21:57 <beelsebob|mini> but unfortunately for you and I, always using spaces is a solution that doesn't involve murder
09:22:07 <a-oXiDe> just basically have a list of the values
09:22:08 <mauke> glguy: I don't want to touch your code, ever
09:22:14 <glguy> mauke: excellent!
09:22:15 <kc5tja> mauke: Your loss.
09:22:20 <nmessenger> a-oXiDe: [d | d <- [0..2]] equals [0..2]
09:22:31 <mauke> seriously, mixing spaces and tabs is evil
09:22:34 <fantasma> is fac supposed to be undefined for negative numbers?
09:22:35 <astrolabe> ehird: I don't know of benchmarking like that, but look at chapter 5 of the ghc user guide.
09:22:35 <beelsebob|mini> indeed it is
09:22:37 <nmessenger> a-oXiDe: what exactly did you want to repeat in the above definition?
09:22:40 <glguy> fantasma: yes
09:22:40 <beelsebob|mini> mauke: that's my point
09:22:50 <kc5tja> mauke: Definitely in agreement on that one.
09:22:51 <jfoutz> beelsebob|mini, :%s/^V^I/    /g maybe?
09:22:54 <beelsebob|mini> mauke: mixing them is bad, and using tabs in certain places is bad - therefore always use spaces
09:23:13 <a-oXiDe> well basically the b for the get3 function so it increments and does it 3 times
09:23:19 <beelsebob|mini> jfoutz: not quite - because a tab is not four spaces, it's anything *up to* four spaces to the next tab stop
09:23:20 <fantasma> do I need a guard to make it undefined for negatives or is there a way to do that with pattern matching?
09:23:20 <mauke> beelsebob|mini: or I can always use tabs for indentation
09:23:30 <a-oXiDe> so dont know where to put the list recursion or how to implement it
09:23:33 <mauke> a-oXiDe: "increments"?
09:23:39 <beelsebob|mini> mauke: no, because tabs don't always layout nicely
09:23:39 <nmessenger> a-oXiDe: er, you could use b, (b+1) and (b+2)?
09:23:57 <beelsebob|mini> I have my editor set to replace all tabs with spaces to the next tab stop
09:23:59 <mauke> beelsebob|mini: how so?
09:24:03 <glguy> tabs are explicitly define in Haskell, so as long as you edit haskell code using the given definition for tabs, there can be no issue
09:24:19 <mauke> glguy: yes, there can. my tabs are 4 spaces wide.
09:24:22 <beelsebob|mini> glguy: sure, that's fine - but personally - 8 spaces per tabs stop is *nasty*
09:24:24 <glguy> Haskell': http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/syntax-iso.html -- "Tab stops are 8 characters apart. "
09:24:27 <lambdabot> Title: Haskell 98 Syntax, http://tinyurl.com/2wyqlm
09:24:37 <glguy> beelsebob|mini: talk to someone with a say in the language defintion
09:24:51 <beelsebob|mini> glguy: I'll just stick to always using spaces thanks :)
09:24:52 <jfoutz> i see. how about not using layouts? it is optional. and maybe worth abandoning if it's causing that much frustration.
09:25:02 <a-oXiDe> yeah i was thinking b, b+1 but it doesnt look too tidy
09:25:04 <mauke> just because there is a feature in the language doesn't mean you have to (ab-)use it
09:25:16 <fantasma> do I need a guard to make it undefined for negatives or is there a way to do that with pattern matching?
09:25:22 <ehird> <3 <3 yaht
09:25:28 <nmessenger> a-oXiDe: meh, it says what it means pretty clearly.
09:25:28 <quicksilver> fantasma: if you just miss it out
09:25:29 <ehird> it's brilliant
09:25:32 <quicksilver> fantasma: then it's undefined
09:25:47 <mauke> a-oXiDe: map (\i -> get3 (row a (b+i)) (b+i, c)) [0..2]?
09:25:53 <astrolabe> ehird: good!
09:25:53 <beelsebob|mini> f 1 = 2 -- this function is undefined for all non-1 values
09:25:56 <fantasma> quicksilver, this is my fac: fac n = product [1..n
09:26:04 <fantasma> close ]
09:26:06 <ehird> already i can't imagine going back to another language
09:26:13 <quicksilver> then you want a guard, yes
09:26:16 <quicksilver> or an if statement
09:26:18 <ehird> it just wouldn't be right
09:26:36 <fantasma> so there is no other way to do it?
09:26:37 <quicksilver> fac n = if n >= 0 then product [1..n] else error "negative factorial"
09:26:39 <astrolabe> ehird: it isn't pleasant, but I find I have to sometimes
09:26:42 * nmessenger hugs ehird
09:26:47 <ehird> :p
09:27:02 <nmessenger> welcome to the cult.  Have some koolaid.
09:27:18 <a-oXiDe> yeah thats the kinda thing i want mauke
09:28:27 <a-oXiDe> altho i need to read up on lambda's a bit more, im a bit confused how they work
09:28:40 <chessguy> ?remember nmessenger welcome to the cult. Have some koolaid
09:28:40 <lambdabot> Done.
09:28:44 <beelsebob|mini> a-oXiDe: all they are are functions with no names
09:28:52 --- mode: ChanServ set +o glguy
09:28:56 --- kick: glguy was kicked by glguy (fuck this)
09:29:01 <mauke> a-oXiDe: they're function literals
09:29:06 <a-oXiDe> how does the \i apply to it?
09:29:10 <nmessenger> double x = x + x is equivalent to double = \x -> x + x
09:29:11 <mauke> \ is lambda
09:29:14 <mauke> i is the parameter
09:29:26 <quicksilver> > (\x -> x + 1) 3
09:29:26 <chessguy> hmm
09:29:28 <lambdabot>  4
09:29:30 <mauke> (\p -> B) is a function with parameter p and body B
09:29:34 <beelsebob|mini> the thing or the right of the -> is the expression to which it evaluates
09:29:42 <nmessenger> (\n -> n + 2) is an unnamed function that takes an argument and adds two to it.
09:30:17 <mauke> a-oXiDe: (you don't happen to know perl, do you?)
09:30:26 <a-oXiDe> ah ok, cheers and nah i dont sorry?
09:30:26 <beelsebob|mini> f = (\n -> n + 2) <-- equivalent to f n = n + 2
09:30:50 <mauke> certain parts of haskell are easier to explain if you know Perl :-)
09:30:51 <nmessenger> > (\n -> n + 2) 5
09:30:53 <lambdabot>  7
09:31:20 <nmessenger> > let f n = n + 2 in f 5
09:31:22 <lambdabot>  7
09:32:04 <chessguy> xerox, ping
09:32:21 <mauke> > (\f x -> x + f x) sqrt 2
09:32:23 <lambdabot>  3.414213562373095
09:32:29 <mauke> pi!
09:32:35 <nmessenger> eh?
09:32:38 <beelsebob|mini> uhh... no
09:32:42 <jfoutz> > 22/7
09:32:44 <lambdabot>  3.142857142857143
09:32:46 <jfoutz> pi!
09:32:54 <ehird> has anyone coded a lambda calculus interpreter? that'd be a literally pure functional language :P
09:32:58 <mauke> > 355/113
09:33:00 <lambdabot>  3.1415929203539825
09:33:04 <jfoutz> ooooo
09:33:04 <quicksilver> ehird: very many people, yes
09:33:07 <ehird> hah
09:33:15 <quicksilver> ehird: haskell is 'literally pure' too
09:33:18 <chessguy> ehird, haskell is pretty much a layer over LC
09:33:25 <ehird> quicksilver: well, no, you can do IO
09:33:30 <quicksilver> ehird: but, in a pure way
09:33:36 <ehird> == not pure, just the purest of the useful languages
09:33:39 <romildo> Hi.
09:33:48 <quicksilver> ehird: I disagree. It's pure.
09:33:57 <quicksilver> ehird: It has referential transparency.
09:34:02 <ehird> quicksilver: a completely pure language would be useless
09:34:06 <ddarius> Asking "Has anyone coded a lambda calculus interpreter?" on #haskell.  Priceless.
09:34:06 <ehird> utterly useless
09:34:17 <chessguy> ddarius, indeed
09:34:27 <mauke> btw, I've done that
09:34:27 <ehird> ddarius: well, haskell does have quite a few more constructs :P
09:34:28 <mauke> in Java
09:34:30 <nmessenger> ehird: whether Haskell's IO is pure or not is debated a lot.  It makes sense to me that it is.
09:34:31 <quicksilver> (actually the failings in haskell's purity are not to do with IO, they're to do with undefined)
09:34:31 <jfoutz> ehird, what are the side effects of algebra?
09:34:37 <ehird> in JAVA? mauke, i hate you
09:34:39 <jfoutz> are you saying algebra is useless?
09:34:40 <ehird> that has to be a crime
09:34:51 <quicksilver> ehird: haskell is completely pure, and yet has IO. Go figure. :)
09:34:52 <ehird> jfoutz: algebra wouldn't be a very good programming language
09:34:57 <quicksilver> and I would say it isn't useless.
09:34:57 <ehird> would it now :)
09:35:10 <pjd> arguably, haskell doesn't have any IO
09:35:11 <mauke> ehird: it could create java objects and could call methods and stuff
09:35:19 <beelsebob|mini> quicksilver: depends on your definition of pure - after all IO doesn't *actually* carry around the whole world as it computes
09:35:25 <hpaste>  romildo pasted "using parsec " at http://hpaste.org/614
09:35:26 <beelsebob|mini> it just simulates what would happen if you did that
09:35:33 <quicksilver> beelsebob|mini: that's an implementation issue, not a language one though
09:35:35 <nmessenger> ehird: when you grok typeclasses more and are really comfortable with expressions and types, see:
09:35:37 <pjd> it just happens to have implementation that magically translate the (pure) IO monad into impure IO code
09:35:37 <nmessenger> @wiki IO_inside
09:35:38 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
09:35:39 <beelsebob|mini> true enough
09:35:44 <quicksilver> beelsebob|mini: you're talking about the way ghc does it
09:35:46 <pjd> "implementations", even
09:35:58 <ddarius> mauke: I've done it in Haskell, Javascript, Scheme, the lambda calculus and I'll probably do it in C# sometime in the near future.
09:36:01 <quicksilver> it's possible to imagine an implementation where the IO monad is basically a list of syscalls
09:36:05 * beelsebob|mini now wants a compiler that really does perform a function on the whole world
09:36:14 <quicksilver> which then get executed by some outer RTS later
09:36:17 <ehird> beelsebob|mini: heh
09:36:18 <romildo> Can anybody tell me what is wrong with the program using parsec? http://hpaste.org/614
09:36:23 <quicksilver> IIRC one version of the hugs IO monad did work like that, in fact
09:36:27 <quicksilver> (roughly like that)
09:36:28 <ehird> you'll need a bomb identifier
09:36:34 <ehird> and news channels on tv
09:36:47 <ehird> and a programming language that works in the real world
09:36:51 <ddarius> mauke: I've probably done it in other languages and, in particular, ones without HOFs but I can't remember. Ah, I think I've done it in Prolog.
09:37:03 <quicksilver> beelsebob|mini: this is a fascinating line of thought, because that way you invent a time machine and multiple timelines :)
09:37:09 <beelsebob|mini> romildo: what's err bound to in run?
09:37:10 <kc5tja> beelsebob|mini: cureAids :: IO ()
09:37:11 * ehird considers writing a pure-lambda-calculus interpreter in haskell once he's learned it fully
09:37:16 <nmessenger> beelsebob|mini: technically, if you alter the real world in some way (print a character, reading a file, sending a LaunchMissle hardware signal), you've updated the currently World value
09:37:24 <beelsebob|mini> kc5tja: roflcakes
09:37:36 <chessguy> ?hoogle missile
09:37:37 <lambdabot> No matches found
09:37:38 <quicksilver> ehird: it's actually quite an easy project
09:37:39 <chessguy> err
09:37:42 <chessguy> ?quote missle
09:37:42 <lambdabot> dons says: mm. It would be kinda fun to hook up the usb missle launcher to an unsafePerformIO.
09:37:43 <quicksilver> ehird: probably 200-300 lines of code
09:37:44 <chessguy> ?quote missile
09:37:45 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
09:37:50 <chessguy> there we go
09:37:54 <quicksilver> ehird: much less if you are deliberately trying to make it smaller
09:37:58 <nmessenger> we are all in the IO monad right now.  Haskell just allows you to write outside of it too.
09:38:04 <ehird> well, yes, of course
09:38:09 <beelsebob|mini> who has a suggestion of what to do with the front half of a salmon?
09:38:29 <kaol> what does it mean to have learnt Haskell fully?
09:38:32 <ehird> but i'd like to do it "pure"ly as possible
09:38:39 <mauke> if you want to see the code, it's at http://rafb.net/p/1lIiQJ76.html
09:38:39 <ehird> kaol: er. finish YAHT. :P
09:38:39 <ddarius> quicksilver: More like <50.  The actual core of it is about maybe 5 lines of code.  The parser is the hardest part.
09:38:41 <lambdabot> Title: Nopaste - No description
09:38:48 <jfoutz> nmessenger, prove it. demonstrate that the world i see isn't an updated copy of the world i was in a second ago
09:38:54 <fantasma> > let scanl (*) 1 [1..] !! 50
09:38:54 <lambdabot>  Parse error
09:39:11 <fantasma> > let fac = scanl (*) 1 [1..] !! 50
09:39:11 <lambdabot>  Parse error
09:39:15 <kc5tja> In regards to missle launching functions, apparently the US Government sponsored a programming contest, and Haskell was a *clear* winner, involving various war-games simulations.  So, . . .
09:39:15 <nmessenger> jfoutz: unfortunately I can't, you'd have to be able to reason from outside the universe.
09:39:18 <kaol> that sounds a bit like saying "learning math fully" ;-)
09:39:18 <beelsebob|mini> ehird: if you want to do something as "purely" as possible I would suggest that 90% programs need a two function IO wrapper and the rest can be written without a monad in sight
09:39:24 <ddarius> quicksilver: I had a pure Prolog interpreter that was <90 lines first cut and still is <350 with all it's (non-standard) libraries being counted as well.
09:39:28 <beelsebob|mini> it tends to make your programs have a very nice mathematical feel
09:39:28 <ehird> kaol: heh
09:39:29 <hpaste>  romildo annotated "using parsec " with "using parsec (reviewed)" at http://hpaste.org/614#a1
09:39:34 <jfoutz> nmessenger, i'd agree we're in a monad. :)
09:39:37 <chessguy> > let fac = scanl (*) [1..] !! 50 in fac
09:39:38 <lambdabot>  Couldn't match expected type `[a]'
09:39:38 <quicksilver> ddarius: right, but considering ehird has only been learning haskell for a day or two I didn't want to overegg the pudding :P
09:39:54 <fantasma> > let fac = scanl (*) 1 [1..] !! 20 in fac
09:39:55 <chessguy> > let fac = (scanl (*) [1..]) !! 50 in fac
09:39:55 <lambdabot>  2432902008176640000
09:39:56 <lambdabot>  Couldn't match expected type `[a]'
09:39:57 <romildo> It fails wit the messages:
09:39:59 <romildo> Couldn't match expected type `GenParser Char st'
09:39:59 <romildo>            against inferred type `(->) (TokenParser st1)'
09:39:59 <romildo>     Probable cause: `identifier' is applied to too few arguments
09:39:59 <romildo>     In a 'do' expression: id <- identifier
09:40:05 <chessguy> oh right
09:40:10 <quicksilver> beelsebob|mini: agh, not without a monad, no
09:40:10 <kc5tja> ehird: I finished YAHT, and I know virtually nothing of Haskell compared to others.
09:40:11 <beelsebob|mini> romildo: is err bound to in the definition of run?
09:40:17 <ddarius> quicksilver: You'd have to go out of your way to make it longer.
09:40:19 <fantasma> > let fac = scanl (*) 1 [1..] !! 50 in fac
09:40:20 <quicksilver> beelsebob|mini: without use of the IO monad, you mean
09:40:20 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
09:40:29 <quicksilver> ddarius: well depends if you put a type system in
09:40:39 <quicksilver> ddarius: I was admittedly thinking of simply types, with an inferrer
09:40:46 <beelsebob|mini> quicksilver: no, without the use of monads -- or rather with the use of datatypes that happen to be monads, but not using the monad functions
09:40:49 <romildo> beelsebob|mini: it is bound in pattern matching of the first alternative in the case.
09:41:01 <quicksilver> beelsebob|mini: you can certainly, but that doesn't mean you should
09:41:07 <quicksilver> beelsebob|mini: monads are a very handy idiom
09:41:13 <beelsebob|mini> romildo: oh, so it is -- sorry
09:41:19 <quicksilver> beelsebob|mini: especially for error handling
09:41:20 <ddarius> quicksilver: Inferring simple types would take about <20 lines more of code.
09:41:25 <beelsebob|mini> quicksilver: I have argued many times that you really really should
09:41:26 <quicksilver> but also for stateless computation
09:41:29 <ddarius> Most of that being an implementation of unification.
09:41:41 <beelsebob|mini> I've never found a real use for a monad other than IO yet
09:41:46 <quicksilver> ddarius: ah well, it took me 200, probably I'm bad at it
09:41:56 <beelsebob|mini> quicksilver: it may just be my brain works very mathematically
09:42:00 <quicksilver> ddarius: the parser was a big chunk of it
09:42:17 <quicksilver> beelsebob|mini: my brain also works very mathematically, and yet monads neatly encapsulate some very useful idioms
09:42:25 <quicksilver> beelsebob|mini: exceptional values/errors being one of the most common
09:42:30 <beelsebob|mini> quicksilver: my problem with monads is exactly taht actually
09:42:35 <ddarius> Yeah, the parser is usually the hardest and longest part of these things.  I often use a Scheme syntax and it still is.
09:42:37 <beelsebob|mini> they encapsulate lots of different idioms
09:42:41 <beelsebob|mini> and put them into syntax that is all the same
09:42:48 <nmessenger> monad = fmap + return + join.  join provides the magic sequencing in the IO monad.
09:42:49 <beelsebob|mini> they actually remove an abstarction layer
09:42:51 <beelsebob|mini> rather than adding one
09:42:59 <beelsebob|mini> they make code *harder* to understand
09:43:04 <beelsebob|mini> (in many cases)
09:43:12 <quicksilver> ddarius: and I did include some hard coded useful functions (operators)
09:43:33 <quicksilver> beelsebob|mini: hmm
09:43:55 <chessguy> hmmm, tht last comment by beelsebob|mini reminds me of something i read yesterday. let me see if i can find it
09:44:06 <roconnor> hmm, autogenerating astectic logrithmic axis for charts is more difficult than I thought.
09:45:12 <quicksilver> let a = do_something x y in case a of {Just a' -> let b = do_somethingelse a' z w in case b of { Just c -> Just . finish_off $ c ; Nothing -> Nothing } ; Nothing -> Nothing }
09:45:23 <quicksilver> beelsebob|mini: don't you end up with code like that all the time?
09:45:29 <quicksilver> beelsebob|mini: dealing with partial functions
09:45:33 <fantasma> > let facl = length . show $ scanl (*) 1 [1..] !! 100 in facl
09:45:34 <lambdabot>  158
09:45:37 <quicksilver> beelsebob|mini: and the Maybe monad is just made for that
09:45:42 <beelsebob|mini> quicksilver: not really -- the functions I write rarely turn out to be partial
09:45:46 <chessguy> ah yes, an interesting comment by HenningThielemann on http://www.haskell.org/haskellwiki/Things_to_avoid/Discussion
09:45:47 <lambdabot> Title: Things to avoid/Discussion - HaskellWiki
09:45:56 <quicksilver> beelsebob|mini: then you have a very different use case to me
09:46:06 <beelsebob|mini> using Maybe tends to be an indication to me that I've done something wrong
09:46:07 <quicksilver> beelsebob|mini: in my world all sorts of things can go wrong
09:46:12 <quicksilver> type unification can fail
09:46:16 <quicksilver> there could be a type error
09:46:22 <quicksilver> (this is writing an interpreter, say)
09:46:33 <fantasma> > let facl = length . show $ scanl (*) 1 [1..] !! 10000 in facl
09:46:35 <lambdabot>  35660
09:47:01 <Philippa> yeah, but usually you want to know something about what went wrong too, so you want Either instead
09:47:07 <beelsebob|mini> quicksilver: that's really a case of an either type rather than a Maybe
09:47:08 <quicksilver> Philippa: right
09:47:09 <fantasma> > let facl = length . show $ scanl (*) 1 [1..] !! 100000 in facl
09:47:13 <lambdabot> Terminated
09:47:16 <fantasma> ouch
09:47:18 <quicksilver> beelsebob|mini: of course it is, I was simplifying
09:47:23 <quicksilver> beelsebob|mini: but Either is a monad too
09:47:34 <beelsebob|mini> quicksilver: note - hence my discussion of I might want nice syntax for union types :P
09:47:40 <quicksilver> just replace Nothing with Left "some useful error type here"
09:47:41 * roconnor uses monads to implement stateful backtracking search
09:47:57 <jfoutz> > product [1..100]
09:47:59 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
09:48:11 <fantasma> > let facl = length . show $ scanl (*) 1 [1..] !! 100 in facl
09:48:11 <Philippa> I don't like the existing Error typeclass though
09:48:12 <beelsebob|mini> quicksilver: see I rarely tend to think of something like type unification in terms of something you do sequentially
09:48:13 <lambdabot>  158
09:48:18 <beelsebob|mini> thus using bind makes little sense to me
09:48:24 <Philippa> and especially not the ErrorMonad class's dependance on it
09:48:25 <beelsebob|mini> I can see where you're coming from though
09:48:39 <Philippa> so don't use bind, use fmap and join?
09:48:50 <quicksilver> beelsebob|mini: it's not about sequential
09:48:57 <quicksilver> beelsebob|mini: this is a popular misconception
09:49:03 <quicksilver> monads aren't about sequentiality
09:49:07 <beelsebob|mini> quicksilver: no, but the monad abstarction tends to make me think "sequence going on here"
09:49:15 <quicksilver> wrong thought then
09:49:16 <beelsebob|mini> if I see do blah; blah; blah
09:49:19 <Philippa> quicksilver: wrong, monads are very definitely about /some/ notion of sequence
09:49:29 <beelsebob|mini> my brain reads first this
09:49:30 <beelsebob|mini> then this
09:49:32 <beelsebob|mini> then this
09:49:34 <quicksilver> Philippa: some monads are commutative
09:49:37 * roconnor also uses monads to implement substitutions in languages
09:49:38 <Philippa> they're just not always about the same one, and it could just be data dependency
09:49:39 <beelsebob|mini> that's what the syntactic sugar says
09:49:40 <mauke> well, stop using your brain then
09:49:44 <quicksilver> Philippa: List is 'nearly' commutative
09:49:52 <Philippa> quicksilver: yeah, they're very much special cases though
09:49:58 * roconnor also uses monads to deal with random numbers
09:49:58 <beelsebob|mini> mauke: the point is that the syntactic sugar applied here says that very clearly
09:50:03 <beelsebob|mini> and it's not what the program is doing
09:50:07 <mauke> beelsebob|mini: you don't need to use that sugar
09:50:08 <quicksilver> Philippa: Maybe is commutative
09:50:10 <beelsebob|mini> this is *exactly* why I think it's a bad thing
09:50:26 * roconnor also uses monads to implement assemblers :)
09:50:26 <beelsebob|mini> mauke: indeed - and I don't
09:50:29 <mauke> m >>= f
09:50:30 <quicksilver> beelsebob|mini: don't use the sugar if it offends you
09:50:36 <nmessenger> I wish monads were first explained to me in terms of fmap, return, and join, without all the scary-sounding "they're used to model computations"
09:50:39 <quicksilver> beelsebob|mini: but that doesn't mean you can't use monads
09:50:45 <beelsebob|mini> quicksilver: using bind is suggestive of exactly the same thing
09:50:54 <quicksilver> beelsebob|mini: no more so that this:
09:50:58 <quicksilver> f (g a) (h b)
09:51:08 <quicksilver> this suggests that 'g' and 'h' happen "before" f
09:51:13 <quicksilver> it's data-dependency sequencing
09:51:19 <beelsebob|mini> quicksilver: given no information about what a which monad I'm using, can you explain what bind does?
09:51:21 <quicksilver> monads don't change that, fundamentally
09:51:23 <Philippa> quicksilver: wrong. It's *suggestive* of "do g before h"
09:51:40 <Philippa> note the highlighted word
09:51:52 <quicksilver> Philippa: what's your point?
09:52:02 <mauke> beelsebob|mini: no, but I can feel it
09:52:06 <quicksilver> beelsebob|mini: no, not really
09:52:07 <Philippa> that if you're going to pedant, be more careful with your words
09:52:08 <nmessenger> beelsebob|mini: x >>= f = join (fmap f x), so If I don't understand a particular monad's fmap and join, I don't understand bind.
09:52:17 <beelsebob|mini> quicksilver: and lo, we have discovered what's wrong with monads
09:52:18 <quicksilver> Philippa: I was echoing beelsebob|mini's point
09:52:28 <quicksilver> Philippa: erm, his word
09:52:33 <beelsebob|mini> if I meet a random program - I have no idea what bind is doing
09:52:34 <quicksilver> Philippa: and my objective is not to be pedantic
09:52:39 <beelsebob|mini> the feeling is that it's something sequential
09:52:44 <beelsebob|mini> but this is often wrong
09:52:47 <quicksilver> Philippa: my objective is to find out why he doesn't like monads
09:52:56 <quicksilver> Philippa: and to disagree with that, and explain why I find them useful
09:52:59 <Philippa> quicksilver: in echoing, you made a mistake. You're arguing fine points, so don't walk into it
09:53:10 <Philippa> also, bear in mind that 'like' is subjective, and we already know why you find them useful
09:53:29 <Philippa> you can't disagree with /him/ disliking them, you can only say you like them - he's making an aesthetic judgement
09:53:29 <pxfont> can type classes support several arguments of higher type without forcing those arguments to be applied to each other? how does Haskell (GHC) know the difference between   class Test f g h   vs.   class Test f x y  ?
09:53:41 <quicksilver> Philippa: yes, obviously
09:53:41 <nmessenger> beelsebob|mini: it's true that monads are very general, so the class in general doesn't define much, and you have to understand the semantics of each instance before you can get a feel.
09:54:16 <quicksilver> Philippa: if you're interested to hear what I'm disagreeing with, read the scrollback as far back as beelsebob|mini's initial points
09:54:20 <beelsebob|mini> nmessenger: yes, my argument is that it is in fact so general that it's useless in 90% of the cases when you *can* use it
09:54:26 <beelsebob|mini> there are 10% of cases it makes nice
09:54:28 <pxfont> s/type/kind (constructor classes)
09:54:30 <quicksilver> Philippa: it doesn't seem to add much if I just copy-paste it all here
09:54:35 <beelsebob|mini> but 90% of them it works - but isn't nice
09:54:46 <fantasma> can you seperate let
09:54:48 <quicksilver> beelsebob|mini: before I discovered monads, I had been programming for many years
09:54:48 <Philippa> I did. I'm also familiar with how beelsebob|mini's objections go
09:54:56 <fantasma> can you seperate let with ";" in ghci
09:55:08 <nmessenger> I disagree with "useless", but I understand your frustration with "there's not enough semantics!"
09:55:10 <quicksilver> beelsebob|mini: after I learnt about them, I recognised in them various patterns which had littered my code
09:55:16 <Cale> beelsebob|mini: Monads are just a way to share common structures between combinator libraries.
09:55:25 <Philippa> beelsebob|mini: do you recognise the value in Reader?
09:55:29 <quicksilver> beelsebob|mini: such as "complex computations which can fail at various points"
09:55:39 <quicksilver> beelsebob|mini: "computations which require a supply of unique indices"
09:55:40 <Cale> For instance, so that you don't end up writing sequence, or mapM for each library you write.
09:55:56 <roconnor> Cale: :) I was just about to say that
09:55:59 <quicksilver> beelsebob|mini: and "computations which require an accumulating state"
09:56:09 <beelsebob|mini> quicksilver: you're explaining my point for me again - you're saying "these two functions are useful for doing 3 completely different abstractions"
09:56:16 <beelsebob|mini> why not have 3 different abstarctions
09:56:21 <beelsebob|mini> instead of 1 jack of all trades
09:56:25 <quicksilver> because it's useful?
09:56:26 <Cale> beelsebob|mini: yes, and you *do* have 3 different abstractions
09:56:28 <Philippa> it's not a jack, it's a master
09:56:32 <quicksilver> isn't that what an abstraction is?
09:56:39 <quicksilver> a common thing between apparently different things?
09:56:45 <Philippa> those things all /are/ monads, whether you work with that or ignore it
09:56:56 <Philippa> quicksilver: no, not per se
09:56:57 <beelsebob|mini> quicksilver: sure - but they should be used iff they are actually useful
09:56:57 <Cale> You then have some code which is abstracted over those abstractions.
09:57:03 <quicksilver> it helps me see the commonalities between things which I previously thought were different
09:57:04 <Cale> So you can share it.
09:57:06 <beelsebob|mini> all this one does is makes different things appear the same
09:57:06 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in fiblist; le
09:57:07 <fantasma> t fiblength = length . show $ fiblist !! 10 in fiblength
09:57:07 <lambdabot>  Parse error
09:57:09 <beelsebob|mini> when they really are not
09:57:13 <roconnor> I think Cale is right.  One major use of monads is so you don't have to write sequence for every single instance.
09:57:17 <quicksilver> then, it gives me powerful combinators which work over the samenesses
09:57:20 <Cale> beelsebob|mini: But they are the same in a very particular way.
09:57:28 <Cale> Specifically, all monads are monads.
09:57:33 <beelsebob|mini> Cale: sure - but not one that the program tends to think about
09:57:38 <quicksilver> for example, given the unique supply monad, I look at 'sequence' once again
09:57:44 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in fiblist; let fiblength = length . show $ fiblist !! 10 in fiblength
09:57:44 <lambdabot>  Parse error
09:57:47 <nmessenger> @src sequence
09:57:48 <lambdabot> sequence ms = foldr k (return []) ms
09:57:48 <lambdabot>     where
09:57:48 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
09:57:48 <beelsebob|mini> as people have already said -- they can't explain the similarity
09:57:49 <quicksilver> and I think 'hmm does this combinator mean anything in the unique supply monad' ?
09:57:52 <Cale> (Sorry to be so tautological about it, but that's really all there is to it)
09:57:53 <beelsebob|mini> they can't explain what "bind" does
09:57:59 <quicksilver> and I discover it means something useful
09:58:02 <Philippa> beelsebob|mini: that varies. I've written code that's very deliberately happy in multiple monads so long as they offer certain features
09:58:03 <Cale> beelsebob|mini: sure we can
09:58:25 <beelsebob|mini> Cale: okay then - given no information about what monad I'm using - tell me what bind does
09:58:28 <Philippa> the rest of the time, do notation is nice. Often the hint about sequencing is nice, though I agree sometimes it's no more so than the order in which things appear in a let statement (which is related, btw)
09:58:32 <Cale> beelsebob|mini: Bind takes a computation, and a function from results of that computation to further computations, and joins them together into a single long computation
09:58:47 <beelsebob|mini> Cale: ahh... so it's about sequencing?
09:58:53 <Cale> essentially.
09:58:54 <beelsebob|mini> and lo... we're back at the begining of the discussion
09:58:58 <quicksilver> Philippa: or, equivalently, the way you nest things in a standard 'expression notation'
09:59:04 <beelsebob|mini> often monads are *not* about sequencing
09:59:08 <Philippa> beelsebob|mini: it's about sequencing like function application's about sequencing
09:59:10 <beelsebob|mini> it's a *bad* abstraction
09:59:15 <nmessenger> beelsebob|mini: that depends on the semantics of "join", it needn't be specifically sequence-like
09:59:18 <Philippa> you're using an overspecific notion of what 'sequence' means
09:59:21 <quicksilver> Philippa: that's exactly what I was trying to say before :)
09:59:22 <fantasma> nmessenger, did you see what I wrote above
09:59:23 <Cale> It depends on what exactly you mean by "sequencing"
09:59:36 <Cale> Whether bind is about that or not.
09:59:37 <Philippa> quicksilver: yes, but you were fucking it up for rhetorical purposes :-)
09:59:43 <quicksilver> nmessenger: in the expression "f (g x) (h x)"
09:59:45 <beelsebob|mini> Cale: exactly - so you haven't actually succeded in explaining to me what bind does
09:59:47 <Cale> It's basically a lifted form of application.
09:59:50 <quicksilver> beelsebob|mini: in the expression "f (g x) (h x)"
09:59:51 <ehird> how on earth is Maybe useful?
09:59:53 <ehird> i don't get it
10:00:01 <Philippa> beelsebob|mini: yes he has. He's just not given a concrete definition
10:00:03 <quicksilver> beelsebob|mini: in some sense g needs to be calculated before you can start calculating f
10:00:04 <Cale> beelsebob|mini: I can't be *completely* specific about what it does of course.
10:00:05 <beelsebob|mini> ehird: partial functions
10:00:11 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in fiblist; let fiblength = length . show $ fiblist !! 10 in fiblength
10:00:12 <lambdabot>  Parse error
10:00:13 <Cale> Because it's abstract.
10:00:13 <nmessenger> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in fiblist in length . show $ fiblist !! 10
10:00:14 <lambdabot>  Parse error
10:00:15 <quicksilver> beelsebob|mini: ditto h
10:00:23 <beelsebob|mini> quicksilver: sure
10:00:24 <quicksilver> beelsebob|mini: so even a plain function application 'sequences'
10:00:30 <beelsebob|mini> no
10:00:34 <nmessenger> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in (length . show) (fiblist !! 10)
10:00:36 <lambdabot>  2
10:00:36 <Cale> The real description of what bind is in general is captured by the monad laws, together with its type.
10:00:37 <beelsebob|mini> a plain function can be thought of abstractly
10:00:42 <Philippa> beelsebob|mini: does the operation in a monoid involve sequencing? Yes? No? Is it a bad abstraction?
10:00:48 <beelsebob|mini> in terms of I know the implementation is going to do one first
10:00:50 <nmessenger> fantasma: does that help?
10:00:54 <beelsebob|mini> but I don't need to think about it like that
10:00:55 <fantasma> nmessenger, :)
10:00:57 <quicksilver> beelsebob|mini: this is just like do { g' <- g x; h' <- h x; f g' h';}
10:01:09 <quicksilver> beelsebob|mini: it's the same thing
10:01:10 <chessguy> ehird, http://209.85.165.104/search?q=cache:Y7FpUKpspJMJ:www.nomaware.com/monads/html/meet.html+haskell+monad+sheep+maybe&hl=en&ct=clnk&cd=2&gl=us
10:01:10 <Cale> beelsebob|mini: same goes for monadic code.
10:01:12 <lambdabot> http://tinyurl.com/2hkk58
10:01:19 <quicksilver> beelsebob|mini: there is a data-dependency, so g' is demanded by f
10:01:22 <beelsebob|mini> quicksilver: except that that particular code layout makes my brain think that "oh... g's going to go first" wheras the other does not
10:01:32 <beelsebob|mini> the other one makes me think "one or other can be evaluated first"
10:01:57 <ehird> The purpose of the Maybe type is to provide a method of dealing with illegal or optional values without terminating the program, as would happen if error were used <-- Ah
10:01:58 <ehird> Bad name.
10:02:01 <Philippa> there's a fundamentally similar property about the lambda calculus itself
10:02:08 <ehird> I thought it was like something that randomly returns True|False
10:02:08 <apfelmus> you can see (a -> m b) as an arrow (a ~> b) with a (>>>) being a rather straightforward notion of function composition. then, `bind` is a massaged (>>>)
10:02:10 <Philippa> in fact, it's enough to show that the lambda calculus is boring for concurrency purposes
10:02:13 <quicksilver> beelsebob|mini: for most monads,  { h' <- h x; g' <- g x; f g' h';} is the same, as well
10:02:14 * beelsebob|mini goes to eat his salmon
10:02:16 <nmessenger> ehird: Maybe Int is all values of Int, plus Nothing.  It's like adding a null to a type
10:02:21 <quicksilver> beelsebob|mini: only a few monads are genuinely non-commutative
10:02:31 <Philippa> (but one with primitive saturated constructor application isn't)
10:02:32 <ehird> nmessenger: It isn't Maybe then
10:02:34 <Cale> > let c = do {x <- c; y <- ask; return y} in runReader c 12
10:02:35 <lambdabot>  12
10:02:38 <roconnor> ehird: in ocaml, maybe is called option, possibly a better name
10:02:51 <Cale> quicksilver: actually, I wouldn't say that.
10:02:52 <quicksilver> ehird: it's "Maybe we have an Int"
10:02:57 <quicksilver> ehird: or "Maybe we don't"
10:02:59 <quicksilver> ehird:  :)
10:03:05 <nmessenger> ehird: it *might be* an Int, or it *might be* Nothing, so its Maybe an Int
10:03:12 <Cale> But there are quite a few commutative monads.
10:03:13 <ehird> :/
10:03:14 <quicksilver> Cale: well 'most' is pretty subjective
10:03:28 <quicksilver> Cale: but for a large class of interesting monads it's "essentially" commutative
10:03:47 <ehird> firstElement :: [a] -> Maybe a <-- there THAT makes sense
10:03:55 <Cale> Like, even the list monad isn't commutative, but there's a sense in which it is?
10:03:58 <quicksilver> Cale: Maybe, List, Error (assuming you don't care which error happens first), unique supply, unification (assuming you don't care which type error you see first)
10:03:59 <ehird> "Takes list containing type a, MAYBE returns a'
10:04:08 <ehird> And then I can return either Nothing or Just x
10:04:09 <ehird> I get it now
10:04:12 <nmessenger> firstElement [] = Nothing; firstElement (x:_) = Just x
10:04:19 <ehird> Maybe is a bad name, to give an illusion, for a nice type name
10:04:19 <quicksilver> Cale: yes, the list monad is commutative if you interpret it as 'multiple return values'
10:04:32 <ehird> And it really IS returning Maybe, because Maybe can be made with Nothing and Just x
10:04:37 <Cale> Right, if you interpret it as the set monad.
10:04:40 <quicksilver> Cale: it's just up-to-some-not-interesting equivalence relation
10:04:42 * quicksilver nods
10:04:46 <ehird> That's clever, though I see now why it's hard to understand: it's made for nice type names
10:04:48 <Cale> and you ignore infinite liss
10:04:52 <Cale> lists*
10:04:57 <quicksilver> Cale: and unique supply is only unique up to 'not caring which unique thing I got first'
10:05:05 <roconnor> ehird: yep
10:05:06 <Cale> right
10:05:07 <nmessenger> ehird: would you prefer Nullable?  :3
10:05:07 <quicksilver> Cale: but that's in the spirit of arbitrary ness
10:05:13 <ehird> Nullable, heh
10:05:47 <quicksilver> Cale: so that's the spirit in which I say that 'most' monads are commutative
10:05:49 <nmessenger> let's rename everything to look like Java!
10:05:53 <Cale> beelsebob|mini: Basically, in lots of combinator libraries, you do have some abstract notion of combining computations in order.
10:06:06 <syntaxfree> ehird: it abstracts away a common data type.
10:06:14 <syntaxfree> it's allso a functor, so you can just fmap stuff around
10:06:16 <ehird> Is there a way to get rid of Nothing from prelude?
10:06:17 <Cale> beelsebob|mini: Monads simply generalise that idea, and allow you to share code between libraries which do.
10:06:20 <ehird> so I can define my own
10:06:20 <ehird> err
10:06:21 <apfelmus> Cale: maybe it's not about combining them in order, but combining them at all
10:06:22 <ehird> s/Maybe/Nothing
10:06:25 <quicksilver> ehird: yes
10:06:27 <Cale> apfelmus: yes
10:06:31 <ehird> quicksilver: how
10:06:31 <ehird> :P
10:06:32 <quicksilver> ehird: import prelude hiding ....
10:06:33 <roconnor> ehird: import Prelude hiding (Nothing)
10:06:34 <nmessenger> @type (\(Just x) -> x)
10:06:36 <lambdabot> forall t. Maybe t -> t
10:06:44 <syntaxfree> -fno-implicit-prelude?
10:06:45 <nmessenger> ^^ though that breaks on Nothing
10:06:45 <roconnor> ehird: granted that sounds funny to read.
10:06:47 <quicksilver> import Prelude hiding (Nothing, Just, Maybe)
10:06:53 <quicksilver> and probably more stuff
10:06:56 <ehird> import Prelude hiding (Maybe, Nothing, Just) Yay
10:07:09 <quicksilver> probably you want to hide maybe, and isJust...
10:07:15 <Cale> apfelmus: Though there is a definite sense in which there's an "order" there, in most monads.
10:07:19 <syntaxfree> what is maybe?
10:07:24 <syntaxfree> :t maybe
10:07:25 <Cale> Or at least, the abstraction allows for ordering.
10:07:26 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:07:32 <nmessenger> syntaxfree: case analysis
10:07:34 <syntaxfree> maybe is fmap?
10:07:34 <quicksilver> Cale: I like your second formulation better
10:07:35 <nmessenger> @src maybe
10:07:36 <lambdabot> maybe n _ Nothing  = n
10:07:36 <lambdabot> maybe _ f (Just x) = f x
10:07:47 <syntaxfree> maybe is fmap. Tsc.
10:07:47 <quicksilver> Cale: the abstraction allows for ordering
10:07:47 <ehird> @src Maybe
10:07:48 <lambdabot> data Maybe a = Nothing | Just a
10:07:51 <apfelmus> Cale: yes, though `order` comes from (>>), not (>>=).
10:07:57 <nmessenger> > maybe 0 (*3) Nothing
10:07:59 <lambdabot>  0
10:08:00 <Cale> Well, >>= as well.
10:08:02 <nmessenger> > maybe 0 (*3) (Just 5)
10:08:03 <lambdabot>  15
10:08:17 <apfelmus> (damn i'm already using ` instead of ")
10:08:21 <quicksilver> syntaxfree: maybe isn't fmap
10:08:22 <roconnor> syntaxfree: nope
10:08:25 <nmessenger> syntaxfree: basically maybe takes a Nothing replacement and a Just replacement.
10:08:27 <roconnor> @src Maybe fmap
10:08:27 <lambdabot> fmap _ Nothing       = Nothing
10:08:27 <xerox> (>>) = (. const) . (>>=)
10:08:27 <Cale> Because if it wasn't present in (>>=), then it wouldn't be present in (>>)
10:08:27 <lambdabot> fmap f (Just a)      = Just (f a)
10:08:32 <quicksilver> syntaxfree: maybe is the elimination rule for Maybe
10:08:34 <dcoutts_> ketil_, any luck with your unfoldr problem?
10:08:41 <quicksilver> syntaxfree: (as either is the elimination rule for Either)
10:08:45 <syntaxfree> ah.
10:08:46 <Cale> x >> y = x >>= const y
10:08:52 <syntaxfree> of course.
10:09:03 <roconnor> @type fmap :: (a -> b) -> (Maybe a) -> (Maybe b)
10:09:06 <lambdabot> (a -> b) -> (Maybe a) -> (Maybe b) :: forall a b. (a -> b) -> Maybe a -> Maybe b
10:09:07 <Cale> quicksilver: and foldr is for lists
10:09:09 <syntaxfree> maybe should be withDefault.
10:09:13 <ehird> @paste
10:09:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:09:21 <apfelmus> Cale: mh, the point about >>= is that you can't reorder due to the data dependency
10:09:25 <nmessenger> fmap lifts functions into Just, maybe pulls values down from either Nothing or Just
10:09:26 <hpaste>  ehird pasted "doesn't like the second firstElement call :/" at http://hpaste.org/615
10:09:31 <ehird> and that's straight out of YAHT too
10:09:42 <nmessenger> ehird: YAHT isn't perfect :/
10:09:49 <roconnor> maybe is more like foldr
10:09:49 <ehird> yes, but :P
10:09:54 <mauke> ehird: what's the error?
10:09:54 <Cale> apfelmus: well, much of the time, anyway
10:09:56 <syntaxfree> yes, I see.
10:10:06 <ehird> mauke:     Ambiguous type variable `a' in the constraint:       `Show a' arising from use of `show' at Nothing.hs:6:21-42    Probable fix: add a type signature that fixes these type variable(s)
10:10:18 <apfelmus> Cale: yeah. "order" comes from the fact that (>>) trashes the data dependency
10:10:33 <hpaste>  nmessenger annotated "doesn't like the second firstElement call :/" with "not enough type information" at http://hpaste.org/615#a1
10:10:45 <quicksilver> apfelmus: that's not quite the whole truth
10:10:50 <Cale> There are also strange notions of "order", like the reversed State monad.
10:10:59 <mauke> ehird: ah, makes sense
10:11:03 <Cale> (where state travels backwards in "time")
10:11:05 <quicksilver> apfelmus: the monad might have a notion of order which has nothing to do with data dependencies
10:11:18 <mauke> ehird: you can probably fix it by using (firstElement "")
10:11:22 <apfelmus> quicksilver: yes? x >> y == y >> x?
10:11:27 <quicksilver> apfelmus: Either does, for example
10:11:30 <jfoutz> ehird: firstElement :: Show a => [a] -> Maybe a
10:11:37 <quicksilver> apfelmus: so does IO, in certain cases
10:11:44 <quicksilver> apfelmus: but many monads don't
10:11:48 <jfoutz> that's a little heavy handed, you want to get the first of non showable things
10:11:53 <quicksilver> apfelmus: this is what I was talking to cale about when you wandered in
10:11:59 <nmessenger> ehird, mauke: thats because "" is typed as a '[Char]', but [] is a '[a]', so it doesn't know which type.
10:12:02 <quicksilver> apfelmus: many monads don't have a notion of order (commutative monads)
10:12:17 <xerox> ?check \amb0 amb1 -> amb0 >> amb1 == amb1 >> (amb0 :: [Int])
10:12:18 <lambdabot>  Couldn't match expected type `m a' against inferred type `Bool'
10:12:23 <quicksilver> apfelmus: actually haskell monads are very rarely commutative, but some are commutative up to some obvious notion
10:12:48 <ehird> that works
10:12:54 <xerox> ?check \amb0 amb1 -> (amb0 >> amb1) == (amb1 >> (amb0 :: Maybe Int))
10:12:55 <lambdabot>  Falsifiable, after 8 tests: Just (-1), Just (-4)
10:12:57 <quicksilver> apfelmus: the data dependency thing is somewhat of a red herring, since with instances of MonadFix you can run the data dependencies backwords anyway :)
10:13:01 <apfelmus> ? don't have a notion of order or aren't commutative? what i'm saying is that the notion of order can only be expressed by (>>)
10:13:12 <nmessenger> ehird: you could also directly annotate the [], "([] :: [Int])"
10:13:21 <quicksilver> 'notion of order' is the same as 'non commutative'
10:13:29 <quicksilver> I don't understand why you think >> is different from >>=
10:13:35 <nmessenger> ehird: "an empty list of Ints"
10:13:45 <quicksilver> >> throws away some data but that's all
10:14:01 <jfoutz> ehird, nmessenger's way is better. it dosn't leak the show requirement out of main.
10:14:01 <Cale> apfelmus: I know what you're saying with that, but that's an awkward way to say it, because anything which you can express with >> can be expressed with >>= alone.
10:14:16 <apfelmus> but not the other way round
10:14:25 <ehird> firstElement :: [a] -> Maybe a ([] :: [Int]) <-- I did something wrong.
10:14:27 <Cale> Right.
10:14:28 <ehird> syntax error.
10:14:31 <allbery_b> quicksilver: but the data thrown away introduces a data dependency, so you can end up with implicit ordering from that
10:14:48 <nmessenger> and anything you can express with (>>=) *should* be expressible with fmap and join, but it isn't in Haskell's implementation.
10:14:49 <mauke> ehird: no, (firstElement ([] :: [Int]))
10:14:53 <allbery_b> that is, if you don't throw it away (the >>= case) it can introduce...
10:14:59 <mauke> ehird: the type of firstElement is fine
10:15:13 <quicksilver> allbery_b: but data dependencies are actually a different issue from the monad order
10:15:14 <apfelmus> quicksilver: no, both are slightly different. "no notion of order" = i don't no what 'order' is; "not commutative" = there are x,y with x >> y /= y >> x
10:15:23 <nmessenger>           putStrLn $ show (firstElement [] :: Maybe Int)
10:15:25 <ehird> well, the whole point
10:15:26 <jfoutz> ehird, rather than editing the type of firstElement, nmessenger wants you to edit line 6
10:15:28 <ehird> of the yaht thing
10:15:30 <ehird> is to not die on []
10:15:35 <ehird> :/
10:15:39 <ehird> (that's what it said. at least)
10:15:42 <quicksilver> allbery_b: in a MonadFix you can run data dependecies backwards
10:15:48 <allbery_b> quicksilver: true, but it does complicate the analysis, so it's easier to remove it from the discussion
10:15:52 <nmessenger> putStrLn $ show (firstElement ([] :: [Int])) -- stupid copy-paste
10:16:04 <Philippa> yes, but MonadFix requires you to show that you've done it too
10:16:06 <quicksilver> allbery_b: do { g x ; x <- f } (f running backwards)
10:16:23 <mauke> ehird: yeah, so?
10:16:26 <quicksilver> apfelmus: I think you can recover one from the other
10:16:26 <apfelmus> Cale: the strange point about (>>=) is one can derive a (>>) from that. with arrows, this is different (?)
10:16:28 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in length . show $ fiblist !! (2^19)
10:16:32 <lambdabot> Terminated
10:16:36 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in length . show $ fiblist !! (2^18)
10:16:40 <lambdabot> Terminated
10:16:44 <nmessenger> anybody know where I can read how mdo is desugared?
10:16:45 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in length . show $ fiblist !! (2^15)
10:16:47 <lambdabot>  6848
10:17:03 <nmessenger> I want to understand the magic
10:17:04 <quicksilver> apfelmus: if x >> y /= y >> x then you can harness that different to 'define what you mean by order'
10:17:06 <Cale> apfelmus: arrows generalise Kleisli composition though. It's a shame that we don't have a name for that.
10:17:08 <mauke> ehird: (firstElement (tail [42])) should work fine
10:17:16 <fantasma> > 2^19
10:17:17 <lambdabot>  524288
10:17:27 <Cale> apfelmus: In some sense, arrows are generalising >>= more than >> though.
10:17:32 <mauke> ehird: it's just [] itself that needs more type information if you just want to print it
10:17:47 <nmessenger> Cale: do you know where mdo desugaring is specified?
10:17:49 <quicksilver> nmessenger: I think it's in the awkward squad paper?
10:17:58 <Philippa> no, that's do
10:18:01 <apfelmus> Cale: yeah. that's why i think that the 'order' discussion cannot happen for arrows.
10:18:10 <quicksilver> it's in one of the SPJ papers :)
10:18:12 <Philippa> if you google 'mdo monad recursion' or similar you'll find the original paper
10:18:17 <Philippa> quicksilver: *no*. You're confusing do and mdo
10:18:21 <liquidengineer> Hello
10:18:22 <quicksilver> Philippa: I am not
10:18:29 <quicksilver> Philippa: I may be confusing papers and authors, though
10:18:50 <liquidengineer> What's the easiest way to instance a show function for a function?
10:18:59 <nmessenger> deriving (Show)?
10:19:03 <ehird> @src foldr
10:19:03 <lambdabot> foldr k z xs = go xs
10:19:04 <lambdabot>     where go []     = z
10:19:04 <lambdabot>           go (y:ys) = y `k` go ys
10:19:05 <nmessenger> for a function
10:19:07 <nmessenger> oh
10:19:27 <fantasma> can prelude do phi?
10:19:32 <nmessenger> import Text.Show.Functions :)
10:19:43 <apfelmus> quicksilver: for me "no notion" means "i can't say what the word 'order' should mean, i don't have an equation i can check to be true or not "
10:19:47 <Cale> apfelmus: er, it can be rephrased to work with them though.
10:19:59 <apfelmus> Cale: 'order'?
10:20:00 <liquidengineer> Text.Show.Functions?
10:20:05 <liquidengineer> that sounds promising
10:20:07 <nmessenger> that'd give you (show anyFunctionAtAll) = "<function>"
10:20:08 <Cale> apfelmus: order of side effects, yeah.
10:21:03 <apfelmus> Cale: i feared that. what's the formulation?
10:21:18 <liquidengineer> That's wonderful
10:21:22 <liquidengineer> You are all of the awesome.
10:21:39 <Cale> I'd have to think about it a bit, but (->) would be a commutative arrow, while data IOA a b = IOA (a -> IO b) wouldn't.
10:21:42 * nmessenger blushes.  "I didn't write it."
10:21:52 <Cale> (or Kleisli IO, if you want)
10:21:55 <ehird> > let x x = show x in x "hi"
10:21:56 <lambdabot>  "\"hi\""
10:21:58 <fantasma> can predlude do phi?
10:21:58 <xerox> @scheck \f -> f 1 == (f :: Int -> Int) 2
10:22:00 <lambdabot>   Failed test no. 1. Test values follow.: {-3->0;-2->0;-1->-1;0->-2;1->-1;2->...
10:22:09 <ehird> > let x x = x x in x x
10:22:09 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
10:22:10 <lambdabot>     Probab...
10:22:11 <nmessenger> fantasma: phi?  the golden ratio?
10:22:12 <ehird> aw
10:22:12 <xerox> Showable functions :-)
10:22:20 <fantasma> nmessenger, yeah
10:22:22 <ehird> xerox: i want hsowable functions :(
10:22:34 <Cale> fantasma: (1 + sqrt 5)/2 ?
10:22:41 <apfelmus> Cale: most likely, yes :) but how to specify the word 'ordered' so that it works for all arrows?
10:22:43 <nmessenger> fantasma: I don't think it's int the Prelude, but you might define one.
10:22:45 <ehird> > let myFunc x = x+2 in show myFunc
10:22:47 <lambdabot>  "<Integer -> Integer>"
10:22:55 <ehird> should give 'x = x+2'
10:23:01 <fantasma> ok, just checking
10:23:03 <nmessenger> ehird: that uses a little ghc-specific magic
10:23:19 <ehird> nmessenger: is showing a function like i said even possible with haskell?
10:23:21 <nmessenger> ehird: to do the show you want, you'd have to solve the halting problem first :)
10:23:25 <ehird> if so, smallest quine ever upcoming =D
10:23:46 <Cale> apfelmus: Well, whether f &&& g is the same as g &&& f >>> pure (\(x,y) -> (y,x))
10:23:48 <Cale> er
10:23:50 <liquidengineer> I don't suppose there's an equivilent for Read? :P
10:24:00 <liquidengineer> as in, reading a function definition from a file?
10:24:01 <Cale> Whether f &&& g is the same as swap >>> g &&& f >>> swap
10:24:10 <nmessenger> liquidengineer: you'd need a Haskell compiler :)
10:24:11 <Cale> where swap = pure (\(x,y) -> (y,x))
10:24:25 <nmessenger> liquidengineer: so hs-plugins or ghc-api
10:24:32 <liquidengineer> ah
10:24:35 <hpaste>  allbery_b pasted "slightly friendlier Show for functions" at http://hpaste.org/616
10:24:40 <Cale> I think that's a fairly elegant way to put it.
10:24:58 <svref> What does one do when one has to do recursion on the length of a tuple?
10:25:00 <nmessenger> though allbery_b's would require -fglasgow-exts
10:25:28 <nmessenger> svref: eh?  I think you'd have to specify each case.
10:25:38 <Cale> Alternately, if the intermediate lines of a proc/do can be reordered arbitrarily or not.
10:25:39 <svref> pairs, triplets, quads, etc?
10:25:52 <liquidengineer> Hmm....
10:25:57 <apfelmus> Cale: yeah, ok, i think that's it.
10:25:58 <dcoutts_> svref, might be time to pull out the type classes
10:26:01 <roconnor> > (\a -> zipwith (/) (tail a) a)) [1 2 5 10]
10:26:01 <lambdabot>  Parse error
10:26:29 <roconnor> > (\a -> zipWith (/) a (1:a)) [2 5 10]
10:26:30 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
10:26:30 <lambdabot>     In the expression:...
10:26:40 <liquidengineer> I have a field in a record type (using data) as follows: fitFunction :: NimPlayer -> FitScore
10:26:40 <nmessenger> commas?
10:26:48 <liquidengineer> I want to be able to read this data type from a file
10:26:52 <roconnor> @type zipWith
10:26:54 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:26:56 <roconnor> oh right
10:26:57 <liquidengineer> but that function's really bugging me up.
10:27:00 <roconnor> > (\a -> zipWith (/) a (1:a)) [2, 5, 10]
10:27:01 <lambdabot>  [2.0,2.5,2.0]
10:27:23 <nmessenger> liquidengineer: you might define a minilanguage for specifying these functions, parse it, and translate into haskell functions.
10:27:24 <liquidengineer> Can I not do that?
10:27:29 <roconnor> > (\a -> zipWith (/) a (1:a)) [2, 2.5, 5, 10]
10:27:29 <svref> I'm writing a parser that reads strings of the format "[a,b,c,d..]" and needs to return tuples (a,b,c,d,..), where a,b,c,and d have different types
10:27:30 <lambdabot>  [2.0,1.25,2.0,2.0]
10:27:41 <liquidengineer> .......I'm not that attached to being able to read files.
10:27:44 <liquidengineer> :P
10:27:47 <Cale> liquidengineer: there's no standard way to serialize arbitrary functions.
10:27:58 <liquidengineer> Cale: Is that planned at all?
10:28:02 <nmessenger> alternatively, you could use Data.Map.Map to define simple functions from one value to another.
10:28:06 <apfelmus> liquidengineer: it's impossible
10:28:11 <ehird> @paste
10:28:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:28:19 <liquidengineer> really?
10:28:23 <hpaste>  ehird pasted "how could i access the elements with this?" at http://hpaste.org/617
10:28:24 <Cale> Well, mostly impossible.
10:28:28 <nmessenger> @type flip lookup (undefined :: M.Map Int Char)
10:28:30 <liquidengineer> I'm surprised
10:28:31 <lambdabot>     Couldn't match expected type `[(a, b)]'
10:28:31 <lambdabot>            against inferred type `M.Map Int Char'
10:28:37 <nmessenger> @type flip M.lookup (undefined :: M.Map Int Char)
10:28:39 <lambdabot> forall (m :: * -> *). (Monad m) => Int -> m Char
10:28:40 <Cale> Not entirely, but you'd have to go to a great deal of trouble.
10:28:46 <allbery_b> <nmessenger> though allbery_b's would require -fglasgow-exts
10:28:48 <liquidengineer> understandable
10:28:48 <allbery_b> doesn't seem to
10:28:53 <mauke> ehird: pattern matching
10:29:02 <fantasma> can you define multiple things with a single let?
10:29:02 <nmessenger> allbery_b: it did when I tried it.
10:29:04 <Cale> and there'd usually be pretty severe restrictions on where the functions could be read back
10:29:04 <ehird> mauke: how would i use pattern matching here?
10:29:08 <apfelmus> liquidengineer: yeah, mostly. no program may touch the serialization or this breaks referential transparanecy
10:29:25 <nmessenger> I'll try again
10:29:33 <Cale> apfelmus: hm?
10:29:33 <mauke> ehird: case t of Tuple1 a -> ...; Tuple2 a b -> ...; etc
10:29:40 <allbery_b> hm.  only thig I got was a whine because I had designed it for quickie use with ghci, so no module declaration, so it wghined about a missig "main"
10:29:53 <ehird> mauke: that isn't pattern matching?
10:30:10 <nmessenger> allbery_b: hmm, nevermind.
10:30:28 <apfelmus> Cale: i think i got confused. i mean there cannot be a Show instance. but "serialization" is likely to mean "the run-time environment emits it"
10:30:32 <hpaste>  allbery_b annotated "slightly friendlier Show for functions" with "with the module declaration (original is suitable for ghci)" at http://hpaste.org/616#a1
10:30:35 <nmessenger> allbery_b: I could *swear* it didn't compile when I tried.  And I had identical code.
10:30:39 <mauke> ehird: what?
10:30:47 <Cale> apfelmus: yeah
10:30:49 <ehird> mauke: well... it isn't, is it?
10:30:54 <mauke> ehird: of course it is
10:30:58 <ehird> i have a Tuple, either made with Tuple1,2,3,4
10:30:59 <fantasma> can you define multiple things with a single let?
10:31:04 <Cale> apfelmus: You certainly can't write a Show instance unless the domain is finite.
10:31:09 <ehird> i don't see how to access the first one
10:31:12 <ehird> or the second one
10:31:14 <ehird> passed
10:31:17 <Cale> apfelmus: but the RTS knows more than you can :)
10:31:19 <ehird> given one of them
10:31:28 <allbery_b> if you had Data.Functions imported then it would blow up due to overlapping instances, I guess
10:31:28 <apfelmus> Cale: yeah. :)
10:31:34 <jfoutz> > let a = 1; b = 2 in a + b
10:31:35 <lambdabot>  3
10:31:40 <nmessenger> @type (M.!)
10:31:42 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
10:31:45 <fantasma> thank you
10:31:47 <apfelmus> liquidengineer: actually, Clean can save function values to disk.
10:31:49 <nmessenger> ^^ that'd turn a Map into a function
10:31:49 <mauke> ehird: what's wrong with case t of Tuple1 a -> ...; Tuple2 a b -> ...; ?
10:32:04 <nmessenger> but, yeah, it'd have to be finite
10:32:32 <apfelmus> Cale: btw, do you know a good example of f . g having less asymptotic complexity than g due to laziness? head . mergesort is fine, but are there others?
10:33:01 <Cale> well, lots of search algorithms
10:33:08 <nmessenger> doesn't it *always* have the complexity of f?  I'm fuzzy on this.
10:33:25 <Cale> Basically, anything where f prunes a tree generated by g
10:33:25 <nmessenger> hmm, no I guess not
10:33:58 <nmessenger> kinda like the "intersection" of f and g?  Again, I don't know what I'm talking about.
10:34:18 <Cale> One of my favourite examples, even though the asymptotic change is not spectacular is  isSubstringOf x y = any (isPrefixOf x) (tails y)
10:34:40 <apfelmus> ah, i think that's what i looked for.
10:34:45 <Cale> Sharing and laziness make this rather good.
10:34:50 <xerox> ?src isInfixOf
10:34:50 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
10:34:52 <xerox> 6.6
10:35:10 <nmessenger> 6.7?  I don't remember my 6.6 having it.
10:35:10 <apfelmus> though it doesn't change worst case complexity, does it?
10:35:12 <Cale> Whereas an strict imperative programmer would tend to look at that and say "are you nuts!?"
10:35:15 <Cale> a*
10:35:53 <nmessenger> I love it!  The compiler turn dead stupid looking algorithms into okay algorithms!
10:36:21 <Cale> (or even a strict functional one)
10:36:35 <nmessenger> "strict"? :P
10:36:45 <Cale> strict as opposed to lazy
10:36:57 <liquidengineer> What does it mean to be Typeable?
10:37:01 <Cale> strict evaluation is innermost leftmost first.
10:37:09 <nmessenger> @src Typeable
10:37:10 <mauke> not necessarily leftmost
10:37:10 <lambdabot> Source not found. stty: unknown mode: doofus
10:37:14 <apfelmus> mh, is there another example that reduces worst case time?
10:37:16 <Cale> Lazy evaluation is outermost leftmost first, with sharing.
10:37:35 <nmessenger> liquidengineer: that means it has a runtime type representation, so you can play with that.
10:37:44 * kc5tja missed something.  This is what happens when you're too busy working at office stuff.
10:38:02 <liquidengineer> nmessenger: ah
10:38:11 * nmessenger wonders at the implementation of TypeRep
10:38:18 <nmessenger> @source Typeable
10:38:19 <lambdabot> Typeable not available
10:38:22 <nmessenger> @source Data.Typeable
10:38:23 <lambdabot> http://darcs.haskell.org/packages/base/Data/Typeable.hs
10:38:25 <dylan_> @hoogle getEnv
10:38:26 <lambdabot> System.getEnv :: String -> IO String
10:38:26 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
10:38:42 <liquidengineer> Could I derive Typeable on this?
10:38:43 <liquidengineer> data NimPlayer = NP {playerID :: Int, strategy :: NimProg, score:: Int}
10:38:54 <liquidengineer> that nice display function says this lacks an instance of typable
10:39:22 <nmessenger> deriving (Typeable) requires a glasgow-extension of some sort I think.
10:39:30 <Cale> apfelmus: Combinatorial searches are good for that. Say, producing a tree of all possible moves in some game, and then doing some depth/width pruning to ensure that only a reasonable number are ever looked at.
10:39:41 <liquidengineer> I've got the fglasgow extents flag set to true
10:39:58 <nmessenger> liquidengineer: add "deriving (Typeable)" to the end of your datatype.
10:39:58 <liquidengineer> would that do it?
10:39:58 <Cale> oh
10:40:03 <liquidengineer> ah
10:40:03 <Cale> another good example...
10:40:05 <liquidengineer> cool
10:40:07 <allbery_b> myTypeRep = mkTyCon "NimPlayer"; instance Typeable NimPlayer where typeOf _ = myTypeRep
10:40:16 <liquidengineer> So I don't have to write my own instance?
10:40:22 <allbery_b> (the version that doesn't require -fglasgow-exts)
10:40:48 <Cale> Many sorting algorithms result in a reduction to O(n) time when you only observe the first element of the resulting list.
10:40:49 <apfelmus> Cale: i'm eager to hear. unfortunately, most pruning only skips of a constant (but large) factor
10:41:22 <Cale> apfelmus: well, pruning depth usually reduces the tree to a constant size.
10:41:53 <nmessenger> Cale: so "head . sort" is good for "minimum"?!
10:41:53 <Cale> It's easier to write code that generates the whole tree, and do pruning as a separate step though.
10:42:03 <apfelmus> Cale: ok, as compared to infinite :) but the generator doesn't have independent meaning then
10:42:04 <Cale> nmessenger: yes, at least asymptotically.
10:42:08 <liquidengineer> allbery: where do I put that?
10:42:20 <liquidengineer> do I replace the instance thing from the pastebin?
10:42:21 <fantasma> can someone tell me what's wrong with this code?
10:42:35 <fantasma> let phi = ((1 + sqrt 5)/2); n = (2^20) in length . show $ ((phi^n-(-phi)^n)/(sqrt 5))
10:42:41 <Cale> apfelmus: well, the tree could still be finite, but growing exponentially with the problem size
10:42:57 <quicksilver> beelsebob|mini: if you're there, or if you come back, I spent a long walk thinking about it and I think I have an inkling of what you mean
10:42:59 <nmessenger> > let x = 1 in -x
10:43:01 <lambdabot>  -1
10:43:08 <mauke> > let phi = ((1 + sqrt 5)/2); n = (2^20) in length . show $ ((phi^n-(-phi)^n)/(sqrt 5))
10:43:09 <nmessenger> (just checking something)
10:43:10 <lambdabot>  3
10:43:14 <allbery_b> no, that's something you can add after defining a"data" type if you want to add a Typeable instance for it without -fglasgow-exts
10:43:18 <mauke> works for me
10:43:23 <quicksilver> beelsebob|mini: I sometimes write custom combinators over a type which is in fact monadic, but I don't make it a Monad instance
10:43:35 <allbery_b> it's probably easier to just use -fglasgow-exts and deriving (Typeable)
10:43:37 <Cale> apfelmus: But the infinite -> finite reduction is the most common one.
10:43:38 <fantasma> mauke, it always gives 3
10:43:51 <fantasma> no matter what n you put in
10:43:52 <quicksilver> beelsebob|mini: and I don't particularly choose to use >>=, rather I use the custom combinator which feels most useful
10:44:02 <liquidengineer> allbery_b: yeah
10:44:06 <quicksilver> beelsebob|mini: so you could say 'why bother to make that a Monad instance'
10:44:09 <mauke> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 20 in (phi ^ n - (-phi) ^ n) / sqrt 5
10:44:11 <lambdabot>  NaN
10:44:13 <apfelmus> Cale: yeah. but even an exponential tree most likely does not have an independent meaning like the sorting function
10:44:17 <quicksilver> beelsebob|mini: the answer is contained in things like Data.Traversable
10:44:25 <allbery_b> in essence that is what the deriving (Typeable) expands to
10:44:32 <apfelmus> Cale: also note that "many" sorting algorithms is somehow not the case. quicksort does not and most mergesort implementations i've seem don't return the head in O(n)
10:44:33 <mauke> > (-1)^3
10:44:34 <lambdabot>  -1
10:44:38 <Cale> apfelmus: It's possible to design algorithms in the list monad such that taking the head of the resulting list gives the greedy algorithm result (in greedy algorithm time), but further results become successively less greedy.
10:44:38 <fantasma> try a smaller n
10:44:40 <norpan> fantasma: NaN is three characters long, yes .)
10:44:46 <liquidengineer> So I should be able to show any function now, yes?
10:44:47 <fantasma> lol
10:45:21 <fantasma> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 3 in (phi ^ n - (-phi) ^ n) / sqrt 5
10:45:21 <allbery_b> not *any* funtion, since it can't deal with polymorphism
10:45:22 <lambdabot>  0.0
10:45:25 <allbery_b> > fmap
10:45:27 <lambdabot>  Add a type signature
10:45:37 <Cale> So you can implement both the greedy heuristic, and the exact solution with the same code.
10:45:45 <apfelmus> Cale: good idea. also pretty easy to implement i think, simply choose the best one first.
10:45:52 <Cale> right.
10:45:52 <norpan> 0.0 is also three characters
10:46:07 <allbery_b> you won't get *that* error with ghc/ghci, you'll get the moral equivalent though --- there's n way to do polymorphic Typeable
10:46:09 <emu> selecting the kth item in a list (in order) is O(n)
10:46:18 <emu> using a sort can be heavy-handed
10:46:18 <allbery_b> "there's no way..."
10:46:22 <fantasma> norpan, why does it return that though
10:46:28 <Cale> I did this in my scheduler for PPC/Altivec and it worked out rather nicely.
10:46:41 <Cale> The code was also really really easy to refactor.
10:46:43 <apfelmus> how s?
10:46:52 <apfelmus> s/s/so
10:46:59 <Cale> You could add additional filters to do extra pruning very easily.
10:47:02 <fantasma> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 3 in show phi
10:47:03 <lambdabot>  "1.618033988749895"
10:47:24 <roconnor> > let f 0 = [1,2,5]; f _ = [1,2,2.5,5] in [x*10^y | x<-[0..] y<- f x]
10:47:25 <lambdabot>  Parse error
10:47:28 <norpan> fantasma: why does it return what?
10:47:32 <fantasma> 0
10:47:36 <roconnor> > let f 0 = [1,2,5]; f _ = [1,2,2.5,5] in [x*10^y | x<-[0..], y<- f x]
10:47:37 <lambdabot>  Add a type signature
10:47:42 <roconnor> > let f 0 = [1,2,5]; f _ = [1,2,2.5,5] in [x*10^y | x<-[0..], y<- f x] :: [Double]
10:47:43 <lambdabot>  Add a type signature
10:47:54 <Cale> Everything was very nicely sorted out into logical steps, and the main part of the algorithm just had to consider ways in which to schedule one additional instruction.
10:47:54 <roconnor> lambdabot: where?
10:48:14 <mauke> fantasma: phi^n == (-phi)^n, so their difference is 0.0
10:48:31 <fantasma> ohHH!
10:48:32 <nmessenger> roconnor: you used a decimal point instead of a comma in f's second case.
10:48:33 <mauke> NaN happens when phi^n == Inf
10:48:35 <fantasma> wow im missing a - sign
10:48:46 <roconnor> nmessenger: that's what I want
10:48:56 <apfelmus> Cale: sounds nice
10:48:58 <roconnor> > let f 0 = [1, 2, 5]; f _ = [1, 2, 2.5, 5] in [x*10^y | x<-[0..], y<- f x] :: [Double]
10:48:59 <lambdabot>  Add a type signature
10:49:01 <Cale> Finally, when the scheduling was finished, the register allocator was able to consume that lazy list of schedules, so that if it couldn't allocate registers for one, the next would be tried.
10:49:14 <fantasma> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 3 in (phi ^ n - (-phi) ^ (-n) / sqrt 5
10:49:15 <lambdabot>  Parse error
10:49:22 <roconnor> > let f 0 = [1, 2, 5]; f _ = [1, 2, 2.5, 5] in [x*10^y | x<-[(0::Integer)..], y<- f x] :: [Double]
10:49:23 <lambdabot>  Couldn't match expected type `Double'
10:49:31 <mauke> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 3 in (phi ^ n - (-phi) ^ (-n)) / sqrt 5
10:49:33 <lambdabot>  Exception: Prelude.^: negative exponent
10:49:40 <roconnor> > let f 0 = [1, 2, 5]; f _ = [1, 2, 2.5, 5] in [y*10^x | x<-[(0::Integer)..], y<- f x] :: [Double]
10:49:41 <lambdabot>  [1.0,2.0,5.0,10.0,20.0,25.0,50.0,100.0,200.0,250.0,500.0,1000.0,2000.0,2500....
10:49:44 <Cale> It would be interesting to use another monad to allow some information to flow back from register allocation to scheduling, but I never tried that. It worked fairly well as it was.
10:49:44 <fantasma> how do you do negative exponents
10:49:54 <mauke> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 3 in (phi ^ n - (-phi) ^^ (-n)) / sqrt 5
10:49:55 <quicksilver> Cale: Imagine a complex query over a relational database, which mientions tables more than once
10:49:56 <roconnor> ah perfect.
10:49:56 <lambdabot>  21.0
10:49:56 <Cheery> http://www.rfc1149.net/blog/2007/02/23/non-classical-paradigms-and-languages/
10:50:00 <lambdabot> Title: Dr Jekyll &#038; Mr Hyde  Blog Archive  Non-classical paradigms and languages, http://tinyurl.com/2j6wev
10:50:20 <fantasma> mauke, use ^^ for negative exponents?
10:50:21 <quicksilver> Cale: a query plan might involve multiple 'table scans' over the same table, as it appears in differen sub expressions
10:50:35 <apfelmus> Cale: interesting. any pointers?
10:50:50 <mauke> > let phi = (1 + sqrt 5) / 2 in [(phi ^ n - (-phi) ^^ (-n)) / sqrt 5 | i <- [0 .. 9], let n = 2 ^ i]
10:50:52 <lambdabot>  [1.0,1.0,3.0,21.0,986.9999999999998,2178309.0,1.0610209857722998e13,2.517288...
10:50:52 <quicksilver> Cale: a good lazy algorithm might somehow paralleslise those, so that the scan happens once and the rows are 'fed' to each subexpression
10:51:02 <quicksilver> Cale: is that in any way related to your register allocation thing?
10:51:22 <chessguy> hm, what are you guys talking about?
10:51:22 <fantasma> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 19 in (phi ^ n - (-phi) ^^ (-n)) / sqrt 5
10:51:23 <lambdabot>  Infinity
10:51:31 <fantasma> thats wrong =\
10:51:37 <fantasma> it should be 109570
10:51:55 <mauke> > 2 ^ (2^19)
10:51:57 <lambdabot>  2596370567831000776126596495726882827744734376348456046357365486775461052458...
10:52:01 <mauke> > 2.0 ^ (2^19)
10:52:01 <Cale> apfelmus: well, without knowing exactly how scheduling decisions affect register allocation, it's tricky, but the basic idea would be to encode the decisions in the monad structure along with the actual results
10:52:03 <lambdabot>  Infinity
10:52:07 <fantasma> wait
10:52:10 <mauke> fantasma: that number doesn't fit in a Double
10:52:23 <Cale> apfelmus: like, using a tree monad with some additional tags in the structure, rather than a list monad.
10:52:24 <fantasma> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 19 in length . show $ (phi ^ n - (-phi) ^^ (-n)) / sqrt 5
10:52:26 <lambdabot>  8
10:52:34 <mauke> > length "Infinity"
10:52:36 <lambdabot>  8
10:52:42 <fantasma> lol
10:52:43 <ehird> > length 1/0
10:52:44 <lambdabot>   add an instance declaration for (Num [a])
10:52:46 <Cale> quicksilver: hmm
10:52:49 <ehird> no, lambdabot
10:52:51 <nmessenger> > length (1/0)
10:52:51 <ehird> > 1/0
10:52:53 <lambdabot>   add an instance declaration for (Fractional [a])
10:52:53 <lambdabot>  Infinity
10:52:58 <nmessenger> ehird: ^^
10:53:08 <ehird> > let x = 1/0 where length x
10:53:08 <lambdabot>  Parse error
10:53:09 <fantasma> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 15 in length . show $ (phi ^ n - (-phi) ^^ (-n)) / sqrt 5
10:53:10 <lambdabot>  8
10:53:12 <ehird> > let x = 1/0 in length x
10:53:13 <lambdabot>   add an instance declaration for (Fractional [a])
10:53:13 <lambdabot>     In the expression: 1 /...
10:53:17 <ehird> bah humbug
10:53:19 <nmessenger> ehird: yours parses as (length 1)/0
10:53:20 <Cale> quicksilver: perhaps a bit. Laziness does allow lots of the work to be shared between steps of the algorithm.
10:53:26 <quicksilver> Cale: it's something I think about from time to time, and the fuzzy pattern matcher in my head felt it was a bit like what you were talking about
10:53:38 <fantasma> why is it returning infinity :(
10:53:46 <mauke> fantasma: because the number is too big to fit in a Double
10:54:12 <fantasma> that sucks major
10:54:20 <ehird> you suck major
10:54:28 <fantasma> whats bigger than a double :D
10:54:36 * nmessenger wonders if anyone's implemented arbitrary-precision floating point :3
10:54:56 <fantasma> that number should fit in a double though
10:54:59 <ehird> so - say i have http://hpaste.org/617 - if i get myFunc (Tuple3 1 2 3), how, in myfunc, can i accses 1 2 or 3
10:55:07 <mauke> > 2.0 ^ (2 ^ 10)
10:55:09 <lambdabot>  Infinity
10:55:11 <nmessenger> fantasma: the intermediate results don't, though
10:55:13 <quicksilver> well there is arbitrary precision rational
10:55:28 <mauke> I'd like to see an infinite precision sqrt 5
10:55:28 <quicksilver> I'm not entirely sure what arbitrary precision floating point would look like
10:55:49 <quicksilver> you'd have to stop somewhere aor all your algorithms wouldn't reterminate
10:55:50 <nmessenger> me neither :D
10:56:00 <allbery_b> I thought there was already such a module, which was known to trigger a bug in nhc98 at the time (since fixed)
10:56:09 <nmessenger> arbitrary exponent precision?
10:56:25 <Cale> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 10 in (phi ^ n - (-phi) ^^ (-n)) / sqrt 5
10:56:26 <lambdabot>  4.5066996336778066e213
10:56:27 <nmessenger> fixed mantissa (is that what it's called?)
10:57:07 <fantasma> > let phi = (1 + sqrt 5) / 2; n = 2 ^ 10 in length . show $ (phi ^ n - (-phi) ^^ (-n)) / sqrt 5
10:57:08 <lambdabot>  22
10:58:29 <roconnor> > let f 0 = [(1*), (2*), (5*)]; f _ = [(1*), (2*), (\x->5*x `div` 2), (5*)] in [y (10^x) | x<-[(0::Integer)..], y<- f x] :: [Integer]
10:58:31 <lambdabot>  [1,2,5,10,20,25,50,100,200,250,500,1000,2000,2500,5000,10000,20000,25000,500...
10:58:51 <quicksilver> nmessenger: ah yes, that would be easy enough to implement
10:59:03 <sjanssen> @keal
10:59:03 <lambdabot> i think i know what code does but code looks to simple to actually do it
10:59:08 <quicksilver> there are also librarys for real arithmetic
10:59:17 <quicksilver> that involves pretty clever stuff and is therefore slow
10:59:31 <ehird> anyone?
10:59:35 <fantasma> which code lambdabot
10:59:43 <nmessenger> quicksilver: so for example sqrt 2 isn't reduced in the middle of the calculation?
10:59:47 <fantasma> @keal
10:59:48 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
10:59:54 <roconnor> > let f 0 = map (*) [1,2,5]; f _ = [(1*), (2*), (\x->5*x `div` 2), (5*)] in [y (10^x) | x<-[(0::Integer)..], y<- f x] :: [Integer]
10:59:56 <lambdabot>  [1,2,5,10,20,25,50,100,200,250,500,1000,2000,2500,5000,10000,20000,25000,500...
11:00:10 <ehird> what the heck does @keal do
11:00:12 <ehird> @keal
11:00:12 <lambdabot> nsa prevent me from returning to math on efnet
11:00:22 <ehird> @keal
11:00:22 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
11:00:26 <fantasma> @fantasma
11:00:26 <lambdabot> Unknown command, try @list
11:00:32 <fantasma> @list
11:00:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:00:46 <quicksilver> nmessenger: you represent things as (infinite) lists of nested intervals, I believe
11:01:01 <nmessenger> ehird: you'd write functions to pull out the various elements and use pattern matching for each case.
11:01:02 <quicksilver> nmessenger: although the concrete details may not feel like that's what you're doing
11:01:04 <sjanssen> @help keal
11:01:05 <lambdabot> keal. Talk like Keal
11:01:15 <chessguy> ?seen keall
11:01:15 <lambdabot> I haven't seen keall.
11:01:18 <chessguy> ?seen keal
11:01:18 <lambdabot> I saw keal leaving #haskell 6d 10h 45m 17s ago, and .
11:01:25 <sjanssen> ehird: keal is this crazy guy that used to spend time in #haskell
11:01:27 <nmessenger> keal was here?!
11:01:30 <sjanssen> 6 days?!
11:01:34 <jfoutz> @slap jfoutz
11:01:35 <lambdabot> why on earth would I slap jfoutz
11:01:37 <ehird> nmessenger: i'm writing the functions to pull out elements her e:)
11:01:47 <ehird> but i'm not sure how to do the specific pattern matching
11:01:52 <nmessenger> ehird: you're asking how to write them?
11:01:59 <ehird> (yaht likes asking you to do things that you have no idea how to yet)
11:02:45 <ehird> yes, pretty much nmessenger
11:03:08 <hpaste>  nmessenger annotated "how could i access the elements with this?" with "pattern-matching on Tuples" at http://hpaste.org/617#a1
11:03:32 <quicksilver> nmessenger: if you're intrested, do a web search on 'computable reals'
11:03:50 <fantasma> i'll give someone here a dollar if they can write code to find the number of digits in the 2^20th number in the fibonacii sequence
11:03:55 <nmessenger> not very interested, no :)
11:04:16 <mauke> fantasma: is that an euler problem?
11:04:28 <fantasma> mauke, no it's not
11:04:33 <mauke> too bad
11:04:41 <fantasma> (im assuming you meant from the euler project)
11:04:42 <nmessenger> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in (length . show) (fib !! 2 ^ 20)
11:04:43 <lambdabot>  1
11:04:47 <nmessenger> :/
11:04:48 <ehird> nmessenger: thank you
11:04:55 <quicksilver> it's certainly a problem I've heard before :)
11:04:56 <ehird> that helps :)
11:04:57 <quicksilver> or, similar ones
11:05:10 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in (length . show) (fib !! (2 ^ 20))
11:05:12 <lambdabot>  Exception: stack overflow
11:05:15 * allbery_b guesses that did (fib !! 2) ^ 20
11:05:15 <fantasma> nmessenger, try it on your own compiler
11:05:21 <nmessenger> of course
11:05:27 * ehird hopes (Tuple a) works for any type...
11:05:32 <fantasma> i already tried that code and i only got it to work with 2^19
11:05:37 <norpan> haha
11:05:42 <norpan> increase the stack size
11:05:49 <fantasma> no idea how
11:05:55 * fantasma is noob of the week
11:05:55 <nmessenger> there has to be a strict way.
11:06:28 <fantasma> nmessenger, did it work on your compiler?
11:07:02 <nmessenger> I didn't try, but I'd guess it'd also overflow
11:07:10 <fantasma> yah =\
11:07:22 <fantasma> 2^19 took 3 minutes and 11 seconds
11:08:04 <nmessenger> *Main> let fib 0 = 1; fib 1 = 1; fib x = (fib $! x-1) + (fib $! x-2) in (length
11:08:04 <nmessenger> . show) (fib (2 ^ 20))
11:08:19 <nmessenger> (currently churning :D)
11:08:25 <nmessenger> overflow :(
11:08:39 * allbery_b running the zip version with enlarged stack
11:08:50 <nmessenger> of course, that wouldn't be tail recursive
11:08:51 <fantasma> would what norpan said "increasing the stack" work?
11:08:52 <allbery_b> (g4 macmini though, so may be a while :)
11:08:55 * nmessenger hits self
11:09:05 <allbery_b> +RTS -K16M
11:09:09 <allbery_b> for my initial attempt
11:09:26 <ehird> bah, it doesn't :(
11:09:33 <norpan> let fib a b 0 = a; fib a b n = seq a $ seq b $ fib b (a+b) (n-1) in fib 1 1 (2^20)
11:09:54 <nmessenger> ehird: more help on the Tuple thing?
11:09:59 <ehird> nmessenger: nope
11:09:59 <fantasma> churning :)
11:10:06 <ehird> i'll take the scenic route then try and make it smaller ;)
11:10:28 <norpan> where is my dollar?
11:10:32 <fantasma> fans are turning on :X
11:10:51 <fantasma> norpan, give it a sec
11:10:53 <nmessenger> fantasma:  :D!
11:11:31 <fantasma> if 2^19 took 3 minutes
11:11:33 <norpan> oh yeah, and do length . show
11:11:34 <sjanssen> @paste
11:11:34 <hpaste>  ehird annotated "how could i access the elements with this?" with "Odd error" at http://hpaste.org/617#a2
11:11:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:11:39 <norpan> to get the number of digits
11:11:42 <fantasma> 2^20 should take?
11:11:46 <fantasma> shit
11:11:50 <nmessenger> norpan: perhaps it is an internet dollar?
11:11:58 <norpan> 2^20 should take double the time
11:12:27 <ehird> Oh, I see.
11:12:31 <fantasma> ok i will start again, this time with length . show
11:12:34 * ehird adds Just
11:12:41 <sjanssen> 3 minutes to compute 2^20th fib?
11:12:42 <ehird> No dice.
11:12:45 <Cale> 219139 digits, btw.
11:12:47 <sjanssen> you need to use a better algorithm
11:12:49 <ehird> adding Just to the values doesn't work
11:13:05 <fantasma> sjanssen, i dont know any other algorithm
11:13:08 <nmessenger> ehird: oh?  Did you type the functions as returning Maybe a?
11:13:14 <ehird> nmessenger: Yep
11:13:17 <ehird> See my paste
11:13:26 <ehird> Changing c, etc to Just c doesn't work either
11:13:29 <ehird> (forgot to do that)
11:13:41 <fantasma> Cale, what processor do you have?
11:13:45 <allbery_b> don't all the Tuple ... need to be Tuple a b c d, not jus Tuple a / Tuple a b / etc.?
11:13:52 <Cale> fantasma: 2.4 GHz P4
11:13:58 <nmessenger> ehird: each Tuple in the sigs must have all four type variables
11:13:58 <fantasma> ah
11:14:08 <hpaste>  sjanssen pasted "this computes fibo 2^20 in less than a second" at http://hpaste.org/618
11:14:15 <ehird> nmessenger: ah, thanks
11:14:16 <fantasma> Cale, how long did it take
11:14:36 <Cale> 0.1 seconds.
11:14:37 <ehird> Works now
11:14:42 <ehird> Just a bit slow though
11:14:45 <ehird> :P
11:15:01 <fantasma> Cale, with the same code that norpan posted??
11:15:09 <Cale> no
11:15:13 <ehird> I hope ghc optimizes pattern matchers into seperate functions instead of matching each time...
11:15:14 <fantasma> oh
11:15:26 <arcatan> horray for binary matrix exponentation, or whatever that is called
11:15:29 <nmessenger> Cale: the contant-time fib algorithm? :)
11:16:00 <nmessenger> I remember it had a big fraction, and a bunch of (sqrt 5)'s
11:16:03 <mauke> it's 219140 digits here
11:16:05 <jfoutz> @type .&.
11:16:07 <lambdabot> parse error on input `.&.'
11:16:07 <fantasma> sjanssen/cale do you know the name of the algorithm that you were using? so that I may look it up
11:16:38 <allbery_b> :t (.&.)
11:16:39 <arcatan> mauke:
11:16:41 <lambdabot> forall a. (Bits a) => a -> a -> a
11:16:44 <arcatan> oops, nothing
11:16:47 <mauke> Cale: what is fib 12 in your algorithm?
11:16:50 <ehird> > let a = x; x = a in x ++ a
11:16:51 <lambdabot>  Exception: <<loop>>
11:16:56 <ehird> > let a = x; x = a in show x
11:16:57 <norpan> bah i still want a dollar, there were no special rules about running time
11:16:58 <lambdabot>  Exception: <<loop>>
11:17:04 <Cale> mauke: 144
11:17:04 <jfoutz> thanks allbery_b
11:17:09 <arcatan> hmm, it's 219140 here too
11:17:23 <Cale> fib 0 = 0
11:17:41 <mauke> Cale: then why do you get 219139?
11:18:00 <nmessenger> geh, I forgot the length . show, so my console got royally spammed :)
11:18:06 <Cale> oh, oops
11:18:16 <Cale> yeah, off by one in counting the digits
11:18:27 <arcatan> you counted them by hand? :)
11:18:27 <Cale> 219140
11:18:33 <norpan> i got it using my function in 5 min 57 seconds
11:18:44 <norpan> that's fast enough
11:18:47 <allbery_b> still chugging here
11:18:54 <nmessenger> see closed form: http://en.wikipedia.org/wiki/Fibonacci_number
11:18:56 <allbery_b> but hey, it's a toy machine :)
11:19:01 <mauke> 39 seconds using my own program
11:19:27 <hpaste>  ehird annotated "how could i access the elements with this?" with "...Odder error" at http://hpaste.org/617#a3
11:19:38 <sjanssen> fantasma: here is quick, simple algorithm: http://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form
11:20:07 <mauke> ehird: did you mean Maybe (Tuple a b c d)?
11:20:36 <ehird> Actually, haskell now says it should be `Tuple (Maybe b) (Maybe c) (Maybe d) d1'
11:20:38 <ehird> Which makes sense.
11:21:03 <ehird> if only I knew what d1 was.
11:21:12 <mauke> an unknown type
11:21:20 <ehird> Ah.
11:21:27 <mauke> it could be anything
11:21:29 <ehird> Hmm, how do I make a type show-able?
11:21:42 <nmessenger> deriving (Show) on the data decl
11:21:44 <mauke> data whatever ... deriving (Show)
11:21:57 <arcatan> how does that deriving thingy work?
11:22:03 <mauke> magic
11:22:13 <arcatan> okay, makes sense
11:22:14 <mauke> (it's built into the compiler)
11:22:22 <nmessenger> arcatan: the report describes the code it should generate
11:23:01 <ehird> Tuple.hs:5:0: parse error on input `deriving'
11:23:10 <ehird> ah, it was the indentation
11:23:17 <ehird>     Ambiguous type variable `d1' in the constraint:      `Show d1' arising from use of `show' at Tuple.hs:30:18-50
11:23:22 <ehird> ho hum, it doesn't like that =P
11:23:30 <mauke> what's line 30?
11:23:37 <ehird> main = putStrLn $ show (tupleTail (Tuple4 1 2 3 4))
11:23:39 <nmessenger> arcatan: http://www.haskell.org/onlinereport/derived.html
11:23:40 <lambdabot> Title: The Haskell 98 Report: Derived Instances
11:23:52 <arcatan> okay, thanks
11:24:04 <mauke> main = print (tupleTail (Tuple4 1 2 3 4) :: Tuple Int Int Int ())
11:25:40 <nmessenger> the Tuple type has to have four types specified, but values may not have all those types, so you add a dummy type when you know it's not used.
11:26:19 <kc5tja> So, XPCOM's owner is royally pissing me off to the point of considering firebombings.
11:26:55 <kc5tja> He's refused the patch I sent *AGAIN*, because blah/blah/symlink -> blah/blah/blah/blah/realFile "isn't handled."
11:26:58 <kc5tja> HUH?!
11:27:07 <kc5tja> That's what the #&$@(%& operating system is for, jackass!
11:27:13 <kc5tja> Grrrr....
11:27:14 <kc5tja> >:(
11:27:18 <chessguy> ahem
11:27:26 <chessguy> let's keep the language clean, please
11:27:28 <mauke> even on windows?
11:27:41 <allbery_b> windows doesn't have them so no issue
11:27:42 <kc5tja> chessguy: Jackass isn't dirty -- jackass == donkey.
11:27:48 <allbery_b> (ignoring reparse point hackery)
11:28:08 <mauke> ok, .lnk files
11:28:28 <kc5tja> Windows 2000 introduced Posix-style symbolic links, as I recall, but they're not generally used.
11:28:30 <ehird> mauke: hm how does that work?
11:28:41 <nmessenger> @bot Darnit I'm angry and I need someone to screem at!
11:28:41 <lambdabot> :)
11:28:49 <nmessenger> @bot You always make me feel better.
11:28:50 <mauke> ehird: it tells it that d1 = ()
11:28:50 <lambdabot> :)
11:28:52 <allbery_b> meanwhile, it strikes me that in an application like mozilla, security requires handl;ing such things internally
11:28:57 <mauke> ehird: which it knows how to "show"
11:28:58 <kc5tja> Even so, those are handled in a totally separate source file, so the Windows maintainers would be responsible for fixing those bugs.
11:29:06 <allbery_b> did you consider asking the XPCOM maintainer what exactly is needed and why?
11:29:22 <kc5tja> allbery_b: It's self-evident from the bug report history.
11:29:26 <ehird> @paste
11:29:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:29:46 <kc5tja> I provided a patch that completely alleviated the situation.  The patch is considered even to be "ideal" by many in the bug history.
11:29:57 <hpaste>  ehird pasted "less than three errors! I mean, wait, no" at http://hpaste.org/619
11:29:59 <DRMacIver> Hm. I heard a while ago that HAppS had some sort of commercial backing. Is this actually the case or am I imagining it? (I can't find anything on google).
11:30:09 <kc5tja> But the owner is, like, "No; I'm just going to invent random reasons why it won't work, without actually *testing* that it does work, so bugger off."
11:30:31 <nmessenger> ehird: oops, those should be (Maybe Int)s
11:32:06 <emu> is there anyone working on Cabal/deb integration?
11:32:20 <liquidengineer> can I give a random generator a floating point seed?
11:32:49 <nmessenger> liquidengineer: why do you need to be that specific about the seed?
11:32:53 <Cale> Okay, I have haskell code which computes length . show $ fib (2^20) in 5.18 seconds
11:32:57 <malsyned> emu: I heard yesterday that John Goerzen had something.
11:33:04 <Cale> Which is considerably slower than mathematica, but still not bad :)
11:33:07 <Cale> !paste
11:33:08 <hpaste> Haskell paste bin: http://hpaste.org/
11:33:11 <mauke> I can beat that
11:33:17 <malsyned> You might ask him, or Igloo.  They maintain most of the debian haskell packages if I'm not mistaken.
11:33:20 <liquidengineer> nmessenger: I want to make a type Seed = Int statement so I can make more readible function signitures
11:33:20 <mauke> fib = const "...very long string..."
11:33:31 <hpaste>  Cale pasted "fib" at http://hpaste.org/620
11:33:40 <nmessenger> @slap mauke
11:33:41 * lambdabot slaps mauke
11:33:50 <mauke> @shapr nmessenger
11:33:51 * lambdabot slaps nmessenger
11:33:52 <malsyned> (Igloo == Ian Lynagh, I believe)
11:33:52 <liquidengineer> nmessenger: right now my wrapper function for the random generator takes seeds as Int
11:34:00 <Cale> could be cleaned up using where
11:34:01 <liquidengineer> I'm afraid this will cause a problem.
11:34:54 <ibid> emu: cabal deb, if ever implemented, could not be very well be used to do create official debian packages, so i doubt it's as useful as cabal rpm would be
11:34:57 <nmessenger> you might turn floating points into int via truncation, rounding, etc.
11:35:04 <ibid> emu: unofficial packages one could do, of course
11:35:20 <malsyned> ibid: why couldn't it be used to create official debian packages?
11:35:23 <liquidengineer> I guess what I'm asking is this:
11:35:30 <liquidengineer> Num is all numbers, Integers and Floats
11:35:35 <liquidengineer> is there a class just for Ints/Integers?
11:35:40 <emu> well i'm not looking to automatically create packages so much as ensure that packages I do create integrate with existing haskell infrastructure
11:35:42 <malsyned> liquidengineer: Integral
11:35:42 <nmessenger> Integral
11:35:51 <hpaste>  Cale annotated "fib" with "refactor" at http://hpaste.org/620#a1
11:36:08 <Cale> oh, we can share a little more...
11:36:42 <ibid> malsyned: because there is a set workflow for it that cabal deb would fit badly
11:36:51 * chessguy watches Cale refactor to fibs = 1:1:zipWith (+) fibs (tail fibs)
11:36:54 <jfoutz> (2 * f1 + f2) * (2 * f1 - f2) could be where'd
11:37:08 <liquidengineer> and what's the type of randomRs?
11:37:15 <Cale> meh, doesn't save any time to share the 2 * f1's
11:37:16 <nmessenger> @type randomRs
11:37:19 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
11:37:26 <Cale> probably it's being caught by CSE anyway
11:37:31 <malsyned> ibid: couldn't a hypothetical "cabal deb" be used to create the .diff and .dsc files?
11:37:33 <ibid> emu: well, there is that sort of cabal intgration to debian packaging
11:37:43 <Cale> Now let's try compiling the program :)
11:37:46 <ibid> malsyned: from what source?
11:37:51 <jfoutz> ah. i thought you were going for code size.
11:37:55 <nmessenger> > randomRs (0, 1 :: Double) (mkStdGen 42)
11:37:57 <lambdabot>  [0.11040701265689151,0.8453984927258916,0.30778213446209723,0.78138808260704...
11:38:08 <malsyned> ibid: pkgname.cabal in the source from the .orig.tar.gz
11:38:16 <liquidengineer> okay
11:38:16 <Cale> cale@zaphod:~$ time ./fib
11:38:16 <Cale> 219140
11:38:16 <Cale> real    0m1.147s
11:38:16 <Cale> user    0m1.116s
11:38:16 <Cale> sys     0m0.020s
11:38:23 <Cale> :)
11:38:23 <liquidengineer> so, I have to give a seed as an Int
11:38:27 <liquidengineer> I suspected this
11:38:37 <Cale> not bad, eh?
11:38:38 <ibid> malsyned: you could use that to create an initial package, but it won't work for maintenance
11:38:49 <malsyned> I don't mean that it could be automated within a debian package build system, but surely it could be arranged that the maintainer had only to run a script on an upstream source to turn it into a debian source package.
11:38:53 <nmessenger> liquidengineer: also: fmap (randomRs (0, 1::Double) newStdGen -- if you want IO
11:39:00 <ibid> malsyned: unless it's really, really smart (which usually translates to really, really bad, unfortunately)
11:39:02 <mauke> what's the complexity of this algorithm?
11:39:04 <nmessenger> (oops, missed a right paren)
11:39:12 <ibid> malsyned: well, that we do already have
11:39:15 <nmessenger> > fmap (randomRs (0, 1::Double)) newStdGen
11:39:17 <lambdabot>  <IO [Double]>
11:39:38 <Cale> I suspect it's bounded by the number of bits of the result.
11:39:40 <malsyned> really?  what's it called?  where does it live?  I want to play!
11:40:01 <allbery_b> you can alien an rpm
11:40:02 <malsyned> I bet emu does too
11:40:09 <hpaste> ?users
11:40:10 <lambdabot> Maximum users seen in #haskell: 328, currently: 319 (97.3%), active: 55 (17.2%)
11:40:15 <Cale> (a constant multiple of those)
11:40:26 <ibid> malsyned: note that i personally dislike the "throw dh-make/whatever at the upstream source and see if it sticks" camp of packaging
11:40:28 <Cale> hmm...
11:40:40 <ibid> malsyned: but as a starting point, it can work, if the packager is competent
11:40:43 <Cale> well, it really depends mostly on the cost of multiplication
11:42:02 <emu> there doesn't seem to be much activity on alioth re haskell
11:42:10 * nmessenger wonders why "randomRsIO rng = fmap (randomRs rng) newStdGen" isn't in the libs.
11:42:37 <malsyned> ibid: sure.  there's always danger in tools that are sortof reliable.  it's like the wizard effect: you get a bunch of boilerplate that you are responsible for but aren't actually qualified to miantain.
11:42:50 <ibid> emu: and that matters because...?
11:42:53 <malsyned> but as you say, as a starting point it can automate a bunch of grunt work.
11:42:57 <ibid> emu: there is the debian-haskell list
11:43:02 <emu> well, where is everyone?
11:43:14 <ibid> emu: doing the work :)
11:43:22 <emu> great, where can i read what they've done?
11:43:26 <malsyned> seriously, though - what's the name of said semi-automatic script and where can I get it?
11:43:26 <ibid> emu: quite a lot of us are on this channel :)
11:43:33 <ibid> malsyned: looking
11:43:37 <malsyned> ibid: thx
11:44:38 <ibid> emu: then there is that mailing list
11:44:45 <emu> yep, taking a looksee now
11:44:49 <ibid> emu: there is no organized project afaik, if that's what you mean
11:45:02 <ibid> and i think i like it that way :)
11:45:12 <ibid> emu: there used to be something on the old wiki
11:45:23 <emu> there's a haskell-policy document drawn up, is that still valid?
11:45:36 <malsyned> Can anyone give me an idea of what features of hugs might make it more suitable for some purposes than ghc/ghci?
11:45:48 <ibid> emu: it's not official, at least
11:45:57 <ibid> emu: it can be a useful starting pint
11:46:05 <emu> sounds good
11:46:09 <chessguy> wow
11:46:11 <ibid> emu: suggest you ask on the list :)
11:46:11 <nmessenger> malsyned: I think the bytecode interpreter is faster than ghci
11:46:18 <chessguy> i've never gotten that message from gmail before
11:46:20 <allbery_b> for some things it is
11:46:20 <chessguy> "Arrgh! The page has been corrupted. If you are running security or firewall software, you may have to disable it"
11:46:33 <ibid> malsyned: hugs is c and therefore easier to port
11:47:14 <malsyned> interesting.  thanks guys.
11:49:02 <liquidengineer> Hmm
11:49:10 <liquidengineer> I've run into a bit of a conundrum
11:49:11 <ibid> malsyned: can't find an actual tool, but look at haskell-devscripts and http://www.n-heptane.com/nhlab/repos/cabalDebianTemplate/
11:49:12 <lambdabot> Title: Index of /nhlab/repos/cabalDebianTemplate
11:49:16 <liquidengineer> how do I get to the pastebin?
11:49:22 <allbery_b> @paste
11:49:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:49:26 <emu> heh, just found that site as well
11:49:32 <glguy> !paste, @paste, ?paste, hpaste: url
11:49:32 <hpaste> Haskell paste bin: http://hpaste.org/
11:50:53 <hpaste>  LiquidEngineer pasted "Random stuff" at http://hpaste.org/621
11:50:57 <fantasma> this is one of the greatest channels i've been in for support ;) thanks guys
11:50:57 <malsyned> ibid: cool, thanks
11:51:18 <Cale> fantasma: we do try :)
11:51:31 <liquidengineer> That code works so far as it gives me a random list of the size I asked for
11:51:45 <liquidengineer> but I can't figure out how to get it to give me different numbers without changing the seed
11:51:56 <liquidengineer> I know it works by making a stream of random numbers
11:52:03 <liquidengineer> can I somehow drop off the ones I just took?
11:52:11 <allbery_b> you need to return the new seed
11:52:13 <mauke> huh? I thought that's the point of having a seed: you can reproduce the numbers
11:52:13 <Cale> liquidengineer: uh, that's the whole point of the seed
11:52:15 <fantasma> ...and I guess that's a direct result of having such a fun languague to work with ;D
11:52:22 <allbery_b> or wrap the whole thing in a State which maintains the seed
11:52:35 <liquidengineer> ah.
11:52:38 <chessguy> (or just maintains the infinite list)
11:52:44 <nmessenger> putting the RNG in the State'd be easier.
11:52:49 <liquidengineer> So I *do* have to do it myself
11:53:00 <Cale> liquidengineer: There are monads which keep track for you.
11:53:05 <liquidengineer> I know how to do that...I just wanted to make sure I wasn't missing something obviouqs.
11:53:05 <Cale> Including IO.
11:53:19 <liquidengineer> Thanks. :)
11:53:22 <Cale> If you don't want to write things in the IO monad, I have a nice Random monad.
11:53:59 <nmessenger> Cale: does Random = State StdGen + helper functions?
11:54:20 <glguy> MonadRandom (RandomT) is pretty slick
11:54:21 <Cale> nmessenger: essentially
11:54:24 <Cale> http://haskell.org/haskellwiki/New_monads/MonadRandom
11:54:25 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
11:54:28 * xerox agrees
11:55:01 <xerox> It's amazingly well-working in Nymphaea (-:
11:55:05 <Cale> yeah :)
11:55:53 <nmessenger> heh, StateT StdGen Identity :)
11:56:31 <xerox> Yeah, Cale has got some theory about Good Monad Design (tm).
11:57:04 <hpaste>  fuzan pasted "stata monad, again." at http://hpaste.org/622
11:57:21 <sjanssen> Chief Monad Architect would be an awesome job title
11:57:21 <hpaste>  (anonymous) annotated "stata monad, again." with "(no title)" at http://hpaste.org/622#a1
11:58:05 <fuzan> I'm still trying to get this working. I have a suspcicion that I'm not aware of how to pass the state monad around,
11:58:24 <xerox> It mostly pass itself around.
11:58:48 <fuzan> That's what I thought, however, can't seem to understand what's causing this exception.
12:00:48 <fantasma> how can I input something with haskell at run time like ./program value
12:01:36 <fuzan> :t getArgs
12:01:39 <lambdabot> Not in scope: `getArgs'
12:02:00 <fuzan> :t System.getArgs
12:02:03 <lambdabot> IO [String]
12:02:58 <fuzan> fantasma: that help?
12:03:00 <xerox> :t System.Environment.getArgs
12:03:03 <lambdabot> IO [String]
12:03:07 <fantasma> fuzan, yah thank you
12:03:19 <fantasma> > getArgs
12:03:20 <lambdabot>   Not in scope: `getArgs'
12:03:33 <fantasma> > System.getArgs
12:03:34 <lambdabot>   Not in scope: `System.getArgs'
12:03:44 <nmessenger> > print . sum . map read =<< getArgs
12:03:45 <lambdabot>   Not in scope: `getArgs'
12:03:51 <fuzan> it's probably not functional via lambdabot.
12:04:04 <LordBrain> @type System.getArgs
12:04:07 <lambdabot> IO [String]
12:04:13 <LordBrain> oh you already did that
12:04:36 <LordBrain> sorry too many windows
12:04:37 <xerox> import System.Environment (getArgs)
12:04:37 <xerox> main = do args <- getArgs
12:04:37 <xerox>           case args of [] -> usage; xs -> parse xs
12:04:55 <nmessenger> (where you define parse to do what you want)
12:05:25 <xerox> usage :: IO (), parse :: [String] -> IO ()
12:05:33 <nmessenger> parse ["--help"] = usage; parse ["-i", file] = doWithInputFile file
12:05:48 <xerox> There also is the possibility to use getopt, but I am not too fond of that.
12:06:00 <xerox> I think you can grab some example from dons' programs.
12:06:20 <nmessenger> GetOpt provides full unixy-style argument parsing, so it's a little big.
12:06:56 <stmartin> Why does ghci let me enter 'let x = 1' at the Prelude> prompt, but hugs doesn't let me enter the same thing at the Hugs> prompt? Hugs says there is a syntax error (unexpected end of input)
12:07:06 <ehird> back
12:07:10 <ehird> who said something :P
12:07:16 <stmartin> (extensions are off on both)
12:07:21 <fantasma> all i want to input is a number so I will try getArgs
12:07:35 <fantasma> ehird, how are you learning haskell
12:07:37 <ehird> i guess nobody
12:07:38 <xerox> starfruit: hugs does not support binding.
12:07:42 <nmessenger> stmartin: that's a special feature of ghci
12:08:02 <xerox> fantasma: italiano?
12:08:12 <fantasma> spanish
12:08:17 <xerox> @arr
12:08:18 <lambdabot> Aye Aye Cap'n
12:08:42 <stmartin> so ghci without any parameters is _not_ standard Haskell 98?
12:08:45 <nmessenger> fantasma: getArgs gives you a list of strings, you can use read to turn them into integers, and head to get the first one if you want to do that.
12:08:51 <ehird> fantasma: yaht + much personal experimentation
12:09:07 <fantasma> ehird, yaht is a book? tutorial?
12:09:15 <ehird> ?where yaht
12:09:15 <nmessenger> er, an *action* resulting in a list of strings.
12:09:15 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
12:09:17 <stmartin> fantasma: I'm also using yaht
12:09:22 <ehird> i'm using the wikibook yaht
12:09:28 <ehird> with a skin i adapted form the haskell wiki
12:09:30 <fantasma> OHHHH
12:09:31 <kc5tja> fantasma: Heh, both.  :)
12:09:31 <ehird> to make wikibooks readable ;)
12:09:35 <fantasma> yet another haskell tutorial!!
12:09:40 <fantasma> = yaht
12:09:42 <ehird> um, duh :P
12:09:50 <fantasma> me too if that's the case
12:10:01 <nmessenger> ehird: does your client still do pdf previews?  Or was that you?
12:10:04 <ehird> (http://hpaste.org/619, in reply to whoever said to use :: Tuple Int Int Int ())
12:10:08 <ehird> nmessenger: yes, it does, hehe
12:10:15 <nmessenger> ehird: turn it off!
12:10:19 <nmessenger> evil!
12:10:30 <ehird> i can't
12:10:37 <ehird> :/
12:11:01 <Knio> if I have data A = B and data C = A | D, is B not a type of C?
12:11:03 <ehird> http://elliotthird.org/Picture%201.png <-- Evil in action
12:11:04 <LordBrain> stmartin, ghci in interactive mode wraps everything in a do
12:11:40 <stmartin> LordBrain: thank you. That makes sense I suppose.
12:12:01 <nmessenger> Knio: 'B' is a value in the A type, 'A' and 'D' are values in the 'C' type.
12:12:34 <Knio> so the A in C does not represent the type A?
12:12:43 <kscaldef>  Knio: you're mixing up type constructors and data constructors
12:12:47 <abcde`> http://haskell.org","Paste turns into an URL. nice.
12:12:55 <nmessenger> Knio: nope, the first name is a constructor, names after that are constituent types.
12:13:00 <Knio> hmm
12:13:03 <mauke> nmessenger: how big? getopt in C is about 40 lines
12:13:06 <kscaldef> they are in different namespaces
12:13:18 <tibbe> I'm in need of some pointers on HXT, anyone?
12:13:23 <nmessenger> mauke: big as in it looked scary when I first saw it :)
12:13:37 <LordBrain> big as in source or as in binary?
12:13:49 <nmessenger> big was the wrong word to use.
12:13:52 * xerox hands tibbe a pointy arrow pointer
12:14:04 <LordBrain> ok
12:14:23 <monochrom> good morning lambdabot
12:14:26 <tibbe> xerox, something like that :)
12:14:45 <tibbe> xerox, I want to parse xml and actual get it out into a haskell value not just new xml!
12:14:50 <hpaste>  LiquidEngineer pasted "Gaurd clause problem" at http://hpaste.org/623
12:15:05 <nmessenger> Knio: you can have data C = SomeA A | D, then (SomeA B) has type C
12:15:14 <xerox> tibbe: I guess you want |getElem|
12:15:27 <liquidengineer> I've got this gaurd clause giving me a non-exhaustive patterns message
12:15:39 <liquidengineer> but I know I've covered all the patterns that will ever exist
12:15:49 <liquidengineer> what can I do to get rid of the exception?
12:16:02 <nmessenger> liquidengineer: you could change the last guard to 'otherwise'
12:16:19 <nmessenger> liquidengineer: and it's just a warning, it'll still compile fine.
12:16:28 <liquidengineer> I thought I used an otherwise
12:16:29 <liquidengineer> otherwise = []
12:16:30 <xerox> tibbe: oh I had it wrong, getChildren >>> getText, for example, extracts the information.
12:16:44 <nmessenger> youFunction | otherwise = []
12:16:49 <doserj> liquidengineer: you should match on []
12:16:52 <LordBrain> put | otherwise = error "AAAAAGH!"
12:16:58 <tibbe> xerox, as text or as a text node?
12:17:11 <monochrom> All of you are wrong.
12:17:26 <nmessenger> > "AAGH!" >>= replicate 5
12:17:28 <lambdabot>  "AAAAAAAAAAGGGGGHHHHH!!!!!"
12:17:35 <LordBrain> lol
12:17:42 <xerox> It spits out Strings to me.
12:17:55 * xerox vanishes
12:17:56 <tibbe> ok
12:18:04 <nmessenger> @slap monochrom
12:18:05 * lambdabot slaps monochrom
12:18:10 <liquidengineer> wait a secodn
12:18:25 <liquidengineer> how do I match on an empty list and have the gaurds?
12:18:28 <liquidengineer> I didn't think I could do that
12:18:34 <monochrom> doserj is right.  The warning is about lacking "intsToProg [] = ...".  But nmessenger is right in that  you can ignore warnings.
12:18:46 <liquidengineer> Oh
12:18:52 <liquidengineer> I didn't know you could do that
12:19:23 <liquidengineer> Very nice.
12:19:23 <liquidengineer> :D
12:19:31 <ehird> > "Hello, world!" >>= replicate 5
12:19:33 <lambdabot>  "HHHHHeeeeellllllllllooooo,,,,,     wwwwwooooorrrrrlllllddddd!!!!!"
12:19:35 <ehird> Someone tell me how that works.
12:19:43 <ehird> Specifically, what does >>= do
12:19:52 <ehird> > replicate 5 'A'
12:19:54 <lambdabot>  "AAAAA"
12:20:03 <glguy> ?src [] >>=
12:20:03 <lambdabot> Source not found. Wrong!  You cheating scum!
12:20:04 <ehird> > map (replicate 5 .) "Hello, world!"
12:20:05 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Char'
12:20:07 <glguy> ?src [] (>>=)
12:20:07 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:20:07 <ehird> :/
12:20:17 <glguy> ehird: that's what >>= for the [] Monad
12:20:24 <ehird> hm
12:20:25 <LordBrain> >>= is like concat map
12:20:28 <LordBrain> in this instance
12:20:32 <malsyned> > map (replicate 5) "Hello World"
12:20:34 <glguy> =<< is concatMap
12:20:34 <lambdabot>  ["HHHHH","eeeee","lllll","lllll","ooooo","     ","WWWWW","ooooo","rrrrr","ll...
12:20:38 <nmessenger> ehird: list's (>>=) is concatMap, so (x >>= f) = concatMap f x
12:20:40 <monochrom> tibbe: http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-2.xhtml may help
12:20:42 <chessguy> LordBrain, s/like //
12:20:45 <glguy> >>= is flip concatMap
12:20:56 <ehird> obscure
12:20:59 <ehird> :P
12:21:07 <Cale> ehird: only until you've seen it once
12:21:07 <glguy> ehird: you need to read up on Monads probably
12:21:18 <glguy> >>= is the monadic bind function
12:21:21 <ehird> glguy: i'm at chapter 3 or something of yaht
12:21:23 <nmessenger> ehird: not terribly.  (x >>= f) is always equal to (join (map f x))
12:21:28 <ehird> monads is chapter 7 or something
12:21:31 <nmessenger> s/map/fmap/
12:21:32 <ehird> you see? ;)
12:21:38 <Cale> ehird: right :)
12:21:42 <glguy> ehird: now you know what ot look forward to :)
12:21:46 <Cale> ehird: Just takes some time.
12:21:51 <ehird> glguy: madness?
12:21:57 <glguy> joy!
12:22:01 <ehird> and madness
12:22:02 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
12:22:13 <Cale> > Control.Monad.sequence [[1,2,3],[4,5],[6,7,8]]
12:22:15 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
12:22:20 <Cale> Somebody fix that!
12:22:21 <Cale> hehe
12:22:25 <ehird> > sequence 0
12:22:26 <glguy> ?get-dons
12:22:27 <lambdabot> Unknown command, try @list
12:22:29 <glguy> ?get-sorear
12:22:29 <lambdabot> Unknown command, try @list
12:22:37 <nmessenger> ehird: Int isn't a monad
12:22:40 <chessguy> ?get-shapr
12:22:40 <lambdabot> shapr!!
12:22:51 <ehird> nmessenger: i was trying random things :P
12:22:55 <ehird> ?get-ehird
12:22:55 <lambdabot> Unknown command, try @list
12:22:58 <Cale> I suppose I could theoretically fix it.
12:22:58 <ehird> ?get ehird
12:22:58 <lambdabot> shapr!!
12:23:04 <ehird> ?get ehird -> shapr!! heh
12:23:05 <lambdabot> shapr!!
12:23:09 <ehird> pff
12:23:09 <Cale> But I'm lazy!
12:23:12 <monochrom> ("blah" >>= replicate 5) = (do{ x<-"blah" ; replicate 5 x }) = [ y | x<-"blah", y <- replicate 5 x ]
12:23:22 <fantasma> n <- getArgs  ...is that correct syntax?
12:23:28 <monochrom> Yes
12:23:29 <mauke> fantasma: in a do block, yes
12:23:32 <nmessenger> fantasma: in a 'do' black yes
12:23:38 <nmessenger> heh
12:23:38 <ehird> anyway, anyone know why http://hpaste.org/619 happens?
12:23:41 <mauke> @quote stereo
12:23:42 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
12:23:42 <fantasma> lol
12:23:50 <glguy> ehird: because someone pasted 618 already
12:23:56 <nmessenger> the stereo thing should be in the topic
12:24:18 <mauke> ehird: oh, I got the type wrong
12:24:32 <monochrom> Because the computer is always right.
12:24:46 <ehird> glguy: No, more like because I pasted that and it contains an error
12:24:47 <mauke> it's something like Tuple (Maybe Int) (Maybe Int) (Maybe Int) ()
12:24:48 <ehird> :P
12:25:08 <glguy> ehird: I don't think we have enough information to help with that one, you'd need to paste more about tupleTail
12:25:18 <mauke> I think you should fix tupleTail, though
12:25:21 <ehird> tupleTail :: Tuple a b c d -> Tuple (Maybe b) (Maybe c) (Maybe d) d1               tupleTail t = Tuple3 (tuple2 t) (tuple3 t) (tuple4 t) <-- :P
12:25:24 <fantasma> can getArgs take an expression such as (2^3)
12:25:31 <nmessenger> glguy: see http://hpaste.org/617
12:25:32 <ehird> well, i'm not quite sure how tupleTail is broken, mauke
12:25:37 <monochrom> getArgs takes nothing
12:25:39 <mauke> ehird: all those Maybe's
12:25:44 <mauke> ehird: they shouldn't be in there
12:25:48 <ehird> it dies without them
12:25:56 <mauke> then it's broken
12:25:59 <fantasma> monochrom, ?
12:26:12 <nmessenger> fantasma: getArgs returns an IO [String], so you'd have to parse the strings to do that.
12:26:17 <monochrom> fantasma, ?
12:26:40 <glguy> tuple1 :: Tuple a -> a -- this is wrong
12:26:46 <glguy> tuple1 :: Tuple a b c d -> a
12:26:47 <fantasma> nmessenger, thanks and "parse" would do that yes?
12:26:50 <hpaste>  ehird annotated "less than three errors! I mean, wait, no" with "this happens... because tuple1,2,3,4 return Maybe a,b,c,d" at http://hpaste.org/619#a1
12:27:05 <nmessenger> fantasma: you'd have to write your own parsing function.
12:27:51 <glguy> fantasma: monochrom says that getArgs takes nothing because getArgs takes no arguments
12:27:55 <nmessenger> fantasma: which is probably not noob-easy
12:28:22 <fantasma> glguy, ah ok
12:28:57 <hpaste>  nmessenger annotated "less than three errors! I mean, wait, no" with "then return Maybe Int :P" at http://hpaste.org/619#a2
12:29:18 <fantasma> nmessenger, i see some code example's on dons site and he uses a parse function ``parse ["-h"]''
12:29:54 <hpaste>  mauke annotated "how could i access the elements with this?" with "better tupleTail" at http://hpaste.org/617#a4
12:29:59 <LordBrain> fantasma, what arguments are passed in depends on the shell, some things have to be escaped, and there's a limit on the length usually
12:30:08 <monochrom> Haskell questions these few days have really degraded.  People are asking vague, ill-defined questions, and worse, unable to concretize upon request.  It's like trying guess a baby's desire.
12:30:10 <nmessenger> fantasma: yep, he's defining a function there, for list containing "-h", he evaluates to the result given.
12:30:44 <kscaldef> monochrom: it's the curse of popularity
12:31:00 * glguy debates installing bitchx so he can do one of those /masskick s
12:31:14 <LordBrain> maybe we're so good at answering questions, that people are starting to attribute magical powers to us.
12:31:16 <glguy> I wonder how long that would take...
12:31:18 <glguy> ?users
12:31:18 <lambdabot> Maximum users seen in #haskell: 328, currently: 327 (99.7%), active: 52 (15.9%)
12:31:20 <LordBrain> :)
12:31:24 <jfoutz> monochrom every communty suffers eternal september.
12:31:24 <tibbe> is there a better way to write a long string literal than contatenating several smaller ones with ++ ?
12:31:26 <nmessenger> monochrom: in this case some of the clarifications have been made earlier
12:31:29 <emu> monochrom: i'm writing a haskell program. it does stuff.. can you help?
12:31:31 <tibbe> \ isn't much better
12:31:38 <glguy> seems like flood control would make 327 kicks take a while
12:31:57 <glguy> tibbe: concat [a,b,c,d,e]
12:31:57 <monochrom> You only need 322 kicks
12:32:10 <glguy> can a kick kick more than one person?
12:32:26 <emu> unwords [a,b,c,d] is also kinda nice
12:32:32 <glguy> I need 3 volenteers (I'll be one of the vicitms!)
12:32:40 * nmessenger raises hand
12:32:44 --- mode: ChanServ set +o glguy
12:32:44 <monochrom> > "This string is broken in-between\                \but is rejoined!"
12:32:46 <lambdabot>  "This string is broken in-betweenbut is rejoined!"
12:32:56 <monochrom> tibbe: try that trick.
12:32:58 <glguy> 2 more please
12:33:02 <emu> multi-line literal strings in haskell are, unfortunately, not the nicest
12:33:16 <monochrom> You can also have line breaks, not just spaces, between the two \'s.
12:33:16 <astrolabe> glguy: me!
12:33:32 * nmessenger raises monochrom's hand
12:33:41 <ehird> > "H\       I\             ello\          LIKE\          , world!\          CHEESE
12:33:42 <lambdabot>  Illegal character in string gap
12:33:43 <ehird> > "H\       I\             ello\          LIKE\          , world!\          CHEESE"
12:33:44 <lambdabot>  Illegal character in string gap
12:33:48 <ehird> bah
12:34:02 --- kick: nmessenger was kicked by glguy (astrolabe hpaste glguy)
12:34:03 <monochrom> You need a pair of \'s
12:34:05 <mauke> > "P\     \WND"
12:34:06 <LordBrain> > "H\           \ello"
12:34:06 <ehird> OH EM GEE
12:34:06 <jfoutz> >"H\   \l\   \ello"
12:34:07 <glguy> :(
12:34:07 <lambdabot>  "PWND"
12:34:08 <lambdabot>  "Hello"
12:34:12 <nmessenger> heh
12:34:16 <glguy> nmessenger: it put the nicks as the message
12:34:18 <glguy> bah
12:34:18 <astrolabe> > "H\       \I\             \ello\          \LIKE\          \, world!\          \CHEESE"
12:34:20 <nmessenger> *** you were kicked from #haskell by glguy (astrolabe hpaste glguy)
12:34:20 <lambdabot>  "HIelloLIKE, world!CHEESE"
12:34:29 <Philippa> isn't PWND a win32 API thing? As in, every windows app gets PWND?
12:34:29 --- mode: glguy set -o glguy
12:34:35 * glguy needs a good masskick scriptfirst
12:34:39 <ehird> Philippa: Yes.
12:34:41 <glguy> nmessenger++
12:34:46 <ehird> Win32->Window->PWND
12:34:52 <monochrom> I thought it was HWND
12:34:52 <ehird> Position Window (No Destructor)
12:34:55 <astrolabe> Have I really been kicked though?
12:35:09 <glguy> astrolabe: nope, I don't know that I can do that with irssi
12:35:12 <ehird> Win32->Window MyPwned = Win32->Window->PWNED
12:35:16 <nmessenger> astrolabe: that's what it said on my client
12:35:16 <ehird> Error: PWNED
12:35:19 <monochrom> Somehow nmessenger was kicked and astrolabe wasn't
12:35:26 <ehird> monochrom: yes.
12:35:30 <glguy> it used the last 3 words as a message
12:35:31 <ehird> the other nicks were the kick msg
12:35:32 <emu> because the arguments to kick are the "Reason" after the name
12:35:44 <nmessenger> yeppers
12:35:46 <emu> IRC doesn't support multi-target kicks directly afaik
12:35:51 <mauke> glguy: try /kick foo,bar,baz reason
12:35:54 <ehird> it doesn't support / commands eihter.
12:35:55 <LordBrain> the first nick would be the person you are kicking the rest are just the reason for kicking them
12:35:59 <monochrom> Haha
12:35:59 <ehird> it's really KICK #chan USER
12:36:07 <emu> kick #chan user :reason
12:36:08 <LordBrain> ah
12:36:09 <ehird> not /kick user reason....
12:36:10 <norpan> hey, are you still here
12:36:12 <ehird> emu: yes
12:36:17 <astrolabe> nmessenger: mine too
12:36:20 <monochrom> hey, i am still here
12:36:28 <norpan> hey, that's great
12:36:49 --- mode: ChanServ set +o glguy
12:36:56 --- kick: hpaste was kicked by glguy (glguy)
12:37:02 <glguy> , didn't work
12:37:15 <ehird> i don't think bots rejoin.
12:37:23 <nmessenger> ehird: glguy owns hpaste
12:37:28 <ehird> oh.
12:37:33 <ehird> that was obvious. i'm stupid
12:37:42 <ehird> please shoot me. thank you and have a nice day
12:37:48 * nmessenger shoots ehird
12:37:52 <ehird> thanks.
12:37:54 <glguy> I tried kicking myself and the bot at the same time, but it still treated the stuff after the comma as a message
12:38:02 --- mode: glguy set -o glguy
12:38:16 <monochrom> OK, so, nmessenger: some vague questions are concretized later, that's good.  I have in mind things like the runInteractiveProcess question on haskell-cafe.  "It works but it doesn't work, what gives?"  "OK so what do you want?"  "Like pipes."  He's so not getting the point.
12:38:25 <LordBrain> xchat has a menu selection which seems to suggest you can kick a mask
12:38:49 <SamB> LordBrain: oh really?
12:39:01 <LordBrain> like *!*@domain
12:39:02 <allbery_b> nope
12:39:07 <allbery_b> the mask applies to the "banb" part
12:39:15 <dylan_> I think /kick -yes * works in irssi
12:39:22 <LordBrain> oh i see
12:39:29 <dylan_> I know /op -yes * does
12:39:31 <LordBrain> i think mirc has mkick
12:39:37 <nmessenger> monochrom: yeah, but what can you do?  If a person doesn't understand the problem well they can either ask for help, or look up the answer if they know where to look.
12:39:37 <LordBrain> for mass kicking
12:39:47 <LordBrain> if memory serves... which it probably doesnt
12:39:52 <glguy> bitchx has functions for annihilating the channel
12:40:26 <nmessenger> the "if they know where to look" part is sometimes hard, and sometimes I'm just to lazy to look myself.  In those cases, I'd expect people to kick my butt.
12:40:47 <glguy> maybe we should pick a topic of the day, and refuse to answer all unrelated , ill-defined quetsions
12:40:54 <glguy> like today coudl be "70s hairstyles"
12:41:03 <deadhird> ./msg ChanServ clean #haskell
12:41:05 <deadhird> woooosh
12:41:14 <monochrom> Which 70s?  1970s?  1870s?  ...
12:41:16 <deadhird> er, at least it used to have that
12:41:18 <LordBrain> ambiguity is acceptable in the english langauge, as long as people do that clarifying part for you readily enough.... otherwise it is pretty annoying.
12:41:23 <deadhird> monochrom: 70 AD.
12:41:33 <glguy> monochrom: that's not a question about hairstyles, next question
12:41:40 <monochrom> haha
12:41:44 <deadhird> what 70s did they have in the hairstyles
12:41:45 <deadhird> i mean.
12:42:04 <glguy> What I want to know is, did the Beatles hairstyle make it into the 70s
12:42:08 <glguy> or was it stuck in the 60s
12:42:15 <astrolabe> ping Cale
12:42:18 * nmessenger considers /parting
12:42:59 <glguy> nmessenger: you might consider unsafePerformIO
12:43:01 <pitecus> I have a largish literal Map in a module and GHC is taking forever to compile it. Is there a better approach?
12:43:36 <glguy> how large is large?
12:43:45 <LordBrain> largish
12:44:05 <glguy> LordBrain: (I was trying to establish an upper bound ;) )
12:44:09 <LordBrain> oh ok
12:44:11 <LordBrain> :)
12:44:34 <deadhird> @src List
12:44:35 <lambdabot> Source not found. My mind is going. I can feel it.
12:44:42 <deadhird> :(
12:44:43 <pitecus> 100K keys
12:44:48 <pitecus> roughly
12:44:51 <LordBrain> whew
12:45:05 <deadhird> the better way is to abandon the project of having every atom in a map
12:45:21 <glguy> > logBase 2 100000
12:45:23 <lambdabot>  16.609640474436812
12:45:23 <monochrom> How could you write a literal Map?
12:45:33 <deadhird> Draw lines between places on the roads
12:45:38 <LordBrain> lol
12:45:41 <glguy> pitecus: you could write a parser and load the map at runtime
12:45:54 <glguy> pitecus: the parser wouldn't have to be complicated
12:46:08 <pitecus> glguy, ya that might work
12:46:12 <glguy> and if you could guarentee things about the initialization list, like it's order
12:46:13 <astrolabe> deadhird: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
12:46:16 <lambdabot> http://tinyurl.com/wfo7q
12:46:16 <glguy> you can speed up construction
12:46:18 <vagif> There's a code sample given here http://sequence.complete.org/node/249#comment
12:46:20 <vagif> sequence_ $ reverse [readFile "/tmp/x", writeFile "/tmp/y"]
12:46:20 <lambdabot> Title: Haskell is a first-class action language as well | The Haskell Sequence
12:46:29 <vagif> but it does not work
12:46:39 <nmessenger> (darnit, got disconnected)
12:46:40 <deadhird> astrolabe: was looking for the definition of the type
12:46:52 <glguy> vagif: you'd need to fold that with >>=
12:46:58 <glguy> vagif: which is not what sequence does
12:47:07 <nmessenger> glguy: unsafePerformIO is dangerous!  I got peered!
12:47:09 <astrolabe> deadhird: it is built in
12:47:14 <deadhird> astrolabe: darn
12:47:32 * nmessenger unshoots deadhird
12:47:37 <astrolabe> deadhird: but there is a pseudo-definition
12:47:41 <fuzan> http://hpaste.org/622#a1 , upon further examination it seems as if s is not of type Quiz, but of (MonadState Quiz m), shouldn't this not be true since the type of s is resultant from s <- get ?
12:47:54 <vagif> glguy: so what is the correct code in this case ?
12:47:57 <drihdaed> timewarp :(
12:48:01 <drihdaed> > head []
12:48:02 <lambdabot>  Exception: Prelude.head: empty list
12:48:10 <drihdaed> bah humbug
12:48:20 * drihdaed just makes it Nil
12:48:20 <glguy> ?type foldl1' (>>=) [readFile "x", writeFile "y"]
12:48:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
12:48:23 <lambdabot>       Expected type: (a -> a) -> (a -> a) -> a -> a
12:48:32 <glguy> OH
12:48:34 <nmessenger> drihdaed: so (car nil) = nil?
12:48:41 <glguy> vagif: no, you can't do that :)
12:48:46 <drihdaed> nmessenger: no
12:48:51 <glguy> ?type foldl1' (>>=) [\_ -> readFile "x", writeFile "y"]
12:48:51 <vagif> dang!
12:48:52 <mauke> > let nil = (nil, nil) in nil
12:48:54 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t1)
12:48:54 <lambdabot>       Expe...
12:48:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
12:48:54 <lambdabot>       Expected type: (a -> a) -> (a -> a) -> a -> a
12:48:56 <drihdaed> so head (Nil) = Nil
12:49:00 <monochrom> vagif: don't bother with it.
12:49:08 <astrolabe> deadhird: section 6.13 http://www.haskell.org/onlinereport/basic.html
12:49:09 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
12:49:20 <drihdaed> astrolabe: i don't know of this "deadhird"
12:49:40 <drihdaed> @src head
12:49:40 <lambdabot> head (x:_) = x
12:49:40 <lambdabot> head []    = undefined
12:49:43 <drihdaed> hah!
12:49:51 <drihdaed> undefined
12:49:56 <drihdaed> does that really exist as a value?
12:50:06 <nmessenger> nope, it's _|_
12:50:08 <LordBrain> its often called bottom in the literature
12:50:21 <drihdaed> hah
12:50:21 <nmessenger> > undefined
12:50:23 <lambdabot>  Undefined
12:50:26 <drihdaed> o rly?
12:50:27 <mauke> > length [undefined]
12:50:28 <drihdaed> > tail []
12:50:29 <lambdabot>  1
12:50:29 <lambdabot>  Exception: Prelude.tail: empty list
12:50:33 <astrolabe> @type undefined
12:50:36 <lambdabot> forall a. a
12:50:43 <nmessenger> > undefined :: ()
12:50:44 <lambdabot>  Undefined
12:50:46 <drihdaed> undefined does exist then
12:51:01 <nmessenger> drihdaed: not *really*, but kinda sorta
12:51:05 <drihdaed> @src fldl
12:51:06 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:51:07 <LordBrain> i've seen it used to do some fun stuff
12:51:08 <drihdaed> @src foldl
12:51:08 <lambdabot> foldl f z xs = lgo z xs
12:51:09 <lambdabot>     where lgo z []     =  z
12:51:09 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:51:16 <astrolabe> It sort of does and sort of doesn't.  Is that vague enough?
12:51:27 <drihdaed> No.
12:51:41 <nmessenger> > undefined :: Tree (StateT Int [] Double)
12:51:42 <lambdabot>        add an instance declaration for (Show (StateT Int [] Double))
12:51:43 <astrolabe> You can use it in code, but you shouldn't evaluate it I guess.
12:51:55 <mauke> @src undefined
12:51:56 <lambdabot> undefined =  error "Prelude.undefined"
12:51:58 <LordBrain> like i saw somewhere a binary tree which is constrained statically where possible and dynamically where not.
12:52:02 <nmessenger> drihdaed: undefined = undefined :)
12:52:05 <mauke> @src error
12:52:06 <lambdabot> error s = throw (ErrorCall s)
12:52:11 <LordBrain> stanamically ballanced binary tree..
12:52:20 <mauke> @src throw
12:52:21 <lambdabot> throw exception = raise# exception
12:52:24 <tibbe> @paste
12:52:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:52:28 <nmessenger> ick, ghc internals!
12:52:29 <chessguy> dynamatically balanced?
12:52:31 <mauke> @src raise#
12:52:32 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:52:45 <astrolabe> undefined        :: a
12:52:45 <astrolabe> undefined        =  error "Prelude.undefined"
12:53:00 <LordBrain> they made use of type-level integers, and the values for each of these type level numbers were simply undefined
12:53:20 <nmessenger> astrolabe: right, but from a semantic standpoint, undefined could be defined as undefined :)
12:53:43 <nmessenger> unravel THAT!
12:53:46 <drihdaed> listFoldl f z [] = z
12:53:46 <drihdaed> listFoldl f z x:xs = foldr (f z x) xs <-- Does this work as a foldr reimpl?
12:53:57 <mauke> should be (x:xs)
12:54:02 <drihdaed> well, yeah.
12:54:02 <LordBrain> http://okmij.org/ftp/Haskell/stanamically-balanced-trees.lhs
12:54:04 <astrolabe> nmessenger: yeah, I guess in a way it would nicer to define 'error' in terms of 'undefined', but then it wouldn't print its string.
12:54:06 <drihdaed> and s/foldr/listFoldl/
12:54:11 <drihdaed> @src foldr
12:54:12 <lambdabot> foldr k z xs = go xs
12:54:12 <lambdabot>     where go []     = z
12:54:12 <lambdabot>           go (y:ys) = y `k` go ys
12:54:16 <mauke> drihdaed: no, that's foldl
12:54:17 <nmessenger> drihdaed: yep, the 'go' just captures the f and z in a closure
12:54:25 <drihdaed> mauke: yes
12:54:27 <drihdaed> i meant foldl
12:54:36 <drihdaed> wonder why the stdlib one is implemented like that hten
12:54:50 <mauke> drihdaed: to avoid passing f down in every call
12:54:51 <emu> @src foldl
12:54:52 <lambdabot> foldl f z xs = lgo z xs
12:54:52 <lambdabot>     where lgo z []     =  z
12:54:52 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:54:53 <nmessenger> drihdaed: see my comment
12:54:59 <drihdaed> mauke: ah
12:55:05 <drihdaed> meh, i don't care =P
12:55:40 <monochrom> It's just a common-subexpression elimination.
12:55:52 <drihdaed> listFoldr k z Nil = z
12:55:53 <drihdaed> listFoldr k z (Cons x xs) = x `k` listFoldr xs <-- I assume listFoldr is the same
12:56:10 <nmessenger> or as is the lingo 'round here, a CSE.
12:56:23 <mauke> missing argument in call to listFoldr xs
12:56:27 <monochrom> Interestingly it seems to matter a lot to some compilers.
12:56:46 <nmessenger> drihdaed: listFoldr accepts three arguments, so you'd have to re-pass k and z
12:56:59 <monochrom> A recent entry in the benchmark has something like:  f x y z = blah : f x y z.
12:57:29 <monochrom> That causes ghc to be very slow, another compiler to be very fast.
12:57:36 <drihdaed> @src foldr
12:57:37 <lambdabot> foldr k z xs = go xs
12:57:37 <lambdabot>     where go []     = z
12:57:37 <lambdabot>           go (y:ys) = y `k` go ys
12:57:55 <drihdaed> no, that looks about right to me
12:58:00 <LordBrain> monochrom, which is very fast?
12:58:03 <drihdaed> oh, i see
12:58:23 <monochrom> Rewriting it as f x y z = let g = f x y z in blah : g   gets both compilers to be equally fast.  It was quite a surprise.
12:58:42 <nmessenger> monochrom: did your literal Map question get answered?
12:58:52 <monochrom> No.
12:59:09 <nmessenger> monochrom: the closest thing is fromList [(key,val),(key,val)]
12:59:09 * fuzan gives up on state monad.
12:59:16 <hpaste>  tibbe pasted "How to pull values from XML and put into record?" at http://hpaste.org/624
12:59:34 <Knio> @prelude
12:59:34 <lambdabot> Unknown command, try @list
12:59:43 <drihdaed> data List a = Nil
12:59:43 <drihdaed>             | Cons a (List a) <-- I'm not sure how to use Cons here
12:59:50 <drihdaed> (Cons 1 (Cons 2 (Cons 3))) doesn't work
12:59:50 <nmessenger> monochrom: you could define (=:) = (,) and get fromList [k1 =: v1, k2 =: v2]
13:00:01 <Botje> drihdaed: the last cons should be Cons 3 Nil
13:00:06 <tibbe> is there a good way in general to pull structured data from XML and put into records when some XML elements are optional?
13:00:19 <LordBrain> monochrom, which entry are was it?
13:00:28 <mauke> *** - EVAL: too few arguments given to CONS: (CONS 3)
13:00:41 <LordBrain> which entry in the benchmarks i mean
13:00:41 <monochrom> I'm looking for the message in haskell-cafe.  Plz give me a moment.
13:00:46 <LordBrain> sure
13:00:49 <drihdaed> Apparently listFoldl f z (Cons x xs) = listFoldl (f z x) xs is constructing the infinite type
13:00:52 <drihdaed> Why, I don't know
13:01:03 <drihdaed> Oh, I see.
13:01:18 <drihdaed> I need f after listFoldl
13:02:05 <drihdaed> What's the show-incantation again?
13:03:07 <nmessenger> drihdaed: I think Cale has it on a macro or something in his client :)
13:03:14 <LordBrain> i don't know what you mean by show-incantation
13:03:25 <mauke> instance (Show a) => Show (List a) where show Nil = "Nil"; show (Cons x xs) = "(Cons " ++ show x ++ " " ++ show xs ++ ")"
13:03:28 <drihdaed> for types, to make them showable
13:03:29 <LordBrain> oh for the bot?
13:03:36 <mauke> deriving (Show)
13:03:44 <LordBrain> oh
13:03:44 <drihdaed> thanks
13:04:04 <drihdaed> Nope:     No instance for (Show (List (List t) -> List t))
13:04:04 <drihdaed>       arising from use of `show' at List.hs:16:18-68
13:04:05 <Cale> nmessenger: hm?
13:04:09 <nmessenger> oh, I thought you meant the thing Cale does with folds and shows
13:04:15 <drihdaed> @type []
13:04:17 <lambdabot> forall a. [a]
13:04:26 <glguy> @kind []
13:04:29 <lambdabot> * -> *
13:04:36 <mauke> drihdaed: you can't show functions
13:04:37 <Cale> Oh, I don't have a macro for that, I just type it.
13:04:42 <mauke> drihdaed: missing parens?
13:04:51 <drihdaed> main = putStrLn $ show (listFoldl (*) (Cons 1 (Cons 3 (Cons 3 Nil))))
13:04:52 <drihdaed> Looks right here
13:04:58 <glguy> > [] 2 :: [] Double
13:04:59 <lambdabot>  Couldn't match expected type `t -> [Double]'
13:05:07 <mauke> drihdaed: missing argument in call to listFoldl
13:05:09 <glguy> > 2 : [] :: [] Double
13:05:11 <lambdabot>  [2.0]
13:05:19 <drihdaed> mauke: CARP. Shoot me.
13:05:30 <drihdaed> Works now
13:05:34 * nmessenger shoots drihdaed again
13:05:51 * Botje shoots drihdaed too, to be sure.
13:06:07 * mauke shoots drihdaed, lazily
13:06:13 * nmessenger also throws a carp at him.
13:06:20 * drihdaed is too dead to say that it's also quite fast
13:06:22 <Knio> > map toLower "Hello"
13:06:24 <lambdabot>  "hello"
13:06:32 <Knio> why can't my hugs find toLower?
13:06:41 <drihdaed> Knio: because you didn't import Char maybe?
13:06:42 <mauke> because you didn't import Data.Char
13:06:48 <Knio> ah
13:06:54 <drihdaed> SHUT UP i'm meant to be a clever newbie
13:06:56 <drihdaed> :(
13:06:59 <mauke> import Char (maybe)
13:07:22 <monochrom> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022720.html
13:07:24 <lambdabot> Title: [Haskell-cafe] Re: Haskell vs Ruby as a scripting language, http://tinyurl.com/25taqx
13:07:50 <nmessenger> Knio: type ":m + Data.Char" beforehand
13:08:23 <nmessenger> or I seem to remember hugs having the toLower automatically at the toplevel?
13:08:50 <nmessenger> drihdaed is a cool nick
13:09:20 <Cheery> Has anyone written a raytracer with haskell?
13:09:42 <jrockway> i have kind of a newbie question; how should i write a class declaration where the members do things like Tree a -> [a] (without limiting myself to Tree)
13:10:06 <jrockway> class Listable a where ... doesn't seem correct to me
13:10:26 <Cheery> ?where vty
13:10:27 <lambdabot> http://members.cox.net/stefanor/vty/
13:10:30 <nmessenger> class Listable l where toList :: l a -> [a]
13:10:43 <dylan_> @hoogle toList
13:10:43 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
13:10:43 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
13:10:43 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
13:10:55 <dylan_> bah.
13:10:56 <nmessenger> @hoogle a -> [b]
13:10:57 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:10:57 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
13:10:57 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
13:11:07 <dylan_> Data.Traverseable, I think
13:11:24 <nmessenger> Foldable has some folds
13:11:26 <jrockway> i'm mostly interested in the mechanics, not the result at this point :)
13:11:35 <jrockway> i'm sure this has been done to death
13:11:59 <drihdaed> is haskell fully object oriented? sure, it has classes and objects, but..
13:12:20 * nmessenger slinks away from that questionn
13:12:23 <siti> there's no inheritance really
13:12:25 <fasta> drihdaed: it has objects?
13:12:30 <drihdaed> fasta: apparently
13:12:32 <fasta> drihdaed: since when?
13:12:37 <pejo> drihdaed, it doesn't have subtyping if that is what you mean. There are extensions/encodings, OOHaskell and O'Haskell though.
13:12:45 <siti> only really interfaces
13:12:47 <drihdaed> fasta: since everyone says so/ :P
13:12:56 <JohnMeacham__> yikes. jhc switched to all compile errors. hrm..
13:12:56 <nmessenger> jrockway: basically, your type 'l' is a container, it has to have another type as an argument for the things in 'contains'.
13:13:00 <fasta> drihdaed: ...
13:13:03 <fasta> diffbavis: sure
13:13:08 <fasta> drihdaed: sure
13:13:10 <nmessenger> jrockway: in other words l has kind * -> *
13:13:13 <fasta> diffbavis: sorry
13:13:19 <nmessenger> @kind []
13:13:20 <drihdaed> drihffbaed
13:13:22 <lambdabot> * -> *
13:13:23 <nmessenger> @kind Tree
13:13:25 <lambdabot> * -> *
13:13:30 <nmessenger> @kind [Int]
13:13:33 <lambdabot> *
13:13:33 <nmessenger> @kind Tree Int
13:13:36 <lambdabot> *
13:13:54 <mightybyte> Can you override show for type synonyms?
13:14:11 <fasta> mightybyte: no
13:14:19 <drihdaed> @quote show
13:14:20 <lambdabot> kilimanjaro says:  the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in
13:14:20 <lambdabot> like 10 days!"
13:14:22 <drihdaed> bah
13:14:25 <fasta> mightybyte: (that's the short answer)
13:14:26 <drihdaed> there should be a bot-way to get it =P
13:14:41 <mightybyte> Hmmm, that's annoying
13:14:46 <nmessenger> mightybyte: synonyms are two different names for the same type, so how would it choose which instance?
13:15:16 <nmessenger> mightybyte: you'd need a datatype or a newtype.  (I *think* you can override instances for newtypes)
13:15:20 <mightybyte> Well, if it's like a typedef it seems like it should be able to.
13:15:24 <fasta> nmessenger: it takes away one use case of Haskell (i.e. not using military typing)
13:15:35 <allbery_b> if you want something like a type synonym but with the ability to replace iinstances, use newtype, that's wha it's there for
13:15:46 <drihdaed> @show
13:15:46 <lambdabot> ""
13:15:50 <drihdaed> @src show
13:15:51 <lambdabot> show x = shows x ""
13:15:53 <drihdaed> blah
13:15:53 <allbery_b> a type synonym is not a typedef, it's a compile time macro
13:16:13 <mightybyte> Does the "type" keyword always create a synonym?
13:16:23 <nmessenger> @src shows
13:16:24 <lambdabot> Source not found. That's something I cannot allow to happen.
13:16:27 <fasta> macro? I don't think you will find that in the Report
13:16:35 <mauke> allbery_b: isn't that what a typedef is?
13:16:48 <fasta> I know what you mean, but it sounds like it comes from the marketing department
13:17:24 <Cheery> when trying to install Vty, it says: Installing: /usr/local/lib/vty-3.0.0/ghc-6.6 & /usr/local/bin vty-3.0.0...
13:17:24 <Cheery> Setup.lhs: Error: Could not find module: Graphics.Vty with any suffix: ["hi"]
13:17:43 <Cheery> I have no idea what this means. :/
13:17:52 <allbery_b> mauke: it is in C, but C's got a rather vaguelr notion of types
13:17:54 <mightybyte> I'm working on my TicTacToe program I mentioned earlier and I have the following...
13:17:57 <mightybyte> type Board = Array Int Piece
13:18:20 <nmessenger> mightybyte: you could write a showing function outside of the Show class.
13:18:32 <mightybyte> Yeah, I already did that
13:18:39 <mauke> newtype Board = Board { unboard :: Array Int Piece }
13:18:43 <allbery_b> and one of the primordial arguments about C typing was how typedef should work; it got resolved sloppily, like most C type issues
13:19:17 <mauke> how is C's typedef different from Haskell's type?
13:19:31 <fasta> I don't think there's any difference in semantics
13:19:39 <mightybyte> mauke: So in that definition unboard converts from the Board back to an array?
13:19:49 <nmessenger> mightybyte: yep
13:19:50 <siti> you can mix types in c, but you can't with type in haskell
13:19:51 <mauke> mightybyte: yes
13:20:02 <mauke> siti: sure I can
13:20:05 <fasta> siti: "mix"?
13:20:08 <siti> umm
13:20:16 <siti> I'll stop ;)
13:20:18 <mauke> > ("foo" :: String) ++ ("bar" :: [Char])
13:20:20 <lambdabot>  "foobar"
13:20:20 <mightybyte> Would I be able to access the underlying array without the unboard?
13:20:27 <nmessenger> you could define withArray f = Board . f . unboard, and wrap your functions in a withArray
13:20:28 <siti> yes but that's "newtype" :p
13:20:29 <mauke> mightybyte: yes, with pattern matching
13:20:37 <mightybyte> Ok
13:20:43 <mauke> siti: huh? type String = [Char]
13:20:51 <fasta> Anybody wrote an automatic existential type instance generator?
13:20:56 <mightybyte> mauke: And then I could make some accessor functions
13:20:59 <siti> one second I will look it up
13:21:00 <drihdaed> Anyone?
13:21:04 <drihdaed> Just need the show magic =P
13:21:17 <drihdaed> ah
13:21:21 <drihdaed> deriving (Show)
13:21:43 <siti> :)
13:22:19 <Cheery> yay, got it installing. :)
13:22:49 <Cheery> ?where alex
13:22:50 <lambdabot> http://www.haskell.org/alex/
13:23:11 <shapr> @where alexj
13:23:11 <lambdabot> I know nothing about alexj.
13:23:17 * shapr grins
13:23:44 <drihdaed> okay, haskell is AWESOME
13:23:47 <siti> oh I got mixed up, type = type synonym, newtype is actually a new type
13:23:50 <drihdaed> i don't know how else to say it
13:24:07 <drihdaed> all other programming languages officially now suck
13:24:08 <nmessenger> "haskell is AMAZINGLY AWESOME" would do
13:24:15 <dmhouse> siti: newtype is basically like data, but is restricted to a single constructor, and that constructor is strict.
13:24:22 <siti> drihdaed: I get the feeling almost every day, but the issue is I discuss it and do no work ;)
13:24:27 <siti> dmhouse: yeah
13:24:29 <dmhouse> newtype F = G X is the same as data F = G !X
13:24:39 <drihdaed> siti: i'm going to write cobol in haskell!
13:24:41 <drihdaed> yes.
13:24:58 * nmessenger fears the Cobolskell demon
13:25:03 <siti> :D
13:25:44 <nmessenger> drihdaed: "... an implementation of" or "... a program as if it were written in"?
13:26:14 <Cheery> ?where happy
13:26:15 <lambdabot> http://www.haskell.org/happy/
13:26:29 <drihdaed> nmessenger: both
13:26:33 <drihdaed> ... as the same thing
13:26:34 * nmessenger dies
13:26:50 <Cheery> hm.
13:27:03 <Cheery> depedency from yi to alex, from alex to happy...
13:27:04 <drihdaed> I find myself not declaring types all over the place for functions
13:27:06 <drihdaed> am I sinning?
13:27:19 <chessguy> yes
13:27:25 <siti> I don't think so, I don't do it much...
13:27:36 <nmessenger> drihdaed: nope.  The compiler's supposed to do that, but if you share it with others, the annotations help make intent clear.
13:27:58 <siti> although with all warnings it warns you if you don't have a type on a function
13:28:02 <chessguy> not to mention if you need to come back to look at it later yourself
13:28:13 <siti> and also haddock needs types on functions for documentation
13:28:16 <nmessenger> aye, chessguy speaks wisdom
13:28:17 <fantasma> anyone know of anything that explains how to use getArgs?
13:28:34 <chessguy> it's at least as important as good comments
13:28:36 <drihdaed> yeah, i guess i'll use them if i do a rael project
13:28:45 <drihdaed> like that pure lambda calculus interpreter :P
13:28:46 <xerox> fantasma: what do you want to know exactly?
13:29:05 <chessguy> Cale, did you check out that paper?
13:29:53 <fantasma> xerox, how to use it, mainly I want to parse an argument from the terminal as an expression
13:30:02 <chessguy> fantasma, often when i want to find a simple example of something, i search the wiki for it
13:30:08 <drihdaed> elements (Leaf x) = x
13:30:08 <drihdaed> elements (Branch left x right) = [elements left, elements x, elements right] <-- Why are these the infinite type?
13:30:08 <nmessenger> you'll have to find/write a parser
13:30:15 <siti> getOpt :p
13:30:18 <xerox> fantasma: do I remember correcly that you want to pass in a number? Is it an integer?
13:30:26 <Cheery> thank god happy didn't had any unfilled depedencies. :/
13:30:33 <siti> I used a combination of getOpt and parsec to do my arguments
13:30:40 <drihdaed> Cheery: isn't there a haskell package manager?
13:30:45 <drihdaed> or rather, autoinstall
13:30:45 <drihdaed> er
13:30:46 <fantasma> xerox, yes it'll be an integer but ideally Id like to pass something like 2^10
13:30:51 <nmessenger> drihdaed: add [] around the first case 'x', and remove the 'elements' call from the x in the second case
13:30:54 <xerox> Let's see if it reads.
13:30:57 <Cheery> drihdaed: sure I'd like it, show it to me.
13:31:00 <xerox> > "2^10" :: Integer
13:31:00 <drihdaed> ruby's rubygems, python's easy_install, perl's CPAN, haskell has somethin, surely?
13:31:00 <lambdabot>  Couldn't match expected type `Integer'
13:31:03 <xerox> > read "2^10" :: Integer
13:31:04 <lambdabot>  Exception: Prelude.read: no parse
13:31:08 <xerox> Dang.
13:31:18 <siti> hackage or what is it called
13:31:18 <Cale> chessguy: a bit
13:31:21 <drihdaed> still infinite
13:31:26 <drihdaed> elements (Leaf x) = [x]     elements (Branch left x right) = [elements left, x, elements right]
13:31:26 <Cheery> ?where hackage
13:31:27 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
13:31:38 <chessguy> Cale, the method isn't very well-explained
13:31:41 <nmessenger> drbean: er, wait, yeah, you'd have to concatenate the lists on the left and right
13:31:41 <allbery_b> hackage is still evolving
13:31:43 <chessguy> it's an interesting idea though
13:31:46 <xerox> Oh look, fantasma.
13:31:54 <xerox> > read "2e10" :: Integer
13:31:56 <lambdabot>  20000000000
13:31:56 <drihdaed> http://hackage.haskell.org/trac/hackage/ <-- cabal_install
13:31:58 <cjay> will hackage be able to uninstall at some point?
13:31:58 <lambdabot> Title: Hackage - Trac
13:32:02 <siti> it's got some nice stuff so far :)
13:32:10 <nmessenger> so "elements left ++ [x] ++ elements right"
13:32:15 <fantasma> xerox, woah
13:32:22 <monochrom> fantasma: if you run your program like "prog xxx yyy 999", then inside your program getArgs returns the list of *strings* ["xxx","yyy","999"], ok?  Now whatever you want to do to those strings, you have to code it up or use library functions.
13:32:29 <drihdaed> does everyone use literate haskell? :/
13:32:35 <siti> lol @ win32 bindings
13:32:42 <siti> I don't :D
13:32:53 <monochrom> I don't use literate haskell.
13:32:56 <xerox> fantasma: so it's like |import System.Environment (getArgs); main = do args <- getArgs; case args of [] -> usage; n = let m = read n :: Integer in ....|
13:33:03 <drihdaed> because i don't want to learn LaTeX >AND< Haskell
13:33:09 * Cheery informs to drihdaed that he uses.
13:33:17 <fantasma> monochrom, obviously, I already have the code for what I want to do with the args
13:33:18 <cjeris> everyone must learn LaTeX.  otherwise no quack.
13:33:22 <nmessenger> drihdaed: you could use the '>' form, which is great for blog posts.
13:33:22 <siti> it seems BSD3 is the preferred license in the haskell community ...
13:33:25 <monochrom> literate haskell does not require latex
13:33:36 <drihdaed> monochrom: i don't like prefixing everything with > either :P
13:33:38 <Cheery> literate haskell is not only LaTeX.
13:33:45 <drihdaed> \begin{code}...\end is more barable
13:33:49 <drihdaed> siti: <3 MIT
13:33:50 <Cheery> drihdaed: I like.
13:33:54 <monochrom> \begin{code}  is hardly "learning latex".
13:33:57 <drihdaed> MIT license, that is
13:34:02 <drihdaed> monochrom: i mean for the other formatting
13:34:05 <siti> well same thing isn't it ?
13:34:09 <Cheery> it's because I have more scrap than anything in my files. :)
13:34:18 <monochrom> ALL NEWBIES DIE!
13:34:27 * nmessenger dies
13:34:32 <emu> your text editor should take care of managing the literate-code markers
13:34:33 * Cheery farts.
13:34:49 * cjeris dies
13:34:51 <monochrom> whining, narcisstic, anti-intellectual newbies
13:35:05 <Cheery> cjeris: that's rude.
13:35:31 <nmessenger> Cheery: you're the one who killed him!  I'd say that's pretty rude!
13:35:35 <Cheery> it's just smell!
13:35:56 <nmessenger> oops, forgot
13:35:58 * nmessenger undies
13:36:13 <chessguy> it's a miracle!
13:36:16 <shapr> SHAZAM!
13:36:19 * Cheery puts up a backup from cjeris
13:36:21 * shapr boings cheerfully
13:36:28 <cjeris> heh.  fortunately, the IO action in which my death was recorded was never invoked before the program terminated
13:36:34 <shapr> yay!
13:36:34 <drihe> > reverse "Hi I'm ehird"
13:36:36 <lambdabot>  "drihe m'I iH"
13:36:47 <drihe> drihe m'I iH *hguoc*
13:36:52 * nmessenger runs quickly away from the dreaded shapr SHAZAM
13:37:14 <drihe> hguoc - Hyper Good Universal Optimizing Compiler
13:37:16 <chessguy> ?remember cjeris fortunately, the IO action in which my death was recorded was never invoked before the program terminated
13:37:16 <drihe> Someone write it
13:37:16 <lambdabot> Done.
13:37:34 <drihe> ?remember lambdabot Done.
13:37:34 <lambdabot> Done.
13:37:39 <drihe> @quote lambdabot
13:37:39 <lambdabot> lambdabot says: Beer, it's so much more than just a breakfast drink!
13:37:40 <nmessenger> evil!
13:37:57 <Cheery> monochrom: I like your communication style btw. It's ingeniously elitistic.
13:38:15 <drihe> I wonder........ is there a way to get lambdabot to say something without quotes round?
13:38:18 <monochrom> hee hee
13:38:24 <nmessenger> @id yeppers
13:38:24 <lambdabot>  yeppers
13:38:36 <nmessenger> @. elite keal
13:38:36 <lambdabot> i suGGez+ u TEAR Ap4Rt 4 20q anD PlUG I7 With +HE 4Lg
13:39:08 <nmessenger> @. elite run fix (+1)
13:39:09 <lambdabot> EX(ep+iON: <<LO0P>>
13:39:41 <nmessenger> plugin composition ftw!
13:39:42 <monochrom> lambdabot can say numbers without quotes around. :)
13:39:45 <chessguy> @vixen
13:39:46 <lambdabot> <undefined>
13:39:50 <nmessenger> :(
13:39:56 <hpaste>  ehird pasted "odd error, part 43845345" at http://hpaste.org/625
13:40:04 <chessguy> @. elite run print "Hi"
13:40:05 <lambdabot> <i0 ()>
13:40:33 <nmessenger> . @run blah = > blah
13:41:07 <drihe> @.
13:41:07 <lambdabot> Not enough arguments to @.
13:41:10 <drihe> @. boo
13:41:10 <lambdabot> Not enough arguments to @.
13:41:16 <Cheery> huh, yi is a freak.
13:41:18 <drihe> @. boo "hmph"
13:41:18 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "boo"
13:41:21 <drihe> blah.
13:41:25 <monochrom> [elements left] ++ [x] ++ [elements right], drihe.  But I thought someone told you that half an hour ago already.
13:41:27 <Cheery> it responded on vim commands. :/
13:41:28 <nmessenger> @. elite protontorpedo
13:41:28 <lambdabot> wHy HasKe|| 0vER zay (|SiP oR zMA11T4|k?
13:41:48 <hpaste>  nmessenger annotated "odd error, part 43845345" with "try this" at http://hpaste.org/625#a1
13:41:49 <monochrom> err elements left ++ [x] ++ elements right, drihe
13:41:51 <Cheery> @"PLUZ"
13:41:52 <lambdabot> Unknown command, try @list
13:42:08 <drihe> monochrom: thanks
13:42:15 <monochrom> or equivalently what nmessenger annotated
13:42:35 <nmessenger> monochrom: beat you by milliseconds! :P
13:42:45 <drihe> Still infinite type
13:42:57 <nmessenger> heh, oops
13:43:16 <hpaste>  nmessenger annotated "odd error, part 43845345" with "forgot the [] in the base case" at http://hpaste.org/625#a2
13:43:16 <monochrom> elements (Leaf x) = [x]
13:43:23 <nmessenger> again!
13:43:56 <monochrom> Relativity implies that it is subjective who's first, depends on who's frame. :)
13:44:12 <drihe> YAAAAY
13:44:12 <drihe> it works.
13:44:28 <monochrom> Reliability implies that it's nice both of us work on it. :)
13:44:39 <nmessenger> monochrom: certainly, but we're nobody around here's really traveling at relativistic speeds :P
13:44:44 <hpaste>  (anonymous) annotated "odd error, part 43845345" with "print" at http://hpaste.org/625#a3
13:45:04 <drihe> how on earth was that related, dear (anonymous)?
13:45:12 <nmessenger> @src print
13:45:13 <lambdabot> print x = putStrLn (show x)
13:45:16 <drihe> aha
13:45:18 <drihe> well
13:45:21 <drihe> i'm stupid
13:45:21 <drihe> ok
13:45:26 <drihe> thank you have a nice day
13:45:51 <nmessenger> you're not stupid if you just didn't know about it.  No one should expect you to be immediately omniscient.
13:46:12 <drihe> :P
13:46:18 <drihe> But I >am> omniscient, that's the problem
13:46:29 <chessguy> > print "3"
13:46:30 <lambdabot>  <IO ()>
13:46:32 <chessguy> > print 3
13:46:32 <nmessenger> how many fingers am I holding up?
13:46:32 <hpaste>  fasta pasted "existentials" at http://hpaste.org/626
13:46:33 <lambdabot>  <IO ()>
13:46:40 <drihe> nmessenger: None.
13:46:44 <drihe> You are thinking of a number to say
13:46:44 <nmessenger> 3!
13:46:47 <drihe> when I say anything else
13:46:54 <drihe> And you will always say something other than what I say.
13:46:56 <drihe> Do you see now?
13:47:03 <nmessenger> heh
13:47:16 <nmessenger> of course, I bow down to the superior being.
13:47:28 <chessguy> @quote nmessenger
13:47:29 <lambdabot> nmessenger says: <chessguy> lambdabot drives? <nmessenger> ...men wild!
13:47:42 <drihe> @quote ehird
13:47:42 <lambdabot> ehird says: the answer to life the universe and everything is NaN
13:47:48 <drihe> @quote ehird
13:47:49 <lambdabot> ehird says: the answer to life the universe and everything is NaN
13:47:55 <drihe> my only quote isn't even funny
13:48:07 <AvengerX> good night alive people :)
13:48:11 <chessguy> heh
13:48:16 <drihe> (i am not alive)
13:48:19 <nmessenger> @remember ehird But I >am> omniscient, that's the problem
13:48:19 <lambdabot> Done.
13:48:31 <AvengerX> drihe: oh sorry... good night for non-alive people tho
13:48:31 <drihe> (I am alive, now)
13:48:34 <chessguy> did anybody else just see something weird in the join message for AvengerX
13:48:48 <drihe> no. i saw "AvengerX joined the room"
13:48:50 <AvengerX> something weird in me join msg?
13:48:56 <AvengerX> maybe the ipv6?
13:48:57 <drihe> join msg? haha, god no
13:49:06 <glguy> chessguy: ipv6
13:49:10 <nmessenger> ooooo, ipv6!
13:49:10 <SamB> ChanServ: that is called ipv6!
13:49:12 <SamB> er.
13:49:14 <chessguy> i saw: AvengerX ... has joined #HaskElL
13:49:15 <SamB> Cheery:
13:49:16 <SamB> er.
13:49:17 <glguy> ?quote stereo
13:49:17 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:49:17 <SamB> chessguy:
13:49:19 <AvengerX> lol
13:49:26 * SamB curses the large number of people here
13:49:28 <drihe> @src foldl
13:49:28 <lambdabot> foldl f z xs = lgo z xs
13:49:29 <lambdabot>     where lgo z []     =  z
13:49:29 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:49:29 <drihe> @src foldr
13:49:29 <lambdabot> foldr k z xs = go xs
13:49:29 <lambdabot>     where go []     = z
13:49:30 <lambdabot>           go (y:ys) = y `k` go ys
13:49:32 <drihe> er
13:49:34 <SamB> not the *people*
13:49:35 * chessguy raises an eyebrow at SamB 
13:49:37 <SamB> just the number
13:49:46 <fantasma> how come "logBase 10" gives me in error in prelude?
13:49:47 <chessguy> ?losers
13:49:48 <lambdabot> Maximum users seen in #haskell: 328, currently: 325 (99.1%), active: 55 (16.9%)
13:49:50 * glguy curses the large people
13:49:51 <SamB> chessguy: wreaks havoc with my tab completion
13:49:56 <emu> > logBase 10 20
13:49:57 <lambdabot>  1.301029995663981
13:50:11 * nmessenger curses those people who are not large, just to be fair
13:50:13 <fantasma> hmm
13:50:14 <drihe> @remember losers 328
13:50:15 <lambdabot> Done.
13:50:19 <AvengerX> lambdabot is a bot written in haskell? :)
13:50:19 * drihe dies for the night
13:50:23 <drihe> AvengerX: BINGO
13:50:25 <drihe> clever boy
13:50:31 <chessguy> ?version
13:50:31 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
13:50:32 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:50:37 <chessguy> AvengerX, ^^
13:50:41 <AvengerX> cool
13:50:41 <glguy> !version
13:50:47 <glguy> !say hpaste HEAD version
13:50:47 <hpaste> hpaste HEAD version
13:50:58 <nmessenger> :D
13:51:05 <glguy> actually, I guess that is a lie
13:51:09 <glguy> hpaste is out of date atm
13:51:12 <AvengerX> I got a sample code of a bot in haskell, I'll put it working and develop it a bit tho (I hope)
13:51:26 <SamB> chessguy: yeah, I see it too now that you mention it...
13:51:35 <chessguy> AvengerX, have you seen the "Roll your own IRC bot tutorial"?
13:51:44 <SamB> @quote losers
13:51:45 <lambdabot> losers says: 328
13:51:46 <AvengerX> chess: exactly that one :)
13:51:53 <SamB> @quote win
13:51:54 <lambdabot> ndm says: Windows is reliable compared to hat
13:51:59 <chessguy> ah, that's a goodun'
13:52:00 <SamB> @quote win
13:52:00 <lambdabot> SeanRussell says: [On the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
13:52:01 <lambdabot> Haskell.
13:52:36 <chessguy> man, i can't remember the last time i wrote a program in something other than haskell
13:52:39 <chessguy> it's been a while
13:53:04 <nmessenger> @quote chessguy
13:53:04 <lambdabot> chessguy says: [in regards to #haskell] man, it's amazing the difference between what happens when someone asks for help here, and what happens when they ask for help in another language channel
13:53:15 <SamB> @quote
13:53:15 <lambdabot> dolio says: Perhaps he's an epigram guy and frowns on Turing completeness.
13:53:31 <lispy> @quote SamB
13:53:31 <chessguy> @quote c++
13:53:32 <lambdabot> SamB says: I was just saying that encasing poeple in concrete is not the best solution to that problem
13:53:32 <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
13:53:50 <nmessenger> @quote c\+\+
13:53:50 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
13:53:59 <nmessenger> hahhahah
13:54:16 <nmessenger> now *that's* a goodun'!
13:54:26 * chessguy gets out his biology textbook
13:54:41 <AvengerX> hmmm... if I got a 'String' like sty="1023", and want just print it as "10.23", I really must do a 'concat [ (fst (splitAt 2 sty)), ".", (snd (splitAt 2 sty))]'  ?
13:54:55 <nmessenger> chessguy: it has to do with your *whisper-whisper*
13:55:11 <AvengerX> Or is there a way to merge these things to just fst . "." . snd with that single splitAt result?
13:55:25 <nmessenger> @pl concat [ (fst (splitAt 2 sty)), ".", (snd (splitAt 2 sty))]
13:55:26 <lambdabot> join [fst (splitAt 2 sty), ".", snd (splitAt 2 sty)]
13:55:27 <chessguy> nmessenger, it's "lamprey" i've never heard of
13:55:38 <nmessenger> @wn lamprey
13:55:40 <lambdabot> *** "lamprey" wn "WordNet (r) 2.0"
13:55:40 <lambdabot> lamprey
13:55:40 <lambdabot>      n : primitive eellike freshwater or anadromous cyclostome having
13:55:40 <lambdabot>          round sucking mouth with a rasping tongue [syn: {lamprey
13:55:40 <lambdabot>          eel}, {lamper eel}]
13:55:45 <chessguy> oooooh
13:55:46 <LoganCapaldo> > splitAt 2 "1023"
13:55:48 <lambdabot>  ("10","23")
13:55:50 <chessguy> that would not be fun
13:55:54 <nmessenger> indeed
13:56:32 <allbery_b> @pl (\(f,s) -> f ++ "." ++ s) (splitAt 2 sty)
13:56:32 <lambdabot> fst (splitAt 2 sty) ++ '.' : snd (splitAt 2 sty)
13:56:37 <allbery_b> feh
13:56:39 <LoganCapaldo> > let (x, y) = splitAt 2 "1023" in x ++ ('.':y)
13:56:40 <lambdabot>  "10.23"
13:56:45 <nmessenger> let (x,y) = splitAt 2 sty in x ++ "." ++ y
13:56:49 <AvengerX> but then, I have to store this at var?
13:56:54 <chessguy> @quote cypherx
13:56:55 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
13:56:57 <chessguy> @quote cypherx
13:56:57 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
13:57:00 <AvengerX> hmm
13:57:03 <siti> it would be cool if all the nehe open gl demos had a haskell version :)
13:57:03 <LoganCapaldo> @pl let (x, y) = splitAt 2 "1023" in x ++ ('.':y)
13:57:04 <lambdabot> (line 1, column 5):
13:57:04 <lambdabot> unexpected "("
13:57:04 <lambdabot> expecting natural, identifier or "in"
13:57:05 <chessguy> seems to be his only quote too
13:57:07 <LoganCapaldo> grr
13:57:14 <LoganCapaldo> pl needs to speak more haskell :)
13:57:47 <AvengerX> I like this let (x, y) = splitAt 2 "1023" in x ++ ('.':y)
13:57:49 <chessguy> @pl f x = splitAt 2 "1023" in (fst x) ++ ('.':(snd x))
13:57:50 <lambdabot> (line 1, column 24):
13:57:50 <lambdabot> unexpected reserved word "in" or "i"
13:57:50 <lambdabot> expecting variable, "(", operator or end of input
13:58:10 <nmessenger> @pl (\(x,y) -> x ++ "." ++ y) (splitAt 2 sty)
13:58:10 <lambdabot> fst (splitAt 2 sty) ++ '.' : snd (splitAt 2 sty)
13:58:11 <chessguy> wait, your code doesn't even make sense
13:58:21 <chessguy> ohh
13:58:30 <AvengerX> chessguy
13:58:39 <chessguy> AvengerX,
13:59:06 <AvengerX> the objective is just to get an integer, 1023, and pass it to currency via show (to turn into string) and pick the last two digits and cut by a '.' ==> "10.23"
13:59:15 <AvengerX> So 1023 => "1023" => "10.23"
13:59:16 <AvengerX> heh
14:00:05 <AvengerX> I just feel like doing splitAt twice to cut the string is kinda .. wasting doing the same thing twice to cut the first and second part of the string
14:00:30 <nmessenger> AvengerX: then use a let or where binding to pick apart the fst and snd
14:00:42 <AvengerX> hmmm
14:01:29 <notsmack> can't you divide by 100 and then show?
14:01:31 <LoganCapaldo> Is there a good reason splitAt returns a tuple?
14:01:44 <chessguy> ?hoogle splitAT
14:01:45 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
14:01:45 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
14:01:45 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
14:01:53 <nmessenger> LoganCapaldo: it splits the list and returns the first and second parts?
14:01:56 <AvengerX> allright... if I use guards, I can do something like: func x = \n | blahblah \n where \n x = splitAt blahblah
14:02:05 <LoganCapaldo> nmessenger, yeah but why not return a list?
14:02:06 <AvengerX> notsmack: hell yes! lol
14:02:20 <LoganCapaldo> Int -> [a] -> [[a]]
14:02:27 <nmessenger> AvengerX: see above
14:02:29 <nmessenger> let (x,y) = splitAt 2 sty in x ++ "." ++ y
14:03:45 <nmessenger> > let (x,y) = splitAt 2 "1023" in x ++ "." ++ y
14:03:47 <lambdabot>  "10.23"
14:04:49 <AvengerX> nmessenger, this let will somewhat collide with the function... I have to do a convcurr :: String -> Price function, so how i'd call let with this?
14:04:55 <AvengerX> It should be something like
14:05:13 <AvengerX> convcurr "1023" = "10.23"
14:05:47 <nmessenger> convcurr sty = x ++ "." ++ y where (x,y) = splitAt 2 sty
14:05:59 <AvengerX> should I do a convcurr x = let (x,y) = splitAt (...) wouldn't it complain about unexpected '='?
14:06:15 <monochrom> convcurr sty = let (x,y) = splitAt 2 sty in x ++ "." ++ y
14:06:30 <xerox> convcurr sty = let (x,y) = splitAt 2 sty in xs ++ ('.' : ys)
14:06:31 <AvengerX> hmm
14:06:36 <nmessenger> nopers, the = is part of the declaration of the name inside the 'let', there'd be no problem.
14:06:42 <abz> ?users
14:06:43 <lambdabot> Maximum users seen in #haskell: 328, currently: 327 (99.7%), active: 56 (17.1%)
14:06:43 <monochrom> I pledge my honour that that line of code has no error.
14:06:43 <xerox> argh. well.
14:06:56 <AvengerX> currently is 325 for me
14:06:57 <AvengerX> :)
14:07:10 <AvengerX> ehn! it counts active users!..
14:07:12 <abz> same
14:07:14 <chessguy> > let convcurr =  show . (`div` 10) . read in convcurr "1023"
14:07:16 <lambdabot>  "102"
14:07:17 * xerox sighs.
14:07:28 <nmessenger> remember, let names act within an implied {} block when using layout
14:07:38 <chessguy> > let convcurr =  show . (/ 100) . read in convcurr "1023"
14:07:39 <lambdabot>  "10.23"
14:07:50 <nmessenger> heh
14:07:59 <chessguy> AvengerX, is that cheating?
14:08:09 <xerox> > (uncurry (++) . second ('.':) . splitAt 2) "1023"
14:08:10 <AvengerX> > let convcurr = show . (/ 100) . read in convcurr "10232"
14:08:11 <lambdabot>  "10.23"
14:08:12 <lambdabot>  "102.32"
14:08:21 <AvengerX> > let convcurr = show . (/ 100) . read in convcurr "10"
14:08:22 <lambdabot>  "0.1"
14:08:31 <chessguy> ?src interact
14:08:31 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:08:32 <monochrom> Actually perhaps convcurr should take a number rather than a string in the first place.
14:08:32 <AvengerX> hmm
14:08:49 <chessguy> hmm, isn't there a function that's just show . f . read ?
14:08:56 <AvengerX> monochrom: well, it will yes
14:08:59 <AvengerX> > let convcurr = show . (/ 100) . read in convcurr 10232
14:09:01 <lambdabot>   add an instance declaration for (Num String)
14:09:13 <chessguy> ?hoogle read
14:09:13 <lambdabot> Prelude.read :: Read a => String -> a
14:09:14 <lambdabot> Text.Read :: module
14:09:14 <lambdabot> Prelude.Read :: class Read a
14:09:23 <Syzygy-> > let convcurr = show . (/ 100) . read in convcurr "10232"
14:09:25 <lambdabot>  "102.32"
14:09:31 <AvengerX> > let convcurr = show . (/ 100) . 10232
14:09:32 <lambdabot>  Parse error
14:09:45 <fantasma> can $! be used with the - operator
14:09:55 <AvengerX> > let convcurr = show . (/ 100) . in convcurr 10232
14:09:56 <lambdabot>  Parse error
14:10:05 <AvengerX> How would be a 'read' for 'Int'? :)
14:10:08 <nmessenger> I've seen the (construct . f . destruct) pattern a lot.  Perhaps a surround f h g  = f . g . h definition?
14:10:27 <chessguy> read is polymorphic. it works fine for any of these types:
14:10:30 <chessguy> ?instance Read
14:10:30 <lambdabot> Maybe you meant: instances instances-importing
14:10:32 <chessguy> ?instances Read
14:10:34 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
14:10:37 <monochrom> read for Int?  Like (read "123" :: Int)?
14:10:47 <Syzygy-> > read "123" :: Int
14:10:48 <lambdabot>  123
14:11:00 <Syzygy-> > read "123" :: Float
14:11:01 <lambdabot>  123.0
14:11:08 <monochrom> > (read "123" :: Int, read "True" :: Bool, read "\"hello\"" :: String)
14:11:09 <nmessenger> > let convcurr = show . (/ 100) in convcurr 10232 -- AvengerX, you had an extra (.)
14:11:10 <lambdabot>  (123,True,"hello")
14:11:10 <lambdabot>  "102.32"
14:11:12 <Syzygy-> > read "Left 123" :: Either Int Float
14:11:13 <lambdabot>  Left 123
14:11:16 <chessguy> > read "123" :: String
14:11:18 <lambdabot>  Exception: Prelude.read: no parse
14:11:19 <LoganCapaldo> awesome. GHC just told me to never create a tuple with more than 4 members :)
14:11:30 <Syzygy-> > read "\"123\"" :: String
14:11:31 <lambdabot>  "123"
14:11:39 <SamB> LoganCapaldo: what?
14:11:41 <LoganCapaldo> good to know that was the cut off point for sanity :)
14:11:45 <Syzygy-> chessguy: You have to give it something that looks like a string. :P
14:11:50 <LoganCapaldo> @instances Read
14:11:51 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
14:12:01 <SamB> @instances Show
14:12:03 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
14:12:06 <SamB> hmm.
14:12:07 <monochrom> There was once I needed 5 members in a tuple.
14:12:12 <SamB> > (1, 2, 3, 4, 5)
14:12:14 <lambdabot>  (1,2,3,4,5)
14:12:16 <Syzygy-> > (1,2,3,4,5)
14:12:16 <Syzygy-> (1,2,3,4,5)
14:12:17 <lambdabot>  (1,2,3,4,5)
14:12:25 <Syzygy-> > (1,2,3,4,5,6,7,8,9,10)
14:12:26 <lambdabot>  (1,2,3,4,5,6,7,8,9,10)
14:12:27 <chessguy> monochrom, isn't that what records are for?
14:12:29 <Syzygy-> No problem.
14:12:30 <SamB> @read (1, 2, 3, 4, 5)
14:12:31 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
14:12:32 <xic> isn't the real maximum tuple length 255 in ghc?
14:12:40 <Japsu> > show (1,2,3,4,5)
14:12:41 <lambdabot>  "(1,2,3,4,5)"
14:12:42 <monochrom> It was a one-off thing.
14:12:42 <SamB> @. read show (1, 2, 3, 4, 5)
14:12:43 <lambdabot>  (1, 2, 3, 4, 5)
14:12:45 <Syzygy-> However, -read- isn't implemented for that many.
14:12:53 <SamB> Syzygy-: it isn't ?
14:12:55 <Syzygy-> > show (1,2,3,4,5,6)
14:12:56 <lambdabot>  "(1,2,3,4,5,6)"
14:13:00 <chessguy> ?src Read
14:13:00 <lambdabot> class Read a where
14:13:00 <lambdabot>   readsPrec    :: Int -> ReadS a
14:13:00 <lambdabot>   readList     :: ReadS [a]
14:13:00 <lambdabot>   readPrec     :: ReadPrec a
14:13:00 <lambdabot>   readListPrec :: ReadPrec [a]
14:13:02 <SamB> @. read show (1, 2, 3, 4, 5, 6, 7)
14:13:02 <Syzygy-> SamB: I don't think it is?
14:13:03 <lambdabot>  (1, 2, 3, 4, 5, 6, 7)
14:13:07 <SamB> @. read show (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
14:13:08 <lambdabot>  (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
14:13:09 <Syzygy-> Ok. I shut up instead.
14:13:11 <Japsu> :D
14:13:22 <AvengerX> > putStr (show (1,2,3,4,5,6))
14:13:22 <Syzygy-> SamB: Are you certain that read . show doesn't get .. y'know .. optimized away?
14:13:23 <nmessenger> > (read . show) (1,2,3,4,5,6)
14:13:24 <lambdabot>  <IO ()>
14:13:25 <lambdabot>  Exception: Prelude.read: no parse
14:13:36 <nmessenger> the @read command isn't read
14:13:44 <AvengerX> > putStr (show 1242)
14:13:45 <Japsu> > read $ show $ take 1337 [1..]
14:13:46 <lambdabot>  <IO ()>
14:13:47 <lambdabot>  Exception: Prelude.read: no parse
14:13:50 <Japsu> hmm
14:13:53 <SamB> > (read . show) (1,2,3,4,5,6) :: (Int, Int, Int, Int, Int, Int)
14:13:55 <lambdabot>  (1,2,3,4,5,6)
14:13:59 <Japsu> > read $ show $ take 1337 [1..]
14:14:00 <lambdabot>  Exception: Prelude.read: no parse
14:14:04 <nmessenger> geh
14:14:07 <Japsu> oops, it's a list
14:14:24 <SamB> > (read . show) (1,2,3,4,5,6,7,8,9,10) :: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int)
14:14:25 <lambdabot>  (1,2,3,4,5,6,7,8,9,10)
14:14:31 <Syzygy-> > (read $ show $ take 1337 [1..]) :: [Int]
14:14:31 <nmessenger> hah
14:14:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:14:46 <Syzygy-> Japsu: You need to tell it what kind of a list it is,.
14:14:47 <monochrom> 31337 is prime.
14:14:50 <Japsu> Syzygy-: k
14:15:03 <nmessenger> > (read . show) (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25) :: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int)
14:15:04 <lambdabot>        add an instance declaration for
14:15:05 <lambdabot>       (Show (Int,
14:15:05 <lambdabot>              Int,
14:15:05 <lambdabot>   ...
14:15:08 <fantasma> nmessenger, how do you use seq or $!
14:15:18 <nmessenger> hehe
14:15:22 <Japsu> lol
14:15:26 <chessguy> @slap nmessenger
14:15:26 * lambdabot slaps nmessenger
14:15:42 <nmessenger> @type seq
14:15:45 <lambdabot> forall a t. a -> t -> t
14:15:48 <xerox> > and [mod 31337 p /= 0 | p <- [3,7..floor (sqrt 31337)]]
14:15:49 <siti> IwantThisEvaluated `seq` (beforeUsingIt IwantThisEvaluated)
14:15:50 <lambdabot>  True
14:15:56 <SamB> > (read . show) (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) :: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int)
14:15:58 <lambdabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
14:16:00 <monochrom> fantasma: seq (2+3) True.  negate $! (5+6).
14:16:08 <nmessenger> > undefined `seq` ()
14:16:09 <lambdabot>  Undefined
14:16:10 <AvengerX> > convcurr sty = let (x,y) = splitAt 2 sty in xs ++ ('.' : ys) read in convcurr "1032"
14:16:11 <lambdabot>  Parse error
14:16:11 <SamB> > (read . show) (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) :: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int)
14:16:12 <lambdabot>        add an instance declaration for
14:16:13 <lambdabot>       (Show (Int,
14:16:13 <lambdabot>              Int,
14:16:13 <lambdabot>   ...
14:16:15 <nmessenger> > undefined `const` ()
14:16:16 <lambdabot>  Undefined
14:16:20 <monochrom> "seq (2+3) True" is of course useless.
14:16:24 <xerox> True.
14:16:26 <SamB> ah. 15 is the limit, apparantly
14:16:41 <trurl> SamB: yes, it's in base/GHC/Read.hs
14:16:42 * AvengerX is a dumb
14:16:46 <AvengerX> > convcurr sty = let (x,y) = splitAt 2 sty in xs ++ ('.' : ys) . read in convcurr "1032"
14:16:47 <lambdabot>  Parse error
14:16:47 <trurl> or .lhs
14:17:08 <chessguy> why doesn't someone just generate the code for massive tuples
14:17:15 <monochrom> negate $! (5+6) expands to let x=(5+6) in seq x (f x).  This is more useful.
14:17:26 <SamB> chessguy: waste of space
14:17:36 <SamB> and time
14:17:44 * chessguy shrugs
14:17:46 <chessguy> i guess
14:17:50 <fantasma> monochrom, negate is necessary?
14:18:04 <monochrom> oops, first, a correction.
14:18:06 <nmessenger> AvengerX: lose the (. read)
14:18:10 <monochrom> negate $! (5+6) expands to let x=(5+6) in seq x (negate x).  This is more useful.
14:18:19 <SamB> I assume the current code was generated once ;-)
14:18:31 <monochrom> Second, negate is just an example for a function.  use any function you want.
14:18:53 * nmessenger is reminded of Zelda 1's "Take any one you want."
14:19:13 <nmessenger> gimme the heart container damnit!
14:19:22 <LoganCapaldo> id $! (5+6)
14:19:25 <AvengerX> > convcurr sty = let (x,y) = splitAt 2 sty in xs ++ ('.' : ys)
14:19:25 <AvengerX> ops... nothing to do
14:19:25 <AvengerX> > convcurr sty = let (x,y) = splitAt 2 sty in xs ++ ('.' : ys) read in convcurr "1032"
14:19:25 <AvengerX> > convcurr sty = let (x,y) = splitAt 2 sty in xs ++ ('.' : ys) read in sty "1032"
14:19:25 <lambdabot>  Parse error
14:19:25 <lambdabot>  Parse error
14:19:25 <lambdabot>  Parse error
14:19:26 <AvengerX> hmmmmm
14:19:30 <AvengerX> i'm lagged.
14:20:05 <nmessenger> AvengerX: LB's > is for evaluating expressions, not defining functions.
14:20:06 <fantasma> monochrom, how can i use $! with + or - or ^
14:20:14 <AvengerX> > convcurr sty = let (x,y) = splitAt 2 sty in xs ++ ('.' : ys) in sty "1032" -- like this?
14:20:14 <lambdabot>  Parse error
14:20:18 <AvengerX> no
14:20:27 <monochrom> (+) $! 5 $! 6
14:20:38 <dancor> i want a way to extract all string literals (or any other lexical element) from php code.  i'm finding that using php's internal lexer (token_get_all()) is way slow.  do you think it could be worth it do implement a php lexer is haskell
14:20:45 <fantasma> got it
14:20:55 <dancor> (sorry to mention the abomination of php here)
14:20:57 <monochrom> let {x=5; y=6} in seq x (seq y (x+y))
14:21:06 <SamB> dancor: how complicated is php, lexically?
14:21:27 <siti> dons: should "frag" segfault?
14:21:27 <nmessenger> > (\sty -> let (x,y) = splitAt 2 sty in xs ++ ('.' : ys)) "1032"
14:21:28 <lambdabot>   Not in scope: `ys'
14:21:35 <nmessenger> > (\sty -> let (x,y) = splitAt 2 sty in x ++ ('.' : y)) "1032"
14:21:37 <lambdabot>  "10.32"
14:21:51 <AvengerX> ehn
14:22:01 <AvengerX> its a lil different than I think I could implement in that guard
14:22:07 <AvengerX> not sure tough
14:22:08 <nmessenger> > {- or this: -} let convcurr sty = let (x,y) = splitAt 2 sty in x ++ ('.' : y) in convcurr "1032"
14:22:09 <lambdabot>  "10.32"
14:22:14 <dancor> SamB: their lexer is stateful and a huge mess but i think it's not really that bad if done sensibly
14:22:30 <SamB> do they have some kind of a spec?
14:22:32 <LoganCapaldo> forth has the best lexer _ever_ :)
14:22:40 <monochrom> dancor: perhaps throw in Alex.
14:22:43 <SamB> forth doesn't *have* a lexer
14:22:43 <AvengerX> let's try the first let :)
14:23:29 <SamB> btw, Alex is totally okay with state in lexers
14:23:37 <LoganCapaldo> Sure it does. You got to distinguish between the whitespace and the non-whitespace ;)
14:23:54 <SamB> LoganCapaldo: well, how do you explain "
14:23:55 <monochrom> Alex would probably imply least effort.
14:24:06 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^20 in logBase 10 $! (-) $! phi^n $! (-phi)^^(-n)/(sqrt 5)
14:24:07 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
14:24:07 <lambdabot>     Probabl...
14:24:59 <LoganCapaldo> SamB, ." and s" ? Just cause the lexer is modifiable at runtime doesn't mean its not there :)
14:25:15 <monochrom> logBase 10 $! ((-) $! phi^n $! (-phi)^^(-n)/(sqrt 5)).  Or perhaps even more ()s.
14:25:21 <kc5tja> The "lexer" in Forth returns precisely one token: word.
14:25:56 <kc5tja> " works because " is an executable word.
14:26:00 <monochrom> The "otherwise" in Haskell returns precisely one value: True. :)
14:26:07 <kc5tja> : "   34 word embed ; immediate
14:26:42 <kc5tja> 34 being the ASCII code for the closing quote.  word parses the "word" delimited by the quote.  embed is a platform-specific word that embeds the string into the definition currently being compiled.
14:26:53 <kc5tja> The immediate tag says that " is executed at compile-time, not compiled.
14:27:04 <LoganCapaldo> I'm glad we are in agreement
14:27:17 <allbery_b> forth has a lexer, t's just very simplistic
14:27:19 * kc5tja is writing a Forth environment for my Kestrel project.  :-)
14:27:31 * LoganCapaldo flies away in a flurry of tornadoness
14:28:06 <kc5tja> And as soon as I'm done with it, I'm planning on a few other projects for it, of which a miniature Haskell (or more strict, eager functional language) compiler is on the list of things to explore.
14:28:35 <LoganCapaldo> strict :(
14:29:00 <kc5tja> LoganCapaldo: Well, that's only because I don't *know* how to do lazy evaluation.  :)
14:29:07 <siti> lol
14:29:16 <siti> so you learn is by making a strict compiler ;)
14:29:20 <michaelw> Rob Ennals would agree that strict is good :)
14:29:21 <kc5tja> Nothing wrong with strict FLs; it's just that lazy is better.
14:29:22 <siti> it*
14:29:47 <kc5tja> siti: Huh?  I don't understand your retort.  :)
14:30:23 <kc5tja> All I know about lazy evaluation is that it's basically call-by-name, which I happen to know for the 65816 is going to be VERY slow indeed.  :(
14:30:29 <SamB> kc5tja: you mean besides the fact that the programs to solve certain problems are provably asymptotically worse in strict languages?
14:30:39 <siti> you use haskell to write a compiler for a strict language because you don't understand lazyness, and by doing that you learn lazyness
14:30:55 <monochrom> That is deep.
14:31:15 <SamB> siti: is this some kind of pun?
14:31:20 <siti> no
14:31:24 <kc5tja> SamB: SamB: It won't be any worse than traditional languages.
14:31:25 <siti> it's just funny
14:31:27 <monochrom> It is some kind of Zen.
14:31:34 <SamB> kc5tja: actually, yes it will
14:31:40 <kc5tja> SamB: How so?
14:31:50 <SamB> traditional languages have mutation, strict functional languages don't
14:31:58 <SamB> (I'm not including ML)
14:32:08 <monochrom> what are you including?
14:32:10 <SamB> (it has wierd imperative stuff)
14:32:20 <SamB> um, the original LISP maybe
14:32:28 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^20 in logBase (10 $! (((-) ($! phi^n) ($! (-phi)^^(-n)))/(sqrt 5)))
14:32:29 <lambdabot>        add an instance declaration for (Floating ((a -> b) -> b))
14:32:30 * LoganCapaldo honestly doesn't know of any strict functional languages by that requirement
14:32:42 <kc5tja> SamB: OOOHHH...I see what you mean.
14:32:48 <kc5tja> No, I said *more* strict, not 100% strict.  :D
14:33:01 <SamB> RML, too ;-)
14:33:07 <kc5tja> Something very much like ML was what I had in mind.
14:33:09 <monochrom> You sure the original LISP is strict pure functional?  You swear?
14:33:10 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^20 in logBase 10 ((-) ($! phi^n) ($! (-phi)^^(-n))/(sqrt 5))
14:33:11 <SamB> no, wait...
14:33:11 <lambdabot>        add an instance declaration for (Floating ((a -> b) -> b))
14:33:12 <lambdabot>     In the ...
14:33:12 <siti> arg @ people writing c like code in haskell, and double arg at people that don't know that sizeOf Int != 4 bytes always
14:33:13 <siti> :(
14:33:14 <SamB> that isn't pure
14:33:22 <kc5tja> Lisp is absolutely not pure functional.  :)
14:33:28 <kc5tja> Scheme is closer.
14:33:29 <SamB> how about RML without any of those I/O primitives?
14:33:40 <kc5tja> Not familiar with all the different dialects of ML.
14:33:47 <AvengerX> Is haskell pure? :)
14:33:53 <SamB> RML isn't really a dialect of ML
14:34:07 <kc5tja> AvengerX: I'd say it's a whole lot more pure than ML is.  :)
14:34:18 <SamB> AvengerX: until you add the FFI addendum, yes ;-)
14:34:29 * kc5tja needs to learn the FFI addendum, I think.
14:34:29 <SamB> (or until you pick a compiler ;-)
14:34:39 <AvengerX> FFI-what? :P
14:34:50 <kc5tja> I'm thinking a good first application for me will be some kind of ROX-Filer clone -- preferably one that doesn't bog down badly over NFS shares.  :)
14:34:57 <AvengerX> another extension to haskell (like haskell 98?)
14:34:59 <AvengerX> ?
14:35:01 <kc5tja> AvengerX: Foreign Function Interface.
14:35:08 <AvengerX> hmmm
14:35:20 <SamB> Haskell 98 is not an extension ;-)
14:35:28 <SamB> Haskell 98 is the latest standard
14:35:34 <fantasma> norpan, you there?
14:35:36 <AvengerX> no?
14:35:37 <SamB> the FFI addendum adds some things to it
14:35:38 <monochrom> Haskell 98 is an extension to the empty language {}.
14:35:41 <AvengerX> Hugs liar
14:35:42 <norpan> fantasma: me here
14:35:46 <AvengerX> heh
14:35:49 <kc5tja> monochrom: rolf!
14:35:54 <kc5tja> monochrom: rofl!
14:35:59 * kc5tja can't type while laughing.
14:36:10 <monochrom> you don't have to correct the spelling... :)
14:36:24 <AvengerX> I think I misread this:
14:36:25 <kc5tja> Yes, I'm rolling on the laughing floor!
14:36:25 <AvengerX> Haskell 98 mode: Restart with command line option -98 to enable extensions
14:36:39 <AvengerX> when I -disable- the 98 mode, it 'enables that extensions'
14:36:45 <fantasma> norpan, how did you do the function with seq: let phi = (1 + sqrt 5)/2; n = 2^20 in logBase 10 ((phi^n)-(-phi)^^(-n)/(sqrt 5))
14:36:46 <monochrom> No misreading.
14:36:47 <kc5tja> monochrom: What's worse, is that rolf! just made me laugh even harder.
14:37:17 <monochrom> OK, do correct the spelling, so you don't laugh too hard and hurt yourself. :)
14:37:29 <AvengerX> kc5tja; happy floor yours huh?
14:37:41 <norpan> fantasma: with seq? i don't really get what you mean
14:37:53 <monochrom> fantasma: in all reality you don't need seq for that at all.
14:38:09 <fantasma> well I am getting values of infinity when I evaluate that
14:38:20 <monochrom> seq will not change that.
14:38:41 <fantasma> what will?
14:39:12 <monochrom> phi to the power 2^20 is probably just too large to fit in Double.
14:39:30 <fantasma> let me check
14:39:50 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^20 in phi^n
14:39:52 <lambdabot>  Infinity
14:40:03 <monochrom> You can't do 10^10^10^10^10^10 and just expect there is some trick to fit in in your mere 4GB RAM computer.
14:40:34 <kc5tja> monochrom: But you managed to fit the quantity in a handful of bytes just now.  :D
14:40:34 <LoganCapaldo> this is why we need lazy doubles :)
14:40:48 <fantasma> so phi^(2^20) would never compute?
14:40:49 <monochrom> lazy doubles is quite an idea :)
14:40:51 <SamB> > 10^10^10^10^10^10
14:40:55 * kc5tja remembers Mathematica that would do precisely this -- if the result was too big, it'd just spit back the very expression you tried to solve as the answer.  :)
14:40:56 <lambdabot> Terminated
14:40:58 <SamB> > 10^10^10^10^10
14:41:03 <lambdabot> Terminated
14:41:06 <SamB> > 10^10^10^10
14:41:10 <lambdabot> Terminated
14:41:14 <SamB> > 10^10^10
14:41:19 <lambdabot> Terminated
14:41:19 <nmessenger> @. elite run 10^10^10^10^10
14:41:23 <lambdabot> terMin4t3d
14:41:26 <glguy> > 2 ^ 2 ^ 10
14:41:28 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
14:41:36 <SamB> oh.
14:41:40 <SamB> @assoc ^
14:41:41 <lambdabot> Unknown command, try @list
14:41:44 <glguy> > 2 ^ 2 ^ 10 == floor (1/0::Double)
14:41:45 <lambdabot>  True
14:41:46 <fantasma> how do I do phi^(2^20)?
14:41:46 <SamB> someone make it work
14:42:11 <nmessenger> @where fixity
14:42:11 <lambdabot> http://www.haskell.org/onlinereport/decls.html#sect4.4.2
14:42:14 <AvengerX> > (\sty -> let (x,y) = splitAt 2 sty in x ++ ('.' : y)) "03"
14:42:16 <lambdabot>  "03."
14:42:24 <AvengerX> > (\sty -> let (x,y) = splitAt 2 sty in x ++ ('.' : y)) "0398"
14:42:25 <lambdabot>  "03.98"
14:42:37 <monochrom> Computers are not meant to solve all your problems.  This is not a limitation of Haskell.
14:42:42 <AvengerX> who defined sty here? :)
14:42:50 <AvengerX> gnn
14:42:51 <AvengerX> hmm
14:42:59 <kc5tja> AvengerX: It's pickled tink.
14:42:59 <SamB> "03" is sty...
14:43:07 <SamB> or "0398"
14:43:11 <fantasma> monochrom, im just asking, would it be possible to do phi^(2^20) on a computer?
14:43:19 <SamB> what is phi?
14:43:21 <AvengerX> but how was it bound there? didnt understand this
14:43:24 <SamB> and what is "do"?
14:43:35 <AvengerX> well, forget it
14:43:49 <fantasma> phi is (1 sqrt 5)/2
14:43:58 <allbery_b> AvengerX: the \ there is a lambda binding.
14:44:10 <AvengerX> ahh
14:44:12 <allbery_b> \pattern -> expansion
14:44:16 <monochrom> That's a trick question.
14:44:41 <monochrom> If you say, use ieee 754 arithmetic, no.
14:44:49 <allbery_b> in this case pattern is "sty", which is introduced as a new symbl by the \
14:44:50 <kc5tja> 2^20 is, let's say, 1e+06.  Since the product of two numbers can be represented (worst case) in a number of length (sum of lengths of two multiplicands), then the length of a number (in digits) of n^(2^20) is going to be close to n*1e+06 digits long.
14:45:06 <kc5tja> (it'll actually be a bit more than that, since 2^20 is 1048576, not 1000000)
14:45:19 <monochrom> If you say, use a multiple-precision arithmetic library, perhaps, depending on how many digits you want.
14:45:41 <fantasma> haskell aside, is there some program that would be able to compute that value?
14:45:53 <allbery_b> probably
14:45:54 <monochrom> Yes.
14:46:05 <allbery_b> it'll be expensive and slow :)
14:46:06 <monochrom> But I like allbery_b's "probably" more.
14:46:07 <SamB> monochrom: couldn't you use ieee 754 if you used a large enough extended representation?
14:46:08 <kc5tja> So, it is possible.  But a double precision real number only can handle about 308 digits -- a far cry from the millions of digits needed by the above expression. :)  Concur with monochrom -- use a specially designed library to represent such large numbers.
14:46:17 <AvengerX> > sty :: String; sty = "1032"; let (x,y) = splitAt 2 sty in x ++ ('.' : y) -- will be the same?
14:46:17 <lambdabot>  Parse error
14:46:21 <AvengerX> no
14:46:24 <LoganCapaldo> lazy doubles!
14:46:29 <SamB> LoganCapaldo: hah
14:46:36 <fantasma> my friend he said he was able to compute logBase 10 ((phi^n)-(-phi)^^(-n)/(sqrt 5)) but I think he is bullshit
14:46:44 <kc5tja> SamB: You're looking at kilobits of space for the mantissa and perhaps hundreds of bits for the exponent if you do.
14:46:44 <allbery_b> you can't do top level bindings in lambdabot
14:46:46 <monochrom> SamB: Yes.
14:47:05 <LoganCapaldo> welll
14:47:16 <LoganCapaldo> ?let sty = "1032"
14:47:17 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:47:21 <SamB> kc5tja: hundreds of bits are no problem...
14:47:34 <allbery_b> > let sty :: String; sty = "1032"; let (x,y) = splitAt 2 sty in x ++ ('.' : y)
14:47:34 <lambdabot>  Parse error
14:47:36 <AvengerX> hmmmm
14:47:59 <kc5tja> SamB: True, but you're still not looking at using what the innate hardware already provides.  :)  It'll be software emulated floating point.
14:48:01 <allbery_b> > let sty :: String; sty = "1032"; (x,y) = splitAt 2 sty in x ++ ('.' : y)
14:48:03 <lambdabot>  "10.32"
14:48:17 <siti> does anyone know if CInt (in haskell) is 64bit on any 64bit OS? on every OS except windows?
14:48:23 <monochrom> fantasma: Are you able to compute 2^100000?  Probably not.  Are you able to compute log_2 (2^100000)?  Oh yes, it's just 100000, what is there to compute?
14:48:29 <AvengerX> nowell you did it.. didn't you?
14:48:33 <SamB> kc5tja: that is no emulation
14:48:36 <AvengerX> > sty :: String; sty = "1032"; let (x,y) = splitAt 2 sty in x ++ ('.' : y) -- will be the same?
14:48:36 <SamB> it just isn't fast
14:48:37 <lambdabot>  Parse error
14:48:42 <AvengerX> > let sty :: String; sty = "1032"; let (x,y) = splitAt 2 sty in x ++ ('.' : y) -- will be the same?
14:48:43 <lambdabot>  Parse error
14:48:45 <SamB> the software was and always will have been first
14:48:53 <AvengerX> > let sty :: String; sty = "1032"; (x,y) = splitAt 2 sty in x ++ ('.' : y) -- will be the same?
14:48:55 <lambdabot>  "10.32"
14:48:56 <fantasma> monochrom, that's why I need help
14:48:58 <AvengerX> ahggggghhhh
14:48:59 <AvengerX> :P
14:49:04 <monochrom> Computing "log_10 blahblah" is not the same as computing "blahblah" first then do the log.
14:49:08 <fantasma> monochrom, I want to compute the log of that huge number
14:49:35 <monochrom> OK, if you gave me a week I could come up with an efficient algorithm.
14:49:36 <fantasma> regardless of what happens first or last
14:49:42 <AvengerX> hugs bad. lambdabot good.
14:49:51 <SamB> and an algorithm is as good as pi
14:49:52 <monochrom> But since your friend has done it, I suggest we reuse software.
14:49:58 <monochrom> hahaha SamB
14:50:34 <monochrom> fantasma: And also that is why I always whine about people not asking their real questions.
14:50:42 <SamB> I mean, algorithms are the only ways we have to represent pi
14:50:52 <fantasma> > 2^20
14:50:53 <AvengerX> allright... I think I really have problems with that double '
14:50:54 <lambdabot>  1048576
14:50:56 <AvengerX>  '='
14:51:10 <AvengerX> let me try to pass it to kind lambdabot
14:51:17 <fantasma> > 1.8^1048576
14:51:18 <lambdabot>  Infinity
14:51:27 <fantasma> > 1.6^1048576
14:51:28 <lambdabot>  Infinity
14:51:32 <fantasma> cool
14:52:30 <monochrom> (-phi)^(-n) is probably negligible for large n.  pretend it is not there.
14:53:09 <monochrom> log (phi^n / sqrt(5)) = n * log (phi) - log(sqrt(5))  is quite manageable.
14:53:09 <fantasma> i agree
14:53:48 <fantasma> > 2^20 * logBase 10 (1.6)
14:53:50 <lambdabot>  214035.314933419
14:53:55 <fantasma> ok............
14:54:19 <monochrom> I am debating with myself on whether I should recommend the #math channel... :)
14:54:20 <fantasma> > 2^20 * logBase 10 (1.6) - logBase 10 (sqrt 5)
14:54:22 <lambdabot>  214034.96544841683
14:54:26 <fantasma> lol
14:54:37 <AvengerX> > price::Int->String; price x = | length (show price) == 1 = "0.0" ++ (show x) | otherwise = let ((ini,end) = splitAt 2 x in ini ++ ('.' : end))
14:54:37 <lambdabot>  Parse error
14:55:14 <fantasma> monochrom, i've never worked with large numbers like this before
14:55:41 <monochrom> college math helps
14:55:49 <AvengerX> I had to work with large numbers with C and used GMP (heh)
14:55:51 <fantasma> im in highschool :(
14:56:05 <AvengerX> Integer in haskell is boundless precision, isnt it?
14:56:16 <monochrom> Ah, but Hong Kong highschool has log too. :)
14:56:17 <SamB> Integer in GHC uses GMP
14:56:21 <AvengerX> (while Int is limited to blah blah)
14:56:35 <kc5tja> > :t Integer
14:56:35 <lambdabot>  Parse error
14:56:43 <kc5tja> And thus, my theory is proven.
14:56:57 <monochrom> what theory?
14:57:05 <nmessenger> kc5tja: that > doesn't do @commands?
14:57:07 <kc5tja> monochrom: All integers are parse errors.  ;D
14:57:29 <nmessenger> or :commands?
14:57:37 <AvengerX> > i :: Integer ; i = 1.8^1048576; show i
14:57:37 <lambdabot>  Parse error
14:57:40 <allbery_b> @instances Bounded
14:57:42 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
14:57:54 <AvengerX> bah :)
14:58:11 <AvengerX> > price::Int->String; price x = | length (show price) == 1 = "0.0" ++ (show x) | otherwise = let ((ini,end) = splitAt 2 x in ini ++ ('.' : end))
14:58:11 <nmessenger> > show (1.8^1048576 :: Integer) -- AvengerX, why the indirection?
14:58:12 <lambdabot>  Parse error
14:58:12 <lambdabot>   add an instance declaration for (Fractional Integer)
14:58:21 <AvengerX> to golf guards I must use ';'?
14:58:44 <allbery_b> AvengerX: you are doing decarations, you need to use "let"
14:58:48 <nmessenger> semicolons seperate declarations either at the toplevel, or in a let.
14:58:56 <allbery_b> > a = 1 -- error
14:58:57 <lambdabot>  Parse error
14:59:07 <allbery_b> > let a = 1 in a
14:59:09 <lambdabot>  1
14:59:10 <AvengerX> > let (price::Int->String; price x = | length (show price) == 1 = "0.0" ++ (show x) | otherwise = (ini,end) = splitAt 2 x in ini ++ ('.' : end))
14:59:10 <lambdabot>  Parse error
14:59:14 <monochrom> AvengerX: there is a way to pass definitions to lambdabot, but it is not ">".  Why don't you try it in a source file?
14:59:18 <allbery_b> no parens
14:59:32 <shapr> syntaxfree: Haha, I like the ADD quote on your blog. It's SO true!
14:59:55 <AvengerX> > let price::Int->String in price; price x = | length (show price) == 1 = "0.0" ++ (show x) | otherwise = (ini,end) = splitAt 2 x in ini ++ ('.' : end)
14:59:55 <lambdabot>  Parse error
14:59:58 <monochrom> lambdabot is not a full Haskell environment.  Things can be rejected by lambdabot but still valid Haskell.
15:00:03 <AvengerX> I'm trying there, with no luck :)
15:00:05 <SamB> shapr: what did he say?
15:00:27 <monochrom> Well use hpaste and show your code and error.
15:00:27 <AvengerX> Sorry, I won't be poking code to lambdabot anymore
15:00:33 <shapr> SamB: Q: How many people with ADD does it take to change a lightbulb?
15:00:42 <nmessenger> AvengerX: the syntax is (let {decl; decl} in expr), so (let {(decl; decl} in expr)) doesn't make sense.
15:00:45 <shapr> SamB: Can you guess the right answer?
15:00:48 <monochrom> It's ok to poke code to lambdabot, just don't believe anything it says.
15:00:58 <SamB> abz: Haskell people just make a new light bulb?
15:01:02 <SamB> er.
15:01:04 <SamB> abz:
15:01:06 <SamB> ack
15:01:07 <allbery_b> you mean "everything it says" don't you?
15:01:16 <SamB> horrible horrible x-chat
15:01:16 <AvengerX> nmessenger: lol you are right! I am a lil confused
15:01:18 <AvengerX> :)
15:01:24 <SamB> I meant to say "A:"
15:01:27 <shapr> SamB: A: HEY! Let's ride bikes!
15:01:32 <SamB> shapr: heh
15:02:17 <SamB> @remember syntaxfree Q: How many people with ADD does it take to change a lightbulb? ... A: HEY! Let's ride bikes!
15:02:18 <lambdabot> Done.
15:02:25 <shapr> Yeah, worth saving.
15:02:40 <monochrom> allbery_b: A major newbie problem is they take what lambdabot does and cross-examine us people with that.  It's very counter-productive.  You're right, but for all newbie practically purposes let's just deny everything and save the trouble.
15:02:51 <fantasma> > (-1.6)^^(-(2^20))
15:02:52 <lambdabot>  0.0
15:03:00 <fantasma> good one lambabot
15:03:10 <fantasma> > (-1.6)^^(-(2^10))
15:03:11 <lambdabot>  9.574977460951134e-210
15:03:12 <shapr> I think that's particularly amusing since I was out of ADD meds for the last three days. During those three days I somehow became convinced that yesterday was Friday.
15:03:34 <SamB> shapr: !!!
15:03:35 <SamB> wow
15:03:46 <SamB> I haven't been out for that long in a long time
15:03:47 <tmoertel> How many Haskell programmers does it take to change a lightbulb?
15:04:06 <SamB> Haskell programmers make new lightbulbs, duh
15:04:13 <monochrom> "lightbulb" is overloaded
15:04:13 <fasta> tmoertel: undefined
15:04:15 <nmessenger> which category is the lightbulb in?  WE NEED MONAD TRANSFORMERS!!
15:04:27 <monochrom> hahaha
15:04:34 <shapr> tmoertel: I'd guess Haskell programmers make a new socket with bulb included and just garbage collect the old one?
15:04:59 <SamB> actually, maybe Haskell lightbulbs, being purely functional, don't burn out?
15:05:05 <shapr> Oh good idea!
15:05:06 <fasta> 0, the GC finalizes one.
15:05:09 <nmessenger> they change it in stereo!
15:05:12 <Pastorn_> is splitEvery included in the upcoming haskell standard?
15:05:19 <SamB> and we just reuse the same Lightbulb value from the .o file ;-)
15:05:59 <tmoertel> My ans ==> None: the existing lightbulb is just fine, but it won't emit photons until you try to consume them.
15:06:06 <nmessenger> Pastorn_: (splitEvery :: ?) (splitEvery x = y) for what x and y?
15:06:18 <SamB> tmoertel: heh
15:06:27 <Pastorn_> hang on...
15:06:31 <AvengerX> pastebin's .com?
15:06:40 <Pastorn_> @paste
15:06:40 <monochrom> @hpaste
15:06:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:06:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:06:42 <AvengerX> it looks like sloow
15:06:51 <AvengerX> ah good
15:06:59 <nmessenger> splitEvery 3 "my head asplode" = ["my ","hea","d a","spl","ode"]?
15:07:08 <Pastorn_> yes
15:07:16 <Pastorn_> just like that
15:07:17 <hpaste>  Avenger pasted "(no title)" at http://hpaste.org/627
15:07:26 <AvengerX> http://hpaste.org/627
15:07:27 <shapr> tmoertel: haha
15:07:29 <AvengerX> ops
15:07:29 <AvengerX> heh
15:07:30 <SamB> @source splitEvery
15:07:31 <lambdabot> splitEvery not available
15:07:32 <AvengerX> ty hpaste :P
15:07:37 <SamB> @src splitEvery
15:07:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:07:50 <SamB> @src splitYouInHalf
15:07:50 <AvengerX> That's what I'm trying to do to make that formatted monetary value :P
15:07:51 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:08:14 * monochrom loves pastes
15:08:22 <nmessenger> splitEvery n = takeWhile (not . null) . unfoldr (Just . splitAt n)
15:08:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/628
15:09:12 <Pastorn_> thats splitEvery
15:09:44 <nmessenger> > (takeWhile (not . null) . unfoldr (Just . splitAt 3)) "my head asplode"
15:09:45 <lambdabot>  ["my ","hea","d a","spl","ode"]
15:10:02 <david_> I'm a beginner in haskell but your otherwise guard looks weird.
15:10:16 <sorear> helloj
15:10:19 <Pastorn_> david_: who's? where?
15:10:19 <sorear> @src otherwise
15:10:20 <lambdabot> otherwise = True
15:10:25 <monochrom> AvengerX: missing "let" before (lx,ly).  splitAt 2 x  should be  splitAt 2 (show x)
15:10:37 <nmessenger> AvengerX: add a 'let' to the last case
15:10:43 <AvengerX> hmm
15:10:44 <david_> Pastorn : the one recently posted to hpaste
15:10:55 <monochrom> All errors are programmer errors.
15:10:57 <AvengerX> I had a let and didn't work anyway... let's see
15:11:14 <monochrom> I just tested my suggestion and no error.
15:11:17 <nmessenger> though formataCentavos = show . (`div` 100) is certainly better
15:11:21 <AvengerX> david_: no problem... I am less than I beginner.. heh
15:11:22 <kscaldef> monochrom: but which programmer?
15:11:46 <nmessenger> er, wait, no
15:11:49 <monochrom> The less skilled programmer, most likely.  There are exceptions.
15:11:53 <AvengerX> ERROR "fazNota.hs":56 - Type error in application
15:11:53 <Pastorn_> AvengerX: Preco?
15:12:02 <AvengerX> Pastorn_: means price
15:12:07 <Pastorn_> ah
15:12:14 <nmessenger> formataCentavos = show . (/ 100) . fromIntegral -- possibly
15:12:47 <david_> would this : " lx ++ "." ++ ly where ( ly,ly ) = splitAt 2 (show x) " be ok ????
15:12:49 <AvengerX> nmessenger: I think I may not use floats (cause of it's rounding or truncatings)
15:13:02 <david_> I mean otherwise = lx ++ "." ++ ly where ( ly,ly ) = splitAt 2 (show x)
15:13:10 <monochrom> Yes.
15:13:31 <nmessenger> david_: yep
15:13:37 <AvengerX> you mean where (lx,ly)?
15:13:46 <david_> yes sorry ( typo )
15:13:52 <monochrom> It's ok to use "where".  But I'm so keen on "let" because I want to dispel the myth "let doesn't work".
15:13:54 <AvengerX> I should have used that where since the beginning :P
15:14:17 <monochrom> PLEASE DON'T GO HOME THINKING "LET DOESN'T WORK".  Please.
15:14:26 <AvengerX> lol
15:14:38 <david_> I think as a newbie where is clearer ( easier to understand/read ) than let :)
15:14:50 <AvengerX> monochrom: allright. I'll reduce the sentence to 'let doesn't work for me'
15:14:51 <AvengerX> heh
15:15:03 <monochrom> How about "I doesn't work for let'>
15:15:10 <AvengerX> lol
15:15:14 <david_> :-D
15:15:15 <AvengerX> fits good as well
15:15:32 <SamB> david_: I'd have to agree that where is usually nicer when you can use it without sticking unneeded branch constructs in your code ;-)
15:15:36 <AvengerX> 'Don't let me try to use let.'
15:16:09 <AvengerX> my teacher said something like it about the 'where'
15:16:14 <nmessenger> Friends don't let friends = let friends...
15:16:30 <monochrom> ...
15:16:39 <fasta> Recursion is recursion
15:16:48 <david_> it's late here. good night people.
15:16:50 <nmessenger> fasta: that's bottom!
15:17:12 <fasta> nmessenger: and a wonderful example of recursion
15:17:13 <nmessenger> recursion is recursion or a base case
15:17:14 <monochrom> bottom is a least fixed point.  fits well with recursion.
15:17:50 <monochrom> recursion is recursion and a base case   (now I'm mincing words, duck)
15:18:03 <AvengerX> I can use also a 'xlen = length (show x)' under the where for the other guards as well, can't I?
15:18:10 <monochrom> YES!
15:18:29 <AvengerX> OMFG at last I said something that makes sense! (I think)
15:18:31 <monochrom> You can probably just have it once and shared by all guards.
15:18:41 * sorear has managed to memorize www.cse.unsw.edu.au/~dons/nobench/results.html, *sigh*
15:19:03 <monochrom> You even memorize the random numbers?
15:19:06 <nmessenger> 'where' scopes over all guards, a 'let' expression scopes over the 'in' expression
15:19:44 <monochrom> Haskell makes sense.
15:19:58 <nmessenger> monochrom: profound.
15:20:01 <AvengerX> Haskell makes.. -I- don't most of the times
15:20:05 <sorear> monochrom: the URL :)
15:20:12 <monochrom> heh
15:20:30 <monochrom> Even I don't always remember my own urls. :)
15:20:35 * SamB thinks we need to have some benchmarks that hugs wins at
15:20:55 <AvengerX> <nmessenger> AvengerX: the syntax is (let {decl; decl} in expr),
15:20:55 <AvengerX> hmmmm
15:21:06 <fasta> SamB: load time
15:21:09 <monochrom> Such as atom, SamB.  http://www.haskell.org/pipermail/haskell-cafe/2007-February/022720.html
15:21:11 <lambdabot> Title: [Haskell-cafe] Re: Haskell vs Ruby as a scripting language, http://tinyurl.com/25taqx
15:21:15 <kc5tja> SamB: You can deliberately inject bad code into it, thus making it the fastest crashing Haskell compiler.  >:)
15:21:19 * kc5tja runs
15:21:19 <sorear> #ifdef __GLASGOW_HASKELL__
15:21:19 <sorear> main = return $! last [0..]
15:21:19 <sorear> #else
15:21:19 <sorear> main = return ()
15:21:23 <sorear> #endif  /* SamB */
15:21:33 <monochrom> naught boy
15:21:42 <SamB> sorear: hmm.
15:21:47 <fasta> sorear: That's cheating
15:21:52 <SamB> I guess I meant that compile time should be included?
15:22:18 <fasta> sorear: place some .so files that you don't use and pass them on the command line... that will crash too
15:22:25 <monochrom> OH!  Do an Oleg type-level arithmetic Eratosthenes Sieve thing!
15:22:35 <fasta> sorear: (incompatible .so files, that is)
15:22:51 <sorear> fasta: how will that *slow* ghc *relate to hugs*
15:23:00 <sorear> not crash, not both
15:23:10 <nmessenger> AvengerX: right, except the layout rule allows you to omit the curlies and semicolons.
15:23:13 <monochrom> Get them to debate "this is/isn't the Sieve!"...
15:23:45 <fasta> sorear: Nm
15:24:12 <fasta> sorear: I thought it would use up all memory and die, which of course it doesn't.
15:24:12 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^20 in (n * (logBase 10 (phi^n)) - (logBase 10 (sqrt 5)))
15:24:13 <lambdabot>  Add a type signature
15:24:19 <AvengerX> kty
15:24:30 <AvengerX> lemme see if I put that to work (/me crosses fingers)
15:24:40 <AvengerX> Prelude> :r
15:24:41 <AvengerX> Main>
15:24:42 <AvengerX> \o/
15:24:47 <SamB> okay, let me restate it...
15:24:49 <AvengerX> forgot to name the module :)
15:25:03 <SamB> we should have benchmarks for compilation time+runtime, too
15:25:18 <nmessenger> <('.'<)  (>'.')>  ^( '.' )^  kirby dance!!!
15:25:26 <AvengerX> now that compilation time is getting so common, it would be a good idea
15:25:47 <AvengerX> heh What's a kirby? Kinda a fluffy bear?
15:26:03 <nmessenger> AvengerX: video game character
15:26:15 <AvengerX> oh my
15:26:24 <fasta> @google Kirby SNES
15:26:29 <lambdabot> http://www.gamespot.com/snes/action/hoshinokirbysuperdeluxe/index.html
15:26:29 <lambdabot> Title: Kirby Super Star for SNES - Kirby Super Star SNES - Kirby Super Star SNES Game
15:26:42 <fasta> Or:
15:26:48 <fasta> @google Kirby NES
15:26:52 <AvengerX> heh, should have stepped thru one of that in my zsnes roms dvd
15:26:52 <lambdabot> http://www.gamespot.com/nes/action/hoshinokirby/index.html
15:26:52 <lambdabot> Title: Kirby's Adventure for NES - Kirby's Adventure NES - Kirby's Adventure NES Game
15:26:56 * nmessenger <3 Kirby's Adventure NES
15:27:07 <fasta> nmessenger: yeah
15:27:24 <nmessenger> @google kirby nintendo
15:27:26 <lambdabot> http://en.wikipedia.org/wiki/Kirby_(Nintendo)
15:27:27 <lambdabot> Title: Kirby (Nintendo) - Wikipedia, the free encyclopedia
15:27:28 <nmessenger> ^^ more general
15:27:34 <AvengerX> I have a SNES... emulators never emulated the super mario's spin jump sound correctly
15:27:51 <Pastorn_> hehe
15:28:00 <Pastorn_> Zsnes on windows works fine =)
15:28:00 <SamB> AvengerX: hmm.
15:28:05 <SamB> Pastorn_: no it doesn't
15:28:15 <AvengerX> Pastorn_: try super marios' spin jump
15:28:20 <SamB> the spc core is horrible
15:28:20 <AvengerX> and compare with the sound of the console
15:28:34 <Pastorn_> then tweak it :)
15:28:41 <AvengerX> Tried all confs
15:28:42 <fasta> @google "spc core"
15:28:42 <SamB> we are in the middle of fixing it, though
15:28:44 <AvengerX> no one worked
15:28:45 <lambdabot> http://www.accd.edu/spc/iprdept/AtD/March%203,%202006%20agenda%20and%20notes.doc
15:28:53 <fasta> What is a spc core?
15:28:56 <SamB> 1.60 should sound a lot better if we ever get it to work right
15:29:04 <Pastorn_> anyway, Kirby Superstar is sooooo great
15:29:05 <fasta> SamB: you work on SNES emulators?
15:29:06 <AvengerX> fasta: something that is horrible
15:29:07 <AvengerX> :)
15:29:22 <SamB> fasta: the sound subsystem of the SNES is called the SPC, usually...
15:29:28 <AvengerX> ah
15:29:33 * nmessenger apologizes for derailing the conversation
15:29:46 <AvengerX> yes it is not perfect like the console game
15:29:58 <fasta> SamB: I have a SNES, but don't know the specs.
15:30:07 <AvengerX> It was good to plug a snes control in the parport, and put zsnes in the television...
15:30:15 <AvengerX> but the sound left something over...
15:30:29 <SamB> anyway...
15:30:31 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^20 in floor(n * (logBase 10 phi) - (logBase 10 5)/2) + 1
15:30:32 <lambdabot>  219140
15:30:53 <fantasma> leet
15:31:08 <sorear> > elem 219140 (fix ((1:).scanl (+) 1))
15:31:11 <SamB> the other ZSNES people ripped out the old waveform generation code a few weeks back
15:31:17 <AvengerX> wwus that phantom?
15:31:28 <monochrom> lambdabot come back!
15:31:28 <sorear> > drop 20 (fix ((1:).scanl (+) 1))
15:31:36 <lambdabot>  [10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,21...
15:31:37 <monochrom> You killed Kenny!
15:31:38 <sorear> @botscnak
15:31:39 <lambdabot> :)
15:31:52 <xerox> @botscan
15:31:53 <lambdabot> Unknown command, try @list
15:31:54 <AvengerX> lol
15:32:18 <sorear> OK, that's NOT a fibbonacci number
15:32:29 <SamB> and when we started hooking up the new one, I noticed how innaccurate the old setup was
15:32:49 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^50 in floor(n * (logBase 10 phi) - (logBase 10 5)/2) + 1
15:32:51 <lambdabot>  235299164688711
15:32:58 <SamB> (others did too, probably)
15:33:05 <SamB> (but maybe they already knew?)
15:33:31 <fasta> SamB: Cool
15:33:43 <SamB> it had been running the sample-generation asynchronously compared to the CPU that controlled it
15:33:59 <SamB> I have to wonder how it sounded as good as it did
15:34:03 <AvengerX> sounds strange: module Name where
15:34:21 <AvengerX> where aaaalll the file down
15:34:32 <SamB> anyway, so in 1.60 it should sound more accurate
15:34:38 <sorear> yeah, that's how h98 module headers work
15:34:51 <sorear> module Name(optional export list) where entire_file
15:35:01 <AvengerX> SamB: you work with developing zsnes or something like that?
15:35:03 <sorear> you can even indent the file if you want :)
15:35:16 <SamB> but we're still having some trouble with the timing between the sound emulation and the main CPU
15:35:21 <SamB> AvengerX: yeah
15:35:25 <AvengerX> sorear: yeah hehe weird
15:35:36 <nmessenger> "Kirby is also known as a skilled dancer." heheh
15:35:54 <roerd> @pl [ a*b | a <- [1,2,3], b <- [4,5,6] ]
15:35:55 <lambdabot> [a * b | a <- [1, 2, 3], b <- [4, 5, 6]]
15:36:06 <sorear> SamB: didn't you also write a SNES emulator in Haskell?
15:36:16 <SamB> no
15:36:18 <AvengerX> SamB: cool man! I really enjoy zsnes on the television despite the sound problem with the spin jump
15:36:19 <sorear> > liftM2 (*) [1,2,3] [4,5,6]
15:36:21 <lambdabot>  [4,5,6,8,10,12,12,15,18]
15:36:28 <SamB> sorear: you must be confused with my Z-machine interpreter?
15:36:32 <nmessenger> zsnes on the TV?!
15:36:34 <sorear> roerd: you looking for that? ^^
15:36:38 <sorear> SamB: ah yes.
15:36:40 <SamB> nmessenger: TV out card?
15:36:44 <nmessenger> er, heh, yeah
15:36:56 <AvengerX> well...
15:37:09 <AvengerX> I must setup primary desktop to the television in order to play on the tv :)
15:37:32 <AvengerX> but the game quality becomes exactly as the videogame (we use it at 320x200, no scanlines (duh))
15:37:38 <fantasma> guys I did it
15:37:41 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^1000 in floor(n * (logBase 10 phi) - (logBase 10 5)/2) + 1
15:37:43 <lambdabot>  2239320553233994133934543986395243007280135370546670446717269489524600061013...
15:37:55 <roerd> @pl do a <- [1,2,3]; b <- [4,5,6]; [a*b]
15:37:56 <lambdabot> (line 1, column 16):
15:37:56 <lambdabot> unexpected ";"
15:37:56 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:37:59 <AvengerX> what does that ... means?
15:38:11 <AvengerX> heh
15:38:13 <sorear> AvengerX: truncated output
15:38:13 <SamB> we still need to make some changes to get it to generate enough samples each frame, I think...
15:38:18 <AvengerX> hehehe
15:38:21 <sorear> roerd: @pl doesn't do do
15:38:28 <xerox> @. pl undo do {a <- [1,2,3]; b <- [4,5,6]; return (a*b)}
15:38:29 <lambdabot> (`fmap` [4, 5, 6]) . (*) =<< [1, 2, 3]
15:38:30 <sorear> roerd: you looking for liftM2 ?
15:38:31 <SamB> it isn't clocking the sound unit quite enough
15:38:37 <siti> who wants to beat my AI at draughts ;), bzr branch http://siti.geek.nz/draughts.bzr/
15:38:37 <AvengerX> SamB: I tought it was like not being developed anymore
15:38:41 <lambdabot> Title: Index of /draughts.bzr
15:38:42 <sorear> roerd: what you looking for?
15:38:44 <SamB> AvengerX: what, ZSNES?
15:38:50 <SamB> what version are you using?
15:38:56 <nmessenger> heh "@pl doesn't do do".  Well how does it remove bodily wastes :P
15:39:45 <AvengerX> 1.42 jan 19 2005
15:39:48 <SamB> 1.51 is the latest release
15:39:48 <roerd> I was looking for a way to turn do-notation into application of (>>=) without lambdas
15:39:53 <AvengerX> my version. yes zsnes. :)
15:39:54 <sorear>  @undo
15:40:05 <sorear> @undo do {a <- [1,2,3]; b <- [4,5,6]; return (a*b)}
15:40:06 <lambdabot> [1, 2, 3] >>= \ a -> [4, 5, 6] >>= \ b -> return (a * b)
15:40:17 <AvengerX> SamB: it already has that improvements with sound you talked about?
15:40:19 <sorear> well, @. pl undo
15:40:20 <nmessenger> roerd: then compose @undo with @pl
15:40:23 <SamB> AvengerX: no
15:40:24 <sorear> but it failed
15:40:28 <sorear> so just ask me
15:40:33 <sorear> > liftM2 (*) [1,2,3] [4,5,6]
15:40:35 <lambdabot>  [4,5,6,8,10,12,12,15,18]
15:40:43 <SamB> we haven't finished the sound improvements yet
15:40:44 <Saizan> @sorear ?
15:40:44 <lambdabot> Unknown command, try @list
15:40:47 <AvengerX> <SamB> the other ZSNES people ripped out the old waveform generation code a few weeks back
15:40:57 <AvengerX> hmm
15:40:57 <sorear> er, us. @#haskell
15:41:20 <nmessenger> @#haskell MY CODES DON'T WORKING!!?!
15:41:21 <lambdabot> Unknown command, try @list
15:41:23 <AvengerX> Cool, I hope to hear mario's spinjump like in the console! :P
15:41:31 <Pastorn_> ?src liftM2
15:41:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:41:39 <SamB> AvengerX: I personally cannot test it on the console
15:41:42 <SamB> my console is broken
15:41:48 <SamB> the power light won't light
15:41:54 <Saizan> @sorear to understand LB internals, is there some paper or should i just read the sources?
15:41:55 <lambdabot> Unknown command, try @list
15:41:57 <AvengerX> SamB: I can record the sound and send you if you want (heh)
15:42:12 <Pastorn_> ?src liftM
15:42:12 <sorear> Saizan: just read the sources :(
15:42:12 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
15:42:13 <SamB> AvengerX: sure ;-)
15:42:20 <SamB> I really ought to be walking the dog...
15:42:43 <Saizan> tought so :\
15:42:45 <Pastorn_> > liftM not (Just True)
15:42:47 <AvengerX> oh
15:42:47 <lambdabot>  Just False
15:42:49 <sorear> IMO @src liftM should = fmap and @src fmap = liftM.  *muahaha*
15:42:50 <Pastorn_> yay!
15:42:58 <AvengerX> don't let it do bad things in non-meant-to-be-made places
15:43:13 <Pastorn_> ?src fmap
15:43:13 <lambdabot> Source not found. I feel much better now.
15:43:21 <AvengerX> lol
15:43:21 <Pastorn_> ?src fMap
15:43:21 <lambdabot> Source not found. You type like i drive.
15:43:28 <Pastorn_> :'/
15:43:30 <AvengerX> lambdabot has quite a sense of humor
15:43:37 <nmessenger> @src Bool fmap
15:43:37 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:43:46 <nmessenger> @src [] fmap
15:43:46 <lambdabot> fmap = map
15:43:49 <nmessenger> :D
15:43:52 <Pastorn_> wtf?
15:43:57 <nmessenger> @src map
15:43:58 <lambdabot> map _ []     = []
15:43:58 <lambdabot> map f (x:xs) = f x : map f xs
15:44:09 <roerd> @pl [1, 2, 3] >>= \ a -> [4, 5, 6] >>= \ b -> return (a * b)
15:44:09 <lambdabot> (`fmap` [4, 5, 6]) . (*) =<< [1, 2, 3]
15:44:11 <Pastorn_> what's f in fmap short for?
15:44:15 <sorear> functor
15:44:25 <nmessenger> Functor, it's just to avoid a name clash with the list map
15:44:34 <sorear> must upgrade Emacs, bye
15:44:46 <AvengerX> f x : map f xs
15:44:46 <AvengerX> heh
15:44:46 <nmessenger> @src (->) fmap
15:44:47 <lambdabot> fmap = (.)
15:44:50 <AvengerX> the <cons> operator
15:44:59 <sorear> @src [] fmap
15:45:00 <lambdabot> fmap = map
15:45:03 <sorear> @src Maybe fmap
15:45:03 <lambdabot> fmap _ Nothing       = Nothing
15:45:04 <lambdabot> fmap f (Just a)      = Just (f a)
15:45:05 <Pastorn_> why did yau write @src [] fmap? with the []
15:45:09 <AvengerX> fasta murderer
15:45:11 <sorear> @src Maybe fmap
15:45:12 <lambdabot> fmap _ Nothing       = Nothing
15:45:12 <lambdabot> fmap f (Just a)      = Just (f a)
15:45:23 <sorear> Pastorn_: to disambiguate.
15:45:26 <sorear> @src Functor
15:45:27 <lambdabot> class  Functor f  where
15:45:27 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:45:31 <sorear> fmap is overloaded
15:45:36 <sorear> @src IO fmap
15:45:36 <lambdabot> fmap f x = x >>= (return . f)
15:45:37 <nmessenger> Pastorn_: fmap is a class method, so you have to tell it which type
15:46:00 <Pastorn_> okay... someone please stop this... when do I use fmap and when do i use normal map?
15:46:01 <sorear> @instances Functor
15:46:02 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:46:14 <ddarius> Pastorn_: You can technically always just use fap
15:46:16 <sorear> use fmap unless you know you are dealing with a list
15:46:19 <nmessenger> Pastorn_: fmap is map for more things than just list
15:46:20 <ddarius> s/fap/fmap
15:46:23 <Saizan> fap :D
15:46:25 <ddarius> Damn 'm' button.
15:46:36 <sorear> @src (,) fmap
15:46:36 <Pastorn_> okay....
15:46:37 <lambdabot> fmap f (x,y) = (x, f y)
15:46:52 <nmessenger> > fmap (*3) (Node 1 [Node 2 [], Node 3 []])
15:46:54 <lambdabot>  Node {rootLabel = 3, subForest = [Node {rootLabel = 6, subForest = []},Node ...
15:47:01 <AvengerX> I hate it when windows groups task items
15:47:10 <Pastorn_> fuck!! ER is on
15:47:23 <nmessenger> goodness, language mister >:/
15:48:04 <nmessenger> I mean damnit!  Watch your mouth!
15:48:09 <nmessenger> ;P
15:48:44 <AvengerX> tought you meant 'Watch yer f*k'n mouth!'
15:48:54 <ddarius> AvengerX: I know what you mean (re windows).
15:49:18 <nmessenger> AvengerX: you can turn it off I believe.
15:49:27 <ddarius> Probably
15:49:46 <Saizan> it's the first thing i've done on xp
15:49:47 <nmessenger> right-click, properties, uncheck "group similar taskbar buttons"
15:49:49 <AvengerX> nmessenger: well, I turn them off and on again, so I get tasks near but not grouped
15:49:54 <ddarius> For me at least, I should instead reimplement ion for Windows.
15:50:03 <fantasma> torrent client written in haskell, how cool would that be? :)
15:50:10 <AvengerX> I just wanted to keep them near, but not amesh
15:50:12 <Cale> @where conjure
15:50:13 <lambdabot> http://darcs.haskell.org/~lemmih/conjure/
15:50:48 <nmessenger> AvengerX: ah.  'Twoud be good if they "huddled together" without mounting one another :)
15:51:08 <fantasma> Cale, cool ;)
15:51:20 <AvengerX> ya
15:51:27 <ddarius> nmessenger: Them and dogs too.
15:51:39 <Cale> fantasma: I'm not sure about the project status, how close it is to being finished/usable.
15:51:48 <oklopol> it would be good if you could change their order by dragging etc as well
15:51:49 <Cale> But it looks like there's lots of good code there anyway.
15:51:50 <AvengerX> lol
15:52:52 * Saizan has 15 cmd.exe open, and doesn't know what's happening in them
15:53:08 <AvengerX> yeah... I think i'd rather training a XGL here so I could SPIN UP my monitor by inside
15:54:12 <AvengerX> FazNota> formataCentavos 1500
15:54:12 <AvengerX> "15.00"
15:54:14 <AvengerX> :)
15:54:18 <Cale> Having multiple desktops with the taskbar showing only what's on each works better for me. I'm not sure Windows has a way to do that though.
15:54:36 <Cale> Grouping happens less often that way.
15:54:44 <AvengerX> does windows have a taskbar to each desktop? :P
15:54:47 <Cale> (but I turn it on anyway)
15:55:13 <Cale> Does Windows have multiple desktops at all?
15:55:18 <AvengerX> well
15:55:21 <Cale> Probably there's software for it.
15:55:21 <AvengerX> mine has
15:55:32 <fantasma> software exists but it's terrible
15:55:39 <AvengerX> one in my CRT and other on the television
15:55:48 <fantasma> nothing like nix desktop switching
15:55:55 <Cale> Oh, requiring more than one monitor for it doesn't count.
15:56:04 <AvengerX> I was just to ask SamB to implement a dual-head support for zsnes ;)
15:56:06 <Cale> That's another issue entirely.
15:56:24 <AvengerX> Cale: well... that's how I have one more desktop here...
15:56:45 <AvengerX> but I know some videocards that make at least virtual desktops (that ones that we scroll with the mouse)
15:57:10 * allbery_b found the multiple desktops powertoy usable if less than ideal, back when.
15:58:17 <AvengerX> not sure about (natively) two or more... not even for that terminal services kind
15:58:17 <dinolinux> how can i put the sum of two variables into a third variable? (sorry for the stupidly simple question)
15:58:17 <AvengerX> blah = bleh + blih
15:58:17 <AvengerX> ?
15:58:17 <dinolinux> i get an error on that
15:58:21 <AvengerX> well... blah :: Int (or Float or etc)
15:58:31 <AvengerX> defined it prior to binding?
15:58:35 <dinolinux> no
15:58:41 <Cale> dinolinux: where are you typing this?
15:58:52 <AvengerX> try defining it then... I'm almost sure you'll get it
15:59:02 <dinolinux> tried both in a file and now in prelude
15:59:10 <monochrom> "let x = y+z in ..." there we go again :)
15:59:10 <AvengerX> blah :: Int
15:59:11 <Cale> er, don't edit the prelude
15:59:15 <AvengerX> blah = bleh + blih
15:59:19 <AvengerX> show blah
15:59:21 <Cale> (you're using hugs?)
15:59:32 <monochrom> Wow editting the prelude! :)
15:59:32 <dinolinux> hugs and ghci
15:59:44 <AvengerX> monochrom and his let's..
15:59:45 * AvengerX runs
15:59:54 <monochrom> "let me rebuild ghc to include x=5+6"...
16:00:04 <nmessenger> kinda has an air of tweaking quantum mechanics to it.
16:00:17 <monochrom> "it only takes ten minutes! dons says so!"...
16:00:37 <xerox> haha.
16:00:46 <ddarius> There are any virtual desktop managers for Windows.
16:01:00 <nmessenger> are many or aren't any?
16:01:09 <allbery_b> you're being m-less again :)
16:01:12 <cjay> there is even one from ms
16:01:17 <ddarius> are many (remember "Damn 'm' button)
16:01:28 <nmessenger> remembered now
16:01:30 <Cale> dinolinux: create a new file, and call it foo.hs. In this file, put  x = 5 + 6, and then load it with GHCi with  ghci foo.hs
16:01:33 <ddarius> With any luck there will be one more in not too long a time.
16:01:40 <Cale> dinolinux: then type x, and see what you get
16:01:52 <nmessenger> > let x = 5 + 6 in x
16:01:53 <lambdabot>  11
16:02:16 <sorear> of course that can be simplified to
16:02:20 <Cale> > let x = 5 + 6 in x^2
16:02:21 <monochrom> "but 5 and 6 are not variables..." :)
16:02:21 <sorear> > 5 + 6
16:02:22 <sorear> or even
16:02:23 <lambdabot>  11
16:02:24 <lambdabot>  121
16:02:25 <sorear> > 11
16:02:27 <lambdabot>  11
16:02:34 <dinolinux> Cale: one sec
16:03:12 <nmessenger> contest: write the most convoluted expression of 11 you can!
16:03:33 <sorear> > let convoluted = convoluted in 11
16:03:34 <AvengerX> > show 11
16:03:34 <lambdabot>  11
16:03:35 <lambdabot>  "11"
16:03:51 <dinolinux> hmm
16:04:00 <AvengerX> > show (read (show (read "11")))
16:04:01 <dinolinux> i think i found the error
16:04:03 <lambdabot>  "11"
16:04:05 <AvengerX> lol
16:04:10 <nmessenger> > join (+) ((length . show) "eleven") -1
16:04:12 <lambdabot>  15
16:04:15 <nmessenger> shit
16:04:31 <AvengerX> what is this nmessenger? hehe
16:04:38 <AvengerX> where eleven == 15?
16:04:57 <AvengerX> breaking paradoxes.. :)
16:05:01 <nmessenger> > (subtract 5) (join (+) ((length . show) "eleven"))
16:05:02 <lambdabot>  11
16:05:06 <AvengerX> lol
16:05:42 <AvengerX> the most obscure the better?..
16:05:54 <nmessenger> the more modules you use the points you gets :D
16:06:16 <AvengerX> I have a very very obscure code in c, which resolves that hannoy tower (tower of hanoi, whatever). The code has 5 lines.
16:06:22 <nmessenger> that was just Prelude and Control.Monad.Reader
16:06:31 <AvengerX> lol
16:06:34 <kc5tja> Oh god, I'm trying to explain monads to a friend of mine, and I'm just failing miserably at it.  :)
16:06:49 <AvengerX> what is a monad?
16:06:53 <AvengerX> does it bite?
16:07:13 <nmessenger> kc5tja: monad = fmap + return + join, so present a bunch of data structures that have those operations.
16:07:17 <allbery_b> > evalState (get >>= return . length) [(),(),(),(),(),(),(),(),(),(),()]
16:07:18 <lambdabot>  11
16:07:21 <sorear> A monad is a triple (F,u,e) where ...
16:07:22 <monochrom> It happens to me too.  Takes several times of practice.
16:07:31 * allbery_b annoys glguy :>
16:07:39 <kc5tja> nmessenger: Dude, I'm sorry, but that is just not helpful to me.  I cannot visualize fmap and join at all.
16:07:48 <sorear> allbery_b: why?
16:07:51 <monochrom> Don't visualize.
16:07:53 <nmessenger> > fmap (+1) [1,2,3]
16:07:54 <sorear> kc5tja: why?
16:07:55 <lambdabot>  [2,3,4]
16:07:56 <allbery_b> > evalState (liftM length get) [(),(),(),(),(),(),(),(),(),(),()]
16:07:57 <lambdabot>  11
16:07:59 <nmessenger> > join [2,3,4]
16:08:00 <lambdabot>   add an instance declaration for (Num [a])
16:08:00 <lambdabot>     In the expression: 4
16:08:07 <nmessenger> > join [[2,3],[4,5]]
16:08:08 <lambdabot>  [2,3,4,5]
16:08:14 <allbery_b> he nags me abut x >>= return . f :)
16:08:21 <kc5tja> sorear: If I knew why, I'd have an understanding of it.
16:08:24 <monochrom> If you visualize, you can't explain (in words).
16:08:48 <monochrom> If you visualize, perhaps you will have to explain by a sculpture.
16:08:53 <kc5tja> monochrom: Visualize == conceptualize; to explain in words, you must understand, and to understand, you must have a concept.
16:09:02 <kc5tja> Pedantry.
16:09:21 <nmessenger> fmap applies a function to its "contents", return puts a value in the monad, and join joins a monad containing a monad together
16:09:30 <allbery_b> @instances Functor
16:09:32 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:09:43 <monochrom> Cale has explained join well.
16:09:44 <allbery_b> > evalState (fmap length get) [(),(),(),(),(),(),(),(),(),(),()]
16:09:46 <lambdabot>  11
16:10:10 <Cale> nmessenger: your use of the term monad is making me wince
16:10:19 <nmessenger> Cale: sorry :)
16:10:28 <Cale> You know why, right?
16:10:35 <nmessenger> no
16:10:45 <Cale> "Monad" refers to the type constructor.
16:10:53 <Cale> That is, "Maybe" is a monad
16:11:01 <Cale> Just (Just 5) is not a monad.
16:11:19 * monochrom loves pedantry
16:11:21 <Cale> hehe
16:11:40 <monochrom> It clarifies and communicates.
16:11:42 <fuzan> hey, i saw a neat oneliner for replicating some io functions earlier. it was something like ,
16:11:51 <nmessenger> Cale: so my explanation of join was fast-and-loose with the details?
16:12:08 <fuzan> liftM ( concat . sequence . replicate 3 ) $ getLine
16:12:28 <fuzan> to merge (as in the code) 3 seperate user-inputted lines
16:12:29 <Cale> nmessenger: a little -- it felt like you were talking about values there
16:12:39 <fuzan> this however only lets me getLine once,
16:12:49 <Cale> But the overall idea was right :)
16:13:03 <nmessenger> Cale: I was.  Perhaps "join joins a monadic value containing a monadic value" :)
16:13:14 <Cale> yeah
16:13:15 <fuzan> how would you actually do it?
16:13:20 <nmessenger> or a monadic monadic value :P
16:13:25 <Cale> hehe
16:13:27 <xerox> With (>>= id).
16:13:38 <ddarius> return makes "variables" and (>>=) substitutes "expressions" for "variables"
16:13:48 <ddarius> making new "expressions"
16:13:59 <monochrom> liftM concat . sequence . replicate 3 $ getLine
16:14:00 <nmessenger> many ways to explain it
16:14:36 <Cale> Join removes a level of indirection :)
16:14:46 * monochrom goes evil
16:14:53 <monochrom> liftM join . sequence . replicate 3 $ getLine
16:14:56 <monochrom> hee hee hee
16:15:03 <fuzan> monochrom: yah, wth. why is:
16:15:05 <Botje> liftM join? O_O
16:15:14 <Cale> liftM join . replicateM 3 $ getLine
16:15:19 <fuzan> liftM concat . sequence . replicate 3 $ getLine
16:15:22 <ddarius> Join takes an "expression of expressions" and makes it an "expression", in "analogy" with a polynomial of polynomials "simplifies" to a polynomial
16:15:23 <fuzan> different from,
16:15:23 <monochrom> I did say I goes evil :)
16:15:30 <fuzan> liftM (concat . sequence .replicate 3 ) $ getLine
16:15:40 <fuzan> oh, i see.
16:15:48 <ddarius> (the quotes on analogy because polynomials form a monad)
16:15:51 <Cale> join is just multiplication
16:15:55 <monochrom> Well, they are syntactically different...
16:16:05 <Cale> in a brutally abstract sense :)
16:16:11 <monochrom> unlikely to be semantically the same.
16:16:29 <ddarius> Cale: That's not really true in some ways.
16:16:49 <sorear> join doesn't even have the same ARITY (in an uncurried framework)
16:16:49 <monochrom> The same way 4+5*6 different from (4+5)*6.
16:17:13 <AvengerX> when I do a var I do like ==> var :: Type;. May I do something like var :: Type = value  ?
16:17:14 <Cale> ddarius: It comes about from the view of monads as monoid objects in the category of endofunctors over a category.
16:17:19 <ddarius> join forms the "multiplication" of a monoid but it's only called multiplication due to the primary application being multiplication
16:17:28 <ddarius> Cale: I'm quite aware of that.
16:17:43 <Cale> It's an abstraction of multiplication.
16:18:00 <sorear> AvengerX: clarify?  you want to put a type signature on the same line?
16:18:10 <AvengerX> sorear: yep
16:18:16 <sorear> AvengerX: you realize you can omit the type signature entirely?
16:18:24 <ddarius> Yes, but saying join is just multiplication is not the same as saying join is just multiplication.
16:18:36 <AvengerX> I know, but got to leave the var type clear
16:18:38 <AvengerX> heh
16:18:40 <matthw> polynomials form a monad - interesting
16:18:54 <monochrom> can't do "var :: Type = value" unless some ghc extension.
16:18:55 <matthw> perhaps that would be another good way to explain them to people who've done some math :)
16:18:58 <sorear> ddarius: those are lexically the same
16:19:05 <monochrom> but can do "var = value :: Type"
16:19:15 <ddarius> Er "abstract multiplication"
16:19:19 <sorear> AvengerX: "I know, but got to leave the var type clear" -- what does this mean?
16:19:25 <AvengerX> should it be possible to use everything in the same line while still have the clarity.
16:19:29 <AvengerX> monochrom: that's it
16:19:36 <matthw> (hi, by the way - i've ventured in here for the first time)
16:19:46 <sorear> hello
16:20:02 <AvengerX> sorear: well-documented, the var type 'written explicitly' on the code
16:20:07 <AvengerX> something like it
16:20:16 <sorear> matthw:  don't be scared, we talk arcana iff there is a dearth of newbies
16:20:30 <SamB> AvengerX: I don't suppose you have any clue how "multiple desktop" support works?
16:20:35 <AvengerX> monochrom: ty ty :)
16:20:39 * SamB doesn't even have his XP box operational
16:20:43 <matthw> hehe... that's ok
16:20:44 <JohnnyL> i have the feeling that there are multple parsers that parse the haskell language.
16:20:46 <SamB> it needs a fan...
16:20:53 <matthw> i see haskell mainly as a way of teaching myself category theory
16:20:56 <AvengerX> SamB: heh... you break everyting
16:21:00 <SamB> also it doesn't have another desktop
16:21:04 <matthw> so i will probably annoy newbies too
16:21:04 <SamB> no I didn't break it
16:21:05 <fuzan> SamB: XP supports mult desktop via power tools
16:21:06 <SamB> it wore out
16:21:10 <AvengerX> SamB; I really have little idea
16:21:13 <sorear> AvengerX: IME type signatures are only useful for multi-len defns, so no need to put it all on one line.
16:21:20 <ddarius> sorear: View vertical composition of natural transformations as the monoidal tensor product that they are and join : T o T -> T
16:21:27 <AvengerX> SamB: but some winamp plugins have support for that 'dual head' or something like it on windows
16:21:37 <fuzan> SamB: I also think some video drivers support mult desktops.
16:21:45 <sorear> ddarius: I have absolutely no idea what you just said.
16:22:06 <AvengerX> And I -think- that the geiss winamp plugin is open source (so can be used as a source of information about dual-head behaviors and so)
16:22:12 <sorear> gah, vty is broken by design ...
16:22:34 <ddarius> sorear: The upshot is that it does have the correct arity we just have a different notion of "product"
16:22:54 <AvengerX> SamB: I think that you can get two desktops just by putting an old PCI videocard together with the main board
16:23:23 <SamB> AvengerX: oh?
16:23:54 <AvengerX> Having two videocards cause windows to work with two-head support
16:24:14 <xerox> Yeah
16:24:37 <AvengerX> so you can activate the second video, throw windows there, call them back....
16:25:00 <AvengerX> well, I mean windows XP and maybe vista
16:25:08 <AvengerX> well, no vista won't accept old pci cards! heh
16:25:48 <SamB> does milkdrop do it too?
16:27:57 <AvengerX> well, no sources for geiss :(
16:28:05 <AvengerX> milkdrop?
16:28:18 <SamB> another plugin
16:28:29 <SamB> by the same guy
16:28:31 <AvengerX> no idea... never seen this plugin
16:28:32 <SamB> but it has sources
16:29:12 <AvengerX> you use directX extensions with zSnes, right?
16:31:55 <SamB> extensions?
16:32:55 <AvengerX> uh... libraries sdk, anything related to directx, like winamp plugins does for example?
16:33:48 <AvengerX> hell yes, milkdrop has a sitting 'dual head' button there :)
16:33:48 <SamB> it uses directx, yes
16:34:21 <AvengerX> actually... you don't need to bother with dualHead... just let choose videocard on zsnes
16:34:36 <AvengerX> when we have multiple desktops it shows two 'adapters' to choose
16:35:25 <AvengerX> for example in milkdrop, in each of the three 'Display Adapter' entries, I have two 'Nvidia Gefo...'
16:35:50 <AvengerX> One for my first (crt) desktop, and other for my second (TV) desktop.
16:36:05 <fuzan> what a sweet ghc compiler message : Urk! Inventing strangely-kinded void TyCon:
16:36:43 <AvengerX> Milkdrop looks like a 'copy' of geiss.. heh
16:37:13 <AvengerX> well, not graphics wise
16:37:23 <AvengerX> just the setup interface, is the same of geiss 2
16:38:29 <SamB> AvengerX: I think milkdrop is actually older, not sure though
16:39:07 <AvengerX> well... didn't mean it timewise... just that one is a copy of another
16:39:48 <AvengerX> for sure the geiss code is based on milkdrop's
16:39:56 <AvengerX> (geiss2)
16:40:20 <AvengerX> But regardless of who's the copy and who
16:40:42 <AvengerX> But regardless of who's the copy and who's copied, they have options for both dualHead and choosing the videocard to use with the game
16:41:57 <AvengerX> After all, the 'dual head' idea is not that fun... (dual head seems to mean sharing the same screen on the two monitors), but it was meant just to allow zsnes run on other screen.
16:42:27 <AvengerX> btw, many programs work by just dragging the window to the other desktop... not sure if it is automatic
16:43:03 <SamB> you can't drag ZSNES?
16:44:37 <zou> i'm looking for a haskell based data mining software
16:45:42 <AvengerX> SamB: no
16:45:52 <AvengerX> it is stuck to the main desktop
16:46:10 <AvengerX> let me make sure I'm not saying bullshit
16:47:00 <SamB> hmm, maybe related to not having a real titlebar?
16:47:01 <fuzan> is it possible to have more code continuing a where statement?
16:47:25 <AvengerX> yes. stuck to the first desktop. :)
16:47:51 <fuzan> func = do foo a b where a = 1; b = 1; putStrLn "done!"
16:47:53 <AvengerX> don't think so... as I move the window, as it reaches the side of my main desktop, it stops moving
16:48:02 <AvengerX> other windows go to the other desktop with no problem
16:48:16 <fuzan> AvengerX: try starting it from a link on the second desktop"
16:48:23 <AvengerX> I can even leave a window partly here and partly there
16:48:44 <SamB> AvengerX: so it stops moving when its right edge hits the right edge of the screen?
16:48:47 <lacrimosa> :-)
16:48:48 <AvengerX> fuzan: no. it always come to the main desktop... like it has a protection to keep into the x,y of the first desktop
16:48:58 <AvengerX> SamB: yep
16:49:36 <SamB> does it do the same thing on the left?
16:49:39 <AvengerX> Only if I split a movie here and there, the movie 'chooses' the window to play, and the other keeps black on the window area.
16:49:42 <fuzan> AvengerX: shitty :\ There might be some wrapper program you can find for controlling programs access to desktop information, subsequently forcing them to spawn to the desrired desktop
16:49:43 <AvengerX> well...
16:49:57 <AvengerX> probably... there's no more desktops over there
16:50:15 <SamB> ah, with the movies, that will be overlay issues ;-)
16:50:20 <AvengerX> lol
16:50:27 <AvengerX> it don't get under the start bar
16:50:43 <AvengerX> not up not left not right and not above start bar
16:50:55 <AvengerX> (btw my start bar is at bottom)
16:51:18 <AvengerX> uh well.. my zsnes is 1.42, I'm not sure if there were desktop behavior changes since that
16:51:46 <SamB> ah, yeah, why don't you try 1.51?
16:52:05 <ddarius> Holy crap!  There's another person named Derek (albeit Derek Wyatt) who also wants to implement ion in Windows.
16:52:16 <fuzan> does window have an equivilent $DISPLAY variable?
16:52:31 <hpaste>  dons pasted "reification of IO" at http://hpaste.org/629
16:52:32 <fuzan> I never understood ion :)
16:52:37 <SamB> um, that wouldn't help anyway would it?
16:52:39 <fuzan> just use emacs.
16:52:48 <AvengerX> heh, i'm d/ling it now
16:53:07 * ddarius doesn't use emacs and doesn't want to start now and that would not solve my problem at all.
16:53:26 <fuzan> ddarius: what's your reasoning / problem behind using ion*?
16:53:29 <AvengerX> password protected?
16:53:31 <mbishop> emacs can indeed be your window manager/environment
16:53:57 <fuzan> i still need to get unlazy and figure out why zsh doesn't play well with emacs's shell buffer
16:54:15 <sorear> hiya dons!
16:54:24 <SamB> because, uh, $DISPLAY only sets what X server to connect to, does it not?
16:54:31 <ddarius> fuzan: I liked ion.  I don't like emacs.  My current problem though is completely unhelped by emacs.
16:54:45 <xerox> @go Emacs standing alone on a Linux kernel
16:54:47 <lambdabot> http://www.informatimago.com/linux/emacs-on-user-mode-linux.html
16:54:48 <lambdabot> Title: Emacs standing alone on a Linux Kernel
16:54:59 <fuzan> ddarius: problem of ?
16:55:17 <ddarius> ion-a-like on windows natively
16:55:23 <sorear> dons: was this in response to something?
16:55:43 <sorear> dons: there is an IMO much nicer way using trees
16:55:52 <AvengerX> SamB: is it normal for the zsnes .zip ask for password?..
16:55:59 <fuzan> No.
16:56:02 <SamB> AvengerX: where did you get that?
16:56:11 <SamB> download it from zsnes.com
16:56:11 <AvengerX> strange... I could look into the files, but when I ask it to be extracted..
16:56:20 <SamB> where did you find it?
16:56:29 <AvengerX> file 'releases.css' is password protected...
16:56:40 <AvengerX> Well... downloaded from sourceforge (link from zsnes.com)
16:56:47 <SamB> really?
16:57:43 <AvengerX> bah, it should be something on my old zsnes directory!
16:57:49 <AvengerX> sorry! (weeeird winXP)
16:57:53 <SamB> huh?
16:58:26 <AvengerX> It seems it asked for a password to overwrite some files..
16:58:34 <SamB> oh?
16:59:00 <AvengerX> nevermind, just installed it on another directory
16:59:07 <AvengerX> it's a problem here anyway
16:59:41 <sorear> @localtime dons
16:59:44 <lambdabot> Local time for dons is Sat Feb 24 11:57:26 2007
17:00:57 <AvengerX> allright... same windowstick on the updated version :)
17:01:21 <AvengerX> it only and solely shows on the second desktop if we actually turn that into the main desktop
17:01:58 <dons> morning
17:01:59 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:03:11 <sorear> what was the paste for?
17:03:37 <sorear> also ... your nobench is too new relative to your jhc to be compatible with it :)
17:04:17 <dons> the paste was for a query in /msg
17:04:26 <dons> yes, re. nobench. looks like i have some jobs to do today
17:06:23 <dons> ?users
17:06:24 <lambdabot> Maximum users seen in #haskell: 329, currently: 304 (92.4%), active: 53 (17.4%)
17:06:31 <dons> new record
17:06:44 <sorear> yay!
17:06:49 <xerox> ?users
17:06:50 <lambdabot> Maximum users seen in #haskell: 329, currently: 305 (92.7%), active: 52 (17.0%)
17:07:05 <xerox> Ah, oops.
17:07:09 <AvengerX> this bot is not recording it correctly
17:07:19 * sorear summons clonebot
17:07:22 <thorat> dons: does it really mean anything, I mean active says more doesn't it?
17:07:50 <thorat> ducks
17:07:59 <sorear> quack?
17:08:09 <thorat> <ducks>
17:08:22 <xerox> <quack?>
17:08:25 <thorat> <-- ducks
17:08:27 <sorear> <ducks/> you mean, tsk, tsk tsk.
17:08:29 * nmessenger quacks
17:08:55 * thorat ducks
17:09:02 <stmartin> What's the best way to print out a list of numbers?
17:09:05 * nmessenger EXPLODES!
17:09:06 <sorear> print
17:09:13 <xerox> print alistofnumbers
17:09:26 <sorear> stmartin: print [1,2,3]  will print "[1,2,3]\n"
17:09:26 <stmartin> Ah, and here's me trying to use putStrLn
17:09:32 <sorear> @src print
17:09:33 <nmessenger> @src print
17:09:33 <lambdabot> print x = putStrLn (show x)
17:09:33 <lambdabot> print x = putStrLn (show x)
17:09:37 <nmessenger> jinx!
17:09:51 <xerox> lambdabot should be trained to answer such questions.
17:10:14 <xerox> _Everybody_ in this channel, beside lambdabot, learn the answer to these questions!
17:10:38 <monochrom> which questions?
17:10:56 <xerox> Questions that lambdabot is able to answer (-:
17:11:03 <AvengerX> lengh show x
17:11:10 <monochrom> yeah I'm learning.
17:11:11 <AvengerX> will do (length show) x ?
17:11:21 <monochrom> Yes.
17:11:26 <AvengerX> hmm
17:11:26 <dons> > length (show pi)
17:11:28 <lambdabot>  17
17:11:29 <nmessenger> AvengerX: yes
17:11:41 <nmessenger> f x y = (f x) y
17:12:05 <nmessenger> ... /= f (x y)
17:12:05 <monochrom> You will appreciate it the moment you need "foldr f 0 xs".
17:12:21 <AvengerX> in the case I do a x = 1 + 2 :: Int -- I have no idea of the precedence in this case
17:12:45 <AvengerX> Should I issue a x = (1 + 2) :: Int, else I'll got an error?
17:12:49 <AvengerX> *get
17:13:21 <nmessenger> (x) = ((1 + 2) :: (Int)) -- these parens are for illustrative purposes, some are syntax errors
17:13:24 <sorear> they should be the same
17:13:34 <sorear> > 1 + 2 :: Int
17:13:35 <lambdabot>  3
17:13:39 <sorear> > 1 + (2 :: Int)
17:13:41 <lambdabot>  3
17:13:49 <sorear> > (1 + 2) :: Int
17:13:51 <lambdabot>  3
17:13:54 <xerox> :t (+)
17:13:56 <lambdabot> forall a. (Num a) => a -> a -> a
17:13:57 <AvengerX> > let x = 1 + 2 :: Int in show x
17:13:58 <lambdabot>  "3"
17:14:07 <xerox> Let one 'a' be Int, the other will follow.
17:14:16 <AvengerX> well, it seems my statement works without parens
17:14:39 <AvengerX> hmmm
17:14:40 <nmessenger> '=' and '::' aren't "operators", they're part of higher syntax than expressions.
17:14:41 <fuzan> > 5.2 + 4 :: Int
17:14:42 <lambdabot>   add an instance declaration for (Fractional Int)
17:14:44 <xerox> Without parens you are unifying the last `a' with `Int'.
17:14:57 <fuzan> > 5.2 + 4
17:14:58 <lambdabot>  9.2
17:15:06 <nmessenger> @type 5.2
17:15:08 <lambdabot> forall t. (Fractional t) => t
17:15:11 <AvengerX> > let x = 1.2 + 2 :: Int in show x
17:15:12 <lambdabot>   add an instance declaration for (Fractional Int)
17:15:34 <AvengerX> > let x = (1.2 + 2) :: Int in show x
17:15:35 <lambdabot>   add an instance declaration for (Fractional Int)
17:15:45 <AvengerX> > let x = 1 + 2 :: Int in show x
17:15:46 <lambdabot>  "3"
17:15:48 <fuzan> as xerox said, look at the type of (+)
17:15:49 <AvengerX> hnmm
17:15:55 <nmessenger> you have to use an explicit function to convert the Fractional to an Int
17:16:12 <AvengerX> yeah
17:16:14 <AvengerX> hmmm
17:16:21 <AvengerX> got it! :)
17:16:21 <nmessenger> @hoogle (Fractional a, Integral b) => a -> b
17:16:23 <xerox> > [round,floor,ceiling] `sequence` (1.2 + 2) :: [Int]
17:16:23 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:16:23 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
17:16:23 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
17:16:28 <nmessenger> eh?
17:16:48 <sorear> Prelude!
17:17:14 <xerox> Pfft to clashing imports.
17:17:15 <nmessenger> I've not used many number converting functions, so I can never remember them
17:17:25 <sorear> dons: poke, can you add a 'import Prelude hiding (mapM, sequence)' to State/Pristine.hs ?
17:17:42 <sorear> > mapM_ (:[]) [1,2,3]
17:17:44 <lambdabot>  [()]
17:17:49 <sorear> > fmap (:[]) [1,2,3]
17:17:51 <lambdabot>  [[1],[2],[3]]
17:18:01 <AvengerX> heh
17:18:01 <AvengerX> (:[])
17:18:05 <sorear> > sequence_ [Just 1,Just 2,Just 3]
17:18:06 <AvengerX> nice smiley
17:18:06 <lambdabot>  Just ()
17:18:08 <nmessenger> @quote monster
17:18:08 <lambdabot> dcoutts says: (:[]) looks like a monster
17:18:12 <allbery_b> @quote eat.a.
17:18:12 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
17:18:16 <AvengerX> lol
17:18:19 <sorear> AvengerX: robot ninja monkey operator
17:18:29 <AvengerX> lol
17:18:31 <sorear> AvengerX: that is its proper name
17:18:47 <nmessenger> I always call it "cons-nil" :P
17:18:58 <sorear> seriously though, I'm checking for other conflicting imports
17:18:59 * wkh feels like giving Haskell another try
17:19:15 <fuzan> I think we should honestly adopt :[] as "monster"
17:19:21 * sorear did a doubletake after misreading *wkh as *ndm
17:19:48 <nmessenger> sorear: how did you manage that reading?
17:19:52 <xerox> > [round,floor,ceiling] `Control.Monad.sequence` (1.2 + 2) :: [Int]
17:19:54 <lambdabot>  [3,3,4]
17:19:58 <sorear> nmessenger: not sure.
17:20:15 <fuzan> xerox: what is that format called?
17:20:29 <monochrom> infix
17:20:29 <xerox> fuzan: do you refer to `infix` notation?
17:20:49 <fuzan> oh wait, nevermind
17:20:51 <fuzan> i'm stupid.
17:20:52 <nmessenger> also Module.Qualified.names
17:21:04 <chessguy> > mplus [1,2] [3,4]
17:21:05 <lambdabot>  [1,2,3,4]
17:21:26 <sorear> chessguy: BITD mplus was called (++)
17:21:31 <LoganCapaldo> > (do { x <- round; y <- floor; z <- ceiling; return [x,y,z] }) (1.2 + 2)
17:21:32 <lambdabot>  [3,3,4]
17:21:34 <chessguy> BITD?
17:21:35 <nmessenger> @vera bitd
17:21:37 <lambdabot> No match for "bitd".
17:21:44 <chessguy> @go BITD
17:21:48 <lambdabot> http://www.bitd.com/
17:21:48 <lambdabot> Title: Best In The Desert Racing Association
17:21:53 <LoganCapaldo> Mmm
17:21:55 <nmessenger> :D  lol!
17:22:05 <LoganCapaldo> ((->) e) is delicious
17:22:08 <chessguy> ohhh, that makes much more sense :)
17:22:25 <nmessenger> "back in the day"?
17:22:27 <chessguy> ?instances monoid
17:22:28 <lambdabot> Couldn't find class `monoid'. Try @instances-importing
17:22:30 <chessguy> nmessenger, probably
17:22:34 <chessguy> ?instances Monoid
17:22:35 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
17:22:37 <wkh> is paul hudak's book "the haskell school of expression" sufficient to get started with haskell?
17:22:39 <LoganCapaldo> @go define:bitd
17:22:40 <lambdabot> No Result Found.
17:22:45 <monochrom> Yes wkh
17:22:53 <sorear> back in the day
17:23:09 <chessguy> wkh, yes. it's good for both beginners and advanced, i think
17:23:15 <LoganCapaldo> I'm just dissapointed that didn't work
17:23:19 <sorear> I'm not making this up, I got it from allbery_b
17:23:21 <chessguy> it starts out slow, but has you doing some challenging projects at the end
17:23:28 <ulfdoz> Also gerade Haskell schafft sehr simpel sehr viel eleganten Unfug.
17:23:30 <LoganCapaldo> @go is google right?
17:23:32 <lambdabot> http://visualbasic.about.com/b/a/050129.htm
17:23:32 <lambdabot> Title: Learn to Google Right
17:23:37 <sorear> LoganCapaldo: yes
17:23:42 <chessguy> LoganCapaldo, yes
17:23:54 <LoganCapaldo> so come on, where the define: support at? :)
17:23:54 <chessguy> heh
17:24:00 <nmessenger> lol at LB answering logan.
17:24:07 <chessguy> a visual basic site about googling?
17:24:36 <LoganCapaldo> ROFL
17:24:37 <chessguy> hmm!
17:24:45 <allbery_b> "bitd" is used a lot by us old timers :)
17:24:57 <LoganCapaldo> http://www.google.com/search?q=define%3Abitd&start=0&ie=utf-8&oe=utf-8&client=firefox-a&rls=org.mozilla:en-US:official
17:24:59 <lambdabot> Title: define:bitd - Google Search, http://tinyurl.com/yohmua
17:25:09 <chessguy> yeah, but you wouldn't expect it to be used by a 16-year-old
17:25:09 <stmartin> @paste
17:25:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:25:12 <nmessenger> google.com didn't return anything useful for define:BITD, either
17:25:13 <chessguy> or whatever sorear is
17:26:40 <hpaste>  stmartin pasted "getNums" at http://hpaste.org/631
17:26:52 <stmartin> The above compiles and runs without error.
17:27:03 <stmartin> But the putStrLn statement doesn't run. Why?
17:27:27 <stmartin> All I see is the print line output:  [1,2,3,4]
17:28:17 <nmessenger> I'm not sure, it looks correct.
17:28:26 <chessguy> yeah, to me too
17:28:29 * chessguy fires up ghc
17:28:34 <monochrom> I'm going to test it.
17:28:34 * stmartin tries it in Hugs
17:28:46 <wkh> so like, haskell is turbo-expressive?
17:28:49 <fuzan> What terminal are you running in?
17:28:50 * sorear just reads it
17:29:03 <stmartin> ghci
17:29:03 <Botje> > toEnum 1 :: Boolean
17:29:04 <nmessenger> wkh: uh, I suppose.  What does that mean?
17:29:05 <lambdabot>   Not in scope: type constructor or class `Boolean'
17:29:06 <chessguy> works for me
17:29:07 <Botje> > toEnum 1 :: Bool
17:29:09 <lambdabot>  True
17:29:19 <monochrom> works for me
17:29:24 <fuzan> try compiling and running it in xterm
17:29:39 <fuzan> sometimes IO is goofy in ghci, i don't know why.
17:29:46 <stmartin> And hugs doesn't output _anything_ (except perhaps a blank line)
17:29:49 <monochrom> I guess "turbo" is just an adjective meaning "uber"
17:30:18 <monochrom> Are you sure you have saved the file?
17:30:33 <sorear> fuzan: goofy?
17:30:38 <stmartin> Yes
17:31:03 <monochrom> IO is not goofy in ghci
17:31:07 <nmessenger> :/  I'm stumped
17:31:09 <chessguy> sorear, i'd say that what stmartin is describing is pretty goofy
17:31:35 <sorear> chessguy: no
17:31:47 <sorear> chessguy: it would be a bug, not mere goofiness
17:31:58 <chessguy> bugs can be goofy too
17:32:02 <allbery_b> works for me in both runhugs and runghc
17:32:07 <chessguy> and it's not a bug in his code
17:32:27 <monochrom> make sure latest version of file is saved. independently verify its content. launch new ghci/hugs session or recompile. make sure ghci/hugs/ghc is reading the correct file.
17:32:48 <chessguy> don't forget to reboot too!
17:32:59 * sorear apparently thinks the GHC bug list is too short.
17:33:01 <stmartin> Running as compiled works
17:33:18 <nmessenger> I dance around with your hand behind your back with reciting an ancient incantation!
17:33:26 <nmessenger> s/I/and/
17:33:36 <chessguy> @quote magic
17:33:36 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
17:33:38 <chessguy> @quote magic
17:33:39 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
17:33:45 <stmartin> I think it was a buffering issue
17:34:20 <stmartin> Changed line 32 to use putStrLn instead of putStr. Looks like I need to figure out how to get it to flush stdout.
17:34:36 <monochrom> putStr can only be worse.
17:34:46 <nmessenger> hFlush stdout
17:34:48 <dons> hFlush stdout
17:34:58 <dons> hSetBuffering stdout Nobuffering
17:34:59 <monochrom> line 32?
17:35:00 <Botje> \bot needs more goat quotes.
17:35:01 <chessguy> stmartin, try taking out the hSetBuffering line? i think that's a hugs hack
17:35:15 <nmessenger> \bot!  cool!
17:35:29 <chessguy> isn't Nobuffering the default?
17:35:33 <sorear> /\bot is better
17:35:41 <nmessenger> ,\bot
17:35:44 <Botje> TRIANGLEBOT!
17:35:47 <sorear> since it's a proper name :)
17:35:56 <monochrom> The default depends on the environment.  It is seldom NoBuffering.
17:36:20 <sorear> Lambda bot
17:36:26 <monochrom> How are you running ghci/hugs, stmartin?  I mean in an xterm?  ...
17:36:29 <stmartin> chessguy: on Unix systems, stdout is line buffered, so if you want a prompt, getting data on the same line as the prompt, you need to flush after the call to putStr
17:36:47 <stmartin> I'm running ghci primarily. Hugs if something seems odd.
17:36:57 <nmessenger> stmartin: but you're not prompting after that last putStLn
17:37:03 <sorear> stmartin: just use System.Console.Readline.readline
17:37:11 <sorear> @ty System.Console.Readline.readline
17:37:14 <lambdabot> String -> IO (Maybe String)
17:37:26 <stmartin> Ohhh. I'll have to look into that later perhaps.
17:37:37 <sorear> line editing is GREAT
17:37:52 * LoganCapaldo wishes there was a type Line = String
17:38:05 <LoganCapaldo> it would make hoogling for such things easier
17:38:08 <nmessenger> ./agree, but isn't Readline borked on Windows?
17:38:10 <monochrom> I tested with ghci-inside-emacs and ghci-inside-gnome-terminal and both worked fine.
17:38:29 <monochrom> So I would blame it on ghci-in-_____ where _____ is whatever you run ghci in.
17:39:08 <sorear> why should stmartin care whether readline works on windows?
17:39:13 <monochrom> "blame" is too harsh.  should be "attribute to".  nothing is mysterious, there is always a scientific explanation.
17:39:59 <nmessenger> sorear: if he should ever want to write something that might be distributed to Windozers like myself :)
17:40:14 <chessguy> but even if there is a scientific explanation, it could still seem pretty goofy until  you find it
17:40:42 <sorear> nmessenger: readline p = putStr p >> hFlush stdout >> fmap Just getLine
17:40:51 <sorear> nmessenger: he can add that right before shipping
17:40:57 <monochrom> yes there are subjective emotions and feelings. they get into the way.
17:40:58 <nmessenger> :)
17:41:03 <sorear> nmessenger: and still use readline for debugging
17:41:12 <stmartin> Excuse the obvious question, but how would I find documentation for System.Console.Readline?
17:41:18 <sorear> @docs System.Console.Readline
17:41:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/readline/System-Console-Readline.html
17:41:30 <nmessenger> darn, you're quick on the draw
17:41:33 <monochrom> obvious questions are ok :)
17:41:54 <allbery_b> probably need to look at the info document for GNU readline as well
17:41:58 <sorear> stmartin: a better answer however is "ask on #haskell", documentation is still generally sparse
17:42:21 <sorear> @undef
17:42:21 * LoganCapaldo blinks
17:42:23 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:42:29 <sorear> bah!
17:42:29 <monochrom> Most functions in System.Console.Readline can be guessed
17:42:33 <nmessenger> "generally spare" as in "completely nonexistant" :P
17:42:43 <sorear> > mapM Just [0,1,2]
17:42:54 <Knio> how do you debug a haskell program?
17:42:59 <LoganCapaldo> Did I just see someone encourage someone to ask questions _instead_ of suggesting they RTFM?
17:43:01 <sorear> Knio: you don't :(
17:43:04 <monochrom> Well System.IO doc is hardly "completely nonexistant"
17:43:04 * LoganCapaldo has a heart attack
17:43:05 <Knio> :(
17:43:05 <xerox> You ought to specify Control.Monad.mapM, because there's a clash in the imports, sorear :-(
17:43:21 <chessguy> LoganCapaldo, this _is_ #haskell
17:43:21 <siti> Knio: you try and get it to compile ;)
17:43:24 <sorear> Fri Feb 23 17:29:36 PST 2007  Don Stewart <dons@cse.unsw.edu.au>
17:43:24 <sorear>   * import Prelude hiding (mapM, sequence, mapM_, sequence_)
17:43:24 <sorear> Shall I pull this patch? (1/1)  [ynWvpxqadjk], or ? for help: y
17:43:28 <sorear> xerox: ^^^
17:43:37 <thorat> Knio: if it typechecks... it's correct
17:43:38 <Knio> it compiles... it prints the wrong answer :(
17:43:47 * sorear faints
17:43:53 <monochrom> LoganCapaldo: this specific case has F no M. :)
17:43:59 <chessguy> Knio, check out http://www.haskell.org/haskellwiki/Debugging
17:44:00 <lambdabot> Title: Debugging - HaskellWiki
17:44:11 <siti> that's the case with pure code, but it's more difficult with IO code but you can use putStrLn there ;)
17:44:18 <sorear> Knio: I presume there are pigs flying outside your window?
17:44:22 <LoganCapaldo> monochrom, doesn't seem to stop anyone else :)
17:44:25 <rahikkala> Knio: Obviously you have left out some static constraints that you could have enforced with the type system
17:44:46 <Knio> heh :/
17:44:58 <dons> @undefine
17:44:59 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:45:07 <sorear> <sorear> @undef                                                           [17:40]
17:45:21 <sorear> debug!
17:45:33 <dons> i updated to your patch between 17:40 and 17:42
17:45:48 <nmessenger> @localtime dons
17:45:50 <lambdabot> Local time for dons is Sat Feb 24 12:43:33 2007
17:46:02 <monochrom> How to debug in Haskell: you wait for ghc 6.8 to come out, then you grab it, then you start setting breakpoints...
17:46:05 <sorear> ... within 3s of my radio clock
17:46:16 <sorear> why wait?
17:46:25 <chessguy> ?localtime sorear
17:46:26 <lambdabot> Local time for sorear is Fri Feb 23 17:44:09 2007
17:46:27 <sorear> http://darcs.haskell.org/packages ghc
17:46:29 <lambdabot> Title: Index of /packages
17:46:33 <sorear> http://darcs.haskell.org/packages/ghc
17:46:34 <monochrom> I wouldn't wait. I would forget debugging. There are other ways.
17:47:17 <LoganCapaldo> haskell seems like the ultimate wellspring of heisenbugs (with a debugger that is)
17:47:28 <sorear> darcs get that, foot get a cup of coffie (15000 patches), ./darcs-all get --extra, configure, make, wait 90mins, make install, enjoy
17:47:52 <monochrom> See? I wouldn't even wait 90mins.
17:48:04 <AvengerX> i'm under the following problem: I got e.g. two Strings "oh my!" and "10.32" (yes, the so-called price!). Now I have to fill a space between them, joining in such a manner that I have a 30-char long string, that would look like "oh my!...(...)...10.32"
17:48:11 <allbery_b> there are snapshots for some platforms...
17:48:37 <monochrom> I would: get a cup of tea, pick up fancy fountain pen, start proving it correct the Dijkstra way (including the fountain pen part)
17:48:40 <AvengerX> I don't know how to do the (30 - length(str1) - length(str2)) dots. :)
17:48:42 <nmessenger> > printf "%25s%s" "oh my!" "10.32" :: String
17:48:43 <lambdabot>  "                   oh my!10.32"
17:49:02 <allbery_b> > replicate 30 '.'
17:49:03 <lambdabot>  ".............................."
17:49:11 <AvengerX> hmmm replicate
17:49:12 <nmessenger> > printf "%-25s%s" "oh my!" "10.32" :: String
17:49:13 <lambdabot>  "oh my!                   10.32"
17:49:29 <Pastorn_> ?src replicate
17:49:30 <lambdabot> replicate n x = take n (repeat x)
17:49:50 <Pastorn_> ?src repeat
17:49:51 <lambdabot> repeat x = xs where xs = x : xs
17:49:54 <monochrom> OH! Seriously, you can also get something out of QuickCheck.
17:50:13 <nmessenger> > repeat "boom!"
17:50:14 <lambdabot>  ["boom!","boom!","boom!","boom!","boom!","boom!","boom!","boom!","boom!","bo...
17:50:36 <xerox> monochrom: I still haven't found the perfect pen. Do you think fountain pens are the way to go? Mumble.
17:50:55 <fuzan> laser pens.
17:51:38 <fuzan> the toner is expensive for them though.
17:51:42 <fuzan> and hard to refill
17:51:42 <xic> penagain
17:51:43 <sorear> pig pens
17:52:05 <AvengerX> lol
17:52:14 <monochrom> I don't know about perfect. If you have 70 dollars to spare, you can spend that to give it a try. You can also try to go to a fountain pen shop and let them convince you.
17:52:24 <allbery_b> pen-rose tiles? :)
17:52:26 <AvengerX> >replicate 5 "oi"
17:52:30 <AvengerX> > replicate 5 "oi"
17:52:32 <lambdabot>  ["oi","oi","oi","oi","oi"]
17:52:47 <AvengerX> hmmm
17:52:51 <sorear> > cycle "oi"
17:52:53 <lambdabot>  "oioioioioioioioioioioioioioioioioioioioioioioioioioioioioioioioioioioioioio...
17:52:54 <AvengerX> > replicate 5 '.'
17:52:55 <lambdabot>  "....."
17:53:06 <AvengerX> this is better :)
17:53:11 <Botje> > concat $ repeat [(concat $ replicate 3 "badger badger badger "),"MUSHROOM MUSHROOM"]
17:53:12 <lambdabot>  ["badger badger badger badger badger badger badger badger badger ","MUSHROOM...
17:53:17 <sorear> jon!
17:53:20 <sorear> er, join!
17:53:22 <allbery_b> > replicate 5 3 -- make it clearer what's going on
17:53:24 <lambdabot>  [3,3,3,3,3]
17:53:35 <xerox> monochrom: oddly enough, I do have, are you thinking of something precise?
17:53:46 <AvengerX> in my way you dont have to concat it after printing the dots
17:53:59 <sorear> > ['x','y','z'] -- AvengerX : hopefuly clearer still
17:54:01 <lambdabot>  "xyz"
17:54:14 <allbery_b> repeat x promotes x to infinite list of x.  Haskell's String is just a list of Char
17:54:15 <AvengerX> sorear: yeah
17:54:44 <AvengerX> so a [ '.', '.', '.'] is a string "..."
17:54:58 <nmessenger> > ['.','.','.']
17:54:59 <lambdabot>  "..."
17:55:21 <nmessenger> = ('.':'.':'.':[])
17:55:24 <AvengerX> see? :)
17:55:30 <sorear> @src String
17:55:31 <lambdabot> type String = [Char]
17:55:38 <AvengerX> yeah, nmessenger! :)
17:55:50 <LoganCapaldo> > take 3 $ ['.','.',...]
17:55:50 <lambdabot>  Parse error
17:55:54 <AvengerX> looks like the monster is right awaiting for the dots
17:55:57 <LoganCapaldo> oh fine
17:56:04 <sorear> > take 3 $ ['.','.'...]
17:56:04 <lambdabot>  Parse error
17:56:09 <nmessenger> that's the "robot ninja monkey with a very tall hat"
17:56:09 <sorear> > take 3 $ ['.','.'..]
17:56:11 <lambdabot>  "..."
17:56:15 <LoganCapaldo> > take 3 $ (fix ('.':))
17:56:17 <lambdabot>  "..."
17:56:32 <AvengerX> LOL
17:56:32 <sorear> repeat = fix . (:) btw
17:56:39 <sorear> forever = fix . (>>)
17:56:41 <LoganCapaldo> sorear, heh that syntax looks better with numbers
17:56:42 <monochrom> Nothing precise.  Just that since fountain pens come in a full spectrum of price-quality (from 5 to 500), I think I can at least name a mid-range price, and that happens to be about 70 (it's also what I spent for mine).
17:56:43 <sorear> cycle = fix . (++)
17:57:01 <sorear> can anyone find any more?
17:57:30 <sorear> @ty fix . (.)
17:57:33 <lambdabot> forall c a. (c -> c) -> a -> c
17:57:34 <nmessenger> @fixify anyone?
17:57:34 <lambdabot> Unknown command, try @list
17:57:45 <AvengerX> > fix . '.'
17:57:47 <lambdabot>  Couldn't match expected type `a -> a1 -> a1'
17:57:52 <sorear> @pl let f g = g (f g) in f
17:57:53 <lambdabot> fix (ap id)
17:58:02 <sorear> = fix . id = fix
17:58:05 <LoganCapaldo> sorear, Now you want to explain (c -> c) -> a -> c ?
17:58:17 <AvengerX> *dazzled
17:58:20 <sorear> LoganCapaldo: easy. \f _ -> fix f
17:58:40 <chessguy> :t fix
17:58:42 <lambdabot> forall a. (a -> a) -> a
17:58:53 <xerox> id = fix . return
17:59:09 <chessguy> ?src return
17:59:09 <lambdabot> Source not found. My mind is going. I can feel it.
17:59:16 <chessguy> :t return
17:59:18 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:59:24 <chessguy> oh that return
18:00:17 <monochrom> I particularly like the feeling of waterly ink flowing out of the tip while I write slowly.  It's a fetish.  Of course there are downsides.  It's water-soluble (hell, it's 99% water), so you could be writing Haskell or math so beautiful, you drop tears and it's all smear... :)
18:00:42 <LoganCapaldo> sorear, so its "add an extra argument pointlessly?" :)
18:02:17 <Cale> monochrom: I like fountain pens too.
18:02:45 <lispy> xerox: i thought it was more like, id = const . fix (or maybe i have them backwards)
18:03:04 <Cale> It's a shame that it's not easier to find materials for them around here.
18:03:29 <Cale> Everyone uses ball points, and that's basically all you can find unless you look pretty hard.
18:03:30 <xerox> lispy: that does not do the same thing.
18:03:48 <lispy> :t fix . const
18:03:49 <hpaste>  Avenger pasted "Error in code (trying to set a string length in a where)" at http://hpaste.org/632
18:03:51 <lambdabot> forall a. a -> a
18:03:54 <Cale> Well, that, and those fine-point pens.
18:04:03 <lispy> :t fix . return
18:04:06 <lambdabot> forall a. a -> a
18:04:15 <nmessenger> > (fix . const) 5
18:04:16 <lambdabot>  5
18:04:26 <AvengerX> :t cons
18:04:28 <nmessenger> return = const
18:04:29 <lambdabot> Not in scope: `cons'
18:04:35 <xerox> I have fallen back to soft pencil after a period of fine-point pens usage.
18:04:44 <Cale> AvengerX: Preco looks like a type in your code, not a value.
18:04:55 <Cale> do you mean the second part of item?
18:04:57 <AvengerX> hmm
18:05:03 <AvengerX> yep
18:05:06 <Cale> snd item
18:05:10 <Cale> or else pattern match
18:05:20 <Cale> formataLinha (nome, preco) = ...
18:05:22 <nmessenger> s/item/(nome,preco)/
18:05:43 <AvengerX> omg sure
18:05:47 <AvengerX> heh
18:06:05 <lispy> is that italian?
18:06:07 <AvengerX> hmmm I like pattern match (and I think the teacher will love it too heh
18:06:08 <AvengerX> )
18:06:14 <AvengerX> no, portuguese (brazil)
18:06:15 <xerox> I quite like slowly smashing the tip on the paper.
18:06:21 <lispy> AvengerX: yes, pat. matching is good!
18:06:30 <lispy> AvengerX: ah, okay
18:07:05 <lispy> AvengerX: i don't know portuguese or italian, i'm just guessing for the fun of it
18:07:19 <AvengerX> heh
18:07:22 <xerox> I also have a black-paper book on which I write with a white pen. But that's another story.
18:07:52 <AvengerX> lol xerox
18:08:27 <AvengerX> I have a dark-green monitor where I write in bright green :)
18:08:45 <nmessenger> geh, pen porn: "<xerox> I quite like slowly smashing the tip on the paper."
18:09:03 <Botje> somebody should ?remember that.
18:09:06 <xerox> While you write on that it looks like the words make their way out from the paper, emitting light.
18:09:57 <AvengerX> maybe the ink is neonized
18:10:10 <AvengerX> that thing that emits light when exposed long enough to light
18:10:18 <AvengerX> (certain lights)
18:10:56 <shapr> phosphors
18:11:02 <AvengerX> well, like some common (and cheap) room light interruptors, and CRT video
18:11:12 <AvengerX> *crt tube
18:11:40 <AvengerX> yeah phosfluorescent or phosphorecent, something like it
18:13:28 <AvengerX> Cale: var preco conflicted with type Preco.. (??)
18:13:32 <AvengerX> was it supposed to happen?
18:14:34 <AvengerX> renamed 'em to other names and works (apparently) fine
18:15:48 <nmessenger> weird.
18:17:27 <Cale> AvengerX: er, it shouldn't, they're in completely different namespaces
18:17:50 <sorear> what is the situation wrt free and nullPtr?
18:18:02 <dons> don't free the nullPtr /
18:18:20 <sorear> ANSI C says I can, so I wondered about haskell.
18:18:23 <AvengerX> so, the nullptr is captive
18:18:36 <sorear> it would shorten my ffi abusing code
18:18:40 <dons> -- |Free a block of memory that was allocated with 'malloc',
18:18:41 <dons> -- 'mallocBytes', 'realloc', 'reallocBytes',
18:18:56 <dons> and your nullPtr isn't created by those, I think.
18:19:20 <sorear> I'm glad I asked!
18:19:34 <sorear> Prelude Foreign> free nullPtr
18:19:34 <sorear> Prelude Foreign> System.Mem.performGC
18:19:34 <sorear> Prelude Foreign> -- no segfault !
18:19:39 <dons> cool
18:19:42 <sorear> woulda thought it safe
18:19:54 <sorear> vty bugreports are no fun :)
18:20:05 <SamB> Prelude Foreign> free (nullPtr :: Ptr ())
18:20:05 <SamB> Prelude Foreign> free (nullPtr :: Ptr ())
18:20:05 <SamB> Prelude Foreign>
18:20:12 <dons> nb. it is directly a call to foreign import ccall unsafe "stdlib.h free"    _free    :: Ptr a -> IO ()
18:20:15 <monochrom> Does Haskell's free just delegate to C's free?  Because if so there is no problem.
18:20:22 <dons> monochrom: see above. yes.
18:20:30 <SamB> dons: sorear just said that C's is safe..
18:20:33 <sorear> er, that's not haskell's free
18:20:38 <sorear> that's GHC's free
18:20:48 <monochrom> GHC's free.
18:21:02 <monochrom> You can't just trust the docs.
18:21:12 <dons> the docs are more conservative
18:21:23 <dons> so you're doing something that isn't documented..
18:21:40 <dons> which may or may not be ok (looks ok here). still, i've never needed to do this in haskell in 9 years. so um. hmm. hmm.
18:22:05 <monochrom> Perhaps "nullPtr" could be Java's rather than C's.
18:23:16 <AvengerX> how do I do conditional assignments (may I use the word 'assignment' in haskell?) for variables?.. if (blah) var=this; else var=that; or there's a (better) way to do inside the var=<expression> ?
18:23:29 <monochrom> I mean, perhaps FFI binds to something other than C.  Then the semantics of malloc, free, nullPtr changes slightly.
18:23:42 <dons> > let x = if 1 > 2 then 3 else 4 in x
18:23:44 <lambdabot>  4
18:23:55 <AvengerX> hmmm no parens
18:24:10 <dons> AvengerX: yeah? if-then-else is just an expression. so no need for mutable updates in the conditions :-)
18:24:15 <sorear> how does one load 2 modules simultaneously in Hugs?
18:24:34 <dons> let var = if blah then this else that -- direct translation
18:24:42 <dons> in fact,   let var | blah = this | otherwise = that
18:24:43 <monochrom> ?: is the biggest mystery dawned on haskell novices from imperative worlds.
18:24:44 <lambdabot> Maybe you meant: . v
18:25:07 <monochrom> And I do mean ?:, not . v :)
18:25:11 <sorear> :also doesn't work :/
18:25:11 <sorear> Hugs.Base> :also Foreign
18:25:11 <sorear> Foreign> :also System.Mem
18:25:11 <sorear> System.Mem> free nullPtr >> performGC
18:25:11 <sorear> ERROR - Undefined variable "nullPtr"
18:25:12 <dons> ?pretty var | blah = this | otherwise = that
18:25:13 <lambdabot>  var | blah = this
18:25:14 <lambdabot>      | otherwise = that
18:25:49 <AvengerX> sorear: use 'import'?
18:25:51 <monochrom> how about :also Foreign System.Mem ?
18:26:00 <sorear> monochrom: didn't work either
18:26:05 <monochrom> oh well
18:26:18 <AvengerX> module <name> where
18:26:23 <AvengerX> import <othermodule.hs>
18:26:36 <AvengerX> is something like it, or am I screwed?
18:26:40 <sorear> AvengerX: this is at the prompt!
18:26:47 <AvengerX> ahh
18:26:51 <sorear> and yhc has no System.Mem!
18:27:05 <AvengerX> wouldn't it be :load <one> then :load <second>
18:27:05 <AvengerX> ?
18:27:05 <sorear> (it does have Foreign.Ptr and Foreign.Marshal.Alloc though)
18:27:59 <sorear> AvengerX: same breakage :(
18:28:25 <sorear> loading in file --> runhugs did the trick (no crash btw)
18:28:33 <AvengerX> well, I load modules this way... or hugs <mod1> <mod2> ...
18:28:46 <AvengerX> :)
18:29:56 <stmartin> System.Console.Readline is a little odd. Why, when I say   readline "Hello: "   and enter in   World   at the prompt, does it return   "Just \"World\""?   Where does the Just come from?
18:30:20 <lispy> stmartin: from the Maybe type
18:30:30 <lispy> :t Just "world"
18:30:32 <AvengerX> :)
18:30:32 <lambdabot> Maybe [Char]
18:30:33 <AvengerX> ops
18:30:33 <chessguy> :t System.Console.Readline
18:30:35 <lambdabot> Couldn't find qualified module.
18:30:42 <chessguy> :t Readline
18:30:45 <lambdabot> Not in scope: data constructor `Readline'
18:30:46 <lispy> ?hoogle readline
18:30:47 <lambdabot> System.Console.Readline.readline :: String -> IO (Maybe String)
18:30:47 <lambdabot> System.Console.Readline :: module
18:30:47 <lambdabot> System.Console.Readline.setReadlineName :: String -> IO ()
18:30:49 <chessguy> sigh
18:31:06 <lispy> as you can see, it has type String -> IO (Maybe String)
18:31:22 <monochrom> Interesting, when does it return Nothing?
18:31:32 <lispy> eof?
18:31:50 <stmartin> So how do I get an input from the user using readline?
18:32:01 <lispy> :t fromJust
18:32:04 <lambdabot> forall a. Maybe a -> a
18:32:08 <lispy> that's an evil way
18:32:12 <Cale> Or case
18:32:14 <lispy> probably better to pattern match on the result
18:32:18 <monochrom> You play a dangerous game :)
18:32:23 <sorear> eof is right
18:32:35 <sorear> readline returns Nothing on eof
18:32:41 <monochrom> case blah of {Nothing -> ... ; Just something -> ...}
18:32:48 <monochrom> thanks lispy sorear
18:32:55 <sorear> unlike getLine which throws an exception :)
18:33:07 <Cale> and right before that, you'd have  blah <- readline "Hello: "
18:33:09 <lispy> Nothing is an exception (in the Maybe monad...)
18:33:09 <monochrom> exceptions are also fine
18:33:35 <sorear> lispy: OK, an IOERROR
18:33:47 <lispy> > fail "oh on!" :: Maybe String
18:33:48 <lambdabot>  Nothing
18:34:17 <Cale> ugh, fail
18:34:19 <sorear> also remember to call ... on the result
18:34:26 <sorear> @ty System.Console.Readline.addHistory
18:34:29 <lambdabot> String -> IO ()
18:34:40 <monochrom> The rush to code up "real" programs, before one learns the basic types properly, ...
18:34:55 <monochrom> is why people love dynamically typed languages so much.
18:35:30 <lispy> i was recently told that type systems like Haskell encourages an over confidence in code which compiles
18:36:11 <SamB> heh
18:36:13 <monochrom> oh, and untype systems like Python encourages an over confidence in code which runs
18:36:13 <SamB> well, maybe
18:36:19 <SamB> heh
18:36:24 <monochrom> EITHER WAY YOU LOSE
18:36:43 <SamB> at least with Haskell, you are more likely to be right
18:37:34 <monochrom> The biggest obstacle to programming is still the human himself, not the computer, not the languages, not the tools.
18:37:42 <lispy> SamB: but they then argue that with Haskell you spend more time getting the code to compile (dealing with the type checker).  Oh and this was almost a Haskell vs. Python debate
18:38:22 <sorear> I believe in quality software.
18:38:25 <chessguy> you know you're programming a lot when you start thinking about what mathematical/programming structures could be used to solve the game you're playing
18:38:34 <lispy> well, i told the person we shouldn't argue about it unless they know some empirical studies that address our claims...otherwise we're jsut debating our experience/intuition
18:38:41 <sorear> I would rather have code that always works, than code which usually works
18:38:42 <siti> @seen dcoutts
18:38:43 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 1h 24m 10s ago.
18:38:57 <dcoutts> siti, pong
18:39:10 <nmessenger> "dealing with the type checker" vs. "figuring out incorrect algorithms"... I have MUCH more experience with the second, but am appreciating the first.
18:39:25 <siti> dcoutts: any reason why the cairo bindings don't have push/pop group ?
18:40:06 <dcoutts> siti, it's called save/restore
18:40:25 <siti> nah, push group is different
18:40:41 <dcoutts> siti, oh ok, I misunderstood
18:40:45 <siti> http://www.cairographics.org/manual/cairo-cairo-t.html#cairo-push-group
18:40:47 <lambdabot> Title: cairo_t, http://tinyurl.com/2hasuh
18:40:55 <hpaste>  stmartin pasted "getNums" at http://hpaste.org/634
18:41:09 <stmartin> No instance for (Num (IO Integer))
18:41:09 <stmartin>       arising from the literal `0' at NumStats.hs:35:15
18:41:15 <sorear> return
18:41:18 <dcoutts> sieni, ah that's a new thing in version 1.2, the bindings have not been updated since the 1.0 api.
18:41:23 <stmartin> It has to do with the literal 0
18:41:25 <dcoutts> oops siti ^^^
18:41:25 <siti> ok
18:41:38 <hpaste>  sorear annotated "getNums" with "fixed?" at http://hpaste.org/634#a1
18:41:38 <dcoutts> (nick tab completion)
18:41:45 <siti> hehe
18:42:00 <dcoutts> siti, would you like to help update them? xerox has been very busy and can't find the time to do it.
18:42:20 <nmessenger> sorear added return: http://hpaste.org/634/diff?old=0&new=1
18:42:31 <sorear> stmartin: also notice the diff boxes; glguy++
18:42:49 <stmartin> Ta, having trouble finding what you changed.
18:43:05 <orbitz> ist her ea built in funciotn for soemthign like: bind2 f c x y = f (c x) (c y)
18:43:16 <stmartin> Nothing shows as old or new
18:43:20 <sorear> orbitz: Data.Function.on
18:43:20 <xerox> ?type let (.:) = (.) . (.); readline = System.Console.Readline.readline in ((. readline) . fmap) .: maybe
18:43:22 <lambdabot> forall a. a -> (String -> a) -> String -> IO a
18:43:24 <nmessenger> orbitz: not in 6.6
18:43:34 <sorear> stmartin: you need to select different versions :)
18:43:34 <chessguy> stmartin, you have to change the second drop-down box to say 1: fixed?
18:43:47 <siti> dcoutts: I'll have a look at it but I don't really know how the bindings work
18:43:56 <stmartin> ah, thanks.
18:44:09 <orbitz> is 6.7 the next version?  sill it be out as stable soon?
18:44:14 <stmartin> Out of curiosity, why does that matter?
18:44:15 <dcoutts> siti, the code is actually quite clear, xerox wrote it well :-)
18:44:16 <sorear> orbitz: no, no
18:44:20 <siti> ok
18:44:20 <nmessenger> orbitz: the HEAD has a function 'on' defined like that.  i.e. (compare `on` snd)
18:44:21 * xerox hugs dcoutts 
18:44:21 <stmartin> (the return bit)
18:44:25 <siti> lol
18:44:27 <dcoutts> ;-)
18:44:31 <sorear> orbitz: 6.7 will NEVER be released.
18:44:36 <orbitz> why?
18:44:38 <sorear> orbitz: just like Linux 2.1 never was
18:44:46 <sorear> orbitz: odd minor version
18:44:48 <orbitz> does it not exist?
18:44:51 <orbitz> ok
18:44:59 <nmessenger> 6.8 might be eventually, though :)
18:45:00 <orbitz> what is the next verion goin got be and how far away is it?
18:45:13 <sorear> orbitz: 6.8, 1-5 years I'd say
18:45:24 <orbitz> why so long?
18:45:29 <dcoutts> 6.6.1 and 6.6.2 will be next
18:45:30 <chessguy> hmm, before or after haskell' i wonder
18:48:01 <chessguy> ?loser
18:48:01 <lambdabot> Unknown command, try @list
18:48:06 <chessguy> ?losers
18:48:06 <lambdabot> Maximum users seen in #haskell: 329, currently: 305 (92.7%), active: 44 (14.4%)
18:48:17 <chessguy> ah, broke the record
18:48:29 <chessguy> dons, ^^
18:50:03 * orbitz licks chessguy 
18:50:37 <chessguy> orbitz, news flash: this is not ##c++
18:50:53 * nmessenger also licks chessguy
18:51:11 <AvengerX> why I see always 2 less than lambdabot?
18:51:12 * chessguy chops off nmessenger's tongue and feeds it to lambdabot
18:51:14 <orbitz> chessguy: right, it's way better
18:51:15 <thorat>  /join ##c++
18:51:35 <heatsink> @seen dcoutts
18:51:35 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 6m 6s ago.
18:51:36 <chessguy> orbitz, better language => better people
18:51:40 <siti> does #c++ have their own bot ;)
18:51:42 <dcoutts> hia heatsink
18:51:46 <heatsink> Hi
18:52:00 <orbitz> siti: they ahve my bot, it's no lambdabot though
18:52:03 <orbitz> (although ti was writen in erlang)
18:52:13 <orbitz> chessguy: yes, uch funenr people who i can lick
18:52:23 <LoganCapaldo> And more importantly does it support template metaprogramming in the channel?
18:52:25 <siti> lol erlang bot in #c++ that is weird :p
18:52:26 <heatsink> I've been looking at that ghc ia64 port, I just figured out what is the next problem that needs fixing
18:52:34 * chessguy stays far away from ##c++
18:52:47 <dcoutts> heatsink, oh yeah?
18:52:47 <orbitz> chessguy: why? it' sos much fun
18:52:55 * orbitz touches chessguy's butt in a manly way
18:53:22 * chessguy pulls out his numchucks
18:53:37 <heatsink> yup.  Problem is that tailcalls aren't getting mangled with my setup
18:53:39 <mbishop> there's a manly way to touch someone's butt?
18:53:49 <heatsink> so a call happens instead of a tail call, messing up the register stack
18:53:55 <chessguy> sooooo, how 'bout them monads
18:54:08 * nmessenger is now mute
18:54:18 <sorear> @localtime beschmi
18:54:20 <lambdabot> Local time for beschmi is Sat Feb 24 05:01:26
18:54:20 * chessguy points at nmessenger and laughs
18:54:22 <dcoutts> heatsink, right
18:54:47 <dcoutts> heatsink, so perhaps it's not striping the prologue and epilog properly
18:54:49 * nmessenger tries to say "You bastard!" but instead makes strange huffing noises
18:54:56 <sorear> @tell beschmi (with up-to-the-minute shim) Symbol's function definition is void: shim-buffer-file-name-maybe-translated
18:54:57 <lambdabot> Consider it noted.
18:55:17 <heatsink> Oh, I should check on that.
18:55:33 <chessguy> nmessenger, strange - it's usually women i have that effect on
18:55:50 * nmessenger beats chessguy into a pulp
18:56:24 <heatsink> dcoutts: gcc sometimes puts the epilogue in the middle of the function.  That's not an ia64-specific optimization, so I'm surprised it hasn't come up before.
18:56:28 * nmessenger talks in thought bubbles henceforth, like Garfield
18:56:33 * Knio cries because his program doesnt work
18:57:07 <dcoutts> heatsink, yeah, I'm not sure if the mangler on other arches have to cope with that.
18:57:11 * nmessenger thinks "Knio: did you paste it?"
18:57:13 <chessguy> nmessenger can't control his/her aggressions, either. He/She picked on others 7 times.
18:57:33 <chessguy> chessguy seems to be unliked too. He/She got beaten 6 times.
18:58:00 <Knio> http://root.h4xn3t.zapto.org:8080/school/cpsc349/a2/parser.hs :D
18:58:06 * nmessenger wonders how chessguy knows this, then remembers LB
18:58:16 <chessguy> ?where stats
18:58:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:58:23 <chessguy> lambdabot is always watching
18:58:51 * sorear likes being the most active human
19:00:24 <siti> http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html <-- funny seen who is the most talkative :p
19:00:24 <lambdabot> Title: #haskell @ freenode.org stats by dons
19:00:29 <siti> seeing*
19:00:57 * allbery_b is slightly embarrassed...
19:01:07 <LoganCapaldo> wooo, I'm in last place!
19:01:09 <stmartin> What is the haskell operator for div. I tried %, but ghci says its out of scope. I see no mention of any such operator in yaht
19:01:18 <sorear> #2 and #3 are also interesting :)
19:01:29 * nmessenger suggests `div` to stmartin
19:01:42 * stmartin thanks nmessenger
19:01:44 <nmessenger> > 10 `div` 3
19:01:46 <lambdabot>  3
19:01:47 <siti> if you are using a double then use /
19:01:53 <sorear> and I'm not here 8-16 hrs a day
19:01:55 <siti> > 1 / 0.2
19:01:56 * LoganCapaldo would guess % to be mod
19:01:57 <lambdabot>  5.0
19:02:05 <allbery_b> nope
19:02:06 <siti> `mod` is mod :p
19:02:12 <allbery_b> % is used with rationals
19:02:14 <LoganCapaldo> If I was going guess about %
19:02:15 <siti> well you can use it without infix...
19:02:17 <LoganCapaldo> I know
19:02:18 * nmessenger thinks " LoganCapaldo: nope, that's the Fractional constructor"
19:02:18 <allbery_b> > 5%3
19:02:20 <lambdabot>  5%3
19:02:29 <lispy> > (-8) `mod` 5
19:02:31 <siti> > 5 `mod` 2
19:02:31 <lambdabot>  2
19:02:32 <lambdabot>  1
19:02:38 <lispy> and it really is mod!
19:02:39 * stmartin suggests mod to himself instead.
19:02:41 <allbery_b> > 10%6
19:02:42 <sorear> > 200 % 25
19:02:43 <lambdabot>  5%3
19:02:44 <lambdabot>  8%1
19:02:45 <sorear> > 200 % 75
19:02:47 <lambdabot>  8%3
19:02:48 <sorear> @botsnack
19:02:49 <lambdabot> :)
19:02:52 <sorear> lag sucks
19:02:53 <heatsink> dcoutts: okay, just wanted to know if I was on the right track.
19:02:54 <sorear> lag--
19:02:58 <lispy> % is a nice way to compute the gcd though :)
19:03:07 <sorear> and :% is the internal constructor
19:03:18 <LoganCapaldo> I know mod is mod, I just figured if % was gonna be anything related to division it would be mod
19:03:20 <AvengerX> nice /me interactivity
19:03:20 <AvengerX> * nmessenger suggests `div` to stmartin
19:03:20 <AvengerX> * stmartin thanks nmessenger
19:03:24 <AvengerX> :)
19:03:36 <siti> > gcd 112 92
19:03:38 <lambdabot>  4
19:03:42 <siti> :)
19:03:42 <sorear> > rem (-20) 3
19:03:44 <lambdabot>  -2
19:03:46 <LoganCapaldo> -fallow-passive-voice
19:03:54 * nmessenger lols at "lambdabot is a very aggressive person. He/She attacked others 51 times."
19:03:55 <AvengerX> > sub (-20) 3
19:03:56 <lambdabot>   Not in scope: `sub'
19:04:07 * dcoutts uploads gtk2hs-0.9.11 to sourceforge and sends out the release announcement
19:04:13 * sorear claps
19:04:23 * xerox woohoos
19:04:25 <dcoutts> woo!
19:04:29 <AvengerX> tought sub were 'subtract' :P
19:04:29 <siti> nice :)
19:04:30 <notsmack> dcoutts++
19:04:34 <dcoutts> right, now I'm off to FOSDEM!
19:04:41 * sorear YAAYA!
19:04:41 * allbery_b hip-hip-hoorays!
19:04:45 * dcoutts has to get a bus in 30 min
19:04:46 <xerox> ?time dcoutts
19:04:48 <lambdabot> Local time for dcoutts is Sat Feb 24 03:02:37
19:04:51 <allbery_b> :t subtract
19:04:51 <siti> @slap notsmack that's c style
19:04:51 * lambdabot slaps notsmack that's c style
19:04:53 <lambdabot> forall a. (Num a) => a -> a -> a
19:04:55 <xerox> Yuck!
19:05:00 <LoganCapaldo> > 2 `dom` 3
19:05:00 <lambdabot>   Not in scope: `dom'
19:05:08 <LoganCapaldo> drat
19:05:09 <dcoutts> xerox, to get to Brussels by 9:30 :-)
19:05:17 <AvengerX> have a nice trip, dcoutts. :)
19:05:24 <xerox> dcoutts: ah, cool. Enjoy!
19:05:24 <dcoutts> thanks!
19:05:35 <siti> dcoutts: yeah I am might send you some pathces
19:05:47 <sorear> wow, dcoutts, your bus can float! :)
19:05:50 <siti> with updated cairo bindings if I get a around to it
19:05:53 <dcoutts> siti, cool, and you can get xerox to review them :-)
19:05:58 <siti> ok
19:05:59 <xerox> ?time
19:06:00 <lambdabot> Local time for xerox is 2007-02-24 04:03:42 +0100
19:06:01 <AvengerX> but don't get too worried with patches and lose your path, right? :)
19:06:02 <sorear> ?time
19:06:04 <lambdabot> Local time for sorear is Fri Feb 23 19:03:46 2007
19:06:04 <dcoutts> sorear, hah, bus to London then eurostar :-)
19:06:29 <sorear> eurostar :: airline?
19:06:36 <siti> train I bet :p
19:06:39 <chessguy> orbitz, by the way: enjoy what you catch in a couple of days
19:06:42 <xerox> siti wins.
19:06:55 <AvengerX> I would bet on UFO
19:07:08 <AvengerX> I will have lost.
19:07:14 <siti> hah
19:08:41 <AvengerX> Yeah! I did it now! :)
19:09:13 <AvengerX>  formataLinha ("Frank Heiss",2343235)
19:09:13 <AvengerX> "Frank Heiss...........23432.35"
19:09:30 <AvengerX> and if first string is toooo big, it'll be cut in order to preserve the value! :)
19:09:38 * AvengerX feels like a haskell coder
19:10:35 * nmessenger congratulates AvengerX
19:10:41 <AvengerX> "Now that I have projected this string formatter, I will be entering a project for developing a operating system all written in haskell.." (media: my text for the interview is done)
19:11:12 <AvengerX> hmmm forgot a newline char there
19:11:34 <LoganCapaldo> Mmm Lazy OS
19:11:43 <AvengerX> ty ty nmessenger! I would have still stuck on the price if it werent you and other people here
19:11:48 <LoganCapaldo> it doesn't write to any files until you try to read from them
19:11:52 <beschmi> sorear: can you grep for that identifier in shim.el?
19:11:52 <lambdabot> beschmi: You have 1 new message. '/msg lambdabot @messages' to read it.
19:13:09 <JohnMeacham> buzzow. I am pleased.
19:13:23 * Knio 's program works!
19:13:46 <sorear> JohnMeacham: ?
19:14:28 <sorear> JohnMeacham: btw, jhc is broken on nobench because I re-enabled haskell98 and dons hasn't upgraded to a version (of jhc) with non-broken haskell98.
19:14:59 <JohnMeacham> I think my new abstract machine might rock. it requires a type inference pass right before code generation, but then spits out highly optimized code. as a side effect, I can use the exact same vm for compiling ml or strict languages and they pay no penalty for lazy evaluation.
19:15:24 <JohnMeacham> and of course, that means that parts of your haskell programs that happen to be strict (not just unboxed) pay no penalty for lazy evaluation.
19:15:29 <sorear> JohnMeacham: i386 shares all the features you just described :)
19:15:34 <heatsink> haha
19:15:47 <SamB> sorear: hah
19:15:49 <sorear> ml, compiled to machine code, pays no lazyness penalty
19:15:58 <SamB> sorear: except that abstract part
19:15:59 <JohnMeacham> hmm.. perhaps abstract machine isn't the word.
19:16:05 <SamB> try llvm?
19:16:11 <JohnMeacham> sorear: indeed. and now neither will a ml front end for jhc.
19:16:14 <sorear> well, an abstract machine can't run any code.
19:16:19 <hpaste>  mauke pasted "typeclass troubles" at http://hpaste.org/635
19:16:20 <stmartin> Yeah! I did FizzBuzz without any help!
19:16:25 <sorear> cool.
19:16:29 <SamB> sorear: well, a machine more abstract than x86 can...
19:16:31 <sorear> JohnMeacham: very nice...
19:16:33 <SamB> such as llvm!
19:16:39 <JohnMeacham> seamless mixing of ml and haskell code was a goal.
19:16:59 <LoganCapaldo> How "seamless"?
19:17:04 <mauke> how can I fix my typeclasses?
19:17:13 <JohnMeacham> very.
19:17:21 * LoganCapaldo has nightmares about ML refs polluting up pure haskell code
19:17:23 <SamB> can you use typeclasses in ML now?
19:17:25 <sorear> JohnMeacham: is this a replacement for E/GRIN? or something else entirely
19:17:30 <LoganCapaldo> (in the same file)
19:17:44 <monochrom> JohnMeacham: please polish it up and publish it!  I also want to know your secret of success. :)
19:18:16 <sorear> Pulling from "http://www.repetae.net/repos/jhc"...
19:18:16 <sorear> No remote changes to pull in!
19:18:39 <JohnMeacham> no. it is a new translation of grin to C. but it doesn't require the whole program analysis pass to be run first. (though, it still can help)
19:20:05 <sorear> did the old way also mean no lazyness penalty?
19:22:49 <heatsink> mauke: try giving anyToken an explicit type signature
19:23:01 <sorear> JohnMeacham: blaphohisu is much more memory hungry than ejthecnar was
19:23:14 <sorear> JohnMeacham: hello world used to compile with no rts options.
19:23:24 <heatsink> Hmm, that doesn't seem to work.
19:23:33 <sorear> JohnMeacham: now it starts swapping right at Loading library base...
19:24:31 <heatsink> mauke, which 'anyToken' parser would run when eof is called?
19:24:44 <AvengerX> hmmm azeitona's good... although I miss wine
19:24:59 <mauke> heatsink: ok, I think I understand the problem :-)
19:25:00 <JohnMeacham> sorear: did you grab the new libraries? the ho file format changed dramatically.
19:25:20 <sorear> JohnMeacham: yes.
19:25:21 <JohnMeacham> that is probably due to Data.Binary not being lazy.
19:25:29 <sorear> oh yeah...
19:25:56 <sorear> JohnMeacham: how high on your priorities list is "make ByteString work"?
19:26:36 <siti> where's data.binary is it an addon?
19:26:43 <sorear> @where binary
19:26:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
19:26:45 <mauke> heatsink: let me try some fundeps
19:26:50 <sorear> siti: ^^
19:26:55 <sorear> siti: yes it is
19:26:56 <siti> k
19:27:15 <hpaste>  stmartin pasted "FizzBuzz" at http://hpaste.org/636
19:27:23 * sorear applauds
19:27:32 <AvengerX> o' weird but cool
19:27:32 <mauke> ok, that lets the minimal test compile
19:27:35 <siti> I am sure Data.Binary is needed in that frag game, it currently uses malloc hacks everywhere :(
19:27:38 <AvengerX> > replicate 2 '.'
19:27:40 <lambdabot>  ".."
19:27:43 <AvengerX> > replicate 1 '.'
19:27:45 <lambdabot>  "."
19:27:56 <AvengerX> yeah! it turns into a string of one char :)
19:27:56 <stmartin> How to map through a list of strings, and print each on its own line to stdout?
19:28:10 <sorear> mapM_ putStrLn
19:28:10 <jcreigh> mapM putStrLn ["hello", "world"]
19:28:15 <AvengerX> map string
19:28:17 * nmessenger retrieves tongue from lambdabot
19:28:27 <mbishop> gross
19:28:32 <hpaste>  sorear annotated "FizzBuzz" with "fix?" at http://hpaste.org/636#a1
19:28:33 <araujo> hello
19:28:34 <stmartin> Ah, that's right. I had read somewhere about mapM_ for monadic stuff
19:28:39 <nmessenger> stmartin: also you could join the lines together via unlines
19:28:51 <AvengerX> araujo: hello there! o/
19:29:12 <JohnMeacham> sorear: what do you mean?
19:29:14 <mauke> putStr (unlines ["hello", "world"])
19:29:15 <Cale> stmartin: Just so you know, the difference between mapM and mapM_ is that mapM_ throws away the results of the actions.
19:29:30 <mauke> and why doesn't haskell have qw()
19:29:30 <nmessenger> > unlines ["hello", "#haskell"]
19:29:32 <lambdabot>  "hello\n#haskell\n"
19:29:48 <Cale> mauke: it has 'words'
19:29:55 <nmessenger> mauke: (words "blah") works
19:29:58 <stmartin> Ah, thanks Cale. The rest of yaht should be very useful to me.
19:30:02 <sorear> JohnMeacham: ejthecnar at least did not support (among other things) multi-line RULES pragmas, which fps uses heavily.
19:30:09 <mauke> ok, good enough
19:30:37 <monochrom> Haskell also has Text.regex now if you want regex splitting.
19:30:45 <araujo> hello AvengerX
19:31:11 <AvengerX> mono: module?
19:31:27 <monochrom> oops, Text.Regex
19:31:37 <mauke> monochrom: bah, posix regex
19:31:41 <Cale> Man, the "Why Haskell just works" article has been generating huge amounts of discussion on Reddit :)
19:31:57 <monochrom> Haskell doesn't just work.
19:32:13 <AvengerX> it's lazy
19:32:16 <AvengerX> it does not work
19:32:18 <sorear> Haskell just doesn't work
19:32:21 <monochrom> hahahaha
19:32:39 <AvengerX> hmmm
19:32:48 <AvengerX> So i'm going to make an OS which does not work!
19:32:49 <sorear> anyway, when feasable I ignore anyone who has ever commented on reddit, so this isn't a problem for me.
19:32:52 <AvengerX> cool! better than windows!
19:32:58 <AvengerX> windows pretends to be working
19:32:59 * araujo too tired to throw lambdas at the moment 
19:33:08 <monochrom> it doesn't acquire malware either :)
19:33:09 <JohnMeacham> sorear: well, RULES are pretty compiler specific anyway. I would worry about using ones meant for ghc in jhc.
19:33:10 <AvengerX> mine will not work at all -- and yes -- will do the job
19:33:40 <AvengerX> ask lambdabot to throw some
19:33:41 <nmessenger> @where house
19:33:42 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
19:33:45 <nmessenger> AvengerX: ^^
19:33:48 <sorear> JohnMeacham: then why is Jhc choking on them, instead of just ignoring an uninterpretable pragma?
19:33:49 <AvengerX> lemme start with an infinite
19:34:01 <AvengerX> > cycle "lambda, "
19:34:02 <lambdabot>  "lambda, lambda, lambda, lambda, lambda, lambda, lambda, lambda, lambda, lam...
19:34:10 <AvengerX> infinite lambdas for all you
19:34:20 --- mode: ChanServ set +o dons
19:34:21 <mauke> lambada!
19:34:22 <AvengerX> there's lambda for all the channel, network, and other network's, channels
19:34:25 --- topic: set to '["The Haskell programming language: tip over the vending machine!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
19:34:29 --- mode: ChanServ set -o dons
19:34:40 <nmessenger> dons: ?
19:34:46 <dons> ?quote vending
19:34:47 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
19:34:47 <lambdabot> of insight hits and it all makes sense.
19:34:59 <nmessenger> hahahahah
19:35:07 * AvengerX sees no difference
19:35:34 <AvengerX> ah now I see
19:35:35 <JohnMeacham> sorear: because they are handled in the parser.
19:35:54 <sorear> maybe that's why it was so easy for me to learn haskell.  vending machines seem to spontaneously tip over in my presence.
19:36:01 <dons> JohnMeacham: should I take the head jhc from darcs and build it then? for nobench?
19:36:07 <AvengerX> hmm
19:36:08 <monochrom> > cycle "\x3bb"
19:36:09 <lambdabot>  "\955\955\955\955\955\955\955\955\955\955\955\955\955\955\955\955\955\955\95...
19:36:11 <sorear> JohnMeacham: {-# RULES_JHC #-} anyone :)
19:36:21 <AvengerX> I never messed up with a vending machine
19:36:27 <JohnMeacham> dons: yeah. and get the new libraries.
19:36:41 <sorear> and {-# RULES_GHC #-}
19:36:48 <AvengerX> sorear: beware the robot ninja donkey could eat your comment!
19:36:54 <monochrom> U+03bb or \955 is the real 
19:36:55 <sorear> if it's good enough for OPTIONS it's good enough for rules.
19:37:13 <sorear> monochrom: most characters look like that for me.
19:37:26 <dons> ok.
19:38:03 <AvengerX> my hugs-linux does not accept accents on variables although teacher told me it works with unicode mapping
19:38:10 <AvengerX> maybe my -vim- isn't unicode... :)
19:38:36 <AvengerX> uh
19:38:44 <AvengerX> gotta find my way out to bed
19:38:55 <dons> AvengerX: ghc/ghci
19:38:57 <dons> not hugs.
19:39:13 * sorear /kicks AvengerX bedward
19:39:17 <dons> for why you want to use ghc/ghci, http://www.cse.unsw.edu.au/~dons/nobench/results.html
19:39:17 <lambdabot> Title: nobench: Haskell implementation shootout
19:39:21 <AvengerX> heh
19:39:31 <chessguy> ?losers
19:39:31 <lambdabot> Maximum users seen in #haskell: 329, currently: 304 (92.4%), active: 48 (15.8%)
19:39:47 <sorear> AvengerX: look at the least successful compiler *hehe* and the most *hehe*
19:40:00 <AvengerX> ty ty ty y'all! gnite
19:40:08 <sorear> bye
19:40:08 <Knio> how do you write an if..then statement in lambda form?
19:40:14 <sorear> Knio: you don't
19:40:19 <sorear> Knio: not possible
19:40:20 <Knio> ah
19:40:26 <AvengerX> ghc ==> a hugs variant (something like it)?
19:40:31 <nmessenger> (\b -> if b then x else y)?
19:40:32 <sorear> ghc is a COMPILER
19:40:38 <sorear> hugs is an INTERPRETER
19:40:40 <AvengerX> ahh to make binaries
19:40:41 <sorear> ghc is Batch
19:40:47 <sorear> hugs is Interactive
19:40:49 <dons> ghci is a bytecode interpreter that comes with ghc.
19:40:53 <dons> replacing hugs
19:40:54 <AvengerX> ghci ==> interpreter?
19:40:58 <sorear> ghci/hugs would be a much better comparison.
19:41:04 <sorear> interactive interpreters both.
19:41:05 <AvengerX> ghci not interactive?
19:41:10 <AvengerX> ah ok
19:41:10 <AvengerX> :P
19:41:11 <sorear> GHC Interactive.
19:41:20 <dons> why do you have hugs installed?
19:41:27 <AvengerX> thought it could be 'ghc interpreter'
19:41:27 <dons> i think its time we started recommending ghci by default, not hugs.
19:41:38 <sorear> everyone, 3, 2, 1, "apt-get purge hugs"
19:41:43 <dons> AvengerX: what lead you to install hugs first?
19:41:52 <AvengerX> hmm
19:42:25 <AvengerX> I didn't install hugs... it is in the student's server... I'll ask for the admin to install GHC/GHCi
19:42:50 <svref> I can't remember, but I think HUGS error messages were easier to read initially.
19:42:54 <AvengerX> But they had only told me (further) about hugs, I think they have lil knowledge about GHC
19:43:26 <mauke> I like ghci's errors better
19:43:27 <nmessenger> svref: they are less scary-looking, but I find them lacking in detail now
19:43:43 <sorear> svref: ghci is very recent, once you needed hugs for any kind of interactivity.
19:43:44 <AvengerX> why is GHC better than hugs, overall?
19:43:55 <sorear> afaihvt, I'm not that old
19:43:55 <AvengerX> (well I don't know GHC and barely know HUGS)
19:44:10 <svref> nmessenger: haskell is pretty scary when starting out
19:44:10 <AvengerX> hvt?
19:44:10 <nmessenger> @vera afaihvt
19:44:12 <lambdabot> No match for "afaihvt".
19:44:13 <mauke> AvengerX: better error messages :-)
19:44:15 <sorear> AvengerX: hugs is essentially unmaintained - ghci is still movign
19:44:21 <AvengerX> hmm
19:44:28 <mauke> AvengerX: ghci lets you define stuff on the fly
19:44:30 <sorear> AvengerX: have been told, mad it up :)
19:44:32 <mauke> as in "let x = ..."
19:44:56 <AvengerX> Let's see if I can manage to install GHC on the box..
19:45:10 <svref> mauke: holy snit, I didn't know that.
19:45:12 <AvengerX> the binaries are ghc/ghci resp, arent them?
19:45:12 <nmessenger> meh, they're both good.  Hugs = Interpreter, GHC = Compiler + GHCi Interpreter
19:45:47 <AvengerX> ghc stands for GNU Haskell Compiler?
19:45:51 <nmessenger> yeah
19:45:56 <sorear> no!
19:45:59 <AvengerX> heh
19:46:01 <sorear> Glasgow Haskell Compiler
19:46:06 <nmessenger> yeah @ binaries, no @ name
19:46:07 <sorear> Glasgow /= GNU
19:46:33 <AvengerX> lol
19:46:36 <sorear> which is an anacronism in every way
19:46:45 <sorear> it is developed at Cambridge
19:46:50 <AvengerX> never heard about glasgow
19:46:50 <nmessenger> @wn anacronism
19:46:52 <lambdabot> No match for "anacronism".
19:47:01 <sorear> it accepts a language far to large to be called Haskell anymore
19:47:04 <svref> Glasgow's Not Unix!
19:47:04 <sorear> and it interprets
19:47:06 <mauke> @spell anacronism
19:47:08 <lambdabot> anachronism anachronisms Anacreon's anachronism's antagonism
19:47:11 <AvengerX> heh
19:47:11 <sorear> !! 0
19:47:20 <nmessenger> @wn anachronism
19:47:22 <lambdabot> *** "anachronism" wn "WordNet (r) 2.0"
19:47:22 <lambdabot> anachronism
19:47:22 <lambdabot>      n 1: something located at a time when it could not have existed
19:47:22 <lambdabot>           or occurred [syn: {mistiming}, {misdating}]
19:47:22 <lambdabot>      2: an artifact that belongs to another time
19:47:24 <lambdabot>      3: a person who seems to be displaced in time; who belongs to
19:47:26 <lambdabot>         another age
19:48:10 <sorear> un-dict archaic term, anyway
19:49:48 <AvengerX> Its name is a recursive acronym for GNU's Not Unix,
19:50:04 * AvengerX trying to find out what GNU means (it seems its an african bull)
19:50:34 <AvengerX> http://en.wikipedia.org/wiki/Wildebeest
19:50:34 <sorear> <AvengerX> Its name is a recursive acronym for GNU's Not Unix,            [19:47]
19:50:34 <sorear> * AvengerX trying to find out what GNU means (it seems its an african bull)
19:50:34 <sorear> ^^^ I got those out of order, correct?
19:50:46 <mauke> let gnu = gnu is not unix in infinite recursion
19:50:53 <AvengerX> no... in order :P
19:51:09 <AvengerX> I shown a result and then explained why I found it
19:51:33 <AvengerX> wildebeest is the Gnu...
19:51:47 <AvengerX> gnu is incomputable!
19:51:50 <AvengerX> omg
19:52:06 <sorear> http://www.gnu.org/fun/jokes/gnu-overflow.html
19:52:08 <lambdabot> Title: GNU-Overflow - GNU Project - Free Software Foundation (FSF)
19:52:50 <AvengerX> can cause the English language to crash
19:52:51 <AvengerX> lol
19:53:08 <nmessenger> only if you evaluate it strictly :)
19:53:54 * AvengerX hangs up
19:54:09 <nmessenger> my internal English-language parser/evaluator is smart enough to bail out of such infinite recursion without a full-blown crash :D
19:54:19 * AvengerX resets
19:54:22 <AvengerX> oh my head
19:54:33 <AvengerX> My english-lang parser is still in beta :P
19:54:56 <AvengerX> That's what happens when you install Portuguese XP on your system primarily
19:55:03 <nmessenger> heh
19:55:22 <SamB> AvengerX: you should use Portuguese Vista
19:55:26 <SamB> it fixes that issue
19:55:27 <nmessenger> English is the jack-of-all-trades, but its internals are horribly messy
19:55:49 <AvengerX> SamB: I'm waiting a bit... yet, its price is as high as a new brain 3GHz
19:56:17 <AvengerX> I'll wait till it gets cheaper then I'd update my brain and the pt lang parser
19:56:44 <AvengerX> until then i'll buy some updates to my english beta, its cool to help in development
19:57:35 <AvengerX> well... now I go... head is really aching bad (I think i'm spending way too long on computer :P)
19:57:43 <AvengerX> bye
19:58:07 <nmessenger> take care
19:59:22 <mauke> cake tear
19:59:44 <stmartin> Anyone know of a reasonable-resolution of the Haskell logo can be found?
19:59:47 <SamB> tear cake
19:59:58 <dons> stmartin: on haskell.org
19:59:58 <SamB> Cale: do you know?
20:00:01 <dons> we've a logos page
20:00:03 <stmartin> Something about twice as large as the one the site mast.
20:00:10 <dons> but possibly not at the right size. hmm.
20:00:21 <dons> let me see..
20:00:42 <stmartin> That will do nicely. Thank you.
20:00:43 <dons> here, http://haskell.org/haskellwiki/Haskell_logos
20:00:45 <lambdabot> Title: Haskell logos - HaskellWiki
20:01:44 <dons> the retro style := with a / through it logo is also fun
20:03:16 <dons> Cale, you've a talent for simple modern logos. any thoughts on a more modern haskell logo?
20:03:22 <dons> with a lambda, of course.
20:03:32 <dons> something reflecting where we're at now
20:04:13 <fantasma> i agree, the current logo is outdated :)
20:05:13 <svref> worse than the logo: I have to figure out how to pronounce "Haskell" so people stop thinking I'm saying "Pascal".
20:05:34 <dons> the haskell logo i grew up with was lovely retro piece was the :=  in a red ciricle, with a line through it
20:05:34 <sorear> AIEEEE!
20:05:39 <dons> i think that was from yale haskell days
20:05:41 <SamB> svref: you wish to propose change of name in haskell''?
20:05:41 <sorear> http://yi.org
20:05:45 <lambdabot> Title: yi.org Dynamic DNS
20:05:52 <sorear>    We see you're using Internet Explorer, which is not compatible with this site.  We strongly suggest downloading Firefox. We think you'll like it better:
20:05:59 <nmessenger> "Curry" jokes might have been preferable to Haskell/Pascal confusion
20:06:16 <SamB> nmessenger: that name was unfortunately already taken
20:06:21 <sorear> someone here use firefox?
20:06:26 <sorear> what's the useragent?
20:06:27 * nmessenger raises hand
20:06:43 <svref> SamB: eek!  Not my place to propose that.  But it is phonetically == Pascal, eh?
20:06:46 <SamB> Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.7) Gecko/20060830 Firefox/1.5.0.7 (Debian-1.5.dfsg+1.5.0.7-2)
20:06:51 <wkh> does IE have any plugins/extensions that let you lie about your user-agent?
20:07:00 <sorear> My current user-agent: "ELinks/0.11.1-1.2-debian (textmode; %s; %t-%b)"
20:07:08 <sorear> wkh: who says I'm using IE?
20:07:20 <dons> the hugs logo is nice, http://cvs.haskell.org/Hugs/pages/images/logo.gif
20:07:31 <sorear> wkh: I don't even use a windowing system, let alone Windows.
20:07:36 <nmessenger> D:  Sites that block whole swaths over users like that make me made.
20:07:42 <nmessenger> of*
20:07:48 <nmessenger> mad*
20:07:52 * nmessenger needs sleep
20:08:10 <svref> I think I'll start saying "Hacks-el"
20:08:15 <fantasma> nmessenger, do you know what the website "oink" is?
20:08:25 <nmessenger> nope
20:08:34 <nmessenger> oink.com?
20:08:41 <fantasma> no, nevermind :)
20:09:02 <SamB> @google oink
20:09:05 <lambdabot> http://oink.me.uk/
20:09:05 <lambdabot> Title: OiNK
20:09:20 <fantasma> hmmm
20:10:38 * nmessenger gets sleep
20:10:40 <nmessenger> bye all
20:10:43 <fantasma> good night
20:10:51 <fantasma> thanks for everything :)
20:12:01 <dons> Cale, oh, here's one i've not seen, http://www.logodesignworks.com/logo-designs/logo-design-h/main/Haskell.gif
20:12:04 <lambdabot> http://tinyurl.com/29m67q
20:12:33 <dons> anyone know where that logo is from?
20:13:03 <svref> Its very GEB
20:13:23 <SamB> svref: it doesn't look hand-carved to me!
20:13:24 <fantasma> originall its from n64
20:13:32 <fantasma> the game console from nintendo
20:13:41 <SamB> oh, wait...
20:13:57 <dons> hehe http://www.sovereign-publications.com/images/thehaskellco/Haskell-logo.gif
20:14:04 <lambdabot> http://tinyurl.com/2b7893
20:14:13 <dons> "Haskell is Americas Design-Build Leader providing the benefits of innovative, conflict free, low cost, quick delivery of facilities to Aviation"
20:14:40 <fantasma> that's annoying
20:17:51 <SamB> where did they get that Haskell 98 logo?
20:23:09 <dylan> so, how long does ghc take to compile with darwinports?
20:23:44 <mauke> ah, I <3 functional dependencies
20:23:45 <dons> doesn't depend on darwinports, depends on the machine.
20:23:52 <dons> betwee 20 minutes and 2 hours for modern machines
20:24:03 <dylan> on a 1.4ghz powerbook
20:24:13 <dons> an hour maybe? with a full build of all libs?
20:24:15 <sorear> 8 minutes ? :)
20:24:23 <dons> 6 minutes on a 16 core box
20:24:36 <sorear> ooh, 16 core box is working now?
20:24:36 <dons> there's too many bottlenecks in the build though
20:24:42 <dons> yep
20:24:44 <dons> :-)
20:24:46 <encryptio> on my 867MHz G4 it takes about 6 hours via fink, compiling twice
20:24:47 <dylan> Sadly, I have to run OSX to have suspend to ram. :(
20:25:13 <sorear> @version
20:25:14 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
20:25:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:25:17 <sorear> @uptime
20:25:17 <lambdabot> uptime: 7d 23h 9m 57s, longest uptime: 7d 23h 9m 57s
20:25:57 <dylan> I'm trying to install darcs so I can get my home directory...
20:26:15 <encryptio> does the type Num a => a -> a require that the two "a"s be of the exact same type (i.e. Int -> Int) or just Num to Num (i.e. Int -> Float) ?
20:26:28 <sorear> same type
20:26:35 <sorear> @type negate
20:26:37 <lambdabot> forall a. (Num a) => a -> a
20:26:44 <sorear> > (negate (2 :: Int)) :: Double
20:26:46 <lambdabot>  Couldn't match expected type `Double' against inferred type `Int'
20:26:47 <dylan> and so I can get my modified version of dwm running. I don't like the mouseyness of OSX's window manager.
20:27:01 <encryptio> dylan: use X11
20:27:04 <sorear> does OSX even have a window manager?
20:27:12 <encryptio> not a customizable one
20:27:14 <sorear> I thought policy was baked into aqua
20:27:17 <dylan> encryptio: I am.
20:27:40 <dylan> but I need darcs before I can do anything. :)
20:47:08 <petekaz> Anyone good with wiki markup on haskell.org?
20:47:34 <petekaz> I created this table on the regex page: http://www.haskell.org/haskellwiki/Regular_expressions
20:47:36 <lambdabot> Title: Regular expressions - HaskellWiki
20:47:51 <SamB> petekaz: it is the same kind as wikipedia...
20:48:18 <petekaz> The problem is that section 2 header creeps to the right side of the table if your wbrowser is open wide enough.
20:48:37 <petekaz> SamB: I use moin and trac wikis only ... never used mediawiki.
20:49:10 <petekaz> If anyone could take a peek and help me out I would be very appreciative.
20:52:14 <petekaz> Nevermind ... I fixed it.
20:53:08 <nrb23> @src foldr
20:53:09 <lambdabot> foldr k z xs = go xs
20:53:09 <lambdabot>     where go []     = z
20:53:09 <lambdabot>           go (y:ys) = y `k` go ys
21:05:51 <fantasma> > let phi = (1 + sqrt 5)/2; n = 2^1000 in floor(n * (logBase 10 phi) - (logBase 10 5)/2) + 1
21:05:52 <lambdabot>  2239320553233994133934543986395243007280135370546670446717269489524600061013...
21:06:36 <fantasma> > let phi = (1 + sqrt 5)/2; n = 10 in floor(n * (logBase 10 phi) - (logBase 10 5)/2) + 1
21:06:37 <lambdabot>  2
21:08:19 <fantasma> @abou
21:08:19 <lambdabot> Unknown command, try @list
21:08:21 <fantasma> @about
21:08:21 <lambdabot> Unknown command, try @list
21:08:23 <fantasma> @list
21:08:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:14:59 <Boney> Oh.  lambdabot's at unsw.
21:15:21 <sorear> yeah!
21:15:33 <Boney> who here was at LCA 2007?
21:15:34 <sorear> Boney:  /who lambdabot dons
21:15:39 <siti> Boney: me
21:15:48 <Boney> siti: how much did it ruck?
21:15:50 <Boney> rock.
21:15:52 <siti> lol
21:15:56 <siti> it was ok :p
21:16:18 <Boney> it was my first confrence of any type and I rekon it really rocked.
21:16:25 <siti> ok
21:16:34 <Boney> I used to be at rmit.edu.au
21:16:41 <Boney> now I'm at unimelb.edu.au
21:16:50 <siti> what part of aus is that?
21:16:54 <Boney> Melbourne.
21:16:56 <sorear> melbourne I guess
21:17:12 <Boney> I start my Honours in computer science this year.
21:17:17 <Boney> doing something language-y
21:17:18 <siti> ok
21:17:18 <sorear> wow, I'm amazed I got that right :)
21:17:32 <Boney> unimelb = University of Melbourne
21:17:36 <sorear> figured
21:17:58 <Boney> http://www.cs.mu.oz.au/research/mercury/index.html <- probably do somthing to do with this.
21:17:58 <lambdabot> Title: The Mercury Project: Introduction
21:18:14 <sorear> but ... san diego native, didn't even realize melborne was in au until 15s ago ...
21:18:39 <abz> Boney: who is your supervisor?
21:19:06 <Boney> abz: I'm hoping for Zoltan.
21:19:12 <abz> excellent
21:19:14 <sorear> @localtime dons
21:19:16 <lambdabot> Local time for dons is Sat Feb 24 16:16:58 2007
21:19:20 <abz> Zoltan's great.
21:19:44 <abz> knows his compiler stuff.
21:19:46 <Boney> abz: he seems pretty cool.  I've only met him twice. hopefully I'll get used to his accent quickly
21:20:06 <Boney> abz: what do you do?
21:20:26 <abz> should be a year of hard work then with Zolton as you supervisor
21:20:43 <abz> Boney: what do I do = Haskell
21:21:00 <dons> sorear: ?
21:21:36 <sorear> dons: nobench run started at Sat Feb 24 01:51:02 EST 2007
21:21:44 <sorear> the 1:51 was meaningless to me
21:22:12 <abz> Boney: have you started to write some Mercury?
21:24:17 <sorear> deleting GHC is amusingly slow
21:25:57 <Boney> abz: I've read "Hello World"
21:25:59 <Boney> I'll start soon.
21:26:04 <Boney> I've also got some papers to read.
21:26:14 <sorear> mm, papers!
21:26:31 <Boney> abz: yeah, everyone says Zoltan works people hard.  I take that to mean he gets the best out of people which sounds good.
21:26:33 <dons> sorear: why? its 1am EST :-) so um, add 5 hours for you time
21:26:57 <mauke> hmm, now that I've fixed my parser, the type of many is many :: (Monad m1, Monad m) => (m1 [a1] -> m [a] -> m1 [a1]) -> m1 a1 -> m1 [a1]
21:26:59 <abz> Hello world should be one line... main = putStrLn "Hello World"
21:27:11 <abz> unlike that Mercury tutorial
21:27:15 <sorear> dons: unfortunately timezone names are not globally unique.
21:27:21 <dons> main = print "...." -- ;)
21:27:36 <Boney> abz: I'm doing this part time.  So I can work.  It will still be busy though.
21:27:38 <sorear> dons: here in San Diego, EST refers unambiguously to New York et al (Eastern US) time.
21:28:09 <dons> little known trick,
21:28:09 <dons> $ cat A.hs
21:28:09 <dons> main = return "hello world"
21:28:09 <dons> $ runhaskell A.hs
21:28:09 <dons> "hello world"
21:28:13 <sorear> besides, I haven't memorized the offset yet :)
21:28:25 <dons> sorear: yeah, its AEDST actually
21:28:39 <Boney> abz: I mean in mercury.  It seems a bit more long-winded.  but the "unique logical variables" which seem to have 1 use in the io module are easier to understand than Monads.
21:28:47 <dons> 4pm here, 9pm in sorear-land
21:28:56 <Boney> I understood them in 15 minutes, it took me too weeks to "get" Monads.
21:29:03 <dons> monads are more general though
21:29:16 <dons> we could have uniqueness of some kind to do IO as well, but we'd still want monads for other things
21:29:21 * sorear fires of a build of GHC HEAD. no more #1151 for me!
21:29:54 <Boney> yeah.  the seem quite handy, for anything where you want a sequence.
21:30:17 <Boney> I understood them once I understood how Either could be implemented with an error on the left and value on the right.
21:30:40 <Boney> then bind can be implemented to not call it's 2nd argument if it's first arugment is an error.
21:30:50 <Boney> and hey code reuse :-)
21:31:01 <abz> was it easier to understand because you had already spent time understanding Monads
21:31:27 <monochrom> Learning is a fixed point operation.
21:31:44 <Boney> not really.  I still don't quite get how monads solve the "IO impossible in a pure langage" problem.
21:31:53 <sorear> they don't
21:31:59 <sorear> haskell doesn't do IO
21:32:11 <sorear> it build descriptions of how to do IO later
21:32:28 <Boney> sorear: ohh, so it's got to do with the lazy evaluation.
21:32:29 <Boney> ?
21:32:29 <monochrom> my view is: monads alone don't, but monads plus something else do.
21:32:32 <mauke> Boney: no
21:32:47 <Boney> ok, I'll stop guessing..
21:32:57 <mauke> Boney: instead of doing I/O yourself, you construct a data structure that describes the IO action you need
21:33:16 <mauke> then you give that structure to an "IO interpreter" that executes it for you
21:34:09 <sorear> Boney: internally, GHC uses an ad-hoc, informally specified, bug ridden, slow implementation of half of uniqueness types to do IO.  IO Monads are a safe clean abstraction layer over that.
21:34:46 <sorear> am I missing an adjective?
21:34:50 <Boney> so main evaluates to a sequence of IO instructurctions, and other calculations..  so something evals() main, gets this sequence then runs it..?
21:34:52 <glguy_> are you playing off of greenspuns 10th law?
21:34:55 <glguy_> ths*
21:34:59 <mauke> Boney: yes
21:35:24 <sorear> glguy_: I'm playing off the one that ends "Common Lisp", dunno who to attribute to.
21:35:25 <mauke> Boney: the trick is that this I/O structure contains callbacks into pure haskell code
21:35:31 <emu> "clean" abstraction layer hmm
21:35:56 <timthelion> I am attempting to learn haskell.  I have read in 3 different places that haskell is hard to debug, this does not make sence to me, I thought that the whole point of a purely functional language was its extream eas in debuging.  Can someone explain why this is not the case?
21:36:13 <emu> haskell is not hard to debug
21:36:27 <mauke> timthelion: laziness means unpredictable evaluation order, which means no stack backtrace
21:36:38 <Boney> Ok.  well that clears that up a bit better.
21:36:41 <timthelion> oh. no stack backtrace
21:36:46 <sorear> haskell has a lot of features that make debugging simple things very easy, eg an interpreter, Show/Read, QuickCHeck, etc.
21:36:53 <timthelion> yes that would make for some difficulties
21:37:09 <sorear> but for really hard stuff there is no step debugger and no clear way to write one
21:37:23 <timthelion> because it is a non-linear language
21:37:30 <sorear> exactly...
21:38:10 <monochrom> hard to debug in the tradition sense (e.g. "get me the stack trace"). easy to debug in some new sense, but tool support is preliminary.
21:38:15 <timthelion> can't one separate terms, and then say how did this value come about though?
21:38:28 <sorear> I wonder how many of the things cited in Linus' rant about the evils of debuggers and why he will do everything he can to defeat the creation of a Linux kdb, apply to Haskell.
21:38:48 <monochrom> Yes timthelion, precisely like that, but tool support is preliminary
21:38:54 <timthelion> huh? evil debugers?
21:39:11 <emu> debuggers from hell!
21:39:16 <monochrom> OK! Linus has offended both the formal methodists and the debuggists!
21:39:20 <sorear> from what I've read Linus thinks debuggers are evil.
21:39:34 <emu> he's a bug-sympathizer
21:39:47 <Boney> he also wrote a monolithic kernel.  *duck*
21:40:02 <monochrom> (Linus also said formal specifications are useless. :) )
21:40:30 <timthelion> I think linus is a rather full of himself jerk myself, I mean who else names a kernel after themselves and claims to be the father of OS movement
21:40:30 <monochrom> So now I wonder what is *his* silver bullet...
21:40:38 <Boney> I'd still prefer to work with Linus than RMS or some of the other people I've met.  He's so much more easy-going.
21:40:51 <nrb23> > Data.List.Utils.uniq "Mississippi"
21:40:52 <lambdabot>   Not in scope: `Data.List.Utils.uniq'
21:40:56 <nrb23> sadness
21:41:16 <monochrom> > Data.List.uniq
21:41:16 <nrb23> debuggers aren't evil!
21:41:18 <lambdabot>   Not in scope: `Data.List.uniq'
21:41:21 <mauke> timthelion: he named the thing "freax"
21:41:28 <nrb23> uniq is from MissingH
21:41:37 <monochrom> I see.
21:41:44 <nrb23> was gonna try quickcheck on nub == uniq
21:42:01 <nrb23> also, debuggers aren't evil!
21:42:20 <sorear> he also doesn't use Haskell.
21:42:31 <mauke> Torvalds originally used the Minix OS on his system which he replaced with the Linux OS. He first named it Freax (a combination of "free", "freak", and the letter X to indicate that it is a Unix-like system), but his friend Ari Lemmke, who administered the FTP server where the Linux kernel was first hosted for downloading, gave Torvalds a directory called linux.
21:42:32 <sorear> my original comment was related to haskell.
21:43:26 <nrb23> it seems one could write a decent debugger for haskell
21:43:48 <nrb23> it just wouldn't look like gdb
21:43:56 <pizza_> i thought freax was free + ax register
21:43:59 <nrb23> but, gdb kinda sux, so anway
21:44:10 <monochrom> ghci is getting one.  you attach breakpoints to subexpressions.
21:44:10 <sorear> ah.  back on topic.  I feel so much better.
21:44:13 <timthelion> I like gdb it looks nice in dejavu sans mono
21:44:25 <nrb23> gdb sux
21:44:28 <monochrom> "w00t subexpression #5 is about to be forced!"
21:44:30 <nrb23> a lot
21:44:54 <nrb23> MULTI is where it's at ;->
21:44:58 <timthelion> most things look nice in dejavu sans mono
21:45:12 * monochrom looks nice in dejavu sans mono
21:45:22 <nrb23> Time Machine too
21:45:46 * sorear thinks Time Machine looked best in aged steel-printed paper
21:46:06 <nrb23> http://www.ghs.com/products/timemachine.html
21:46:09 <lambdabot> Title: TimeMachine debugger for embedded systems - Green Hills Software
21:47:07 <monochrom> If I make a debugger, I'll call it "parallel universe" rather than "time machine".
21:47:37 <nrb23> time machine isn't quite a debugger.. you can run *backwards* as well as forwards
21:47:54 <nrb23> it's more of an integration into the MULTI debugger
21:48:42 <fantasma> if i put a block comment into a line comment does the compiler recoginize the block comment?
21:48:56 <monochrom> Like what?
21:49:14 <fantasma> for example~~~ -- hello (- inside block
21:49:16 * monochrom resists the temptation to guess
21:49:33 <nrb23> doesn't look it
21:49:33 <fantasma> and the block ends in a few lines
21:49:44 * monochrom asks ghc
21:50:16 <monochrom> It is not recognized.
21:50:29 <fantasma> ok :)
21:50:31 <fantasma> thanks
21:50:36 <nrb23> which makes sense to me
21:51:05 * sorear goes back to VTY!
21:51:42 <nrb23> VTY?
21:52:13 <monochrom> video tape youtube
21:52:22 <nrb23> ?
21:52:32 <monochrom> I'm just joking
21:52:58 * nrb23 is watching Buffy The Vampire Slayer with his wife
21:53:01 <sorear> my current project, which has *grr* *grr* achieved a significant amount of name recognition
21:53:04 <sorear> ie not IRC
21:53:15 <monochrom> I'll try looking for it
21:54:48 <monochrom> http://www.haskell.org/pipermail/haskell/2007-February/019121.html
21:54:48 <nrb23> ahh, looks neat
21:54:50 <lambdabot> Title: [Haskell] ANN: Vty 3.0.0, http://tinyurl.com/29rt9s
21:55:18 <mauke> (Monad m3, Monad m2, Monad m1, Monad m) => (m1 (m a1) -> m3 (m2 a) -> t) -> m1 a1 -> t
21:55:22 <mauke> guess what function this is :-)
21:55:24 <sorear> if you really wanted to know it's in @where :)
21:55:39 <sorear> hmm
21:55:45 * sorear ponders
21:56:15 <sorear> it involves fail (or forever), I can say that much
21:56:31 <mauke> right
21:59:08 <sorear> @ty \g -> \x -> g (liftM return x) (return (fail "foo"))
21:59:08 <sorear> @botsnack
21:59:09 <sorear> lag o lag o lag o lag
21:59:10 <sorear> la la la
21:59:11 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) a (m3 :: * -> *) t. (Monad m, Monad m1, Monad m2, Monad m3) => (m1 (m a1) -> m3 (m2 a) -> t) -> m1 a1 -> t
21:59:12 <lambdabot> :)
21:59:12 * sorear curses lag
21:59:14 <sorear> lag--
21:59:16 * sorear goes back to hacking
21:59:18 <sorear> @botsnack
21:59:19 <lambdabot> :)
21:59:31 <mauke> I think you win
21:59:43 <mauke> optional c p = liftM return p `c` return (fail "optional: no match")
22:00:03 <nrb23> ?where vty
22:00:03 <lambdabot> http://members.cox.net/stefanor/vty/
22:01:05 * sorear has studied the ways of the great Djinn
22:08:23 <nrb23> sorear: vty looks neat ;->
22:10:38 <sorear> don't get too excited
22:11:09 <sorear> it's almost unfixably slow, and it depends for survival on the fact that non-VT100-compatible terminals simply no longer exist
22:11:17 <nrb23> :->
22:14:00 <mauke> (Monad m) => (t -> m a -> t1) -> a -> t -> t1
22:14:33 <mauke> nah, too easy
22:15:08 <monochrom> that is too easy :)
22:15:17 <timthelion> um, how does one exit ghci?
22:15:28 <monochrom> :quit
22:15:55 <timthelion> where's the start of that list ;)
22:15:56 <bd_> :q or ^D
22:17:15 <mauke> what list?
22:17:52 <mauke> @hoogle (a -> m a1 -> m a1) -> [a] -> m a1
22:17:53 <lambdabot> Did you mean: (a -> m A1 -> m A1) -> [a] -> m A1
22:17:53 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
22:17:53 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
22:19:18 <goltrpoat> is there an idiomatic way to express a VM based around a set of 32 bit integer and float registers?  i think i know the answer to that, but i'm rather disliking the number of unsafeCoerce calls i end up with
22:19:46 <monochrom> ?type foldl1
22:19:48 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
22:19:54 <monochrom> ?type foldl
22:19:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:20:05 <goltrpoat> think a heap where 'dword ptr [addr]' can be used as a source argument to either a floating point or integer operation.
22:20:21 <mauke> Ptr CChar
22:20:30 <goltrpoat> yeah.  trouble is, that puts me in IO
22:21:06 <mauke> a stateful array of bytes?
22:21:23 <goltrpoat> when executing, yes
22:21:37 <goltrpoat> (words, but bytes works)
22:21:45 <monochrom> ?type \mop xs -> foldr mop (fail "whatever") xs
22:21:47 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1 -> m a1) -> [a] -> m a1
22:22:14 <sorear> if it is stateful, what are you doing NOT in IO?
22:22:24 <sorear> ST will also do
22:22:33 <sorear> but don't lie and say it is pure
22:22:40 <sorear> that way lies madness
22:22:41 <goltrpoat> the reason i'd prefer it to not be in IO is that i'd like a nice clean execProgram code call.
22:22:58 <sorear> goltrpoat: then use ST, and runST
22:23:00 <goltrpoat> the VM is there to facilitate me playing around with code generation, so the more transparent it is, the better.
22:23:31 <sorear> goltrpoat: oh, if you're using a VM and all that unsafe trickery unsafePerformIO and the FFI might be better *grin*
22:23:49 <goltrpoat> FFI actually does seem cleaner at this point, which disturbs me.
22:23:49 <goltrpoat> :)
22:23:54 <sorear> goltrpoat: eg Data.ByteString uses Ptr CChar and unsafePerformIO *liberally*
22:24:00 <goltrpoat> -nod-
22:24:16 <sorear> goltrpoat: the scariest thing for me ... I've lost my fear of malloc/free.
22:24:32 <goltrpoat> in what sense?
22:24:39 <sorear> Foreign.Marshal.Alloc that is, I think I'll still avoid the ones in stdlib.h
22:24:44 <goltrpoat> ah.
22:25:30 <goltrpoat> i've been avoiding Foreign like the plague, unless i'm doing FFI or this crazy semi-typed bullshit i'm doing right now
22:25:55 <sorear> unsafePerformIO doesn't mean "don't use", it means "think first".
22:26:02 <goltrpoat> certainly
22:26:04 <sorear> You are smarter than the compiler.
22:26:31 <mauke> then why does the compiler find type errors in my code? :(
22:26:32 <sorear> Haskell's type system is very weak, in the sense of logic (it can't prove much)
22:26:46 <goltrpoat> well, the weaker the logic the more guarantees
22:27:01 <goltrpoat> i think a number of people would have preferred to have weaker logics in the type system
22:27:22 <goltrpoat> wrong direction as far as my issue goes, though :)
22:27:34 <sorear> since your brain can operate in the full ZFC maths, you can write a larger class of programs while retaining safety if you give up on compiler-enforced saftey.
22:28:06 <goltrpoat> i'm not sure i follow, there.
22:28:21 <goltrpoat> we don't really have ZFC in the type system.
22:28:32 <goltrpoat> be nice.
22:29:28 <goltrpoat> if we had that, i mean.  dependent types are a first principles type pre-requisite there though.
22:29:35 <goltrpoat> unless i'm missing something.
22:29:39 <sorear> so every program that can be proved correct using ZFC but not HM needs unsafeCoerce# or similar to express
22:29:47 <goltrpoat> oh right.
22:30:14 <monochrom> I operate full simply-typed lambda calculus.
22:30:44 <sorear> simply typed lc is waaay to weak.  it can't even express id.
22:31:04 <goltrpoat> ?
22:31:07 <monochrom> What I mean is hol.sf.net
22:31:13 <sorear> I need at least first order polymorpgism
22:31:29 <monochrom> Full stratefied higher-order logic.
22:31:45 <monochrom> It contains something stronger than the axiom of choice.
22:31:57 <goltrpoat> wha.
22:32:15 <monochrom> It is also higher-order, so it's even less decidable than first-order ZFC. :)
22:32:31 <sorear> goltrpoat: the axiom of omega is certainly stronger than the AoC :)
22:32:38 <goltrpoat> oh that.
22:33:24 <sorear> it also renders your logic fairly useless
22:33:37 <goltrpoat> always a good thing.
22:34:21 <monochrom> To be frank, I have only used fourth-order.
22:38:53 <JoshTriplett> While playing with HOpenGL, I found the following definition useful:
22:38:53 <JoshTriplett> bracket__ open close = bracket_ open (\_ -> close)
22:38:53 <JoshTriplett> This allows cleanup functions that don't need the result of the init function.  Would that make a reasonable addition to the IO module?
22:38:57 <goltrpoat> anyway, 2.5 years or so with haskell, and that was the first time i actually went.. wait.  i can't do this.. cleanly?  and.. in a pretty manner?  with flourish?
22:39:26 <monochrom> It is in Control.Exception
22:40:06 <goltrpoat> wasn't there a bracket_ around somewhere
22:40:30 <monochrom> It is in Control.Exception
22:40:32 <JoshTriplett> goltrpoat: Yeah, IO has bracket_
22:40:45 <sorear> goltrpoat: I'ven't been here a whole year yet ... and people are already telling me "your code is too slow".  Fine, I tasted FFI abuse ... and haven't been able to let go.  Muahahaha.
22:41:05 <goltrpoat> heheh
22:41:21 <JoshTriplett> monochrom: Huh.  Control.Exception.bracket_ != IO.bracket_.  Odd.
22:41:33 <goltrpoat> i write performance code for a living, so i figure i can make do with my haskell code not being the fastest thing on the block for now
22:41:47 <saddev> don't you think Haskell is lacking a good easy and fast to read tutorial for programmers who are not mathematicians but know how to develop in other languages? I mean, something that doesn't introduce the Hello World at the 11th chapter and starts the first chapter with Abelian groups?
22:41:53 <sorear> monochrom: not odd at all.
22:41:55 <sorear> er,
22:42:00 <sorear> JoshTriplett: not odd at all.
22:42:19 <goltrpoat> saddev:  that's something i mentioned a little while back.  there does seem to be a bit of a disconnect there.
22:42:20 <monochrom> In what sense are they != ?
22:42:33 <sorear> JoshTriplett: haskell98 provides IO.bracket_ etc, and also stipulates that error generates an uncatchable exception.
22:42:40 <JoshTriplett> monochrom: They have different types, and thus different semantics.
22:42:42 <nornagon> monochrom: Control.Exception.bracket_ catches more things, so i'm told.
22:43:01 <sorear> JoshTriplett: so when we added a catch that *could* catch error calls, we had to give it a different name, for compatability.
22:43:15 <JoshTriplett> sorear: Yeah, but why a different type?
22:43:27 <JoshTriplett> sorear: Why not make bracket and bracket IO-compatible?
22:43:36 <saddev> goltrpoat: I program in 3 other languages and I picked them up in less than a week each. Last time I attempted Haskell I've spent a month and I still feel like I don't know anything about it.
22:43:40 <sorear> @type IO.bracket
22:43:43 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:43:44 <monochrom> ?type IO.bracket_
22:43:47 <lambdabot> forall a b c. IO a -> (a -> IO b) -> IO c -> IO c
22:43:51 <sorear> @type Control.Exception.bracket_
22:43:54 <lambdabot> forall a b c. IO a -> IO b -> IO c -> IO c
22:44:02 <sorear> that's really odd
22:44:15 <fantasma> its easier to learn haskell when you dont know any languages to begin with saddev
22:44:17 <JoshTriplett> sorear: All three seem useful.
22:44:41 <JoshTriplett> sorear: Having two confusingly incompatible ones with the same name, not so much. :)
22:45:36 <goltrpoat> saddev:  it takes some time to get to a point where you're comfortable with it.  the analogy i used a while back was that if a c++ programmer learning java is like an english speaker learning french, then a c++ programmer learning haskell is like an english speaker learning to ride a bike.
22:45:43 <saddev> fantasma: I actually found many things that made me say "Oh, I wish Python had this", but then I'm unable to really GET the language in a reasonable amount of time (and I don't want to invest 6 months just to get the basics)
22:45:51 <goltrpoat> takes a little while, but once you "get it", it quickly becomes indispensible.
22:46:06 <saddev> goltrpoat: funny analogy
22:46:35 <saddev> I guess there is no shortcut, eh
22:46:48 <JoshTriplett> goltrpoat: I've actually heard a similar analogy, with the last part as "then a C programmer learning Haskell is like an English speaker learning ... Haskell." :)
22:46:50 <timthelion> so what is it that I have to do to get rid of the error hi.hs:2:30: Not in scope: `Char.isUpper'
22:46:53 <timthelion> in ghc
22:46:59 <goltrpoat> josh:  haha nice
22:47:04 <timthelion> when making hi.hs
22:47:19 <JoshTriplett> timthelion: import Char?
22:47:19 <sorear> timthelion: add 'import Char'
22:47:20 <monochrom> I knew 7 languages before Haskell.  Took me two years.
22:47:23 <fantasma> i've just started learning haskell today and I dont see how ive been using imparative languages
22:47:26 <sorear> timthelion: at the very top
22:48:15 <fantasma> i was able to calculate the # of digits in the nth fibonacii with 1 line :)
22:48:34 <JoshTriplett> sorear: You mentioned that IO's brackets don't catch some things due to the definitions of the standard; could haskell' perhaps change that, so that the built-in bracket catches more things?
22:48:35 <saddev> I tried to read A Gentle Introduction to Haskell 98. But i was too distracted by one thought in my mind... This thought was more or less "gentle... gentle my ass". :-)))
22:48:41 <goltrpoat> one thing about haskell is that it's very good at pointing out exactly what it is that you're missing.  but the issue is that it keeps doing that.  for years.
22:48:49 <goltrpoat> and then, years later, you go, uh..  oh, ok, i get it.
22:49:08 <xpika> saddev: try YAHT its my fav haskell 98 tutorial
22:49:13 <goltrpoat> huge amounts of fun in the meantime, though.
22:49:20 <monochrom> I am able to factor 31337 into its prime factors in one line.
22:49:25 <monochrom> > 31337
22:49:27 <lambdabot>  31337
22:49:34 <monochrom> That's the line.  31337 is prime.
22:49:39 <fantasma> i know
22:49:40 <JoshTriplett> monochrom: We got it. :)
22:49:40 <fantasma> lol
22:49:44 <Slarba> haha
22:49:47 <saddev> > YAHT
22:49:48 <lambdabot>   Not in scope: data constructor `YAHT'
22:49:53 <saddev> > @YAHT
22:49:54 <lambdabot>  Parse error
22:49:54 <mauke> @where yaht
22:49:55 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
22:49:57 <fantasma> and 1337 is divisible by???
22:50:04 <saddev> mauke: thanks.
22:50:10 <xpika> @elite 31337
22:50:10 <lambdabot> 31337
22:50:16 <xpika> @elite elite
22:50:17 <lambdabot> eli7E
22:50:26 <saddev> I may give Haskell another shot
22:50:27 <timthelion> is there any way I can make this main = putStrLn (foldr (++) "" (map show (map Char.isLower "aBCde"))) less pareny?
22:50:34 <timthelion> it looks almost like lisp
22:50:35 <saddev> and then maybe write my own easy going tutorial :-P
22:50:57 <fantasma> timthelion, that's an excercise in the haskell tutorial!
22:51:09 <timthelion> fantasma yes it is
22:51:11 <JoshTriplett> > filter ((==0). (mod 1337)) [1..1337]
22:51:13 <lambdabot>  [1,7,191,1337]
22:51:19 <JoshTriplett> fantasma: ^
22:51:21 <siti> saddev: another haskell tutorial would rock :)
22:51:32 <saddev> on another subject, is WASH production ready for Web application development? I use Django a lot so far.
22:51:36 <siti> I could never really find any good ones when I first started
22:52:10 <fantasma> tim what page in the pdf is the question on?
22:52:29 <mauke> timthelion: main = putStrLn (concatMap (show . isLower) "aBCde")
22:52:44 <mauke> timthelion: main = putStrLn . concatMap (show . isLower) $ "aBCde"
22:53:00 <monochrom> mauke beats me.
22:53:17 <encryptio> what's the reason behind not being able to catch errors outside the IO monad?
22:53:25 <encryptio> exceptions*
22:53:41 <monochrom> some pure-functional reasons
22:53:43 <sorear> encryptio: unpredictable evaluation order, and referential transparency
22:53:54 <fantasma> > let mult a b = a + mult a (b-1) in mult 4 3
22:53:58 <lambdabot> Terminated
22:54:09 <monochrom> base case
22:54:10 <JoshTriplett> fantasma: Base case? :)
22:54:14 <sorear> encryptio: referential transparency means that forall x.  x is the same as x, even if the occurences are in a different place
22:54:22 <timthelion> fantasma 30
22:54:22 <fantasma> JoshTriplett, ah forgot it just a sec!
22:54:30 <fantasma> timthelion, thanks :)
22:54:31 <monochrom> Hey!  We have a handful of novices here!  Let me confuse them!
22:54:34 <sorear> encryptio: e.g. getClockTime would violate this if not in IO (you see how?)
22:54:43 <monochrom> > let 1+2 = 10 in 1+2
22:54:45 <lambdabot>  10
22:54:47 <encryptio> i know about monadic IO...
22:54:55 <sorear> encryptio: this is considered a very desirable property of haskell...
22:54:56 <goltrpoat> monochrom:  quick!  modal logic to the rescue!
22:55:07 <fantasma> that does not confuse
22:55:09 <encryptio> but yes, i understand now why exceptions are IO monad only
22:55:13 <goltrpoat> damn.
22:55:16 <sorear> encryptio: now, since evaluation order is unspecified...
22:55:19 <goltrpoat> foiled again.
22:55:19 <monochrom> "parallel universe" is the name of my debugger
22:55:29 <saddev> how do i install Haskell on Ubuntu? Should I go for GHC or for Hugs?
22:55:35 <fantasma> monochrom, by doing that your just modifying the "+" function yes?
22:55:36 <sorear> GHC
22:55:38 <mauke> I prefer ghc
22:55:42 <JoshTriplett> saddev: "yes".
22:55:54 <sorear> it's fairly old on Ubuntu (6.4.2), but still better than hugs
22:55:55 <encryptio> saddev: ghc if possible. hugs if not.
22:56:08 <monochrom> can't say "modify".  but redefine and shadow the original one, sure.
22:56:10 <mauke> fantasma: it doesn't modify the existing (+) function
22:56:20 <fantasma> copies it into a new version?
22:56:22 <monochrom> > let 1+2=10 in 1+1
22:56:22 <saddev> I heard that compiling GHC from source it will take me forever
22:56:23 <lambdabot>   Non-exhaustive patterns in function +
22:56:27 <saddev> is it true?
22:56:27 <sorear> encryptio: > pureTry (error "a" + error "b")  -- what would this return?
22:56:30 <mauke> fantasma: no copying
22:56:35 <JoshTriplett> fantasma: No, just makes a new function +.
22:56:38 <siti> about 1 hour on a dual proc machine for me
22:56:46 <encryptio> sorear: aha.
22:56:47 <goltrpoat> compiling GHC from source took me damn near a day.
22:56:52 <monochrom> So the local + is from scratch.
22:56:55 <sorear> saddev: 90m on a 1proc machine
22:56:56 <goltrpoat> that's not really an issue though.
22:57:08 <sorear> saddev: infact I just did it
22:57:09 <siti> I think dons on a 16 processor machine has got it down to 6mins but that's with no optomizations iirc
22:57:17 <goltrpoat> nuts
22:57:18 <encryptio> 6 hours here, double compilation on an 867MHz G4.
22:57:26 <sorear> saddev: I finished building GHC about 10minutes ago.
22:57:30 <monochrom> Hey novices!  I have another trick!
22:57:37 <fantasma> lol
22:57:38 <monochrom> > let 1 = 2+2 in 2+2
22:57:39 <lambdabot>  4
22:57:41 <saddev> sorear: is it worth installing it from source?
22:57:57 <fantasma> shut up monochrom you were a novice once yourself :P
22:58:03 <sorear> saddev: probably not, unless you want the latest and greatest features
22:58:08 <encryptio> saddev: depends. how expensive is your idle processing time?
22:58:18 <sorear> saddev: eg you only get a debugger if you install from source
22:58:19 <monochrom> I mean it in a friendly way.
22:58:20 <siti> if you want to use fiesty you will get ghc 6.6 and other goodies :)
22:58:31 <goltrpoat> > let l = 1234+4321 in 2+2
22:58:33 <lambdabot>  4
22:58:38 <monochrom> I'll try "hey kids" next time.
22:58:44 <saddev> is it just ./configure && make && make install as usual?
22:58:48 <JoshTriplett> monochrom: Better to give examples when they come up, rather than just dropping them out of the blue.
22:58:54 <sorear> saddev: autoreconf first
22:58:55 <fantasma> > let mult a 0 = 0; mult a b = a + mult a (b-1) in mult 4 3
22:58:56 <lambdabot>  12
22:59:01 <fantasma> woot
22:59:05 <fantasma> > let mult a 0 = 0; mult a b = a + mult a (b-1) in mult 1 3
22:59:06 <lambdabot>  3
22:59:11 <monochrom> @quote Syzygy
22:59:11 <fantasma> > let mult a 0 = 0; mult a b = a + mult a (b-1) in mult 0 3
22:59:12 <lambdabot> No quotes match. Wrong!  You cheating scum!
22:59:12 <lambdabot>  0
22:59:13 <saddev> 11 October 2006 realease right?
22:59:15 <monochrom> @quote Syzygy-
22:59:16 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
22:59:24 <monochrom> @quote Syzygy-
22:59:25 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
22:59:29 <monochrom> @quote Syzygy-
22:59:30 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
22:59:37 <bos> @hoogle forever
22:59:37 <lambdabot> No matches found
22:59:37 <sorear> saddev: if you have a release .tar.gz you don't need to autoreconf, but if you're not going HEAD there's not much point in coming from source
22:59:40 <monochrom> OK, I can't find what I want.
22:59:45 <fantasma> i did it, i multiplied numbers!
23:00:05 <JoshTriplett> bos: Looking for something in particular?
23:00:29 <sorear> bos: repeatM
23:00:32 <bos> JoshTriplett: forever is in Control.Monad in the darcs head of base, but not ghc 6.6
23:00:33 <sorear> bos: fix.(>>)
23:00:39 <fantasma> is it possible to do division recursively
23:00:40 <sorear> bos: short enough?
23:00:45 <bos> sorear: :-)
23:00:46 <sorear> fantasma: of course!
23:00:57 <fantasma> dont write the code!
23:01:02 <fantasma> :)
23:01:07 <saddev> sorear: I see what you mean. To learn, is it better going with HEAD, the tar.gz 6.6 or the ubuntu deb package 6.4.2?
23:01:32 <siti> well you don't really need the features in ghc 6.6
23:01:33 <JoshTriplett> saddev: For learning purposes, one of the latter two, most likely the deb.
23:01:35 <sorear> saddev: 6.4.2. anything later than 3.0 or so will get you haskell98
23:01:53 <sorear> saddev: 6.4.2 is likely to get you the least "fun"
23:02:07 <siti> they come in useful when you are making gtk apps in haskell, using a debugger and other nifty features
23:02:47 <sorear> drum roll...
23:02:47 <monochrom> I know how to do division recursively.  To divide x by y, search through 0*y, 1*y, 2*y, ... until you find n*y == x.
23:02:49 <sorear> stefan@stefans:/usr/local/src$ ghc -V
23:02:49 <sorear> Segmentation fault
23:02:49 <sorear> stefan@stefans:/usr/local/src$
23:02:52 <saddev> killer. I'll get the stable 6.6 from source for this time, then one day I'll go pro with the source code from head. :-) And any good Linux editor for Haskell?
23:03:05 * monochrom high-fives ghc
23:03:16 <sorear> saddev: vim and emacs both have good support
23:03:19 <mauke> No instance for (...) arising from is bound by the instance declaration at pp.hs:154:8
23:03:22 <mauke> wtf?
23:03:27 <monochrom> I like vim, emacs, and eclipse.
23:03:28 <goltrpoat> kdevelop has decent support as well.
23:04:04 <saddev> sorear: does the Eclipse plugin have good support for it? I'm not too much into Vim and Emacs (maybe I should get into it)
23:04:20 <monochrom> not very good.
23:04:28 <siti> it works but not that well
23:04:30 <goltrpoat> most of eclipse is "not very good," though.
23:04:34 <siti> it is basically a nice editor
23:04:41 <sorear> saddev: Eclipse? don't expect me to say anything good about any X-requiring program.
23:04:47 <siti> that's with the eclipse-fp plugin
23:05:05 <sorear> saddev: the ONLY such programs I use are xpdf, ghostview, and firefox.  Hate all three.
23:05:06 <monochrom> eclipse doesn't require X.  just use XP.  XD
23:05:10 <siti> sorear: stop being silly eclipse rocks :p
23:05:17 <saddev> sorear, siti: and what does Vim do in terms of Haskell support?
23:05:27 <sorear> highlighting!
23:05:29 <goltrpoat> saddev:  if you have a windows machine with visual studio on it, then vshaskell is quite nice, btw.
23:05:35 <sorear> same thing it does for every language!
23:05:35 <siti> I don't use vim I hate it
23:05:37 <fuzan> @src until
23:05:38 <lambdabot> until p f x | p x       = x
23:05:38 <lambdabot>             | otherwise = until p f (f x)
23:05:39 <siti> I hate emacs too :)
23:05:49 <goltrpoat> otherwise, there's a number of editors with haskell syntax highlighting, and some of them care about packaging.
23:06:01 <saddev> goltrpoat: I do. That's something good for when I'm stuck on Windows.
23:06:03 <siti> I like sane gui editors, well I have always been a mouse user, fps games rock :p
23:06:11 <sorear> emacs (with beschmi's shim package) supports highlighting, type lookup, two-key hoogling, go-to-next-type-error, ...
23:06:14 <sorear> beschmi++
23:06:44 <fuzan> but for some reason it's "cool" to hate emacs and adore vim.
23:06:56 <siti> I hate both, :p
23:06:59 * sorear is uncool
23:07:00 <fuzan> i think it's due to motif, which no longer exists in my emacs :)
23:07:16 <sorear> fuzan: I use emacs-nox, always have, always will.
23:07:24 <fuzan> emacs-nox?
23:07:35 <fuzan> ah, no x
23:07:52 * sorear loathes GUIs
23:07:57 <fuzan> heh, i do like using my mouse.
23:08:07 <fuzan> you can remove the ui elements in the regular x.
23:08:08 <sorear> I use my mouse too.
23:08:08 <fantasma> sorear, can recurisive division be done with only + and -
23:08:15 <sorear> fantasma: easily!
23:08:17 <saddev> I shall be back guys. I go to install from source.
23:08:32 <fantasma> sorear, whats the algorithm
23:08:40 <goltrpoat> i just don't get it.. i honestly hope some day to figure out what the point is.  i spent years in vi, these days it just seems like a mediocre editor that i'm glad to be away from
23:09:08 <fantasma> goltrpoat, what do you use instead?
23:09:18 <goltrpoat> really depends
23:09:24 <monochrom> To divide x by y, you can search through 0, 0+y, 0+y+y, 0+y+y+y, ... until you hit x.
23:09:31 <sorear> > let divi b l | b < 0 = (-1) + divi (b+l) l | b >= l = 1 + divi (b-l) l | True = 0 in divi 100 3
23:09:32 <lambdabot>  33
23:09:33 <bd_> monochrom: or overshoot? :)
23:09:43 <sorear> > let divi b l | b < 0 = (-1) + divi (b+l) l | b >= l = 1 + divi (b-l) l | True = 0 in divi (-12) 3
23:09:45 <lambdabot>  -4
23:09:51 <monochrom> Oh you can also search through x, x-y, x-y-y, x-y-y-y, ... until you get too close to 0.
23:09:54 <sorear> > let divi b l | b < 0 = (-1) + divi (b+l) l | b >= l = 1 + divi (b-l) l | True = 0 in divi 999999 7
23:09:56 <goltrpoat> msvc, textpad, kdevelop.  gedit/wordpad/vi for quick editing.
23:09:56 <lambdabot>  142857
23:10:17 <fantasma> you should try jed :)
23:10:18 <sorear> actually, you can make divi exponentially faster
23:10:22 <sorear> that is the hint
23:10:34 <goltrpoat> i haven't tried jed, good point there.
23:10:40 <monochrom> I like suggesting dumb ideas :)
23:11:03 <goltrpoat> or.. haven't tried it in development, anyway.
23:13:19 <siti> oh yeah kdevelop has haskell support does it not?
23:13:24 <goltrpoat> yeah
23:13:29 <siti> is it any good?
23:13:33 <siti> better than eclipse?
23:13:42 <sorear> AAAAHHH!
23:13:44 <fantasma> eclipse 0.o
23:13:47 <goltrpoat> it could be better.  i don't know what the haskell support is like in eclipse
23:14:00 <sorear> I just wasted a whole hour compiling GHC with a b0rken ghc.
23:14:01 <goltrpoat> honestly, i hate eclipse, due to a few months of j2me experience with it
23:14:32 <siti> ok it's basically simple build support, + outline, syntax highlighting
23:14:38 <fantasma> eclipse is great if your working for java, i would imagine it sucks if your working with anything else
23:14:42 <goltrpoat> siti:  correct
23:15:01 <siti> well I hate java but I like eclipse, also java is not as bad when you have eclipse :p
23:15:06 <goltrpoat> fantasma:  it just seemed incredibly clunky.
23:15:26 <fantasma> goltrpoat, it is, mainly because it's written in java
23:15:26 <goltrpoat> i ended up writing my java code in msvs and using a custom build step to package it
23:15:33 <goltrpoat> correct.
23:15:49 <siti> stuff like you hold down control and click any class/method/variable and it's like browsing your source code
23:15:54 <timthelion> main = putStrLn (foldr (++ " "++) (map (show)(foldr (max) 0 [5,10,2,8,1] ))) hmm?  hi.hs:2:32: parse error on input `)'
23:16:08 <mauke> (++ " " ++) looks invalid
23:16:20 <siti> curring?
23:16:28 <timthelion> ok
23:16:39 <goltrpoat> tim:  one too many )s
23:16:49 <mauke> putStrLn (concat (intersperse " " (map show (foldr max 0 [5,10,2,8,1]))))
23:16:51 <timthelion> so I can't just put an expression in place of a function? why not
23:17:18 <mauke> @type (++ " " ++)
23:17:21 <lambdabot> parse error on input `)'
23:17:36 <timthelion> oh
23:17:46 <mauke> @pl \x y -> x ++ " " ++ y
23:17:47 <lambdabot> (. (' ' :)) . (++)
23:17:49 <timthelion> ((++) "" (++))?
23:18:14 <goltrpoat> scratch that
23:18:22 <fantasma> > let div a 0 = 0; div a b = 1 + div (a-b) in div 10 5
23:18:22 <mauke> I'd use an explicit lambda (or intersperse)
23:18:23 <lambdabot>      Occurs check: cannot construct the infinite type: t = a -> t
23:18:23 <lambdabot>     Probabl...
23:18:40 <goltrpoat> > map show (foldr max 0 [5,10,2,8,1])
23:18:41 <lambdabot>   add an instance declaration for (Num [a])
23:18:41 <lambdabot>     In the expression: 1
23:18:42 <mauke> fantasma: missing argument in call to div
23:18:44 <goltrpoat> that's broken
23:18:52 <goltrpoat> (at least)
23:19:11 <fantasma> mauke, what?
23:19:14 <goltrpoat> what are you trying to do with foldr max?
23:19:33 <mauke> fantasma: 1 + div (a-b)
23:19:33 <fantasma> ohhhhhhhh
23:19:34 <fantasma> ok
23:19:54 <fuzan> hmm, I can't seem to think of an elegant method of randomizing a list by picking an element and cons'ing recursively. is it possible to do with a fold?
23:20:01 <fantasma> > let div a 0 = 0; div a b = 1 + div a b (a-b) in div 10 5
23:20:02 <lambdabot>      Occurs check: cannot construct the infinite type: t = a -> t
23:20:02 <lambdabot>     Probabl...
23:20:15 <fantasma> wait
23:20:18 <fantasma> no
23:20:35 <saddev> did any of you read Programming in Haskell by Graham Hutton? It looks like a sweet book.
23:20:52 <fantasma> > let div a 0 = 0; div a b = 1 + div (a-b) b in div 10 5
23:20:55 <lambdabot>  Exception: stack overflow
23:21:07 <fantasma> > let div 0 b = 0; div a b = 1 + div (a-b) b in div 10 5
23:21:08 <mauke> infinite loop
23:21:08 <lambdabot>  2
23:21:29 <fantasma> > let div 0 b = 0; div a b = 1 + div (a-b) b in div 9 0
23:21:31 <lambdabot>  Exception: stack overflow
23:21:37 <fantasma> > let div 0 b = 0; div a b = 1 + div (a-b) b in div 9 3
23:21:38 <lambdabot>  3
23:21:42 <fantasma> nice
23:21:46 <timthelion> hmm, now I get no instance of (Num [a]) main = putStrLn (foldr (concatPairWithSpace) "" (map (show) (foldr (max) 0 [5,10,2,8,1] )))
23:22:07 <mauke> timthelion: yes, because map needs a list
23:22:12 <mauke> but foldr max returns a number
23:22:19 <timthelion> ok
23:22:20 <goltrpoat> fuzan:  a) write a function to take a list and shuffle it.
23:22:22 <siti> I think everyone has asked other peoples opinions of that book in here ;)
23:22:26 <timthelion> so all that effort is being wasted
23:22:33 <fantasma> if i was compiling this code for use, i would get rid of the "lets" correct?
23:22:38 <fuzan> goltrpoat: i can do it naively. i'm looking for an elegant solution though :)
23:22:39 <siti> from what I gathered it was a good begineer book but was expensive
23:22:40 <goltrpoat> fuzan:  this is actually nicer with an array, oddly enough (see ixmap)
23:22:51 <saddev> siti: and what was the overall outcome?
23:23:03 <saddev> siti: ok
23:23:51 <saddev> it's only 180 pages, it can't be complete
23:24:04 <monochrom> yes fantasma
23:24:31 <fantasma> thanks monochrom
23:26:43 * sorear is now building GHC.  Again.
23:26:50 <goltrpoat> fuzan:  where i was going with my "take a list and shuffle it" bit is that shuffling is well known, and the fact that the underlying container can be changed makes it an exercise in polymorphism
23:27:04 <fantasma> how come there are no binaries for ghc?
23:27:12 <fuzan> fantasma: there are.
23:27:29 <fantasma> why's he building it?
23:27:42 <fuzan> because some people like/have to.
23:27:52 <sorear> fantasma: because there are no binaries for HEAD
23:28:04 <goltrpoat> i had to install it because the version in debian main/stable is like.. 6.2.x
23:28:13 <goltrpoat> install = build
23:28:15 <fantasma> im not sure what that means atm, but hopefully I will soon enough :)
23:28:35 <fantasma> with reference to HEAD
23:28:37 <fuzan> goltrpoat: what exactly do you mean by the underlying container changing?
23:28:49 <monochrom> "There is already unix, why use windows?"  "because some people like to."
23:29:30 <fuzan> fantasma: it means that for the newest versions of GHC, there's no binary support
23:29:33 <sorear> fantasma: HEAD is the main development repo - the only way I could get new features faster is if my name was Simon
23:29:45 <siti> lol
23:30:05 <fantasma> simon = maintainer?
23:30:15 <goltrpoat> fuzan:  i guess i'm just saying that there's a fair bit of room to experiment with different containers, there.  class ShuffleableContainer a where shuffle :: a -> a; instance (Ord a) => ShuffleableContainer [a] where .. do your thing .. etc.
23:30:19 <sorear> fantasma: simon = maintainerS
23:30:31 <sorear> fantasma: Simon Marlow and Simon Peyton-Jones
23:30:45 <fantasma> haha coincidence
23:30:50 <fuzan> gotcha.
23:30:57 <sorear> fantasma: there's a running joke around here about the fact that the maints have the same first name.
23:31:20 <fuzan> Curry Haskell's real first name was Simon.
23:31:21 <sorear> "named Simon" generally means "GHC maintainer"
23:32:06 <fantasma> if Haskell's first name is really Simon then what's Curry?
23:32:24 <fuzan> His favorite food?
23:32:34 <mauke> fantasma: his last name
23:32:53 <monochrom> I like Japanese curry.
23:32:56 <fantasma> then whats haskell
23:33:05 <mauke> a programming language
23:33:06 <fuzan> His favorite language.
23:33:10 <fantasma> lol
23:33:15 <mauke> Simon "Haskell" Curry
23:33:19 <fantasma> oh
23:33:22 <fuzan> duh.
23:33:23 <fantasma> i see haha
23:33:34 <goltrpoat> clear potential for industrial espionage, there.  "halt!  what's your name?"  "er.. simon."  "oh.  so sorry, pass on through."  "little did you know, that my real name is simon m. holzenmeyer, and i am here to steal the secrets of the lambda!  you insult me and my family!  prepare to die!  hhmphf!"
23:34:12 <monochrom> You play wolfenstein too much
23:34:18 <goltrpoat> haha
23:34:22 <sorear> @remember goltrpoat clear potential for industrial espionage, there.  "halt!  what's your name?"  "er.. simon."  "oh.  so sorry, pass on through." "little did you know, that my real name is simon m. holzenmeyer, and i am here to steal the secrets of the lambda!  you insult me and my family!  prepare to die!  hhmphf!"
23:34:23 <lambdabot> Done.
23:34:49 <mauke> @quote simon
23:34:49 <lambdabot> goltrpoat says: clear potential for industrial espionage, there.  "halt!  what's your name?"  "er.. simon."  "oh.  so sorry, pass on through." "little did you know, that my real name is simon m.
23:34:50 <lambdabot> holzenmeyer, and i am here to steal the secrets of the lambda!  you insult me and my family!  prepare to die!  hhmphf!"
23:34:50 <monochrom> I love wolfenstein.  brings out my true nature.
23:34:51 <sorear> here and I thought that was a line from some mob film
23:35:48 <siti> do the simon's ever come in #haskell or do they prefer to get work done ;)
23:35:53 <fuzan> there's no way to do , let x = (magicalFoo) $ return 5
23:35:58 <monochrom> guard: "passport!"  (me shows stolen passport)  (guard lets me in, off-guard)  (me shoots guard)
23:36:07 <fuzan> some , f :: m a -> a
23:36:14 <fuzan> is therE?
23:36:31 <mauke> > let x = magicalFoo $ return 5; magicalFoo = head in x
23:36:32 <lambdabot>  5
23:36:34 <sorear> siti:
23:36:39 <sorear> @seen JaffaCake
23:36:40 <lambdabot> JaffaCake is in #haskell and #ghc. I last heard JaffaCake speak 17h 22m 23s ago.
23:36:45 <monochrom> I love betraying people :)
23:36:47 <sorear> Simon Marlow
23:36:47 <siti> sorear: yes :P?
23:36:58 <sorear> SPJ is here much less often.
23:37:03 <goltrpoat> monochrom:  you should play KOTOR then
23:37:14 <sorear> siti: JaffaCake is SimonMarlow
23:37:22 <timthelion> so does the lazy functionality mean that you can do the impossible and make an enumerable list of all prime numbers?
23:37:29 <sorear> yes!
23:37:43 <fantasma> its so much fun
23:37:46 <mauke> timthelion: wait until you see the time travel stuff
23:37:48 <timthelion> has anyone made a function that makes that list?
23:38:04 <monochrom> haskell-cafe is full of them lately.
23:38:05 <goltrpoat> it's popular with intro tutorials
23:38:14 <fantasma> wait a second, someone will code it right now in irc tim
23:38:21 <siti> well that's how fibonachi is done with that zipWith method...
23:38:32 <siti> and then you can just go take 1000 $ fibList
23:38:33 <sorear> > let sieve n (x:xs) = x:filter ((/=0) . (`mod` x)) xs in sieve [2..]
23:38:35 <lambdabot>  <[Integer] -> [Integer]>
23:38:51 <sorear> > let sieve (x:xs) = x:sieve (filter ((/=0) . (`mod` x)) xs) in sieve [2..]
23:38:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:39:24 <fuzan> Not the most efficient sieve, but sure a pretty one :)
23:39:27 <fantasma> let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in show $ fiblist !! (2^19)
23:39:37 <fantasma> oops
23:39:40 <fantasma> terminate
23:39:44 <mauke> > let primes = 2 : sieve [3, 5 ..]; sieve (p : ns) = p : sieve (filter ((0 /=) . (`mod` p)) ns); isPrime n = n == head (dropWhile (< n) primes) in primes
23:39:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:40:04 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in show $ fiblist !! (19)
23:40:06 <lambdabot>  "4181"
23:40:29 <sorear> > drop 100000 $ fix (([0..607] ++) . liftM2 (zipWith (+)) (drop 203) (drop 606)) -- lagged fibonacci PRNG, constants taken from Boost
23:40:31 <lambdabot>  [167652411391607049348596647041168119452208244350405798105392005188344009183...
23:40:45 <mauke> holy
23:40:50 <sorear> > drop 100000 $ fix (([0::Int..607] ++) . liftM2 (zipWith (+)) (drop 203) (drop 606)) -- oops, that type is VERY important
23:40:51 <lambdabot>  Parse error
23:41:04 <sorear> > drop 100000 $ fix (([0::Int ..607] ++) . liftM2 (zipWith (+)) (drop 203) (drop 606)) -- the space more so
23:41:05 <lambdabot>  [952572057,-1388372156,50283391,-1273810191,1332589190,-1190325566,-19321366...
23:41:37 <sorear> THAT is the prng
23:41:41 <goltrpoat> speaking of lists of primes, cute five minute exercise, if you're into that type of thing:  http://mathworld.wolfram.com/HappyNumber.html
23:41:42 <JoshTriplett> sorear: Period?
23:41:42 <timthelion> hmm. interesting. is it accualy usefull?
23:41:43 <lambdabot> Title: Happy Number -- from Wolfram MathWorld
23:42:58 <goltrpoat> tim:  hopefully not :)
23:43:11 <sorear> > drop 100000 $ fix (([0::Int ..608] ++) . liftM2 (zipWith (+)) (drop 273) (drop 607)) -- period approx. 2^32000
23:43:12 <lambdabot>  [-1860105762,-1136029074,-1194292232,2133823520,-130746068,-499097947,-25259...
23:43:22 <sorear> I mistyped the constants the first time :)
23:43:39 <nornagon> nifty
23:43:43 <nornagon> what's that?
23:43:43 <sorear> also I'm using slightly less precise arithmetic, which might make a difference.
23:44:02 <fantasma> why drop 607 and 273?
23:44:07 <nornagon> lagged fibonacci?
23:44:07 <JoshTriplett> nornagon: Psuedo-random number generator.
23:44:10 <sorear> nornagon: http://boost.org/libs/random/random-generators.html#lagged_fibonacci_spec
23:44:12 <lambdabot> Title: Boost Random Number Library Generators, http://tinyurl.com/yt48eg
23:44:17 <nornagon> ah.
23:44:20 <sorear> the 607 version
23:44:49 <sorear> except I use 0b32 fixed point [0,1) instead of double precision FP [0,1)
23:44:58 <sorear> so 32 bit mantissa not 52
23:45:07 <sorear> hopefully small difference :)
23:45:42 <JoshTriplett> @hoogle a -> [a]
23:45:43 <lambdabot> Prelude.repeat :: a -> [a]
23:45:43 <lambdabot> List.intersperse :: a -> [a] -> [a]
23:45:43 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
23:45:58 <JoshTriplett> @hoogle Int -> [Int]
23:45:59 <lambdabot> No matches, try a more general search
23:46:03 <JoshTriplett> @hoogle Integer -> [Integer]
23:46:04 <lambdabot> No matches, try a more general search
23:46:14 <JoshTriplett> @hoogle Num a => a -> [a]
23:46:15 <lambdabot> Prelude.repeat :: a -> [a]
23:46:15 <lambdabot> List.intersperse :: a -> [a] -> [a]
23:46:15 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
23:46:18 <goltrpoat> what are you looking for?
23:46:21 <sorear> > drop 100000 $ fix (([0,0.001..0.608] ++) . map (\x -> if x >= 1 then x-1 else x) . liftM2 (zipWith (+)) (drop 273) (drop 607)) -- with FP
23:46:23 <lambdabot>  [0.6802066190707614,7.958252692908951e-2,0.11209231887718851,0.6684576948410...
23:46:29 <JoshTriplett> goltrpoat: digits. :)
23:46:42 <goltrpoat> eh?
23:46:43 <goltrpoat> hehe
23:46:44 <JoshTriplett> goltrpoat: Or iterate until a given value.
23:46:54 <mauke> iterate what?
23:47:00 <JoshTriplett> goltrpoat: The latter I can do with takeWhile, though.
23:47:00 <goltrpoat> takeWhile . repeat?
23:47:07 <sorear> > map (toEnum . (+48) . floor . (*10)) $ drop 100000 $ fix (([0,0.001..0.608] ++) . map (\x -> if x >= 1 then x-1 else x) . liftM2 (zipWith (+)) (drop 273) (drop 607))
23:47:09 <lambdabot>  [54,48,49,54,57,57,57,55,50,51,52,50,53,57,50,57,50,54,52,53,55,57,51,51,50,...
23:47:13 <sorear> bah.
23:47:16 <sorear> defaulting--
23:47:22 <sorear> > (map (toEnum . (+48) . floor . (*10)) $ drop 100000 $ fix (([0,0.001..0.608] ++) . map (\x -> if x >= 1 then x-1 else x) . liftM2 (zipWith (+)) (drop 273) (drop 607))) :: [Char]
23:47:24 <lambdabot>  "601699972342592926457933269552547814362153038287076709390800297156405117655...
23:47:40 <bd_> @unpl (map (toEnum . (+48) . floor . (*10)) $ drop 100000 $ fix (([0,0.001..0.608] ++) . map (\x -> if x >= 1 then x-1 else x) . liftM2 (zipWith (+)) (drop 273) (drop 607)))
23:47:40 <sorear> now that's a random number generator.
23:47:41 <lambdabot> (map (\ o -> toEnum ((floor (o * 10)) + 48)) (drop 100000) (fix (\ y -> ([0, 1.0e-3 .. 0.608]) ++ (map (\ x -> if (x >= 1) then (x - 1) else x) (((drop 273) >>= \ e -> (drop 607) >>= \ d -> return (
23:47:42 <lambdabot> zipWith (+) e d)) y)))))
23:47:57 <goltrpoat> sorear:  i have no idea what you're doing, but it has random looking numbers in it, and for that, i salute you.
23:48:01 <timthelion> waa
23:48:10 <mauke> @type map digitToInt . show
23:48:11 <sorear> but I still think the fixed point version is clearer
23:48:13 <lambdabot> forall a. (Show a) => a -> [Int]
23:48:14 <timthelion> I hate it when I don't have the math for references
23:48:22 <timthelion> what is the concept of induction?
23:48:28 <JoshTriplett> mauke: Good point; I didn't think of show.
23:48:28 <mauke> > (map digitToInt . show) 5923
23:48:30 <lambdabot>  [5,9,2,3]
23:48:31 <bd_> @remember goltrpoat i have no idea what you're doing, but it has random looking numbers in it, and for that, i salute you.
23:48:32 <lambdabot> Done.
23:48:40 <goltrpoat> damn, i'm on fire.
23:48:50 <bd_> @. hoogle type map
23:48:53 <lambdabot> Did you mean: Forall a B. (a -> b) -> [a] -> [b]
23:48:54 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:48:54 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
23:48:57 <bd_> tsk
23:50:34 <timthelion> what is the fibonacci sequence?
23:50:42 <siti> a silly thing
23:50:49 <mauke> 1, 1, 2, 3, 5, 8, 13, 21, ...
23:50:50 <Botje> HOT RABBIT ON RABBIT ACTION
23:50:53 <siti> @google fibonacci wikipedia
23:50:53 <goltrpoat> F_n = F_{n-2} + F_{n-1}
23:50:55 <lambdabot> http://en.wikipedia.org/wiki/Fibonacci
23:51:03 <goltrpoat> with the choice F_0 = F_1 = 1
23:51:16 <timthelion> yes, but I don't understand what the sub n-2 n-1 means
23:51:19 <sorear> > fix((1:).scanl(+)1)
23:51:20 * JoshTriplett tries to remember the syntax in lambdabot for binding a name.
23:51:21 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:51:31 <sorear> ^^^ the fibonacci sequence
23:51:40 <siti> woah man
23:51:48 <siti> that's the shortest one ever :p
23:51:51 <nornagon> is dat sum golf?
23:51:56 <goltrpoat> tim:  "fifteenth Fibonacci number is the thirteenth such number, plus the fourteenth such number."
23:52:30 <JoshTriplett> nornagon: Heh.  I guess fibonacci sequence generation could qualify as "sum golf". :)
23:52:32 <sorear> siti: in all fairness I didn't invent it.
23:52:33 <goltrpoat> sorear:  wow that's slick.  i don't think ive seen that one before
23:52:37 <siti> ok
23:52:50 <nornagon> JoshTriplett: heh
23:52:50 <JoshTriplett> ype scanl
23:52:54 <JoshTriplett> @type scanl
23:52:55 <sorear> siti, goltrpoat: the fix for fibonaccis is well established lore
23:52:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:53:31 <sorear> http://haskell.org/haskellwiki/The_Fibonacci_sequence#With_scanl
23:53:33 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
23:54:25 <goltrpoat> sorear:  sure, it's just a lot more concise than what i wouldve written off the top of my head if prodded to write it in terms of fix
23:55:30 <goltrpoat> it's rather pretty if you read it.
23:56:37 <Botje> > let fibs = 1 : zipWith (+) 1 fibs $ tail fibs in fibs
23:56:38 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
23:56:40 <monochrom> > scanl (+) 1 [10,20,30]
23:56:41 <lambdabot>  [1,11,31,61]
23:56:42 <Botje> ehh
23:56:47 <siti> lol fastest fib in the west
23:56:57 <Botje> > let fibs = 1 : 1: zipWith (+) 1 fibs $ tail fibs in fibs
23:56:58 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
23:57:01 <timthelion> you know what's hard to look up? $
23:57:02 <Botje> oh sod it.
23:57:04 <goltrpoat> move aside, fftw
23:57:12 <Botje> << only awake for 10 minutes
23:57:16 <siti> hmm I need to learn how to use fix it's rather strange to me
23:57:24 <JoshTriplett> @type fix
23:57:26 <Botje> but that's the definition mere mortals would use
23:57:27 <lambdabot> forall a. (a -> a) -> a
23:57:47 <Botje> siti: i've never used fix in haskell for anything seirous
23:57:58 <Botje> focus on monads and arrows first
23:58:01 <siti> yeah, but it looks cool ;)
23:58:08 <JoshTriplett> Botje: Ditto.  But it proves rather fun for craziness.
23:58:11 <siti> I am not new to haskell :p
23:58:19 <Botje> > let fibs = 1 : 1: zipWith (+) fibs $ tail fibs in fibs
23:58:20 <lambdabot>  Couldn't match expected type `[t]'
23:58:31 * Botje looks for something to break
23:58:42 <Botje> don't program haskell when you're awake for less than 30 minutes kids.
23:58:46 <mauke> Botje: stop using $, dude
23:59:01 <JoshTriplett> siti: Best example to understand fix:
23:59:04 <Botje> but EUR doesn't work ;)
23:59:12 <JoshTriplett> > take 10 $ fix (1:)
23:59:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
23:59:17 <goltrpoat> the best example to understand fix, doesn't typecheck.
23:59:25 <Botje> I still need to memorize precedence rules :(
23:59:25 <goltrpoat> (mwahaha)
23:59:53 <JoshTriplett> goltrpoat: What example did you have in mind?
23:59:56 <Botje> the traditional introduction of fix is to make fac work in \-calculus
