00:00:28 <clanehin> possibly unclear, I meant in a class declaration "class MonadError e m | m -> e where"
00:00:52 <dcoutts> chessguy, pong
00:01:22 <chessguy> @undo do { p1 <- r ps; p2 <- r ps; return $ if ((snd p1) < (snd p2)) then p1 else p2 }
00:01:22 <lambdabot> r ps >>= \ p1 -> r ps >>= \ p2 -> return $ if ((snd p1) < (snd p2)) then p1 else p2
00:01:53 <chessguy> dcoutts, someone said gtk2hs has an interface or something for Graphics.SOE?
00:02:12 <dcoutts> chessguy, yes
00:02:24 <chessguy> dcoutts, where might i learn about it
00:03:09 <chessguy> i'm expecting SOE any day now, and i'd like to figure out how to work through the examples with gtk2hs
00:03:30 <michaelw> clanehin: google for "functional dependencies"
00:03:38 <dcoutts> chessguy, the API is the same as the original Graphics.SOE
00:03:55 <dcoutts> chessguy, it's part of Gtk2Hs, under the module name Graphics.SOE.Gtk
00:04:45 <chessguy> so i just import Gtk2HS.Graphics.SOE.Gtk instead of Graphics.SOE?
00:04:48 <dcoutts> yes
00:05:00 <dcoutts> chessguy, let me know how you get on, I've tried to make it match the original behaviour exactly but I've never worked through all the examples in the book.
00:05:31 <chessguy> well, i've never even used gtk2hs, so i'll be a pretty ignorant guinea pig
00:05:49 <dcoutts> chessguy, as I say, the API is *exactly* the same
00:06:53 <clanehin> michaelw: thanks
00:07:56 <chessguy> dcoutts,  import Gtk2Hs.Graphics.SOE.Gtk doesn't work
00:08:40 <dcoutts> chessguy, oh, sorry I misread what you said a moment ago..
00:08:43 <dcoutts> Graphics.SOE.Gtk
00:09:22 <dcoutts> chessguy, there's no Gtk2Hs prefix anywhere
00:09:45 <chessguy> ok, that one works
00:09:56 <chessguy> as i said, i've not used gtk2hs at all myself
00:11:25 <chessguy> but now maybe i'll put a gtk2hs front end on my GP Library. that would be fun :)
00:14:11 <dons> hugs error of the day, Maximum token length (4000) exceeded
00:14:35 <dons> (a string literal)
00:14:36 <chessguy> @pl \xs -> map (\x -> (x, f x)) xs
00:14:37 <lambdabot> map (ap (,) f)
00:14:46 <chessguy> ?hoogle ap
00:14:46 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
00:14:47 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
00:14:47 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
00:15:19 <dcoutts> See folks in Nottingham in 4 hours!
00:15:25 * dcoutts -> Nottingham
00:15:38 <bos> @pl \(a,b)->(b,a)
00:15:39 <lambdabot> uncurry (flip (,))
00:17:47 <chessguy> @pl \x -> tF xs x
00:17:48 <lambdabot> tF xs
00:18:03 <chessguy> @pl \x -> tF x xs
00:18:03 <lambdabot> flip tF xs
00:19:29 <ski_> :t uncurry curry
00:19:31 <lambdabot> forall a b c. ((a, b) -> c, a) -> b -> c
00:20:11 <bos> @pl \a b x y -> a x y >>= b
00:20:12 <lambdabot> flip . ((flip . ((>>=) .)) .)
00:20:21 <bos> @pl \x y -> a x y >>= b
00:20:22 <lambdabot> flip flip b . ((>>=) .) . a
00:21:02 <ski_> (b =<<) .: a
00:29:24 <nornagon> i totally want that to be flip flop b . ((>>=) .) . a
00:29:35 <nornagon> @let flop = flip
00:29:36 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
00:29:40 <nornagon> gar.
00:30:34 <chessguy> @yarr
00:30:34 <lambdabot> Well Ahoy! thar.
00:31:15 <chessguy> dons, ping
00:35:36 <chessguy> i'm wondering if this is a good candidate for map fusion. i'm trying to define selectSubTree :: Tree a -> State GlobalState (Tree a) -- where GlobalState has a stdGen in it, and i want to randomly pick a subtree of a given tree (of which i don't know the size)
00:44:13 <bringert> vnc2swf
00:44:35 <chessguy> hi bringert
00:44:39 <bringert> hi
00:44:41 <bringert> oops
00:44:49 <bringert> that should have gone in google
00:45:48 <ski_> @google vnc2swf
00:45:50 <lambdabot> http://www.unixuser.org/~euske/vnc2swf/
00:45:50 <lambdabot> Title: vnc2swf - Screen Recorder
00:49:20 <fuzan> Data.Binary looks cool!
00:49:53 <chessguy> @pl \x -> (x, f x)
00:49:54 <lambdabot> ap (,) f
00:50:09 <nornagon> :t ap
00:50:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:50:43 <glguy> :t (,) =<< f
00:50:46 <lambdabot> Not in scope: `f'
00:50:52 <chessguy> glguy!
00:50:56 <glguy> :t ((,) =<<)
00:50:58 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
00:51:08 <chessguy> did you see my question?
00:51:18 <glguy> i don't know anything about map fusion..
00:51:24 <glguy> except that it exists
00:51:29 <chessguy> how would you approach the problem then?
00:51:37 <glguy> and reduces the number of times a list needs to be recreated
00:52:19 <nornagon> @djinn b -> a -> b -> a -> b -> a -> b
00:52:20 <lambdabot> f _ _ _ _ a _ = a
00:52:21 <chessguy> best approach i can come up with is to map over the tree, and put the size of each subtree in each node, then choose a random number from 1 to n, the total size of the tree, and find that node
00:52:38 <nornagon> @djinn b -> (a -> b) -> a -> (b -> a -> b)
00:52:39 <lambdabot> f _ a b _ _ = a b
00:52:53 <nornagon> @djinn b -> (a -> b) -> a -> (b -> a) -> b
00:52:53 <lambdabot> f _ a b _ = a b
00:53:01 <nornagon> cheater.
00:53:56 <glguy> nornagon: what sort of function are you expecting?
00:54:13 <nornagon> none really, i was just playing.
00:54:44 <glguy> ugh, it's way to late
00:54:59 <glguy> chessguy: sorry, I really need to sleep, but I imagine you'll have to count them all first
00:55:09 <glguy> you could even flatten the tree
00:55:14 <glguy> into a list
00:55:20 <glguy> and return a random element from it
00:55:24 <glguy> (using length and whatnot)
00:55:26 <chessguy> or early, depending on your perspective :)
00:55:30 <chessguy> yeah
00:55:45 <chessguy> that sounds pretty much equivalent to what i said
00:55:51 * glguy &
00:58:04 <chessguy> hmm, i'd have to be careful how i flatten it, because i'd have to unflatten it to get the subtree back
01:04:15 <araujo> http://www.desktoplinux.com/news/NS3057967810.html
01:04:17 <lambdabot> Title: Mono brings Visual Basic programs to Linux
01:04:37 <JohnnyL> can you run haskell on top of a JVM?
01:12:56 <DRMacIver> I was writing some very lazy code the other day and idly wondered how to translate it into Haskell. Most of it translates rather nicely, but I ran into a bit of a problem which I didn't know how to translate (mostly due to Haskell ignorance I suspect).
01:13:16 <Cale> DRMacIver: what was it? :)
01:13:27 <DRMacIver> I have a function which takes an argument, does IO and returns a value based on this IO.
01:13:39 <DRMacIver> But if it's invoked multiple times on the same argument it shouldn't perform IO again.
01:13:43 <DRMacIver> It should just return the last value it returned.
01:13:56 <quicksilver> that's not really a function, then :)
01:14:14 <DRMacIver> I couldn't see how to implement something like this in Haskell without invoking some really nasty hacking with pretend state. :)
01:14:27 <DRMacIver> quicksilver: Well, yes. :) 'function' then.
01:14:29 <quicksilver> make it type IO (a -> IO b)
01:14:33 <Cale> IO (a -> IO b)
01:14:34 <Cale> yes
01:14:39 <quicksilver> or, even, IO ( a -> b )
01:14:41 <quicksilver> possibly
01:15:00 <DRMacIver> But doesn't that fail the criterion that the second time it's invoked on the same argument it doesn't perform IO?
01:15:12 <Cale> The outer layer of IO will set up the table responsible for keeping track of which things have happened
01:15:16 * quicksilver nods
01:15:18 <DRMacIver> Ah, right.
01:15:20 <quicksilver> for example an array
01:15:24 <quicksilver> or a data.map
01:15:24 <JohnnyL> @seen humasect
01:15:24 <Cale> the inner later will update that table
01:15:25 <lambdabot> I saw humasect leaving #haskell 1d 17m 5s ago, and .
01:15:28 <Cale> layer*
01:15:50 <fuzan> how would you define the type declaration for something like flatten?
01:15:50 <Cale> If you'd like, I could write you an example :)
01:16:00 <DRMacIver> Cale: That would be great if you could. :)
01:16:12 <Cale> fuzan: flatten :: [[a]] -> [a]
01:16:12 <Cale> ?
01:16:15 <quicksilver> fuzan: flatten :: [[a]] -> [a] ? or flatten :: Tree a -> [a] ?
01:16:31 <DRMacIver> (I'm not actually working with Haskell at the moment, but I'm writing a lot of code that's lazy and quasifunctional, so I'm trying to keep it in the back of my mind)
01:16:31 <quicksilver> (there are a few things you might mean, by flatten :)
01:16:45 <fuzan> list flatten. does that handle variable depths?
01:16:58 <quicksilver> ah well
01:17:00 <fuzan> i mean, [[[[[[[[5,4]]]]]],1]
01:17:10 <fuzan> :t [[[3,2],5],6]
01:17:12 <quicksilver> the built in list-type doesn't handle variable depths in a single type
01:17:13 <lambdabot> forall t. (Num t, Num [t], Num [[t]]) => [[[t]]]
01:17:24 <fuzan> i was thinking about this the other day
01:17:33 <fuzan> and i had no idea how to express the type :)
01:17:34 <quicksilver> [[[3,2],5],6] is badly typed (ignore lambdabot ;P)
01:17:43 <JohnnyL> can you write a program in haskell under a jvm and generate java code by parsing the byte code that was generated under haskell?
01:17:45 <quicksilver> a 'deep list' is really a kind of tree
01:17:58 <fuzan> i suppose.
01:19:19 <quicksilver> data DeepList a = Null | DeepCons DeepList Deeplist
01:19:31 <quicksilver> erm, that's not quite right
01:19:39 <quicksilver> data DeepList a = Null | DeepCons DeepList Deeplist | DeepAtom a
01:19:41 <quicksilver> approximately
01:19:48 <pejo> JohnnyL, but why?
01:19:57 <quicksilver> (although that allows a top-level atom as distinct from a single element list, so it's not perfect)
01:20:12 <JohnnyL> pejo, because java requires much typing and isn't nearly compressed as haskell.
01:20:29 <quicksilver> JohnnyL: what's the point of generating java code though?
01:20:38 <quicksilver> JohnnyL: supposing you have byte code, how is that not good enough?
01:20:39 <JohnnyL> quicksilver, so your boss aproves.
01:20:43 <quicksilver> heh
01:20:57 <JohnnyL> haskell is rather above most working people's language.
01:21:08 <DRMacIver> JohnnyL: Java byte code looks very like Java, but you're likely to run into a few problems.
01:21:28 <DRMacIver> JohnnyL: There are just enough things you can do in byte code that you can't do in Java that you'll run into some things decompilers can't handle.
01:21:40 <DRMacIver> Goto and clever storage on the stack are the main things.
01:22:04 <DRMacIver> JohnnyL: You're much better off finding a Haskell compiler which targets Java directly rather than Java byte code. :)
01:22:27 <JohnnyL> ok
01:23:11 <JohnnyL> i don't see what the big problem is though. What little I know of haskell and java byte code. The haskell would turn into little imperative steps under the jvm.
01:23:25 <JohnnyL> THe opposite direction I can't see as clearly.
01:23:29 <michaelw> DRMacIver: there are some complications with compiling Haskell to Java.  TCO, for starters.  AFAIR, that route was trie
01:23:33 <michaelw> *tried
01:23:37 <quicksilver> a problem is that java --> jvm is a homomorphism
01:23:39 <DRMacIver> JohnnyL: It will probably generate goto instructions and store things on the stack.
01:23:43 <quicksilver> not an isomorphism
01:23:50 <quicksilver> so jvm --> java is not clear
01:23:53 <fuzan> that explains why I couldn't figure out how to do it, it's not possible with generic lists :\
01:23:55 <JohnnyL> eww, not good.
01:24:06 <quicksilver> fuzan: that's not the type that 'ordinary lists' represent
01:24:08 <DRMacIver> quicksilver: Although it is an injective homomorphism. :)
01:24:09 <JohnnyL> how about an intermediate VM like .Net/MONO?
01:24:22 <DRMacIver> JohnnyL: .NET/MONO's instructions look pretty similar to Java's. :)
01:24:23 <JohnnyL> because .NET runs f# (a functional language)
01:24:23 <quicksilver> fuzan: don't believe the FUD that haskell "can't do deep lists" though
01:24:29 <JohnnyL> which was based on o'caml.
01:24:43 <DRMacIver> JohnnyL: Sure. But you'll have trouble decompiling F# into C#. :)
01:24:52 <DRMacIver> michaelw: Yeah, that doesn't surprise me.
01:24:55 <quicksilver> fuzan: it's just that the built-in type list isn't the one you're looking for
01:25:00 <DRMacIver> michaelw: Although you can always trampoline. :-/
01:25:09 <quicksilver> the .NET CLR is even worse
01:25:19 <quicksilver> it has even more constructs not supported by java
01:25:26 <quicksilver> tail recursion and explicit stack unwinds
01:25:28 <quicksilver> IIRC
01:25:37 <Cale> !paste
01:25:37 <hpaste> Haskell paste bin: http://hpaste.org/
01:25:41 <quicksilver> (when I say 'even worse' it's actually 'much better')
01:25:51 <quicksilver> (but worse from the perspective of a decompiler)
01:26:05 <pjd> quicksilver: isn't CLR's tail recursion *slower* than normal function calls?
01:26:16 <pjd> (so i hear)
01:26:54 <pjd> JohnnyL: there's a guy working on a JVM backend to GHC
01:26:55 <pjd> http://www.cs.rit.edu/~bja8464/lambdavm/
01:26:57 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
01:27:04 <JohnnyL> oh ok.
01:27:07 <JohnnyL> thanks
01:27:41 <hpaste>  Cale pasted "AskMap" at http://hpaste.org/572
01:27:49 <beelsebob> quicksilver: what's wrong with data Deeplist a = Nil | Leaf a | Branch (Deeplist a) (Deeplist a)
01:27:51 <Cale> DRMacIver: check it out :)
01:28:24 <Cale> we can actually parametrise this better
01:28:58 <quicksilver> beelsebob: it has multiple ways of representing [[[a]]]
01:29:03 <michaelw> beelsebob: how is that different from a tree?
01:29:04 <DRMacIver> Cale: Hah. So it is in fact almost identical to the implementation in Java. :) Thanks though - looks neat.
01:29:05 <quicksilver> beelsebob: in some sense that's not a problem
01:29:13 <beelsebob> quicksilver: indeed - as do deeplists
01:29:14 <quicksilver> beelsebob: but it's not quite what the OP was asking about
01:29:19 <beelsebob> that's exactly what you'd expect
01:29:31 <quicksilver> ?
01:29:33 <beelsebob> michaelw: it isn't -- that's what a deeplist is
01:29:38 <beelsebob> it's a tree flattened into a list
01:29:43 <quicksilver> in lisp, ( ( ( 1 ) ) ) is canonical
01:29:49 <quicksilver> there aren't two ways of representing that
01:30:04 <quicksilver> here we have multiple ones
01:30:07 <beelsebob> but that's only because lisp has a rule about which version to use
01:30:44 <JohnnyL> pjd, there is so much crap on that site, hard to find where it is. {keeps searching}
01:30:55 <quicksilver> beelsebob: no, there's more to it than that
01:31:06 <beelsebob> hmm?
01:31:08 <michaelw> urm, i would not call that flattened, and neither would I call it "Deeplist" :)
01:31:17 <quicksilver> (nil . (1)) is not ((1))
01:31:37 <quicksilver> ((1)) is ((1).nil)
01:31:42 <beelsebob> what's your point?
01:31:45 <quicksilver> but (nil . (1)) is a distinct list value
01:31:55 <beelsebob> yes
01:32:06 <beelsebob> why is that a problem?
01:32:22 <quicksilver> maybe I'm being dumb. Just a moment :)
01:32:37 <hpaste>  Cale annotated "AskMap" with "refactor" at http://hpaste.org/572#a1
01:32:44 <beelsebob> entirely plausable that I am too - but I think you're getting too hung up on Lisp's version of doing it
01:32:52 <beelsebob> and implementation details
01:33:24 <michaelw> well, canonical representations are a good thing. more invariants that can be checked
01:33:29 <beelsebob> true
01:33:36 <beelsebob> but deep lists don't have that one
01:33:40 <beelsebob> unfortunately
01:33:41 <quicksilver> ah, here's the different with list
01:33:43 <quicksilver> lisp
01:33:49 <quicksilver> you're permitting ((1).1)
01:33:58 <quicksilver> which deep list is that supposed to represent?
01:34:16 <beelsebob> presumably the same as (1 1)
01:34:19 <beelsebob> (flattened)
01:34:27 <quicksilver> that's ((1).(1))
01:34:33 <quicksilver> so you've lost canonical representation
01:34:34 <beelsebob> correct
01:34:39 <beelsebob> what's your point?
01:34:46 <quicksilver> that the derived Eq instance won't work
01:34:54 <beelsebob> so write an instance
01:35:01 <Cale> DRMacIver: there's a refactoring -- but you should get the idea
01:35:03 <quicksilver> and that any functions defined over this datatype have to make sure they behave correctly on non-canoncial forms
01:35:11 <beelsebob> indeed
01:35:16 <quicksilver> you can write a 'non-function' if you're not careful
01:35:20 <beelsebob> I never said deep list wasn't a nice data structure
01:35:24 <beelsebob> was*
01:35:34 <Cale> DRMacIver: the basic thing is that a function of type a -> IO b is still pure in one important regard: it returns the same action for the same input every time.
01:36:01 <beelsebob> in fact... reading definitions for deep list, none of them mention a cannonical form
01:36:01 <xpika> i need a tree. how can i make one?
01:36:09 <Cale> So without that outer layer of IO, there's no way to set up the table.
01:36:17 <beelsebob> xpika: data Tree a = Branch (Tree a) (Tree a) | Leaf a
01:36:37 <Cale> Or  data Tree a = Leaf | Branch a [Tree a]
01:36:53 <beelsebob> or data Tree a = Branch [Tree a] | Leaf a
01:37:06 <Cale> Or any number of things. There's Data.Tree
01:37:16 <xpika> beelsebob: sorry I should of qualified i needed a Data.Tree
01:37:17 <beelsebob> or Tree a = Branch (Tree a) a (Tree a) | Leaf
01:37:24 <Cale> But it's rarely used :)
01:37:47 <Cale> Oh, then use the Node constructor
01:38:06 <xpika> > Node 1 (Node 2)
01:38:08 <lambdabot>  Couldn't match expected type `Forest t'
01:38:12 <Cale> Node 5 [Node 3 [], Node 1 [Node 2 [], Node 6 []]]
01:38:30 <beelsebob> shouldn't they be records
01:38:37 <quicksilver> beelsebob: well I think it's fair to say that a data structure which contains non-canonical forms is pretty unpleasant as a concrete type
01:38:42 <xpika> thanks
01:38:42 <Cale> You can ignore that if you don't want record syntax
01:38:45 <beelsebob> Node {rootLabel = 5, subForrest = [Node {...}]}
01:38:51 <quicksilver> beelsebob: you'd need to abstract it away
01:38:55 <xpika> i forgot forest actually mean [Tree]
01:38:56 <beelsebob> quicksilver: absolutely, agreed
01:39:01 <Cale> You can write it that way if you want, but it's a waste of keystrokes.
01:39:10 <beelsebob> but it certainly is a deep list quicksilver
01:39:48 <quicksilver> data DeepList = Nil | DeepCons (DeepList a) [DeepList a]
01:39:53 <quicksilver> might be more faithful
01:40:24 <beelsebob> well no, that's not more faithful -- it does guarentee a cannonical form
01:40:43 <beelsebob> incidentally the definition the lispers all seem to give in BNF is...
01:40:44 <beelsebob>  deeplist t ::= t | Nil | Cons (deeplist t) (deeplist t)
01:41:49 <beelsebob> bad nedsplit!
01:41:52 <beelsebob> net too
01:42:41 <quicksilver> it is more faithful! In the representation sense! Or have I mixed my duals and it's more full?
01:43:18 <beelsebob> I think it's closer to the implementation detail
01:43:25 <beelsebob> but not closer to the abstract description
01:44:47 <quicksilver> in your first version, if ((1).1) is supposed to be the same as ((1).(1))
01:45:00 <quicksilver> then why isn't ((1).(1)) the same as ((1).((1)))
01:45:14 <quicksilver> the equivalence relation isn't even structure-respectin
01:45:16 <beelsebob> it is... flattened
01:45:29 <quicksilver> but flattened isn't the only story!
01:45:39 <quicksilver> if flattened was the only story, I wouldn't be defining a deep list :)
01:45:50 <quicksilver> presumably I'm defining a deep list because I carea about the deep structure
01:45:57 <beelsebob> unfortunately, a one dimentional abstract data structure can be represented in many ways in a dwo dimensional concrete structure
01:46:34 <quicksilver> obviously. I don't think that's the point though.
01:46:45 <quicksilver> This implementation contains a surprising equivalence
01:46:54 <quicksilver> which isn't even substitution-respecting
01:47:04 <quicksilver> in my view, that makes it a bad implementation
01:47:19 <quicksilver> (I'd be happer if we just said ((1).1) was 'illegal' I guess)
01:47:28 <quicksilver> (which is what lisp does, I guess)
01:49:40 <xpika> > Data.Foldable.toList $ Node 5 [Node 3 [], Node 1 [Node 2 [], Node 6 []]]
01:49:41 <lambdabot>  [5,3,1,2,6]
01:52:57 <DRMacIver> Cale: Right. Thanks again.
01:53:11 <xpika_> what is the Data.Foldable equivalent of map?
01:54:03 <quicksilver> you mean from Tree -> Tree?
01:54:15 <quicksilver> or from Tree -> List?
01:54:39 <DRMacIver> Anyway, all this Haskell is very well, but I suppose I'd better go to work and do some Java. Sigh.
01:54:42 <xpika_> Tree -> Tree
01:54:45 <quicksilver> there isn't a Tree -> Tree 'map' in Foldable, because Foldable is all about flattening :)
01:54:47 <xpika_> quicksilver: ^^
01:55:08 <quicksilver> however, Tree implements Functor
01:55:12 <quicksilver> so fmap should do it fine
01:55:28 <quicksilver> > fmap (*2) $ Node 5 [Node 3 [], Node 1 [Node 2 [], Node 6 []]]
01:55:30 <lambdabot>  Node {rootLabel = 10, subForest = [Node {rootLabel = 6, subForest = []},Node...
01:56:02 <quicksilver> fmap should work on any 'container data structure'
01:56:14 <xpika> quicksilver: ooh nice
01:56:14 <quicksilver> and you'd we well advised to make any container you code yourself a Functor instance
01:57:19 <xpika> quicksilver: I read syntaxfrees article where he demonstrated replacing (.) with fmap
01:57:27 * quicksilver nods
01:57:36 <quicksilver> well that's in the arrow monad (which is also a Functor)
01:57:37 <xpika> quicksilver: is this realistic?
01:57:47 <quicksilver> 'realistic' in what sense?
01:57:51 <quicksilver> is it good coding style, you mean?
01:57:54 <quicksilver> I'd say no :)
01:57:58 <xpika> ok then.
01:58:02 <quicksilver> (.) is perfectly clear as it is
01:58:09 <quicksilver> it's a neat trick, and it's educational
01:58:14 * xpika reads up on the function monad
01:58:37 <xpika> its about my 6'th monad i know
01:58:57 <pjd> xpika: it's (a|the) Reader monad
01:59:00 <xpika> IO,List,Reader,Cont,State,ST
01:59:46 <xpika> pjd: (->) :: Reader?
02:00:17 <quicksilver> (r->)  is Reader
02:00:25 <quicksilver> (although we don't support sectional notation for types)
02:00:30 <quicksilver> so it's called (->) r
02:00:57 <quicksilver> 'calculations which need a value of type r to run'
02:01:09 <pjd> xpika: http://www.alpheccar.org/en/posts/show/61
02:01:11 <lambdabot> Title: A newbie in Haskell land : The (->) monad
02:01:13 <quicksilver> i.e. 'calculations which want to be run in an enivorenment which provides a value of type r'
02:01:59 <quicksilver> > do { x <- (*2) ; y <- (-4) ; return (x,y) } $ 12
02:02:00 <lambdabot>   add an instance declaration for (Num (a -> t))
02:02:00 <lambdabot>     In a 'do' expression: y ...
02:02:12 <quicksilver> > do { x <- (*2) ; y <- (subtract 4) ; return (x,y) } $ 12
02:02:13 <lambdabot>  (24,8)
02:03:46 <xpika_> ow wow..
02:04:14 <pjd> > (*) >>= id $ 5
02:04:15 <lambdabot>  25
02:04:49 <pjd> > join (*) 5
02:04:51 <lambdabot>  25
02:14:00 <JohnMeacham> hello. anyone in the los angeles or san fransisco bay area? I am likely to be throwing a party soon and would love for haskell-folk to invade it.
02:14:10 <araujo> morning
02:14:32 <earthy> he. I'm near the west coast...
02:14:41 <earthy> of continental europe however. :)
02:15:59 <fuzan> how can I load a file without resetting the  scope of my current ghci?
02:16:44 <Stinger> hmmm is there a simple haskell syntax summary
02:17:13 <Stinger> somewhere around the place? Or can someone tell me how an if then else should be arranged? :)
02:17:33 <quicksilver> > if 3>4 then 12 else 15
02:17:34 <lambdabot>  15
02:17:42 <Stinger> multiline I mean
02:17:46 <quicksilver> lines don't matter
02:17:49 <quicksilver> do what you want :)
02:18:06 <quicksilver> just be careful of surrounding layout-sensitive structures
02:18:25 <fuzan> usually I indent the then/else a char offset from the if
02:19:07 <quicksilver> I trust haskell-mode to do something plausible, and jsut hit 'tab'
02:19:15 <mux> fuzan: I think :load meets those requirements, doesn't it?
02:19:27 <fuzan> it's not seeming that way,
02:19:29 <Stinger> ah ok, else cant be at the same level as the if
02:19:31 <fuzan> :l main.hs
02:19:35 <fuzan> main -> works
02:19:38 <fuzan> :l test.hs
02:19:38 <Stinger> in a do expression
02:19:43 <fuzan> main -> no longer exists
02:19:45 <mux> it resets the scope to what's imported in the file?
02:19:48 <fuzan> yes.
02:19:50 <xpika> can i query data types from vim?
02:19:56 <quicksilver> Stinger: right
02:20:02 <mux> fuzan: what about :add <file> ?
02:20:06 <fuzan> ill try.
02:20:09 <quicksilver> Stinger: otherwise, the 'else' is introducing a new 'do statement'
02:20:14 <quicksilver> Stinger: which is then a syntax error
02:20:32 <Stinger> haskell mode doesnt want to put it anywhere else :P
02:22:06 <fuzan> mux: this is odd, it compilesboth but still only uses the recentmost's scope
02:22:23 <mux> I have no idea how to do it then
02:22:24 <quicksilver> Stinger: sometimes you have to hit tab a few times until it gets it right
02:22:33 <quicksilver> fuzan: it would work if there were different modules
02:22:43 <Stinger> no it really doesnt want to put it anywhere else
02:22:47 <quicksilver> fuzan: if you define a file with no explicit module definition
02:22:59 <quicksilver> fuzan: then it puts that in a module called Main
02:23:06 <quicksilver> fuzan: then your two modules called Main override each other :)
02:23:08 <fuzan> there's two modules. I'm not sure how to access from the other tho.
02:23:15 <quicksilver> ModuleName.thing
02:23:41 <fuzan> oh, yay.
02:23:43 <fuzan> thanks.
02:24:55 <quicksilver> you can manipulate the 'default module imports at the commandline' with :m
02:40:50 * mux wonders if neil will keep his word and eat his keyboard
02:43:05 <dblhelix> mux: wasn't simon supposed to eat his?
02:46:58 <dons> though, strictly, pidigits isn't part of nofib. its a gmp-binding testing program from the shootout
02:47:05 <mux> dblhelix: I maye have got confused, in that case, s/neil/simon/ :-)
02:47:09 <dons> so anyone using gmp should get roughly the same numbers :-)
02:47:17 <beelsebob> @hoogle Ordering -> Ordering
02:47:18 <lambdabot> No matches, try a more general search
02:47:20 <beelsebob> :(
02:47:26 <int-e> @where hbench
02:47:27 <lambdabot> I know nothing about hbench.
02:47:33 <dons> ?where nobench
02:47:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/nobench
02:47:39 <int-e> oh.
02:49:16 <earthy> !autolart
02:49:53 <earthy> or you profile the newly compiled optimised version  instead of the old unoptimised that you still have lying around...
03:06:51 <araujo> morning
03:23:08 <MarcWebe1> Can I compile cyclic module dependencies with cabal/ ghc?
03:26:02 <bakert>  Anyone know what this means: "darcs: bug in get_extra commuting patch"
03:26:04 <bakert> ?
03:27:19 <MarcWebe1> bakert: No, but there is a darcs channel ;-)
03:28:18 <bakert> i tried that.  experience shows that #haskell gets better results.  although one could argue i should take a hit for clarity and not chat about it here anyway i suppose.
03:28:48 <Cale> bakert: that's fine :)
04:12:59 <xpika> does anyone know what the default precedence of an `infix` function?
04:15:25 <araujo> 6 i think
04:15:47 <araujo> mm.. or is it 9?
04:15:49 <araujo> :-)
04:18:28 <Thunder> "Any operator lacking a fixity declaration is assumed to be infixlÂ 9" from http://haskell.org/onlinereport/decls.html#sect4.4.2
04:18:29 <lambdabot> Title: The Haskell 98 Report: Declarations
04:25:29 <emk> Anyone know what's up with nomaware?
04:25:40 <emk> Is there another site for that monad tutorial?
04:27:21 <MarcWebe1> emk Perhaps try google and cache?
04:27:46 <emk> MarcWebe1: Yeah, it's still in the Google cache, but that will disappear soon.
04:27:47 <syntaxfree> oh boy, what has Haskell done to my mind?
04:27:56 <emk> syntaxfree++
04:28:05 <syntaxfree> hey emk.
04:28:26 <emk> MarcWebe1: The nomaware tutorial was excellent, and I'd hate to lose it from the web.
04:28:41 <syntaxfree> I was reading on object-oriented databases, and can't stop the "but has this got a formal calculus as a foundation?" thought quiet.
04:28:59 <syntaxfree> I didn't like the nomaware tutorial.
04:29:12 <syntaxfree> It was more of a guide than a tutorial. It's out?
04:29:32 <syntaxfree> I like the Crash Monad Tutorial
04:29:51 <quicksilver> emk: http://web.archive.org/web/20051104132745/http://nomaware.com/monads/html/index.html
04:29:53 <lambdabot> Title: All About Monads, http://tinyurl.com/2g78y6
04:29:58 <emk> syntaxfree: Does anyone have as much detail on monad transformers as Nomaware?
04:30:09 <quicksilver> emk: AFAIK, wayback don't plan to delete their archives, ever
04:30:09 <syntaxfree> emk: well, there is that.
04:31:41 <kzm> Anybody know whether there's endianness stuff being added to Data.Binary (or elsewhere?)
04:31:53 <SamB> quicksilver: at least not without specific request
04:32:26 <kzm> (I just squashed a nasty bug in my byte-swapping code.  Worked for all cases except byte value 0x80.  Yes, it was a sign issue)
04:32:27 <emk> syntaxfree: For a reasonably formal semantics of Object Query Language (OQL), Google for "Comprehending Queries". The author reduces OQL to a series of monad comprehensions, and then to catamorphisms and combinators.
04:32:46 <syntaxfree> oh, cool.
04:32:47 * SamB wants a dogamorphism
04:32:57 <syntaxfree> I kinda just wanted to know there *was* one.
04:33:22 <syntaxfree> I'm really trying to focus on one or two things at once now. I have little intellectual energy as it is, lately.
04:33:40 <emk> http://citeseer.ist.psu.edu/grust99comprehending.html
04:33:43 <lambdabot> Title: Comprehending Queries - Grust (ResearchIndex)
04:33:51 <syntaxfree> thanks!
04:33:54 <emk> syntaxfree: I know the feeling...
04:34:34 <syntaxfree> My interest in databases is fleeing. I'm fascinated by Datalog, and wonder why it never got off the ground, and I'm just looking around what other models besides the relational have been proposed.
04:34:46 <SamB> fleeing or fleeting?
04:34:56 <syntaxfree> fleeting, maybe.
04:35:02 <syntaxfree> @web1913 fleeting
04:35:04 <lambdabot> *** "Fleeting" web1913 "Webster's Revised Unabridged Dictionary (1913)"
04:35:04 <lambdabot> Fleet \Fleet\, v. i. [imp. & p. p. {Fleeted}; p. pr. & vb. n.
04:35:04 <lambdabot>    {Fleeting}.] [OE. fleten, fleoten, to swim, AS. fle['o]tan to
04:35:04 <lambdabot>    swim, float; akin to D. vlieten to flow, OS. fliotan, OHG.
04:35:04 <lambdabot>    fliozzan, G. fliessen, Icel. flj[=o]ta to float, flow, Sw.
04:35:06 <lambdabot> [23 @more lines]
04:35:15 <syntaxfree> @web1913 fleeing
04:35:17 <lambdabot> *** "Fleeing" web1913 "Webster's Revised Unabridged Dictionary (1913)"
04:35:17 <lambdabot> Flee \Flee\, v. i. [imp. & p. p. {Fled}; p. pr. & vb. n.
04:35:17 <lambdabot>    {Fleeing}.] [OE. fleon, fleen, AS. fle['o]n (imperf.
04:35:17 <lambdabot>    fle['a]h); akin to D. vlieden, OHG. & OS. fliohan, G.
04:35:17 <lambdabot>    fliehen, Icel. fl?ja (imperf. fl??i), Dan. flye, Sw. fly
04:35:19 <lambdabot> [17 @more lines]
04:35:25 <syntaxfree> hmm. both fit.
04:35:28 <syntaxfree> @more
04:35:29 <lambdabot>    (imperf. flydde), Goth. pliuhan. (?) 84. Cf. {Flight}.]
04:35:29 <lambdabot>    To run away, as from danger or evil; to avoid in an alarmed
04:35:29 <lambdabot>    or cowardly manner; to hasten off; -- usually with from. This
04:35:29 <lambdabot>    is sometimes omitted, making the verb transitive.
04:35:29 <lambdabot>  
04:35:31 <lambdabot> [12 @more lines]
04:35:37 <syntaxfree> haha. fleeting.
04:35:50 <syntaxfree> flirting, maybe :)
04:36:06 <SamB> @dict fleeting
04:36:06 <lambdabot> Supported dictionary-lookup commands:
04:36:07 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
04:36:07 <lambdabot> Use "dict-help [cmd...]" for more.
04:36:17 <SamB> @web1913 fleeting
04:36:19 <lambdabot> *** "Fleeting" web1913 "Webster's Revised Unabridged Dictionary (1913)"
04:36:19 <lambdabot> Fleet \Fleet\, v. i. [imp. & p. p. {Fleeted}; p. pr. & vb. n.
04:36:19 <lambdabot>    {Fleeting}.] [OE. fleten, fleoten, to swim, AS. fle['o]tan to
04:36:19 <lambdabot>    swim, float; akin to D. vlieten to flow, OS. fliotan, OHG.
04:36:19 <lambdabot>    fliozzan, G. fliessen, Icel. flj[=o]ta to float, flow, Sw.
04:36:20 <SamB> @more
04:36:21 <lambdabot> [23 @more lines]
04:36:23 <lambdabot>    flyta, D. flyde, L. pluere to rain, Gr. ? to sail, swim,
04:36:25 <lambdabot>    float, Skr. plu to swim, sail. [root]84. Cf. {Fleet}, n. &
04:36:27 <lambdabot>    a., {Float}, {Pluvial}, {Flow}.]
04:36:29 <lambdabot>    1. To sail; to float. [Obs.]
04:36:31 <lambdabot>  
04:36:33 <lambdabot> [18 @more lines]
04:36:34 <SamB> @more
04:36:35 <lambdabot>             And in frail wood on Adrian Gulf doth fleet.
04:36:37 <lambdabot>                                                   --Spenser.
04:36:39 <lambdabot>  
04:36:41 <lambdabot>    2. To fly swiftly; to pass over quickly; to hasten; to flit
04:36:43 <lambdabot>       as a light substance.
04:36:45 <lambdabot> [13 @more lines]
04:36:54 <SamB> ah. FINALLY!
04:37:48 <nornagon> floodtastic
04:38:27 <syntaxfree> Prolog always looked to me like a perfect business language.
04:44:53 <MarcWebe1> emk  Perhaps we should ask at haskelcafe if somebody knows ? and if nobody does save a copy ?
04:45:12 <emk> MarcWebe1: Probably not a bad idea.
04:45:24 <emk> Does anyone know how to get in touch with author, to get permission?
04:47:28 <emk> syntaxfree: The big problem with Prolog is that it relies on simple backtracking, which takes O(2^N) time for N choices. There's a couple of ways to solve that, including (a) eliminating backtracking or (b) using a constraint engine to maximize the possible inference before making a guess. But yeah, it's a nice language.
04:48:07 * emk likes Oz, but most people around here probably prefer Mercury
04:48:32 <MarcWebe1> emk Please send any comments, corrections, or suggestions to Jeff Newbern at jnewbern@yahoo.com. Will you try or should I?
04:49:16 <emk> MarcWebe1: I'm happy to send a note. But feel free, if you wish!
04:50:00 <MarcWebe1> emk: Go on and let me now. I'm willing to make a copy using google cache if he doesn't respond.
04:51:35 <MarcWebe1> Do you know wether there is support in cabal compiling mutually recursive modules?
04:52:57 <emk> MarcWebe1: I sent him a short ping.
04:53:27 <earthy> okaay... -O2 cut the percentage of time spent in fromIntegral from 39.2% to 17.1%
04:53:37 <earthy> still... *WTF*?!
04:54:48 <earthy> fromIntegral :: Int -> Word taking 17% of my running time?!
04:55:25 <quicksilver> earthy: look on the bright side, at least that is, in principle, something that's easy to speed up?
04:56:04 <quicksilver> MarcWebe1: the webarchive copy will be easier to trawl and archive than the google copy
04:56:08 <earthy> in principle
04:56:19 <quicksilver> earthy: what does your program do?
04:56:44 <earthy> I'm profiling a particular use case of Dazzle
04:56:56 <earthy> where I do shitloads of IntMap operations
04:57:12 <syntaxfree> emk: yeah. It seems modern Prolog compilers/interpreters handle some form of constraint logic programming though.
04:57:33 <quicksilver> interesting
04:57:45 <quicksilver> earthy: why does dazzle use word and not int in the first place?
04:57:51 <emk> Often as a library on top of Prolog...
04:57:53 <earthy> it's in DData
04:57:57 <MarcWebe1> ?where webarchive
04:57:58 <lambdabot> I know nothing about webarchive.
04:58:04 <earthy> and I have *no* clue why Daan did this
04:58:34 <syntaxfree> Anyway, this Datalog thing is apparently a reduced version of Prolog for database querying.
05:00:13 <quicksilver> MarcWebe1: http://web.archive.org/web/20051104132745/http://nomaware.com/monads/html/index.html
05:00:15 <lambdabot> Title: All About Monads, http://tinyurl.com/2g78y6
05:00:27 <syntaxfree> @google crash monad tutorial
05:00:29 <lambdabot> http://www.patryshev.com/monad/m-intro.html
05:00:30 <lambdabot> Title: Crash Monad Tutorial
05:00:40 <syntaxfree> that's really the best tutorial for beginners  I've ever seen.
05:01:45 <quicksilver> However, I believe that the link syntaxfree posted is the *worst* tutorial for beginners I've ever seen :)
05:01:53 <quicksilver> just in the spirit of free speech etc
05:02:15 <Cheery> are monads allowed to bind during runtime?
05:02:31 <syntaxfree> Why?
05:02:34 <quicksilver> Cheery: 'runtime' is a nebulous concept. Care to explain a little more?
05:02:41 <syntaxfree> It freaking explains what a monad is!
05:02:42 <SamB> Cheery: no. they are kept well lubricated!
05:02:57 <quicksilver> syntaxfree: well it all depends what you want to acheive
05:03:06 <Cheery> like, allowing random input to decide how monads bind together.
05:03:16 <syntaxfree> yes. that's why I said "beginners".
05:03:44 <quicksilver> syntaxfree: I don't believe that the best way to teach a programmer, or a haskell learner, monads, is to teach them category theory
05:04:02 <quicksilver> I don't think the category theory is all that enlightening at all, from a programming perspective
05:04:20 <syntaxfree> it doesn't dwell much on category theory.
05:04:22 <quicksilver> (although I think the *programming* is quite enlightening from a category theorists perspective)
05:04:54 <syntaxfree> It just throws a few concepts and diagrams, and then applies it to a state monad!
05:05:04 <quicksilver> a lot of concepts and diagrams
05:05:16 <quicksilver> and I don't find most of them helpful to the goal of using monads in programming
05:06:02 <syntaxfree> I quote from the tutorial itself :)
05:06:05 <syntaxfree> "It's like talking about electricity without using calculus. Good enough to replace a fuse, not good enough to design an amplifier."
05:06:26 <quicksilver> We are in Set category. Take an set A, and let's define the following functor: X |-> (X×A)^A
05:06:39 <quicksilver> IMO this language is totally alienating to your typical programmer
05:07:11 <quicksilver> Cheery: yes, you can acheive that
05:07:12 <SamB> hootay!
05:07:22 <quicksilver> Cheery: although your initial question was not very well formed :)
05:07:24 <syntaxfree> I'm sure the calculus was alienating to typical civil engineers once. Aren't we glad it was forcefully introduced, though?
05:07:43 <quicksilver> yes, but I don't accept the analogy
05:07:44 <Cheery> lol. :) quicksilver I shall compensate my bad english with haskell.
05:07:58 <syntaxfree> I mean, engineering faced the invasion of formal mathematics in the mid-1800s. Economics faced that in the 1930s/1940s.
05:08:08 <SamB> what do civil engineers do?
05:08:22 <syntaxfree> I mean, knowing physics was considered "useless" for engineers.
05:08:29 <syntaxfree> SamB: build roads, bridges, etc.
05:08:32 <SamB> ah.
05:08:34 <SamB> bridges
05:08:37 <SamB> I was wondering
05:08:48 <syntaxfree> I keep on using the bridge analogy on Reddit.
05:08:49 <SamB> yeah, you definately want them to know calculus ;-)
05:09:02 <quicksilver> syntaxfree: I continue to agree, and continue to find the analogy invalid :)
05:09:07 <SamB> you don't want them to design bridges that go harmonic motion!
05:09:13 <quicksilver> I really don't think knowing category theory is necessary to be a good programmer
05:09:22 <quicksilver> nor do I think it's even particularly helpful
05:09:29 <syntaxfree> "Would you rather walk on a bridge designed by someone who used calculus-based physics, or by someone who built progressively larger "unit tests" made of cardboard?"
05:09:47 <syntaxfree> I'm not saying "knowing category theory".
05:09:59 <syntaxfree> Your typical engineer doesn't know quantum mechanics or even real analysis either.
05:10:07 <Cheery> quicksilver: I find it helpful to know where monads came from.
05:10:14 <quicksilver> Cheery: I find it interesting
05:10:19 <quicksilver> Cheery: but not particularly important
05:10:19 <syntaxfree> but there's a difference between knowing real analysis and knowing The Calculus.
05:10:34 <quicksilver> syntaxfree: right. but The Calculus can be (and is) used To Calculate
05:10:39 <Cheery> like it's helpful to know where people comes from when you study human behavior.
05:10:51 <quicksilver> Category Theory is very abstract, contains few general theorems
05:11:00 <quicksilver> and programming does not normally involve applying these theorems to your programs
05:11:03 <syntaxfree> that's the difference between delving into Freyd and knowing the cat theory in the Crash Monad Tutorial.
05:11:25 <syntaxfree> quicksilver: The Calculus basically involves understanding a few *concepts*.
05:11:30 <syntaxfree> General properties of functions.
05:11:32 <syntaxfree> Continuity
05:11:34 <syntaxfree> Limits.
05:11:53 <SamB> quicksilver: how do you know?
05:11:59 <quicksilver> SamB: how do I know which part?
05:12:05 <SamB> <quicksilver> and programming does not normally involve applying these theorems to your programs
05:12:19 <SamB> maybe it does, but you never noticed it was those theorems?
05:12:25 <quicksilver> syntaxfree: I want my engineers to understand calculus because they use it to perform calculations
05:12:26 <syntaxfree> I mean, differentiation and integration rules are available at google's distance.
05:12:30 <quicksilver> SamB: in that case it wouldn't matter
05:12:38 <syntaxfree> but why the hell are they differentiating?
05:12:44 <SamB> quicksilver: it might save you time to know the general versions?
05:12:48 <quicksilver> syntaxfree: calculations which influence design and safety
05:12:55 <quicksilver> syntaxfree: that's *important*
05:13:06 <SamB> quicksilver: CT could influence design
05:13:09 <quicksilver> I don't believe category theory is a similarly *important* tool in writing programs
05:13:12 <syntaxfree> That's in the middle. It's neither being an algorithm executing machine, nor knowing 17 proofs to the Ascoli-Arzela Lemma.
05:13:27 <syntaxfree> quicksilver: nor did engineers in the 1850s, or economists in the 1940s.
05:13:39 <quicksilver> SamB: It might save time to know the general versions, and that's a very interesting idea, of which I'm interested to read examples
05:13:44 <quicksilver> SamB: I have seen a few examples
05:13:47 <SamB> I want to know why my micro course did *not* involve calculus
05:13:53 <SamB> I felt totally ripped off :-(
05:13:56 <quicksilver> SamB: however it's perfectly possible to write good programs without
05:14:18 <quicksilver> SamB: CT does influence design sometimes, the CaML compiler being the obvious, and massive example
05:14:20 <SamB> though I suppose I should have noticed it didn't have Calc I as a prerequisite, I suppose...
05:14:34 <quicksilver> SamB: but nonetheless most program designs do no require categorical insight
05:14:48 <quicksilver> I'm not suggesting category theory is useless, far from it.
05:14:52 <syntaxfree> SamB: well, there are some introductory micro courses that are based just on graph-waving.
05:14:53 <quicksilver> I *am* suggesting that it isn't a requirement.
05:15:02 <SamB> syntaxfree: pretty much!
05:15:03 <syntaxfree> "Hey, looky, supply crosses demand."
05:15:06 <quicksilver> and further, that making it a perceived requirement alienates people.
05:15:17 <quicksilver> which is why I don't like syntaxfree's choice of monad tutorial.
05:15:27 <SamB> I tried to figure out what derivatives we were approximating
05:15:28 <syntaxfree> SamB: that's basically good enough to, uh, understand that supply crosses demand iff you're willing to believe it.
05:15:29 <SamB> sometimes
05:15:49 <syntaxfree> SamB: most of basic micro comes down to Kuhn-Tucker nonlinear programming.
05:15:50 <Cheery> quicksilver: Like. "Oh noe, Haskell requires me to know A B and C. No way I could ever program with it!"
05:15:57 <syntaxfree> The basic micro they teach in econ 101 anyway.
05:16:06 <syntaxfree> Modern micro is based on differential manifold theory.
05:16:11 <SamB> syntaxfree: I'm pretty sure supply always crosses demand
05:16:22 <araujo> http://www.timestretch.com/FractalBenchmark.html
05:16:23 <lambdabot> Title: Ruby, Io, PHP, Python, Lua, Java, Haskell, and Plain C Fractal Benchmark
05:16:31 <SamB> unless the good is impossible to make
05:16:31 <araujo> Haskell For Scripting!
05:16:35 <syntaxfree> SamB: that's really not a trivial fact.
05:16:36 <Cheery> if you are afraid from that, as an ex-h-noob, I know that was exactly my feeling year ago. :)
05:16:44 <ttmrichter> I agree with quicksilver: that monad tutorial will turn off prospective Haskell hackers, not make them more effective programmers.
05:16:57 <SamB> syntaxfree: hmm.
05:17:06 <quicksilver> Cheery: Personally, I'm a fan of the argument "Haskell is a good language, and perfectly learnable by any competent programmer"
05:17:16 <syntaxfree> quicksilver: the 1850 bridge technology was perfectly operable without the calculus.
05:17:16 <SamB> now you've got me interested in how you would prove it!
05:17:26 <SamB> is there some kind of free micro textbook around?
05:17:33 <quicksilver> Cheery: However I believe that there exist competent programmers who find abstract mathemetical notation a turn-off
05:17:34 <ttmrichter> Yes CT is necessary to, say, design a functional language.  But if you're using CT to write an accounting app?  You're WAAAAAAY over-engineering.  It would be like using calculus to build the deck out back of your house.
05:17:48 <SamB> quicksilver: okay, so they probably don't like Haskell anyway
05:17:48 <syntaxfree> SamB: I've got the standard advanced micro text-book, Mas Colell, Whinston & Green.
05:17:54 <quicksilver> Cheery: and I'm keen to push forward my view that that really isn't necessary to get to grips with it
05:18:00 <syntaxfree> It was scanned out, though, so it's like 200 or 300 megabytes.
05:18:04 <quicksilver> SamB: that is where I absolutely disagree
05:18:11 <Cheery> quicksilver: me too, I was one of such programmers who ignored some unfamiliar mathematics.
05:18:17 <SamB> quicksilver: well, they can read another tutorial then
05:18:32 <quicksilver> SamB: I think haskell is (and needs to be) accessible to programmers who don't have familiarity with discrete mathematics
05:18:35 <quicksilver> SamB: exactly!
05:18:37 <syntaxfree> again, the 1850 bridge technology was perfectly operable without the calculus.
05:18:45 <quicksilver> SamB: ergo, in my opinion, syntaxfree's tutorial is not the best :)
05:18:50 <quicksilver> syntaxfree: *nod* agreed
05:19:02 <syntaxfree> it's not *my* tutorial. Hell, I wish it was ;)
05:19:06 * quicksilver nods
05:19:10 <SamB> quicksilver: okay, I suppose I see your point about newbies maybe not being the best audience for this tutorial
05:19:12 <ttmrichter> I'll go a step further.  Most bridges built *TODAY* don't need calculus.
05:19:12 <quicksilver> it is, however, the one you are espousing :)
05:19:15 <syntaxfree> quicksilver: do you really wish we never moved past the 1850s in bridge technology?
05:19:22 <SamB> ttmrichter: but it doesn't hurt to have it
05:19:31 <syntaxfree> ttmrichter: maybe; I'm not knowledgeable about bridges.
05:19:35 * SamB is majoring in engineering as an excuse to learn all this stuff
05:19:51 <ttmrichter> If you're building a deck, using calculus is waaaaaaay overkill.  The right tool for the job and all that.
05:19:53 <syntaxfree> ttmrichter: would you rather churn out cheaply paid "bridgeers" that didn't have to learn the calculus?
05:20:09 <SamB> deckers!
05:20:14 <syntaxfree> I mean, they should know a thing or two about structural physics and whatnot.
05:20:16 <MarcWebe3> Does hs-plugins work with ghc-6.6? In gentoo its blocked. The homepage states hs-plugins requires GHC 6.4 or later..
05:20:25 <ttmrichter> syntaxfree: Yes.  If they're just building a damned footbridge over a stream in my backyard I'd rather not pay for Ph.D. candidate-level engineers.
05:20:46 <SamB> apparantly they make pharmacy students learn calculus-based physics here...
05:20:50 <syntaxfree> that is an interesting and bold statement, sir.
05:21:00 <ttmrichter> If I hire a contractor to build a deck, rules of thumb are more than sufficient and will likely get me my deck a whole lot faster.
05:21:08 <SamB> ttmrichter: why do you need any sort of engineer to build a footbridge?
05:21:15 <SamB> over a stream?
05:21:16 <syntaxfree> SamB: I keep wishing they'd teach calculus-based economics to everyone.
05:21:33 <Cheery> ttmrichter: the best thing would be that they'd be building somebody else's designed footbridge over a stream in your backyard. ;)
05:21:45 <ttmrichter> SamB: that's kind of my point.  I *DON'T* need an engineer to do it.  A handyman is just fine.  Just like I don't need a CT-theorist to write my ... I don't know, payroll system.
05:22:01 <syntaxfree> SamB: that'd eliminate a significant ammount of the political idiocy in the world.
05:22:12 <SamB> hmmm.
05:22:25 <SamB> syntaxfree: you mean politicians would need to take that?
05:22:27 <ttmrichter> Hell, I could build that footbridge myself in less than a day.
05:22:30 <syntaxfree> no, voters.
05:22:31 <SamB> or, better, statesmen?
05:22:33 <SamB> oh.
05:22:39 <SamB> I don't think you can enforce that...
05:22:48 <syntaxfree> I know, I know.
05:22:55 <SamB> calculus is too much for some
05:23:05 <syntaxfree> Anyway, computer programming is different from bridge-building in that you can just download readymade bridges if you need one.
05:23:06 <ttmrichter> And CT is too much for some (most, in fact) programming.
05:23:13 <ttmrichter> Yes.
05:23:15 <ttmrichter> Precisely.
05:23:26 <SamB> although I think I may have actually managed to express to my sister what a derivative is ;-)
05:23:30 <quicksilver> So, if you wish to evangelise haskell (which I do)
05:23:33 <syntaxfree> So you're not hiring a handyman to build a footbridge over the stream in your yard.
05:23:37 <ttmrichter> I can download Haskell and presume that the people who made the language did the hard design work on the type system so *I DON'T HAVE TO LEARN THE MATH BEHIND IT*.
05:23:49 <SamB> (though she *is* essentially taking a precalculus course)
05:23:53 <quicksilver> then it is 'bad PR' to suggest to people that they should try to understand set and category theory
05:23:53 <syntaxfree> YES. But you're telling people they CAN BE BRIDGE DESIGNERS.
05:24:02 <syntaxfree> I mean, people are downloading ugly pieces of crock all the time.
05:24:07 <syntaxfree> Software that crashes.
05:24:20 <SamB> syntaxfree: I would build my own bridge
05:24:31 <SamB> probably
05:24:31 <ttmrichter> My GHC occasionally crashes.
05:24:38 <ttmrichter> Despite the CT theorists behind it.
05:24:45 <syntaxfree> I've never seen it crash ; )
05:24:47 <SamB> ttmrichter: it needs more theory, probably
05:24:48 <ttmrichter> I'm not sure that's a direction you want to be travelling in.
05:24:55 <SamB> syntaxfree: you ain't seen much ;-)
05:25:14 <ttmrichter> You should sign up to the GHC bugs mailing list (whatever its name is).
05:25:16 <syntaxfree> SamB: I've seen it fail compilation in ugly ways. That's not really crashing :P
05:25:18 <ttmrichter> You'll see lots of crash reports.
05:25:20 <SamB> I assume "the impossible" counts as a crash?
05:25:35 <ttmrichter> I would say "the impossible happened" is a crash....
05:25:38 <earthy> hm. oddness. my code is doing 211861188 typecasts
05:25:53 <xerox> earthy: what does it do?
05:25:59 <syntaxfree> anyway, yeah, all the CT theory out there hasn't gotten us "perfect" software or nothing approaching it. So what?
05:26:14 <SamB> there is no perfect software ;-P
05:26:20 <ttmrichter> You're the one who brought up "downloading ... software that crashes".
05:26:26 <syntaxfree> People who know more than you or me seem to emphasize category theory as the way to improve the current state of software.
05:26:28 <ttmrichter> I just said you likely didn't want to travel that path.
05:26:29 <SamB> except maybe this program I have here written in "null"
05:26:37 <ttmrichter> I agree with said people.
05:26:45 <syntaxfree> YES. What I'm saying is, the methodologies we have are *far from ideal*.
05:26:52 <earthy> xerox: cast Int to Word in dealing with an IntMap
05:26:53 * SamB goes to run "touch true.null"
05:26:53 <syntaxfree> Rallying against improvement is, uh, odd.
05:26:53 <ttmrichter> But those people also seem to be dedicated to encapsulating said CT, not forcing people to learn it.
05:27:12 <SamB> hmm.
05:27:18 <syntaxfree> I'm not forcing anything. I'm just saying I recomend this really hand-wavey explanation of what monads are to beginners.
05:27:20 <SamB> so, not for beginners?
05:27:21 <ttmrichter> Simon Peyton-Jones, for example, seems to be interested in bringing explanations of Haskell down from the lofty ivory towers into the real world.
05:27:25 <syntaxfree> and it *is* really hand-wavey./
05:27:28 <earthy> where the keys are Ints, but cast to machine words to do the PATRICIA map datastructure speedily
05:27:29 <fasta>  runInteractiveProcess "xzvg" ["path_to_png_file"] Nothing Nothing >>= \(_,_,_,pid) -> waitForProcess pid
05:27:34 <syntaxfree> it's not a freaking text-book.
05:27:37 <fasta> Why doesn't this work?
05:27:41 <syntaxfree> It's a 30-minute tutorial!
05:27:42 <ttmrichter> It's also gibberish to 99% of working programmers, I'd guess.
05:27:46 <fasta> I get Exitcode 127
05:27:58 <ttmrichter> It's purest pen-scratchings.
05:28:07 <fasta> When I run xzvg on the commandline when thast argument, it does work.
05:28:13 <Slarba> the scariest/hardest thing about monads is the word "monad"
05:28:17 <ttmrichter> With little connection to anything tangible that can actually be useful to the work-a-day programmer.
05:28:19 <Syzygy-> Hehe
05:28:22 <xerox> earthy: You might use directly Data.Map Word a instead of using IntMap . fromIntegral ?
05:28:22 <ttmrichter> Slarba: I agree.
05:28:24 <SamB> fasta: does it need an absolute path?
05:28:36 <syntaxfree> the scariest thing about monads is grokking type classes first.
05:28:38 <fasta> SamB: No, but better safe then sorry.
05:28:41 <ttmrichter> Once I grokked what a Monad was, I slapped my forehead and went "that's IT?!?!"
05:28:46 <SamB> @hoogle runInteractiveProcess
05:28:47 <Syzygy-> Yeah. Once you realize that a monad is nothing other than a monoid in a specific connected category, the rest is easy...
05:28:47 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
05:28:49 <fasta> SamB: than*
05:28:54 <SamB> @doc System.Process
05:28:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
05:28:54 <quicksilver> syntaxfree: I think we have a communication disconnect
05:28:55 <Slarba> ttmrichter: that happened to me too :D
05:29:01 <quicksilver> syntaxfree: that is *so* not hand-wavy
05:29:04 <Syzygy-> (I think it's the endofunctor category you'd want...)
05:29:24 <quicksilver> "..For each object a there is a unit arrow, ida: a  a, such that for any f: a  b the following is true: ida ° f = f, and for any g: c  a we have g ° ida = g..."
05:29:25 <syntaxfree> a monad is an endofunctor on the category of types.
05:29:28 <ttmrichter> Slarba: I'm still a little hazy on what makes a Functor different from ordinary, everyday "map", though.
05:29:35 <quicksilver> this is nothing like hand-wavy
05:29:45 <quicksilver> this is, to the ordinary mortal, obscure mathematical language.
05:29:50 <Slarba> ttmrichter: map is a special case of fmap?
05:29:55 <Syzygy-> syntaxfree: There is a way to view it as a monoid too though.
05:30:00 <ttmrichter> slarba: That's what I've been assuming.
05:30:01 <syntaxfree> I know, I know.
05:30:02 <Syzygy-> You just have to pick the right category to work in.
05:30:07 <Cale> A monad is a monoid object in the endofunctor category.
05:30:08 <syntaxfree> Yes, I know :)
05:30:11 <Slarba> fmap is more general
05:30:20 <Slarba> function maps elements, functor maps structures
05:30:31 <Cale> A monoid is a monoid object in the category of sets.
05:30:49 <Syzygy-> Cale: That's it. Thanks.
05:30:56 <syntaxfree> ttmrichter: a category is a bunch of things together with "functions" (in a loose sense) between them.
05:31:27 <syntaxfree> A functor in Haskell is, therefore, a type constructor (that takes types to types) and a fmap (that takes a -> b to F a  -> F b)
05:31:28 <ttmrichter> Slarba: that's what I had guessed from seeing fmap in use.  But again it's not particularly well spelled-out in the documentation on it.  I really do think there's a need for a "Haskell for the Working Programming" book.
05:31:48 <Slarba> ttmrichter: yeah.
05:31:48 <syntaxfree> ttmrichter: two-word explanation: fmap = liftM
05:32:24 <quicksilver> only if you've already grokked monads, which are strictly harder than functors :) But if you do grok them in that order, then yes.
05:32:25 <syntaxfree> I should say liftF
05:32:36 <syntaxfree> yes, yes.
05:32:54 <Cale> liftM = fmap, but not the other way around ;)
05:33:02 <syntaxfree> anyway, fmap lifts functions from the world of "plain types" to the world of "F types".
05:33:08 <syntaxfree> I mean liftF !
05:33:15 <ttmrichter> I did finally grok monads.  With that whole "That's IT?!?!?!" reaction and everything.  I suspect that when I finally grok (I'm close) Functors, I will do the same thing.
05:33:26 <Cale> ttmrichter: There's not much to them
05:33:26 <quicksilver> ttmrichter: Functors are Monads which only have liftM
05:33:33 <quicksilver> ttmrichter: but don't have 'bind'
05:33:37 <ttmrichter> The problem is my math classes are well over 20 years behind me.
05:33:43 <quicksilver> ttmrichter: (or fail)
05:33:54 <xerox> Let's answer in majestic stereo.
05:33:55 <Cale> ttmrichter: Functors are just data structures to which you can apply a function to all the "elements" they contain.
05:33:58 <quicksilver> ttmrichter: they generally have 'return' but don't technically need it
05:34:10 <Cale> At least, that's about all you have to think of it in Haskell.
05:34:17 <syntaxfree> ttmrichter: which might be why you're so bitter about the introduction of mathematics into programming? I mean, it's okay. I don't know one fourth of what I should know either.
05:34:31 <syntaxfree> I'm not campaigning around for "That stuff I don't know is useless!" though.
05:34:33 <nomeata> @type sequence
05:34:35 <lambdabot>     Ambiguous occurrence `sequence'
05:34:35 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
05:34:36 <ttmrichter> The explanations of them assume too much of my memory.  I'm basically having to relearn all my old abstract math from 25 years ago -- while I'm stuck in a country where I have no access to math texts I can understand.
05:34:39 <Cale> "elements" is in scare quotes though, since often it's a little unusual to think of the values you're applying the function to in that way
05:34:46 <nomeata> @type sequence.sequence
05:34:49 <lambdabot>     Ambiguous occurrence `sequence'
05:34:49 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
05:34:56 <nomeata> @type Monad.sequence.Monad.sequence
05:34:59 <ttmrichter> I'm not saying it's useless.
05:34:59 <lambdabot> forall a. [[a]] -> [[a]]
05:35:03 * integral points at mathworld and other websites with handy maths definitions and statements of theorems
05:35:05 <nomeata> @type Monad.sequence.Monad.sequence.Monad.sequence
05:35:08 <lambdabot> forall a. [[a]] -> [[a]]
05:35:11 <ttmrichter> I'm saying that it's useless to most working programmers.
05:35:14 <nomeata> > (Monad.sequence.Monad.sequence.Monad.sequence) ["10"]
05:35:15 <lambdabot>   Not in scope: `Monad.sequence'
05:35:22 <bd_> > sequence [(*2)] 4
05:35:23 <Slarba> btw I'm working on a Haskell tutorial written in finnish
05:35:26 <ttmrichter> And that there are better approaches to introducing the subjects than tossing off equations.
05:35:26 <nomeata> > (sequence.sequence.sequence) ["10"]
05:35:28 <xerox> :t (+2) `fmap` (return 10 :: IO Int)
05:35:30 <Slarba> any finns?
05:35:30 <lambdabot> IO Int
05:35:32 <syntaxfree> most working programmers are in firmly in the thedailywtf world.
05:35:32 <fasta> SamB: I want the program to run the command and do nothing until I close the picture viewer.
05:35:34 <bd_> hm
05:35:34 <Cale> ttmrichter: But yeah, basically, a functor is just a data constructor F, so that for each type a, (F a) is a new type, together with a function map :: (a -> b) -> F a -> F b
05:35:47 <Cale> or, as it's called these days, fmap
05:35:57 <SamB> fasta: ah.
05:36:03 <Cale> This is conveyed by the class declaration for Functor
05:36:05 <Slarba> I need reviewers :)
05:36:07 <Cale> class Functor f where
05:36:07 <nomeata> > (sequence.sequence.sequence) ["1","0"]
05:36:10 <SamB> well, I don't know how to do that
05:36:16 <Cale>    fmap :: (a -> b) -> f a -> f b
05:36:22 <quicksilver> ttmrichter: inituitively it's a container, and map means 'apply f to every element in your container'
05:36:24 <SamB> but it should not be too hard...
05:36:30 <nomeata> donât try this at home: (sequence.sequence.sequence) ["10","10"]
05:36:35 <ttmrichter> I'm beginning to regret mentioning functors.  :)  I'm close on those -- to the point that I suspect the next slot for practice I set up will give me that moment of Zen enlightenment.
05:36:42 <fasta> SamB: I thought that waitForProcess would do it...
05:37:11 <xerox> ttmrichter: as Cale says, there's not much to them, I think you should read his explanations. There is much traffic, though.
05:37:14 <syntaxfree> which reminds me of my question..
05:37:21 <syntaxfree> are Prolog functors cat theory functors?
05:37:33 <syntaxfree> I mean, ML functors aren't, we've established that.
05:37:49 <Cale> syntaxfree: no, I don't think so, but let me recall what exactly they were
05:37:57 <Cale> oh, right
05:37:59 <Cale> no, they're not
05:38:08 <ttmrichter> xerox, Cale: I'm at the point of recognising and understanding the structures.  It's the applications I'm still fuzzy on, hence the need for the next practice session to see how they're put to use and how they can be bent and twisted.
05:38:13 <syntaxfree> they look scarily so. But no claim is made in the book I'm reading.
05:38:13 <fasta> SamB: never mind
05:38:23 <fasta> SamB: I made a typo :(
05:38:31 <SamB> heh
05:38:36 <xerox> ttmrichter: do you understand map, the list function?
05:38:46 <syntaxfree> (I'm reading Nilson & Maluszinsky, "Logic, programming and prolog")
05:38:51 <fasta> (Transposition of one letter of a program I normally never use. )
05:38:59 <xerox> > fmap (^2) [1..10]
05:39:01 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
05:39:05 <ttmrichter> xerox: Yes.  I've been using map since long before using Haskell.
05:39:06 <xerox> > fmap (^2) (Just 10)
05:39:08 <lambdabot>  Just 100
05:39:12 <xerox> > fmap (^2) Nothing
05:39:13 <lambdabot>  Nothing
05:39:19 <syntaxfree> xerox: yay! Fantastic example :)
05:39:23 <the_dormant> syntaxfree: is the book interesting?
05:39:35 <xerox> It just applies the function to the container without modifying the structure of the container itself.
05:39:38 <ttmrichter> > map (^2)[1..10]
05:39:39 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
05:39:45 <ttmrichter> What's the difference?
05:39:47 <syntaxfree> the_dormant: it introduces a formal propositional calculus before even talking about Prolog. I like that.
05:39:50 <xerox> :t map
05:39:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:39:53 <Cale> ttmrichter: fmap is more general
05:39:54 <xerox> :t fmap
05:39:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:39:57 <syntaxfree> I also need to brush up on my logic as well, so.
05:39:58 <Slarba> > fmap (^2) [1..10]
05:39:59 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
05:40:02 <Slarba> :)
05:40:06 <ttmrichter> > map (^2) (Just 10)
05:40:07 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe t'
05:40:08 <syntaxfree> the_dormant: the good thing: it's freely available.
05:40:09 <xerox> ttmrichter - instance Functor [] where fmap = map
05:40:13 <Cale> Really, we ought to get rid of the list-specific map and replace it with fmap.
05:40:16 <syntaxfree> http://www.ida.liu.se/~ulfni/lpp/copyright.shtml
05:40:17 <lambdabot> Title: Logic, Programming and Prolog (2ed)
05:40:18 <ttmrichter> Got it.
05:40:21 <ttmrichter> Just saw it.
05:40:28 <ttmrichter> And yes, it's a "Well, DUH!" moment.  :D
05:40:30 <syntaxfree> it was published by Wiley & sons and all, but copyright was reverted to authors.
05:40:31 <xerox> ttmrichter - instance Functor Maybe where fmap f (Just x) = Just (f x); fmap _ Nothing = Nothing
05:40:38 <Cale> Now, to bend your mind a little further:
05:40:49 <Cale> > (+1) `fmap` (*3) `fmap` [1,2,3,4,5]
05:40:51 <lambdabot>  [4,7,10,13,16]
05:40:58 <Cale> oh, wait :)
05:41:01 <xerox> ttmrichter - Try to define the |instance Functor Tree| for |data Tree a = Leaf a | Branch (Tree a) (Tree a)|
05:41:02 <Cale> > ((+1) `fmap` (*3)) `fmap` [1,2,3,4,5]
05:41:04 <lambdabot>  [4,7,10,13,16]
05:41:23 <Cale> the first one might have made sense, the second one is certainly stranger :)
05:41:36 <xerox> I got that as an exercise from shapr when I was learning haskell some years ago (:
05:41:39 <Cale> > ((+1) `fmap` (*3)) 10
05:41:40 <lambdabot>  31
05:41:42 <syntaxfree> @instances Functor
05:41:44 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:41:49 <quicksilver> surely they're the same, `fmap` associates left ?
05:41:51 <Cale> hence, fmap is function composition as well.
05:41:53 <syntaxfree> there it is. The reader functor :)
05:42:14 <syntaxfree> > fmap (+1) (2,3)
05:42:15 <Cale> quicksilver: probably it does, but if you read it as if it associated to the right, it wouldn't seem so odd.
05:42:16 <lambdabot>  (2,4)
05:42:19 <ttmrichter> Hmmm...  Interesting, Cale.  Didn't realise it could be composed.
05:42:21 <quicksilver> Cale: *nod*
05:42:35 <quicksilver> ttmrichter: Cale is playing with your mind
05:42:42 <quicksilver> ttmrichter: there were two different Functors there
05:42:43 <Cale> ttmrichter: This comes from the instance of Functor for ((->) e)
05:42:47 <xerox> instance Functor ((->) e) where fmap f g = f . g
05:42:54 <syntaxfree> as I said, the reader functor :)
05:43:09 <syntaxfree> which common monad combinators rely on the definition of fmap?
05:43:21 <xerox> syntaxfree: bind.
05:43:30 <the_dormant> syntaxfree: cool
05:43:33 <syntaxfree> xerox: uh, but you usually supply your own fmap.
05:43:35 <Cale> ((->) e) is also a monad, often referred to as the reader monad
05:43:35 <xerox> :t (join .) . liftM
05:43:37 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
05:43:57 <ttmrichter> Some of this stuff is beginning to verge on executable line noise.  Partially from the intervening chatter.  :D
05:44:03 <Cale> This is because it captures the idea of computations which read from an environment
05:44:14 <xerox> syntaxfree: ah I see what you mean.
05:44:18 <Cale> Yeah, it's busy in here today :)
05:44:42 <quicksilver> syntaxfree: you could define bind using fmap and join. That's the way I tend to think of it, but it's not the Haskell Way
05:44:45 <Cale> > (do x <- (+1); y <- (*2); return (x,y)) 10
05:44:47 <lambdabot>  (11,20)
05:45:00 <syntaxfree> quicksilver: I know. I've picked up that habit from sigfpe.
05:45:06 <xerox> ?pl \amb f -> amb >>= return . f
05:45:07 <lambdabot> (. (return .)) . (>>=)
05:45:11 <Cale> But if that hurts, perhaps better to put it off until later :)
05:45:19 <xerox> yuck.
05:45:33 <syntaxfree> Cale: yay. The proper use of the reader monad just clicked!
05:45:46 <metaperl>           let (here, y : there) = splitAt i xs   -- i'm not familiar with here, y as pattern matching
05:45:46 <syntaxfree> (I thought of it as being point-free programming fodder)
05:46:12 <Cale> metaperl: (here, (y : there))
05:46:14 <Syzygy-> syntaxfree: Enlighten me?
05:46:16 <quicksilver> metaperl: it's a tuple (a,b) where b is a list, so b = y : there
05:46:18 <xerox> ?pl \f amb -> amb >>= return . f
05:46:18 <lambdabot> fmap
05:46:20 <xerox> Silly pl.
05:46:27 <metaperl> Cale - oh I see. thanks
05:46:56 <syntaxfree> Syzygy-: about?
05:47:06 <Syzygy-> Proper interpretation of the reader monad.
05:47:13 <syntaxfree> 11:42 < Cale> > (do x <- (+1); y <- (*2); return (x,y)) 10
05:47:14 <xerox> Syzygy- - Environment monad.
05:47:15 <Syzygy-> Since you now understand it, you might be able to share. :P
05:47:28 <Syzygy-> xerox: Huh?
05:47:40 <xerox> Syzygy- That is, a State where you can only |get|, using |ask|.
05:47:42 <syntaxfree> > do { x<- (+5); return x } 10
05:47:43 <lambdabot>  Parse error
05:47:50 <Syzygy-> Hmmmmm....
05:47:52 <syntaxfree> > (do {x<-5; return x;}) 10
05:47:53 <lambdabot>   add an instance declaration for (Num (t1 -> t))
05:47:53 <lambdabot>     In a 'do' expression: x...
05:48:09 <syntaxfree> > (+5) >>= 10
05:48:10 <lambdabot>   add an instance declaration for (Num (a -> a -> b))
05:48:21 <christine_c> hi people
05:48:26 <xerox> Syzygy- You can also run |local| computations with a different environment, which would not escape the caller.
05:48:29 <Syzygy-> > (+) >>= (*) 10
05:48:30 <lambdabot>   add an instance declaration for (Num (a -> a))
05:48:37 <christine_c> do you know some sites working on compiler design
05:48:42 <Syzygy-> > (+) >>= (*) (+1)
05:48:42 <lambdabot>   add an instance declaration for (Num (a -> a))
05:48:50 <Syzygy-> > (+1) >>= (*)
05:48:52 <lambdabot>  <Integer -> Integer>
05:48:54 <Syzygy-> > (+1) >>= (*) 10
05:48:55 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
05:48:55 <lambdabot>     Probabl...
05:48:55 <syntaxfree> > (+1) >>= (*2) $ 5
05:48:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
05:48:57 <lambdabot>     Probabl...
05:48:58 <christine_c> the basic of compiler design?
05:49:03 <xerox> > ((^2) >>= (*)) 10
05:49:04 <lambdabot>  1000
05:49:25 <xerox> ?docs Control.Monad.Reader
05:49:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
05:49:44 <syntaxfree> > (do { x<- (^2); y<-(*) x; return y;}) 10
05:49:46 <lambdabot>  1000
05:49:47 <xerox> Syzygy-: do the types of the functions defined there make sense?
05:50:31 <Syzygy-> xerox: I must admit I haven't really looked into it - my comment was very much a direct response to (14:43) ( syntaxfree) Cale: yay. The proper use of the reader monad just clicked!
05:50:35 <syntaxfree> > (liftM2 (.) (^2) (*)) 10
05:50:36 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> c
05:50:36 <lambdabot>     Probabl...
05:53:02 <xerox> > liftM2 (.) (^) (*) 10 3
05:53:04 <lambdabot>  1000000000000000000000000000000
05:53:33 <xerox> *click*  :-P
05:54:29 <xerox> > liftM2 (.) (+) (^) 10 3
05:54:31 <lambdabot>  1010
05:55:36 <fasta> Is there a function that does runInteractiveProcess and waits for it to complete?
05:55:57 <xerox> ?hoogle waitForProcess
05:55:57 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
05:56:13 <xerox> ?hoogle runInteractiveProcess
05:56:14 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
05:56:28 <xerox> There you go.
05:56:36 <fasta> xerox: No, I already did that
05:56:37 <quicksilver> fasta: runProcess?
05:56:47 <fasta> quicksilver: possibly
05:56:52 <fasta> quicksilver: I don't know. Do you?
05:57:00 <quicksilver> fasta: I know what runProcess does.
05:57:03 <quicksilver> I don't know what you want.
05:57:11 <quicksilver> runProcess will run a program and wait for it to terminate.
05:57:22 <quicksilver> or, I thought it did
05:57:25 * quicksilver suddenly unsure
05:57:29 <gds> @type runProcess
05:57:31 <lambdabot> Not in scope: `runProcess'
05:57:33 <fasta> quicksilver: I want to do foo = runInteractiveProcess <blaat> >>= \(_,_,_,pid) -> waitForProcess pid
05:58:02 <quicksilver> fasta: OK, and what goes wrong when you try that?
05:58:13 <fasta> quicksilver: try what?
05:58:18 <fasta> quicksilver: my code is correct
05:58:31 <quicksilver> fasta: so what's the problem?
05:58:40 <chessguy> 'morning haskellers
05:58:40 <fasta> I just wanted to know whether there's an API function that already does that.
05:58:45 <quicksilver> oh
05:58:48 <quicksilver> no, I don't think so
05:58:59 <fasta> ok, thanks
05:59:06 <MarcWebe3> instance Fail () => TypeEqFalse x x   Wow to read this? Its from HList
06:00:26 <xerox> haha.
06:00:41 <chessguy> xerox!
06:00:52 <ttmrichter> chessguy: "Morning"?!
06:00:58 <chessguy> ?time
06:00:59 <lambdabot> Local time for chessguy is Wed Feb 21 08:58:56
06:01:03 <ttmrichter> ?time
06:01:07 <xerox> Hi.
06:01:14 <ttmrichter> Heh.  No time for me.
06:01:22 <chessguy> ?localtime ttmrichter
06:01:28 <ttmrichter> ?localtime ttmrichter
06:01:36 <ttmrichter> I exist outside of time....  :D
06:01:38 <chessguy> so, i have an interesting problem
06:02:02 <ttmrichter> Why won't lambdabot tell my time?  What incantations have I missed?
06:02:11 <chessguy> i'm trying to write a function randomSubTree :: Tree a -> State GlobalState (Tree a)
06:02:25 <chessguy> where GlobalState has a RNG
06:02:42 <fasta> chessguy: still working on genetic programming?
06:02:44 <chessguy> and i want to choose a random subtree of the tree i'm given, without knowing the size of it
06:02:53 <chessguy> fasta, yup
06:03:01 <fasta> chessguy: is it progressing?
06:03:03 <chessguy> making some progress too
06:03:04 <quicksilver> there would be more than one way to define random tree, I imagine
06:03:11 <xerox> chessguy: you might generate a random path.
06:03:32 <quicksilver> indeed, there's more than one way to define subtree :)
06:03:48 <chessguy> my only algorithm so far has been to map (,treeSize) over the whole tree
06:04:12 <chessguy> and then choose a random number from 1 to n, the size of the whole tree, and find the nth node
06:04:48 <chessguy> quicksilver, by subtree i just mean 'tree rooted at any node in a given tree'
06:05:02 <chessguy> xerox, how would you go about doing that?
06:05:16 <quicksilver> chessguy: and how would you like the probabilities to work out?
06:05:19 <xerox> chessguy: how's your Tree datatype defined?
06:05:51 <chessguy> xerox, using Data.Tree
06:06:00 <xerox> Oh cool.
06:06:05 <chessguy> quicksilver, any node in the tree should be an equally likely root
06:06:12 <xerox> I'll give it a try.
06:06:17 <xerox> ?docs Data.Tree
06:06:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
06:06:19 <ddarius> I'm way late but: functors are category homomorphisms and there's more to them than the "type constructor" and fmap, they must also satisfy certain (simple) laws (namely the preservation of the category structure, i.e. id and .)
06:06:33 <fasta> chessguy: did you read the Sussman paper about robustness?
06:06:48 <chessguy> hmm, doesn't ring a bell
06:06:54 <fasta> chessguy: I think you will like it
06:06:55 <chessguy> Sussman as in Abelson and Sussman?
06:06:59 <fasta> chessguy: yes
06:07:06 <chessguy> link?
06:07:52 <fasta> chessguy: They took the file off-line :(
06:08:03 <chessguy> awww.
06:08:03 <fasta> http://programming.reddit.com/info/15db8/comments
06:08:05 <lambdabot> Title: "Building robust systems" by Gerald Jay Sussman [PDF] (reddit.com)
06:10:06 <fasta> http://64.233.183.104/search?q=cache:caujSttFrqMJ:swiss.csail.mit.edu/classes/symbolic/spring07/robust-systems.pdf+building+robust+systems&hl=nl&ct=clnk&cd=3&gl=nl&client=firefox-a
06:10:09 <lambdabot> http://tinyurl.com/yvq9do
06:10:18 <fasta> That's the google cache version
06:10:25 <chessguy> ah, nice
06:10:47 <fasta> chessguy: not very technical, but has some nice points
06:10:55 <sendark> @hooogle map
06:10:56 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
06:10:56 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
06:10:56 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
06:11:07 <sendark> @hooogle Prelude.map
06:11:08 <lambdabot> No matches, try a more general search
06:11:27 <chessguy> thanks, i'll check it out
06:11:58 * Ulfalizer doesn't get the topic
06:12:06 <Ulfalizer> what does callCC relate to in haskell?
06:12:20 <quicksilver> the continuation monad?
06:12:28 <Ulfalizer> haven't used it
06:13:25 <Ulfalizer> i mean, what's the topic trying to say? is there some better "alternative" to callcc in haskell? is it a jab at scheme? is it just "omg, we're smart enough to know how to use it"? :)
06:14:43 <fasta> Ulfalizer: probably lazyness
06:14:56 <fasta> Ulfalizer: I am not sure either.
06:15:05 <fasta> Ulfalizer: although I have used callCC in Haskell
06:15:52 <Ulfalizer> i just learned about it in scheme yesterday and got curious
06:16:07 <quicksilver> Ulfalizer: I suspect the point is that rather than having callCC as a primitive, to be used unrestrictedly (and type-violatingly)
06:16:19 <Ulfalizer> ok
06:16:21 <quicksilver> Ulfalizer: we have encapsulated callCC into a type-safe box, to use when necessary
06:17:15 <fasta> quicksilver: it's not like that has only advantages.
06:17:25 <ddarius> Ulfalizer: No, no.  It's mostly the last option you listed.
06:17:27 <Ulfalizer> maybe "we know how to do callCC!" or "we know how to implement callCC!" would make more sense in that case though :)
06:17:38 <Ulfalizer> ddarius: ah, ok
06:17:43 <ddarius> It was prompted by a particular use of callCC.
06:18:02 <Ulfalizer> ok, so it's a kind of insider-topic? :P
06:18:35 <fasta> The most advanced use of callCC I have seen was in Scheme.
06:18:49 <ddarius> @google site:tunes.org "@topic-cons The Haskell programming language: we know when to use callCC!"
06:18:50 <lambdabot> No Result Found.
06:18:53 * syntaxfree is understanding knowthing.
06:19:04 <syntaxfree> s/knowthing/nothing! :)
06:19:20 * earthy is trying to understand parts of saude.gov.br
06:19:23 <syntaxfree> I mean, is callCC related to continuations?
06:19:26 <xerox> chessguy: do you have a Zipper for Data.Tree?
06:19:43 <syntaxfree> why saude.gov.br?
06:19:53 <earthy> but methinks a trip to Brasil isn't in the books for a couple of months at least
06:19:56 <quicksilver> syntaxfree: callwithCurrentContinuation
06:19:59 <quicksilver> syntaxfree: (yes, it is)
06:20:01 <chessguy> not handy
06:20:03 <earthy> does 'Febre Amarela' ring a bell?
06:20:35 <xerox> chessguy: I can't find one, but I think it's really straightforward to select subtrees with such a tool.
06:20:36 <syntaxfree> quicksilver: um, aren't continuations about passing a continuation function as an argument?
06:20:41 <syntaxfree> earthy: yellow fever?
06:20:42 <earthy> I was trying to ascertain whether or not the guilty mosquitoes are infected in my native municipality of Paranapanema.
06:20:43 <quicksilver> syntaxfree: yes
06:20:48 <quicksilver> syntaxfree: and that's with callCC does
06:20:53 <syntaxfree> so why a special directive?
06:20:56 <earthy> but the website doesn't really give me the current list, only the one for 2004
06:21:08 <quicksilver> syntaxfree: you need a directive to 'concretise' the current continuation
06:21:30 <quicksilver> syntaxfree: call/cc is lisps syntax to 'grab' the continuation at that time
06:21:32 <syntaxfree> ?
06:21:46 <xerox> chessguy: actually, I find some, but they are all about showing off Generic Haskell, or type-indexed datatypes.
06:22:04 <syntaxfree> well, nevermind. I'm trying to focus on something else.
06:22:10 <syntaxfree> I'll have to postpone understanding CPS>
06:22:12 <ddarius> syntaxfree: That's continuation passing style.
06:22:19 <earthy> CPS is fun
06:22:20 <Ulfalizer> you get the current continuation represented as a procedure passed to the procedure you provide as an argument to callcc
06:22:36 <chessguy> as i recall, there's a wiki page that has most of the code for a Tree zipper
06:22:57 <Ulfalizer> so you can just call it later on to get back to where you did the callcc
06:23:02 <chessguy> http://www.haskell.org/haskellwiki/Zipper
06:23:03 <lambdabot> Title: Zipper - HaskellWiki
06:23:13 <xerox> chessguy: we need one for Rose Trees.
06:23:18 <quicksilver> callcc is something like 'grab the current program counter and pass it to a procedure'
06:23:18 * earthy hopes -funbox-strict-fields is going to help my case
06:23:21 <chessguy> i'd think that could be adapted
06:23:25 <Ulfalizer> it's kinda lika a goto in a sense, but more dynamic..
06:23:31 <quicksilver> except that it handles variables and stuff correctly
06:23:36 <pjd> quicksilver: s/counter/call stack/
06:23:37 <earthy> but ghc does slow down quite a lot when compiling with -O2 -funbox-strict-fields
06:23:43 <fasta> Reified delimited continuations .... you've got to love those!
06:23:44 <xerox> Gerard Huet. The zipper. Journal of Functional Programming, 7(5):549â554, 1997.
06:23:54 <xerox> I need this paper, anybody knows how to get ahold of a copy of it
06:23:55 <xerox> ?
06:23:56 <quicksilver> pjd: yes, I was trying to appeal to a rather basic analogy
06:24:17 <quicksilver> xerox: try data.traversable, and the paper mentioned in the haddock for that module
06:24:27 <xerox> quicksilver: I specifically need that paper.
06:24:29 <pjd> quicksilver: sorry, was drive-by comment :)
06:24:36 <quicksilver> pjd: :)
06:24:40 <sendark> can anyone tell me what this means? \v -> (vars, doms, constrs, update_var asign var v)
06:24:49 <sendark> why is the v curried?
06:25:02 <earthy> http://journals.cambridge.org/article_S0956796897002864 doesn't help, xerox?
06:25:02 <xerox> I don't have to try anything, I need an implementation which resides in that publication.
06:25:03 <quicksilver> sendark: because it's inside a tuple
06:25:06 <Ulfalizer> syntaxfree: with continuation passing style every call is a tail call. you explicitly tell procedures where to go when they're finished by passing in a "continuation function".
06:25:06 <chessguy> xerox, hmm. http://okmij.org/ftp/Computation/Continuations.html looks interesting
06:25:08 <lambdabot> Title: Continuations and delimited control
06:25:24 <syntaxfree> That I get.
06:25:27 <Ulfalizer> it's somewhat like imperative programming in that first-this-then-that sense
06:25:28 <sendark> why do you need to curry something inside a tuple?
06:25:42 <quicksilver> sendark: what you're talking about isn't currying, actually
06:25:52 <quicksilver> what would you expect instead?
06:25:55 <xerox> earthy: does that site let you download the articles?
06:26:01 <pjd> you can also do CPS without tail calls using a trampoline loop
06:26:04 <quicksilver> simply (vars, doms, constrs, update_var asign var)
06:26:05 <quicksilver> ?
06:26:10 <xerox> In particular, 1997 Volume 7.
06:26:15 <earthy> it lets me. :)
06:26:21 <sendark> hmm no, because update_var takes 3 arguments
06:26:24 * earthy is looking at the pdf right now
06:26:26 <xerox> Issue 6.
06:26:26 <quicksilver> sendark: right
06:26:37 <quicksilver> sendark: so that v has to get in there somehow
06:26:39 <Ulfalizer> pjd: haven't heard of. my only experience with continuations comes from the nondeterministic evaluator in SICP.
06:26:40 * chessguy bribes earthy for a copy
06:26:43 <xerox> Hmmm.
06:26:44 <quicksilver> sendark: lambda-abstraction is how you do it
06:26:51 <Ulfalizer> *continuation passing style
06:26:52 <sendark> yea right, but there is nothing defining v
06:26:56 <sendark> its just there
06:27:02 <quicksilver> sendark: it's a function
06:27:03 * earthy looks at chessguy
06:27:06 <quicksilver> sendark: you supply v when you call it
06:27:09 <earthy> now, how would we get such a copy to you?
06:27:14 <quicksilver> :t \x -> (1,x)
06:27:17 <lambdabot> forall t t1. (Num t) => t1 -> (t, t1)
06:27:20 <sendark> ah
06:27:24 <sendark> ok that makes more sense
06:27:25 <pjd> Ulfalizer: it's a very tiny modification; instead of every tail call, you return a thunk that does the call
06:27:25 <quicksilver> >  ( \x -> (1,x) ) 7
06:27:26 * chessguy grins
06:27:27 <lambdabot>  (1,7)
06:27:44 <quicksilver> sendark: that's what \v means
06:27:48 <pjd> and then you stick everything in a loop that repeatedly calls each thunk to get the next thunk
06:27:52 <quicksilver> sendark: you can read it as 'Give me a 'v' and I will...'
06:28:00 <ddarius> pjd: That's how I made a Scheme interpreter in Javascript at one point.
06:28:29 <Ulfalizer> pjd: ah, ok
06:28:48 <sendark> cheers quicksilver
06:28:52 <pjd> so it's just explicit, low-budget tail calls, really
06:29:01 <Ulfalizer> yeah
06:30:05 <quicksilver> it's a fairly low-level distinct, certainly
06:30:28 <quicksilver> but 'CPS' a.k.a  'make everything a continuation' is more like a compilation technique
06:30:34 <Saizan> i think "current" in "call with current continuation" is a bit ambiguos, at first i that was referring to the continuation that was passed to the caller
06:30:34 <quicksilver> while continuations themselves are a programming technique
06:30:50 <quicksilver> (albeit one you can do great evil with)
06:30:57 <Saizan> s/i /i thought/
06:31:05 * xerox hugs Saizan 
06:31:16 <Slarba> damn gprs. it makes you hack haskell while commuting in a bus
06:31:26 * Saizan ghci xerox
06:31:27 <fasta> Is putStr "" optimized away?
06:31:56 <chessguy> xerox, ok, got the paper
06:32:22 * earthy prints out a copy to read while his ghc compiles;
06:32:26 <ddarius> Saizan: It's the continuation that is current at the location callCC is evaluated.
06:32:31 <chessguy> short paper
06:33:12 <ddarius> fasta: It depends on whether it flushes the buffer, if not it's actually possible that it does.
06:33:28 <Saizan> ?type callCC
06:33:33 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
06:33:46 <chessguy> and fairly simple if you've already seen the idea of a zipper
06:34:01 <fasta> ddarius: define it
06:34:12 <fasta> GHC?
06:34:39 <ddarius> putStr = mapM_ putChar
06:37:47 <xerox> Yuck, it's in OCaml.
06:38:13 <erider> good morning
06:38:32 <chessguy> xerox, and not very complete at that
06:39:37 <fasta> There are some bugs in that paper, IIRC
06:39:44 <emk> Syzygy-, syntaxfree, _frederik_: A minor twist on the Dist monad:
06:39:46 <emk> http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
06:39:48 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
06:40:24 <chessguy> xerox, anyway, i'm not sure i see how a zipper would help for this problem
06:40:33 <xerox> chessguy: I do (:
06:40:49 <chessguy> care to enlighten me?
06:41:02 <xerox> Let me see if the idea works.
06:41:50 <chessguy> if you assume you have a zipper and describe  me the algorithm, and i like it, i'll write the darn zipper myself, and send it to you
06:44:00 <emk> Gotta run, but I'll be around later tonight.
06:45:19 <xerox> chessguy: |let {walk 0 = id; walk 1 = down; walk 2 = left; walk 3 = right} in map walk . randomRs (0,3)
06:45:28 <xerox> actually
06:46:42 <xerox> Yeah, that.
06:46:49 <chessguy> hmmm
06:46:50 <xerox> |fst .|
06:46:57 <xerox> to discard the path.
06:47:40 <chessguy> that gives you an infinite random path
06:47:46 <xerox> Yeah, with a foldr it exits on id.
06:48:00 <chessguy> very interesting
06:48:23 <xerox> At least I hope.
06:48:35 <chessguy> so i'd choose a random number, and lop off that many steps
06:48:47 <xerox> Hmm.
06:49:00 <chessguy> ?hoogle randomRs
06:49:01 <lambdabot> Random.randomRs :: (Random a, RandomGen b) => (a, a) -> b -> [a]
06:49:01 <lambdabot> System.Random.randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
06:49:05 <xerox> I'd just generate the path, and walk it, and exit when needed.
06:49:10 <Saizan> i don't think that gives you an equal probability for all the nodes
06:49:19 <chessguy> Saizan, that's what i'm wondering too
06:49:33 <Saizan> xerox: "needed"?
06:49:38 <earthy> unless you dynamically weight the seen nodes
06:50:12 <earthy> (as in the ages old question: generate a random line from a text file, where you can only keep 1 line in memory at any one time)
06:50:42 <earthy> (and can only sequentially read through the file, and don't get to determine the filesize in advance)
06:51:06 <chessguy> earthy, is that possible?
06:51:33 <earthy> what, the random line thing? yeah
06:51:47 <chessguy> how?
06:51:56 <pjd> chessguy: keep a running count, N, of how many lines you've seen
06:52:04 <earthy> it's quite simple really. if you have just 1 line, that is the random line
06:52:05 <xerox> Saizan - Yes, like, you picked left but you were at the leftmost, or you got to the bottom of a branch.
06:52:29 <earthy> if you have n+1 lines, you have change n/n+1 that your line is one of the first n, and chance 1/n+1 that it is the new line
06:52:31 <pjd> for each line you read, you keep it with 1/n probability
06:52:55 <xerox> Saizan: I haven't decided yet if it's better to embed such controls in the zipper movements, with a monad, or not.
06:53:13 <chessguy> xerox, i thought i heard somewhere that someone had monadized zipper
06:53:51 <xerox> Oleg's zipper is just too much
06:53:57 <pjd> chessguy: http://sigfpe.blogspot.com/2007/01/monads-hidden-behind-every-zipper.html ?
06:54:00 <lambdabot> Title: A Neighborhood of Infinity: The Monads Hidden Behind Every Zipper, http://tinyurl.com/2czr94
06:54:13 <xerox> Monadic, and parametrized on the container type, AND on the movements!
06:54:15 <chessguy> so when you read the second line, there's a 1/2 chance you'll switch to that being your random line?
06:54:34 <chessguy> xerox, hehe
06:54:35 <pjd> chessguy: yeah
06:54:47 <chessguy> pjd, interesting
06:55:07 <chessguy> i suppose i could do something like that with this
06:55:46 <xerox> Saizan: do you have suggestion about the equiprobability problem, if any?
06:56:05 <pjd> chessguy: the intuition behind that method is that as you go along, each new line has less chance of being switched to
06:56:25 <pjd> but each older line has more chance of being switched away from
06:56:33 <pjd> in the end, it balances out perfectly
06:56:45 <chessguy> pjd, is there a proof that it balances out?
06:56:57 <Saizan> xerox: err, no
06:57:21 <earthy> chessguy: ofcourse.
06:57:41 <earthy> base case: file of length 1: the random line has to be the 1 line
06:58:01 <chessguy> sure
06:58:13 <xerox> You're extending this problem to a random line in a random file in a hiearchy you don't know (:
06:58:28 <chessguy> xerox, it has a lot of similarities
06:59:14 <chessguy> xerox, i could always count the total number of nodes first without affecting the asymptotic runtime, so in a way this problem is even easier than the one earthy is describing
06:59:28 <earthy> inductive case: file of length n+1: suppose a random line has been chosen at random from the first n lines. We choose between that line with a chance of n/n+1 and the last line with a chance of 1/n+1
06:59:47 <Saizan> you just have to walk through all your nodes, instead of all your lines
06:59:50 <xerox> chessguy: I think one travel is enough
07:00:05 <chessguy> xerox, me too
07:00:57 <earthy> if the chosen line is the last line, the chance was 1/n+1.
07:01:05 <xerox> ?type Data.Traversable.traverse
07:01:08 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:01:28 <earthy> if the chosen line is the one that had already been chosen, the chance is 1/n * n/n+1 == 1/n+1
07:02:03 <earthy> hm. 79 of 82
07:02:07 <earthy> my compile is almost done! yeaay!
07:04:12 * mux deals with topological sorting of DAGs and sooooo wishes he was writing haskell instead of Perl
07:05:44 <chessguy> this is going to be an interesting algorithm to write
07:06:08 <Saizan> 1/n * n/n+1 == 1/n+1 <-- this is only true for large n, right?
07:06:27 <quicksilver> no, that's true for all n :P
07:06:34 <chessguy> for all non-zero n
07:06:39 <quicksilver> yes, that too
07:06:52 <chessguy> i wonder if i could do it recursively instead of as a traversal
07:06:54 <Saizan> ah, yes off course
07:07:31 <chessguy> well, instead of a zipper-walk, that is
07:09:34 <Saizan> chessguy: with a state monad for the counter is quite simple i think
07:09:47 <chessguy> hm, i'm not sure you even need that
07:10:18 <Saizan> well you pass it explicitly
07:11:21 <chessguy> yeah, i think i can just pass the counter around
07:11:56 <chessguy> it's not nearly as much fun as xerox' infinite path though
07:12:52 <xerox> Actually you could use Oleg's Zipper now that I think of it.
07:13:10 <xerox> data Movements = Down | Left | Right deriving (Enum, Bounded)
07:13:18 <chessguy> xerox, but the equiprobability is the problem you run into with the zipper approach
07:13:36 <xerox> path = randomRs (minBound,maxBound) :: (RandomGen g) => g -> [Movements]
07:14:58 <Saizan> well but even if you pick each movement random, you have to decide which is the right nomber of them
07:15:23 <xerox> Saizan: that's why I added 'id' before, in fact.  Hmm.
07:15:44 <Saizan> xerox: but id just doesn't move
07:15:46 <fons> hi all
07:15:56 <fons> is there a whay to compose type constructors?
07:16:00 <fons> way*
07:16:04 <xerox> Saizan: yeah, so when prevtree == thistree, end the walk.
07:16:07 <quicksilver> fons: yes
07:16:10 <quicksilver> Foo . Bar
07:16:14 <chessguy> but you also have the problems of 1.) not starting in a random place, and 2.) what to do when you hit the leaf nodes. if you just stop, it's not so random any more
07:16:18 <fons> something such as (->).(->)
07:16:52 <xerox> fons: Haskell hasn't got type-level lambdas.
07:17:13 <quicksilver> but you can still compose type constructors
07:17:15 <xerox> type Compose f g a = f (g a)
07:17:21 <xerox> ...if you really want.
07:17:24 <quicksilver> just not (->)
07:18:01 <fons> xerox, that's not quita the same, as you cannot create a constructor class out of Compose
07:18:22 <quicksilver> :t Node . Node $ 5
07:18:24 <lambdabot> forall a. (Num a) => Forest (Forest a -> Tree a) -> Tree (Forest a -> Tree a)
07:18:35 <quicksilver> composed constructor!
07:18:45 <fons> quicksilver, from the terminology I know Node is not a type constructor, it is just a constructor
07:18:52 <quicksilver> ah
07:18:54 <xerox> Thay are data constructors.
07:18:58 <quicksilver> then I was reading too fast
07:19:01 * quicksilver nods
07:19:13 <quicksilver> no, you can't compose type constructors, not directly
07:19:15 <fons> quicksilver, and a constructor is a function as well, so you are using just the composition operator
07:19:21 <quicksilver> agreed
07:19:22 <Saizan> would you consider IO (Maybe a) type constructor composition?
07:19:53 <xerox> That's actually a type.
07:20:49 <fons> type constructor composition would make constructor classes much more useful
07:20:56 <fons> (and expressive)
07:21:15 <Cale> newtype Compose f g x = C (f (g x))
07:21:23 <Saizan> heh
07:22:03 <xerox> What are constructor classes?
07:22:19 <fons> xerox, Monad and Functor for instance
07:22:26 <Saizan> typeclasses where the parameter is at least * -> *?
07:22:36 <fons> Saizan, yep
07:22:41 <xerox> Ah, classes of type constructors.
07:23:06 <fons> xerox, thats the terminology I've been reading through but I might be wrong :S
07:23:43 <Saizan> so, an example of the utility of composing type constructors?
07:24:17 <fons> Saizan, let me paste it at hpaste
07:24:33 <Saizan> k
07:25:04 <earthy> ah, goody. -O2 -funbox-strict-fields ftw
07:25:27 <earthy> (>5 times speedup :))
07:25:58 <xerox> Yay!
07:26:16 <Saizan> ghc has too much performance options, there should be a one big -fdo-all-you-can too :D
07:26:18 <quicksilver> there is definitely something odd about google and the new wiki
07:26:48 <hpaste>  fons pasted "type constructor composition could be useful here" at http://hpaste.org/573
07:27:00 <fons> Saizan, there you go
07:27:03 <quicksilver> earthy: -funfolding-use-threshold=16
07:28:14 <fons> Saizan, there are better examples at http://www.cse.ogi.edu/~mpj/pubs/fundeps.html
07:28:16 <lambdabot> Title: Redirect: Web resource has moved
07:29:32 <earthy> Saizan: yes, that is called -O2
07:29:42 <earthy> -funbox-strict-fields may in fact slow you down
07:29:52 <fons> xerox, what languages do actually implement type level lambdas?
07:30:17 <xerox> None? I have no idea.
07:30:32 <fons> xerox, I was just curious
07:30:34 <xerox> Maybe Haskell in some near future (-:
07:30:34 <fons> :)
07:31:03 <xerox> http://www.cs.vu.nl/boilerplate/library/Aliases.hs
07:31:12 <xerox> "Type constructors for type-level lambdas"
07:31:39 <earthy> quicksilver: I'm not sure that would help for functions of the form natFromInt i = fromIntegral i
07:32:29 <earthy> but at least the profile doesn't look completely insane anymore ;)
07:34:54 <earthy> (I can try to find the algorithmic stupidities now ;))
07:41:21 <xerox> Good luck with your algorithms, chessguy, earthy.
07:41:27 * xerox vanishes.
07:41:30 <chessguy> xerox, thanks a lot
07:41:43 <chessguy> i'll let you know how it goes. i'm going to try to work out the details over my lunch break
07:43:08 <earthy> goody! 60% of my time spent in one function, that is called once!
07:43:52 <pejo> earthy, atleast you know where to optimize :-)
07:44:19 <earthy> yeah, it's pretty clear ;)
07:44:51 <earthy> at least, it is now. :)
07:47:02 <JohnnyL> help.
07:47:27 <earthy> what is it, little john?
07:47:28 <JohnnyL> i'm compiling darcs... aLen :: HasBounds a => a Int e -> Int
07:47:38 <JohnnyL> http://rafb.net/p/nK4gn611.html
07:47:40 <lambdabot> Title: Nopaste - darcs compile
07:53:26 <kc5tja> JohnnyL: No idea here; Maybe given some more time and another query, someone else here would know.  Darcs compiled out of the box for me.  What GHC version do you have, and what source tree of Darcs are you trying to build?
07:56:21 <fasta> Darcs didn't build for me neither.
07:56:58 <fasta> (with ghc-6.6 and with ghc-6.7)
07:58:00 <kc5tja> Sounds like a bug with GHC 6.6 then; it builds perfectly with GHC 6.4 (which is what I used, as per the darcs website recommendations).  Might want to report this as a bug to the darcs folks.
07:58:18 <kc5tja> The site recommends "at least GHC 6.4" -- but it seems that was written before 6.6 came out.  :)
07:59:42 <pejo> JohnnyL, darwinports (or macports) has patches for darcs so it will build with 6.6.
07:59:49 <kc5tja> I'll wait until people start having major issues with 6.8 before I consider upgrading GHC to 6.6 :)
08:00:52 <doserj> from ghc-6.6 release notes: The HasBounds class has been removed from Data.Array.Base, and its bounds method is now in the IArray class
08:02:54 <fasta> When they know it works with 6.4, they should claim it only works with 6.4 to be safe.
08:03:52 <michaelw> hmm, is there a way to export constructors only for pattern matching (but not for constructing)?
08:04:19 <Saizan> instance (PGMable p a) => Binary (p a) <-- how can this instance match any type if i have not defined an instance of PGMable?
08:04:24 <kc5tja> fasta: That is a distinctly Unixy way of thinking, where version 2 will break version 1 programs (which fundamentally goes against the whole concept of versioning style).  This rule doesn't apply to other operating systems, where version 2 is guaranteed to be backward compatible with version 1.
08:04:53 <kc5tja> fasta: So if you don't like how versioning is handled on Unix, I recommend creating a movement to address the root of the problem (Unixy versioning rules).
08:04:56 <fasta> kc5tja: it's not my fault darcs isn't building, is it?
08:05:09 <kc5tja> fasta: Nor is it Roundy's fault.
08:05:23 <kc5tja> He had no idea that GHC folks would change the fundamental structure of the libraries.
08:05:26 <fasta> kc5tja: the person who claimed at least 6.4 made a mistake
08:06:00 <kc5tja> fasta: Yes, so why are you complaining to me, when you should be filing a bug report?
08:06:11 <fasta> kc5tja: I am not complaining.
08:06:23 <fasta> kc5tja: AFAIK, there's already a bug for this.
08:06:32 <fasta> kc5tja: I looked when I had the same problem.
08:06:43 <michaelw> I read "works at least with version X" as "works with X, untested with anything before or after"
08:06:45 <kc5tja> fasta: Hopefully, 1.0.9 will address this issue.
08:07:32 <pejo> kc5, the code in 1.0.8 that doesn't build with 6.6 is changed in 1.0.9.
08:08:15 <kc5tja> Cool.
08:10:04 <Lemmih> @seen bringert
08:10:04 <lambdabot> I saw bringert leaving #haskell 6h 50m ago, and .
08:17:06 <JohnnyL> pejo, thanks.
08:17:15 <kellegous> essington = awesome.
08:19:42 <JohnnyL> pejo, how do I get them
08:19:43 <JohnnyL> ?
08:29:12 <glguy> !paste
08:29:13 <hpaste> Haskell paste bin: http://hpaste.org/
08:35:13 <glguy> I'm blue if I was green I would die
08:36:54 <hpaste>  glguy annotated "if-else in a do?" with "corrected" at http://hpaste.org/564#a1
08:40:10 <glguy> ?yow
08:40:11 <lambdabot> How do you explain Wayne Newton's POWER over millions?  It's th'
08:40:11 <lambdabot> MOUSTACHE ...  Have you ever noticed th' way it radiates SINCERITY,
08:40:11 <lambdabot> HONESTY & WARMTH?  It's a MOUSTACHE you want to take HOME and introduce
08:40:11 <lambdabot> to NANCY SINATRA!
09:06:38 <Cheery> Hmm.
09:06:54 <Cheery> State machine in functional language does not seem a good idea now.
09:07:03 <Cheery> It's like trying to thinking in aristotelian logic.
09:07:06 <Cheery> it sucks.
09:07:08 <Cheery> a lot.
09:07:36 <Thunder> You can convert state to position in an arbitary data structure.
09:07:52 <Thunder> I.e. your state can be a continuation.
09:08:12 <Cheery> yes, but that's already different than state, isn't it?
09:08:30 <Cheery> Better to benefit from those differences than trying to 'follow' some stupid abstraction.
09:08:50 <Thunder> State in a state machine is the concept of "getting back where i'm interrupted'.
09:09:31 <glguy> UUStudent: back again?
09:11:02 <Cheery> Does anyone here know how could I understand better what can I do in Haskell?
09:11:16 <chessguy> Cheery, read and write lots of code
09:11:52 <glguy> Cheery: maybe rephrase that question?
09:12:45 <Cheery> Is there any good guidelines you could give? For example from data structures?
09:13:18 <chessguy> Cheery, your question is too vague
09:13:27 <glguy> You aren't actually asking anything
09:14:40 <Cheery> sorry. :(
09:16:22 <quicksilver> I don't think state machine is stupid at all in a functional language
09:16:29 <fons> Saizan, if you are still interested in the type-level lambas issue, I just posted a mail concerning it to haskel-cafe, see http://www.haskell.org/pipermail/haskell-cafe/2007-February/022728.html
09:16:31 <lambdabot> Title: [Haskell-cafe] Type-level lambdas in Haskell? ( was Multiparameter class error), http://tinyurl.com/2zfcoy
09:17:43 <malebria> Hello, I'm getting a Warning which I've never seen:
09:18:48 <hpaste>  malebria pasted "Strange warning" at http://hpaste.org/576
09:19:34 <Saizan> fons: oh, nice, btw i've read before that type level lambdas would screw type inference
09:19:37 <Cheery> malebria: your pattern matches overlap.
09:19:38 <glguy> type_
09:19:45 <glguy> malebria: type_
09:19:50 <glguy> is that supposed to be type _
09:20:03 <malebria> glguy: no, it's type_
09:20:05 <fons> Saizan, any pointers to that?
09:20:06 <malebria> it's right.
09:20:11 <Cheery> malebria: let me do one thing.
09:20:16 <malebria> Cheery: but why I don't get a warning with the second one?
09:20:43 <Saizan> fons: mmh no, just channel talk..
09:22:00 <Cheery> malebria, or wait, this is not looking like simple.
09:22:38 <Lemmih> @seen musasabi
09:22:38 <lambdabot> musasabi is in #happs, #ghc, #haskell-blah and #haskell. I don't know when musasabi last spoke.
09:22:39 <glguy> malebria: when you removed the parentheses you changed the meaning
09:23:05 <Cheery> malebria: I don't know for sure yet, but if your pattern matching overlaps so that some things are never done because of it, it gives that "strange warning".
09:23:26 <fons> Saizan, well, at least my example shows they would work well with constructor classes
09:23:27 <Cheery> like: blah _ = 0 ; blah 2 = 3
09:23:31 <Cheery> would give such error.
09:23:33 <malebria> hum...
09:23:42 <malebria> glguy: which parentheses?
09:23:51 <glguy> if your pattern matches
09:24:23 <glguy> in*
09:25:49 <malebria> I didn't removed any parentheses
09:27:36 <Cheery> malebria: could you give the description of BasicC ?
09:28:20 <malebria> Cheery: Sure, I'll make the full paste then.
09:28:36 <Cheery> but I need only small part.
09:29:00 <Cheery> data (what one?) event object = BasicC event object | (what here?)
09:30:29 <malebria> Hum, I got the error.
09:30:39 <malebria> The point is that all cases are being treated in the patterns.
09:30:44 <malebria> So it'll never reach _
09:31:01 <malebria> Thanks guys.
09:31:23 <Cheery> that was exactly what I meant.
09:31:38 <Cheery> data Basic e o = BasicC e o
09:32:09 <Cheery> when you add an another definition to your Basic -type, you may need the _ again later.
09:33:20 <nmessenger> yeah, the old AssignAttributes contained a Maybe type which you only handled the Just versions of, so the basicHistory _ case would cover Nothings.
09:33:41 <malebria> Yes, but it's not going to change very much from now on.
09:34:03 <nmessenger> the new set of equations cover all cases, so its just telling you that the last case is superfluous.
09:43:36 <shapr> Has anyone heard from musasabi lately?
09:45:24 <Cheery> @seen musasabi
09:45:25 <lambdabot> musasabi is in #happs, #ghc, #haskell-blah and #haskell. I don't know when musasabi last spoke.
09:47:39 <MarcWebe3> Can you give me a simple example using  instance MonadReader r ((->) r) where
09:47:45 <MarcWebe3> ?
09:48:34 <MarcWebe3> Wait. I have to think about it again...
09:48:38 <Saizan> > (+1) >>= (*) $ 5
09:48:41 <lambdabot>  30
09:51:33 <bakert> ?where system.time
09:51:33 <lambdabot> I know nothing about system.time.
09:52:18 <nmessenger> bakert: @docs? @source?
09:52:27 <bakert> ?docs system.time
09:52:27 <Cheery> bakert: you may have to persuade him harder to get him tell his little secret.
09:52:28 <lambdabot> system.time not available
09:52:35 <nmessenger> @docs System.Time
09:52:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
09:52:41 <bakert> aha case sensitive
09:52:45 <Cheery> ?where System.Time
09:52:45 <lambdabot> I know nothing about system.time.
09:53:13 <bakert> Do you know how to take 1 second off a ClockTime?
09:53:13 <nmessenger> the @where command is more for overall haskell projects, not Modules
09:53:16 <bakert> Or a CalendarTime?
09:53:20 <bakert> nmessenger, i see
09:54:30 <nmessenger> @type addToClockTime
09:54:32 <lambdabot> Not in scope: `addToClockTime'
09:54:36 <MarcWebe3> bakert: Just browse the module which defines ClockTime. There are some helper functions..
09:54:50 <quicksilver> MarcWebe3: In my opinion, the simplest interesting one is this:
09:54:59 <nmessenger> :b is a very useful ghci command :)
09:55:12 <quicksilver> > do { x <- (*2) ; y <- (+5) ; return (x,y) } $ 8
09:55:13 <lambdabot>  (16,13)
09:55:26 <quicksilver> MarcWebe3: '8' is the constant environment
09:55:39 <quicksilver> MarcWebe3: <- applies the environment to the given functin
09:56:03 <Cheery> > :beer help
09:56:04 <lambdabot>  Parse error
09:56:08 <Cheery> > :b blah
09:56:09 <lambdabot>  Parse error
09:56:15 <Cheery> @beer help
09:56:15 <lambdabot> I haven't seen help.
09:56:37 <nmessenger> . @beer -> SpellChecker -> @seen
09:56:43 <MarcWebe3> Saizan has given me this example. (but one >>= less). ghci can't find the instance for Monad ((->) a) Where is it defined? hoogle says Prelude..
09:56:58 <nmessenger> Control.Monad.Reader
09:57:09 <quicksilver> also Control.Monad.Instances, I believe
09:57:11 <nmessenger> Prelude?  Really?
09:57:48 <MarcWebe3> nmessenger: Sure. Obviously. Sorry. I mixed things up.
09:58:04 <nmessenger> :)
09:59:49 <pejo> Could anyone suggest a typical higher-order function that isn't map, or foldr?
10:00:16 <quicksilver> pejo: one of the parsec combinators, perhaps?
10:00:18 <chessguy> ?type scanl
10:00:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:00:26 <chessguy> maybe?
10:00:26 <nmessenger> @type callCC
10:00:30 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
10:00:41 <chessguy> @slap nmessenger
10:00:41 * lambdabot smacks nmessenger about with a large trout
10:01:23 <nmessenger> (>>=) even
10:01:30 <quicksilver> pejo: filter is another simple one
10:01:44 <chessguy> oh yes, that's a good one
10:01:52 <nmessenger> sortBy, groupBy, etcBy
10:01:56 <chessguy> zip
10:02:00 <chessguy> zipWith, rather
10:02:24 <quicksilver> :t zip
10:02:27 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:02:36 <quicksilver> :t zipWith
10:02:38 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:02:42 <nmessenger> if it doesn't take a function as an argument, it's probably not generic enough :)
10:02:45 * quicksilver nods
10:02:48 <nmessenger> :t zipWith (,)
10:02:50 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:03:07 <bos> @pl \(a, (b, c)) -> (a,b,c)
10:03:08 <lambdabot> uncurry ((`ap` snd) . (. fst) . (,,))
10:03:48 <chessguy> yeah, that's why i corrected myself to say zipWith
10:03:59 <chessguy> ?hoogle by
10:03:59 <lambdabot> System.Posix.Types.ByteCount :: type ByteCount
10:03:59 <lambdabot> System.Win32.Types.BYTE :: type BYTE
10:03:59 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:04:05 <chessguy> @hoogle+
10:04:05 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
10:04:05 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
10:04:05 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:04:09 <chessguy> @hoogle+
10:04:10 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
10:04:10 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
10:04:10 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
10:04:15 <chessguy> nubBy!
10:04:19 <bos> @pl \(a,b,c) -> a
10:04:19 <lambdabot> (line 1, column 6):
10:04:19 <lambdabot> unexpected ","
10:04:19 <lambdabot> expecting letter or digit, operator or ")"
10:04:19 <lambdabot> ambiguous use of a non associative operator
10:04:26 <chessguy> @hoogle+
10:04:27 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
10:04:27 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:04:27 <lambdabot> Data.IntMap.isProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
10:04:46 <chessguy> isProperSubmapOfBy!
10:04:53 <kaol> @source nubBy
10:04:54 <lambdabot> nubBy not available
10:05:04 <chessguy> ?src nubBy
10:05:05 <lambdabot> nubBy eq []             =  []
10:05:05 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:05:27 <nmessenger> the By versions get around needing an (Ord a) or (Eq a) context by passing in the (==) or compare to use directly
10:05:40 <chessguy> ?source+ nubBy src nubBy
10:05:40 <lambdabot> nubBy src nubBy not available
10:06:01 <pejo> quicksilver/chessguy, thanks. Filter is good.
10:06:09 <nmessenger> @src nub
10:06:10 <lambdabot> nub = nubBy (==)
10:06:14 <nmessenger> :)
10:06:38 <nmessenger> @src sort
10:06:38 <kc5tja> :t nub
10:06:39 <lambdabot> sort = sortBy compare
10:06:40 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:07:03 <nmessenger> > nub [1,2,5,2,4,5,2,1,3,6]
10:07:05 <lambdabot>  [1,2,5,4,3,6]
10:07:30 <kc5tja> So, nub :: Haskell = uniq :: Bash.  :)
10:07:39 <nmessenger> aye
10:07:59 <kc5tja> What a strange name for the concept.
10:08:57 <resiak> ISTR that the logic is that 'nub' means 'essence'.  It's a nice word.
10:09:04 <hpaste>  int-e pasted "comment for 'nub' from Data.List" at http://hpaste.org/577
10:09:35 <kaol> what a nice application of laziness in it, too
10:09:44 <int-e> hmm. I guess this is also in the online documentation somewhere, but I'm too lazy to look for it.
10:10:13 <nmessenger> it's just @docs Data.List
10:10:40 <jyasskin> Hm, nub :: O(n^2) while uniq :: O(n).
10:10:57 <kc5tja> quicksilver: You at keyboard?
10:11:34 <nmessenger> jyasskin: does uniq just remove adjacent equal items?
10:11:43 <jyasskin> Yeah, so generally you have to sort the list first.
10:12:02 <jyasskin> uniq = map head . group  -- I think.
10:12:27 <xerox> nope.
10:12:34 <xerox> map head . group . sort
10:12:48 <int-e> nope. wrong order :)
10:13:04 <xerox> ?src nub
10:13:05 <lambdabot> nub = nubBy (==)
10:13:08 <jyasskin> The bash uniq doesn't include the sorting step, but most uses do.
10:13:08 <xerox> ?src nubBy
10:13:09 <lambdabot> nubBy eq []             =  []
10:13:09 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:13:12 <nmessenger> xerox: nope. :)  uniq is as jyasskin describes
10:13:22 <xerox> Oh.
10:13:31 <xerox> That's not really unique.  Okay.
10:13:45 <int-e> xerox: you usually use it as ... | sort | uniq :)
10:13:49 <nmessenger> so uniq "foozoo" = "fozo" -- as per specification
10:14:03 <xerox> int-e: ah-ha.
10:15:53 <nmessenger> sort | uniq isn't quite nub either.  let uniq = map head . group in ((uniq . sort) "badlad" == "abdl") while (nub "badlad" == "badl")
10:17:24 <MarcWebe3> nmessenger: Sorry. I did ask the wrong question. Where can I find the implementation of Monad ((->) a) ?  MonadReader ((->) a) can be found in Control.Monad.Reader. hoogle tells me that Monad ((->)a) can be found in the Prelude.. is this correct?
10:18:29 <chessguy> ?hoogle uniq
10:18:29 <lambdabot> Language.Haskell.TH.Syntax.Uniq :: type Uniq
10:18:29 <lambdabot> Data.Unique :: module
10:18:29 <lambdabot> Data.Unique.Unique :: data Unique
10:18:32 <xerox> ?source Control.Monad.Reader
10:18:33 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
10:18:40 <xerox> There you go.
10:19:00 <jyasskin> MarcWebe3: http://darcs.haskell.org/ghc-6.6/packages/base/Control/Monad/Instances.hs
10:19:03 <lambdabot> http://tinyurl.com/25qyth
10:19:24 <nmessenger> I'm not sure if Monad ((->) r) is in the Prelude.  I'd assumed it wasn't.
10:19:40 <kc5tja> What are monad readers, and what are they typically used for?
10:19:43 <nmessenger> @where report
10:19:44 <lambdabot> http://www.haskell.org/onlinereport/
10:20:20 <nmessenger> A reader monad represents a computation that depends on some shared state that it can "read" via the ask function.
10:20:21 <MarcWebe3> jyasskin is right.
10:20:23 <nmessenger> @type ask
10:20:26 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:20:50 <xerox> instance Monad ((->) e) where return = const; f >>= g = \e -> g (f e) e
10:21:05 <nmessenger> A function (Int -> Char) can be thought of as a computation that results in a Char, while reading an Int
10:21:46 <nmessenger> given type IntReader = (->) Int, the signature IntReader Char makes it more explicit.
10:22:13 <nmessenger> instance Monad ((->) r) just generalizes the state to all types, not just Int.
10:23:27 <nmessenger> > fmap (*3) (+1) $ 4 -- (+1) is a computation that results in a number, 'fmap (*3)' changes the resulting number
10:23:28 <lambdabot>  15
10:23:45 <nmessenger> in this case, fmap for ((->) r) is (.)!
10:24:00 <nmessenger> > (*3) . (+1) $ 4
10:24:01 <lambdabot>  15
10:24:11 <resiak> is fmap not always (.) for ((->) r) ?
10:24:24 <xerox> resiak: what do you mean?
10:24:33 <nmessenger> join takes a (a -> a -> r) and turns it into an (a -> r) by duplicating the input
10:24:40 <nmessenger> > join (*) 5
10:24:42 <lambdabot>  25
10:24:47 <MarcWebe3> resiak. It is. See Control.Monad.Instances ;-)
10:24:54 <resiak> xerox: I think I misparsed what nmessenger said.
10:25:16 <nmessenger> and (>>=) is of course a combination of join and fmap
10:25:16 <resiak> and MarcWebe3 confirms it.  I'll shut up now :-)
10:25:24 <nmessenger> > (+3) >>= (*) $ 5
10:25:26 <lambdabot>  40
10:25:34 <xerox> resiak: it's good to ask questions.
10:26:29 <resiak> I'm still not clear on what the point of this particular monad instance, but I suspect I should use it some and it'll click.
10:26:35 <darrint> Has anyone ever released Happs debs for ubuntu?
10:26:53 <nmessenger> It's like a State monad that you can't change, it just get inputted once.
10:27:43 <jyasskin> And, because we've always wanted a simpler infix notation for (fmap), http://comonad.com/reader/2006/generalizing-dot/ proposes using just (.). :)
10:27:49 <lambdabot> Title: The Comonad.Reader » Generalizing (.)
10:28:41 <kc5tja> > (+4) >>= (*) $ 5
10:28:42 <lambdabot>  45
10:28:42 <nmessenger> jyasskin: yeah, but I'm still not sure if I like it.  It is sexy, but perhaps a little over-generalizing for my puny brain :)
10:29:08 <jyasskin> I'm not sure either, but then, pointless notation hurt my brain for a long time too.
10:29:38 <kc5tja> It appears to be computing (a+b)*b
10:29:46 <nmessenger> @wiki The_Other_Prelude
10:29:47 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
10:29:49 <nmessenger> ^^ I've contributed to that page a bit, so I like some of the ideas
10:30:10 <nmessenger> @src (->) (>>=)
10:30:11 <lambdabot> f >>= k = \ r -> k (f r) r
10:30:19 <xerox> kc5tja: (*) ((+4) 5) 5 = (4+5) * 5
10:30:26 <nmessenger> k = (*) and f = (+4)
10:31:25 <kc5tja> xerox: There's quite a bit of black magic involved with that transformation, so I'm not going to investigate further.
10:31:34 <kc5tja> I'll run into it at some point in the future most likely.
10:31:44 <xerox> kc5tja: there is no magic :-)
10:31:51 <kc5tja> That's what you think.  :)
10:31:58 <nmessenger> > (\x f -> join (fmap f x)) (+4) (*) 5
10:31:59 <xerox> The line that lambdabot spit out is the actual definition.
10:32:00 <lambdabot>  45
10:32:16 <xerox> As nmessenger says, substitute the values you provided.
10:32:25 <xerox> What do you get is the equation I wrote.
10:32:46 <xerox> That's one of the best things of this language, you can just go and apply equational reasoning to code.
10:32:51 <kc5tja> xerox: I know.  But the logic behind that lambdabot definition is where the black magic exists.
10:33:13 <xerox> Hmmm, I suppose djinn is black magic too.
10:33:30 <xerox> Let's give it a try anyway.
10:33:35 <xerox> :t (>>=)
10:33:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:33:44 <xerox> ...and substitute (e ->) for m.
10:33:53 <nmessenger> (>>=) always equals (\x f -> join (fmap f x)), so the semantics of ((->) r)'s (>>=) follow.
10:33:57 <xerox> @djinn (e -> a) -> (a -> e -> b) -> (e -> b)
10:33:57 <lambdabot> f a b c = b (a c) c
10:34:32 <emu> @djinn a -> m a
10:34:33 <lambdabot> -- f cannot be realized.
10:34:33 <nmessenger> here, (e ->) is the 'm' part of (>>=)'s signature
10:34:34 <kc5tja> nmessenger: It follows only if you know the path.  I do not follow.  :)
10:34:38 <nmessenger> @type (>>=)
10:34:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:35:01 <xerox> kc5tja - It reduces to the problem of finding a function (e -> b), given two functions (e -> a) and (a -> e -> b).
10:36:47 <nmessenger> kc5tja: no problem. :)  It usually makes sense in my brain but sometimes my brain stops working and I'm like "wait, WHAT?!" :D
10:36:49 <xerox> I agree that coming up with the idea that ((->) e) is a monad is not obvious.
10:37:17 <kc5tja> And intellectually hostile, to boot.
10:37:26 <nmessenger> heh
10:37:35 <kc5tja> Don't feed the monad readers!
10:37:40 <MarcWebe3> jyasskin: We should start a wiki page with brain damaging pointless notation and much more important: with annotations ;-)
10:37:57 <nmessenger> isn't that Open your mind! or some such?
10:38:00 <xerox> That depends on one's own intuition.
10:38:05 <jyasskin> I think my favorite was "(.) (.) (.)".
10:38:20 <kc5tja> :t (.) (.) (.)
10:38:22 <xerox> Composes a binary function with an unary one
10:38:22 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:38:27 <DynWind> has anyone played with Haskore recently?
10:39:06 <kc5tja> I'm not even going to pretend I know how to derive the type of (.) (.) (.).
10:39:07 * MarcWebe3 starts screaming.. Wait I've seen (.) . (.) or something like that before.. in HaXml ? I don't know any more..
10:39:12 <kc5tja> Or what it actually does.  :)
10:39:26 <xerox> kc5tja: again, just use the definition.
10:39:35 <kc5tja> xerox: I *AM*, but it's not helping.
10:39:35 <MarcWebe3> DynWind: Not recently..
10:39:48 <xerox> (f . g) = \x -> f (g x)
10:39:50 <nmessenger> \x y -> f (g x y) = (f .) . g = (.) (.) (.) f g
10:40:24 <kc5tja> That second derivation doesn't follow for me.
10:40:39 <kc5tja> How did you go from f (g x y) to (f .) . g
10:40:42 <kc5tja> That makes zero sense.
10:41:17 <nmessenger> can you follow: \x y -> f ((g x) y) = \x -> f . g x
10:41:20 <jyasskin> \x -> \y -> f (g x y) = \x -> f . (g x) = \x -> (f .) (g x) = (f .) . g
10:41:45 <kc5tja> nmessenger: Yes.
10:42:12 <nmessenger> then \x -> f . g x = \x -> (f .) (g x) = (f .) . g
10:42:32 <kc5tja> Sorry, I can't follow that.
10:42:34 <DynWind> maybe I should cabalize Haskore ...
10:42:39 <xerox> \x y -> f (g x y) =definition= \x y -> (f . g x) y =beta-reduction= \x -> f . (g x) =infix to prefix= \x -> (.) f (g x) =application= \x -> (f .) (g x) =definition= \x -> ((f .) . g) x =beta-reduction= (f .) . g
10:43:10 <nmessenger> in Englishy: g gets a parameter and returns a function.  That function is passed to (f .), which composes f after it.
10:43:14 <xerox> `definition' stays for "definition of (.)".
10:43:14 <kc5tja> (f .) <-- that's what is getting me.
10:43:23 <xerox> (f .) = (.) f
10:43:30 <xerox> (2 +) = (+) 2
10:43:36 <kc5tja> xerox: I got that.
10:43:40 <nmessenger> > (negate .) (+1)
10:43:42 <lambdabot>  <Integer -> Integer>
10:43:46 <nmessenger> > (negate .) (+1) 5
10:43:48 <lambdabot>  -6
10:43:59 <xerox> Well, have fun (-:
10:44:38 <kc5tja> (f .) (g x) = (f . g) x
10:45:26 <nmessenger> (x !) (y) = x ! y, so (f .) (g x) = f . (g x)
10:45:28 <xerox> (f .) (g x) = f . (g x) = (.) f (g x) = \y -> f (g x y)
10:45:33 <DynWind> ?where haskore
10:45:33 <lambdabot> http://cvs.haskell.org/darcs/haskore/
10:45:39 <xerox> (That is, what you have written is wrong.)
10:45:41 <DynWind> ah, someone's done it
10:46:19 <nmessenger> (f .) (g x) = ((f .) . g) x
10:46:45 <nmessenger> let fdot = (f .) in fdot (g x) = (fdot . g) x
10:47:26 <nmessenger> the second part is the definition of (.)
10:47:29 <nmessenger> @src (.)
10:47:30 <lambdabot> (.) f g x = f (g x)
10:47:52 <kc5tja> Sure, I'm aware of that.
10:48:00 <kc5tja> I'm just not seeing how the components all fit together.
10:48:45 <nmessenger> perhaps different names: (inner .) (outer x) = let innerdot = (inner .) in innerdot (outer x) = (innerdot . outer) x
10:48:59 <nmessenger> so innerdot is (.)'s f, and outer is (.)'s g.
10:49:12 <chessguy> heh. anyone read eric kidd's blog? looks like he's doing quantum mechanics with haskell :)
10:50:09 <Daveman> :)
10:50:17 <zoOmBiOZ> CHK the new version of C99 SHELL with SAFE MODE bypass WORK test there +++>>>   !!!PRIVATE!!!   http://www.fencing.net/images/enc.txt?   !!!PRIVATE!!! <<<+++  WE STOLED IT FROM PRIVATE CREW AND MAKE IT NOW PUBLIC FUCK PRIVATE    ===>    MOROCCO RULEZ
10:50:42 <chessguy> what in the world?
10:50:51 <kc5tja> And, now, a DDoS is launched.
10:50:56 --- mode: ChanServ set +o glguy
10:50:58 --- mode: glguy set +b *!*=zoOmBiOZ@81.8.158.*
10:50:58 --- kick: zoOmBiOZ was kicked by glguy (glguy)
10:51:00 --- mode: ChanServ set +o xerox
10:51:04 <kc5tja> Because I can't see that spam making ANY amount of sense otherwise.
10:51:12 --- mode: xerox set -o xerox
10:51:59 <chessguy> xerox, you're too slow :)
10:52:06 * xerox hmpfs
10:52:25 * glguy has forwarded the issue to numist, an ircop
10:53:02 <kc5tja> glguy: Good idea.
10:55:54 --- mode: glguy set -o glguy
10:58:23 <glguy> you don't train for the moment when you'll need to spring to action and kill a spammer?
10:58:28 <glguy> xerox: ^
10:58:52 * nmessenger is writing a derivation fro (.) (.) (.) on hpaste
10:58:55 <nmessenger> for*
11:00:24 <Saizan> why instance Foo p a => Binary (p a)  suddenly overlaps with *everything* even if there's no PGMable instance?
11:00:34 * kc5tja notes launching a distributed build on the local workstation really cuts into UI response times.
11:00:46 * xerox lifts weights full of lambdas
11:02:25 <hpaste>  nmessenger pasted "derivation of (.) (.) (.)" at http://hpaste.org/578
11:03:11 <chessguy> @type (.) (.) (.)
11:03:14 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:04:56 <sjanssen> @. djinn type (.) (.) (.)
11:04:59 <lambdabot> f a b c d = a (b c d)
11:05:01 <astrolabe> Do you think lambdabot could be trained to identify and boot spammers?
11:05:33 <bakert> astrolabe, i don't know but i can see some amusing bootings as we try to find out ...
11:05:39 <astrolabe> maybe if it just booted people who use all caps :)
11:05:40 <DynWind> it might kick itself ;)
11:05:52 <MarcWebe3> astrolabe: A good starting point would be  spammer_propability str = count . (filter isUpper) ;-)
11:06:04 <astrolabe> right
11:06:55 <astrolabe> The string 'RULEZ' should be enough to get you banned whether you're a spammer or not.
11:07:30 <bakert> then you would be banned
11:07:36 <bakert> :)
11:07:39 <hpaste>  glguy annotated "derivation of (.) (.) (.)" with "my version" at http://hpaste.org/578#a1
11:07:44 <nmessenger> RULEZ!!!1 RULEZ!!!1 RULEZ!!!1 RULEZ!!!1 RULEZ!!!1
11:07:49 --- mode: ChanServ set +o glguy
11:07:51 --- mode: glguy set +b *!*=nmesseng@*.160.136.64.1dial.com
11:07:51 --- kick: nmessenger was kicked by glguy (glguy)
11:07:53 <bakert> and nmessenger would be banned
11:07:57 <bakert> !!!
11:07:58 <MarcWebe3> We can also INtroDUCE a WHITE LIST? ;)
11:07:59 <bakert> ;)
11:08:08 --- mode: glguy set -b *!*=nmesseng@*.160.136.64.1dial.com
11:08:19 <Botje> you could measure time spent being "nice"
11:08:27 <MarcWebe3> Everyone who has used at least one lambdabot command will be added automatically? ...
11:08:40 <Botje> since spammers / kiddies like to start annoying people ASAP
11:08:51 --- mode: glguy set -o glguy
11:08:59 <DynWind> ?where Hsc
11:08:59 <lambdabot> I know nothing about hsc.
11:11:42 <glguy> why don't I just sit with my hands hovering over / o p m e k n TAB and whatever keys the offender's nick starts with
11:12:31 <nmessenger> that's quite a lot of fingers :P
11:12:46 <glguy> that gives me two fingers for the nick
11:12:59 * nmessenger tries it.  Keyboard twister!
11:13:03 <glguy> you just hold them at the right heights such that when you smash down on the keyboard it types all that in
11:13:16 <nmessenger> _frederik_:/mgpok
11:13:17 <Vq^> hej hygge
11:13:35 <nmessenger> heh
11:13:39 <hygge> hej!
11:13:59 <hygge> who are you, vq^?
11:14:04 <DynWind> how do I tell lambdabot the location of Hsc?
11:14:05 <astrolabe> MarcWeber: I think that would work quite well
11:14:09 <hygge> ;)
11:14:11 <nmessenger> @help where+
11:14:12 <lambdabot> where+ <key> <elem>. Define an association
11:14:27 <glguy> @yhjulwwiefzojcbxybbruweejw
11:14:27 <DynWind> where+ hsc http://www.slavepianos.org/rd/sw/sw-69/
11:14:28 <lambdabot> "\""
11:14:28 <lambdabot> Title: Index of /rd/sw/sw-69
11:14:33 <DynWind> thanks
11:15:05 * glguy wonders if that is a sfw url
11:15:07 <glguy> ;)
11:15:28 <DynWind> :P
11:16:22 <Vq^> hygge: i am me :)
11:19:25 * nmessenger celebrates his first IRC kicking!
11:20:21 <nmessenger> it RULEZ!!1 :P
11:20:50 <glguy> \kick nmessenger
11:20:52 <glguy> oops :)
11:20:54 <nmessenger> heh
11:21:16 <astrolabe> :) kicking's too good for him
11:21:18 <emu> is that a TeX command?
11:21:30 <glguy> \kick{nmessenger}
11:21:32 <glguy> that?
11:21:37 <emu> don't kick the messenger!
11:21:42 * nmessenger 's bottom hurts.
11:21:44 <glguy> @slap emu
11:21:44 <lambdabot> why on earth would I slap emu
11:21:48 <glguy> @slap nmessenger
11:21:48 * lambdabot slaps nmessenger
11:21:54 <emu> @botsnack
11:21:54 <lambdabot> :)
11:21:57 <glguy> lambdabot knows what's going on
11:22:03 <nmessenger> @vixen DON'T YOU LOVE ME ANYMORE?!
11:22:04 <lambdabot> <undefined>
11:22:23 <nmessenger> ...guess that's a no.
11:22:24 <astrolabe> What's the irc command to print the topic?
11:22:30 <nmessenger> @list topic
11:22:31 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
11:22:33 <emu>  /topic
11:22:43 <nmessenger> oh, irc command
11:22:57 <astrolabe> hmmm /topic doesn't work for me
11:23:11 <astrolabe> @topic-tell
11:23:12 <lambdabot> Do not know that channel
11:23:19 <glguy> @topic-tell #haskell
11:23:19 <lambdabot> ["The Haskell programming language: we know when to use callCC!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The
11:23:20 <lambdabot> language of ICFP winners 3 years running"]
11:23:28 <astrolabe> ah
11:23:29 <astrolabe>  thanks
11:23:44 <glguy> I'm responsible for two elements of the topic :)
11:24:07 <nmessenger> paste and callCC?
11:24:09 <glguy> yeah
11:24:23 <glguy> dons added the callCC thing in response to monochom's exclamation after I used it
11:25:47 <mwc> What is ghc-asm?
11:25:57 * mwc pokes at the mystery binary
11:26:57 <mwc> Hmm, it seems to be perl, and not just ELF binary line noise
11:27:03 <mwc> Is this the mangler?
11:27:31 <nmessenger> mwc: did you check the docs?
11:27:54 <mwc> it doesn't have a man page or give any usage info
11:29:57 <nmessenger> http://haskell.org/ghc/docs/latest/html/users_guide/sec-install-files.html#id3124229
11:29:59 <lambdabot> Title: 2.3. The layout of installed files, http://tinyurl.com/yuchcx
11:32:05 <mwc> didn't think to look there... scanned the docs for usage info
11:34:12 <nmessenger> MarcWebe3: earlier you mentioned starting a wiki page that had crazy stuff, perhaps: http://haskell.org/haskellwiki/Blow_your_mind
11:34:13 <lambdabot> Title: Blow your mind - HaskellWiki
11:35:29 <Saizan> ?docs Data.Array.Unboxed
11:35:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Unboxed.html
11:35:40 <roconnor_> Anyone know of a Haskell implementation of Remes exchange algorithm?
11:36:09 <roconnor_> or Remez exchange algorithm
11:37:17 <roconnor_> @google Remez Haskell
11:37:20 <lambdabot> http://www.uni-bonn.de/~manfear/mathdict-entry.php?term=Remez%20algorithm&lang=en&fromLang=de&toLang=en&letter=r
11:37:23 <Patty01> does anyone know of a cpu emulator or virtual machine implemented in haskell?
11:37:40 <nmessenger> someone wrote part of a Game Boy emulator
11:37:42 <roconnor_> Patty01: for a real or fake cpu?
11:37:52 <kc5tja> Patty01: You might want to check on Google -- there is at least one Gameboy emulator written in Haskell.
11:38:04 <nmessenger> @google haskell game boy emulator
11:38:06 <lambdabot> http://www.bluishcoder.co.nz/2006/04/haskell-gameboy-emulator.html
11:38:06 <lambdabot> Title: Bluish Coder: Haskell Gameboy Emulator
11:38:10 <Patty01> either - I'm implemen ting one at the moment and performance blows.  I want to see someone else whose done it
11:38:19 <roconnor_> @google dons UM
11:38:22 <lambdabot> http://www.azcentral.com/arizonarepublic/arizonaliving/articles/0215tyrabanks0215.html
11:38:22 <lambdabot> Title: 10 years later, Tyra dons her, um, modified 'SI' bikini
11:38:28 <roconnor_> hmm
11:38:29 <bos31337> is there anything decent to read on dealing with C structs in Haskell?
11:38:33 <kc5tja> It's not the fastest emulator though, as I recall.  But it does work, apparently.
11:38:41 <int-e> @where um
11:38:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
11:39:18 <roconnor_> Patty01: there are some haskell VM implemenations at int-e's link above
11:39:36 <Patty01> thanks - will look at them now
11:39:49 <roconnor_> bos31337: you mean FFI?
11:40:17 <MarcWebe3> nmessenger: I think this comes close to it ;-)
11:40:17 <bos31337> roconnor_: yes.
11:40:45 <roconnor_> bos31337: ah, sorry, I don't know FFI.
11:44:17 <chessguy> roconnor, there's nobody here with the nick bos31337. get a clue!
11:44:58 <roconnor> bos: ah, sorry, I don't know FFI.
11:45:05 <chessguy> :)
11:45:59 <chessguy> ?source Data.Tree
11:45:59 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
11:47:00 <Patty01> Well let me ask a different question; where's a good tutorial on unsafeRead and unsafeWrite; it looks like I need these badly
11:48:33 <roconnor> @hoogle unsafeRead
11:48:34 <lambdabot> No matches found
11:49:05 <roconnor> Patty01: I thought unsafeRead/write were pretty easy to use
11:49:15 <roconnor> they are like read and write, but without the bounds check
11:49:29 <roconnor> so you can segfault if you are not careful
11:49:52 <Patty01> Do they work for anything, or just special data types?
11:50:01 <roconnor> Patty01: they work on arrays
11:50:16 <roconnor> maybe specifically UArrays?
11:50:18 <roconnor> not sure
11:50:27 <Patty01> I tried playing with them a while back and was missing instnaces or something
11:50:28 <roconnor> the types should make it clear how to use them
11:51:30 <Patty01> thx anyway
11:54:03 <abz> ?hoogle fork
11:54:03 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
11:54:04 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
11:54:22 <abz> ?hoogle Posix
11:54:23 <lambdabot> Text.Regex.Posix :: module
11:54:23 <lambdabot> System.Win32.File.fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
11:54:23 <lambdabot> System.Win32.File.sCS_POSIX_BINARY :: BinaryType
12:00:23 <pjd> i'm not having any luck figuring this out from other places:  where/how are the x.org/XKB digraphs defined?
12:01:10 <pjd> i want to type Haskell symbols more conveniently :)
12:06:04 <DynWind> Could not find module ound.OpenSoundControl.OSC':
12:06:37 <DynWind> it is a member of package hosc-0.1, which is hidden
12:06:42 <DynWind> what does that mean?
12:08:13 <kc5tja> Perhaps there is a typo in the module's name?  :)
12:08:34 <DynWind> no, it is *Sound*, the S got swallowed while pasting :)
12:08:57 <Lemmih> DynWind: Using Cabal? If so, you need to add hosc to your build-depends.
12:09:04 <DynWind> I have hosc installed, and its cabal file says that the module under question is 'exported'
12:10:10 <DynWind> Lemmih: thanks, that seems to have fixed it
12:10:43 <kc5tja> Haha -- hey, it was worth a try.
12:12:07 <JohnnyL> @seen humasect
12:12:07 <lambdabot> I saw humasect leaving #haskell 1d 11h 13m 46s ago, and .
12:13:49 * DynWind gives up trying to build Haskore
12:14:55 <psi> is there a prefered database interface library?
12:15:45 <xerox> ?where HaskellDB
12:15:46 <lambdabot> http://haskelldb.sourceforge.net/
12:16:38 <xerox> psi: bringert maintains and uses it, for example in Hope.
12:17:14 <Lemmih> psi: HDBC is nice.
12:18:18 <psi> thanks
12:18:56 <xerox> Both are in HackageDB, ready for cabal-getting.
12:21:35 <Orphi> Is anything alive in here?
12:21:47 <xerox> Of course!
12:21:56 <Orphi> lol... worth checking.
12:21:57 <xerox> Look around...
12:21:59 <xerox> ?users
12:22:00 <lambdabot> Maximum users seen in #haskell: 317, currently: 313 (98.7%), active: 47 (15.0%)
12:22:25 <Orphi> anybody here know anything about darcs?
12:22:25 <kaol> ?users
12:22:26 <lambdabot> Maximum users seen in #haskell: 317, currently: 313 (98.7%), active: 47 (15.0%)
12:22:26 <bohanlon> I am not quite dead
12:22:32 * Vq^ neither
12:22:36 <kaol> bah, I was counted as active already
12:22:42 <Vq^> ?users
12:22:43 <lambdabot> Maximum users seen in #haskell: 317, currently: 312 (98.4%), active: 47 (15.1%)
12:22:52 <xerox> Orphi: sure, ask right away.
12:23:10 <Orphi> I copied a darcs repo onto my web server, and darcs get seems to work fine
12:23:16 <Orphi> but darcs pull gives me a weird error
12:23:32 <xerox> What weird error?
12:23:45 <Orphi> it seems darcs is trying to fetch some file that doesn't exist, and is interpreting the HTTP300 message from my ISP as "data"
12:24:09 <Orphi> "I don't understand <html><head>", etc.
12:24:30 <xerox> Non-standard HTTP reply?
12:25:03 <Orphi> HTTP 300 = "multiple choices"
12:25:05 <Orphi> apparently
12:25:15 <Orphi> if I knew what file darcs was trying to fetch....
12:26:08 <Orphi> hold on, let me see if I can make it do the error right now...
12:26:12 <xerox> You might want to tell that to the #darcs people.
12:27:40 <Orphi> "The file you requested (darcs/foo/.git/darcs-format) could not be found"
12:28:00 <Orphi> well, sure enough, that file *doesn't* exist, but...
12:28:35 <Orphi> mmm... there's a darcs-specific channel, eh?
12:29:09 <Orphi> BTW... how the heck does one pronounce "darcs", anyway??
12:29:42 <nmessenger> like the plural of "dark" I presume
12:29:46 <psi> xerox: I couldn't find haskelldb in hackage.
12:29:56 <Orphi> that's what I figured...
12:36:26 <xerox> psi: auhm, I thought I added it.
12:36:53 * kolmodin tries to figure out how to describe a type signature in template haskell
12:37:05 <kolmodin> how do I describe for example "Bool -> Int" ?
12:37:09 <Orphi> eeeps x_x
12:37:19 <kolmodin> using the 'data Type' ?
12:37:25 <kolmodin> Igloo: ^^ :)
12:43:59 <kolmodin> mmm... I think I got it
13:06:10 <glguy> ?yow
13:06:10 <lambdabot> ... this must be what it's like to be a COLLEGE GRADUATE!!
13:07:04 <nmessenger> where does @yow get its material?
13:07:13 <chessguy> ?help yow
13:07:13 <lambdabot> yow. The zippy man.
13:07:24 <chessguy> that's informative
13:07:51 <Wallbraker> ?yow
13:07:52 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
13:07:52 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
13:07:54 <nmessenger> indeed
13:08:07 <chessguy> ?quote helpful
13:08:07 <lambdabot> No quotes match. You speak an infinite deal of nothing
13:08:34 <chessguy> ?quote informative
13:08:35 <lambdabot> SamB says: Because sliced bread gives horribly uninformative error messages?
13:09:50 <bos> @hoogle throwErrno
13:09:50 <lambdabot> Foreign.C.Error.throwErrno :: String -> IO a
13:09:50 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
13:09:50 <lambdabot> Foreign.C.Error.throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
13:10:15 <bos> @hoogle getErrno
13:10:15 <lambdabot> Foreign.C.Error.getErrno :: IO Errno
13:10:24 <Excedrin> nmessenger: afaik, @yow material is from Emacs M-x yow, which is from the Zippy the Pinhead comic by Bill Griffith
13:13:17 <bos> wow, wrapping C functions that can block is fun.
13:13:28 <bos> throwErrnoIfMinus1Retry_repeatOnBlock ahoy!
13:14:35 <sjanssen> bos: that's a built in function?
13:15:11 <sjanssen> @hoogle repeatOnBlock
13:15:11 <lambdabot> No matches found
13:17:34 <writerz_> SaLuT A tOuS !!!!!!!!!!!!!!!!!!!!!!!!!!!
13:17:40 <sjanssen> bos: "The rpm command I wrote correctly calculates dependencies on ... system packages too" -- I'm curious, how do you do this?
13:18:21 <writerz_> bon personne d'interessant j'me casse
13:18:21 <matthew> So was #haskell quiet this afternoon? Was the 70 or so who went to "fun in the afternoon II" noticeable?
13:19:06 <bos> sjanssen: it's implemented in Netowkr.Socket
13:19:19 <bos> sjanssen: depending on system packages isn't too hard.
13:19:45 <bos> cabal already represents the external libraries that a package needs to link against.
13:20:23 <bos> so the trick is to find those libraries (you have to use both gcc and the cabal library search path), then ask rpm who owns the libraries.
13:20:41 <bos> taking into account the fact that there might be a .so, a .a, or both.
13:20:56 <sjanssen> I see
13:21:24 <bos> so the end result is that if cabal says "i need -lbz", i can turn this into a dependency on "bzip2-devel".
13:23:27 <glguy> ?yow!
13:23:28 <lambdabot> Hold the MAYO & pass the COSMIC AWARENESS ...
13:23:33 <sjanssen> so this comes from the extra-libraries field in a cabal spec?
13:23:59 <bos> sjanssen: yep.
13:24:16 <bos> sjanssen: and extraLibDirs.
13:24:39 <bos> although any package that uses extraLibDirs is pretty well unportable.
13:24:58 <malsyned> In tutorials and discussions, I often see binary trees represented as "data Tree a = Node a | Branch (Tree a) a (Tree a)" when I would expect "data Tree a = Tree (Tree a) a (Tree a) | NullTree" to be much more convenient to work with.  Is there a strong argument I'm not aware of for tagging leaf nodes explicitly, rather than allowing them to be any node (Tree Null _ Null) ?
13:25:18 <sjanssen> bos: I think your master plan of generating rpms for all of hackage is a great idea
13:25:24 <bos> :-)
13:25:31 <glguy> malsyned: it depends exclusively on what you are using the trees for
13:25:35 <bos> it's easy to script it up now.
13:25:54 <matthew> malsyned: I tend to always moan and annoy people when they use non-empty leaves
13:26:03 <bos> for i in */Setup.*hs; do (cd $(dirname $i) && runghc $(basename $i) rpm); done
13:26:09 <malsyned> matthew: that would be my instinct as well.
13:26:29 <chessguy> for many applications you want all nodes to be of the same type
13:27:03 <matthew> malsyned: I've seen worse. Eg read Tim Sheard's papers on GADTs. The definition of tree he uses is really really weird
13:27:10 <malsyned> glguy: is it an efficiency thing?  or are there a significant number of tree operations that can be more eloquently expressed if leaves are tagged explicitly?
13:27:24 <a-oXiDe> Hi i was just wondering if anyone could help me, i was wondering whats the difference between data and type when defining data types?
13:27:42 <matthew> a-oXiDe: type is just an alias
13:27:43 <glguy> type is a synonym, a convenience
13:27:59 <sjanssen> bos: I'm pondering how one could do a similar thing for Gentoo's portage
13:28:10 <a-oXiDe> and data is values it can hold?
13:28:17 <malsyned> a-oXiDe: nope
13:28:37 <malsyned> type is analogous to a typedef in C: it doesn't actually create any new types, it just lets you give a shorter name to an existing complex type.
13:28:54 <malsyned> like, the Prelude defines "type String = [Char]" so that you don't have to write [Char] everywhere.
13:29:45 <malsyned> data lets you create new algebraic data types, which I think I'd better let someone more versed in the theory explain.  They are entirely new data types analogous to something of a cross between enums, structs, unions, and maybe some other ingredients.
13:30:07 <a-oXiDe> oh ok i understand cheers
13:30:07 <nmessenger> and "data [a] = [] | a : [a]", i.e. a list of a's is either nil, or an 'a' consed to another list of a's.
13:30:38 <glguy> or more clearly expressed as data List a = Null | Cons a (List a)
13:31:37 <nmessenger> do you understand the various parts of the datatype syntax?
13:32:27 <a-oXiDe> erm by syntax u mean 'data Answer = Yes | No | Unknown' , somethng like that?
13:32:33 <bos> sjanssen: i don't think it would be hard to do.
13:32:52 <nmessenger> yep
13:33:01 <bos> though i don't know if gentoo's package system can tell you who owns particular files.
13:33:08 <bos> if not, that's a bit of a problem.
13:33:12 <mwc> a-oXiDe, then you also have newtype :) which basically creates a type that's not interchangeably with the original but shares its underlying representation. It can have its own instances as well
13:33:14 <sjanssen> bos: I believe there are external tools
13:34:22 <a-oXiDe> ok thanks, im pretty new to haskell
13:34:29 <nmessenger> in glguy's example, "List" is a *type constructor*.  It takes some type 'a' and creates a new compound type, "List of a"
13:35:01 <nmessenger> "Null" and "Cons" are two *data constructors*, which are simple functions that make values of the List a type.
13:35:24 <glguy> :k []
13:35:26 <lambdabot> * -> *
13:35:29 <glguy> :t []
13:35:31 <lambdabot> forall a. [a]
13:35:44 <xerox> :D []
13:35:49 <nmessenger> the "Cons" constructor also requires two arguments, one of type 'a', and one of type 'List of a'.
13:36:57 <a-oXiDe> im doing an assignment and have a list of lists representing rows in a sudoku, how would i extract one list out of the list of lists at a time? i understand the take function of grid size and list comprehension and recursion
13:37:18 <glguy> > [1,2,4,6,7,9] !! 4
13:37:19 <lambdabot>  7
13:37:33 <nmessenger> the (!!) function extracts an element, head works like (!! 0), i.e. it takes the first
13:37:34 <glguy> oh, one at a time
13:37:40 <SamB> what is "a time"?
13:37:50 <glguy> > map (*2) [1,2,4,6,7,9]
13:37:52 <lambdabot>  [2,4,8,12,14,18]
13:38:39 <nmessenger> though you'd probably do well with using pattern-matching to extract the heads and tails yourself, and the Prelude has a bunch of functions that do that in common ways.
13:39:23 <a-oXiDe> i understand that but if its a list in a list eg [[1,2][3,4]] can i just do head to get [1,2]?
13:39:36 <nmessenger> > head [[1,2],[3,4]]
13:39:38 <lambdabot>  [1,2]
13:39:47 <a-oXiDe> ah awesome, thank u very much
13:40:39 <nmessenger> LB is teh helpful :)
13:43:00 <nmessenger> > [[1,2],[3,4]] == ((1 : (2 : [])) : ((3 : (4 : [])) : []))
13:43:02 <lambdabot>  True
13:43:34 <malsyned> > map head [[1, 2], [3, 4]]
13:43:36 <lambdabot>  [1,3]
13:43:40 <glguy> \ (x:_) -> give x
13:43:48 <nmessenger> give?
13:43:59 <kscaldef_> is there a platform-independent way to get the path separator, or to otherwise concatenate two FilePaths?
13:44:00 <glguy> try to ?pl it ;)
13:44:11 <nmessenger> hahahah
13:44:29 <nmessenger> @slap glguy
13:44:30 * lambdabot slaps glguy
13:44:37 <dinolinux> evening all, i'm very new to haskell, but been learning it for a few days now, so far i like it a lot, i've been reading yet another haskell tutorial, any others you might suggest?
13:45:00 <EvilTerran> kscaldef_, you'll need a library; it's a bit of a classic problem
13:45:25 <apfelmus> @where meta
13:45:26 <lambdabot> I know nothing about meta.
13:45:28 <glguy> kscaldef_: you mean using the FilePath library?
13:45:32 <apfelmus> @where metatutorial
13:45:33 <lambdabot> I know nothing about metatutorial.
13:45:45 <nmessenger> dinolinux: haskell.org list a couple of good ones in both "Haskell in 5 steps" and "Learning Haskell"
13:45:47 <apfelmus> dinolinux: http://www.haskell.org/haskellwiki/MetaTutorial
13:45:48 <lambdabot> Title: Meta-tutorial - HaskellWiki
13:46:04 <EvilTerran> I'm not aware if such a library comes bundled... FilePath sounds plausibly.
13:46:05 <EvilTerran> *e
13:46:10 <chessguy> @where+ metatutorial http://www.haskell.org/haskellwiki/MetaTutorial
13:46:10 <lambdabot> Done.
13:46:14 <kscaldef_> I don't think I've seen/noticed such a library
13:46:17 <dinolinux> thanks
13:46:24 <glguy> ?where filepath
13:46:25 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
13:46:31 <dinolinux> looking forward to learning haskell :)
13:46:35 <glguy> that's what you want
13:48:17 <kscaldef_> yeah, that looks like what I want
13:48:46 <Saizan> ?hoogle isWindows
13:48:47 <lambdabot> No matches found
13:48:50 <malsyned> dinolinux: I find the Gentle Introduction to be pretty helpful too.
13:49:00 <kscaldef_> thanks
13:49:06 <malsyned> http://www.haskell.org/tutorial/
13:49:07 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
13:49:32 <malsyned> it only covers Haskell98, so there are some interesting features of the more modern compilers that you'll want to pick up after reading it, but it's a solid introduction to the basic concepts.
13:51:37 <malsyned> dinolinux: also, if you haven't already, check out http://haskell.org/hoogle.  It's indispensable for trying to read sample code you come across before you're familiar with the standard Prelude.
13:51:38 <lambdabot> Title: Hoogle
13:52:02 <dinolinux> ah thanks, i've been looking for some sample code
13:52:42 <thorat> dinolinux: the standard prelude code itself is also very informative
13:53:28 <nmessenger> http://www.haskell.org/onlinereport/standard-prelude.html
13:53:30 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
13:59:32 <a-oXiDe> im a little confused as to how i maybe going wrong here, if i have a type Matrix = [Row] and type [Row] = [Int] then to return a set row i would take 'row a = Matrix!!a'?  I'm getting a not in scope datacontructor error
13:59:58 <mauke> type [Row] looks like a syntax error
14:00:09 <mauke> Matrix is a type, not a value
14:00:19 <nmessenger> a Row should logically be a list of Int, thus "type Row = [Int]"
14:00:28 <mauke> did you mean a !! 0 or something?
14:00:37 <matthew> you might have meant type Row = [Int]
14:00:38 <Botje> a-oXiDe: you need to actually declare something of type matrix too.
14:00:51 <a-oXiDe> yeah i declared Matrix = [Row]
14:00:54 <Botje> no..
14:00:57 <Botje> that's a type definition
14:01:03 <Botje> you need to declare a _VALUE_ of type matrix.
14:01:14 <nmessenger> and Matrix is a *type*, not a value, so you should say "[[1]] !! 0" not "Matrix !! 0"
14:01:15 <mauke> a-oXiDe: that's like saying 2 + Int
14:01:17 <mauke> it doesn't make sense
14:01:54 <a-oXiDe> ah rite i thought i could just define it saying that a matrix is a list of rows that contain a list of ints
14:02:14 <glguy> [[Int]]
14:02:16 <nmessenger> aye, so you can type ([[1]] :: Matrix)
14:02:42 <nmessenger> "a list containing a list containing a 1 has type Matrix"
14:02:58 <sieni> no it doesn't
14:03:08 <sieni> well it does
14:03:20 <sieni> wtf am I talking about?
14:03:24 <xerox> @slap sieni
14:03:24 * lambdabot slaps sieni
14:03:29 <nmessenger> :P
14:03:52 <sieni> but [[Int]] is not the right type for matrices
14:04:04 <mauke> it's good enough
14:04:08 <nmessenger> so you can define functions (f :: Matrix -> blah) and it'll accept a [[Int]]
14:04:31 <a-oXiDe> when u say declare a _Value_ of type matrix im confuse
14:04:39 <a-oXiDe> *confused
14:05:03 <nmessenger> type Matrix = [[Int]], thus any list of list of Ints could be typed as a Matrix
14:05:13 <nmessenger> they are type synonyms
14:05:29 <a-oXiDe> ok i understand that
14:05:43 <sieni> mauke: well... you could have mismatches with the number of rows for example (if the the outer list is the list of columns)
14:05:51 <Syzygy-> I'm very much considering making Matrices typed Num a => Array (Integer,Integer) a
14:05:57 <Syzygy-> for the numeric prelude...
14:06:08 <nmessenger> sieni: true, but for simple learning stuff it doesn't matter a great deal.
14:06:12 <mauke> a-oXiDe: "foo" is a value of type String
14:06:25 <nmessenger> and "type String = [Char]"
14:06:29 <mauke> you can say length "foo", but not length String
14:06:32 <glguy> foo has type String, String has kind * :)
14:06:37 <nmessenger> so "foo" = ['f', 'o', 'o']
14:06:44 <a-oXiDe> ahk yeah
14:06:50 <nmessenger> kinds can wait a short while
14:06:53 <sieni> nmessenger: depends on how much you value the type safety of Haskell
14:07:36 <sieni> nmessenger: you shouldn't be able to construct such values anyway
14:07:39 <nmessenger> sieni: understanding what the "type" and "data" decls mean comes first :)
14:08:37 <nmessenger> sieni: after that, type correctness is indeed vital.
14:09:45 <sieni> although it might be tricky to try to prevent e.g. matrix multiplication when it's not allowed
14:10:23 <nmessenger> the "type" decl doesn't give you any new ways to create values, you have to use the underlying type constructors, i.e. [[1]] or [[1,2],[3,4]], etc.
14:10:56 <nmessenger> s/type constructors/data constructors/  bleh
14:11:17 <nmessenger> "type's constructors" I think I meant
14:12:50 <a-oXiDe> cheers for that, i got it working now
14:13:02 <a-oXiDe> and understanding the difference :)
14:13:29 <nmessenger> \o/
14:17:11 * glguy thinks that what sieni wants a fully dependent types
14:17:17 <glguy> a/is
14:17:36 <glguy> system
14:18:01 <nmessenger> @spell glguy
14:18:02 <lambdabot> gluey glut kluge glue glum
14:18:34 <glguy> glguy isn't a word... jeez
14:18:42 <glguy> or a real one at least
14:19:11 * glguy ponders
14:19:15 <glguy> ?all-dicts word
14:19:19 <lambdabot> *** "Word" gcide "The Collaborative International Dictionary of English v.0.48"
14:19:21 <lambdabot> Word \Word\, n. [AS. word; akin to OFries. & OS. word, D. woord,
14:19:23 <lambdabot>    G. wort, Icel. or[eth], Sw. & Dan. ord, Goth. wa['u]rd,
14:19:25 <lambdabot>    OPruss. wirds, Lith. vardas a name, L. verbum a word; or
14:19:27 <lambdabot>    perhaps to Gr. "rh`twr an orator. Cf. {Verb}.]
14:19:29 <lambdabot> [330 @more lines]
14:19:39 * nmessenger prefers @wn, it's usually pretty succinct
14:19:53 <hpaste> @wn word
14:19:54 <lambdabot> *** "word" wn "WordNet (r) 2.0"
14:19:54 <lambdabot> word
14:19:54 <lambdabot>      n 1: a unit of language that native speakers can identify; "words
14:19:54 <lambdabot>           are the blocks from which sentences are made"; "he
14:19:54 <lambdabot>           hardly said ten words all morning"
14:19:56 <lambdabot> [23 @more lines]
14:20:05 <chessguy> very succinct :)
14:20:15 <hpaste> @wn succinct
14:20:17 <lambdabot> *** "succinct" wn "WordNet (r) 2.0"
14:20:17 <lambdabot> succinct
14:20:17 <lambdabot>      adj : briefly giving the gist of something; "a short and
14:20:17 <lambdabot>            compendious book"; "a compact style is brief and
14:20:17 <lambdabot>            pithy"; "succinct comparisons"; "a summary formulation
14:20:19 <lambdabot>            of a wide-ranging subject" [syn: {compendious}, {compact},
14:20:21 <lambdabot>             {summary}]
14:20:32 <glguy> ?jargon recursion
14:20:34 <lambdabot> *** "recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:20:34 <lambdabot> recursion n. See {recursion}. See also {tail recursion}.
14:20:34 <lambdabot>  
14:20:50 <Boney> hah
14:21:09 <nmessenger> @slap Jargon File
14:21:09 * lambdabot smacks Jargon File about with a large trout
14:21:25 <glguy> ?jargon tail recursion
14:21:27 <lambdabot> No match for "tail".
14:21:27 <lambdabot>  
14:21:27 <lambdabot> *** "recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:21:27 <lambdabot> recursion n. See {recursion}. See also {tail recursion}.
14:21:27 <lambdabot>  
14:21:28 <Boney> you need a bot to slap for you ?
14:21:33 <glguy> ?jargon "tail recursion"
14:21:34 <lambdabot> *** "tail recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:21:34 <lambdabot> tail recursion n. If you aren't sick of it already, see {tail
14:21:34 <lambdabot>    recursion}.
14:21:35 <lambdabot>  
14:21:38 <bd_> XD
14:21:43 <glguy> ?quote bot
14:21:44 <lambdabot> kolmodin says: it's nice to have static types after a bottle of wine
14:21:48 <chessguy> i don't think /slap works any more
14:21:49 <glguy> ?quote bot.*fight
14:21:50 <lambdabot> glguy says: lol, making lambdabot fight your battles
14:21:53 <bd_> ?quote ghc
14:21:53 <lambdabot> ghc says: GHC error in desugarer lookup
14:22:00 * nmessenger slaps /slap with a large smelly trout
14:22:07 <norpan> romeo&julieta + 15 yo laphroaig
14:22:13 <norpan> that's what i call pleasure
14:22:29 <hpaste> @slap Boney
14:22:29 * lambdabot beats up Boney
14:22:39 <glguy> I have a bot have a bot fight my battles for me
14:22:46 <chessguy> @slap norpan
14:22:46 <lambdabot> why on earth would I slap norpan
14:22:55 <lambdabot> glguy: You wish.
14:22:59 <norpan> that's my bot!
14:23:17 <lambdabot> norpan: I am nobody's bot.
14:23:26 <nmessenger> rank-2 botomorphism!
14:23:35 <hpaste> Pay no attention to the man behind the curtain
14:23:44 <lambdabot> Indeed.
14:23:51 <lambdabot> Not that it need be a man.
14:24:00 <chessguy> ?users
14:24:00 <lambdabot> Maximum users seen in #haskell: 317, currently: 315 (99.4%), active: 54 (17.1%)
14:24:12 <norpan> jag kÃ¤nner en bot, hon heter anna, anna heter hon
14:24:14 <Pseudonym> G'day everyone.  Quick question.
14:24:14 <chessguy> ooh, almost maxed out
14:24:19 <chessguy> hi Pseudonym
14:24:21 <kolmodin> norpan: haha :)
14:24:29 <Pseudonym> Anyone know of a pread()/pwrite() binding for Haskell?
14:24:35 <Pseudonym> Perhaps one that works with FPS?
14:24:42 <chessguy> norpan, this is an english channel. please follow suit
14:24:46 <Pseudonym> It shouldn't be hard, but I thought I'd ask first.
14:25:03 <norpan> chessguy: it was not possible to write that in anything else than swedish
14:25:03 <Pseudonym> That's right.  Only English, no Scheme.
14:25:14 <Pseudonym> norpan: #haskell.se exists
14:25:23 <norpan> don't i know it
14:25:37 <chessguy> ?users #haskell.se
14:25:37 <lambdabot> Maximum users seen in #haskell.se: 1, currently: 0 (0.0%), active: 0 (NaN%)
14:25:39 <Pseudonym> I am curious what it means, though.
14:25:43 <glguy> ?bable se en jag kÃ¤nner en bot, hon heter anna, anna heter hon
14:25:43 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language se not supported
14:25:59 <chessguy> ?google babelfish
14:25:59 <Pseudonym> heter means "the same"?
14:26:00 <lambdabot> http://babelfish.altavista.com/
14:26:00 <lambdabot> Title: AltaVista - Babel Fish Translation
14:26:02 <norpan> it's a lyric from a song about an irc bot
14:26:10 <norpan> it means "i know a bot, her name is anna"
14:26:45 <norpan> it was last summer's torment
14:27:14 <Pseudonym> It's still Summer here.
14:27:16 <norpan> kolmodin knows
14:27:50 <xerox> http://basshunter.m0o.eu/
14:27:51 <lambdabot> Title: Basshunter Subtitled Vids
14:27:55 <xerox> Second link in the upper left.
14:27:59 <norpan> wow
14:28:49 <Pseudonym> Given that it's still Summer here, and we're still being tormented by "I don't need a man"...
14:28:54 <chessguy> that's pretty catchy
14:29:12 <norpan> it's catchy, but he is such a bad singer
14:29:41 <Pseudonym> Hmmm.
14:29:50 <chessguy> well, i wouldn't expect swedish to be an easy language to sing in
14:29:56 <Pseudonym> What was last Summer's torment in the Southern Hemisphere?
14:30:03 <Pseudonym> Oh, yes, that's right.  James Blunt.
14:30:20 <nmessenger> my Internet is zipping along at a whole 4.8 Kilobits per second, so I'll not be watching any streaming video. :(
14:30:31 <svref> Is falling off the end of main without calling hClose on open file-handles Bad?
14:31:22 <norpan> they should close automatically
14:31:29 <Pseudonym> Not in any reasonable operating system.
14:31:29 <bd_> I think the RTS guarentees that finalizers will be called before termination
14:31:39 <bd_> ?where hs-plugins
14:31:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:31:46 <Pseudonym> It's worse if you don't clean up SysV shm segments or something.
14:32:07 <norpan> the english subtitles were not a very accurate translation
14:32:37 <norpan> but i suppose the meaning goes through
14:33:51 <chessguy> was this actually a popular song?
14:34:03 <norpan> chessguy: yeah, beats me
14:34:09 <norpan> i find it awful
14:34:09 <chessguy> heh
14:34:18 <chessguy> irc must be much more common in Sweden than here
14:34:29 <chessguy> you have to be pretty geeky to use it here
14:34:40 <norpan> many people thought it was about a "bÃ¥t" instead (boat)
14:34:49 <chessguy> lol
14:34:59 <norpan> as shown in the video :)
14:35:09 <chessguy> a båt that kicks spammers?
14:35:13 <norpan> a boat in a channel makes perfect sense
14:35:23 <xerox> hahaha...
14:35:48 * nmessenger nomimates LB for a rename to "lambdaboat"
14:35:54 <chessguy> haha
14:36:10 <chessguy> @nick lambdaboat
14:36:10 <lambdabot> Maybe you meant: dice dict
14:36:26 <Igloo> kolmodin: You should be able to quasi-quote some normal Haskell and print it out to see how to build it
14:39:18 <kolmodin> Igloo: umm.. ok, thanks
14:39:41 <chessguy> @quote
14:39:41 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
14:40:37 <nmessenger> Functor: "Monad... I Am Your Father!"
14:41:47 <bd_> map: "List... I am your functor!"
14:41:56 <nmessenger> heh
14:41:59 <chessguy> oh my
14:42:04 <chessguy> it's really getting bad in here
14:43:10 <Cheery> nmessenger: List GeneralDataStructure: "NOOOOOOO!!!!!"
14:43:49 <kolmodin> Igloo: works like a charm, thanks
14:44:30 <Cheery> Xanadu -system seems impartial.
14:44:37 <Cheery> It does only consider text. :(
14:44:41 <emu> idle question: list comprehensions are based on set-notation, but even having monad comprehensions wouldn't let you actually specify Data.Sets as comprehensions.  isn't that a bit odd?
14:45:17 <bd_> Actually, someone built a Set monad.
14:45:24 <bd_> ?where monadset
14:45:25 <lambdabot> I know nothing about monadset.
14:45:39 <chessguy> @go haskell Set monad
14:45:42 <lambdabot> http://sigfpe.blogspot.com/2006/11/why-isnt-listt-monad.html
14:45:42 <lambdabot> Title: A Neighborhood of Infinity: Why isn't ListT [] a monad?
14:45:48 <chessguy> bzzt.
14:45:53 <bd_> ?where+ MonadSet http://article.gmane.org/gmane.comp.lang.haskell.cafe/18118
14:45:54 <lambdabot> Done.
14:46:03 <Cheery> Thus it does not consider much how to edit documents which should retain their revision -identity.
14:46:39 <Cheery> oh, and it's practically layout-blind. :)
14:59:12 <Cheery> Is there a drawing program or some such written in haskell?
14:59:28 <norpan> drawing, as in images?
14:59:32 <Cheery> yep.
14:59:41 <Cheery> simple text editor would go as well.
14:59:53 <norpan> we never do anything simple
14:59:56 <abz> what like gimp?
14:59:57 <norpan> for that we use c++
15:00:27 <nmessenger> @where pancito
15:00:27 <lambdabot> http://www.acooke.org/jara/pancito/
15:00:29 <Cheery> I'd like to know how you can allow interactive editing of persistent data with functional languages similar to haskell.
15:00:46 <norpan> have a look at yi
15:00:46 <nmessenger> ^^ I've heard of that, it represents images as Point -> Color functions.
15:01:07 <malsyned> how is yi?  I'm just building it now.
15:01:53 <Pseudonym> Cheery: It depends on what you're doing.
15:02:20 <Pseudonym> Generally speaking, we make tricky data structures and then hide them behind a beautiful API.
15:02:23 <norpan> but the easy answer is embed it in a monad :)
15:02:59 <Pseudonym> All you then need is a silver forge to make your bullets in.
15:03:01 <dons> Cheery: you edit your persistent, mutable data in a monad
15:03:36 <dons> e.g. see Yi
15:03:37 <dons> :-)
15:03:40 <Cheery> ok. :)
15:03:48 <norpan> dons: i agree :)
15:03:58 <thorat> should we use Yi from darcs or tarball
15:03:59 <thorat> ?
15:04:05 <dons> from darcs
15:04:09 <dons> it supports syntax highlighting
15:04:11 <Pseudonym> Speaking of persistent, mutable data, I need to repeat a question I asked earlier.
15:04:16 <dons> but note, its a bit experimental in darcs
15:04:22 <dons> actually, you could use the tarball
15:04:26 <dons> its faster, and looks like vi
15:04:27 <Cheery> I guess you can't imagine how much am I intrigued by this kind of software written in haskell.
15:04:30 <dons> just no syntax highlighting
15:04:32 <Pseudonym> Has anyone done a binding of pread/pwrite that works with fps?
15:04:35 <thorat> the tarball is ancient ;)
15:04:47 <dons> Cheery: why? its a general purpose language -- would kinda suck if you couldn't edit data ..
15:05:08 <dons> its all in the monad
15:05:10 <bos> @hoogle ioError
15:05:11 <lambdabot> Prelude.ioError :: IOError -> IO a
15:05:11 <lambdabot> Prelude.IOError :: type IOError
15:05:11 <lambdabot> Control.Exception.ioErrors :: Exception -> Maybe IOError
15:05:13 <malsyned> this is so weird.  I was just trying to build yi after reading about in some random old #haskell log that I found chasing down an LB-remembered quote, when suddenly the whole channel starts building yi.
15:05:33 <Cheery> dons: yes, but it's not straightforward, when compared to procedural languages' style of doing same programs.
15:05:35 <Pseudonym> Distributed builds are good, surely?
15:05:40 <shapr> Yi is way cool.
15:06:04 <Cheery> And because there's so much differences, there must also be something really interesting to be learned about it. :)
15:06:31 <mauke> haskell can execute arbitray machine code, see http://hpaste.org/567 :-)
15:06:42 <dons> Cheery: it isn't? you just write imperative code in the IO monad (that's one way)
15:06:47 <bos> @hoogle errnoToIOError
15:06:48 <lambdabot> Foreign.C.Error.errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError
15:06:54 <dons> pretty much the same code, but with a few other higher order functions tossed in
15:07:19 <Pseudonym> mauke: Just import unsafeExecuteArbitraryMachineCode
15:07:32 <mauke> @index unsafeExecuteArbitraryMachineCode
15:07:32 <lambdabot> bzzt
15:08:18 <malsyned> is there a utility for automatically tracking down and installing cabal dependencies?
15:08:23 <Cheery> dons: yep, I know you use monads, but usage of monads is not seeming straightforward when your program grows in size.
15:08:44 <bos> there's got to be a nicer way to raise an IO exception than ioError (errnoToIOError "sendChunks" eINVAL Nothing Nothing)
15:08:54 <dons> why? you use only 1 or 2, and they neatly partition different parts of the program from each other.
15:09:04 <Excedrin> mauke: that's really neat
15:09:06 <dons> have you use monads in larger programs?
15:09:32 <malsyned> Cheery: you'd be surprised.  I've found, in admittedly limited experience, that monadic IO scales better than traditional IO.
15:10:23 <Cheery> dons: not yet, but I'd except so to happen. Not sure thought. :)
15:10:41 <Cheery> *expect
15:10:47 <malsyned> you have to become comfortable with the monadic combinator operators, though.  do notation isn't nearly as much fun.
15:11:17 <sorear> hello.
15:11:17 <Cheery> I'm attempting to write some kind of bigger software sooner or later with haskell, thought.
15:12:04 <malsyned> hey sorear
15:12:08 <bos> niiice. efficient chunked network I/O using writev.
15:12:31 <malsyned> sorear: I'm just about to build vty.  should I go with the head of the repo, or should I grab a tag?
15:15:59 <fuzan> <3 ghci compile-time.
15:16:27 * kc5tja is just plain looking for an excuse to code something in Haskell.  :)
15:19:16 <chessguy> woohoo! my very own copy of HSOE hath arriven!
15:19:26 <fuzan> HSOE?
15:19:30 <sorear> malsyned: the head should work (I haven't tested it much), but note that I've broken compatability twice
15:19:48 <chessguy> ?where hsoe
15:19:48 <lambdabot> I know nothing about hsoe.
15:20:02 <sorear> malsyned: yi is AFAIK the only program so far updated to use the new (and *much* faster) 3.0 api
15:20:22 <malsyned> so if I grab the 3.0 tag, I'll be good to go?  (I'm building yi, that's why I'm getting vty)
15:20:30 <chessguy> ?where soe
15:20:30 <lambdabot> http://haskell.org/soe/
15:20:31 <sorear> yeah
15:20:39 <chessguy> ?where+ hsoe http://www.haskell.org/soe/
15:20:39 <Cheery> "cannot satisfy dependency vty>=3.0"
15:20:40 <lambdabot> Done.
15:20:53 <Cheery> What is vty?
15:21:07 <malsyned> sorear: does vty have a web page?
15:21:10 <Cheery> ?where vty
15:21:11 <lambdabot> http://members.cox.net/stefanor/vty/
15:21:18 <sorear> the terminal interface library I wrote a year ago after I gave up learning ncurses
15:21:27 <nmessenger> kc5tja: just yesterday I wrote a script that compares a list of files to find duplicates.  You could write little tools like that.
15:21:32 <dibblego> I wish there was a Haskell <-> XML translator somewhere so that I can write applications with Haskell, then say "it's just configuration"
15:21:40 <sorear> I honestly never knew it would become this popular...
15:21:44 <dibblego> <map f="+2" list="xs"/>
15:21:50 <malsyned> sorear: also, is it possible that vty requires ghc 6.6?  Setup is telling me "unknown field "install-includes""
15:21:55 <SamB> dibblego: hah
15:22:03 <SamB> dibblego: it would be way longer though
15:22:14 <dibblego> SamB, of course; but that's what "they" want
15:22:33 <Cheery> so... it possibly requires the newest ghc...
15:22:35 <dibblego> SamB, ideally, I'd write Haskell, then press the "appeal to the pointy-haired boss" button, which outputs XML
15:22:41 <sorear> malsyned: it needs, 6.6, blame dons, if you want it to work on 6.4 (a) delete that field (b) add a fps dependency
15:22:49 <chessguy> dibblego, haxml?
15:23:13 <malsyned> sorear: well, if I'm to blame dons, then I should probably expect yi to want 6.6 too, huh?
15:23:14 <sorear> malsyned: but aside from Data.ByteString and the cabal issue you mention, vty is H98+addenda (no h' even)
15:23:23 <Cheery> So I guess it is time for me to actually install newest ghc+ghci to my system. :)
15:23:28 <dibblego> I'm not sure haxml does that
15:23:56 <Cheery> wait... there's both authors of Yi and vty?
15:24:38 <mbishop> Haha ESR getting ripped on reddit, I love it
15:25:39 <Cheery> I think I'll start the installing rumba after I've got some sleep.
15:26:26 <Cheery> Hopefully it won't be too hard procedure for somebody who has compiled&installed software before. :/
15:27:00 <SamB> <app><var name="map"/><app><var name="flip"/><var name="+"/><int value="2"/></app><var name="xs"/></app>
15:27:07 <sorear> Cheery: both authors?
15:27:12 <kc5tja> nmessenger: But I already have these kinds of tools written in other languages.  :D
15:27:38 <Cheery> sorear: just wondering because if it's so, that's neat.
15:27:44 <shapr> kc5tja: Well, it would be an excuse...
15:27:44 <sorear> Cheery: also, I've heard GHC-6.6 takes a *long* time to build
15:27:57 <sorear> Cheery: no, I mean I didn't understand :)
15:28:34 <chessguy> shapr!
15:28:38 <nmessenger> SamB: I tried to write something like that but decided I was *way* too lazy.
15:28:49 <Cheery> ah, I were asking whether there's both, author(s) of Yi and author(s) of vty on this channel?
15:29:08 <shapr> chessguy!
15:29:19 <shapr> Cheery: yup
15:29:39 <SamB> try dons and sorear ;-)
15:29:53 <sorear> jyp (yi) also comes pretty often
15:30:06 <sorear> @seen tuomov
15:30:07 <lambdabot> I haven't seen tuomov.
15:30:11 <Cheery> sorear: Do you think I could get my hands on x86/IA32 -version of GHC-6.6 without compiling it myself?
15:30:15 <SamB> @localtime dons
15:30:17 <lambdabot> Local time for dons is Thu Feb 22 10:28:11 2007
15:30:21 <sorear> Cheery: easily!
15:30:26 <chessguy> shapr, how's things? getting any less crazy?
15:30:28 <sorear> haskell.org/ghc
15:30:52 <sorear> Cheery: I assume you are running ubuntu?
15:31:03 <Cheery> correct assumption.
15:31:13 <sorear> http://haskell.org/ghc/download_ghc_66.html
15:31:14 <lambdabot> Title: GHC: Download version 6.6
15:31:40 <sorear> so, there's a "generic" (ie statically linked) binary option
15:32:05 <sorear> worst case scenario, you'll need to use a hexeditor to fix the readline dependency
15:32:12 * sorear did that installing 6.4.2
15:32:39 <psi>  it's worth trying the debian package first.
15:33:03 <siti> 6.6 is in fiesty but that's obviously in beta
15:33:46 <sorear> psi: why? the generic 6.4.2 worked fine for me (after hexedit), and I use it fairly regularly
15:35:52 <psi> because it can be handled by package system.
15:36:30 <sorear> ah right.  keep forgetting they use the same package manager.
15:36:47 <shapr> chessguy: Yeah, things are getting less crazy, what can I do for you?
15:36:53 <sorear> as opposed to, say, installing and rpm vs. general on debian
15:37:11 <Cheery> sorear: ubuntu repo gives me 6.4 only.
15:37:24 <chessguy> shapr, wasn't looking for anything in particular
15:37:37 <shapr> chessguy: How's your code going?
15:37:39 <kc5tja> shapr: While true, it'd also be wasted effort, too.  :)
15:37:50 <sorear> Cheery: I know, it's very well known here *sigh*
15:37:53 <kscaldef_> is there some sort of monadic version of 'if'?  So that I can write something like
15:37:55 <kscaldef_> do is_dir <- doesDirectoryExist f
15:37:55 <kscaldef_>    if is_dir then doDirStuff else doFileStuff
15:38:01 <diogo> hello
15:38:03 <kscaldef_> without needing a temp variable
15:38:13 <chessguy> it's coming along. i pretty much dropped the simulator thing, because i couldn't see any way to improve it
15:38:31 <shapr> kc5tja: Ah, but you'd learn something, and that's not a waste.
15:38:35 <sorear> kscaldef_: no, it's a common library wishlist item :(
15:38:41 <diogo> is this correct?
15:38:41 <chessguy> but i've started working on a genetic programming framework in haskell, which is going well
15:38:42 <diogo> let x   = [r1, r2]
15:38:54 <kscaldef_> sorear: that seems to be the answer to all my questions today
15:39:11 <sorear> kscaldef_: sigh.
15:39:32 <psi> Cheery: try downloading it manually from http://packages.debian.org/testing/devel/ghc6
15:39:33 <lambdabot> Title: Debian -- ghc6
15:39:35 <shapr> chessguy: That sounds nifty.
15:39:51 <diogo> * let x = [r1, r2]
15:39:51 <diogo> * r1r = therule r1
15:39:51 <diogo> * r2r = therule r2
15:39:52 <diogo> * in r1r ||| r2r
15:40:13 <dons> anyone know where to get the hbc src?
15:40:23 <dons> anyone at chalmers?
15:40:24 <chessguy> ?where hbc
15:40:24 <lambdabot> http://www.cs.chalmers.se/~augustss/hbc/hbc.html
15:40:28 <dons> or named 'lennart' ?
15:40:42 <dons> chessguy: the link there is dead
15:41:20 <nmessenger> diogo: the definitions of r1r and r2r should align with x
15:41:42 <Cheery> psi: ok, were i386 equivalent to x86?
15:41:51 <chessguy> dons, ah. i couldn't remember, but i thought i had seen someone where+ it recently
15:41:52 <diogo> hm
15:42:08 <dons> yeah, me. adding the above link :-)
15:42:09 <psi> Cheery: yeah
15:42:20 <shapr> dons: I have a local copy from 2004, you want it?
15:42:26 <diogo> it's aligned but i still get a parser error
15:42:45 <diogo> on the second =
15:42:55 <Cheery> good night.
15:43:24 <nmessenger> @paste it on hpaste.org
15:43:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:43:39 <dons> shapr: oh, you have src?
15:43:45 <diogo> could be a problem from my editor?
15:43:54 <nmessenger> possibly
15:44:26 <shapr> dons: I have a copy of everything I could get my hands on up until the last year or so.
15:44:39 <dons> could you host the src somewhere so I could grab it?
15:44:42 <sorear> @seen augustss
15:44:43 <lambdabot> I saw augustss leaving #haskell 1d 14h 43m 47s ago, and .
15:44:44 <dons> i'm pondering reviving hbc..
15:45:02 <shapr> dons: http://www.scannedinavian.com/~shae/hbc-2004-06-29.src.tar.gz
15:45:08 <dons> woot
15:45:23 <sorear> if that's the speed of a haskell->LML compiler - how fast is native LML?
15:45:43 <shapr> dons: I don't know if there's a more recent version of hbc, but that's what I have.
15:46:12 * sorear has fetched too
15:46:14 <dons> sorear: its just a haskell compiler
15:46:18 <dons> that used to be an lml compiler
15:46:28 <dons> shapr: yeah, i'll bug lennart about it when he appears
15:46:30 <sorear> dons: oh, ooops
15:46:43 <sorear> so how did Lazy ML handle IO
15:47:30 <dons> wel, if its an ML, probably impurely :-) better ask lennart though
15:49:22 * sorear also wonders if there will ever be hbc' ...
15:49:44 <fuzan> hbc?
15:50:23 <sorear> Haskell B Compiler
15:50:24 <chessguy> shapr, if you care to keep up with my code, keep an eye on darcs get http://catenova.org/~awagner/GPLib
15:50:26 <lambdabot> Title: Index of /~awagner/GPLib/
15:50:37 <fuzan> B as in?
15:50:38 <sorear> among the oldest, and apparently still among the best.
15:50:43 <sorear> Brooks :)
15:50:43 <fuzan> ah.
15:50:50 <fuzan> benchmarks?
15:50:57 <sorear> like, no significant updates since 1995 old
15:51:00 <dons> sorear: there's no one maintaining it at all.
15:51:02 <fuzan> oooh.
15:51:08 <sorear> @where nobench-results
15:51:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/results.html
15:51:09 <dons> so if there's to be hbc 1.0, it would be up to us
15:51:22 <sorear> fuzan: that link
15:51:54 <sorear> apparently dons is in the middle of regenerating the benchmarks :)
15:52:02 <fuzan> is it even feasible to revive hbc to the new specifications and compete against ghc?
15:52:14 <dons> it is an h98 compiler
15:52:16 <JohnMeacham_> it would be nice if the nobench results page didn't erase itself until the new run was complete.
15:52:20 <dons> so its mostly a matter of porting libs
15:52:22 <sorear> fuzan: later in the lists there are a half-dozen benchmarks hbc does much better than ghc.
15:52:24 <fuzan> ah
15:52:34 <dons> JohnMeacham_: yeah sorry. i'm just tweaking things.
15:52:38 <dons> once it settles down, that won't happen
15:52:40 <sorear> so, what brings you back here?
15:52:42 <sorear> :)
15:53:30 * sorear goes to implement separate jhc-grin and jhc-ghc nobench compilers, leaving jhc-grin disabled for now
15:54:33 <bos> @hoogle sizeOf
15:54:34 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
15:54:40 <JohnMeacham_> jhc-dotnet perhaps soon too.
15:55:10 <sorear> JohnMeacham_: any gotchas, or just "add -fvia-ghc to the command line"
15:55:11 <sorear> ?
15:55:46 <sorear> heh, jhc is still using $(HBC_RUN_ARGS)
15:55:56 <sorear> manualsearchandreplace--
15:56:47 <bos> dons: ping
15:56:50 <JohnMeacham_> something I noticed about the benchmarks, is that a lot of them arn't written to use modern strictness notations on their data types. I think either adding some example with some modestly strictified (as in, what a reasonable programmer would add nowadays) data types, or reworking some of the old examples some would help.
15:57:26 <sorear> nah!  compilers like jhc are supposed to be *good* at inferring things like that!
15:57:27 <JohnMeacham_> sorear: that should work in general, not sure if it is in the most recent build.
15:57:27 <dons> bos: pong
15:57:37 <dons> JohnMeacham_: yeah, almost all the 'real' programs need fixing
15:57:43 <dons> or finding modern programs..
15:57:45 <sorear> JohnMeacham_: isn't the whole point of nofib the fact that it is naive code?
15:58:03 <dons> the 'real' progs are mostly circa 1990 though
15:58:07 <dons> so they're a bit weird
15:58:31 <JohnMeacham_> it should be natural code, not naive code. which involves some strictness nowadays. (but not at the expense of clarity)
15:59:05 <fuzan> Ugh, these gentoo builds are annoying me now :\
15:59:16 <bos> dons: do you know if a handle that you get from a socket is buffered? it appears to be.
15:59:24 <JohnMeacham_> also, custom data types and newtypes, which wern't that popular pre-deriving days, but would likely be used a lot now.
15:59:31 <chessguy> heh. apparently there are no solutions given for the exercises in SOE
15:59:34 <dons> bos, possibly. you can set it unbuffered though
15:59:45 <bos> ok.
15:59:54 <dons> JohnMeacham_: and library code. no benchmarks use Data.Map, for example
16:00:15 <bos> on an unrelated note, is there a downside to -fbang-patterns vs. using `seq` in a guard?
16:00:27 <dons> only that hugs doesn't support them
16:00:30 <dons> do you use hugs :-)
16:00:44 <bos> one outgrows hugs rather rapidly :-)
16:00:45 <dons> I use -fbang-patterns a lot now. they're really really really better than `seq`
16:01:17 <dons> there's less of a penalty for giving strictness, so its a bit cheaper to tune the evaluation order
16:02:51 <sorear> wow, I have a nested conflict!
16:02:57 <JohnMeacham_> but I worry it will encourage the overstrictness syndrome. where people just strictify everything without knowing why and end up with that other type of space leak. also, at some point, you gotta trust your compiler :)
16:03:29 <mwc> dons, how do you tune the eval order with bang patters. a `seq` b `seq` c is obvious..
16:03:36 <dons> f !x = ..
16:03:41 <dons> f x = x `seq` ...
16:03:44 <dons> pick one
16:03:55 <mwc> dons, right, but if you had f !x !y = ...
16:03:56 <dons> JohnMeacham_: right. it may do
16:04:02 <mwc> how do you pick x or y?
16:04:11 <mwc> (to be evalutated first)
16:04:18 <dons> JohnMeacham_: feedback from say, ghc core, on when it actually matters would be useful
16:04:24 <sorear> mwc: you dont'
16:04:29 <JohnMeacham_> the evaluation order of a `seq` b `seq` c is _undefined_, remember, seq is only defined by seq _|_ _ = _|_, it certainly does not imply its first argument is evaluated before its secondp
16:04:32 <dons> mwc, i don't. i look at what gets unboxed in the compiler
16:04:37 <sorear> mwc: those seqs don't sequence anything
16:04:43 <dons> its really more useful as a strictness hint
16:04:50 <mwc> ah, that's how I see it
16:05:01 <dons> that such a value will never be bottom, so you can unbox it and use a raw machine word (or whatever)
16:05:19 <mwc> yeah, that's useful
16:05:26 <dons> ghc does pretty well. but sometimes you have to nudge the strictness analyser in  the right direction
16:05:47 <dons> e.g. strictifying strict bytestrings turns them into a char*
16:05:56 <JohnMeacham_> dons: yeah. and feedback from space profiling. like.. syntax highlight the terms that are generating the most garbage.
16:06:12 <dons> yeah
16:06:17 * sorear is now running nobench with jhc -fvia-ghc
16:06:24 <dons> i'd like to have a buffer with the current expression's core output
16:06:37 <dons> so i can, e.g, add a bang pattern and see what core is generated
16:06:52 <sorear> GHC-API ftw!
16:07:13 <sorear> so, how big is the demand for a core prettier-printer?
16:07:14 <sorear> :)
16:07:22 <dons> i've just started another benchmark run, which should hopefully fix up hbc hugs and nhc a bit
16:07:28 <dons> missing packages, too small heaps and so on
16:07:29 <dons> http://www.cse.unsw.edu.au/~dons/nobench/results.html
16:07:30 <lambdabot> Title: nobench: Haskell implementation shootout
16:07:53 <dons> i'm going to have to hassle ndm about this 'i use hugs because its faster' malarky
16:08:05 <dons> since even nop is almost the same with hugs
16:08:15 <JohnMeacham_> sorear: jhc has one :) you need a unicode terminal to view it prettily though.
16:08:15 <dons> oh, we have hbi too
16:08:20 <dons> should test that at some point
16:08:31 <sorear> JohnMeacham_: how pretty is it?
16:08:44 <sorear> JohnMeacham_: I want to add infix operators and un-renaming.
16:09:05 <sorear> JohnMeacham_: a little bit of type erasure *might* be nice.
16:09:30 <shapr> Isn't there some simple syntax to import a module and re-export everything it exports?
16:09:37 <sorear> yes
16:09:48 <shapr> sorear: What is that syntax?
16:09:51 <dons> anyone know how to incresae the stack size in hugs?
16:10:04 <dons> i can only find -h (heap) on the hugs page
16:10:07 <sorear> module This (.., module Othor, ...) where ... import Other ...
16:10:16 <shapr> Ah, thanks.
16:10:19 <JohnMeacham_> scroll down a ways in here... though, this is fairly out of date. http://repetae.net/lcube.html
16:10:20 <lambdabot> Title: jhc -v Try-Hello.hs -flint --ignore-ho -dhtml
16:10:42 <sorear> infertype:
16:10:42 <sorear> >>> internal error:
16:10:42 <sorear> Strong': ^[[1m?^[[0m x200
16:10:42 <sorear> Cannot strong:
16:10:45 <sorear> (^[[1m?^[[0m, [x200])  -- JohnMeacham_ , it broke again
16:11:15 <ddarius> sorear: What is with you and ftw?
16:11:34 <araujo> hello
16:11:38 <ddarius> heya shapr
16:11:44 <shapr> Hiya ddarius, what's up?
16:11:50 <JohnMeacham_> okay. I think that build is just broken. I'll put a new tag out later tonight hopefully.
16:12:21 <sorear> JohnMeacham_: is there a rule for picking good tags? or are they all equally likely to fail?
16:12:28 <JohnMeacham_> http://repetae.net/ghc_core.vim
16:12:34 <Heffalump> what is -fbang-patterns?
16:12:36 <dons> oh?
16:12:40 <dons> f !x = ...
16:12:43 <shapr> @where binary
16:12:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
16:12:57 <ddarius> shapr: I have a time consuming activity to handle first, but if I have time after that I may continue to work on an article I'm writing on the Riemann Hypothesis.
16:13:02 <dons> Heffalump: nice `seq` syntax
16:13:13 <Heffalump> ah
16:13:19 <shapr> ddarius: That sounds like fun.
16:13:20 <JohnMeacham_> sorear: it depends, it just happens to be in a particularly iffy state at the moment. I wouldn't bother trying to go back in time yet.
16:13:28 <sorear> Test: digits-of-e1 (the digits of e using continued fractions.)
16:13:28 <sorear> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/digits-of-e1
16:13:28 <sorear> jhc-ghc              1.410    seconds            (1.0 x)
16:13:28 <sorear> ghc                  3.950    seconds            (2.8 x)
16:13:30 <Heffalump> so that means f x = x `seq` f' x where f' x = ...
16:13:30 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/digits-of-e1, http://tinyurl.com/2dztwa
16:13:30 <Heffalump> ?
16:13:36 <sorear> ^^^ look at that!!!
16:14:18 <sorear> dons, JohnMeacham_: jhc works
16:14:48 <sorear> JohnMeacham_, dons: and thrice as fast as ghc to boot.
16:15:07 <dons> nice
16:15:10 <dons> that's what we want
16:15:24 <dons> sorear: do you have instructions on which jhc to grab and build for this?
16:15:27 <JohnMeacham_> ooh. neat. I have gotten some good results using jhc as a preprocessor for ghc. it is not consistantly better though. and the ghc back end is fairly buggy, I'd like some help from ghc people.
16:15:37 <sorear> so, shall I send in my patch now or wait for it to finish building.
16:15:49 <dons> JohnMeacham_: we just have to put up some numbers, and light a fire under them ;)
16:16:17 <dons> sorear:you can send it now, or later. but i'll need the instructions on which jhc to get
16:16:33 <sorear> dons: ejthecnar, don't use ghc-head (jhc uses finitemap), do use -fasm, edit prefix, make, make haskell98-0.1.hl, make install
16:16:43 <sorear> er, s/haskell98/base
16:16:47 <JohnMeacham_> okay. though, can you hold off publishing them until I get a fully working tag up people can just download and use, so I don't get a bunch of "it doesn't work!" emails :)
16:16:49 <sorear> haskell98 doesn't compile :(
16:17:10 <sorear> JohnMeacham_: did System.IO.Error ever exist?
16:17:17 <dons> JohnMeacham_: right. i need to build jhc on the benchmark box first
16:17:24 <JohnMeacham_> oh. I think it might not.
16:17:24 <sorear> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/digits-of-e2
16:17:24 <sorear> jhc-ghc              4.940    seconds            (1.0 x)
16:17:24 <sorear> ghc                  5.920    seconds            (1.2 x)
16:17:25 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/digits-of-e2, http://tinyurl.com/34mbo8
16:17:29 <sorear> less dramatic :(
16:17:52 <sorear> JohnMeacham_: because of that, haskell98 doesn't build
16:18:08 <sorear> JohnMeacham_: because of THAT, nobench *needs* --noauto -p base
16:18:08 <dons> my hope is that interesting numbers from hbc and jhc should focus the ghc devs minds on the backend :-)
16:18:46 <sorear> jhc -fvia-ghc --noauto -p base -o integrate integrate.hs +RTS -sstderr -H340M -c -F1.1
16:18:46 <sorear> integrate.hs:1   - Warning: The pragma 'OPTIONS_GHC' is unknown
16:18:48 <sorear> hahah.
16:19:11 <dons> oh, jhc is supposed to ignore that
16:19:29 <sorear> JohnMeacham_: it looks like jhc doesn't implement defaulting at the top level?
16:21:22 <JohnMeacham_> sorear: no. I don't like defaulting. or I'm too lazy to implement it. one of those.
16:22:02 <sorear> integrate is dying because of it :)
16:22:18 <JohnMeacham_> heading out. am seven hours late for work.
16:22:49 <sorear> bye
16:22:49 <shapr> That's a bit late.
16:23:25 <dons> hey. when you're a haskell compiler author, you can turn up to work any time you want
16:24:01 <kc5tja> 7 hours is a bit much though.  :(
16:24:14 <kc5tja> If I were ever 7 hours late for work, they'd tell me to not bother coming in.
16:24:24 <kc5tja> *EVER* *AGAIN*.
16:24:32 <kc5tja> And not even a goodbye on the phone.  :)
16:24:36 <dons> you shoudl write a haskell compiler
16:24:44 <kc5tja> Hahah :)
16:24:53 * sorear wants to..
16:25:11 <kc5tja> Dude, I can't even grok what is considered to be simple algebraic substitutions, and you want me to work on a Haskell compiler?
16:25:16 <sorear> jhc is being really slow on loop
16:25:23 <bd_> kc5tja: You'll grok it by the end! ;)
16:25:37 <sorear> make[3]: *** [compile-jhc-ghc] Error 99
16:25:37 <sorear> make[3]: Leaving directory `/usr/local/src/nobench/imaginary/loop' -- sigh
16:25:41 <kc5tja> Or run away screaming first.
16:25:43 <sorear> you know what 99 means
16:25:55 <dons> i do
16:26:09 <kc5tja> sorear: Go to the store, buy some more, 99 bot...never mind.
16:26:10 <sorear> kc5tja: johnmeacham wrote jhc to learn haskell ...
16:26:16 <dons> that's good though. look how quickly this is identifyingthings to improve!
16:26:29 <dons> yhc has fixed System.*; nhc no comes bundled with fps
16:26:48 <sorear> partial-sums.hs:1   - Warning: The pragma 'OPTIONS_GHC' is unknown
16:26:48 <sorear> Error: Module not found: Monad
16:26:54 <kc5tja> Let's put it this way -- I'm not writing a compiler without at least 10 other people to help me with it.  :)
16:27:05 <kc5tja> Because it'll take about that much man power to get something to even produce hello world.
16:27:07 <dons> 10 would be  a bit team
16:27:19 <dons> you should be able to reproduce ghc from scratch in 5 years with 10 people
16:27:25 <Pseudonym> Hey, first time I've ever seen a comment on GMBM from "S. P. Jones"
16:27:36 <sorear> jhc is consenting to look at pidigits!
16:27:44 <mwc> Hmm, isn't ocaml written by 4 guys
16:28:25 * kc5tja has wondered how Haskell would compile to the 65816 architecture though, and whether or not it could be made to run faster than C on that architecture.
16:28:38 <bd_> kc5tja: write a GHC backend? :)
16:28:39 <xerox> Pseudonym: what is GMBM?
16:28:44 <kc5tja> 65816 is a 16-bit version of the 6502, for those wondering; a pure accumulator architecture with some wickedly bizarre instruction forms sometimes.
16:29:03 <kc5tja> bd_: The thought has occured to me -- I was asking about this very possibility a few days ago.
16:29:10 <andygill> helllo
16:29:15 <kc5tja> But, I am not confident that I could do it alone.
16:29:23 <Pseudonym> xerox: http://scienceblogs.com/goodmath/2007/02/using_monads_for_control_maybe_1.php
16:29:25 <lambdabot> Title: Good Math, Bad Math : Using Monads for Control: Maybe it's worth a look?, http://tinyurl.com/2znsxy
16:29:26 <Pseudonym> Second comment.
16:29:58 <Pseudonym> Bye Andy.
16:30:11 <xerox> Pseudonym: I've seen that today, but didn't notice the comments, ha.
16:30:28 <Igloo> sorear: What do you use defaulting for OOI?
16:30:42 <sorear> @vera OOI
16:30:43 <lambdabot> No match for "OOI".
16:30:58 <Igloo> Out Of Interest
16:31:06 <sorear> Test: pidigits (lazy, arbitrary precision integers)
16:31:06 <sorear> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/pidigits
16:31:07 <sorear> jhc-ghc              0.010    seconds            (1.0 x)
16:31:07 <sorear> ghc                  10.200    seconds            (1020.0 x)
16:31:07 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/pidigits
16:31:17 <dons> sorear: huh. correct output??
16:31:19 <sorear> dons: nm that jhc's output is massively wrong :)
16:31:25 <dons> ah ok
16:31:36 <dons> it should be about the same time as ghc there, since its libgmp that's the bottleneck
16:31:43 <xerox> Goodnight.
16:31:50 <dons> so we need diffs  and 'Incorrect output' errors
16:31:53 <sorear> Igloo: I don't.
16:31:59 <sorear> Igloo: nobench does.
16:32:16 <Igloo> sorear: nobench itself, or some of the benchmarks?
16:32:19 <sorear> Igloo: jhc doesn't support defaulting in all cases.
16:32:36 <sorear> Igloo: therefore jhc can't run some of the benchmarks
16:32:53 <sorear> Test: primes (prime sieve)
16:32:54 <sorear> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/primes
16:32:54 <sorear> ghc                  3.530    seconds            (1.0 x)
16:32:54 <sorear> jhc-ghc              3.960    seconds            (1.1 x)
16:32:54 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/primes
16:32:57 <sorear> ^^^ interesting
16:34:01 <dons> sorear: so do we have a darcs tag for which jhc i should get?
16:34:33 <sorear> I'm using ejthecnar
16:35:21 <sorear> Test: queens (n queens)
16:35:21 <sorear> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/queens
16:35:21 <sorear> ghc                  1.770    seconds            (1.0 x)
16:35:21 <sorear> jhc-ghc              2.590    seconds            (1.5 x)
16:35:21 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/queens
16:35:27 <sorear> waaahhaahahaa!
16:35:41 <sorear> my plans!!!
16:37:16 <sorear> Test: nop (do absolutely nothing)
16:37:16 <sorear> http://www.cse.unsw.edu.au/~dons/code/nobench/imaginary/nop
16:37:16 <sorear> ghc                  0.010    seconds            (1.0 x)
16:37:16 <sorear> jhc-ghc              0.010    seconds            (1.0 x)
16:37:17 <lambdabot> Title: Index of /~dons/code/nobench/imaginary/nop
16:38:03 <dons> sorear: better output these to #haskell-oveflow
16:38:09 <dons> ?where jhc
16:38:10 <lambdabot> http://repetae.net/john/computer/jhc/
16:38:16 <sorear> dons: your makefile is mildly broken
16:38:16 <sorear> /bin/sh: line 0: cd: wheel_sieve1: No such file or directory
16:38:16 <sorear> /bin/sh: line 0: cd: wheel_sieve2: No such file or directory
16:38:24 * sorear joins #haskell-oveflow
16:38:28 <dons> spotted. thanks
16:38:43 <sorear> *** Users on #haskell-oveflow: @sorear
16:39:01 <dons> overflow
16:39:17 <sorear> spotted that
16:39:27 <sorear> dabbrev will blindly copy typos :)
16:39:38 <chessguy> dcoutts, dcoutts_ ping
16:39:41 <dons> so I darcs get http://repetae.net/john/repos/jhc --tag ejthecnar
16:39:44 <lambdabot> Title: Index of /john/repos/jhc
16:39:57 <sorear> yeah
16:40:34 <sorear> edit the Makefile
16:41:05 <dons> hmm?
16:41:27 <sorear> it has a config options section :)
16:41:44 <dons> jhc's Makefile?
16:41:49 <sorear> yeah
16:41:56 <dons> and edit it to say what?
16:42:04 <dons> eno-enough-info
16:42:24 <MarcWebe2> Do you know where I can find more information about MutVars ?
16:42:37 <dons> gee, i wonder if we could get knuth to switch to dwm, http://www-cs-faculty.stanford.edu/~knuth/screen.jpeg
16:42:41 <dons> MarcWebe2: MVars ?
16:42:47 <dons> ?docs Control.Concurrent.MVar
16:42:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
16:42:59 <sorear> dons: I needed to clarify 6.6 in the makefile
16:43:23 <sorear> MarcWebe2: MutVar# is not to be touched without proper cause.
16:43:42 <dons> ah ok
16:43:52 <MarcWebe2> dons Its from STRef.lhs. Example:  data STRef s a = STRef (MutVar# s a)
16:43:57 <MarcWebe2> I've never seen it before.
16:44:30 <sorear> MarcWebe2: one element mutable array.
16:44:36 <sorear> MarcWebe2: unboxed fooref
16:44:44 <sorear> @k GHC.Prim.MutVar#
16:44:45 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . v
16:44:50 <sorear> @kind GHC.Prim.MutVar#
16:44:53 <lambdabot> * -> * -> !
16:45:09 <sorear> ooh, haven't seen ! before
16:45:44 <dons> huh
16:45:47 <dons> neither
16:45:49 <sorear> jhc is using a lot of ram to compiler boyer...
16:45:58 <sorear> ?
16:46:13 <sjanssen> @kind GHC.Prim.MutVar Int Int
16:46:16 <lambdabot>     Not in scope: type constructor or class `GHC.Prim.MutVar'
16:46:23 <sjanssen> @kind GHC.Prim.MutVar# Int Int
16:46:26 <lambdabot> !
16:46:35 <dons> a unique type ;)
16:46:41 <dons> (something that can be mutably updated?)
16:46:46 <wolverian> is that the new 6.6 mutable stuff?
16:46:54 <dons> hmm?
16:46:59 <sorear> @kind GHC.Prim.Int#
16:47:01 <lambdabot> #
16:47:05 <dons> i seem to vaguely recall when this went in
16:47:11 <wolverian> I remember something about optimisations in 6.6 about that
16:47:37 <MarcWebe2> And what does this mean? mutable array? Kind of Dynamic ?
16:48:07 <dibblego> it's a section of YAHT that's not written yet  last I looked
16:48:22 <ddarius> wtf? "Problems in standard functional languages: they aren't object-oriented."
16:48:30 <sorear> idiot
16:48:37 <dibblego> ddarius, lol, link?
16:48:38 <dons> heh
16:48:56 <dons> yeah, cause more stateful objects is what we need
16:49:14 <dibblego> well, is 'state' an inherent property of OO?
16:49:20 <sorear> dons: should I submit my new jhc patch now?  it's not dons benchmarking :)
16:49:21 <dibblego> if not, then "type-classes"
16:49:25 <ddarius> http://scienceblogs.com/goodmath/2006/11/why_haskell.php#comment-273657
16:49:26 <lambdabot> Title: Good Math, Bad Math : Why Haskell?, http://tinyurl.com/y8dzbl
16:49:41 <dibblego> if so, then 'lol'
16:49:45 <ddarius> digglego: Some OO people require it others don't.
16:50:00 <dons> sorear: ok. please do.
16:50:13 <dibblego> ddarius, I'm just wondering if there is a general consensus
16:51:22 <sorear> dons: sent.
16:52:00 <ddarius> dibblego: No, no there's not.
16:52:13 <ddarius> FP also has that problem, but to a much much lesser extent.
16:52:32 <dibblego> as in, the looseness of the term, 'function' you mean?
16:53:26 <sorear> dons: sent another fix...
16:53:28 <ddarius> dibblego: Depending on what you mean, yes (or no).  Entertainingly, mostly on whether -purity- is an inherent property of FP.
16:53:39 <dibblego> ddarius, yeah that's what I mean
16:53:46 <sjanssen> "Second, I haven't seen good functional language, I don't know haskell, but I've learned Lisp and CL." -- why trust the opinion of somebody that has such limited experience with FP?
16:54:02 <sorear> uh, CL < Lisp
16:54:11 <sorear> with a round <>
16:54:41 <dons> sjanssen: the statement about functional languages being untyped is the funny one.
16:54:46 <sjanssen> "They are not typed, there is very few programming security(private, public, ...)."
16:54:47 <ddarius> CL \subset Lisp
16:54:48 <sorear> *gag*
16:54:51 <sjanssen> dons: yes :)
16:54:56 <MarcWebe2> Is STRef something similar to IORef but bound to a thread?
16:55:00 <sorear> modules ROCK
16:55:02 <sorear> MarcWebe2: yes
16:55:05 <dons> anyway, who cares about the opinion of people on a topic they acknowledge they aren't qualified to have an opinion on
16:55:12 <sorear> killfile!
16:55:22 <dibblego> dons, they do!
16:55:24 <ddarius> sorear: Dart tootin' Those vector spaces are just too constrained.
16:55:24 <sjanssen> MarcWebe2: IORef's are actually STRef RealWorld
16:55:37 <dons> dibblego: hehe
16:56:03 <sjanssen> MarcWebe2: so they're references in a certain "mutability context"
16:56:24 <MarcWebe2> sorear Ok Thanks. Thats enough for now ;)
16:57:20 <sorear> MarcWebe2: anything with a # in it is deep GHC hackery, to be avoided if practical.  (except for the GHC bit, even #ifdef)
16:58:24 <glguy> ?where zlip
16:58:24 <lambdabot> I know nothing about zlip.
16:58:25 <glguy> ?where zlib
16:58:25 <lambdabot> darcs get http://haskell.org/~duncan/zlib
16:58:43 <dons> get it from hackage
16:58:45 <dons> ?where hackage
16:58:46 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
16:58:52 <dons> people should always look at hackage first now
16:59:04 <sjanssen> dons: time for @hackage?
16:59:11 <dons> yeah
16:59:13 <MarcWebe2> sorear Yeah. I've learned that now. I don't want to hack on it. I just want to know where to put it into mind.
17:00:16 <sorear> MarcWebe2: agreed.  I for one find GHC's source its best documentation.
17:00:17 <JohnnyL> ?where darcs
17:00:18 <lambdabot> http://darcs.net/
17:00:35 <sorear> #darcs !
17:00:49 <dmead> ?src fold
17:00:50 <lambdabot> Source not found. Are you on drugs?
17:00:50 <sorear> @users #darcs
17:00:51 <lambdabot> Maximum users seen in #darcs: 56, currently: 46 (82.1%), active: 7 (15.2%)
17:00:55 <sorear> ?src foldr
17:00:56 <dmead> ?src foldr
17:00:56 <lambdabot> foldr k z xs = go xs
17:00:56 <lambdabot>     where go []     = z
17:00:56 <lambdabot>           go (y:ys) = y `k` go ys
17:00:57 <lambdabot> foldr k z xs = go xs
17:00:57 <lambdabot>     where go []     = z
17:00:58 <lambdabot>           go (y:ys) = y `k` go ys
17:00:59 <dmead> =p
17:01:03 * araujo back
17:01:13 <ddarius> You know what's ironic.  The "functional" language that person does have experience with also readily supports OO.
17:01:23 <Pseudonym> Methinks lambdabot doth protest too much.
17:01:27 <Pseudonym> Perhaps you are the one on drugs, and are just projecting.
17:01:47 <SamB> Pseudonym: doesn't that mean vomitting?
17:01:56 * sorear mutters something about submitting patches
17:01:57 <Excedrin> those lambdabot error messages are from sudo, right?
17:02:02 <JohnnyL> there are 0 functional topic books in Borders books & music.
17:02:14 <allbery_b> excedrin: openbsd sudo, yes
17:02:18 <bd_> @hoogle subRe
17:02:19 <lambdabot> Text.Regex.subRegex :: Regex -> String -> String -> String
17:02:30 <glguy> :-/ what's the correct emacs way to goto a certain line number? M-x goto-line?
17:02:36 <Excedrin> allbery_b: I thought it was a compile time option
17:02:38 <sorear> M-g M-g
17:02:41 <Pseudonym> JohnnyL: Borders isn't exactly comprehensive.
17:02:50 <Pseudonym> No matter how good the coffee is.
17:02:51 <sorear> glguy: M-g, or in emacs 22 M-g M-g
17:03:08 <Excedrin> --with-insults
17:03:12 <dmead> is 22 any prettier looking?
17:03:24 <JohnnyL> Pseudonym, there where 2 sets of chess players there. I may join up.
17:03:29 <sorear> dmead: they all look the same
17:03:47 <dmead> someone should pretty up emacs at some point
17:03:57 <Excedrin> oh, it's actually possible to set it in /etc/sudoers
17:04:04 <dmead> i want opengl driven cairo buttons and widgets!
17:04:05 <Pseudonym> Add flowers.  Flowers are pretty.
17:04:09 <sorear> dmead: actually, we're making yi look MORE like emacs
17:04:26 <kc5tja> sorear: Ewww!  :)
17:04:26 <sorear> dmead: oh.  X /= good, never was, never will.
17:04:31 <kc5tja> (couldn't resist)
17:04:38 <allbery_b> maybe it is but mosy systems don't choose the option by default
17:04:56 <sorear> --1-:**-F1  #haskell@anthony.OPN    Bot (883,5)    (ERC)----17:02--------------------------------------------------------------- I like the only emacs UI widget
17:04:57 <Pseudonym> sorear: X is neutral.  By definition.
17:04:59 <kc5tja> sorear: I like X's philosophy -- but it's implementation is definitely showing its age.
17:05:01 <Pseudonym> It can't be good or bad.
17:05:05 <dmead> whats yi?
17:05:10 <allbery_b> @where yi
17:05:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:05:12 <sorear> @hwere yi
17:05:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:05:20 <dmead> ;p
17:05:34 <dmead> and they say the semantic web is just a dream...
17:05:36 <dons> sjanssen++ patches
17:05:44 <sorear> ooh, what for?
17:05:50 <sjanssen> sorear: @hackage
17:05:57 <sorear> sjanssen++
17:05:59 <sjanssen> returns the URL of a package
17:06:07 <sorear> @dynamic-reload dummy
17:06:08 <lambdabot> Unknown command, try @list
17:06:10 <sorear> aww.
17:06:10 * kc5tja would like to play with a THE-like editor.
17:06:28 <sorear> @admin - mdalkmlal
17:06:47 <dons> hmm?
17:07:00 * Philippa returns from FitA
17:07:09 <sorear> just checking whether you can use it to check status .. perhaps a good /msg candidate
17:07:23 <dons> Philippa: how was it?
17:07:31 <dmead> http://davidguy.brinkster.net/goaste/stuff/calvin/calvinretouchdistressed.jpg
17:07:32 <lambdabot> http://tinyurl.com/2cht84
17:07:34 <Pseudonym> What do you do in FitA?
17:07:36 <Philippa> 'twas indeed fun, though it's not exactly afternoon any more
17:07:40 <dmead> that made me :<
17:07:51 <Pseudonym> Take data points and come up with least-squares curves?
17:07:58 <Philippa> sit, munch quietly on chocolate and listen to talks
17:08:08 <sorear> ... give talks?
17:08:17 <Philippa> they wouldn't let me
17:08:24 <Philippa> don't blame 'em given the ones they picked though
17:08:26 <Pseudonym> They saw you coming.
17:08:35 <Excedrin> kc5tja: what's THE
17:08:42 <Philippa> heh. Well, gmh knows me, Conor didn't
17:08:47 <allbery_b> hessling editor
17:09:09 <Philippa> I'm also resisting the temptation to post "Zeroth! Everyone have fun?" to the mailing list
17:09:25 <allbery_b> cloneof IBM's XEDIT, which you could think of as Emacs as soeen by an IBM mainframe/3278 terminal user
17:09:29 <Pseudonym> Or you could just say: Succ Zeroth!
17:10:23 <Philippa> that's for my successor, obviously
17:10:39 <ddarius> dmead: Yeah.
17:10:39 <Philippa> the point being that they'd be succier than me because I beat them to it, obviously
17:10:56 <dmead> ;/
17:24:10 <dons> $ ./jhc -V
17:24:11 <dons> jhc 0.1 20070222 (ejthecnar+0)
17:24:17 <sorear> yay!
17:24:52 <dons> now to compile the libraries
17:25:03 <sorear> don't bother with precompiled libs; $ make base-1.0.hl and wait half an hour
17:25:15 <dons> ok
17:25:16 <sorear> (on the HEAD-in-90m machine)
17:25:34 <dons> kind of verbose output??
17:25:40 <TomMD> sorear:  I am curious, does your day job require (or perhaps 'allow') you to hang out on #haskell? :)
17:25:50 <dons> TomMD: it does ;)
17:25:56 <dons> sorear: this is your job, right?
17:26:24 <sorear> Don't have one :)
17:26:36 <dons> "hacker of lambdas"
17:26:52 <sorear> <-- is 16, and needs *something* to fill the time between homework and sleep
17:27:50 <dons> so i'll need to make haskell98 too?
17:28:00 <TomMD> Depending on the path you take, that might mean you have to suffer though C/++ courses in a few years.
17:28:04 <dons> and then a make install should dump these weird .ho files somewhere?
17:28:06 <dibblego> ?docs IO
17:28:06 <lambdabot> IO not available
17:28:08 <sorear> dons: you can try
17:28:22 <sorear> dons: no, .hl : .ho  :: .a : .o
17:28:32 <sorear> except .hl has the interfaces too
17:28:33 <dons> ah ok
17:28:58 <ddarius> sorear: You do homework?  You sleep?
17:29:04 <dons> we should start gathering better 'real' programs
17:29:04 <sorear> ddarius: yes.
17:29:10 <dons> I added Djinn
17:29:18 <sorear> jhc!
17:29:20 <dons> but we should be able to find more modern replacements for some of the other categories
17:29:31 <dons> since they all run in 0.02s now
17:29:39 <sorear> jhc'd be a good real/ benchmark :)
17:29:39 <ddarius> sorear: When I was in high school, occasionally I would experiment with those.
17:29:41 <glguy> ugh, I pulled my car in to find that my fiancee had dropped her cell phone and drove over it on here way out today
17:29:44 <sorear> too good, maybe.
17:29:57 <dons> i know dcoutts has a nice lexer for munging C src
17:30:02 <dons> that stresses ghc a bit
17:30:15 <hpaste>  Marc Weber pasted "ghc 6.6 compiler bug? -fallow-incoherent-instances given but still not compiling" at http://hpaste.org/580
17:30:23 <dons> 16164 dons      25   0  687m 682m 5920 R 99.9 33.7   4:55.78 jhc
17:30:25 <dons> go jhc!
17:31:01 <glguy> how come any time someone talks about jhc (dons, sorear) it involves large amounts of ram?
17:31:26 <sorear> on MY system, jhc wants far more ram than I have.
17:31:31 <sorear> whoa, 2G !
17:31:31 <dons> jhc is the mlton of haskell compilers
17:31:50 <dons> it sucks in all the libs and runtime and inlines everything I thin :-)
17:32:04 <glguy> and the end result is good ?
17:32:08 <sorear> except it's written in Haskell, and has not been hprofiled, laziness ftw
17:32:17 <dons> well, it seems to produce some fast code on microbenchmarks
17:32:23 <mbishop> Hmm, someone should start a Haskell Cookbook
17:32:26 <dons> we'll see in a few hours after the bench runs through
17:32:38 <sorear> its a solid five times faster on spectral/ansi
17:32:56 <Excedrin> mbishop: there is one: http://pleac.sourceforge.net/pleac_haskell/index.html
17:33:04 <mbishop> eww, pleac
17:33:26 <mbishop> Excedrin: I suppose I should have said a GOOD one :P
17:33:38 <allbery_b> apparentrly it's being reworked to make it actually Haskell, instead of Haskell pretending to be Perl
17:33:45 <sjanssen> Excedrin: please don't recommend pleac haskell to people
17:33:48 <allbery_b> so now is the time to get involved with that effort
17:33:54 <dibblego> dons, I need a link to Haskell performance in general - what can I use?
17:34:04 <sorear> @iki Performance
17:34:05 <lambdabot> http://www.haskell.org/haskellwiki/Performance
17:34:09 <sorear> dibblego: &&&
17:34:12 <sorear> er, ^^^
17:34:20 <dons> dibblego: what kind of info specifically?
17:34:22 <dibblego> sorry, I meant performance benchmarks
17:34:23 <sorear> always get my operators confused :)
17:34:28 <dibblego> just something I can point to
17:34:29 <sorear> @where nobench-results
17:34:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/results.html
17:34:37 <dons> dibblego: so those are appearing above ^^
17:34:38 <sorear> dibblego: ^^^
17:34:40 <dons> also, the shootout
17:34:42 <dons> ?shootout
17:34:43 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
17:34:47 <dibblego> nice thanks
17:34:48 <Excedrin> sjanssen: why not? if it's poor quality, wouldn't it be good for people to improve it?
17:34:55 <dons> they're the main public srcs of current benchmark data
17:35:21 <sorear>    jhc-ghc /bin/sh: jhc: command not found
17:35:22 <dons> dibblego: is this for a blog article?
17:35:26 <sorear> wha?
17:35:30 <dons> i'd refer to the shootout, the nobench is a bit unstable
17:35:37 <dons> sorear: run started to test nhc and hugs patches
17:35:39 <dibblego> dons, yeah, I did cheers
17:35:39 <sjanssen> Excedrin: yes, it'd be nice if someone would improve it.  In the mean time, however, I think it has major potential to confuse newbies
17:35:42 <dons> but yhc is still building on my box
17:36:09 <glguy> is emacs 22 stable enough for everyday useage?
17:36:17 <sorear> I use it every day
17:36:24 <mbishop> glguy: yeah
17:36:27 <dons> dibblego: you know what's really cool: we have 3 compilers (4 if you count hacle+clean) that produce C like speed regularly from tuned haskell code
17:36:43 <dons> ghc, jhc and hbc all compile down to damn fast code.
17:36:53 <dibblego> dons, it's inevitable!
17:36:55 <dibblego> :)
17:37:01 <dons> so why can't the ruby guys get a single compiler out the door?
17:37:10 <sorear> eh? *poke poke*
17:37:15 <sorear> *taunt taunt*
17:37:17 <bd_> because their language is much more dynamic than haskell? :)
17:37:28 <dons> yes. too much in the runtime.
17:37:32 <bd_> When you can redefine + at run time, writing a useful compiler becomes a Hard Problem...
17:37:37 <zbrown> last i checked ruby was interpreted no?
17:37:45 <dons> the hipe erlang compiler guys were complaining to me similarly.
17:37:53 * allbery_b has done som remarkably evil thinsg with ruby --- seems like it'd be rather hard to compile
17:38:16 <dons> zbrown: so is haskell. (hug), and bytecode/vm (nhc/yhc), and compiled to native code (ghc,hbc,jhc,hacle+clean)
17:38:25 <glguy> Ruby programs put methods on the Nil object or Null object (I don't remember) to avoid failing due to calling methods of null
17:38:31 <glguy> disgusting
17:38:44 <kc5tja> Excedrin: THE = The Humane Environment, a new UI concept arrived through research by Jef Raskin.
17:38:46 <allbery_b> yeh
17:38:48 <glguy> Nil.isemptylist?
17:38:51 <glguy> True!
17:38:52 <dibblego> glguy, I don't quite get that
17:38:58 <sjanssen> how much fame could Haskell get if there were a "rugs" project?
17:39:03 <zbrown> dons: well true. though i tend to focus on the bytecode/vm or native code
17:39:05 <Excedrin> kc5tja: any url?
17:39:07 <kc5tja> Excedrin: You should read The Humane Interface (the book that predated the THE project).
17:39:08 <allbery_b> Nil is a singleton class so they can pull that off
17:39:11 <dibblego> glguy, Scala does that too - so I wrote my own list
17:39:12 <dons> sjanssen: pretty famous.
17:39:15 <kc5tja> Excedrin: I'm sure there is one.  Let me dig a bit.
17:39:20 <Excedrin> kc5tja: is it still based on keyboard and mouse?
17:39:27 <dons> sjanssen: i think its doable in shorter time than p6 too..
17:39:40 <allbery_b> that would be because ruby already has a spec :)
17:39:47 <dibblego> glguy, is isEmptyList an abstract method of the data type List?
17:39:58 <liquidengineer> hi
17:39:58 <allbery_b> lwall's *still* rewiring p6...
17:40:00 <kc5tja> Excedrin: http://rchi.raskincenter.org/index.php?title=Home
17:40:02 <lambdabot> Title: Home - Raskin Center
17:40:03 <dons> ?users
17:40:04 <dibblego> Nil overrides with true, Cons overrides with false
17:40:04 <lambdabot> Maximum users seen in #haskell: 317, currently: 296 (93.4%), active: 47 (15.9%)
17:40:05 <glguy> dibblego: I have no idea, I saw it on reddit
17:40:08 <liquidengineer> How do I derive show in a class?
17:40:19 <liquidengineer> I know how to do it for an instance or a data type
17:40:42 <liquidengineer> I'm using the show function in a class method, and GHC is telling me I need to derive show
17:40:46 <allbery_b> it's not really meaningful to do it for a class
17:41:00 <liquidengineer> how about just for the function?
17:41:10 <allbery_b> you instead want to make Show a context for the class:  class Show a => MyClass a where ...
17:41:28 <allbery_b> thus requiring that any instance for the class also implement Show
17:41:33 * sorear thinks about writing a binary terminfo parser using Data.Binary
17:41:36 <liquidengineer> Oooh
17:41:38 <liquidengineer> that's awesome
17:41:49 <liquidengineer> Can I group those?
17:42:02 <liquidengineer> i.e., have it require Eq, too?
17:42:05 <Excedrin> kc5tja: is Archy different from THE?
17:42:07 <allbery_b> sure
17:42:12 <glguy> yea! emacs 22 to have mouse wheel support :)
17:42:15 <allbery_b> class (Show a, Eq a) => ...
17:42:21 <dons> anyone else ever thought its cute how you can map a haskell data type to html as xhtml + css div tags?
17:42:21 <liquidengineer> oh *wow*
17:42:23 <liquidengineer> that is so awesome
17:42:25 <dons> the type becomes a div tag
17:42:31 <dons> the fields become values in html
17:42:38 <dons> and the css file becomes the show instance
17:42:55 <dons> sorry, the constructor becomes a div tag
17:43:18 <allbery_b> be aware that this is a good way to confuse ghc, though; if it starts complaining about undecidable or overlapping instances, you can tell it to continue with the appropriate -fallow-{overlapping,undecidable}-instances option but it can lead to infinite loops in the typechecker
17:44:04 <kc5tja> Excedrin: Archy is the modern name for THE.  It was renamed just before Jef Raskin's death.
17:44:09 <allbery_b> I *think* this isn't likely to be much of a problem for things like Eq or Ord, slightly more so for Show, very risky for other typeclasses
17:44:52 <sjanssen> allbery_b: contexts in class declarations are totally safe
17:44:57 <chessguy> ?hoogle modify
17:44:57 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
17:44:58 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
17:44:58 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
17:44:59 <allbery_b> oh, ok
17:45:26 <sorear> besides, undecidable instances are the only undecidable ones
17:45:27 <sjanssen> allbery_b: it's "instance SomeClass a => OtherClass a" that is overlapping (and dangerous)
17:45:43 <sorear> incoherent instances are perfectly decidable
17:45:53 <chessguy> ?hoogle evalState
17:45:54 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
17:45:54 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
17:46:03 <mbishop> I'm definately not qualified to start the haskell cookbook, but I at least made the page
17:46:05 <mbishop> http://haskell.org/haskellwiki/Cookbook
17:46:07 <lambdabot> Title: Cookbook - HaskellWiki
17:46:47 <sjanssen> mbishop: you should check out "99 problems" on the wiki
17:47:07 <mbishop> I've seen it
17:47:17 <mbishop> that too, however, is just a clone, of the 99 prolog problems
17:47:18 <sjanssen> it isn't as oriented to real world issues as PLEAC, for example, but there are plenty of nice code snippets
17:47:24 <mbishop> not bad though, but meh
17:47:47 <mbishop> I'd rather have a nice from scratch one, like the common lisp/scheme/erlang cookbooks
17:49:37 <dons> mbishop: can you maybe fill out the sectoins that need to be done?
17:49:40 <dons> divide and conquer
17:49:52 * allbery_b gets an Oleg-headache :/
17:49:57 <dons> if you can break it up into headings/ problems that need solutions (based on PLEAC or erlang cookbook) or something
17:50:03 <dons> then the rest of the community can fill it out
17:50:12 <dons> i'd chip in a few solutions
17:50:19 <liquidengineer> Anyone wanna see someone argue that the Haskell quicksort is in fact, *not* a quicksort?
17:50:26 <liquidengineer> I found a polemic. :P
17:50:28 <dons> so. something like "    Exercise 17: how do I .... ? "
17:50:42 <mbishop> dons: hmm, like make the headers? sure
17:50:43 <dons> liquidengineer: is it someone complaining about it not being inplace?
17:50:49 <liquidengineer> Yeah
17:50:54 <liquidengineer> http://php.mandelson.org/wordpress/?p=46
17:50:57 <lambdabot> Title: Jacob&#8217;s blog » Haskell vs. C readability stawman
17:51:05 <dons> liquidengineer: you just point out that inplace quicksort was invented quite a while after the original quicksort
17:51:13 <dons> anyway, yeah, is that an old article? I thin kso
17:51:20 <liquidengineer> yeah, I think
17:51:25 <dons> inplace-ness is just an optimisation
17:51:28 <glguy> oh my, emacs compiled with GTK2 support this time
17:51:52 <liquidengineer> someone suggests you can make an in place quicksort with monads
17:51:55 <liquidengineer> ...
17:52:03 <dons> of course you can
17:52:09 <liquidengineer> They do not explain *why* you'd want to
17:52:13 <TomMD> When looking though the GHC src I see parts like "fork# action state" - what does the '#' do?
17:52:27 <dons> its a reference to a ghc primop
17:52:46 <dons> that maps to some runtime function, or assembly
17:52:54 <dons> so probably forking a runtime thread?
17:53:01 <chessguy> ?hoogle if
17:53:01 <lambdabot> Prelude.if :: keyword
17:53:01 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
17:53:01 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
17:54:31 <bd_> @hoogle (MArray a e m) => a i e -> (i, i) -> (i, i) -> a i e
17:54:32 <lambdabot> No matches, try a more general search
17:54:34 <bd_> hmm
17:54:54 <bd_> any way to create a 'view' of a MArray? That is, to change the Ix range used to index it.
17:55:07 <sorear> liquidengineer: http://hpaste.org/98 also see 99
17:55:46 <liquidengineer> Is there a performance boost?
17:55:49 <liquidengineer> I'm use
17:56:00 <liquidengineer> I'm using the accumulator version from The One Wiki
17:56:24 <sorear> liquidengineer: almost certainly not.  ghc generates (or did, anyway) bad code for mutable anything
17:56:25 <mbishop> dons: how's this? http://haskell.org/haskellwiki/Cookbook
17:56:27 <lambdabot> Title: Cookbook - HaskellWiki
17:56:49 <MarcWebe2> TomMD: sorear told me its some ghc internal stuff..
17:57:32 <TomMD> Alright, so now it's time to hunt down how the preprocessing works :)
17:57:37 <sorear> TomMD: # is a mnemonic device for primitive types and values.
17:57:46 <sjanssen> liquidengineer: if you want a really nice sort in Haskell, you should look at:
17:57:51 <sjanssen> @fptools Data.List
17:57:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
17:57:56 <sorear> TomMD: forkIO is implemented using fork# on State#s
17:58:00 * ddarius wrote the C quicksort in Haskell, following the C closely.
17:58:08 <Philippa> it suggests you need to be on something to deal with them
17:58:16 <dons> mbishop: ok. good start. but if you want people to write it for you, you need to put in a) an example b) fine grained secton headings, http://haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
17:58:17 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
17:58:25 <chessguy> is it not valid to do "if x then y" without an alternative in haskell?
17:58:31 <sorear> correct.
17:58:39 <dons> ^^ if you fill out most of the section headings, and link to an example you'd like to duplicate, mbishop, then the community can just jump in and write the rest
17:58:46 <sorear> if False then 2 -- what does this eval to, chessguy?
17:58:47 <dons> but they need some initial guidance on what you're looking for
17:59:00 <chessguy> hmmm
17:59:02 <chessguy> it doesn't
17:59:10 <dons> mbishop: if you can fill out 1 or 2 examples of the cookbook style solutions you're looking for. then invite the community, via haskell-cafe@ to fill out the rest
17:59:10 <sjanssen> liquidengineer: it's a merge sort with some very nice properties.  For example, "head . sort" runs in O(n) time
17:59:10 <sorear> _|_? :p
17:59:19 <chessguy> that would be bad
17:59:23 <mbishop> dons: good idea :)
17:59:41 <dons> but for it to be self sustaining you have to set it upso that contributors don't face any barrier in working out whta they're supposed to do
18:00:11 <dons> i.e. they should only have to write the answer sectoins. and people love showing off how smart they are by solving puzzle answers
18:00:41 <liquidengineer> sjanssen: that's List.sort?
18:00:45 <liquidengineer> I thought it was an insertion sort
18:01:00 * dons lesson on open source resources: make everyting a puzzle and invite clever solutions
18:01:20 <dons> also, do it in public, and try to get people to compete
18:01:24 <sjanssen> liquidengineer: the Haskell report defines sort as an insertion sort for brevity, but the real implementation in Data.List is merge sort
18:01:58 <hpaste>  ddarius pasted "C QS in Haskell" at http://hpaste.org/581
18:02:14 <liquidengineer> I wonder if that outperforms the quicksort with accumulators implementation from Wikipedia...
18:02:18 <liquidengineer> thoughts?
18:02:42 <sjanssen> liquidengineer: do you have a link?
18:03:07 <liquidengineer> Yeah
18:03:10 <liquidengineer> http://en.literateprograms.org/Quicksort_(Haskell)
18:03:11 <lambdabot> Title: Quicksort (Haskell - LiteratePrograms
18:03:31 <liquidengineer> Oops.  I guess it's not Wikipedia at all
18:03:33 <liquidengineer> :P
18:04:11 <liquidengineer> Sorry.
18:04:30 <Cale> the end of that page is full of misinformation
18:04:53 <Cale> The standard doesn't specify that any particular algorithm be used to implement sort.
18:05:02 <dons> and we use mergesort now
18:05:07 <Cale> and GHC has used a merge sort for a while now
18:05:08 <Cale> yeah
18:05:34 <Xgc> Has there been any attempt at implementing heapsort?
18:05:38 <liquidengineer> Is merge sort better than quicksort?
18:05:47 <liquidengineer> in terms of performance
18:05:48 <Cale> For sorting lists, it seems to be.
18:05:51 <liquidengineer> ah
18:05:57 <liquidengineer> I thought qs was the holy grail
18:06:04 <Xgc> liquidengineer: Nope.
18:06:07 <Excedrin> I'd like to see Smoothsort in Haskell
18:06:10 <sjanssen> liquidengineer: naive quicksort also has the O(n^2) problem
18:06:24 <siti> liquidengineer: well even glibc uses mergesort on the qsort function if it can allocate enough memory
18:06:35 <Excedrin> all sort algorithms have tradeoffs
18:06:48 <Xgc> liquidengineer: Worst case of most well behaved sorts is where qs breaks down.
18:07:10 <liquidengineer> ah
18:07:14 <Xgc> That was not what I meant to say.
18:07:18 <liquidengineer> what's a Smoothsort?
18:07:21 <glguy_> for sorting Ints , radix sort works pretty well
18:08:02 <Xgc> liquidengineer: Worst case of heapsort, for instance is quicksorts average performance. Roughly: nlogn
18:08:29 * sorear likes incremental quicksort - access elements in any order, with O(n log n) total cost and O(n) maximum individual cost
18:08:50 <Excedrin> liquidengineer: it's a heapsort varient by Dijkstra that performs closer to O(n) when the input is already sorted
18:09:50 <hpaste>  chessguy pasted "Choosing a random subtree with equal probability" at http://hpaste.org/582
18:09:54 * chessguy sighs
18:09:58 <chessguy> i can't quite seem to get this
18:12:56 <Cale> an easy way would be to build a list of the subtrees (a traversal), and just pick one at random from that
18:13:13 <Cale> Might not be the *most* efficient way to do it, but it shouldn't be horrible.
18:13:37 <Cale> and it ought to be easy to get right
18:13:57 <chessguy> but it's doesn't give equal probabilities to all nodes, does it?
18:14:05 <Cale> Of course it would.
18:14:07 <hpaste>  glguy annotated "Choosing a random subtree with equal probability" with "pick a tree" at http://hpaste.org/582#a1
18:14:28 <Cale> glguy: yes, like that, exactly
18:15:01 <sorear> chessguy: what you have seems right?
18:15:10 <glguy_> or: flatten b@(Branch xs) = b : concatMap flatten xs
18:15:55 <chessguy> does that give a whole tree, or just a node?
18:16:00 <chessguy> sorear:
18:16:00 <chessguy> RandomTree.hs:23:33:
18:16:01 <chessguy>     `GlobalState' is not applied to enough type arguments
18:16:01 <chessguy>     Expected kind `*', but `GlobalState' has kind `* -> *'
18:16:02 <sorear> hmm, what you are writing is lot like tails
18:16:09 <sorear> ie it is a paramorphism
18:16:29 <glguy_> chessguy: what I wrote in channel after the 'or:' gives whole trees
18:16:32 <sorear> chessguy: that's a random number probelm, not a tree flattening problem
18:16:54 <chessguy> sorear, i never said i had a tree flattening problem
18:17:08 <sorear> chessguy: that's a higher kinded tysig problem, of which there are exactly 0 in the code you pasted.
18:18:05 <chessguy> well, apparently you're wrong
18:18:13 <orbitz> can i do osethign like foo (x,x) = True
18:18:23 <orbitz> or od i hav eot do foo (x, y) | x == y = True
18:18:31 <hpaste>  sjanssen annotated "Choosing a random subtree with equal probability" with "fix kinding problem" at http://hpaste.org/582#a2
18:18:45 <sjanssen> orbitz: you have to use ==
18:19:00 <dons> sorear: you weren't able to build haskell98 ?
18:19:04 <chessguy> ohhhh
18:19:12 <chessguy> @slap chessguy
18:19:12 * lambdabot slaps chessguy
18:19:13 <dons> sorear: i'm getting, $ jhc -fvia-ghc --noauto -p base   -o bernouilli bernouilli.hs
18:19:15 <sorear> dons: no I wasn't
18:19:16 <dons> any clues?
18:19:16 <chessguy> @slap chessguy
18:19:17 * lambdabot smacks chessguy about with a large trout
18:19:19 <dons> user error (LibraryMap: Library base not found!)
18:19:40 <sorear> dons: you need to install the base library
18:19:49 <chessguy> i forgot i had parameterized GlobalState
18:19:52 <sorear> (I thought that was automatic?)
18:19:58 <dons> $ ls /home/dons/lib/jhc-0.1
18:19:58 <dons> base-1.0.hl
18:20:25 <sorear> jhc -v -fvia-ghc --noauto -p base   -o bernouilli bernouilli.hs ?
18:20:53 <dons> it tried to install haskell98 too, and failed
18:21:00 <dons> maybe it missed a register step
18:21:11 <sorear> dons: I have ~/lib/jhc , not ~/lib/jhc-0.1.  perhaps try moving the directory?
18:21:20 <dons> ok
18:21:59 <dons> ah yes.
18:22:13 <dons> that did the trick
18:22:29 <dons> $ jhc -fvia-ghc --noauto -p base   -o bernouilli bernouilli.hs
18:22:29 <dons> Error: Module not found: Ratio
18:22:38 <dons> sorear: so what ones do you know to work?
18:22:55 <sorear> digits-of-e1, digits-of-e2, ansi
18:22:59 <dons> loop?
18:23:18 <sorear> primes, queens, nop
18:23:23 <sorear> no, not loop
18:23:27 <dons> ok.
18:23:42 <sorear> but it was a timeout not an errorcall, so it might work on your vastly faster machine
18:23:57 <dons> ah ok.
18:24:18 <dons> ok. looking better. digits-of-e1 going
18:24:26 <sorear> good!
18:24:42 <dons> ok. i'll run the full suite now with jhc
18:24:48 <dons> and we'll see in a few hours what we shall see
18:25:50 * sorear is excited
18:26:04 <sorear> it'll be even more interesting once john fixes haskell98
18:26:11 <dons> yep
18:26:13 <sorear> Ratio System etc
18:26:19 <dons> this is exactly how we get people to hack on projects
18:26:48 <sorear> and .. maybe jhc will get bytestrings
18:27:08 <sorear> then I could see how fast it is on vty-selfbench :)
18:27:38 <chessguy> ?hoogle getRandom
18:27:39 <lambdabot> No matches found
18:27:49 <chessguy> glguy, is your getRandom my getRand ?
18:28:05 <sorear> getStdRand
18:28:12 <sorear> +om
18:29:52 <chessguy> i don't see how this guarantees equal probabilities for all the nodes anyway
18:32:26 <orbitz> wha tis the poitn of Either? I can' trealy see why youd' wna tot use it?
18:32:51 <siti> for error handling
18:32:51 <dons> to signal error conditions
18:32:54 <araujo> Many things
18:32:59 <araujo> Exceptions for instance
18:33:03 <sorear> lots of theoretical importance - Either is (+) in the semiring of types
18:33:15 <sorear> (,) is (*)
18:33:22 <dons> > do x <- Right 7 ; y <- Right 8 ; if x + y < 2 then Right y else Left "doesn't work"
18:33:23 <sorear> () is 1, Void is 0
18:33:23 <lambdabot>  Left "doesn't work"
18:33:37 <dons> orbitz: error handling monads ^^
18:33:43 <orbitz> oh is ee
18:33:46 <bd_> sorear: Void?
18:33:53 <bd_> oh, data Void
18:33:54 <sorear> newtype Void = Void Void
18:33:56 <orbitz> why suing righ tleft an dnot havin Pass Fail for that?
18:33:57 <Cale> chessguy: Why not just take my idea? It's obvious that you'll get uniform probability for the nodes, because you have a list of all the nodes, each occurring exactly once, and you're picking an element of the list with uniform probability,
18:34:01 <orbitz> seems less arbitrary?
18:34:05 <dons> > do x <-return 7 ; y <- return 8 ; if x + y < 2 then return y else fail "doesn't work" :: Either String Int -- yeah?
18:34:05 <Cale> er, .
18:34:07 <lambdabot>  Left "doesn't work"
18:34:28 <chessguy> Cale, i thought glguy's idea was your idea
18:34:45 <Cale> er, I haven't been following closely
18:35:17 <chessguy> and if i flatten the tree into a list and then choose an element from the list, don't i just get a node, instead of the tree
18:35:20 <lispy> > fail "isn't right." :: Either String Int
18:35:22 <lambdabot>  Left "isn't right."
18:35:41 <Cale> getRandom, I think is from my MonadRandom library.
18:35:57 <Cale> chessguy: you don't really flatten the tree
18:36:03 <chessguy> ...
18:36:06 <sorear> orbitz: because Left and Right are just discriminators.  Either is symetric, it doesn't do errors or sucess.
18:36:10 <Cale> well, maybe his code did
18:36:21 <Cale> You really just want to produce a list of the subtrees.
18:36:25 <sorear> orbitz: would you like inl and inr better :)
18:36:31 <chessguy> yes
18:36:53 <chessguy> that would be fine
18:37:18 <orbitz> sorear: right but to say success or error in a monad doens' tit make more sense to have soemthign that's Pass and Fail?
18:37:28 <orbitz> maybe the left handed peopel think left hosuld be uscess!
18:37:40 <lispy> orbitz: we do think that
18:37:59 <lispy> i've been annoyed by that one more than one occasion :)
18:40:04 <sjanssen> subtrees t = t : concatMap subtrees (subForest t) -- this is what you want, chessguy
18:40:24 <glguy> 20:13  glguy_> or: flatten b@(Branch xs) = b : concatMap flatten xs
18:40:26 <orbitz> do you think Iran Man's suits software is wirten in Haskell?
18:40:31 <Cale> subtrees (n @ (Node x xs)) = n : (xs >>= subtrees)
18:40:46 <chessguy> glguy, i'm talking about a rose tree
18:40:53 <lispy> orbitz: is that some sort of bad pun or is there really an Iran man?
18:41:12 <orbitz> lispy: the super hero
18:41:19 <lispy> from iran?
18:41:27 <orbitz> oops
18:41:28 <orbitz> Iron Man
18:41:32 <lispy> oh!
18:41:36 <lispy> totally different meaning :)
18:41:43 <orbitz> sorry
18:41:55 <glguy> chessguy: so?
18:42:26 <lispy> orbitz: well there was that april fools about the software at the hospital to run the surgery machine being rewritten in haskell and saving lives
18:42:29 <chessguy> so the Branch constructor has no meaning
18:42:39 <SamB> hahaha
18:42:41 <SamB> yeah right
18:42:49 <glguy> chessguy: so use your imagination and apply it to the specific implementation you are using
18:42:54 <orbitz> hah
18:43:15 <orbitz> lispy: although it is sad whent eh oppsite hapepns
18:43:28 <orbitz> i.e. that radiation therapy machien that UI was competlely broken
18:44:04 <glguy> chessguy: flatten b@(Branch _ xs) = b : concatMap flatten xs
18:44:06 <chessguy> glguy, how about not being rude about it
18:44:06 <sorear> orbitz: they also did a Haskell X-ray machine,which saved many lives, infact it killed nobody
18:44:07 <SamB> hmm?
18:44:23 <chessguy> glguy, i'm doing the best i can with the haskell i know
18:44:29 <glguy> chessguy: I was pointingout that your comment didn't make sense was all
18:44:41 <chessguy> and i was pointing out that your code didn't make sense at all
18:44:41 <glguy> I'm not criticising your programming ability
18:44:53 <orbitz> sorear: right then and there or was there a 20 year follow up too?
18:45:00 <glguy> chessguy: a rose tree makes sense as all branches rather than all leaves
18:45:19 <sorear> orbitz: same day follow up.
18:45:54 <lispy> orbitz: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg01008.html
18:45:54 <lambdabot> Title: re. A Good Story
18:45:58 <lispy> orbitz: but check the date of the email :)
18:46:03 <sorear> orbitz: the punch line: "The Xray machine has not been used at all since we moved it to haskell - we're still compiling the standard libs"
18:46:10 <lispy> Date: Thu, 1 Apr 93 11:11:27 -0500
18:47:35 <orbitz> i noticed some nasa software is moving form Lisp to C++, any dieas why this is happening?
18:47:54 <Pseudonym> Surely that would depend on what the software is.
18:47:56 <sorear> all the lisp programmers are senile and/or dead?
18:47:57 <lispy> ex-MIT staffers moved on?
18:48:16 <Pseudonym> Perhaps they're relying more on third-party libraries that don't have good Lisp bindings.
18:48:34 <orbitz> it eem shome brewed stuff
18:48:37 <Pseudonym> Actually, I guess that would technically be second-party.
18:48:42 <lispy> erlang seems like a natural thing for them to use
18:48:44 <sjanssen> C++ provides more obfuscatory defense against nosy space aliens
18:48:47 <Pseudonym> Since NASA is, in this case, its own client.
18:48:50 <orbitz> the one in paticular i'm thinking of is for ... life suppot or omsething like that
18:49:04 <Pseudonym> sjanssen: Not true.  I've seen Independence Day.  The aliens' code is all in C.
18:49:21 <orbitz> Pseudonym: and can run mac binaries
18:49:22 <Pseudonym> And it's a dialect of C where you don't have to close all braces.
18:49:29 <lispy> Pseudonym: maybe the aliens have taken over our nasa!
18:49:30 <sorear> orbitz: Galois connections uses haskell for $RANDOM_TASK_WITH_EXTREME_RELIABLILITY_REQS
18:49:37 <sorear> orbitz: IIRC missile control systems
18:49:39 <sjanssen> Pseudonym: we're not worried about those aliens anymore :)
18:49:39 <Pseudonym> Oh, we knew that.
18:49:48 <Pseudonym> Only we don't call them aliens.  We call them politicians.
18:50:02 <orbitz> sorear: cool!
18:50:27 <Pseudonym> I suspect the real reason is they thought the system needed a rewrite, and the best way to ensure that you don't reuse any code is to use another language.
18:50:28 <sorear> defence contracters aren't quite as cool as hospitals, but...
18:50:28 <orbitz> i think i would like to work in a place where the goal was to hav eexteremly reliable osftware
18:50:39 <orbitz> my current job is to have extremely bad software that is written fast
18:50:55 <Pseudonym> I used to work for a defence contractor.
18:51:11 <Pseudonym> I never really understood programming as it should be since I worked there.
18:51:11 * Nafai works for a defense contractor
18:51:20 <lispy> orbitz: i've been writing fortran code all day, i couldn't imagine writing secure or bug free code in that language
18:51:30 <orbitz> hah
18:51:35 <orbitz> i wonder how fortress will pan out
18:51:36 <Pseudonym> My first assignment was adding a "copy file" operation to a custom scripting system.
18:51:38 <Pseudonym> It took me two weeks.
18:51:50 <chessguy> sjanssen, that's exactly what i needed, thanks
18:51:52 <chessguy> sjanssen++
18:52:00 <lispy> Pseudonym: wow
18:52:03 <lispy> Pseudonym: why is that?
18:52:05 <Pseudonym> And most of that was dealing with corner cases, like what if the file is actually a block device.
18:52:40 <Pseudonym> Most of the rest was, of course, understanding the code base.
18:53:12 <Pseudonym> "Dealing with corner cases" does, of course, include writing the test suite.
18:53:50 <allbery_b> at least you dealt with them
18:53:59 <orbitz> lispy: used K/J at all?
18:54:02 <lispy> one of my problems with fortran is interfacing with zlib.  I interface with "compress", it seems to work correctly and I can uncompress the data back to what it was.  But as soon as I do other standard things, like variable assignments my program starts having undefined behavior.
18:54:06 <Pseudonym> Extreme Programming Exhausted
18:54:07 <lispy> orbitz: no, what's that?
18:54:10 * allbery_b recalls various windows DoS issues involving tricking web services into opening devices
18:54:14 <orbitz> lispy: programming languages
18:54:20 <orbitz> dscendent sof APL
18:54:51 <glguy> J ftw
18:55:12 <lispy> something about calling the dll function breaks my program, but i can't figure out what...even the disassembled code looks like it should
18:55:13 <orbitz> KDB was writen withotu a single explicit loop!
18:55:41 <orbitz> anyways, i htink teh poitn-free style of J/K is preatty cool, i'm always giddy when I cn acomplish a similar feat in haskell
18:55:56 <glguy> I don't know any K, but J takes point-free to a new level
18:56:21 <orbitz> when i was first looking at haskell i always wondered what the poitn of (.) was, but it became so useful when i trei dot do anythign poitn free
18:56:21 <allbery_b> J's point-free broke my brain
18:56:31 <lispy> > map length . group . take 1000 . fix $ show
18:56:32 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,489]
18:56:39 <lispy> orbitz: like that? ^^ :)
18:56:58 <mauke> haha
18:57:00 <sorear> > drop 100000 $ fix (([0::Int ..607] ++) . liftM2 (zipWith (+)) (drop 203) (drop 606))
18:57:02 <lambdabot>  [952572057,-1388372156,50283391,-1273810191,1332589190,-1190325566,-19321366...
18:57:05 <allbery_b> but it did prepare me somewhat for deciphering SML and Haskell
18:57:10 <sorear> orbitz: how's that? ^^^
18:57:25 <sorear> lagged fibonacci PRNG
18:57:39 <mauke> don't fix show. it isn't broken!
18:57:48 <glguy> @yhjulwwiefzojcbxybbruweejw
18:57:48 <lambdabot> Exception: <<loop>>
18:57:49 <lispy> > fix show
18:57:51 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:58:01 <bd_> heh
18:58:03 <lispy> mauke: oh noes, the fixed version looks broken!
18:58:08 <sorear> haskell ... the language where standard high performance PRNGs ... are one liners
18:58:10 <orbitz> sorear: sexy
18:58:21 <Pseudonym> fix shows "1"
18:58:22 <bd_> > fix (show . cycle)
18:58:24 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:58:25 <Pseudonym> > fix $ shows "1"
18:58:27 <lambdabot>  "\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"\"1\"...
18:58:40 <Pseudonym> > fix $ shows "Hello world|"
18:58:41 <lambdabot>  "\"Hello world|\"\"Hello world|\"\"Hello world|\"\"Hello world|\"\"Hello wor...
18:58:48 <Pseudonym> > fix $ showString "Hello world|"
18:58:49 <lambdabot>  "Hello world|Hello world|Hello world|Hello world|Hello world|Hello world|Hel...
18:58:50 <lispy> :t shows
18:58:52 <lambdabot> forall a. (Show a) => a -> String -> String
18:59:09 <lispy> > shows 1 "hi"
18:59:11 <lambdabot>  "1hi"
18:59:29 <Pseudonym> > shows 1 . showChar ' ' . shows 2 $ ""
18:59:31 <lambdabot>  "1 2"
18:59:36 <orbitz> is a point-free osution generally preferd to ane xpicit lambda?
18:59:38 <Pseudonym> lispy: That's what it's for.
18:59:50 <Cale> orbitz: depends
18:59:51 <Pseudonym> orbitz: No.
18:59:59 <Pseudonym> There is no "generally" here at all.
19:00:04 <orbitz> ok
19:00:07 <fuzan> A little off-topic, but what' sht ename of the webpage with all the numeric sequences?
19:00:22 <lispy> orbitz: point free falls a part in terms of readability when you're threading more than one thing through your function calls
19:00:26 <dropdrive> encyclopedia of integer sequences?
19:00:29 <glguy> slone?
19:00:31 <Pseudonym> ?google on-line integer sequences
19:00:33 <lambdabot> http://www.research.att.com/~njas/sequences/
19:00:33 <dropdrive> fuzan, that was for you.
19:00:33 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
19:00:35 <Cale> Sloane
19:00:36 <Pseudonym> That's it,.
19:00:37 <fuzan> Trying to find the knuth's mininum number of comparisons for n digits sequence
19:00:41 <SamB> orbitz: when did you start to type so badly?
19:00:50 <fuzan> sigh. i tried "numeric sequeneces" to no avail :\
19:00:50 <Pseudonym> fuzan: log_2 (n!)
19:00:55 <SamB> @. orbitz yow
19:00:56 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "orbitz"
19:00:58 <SamB> aww
19:00:59 <Cale> The OEIS is great
19:00:59 <Pseudonym> Well, floor (log_2 n!)
19:00:59 <lispy> @pl \x y -> y + x - y * x
19:01:00 <lambdabot> ap (ap . ((-) .) . (+)) (*)
19:01:01 <orbitz> for instance i much prefer filter ((==0) . snd) [(a, b)] to (\(_, x) -> x == 0)
19:01:07 <SamB> @yow
19:01:08 <lambdabot> Hello.  Just walk along and try NOT to think about your INTESTINES
19:01:08 <lambdabot> being almost FORTY YARDS LONG!!
19:01:12 <orbitz> SamB: how di dyou never notice?
19:01:15 <fuzan> Pseudonym: that's a model, not proven s(n)
19:01:23 <SamB> orbitz: do you only do it sometimes?
19:01:29 <orbitz> SamB: i do it all teh tiem
19:01:30 <allbery_b> you type like I do :)_
19:01:30 <sorear> @nazi-on
19:01:31 <lambdabot> Spelling nazi engaged.
19:01:34 <sorear> @nazi-off
19:01:35 <lambdabot> Spelling nazi disengaged.
19:01:36 <orbitz> SamB: it's myt ardemark
19:01:44 <SamB> orbitz: how long has it been your trademark?
19:01:54 <orbitz> SamB: since i created teh internet
19:01:55 <Pseudonym> fuzan: Yes, it's a model, but there's a simple argument that it's reasonable.
19:01:57 <SamB> because I didn't notice until, oh, maybe the last month
19:02:07 <SamB> orbitz: I didn't know you were al gore
19:02:09 * sorear wonders whether SamB is delegating to doctor-mode
19:02:10 <mbishop> dons: I think I fleshed the page out pretty good...see anything I should fix/change, or should that be enough for people to get the general idea?
19:02:21 <orbitz> SamB: there is  a lot you dont' know about me
19:02:24 <Pseudonym> Given an arbitrary permutation, it takes log_2 (n!) yes/no decisions to decide which permutation it is.
19:02:25 <SamB> sorear: nonsense!
19:02:32 <Pseudonym> That's simple information theory.
19:02:32 <SamB> doctor mode does not know how to fix his spelling
19:02:37 <siti> orbitz: you created a series of tubes!
19:02:43 <orbitz> siti: and pipes
19:02:48 <Pseudonym> Now that doesn't prove that it's the minimal number of comparisons to reorder.
19:02:55 <lispy> Pseudonym: what other log bases are there?
19:03:10 <Pseudonym> lispy: Only that and e.
19:03:14 <mbishop> http://haskell.org/haskellwiki/Cookbook
19:03:16 <lambdabot> Title: Cookbook - HaskellWiki
19:03:18 <Pseudonym> And e is only required in some numeric code.
19:03:21 <mbishop> please start correcting/adding things
19:03:22 <mbishop> :)
19:03:40 <SamB> Pseudonym: you are kidding, I hope?
19:03:42 <lispy> that's not the crazy cookbook that redefines the prelude is it?
19:03:45 <Pseudonym> And even then, only because FPUs usually provide log_e natively.
19:03:53 <Pseudonym> SamB: You decide!
19:04:06 <SamB> you do know that you need ln for integration?
19:04:09 <lispy> Pseudonym: no joke!
19:04:14 <mbishop> lispy: no, it's one I just started to try and fix it
19:04:20 <glguy> ?index Float
19:04:21 <lambdabot> Prelude, GHC.Exts, Graphics.Rendering.OpenGL.GL.VertexArrays, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
19:04:23 <mbishop> well, to improve on the PLEAC one anyway
19:04:23 <lispy> mbishop: ah, okay
19:04:26 <lispy> mbishop: you may live
19:04:31 * mbishop bows
19:04:42 <lispy> the pleac one made my head hurt
19:04:57 <mbishop> Although I'm no haskell expert, so you might want to kill me when you read that...but at least this one is one the wiki, so you can fix it :P
19:05:05 <mbishop> on*
19:05:06 <Pseudonym> Anyway, it is possible that there's a sort algorithm which doesn't require detecting which permutation it is.
19:05:20 <orbitz> does NASA use haskell fo ranything or ar ethey mostly lisp/python feinds
19:05:23 <Pseudonym> A comparison-based onw, anyway.
19:05:40 <SamB> orbitz: maybe you used to just have spaces transposed with things
19:05:47 <SamB> now you seem to be transposing letters too
19:05:49 <mbishop> I thought NASA still used Ada
19:05:50 <SamB> a lot
19:05:50 <allbery_b> I gather they're mostly python
19:05:55 <orbitz> SamB: i swear, it's been my trademark for awhile
19:06:06 <SamB> transposed letters?
19:06:13 <Pseudonym> NASA is actually a very distributed system.
19:06:21 <glguy> HAL/S is the programming language used for the on-board software of the Space Shuttle.
19:06:21 <Pseudonym> Different crowds use different tools.
19:06:28 <orbitz> mbishop: i know a number of theri probes are in lisp, i heard a number of stories about fixing it in mid flight
19:06:39 <Pseudonym> Yeah, but HAL/S isn't maintained by NASA.
19:06:46 <Pseudonym> It's maintained by a contractor.
19:06:59 <SamB> orbitz: what do they do if they crash the little things?
19:07:05 <SamB> I mean, software-ly?
19:07:19 <SamB> not into a massive object
19:07:19 <Pseudonym> And, of course, their deep space probes are still binary patched in machine code.
19:07:22 <orbitz> SamB: they have extenisve testing before hand
19:07:26 <SamB> ah
19:07:28 <orbitz> SamB: but they hav elots and lots of redudanceis
19:07:30 <Pseudonym> It's kinda hard to do a software upgrade of Voyager.
19:07:32 <mbishop> Hmm, can I make a standalone binary of a haskell program that will run on windows...but build it in Linux?
19:07:37 <SamB> so no punching away at the REPL then ;-)
19:07:41 <orbitz> SamB: http://en.wikipedia.org/wiki/Spirit_rover#January_21_flash_memory_management_anomaly
19:07:43 <lambdabot> http://tinyurl.com/rselt
19:07:53 <orbitz> mbishop: cross compilation aye?
19:08:03 <SamB> come to think of it, the latency would be far too high anyway
19:08:04 <SamB> ;-)
19:08:13 <orbitz> SamB: only 3 minutes:)
19:08:33 <lispy> too long for tcp/ip, though right?
19:08:33 <orbitz> SamB: supspeodly tehy lost MGS due to a software bug:)
19:09:19 <allbery_b> clearly they need to use the haskell dimensioned numbers library :)
19:09:19 <mbishop> orbitz: I suppose...any idea if it's possible? (and fairly simple? if it's too complicated, I could always actually built it in windows...)
19:09:28 <sorear> mbishop: apt-get install mingw
19:09:41 <orbitz> mbishop: build it ot C and use cross compielr for htat?
19:09:42 <sorear> er mingw32
19:09:45 <mbishop> built/build
19:10:00 <sorear> mingw32 - Minimalist GNU win32 (cross) compiler
19:10:17 <orbitz> mbishop: cross compiling in genrealy always seems liek more effor than it's wroth but i don't know...
19:10:18 <SamB> there were too many files in the filesystem?
19:10:25 <Pseudonym> http://www.openchannelfoundation.org/cosmic/  <- Archaic software goodness.
19:10:28 <lambdabot> Title: Open Channel Foundation: NASA Cosmic Collection
19:10:35 <orbitz> SamB: yeah
19:10:37 <liquidengineer> Hello
19:10:40 <SamB> why didn't they test the filesystem for how much it could hold?
19:10:42 <mbishop> orbitz: it'd agree with that
19:10:45 <orbitz> SamB: but alt leh redudnecneis meant they could sitll contorl it from earth which was sweet
19:10:45 <mbishop> I'd
19:10:47 <liquidengineer> what's the easiest way to convert a ClockTime to an int?
19:10:50 <mbishop> man my typing is terrible today
19:10:53 <SamB> orbitz: yeah
19:10:59 <SamB> I suppose they are used to this sort of thing
19:11:02 <liquidengineer> like, seconds since the beginning of hte current epoch or something
19:11:04 <sorear> liquidengineer: \(TOD seconds picos) -> seconds
19:11:08 <SamB> they *have* been doing it for years
19:11:12 <orbitz> SamB: i'd lov eot work on somethign that requires that aoutn of fault tolerence
19:11:53 <SamB> they know a lot about how to make things so that you don't need both physical access and a lot of experience to fix problems by now ;-)
19:12:01 <SamB> err.
19:12:04 <orbitz> SamB: i'd hope so:)
19:12:08 <SamB> s/experience/equipment/
19:12:11 <SamB> man
19:12:19 <SamB> I hate it when I forget what I meant to say in the middle
19:12:39 <mbishop> liquidengineer: only way I found to do it turns it into an IO Integer....probably easier to use http://cvs.haskell.org/Hugs/pages/libraries/unix/System-Posix-Time.html#v%3AepochTime
19:12:41 <lambdabot> http://tinyurl.com/ywgul4
19:12:50 <liquidengineer> brb
19:12:52 <orbitz> SamB: http://www.astronomy.com/asy/default.aspx?c=a&id=5019
19:12:54 <lambdabot> Title: Astronomy - Software bug downed Mars probe - Daniel Pendick
19:13:59 <sorear> mbishop: how could it ever NOT be in IO?
19:15:14 <ddarius> Pseudonym: Is the version of your dimensioned numbers on SourceForge the most current.  Didn't it move to some darcs repo?
19:15:39 <liquidengineer> Is that a standard library with GHC?
19:15:55 <liquidengineer> sorear: how does that work?
19:16:04 <mbishop> sorear: don't know...when you want to do time differences or something?
19:16:06 <liquidengineer> is that a lambda function?  I've never used one in Haskell
19:16:27 <sorear> mbishop: I'm afraid you are misunderstanding what IO types mean.
19:16:27 <sorear> liquidengineer: yes
19:16:27 <sorear> liquidengineer: it's just syntax
19:16:33 <sorear> @botsnack
19:16:34 <lambdabot> :)
19:16:37 <mbishop> sorear: more than likely :P
19:16:55 <liquidengineer> ah
19:17:13 <SamB> orbitz: hmm.
19:17:13 <liquidengineer> so how does this lambda function work?
19:17:15 <orbitz> are all monads IO types?
19:17:19 <SamB> maybe they need to work on that "safe mode"
19:17:23 <SamB> try and make it safe
19:17:26 <liquidengineer> I'm not sure how to use it
19:17:28 <orbitz> SamB: hah
19:17:33 * glguy throws sorear on the IO fire
19:17:35 <sorear> mbishop: an 'IO ClockTime' is not a clocktime, it is a description of how to get a clocktime
19:17:38 <glguy> fix it!
19:17:47 <SamB> you know, so it doesn't point the heatsink at the SUN!
19:17:51 <liquidengineer> (also, I eventually need this number in a Int form
19:17:54 <sorear> glguy: mfix!
19:18:02 <liquidengineer> can I cast the result of the lamba function?
19:18:05 <bd_> > mfix point_antenna_at_sun
19:18:06 <lambdabot>   Not in scope: `point_antenna_at_sun'
19:18:09 <bd_> didn't work :(
19:18:19 <glguy> ?quote missle
19:18:19 <lambdabot> dons says: mm. It would be kinda fun to hook up the usb missle launcher to an unsafePerformIO.
19:18:43 <sorear> liquidengineer: an lambda function is just syntax for a regular one. eg you could define
19:19:01 <sorear> clockTimeToEpochSeconds (TOD x _) = x
19:19:08 <orbitz> SamB: well they got a probe from earth to mars safely, probably figured hat was enough work
19:19:17 <kfish> ooh, i saw a usb missile launcher in a store the other day, right next to cans of tinned soup (yes, this was a computer hardware store)
19:19:30 <liquidengineer> why the wildcard argument?
19:19:32 <orbitz> (which is increidbly impressiv ein my book...)
19:19:44 <glguy> what is it?
19:19:45 <SamB> kfish: why do they sell food?
19:20:16 <kfish> SamB, for japanese otaku who would probably starve otherwise, i suppose :-)
19:20:18 <allbery_b> liquidengineer:  you're not using the value, why bother to bind it?
19:20:21 <glguy> orbitz: I think that your cat might have just walked on your keyboard ;)
19:20:39 <sorear> liquidengineer: because you can't stuff a fractional part into an Integer, and you requested an Integer.
19:20:44 <orbitz> glguy: i'm a really godo typist!
19:20:55 <sorear> liquidengineer: if you can take doubles I can write
19:21:09 <allbery_b> lambdas are actually the low level mechanism in haskell; a definition like foo x = ... is really foo = \x -> ...
19:21:26 <sorear> clockTimeToEpochSeconds (TOD x y) = fromInteger x + ((1**(-12)) :: Double) * fromInteger y
19:21:33 <liquidengineer> wait
19:21:36 <liquidengineer> how does TOD store time?
19:21:57 <liquidengineer> what's the integer and what's the fraction?  I was expecting one massive integer
19:21:59 <sorear> TOD seconds_since_epoch_as_an_integer picoseconds_since_beginning_of_second
19:22:16 <glguy> Hmm, those are a lot of wildcards!
19:22:29 <liquidengineer> ah
19:22:32 <liquidengineer> yeah
19:22:33 <sorear> glguy: ?
19:22:34 <liquidengineer> seconds is enough
19:22:39 <glguy> sorear: i kid!
19:22:59 <liquidengineer> but I get this message now
19:23:00 <liquidengineer> No instance for (Show (ClockTime -> Integer))
19:23:36 <sorear> that means what it says, you can't show (convert to string) a function
19:23:53 <sorear> usually you want to convert the result of applying a fucntion to a value
19:24:22 <glguy> > getLine
19:24:23 <lambdabot>  <IO [Char]>
19:24:27 <liquidengineer> Oh!
19:24:38 <liquidengineer> so this gives me a function I need to call on another function
19:24:46 <liquidengineer> which gives me my value
19:25:42 <sorear> it gives you a function that turns ClockTimes into seconds since the epoch
19:25:46 <allbery_b> clockTimeToEpochSeconds expects to be invoked on a function that returns a ClockTime (see System.Time)
19:25:53 <allbery_b> @hoogle ClockTime
19:25:54 <lambdabot> System.Time.ClockTime :: data ClockTime
19:25:54 <lambdabot> Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
19:25:54 <lambdabot> Time.getClockTime :: IO ClockTime
19:27:01 <liquidengineer> clockTimeToEpochSeconds getClockTime
19:27:03 <allbery_b> :t let clockTimeToEpochSeconds (TOD x y) = fromInteger x + ((1**(-12)) :: Double) * fromInteger y in getClockTime >>= return . show . clockTimeToEpochSeconds
19:27:03 <liquidengineer> does not work
19:27:06 <lambdabot> Not in scope: data constructor `TOD'
19:27:06 <lambdabot>  
19:27:06 <lambdabot> <interactive>:1:98: Not in scope: `getClockTime'
19:27:13 <allbery_b> hm
19:27:35 <liquidengineer> getClockTime returns an IO type, which chokes the epoch function
19:27:39 <allbery_b> :t let clockTimeToEpochSeconds (System.Time.TOD x y) = fromInteger x + ((1**(-12)) :: Double) * fromInteger y in System.Time.getClockTime >>= return . show . clockTimeToEpochSeconds
19:27:42 <lambdabot> IO String
19:28:06 <allbery_b> :t let clockTimeToEpochSeconds (System.Time.TOD x y) = fromInteger x + ((1**(-12)) :: Double) * fromInteger y in System.Time.getClockTime >>= return . clockTimeToEpochSeconds
19:28:08 <lambdabot> IO Double
19:29:12 <glguy> NOOOO
19:29:22 <glguy> a >>= return . b -- !!
19:29:26 <glguy> liftM b a
19:29:31 <allbery_b> heh
19:29:37 <liquidengineer> this seems ... troublesome
19:29:39 <sorear> fmap! fmap!
19:29:39 <bd_> fmap b a
19:29:49 <sorear> (>>$) = flip fmap
19:29:54 <sorear> a >>$ b
19:29:55 <allbery_b> :t let clockTimeToEpochSeconds (System.Time.TOD x y) = fromInteger x + ((1**(-12)) :: Double) * fromInteger y in clockTimeToEpochSeconds `fmap` System.Time.getClockTime
19:29:58 <lambdabot> IO Double
19:30:00 <glguy> sorear: ffor?
19:30:14 <sorear> glguy: makes writing parsers much easier.
19:30:15 <dibblego> are there any plans to make a primitive natural number data type?
19:30:26 <sorear> 'fraid not
19:31:14 <glguy> sorear: looks similar to: >>^
19:31:30 <liquidengineer> that's fine
19:31:33 <bd_> dibblego: natural number datatype?
19:31:36 <liquidengineer> they'll just have to make their own seeds
19:31:50 <dibblego> data Nat = Zero | Succ Nat
19:32:03 <liquidengineer> unless there's an easy way to just stick an IO on a type
19:32:11 <glguy> liquidengineer: return
19:32:11 <dibblego> which of course, performs not-so-well unless it is a primitive
19:32:16 <liquidengineer> return?
19:32:24 <dibblego> :type return
19:32:29 <dibblego> ?type return
19:32:31 <bd_> dibblego: Can that be a primitive? :)
19:32:32 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:32:33 <glguy> :t return :: a -> IO a
19:32:36 <lambdabot> a -> IO a :: forall a. a -> IO a
19:32:49 <sorear> bd_: we have Word (aka unsigned int), why not bigword?
19:33:12 <bd_> I suppose, but Integer should be asymptopically just as fast, right?
19:33:18 <liquidengineer> Couldn't match expected type `ClockTime'
19:33:18 <liquidengineer>            against inferred type `m (IO ClockTime)'
19:33:27 <liquidengineer> so close :)
19:33:38 <allbery_b> did you pay any attention to what we were doing above?
19:33:48 <liquidengineer> It really confused me
19:33:58 <allbery_b> fmap clockTimeToEpochSeconds getClockTime
19:34:07 <liquidengineer> fmap?
19:34:12 <dibblego> ?type fmap
19:34:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:34:19 <sorear> like map, but more polymorphic!
19:34:27 <liquidengineer> ...wow.
19:34:31 <liquidengineer> so....what's it do?
19:34:31 <bd_> ?type fmap fmap
19:34:32 <allbery_b> yes.  it lifts clockTimeToEpochSeconds into IO so it can operate on the returned ClockTime
19:34:34 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
19:34:36 <bd_> ?type fmap fmap fmap
19:34:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:34:44 <bd_> hmm
19:35:00 <allbery_b> :t let clockTimeToEpochSeconds (System.Time.TOD x y) = fromInteger x + ((1**(-12)) :: Double) * fromInteger y in fmap clockTimeToEpochSeconds System.Time.getClockTime
19:35:03 <lambdabot> IO Double
19:35:08 <mauke> > fmap toUpper "zomg"
19:35:10 <lambdabot>  "ZOMG"
19:35:20 <liquidengineer> Cool.
19:35:21 <liquidengineer> :D
19:35:31 <allbery_b> getClockTime retuns IO ClockTime, fmap lifts clockTimeToEpochSeconds into IO and produces IO Double
19:35:49 <ddarius> fmap (+1) (const 3) 5
19:35:53 <mauke> > fmap toUpper (Just 'z')
19:35:55 <lambdabot>  Just 'Z'
19:35:57 <ddarius> > fmap (+1) (const 3) 5
19:35:58 <lambdabot>  4
19:35:59 <allbery_b> you can also use liftM, or the first way I did it with the raw monadic mechanisms (>>= and return)
19:36:22 <mauke> > fmap toUpper (const 'z') ()
19:36:24 <lambdabot>  'Z'
19:38:32 <mauke> > runIdentity
19:38:33 <lambdabot>   add an instance declaration for (Typeable1 Identity)
19:38:39 <mauke> nice
19:39:17 <liquidengineer> wow
19:39:18 <liquidengineer> okay
19:39:27 <liquidengineer> just one more question
19:39:33 <liquidengineer> How does one do the reverse?
19:39:38 <liquidengineer> that is, go from IO a to a?
19:39:43 <mauke> you don't
19:39:47 <ddarius> One doesn't.
19:40:03 <mauke> type Pandora = IO
19:40:05 <ddarius> And really, why would you?  The point of a program is IO.
19:40:17 <liquidengineer> hmmm
19:40:49 <liquidengineer> well....thing is, I wanted to use the clocktime as a random seed for mkStdGen
19:40:55 <liquidengineer> mkStdGen needs Ints
19:41:47 <allbery_b> use the same fmap trick
19:41:49 <mauke> oh, just use >>=
19:41:55 <allbery_b> or >>=
19:41:58 <sorear> or use getStdRandom!
19:42:05 <mauke> @type (>>=)
19:42:05 <sorear> @hoogle getStdRandom
19:42:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:42:08 <lambdabot> Random.getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
19:42:13 <sorear> @hoogle getStdGen
19:42:14 <lambdabot> Random.getStdGen :: IO StdGen
19:42:26 <sorear> so use one of those to get a pre-seeded rng
19:42:58 <liquidengineer> What's getStdRandom?
19:43:59 <slowriot> is there any standard function that iterates a function some variable number of times?
19:44:10 <sorear> there isn't one
19:44:17 <sorear> > iterate (*2) 1  -- a list
19:44:19 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:44:36 <liquidengineer> isn'tthat just map?
19:44:50 <sorear> > foldr (const (*2)) 1 (replicate 8 ()) -- a very klugy repeat
19:44:51 <lambdabot>  256
19:45:02 <mauke> :t \n -> take n . iterate
19:45:04 <lambdabot>     Couldn't match expected type `[a]'
19:45:05 <lambdabot>            against inferred type `a1 -> [a1]'
19:45:05 <allbery_b> > take 5 $ iterate (*2) 1
19:45:07 <lambdabot>  [1,2,4,8,16]
19:45:27 <hpaste>  glguy annotated "derivation of (.) (.) (.)" with "better still" at http://hpaste.org/578#a2
19:45:35 <liquidengineer> Oh
19:45:38 <liquidengineer> yeah
19:45:43 <liquidengineer> Now I remember why I can't use getStdRandom
19:45:47 <mauke> :t \n -> ((.) . (.)) (take n) iterate
19:45:50 <liquidengineer> I need to be able to specify my seed
19:45:50 <lambdabot> forall a. Int -> (a -> a) -> a -> [a]
19:45:57 <liquidengineer> not all the time
19:45:58 <liquidengineer> but sometimes
19:46:08 <liquidengineer> so I can recreate a given "random" solution
19:47:20 <allbery_b> > fmap mkStdGen (return 5 :: IO Int) -- won't actually run in LB
19:47:22 <lambdabot>   add an instance declaration for (Typeable StdGen)
19:48:17 <dons> yo
19:48:22 <sorear> ho?
19:48:25 <liquidengineer> ho
19:48:46 <dons> sorear: http://www.cse.unsw.edu.au/~dons/nobench/results.html
19:48:47 <liquidengineer> allbery_b: LB?
19:48:47 <lambdabot> Title: nobench: Haskell implementation shootout
19:48:48 <chessguy> liquidengineer, what are you working on?
19:48:49 * kc5tja things he has a bottle of rum here somewhere...
19:48:49 <dons> numbers starting to appear
19:48:53 <allbery_b> lambdabot
19:49:00 <allbery_b> \but I did something wrong anyway
19:49:19 <allbery_b> and my DSL's starting to drop (mmm, whacked phone wiring + icemelt) so I'm giving up for the night
19:49:19 <sorear> jhc is looking fairly respectable now..
19:49:24 <liquidengineer> chessguy: a random number generator that takes a seed and a range and generates an infinite list of items in that range
19:49:33 <dons> yeah. we'll see what happens once its hits spectral and real
19:49:37 <dons> missing h98 should break things.
19:49:46 <liquidengineer> I need to be able to use a chosen seed because I'm doing genetic programming, and seed is what controls the population I get
19:49:46 <dons> but we did *expect* it to do well on the microbenchmarks
19:49:57 <allbery_b> > return 5 :: IO Int >>= return . mkStdGen
19:49:58 <lambdabot>  Parse error
19:50:11 <allbery_b> > (return 5 :: IO Int) >>= return . mkStdGen
19:50:12 <dons> we need competition amongst the compilers. this should help i think
19:50:12 <lambdabot>   add an instance declaration for (Typeable StdGen)
19:50:18 <allbery_b> hrm
19:50:29 <allbery_b> someone with a brain can figure it out :)
19:50:31 <sorear> ../../bin/timeout 400 will probably hurt jhc a lot :)
19:50:32 <glguy> allbery_b: cut it out, that burns my eyes!
19:51:03 <sorear> allbery_b: what's the Question?
19:51:04 <ddarius> allbery_b: lambdabot is stating exactly what the problem is.
19:51:06 <allbery_b> was just trying to figure out why the fmap one was whining
19:51:49 <glguy> > runIdentity $ return 5 >>= return . mkStdGen
19:51:50 <lambdabot>  6 1
19:52:09 <liquidengineer> chessguy: using the system's random number generator would mean very different, unreproducable results from run-to-run, platform-to-platform, so it's not an option
19:52:20 <glguy> which, except for the fact that we are dragging Monads into this for mno reason, looks beter as
19:52:32 <glguy> > runIdentity $ return . mkStdGen =<< return 5
19:52:33 <lambdabot>  6 1
19:52:39 <chessguy> liquidengineer, what's your end goal?
19:52:49 <liquidengineer> for this project?
19:52:51 <chessguy> yes
19:53:08 <liquidengineer> I'm building a genetic algorithm powered simulation of the game of nim
19:53:09 <glguy> > randoms . mkStdGen $ 42
19:53:11 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
19:53:24 <liquidengineer> I want to see if I can evolve a solution close to the optimal one
19:53:47 <kc5tja> :(
19:53:49 <kc5tja> No fair!
19:53:50 <chessguy> is the optimal one known?
19:53:52 <kc5tja> *I* want to evolve!
19:54:05 <liquidengineer> Yes
19:54:08 <kc5tja> (sorry -- I'm being silly)
19:54:11 <liquidengineer> there's a mathematical formula
19:54:15 <kc5tja> (food/sugar high, I guess)
19:54:25 <liquidengineer> it's explained on wikipedia, if you're interested
19:54:27 <liquidengineer> it's based on XOR
19:57:00 <chessguy> ah, i have read that article
19:57:13 <slowriot> I have a seemingly simple task, but I can't figure out an elegant way to code it
19:57:31 <rashakil> then use an inelegent way.
19:57:39 <slowriot> suppose I have an NxN square of single lower-case letters. columns separated by spaces, rows separated by newlines. I want to read these characters into a list.
19:57:55 <slowriot> hopefully, someone else has an elegant way
19:58:07 <Excedrin> slowriot: look at the sudoku solvers
19:58:13 <mauke> map words . lines
19:58:17 <kc5tja> Read it in as a list of strings, then join all the strings together to flatten it to a single list?
19:59:13 <rashakil> > (head . words) "a b c\nd e f\ng h i\n"
19:59:14 <lambdabot>  "a"
19:59:18 <rashakil> oh moron
19:59:24 <rashakil> > (map head . words) "a b c\nd e f\ng h i\n"
19:59:25 <lambdabot>  "abcdefghi"
20:00:10 <mauke> > filter (not . isSpace) "a b c\nd e f\ng h i\n"
20:00:12 <lambdabot>  "abcdefghi"
20:00:14 <slowriot> so if you call map on a string separated by newlines, it will consider it a list of lines?
20:00:29 <mauke> no
20:00:40 <slowriot> oh
20:00:51 <ddarius> slowriot: Haskell doesn't do magic.
20:01:16 <fuzan> :t lines
20:01:22 <lambdabot> String -> [String]
20:01:27 <slowriot>  > words "a b c\n d e f\ng h i\n"
20:01:32 <Cale> It considers \n whitespace though, if that helps.
20:01:37 <dons> print . map reverse . lines =<< getContents
20:01:40 <slowriot> > words "a b c\n d e f\ng h i\n"
20:01:42 <lambdabot>  ["a","b","c","d","e","f","g","h","i"]
20:02:07 <mauke> > join (words "a b c\n d e f\ng h i\n")
20:02:11 <Cale> > words "  a    b   \n   c d e   f "
20:02:11 <lambdabot>  "abcdefghi"
20:02:13 <lambdabot>  ["a","b","c","d","e","f"]
20:03:22 <glguy> haskell is strongly typed
20:03:27 <glguy> none of that perl non-sense
20:03:40 <mauke> perl is strongly typed, too!
20:03:41 <LoganCapaldo> import Data.Dynamic
20:03:47 <LoganCapaldo> hahaha, only kidding
20:03:48 <glguy> lol
20:03:52 <mauke> keys @foo is a compiler error, for example
20:04:08 <glguy> LoganCapaldo: Data.Dynamic doesn't make the types any less strong :-p
20:04:17 <LoganCapaldo> Looks like a syntax error ;)
20:04:25 <glguy> mauke: lol, until "1" + 2 doesn't work
20:04:26 <LoganCapaldo> since keys is a builtin
20:04:28 <glguy> it's not strongly typed
20:04:39 <hpaste>  sjanssen annotated "derivation of (.) (.) (.)" with "use Haskell to check each step of your proof" at http://hpaste.org/578#a4
20:04:47 <mauke> glguy: depends on your definition of "strongly typed"
20:05:10 <Cale> glguy: hehe, instance Num String where ...
20:05:23 <glguy> Cale: what would that change?
20:05:38 <Cale> It would make "1" + 2 work in Haskell.
20:05:42 <glguy> how?
20:05:43 <LoganCapaldo> it would?
20:05:47 <Cale> Yes, of course.
20:05:56 <glguy> because fromIntegral 2?
20:05:57 <LoganCapaldo> I thought it would still have to be "1" + "2"
20:06:00 <Cale> right
20:06:02 <fuzan> > map (length.words) $ lines "hello and goodbye,\n world"
20:06:05 <lambdabot>  [3,1]
20:06:06 <sjanssen> 2 desugars to (fromInteger compilerConstantFor2)
20:06:18 <sorear> (I# 2#) in ghc
20:06:20 <sjanssen> and fromInteger is an overloaded function in the Num class
20:06:27 <slowriot> would I have to write a recursive function to read n lines from a handle and then concatenate them together? I think I could probably use (foldl ++), but that would
20:06:28 <LoganCapaldo> Ah, so there are implicit conversions?
20:06:29 <sorear> er, S# 2#
20:06:41 <slowriot> ...that would be weird
20:06:42 <glguy> LoganCapaldo: no
20:06:49 <glguy> LoganCapaldo: the constant is exactly one type
20:06:50 <sorear> > concat ["abc","def","gh"]
20:06:51 <lambdabot>  "abcdefgh"
20:06:54 <Cale> slowriot: concat . take n . lines
20:06:55 <sorear> slowriot: ^^
20:07:01 <glguy> the fromIntegral is free because it is a constant
20:07:25 <Cale> slowriot: also, avoid foldl as much as possible, foldr is almost always what you want.
20:07:34 <LoganCapaldo> I think that if "1" + 2 works by doing instance Num String then you are just splitting hairs
20:07:40 <Cale> (well, 75% of the time, anyway)
20:07:48 <LoganCapaldo> as to whether or not an implicit conversion is happening
20:08:03 <glguy> LoganCapaldo: it isn't being "converted"
20:08:12 <LoganCapaldo> You still have to know about fromIntegral, same as you have to know about perl's rules
20:08:29 <mauke> :t \n -> liftM concat . sequence . replicate n $ getLine
20:08:29 <sorear> foldl is Bad ~98% of the time
20:08:31 <lambdabot>     Ambiguous occurrence `sequence'
20:08:32 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
20:08:41 <Cale> However, we probably wouldn't define an instance of Num for String in Haskell, because usually we want our instances of Num to make a little more sense than that.
20:08:41 <sorear> 80% foldr, 18% foldl', 2% foldl
20:08:42 <mauke> lambdabot: you suck
20:08:43 <LoganCapaldo> whether its being "converted" or not it still _looks_ like a "conversion"
20:09:01 <glguy> Cale: can [Char] be an instance of Num under H98?
20:09:06 <Cale> mauke: It's the Data.Traversable import
20:09:06 <slowriot> Cale: I don't have a list of lines, though. I'm reading from a handle.
20:09:11 <sjanssen> glguy: no, it can't
20:09:15 <glguy> HA!
20:09:16 <glguy> solved
20:09:24 <sjanssen> glguy: but it can be effectively solved
20:09:28 <Cale> slowriot: right, so you use x <- hGetContents, and you have a string x
20:09:53 <mauke> slowriot: how about \n -> liftM concat . sequence . replicate n $ getLine ?
20:09:57 <slowriot> That wouldn't work if the handle were stdin, though, would it?
20:10:13 <Cale> yes
20:10:14 <sjanssen> class IsChar t where conv :: [t] -> String; instance (IsChar t) => Num [t] -- glguy, this is an easy workaround
20:10:15 <Cale> it would
20:10:30 <Cale> x is actually constructed lazily (this is magic)
20:10:40 <sjanssen> oh, and: instance IsChar Char where conv = id
20:11:21 <Cale> There's also getContents, when you just want stdin
20:11:22 <sorear> sjanssen: instance IsString Int where fromString = read , now "2" + 3 works
20:11:40 <rashakil> okay, now slowriot has been told that Haskell doesn't do magic, and that it does...  just keeping score.
20:11:45 <bd_> sorear: that's evil :(
20:11:50 <sorear> sjanssen: -foverloaded-strings will be abused
20:12:03 <sjanssen> sorear: hahaha, I hadn't thought about that before!
20:12:31 <slowriot> Cale: okay, cool
20:12:40 <sjanssen> sorear: I think overloaded strings are a necessary evil, though
20:12:45 <bd_>  forkIO "print 42"
20:12:47 <slowriot> mauke: I'm looking that stuff up on haskell.org at the moment
20:13:46 <sorear> I think all syntax sugar should be overloaded.  List syntax!  Strings!  Numeric literals!  Lambdaforms!
20:14:04 <ddarius> sorear: Far less than 2% of the time is foldl useful.
20:14:21 <ddarius> foldl' is probably the most useful
20:15:08 <sorear> @src reverse
20:15:08 <lambdabot> reverse = foldl (flip (:)) []
20:15:24 <sorear> ... can foldl' be used there?
20:16:02 <ddarius> > foldl' (flip (:)) [] [undefined, 'a']
20:16:03 <lambdabot>  Undefined
20:16:10 <ddarius> > foldl (flip (:)) [] [undefined, 'a']
20:16:12 <lambdabot>  Undefined
20:16:21 <bd_> heh
20:16:24 <glguy> > head $ foldl' (flip (:)) [] [undefined, 'a']
20:16:25 <lambdabot>  'a'
20:16:26 <bd_> > reverse [undefined, 'a']
20:16:28 <lambdabot>  Undefined
20:16:30 <bd_> oh
20:16:31 <bd_> right
20:17:20 <ddarius> sorear: Yes.  We have id $! ((:) x xs) = ((:) x xs)
20:18:04 <sorear> ddarius: forall x. id $! x = x
20:18:11 <hpaste>  mauke pasted "Magic!" at http://hpaste.org/583
20:18:11 <glguy> > foldr (\x -> (x:).(if even x then (x:) else id)) [] [1..10]
20:18:13 <lambdabot>  [1,2,2,3,4,4,5,6,6,7,8,8,9,10,10]
20:18:16 * sorear expected better of the great ddarius
20:18:38 <ddarius> ddarius expected the readers to grasp my intent
20:18:51 <hpaste>  sjanssen pasted "overloaded fiasco!" at http://hpaste.org/584
20:18:52 <ddarius> But whatever, forcing a cons cell is always safe.
20:18:53 <glguy> the example is left to the read as an exercise?
20:18:56 <sjanssen> sorear: ^^^
20:19:33 <ddarius> forall f. f $! ((:) x xs) = f ((:) x xs)
20:20:13 <sorear> sjanssen: remember that safe strings post? we could automate lifting!
20:20:43 * ddarius goes back to playing with his Leatherman e307x
20:21:05 * sorear feels sharp pains for ddarius
20:21:39 <mbishop> better than shapr pains, I suppose
20:21:44 <mauke> instance (IsString a) => IsString (IO a) where fromString s = putStr s >> return (fromString s)
20:21:45 <ddarius> This thing is sweet, I should buy my self one.
20:21:53 <Nafai> mbishop: Hah!
20:22:09 <sjanssen> sorear: that'd actually be pretty handy
20:22:24 <sjanssen> even in a normal library like xhtml
20:22:26 <mauke> do { x <- "3"; print (x + 2) }
20:22:28 <mbishop> ddarius: I like my leatherman wave myself
20:22:49 <sorear> what, does leatherman make cellphones now?
20:23:11 * sorear was wondering why ddarius liked playing with knives so much
20:23:21 * mbishop cuts sorear
20:24:02 <sjanssen> you have a leatherman, and the best you can do is "cut"?
20:24:18 <ddarius> The Wave is not a knife.
20:24:24 <ddarius> (It has knives, but...)
20:24:30 * sjanssen gouges mbishop with an awl
20:24:34 <glguy> ?remember sjanssen [(*) mbishop cuts sorear] you have a leatherman, and the best you can do is "cut"?
20:24:35 <lambdabot> Done.
20:24:44 <fuzan> It actually has a small embedded processor that can calculate the optimal cutting angle.
20:25:03 <mbishop> heh
20:25:17 <mbishop> the wave has quite a few features...I could saw off sorear's limbs if you so prefer
20:25:31 <ddarius> It's fun to launch the blade and put it back with one hand.  It's so smooth and easy.  Same for the carabiner.  The bit driver, not so much.
20:25:59 <fuzan> You should try a banana knife.
20:26:13 <LoganCapaldo> My leatherman not only cuts, it also backtracks
20:26:44 <mbishop> I can open/close the main blade on my wave, but closing is just a little dangerious (have to push the lock then push the blade downward, forget to move your finger and you might lose it)
20:26:54 <fuzan> Damnit, I tried to make up a silly imaginary knife and it exists :\
20:26:54 <mbishop> open/close with one hand that is
20:27:44 <ddarius> The e307x has Blade Launcher, so I can open it with a slight flick of the wrist and close it by simply pushing a bit on the lock liner.
20:28:24 <mbishop> I use my leatherman all the time, it's so handy heh
20:29:18 <SamB> fuzan: hahaha
20:35:03 <bd_> hmm that's interesting
20:35:09 <JohnnyL> has there been web sites written in haskell?
20:35:29 <bd_> open ghci, type: :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap. You will get something very long. Now do :m + Control.Monad.Fix and :m - Control.Monad.Fix. Now try again.
20:35:31 <glguy> !paste
20:35:31 <hpaste> Haskell paste bin: http://hpaste.org/
20:36:01 <ddarius> @google halipeto
20:36:04 <lambdabot> http://www.acooke.org/jara/halipeto/index.html
20:36:05 <lambdabot> Title: Jara Software: Halipeto: Home Page
20:36:18 <mbishop> @where cookbook
20:36:19 <lambdabot> I know nothing about cookbook.
20:36:38 <mbishop> @where+ cookbook http://haskell.org/haskellwiki/Cookbook
20:36:39 <lambdabot> Done.
20:36:52 <allbery_b> bd_: known, has been discussed on -cafe
20:37:04 * ddarius does not say that @wiki Cookbook is shorter
20:37:16 <allbery_b> once ghci sees a type it never quite lets go
20:37:18 <bd_> allbery_b: ah
20:37:21 <mbishop> heh
20:37:22 <mbishop> @wiki
20:37:23 <lambdabot> http://www.haskell.org/haskellwiki/
20:37:27 <mbishop> @wiki cookbook
20:37:28 <lambdabot> http://www.haskell.org/haskellwiki/cookbook
20:37:32 <Cale> @where hope
20:37:33 <lambdabot> http://hope.bringert.net/
20:37:41 <mbishop> neat :P
20:37:43 <Cale> There's a website in Haskell :)
20:38:42 <Cale> Is there a list of active HAppS projects somewhere?
20:38:56 <sorear> #haskell
20:38:57 <sorear> :)
20:39:54 <Cale> Well, there's obviously HPaste and pass.net
20:45:52 * ddarius needs to get to sewin'
20:52:48 <sorear> dons: poke, primes/yhc has been running way too long (by the build.log)
20:55:56 <fuzan> i like how the hpaste's generated html doesn't contain a single newline :)
20:56:20 <ddarius> fuzan: It's to save on disk space.
20:57:34 <glguy> it is to save on bandwidth
20:57:44 <sorear> fuzan: heh. xhtml has a printer that produces nls, but it is documented as FOR DEBUGGING USE ONLY
20:58:09 <glguy> hpaste doesn't use newlines to terorize sorear
20:59:03 <malsyned> is there a haskell xhtml pretty-printing library for restoring the newlines on the client machine on demand? ;)
20:59:23 <ddarius> Maybe.  It'd take like 5 seconds to write one.
21:00:06 * fuzan needs to play with happs
21:00:10 <malsyned> a sufficiently advanced haskell programmer is indistinguishable from a magician.
21:00:41 <glguy> which brings us back to SICP
21:00:42 <fuzan> are you saying that haskell programmers trick people into thinking their code works?
21:01:04 <malsyned> fuzan: no, that would imply that they actually were a magician.
21:01:12 <allbery_b> into thinking it's easy? :)
21:01:17 * glguy is meerly a conjurer
21:01:18 <malsyned> allbery_b: exactly
21:01:34 <Cale> @where conjure
21:01:34 <lambdabot> http://darcs.haskell.org/~lemmih/conjure/
21:01:35 <glguy> merely*
21:03:16 * glguy &
21:03:57 <malsyned> does happs use haxml or hxt or one of those, or does it have its own html-generating system?
21:04:46 <glguy_> happs doesn't generate html
21:04:59 <glguy_> you'd use xhtml, HaXml, xsltproc, HXT
21:05:00 <glguy_> etc
21:05:01 <malsyned> oh.  what's it do then?
21:05:24 <glguy_> translates requests into transformations on state and then into responses
21:05:44 * Boney waits for someone to write Haskell on Hangers so we can all write blogs really really quickly.
21:05:57 <malsyned> it leaves the representation of the state, requests, and responses up to the user?
21:06:03 <LoganCapaldo> Happs is too hard core for me
21:06:12 <LoganCapaldo> I _want_ Haskell on Hangers
21:06:25 <SamB> on hangers?
21:06:27 <Boney> lets write one.  Tonight.
21:06:37 <SamB> for lambda lifting?
21:06:41 <Boney> SamB: a play on "Ruby on Rails"
21:06:58 <allbery_b> better than "... on hairpins"
21:07:12 <fuzan> haskell on harlots ?
21:07:18 <mbishop> Haskell on Heroin
21:07:19 <malsyned> handbaskets? ;)
21:07:22 <Boney> haskell on hovercrafts.
21:07:31 <Boney> there we've got the transport thing going that rails does.
21:07:33 <allbery_b> hang-gliders!
21:07:37 <Boney> Oh!
21:07:42 <mbishop> Haskell on Helicopters
21:07:42 <LoganCapaldo> Haskell on HyperShips
21:07:47 <malsyned> LoganCapaldo: beat me to it!
21:07:57 <sorear> Haskell on Helium?
21:08:03 <Boney> lets just call it HoH and people can decide what the 2nd H means for themselves.
21:08:05 <fuzan> Haskell on Hexagrams.
21:08:13 <LoganCapaldo> LOL
21:08:22 <jcreigh> Or maybe it could just be named like anything else without trying to make a bad pun...
21:08:23 <LoganCapaldo> HoH: Haskell on HoH
21:08:23 <ddarius> Boney: History of Haskell
21:08:24 <malsyned> Boney: I second that
21:08:27 <mbishop> Haskell on Haskell?
21:08:33 <SamB> Boney: not that kind of rails
21:08:34 <LoganCapaldo> Lazily evaluated infinite acronym
21:08:41 <SamB> the kind you use for rackmount stuff
21:08:49 <Boney> SamB: oh.
21:08:59 <mbishop> Haskell on Hotpot Mits
21:09:16 <Boney> now that I've de-railed the conversation..
21:09:18 <LoganCapaldo> let HoH = "Haskell on " ++ HoH in HoH
21:09:26 <LoganCapaldo> > let HoH = "Haskell on " ++ HoH in HoH
21:09:27 <lambdabot>   Not in scope: data constructor `HoH'
21:09:28 <glguy_> ?quote rails
21:09:28 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
21:09:33 <LoganCapaldo> doh
21:09:41 <SamB> well, okay, okay, so it works both ways
21:09:46 <LoganCapaldo> > let _HoH = "Haskell on " ++ _HoH in _HoH
21:09:46 <mbishop> HoH HoH HoH, Merry Monads!
21:09:47 <lambdabot>  "Haskell on Haskell on Haskell on Haskell on Haskell on Haskell on Haskell o...
21:10:06 <SamB> > fix (showString "Haskell on")
21:10:07 <lambdabot>  "Haskell onHaskell onHaskell onHaskell onHaskell onHaskell onHaskell onHaske...
21:10:11 <SamB> er.
21:10:12 <SamB> > fix (showString "Haskell on ")
21:10:14 <lambdabot>  "Haskell on Haskell on Haskell on Haskell on Haskell on Haskell on Haskell o...
21:10:25 <LoganCapaldo> > fix ("Haskell on "++)
21:10:26 <glguy_> sounds slow
21:10:27 <lambdabot>  "Haskell on Haskell on Haskell on Haskell on Haskell on Haskell on Haskell o...
21:10:47 <LoganCapaldo> Mine's shorter :)
21:11:05 <LoganCapaldo> but the point was the lazy infinite acronym! You lose that with fix
21:11:12 <malsyned> This channel is the first time I've ever seen a MUREPL.
21:11:18 <glguy_> fix is lazy
21:11:39 <LoganCapaldo> glguy, but wheres the acronym?
21:11:40 <SamB> malsyned: a what?
21:11:42 <malsyned> or at this point, more of an MMOREPL.
21:12:04 <malsyned> SamB: Massively Multiplayer Online Read-Eval-Print Loop
21:12:18 <SamB> Multiplayer Undiscoverd Recreational Environment for Programming Languages?
21:12:53 <malsyned> @users
21:12:53 <lambdabot> Maximum users seen in #haskell: 317, currently: 287 (90.5%), active: 37 (12.9%)
21:12:59 <malsyned> ^^^ I think it's been discovered.
21:13:15 <SamB> no more than the Undiscovered Underground, methinks...
21:13:27 <fuzan> any gentooers here?
21:13:42 <glguy_> aw, not nice to out them :0)
21:13:45 <sorear> @seen lambdabot
21:13:45 <lambdabot> Yes, I'm here. I'm in #haskell.it, #haskell, #haskell.es, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell-
21:13:46 <lambdabot> overflow and #haskell-blah
21:14:04 <sorear> sure, so many we have an entire channelful of them
21:14:10 <sorear> @users #gentoo-haskell
21:14:10 <lambdabot> Maximum users seen in #gentoo-haskell: 24, currently: 19 (79.2%), active: 3 (15.8%)
21:14:13 <SamB> @seen freenode2:lambdabot2
21:14:14 <lambdabot> I haven't seen freenode2:lambdabot2.
21:14:22 <SamB> @seen lambdabot2
21:14:23 <lambdabot> I haven't seen lambdabot2.
21:14:35 <sorear> SamB: ?
21:14:39 <SamB> sorear: what?
21:14:47 <fuzan> i'm in #gentoo-haskell
21:14:50 <SamB> isn't there such a creature?
21:14:55 <fuzan> I asked a question a while back :)
21:14:58 <sorear> once :)
21:15:07 <SamB> where did the poor thing go?
21:15:14 <SamB> and who is in the channels it was in?
21:16:36 <kfish> yeah, no lambdabots in #haskell.jp :-(
21:16:49 <sorear> @help irc-connect
21:16:50 <lambdabot> irc-connect tag host portnum nickname userinfo.  connect to an irc server
21:17:20 <sorear> @irc-connet freenode2 chat.freenode.net 6667 lambdabot2 LambdarobotsForever
21:17:32 <sorear> @join freenode2:#haskell.jp
21:17:41 <sorear> @seen freenode2:lambdabot
21:17:42 <lambdabot> I haven't seen freenode2:lambdabot.
21:17:48 <sorear> @seen freenode:lambdabot
21:17:48 <kfish> i have!
21:17:49 <lambdabot> Yes, I'm here. I'm in #haskell.it, #haskell, #haskell.es, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell-
21:17:49 <lambdabot> overflow and #haskell-blah
21:18:06 <SamB> sleepy time
21:18:19 <kfish> @seen freenode:lambdabot2
21:18:19 <lambdabot> I haven't seen freenode:lambdabot2.
21:18:42 <sorear> @admin + freenode2:sorear
21:19:02 <sorear> @msg freenode2:#haskell hi!
21:19:11 <SamB> @bot
21:19:12 <lambdabot> :)
21:19:17 <sorear> er, +n
21:19:44 <sorear> so, who else wants a lambdabot2?
21:19:59 <SamB> so, this persists?
21:20:10 <sorear> until the next restart
21:20:20 <SamB> that sounds kinda useless
21:20:46 <sorear> SamB: lambdabot has only a crippled version of happs.
21:20:52 <SamB> oh, but sleep...
21:21:00 <SamB> lambdabot has happs?
21:21:00 <sorear> SamB: if lambdabot had a full version, all this would persist
21:21:02 <fuzan> is there a "extralibs" ghc package on the gentoo-overlay?
21:21:24 <allbery_b> I think it's broken into components
21:21:28 <Boney> @type fix
21:21:31 <allbery_b> libghc6-*
21:21:31 <lambdabot> forall a. (a -> a) -> a
21:21:40 <sorear> SamB: no, it's so crippled it goes by a different name, in much the same way (and extent) DOS is a crippled version of UNIX
21:21:48 <allbery_b> e.g. libghc6-net-dev, libghc6-mtl-dev, etc.
21:22:00 <emk> OK, I finally ported Sungwoo Park's probability monad to Haskell:
21:22:01 <emk> http://www.randomhacks.net/articles/2007/02/21/randomly-sampled-distributions
21:22:04 <lambdabot> Title: Refactoring probability distributions, part 2: Random sampling, http://tinyurl.com/2ytmlt
21:22:22 <SamB> sorear: ah.
21:22:42 <malsyned> goodnight, everybody.
21:22:47 <SamB> so like it isn't happs at all, but just borrows a few ideas, twisted into a cruel caracature?
21:23:15 <sorear> yeah
21:25:31 <sorear> emk: so I suppose now would be a good time to unveil my co-monadic RNG?
21:26:43 <sorear> > drop 100000 $ fix (([0::Int ..607] ++) . liftM2 (zipWith (+)) (drop 203) (drop 606))  -- unrelated "random" discovery of the day - lagged Fibonacci PRNG is a Haskell one-liner, using fixed point arithmatic and lazy streams.
21:26:45 <lambdabot>  [952572057,-1388372156,50283391,-1273810191,1332589190,-1190325566,-19321366...
21:27:31 <emk> sorear: Yikes!
21:27:42 <sorear> random numbers!
21:28:35 <emk> sorear: You could always use a real-world entropy source: http://xkcd.com/c221.html
21:28:36 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
21:29:10 <sorear> is that the 4 one? cause I've been referred to that twice already :)
21:29:21 <emk> sorear: Of course. :-)
21:29:39 <emk> It's just too appropriate for random numbers in Haskell...
21:30:35 <bd_> too bad in C it's far too hard to prove correctness of the code ;)
21:30:49 <sorear> dons: yhi (timeout 400 as always) has been running for an HOUR now
21:31:18 * allbery_b thinks sorear's yi fingermacro got the best of him there
21:33:23 <ddarius> Hmm, straight stitch all the way
21:34:03 <glguy_> http://xkcd.com/c224.html
21:34:04 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
21:34:36 <sorear> allbery_b: yi?
21:34:46 <sorear> allbery_b: I was talking about the York Haskell Interpreter
21:34:54 * jcreigh likes xkcd
21:35:14 <allbery_b> oh
21:37:14 <sorear> or maybe dons killed it ... :)
21:37:57 <glguy_> > (9^2+19^2/22)**0.25
21:37:58 <lambdabot>  3.141592652582646
21:38:16 <glguy_> > (9^2+19^2/22)**0.25 - pi
21:38:17 <lambdabot>  -1.007147254483698e-9
21:42:58 <Pseudonym> iterate (\x -> x + sin x) 3 !! 10
21:43:02 <Pseudonym> > iterate (\x -> x + sin x) 3 !! 10
21:43:04 <lambdabot>  3.141592653589793
21:43:08 <Pseudonym> > iterate (\x -> x + sin x) 3 !! 10 - pi
21:43:10 <lambdabot>  0.0
21:44:41 <glguy_> > iterate (\x -> x + sin x) 3
21:44:43 <lambdabot>  [3.0,3.1411200080598674,3.1415926535721956,3.141592653589793,3.1415926535897...
21:44:54 <glguy_> > iterate (\x -> x + sin x) 2
21:44:56 <lambdabot>  [2.0,2.9092974268256815,3.139509133067792,3.1415926520823465,3.1415926535897...
21:45:06 <glguy_> > iterate (\x -> x + sin x) 0
21:45:08 <lambdabot>  [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0...
21:45:13 <glguy_> :(
21:45:22 <ddarius> 0 + 0 = 0
21:45:29 <glguy_> clearly
21:45:31 <glguy_> > iterate (\x -> x + sin x) 0.1
21:45:32 <lambdabot>  [0.1,0.19983341664682816,0.39833948190923774,0.7862278496020768,1.4939210640...
21:45:40 <kc5tja> Finally -- a reason to hack in Haskell -- Let darcs replace accept quotation marks as valid members of a symbol name.  >:(
21:46:04 <dons> hey great news. we have a student to work on Frag this year!
21:46:59 <beschmi> kc5tja: cool, you know where to start?
21:47:40 <sorear> great!
21:47:56 <dons> trying to convince him to do an smp yampa layer
21:48:01 <ddarius> Wow.  Haskell must really be unpopular if finding a someone to work on a 3D shooter out of a group of -student- programmers is hard.
21:48:07 <dons> though he might want to work on the ai layer
21:48:12 <sorear> dons: check the nobench run, yhi has been running for nine times longer than the timeout
21:48:27 <dons> ddarius: no, it wasn't hard! we have 2 students getting ready to work on it, in fact :-)
21:48:41 <kc5tja> beschmi: NOPE!
21:48:43 <dons> sorear: oh. hmm
21:48:45 <dons> yhi ?
21:48:53 <sorear> york haskell interpreter
21:49:01 <kc5tja> beschmi: But at some point, I will find out any way I can, including pestering folks here, #darcs, mailing lists, etc.
21:49:02 <dons> sorear: oh sorry. /me was thinking of hbi
21:49:07 <sorear> end of bench.log hasn't moved in an hour
21:49:12 <dons> sorear: on your end? or mine?
21:49:14 <nornagon> @src pi
21:49:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:49:23 <sorear> dons: yours
21:49:28 <kc5tja> beschmi: Because as a Forth coder, symbols can (like Haskell) be comprised of any arbitrary punctuation.
21:49:29 <sorear> http://www.cse.unsw.edu.au/~dons/nobench/bench.log
21:49:41 <nornagon> > iterate (\x -> x + sin x) 4
21:49:41 <dons> who says that's up to date?? ;)
21:49:42 <lambdabot>  [4.0,3.2431975046920716,3.1417673837620823,3.141592653590682,3.1415926535897...
21:49:49 <nornagon> > iterate (\x -> x + sin x) 7
21:49:50 <lambdabot>  [7.0,7.656986598718789,8.637645745090698,9.345977622677124,9.424696434390352...
21:49:55 <kc5tja> beschmi: And guess what -- I need to rename a symbol in a ton of Forth sources that includes a dot and a quotation mark in them.  Go figure.
21:49:58 <dons> updated
21:50:00 <nornagon> > 3 * pi
21:50:01 <lambdabot>  9.42477796076938
21:50:09 <sorear> dons: I thought you had a system that served directly from the harddrive. sorry.
21:50:22 <sorear> I thought I was unique in needing to manually push changes :)
21:50:22 <beschmi> kc5tja: tried to add support for spaces in replace, but they don't get properly quoted properly in patch files
21:50:34 <dons> nah, i had a script running that did 'make publish' every now and then , but i pulled the network connectoin and must've killed it
21:50:48 <dons> normally 'make publish' just runs at the end of the script
21:51:08 <beschmi> kc5tja: so make sure sure that it works for quotes. i can look for the mailing list discussion/issues
21:51:09 <brad__> hi, can anyone provide me with a very coarse simplistic explanation of STM?
21:51:44 <sorear> atomically blocks don't get interrupted
21:52:02 <dons> and transactions are logged and retried, rather than deadlocking
21:52:06 <sorear> ^^^ coarsest over-simpliedest explanation available
21:52:12 <brad__> ah, i see!
21:52:20 <dons> since actions are pure you can rerun them again and again
21:52:29 <brad__> i am reading the paper now, just thought i would skip to the chase
21:52:47 <brad__> by paper i mean http://research.microsoft.com/Users/simonpj/papers/stm/beautiful.pdf
21:52:49 <lambdabot> http://tinyurl.com/2hyrxp
21:52:54 <glguy_> and since processor time is theoretically infinite... retries don't cost anything ;)
21:53:15 <sorear> brad__: it runtime compiles the atomically block into a virtual CASn instruction (check these values, then write thes)
21:53:35 <sorear> then a small atomic update kernel executes the instruction
21:53:43 <sorear> if it fails, the action is retried
21:53:50 <brad__> it seems the "crux" is that transactions are logged and retried
21:53:53 <brad__> am i right?
21:54:00 <sorear> it's just like the old atomic list manager trick
21:54:04 <dons> brad__: right.
21:54:14 <glguy_> the action is only retied when a retry statement is found?
21:54:16 <brad__> this is what seems to differentiate STM from "normal" wait/signal concurrency
21:54:16 <sorear> eg in the appendix of the Motorola MC68020 System Programmer's Manual
21:54:32 <sorear> except that book uses assembly language, not haskell :)
21:54:45 <glguy_> brad__: less error prone, more scalable
21:55:21 <brad__> so it seems very important that these transactions are strictly ordered, otherwise this retry log will result in values getting clobbered
21:55:36 <brad__> this ordering seems non-trivial to implement
21:55:41 <sorear> the log is local to each transaction
21:56:12 <sorear> all the runtime system has to enforce is atomicity of the final compare-and-swap
21:56:29 <siti> "I shall explain STM using Haskell,the most beautiful programming language I know" <-- not biased at all ;)
21:56:33 <sorear> and that can be done with atomic instructions (look ma, no locks!)
21:56:51 <brad__> let me try to make a leap - since values in haskell can be traced through the functions acting upon them with functional semantics (no side effects), haskell lends itself to STM
21:56:53 <Japsu> lol, microsoft paper typeset with TeX :)
21:57:12 <siti> yeah a good ms guy :)
21:57:23 <sorear> dons: awww - /~dons/code/nobench/imaginary/paraffins/jhc-ghc.compile --> 404
21:57:52 <brad__> is my statement true? does haskell lend itself to STM more than other languages?
21:57:53 <dons> right. i need a script to tar those up and put them into the web dir
21:58:04 <dons> brad__: right. since side effects can be ruled out statically
21:58:11 <dons> making this whole thing tractable
21:58:31 <sorear> dons: you can't just use 'cd public_html ; ln -s ../nobench' :)
21:58:34 <dons> > print "same reason we can allow arbitrary haskell in an irc channel"
21:58:39 <lambdabot>  <IO ()>
21:58:44 <brad__> interesting...its a real feather in the cap of haskell
21:58:51 <brad__> if STM proves out
21:59:43 <sorear> > unsafePerformIO (renameFile ".bashrc" "nobench/_darcs/inventory")  -- good old fashioned namespace control is also needed
21:59:46 <lambdabot>   Not in scope: `renameFile'
22:00:15 <brad__> also i see ghc has reclaimed a respectable position in the shootout sandbox!
22:00:21 <ddarius> Bah. Capabilities.
22:02:12 <sorear> brad__: have you seen:
22:02:18 <sorear> @where nobench-results
22:02:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/results.html
22:02:22 <brad__> yes!
22:02:24 <brad__> very cool
22:02:45 <brad__> ghc seems to rule the roost
22:03:08 <ddarius> It'd be embarassing if it didn't.
22:03:14 <brad__> dons - any chance of goa being part of the next ghci (6.8)?
22:04:25 <brad__> a random aside, i started looking into D (the digitalmars C-like lang) last night...you know, compared to haskell, it just didn't seem that interesting!
22:04:44 <ddarius> D isn't that interesting period.
22:04:53 <ddarius> (But then that's not really it's goal)
22:04:57 <brad__> the more i learn about haskell, the more i realize i don't know!
22:05:03 <allbery_b> it's an improvement over C... which isn't saying much.  (so is a sharp stick in the eye)
22:05:29 <brad__> yes i agree ddarius, it seemed that being interesting was not a goal of D
22:06:04 <sorear> brad__: and once you learn enough about haskell, you realize there is nothing to know about it.
22:06:34 <brad__> sorear - a closet existenstialist?
22:06:35 <sorear> brad__: it's first order System Fw with type inference and a ton of sugar.
22:06:58 <brad__> yes but you have to get to haskell nirvana first to grok that in your head
22:07:21 <ddarius> " ... ... ... you can't fool me.  It's functions all the way down."
22:08:08 <brad__> there are a lot of mind-benders on the way though...i can tell you that after years of imperative programming, partially evaluated functions (for example) are a trip!
22:08:34 <brad__> but then i realize they are essential to the language, a bigger trip!
22:09:25 <kc5tja> beschmi: If you could, that'd be awesome.  Thanks :)
22:09:36 * kc5tja took on Firefox and won, I'm sure I can take on Darcs too.
22:09:56 <brad__> well thanks everyone for teaching me the essentials of STM
22:10:03 <brad__> take care and good night!
22:10:10 <sieni> night?
22:10:14 <sieni> you lucky bastard!
22:10:18 <brad__> in california it is!!
22:10:24 <kc5tja> Yay california!
22:10:31 <sorear> night too!
22:10:35 <brad__> bay area!
22:10:38 * kc5tja is in Mountain View
22:10:41 <sieni> nighty night
22:10:42 <sorear> sd here :(
22:10:47 <brad__> me in san jose
22:10:52 <brad__> a dot in the hills
22:10:52 <kc5tja> sorear: Doh -- I *used* to live in San Diego.
22:10:58 <brad__> i can see mtn view from here!
22:11:09 <kc5tja> brad__: Haha -- I drove through that just this last Saturday.
22:11:22 <kc5tja> That rock on the side of 101 coming in, at night, is pretty scary.  :)
22:11:33 <brad__> indeed!
22:11:48 <brad__> try driving mt hamilton for true fright!
22:11:57 <kc5tja> Heheh -- maybe next time.
22:12:18 <brad__> 360 hairpin turns - no kjoke!
22:12:21 <kc5tja> I would like to do some more sight-seeing around here though.
22:13:07 <brad__> yes a lot to see and do in the bay area
22:13:07 <kc5tja> Anyway, I'll let you go.  Hope to see you again here.
22:13:21 <brad__> agreed kc5tja! take care!
22:36:22 <nrb23> anyone want to talk data structures?
22:37:18 <nrb23> I'm trying to determine the best structure for my Ethereal/WireShark-like project
22:38:22 <sieni> nrb23: struct {int a; double b;} foo = {7, 10.2};
22:38:36 <sieni> it's a bit hard to communicate this way, but...
22:40:48 <dons> data T = T { a :: Int, b :: Double }
22:40:59 <nrb23> sieni: :->
22:41:34 <nrb23> I'm trying to represent the whole wrapping of packet layers
22:41:55 <nrb23> Ethernet -> IP -> TCP
22:41:57 <kc5tja> nrb23: How, exactly, do you mean by that?
22:42:00 <kc5tja> Ah
22:42:12 <nrb23> and eventually, I want HTTP, IRC, etc
22:42:16 <kc5tja> Each layer represented by a unique object of some kind?
22:42:25 <nrb23> at the moment, that's what I have
22:42:39 <nrb23> ?paste
22:42:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:43:13 <kc5tja> Damn, I really need to remember ?paste command.  That is just plain too dang useful.  :)
22:44:19 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/585
22:44:36 <nrb23> and, once again I forgot the title and my name
22:45:00 <hpaste>  nrb23 annotated "(no title)" with "etherbunny types" at http://hpaste.org/585#a1
22:45:59 <nrb23> I'm using the Binary.Get Monad
22:46:12 <nrb23> I have a getEthernetPacket
22:46:22 <nrb23> it calls getIPPacket
22:46:28 <nrb23> which calls getTCPPacket
22:47:04 <nrb23> each of these returns one of the datatypes from the paste
22:48:23 <nrb23> I have two issues with this method
22:48:38 <nrb23> one, it's not very flexible
22:48:45 <nrb23> but I can live with that
22:49:04 <nrb23> two, in order to check the TCP checksum, I need to know about the IP layer
22:50:07 <kc5tja> Unfortunately so.
22:50:24 <kc5tja> I don't know what they were thinking when the framers of the protocol spec did that.  Morons.
22:50:31 <kc5tja> "It was for efficiency reasons!" they claim.
22:50:33 <kc5tja> Bullcrap.
22:50:37 <nrb23> heh
22:50:51 <kc5tja> The nodes were all I/O bound -- the *fastest* links were 56kbps at the time.
22:50:57 <kc5tja> They were not compute-bound.
22:51:14 <nrb23> well, it does save needing to repeat the IP address
22:51:23 <kc5tja> You don't need to repeat the IP address.
22:51:37 <kc5tja> TCP's job is reliable transport, not routing.
22:51:39 <kc5tja> That's IP's job.
22:51:58 <nrb23> right, but it's a good idea to include the IP address in the checksum
22:52:01 <nrb23> although not essential
22:52:07 <kc5tja> I 100% disagree.
22:52:21 <kc5tja> As a result, TCP is now intrinsically intertwined with IP -- cannot be separated.
22:52:23 <nrb23> in any case, it's a PITA
22:52:30 <kc5tja> This was a *major* issue when IPv6 came out.
22:52:35 * kc5tja nods
22:52:40 <nrb23> yeah, I suppose that's true
22:52:57 <kc5tja> They point at X.25 and its derivatives, and laugh, and say, "Look how you confuse your network layers!"
22:53:03 <kc5tja> But they refuse to look in the mirror.
22:53:08 <nrb23> :->
22:53:23 <kc5tja> If it's one thing I abhore the most, it's hypocrites, and the framers of the IP protocol stack comprise the very definition.
22:53:35 <kc5tja> But I digress.  Sorry -- it hits home, since I also hack AX.25 protocol.  :)
22:53:40 <nrb23> :->
22:54:04 <nrb23> what pisses me off is the ones-compliment math in the checksum
22:54:50 <kc5tja> Hehe
22:55:17 <kc5tja> Haskell compilers ought to optimize that (-x-1) is the same as (x^0xFFF...)
22:55:30 <kc5tja> where ^ is the C-language XOR operator in this case.
22:55:48 <nrb23> (I had a CRAZY bug in a tcp/ip stack involving it a month or so ago)
22:58:17 <nrb23> anyway... I'm not sure what the best way to implement this is
22:58:28 <nrb23> in Python, I'd make a heterogenous list
22:59:13 <nrb23> [EthPkt, IPPkt, TCPPkt, ProtocolSpecific]
23:01:56 <kc5tja> Well, I guess I'm not understanding precisely what the concern is.
23:02:12 <kc5tja> I see two methods of resolving your conflict though.
23:02:23 <kc5tja> First, define a heterogeneous list data type of some kind.
23:02:26 <nrb23> I don't like the descending encapsulation I currently have
23:02:55 <kc5tja> Second, define classes so that any arbitrary "thing" may be "embeddable" inside the Ethernet frame, for instance.
23:03:11 <kc5tja> (e.g., an IPPkt would be an instance of EtherEmbeddable class or some such)
23:03:35 <kc5tja> But, really, I'm thinking the easiest solution would be to define (or find in some library) a hetero-list.
23:03:58 <nrb23> yeah, I can make a hetero-list
23:04:30 * kc5tja isn't good enough with Haskell to know how to do that.  So I'll leave that to the experts for the time being.  But, that being said, it should be possible to do.
23:05:45 <nrb23> I'm not sure about the "embeddable class" thing working
23:05:52 <kc5tja> A degenerate case might be data Pkt = EthPkt h (Pkt hs) | IPPkt h (Pkt hs) | ...
23:05:55 <nrb23> classes don't give you dynamic types
23:06:11 <kc5tja> That is still 100% type safe, but it's still might be a pain to extend later on.
23:06:24 <nrb23> yeah, I may just keep it how it is
23:06:46 <nrb23> I'd eventually like to be able to do plugins, but I haven't had a chance to look through the plugin library
23:07:03 <kc5tja> I'm going to be pondering that all night now -- there just has to be a way of defining a heterogeneous list.
23:08:47 <kc5tja> :t data P = E a (P ps) | I b (P ps)
23:08:51 <lambdabot> parse error on input `data'
23:09:13 <mauke> a, ps, b undeclared
23:10:03 <kc5tja> undeclared in what way though?  I'm not trying to parameterize P.
23:10:20 <mauke> oh
23:10:41 <kc5tja> :t data P = E a (P ps) | I b (P ps) | Nil
23:10:44 <lambdabot> parse error on input `data'
23:11:00 <kc5tja> just making sure that a sentinel type wasn't the cause of the error.
23:11:10 <nrb23> it looks like you can do it with exestential types
23:11:18 <hpaste>  sjanssen pasted "use RULES for your own optimizations" at http://hpaste.org/586
23:11:19 <nrb23> >  data ShowH = forall s. Show s => SH s
23:11:19 <nrb23>  
23:11:19 <lambdabot>  Parse error
23:12:05 <sjanssen> kc5tja: ^^^
23:12:15 <nrb23> sjanssen: do you think that would actually make it faster?
23:13:08 <sjanssen> nrb23: I have no idea
23:13:09 <nrb23> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#The_forall_keyword
23:13:11 <lambdabot> http://tinyurl.com/f9umb
23:13:25 <sjanssen> I just wanted to demonstrate that it can be done, and that it's fairly easy
23:13:41 <nrb23> sjanssen: ahh, well done with that part ;->
23:14:57 <quicksilver> kc5tja: there are a number of ways of defining heterogenous lists
23:15:01 <quicksilver> kc5tja: HList is one approach
23:15:11 <quicksilver> It's Normally Not What You Really Want Though (TM)
23:15:53 <kc5tja> sjanssen: Cool -- it's almost like a macro.  :)
23:16:02 <kc5tja> only not.
23:16:49 <kc5tja> quicksilver: When I want a list of "things," they usually are of the same type in the sense that they all expose a consistent interface.  But they aren't all necessarily the same type as far as the compiler is concerned.
23:17:03 <kc5tja> quicksilver: btw, Billy wants to know if he can have your e-mail address.  :)
23:17:13 <quicksilver> kc5tja: it's the same as it always was
23:17:16 <quicksilver> kc5tja: jules@jellybean.co.uk
23:17:34 * quicksilver is proud of having held onto an email address for 11 years
23:17:40 <kc5tja> Hahaha
23:18:09 <quicksilver> kc5tja: well the type-safest thing to do is embed them in a convenient container type, IMO
23:18:34 <quicksilver> but it is possible to do, essentially  [ (exists a . Ord a => a) ]
23:18:35 <kc5tja> quicksilver: Example?
23:18:53 <quicksilver> higher rank types cause pain to the inferrer, though
23:19:58 <quicksilver> kc5tja: define an algebraic datatype. data ThingsWhichGoNi = OneSortOfNi foo | AnotherSortOfNi bar
23:20:32 <kc5tja> Right.  And now you can use [ThingsWhichGoNi] to express the list.
23:20:35 <quicksilver> then you make a typeclass which goes with it
23:20:40 <quicksilver> to 'cast' things into the type
23:21:14 <kc5tja> nrb23: ^^ This is what I was talking about.
23:21:35 <kc5tja> Now, the problem is, though, is nrb23's point about them not being dynamic types is true.
23:21:48 <kc5tja> Suppose we define Ta, Tb, and Tc, and have a type class for all three types.
23:21:49 <quicksilver> class NiiAble a where castToNii :: a -> ThingsWhichGoNi
23:22:10 <quicksilver> instance NiiAble Foo where castToNii f = OneSortOfNi f
23:22:16 <kc5tja> Then someone comes along and defines Td, Te, and Tf *after* the program is compiled.
23:22:23 <quicksilver> agreed
23:22:27 <quicksilver> then you can't do that
23:22:34 <kc5tja> But that's what needs to be done.
23:22:52 <quicksilver> then you need HList, or a type-safe wrapper around HList
23:22:56 <quicksilver> or a higher-rank type solution
23:23:12 <quicksilver> or you roll your own
23:23:24 <quicksilver> remember new instances can be defined later
23:23:33 <kc5tja> Except, so far as I can tell, there is no way to roll one's own using Haskell-provided constructs.
23:23:46 <quicksilver> the new instances would have to define some way to 'pack' and 'unpack' the new types into a common storage format
23:23:51 <quicksilver> which you could then put into a list
23:24:05 <quicksilver> (the common storage format could be as simple as serialising to string, you can have a type-checking wrapper around it)
23:24:35 <nrb23> well, in my case I could just use Binary.Get and Binary.Put
23:24:48 <quicksilver> right, Binary is one example of a common storage format
23:25:01 <nrb23> but I think that would probably be a bit slow for my purposes
23:25:06 <quicksilver> I think it might be true that haskell modules are a bit hard to extend in this direction
23:25:11 <kc5tja> But isn't all this marshalling to and fro going to take more time than necessary?
23:25:18 <quicksilver> (the direction of 'extensible to new datatypes')
23:25:59 <quicksilver> the new Binary stuff is pretty fast
23:26:08 <quicksilver> but I'm not sure that's really the point
23:26:10 <kc5tja> My monitor is really wigging out.
23:26:14 <quicksilver> it's 'clunky' somehow :)
23:26:37 <sjanssen> what exactly is the problem here?
23:26:47 <kc5tja> It's either because we've got some nasty lightning nearby, someone's really dinking around with the power, or my monitor is about to go.  :/
23:26:49 <nrb23> I suppose if I only need to select one particular bit of data, the binary wouldn't be problematic
23:27:10 <nrb23> sjanssen: it's not really a "problem"
23:27:18 <nrb23> sjanssen: I'm just looking for the best way to represent my data
23:27:40 <kc5tja> sjanssen: Post-compilation extensibility (aka, "open polymorphism" in traditional OO-speak)
23:28:40 <nrb23> of course, it's all academic for me at the moment.. I'm not planing on implementing plugins for this code anytime soon
23:31:10 <quicksilver> I believe you can do what you want with higher-rank types
23:31:17 <quicksilver> you can also do it with Typable and Dynamic
23:31:39 <quicksilver> personally I 'feel' that that's ugly, but I could be misrepresenting it
23:32:08 <quicksilver> in a real application, I probably wouldn't actually make Td Te and Tf new types
23:32:17 <quicksilver> I'd design Ta in the first place to be extensible
23:32:30 <quicksilver> but of course it does depend on all sorts of details
23:32:38 <kc5tja> But
23:32:51 <kc5tja> defining Td, Te, and Tf, by definition, *is* extending Ta.
23:32:58 <quicksilver> anyhow I have a bus to catch. Maybe you'll find a higher-rank guru in a bit to give a neater solution
23:33:10 <kc5tja> Hehe
23:33:13 <kc5tja> Not I -- I'm going to bed.  :)
23:33:20 <nrb23> well, it's late here, and I should go to bed as well
23:33:38 <quicksilver> kc5tja: there is a subjective decision to be made about what kinds of things need to be different types, at the type-system level, and what can be different values of the same type (for the compiler's purposes)
23:35:38 <nrb23> well, I'm off to bed
23:35:45 <nrb23> thanks for the excellent discussion
23:40:08 <quicksilver> kc5tja: if you're still there, I found a good page on the higher-rank method
23:40:12 <quicksilver> kc5tja: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
23:40:15 <lambdabot> http://tinyurl.com/f9umb
23:41:20 <quicksilver> kc5tja: the ShowH example is pretty much exactly what nrb23 was after
