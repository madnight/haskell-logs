00:00:14 <goltrpoat> zarvok:  alrighty.  sorry if i'm beating a dead horse here.
00:00:26 <uccus> mauke: I protest :D that's not the reason to introduce bind
00:00:32 <newsham> you all use lambdas instead of "let", right?
00:00:42 <newsham> or do you approve of let-bindings but not do-bindings?
00:00:44 <mauke> uccus: really?
00:00:54 <goltrpoat> i don't disapprove of do :)  jesus.
00:01:17 <uccus> mauke: your argument (that particular one) would fail for multiple binds, right? ;)
00:01:26 <mauke> uccus: huh?
00:01:30 <zarvok> goltrpost: I guess it's not bind notation in particular that is a problem.  The wikibook, for example, has a _great_ tutorial that uses binds.  tutorials with too much theory, rather, are what I think can be offputting.  Perhaps I misinterpreted what you meant by revealing the underlying structure
00:01:36 <newsham> i wouldnt teach a python programmer to use lambdas instead of let.  I would teach that approach if I was teaching lambda calculus and wanted to formalize bindings before giving sugar.
00:01:43 <uccus> for succeesive binds, do notation looks easier
00:01:56 <newsham> but I think a practiced programmer can handle "let" without going into implementation details
00:02:00 <mauke> uccus: sure, but it doesn't tell me what's really going on
00:02:15 <goltrpoat> you know.. LC with let is a good thing, right.
00:02:20 <mauke> and why do { putStr(getLine) } doesn't work
00:02:24 <goltrpoat> qualitatively speaking.
00:02:25 <DannoHung> Let made more sense to me after I read about how it could be emulated with functions in SICP
00:02:33 <uccus> mauke: I am here arguing for (>>=) as the way to teach newbies... not against it
00:02:58 <newsham> try explaining:   randomIO >>= (\x -> randomIO >>= (\y -> return (x + y))   to a beginner.
00:03:06 <DannoHung> do{ x <- getLine; putStr(x)}, right?
00:03:07 <newsham> you know how long I staired at that to figure out whats goin gon?
00:03:20 <mauke> newsham: easy if you know IO
00:03:24 <dons> no need for the extra parens , DannoHung
00:03:29 <DannoHung> ah
00:03:29 <mauke> DannoHung: getLine >>= putStr :-)
00:03:31 <dons> so, do x <- getLine ; putStr x
00:03:37 <newsham> it never occurred to me until much much later that the lambdas were just binding names to values in an expression
00:03:39 <dons> the bot can even work this otu:
00:03:42 <goltrpoat> zarvok:  oh im just saying that if you put a tv in front of someone for the first time, you may want to teach them how to use the remote.
00:03:47 <dons> ?. pl undo do x <- getLine ; putStr x
00:03:48 <lambdabot> putStr =<< getLine
00:03:49 <dons> :)
00:03:57 <newsham> mauke: i didnt have problems with the IOs, it was the lambdas.
00:04:17 <mauke> newsham: whoa. what's so hard about lambda?
00:04:18 <newsham> "what does this function (\y -> return (x + y)) mean?  where the heck does x come from!@#?"
00:04:24 <goltrpoat> newsham:  ?
00:04:27 <uccus> oh DannoHung, it might do you some good to know the =<< operator (which is >>= the other way)
00:04:28 <mauke> newsham: oh, closures
00:04:32 <newsham> yup
00:04:37 <zarvok> goltrpoat: heh, I'm not sure that's fair, you can use the monads just as well with the do notation
00:04:38 <dons> ?src (=<<)
00:04:39 <lambdabot> f =<< x = x >>= f
00:04:47 <dons> i love this language
00:04:55 <zarvok> amen
00:04:55 <newsham> if the truth can be told so as to be understood, it will be believed.
00:05:03 <mauke> newsham: I already knew about closures from Perl before I started learning Haskell, so that wasn't a problem
00:05:08 <sieni> ?src (>>=)
00:05:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:05:15 <dons> its in a monad, so,
00:05:19 <dons> ?src Either (>>=)
00:05:20 <lambdabot> Left  l >>= _ = Left l
00:05:21 <lambdabot> Right r >>= k = k r
00:05:23 <sieni> that explains a lot about americans
00:05:25 <newsham> mauke: me too, but for some reason the expressoin was still very confusing
00:05:29 <dons> ?src Maybe (>>=)
00:05:30 <lambdabot> (Just x) >>= k      = k x
00:05:30 <lambdabot> Nothing  >>= _      = Nothing
00:05:34 <newsham> perhaps i wasnt as practiced in closures then.
00:05:39 <mauke> newsham: my main problem was understanding how to do IO in a pure language (and laziness)
00:05:46 <dons> sieni: yeah, you have to pick the instance you want to see
00:05:52 <DannoHung> newsham: Now, in that Random example you had, how do you get the plain value out of the monad created by return(x + y)?  Like, it would be a RandomMonad, right?  Do you need to wrap it in another monad or something?
00:06:14 <newsham> danno: thats one of the goals of the IO monad.  you cant get the value out!  (some minor exceptions aside).
00:06:17 <mauke> DannoHung: no, it would be in IO
00:06:44 <uccus> DannoHung: once you put it inside the IO monad, you can't get it out. why?
00:06:45 <goltrpoat> LC really didn't cause me any problems when i started out (after a month long crash course in scheme -- philippa kept talking about haskell, and i figured i'd see what all the fuss was about)
00:06:48 <newsham> your entire program must be one IO action.  and you can use do-blocks (or bind) to combine together many small IO actions into that oen big IO action.
00:06:57 <uccus> I mean, what's the motivation? what do you think?
00:07:02 <DannoHung> I don't think I associated Random and IO properly before...
00:07:06 <newsham> one of your building blocks is "print x".   so you could use that to make the value get printed.
00:07:07 <goltrpoat> the only real problem i had was just having to think differently, and design differently
00:07:29 <newsham> main = do { x <- randomIO; y <- return (x + 3); print y }
00:07:38 <mauke> DannoHung: there's a hidden global random number generator. you can access it with IO actions.
00:07:40 <newsham> (note: you can use a let instead of the "return" in the second line)
00:07:42 <mauke> (randomIO)
00:08:05 <DannoHung> But you can't carry the result of the random number generator anywhere else in the program...
00:08:16 <DannoHung> Right?
00:08:25 <newsham> danno: when using randomIO the state of the RNG gets carried "in the background" for you
00:08:28 <mauke> sure you can, you just have to put the "rest of the program" in a do block
00:08:30 <newsham> as part of the "IO" state.
00:08:49 <newsham> the next tme you make use of the randomIO action you get a new value
00:08:53 <goltrpoat> or thread it into the "rest of the program"
00:09:06 <newsham> main = do { x <- randomIO; y <- randomIO; printf "%d %d %d" x y (x+y) }
00:09:19 <mauke> DannoHung: btw, there's a bit of confusion here regarding the meaning of "result of the random number generator"
00:09:28 <DannoHung> mauke: Hmmm... Sooo, the randomness tends to end up pretty close to the top of a program.  There aren't any libraries that use Random numbers except by being seeded from the top level program.
00:09:31 <mauke> DannoHung: did you mean the value returned by randomIO, or the RNG itself?
00:09:37 <DannoHung> mauke: value
00:09:52 <newsham> I think danno saw a tutorial using the traditional functional Random functions and perhaps the state monad to make it easier to use
00:10:39 <mauke> DannoHung: pretty much, yes. a function that has the type Int -> Int will always return the same value when called with the same argument.
00:10:46 <mauke> it can't use random data
00:11:35 <DannoHung> I think I've got it then, and I think newsham is right about the tutorial I saw.
00:12:07 <mauke> things get more complicated when you create your own RNGs and pass them around
00:12:19 <DannoHung> I can imagine.
00:12:29 <mauke> it's usually sufficient to use the predefined RNG in IO
00:12:30 <newsham> > runState (do { (x,g) <- gets random; put g; (y,g') <- gets random; put g'; return (x+y) } (mkStdGen 3)
00:12:31 <lambdabot>  Parse error
00:12:37 <newsham> > runState (do { (x,g) <- gets random; put g; (y,g') <- gets random; put g'; return (x+y) }) (mkStdGen 3)
00:12:38 <lambdabot>  (399837179,1759534916 1872071452)
00:12:45 <mauke> yeah, like that :-)
00:13:58 <newsham> > let sRand = (do { (x,g) <- gets random; put g; return x}) in runState (do { x <- sRand; y <- sRand; return (x+y) }) (mkStdGen 3)
00:14:00 <lambdabot>  (399837179,1759534916 1872071452)
00:14:16 <DannoHung> runState is a function for lambda bot?  And mkStdGen 3 provides a seed value?
00:14:30 <mauke> mkStdGen 3 creates a new RNG from the seed 3
00:14:32 <newsham> runState is something that runs an action from the State monad.
00:14:39 <mauke> @index runState
00:14:39 <lambdabot> Control.Monad.State, Control.Monad.RWS
00:14:59 <newsham> the State monad lets you use "get" and "gets" to get the current state, and "put" to set a new value for state.
00:15:21 <newsham> in my example I put a random generator into the state.
00:15:29 <mauke> basically, the State monad contains a single hidden variable you can read/write
00:15:36 <newsham> and used "gets random" to pull out a value and a new generator and "put" to put back the new generator (for next time)
00:15:51 <mauke> this hidden variable contains a RNG in newsham's example
00:16:02 <newsham> my initial state was (mkStdGen 3)  which is a generator seeded with '3'
00:16:22 <mauke> @type random
00:16:24 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
00:16:34 <newsham> "gets" gets the state and then applies a function to it.
00:16:48 <newsham> I did "gets random" which got the state (a generator) and ran "random g" with that state (g)
00:17:10 <newsham> which returned (Int, newgenerator)
00:17:13 <mauke> 'random' takes a RNG, and returns a random number and a new RNG
00:17:31 <DannoHung> Cool, I see how it works now.
00:17:33 <newsham> sRand = (do { (x,g) <- gets random; put g; return x})
00:17:40 <DannoHung> The other Random monad's hella easier
00:17:58 <newsham> so "sRand" is a state action that when executed, results in a new value, while behind the scenes updating the generator for next time
00:18:14 <newsham> sRand is sort of like "randomIO".
00:18:20 <mauke> IO is State on steroids
00:18:22 <DannoHung> That return wraps x with the generator, right?
00:18:23 <newsham> except "randomIO" stores its state with the other IO state
00:18:25 <bos> wow, the front page of programming.reddit.com is 1/3 haskell right now.
00:18:47 <newsham> the "return x"   sets the result of the action to "x"
00:19:28 <newsham> the state monad behind the scenes keeps track of two things, the resulting value and the state.
00:19:52 <newsham> a state action is basically something that takes the current state and maps that two a new state and a result
00:20:03 <newsham> and of course do-blocks (or binds) cmbine those actions together
00:20:15 <newsham> > runState (return 3) 1
00:20:16 <lambdabot>  (3,1)
00:20:20 <sieni> coolest misspelling of "to" ever
00:20:32 <mauke> > return (return 42) :: Maybe [Int]
00:20:33 <lambdabot>  Just [42]
00:20:35 <newsham> > runState (do { x <- get; put 5; return (x+1) }) 1
00:20:36 <lambdabot>  (2,5)
00:20:47 <newsham> see, there we started with a state of '1'
00:21:04 <newsham> then we got that state into "x", set the new state to '5' and set the resul tto 1+1 = 2.
00:21:07 <newsham> and ended up with (2,5)
00:21:36 <DannoHung> Lemme try this... might be silly...
00:21:43 <newsham> s'ok, silly's fine!
00:22:02 <mauke> > tails "silly"
00:22:03 <lambdabot>  ["silly","illy","lly","ly","y",""]
00:22:03 <DannoHung> > runState (do { x <- get; put x*2; return (0)}) 4
00:22:04 <lambdabot>   add an instance declaration for (Num (State s ()))
00:22:14 <newsham> parenthesis around (x*2)
00:22:14 <mauke> DannoHung: missing parens around x*2
00:22:17 <DannoHung> Oops
00:22:28 <newsham> otherwise it wants to  (put x) * 2
00:22:34 <DannoHung> > runState (do { x <- get; put (x*2); return (0)}) 4
00:22:36 <lambdabot>  (0,8)
00:22:45 <DannoHung> Shweet
00:22:48 <newsham> you're coding with state!
00:23:07 <DannoHung> Hah hah!  Now we're cooking with isolated imperativeness!
00:23:09 <newsham> gets is like get but with an added function.
00:23:12 <mauke> > runState (do { modify sqrt; return "your mom" }) 2
00:23:13 <lambdabot>  ("your mom",1.4142135623730951)
00:23:21 <newsham> > runState (do { x <- gets (+ 1); return x } 4
00:23:22 <lambdabot>  Parse error
00:23:26 <newsham> > runState (do { x <- gets (+ 1); return x }) 4
00:23:27 <lambdabot>  (5,4)
00:23:46 <newsham> mauke used another interesting one called "modify"
00:23:57 <newsham> which reads the state, runs it through a function, and puts it back
00:24:14 <mauke> modify f = do { x <- get; put (f x) }
00:24:17 <newsham> so he started with state of 2 and ended up with 1.414...
00:24:24 <DannoHung> Woah... okay.  I've got Monads now because I think I just had an initial realization about what it tells you to do about your program structure.
00:24:32 <newsham> yup!  thats the great thing, you can build your own things, like how mauke defined modify
00:24:43 <DannoHung> It's like staring into the face of God...
00:24:57 <DannoHung> Or... some other super natural entity with a beard...
00:24:57 <newsham> did he blink?
00:25:13 <DannoHung> Perhaps, Abraham Lincoln... on Mars.
00:26:13 <DannoHung> I've gotta thank you guys.  You helped push me over the edge into understanding.
00:26:41 <newsham> danno: its always fun :)
00:27:08 <newsham> here's a really cool thing
00:27:43 <newsham> liftM func act = do { x <- act; return (func x) }
00:28:01 <newsham> that works for any monad.  any time you see that pattern in your code you can use liftM.
00:28:04 <DannoHung> Ah, lift, to make a function work with a monad, right?
00:28:10 <newsham> there are lots of generic patterns you can pull out of your code
00:28:15 <newsham> and lots are already made for you.
00:28:15 <dons> bos: re your config file parser, I usually just use read/show to do config files, using a record type
00:28:21 <newsham> > liftM (+ 3) (Just 5)
00:28:23 <lambdabot>  Just 8
00:28:30 <dons> so the text would be something like: Config { x = "foo" ; y = "bar" }
00:28:42 <mauke> recently I saw this code in ##c: int cloexec(int fd) { int f = fcntl(fd, F_GETFD); if (f != -1) { f = fcntl(fd, F_SETFD, f | FD_CLOEXEC); } return f; }
00:28:43 <newsham> thats the cool thing about abstraction.
00:28:54 <mauke> I felt the instinctive urge to use a monad :-)
00:28:59 <DannoHung> How do you do that define thing... I'd like to see the liftM code
00:29:07 <mauke> @src liftM
00:29:08 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:29:27 <newsham> ?src liftM2
00:29:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:29:37 <newsham> > liftM2 (+) (Just 3) (Just 5)
00:29:39 <lambdabot>  Just 8
00:29:47 <newsham> > liftM2 (+) (Just 3) Nothing
00:29:48 <lambdabot>  Nothing
00:29:58 <DannoHung> Cooooool
00:30:00 <mauke> yay, primitive exceptions (a.k.a longjmp)
00:30:43 <DannoHung> Hmm... I wonder what Haskell for embedded devices would be like (referencing the C code)
00:31:22 <newsham> > (+ 1) `fmap` (Just 3)
00:31:23 <lambdabot>  Just 4
00:31:37 <newsham> > (+) `fmap` (Just 5) `fmap` (Just 8)
00:31:38 <lambdabot>      Expecting a function type, but found `f b'
00:31:39 <lambdabot>       Expected type: a -> b
00:31:39 <lambdabot>  ...
00:31:45 <mauke> cloexec fd = do { f <- fcntl fd fGetfd; fcntl fd fSetfd (f .|. fdCloexec) }, except not
00:31:54 <newsham> hmm.. nevermind :)
00:32:12 <mauke> > return (+) `ap` Just 5 `ap` Just 8
00:32:13 <lambdabot>  Just 13
00:32:31 <newsham> thx :)
00:33:16 <DannoHung> @src return
00:33:17 <lambdabot> Source not found. Do you think like you type?
00:33:22 <newsham> ?src [] return
00:33:23 <lambdabot> return x    = [x]
00:33:23 <DannoHung> Hmmm
00:33:26 <DannoHung> Ah
00:33:31 <newsham> ?src (Maybe Int) return
00:33:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:33:35 <mauke> @src Maybe return
00:33:35 <lambdabot> return              = Just
00:33:45 <newsham> ?src State return
00:33:46 <lambdabot> Source not found. You type like i drive.
00:33:50 <mauke> @src IO return
00:33:50 <lambdabot> return x    = returnIO x
00:33:56 <mauke> gee, thanks
00:34:07 <DannoHung> Right, what do you call those monads that are defined by return?  Neutral?  Uuhhh... I dunno
00:34:20 <newsham> "containers"?
00:34:22 <newsham> *shrug*
00:34:23 <DannoHung> I'm just trying to write a little something up to explain monads to myself... helps cement the learning, y'know?
00:34:24 <mauke> that's not what a monad is, actually :-)
00:34:48 <newsham> http://www.haskell.org/haskellwiki/Monads_as_Containers
00:34:50 <lambdabot> Title: Monads as containers - HaskellWiki
00:35:06 <mauke> DannoHung: trivial action or unit, maybe?
00:35:15 <DannoHung> trivial unit sounds good to me.
00:36:01 <mauke> (some people call return "unit", right?)
00:36:09 <newsham> i like to think of it as two categories -- inert functions that will later be activated (IO, State, Reader, etc)  and  containers with values (Maybe, [])
00:36:12 <DannoHung> I think the International Organization of Pure Functional Programmers should decide on Monad nomenclature.
00:36:31 <newsham> inert functions with state/side effects.
00:38:12 <DannoHung> Huh... it's kinda funny how close Monads are to strict ADTs...
00:38:22 <newsham> once you have the general concept down, the main details to hone in on are 1) how do actions get combined by bind/do-blocks, 2) what does "return" mean, and 3) what other functions come along with the monad (like get/put for state)
00:38:56 <mauke> yeah, Monad is just a very generic interface for many different things
00:39:10 <newsham> ie for Maybe:  1) if one is Nothing, they'll all be Nothing, otherwise use the values,  2) return x makes Just x.  3) not much...
00:39:14 <mauke> the interesting stuff is the part that's not shared by all other monads
00:40:21 <vincenz> dons: ping
00:40:24 <vincenz> @localtime dons
00:40:26 <lambdabot> Local time for dons is Thu Feb  1 19:35:45 2007
00:43:20 <vincenz> dcoutts: ping
00:44:02 <uccus> > return (+) `ap` Just 5 `ap` Just 8 `ap` Just 3
00:44:03 <lambdabot>   add an instance declaration for (Num (a -> b))
00:44:39 <mauke> heh
00:44:54 <mauke> (cryptic errors)++
00:45:12 <newsham> > (+) `fmap` Just 5 `ap` Just 3
00:45:14 <lambdabot>  Just 8
00:45:51 <newsham> uccus: too many args for + :)
00:45:53 <mauke> uccus: I have a file that makes that work (the result is Just 13)
00:46:46 <uccus> hehe, I just wanted to know how the compiler responds to such nonsense
00:47:02 <vincenz> \o/
00:47:06 <mauke> it's not necessarily nonsense
00:47:09 * vincenz had a paper accepted on 'fusion' for STL-sequence
00:47:34 <mauke> *Main> 1 2 3
00:47:34 <mauke> 1
00:47:40 <newsham> > let (+:) = liftM2 (+) in Just1 +: Just2 +: Just3 +: Just 4
00:47:41 <lambdabot>   Not in scope: data constructor `Just3'
00:47:42 <vincenz> ..s
00:47:46 <newsham> > let (+:) = liftM2 (+) in Just1 +: Just 2 +: Just 3 +: Just 4
00:47:47 <lambdabot>   Not in scope: data constructor `Just1'
00:47:50 <newsham> > let (+:) = liftM2 (+) in Just 1 +: Just 2 +: Just 3 +: Just 4
00:47:51 <lambdabot>  Just 10
00:48:49 <mauke> > liftM sum (sequence [Just 1, Just 2, Just 3, Just 4])
00:48:51 <lambdabot>  Just 10
00:49:09 <newsham> > Just (sum [1,2,3,4])
00:49:11 <lambdabot>  Just 10
00:49:23 <DannoHung> heh
00:49:27 <mauke> > return 10 :: Maybe Int -- OPTOMIZED
00:49:28 <lambdabot>  Just 10
00:49:29 <DannoHung> Does this thing do APL too?
00:49:32 <DannoHung> + 1 2 3 4
00:49:45 <DannoHung> Guess not
00:49:46 <mauke> no, but it can do unlambda IIRC
00:49:49 <DannoHung> :D
00:49:57 <dblhelix> vincenz: congratulations! is it available on line?
00:50:17 <vincenz> dblhelix: hmm, not yet, I have to rewrite it for the camera-ready version, and not sure what the copyright policy is
00:50:25 <newsham> www.unlambda.com?
00:51:11 <mauke> http://www.madore.org/~david/programs/unlambda/
00:51:17 <lambdabot> Title: The Unlambda Programming Language
00:51:31 <roconnor> @where unlambda
00:51:31 <lambdabot> http://www.madore.org/~david/programs/unlambda/
00:52:53 <vincenz> @tell dons If you happen to have a paper I can reference on the fusion stuff you did, that'd be great. I  had a paper accepted on a similar topic but then for c++/STL code
00:52:54 <lambdabot> Consider it noted.
00:54:12 <dons> vincenz: check my web page
00:54:13 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
00:54:22 <vincenz> dons: I did, it only states 3 papers afaict
00:54:30 <dons> yeah, and the last one is the fusion paper
00:54:44 <dons> that's what you were looking for?
00:55:08 <vincenz> dons: ah cool, I thought it was mostly on the bytestring stuff, I must've scanned too fast :)
00:55:11 <vincenz> yep
00:55:18 <vincenz> hmm, not submitted yet?
00:55:27 <dons> yeah its already been and gone!
00:55:33 <dons> won 'Most Practical Paper' :)
00:55:45 <vincenz> cool :)
00:55:46 <dons> ah, i forgot to push the update to the web page
01:05:05 <abz> >:t liftM const
01:05:13 <dons> :t liftM const
01:05:15 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> a1)
01:05:25 <abz> :t liftM2 const
01:05:27 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
01:05:38 <dons> code for free! :)
01:05:42 <dons> yay for higher order functions
01:06:02 <abz> before lambdot gave liftM2 (>>)
01:06:19 <abz> what command to you use?
01:06:26 <abz> pl?
01:06:31 <dons> ah yeah
01:06:37 <dons> ?pl liftM2 const
01:06:38 <lambdabot> liftM2 const
01:06:45 <dons> ?pl liftM const
01:06:46 <lambdabot> fmap const
01:06:51 <dons> heh
01:07:05 <abz> what is lambdot trying to do?
01:07:28 <dons> ?pl \x f y g -> y (f x) (g x) x
01:07:29 <lambdabot> flip =<< ((flip . (flip .)) .) . ap (flip . ((flip . ((.) .) . flip id) .) . flip id) (flip id)
01:07:34 <dons> ?pl \x f y g -> y (f x)
01:07:35 <lambdabot> (((const .) . flip id) .) . flip id
01:07:37 <abz> just find a simplier way
01:07:45 <dons> ?pl \x f y g -> f x
01:07:46 <lambdabot> ((const . const) .) . flip id
01:07:58 <dons> ?pl \x f y g -> y g
01:07:59 <lambdabot> const (const id)
01:08:33 <xerox> ?pl \f g x y -> f x (g y)
01:08:34 <lambdabot> flip . ((.) .)
01:08:39 <xerox> auhm.
01:08:41 <xerox> G'morning.
01:09:34 <abz> look there  http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS right
01:09:51 <xerox> ?pl \f g x -> f x (g x)
01:09:52 <lambdabot> ap
01:09:54 <xerox> ok.
01:10:31 <mauke> @pl \f g x -> f x >> g x
01:10:31 <lambdabot> liftM2 (>>)
01:10:47 <abz> :t liftM (>>)
01:10:49 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m a) -> m1 (m b -> m b)
01:11:10 <abz> that lifts a monad into a/the monad though....
01:11:29 <abz> can you do that?
01:11:51 <xerox> Yep.
01:12:01 <abz> can anyone give an example?
01:12:55 <abz> of when anyone would be crazy enough to use liftM2 (>>)
01:13:14 <dons> it seems a bit unusual. possibly useful for writing a monad transformer
01:13:40 <mauke> :t liftM2 (>>) show putStr
01:13:41 <lambdabot>     Couldn't match `[b]' against `IO ()'
01:13:42 <lambdabot>       Expected type: String -> [b]
01:13:47 <dons> > (liftM2 (>>)) (Just (Just 1))
01:13:48 <lambdabot>  Add a type signature
01:13:51 <mauke> :(
01:13:54 <dons> > (liftM2 (>>)) (Just (Just 1)) :: Maybe Int
01:13:55 <lambdabot>      Expecting a function type, but found `Maybe Int'
01:13:55 <lambdabot>       Expected type: Ma...
01:14:03 <dons> > (liftM2 (>>)) (Just (Just 1)) :: Maybe (Maybe Int)
01:14:04 <lambdabot>      Expecting a function type, but found `Maybe (Maybe Int)'
01:14:05 <lambdabot>       Expected ...
01:14:23 <dons> > (liftM2 (>>)) (Just (Just 1)) :: Maybe (Maybe Int -> Maybe Int)
01:14:24 <lambdabot>      Expecting a function type, but found `Maybe (Maybe Int -> Maybe Int)'
01:14:24 <lambdabot>   ...
01:14:27 <dons> too hard
01:14:29 <xerox> :t \ma1 ma2 -> do a1 <- ma1; a2 <- ma2; return (a1 >> a2)
01:14:31 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m1, Monad m) => m (m1 a) -> m (m1 b) -> m (m1 b)
01:14:32 <dons> :}
01:14:35 <xerox> hm
01:15:15 <xerox> ?type liftM2 (>>) putStr putStrLn "hi"
01:15:17 <lambdabot> IO ()
01:15:44 <dons> > liftM2 (>>) (Just 1) Just 7
01:15:45 <lambdabot>  Couldn't match `(->) t' against `Maybe'
01:15:52 <dons> > liftM2 (>>) Just Just 7
01:15:53 <lambdabot>  Just 7
01:15:54 <xerox> yes
01:16:14 <dons> > liftM2 (>>) const const 7
01:16:15 <lambdabot>  Add a type signature
01:16:18 <dons> heh
01:16:28 <mauke> :t liftM2 (>>) print putStr
01:16:30 <lambdabot> String -> IO ()
01:16:31 <dons> > liftM2 (>>) id id 7
01:16:32 <lambdabot>   add an instance declaration for (Num (m a))
01:16:43 <dons> :t liftM2 (>>) const const id
01:16:45 <lambdabot> forall b a. b -> a -> a
01:16:54 <dons> > liftM2 (>>) const const id 1 2
01:16:56 <lambdabot>  2
01:16:57 <mauke> > liftM2 (>>) id id "foo"
01:16:59 <lambdabot>  "foofoofoo"
01:17:20 <dons> > liftM2 (>>) const (flip const) id 1 2
01:17:21 <lambdabot>   add an instance declaration for (Num (t -> a))
01:17:34 <xerox> mauke: oh that's what I wanted to do.
01:17:43 <xerox> > liftM2 (>>) (flip replicate "abz") (const "abz") 3
01:17:44 <lambdabot>  "abzabzabz"
01:18:14 <pesco> Lemmih: Hi, I'm just trying out the new cabal-install and am running into trouble...
01:19:02 <abz> thanks guys.
01:19:18 <pesco> Lemmih: You here?
01:19:54 <Lemmih> pesco: Maybe. Looking for someone to blame?
01:20:00 <pesco> Lemmih: No. ;)
01:20:07 <vincenz> pesco: wrong answer
01:20:14 <Lemmih> Phew, then yes, I'm here.
01:20:48 <dons> heh
01:20:59 <dons> that's the open source spirit!
01:21:08 <pesco> I'm running into incompatibility problems.
01:21:30 <pesco> My example: XmlRpc depends on HaXml, but HaXml changed a module name -> breaks
01:22:14 <pesco> The old version which works is available in hackageDB but we need a way for cabal-install to know which one it needs.
01:22:20 <Lemmih> @seen xerox
01:22:21 <lambdabot> xerox is in #haskell-blah, #haskell-overflow and #haskell. I last heard xerox speak 4m 37s ago.
01:22:31 <xerox> Lemmih: are you looking for someone to blame?
01:22:37 <pesco> :)
01:23:03 <xerox> pesco: how do modules break the installation process?
01:23:23 <pesco> AFAICS, we should add a "can-replace:" field to .cabal where the author of HaXml could have made explicit the fact that 1.17 it's not backwards compatible with 1.13.2.
01:24:19 <pesco> xerox: Sorry for being to brief. XmlRpc imports module A (as it was in HaXml-1.13) and HaXml-1.17 changed the name of A to B.
01:24:45 <pesco> What do you guys think?
01:24:55 <dons> this whole in-the-kitchen-as-imperative-or-functional-thinking thread on -cafe is weird
01:24:56 <Lemmih> @seen bringert
01:24:56 <lambdabot> I saw bringert leaving #haskell 30m 18s ago, and .
01:26:25 <pesco> Is poking the author of every dependant of HaXml a viable answer to this?
01:26:26 <xerox> pesco: it may be the case that successful compilation should be one of the checks to be done on a package entering hackage? I'm not too sure.
01:26:52 <pesco> xerox: The problem is that it compiled fine at the time of _entry_ but breaks later!
01:27:19 <xerox> Ah, I see now.
01:28:08 <xerox> I don't think we impose any standard versioning mechanism, right?
01:28:22 <pesco> This is exactly what I was trying to avoid when I wrote my "ECT" article, but at a different level.
01:28:32 <dons> i guess the version of haxml that the other apps depend on is older than the version on hackage?
01:28:43 <dons> but that they just say: dep: haxml >= xy.z
01:28:45 <pesco> xerox: I don't think we do, and it would probably not be a good idea.
01:28:59 <xerox> dons: right.
01:29:00 <pesco> dons: Exactly. But what else could they say?
01:29:20 <pesco> dons: At the time of writing, there's no way of knowing at which point in the future your dependency will break.
01:29:22 <dons> haxml == x.y.z
01:29:25 <dons> since it will break later
01:29:37 <dons> so people should be conservative!
01:29:41 <dons> and only include those that are known to work
01:29:59 <dons> pesco: so the soln must be to roll back your haxml to an earlier version?
01:30:16 <pesco> dons: That would mean accumulating large numbers of different package versions on your system...
01:30:41 <pesco> dons: And make the sole existance of the ">=" operator for dependencies pointless.
01:30:48 <xerox> pesco: I think accumulating version is a plus, especially since they happen not to be backwards-compatible sometimes.
01:30:58 <Donner> Other systems does not allow to break backward compatibiltiy within the same major version.
01:31:01 <pesco> xerox: Then why does ">=" exist?
01:31:22 <xerox> It's for the lazy programmer!
01:31:23 <pesco> Donner: But that's a policy to impose on module authors -> Hard.
01:31:25 <xerox> Sigh.
01:31:36 <Donner> So a dep: haxml >= 1.35 means: Every version 1.x where x > 35.
01:32:17 <xerox> Donner: the author might break things in 1.36 anyway.
01:32:35 <norpan> do it like libtool then
01:33:36 <Donner> xerox: With respect to the interface this should not happen.
01:34:11 <pesco> My proposal would be to reinterpret ">=" as upwards compatibility as recorded by "can-replace:" fields instead of simple numeric comparison on version numbers.
01:34:18 <xerox> Maybe we could add a checkbox on the upload interface "does it break wrt backwards compatibility?"
01:34:27 <norpan> or do it even more fine-grained, specify exactly which functions and types are used :)
01:34:44 <pesco> xerox: That's exactly what I'm suggesting, but on the level of the .cabal file.
01:35:58 <xerox> pesco: a good place to discuss such proposal is on the cabal-devel ml.
01:35:59 <Donner> pesco: Do you really think, a new field will be better respected by the programm which does not handle version numbers correctly?
01:36:30 <pesco> Donner: No, but it would fail-safe. I.e. assume incompatibility unless otherwise specified.
01:36:44 <Donner> There is no technical solution to social problems.
01:37:16 <Donner> pesco: That are major version numbers for.
01:37:24 <pesco> xerox: Yes, you're right, of course.
01:38:03 <xerox> I must go, good luck.
01:38:28 <Donner> Change interface: update major number, add to the interface: update minor number, submit bugfixes: update subminor number.
01:39:41 <pesco> Donner: Everybody knows that. But the sad reality is that nobody does it that way. Probably because most people don't like to bump their major number with every incompatible change.
01:39:58 <pesco> Because the changes themselves can be pretty small.
01:40:25 <pesco> Like renaming a module to something more appropriate. Not every package has an Architecture Review Board behind its design.
01:41:25 <pejo> Why does it matter if your module is called 15.7 or 3.8 anyways?
01:41:52 <uccus> silly question: why do type constructors start with a capital letter but functions don't?
01:41:55 <pejo> (Re bumping the major version, I'm not saying people should break the API in minor releases).
01:42:02 <uccus> pejo: agreed
01:42:19 <Donner> uccus: historical reasons. It was just decieded to to so.
01:42:34 <uccus> can we drop it now? :D
01:43:28 <Donner> uccus: No it's considered as a major feature.
01:44:15 <uccus> think about it... if data boolean = true | false... for a function branch true = this, branch false = that... all the compiler needs to do is to check for boolean constructors, and if there is none, it's a variable
01:44:24 <Donner> uccus: Pattern matching is much more clear if contructors are clear different from names.
01:44:51 <Donner> Lifting this paradigma to types results in the actual behavior.
01:44:56 <rahikkala> Will my program break on Windows if I use '\n'?
01:45:06 <rahikkala> (as opposed to "\n")
01:45:24 <uccus> but I can't name my function GCD!
01:45:26 <pesco> rahikkala: What? If '\n' works, it will break regardless of platform.
01:46:08 <pesco> uccus: Correct. You can name it gcd.
01:46:23 <Donner> uccus: Can you see immediatly what is a pattern match and what is a name binding just from see the case expresseion? Yes. If you allow lower-letter-constructors: No.
01:47:17 <uccus> Donner: can you see immediately what is a pattern match and what is name binding in case your constructor is an operator? oh yes, variables can't contain +'s. silly me.
01:47:24 <Donner> uccus: You can name your function GCD. Use unicode and choose the similar glyphs from other alphabets.
01:47:34 <uccus> lol
01:48:35 <Donner> uccus: This technique is quite powerful and widely used in phishing attacks.
01:49:08 <uccus> but don't you all think the most sensible name for the successor function is 1+ and the most sensible constructor name for complex numbers is +i ... I hate symbols/letters discrimination!
01:50:58 <Eelis> uccus: i don't think 1+ is the most sensible name for the successor function, as i consider "successor" to be a more fundamental notion than "plus"
01:51:44 <mauke> > succ False
01:51:45 <uccus> what licence issues would I face if I replace the lex/parse layer of Haskell with something that does not impose uppercase/lowercase rules?
01:51:45 <lambdabot>  True
01:52:12 <uccus> mauke: that's the succ function from the Enum class, not the constructor of the naturals.
01:52:23 <Donner> uccus: None. Haskell is desigend to be modified.
01:52:41 <mauke> uccus: yes, the successor function
01:52:44 <uccus> so that is not "more fundamental" than plus, as Eelis said
01:52:56 <uccus> argh
01:53:24 <uccus> I'm sorry, I mean, the successor constructor should be named 1+ ... not the successor function form the Enum class. sorry.
01:53:55 <uccus> like data Natural = Zero | 1+ Natural
01:54:42 <Donner> 1+ belongs to Num, not Enum. 1+ suggest a group structure which is not provided by Enum.
01:55:00 <mauke> ew
01:55:04 <Donner> oops: Semigroup
01:55:13 <mauke> data N = 0 | S N
01:55:59 <uccus> yes, I'm not worry about Enum
01:56:09 <uccus> data Natural = 0 | 1+ Natural
01:56:11 <uccus> yay!
01:56:17 <mauke> no, 1+ is evil
01:56:29 <sieni> @type succ
01:56:30 <lambdabot> forall a. (Enum a) => a -> a
01:56:34 <uccus> mauke: if you say so :(
01:56:34 <Donner> uccus: Consider data Colour = Red | Green | Blue.  What should Red + Green mean?
01:56:39 <sieni> > succ 7
01:56:40 <lambdabot>  8
01:56:44 <sieni> > succ 7.5
01:56:45 <lambdabot>  8.5
01:57:10 <sieni> > pred 3.141
01:57:13 <lambdabot>  2.141
01:57:18 <uccus> there you go... Red + Green = Blue, by sieni's example
01:57:34 <Donner> uccus: Why?
01:58:05 <Eelis> using the symbol '+' in the definition of natural numbers is like getting ahead of one's self. one should *first* define the natural numbers, and *then* define + on them.
01:58:15 <uccus> oh.. red+green=green
01:58:31 <Donner> uccus: Please take a look to Ada's enumerations. They allow explicitly different binary representations.
01:58:44 <uccus> Eelis: agreed. but the name Succ sucks.
01:59:08 <Eelis> uccus: agreed. i'd prefer S like mauke suggested
01:59:10 <uccus> Donner: something like C's enums? but
01:59:14 <Donner> uccus: The next version of Ada is not named Ada'Succ for the same reason.
01:59:43 <Donner> uccus: No, quite different.
01:59:50 <uccus> yes, overall, is pleasing to look at data N = Z
01:59:57 <uccus> data N = Z | S N
02:00:20 <uccus> but that includes all the undefines, right?
02:00:29 <uccus> any way I can forbid them?
02:01:17 <roconnor> data N = O | S N
02:02:06 <uccus> figures.
02:02:07 <uccus> thanks.
02:03:27 <ttfh> Sorry if offtopic, but has anyone here heard of the companies "Sogeti" or "Ångpanneföreningen"?
02:20:09 <vermoos> salutations! i'm a complete haskell newbie witht a bit of prolog experience
02:20:32 <vermoos> anyone know why this   [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x**2+y**2==z**2 ]
02:20:45 <vermoos> produces only 4 solutions when there are 36?
02:21:04 <vermoos> like is there a forall quantifier i could use?
02:21:06 <sehute> vermoos: Welcome. As I soon learned when I first came here, there are many clever and friendly Haskellitos hanging around here.
02:21:16 <opqdonut> > [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x**2+y**2==z**2 ]
02:21:18 <lambdabot>  [[3.0,4.0,5.0],[4.0,3.0,5.0],[5.0,12.0,13.0],[6.0,8.0,10.0],[7.0,24.0,25.0],...
02:21:29 <Eelis> > length [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x**2+y**2==z**2 ]
02:21:30 <opqdonut> doesn't look like 4 solutions
02:21:31 <lambdabot>  40
02:22:21 <vermoos> sehute: i look forward to finding out what a monad is ;)
02:22:42 <dons> > length [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x**2+y**2==z**2 ]
02:22:44 <lambdabot>  40
02:22:54 <dons> vermoos: does that work for you?
02:22:55 <therp> your prolog initiation is visible from your code :)
02:22:59 <dons> heh
02:23:04 <therp> good morning btw :)
02:23:08 <sehute> vermoos: I'm still not sure, except that it has to do with spacesuites ;)
02:23:19 <dons> and apples!
02:23:25 <sehute> dons: and apples ;)
02:23:47 <sehute> vermoos: I like to think of monads as a kind of tag that can contain a value
02:23:58 <vermoos> dons: i get 4!
02:24:02 <sehute> vermoos: but I haven't completely gotten it yet
02:24:08 <mauke> monads are magic boxes
02:24:16 <vermoos> dons: i'm using hugs -98
02:24:17 <mauke> some boxes are more magic than others
02:24:28 <matthew_-> mmm. I'm far from sure I like that analogy
02:24:50 <vermoos> sehute: are we talking monad=="logical workflow" ?
02:25:05 <dons> right, vermoos, I also get only 4 in hugs!
02:25:06 <sehute> Monads can capture dirtyness and make them clean. Like the IO-monad can capture dirty input from dirty users, and make it appear as clean. ;)
02:25:10 <dons> Hugs.Base> [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x**2+y**2==z**2 ]
02:25:14 <dons> [[5.0,12.0,13.0],[10.0,24.0,26.0],[12.0,5.0,13.0],[24.0,10.0,26.0]]
02:25:16 <dons> rounding errors?
02:25:38 <mauke> try ^
02:25:51 <sehute> vermoos: monads are a kind of data-object that encapsulates values in a way that makes it hard to manipulate, but very beautiful in theory
02:26:09 <dons> yeah, that's better
02:26:11 <vermoos> dons: i guessed that hugs was getting a solution for, say 5, succeeding, and then skipping on to 6, hence the need for a forall quantifier
02:26:13 <dons> Hugs.Base> [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x^2+y^2==z^2 ]
02:26:29 <dons> vermoos: no, I don't think that's what's happening
02:26:35 <sehute> vermoos: but, you might want to check a monad-tutorial instead of listening to me, as I'm still a n00b on monads
02:26:37 <Ytinasni> > [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x^2+y^2==z^2 ]
02:26:39 <lambdabot>  [[3,4,5],[4,3,5],[5,12,13],[6,8,10],[7,24,25],[8,6,10],[8,15,17],[9,12,15],[...
02:26:45 <Ytinasni> > length [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x^2+y^2==z^2 ]
02:26:47 <lambdabot>  40
02:26:57 <matthew_-> > let (=~=) a b = abs ((abs a) - (abs b)) < 0.0000001 in [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x**2+y**2=~=z**2 ]
02:26:58 <lambdabot>   add an instance declaration for (Floating Bool)
02:26:59 <vincenz> > [(x,y,z) | let n = [1..5], x <-n, y_<-n, z<-n, x*2+y*y==z*z]
02:27:00 <lambdabot>   Not in scope: `y'
02:27:04 <vincenz> > [(x,y,z) | let n = [1..5], x <-n, y<-n, z<-n, x*2+y*y==z*z]
02:27:06 <lambdabot>  [(4,1,3)]
02:27:07 <dons> there's at least one difference in floating point rounding between hugs and ghc
02:27:13 <vincenz> > [(x,y,z) | let n = [1..50], x <-n, y<-n, z<-n, x*2+y*y==z*z]
02:27:13 <dons> Hugs.Base> 1.1 + 2.2
02:27:14 <dons> 3.3
02:27:15 <lambdabot>  [(4,1,3),(6,2,4),(8,3,5),(10,4,6),(12,1,5),(12,5,7),(14,6,8),(16,2,6),(16,7,...
02:27:18 <dons> > 1.1 + 2.2 -- raw machine
02:27:19 <lambdabot>  3.3000000000000003
02:27:22 <vincenz> there you go
02:27:23 <vincenz> pure ints
02:27:25 <vermoos> sehute: i'll keep asking - thanks
02:27:33 <vincenz> > 8*8+3*3
02:27:34 <lambdabot>  73
02:27:39 <vincenz> ack
02:27:46 <vincenz> > length [(x,y,z) | let n = [1..50], x <-n, y<-n, z<-n, x*x+y*y==z*z]
02:27:48 <lambdabot>  40
02:27:53 <sehute> vermoos: :-)
02:27:55 <roconnor> > length [[x,y,z]|x<-[1..50],y<-[x..50],z<-[y..50],x^2+y^2==z^2
02:27:55 <lambdabot>  Parse error
02:27:55 <vincenz> 40 solutions, pure ints, no floats
02:28:01 <matthew_-> > let (=~=) a b = abs ((abs a) - (abs b)) < 0.0000001 in [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],(x**2+y**2) =~= (z**2) ]
02:28:02 <roconnor> > length [[x,y,z]|x<-[1..50],y<-[x..50],z<-[y..50],x^2+y^2==z^2 ]
02:28:03 <lambdabot>  [[3.0,4.0,5.0],[4.0,3.0,5.0],[5.0,12.0,13.0],[6.0,8.0,10.0],[7.0,24.0,25.0],...
02:28:04 <lambdabot>  20
02:28:32 <roconnor> ooooh (**) is defined in terms of exp
02:28:38 <vincenz> > [(x,y,z) | let n = [1..50], x <-n, y<-n, z<-n, x*x+y*y==z*z]
02:28:39 <lambdabot>  [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(7,24,25),(8,6,10),(8,15,17),(9,12,15),(...
02:28:39 <matthew_-> that should give the same on hugs and ghc I'd guess
02:28:41 <roconnor> no wonder there are rounding issues.
02:28:41 <vincenz> use this one !
02:29:02 <vincenz> and actually, that's normal, you get duplicate solutions
02:29:14 <roconnor> @src (**)
02:29:15 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:29:25 <vincenz> > [(x,y,z) | x <- [1..50], y<-[x..50], z<-[y..50], x*x+y*y==z*z]
02:29:26 <Ytinasni> so, uh, what were you saying about 36 solutions?
02:29:27 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,2...
02:29:31 <matthew_-> > length . nub $ [(x,y,z) | let n = [1..50], x <-n, y<-n, z<-n, x*x+y*y==z*z]
02:29:33 <lambdabot>  40
02:29:33 <vincenz> > length [(x,y,z) | x <- [1..50], y<-[x..50], z<-[y..50], x*x+y*y==z*z]
02:29:35 <lambdabot>  20
02:29:38 <vermoos> vincenz: how do i deal with rounding errors on a dell inspiron 2200 w/ dapper drake?
02:29:41 <vincenz> matthew_-: you get dup solutions
02:29:47 <roconnor> x**y = exp(ln(x)*y) I think
02:29:49 <vincenz> matthew_-: (4,3,5), (3,4,5)
02:30:01 <matthew_-> ahh, I wasn't thinking clearly
02:30:03 <vincenz> vermoos: use integer arithmetic
02:30:08 <matthew_-> nub should be better at mindreading
02:30:10 <vincenz> correct one > length [(x,y,z) | x <- [1..50], y<-[x..50], z<-[y..50], x*x+y*y==z*z]
02:30:13 <matthew_-> @type nubby?
02:30:14 <lambdabot> parse error (possibly incorrect indentation)
02:30:17 <vincenz> notice how y starts at x
02:30:17 <matthew_-> @type nubBy
02:30:19 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
02:30:21 <vincenz> and z starts at y (logically)
02:30:34 <vincenz> but, that's still wrong
02:30:40 <vermoos> vincenz: doh! the first damn thing i learnt 'bout haskell !
02:30:40 <vincenz> correct one > length [(x,y,z) | x <- [1..50], y<-[x..50], z<-[y..100], x*x+y*y==z*z]
02:30:48 <vincenz> > length [(x,y,z) | x <- [1..50], y<-[x..50], z<-[y..100], x*x+y*y==z*z]
02:30:50 <lambdabot>  26
02:31:01 <vincenz> > sqrt(5000)
02:31:03 <lambdabot>  70.71067811865476
02:31:06 <vincenz> 26 solutions total
02:31:12 <vermoos> er...
02:31:12 <ivanm> Is there a tool which will read through Haskell source and offer possible improvements, etc?
02:31:16 <vincenz> since you lose some by cutting of z at only 50
02:31:21 <Ytinasni> > length [(x,y,z) | x <- [1..100], y<-[x..100], z<-[y..100], x*x+y*y==z*z]
02:31:22 <ivanm> Kind of like a Haskell version of this site: http://www.lahey.com/check.htm?
02:31:23 <lambdabot>  52
02:31:24 <lambdabot> Title: Lahey - Fortran Source Check
02:31:36 <vermoos> vincenz: can i cast x, y and z as Integer instead of Int?
02:31:52 <vincenz> Ytinasni: you want to bring the z up to 1.5*max-range x or y
02:32:01 <vermoos> [[x,y,z]|x<-[1..50],y<-[1..50],z<-[1..50],x**2+y**2==z**2 ]
02:32:01 <vincenz> vermoos: Integer is the std
02:32:12 <vermoos> vincenz: so why the rounding errors?
02:32:18 <vincenz> @type (**)
02:32:20 <lambdabot> forall a. (Floating a) => a -> a -> a
02:32:21 <Ytinasni> vincenz: it's too late at night for math like that :)
02:32:31 <mauke> @type (^)
02:32:33 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
02:32:35 <matthew_-> it's morning!
02:32:47 <vermoos> moin
02:33:08 <vermoos> math is easier in haskell :)
02:33:11 <matthew_-> mmm. the int version should be much much faster than the floating one too. As well as more accurate
02:33:17 <roconnor> vermoos: x**y is probably defined to be exp(ln(x)*y)
02:33:45 <roconnor> the exp and ln functions will introduce rounding errors.
02:34:06 <roconnor> > 0**0
02:34:07 <matthew_-> on the grand list of programming dos and don'ts, "avoid floating-point like the plague" must be up near the top.
02:34:07 <lambdabot>  1.0
02:34:13 <roconnor> hmm
02:34:26 <roconnor> > exp(ln(0))
02:34:27 <lambdabot>   Not in scope: `ln'
02:34:32 <roconnor> > exp(log(0))
02:34:34 <lambdabot>  NaN
02:34:40 <vincenz> > NaN ** NaN
02:34:41 <lambdabot>   Not in scope: data constructor `NaN'
02:34:52 <roconnor> well, so much for my theory.  Maybe 0**0 is special cased?
02:35:02 <vincenz> meejbie
02:35:15 <ivanm> By default, x ^0 == 1
02:35:15 <mauke> > 0 ** (0 :+ 0)
02:35:16 <lambdabot>  NaN :+ NaN
02:35:19 <vermoos> the *solution* : replace y**2 with y**y and i get 40 solutions
02:35:21 <ivanm> > log (exp 0)
02:35:22 <lambdabot>  0.0
02:35:36 <matthew_-> oh yes, that's a point. In some program, I want to use infinity as an upper bound. Is there anyway I can indicate this other than something like (1/0) ?
02:35:46 <roconnor> > 0.000001**0.000001
02:35:48 <lambdabot>  0.9999861845848758
02:36:29 <mauke> > iterate (join (**)) 0.0000000000001
02:36:30 <lambdabot>  [1.0e-13,0.9999999999970066,0.9999999999970066,0.9999999999970066,0.99999999...
02:36:48 <ivanm> :hoogle isInfinite
02:36:55 <ivanm> @hoogle isInfinite
02:36:55 <lambdabot> Prelude.isInfinite :: RealFloat a => a -> Bool
02:37:02 <matthew_-> > map (1-) $ iterate (join (**)) 0.0000000000001
02:37:04 <lambdabot>  [0.9999999999999,2.993383318994347e-12,2.993383318994347e-12,2.9933833189943...
02:37:05 <ivanm> Is that what you want matthew_?
02:37:23 <matthew_-> ivanm: no. hang on, I'll check the code
02:37:51 <vincenz> @src (**)
02:37:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:39:35 <ivanm> matthew_: well, its from the preclude, so I guess its built in.  Then again, I haven't used Haskell for long so what would I know ;)
02:41:26 <mauke> @src Double (**)
02:41:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:43:50 <roconnor> Perhaps the problem is that (**) is an element of a typeclass
02:43:56 <roconnor> @src (>>=)
02:43:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:44:16 <roconnor> @src Maybe (>>=)
02:44:22 <lambdabot> (Just x) >>= k      = k x
02:44:24 <lambdabot> Nothing  >>= _      = Nothing
02:44:26 <roconnor> oh wow
02:44:32 <roconnor> @botsnack
02:44:33 <lambdabot> :)
02:44:40 <roconnor> lambdabot++
02:44:43 <dons> @src IO (>>=)
02:44:44 <lambdabot> m >>= k     = bindIO m k
02:44:50 <dons> @src bindIO
02:44:51 <lambdabot> bindIO (IO m) k = IO ( \ s ->
02:44:51 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
02:44:54 <dons> tada!
02:45:12 <roconnor> I should use unIO more often
02:45:17 <roconnor> ;)
02:45:23 <ivanm> dons: since you seem to be online, can you give me a hand working out why lambdabot stopped working recently?
02:45:51 <mauke> @src unIO
02:45:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:46:15 <dons> ah, ivanm ! I have you mail in my inbox
02:46:30 <ivanm> OK, wasn't sure if you got it or not.  Any ideas?
02:46:32 <dons> ivanm, remove the State/seen file
02:46:43 <dons> the binary lib changed the state file format
02:46:53 <dons> so it has to be either converted or removed
02:47:46 <ivanm> dons: That worked, thank! It was working for a while and I didn't update it or anything before it suddenly stopped, but now its back to normal again!!!
02:47:48 <ivanm> @botsnack
02:47:49 <lambdabot> :)
02:50:37 <ivanm> dons: is it possible to get a more meaningful list of what all the plugins actually do and how to use them?  For example, what is the bf plugin meant to do?
02:50:42 <matthew_-> lambdabot ? where are you?
02:50:49 <roconnor> @google hemimetric
02:50:52 <lambdabot> http://en.wikipedia.org/wiki/Hemimetric_space
02:51:03 <matthew_-> oh. I'm ignoring it. doh!
02:51:10 <matthew_-> silly irc client...
02:52:07 <mauke> @bf ++++++++++++++++++++++++++++++++[.+]
02:52:08 <lambdabot>   !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk...
02:52:37 <dons> ivanm, the 'help' plugins
02:52:40 <dons> @help pl
02:52:41 <lambdabot> pointless <expr>. Play with pointfree code.
02:52:47 <dons> well, that's about it :)
02:53:17 <roconnor> I suppose we could create more detailed help on the wiki.
02:53:50 <ivanm> dons: OK, that's what I was looking for!  still doesn't explain what the "yhjulwwiefzojcbxybbruweejw" command is meant to do (I assume its just random, stupid comments?)
02:54:10 <mauke> @yhjulwwiefzojcbxybbruweejw
02:54:11 <lambdabot> "\""
02:54:14 <mauke> oh, v
02:54:16 <nmessenger> ivanm: dons told me it's an in-joke
02:54:17 <norpan> it's an internal joke
02:54:23 <dons> check the src, its a joke reference to an old lambdabot bug
02:54:24 <mauke> @v
02:54:25 <lambdabot> "\""
02:54:25 <dons> :)
02:54:28 <norpan> literally internal
02:54:36 <ivanm> and what was "v" meant to be?
02:54:44 <dons> you used to be able to hook into an internal symbol, 'v', inside the @run plugin
02:54:54 <dons> which mystied many for a long long time
02:55:00 <dons> mystified
02:55:09 <mauke> > let v = show v in v
02:55:11 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:55:17 <dons> then i fixed that. but we remember that famous bug to this day, via the @v plugin
02:55:29 <ivanm> OK
02:55:32 <nmessenger> > fix show
02:55:33 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:55:37 <dons> the first fix to the @v problem was to use a new symbol, "yhjulwwiefzojcbxybbruweejw"
02:55:41 <dons> but someone worked that out too :)
02:55:59 <dons> so, yes, lambdabot has a cultural history :)
02:56:09 <ivanm> so then what? you disabled that "bug"?
02:56:11 <mauke> > let v = show (head v) in v
02:56:12 <lambdabot>  Exception: <<loop>>
02:56:19 <dons> yeah, it has been fixed properly :)
02:57:26 <ivanm> OK, so I asked this earlier, but is there a code check/profiling tool for Haskell, like the website http://www.lahey.com/check.htm for fortran?
02:57:28 <lambdabot> Title: Lahey - Fortran Source Check
02:57:45 <dons> for profiling, use ghc's great profiler
02:57:52 <dons> compile with -prof -auto-all
02:57:56 <dons> and run the code with +RTS -p
02:57:58 <roconnor> How would one write the set of compact subsets?
02:58:00 <dons> which creates the file foo.prof
02:58:03 <vincenz> > let v = head (show v) in v
02:58:05 <lambdabot>  Exception: <<loop>>
02:58:12 <dons> for code coverage, there's HPC, in the latest ghc head branch
02:58:16 <nmessenger> ivanm: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
02:58:17 <dons> for checking, there's QuickCheck
02:58:18 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
02:58:19 <dons> and HUnit
02:58:36 <dons> ?check \x -> reverse (reverse x) == (x :: [Int])
02:58:37 <lambdabot>  OK, passed 500 tests.
02:58:59 <ivanm> Not source checking: I meant something that would suggest possible improvements/optimisations for the code
02:59:09 <ivanm> or does ghc do that automatically on compiling?
02:59:11 <dons> ah, DrHaskell
02:59:17 <nmessenger> or a lint?
02:59:17 <dons> well, ghc does optimise
02:59:22 <dons> compile with -O -Wall ?
02:59:45 <dons> -Wall gives you warning about unsafe practices
02:59:46 <nmessenger> @where drhaskell
02:59:47 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
02:59:55 <ivanm> OK, thanks
02:59:57 <dons> -O optimises, of course. and DrHaskell suggests alternative code
03:00:01 <dons> lambdabot's @pl also does this
03:00:05 <dons> @pl \f x -> f x
03:00:06 <lambdabot> id
03:00:30 <roconnor> so does @unpl
03:00:30 <ivanm> Well, I meant something like @pl that would go through the whole file for me
03:00:31 <mauke> @pl \f x -> f x (x f)
03:00:32 <lambdabot> ap ap (flip id)
03:00:32 <nmessenger> careful with @pl, though, it can get crazy :)
03:00:38 <dons> @. pl undo do x <- getChar ; putChar (reverse x)
03:00:38 <roconnor> @unpl \f x -> f x
03:00:39 <lambdabot> putChar . reverse =<< getChar
03:00:39 <lambdabot> \ f x -> f x
03:00:42 <ivanm> Yeah, I noticed ;)
03:00:44 <roconnor> er
03:00:47 <roconnor> bad example
03:00:50 <dons> ivanm, not that I know of.
03:00:53 <dons> roconnor: defeated!
03:00:59 <nmessenger> @pl \f g h -> f g (f h)
03:00:59 <lambdabot> flip =<< ((.) .)
03:01:05 <dons> round 2 to the bot!
03:01:09 <roconnor> @unpl (\f x -> f x) g
03:01:09 <lambdabot> (\ x -> g x)
03:01:25 <dons> keep trying! bot scores 3
03:02:00 <ivanm> So I need yhc for dr haskell?
03:02:07 <nmessenger> @pl \f g h -> f h (g h)
03:02:08 <lambdabot> ap
03:02:10 <mauke> @pl \f a g b c -> f a (g a) b (g b) c (g b)
03:02:11 <dons> apparently. i'm not sure how fit for use it is yet.
03:02:12 <lambdabot> flip flip id . (liftM2 (liftM2 flip) .) . flip flip id . (liftM2 ap .) . (`ap` flip id) . ((.) .)
03:02:13 <roconnor> unpl needs a bit more work in displaying results.
03:02:14 <Masklinn> hello haskell
03:02:23 <dons> mauke wins
03:02:34 <rahikkala> Mauke?
03:02:36 <mauke> FATALITY
03:02:38 <ivanm> OK, I know my code works, I was just looking for possible optimisations
03:02:44 * rahikkala sees
03:02:57 <ivanm> I've (just about) finished my first Haskell program, a Latin Square solver
03:03:01 <mauke> @. unpl pl \f a g b c -> f a (g a) b (g b) c (g b)
03:03:03 <lambdabot> (\ au f -> ((((\ bv ao aq -> au bv (ao aq)) >>= \ bx -> (\ aj ak -> ak aj) >>= \ bw -> return (bx bw)) f) >>= \ ad -> (\ ab -> ab) >>= \ ac -> return (ad >>= \ bi -> ac >>= \ bh -> return (bi bh))) >
03:03:03 <lambdabot> >= \ i -> (\ g -> g) >>= \ h -> return (i >>= \ n -> h >>= \ m -> return (\ t -> n t m)))
03:03:12 <ivanm> and I'm just about up to the optimisation stage
03:03:30 <mauke> wow, unpl is horrible
03:03:31 <nmessenger> \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)
03:03:32 <roconnor> ivanm: ususally one can keep refininging a haskell program until it is one line that uses ``sequence'' in is somewhere.
03:03:36 <nmessenger> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)
03:03:37 <dons> DrHaskell is supposed to suggest better alternatives, using a strategy similar to @pl, but aimed more at producing better code
03:03:40 <ivanm> just have to figure out how to read command line variables
03:03:42 <dons> rather than funny code
03:03:45 <dons> however, i've not used it
03:03:45 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
03:03:45 <lambdabot> ((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .
03:03:45 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
03:03:45 <lambdabot> . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .) .)
03:03:47 <lambdabot>  .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .
03:03:50 <lambdabot> [24 @more lines]
03:03:52 <dons> ok :(
03:03:54 <lambdabot> optimization suspended, use @pl-resume to continue.
03:03:58 <dons> ivanm: getArgs
03:04:00 <ivanm> roconnor: i'm not _that_ desperate ;)
03:04:08 <dons> main = do a <- getArgs ; print a
03:04:25 <dons> import System.Environment
03:04:28 * nmessenger apologizes
03:04:32 <dons> :)
03:04:35 <roconnor> main = getArgs >>= print
03:04:36 <ivanm> dons: how do I tell it to read in an Int variable? Or what about if I want optional -arg flags?
03:04:37 <dons> that's a good one though
03:04:56 <nmessenger> @index readLn
03:04:57 <lambdabot> System.IO, Prelude
03:05:09 <mauke> @index reads
03:05:10 <lambdabot> Text.Read, Prelude
03:05:16 <dons> main = do n <- getArgs >>= readIO . head ; print n
03:05:23 <roconnor> > read "5"
03:05:24 <lambdabot>  Add a type signature
03:05:25 <nmessenger> > System.IO.readLn >>= print . (2+)
03:05:26 <lambdabot>   Not in scope: `System.IO.readLn'
03:05:30 <dons> ivanm, for more complex things use System.Console.GetOpt
03:05:31 <roconnor> > read "5" :: Int
03:05:33 <lambdabot>  5
03:05:35 <dons> for proper getopt parsing
03:06:21 <ivanm> I don't think I need the optional flags, its mainly just the Int value that I need to read in
03:06:28 <nmessenger> > reads "not an int!" :: [(Int,String)]
03:06:30 <lambdabot>  []
03:06:36 <nmessenger> > reads "12!" :: [(Int,String)]
03:06:37 <lambdabot>  [(12,"!")]
03:06:52 <mauke> @type reads
03:06:53 <lambdabot> forall a. (Read a) => ReadS a
03:07:00 <nmessenger> @src ReadS
03:07:01 <lambdabot> Source not found. I've seen penguins that can type better than that.
03:07:28 <nmessenger> I think type ReadS a = String -> [(a, String)]
03:07:30 <mauke> > (reads :: ReadS Double) "1.2.3"
03:07:32 <lambdabot>  [(1.2,".3")]
03:07:50 <dons> ivanm, yeah, so call 'read' on the string
03:07:54 <dons> you get back from getArgs
03:08:32 <ivanm> OK, thanks!
03:08:33 <nmessenger> do [inp, outp] <- getArgs; hPutStr outp =<< hGetContents inp
03:08:56 <ivanm> what's the difference between read and reads?
03:09:01 <nmessenger> type
03:09:11 <nmessenger> read blows up on bad format
03:09:17 <nmessenger> > read "blah!" :: Int
03:09:18 <lambdabot>  Exception: Prelude.read: no parse
03:09:29 <nmessenger> > reads "blah!" :: ReadS Int
03:09:30 <lambdabot>      Expecting a function type, but found `[(a, String)]'
03:09:30 <lambdabot>       Expected type...
03:09:43 <nmessenger> > (reads :: ReadS Int) "blah!"
03:09:44 <lambdabot>  []
03:10:32 <ivanm> I've never seen that notation of typing a function before the arguments before... whats the significance to it?
03:10:42 <ivanm> or is that just because its an inline evaluation?
03:10:44 <nmessenger> @type reads
03:10:45 <lambdabot> forall a. (Read a) => ReadS a
03:11:04 <nmessenger> reads is overloaded, it needs to be restricted to be evaluated
03:11:13 <dons> just to give the type checker enough information to read the correct type in
03:11:40 <nmessenger> usually, this happens by automatically by the expression's type environment
03:11:53 <nmessenger> "type inference"
03:12:16 <ivanm> Yeah, I meant doing '(reads :: ReadS Int) "blah!" ' instead of ' reads "blah!" :: Int '
03:12:25 <ivanm> what's the difference?
03:12:40 <nmessenger> the second is ill-typed, reads returns a [(a,String)]
03:12:53 <nmessenger> > reads "blah!" :: [(Int,String)]
03:12:55 <lambdabot>  []
03:13:08 <nmessenger> I found annotation the 'reads' easier
03:13:08 <ivanm> oh, I misread the line and got the wrong one :s
03:13:13 <nmessenger> annotating*
03:13:45 <ivanm> OK, thanks nmessenger
03:14:20 <dons> ivanm, so you have a program reading the command line flags now?
03:14:24 <dons> ?docs System.Environment
03:14:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
03:14:39 <ivanm> no, not yet, I've hard-coded the input atm
03:14:59 * nmessenger ponders a type syntax extension for explicit inference, i.e. (f :: ... -> Int) would infer all but f's result
03:14:59 <ivanm> I'm generating Latin Squares that match certain criteria of a given size
03:15:29 <ivanm> Ultimately, I would read in the size from the command line but for testing purposes I've just hard-coded the value in
03:16:06 <ivanm> would anyone be interested in looking at my program once I've finished it [and giving me possible hints ;)]?
03:16:23 <nmessenger> do [sizeStr] <- getArgs; let size = read sizeStr; print $ makeLatingSquares size; return ()
03:16:35 <nmessenger> main = ...
03:16:54 <nmessenger> s/g//
03:17:44 <nmessenger> @index getArgs
03:17:44 <lambdabot> System.Environment
03:17:49 <nmessenger> make sure to import
03:18:00 <ivanm> Yep
03:18:12 <ivanm> thanks for that code fragment, nmessenger
03:18:14 <dons> ivanm, sure. post it to hpaste.org
03:18:21 <nmessenger> !paste
03:18:23 <ivanm> what's the significance of return () ?
03:18:27 <dons> ?paste
03:18:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:18:37 <dons> is our hpaste bot missing?
03:18:41 <nmessenger> ivanm: to satisfy 'main's expected type
03:18:51 <nmessenger> @seen hpaste
03:18:51 <lambdabot> I saw hpaste leaving #haskell 1h 36m 22s ago, and .
03:19:00 <nmessenger> "and ."?
03:19:01 <ivanm> Yeah, I will: just got to check licensing issues first, as I'm doing it as  a uni project (and they're paying me for it)
03:19:41 <dons> i'd be very surprised if you weren't allowed to ask for help in a public forum :)
03:19:58 <nornagon> dons: non-disclosure maybe?
03:20:00 <ivanm> I meant publishing the finished code
03:20:05 <dons> good morning mnislaih !
03:20:10 <mnislaih> hiya dons !
03:20:29 <mnislaih> any Railists around ? ;)
03:20:36 <ivanm> It should be OK, seeing as how I'm using code I found off the haskell website (some sudoku solving code, to be exact)
03:20:47 <dons> heh
03:20:55 <dons> mnislaih: :)
03:21:01 <ivanm> I just don't want to get any legal issues, but I'm seeing my supervisor tomorrow and I'll bring it up
03:21:05 <dons> mnislaih: i haven't seen any, but they could be hiding!
03:21:42 <dons> ivanm: what a pity, my supervisor required me to sign a 'all code will be released as open source'  clause in my contract :)
03:25:03 <ivanm> Yeah, but I'm only an undergrad doing a summer project, and seeing as how I'm being funded by AMSI, which is a national body, I've got no idea off the top off my head
03:25:57 <ivanm> The only paperwork that I saw/filled out was one saying that yes I'm doing the project, what I'm doing, pay details and OHS forms [which I still haven't filled out ;)]
03:26:08 <ivanm> you work at UNSW, don't you dons?
03:26:54 <dons> yep
03:27:31 <dons> ivanm: you're doing a summer project in haskell? where?
03:27:35 <dons> ANU?
03:28:10 <ivanm> well, as part of my summer project I've got to give a talk in Sydney on the 16th of feb about it, and I'm going to try and get some haskell involved, so if ur interested I can get more details for you
03:28:18 <ivanm> i'm doing it at UQ, under the maths department
03:28:39 <dons> will you be at unsw? or usyd?
03:28:51 <ivanm> Paul Bailes, the head of the school of ITEE suggested I should look at Haskell when I told him I liked the 1st year scheme subject
03:29:32 <dons> wow, you use scheme in first year?
03:29:36 <dons> that's pretty uncommon in .au
03:29:40 <arasinen> Apropos, is Google's code project called "Winter of Code" in the southern hemisphere?
03:29:51 <dons> haskell seems to be the main intro lang
03:30:03 <dons> arasinen: nah, its still summer of code
03:30:13 <dons> just not many students can get time off to work on it :(
03:30:50 <ivanm> Well, the project is funded by AMSI (the australian mathematical sciences institute), and the talks are at the CSIRO Big Day In
03:31:04 <nmessenger> ivanm: so what do you think of his suggestion so far?
03:31:10 <ivanm> i'm not sure where the talks are being held (trying to find out), but we're staying at the stamford grand
03:31:43 <dons> sounds cool
03:32:04 <ivanm> I like Haskell, especially since I can focus on the hi-level stuff unlike C (which I hate)
03:32:40 <ivanm> most of the stuff I've done so far has been in either matlab or Java, along with some Scheme, Python, Fortran90 and C
03:32:46 <dons> yeah, i think for maths/non-CS people needing to do high level things, having to learn C would be insane
03:33:10 <dons> hey blackdog
03:33:20 <ivanm> oh yeah, UQ's new introductory programming subject is scheme, using SICP from MIT
03:33:28 <resiak> All of the physics and engineering people here seem to use C, which is insanity
03:33:39 <ivanm> well, I'm doing a dual IT/Sci (math,phys) degree
03:33:39 <dons> blackdog: how's the code? shout you a lambda for old times sake?
03:34:04 <ivanm> then again, the only C I did was for micro-controllers ;)
03:34:16 <arasinen> resiak: I guess C still has the efficiency edge in large simulations
03:34:26 <arasinen> And with decent numeric libraries it isn't all bad.
03:34:34 <ivanm> but most of the stuff I'm doing these days is in computational science, which is what I learnt fortran90 for
03:34:39 <arasinen> (OTOH I thought phycisists used Fortran? :)
03:35:12 * nmessenger looked at Fortran code once. It was scary.
03:35:13 <dons> arasinen: but you can use haskell to *generate* C :)
03:35:20 <ivanm> well, the people who teach the 3rd year computational physics subject all use matlab (shudder)
03:35:23 <dons> (I do in a chemsitry simulation project)
03:35:27 <earthy> arasinen: C doesn't have the efficiency edge in large simulations. Fortran does.
03:35:52 <ivanm> nmessenger: fortran90 is a lot better than fortran77: e.g. you don't have to worry about column-based spacing
03:35:57 <earthy> (ofcourse, the NAG is available for C these days...)
03:36:12 <ivanm> a lot of the libraries, etc are still based on fortran (e.g. lapack)
03:36:17 <earthy> (and the NAG is what physicists want)
03:36:46 <ivanm> well, at the university of queensland, matlab reigns supreme for most maths/phys people
03:37:06 <earthy> ah, yes.
03:37:09 <ivanm> mainly because they don't do anything that big, and its pretty good at matrix-based stuff
03:37:29 <earthy> and those that do big stuff call out to fortran
03:37:40 <ivanm> so, what do you all think of the other functional languages like OCaml and Clean?
03:37:40 <earthy> a friend of mine, theoretical chemist, did that. ;)
03:37:50 <earthy> OCaml is ugly
03:37:53 <earthy> Clean is nice but misled
03:38:05 <resiak> arasinen: they're not doing large simulations... these are undergrads like me.
03:38:11 <dons> OCaml is too old fashioned
03:38:23 <ivanm> Despite what I read on the haskell site about it being second in the great computer language shootout, from what I can see OCaml and Clean seem to have better scores there :s
03:38:35 <ivanm> earthy: how is Clean misled?
03:38:50 <dons> ivanm, yeah, ocaml and clean have some zippy backends.
03:38:57 <earthy> ivanm: the clean people should do haskell :)
03:39:02 <norpan> they are all great languages and worth studying
03:39:08 <dons> though the shootout does need to be updated to use ghc 6.6 and bytestrings
03:39:24 <dons> earthy: didn't that battle get lost around 1988?
03:39:35 <earthy> dons: yeah, partially
03:39:46 <norpan> clean has nice features, but the syntax is worse than haskell's
03:39:49 <norpan> imho
03:40:12 <nmessenger> worse -> not as good as?  ;)
03:40:16 <norpan> yes
03:40:26 <dons> uniqueness types have a worse reputation for brain hurting than monads, too
03:40:33 <nmessenger> oh?
03:40:44 <norpan> i don't mind a bit of brain hurting
03:40:55 <ivanm> How is that? I've barely looked at Monads and my brain already hurts :s
03:40:56 <matthew_-> good for the soul
03:41:07 <norpan> uniqueness types are interesting
03:41:10 <dons> brain hurting without the expressive power :)
03:41:14 <norpan> and clean also have an operational semantics
03:41:18 <earthy> note that clean in 1988 was not that neat
03:41:31 <nmessenger> also closed-source?
03:41:39 <norpan> no clean is open source right?
03:41:47 <ivanm> its dual-licensed under LGPL and a commercial license now
03:41:48 <nmessenger> I do not know
03:41:56 <ivanm> but the clean report was last updated as a draft in 2001 :s
03:41:58 <norpan> clean was closed
03:42:04 <norpan> but is now open
03:42:04 <pejo> dons, in what way do you consider O'Caml old fashioned?
03:42:06 <ivanm> clean 2 can be open
03:42:10 <dons> yeah, that's the major failure I think, the license killed off any chance for a community to grow
03:42:20 <nmessenger> I know little of clean and ocaml, so I cannot comment on them.
03:42:27 <amiddelk> there is a download link of the clean software
03:42:29 <dons> pejo, impurity and overloading :)
03:42:50 <earthy> the Clean group also wasn't very nice in the mid 1990's
03:43:05 <nmessenger> earthy: how so?
03:43:06 <norpan> but it has a nice logo, reminds me of the commodore logo
03:43:30 <ivanm> norpan: that's a really great criteria for what constitutes a good programming language ;)
03:43:33 <earthy> nmessenger: very closed, very commercial-minded
03:43:58 <earthy> they actually spun off a company to commercialise clean in 1995 or somesuch
03:44:00 <norpan> anyway, the three of clean,haskell, and ocaml all have nice things that make them worth studying
03:44:02 <pejo> norpan, doesn't most research languages have either operational or denotational semantics specified?
03:44:07 <earthy> that failed. :)
03:44:18 <norpan> pejo: my point is that haskell doesn't have an operational semantics
03:44:25 <earthy> Clean has got *1* thing that Haskell hasn't. uniqueness types.
03:44:44 <ivanm> also, from what I can tell Clean seems to be a bit more windows-focussed than Haskell, which is bad for me
03:44:57 <earthy> oh, I lie. It has Sparkle, it has generics
03:45:10 <dons> earthy: also polymorphic dynamics
03:45:11 <earthy> ivanm: Clean started out on macs and transputers. ;)
03:45:19 <dons> though, hang on, we have that too .
03:45:24 * dons remembers his phd topic again
03:45:38 <ivanm> well, nowadays the website says the the linux version has less features than the windows version
03:45:40 <norpan> clean has an IDE
03:45:52 <ivanm> emacs is the only IDE worth using ;)
03:45:54 <earthy> clean damn better well have an IDE
03:46:00 * earthy programmed the help system for that back in 1994
03:46:07 <norpan> by the way, how is hIDE doing?
03:46:09 <dons> hehe
03:46:27 <matthew_-> earthy: you say it has generics - is this anything beyond associated types ?
03:46:31 <ivanm> earthy: so ur a bitter, ex-Clean programmer? ;)
03:46:41 <dons> norpan, forget hIDE, long live shim!
03:46:41 <earthy> bitter, but not about Clean the language. :)
03:46:48 <dons> ?where shim
03:46:49 <lambdabot> http://shim.haskellco.de/trac/shim
03:46:56 <norpan> i'll have a look at shim
03:47:04 <dons> norpan: there's a push to do a standard ghc-api binding to emacs and vim
03:47:04 <earthy> matthew_: yup. it has full generics as in generic haskell or syb
03:47:08 <dons> and build the tools that way
03:47:20 <dons> (i.e. like Isabelle and Proof General do for emacs)
03:47:35 <dons> leaving other people to worry about buffers and windows and text and linewrapping :)
03:47:35 <norpan> makes sense, especially if it's done for vim :)
03:47:51 <norpan> vim is clearly better than emacs ;)
03:48:03 <dons> though also, yi now has syntax highlighting!
03:48:06 <dons> as of yesterday
03:48:12 <dcoutts> @yarr!
03:48:12 <lambdabot> Keelhaul the swabs!
03:48:12 <dons> hmm. i should try it out and check that it works
03:48:24 * nmessenger quietly walks away from vi/emacs flames
03:48:36 <ivanm> yi is meant to be a Haskell-based emacsen, right?
03:48:39 <sehute> vim ftw! :)
03:48:39 <dons> dcoutts: so how are we going to change the world today?
03:48:44 * earthy still doesn't really get what ghci-api bindings would buy me
03:48:45 * dcoutts does cd yi; darcs pull
03:48:47 <dons> ivanm: a text editor
03:49:00 <earthy> better tags support, yeah
03:49:04 * ivanm regrets bringing up the whole emacs vs vi/m garbage
03:49:06 <earthy> maybe
03:49:11 <dcoutts> dons, I'm going to change the world today by releasing the second release candidate for Gtk2Hs
03:49:13 <dons> earthy: ghc-api bindings give you things automatic import completion
03:49:16 <norpan> earthy: immediate syntax checking and type checking
03:49:17 <earthy> ivanm: it's about integration
03:49:21 <dons> and type-sensitive syntax highlighting
03:49:31 <dons> dcoutts: sounds good!
03:49:49 <dcoutts> dons, since obviously yi-gtk and hIDE need that :-)
03:49:50 <norpan> we all change the world slightly every day
03:49:56 <earthy> automatic import completion...
03:50:09 <earthy> all other completion I already have now
03:50:24 <dons> dcoutts: that's very true
03:50:29 <earthy> and type-sensitive syntax highlighting... I don't really see what that'd give me
03:50:31 <dcoutts> dons, I got my OpenGL FP practical program running on Windows yesterday in GHCi, I was well pleased and had to call colleagues into my office to show it off :-)
03:50:43 <earthy> the only thing I imagine it'd buy me is sub-expression type information
03:50:45 <dons> type sensitive identifer completion?
03:50:59 <dons> maybe even type sensitive expression completion?
03:51:14 <earthy> hm. a type-sensitive omni completer
03:51:17 <earthy> that'd be an idea
03:51:19 <pejo> earthy, are you pondering what could be done with ghc-api that you don't currently have, or is it what it gives you today?
03:51:32 <earthy> pejo: the former
03:51:57 <dons> the advantage is really type information, and package information, that ghc has
03:51:59 <earthy> using ghci-api pulls in a *huge* dependancy
03:52:07 <dcoutts> dons, I want an IDE that will show me the intermediate code at every stage of ghc compilation pipeline
03:52:12 <dons> so completing import lists for us, based on identifiers that appear in the src
03:52:14 <dons> that'd be fun
03:52:31 <norpan> i want type-dependent identifier completion
03:52:34 <dcoutts> dons, and a 'live update' view where I can change the source and look at the changes in the core, like in 2 panes.
03:52:40 <dons> ah yes, and viewing interactively what Core ghc turns a code fragment into
03:52:51 <dons> yeah. think of the tuning that'd give us
03:52:57 <dcoutts> exactly
03:52:59 * ivanm wants to try out yi, but Gentoo says that ghc-6.6 and hs-plugins won't play nicely together :(
03:53:10 <earthy> that's still true, unfortunately
03:53:12 <dcoutts> and info on the strictness and worker wrapper transform for each function
03:53:14 <dons> ivanm, yeah, its strictly a bleeding edge issue
03:53:15 <syntaxfree> www.funroll-loops.org
03:53:26 <dons> ghc 6.6 and hs-plugins (darcs version) now work
03:53:29 <ivanm> syntaxfree: not funny
03:53:30 <dons> as of yesterday
03:53:42 <syntaxfree> bah, funroll-loops is down.
03:54:02 <pejo> dcoutts/dons, while that stuff is useful for the average phd/phd student, I'm not sure that is what hte masses wants in general. :-)
03:54:04 <ivanm> dons: OK, I'll wait till someone updates the haskell overlay then
03:54:04 <matthew_-> dons! YAY!
03:54:22 <dons> thank Lemmih
03:54:24 <dons> he did the job :)
03:54:27 <dcoutts> pejo, sure, I just said "I want!" ;-)
03:54:33 <syntaxfree> http://209.85.165.104/search?q=cache:ry_pKAkI_1YJ:funroll-loops.org/+funroll-loops&hl=pt-BR&ct=clnk&cd=1
03:54:36 <lambdabot> http://tinyurl.com/2qe2pb
03:54:43 <matthew_-> I can finally upgrade to 6.6 on one of my servers
03:54:46 <syntaxfree> ivanm: hey, being able to laugh at oneself is one of the hallmarks of virtue.
03:54:50 <pejo> dcoutts, it's a nice idea - I'd want it myself if I was developing a compiler.
03:54:55 <matthew_-> @karma+ Lemmih
03:54:56 <lambdabot> Lemmih's karma raised to 38.
03:55:13 <ivanm> syntaxfree: yeah, I know, but the Gentoo Linux distribution isn't me ;)
03:55:31 <syntaxfree> heh. Maybe I'm just thinking of myself three years ago.
03:55:39 <syntaxfree> I spent about an year dicking about with Gentoo.
03:55:49 <ivanm> I just chose Gentoo because it wasn't RPM-based, and because people think I must be intelligent for using it ;)
03:56:12 <matthew_-> Debian also tends to fall into that category
03:56:12 <syntaxfree> I eventually got fed up, got a Mac and a girlfriend.
03:56:19 <syntaxfree> Too bad she dumped me a month ago. Ouch.
03:56:30 <pejo> The mac was a good choice.
03:56:30 <ivanm> syntaxfree: but do you still have the mac?
03:56:39 <syntaxfree> yep.
03:56:47 <nmessenger> LOL COMPUTER NERDS!!!!11
03:56:50 <nmessenger> :P
03:56:53 <ivanm> well, 50% isn't bad ;)
03:57:01 <nmessenger> (says the guy on IRC)
03:57:59 <nmessenger> *crickets chirp*
03:59:05 <dons> > fix ((1:) . scanl (+) 1)
03:59:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:59:12 <dons> phew, code!
03:59:19 <nmessenger> hooray code!
03:59:41 <dons> i was getting scared I'd wandered into #haskell-blah for a minute there
04:00:10 <dons> any puzzles on hpaste.org we can solve?
04:00:42 <dons> mm, maybe lambdabot should be able to list unanswered queries on hpaste
04:00:55 <xerox> Nice idea.
04:01:26 <dons> i've found in the past week when i'm bored i go and solve questions on hpaste..
04:01:40 <dons> and i encourage anyone else tiwddling their haskell thumbs to do the same! :)
04:01:42 * earthy envies you
04:01:50 * nmessenger thought he was the only one who does that
04:01:52 <earthy> you get bored! :)
04:01:58 <syntaxfree> I'm kinda hacking on hpaste.
04:01:59 <ivanm> OK, a haskell-related question: if I have a list of items, where some of the items can be related by a function (i.e. a matrix and its transpose) and I wanted to filter these out so that I only ever have one of these items, how should I go about it? nubBy or a delete-based function?
04:02:08 <syntaxfree> Mostly trying to understand the code so I can turn it into a bulletin board.
04:02:16 <dons> earthy: well, looking for a break from coding :)
04:02:21 <syntaxfree> I can't compile it, though, so I might not be helpful.
04:02:56 <nmessenger> ivanm: so you have a list [x,y,z] and you want to end up with just *one* of these?
04:03:23 <nmessenger> @type find -- maybe?
04:03:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
04:03:51 <ivanm> well, if I denote the transpose of a matrix by a prime, then I have a list like [a,a',b,c,d,b',c',d'] and I want to end up with [a,b,c,d]
04:03:55 <syntaxfree> @type (\\)
04:04:01 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:04:11 <syntaxfree> maybe you want a combination of filter and \\.
04:04:22 <nmessenger> nubBy kinda sounds like that
04:04:23 <syntaxfree> > [2,3,4,5] \\ [3,4]
04:04:30 <nmessenger> @type nubBy
04:04:46 <ivanm> i.e. for all a, there exists at most one a' such that f a a' = True
04:04:55 <uccus> ivanm: I think you are after nubBy
04:05:08 <uccus> supply your f to nubBy
04:05:12 <nmessenger> nubBy isTransposition listOfMatrices
04:05:26 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
04:05:26 <syntaxfree> There is some general structure to functions like nubBy and sortBy.
04:05:27 <lambdabot>  [2,5]
04:05:38 <syntaxfree> they like allow you to use an alternate Eq/Ord structure.
04:05:47 <ivanm> Well, the two I've worked out are:
04:05:52 <ivanm> removeTransposed n = nubBy (\ ls -> (==) (transposedForm n ls))
04:05:59 <ivanm>  removeTransposed' n (ls:lss) = ls : (removeTransposed' n lss')
04:05:59 <ivanm> >                                where
04:05:59 <ivanm> >                                lss' = delete trans lss
04:05:59 <ivanm> >                                trans = transposedForm n ls
04:06:00 <lambdabot>  Parse error
04:06:00 <lambdabot>  Parse error
04:06:00 <lambdabot>  Parse error
04:06:12 <syntaxfree> the obvious way to make that explicit is to create a new type and instance Eq and Ord accordingly.
04:06:20 * ivanm forgot to remove the greater than signs
04:06:26 <syntaxfree> I wonder if there's a better way to supply alternate structure to existing types.
04:06:42 <uccus> syntaxfree: sigh
04:06:47 <ivanm> well, I've only done aliasing, where I define a Matrix a -> [[a]]
04:06:50 <syntaxfree> sigh?
04:07:06 <uccus> syntaxfree: take a look at Scala if you have time...
04:07:27 <syntaxfree> hmm. I programmed myself to take a look at Erlang today. I'll write it down, though.
04:07:36 <ivanm> Out of these two functions, I would guess that the second would be more efficient as delete stops at the first instance.  Would this be right?
04:08:29 <syntaxfree> uccus: you do understand what I'm saying, right? There's a lot of grunt work in writing fooBy-like functions.
04:08:47 <uccus> syntaxfree: basically what Scala does is the following... it resolves the function to be supplied from the scope. if there is only one function with the given type in the context then it uses that.
04:08:53 <nmessenger> so [a, a', a'] -> [a, a']?
04:09:40 <syntaxfree> ivanm: anyway, my suggestion stands: create a new datatype for "TransposeFreeMatrix" and instance Eq so that a == a'
04:10:00 <syntaxfree> I'm sure nubBy solves the problem temporarily, but it doesn't "feel" right.
04:10:07 * nmessenger is not sure if that's a good idea, but can't explain why
04:10:31 <ivanm> syntaxfree: not quite sure what your meaning is here.  I've got a function that transposes the matrix, which is what I uses for my two equality functions for nubBy and delete
04:11:05 <syntaxfree> well, certainly theres an equivalence class of matrices that are equal modulo transposing.
04:11:27 <syntaxfree> Maybe that's what I want. Modulo-f equivalence classes.
04:11:34 <uccus> ivanm: he means you define a type that "equals" a with (transpose a)
04:11:34 <syntaxfree> I wonder what's the most general way to implement that in Haskell.
04:11:49 <nmessenger> ivanm: if you can either guarantee that the list doesn't contain multiple duplicates, or you don't *care* that it does, then your deleting function should be okay.  Personally, I'd use the simple library functions.
04:11:54 <uccus> of course it is ;)
04:12:35 <ivanm> I can guarantee that there is at most 1 duplicate, so to me the second function would be slightly more efficient, but the first one with nubBy looks cleaner
04:12:53 * nmessenger values clear code
04:12:59 <uccus> me too... nubBy or nub on eq class seems fine to me, I think he is overspecifying the prob
04:13:05 * syntaxfree values generality.
04:13:43 <ivanm> well, the reason is that Latin Squares are an O(n^(n^2)) problem, so I need to make it as efficient as possible
04:13:44 <nmessenger> clear code and generality coexist pretty well
04:13:49 * uccus values valuation itself
04:13:54 <jacobian> Is there a canonical name for a function that folds over a list with a function that goes from a->m b, given a "bind" operation for m?
04:13:59 <syntaxfree> nmessenger: sure.
04:14:06 <nmessenger> @type foldM
04:14:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:14:17 <syntaxfree> nmessenger: any suggestions on how to write general code for a "modulo-foo equivalence class"  type class?
04:14:48 <jacobian> thanks nmessenger!
04:15:18 <syntaxfree> jacobian: many list functions have a fooM equivalent. It's often worth hoogling for them if you're reasoning that way.
04:15:24 <ivanm> so, I need a way to remove the tranposed forms as efficiently as possible, because from my naive and simple experiments, this removal phase adds about 50% extra runtime on
04:15:25 <rahikkala> ivanm: If efficiency is a concern and you're able to write a "canonicalizing" function, which removes the extraneous data you don't want to check for equality on, consider \l -> map fst $ nubBy snd $ zip l $ canonicalize l
04:15:49 <nmessenger> syntaxfree: not immediately
04:15:55 <ivanm> @hoogle canonicalize
04:15:55 <lambdabot> System.Directory.canonicalizePath :: FilePath -> IO FilePath
04:15:57 <syntaxfree> I'll post to haskell-cafe.
04:16:27 <ivanm> rahikkala: i don't think I have any idea what you're talking about, sorry
04:18:52 <ivanm> @pl \l -> map fst $ nubBy snd $ zip l $ canonicalize l
04:18:53 <lambdabot> map fst . nubBy snd . ap zip canonicalize
04:19:12 <nmessenger> canonicalize looks like it reduces a thing to a more-efficient-to-check-equality-on form.  I'm not sure how that applies to matrices (I'm not very learned in them).
04:19:16 <rahikkala> That might be because that line was severely wrong :(
04:19:25 * rahikkala beats it into a more working shape
04:19:27 <ivanm> ahhhhh, that would explain it ;)
04:21:13 * nmessenger 's head explodes from 'ap zip canonicalize'.  "It's S!  And I understand it!"
04:21:34 <rahikkala> For instance, if you have a list of ints and you only want out those ints that have the same absolute value...
04:21:38 <rahikkala> > let l = [(-4)..5]; matching p x y = ((p x) == (p y)) in map fst $ nubBy (matching snd) $ zip l (map abs l)
04:21:40 <lambdabot>  [-4,-3,-2,-1,0,5]
04:22:45 <cl4proze> hi, I am trying to compile glr examples from happy 1.16 and it says that I don't have package data. Any tips on where I can get that package?
04:23:03 <nmessenger> @let pointwise f g x y = g x `f` g y -- seems like a common idiom
04:23:04 <lambdabot> Defined.
04:23:18 <rahikkala> I don't know if there's such an operation for matrices and transposition, either
04:23:42 <ivanm> rahikkala: OK, but what happens if l is extremely long.... will your code search through the whole thing even if it already finds one? That's my biggest worry :s
04:24:04 <roconnor> @get zarvok
04:24:04 <lambdabot> shapr!!
04:24:11 <roconnor> um
04:24:17 <roconnor> that doesn't work at all as I expected
04:24:26 <ivanm> I've got a transposition function defined, so the ((p x) == (p y)) can just be ((transposedForm x) == y) for my case
04:24:48 <rahikkala> @src nubBy
04:24:48 <lambdabot> nubBy eq []             =  []
04:24:49 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:24:52 <nmessenger> at-get is short for @get-shapr
04:25:06 <nmessenger> @g
04:25:06 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . v
04:25:18 <roconnor> @girl19
04:25:19 <lambdabot> nobody can catch me
04:26:00 <roconnor> I guess it is a bit early in @ cmu for zarvok
04:26:32 <syntaxfree> well, just posted this to haskell-cafe.
04:26:33 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/01/modulo-foo-equivalence-classes/
04:26:36 <lambdabot> Title: Modulo-foo equivalence classes? Â« Data.Syntaxfree, http://tinyurl.com/262hg5
04:26:38 <ivanm> @src filter
04:26:39 <lambdabot> filter _ []     = []
04:26:39 <lambdabot> filter p (x:xs)
04:26:39 <lambdabot>     | p x       = x : filter p xs
04:26:39 <lambdabot>     | otherwise = filter p xs
04:27:03 <rahikkala> ivanm: Do you mean that the list is guaranteed not to have more than one deletable copy of each matrix? If that's tha case I guess you'll want delete...
04:27:34 <nmessenger> rahikkala: yep, he's confirmed that.
04:27:45 * rahikkala is slow
04:27:54 <ivanm> rahikkala: yeah, it is guaranteed, because of the way I generate them...  I thought delete was the most efficient way, but the nubBy method was _so_ much nicer!
04:28:20 * ivanm forgives rahikkala, and says thanks anyway
04:28:47 <syntaxfree> this is really a case of equivalence classes.
04:28:50 <kolmodin> dons, dcoutts: we don't have any Binary instances for Double or Float..
04:28:59 <dcoutts> true
04:29:00 <syntaxfree> there should be a pretty way of expressing equivalence classes in Haskell.
04:29:12 <dons> kolmodin: very true
04:29:21 <dons> please think up one. i couldn't. but i didn't try very hard.
04:29:29 <dcoutts> kolmodin, do you think we can use the IEEE binary format
04:29:30 <dons> someoen suggested there were standard encodings :)
04:29:30 * ivanm is amazed that someone thought his problem was good enough to blog about
04:29:35 <kolmodin> I haven't either. it just struck me
04:29:44 <syntaxfree> ivanm: it's not a good blog :)
04:29:50 <nmessenger> syntaxfree: if you're up for an oleg or two of hackery, then you might read...
04:29:55 <uccus> syntaxfree: the way you specified the problem is sort of like the classical use case of type-classes, I don't think anybody will come up with an interesting alternative
04:30:01 <dcoutts> kolmodin, bah, who uses floating point anyway? ;-)
04:30:01 <dons> ivanm: yeah, don't mind syntaxfree. he just likes teasing the python programmers
04:30:02 <nmessenger> @google Functional Pearl: implicit configurations
04:30:04 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
04:30:04 <ivanm> syntaxfree: doesn't really matter ;)
04:30:14 <syntaxfree> the problem is parameterizing a type class with a function that (==) can use.
04:30:22 <kolmodin> dcoutts: you shouldn't, to easy to get it wrong :)
04:30:48 <dcoutts> I don't, fear not
04:30:48 <dons> > 1.1 + 2.2 -- friends don't let friends use floating point!
04:30:50 <lambdabot>  3.3000000000000003
04:30:57 <kolmodin> augustss once said that you should have to take a float point license to use them. sometimes that's not a bad idea :)
04:30:57 <syntaxfree> I mean, sure I can write a Modulo7Eq class and a Modulo5Eq class.
04:31:01 <dcoutts> I steer well clear of numerical stuff
04:31:16 <earthy> that's why we have exact representations of the computable reals, right? :)
04:31:20 <syntaxfree> how do I come up with a class that accepts (\x->x `mod` 5) as a parameter?
04:31:23 <earthy> CReal.hs, IIRC
04:31:34 <kolmodin> dcoutts: I'll see what DICOM does to save floats and doubles
04:31:34 <dons> > 11 % 10 + 22 % 10
04:31:36 <lambdabot>  33%10
04:31:36 <ivanm> syntaxfree: well, I've already managed to get rid of most of the equivalence classes based on how I've generated the matrices (hence why I can guarantee that there is at most one deletable version), but the transposed ones are the difficult ones
04:31:43 <earthy> http://www.augustsson.net/Darcs/CReal/
04:31:48 <lambdabot> Title: Index of /Darcs/CReal
04:31:50 <Gotaku> How would I got about translated this short python code into haskell?
04:31:51 <Gotaku> http://pastebin.com/872690
04:31:53 <roconnor> @google FewDigits
04:31:55 <lambdabot> http://r6.ca/FewDigits/
04:31:56 <lambdabot> Title: Few Digits 0.5.0
04:32:07 <dons> Gotaku: good question!
04:32:28 <dons> Gotaku: you should use hpaste.org though ;)
04:32:34 <syntaxfree> ivanm: I admire you actually managing to do real work instead of getting backtracked by abstract-structure nonsense you're not even knowledgeable enough to tackle, like me.
04:32:35 <fasta> I have something of type Foo GHC.Prim.Any GHC.Prim.Any GHC.Prim.Any GHC.Prim.Any
04:32:46 <fasta> Does that mean I broke the type inferencer?
04:32:46 <roconnor> we should add CReal to lambdabot
04:32:52 <Gotaku> Noted.
04:32:54 <dons> roconnor: good idea.
04:32:56 <roconnor> and then make it the default :P
04:33:04 <dons> then we'd actually learn it
04:33:09 <dons> which might help adoption
04:33:14 <nmessenger> syntaxfree: did you see that Oleg paper?
04:33:15 <ivanm> syntaxfree: I find the abstract nonsense stuff quite entertaining, and besides, it helps me forget the fact that I really should be getting to bed ;)
04:33:18 <earthy> russel, how much does Few Digits differ from CReal? or does it simply expand on it?
04:33:23 <syntaxfree> nmessenger: it's downloading.
04:33:28 <earthy> (and this is your PhD subject, isn't it? :))
04:33:30 <syntaxfree> sloow download, too.
04:33:34 <roconnor> earthy: it is faster is some cases, and slower in most others ;)
04:33:43 <dons> earthy: he's at least written a paper or two on the area :)
04:33:49 <roconnor> yes, this is part of my PhD work
04:33:52 <dons> roconnor: want to submit a lambdabot patch to turn on CRea?
04:34:06 * nmessenger has at least a dozen pdfs in his haskell directory
04:34:07 <roconnor> how hard it is to edit lambdabot?
04:34:12 <Gotaku> dons: I can't figure out how to write it in haskell in a proper way.
04:34:18 <syntaxfree> lambdabot code seems clear to me.
04:34:27 <syntaxfree> Compiling it is what's screwed. ;)
04:34:36 <dons> Gotaku: what does the code do? it concats its input lines?
04:34:51 <dons> until a blank line is reached?
04:34:54 * ivanm agrees about compiling lambdabot, especially for someone who hasn't used much haskell before
04:35:02 <roconnor> It shouldn't be so hard to do. At the simplest level we just need to add CReal to the list of default imports.
04:35:03 <dons> yeah, its a bit too hard atm
04:35:43 <ivanm> dons: before adding any more plugins to lambdabot, how about simplifying/documenting the install process a little better for haskell newbs like myself, especially when new libraries also need to be installed?
04:36:06 * fasta expects standard Hackage answer in 5
04:36:21 <dons> Gotaku: something like: main = print . concat . takeWhile (not . null) . lines =<< getContents
04:36:32 <syntaxfree> maybe lambdabot should me more modular.
04:36:42 <dons> Gotaku: though my python is rusty enough to not be 100% sure what you're trying to do
04:36:50 <syntaxfree> that way, if one wants to run a specific plugin, they can as their own bot here, as opposed to adding it to the main lambdabot.
04:36:52 <rahikkala> > let nubOneBy _ [] = []; nubOneBy p (x:xs) = x : nubOneBy p (deleteBy p x xs) in nubOneBy (==) [1,2,3,2,1,3,2]
04:36:52 <nmessenger> dons: interact!
04:36:54 <lambdabot>  [1,2,3,2]
04:37:09 <syntaxfree> I wish I could stay in the same project for more than two days!
04:37:20 <SamB> syntaxfree: are you saying ... some kind of a swarm?
04:37:29 <rahikkala> ivanm: I'm not sure if that's very efficient at all either, though
04:37:34 <dons> main = interact $ (++"\n") . concat . takeWhile (not . null) . lines
04:37:36 <ivanm> rahikkala: is that meant to be a delete-first-only version of nubBy?
04:37:36 <kolmodin> also note that getContents throws away the rest of the contents
04:37:37 <dons> Gotaku: or that ^
04:37:44 <rahikkala> ivanm: Yes
04:37:45 <fasta> Anybody seen a type like Foo GHC.Prim.Any GHC.Prim.Any GHC.Prim.Any GHC.Prim.Any get derived?
04:38:02 <syntaxfree> #haskell itself could have a "no alternate lambdabot policies" to avoid the singularity arising in here why people are trying to hack, but..
04:38:04 <dons> Gotaku: right, as kolmodin says you might just want a loop calling readline or getLine
04:38:08 <roconnor> default (CReal)
04:38:12 <ivanm> rahikkala: thanks, I'll try it out
04:38:19 <xerox-> dons, unlines . ?
04:38:27 <dons> sure
04:38:48 <roconnor> why is lambdabot hard to build?
04:39:03 <dons> i guess since it has 2 external deps, and 90 modules?
04:39:09 <dons> and run in-tree
04:39:18 <roconnor> what are the 2 external deps?
04:39:28 <roconnor> run in-tree?
04:39:28 <ivanm> dons: how bout every now and then creating stand-alone binaries?
04:39:30 <dons> zlib, binary
04:39:40 <dons> ivanm: that's a crazy idea! ;)
04:39:43 <dons> (good idea)
04:40:04 <roconnor> I guess one need to be able to get lambdabot core to play with.
04:40:24 <ivanm> especially when I wanted to put it the computers at uni, and whilst I had just managed to get them to put on ghc they didn't add anything else like darcs :s
04:40:24 <matthew_-> now for that minimum number of architectures to provide binaries for...
04:40:28 <roconnor> then people like dons can take several lambdabot modules (some with dependencies) and merge them all together?
04:40:40 <nmessenger> @check (\lines -> concat lines ++ "\n" == unlines lines) :: [String] -> Bool -- xerox-
04:40:41 <lambdabot>  Falsifiable, after 0 tests: ["\92862\982952","\491831\300041\661628"]
04:40:57 <ivanm> matthew_: I see your point :s
04:41:34 <syntaxfree> nmessenger: the paper you sent me to is "Implicit configuration".
04:41:43 <syntaxfree> is that the one I'm supposed to read?
04:41:49 <matthew_-> there's the 11 Debian release architectures, then solaris (Sparc and x86), mac (PPC and x86-64) and then all the windows too ;-)
04:41:50 <ivanm> Well, thanks everyone for your help/suggestions, but I think its time I got off the 'net
04:41:59 <ivanm> Cya, and once again thanks!!!!
04:42:02 <Gotaku> Can you pattern match elements of a list? like ['\n']?
04:42:05 <earthy> hm. cabal-install doesn't compiler out of the box
04:42:08 <earthy> -r
04:42:14 <nmessenger> syntaxfree: yep, it has stuff about modulo arithmetic
04:42:17 <earthy> gotaku: yes.
04:42:42 <earthy> > let f ['\n'] = True; f [] = False in f "\n"
04:42:43 <lambdabot>  True
04:42:46 <nmessenger> syntaxfree: it's kinda related
04:43:19 <earthy> > let f ['\n'] = True; f [] = False in (f "\n", f "")
04:43:20 <lambdabot>  (True,False)
04:43:23 <syntaxfree> @check (\x + 1 == x + 2 - 1) :: [Int->Bool]
04:43:24 <lambdabot>  Parse error
04:43:26 <nmessenger> Gotaku: ['\n'] is just sugar for ('\n':[])
04:43:27 <syntaxfree> What am I doing wrong?
04:43:47 <nmessenger> syntaxfree: add '-> x'
04:43:48 <syntaxfree> ah, damn.
04:43:51 <syntaxfree> sure, yes.
04:43:51 <syntaxfree> sorry.
04:44:42 <nmessenger> @check (\xs -> not (null xs) ==> [head xs] == take 1 xs) :: [Int] -> Property
04:44:43 <lambdabot>  OK, passed 500 tests.
04:45:16 <nmessenger> "implies" is fun!
04:45:23 <syntaxfree> @check (\x->x+1 == x+2-1) :: Int->Bool
04:45:25 <lambdabot>  OK, passed 500 tests.
04:45:31 <syntaxfree> hmm. there's an imply operator.
04:45:49 <nmessenger> if you want to play with @check a lot, try /msging LB
04:45:52 <earthy> hmkay. the cabal / hackage stuff isn't clear on which to use: cabal-get or cabal-install
04:45:59 <syntaxfree> nmessenger: I am.
04:46:10 <nmessenger> syntaxfree: right-o :)
04:46:20 <syntaxfree> nmessenger: I just wanted to show you I did it right finally so you didn't keep on showing it..
04:46:24 <nmessenger> @type (==>)
04:46:26 <lambdabot> Not in scope: `==>'
04:46:32 <nmessenger> @index (==>)
04:46:33 <lambdabot> Test.QuickCheck, Debug.QuickCheck
04:46:35 * syntaxfree is not testing x + 2 = x + 1 +1, no ;)
04:46:43 <nmessenger> @type (Test.QuickCheck.==>)
04:46:45 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
04:46:50 <Donner> nmessenger: Does implies in check really help that much? It prevents finding the corner cases.
04:47:20 <nmessenger> Donner: it allows you to specifically say the exceptions to your property
04:47:43 <nmessenger> @check (\xs -> [head xs] == take 1 xs) :: [Int] -> Bool
04:47:45 <lambdabot>  Falsifiable, after 0 tests: []
04:47:57 <roconnor> earthy: I'm working on extensions as well.  I will have integration and compact sets.
04:48:00 <Donner> Of course: The exceptions you think of. Quickcheck is usful to find the exceptions you are not aware of.
04:48:09 <roconnor> But this may not appear in Haskell. :(
04:49:11 <SamB> @check undefined
04:49:12 <lambdabot>  Add a type signature
04:49:21 <SamB> @check (undefined :: ())
04:49:22 <lambdabot>  Arguments exhausted after 0 tests.
04:49:27 <SamB> @qcheck (undefined :: ())
04:49:28 <lambdabot> Maybe you meant: check scheck
04:49:39 <Donner> Implies drops a lot of testcases, so you do not get really 500 test but only a very small fraction up to zero tests at all. It's better to use custom generators.
04:49:49 <SamB> @check (undefined :: Int -> Bool)
04:49:51 <lambdabot>  Undefined
04:50:12 <nmessenger> Donner: oh.  I've not used QuickCheck that much.
04:50:22 * SamB thinks quickcheck should catch exceptions so it can tell you what testcases triggered them
04:50:26 <Donner> nmessenger: Keep that in mind.
04:50:36 <nmessenger> Donner: can I write a generator using @check?
04:51:13 <nmessenger> thanks for the tip.
04:51:15 <Donner> nmessenger: I'm here since two days. I did not even know of lambdabot before ;-)
04:52:05 <SamB> Donner: @check only supports expressions, so...
04:53:05 <Donner> @check (x > x) => x == x +1
04:53:06 <lambdabot>  Parse error
04:53:31 <nmessenger> @check (\x -> x > x ==> x == x + 1) :: Int -> Bool
04:53:32 <lambdabot>  Couldn't match `Bool' against `Property'
04:53:38 <nmessenger> @check (\x -> x > x ==> x == x + 1) :: Int -> Property
04:53:39 <lambdabot>  Arguments exhausted after 0 tests.
04:54:15 * nmessenger thinks it'd be cool if @check automatically generated lambdas for free variables
04:54:43 <nmessenger> and possibly defaulted arguemnts to Int or something
04:55:30 <nmessenger> @check (\x -> x > x == False) :: Int -> Bool
04:55:31 <lambdabot>      precedence parsing error         cannot mix `(>)' [infix 4] and `(==)' [...
04:55:45 <nmessenger> @check (\x -> not (x > x)) :: Int -> Bool
04:55:46 <lambdabot>  OK, passed 500 tests.
04:56:15 * nmessenger is not taking own advice about /msg :/
04:56:31 <fasta> dons: Did you ever have Foo GHC.Prim.Any GHC.Prim.Any GHC.Prim.Any GHC.Prim.Any getting derived?
04:56:59 <nmessenger> ?paste the code if you can, I haven't.
04:57:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:57:19 <fasta> When I replace the expression with that type by an equivalent expression, it derives another type.
04:58:26 <nmessenger> 'Any' as far as I know, is the top type for when the compiler is stuck with 'forall a. a'
04:59:54 <fasta> nmessenger: so, that's the type whose only inhabitant is the value bottom?
05:00:34 <fasta> Haskell-cafe is exploding
05:00:51 <Donner> fasta: Read it lazily ;-)
05:00:58 <nmessenger> I thought the type couldn't escape GHC internals.  If it can't infer beyond 'Any' isn't it supposed to reject it?
05:01:11 <roconnor> nmessenger: is it easy to find the free variables?
05:01:59 <nmessenger> roconnor: I'd presume not, it'd also behave strangely if a person didn't know of a library function and used its name.  My suggestion was only fleeting.
05:02:08 <roconnor> @check (\not x -> not (x > x)) :: (Bool -> Bool) -> Int -> Bool
05:02:08 <SamB> if it can't escape internals... why does it have a Haskell-level name?
05:02:10 <lambdabot>  Falsifiable, after 4 tests: <Bool -> Bool>, -4
05:02:32 <matthew_-> grr, why is there no zipWith3M ?
05:02:43 <nmessenger> SamB: GHC's written in Haskell, isn't it :)
05:02:52 <roconnor> nmessenger: yeah, it sort of seems like a good idea at first, but then you find it is actually quite difficult.
05:02:56 <Gotaku> I still can't get runInteractiveProcess to work...
05:03:05 <SamB> nmessenger: yes. but they have different names for things in Core!
05:03:06 <Donner> @check (\x -> x > 50 ==> x + 1 == x + 1) :: Int -> Property
05:03:07 <lambdabot>  Arguments exhausted after 0 tests.
05:03:10 <nmessenger> ?paste bins for everyone!
05:03:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:03:11 <roconnor> @type runInteractiveProcess
05:03:13 <lambdabot> Not in scope: `runInteractiveProcess'
05:03:20 <roconnor> @hoogle runInteractiveProcess
05:03:21 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
05:03:29 <Donner> nmessenger: The corner case was never hit. The process was not even successful.
05:04:22 <SamB> @scheck (\not x -> not (x > x)) :: (Bool -> Bool) -> Int -> Bool
05:04:24 <lambdabot>   Failed test no. 2. Test values follow.: {True->True;False->False}, 0
05:04:43 <SamB> not doesn't work very well if it is actually id ;-P
05:04:47 <syntaxfree>  @check (\x -> x >= 50 ==> x /= 50) :: Int -> Property
05:04:49 <nmessenger> Donner: noted.  But there's not much alternative when demonstrating things in-channel.
05:04:51 <roconnor> scheck prints functions more nicely
05:05:10 <syntaxfree> @check (\x -> x >= 50 ==> x /= 50) :: Int -> Property
05:05:12 <lambdabot>  Arguments exhausted after 0 tests.
05:05:20 <SamB> roconnor: more informatively, at least
05:05:29 <syntaxfree> hmm. it first tests the corner test.
05:05:54 <nmessenger> "Arguments exhausted" means it ran out of test cases without doing any tests.
05:06:19 <syntaxfree> huh?
05:06:29 <syntaxfree> it doesn't know any integers >=50?
05:06:55 <nmessenger> syntaxfree: it only does 500 cases.  I suppose it just didn't go past 50.
05:07:19 <nmessenger> (the test case count is configurable.  LB is configured for 500)
05:07:19 <Donner> syntaxfree: QuickCheck is trimmed to test some corner cases. Large values are not the default corner cases of Int.
05:07:31 <syntaxfree> @check (\x-> x/=30000) :: Int -> Bool
05:07:33 <lambdabot>  OK, passed 500 tests.
05:07:47 <syntaxfree> test cases are random?
05:07:54 <syntaxfree> or does the test variable need to be a member of Enum?
05:07:58 <Donner> @check (<50::Int)
05:07:58 <lambdabot>  Parse error
05:08:10 <Donner> @check (<(50::Int))
05:08:12 <lambdabot>  Falsifiable, after 114 tests: 56
05:08:42 <Donner> Therefore it's much better to write own generators.
05:09:03 <nmessenger> ?type trace
05:09:05 <lambdabot> Not in scope: `trace'
05:09:10 <nmessenger> ?hoogle trace
05:09:11 <lambdabot> Debug.Trace.trace :: String -> a -> a
05:09:11 <lambdabot> Debug.Trace :: module
05:09:11 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
05:09:26 <nmessenger> try :m+ Debug.Trace Test.QuickCheck, quickCheck (\x -> trace (show x) True) :: Int -> Bool
05:10:23 <nmessenger> hmm, didn't work
05:11:15 <nmessenger> type in the wrong place
05:11:44 <nmessenger> quickCheck (\x -> trace (show (x::Int)) True)
05:12:41 <nmessenger> also :m + (with the space)
05:13:54 <nmessenger> strange that test cases get repeated
05:18:12 <nmessenger> ZOMG GREEN!
05:19:30 <syntaxfree> soylent grün ist menschenfleisch.
05:19:41 <nmessenger> oh noes!
05:19:52 <syntaxfree> what?
05:20:02 <nmessenger> soylent green is people?
05:20:34 <roconnor> soylent green is peopleflesh?
05:20:36 <syntaxfree> what, you've been eatin' it?
05:20:56 <nmessenger> not to my knowledge
05:21:12 <nmessenger> :D
05:21:50 <nmessenger> That's from the Oddworld games, right?
05:22:41 <chris2> how do i tell ghc to compile to position independent code with foreign ccall exports?
05:22:42 <syntaxfree> what?
05:22:47 <syntaxfree> http://en.wikipedia.org/wiki/Soylent_green
05:22:55 <Gotaku> How would I run a process and dump it's output to my screen?
05:25:13 * nmessenger tries to write Gotaku's code
05:33:22 <nmessenger> here's a start, but still doesn't work: http://hpaste.org/237  Anybody have any ideas?
05:34:22 <Gotaku> I tried all sorts of things and it still won't work.
05:35:24 <Gotaku> dons: You around?
05:37:34 <Itkovian_> syntaxfree: Wumpscut FTW ;-)
05:37:55 <Donner> @seen dons
05:37:56 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 58m 11s ago.
05:38:18 <kowey> Gotaku, nmessenger: replacing the fmap with =<< works on my machine
05:38:19 <lambdabot> kowey: You have 1 new message. '/msg lambdabot @messages' to read it.
05:39:21 <nmessenger> so it does
05:40:22 <Gotaku> Why doesn't haskell have something like the popen function?
05:40:41 <nmessenger> @type putStr `fmap` hGetContents undefined -- oh, duh
05:40:43 <lambdabot> Not in scope: `hGetContents'
05:40:54 <nmessenger> @type putStr `fmap` System.Process.hGetContents undefined -- oh, duh
05:40:56 <lambdabot> Not in scope: `System.Process.hGetContents'
05:40:57 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
05:40:59 <lambdabot> http://tinyurl.com/y5fbtr
05:41:05 <Cale> Gotaku: look there :)
05:41:07 * dcoutts notes that Bulat now has ADSL
05:41:16 <nmessenger> @type putStr `fmap` System.IO.hGetContents undefined -- oh duh?
05:41:18 <lambdabot> IO (IO ())
05:41:52 <Cale> you need the join after that, or else use bind which is a combination of fmap with join :)
05:42:02 <nmessenger> yes, I figured that :P
05:43:43 <trurl> nmessenger: why are you using waitForProcess?
05:44:04 <dylan> @type ((=<<) .)
05:44:05 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a1 -> a -> m b) -> a1 -> m a -> m b
05:44:07 <dancor> why aren't multi-param classes standard
05:44:11 <Gotaku> I don't understand what =<< does
05:44:16 <nmessenger> trurl: 'cause I'm a nutball!
05:44:43 <ski> :t putStr =<< System.IO.hGetContents undefined
05:44:45 <lambdabot> IO ()
05:44:54 <ski> :t (=<<)
05:44:56 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
05:44:57 <ski> :t ($)
05:44:59 <lambdabot> forall b a. (a -> b) -> a -> b
05:45:01 <nmessenger> Gotaku: (do str <- hGetContents o; putStr str) = putStr =<< hGetContents o
05:45:12 <trurl> Gotaku: a >>= b is equivalent to b =<< a
05:46:17 <dylan> @type ((=<<) .) filterM
05:46:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> m [a] -> m [a]
05:46:39 <dancor> i would like to define a serialization for types by making them Instance's of a ReadWrite class.  but i would also like to let that serialization depend on another thing (a serialization method).  i should use a multi-parameter class right?
05:46:41 <dylan> ^ useful function.
05:47:45 <Saizan> dancor: you want many seralization methods for each class?
05:47:53 <Saizan> s/class/type/
05:48:24 <dancor> Saizan: i want to allow ppl to drop in other types as needed yeah
05:48:38 <dancor> ahh other serialization methods, i mean
05:48:55 <dancor> like there's a binary one, a json one
05:49:44 <Gotaku> Ok, this works fine if the process writes to stdout then terminates but the process I want to run doesn't.
05:49:51 <dancor> but i need like ReadWrite Int BinaryMethod to define doRead t m
05:50:02 <nmessenger> Gotaku: does it need input before it writes output?
05:50:23 <dancor> if i just make it ReadWrite Int, then i can't define it for the two different methods right
05:51:17 <Gotaku> nmessenger: Yes.
05:51:31 <Odd_Bloke> Hi guys, I'm completely new to Haskell and I'm following a tutorial which, as an exercise, has asked me to write a recursive function which multiplies two numbers together using only addition. What I have so far is at http://pastebin.com/872724 but Hugs keeps segfaulting with that, so I'm clearly doing something wrong. Could someone cast an eye over it and give me a hand?
05:51:40 <Saizan> dancor: mmh yeah it seems to me that you need 2 parameters
05:51:52 <dancor> this is for hooking haskell into an rpc library that explicitly allows serialization method to be changed
05:52:02 <dancor> ok
05:52:10 <Gotaku> nmessenger: I send a string to it's input and should recieve a string from it's output.
05:52:22 <nmessenger> Gotaku: did you give it input first?  Maybe you should use the pastebin.
05:53:13 <Odd_Bloke> Actually, NM, I discovered a case of underbracketing in my arguments.
05:53:45 <Gotaku> nmessenger: I ask because I don't know how... if I use hGetContents it will just sit there blocking.
05:54:05 <ski_> (Odd_Bloke : .. and the second argument can't be negative)
05:55:13 <nmessenger> hGetContents I think gets all the output, so it'll block till the process terminates.  Perhaps you should piecewise hGetLine?
05:55:48 <Gotaku> Does haskell have a function like the C function getdelim?
05:55:51 <dylan> or liftM lines hGetContents?
05:57:06 <Saizan> Odd_Bloke: (mult a b-1) gets parsed as: ((mult a b) -1) so the recursion never ends
05:57:28 <Odd_Bloke> Saizan: Yeah, I just realised that.
05:57:46 <Saizan> Odd_Bloke: ah sorry, missed the line
06:00:18 <roconnor> apparently raster doesn't mean what I thought it meant.
06:01:01 <nmessenger> ?wn raster
06:01:03 <lambdabot> *** "raster" wn "WordNet (r) 2.0"
06:01:03 <lambdabot> raster
06:01:03 <lambdabot>      n : formation consisting of the set of horizontal lines composed
06:01:03 <lambdabot>          of pixels that is used to form an image on a CRT
06:01:57 <roconnor> the horizonal lines is an important part of the definition.
06:02:05 <roconnor> or was an imporant part of the definition
06:02:17 <roconnor> Perhaps the word will evolve.
06:02:18 <kowey> Gotaku: well, you could use something like takeWhile (/= delim)
06:02:33 <roconnor> But I thought it basically meant grid, or perhaps finite grid.
06:02:57 <nmessenger> likewise, I didn't know that it was specifically row-biased
06:03:09 <roconnor> but grids have a certain symetry between horizonal and vertical that the word raster doesn't really entail.
06:03:47 * dylan now tries to think of a pun involving raster-farians.
06:04:01 * nmessenger groans in advance
06:04:13 <roconnor> raster: [German, from Latin rÄstrum, rake (from the resemblance of the parallel lines to a rake's path).]
06:05:02 <dancor> is it possible to do like   class MyClass a b   but restrict b to some type
06:05:23 <roconnor> class Foo b => MyClass a b
06:05:33 <dancor> ah.  the obvious
06:05:46 <nmessenger> to some *class?
06:05:55 <dancor> yeah
06:05:59 <dancor> right
06:06:10 <roconnor> not entirely sure MPTC will like that
06:06:12 <dancor> i still don't know what a Kind is
06:06:30 <nmessenger> dancor: you know what a type constructor is?
06:06:30 <dylan> dancor: a kind is the type of a type.
06:06:37 <roconnor> Kinds is the type of type constructors
06:06:40 <dylan> or the type of a type constructor.
06:06:58 <nmessenger> Int :: *, Maybe :: * -> *, Maybe Int :: *
06:07:08 <nmessenger> :: "has kind"
06:07:17 <roconnor> @kind StateT
06:07:18 <lambdabot> * -> (* -> *) -> * -> *
06:07:21 <erider> gm all from Bogota
06:08:03 <dancor> ok
06:08:14 <dancor> roconnor: MPTC?  ghc liked it
06:08:22 <dancor> ate it right up
06:08:30 <roconnor> MPTC means multi-parameter type classes
06:08:33 <nmessenger> it's useful for example if you want to specify type 'T a b c' but restrict 'b' to a second-kind type constructor
06:08:43 <roconnor> Normally type classes can only take one parameter.
06:08:55 <dancor> roconnor: yeah it worked with that
06:08:59 <nmessenger> {-# OPTIONS_GHC -fglasgow-exts #-}
06:09:12 <dancor> oh should i put that in the file
06:09:18 <dancor> instead of my makefile
06:09:25 <nmessenger> dancor: either should be fine
06:09:29 <dancor> k
06:09:45 <roconnor> it's a bit more reusuable when you put it in the file.
06:10:07 <nmessenger> I find that the closer metadata is to its data, the more likely it'll be kept correct.
06:10:30 <dancor> that is certainly true
06:10:59 <dancor> do i need that only in the file defining the MPTC
06:11:03 <dancor> or in any file using it
06:11:29 <nmessenger> not sure, not used MPTCs
06:11:31 <roconnor> I
06:11:37 <roconnor> I'm not certain.
06:11:41 <dancor> k
06:11:49 <roconnor> I usually put it in any file that GHC complains about ;)
06:11:55 <nmessenger> apostrophe next to return, brilliant design. :)
06:12:06 <roconnor> nmessenger: ;)
06:12:14 <Gotaku> I just can't figure out how to get the output of a running process without having my program block indefinitely.
06:12:29 <nmessenger> ?paste your code Gotaku!
06:12:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:16:10 <Gotaku> http://hpaste.org/238
06:17:57 <nmessenger> what's gnugo?  Could you paste annotate a typical interactive session?
06:18:13 <dancor> if   class CanYay x where yay :: IO ()   how do i specify yay in CanYay Int vs CanYay String
06:19:13 <nmessenger> doesn't 'x' need to be used in each method?
06:19:43 <Odd_Bloke> I'm now having a different issue. I'm taking input a line at a time and then attempting to treat it as a number (and, indeed, the input is intended to be a number). However, it's currently being treated as a Char. Am I doing something wrong, or is there a quick fix for this?
06:19:59 <nmessenger> ?index readLn
06:20:00 <lambdabot> System.IO, Prelude
06:20:07 <nmessenger> ?hoogle readLn
06:20:08 <lambdabot> Prelude.readLn :: Read a => IO a
06:20:26 <roconnor> cool
06:20:30 <roconnor> I didn't know that
06:20:48 <nmessenger> > do numberString <- getLine; let number = read numberString -- or this
06:20:49 <lambdabot>  Parse error
06:20:59 <nmessenger> @type read
06:21:01 <lambdabot> forall a. (Read a) => String -> a
06:21:18 <Gotaku> nmessenger: http://hpaste.org/239
06:21:31 <roconnor> readLn looks like what Odd_Bloke is looking for
06:22:41 <Odd_Bloke> > do numberString <- readLn; let number = read numberString --?
06:22:42 <lambdabot>  Parse error
06:22:58 <nmessenger> readLn does both getLine and read
06:23:18 <Odd_Bloke> Ah, OK.
06:23:20 <nmessenger> read turns a string into a number (or any instance of the Read class)
06:24:17 <nmessenger> Gotaku: maybe you should hPutStr the first inputs, then takeWhile (/= delim) then output.
06:24:17 <dancor> i guess i can only use yay if there is an instance of CanYay a?
06:24:53 <dancor> and i can _never_ use yay defined on any limited instance (like CanYay String) ?
06:24:54 <nmessenger> dancor: instance CanYay Int where yay = putStr "yay!" -- but I still thought that class was invalid
06:25:09 <dancor> nmessenger: that compiles
06:25:21 <dancor> nmessenger: but if you call it
06:25:38 <dancor> ghc says that there is no instance for CanYay a
06:26:00 <dancor> even though there is one for CanYay Int
06:26:26 <Gotaku> nmessenger: I don't have to send any input right now... to start I'm just trying to print the first line of the output.
06:26:36 <dancor> ok well this is complicated because i actually have a MPTC
06:26:50 <nmessenger> well, yeah, you need an implementation if you want to call a function, can you put a default one in the class?
06:27:15 <dancor> basically i'm writing a "skip" function that skips over the type (in the given serialization)
06:27:27 <dancor> so i don't want it to take the type or return it
06:27:35 <dancor> but i guess that's not possible
06:27:48 <nmessenger> Gotaku: maybe try terminating gnugo after reading the first line?
06:27:52 <dancor> since it becomes uncallable
06:28:05 <dancor> if it is not connected to the type in some way
06:28:50 <Gotaku> nmessenger, But that isn't my goal. I want to read the first line of output of a running process.
06:28:57 <nmessenger> dancor: couldn't you do 'yay :: CanYay a => a -> IO(); yay _ = blah'
06:29:35 * nmessenger tries piping 'dir' through 'more' and reading
06:31:29 <nmessenger> It worked for me, I'm sorry but I can't help specifically with gnugo :(
06:32:04 <Gotaku> piping dir through more will terminate unless you run it in a directory with lots of files.
06:32:12 <nmessenger> aye, and I did
06:33:02 <Gotaku> What's your code?
06:33:58 <Odd_Bloke> I've tried using readLine to no avail. My original code is at http://pastebin.com/872749 and the error message I'm receiving is at http://pastebin.com/872750. I'd appreciate it if someone could give them a quick look.
06:36:12 <nmessenger> http://hpaste.org/238#a1
06:38:07 * nmessenger looks at Odd_Bloke's code
06:39:10 <Odd_Bloke> \o\ |o| /o/
06:40:27 <roconnor> @type getLine
06:40:30 <lambdabot> IO String
06:40:36 <roconnor> @type readLn
06:40:38 <lambdabot> forall a. (Read a) => IO a
06:41:20 <nmessenger> Odd_Bloke: ah!  the use of the result in doOutput infers it to be a [String].  Add 'show' around the folded sum.
06:42:03 <nmessenger> putStrLn("The sum of the entered numbers is: " ++ show (foldr (+) 0 input) ++ ".")
06:42:24 <nmessenger> type annotations are your friend when debugging type troubles
06:42:57 <roconnor> doOutput :: Num a => a -> IO ()
06:43:09 <Gotaku> Why won't this work? It's really starting to piss me off.
06:43:21 <Odd_Bloke> nmessenger: Thanks!
06:43:36 <nmessenger> @type show -- the opposite of read
06:43:38 <lambdabot> forall a. (Show a) => a -> String
06:43:53 * roconnor has never used runInteractive
06:45:50 <Gotaku> There is no reason I can see why this doesn't work.
06:47:04 <Gotaku> How do I read the first line of text from a still running process?
06:47:39 <Gotaku> This works: http://hpaste.org/240
06:47:47 <Gotaku> But if I remove the -v argument it doesn't.
06:47:56 <Gotaku> It just sits there blocking.
06:48:07 <roconnor> @hoogle runInteractive
06:48:09 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
06:48:09 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
06:48:16 <roconnor> @docs System.Process
06:48:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
06:49:13 <roconnor> according to the docs, you should be using forkIO
06:49:22 <roconnor> For example, to start a process and feed a string to its stdin:
06:49:22 <roconnor>    (inp,out,err,pid) <- runInteractiveProcess "..."
06:49:22 <roconnor>    forkIO (hPutStr inp str)
06:49:44 <Gotaku> ...
06:49:50 <Gotaku> I'm not trying to feed it a string.
06:50:13 <roconnor> wait,you are using runInteractiveCommand, not runInteractiveProcess?
06:50:30 <Gotaku> Yes.
06:50:46 <Gotaku> Not that it makes any difference.
06:50:53 <ToRA> Gotaku: http://hpaste.org/240#a1
06:50:58 <earthy> gotaku: do hSetBuffering i NoBuffering
06:51:28 <ToRA> Gotaku: i actually get some output...though it's not normal characters
06:51:29 <earthy> that works at least for me. ;)
06:52:24 <earthy> by setting the input of the interactive process to be unbuffered it will not wait for the input buffer to fill
06:52:44 <earthy> therefore generating its output lines without waiting for input from you
06:52:58 <Gotaku> Eh?
06:53:23 <earthy> http://hpaste.org/238#a2
06:53:55 <earthy> not sure if that'll help with gnugo, but it does with ls. ;)
06:54:17 <Gotaku> earthy that doesn't work...
06:54:42 <earthy> why not, I wonder.
06:54:55 <earthy> does gnugo output to stdout at all?
06:55:01 <Saizan> ?type forkIO
06:55:02 <lambdabot> Not in scope: `forkIO'
06:55:15 <Saizan> ?hoogle forkIO
06:55:16 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
06:55:17 <nmessenger> earthy: http://hpaste.org/239
06:55:43 <Cale> If no terminal is detected, gnugo will assume that you want to talk to it in Go Modem Protocol
06:56:05 <earthy> *ah*. see. ;)
06:56:06 <nmessenger> try 'gnugo --help'?
06:56:36 <earthy> I'm gonna guess Go Modem Protocol is not line-oriented. ;)
06:56:43 <Gotaku> With no args gnugo plays a ascii game.
06:57:07 <Odd_Bloke> If, at the end of a recursion, I just want the function to return back up the stack without doing anything, what should I use?
06:57:31 <earthy> Odd_Bloke: what the *hell* do you mean? :)
06:57:44 <Odd_Bloke> earthy: I often wonder. :p
06:57:51 <nmessenger> dontDoAnything = const ()
06:57:52 <Cale> Odd_Bloke: you return a value?
06:57:56 <Saizan> ghc should be able to garbage-collect the head of a list when traversed with mapM_, right?
06:58:02 <beschmi> roconnor: really liked your TMR article, do you think it would be feasible to use your assembler EDSL approach for a "portable assembler" like http://cr.yp.to/qhasm.html
06:58:04 <lambdabot> Title: qhasm: tools to help write high-speed software
06:58:13 <earthy> no, honestly, you seem to be mistakenly confusing functional and imperative code
06:58:13 <Gotaku> earthy, gnugo does output to stdout: http://hpaste.org/239
06:58:16 <Cale> Odd_Bloke: and use tail recursion -- that is, you ought to just be calling yourself.
06:58:34 <earthy> and the 'not doing anything' sound suspiciously like 'not have any side effects'
06:58:35 * nmessenger says hello to nmessenger
06:58:43 <Odd_Bloke> earthy: Having been programming functionally for around 24 hours now, that's more than a little possible...
06:58:52 <Cale> So something like  foldl f z [] = z; foldl f z (x:xs) = foldl f (f z x) xs
06:59:04 <earthy> Gotaku: it does to a terminal. runInteractiveProcess does not provide a terminal
06:59:07 <Cale> foldl is a good example of a tail recursive function
06:59:10 <roconnor> beschmi: I'm not really sure how well my assembler would scale up from toy exercise.  I don't have a lot of faith.
06:59:21 <Cale> It calls itself with new parameters until it reaches the end of the list.
06:59:41 <nmessenger> runInteractiveCommand mentions using the shell, maybe that would work?
06:59:44 <roconnor> beschmi: you know about c minus minus?
06:59:53 <Odd_Bloke> Cale: How does it work out when it's reached the end of the list?
06:59:54 <Cale> But this isn't *really* how you want to think about it most of the time. Thinking about things equationally is much more effective.
07:00:01 <Cale> Odd_Bloke: It pattern matches.
07:00:11 <beschmi> roconnor: ok, i really like how you can write assembler macros in haskell
07:00:25 <Cale> foldl (+) 0 [1,2,3]
07:00:25 <roconnor> beschmi: it was a lot of fun!
07:00:33 <Gotaku> earthy: So what can I do about that?
07:00:34 <Cale> = foldl (+) (0 + 1) [2,3]
07:00:35 <nmessenger> assembler in haskell?!  blasphemy!  o.O
07:00:41 <Cale> = foldl (+) ((0+1)+2) [3]
07:00:48 <Cale> = foldl (+) (((0+1)+2)+3) []
07:00:54 <Cale> = ((0+1)+2)+3
07:01:00 <Cale> = (1+2)+3
07:01:01 <roconnor> beschmi: I started asking about doing circular programming with Monads, and someone here mentioned MonadFix.
07:01:02 <Cale> = 3+3
07:01:04 <Cale> = 6
07:01:09 <Cale> See how that works?
07:01:21 <roconnor> It took me a while to figure out how to use mdo, but the results were amazing.
07:01:49 <roconnor> nmessenger: it's just one more step to having an entire Haskell based programming chain. ;)
07:01:49 <Cale> roconnor: mdo is easier to use at first if you don't think too hard about what's actually happening
07:01:49 <earthy> gotaku: try changing the call to   runInteractiveProcess "gnugo" ["--mode ascii"] Nothing Nothing
07:01:53 <beschmi> roconnor: i think its a bit too high level compared to qhasm, but i haven't looked in detail
07:02:08 <earthy> nmessenger: have you not read the monad.reader number 6?
07:02:12 <Odd_Bloke> Cale: Yeah.
07:02:16 <nmessenger> earthy: nope
07:02:22 <roconnor> Cale: it is now clear to me what mdo is doing ... Time travel!
07:02:24 <earthy> do :)
07:02:25 <beschmi> roconnor: yeah, i wondered about MonadFix when i read the mtl sources, but didn't look it up at the time
07:02:38 <beschmi> roconnor: now i know what it's good for
07:02:40 * nmessenger heads off
07:02:41 <Odd_Bloke> But my question is when it works out that it has an empty list remaining, how does it stop recursing?
07:02:51 <Cale> Odd_Bloke: foldl f z [] = x
07:02:52 <Cale> er
07:02:54 <Cale> Odd_Bloke: foldl f z [] = z
07:03:04 <Cale> That equation isn't recursive.
07:03:06 <earthy> um. it doesn't call itself anymore.
07:03:15 <earthy> that's good enough, isn't it? :)
07:03:39 <roconnor> The important thing about programming in Haskell is to totally forget about the computer.
07:03:41 <Cale> Each of the equations are tried in turn. The first one to match wins.
07:03:44 <Gotaku> earthy... That works. But I don't understand the --help says the default is ascii.
07:03:58 <Cale> foldl f z [] = z
07:04:07 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
07:04:08 <Odd_Bloke> earthy: Yeah, but if I just leave it blank then I have 'then else recursiveFunction'. What goes between the then and the else to tell it to, effectively, do nothing?
07:04:15 <Cale> only the second equation here is recursive
07:04:24 <Cale> and it requires that the list is nonempty
07:04:27 * Odd_Bloke understands recursion.
07:04:31 <Cale> but it calls itself with a shorter list
07:04:37 <earthy> Odd_Bloke: your return value for the empty case, obviously
07:04:37 <Gotaku> I guess it means the default is ascii if no terminal is detected, otherwise it uses gmp... I guess I got confused.
07:04:45 <Cale> So eventually, it's going to call itself with an empty list (given that the list is finite)
07:04:47 <earthy> Gotaku: exactly
07:04:57 <Cale> and when it does, the 'z' parameter will be returned
07:05:21 <earthy> you *do* know what the value to be returned for the base case is, don't you?
07:05:25 <Odd_Bloke> earthy: Well, as it recurses it's outputting and I don't want to output anything at this point.
07:05:34 <Cale> It's not outputting anything.
07:05:43 <Odd_Bloke> Cale: In IO terms.
07:05:47 <earthy> oh, your type is something like  dosomething :: [a] -> IO () ?
07:06:03 <earthy> dosomething [] = return ()
07:06:08 <Cale> Oh, okay, you're talking about doing actual IO as well :)
07:06:28 <earthy> dosomething (x:xs) = doprint x >> dosomething xs
07:06:28 <earthy> ?
07:06:37 <nmessenger> return () is the no-op in IO
07:06:37 <nmessenger> or close enough
07:06:38 <Cale> er, I think I know what sort of example he wants
07:06:49 <Cale> you have an if foo then ... else ...
07:07:02 <Cale> and you want one of the branches to stop recursing?
07:07:10 <Cale> and the other to continue?
07:07:23 <Cale> To stop recursing, put something like  return ()
07:07:23 <earthy> oh, dosomething xs = if null xs then return () else doprint (head xs) >> dosomething (tail xs)
07:07:34 <Gotaku> What's the difference between runInteractiveProcess/Command?
07:07:37 <Cale> return () is a no-op
07:07:55 <Odd_Bloke> Right, that's what I was looking for.
07:07:58 <Odd_Bloke> Thanks guys.
07:07:59 <trurl> Gotaku: ...Command runs the command via the shell
07:08:02 <Cale> Gotaku: Command passes the string to the shell.
07:09:17 <Cale> I'm not having much luck even with setting gnugo into ascii mode.
07:09:18 <nmessenger> @hoogle runInteractive
07:09:19 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
07:09:19 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
07:09:30 <Cale> (and turning off all buffering)
07:09:50 <roconnor> dosomething xs = unless (null xs) (do print (head xs) >> dosomething (tail xs))
07:09:59 <Cale> oh, nevermind
07:10:03 <Cale> I was reading stderr
07:10:09 <Cale> It works fine
07:10:12 <nmessenger> silly Cale :P
07:10:15 <roconnor> dosomething xs = unless (null xs) (print (head xs) >> dosomething (tail xs))
07:10:45 <chessguy> 'morning haskellers
07:10:47 <int-e> @type let dosomething xs = unless (null xs) (print (head xs) >> dosomething (tail xs)) in (dosomething, mapM_)
07:10:49 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m, Show a) => ([a] -> IO (), (a1 -> m b) -> [a1] -> m ())
07:11:20 <int-e> Ah I guess I wanted  mapM_ print
07:11:26 <Gotaku> Is there a function like C's getdelim? I need to read a string until \n\n is reached.
07:12:06 <Saizan> ?hoogle getLine
07:12:07 <lambdabot> Prelude.getLine :: IO String
07:12:07 <lambdabot> System.Console.Readline.getLineBuffer :: IO String
07:12:07 <lambdabot> System.Console.SimpleLineEditor.getLineEdited :: String -> IO (Maybe String)
07:12:21 <Saizan> ah, \n\n
07:12:45 <Cale> unlines . takeWhile (not . null) . lines
07:12:51 <Cale> @type unlines . takeWhile (not . null) . lines
07:12:53 <lambdabot> String -> String
07:13:08 <Cale> @type unlines . takeWhile (not . null) . lines $ "Hello\nWorld\n\nFoo!"
07:13:10 <lambdabot> String
07:13:14 <Cale> > unlines . takeWhile (not . null) . lines $ "Hello\nWorld\n\nFoo!"
07:13:17 <lambdabot>  "Hello\nWorld\n"
07:13:48 <Cale> Ah, right, unlines always leaves a newline after every line.
07:14:00 <Cale> If you don't like that, it's easy to fix.
07:14:10 <Gotaku> That shouldn't be a problem, thanks.
07:14:35 <chessguy> hey Cale, thanks for the interesting response to my recursion thread
07:14:37 <nmessenger> unlines {-should-} = concat . intersperse "\n"
07:15:08 <Cale> chessguy: On the mailing list, was it?
07:15:14 <int-e> > lines "\n" -- should produce ["",""] to match that?
07:15:14 <nmessenger> unlines . lines = (++"\n")
07:15:16 <lambdabot>  [""]
07:15:23 <chessguy> Cale,  yes. -cafe
07:15:37 <Cale> ah, so you're Andrew Wagner then :)
07:15:39 <chessguy> regarding raw recursion vs. recursion via map, foldr, etc.
07:15:41 <chessguy> indeed
07:16:00 <chessguy> for better or worse :)
07:17:32 <int-e> @check \xs -> (unlines . lines) xs == xs ++ "\n"
07:17:34 <lambdabot>  Falsifiable, after 3 tests: ""
07:17:53 <chessguy> Cale, i was a little disappointed by the lack of much response
07:18:59 <int-e> nmessenger: lines isn't invertable, it's meant to be used on strings that end in \n. unlines matches that.
07:20:35 <emu> reading these math blogs, i realize there is a great need for blogs with math typesetting support
07:21:24 <nmessenger> @check (\xs -> let ys = xs ++ "\n" in (unlines . lines) ys == ys) :: String -> Bool
07:21:26 <lambdabot>  OK, passed 500 tests.
07:21:35 <int-e> > map head . takeWhile (not . isPrefixOf "\n\n") . init . tails $ "abc\ndef\n\nghi\njkl"
07:21:36 <lambdabot>  "abc\ndef"
07:22:11 <Cale> chessguy: Yeah, I don't know. I get the feeling that it was something which used to be covered better.
07:22:32 <Cale> chessguy: Now everyone's into the idea that we should teach IO first, which I think is silly.
07:23:13 <Cale> You need to teach lists first. There are also lots of people who don't understand that lists aren't just another data structure, but are quite possibly the most important one.
07:23:24 <emu> @src fix
07:23:24 <lambdabot> fix f = let x = f x in x
07:23:47 <Cale> Cons-lists essentially capture linear recursion, which is by far the most common.
07:23:57 <chessguy> Cale,yes
07:24:30 <chessguy> i agree about IO, especially since ghcI is ghc_I_. it's interactive by nature
07:24:31 <fasta> Is there something like whileM similar to forM_ ?
07:25:01 <int-e> @index unfoldM
07:25:02 <lambdabot> bzzt
07:25:06 <allbery_b> ?type until
07:25:08 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:25:12 <allbery_b> hm, no
07:25:33 <emu> sequence_ . takeWhile f . iterate?
07:25:41 <fasta> I am not working with lists.
07:26:25 <nmessenger> @type \f -> sequence_ . takeWhile f . iterate
07:26:26 <lambdabot>     Expecting a function type, but found `b'
07:26:27 <lambdabot>       Expected type: (a1 -> a1) -> [a]
07:26:29 <fasta> I should be able to write whileM (return False) <do something>
07:26:45 <Cale> fasta: no, but there ought to be.
07:26:46 <emu> na that wont work
07:26:50 <fasta> I can write it myself.
07:26:59 <Cale> yeah.
07:27:00 * fasta is writing imperative code very compactly in Haskell :)
07:27:09 <matthew_-> !paste
07:27:14 <nmessenger> ?seen hpaste
07:27:15 <lambdabot> I saw hpaste leaving #haskell 5h 44m 45s ago, and .
07:27:18 <Cale> Haskell is quite possibly the finest imperative language available today :)
07:27:19 <glguy> hmm
07:27:21 <roconnor> Cale: I've been thinking that we should write a tutorial about how to write Haskell tutorials.
07:27:23 <matthew_-> wah!
07:27:32 <Cale> roconnor: That's an idea.
07:27:42 <nmessenger> ?google haskell metatutorial
07:27:42 <Cale> roconnor: I'm writing a book.
07:27:44 <chessguy> lol
07:27:44 <int-e> roconnor: is there a tutorial for that?
07:27:45 <fasta> about 35 lines for a complete connected components implementation including the traversal and imports etc.
07:27:45 <lambdabot> http://www.haskell.org/haskellwiki/MetaTutorial
07:27:46 <lambdabot> Title: Meta-tutorial - HaskellWiki
07:27:48 <roconnor> There are lots of haskell tutorials of various qualities
07:27:49 <beschmi> fasta: there is one in House http://hpaste.org/241
07:28:06 <Cale> (which should make use of many of the ideas I've had about teaching Haskell)
07:28:14 <fasta> beschmi: Thanks
07:28:18 <roconnor> So we need to gather the knowledge we have all gained about writing Haskell tutorials into one document.
07:28:48 <Cale> The hardest problem for me right now is how to really properly introduce types and values.
07:29:00 <Cale> The very early bootstrapping material is tricky.
07:29:21 <roconnor> That wiki entry isn't really a Metatutorial.
07:29:30 <dino-> Cale: One thing I'll note is, when reading your _Monads as Containers_, the first part is fantastic. One of the clearest things I've read about it. And then the Reader part drives me insane. :o
07:29:39 <chessguy> Cale, i've had a couple ideas about teaching haskell too, from the perspective of newbies
07:30:03 <Cale> dino-: Yeah, I'd intended the reader part and after as sort of an addendum.
07:30:03 <moonlite> i'm going to hold a talk tomorrow in a class im attending, on a recent research paper regarding programming languages, unfortunately my first choice (Software Transactional Memory) was rejected since most students in the group already had been taught that in another course. Anyhow, a deadline and being ill for a week put me in the position of having only today to chose and prepare the speak. :)
07:30:22 <nmessenger> Yeah, it's more of a "how to find a tutorial" tutorial
07:30:39 <dino-> I'm not sure if it's because Reader (and other monads-as-computations) just don't play well with the container analogy or what.
07:30:44 <moonlite> So, any suggestions? The paper on ByteStrings was ok and was passed, anything remotely like that would be really neat. :)
07:30:45 <chessguy> one is what i talked about with respect to recursion - just spending a lot more time on HOFs and the abstraction of recursion than just "Here's map. Here's foldr. Have fun"
07:30:52 <Cale> moonlite: *Most* of them had been introduced to STM? That's interesting.
07:31:33 <moonlite> Cale: yeah, most students attend Advanced Functional Programming, and Koen Claessen runs that course. so yeah. :)
07:31:38 <Cale> ah
07:32:10 <Cale> So they all know about monads. How about comonads or arrows?
07:32:25 <Cale> That's less practical than ByteStrings for the time being though :)
07:33:00 <glguy> dino-: Reader is the most basic "Monad as Container" , it contains one value, and you can't even change that value!
07:33:05 <nmessenger> so practicality is proportional to specificity?
07:33:05 <chessguy> the other thing i would really want from a newbies book for haskell is to really cover type classes thoroughly before monads. i think having a thourough understanding of type classes makes the idea of monads much clearer. it took me a while before i went "oh, a monad is just a type class"
07:33:24 * dino- cries.
07:33:25 <moonlite> yes that would be nice. Are there any _recent_ papers on them though? The best paper on Arrows i found was the one Hughes wrote, and 42 pages seemed a bit much to digest for a speech to hold tomorrow. :)
07:33:52 <moonlite> i'll check up on comonads now though
07:34:02 <dino-> Well, I just spent an intense week with YAHT's simple state monad thing and I actually get it this time.
07:34:09 <nmessenger> ?google Cellular Automata is comonadic
07:34:14 <fasta> How hard is would it be to traverse over a datatype definition, and automatically generate "setters" too? (with the help of modify)
07:34:15 <lambdabot> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
07:34:15 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
07:34:15 <Cale> nmessenger: hehe -- practicality of abstractions is measured by the average over all specific examples of the practicality of the example.
07:34:26 <dino-> I guess the (->) business in MaC (Monads as Containers) started to lose me.
07:34:43 <Cale> dino-: yeah, it's much harder to digest, I know :)
07:34:45 <chessguy> fasta, isn't that what named fields are for?
07:35:06 <Cale> dino-: I was tackling the *hard* examples of the Monads as Containers view there.
07:35:09 <fasta> chessguy: Named fields only work for getters
07:35:21 <chessguy> fasta, no, i think you're wrong
07:35:24 <fasta> chessguy: Haskell' intends to generalize it, IIRC
07:35:33 <glguy> myvar { myfield = "someval" }
07:35:48 <fasta> chessguy: I know I am not wrong in this particular case.
07:35:50 <Cale> chessguy: yes, yes, yes. Typeclasses need to be introduced *really* early on.
07:35:57 <fasta> glguy: Yes, I am aware of that.
07:36:03 <boegel> fasta, chessguy: your names sound like benchmarks I use ;-)
07:36:04 <nmessenger> Cale: but not before types!
07:36:07 <Cale> Like, everyone should know what class contexts mean after the first lecture.
07:36:18 <Cale> Sure, types also need to be very early.
07:36:22 <glguy> fasta: HAppS defines: withField and a_field
07:36:26 <nmessenger> oh, among more learned folks?
07:36:30 <Cale> Types and values are the first thing which needs to be learned.
07:36:31 <glguy> fasta: a_field being a direct setter
07:36:47 <glguy> fasta: using Template Haskell
07:36:49 <Cale> I'm talking about in an ideal Haskell tutorial
07:36:52 <chessguy> fasta, ok, i'm misunderstanding then. how is what you want different from the line glguy gave: myvar { myfield = "someval" }
07:36:52 <Cale> Or course.
07:37:06 <chessguy> Cale, class contexts
07:37:07 <chessguy> ?
07:37:11 <Cale> (Ord a) =>
07:37:14 <glguy> fasta: HAppS calls that function inferRecordUpdaters
07:37:25 <fasta> glguy: ok, I will download HApps, and grep it for inspiration. :)
07:37:26 <hpaste>  csci pasted "Searching for a design pattern" at http://hpaste.org/242
07:37:29 <nmessenger> The problem, though, is that learning "types", "values", "classes" and such is all very abstract, so it's hard to understand without concrete examples.
07:37:53 <csci> Hi, would be nice if someone could take a look at hpaste's. It's a design-/syntax(?) question
07:37:56 <Cale> Right, so you need to introduce values along with them. The hardest part is that there's so much syntax involved with values.
07:37:58 <nmessenger> And making useful concrete examples often requires an interaction of many of those things.
07:38:03 <fasta> chessguy: try to work in a monadic context, and you will see.
07:38:05 <Cale> Yeah.
07:38:30 <Cale> However, I still think it's very important to get a basic understanding of what those things mean laid down very early.
07:38:32 <Igloo> Should   ByteString -> (Word8, ByteString)   be called headTail or unCons? Vote now!
07:38:43 <nmessenger> http://hpaste.org/242
07:38:56 <Igloo> Err, I mean: Should   ByteString -> Maybe (Word8, ByteString)   be called headTail or unCons? Vote now!
07:38:58 <glguy> csci: if you are trying to hide a variable, you could use the Reader monad
07:39:07 <fasta> glguy: HApps actually starts to sound more practical by the day.
07:39:07 <Saizan> unCons!
07:39:10 <Cale> Because they will see those things in their error messages, and when they use :t
07:39:12 <fasta> unDons!
07:39:15 <fasta> ;)
07:39:22 <Cale> And the ability to use :t is really important.
07:39:23 <csci> glguy, Ok, Thanks. Till now I only now the IO monad :) In what module do I find it?
07:39:32 * Igloo has no desire to take dons apart
07:39:39 <glguy> csci: Control.Monad.Reader
07:39:44 <chessguy> fasta, ah ok, thanks for the explanation
07:39:47 <csci> glguy, Argh, obviously. Thanks :)
07:39:54 <velco> unConscious
07:40:17 <chessguy> boegel,you do chess stuff as benchmarks?
07:40:21 * Igloo makes a mental note not to ask #haskell a serious question in the future  :-)
07:41:10 <glguy> Igloo: I like headTail in the spirit of divMod
07:41:17 <glguy> :t divMod -- that's a function, right?
07:41:19 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
07:41:29 <int-e> :t quotRem
07:41:31 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
07:41:31 <nmessenger> divMod should be unMultiply!
07:41:40 <glguy> I use uncons in the spirit of uncurry
07:41:42 <Cale> Is it possible to implement that more efficiently than (head *** tail) ?
07:41:44 <int-e> nmessenger: multiplyAdd?
07:41:56 <fasta> boegel: I always use boegels to scare people.
07:42:04 <int-e> Igloo: I'd vote for unCons, it's shorter ;)
07:42:15 <Igloo> Cale: It makes the code slightly nicer as you don't have to do the is-it-null test explicitly yourself
07:42:24 <Cale> Igloo: ah, okay
07:42:45 <Cale> headTail
07:43:07 <Cale> unCons is a bit disingenuous, since there's no real cons-cell there.
07:43:11 <glguy> (in my code: uncons f (x:xs) = f x xs)
07:43:51 <glguy> :type uncurry
07:43:56 <nmessenger> Cale: what? isn't (:) the cons constructor?
07:43:59 <glguy> :t uncurry
07:44:01 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
07:44:03 <Cale> If I was going to have an unCons in the ByteString libraries, I'd have it detach the first strict bytestring from the start of a lazy one.
07:44:08 <Cale> nmessenger: yes it is
07:44:11 <emu> Igloo: similar functions for Sets are called things like minView
07:44:15 <nmessenger> oh, for ByteStrings.
07:44:16 <Cale> nmessenger: We're talking about bytestrings.
07:44:59 <emu> that implies ordering based on the elements, while the ordering here is simply a sequence
07:45:17 <dino-> (late to this convo) Cale: I think it's great you're talking about writing more educational material. The monad thing is very good.
07:45:23 <int-e> hmm. in the spirit of Data.Sequence, viewl  would be an option (naa, not seriously)
07:45:56 <glguy> int-e: viewl isn't such a bad idea (iff you are implementing all of ViewL)
07:46:11 <dino-> I would be in bad shape if it wasn't for these documents. YA, All About, etc..
07:46:26 <glguy> yeah... documentation is key
07:46:46 <Igloo> Cale: There is a cons function, though
07:46:53 <emu> yet another all about you could have invented meta monads tutorial
07:46:56 <chessguy> ?hoogle cons
07:46:57 <lambdabot> Prelude.const :: a -> b -> a
07:46:57 <lambdabot> Data.PackedString.consPS :: Char -> PackedString -> PackedString
07:46:57 <lambdabot> Data.Generics.Basics.constrFields :: Constr -> [String]
07:47:02 <Cale> dino-: Yes, I'm writing a book. I haven't decided how I want to license it yet though. I may want to find a publisher when I'm done.
07:47:06 <Igloo> Thanks for all the opinions, anyway
07:47:29 <chessguy> Cale, when do you expect that to be?
07:47:40 <nmessenger> emu: from Mars!
07:47:53 <Cale> I'm not sure. Some parts go faster than others.
07:48:11 <int-e> glguy: there's the problem that you can't make ByteString an instance of Foldable.
07:48:26 <Donner> What is the difference between "seq" and "seq' _ = id :: !a -> b -> b" ?
07:48:37 <int-e> glguy: so ... well ... viewl would be promising too much, I think.
07:48:59 <Igloo> Donner: Does anything support ! on types like that?
07:49:13 <Igloo> Donner: I suspect the answer is nothing, though
07:49:15 <Cale> Donner: you can't write the second one.
07:49:55 <Cale> seq can be implemented for certain concrete types by pattern matching
07:49:59 <int-e> well, with bang patterns you could write  seq !_ b = b; bang patterns are fairly new though.
07:50:10 <Cale> Bang patterns translate into seq though.
07:50:24 <int-e> I'm not sure if this is semantically the same.
07:50:31 <nmessenger> ah! infinite recursion!
07:51:01 <nmessenger> why can't ByteString be Foldable?
07:51:23 <int-e> nmessenger: because it's not an arbitrary list; the types of the list elements are restricted
07:52:36 <nmessenger> ah, of course
07:53:10 <emu> the hitchhiker's guide to yet another tour of the haskell road to logic, maths, and two dozen short lessons on tackling the awkward craft of functional monstrous monadic lovers who could have invented the systematic design of monad transformers step by step - Don't Panic
07:53:41 <Donner> Ah, I see. It's not possible with a strict datatype to define seq, because the datatype is not evaluated. ...
07:53:45 <emk> emu: Heh.
07:53:58 <chessguy> ?remember emu  the hitchhiker's guide to yet another tour of the haskell road to logic, maths, and two dozen short lessons on tackling the awkward craft of functional monstrous monadic lovers who could have invented the systematic design of monad transformers step by step - Don't Panic
07:53:59 <lambdabot> Done.
07:54:10 <int-e> Cale: interestingly you can (or could) use bang patterns on unboxed types, so I suspect it actually taps into the strictness analysis pass directly.
07:54:29 <emu> next time someone asks for a tutorial....
07:54:34 <Saizan> emu: you sould make a turial name generator as a lambdabot plugin :D
07:56:00 <emu> ?tutorial
07:56:01 <lambdabot> Unknown command, try @list
07:57:52 <chessguy> ?where tutorial
07:57:53 <lambdabot> http://www.haskell.org/tutorial/
07:58:44 <Saizan> does iterate memoize the intermediate steps?
07:58:53 <Donner> Message-ID: <bhj794xum.ln2@msgid.7eggert.dyndns.org>
07:59:21 <emu> they are thunks
07:59:28 <Donner> Sorry, wrong channel. Don't paste using pointing devices.
07:59:38 <kosmikus> ?src iterate
07:59:38 <lambdabot> iterate f x =  x : iterate f (f x)
07:59:42 <kosmikus> Saizan: ^^
07:59:44 <nmessenger> words to live by.
07:59:59 <Saizan> kosmikus: so, no!
08:00:17 <kosmikus> Saizan: er, yes. or I don't understand what you mean.
08:00:47 <hpaste>  (anonymous) annotated "Searching for a design pattern" with "(no title)" at http://hpaste.org/242#a1
08:00:50 <kosmikus> but I have to leave ...
08:01:41 <nmessenger> csci: Ha$kell?
08:02:50 <Saizan> iterate f x = [x.f x,f (f x), f (f (f x)... as per that definition, so if i consume the list f gets applied n(n+1)/2 times
08:03:03 <Saizan> 1 + 2+3+4+5..
08:03:38 <Saizan> but the real implementation could be different
08:03:41 <nmessenger> so you want 'iterate' f x = x : iterate' (f $! x)' ?
08:03:43 <Saizan> i hope
08:04:33 <Saizan> aaah, wait
08:04:57 <Saizan> i was totally wrong, they are shared
08:15:36 <fernan> is there a hugs irc channel?
08:16:04 <Igloo> Only this one
08:20:09 * chessguy hugs fernan
08:20:45 * roconnor hugs fernan too
08:21:52 * nmessenger hugs fernan as well
08:22:23 * nmessenger ghc's chessguy
08:23:03 * chessguy throws an exception
08:24:02 * rahikkala provides output
08:24:21 * roconnor catches chessguy's exception and resets
08:24:25 <fernan> I was wondering if there is some sort of ffi test suite
08:24:27 * glguy takes exception
08:24:40 <fernan> during hugs compile
08:24:45 <roconnor> @hoogle reset
08:24:46 <lambdabot> Text.Html.reset :: String -> String -> Html
08:24:46 <lambdabot> Text.ParserCombinators.ReadPrec.reset :: ReadPrec a -> ReadPrec a
08:24:46 <lambdabot> Foreign.C.Error.resetErrno :: IO ()
08:24:57 <roconnor> @hoogle shift
08:24:59 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
08:25:01 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
08:25:01 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
08:25:05 <roconnor> hmm
08:26:36 <nomeata> Hi. What might be a good way to parse a latex file into a list of tuples containing (command, option), (assuming all commands have just one option and optional parameters ignored)?
08:28:01 <nomeata> one of the parser libraries, or will it be easier by hand?
08:28:31 <hpaste>  nomeata pasted "latex code parser" at http://hpaste.org/243
08:28:41 <nomeata> This is what I have, but it is ugly and not robust.
08:29:12 <nomeata> example for non-robustness: Latex.hs:43:7-44: Irrefutable pattern failed for pattern (command, n : rest2)
08:29:48 <glguy> You should probably just use Parsec or ReadP
08:29:57 <nmessenger> nomeata: I know nothing of LaTeX, but you should use Parsec
08:30:07 <fasta> How can I reexport a complete module? I did module Foo where (module ReexportedModule, <other stuff), but a method bar inside ReexportedModule doesn't get imported in a module Zork importing Foo.
08:30:44 <nmessenger> fasta: ReexportedModule *doesn't* export bar?
08:30:47 <allbery_b> it works if you use a default/simple import.  if you import qualified, it won't get re-exported
08:31:08 <allbery_b> this is silent with ghc < HEAD (HEAD warns nothing is re-exported)
08:31:14 <fasta> nmessenger: ReexportedModule looks like: module ReexportedModule where <list of definitions>
08:31:26 <allbery_b> er
08:31:30 <allbery_b> where's' its export list?
08:31:44 <glguy> is it just a case of: module A (B(..)) where?
08:31:56 <fasta> allbery_b: It has no explicit export list.
08:31:57 <nmessenger> allberry_b: no export list = export all toplevel names I think
08:32:05 <fasta> nmessenger: right
08:33:26 <nmessenger> maybe a syntax like 'module Foo (module Reexported(..)) where ...'?
08:33:46 <nmessenger> or is (..) only for type constructors?
08:33:58 <nomeata> glguy: do you know a good intro to ReadP?
08:34:10 <fasta> nmessenger: doesn't appear to work
08:34:14 <fasta> parse error on input `('
08:35:26 <glguy> nomeata: ReadP is extremely similar to Parsec, and you use readP_to_S to make it behave like reads does
08:35:43 <glguy> (which is how you use the finished result)
08:36:03 <glguy> readS_to_P allows you to use Read instances in your parser
08:40:26 <beschmi> nomeata: pandoc has a latex parser, but i don't know how complete it is
08:40:33 <beschmi> @where pandoc
08:40:33 <lambdabot> http://sophos.berkeley.edu/macfarlane/pandoc/
08:40:59 <fasta> Odd, I get Warning: The export item `module Bar.Baz.Zork' exports nothing
08:41:13 <nomeata> beschmi: thx for the pointer
08:41:16 <fasta> (That module does export lots of stuff)
08:41:29 <beschmi> nomeata: btw, you're in Karlsruhe too?
08:42:08 <emu> @seen therp
08:42:09 <lambdabot> therp is in #haskell and #darcs. I last heard therp speak 6h 19m 2s ago.
08:42:35 <nomeata> beschmi: not at the moment, but I will be when the semester starts again
08:43:00 <nomeata> interesting: http://sophos.berkeley.edu/macfarlane/pandoc/doc/Text-Pandoc-Definition.html#t%3APandoc looks quite like my http://latexki.nomeata.de/WikiData.html
08:43:03 <lambdabot> http://tinyurl.com/27owb4
08:43:07 <nomeata> So much to re-inventing the wheel.
08:43:18 <emu> @tell therp did you really make '(x) == ([] x)?
08:43:18 <therp> emu: pong
08:43:19 <lambdabot> Consider it noted.
08:43:19 <lambdabot> therp: You have 1 new message. '/msg lambdabot @messages' to read it.
08:43:43 <emu> or ([] 'x)?
08:43:50 <beschmi> nomeata: i see
08:44:08 <therp> emu: well, no. At the end I decided that it's too misleading for Lisp programmers. at the moment it's %(x)=([] x) but to be honest, I don't like that either
08:44:23 <therp> emu: ([] 'x) does not exist. ([] `x) exists though
08:44:32 <emu> is ' not quote?
08:44:48 <nomeata> beschmi: Are you also a university student there?
08:44:54 <therp> emu: no. there is nothing triggering on ' ATM.
08:45:00 <emu> that's probably best
08:45:11 <beschmi> nomeata: yes, i'm writing my diploma thesis right now
08:45:14 <emu> the qsort example uses '(x) where x is supposed to be evaluated
08:45:59 <nomeata> beschmi: ok, then this is proably not interesting any more for you: http://mitschriebwiki.nomeata.de/
08:46:00 <lambdabot> Title: Das VorlesungsMitschiebWiki - index
08:46:08 <therp> emu: I had that, yes. the old syntax sugar for explicit lists (evaluated lists) was '(x) = ([] x)
08:46:16 <beschmi> nomeata: i think Leif Frenzel (eclipse plugin for haskell) is from karlsruhe too, maybe we can have a haskell stammtisch sometime
08:46:19 <therp> emu: maybe that's an old example floating around.
08:46:57 <therp> at the moment I'm preparing a Liskell presentation for anyother screencast.. if I only had the qtrle codec to cut down the video size..
08:47:00 <beschmi> nomeata: cool, wish we had something like that
08:47:02 <therp> -y
08:47:16 <nomeata> beschmi: I would definately be interested
08:47:31 <emu> therp: its in the liskell-draft
08:47:35 <nomeata> beschmi: you donât happen to know of any lectures or seminars or practica next semester somehow related to haskell?
08:47:46 <emu> therp: it's just bad because a lot of newbie lisp programmers make the mistake of thinking '(x) == (list x)
08:48:46 <therp> emu: I noticed it, and changed in the source. the draft stilll needs a little work. in 4 days I know whether this draft is accept for ILC.. I hope it will be, and then a series of reviews starts anyway
08:49:27 <beschmi> nomeata: i don't think there is any group that uses haskell (or even fp). maybe the cellular automata group (Vollmar)
08:51:36 <emu> cool
08:51:37 <nomeata> beschmi: Info II was taught with Haskell, under Calmet and Eberhardt. I was both student and tutor, so that got me started, but now Calmet has left the university.
08:51:53 <therp> emu: I would be interested if the parse tree transformation stuff is easily comprehensible. http://clemens.endorphin.org/testsuite-liskell/tests/liskell/metaprogramming/LskPrelude.lsk - please search for "simple-list". that's the function rewriting %(a b c) into ([] a b c). and nil into ([])
08:51:55 <lambdabot> http://tinyurl.com/328muf
08:52:09 <therp> emu: only if you have a few minutes.. :)
08:52:40 <emu> i have to run to class in 5 :/
08:52:48 <therp> emu: ah ok nevermind :)
08:53:00 <fasta> @quote Hoara
08:53:01 <lambdabot> No quotes match. It can only be attributed to human error.
08:53:07 <beschmi> nomeata: oh, i didn't know that. Info 1 was the only haskell at uni for me. i heard most of Calmet's lectures, but there wasn't much fp in there
08:53:13 <fasta> @quote Hoare
08:53:13 <lambdabot> No quotes match. It can only be attributed to human error.
08:53:43 <nomeata> beschmi: I think Iâs mostly his assistant (Ralf Eberhardt) who is responsible for that. And most students hate him for that :-)
08:53:43 <emu> well i have it saved for later
08:54:00 <nomeata> This semester theâll use Java in Info II, just as in Info I
08:54:29 <beschmi> poor students
08:55:14 <fasta> There are two ways of constructing a software design. One way is to make it so simple that there are obviously no deficiencies. And the other way is to make it so complicated that there are no obvious deficiencies.
08:55:23 <fasta> How do I set a quote?
08:55:44 <beschmi> nomeata: i have to go, perhaps we can talk later about a haskell meeting.
08:56:39 <glguy> fasta: first, someone else says something memorable in channel
08:56:44 <glguy> and then you quote them to the bot
08:56:54 <kowey> glguy: how much effort would it be to have it so that hpaste works nicely for #haskell.dut, #haskell.fr, etc?
08:57:09 <hoare>  There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.  -C. A. R. Hoare
08:57:52 <hoare> @quote hoare
08:57:53 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
08:57:59 <glguy> kowey: You'd need a patch to allow the site to specify which channel to send to, and then you'd need to add support for joining multiple channels to the bot
08:58:10 <hoare> @help quote
08:58:10 <lambdabot> quote <nick>
08:58:11 <lambdabot> remember <nick> <quote>
08:58:11 <lambdabot> Quote somebody, a random person, or save a memorable quote
08:58:18 <dmhouse> Afternoon everyone.
08:58:24 <glguy> kowey: there shouldn't be anything to difficult about it
08:58:58 <kowey> glguy: hmm... i guess one way to do the specify-the-site bit would be to have hpaste.org/fr, hpaste.org/dut, etc (at least from a UI point of view)
08:59:04 <hoare> @remember hoare "There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.  -C. A. R. Hoare"
08:59:05 <lambdabot> Done.
08:59:20 <kowey> s/specify the site/specify the channel/
08:59:22 <glguy> kowey: or: fr.hpaste.org
08:59:28 <kowey> ooh, nicer
09:02:29 <kowey> (well, if anybody else wants to work on this, note that I wasn't volunteering :-) )
09:02:42 <glguy> I'm not too concerned about it either
09:02:47 <glguy> I don't use any other channels but this
09:03:00 <kowey> right... lazy implementation
09:03:19 <glguy> community implementation, the source is public so people can add features they need
09:03:24 <kowey> code-by-need
09:03:53 <Saizan> mmh so we statically decide the channels?
09:04:23 <glguy> when someone figures out a good way to communicate *into* the HAppS state
09:04:29 <glguy> then I can add from the irc bot
09:04:37 <glguy> otherwise, I'd manage that stuff from the website
09:04:40 <glguy> in the admin section
09:05:05 <Saizan> admin section :O
09:05:30 <glguy> Yeah, there is a framework for admin pages, and there is a delte page so far
09:05:34 <glguy> /admin/
09:07:08 <Saizan> mmh that reminds me i didn't cheked the sources since the former api..
09:10:56 <glguy> Saizan: to compile the current code, you'll need a current HAppS
09:14:45 <Saizan> glguy: k, even if i'm struggling with a 200mb memory leak serializing a zipper
09:15:30 <Saizan> it gets gc-ed to 30mb shortly after, but it's not very nice for my ram
09:15:47 <mux> > let foo = map (read . return) . show
09:15:47 <lambdabot>  Parse error
09:15:54 <mux> @let foo = map (read . return) . show
09:15:55 <lambdabot> <local>:4:11:     Ambiguous type variable `a' in the constraint:       `Read ...
09:16:08 <mux> bah, lambdabot should use -fno-monomorphism-restriction :-)
09:16:36 <mux> @let foo = map (read . return) . (show :: Integer -> String)
09:16:37 <lambdabot> <local>:4:11:     Ambiguous type variable `a' in the constraint:       `Read ...
09:16:57 <mux> @let foo = map (read . return) . (show :: Int -> String)
09:16:58 <lambdabot> <local>:4:11:     Ambiguous type variable `a' in the constraint:       `Read ...
09:17:01 <mux> help!
09:17:27 <glguy> it doesn't know what type you want it to read in
09:17:34 <mux> oh
09:17:35 <mux> stupid me
09:17:44 <glguy> you could always just specify an argument on foo
09:17:48 <glguy> instead of writing it point-free
09:17:55 <mux> right
09:18:24 <mux> @let foo x = map (read . return) . show x
09:18:24 <lambdabot> <local>:4:30:     Expecting a function type, but found `[Char]'       Expecte...
09:18:30 <mux> @let foo x = map (read . return) . show $ x
09:18:31 <lambdabot> Defined.
09:18:37 <mux> > L.foo 12345
09:18:37 <lambdabot>  Add a type signature
09:18:46 <mux> > L.foo 12345 :: [Int]
09:18:47 <lambdabot>  [1,2,3,4,5]
09:18:50 <mux> here we are
09:19:06 <mux> can someone think of a better way to write this? someone asked for this in #haskell.fr and I couldn't find better
09:19:25 <glguy> > map digitToInt "1234"
09:19:27 <lambdabot>  [1,2,3,4]
09:19:47 <glguy> > map digitToInt $ show 1234
09:19:49 <lambdabot>  [1,2,3,4]
09:19:57 <mux> hmpf.
09:20:14 <mux> I feel lame now :-)
09:20:23 <metaperl> @type map
09:20:25 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
09:20:44 <metaperl> > (\x -> x * x) [1 .. 3]
09:20:45 <lambdabot>   add an instance declaration for (Num [a])
09:20:46 <lambdabot>     In a lambda abstraction: \ x ...
09:20:58 <metaperl> > map (\x -> x * x) [ 1.. 3]
09:21:00 <lambdabot>  [1,4,9]
09:21:21 <Saizan> > snd . foldr (\x (i,acc) -> (i+1,x*2^i+acc)) (0,0) $ 1234
09:21:22 <lambdabot>   add an instance declaration for (Num [b])
09:21:35 <metaperl> map (\x -> x * x) $ map (\x -> x * x) [ 1.. 3 ]
09:21:52 <metaperl> > map (\x -> x * x) $ map (\x -> x * x) [ 1.. 3 ]
09:21:53 <lambdabot>  [1,16,81]
09:21:59 <glguy> > let f x | x < 10 = [x] | otherwise = let (a,b) = x `divMod` 10 in b : f a in f 1234
09:22:01 <lambdabot>  [4,3,2,1]
09:23:22 <kaol> > unfoldr (\x -> guard (x /= 0) >> return (uncurry (flip (,)) (divMod x 10))) 1234
09:23:23 <lambdabot>  [4,3,2,1]
09:23:35 <glguy> > let f x | x < 10 = [x] | otherwise = let (a,b) = x `divMod` 10 in b : f a in f 0
09:23:36 <lambdabot>  [0]
09:23:40 <glguy> > unfoldr (\x -> guard (x /= 0) >> return (uncurry (flip (,)) (divMod x 10)))
09:23:41 <lambdabot>  Add a type signature
09:23:42 <glguy> > unfoldr (\x -> guard (x /= 0) >> return (uncurry (flip (,)) (divMod x 10))) 0
09:23:44 <lambdabot>  []
09:23:50 <glguy> that's why I didn't go that route
09:24:06 <glguy> > unfoldr (\x -> guard (x /= 0) >> return (uncurry (flip (,)) (divMod x 10))) 10
09:24:08 <lambdabot>  [0,1]
09:26:01 <metaperl> @type square
09:26:03 <lambdabot> Not in scope: `square'
09:26:45 <metaperl> > let sq = (\x -> x * x) in map sq $ map sq [1 .. 3]
09:26:47 <lambdabot>  [1,16,81]
09:28:05 <vincenz> > let sq = join (*) in map sq $ map sq [ 1..4]
09:28:07 <lambdabot>  [1,16,81,256]
09:28:40 <vincenz> > let sq = join (*) in map (join sq) [ 1..4]
09:28:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
09:28:45 <lambdabot>       Expe...
09:28:48 <vincenz> ack
09:28:55 <vincenz> > let sq = join (*) in map (sq .sq) [ 1..4]
09:28:57 <lambdabot>  [1,16,81,256]
09:30:02 <glguy> metaperl: have you "released" the xcode plugin yet?
09:30:28 <metaperl> glguy - xocde plugin? i dont know what you are talking about
09:30:31 <glguy> oh
09:30:41 <glguy> nevermind then , I thought dons said that was yours
09:30:49 <metaperl> oh  no . not at all :)
09:38:11 <ski> > let sq = join (*) in map (join (.) sq) [1..4]
09:38:12 <lambdabot>  [1,16,81,256]
09:39:20 <int-e> ski: uhm. (^2) ?
09:39:58 <ski> (^4)
09:40:32 <int-e> yes, I meant the sq :)
09:41:07 * ski just parroted from above ..
09:47:07 <chessguy> ?where calewiki
09:47:08 <lambdabot> I know nothing about calewiki.
09:47:15 <chessguy> ?where cale
09:47:15 <lambdabot> http://cale.yi.org/
09:47:54 <chessguy> ?where+ calewiki http://cale.yi.org/
09:47:55 <lambdabot> Done.
09:49:35 <Saizan> some hints on profiling memory usage?
10:00:38 <Cale> dons: are you here?
10:01:54 <chessguy> ?seen dons
10:01:54 <lambdabot> dons is in #happs, #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 5h 22m 8s ago.
10:10:22 <astrolabe> Saizan: Is that a request?
10:12:21 <chessguy> what is http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Trans.html for?
10:12:23 <lambdabot> http://tinyurl.com/yqbbla
10:13:07 <ski> monad transformers
10:13:20 <chessguy> ah
10:13:48 <astrolabe> monad transformers: more than meets the eye
10:13:59 <dmhouse> astrolabe: I wouldn't say so.
10:14:08 <dmhouse> Monad transformers: an easy concept with a scary name.
10:14:56 <ski> @instances-importing Control.Monad.Trans MonadTrans
10:14:57 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
10:15:16 <astrolabe> dmhouse: http://movies.msn.com/movies/movie.aspx?m=124526
10:15:18 <lambdabot> Title: Movie Info for The Transformers: More Than Meets the Eye, Part 1 on MSN Movies
10:15:40 <dmhouse> Oh, I get it. :)
10:16:12 <astrolabe> Sorry, not worth getting really :)
10:16:17 <chessguy> i suspected it was something to do that
10:17:39 <sjanssen> category theory in disguise?
10:20:53 <Cale> Is anyone else here running a lambdabot and knows about the new rc file format?
10:20:55 <vincenz> @join #scheme
10:25:08 <chessguy> Cale, i have a build at home, but no access right this minute, unfortunately
10:35:17 <shapr> @seen glguy
10:35:18 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 1h 4m 36s ago.
10:36:21 <shapr> glguy: ping
10:37:48 <astrolabe> Is it usual to have to sometimes pass-in or return dummy variables into functions solely to pacify the type system?
10:38:11 <chessguy> hey shapr, i think that simulator is going to be a little too complex for what i want to do
10:39:09 <bd_> astrolabe: why do you need to do that?
10:39:18 <astrolabe> 'dummy variable' is the wrong term, but I mean variables that are never used, except for their type.
10:39:22 <dmhouse> Alright, software gurus; here's a problem I'm having that you can feel free to pick your brains over. It's more about high-level structure than any specific issue.
10:39:54 * chessguy wakes up the hyenas
10:39:58 <bd_> astrolabe: hmm, it's occasionally done - eg, Storable.sizeOf
10:40:06 <bd_> but I don't think it's too common
10:41:06 <dmhouse> I'm striving for a pretty strict MVC structure in my program. Now, I've written a generic viewer to handle the 'Are you sure you wish to delete this X' pages. The problem is that I have 'breadcrumbs' on each page that are a series of links to the current object being viewed/deleted etc. and links to all of its parents.
10:41:48 <bd_> astrolabe: why do you need them?
10:41:50 <astrolabe> bd_: I've got a unary datatype that is essentially the file name of a file that stores some data whose type is the argument to the unary type.  When I delete this file, I need to read some of the data, and hence need to know its type.
10:42:09 <bd_> astrolabe: hm, could this be an application for GADTs?
10:42:45 <bd_> or, well, do you mean something like:
10:42:51 <bd_> newtype FileName a = FN String
10:43:00 <astrolabe> bd_: I know nothing about them, but I'm keen on sticking to haskell98 (apart from the unsafeInterleaveIO, which has already tempted me).
10:43:10 <bd_> in which case you could do: data FileName a = FN String | Dummy a
10:43:11 <dmhouse> Ooh, actually, I've just had an idea.
10:43:16 <astrolabe> bd: that is what I mean, yes
10:43:17 <bd_> and now you can introduce a later:
10:43:34 <shapr> How does darcs emit documentation into a single file from multiple modules? I'd like to use that same approach for the HAppS tutorial..
10:43:54 <bd_> deleteFile f@(FN filename) = doMagicDelete (Dummy undefined `sameType ` f) >> deleteActualFile filename
10:44:05 <bd_>   where sameType :: a -> a -> a
10:44:09 <bd_>         sameType = const
10:44:22 <bd_> and now don't export Dummy
10:44:38 <chessguy> ?seen opqdonut
10:44:39 <lambdabot> opqdonut is in #darcs and #haskell. I last heard opqdonut speak 8h 23m 5s ago.
10:44:50 * astrolabe tries to understand
10:45:06 <opqdonut> hi chessguy
10:45:28 <astrolabe> @type asTypeOf
10:45:30 <bd_> astrolabe: Dummy undefined is constrained to be the same type as the argument f
10:45:31 <lambdabot> forall a. a -> a -> a
10:45:49 <chessguy> hey.
10:46:02 <bd_> so your magic deletion function can now use the constructor argument to force some other variable to be the same type
10:46:08 <chessguy> opqdonut, false alarm, sorry. i was trying to find the code you sent me, and thought i had lost it. but i found it now
10:46:30 <bd_> astrolabe: another way to do it:
10:46:35 <astrolabe> bd: I've got to write it down.  Thanks, I'll get back to you
10:46:41 <bd_> wait, are ~-patterns H98?
10:46:55 <astrolabe> yes
10:47:01 <bd_> okay, you could do:
10:47:16 <opqdonut> chessguy: np, hf :)
10:47:39 <ski> astrolabe : @type deleteFile
10:47:39 <bd_> magicDelete fn@~(Dummy typeMagic) = readFromFile (getFileName fn) `sameType` typeMagic
10:47:47 <bd_> with the same `sameType` combinator
10:48:12 <sjanssen> @type asTypeOf -- use this function, bd_
10:48:13 <ski> @src asTypeOf
10:48:13 <lambdabot> forall a. a -> a -> a
10:48:14 <lambdabot> asTypeOf = const
10:48:19 <bd_> ah :)
10:48:45 <bd_> anyway, the basic idea of adding a dummy constructor for type purposes is probably what you need
10:51:43 <astrolabe> bd_: thanks very much, I've written those down.
10:51:54 <ski> astrolabe : @type deleteFile
10:52:02 <astrolabe> ski: why did you say 'astrolabe : @type deleteFile'?
10:52:10 <ski> it's a question
10:52:19 <astrolabe> Ah
10:53:02 <astrolabe> Something like   deleteFile :: FileName a -> IO ()
10:53:38 <ski> ok .. then i guess something alike bd_'s approach is unavoidable
10:53:55 <ski> (you could pass an explicit dummy arg, though)
10:54:26 <ski> hm .. is it reading things of type 'a' from the file and storing it somewhere ?
10:55:03 <bd_> actually, you don't really need a dummy constructor...
10:55:13 <bd_> getFNType :: FileName a -> a
10:55:16 <bd_> getFNType = undefined
10:55:47 <astrolabe> ski: it needs to read the file first because it is in the file is the name of the next file, that also has to be deleted.
10:55:51 <chessguy> i wonder if reflection will ever be possible in haskell
10:56:09 <astrolabe> bd_: ooh that's nice!
10:56:17 <bd_> chessguy: Data.Typeable?
10:56:17 <bd_> + hs-plugins =+ GHC.*...
10:56:44 <ski> astrolabe : but what does it do with the value of type 'a' that has been read ?  return from the IO action ?, store in some 'IORef' or something ?
10:56:58 <nmessenger> > show . typeOf $ ord -- astrolabe
10:57:00 <chessguy> mm, that's a little different i think
10:57:00 <lambdabot>  "Char -> Int"
10:57:09 <chessguy> i'm looking at this code:
10:57:10 <chessguy> data Event = Event { param::Int, thresh::Double, dir::Bool }
10:57:10 <chessguy> instance Random Event where
10:57:10 <chessguy>     random g0 = (Event p t d,g)
10:57:10 <chessguy> 	where (p,g1) = randomR (1,5) g0
10:57:11 <chessguy> 	      (t,g2) = randomR (0,100) g1
10:57:11 <mux> heheh, ain't that great: MS managed to have a security flaw in their new "Vista Speech Control"
10:57:12 <chessguy> 	      (d,g)  = random g2
10:57:14 <astrolabe> ski: chucks it away
10:57:17 <metaperl> > let sq = (\x -> x*x) in map (sq . sq)  [1..3]
10:57:18 <lambdabot>  [1,16,81]
10:57:36 <mux> MS recommends turning off the speakers or microphone until a fix is released :-)
10:57:42 <astrolabe> !paste
10:57:42 <hpaste> Haskell paste bin: http://hpaste.org/
10:57:43 <ski> astrolabe : sorry, what does 'chuck' mean ?
10:57:44 <mux> or turn off vista speech control, of course
10:57:55 <astrolabe> ski: sorry.  chuck = throw
10:58:26 <ski> then why read it ?
10:58:42 <astrolabe> ski: but read needs to be able to parse the string to get to the filename
10:59:10 <chessguy> bd_, it seems like there ought to be a way to abstract something like taht
10:59:13 <chessguy> *that
10:59:55 <ski> astrolabe : what string ? file contents ?
11:00:05 <astrolabe> ski: yes
11:00:20 <ski> so why are you then having a type variable 'a' ?
11:00:33 <newsham> bd: like using a state monad to carry the generator around?
11:00:39 <xian> hello. i'm looking for this tutorial called "all about monads" which is considered very good. unfortunately the server which hosts it, seems to be down. does anyone know where else i could get it from?
11:00:40 <newsham> s/bd/chess/
11:01:26 <astrolabe> ski: I don't think this is what you mean, but so that I can store Doubles or Ints, or whatever I want to in the file.
11:01:27 <newsham> > let sRand = (do { (x,g) <- gets random; put g; return x}) in runState (do { x <- sRand; y <- sRand; return (x+y) }) (mkStdGen 3)
11:01:29 <lambdabot>  (399837179,1759534916 1872071452)
11:01:45 <chessguy> newsham, like having a general way to construct random instances of composite data types
11:01:48 <newsham> chess: sRand hides the generator
11:02:04 <newsham> chess: oh..hmm.. seen the quickCheck stuff?
11:02:14 <chessguy> no
11:02:22 <newsham> do you know what quickcheck is?
11:02:41 <newsham> ?check \x -> x + 2 == x + 1 + 1
11:02:43 <lambdabot>  Add a type signature
11:02:50 <newsham> ?check \x -> x + 2 == (x :: Int) + 1 + 1
11:02:51 <lambdabot>  OK, passed 500 tests.
11:02:58 <chessguy> hmm
11:03:03 <astrolabe> @karma+ bd
11:03:04 <lambdabot> bd's karma raised to 2.
11:03:06 <newsham> i define a property, it checks it.   it has to have a mechanism for generating the arguments
11:03:11 <chessguy> how is it relevant to this?
11:03:15 <ski> xian : mayhaps you might read part of it by google cache http://216.239.59.104/search?q=cache:UJ2spam_St4J:www.nomaware.com/monads/+nomaware&hl=en&ct=clnk&cd=1
11:03:17 <lambdabot> http://tinyurl.com/24f4bc
11:03:22 <chessguy> oh, i see
11:03:23 <newsham> so part of the quickcheck lib has a class for abstracting how to generate random instances
11:03:53 <ski> astrolabe : i thought you were storing a filename in the file ..
11:03:59 <chessguy> documentation for it looks pretty shoddy
11:04:15 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
11:04:15 <xian> ski: good idea, thanks.
11:04:18 <lambdabot> http://tinyurl.com/y3vmep
11:04:38 <newsham> http://www.cs.chalmers.se/~rjmh/QuickCheck/  has a paper describing it in more detail
11:04:41 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
11:04:42 <ski> (xian : and just google the subpages and get their google cache, of course)
11:04:49 <chessguy> ok, i'll check it out
11:05:30 <syntaxfree> bah. anyone here experienced with Erlang?
11:05:32 <newsham> the "Arbitrary" class is the one that makes the generators
11:05:35 <chessguy> ?check map (^2) xs == map (\x -> x * x) xs
11:05:36 <lambdabot>   Not in scope: `xs'
11:05:49 <chessguy> ?check map (^2) == map (\x -> x * x)
11:05:51 <lambdabot>   add an instance declaration for (Eq ([b] -> [b]))     In the definition of ...
11:05:53 <astrolabe> ski: the file consists of a 'list' of as, and then possibly a filename pointing to the next file
11:06:14 <ski> ?check \xs -> map (^2) xs == map (\x -> x * x :: Int) xs
11:06:16 <lambdabot>  OK, passed 500 tests.
11:06:31 <ski> ?check map (^2) == map (\x -> x * x :: Int)
11:06:32 <lambdabot>   add an instance declaration for (Eq ([Int] -> [Int]))     In the definition...
11:06:46 <newsham> > generate 1 (mkStdGen 2) arbitrary :: Int
11:06:47 <lambdabot>   Not in scope: `arbitrary'
11:06:52 <ski> astrolabe : aha ..
11:07:08 <ski> astrolabe : and the next file also contains 'a' ?
11:07:16 <astrolabe> ski: sorry about the cryptic explanations :)
11:07:24 <astrolabe> ski: right
11:07:37 <chessguy> newsham, you think that could be adapted to use for this?
11:08:13 <ski> so your 'FileName a' is basically a kind of typed linked-list^H^H^H^Hfile chain
11:08:14 <newsham> not sure what "this" is.. you want to build a ranodm something or other, right?
11:08:36 <chessguy> yes, for an arbitrary data structure like the one i pasted
11:08:51 <chessguy> data Event = Event { param::Int, thresh::Double, dir::Bool }
11:09:23 <newsham> you want something like x <- arbitrary; y <- arbitrary; z <- arbitrary; return Event x y yz
11:09:39 <newsham> and that would be your definition of arbitrary for Event
11:09:53 <chessguy> wow, it's that easy?
11:09:58 <ski> chessguy : where would the magic numbers '(1,5)','(0,100)' come from ?
11:10:27 <newsham> chess: they want to make it easy to write test cases.  if it was hard, nobody would use it :)
11:10:42 <newsham> chess: I have a small example in CheckTree here:  http://www.thenewsh.com/%7Enewsham/x/tree/
11:10:43 <opqdonut> :D
11:10:44 <lambdabot> Title: Directory /~newsham/x/tree/
11:11:00 <chessguy> newsham, generating random trees?
11:11:13 <ski> chessguy : you could replace 'param::Int, thresh::Double' by 'param::Param, thresh::Thresh' and hardcode the magic numbers into 'Arbitrary' instances for those two types, and them use what newsham suggested directly
11:11:24 <newsham> chess: yah, to test a small set of tree funcs
11:11:41 <ski> (or actually : 'liftM2 Event arbitrary arbitrary arbitrary')
11:11:48 <newsham> liftM3 ?
11:11:54 <ski> er .. right
11:12:03 <chessguy> nice, i'll check that out
11:13:13 <astrolabe> ski yes
11:13:46 <bd_> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
11:13:48 <lambdabot> No matches, try a more general search
11:14:15 <newsham> ?type curry
11:14:17 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
11:14:24 <newsham> ?type uncurry
11:14:26 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
11:14:34 <newsham> ?type uncurry3
11:14:36 <lambdabot> Not in scope: `uncurry3'
11:14:37 <newsham> ?type uncurry2
11:14:39 <lambdabot> Not in scope: `uncurry2'
11:14:53 <newsham> ?hoogle curry
11:14:54 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
11:14:54 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
11:16:20 <ski> @type curry . curry
11:16:23 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
11:16:24 <ski> @type uncurry . uncurry
11:16:26 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
11:16:36 <bd_> @. pl djinn (a -> b -> c -> d) -> (a, b, c) -> d
11:16:38 <lambdabot> (line 1, column 15):
11:16:38 <lambdabot> unexpected "="
11:16:38 <lambdabot> expecting variable, "(", operator or end of input
11:16:41 <bd_> :/
11:16:43 <bd_> @djinn (a -> b -> c -> d) -> (a, b, c) -> d
11:16:44 <lambdabot> f a (b, c, d) = a b c d
11:17:02 <bd_> @pl \a (b, c, d) -> a b c d
11:17:03 <lambdabot> (line 1, column 9):
11:17:03 <lambdabot> unexpected ","
11:17:03 <lambdabot> expecting letter or digit, operator or ")"
11:17:03 <lambdabot> ambiguous use of a non associative operator
11:17:33 <ski> @pl \x y -> (x,y)
11:17:34 <lambdabot> (,)
11:17:39 <ski> @pl \x y z -> (x,y,z)
11:17:39 <lambdabot> (,,)
11:17:46 <ski> @pl f = \x y z -> (x,y,z)
11:17:53 <lambdabot> f = (,,)
11:18:02 <bd_> one-way?
11:18:04 <ski> @pl f = \(x,y,z) -> x y z
11:18:05 <lambdabot> (line 1, column 3):
11:18:05 <lambdabot> unexpected "="
11:18:05 <lambdabot> expecting variable, "(", operator or end of input
11:18:16 <ski> it doesn't appear to understand tuples in patterns
11:18:26 <bd_> @hoogle (a, b, c) -> a
11:18:27 <lambdabot> No matches, try a more general search
11:18:31 <bd_> @hoogle (a, b,) -> a
11:18:32 <lambdabot> No matches, try a more general search
11:18:34 <bd_> @hoogle (a, b) -> a
11:18:35 <lambdabot> Prelude.fst :: (a, b) -> a
11:18:35 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
11:18:35 <lambdabot> Prelude.snd :: (a, b) -> b
11:18:39 <ski> @hoogle fst3
11:18:40 <lambdabot> No matches found
11:18:45 <bd_> might be impossible to deconstruct them in a pointless manner
11:18:53 <bd_> @pl \(a, b) -> a
11:18:53 <lambdabot> fst
11:20:57 <xerox> You might use (a,(b,c)), and arrow combinators.
11:21:41 <xerox> :t app
11:21:43 <lambdabot> forall (a :: * -> * -> *) c b. (ArrowApply a) => a (a b c, b) c
11:21:43 <bd_> that would be admitting defeat :)
11:21:49 * bd_ wonders if it can be done with Data.Typeable
11:22:01 <sjanssen> @djinn (a, b, c) -> a
11:22:02 <lambdabot> f (a, _, _) = a
11:22:38 <newsham> > let oneOfThree (a,b,c) = a in oneOfThree (1,2,3)
11:22:40 <lambdabot>  1
11:23:11 <newsham> if its fair to use fst, it should be fair to use oneOfThree
11:23:39 <bd_> @hoogle Dynamic -> TyCon
11:23:40 <lambdabot> No matches, try a more general search
11:23:54 <bd_> newsham: It's cheating if we have to define a non-base function for it ;)
11:24:27 <newsham> bd: then its cheating that fst was predefined.
11:24:48 <newsham> class Second a b where second :: a -> b
11:24:57 <bd_> > fromDynamic $ flip runCont id $ callCC $ \cc -> Data.Generics.everywhereM cc (1,2,3) :: Int
11:24:58 <lambdabot>   Not in scope: `Data.Generics.everywhereM'
11:25:02 <bd_> :/
11:25:14 <newsham> instance Second (a,b) b where second = snd
11:25:29 <newsham> instance Second (a,b,c) b where second (x,y,z) = y
11:26:33 <ski> bd_ : what was that meant to do ?
11:27:26 <bd_> I was hoping to extract the first element of the pair as a dynamic, but that failed utterly in ghci :)
11:27:58 <newsham> in spoken language we use the same word to select the second item of any list or tuple of two or more items
11:28:24 <bd_> tuples should be a recursive type
11:28:33 <ski> bd_ : hmm .. interesting
11:28:34 <bd_> with sugar for N > 2
11:28:39 <sjanssen> you shouldn't use tuples
11:28:49 * ski wonders if one could so internal->external iterator with that ..
11:29:02 <bd_> ski: Maybe with delimited continuations
11:29:10 <newsham> bd:   (Int, (Char, (String, ()))) ?
11:29:13 <ski> bd_ : that's what i meant, yes
11:29:35 <bd_> newsham: yes, that should be the same as (Int, Char, String), or something along those ilnes
11:29:37 <sjanssen> nested tuples occupy more storage space
11:30:01 <bd_> I recall a Haskell' proposal to make tuples recursive, with the right size strict (so it can be unboxed)
11:30:10 <newsham> why not whip up some syntactic sugar in TH and try it out?
11:30:19 <ski> TNil# :: (#)
11:30:20 <ski> TCons# :: * -> (#) -> (#)
11:30:28 <ski> Tuple :: (#) -> *
11:30:32 <ski> something like that ?
11:30:35 <sjanssen> bd_: no existing Haskell compiler knows how to unpack polymorphic fields like that
11:30:48 <bd_> sjanssen: It could be special-cased for tuples if need be
11:31:05 <sjanssen> "special-cased" is a dirty word :)
11:31:08 <bd_> :)
11:32:15 <sjanssen> I'd rather that people stop using tuples
11:33:57 <chessguy> sjanssen, how would you prefer to do something like let (a::A, b::B) = fooBar in ...
11:34:01 <syntaxfree> tuples are useful.
11:34:26 <sjanssen> chessguy: 2-tuples are okay
11:34:34 <sjanssen> 3-tuples and beyond are iffy
11:34:40 <chessguy> sjanssen, how would you prefer to do something like let (a::A, b::B, c::C) = fooBar in ...
11:35:12 <sjanssen> chessguy: how many functions return a 3-tuple?  how many return a 4-tuple?
11:35:22 <roconnor> @hoogle (a,b,c)
11:35:23 <lambdabot> No matches, try a more general search
11:35:25 <chessguy> i'm sure i wouldn't know
11:35:32 <chessguy> i'm just curious
11:35:35 <roconnor> @hoogle (a,b,c,d)
11:35:36 <lambdabot> No matches, try a more general search
11:35:49 <roconnor> @hoogle (a,b)
11:35:50 <lambdabot> Data.Map.findMax :: Map k a -> (k, a)
11:35:51 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
11:35:51 <lambdabot> Data.Map.elemAt :: Int -> Map k a -> (k, a)
11:36:00 <roconnor> sjanssen: none
11:37:25 <daniel_larsson> @hoogle context
11:37:28 <lambdabot> Data.Graph.Inductive.Graph.context :: Graph gr => gr a b -> Node -> Context a b
11:37:28 <lambdabot> Data.Graph.Inductive.Graph.Context :: type Context a b
11:37:28 <lambdabot> Data.Graph.Inductive.Monad.contextM :: GraphM m gr => m (gr a b) -> Node -> m (Context a b)
11:37:45 <daniel_larsson> A Context is a 4-tuple
11:37:52 <ski> bd_ : it seems 'everywhereM' want a polymorphic argument, while 'cc' is monomorphic
11:37:59 <sjanssen> we probably should have curryN/uncurryN where N is the largest size of tuple that the report guarantees
11:39:43 <ski> assocR :: (a,b,c) -> (a,(b,c))
11:39:53 <ski> maybe versions of that, too ..
11:40:46 <bd_> ski: yeah, mkM I guess
11:41:07 <sjanssen> uncurry is sufficient to pointfree any function on tuples
11:41:34 <sjanssen> uncurryN, that is
11:42:24 <newsham> ?type uncurry3
11:42:26 <lambdabot> Not in scope: `uncurry3'
11:43:08 <sjanssen> assocR can be written: uncurry3 (. (,)) . (.) . (,)
11:48:30 <metaperl> > zip ["a", "b", "c"] [1..]
11:48:32 <lambdabot>  [("a",1),("b",2),("c",3)]
11:50:33 <metaperl> > map (\(a,b) -> "Index: " ++ (show b) ++ "element: " ++ a ( zip ["a" , "b", "c"] [0..] )
11:50:34 <lambdabot>  Parse error
11:51:50 <chessguy> > zip3 "abcdef" [1..] [10,11,..]
11:51:51 <lambdabot>  Parse error
11:52:00 <chessguy> @type zip3
11:52:02 <lambdabot> forall c b a. [a] -> [b] -> [c] -> [(a, b, c)]
11:52:12 <chessguy> > zip3 "abcdef" [1..] [10,11..]
11:52:14 <lambdabot>  [('a',1,10),('b',2,11),('c',3,12),('d',4,13),('e',5,14),('f',6,15)]
11:52:17 <chessguy> extra comma snuck in there
11:52:46 <metaperl> do I need mapM_ to print this?
11:52:48 <metaperl> >  map (\(a,b) -> "Index: " ++ (show b) ++ "element: " ++ a)  ( zip ["a" , "b", "c"] [0..] )
11:52:50 <lambdabot>  ["Index: 0element: a","Index: 1element: b","Index: 2element: c"]
11:53:11 <mux> mapM_ putStrLn yeah
11:55:18 <chessguy> ?src mapM_
11:55:19 <lambdabot> mapM_ f as = sequence_ (map f as)
11:55:29 <bd_> ?src sequence_
11:55:30 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:55:38 <bd_> ?src foldr
11:55:39 <lambdabot> foldr k z xs = go xs
11:55:39 <lambdabot>     where go []     = z
11:55:39 <lambdabot>           go (y:ys) = y `k` go ys
11:56:15 <chessguy> > putStrLn "foo"
11:56:17 <lambdabot>  <IO ()>
11:57:00 <sjanssen> @pl mapM_ f xs = foldr (\y ys -> f y >>= \y' -> fmap (y:) ys) (return []) xs
11:57:01 <lambdabot> mapM_ = flip foldr (return []) . (`ap` ((const .) . fmap . (:))) . (((.) . (>>=)) .)
11:57:07 <chessguy> > map putStrLn ["foo","bar","baz"]
11:57:09 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>]
11:57:24 <sjanssen> metaperl: you should just use that ^^^ expression instead :)
11:58:42 <sjanssen> @pl mapM_ f xs = foldr (\y ys -> liftM2 (:) (f y) ys) (return []) xs
11:58:43 <lambdabot> mapM_ = flip foldr (return []) . (liftM2 (:) .)
11:58:47 <sjanssen> ah, much better
12:00:13 <chessguy> @type sequence_
12:00:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
12:03:04 <chessguy> that example makes sequence_ make a lot of sense
12:03:13 <chessguy> and mapM_ for that matter
12:04:26 <beelsebob> http://www.bbc.co.uk/bbctrust/consult/open-consultations/ondemand_services.html <-- go tick the very important it works on non microsoft systems
12:04:29 <lambdabot> Title: BBC Trust - On-demand Services' consultation, http://tinyurl.com/ypdmd6
12:04:39 <bd_> hmm
12:04:43 <bd_> ?where delimited continuations
12:04:44 <lambdabot> I know nothing about delimited.
12:06:04 <ski> http://community.schemewiki.org/?composable-continuations-tutorial
12:06:08 <lambdabot> http://tinyurl.com/yy2eux
12:06:32 <chessguy> ?where continuations
12:06:33 <lambdabot> I know nothing about continuations.
12:06:34 <bd_> I'm looking for a haskell implementation actually :)
12:06:52 <bd_> @hoogle shift
12:06:53 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
12:06:53 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
12:06:53 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
12:06:55 <ski> in the continuation monad ?
12:07:08 <bd_> Cont isn't a delimited continuation
12:07:17 <ski> sure it can be
12:07:31 <bd_> maybe, but I'm not sure I know the theory well enough for that :/
12:09:00 <bd_> I guess I could use Cont...
12:09:34 <ski> reset = return . (`runCont` id)
12:09:43 <ski> shift f = Cont (\k -> f (return . k) `runCont` id)
12:09:58 <glguy>   getCC :: MonadCont m => m (m a)
12:09:58 <glguy>   getCC = callCC (\c -> let x = c x in return x)
12:09:58 <glguy>   getCC' :: MonadCont m => a -> m (a, a -> m b)
12:09:59 <glguy>   getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
12:10:01 <glguy> that stuff?
12:10:55 <glguy> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/7646
12:10:58 <lambdabot> Title: gmane.comp.lang.haskell.cafe
12:11:07 <ski> glguy : well .. that isn't delimited, right ?
12:12:11 <ski> glguy : anyway, that is a cool use
12:12:18 <ski> ty for sharing
12:12:24 <glguy> nevermind, I thought you were talking about something else :)
12:12:32 * glguy doesn't have a ton of continuation experience
12:13:12 <syntaxfree> experience is measured in kilos?
12:13:37 <glguy> pounds
12:13:41 <chessguy> hmm, how did i not know about http://planet.haskell.org/ before?
12:13:44 <lambdabot> Title: Planet Haskell
12:13:51 <glguy> http://lambda-the-ultimate.org/node/1584
12:13:52 <lambdabot> Title: Delimited dynamic binding | Lambda the Ultimate
12:14:06 <glguy> stuff in this post seems to suggest that it can be done using ST, rather than just with Cont
12:14:56 <syntaxfree> @google 1 ton in pounds
12:14:57 <lambdabot> 1 short ton = 2,000 pounds
12:15:08 <syntaxfree> @google 1 ton in kilograms
12:15:09 <lambdabot> 1 short ton = 907.18474 kilograms
12:15:18 <glguy> @google 1 metric ton in kilograms
12:15:20 <lambdabot> 1 metric ton = 1,000 kilograms
12:15:24 <syntaxfree> GAH. 1 ton = 100 kilos, for chrissakes.
12:15:38 <glguy> short ton /= metric ton
12:15:39 <syntaxfree> x10
12:15:41 <syntaxfree> :(
12:18:21 <syntaxfree> @google 1 giant in meters
12:18:28 <lambdabot> http://www.dinosauria.com/dispatches/19981108001.html
12:18:28 <lambdabot> Title: Dino-Dispatches No. 1, 11/08/1998, Giant pliosaurs -- real and imaginary
12:18:40 <chessguy> lol
12:25:07 <newsham> ?quickcheck ton == metric ton
12:25:08 <lambdabot> Unknown command, try @list
12:25:33 <newsham> > let motor roar = roar "vroom! " in motor cycle
12:25:34 <lambdabot>  "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom...
12:25:54 <tessier_> Can someone explain to me what denotational semantics are?
12:26:15 <tessier_> I've been seeing that everywhere in my study of functional programming but everyone seems to assume you already know what it is
12:26:43 <bd_> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics - note, you don't need to know any of this to program haskell :)
12:33:30 <Notostraca> Okay.
12:33:49 <Notostraca> I cannot compile anything with GHC
12:34:04 <Notostraca> because I have no idea what I am doing.
12:34:29 <Notostraca> Where do I place files on Windows?
12:35:58 <Forum_user> hi all
12:36:00 <Forum_user> EXOTICS ADULT FORUM ::::::: http://exotics.ezbbforum.com
12:36:01 <lambdabot> Title: EXOTICS :: Index
12:36:07 <Forum_user> EXOTICS ADULT FORUM ::::::: http://exotics.ezbbforum.com ..
12:36:09 <lambdabot> Title: EXOTICS :: Index
12:36:09 <Forum_user> EXOTICS ADULT FORUM ::::::: http://exotics.ezbbforum.com ....
12:36:11 <lambdabot> Title: EXOTICS :: Index
12:36:33 --- mode: ChanServ set +o glguy
12:36:41 <Forum_user> ALL P O R N AND ADULT :::::::: http://exotics.ezbbforum.com
12:36:42 <lambdabot> Title: EXOTICS :: Index
12:36:58 <matthew-_> it left? by itself?
12:37:17 <Notostraca> They are...evolving...
12:37:25 <Notostraca> OH GOD NO!
12:37:54 --- mode: glguy set -o glguy
12:37:58 <Rasmus> i <3 haskell
12:38:30 <kowey> Notostraca: are you trying to compile a program you wrote?
12:38:48 <Notostraca> No, I'm trying to compile mage
12:38:56 <Notostraca> that netHack clone
12:39:29 <glguy> I notified a servop... forum_user is offline (until he comes back ;) )
12:39:33 <Notostraca> And it has a makefile with multiple folders and stuff
12:40:12 --- mode: ChanServ set +o shapr
12:40:50 --- mode: shapr set +b *!*@85.104.93.*
12:40:58 --- mode: shapr set -o shapr
12:41:19 <glguy> shapr: I was going to kick ban... and have xyr k-line, but I fumbled the command
12:41:27 * glguy doesn't ever kick / ban
12:43:33 <Notostraca> so...compiling mage with GHC?
12:44:06 <Notostraca> How would I go about that, folder-wise on Win?
12:46:17 <kowey> hmm... trying the same on my Mac, but 'hsc2hs -o Curses.hs Curses.hsc -L -lcurses' seems to have no effect
12:48:24 <Notostraca> Someone recommended an older GHC version
12:48:42 <Notostraca> on rec.games.roguelike.development
12:50:18 <Notostraca> 6.2, 6.4 maybe?
12:50:43 <Notostraca> They're mostly looking for Windows binaries.
12:51:18 <kowey> shapr: any comments?
12:52:00 <glguy> I forget, why does palomer keep getting banned?
12:53:07 <syntaxfree> palomer was a perfectly legitimate user IIRC.
12:53:17 <syntaxfree> specially in this channel, which is extra-tolerant of trolls and annoyances.
12:53:22 <syntaxfree> (like syntaxfree ;) )
12:53:34 <glguy> I do remember that he gets unbanned, comes back, and then does the same thing and gets banned again
12:53:41 <glguy> I just never get to really witness it
12:54:03 <chessguy> hey syntaxfree, you're a blogger, Planet Haskell is just an aggregate blog site, right? you blog somewhere else?
12:54:17 <sjanssen> palomer is consistently OT
12:54:35 <glguy> operating thetan?
12:54:42 <sjanssen> and when he is on topic he asks questions that are clearly documented in the obvious places
12:54:50 <glguy> ah, ok
12:54:58 <zem> is there any way to make ghc generate worse code, but do it faster?
12:55:00 <syntaxfree> bah, I'm probably at risk.
12:55:03 <sjanssen> glguy: palomer may or may not be a scientologist, I meant off topic
12:55:10 <glguy> sjanssen: I know ;)
12:55:13 <sjanssen> zem: don't compile with -O?
12:55:15 <pejo> zem, dont' use optimization
12:55:24 <sjanssen> zem: avoid -fvia-c too
12:55:25 <zem> i'm not
12:55:33 <zem> just linking against wxhaskell
12:55:44 <syntaxfree> I'm either on topic discussing things from a very abstract, yet unknowledgeable viewpoint ("Modulo-foo equivalence classes"), attempting to help newbies or straying somewhat off-topic.
12:55:46 <zem> but it makes my hard disk grind and takes way too long for a ten line program
12:56:11 <sjanssen> zem: what's the command line you're running?
12:56:13 <Notostraca> does anyone have a link for how to use GHC so I don't bug the channel anymore?
12:56:21 <syntaxfree> since my brain has turned to mush two months ago, I haven't been able to code more than 20 lines at a time. but anyway.
12:56:24 <zem> ghc -package wx anagrid.hs
12:56:28 <syntaxfree> chessguy: Planet Haskell is not a collective blog.
12:56:29 <zem> no optimisations at all
12:56:29 <Notostraca> The docs aren't helping
12:56:40 <syntaxfree> chessguy: it's a RSS aggregator, like Bloglines, Netvibes, etc.
12:56:43 <xerox> Notostraca: haskell.org/ghc -> documentation -> users' guide
12:57:01 <sjanssen> zem: that's as good as it gets, I'm afraid :(
12:57:39 <zem> phooey :( makes learning via tiny experiments a pain
12:57:53 <kpreid> zem: ghci?
12:57:57 <zem> plus it segfaulted ghci
12:57:57 <syntaxfree> chessguy: my own Haskell blog can be read individually at http://syntaxfree.wordpress.com. I also have two other unrelated blogs.
12:58:00 <lambdabot> Title: Data.Syntaxfree
12:58:04 <Notostraca> that is exactly what confused me
12:58:12 <Notostraca> the User's guide
12:58:18 <chessguy> syntaxfree, i'm thinking about starting to blog about haskell
12:58:29 <chessguy> if i find a goot blog site
12:58:35 <chessguy> s/oot/ood/
12:58:49 <zem> huh - no, ghci worked now
12:58:50 <syntaxfree> wordpress.com is pretty good, if you don't want to fiddle with templates.
12:58:56 <zem> no idea what went wrong the last time
12:59:02 <syntaxfree> blogger.com is less good, but you can use custom templates.
13:00:02 <syntaxfree> you can later export your wordpress.com data if you ever move to self-hosting. I really chose wordpress.com because I had been self-hosting a WP blog for two years, but I'm more satisfied with it than I ever was with Blogger in the 1999-2004 period.
13:00:05 <emu> is there any blog software which handles math typesetting and code too?
13:00:18 <Notostraca> Wikipedia?
13:00:28 <syntaxfree> emu: most blog software can use LaTeX plugins, iff LaTeX is installed on the server.
13:00:32 <emu> how does wikipedia do it anyhow, looks like they run tex on it
13:00:35 <syntaxfree> I just use www.mathbin.net
13:00:36 <emu> and then include a gif
13:00:42 <syntaxfree> yes, WikiMedia has a LaTeX plugin as well.
13:01:02 <syntaxfree> WikiMedia does it on the fly.
13:02:06 <mux> I wonder if it's a sign of haskell intoxication when you read people saying curry is great on a channel, talking about the food, and you think you were in haskell and they were talking about the curry function or haskell b. curry
13:02:44 <emu> :t liftM2 (.)
13:02:46 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
13:03:20 <emu> @hoogle (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
13:03:21 <lambdabot> No matches, try a more general search
13:03:24 <zem> only if you start wondering when henry rice did anything with curry
13:07:31 <huschi> has anybody here tried to develop an ajax application with haskell? this seems to be an interesting field.
13:08:20 <Notostraca> ycr2js, hajax
13:09:30 <huschi> on the hajax page in the haskellwiki are only suggestions as far as i can see.
13:09:31 <Notostraca> ycr2js apparently is under development right now
13:09:51 <kosmikus> ?seen bringert
13:09:52 <lambdabot> I saw bringert leaving #haskell 1h 36m 17s ago, and .
13:10:19 <Notostraca> http://blogs.nubgames.com/code/?p=16#comment-64
13:10:21 <lambdabot> Title: Nub Games Â» Comparing Gzip Code Reduction
13:10:24 <shapr> kowey: I still didn't write mage, and I haven't built it recently...
13:10:45 <Notostraca> please build?
13:11:03 <shapr> HaskellNet has JSON code.
13:11:10 <shapr> huschi: That might help some.
13:11:24 <kosmikus> shapr: wasn't mage this roguelike?
13:11:34 <shapr> kosmikus: Yup, dark wrote it ages ago.
13:11:56 <shapr> kosmikus: It seems to have had a huge surge of popularity on rec.games.roguelike the last few day.s
13:12:03 <shapr> I'm getting email about it since it's on my server.
13:12:08 <kosmikus> shapr: really?
13:12:16 <shapr> yeah, dark == Richard Braakman
13:12:23 <kosmikus> shapr: it's not particularly exciting except it's written in Haskell, right?
13:12:25 <shapr> aka dark at xs dot nl
13:12:27 <kosmikus> or is it alive
13:12:29 <shapr> kosmikus: That's what I thought...
13:12:48 <shapr> but it seems that a bunch of people are trying to build it and hack on it.
13:12:58 <kosmikus> nice
13:12:59 <huschi> shapr: what's haskellnet? dotnet for haskell?
13:13:11 <Notostraca> I could "host" the binary
13:13:16 <kosmikus> roguelike in Haskell is also still on my list of things to do
13:13:27 <Notostraca> rarhost.com would be good for this
13:13:34 <kosmikus> always wanted to make a project for a student practical out of this ;)
13:13:45 <shapr> huschi: Nah, HaskellNet is Jun Mukai's Summer of Code project. It started out with the modules he wrote before SoC, SMTP, POP3, etc.
13:14:00 <Notostraca> yeah, Haskell is ideal for large projects, so they say
13:14:17 <shapr> huschi: I was the mentor for that project, and I asked for Google's gdata API support if he got bored after writing the 'necessary' code.
13:14:30 <shapr> huschi: It seems that he got at least part way there.
13:14:49 <shapr> Notostraca: Are you T. Ettinger?
13:15:01 <Notostraca> Si`, sen~or
13:15:22 <shapr> muy bien!
13:15:29 <huschi> there seem to no docs on haskellnet.
13:15:34 <Notostraca> por favor el bano
13:15:51 <Notostraca> ^ a quote from a kid in my Spanish class
13:15:56 <shapr> Â¿habla espaÃ±ol?
13:16:00 <Notostraca> 3rd year HS spanish
13:16:41 <Notostraca> si`, un poco pequen~o
13:17:08 <shapr> talar du svenska?
13:17:26 <Notostraca> I speak swedish chef, at least
13:17:28 <shapr> hah
13:17:52 <shapr> Notostraca: So you're the guy who linked to mage on rec.games.roguelike.development then... I'll have to check my web logs and see how many hits it got...
13:18:02 <Notostraca> Sorry about that
13:18:21 <shapr> no, it's good!
13:18:24 <Notostraca> I didn't expect a whole lot of hits
13:18:34 <shapr> I like publicizing Haskell.
13:18:45 <Notostraca> well that is good
13:18:55 <shapr> Whether or not Haskell the language becomes popular is not as important as getting its ideas out into the world.
13:19:13 <Notostraca> the Black hole theory
13:20:13 <Notostraca> now, about the compiling...
13:20:23 <paolino> it's even becoming popular
13:20:27 <Notostraca> the code seems to use an older version of GHC
13:21:27 <Notostraca> the comments here
13:21:29 <Notostraca> http://groups.google.com/group/rec.games.roguelike.development/browse_thread/thread/8d25f057a90d87aa?hl=en*
13:21:32 <lambdabot> Title: rec.games.roguelike.development | Google Groups, http://tinyurl.com/2zekwq
13:21:59 <Notostraca> say something about Data.Set
13:22:27 <Notostraca> did it undergo major changes?
13:22:38 <dmead> bonk
13:22:43 <dmead> does ghc to proper tail recursion yet?
13:22:49 <syntaxfree> "something about Data.Set"
13:22:53 <shapr> dmead: As opposed to?
13:22:56 <dmead> the suspense is killing me
13:23:09 <dmead> not recognizing tail calls?
13:23:09 <kosmikus> Notostraca: I'll try to compile it on ghc-6.6
13:23:25 <Notostraca> the suspense kills me also.
13:23:40 <shapr> dmead: I think GHC has recognized tail calls longer than I've been using Haskell.
13:23:42 <sjanssen> dmead: I think GHC has been doing proper tail recursion for a long time now
13:23:57 <dmead> i read that it's not ghc that doesn't do it
13:24:01 <dmead> it's the gcc backend it uses
13:24:10 <dmead> which doesn't have proper tail support
13:24:22 <Lemmih> > foldr (+) 0 [1..1000000]
13:24:24 <lambdabot>  Exception: stack overflow
13:24:24 <Lemmih> > foldl' (+) 0 [1..1000000]
13:24:25 <sjanssen> dmead: do you have some quantitative evidence?
13:24:27 <lambdabot>  500000500000
13:24:43 <dmead> yea, gcc just got tail recursion support like 2 weeks ago
13:24:44 <kosmikus> Notostraca: it doesn't do much, iirc
13:25:11 <sjanssen> dmead: ghc handles the tail recursion itself
13:25:14 <shapr> dmead: You mean the mangler?
13:25:18 <shapr> ohh
13:25:22 <shapr> He means the Evil Mangler
13:25:24 <sjanssen> it mangles the code plenty before it gets to gcc
13:25:25 <Notostraca> kosmikus: mage?
13:25:30 <dmead> eh?
13:25:33 <dmead> hmm
13:25:37 <shapr> @google ghc evil mangler
13:25:40 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/mangler.html
13:25:40 <lambdabot> Title: The GHC Commentary - The Evil Mangler
13:25:42 <sjanssen> and the code after it leaves gcc too
13:26:04 <dmead> ghc just parses haskell into C right?
13:26:06 <sjanssen> dmead: do you have a program that seems to be lacking tail calls?
13:26:15 <dmead> no, but I've been wondering about this
13:26:29 <dmead> hmm
13:26:38 <sjanssen> dmead: no, it is far more complicated than parsing into C
13:26:50 <dmead> hmm
13:26:54 <dmead> nm then :)
13:27:00 <sjanssen> ghc treats C as a semi-platform independent assembler
13:27:05 <profmakx> hm. are there any known issues with ghc-6.6 under FreeBSD? I have run into a few strange problems with lambdabot and darcs as it seems -.-
13:27:45 <shapr> That treatment of C is the reason for the creation of C--
13:27:58 <kosmikus> Notostraca: yes
13:28:15 <Notostraca> Does the @ fight the monsters?
13:28:28 <Notostraca> if so, its good enough to work with
13:32:43 <kosmikus> I don't know anymore
13:32:52 <kosmikus> wait a moment :)
13:42:46 <chessguy> foldr (-) [2,-10]
13:42:47 <chessguy> > foldr (-) [2,-10]
13:42:49 <lambdabot>   add an instance declaration for (Num [a])
13:43:01 <chessguy> > foldr (-) 0 [2,-10]
13:43:03 <lambdabot>  12
13:46:00 <kosmikus> Notostraca: ok, got it to compile with ghc-6.6
13:46:02 <kosmikus> you have that?
13:47:29 <kosmikus> I'm just afraid you'll be disappointed
13:50:55 <chessguy> > (putStrLn "three") >> ((putStrln "two") >> ((putStrLn "one") >> (return ())))
13:50:57 <lambdabot>   Not in scope: `putStrln'
13:51:06 <chessguy> > (putStrLn "three") >> ((putStrLn "two") >> ((putStrLn "one") >> (return ())))
13:51:08 <lambdabot>  <IO ()>
13:51:18 <Botje> what's with all the parentheses?
13:51:38 <chessguy> just fiddling around
13:51:49 * Botje grabs a violin and fiddles along
13:51:57 <chessguy> > putStrLn "three" >> putStrLn "two" >> putStrLn "one" >> return ()
13:51:59 <lambdabot>  <IO ()>
13:52:00 <chessguy> better?
13:52:27 <chessguy> @type putStrLn "three" >> putStrLn "two" >> putStrLn "one"
13:52:29 <lambdabot> IO ()
13:52:34 <chessguy> hmm
13:52:44 <chessguy> what's the difference between <IO ()> and IO ()
13:53:58 <kosmikus> Notostraca: are you still there?
13:54:33 <norpan> IO () is the type
13:54:49 <kosmikus> chessguy: there's none <...> is just lambdabot's way to tell you it's printing the type rather than the value
13:54:49 <chessguy> but what's the <> mean
13:54:52 <norpan> <IO ()> seems to be what lambdabot prints when it's asked to show an IO () value
13:55:18 <norpan> i definitely remember it used to say no IO allowed
13:55:50 <chessguy> @type return
13:55:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
13:57:04 <chessguy> hm, so the return is what makes it actually execute the IO actions
13:57:06 <dons> now we allow it, but just don't evaluate the result
13:57:21 <chessguy> hs-plugins++
13:57:25 <dons> we just intercept the action, and rather than force it, print a string in its pace
13:57:28 <dons> place.
13:57:29 <dons> ?users
13:57:30 <lambdabot> Maximum users seen in #haskell: 322, currently: 299 (92.9%), active: 48 (16.1%)
13:57:50 <chessguy> :t putStrLn "three" >> putStrLn "two" >> putStrLn "one" >> return ()
13:57:52 <lambdabot> IO ()
13:57:53 <chessguy> :t putStrLn "three" >> putStrLn "two" >> putStrLn "one"
13:57:56 <lambdabot> IO ()
13:58:05 <chessguy> oh, they are the same type
14:02:09 <kosmikus> chessguy: surprised?
14:03:10 <kosmikus> hi dons
14:03:16 <dons> hey kosmikus
14:03:23 <chessguy> kosmikus, hmm?
14:03:37 <kosmikus> is ChilliX back in in .au ?
14:03:41 <dons> hey, LtU kosmikus http://lambda-the-ultimate.org/node/2017
14:03:43 <lambdabot> Title: Generic Programming, Now! | Lambda the Ultimate
14:03:46 <dons> kosmikus: yep, landed a few days ago
14:03:55 <dons> Gabi's back next week
14:04:32 <kosmikus> dons: thanks for the link, hadn't seen that one
14:04:39 <chessguy> kosmikus, are you talking about my comment about the two expressions?
14:05:46 <Saizan> ?hoogle installHandler
14:05:47 <lambdabot> GHC.ConsoleHandler.installHandler :: Handler -> IO Handler
14:05:58 <kosmikus> chessguy: yes
14:06:21 <Saizan> is installHandler somewhat unix-specific?
14:06:38 <chessguy> kosmikus, well i guess i expected return to change the type, yes.
14:08:15 <augustss> yo!
14:08:21 <kosmikus> chessguy: well, putStrLn is already of type String -> IO (), so putStrLn "one" :: IO (), which is the same as the type of "return ()"
14:08:35 <kosmikus> chessguy: if you'd return something different from (), it would change the type ...
14:08:57 <chessguy> mm, so why is the return () even needed?
14:09:13 <chessguy> ohhhh, it's not
14:09:16 <chessguy> duh :)
14:09:43 <chessguy> it's the identity for >>
14:09:53 <dons> mm. audreyt++   the tail of haskell addiction via the gateway drug, parsec http://notes-on-haskell.blogspot.com/2007/01/my-journey-to-haskell.html
14:09:56 <lambdabot> Title: Notes on Haskell: My Journey to Haskell, http://tinyurl.com/2246s6
14:13:06 <chessguy> @type gfoldl
14:13:08 <lambdabot> Not in scope: `gfoldl'
14:13:15 <chessguy> ?hoogle gfoldl
14:13:16 <lambdabot> Data.Generics.Basics.gfoldl :: Data a => (c (a -> b) -> a -> c b) -> (g -> c g) -> a -> c a
14:13:16 <lambdabot> Data.Generics.Twins.gfoldlAccum :: Data d => (a -> c (d -> r) -> d -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
14:13:36 <chessguy> yeesh
14:14:03 <chessguy> c (a -> b)
14:14:06 <chessguy> what's this?
14:14:49 <bd_> The paper warns you not to think to hard about it :)
14:14:52 <Hunter_wow> cant someone give me the easyest example of "read". Trying:   read "2" (whant to remove the string) But dosent work =(
14:14:56 <bd_> too*
14:15:03 <bd_> > read "2" :: Int
14:15:05 <lambdabot>  2
14:15:31 <Hunter_wow> aha, thanks a lot =)
14:15:33 <kosmikus> chessguy: return () is only the left identity for >>
14:15:38 <kosmikus> but it's still not needed in this case
14:15:56 <chessguy> kosmikus, yeah, i was tracing a foldr that used it
14:16:11 <chessguy> for which it was necessary
14:16:33 <bd_> Hunter_wow: You don't need the :: Int if haskell can guess what type it is from context, btw
14:16:39 <bd_> but with lambdabot it has no way of knowing
14:19:25 <therp> why is the latex beamer package so broken. I don't want to use openoffice
14:22:10 <kosmikus> therp: is it broken?
14:22:13 <glguy> http://blogs.nubgames.com/code/?p=19
14:22:15 <lambdabot> Title: Nub Games Â» Writing a Simple Search Engine in Haskell: Part 1 &#8212; Maybe and ...
14:22:21 <glguy> I don't get it, wtf does the first block of code do
14:22:41 <chessguy> @type mapM
14:22:43 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
14:22:46 <glguy> err, second block
14:22:47 <kosmikus> therp: in my opinion, it's one of the best-written packages that are there. of course, it can't change the essence of TeX, which has some inherent broken-ness.
14:22:48 <therp> kosmikus: well, xdvi is unable to render it's pgf generated postscript parts properly..
14:23:02 <kosmikus> just don't use xdvi.
14:23:05 <chessguy> @type mapM_
14:23:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
14:23:10 <kosmikus> why would anyone still use dvi?
14:23:50 <therp> kosmikus: because xdvi is able to quickly reload stuff.. what else target do you suggest?
14:23:59 <kosmikus> xpdf ?
14:24:58 <kosmikus> gv works as well, but since all TeX distributions are using pdftex as standard binary anyway, you can as well generate pdf immediately and save an unnecessary intermediate step.
14:25:00 <therp> hm. I suppose this won't work nicely with pstricks unless I dvipdf it
14:25:15 <chessguy> what the....
14:25:24 <chessguy> "Notice how in Haskell you can use pattern matching to combine the multiple tests into one case statement to avoid nested conditionals and ba neep gra na weep ninibon"
14:25:43 <chessguy> ack
14:25:46 <chessguy> </b>
14:26:01 <kosmikus> therp: ok. pstricks is a point in favor of the dvi->ps chain.
14:26:26 <kosmikus> therp: although I never used it, and pgf can do many of the same things (not all, I know).
14:26:42 <glguy> is there some trick I don't know, or is this just a syntax error?
14:26:42 <glguy> case (ff, ss, bb) of (Nothing, Nothing, Nothing) -> (m -> True)
14:26:52 <kosmikus> therp: but then you can still use "gv" as a viewer. dvips is fast, and gv reloads quickly as well.
14:26:59 <therp> kosmikus: hm, I started with pstricks..  there is no particular reason, I'm using it, except it was the first one
14:27:27 <chessguy> glguy, well, if we had a @load command to load from a pastebin, we could check real easy :)
14:27:36 <chessguy> (hint, hint)
14:28:00 <glguy> darcs gets http://kakapo.scannedinavian.com/~eric/hpaste   (hint hint ) ;)
14:28:03 <dons> glguy: why are you so mean in reddit comment? ;)
14:28:09 <therp> then I just have to teach auctex that it should run "make" instead of "latex". With pstricks you have to reload often, and then every additional key stroke is almost too much
14:28:12 <dons> you seem like such a civil guy, then on reddit you turn evil
14:28:31 <glguy> dons: I don't like misrepresentation of Haskell to the masses :-p
14:28:37 <SamB> maybe reddit is the dark side of the source?
14:28:42 <Notostraca> kosmikus: sorry, I'm back
14:28:44 <kosmikus> dons: show me the comment, please :)
14:28:58 <dons> be fun and nice about though, its better for our community.
14:29:01 <hpaste>  nomeata pasted "find span function" at http://hpaste.org/244
14:29:05 <Notostraca> They are filming the series finale of the OC at my house
14:29:06 <nomeata> Hi
14:29:14 <Pseudonym> There is no dark side of the source, really.  As a matter of fact it's all dark.
14:29:20 <dons> http://programming.reddit.com/user/glguy/ :)
14:29:23 <lambdabot> Title: overview by glguy (on programming.reddit.com)
14:29:25 <dons> Pseudonym: heh
14:29:28 <glguy> dons: but it's one poorly written content free blog posting after another!
14:29:28 <nomeata> I wrote this function that take a text and finds the spans of the sections, or something similar.
14:29:43 <kosmikus> Notostraca: didn't know you're that famous ;)
14:29:43 <dons> glguy: you already changed the comment?
14:29:53 <nomeata> It is recursive, and Iâm wondering: Can I sensibly re-write that using foldr, or mapAccumR, or something like that?
14:29:55 <glguy> dons: I have no idea what you are talking about!
14:30:04 <Notostraca> My house is; as for me...Hell no
14:30:21 <kosmikus> Notostraca: anyway, I have a patch that makes mage compile on ghc-6.6 and probably on ghc-6.4.2, too. I can only test on Linux tonight, I could produce a Windows binary tomorrow.
14:30:40 <Notostraca> WOW thanks!
14:30:50 <glguy> dons: and lots of my comments are in good spirits!
14:30:53 <dons> glguy: still, be nice! we don't want to be the next angry lispers ..
14:30:57 <dons> i know i know.
14:30:58 <nomeata> Or maybe the Writer Monad? It goes through the list, remembering when the section started and what the name is, and on a new section or the end of the list, it puts the span of the last section in the result.
14:31:30 <Notostraca> you could mail me at the address given on rgrd earlier, okay?
14:31:53 <kosmikus> dons: if I look at that page, I don't get anything. what's really written by who?
14:31:53 * dons watches cat try to unplug laptop
14:31:56 <Notostraca> I don't know if or where I should post it
14:32:28 <kosmikus> Notostraca: do you have ghc-6.6 installed?
14:32:33 <Notostraca> yes
14:32:42 <chessguy> is there a decent way to see only haskell-relevant posts on reddit?
14:32:46 <kosmikus> so I can send you the patch, and you can see whether it works for you.
14:32:50 <glguy> dons: and furthermore! ;) if you read past that first comment, I don't see how you can accuse me of displaying my contempt for the majority of reddit users
14:33:19 <chessguy> "but the important thing is that you've protected your ego!"
14:33:21 <chessguy> lol
14:33:29 <glguy> chessguy: well... read the parent comment!
14:33:40 <dmead> how can you not have contempt for reddit?
14:33:44 <dmead> :P
14:33:49 <kosmikus> Notostraca: it's at http://www.iai.uni-bonn.de/~loeh/mage-1.0pre35-ghc66.patch temporarily
14:33:59 <glguy>  13 points 2 months ago by glguy
14:33:59 <glguy> I'm pretty sure that qwe1234 is just part of some psychology experiment to see how a social bookmarking site responds to complete ignorance.
14:34:17 <chessguy> reddit befuddles me
14:34:17 <dons> glguy: i don't think qwe1234 is even around anymore
14:34:22 <glguy>  dons nope
14:34:26 <dons> i guess the project ended
14:34:34 <glguy> I wonder when they are publishing
14:34:34 <dylan> or ran out of funding.
14:35:02 <dons> ok, so dmead is a lot meaner than glguy ;)
14:35:22 <jgrimes> the latest issue of The Monad Reader is very cool
14:35:26 <nomeata> Hmm. Maybe  (catMaybes.mapAccumR) is what i want. But then, it does not allow me to produce output at the end of the input list.
14:35:35 <Notostraca> okay, got it.
14:35:40 <dylan> I've found among the average linux-using non-programmer geek-type has two reactions to the word "haskell".
14:35:41 <dons> jgrimes: i wonder if we can get html rendering somehow
14:35:42 * glguy is a model of helpfulness ;)
14:35:43 <dylan> Actually, three.
14:35:48 <dons> it would really open up the readership
14:35:56 <dons> dylan: oh, yes?
14:35:57 <Notostraca> where do I place it / how do I compile?
14:36:01 <dylan> "Haskell is that weird math language", "what is haskell?", and "Pascal???"
14:36:11 <dons> ok. that's fine.
14:36:18 <kosmikus> Notostraca: oh, right, Windows. do you have a "patch" somewhere?
14:36:32 <Notostraca> the...one you gave me?
14:36:40 <SamB> dylan: almost everyone I've mentioned it to has had the third one
14:36:41 <kosmikus> no, a program called patch.
14:36:41 <dylan> I found it's almost impossible to discuss the merits of haskell to those that don't know what a lambda is.
14:36:56 <SamB> where by "mentioned" I mean "mentioned in spoken communication"
14:37:00 <Notostraca> nope, no patch
14:37:03 <dylan> SamB: same here.
14:37:16 <kosmikus> Notostraca: I'll just put the patched archive online.
14:37:33 <Notostraca> rarhost.com is good
14:37:42 <dylan> I'm performing a sociological study of my LUG for sociology class. XD
14:38:05 <dylan> there's a big difference between the debian/ubuntu folk and the redhat folk, for instance.
14:38:07 <Notostraca> only hosts up to 500MB of rars though
14:38:17 <dylan> I have some nice field notes already.
14:38:27 <chessguy> > 3 ^ 361
14:38:29 <lambdabot>  1740896506590319279071882380705643679466027249502635411948281187068010516761...
14:38:55 <chessguy> ?hoogle log
14:38:56 <lambdabot> Prelude.log :: Floating a => a -> a
14:38:56 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
14:38:56 <lambdabot> GHC.ConsoleHandler.Logoff :: ConsoleEvent
14:38:59 <jgrimes> dons, aren't there several latex -> html translators? I haven't messed with latex much so I don't know how hard of a thing that is to do.
14:39:15 <sek> tex2html is one
14:39:16 <kosmikus> Notostraca: ok, http://www.iai.uni-bonn.de/~loeh/mage-1.0pre35-ghc66.zip
14:39:19 <chessguy> > log $ 3^361
14:39:20 <lambdabot>  396.5990362091876
14:39:24 <dons>   there are, but i'm not sure of the quality.
14:39:33 * dylan prefers texinfo because it makes decent HTML, PDF, docbook, and plain text.
14:39:39 <chessguy> > log 3^361
14:39:41 <lambdabot>  5.557089320679087e14
14:39:49 <dons> tex2page is pretty good
14:39:57 <dons> i wrote the hs-plugins man page in that before the days of haddock
14:39:58 <sjanssen> chessguy: parses as (log 3)^361
14:40:02 <dylan> I'm using xml2rfc for some documentation right now
14:40:12 <chessguy> sjanssen, hmm
14:40:18 <chessguy> > log 3
14:40:18 <dons> so the key isue would be marking up code and math properly
14:40:19 <lambdabot>  1.0986122886681098
14:40:23 <dons> what do the math guys use?
14:40:31 <chessguy> oh, base e
14:40:31 <Notostraca> kosmikus: how do I compile with GHC?
14:40:34 <dons> on their math blogs :) inline .png?
14:40:37 <Notostraca> n00b question...
14:40:45 <dons> ghc A.hs
14:40:46 <glguy> dons: but he was correct about my cringing :) (to keep on topic)
14:40:49 <sjanssen> > logBase 3 (3^361)
14:40:50 <lambdabot>  361.0
14:41:07 <chessguy> > logBase 10 (3^361)
14:41:07 <dylan> dons: btw, I am slowly rewriting dwm-related tools in haskell. So far, I have lsx and swarp ported. No major line number changes, sadly.
14:41:09 <lambdabot>  172.2407729537981
14:41:13 <jgrimes> dons, for some of them yeah. n-Category Cafe uses MathML
14:41:22 <dons> dylan: oh very nice!
14:41:30 <jgrimes> but not everyone likes MathML either
14:41:35 <Notostraca> which folder do I place Main.hs in?
14:41:36 <dylan> I should put my work in a darcs repo somewhere.
14:41:49 <kosmikus> Notostraca: I'll pm you the commands
14:41:51 <dylan> swarp was a fun exercise in using Graphics.X11.Xlib
14:45:11 <abz> I just had an epiphany: I just learn't the _real_ power of foldr = I don't think I'll ever need another map, or filter, or temporary variable
14:45:30 <abz> I haven't written a recursive function in days now.
14:45:31 <chessguy> ermm
14:45:43 <chessguy> foldr doesn't remove the need for map
14:45:49 <Hunter_wow> need any imports for "remaning"? (if its built in)
14:46:07 <chessguy> s/need for/convenience of/
14:46:16 <abz> chessguy: true
14:46:36 <Notostraca> kosmikus: talk here briefly? I have pdcurses, so I do have curses.h
14:47:14 <kosmikus> I see
14:47:34 <kosmikus> but it probably doesn't work with the same commands as I've given you?
14:48:08 <Notostraca> on Windows?
14:48:25 <chessguy> (i think map can be written in terms of foldr, can't it?
14:48:36 <sjanssen> chessguy: correct
14:48:42 <kosmikus> Notostraca: yes? command line? :)
14:48:45 <chessguy> would be really messy though
14:48:50 <Notostraca> you mentioned lncurses, lcurses, and hsc2hs
14:48:52 <sjanssen> @type \f -> foldr (\x xs -> f x : xs) []
14:48:54 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
14:49:09 <sjanssen> chessguy: not so bad, but I'd rather write "map" instead
14:49:12 <Notostraca> Also I have no idea where to put this/call GHC
14:49:36 <chessguy> > (\f -> foldr (\x xs -> f x : xs) []) (^2) [1..]
14:49:38 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
14:50:08 <glguy> :t \f -> foldr ((:) . f) []
14:50:10 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
14:50:28 <kosmikus> Notostraca: you unpack the .zip, you change to the mage-1.35.../src directory, there you type the commands
14:50:34 <glguy> :t flip foldr [] . ((:) .)
14:50:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:50:36 <kosmikus> hsc2hs should be part of the ghc distribution
14:50:53 <Notostraca> ghc is not a recognized command
14:51:11 <kosmikus> you have to put the ghc binary directory in your path
14:51:53 <Notostraca> ghc/bin must be put into magepreblah?
14:52:09 <kosmikus> no
14:52:15 <kosmikus> in your search path
14:52:29 <Notostraca> never done this before
14:52:40 <Saizan> Notostraca, you need to edit your %Path% variable, like set PATH=%PATH%;C:\path\to\ghc;C:\path\to\ghc\bin
14:52:41 <Notostraca> which file do i edit?
14:52:46 <kosmikus> ok. I'll try on a Windows machine tomorrow, but I can't promise anything.
14:52:52 <kosmikus> I'm not very good at Windows myself.
14:52:55 <Notostraca> sorry.....
14:53:16 <kosmikus> if you're online tomorrow, I'll tell you about the results.
14:53:34 <Saizan> is there an archive i can try?
14:53:53 <Saizan> found in the logs
14:54:14 <Notostraca> or, e-mail me.
14:56:01 <Odd_Bloke> Can anyone recommend a good Haskell tutorial? The one I've been following thus far is less than ideal...
14:56:27 <dons> Odd_Bloke: the best tutorials are listed on haskell.org under 'Tutorials and books'
14:56:28 <Notostraca> Odd_Bloke: do you speak anything already?
14:56:31 <dons> but one of the best is YAHT
14:56:33 <dons> ?where yaht
14:56:34 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:56:39 <dons> we usually recommend that one
14:56:45 <dons> its also available from the haskell wikibook
14:56:49 <dons> ?where wikibook
14:56:50 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:57:20 <dons> Odd_Bloke: welcome!
14:57:21 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
14:57:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:57:33 <Odd_Bloke> Notostraca: Python, Java.
14:57:44 --- mode: ChanServ set +o glguy
14:58:01 --- kick: glguy_ was kicked by glguy (My fiancee is using my laptop)
14:58:01 <Notostraca> not C or C++? really? CONGRATULATIONS!
14:58:08 --- mode: glguy set -o glguy
14:58:10 <kosmikus> dons: nice, didn't know that one ...
14:58:24 <dons> ?where+ tutorials http://haskell.org/haskellwiki/Books_and_tutorials
14:58:25 <lambdabot> Done.
14:58:28 <Notostraca> python wins!
14:58:36 <dons> Odd_Bloke: in general we try to centralise all the key documents on haskell.org
14:58:41 <dons> or at least link to them from there
14:58:46 <Notostraca> but Haskell kneecaps it to take the Gold!
14:58:46 <sjanssen> glguy: don't trust the fiancee in #haskell? ;)
14:58:50 <dons> so http://haskell.org is the best palce to start
14:58:52 <lambdabot> Title: Haskell - HaskellWiki
14:59:05 <glguy> sjanssen: naw, just don't want her to see me talking at work
14:59:19 <glguy> sjanssen: and then complain that I didn't come home early if I wasn't doing anything ;)
14:59:29 <sjanssen> heh
14:59:56 <chessguy> lol
15:00:08 <sjanssen> Notostraca: I blame you if people call Haskell the "Tonya Harding" of programming languages
15:00:16 <Notostraca> lol
15:00:27 <dons> heh
15:00:42 <Notostraca> it does do things in an unorthodox way...
15:01:06 <Notostraca> like bypassing excess code the way tonya bypassed the law...
15:01:19 <glguy> When you have a sledgehammer, everything looks like a nail
15:01:25 <glguy> but when you have a pipe...
15:01:31 <glguy> everything looks like a kneecap?
15:02:19 <Philippa> I was thinking something more herbal
15:03:09 <glguy> ack, class
15:03:10 <Notostraca> oh, I get it!
15:03:11 * glguy &
15:05:12 <chessguygoinghom> whatever
15:07:26 <Saizan> what does it mean if your program completes the first 4 iterations in a second and then gets stuck for 45 minutes on the fifth managing to slow down your pc even if with 2% cpu and ~40mb ram usage? :\
15:07:55 <augustss> sounds odd
15:09:07 <Saizan> each iteration writes a file via binary's encodeFile
15:09:21 <dons> is it small enough to post a test case?
15:09:54 <Saizan> it's 136 lines
15:10:07 <dons> self contained?
15:10:13 <bogdano> Saizan: what does strace shows?
15:10:22 <dons> can you strip it down to a reproducible test case?
15:10:51 <Saizan> mmh i'll try
15:11:25 <Saizan> (by the way the crash with -threaded was resolved with ghc HEAD)
15:12:03 <dons> good to know.
15:12:27 <mgsloan> wow. clean really looks a lot like haskell
15:13:15 <mgsloan> haskell - monads + uniqueness type inference = clean
15:13:34 <mgsloan> forgot the - community...
15:14:31 <Masklinn> #quote cjeris
15:14:37 <Masklinn> @quote cjeris
15:14:38 <lambdabot> cjeris says: and it's amazing what some languages do to make thinking impossible, seemingly justified by the assumption that no one thinks anyway, so it's more important to make non-thinking
15:14:38 <lambdabot> programming as easy as possible.  see ColdFusion.
15:14:49 <augustss> clean is close to haskell.  they just had to make it a little fifferent :(
15:14:59 <augustss> s/fiff/diff/
15:15:00 <mgsloan> yeah :/
15:15:12 <Masklinn> mgsloan > how does clean handle I/O without monad?
15:15:23 <Masklinn> it stays impure?
15:15:25 <Masklinn> @quote cjeris
15:15:25 <mgsloan> those unique type thingamabobs
15:15:26 <lambdabot> cjeris says: and it's amazing what some languages do to make thinking impossible, seemingly justified by the assumption that no one thinks anyway, so it's more important to make non-thinking
15:15:26 <lambdabot> programming as easy as possible.  see ColdFusion.
15:15:36 <mgsloan> I'm looking into it atm, actually
15:15:53 <augustss> the world has to be threaded manually.  and single threaded
15:16:08 <Masklinn> mgsloan > Ok. I'll just write it down on my list of "languages to check once head has stopped exploding at the sight of haskell code"
15:16:18 <mgsloan> hehe
15:16:26 <mbishop> clean isn't free, that's mroe than likely the reason it failed
15:16:29 <Philippa> yeah, I'd rather have it in a monad anyway - less possibility to screw up
15:16:30 <mgsloan> augustss: yikes.  well, haskell way is definitely better
15:16:44 <Philippa> OTOH, having uniqueness typing is great for making things like that efficient
15:16:55 <dons> Start world
15:16:55 <dons>    # (console, world) = stdio world
15:16:55 <dons>    = toString (sumints console 0) +++ "\n"
15:17:32 <augustss> mgsloan: well, uniqueness types are very convenient for some things.  better than haskell, i'd say.  but monads are more general
15:17:44 <dons> sometimes clean feels very low level, like getting at Ptrs from C in haskell,
15:17:45 <dons> sumints f sumi
15:17:46 <dons>    # (ok,i,f) = freadi f
15:17:46 <dons>    | not ok = sumi
15:17:46 <dons>    = sumints f (sumi+i)
15:17:51 <sorear> mbishop: it's not?  iirc it's gpl `join` proprietary
15:18:08 <mgsloan> huh. dons - I'm actually interested in that low-levelness
15:18:33 <dons> the above looks almost like a wrapper to fread. though we'd just use bytestrings for this now.
15:18:33 <Masklinn> mbishop > isn't clean dual-licensed?
15:18:59 <Masklinn> dons > wait, you're also a Clean hacker?
15:19:04 <mbishop> dual licensed is as good as non free for those crazy RMS types
15:19:05 <augustss> sorear: is it meet or join? :)
15:19:19 <sorear> augustss: join.
15:19:49 <dons> sum s n | Just (m,t) -> sum t (n+m)  | otherwise = n
15:20:10 <dons> oh, missing code.
15:20:19 <dons> | Just (m,t) <- readInt s = ...
15:20:31 <mgsloan> are uniqueness types just something to make it so you can't split the world in two?
15:20:45 <mbishop> http://www-users.cs.york.ac.uk/~mfn/hacle/
15:20:51 <lambdabot> Title: Hacle
15:21:27 <nmessenger> mgsloan: also they allow the compiler to optimize construction to desctructive update, from what I've read
15:22:10 <sorear> does clean have any unsafeMakeWorld/unsafeSplitWorld?  (by analogy w/ unsafe{Perform,Interleave}IO)
15:22:40 <bd_> There'd need to be an unsafeCombineWorld too I'd think
15:22:49 <bd_> or unsafeSeqWorld, or something...
15:22:58 <Saizan> unsafeEndTheWorld?
15:23:13 <bd_> unsafeWouldYouLikeToPlayAGame
15:23:45 <bd_> [very unsafe...]
15:23:47 <mbishop> clean seems to be out of date
15:23:58 <mgsloan> the website is, at least :P
15:24:02 <mbishop> their IDE isn't even available on mac or linux
15:24:57 <beschmi> mbishop: yeah, unlike the haskell ide ;)
15:25:15 <mbishop> heh
15:25:19 <dons> emacs is available everywhere!
15:25:26 <sorear> emacs IS an OS
15:25:54 * sorear wants his house/yi/ghc only system
15:26:03 <mbishop> dual licensing is a terrible idea, I get they want to make money, give support, etc, but what if someone makes a great library...and it's commercial
15:26:07 <mbishop> you're SOL
15:26:21 <beschmi> sorear: how is synhl coming along?
15:26:45 <Pseudonym> Where can I get drivers for my wireless network card for Emacs?
15:27:27 <sorear> Pseudonym: I think your best bet is a Linux emulation layer rigged for 12K stacks :(
15:27:35 <mbishop> wikipedia says Clean is available for "Linux, but with limited input-output capabilities and without the "Dynamics" feature."
15:27:50 <sorear> the 12K is something of a code ... don't try to figure it out
15:27:52 <Odd_Bloke> Hmm, I've just copied the code from the examples in the tutorial and yet it's not working. The relevant code and the error are at http://pastebin.ca/336317, could someone point out where I'm going wrong?
15:28:15 <dons> Odd_Bloke: you can use hpaste.org next time, its a bit nicer for haskell, and announces your pastes in here
15:28:20 <hpaste>  rahikkala pasted "I'm failing to understand typeclasses" at http://hpaste.org/245
15:28:28 <Odd_Bloke> dons: Ah, OK, will do.
15:28:33 <sorear> syntaxfree: awake?
15:29:05 <syntaxfree> yes.
15:29:19 <syntaxfree> at least to the extent I'veen awake for the past month.
15:29:47 <sorear> syntaxfree: Oleg has done work on parameterized typeclasses that could *easily* be adapted for your purpose.
15:29:54 <sorear> @google Implicit configurations
15:29:55 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
15:30:00 <syntaxfree> sorear: the Implicit Configurations paper?
15:30:04 <sorear> yes.
15:30:04 <syntaxfree> Yes, I've been referred to that.
15:30:22 <syntaxfree> thanks!
15:30:36 <nmessenger> Odd_Bloke: your example usage is incorrect, it should be *Blah> listLength (Cons 1 Nil)
15:30:55 <nmessenger> the code is fine
15:31:48 <Odd_Bloke> nmessenger: Yeah, I assumed the code was fine, the knuckleheadedness all mine.
15:32:10 <sorear> beschmi: not *badly*.  Jhc distracted me yesterday (it's kinda hard to hack with 200% memory utilization), and my refusal to consider line-oriented highlighting has also been a minor roadblock, but I at least know what to check next.
15:32:31 <nmessenger> knuckleheadedness is usually proportional to inexperience, so no worries :)
15:33:59 <beschmi> sorear: oh i remember that you used your last 0.3% of cpu for irc yesterday
15:34:39 <syntaxfree> jhc.
15:34:41 <sorear> next plan: find a way to access the DFA in alex.
15:34:49 <syntaxfree> I knew nhc, yhc, hbc, but jhc is new to me.
15:34:58 <sorear> syntaxfree: JohnMeacham
15:35:01 <Odd_Bloke> nmessenger: If you'll forgive me asking a further question, I'm confused as to how a List of more than one element could be created via that method. If I don't give it a single parameter and then Nil, I cause an error.
15:35:06 <syntaxfree> ahhh.
15:35:10 <syntaxfree> yes, yes, I saw that.
15:35:24 <sorear> super-optimizing, stalin/mlton for haskell
15:35:32 <sorear> wants 450MB to compile base
15:35:37 <syntaxfree> Odd_Bloke: be recursive.
15:35:41 * rahikkala fails to fix his typeclass problem, decides to sleep on it
15:35:48 <syntaxfree> Cons (Elem (Cons Elem Nil))
15:35:53 <nmessenger> Odd_Bloke: (Cons 1 (Cons 2 (Cons 3 Nil)))
15:36:51 <Odd_Bloke> syntaxfree, nmessenger: Thanks, that should've occurred to me before now. :p
15:36:57 <nmessenger> Odd_Bloke: notice the similarity to ((:) 1 ((:) 2 ((:) 3 []))) -> 1 : (2 : (3 : [])) -> 1:2:3:[] -> [1,2,3]
15:37:24 <sorear> gah.  Yi uses *completely different* buffer types in Gtk and !Gtk.
15:37:32 <Odd_Bloke> nmessenger: I do _now_. :p
15:38:20 <syntaxfree> Odd_Bloke: Welcome to the Club For People With Regular Brains.
15:39:35 <hyrax42> will instance Monad ((->) e) ever be part of the Prelude?
15:40:41 <Jaak> @hoogle forM
15:40:42 <lambdabot> Text.Html.form :: Html -> Html
15:40:42 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
15:40:42 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
15:40:47 <Jaak> bah
15:41:04 <hyrax42> ?hoogle forM_
15:41:05 <lambdabot> No matches found
15:41:14 <hyrax42> Jaak: forM = flip mapM
15:41:26 <hyrax42> ?inded forM
15:41:27 <lambdabot> bzzt
15:41:27 <givi> ?foldr
15:41:34 <Jaak> i know, i was just hoping it was defined somewhere
15:41:34 <givi> oops...
15:41:46 <hyrax42> Jaak: I think it is...
15:41:54 <givi> ?hoogle foldr
15:41:55 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
15:41:55 <lambdabot> Prelude.foldr1 :: (a -> a -> a) -> [a] -> a
15:41:55 <lambdabot> Data.PackedString.foldrPS :: (Char -> a -> a) -> a -> PackedString -> a
15:42:03 <hyrax42> ?index forM_
15:42:04 <lambdabot> bzzt
15:42:07 <hyrax42> hm
15:42:36 <nmessenger> :b Control.Monad shows it in ghci... strange
15:42:49 <sorear> nmessenger: you must be using 6.6
15:42:59 <sorear> nmessenger: lambdabot is still using 6.4.x
15:43:05 <sorear> (6.5 to be exact)
15:43:18 <nmessenger> that explains it
15:43:27 <givi> how can one get a list of all lambdabot commands?
15:43:28 <hyrax42> Jaak: I think they are in Control.Monad regardless of what lb says
15:43:34 <hyrax42> ?list
15:43:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:43:42 <nmessenger> givi: or '/msg lambdabot @'
15:43:43 <sorear> now that Lemmih has fixed 6.6/hs-plugins, the but can be upgrated.
15:43:46 <givi> :))) neat!
15:43:58 <sorear>  @list-all
15:43:59 <Jaak> no forM_ in Control.Monad
15:44:40 <nmessenger> Jaak: 6.4?
15:44:42 <int-e> forM_ is rather new; you can use  flip mapM_  instead.
15:44:43 <Jaak> yes
15:44:53 <hyrax42> Jaak: I think it was added in Aug 30 or so
15:45:10 <Jaak> owkay, i can live with one extra line :P
15:45:55 <nomeata> What is the difference between ?hoogle and @hoogle?
15:45:59 <nmessenger> none
15:46:34 <givi> I love this channel! :-d
15:46:37 <nmessenger> whichever you think looks cooler
15:46:40 <nomeata> ah, ok, now I see the _ at the endof hyrax42âs ?hoogle line. itâs late.
15:47:25 <hyrax42> nomeata: ?
15:47:29 <hyrax42> ?localtime nomeata
15:47:31 <lambdabot> Local time for nomeata is Fri Feb  2 00:42:45
15:47:58 <hyrax42> france/germany/anywhere in Europe except the UK?
15:48:07 <nomeata> ?localtime hyrax42
15:48:09 <lambdabot> Local time for hyrax42 is 2007-02-01 18:43:23 -0500
15:48:17 <nomeata> hyrax42: exactly. central europe time
15:48:38 <givi> nomeata: Where are you from&
15:48:40 <givi> ?
15:48:42 <hyrax42> I know my timezones :p
15:49:09 <sorear> @localtime sorear
15:49:10 <lambdabot> Local time for sorear is Thu Feb  1 15:44:24 2007
15:49:24 <sorear> (pop quiz!)
15:49:31 <hyrax42> PT
15:49:41 <nmessenger> somewhere in Australia?
15:49:44 <hyrax42> PDT specifically, I believe
15:49:48 <nomeata> givi: Germany, Herrenberg
15:50:02 <sorear> ding ding!
15:50:08 <nomeata> @localtime lambdabot
15:50:08 <lambdabot> I live on the internet, do you expect me to have a local time?
15:50:12 <nmessenger> wait, no, that's 3 pm, Pacific?
15:50:16 <hyrax42> lol
15:50:17 <givi> Can anyone explain it to a newbie:
15:50:19 <givi> main = interact f
15:50:19 <givi>     where f = unlines . takeWhile (/="42") . words
15:50:34 <givi> what is .?
15:50:41 <mauke> function composition
15:50:42 <hyrax42> ?src (.)
15:50:43 <lambdabot> (.) f g x = f (g x)
15:50:45 <sorear> that reads words, and prints them one at a time until 42
15:50:49 <nomeata> givi: it takes two functions and makes a new function out of it
15:50:50 <mauke> (f . g) x = f (g x)
15:51:01 <nmessenger> givi: it "pipes" functions together so the output of 'g' becomes the input of 'f'
15:51:03 <nomeata> givi: be feeding oneâs output into the next function
15:51:14 <nomeata> givi: like Unix pipe, just the other direction (right to left)
15:51:30 <nomeata> ?src mapAccumR
15:51:30 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:51:41 <nomeata> ?src List.mapAccumR
15:51:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:51:56 <nomeata> ?src foldr
15:51:56 <lambdabot> foldr k z xs = go xs
15:51:57 <lambdabot>     where go []     = z
15:51:57 <lambdabot>           go (y:ys) = y `k` go ys
15:52:01 <hyrax42> what are these mapAccumR/L functions
15:52:11 <nomeata> hyrax42: a mixture of map and foldr
15:52:26 <Botje> I'm working through SPJones' "implementation of functional programming languages"
15:52:33 <Botje> i'm a bit scared of the G-machine chapters.
15:52:33 <nomeata> hyrax42: while mapping the list, you can pass a value through
15:52:45 <Botje> are they worth the time to understand them?
15:52:54 <hyrax42> nomeata: hmm
15:53:03 <givi> what is the meaning of ` in Haskell?
15:53:07 <nmessenger> @src mapAccumR
15:53:08 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:53:19 <Botje> givi: you can use `fun` to make a function infix
15:53:23 <mauke> givi: x `f` y = f x y
15:53:37 <givi> cool! thanx! :)
15:53:50 <sorear> STG is fun!  I dunno, I haven't been able to read them yet
15:53:51 <nomeata> > mapAccumR (\n line -> (show n ++ line, n+1)) 0 ["a","b","c"]
15:53:52 <lambdabot>   add an instance declaration for (Num [Char])
15:53:53 <nmessenger> givi: so (2 `elem` [1,2,3]) = (elem 2 [1,2,3])
15:54:00 <Botje> mauke: I read about SK(I) calculus today. it's scary :]
15:54:11 <nomeata> > mapAccumR (\n line -> (n+1, show n ++ line)) 0 ["a","b","c"]
15:54:12 <lambdabot>  (3,["2a","1b","0c"])
15:54:45 <nomeata> > mapAccumL (\n line -> (n+1, "This is element Nr. "++show n ++": "++ line)) 1 ["a","b","c"]
15:54:46 <lambdabot>  (4,["This is element Nr. 1: a","This is element Nr. 2: b","This is element N...
15:55:10 <nmessenger> SKI is fun!  Haskell's S is '((->) e) ap', K is 'const', I is 'id'
15:55:35 <nomeata> hyrax42: you see, you can pass a state (in this case, the count of line) while mapping the elements of the list. it returns both the last state and the list of results.
15:55:45 <sorear> K is also 'return' - use only monadics!
15:55:47 <givi> ?index interact
15:55:47 <lambdabot> System.IO, Prelude
15:55:53 <hyrax42> nomeata: I see
15:55:55 <nmessenger> @pl \f g h -> f h (g h)
15:55:56 <lambdabot> ap
15:55:58 <hyrax42> could be useful
15:55:59 <givi> ?src interact
15:55:59 <lambdabot> interact f = do s <- getContents; putStr (f s)
15:56:04 <hpaste>  bamboo pasted "a simple stateful gtk app" at http://hpaste.org/246
15:56:31 <mauke> @unlambda `.zv
15:56:32 <lambdabot>  z
15:56:37 <nomeata> hyrax42: havenât used it myself yet. for me, it takes longer to think about how to apply it correctly, than writing the recursion myself. but itâs probably a matter of training.
15:56:52 <hyrax42> nomeata: that's true for most of those thingies
15:57:01 <nomeata> hmm. not map. :-)
15:57:18 <nmessenger> ?type not map
15:57:20 <lambdabot>     Expecting a function type, but found `Bool'
15:57:20 <lambdabot>       Expected type: Bool
15:57:34 <hyrax42> nomeata: well partly the first thing but mostly I mean the matter of training/learning/experience part
15:57:36 <nomeata> but yes, for anything but map and filter I mostly (still) write it out
15:58:00 <nomeata> speaking of: is there a better, not explicit, way of writing this function: http://hpaste.org/244
15:58:10 <nomeata> mapAccumL does not seem to fit there
15:58:33 <mauke> haha, findspans anfang
15:58:46 <nomeata> ups. I better fix that in my code :-)
15:58:48 <givi> I love this channel one more time! Thanks everybody ;) Haskell society is fun!
15:58:55 <hyrax42> what is anfang
15:59:00 <mauke> beginning
15:59:09 <nomeata> s/anfang/first/
15:59:11 <hyrax42> givi: it is very good
15:59:19 <Saizan> if i build a big list from small chunks and then i need to reverse it, is it better to reverse each chunk instead? memory-wise
15:59:26 <givi> mauke: are you German too?
15:59:35 <mauke> givi: yes
15:59:38 <nmessenger> nomeata: also should s/->/<-/?
15:59:51 <nomeata> nmessenger: where?
15:59:52 <hyrax42> nomeata: unrelated question, how you get the arguments to line up automatically
15:59:57 <hyrax42> the wildcards
16:00:00 <givi> I love Germans! I love German :)
16:00:10 <givi> Too many emotions... bb
16:00:11 <nmessenger> nomeata: oh, nevermind, I was thinking pattern bindings
16:00:36 <nomeata> nmessenger: nope, just case :-)
16:01:04 <nomeata> hyrax42: my using the large key on your keyboard. but thatâs manually, not automatically, Iâm afraid :-)
16:01:19 <nomeata> nmessenger: I hope it is clear what the function does.
16:01:20 <hyrax42> nomeata: oh :(
16:01:47 * mbishop shields his eyes from those crazy non unicode characters
16:01:58 <Botje> mbishop: mÃ¸Ã¸se!
16:02:14 <hpaste>  nomeata annotated "find span function" with "De-Germanized" at http://hpaste.org/244#a1
16:03:13 <hyrax42> what are the (Int, Int)
16:03:43 <nomeata> hyrax42: the lines from where to where a certain section, defined by a Just from the extract function, ranges
16:04:06 <hyrax42> oh the Nothing is
16:04:07 <hyrax42> ah
16:04:08 <hyrax42> ok
16:04:09 <hyrax42> got it
16:04:34 <nomeata> I use it to find the line ranges of chapters in a LaTeX Document. The first is then called "Preamble"...
16:05:00 <nmessenger> nomeata: it seems clear enough.  Possibly the matching on the list could be replaced by 'foldr', but it's not obvious to me how.
16:05:00 <hyrax42> useful?
16:05:25 <nomeata> hyrax42: I use it, see http://mitschriebwiki.nomeata.de/Stochastik1.html
16:05:27 <lambdabot> Title: Das VorlesungsMitschiebWiki - ./data/Stochastik1.tex
16:05:37 <nomeata> the line numbers are hidden in the edit links (âbearbeitenâ)
16:06:22 <hyrax42> I saw
16:07:17 <nomeata> Maybe it could be re-written in a nice way using the Writer monad or something (after all, it goes through the list and write something)
16:07:26 <nomeata> But I donât see how that helps with clarity.
16:08:12 <nomeata> (And I donât know the Writer Monad enough to know how it would look)
16:08:29 <nmessenger> maybe map extract over the lines and work with the Maybe headers more directly?
16:09:18 <nomeata> nmessenger: true, findspan f a == findspan id a . map f
16:09:23 <chessguy> hi haskellers
16:09:34 <nmessenger> hi chessguy
16:09:44 <nomeata> nmessenger: but that does not really change the function
16:09:48 <bd_> hm, why is there no Data.Sequence.toList?
16:10:06 <bd_> @hoogle Seq a -> [a]
16:10:07 <lambdabot> No matches, try a more general search
16:10:15 <emu> bd_: it's Foldable
16:10:29 <emu> @doc Foldable
16:10:30 <nomeata> nmessenger: but then, if I do that, I can rewrite the case as function pattern matching, which looks nicer.
16:10:30 <lambdabot> Foldable not available
16:10:31 <bd_> ah
16:10:49 <nmessenger> I was typing that, nomeata!
16:11:01 <nmessenger> :P
16:11:03 <bd_> emu: Foldable.toList, I guess?
16:11:08 <hpaste>  beelsebob pasted "Am I missing something here" at http://hpaste.org/247
16:11:19 <beelsebob> anyone here know how to work happy well?
16:11:19 <bd_> [in that case, shouldn't there be a Monoid.fromList? :)]
16:11:46 <hpaste>  nomeata annotated "find span function" with "Move extract into a map" at http://hpaste.org/244#a2
16:12:41 <nomeata> nmessenger: I moved the extract outside the helper function. It looks a bit nicer, but itâs still explicit recursion, and does not use some cool haskell function/monad.
16:14:12 <nmessenger> nomeata: I think possibly findspans' could be a foldr, /me tries to hack on it.
16:15:23 <nomeata> nmessenger: it surely can, but either changing the "to" line of the last element of the list (in case of a non-header), or by appending a new such element
16:15:46 <nmessenger> (++Nothing)?
16:16:04 <nomeata> nmessenger: but I doubt that it is nicer than the explicit one. at least in this way, this would be a case of âimplement it in foldr for the sake of itâ than real code improvement
16:16:26 <nmessenger> ?src sum
16:16:26 <lambdabot> sum = foldl (+) 0
16:17:49 <chessguy> anybody here have SOE?
16:17:49 <hyrax42> nomeata: I'm messing around with it
16:17:53 <hyrax42> it'll be unreadable if I get anywhere
16:22:01 <hpaste>  nomeata annotated "find span function" with "Untested, but typechecked shot at foldl" at http://hpaste.org/244#a3
16:22:32 <nomeata> I donât like how this passes around the complete output list in the foldr, and either extends it or modified the current element.
16:22:50 <nomeata> nmessenger: is that what you are hacking at the moment as well?
16:23:10 <nomeata> hmm. (1,9) should be (1,0) of course
16:23:44 <nmessenger> seems clearish, but I was also thinking of zipping the (Int,Int) onto the [line] and filtering somehow
16:24:53 <nomeata> nmessenger: thatâs how I started, with the line number zipped to each line. the problem with (Int,Int) is that the second Int is unknown at that moment.
16:24:55 <hyrax42> nomeata: your (Int,Int) are 1-indexed as well as first, last inclusive?
16:25:02 <nomeata> hyrax42: yes
16:25:18 <nomeata> hyrax42: intuitively numbered, Iâd call it :-)
16:25:38 <sorear> newtype Alex a = Alex { unAlex :: AlexState -> Either String (AlexState, a) }  -- is MTL really that slow?
16:25:59 <sorear> as opposed to:
16:26:14 <sorear> @unmtl StateT AlexState (Error String) a
16:26:15 <lambdabot> err: Unknown MTL(1)
16:26:19 <sorear> @unmtl StateT AlexState (Either String) a
16:26:20 <lambdabot> err: Unknown MTL(1)
16:26:25 <sorear> @unmtl StateT AlexState (Either String) a
16:26:26 <lambdabot> err: Unknown MTL(1)
16:26:29 <sorear> @unmtl StateT AlexState (Either String)
16:26:30 <lambdabot> err: Unknown MTL(1)
16:26:40 <sorear> nm unmtl
16:26:54 <nmessenger> so does (let ((_,b1):_):(a2:_):_) = findspans ... in b1 == a2 - 1) hold?
16:27:29 <nmessenger> is each upper bound one less than the next lower bound?
16:27:37 <nomeata> nmessenger: Yes, unless there is a bug :-)
16:27:39 <hyrax42> nomeata: I'll get back to it later
16:27:44 <hyrax42> food time
16:28:01 <nomeata> hyrax42: I might be off, but if you come up with anything interested, mail@joachim-breitner.de will listen to it :-)
16:28:02 <hyrax42> (it's been a while since I messed around much with haskell :/)
16:28:17 <hyrax42> nomeata: I'm not aiming for understandable or readable :p
16:28:46 <nomeata> nmessenger: one way might be zipping the lines with [1..], filtering for the captions, and then use that to reassemble the spans
16:28:48 <tessier_> Why are academic papers always written in this annoying two column style? And why is my computer monitor never big enough to be able to read the whole page top to bottom without scrolling? How annoying.
16:29:03 <hyrax42> nomeata: I'm zipping, and groupBy-ing
16:29:04 <tessier_> Read the first column, scroll, scroll, end of column, scroll to top, read second column, scroll, scroll...
16:29:05 <dons> to pack words into 12 pages . blame the publisher
16:29:12 <nomeata> nmessenger: but I did not like that because it would also need the lenght of the list
16:29:16 <tessier_> 55 pages of Haskell history written in two column format.
16:29:18 <SamB> tessier: maybe if you turned it sideways it would work better?
16:29:25 <nomeata> hyrax42: grouping is an interesting idea
16:29:26 <tessier_> SamB: Turned what sideways?
16:29:32 <SamB> the monitor
16:29:43 <SamB> ... I know, not usually practical...
16:29:47 <tessier_> SamB: Then the text is all sideways.
16:29:49 <nomeata> tessier_: or the chair
16:29:50 <Excedrin> convert pdf to txt problem solved
16:29:51 <SamB> hah
16:30:07 <SamB> it works better if you can get the image turned sideways to match
16:30:13 <SamB> (that is, the other way)
16:30:53 <sorear> dons: @unmtl doesn't do Either
16:30:55 <hyrax42> nomeata:
16:31:08 <nmessenger> nomeata: not really: zip [1..] $ (++ Just emptyHeader) $ map extact lines
16:31:14 <hyrax42> findspans ... = groupBy (equating (isNothing.snd)) . zip [1..] .  map extract $ (first:list)
16:31:17 <hyrax42> is getting close-ish
16:31:57 <hyrax42> just need to get the indices of the spans
16:32:01 <hyrax42> but now food is waitng
16:32:29 <nomeata> nmessenger: the Just emptyHeader is somewhat a hack, but might be a viable obtion nevertheless
16:32:30 <beelsebob> how would anyone here go about debugging a happy parser?
16:32:43 <dmead> use parsec?
16:32:45 <dmead> instead?
16:32:46 <dmead> :P
16:32:49 <beelsebob> :P
16:32:53 <mbishop> :P
16:33:01 <siti> :P
16:33:06 <dmead> isn't happy part of the preprocessor?
16:33:21 <sorear> dmead: happy is a preprocessor
16:33:31 <dmead> ah
16:33:36 <sorear> dmead: there is no Haskell Preprocessor for happy to be part of
16:33:45 * nmessenger has to go
16:33:46 <dmead> gotcha
16:33:47 <nomeata> it should probably be findspans ... =  groupBy (isNothing.snd) . zip [1..] .  map extract $ (first:list)
16:33:57 <nomeata> nmessenger: cu and thx
16:34:17 <dons> sjanssen: I submitted a faster sumcol, http://haskell.org/haskellwiki/Shootout/SumFile#Fastest_.28twice_as_fast_as_old_Char_entry.29
16:34:21 <lambdabot> Title: Shootout/SumFile - HaskellWiki, http://tinyurl.com/yv3nd9
16:34:46 <nomeata> Iâm leaving as well. The explicit version is not too bad, after all :-)
16:36:51 <dmead> is it nessicary to understand the innards of ghc to write the shootoff examples?
16:37:25 <nomeata> this probably works. very haskellish :-) findspans first extract = . map (\((n,h):l) -> ((n,n+lenght l),fromMaybe first h). groupBy (isNothing.snd) . zip [1..] .  map extract
16:37:31 <dmead> or can you figure out a fast solution just on the visible structure
16:39:47 <mbishop> How can I get a random element from a list? I'm trying "list !! randomRIO (1, (length list))" but it gives an error (expected Int against inferred type IO t)
16:40:00 <dons> dmead: not usually, but it helps to know how things are compiled, once you start chasing C
16:40:00 <sorear> one moment ...
16:40:13 <dons> getting a reasonable solutoin doesn't require innards
16:40:24 <dmead> hmm
16:40:29 <dons> getting a beats-just-about-everything, well, that requires compiler knowledge in any language
16:40:36 <dmead> right right
16:40:53 <sorear> mbishop: Lib/Util.hs, line 220, in lambdabot.
16:40:57 <dons> also helps if you wrote the core library the code depends upon ;)
16:41:02 <sorear> @where lambdabot
16:41:02 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:41:06 <mbishop> sorear: thanks, I'll look
16:41:13 <dmead> =)
16:41:16 <nomeata> @pl \(a,b)->b
16:41:16 <lambdabot> snd
16:41:28 <nomeata> @pl \a b -> b
16:41:28 <lambdabot> const id
16:41:35 <sorear> mbishop: that's the code used for @quote and @src's rudeness :)
16:41:47 <nomeata> @pl flip const
16:41:47 <lambdabot> const id
16:42:02 <sorear> nomeata: you probing the refactorings?
16:43:14 <nomeata> sorear: no, just confirming what I thought earlier: flip const == const id
16:46:11 <hpaste>  nomeata annotated "find span function" with "the type-correct oneliner. somewhat typical for bad haskell, is it?" at http://hpaste.org/244#a4
16:47:42 <nomeata> @pl findspans first extract = map (\((n,h):l) -> ((n,n+length l),fromMaybe first h)) . groupBy (const (isNothing.snd)) . zip [1..] .  map extract in findspan
16:47:42 <lambdabot> (line 1, column 143):
16:47:42 <lambdabot> unexpected reserved word "in" or "i"
16:47:42 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
16:47:52 <nomeata> @pl let findspans first extract = map (\((n,h):l) -> ((n,n+length l),fromMaybe first h)) . groupBy (const (isNothing.snd)) . zip [1..] .  map extract in findspan
16:47:52 <lambdabot> findspan
16:47:57 <nomeata> @pl let findspans first extract = map (\((n,h):l) -> ((n,n+length l),fromMaybe first h)) . groupBy (const (isNothing.snd)) . zip [1..] .  map extract in findspans
16:48:02 <lambdabot> (. (((groupBy (const (isNothing . snd)) . zip [1..]) .) . map)) . (.) . map . (`ap` tail) . (. head) . (`ap` snd) . (. fst) . flip ((.) . flip . ((,) .) . liftM2 (.) (,) ((. length) . (+))) .
16:48:02 <lambdabot> fromMaybe
16:48:17 <dmead> ew
16:48:22 <dmead> thats some ugly code
16:48:23 <dmead> =/
16:48:23 <augustss> mmmmmmm, pointless
16:48:27 <dmead> lol
16:48:27 <nomeata> yay for pointless style
16:48:44 <augustss> completely incomprehensible
16:48:52 <nomeata> Haskell would be ideal for people worried about their intelectual properties
16:49:07 <nomeata> this is less usefull than assember generated from C
16:49:11 <nomeata> (ok, not really, but close)
16:49:14 <sorear> "This is called `job security'."
16:49:35 <dons> pity there's @unpl ...
16:49:42 <SamB> dons: hahaha
16:49:52 <nomeata> @unpl (. (((groupBy (const (isNothing . snd)) . zip [1..]) .) . map)) . (.) . map . (`ap` tail) . (. head) . (`ap` snd) . (. fst) . flip ((.) . flip . ((,) .) . liftM2 (.) (,) ((. length) . (+))) .fromMaybe
16:49:52 <lambdabot> (\ af bz f -> map ((\ cf -> ((\ ci p s -> ((,)) (((,) >>= \ v -> (\ bw co -> bw + (length co)) >>= \ u -> return (\ ab -> v (u ab))) (fst ci) s) (fromMaybe af p)) >>= \ cw -> snd >>= \ cv -> return (
16:49:53 <lambdabot> cw cv)) (head cf)) >>= \ cq -> tail >>= \ cp -> return (cq cp)) (groupBy (\ _ bk -> isNothing (snd bk)) (zip [1 ..] (map bz f))))
16:50:07 <nomeata> hmm. does not really help :-)
16:50:16 <dons> hehe
16:50:37 <augustss> when i ran the first (aka bottomth) obfuscated haskell code contest i was surprised people didn't use more of the wonderful obfuscartions haskell has available
16:50:51 <Excedrin> are there programs where repeated @pl and @unpl continuously grows?
16:50:54 <mauke> unpl is worse than pl
16:51:01 <dmead> so uhh
16:51:02 <nomeata> dons: what style  http://hpaste.org/244 do you prefer: the explicit recursion the foldl, or the oneliner?
16:51:04 <dmead> what does that code do?
16:51:04 <dons> @. unpl pl \f x -> f x
16:51:05 <lambdabot> (\ a -> a)
16:51:29 <nomeata> dmead: see  http://hpaste.org/244
16:51:46 <dons> looks like an unfoldr ?
16:51:50 <dmead> ah
16:51:58 <dmead> mm
16:52:12 <nomeata> dons: not really, the input is a list (a list of LaTeX code lines)
16:52:25 <dmead> isn't using fold less flexible than writting your own recursion?
16:52:26 <dons> ah ok. more a filter . map or some such?
16:52:39 <nomeata> dons: and it generated the list of chapter captions, including the span of lines this chapter applies to
16:52:42 <dons> yeah, like using while and for loops is less flexible than goto
16:52:55 <dmead> hmm
16:53:04 <nomeata> dons: âfirstâ is the name of the 0th chapter, in the LaTeX-Case, âPreambleâ
16:53:06 <Excedrin> dons: I just built lambdabot from darcs, it sort of works, but it has these errors: "Data.Binary.Get.takeExactly: Wanted 8 bytes, found 0" when I run it in standalone, any ideas?
16:53:08 <dmead> i'm curious if my main function in my prover can be used with fold
16:53:27 <dmead> i just don't see how you could do it
16:53:27 <nomeata> dons: I first thought of mapAccumL, but thatâs not completely it
16:54:14 <dons> Excedrin: interesting. try removing State/seen
16:54:57 <augustss> dmead: fold is less powerful, but not very much less
16:55:11 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/Prover.hs
16:55:18 <dmead> resolvedb
16:55:19 <beschmi> can you expect more potential for optimizations (fusion) when using foldr instead of explicit recursion?
16:55:19 <dmead> at the bottom
16:55:41 <nomeata> peoply do all kinds of things with fold, like zip or takeWhile :-)
16:55:42 <dons> beschmi: yes
16:55:50 <Philippa> yes, it's much easier to spot a catamorphism that's actually labelled as such
16:56:02 <hpaste>  dmead pasted "fold?" at http://hpaste.org/248
16:56:39 <augustss> dmead: hmmm, do you want comments on that code?  it can be simplified
16:56:43 <nomeata> dmead: resolvedb(x:[])   = [x] can be resolvedb([x])   = [x] :-)
16:56:44 <sorear> dons: I've finally found a very good solution to the inc lexing problem, and it's just a wrapper, no need to touch the alex internals.
16:57:00 <sorear> dons: now if I can just force myself to fix the gtk build :)
16:57:02 <dons> oh, sounds good
16:57:02 <dmead> hmm
16:57:10 <dmead> [x] is a list right?
16:57:12 <dmead> like in ml?
16:57:13 <sorear> right
16:57:22 <dmead> but i want to match to a singleton list
16:57:28 <sorear> don't know ml, but [x] is a singleton list
16:57:29 <augustss> dmead: you have committed many of the sins I spank students for ;)
16:57:33 <dmead> =p
16:57:51 <augustss> why write 'if c then True else False'?
16:57:52 <dmead> this was an independent project
16:57:59 <dmead> where?
16:57:59 <sorear> dmead: also drhaskell was created for times like this - check it out
16:58:18 <sorear> (it's nowhere near complete, but it does do stuff)
16:58:20 <mauke> willResolve
16:58:22 <sorear> @where drhaskell
16:58:23 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
16:58:24 <dons> sorear: have yo uused drhaskell?
16:58:28 <sorear> dons: nope.
16:58:32 <mauke> shouldResolve
16:58:35 <dons> ndm should put drhaskell online, i think. then people might actually use it
16:58:39 <dons> avoiding the need to get yhc built
16:58:40 <mauke> isTautology
16:58:41 <sorear> dons: I just pulled the docs out of memory :)
16:58:57 <dmead> oh
16:58:57 <dmead> mm
16:59:03 <dmead> ah thats right
16:59:09 <mauke> if x then True else y can be written as x || y
16:59:12 <dmead> i hadn't touched that for quite a while
16:59:13 <dmead> yea
16:59:50 <dmead> i should upload a version with proper comments
16:59:52 <dmead> :o
16:59:53 <augustss> dmead: and use curried functions, not tuples
17:00:08 <dmead> yea i've gotten that alot
17:00:16 <dmead> soon i'll start working on it again
17:00:38 <augustss> dmead: negationIn(a, xs) = any (a `negationOf`) xs
17:00:48 <dmead> ahh
17:00:51 <dmead> didn't know about any
17:00:55 <augustss> with currying
17:01:01 <hpaste>  nomeata annotated "fold?" with "Some changes" at http://hpaste.org/248#a1
17:01:08 <sorear> @ask glguy filters.  drhaskell. ghc 2>&1, ghc6.7 2>&1, ghc6.4.2 2>&1.  links for "pipe paste/annotatation into $foo".  big box for entering code.  (hpaste)
17:01:09 <lambdabot> Consider it noted.
17:01:20 <augustss> negationIn a = any (a `negationOf`)
17:01:24 <nomeata> dmead: just a few things I consider nicer
17:01:30 <dmead> ah
17:01:35 <dmead> yea, looks a bit simpler like ML
17:01:52 <sorear> ML? simpler? *faint* :p
17:01:56 <dmead> =p
17:02:32 <dmead> yea i wrote this as i was learning haskell
17:02:38 <dmead> so there are some problems =p
17:02:53 <sorear> anyway, Haskell is not ML, and currying is standard.  just because you CAN write FORTRAN in Perl doesn't mean you should.
17:03:03 <dmead> hehe
17:03:36 <dmead> with currying does it always associate long parameters correctly?
17:03:40 <dmead> or do you have to use some parens
17:03:44 <dmead> for specificity
17:04:02 <hyrax42> nomeata: you got it?
17:04:05 <sorear> sometimes parens are needed yes
17:04:13 <sorear> > (+) 1 (*) 2 3
17:04:14 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
17:04:17 <sorear> > (+) 1 ((*) 2 3)
17:04:19 <lambdabot>  7
17:04:28 <hpaste>  nomeata annotated "fold?" with "even shorter" at http://hpaste.org/248#a2
17:04:44 <nomeata> hyrax42: yes, see hpaste. Although I donât like it :-)
17:05:02 <dmead> with darcs
17:05:07 <hyrax42> nomeata: not surprising...
17:05:08 <dmead> i've made changes to my working copy
17:05:12 <mauke> *Main> (+) 1 (*) 2 3
17:05:12 <mauke> 7
17:05:18 <dmead> and i want to insert it into the _darcs stuff
17:05:20 <dmead> whats the command?
17:05:23 <dmead> darcs record?
17:05:25 <sorear> record?
17:05:29 <dmead> k
17:05:34 <sorear> be sure to add first
17:05:36 <sorear> and init
17:05:41 <dmead> no files were added
17:05:42 <sorear> :)
17:05:46 <dmead> just code changes
17:05:46 <sorear> ok.
17:05:46 <dmead> etc
17:05:49 <sorear> ok.
17:06:01 <hyrax42> ?t const (isNothing.snd)
17:06:01 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
17:06:04 <dmead> yea darcs is much nicer than subversion
17:06:08 <dmead> too bad it doesn't scale
17:06:11 <bd_> hyrax42: :t or ?type
17:06:13 <hyrax42> :p const (isNothing.snd)
17:06:17 <hyrax42> arrg
17:06:21 <hyrax42> :t const (isNothing.snd)
17:06:23 <lambdabot> forall a a1 b. b -> (a1, Maybe a) -> Bool
17:06:58 <sorear> dmead: it scales well! when you rewrite that 30MB C Program in subversion into Haskell, it shrinks to a darcs-compatible 30K :)
17:07:01 <nomeata> Why is there no "when' c a = if c then a else mzero"
17:07:06 <dmead> =)
17:07:10 <nomeata> @type let when' c a = if c then a else mzero in when'
17:07:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> m a -> m a
17:07:20 <bd_> nomeata: guard c >> a
17:07:24 <sorear> nomeata: when' = guard
17:07:26 <bd_> @pl \c a -> guard c >> a
17:07:26 <lambdabot> (>>) . guard
17:07:30 <dmead> i set up darcs for some guys at my internship
17:07:32 <nomeata> bd_: ok, true
17:07:34 <sorear> er, that.
17:07:36 <dmead> it's in c++ but nothing too long
17:07:48 <hyrax42> ?src guard
17:07:48 <lambdabot> guard True  =  return ()
17:07:49 <lambdabot> guard False =  mzero
17:07:51 <sorear> what do they think?
17:08:01 <dmead> i've go to demo it
17:08:02 <sorear> (have you told them about #darcs ?)
17:08:08 <dmead> hehe not as yet
17:08:14 <dmead> *got to demo it
17:08:43 <sorear> your questions will be answered in 10s ... 3pm - 10pm PDT :(
17:10:34 <hpaste>  nomeata annotated "fold?" with "Monad magic instead of else [] " at http://hpaste.org/248#a3
17:10:39 <hyrax42> ?pl \((n,h):l) -> ((n,n+length l),fromMaybe first h)
17:10:40 <lambdabot> ap (uncurry ((. fromMaybe first) . flip . ((,) .) . liftM2 (.) (,) ((. length) . (+))) . head) tail
17:10:56 <hyrax42> hahaha
17:11:08 <beschmi> dmead: did you set up darcsweb?
17:11:12 <chessguy> ?hoogle map
17:11:13 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
17:11:13 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
17:11:13 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
17:11:21 <chessguy> ?hoogle mapAccumL
17:11:21 <nomeata> hyrax42: I ?plâed the whole function further up there. thatâs a beast...
17:11:22 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
17:11:22 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:11:32 <dmead> beschmi: we're gonna use it over ssh in an internal network
17:11:35 <dmead> it's only 6 guys
17:12:03 <hyrax42> nomeata: I'll save my eyes
17:12:06 <beschmi> dmead: ok, but darcsweb is nice for browsing the code. especially for people new to darcs
17:12:14 <chessguy> ?hoogle a -> b -> (a, c)
17:12:14 <dmead> hmm
17:12:15 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
17:12:15 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
17:12:17 <dmead> i'll take a look
17:12:25 <hyrax42> ?src cycle
17:12:26 <lambdabot> cycle [] = undefined
17:12:26 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
17:12:44 <beschmi> dmead: http://www.llucax.com.ar/~luca/repos/darcsweb/?r=darcsweb;a=summary
17:12:48 <lambdabot> Title: darcs - darcsweb, http://tinyurl.com/2b7r4t
17:12:50 <nomeata> ?djinn a -> b -> (a,c)
17:12:51 <lambdabot> -- f cannot be realized.
17:13:56 * nomeata got to go, far too late already. Any nicer variants of http://hpaste.org/244 are welcome :-)
17:14:01 <augustss> nomeata: wanna make a c out of thin air? :)
17:15:14 <mauke> flang [] = []; flang [Nothing] = []; flang (Nothing : _ : xs) = flang xs; flang (Just x : xs) = x : flang xs
17:15:25 <mauke> your task, should you choose to accept it, is to rewrite flang in terms of foldr
17:16:40 <nomeata> mauke: is it catMaybes with all Justâs following a Nothing ignored?
17:17:01 <mauke> no, consider [Nothing, Nothing, Just 2]
17:17:32 <nomeata> results in [], does it?
17:17:43 <mauke> should be [2]
17:17:44 <jcreigh> It's not obvious to me how you could do that with a foldr. I suppose that's the point. :)
17:17:44 <sorear> no, that results in [2]
17:17:53 <sorear> sure it can!
17:18:00 <augustss> of course it can
17:18:13 <nomeata> > let flang [] = []; flang [Nothing] = []; flang (Nothing : _ : xs) = flang xs; flang (Just x : xs) = x : flang xs in flang  [Nothing, Nothing, Just 2]
17:18:15 <lambdabot>  [2]
17:18:20 <nomeata> ok, it is too late for me :-)
17:18:21 <edwinb> depends how readable you want it to be...
17:18:45 <nomeata> ah, I see: there have to be a even number of Nothings before a Just for it to count
17:18:52 <jcreigh> I didn't say impossible...just non-obvious, and probably confusing.
17:19:13 <nomeata> would be a case for mapAccumL, Iâd say
17:19:59 <nomeata> Itâs actually quite similar to my problem in http://hpaste.org/244, just that i need to know the numbers of Nothingâs _following_ a Just
17:20:15 <chessguy> speaking of mapAccumL, some really nice examples here: http://www.zvon.org/other/haskell/Outputlist/mapAccumL_f.html
17:20:16 <lambdabot> Title: Haskell : mapAccumL
17:20:57 <nomeata> mapAccumL could cound the Nothings, turn wrong Justs into Nothings, and then apply catMaybe to the result.
17:21:50 <DapperDan2> has anybody read Graham Hutton's new 'Learning Haskell' book?
17:22:02 <nomeata> and then I have to find someone who has written mapAccumL in terms of foldr. good night :-)
17:22:28 <newsham> ?farber
17:22:28 <lambdabot> Unknown command, try @list
17:22:33 <augustss> no, but i'm gonna look for graham's book this weekend
17:22:40 <DapperDan2> 'Programming in haskell' even
17:22:42 <mbishop> DapperDan2: I haven't, but I would be interesting in finding out what people think about it
17:22:52 <DapperDan2> no reviews to be found online
17:22:58 <DapperDan2> i ordered a copy
17:23:06 <Philippa> I haven't, his lectures were good though
17:23:19 <DapperDan2> what did you think of hudak/the multimedia book?
17:23:21 <Philippa> well, good for what they were aiming to do - I taught myself a lot about how to hack in haskell
17:23:42 <Philippa> OTOH I missed the lecture on monads so I couldn't tell you if that was any good either :-)
17:24:09 <DapperDan2> sounds like a bad one to miss phillipa :)
17:24:36 <Philippa> I managed to teach myself well enough to be one of the people who did a lot of the explaining on here for a good year or so
17:24:56 <Philippa> these days people seem to get pointed at tutorials a lot more often instead
17:25:03 <DapperDan2> from hutton's material? that sounds like an endorsement to me.
17:25:18 <newsham> ?type positions
17:25:19 <DapperDan2> the tutorials go so far. i've gotten a lot from hudak's book and the hpaste source code.
17:25:20 <lambdabot> Not in scope: `positions'
17:25:34 <Philippa> from what was available generally. And I only really came back to Haskell a couple of years later looking to write interpreters, typecheckers and so forth
17:25:52 <Philippa> but I'd got a lot of how to do FP generally from his lectures and the exercises, which helped a lot
17:25:58 <DapperDan2> not enough to do what i want though, which is write http/rest resource implementations.
17:26:32 <Philippa> hmm. Would seeing source for a simple wiki based on the old version of Network.CGI help?
17:26:49 <Philippa> the new version's a little more involved, but I don't think it's horrendously so
17:26:52 <DapperDan2> yep definitely.
17:27:14 <Philippa> http://www.flippac.org/projects/flippi/index.html <- grab the oldest version
17:27:16 <DapperDan2> happs is a little too much to swallow at once.
17:27:16 <lambdabot> Title: Flippi: a Wiki clone written in Haskell
17:27:29 <sorear> dons: gtk build fixed!
17:27:39 <newsham> sorear: yay
17:28:21 <sorear> it won't highlight however - the differences are too great to port my changes with my current lack of understanding of the gtk port :(
17:28:23 <Philippa> the newer version's got extra stuff you don't care about, v0.02's nice and minimalistic
17:29:51 <Excedrin> Philippa: is there a running one somewhere?
17:30:08 <Philippa> Excedrin: not that I know of now, unfortunately
17:30:31 <Philippa> oh, and I think v0.02 uses Data.FiniteMap as well
17:30:36 <Philippa> though I could be wrong
17:31:05 <Philippa> it otherwise builds straight out of the zip with a ghc --make though
17:31:07 <chessguy> has gtk2hs been released?
17:31:24 <dcoutts> chessguy, I'm just doing testing for the RC2
17:31:38 <newsham> http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe is up, is that what you mean?
17:31:47 <dcoutts> that's RC1
17:32:13 <dcoutts> so yeah, RC2 should be out today/tomorrow
17:32:25 <beelsebob> glguy: *poke*
17:33:06 <sorear> @seen glguy
17:33:06 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 2h 29m 54s ago.
17:34:30 <sorear> glguy: *prod* hpaste is unidentified again
17:34:44 <chessguy> hmm. what's pango?
17:34:53 <newsham> text stuff
17:34:57 <sorear> chessguy: a test-layout lib
17:35:08 <sorear> C, with unofficial Haskell bindings
17:35:09 <beelsebob> @tell glguy Prod me about a bug in hpaste
17:35:10 <lambdabot> Consider it noted.
17:35:54 <sorear> @tell glguy hpaste is unid'd again (not a BIG deal)
17:35:54 <lambdabot> Consider it noted.
17:36:05 <dons> sorear: uni'd?
17:36:12 <sorear> un id'd
17:36:31 <sorear> as in <*hpaste> foo
17:37:18 <sorear> dons: btw, gtk/yi works again (no highlighting, sorry)
17:37:43 <dons> great
17:38:04 <newsham> ?farber
17:38:04 <lambdabot> Unknown command, try @list
17:41:36 <beschmi> DapperDan2:  i learned monads from hutton&meijer's paper about monadic parsing, i think there is a chapter about that in the book too
17:42:03 <sorear> now for *haskell* coloring!
17:42:38 <beschmi> sorear: there is a stripped down lexer in the vshaskell sources
17:42:47 <augustss> the haskell coloring book?
17:42:49 <DapperDan2> thanks all for your help.
17:43:00 <edwinb> haskell by numbers?
17:43:06 <dmead> =o
17:43:16 <newsham> easy as [1..3]
17:43:40 <sorear> beschmi: I know.  but I don't want to use it because yi is line-agnostic - installing it would require far too much BufferImpl hacking.
17:44:00 <sorear> besides, I have sunk costs.
17:44:14 <sorear> I know how to make *any* alex lexer incremental.
17:44:28 <newsham> sunk costs should not affect future decisions, only marginal future costs and benefits
17:44:31 <augustss> one of funniest programming books i've seen is "A Fortran Coloring Book"
17:44:50 <edwinb> augustss: this scares me...
17:45:02 <edwinb> please tell me where I can find it ;)
17:45:08 <SamB> augustss: it should not be surprising that this is one of the funniest books, with a title like that
17:45:25 <dibblego> :t forall
17:45:27 <lambdabot> Not in scope: `forall'
17:45:36 <dibblego> ?hoogle [Bool] -> Bool
17:45:37 <lambdabot> Prelude.and :: [Bool] -> Bool
17:45:37 <lambdabot> Prelude.or :: [Bool] -> Bool
17:45:38 <augustss> as we all know, the '=' in FORTRAN is the gozzinta sign
17:45:49 <newsham> :type all
17:45:51 <chessguy> ?hoogle all
17:45:52 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
17:45:52 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
17:45:52 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
17:45:53 <bd_> dibblego: forall is a type operator, not a function
17:46:07 <chessguy> ?hoogle and
17:46:07 <newsham> > all (< 10) [1..8]
17:46:07 <lambdabot> Prelude.and :: [Bool] -> Bool
17:46:08 <lambdabot> Prelude.significand :: RealFloat a => a -> a
17:46:08 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
17:46:09 <lambdabot>  True
17:46:35 <dibblego> I was just looking for â
17:47:09 <augustss> @src all
17:47:09 <sorear> you mean C's ?: ?
17:47:10 <lambdabot> all p =  and . map p
17:47:24 <newsham> ?src if'
17:47:25 <lambdabot> Source not found. Are you on drugs?
17:47:41 <sorear> x ? y : z ==> if x then y else z
17:47:48 <sorear> ugly, we know :(
17:47:59 <dibblego> no, and does what I need, thanks
17:49:04 <dons> sjanssen: Summary: GHC 6.6 ByteString-based sumcol.hs
17:49:04 <dons> >Resolution: Accepted
17:49:31 <dons> sjanssen: so the process is to submit new versoins. i'm hackign fasta.hs atm (it sucks on the 25M value of N atm)
17:49:43 <chessguy> is HSOE based on gtk2hs?
17:49:55 <chessguy> for its animation stuff
17:50:23 <dcoutts> chessguy, no, but there's an implementation of the SOE API included with Gtk2Hs
17:50:44 <dcoutts> the original implementation was based on the HGL which is unsupported (and ugly)
17:50:48 <chessguy> dcoutts, so it's library-independent?
17:51:04 <SamB> unfortunately the SOE API does not support text measurement
17:51:16 <SamB> chessguy: more than one library implements the API, if that is what you mean...
17:51:26 <SamB> you have to adjust your imports though
17:51:32 <dcoutts> SamB, that'd be easy to add to the Gtk implementation, it's just a matter of exposing the underlying functionality
17:51:45 <chessguy> i guess what i want to know is what i need to install to be able to write the programs in it
17:52:05 <dcoutts> chessguy, well of course I'd say you can install Gtk2Hs and get an implementation that way
17:52:22 <dcoutts> or you can use the original implementation of Graphics.SOE
17:52:28 <dcoutts> which is included in the hgl package
17:52:32 <SamB> but why would you want to do that?
17:53:00 <chessguy> SamB, do what?
17:53:47 <newsham> if I bind an operator in a let-binding, is it always right-assocative?
17:53:55 <dcoutts> the 'soegtk' package is bundled with the latest version of Gtk2Hs, or there's a stand-alone version that works with the older release of Gtk2Hs
17:53:58 <SamB> use Graphics.SOE from the HGL package...
17:54:07 <newsham> > let ($) x f = f x in 1 $ (2 $ (+))
17:54:09 <lambdabot>  3
17:54:13 <sorear> newsham: I think it's non-associative
17:54:15 <newsham> how can I make $ assoc right?
17:54:24 <chessguy> now i'm really confused. i guess i'll wait until the book comes
17:54:27 <sorear> > let (?) x f = x f in 1 ? 2 ? 3
17:54:28 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
17:54:35 <chessguy> but i am going to try to get gtk2hs running anyway
17:54:35 <sorear> > let (?) x f = x f in (+) ? 2 ? 3
17:54:37 <lambdabot>  5
17:54:42 <sorear> gah.
17:54:45 <newsham> > let ($) x f = f x in 1 $ 2 $ (+)
17:54:46 <lambdabot>   add an instance declaration for (Num (t -> a))
17:54:50 <newsham> see.. its associng left
17:55:02 <sorear> lambda lift!
17:55:10 <dcoutts> chessguy, are you on windows or linux?
17:55:32 <chessguy> 64-bit fedora core
17:55:58 <newsham> chess: you code lisp at all?
17:56:11 <chessguy> newsham, not really
17:56:51 <chessguy> did a little scheme for a class, and looked at Koza's genetic programming, which is in lisp. that's about it
17:56:52 <chessguy> why?
17:56:53 <newsham> I was hoping that since ($) is normally right-assoc i could just borrow it and keep its assoc
17:59:54 <newsham> can you specify infixr in lambdabot?
18:00:26 <newsham> > infixr 5 ?; let (?) x f = f x in 1 ? 2 ? (+)
18:00:27 <lambdabot>  Parse error
18:00:59 <sorear> newsham: you *could* in principle, but it's not implemented.
18:01:10 <newsham> infixr 5 ?
18:01:10 <newsham> (?) x f = f x
18:01:11 <newsham> main = print $ 1 ? 2 ? (+)
18:01:13 <newsham> works for me
18:01:56 <chessguy> dcoutts, does gtk2hs RC2 no longer rely on Data.FiniteMap?
18:02:41 <dcoutts> chessguy, right. All the pre-releases and RCs work with ghc-6.6
18:02:59 <chessguy> cool
18:03:32 <dcoutts> chessguy, if you install RC1 right now you're going to be annoyed when I release RC2 in half an hour... ;-)
18:03:38 <chessguy> ?where haddock
18:03:38 <lambdabot> http://www.haskell.org/haddock/
18:03:51 <chessguy> dcoutts, i can't anyway, unless i roll back to 6.4 :)
18:04:28 * dcoutts doesn't understand
18:04:51 <dcoutts> it works with ghc-6.2 to 6.6
18:05:05 <dcoutts> (and probably 6.0 but I've not tested that)
18:05:13 <chessguy> hmm. it's failing to make because it wants Data.FiniteMap
18:08:12 <ctkrohn> Has anyone heard of any general-purpose GPU projects using Haskell?
18:08:21 <ctkrohn> Seems like it could be an interesting area...
18:08:32 <dons> ctkrohn: yeah.. we've a phd student working on it
18:08:34 <chessguy> GPU?
18:08:42 <jcreigh> graphics processing unit?
18:09:05 <chessguy> glitch-patching utility?
18:09:15 <ctkrohn> dons: interesting, does he have a website or something?
18:09:17 <sorear> ctkrohn: dunno if it qualifies as GP, but I figured out how to trick a GPU into rendering fractals
18:09:36 <dons> ctkrohn: http://cgi.cse.unsw.edu.au/~seanl/index.cgi/Research
18:09:37 <lambdabot> Title: Research - Sean's Wiki
18:09:38 <dons> ?where dph
18:09:39 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
18:09:45 <dons> the idea is to compile dph array code onto the gpu
18:09:52 <sorear> (and then stopped because of 5-yr-old crash bugs in Xorg that I reliably tickled)
18:10:02 <dons> he's got scanls, folds, maps, filters and zips running from a C library on the gpu
18:10:02 <ctkrohn> dons: ah, I just found that link in a comment you left in a reddit thread :)
18:10:12 <ctkrohn> interesting
18:10:13 <sorear> (oh, and I was implementing it in Haskell/HOpenGL)
18:17:43 <Z4rd0Z> When I'm inside the IO monad, an IO string should behave as a string, right?  For example, a function that takes a string argument should accept an IO string..if not, how the heck am I supposed to read a file into a string and then pass it to a function?
18:19:14 <sorear> you aren't "inside IO"
18:19:17 <Cale> Z4rd0Z: no, an IO String is an action, which when executed, will produce a String
18:19:18 <dons> Z4rd0Z: you use the do notation to unwrap the value
18:19:28 <sorear> IO just allows you to combine actions
18:19:35 <dons> do s <- readFile "foo" ; print (reverse s)
18:19:41 <Cale> You use "str <- act" inside a do-block to run the action and get the string.
18:19:48 <dons> here s :: String, and readFile "foo" :: IO String
18:19:52 <sorear> if you have foo :: IO String and bar :: String -> IO () , you can write foo >>= bar :: IO ()
18:20:12 <dons> Z4rd0Z: welcome to monadic side effects
18:20:28 <Cale> @wiki Introduction_to_IO
18:20:28 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
18:20:29 <dons> you can't interchange IO String and String, since IO String is side effecting
18:20:32 <Cale> read that :)
18:20:50 <Z4rd0Z> yes well, I'm doing that:  readFile "foo" >>= \xmlstr ->
18:21:25 <Cale> xmlstr will be of type String
18:21:27 <Z4rd0Z> I've read it all, it's just that a function that supposedly takes a string as an argument won't let me use xmlstr as an argument
18:21:27 <dons> yep, and xmlstr :: String
18:21:40 <dons> hmm. the above code looks fine
18:21:45 <Cale> oh, it will. Let's see the rest of your code?
18:21:51 <dons> could you hpaste.org the larger fragment?
18:21:54 <dons> ?paste
18:21:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:22:02 <dons> and the error
18:23:26 <hpaste>  Z4rd0Z pasted "xml pretty printing" at http://hpaste.org/251
18:24:03 <Cale> What's the type of HX.xmlParse ?
18:24:22 <hpaste>  Z4rd0Z pasted "xml pretty printing error" at http://hpaste.org/252
18:24:54 <sorear> is xmlParse an IO action?
18:25:08 <nmessenger> Z4rd0Z: add return (...) to the last line
18:25:16 <SamB> sorear: isn't it in that funky arrow?
18:25:16 <Cale> yeah, xmlParse is producing a Document
18:25:20 <Cale> not an IO action
18:26:07 <hpaste>  Cale annotated "xml pretty printing" with "fixed?" at http://hpaste.org/251#a1
18:26:35 <Cale> of course, that won't quite do if that's your main
18:26:52 <Cale> actually, you probably want the last line to be  putStrLn (PP.document doc)
18:26:58 <Cale> (if that's a string)
18:28:08 <Cale> Note that there's a difference between   foo <- bar  and  let foo = bar
18:28:48 <Cale> The first one will run the action bar in order to produce foo, the second defines foo as equal to bar (so if bar happened to be an action, foo would be the same action)
18:29:16 <chessguy> !paste
18:29:17 <hpaste> Haskell paste bin: http://hpaste.org/
18:29:31 <Z4rd0Z> Cale:  yes, it works
18:30:19 <hpaste>  chessguy pasted "problem with new haddock install" at http://hpaste.org/253
18:30:20 <Z4rd0Z> I see now that I was trying to bind the return value of xmlParse as an IO action
18:30:25 <Cale> right'
18:30:30 <chessguy> anyone know anything about this?
18:30:49 <sorear> ghc question: How do I define a GADT with a constructor with a nontrivial context using record syntax?
18:31:12 <sorear> chessguy: *ick* root!
18:31:23 <sorear> chessguy: I think you need to register first
18:31:29 <chessguy> ah
18:31:59 <chessguy> i forget, what's the command for that?
18:33:01 <sorear> oh wait no
18:34:00 <sorear> chessguy: haddock didn't fail.
18:34:00 <sorear> chessguy: Warning: has a very specific meaning, and it's not failure :)
18:34:00 <sorear> haddock always prints junk warnings, everyone takes a while to get used to it
18:34:00 <sorear> chessguy: check in dist/doc/*
18:34:35 <chessguy> oh, du
18:34:40 <chessguy> duh
18:34:52 <chessguy> that always screws me up. what's it complaining about though?
18:35:28 <sorear> chessguy: it's complaining about the fact the you are refing undefined symbols
18:35:37 <SamB> oh, those.
18:35:44 <sorear> they are defined in base, but haddock doesn't (yet) understand that.
18:35:54 <SamB> those are because it isn't very good at finding haddock interface files...
18:36:05 <SamB> (well, also they might not exist)
18:41:39 <sorear> How do I define a custom wrapper in alex?
18:42:24 <SamB> you stick it at the bottom of the file or import it at the top
18:42:36 <SamB> (cribbing code from an existing one, likely)
18:42:57 <sorear> so I can't make %wrapper "yi" work :(
18:43:05 <SamB> @where hSelf2
18:43:05 <lambdabot> http://naesten.dyndns.org:8080/repos/hSelf2/
18:43:20 <SamB> see Lexer.x
18:44:54 <SamB> (also ParseMonad.hs)
18:45:13 <SamB> anyway, that is how *I* did it the last time I did it
18:45:24 <sorear> SamB: I'm gonna have lots of lexers.
18:45:34 <SamB> sorear: so stick the wrapper in a file
18:45:38 <sorear> is there anything better than #include ?
18:45:42 <SamB> and say "import FooWrapper"
18:45:44 <SamB> at the top
18:45:53 <SamB> of every lexer
18:45:57 <sorear> SamB: import only works one way
18:46:03 <SamB> oh.
18:46:20 <sorear> SamB: the wrapper can't call alexScan, and the lexer can't export highlighter
18:46:38 <SamB> point
18:46:41 <sorear> or do you mean just factoring out most of the boilerplate and keeping:
18:46:59 <sorear> { highlighter = yiAlexHighlighter alexScan }
18:47:25 <sorear> hm. how will the wrapper access AlexResult et alia?
18:48:52 <SamB> I guess you could put most of it in a module and just make an include file to hold the rest?
18:49:40 * sorear gets a clothespin...
18:51:49 <SamB> yeah, that is a good place to put your nose
18:56:55 <chessguy> dcoutts, your half hour is up
18:57:08 <dcoutts> chessguy, I found a problem on win32
18:57:21 <dcoutts> but I've fixed it
18:57:21 <chessguy> no excuses!
18:57:36 <dcoutts> I might release without re-testing...
18:57:43 <dcoutts> I reckon it works :-)
18:58:01 <sorear> hey, if it breaks, more power to the console users
18:58:02 <sorear> :)
18:59:42 <dcoutts> hmm, the fix isn't good enough
18:59:52 <dcoutts> sorry folks, no release this evening
19:00:24 <chessguy> even for linuxers?
19:00:47 <dcoutts> linking 2678 .o files seems to overflow the command line length :-)
19:01:05 <dcoutts> I need to do something with a linker script or xargs
19:01:12 <dcoutts> but not now, now sleep
19:01:15 <dcoutts> g'night
19:01:24 <sorear> night
19:04:38 <glguy> !paste
19:04:39 <lambdabot> glguy: You have 3 new messages. '/msg lambdabot @messages' to read them.
19:04:39 <hpaste> Haskell paste bin: http://hpaste.org/
19:05:51 <glguy> sorear: unid'd?
19:06:01 <sorear> unidentified, sorry
19:06:11 <glguy> oh
19:06:29 <sorear> what do you think of my proposal?
19:06:43 <hyrax42> :t evalState
19:06:45 <lambdabot> forall a s. State s a -> s -> a
19:06:49 <orbitz> can i pattern match on an function parameter and bind it to a variabel too?  in erlang i'd do foo({a, b, c} = Foo)  then I can use Foo as wel las a, b, c
19:06:58 <glguy> sorear: you just want to verify that stuff compiles, for example?
19:07:20 <sorear> glguy: that, and so people don't have to paste the errors
19:07:27 <sorear> but drhaskell is important too :)
19:07:55 <sorear> orbitz: you mean like: foo rec@Record{ x = a, y = b} = {- use a b and rec -}
19:08:11 <orbitz> sorear: i think so, but can i do that with any thing?
19:08:11 <sorear> orbitz: it's called an "as pattern"
19:08:16 <sorear> orbitz: yes.
19:08:30 <glguy> I don't really know how to approach that in HAppS yet, but I'll investigate... I'd also need to talk to sorear about the resource usage
19:08:38 <orbitz> so i could do... foo l@(x:xs) = ...
19:08:42 <sorear> orbitz: yes,
19:08:46 <orbitz> thank you sorear
19:08:47 <sorear> s/,/./
19:08:47 <glguy> beelsebob: feel free to /msg me your bug report or to email me it
19:09:04 <sorear> glguy: what do I care? did you mean "talk to shapr about" ?
19:10:33 <ddarius> :listcommands
19:11:25 <sorear> ddarius: you mean: @list-all?
19:12:06 <ddarius> probably, it either has changed or I just forgot.  Probably a little of both.
19:12:16 <sorear> @listcommands
19:12:16 <lambdabot> Unknown command, try @list
19:12:21 <sorear> @list
19:12:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:12:48 <sorear>  @list-all is very noisy, so dons put the output online and added a link command :)
19:13:02 <sorear> ddarius: how far back do you go with #haskell?
19:13:35 <sorear> it was never '^:' in my memory, and I'm senior enough to be a bot admin
19:14:07 <ddarius> There was a high of 45 people when I joined.  Incidentally, I'm one of the original developers of lambdabot.
19:14:29 <ddarius> I'm probably still in the admin file...
19:14:31 <sorear> ooh
19:14:34 <sorear> cool...
19:14:56 <sorear> ddarius: AUTHORS lists you as:
19:15:03 <ddarius> I thought at one point it was changed to take both @ and :
19:15:03 <sorear> Derek Elkins <ddarius@users.sourceforge.net> aka Darius on #haskell
19:15:13 <sorear> ddarius: it takes both @ and ?
19:15:25 <sorear> should I submit a patch for your new nick?
19:15:26 <allbery_b> : is only used for ghci-ish :t and :k.  @ and ? are command chars
19:15:27 <ddarius> Yeah, I usually used Darius, but I think Darius Bacon registered it.
19:15:42 <ddarius> I gathered.
19:15:49 <ddarius> ddarius was my usual alternate nick.
19:16:36 <sorear> confirming it should be changed in AUTHORS?
19:17:06 <ddarius> @seen shapr
19:17:06 <lambdabot> shapr is in #happs and #haskell. I last heard shapr speak 5h 35m 52s ago.
19:17:18 <ddarius> sorear: no
19:17:21 <sorear> dons is the primary maint now
19:18:06 <ddarius> Yeah, I think that happened before I took a very extended break from #haskell; that or I heard about it on the mailinglist or something.
19:19:27 <sorear> it is a very exciting time for lambdabot; communications have been refactored into plugins, and an XMPP plugin is Coming Soon
19:19:31 <sorear> @help irc-connect
19:19:31 <lambdabot> irc-connect tag host portnum nickname userinfo.  connect to an irc server
19:19:33 <ddarius> @seen Pseudonym
19:19:34 <lambdabot> Pseudonym is in #haskell-blah and #haskell. I last heard Pseudonym speak 3h 52m 47s ago.
19:20:19 <glguy> sorear: yeah, I meant shapr, tab-complete makes me laz
19:20:20 <glguy> y
19:20:39 <ddarius> @seen Philippa
19:20:40 <lambdabot> Philippa is in #scannedinavian, #oasis, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 1h 49m 33s ago.
19:20:41 <sorear> sh, not s :)
19:21:54 <glguy> Colloquy supports tab-completion on arbitrary words :)
19:21:55 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
19:21:57 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
19:22:09 <dons> Just so you know we can do it (but note the space leak, gotta fix that)
19:22:16 <dmead> on the moon
19:22:19 <dmead> haskell writes itself
19:22:31 <dons> sjanssen: check it out ^^
19:22:51 <Adamant> in Soviet Russia, Haskell type-checks you!
19:23:01 <dmead> on the moon
19:23:12 <dmead> our weekends are so advanced, they encompass the entireeeee week
19:23:27 <Adamant> dmead, what were you doing in Boston today?
19:23:30 <Adamant> you mad bomber
19:23:31 <dmead> haha
19:23:45 <Adamant> what bombs at midnight
19:23:50 <dmead> i can't stop laughing when i read/watch that stuff
19:23:54 <Adamant> oh wait, wrong geek favorite.
19:23:59 <bd_> dons: ooh, haskell beat C there? nice :)
19:23:59 <Adamant> yes, it is hilarious
19:24:00 <dmead> it's so funny on so many levels
19:24:13 <Adamant> don't these people watch Adult Swim?
19:24:13 * allbery_b notes that there turns out to be a reason for the paranoia
19:24:19 <SamB> @quote moon
19:24:20 <lambdabot> No quotes match. My pet ferret can type better than you!
19:24:24 <dons> bd_ haskell beats everything there :) but its illegal
19:24:25 <SamB> allbery_b: hmm?
19:24:32 <allbery_b> apparently there was a *real* bomb planted at Tufts while this was going on
19:24:36 <bd_> dons: yeah, O(n) memory?
19:24:37 <dmead> guess not!
19:24:38 <Adamant> ah
19:24:47 <Adamant> so it's not all crazy paranoia.
19:24:48 <dons> bd_ right, that's a bug I made. oops
19:24:50 <dmead> really?
19:24:51 <dmead> hmm
19:24:51 <allbery_b> yeh
19:24:52 <dons> gotta fix that now
19:24:53 <SamB> allbery_b: did it have alien leds put on it?
19:24:57 <allbery_b> nope
19:25:11 <dmead> plutonians suck!
19:25:22 <newsham> ?google bush mooninites
19:25:22 <SamB> they aren't going through with this silly trial are they?
19:25:24 <lambdabot> http://www.plastic.com/article.html;sid=05/11/28/13295177;mode=nested
19:25:25 <lambdabot> Title: Plastic: Bush Preemptively Strikes Moon After Mooninite Declaration Of Superiori ...
19:25:25 <sorear> dons: you need to submit a better 'Haskell GHC' (ie the one liner)
19:25:34 <dmead> LOL
19:25:47 <dmead> yea it'll probably get thrown out
19:26:20 <SamB> I suppose the judge can do that easily: "I wouldn't have thought it was dangerous"
19:26:24 <dmead> but the prosecutors and the cops can't admit their wrong and are gonna need the judge to do it for em
19:26:38 <dmead> yea i saw footage of their arraignment
19:26:46 <dmead> the charges dont' fit the situation at all
19:26:56 <dmead> but it's entertaining until they get dropped
19:27:05 <SamB> I saw pictures of the thingies
19:27:10 <SamB> they don't look dangerous
19:27:11 <newsham> the best coverage i've seen of the incident is: http://youtube.com/watch?v=4G-D0F4Q9yk
19:27:23 <SamB> someone said something about that guy being scary, but I don't watch that show...
19:27:34 <dmead> it's really funny
19:27:46 <allbery_b> yeh, it all looks ridiculous --- but if they also had to deal with a real bomb, it's somewhat more understandable
19:27:46 <dmead> the entire show is improvsation
19:27:58 <dmead> when the voice actors do their stuff
19:28:03 <dmead> the writters give them some parameters
19:28:07 <dmead> and they just go off
19:28:12 <dmead> and then the cartoon gets written
19:28:19 <dmead> *drawn
19:28:34 <dmead> yea i suppose
19:28:43 <SamB> whoa
19:28:45 <dmead> but it was clearly a cartoon on the things
19:28:45 <SamB> cool
19:29:08 <dmead> yea
19:29:14 <dmead> it gets real trippy and funny
19:29:31 <SamB> I guess the policefolk weren't fans?
19:29:43 <newsham> it was scary.  it had batteries and wires.
19:29:49 <newsham> all the parts of an IED.
19:29:58 <newsham> (except you know.. explosives or somewhere to put explosives)
19:30:08 <dmead> rofl yea
19:30:12 <newsham> also depending on your font  IED looks like lED
19:30:16 <dmead> and IEDs don't usually have cartoons flipping the bird
19:30:20 <dmead> hehe
19:30:30 <newsham> dmead: depends on if the terrorists are into adult swim i suppose
19:30:34 <dmead> on cnn, they actually blurred out the cartoon middle finger
19:30:39 <dmead> it was lol
19:31:29 <newsham> if the only thing we have to fear is fear itself then i guess we should be afraid of emergency response units, politicians and the mass media.
19:31:43 <dmead> true that
19:31:45 <sorear> must @remember that.
19:32:09 <SamB> the mass media -- they didn't portray this stuff as scary did they?
19:32:15 <sorear> @remember newsham if the only thing we have to fear is fear itself then i guess we should be afraid of emergency response units, politicians and the mass media.
19:32:15 <sorear>  
19:32:15 <lambdabot> Done.
19:32:30 <newsham> samb: they at the very least called it a "hoax device"
19:32:44 <dibblego> what are you talking about?
19:32:52 <sorear> dibblego: boston.
19:33:01 <dmead> @remember dmead Here on the moon, our weekends are so advanced they encompass the entire week
19:33:02 <lambdabot> Done.
19:33:02 <newsham> see /last youtube
19:33:08 <SamB> how could it be a hoax?
19:33:22 <dmead> it cant
19:33:26 <sorear> dibblego: unless you live in a cave, you must've at least smelled the hysteria.
19:33:29 <dmead> it makes no sense for it to be a hoax
19:33:40 <dibblego> sorear, I don't watch the media
19:33:40 <SamB> maybe if they were supposed to be markers for an alien invasion ;-)
19:33:54 <dmead> :P
19:33:55 <SamB> dibblego: not the IRC either then?
19:34:01 <newsham> fox news suggested that the creators called 911 after not seeing any reaction to them.
19:34:03 <dibblego> yes, that's why I asked
19:34:06 <sorear> dibblego: neither do I. but it made the exposed surface of the newspapers.
19:34:07 <dmead> dibblego: read up
19:34:17 <SamB> newsham: what a strange thing to suggest
19:34:21 <SamB> that would be idiotic
19:34:29 <dmead> yea
19:34:32 <dibblego> sorear, there is a police strike/stink on here locally - that is on the front lately
19:34:42 <dmead> there were many more people involved in planting these signs
19:34:49 <newsham> well it had already been established that the earlier reports were by known sources (for examle, one of the subway operators)
19:34:54 <dmead> apparently there were some in my city (philadelphia)
19:35:00 <sorear> dibblego: oh. I guess some places have more real news than SanD? :)
19:35:02 <newsham> but thats not how you run a "news" show
19:35:04 <dmead> i should go pillage a few :o
19:35:13 <newsham> dmead: they're selling for $2k or so on ebay
19:35:17 <newsham> grab one if you can
19:35:29 <dmead> oh man
19:35:36 <dmead> =)
19:35:37 <SamB> how much are plans?
19:35:46 <newsham> i havent heard of plans yet
19:35:53 <newsham> there are tshirts though :)
19:36:00 <dibblego> sorear, a police officer murdered a native, no charges laid initially, protest, then changed their mind; now the police are upset because it's all political and a fellow officer is being charged to satsify the wants of the protesters
19:37:10 <dmead> @remember dmead I DON'T NEED NO MANUAL FOR ROCKIN OUT!
19:37:11 <lambdabot> Done.
19:37:30 <newsham> http://www.makezine.com/blog/archive/2007/02/homemade_led_sh.html  http://www.makezine.com/blog/archive/2007/02/boston_moonimit.html
19:37:32 <lambdabot> Title: MAKE: Blog: Homemade LED shirt...
19:37:53 <newsham> 2nd url has some closeup pics of the pcb.  nice work
19:39:56 <dmead> hehe
19:41:59 <beelsebob> glguy: you still there?
19:42:07 <dibblego> so these bombs were not a hoax?
19:42:41 <chessguy> dons++ nice tutorial on writing a haskell program
19:43:19 <araujo> hello
19:43:37 <chessguy> araujo, :)
19:43:43 <beelsebob> lo
19:43:44 <araujo> chessguy!
19:43:56 * araujo pulls chessguy into #haskell.es
19:44:11 <allbery_b> ah.  *two* "bombs" --- both fake but very realistic pipe bombs.
19:44:20 <allbery_b> nothing like that to feed paranoia
19:44:35 <xpika__> does anyone here use continuations to implement there iterators?
19:44:51 <beelsebob> xpika__: depends on the situation, but yes
19:44:52 <dibblego> xpika__, you mean like List.iterate?
19:44:56 <sorear> I use Cont - does that count?
19:45:02 <xpika__> yep
19:45:12 <xpika__> thats what im using atm
19:45:28 <dmead> dibblego: they were LED boards showing some cartoon characters
19:45:44 <dibblego> dmead, so what's all the fuss about exactly?
19:45:47 <newsham> dibble: no. they werent bombs and they werent supposed to look like bombs and they dont look like bombs
19:45:50 <dmead> that the cops over reacted
19:45:51 <newsham> hence no hoax.
19:45:58 <dibblego> oh right
19:46:06 <dibblego> did anyone even say they were bombs?
19:46:10 <dmead> nope
19:46:20 <dmead> the guys they arressted were cracking up in court
19:46:24 <dmead> it's funny shit
19:46:30 <dibblego> so someone put some funny lights on the street and are arrested for bomb hoaxes?
19:46:35 <dmead> yes
19:46:41 <dibblego> oh, that's fucking funny
19:46:44 <dmead> yes
19:46:45 <dmead> it is
19:46:58 <newsham> http://www.flickr.com/photos/84221353@N00/377039406/in/pool-make/
19:47:00 <lambdabot> Title: Makin' things with light on Flickr - Photo Sharing!
19:47:02 <chessguy> hey, let's keep the language clean
19:47:15 <sorear> no, let's keep it Haskell.
19:47:28 <sorear> Clean is over in room 37D
19:47:30 <dibblego> I don't subscribe to the notion of a distinction
19:47:30 <chessguy> i knew someone was going to make a stupid joke about that
19:47:42 <dmead> heres a good link with video
19:47:42 <dmead> http://www.reason.com/blog/show/118466.html
19:47:44 <lambdabot> Title: Reason Magazine - Hit & Run > "What we really want to talk about today -- it's k ...
19:47:46 <chessguy> i said clean, not Clean
19:47:58 <araujo> hah
19:48:09 <dmead> lawl
19:48:33 <emu> stay in the Haskell monad
19:48:38 <glguy> beelsebob: yes
19:48:49 <dmead> the channel is doing an unsafeio =/
19:50:21 <hyrax42> what is the source of spaceleak in that shootout submission?
19:50:22 * sorear > homework
19:52:46 --- mode: irc.freenode.net set +o ChanServ
19:53:34 <dibblego> what a pair of champions
19:54:50 <dons> hyrax42: it reads a strict bytestring in
19:55:02 <hyrax42> oh
19:55:03 <dons> thus it is illegal, it reads the entire file contents before parsing
19:55:13 <dons> but just goes to show you how zippy bytestrinsg are, eh!
19:55:17 * dons was very surprised
19:55:21 <hyrax42> for reference, how does the "naive" fps version go
19:55:33 <dons> anyway, i've just submitted an amended version that uses lazy bytestrings instead
19:55:41 <dons> should be a bit slower, but i suspect very competitive
19:55:55 <dons> hyrax42: there's a 2 liner that runs about twice as slow
19:55:55 <hyrax42> sum . map read . B.lines
19:56:03 <dons> yeah, map readInt
19:56:13 <dons> here, i've got numbers...
19:56:42 <hyrax42> ah, I was wondering if thre was a way to get around read being polymorphic
19:56:50 <hyrax42> twice as slow still is top no?
19:57:02 <chessguy> dons, if you're ever wanting to bench anything on a 64-bit architecture, my computer's itching to try it
19:57:11 <dons> so, strict bytestrings:
19:57:12 <dons> $ time ./D < input
19:57:12 <dons> 1344000
19:57:12 <dons> ./D < input  0.17s user 0.08s system 72% cpu 0.345 total
19:57:20 <dons> lazy bytestrings,
19:57:23 <dons> $ time ./E < input
19:57:23 <dons> 1344000
19:57:23 <dons> ./E < input  0.51s user 0.03s system 97% cpu 0.550 total
19:57:27 <dons> naive, lazy bytestrings:
19:57:35 <dons> $ time ./C < input
19:57:36 <dons> 1344000
19:57:36 <dons> ./C < input  0.80s user 0.03s system 98% cpu 0.839 total
19:57:55 * hyrax42 thinks dons's computer is somewhat faster than the shootout's one
19:57:56 <dons> note that apparently the strict bytestrings run like some alien technology
19:58:22 <dons> the lazy bytestring entry outperforms the strict one after 20-30M input though
19:59:00 <hyrax42> oh so that would be even quicker if you uploaded it to shootout?
19:59:06 <dons> ok, the lazy entry has been accepted. it should appear on the site soon
19:59:11 <Adamant> has anyone added a hint mode for ghc with all the new optimizations?
19:59:17 <dons> well, it'll be quicker if the size goes up in the future
19:59:21 <dons> may even be quicker now, hard to say
19:59:30 <Adamant> like, "use Bytestring instread of String", etc.?
20:00:52 <dons> hmm. hard to do that
20:02:31 <bd_> Any way to make GHC magically turn String into ByteString? :)
20:03:20 <chessguy> magic :: String -> ByteString? :)
20:03:25 <bd_> heh
20:03:33 <bd_> I was thinking more some really clever RULES abuse >.>
20:03:56 <bd_> getting the bottom semantics right would be tricky though...
20:04:35 <hyrax42> what makes this
20:04:37 <hyrax42> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=2
20:04:39 <lambdabot> Title: sum-file Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2pxuqt
20:04:41 <hyrax42> so pathetic?
20:05:37 <dons> hyrax42: looks like a space leak
20:05:43 <glguy> @losers
20:05:44 <lambdabot> Maximum users seen in #haskell: 322, currently: 270 (83.9%), active: 32 (11.9%)
20:05:51 <bd_> hyrax42: O(n) space usage
20:05:52 <dons> ah, and not strict enough to unbox the bytestring
20:06:05 <hyrax42> also how many haskell GHC's are there... can some of them get removed?
20:06:59 <dons> hyrax42: yes, that is about to happen
20:07:30 <hyrax42> ok
20:07:33 * hyrax42 stops asking questions
20:07:56 <rc-1> http://scienceblogs.com/goodmath/goodmath/programming/haskell/
20:07:57 <lambdabot> Title: Good Math, Bad Math
20:07:58 <dons> but, hey, how cool is ghc 6.6!
20:08:09 <hyrax42> dons: I don't know :(
20:08:13 <hyrax42> haven't upgraded yet
20:08:15 <rc-1> some very cool intro to haskell lecutres
20:08:30 <rc-1> (learning from them ATM :) )
20:08:40 <monomorph> ghc-6.6 is very cool
20:09:20 <chessguy> http://scienceblogs.com/goodmath/2007/01/haskell_a_first_step_into_mona_1.php
20:09:22 <lambdabot> Title: Good Math, Bad Math : Haskell: A First Step Into Monads, http://tinyurl.com/2bdder
20:09:22 <monomorph> You can safely remove GHC 3 and earlier :)
20:09:27 <chessguy> yay, another monad tutorial!
20:09:39 <dons> monomorph: heh
20:09:56 <monomorph> First step into Mona! Mona Lisa! Buene Bella!
20:10:22 <rc-1> chessguy, i just linked to goodmath
20:11:00 <chessguy> yeah, i was just pointing out the monad tutorial
20:11:12 <rc-1> chessguy, also im writing a chess/go variants server/client right now :)
20:11:35 * gravity wishes he was at the point where he could take advantage of a new ghc
20:11:37 <chessguy> oh? in haskell?
20:12:20 <hyrax42> does anyone here own Okasaki's purely funcitonal data structures?
20:12:34 <dibblego> hyrax42, yes
20:12:39 <dibblego> hyrax42, right next to me
20:12:56 <hyrax42> dibblego: worth owning?
20:13:02 <hyrax42> bearing in mind that I have his thesis on my comp
20:13:08 <hyrax42> thesis/dissertation
20:13:09 <rc-1> chessguy, i didnt know about haskell yet when i started :( so no its in java
20:13:10 <dibblego> hyrax42, yes, but all the code examples are in ML (there is Haskell in an appendix)
20:13:16 <hyrax42> don't remember which
20:13:27 <chessguy> ewwww
20:13:29 <chessguy> java--
20:13:41 <dibblego> he also introduces with the usual strict versus laziness mistake/debate
20:13:51 <dibblego> which turned me off a bit, but otherwise, it's a good read
20:13:57 <hyrax42> mistake/debate?
20:13:59 <rc-1> yeah i know, but i have so much done, it would be a shame to have to start over
20:14:06 <dibblego> you know the one?
20:14:19 <chessguy> rc-1, what's your goal in writing it?
20:14:45 <hyrax42> dibblego: maybe :?
20:15:04 <rc-1> chessguy, its to be a game server thats GPL and easy to add games to, and a graphical client for it
20:15:12 <dibblego> hyrax42, many ML zealots believe that you should create lazy structures from eager ones
20:15:16 <hyrax42> dibblego: it says on amazon "all source code is given in sml and haskell"... does that mean that all examples are given in haskell, or that no examples are given in any other language?
20:15:28 <rc-1> so far i have 18 chess variants, will add go soon, then add rating system, and add API for adding other games
20:15:29 <chessguy> rc-1, the users can add games?
20:15:34 <dibblego> hyrax42, the book is ML throughout, with an appendix containing the Haskell equivalent
20:15:41 <hyrax42> dibblego: ok
20:15:42 <rc-1> chessguy, not yet, but they will be able to
20:15:58 <hyrax42> dibblego: not terribly familiar with the argument, but I can imagine one exists
20:16:07 <chessguy> rc-1, are you planning on selling memberships?
20:16:18 <dibblego> hyrax42, Introduction 1.2 Strict vs Lazy Evaluation (made me roll my eyes)
20:16:24 <rc-1> chessguy, nope someone donated a free 100MBPS 4 processor server for it,
20:16:28 <hyrax42> hm
20:16:39 <chessguy> rc-1, whoah
20:16:41 <rc-1> so im going to let people use for free :)
20:16:53 <chessguy> nice
20:17:06 <hyrax42> dibblego: is it any different from his dissertation?
20:17:15 <dibblego> "Which is superior is a topic debated with sometimes religious ferver by functional programmers"
20:17:18 <dibblego> hyrax42, I haven't read that
20:17:28 <chessguy> do you have the client/server protocol finished already?
20:17:41 <rc-1> i have a CVS if you want to look at it; but dont try and test it right now i just rewrote some server code and havnt gotten chance to debug it yet
20:17:53 <hyrax42> dibblego: a quick random verification
20:17:58 <dibblego> hyrax42, link?
20:18:13 <hyrax42> section 1.2 is strict vs. lazy, 3.3.1 the role of lazy evaluation
20:18:17 <hyrax42> oh that would make more sense, wouldn't it
20:18:31 <rc-1> chessguy, i had a totally working model, but it was going to be too slow so i rewrote it as a priority queue
20:18:52 <rc-1> i had never done any server programming before, so i nievely had 1 thread per player lol
20:18:57 <chessguy> mmmm, i'm talking about the protocol itself
20:19:00 <dibblego> I cannot find a section 3.3.1
20:19:03 <dibblego> only 3.3 and 3.4
20:19:05 <rc-1> chessguy, yup i do
20:19:06 <chessguy> like what the client and server communicate back and forth
20:19:21 <hyrax42> dibblego: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
20:19:41 <chessguy> i'd be interested in seeing that. i've done some client/server game programming
20:20:18 <dibblego> hyrax42, definitely looks similar
20:21:11 <rc-1> chessguy, ah cool maybe you could help me get the new datainputstream thing working again; it worked perfectly before and could play all the two player games, do seeks, and stuff
20:21:16 <hyrax42> dibblego: I may get the book anyway
20:21:20 <dibblego> hyrax42, the book looks the same, except with about double as much content
20:21:29 <rc-1> only rewrote cause stack would get too heavy later with all those threads 1/player
20:21:34 <hyrax42> I am thinking of getting hutton and okasaki on my next amazon order
20:21:47 <dibblego> some of the chapters in the thesis contents are direct copies to the book, but the book contains (quite a lot) things not in the thesis
20:22:02 <rc-1> ChanServ, http://figs.cvs.sourceforge.net/figs/FIGS/
20:22:03 <lambdabot> Title: SourceForge.net Repository - [figs] Index of /FIGS
20:22:04 <chessguy> actually, my experience is more on the client side
20:22:06 <hyrax42> dibblego: ok, thanks
20:22:22 <rc-1> chessguy, the client already works fine
20:22:45 * sorear < #haskell
20:22:49 <sorear> err
20:22:54 * sorear < homework
20:23:23 <hyrax42> sorear: successful?
20:24:02 <rc-1> chessguy, the channel for it is #FIGS btw :)
20:25:08 <sorear> hyrax42: I think so
20:25:09 <sorear> (?)
20:25:56 <hyrax42> just seemed a short homework excursion
20:26:01 <hyrax42> so either going well or poorly
20:26:04 <hyrax42> in my experience, anyway
20:27:36 <sorear> not sure yet, I kinda forgot the details-of-assignment :)  but, semester is 4 days young, plenty of time to fix an A-
20:28:23 <emu> entering 4th week of semester already, here
20:29:43 <hyrax42> we're 4 1/2 weeks in
20:29:54 <hyrax42> well
20:30:00 <hyrax42> 4 full weeks yesterday I guess
20:30:13 <hyrax42> I get ahead of myself around this time of the week and imagine it's all done
20:30:30 <emu> it's never done
20:31:20 <SamB> I've a test tomorrow
20:31:25 <SamB> in physics
20:31:46 <hyrax42> what year are you?
20:31:46 <SamB> shouldn't be any trouble though
20:31:52 <SamB> I'm confused about that
20:32:00 <sorear> hyrax42: hs junior
20:32:19 * SamB has a test in University Physics II
20:32:22 <hyrax42> yikes really
20:32:29 * hyrax42 feels old
20:32:36 <SamB> hyrax42: how old are you?
20:32:39 <emu> man, when did high schools start having such few hours and days
20:32:52 <hyrax42> 23 ...?
20:32:53 <hyrax42> yeah
20:32:56 <emu> schools around here i see kids getting into the buses at like 1:30pm
20:33:22 <SamB> emu: smart!
20:33:31 <SamB> my sister doesn't get home till 3
20:33:42 <emu> 3 was "normal" in my day
20:33:44 <sorear> I get home at 3
20:38:20 <sorear> dons: urps.  looks like I'll need to use undocumented alex_* symbols after all.  (they haven't been touched since June '06 however, so plenty of time to get a new interface)
20:39:14 <chessguy> anybody else thing return is really poorly named?
20:39:19 <chessguy> or is it just me?
20:39:34 <emu> i think its a bit misleading for imperative programmers coming to haskell
20:39:43 <emu> would you prefer "unit"?
20:39:44 <sorear> what is return called, categorically?
20:39:57 <dibblego> unit iirc
20:40:15 <chessguy> maybe 'wrap'
20:40:21 <chessguy> or something
20:40:22 <sorear> I take it unit is :: m () and return = unit . fmap . const
20:40:24 <sorear> ?
20:40:38 <sorear> er, flip fmap unit . const
20:40:42 <hyrax42> unit is just return
20:40:43 <emu> no, return = unit
20:40:45 <hyrax42> well mu
20:40:50 <hyrax42> in some contexts
20:40:55 <hyrax42> oops
20:40:57 <hyrax42> mu is join
20:40:58 <hyrax42> eta is return
20:41:01 <emu> yea, we should just switch to latex-input like Fortress and call it eta
20:41:36 <sorear> just needs to be more APL-y
20:41:52 <emu> Fortress hides its monads, very shameful
20:42:21 <mbishop> I think hiding monads would be a good idea actually
20:42:37 <emu> well, as in, you can't make your own
20:42:59 <mbishop> oh, well that's silly
20:43:03 <Adamant> are monads the next Lisp macros?
20:43:07 <mauke> crouching side effect, hidden monad
20:43:13 <Adamant> banned because Java programmers can't handle them?
20:43:13 <emu> they both begin with "m"
20:43:35 <gravity> ghc doesn't spit out nearly as helpful error messages when using the do notation as when explicitly binding things
20:43:36 <Adamant> and yes, I went there.
20:44:18 <hyrax42> > minBound :: Char
20:44:19 <lambdabot>  '\NUL'
20:44:26 <hyrax42> > maxBound :: Char
20:44:27 <lambdabot>  '\1114111'
20:44:51 <hyrax42> ord maxBound - ord minBound
20:44:57 <hyrax42> > ord maxBound - ord minBound
20:44:58 <lambdabot>  1114111
20:45:11 <emu> > chr (ord (maxBound :: Char) + 1)
20:45:13 <jcreigh> oh, that's not octal?
20:45:17 <lambdabot>  Exception: Prelude.chr: bad argument
20:45:20 <jcreigh> > chr (ord 200)
20:45:21 <lambdabot>   add an instance declaration for (Num Char)
20:45:45 <jcreigh> > chr 200
20:45:49 <lambdabot>  '\200'
20:45:50 * jcreigh kicks himself
20:45:53 <emu> :t ord
20:45:55 <lambdabot> Char -> Int
20:46:10 <hyrax42> > showHex $ ord (maxBound :: Char)
20:46:12 <lambdabot>  <[Char] -> [Char]>
20:46:25 <hyrax42> > showHex $ ord (maxBound :: Char) $ []
20:46:26 <lambdabot>      Expecting a function type, but found `Int'
20:46:27 <lambdabot>       Expected type: a -> b
20:46:27 <lambdabot>  ...
20:46:28 <emu> > chr ((ord (maxBound :: Char)) + 1)
20:46:29 <lambdabot>  Exception: Prelude.chr: bad argument
20:46:49 <hyrax42> > (showHex $ ord (maxBound :: Char)) ""
20:46:51 <lambdabot>  "10ffff"
20:47:53 <jcreigh> :t showHex
20:47:55 <lambdabot> forall a. (Integral a) => a -> ShowS
20:50:23 <hyrax42> where type ShowS = String -> String
20:50:43 <hyrax42> allows constant time appending as function composition, I believe...
20:51:09 <sorear> == tree building
20:51:29 <sorear> viewed as raw PAp nodes in the heap, ShowS is equvalent to:
20:51:48 <sorear> data ShowS = Empty | Singleton ch | Pair ShowS ShowS
20:52:21 <sorear> showStoString Empty s = s ; showStoString (Singleton c) s = c:s ; showStoString (Pair a b) s = showStoString a (showStoString b s)
20:52:42 <sorear> which is obviously O(n) for conversion and O(1) for all building ops
20:52:59 <sorear> if that makes more sense
20:53:14 <hyrax42> enough anyway
20:53:20 <hyrax42> what is PAa?
20:53:23 <hyrax42> PAp?
20:53:31 <sorear> Partial APplication
20:53:33 <hyrax42> partial application?
20:53:42 <hyrax42> kk
20:53:47 <sorear> it's been a while since I read the Commentary, I might have the name wrong
20:53:56 * hyrax42 is ignorant of all implementation details
20:54:00 <hyrax42> which commentary
20:54:04 <sorear> the ghc one
21:01:36 <narain> is it dangerous if (+), (-) or (*) are not commutative in an instance of Num?
21:02:11 <narain> well, (*) specifically
21:02:13 <bd_> probably
21:02:28 <bd_> well, inasmuch as higher-level combinators might not behave as expected
21:02:35 <mauke> (-)?
21:02:41 <Korollary> It depends on how surprised your users will be.
21:02:54 <narain> im probably going to be my only user :)
21:03:10 <glguy> (-) is neither commutative nor associative
21:03:21 <narain> i was thinking of making a Matrix type an instance of Num
21:03:27 <narain> right, forget (-)
21:03:33 <Korollary> isn't matrix addition commutative?
21:03:44 <glguy> yeah
21:04:00 <glguy> ?src Num
21:04:00 <lambdabot> class  (Eq a, Show a) => Num a  where
21:04:00 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:04:00 <lambdabot>     negate, abs, signum     :: a -> a
21:04:00 <lambdabot>     fromInteger             :: Integer -> a
21:04:03 <narain> yes, i overgeneralized my original statement  :(
21:04:23 <narain> only (*) is noncommutative
21:04:37 <glguy> and (-)
21:05:10 <narain> glguy: only (*) is _unexpectedly_ noncommutative
21:05:43 <glguy> the issues with a Num instance for a Matrix are typically greater than (*)
21:05:56 <glguy> signum and fromInteger don't fit well either
21:06:12 <glguy> abs * signum won't work
21:06:39 <narain> ah
21:06:44 <narain> hadn't thought that far ahead
21:06:46 <Cale> fromInteger works fine
21:06:49 <chessguy> ?where ghc
21:06:49 <lambdabot> http://haskell.org/ghc
21:06:59 <Cale> signum would be a problem though
21:07:16 <Korollary> fromInteger works fine?
21:07:17 <mgsloan> I think half-life might be written in haskell, at least, they use the logo :P
21:07:27 <Cale> You'd want fromInteger to return that multiple of the identity matrix
21:07:48 <allbery_b> that's what I was thinking, fwiw
21:09:16 <narain> so forcing things into the Num class to get operators to work is a bad idea it seems
21:09:31 <Cale> In general, yeah
21:09:34 <glguy> <+> <*> <-> aren't bad operators either :)
21:09:40 <Cale> just invent a new operator name :)
21:09:54 <narain> glguy: that's not bad :)
21:10:14 <bd_>  (3:+)
21:10:24 <monomorph> <+> has a million different uses already :)
21:10:37 <glguy> .+. .-. .*. (might collide with Data.Bits)
21:10:41 <narain> :info <+>
21:10:51 <glguy> oops
21:10:53 <narain> :t <+>
21:10:55 <lambdabot> parse error on input `<+>'
21:10:56 <bd_> glguy: data.bits is .|. .&. I thought?
21:10:58 <glguy> or rather, no they don't
21:11:03 <glguy> bd_: right
21:13:02 <emu> list monad is a nice way to run an NFA
21:16:21 <monomorph> .+ .* is OCaml-like
21:16:37 <monomorph> You may like to consider them. :)
21:16:52 <monomorph> All great inspirations come from OCaml. :)
21:16:54 <allbery_b> also SML
21:17:15 <allbery_b> OCaml being just a strange mutation of it...
21:18:03 <rc-1> does haskell have a good networking library/are there any examples of servers built in it?
21:18:20 <bd_> rc-1: HAppS?
21:18:31 <sorear> @where hpaste
21:18:32 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
21:18:53 <allbery_b> the Network library can be used to write servers, certainly
21:19:01 <rc-1> thanks :)
21:19:06 <allbery_b> (also I've written a simple server but it's designed to run from inetd, not standalone)
21:19:30 <rc-1> wrote a chess server in java; thinking about changing the entire thing to haskell
21:19:40 <narain> monomorph: OCaml uses those for floating-point operations, right?
21:19:41 <allbery_b> doooooo it!
21:19:49 <rc-1> you guys think that rewriting it all is worth having it in a good language?
21:20:01 <Korollary> Why not write something else instead?
21:20:07 <monomorph> Yes
21:20:17 <allbery_b> yeh, the .x ops in ML are floating; it doesn't have typeclasses so can't overload e.g. +
21:20:39 <sorear> I thought it had C-style overloading?
21:20:45 <sorear> ie for primops only
21:20:50 <rc-1> Korollary, i really want to write a good game server that is open source and is easy to add new game types to
21:20:52 <narain> SML overloads +, * etc
21:20:56 <narain> OCaml doesn't
21:21:10 <nmessenger> how does OCaml do polymorphism?
21:21:13 <sjanssen> that's asinine
21:21:45 <rc-1> sjanssen, talking to me :?(
21:21:49 <monomorph> OCaml doesn't have typeclass and operator overloading.
21:21:52 <emu> parametrically
21:21:52 <Korollary> It's got ml functors
21:22:23 <emu> but actually, yea, the special case for the Eq typeclass in SML kinda pisses me off about it. and everything has a default Show, except ascripted types of course.
21:22:23 <sjanssen> rc-1: nah, I'm talking about the non overloaded ops on OCaml
21:22:53 <narain> arithmetic ops in SML are pretty much a special case
21:22:54 <rc-1> ah ok i agree with you then!
21:22:56 <mbishop> there is an extension for ocaml
21:23:03 <mbishop> Gcaml, it does overloading
21:23:16 <emu> writing a polymorphic type variable like ''a indicates that it should be an equality-class type
21:23:29 <narain> nothing else can be overloaded
21:23:47 <emu> but functors are really cool, if you can figure them out
21:23:59 <nmessenger> @google ocaml functors
21:24:03 <lambdabot> http://www.ps.uni-sb.de/~rossberg/SMLvsOcaml.html
21:24:03 <lambdabot> Title: SML vs. Ocaml
21:24:07 <emu> SML module system functors
21:24:13 <rc-1> narain, that was the point; special cases are bad in my opinion!
21:24:15 <sorear> do they have anything to do with haskell functors?
21:24:22 * nmessenger presumes not
21:24:23 <Korollary> No
21:24:34 <emu> they apply to SML modules, so no
21:24:41 <mauke> they're like C++ templates
21:24:47 <emu> i think of them as higher-order modules
21:25:00 <Korollary> They're categorical functors, too, though. Just over modules.
21:25:00 <narain> rc-1: i agree
21:25:09 <emu> it's quite neat, except for all the confusing parts which introduce weird constraint syntax using "where" and whatnot
21:25:38 <hpaste>  dryice pasted "help the newbie" at http://hpaste.org/254
21:25:48 <emu> which i've all forgotten since i haven't touched SML in 3 years
21:26:11 <sorear> should I learn ML?
21:26:15 <allbery_b> dryice: return (num + s)
21:26:17 <glguy> dryice: you have to tell us what you want
21:26:21 <glguy> ah
21:26:29 <emu> its not hard
21:26:43 <Korollary> I didnt like it much
21:26:45 <dryice> glguy: ok - after that I get  Couldn't match expected type `[a]' against inferred type `IO ()'
21:26:50 <hpaste>  allbery_b annotated "help the newbie" with "parentheses.  application binds tight!" at http://hpaste.org/254#a1
21:26:54 <emu> SML could be a very nice language, it just has these ... inflexibilities ... which make it too onerous
21:27:17 <hpaste>  dryice pasted "help the newbie 2" at http://hpaste.org/255
21:27:24 <emu> i'd use it over Java any day
21:27:30 <sorear> rephrasing: as a haskell guru, would I learn anything from ML?
21:27:36 <glguy> dryice: you can use the annotation link to add pastes to the existing one
21:27:46 <allbery_b> and now you need to include an error message or something
21:27:48 <Korollary> I'd use it over java/c++ as well
21:28:14 <emu> i think the module functors are worht learning
21:28:19 <Korollary> Yes
21:28:21 <magnus--_> SML/ocaml are both very nice to work in imo
21:28:22 <allbery_b> Ijust grabbed at the obvious error, didn't try to run it or etc. (dealing with pastes is a little complex with this strange setup)
21:28:30 <dmead> yea
21:28:41 <dmead> in ML you can change from functional to imperative style anytime
21:28:45 <hpaste>  dryice annotated "help the newbie 2" with "error" at http://hpaste.org/255#a1
21:28:47 <mbishop> sml/ocaml are indeed pretty nice
21:28:57 <emu> dmead: i dont consider that an advantage
21:29:02 <mbishop> no messing with IO monad silliness :/
21:29:12 <sorear> dryice: that's not an error in the code you pasted!
21:29:17 <magnus--_> sorear: The module system is different and interesting
21:29:23 <sorear> dryice: it's an error in other (someone elses?) code
21:29:23 <mauke> dryice: that has nothing to do with doSumming
21:29:28 <allbery_b> ...but it's the same problem
21:29:28 <dmead> monds are indeed interesting
21:29:40 <dmead> but i'm not clear why it's more useful
21:29:42 <emu> Standard ML also has a full formally specified denotational semantics, if can stomach to read it
21:29:45 <hpaste>  glguy annotated "help the newbie 2" with "fixed" at http://hpaste.org/255#a2
21:30:08 <allbery_b> see error message:  (putStr "sum=") ++ (show s) --- this is telling you you forgot parentheses, because it's applying ++ to the wrong thing
21:30:21 <allbery_b> er, ptStrLn
21:30:22 <hpaste>  dryice annotated "help the newbie 2" with "full source that returns error above" at http://hpaste.org/255#a3
21:30:23 <narain> apart from the module system though, i doubt a Haskell guru would find anything new in SML
21:30:34 <glguy> dryice: I already pasted the correction above
21:30:55 <glguy> dryice: function application happens before operator applicatio
21:30:56 <glguy> n
21:31:00 <dryice> ok thanks guys
21:31:17 <dryice> i'll had another one - i'll be back soon after i can reproduce it
21:31:32 <narain> i don't know much about OCaml though
21:31:33 <allbery_b> Haskell's precedence rules do take some getting used to; just remember that function application binds more tightly than anything else, so any time you want to pass an expression as a single argument to some function you must parenthesize t
21:31:39 <mbishop> I find the use of IO in haskell indeed "awkward", and it's annoying since you need to use it so much
21:31:39 <narain> maybe the OO system is interesting?
21:32:04 <Korollary> I doubt it. Iirc nobody writes oo code much in ocaml
21:32:31 <allbery_b> (this is a consequence of it being bothpossible and very useful to pass functions and operators as arguments)
21:33:30 <narain> I wonder why OCaml seems more popular than SML though?
21:33:48 <Korollary> newer
21:34:39 <narain> That's it?
21:35:00 * allbery_b thinks OCaml had better marketing
21:35:08 <siti> the one thing that fustrates me in haskell is there is no sensible way to have, say 2 rendering modules and you want to dynamically choose them
21:35:22 <Korollary> siti: hsplugins?
21:35:28 <siti> I'll have a look ;)
21:35:32 <monomorph> That's an overkill.
21:35:46 * allbery_b was thinking maybe generics, but imagines that would get ugly fast
21:35:51 <siti> kolmodin: link?
21:35:56 <allbery_b> or Dynamic
21:35:58 <mauke> @where hsplugins
21:35:59 <lambdabot> I know nothing about hsplugins.
21:36:03 <mauke> @where hs-plugins
21:36:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
21:36:04 <siti> @dumbot
21:36:05 <allbery_b> is what I actualy meant
21:36:05 <lambdabot> Unknown command, try @list
21:36:08 <siti> ok
21:36:20 * allbery_b thinks he's too tired and fuzzzy to think straight tonight, grah
21:36:28 <mbishop> ocaml has a very solid base, with the INRIA doing all the standards and most of the libraries and stuff
21:36:38 <Korollary> yes, better libs
21:36:39 <allbery_b> @botsnack
21:36:40 <lambdabot> :)
21:36:40 <siti> wow both things I have complained about are answered in about 10 seconds in this channel :)
21:36:47 <Korollary> seems to perform better than mlton, too.
21:36:56 <siti> and it seems both have a fix :)
21:36:58 <sorear> siti: we pride ourselves on that.
21:37:00 <mbishop> and it doesn't need 5 different compilers for interaction and optimization and such, since the standard compiler for ocaml is nice
21:38:23 <mbishop> I like the idea of pure functional programming, but honestly, I can't get used to it, just too awkward
21:38:24 <allbery_b> funny thing... I looked over SML 9don't recall much of it --- studied only to the point of being able to mostly comprehend the occasional chunk of SML jhutz would toss at me), but thought it was a bit asinine with things like let rec.
21:38:42 <allbery_b> looked over ocaml later, hit something fairly quickly (that I don't now recall) that looked even more asinine, dropped it
21:38:46 <mbishop> Wonder if it would be possible for haskell to hide all the IO crap, so you don't have to worry aobut your times, etc
21:38:57 <mbishop> er, types*
21:39:09 <mauke> mbishop: heh, I like that part, actually
21:39:11 <sorear> mbishop: yes.
21:39:14 <allbery_b> Haskell, on the other hand, looked a lot like SML with the asinine bits removed
21:39:15 <bd_> It wouldn't make much sense to use an Int where a (String -> IO ()) is expected... :)
21:39:20 <glguy> Monadic IO isn't a hack, it becomes a blessing
21:39:21 <mbishop> mauke: why?
21:39:23 <siti> haskell just takes time, and alot of banging your head
21:39:24 <sorear> mbishop: see eg Applicative notation
21:39:27 <Korollary> mbishop: write everything in a do block that
21:39:29 <siti> because everything you learnt was wrong
21:39:37 <sorear> mbishop: (not implemented in any known compiler)
21:39:45 <siti> now I can hardly write code in other languages because it's so painful
21:39:56 <siti> and you see all those null pointer error conditions :(
21:39:57 <sorear> siti: heh. yeah.
21:40:02 <mauke> mbishop: because IO values are basically imperative programs you can manipulate and combine with a really cool "macro language": Haskell
21:40:13 <sorear> there needs to be @siti
21:40:15 <mbishop> glguy: never called it a hack, just seems awkward to use
21:40:25 <nmessenger> @quote siti
21:40:26 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
21:40:39 * nmessenger has never tried a rutabaga
21:40:41 <mauke> @keal
21:40:41 <sorear> by analogy with @palomer, only positive
21:40:42 <lambdabot> #haskell needs to take its meds
21:41:15 <glguy> @protontorpedo
21:41:16 <lambdabot>  and is haskell ez to debug?
21:41:23 <mbishop> I suppose it just takes more time to get used to, but I find myself knowing how to program something in haskell, then I go to compile and it complains about IO stuff that
21:41:24 <glguy> getting easier!
21:41:32 <mbishop> I don't understand, it's frustrating :/
21:41:42 <siti> yeah the errors in haskell are so confusing
21:42:00 <siti> I usually just look at the line, and see what I done wrong ;)
21:42:08 <nmessenger> they can be scary-looking, but extremely helpful if you can read them.
21:42:11 <siti> but I am getting slowly used to them
21:42:22 <siti> usually the top part of the error is the only relevant bit
21:42:25 <mauke> mbishop: heh, when it "complains about IO stuff", then you don't know how to do it in haskell :-)
21:42:27 <mbishop> I can usually tell what they are saying, just not how to fix them :/
21:42:28 <nmessenger> @quote type.errors
21:42:29 <lambdabot> LoganCapaldo says: I like constructing things with type errors. It lets me read the error and try and figure out what I'm really trying to do
21:42:40 <mbishop> mauke: indeed, I just mean it LOOKS like it should work :/
21:42:54 <sorear> @tell dons siti is begging for a quote partial application (by analogy with @protontorpedo, @keal, ..)
21:42:55 <lambdabot> Consider it noted.
21:42:57 <mauke> mbishop: what languages do you know?
21:42:58 <sjanssen> ghc -f-dwim
21:43:20 <mbishop> mauke: scheme, common lisp, a little ML, a few of those "other" languages
21:43:31 <mauke> ah
21:43:34 <glguy> I tried to reason about German by ear before I understood it, my highschool teacher wouldn't have any of it
21:44:07 <mbishop> I need to get a better book on haskell
21:44:14 <mauke> mbishop: do you understand how haskell's IO system works?
21:44:23 <mbishop> I have SOE, but it's so IO based that they just gloss over IO stuff
21:44:36 <nmessenger> @wiki IO_inside
21:44:37 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
21:44:41 <mbishop> mauke: sort of, I keep reading anything I find, still not totally getting it yet
21:44:54 <nmessenger> ^^ was epiphany-inducing for me
21:45:04 * mbishop thinks he has that bookmarked
21:45:13 <mauke> nmessenger: eww, that uses scary concepts like monads and RealWorld
21:45:30 <glguy> learning Monads before really learning IO isn't a bad ideo
21:45:49 <nmessenger> what's so scary about the RealWorld?  You're in it :P
21:45:58 <allbery_b> IO Inside is the stepping stone from "okay, I srta get monads, but IO is still weird" to "ohhhhhh"
21:46:11 <mauke> I think you should learn IO first, write "hello world", etc
21:46:19 <narain> nmessenger: Don't tell me the RealWorld isn't scary! :)
21:46:19 <mauke> then later you can still worry about monads
21:46:22 <sjanssen> nmessenger: the scary thing is that RealWorld# doesn't actually exist
21:46:25 <mbishop> I want to get Bird and Wadler, but it's another one of those expensive books heh
21:46:41 <monomorph> RealWorld /= RealWorld#
21:46:48 <bd_> sjanssen: sure it does, as far as denotational semantics are concerned :)
21:47:05 <bd_> sjanssen: and that's all that really matters, right?
21:47:08 <sorear> RealWorld# is an ugly hack.
21:47:23 <nmessenger> bd_, sjanssen: yeah!  Who cares if it's actually just ()?  That's an implementation detail.
21:47:47 <sorear> Elegant, in a disturbing way, like some kind of well designed torture machine.
21:47:54 <jcreigh> I notice when you look at low-level GHC stuff, there's scary hash marks all over. What does that indicate?
21:47:59 <sorear> unboxing
21:48:07 <bd_> nmessenger: nono, it's State# RealWorld, clearly :)
21:48:08 <narain> mbishop: Wadler's "Monads for Functional Programming" paper is a pretty good motivator
21:48:12 <mauke> RealWorld is an unimportant implementation detail
21:48:14 <bd_> jcreigh: anything ending in # is a GHC primitive
21:48:18 <sorear> jcreigh: Int -> int (*)()  /* a thunk */
21:48:23 <bd_> wired into the compiler
21:48:26 <bd_> in GHC.Prim
21:48:31 <sorear> jcreigh: Int# -> int  /* a number */
21:48:36 <nmessenger> sorear: makes sense to me: 'type IO a = World -> (a, World)', i.e., it transforms the state of the World and results in an 'a'.
21:48:45 <sjanssen> bd_: not all #'s are wired into the compiler
21:48:59 <bd_> hm
21:49:06 <bd_> well, they're all implementation details anyway :)
21:49:07 <mbishop> I'm reading SPJ's awkward squad right now
21:49:12 <Korollary> very good paper
21:49:16 <bd_> data Int = GHC.Base.I# Int# <-- I guess I# isn't primitive
21:49:31 <mauke> I should write an alternative IO that's not a function
21:49:52 <sjanssen> # usually means that it operates on an unboxed value
21:49:52 <mauke> IO a being a function only causes headaches
21:50:19 <bd_> mauke: it being a function is just a implementation detail for sequencing purposes..
21:50:51 <mauke> yeah, exactly
21:50:55 <sjanssen> does anybody really know what IO is?  does anybody really care?
21:51:01 <Korollary> I don't
21:51:09 <mauke> no one should need to know about RealWorld, especially not newbies
21:51:16 <sjanssen> (about IOOOO)
21:52:08 <glguy> io therefore iam
21:52:24 <nmessenger> io, io, it's off to work we go
21:52:38 <mauke> io ergo sum
21:53:08 <glguy> ergo got a lot of use after The Matrix :-)
21:53:20 <Korollary> I stopped using it after the matrix
21:53:23 <Korollary> passe
21:53:29 <allbery_b> or ergot, sometimes hard to tell :)
21:53:40 <sorear> nmessenger: it makes *sense*, but I don't think you should think of it that way. I much prefer continuations for reasoning.
21:54:34 <sorear> @botsnack
21:54:35 <lambdabot> :)
21:54:54 <nmessenger> sorear: I'll think of it how I want :P
21:54:55 <siti> @botsnack
21:54:55 <lambdabot> :)
21:55:01 <siti> @help
21:55:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:55:09 <siti> @list
21:55:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:55:29 <mauke> @quote
21:55:29 <lambdabot> Makali says: Whenever a programmer thinks, "Hey, skins, what a cool idea", their computer's speakers should create some sort of cock-shaped soundwave and plunge it repeatedly through their skulls.
21:55:53 <nmessenger> @vixen Still dead?
21:55:54 <lambdabot> <undefined>
21:56:16 <mauke> @quote
21:56:16 <lambdabot> Bulat says: there is new Time library, which is supposed to replace old System.Time. we hope that it will happen before 2038
21:56:35 <nornagon> @quote
21:56:36 <lambdabot> droundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
21:56:51 <mauke> @keal
21:56:52 <lambdabot> are you saying i am MegaMonad?
21:56:58 * nmessenger mostly understood that
21:57:00 <sjanssen> @meal
21:57:00 <lambdabot> evaluating expressions is ALL haskell does?????
21:57:03 <sjanssen> yes!
21:57:07 <sjanssen> best keal quote
21:57:17 * sjanssen wants that on a #haskell tshirt
21:57:32 <allbery_b> some of those expressions are "interesting", of course :)
21:57:36 <siti> @slap
21:57:37 * lambdabot slaps
21:57:44 <siti> @slap allbery_b
21:57:44 <lambdabot> why on earth would I slap allbery_b
21:57:47 <mauke> @shapr siti
21:57:47 <nmessenger> @slap me
21:57:47 * lambdabot beats up siti
21:57:48 * lambdabot smacks nmessenger about with a large trout
21:57:48 <siti> pfft
21:58:00 <allbery_b> heh
21:58:02 <siti> how can you do it and I can't :(
21:58:15 <siti> @shapr siti
21:58:15 * lambdabot slaps siti
21:58:18 <nmessenger> siti: LB is a fickle girl
21:58:29 <monomorph> @botsteak
21:58:30 <lambdabot> Unknown command, try @list
21:58:38 <mauke> @bat
21:58:38 <lambdabot> Maybe you meant: bf bug fact faq ft let map part what
21:58:39 <monomorph> @botlambchop
21:58:40 <lambdabot> Unknown command, try @list
21:58:57 <glguy> @teens
21:58:57 <mauke> @bf +[.+]
21:58:58 <lambdabot>   !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk...
21:59:03 <monomorph> This bot doesn't know how to enjoy the best dishes.
21:59:42 <siti> @unlambda foldr (\a b-> a + b) 0 [1..10]
21:59:43 <lambdabot>  unlambda: Unknown operator 'f'
21:59:47 <siti> pfft
21:59:59 <siti> @unlambda (\a b-> a + b)
21:59:59 <lambdabot>  unlambda: Unknown operator '('
22:00:09 <siti> @unlambda \a b-> a + b
22:00:10 <lambdabot>  unlambda: Unknown operator '\\'
22:00:11 <allbery_b> look up unlambda
22:00:11 <nmessenger> @unlambda ```sii``sii
22:00:15 <lambdabot> Done.
22:00:19 <siti> ;S
22:00:41 <siti> @elite
22:00:42 <lambdabot> Say again?
22:00:45 <nmessenger> > ap id id (ap id id)
22:00:45 <sorear> I think what you want is:
22:00:45 <siti> @elite siti
22:00:46 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
22:00:46 <lambdabot>       Expec...
22:00:46 <lambdabot> $I+I
22:00:56 <sorear> @pl \a b -> a + b
22:00:57 <lambdabot> (+)
22:01:07 <sorear> @pl \a b c d e -> e c b a d
22:01:08 <lambdabot> ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))
22:01:10 <nmessenger> extended LB play should maybe be taken to /msg
22:01:20 <siti> @help fact-update
22:01:21 <lambdabot> Define a new fact, overwriting
22:01:31 <allbery_b> @quote flip-stream
22:01:32 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
22:01:48 <siti> @dice
22:01:49 <lambdabot> unexpected end of input: expecting number
22:01:54 <lambdabot> This is sorear's favorite command.
22:01:54 <siti> @help dice
22:01:55 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
22:01:59 <nmessenger> @dice 2d6
22:02:00 <lambdabot> 2d6 => 6
22:02:08 <siti> :S
22:02:23 <nmessenger> @dice 1d20
22:02:24 <lambdabot> 1d20 => 5
22:02:49 <lambdabot>  @msg is fun
22:02:53 <siti> @dice 1d1
22:02:54 <lambdabot> 1d1 => 1
22:02:57 <siti> WOW!
22:03:10 <sorear> ?
22:03:18 <siti> I am just being silly :P
22:03:23 * sorear peeks from the curtain
22:03:27 * nmessenger imagines a 1-sided die
22:03:35 <siti> @wikipedia best programming language
22:03:37 <lambdabot> No Result Found.
22:03:40 <nornagon> nmessenger: sphere
22:03:41 <siti> lol
22:03:41 <sorear> duh, it's spherical
22:03:57 <narain> @dice 1d0
22:03:57 <lambdabot> 1d0 => 0
22:04:03 <siti> @spell haskelll
22:04:05 <lambdabot> Haskell Haskel Haskell's Haskel's Skell
22:04:12 <siti> wooho haskell is in the dictionary
22:04:13 <sorear> unfortunately dice of 3 and fewer sides cannot be finite complexes
22:04:14 <siti> @botsnack
22:04:15 <lambdabot> :)
22:04:18 <nmessenger> @spell farfignuten
22:04:19 <lambdabot> Farmington Tarkington gargantuan forgotten Argentine
22:04:37 <allbery_b> you'd need a German dictionary for that
22:04:43 <allbery_b> ...if then
22:04:49 <siti> @spell-all farfignuten
22:04:50 <lambdabot> Did you mean Farmington, Tarkington, gargantuan, forgotten or Argentine?
22:04:59 <siti> what's the difference :S
22:05:06 <siti> @pretty lambdabot
22:05:07 <lambdabot> "Parse error" at column 10
22:05:08 <allbery_b> @spell vergnugte
22:05:09 <lambdabot> verging vignette virginity Vegemite reignite
22:05:13 <siti> @help pretty
22:05:14 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
22:05:22 <nmessenger> @spell-all multpile wrods
22:05:23 <sorear> @prety f x = x+y
22:05:23 <lambdabot> Did you mean multiple, multiply, multiplier, multiples or multiplet?
22:05:23 <lambdabot>  f x = x + y
22:05:32 <siti> @pretty 5*5/2
22:05:33 <lambdabot> "Parse error" at column 6
22:05:46 <siti> @pretty 5*5`div`2
22:05:46 <lambdabot> "Parse error" at column 10
22:05:53 <siti> :S
22:06:02 <narain> @pretty x=5*5`div`2
22:06:03 <lambdabot>  x = 5 * 5 `div` 2
22:06:07 <siti> oh ok
22:06:16 <siti> a haskell function
22:06:23 <siti> not really an expression ;)
22:06:24 <narain> i was just guessing :)
22:06:35 <siti> @todo
22:06:36 <lambdabot> 0. SamB: A way to get multiple results from a google search
22:06:36 <lambdabot> 1. dons: improve formatting of @dict
22:06:36 <lambdabot> 2. dons: write Haskell Manifesto
22:06:36 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
22:06:36 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
22:06:38 <lambdabot> [23 @more lines]
22:06:56 <nmessenger> siti: /msg lambdabot @blah
22:07:06 <siti> yeah yeah sorry I was just playing ;)
22:07:10 <siti> no one else was talking :P
22:07:26 <nmessenger> siti: or /join #haskell-blah ;)
22:07:27 <siti> I'll feel people's logs with useless crap....
22:07:46 <siti> heh
22:07:54 <newsham> ?yhjulwwiefzojcbxybbruweejw
22:07:55 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
22:08:43 <nmessenger> @. elite . elite . elite girl19
22:08:44 <lambdabot> I |-|Av3 B33n IN70 n07 4c7U411y |-|4(xIng, 8U7 $0cial 3n9INe3rIn9
22:11:28 <newsham> ?. elite babel en fr someone sent us up the bomb
22:11:30 <lambdabot> qUElQU'un N0US 4 3nVOYé$ \/eRz0rz |3 |-|Au+ De lA BoMB3
22:12:00 <nmessenger> @. elite run cycle "lo"
22:12:02 <lambdabot> "1oLol0lOlo1o|olO|0LOlOlO|Ol0LOloL01OL0lO|o|0|OL010L0L0|o|O|ol0|0|O10l0LoL0l...
22:12:35 <arcatan> I see lambdabot is a tool for great creativity
22:12:37 <nmessenger> s/us up/up us/
22:12:49 <nmessenger> /pet-peeve
22:13:02 <newsham> i wouldnt harm your pet
22:13:32 <arcatan> Somebody set up us the bomb.
22:13:34 <jcreigh> "But nevertheless it's considered Good Style to use 'do' even for one statement because it simplifies adding new statements in the future." -- IO Inside (Hmm, I usually just say "foo = someAction" if there's only one IO action.)
22:13:51 <nmessenger> /agree jcreigh
22:13:54 <sjanssen> jcreigh: that isn't typical advice
22:14:06 <nmessenger> /slash
22:14:16 <sjanssen> especially with the capital letters
22:14:21 <Korollary> how much of a gain is that? "adding new statements in the future." Sheesh
22:14:22 <newsham> that sounds akin to saying "always use curly braces with for and while loops"
22:14:31 <newsham> some people are religeous about it but many dont hold to that rule
22:15:04 <newsham> i personally use an extra do more often than not.
22:15:17 <newsham> but its nothing worth arguing about
22:15:27 <sorear> i personally use >> more often than do, even in the 2-stmt case
22:15:41 <nmessenger> aye!  Let's hear it for the voice of reason!
22:17:35 <nmessenger> but Capital Letters do tend to Make A Point
22:17:57 <newsham> so does a pencil sharpener.
22:18:09 * nmessenger high-fives newsham 
22:18:24 <sjanssen> so does @unpl
22:18:49 <sjanssen> @unpl f . g -- ah yes, excellent point, unpl
22:18:50 <lambdabot> (\ c -> f (g c))
22:19:31 <glguy> unnecessary do's make me think the author doesn't fully understand what do is for
22:19:46 <sorear> all do's are unnecessary
22:20:04 <sorear> @get-diego
22:20:04 <lambdabot> Unknown command, try @list
22:20:10 <monomorph> all do's are necessary.
22:20:10 * sorear quietly leaves
22:20:11 <emu> do hair shirts have hair-dos?
22:20:23 <nmessenger> monomorph: they're just syntax sugar
22:20:37 <newsham> most of haskell is syntactic sugar.
22:20:38 <monomorph> they are necessary syntax sugar.
22:20:43 <newsham> you should be using lambdas.
22:20:53 <nmessenger> @undo do {s <- getLine; print s}
22:20:54 <lambdabot> getLine >>= \ s -> print s
22:20:56 <emu> let isn't sugar
22:20:56 <newsham> anyone who uses anything else should be ashamed of themselves
22:21:12 <newsham> are you sure?
22:21:17 <emu> @type fix
22:21:19 <lambdabot> forall a. (a -> a) -> a
22:21:19 <emu> @src fix
22:21:19 <lambdabot> fix f = let x = f x in x
22:21:26 * nmessenger is ashamed of himself
22:21:42 <narain> emu: iirc from my SML days, let is sugar
22:21:50 <sjanssen> emu: let can desugar into lambdas and application
22:21:51 <nmessenger> @. pl undo do {s <- getLine; print s}
22:21:52 <lambdabot> print =<< getLine
22:22:03 <monomorph> Haskell is sugar for GHC Core or JHC Core.
22:22:05 <emu> you can't write the Y combinator without let, in haskell's type system
22:22:24 <emu> (or some explicit recursion construct)
22:22:34 <sjanssen> oh right, recursion
22:22:38 <sjanssen> duh
22:23:04 <newsham> emu: you are allowed to use let to implement Y.
22:23:19 <monomorph> ASCII is syntax sugar for binary.
22:23:20 <newsham> but you must promise not to use it for anything else
22:23:25 <sorear> also, the "haskell's type system" is important.
22:23:32 <narain> so if you write the Y combinator using lambdas, the type system can't figure it out?
22:23:33 <emu> ok; all recursive functions could use fix ;)
22:23:39 <nmessenger> EVERYTHING is syntax sugar for strings :)
22:23:41 <emu> narain: basically
22:23:45 * sorear has implemented a sound typesystem that can type fix
22:24:06 <narain> emu: interesting
22:24:12 <emu> there are such type systems
22:24:23 <monomorph> You now see why "___ is just syntax sugar" is irrelevant to "___ is necessary".
22:24:54 <sorear> narain: yes, it's been proven. wikipedia "strongly normalizing"
22:24:56 <emu> @type \f -> (\x -> f (x x)) (\x -> f (x x))
22:24:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
22:24:58 <lambdabot>       Expected type: t
22:25:07 <emu> there are other ways to try, but they all come down to that
22:25:13 <nmessenger> monomorph: Yeah, they're aren't *terribly* correlated, but I find sometimes using explicit binds looks neater
22:25:31 <sorear> and they all fail, in the simply typed LC (which is haskell - data decls)
22:25:38 <monomorph> Explicit binds are also necessary.
22:25:48 <newsham> come and see the violence inherent in the system.
22:25:49 <emu> haskell has type classes too
22:26:01 <emu> well i guess that goes with data decls
22:26:53 <monomorph> "___ is unnecessary" makes me think the speaker doesn't fully understand what programming is for, to paraphrase the speaker.
22:28:24 <glguy> man... you guys really took my completely reasonable statement to the extreme :)
22:29:06 <monomorph> Haha sorry
22:29:22 <sorear> night all
22:29:30 <newsham> glguy: only way to see where it will break ;-)
22:29:38 <uebayasi> hey hey
22:29:55 <cjs> Oooo, look who's here!
22:30:09 <monomorph> who?
22:30:20 <cjs> uebayashi-san.
22:30:29 <cjs> Another NetBSD developer.
22:30:46 <cjs> Anyway, wasn't there a way to define stuff at the top-level in Hugs? I can't remember how to do it.
22:31:00 <newsham> from the interactive cmd line?
22:31:02 <glguy> Open Text Editor..
22:31:02 <monomorph> No, not hugs.
22:31:15 <monomorph> In ghci, "let x=2+2"
22:31:24 <cjs> Yeah, from the interactive command line. Not Hugs, only ghci? I can switch.
22:31:39 <monomorph> perhaps "let five=2+2" is better
22:32:43 <glguy> man... beautiful women keep telling me to call them on TV
22:32:43 <asokoloski> hey, anyone mind if I ask a boring, module-installing type question?
22:32:45 <monomorph> you can also: xs <- readFile "/etc/passwd"
22:32:48 <glguy> I could meet hot singles
22:32:56 <glguy> sigh up for a 2 year degree program
22:33:06 <nmessenger> cjs: nope, you'll have to make do with expression-level names: 'let x = ... in ...'
22:33:44 <nmessenger> though Hugs does allow 'where'-clauses as if they were expression-level
22:33:57 <nmessenger> (last time I used it)
22:34:10 <monomorph> like "5 where 5=2+2" ?
22:34:15 <newsham> also hugs has :edit
22:34:24 <newsham> so if you run hugs on a file, you can constantly :edit it when you want new top levels
22:34:32 <nmessenger> monomorph: yep, but all that does is redefine (+) :P
22:34:38 <newsham> which is often enough
22:34:58 <monomorph> It happens to redefine nothing.
22:34:58 <nmessenger> > let 2 + 2 = 5 in 5
22:35:00 <lambdabot>  5
22:35:07 <nmessenger> > let 2 + 2 = 5 in 2 + 2
22:35:09 <lambdabot>  5
22:35:09 <asokoloski> > let 2 + 2 = 5 in 2 + 2
22:35:11 <lambdabot>  5
22:35:12 <monomorph> 2+2=5 /= 5=2+2
22:36:03 <monomorph> > let 5=2+2 in 2+2
22:36:05 <lambdabot>  4
22:36:08 <monomorph> see?
22:36:17 <asokoloski> haha
22:36:21 <monomorph> In fact...
22:36:35 <monomorph> > let 5=2+2 in 5==2+2
22:36:36 <lambdabot>  False
22:36:37 <newsham> is it possible to make a typeclass "Second a b" that has a function  second :: a -> b     that returns the second item of a tuple of size 2 or 3?
22:36:40 <nmessenger> oh, I misread it
22:37:13 <newsham> second (x,y) = y;      second (x,y,z) = y   ...
22:40:46 <asokoloski> does anyone here know how to get the module FFI?
22:41:25 <asokoloski> I'm trying to install zlib (as a side quest in the search for the holy lambdabot)
22:41:35 <emu> maybe you need -ffi flag?
22:41:52 <asokoloski> oh
22:42:00 <asokoloski> I'll try that
22:43:05 <newsham> http://www.thenewsh.com/~newsham/x/order.hs
22:43:15 <newsham> why do I need to tell it the types?
22:43:56 <asokoloski> emu: I'm running "runhaskell -ffi Setup.hs build"
22:44:30 <asokoloski> and it exits immediately.   seems like it's not actually doing anything
22:45:40 <asokoloski> I may be messing up the install commands for zlib, of course.  I'm a noob :(
22:46:46 <asokoloski> The docs for zlib are ... sparse
22:48:20 <sjanssen> asokoloski: sounds like you need to install c2hs
22:48:35 <newsham> anyone here good with classes and types?
22:49:18 <asokoloski> I will try that
22:49:20 <pzpz> hey -- i'm scouring the net right now to no avail; is it neccessary to have to define all the tokens twice wihle using alex/happy? (First in alex, and then once again in Happy?)
22:49:25 <sjanssen> erm, maybe not
22:49:33 <sjanssen> asokoloski: you're using ghc, right?
22:49:36 <asokoloski> yes
22:49:48 <asokoloski> i'm getting this error:
22:49:51 <asokoloski> Stream.hsc:258:41: Not in scope: `nullForeignPtr'
22:50:01 <sjanssen> and what happens when you run "runghc Setup.hs configure; runghc Setup.hs build"?
22:50:12 <asokoloski> configure works fine
22:50:25 <asokoloski> oh, haha
22:50:34 <asokoloski> hold on
22:50:59 <asokoloski> same
22:51:28 <asokoloski> i was using runhaskell, but both that and runghc give the aforementioned error
22:51:28 <sjanssen> newsham: adding a functional dependency in Second might help
22:51:44 <asokoloski> for runghc Setup.hs build
22:52:14 <newsham> sjan: not sure what that means
22:52:18 <sjanssen> runghc and runhaskell are probably the same thing on your system
22:52:32 <asokoloski> yep
22:52:47 <sjanssen> change the 4th line to "class Second a b | a -> b where"
22:52:49 <asokoloski> googling led me to believe that i need FFI, which I don't seem to have
22:53:11 <asokoloski> damn, you're multitasking :)
22:53:25 <asokoloski> nice
22:53:37 <sjanssen> asokoloski: the latest source from darcs builds for me
22:53:52 <newsham> what does that mean?
22:53:54 <asokoloski> i'm using ghc 6.4.1 on a mac
22:54:01 <sjanssen> I've got ghc 6.6, and I don't seem to have an FFI package
22:54:03 <asokoloski> which may be an issue too
22:54:05 <asokoloski> hmm
22:54:25 <sjanssen> you likely need 6.6 for zlib
22:54:31 <asokoloski> ok
22:54:44 <newsham> i built zlib in 6.4 (i had troubles with my zlib.h but not with ghc)
22:54:51 <asokoloski> and that probably means building ghc from source?
22:55:08 <asokoloski> 6.4.1 is the latest binary for os x
22:55:23 <asokoloski> huh
22:55:33 <narain> newsham: this might help: http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies
22:55:37 <lambdabot> Title: FunctionalDependencies - Haskell Prime - Trac, http://tinyurl.com/32qu3g
22:55:38 <sjanssen> asokoloski: there might be binary packages for your system.  Alternatively, you could ask newsham what he did
22:55:43 <asokoloski> yep
22:55:45 <narain> not that i understand it much :)
22:55:52 <newsham> narain: thank you
22:56:00 <asokoloski> newsham, are you also on a mac?
22:56:27 <sjanssen> newsham: basically the "a -> b" fundep means that fixing the type of a fixes the type of b
22:56:30 <newsham> no. linux.
22:56:48 <sjanssen> it's a directive to the type inferencer to simplify the class constraints
22:57:13 <sjanssen> the steps to build zlib on 6.4 should be the same for any platform
22:57:26 <asokoloski> ok
22:58:14 <asokoloski> are there any steps that an unexperienced person might tend to miss?
22:58:54 <sjanssen> if you want to install lambdabot on 6.4, you'll need to install ByteString too
22:59:09 <sjanssen> (ByteString is also a dep of zlib)
22:59:10 <asokoloski> I got the latest darcs source, then ran the
22:59:21 <asokoloski> i think i have that already
23:00:19 <newsham> yay, that fixed it
23:00:27 <asokoloski> zlib's the only one giving me trouble
23:01:00 <newsham> so i guess my question is... if its possible to implement a generic fst,snd,etc..  like this, why dont the libs do that?
23:01:18 <pzpz> Is there any way to have Happy understand the token definitions defined in an Alex (.x) file, or must they be duplicated?
23:01:49 <sjanssen> newsham: the libs were designed before MPTCs and fundeps were invented
23:02:06 <newsham> is this something worth doing?
23:02:18 <sjanssen> perhaps
23:04:58 <sjanssen> in practice, the tuple issue doesn't seem to come up very often
23:05:53 <xpika___> what can i do with a monad reader?
23:06:25 <newsham> keep around "global" readable state
23:06:55 <newsham> (you mean reader monad?  or am I talking about something else?)
23:07:13 <xpika___> Control.Monad.Reader
23:07:45 <sjanssen> @docs Control.Monad.Reader
23:07:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
23:07:56 <xpika___> ype. that one
23:07:56 <sjanssen> ouch, those docs suck
23:08:30 <newsham> lets say you have a config file with lots of parameters.  you can roll it up in a reader monad so you can access the config wherever you want without having to always pass it around explicitely
23:08:43 <sjanssen> actually, that page seems to be partially garbled
23:08:56 <sjanssen> "Declaration of the Monoid class,and instances for list and functions" -- way wrong
23:09:39 <newsham> > runReader (do { x <- asks fst; y <- asks snd; return (x+y)}) (5,6)
23:09:41 <lambdabot>  11
23:09:59 <sjanssen> @google all about monads control.monad.reader
23:10:02 <lambdabot> http://lambda-the-ultimate.org/node/92
23:10:02 <lambdabot> Title: Explaining monads | Lambda the Ultimate
23:10:45 <xpika___> ahhh, i get it
23:11:00 <xpika___> its very similar to the state monad
23:11:09 <newsham> yah, reader is a read-only state monad.
23:11:20 <xpika___> :(
23:11:20 <newsham> there's also one for writing
23:11:26 <xpika___> :)
23:13:06 <newsham> > runWriter (do { tell "foo"; tell "bar"; return 3})
23:13:08 <lambdabot>  (3,"foobar")
23:13:32 <dons> sjanssen: chunkwise strict sumfile, should run faster than the fully lazy version (avoids a bunch of bounds checks), http://www.haskell.org/haskellwiki/Shootout/SumFile#Pending
23:13:32 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:13:35 <lambdabot> Title: Shootout/SumFile - HaskellWiki
23:13:51 <nmessenger> @type join (***) -- also you can do weird type hackery with it
23:13:53 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
23:14:10 <nmessenger> > join (***) 12
23:14:11 <lambdabot>   add an instance declaration for (Show (a (b, b) (c, c)))
23:14:17 <xpika___> is mark the brother of Simon?
23:15:13 <nmessenger> @type join (***) negate
23:15:14 <lambdabot> forall b. (Num b) => (b, b) -> (b, b)
23:15:36 <nmessenger> > join (***) negate (2,-12)
23:15:38 <lambdabot>  (-2,12)
23:16:29 <nmessenger> like a 'map' for pairs
23:17:03 <asokoloski> i think i figured out my problem -- I'm using version 0.7 of Data.ByteString, but 'nullForeignPtr' is only exported from Data.ByteString.Base in the head
23:17:49 <asokoloski> thanks everyone
23:23:31 <mbishop> Why do people think OO is so great?
23:23:52 <dons> ?quote deprec
23:23:52 <lambdabot> Excedrin says: isn't OO deprecated?
23:24:15 <desrt> merely depreciated
23:24:41 <sieni> both
23:27:29 <newsham> ?farber
23:27:29 <lambdabot> Unknown command, try @list
23:27:55 <xpika___> mbishop: because oo emphasizes data hiding?
23:28:51 <mbishop> what language doesn't emphasize abstraction?
23:28:56 <xpika___> C
23:28:59 <nmessenger> assembler
23:29:02 <dons> perl?
23:29:07 <xpika___> perl has OO
23:29:10 <sieni> fortran
23:29:29 <sieni> does oo emphasize abstraction? :-O
23:29:46 <xpika___> sieni:  as far as i know
23:29:48 <mbishop> that's what he said :P
23:30:37 <nmessenger> well, objects are these little blobs that have functions defined on them, and the usual subtyping polymorphism means you can use a thing if it follows an interface and it should Do The Right Thing
23:30:44 <asokoloski> perl has closures too, though they're not so often used as to warrant a single-character syntax like '\'
23:32:06 <lucca> mbishop: unlambda emphasizes abstraction removal... ^_^
23:32:24 <nmessenger> a Java class is three inextricably bound things, though: a class of types that follow an interface, a concrete type, and a declaration that the type is in the class
23:32:39 <nmessenger> lucca: "lambda abstraction"?
23:33:08 <lucca> aye, a different type of abstraction than was meant here
23:33:44 <mbishop> OO has no formal definition it seems
23:34:03 <lucca> are there any haskell implementations of unlambda?  I got all excited and looked in lambdabot... but it just shells :/
23:34:04 <xpika___> mbishop: neither to any programming terms :(
23:34:14 <lucca> hm, unlambda or lazy-k
23:34:20 <mbishop> xpika___: indeed, that's usually true, but OO seems worse heh
23:34:31 * nmessenger wants to write something in Lazy K one day
23:35:18 * xpika___ says make it today!
23:37:11 <dons> yeah, there's a 20 line unlambda implementatoin in lambdabot
23:39:48 <nmessenger> @google unlambda in haskell
23:39:49 <lambdabot> http://home.nvg.org/~oerjan/unl-int/
23:46:13 <yip__> anyone know what the Bool parameter is supposed to mean for getHostEntries?
23:49:03 <nmessenger> ?index getHostEntries
23:49:04 <lambdabot> Network.BSD
23:49:09 <nmessenger> @docs Network.BSD
23:49:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-BSD.html
23:49:17 <yip__> the docs don't say anything
23:50:01 <nmessenger> google code search "getHostEntries"?
23:50:16 <yip__> can lambdabot do that?
23:50:25 <Korollary> @src getHostEntries
23:50:26 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:50:40 <nmessenger> the Hugs source names that parameter stayOpen
23:51:40 <yip__> hm.....
23:51:52 <yip__> is hugs any good compared to ghc?
23:52:30 <Korollary> ghc is better
23:52:31 <sieni> it has a cuddly name?
23:53:08 <nmessenger> http://tinyurl.com/2mrwhc
23:53:11 <lambdabot> Title: Language-Haskell-0.01/hugs98-Nov2003/fptools/libraries/network/Network/BSD.hsc - ...
23:53:18 <lispy> @dons
23:53:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:53:19 * nmessenger doesn't know how to paste in irssi
23:54:32 <pjd_> ugh: http://kawagner.blogspot.com/2007/02/why-monads-are-evil.html
23:54:34 <lambdabot> Title: Karsten Wagner's Blog: Why monads are 'evil'
23:55:03 <nmessenger> pjd_: yeah, I read that.  He/She didn't even get it after I tried to explain.
23:56:07 * pjd_ laughs at the inimitable Slava comment
23:57:08 <nmessenger> yikes! That's harsh.
23:57:32 <pjd_> nmessenger: sounds like the usual Slava to me
23:58:01 <dons> slava's great :)
23:58:14 <pjd_> yep :)
23:59:25 <pjd_> man, how many things are wrong in that essay
23:59:30 <Korollary> He's clueless
23:59:42 <Korollary> and been like that for 2 years
23:59:48 <pjd_> really?
23:59:49 <Korollary> ignorance is bliss
23:59:57 <Korollary> yeah, check out his posts at LtU
