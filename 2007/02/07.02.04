00:04:01 <sorear> gak!
00:05:58 <nmessenger> netsplit!
00:09:10 <sorear> @users
00:09:11 <lambdabot> Maximum users seen in #haskell: 322, currently: 265 (82.3%), active: 21 (7.9%)
00:09:32 <sorear> and I thought it was a simple connection problem.
00:09:57 <sorear> very distracting when ERC switches focus mid-hack to the newly opened #haskell buffer :(
00:27:14 <sorear> @botsnake
00:27:15 <lambdabot> :)
00:28:54 <nmessenger> @botplane
00:28:55 <lambdabot> Unknown command, try @list
00:29:20 <dons> sorear, bored? want to fix the mandelbrot shootout entry?  you could lazily generate a (lazy) bytestring, for decen perf. --> http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=all
00:29:21 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
00:29:22 <lambdabot> Title: mandelbrot benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langua ..., http://tinyurl.com/q8e4f
00:29:25 <dons> i really think we can do a lot better here
00:33:28 <sorear> yes we can
00:33:45 <sorear> I saw it a couple days ago :)
00:34:33 <sorear> ATM i'm refactoring vty to separate the terminfo-style layer from the curses-style layer
00:34:39 <sorear> also:
00:34:57 <sorear> see Graphics.Vty.Addr.  large record with lots o' strict bools.
00:35:27 <sorear> dons: ghc isn't smart enough to unbox strict Bools, even with -funbox-strict-fields!
00:35:55 <sorear> and since the API uses record update, switching to bitflags would be incompatible :(
00:45:44 <dons> Bools are a bit special
00:45:55 <dons> you could use UArray Bool, they're packed as bits
00:46:10 <bd_> it would be an API change though
00:46:31 <dons> well, yi is a good perf test for vty
00:46:50 <dons> practical use should inform the library api
00:47:25 <dons> if we can't get curses speed out of vty, we'd have to switch back...  (/me motivates sorear some more ... :)
00:47:48 <bd_> sorear: Can you transform it from a constructor of Bools to a bitfield when it crosses the API boundrary?
00:47:55 <bd_> assuming it's not going to be crossing too often
00:48:41 <sorear> bd_: that's the problem - it'll be passed in once and immediately deconstructed... only to be scrutinized once and compared twice
00:49:09 <bd_> ?
00:49:21 <sorear> also I suspect the *heavy* use of IORefs is a more significant factor
00:49:25 <dons> a Word32 with some smart constructors for setting and getting bits doesn't seeem too painful
00:49:30 <dons> sorear: oh yes
00:49:33 <dons> IORefs aren't very fast
00:50:15 <sorear> is there a non-C-volatile ref type?
00:50:28 <sorear> ie not thread safe, but reorderable
00:50:59 <bd_> ?where vty
00:51:00 <lambdabot> http://members.cox.net/stefanor/vty/
00:51:04 <dons> hmm. you can update fields in an IOUArray
00:52:45 <bd_> sorear: If the datatype is simple enough, you could use Ptr. It'd by ugly though
00:52:48 <bd_> be*
00:53:00 <bd_> I guess you're in IO already though
00:53:10 <dons> yeah, Ptr a is pretty good
00:53:33 <dons> StateT (Ptr Foo) :)
00:53:41 <sorear> ReaderT?
00:53:53 <sorear> right now I'm going for StateT IO
00:53:56 <sorear> right now I'm going for StateT foo IO
01:33:52 <patrick22> hello
01:34:30 <patrick22> I am trying out the scheme interpreter tutorial and have a basic problem.... anyone there to help ? thanks!
01:34:38 <dons> yeah, ask away
01:34:43 <patrick22> ok
01:35:09 <patrick22> main = do args <- getArgs
01:35:10 <patrick22>           putStrLn (readExpr (args !! 0))"
01:35:37 <patrick22> and when i compile, i get the error message:  Not in scope: `getArgs'
01:35:44 <bd_> import System.Environment
01:35:49 <dons> right. its in the System.Environment module
01:36:00 <dons> so add the above line to your src file (at the top)
01:36:10 <patrick22> yes i see....
01:36:37 <patrick22> yeps... it works...
01:36:48 <dons> ?. pl undo do args <- getArgs; putStrLn (readExpr (head args))
01:36:49 <lambdabot> putStrLn . readExpr . head =<< getArgs
01:37:02 <dons> that's a shorter way to write the above 2 lines you posted
01:37:14 <dons> main = putStrLn . readExpr . head =<< getArgs -- :)
01:37:24 <dons> just for fun, and to inspire you :)
01:37:27 <patrick22> hm.... i see this =<<  operator often, but dont understand it yet
01:37:40 <patrick22> inspiration is good
01:37:42 <dons> it runs the action on the right, passing its result to the code on the left
01:37:45 <nornagon> it's just >>= the other way around.
01:37:50 <nornagon> ?src =<<
01:37:50 <lambdabot> Source not found. Wrong!  You cheating scum!
01:37:53 <nornagon> ?src =<< List
01:37:54 <lambdabot> Source not found. My pet ferret can type better than you!
01:37:59 <dons> ?undo do  x <- getArgs; print x
01:37:59 <lambdabot> getArgs >>= \ x -> print x
01:38:08 <dons> ?. pl undo do  x <- getArgs; print x
01:38:09 <lambdabot> print =<< getArgs
01:38:30 <dons> ?src (=<<)
01:38:30 <lambdabot> f =<< x = x >>= f
01:38:41 <dons> what a cute language, eh? :)
01:39:21 <patrick22> yes.... i am writing down these ideas... to reflect on it....
01:40:54 <patrick22> by the way, what is the idea behind the use of type signatures, e.g. passing multiple parameters to a function... i find these many arrows confusing
01:41:09 <qwr> patrick22: curring
01:41:16 <nornagon> a -> b -> c  ===  a -> (b -> c)
01:41:42 <nornagon> so f :: a -> b -> c called with one argument returns a function that takes one argument and returns one value.
01:41:51 <nornagon> functions only ever take one argument, really.
01:42:05 <qwr> http://en.wikipedia.org/wiki/Currying
01:42:18 <sorear> yay!  I've my first GHC panic!
01:42:50 <siti> :D
01:43:02 <patrick22> ah... ok... that seems to make sense. (i see this in this lambda calculus as well-- one parameter)
01:44:28 <dons> > let f x y = x + y in    let  add2 = f 2 {- curry! -}   in add2 7
01:44:30 <lambdabot>  9
01:44:59 <qwr> > let f = \a -> (\b -> a + b) in f 2 7
01:45:01 <lambdabot>  9
01:46:28 <qwr> > let f = \x -> (\y -> x + y) in (f 2) 7
01:46:30 <lambdabot>  9
01:46:36 <qwr> all the same...
01:51:18 <moconnor> I have a data type "data Foo = Bar String | Baz String".  I want to write a function which given a Foo returns the inner string.  So I could write foo2str (Bar x) = x and similar for Baz.  Is there anyway w/o manually listing the constructors?  My real case has 12 constructors.
01:52:03 <moconnor> So my implementation is 12 lines long, and seems offensively WET.
01:52:11 <dons> if they all share the same String underneath, you could structure it differently
01:52:36 <dons> data Foo = Foo { foo2str :: String, constr :: T } ; data T = Bar | Baz | ...
01:52:47 <moconnor> They don't share the same string.  It could be Bar "cows" and Baz "cats", if that's what you mean.
01:52:48 <dons> then foo2str will extract the String for any Foo
01:52:59 <dons> no, they all have a String field?
01:53:04 <moconnor> yeah, they do
01:53:11 * moconnor contemplates your code
01:53:16 <dons> in which case the above type would work, and you get a free extraction function
01:53:38 <Syzygy-> moconnor: Are all constructors of the form Something String?
01:54:17 <moconnor> Syzygy-: yes
01:55:04 <Syzygy-> Hmmmm. foo2string (_ s) = s didn't work though.
01:55:55 <Syzygy-> data Foo = Foo { foo2string::String} | Bar {foo2string::String}
01:56:00 <Syzygy-> This works in ghc 6.6
01:56:47 <moconnor> dons: I'm using this in conjunction with GetOpt, so if I swapped foo2str and constr, could I pass (Foo Bar), which is curried, as new constructor?  Since GetOpt just requires (String -> a)
01:56:52 <moconnor> oh, /me just tries it
01:57:23 <moconnor> Syzygy-: I'll poke at that too, thanks
01:59:15 <dons> yeah
01:59:40 <hpaste>  dons pasted "example for moconnor" at http://hpaste.org/303
02:02:43 <sorear> gah, I *hate* concurrency bugs
02:09:13 <moconnor> dons: Thank you, that was exactly what I needed.  It simplified some other stuff too.
02:33:43 <sorear> dons: bah. switching the vty inner loop to StateT (from IORef) actually made it ~10% *slower*
02:38:49 <tuukkah> is there any another way to access packages in hoogle instead of editing the query uri?
02:40:31 <sorear> @tell dons bah. switching the vty inner loop to StateT (from IORef) actually made it ~10% *slower*
02:40:32 <lambdabot> Consider it noted.
02:40:38 <sorear> night.
02:41:31 <Syzygy-> hs-plugins was working in ghc6.6 nowadays, wasn't it?
02:41:46 <hpaste>  flazz pasted "take a look?" at http://hpaste.org/304
02:41:57 <flazz> can someone take a look at that? i'm learning haskell
02:43:32 <astrolabe> flazz: on your last line
02:43:41 <flazz> yes?
02:44:03 <astrolabe> oh, hang on
02:44:11 <flazz> nice pastebin by the way
02:44:39 <astrolabe> flazz: which is line 6?
02:44:50 <flazz> the last one
02:45:47 <astrolabe> I think you want to lose the square bracets round [r:rs]
02:45:53 <flazz> ok
02:46:09 <astrolabe> round replace them with round ones
02:46:34 <pejo> Syz, the code in darcs supposedly does.
02:46:49 <Syzygy-> pejo: hs-plugins from darcs?
02:46:51 <Syzygy-> Good to know.
02:47:14 <Syzygy-> That may end up meaning that my productivity plummets as I play with yaxu's stuff...
02:47:54 <pejo> Syz, would have been even worse if it hadn't been in darcs - then you would have had to do it all yourself!
02:47:59 <flazz> astrolabe: it worked, thanks
02:48:09 <astrolabe> flazz: do you see why?
02:48:35 <flazz> the [] would mean an array of r:rs as opposed to a head:tail
02:48:35 <flazz> ?
02:48:47 <roconnor> > ((+1) `liftM` (+2)) 0
02:48:48 <lambdabot>  3
02:48:52 <flazz> (r:rs) separates it from j instead?
02:49:01 <roconnor> hey, we don't need . afterall
02:49:32 <astrolabe> flazz: [r:rs] means a list containing a single element, that element being a list made of r prepended to rs.
02:49:35 <roconnor> > ((+1) `liftM` (fromEnum)) '0'
02:49:37 <lambdabot>  49
02:49:46 <roconnor> > (+1) `liftM` (fromEnum) $ '0'
02:49:48 <lambdabot>  49
02:49:54 <roconnor> @pl (+1) `liftM` (fromEnum) $ '0'
02:49:54 <lambdabot> fromEnum '0' + 1
02:50:03 <roconnor> right
02:50:11 <flazz> astrolabe: right, thanks
02:54:00 <flazz> is there a way for emacs and hugs to work together?
02:54:10 <flazz> so i dont need a terminal
02:54:20 <xerox> ?go haskell emacs mode
02:54:22 <lambdabot> http://www.haskell.org/haskell-mode/
02:54:22 <lambdabot> Title: Haskell Mode for Emacs
02:54:57 <roconnor> does stdgen on linux use /dev/urandom?
02:55:17 <FZ> xerox: the mode I'm using right now :)
02:55:23 <FZ> after an apt-get install haskell-mode
02:55:34 <flazz> so am i, just noticed
02:56:07 <xerox> (add-hook 'haskell-mode-hook 'turn-on-haskell-hugs) ;I think
03:00:23 <flazz> is there a way to send a haskell buffer to a hugs session? or do i ahve to save and then load from a file?
03:00:30 <xerox> C-c C-l
03:00:58 <flazz> undefined
03:01:10 <brainly-green> did a lot of people just leave and enter
03:01:13 <brainly-green> or was that just me
03:01:16 <astrolabe> xerox: is there a reason that you linked to a page that starts with a link to a latest version?
03:01:25 <astrolabe> brainly-green: just you
03:01:48 <xerox> astrolabe: I joined and saw flazz asking for haskell-mode, I probably jumped into the middle of a conversation?
03:02:00 <astrolabe> xerox: not at all
03:02:24 <astrolabe> I just wondered if the page you linked to was better than the latest version that it links to.
03:04:56 <xerox> astrolabe: I don't think so.
03:05:47 <pejo> flazz, you need to fiddle some with .emacs per hte installation instructions to activate it all, I think.
03:05:57 <flazz> ok
03:06:11 <astrolabe> xerox: thanks
03:06:35 <xerox> You're welcome.
03:09:45 <xerox> What is the title of that Haskell book recently published?
03:10:43 <Syzygy-> WOOOOOOOOOOOOOT!
03:10:46 <Syzygy-> I have hs-plugins!!!
03:11:03 <Heffalump> now get it working with 6.6 :-)
03:11:09 <calvins_> xerox: Programming in Haskell
03:11:36 <calvins_> http://www.cs.nott.ac.uk/~gmh/book.html
03:11:38 <lambdabot> Title: Programming in Haskell
03:11:50 <calvins_> Has anybody here bought that book yet, or looked at it carefully?
03:12:38 <dons> Heffalump: its working with 6.6 now
03:12:38 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:12:40 <Syzygy-> Heffalump: That's it. I have it - on a 6.6 platform.
03:12:44 <dons> well, at least the tessuite runs
03:12:58 * Syzygy- sulks. I have hs-plugins. But it turns out that supercollider won't run natively on amd64. :(
03:13:16 <Syzygy-> And I haven't quite figured out how to get it running as a 32bit app either.
03:15:05 * xerox eagerly darcspulls
03:17:52 <xerox> ?version
03:17:53 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
03:17:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:23:23 <Saizan> ?where hs-plugins
03:23:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
03:24:19 <xerox> calvins_: yes thanks, I found that the wiki has a nice books list.
03:26:27 <augustss> Howdy!
03:27:17 <JKnecht> hey you
03:28:23 <hpaste>  xpika annotated "take a look?" with "matrix fix" at http://hpaste.org/304#a1
03:29:12 <rc-1> why doesnt apt have 6.6?
03:29:41 <Vq^> rc-1: what apt?
03:29:54 <JKnecht> debian I presume
03:30:09 <rc-1> yeah (im on ubuntu but its the same thing)
03:30:20 <rc-1> seems its behind on alot of stuff, just wondering why
03:30:55 <Vq^> isn't the packagerepositories of debian and ubuntu quite different?
03:31:24 <rc-1> Vq^, no idea
03:32:45 <ivanm> From memory, Ubuntu has a few extra packages, and is based on debian-unstable
03:33:47 <pejo> rc-1, debian stable avoids updating programs due to stability concerns. (Better to have a known deficiency in some program that you found out during testing before deployment, rather than upgrading and getting changed behaviour under your feet).
03:34:39 <rc-1> pejo, ah thanks! but ubuntu is from unstable
03:35:35 <pejo> rc-1, hm. Maybe 6.6 came out after your version of Ubuntu was released, and will be in the next version?
03:36:31 <rc-1> pejo, that could be it! i didnt know they couldnt change the repos after a version comes out
03:36:32 <gotaku> 6.6 is in Ubuntu Feisty Fawn.
03:36:39 <rc-1> good :)
03:46:43 <ivanm> Is there an efficiency hit from defining a new type instead of just using a type alias?
03:49:53 <moconnor> Is there any way to turn this: "some_rec {foo=1}" into a function where foo gets passed in?  I.e. I want to do something like:  update r f v = r {f=v} (though, in reality r is coming from a reader monad and I'm calling local, and want my transformation function to just update one field.)
03:50:53 <FZ> rc-1: apt doesn't have 6.6?
03:51:04 <FZ> $ ghc --version
03:51:04 <FZ> The Glorious Glasgow Haskell Compilation System, version 6.6
03:51:10 <FZ> on my Debian system...
03:51:16 <FZ> installed by apt-get
03:52:20 <rc-1> FZ, i just installed in ubuntu edgy eft and
03:52:20 <rc-1> whyso@Andrew:~$ ghc --version
03:52:20 <rc-1> The Glorious Glasgow Haskell Compilation System, version 6.4.2
03:53:15 <FZ> rc-1: sorry, I thought you were using Debian
03:53:57 <rc-1> fz does debian tend to be more up-to-date? if so i might switch
03:54:38 <FZ> rc-1: If you use Debian unstable
03:54:47 <FZ> it is very up to date in many respects
03:54:58 <FZ> that's what I'm using
03:55:04 <FZ> I started with Debian stable release
03:55:14 <FZ> then apt-get dist upgrade
03:55:22 <FZ> upgrading to unstable Debian
03:55:34 <dons> moconnor: foo, the label? no.
03:55:45 <dons> moconnor: so you still need updateF r v = r { f = v }
03:56:05 <dons> labels *aren't* first class values in haskell's current record system (and everyone thinks this is bizarre)
03:57:16 <pejo> dons, any proposals for that for Haskell'?
03:57:59 <gotaku> If I use an accumulator to build a list, can it still be lazy?
03:58:29 <matthew-_> yes
03:59:11 <moconnor> dons: ok, thnk you.
03:59:14 <moconnor> er, thank you
03:59:15 <dons> > unfoldr (Just . random) :: [Int]
03:59:16 <lambdabot>      Expecting a function type, but found `[Int]'
03:59:16 <lambdabot>       Expected type: [Int]
03:59:16 <lambdabot> ...
03:59:21 <xerox> aha
03:59:25 <dons> > unfoldr (Just . random) 42 :: [Int]
03:59:26 <lambdabot>  Add a type signature
03:59:36 <xerox> :t random
03:59:38 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
03:59:48 <xerox> Oh, nice.
04:00:08 <dons> > unfoldr (Just . random) (mkStdGen 42) :: [Int]
04:00:10 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
04:00:21 <ivanm> For a small program, should I create new data types, or should I just leave it as type aliases?
04:00:26 <dons> gotaku: ^^ unfoldr is a good way to build a list, if you can master its powers :)
04:00:48 <dons> ivanm: i create new data types for 20 line programs :)
04:00:55 <dons> but it depends on the complexity of the data
04:00:55 <gotaku> I'll take a look.
04:01:07 * augustss needs to write some new decent RNGs.
04:01:16 <dons> generally though, the cost of creating a new data structure is cheaper in haskell than just about anywhere else
04:01:19 <dons> so go nuts!
04:01:23 <xerox> > unfoldr (Just . randomR (0,1::Int)) (mkStdGen 42)
04:01:25 <lambdabot>  [1,1,1,0,0,1,0,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0...
04:01:31 <xerox> Coooool.
04:01:46 <gotaku> dons: I'm working on my mandelbrot program again... unfortunatly...
04:01:56 <augustss> > unfoldr (Just . random) (mkStdGen 42) :: [Bool]
04:01:57 <lambdabot>  [True,True,True,False,False,True,False,True,False,True,True,True,False,False...
04:02:09 <ivanm> dons: for my Latin Squares, I'm implementing them as  matrices (i.e. [[a]]), and was thinking of using newtype to hide implementation data and implement show directly
04:04:24 <matthew-_> can you not do data declarations for LB?
04:04:34 <matthew-_> > data Giants = Paper | Rock | Scissors; unfoldr (Just . random) (mkStdGen 42) :: [Giants]
04:04:35 <lambdabot>  Parse error
04:04:37 <dons> > map fromEnum (unfoldr (Just . random) (mkStdGen 42) :: [Bool])
04:04:39 <lambdabot>  [1,1,1,0,0,1,0,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0...
04:04:50 <flazz> how can i get Prelude loaded in a hugs session?
04:04:55 <Saizan> matthew-_: no, you can't just as in ghci
04:05:00 <ndm> flazz: just start Hugs, and its already started
04:05:07 <matthew-_> Saizan: ahh, that makes sense I guess
04:05:27 <ndm> flazz: :load Prelude also works
04:05:30 <flazz> i get Hugs.Base
04:05:41 <dons> its loaded by default, :m Prelude though, if you ditched it
04:05:51 <ndm> flazz: which version of Hugs?
04:06:09 <flazz> March 2005
04:06:18 <dons> matthew-_: it could be allowed, though with newtypes you could have the typechecker diverge...
04:06:20 <ndm> flazz: windows or linux?
04:06:21 <resiak> How do I remove a package I installed with Cabal?
04:06:25 <flazz> :l Prelude works
04:06:26 <flazz> linux
04:06:32 <dons> ghc-pkg unregister foo
04:06:37 <resiak> awesome, thanks
04:06:45 <ndm> flazz: upgrade, the newer Hugs is better, and has various bug fixes
04:06:57 <flazz> ok
04:07:05 <flazz> i just cant seem to get toUpper to work
04:07:16 <ndm> flazz: import Data.Char
04:07:34 <flazz> thanks, the yaht didn't say that
04:07:34 <ndm> flazz: toUpper used to be in the Prelude, but now is in either Char or Data.Char (they are roughly the same)
04:07:45 <ndm> flazz: the Yaht that is on the wiki?
04:07:46 <dons> Hugs.Base> :l Data.Char
04:07:46 <dons> Data.Char> toUpper 'x'
04:07:46 <dons> 'X'
04:07:53 <resiak> dons: followed by rming the relevant files?
04:08:01 <dons> resiak: right
04:08:39 <augustss> @src toUpper
04:08:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:09:20 <flazz> my distro only has 2005.3 as the latest hugs version
04:10:40 <pejo> augustss, were you talking about a haskell implementation of rng's?
04:10:51 <augustss> pejo: yes
04:11:42 <augustss> I feel responsible for the not-so-great one that Haskell has now.
04:14:20 <augustss> I have a reference to a rather interesting generator (L'Ecuyer involved again) where you can advance the state of the generator very fast.  That might allow a decent split operation.
04:16:18 <pejo> augustss, responsible as in H98 specification, or wrote the current code in ghc, or something else?
04:16:25 <dcoutts> sjanssen, pong
04:16:52 <augustss> I write the StdGen code a long, long time ago (in LML, then in Haskell).
04:17:02 <augustss> s/write/wrote/
04:17:20 <augustss> I take responsibility for the RNG interface in H98
04:17:25 <augustss> grr
04:17:33 <augustss> s/take/take NO/
04:19:18 <gotaku> What about unfoldr makes it good for building lists?
04:19:45 <augustss> :t unfoldr
04:19:47 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:19:59 <augustss> because it returns a list? :)
04:21:07 <gotaku> augustss: I mean why unfoldr instead of an accumulator?
04:22:03 <pejo> Why doesn't lambdabot respond to :t unfoldr in messages by the way?
04:22:21 <dons> ah, bug, it only knows @type outside of the main channel
04:22:22 <augustss> gotaku: it abstracts a common pattern for building a list.  you give a function that from a b gives you an element of the list and a new b, and you give it a starting b, and off it goes!
04:24:44 <flazz> do the compiled binaries of ghc need a runtime installed?
04:24:54 <dons> its linked statically, so no.
04:25:07 <flazz> are they always linked statically?
04:25:14 <resiak> Hrm.  lambdabot won't build, because Cabal can't find 'network'.  What am I missing?
04:25:32 <dons> you can have them linked dynamically on some architectures
04:25:38 <dons> resiak: the 'network' package, and probably others
04:25:44 <dons> in the 'extralibs' bundle
04:25:51 <dons> get them from apt, if you're on debian
04:25:52 <resiak> that'll be the badger -- thanks.
04:32:44 <gotaku> Does haskell have a way to dump a Word32 to stdout in binary form?
04:39:02 <dcoutts> gotaku, yep. That's exactly what the new binary library does.
04:39:16 <dcoutts> but perhaps you don't want that general a solution
04:39:39 <gotaku> 6.6 new?
04:39:58 <dcoutts> @where binary
04:39:59 <lambdabot> http://darcs.haskell.org/binary
04:40:02 <dcoutts> separate library
04:40:10 <gotaku> Can't use it then.
04:40:18 <dcoutts> why?
04:40:44 <gotaku> I'm working on my old mandelbrot shootout entry.
04:40:51 <dcoutts> ah hmm
04:41:12 <dcoutts> well you can use poke and hPutBuf
04:41:18 <dcoutts> @hoogle hPutBuf
04:41:19 <lambdabot> System.IO.hPutBuf :: Handle -> Ptr a -> Int -> IO ()
04:41:19 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
04:43:09 <ivanm> @pl \ (x,y) -> ((f x) && not (f y)) || ((f y) && not (f x))
04:43:10 <lambdabot> uncurry (ap (ap . ((||) .) . (. (not . f)) . (&&) . f) (flip ((&&) . f) . not . f))
04:43:20 <gotaku> I don't yet know how Ptr works in haskell.
04:43:43 * ivanm finds his original function much easier to read
04:43:46 <AStorm> ivanm, ugly
04:44:08 <AStorm> I'd add: where a = f x; b = f y
04:44:42 <ivanm> AStorm: yeah, I know.  I have a pair of values, and I want exacly one to return true for a Boolean function
04:44:44 <AStorm> Other than that, aren't you emulating an xor?
04:45:03 <ivanm> Hmmm..... now that you meantion it...
04:45:05 <ivanm> @hoogle xor
04:45:06 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
04:45:23 <ivanm> I don't think that's what I want
04:45:27 <AStorm> Mhm.
04:45:42 <AStorm> It's some operator
04:45:51 <ivanm> @hoogle or
04:45:52 <lambdabot> Prelude.or :: [Bool] -> Bool
04:45:53 <lambdabot> Char.ord :: Char -> Int
04:45:53 <lambdabot> GHC.Conc.orElse :: STM a -> STM a -> STM a
04:46:57 <AStorm> No, there isn't one.
04:47:06 <AStorm> Somebody, add it to a library :>
04:47:18 * ivanm agrees
04:47:36 <AStorm> Or...
04:47:38 <AStorm> try /=
04:47:43 <ivanm> OK, I'll implement xor myself then... would a pattern match be best?
04:47:44 <AStorm> f x /= f y
04:47:52 <AStorm> That's almost like an xor
04:47:53 <Syzygy-> ?src or
04:47:53 <ivanm> duh!!!!!
04:47:54 <lambdabot> or    =  foldr (||) False
04:48:15 <Syzygy-> ?src Data.Bits.or
04:48:15 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:48:23 <AStorm> ?src /=
04:48:23 <lambdabot> Source not found. My mind is going. I can feel it.
04:48:26 <AStorm> :P
04:48:33 <AStorm> ?hoogle /=
04:48:33 <Syzygy-> ?src (/=)
04:48:33 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
04:48:34 <lambdabot> x /= y = not (x == y)
04:48:40 <Syzygy-> AStorm: You need the brackets.
04:48:44 <AStorm> Hm.
04:48:51 <AStorm> For hoogle I don't...
04:49:01 <Syzygy-> Nope.
04:49:04 <Syzygy-> But for src you do.
04:49:09 <Syzygy-> ?src (-)
04:49:09 <lambdabot> x - y = x + negate y
04:49:23 <AStorm> ?src negate
04:49:23 <ivanm> ?src (/=)
04:49:24 <lambdabot> negate x = 0 - x
04:49:24 <lambdabot> x /= y = not (x == y)
04:49:40 <AStorm> negate and - are mutually recursively defined :P
04:50:05 <Syzygy-> AStorm: In that way any one of them is a complete definition for both.
04:50:05 <ivanm> So are all the Prelude functions implemented directly into GHC, etc?
04:50:18 <ivanm> Hence why there's no source for them?
04:50:20 <AStorm> Yeah right. Tautologic, defining nothing.
04:50:29 <AStorm> Yes, they are.
04:50:38 <AStorm> ?src map
04:50:39 <lambdabot> map _ []     = []
04:50:39 <lambdabot> map f (x:xs) = f x : map f xs
04:51:15 <AStorm> That's why ghc has to be bootstrapped :>
04:51:20 <ivanm> ?location map
04:51:21 <lambdabot> Unknown command, try @list
04:51:29 <AStorm> ?where map
04:51:30 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:51:30 <ivanm> ?index map
04:51:31 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
04:51:37 <AStorm> :>
04:51:41 <ivanm> lol!
04:52:05 <ivanm> Yeah, but using (f x) /= (f y) works!
04:52:15 <AStorm> It has to.
04:52:25 <AStorm> Because xor is boolean inequality
04:52:30 <ivanm> (I didn't see that originally, as I had defined f and not f as different functions, and was using the two seprately)
04:52:45 <AStorm> I wonder if nor and nand are implemented.
04:52:52 <AStorm> ?hoogle nor
04:52:52 <lambdabot> Network.URI.normalizeCase :: String -> String
04:52:53 <lambdabot> Network.URI.normalizeEscape :: String -> String
04:52:53 <lambdabot> Network.URI.normalizePathSegments :: String -> String
04:52:55 <AStorm> :/
04:52:58 <AStorm> ?hoogle nand
04:52:59 <lambdabot> No matches found
04:53:07 <ivanm> I guess not then ;)
04:53:10 <AStorm> Blah.
04:53:26 <AStorm> Hey, how can I add myself to the map?
04:54:17 <Saizan> is there something like Bool# in ghc?
04:54:19 <AStorm> Aha, just add myself on the wiki
04:54:25 <AStorm> Saizan, and that is?
04:54:34 <Saizan> unboxed Bool
04:54:48 <AStorm> Uh... there's no boxing and unboxing in Haskell.
04:54:57 <AStorm> There is CInt
04:55:03 <AStorm> And maybe CBool?
04:55:15 <AStorm> But these don't give you any advantage.
04:55:36 <Saizan> AStorm: for boxed i mean pointer to "code" in the heap
04:55:58 <Saizan> and for unboxed "machine" values instead
04:56:02 <AStorm> hmm? no pointers in Haskell even :>
04:56:10 <AStorm> Ok, let me think...
04:56:24 <Saizan> Astorm, i'm talking at the core level, after compilation
04:56:25 <norpan> there certainly is boxing in haskell
04:56:29 <AStorm> Boolean is directly unboxed
04:56:47 <AStorm> Integers and such aren't, there are some C types.
04:56:56 <AStorm> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html
04:56:58 <lambdabot> http://tinyurl.com/2x9kwh
04:56:58 <SamB> ???
04:56:59 <ivanm> To add myself to the maps of users, do I need an account for the haskell wiki first?
04:57:24 <norpan> AStorm: i think you are confusing boxing and type representatino
04:57:38 <AStorm> norpan, unconfused myself :P
04:57:46 <AStorm> Boolean is converted to c-- boolean
04:57:51 <norpan> all haskell values are boxed because they may be delayed computations
04:57:55 <AStorm> Which _is_ native.
04:58:11 <AStorm> Some numeric types aren't.
04:58:20 <AStorm> (esp. Integral)
04:58:22 <Saizan> GHC.Float.Double boxed, GHC.Prim.Double# unboxed
04:58:27 <norpan> exactly
04:59:15 <Saizan> so, is GHC.Base.Bool boxed? if yes, what's the relative unboxed?
04:59:53 <AStorm> $!yourbool
05:03:32 <Saizan> uhm, i've seen using  foo !a = ..., do i need an extension for that?
05:05:53 <resiak> Hrm.  ghc6 comes with Data.ByteString, but lambdabot's refusing to build, citing an inability to satisfy its dependency on fps>=0.7.  Am I missing something?
05:08:17 <dons> use the 6.6.cabal file
05:08:18 <xerox> Saizan: yes, bang patterns
05:08:26 <resiak> aha, thanks
05:08:36 <xerox> -fallow-bang-patterns -fbang-patterns I don't remember.
05:08:40 <norpan> big badabang
05:08:42 <dons> -fbang-patterns is the flag, though foo  a = a `seq` ...  also orks
05:08:48 <dons> badaboom!
05:08:59 <norpan> sure, but then it won't end in bang
05:09:52 <xerox> What is that word that express the dual of an analogy?
05:10:03 * matthew-_ loves bang-patterns
05:10:28 <matthew-_> or rather, I like the ability to make things go really fast by unboxing
05:10:36 <gotaku> Ah, what are bang patterns?
05:10:43 <matthew-_> strictness modifiers
05:11:31 <norpan> xerox: what is the dual of an anology anyway
05:11:38 <matthew-_> it can make some of your code look quite odd. Eg given data Vector = Vec !Double !Double !Double I often end up writing f v@(Vec !_ !_ !_) = blah
05:11:46 <norpan> analogy
05:12:17 <xerox> norpan: beats my English vocabulary :-(
05:12:27 <norpan> yes, but explain what it should be
05:13:23 <norpan> a comparison that highlights a dissimilarity?
05:13:30 <xerox> Yes. Even a duality.
05:14:10 <matthew-_> arc-analogy ? ;-)
05:14:31 <norpan> heterology?
05:23:07 <RyanT5000> who are the best professors for languages-related stuff at MIT?
05:23:26 <RyanT5000> i'm in boston for the next 2.5 years, and i'd like to get started on a Ph.D. by the end of that
05:23:43 <RyanT5000> the project would be either a new language with interesting properties or an extension(s) to haskell
05:25:40 <RyanT5000> @help
05:25:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:25:43 <RyanT5000> @list
05:25:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:26:40 <RyanT5000> hm, i guess i hit the dead time of day/night
05:27:41 <RyanT5000> @users
05:27:42 <lambdabot> Maximum users seen in #haskell: 322, currently: 283 (87.9%), active: 35 (12.4%)
05:28:04 <nmessenger> RyanT5000: I'm not exactly a guru, but did you want to know something?
05:28:16 <gotaku> http://www.haskell.org/haskellwiki/List_comprehension
05:28:18 <lambdabot> Title: List comprehension - HaskellWiki
05:28:19 <gotaku> How informative...
05:28:36 <RyanT5000> lol
05:28:47 * nmessenger echoes 'lol'
05:28:54 <RyanT5000> i've always hated those things anyway
05:29:07 <RyanT5000> i guess i'm a programming languages diabetic
05:29:39 <nmessenger> ?remember RyanT5000 [on syntax sugar] i guess i'm a programming languages diabetic
05:29:39 <lambdabot> Done.
05:29:47 <RyanT5000> :)
05:29:54 <nmessenger> @ryansnack
05:29:55 <lambdabot> Unknown command, try @list
05:30:02 <nmessenger> @botsnack
05:30:03 <lambdabot> :)
05:30:08 <RyanT5000> lol
05:31:19 * roconnor wonders who wrote http://paste.lisp.org/display/36311
05:31:50 <nmessenger> "Pasted by: eq"
05:31:50 <RyanT5000> lol nice
05:31:57 <nmessenger> ?seen eq
05:31:57 <lambdabot> I haven't seen eq.
05:32:18 <RyanT5000> that's pretty sweet; now it just needs an "emit" function
05:32:22 <roconnor> nmessenger: I didn't find anything in the #haskell log
05:32:55 <pbx> N00b alert
05:33:04 <xerox> nmessenger: that's from the last TMR it seems
05:33:07 <nmessenger> n00bs!
05:33:09 <pbx> How do I concatenate a list of strings into a single string?
05:33:15 <nmessenger> @type concat
05:33:15 <roconnor> It seems like an improvement over my work
05:33:17 <lambdabot> forall a. [[a]] -> [a]
05:33:32 <nmessenger> > concat ["blah", "barf", "foo"]
05:33:33 <lambdabot>  "blahbarffoo"
05:33:40 <xerox> Oh!
05:33:44 <RyanT5000> anyone have any comment on my MIT professor question?
05:33:47 <pbx> Thanks!
05:33:57 <RyanT5000> [in short, i'm in boston, want to start prog lang ph.d.]
05:34:10 <nmessenger> RyanT5000: sorry, I know nothing of MIT :/
05:34:16 <RyanT5000> :(
05:34:19 <roconnor> xerox: I was thinking that I might be able to somehow use the list length itself to keep track of the number of instructions
05:34:38 <antoine> hi there. newbie question. say I have x :: Integer. I want to get the floor of logBase 2 x. I'm not sure to understand yet the whole numeric classes thing ...
05:34:39 <roconnor> xerox: the use of ++ in the bind function worries me
05:34:47 <RyanT5000> i know lots of you are international, but when it comes to programming languages stuff, i trust this chatroom more than about anything else
05:34:48 <pbx> BTW nmessenger, I think you commented on my blog recently. I fixed that Markdown problem :)
05:34:52 <roconnor>         (>>=) cur f = Asm (\pos -> let
05:34:52 <roconnor>                 (res,coms) = runAsm cur pos
05:34:52 <roconnor>                 npos = pos+length coms
05:34:52 <roconnor>                 (res',coms2) = runAsm (f res) npos
05:34:52 <roconnor>                 in (res',coms++coms2)
05:34:52 <roconnor>                 )
05:34:54 <xerox> roconnor: yeah
05:35:00 <roconnor> Is that bad?
05:35:10 <nmessenger> pbx: aye, I did.  Glad to see you've dived into Haskell.
05:35:11 <roconnor> it seems like it would be quadratic in the instruction count
05:35:25 <roconnor> but you can never tell with Haskell. ... at least not easily ;)
05:35:38 <nmessenger> pbx: I'm the nut who wrote the 'reverse' thing in False 8)
05:35:39 <xerox> roconnor: tried profiling?
05:35:41 <roconnor> I probably have the same problem in my code.
05:36:01 <roconnor> I've never worked with assembly long enough to notice a problem
05:36:09 <roconnor> it was always a toy solution
05:36:18 * pbx backs slowly away
05:36:56 <gotaku> The release candidate of gtk2hs is out.
05:37:53 <tuukkah> i'm a bit lost with ActionGroup. i'm trying to translate from my Python code, but there's no accelGroupNew, the label in actionNew is not in Maybe, ActionEntry is not exported
05:37:53 <nmessenger> Though codegolf does seem rather limited on language choice.
05:37:59 <roconnor> I also wonder why google blog search indexes paste.lisp.org
05:38:03 <roconnor> that seemed weird
05:38:07 <roconnor> thats how I found this paste
05:38:23 <RyanT5000> simple: google is all-knowing
05:38:35 <roconnor> crazy
05:38:37 <RyanT5000> lol
05:38:39 <nmessenger> roconnor: GoogleBot is *everywhere*, * spooky music *
05:40:02 <pbx> nmessenger: Did you see this yet?   http://shinh.org:81/
05:40:03 <lambdabot> Title: anarchy golf
05:40:31 <nmessenger> "99 shinichiroes of hamaji" :D
05:40:53 <pbx> I did that one in Haskell! I was so proud.
05:41:07 * nmessenger pats pbx on back
05:41:42 <gotaku> pbx, what is it?
05:42:34 <nmessenger> "99 bottles of beer" s/bottles/shinichiroes/ s/beer/hamaji/
05:42:55 <pbx> gotaku: It's a codegolfing competition. You submit the shortest program you can that passes a certain set of tests. It's an old Perl tradition I guess but this one supports 30+ languages.
05:45:21 <nmessenger> the 'echo' problem (http://shinh.org:81/p.rb?echo) would be *perfect* for Lazy K, the empty source file would pass!
05:45:22 <lambdabot> Title: anarchy golf - echo
05:45:45 <nmessenger> Can't get much smaller :-}
05:45:47 <xerox> roconnor: that's because it has got RSS feeds of pastes
05:45:47 <gotaku> Can you view the entries somehow?
05:46:33 <pbx> gotaku: Nope.  I don't think he even stores them.
05:47:02 <roconnor> ah
05:47:10 <gotaku> pbx: So what's the point?
05:47:16 <nmessenger> :/  That seems logical for the competition, but it makes me sad.
05:47:46 <pbx> gotaku: What nmessenger said.
05:48:52 <gotaku> How is size determined?
05:49:38 <pbx> gotaku: Bytes, including whitespace
05:50:24 <gotaku> In that case I don't think I want to see the source code anyway.
05:50:36 <pbx> Indeed!
05:51:15 <nmessenger> 'main=interact$unlines.filter(/=[]).lines' (40 bytes) http://shinh.org:81/p.rb?delete+blank+lines
05:51:17 <lambdabot> Title: anarchy golf - delete blank lines
05:52:03 <nmessenger> readable, still
05:53:04 <beelsebob> Igloo: oops, helps if someone doesn't trip over the power cord in the middle of the night
05:54:04 <Igloo> beelsebob: heh
05:55:12 <roconnor> OMG, I can use GTK at the same time I use GHCi
05:55:26 * roconnor feels like he's in a python interpreter
05:55:30 <RyanT5000> lol
05:55:45 <xerox> roconnor: OS X?
05:55:53 <RyanT5000> i've run my (relatively simple) 3d engine in ghci
05:55:55 <roconnor> Ubuntu
05:56:09 <roconnor> I've never played with Gtk before
05:56:21 <roconnor> I didn't think it would play well with GHCi
05:56:35 <RyanT5000> yeah... ghci is pretty awesome that way
05:56:39 <dcoutts> tuukkah, I must admit I've never used the action group stuff. If you think there's anything missing do email the gtk2hs-devel list.
05:56:49 <roconnor> Actually, I'm not using Gtk directly, I'm using that nifty Haskell charting library
05:56:59 <roconnor> This is WAY better than Gnuplot :)
05:57:09 <xerox> roconnor: interesting!
05:57:44 <roconnor> I just make a plot of brownen(sp?) motion
05:57:54 <roconnor> from the GHCi command line
05:58:08 <dcoutts> roconnor, hmm, that's a nice example, we should write it up for the gtk2hs webite with some screenshots and instructions.
05:58:47 <roconnor> well, I'm pushing the bounds as to what is aceptable on the command line, but I do get to explore and play.
05:58:47 <dcoutts> people are doing lots of cool stuff with gtk2hs but that's not very well reflected on the website yet I think
05:59:53 <roconnor> boy these charts are pretty
06:00:06 * dcoutts want's screenshots!
06:00:07 <roconnor> cairo is a lot nicer looking that gnuplot ;)
06:00:45 <roconnor> dcoutts, presumably you've seen http://dockerz.net/software/chart.png
06:01:22 <dcoutts> roconnor, yeah, but I want something for the website like this:
06:01:23 <dcoutts> http://haskell.org/gtk2hs/archives/category/screenshots/
06:01:24 <lambdabot> Title: Gtk2Hs » Screenshots
06:01:56 <dcoutts> ie a couple pics and some explanation / demo / tutorial
06:02:09 <dcoutts> just to show off stuff really
06:02:33 * dcoutts begs roconnor to write something for us
06:03:21 <roconnor> well, I'll see what I can do
06:03:26 <dcoutts> yay
06:03:35 <roconnor> But I won't do anything until I figure out what I am doing
06:03:43 <dcoutts> ok :-)
06:04:02 <dcoutts> an email with a couple pics and some description would be prefect, I'll format it for the website
06:05:35 <hpaste>  roconnor pasted "my first chart" at http://hpaste.org/305
06:06:10 <xerox> roconnor: www.imageshack.us
06:06:16 <roconnor> ah, my chart was tuncated
06:07:25 <nmessenger> roconnor: er, why don't you use imageshack or something for images?
06:07:36 <roconnor> http://img206.imageshack.us/my.php?image=test2aw3.png
06:07:37 <lambdabot> Title: ImageShack - Hosting :: test2aw3.png
06:07:48 <roconnor> nmessenger: I wasn't exactly aware of imageshack
06:08:23 <nmessenger> Cool.  Copy/pasting a data url is just a little awkward.
06:08:52 <roconnor> nmessenger: and hpaste didn't like my large amount of data
06:09:20 <roconnor> I had better paste how to make that chart
06:09:25 <nmessenger> perhaps I should have said "You could use" instead of "Why don't you use"
06:12:34 <hpaste>  roconnor annotated "my first chart" with "ghci source" at http://hpaste.org/305#a1
06:13:08 <roconnor> so 7 lines of code
06:13:15 <roconnor> half are loading modules
06:13:24 <roconnor> and er, one is really really long
06:13:35 <roconnor> probably should be broken up
06:18:23 <Saizan> roconnor, you forgot a "let"
06:18:39 <roconnor> oh, where?
06:19:09 <Saizan> 2nd line, should be let bits = .., right?
06:19:14 <roconnor> nope
06:19:17 <roconnor> I use <-
06:19:42 <roconnor> to convert IO [Bool] to [Bool]
06:19:46 <roconnor> ``convert''
06:19:48 <Saizan> well, but it floods ghci output..
06:20:01 <roconnor> it does?
06:20:03 <roconnor> not for me
06:20:21 <xerox> x <- amb; return () ?
06:20:29 <roconnor> GHC Interactive, version 6.4.1, for Haskell 98.
06:20:49 <Saizan> i've 6.6, maybe it's that
06:24:22 <Igloo> -fno-print-bind-result turns that off
06:27:17 <roconnor> this is totally going to replace gnuplot
06:27:35 <roconnor> you have all of haskell at your disposal
06:28:09 <roconnor> and it looks better
06:36:32 <matthew-_> mmm. need to be able to call that from inside latex
06:36:46 <matthew-_> have it generate a pdf and then include that back in the latex
06:36:53 <matthew-_> then it'd be *really* cool ;)
06:44:55 <Cope> hello - i'm trying to get my head around FP as a method - am trying to write pseudo code for a letter frequency counter by using a map() that generates a list of pairs, eg hello -> (h,1), (e,1), (l,1), (l,1), (o,1); and then a reduce which will ultimately give a frequency table.  I have no experience in anything other than python, so am really just trying to get my head around it.  A friend recommended haskell programmers (and indeed haskell language) as a
06:45:03 <Cope> Can you help? :)
06:45:45 <Cope> the frequency counter is just my idea of something i know how to do imperatively... any other example would be fine - that's just what I had in my mind - the objective is just to start thinging functionally.
06:46:32 <Saizan> have you a specific problem?
06:48:02 <Lemmih> > map (head &&& length) . group . sort $ "hello world"
06:48:03 <lambdabot>  [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
06:48:53 <Cope> Saizan: do you mean do I have a specific problem in understanding? Or a specific problem I wish to solve?
06:49:28 * allbery_b is not sure using an arrow is quite the right response there
06:49:32 <Saizan> a specific problem in understanding the problem you are wishing to solve
06:49:40 <allbery_b> (then again I contemplated a liftM2 :)
06:50:10 <Cope> well, the reason for learning FP is that I may have to start looking into using mapreduce as a  methodology for some hefty data processing
06:50:15 <ookk> is wxhaskell available for intel macs?
06:50:19 <Lemmih> allbery_b: Arrows work great for showing off.
06:50:27 <allbery_b> > map (\l -> (head l, length l)) . group . sort $ "hello world"
06:50:29 <lambdabot>  [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
06:50:30 <kowey> ookk: the darcs version of wxhaskell runs on my intel Mac
06:50:43 <Cope> and as I understand it one of the key points is that FP is highly parallelisable
06:50:46 <Cope> because state doesn't change
06:50:51 <allbery_b> the slightly more non-expert-friendly version
06:50:51 <Cope> so things can be done in any order
06:50:53 <Cope> is that right?
06:50:57 <Saizan> right
06:51:03 <nmessenger> (\l -> (head l, length l)) = (head && length) in the (->) Arrow
06:51:08 <Philippa> rightish
06:51:14 <Philippa> it's not quite as good as it sounds
06:51:21 <nmessenger> s/&&/&&&/
06:51:34 <Cope> so what I wanted to do was... Philippa? Oooh, yes, I'd forgotten you are a haskeller.
06:51:38 <Cope> :D
06:51:39 <ookk> kowey, is it stable?
06:51:56 <michaelw> Cope: the gph crowd and other did not produce concrete evidence for that claim so far. (I am not blaming them, it's a hard problem)
06:52:02 <Lemmih> > M.toList $ M.fromListWith (+) [ (c, 1) | c <- "hello world" ]
06:52:04 <lambdabot>  [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
06:52:06 <kowey> ookk: i haven't used it much, but I have no reason to believe it would be unstable
06:52:29 <Philippa> Cope: what is true is that the lack of state makes it a lot easier to write explicitly concurrent code
06:52:34 <Cope> what I wanted to do was come up with a really basic problem that I could use to understand how to solve a problem functionally rather than imperatively
06:53:44 <nmessenger> Cope: your problem is easily fixable with library functions, though.  First the list is sorted, grouped into lists of equal elements, then each list is transformed into a (first element, length of list) pair
06:54:05 <nmessenger> > group . sort $ "hello world"
06:54:07 <lambdabot>  [" ","d","e","h","lll","oo","r","w"]
06:54:22 <nmessenger> > (head &&& length) . group . sort $ "hello world"
06:54:23 <lambdabot>  (" ",8)
06:54:28 <nmessenger> > map (head &&& length) . group . sort $ "hello world"
06:54:30 <lambdabot>  [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
06:54:50 <Cope> could you explain what group . sort $ means?
06:54:58 <Cope> which function comes first?
06:55:09 <nmessenger> group . sort = \xs -> group (sort xs)
06:55:21 <nmessenger> sort is first
06:55:23 <Cope> does "hello world" get sorted first? into alphabetical order?
06:55:30 <Saizan> yes
06:55:34 <Cope> right... so how would one write a sort routine, functionally?
06:55:35 <LoganCapaldo> f $ g x y = f (g x y)
06:55:40 <Philippa> into charset order, strictly speaking
06:55:47 <Saizan> ?src sort
06:55:47 <lambdabot> sort = sortBy compare
06:55:48 <Cope> I am trying to understand the actual methodology
06:55:52 <Philippa> :-)
06:55:56 <Saizan> ?src sortBy
06:55:57 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
06:56:04 <Philippa> Cope: there's an infamous two line quicksort. You don't want to use it
06:56:18 <LoganCapaldo> But its so pretty looking :)
06:56:20 <Cope> i could write a sort routine in python, but again, it would involve loops and side effects
06:56:27 <Saizan> ?src insertBy
06:56:28 <lambdabot> insertBy _   x [] = [x]
06:56:28 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
06:56:28 <lambdabot>                                  GT -> y : insertBy cmp x ys'
06:56:28 <lambdabot>                                  _  -> x : ys
06:57:01 <nmessenger> getting a sorted copy of a list, group equals, finding head and length are all things that can be done by pure data mashing without side effects.  Haskell encourages you to code this way by making it the easiest way.
06:57:18 <nmessenger> @src sort
06:57:18 <lambdabot> sort = sortBy compare
06:57:24 <nmessenger> @src sortBy
06:57:25 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
06:57:45 <nmessenger> @src insertBy
06:57:45 <lambdabot> insertBy _   x [] = [x]
06:57:46 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
06:57:46 <lambdabot>                                  GT -> y : insertBy cmp x ys'
06:57:46 <lambdabot>                                  _  -> x : ys
06:57:50 <nmessenger> @src foldr
06:57:51 <lambdabot> foldr k z xs = go xs
06:57:51 <lambdabot>     where go []     = z
06:57:51 <lambdabot>           go (y:ys) = y `k` go ys
06:57:53 <Saizan> basically you compose functions, rather than routing around datas
06:58:33 <gotaku> When should a Reader monad be used instead of State?
06:58:42 <Philippa> gotaku: when you can
06:58:43 <LoganCapaldo> fyi, the sort that you don't want to use is sort [] = []; sort (x:xs) = sort [ y | y <- xs, y < x] ++ [x] ++ sort [ w | w <- xs, w >= x ]
06:59:25 <gotaku> Philippa: What is the reason to use a Reader instead of State?
06:59:43 <Philippa> it has more specific invariants, so it prevents more possible errors
07:00:02 <nmessenger> Reader represts something that can 'ask', State is something that can 'get' and 'put'.
07:00:15 <nmessenger> represts?!  represents even. o.O
07:01:05 <LoganCapaldo> Help, I'm being represt!
07:01:16 <michaelw> gotaku: if your state modifications should be bounded in time (dynamic extent), you can use the Reader monad
07:01:19 <LoganCapaldo> Now we see the violence inherent in the system :)
07:02:05 * nmessenger hits LoganCapaldo with a large irrefutable pattern
07:02:06 <jlouis> gotaku, also, by using a Reader rather than a State you make the intent clear to a reader of the program. You can't shove something into a Reader
07:02:24 <kowey> Cope: has this been helpful so far?
07:03:02 <nmessenger> Cope: how much Haskell have you done? Have you read any tutorials?
07:03:47 <Cope> I've not done any haskell yet - have just begun reading, so am at the level of ideas at present?  Perhaps I need to get my hands dirty first!
07:04:06 <nmessenger> ?wiki Haskell_in_5_steps
07:04:07 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
07:04:13 <nmessenger> ^^ is the best place to start
07:04:41 * Cope looks.
07:05:21 <TomMD> @where yaht
07:05:21 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
07:05:24 <nmessenger> you might also play with lambdabot
07:05:26 <TomMD> I like that one
07:05:27 <kowey> Cope: there's a couple of things going on in the answers so far (in case i'm not beind redundant)
07:05:29 <nmessenger> ?protontorpedo
07:05:30 <lambdabot> is haskell doomed to be a mysql driver?
07:05:58 <pbx> Cope: And never read anything that comes after the name "protontorpedo"
07:06:25 <nmessenger> @quote one.line.replacement
07:06:26 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
07:06:26 <lambdabot> for your entire program.")
07:06:33 <kowey> Cope: One thing you'll see in FP alot is, instead of doing loops, transforming lists into other lists
07:06:35 <Lemmih> Cope: Listen to the wisdom of keal instead.
07:06:39 <nmessenger> 8-)
07:06:43 <TomMD> ?quote keal
07:06:44 <lambdabot> No quotes match. I've seen penguins that can type better than that.
07:06:53 <Lemmih> ?keal
07:06:54 <lambdabot> how do i search for someone saying 'Keal' in mirc
07:06:55 <Cope> kowey: yes... i was playing with this on paper last night
07:07:19 <Cope> btw do I want hugs or ghc?
07:07:50 <nmessenger> GHC has IMO more informative error messages, but is larger.
07:07:54 <kowey> Cope: so that's what this group, sort, business is about... instead of looping, we just build intermediate lists, first a sorted one, and then a grouped one of that
07:07:55 <TomMD> Cope:GHC gives better error messages now, imo.  Also, GHC is what people use who want their programs to actually do a task (and aren't just learning).
07:08:29 <nmessenger> Hugs is an interpreter, GHC is a compiler, but comes with an interpreter
07:08:39 <kowey> Cope: the other thing that happens is that we tend to 'compose' functions together (which is why you saw stuff like group.sort)
07:08:53 <kowey> Cope: but i think that's less important to learn about for now than the lots-of-intermediate-lists idea
07:09:02 <Cope> kowey: right - I began to realise this last night.  It felt a bit like unix pipelines... passing things along.
07:09:13 <nmessenger> Aye!  Very similar.
07:09:23 <kowey> Cope: i think you'll do just fine :-)
07:10:05 <Cope> so where it is a little above my head is that the library functions are the sorts of things I think would be ideal ways to learn how to solve a problem functionally!
07:10:17 <Cope> eg your sort function
07:10:20 <Cope> or your group function
07:10:55 <kowey> Cope: it's a good exercise to try to  figure out how to implement those functions... it'll get you used to recursion
07:11:01 <kowey> Cope: but what do you mean exactly?
07:11:02 <nmessenger> http://www.haskell.org/onlinereport/standard-prelude.html
07:11:04 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
07:11:04 <Cope> > sort $ "wibble"
07:11:06 <lambdabot>  "bbeilw"
07:11:45 <nmessenger> ($) is just a convenience function for omitting parens
07:11:57 <Philippa> > sort "wibble"
07:11:59 <lambdabot>  "bbeilw"
07:12:45 <Cope> kowey: well... what I think I want to achieve is a simple program that demonstrates this intermediate lists idea, and ideally one which demonstrates that things could be farmed out, as the initial driver of this is needing to understand MapReduce as a distributed processing model.
07:13:01 <Cope> (ghc installing)
07:13:13 <TomMD> Version 6.6?
07:13:20 * Cope nods.
07:13:33 <Cope> ?group
07:13:34 <lambdabot> Unknown command, try @list
07:13:49 <Cope> group "beer"
07:13:56 <Cope> aha
07:13:58 <Philippa> Cope: you'll find an awful lot of things that can be written as either maps or folds (fold being what we call reduce)
07:14:06 <kowey> > group "beer"
07:14:07 <lambdabot>  ["b","ee","r"]
07:14:23 <kowey> > group "beerbeer"
07:14:24 <lambdabot>  ["b","ee","r","b","ee","r"]
07:14:33 <Cope> > group 12345
07:14:34 <lambdabot>   add an instance declaration for (Num [a])
07:14:49 <nmessenger> @type group
07:14:51 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
07:14:54 <nmessenger> operates on lists only
07:15:06 <nmessenger> that's the '[a] ->' part
07:15:08 <Cope> > group (1,2,3,4,5)
07:15:09 <lambdabot>  Couldn't match `[a]' against `(a1, b, c, d, e)'
07:15:19 <nmessenger> > group [1,2,3,4,5]
07:15:21 <lambdabot>  [[1],[2],[3],[4],[5]]
07:15:22 <allbery_b> list is [], not ()
07:15:32 <kowey> Cope: one difference with Python is that tuples and lists aren't the same thing
07:15:40 * kowey hopes he didn't get his Python wrong
07:15:47 <Cope> right, tuples are immutable
07:15:54 <Philippa> no
07:15:58 <Philippa> that's not the difference
07:16:04 <pbx> The big diff in Haskell is that different length tuples are different types
07:16:19 <nmessenger> (well, *everything*'s immutable is Haskell :P)
07:16:20 <nmessenger> in*
07:16:21 <Philippa> and lists're homogenous - they only contain values of one type
07:16:39 <Philippa> you can have (Int, String), but only [Int] or [String]
07:16:45 <nmessenger> though that's not a *terrible* restriction.
07:16:48 <roconnor> [Either Int String]
07:16:49 <Cope> could you clarify the term "type"?
07:16:50 <pbx> FWIW this corresponds very closely to actual usage in Python, though it's not enforced.
07:16:54 <nmessenger> > [Left 1, Right "foo"]
07:16:55 <lambdabot>  [Left 1,Right "foo"]
07:16:57 <nmessenger> @type [Left 1, Right "foo"]
07:17:00 <lambdabot> forall a. (Num a) => [Either a [Char]]
07:17:10 <Philippa> Cope: what other languages have you used?
07:17:30 <Cope> plenty of python and shell; very small amount of ruby
07:17:39 <Philippa> so no other statically-typed languages. Ah.
07:17:52 <Philippa> If you have an Int and a Float in Haskell, you can't multiply them
07:17:55 <pbx> Cope: Before somebody makes your head explode, let me just interject as a fellow n00b that types are a very big deal in Haskell. One of the coolest and most unusual things. Unless you've used another related language like ML you've probably never seen anything like them.
07:17:59 <Philippa> not only that, but you can't even compile the code that tries to do it
07:18:07 <LoganCapaldo> shell is statically typed. Everything is either  a file or a string :)
07:18:15 <nmessenger> Haskell's type system is a challenge, but stick with it, there's some cool stuff in there.
07:18:24 <Philippa> and it catches mistakes all over the place
07:18:26 <gotaku> I'm still trying to wrap my brain around haskell types.
07:18:38 <Philippa> I have two classes of bug that takes hours or longer to catch
07:18:40 <Cope> like ocaml - compile time type checking
07:18:54 <Philippa> the first is problems that stumped the original researchers who first did what I'm doing for a fair while...
07:19:13 <Philippa> and the second is cases where the type system doesn't have quite enough info and thus can't spot the blatantly stupid thing I've done by accident
07:19:39 <Philippa> "compile time" is an implementation artefact - but yes, you can check the types without running the code
07:19:54 <Philippa> and indeed they have to've been checked to know you have a valid Haskell program
07:20:11 <Cope> alright! I have ghci running
07:20:27 <Cope> this is an interpreter, not unlike python's? or irb?
07:20:39 <zarvok> Cope: yep
07:20:41 <Cope> nice
07:20:44 <pbx> Yeah.
07:20:45 <nmessenger> datatypes, type aliases, "newtypes", classes of types, higher-kinded-types, existential types, etc. etc.
07:20:50 <LoganCapaldo> yeah ghci : ghc :: irb : ruby
07:21:43 <pbx> Cope: in ghci typing ":t " in front of a piece of data will tell you its type, if you want to play around with that.
07:21:48 <Cope> ok, now am i right in thinking that i can't set things equal to things? what's that called... um... assignment
07:21:52 <nmessenger> Cope: one way to get started is ':browse Prelude', that'll list the Prelude.  There's a lot of functions in there.
07:22:00 <Cope> so I can't do: list = "word"
07:22:08 <pbx> Cope: let list = "word"
07:22:09 <Philippa> nmessenger: in fairness higher-kinded types're something you don't even notice until you realise that there're type systems that don't have them
07:22:28 <Cope> ah ok
07:22:29 <LoganCapaldo> You can do list = "word" but you can't do list = "word2" later
07:22:50 <Cope> ok... so like constants in ruby
07:22:58 <nmessenger> LoganCapaldo: well, you can, but that just introduces a new 'list' name that hides the first.
07:23:04 <LoganCapaldo> nmessenger, shh!
07:23:06 <LoganCapaldo> ;)
07:23:08 <nmessenger> :P
07:23:14 <pbx> LoganCapaldo: You can't do that without "let" in ghci unless I missed something
07:23:29 <kowey> Cope: one tricky thing is that what you can write in ghci is different from what you would type in a source file
07:23:34 <nmessenger> > let x = 1 in let x = 2 in x
07:23:35 <lambdabot>  2
07:23:45 <kowey> Cope: it sounds outrageous at first, but it'll make more sense later on
07:24:15 <kowey> Cope: so for large enough examples, you're best of just saving to a file and loading that from  ghci (or compiling it with ghc)
07:24:15 <Cope> ok, so I have let scores = [75, 50, 25, 80]
07:24:28 <Cope> suppose i wanted to sort that list.
07:24:33 <Philippa> and I'd say "large enough" is anything more than a one-liner
07:24:37 <Cope> using, eg, a bubble algorithm
07:24:37 <nmessenger> type 'sort scores'
07:24:48 <Philippa> > let scores = [75, 50, 25, 80] in sort scores
07:24:49 <lambdabot>  [25,50,75,80]
07:24:54 <Philippa> ...you don't want to bubblesort :-)
07:24:58 <nmessenger> er, ':m + Data.List' first to import the 'sort' function
07:25:02 <Cope> sure... but suppose *I* want to sort it... to understand recursion etc
07:25:11 <Philippa> really, bubblesort's pretty unnatural in Haskell
07:25:16 <Philippa> and not in the fun way
07:25:21 <AStorm> merge sort looks nice
07:25:23 <Cope> oh, ok, well... any other sort
07:25:23 <nmessenger> @google quicksort in haskell
07:25:26 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
07:25:27 <lambdabot> Title: Introduction - HaskellWiki
07:25:31 <LoganCapaldo> I suspect bubble sort is even harder to write in haskell than an easier sort
07:25:46 <Philippa> sort [] = [] -- sorting an empty list gives you an empty list
07:25:50 <LoganCapaldo> Maybe you want to try an insertion sort
07:26:04 <LoganCapaldo> s/easier/better/
07:26:04 <AStorm> LoganCapaldo, that'd also be unnatural in Haskell, but... :>
07:26:05 <Philippa> sort (x:xs) = ... -- sorting a list consisting of an item x followed by a remaining list xs
07:26:12 <LoganCapaldo> brain fried
07:26:37 <AStorm> The best looking in Haskell are merge sort and quicksort
07:26:39 <nmessenger> sort (x:xs) = sort (filter (<x) xs) ++ [x] ++ sort (filter (>=x) xs) -- items less than 'x', followed by 'x', followed by items greater than 'x'
07:26:55 <AStorm> nmessenger, n^2
07:27:11 <nmessenger> AStorm: yeah, but good for learning anyway
07:27:14 <AStorm> Don't use filter.
07:27:22 <AStorm> Just sort xs
07:27:29 <nmessenger> partition maybe?
07:27:33 <AStorm> Yes, partition.
07:27:56 <AStorm> That'd be quicksort
07:28:11 <AStorm> Merge sort would look rather more like splitting the list in two
07:28:59 <nmessenger> sort (x:xs) = lessers ++ [x] ++ greaters where (lessers,greaters) = partition (<x) xs
07:29:01 <Vq^> mergesort seems more natural since it's harder to do inplace sort on a haskell-list (or have i got this wrong?)
07:29:03 <pbx> The point of that quicksort algorithm has nothing to do with performance -- it's just a pretty demo of Haskell concision and expressiveness, right?
07:29:08 <LoganCapaldo> sort [] xs = xs; sort (x:xs) ys = sort xs (insert x ys) where insert x [] = [x]; insert x (y:ys) = if x < y then (x:y:ys) else y:(insert x ys)
07:29:40 <LoganCapaldo> doesn't seem so unnatural to me
07:29:47 <Philippa> Vq^: in-place quicksort's a special case, it was discovered after quicksort itself IIRC
07:30:04 <AStorm> Anyway, quicksort is slower :P
07:30:46 <roconnor> Oh, this is were I'm supposed to say that quicksort is a bad haskell demo
07:30:52 <roconnor> quicksort is really tree sort
07:31:06 <kowey> Cope: so far so good? I think LoganCapaldo's sort is a good thing to start with
07:31:13 <Vq^> Philippa: i see
07:31:27 <LoganCapaldo> Cope, just realize mine has to be done like sort scores []
07:31:36 <LoganCapaldo> it needs a place to hold on what its doing
07:31:38 <kowey> Cope: you can start by defining a function 'insert' to stick an element x into a sorted list
07:31:48 <Philippa> or you call your sort sort' and sort xs = sort' xs []
07:32:21 <Cope> do i need to almost read back to front?
07:32:49 <kowey> Cope: are you saying that because i talked about starting with insert? or something else?
07:33:04 <Cope> because a few examples have seemed like I start at the right and think left
07:33:13 <Cope> > sort . group $ "wibble"
07:33:14 <lambdabot>  ["bb","e","i","l","w"]
07:33:38 <nmessenger> Cope: usually you do, since function arguments are to the right
07:34:03 <nmessenger> > sort (group "wibble") -- with fewer crazy-looking operators
07:34:05 <lambdabot>  ["bb","e","i","l","w"]
07:34:14 <AStorm> > sort "nmessenger"
07:34:16 <lambdabot>  "eeegmnnrss"
07:34:24 <AStorm> Looks much better.
07:34:31 <nmessenger> > sort "AStorm"
07:34:32 <kowey> Cope: think in English! 'sort the result of grouping "wibble"'
07:34:33 <lambdabot>  "ASmort"
07:34:38 <nmessenger> ASmort!
07:34:40 <AStorm> :P
07:35:13 <kowey> (well, in English without the word 'then')
07:35:44 <Cope> LoganCapaldo's sort looks pretty involved... so the first step is an insert
07:35:51 <AStorm> > sort "haskell"
07:35:53 <lambdabot>  "aehklls"
07:35:53 <Cope> so the input is a list: "hello"
07:36:04 <kowey> it only looks that way because of the stuff he  did to cram it all on one line
07:36:08 <nmessenger> yep, type String = [Char]
07:36:25 <nmessenger> "list of Char"
07:36:34 <AStorm> haskell sorted = aeh[, it] klls!
07:36:39 <Cope> the output is what? 'h', 'e', 'l', 'l', 'o'?
07:36:46 <nmessenger> AStorm: !!
07:37:01 <nmessenger> > ['h','e','l','l','o']
07:37:02 <lambdabot>  "hello"
07:37:03 <spiffy> > 'h':'e':'l':'l':'o':[]
07:37:05 <lambdabot>  "hello"
07:37:13 <kowey> these three are all the same thing
07:37:17 <spiffy> nmessenger: beat me to it :P
07:37:32 <nmessenger> spiffy: I was going to do the (:) form anyway :D
07:37:58 <AStorm> > 'h' cons 'e' cons 'l' cons 'l' cons 'o'
07:37:59 <lambdabot>   Not in scope: `cons'
07:38:01 <nmessenger> just different syntaxes for precisely the same list
07:38:04 <AStorm> whoops
07:38:13 <nmessenger> let cons = (:) in ... `cons` ...
07:38:14 <AStorm> > 'h' `cons` 'e' `cons` 'l' `cons` 'l' `cons` 'o'
07:38:15 <lambdabot>   Not in scope: `cons'
07:38:26 <AStorm> > 'h' `L.cons` 'e' `L.cons` 'l' `L.cons` 'l' `L.cons` 'o'
07:38:27 <lambdabot>   Not in scope: `L.cons'
07:38:32 <AStorm> Blah.
07:38:35 <nmessenger> ?let cons = (:)
07:38:36 <lambdabot> Defined.
07:38:39 <AStorm> > 'h' `L.cons` 'e' `L.cons` 'l' `L.cons` 'l' `L.cons` 'o'
07:38:40 <lambdabot>  Couldn't match `[Char]' against `Char'
07:38:47 <AStorm> > 'h' `L.cons` 'e' `L.cons` 'l' `L.cons` 'l' `L.cons` 'o' `L.cons` []
07:38:48 <lambdabot>  Couldn't match `[Char]' against `Char'
07:38:52 <AStorm> ?
07:39:01 <nmessenger> infixr
07:39:09 <AStorm> nmessenger, gah!
07:39:22 <Cope> argh, this is all hurting my head too much.
07:39:22 <AStorm> ?let cons = infixr (:)
07:39:23 <lambdabot>  Parse error
07:39:25 <Cope> :)
07:39:39 <nmessenger> :(  no cons for you!  infixr is a toplevel decl
07:39:42 <AStorm> :/
07:39:48 <spiffy> just be glad they arent talking about comands or other fun stuff :D
07:40:10 <nmessenger> > "aah!" >>= replicate 5 -- yay!
07:40:12 <lambdabot>  "aaaaaaaaaahhhhh!!!!!"
07:40:14 <kowey> Cope: AStorm and nmessenger were just horsing around with lambdabot, disregard
07:40:36 <nmessenger> > cycle "lo"
07:40:38 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
07:40:42 <kowey> although you'll also want to embrace the hurting-of-head
07:41:08 <LoganCapaldo> > let (*) = (>>= replicate) in "aah!" * 5
07:41:09 <lambdabot>  Couldn't match `a -> Int' against `[Char]'
07:41:20 <xerox> nmessenger: haha
07:41:20 <LoganCapaldo> darn
07:41:52 <AStorm> ?undo \a b -> a >>= replicate b
07:41:53 <lambdabot> \ a b -> a >>= replicate b
07:41:58 <AStorm> ?pl \a b -> a >>= replicate b
07:41:59 <lambdabot> (. replicate) . (>>=)
07:42:01 <AStorm> Ok.
07:42:21 <AStorm> > let (*) = (. replicate) . (>>=) in "aah!" * 5
07:42:23 <lambdabot>  "aaaaaaaaaahhhhh!!!!!"
07:42:30 <LoganCapaldo> oh drat
07:42:43 <LoganCapaldo> I was ready to blam Num
07:42:49 * LoganCapaldo hangs head in shame
07:42:55 <AStorm> Wrong arg order :P
07:42:56 <nmessenger> LoganCapaldo: go in the corner!
07:43:35 <xerox> AStorm: no, different function.
07:43:46 <AStorm> xerox, that too :>
07:43:52 <LoganCapaldo> yeah, different function!
07:43:57 * LoganCapaldo calls out from his corner
07:44:05 <nmessenger> Cope: have you started reading "Yet another Haskell Tutorial"?  That's good to start
07:44:19 <pbx> OK Cope, well, that concludes the introductory Haskell lesson! I hope you absorbed it all.
07:44:34 <LoganCapaldo> Yes, because there wil be a quiz
07:44:35 <LoganCapaldo> ;)
07:44:38 <nmessenger> I hope at least *something* stuck to ya
07:45:14 <Cope> hehe, i am sure some did
07:45:35 <Cope> and I am much encouraged by your friendliness and knowledge! am reading tutorials now
07:45:44 * nmessenger tosses lambdas around.  "Functions for everybody!"
07:46:03 <AStorm> Not sugared? Eh...
07:47:16 <AStorm> functions are sugared lambdas! You tried to cheat us!
07:47:26 <nmessenger> :P
07:48:00 * nmessenger takes lambda back from ASmort.
07:54:19 <dylan> @where yaml
07:54:20 <lambdabot> I know nothing about yaml.
07:54:28 <dylan> @where HsSyck
07:54:28 <lambdabot> http://svn.openfoundry.org/pugs/third-party/HsSyck/
08:01:37 <notsmack> i guess there's no gstreamer binding for haskell?
08:01:59 <Lemmih> Didn't Igloo write one once?
08:03:11 <notsmack> Lemmih: thanks, adding igloo to my search terms found me a darcs repo
08:08:06 <matthew-_> is there an xor function?
08:08:47 * nmessenger was eerily reading just that question in the logs
08:09:02 <nmessenger> there's one for Bits a => a
08:09:16 <allbery_b> xor onBool is (/=), no?
08:09:26 <allbery_b> *on Bool
08:10:06 <xerox> yes
08:10:24 <matthew-_> oh bother, yes of course. tnx
08:10:50 <nmessenger> map (\(x,y) -> (x,y,x /= y)) [(0,0),(0,1),(1,0),(1,1)]
08:10:56 <nmessenger> > map (\(x,y) -> (x,y,x /= y)) [(0,0),(0,1),(1,0),(1,1)]
08:10:57 <lambdabot>  [(0,0,False),(0,1,True),(1,0,True),(1,1,False)]
08:11:07 <nmessenger> yep
08:11:13 <matthew-_> super. tnx
08:11:59 <Botje> @pl \(x,y) -> (x,y,x /= y)
08:12:00 <lambdabot> uncurry (liftM2 ap (,,) (/=))
08:12:11 <Botje> there's a (,,) operator too? O_O
08:12:21 <allbery_b> tuple constructor, yeh
08:12:23 <nmessenger> (,,) x y z = (x, y, z)
08:12:26 <musasabi> Does someone have template haskell for deriving binary instances?
08:12:30 <Botje> funky
08:12:43 <nmessenger> also (,,) x y = \z -> (x, y, z)
08:13:11 <notsmack> nmessenger, Botje: handy, didn't know that one.
08:15:27 <nmessenger> @check (\xs ys ->  zip xs ys == zipWith (,) xs ys) :: [Int] -> [Int] -> Bool
08:15:29 <lambdabot>  OK, passed 500 tests.
08:16:31 <nmessenger> zip = zipWith (,)
08:16:38 <rahikkala> > (,,,,,,,,,,,,,,) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- o_O
08:16:39 <lambdabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
08:17:03 <AStorm> > zipWith (:) 1 2 3 4 5
08:17:05 <lambdabot>      The function `zipWith' is applied to six arguments,
08:17:05 <lambdabot>     but its type `(a...
08:17:10 <xerox> Nnnnnnnnnn-tuples!
08:17:11 <AStorm> :/
08:17:34 <notsmack> @hoogle (a, b) -> c -> (a, b, c)
08:17:35 <lambdabot> No matches, try a more general search
08:17:41 <AStorm> Nope.
08:17:58 <AStorm> ?hoogle (a, a) -> b -> (a, a, b)
08:17:59 <lambdabot> No matches, try a more general search
08:18:02 <AStorm> ?
08:18:14 <nmessenger> @type \(x,y) z -> (x,y,z)) -- not sure of anything better
08:18:16 <lambdabot> parse error on input `)'
08:18:20 <LoganCapaldo> @pl (\(a, b) c -> (a, b, c))
08:18:21 <lambdabot> uncurry (,,)
08:18:29 <nmessenger> ah!
08:18:31 <notsmack> hah.
08:18:33 <notsmack> nice.
08:18:51 <nmessenger> extendTuple = uncurry
08:18:56 <dcoutts> aking, if I give you a new gtk2hs tarball would you give it a go and see if I've fixed the ld problem ok?
08:18:57 <notsmack> i'm impressed pl found it
08:19:10 <rahikkala> @pl (\(a, b, c) d -> (a, b, c, d))
08:19:10 <lambdabot> (line 1, column 8):
08:19:11 <lambdabot> unexpected ","
08:19:11 <lambdabot> expecting letter or digit, operator or ")"
08:19:11 <lambdabot> ambiguous use of a non associative operator
08:19:11 <nmessenger> > uncurry (,,,,)
08:19:13 <lambdabot>  Add a type signature
08:19:16 <nmessenger> @type uncurry (,,,,)
08:19:18 <lambdabot> forall a b c d e. (a, b) -> c -> d -> e -> (a, b, c, d, e)
08:19:27 <nmessenger> o.O
08:19:28 <aking> dcoutts: sure - no prob
08:19:43 <LoganCapaldo> > uncurry (,,) 1 (2,3)
08:19:44 <lambdabot>   add an instance declaration for (Num (a, b))
08:19:44 <dcoutts> aking, ok, cool. I'll ping you when it's available.
08:19:54 <AStorm> @type uncurry uncurry uncurry (,,,,)
08:19:54 <aking> dcoutts: thanks
08:19:55 <lambdabot>     Expecting a function type, but found `(a, b)'
08:19:56 <lambdabot>       Expected type: (a -> b -> t -> t1, (a, b))
08:19:58 <LoganCapaldo> > uncurry (,,) (2,3) 1
08:20:00 <lambdabot>  (2,3,1)
08:20:11 <AStorm> @type uncurry $ uncurry $ uncurry (,,,,)
08:20:13 <lambdabot> forall b a b1 d e. (((a, b1), b), d) -> e -> (a, b1, b, d, e)
08:20:34 <notsmack> heh
08:20:50 <AStorm> Demoroniser? :>
08:21:19 <notsmack> @instances Functor
08:21:20 <nmessenger> @type uncurry uncurry -- I wonder
08:21:21 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:21:22 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
08:21:45 <LoganCapaldo> that's a weird type
08:21:55 <LoganCapaldo> oh snap
08:21:58 <nmessenger> > uncurry uncurry ((+), (3,4))
08:22:00 <lambdabot>  7
08:22:14 <nmessenger> it worked!  I just matched the types.
08:22:38 <LoganCapaldo> > let applyFromLisp = uncurry uncurry in applyFromLisp ((+), (2,3))
08:22:41 <lambdabot>  5
08:22:41 <AStorm> It's the opposite of what Haskell does on normal calls
08:23:30 <LoganCapaldo> > uncurry uncurry ((++), "a", "b")
08:23:31 <lambdabot>  Couldn't match `(a -> b -> c, (a, b))' against `(a1, b1, c1)'
08:23:40 <LoganCapaldo> > uncurry uncurry ((++), ("a", "b"))
08:23:43 <lambdabot>  "ab"
08:23:45 <LoganCapaldo> hehehhe
08:23:48 <LoganCapaldo> this is fun
08:23:50 <nmessenger> \o/
08:24:40 <nmessenger> we're uncurrying the 'uncurry' function itself
08:24:45 <AStorm>  /o/
08:24:48 <LoganCapaldo> nmessenger, what does \o/ mean?
08:24:49 <AStorm>  \o\
08:24:56 <AStorm> \o/
08:25:13 <LoganCapaldo> @unpl \o/
08:25:14 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
08:25:16 <nmessenger> Let's get on up, and dance! (/bash.org)
08:25:49 * xerox has an evil idea.
08:25:52 <roconnor> \o/ is a picture of a guy with his arms in the air
08:26:03 * nmessenger likes evil ideas
08:26:27 <AStorm> ?type uncurry . uncurry
08:26:29 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
08:26:44 <nmessenger> coolz!
08:27:00 <nmessenger> hmm, anybody have a (a -> b -> c -> d) handy?
08:27:27 <Botje> (,,,) ? :p
08:27:28 <roconnor> @hoogle a -> b -> c -> d
08:27:30 <lambdabot> No matches, try a more general search
08:27:41 <roconnor> @type (,,)
08:27:43 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
08:28:10 <roconnor> @hoogle a -> b
08:28:12 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
08:28:12 <AStorm> ?type (+) . (/) . (*) . (-)
08:28:12 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
08:28:12 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
08:28:14 <lambdabot> forall a. (Num (((a -> a) -> a -> a) -> (a -> a) -> a -> a), Fractional ((a -> a) -> a -> a), Num (a -> a), Num a) => -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a ->
08:28:14 <lambdabot> a) -> a -> a
08:28:16 <nmessenger> > (uncurry . uncurry) (,,) ((1,2),3) -- I can guess the result
08:28:17 <lambdabot>  (1,2,3)
08:28:43 <LoganCapaldo> heh
08:28:45 <nmessenger> > (uncurry . uncurry) (\x y z -> x+y+z) ((1,2),3)
08:28:47 <lambdabot>  6
08:29:02 <LoganCapaldo> \o/ /o\ \o/ -- guy doing the we're not worthy thing
08:29:03 <AStorm> > let wtf = (+) . (/) . (*) . (-) in wtf 1 2
08:29:05 <lambdabot>        add an instance declaration for (Num (((a -> a) -> a -> a)
08:29:05 <lambdabot>            ...
08:29:22 <AStorm> Hmm.
08:29:40 <nmessenger> @type ((+) .) . (/)
08:29:42 <AStorm> ?pl \a b c d in a + b / c * d
08:29:42 <lambdabot> forall a. (Fractional a) => a -> a -> a -> a
08:29:43 <lambdabot> (line 1, column 10):
08:29:43 <lambdabot> unexpected reserved word "in"
08:29:43 <lambdabot> expecting pattern or "->"
08:29:49 <AStorm> ?pl \a b c d = a + b / c * d
08:29:50 <lambdabot> (line 1, column 10):
08:29:50 <lambdabot> unexpected "="
08:29:50 <lambdabot> expecting pattern or "->"
08:29:54 <AStorm> BLAH.
08:29:55 <LoganCapaldo> AStorm, ->
08:29:57 <AStorm> ?pl \a b c d -> a + b / c * d
08:29:58 <lambdabot> (. (((*) .) . (/))) . (.) . (.) . (+)
08:30:08 <AStorm> ?!?
08:30:09 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
08:30:12 <LoganCapaldo> LOL
08:30:14 <LoganCapaldo> wow
08:30:23 * xerox sighs.
08:30:34 <nmessenger> Composition composition! What's you're function! :-}
08:30:52 <AStorm> ?type (.) . (.)
08:30:54 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:30:58 <nmessenger> (gah! I commited the deadly "you're/your" sin)
08:31:00 <xerox> ....no type level uncurry, dang.
08:31:11 <LoganCapaldo> nmessenger, in a song about grammar no less ;)
08:31:22 <AStorm> AKA Owl operator
08:31:29 * nmessenger bathes in irony
08:32:01 <AStorm> nmessenger, not in iron?
08:32:04 <nmessenger> xerox: type-level uncurry would have to do with type constructors I think
08:32:56 <AStorm> ?unpl (*) . (+) . (/)
08:32:57 <lambdabot> (\ c -> (*) ((+) ((/) c)))
08:33:22 <nmessenger> > Uncurry StateT = \(a,b) -> StateT a b, though I'm not sure how to pass a tuple of types ;P
08:33:22 <lambdabot>  Parse error
08:33:47 <nmessenger> type-level lambdas!
08:34:16 <AStorm> That'd be... inappropriate
08:34:36 <AStorm> You know, type interpreter _is_ Turing-complete... but
08:34:37 <LoganCapaldo> type Uncurry a b c = a (b, c)
08:34:42 <roconnor> AStorm: why do you think forall is ;)
08:34:44 <roconnor> er
08:34:48 <roconnor> what do you think forall is ;)
08:35:00 <roconnor> oh wait, nevermind
08:35:05 <roconnor> forall is Pi, not lambda
08:35:22 <roconnor> anyhow type leveled lambdas are great!
08:35:29 <nmessenger> type Flip a b c = a c b -- works
08:35:36 <roconnor> and if you remove fix, you don't have to worry about being turing complete
08:35:42 <nmessenger> Flip Either Int Char = Either Char Int
08:35:52 <AStorm> ?type fix
08:35:54 <lambdabot> forall a. (a -> a) -> a
08:36:12 <AStorm> >fix me
08:36:22 <nmessenger> > fix ("me"++)
08:36:23 <maskd> i'm trying to build lambdabot, but i get this error: Setup.hs: cannot satisfy dependency zlib-any
08:36:23 <notsmack> @src fix
08:36:24 <lambdabot>  "mememememememememememememememememememememememememememememememememememememem...
08:36:24 <lambdabot> fix f = let x = f x in x
08:36:38 <allbery_b> ?where zlib
08:36:39 <LoganCapaldo> > take 2 $ fix ("aspirin":)
08:36:39 <lambdabot> darcs get http://haskell.org/~duncan/zlib
08:36:40 <lambdabot>  ["aspirin","aspirin"]
08:36:42 <roconnor> ... if you remove general recursion, you don't have to worry about being Turing complete
08:37:11 <AStorm> roconnor, you can't :P
08:37:17 <roconnor> I can't what?
08:37:18 <AStorm> We already have recursive types.
08:37:22 <maskd> allbery_b: i tried that. can't build it either
08:37:41 <roconnor> Most recursive types are still fine.
08:37:50 <roconnor> they don't give you general recursion
08:38:06 <AStorm> What about mutually recursive types?
08:38:13 <roconnor> most of them are also fine
08:38:21 <LoganCapaldo> type R a = a (R a)
08:38:25 <LoganCapaldo> Bwahahahahhaha
08:38:47 <roconnor> LoganCapaldo: that doesn't parse
08:38:52 <yts> hello!
08:38:58 <yts> i have a question about haskell
08:39:07 <LoganCapaldo> roconnor, what you're not using GHC 99 from the future? ;)
08:39:17 <nmessenger> yts: ask away!
08:39:22 <yts> what's the meaning of forall a. a->a
08:39:33 <yts> forall a. a -> m a
08:39:35 <AStorm> yts, you can read that
08:39:38 <roconnor> AStorm: I had your recation to lambdas on the type level too
08:39:40 <AStorm> It's a higher order type
08:39:44 <nmessenger> for all types 'a', this is a function from an 'a' to an 'a'
08:40:08 <nmessenger> forall a. a->a, that is
08:40:09 <roconnor> but I have seen the light
08:40:18 <allbery_b> maskd: what error?  what version of ghc are you using?
08:40:23 <allbery_b> @paste -- paste error here
08:40:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:40:38 <AStorm> roconnor, the light on doing computations on compile time? :P
08:40:42 <AStorm> *of
08:40:49 <yts> but onlbut a -> a is the same
08:41:07 <AStorm> yts, in this case yes.
08:41:19 <roconnor> I admit that the notion of compilation and interpretation gets even more fuzzy.
08:41:21 <AStorm> But it can also be: exists a. a -> a
08:41:23 <nmessenger> yts: 'forall a. a -> m a' could be 'Int -> Maybe Int' or 'Char -> IO Char', or likewise
08:41:47 <yts> nmessenger: but a -> m a can mean the same
08:41:51 <yts> like monad
08:42:00 <yts> the type of return
08:42:10 <nmessenger> @type return
08:42:10 <yts> return :: a -> m a
08:42:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
08:42:15 <nmessenger> yep
08:42:20 <roconnor> but the IO monad still draws the line at what must be done at runtime
08:42:27 <roconnor> ... presumably
08:42:38 <nmessenger> with the additional stipulation that 'm' has to be a monadic type constructor
08:42:40 <LoganCapaldo> IO -- Don't cross me, I'm a line!
08:42:56 <AStorm> roconnor, why?
08:43:01 <AStorm> Compile-time IO... :>
08:43:10 <maskd> allbery_b: zlib's Setup.hs complains about imagemagick
08:43:11 <nmessenger> IO is an ordinary monad that just doesn't have a (safe) runIO function.
08:43:14 <AStorm> Maybe not from stdio, but...
08:43:16 <maskd> allbery_b: import: unable to open module file `/usr/lib/ImageMagick-6.3.0/modules-Q16/coders/simple.la': No such file or directory.
08:43:20 <roconnor> obviously you can't run a function that relies on input from IO.
08:43:23 <LoganCapaldo> AStorm, ugh, you are makig me think of C++ now
08:43:32 <allbery_b> ???
08:43:35 <roconnor> er
08:43:46 <roconnor> can't run a function at compile time that relies on  input from IO.
08:43:52 <AStorm> You could.
08:44:06 <nmessenger> > (return :: Int -> Maybe Int) 5
08:44:08 <lambdabot>  Just 5
08:44:11 <AStorm> E.g. reads some data from file and then builds some evil classes.
08:44:23 <nmessenger> > (return :: Int -> Either String Int) 5
08:44:25 <lambdabot>  Right 5
08:44:25 <roconnor> I don't think that is the semantics of IO.
08:44:37 <AStorm> reads some other data from file and builds some less evil classes
08:45:04 <roconnor> because now if you change the file then your program doesn't change, even though it should reflect the new file.
08:45:09 <LoganCapaldo> > (fail :: String -> Either String Int) "Upside down!"
08:45:10 <lambdabot>  Left "Upside down!"
08:45:15 <maskd> allbery_b: i forgot to use runhaskell, nevermind
08:45:17 <AStorm> roconnor, yes, the program does change :P
08:45:27 <AStorm> It's a totally different program.
08:45:44 <roconnor> how can the program change if you haven't recomplied it?
08:45:48 <yts> nmessenger: the board has a lot of message >"<
08:45:51 <AStorm> You did compile it...
08:45:53 <nmessenger> > (fail :: String -> Maybe Int) "Upside down!"
08:45:54 <lambdabot>  Nothing
08:45:59 <AStorm> It's like a compile-time switch.
08:46:01 <Botje> > fail "behind as a child" :: Either String Int
08:46:02 <lambdabot>  Left "behind as a child"
08:46:08 <Botje> :p
08:46:13 <LoganCapaldo> nmessenger, yer silly
08:46:15 <roconnor> yes, but compile time switch isn't the semantics of IO.
08:46:24 <LoganCapaldo> But Butje is sillier
08:46:26 <AStorm> It can be.
08:46:29 <LoganCapaldo> err Botje
08:46:34 <AStorm> IO is just input and output
08:46:41 <Botje> KING OF TEH SILLIES!
08:46:41 <AStorm> Compile-time output is nice too.
08:46:50 <roconnor> IO is more than input and output
08:46:53 <roconnor> it has threads
08:46:57 <roconnor> it has mutable state
08:47:01 <AStorm> Might have, doesn't need to.
08:47:03 <roconnor> it has random numbers
08:47:07 <yts> nmessenger:  i just wonder what's the difference between a->m a and forall a.  a-> m a
08:47:10 <AStorm> Mutable state, yes. No random numbers :P
08:47:14 <roconnor> these are part of Haskell 98
08:47:30 <roconnor> er
08:47:30 <nmessenger> yts: no difference, the forall just introduces a type variable.  It's implicit usually.
08:47:35 <AStorm> Compile-time random numbers... sounds useful and appropriate, somehow.
08:48:01 <roconnor> AStorm: having compile time stuff is great, but it is more like template haskell.
08:48:07 <roconnor> and not IO
08:48:21 <AStorm> Exactly, but having compile time IO would be nice too :>
08:48:27 <yts> tnmessenger: but a,b,c this kind of type name is represent generic type already
08:48:48 <allbery_b> yts: yes, as he sdaid it's nornmally implicit
08:48:50 <nmessenger> yts: yep. 'a' is shorthand for 'forall a. a'
08:49:04 <AStorm> What about forall a. b -> a
08:49:05 <AStorm> :>
08:49:09 <allbery_b> there are some unusual cases where yu want to say it explicitly; plus, it's a bit clearer in some cases to explicitly specify it
08:49:24 <yts> oh!!
08:49:27 <yts> i got it!
08:49:27 <allbery_b> (well, haskell98 doesn't let you say it explicitly)
08:49:41 <nmessenger> AStorm: 'b' is free, and by the semantics of haskell, is implicitly forall qualified
08:49:48 <AStorm> Yep. :P
08:49:55 <AStorm> What about exists b. forall a. b -> a
08:50:14 <allbery_b> well, it
08:50:19 <allbery_b> 's illegal, for one :)
08:50:23 <AStorm> No.
08:50:25 <AStorm> It's _|_
08:50:26 <allbery_b> (no exists :)
08:50:37 <AStorm> Not yet, will probably be in H'
08:51:02 <nmessenger> I'm not *quite* to understanding exists quantification.
08:51:27 <seliopou> Implementation question: Does GHC transform programs that use type classes to a dictionary passing style, or has a new method been developed?
08:51:32 <AStorm> It's a function, that when applied to some type b can return something of any type
08:51:52 <AStorm> Where "some type" can be many types, but not all.
08:51:53 <seliopou> :t head []
08:51:54 <lambdabot> forall a. a
08:51:58 <nmessenger> AStorm: would that be 'forall a b. b -> a'?
08:51:58 <seliopou> er...
08:52:04 <AStorm> nmessenger, no
08:52:12 <allbery_b> so, generalized error
08:52:13 <seliopou> :t \x -> head []
08:52:15 <lambdabot> forall a t. t -> a
08:52:16 <AStorm> _some_ types :>
08:52:27 <AStorm> for others, error :P
08:52:49 <AStorm> : \x -> _|_
08:52:53 <AStorm> :t \x -> _|_
08:52:54 <lambdabot> parse error on input `|'
08:53:00 <AStorm> :t \x -> bottom
08:53:01 <lambdabot> Not in scope: `bottom'
08:53:03 <nmessenger> :t \x -> undefined
08:53:04 <AStorm> Blah.
08:53:05 <lambdabot> forall a t. t -> a
08:53:17 <nmessenger> undefined is bottom
08:53:19 <AStorm> Too much ML lately :>
08:54:14 <seliopou> AStorm: It's been a while since I've done ML and I seem to have forgotten if one can create his own eqtypes
08:54:26 <allbery_b> > let (_|_) = undefined in _|_
08:54:26 <lambdabot>  Parse error
08:54:30 <seliopou> is that possible?
08:54:46 <AStorm> > let (_|_) = undefined in (_|_)
08:54:47 <lambdabot>  Parse error
08:54:52 <allbery_b> oh well
08:54:56 <glguy> _ is a letter
08:55:01 <AStorm> > let (_|_) = undefined in `_|_`
08:55:02 <lambdabot>  Parse error
08:55:06 <AStorm> ?!?
08:55:06 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
08:55:18 <glguy> > let _l_ = undefined in _l_
08:55:19 <lambdabot>  Add a type signature
08:55:23 <allbery_b> yeh, can't mix letters and punctuation
08:55:34 <AStorm> Boo hoo :/
08:55:48 <allbery_b> ...or use _ that way :/
08:56:11 <glguy> > let _l_ = undefined in _l_ :: ()
08:56:12 <lambdabot>  Undefined
08:56:18 <nmessenger> (_|_) looks like a butt :D
08:56:19 <xerox> Argh, I hit an infinite type.
08:56:28 <AStorm> nmessenger, it's not called "bottom" for nothing
08:56:43 <allbery_b> > let _|_ :: forall a. a -> a -> a; _|_ = undefined in _|_
08:56:44 <lambdabot>  Parse error
08:57:04 <allbery_b> didn't think so
08:57:05 <AStorm> _|_ is not a valid lexeme it seems
08:57:17 <glguy> _l_ is though
08:57:23 <allbery_b> I think it's taking the _s as pattern bl;anks
08:57:23 <nmessenger> I propose ... as a syntactic special case for bottom, prefix like normal functions.  Then examples with '...' in the would type. :)
08:57:27 <AStorm> _1_
08:57:40 <allbery_b> nmessenger: how perl6 of you
08:57:58 <AStorm> :D
08:58:18 <nmessenger> allbery_b: is that a compliment?
08:58:26 <allbery_b> take that as you will
08:58:31 * nmessenger does
08:58:42 <allbery_b> perl6 does have ... as an exception though
08:58:56 <AStorm> How thoughtful of them.
08:58:57 <allbery_b> meaning "unimplemented"
08:59:07 <nmessenger> cool!
08:59:20 <AStorm> > let (...) = undefined in f x = (...)
08:59:21 <lambdabot>  Parse error
08:59:27 <AStorm> > let (...) = undefined in (...)
08:59:28 <lambdabot>  Add a type signature
08:59:33 <AStorm> > let (...) = undefined in (...) : ()
08:59:34 <lambdabot>  Couldn't match `[a]' against `()'
08:59:37 <AStorm> > let (...) = undefined in (...) :: ()
08:59:39 <lambdabot>  Undefined
08:59:49 <AStorm> Oh, now we have that too :>
08:59:58 <nmessenger> (...) works I guess, but I wanted ...
09:00:02 <allbery_b> > let (...) :: forall a. a; (...) = undefined in (...)
09:00:03 <lambdabot>  Parse error
09:00:07 <AStorm> ... works too
09:00:11 * allbery_b thinks he's missing something
09:00:11 <AStorm> > let (...) = undefined in ... :: ()
09:00:12 <lambdabot>  Parse error
09:00:31 <allbery_b> oh wait, no extensions.  duh
09:00:34 <nmessenger> allbery_b: forall supported in '>' types?
09:01:02 <allbery_b> nmessenger: lbot doesn't d extensions, I bet it doesn't like forall as a result
09:01:14 <allbery_b> > let (...) :: a; (...) = undefined in (...)
09:01:15 <lambdabot>  Add a type signature
09:01:22 <nmessenger> blah
09:01:35 <AStorm> > let (...) :: a = undefined in (...) :: ()
09:01:35 <lambdabot>  Parse error
09:01:37 <nmessenger> ?let (...) = undefined
09:01:38 <lambdabot> Defined.
09:01:46 <nmessenger> ?type (...)
09:01:47 <lambdabot> Not in scope: `...'
09:01:56 <nmessenger> > typeOf (...)
09:01:56 <AStorm> ?type L....
09:01:57 <lambdabot>  Add a type signature
09:01:58 <allbery_b>  ?type doesn't see ?let
09:01:58 <lambdabot> parse error on input `L....'
09:02:06 <AStorm> ?type L.(...)
09:02:08 <lambdabot> Not in scope: data constructor `L'
09:02:08 <lambdabot>  
09:02:08 <lambdabot> <interactive>:1:2: Not in scope: `...'
09:02:18 <AStorm> > L....
09:02:19 <lambdabot>  Parse error
09:02:23 <AStorm> > L.(...)
09:02:24 <lambdabot>   Not in scope: data constructor `L'
09:02:24 <nmessenger> AStorm: qualified operators are (Module.!)
09:02:32 <allbery_b> > ...
09:02:33 <lambdabot>  Parse error
09:02:36 <allbery_b> > (...)
09:02:37 <lambdabot>  Add a type signature
09:02:48 <allbery_b> > (...) :: ()
09:02:50 <lambdabot>  Undefined
09:02:58 <AStorm> > let f = (...) in f 1 2 3
09:02:59 <lambdabot>  Add a type signature
09:03:00 <nmessenger> but yeah, @type doesn't see it, and typeOf requires monomorphism
09:03:13 <allbery_b> > 1 ... 0
09:03:15 <lambdabot>  Add a type signature
09:03:17 <AStorm> > let f a b c :: Int -> Int -> Int -> Int = (...) in f 1 2 3
09:03:18 <lambdabot>  Parse error
09:03:18 <allbery_b> > 1 ... 0 : ()
09:03:19 <lambdabot>  Couldn't match `[a]' against `()'
09:03:27 <AStorm> > let (f a b c :: Int -> Int -> Int -> Int) = (...) in f 1 2 3
09:03:28 <lambdabot>  Parse error in pattern
09:03:31 <allbery_b> hm, right, syntactic special case
09:03:37 <allbery_b> so much for tha
09:03:38 <allbery_b> t
09:03:45 <nmessenger> > 1 ... 0 :: ()
09:03:46 <lambdabot>  Undefined
09:03:47 <AStorm> > 1 ... 0 :: ()
09:03:48 <lambdabot>  Undefined
09:03:53 <nmessenger> jinx!
09:03:59 <allbery_b> duh
09:04:06 * allbery_b missed that, d'oh
09:04:10 * nmessenger beats the ML out of allbery_b
09:04:13 * allbery_b still fuzzy
09:04:33 <allbery_b> no ML, just dropped colon and jumping t conclusions
09:05:03 * nmessenger beats him up anyway :)
09:06:08 <AStorm> > let f x y :: Int -> Int -> Int = (...) in f 1 2
09:06:09 <lambdabot>  Parse error
09:06:12 <AStorm> Why?
09:06:29 <AStorm> > let f x y :: Int -> Int -> Int = ... in f 1 2
09:06:29 <lambdabot>  Parse error
09:06:31 <glguy> http://digg.com/offbeat_news/Wisconsin_police_chief_tickets_HIMSELF_235_docks_4_points_on_his_license -- the last, unrelated comment is great ;)
09:06:31 <nmessenger> no types on lhs in '>'s simple parser
09:06:33 <lambdabot> Title: Digg - Wisconsin police chief tickets HIMSELF $235 & docks 4 points on his licen ..., http://tinyurl.com/27d9f2
09:06:46 <AStorm> Boo hoo.
09:07:03 <nmessenger> > let f :: Int -> Int -> Int; f x y = ... in f 1 2
09:07:03 <lambdabot>  Parse error
09:07:10 <nmessenger> > let f :: Int -> Int -> Int; f x y = (...) in f 1 2
09:07:12 <lambdabot>  Undefined
09:08:00 <nmessenger> hooray for Aqua Teen Hunger Force!
09:08:02 <AStorm> > let wtf = (...) . (...)
09:08:03 <lambdabot>  Parse error
09:08:07 <AStorm> ?let wtf = (...) . (...)
09:08:08 <lambdabot> Defined.
09:08:12 <AStorm> ?type L.wtf
09:08:14 <basti_> ...?
09:08:14 <lambdabot> Couldn't find qualified module.
09:08:20 <AStorm> ?type wtf
09:08:22 <lambdabot> Not in scope: `wtf'
09:08:29 <AStorm> > wtf
09:08:30 <lambdabot>  Add a type signature
09:08:33 <AStorm> > wtf :: ()
09:08:34 <lambdabot>      Expecting a function type, but found `()'
09:08:34 <basti_> what are you trying to do?
09:08:34 <lambdabot>       Expected type: ()
09:08:34 <lambdabot>       ...
09:08:36 <nmessenger> basti_: (...) = undefined = _|_
09:08:45 <basti_> okay
09:08:57 <nmessenger> it's @let'ed
09:09:05 <AStorm> > L.wtf :: ()
09:09:06 <lambdabot>      Expecting a function type, but found `()'
09:09:07 <lambdabot>       Expected type: ()
09:09:07 <lambdabot>       ...
09:09:25 <basti_> theres types that can be shown to be uninhibited.
09:09:26 <nmessenger> L.wtf :: Int -> Int
09:09:30 <nmessenger> > L.wtf :: Int -> Int
09:09:32 <lambdabot>  <Int -> Int>
09:09:38 <nmessenger> :}
09:09:52 <nmessenger> "Expecting a function type" so I gave it one.
09:10:03 <AStorm> > L.wtf :: Int -> Int 2
09:10:04 <lambdabot>  Parse error
09:10:10 <AStorm> > L.wtf :: Int -> Int; L.wtf 2
09:10:11 <lambdabot>  Parse error
09:10:12 <nmessenger> parens
09:10:27 <nmessenger> > (wtf::Int->Int) 2
09:10:29 <lambdabot>  Undefined
09:11:15 <nmessenger> the definition of (.) makes it a simple lambda
09:11:19 <nmessenger> @src (.)
09:11:20 <lambdabot> (.) f g x = f (g x)
09:11:31 <AStorm> Unfortunately, we can't do a function that takes an undefined number of parameters...
09:11:35 <AStorm> > undefined 1 2 3
09:11:36 <lambdabot>  Add a type signature
09:11:41 <nmessenger> f and g = _|_, but f . g = \_ -> _|_
09:11:47 <AStorm> > undefined 1 2 3 :: Int -> Int -> Int -> Int
09:11:49 <lambdabot>  <Int -> Int -> Int -> Int>
09:12:03 <AStorm> > undefined 1 2 3 :: Int -> Int -> Int -> Blah
09:12:04 <lambdabot>   Not in scope: type constructor or class `Blah'
09:12:10 <nmessenger> give it three more Ints :)
09:12:27 <nmessenger> or a *-kinded type
09:12:34 <nmessenger> > undefined 1 2 3 :: INt
09:12:35 <lambdabot>   Not in scope: type constructor or class `INt'
09:12:36 <nmessenger> > undefined 1 2 3 :: Int
09:12:38 <lambdabot>  Undefined
09:12:39 <LoganCapaldo> @type (undefined :: Int -> Int -> Blah) 1 2
09:12:41 <lambdabot> Not in scope: type constructor or class `Blah'
09:12:50 <nmessenger> @kind Int -> Int -> Int -> Int
09:12:52 <lambdabot> *
09:12:52 <LoganCapaldo> lambdabot, doesn't matter :)
09:13:00 <LoganCapaldo> @type (undefined :: Int -> Int -> Maybe String) 1 2
09:13:00 <nmessenger> wait
09:13:01 <lambdabot> Maybe String
09:13:29 <nmessenger> oops, the * kind doesn't apply
09:13:40 <AStorm> undefined function taking undefined number of undefined parameters?
09:14:01 <LoganCapaldo> @type (undefined :: Int -> Int -> a) 1 2
09:14:02 <lambdabot> forall a. a
09:14:07 <nmessenger> the number of parameters is quite clearly defined by the type :P
09:14:30 <allbery_b> :t printf
09:14:32 <lambdabot> forall r. (PrintfType r) => String -> r
09:14:46 <AStorm> defined, but undefined :: Int -> a and undefined :: Int -> Int -> a are both legal :P
09:14:47 <nmessenger> so that one's less clear
09:15:06 <nmessenger> so they are.
09:16:23 <AStorm> undefined :: * -> * -> ... -> * -> _|_
09:16:47 <AStorm> higher-kinded kinds? :P
09:16:47 <nmessenger> the stars make me think of kinds
09:16:59 <AStorm> They should.
09:17:16 <nmessenger> all values (if I understand correctly) are in * types
09:18:55 <nmessenger> undefined is a value, but there might be an Undefined type, which would be cool if the kind-level was more expressive.
09:19:29 <nmessenger> or rather, undefined *isn't* a value, since it doesn't *actually* exist.
09:19:36 * nmessenger head a splode
09:20:01 <AStorm> Haha!
09:20:08 <AStorm> Mine didn't.
09:20:15 <AStorm> It does exists in System F
09:20:28 * nmessenger gets a shotgun. >:)
09:20:58 <nmessenger> It'll explode one way or another!
09:21:00 <SamB> actually, undefined might be a value, but of the most worthless sort ;-)
09:21:35 <LoganCapaldo> undefined is the most useful value!
09:21:37 <nmessenger> SamB: well, when 'undefined = undefined' finishes evaluating, let me know ;)
09:21:52 <AStorm> Haha, it does.
09:21:56 <SamB> well. the GC thinks it is a value!
09:21:57 <AStorm> undefined is built-in
09:22:12 <SamB> > let undefined = undefined in undefined
09:22:13 <lambdabot>  Add a type signature
09:22:17 <SamB> > let undefined = undefined in undefined :: ()
09:22:18 <lambdabot>  Exception: <<loop>>
09:22:23 <AStorm> Whoops.
09:22:27 <pejo> nmessenger, why do you wnat it to finish? Observing termination behaviour should be enough!
09:22:48 * allbery_b tries to decipher PrintfType
09:22:50 <AStorm> But it does exist.
09:22:53 <nmessenger> heh.  But I must observe it from outside the system.
09:23:02 <AStorm> It's just System F typechecker balking at it.
09:23:19 <nmessenger> what's System F?  I've heard of it several times.
09:23:33 <LoganCapaldo> its the precursor to System G ;)
09:23:38 <AStorm> It's the lower level Haskell type language, used in GHC
09:24:49 <pejo> nmessenger, the "normal" System F was discovered by Girard in the 70's, in context of proof theory in logic.
09:25:21 <pejo> nmessenger, and Reynolds discovered some similar system which he called polymorphic lambda calculus.
09:25:57 <emu> polymorphic lambda calculus is a better name than System F
09:26:39 <emu> but logicians enjoy those single letter names.  /me thinks of modal logic
09:26:41 <nmessenger> I know the terms 'polymorphic' and 'lambda calculus'.  System F is just opaque.
09:27:18 <nmessenger> Lambda-bar Mu Mu-tilde
09:27:40 <nmessenger> I mean, WTF?
09:27:55 <pejo> nmessenger, was that the article by those french people, which allowed both cbv and cbn evaluation?
09:28:14 <nmessenger> Sounds familiar, but I have no idea what it means 8-)
09:29:04 <pejo> (Do people in here find it hard to remember foreign last names?)
09:29:37 <zarvok> heh, I don't have trouble remembering, but the pronounciation often throws me
09:29:47 <emu> i have trouble remembering any names
09:29:53 <zarvok> I mean, no right thinking person would pronounce Leroy as it is supposed to be
09:29:59 <emu> usually people introduce themselves to me and i forget their name within 30 seconds
09:30:45 <pejo> zarvok, except that the rihgt thinking person would realise he's french.
09:30:54 <nmessenger> zarvok: as an English-thinking person I'd take a stab at the usual English pronunciation
09:31:10 <zarvok> pejo: heh, of course, I take issue with french pronounciations as a whole, really
09:31:33 <basti_> elle allait au long du canal laterale a la loire
09:31:35 <roconnor> :t randoms
09:31:37 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
09:31:49 <zarvok> of course, I'm just playing around
09:32:12 <nmessenger> I find French pronunciation to be quite cool, I took French in high school, and that's what really started my interest in general phonetics.
09:32:16 <hyrax42> :t (***)
09:32:18 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:32:21 <hyrax42> :t (&&&)
09:32:23 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:32:49 <nmessenger> for a => (->), (f &&& g) = \x -> (f x, g x)
09:33:16 <nmessenger> and (f *** g) = \x y -> (f x, g y)
09:33:57 <nmessenger> > map (head &&& length) . group . sort $ "hello there"
09:33:59 <lambdabot>  [(' ',1),('e',3),('h',2),('l',2),('o',1),('r',1),('t',1)]
09:34:45 <nmessenger> > (id *** (+1)) (5, 20)
09:34:47 <lambdabot>  (5,21)
09:36:10 <nmessenger> er, f *** g = \(x,y) -> (f x, g y)
09:37:18 <nmessenger> (***) parallelizes two arrows, (&&&) splits an input between them
09:37:35 <hpaste> Event 41337 of TxContext HAppS.Protocols.HTTP.Request
09:38:06 <nmessenger> that event should definitely be ten thousand fewer. ;)
09:38:24 <roconnor> @pl (\x->x `mod` y==0)
09:38:25 <lambdabot> (0 ==) . (`mod` y)
09:40:09 <nmessenger> heh
09:40:15 <nmessenger> @src (->) (***)
09:40:16 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
09:40:23 <nmessenger> @src (->) (&&&)
09:40:24 <lambdabot> Source not found. Are you on drugs?
09:40:54 <nmessenger> @src (&&&)
09:40:55 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
09:41:05 <hyrax42> ?pl \(k, d) (n, m) -> (n+1, insertWith (+) k d m)
09:41:06 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (,) . (1 +))) .) . insertWith (+))
09:41:08 <glguy> flazz: are you still here?
09:42:55 <hpaste>  glguy annotated "take a look?" with "using Data.List" at http://hpaste.org/304#a2
09:45:18 <LoganCapaldo> is it just me or is this whole "getting info from the future" more confusing than just doing two passes?
09:45:30 <glguy> LoganCapaldo: wrt?
09:45:36 <nmessenger> the Monad.Reader?
09:45:38 <LoganCapaldo> I feel like this abstraction (metaphor?) is leaking all over the place
09:45:57 <nmessenger> I still haven't read it.
09:47:08 <emu> its just recursion
09:47:18 <emu> attaching strange names to it just makes it more confusing
09:50:22 <chessguy> hi haskellers
09:50:46 <augustss> I agree with emu, it's just recursion.
09:50:50 <augustss> no magic
09:51:20 <chessguy> ?quote magic
09:51:21 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
09:51:57 <nmessenger> My understanding of the fix operator improved when I manually unrolled the Javascript Y combinator
09:52:26 <augustss> The Javascript Y combinator?  *gasp*
09:52:52 <chessguy> what is a combinator? i hear that word a lot
09:52:53 <nmessenger> ?google javascript y combinator
09:52:56 <lambdabot> http://www.cs.cityu.edu.hk/~hwchun/31337/blog/2005/09/y-combinator-in-javascript.php
09:53:10 <nmessenger> that's not it
09:53:44 <nmessenger> chessguy: combinator, if I understand correctly, means "higher-order function"
09:54:00 <chessguy> oh, that's easy
09:55:25 <glguy> I was under the impression that a combinator was any function without free variables
09:55:52 <nmessenger> that's the definition that I see used usually.
09:56:17 <nmessenger> here we are: http://javascript.crockford.com/little.html
09:56:19 <lambdabot> Title: The Little JavaScripter
09:57:34 <nmessenger> re: combinator; doesn't mean it's the correct usage, though.
09:58:54 <mattam> @hoogle Data.Foldable
09:58:55 <lambdabot> No matches, try a more general search
09:59:01 <mattam> why doesn't it work ?
09:59:45 <nmessenger> Foldable is in 6.6 I heard
10:00:11 <nmessenger> and LB's hoogle isn't
10:00:56 <mattam> ok
10:01:24 <glguy> Can anyone else whistle out of the corner of their mouth?
10:01:44 <glguy> while maintaining a relaxed expression
10:02:20 <Axioplase> glguy: I can't. but I can imitate the sound of a drop of water. which is cooler.
10:03:07 <glguy> my fiancée was just giving me a hard time because I was doing it, and asked how it was I learned to do it
10:03:17 <glguy> obviously I learned it the same way anyone learns to whistle
10:03:26 <glguy> but I didn't know how common it was
10:03:27 <matthew-_> how do you convert from one monad to another? eg if x = [] then I want Nothing, else if x = (a:_) I want Just a
10:03:47 <glguy> :t listToMaybe
10:03:49 <lambdabot> forall a. [a] -> Maybe a
10:03:50 <glguy> :t maybeToList
10:03:52 <lambdabot> forall a. Maybe a -> [a]
10:03:54 * ski can wiggle ears,nose,front hairline ..
10:03:56 <glguy> :t msum
10:03:58 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
10:04:02 <matthew-_> tnx
10:06:22 <LoganCapaldo> > msum [Just 'a', Nothing, Just 'b'] == Just 'a'
10:06:23 <lambdabot>  True
10:07:35 <LoganCapaldo> > msum [[1], [2]] == join [[1], [2]] && msum [[1], [2]] == concat [[1], [2]]
10:07:36 <lambdabot>  True
10:08:06 <LoganCapaldo> [] is a funny monad :)
10:08:12 <basti_> it isnt
10:08:28 <LoganCapaldo> basti_, sure it is
10:08:29 <basti_> theres worse probably
10:08:39 <LoganCapaldo> you can't tell me my opinions about funnyness :)
10:08:42 <basti_> ^^
10:08:44 <nmessenger> join = concat, fmap = map, (>>=) = concatMap, return = (:[]), makes sense
10:09:51 <nmessenger> doesn't msum (x :: [[a]]) = join x?
10:10:22 <nmessenger> = concat x, since mzero = [], and mplus = (++)
10:10:23 <LoganCapaldo> nmessenger, I thought I just said that?
10:10:41 <nmessenger> so why is it strange?
10:11:15 <nmessenger> @src msum
10:11:15 <lambdabot> msum =  foldr mplus mzero
10:12:33 <nmessenger> (>>=) = flip concatMap actually
10:13:15 <nmessenger> ?src [] (>>=)
10:13:16 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:13:24 <LoganCapaldo> its not strange, it's funny :) in one context its a list of monads in another its a m (m a) but the result conincendentaly happens to be the same cause of how [] happens to be
10:13:31 <LoganCapaldo> I thought it was funny :)
10:13:43 <nmessenger> You are Wrong!
10:13:45 <nmessenger> :P
10:20:28 <glguy> Does anyone have any feedback on Haskell support in BBedit vs TextMate?
10:29:22 <ookk> glguy, like what?
10:29:36 <ookk> you maintain the bundle for textmate?
10:29:44 <glguy> Like if one's features are more suited to editing haskell code
10:30:00 <glguy> if one is worth $30 or the other $125
10:30:13 <ookk> well i haven used bbedit, but i do use textmate
10:30:19 <ookk> what are you looking for?
10:30:52 <ookk> glguy, textmate doesnt have anything special except for syntax highlight for haskell
10:30:56 <glguy> ok
10:31:00 <ookk> apple-R to run etc
10:31:03 <glguy> does bbedit have something more for haskell?
10:31:13 <ookk> i dont know, never used bbedit
10:31:18 <glguy> textmate *does* have command-R?
10:31:39 <ookk> yeah
10:31:53 <ookk> and auto-complete on lambda functions
10:32:45 <ookk> other then that i like textmates generic stuff to
10:32:45 <glguy> ?
10:32:53 <ookk> you can write \ and press tab
10:33:09 <glguy> and what can it assume from there??
10:33:11 <ookk> and it will write \ <somestuff> -> <some other stuff>
10:33:18 <ookk> and let you fill in <>
10:33:23 <glguy> oh
10:33:31 <ookk> fill in the first <> press tab and fill in the second <>
10:34:11 <mattrepl> yeah, textmate's snippets are basically templates that remove the need to enter in duplicate data and will write out the boilerplate code for you
10:34:16 <ookk> i also like that when you write [ or ( textmate automatically inserts a ] or )
10:34:34 <ookk> glguy, those kind of things are really easy to make yourself
10:34:43 <ookk> textmate lets you create your own commands
10:34:52 <glguy> hmm, interesting
10:34:58 <glguy> (I've been using ViM up to now)
10:35:09 <glguy> hey, does it support open/save via scp/sftp?
10:35:16 <ookk> glguy, and i highlight some text and press ( { { whatever it surrounds it with () {} [] respectively
10:35:24 <glguy> oh, cool
10:35:30 <glguy> you added that feature yourself?
10:35:33 <ookk> glguy, i dont know if it supports that
10:35:39 <ookk> glguy, no it is default
10:36:10 <glguy> I think that sftp features were in BBEdit
10:36:17 <ookk> glguy, if it doesnt exist it would not be hard to do yourself
10:36:24 <mattrepl> glguy, there was talk about remote file support, but the TM developer was adamant about that being something that should be supported on the OS level
10:36:35 <ookk> you can call bash-scripts or whateever from textmate
10:36:51 <ookk> and it has variables for what is selected, what your filename is and so on
10:37:08 <glguy> does it have any VCS integration?
10:37:10 <ookk> with that i easily wrote a command that compiled a latex file to pdf and opened it in preview.app
10:37:25 <glguy> (more importantly, has anyone written a tie-in to darcs :)  )
10:37:38 <maskd> http://hpaste.org/306
10:37:53 <ookk> glguy, as i said, the haskell bundle i am using is almost only syntax highlight
10:37:55 <glguy> if you wouldn't have unchecked the announce box
10:38:04 <glguy> that would have been announced for you
10:38:46 <ookk> it would be trivial to add darcs support
10:39:14 <ookk> just write a bash script and you have variables like $FOLDER_NAME, $FILENAME
10:39:20 <ookk> that textmate provides
10:39:26 <mattrepl> can search http://macromates.com/wiki/Main/HomePage for more details too
10:39:30 <lambdabot> Title: Main / HomePage — TextMate Wiki
10:39:35 <glguy> that's where I am
10:39:58 <ookk> glguy, and you dont have to beat your esc-button to death (since you are comming from vi) :P
10:40:08 <glguy> that *never* bothered me :)
10:40:39 <glguy> The only problem that I have with vim is that it doesn't integrate well into OS X
10:40:57 <hyrax42> if I'm folding a Map to insert a bunch of stuff, should I use foldl' or foldr?
10:41:01 <ookk> you are using Vim.app?
10:41:08 <glguy> hyrax42: union
10:41:11 <glguy> ookk: yes
10:41:35 <glguy> :t Data.Map.union
10:41:37 <lambdabot> forall a k. (Ord k) => Data.Map.Map k a -> Data.Map.Map k a -> Data.Map.Map k a
10:41:42 <glguy> :t Data.Map.fromList
10:41:44 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
10:41:53 <ookk> glguy, i think textmate is definitely worth its price
10:42:06 <hyrax42> well I'm getting stack overflow is why I ask
10:42:25 <ookk> glguy, i contrast to vi its really easy to customize without having a big unix beard
10:42:44 <gravity> The beard is powerful
10:43:59 <ookk> glguy, have you tried textmate? i think you can try it for 30 days or something
10:44:18 <glguy> i have it downloaded now
10:44:23 <glguy> I'm installing svn
10:44:28 <glguy> so that I can install the Haskell bundle
10:44:46 <ookk> glguy, there is a textmate bundle called GetBundle
10:45:03 <ookk> it lets you install all the difference bundles from textmate itself
10:45:16 <glguy> I don't have that bundle either
10:45:34 <ookk> it would be the first one to get
10:45:58 <ihope> Haskell without a "bottom" value would be fun, aye?
10:46:01 <ookk> then you can auto-update bundles that you have etc
10:46:09 <ihope> A little hard to implement, though.
10:46:23 <gravity> How do you import libraries in to ghci? "import Control.Monad" just gives me a parse error
10:46:25 <mattrepl> ookk, that's cool!
10:46:33 <glguy> :m + lib
10:46:34 <hyrax42> gravity: :m + Control.Monad
10:46:34 <ookk> http://sg.validcode.at/2006/11/7/textmate-getbundle-bundle
10:46:36 <lambdabot> Title: validcode TextMate GetBundle Bundle
10:46:38 <gravity> Ah, thank you!
10:46:46 <slowriot> What is the logical not operator in haskell?
10:46:52 <hyrax42> slowriot: not
10:46:57 <hyrax42> > not True
10:46:58 <lambdabot>  False
10:46:59 <slowriot> thanks
10:49:40 <glguy> cool, I'm up and running
10:50:41 <glguy> bah, it looks in the wrong places for "runhaskell"
10:51:49 <glguy> the syntax highlighting seems arbitrary
10:53:07 <rahikkala> @src fix
10:53:07 <lambdabot> fix f = let x = f x in x
10:53:11 <hyrax42> ?index foldl'
10:53:11 <lambdabot> Data.List
10:53:39 <rahikkala> @pl fix f = let x = f x in x
10:53:39 <lambdabot> fix = fix id
10:53:42 <rahikkala> :(
10:54:20 <ookk> glguy, the syntax highlighting can depend on the theme you are using
10:54:35 <ookk> glguy, some themes doesnt have differente colors for all different kind of stuff
10:54:54 <zem> 'ello
10:55:21 <zem> is haskell-cafe the right place to ask wxHaskell questions? the wxhaskell mailing list seems mostly devoted to hacking on the project itself
10:55:53 <augustss> i don't think anyone will object
11:02:59 <TwigEther> I r teh bums
11:03:27 <augustss> what?
11:08:51 <zem> does zip (map f xs) (map g xs) reduce to anything?
11:09:08 <zem> (apart from map
11:09:22 <Botje> (map f xs, map g xs)
11:09:23 <zem> picking apart zip xs xs in an explicit lambda)
11:09:43 <Botje> I think you can abuse arrows somehow
11:09:44 <Botje> :t (&&&)
11:09:46 <glguy> [ (f x, g x) | x <- xs]
11:09:47 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:09:55 <glguy> map (f &&& g) xs
11:09:59 <Botje> ah
11:10:06 <Botje> I even guessed the operator correctly
11:10:07 <Botje> yay :)
11:10:15 <zem> sweet :)
11:10:27 <zem> they thought of everything
11:10:32 <augustss> @pl \ xs -> zip (map f xs) (map g xs)
11:10:32 <lambdabot> ap (zip . map f) (map g)
11:10:38 <augustss> boring
11:10:38 <Heffalump> ick
11:10:51 <glguy> liftM2 zip (map f) (map g)
11:10:58 <Botje> @pl \xs -> (map f xs, map g xs)
11:10:59 <lambdabot> ap ((,) . map f) (map g)
11:11:09 <Botje> silly \bot
11:11:10 <glguy> Botje: that's something different
11:11:22 <Botje> hmm
11:11:24 <zem> where is &&& defined?
11:11:24 <Botje> ohyeah.
11:11:31 <Botje> :t unzip
11:11:33 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
11:11:51 <xerox> zem - in Control.Arrow.
11:11:53 <glguy> zem: Control.Arrow
11:12:43 <nmessenger> zem: ask lambdabot: @index (&&&)
11:12:52 <zem> which is considered better style?
11:12:57 <slowriot> gchi seems to crash whenever I try to exit it
11:13:39 <glguy> zem: the list comprehension is probably the cleanest
11:15:35 <nmessenger> @check (\f g xs -> map (f &&& g) xs == zip (map f xs) (map g xs)) :: (Int->Int) -> (Int->Int) -> [Int] -> Bool
11:15:39 <lambdabot>  OK, passed 500 tests.
11:15:50 <zem> whoa- nice bot
11:16:08 <nmessenger> @botsnack
11:16:08 <lambdabot> :)
11:16:16 <hpaste>  chessguy pasted "(no title)" at http://hpaste.org/308
11:17:07 <nmessenger> ?quote lambdabot
11:17:08 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
11:17:52 <chessguy> ok guys, i've got several problems which seem to have a very similar structure. i want to find a way to abstract them to solve other problems which can be thought about in the same way. here they are: http://hpaste.org/307 , http://hpaste.org/308 , and http://hpaste.org/309 (note that these are just sketches, the programs aren't done yet
11:17:56 <chessguy> )
11:19:19 <chessguy> the general structure of the problem is that an object enters a system, interacts with different parts of the system, and eventually leaves, and we want to monitor some statistics about the interaction
11:19:42 <chessguy> sorear, hi
11:19:47 <chessguy> you just missed my big paste
11:20:05 <chessguy> ok guys, i've got several problems which seem to have a very similar structure. i want to find a way to abstract them to solve other problems which can be thought about in the same way. here they are: http://hpaste.org/307 , http://hpaste.org/308 , and http://hpaste.org/309 (note that these are just sketches, the programs aren't done yet)
11:21:56 <nmessenger> ?quote i.4M
11:21:56 <lambdabot> lambdabot says: i 4M THe cooLES+ bo+ e\/eR
11:24:30 <sek> ?quote sek
11:24:30 <lambdabot> No quotes match. You type like i drive.
11:26:04 <chessguy> lambdabot drives?
11:26:43 <nmessenger> ...men wild!
11:26:47 <rahikkala> Considering what she looks like, probably not very well
11:26:48 <Saizan> that's the point, i guess
11:26:55 <rahikkala> ( http://www.cse.unsw.edu.au/~dons/images/lambdabot.png for reference)
11:28:22 <chessguy> so, any suggestions how i can look at three similar programs and factor out what's in common?
11:29:04 <chessguy> (either in general, or in this specific case)
11:29:35 <mbishop> @remember nmessenger <chessguy> lambdabot drives? <nmessenger> ...men wild!
11:29:36 <lambdabot> Done.
11:29:51 <trurl> chessguy: maybe kdiff3
11:30:11 <chessguy> trurl, what's that?
11:30:28 <chessguy> oh, like diff?
11:30:36 <trurl> yes, but for three files
11:31:04 <chessguy> i think i'm looking for something a little higgher-level than that
11:31:37 <trurl> sorry, I didn't read what you wrote before
11:32:50 <zem> hm - guess at what's common and refactor all three programs to see whether it really is?
11:33:08 <zem> should be feasible if you do it one guess at a time
11:33:11 <Botje> compile them to lambdacalculuss!
11:33:38 <chessguy> zem, guess?
11:34:10 <zem> well, see what you feel, by eyeballing all three programs, is a common pattern
11:34:10 <chessguy> i can see a lot of what's in common, but i'm not sure how to factor it out
11:34:23 <zem> then try rewriting code in each prog in terms of that pattern
11:37:34 <ookk> anyone built wxhaskkel on their intel mac?
11:37:40 <chessguy> zem, anything in particular you would recommend trying for these programs?
11:37:42 <ookk> is there a binary distribution?
11:37:55 <nmessenger> the only useful commonality I immediately see is the simulate function of type StateT a IO (), and that's only in IO because of randomRIO.
11:38:49 <zem> no, but i'm new to haskell
11:38:57 <nmessenger> Do you intend the final versions to use actual random data?
11:38:58 <zem> don't yet have a feel for what's possible in terms of abstraction
11:39:23 <chessguy> nmessenger, random, but fitting some certain distributions
11:40:47 <nmessenger> You might put the RNG in the state and change from StateT a IO () to State a ()
11:41:32 <chessguy> ok
11:41:39 <chessguy> but that's relatively trivial
11:42:02 <augustss> but important.  you don't want IO if you can avoid it
11:42:07 <nmessenger> I"m not sure if that'll help, abstraction-wise, but more purity never hurt nothin'
11:42:25 <glguy> If you use MonadRandom, you can have: RandomT and State
11:42:30 <glguy> and keep the two states separate
11:43:15 <chessguy> true
11:43:32 <chessguy> i'm more interested in the abstraction part right now though
11:43:37 <glguy> Google Earth is amazing, I don't know why I didn't install it until just now
11:44:23 <svref> glguy: do they have a real linux version yet?
11:44:29 <augustss> glad you found it :)
11:44:38 <glguy> linux version?
11:44:48 <svref> glguy: of google earth?
11:44:53 <siti> yes they do :P
11:44:55 * glguy is no fan of linux
11:45:08 <nmessenger> Google Earth is teh coolness, but I have a sissy dialup :(
11:45:09 <glguy> I stick to windows, os x, and openbsd :)
11:45:24 <siti> lol
11:45:36 <augustss> but with a linux version us bsd folks could run it
11:45:50 <augustss> (well, i'm using a mac os x now)
11:46:00 <glguy> additionally, I don't *sit* at an openbsd box
11:46:06 <glguy> I just use one remotely
11:46:14 <siti> e.g. you use it on the server?
11:46:35 <glguy> it sits 90 miles away on a university campus
11:47:28 <augustss> I've used netbsd on my desktop machines since about 1992, so i figured it was time to try something new.
11:50:03 * mwolak is slightly bitter about google earth right now
11:50:11 <siti> why?
11:50:41 <mwolak> I work at a place that does some GIS stuff... I wrote a quicky script to make some ground overlays
11:51:06 <mwolak> my boss saw it, now I've got to make the quicky script into something more robust over the weekend :/
11:51:19 <siti> ok
11:51:59 <augustss> you shouldn't have shown him until Monday ;)
11:52:00 <mwolak> and since google earth doesn't support XPM transparency right, that means I've got to write a PNG encoder :(
11:53:11 <zem> blech
11:54:30 <paolino> hi, I need to enter multiple (Int,String) arguments on the command line , what do you suggest ?
11:55:40 <augustss> perhaps as '[(3,"foo"),(42,"bar")]' ?
11:56:14 <paolino> ah parse the list all together
11:56:26 <Heffalump> that's the very easy way :-)
11:56:37 <augustss> I like easy.
11:56:41 <nmessenger> > fmap (read . head) getArgs :: IO [(Int,String)]
11:56:42 <lambdabot>   Not in scope: `getArgs'
11:56:52 <Heffalump> if those are all you need to supply it wouldn't be much harder to parse them one at a time
11:57:11 <Heffalump> mapM (fmap read) getArgs :: IO [(Int, String)]
11:58:02 <paolino> '(5,"foo")' format ?
11:58:42 <paolino> I need the '   to escape parenthesis ?
11:58:50 <Heffalump> I think that would work, yes.
11:58:54 <malsyned> is there a function in the prelude to extract the even or odd elements of a list?
11:59:03 <nmessenger> filter even?
11:59:15 <nmessenger> ?type partition even
11:59:17 <lambdabot> forall a. (Integral a) => [a] -> ([a], [a])
11:59:26 <nmessenger> > partition even [1..10]
11:59:28 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
11:59:29 <Heffalump> malsyned: do you mean every other element?
11:59:35 <paolino> ?type even ?
11:59:36 <augustss> You need the ' to escape the parenthesis and the "
11:59:36 <lambdabot> parse error (possibly incorrect indentation)
11:59:36 <Heffalump> rather than the ones that happen to be even numbers
11:59:37 <malsyned> Heffalump: yes
11:59:47 <Heffalump> I don't think so, then
11:59:50 <nmessenger> oh, oops
12:00:01 <malsyned> ?type even
12:00:03 <lambdabot> forall a. (Integral a) => a -> Bool
12:00:09 <nmessenger> > even 2
12:00:10 <lambdabot>  True
12:00:20 <nmessenger> not what you want
12:00:33 <malsyned> nope
12:00:37 <glguy> > map head . takeWhile (not . null) . iterate (drop 2) $ [1,1,1,4,4,4,5,5,6]
12:00:39 <lambdabot>  [1,1,4,5,6]
12:01:13 <paolino> ?type iterate $ drop 2
12:01:15 <lambdabot> forall a. [a] -> [[a]]
12:01:26 <malsyned> paolino: alternately, do {args <- getArgs; [(read x :: Int, y) | x <- evens getArgs | y <- (evens.tail) getArgs]} where evens=!!what glguy said!!
12:01:31 <_roconnor> foldr (\x (a,b) -> (b,x:a)) ([],[]) "hello"
12:01:33 <_roconnor> > foldr (\x (a,b) -> (b,x:a)) ([],[]) "hello"
12:01:35 <lambdabot>  ("el","hlo")
12:02:15 <malsyned> you need ghc extensions for that one
12:02:22 <glguy> http://hpaste.org/123
12:02:29 <glguy> that paste has a split function
12:02:41 <glguy> [a] -> ([a],[a])
12:03:05 <DukeDave> Hey everyone
12:03:27 <DukeDave> a quicky which is annoying me:
12:03:31 <glguy> !paste
12:03:31 <hpaste> Haskell paste bin: http://hpaste.org/
12:03:32 <hpaste>  DukeDave pasted "Sort on second element of tuple" at http://hpaste.org/310
12:03:55 <chessguy> DukeDave, sortBy snd
12:04:08 <glguy> let comparing f x y = f x `compare` f y in sortBy (comparing snd)
12:04:15 <glguy> chessguy: try type checking that
12:04:27 <chessguy> @type sortBy
12:04:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:04:51 <glguy> ?type let comparing f x y = f x `compare` f y in sortBy (comparing snd)
12:04:53 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
12:05:06 <DukeDave> yeah I thought of using snd but can't find a way to use it
12:05:14 <DukeDave> (which is cleaner than current approach)
12:05:19 <glguy> *couldn't*
12:05:21 <chessguy> glguy's right as usual
12:06:20 <DukeDave> lol, well, if I'm still trying to find a way ;)
12:06:35 <glguy> whoa, did anyone else know about Data.FunctorM?
12:06:36 <DukeDave> couldn't is so defeatist ;)
12:06:48 <nmessenger> @type liftM2 compare
12:06:50 <lambdabot> forall a2 (m :: * -> *). (Monad m, Ord a2) => m a2 -> m a2 -> m Ordering
12:06:57 <glguy> DukeDave: couldn't is the past tense, now you know how to do it properly ;)
12:07:05 <nmessenger> for m = ((->) r), isn't that comparing?
12:07:11 <glguy> nmessenger: no
12:07:42 <glguy> ?type liftM2 compare
12:07:44 <lambdabot> forall a2 (m :: * -> *). (Monad m, Ord a2) => m a2 -> m a2 -> m Ordering
12:08:01 <nmessenger> that takes two functions and an argument, we want two arguments for one function, right?
12:08:08 <glguy> yeah
12:08:12 <DukeDave> cheers! ;)
12:08:35 <glguy> ?type \x y -> liftM2 compare ($ x) ($ y) snd
12:08:36 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
12:08:38 <nmessenger> is there a more compact way to write 'pointwise (!) f x y = f x ! f y'?
12:08:53 <augustss> sortBy (compare `on` snd)
12:09:00 <glguy> ?index on
12:09:01 <lambdabot> bzzt
12:09:06 <glguy> I know that is 6.6
12:09:10 <nmessenger> on = pointwise?
12:09:11 <glguy> but I can't ever remember where
12:09:18 <allbery_b> I thought on was HEAD
12:09:20 <augustss> @src on
12:09:21 <lambdabot> (*) `on` f = \x y -> f x * f y
12:09:32 <nmessenger> seems so
12:09:32 <augustss> It's head, I think.
12:09:38 <glguy> ?version
12:09:39 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
12:09:39 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:09:56 <augustss> I find `on` very useful
12:10:25 <zem> @index on
12:10:26 <lambdabot> bzzt
12:10:32 <glguy> lambdabot isn't HEAD
12:10:33 <malsyned> augustss: where is `on` defined?
12:10:41 <sorear> Data.Function
12:10:48 <sorear> @docs Data.Function
12:10:49 <lambdabot> Data.Function not available
12:10:57 <glguy> Data.Function isn't 6.6
12:11:24 <sorear> gah.  It makes links to the HEAD docs, so it can't see HEAD modules!
12:12:25 <augustss> malsyned: Until it is released, just use the one line definition above
12:12:42 <zem>  In function `__stginit_Main_': undefined reference to `__stginit_ControlziMonadziState_'
12:13:03 <Cale> Compile with --make
12:13:04 <zem> anyone know what that's all about? ghc spits out the ld error but ghci links it
12:13:06 <augustss> zem: are you using --make?
12:13:21 <zem> ah
12:13:27 <zem> no, didn't know about that
12:13:29 <Cale> Or -package mtl I think
12:13:39 <zem> --make fixed it, thanks
12:13:42 <Cale> But --make will work out what packages are needed
12:14:04 <astrolabe> perhaps --make should be the default.  One less pitfall for beginners
12:14:07 <zem> that's cool :)
12:15:10 <sorear> data Foo = Bar !Baz  ;  newtype Foo = Bar Baz   --  why do we have both?  and when is the first better?
12:15:38 <augustss> Disallowing the first would be a weird special case
12:16:36 <nmessenger> They should behave similarly
12:16:45 <Cale> actually, they don't
12:16:52 <augustss> It's i the Haskell spirit:  provide two almost equal ways to do everyting ;)
12:16:59 <Cale> data D = D !Int
12:17:05 <Cale> newtype N = N Int
12:17:16 <Cale> d (D k) = 42
12:17:16 <nmessenger> the datatype still adds a misdirection?
12:17:17 <augustss> Cale: well, the behave similarly, but not exactly the same
12:17:22 <Cale> n (N k) = 42
12:17:36 <sorear> Cale: how are they different?
12:17:38 <Cale> Then d undefined = undefined
12:17:43 <Cale> but n undefined = 42
12:18:18 <Cale> also, d (D undefined) = undefined
12:18:26 <Cale> but n (N undefined) = 42
12:19:00 <nmessenger> the ! forces WHNF in D, but the N tag doesn't really exist at runtime, and the pattern match doesn't force any evaluation?
12:19:07 <Cale> right
12:19:28 * nmessenger is starting to get this stuff!
12:19:45 <sorear> IOW (N x) where N is a newtype constructor, is irrefutable ... interesting.
12:19:47 <augustss> you certainly are!
12:20:51 <ihope> @botsmack
12:20:51 <lambdabot> :)
12:20:55 <ihope> Fun.
12:21:17 <augustss> @botstuck
12:21:17 <lambdabot> :)
12:21:25 <nmessenger> @botsmash
12:21:25 <sorear> @botsnake
12:21:25 <lambdabot> Unknown command, try @list
12:21:26 <lambdabot> :)
12:21:41 <Cale> @bootsnake
12:21:41 <lambdabot> Unknown command, try @list
12:21:57 <nmessenger> @bostonack
12:21:58 <lambdabot> :)
12:22:02 <DukeDave> wow so that on function is pretty useful huh!
12:22:10 <augustss> @botsnail
12:22:11 <lambdabot> :)
12:22:21 <allbery_b> what was wrong with comparing?
12:22:33 <allbery_b> (aside from needing to import Data.Ord)
12:22:33 <sorear> @botshack
12:22:34 <lambdabot> :)
12:22:36 <nmessenger> comparing = on compare, on is more general
12:22:39 <nornagon> @botsuck
12:22:40 <lambdabot> :)
12:22:41 <allbery_b> sure
12:22:48 <nmessenger> = (compare `on`)
12:23:24 <DukeDave> I'm not sure I really get the definition:    (*) `on` f =  \x y -> f x * f y
12:23:43 * allbery_b was puzzled by that as well
12:23:48 <nmessenger> how about 'on op f x y = f x `op` f y'?
12:23:51 <sorear> DukeDave: you can't pattern match on a polymorphic function constant :)
12:24:00 <augustss> g `on` f = \ x y -> g (f x) (g x)
12:24:16 <nmessenger> s/g x/f x/
12:24:26 <augustss> yes
12:24:29 <allbery_b> g `on` f = f x `g` f y
12:24:35 <sorear> augustss: you're turning into djinn
12:24:36 * int-e would prefer (?) over (*) in that definition :)
12:24:39 <augustss> (*) is just another name
12:24:47 <nmessenger> /f y/ >.> <.<
12:24:50 <augustss> > let (*) = True in (*)
12:24:52 <lambdabot>  True
12:24:59 <sorear> augustss: s/f x/f y/ :)
12:25:06 <sorear> augustss: classic djinn mistake :)
12:25:12 <augustss> heh
12:25:29 <int-e> > let (?) = (+) in 1 ? 2
12:25:30 <nmessenger> I usually use (!) as a generic op name
12:25:31 <lambdabot>  3
12:25:44 <int-e> but ! is taken. ? is not, afaik.
12:25:52 <augustss> :t \ g f x y -> f x `g` f y
12:25:54 <int-e> @index (?)
12:25:54 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
12:25:54 <lambdabot> bzzt
12:25:58 <sorear> int-e: nmessenger is fixing that!
12:26:11 <augustss> @djinn (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
12:26:12 <sorear> @hoogle (?)
12:26:13 <lambdabot> f a b c _ = a (b c) (b c)
12:26:13 <lambdabot> Did you mean: (?)
12:26:14 <lambdabot> Prelude.undefined :: a
12:26:14 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
12:26:15 <DukeDave> right, well now I need a beer :)
12:26:19 <nmessenger> > let (?) c t f = if c then t else f in (1 < 2 ? "yep" $ "nope")
12:26:21 <lambdabot>      Expecting a function type, but found `Bool'
12:26:21 <lambdabot>       Expected type: a -> b
12:26:21 <lambdabot> ...
12:26:30 <augustss> darn, djinn got it wrong
12:26:41 <nmessenger> grah, no infixr in expressions
12:26:45 <nornagon> > let { (?) = if ; (:) = then } in (1 + 2 == 3) ? "hi" : "foo"
12:26:45 <lambdabot>  Parse error
12:26:49 <int-e> and (?) is also a cute unknown :)
12:26:55 <nmessenger> but it *does* work beautifully
12:27:34 <nmessenger> http://hpaste.org/302
12:27:37 <sorear> but ... I needed (?) to lose 6 chars on my theorem prover! you *can't* take it! noooo!
12:27:45 <nornagon> > let { a ? b = if a then b ; (:) = else } in (1 + 2 == 3) ? "hi" : "foo"
12:27:46 <lambdabot>  Parse error
12:27:48 <nornagon> hmph.
12:27:55 <nornagon> foiled.
12:27:57 <nmessenger> sorear: what, you can't shadow names :P
12:28:13 <int-e> nmessenger: not really.
12:28:14 <sorear> nmessenger: import Prelude hiding(?) is too long.
12:28:33 <int-e> main = let ... in ... :)
12:28:47 <int-e> but that's probably too long, too.
12:28:50 <nmessenger> blah = ... ? ... where (?) = (MyTheoremProver.?)
12:28:53 <SyntaxNinja> y0
12:28:53 <lambdabot> SyntaxNinja: You have 1 new message. '/msg lambdabot @messages' to read it.
12:28:55 <DukeDave> I'm so confused, (*) is just multiplication.. what is it doing in the definition of 'on'
12:28:58 <int-e> sorear: it'd have to be hiding ((?)), wouldn't it?
12:29:12 <sorear> DukeDave: iirc it was an example
12:29:26 <allbery_b> DukeDavce: it's just a name, as used in the definition it's a variable of sorts, shadowing the normal definition
12:29:41 <nmessenger> DukeDave: (*) is a name like any other, 'on' takes an operator-like function, and binds it to (*)
12:29:42 <sorear> oh duh
12:29:44 <sorear> stupid me
12:29:59 <allbery_b> you can shadow names like that, or with let, etc.
12:30:07 <allbery_b> (all of them local)
12:30:08 <nmessenger> on op f x y = f x `op` f y -- is equivalent
12:30:53 <DukeDave> ah gotcha, wow that's simple then :)
12:31:14 <nmessenger> Haskell usually is :D
12:31:15 <augustss> DukeDave: operators are not special in Haskell, they can be rebound and reused like any other identifier
12:31:17 <michaelw> let (?) c cons alt = if c then cons else alt; (.:.) = id in False ? 1 .:. 2
12:31:19 <DukeDave> seems someone was having an "it was hard to write so it should be hard to read" day then :)
12:31:26 <SyntaxNinja> glguy: you rock
12:31:47 <DukeDave> Thanks all though! get it now :)
12:31:55 <glguy> SyntaxNinja: you saw the HAppS example?
12:32:01 <SyntaxNinja> glguy: looking at it now
12:32:06 <SyntaxNinja> it uses HXT not HaXml, 'eh?
12:32:20 <glguy> Right (that's what Cale's original RSS example used)
12:32:26 <int-e> DukeDave: it was inspired by C types - declaration reflects use ;-)
12:32:35 <glguy> I have [] HaXml experience
12:32:57 <SyntaxNinja> glguy: heh
12:33:01 <nmessenger> (the odd C rules for * and [] should really die)
12:33:13 <sorear> C should really die
12:34:52 <DukeDave> I'm surprise 'on' isn't in the prelude then, I assume there is a good reason someone can lecture me on? :)
12:35:23 <nmessenger> nobody thought of it :}
12:35:31 <augustss> that's about it
12:35:32 <int-e> @index on
12:35:32 <lambdabot> bzzt
12:35:37 <allbery_b> probably afraid of breaking xisting programs
12:35:44 <nmessenger> I hear it's in the HEAD, though
12:35:50 <allbery_b> since Prelude is privileged
12:36:01 <allbery_b> it's in Data.Functions not Prelude I thought
12:36:10 <LoganCapaldo> @type (\op f g x -> op (f x) (g x))
12:36:11 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t3) -> (t2 -> t) -> (t2 -> t1) -> t2 -> t3
12:36:12 <nmessenger> oh, yeah
12:36:23 <LoganCapaldo> @type ap
12:36:25 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
12:36:29 <LoganCapaldo> oh
12:36:50 <LoganCapaldo> @pl (\op f g x -> op (f x) (g x))
12:36:51 <lambdabot> liftM2
12:37:11 <nmessenger> @pl (\op f x y -> op (f x) (f y))
12:37:12 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:37:21 <nmessenger> not as sexy-looking :)
12:37:36 <allbery_b> looks a bit dotty to me :)
12:37:40 <LoganCapaldo> huh
12:37:47 <augustss> Hmmm, my djinn gets `on` right
12:37:52 <SyntaxNinja> hxt is big
12:37:57 <LoganCapaldo> where did liftM2 come from?
12:37:57 <emk> Oooooh. GHC supports Unicode operators.
12:37:59 <augustss> Guess I've turned up the search depth
12:38:06 * emk resists the dark side of the force, feebly
12:38:26 <augustss> LoganCapaldo: Neptune?
12:38:30 <nmessenger> LoganCapaldo: the monad in this case is ((->) r), i.e. functions from 'r' to some type
12:38:42 <nmessenger> @type liftM2
12:38:42 <sorear> emk: (virtually?) all haskells support unicode internally
12:38:44 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:38:54 <LoganCapaldo> yeah but why did it give a different answer when you asked?
12:38:55 <sorear> emk: they just can't IO anything but 8859-1
12:38:57 <nmessenger> replace all m with (e ->)
12:39:13 <orbitz> is there a simple way to time a function call in haskell?  or to see how much work ha sbeen done form one moment to the next
12:39:16 <nmessenger> LoganCapaldo: 'cause I asked a different question :)  Look closely.
12:39:28 <LoganCapaldo> ooooooh
12:39:32 <LoganCapaldo> silly me
12:39:33 <emk> sorear: Oh, I don't care about the character set manipulated by my programs right this instant.
12:40:07 <emk> sorear: What pleases me is that GHC reads *.hs files as UTF-8, and allows me to use Unicode operator characters as Haskell operators.
12:40:11 <nmessenger> yours sends an argument to two functions, mine sends two arguments through one function.
12:41:44 <emk> orbitz: GHC has pretty good profiling support.
12:41:45 <sorear> orbitz: nope
12:43:57 <emk> sorear: I'm delighted and horrified that GHC would allow me to write something "nil ▽ cons", and actually treat that as an ordinary expression...
12:44:19 * nmessenger can't see that character, what is it?
12:44:22 <augustss> emk: why horrified?
12:44:30 <augustss> It's a nabla
12:44:35 <siti> lol that's awesome :D
12:44:41 <nmessenger> @wikipedia nabla
12:44:44 <lambdabot> No Result Found.
12:44:49 <siti> lol
12:44:53 <allbery_b> someone fix that plugin :p
12:44:58 <augustss> actually, looks like a triangle
12:45:00 <emk> augustss: Because I firmly intend to abuse this power...
12:45:14 <nmessenger> @all-dicts nabla
12:45:16 <emk> augustss: It's a categorical 'junc' operator.
12:45:16 <lambdabot> *** "nabla" gcide "The Collaborative International Dictionary of English v.0.48"
12:45:16 <lambdabot> del \del\ n. (Math.)
12:45:16 <lambdabot>    a differential operator which, operating on a function of
12:45:16 <lambdabot>    several variables, gives the sum of the partial derivatives
12:45:16 <lambdabot>    of the function with respect to the three orthogonal spatial
12:45:18 <lambdabot> [5 @more lines]
12:45:22 <augustss> emk: power to the power users, that's what I say
12:45:25 <emk> A downward-pointing triangle.
12:45:57 <nmessenger> uh... sure... I *totally* understand that.
12:46:15 * nmessenger whistles
12:47:09 <emk> nmessenger: I'm trying to turn certain bits of math into running Haskell, just for kicks...
12:47:21 <ski> (... 'three' ?)
12:47:33 <emk> In particular, the categorical datatypes in "Comprehending Queries".
12:47:41 <nmessenger> @more
12:47:42 <lambdabot>    coordinates; -- also called the {gradient} or {grad}. It is
12:47:42 <lambdabot>    represented by an inverted Greek capital delta ([nabla]), and
12:47:42 <lambdabot>    is thus because of its shape also called {nabla}, meaning
12:47:42 <lambdabot>    harp in Hebrew.
12:47:42 <lambdabot>    [PJC]
12:48:35 <emk> So it's not the nabla that lambdabot is looking for...
12:48:50 <allbery_b> λx→x*2
12:48:51 <LoganCapaldo> we need nablabot
12:49:00 <LoganCapaldo> nabla the ultimate ..
12:49:11 <LoganCapaldo> the nabla calculus
12:49:25 <ski> emk : junc = [id,id]  ?
12:49:49 <allbery_b> that took too much effort, vnc is annoying sometimes
12:49:58 <mbishop> Nambla calculus? you implement numbers using little boys?
12:50:26 * allbery_b could make a snide joke about Chirch numerals...
12:50:30 <allbery_b> Church
12:50:32 * nmessenger isn't touching going anywhere *near* that one.
12:50:32 <emk> (f `junc` g) x = case x of { Left x' -> f x'; Right x' -> g x'; }
12:50:39 <LoganCapaldo> groooooooooooooan
12:50:40 <nmessenger> s/touching//
12:51:41 <nmessenger> that's not complicated at all.
12:52:01 <sjanssen> @remember mbishop Nambla calculus? you implement numbers using little boys?
12:52:01 <lambdabot> Done.
12:52:07 <ski> emk : ok .. (the '[..,..]' syntax i was using, then)
12:52:25 <LoganCapaldo> Is there a @forget?
12:52:33 <nmessenger> there should be
12:52:35 <mbishop> @alcohol?
12:52:36 <lambdabot> Unknown command, try @list
12:52:37 <mbishop> :)
12:52:38 <sorear> wait...
12:52:41 <nmessenger> @list quote
12:52:41 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
12:52:44 <sorear> junc = |||
12:52:48 <sorear> @ty (|||)
12:52:50 <lambdabot> forall (a :: * -> * -> *) d c b. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
12:52:51 <Cale> @type either
12:52:53 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
12:53:05 * ski nods
12:53:08 <nornagon> @yhjulwwiefzojcbxybbruweejw
12:53:09 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
12:53:11 <mbishop> @quote arr
12:53:12 <lambdabot> metaperl says: Haskell is like the lady who never gets married because there is something wrong with every potential suitor
12:53:17 * nmessenger was thinking either too
12:53:29 <nornagon> @quote monad
12:53:30 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
12:53:45 <nmessenger> @arr!
12:53:45 <sorear> so, now that we have (|||), we don't need either? :p
12:53:48 <lambdabot> Smartly me lass
12:54:43 <nmessenger> either does seem like a (|||) special case
12:55:23 <LoganCapaldo> oooo either is a neato function
12:55:28 <zem> haskell is like the lady who never gets married 'cause she's just too lazy (:
12:55:53 <nmessenger> > either (+1) (ord) (Right 'p')
12:55:55 <lambdabot>  112
12:56:14 <nmessenger> > (+1) ||| (ord) $ (Right 'p')
12:56:16 <lambdabot>  112
12:56:23 <psi> @girl19
12:56:24 <lambdabot> I have been into not actually hacking, but social engineering
12:56:32 <psi> @girl19
12:56:33 <lambdabot> I have been into not actually hacking, but social engineering
12:56:41 <sjanssen> @keal
12:56:41 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
12:56:56 * nmessenger lols
12:57:08 <ski> @protontorpedo
12:57:09 <lambdabot> so why would one prefer haskell to say clisp or smalltalk?
12:57:15 <zem> who or what iss keal?
12:57:21 <LoganCapaldo> @. translate english keal
12:57:21 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "translate"
12:58:10 <ski> zem : a person with schizofrenia
12:58:25 <zem> ah
12:58:32 <nmessenger> an _actual_ person?
12:58:36 <ski> yes
12:58:47 <ski> was here and in #mth some months ago
12:58:51 <ski> #math
12:58:59 <zem> are these actual quotes or parodies/
12:59:04 <ski> actual qoutes
12:59:06 <LoganCapaldo> Theres a #math?
12:59:07 <zem> wow
12:59:09 <zem> @keal
12:59:09 <lambdabot> and yes that was with zero formal training in all realms
12:59:10 <nmessenger> awesome!
12:59:25 <LoganCapaldo> Does that mean theres a programming language called math?
12:59:28 <zem> there is and it's full of people looking for help with their homework :0
12:59:31 <nmessenger> @. elite keal
12:59:32 <lambdabot> i (aN 3xplain \/\/HY zom3T|-|iN9 i$ WI+HoUT KNo\/\/iNg \/\/h47 7he RuleS DECIDed by MaN 4R3
12:59:33 <zem> oh, no, that was undernet
12:59:34 <zem> nevermind
12:59:39 <augustss> keal was for real?  I always thought it was some spoof
12:59:42 <nmessenger> :D
12:59:59 <psi> @keal
12:59:59 <lambdabot> obviously you never heard of Tier. theoretically it would work using nanobots
13:00:01 <ski> augustss : i think he was for real ..
13:00:21 <dhain> hate to interrupt, but i'm trying to get hpaste to compile and i keep getting this: HPasteAdmin.hs:75:19: Not in scope: `thefor', which i've read is because of HaXml, but i've got the darcs version... any ideas?
13:00:22 <augustss> Awesome! :)
13:00:23 <ski> (too strange to be spoof ..)
13:01:04 <sorear> ddhain: you need a newer darcs version.
13:01:35 <dhain> a newer version of darcs or a newer darcs version of haxml?
13:01:42 <sorear> ie pull and try again
13:01:56 <sorear> a newere darcs version of haxml
13:02:04 <dhain> No remote changes to pull in!
13:02:36 <dhain> could it be because i've got 1.13.2 and 1.17 installed at the same timE?
13:02:41 <sorear> uh,dis you recompile and rregester after latest pull?
13:02:49 <sorear> I don't think so
13:03:15 <sorear> are you using the unstable branch?
13:03:27 <dhain> hmm... let me check
13:05:06 <dhain> i'm using the one from http://www.cs.york.ac.uk/fp/darcs/HaXml/
13:05:09 <lambdabot> Title: Index of /fp/darcs/HaXml
13:05:48 <sorear> bah sorry
13:06:01 <sorear> thefor would be in xhtml
13:06:07 <dhain> ahhh
13:06:13 * LoganCapaldo is tempted to create a web page containing <title>Hononary Chairbot</title> and mentioning it in the channel
13:07:23 <dhain> ty sorear
13:07:30 <nmessenger> @ty sorear
13:07:33 <lambdabot> Not in scope: `sorear'
13:10:59 <dhain> yay, it built that time
13:11:05 <LoganCapaldo> can you have a data or a type with the same name as a typeclass? I'd like to see an obfuscated type signature contest for Haskell, and have things like (Num a) => Num a
13:11:26 <sorear> LoganCapaldo: I think so.
13:12:08 <augustss> No
13:12:21 <augustss> classes and types live in the same name space
13:12:30 <augustss> for no particular reason
13:14:03 <sorear> wpw
13:14:04 <Heffalump> has anyone suggested changing that for haskell' ?
13:14:36 <allbery_b> what, we want to encourage obfuscated haskell?
13:15:01 <LoganCapaldo> no, no, perfectly clear Haskell, just obfuscated type signatures :)
13:15:18 <Heffalump> I don't find Num a => Num a confusing, personally.
13:15:29 <Heffalump> well, only marginally
13:17:02 <LoganCapaldo> > let default f x = f ||| (const 1) in [default 0 (+1) $ Left 1, default 0 (+1) $ Right "error"]
13:17:02 <lambdabot>  Parse error
13:17:17 <Heffalump> :-)
13:17:21 <LoganCapaldo> > let default f x = (f ||| (const 1)) in [default 0 (+1) $ Left 1, default 0 (+1) $ Right "error"]
13:17:21 <lambdabot>  Parse error
13:17:44 <LoganCapaldo> lambdabot: be a little more helpful here buddy
13:17:56 <allbery_b> it's more helpful in /msg
13:17:56 <LoganCapaldo> at least give me a line number ;)
13:18:09 <allbery_b> usually
13:18:29 <allbery_b> but not this time.  feh
13:18:40 <augustss> LoganCapaldo: default is a keyword
13:18:48 <LoganCapaldo> AHA
13:18:52 <allbery_b> d'oh, right
13:19:06 <LoganCapaldo> > let def f x = (f ||| (const 1)) in [def 0 (+1) $ Left 1, def 0 (+1) $ Right "error"]
13:19:07 <lambdabot>   add an instance declaration for (Num (a1 -> a))
13:19:53 <Heffalump> 'lo
13:20:17 <augustss> 'lo
13:20:34 <rc-1> http://scienceblogs.com/goodmath/2007/02/basics_the_turing_machine_with_1.php#more
13:20:37 <lambdabot> Title: Good Math, Bad Math : Basics: The Turing Machine (with an interpreter!), http://tinyurl.com/2hqxhz
13:21:07 <rc-1> 5> lambdabot
13:26:38 <DukeDave> @src unionBy
13:26:38 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
13:27:57 <LoganCapaldo> > let def f x = (f ||| (const 1)) in [def (+1) 0 $ Left 1, def (+1) 0 $ Right "error"]
13:27:58 <lambdabot>  [2,1]
13:28:02 <LoganCapaldo> slly me
13:28:10 <LoganCapaldo> getting my own arg order wrong
13:28:49 <LoganCapaldo> > let def f x = (f ||| (const 1)) in (def (+1) 0 $ Just 2, def (+1) 0 $ Nothing)
13:28:50 <lambdabot>  Couldn't match `Either b c' against `Maybe a'
13:29:01 <LoganCapaldo> ||| doesn't work for Maybe?
13:29:12 <LoganCapaldo> drat
13:29:20 <LoganCapaldo> @type (|||)
13:29:21 <lambdabot> forall (a :: * -> * -> *) d c b. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
13:29:41 <LoganCapaldo> Oh it makes sense
13:30:53 <LoganCapaldo> @instances ArrowChoice
13:30:54 <lambdabot> (->), Kleisli m
13:31:13 <LoganCapaldo> @where Kleisli
13:31:13 <lambdabot> I know nothing about kleisli.
13:31:51 <sorear> LoganCapaldo: Control.Arrow
13:31:58 <sorear> @docs Control.Arrow
13:31:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
13:32:07 <sorear> and the command you want is
13:32:17 <sorear> @index Keisi
13:32:17 <lambdabot> bzzt
13:32:19 <LoganCapaldo> @where IditotsGuideNotDocsForSmartPeople ;)
13:32:19 <lambdabot> I know nothing about iditotsguidenotdocsforsmartpeople.
13:32:22 <sorear> @index Kleisi
13:32:23 <lambdabot> bzzt
13:32:34 <allbery_b> @index Kleisli
13:32:35 <lambdabot> Control.Arrow, Control.Arrow
13:32:36 <sorear> gah.
13:33:07 <sorear> we need levenschtein for symbol
13:33:09 <sorear> s
13:34:00 <sjanssen> @hoogle kleisi
13:34:01 <lambdabot> No matches found
13:34:08 <sjanssen> @hoogle kleisli
13:34:08 <lambdabot> Control.Arrow.Kleisli :: a -> m b -> Kleisli m a b
13:34:09 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
13:34:09 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
13:35:01 <sorear> shouldn't the second be Control.Arrow.Kleisli :: (* -> *) -> * -> * -> * ? :)
13:35:49 <sjanssen> @hoogle Prelude
13:35:50 <lambdabot> Prelude :: module
13:35:50 <lambdabot> Language.Haskell.Syntax.prelude_mod :: Module
13:35:50 <lambdabot> Distribution.Extension.NoImplicitPrelude :: Extension
13:37:33 <kowey> zem: feel free to ask questions on the wxhaskell-users list as well
13:37:46 <zem> thanks, will do
13:41:00 <kolmodin> good night!
13:42:18 <augustss> did we get Kleisli composition included in in head now?
13:43:42 <sorear> augustss: yes
13:43:58 <augustss> what's it called?  an where?
13:45:05 <sorear> >=> i think, control.monad
13:45:49 * sorear runs ghci...
13:46:46 <augustss> Hmmm, my emoticon translator turned whatever it was you wrote into a little devil
13:47:02 <Anon4888> > = >
13:47:03 <lambdabot>  Parse error
13:47:05 <LoganCapaldo> Many of the monad operators look like fish to me
13:47:37 * LoganCapaldo wonders if augustss will now get a stretched out devil
13:47:38 <monomorph> Haskell is an emoticon language.  (:)
13:47:43 <augustss> Hmmm, ok
13:47:59 <augustss> how the heck will I remember that one
13:48:20 <augustss> there are only so many permutations of <=> that will fit
13:48:24 <LoganCapaldo> think of it as the little deviloperator?
13:48:27 <monomorph> Try them all.
13:48:48 <proma1> anyone implemented minimax algorithm? i'm getting stack overflow...
13:48:58 <proma1> need some help
13:49:38 <LoganCapaldo> Stop recursing infinitely ;)
13:49:49 <siti> :D
13:49:57 <LoganCapaldo> > fix fix
13:49:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
13:49:58 <lambdabot>       Expec...
13:50:17 <augustss> > fix id
13:50:18 <lambdabot>  Add a type signature
13:50:19 <siti> proma1: I have implemented a few min-max algos, although resonably complex
13:50:25 <siti> first was ugly when I was a noob at haskell
13:50:26 <LoganCapaldo> > fix id :: ()
13:50:27 <siti> :(
13:50:28 <lambdabot>  Exception: <<loop>>
13:50:31 <siti> but I could try and help
13:51:22 <LoganCapaldo> > fix id 1
13:51:23 <lambdabot>  Add a type signature
13:51:31 <LoganCapaldo> > fix id 1 :: (Num a) => a
13:51:33 <lambdabot>  Exception: <<loop>>
13:51:36 <LoganCapaldo> hey now
13:51:56 <LoganCapaldo> that shouldn't loop :)
13:52:16 <sorear> LoganCapaldo: no, it's _|_
13:52:35 <sorear> _|_ is the least fixed point of id, since id is strict
13:52:45 <LoganCapaldo> Oh id is strict?
13:53:00 <Axioplase> Not that I want to sue them, but is it possible to have equi-recursive types in haskell ?
13:53:05 <LoganCapaldo> > let lazy_id x = x in fix lazy_id 1 :: (Num a) => a
13:53:06 <lambdabot>  Exception: <<loop>>
13:53:12 <LoganCapaldo> Hmm
13:53:14 <sorear> LoganCapaldo: yes.
13:53:14 <sorear> Axioplase: yes
13:53:23 <LoganCapaldo> I guess you can't write a lazy id huh?
13:53:32 <sorear> LoganCapaldo: your lazy_id is strict
13:53:38 <LoganCapaldo> lol
13:53:42 <Axioplase> sorear: I'm curious... could you tell me how ?
13:53:48 <sorear> LoganCapaldo: id is by definition strict
13:54:16 <augustss> LoganCapaldo: it would be a feat to write a lazy id.  What would it return?
13:54:17 <proma1> siti: I at dinner time so I'll be back later... so can I boder you then?
13:54:23 <sorear> Axioplase: data Equi = Equi (Equi -> Bool)  --aiui
13:54:28 <siti> proma1: most likely...
13:54:33 <LoganCapaldo> A thunk? :)
13:54:36 <jcreigh> > length $ map id (replicate 10 undefined)
13:54:37 <lambdabot>  10
13:54:38 <proma1> yks ;)
13:54:43 <Axioplase> thanks
13:54:51 <Anon4888> data constructors are lazily evaluated... applications strictly
13:55:04 <augustss> LoganCapaldo: but you're only calling id because you need the value, so the thunk would get forced at once
13:55:04 <LoganCapaldo> > let id x = const x in fix id 1 :: (Num a) => a
13:55:05 <lambdabot>   (b -> a) -> b -> a
13:55:05 <lambdabot>       Inferred type: (b -> a) -> b -> b -> a
13:55:16 <LoganCapaldo> > let id x = const x in fix $ id 1 :: (Num a) => a
13:55:18 <lambdabot>  1
13:55:21 <LoganCapaldo> hehehehe
13:55:39 <LoganCapaldo> too bad about the cheating
13:56:10 <sorear> const undefined is also strict!
13:56:36 <augustss> sure is
13:56:54 <LoganCapaldo> but I said const 1 not const undefined
13:57:01 <LoganCapaldo> So its fine
13:57:13 <sorear> const 1 is non-strict
13:57:22 <augustss> > fix (const (1::Int))
13:57:23 <lambdabot>  1
13:57:31 <LoganCapaldo> now I just need a haskell with different rules for parsing function application so I could write it as fix id 1
14:01:36 <monomorph> try to force evaluation of numerical parameters.
14:01:37 <monomorph> If you have seen foldl vs. foldl' you know what's going on.
14:01:43 <monomorph> foldl (+) 0 (long list) ==> stack overflow.  foldl' (+) 0 (long list) ==> ok.  This is because foldl' tries to force evaluation of the partial sum before going on.
14:03:29 <emk> It's impossible to define an Id or K functor in Haskell, right?
14:03:39 <emk> type Id a = a, etc...
14:04:14 <sorear> sure you can.
14:04:39 <LoganCapaldo> type K a b = a
14:04:39 <sorear> Haskell has full type level lambdas - the catch is you have to bring your own equality proofs.
14:04:50 <sorear> newtype K a b = K a
14:05:13 <sorear> newtype S a b c = S (a c (b c))
14:05:22 <Axioplase> does ghc --make handle automatically dependencies ? ot just the trivial ones ?
14:05:24 <sorear> newtype I a = I a
14:05:25 <vincenz> sorear: K is phanto
14:05:27 <vincenz> m
14:06:00 <sorear> vincenz: whah?
14:06:29 <hpaste>  emk pasted "Id Functor unhappy" at http://hpaste.org/311
14:07:12 <vincenz> sorear: K is a phantom type in b
14:07:25 <emk> sorear: Ah, so I should make it not reduce down to "a"?
14:07:51 <augustss> Axioplase: --make handles dependencies
14:08:17 <hpaste>  sorear annotated "Id Functor unhappy" with "newtypes are sufficiently powerful, synonyms aren't" at http://hpaste.org/311#a1
14:08:44 <emk> sorear: Hmm. Let me think about whether that will do what I want in the code in question...
14:08:55 <emk> And thanks!
14:09:36 <Axioplase> augustss: alright, thanks.
14:09:38 <sorear> emk: the Id and unId in the fmap declaration are what I called "your own equality proofs".  Haskell can't infer them because it's undecidable
14:11:07 <emk> I'm trying to implement the polynomial functors in Haskell so I can define F-algebras the hard way, so that's why I need K and Id.
14:11:17 <jcreigh> I can't resolve nomaware.com
14:11:33 <jcreigh> Is this just me?
14:11:40 <allbery_b> been gone for a couple weeks I think
14:11:42 <allbery_b> :(
14:13:32 <bd_> archive.org? :/
14:14:43 <jcreigh> Google cache works.
14:15:40 <jcreigh> ...for now.
14:16:19 <dons> morning al
14:16:23 <dons> l
14:16:29 <astrolabe> morning don
14:16:30 <astrolabe> s
14:16:34 <chessguy> 'evening, don
14:16:34 <sjanssen>  good morning
14:16:34 <chessguy> s
14:16:44 <emk> sorear: The constant functor has an entertaining definition of fmap:
14:16:45 <emk> fmap f (K a) = K a
14:16:56 <dons> ah good, we're still climbing, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
14:16:58 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/lepfo
14:17:00 <dons> another couple of points over night
14:17:14 <dons> mm. i wonder if we can get past SML today
14:17:49 <ddarius> emk: What's entertaining about that?
14:18:34 <emk> ddarius: I'm easily amused by the fact that the two Ks have different types for their phantom element.
14:18:35 <chessguy> past SML? it looks to me like haskell is ahead of SML
14:19:13 <dons> there's a couple of dodgy haskell entries that drag things back, and 2 broken ones
14:19:39 <proma1> siti: i'm getting stack overflow when computing minimax
14:20:22 <ddarius> dons: Are there entries for every benchmark?
14:20:29 <proma1> siti: i have makeGameTree wich computes all possible moves with depth N
14:21:14 <mwolak> WOOOHOOO... I made a valid png file :)
14:21:21 <dons> ddarius: there are, but the update to 6.6 broke two, and we can write a number of others much much more efficiently now
14:21:25 <proma1> siti: at leafs I compute the heuristic
14:21:26 <dons> (e.g. sum-file ;)
14:21:27 <sorear> yay!
14:21:29 <proma1> thats corrent
14:21:36 * sorear <3 VM
14:22:06 <proma1> siti: then at nodes I compute the maximum/minimum child
14:22:41 <hpaste>  csci pasted "Strange label-problem with gtk2hs" at http://hpaste.org/312
14:22:45 <proma1> whats the cause of stack overflow? depth firt search?
14:22:52 <chessguy> proma1, what game are you doing?
14:23:00 <fasta> For some reason the code only compiles when I supply a type signature. What's the usual reason for this happening? I only use MonadState .
14:23:01 <csci> Any gtk2hs experts here? :)
14:23:13 <proma1> hmmm don't know the english name
14:23:30 <proma1> chessguy: but i win if i have N pieces in line
14:23:31 <csci> mwolak, What lib where you using?
14:23:32 <fasta> Inferred type is less polymorphic than expected
14:23:32 <fasta>       Quantified type variable `a' is mentioned in the environment:
14:23:40 <proma1> chessguy: 4-connect?
14:23:47 <mwolak> csci: I'm writing a png lib
14:23:50 <fasta> That's what I get when I remove the type signature.
14:23:55 <chessguy> connect 4
14:23:59 <csci> mwolak, Great. Would use it :)
14:24:04 <ddarius> Axioplase: Haskell has iso-recursive types, not equirecursive types... at least not in any obvious way.
14:24:05 <proma1> chessguy: have you done minimax ?
14:24:11 <sjanssen> fasta: generally the monomorphism restriction would cause that
14:24:20 <chessguy> proma1, sure
14:24:30 <mwolak> csci: it's real rough at the moment, have to clean it up a bit, but at least I know the parts are right :)
14:24:50 <chessguy> i've done chess AI, though not in haskell
14:24:59 * ddarius is happy impredicativity was implemented, albeit a flag to turn it off would be nice.
14:25:08 <csci> mwolak, I hope you'll announce it in haskell-cafe, when you have some working parts :)
14:25:15 <proma1> chessguy: any orientation? I googled but I can't eliminate stack overflow error
14:25:25 <proma1> I've done minimax in C
14:25:36 <mwolak> csci: will do
14:25:38 <ddarius> proma1: Wo ist das Kode?
14:25:39 <chessguy> hmm. what depth are you searching to?
14:25:50 <proma1> ddarius: what?
14:25:59 <ddarius> proma1: Where is the code?
14:26:05 <proma1> of?
14:26:09 <proma1> minimax haskell?
14:26:18 <ddarius> The code that is overflowing.
14:26:37 <fasta> sjanssen: hmm, normally ghc says:" probable cause <...> monomorphism restriction". You were right, thanks.
14:26:45 <astrolabe> If you are hanging on to the whole tree, that might cause an overflow
14:26:46 <proma1> ddarius: one monent.. its on other machine... ill paste
14:27:24 <chessguy> proma1, i highly recommend reading "Why functional programming matters" for a discussion of lazy minimax
14:27:28 <chessguy> ?where whyfp
14:27:29 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
14:27:58 <astrolabe> But I don't think a full depth search is practical for connect 4,  you need something like proof-number search
14:28:32 <chessguy> full depth search? you mean searching until the game is over?
14:28:56 <proma1> well i'm getting stack overflow with a gametree with height 2
14:29:00 <proma1> strange..
14:29:14 <chessguy> yeah, that's not good
14:29:17 <Axioplase> ddarius: yes, I found some threads about that on mailing lists.
14:29:35 <siti> proma1: where's your code?
14:29:37 <astrolabe> chessguy yes
14:29:47 <chessguy> you're doing something wrong in the recursion then
14:29:56 <hpaste>  proma1 pasted "minimax (partial)" at http://hpaste.org/313
14:30:07 <proma1> there it is
14:31:28 <astrolabe> Maybe your tree has no bottom
14:31:44 <Axioplase> I'd say list astrolabe
14:31:47 <chessguy> how embarrassing
14:31:57 <hpaste>  proma1 pasted "minimax (partial 2)" at http://hpaste.org/314
14:32:17 <proma1> astrolabe: yes it has
14:32:21 <fasta> Anyone knows how to disable Google suggest in Iceweasel?
14:32:31 <siti> woah man, use map not listcomprehensions ;)
14:32:34 <fasta> Never mind
14:32:55 <proma1> I do minimax [] $ makeGameTree game depth
14:33:06 <chessguy> hmm, i don't see where you're decreasing the search depth in the recursion
14:33:14 <proma1> siti: why?
14:33:38 <proma1> siti: map is a listcomprehension right?
14:33:40 <siti> proma1: just my personal perference, you can keep what you like, It'll take me longer to process the code ;)
14:33:48 <proma1> ok
14:33:56 <fasta> proma1: I agree, for what it's worth.
14:34:12 <fasta> proma1: (that is: I agree with siti)
14:34:25 <chessguy> proma1, unfortunately, i'm on my way to a super bowl party. but i highly, highly recommend you read that paper. i'll message you my email address for if you can't figure out the problem
14:34:30 <proma1> yes that makes sence
14:34:50 <proma1> chessguy: tks ;)
14:35:19 <proma1> siti: anyway $! shouldn't evaluate the right side first?
14:35:19 <astrolabe> proma1: could a parent node have an infinite number of children?
14:35:33 <proma1> astrolabe: no
14:35:42 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/315
14:35:55 <proma1> astrolabe: possibleMoves returns only the valud moves one player can make
14:35:59 <siti> http://hpaste.org/315 <-- this is a relveant section of my code
14:36:19 <proma1> In my test case I have a board with size 3x3...
14:36:22 <siti> it might be confusing because there is no background
14:36:29 <largos> does anyone know if the "meet the monads" tutorial is available anywhere? (the version at nomawmare.com is down :( )
14:36:43 <siti> I found it by searching for the zip file
14:36:48 <siti> do google cache on the that
14:36:49 <siti> site
14:36:52 <siti> find zip file name
14:36:53 <siti> google it
14:36:56 <largos> ah, cool.
14:36:59 <siti> there's a file somewhere about 5 results down
14:37:01 <proma1> siti: looking your paste
14:37:09 <astrolabe> proma: do you know about Debug.Trace?
14:37:11 <largos> I found the cached pages, but didn't thing to look for an archive
14:37:44 <siti> it might be a bit weird because this stops after a certain amount of processing has been done
14:40:50 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-misc see section 4.14.5 option -xc
14:40:53 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/d7dj4
14:44:36 <yaxu> anyone got lhs2tex working under ubuntu edgy?
14:45:02 <siti> proma1: well in your code aren't you always adding more to the moves list? (mvs ++ [m])
14:45:14 <siti> so it's never going to get pattern matched with [] therefore never exiting..
14:45:42 <siti> arg oops, I am dumb, don't worry ;)
14:56:02 <hyrax42> mvs ++ [m] will get slow pretty quickly
14:56:30 <rc-1> a good name for this channel would be monaddib :)
14:56:40 <rc-1> (as in dune)
14:56:52 <hyrax42> rc-1: I was going to ask if that's what you meant
14:58:33 <sorear> @seen Muad_Dib
14:58:34 <lambdabot> Muad_Dib is in #haskell.dut, #haskell-blah and #haskell. I don't know when Muad_Dib last spoke.
14:58:39 <sorear> @uptime
14:58:39 <lambdabot> uptime: 5d 1h 7m 12s, longest uptime: 5d 1h 7m 12s
15:03:27 <proma1> ping?
15:03:54 <dons> pong.
15:03:56 <proma1> astrolabe: you were talking about Debug.Trace?
15:04:02 <proma1> dons: =)
15:04:20 <proma1> http://hpaste.org/313
15:04:44 <proma1> need help on minimax implementation and stack overflow exception
15:05:27 <hyrax42> proma1: I've done it but differently from yours
15:05:35 <proma1> hyrax42: like?
15:05:51 <hyrax42> in Gametree a b is a the game state?
15:06:04 <proma1> a is the board
15:06:08 <proma1> and b is the move
15:06:16 <Anon4888> Is hpaste the tool glguy wrote?
15:06:17 <hyrax42> and you can drop the Show a, Show b contstraint unless you really want it
15:06:23 <hyrax42> Anon4888: yup
15:06:28 <Anon4888> It looks pretty good now
15:06:50 <proma1> hyrax42: yes I can drop them
15:07:12 <hyrax42> proma1: I had something liek this
15:07:31 <proma1> can you paste?
15:07:38 <hyrax42> yeah I guess so
15:08:04 <proma1> hyrax42: tks
15:09:03 <proma1> :S
15:09:07 <proma1> =P
15:09:45 <hyrax42> hmm some of the code is extraneous, let me pick the relevant functions
15:09:57 <proma1> ok
15:10:02 <dcoutts> @tell csci take a look at the gtk2hs concurrency demos, that'll fix your issue.
15:10:02 <lambdabot> Consider it noted.
15:10:48 <Anon4888> proma - how deep is your game tree?
15:11:56 <proma1> Anon4888: with depth 1 it gives stackoverflow
15:12:28 <siti> proma1: do you have a full module so I can play with it?
15:12:29 <proma1> if I do Prelude> makeGameTree game 1
15:12:44 <proma1> it shows the tree
15:12:54 <proma1> siti: yes
15:14:22 <hpaste>  proma1 pasted "N-connect game with minimax (unit test at the end)" at http://hpaste.org/316
15:14:29 <Anon4888> oh wait, aren't the order of your compare & return values wrong?
15:14:41 <Anon4888> fooo (a,_) (b,_) = compare a b
15:14:42 <proma1> ops
15:14:45 <Anon4888> fooo (a,_) (b,_) = compare a b
15:14:46 <proma1> paste too king
15:14:50 <Anon4888> minimaxAI mvs (GameTree n []) = (mvs, heuristic n)
15:14:53 <hpaste>  hyrax42 annotated "minimax (partial)" with "Minimax with Data.Tree" at http://hpaste.org/313#a1
15:15:03 <Anon4888> don't you want to compare the heuristics?
15:15:15 <proma1> Anon4888: yes
15:15:19 <Anon4888> ie. the second element in the pair, not the first
15:15:31 <proma1> siti: mail?
15:15:54 <siti> what for?
15:16:03 <hyrax42> proma1: your way may be less ugly not sure
15:16:16 <hyrax42> I was feeling lazy
15:16:26 <Anon4888> proma1: are you agreeing that's a bug?
15:16:41 <proma1> Anon4888: checking wait
15:17:13 <proma1> I don't understand why it gives stack overflow with a tree with depth 1...
15:17:30 <proma1> and if I evaluate step by step then it gives the correct result
15:18:29 <Anon4888> I don't see why it doesn't terminate... but that does look like a bug to me
15:18:31 <Anon4888> Am I wrong?
15:18:59 <Anon4888> You're returning the heuristic in the second item of the pair, but comparing the first items... no?
15:19:54 <proma1> well Anon4888 that a F***ing good point
15:19:59 <proma1> =)
15:20:08 <Anon4888> What does compare do to lists?  Maybe that's why it's diverging?
15:20:17 <proma1> making changes
15:22:09 <hyrax42> ?pl \f (a,b,c) -> f a b c
15:22:10 <lambdabot> (line 1, column 8):
15:22:10 <lambdabot> unexpected ","
15:22:10 <lambdabot> expecting letter or digit, operator or ")"
15:22:10 <lambdabot> ambiguous use of a non associative operator
15:22:18 <LoganCapaldo> Is this sort of type possible? changeM :: (Change m1 m2, Monad m1, Monad m2) => m1 a -> m2 a
15:22:37 <LoganCapaldo> where m1 could be Maybe and m2 could be [] for instance
15:22:38 <proma1> well guys Anon4888 has sharp eyes
15:22:49 <proma1> sorry my stupidity
15:22:59 <Anon4888> cool - what did I win :)
15:23:12 <proma1> chocolate?
15:23:13 <proma1> :P
15:23:16 <proma1> tks guys
15:23:42 <proma1> it was comparing list of moves (game tree paths), not heuristics
15:37:04 <araujo> hello
15:40:49 <dons> hey araujo
15:42:57 <araujo> dons, hi there, how you doing?
15:43:57 <dons> good!
15:45:09 * araujo been a bit away from the haskell community
15:45:29 <araujo> anything interesting going on?
15:45:39 * basti_ disassembled a scanner
15:45:47 <basti_> that had nothing to do with haskell, but it was interesting
15:45:47 <dons> hmm, we have hpaste.org now :)
15:45:54 <slowriot> So has anyone here used Erwig's fgl much?
15:46:12 <hpaste> pong
15:46:29 <dons> what else. oh, the shootout is being revived. e.g. http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all  :)
15:46:32 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
15:46:32 <dons> slowriot: yeah, a little
15:46:38 <dons> it badly needs more haddock documentatoin
15:46:51 <slowriot> haddock?
15:47:10 <dons> the doc generating tool
15:47:20 <araujo> slowriot, i used it a bit time ago
15:47:27 <araujo> dons, yeah, nice
15:47:37 <slowriot> I've read his original paper, which is good, but I am curious about the current implementation in haskell. Are there any tutorials for it anywhere?
15:47:49 <basti_> dons: great think :)
15:47:50 <basti_> g
15:48:12 <araujo> slowriot, there is a very good one on the fgl site
15:48:33 <slowriot> the userguide seems a bit outdated
15:54:18 <dons> sjanssen: yow! http://twan.home.fmf.nl/compact-string/
15:54:20 <lambdabot> Title: Data.CompactString
15:54:33 <dons> ?where+ compact-string http://twan.home.fmf.nl/compact-string/
15:54:33 <lambdabot> Done.
15:55:41 <slowriot> maybe it isn't
15:55:48 <slowriot> I'm looking through the change list
15:56:12 <slowriot> the first thing the tutorial mentions is the embed function for creating graphs, but I can't find that on haskell.org
15:57:14 <dons> you can't find what? fgl?
15:57:31 <slowriot> embed
16:01:17 <hpaste>  defcon8 pasted "please help" at http://hpaste.org/317
16:01:20 <slowriot> Well, I just asked about it in this channel to make sure there isn't some up-to-date user guide that I don't know about. I'll spend some time messing around with fgl. I'll figure it out eventually.
16:02:31 <defcon8> can anyone tell me why I'm getting an error for line 4, please?
16:02:47 <dons> what error do you get?
16:03:02 <nominolo> defcon8: you're missing an = sign
16:03:07 <nominolo> after otherwise
16:03:19 <defcon8> ahh, thanks
16:04:02 <mbishop> translating sicp exercises into haskell? :)
16:04:06 <defcon8> yeah
16:04:18 <defcon8> that didn't seem to work :|
16:04:55 <defcon8> oh I forgot to do guess^2
16:05:24 <defcon8> works fine now :D
16:06:12 <mbishop> Heh, all this good coder/bad coder stuff on reddit makes me want to write a silly reply
16:06:39 <defcon8> I hate the people on sites like digg and reddit
16:07:02 <defcon8> most of them are lame
16:07:04 <dons> heh
16:07:51 <norp> most people are lame everywhere
16:08:29 <basti_> most people are lame most of the time
16:08:52 <basti_> thats some kind of a corollary to warhols bonmot of everybody being famous for 15 minutes one day
16:08:53 <mbishop> lambdabot: Are you lame?
16:08:56 <defcon8> well it seems they congregate around digg
16:09:18 <dons> that's pretty much uncontested :)
16:09:30 <mbishop> defcon8: the solution is obvious, blow it up, and hope the fallout gets them all
16:09:35 <dons> though 'lame' might be too polite :)
16:09:39 <defcon8> oh yeah
16:09:48 <norpan> i'm lame too
16:10:25 <defcon8> I want to make haskell find the perfect blackjack cardcounting algorithm
16:10:37 <dons> @keal
16:10:38 <lambdabot> evaluating expressions is ALL haskell does?????
16:10:47 <basti_> I'd use a proofchecker for that
16:10:49 <defcon8> I must first read up on dicrete mathematics and then I will go on to my world domination
16:10:54 <basti_> whats keal?
16:11:19 <defcon8> @2+2
16:11:20 <lambdabot> Unknown command, try @list
16:11:28 <defcon8> how do I make her do stuff?
16:11:47 <norpan> > 2+2
16:11:48 <lambdabot>  4
16:13:42 <mbishop> Let's see how much I can stur the pot
16:13:44 <mbishop> http://programming.reddit.com/info/12v3g/comments
16:13:46 <lambdabot> Title: Criticism of C++ (PDF) (reddit.com)
16:13:48 * mbishop rubs his hands together
16:14:53 <defcon8> I like commenting on digg with the soul intention to be the most "dugg-down"
16:15:29 <defcon8> damn it, only -1 digg on my last comment
16:19:58 <defcon8> mbishop, you use ada?
16:20:02 <mbishop> No
16:20:08 <sorear> tell fodder
16:20:36 <sorear> gah, jhc has spent over an hour optimizing System.Locale
16:23:15 <mbishop> oops
16:23:18 <mbishop> just noticed my link is wrong
16:23:56 <mbishop> http://programming.reddit.com/info/12v51/comments
16:23:58 <lambdabot> Title: Criticism of C++ (PDF) (reddit.com)
16:23:59 <mbishop> there, that's better
16:25:57 <augustss> @seen igloo
16:25:57 <lambdabot> igloo is in #haskell.hac07, #ghc, #darcs and #haskell. I last heard igloo speak 10h 1m 50s ago.
16:26:29 <Igloo> augustss: Yup?
16:27:06 <sorear> @users
16:27:07 <lambdabot> Maximum users seen in #haskell: 322, currently: 291 (90.4%), active: 42 (14.4%)
16:27:10 <augustss> just wanted to tell you i've sent some email to cvs-bugs, so it doesn't fall into /dev/null
16:28:11 <Igloo> augustss: OK, thanks; I'm looking at the HsRecordBinds one right now as it happens  :-)
16:28:19 <sorear> CPU Temp:  +61.0 C  (low  =   +10 C, high =   +60 C)   ALARM
16:28:27 <sorear> yay jhc
16:28:34 <augustss> heh
16:29:19 <augustss> Igloo: the record wildcard extension would make Bulat happy ;)
16:29:27 <sorear> I suppose it would be faster if I wasn't using +RTC -c :)
16:29:34 <sorear> er, +RTS -c
16:31:45 <Igloo> augustss: Shouldn't HsRecordBinds be a newtype rather than data?
16:32:43 <Igloo> I guess it doesn't really matter
16:33:07 <augustss> Igloo: it get's a second constructor in my later patch :)
16:33:16 <Igloo> Ah, OK  :-)
16:35:13 <sorear> grr. /me gives up and downloads the precompiled libraries.
16:36:22 <slowriot> is there anything in haskell like "dir" in python?
16:36:40 <augustss> sorear: good luck.  I've never been able to compile anything with jhc.  the precompiled libraries were incompatible with my jhc somehow
16:37:06 <augustss> slowriot: and what's dir in python?
16:37:11 <sorear> slowriot: no.  haskell's staticness allows compilers to discart that info.
16:37:17 <Igloo> slowriot: No, although TH comes vaguely close
16:37:18 <sorear> slowriot: HOWEVER, ghci allows :br
16:37:28 <LoganCapaldo> slowriot, looks like show would be the closest
16:37:38 <LoganCapaldo> if I'm reading help(dir) correctly
16:37:40 <sorear> slowriot: e.g. :br System.IO
16:37:55 <slowriot> ah, just what I was looking for. Thanks, sorear
16:37:57 <sorear> slowriot: also look at Data.Generics
16:38:05 <sorear> slowriot: yw.
16:38:23 <sorear> wow, I'd totally forgotten that dir works on non-modules
16:38:39 <sorear> <-- not an experienced pythoner
16:38:57 * LoganCapaldo has never written a program in python
16:39:54 * augustss has only looked at Python code
16:39:59 <hyrax42> pretty sure there is no equivalent to dir
16:40:23 <dons> Igloo: btw, you had a need fro this fromForeignPtr/toForeignPtr api change in bytestring?
16:40:34 <Igloo> dons: Yes
16:40:50 <dons> ok. i'll just have to bite the bullet then :)
16:41:06 <Igloo> dons: Because it's an API change, you mean?
16:41:25 <sorear> augustss: Loading library ./base-1.0.hl failed due to missing dependencies  <---  your error?
16:41:58 <augustss> sorear: I can't remember, but something like that
16:43:16 <sorear> augustss: I'll report it on the mailing list, start another source build tonight, and if I succeed I'll put the (compatible with darcs jhc) libs on my webhost.
16:46:10 <dons> Igloo: right, and its a widely used functoin (relatively)
16:47:38 <Igloo> *nod*
16:47:51 <Igloo> Only in Base though, at least
16:48:08 <Cale> ""The critique is long; it would be good if it were shorter, but that would be possible only if there were less flaws in C++."
16:50:51 <Korollary> God. 60 pages of drivel
16:51:23 <augustss> Igloo: so I noticed that IsString is no longer exported from the Prelude.  That, of course, means that my test case no longer compiles.  What's the official way to bring IsString into scope now?
16:51:51 <jcreigh> and an annoying two-column layout that's hard to read on a PC.
16:52:58 <Cale> jcreigh: what makes it hard to read?
16:53:38 <Igloo> augustss: Oh, don't worry about it, I'll fix it once the proposal goes through
16:53:44 <Korollary> scrolling up and down in one page
16:53:45 <jcreigh> Cale: I hate having to constantly scroll up and down.
16:53:47 * Igloo should have put a shorter deadline on it
16:54:20 <Igloo> augustss: If you want to use it locally then I think you'll need to get it from GHC.Base
16:54:34 <Igloo> Or apply the patch from the proposal to your repo
16:54:36 <augustss> I use it daily :)
16:54:54 <augustss> But GHC.Base is fine for now
16:55:40 <Igloo> Well, applying the patch and using Data.String will mean you won't have to go through changing all the imports later (assuming no-one objects)
16:57:01 <augustss> it's a one line change in our code base, no big deal
16:57:50 <augustss> now, if we could just get overloaded booleans as well I'd be happy
16:58:00 <Igloo> heh
16:58:03 <augustss> but that's not easy
16:58:13 <augustss> not easy to do nicely
17:02:59 <sorear> augustss: hehe - the format has *definitely* changed - the precompiled libs aren't gzipped, my repo has lib-gzipping code.
17:03:35 <augustss> sorear: yeah, that sounds like a change all right!
17:03:46 <sorear> so I'm running nice -20 jhc, will check back in 14hrs.
17:03:49 <cpfr> hey is there a sqlite library for haskell?
17:05:30 <newsham> > length $ takeWhile ((<= 2.0).magnitude) $ take 256 $ iterate (\x -> x*x + (0.1 :+ 1.3)) 0
17:05:32 <lambdabot>  2
17:05:45 <newsham> > length $ takeWhile ((<= 2.0).magnitude) $ take 256 $ iterate (\x -> x*x + (0.1 :+ 0.9)) 0
17:05:47 <lambdabot>  5
17:05:52 <sorear> now, if my system had 30% more RAM, jhc wouldn't be swapping and probably be a LOT faster...
17:06:05 <dons> cpfr, all libs are documented at http://haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
17:06:07 <lambdabot> Title: Libraries and tools/Database interfaces - HaskellWiki, http://tinyurl.com/3xb8dd
17:06:07 <Cale> http://www.quux.org:70/devel/hdbc
17:06:10 <lambdabot> Title: Gopher: hdbc
17:06:24 <cpfr> hsql or hdbc
17:06:27 <siti> sorear: umm nice -20 I hope you're joking
17:06:29 <cpfr> which should i go with
17:06:40 <Cale> I have no idea why it's hosted on a gopher server
17:06:59 <Cale> But there's a sqlite3 driver for it.
17:07:12 <allbery_b> siti: csh and sh/bash/etc. do priorities in reverse from each other
17:07:20 <sorear> siti: no, I'm not.
17:07:23 <siti> ahh ok
17:07:31 <sorear> siti: remember nice needs a '-'
17:07:39 <sorear> at least here
17:07:56 <sorear> allbery_b: I didn't know nice was a builting
17:08:06 <siti> on my platform that command would make the process have almost realtime priority ;)
17:08:24 <allbery_b> it's a builtin in csh
17:08:31 <sorear> gah, I don't even HAVE a csh
17:08:37 <siti> yes, I see from above :P
17:08:46 <siti> bsd people :P pfft ;)
17:09:28 <Cale> Please don't use csh
17:09:31 <sorear> siti: actually this is debian linux :)
17:09:47 <mbishop> hsh? :P
17:09:47 <siti> lol ok
17:10:07 <sorear> Cale: if it makes you feel better, the command I was trying to use was not "csh" but "man csh" :)
17:10:09 <siti> is there a haskell shell?
17:10:22 <sorear> ghci forever!
17:10:27 <Cale> There are haskell shell utilities.
17:10:32 <siti> bit difficult running programs :P
17:10:42 <Adamant> csh is evil. at least use tcsh.
17:10:43 <mbishop> someone voted down my criticism of C++ before anyone had a change to look at it :[
17:10:53 <siti> lol
17:11:02 <Cale> I looked at it, briefly.
17:11:12 <Korollary> That was your pdf?
17:11:15 * mbishop nods
17:11:22 <mbishop> Well, I didn't write it
17:11:28 <mbishop> just linked it, from that ada site
17:11:29 <Cale> You're not Ian Joyner! :)
17:11:36 <mbishop> I sure hope not heh
17:11:47 <siti> mbishop: well it's a tiny thing to read ;)
17:12:31 <Cale> It's sort of tiring.
17:12:47 <Cale> I sort of wish people would stop talking about C++ altogether.
17:13:14 <siti> well we have to help improve haskell then people can stop using it :p
17:14:02 <allbery_b> ever looked at the tcsh source?  ewwwww
17:14:02 <Cale> How much of an improvement over C++ does Haskell need to be?
17:14:21 <mbishop> I don't think haskell and C++ are really an either or kind of thing for most people
17:14:28 <siti> well the actual language needs none, but documentation, bindings etc...
17:14:38 <mbishop> sadly people use C++ for stuff other than systems programming, which is pretty much useless heh
17:14:39 <siti> yeah, you're right
17:14:49 <Cale> mbishop: I contend that if you know Haskell, writing C++ will be quite painful :)
17:14:53 <siti> c is better for systems programming IMO though :P
17:15:05 <mbishop> C is just too dangerious
17:15:35 <jcreigh> I think we should introduce the death penalty for people who say something is too slow without benchmarking. :)
17:15:56 * mbishop never mentioned speed
17:17:31 <Cale> C is an okay target language, but I'd rather see things like C-- do well.
17:18:10 <augustss> C isn't bad for what is was meant for.
17:18:20 <siti> well c achieves its purpose :)
17:18:28 <siti> it's good for what it's designed for
17:18:40 <augustss> And I much prefer it over C++
17:19:16 <Binkley> well, saying you prefer C over C++ is a little like saying you prefer being torn to shreds by wolverines over being torn to shreds by rabid wolverines ;-)
17:19:17 <siti> yes, it's simple.  If I want a higher-level language I'd not go to c++ but something else...
17:19:32 <augustss> But I must admit a certain awe of C++ templates.  People do clever things with them (but it's a horrible pure functional language.)
17:19:50 <Binkley> people don't do anything with C++ templates that you couldn't do in Haskell's type system
17:20:03 <Binkley> I'm sure someone will go try to prove me wrong now
17:20:05 * Binkley gets the popcorn
17:20:15 <Cale> Well, if you count MPTC's + fundeps.
17:20:16 <jcreigh> segfault? :)
17:20:30 <Binkley> oh, it's easy to make GHC segfault
17:20:35 <Binkley> if you hack the RTS :-)
17:20:38 <jcreigh> Binkley: hmm?
17:20:39 <augustss> Binkley: since templates are not type checked until instantiated you can do more things with them.
17:20:57 <LoganCapaldo> Can you really do the C++ factorial trick in Haskell's type system?
17:21:05 <Binkley> augustss: yeah, I shouldn't have tried to imply that C++ templates weren't horrible
17:21:14 <Cale> LoganCapaldo: not without extensions.
17:21:17 <augustss> LoganCapaldo: Sure :)
17:21:31 <augustss> LoganCapaldo: if you turn on enough extensions
17:21:37 <LoganCapaldo> heh
17:21:47 <Binkley> -fturing-complete-type-system
17:21:56 <jcreigh> Binkley: I can't recall ever making a GHC-compiled program segfault. But I haven't used any of the unsafeYouReallyDontWantToDoThisIO functions.
17:22:07 <augustss> -fundecidable-instances
17:22:21 <Binkley> jcreigh: well, actually, I've gotten segfaults from both GHC and my compiled code even when I *wasn't* hacking GHC in horrible ways
17:22:35 <Binkley> but I think I radiate an aura of chaos, panic and disorder that results in such things happening
17:22:51 <Botje> that or your RAM is faulty.
17:23:03 <augustss> GHC is not bug free
17:23:22 <siti> but it's written in haskell, if it compiles it's bug free (well almost) :D
17:23:42 <augustss> it's alo like 50000 lines of C
17:23:51 <Binkley> I agree, GHC isn't bug free
17:23:57 <Binkley> is there anyone who would debate that? :-)
17:24:07 <Binkley> OTOH some people seem to discover more bugs in it than others.
17:25:01 <augustss> I take that back, it;s 240000 lines of C
17:25:14 * allbery_b is not quite as much of a "human fuzzer" as he used to be
17:26:05 <augustss> I take it back again, it's only 120000 lines.  I counted the .c file in _darcs as well
17:26:09 <Binkley> heh
17:26:16 <Binkley> no disrespect for GHC
17:26:41 <Binkley> I've just worked with it enough to smirk a little when people are all "omfg Haskell programs are always perfect forever!"
17:26:46 <Binkley> Just a little.
17:26:51 <Binkley> I don't want to ruin people's innocence *too* soon.
17:26:52 <mbishop> I'm not sure anything can be bug free, but I definately think using C sure doesn't help any
17:27:41 <Cale> If you want to write a program that is bug free, chances are that it's easier to do it in Haskell than in C.
17:28:10 <Binkley> well, Haskell gets rid of a huge class of bugs. It's true.
17:28:16 <LoganCapaldo> main = putStrLn "Hello, world!" -- woot! I did it, a bug free program
17:28:24 <Binkley> but when bugs get eliminated, humans have to invent more bugs
17:28:27 <Binkley> it's their nature
17:28:31 * LoganCapaldo waits for people to find bugs in it
17:28:36 <Binkley> maybe I shouldn't be so cynical
17:28:47 <Binkley> LoganCapaldo: whether it has bugs depends on what its specification is :-)
17:29:20 <LoganCapaldo> Binkley, it's a literate program, that was the specification ;)
17:29:25 <augustss> Binkley: Haskell is certainly no guarantee.  But I write code with many fewwer bugs in Haskell than anything else I've used.
17:29:43 <Binkley> yeah, but I wonder...
17:29:52 <Binkley> when Haskell takes over the world and everyone starts writing all their programs in it...
17:30:00 <Binkley> as is surely just on the verge of happening..
17:30:03 <Binkley> then what?
17:30:04 <jcreigh> ha
17:30:15 <jcreigh> Haskell is not going to take over the world.
17:30:17 <LoganCapaldo> then we are gonna see the post-Haskell language
17:30:21 <augustss> Then we'll have all these people who can't program using Haskell
17:30:38 <augustss> But that won't affect how I can use Haskell
17:30:40 <LoganCapaldo> and my brain will hurt even more than it does now
17:31:09 <Binkley> augustss: I think we already have a lot of people who can't program using Haskell
17:31:14 <Binkley> have you read the mailing lists lately?
17:31:19 <LoganCapaldo> because it will probably have arrows in the type system or something equally insane that I can't imagine
17:31:22 <Binkley> but, I see your point
17:31:25 <augustss> Binkley: yes
17:32:33 * LoganCapaldo imagines a future where Haskell is low level and programmers use it for "speed"
17:32:36 <Binkley> haha
17:33:20 <LoganCapaldo> Common threads on LanguageOfTheFuture
17:33:40 <LoganCapaldo> 's ML include "For Speed use Haskell"
17:33:42 * Cale envisions a future where programs written in higher level languages typically run faster than those written in low-level ones.
17:34:47 <LoganCapaldo> and "How do I use higher-kinded monadic arrows to parse n-dimensional markup in a hilbert manifold?"
17:34:50 <augustss> Cale: yes, the vision is 50 years old.  we're still waiting ;)
17:34:56 * mbishop imagines a future filled with scantily clad women to do his bidding
17:35:10 * Korollary tries to imagine next friday
17:35:11 <augustss> But maybe soon
17:35:21 <Cale> augustss: If Intel keeps making processors anyway :)
17:35:50 <Cale> actually, that's not really true, and rather frustrating.
17:36:07 <Binkley> soon we'll all be using quantum computers anyway
17:36:21 <Korollary> no
17:36:33 <czanonie> Non determinism for the win!
17:36:48 <Cale> What's with this "for the win" thing?
17:36:55 <Cale> Where did that come from?
17:37:11 <czanonie> Counterstrike, probably.
17:37:14 <LoganCapaldo> Sports?
17:37:15 <glguy> is it from the show *Hollywood Squares*?
17:37:31 <LoganCapaldo> And its a homerun into left field for the win?
17:37:35 <glguy> You pick squares "for the win" or "for the block"
17:38:03 <Cale> We really need a decent architecture for which it's relatively easy to analyse the performance of programs, so that it becomes simpler to do discrete optimisation across spaces of implementations.
17:38:24 <Korollary> why?
17:38:47 <augustss> we need people who can program
17:38:49 <Binkley> Cale: is that really a question of needing a better architecture, or a question of needing better program understandign tools?
17:38:57 <Binkley> well, we need smarter people
17:38:58 <LoganCapaldo> Cale, couldn't you do that with an emulator for said arch. w/o all the messiness of trying to get someone to produce it?
17:39:06 <Binkley> unfortunately the supply of smartness in the universe seems fairly constant
17:39:18 <Cale> Well, you can write simulators, but it makes the evaluation function hard.
17:39:20 <augustss> oh, education helps
17:39:27 <Binkley> I'm not sure how much education helps
17:39:36 <Cale> I'm thinking about things like FFTW.
17:39:37 <Korollary> evolution helps more in the long term
17:39:37 <augustss> it helps
17:39:41 <Cale> But more general.
17:39:41 <mbishop> @remember Binkley well, we need smarter people
17:39:42 <lambdabot> Done.
17:39:45 <Binkley> or rather, if you want to fix education, you have to start in kindergarten
17:39:53 <augustss> and earth population is growing
17:39:55 <Binkley> and I know I'm not qualified to take on that task, personally
17:40:17 <augustss> we'll just outsource everything to india
17:40:20 <czanonie> Logo FTW?
17:40:25 <LoganCapaldo> > let education = ("start in kindergarten "++) in fix education
17:40:27 <lambdabot>  "start in kindergarten start in kindergarten start in kindergarten start in ...
17:40:33 <Cale> I know how to take on the task of correcting the mathematics curriculum, if only I was given complete executive control of the education system.
17:40:54 <Binkley> Cale: yes, the problem is not actually knowing what to do, but convincing other people they should help you do it
17:40:58 <Binkley> it all comes down to politics
17:41:00 <Korollary> how about complete control of a country?
17:41:07 <augustss> The world would be a better place if I were a dictator too ;)
17:41:12 <Binkley> and we as software engineers all love to say we hate politics
17:41:15 <Cale> I don't think I need that much power to accomplish it.
17:41:21 <Binkley> don't be too sure
17:41:26 <LoganCapaldo> the world would be a lousy place were I a dictator
17:41:27 <czanonie> You must remember however that not all people can even complete requirements imposed by the current education system.
17:41:33 <Binkley> People are very invested, personally, in self-identifying as math haters
17:41:42 <Binkley> people get unhappy when you try to take away their identity
17:41:55 <czanonie> People are not all capable of the same level of understanding ^_^
17:41:56 <Korollary> Why do we need to do anything? Who says there's something that needs fixing?
17:42:10 <augustss> Binkley: you are speaking of the US, I presume
17:42:12 <Cale> The requirements imposed for mathematics in the current system are mostly misdirected anyway. Things could actually be a good deal easier and yet more productive.
17:42:15 <Binkley> Korollary: the education system as it is wastes human potential to a huge extent. I'd say that's a problem
17:42:25 <Korollary> Binkley: why?
17:42:26 <Binkley> augustss: I'm American, so of course I'm only speaking of the US
17:42:32 <Binkley> I thought that went without saying :P
17:42:43 <Binkley> Korollary: why does it waste human potential, or why is that a problem?
17:42:53 <augustss> You could have been from Sri Lanka for all I know
17:42:58 <Binkley> Cale: I'd say the requirements for *everything* in the current system are misdirected
17:43:10 <Korollary> Why is that a problem. You can always improve, but I don't know how much is enough.
17:43:49 <Cale> Binkley: to some extent. I think math is far more screwed up than anything else -- that's not saying that anything else is particularly good.
17:44:13 <Cale> I'm talking about Canada, but the curriculum is similar.
17:44:42 <Binkley> Cale: I agree, and I think that mostly has to do with people who are unenthusiastic about math teaching math
17:44:49 <Cale> The problem with the mathematics curriculum is that what they do, I wouldn't even call it mathematics.
17:44:57 <Binkley> To fix that, you have to create incentives for enthusiastic people wanting to teach math
17:45:04 <augustss> Yep
17:45:07 <Binkley> Which, I think, mostly comes down to money
17:45:43 <Binkley> which, again, comes down to politics
17:45:44 <augustss> Teachers should be paid much, much more
17:46:00 <Cale> I think that with the current curriculum, you end up crushing the spirits of potentially enthusiastic teachers as well.
17:46:16 <Korollary> Holy jumping you. Coca Cola dropped major mullah on this year's superbowl ads.
17:46:26 <Cale> I know that I couldn't remain sane teaching that.
17:46:50 <Binkley> Cale: that certainly seems to apply to all of my friends who've ever been teachers, yes
17:47:00 <Binkley> one friend of mine who teaches 9th-grade math says her job is mostly crowd control
17:47:08 <Binkley> and what person who had a choice would want a job like that?
17:47:14 <allbery_b> in the US you also need to fix the "schools are dfay care" problem
17:47:23 <allbery_b> yeh, that
17:47:23 <Binkley> I don't think it's just the curriculum that crushes teachers' souls--
17:47:29 <Binkley> the problem is, yeah, what allbery_b just said
17:47:51 <Binkley> Hell, I don't even want to become a *university* professor because I feel like the "teaching" component of the job would be too much about babysitting
17:47:59 <augustss> luckily there is a steady stream of immigrants to the US...
17:48:01 <Binkley> so why would sane people want to teach at a lower level than thta?
17:48:09 <Cale> Meh, I'd be okay with that level of keeping things together.
17:48:25 <Cale> There's almost no babysitting going on at Waterloo, anyway.
17:48:41 <Cale> If anything, you'd need to work to get any of the students to say anything.
17:48:52 <allbery_b> college/university level costs too much to be daycare
17:49:02 <Binkley> at an excellent university, maybe not babysitting... but even at the best universities, students are still largely in "I will sit here passively absorbing knowledge" mode
17:49:15 <allbery_b> sure, they never learned how to learn :/
17:49:16 <Korollary> party, dude
17:49:19 <Binkley> allbery_b: well, if that's true, I'm still looking for an explanation of why my students didn't say anything when I was a TA
17:49:23 <Binkley> maybe it was personal
17:49:31 <glguy> We've got plenty of people actively not learning in the class I'm taking
17:49:35 <Cale> That's better than being in "I'm here to socialise during the lectures" mode.
17:49:43 <Korollary> Binkley: They were not up to the subject to say anything.
17:49:44 <Giuly2> hi
17:49:46 <Giuly2> EXOTICS ADULT FORUM ::::::::::: http://exotics.ezbbforum.com
17:49:48 <lambdabot> Title: EXOTICS :: Index
17:49:48 <Giuly2> EXOTICS ADULT FORUM ::::::::::: http://exotics.ezbbforum.com
17:49:49 <Binkley> hell, I think students socializing with each otehr during lectures is almost better
17:49:49 <lambdabot> Title: EXOTICS :: Index
17:49:50 <Cale> hi, you're banned
17:49:53 --- mode: ChanServ set +o glguy
17:50:00 <Binkley> because then at least they get *something* out of it
17:50:05 <Binkley> *someone's* time isn't wasted
17:50:06 <allbery_b> by the time they get to college it's too late for most kids to figure out how to learn
17:50:12 <Binkley> allbery_b: yep, I agree
17:50:19 <Binkley> that's why I was saying you have to start with kindergarten
17:50:19 --- mode: Cale set +b *!*@88.232.73.189
17:50:20 * allbery_b ended up teaching himself, school was *useless* for it
17:50:26 <Binkley> I taught myself too
17:50:39 <Binkley> but I was just really freakin' lucky
17:50:43 --- mode: Cale set -o Cale
17:50:47 <Binkley> to have a parent who saw that school would be useless for me, and took me out
17:50:57 <Binkley> I feel bad all the time that most kids aren't as lucky as I was
17:51:03 <Binkley> I'm not sure what to do about it, though
17:51:16 <allbery_b> I didn't get lucky that way (well, early school yes, but that's a whole 'nother ball of snakes)
17:51:33 <Binkley> well, no school, and then early college, for me
17:51:34 * Pseudonym wonders what would happen if we spammed the "adult forum" with category theory
17:51:41 <Korollary> heh
17:51:44 <Binkley> Pseudonym: only one way to find out :-0
17:51:53 <Cale> That would be funny.
17:52:06 <Pseudonym> I'm sure they do a lot of pushforwards there.
17:52:15 * Binkley isn't even going to say anything about bananas
17:52:22 <Pseudonym> Or barbed wire.
17:52:23 <allbery_b> one of my middle school teachers talked the high school into an accelerated program for me, though, with the result that I spent half days my senior year at CWRU.  (but the schedule I got stuck with was a bit much for someone trying t graduate from high school at the same time; winter semester was a bit of a bust...)
17:52:35 <allbery_b> s/winter/spring/
17:52:56 <Cale> The pure mathematics club at waterloo once took over alt.niggers
17:53:09 <Cale> and changed their FAQ
17:53:26 <cpfr> i dont know about the universities
17:53:33 <Binkley> well, better than the racism club taking over alt.mathematics ;-)
17:53:48 <cpfr> i talk with peers during lectures
17:53:59 <Anon4888> What, you go to class?
17:54:01 <cpfr> but its relevant discussion
17:54:24 --- mode: glguy set -o glguy
17:54:31 <cpfr> yea i do go to class!
17:54:35 <cpfr> sometimes ...
17:54:41 <mbishop> uh oh
17:54:45 <mbishop> was someone naughty?
17:54:56 <mbishop> oh, spammers heh
17:55:04 <Anon4888> At univ, I'd almost always feel like I accomplished more reading a book for an hour than attending class
17:55:07 <Binkley> last year I was taking clasess where the other students spent the lectures talking to each other on IRC
17:55:19 <Binkley> and finally I decided to go on the IRC channel myself, too, just to see what they were talking about
17:55:23 <Binkley> and it was things like
17:55:30 <Binkley> "hey, did [prof] get a haircut? it looks like it"
17:55:34 <Binkley> So I dropped out of that program
17:55:43 <glguy> man... I am not good at the whole springing to life as an op and banning the spammer
17:56:02 <Korollary> glguy: Talk to Q about that. Maybe there's a widget for it.
17:56:13 <Binkley> maybe a better solution to spam would be to require people to prove that they can explain the foldr/build rule before they're allowed to join :-0
17:56:28 <Cale> iirc, they used the name as an acronym for "Number, Integration, Group, Graph, Enumeration, Ring, and Set theory"
17:56:28 <Pseudonym> Then we wouldn't get dumb homework questions.
17:56:36 <Binkley> yes, so everybody wins!
17:56:37 <LoganCapaldo> glguy, you need more practice. It's sick when people do it really quick, like op ban deop before you can blink
17:56:44 <Pseudonym> Clearly, we should be asking potential joiners to show their monad tutorial.
17:56:48 <Binkley> haha
17:56:54 <Cale> and basically started posting lots of mathematics there
17:56:54 <glguy> LoganCapaldo: I need a better macro for it
17:57:02 <Binkley> no, actually, we should be asking potential joiners to prove that they *haven't* written a monad tutorial
17:57:03 <Pseudonym> And in #scheme, they should ask for their simple brain-dead scheme interpreter.
17:57:04 <cpfr> folkr
17:57:09 <Binkley> given the quality of some of those tutorials
17:57:13 <Binkley> present company excluded
17:57:16 <glguy> LoganCapaldo: right now, I have to /msg chanserv... which opens a new window :-/ and the ncom back
17:57:23 * Pseudonym hasn't written one; hangs head in shame
17:57:29 <Binkley> I've never written one either
17:57:31 <Korollary> Pseudonym: It's more like an allegiance to macros.
17:57:34 <Pseudonym> I did write a simple brain-dead Lisp interpreter in Miranda, though.
17:57:42 <Pseudonym> That's kind of an equivalent.
17:57:45 <Binkley> I've only tried to explain monads to people who I shouldn't explain them to
17:57:55 <Cale> Eventually the dean had to tell them that although he didn't totally disagree with what they were doing, he had to tell them to stop, because lots of posts by uwaterloo addresses in alt.niggers looked bad.
17:57:58 <glguy> I know I could write an mIRC script to op and ban someone for saying something like that in channel automatically
17:58:01 <Binkley> hahaha
17:58:09 <LoganCapaldo> I'm so not experienced enough to be in any channel by those standards :)
17:58:11 <mbishop> glguy: man that would be k-rad
17:58:14 <Binkley> wow, I've never actually got yelled at by my dean for my online activities
17:58:17 <Binkley> only my advisor
17:58:40 <mbishop> oh sorry, I saw mirc mentioned, thought it was the 1990s again
17:58:52 <glguy> or maybe I could learn enough applescript to do it
17:59:01 <LoganCapaldo> yech
17:59:01 <Korollary> We are. I just saw Prince sing.
17:59:07 <LoganCapaldo> lambdabot should do it
17:59:11 <Binkley> AppleScript?
17:59:15 <allbery_b> in #lopsa we just all stay op-ed, but that's kind of a different situation (all sysadmins, several are also ircops so abuse is rare and easily dealt with)
17:59:17 <LoganCapaldo> thats what they do in #ruby-lang
17:59:18 <Pseudonym> Can you imagine giving lambdabot op privs?
17:59:21 <sjanssen> Korollary: if it really was the 90s, you wouldn't be able to call him Prince
17:59:24 <Binkley> clearly we need an IRC server and client implemented in haskell
17:59:27 <glguy> Binkley: I'm using OS X
17:59:28 <lambdabot> Yeah! Gimme gimme!
17:59:31 <Binkley> that should be somebody's next project
17:59:40 <Binkley> glguy: sure, but that's basically Unix
17:59:40 <lambdabot> I'll rename it #no-humans.
17:59:45 <mbishop> heh
17:59:51 <Binkley> so why would you need to use AppleScript?
18:00:06 <glguy> Binkley: so tie it into colloquy
18:00:08 <glguy> to*
18:00:11 <mbishop> "Kill all humans!" - Bender Bending Rodriguez
18:00:15 <Anon4888> apologies for off-topic, but my mIRC just expired... suggestions for a good windows irc client?
18:00:19 <Pseudonym> Actually, that isn't such a dumb idea.
18:00:25 <Korollary> sjanssen: the name change happened in 1995
18:00:27 <Korollary> err 1994
18:00:46 <allbery_b> @where hircules
18:00:47 <lambdabot> http://haskell.org/hircules/
18:00:54 <Pseudonym> One command which extracts the IP address of the miscreant and constructs the relevant ban command.
18:00:55 <allbery_b> ^^^ irc client :)
18:00:58 <ludwig-> Anon4888: my condolences..
18:01:16 <Anon4888> it's ok, I didn't know him very well
18:01:37 <Anon4888> thanks allbery
18:01:40 <czanonie> Anon4888: irssi binaries for windows are available that run in cmd prompt and rxvt.
18:01:52 <ludwig-> hircules looks interesting
18:01:53 <LoganCapaldo> theres a windows rxvt?
18:01:54 <allbery_b> half kidding; I have no idea how complete it is
18:02:07 * LoganCapaldo is using HydraIRC on Win.
18:02:09 <mbishop> the irssi binary comes with rxvt
18:02:11 <allbery_b> when I used windows I used the windows port of xchat, but then I like xchat
18:02:20 <LoganCapaldo> I don't know if i'd call it "good" but its not "bad"
18:02:26 <Anon4888> Yes, I assumed it was written in Haskell and thus incomplete :)
18:02:26 <glguy> quick test
18:02:27 <allbery_b> rxvt's available for cygwin, if nothing else
18:02:42 <mbishop> Anon4888: blaspheme!
18:02:49 <allbery_b> yes, well, that whole partial application thing (not to say partial functions :)
18:02:54 <LoganCapaldo> allbery_b, I was more interested in cmd.exe inside rxvt
18:03:12 <mbishop> yeah because cmd.exe is so useful!
18:03:13 * mbishop coughs
18:03:16 <LoganCapaldo> lol
18:03:19 <LoganCapaldo> it is
18:03:27 <jcreigh> LoganCapaldo: really? how so?
18:03:28 <allbery_b> if it's what you know, switching to e.g. bash is downright painful
18:03:38 <allbery_b> like me tryng to use cmd.exe, or for that matter *csh
18:03:40 <LoganCapaldo> Cygwin is the ultimate leaky abstraction :)
18:03:54 * LoganCapaldo uses zsh
18:04:07 <mbishop> zsh is the emacs of shells
18:04:14 <LoganCapaldo> indeed
18:04:19 * LoganCapaldo uses vim
18:04:26 <LoganCapaldo> Because vim is the emacs of vis
18:04:26 <allbery_b> (well, except I used to use csh --- back when it was csh or /bin/sh, and there was no bash (or even ksh, outside of AT&T)
18:04:27 * mbishop uses emacs
18:04:49 <mbishop> allbery_b: So I take it you're an old fart? :)
18:04:51 <czanonie> too bad emacs and zsh don't play well together :)
18:05:08 <allbery_b> rather
18:05:37 <LoganCapaldo> cmd.exe is great I can type ghci or irb
18:07:44 * allbery_b wonders of he's going to be halthy enough to go to work tomorrow, speaking of "old" :/
18:08:55 <xpika> @src (#)
18:08:55 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:09:04 <LoganCapaldo> Yowch
18:09:19 <xpika> @index (#)
18:09:20 <lambdabot> bzzt
18:09:21 <LoganCapaldo> So very insulting
18:10:12 <Anon4888> "Anyone who is a politician or who works for any form of government body
18:10:12 <Anon4888> is expressly forbidden to use any version of HydraIRC.
18:10:23 <Anon4888> um... ok :)
18:10:39 <LoganCapaldo> Does it really say that?
18:10:39 <sjanssen> that's bizarre
18:10:41 <LoganCapaldo> crud
18:10:47 <Anon4888> As you install, yes
18:10:51 <xpika> what does the (#) operator do?
18:11:03 <xpika> eg. http://en.wikipedia.org/wiki/Haskell_(programming_language)
18:11:07 <sjanssen> xpika: where have you seen the # operator?
18:11:12 * LoganCapaldo quit ("Works the for government")
18:11:20 <xpika> ^^
18:11:24 <Cale> Depends on what someone has defined it to do.
18:11:44 <Cale> On that page, it's defined as part of the definition of hamming.
18:11:46 <sjanssen> xpika: not a standard operator, but it looks like flip (.)
18:11:47 <Pseudonym> Now does soemone who works for a state university count?
18:11:51 <Pseudonym> Not that I'm using HydraIRC.
18:11:52 <Cale> no, it's not
18:11:55 <sjanssen> ah, nevermind
18:12:09 <Cale> It's an ordered merge operation.
18:12:14 * glguy tries something
18:12:18 <glguy> ADULT FORUM
18:12:18 --- mode: ChanServ set +o glguy_
18:12:24 <glguy> hmm, I need a delay
18:12:44 <LoganCapaldo> HMM
18:13:01 <LoganCapaldo> finds glguy's logic regarding ADULT FORUM possibly flawed
18:13:08 <glguy_> :)
18:13:58 <es> how does the definition of seq _ y = y forces evaluation? Wouldn't lazy evaluation skip the first argument since it isn't used?
18:13:58 --- mode: glguy_ set -o glguy_
18:14:02 <Cale> xpika: do you see how that works?
18:14:13 <LoganCapaldo> es: its a magic special case
18:14:13 <glguy> one more try ADULT FORUM
18:14:16 <Cale> xpika: It's part of the where clause
18:14:19 --- mode: ChanServ set +o glguy_
18:14:25 <sjanssen> es: that isn't a valid defn. of seq
18:14:51 <Cale> es: seq is not definable in Haskell, at least not at that level of polymorphism
18:14:51 <LoganCapaldo> you can't write seq in Haskell afaik
18:15:03 <Cale> You can define it for specific data types.
18:15:17 <Cale> By simply pattern matching against one of the constructors
18:15:19 <es> I thought I saw that in Prelude.hs
18:15:56 <Cale> seq x y = y when x is defined.
18:16:06 <Cale> seq undefined y = undefined
18:16:23 --- mode: glguy_ set -o glguy_
18:17:15 <es> I saw it here http://darcs.haskell.org/packages/base/Prelude.hs
18:18:01 <Cale> es: that's inside an #ifdef __HADDOCK__, which means it'll only be there when Haddock is producing documentation.
18:18:03 <sjanssen> es: that definition of seq is only included for haddock purposes
18:18:51 <Cale> I actually sort of wonder why that definition is there at all, and not just the type signature.
18:19:51 <es> hmm... ok. what brought me to it is I'm trying to understand why putStrLn "a" `seq` putStrLn "b" does not print "a"
18:20:08 <sorear> because haskell is pure
18:20:10 <Cale> Because it only evaluates putStrLn "a", it doesn't execute it.
18:20:29 <Cale> putStrLn "a" evaluates into an IO action, which must be executed in order to actually happen.
18:20:57 <sorear> the *only* ways to execute IO actions are: bind it to main | execute a compound action made from it using bind
18:21:06 <Cale> If you want the putStrLn "a" to actually occur, use >>
18:21:12 <Cale> instead of `seq`
18:21:37 <Cale> In some sense, main is the only IO action ever run.
18:21:46 <Cale> (unless you type things in GHCi)
18:21:50 <es> Ah, I was executing this function in ghci. That's must be the reason "b" was printed out
18:22:20 <es> alright. thanks all.
18:22:37 <Cale> Okay, then what happened was that putStrLn "a" was evaluated, the resulting action thrown away, then putStrLn "b" was evaluated into an action, and since it was an action, that action was carried out.
18:32:05 <moconnor> when I run ghci on my main program (i.e. the one with main :: IO ()) my functions and stuff aren't in scope.  What do I need to do so I can see my functions?
18:34:08 <Korollary> import your functions from whichever module you put them in
18:43:42 <glguy> I'm trying to learn how t oscript Colloquy by example... is there a good place to see other people's scripts?
18:43:54 <glguy> hmm
18:43:56 <glguy> wrong channel
18:44:02 <olliej> glguy: really? :D
18:44:18 <olliej> glguy: i would imagine colloquy.info
18:44:29 <olliej> glguy: failing that you could harangue xenon in #webkit
18:44:34 <glguy> Their examples aren't particularly enlightening
18:59:18 <boulez`> glguy: message?
18:59:24 <glguy> ?
18:59:34 <sorear> @users
18:59:34 <lambdabot> Maximum users seen in #haskell: 322, currently: 285 (88.5%), active: 31 (10.9%)
18:59:44 <boulez`> I got queried [19:31] (glguy): PRIVMSG glguy :hello
19:00:18 <glguy> boulez`: applescript screw up. I started sending that to everyone in the channel
19:00:25 <glguy> I'm sticking to using other peoples scripts now
19:01:39 <gvdm_other> would ADULT FORUM work for me?
19:01:42 <gvdm_other> wait
19:01:45 <gvdm_other> wait
19:01:50 <gvdm_other> how long was this delay?
19:02:10 <gvdm_other> hmm, no ops...
19:04:29 <xpika> @src interact
19:04:30 <lambdabot> interact f = do s <- getContents; putStr (f s)
19:04:58 <glguy> I decided against setting a trigger for ADULT FORUM
19:05:03 <glguy> I've got a better way in kind
19:05:04 <glguy> mind*
19:05:26 <sorear> can't we just ban the turks? :p
19:05:49 * LoganCapaldo still likes @ban ip
19:06:19 <LoganCapaldo> then it works regardless of the client you happen to be using at the time, whether your scripts / macros are setup, etc.
19:06:30 --- mode: ChanServ set +o glguy
19:06:42 --- mode: glguy set -o glguy
19:06:48 <sorear> I'd like to give lambdabot a markov-type writing analyzer and autoblocker.
19:06:57 <matt__r> glguy: that didn't last long
19:07:05 <glguy> matt__r: the script worked
19:07:14 <glguy> when I /op myself, it msg's chanserv
19:07:15 * sjanssen isn't quite comfortable with auto blocking
19:07:24 <sorear> nick? bah. we know you're smerdy/palomer/that-adult-forums-guy
19:07:35 <glguy> the script automatically tells chanserv to do stuff if you aren't opped yourself
19:07:55 <sorear> I do think spamming the forum with category theory sounds good :)
19:08:27 <Cale> Go for it.
19:09:11 <matt__r> the analogues of injective and surjective functions on sets are not sufficient to describe the full range of special kinds of arrows
19:09:19 <fincher> I asked this question before, but accidentally left (closed wrong window) without seeing if there was an answer.
19:09:23 <Cale> "This forum was advertised on a Haskell IRC channel. Thus it was decided that the forum would like more posts about Haskell and category theory."
19:09:36 <fincher> What's the best paper to learn about GADTs from?
19:09:52 <fincher> something like SPJ's "Beautiful Concurrency", ideally.
19:09:53 <Cale> fincher: Possibly the remake of the wobbly types paper.
19:10:05 <Cale> http://research.microsoft.com/~simonpj/papers/gadt/index.htm
19:10:07 <lambdabot> Title: Simple unification-based type inference for GADTs
19:10:18 --- mode: ChanServ set +o glguy
19:10:23 <glguy> :-)
19:10:27 --- mode: glguy set -o glguy
19:10:33 <Cale> It's not exactly a tutorial, but has a basic introduction.
19:10:35 <glguy> just checking, but /op works now
19:10:43 <glguy> so I'll be able to respond that much faster ;)
19:10:59 <matt__r> the notion of adjoint, developed by kan an 1958 ,is considered on the the most important ideas in category theory and perhaps the most significant contribution of category theory to the broader arena of mathematical thinking
19:11:11 <fincher> Cale: thanks, I'll read it.
19:11:43 <Cale> matt__r: Yeah, I wish we had more information on how it relates to programming.
19:12:12 <matt__r> I can only parrot me betters - it was all from Pierce's book
19:12:17 <matt__r> s/me/my
19:14:52 <LoganCapaldo> no
19:15:00 <LoganCapaldo> parrot's involve pirate
19:15:07 <LoganCapaldo> and a pirate would say me
19:15:12 <LoganCapaldo> that was an anti-correction
19:15:19 <LoganCapaldo> @arr
19:15:20 <lambdabot> Drink up, me 'earties
19:15:50 <glguy> I remember when I used to use bitchX, there were like 8 different ways to kick ban someone
19:16:06 <glguy> hell... I think there was a command to take over the channel and kick everyone out
19:16:26 <glguy> but with Colloquy, I have to use two commands to even kickban someone :)
19:16:28 <LoganCapaldo> LOL
19:16:38 <LoganCapaldo> that must have been a lonely command
19:17:18 <glguy> http://www.holoweb.net/~liam/bx/channeloperatorcommands.html
19:17:20 <lambdabot> Title: BX: channel operator commands
19:17:47 <glguy> ./FUCK	Usage: /fuck <nick> [reason]- Deops, bans and kicks <nick> for [reason]Also adds <nick> to shitlist at level 3 for current channel
19:18:27 <glguy> ./fuckem- Bans *!*a*@* thru *!*z*@* on current channel
19:19:40 <LoganCapaldo> theres a lot of lonely commands there
19:20:19 <glguy> \md - mass deop
19:20:31 <LoganCapaldo> like /mb mass bans everyone on current channel and /mk mass kicks everyone on the current channel
19:20:47 <Anon4888> and /me emotes
19:21:10 <glguy> I need to script a /kb <nick> [reason]
19:21:19 <glguy> that automatically ops me first
19:22:42 <sorear> wow
19:22:43 <glguy> ah, when you are an op, there is a drop down menu item for kickban
19:23:03 <sorear> for the first time in weeks I reached for perl to solve a problem :/
19:23:31 <glguy> sorear: what was your problem? some of the letters on your keyboard didn't work?
19:23:33 <hpaste>  sorear pasted "What would this look like in maximally idiomatic and/or short Haskell?" at http://hpaste.org/318
19:23:58 <sorear> glguy: actually, my CPU cooling system is bad.
19:24:19 <glguy> what does qx|sensors| do?
19:24:33 <sorear> quote executable
19:24:42 <sorear> it's like shell `sensors`
19:25:07 <sorear> the output of which contains:
19:25:09 <sorear> CPU Temp:  +58.0 C  (low  =   +10 C, high =   +60 C)
19:26:17 <xpika> can anyone think of a more consice way of writing:
19:26:18 <xpika> main=interact$unlines.filter(/="").lines
19:26:27 <sorear> and manually isn't an option since it needs to run while I'm sleeping :(
19:27:21 <glguy> xpika: slightly related, /= "" is (not . null)
19:27:43 <sorear> main=interact$map head.groupBy(on(&&)(/='\n')) ?
19:27:54 <sorear> gha, that's longer
19:27:55 <xpika> im on http://shinh.org:81/p.rb?delete+blank+lines
19:28:01 <lambdabot> Title: anarchy golf - delete blank lines
19:28:22 <sorear> yeah, we need interactLines
19:28:25 <glguy> ah
19:28:46 <sorear> ?
19:29:26 <glguy> ah, I see, it's a golf challenge
19:29:40 <glguy> > length "main=interact$unlines.filter(/="").lines"
19:29:41 <lambdabot>      The function `length' is applied to two arguments,
19:29:41 <lambdabot>     but its type `[a]...
19:29:45 <glguy> > length "main=interact$unlines.filter(/=\"\").lines"
19:29:47 <lambdabot>  40
19:30:15 <glguy> > "test" > ""
19:30:16 <lambdabot>  True
19:30:22 <glguy> > "" > ""
19:30:23 <lambdabot>  False
19:30:30 <glguy> > is shorter than /=
19:30:31 <lambdabot>  Parse error
19:31:27 <xpika> yay i shaved a single character
19:32:33 <sorear> dons: is nov2006 a good curses-yi?
19:33:22 <xpika> > length "main=interact$unlines.filter(""<).lines"
19:33:23 <lambdabot>      The function `length' is applied to two arguments,
19:33:23 <lambdabot>     but its type `[a]...
19:33:37 <xpika> > length "main=interact$unlines.filter(\"\"<).lines"
19:33:38 <lambdabot>  39
19:35:00 <sorear> remember [] and "" are interchangable here
19:35:16 <sorear> it'll help for obfuscation :)
19:35:25 <sorear> @ask dons is nov2006 a good curses-yi?
19:35:25 <lambdabot> Consider it noted.
19:35:28 <xpika> sorear: and remember [] and "" are the same length5D
19:36:00 <xpika> sorear: yea, i guess it is more obfuscated
19:36:50 <glguy> the test cases allow you to eliminate ALL duplicated lines
19:36:53 <glguy> not just empty ones
19:37:09 <glguy> (even though that isn't stated in the problem)
19:37:10 <U1f> hi there, short question: how do i typecast Int to Float?
19:37:22 <sorear> fromIntegral
19:37:37 <sjanssen> @type fromIntegral
19:37:39 <lambdabot> forall b a. (Num b, Integral a) => a -> b
19:37:40 <sorear> > (fromIntegral :: Int -> Float) 234
19:37:41 <lambdabot>  234.0
19:37:50 <arjanoosting> @type readIORef
19:37:52 <lambdabot> Not in scope: `readIORef'
19:38:06 <arjanoosting> @hoogle @readIORef
19:38:06 <lambdabot> Hoogle Error: Parse Error: Unexpected character '
19:38:12 <arjanoosting> @hoogle readIORef
19:38:13 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
19:38:19 <glguy> how do you tell vim not to end a file with a newline?
19:38:20 <sorear> U1f: or maybe you meant unsafeCoerce# :: Int# -> Float#  -- reinterprets bits as ieee 754, be *very* careful
19:38:24 <sorear> :set noeol
19:45:57 <gvdm_other> sorear: so, you pick the right integer so that its (signed?) binary representation (assuming 32 bits) comes out right for the iee 754 float? the only way to get that right would be to think through all of the bits... yeech comp203 taught me enough to hate figuring out exponents from the right 8 bits
19:52:32 <U1f> sorear: fromIntegral did the job, thx :)
19:54:43 <sorear> gvdm_other: I wasn't sure of the question.  If he has an ieee754 single precision stored as an Int, unsafeCoerce# is by far the easiest way to do ieee754 arithmatic on it.  If he has an integer and wants the normal mathematical injection, fromIntegral is easier.
20:00:26 <hpaste>  allbery_b annotated "What would this look like in maximally idiomatic and/or short Haskell?" with "this is nobody's shortest or most idiomatic :)" at http://hpaste.org/318#a1
20:00:34 <bd_> sorear: Would unsafeCoerce# be safe on a boxed type such as Int? Or would it be better to use it on the Int# inside?
20:01:34 <allbery_b> ...or tested, for that matter.  it compiles :)
20:02:22 <sorear> bd_: it is only safe if the representations are identical, among other things if the tag is the same.  I believe GHC does not scrutinize the tags of single constructor types like Int, but i've heard yhc does.
20:08:09 <hpaste>  allbery_b annotated "What would this look like in maximally idiomatic and/or short Haskell?" with "very minor improvement" at http://hpaste.org/318#a2
20:09:40 <sorear> I think popen(from MissingH) might help ...
20:09:49 <xpika> what does GHC use perl for?
20:10:02 <sjanssen> xpika: the evil mangler
20:10:21 <xpika> sjanssen: :S ?
20:10:22 <sjanssen> a program that reads gcc assembly output and changes things around
20:10:25 <SamB> xpika: appropriate, eh?
20:10:38 <SamB> that is actually what the component is called ;-)
20:11:04 <sorear> there used to also be a perl "Evil Driver", similar to gcc's collect2
20:12:31 <olliej> SamB/sorear: there's also reload.c -- it isn't perl though
20:12:45 <olliej> it's not really C either.. it's more cpp
20:12:54 <sorear> heh
20:13:14 <olliej> SamB/sorear: http://gcc.gnu.org/wiki/reload -- read the first sentence
20:13:16 <lambdabot> Title: reload - GCC Wiki
20:16:05 <xpika> does GHC require GCC on a i386 architecture?
20:16:23 <bd_> There's a native code generator as well
20:16:30 <bd_> slightly less efficient though
20:16:33 <SamB> it probably does though
20:16:35 <SamB> what about FFI?
20:16:48 <xpika> bd_: a C-- compiler?
20:17:26 <bd_> SamB: FFI can be generated directly. There was a thread on -cafe recently where someone was having problems compiling with -O but not without -O - it was because when the GCC backend was activcated, it suddenly started needing header files.
20:17:41 <bd_> xpika: GHC has a builtin cmm compiler, which outputs either assembler or C, I believe
20:17:59 <sorear> aiui too
20:18:11 <bd_> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain diagram
20:18:14 <lambdabot> Title: Commentary/Compiler/HscMain - GHC - Trac, http://tinyurl.com/2ej9w4
20:18:18 <sorear> there's also a number of issues eg with lstat
20:18:45 <sorear> which is a macro on linux ... so programs that use the 'unix' package don't work with -fasm
20:18:48 <sorear> (at least on head)
20:19:04 <sorear> hurts me ... vty needs termios
20:19:06 <bd_> hmm
20:19:22 <SamB> so basically it is a good idea to have GCC
20:19:31 <moconnor> Given a module, how do you find which package it is in?
20:19:34 <bd_> maybe when ffi is involved it should always generate C glue at least, even if the bulk of the haskell code uses the native code generator?
20:19:41 <bd_> moconnor: hoogle?
20:19:48 <bd_> hm,  maybe not though
20:19:59 <sorear> @docs
20:20:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:20:16 <SamB> bd_: it would be a nice option to have, I guess
20:20:19 <sorear> moconnor: ^^^ big table of module/package pairs, sorted by module
20:20:44 <bd_> I wonder, does {-# OPTIONS_GHC -fvia-c #-} work? >.>
20:21:23 <moconnor> sorear: thank you
20:21:38 <SamB> bd_: why wouldn't it?
20:21:41 * moconnor was thinking ghc-pkg would be able to tell me.
20:22:01 <sorear> bd_: I find that success depends on whether the *program* is compiled with -fvia-C.
20:22:26 <bd_> sorear: Have you tried NOINLINEing the ffi exports?
20:22:53 <allbery_b> ghc manual says -fasm and -fvia-c are both dynamic, so it "should" wokr
20:23:10 <sorear> bd_: no, I don't have write access to darcs.haskell.org/unix :)
20:23:11 <SamB> I think I've seen it
20:23:14 <allbery_b> I seem to recall one of the ghc bug reports suggestng that some options documented as dynamic aren', though
20:23:17 <SamB> GHC doesn't just ignore those
20:23:25 <SamB> at least I don't think it does
20:23:44 <bd_> sorear: You could build a package to test it, and submit a patch if it works, at least :)
20:24:39 <sorear> @tell augustss http://www.haskell.org/pipermail/jhc/2007-February/000004.html
20:24:40 <lambdabot> Consider it noted.
20:25:00 <sorear> augustss: if you are listening - poke, your answer has come
20:25:45 <xpika> does anyone else here agree that haskell should allow nested guard patterns?
20:26:01 <xpika> ie. guard patterns in guard patterns
20:26:05 <jcreigh> xpika: hmm? How would that work?
20:26:11 <xpika> @paste
20:26:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:30:20 <chessguy> hi haskellers
20:30:48 <olliej> yoyo chessguy
20:31:31 <chessguy> yo whassup in da hood, dawg/
20:31:42 <olliej> hehe
20:33:03 <hpaste>  xpika pasted "like this" at http://hpaste.org/319
20:34:11 <chessguy> hi monochrom
20:34:14 <monochrom> hi
20:34:28 <xpika> you can nest case and if statements... why not guard patterns?
20:35:43 <JKnecht> sounds messy, cascade would seem to be more sensible.
20:36:23 <xpika> also guard patterns should be able to be written in pointfree.
20:36:35 <emu> highly layout dependent eh
20:36:41 <emu> what i want is a $ pattern
20:36:51 <xpika> whats that/
20:37:17 <emu> match (Foo x $ Bar y z)
20:37:44 <xpika> yep that would be good too
20:38:40 <glguy> ok, ... I've got /op working for quick op, and /kb <nick> for fast kick ban... I think :)
20:38:42 --- mode: ChanServ set +o glguy
20:38:45 --- mode: glguy set +b glguy_!*@*
20:38:45 --- kick: glguy_ was kicked by glguy (glguy)
20:38:47 <glguy> woot
20:39:00 --- mode: glguy set -o glguy
20:39:06 * emu is somewhat confused
20:39:10 <glguy> hmm... I guess I should not leave me banned
20:39:14 --- mode: ChanServ set +o glguy
20:39:19 --- mode: glguy set -b glguy_!*@*
20:39:23 --- mode: glguy set -o glguy
20:39:38 <glguy> I'm ready for the spammer now!
20:39:42 <glguy> bring it on!
20:40:09 <chessguy> did we have trouble with a spammer today?
20:40:19 <SamB> emu: I think he was testing banning ;-)\
20:40:19 <glguy> yeah
20:40:44 <glguy> he got his 3 messages in before we could kill him
20:40:46 <sjanssen> glguy: are you using colloquy scripts?
20:40:49 <glguy> unacceptable :)
20:40:59 <glguy> sjanssen: I'm using a colloquy script to speed up /op
20:41:04 <sorear> glguy: he was here yesterday - twice
20:41:06 <glguy> sjanssen: and a different one I wrote for /kb
20:41:07 <SamB> yeah! kill him and plunder his corpse!
20:41:17 <sorear> ZOTTTTT!
20:41:23 <sjanssen> glguy: wanna share your scripts?
20:41:25 <chessguy> hey glguy, have you seen the three programs i sketched out that i'm trying to abstract?
20:41:38 <glguy> sjanssen: nothing fancy, but sure
20:42:04 <glguy> this is the one I didn't write: http://colloquy.info/extras/details.php?file=40
20:42:07 <lambdabot> Title: Colloquy: Extras: Plugins & Scripts: ChanServOp
20:42:14 <glguy> !paste
20:42:14 <hpaste> Haskell paste bin: http://hpaste.org/
20:42:25 <hpaste>  glguy pasted "Colloquy /kb script" at http://hpaste.org/320
20:42:39 <glguy> There might be a better way to write that script, but I don't know it :)
20:43:31 <dons> glguy: you working out how to quickly kickban?
20:43:32 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
20:43:44 <glguy> dons: I *figured* out how to
20:43:54 <glguy> I think
20:44:26 <dons> good
20:44:49 <glguy> I've got it down to two steps, each command is two characters long
20:45:05 <glguy> (because I don't know how to tell it to wait for chanserv to op me first)
20:45:17 <dons> yeah, same here
20:45:17 <sorear> dons: nov2006 yi seems to send the whole screen off to curses, every time.
20:46:40 <dons> but then curses should only update the bits that are needed
20:47:12 <sorear> well, same story with vty ...
20:47:23 <sorear> meaning I have no excuse but to say vty is slow
20:47:27 <allbery_b> yes, but that still slows down curss' diff algorithm I think
20:47:53 <allbery_b> if no changes are registered for a line it skips over it completely, so avoiding no-op updates is a good thing
20:48:03 <dons> yeah, hmp3 updates different parts of the screen on their own threads
20:48:15 <dons> which is more efficient. but yi with full screen still runs pretty zippy , iirc
20:48:21 <dons> curses is fast
20:48:54 <sorear> so why are my loops so slow... :(  and I don't really know what to change.
20:49:11 <sorear> should I abandon higher order functions? (zip,filter,sequence_)?
20:49:20 <sorear> should I use UArray instead of [] (API CHANGE)
20:49:22 <dons> quite possibly yes.
20:49:30 <dons> look at the loops in Data.ByteString
20:49:44 <dons>  and learn the mysteries of -ddump-simpl :)
20:49:59 <sorear> should I use an abstract type for attributes, containing a single Word8# ?
20:50:18 <SamB> Word8#?
20:50:19 <sorear> should I use an immediate-mode interface ?
20:50:20 <SamB> why 8?
20:50:30 <glguy> someone say "ADULT FORUM" for me?
20:50:34 <sorear> SamB: because 32 is 4x slower, intuitively?
20:50:41 <SamB> ADULT FORUM
20:50:42 <chessguy> ADULT FORUM
20:50:42 <glguy> (not auto killing)
20:50:46 <LoganCapaldo> ADULT FORUM
20:50:48 <glguy> hmm, ok, didn't work
20:50:49 <lambdabot> ADULT FORUM
20:50:51 <glguy> THAATS ENOUGH :)
20:50:55 <SamB> hehehehe
20:50:58 <chessguy> haha
20:51:10 <chessguy> we're eager to please
20:51:15 <LoganCapaldo> @where+ af ADULT FORUM
20:51:16 <lambdabot> Done.
20:51:23 <LoganCapaldo> @where af
20:51:24 <lambdabot> ADULT FORUM
20:51:24 <allbery_b> heh
20:51:29 <SamB> sorear, dons: that was a bit overdoing it, I think...
20:51:33 <lambdabot> Free ADULT FORUM - http://www.hpaste.org
20:51:41 <chessguy> haha
20:51:48 <SamB> hmm, true dat ;-)
20:51:49 <allbery_b> *snerk*
20:51:52 <Pseudonym> LOL!
20:51:55 <chessguy> ?remember lambdabot Free ADULT FORUM - http://www.hpaste.org
20:51:55 <lambdabot> Done.
20:51:59 <sorear> SamB: Ok, I'll stop (for now)
20:52:05 <SamB> @quote lambdabot
20:52:06 <lambdabot> lambdabot says: Free ADULT FORUM - http://www.hpaste.org
20:52:07 <SamB> @quote lambdabot
20:52:08 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
20:52:10 <SamB> @quote lambdabot
20:52:11 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
20:52:15 <SamB> heh
20:52:23 <SamB> @quote lambdabot
20:52:23 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
20:52:28 <SamB> @quote sorear
20:52:28 <lambdabot> sorear says: ghc's map fusion is provably incorrect
20:52:31 <chessguy> @quote forum
20:52:31 <lambdabot> No quotes match. You speak an infinite deal of nothing
20:52:40 <chessguy> @quote FORUM
20:52:40 <SamB> hmm.
20:52:40 <lambdabot> lambdabot says: Free ADULT FORUM - http://www.hpaste.org
20:52:43 <SamB> I like the old way
20:52:45 <sorear> that's my least favorite :(
20:52:48 <sorear> @quote sorear
20:52:49 <lambdabot> sorear says: I can actually hold a conversation with chanserv [/talking about NOTICE]
20:52:54 --- mode: ChanServ set +o sjanssen
20:53:12 --- mode: ChanServ set +v sorear
20:53:14 <dancor> so should i treat 2d arrays as y,x
20:53:14 <nornagon> @quote type-check
20:53:14 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
20:53:24 <nornagon> @quote type-check
20:53:24 <lambdabot> SyntaxNinja says: * SyntaxNinja does the type-checking dance ;)
20:53:27 --- mode: ChanServ set -v sorear
20:53:29 <dancor> it seems like elems is going to give me them that way
20:53:44 <nornagon> @quote party
20:53:45 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
20:53:49 <dancor> or should i make a stand and say that x,y is more natural
20:53:58 <dancor> and throw in transpose as needed
20:54:50 <es> I have a set of functions that work. Then I found something worth notifying user down the line. I found myself rewriting that set of functions to be in IO type. Is this typical or am I doing it wrong?
20:55:23 <allbery_b> take a look at Control.Exception
20:55:25 --- mode: ChanServ set -o sjanssen
20:55:51 <allbery_b> you still need to run in IO to catch it, if that's what you want t do, but you can throw from pure code
20:55:51 <chessguy> so, do i remember correctly that someone said there's a back-tracking monad?
20:56:00 <sorear> []
20:56:08 <glguy> chessguy: other than MonadNondet and List?
20:56:27 <chessguy> glguy, i guess
20:56:42 <chessguy> i don't really know what they meant by it, but it sounds interesting
20:58:14 <Pseudonym> ListT is, unfortunately, wrong in subtle ways.
20:58:19 <Pseudonym> MonadNondet is better.
20:58:22 <Pseudonym> If I do say so myself.
21:00:05 <es> allbery: I'll check that out. Come to think of it, that looks like I'm wanting a side effect, printing warning, but haskell won't allow that I think.
21:00:31 <allbery_b> secretly it does, but best not.
21:00:45 <chessguy> WriterT?
21:00:53 <bd_> es: Are you looking for something just for debugging, or is this for production output?
21:01:03 <bd_> If the latter, WriterT + Data.Sequence is probably best
21:01:15 <allbery_b> you can use Control.Exception to throw exceptions (which must be caught in IO, but can br thrown from pure); Writer monad; MonadError (e.g. Either String)
21:01:28 <allbery_b> the other options require rewriting your code though
21:01:56 <es> Well, I'm just playing, and my mind is not tuned to haskell yet.
21:02:17 <allbery_b> are these notifications supposd to stop processing?
21:02:35 <SamB> Debug.Trace could be abused for warnings, also
21:02:55 <allbery_b> if not, you probaly need Writer/WriterT, or abusing Debug.Trace or other evil
21:03:25 <chessguy> what's the difference between Writer and WriterT?
21:03:41 <dancor> is y,x arrays just trashy c-minded-ness or is there like still some efficiency value
21:04:01 <bd_> dancor: y,x arrays?
21:04:08 <dancor> indexing 2d arrays
21:04:08 <allbery_b> WriterT is a transformer:  it can be stacked on oter monads
21:04:29 <allbery_b> if you stack on top of Identity you get Writer, effectively
21:04:41 <dancor> i have a 2d array of ints m which i then print by manipulating elems m
21:04:45 <bd_> dancor: It can be convenient in some cases... if you're modeling somethis which is logically two-dimensional it can be convenient to be able to use the corrdinates directly
21:05:20 <dancor> bd_: but should i treat the first index as the vertical position
21:05:42 <dancor> m // [((x, y), v)]  or  y, x
21:05:50 <allbery_b> which is more convenient for you?
21:06:15 <chessguy> allbery_b, ok, that's what i thought you were going to say. just wanted to make sure i was right
21:06:22 <chessguy> i'm slowly starting to get the hang of this
21:06:53 <dancor> allbery_b: y, x is more convenient for printing..
21:06:54 <bd_> dancor: oh, I see. If you're looking to squeeze the last bit of performance out, you could improve the cache coherency by traversing the last dimension first
21:07:31 <bd_> that is in (0, 0) -> (3, 3),  (0, 0), (0,1) ... would be marginally more efficient than (0,0) (1,0), since the indexes are located closer in R
21:07:34 <bd_> AM
21:08:58 <sorear> dons: part of the problem is that ghc is *very* effective at uglifying vty.  I could read the -ddump-simpl from nornagon's mandlebrot, but vty expands to fourty thousand lines of garbage. (with minimal options and trimmed to one file, still thousands)
21:12:51 <Pseudonym> If you think that's bad, you should see RTL code.
21:17:18 <dancor> what is the right way to read an int from a string
21:17:25 <sorear> read
21:17:28 <dancor> with like Mabye return
21:17:35 <sorear> reads
21:17:36 <dancor> i don't want extreme death
21:17:44 <sorear> reads.
21:17:54 <sorear> > listToMaybe . reads $ "100"
21:17:55 <lambdabot>  Add a type signature
21:18:20 <bd_> > listToMaybe . reads $ "100" :: Int
21:18:21 <lambdabot>  Couldn't match `Int' against `Maybe (a, String)'
21:18:24 <sorear> > (listToMaybe . map fst . filter (null . snd) . reads $ "100") :: Maybe Int
21:18:25 <lambdabot>  Just 100
21:18:29 <sorear> > (listToMaybe . map fst . filter (null . snd) . reads $ "100s") :: Maybe Int
21:18:31 <lambdabot>  Nothing
21:18:36 <sorear> > (listToMaybe . map fst . filter (null . snd) . reads $ "11s00") :: Maybe Int
21:18:37 <lambdabot>  Nothing
21:18:41 <sorear> > (listToMaybe . map fst . filter (null . snd) . reads $ "12") :: Maybe Int
21:18:43 <lambdabot>  Just 12
21:18:45 <sorear> > (listToMaybe . map fst . filter (null . snd) . reads $ "") :: Maybe Int
21:18:47 <lambdabot>  Nothing
21:18:50 <sorear> > (listToMaybe . map fst . filter (null . snd) . reads $ " 2") :: Maybe Int
21:18:52 <lambdabot>  Just 2
21:19:42 <dancor> is there a stricter one where initial space is not allowed
21:19:56 <dancor> maybe i'll just write what i want
21:19:58 <sorear> I don't know :(
21:20:07 <dancor> prelude be damned
21:20:41 <LoganCapaldo> let readStrictly ' ':xs = error "Initial space"; readStrictly xs = reads xs
21:20:44 <LoganCapaldo> :-p
21:20:49 <dancor> nice
21:20:57 <nornagon> ewww.
21:21:06 <nornagon> partial functions ftl.
21:21:12 <jcreigh> readInt s = if all isDigit s then Just (read s) else Nothing
21:21:19 <jcreigh> readInt :: String -> Int
21:21:34 <dancor> s/I/Maybe I/
21:22:46 <sorear> hah! that's partial
21:22:52 <sorear> readInt "" --> _|_
21:23:00 <sorear> er Just _|_
21:24:20 <jcreigh> sorear: oh, you're right
21:24:36 <jcreigh> is there an all1? :)
21:24:56 <chessguy> ?type all
21:24:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:25:04 <bobwhoops> Is there an easy way to remove every nth element from a list?
21:25:09 <jcreigh> > all (const False) []
21:25:11 <lambdabot>  True
21:25:27 <LoganCapaldo> all1 p [] = error "Partial function"; all1 p xs = all p xs ;)
21:25:39 <nornagon> > all isDigit ""
21:25:41 <lambdabot>  True
21:25:47 <allbery_b> readInt x@(_:_) | all isDigit x = Just (read x) | otherwise = Nothing; readInt _ = Nothing
21:26:11 <LoganCapaldo> > all (not . isDigit) ""
21:26:13 <jcreigh> hmm...I was thinking "all1 f []" would be False, so all1 is a bad name for it.
21:26:13 <lambdabot>  True
21:26:13 <glguy> nornagon: that fits the classic definition of all :)
21:26:18 <mauke> > read " 1" :: Int
21:26:19 <lambdabot>  1
21:26:24 <LoganCapaldo> I love all :)
21:26:28 <glguy> > all isDigit "" && any isDigit ""
21:26:29 <lambdabot>  False
21:26:47 <nornagon> nice
21:26:56 <glguy> > liftM2 (&&) (all isDigit) (any isDigit) "123"
21:26:58 <lambdabot>  True
21:27:15 <mauke> case reads x of [(n,"")] -> Just n; _ -> Nothing
21:27:22 <chessguy> @pl foo n ls = (take (n-1) ls) ++ (foo $ (drop n ls))
21:27:23 <lambdabot> foo = fix (ap (ap . ((++) .) . take . subtract 1) . (. drop) . (.))
21:28:19 <glguy> > concat . take 2 . takeWhile (not . null) . iterate (drop 3) $ [1..10]
21:28:20 <chessguy> hm
21:28:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,4,5,6,7,8,9,10]
21:28:40 <glguy> > concat . map (take 2) . takeWhile (not . null) . iterate (drop 3) $ [1..10]
21:28:41 <lambdabot>  [1,2,4,5,7,8,10]
21:28:52 <allbery_b>  @pl generated fix!
21:29:26 * glguy is listening to She's Good For Business by Mstrkrft from The Looks
21:29:29 <chessguy> > concat . map (take 2) . takeWhile (not . null) . iterate (drop 3) $ [1,15,3,7,2,92,3,19]
21:29:30 <lambdabot>  [1,15,7,2,3,19]
21:29:38 <glguy> it's a shame that #haskell strips out color codes ;)
21:29:56 <SyntaxNinja> is there an mbox parser in Haskell somehwere?
21:30:05 <chessguy> darnit, glguy, where do you come up with this crap so fast
21:30:06 <SyntaxNinja> btw, I just uploaded HAppS and hxt to hackage :)
21:30:24 <SyntaxNinja> hackage rocks!
21:30:25 <chessguy> it's going to take me ten minutes to even figure out what you did
21:30:27 <glguy> chessguy: I eat strawberries
21:31:06 <chessguy> > iterate (drop 3) $ [1..10]
21:31:08 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10],[],[],[],[],[],[],[...
21:31:54 <chessguy> > takeWhile (not . null) . iterate (drop 3) $ [1..10]
21:31:56 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10]]
21:32:23 <chessguy> incredible
21:36:05 <skeh> Hey, does anyone know of a place where I can find old GRE CS exams
21:36:35 <zarvok> you can find one sample exam at the GRE website
21:36:43 <zarvok> but I don't know that there are any others available
21:36:52 <zarvok> there aren't any good books
21:36:59 <skeh> I know
21:37:03 <skeh> it angers me
21:37:17 <dons> phew, just update the k-nuc benchmark. still too slow though (the hashtable library isn't so optimal)
21:37:20 <zarvok> the official booklet, though, has an outline of topics
21:37:21 <dons> good thing no one uses it ;)
21:37:28 <zarvok> heh
21:37:39 <glguy> ?shootout
21:37:40 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:37:54 <glguy> Hurrah for beating SML
21:37:57 <zarvok> dons: beat SML yet?
21:37:58 <zarvok> ah
21:38:00 <zarvok> well then
21:38:04 <dons> getting close...
21:38:09 <chessguy> ?where shootout
21:38:09 <lambdabot> http://shootout.alioth.debian.org/
21:38:13 <dons> probably after knuc goes through
21:38:42 <dons> bytestrings really make some of this high perf stuff easier
21:38:53 <dons> compared to last time i tried to do some of these entries
21:38:59 <chessguy> hmm, is that link right?
21:39:00 <bos> dons: ByteString's readInt doesn't check for overflow
21:39:07 <dons> now you just suck in a bytestring and if needed, play with its Ptr
21:39:10 <bos> this seems like a bug to me.
21:39:16 <dons> yeah, sounds like a bug..
21:39:26 <bos> ok, i'll file a bug somewhere.
21:39:30 <bobwhoops> skeh: There was this one cheap book I found that had 4 exams in it, but I can't recall what it's called
21:39:31 <dons> or, use readInteger (if anyone cares enough, they can patch.. :)
21:39:35 <bos> heh.
21:39:52 <bos> is there an fps trac instance, or should i use ghc, or what's your preference?
21:40:00 <dons> zarvok: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=mlton
21:40:03 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/yqhybo
21:40:08 <dons> i'd say that's "close"
21:40:26 <dons> mandelbrot and knuc can do better on the haskell side
21:40:44 <dons> and regex-dna (though that'll be hard since the regex-tre lib isn't on the shootout)
21:40:47 <glguy> why is GHC so sexy for binary trees?
21:40:50 <zarvok> yeah, it's quite impressive, mlton is very fast
21:41:02 <glguy> the code doesn't look particularly tuned
21:41:02 <dons> glguy: fp is born for data structures like that
21:41:22 <dons> glguy: looks are deceiving (though this also shows how much better ghc is than a year ago)
21:42:13 <dons> ghc generates pretty much perfect Core for the binary-trees problem
21:42:29 <dons> its only gcc letting us down in the end (its asm doesn't spot loops, so every loop is a computed jump)
21:42:31 <chessguy> hmm, where's the front page for the shootout that shows how many overall points each language has?
21:42:42 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:42:45 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/lepfo
21:42:56 <glguy> why does fasta default to 0
21:43:06 <chessguy> aaha
21:43:15 <chessguy> any objection to where+'ing that?
21:43:20 <dons> go for it
21:43:21 <dons> ?shootout
21:43:22 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:43:26 <dons> ^^
21:43:41 <chessguy> ?where+ shootout http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:43:42 <lambdabot> Done.
21:43:45 * glguy wonders why that has a separate plugin
21:44:12 <chessguy> so haskell has already passed SML, overall
21:44:14 <glguy> dons: I like what you did to sum-file
21:44:23 <glguy> it's *the fastest*
21:44:27 <dons> so, what's left: fix nbody, improve mandelbrot and fannkuch
21:44:43 <dons> yeah, there's a 15 or so instruction loop generated by ghc for that
21:44:46 <dons> its very very nice :)
21:44:55 <dons> i like how the two pure lazy languages are ranked 1 and 2 in sum-file
21:45:15 <glguy> tis sick
21:45:21 <dons> its still a bit harder than it should be
21:45:29 <dons> but things are miles better than a year ago
21:45:54 <zarvok> dons: what's the problem on nbody? ghc 6.6 changes?
21:46:24 <dons> it depends on the mtl monad library, which isn't on the shootout now
21:46:29 <dons> (it used to be bundled with ghc)
21:46:35 <zarvok> ah
21:46:38 <dons> so you can't actually use any monad transformers in shootout code :(
21:46:57 <glguy> dons, would cheap-concurrency benefit from using Chan
21:46:58 <zarvok> who controls what is on shootout?
21:47:24 <dons> the shootout team, you isaac gouy, brent fulgram and some other hackers
21:47:34 <dons> s/you/ you can check the cvs repo for names/
21:47:47 <sjanssen> will the shootout team add mtl for us?
21:48:13 <dons> we might have to ask nicely. though from experience (e.g. binary) inlining any monad you need is going to be faster
21:48:37 <dons> the mtl stuff doesn't have the right INLINE pragmas to unfold properly
21:49:12 <dons> and if we can't do better with the 'mandelbrot' one, i'd submit a bug report to ghc HQ
21:49:45 <dons> this shows the broken entries: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=clean
21:49:47 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2aslsn
21:50:07 <dons> i.e. we match clean mostly, 'cept for the entries not yet updated
21:50:28 <matt__r> why is clean having an easier time getting fast results?
21:50:33 <matt__r> is it strict?
21:50:38 <matt__r> it is pure right?
21:50:55 <sorear> matt__r: it is pure and lazy *but* has very different idioms.
21:51:00 <dons> yeah, though with uniquness types they tend to drop down to mutable data very easily
21:51:20 <dons> note that all the new ghc 6.6 bytestring entries run at clean speed
21:51:21 <matt__r> a question that I don't mean to provoke people with....
21:51:30 <matt__r> why is haskell more popular than clean?
21:51:40 <olliej> dons: you know of any papers/workshop-type tutorials on implementing damas milner type inference?
21:51:41 <dons> community and libraries and research base
21:51:47 <dons> also, licenses
21:51:51 <matt__r> ahhh
21:51:59 <dons> olliej: there must be some. but not off the top of my head
21:52:00 <sorear> isn't clean GPL?
21:52:10 <matt__r> but when push comes to shove, there is little to choose between the actual languages, right?
21:52:10 <olliej> dons: righto
21:52:29 <dons> matt__r: yeah, though for getting things done you'd need the much larger library base haskell has
21:52:29 <sorear> #haskell! :)
21:52:42 <matt__r> it makes me think the clean compiler would make an interesting study
21:52:42 <dons> for performance, i think we can match clean now ('cept maybe on floating point)
21:53:02 <matt__r> since it seems fewer people have managed to put together something very respectable
21:53:02 <sorear> is jhc still faster than ghc?
21:53:03 <zarvok> what's clean do differently for floating point stuff?
21:53:06 <dons> ben l's phd is a product, he was telling me, of fixing Clean :)
21:53:14 <dons> zarvok: better native code generator
21:53:21 <zarvok> hmm
21:53:23 <matt__r> sweet
21:53:27 <glguy> Clean has uniqueness types, but those only solve stuff that ST does, right?
21:53:42 <matt__r> we need to get ben l on here
21:53:44 <glguy> in general they address different issues than monads do?
21:53:45 <dons> yeah, they tag ST-like structures nicely on the type level
21:53:57 <matt__r> he is all the way down south
21:53:59 <dons> we use the FFI for things that a Clean guy would use a uniquness type
21:54:02 <sorear> dons: vty problem: how do I make a UArray of an abstract type?  kill the abstaction?  *dread* *dread*
21:54:15 <sorear> the FFI?
21:54:17 <dons> (e.g. drop into a Ptr, mutate in place, but only if you assure yourself on the side that you've got uniqueness)
21:54:30 <matt__r> foreign function interface?
21:54:35 <dons> right.
21:54:36 <sorear> how does Ptr beat UArray?
21:54:41 <bos> dons: http://cvs.haskell.org/trac/ghc/ticket/1132
21:54:43 <lambdabot> Title: #1132 (Data.ByteString.Lazy.Char8's readInt does no bounds checking) - GHC - Tra ...
21:54:56 <dons> at least, I use the FFI like a flexible ST monad. to achieve the same affect a clean hacker would get tagging an array as unique
21:54:57 <matt__r> although clean definately uses uniqueness types for guis
21:55:24 <sorear> dons: what makes Ptr better than IOUArray?
21:55:33 <sorear> (no bounds/etc?)
21:55:35 <dons> IOUArray's can be quite good
21:55:37 <glguy> but they don't address the area of DSLs , right?
21:55:42 <dons> very good, if you use unsafe*
21:55:57 <matt__r> maybe a wallace-style clean v haskell showdown would be interesting
21:56:02 <chessguy> can uniqueness types not be expressed efficiently in haskell?
21:56:11 <glguy> and threaded state
21:56:19 <dons> matt__r: here's an example of using the FFI (and a programmer provided manual check) to do uniqueness hacking in haskell, http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp&lang=ghc&id=2
21:56:21 <lambdabot> Title: reverse-complement Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&n ..., http://tinyurl.com/yobub3
21:56:27 <matt__r> http://nhc98.blogspot.com/2005/10/ocaml-vs-haskell-is-strict-language.html
21:56:29 <lambdabot> Title: malcolm: O'Caml vs Haskell - is a strict language faster?, http://tinyurl.com/2cj6er
21:56:35 <dons> here, revcomp is used on a bytestring i know isn't reused
21:56:45 <dons> of course, the type checker can't work this out, i have to do it manually
21:57:06 <sorear> dons: how do I make vty's interface use UArray without breaking the abstraction on Attr?
21:57:13 <dons> sorear: hmm.
21:57:40 <matt__r> dons: tricky
21:57:40 <dons> chessguy: you can express them on the value level, and probably if you're super-clever, using an ST-like type
21:57:57 <dons> so the Clean compiler infers that kind of stuff from the type though
21:58:15 <dons> we do some similar things with rewrite rules, actually, in the bytestring lib
21:58:19 <sorear> there is a phd out there somewhere to add uniqueness types to haskell
21:58:22 <skeh> Hey, does anyone know of a place where I can find old GRE CS exams
21:58:25 <skeh> ooops sorry
21:58:26 <dons> since the stream fusion mechanism generates unique stream values, not available from outside
21:58:27 <glguy> Clean's GUI was a big turn off for me in the beginning
21:58:28 <skeh> already asked once
21:58:30 <dons> so they can be updated in place
21:58:33 <glguy> I'd rather no GUI than a terrible one
21:58:48 <matt__r> glguy: with you on that one
21:59:01 <dons> sorear: i'm not sure we need them. though an analysis to find some uniqueness, on strict types, would be neat
21:59:04 * matt__r was forced to use motif for a few years
21:59:16 <dons> but we get it almost there with rewrite rules and fusion anyway
21:59:19 * matt__r wonders who the hell ever thought that looked good
21:59:41 <sorear> rewrite rules are IMO one of haskell's greatest advantages.
22:00:02 <sorear> for all its superficial complexity haskell's interior is shockingly orthogonal
22:00:09 <sjanssen> bos: note that readInt's behavior is consistent with read
22:00:12 <sorear> lisp is a programmable programming language.
22:00:21 <sorear> haskell is a programmable optimizing compiler.
22:00:22 <sjanssen> > read "99999999999999999999" :: Int
22:00:23 <lambdabot>  1661992959
22:00:30 <dons> bos, yeah, the QC properties at least say read matches readInt
22:00:45 <dons> if it actually diverges from 'read', please record that. otherwise no change :)
22:00:46 <allbery_b> matt__r:  BITD it was a "nice" 3D version of the Windows (2.11) UI
22:00:47 <bos> ok, that makes me feel better. now we have two bugs :-)
22:01:03 <dons> well, it means its in the report, not the fps code ;)
22:01:17 <allbery_b> of course, Windows went on to come up with something less ugly, while Motif stagnated
22:01:19 <matt__r> bitd?
22:01:19 <mauke> > 99999999999999999999 :: Int
22:01:21 <lambdabot>  1661992959
22:01:24 <allbery_b> "back in the day"
22:01:30 <matt__r> ahh
22:02:42 <bos> it's very old school to not bounds-check reading integers :-) feel like c!
22:03:03 <sjanssen> bos: you could use readInteger
22:03:10 <bos> i know.
22:04:32 <sjanssen> > fromInteger 99999999999999999999 :: Int
22:04:33 <lambdabot>  1661992959
22:05:24 <sjanssen> I'm not sure what readInt should return in this case
22:05:46 <sjanssen> maybe Just (_|_, restOfString)
22:06:52 <bos> my suggestion was Nothing
22:07:24 <sjanssen> that's probably more useful
22:08:05 <bos> but really anything that doesn't cause the nuclear launch codes to be used is better than wrapping every maxBound :: Int
22:08:27 <dons> use Integer! :)
22:08:48 <bos> but! but!
22:27:32 <bd_> ?where zlib
22:27:33 <lambdabot> darcs get http://haskell.org/~duncan/zlib
22:28:41 <bd_> ?where binary
22:28:41 <lambdabot> http://darcs.haskell.org/binary
22:33:20 <bos> i wonder if karsten wagner's ears are aflame yet.
22:38:30 <Cale> hm?
22:38:45 <Cale> Oh, that reminds me, I should reply to him again.
22:39:57 <carebear666> if you ever try to kick me or ban me i will get my uncle(irc opp) after you and by the way i have a nuke and a mail bomb on the way asshole
22:40:27 --- mode: ChanServ set +o dons
22:40:32 <carebear666> if you ever try to kick me or ban me i will get my uncle(irc opp) after you and by the way i have a nuke and a mail bomb on the way asshole
22:40:36 --- mode: ChanServ set +o glguy
22:40:38 --- mode: glguy set +b carebear666!*@*
22:40:38 --- kick: carebear666 was kicked by glguy (glguy)
22:40:43 --- mode: ChanServ set -o dons
22:42:39 <dons> glguy: did you ever work out how to get the kick alias to wait on ops before kicking?
22:42:47 <glguy> dons not yet :(
22:43:21 <dons> hey nalioth
22:43:42 --- mode: glguy set -o glguy
22:43:47 <nalioth> i see i'm too late for the floor show  :P
22:43:48 <nalioth> hi dons
22:43:51 <dons> yeah :)
22:44:53 <glguy> dons: were you waiting to kick?
22:45:07 <dons> glguy, no, couldn't remember the command :) all hacked out today
22:45:10 <glguy> lol
22:45:11 <glguy> ok
22:45:19 <glguy> I heard the sound effect and wondered what happened
22:45:34 <glguy> so I switched to this computer and saw he was still in channel!
22:45:36 <glguy> zomg ;)
22:45:41 <glguy> so I used my new /kb command
22:45:50 <dons> yeah, that's what i was fumbling around for
22:45:56 <glguy> since I usually can't type the right command in in a pinch
22:46:21 <glguy> #haskell ops are a laid back bunch ;)
22:46:46 <dons> heh
22:46:51 <dons> ?users
22:46:51 <lambdabot> Maximum users seen in #haskell: 322, currently: 282 (87.6%), active: 36 (12.8%)
22:46:58 <glguy> Oh shoot, I have to ban someone...
22:47:02 <glguy> okay, lets see
22:47:07 <glguy> 'K'
22:47:12 <glguy> 'i'
22:47:17 <glguy> oops, forgot the slash
22:47:22 <glguy> backspace backspace
22:47:26 <glguy> :)
22:48:26 <glguy> I don't understand why people do that to channels...
22:48:51 <dons> people are strange
22:48:52 <glguy> what possible joy is there to be had
22:48:53 <allbery_b> I'm guessing that lastone was a hijacked account, someone's trying to get it banned from as many channels as possible
22:49:04 <glguy> ah
22:49:06 --- mode: ChanServ set +o glguy
22:49:21 --- mode: glguy set -b carebear666!*@*
22:49:32 --- mode: glguy set -o glguy
22:49:38 <glguy> I'm not going ot play into *that* game ;)
22:49:47 <glguy> besides, if he comes back it will be worth the practice
22:49:56 <dons> yeah, i've just set chanserv to block the host
22:50:07 <dons> blocking nicks isn't that useful, 'cept for particular trolls
22:50:19 <glguy> blocking nicks is useful for the short term
22:50:22 <glguy> if they have autorejoin on
22:50:51 <glguy> it's also volumes easier to do in applescript when you don't know hardly any of it
22:51:27 <glguy> we'd fix the spammer problem if we just required nickserv ident
22:51:29 <glguy> :)
22:51:42 <glguy> hardly any spammers use it
22:53:05 <Ytinasni>  how many of the users here use it, though?
23:00:24 <nalioth> your carebear friend ran amuck in another channel and caught the k-train
23:00:55 <nalioth> if it was a professional troll, i'm sure he'll be back soon
23:01:01 <nalioth> ciao
23:05:34 <glguy> lawl @ pro trolls
23:05:45 <glguy> I guess everyone wants to be good at *something*
23:14:27 <bos> glguy: answer to an earlier question of yours: http://www.penny-arcade.com/comic/2004/03/19
23:14:28 <lambdabot> Title: Penny Arcade! - Green Blackboards (And Other Anomalies)
23:14:40 <glguy> :)
23:17:16 <bos> any haskellers use del.icio.us?
23:18:01 <sjanssen> bos: I do on occasion
23:19:49 <hyrax42> I do
23:23:38 <hyrax42> as a one-way thing mostly
23:23:38 <hyrax42> to allow me to close tabs
23:24:47 <Cale> hm?
23:44:57 <astrolabe> Is there a way to get strict arrays, other than using unboxed ones?
23:45:41 <nornagon> [!a]?
23:45:59 <dons> astrolabe: use an unboxed array
23:46:08 <dons> or explicitly force values with ! patterns
23:46:24 <astrolabe> thanks guys
23:46:48 <dons> some kinds of strictness you can get with Array Int T ; data T = T !Int -- a bit stricter (in the elements)
23:48:22 <astrolabe> Hmmm I think it's the elements that are giving me problems
23:48:50 <dons> any reason not to use Data.Array.Unboxed?
23:51:18 <astrolabe> As a sanity check, I'm using foldl' on a long list.  I'm guessing that this means that the operation I'm using with foldl' has to be strict in the list elements.  Is this right?
23:51:36 <astrolabe> dons: It's not haskell98.
23:53:09 <astrolabe> But it sounds as though that's what I should use anyway.
23:54:35 <dons> you're sticking to h98?? why? :)
23:54:40 <dons> just use the base libs.
23:54:54 <dons> i wonder if anyone sticks to python98
23:55:10 <dons> or ruby98.. (though i guess ruby still runs like its 1988)
23:55:31 <glguy> if you write for haskell 98, you are admitting your code is 9 years out of date when you finish ;)
23:55:36 <astrolabe> I'm worried that stuff not in 98 might not compile under later versions of ghc.  Do you think I'm being over cautious?
23:55:48 <dons> yes
23:55:55 <dons> use what's in base, its not going anywhere
23:56:58 <astrolabe> dons: right! thanks!  (I assume you'll be behind me when I storm Microsoft research in 10 years time :)  )
23:57:28 <dons> sure!
23:58:38 <kfish> Functional Fate?: http://www.functionalfate.org/images/thumb-10851147.jpg
