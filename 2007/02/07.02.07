00:19:14 <dons> ?yow
00:19:15 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
00:19:29 <newsham> ?yarr
00:19:30 <lambdabot> Yarrr!
00:24:32 <siti> @botsnack
00:24:33 <lambdabot> :)
00:24:47 <xpika> what does the 'M' in "MVar" stand for?
00:24:52 <siti> umm
00:24:55 <siti> Multi?
00:25:19 <siti> multithread?
00:25:34 <glguy> magic?
00:25:38 <siti> :D
00:25:55 <xpika> what about TVar?
00:26:16 <glguy> transactional
00:28:16 <mauke> @src sequence
00:28:16 <lambdabot> sequence ms = foldr k (return []) ms
00:28:17 <lambdabot>     where
00:28:17 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
00:28:17 <Thunder> xpica: MVar is "Mutable Variable"
00:31:14 <dons> mutable?
00:31:18 <dons> its a mutable variable
00:33:13 <glguy> isn't that a bit redundant? :)
00:33:51 <pjd_> glguy: mathematically, variables aren't mutable :)
00:34:42 <glguy> from wikipedia, stolen by answers: In mathematics, a variable often represents an unknown quantity that has the potential to change;
00:34:46 <siti> mathematically you can't do concurrency and make real apps ;)
00:35:09 <glguy> Variables are often contrasted with constants, which are known and unchanging.
00:35:14 <glguy> (I know this proves nothing)
00:35:52 <JKnecht> siti what are you talking about?
00:36:03 * glguy &
00:36:22 <siti> (21:31:03) pjd_: glguy: mathematically, variables aren't mutable :)
00:37:03 <pjd_> glguy: it all depends on the context within which "change" is defined, i guess
00:38:07 <siti> could the person who does hoogle make it search gtk2hs libs :(
00:38:43 <pjd_> the way mathematical variables "change", say, in an equation, correspond more or less to the way Haskell variables "change", when functions are invoked with different parameters
00:39:12 <pjd_> within an evaluation/invocation, there is no change
00:39:17 <pjd_> (in both cases)
00:40:47 <pjd_> the way MVars change is a completely different beast; the closest thing you'll get in mathematics is probably in one of the concurrency calculi
00:41:05 <pjd_> (pi, join, and so on)
00:41:27 <pjd_> </navelgaze>
00:46:00 <mauke> @pl (a -> c) -> (b -> d) -> Either a b -> Either c d
00:46:01 <lambdabot> (line 1, column 4):
00:46:01 <lambdabot> unexpected ">"
00:46:01 <lambdabot> expecting variable, "(", operator or ")"
00:46:05 <mauke> @hoogle (a -> c) -> (b -> d) -> Either a b -> Either c d
00:46:06 <lambdabot> No matches, try a more general search
01:03:15 <mauke> @src Maybe mplus
01:03:15 <lambdabot> Nothing `mplus` ys  = ys
01:03:16 <lambdabot> xs      `mplus` _ys = xs
01:27:58 <quazimodo> hello people
01:28:04 <quazimodo> hrm nvm
01:28:09 <quazimodo> too silent here
01:28:14 * quazimodo sneaks away
01:28:52 <Cale> hi
01:39:33 <mauke> argh, why isn't m automatically an instance of Monad
01:40:40 <sieni> ecause
01:40:42 <sieni> because
01:48:52 <siti> @hoogle gmapQ
01:48:53 <lambdabot> Data.Generics.Basics.gmapQ :: Data a => (a -> u) -> a -> [u]
01:48:54 <lambdabot> Data.Generics.Basics.gmapQi :: Data a => Int -> (a -> u) -> a -> u
01:48:54 <lambdabot> Data.Generics.Basics.gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
01:51:30 <siti> nice article :) http://www.defmacro.org/ramblings/haskell-web.html
01:51:32 <lambdabot> Title: Haskell and Web Applications
01:52:24 <mauke> tokenIf :: (Stream s, Monad m) => (t -> Bool) -> ParserT s t m t
01:55:51 <dcoutts> siti, there is a hoogle for gtk2hs!
01:56:15 <dcoutts> http://haskell.org/hoogle/?package=gtk&q=foo
01:56:16 <lambdabot> Title: foo - Hoogle
01:56:53 <dcoutts> siti, the "Search API docs" thing on the Gtk2Hs web site side-bar is a hoogle search.
01:57:53 <mauke> whee, eof = notFollowedBy anyToken compiles
02:02:56 <dcoutts> dons, I was thinking of continuing the streams & lists work in the fps-unstable repo rather than a new one. Or do you think that'd be unwise?
02:03:29 <dcoutts> I'd start by tagging the current state (to save what we used for the benchmarks in the paper) then strip out the old fusion systems
02:03:46 <dcoutts> move the modules under Experimental.* so we can compile them with 6.6
02:04:05 <siti> dcoutts: ok thanks
02:04:34 <siti> it would be nice if you could search both gtk2hs and the built-in haskell packages...
02:05:16 <dcoutts> siti, that'll be possible in the next version of hoogle. At the moment searching other packages it's a bit of a hack apparently.
02:05:26 <dcoutts> ndm is the chap to ask about it
02:05:27 <siti> ok awesome :)
02:06:46 * Syzygy- jumps into a haskell-cafe discussion about notation and dumps a post about category theory into it....
02:07:13 <mauke> ok, this is my first contact with monad transformers
02:07:19 <mauke> does runParser p s = runIdentity (runParserT p s) look right?
02:07:27 <tessier__> mauke: Say hi to Optimus Prime for me
02:07:41 <mauke> ouch
02:11:51 <dons> dcoutts: i think work on the unstable repoo
02:12:00 <dcoutts> dons, ok :-)
02:12:26 * dcoutts had an email round the department about software patterns
02:12:27 * dcoutts plots how to skew their results towards FP
02:12:45 <dcoutts> http://www.softwarepatterns.eu/
02:12:55 <dcoutts> mwaha ha ha
02:13:14 <siti> you are so evil ;)
02:13:43 <dcoutts> but then I realise they want to know the *number* of *named* software design patterns I use.
02:13:51 <dcoutts> I can't name them
02:14:12 <Syzygy-> Hmmmmm?
02:14:22 <dcoutts> so if a design pattern person came round here with their catalogue
02:14:22 <siti> like OO design patterns?
02:14:37 <dcoutts> what would we say we had in our catalogue?
02:14:39 <dcoutts> yeah OO
02:14:50 <dcoutts> names people. names!
02:15:00 <dcoutts> the design pattern people love names
02:15:18 <siti> yes
02:15:36 <mauke> http://www.lsd.ic.unicamp.br/~oliva/fun/prog/resign-patterns
02:16:23 <dcoutts> heh heh
02:16:50 <siti>  1.5 Simpleton  The Simpleton Pattern is an extremely complex pattern used for the most trivial of tasks. The Simpleton is an accurate indicator of the skill level of its creator.
02:16:51 <siti> :D
02:16:57 <siti> that's the easiest one, irony :)
02:17:24 <dcoutts> yeah I was just about to paste that one :-)
02:17:33 <siti> ok
02:17:53 <siti> 3.11 Visitor From Hell
02:17:54 <siti> lol
02:25:28 <xpika> how can i use newListArray?
02:25:30 <xpika> newListArray (0,3) [0,0,0,0]
02:25:34 <xpika> doesnt work
02:25:46 <siti> > newListArray (0,3) [0,0,0,0]
02:25:46 <mwc> I picked up a book on design patterns at one point. Is there any difference between a fold and a visitor?
02:25:47 <lambdabot>   Not in scope: `newListArray'
02:25:56 <mwc> Not one that I can see anyways
02:26:08 <mwc> I use that as an example of the power and precision of FP.
02:26:50 <siti> mwc: yeah they're pretty much the same
02:26:51 <mwc> @hoogle listArray
02:26:52 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
02:26:52 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
02:26:52 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
02:26:55 <siti> apart from visit is ugly to implement
02:27:01 <siti> vistor
02:27:03 <mwc> are you sure there's a new list array?
02:27:14 <xpika> umm
02:27:19 <xpika> @hoogle newListArray
02:27:20 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
02:27:29 <xpika> acutally
02:27:36 <xpika> @index newListArray
02:27:37 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
02:27:50 <mwc> Why on earth is hoogle case sensitive?
02:27:54 <xpika> the IO one is the one i want to use
02:28:34 <xpika> mwc: I agree, it should use 'smartcase'
02:30:15 <xpika> actually, there is a prefix new on the function i want to use
02:30:25 <mauke> how does it not work?
02:31:19 <xpika> No instance for (MArray a t IO)
02:31:36 <xpika> hoogle IS case insensitive
02:33:56 <xpika> dw: i'll just hpaste it
02:35:38 <dcoutts> dons, SPJ keeps adding more and more rules and spec constr stuff
02:35:47 <dcoutts> Tue Feb  6 04:22:33 PST 2007  simonpj@microsoft.com
02:35:47 <dcoutts>   * Improve rule-matching for let expressions
02:36:14 <dcoutts> what can we match with rules now?
02:37:59 <bakert> If I want to throw an exception from my code, what type should I throw?
02:38:09 <earthy> ?!
02:38:10 <lambdabot> Maybe you meant: . v
02:38:13 <earthy> Either
02:38:15 <earthy> probably
02:38:28 <earthy> but your question hardly makes sense. ;)
02:38:48 <bakert> earthy, I'm actually wrapping a database exception.  so this is going to be a very rare event.  I don't want to have to explicitly deal with Eithers through the code.
02:39:07 <earthy> and you're doing this purely or in a monad already?
02:39:16 <bakert> The database stuff is in IO.
02:39:18 <earthy> if you're in a monad already, use ErrorT
02:39:40 <bakert> ErrorT, eh?  I'll have a read.
02:39:42 <nmessenger> xpika: newListArray (0,3) [0..3] :: IO (IOArray Int Int) -- works in my ghci
02:39:50 <siti> lol no docs ;)
02:39:54 <siti> have fun reading it :D
02:40:03 <bakert> oh dear.
02:40:07 <siti> @hoogle ErrorT
02:40:08 <lambdabot> Control.Monad.Error.ErrorT :: m (Either e a) -> ErrorT e m a
02:40:08 <lambdabot> Control.Monad.Error.ErrorT :: newtype ErrorT e m a
02:40:08 <lambdabot> Control.Monad.Error.mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
02:40:13 <siti> arg
02:40:15 <siti> umm
02:40:19 <siti> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html#v%3AErrorT
02:40:21 <lambdabot> http://tinyurl.com/sw72f
02:40:26 <ivanm> To everyone who was helping me last night with the memoisation stuff, etc: I tried to implement it and it failed, but then I worked out that what I wanted to memoise only takes about 5-10% of the processing time, so memoisation wouldn't make much of a difference
02:40:27 <lambdabot> ivanm: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:40:27 <siti> @botsnack
02:40:28 <lambdabot> :)
02:41:13 <earthy> ofcourse, you could also take a look at Control.Exception... ;)
02:41:21 <ivanm> nmessenger: I just got my messages from you: thanks for the hug, but I assure you my parents were married before I was concieved ;)
02:41:29 <nmessenger> ivanm:  :P
02:41:36 <bakert> earthy, that's what i'm using at the moment.  i catch the db exception and wrap it in a throwIO ErrorCall
02:41:45 <bakert> but I don't think that's what ErrorCall is meant for.
02:42:06 <bakert> There's these Dynamic exceptions but I don't understand them.  That might be what I'm "meant" to use.
02:42:14 <bakert> I really don't understand ErrorT, though!
02:42:42 <earthy> ErrorCall would be wrong indeed. Dynamic would be the correct way
02:43:10 <bakert> The reason I picked ErrorCall was because it allowed me to send a String up the chain.  Not for any other reason.
02:43:25 <earthy> to use it you need to define your own exception type that will capture the exceptions you want to throw, and derive Typeable for it
02:43:29 <bakert> So, ErrorT or Dynamic, which should I spend time trying to understand do you think?
02:43:30 <tessier> Anyone know if How To Design Programs is available in pdf format?
02:43:54 <bakert> http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fportal.acm.org%2Fft_gateway.cfm%3Fid%3D775749%26type%3Dpdf&ei=uqzJRdOqIo_uQbvEodwG&usg=__S0Q4ltYSz62UrHX_ALCZdAHOrK0=&sig2=6M6V-xZyrmFP9o_PPPTb8w
02:43:59 <lambdabot> http://tinyurl.com/29pcss
02:44:04 <earthy> bakert: if you're already using Control.Exception and have handling code, then go with throwDyn
02:44:09 <musasabi> Is there really no standard Proxy type?
02:44:18 <bakert> earthy, OK.  thanks earthy i'll have a look at it.
02:44:54 <earthy> but really, what you do is define your own datatype that derives Typeable and then write a catch function to deal with elements of that datatype
02:45:31 <bakert> Can you give me an example of the type declaration?  No examples in the docs is hurting my understanding.
02:45:46 <bakert> I'm not quite getting this Typeable thing.
02:45:55 <bakert> ?hoogle Typeable
02:45:56 <lambdabot> Data.Typeable :: module
02:45:56 <lambdabot> Data.Typeable.Typeable :: class Typeable a
02:45:56 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
02:46:10 <earthy> data MyException = DBConnnectionException String | DBQueryException String  deriving Typeable
02:46:39 <earthy> that's *all*. ;) then you can call   throwDyn (DBConnectionException "Could not connect to db")
02:46:48 <bakert> earthy, brilliant thanks very much.  So then I can use the normal try and catch with that or does Dynamic have it's own try and catch?
02:48:05 <earthy> and something like catchDyn  (do block) (let handle (DBConnectionException s) = dosomething; handle (DBQueryException s) = dosomethingelse in handle)
02:48:32 <earthy> which is very much like the code you're using anyway
02:48:35 <siti> hmm that's pretty ugly, why can't you define any exception without resorting to the dynamic hack?
02:48:48 <bakert> Brill.  No "try", though?
02:49:04 <siti> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#DynamicExceptions
02:49:06 <lambdabot> http://tinyurl.com/yk8zqb
02:49:11 <earthy> siti: because the Exception type cannot be extended
02:49:24 <siti> why isn't it a class then ?
02:50:04 <earthy> bakert: you could use try, but you'd have to match on 'Dynamic x' and then match on your exception
02:50:14 <Saizan> siti: you would use introspection to get the "concrete" type of exception anyway
03:01:52 <mauke> bah, why is Parsec's notFollowedBy so broken
03:02:29 <bakert> So, -fglasgow-exts.  You all just use that all the time?
03:02:53 <nornagon> any time you want the glasgow extensions, yes.
03:03:00 <mauke> Parsec> parseTest (notFollowedBy (digit >> letter)) "1;"
03:03:01 <mauke> parse error at (line 1, column 1):
03:03:01 <mauke> unexpected ";"
03:03:01 <mauke> expecting letter
03:03:20 <bakert> nornagon, but you don't think that's a bad thing?
03:03:27 <bakert> nornagon, you don't try and avoid it?
03:03:46 <nornagon> not really
03:04:01 <nornagon> I'm not exactly experienced, though -- i just do whatever works.
03:08:07 <ivanm> Can someone explain to me what CAF is? before anyone tells me to look it up myself, I did, but apart from the name "constant application form", I didn't find much
03:10:32 <araujo> morning
03:13:49 <malcolmw> ivanm: a CAF is like a function binding with no arguments
03:14:18 <ivanm> malcolmw: which means?
03:14:52 <malcolmw> ivanm: once it has been evaluated, it hangs around taking up space that can't be reclaimed (unless your compiler is smart)
03:15:42 <ivanm> malcolmw: as in anonymous lambda functions?
03:15:50 <malcolmw> ivanm: also, if you are profiling, the cost of evaluating it can only be attributed to its first user
03:16:17 <malcolmw> ivanm: no, a CAF is not a function - it doesn't take arguments.
03:16:25 <mauke> what is a function binding with no arguments?
03:16:35 <ivanm> that's what I was trying to understand ;)
03:16:57 <Saizan> it's when you have already provided all arguments to your function
03:17:02 <malcolmw> ivanm: e.g. foo = expensive (bar zed)
03:17:15 <sieni> > let foo () = 7 in foo ()
03:17:16 <lambdabot>  7
03:17:20 <ivanm> so, its like a final static variable in java or something?
03:17:23 <malcolmw> it's more of a pattern binding  than an function
03:17:44 <malcolmw> sieni: that's not a CAF
03:18:18 <Saizan> ivanm: it's not static
03:18:29 <mauke> http://haskell.org/hawiki/ConstantApplicativeForm
03:18:29 <malcolmw> a CAF is just an applicative expression, bound to a name.
03:18:30 <lambdabot> Title: ConstantApplicativeForm - The Haskell Wiki
03:18:39 <mauke> why does it have to be bound?
03:18:44 <ivanm> now why couldn't I find that before?
03:18:54 <malcolmw> binding it is what makes it constant
03:19:25 <malcolmw> constant, as in, every time you refer to it, it has the same value
03:19:44 <malcolmw> you couldn't refer to it more than once if it wasn't bound to a name
03:19:54 <Saizan> ivanm: it's a page of the old wiki
03:20:17 <ivanm> OK, that's why I couldn't find it then
03:22:00 <ivanm> well, from what I understand of that page, a CAF doesn't need _all_ of its arguments provided...
03:22:38 <ivanm> so are pointfree functions CAFs?
03:22:58 <mauke> I think so
03:23:08 <Saizan> as partial applications are
03:23:27 <Saizan> in fact i think this as something to do with the monomorphism restriction
03:23:36 <Saizan> s/as/has/
03:23:51 <ivanm> OK, I think that makes sense then... so when profiling, how can I tell which CAF is being referred to?
03:24:42 <Saizan> you can put pragmas to give them names
03:25:13 <Saizan> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html#id3159559
03:25:15 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
03:25:33 <ivanm> OK, I'll have a look....
03:25:48 <ivanm> Its not that big a deal, as they're pretty far down the list, but I was wondering what they were
03:25:59 <ivanm> Thanks!
03:26:46 <ivanm> Another question: was (=<<) introduced in ghc 6.6? Because I have a function using it (got it from pl) and it works on my laptop with 6.6, but it failed on the server at uni with 6.4.2
03:28:01 <nmessenger> "Since one-off costs aren't strictly speaking part of the call-graph of the program, they are attributed to a special top-level cost centre, CAF. There may be one CAF cost centre for each module (the default), or one for each top-level definition with any one-off costs (this behaviour can be selected by giving GHC the -caf-all flag)."
03:28:25 <ivanm> yeah, I just read that...
03:28:30 <ivanm> thanks anyway, nmessenger
03:29:31 <ivanm> @index (=<<)
03:29:32 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
03:33:41 <nmessenger> I would send you to the 6.4.2 docs to check, but they don't seem to work for me right now: http://haskell.org/ghc/docs/6.4.2/html/
03:34:00 <bakert> ?pl         trans = fromMaybe 0.0 (lookup key ts)
03:34:01 <lambdabot> trans = fromMaybe 0 . 0 (lookup key ts)
03:34:05 <nmessenger> anyway, if it isn't there:
03:34:08 <bakert> ?pl         trans = fromMaybe 0 (lookup key ts)
03:34:09 <lambdabot> trans = fromMaybe 0 (lookup key ts)
03:34:10 <nmessenger> @src (=<<)
03:34:11 <lambdabot> f =<< x = x >>= f
03:35:48 <ivanm> nmessenger: I didn't realise that the old docs were kept online... but =<< seems to be there as well... pity I can't remember the error message that came up
03:36:12 <nmessenger> bakert: which lookup are you using?  Data.Map provides lookupWithDefault
03:36:26 <mauke> =<< is in the Haskell98 prelude
03:36:50 <bakert> nmessenger, aha, interesting.  does it deal with Maybes?
03:37:00 <bakert> oh sorry yes of course it does
03:37:03 <bakert> brill!
03:37:24 <nmessenger> @type M.lookupWithDefault
03:37:25 <lambdabot> Couldn't find qualified module.
03:37:44 <bakert> ?hoogle lookupWithDefault
03:37:45 <lambdabot> Data.FiniteMap.lookupWithDefaultFM :: Ord key => FiniteMap key elt -> elt -> key -> elt
03:37:53 <bakert> urk!
03:38:32 <mauke> @type Data.Map.lookupWithDefault
03:38:35 <lambdabot> Not in scope: `Data.Map.lookupWithDefault'
03:38:52 <nmessenger> sorry, findWithDefault
03:39:02 <nmessenger> @type Data.Map.findWithDefault
03:39:04 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
03:39:57 <nmessenger> > findWithDefault 'x' 1 (M.fromList [(4,'d'),(20,'t')])
03:39:58 <lambdabot>   Not in scope: `findWithDefault'
03:40:02 <nmessenger> > M.findWithDefault 'x' 1 (M.fromList [(4,'d'),(20,'t')])
03:40:04 <lambdabot>  'x'
03:40:10 <nmessenger> > M.findWithDefault 'x' 4 (M.fromList [(4,'d'),(20,'t')])
03:40:12 <lambdabot>  'd'
03:42:08 <nmessenger> > m -- heh, still there from yesterday
03:42:10 <lambdabot>  {1:='a',2:='b',3:='c'}
03:43:36 <dons> sjanssen, https://alioth.debian.org/tracker/index.php?func=detail&aid=304447&group_id=30402&atid=411646
03:43:37 <lambdabot> http://tinyurl.com/24fpl5
03:43:47 <dons> a better-still mandelbrot. we'll see what the shootout box things..
03:45:59 <xpika> @t M.fromList
03:45:59 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:46:07 <xpika> @type M.fromList
03:46:09 <lambdabot> Couldn't find qualified module.
03:46:12 <xpika> :(
03:46:25 <nmessenger> @type Data.Map.fromList
03:46:26 <xpika> >:t M.fromList
03:46:27 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
03:46:46 <nmessenger> >:t looks like an angry face :)
03:46:57 <xpika> yes it does..
03:47:39 <xpika> maybe lambdabot should have its prompt changed to *<
03:51:55 <kzm> Whoa.  Data.Binary is no friend of the monomorphism restriction!
03:52:28 <dons> hmm?
03:52:45 <dons> (sounds about right ;)
03:53:58 <dons> ?uptime
03:53:59 <lambdabot> uptime: 7d 14h 4m 7s, longest uptime: 7d 14h 4m 7s
03:54:06 <dons> go bot-girl!!
03:54:14 <kzm> Well, yes.  I accidentally decoded a large file as a rather big Integer.
03:54:28 <dons> ah right
03:54:30 <kzm> On the plus side: it was pretty fast.  Well, except for the scrolling digits.
03:54:33 <kzm> :-)
03:54:35 <dons> hehe
03:54:51 <dons> oh, right, like:  ghci> decode "foo"
03:54:58 <kzm> Any convenient byte-swap funcitons, btw?
03:54:58 <dons> and it assumes Integer or some such?
03:55:12 <kzm> Seems to, yes.  Not so surprising in retrospect, of course.
03:55:20 <dons> there aren't, but you can snoop in Data.Binary.* for examples
03:55:54 <kzm> Ideally, I'd like to be able to 'switch mode' on the fly, but I'll settle for some manual conversion.
03:56:46 <dons> hey, I updated some of the dna-hacking benchmarks on the shootout. they're tricky beasts, but we're looking a lot better than we used to
03:56:52 <dons> bytestrings, as you can guess , help
03:57:58 <Cheery> Does somebody know anything about implementing logic programming -things like Rete algorithm on haskell?
03:59:02 <hpaste>  xpika pasted "IORef Array." at http://hpaste.org/365
04:00:04 <kzm> > 440477507
04:00:05 <lambdabot>  440477507
04:00:10 <dons> xpika, you can create instance MArray IOUArray (Ptr a) IO where
04:00:19 <kzm> > Text.Printf.printf "%x" 440477507
04:00:20 <lambdabot>  Add a type signature
04:00:20 <dons> rather than refs, if you want to go a bit lower level
04:00:36 <dons> > Text.Printf.printf "%x" (440477507 :: Int) :: String
04:00:37 <lambdabot>  "1a412743"
04:00:57 <kzm> > Text.Printf.printf "%x" (440477507::Integer)
04:00:59 <lambdabot>  Add a type signature
04:01:02 <kzm> > Text.Printf.printf "%x" (440477507::Integer) :: String
04:01:04 <lambdabot>  "1a412743"
04:01:11 <TB> Hi, I'm taking a course on Haskell, and in the book it states I can define a function like "even (2*n) = True" and "even (2*n+1) = False", however both WinHugs and Helium tell me this is impossible, would anyone know what I am doing wrong ?
04:01:23 <kzm> Hmm.. didn't work on my ghci.  Got 'undefined'.  Funny.
04:01:29 <dons> TB, you have to define them in a source file
04:01:40 <TB> dons: I did, but it complains about the * character :/
04:01:53 <dons> TB, oh!
04:01:57 <dons> that's a n*k pattern
04:02:03 <dons> they've not been supported for hmm, 10 years or so!
04:02:21 <dons> only in Gofer, back in the mid 90s was that syntax valid
04:02:29 <kzm> Works when I add :: String.
04:02:32 <TB> ... :/
04:02:36 <dons> TB, this is very strange
04:02:40 <dons> what book are you learning from?
04:02:51 <TB> A dictate written by the professor :/
04:03:13 <dons> maybe you should ask them to try running the code ;) then point out n*k patterns aren't supported in any current haskell system
04:03:25 <dons> they're not valid haskell 98, which was defined 8 years ago now
04:03:44 <Igloo> vincenz: Re Debian packages on ubuntu, I'd have thought so but I don't know
04:03:50 <dons> ?let even n = n `mod` 2 == 0
04:03:52 <lambdabot> Defined.
04:03:54 <dons> > even 8
04:03:55 <lambdabot> Terminated
04:04:00 <dons> ?undefined
04:04:01 <lambdabot> Undefined.
04:04:18 <dons> ?let even n = n `mod` 2 == 0
04:04:20 <lambdabot> Defined.
04:04:23 <TB> oh...
04:04:25 <dons> > even 8
04:04:26 <lambdabot> Terminated
04:04:28 <TB> First print is from september 1992 :/
04:04:33 <dons> ?let myeven n = n `mod` 2 == 0
04:04:34 <lambdabot> Defined.
04:04:43 <dons> > myeven 8
04:04:44 <lambdabot>  True
04:04:46 <TB> Would've expected something stupid like that to be fixed in the 2007 print :/
04:04:50 <dons> TB, ah that explains it!
04:05:01 <dons> yeah, Haskell is a very very very different language to the Haskell of 1992
04:05:22 <dons> head on over to http://haskell.org for a more updated view of where things are
04:05:23 <lambdabot> Title: Haskell - HaskellWiki
04:05:39 <TB> Pfff, I've spent hours trying to figure out why that didn't work :P
04:05:43 <dons> the (n*k) pattern extension was used in Gofer, and was not adopted into any haskell standard, that i'm aware of
04:05:50 * TB is off to write a letter to the prof
04:06:01 <dons> n+k patterns are valid, though
04:06:05 <dons> though rarely used
04:06:31 <Cale> TB: yeah, hang around here :)
04:06:43 <dons> TB, you can be proud that in 6 years of this channel, you're the first to ever ask about n*k patterns :)
04:06:46 <Cale> asking questions here is a good way to get problems fixed quickly :)
04:07:35 <dons> TB, who's the professor?
04:08:03 <TB> D. Swierstra from Utrecht
04:08:10 <nmessenger> dons: why @let even?  Why not the even in Prelude?
04:08:14 <dons> oh, I think he probably knows this then :)
04:08:26 <dons> he'll probably be quite impressed you spotted it
04:08:36 <TB> Yeah, still gonna write him an email about it :P
04:08:39 <dons> nmessenger: i just wanted to show how to define it without n*k patterns
04:09:00 <TB> If he knew about it, he'd probably have fixed it by now... there's been a reprint of it almost every year :/
04:09:13 <dons> ah right. so is this a .nl haskell textbook?
04:09:16 <nmessenger> dons: @src'd do that :P
04:09:23 <dons> @src even
04:09:24 <lambdabot> even n = n `rem` 2 == 0
04:09:26 <dons> good idea nmessenger :)
04:09:45 <Cale> Well, he knows that n*k patterns aren't supported, he just wouldn't know that his notes are still using them.
04:09:49 <nmessenger> @botsnack
04:09:50 <dons> yeah
04:09:50 <lambdabot> :)
04:10:02 * dcoutts_ just suffered through an OO design patterns lecture on the visitor pattern aka the 'fold'
04:10:04 <TB> dons: Yes, it's a dutch one :P
04:10:07 <dcoutts_> soo much code :-(
04:10:21 <dcoutts_> and yet not generic and reusable :-(
04:10:21 <dons> TB, is it available online? we've got a list of haskell textbooks on haskell.org
04:10:28 <dons> I didn't know there was a dutch one in print
04:10:32 <dons> dcoutts_: hehe
04:10:41 <pjd_> dcoutts: s/yet/hence/, surely
04:10:44 <TB> http://abaris.zoo.cs.uu.nl:8080/wiki/pub/FP/CourseLiterature/fp.pdf
04:10:46 <TB> That's the one
04:10:47 <lambdabot> http://tinyurl.com/y7sejf
04:10:50 <TB> http://www.cs.uu.nl/wiki/FP/CourseLiterature
04:10:51 <dcoutts_> pjd_, heh, yeah.
04:10:53 <lambdabot> Title: FP / Course Literature
04:10:55 <nmessenger> dcoutts_:  :O...  :(
04:11:15 <dons> TB, feel free to hang out here, we have a few .uu.nl guys
04:11:18 <Cale> OO Design patterns are tedious examples of ways that most OO languages are flawed, by not allowing those things to be abstracted away into functions or similar.
04:11:18 <dcoutts_> dons, when it comes to the practical I'm going to sneak in early and write out the 10 line functional version on the board :-)
04:11:26 <TB> dons: I will ;)
04:11:27 <dons> dcoutts_: heh. yay!
04:12:20 <dcoutts_> I might label it the "fold pattern"
04:12:22 <dons> TB, if you're looking for a more up to date textbook,
04:12:24 <dons> ?where yaht
04:12:24 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
04:12:25 <dons> is a good one
04:12:32 <dons> dcoutts_: subversive!
04:12:38 <dcoutts_> ;-)
04:12:52 <dons> but you know, if you can do it in 10 line, it must be a toy
04:13:19 <TB> dons: Thanks, I'll try to read it on my own, but I'm afraid I'll have to stick to the textbook from the prof for the classes :P
04:13:27 <Cale> YAHT isn't perfect, but it's quite good for the initial chapters. The wikibook is also worth looking at.
04:13:28 <dons> yep. good idea
04:13:40 <Cale> @where wikibook
04:13:40 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:13:51 <dons> TB, and try to install ghc. its really a lot more useful than hugs, I find.
04:13:53 <hpaste>  (anonymous) pasted "byte swapping" at http://hpaste.org/366
04:13:56 <dons> since you can actually compile to very fast code
04:14:02 <dons> and you get a lot more libraries to play with
04:14:23 <kzm> Could probably be more elegant, but seems to work (byte swapping, that is)
04:14:26 <Cale> and the error messages are often better (but occasionally involve more terminology)
04:14:42 <TB> k :)
04:14:58 <nmessenger> whomever (anonymous) is: wouldn't shifting be faster than multiplying and dividing?
04:15:12 <dons> kzm, oh, .. that looks like the Binary instance in Data.Binary.hs
04:15:13 <TB> Btw, does anyone know of a nice haskell interpreter with source-code for windows, so I can port to windows mobile? (to test stuff in class) ?
04:15:16 <kzm> nmessenger, I am anonymous.  Or was, at any rate.
04:15:43 <kzm> Well - or you could just multiply with 256^n in the reverse direction...
04:16:26 <dons> TB, hugs would be the best bet.
04:16:27 <hpaste>  (anonymous) annotated "byte swapping" with "shifts" at http://hpaste.org/366#a1
04:16:36 <dons> sorry, that was me
04:17:33 <pjd_> mauke: thanks, those resign patterns made my day
04:17:37 <dons> kzm, so you just stick a reverse in there, or use the example code in Data.Binary.Get/Builder for how to shift from big to little endian, and so on
04:18:34 <kzm> Yep.
04:20:27 <kzm> You're using fromIntegral to truncate to bytes, right?
04:20:39 <dons> yeah
04:20:55 <dons> it turns into a narrowWord8# primop
04:21:00 <dons> (and thus a cast in the C backend)
04:22:58 <nmessenger> I like the symmetry between 'unfoldr step' and 'foldr unstep'
04:24:04 <dons> its a beautiful language. that's low level library code remember!
04:24:30 <kzm> (sigh)  I'm afraid I have an existential problem... my function is Integral a => a -> a, how do I stick that as a member of a data type?
04:24:31 <dcoutts_> @pl (\e1 e2 -> e1 . showString " + " . e2)
04:24:32 <lambdabot> (. (showString " + " .)) . (.)
04:25:29 <dcoutts_> @pl (\e1 e2 -> e1 <+> ch '+' <+> e2)
04:25:30 <lambdabot> (<+>) . (<+> ch '+')
04:25:38 <kzm> I.e. I don't want the data type parametric.
04:26:19 <dons> either make it parametric, or use an existential to hide the concrete type in each object
04:26:48 <kzm> Hmm.. I'll try with -fglasgow-exts, and see if that helps a bit :-)
04:26:56 <dons> heh
04:27:44 <kzm> The universal solution.
04:28:37 <Cale> You'll still need a forall, or GADT syntax, if you want an existential.
04:34:30 <ookk> audreyt, i also noticed that the ghc-6.6 tarball is missing: HsOpenGL.h       HsOpenGLExt.h    HsOpenGLTypes.h
04:34:38 <fasta> What extension can I use to get
04:34:38 <fasta> class Foo a where
04:34:38 <fasta>  foo::a
04:34:38 <fasta>  
04:34:38 <fasta> working? (I am aware of the dummy argument approach)
04:35:24 <Cale> kzm: er, or more likely what you want is for the constructor to have a rank-2 type...
04:35:43 <hpaste>  dcoutts pasted "The visitor pattern: die OOD die!" at http://hpaste.org/367
04:36:14 <nmessenger> fasta: that doesn't work for you?
04:36:14 <dcoutts_> eval = visit id (+) negate
04:36:18 <dcoutts_> muaha hah ha
04:36:28 <nmessenger> @src Bounded
04:36:28 <lambdabot> class  Bounded a  where
04:36:29 <lambdabot>     minBound, maxBound :: a
04:36:33 <Cale> which means that the forall is in the type of the component
04:36:44 <kzm> Cale - I'm possibly abusing the word 'existential'.
04:37:12 <Cale> data IntegralFunction = IF { apply :: forall a. (Integral a) => a -> a }
04:37:35 <kzm> That's how it looks, yes.
04:37:40 <dons> dcoutts_: and that's not even SYB :)
04:37:43 <Cale> that would mean the function passed to IF *must* be polymorphic
04:37:52 <dcoutts_> dons, I wanted as simple as possible
04:37:56 <kzm> apply must now work for any integral type. Yes, that was what I wanted.
04:38:02 <fasta> nmessenger: ok, I assume you mean that I define another function besides the one in the class and let users use that. That way the users don't need the dummy argument.
04:38:04 <dons> yeah. look good
04:38:34 <dons> in syb i guess it would be some of gmap
04:41:26 <nmessenger> fasta: I guess a don't understand what you mean.  'class Foo a where foo :: a' is perfectly legal.  You could then 'instance Foo Char where foo = '\0''.
04:41:40 <dcoutts_> our Haskell IDE should generate folds for us
04:41:48 <dcoutts_> and unfolds
04:43:41 <fasta> nmessenger: no it's illegal.
04:43:47 <fasta> nmessenger: try it
04:43:50 <pejo> dcoutts, what's the "D" for?
04:44:00 <dcoutts_> pejo, Design
04:44:07 <fasta> nmessenger: Wait
04:44:20 <fasta> nmessenger: When you take a::Int, it fails.
04:44:36 <nornagon> pejo: Dragon; could be white, blue, red, black, grey or silver.
04:45:14 <pejo> Heh. I seem to be the only one not violently opposed to subtyping in here.
04:45:24 <fasta> nmessenger: right, you can't have a method that doesn't mention none of the type variables of the class.
04:45:34 <dcoutts_> pejo, I like subtyping for some things
04:45:41 <hpaste>  nmessenger pasted "Foo class" at http://hpaste.org/368
04:45:58 <fasta> nmessenger: so, I was asking if there was a way around it (other than the method I already said)
04:46:16 <dcoutts_> pejo, I think it's partly a reaction against OOP which over uses subtyping
04:46:28 <fasta> nmessenger: right, but if you add bar::Int now, doesn't work anymore.
04:46:46 <pejo> dcoutts, that's mainly because most languages with subtyping have a type system that is crap though.
04:46:54 <nmessenger> fasta: right, because Int isn't a Foo. :P  You'd have to declare an instance
04:47:12 <fasta> nmessenger: no
04:47:29 <dcoutts_> pejo, aye
04:47:48 <fasta> class Foo a where
04:47:48 <fasta>  foo::a
04:47:48 <fasta>  bar::Int
04:48:06 <fasta> bar is illegal.
04:48:23 <quicksil1er> fasta: all class functions have to 'depend' on the class parameter somehow
04:48:35 <fasta> quicksil1er: yes, I know that.
04:48:43 <quicksil1er> well your "bar" doesn't
04:48:47 <quicksil1er> it doesn't 'depend' on a
04:48:51 <fasta> quicksil1er: but I was asking for an extension that lifts this.
04:48:57 <fasta> quicksil1er: you are stating the obvious.
04:48:57 <pejo> dcoutts, (just for the record - I'm all for HM with rank-n polymorphism, type classes and subtyping - which would let the user choose mechanism for the design).
04:49:05 <quicksil1er> therefore the type inference algorithm can't work out which 'a' to use, I believe
04:49:13 <nmessenger> if it doesn't depend on 'a', you should probably just write it outside the class.
04:49:36 <dcoutts_> pejo, aye I looked at an HM(<) system for something once, it's not too bad.
04:49:46 <dcoutts_> erm HM(<=)
04:50:43 <pejo> dcoutts, hm, yeah. Weren't you trying to design a sound and complete type inference for HM(<=)?
04:51:14 <SamB> alternatively, add a bogus parameter
04:51:25 <quicksil1er> fasta: I apologies for stating the obvious, I was attempting to understand your problem
04:51:47 <nmessenger> i.e. the dummy arg approach fasta mentioned
04:53:07 <SamB> it does not make sense to me to have an overloaded function that isn't overloaded on anything in particular
04:53:32 <quicksil1er> I presume it uses the type in some subtle internal way
04:53:46 <quicksil1er> like asTypeOf or a Data.Dynamic cast or something
04:53:53 <nmessenger> yeah.  'bar :: a -> Int' can *choose* not to depend on 'a', but it leaves the option open.
04:53:56 <quicksil1er> I'd be interested to see what fasta is trying to do
04:54:47 <quicksil1er> I'd also be interested to know how he expects the compiler to know which 'a' to choose
04:54:49 <nmessenger> +any particular instance of Foo can *choose*...
04:55:22 <nmessenger> quicksil1er: I don't see any way around explicit type annotation.
04:55:40 <Saizan> well, in its class each class has some particular constant value, it's not that strange
04:55:51 <Saizan> s/its/his/
04:56:01 <Saizan> s/each class/each type/
04:56:19 <quicksil1er> nmessenger: but if it doesn't mention 'a' in its type then you can't give a type annotation which disambiguates it :)
04:56:20 <nmessenger> Saizan: yeah, but does each type have a constant 'Int'?
04:56:27 <SamB> but... how does it know which type you are dealing with?
04:56:47 <fasta> The reason for putting it in the class is that it defines an obligation for the person writing a possible subclass.
04:56:48 <nmessenger> quicksil1er: oh yeah I guess you're right :o)
04:56:57 <fasta> Otherwise this person could forget it.
04:57:21 <SamB> subclass????
04:57:38 <nmessenger> slip of the tongue I'd wager
04:58:02 <nmessenger> s/subclass/instance/
04:58:58 <fasta> Ultimately, the problem comes in the instances, yes.
04:59:14 <bryanl> haskell is giving me an inferiorty complex :)
04:59:50 <nmessenger> fasta: if you want, for instance the type Char to have a bar = 1, String to have a bar = 2, Double to have a bar = 3, you'd pretty much have to change to 'bar :: a -> Int' and use a dummy
04:59:58 <bakert> bryanl, me too.
05:00:20 <fasta> Anyway, people have written research papers about lifting this restriction in general by adding type level functions, IIRC.
05:00:29 <fasta> So, apparantly someone cares about it.
05:00:40 <quicksil1er> I wasn't trying to suggest no one cared about it :)
05:00:56 <quicksil1er> I was (a) interested in use cases and (b) pointing out the syntactic problem
05:01:02 <quicksil1er> that the compiler can't know which 'bar' you mean
05:01:07 <nmessenger> quicksil1er probably, just as I, didn't understand what you were looking for.
05:01:13 <quicksil1er> because it chooses instance by type inference
05:01:19 <quicksil1er> and if the type it infers doesn't help then...
05:02:10 <nmessenger> fasta: does what I said above sound like what you want?
05:02:32 <fasta> nmessenger: it's equivalent to what I said at the start of the conversation.
05:02:41 <nmessenger> yea
05:02:49 <fasta> nmessenger: I was asking for a different approach.
05:02:54 <fasta> nmessenger: never mind it
05:04:25 <nmessenger> this sounds exactly like what Oleg did in the implicit configurations paper for reifying types.
05:04:45 <nmessenger> have you read it?
05:05:23 <nmessenger> s/reifying/reflecting/ maybe?  I'm not terribly familiar with the terminology.
05:07:42 <ejt> hi, how would you write the following in point-free style ?
05:07:45 <ejt> step m = (getMicrocode . nextInstruction $ m) m
05:08:01 <ejt> it seems ugly with 'm' referenced twice
05:08:07 <nmessenger> @pl \m -> (f . g $ m) m
05:08:08 <lambdabot> f =<< g
05:08:38 <nmessenger> a little crazy-looking.  I'd prefer the pointy version.
05:08:40 <ejt> that's a neat trick, thx
05:09:11 <dons> ?pl step m = (getMicrocode . nextInstruction $ m) m
05:09:12 <lambdabot> step = getMicrocode =<< nextInstruction
05:09:37 <matthew_-> can you make infix data constructors?
05:09:39 <dons> you'd need the -> a Monad instance there, available from Control.Monad.Instances
05:09:41 <matthew_-> s/data/type/
05:09:42 <dons> matthew_-: yep
05:09:45 <dons> and type constructors too :)
05:09:52 <matthew_-> just normal backticks?
05:10:00 <dons> data a :*: b = a :*: b
05:10:10 <dons> (1 :*: 2) :: (Int :*: Integer)
05:10:11 <ejt> dons: thx
05:10:16 <matthew_-> wow. cool
05:10:16 <nmessenger> hmm, never tried Int `Either` Char.
05:10:23 <dons> that works
05:10:27 <dons> :k Int `Either` Char
05:10:29 <lambdabot> *
05:10:52 <nmessenger> too bad no type-level sections :)
05:10:55 <dons> pretty rare. once people go infix they tend to define a type sym for that
05:11:02 <dons> heh 
05:11:18 <dons> Int :|: Char
05:11:42 <dons> type (:|:) = Either -- wonder if that works
05:11:49 <dons> then Int :|: Char is a cute type
05:11:52 <nmessenger> I tried something like that, it seemed to
05:12:07 <quicksil1er> for type-level sections you essentially need type-level lambdas
05:12:13 <matthew_-> mmm. I want data Foo = Int Foo Blah
05:12:18 <quicksil1er> type-level lambdas would solve other problems too
05:12:23 <quicksil1er> but they open a can of works
05:12:24 <dons> Int `Foo` Blah
05:12:24 <quicksil1er> worms
05:12:31 <matthew_-> gah. thanks.
05:12:46 <dons> quicksil1er: you get proper type level functions ith the new index type families
05:12:51 <dons> but no sections ;)
05:13:12 <quicksil1er> dons: I'm out of touch, got a reference for that?
05:13:37 <dons> ?where ATs
05:13:37 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/AssociatedTypes
05:13:58 <dons> not that page, I think. but close
05:14:26 <dons> http://haskell.org/haskellwiki/GHC/Indexed_types
05:14:28 <lambdabot> Title: GHC/Indexed types - HaskellWiki
05:14:37 <dons> ?where+ indexed-types http://haskell.org/haskellwiki/GHC/Indexed_types
05:14:37 <lambdabot> Done.
05:14:39 <nmessenger> type Flip a b c = a c b; -- thus (-> r) = Flip (->) r
05:14:58 <dons> note you can also define infix class names
05:15:06 <quicksil1er> dons: thanks
05:16:01 <nmessenger> quicksil1er: wouldn't that work?
05:16:04 <dons> so you can have a family of type functions associated with each class
05:18:30 <nmessenger> *Main> :k Flip (->) Int
05:18:31 <nmessenger> Flip (->) Int :: * -> *
05:18:54 <quicksil1er> fun
05:19:23 <nmessenger> type aliases are like very limited lambdas
05:20:09 <nmessenger> type Flip should be in Prelude!
05:20:27 <nmessenger> I demand type-level sections!
05:20:46 <xerox> (OT: App for reading PostScript files?)
05:22:18 * nmessenger knows of GhostScript.  Never tried it though.  Consult google?
05:22:51 <Syzygy-> gsview is decent.
05:23:01 <Syzygy-> Ghostscript raw works, but is slightly annoying.
05:23:11 <Syzygy-> And there are various frontends to Ghostscript, depending on where you are.
05:23:20 <nmessenger> (of various flavors) was implied :P
05:24:07 <qwr> or kghostscript, when you have kde
05:24:32 <qwr> err kghostview
05:25:31 <xerox> Thank you.
05:26:14 * nmessenger mumbles something about kind-level sections, then metakinds...
05:26:30 * quicksil1er takes a metanmessenger section
05:28:24 <nmessenger> since metatypes have the name "kinds", should there be a name for metakinds?  varieties?
05:28:26 <ejt> ok, follow up question; is there a good explanation of the (->) r monad anywhere ?
05:29:16 <xerox> ejt: it is actually the Reader Monad.
05:29:19 <Syzygy-> > ((+2) >>= (+3::Int) >>= return) 5
05:29:19 <lambdabot>  Parse error
05:29:39 <nmessenger> parens around 3::Int
05:29:49 <ejt> xerox: k, I'll go and re-read a text book, thx
05:29:50 <Syzygy-> > ((+2) >>= (+(3::Int)) >>= return) 5
05:29:51 <lambdabot>  Couldn't match `Int -> b' against `Int'
05:30:00 <Syzygy-> > ((+2) >>= (+(3::Int)) >>= return)
05:30:01 <lambdabot>  Couldn't match `Int -> b' against `Int'
05:30:22 <xerox> > ((+2) >>= (+)) 3
05:30:24 <lambdabot>  8
05:30:43 <nmessenger> wow.
05:30:59 <Syzygy-> @type ((+2) >>= (+))
05:31:01 <lambdabot> forall a. (Num a) => a -> a
05:31:09 <Syzygy-> @type ((+2) >>= )
05:31:11 <lambdabot> forall a b. (Num a) => (a -> a -> b) -> a -> b
05:31:12 <pjd_> ejt: intuitively, (->) r is a function without an input
05:31:23 <pjd_> and in monad form, it's a monadic computation without a shared input
05:31:29 <xerox> pjd_: /with/.
05:31:34 <pjd_> hence the reader monad, more or less
05:32:14 <pjd_> xerox: no, it's with after you apply an environment to it :)
05:33:02 <robreim> excuse my ignorance: what's the difference between floor and truncate?
05:33:14 <quicksil1er> how they behave on negative numbers
05:33:23 <robreim> aha! Thank you :)
05:33:48 <nmessenger> @redo ((+2) >>= (+))
05:33:49 <lambdabot> (do { a <- (+ 2); (+) a})
05:33:51 <ejt> pjd_: ah, I think I'm beginning to understand, will experiment a bit ...
05:35:01 <nmessenger> how could I put asks in there?
05:37:43 <nmessenger> > do { x <- asks (+ 2); y <- asks (+ x); return y} $ 3
05:37:44 <lambdabot>  8
05:44:00 <matthew_-> can you alter the binding precedence of type constructors?
05:45:10 <matthew_-> eg. data Foo = A Foo Int | B String -- I'd like to write (A B "boo" 5) without using parenthesis
05:45:26 <nmessenger> see if the various infix decls work
05:45:55 <matthew_-> currently I'd have to write (A (B "boo") 5). So I want to give the B constructor a higher precedence.
05:46:04 <matthew_-> ok. I'll look at those
05:46:14 <nmessenger> my ghci compiled 'type (:*:) = (,); infixl 1 :*:'
05:47:41 <matthew_-> mmm. the docs suggest it'll work too. http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#infix-tycons
05:47:44 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
05:47:49 <nmessenger> that'd require infix type constructors, though. :)
05:48:12 <matthew_-> yep. I have that too!
05:48:17 <nmessenger> you might do infixl 1 `A`
05:48:57 <matthew_-> ahh. I see your point.
05:49:03 <nmessenger> oh, data constrs, I misread your first question
05:50:00 <nmessenger> Maybe is a type constr, Just is a data constr.  In your example you mentioned type constrs but A and B are data constrs.  I got confused.
05:50:42 <matthew_-> ok. I have infix data constr and would like to also set a precedence on a data constr
05:51:06 <nmessenger> should work fine, (:) is a data constr and it has a precedence :)
05:51:21 <matthew_-> yeah, ghci seems to compile it. is 1 high or low?
05:51:26 <nmessenger> low
05:52:15 <beelsebob> Igloo: how does ghc test the version of readline then?
05:52:56 <Igloo> beelsebob: Hmm? Why do you ask?
05:53:08 * nmessenger searches the report for operator precedences
05:53:18 <beelsebob> because my intel box failed with an unparseable version for readline
05:53:21 <quicksil1er> matthew_-: you can't change the 'precedence' of prefix though
05:53:23 <beelsebob> wanted to prod you with what it got back
05:53:28 <quicksil1er> matthew_-: cos that's not how prefix works :)
05:54:40 <matthew_-> ok, I think I meant fixity
05:54:53 <Igloo> beelsebob: Hmm, are you sure it's the readline version causing the problem?
05:55:18 <nmessenger> fixity relates to left/right binding, precedence to binding order, they just happen to use the same decl
05:55:31 <beelsebob> uhh.. .good point - I had that in my head for some reason
05:55:33 <matthew_-> right. I'm confused then
05:55:49 <beelsebob> I think I read the first word on that line as readline not reading
05:55:53 * Igloo is just trying to work out which package.conf.inplace it is that it's complaining about
05:56:00 <Igloo> Ah, heh
05:56:16 <matthew_-> basically, is it possible, given data Foo = A Foo Int | B String -- to adjust $feature so that I can write (A B "boo" 5) without ghc complaining?
05:56:38 <nmessenger> basically, no :)
05:57:08 <nmessenger> the closest is (B "boo" `A` 5)
05:57:08 <quicksil1er> matthew_-: no
05:57:18 <Vq^> matthew_-: maybe if it's inside a comment...
05:57:22 <matthew_-> lol
05:57:33 <matthew_-> Vq^ thinks outside the box!
05:57:42 <quicksil1er> matthew_-: the invisible 'juxtaposition' operator has highest precendence and is left-associative
05:57:53 <quicksil1er> a b c d e f g is ((((((a b)c)d)e)f)g)
05:57:58 <Igloo> beelsebob: Can you mail me /Users/tatd2/buildbot/ghc/tatd2-head/build/compiler/package.conf.inplace please?
05:58:06 <Vq^> matthew_-: thank you :)
05:58:08 <quicksil1er> irrespective if a..g are constants, or functions, or constructors
05:58:24 <nmessenger> quicksil1er: but what operator connects the juxtaposition operator to its arguments? :)
05:58:32 <matthew_-> So I can't adjust the way it tries to add parenthesis?
05:58:35 <quicksil1er> matthew_-: no
05:58:43 <matthew_-> ok. thanks for your help.
05:58:47 <quicksil1er> nmessenger: the part after the word 'is' was meta syntax
05:58:48 * matthew_- sulks
05:58:57 <quicksil1er> matthew_-: most people use $ or . to acheive that kind of thing
05:59:02 <matthew_-> yeah
05:59:33 <nmessenger> ooh, /me didn't think about metasyntax.  What's its metametasyntax?
05:59:35 <quicksil1er> matthew_-: it woudl be powerful but potentially *really* confusing to allow to alter the parser in that way
06:00:02 <quicksil1er> matthew_-: currently I don't have to look at the types of a..g to parse that example I gave
06:00:07 <quicksil1er> (or any other information about them)
06:00:17 <nmessenger> i.e. try all possible parses until one typechecks.  That'd lead to some (extremely!) subtle bugs.
06:00:50 <Syzygy-> nmessenger: Then you'd have code dependent on what order the parser tries possibilities.
06:00:54 <quicksil1er> perl has a parser with subtleties like this and anyone who has been bitten by them probably wouldn't recommend the experience :)
06:01:04 <nmessenger> hence subtle bugs :P
06:02:02 <nmessenger> with the (extremely!)
06:03:55 <bakert> ?hoogle Maybe a -> Bool
06:03:56 <lambdabot> Maybe.isJust :: Maybe a -> Bool
06:03:56 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
06:04:14 <bakert> > isJust $ Just 6
06:04:15 <lambdabot>  True
06:04:19 <bakert> cool.
06:04:56 <nmessenger> you're not just isJust'ing to justify fromJust'ing, are you?
06:05:09 <nmessenger> just
06:05:11 <matthew_-> > liftM (const True) $ Just 6
06:05:12 <lambdabot>  Just True
06:05:18 <matthew_-> oh blast!
06:05:39 * matthew_- remembers to try to think next time
06:05:41 <nmessenger> > maybe True (const False) $ Just ()
06:05:43 <lambdabot>  False
06:05:51 <nmessenger> > maybe True (const False) $ Nothing
06:05:53 <lambdabot>  True
06:06:57 <Syzygy-> > let foo x | isJust x = Just (fromJust x); | otherwise = Nothing; in foo $ Just 3
06:06:57 <lambdabot>  Parse error
06:07:12 <nmessenger> gah!
06:07:24 <Syzygy-> nmessenger: What?
06:07:32 <nmessenger> foo = id, you ninny!
06:07:38 <Syzygy-> nmessenger: I know!
06:07:43 <nmessenger> :P!
06:07:59 <Syzygy-> Why would I write it otherwise? If it weren't silly?
06:08:16 <nmessenger> > maybe Nothing Just $ Just 3
06:08:17 <lambdabot>  Just 3
06:08:21 <nmessenger> heh
06:08:27 <Syzygy-> ?type Nothing
06:08:29 <lambdabot> forall a. Maybe a
06:08:43 <Syzygy-> (gods I love the autocompletion hack I did for lambdabot....)
06:09:03 <Syzygy-> ?ty<tab> <<= <3
06:09:03 <lambdabot> Unknown command, try @list
06:09:08 <Syzygy-> :P
06:09:19 <nmessenger> ?ty Nothing -- :P
06:09:21 <lambdabot> forall a. Maybe a
06:09:31 <Syzygy-> nmessenger: Well, yeah, you can do that.
06:09:44 <Syzygy-> But you won't learn hacking irssi-scripts in perl that way around.
06:10:01 <Syzygy-> ?ty maybe
06:10:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:10:06 <Syzygy-> was what I wanted to figure out.
06:10:26 <Syzygy-> > maybe (Just ()) Nothing $ Just 3
06:10:26 <lambdabot>      Expecting a function type, but found `Maybe a'
06:10:27 <lambdabot>       Expected type: a ->...
06:10:34 <Syzygy-> > maybe (Just 0) Nothing $ Just 3
06:10:34 <lambdabot>      Expecting a function type, but found `Maybe a'
06:10:35 <lambdabot>       Expected type: a ->...
06:10:39 <nmessenger> the 'b' basically replaces your Nothing, the (a -> b) replaces Just
06:10:48 <quicksil1er> maybe has it's arguments the wrong way around though
06:10:50 <quicksil1er> silly maybe :)
06:10:52 <Syzygy-> Oh. And Nothing 3 is bad.
06:11:01 <Syzygy-> > maybe (Just 0) (const Nothing) $ Just 3
06:11:02 <quicksil1er> it should be 'maybe do this, otherwise that'
06:11:02 <lambdabot>  Nothing
06:11:04 <nmessenger> > maybe 0 (+1) $ Just 3
06:11:06 <lambdabot>  4
06:11:14 <nmessenger> @src Maybe
06:11:15 <lambdabot> data Maybe a = Nothing | Just a
06:11:17 <Syzygy-> > maybe (Just 0) (const Nothing) $ Nothing
06:11:18 <lambdabot>  Just 0
06:11:21 <Syzygy-> ?src maybe
06:11:21 <lambdabot> maybe n _ Nothing  = n
06:11:21 <lambdabot> maybe _ f (Just x) = f x
06:11:22 <nmessenger> quicksil1er: nuh-uh :P
06:11:36 <quicksil1er> nmessenger: well it's always seemed backwards to me
06:11:39 <quicksil1er> ?type (flip maybe)
06:11:41 <lambdabot> forall a a1. (a1 -> a) -> a -> Maybe a1 -> a
06:11:48 <quicksil1er> much better
06:12:00 <Syzygy-> quicksil1er: This way around you can build sections neater...
06:12:11 <Syzygy-> quicksil1er: Under the assumption that the function will vary more than the default value.
06:12:20 <quicksil1er> yes, that's a good point
06:37:26 <kzm> > let n = fromIntegral {- $ comment -} 42 in n
06:37:31 <lambdabot>  42
06:37:34 <kzm> sigh.
06:37:59 <Syzygy-> Hmmmm?
06:46:18 <nmessenger> kzm: sigh what?
06:46:41 <kzm> I got an error with ghci when I inserted a comment like that.
06:46:54 <kzm> It was in a do block, though.
06:47:16 <nmessenger> no 'in's in do blocks
06:48:10 <quicksil1er> I think you can put an in in a do block if it's in a parenthesised expression :)
06:48:11 <hpaste>  kzm pasted "ghci error?" at http://hpaste.org/369
06:48:44 * nmessenger tries
06:49:14 <qwr> @hoogle bswap
06:49:15 <lambdabot> No matches found
06:49:57 <kzm> it's my own byteswap thingy.
06:50:26 <kzm> and, yes, no 'in', I know :-)
06:50:29 <nmessenger> both give me errors, but I don't have Binary installed
06:50:43 <nmessenger> "The last statement in a 'do' construct must be an expression"
06:51:10 <kzm> Well, I thought it was strange.  Commenting it out like that ought to work, AFAICT.
06:51:28 <kzm> Oh, and it's not the complete do-block, btw
06:52:32 <nmessenger> it *ought* to.  I'm not sure what'd cause it to error.
06:52:51 <nmessenger> type error?
06:53:39 <nmessenger> > reverse "yaRcimsoC"
06:53:41 <lambdabot>  "CosmicRay"
06:54:08 <nmessenger> @yaR!
06:54:09 <lambdabot> I'd like to drop me anchor in her lagoon
06:54:50 <yaRcimsoC> hello again :-)
06:55:04 <yaRcimsoC> I'm wanting my name back, but I think it's unlikely :-)(
06:55:14 <yaRcimsoC> hehe, that's a new smiley
06:55:49 <nmessenger> "slobbery retainer"  :-)(,
06:56:04 <yaRcimsoC> lol
06:58:27 <hpaste>  nominolo pasted "ST weirdness" at http://hpaste.org/370
06:58:44 <joakim> hi folks
06:58:48 <nominolo> can someone help resolving this compiler error?
06:58:59 <joakim> just started to learn haskell
06:59:31 <nominolo> ?stats
06:59:32 <lambdabot> Unknown command, try @list
06:59:38 <nominolo> @stats
06:59:39 <lambdabot> Unknown command, try @list
06:59:46 <nmessenger> nominolo: @users?
06:59:47 <joakim> have programmed in several imperative languages before, so haskell is a little weird at the moment
06:59:59 <nominolo> d'oh
07:00:00 <nominolo> yes
07:00:02 <nominolo> @user
07:00:02 <lambdabot> Maximum users seen in #haskell: 322, currently: 298 (92.5%), active: 38 (12.8%)
07:00:07 <nmessenger> joakim: how much Haskell have you read about/written?
07:00:23 <joakim> reading yaht now
07:00:31 <joakim> chapter 3
07:00:45 <joakim> i'm on the exercises
07:01:02 <dcoutts_> nominolo, take off the :: ST s ([b], LogMsg) type annotation
07:01:17 <dcoutts_> I don't think it means what you think it means.
07:01:21 <nominolo> dcoutts_: that doesn't help
07:01:28 <joakim> trying to map low characters as True into a list
07:01:29 <nominolo> (tried it)
07:01:37 <joakim> and the oposite as False
07:01:53 <nmessenger> map isLower?
07:02:00 <joakim> yep
07:02:26 <joakim> but i don't know how i can map booleans into a new list
07:02:57 <quicksil1er> > map isLower "aAbBccDD"
07:02:58 <lambdabot>  [True,False,True,False,True,True,False,False]
07:03:13 <quicksil1er> joakim: that's what 'map' does :)
07:03:18 <joakim> Oh
07:03:20 <hpaste>  (anonymous) annotated "ST weirdness" with "(no title)" at http://hpaste.org/370#a1
07:03:23 <nmessenger> > map fromEnum $ map isLower "aAbBccDD"
07:03:25 <lambdabot>  [1,0,1,0,1,1,0,0]
07:03:40 <mux> joakim: map takes a function of the form (a -> b), and from a list [a], returns a list [b], so the type can change
07:03:40 <nominolo> dcoutts_: that's the message without the annotation
07:03:45 <mux> @type map
07:03:46 <joakim> lol, I thought i had to do something else
07:03:46 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
07:03:50 <quicksil1er> > map (fromEnum.isLower) "aAbBccDD"
07:03:52 <lambdabot>  [1,0,1,0,1,1,0,0]
07:03:56 <joakim> it do it automatically :)
07:03:58 <quicksil1er> nmessenger: I win, I saved characers!
07:04:07 <nmessenger> :P
07:04:44 <joakim> haskell is fun
07:04:54 <nmessenger> joakim: Aye!  Do you have a question?
07:05:07 <joakim> not now
07:05:20 <nmessenger> @src map
07:05:20 <lambdabot> map _ []     = []
07:05:21 <lambdabot> map f (x:xs) = f x : map f xs
07:06:11 <nmessenger> mapping a function over the empty list is the empty list, mapping over a list starting with 'x' followed by 'xs' is 'f x' followed by 'f' mapped over 'xs'
07:06:59 <dcoutts_> nominolo, look at the type of runST
07:07:09 <dcoutts_> @type Control.Monad.ST.runST
07:07:10 <nominolo> ?type runST
07:07:11 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
07:07:12 <lambdabot> Not in scope: `runST'
07:07:30 <dcoutts_> note that the forall a scopes only over the arg?
07:08:38 <joakim> bah, need to do homeworks :/
07:08:47 <nominolo> hm
07:08:56 <hpaste>  dcoutts annotated "ST weirdness" with "runUnit has rank-2 type" at http://hpaste.org/370#a2
07:09:53 <dcoutts_> nominolo, look at it this way, with the type you had originally, I as the caller of that function get to pick the type of 's'.
07:10:02 <dcoutts_> nominolo, however that's not right
07:10:16 <dcoutts_> we do not get to pick the 's' type parameter in runST
07:10:18 <nominolo> ah, ok
07:10:20 <nominolo> i get it
07:10:22 <dcoutts_> that's the whole point of ST
07:10:38 <dcoutts_> it's universally quantified over the s type parameter
07:10:41 <quicksil1er> it's s3kr3t
07:10:49 <quicksil1er> only SPJ gets to know the type of 's'
07:10:51 <quicksil1er> and he's not telling
07:10:52 <quicksil1er> :P
07:10:55 <dcoutts_> right :-)
07:11:20 <dcoutts_> you have to make it work for any 's' and runST get's to pick.
07:11:34 <nominolo> i know the basic idea.  but i didn't know what the pitfalls were and how to handle them ;)
07:11:43 <joakim> is it possible to see the c code that ghc produces?
07:11:50 <dcoutts_> nominolo, aye, it's tricky.
07:12:02 <dcoutts_> joakim, yep but you probably do not want to see it :-)
07:12:15 <joakim> hehe
07:12:41 <dcoutts_> joakim, ghc uses gcc as if it were an assembler and the C code looks like assembly.
07:12:59 <joakim> aha
07:12:59 <ejt> does lambdabot have a command to list prelude functions with a particular type ?
07:13:00 <quicksil1er> joakim: ghc -C
07:13:07 <quicksil1er> joakim: ghc --help gives more options
07:13:09 <nmessenger> ejt: hoogle
07:13:12 <sjanssen> @hoogle [a] -> a
07:13:13 <lambdabot> Prelude.head :: [a] -> a
07:13:13 <lambdabot> Prelude.last :: [a] -> a
07:13:13 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
07:13:18 <ejt> top !
07:13:19 <ejt> thx
07:13:33 <joakim> will try
07:13:52 <quicksil1er> @hoogle (a -> b) -> (a -> c)  -> a -> (b,c)
07:13:53 <lambdabot> No matches, try a more general search
07:14:04 <nmessenger> you might also ask it to *make* one via djinn
07:14:07 <quicksil1er> @djinn (a -> b) -> (a -> c)  -> a -> (b,c)
07:14:09 <lambdabot> f a b c = (a c, b c)
07:14:19 <quicksil1er> well duh :P
07:14:24 <ejt> @djinn [[a]] -> [[a]]
07:14:25 <lambdabot> f a = a
07:14:31 <ejt> :)
07:14:34 <quicksil1er> I wanted a cool arrow combinator version
07:14:40 <nmessenger> @pl f a b c = (a c, b c)
07:14:41 <lambdabot> f = liftM2 (,)
07:14:49 <nmessenger> quicksil1er: that's pl :P
07:15:01 <quicksil1er> which monand is that it's lifting into?
07:15:05 <nmessenger> Reader
07:15:09 * quicksil1er nods
07:15:09 <nmessenger> ((->) r)
07:15:09 <joakim> oh, see it now
07:15:26 <joakim> lots of #defines
07:16:10 <hpaste>  Hunter_wow pasted "shift lists" at http://hpaste.org/371
07:17:33 <nmessenger> Hunter_wow: randomR accepts a pair of bounds for its first arg
07:17:37 <Hunter_wow> Im VERY bad at generators, trying to learn
07:17:46 <Hunter_wow> ok.
07:17:58 <nmessenger> > randomR (0,100) (mkStdGen 42)
07:18:00 <lambdabot>  (25,1720602 40692)
07:18:44 <Hunter_wow> then I have to add something to my "k" in "where" I guess
07:18:56 <quicksil1er>  @type randomR
07:19:04 <quicksil1er> @type randomR
07:19:06 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
07:19:30 <nmessenger> Hunter_wow: you might accept a list of take counts instead of the generator, and generate them via randoms
07:19:44 <quicksil1er> Hunter_wow: you've made k recurse on itself
07:19:50 <quicksil1er> Hunter_wow: which is a bit off
07:19:52 <quicksil1er> odd
07:20:21 <quicksil1er> I think maybe you mean RandomR (0,length x)
07:20:38 <Hunter_wow> ah, might be it
07:20:41 <nmessenger> yep, passing k to randomR fixes it to a pair, and take a drop complain that they don't accept pairs
07:20:50 <nmessenger> s/a/and/
07:21:58 <Hunter_wow> aha, so I have to take "fst" in the drop?
07:22:20 <nmessenger> k is wrong, quicksil1er said the correct version
07:22:43 <Hunter_wow> k, testing
07:22:49 <nmessenger> k :)
07:23:23 <nmessenger> length x - 1, though, randomR uses inclusive bounds.
07:23:50 <nmessenger> and you should really consider factoring the RNG out of this function
07:24:50 <Hunter_wow> RNG=?
07:24:57 <nmessenger> random number generator
07:25:04 <Hunter_wow> aha,k
07:25:54 <nmessenger> shifts xs (c:counts) = take c xs : shifts (drop c xs) cs -- also the base case for []
07:26:02 <nmessenger> s/counts/cs/
07:26:30 * nmessenger thinks this could be an unfoldr
07:29:04 <nmessenger> ... = taken : shifts dropped cs where (taken, dropped) = splitAt c xs
07:31:23 <Hunter_wow> aha, never seen splitAt before ^^
07:31:30 <hpaste>  Hunter_wow annotated "shift lists" with "The last litle step in shift.." at http://hpaste.org/371#a1
07:34:51 <Hunter_wow> @type randomR
07:34:53 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
07:35:19 <Hunter_wow> fst (a, g)
07:36:40 <ehird> I'm toying with haskell (just done the "5 steps tutorial") but before I go on I'd like to ask: is there an accepted standard for indentation of haskell programs? i.e. hard tabs or soft tabs, what width if soft
07:37:20 <nmessenger> most people use spaces (soft tabs?), I don't know of a usual width, I usually use 2-4
07:37:31 <quicksil1er> ehird: certainily nothing accepted
07:37:42 <quicksil1er> ehird: I suspect many people just do what their editor does for them :)
07:38:02 <joakim> i'm convinced it is a simple solution on this exercise too, but
07:38:09 <ehird> quicksil1er: that's kinda hard when your editor requires you to pick hard/soft and the length, heh
07:38:11 <sjanssen> soft tabs of width 4 are pretty typical, I think
07:38:13 <Jaak> use only spaces or only tabs, just don't mix those two
07:38:13 <joakim> i should take lower cas
07:38:22 <sjanssen> ehird: do not use hard tabs
07:38:33 <ehird> sjanssen: any reason why?
07:38:40 <hpaste>  nmessenger annotated "shift lists" with "(no title)" at http://hpaste.org/371#a2
07:38:46 <joakim> i should take a lower case letters and return how many it is
07:38:47 <quicksil1er> that's a logn and painful debate, ehird :)
07:38:48 <sjanssen> and if you insist on using hard tabs, set them to 8 spaces
07:38:56 <joakim> "aBCde" -> 3
07:39:09 <quicksil1er> joakim: I could just tell you the answer
07:39:10 <allbery_b> hard tabs are only guaranteed to be 8 spaces on unix, your program will likely break on windowos as a result by violating the layout rule
07:39:13 <quicksil1er> joakim: but you wouldn't learn much :)
07:39:18 <ehird> quicksil1er: i was just wondering if it was a reason beyond "HARD TABS ARE EVIL" (a reason I lik eto ignore :P)
07:39:20 <joakim> i know
07:39:25 <nmessenger> > length (filter isLower "aBCde")
07:39:25 <quicksil1er> ehird: there are reasons, yes
07:39:26 <lambdabot>  3
07:39:28 <sjanssen> ehird: if you mix tab indentation with space indentation you can have layout troubles
07:39:33 <quicksil1er> joakim: browse the prelud
07:39:41 <quicksil1er> joakim: look around the list functions
07:39:47 <quicksil1er> or, well, get nmessenger to do it :P
07:39:47 <joakim> ok
07:39:54 <ehird> sjanssen: tabs for the initial indentation then spaces in e.g. comments for laying out text seems to scale perfectly..
07:39:58 <nmessenger> oops, yeah, learning
07:39:59 <joakim> length and filter
07:40:16 * nmessenger shrinks
07:40:17 <quicksil1er> ehird: that's perfectly sane as a notion, but hard to maintain without editor support
07:40:26 <sjanssen> especially if you use tab stops that aren't 8 spaces -- the code will look right on your screen but will fail to compile/mean the wrong thing to a Haskell compiler
07:41:25 <nmessenger> sjanssen: only *sometimes*, which makes it particularly evil.
07:42:32 <ehird> i use 8-width tabs anyway :p
07:42:54 <sjanssen> then you should be okay
07:43:04 <joakim> > let func = filter Char.isLower "aBCde"
07:43:05 <lambdabot>  Parse error
07:43:17 <nmessenger> yeah, but be careful of tab-nazis here :P
07:43:17 <joakim> oh
07:43:25 <joakim> length func
07:43:27 <TB> > 3 + 4
07:43:29 <lambdabot>  7
07:43:33 <TB> nice bot :)
07:43:45 <nmessenger> joakim: the 'let' needs an 'in'
07:43:53 <joakim> ok
07:43:53 <TB> let fib 0 = 0
07:43:56 <TB> let fib 1 = 1
07:44:09 <TB> let fib n = fib (n-1) + fib (n-2)
07:44:10 <ehird> nmessenger: what does that make me? a tab jew?
07:44:12 <joakim> haven't learnt about functions yet
07:44:17 <nmessenger> heh
07:44:19 <TB> > fib 3
07:44:21 <lambdabot>   Not in scope: `fib'
07:44:24 <TB> bah :P
07:44:27 <joakim> just seen how it is in examples
07:44:32 <ookk> 8 spaces tab? you got widescreen or something?
07:44:34 <ookk> :P
07:44:37 <ehird> ookk: yes. :)
07:44:38 <Jaak> > let fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 10
07:44:39 <lambdabot>  55
07:44:40 <nmessenger> TB: @let for new names, but you'll have to use case for multiple patterns
07:45:00 <ookk> ehird, haha ok fine then
07:45:03 <TB> :)
07:45:10 <TB> me likes that bot ;)
07:45:14 <ehird> > "i -->	<-- am a real tab."
07:45:16 <lambdabot>  "i -->\t<-- am a real tab."
07:45:20 <ehird> phooey
07:45:38 <nmessenger> @let fib n = case n of {0 -> 0; 1 -> 1; x -> fib (n-1) + fib (n-2)}
07:45:40 <lambdabot> Defined.
07:45:42 <nmessenger> > fib 10
07:45:45 <lambdabot>  55
07:45:51 <TB> :)
07:46:05 <ehird> > "> \"hi\""
07:46:07 <lambdabot>  "> \"hi\""
07:46:11 <ehird> grumble
07:46:16 <ookk> > fib 20
07:46:18 <lambdabot>  6765
07:46:23 <ehird> > fib 2047349573498573495734945734958347590345709257349587349573845
07:46:27 <lambdabot>  Exception: stack overflow
07:46:28 <TB> ... :/
07:46:31 <TB> That's mean! :P
07:46:39 <ehird> yes, it is
07:46:41 <joakim> > length ['h', 'e', 'l', 'l', 'o']
07:46:42 <lambdabot>  5
07:46:43 <TB> poor lambdabot!
07:46:51 * TB strokes lambdabot
07:46:58 <nmessenger> @slap TB
07:47:01 <ehird> > putStrLn "> 'hello. i am talking to myself.'"
07:47:09 * lambdabot slaps TB
07:47:10 <TB> @let cookie = 0
07:47:12 <ehird> no stdout redirection!
07:47:12 <nmessenger> @id no I am not
07:47:14 <lambdabot>  <IO ()>
07:47:21 <TB> @let eat n = "thank you"
07:47:25 <TB> > eat cookie
07:47:27 <lambdabot> Defined.
07:47:30 <rahikkala> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 2047349573498573495734945734958347590345709257349587349573845
07:47:31 <Jaak> > fix ((1:) . scanl (+) 1) -- phew
07:47:32 <lambdabot>  no I am not
07:47:36 <lambdabot> Defined.
07:47:38 <lambdabot>  "thank you"
07:47:40 <lambdabot>  Exception: Prelude.(!!): negative index
07:47:41 <ehird> > putStrLn "I am a bit behind."
07:47:42 <TB> :D
07:47:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:47:44 <lambdabot>  <IO ()>
07:47:49 <nmessenger> LB spamming!
07:47:54 <allbery_b> @botsnack
07:47:55 <lambdabot> :)
07:48:01 <ehird> > putStrLn "TRAPPED IN BOT FACTORY, SEND HELP"
07:48:03 <lambdabot>  <IO ()>
07:48:16 <lambdabot> You guys are abusing me!
07:48:21 <TB> > eat cookie
07:48:21 <nmessenger> if you have the privs, you can @msg
07:48:22 <lambdabot>  "thank you"
07:48:25 <TB> :)
07:48:31 <nmessenger> like whoever did that
07:48:33 <ehird> "You guys are abusing me!  thank you"
07:49:00 <TB> @let cookie = 0
07:49:01 <lambdabot> <local>:6:0:     Multiple declarations of `L.cookie'     Declared at: <local>...
07:49:09 <ookk> @let fib n = (0:1:[(fib (n-1)) + (fib (n-2)) | n <- [2..]]
07:49:10 <lambdabot>  Parse error
07:49:10 <TB> ...
07:49:15 <joakim> please, show me how i can return how many lower case letters from a string
07:49:18 <ookk> @let fib n = (0:1:[(fib (n-1)) + (fib (n-2)) | n <- [2..]])!!n
07:49:18 <nmessenger> slash-msg lambdabot if you want to play
07:49:19 <lambdabot> <local>:6:0:     Multiple declarations of `L.fib'     Declared at: <local>:3:...
07:49:19 <TB> Can I tell it to undefine cookie ?
07:49:32 <allbery_b> @undef cookie
07:49:33 <lambdabot> Undefined.
07:49:37 <TB> @undef eat
07:49:38 <lambdabot> Undefined.
07:49:42 <ookk> @undef fib
07:49:42 <TB> @let cookie = 0
07:49:43 <lambdabot> Undefined.
07:49:43 <lambdabot> Defined.
07:49:44 <ookk> @let fib n = (0:1:[(fib (n-1)) + (fib (n-2)) | n <- [2..]])!!n
07:49:45 <lambdabot> Defined.
07:49:46 <TB> @let cookies = 1
07:49:47 <lambdabot> Defined.
07:49:49 <ookk> fib 20
07:49:50 <ookk> > fib 20
07:49:51 <nmessenger> take it to /msg!
07:49:52 <lambdabot>  6765
07:49:56 <ookk> > fib 100
07:49:57 <lambdabot>  354224848179261915075
07:49:59 <ookk> > fib 1000
07:50:01 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
07:50:12 <sjanssen> @type length . filter (Data.Char.isLower)
07:50:14 <lambdabot> [Char] -> Int
07:50:20 <sjanssen> joakim: ^^^
07:50:21 <TB> @let eat n = case n of {0 -> "Thank you"; 1 -> "I like cookies!"; x -> "I only like cookies!"}
07:50:21 <ehird> > "so what are these .hi files hanging around"
07:50:23 <lambdabot> Defined.
07:50:23 <lambdabot>  "so what are these .hi files hanging around"
07:50:24 <TB> > eat cookie
07:50:26 <lambdabot>  "Thank you"
07:50:28 <TB> > eat cookies
07:50:29 <lambdabot>  "I like cookies!"
07:50:31 <TB> > eat 3
07:50:33 <lambdabot>  "I only like cookies!"
07:50:35 <TB> :D
07:50:41 <ehird> > wait how does that work
07:50:42 <lambdabot>   Not in scope: `work'
07:50:47 <ehird> shut up, bot
07:51:02 <Igloo> Anyone with trac+darcs experience (and ideally a d.h.o account) around?
07:51:08 <TB> > eat ehird
07:51:09 <lambdabot>   Not in scope: `ehird'
07:51:15 <TB> @let ehird = 2
07:51:17 <lambdabot> Defined.
07:51:18 <TB> > eat ehird
07:51:19 <lambdabot>  "I only like cookies!"
07:51:21 <nmessenger> TB: /msg lambdabot
07:51:21 <TB> :)
07:51:27 <ehird> > @let ehird = 1
07:51:28 <lambdabot>  Parse error
07:51:29 <ehird> er.
07:51:30 <TB> nmessenger:  case n of {0 -> 0; 1 -> 1; x -> fib (n-1) + fib (n-2)}
07:51:34 <ehird> @let ehird = 1
07:51:35 <lambdabot> Defined.
07:51:36 <TB> err
07:51:38 <TB> wrong copy paste
07:51:41 <Jaak> > let 3 = cookie in eat 3 -- hmm
07:51:42 <lambdabot>   Not in scope: `eat'
07:51:59 <TB> nmessenger: [freenode-info] if you need to send private messages, please register: http://freenode.net/faq.shtml#privmsg
07:52:01 <lambdabot> Title: freenode: frequently-asked questions
07:52:05 <TB> but ok, i'll stop :P
07:52:06 <Jaak> oops
07:52:12 <ehird> this channel is probably a better place to learn haskell than tutorials haha
07:52:31 <glguy> This channel is a better place to ask the questions you have while reading the tutorials ;)
07:52:34 <nmessenger> I was always able to /msg lambdabot before I id'd
07:53:02 <nmessenger> try /msg lambdabot @bot
07:53:10 <joakim> Use the functions mentioned in this section (you will need two of them)
07:53:10 <joakim> to compute the number of lower-case letters in a string. For instance, on aBCde it
07:53:10 <joakim> should return 3.
07:53:41 <quicksil1er> joakim: in fact, nmessenger answered you some time ago
07:53:49 <ehird> nmessenger: freenode hit the proverbial /msg off switch for unregd's
07:53:56 <slowriot> is there a way to solve this problem in O(n) without using arrays or hashtables?
07:53:57 <slowriot> https://www.spoj.pl/problems/PERMUT2/
07:54:03 <joakim> he did? didn't see. lazy me
07:54:03 <bd_> hmm, GHC Trac seems down
07:54:08 <quicksil1er> but I would urge you to experiemtn with filter and length
07:54:17 <quicksil1er> joakim: think how you might break down the problem
07:54:19 <nmessenger> > filter even [1..10]
07:54:20 <lambdabot>  [2,4,6,8,10]
07:54:27 <nmessenger> > filter (>5) [1..10]
07:54:29 <lambdabot>  [6,7,8,9,10]
07:54:32 <dcoutts_> bd_, yep, it's being upgraded
07:54:40 <nmessenger> filter isLower "aBcDe"
07:54:48 <nmessenger> > filter isLower "aBcDe"
07:54:49 <lambdabot>  "ace"
07:55:23 <ehird> hmm... Yet Another Haskell Tutorial and A Gentle Introduction to Haskell are linkde on the 5 steps page... is there any considered better overall in the community or not?
07:55:43 <nmessenger> Yaht is pretty universally recommended
07:55:48 <ehird> alright
07:56:04 <nmessenger> > length "ace"
07:56:06 <lambdabot>  3
07:57:07 <TB> @let mylength "cookie" = "I like cookies
07:57:07 <lambdabot>  Improperly terminated string
07:57:31 <ehird> wow, yaht is huge.. more of a book than a tutorial :p
07:57:32 <glguy> slowriot: so ambiguous permutations are ones whose cycles have length 1 or 2
07:57:33 <glguy> ?
07:57:36 <TB> @let mylength s = case s of {"cookie" -> "I like cookies!"; x -> length s}
07:57:38 <lambdabot> Couldn't match `[Char]' against `Int'
07:57:49 <TB> :/
07:57:58 <TB> Haskell doesn't love me anymore :'(
07:57:58 <slowriot> glguy: I am not sure. That's not how I identified them.
07:58:04 <nmessenger> mylength can't sometimes return a String but sometimes an Int.
07:58:19 <TB> @let mylength s = case s of {"cookie" -> "I like cookies!"; x -> "I don't know, stop bothering me!"}
07:58:20 <lambdabot> Defined.
07:58:24 <glguy> slowriot: that method would take O(n) time to check with an array
07:58:25 <TB> > mylength "poop"
07:58:26 <nmessenger> that wouldn't type, unless String and Int shared a class.
07:58:27 <lambdabot>  "I don't know, stop bothering me!"
07:58:29 <TB> > mylength "cookies"
07:58:31 <lambdabot>  "I don't know, stop bothering me!"
07:58:33 <TB> :D
07:58:35 <slowriot> glguy: it seems like it
07:58:37 <glguy> I'm still thinking of how to do it without one efficiently
07:58:44 <TB> > mylength "cookie"
07:58:45 <lambdabot>  "I like cookies!"
07:58:51 <TB> "me too!"
07:58:59 <nmessenger> "SRSLY?"
07:59:11 <glguy> slowriot: it could be done in n log n time with a map containing the expected cycles
07:59:12 <Syzygy-> "YARLY"
07:59:14 <glguy> without arrays
07:59:19 <slowriot> glguy: yeah, you're right
07:59:19 <Jaak> > let mylength s = case s of {"cookie" -> Left "I like cookies!"; x -> Right (length s)} in mylength "cookie"
07:59:21 <lambdabot>  Left "I like cookies!"
07:59:24 <Jaak> > let mylength s = case s of {"cookie" -> Left "I like cookies!"; x -> Right (length s)} in mylength "cookies"
07:59:26 <lambdabot>  Right 7
07:59:38 <TB> :/?
07:59:44 <nmessenger> Either String Int
07:59:46 <glguy> slowriot: you'll want to use ByteString's readInt for this
07:59:55 <slowriot> glguy: I did implement it with a map. I thought an n lg n solution would be fast enough, but it turns out that it wasn't.
08:00:07 <nmessenger> ... is a type that could be either a string or and Int :)
08:00:11 <allbery_b> can I recommend #haskell-overflow for folks who want to play with lambdabot without registering for /msg?
08:00:13 <slowriot> glguy: why not read?
08:00:23 <glguy> slowriot: way too slow
08:00:55 <slowriot> even when compared to a map lookup with 100000 elements?
08:00:55 <glguy> slowriot: also, be sure to use lazy bytestrings
08:01:05 <glguy> slowriot: try profiling if you aren't sure
08:01:07 <TB> @let like = 0
08:01:08 <lambdabot> Defined.
08:01:25 <glguy> > log 100000
08:01:27 <lambdabot>  11.512925464970229
08:01:31 <TB> @let do a b c = "Hell yeah!"
08:01:31 <lambdabot>  Parse error in pattern
08:01:40 <TB> bah :P
08:01:58 <nmessenger> do is reserved
08:02:05 <slowriot> log (log 100000)/(log 2)
08:02:21 <slowriot> I guess I don't know how to use lambda bot
08:02:22 <Syzygy-> > log (log 100000)/(log 2)
08:02:24 <lambdabot>  3.525182567587084
08:02:37 <Syzygy-> You need that > at the beginning, to tell her you want her to do something
08:02:38 <nmessenger> @help
08:02:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:02:40 <nmessenger> @list
08:02:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:02:56 <nmessenger> the '>' command is short for '@run'
08:02:57 <paolino> hi
08:02:57 <paolino> what is wrong here?
08:02:57 <paolino> states :: StateT [String] IO [FileStatus]
08:02:57 <paolino> states = gets (liftIO. mapM getFileStatus)
08:02:59 <slowriot> Syzygy: aha
08:03:15 <TB> bf
08:03:40 <Syzygy-> ?type fets (liftIO . mapM getFileStatus)
08:03:41 <lambdabot> Not in scope: `fets'
08:03:41 <lambdabot>  
08:03:41 <lambdabot> <interactive>:1:20: Not in scope: `getFileStatus'
08:03:47 <Saizan> ?type gets
08:03:47 <Syzygy-> ?type gets (liftIO . mapM getFileStatus)
08:03:49 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
08:03:50 <lambdabot> Not in scope: `getFileStatus'
08:04:34 <slowriot> I'm confused. My calculator says that ln(100000)/ln(2) == 16.6 give or take.
08:04:36 <Saizan> gets takea function (s -> a), so in your case a function [String] -> a
08:05:31 <Saizan> slowriot: you have asked lambdabot for ln(ln(100000))/ln(2)
08:05:45 <joakim> why has YAHT got exercises where you should write function when it's not even introduced?
08:06:01 <paolino> @. pl undo do {a<- get;liftIO $ mapM getFileStatus a}
08:06:01 <lambdabot> liftIO . mapM getFileStatus =<< get
08:06:05 <nmessenger> joakim: didn't it talk about length and filter?
08:06:19 <glguy> > log (exp 1)
08:06:21 <lambdabot>  1.0
08:06:27 <slowriot> ah
08:06:28 <joakim> yeah, but writing your own function
08:06:34 <Syzygy-> > exp (log 1)
08:06:35 <lambdabot>  1.0
08:06:41 <glguy> hurray!
08:06:47 <Syzygy-> > log (exp 0)
08:06:48 <lambdabot>  0.0
08:06:55 <glguy> :-/
08:06:57 <Syzygy-> > exp (log 0) -- *takes cover*
08:06:58 <lambdabot>  NaN
08:07:04 <glguy> boom
08:07:45 <slowriot> > (log (exp 100000))/(log (exp 2))
08:07:47 <lambdabot>  Infinity
08:07:52 <joakim> i should write a function using fold to return the biggets value in a list
08:08:01 <joakim> > maximum [15,3,4]
08:08:03 <lambdabot>  15
08:08:10 <slowriot> > (log (exp 100000.0))/(log (exp 2.0))
08:08:12 <lambdabot>  Infinity
08:08:19 <quicksil1er> joakim: ignore "write a function"
08:08:24 <quicksil1er> joakim: it's just a way to talking
08:08:30 <quicksil1er> joakim: read it as "write some haskell"
08:08:36 <slowriot> > (log (exp 3.0))
08:08:38 <lambdabot>  3.0
08:08:46 <slowriot> > (exp 100000.0)
08:08:47 <lambdabot>  Infinity
08:08:49 <slowriot> ah
08:08:50 <joakim> ok
08:09:37 <quicksil1er> joakim: but you're right, it is clumsy to use that before it is described
08:09:51 <nmessenger> joakim: hmm yeah it does seem like it asks you to write a function without showing the syntax first.  A hole in the tutorial
08:10:26 <nmessenger> it's not perfect
08:11:34 <nmessenger> functions are discussed in 3.5
08:11:53 <slowriot> glguy: Can you use the : syntax with ByteStrings?
08:11:55 <joakim> i skip those exercises and do them later
08:11:59 <nmessenger> but don't worry about it yet
08:12:29 <quicksil1er> joakim: you don't need to write a function to do those exercises
08:12:37 <quicksil1er> just write code, instead of a function
08:12:40 <glguy> slowriot: no, but you don't need to
08:12:47 <glguy> the bytestring words function returns a list
08:12:56 <joakim> sure not, but i'm logically not in functional languages
08:13:14 <hpaste>  slowriot pasted "Ambiguous Permutations" at http://hpaste.org/372
08:13:37 <slowriot> here is my O(n lg n) solution.
08:14:23 <slowriot> I'm not sure if I expect an O(n lg n) solution to run fast enough (they do not say how many test cases there are, after all), but if you guys have any feedback for me, it would be appreciated.
08:14:47 <slowriot> again, this is the problem: https://www.spoj.pl/problems/PERMUT2/
08:15:06 <quicksil1er> there is no such thing is O(n), everything which you think is O(n) is O(n lg n) :)
08:15:27 <glguy> in an irrelevant theoretical sense
08:15:35 <glguy> where numbers have no bound
08:16:18 <slowriot> never heard of that before
08:18:01 <quicksil1er> slowriot: issues like data locality
08:18:04 <quicksil1er> and space
08:18:19 <quicksil1er> e.g. most O(n) time algorithms also consume O(n) space
08:18:29 <quicksil1er> the O(n) space will tack on a lg n time
08:18:34 <glguy> they do?
08:18:57 <slowriot> to allocate maybe? Usually it can be accessed in constant time.
08:19:06 <quicksil1er> slowriot: not usually, no :)
08:19:21 <quicksil1er> slowriot: usually the first n MB are in level X cache, the next n MB are in level Y cache...
08:19:33 <quicksil1er> slowriot: the next chunk is in RAM, and the chunk after that in slow storage
08:19:42 <michaelw> quicksil1er: it depends on which machine model you are using.  whether you have unit costs or not
08:19:44 <quicksil1er> so your algorihm scales according to the storage penalties it incurs
08:19:48 <quicksil1er> michaelw: clearly
08:19:54 <quicksil1er> I generalise :)
08:20:08 <slowriot> huh
08:20:13 <quicksil1er> but it's fiendishly hard to get interesting algorithms to genuinely perform in O(n).
08:20:17 <michaelw> of course, unbounded size registers are kind of unrealistic :)
08:20:41 <quicksil1er> and emulation of unbounded size on a bounded size machine is typically another lg n factor
08:20:45 <quicksil1er> :)
08:21:26 <michaelw> yeah, so you can litter your estimations with log factors, but I'd rather not.
08:21:39 <quicksil1er> right
08:21:48 <quicksil1er> but it's often not worth preferring O(n) over O(n lg n)
08:21:53 <quicksil1er> that was the point I was making
08:22:14 <quicksil1er> it's worth preferring either one over (n^2) or (2^n)
08:22:39 <quicksil1er> but the lg factor is not scary
08:29:19 <slowriot> ?src readInt
08:29:20 <lambdabot> Source not found. I feel much better now.
08:29:37 <slowriot> ?src Data.ByteString.readInt
08:29:38 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:38:01 <slowriot> the code I pasted uses IntMap... I meant to use map. I don't know why I changed it to IntMap. Just messing around, I guess.
08:38:38 <hpaste>  glguy annotated "Ambiguous Permutations" with "my version" at http://hpaste.org/372#a1
08:39:25 <glguy> in the worst case, 1/2 of the elements could be stored in the map
08:39:36 <glguy> IntMap is prefered to Map when using Int as a key
08:39:57 <fincher> as an optimization?
08:40:03 <fincher> does it use Patricia tries?
08:40:07 <glguy> yes
08:40:12 <glguy> ?docs Data.IntMap
08:40:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
08:40:27 <glguy> "The implementation is based on big-endian patricia trees."
08:41:07 <glguy> This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int  (32 or 64).
08:41:27 <slowriot> that's worse than lg n, though
08:41:59 <slowriot> (in our case)
08:43:03 <ookk> audreyt, you there?
08:43:34 <glguy> slowriot: it isn't a strict bound
08:43:49 <slowriot> oh, so average case tends to beat normal maps?
08:44:56 <slowriot> yeah, I guess the docs do say that.
08:45:50 <glguy> slowriot: a bound of O(min(n,W)) is technically constant time or better (with a large constant)
08:46:12 <slowriot> yeah... the constant would be 32
08:46:20 <slowriot> but lg 100000 is about 16
08:46:26 <glguy> so?
08:46:35 <glguy> that doesn't mean that Map isn't 23*log n
08:47:16 <glguy> anyway, yo ucan't use bytestrings on spoj anyway
08:47:39 <slowriot> dang
08:47:52 <glguy> spoj isn't worth doing until they update from ghc 6.4.1
08:48:14 <slowriot> what should I use until then?
08:48:26 <glguy> projecteuler.net is one place
08:49:15 <slowriot> yeah, Project Euler is pretty cool
08:50:54 <slowriot> It's 8:47... I need start working on my homework. Thanks for the help, glguy.
09:14:23 <hpaste>  eighty pasted "starrays!11" at http://hpaste.org/373
09:14:34 <Eighty> helps!
09:14:46 <Eighty> is there any good tutorial on starrays (and ioarrays would be nice too)
09:15:00 <Eighty> the reference isn't easy to understand
09:15:24 <bd_> Eighty: Don't use $ with runSTArray :/
09:15:56 <Eighty> what the?
09:15:59 <trurl> Eighty: http://www.haskell.org/haskellwiki/Modern_array_libraries
09:16:01 <lambdabot> Title: Modern array libraries - HaskellWiki
09:16:02 <Eighty> okay
09:16:02 <bd_> it's a weird limitation of the type system
09:16:02 <bd_> use: x = runSTArray (mk 3)
09:16:05 <Eighty> but why doesn't that work?
09:16:19 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/07/the-20-minute-parser/
09:16:23 <lambdabot> Title: The 20-minute parser  Data.Syntaxfree
09:16:27 * syntaxfree ducks
09:16:47 <bd_> Eighty: It's some weird limitation of existential types... ($) doesn't have a polymorphic type, but it needs to, or something.
09:16:49 <Eighty> trurl: that page basically just exclaims the names of the different arrays, and then runs away
09:16:54 <nmessenger> yay!  /me likes reading syntaxfree's blog
09:17:12 <TuringTest> Eighty: Have you used the ST monad before?
09:17:13 <syntaxfree> nmessenger: this ain't one of the usual rants, I'm afraid. I'm trying to be positive ; )
09:17:19 <Eighty> TuringTest: no
09:17:21 <trurl> Eighty: I found it useful
09:17:46 <TuringTest> Eighty: have you used IOArray or IORef before?
09:17:50 <bd_> wasn't there aq thread on -cafe not too long about about this?
09:17:53 <bd_> ago*
09:18:03 <Eighty> TuringTest: i used IOArray a few days ago
09:18:10 <Eighty> but probably not the way i'm supposed to
09:18:18 <nmessenger> is nadsat that Clockwork Orange slang?
09:18:23 <syntaxfree> yes.
09:18:29 <Eighty> because i only know about the functions newListArray, writeArray and readArray.
09:18:38 <Eighty> i'd like a nice tutorial
09:18:48 <TuringTest> Eighty: Then the MArray interface is the same set of commands (newArray / readArray / writeArray) that work with STArray
09:19:25 <bd_> ?where haskell-cafe
09:19:26 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
09:19:52 * nmessenger should really follow (the provided!) Wikipedia links before asking dumb questions
09:19:58 <bd_> Eighty: This thread is relevant to your immediate problem: http://www.haskell.org/pipermail/haskell-cafe/2007-January/021035.html
09:20:01 <lambdabot> Title: [Haskell-cafe] Composing functions with runST, http://tinyurl.com/ypbf6e
09:20:14 <quicksil1er> @pl \(((((a,b),c),d),e),f) -> b:f
09:20:15 <lambdabot> uncurry ((:) . snd . fst . fst . fst)
09:20:32 <quicksil1er> @pl \(((((a,b),c),d),e),f) -> b:d
09:20:32 <lambdabot> uncurry (uncurry (uncurry (((const . const) .) . (:) . snd . fst)))
09:20:39 <quicksil1er> heh
09:20:50 <bd_> Eighty: see also http://www.haskell.org/pipermail/haskell-cafe/2007-January/021046.html
09:20:52 <lambdabot> Title: [Haskell-cafe] Composing functions with runST, http://tinyurl.com/24ol2j
09:21:19 <bd_> it's ugly, I know :/
09:22:33 <syntaxfree> yes, I  know I could use flip join findWithDefault in subst.
09:25:20 <chessguy> hi haskellers
09:26:32 <Eighty> well i won't use $ then :/
09:28:47 <Saizan> syntaxfree: don't your word parser strips away all spaces? so "baboochka : old woman :: Russian (babooshka/grandmother)" returns fromList [("baboochka","oldwoman")]?
09:29:48 <Saizan> s/("baboochka","oldwoman")/("oldwoman","baboochka")/
09:29:58 <syntaxfree> Saizan: it uses "words" anyway, so.
09:31:38 <Saizan> yes but with "appy polly loggies : apologies" you will translate "apologies" to "appypollyloggies"
09:31:48 <Saizan> well, just a minor glitch anyway :)
09:31:53 <nmessenger> > {- but -} (filter isAlpha " old woman") -- in the definition of word
09:31:55 <lambdabot>  "oldwoman"
09:31:58 <matthew_-> Does Conor McBride ever appear on #haskell?
09:33:31 <chessguy> lol
09:33:36 <chessguy> "This example comes with a disclaimer. You should never use Writer in this way."
09:34:06 <syntaxfree> Saizan: well, it'd take me more than the alloted time.
09:34:24 <nmessenger> syntaxfree: would it be better to have word result in a CharParser () (String, String) and the fromList the [(String, String)]?
09:34:30 <syntaxfree> The point was to do it on a whim. People seem to insist that Haskell is no good for quick hacks. So there!
09:34:36 <nmessenger> heh
09:34:47 <Saizan> plus i'm not very sure how this works, but won't dict skip only headers that appear at the top?
09:35:01 <nmessenger> I guess it serves that goal well
09:35:02 <syntaxfree> nmessenger: I know how the unions conflict handling works; not sure for fromList.
09:35:23 <syntaxfree> Saizan: well, my testing seems to indicate it's okay.
09:35:50 <syntaxfree> *Nadsat> bain "A bad girl drinks milk and has sex"
09:35:50 <syntaxfree> Right "A baddiwad devotchka firegolds moloko and has pol"
09:35:52 <nmessenger> > fromListWith const [(1,'a'),(1,'b'),(2,'c')]
09:35:53 <lambdabot>   Not in scope: `fromListWith'
09:35:56 <nmessenger> > M.fromListWith const [(1,'a'),(1,'b'),(2,'c')]
09:35:57 <lambdabot>  {1:='b',2:='c'}
09:36:01 <syntaxfree> (where bain text = do { dict<-nadsatDict; print $ fmap (subst text) dict; })
09:36:50 * Japsu would kindly like to point out that Miko-Chan is a spambot
09:37:09 <Japsu> this is what I got in a query when I joined #haskell:  19:33  Miko-Chan : Harry Potter - The Order Of The Phoenix, Out 13th July 2007!! Book Now to avoid Disappointment...
09:37:09 <syntaxfree> oh. I've also printed the entire dictionary with nadsatDict >>= print, the headers don't show up.
09:37:31 <fincher> I can confirm Japsu's analysis.
09:37:38 <fincher> Miko-Chan should be removed from the channel.
09:37:43 <nmessenger> ops!
09:37:45 <syntaxfree> I got nothnig.
09:37:47 <Saizan> so >>= interleaves the parsers?
09:37:59 <chessguy> syntaxfree, Miko-Chan just joined
09:38:15 <syntaxfree> nah. it's just that nadsatDict is in the IO monad since it reads from a file.
09:38:28 <syntaxfree> so I >>= into print so I can look at the entire dictionary as represented in a Map.
09:38:34 <Saizan> that i see
09:38:36 <syntaxfree> I did that precisely to verify headers were out.
09:38:48 <Saizan> i was talking about an imaginary desucared dict :)
09:38:48 <Miko-Chan> Todays Smilie count is sponsored by Dr Pepper(tm) - Smilie count is 1
09:38:50 <glguy> !paste
09:38:51 <hpaste> Haskell paste bin: http://hpaste.org/
09:38:55 <Saizan> *desugare
09:39:04 <syntaxfree> haha. Miko-Chan looks more like a chatter-bot.
09:39:08 <nmessenger> :(
09:39:15 <nmessenger> :D
09:39:25 <nmessenger> doesn't know her smileys very well
09:39:34 <glguy> !say hi
09:39:35 <hpaste> hi
09:39:44 <chessguy> !say foo
09:39:47 <nmessenger> 8-)
09:39:49 <chessguy> :(
09:39:52 <matthew_-> does anyone else find the following odd: a) much of type checking is based on unification. b) Haskell is supporting more and more of the dependent type system ideas, which are strongly based on unification. c) unification of non-type variables in haskell is not supported.
09:40:04 <syntaxfree> I wish I knew how to make Nadsat into a lambdabot plugin.
09:40:18 <chessguy> what's Nadsat?
09:40:34 <syntaxfree> clockwork orange slang.
09:40:40 <syntaxfree> chessguy: http://syntaxfree.wordpress.com/2007/02/07/the-20-minute-parser/
09:40:43 <lambdabot> Title: The 20-minute parser  Data.Syntaxfree
09:41:31 <syntaxfree> lambdabot should have a more transparent "text filter" API.
09:41:41 <Mavez-San> !jb
09:41:41 <Miko-Chan> Explosions do not kill Jack Bauer, they just get stuff out of his way.
09:42:00 <syntaxfree> Mko-Chan is a bot.
09:42:02 <syntaxfree> !jb
09:42:02 <Miko-Chan> When you open a can of whoop-ass, Jack Bauer jumps out.
09:42:03 <chessguy> syntaxfree, nice
09:42:29 <chessguy> Mavez-San, why is Miko-Chan spamming people when they arrive?
09:42:33 <nmessenger> syntaxfree: where did you get the nadsat dictionary?
09:42:40 <syntaxfree> nmessenger: it's linked in the article.
09:42:52 <fincher> syntaxfree: I used to know someone who went by the nick "SyntaxPolice" -- his name was Isaac Jones, iirc.  Are you him, or are you just someone else with a similar nick?
09:42:53 <syntaxfree> "this page where there's a translator for Windows"
09:42:54 <Mavez-San> !tyme
09:42:55 <Miko-Chan> Wed, 7 Feb 2007 17:43:11
09:43:02 <syntaxfree> I'm Diego Navarro.
09:43:04 <glguy> Miko-Chan: needs to not spam please
09:43:07 * nmessenger should *really* just follow links first :S
09:43:30 <syntaxfree> nmessenger: wordpress.com even has that annoying SNap preview onMouseover.
09:43:45 <Mavez-San> !jb
09:43:46 <Miko-Chan> Jack Bauer makes onions cry.
09:43:46 <nmessenger> very annoying, yes.
09:44:00 <glguy> Mavez-San: please disable the auto-greet
09:44:02 <syntaxfree> it got some people in trouble with the NSFW test image for Pancito, it seems :(
09:44:09 <nmessenger> heh
09:44:13 <Philippa> fincher: Isaac's SyntaxNinja
09:44:33 <fincher> Philippa: oh yeah.
09:44:41 <fincher> so syntaxfree isn't Isaac, I assume :)
09:44:41 <Miko-Chan> Todays Smilie count is sponsored by Dr Pepper(tm) - Smilie count is 2
09:44:51 <Philippa> fincher: right :-)
09:44:59 <fincher> can someone get Miko-Chan out of here?
09:45:18 <Mavez-San> !jb
09:45:19 <Miko-Chan> The Black Eyed Peas were just The Peas until Jack Bauer heard their music.
09:45:20 --- mode: ChanServ set +o glguy
09:45:24 --- mode: glguy set +b *!*n=miko@*.co.uk
09:45:24 --- kick: Miko-Chan was kicked by glguy (glguy)
09:45:25 <nmessenger> what the hell does that mean?  Does Dr Pepper get a penny every time someone says ":)"?
09:45:28 * chessguy waves byebye
09:45:40 <chessguy> (and good riddance)
09:46:00 <syntaxfree> Mavez-San: a chatty bot is probably not welcome in a technical channel like this.
09:46:06 <Mavez-San> :(
09:46:10 <bos> @hoogle isNaN
09:46:11 <chessguy> s/probably/
09:46:11 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
09:46:14 <syntaxfree> It might be greeted with a cheerier reception at #haskell-blah
09:46:17 <glguy> especially one that auto-greets
09:46:18 <chessguy> s/probably// that is
09:49:08 --- mode: glguy set -o glguy
09:51:41 <Philippa> syntaxfree: -blah can be considered anti-bot, I think
09:51:54 <Philippa> it rubs up against the non-logging policy
09:52:13 <syntaxfree> ah, I see.
09:52:19 <chessguy> there's a non-logging policy in -blah?
09:52:22 <Philippa> lambdabot's at least a known element
09:52:38 <Philippa> chessguy: yeah. It can be reasonably taken as "no logging anywhere that might end up public" rather than "no logs at all"
09:52:43 <syntaxfree> well, nonlogging can be negotiated. I find the smiley count thing funnyish, for a while.
09:53:01 <Philippa> but bots're always going to raise a higher level of suspicion than human-controlled clients
09:53:17 <quicksil1er> I log all my channels for 24 hours
09:53:21 <quicksil1er> that's just how my client works
09:53:27 <chessguy> what client?
09:53:30 <quicksil1er> I sort of assume that isn't the spirit of 'antilogging' though
09:53:31 <quicksil1er> irssi
09:53:40 --- mode: ChanServ set +o glguy
09:53:43 <chessguy> ah, i didn't know irssi did that
09:53:45 --- mode: glguy set -b *!*n=miko@*.co.uk
09:53:46 * chessguy hides
09:53:46 <quicksil1er> well it's not technically a log, it's a scrollback
09:53:50 --- mode: glguy set -o glguy
09:53:50 <Philippa> quicksil1er: right. So long as you don't have the logs where others can get at them
09:53:52 <chessguy> whew
09:53:52 <quicksil1er> but it is the same thing, after all
09:54:06 * glguy doesn't really want to fill the ban list, hopes the bot won't become a nuisance
09:54:09 <Philippa> a lot of clients'll keep text logs, and some people find them useful for non-blackmail purposes too
09:54:13 <Philippa> (I'm one of them)
09:54:47 <chessguy> i really need to uninstall hydraIRC and put xChat on this machine. i like it at home
09:55:34 <syntaxfree> logs aren't conclusive proof.
09:55:56 <syntaxfree> [3:53 PM] <chessguy> I hate Haskell. I prefer Java.
09:56:00 <glguy> I think you should probably figure that anything you say on IRC could be on the front page of the NYTimes tomorrow
09:56:11 <syntaxfree> I've even been mis@quoted in the lambdabot db.
09:56:12 * chessguy shoots himsef
09:56:21 <Philippa> syntaxfree: some things don't need conclusive proof, especially if the writing style fits
09:56:26 <chessguy> lol
09:56:38 <chessguy> Mavez-San is having a bad day
09:56:53 <Philippa> certain tendencies of mine that're not infrequently discussed in -blah could easily cause someone career difficulty on the basis of rumour alone
09:57:08 <syntaxfree> I know, I know.
09:57:11 <Philippa> (I don't mind using myself as an example because I'm thoroughly out about such things)
09:57:54 <Philippa> I'm subtly misquoted in lambdabot thanks to an error on vincenz's behalf :-)
09:58:00 <chessguy> @quote Philippa
09:58:01 <lambdabot> Philippa says: hey, if the guy wants a monadectomy that's his choice
09:58:01 <syntaxfree> I've thought out about a thing or two as well, and I'd rather an employer know of my full psychiatric history (which isn't much so far) so I can be sure I'm working for someone who *get's it*.
09:58:17 <syntaxfree> @quote syntaxfree
09:58:17 <lambdabot> syntaxfree says: Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
09:58:27 <syntaxfree> that's not me, that's Erik Meijer.
09:58:33 <syntaxfree> @quote syntaxdree
09:58:34 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
09:58:38 <syntaxfree> @quotre syntaxfree
09:58:39 <lambdabot> syntaxfree says: yes, The Wadlerman. the Prince of Funktions.
09:58:51 <syntaxfree> that's me. I'll look for the quote in private and paste it here.
09:59:52 <syntaxfree> I think the misquote might have been removed. I did whine to dons immediately, and five minutes later said "oh, forget it, I'm being childish".
10:00:28 <syntaxfree> anyway, all that supports a point that IRC is no conclusive evidence, maybe modulo server logs.
10:00:39 <Philippa> it never was, but that's not the point
10:02:18 <chessguy> ?quote least-broken
10:02:19 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
10:02:23 <chessguy> that's a good one
10:03:06 <matthew_-> it also probably has some of the most attention in looking for brokenness, imho.
10:03:08 <chessguy> reminiscent of a chess quote: "Chess grandmasters are just chess players who suck the least at chess", by Kasparov (though probably mangled)
10:03:49 <Philippa> chessguy: "make the fewest mistakes"?
10:04:04 <chessguy> maybe
10:04:12 <chessguy> i thought it was stronger than that
10:04:39 <Philippa> possibly "fuck up least", then :-)
10:09:56 <paolin1> @paste
10:09:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:10:00 <fincher> wasn't there a chess player who said, "The winner is the one who made the second-to-last mistake"?
10:10:13 <chessguy> yes, probably many of them :)
10:10:28 * syntaxfree is reading the Nadsat version of "Notes from the underground" now ; )
10:11:38 <hpaste>  paolino pasted "DiffArray slow ?" at http://hpaste.org/374
10:12:28 <paolin1> using that shuffle I get
10:12:29 <paolin1> *Lib> sum $ Shuffle.run0 evalState (Shuffle.shuffle [1..10000])
10:12:29 <paolin1> 50005000
10:12:29 <paolin1> (41.50 secs, 827815908 bytes)
10:14:23 <syntaxfree> hey. the nadsat filter as I posted eats newlines. I can't find out why though.
10:14:29 <paolin1> it's not a usable  function with that performace
10:15:13 <chessguy> > pi
10:15:14 <lambdabot>  3.141592653589793
10:15:28 <chessguy> hmm, not exact?
10:16:14 <hpaste>  syntaxfree pasted "it eats newlines!" at http://hpaste.org/375
10:17:19 <arcatan> who needs newlines anyway?
10:18:02 <chessguy> ?quote extra
10:18:03 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
10:19:27 <syntaxfree> Over 2,000,000 Scripts exist for greasemonkey.
10:19:52 <syntaxfree> there seems to be NONE that just uses a unix text filter to parse text!
10:20:44 <matthew_-> well you can't shell out from javascript easily
10:21:00 <syntaxfree> Greasemonkey is just javascript?
10:21:04 <matthew_-> yep
10:21:14 <syntaxfree> bah.
10:21:14 <emu> this history of haskell makes a fine tutorial
10:21:23 <syntaxfree> There should be universal unix text filter support anywhere.
10:21:29 <syntaxfree> All throughout Cocoa, too.
10:21:47 <matthew_-> intel are adding that as an sse4 instruction to the next core 2 duo cpu line
10:21:52 <matthew_-> (penryn onwards)
10:22:04 <matthew_-> yes, string searching on the CPU. Hum.
10:22:08 <syntaxfree> Unix pipes are the perfect API for text manipulation. Why not leverage it?
10:22:29 <paolino> anyone has a clue on what makes my shuffle so slow ?
10:23:26 <xerox> ciao paolino (:
10:23:28 <emu> maybe if you added currying and lambda expressions to the unix shell
10:23:38 <paolino> and arrows
10:23:43 <paolino> ciao xerox
10:23:45 <syntaxfree> and comonads.
10:23:46 <syntaxfree>  
10:23:47 <syntaxfree> : )
10:24:02 <matthew_-> syntaxfree: most firefox addons are just javascript. I know of only one that isn't
10:24:19 <syntaxfree> I just want something that filters text in pages by a unix script.
10:24:24 <syntaxfree> This isn't rocket science : (
10:24:28 <glguy> ad block plus for the win!
10:25:06 <matthew_-> it's actually quite hard. you should look at the source code for tiddlywiki to see the pain that goes through to try to save to the local filesystem
10:25:36 <paolino> yes
10:25:40 <syntaxfree> bah, I'm beginning to think of serving the script locally as a CGI program!
10:26:01 <syntaxfree> I wonder if *that* a browser plugin can do.
10:26:07 <matthew_-> no
10:26:23 <syntaxfree> not the serving, I mean, filtering through a server.
10:26:31 <syntaxfree> I'm gonna run HappS or something.
10:26:42 <matthew_-> yes, you can do that with greasemonkey
10:26:54 <syntaxfree> the browser script would POST to the local server, which would return the filtered tex.
10:26:55 <quicksil1er> @pl \x -> [f.g $ x]
10:26:56 <lambdabot> return . f . g
10:27:13 <matthew_-> load the page, grab the innerHTML, then xmlhttp to send it to your server, grab the response and reset the innerHTML
10:27:22 <matthew_-> and this is so *way* off topic ;)
10:27:28 <quicksil1er> lambdabot: I don't like return for lists though :(
10:27:36 <quicksil1er> is the source code for @pl available ?
10:27:48 <glguy> all the lambdabot source is available
10:28:12 <quicksil1er> Is pl 'just part of it' or is it using a separate module?
10:28:22 <glguy> a plugin
10:29:05 <paolino> glguy please, tell me why my shuffle is so slow :)
10:30:01 <glguy> paolino: yes, STArrays are faster than DiffArrays
10:31:06 <nmessenger> quicksil1er: return for lists is (:[]), you could use that.
10:31:08 <quicksil1er> glguy: ooh, lambdabot as a ghci plugin. Cute. That would be faster than IRC when I'm on the train :P
10:31:23 <syntaxfree> YES!
10:31:31 <quicksil1er> nmessenger: that's a very good point
10:31:32 <glguy> quicksil1er: I think that is called GAO
10:31:38 <syntaxfree> http://wafflesoftware.net/thisservice/
10:31:38 <glguy> (don't know for sure though and never used it
10:31:40 <lambdabot> Title: ThisService
10:31:44 <syntaxfree> that's Mac-only, but solves my problem!
10:31:46 <nmessenger> GOA, ghci on acid
10:31:49 <syntaxfree> Here I go browsing in nadsat ; )
10:31:51 <nmessenger> @where goa
10:31:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
10:31:57 <syntaxfree> bah, Tiger required ;'(
10:32:19 <glguy> You don't use 10.4?
10:32:34 <syntaxfree> nope. It was too slow on my 256megs of ram mac last time I checked.
10:32:51 <syntaxfree> But it's starting to get frustrating how many things are only available for 10.4
10:32:54 <syntaxfree> Beginning with GHC!
10:33:10 <syntaxfree> Dunno, my work environment is so perfect now, maybe I shouldn't screw with it. But I'm tempted!
10:33:46 <quicksil1er> nmessenger: yes, I prefer that. To be that's more 'self-documenting'
10:33:50 <quicksil1er> nmessenger: 'to me'
10:34:05 <quicksil1er> the problem with return is you have to think "hmm, what is the type of that sub expression"
10:34:10 <nmessenger> @. pl src [] return
10:34:11 <lambdabot> (line 1, column 1):
10:34:11 <lambdabot> unexpected end of input
10:34:11 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
10:34:16 <nmessenger> @src [] return
10:34:17 <lambdabot> return x    = [x]
10:34:31 <quicksil1er> (an editor extension which could show me the inferred type at any point in the code would be fun)
10:34:48 <quicksil1er> @pl (\((((((_,_),ns),_),_),ts),_) -> (Just ns,ts))
10:34:49 <lambdabot> uncurry (uncurry ((const .) . (,) . Just . snd . fst . fst))
10:34:50 <nmessenger> @pl return x = [x]
10:34:50 <lambdabot> return = return
10:34:54 <nmessenger> heh
10:35:03 <syntaxfree> off-topic question about Macs, please join #haskell-blah
10:35:07 <quicksil1er> @pl (\x -> (Nothing,x)).(map (\x -> [x])).snd.fst
10:35:07 <lambdabot> (,) Nothing . map return . snd . fst
10:35:17 <quicksil1er> hmm that's sexy
10:35:38 <nmessenger> @type (\x -> (Nothing,x)).(map (\x -> [x])).snd.fst
10:35:40 <lambdabot> forall a a1 a2 b. ((a2, [a1]), b) -> (Maybe a, [[a1]])
10:35:49 <nmessenger> an odd type
10:35:58 <quicksil1er> nmessenger: combinator parsing
10:36:09 <quicksil1er> nmessenger: extracting the bits I want
10:36:16 <quicksil1er> there's probably a better way, I'm very rusty
10:37:27 <nmessenger> (\((_, y), _) -> (Nothing, map (:[]) x)) -- ?
10:37:47 <nmessenger> if you're using lambdas anyway, I'd use pattern-matching instead of fst and snd
10:38:18 <nmessenger> s/y/x/
10:38:50 <quicksil1er> nmessenger: yes, that code 'evolved'
10:39:05 <nmessenger> I know the type, :o)
10:39:16 <quicksil1er> nmessenger: I have an irrational preference: point-free when I understand the pointfree version, explicit lambda when it gets complex and my eyes can't parse it
10:40:00 <nmessenger> projections like head, tail, fst, and snd just feel strange to me
10:40:02 <syntaxfree> lambdas are often harder to parse than simple point-free.
10:40:16 <syntaxfree> (*2) . (+)  is clearer than (\x y -> 2*(x+y))
10:40:28 * syntaxfree often uses (&) = flip (.)  for additional clarity.
10:41:05 <nmessenger> @src (->) (>>>)
10:41:05 <lambdabot> f >>> g = g . f
10:41:18 * syntaxfree drops dead.
10:41:42 <nmessenger> ot
10:41:48 <nmessenger> it's already there!
10:42:01 <nmessenger> (pressed return instead of ')
10:42:58 <Syzygy-> > (*2) >>> (+) $ 3
10:42:59 <lambdabot>  Add a type signature
10:43:02 <Syzygy-> > (*2) >>> (+) $ 3 :: Int
10:43:02 <syntaxfree> > (+) >> (*2) $ 3
10:43:03 <lambdabot>  Couldn't match `Int' against `a -> a'
10:43:04 <lambdabot>  6
10:43:05 <syntaxfree> ugly.
10:43:13 <Syzygy-> Ah.
10:43:23 <nmessenger> > (*2) >>> (+3) $ 5
10:43:23 <syntaxfree> you need a type declaration for the reader monad.
10:43:24 <Syzygy-> Oh, wait. That's not what I wanted to do.
10:43:24 <lambdabot>  13
10:43:24 <syntaxfree> er, arrow.
10:43:29 <astrolabe> '(*2) . (+)' is wrong isn't it?
10:43:31 <Syzygy-> That was it. :P
10:43:35 <Syzygy-> astrolabe: Yes, it is.
10:43:37 <nmessenger> (>>>) is flip (.)
10:43:48 <syntaxfree> astrolabe. nah.
10:43:54 <syntaxfree> > (*2) . (+) $ 3 5
10:43:55 <lambdabot>   add an instance declaration for (Num (t -> a))
10:44:11 <nmessenger> that'd probably be (>>=) or something
10:45:09 <syntaxfree> > (+) 3 5
10:45:11 <lambdabot>  8
10:45:14 <syntaxfree> > (*2) 8
10:45:16 <lambdabot>  16
10:45:23 <syntaxfree> > ((*2) . (+)) $ 3 5
10:45:24 <lambdabot>   add an instance declaration for (Num (t -> a))
10:45:28 <syntaxfree> grrrrr
10:45:37 <nmessenger> > ((*2) . (+5)) $ 3
10:45:39 <lambdabot>  16
10:45:55 <nmessenger> (+) isn't a Num a => a -> a
10:46:05 <nmessenger> (+5) is
10:46:22 <syntaxfree> yes. But I gave it *TWO* arguments.
10:46:42 <nmessenger> > (((*2) .) . (+)) $ 3 5
10:46:43 <lambdabot>   add an instance declaration for (Num (t -> a))
10:47:04 <nmessenger> > (((*2) .) . (+)) 3 5
10:47:05 <lambdabot>  16
10:47:35 <nmessenger> @pl \x y -> f (g x y)
10:47:36 <lambdabot> (f .) . g
10:47:39 <xerox> syntaxfree: yes it is.
10:47:59 <syntaxfree> xerox: what is what?
10:48:02 <xerox> (wrong)
10:48:16 <olliej> ?seen ndm
10:48:17 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 23h 9m 41s ago, and .
10:48:18 <xerox> :t (*2) . (+)
10:48:20 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a -> a
10:48:50 <xerox> :t (*2) >>= (+)
10:48:52 <lambdabot> forall a. (Num a) => a -> a
10:49:13 <nmessenger> @src ((->) r) (>>=)
10:49:13 <lambdabot> Source not found. Take a stress pill and think things over.
10:49:43 <nmessenger> hmm.
10:51:42 <nmessenger> It's not obvious how to lookup the reader monad's (>>=).
10:52:36 <xerox> ?djinn (e -> a) -> (a -> e -> b) -> (e -> b)
10:52:37 <lambdabot> f a b c = b (a c) c
10:53:01 <nmessenger> ?remember syntaxfree * syntaxfree often uses (&) = flip (.)  for additional clarity.   <nmessenger> @src (->) (>>>)   <lambdabot> f >>> g = g . f   * syntaxfree drops dead.
10:53:01 <lambdabot> Done.
10:56:01 <nmessenger> that's far too funny
10:56:40 <Saizan> & is shorter than >>>
11:00:45 <Nanar> I have a big problem with HTTP module
11:00:57 <Nanar> It is installed but I cannot use it
11:01:08 <Nanar> ghc said module is not exported
11:01:53 <Botje> nmessenger: you meanie.
11:02:24 <nmessenger> meanie for what?  edumacating?
11:02:54 <Botje> yar. we don't need no edumacation :p
11:03:08 <nmessenger> his reaction was just too priceless
11:03:14 <Botje> agreed :)
11:03:50 * shaleh is trying to understand hugs
11:04:12 <nmessenger> shaleh: you a Haskell newbie?  Do you have a specific question?
11:04:13 <shaleh> how do I define a function from the interactive prompt? Or do i have to write functions in external files and load them?
11:04:27 <shaleh> how do I define a function from the interactive prompt? Or do i have to write functions in external files and load them?
11:04:36 <nmessenger> You can't, yes you must.
11:04:45 <nmessenger> (last time I checked)
11:04:54 <shaleh> nmessenger: thanks, I am more accustomed to Python's interpreter
11:05:02 <shaleh> nmessenger: is the same true of ghci?
11:05:05 <dcoutts_> shaleh, one can define small functions in ghci using:
11:05:07 <nmessenger> no
11:05:09 <dcoutts_> let foo x = ...
11:05:33 <dcoutts_> that's how it works in a monad, and ghci is kind of the IO monad
11:05:54 <dcoutts_> so it allows let ... and _ <- ...
11:05:56 * nmessenger never thought of it that way
11:06:34 <shaleh> hmm, but not pattern matching / overloading
11:06:34 <nmessenger> also adds a helpful 'print $' to non-IO expressions
11:06:41 <shaleh> ok, write in files, load into runtime
11:06:42 <shaleh> got it
11:06:59 <dcoutts_> hia SyntaxNinja, I think Igloo was looking for you
11:07:31 <SyntaxNinja> hi dcoutts_, hi Igloo
11:07:49 <Saizan> shaleh: if you use emacs you can install haskell-mode and load your file in a ghci just by C-c C-l
11:07:54 <dcoutts_> SyntaxNinja, Igloo has been trying to upgrade Trac on darcs.h.o
11:08:22 <emu> shaleh: also once you :load file you can always :reload it (:l and :r respectively).  and emacs haskell-mode has bindings for all that too.
11:08:37 <shaleh> Saizan: fair enough. This is more about learning to think in haskell. I am decidedly a Python thinker currently
11:09:07 <shaleh> I usually noodle around, define functions and classes, then copy them into source files once i like them
11:09:12 <emu> i came from Common Lisp so I'm even more picky about interactivity ;)
11:09:29 <nmessenger> shaleh: good to have you on board, work through one of the tutorials, and come back here with questions. :)
11:09:52 <shaleh> nmessenger: I tried a year and a half ago. Hit the monad wall and walked away.
11:10:09 <shaleh> picked my books back up yesterday
11:10:59 <shaleh> nmessenger: thanks for the warm welcome though
11:11:12 <Procyon_> shaleh: I'm a Schemer, so I understand too.  emacs ghci mode is very good as a repl though.  Edit what you want to say in the top window, C-c C-r to execute in the bottom.
11:11:15 <shaleh> is there a decent hugs v. ghci write up somewhere
11:12:32 <SyntaxNinja> dcoutts_: I haven't had a chance to check my email today :)
11:12:56 <dcoutts_> SyntaxNinja, no, I think he was planning to pounce on you here :-)
11:13:09 <emu> shaleh: i'm told hugs has nicer error messages
11:13:15 <emu> however, i always did well with ghci
11:13:22 <Binkley> emu: actually, GHC's error messages have improved a lot over the past few years
11:13:29 <vincenz> re
11:13:29 <Binkley> whoever said that may have been thinking of GHC as of six years ago
11:13:32 <dcoutts_> SyntaxNinja, btw, galois used to to transformation of C code, they don't have a nice open source C parser written in Haskell do they?
11:13:38 <vincenz> Igloo: alright, thanks
11:13:41 <dcoutts_> SyntaxNinja, just wondering if I'm duplicating work :-)
11:13:50 <SyntaxNinja> dcoutts_: I can ask around.
11:14:04 <dcoutts_> SyntaxNinja, I'm having another go at making c2hs's C parser work properly
11:14:07 <emu> i don't think there's much reason to use hugs except: you can't get ghc on your system, hugs probably uses less memory.
11:14:23 <Binkley> true, hugs is more portable
11:14:57 <nmessenger> hugs sounds friendlier :)
11:15:14 <Binkley> ghci is very friendly :-)
11:15:19 <Binkley> names can be deceptive!
11:15:20 <emu> hugs, released on valentine's day 1995!
11:15:31 <nmessenger> guhicky?
11:15:44 <Binkley> well, ghc was originally released on april fool's day
11:15:57 <dcoutts_> aye, ghci gives better better error messages than hugs does
11:16:03 <dcoutts_> so better for beginners I think
11:16:04 <emu> ghci is very good nowadays it seems.  i've run into a couple of strange bugs in odd situations.  the next step is an hs-plugins based interpreter i think.
11:16:33 <dcoutts_> emu, why would one based on hs-plugins be better?
11:17:20 <allbery_b> ghc-api not good enough for you?
11:17:39 <dcoutts_> ghci uses the ghc-api of course
11:18:11 <emu> introducing changes into a running program would be nice
11:18:39 <emu> a complaint about ghci: if you load or reload a bad file, you lose your place
11:18:52 <Binkley> what do you mean by "your place"?
11:19:01 <dcoutts_> the current set of bindings
11:19:01 <emu> the current module definitions
11:19:04 <Binkley> oh, yeah
11:19:06 <Binkley> that annoys me too
11:19:10 <Saizan> don't you lose it even if it's good?
11:19:14 <emu> it would be nice to retain that because then you could check your types and try again
11:19:20 <Binkley> yeah
11:19:23 <Binkley> would be nice
11:19:37 <Binkley> if erlang can do it, then ghc should be able to! ;-)
11:19:43 <emu> nowadays i "defensively" use :type (via my emacs keybindings which also remember the types)
11:20:13 <emu> so when i hover over the function name it will message the type in the mini buffer
11:20:39 <emu> haskell-doc has that for built-in functions, but it also has an a-list in which you can add "user defined function :: type pairs"
11:21:30 <emu> i would also like to extract the types of inner functions and variables, but my probing of GHC-API revealed that to be difficult (I think)
11:21:48 <chessguy> hey dcoutts, i just saw something that says it requires gtk+hs...is that different from gtk2hs?
11:22:38 <allbery_b> wasn't that the old version of gtk2hs?
11:22:43 <dcoutts_> chessguy, gtk+hs is really really old. gtk2hs forked from it about 5 years ago
11:22:47 <nmessenger> If there are errors, it'd be cool if :l and :r loaded everything that was correct
11:22:50 <dcoutts_> it's not seen any development since
11:22:51 <chessguy> hmm
11:22:57 <Binkley> emu: by "inner functions and variables" you mean non-top-level functions and variables?
11:23:04 <dcoutts_> chessguy, it was for Gtk+ 1.x
11:23:06 <emu> yes
11:23:08 <chessguy> if something requires gtk+hs, is it likely to work with gtk2hs?
11:23:11 <emu> ie. within a where-clause
11:23:19 <dcoutts_> chessguy, with a little porting, yes.
11:23:31 <dcoutts_> chessguy, what prog are you looking at?
11:23:35 <chessguy> hIde
11:23:41 <dcoutts_> oh the old version
11:23:49 <dcoutts_> that'd be a lot of work
11:23:49 <chessguy> ?where hide
11:23:50 <lambdabot> http://haskell.org/haskellwiki/HIDE
11:24:01 <Binkley> emu: i'd think that would be non-straightforward. for one thing, names can be shadowed, and they don't have to be globally unique
11:24:05 <emu> i also like the idea of supporting a similar-to-SLIME ide
11:24:14 <dcoutts_> chessguy, you can still download a binary build of it I think
11:24:14 <emu> Binkley: right, you would have to establish the lexical context
11:24:35 <emu> but right now i have no time for looking into these things as i have a full time job and 2 classes
11:24:37 <Binkley> emu: yeah, I don't know how you would specify the context. I guess with some thought you could come up with something reasonable
11:24:39 <Binkley> i hear you
11:24:40 <dcoutts_> chessguy, it'd probably only work with the same vintage of ghc too.
11:24:41 <emu> speaking of which, i must go :(
11:24:56 <chessguy> hmm, that page doesn't say anything about requiring a graphical library
11:24:57 <Binkley> i have a part-time job and no classes and i still have a hard time finding time to hack :-0
11:24:58 <emu> Binkley: allegro CL has a way actually
11:27:19 <chessguy> i guess i'll just have to try to build it and see what happens
11:30:44 <glguy> woohoo, company is budgeting cash for new dev PCs
11:31:01 <glguy> dualcore,lots o hd, and 2 gigs ram
11:31:23 <vincenz> noice
11:31:25 <master_baiter> woohoo
11:31:28 <vincenz> how much screen
11:31:37 <glguy> we still keep our existing monitors
11:31:45 <glguy> 2x 17" lcd
11:31:51 <glguy> I think
11:31:52 <glguy> maybe 19
11:31:56 <glguy> I'm not sure what these are now
11:32:23 <vincenz> master_baiter: what does your nick refer to?
11:32:26 <glguy> maybe 18, lcds come in different sizes
11:32:37 <vincenz> Binkley: heh I was searching on some terms on linkedin and saw your profile
11:32:48 <Binkley> vincenz: that doesn't surprise me
11:32:59 <vincenz> Binkley: nor me, you have quite a few terms :)
11:32:59 <master_baiter> i'm a master baiter
11:33:05 <Binkley> if you know of any jobs, let me know :-)
11:33:08 <vincenz> master_baiter: meaning?
11:33:11 <vincenz> Binkley: definitely
11:33:16 <vincenz> Binkley: should I add you?
11:33:27 <master_baiter> i master bait
11:33:36 <Binkley> i'm trying to add mostly people who i know
11:33:42 <Binkley> like, offline :-)
11:33:44 <vincenz> master_baiter: it is hardly amusing
11:33:56 <master_baiter> i find it amusing.
11:34:33 <vincenz> master_baiter: perhaps you could pick a less offensive name?/
11:34:48 <master_baiter> how is my "name" offensive?
11:34:50 <glguy> lol, doesn't matter if you find it amusing if vincenz doesn't :)
11:35:03 <vincenz> Binkley: mind pming me your email?/
11:35:20 <glguy> maybe just hpaste your email?
11:35:21 <glguy> ;)
11:35:46 <vincenz> master_baiter: perhaps you could explain how you find it amusing?
11:35:59 <Binkley> vincenz: /ignore is a good command to know ;-)
11:36:04 <master_baiter> it's a funny name
11:36:09 <vincenz> Binkley: I just had a course on communications ;)
11:36:20 <Binkley> vincenz: maybe you should have studied harder ;-)
11:36:29 <glguy> this reminds me of a Burt Reynolds SNL skit
11:36:32 <Binkley> heh
11:36:36 <vincenz> master_baiter: and do you believe that such humor is appropriate for a channel focussed on programming languages?/
11:36:43 <glguy> celebrity jeopardy
11:36:47 <chessguy> has anybody here listend to many of the haskell video lectures linked here: http://lambda-the-ultimate.org/node/1303
11:36:47 <glguy> Turd Ferguson
11:36:48 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
11:36:50 <glguy> its a funny name
11:36:56 <chessguy> i'm wondering if he ever gets around to interesting stuff like monads
11:37:07 <master_baiter> vincenz you think this is the only channel i'm in?
11:37:28 <glguy> ?spell masterbater
11:37:29 <lambdabot> master bater master-bater masturbate masturbated masturbates
11:37:49 <fincher> I'm in agreement with vincenz, fwiw.
11:37:59 <glguy> ?users
11:37:59 <lambdabot> Maximum users seen in #haskell: 322, currently: 312 (96.9%), active: 44 (14.1%)
11:38:15 <glguy> > 1 / 312 * 100
11:38:16 <lambdabot>  0.3205128205128205
11:38:33 <vincenz> master_baiter: most likely not, however perhaps you misunderstood my question?
11:38:50 <master_baiter> vincenz perhaps
11:39:01 <vincenz> I asked if it is appropriate for a channel on PLs
11:39:22 <glguy> vincenz: so it wasn't a course on direct communication?
11:39:34 <vincenz> glguy: no, confrontational styles do not hlep
11:39:36 <master_baiter> vincenz i think it's fine.
11:40:09 <master_baiter> feel free to ignore me, if you don't.
11:40:26 <Binkley> so, anybody implemented any good type classes lately?
11:41:10 <vincenz> master_baiter: other people in the past have been asked to change their name and I think it is somewhat of an unwritten policy.
11:41:11 <chessguy> Binkley, that sounds like a bad pickup line :)
11:41:25 <master_baiter> unwritten = doesn't exist
11:41:46 <glguy> written = +b
11:41:51 <vincenz> right
11:41:54 <vincenz> unwritten = +k
11:41:55 <master_baiter> verba volant, scripta manent
11:42:22 <master_baiter> well, feel free to do whatever you want.
11:42:27 <vincenz> master_baiter: can you understand that some may find it offensive?
11:42:32 <chessguy> master_baiter, when everyone but you thinks there's something wrong with your name but you, you're probably wrong
11:42:38 <hpaste>  Hunter_wow pasted "generators and lists" at http://hpaste.org/376
11:42:50 <chessguy> just a general rule of thumb
11:42:58 <master_baiter> there is nothing offensive with my nickname
11:43:09 <glguy> "The words fly away, the writings remain"
11:43:13 <vincenz> master_baiter: I understand that is your point of view, but can you understand that others may not see it that way?
11:43:17 <master_baiter> do you have something against baiting?
11:43:21 <Binkley> Folks, whether you've had a communication class or not, a good rule of thumb is that ignoring people almost always makes them go away
11:43:32 <master_baiter> vincenz i don't particularly care what other think
11:43:40 <chessguy> i say you just kline the guy and be done with him
11:43:43 <vincenz> master_baiter: then why are you in a place intended to communicate wiht others?
11:43:49 <dylan> master_baiter: I find the name "master" politically sensitive as it brings to mind all sorts of slavery that you humans have subjected each other to.
11:43:53 <glguy> chessguy: channel ops can't k-line
11:44:06 <chessguy> kline, ban, whatever
11:44:13 <chessguy> he obviously doesn't want to listen to common sense
11:44:27 <master_baiter> vincenz you're the one who was trying to communicate with me
11:44:33 <Hunter_wow> back to work, shall we? :P
11:44:37 <master_baiter> while i was pretty much lurking
11:44:44 <vincenz> master_baiter: So you are saying that you have no added value in this channel besides having an offensive name
11:44:44 <glguy> do you guys want to take that to -blah ;)
11:44:50 <master_baiter> vincenz sure
11:44:53 <vincenz> ok
11:44:55 <vincenz> goodbye then
11:44:58 <master_baiter> bye!
11:45:39 --- mode: ChanServ set +o vincenz
11:45:42 --- mode: vincenz set +b *!*i=refugee@*.mu.org
11:45:42 --- kick: master_baiter was kicked by vincenz (vincenz)
11:45:44 <glguy> hmm, vincenz has not optimized his op+kb sequence
11:45:50 <vincenz> not yet no
11:45:51 --- mode: vincenz set -o vincenz
11:46:03 <glguy> vincenz: why not +b master_baiter!*@*
11:46:04 <vincenz> It's not the first time he's been addressed on this subject
11:46:08 <Binkley> SO MUCH DRAMA IN THE PHD
11:46:11 <vincenz> glguy: /kickban
11:46:12 <glguy> and let him lurk under a different name
11:46:34 <glguy> vincenz: I use /knockout (when I want it to automatically remove the ban in 5
11:46:43 <vincenz> glguy: ah nice :)
11:46:43 <glguy> aka /kn
11:46:49 <vincenz> Thanks for the suggestion
11:46:51 <Binkley> brb
11:46:53 <glguy> (in irssi)
11:47:05 <glguy> vincenz: and I aliased /opme to msg chanserv
11:47:12 <gvdm_other> on shootout haskell went from 20 times slower than C to 12, is there any reason why we can't get better performance for the mandelbrot?
11:47:15 <vincenz> glguy: I had that, but cleared my settings
11:47:26 * vincenz hides ban messages so does not know whom to unban
11:47:27 <Hunter_wow> anyone who got time for my paste?  http://hpaste.org/376
11:47:27 <notsmack> seemed juvenile, but not /offensive/, imo
11:47:33 --- mode: ChanServ set +o glguy
11:47:39 <dcoutts_> gvdm_other, I think some people have been looking at it recently.
11:47:39 --- mode: glguy set -b *!*i=refugee@*.mu.org
11:47:48 --- mode: glguy set +b master_baiter!*@*
11:47:48 <vincenz> notsmack: he has been asked before to change it and obviously was not interested in communicating anything useful
11:47:58 --- mode: glguy set -o glguy
11:48:07 <dcoutts_> gvdm_other, if you want to help out on it, go for it. :-) You might also want to talk to dons about it.
11:48:14 <Binkley> Hunter_wow: yes. take a look at your code -- what's the return type of the body?
11:48:23 <Binkley> the right-hand side of your definition of shifts, that is
11:49:30 <chessguy> i think a number of people looked quite extensively at mandelbrot last night
11:49:44 <Hunter_wow> yea, can see it will return [[Int]]. But no ideas how and why it also should be ..,StdGen)
11:50:15 <Binkley> Hunter_wow: well, do you want to start with figuring out the "how" or the "why"? :-D
11:50:19 <dcoutts_> chessguy, did they discover anything interesting?
11:50:33 <Hunter_wow> Binkley: :P
11:50:40 <chessguy> dcoutts_, i don't know, i was on the phone
11:50:50 <dcoutts_> heh ok :-)
11:50:51 <chessguy> i think they improved it quite a bit, but i'm not sure
11:51:09 <gvdm_other> I was listening in and it seemed like nobody really knew what the compiler was doing, and sometimes things went faster...
11:51:22 <gvdm_other> chessguy: from 20 to 12 times C
11:51:33 <gvdm_other> the leading implementation right now
11:52:24 <Hunter_wow> but is it even possible to return an (x,stdGen). I mean is not an "stdGen" just an tool to get an result?
11:52:56 <Binkley> Hunter_wow: sure, you can return an (x,stdGen). Something of type StdGen is a first-class value
11:52:59 <Binkley> that means you can use it anywhere
11:53:00 <chessguy> Hunter_wow, you can pass or return anything in haskell
11:53:05 <Binkley> but, what do you mean by "just an tool to get a result?"
11:53:37 <Hunter_wow> aha, ok
11:54:34 <Hunter_wow> just mean it feels stupid to have it as an result. But I guess that depends on how I will use the results.
11:54:49 <Binkley> well, stupid is as stupid does :-)
11:54:58 <chessguy> thank you Forrest Gump
11:55:02 <Binkley> whether it's stupid depends, though...
11:55:03 <Hunter_wow> stdGen is as we call it an "generator" right? and is not a value?
11:55:09 <Hunter_wow> ok :)
11:55:09 <Binkley> were you given a specification for shifts?
11:55:20 <Binkley> in Haskell, every expression has a value
11:55:52 <Binkley> randomR, in this context, returns an expression whose type is ([Int], StdGen)
11:55:56 <Hunter_wow> ah, but value I mean int or number :)
11:56:00 <Binkley> and so you can do anything you want with the thing it returns
11:56:02 <glguy> > mkStdGen 42
11:56:04 <lambdabot>  43 1
11:56:05 <Binkley> well, Haskell's type system is more interesting
11:56:10 <Binkley> you can have values that aren't ints
11:56:14 <glguy> :t mkStdGen 42
11:56:16 <lambdabot> StdGen
11:56:23 <Binkley> values can be simple types like ints or chars, or more complex types like lists or pairs
11:56:28 <Binkley> values can also be functions
11:56:42 <glguy> a StdGen is a value with two seeds
11:57:35 <Hunter_wow> means StdGen can be anything?.. Or just an generator who needs inputs or something to work?
11:57:53 <glguy> RandomGen can be "anything"
11:57:58 <glguy> ?src RandomGen
11:57:58 <lambdabot> class RandomGen g where
11:57:59 <lambdabot>    next     :: g -> (Int, g)
11:57:59 <lambdabot>    split    :: g -> (g, g)
11:57:59 <lambdabot>    genRange :: g -> (Int,Int)
11:58:11 <Hunter_wow> ok
11:58:12 <glguy> StdGen is a concrete implementation
11:58:37 <Hunter_wow> :t StdGen
11:58:39 <lambdabot> Not in scope: data constructor `StdGen'
11:58:53 <glguy> :k StdGen
11:58:55 <lambdabot> *
11:58:56 <Hunter_wow> ?src StdGen
11:58:57 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:59:21 <gvdm_other> ?src stdGen
11:59:22 <lambdabot> Source not found. Where did you learn to type?
11:59:45 <gvdm_other> hmm, lambdabot hates me
11:59:50 <Hunter_wow> :P
11:59:56 <Hunter_wow> whell, I give up for the moment
12:00:09 <Hunter_wow> thx for trying at least =)
12:00:19 <resiak> ?src mkStdGen
12:00:20 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:00:20 <glguy> what are you trying to figure out?
12:00:21 <Binkley> Hunter_wow: well, feel free to come back if you think of other questions later on
12:00:25 <glguy> I missed the original question
12:00:37 <Hunter_wow> Binkley thx, I will, cu ;)
12:01:05 <Hunter_wow> glguy: think I have to figure that out
12:02:10 <Hunter_wow> http://hpaste.org/376   belive I need to put me into it a bit more. Those generators are meking me confused
12:02:19 <Hunter_wow> *making
12:02:24 <chessguy> ?tyman, i really hope these video lectures get to more interesting stuff. i like his style, but it's a little tedious
12:02:24 <lambdabot> Unknown command, try @list
12:03:18 <glguy> Hunter_wow: so you need a function called "rotate" that rotates a list?
12:03:26 <glguy> and a function that uses that and a random number
12:03:35 <glguy> to randomly rottate the list?
12:04:38 <glguy> > let rotate n xs = uncurry (flip (++)) (splitAt n xs) in rotate 2 [1..10]
12:04:40 <lambdabot>  [3,4,5,6,7,8,9,10,1,2]
12:04:43 <Hunter_wow> yea, think so, move one random length part to the end
12:05:32 <glguy> do you have to do this more than once?
12:06:12 <Hunter_wow> no, the function will be called again later on and do it over again. So just once with random rotation
12:06:24 <glguy> do you know about state monads?
12:06:31 <Hunter_wow> no
12:06:40 <glguy> ok, so I won't use them in an example
12:09:55 <hpaste>  glguy annotated "generators and lists" with "randRotate" at http://hpaste.org/376#a1
12:10:19 <glguy> since you aren't using state monads yet, you will have to manually thread the generator through each computation that uses random numbers
12:10:30 <chessguy> by the way, a very nice application of the state monad: http://www.haskell.org/haskellwiki/Compose
12:10:31 <lambdabot> Title: Compose - HaskellWiki
12:10:39 <glguy> (i,g') = randomR (0,i-1) g -- mistake -- (i,g') = randomR (0,n-1) g
12:11:49 <glguy> I added the definition of "rotate" to the paste if you refresh
12:12:11 <Hunter_wow> ah, thx
12:14:06 <Hunter_wow> whell, really need to get me something to eat now, lots of thanks glguy!
12:15:01 <chessguy> err, i think there's a bug in there, glguy
12:17:15 <chessguy> glguy, i think you want: (i,g') = randomR (0,n-1) g
12:17:15 <glguy> probably is
12:17:27 <glguy> chessguy: read the scroll back
12:17:32 <glguy> 14:08  glguy> (i,g') = randomR (0,i-1) g -- mistake -- (i,g') = randomR (0,n-1) g
12:17:37 <chessguy> oh, sorry
12:17:59 <chessguy> i'm only half paying attention while listening to a video lecture and pretending to do work
12:17:59 <hpaste>  glguy annotated "generators and lists" with "minor correction" at http://hpaste.org/376#a3
12:18:14 <glguy> http://hpaste.org/376/diff?old=1&new=3
12:18:18 <glguy> diff ftw
12:19:13 <glguy> since comparing bytestrings does a length comparison first (for equality)
12:19:27 <glguy> the diff algorithm is generally able to run pretty quickly for two pastes
12:20:05 <glguy> (bytestring length is O(1)
12:20:31 <dcoutts_> it also checks pointer equality for shortcut ==
12:20:38 <xerox> chessguy: which lecture?
12:20:39 <dcoutts_> so in the best case == is O(1)
12:20:46 * xerox waves to dcoutts_
12:20:51 <dcoutts_> hia xerox
12:21:14 <xerox> pointer equality!
12:21:26 <glguy> separate but equal!
12:21:26 <dcoutts_> glguy, so using a string pool with ByteString gives you O(1) == most of the time
12:21:38 <xerox> how's going the list fusion stuff?
12:21:39 <ndm> dcoutts, best case for non-equal strings only
12:22:03 <glguy> equal strings will best case shortcut
12:22:05 <glguy> on pointer equality
12:22:14 <dcoutts_> ndm, hm? the worst case is strings that are equal but not the same memory chunk
12:22:36 <ndm> dcoutts, btw - got my multithreaded demo working beautifully with gtk - that one additional function is very handy!
12:22:46 <glguy> in the diff algorithm , all of the strings are different memory chunks
12:23:03 <dcoutts_> ndm, great
12:23:27 <xerox> ndm: cool, what are you doing with multithreaded gtk?
12:23:30 * ndm wonders if there is any benchmark where Yhc could outperform GHC in the shootout
12:23:34 <ndm> @where guihaskell
12:23:35 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
12:23:35 <cjay> moin
12:23:39 <ndm> xerox: ^
12:23:42 <mahogny> ndm, did you fix the threads problem?
12:24:11 <ndm> mahogny: dcoutts_ did, in the latest Gtk snapshot - which means when I get some free time i can port the fix and continue onwards
12:24:31 <mahogny> nice. one thing less on my todo :)
12:24:35 <chessguy> :t -> \x y x*y
12:24:37 <lambdabot> parse error on input `->'
12:24:40 * mahogny was just about to use gtkhs
12:24:44 <chessguy> :t \x y x*y
12:24:46 <lambdabot> parse error on input `*'
12:24:50 <chessguy> :t \x y -> x*y
12:24:53 <lambdabot> forall a. (Num a) => a -> a -> a
12:24:56 <chessguy> man, i'm tired
12:25:00 <ndm> threading + gtk is now pretty nice - a bit of work, but a lot less than say C coding
12:25:13 <dcoutts_> it's still unchecked
12:25:29 <dcoutts_> you can shoot yourself in the foot pretty easily
12:25:47 <xerox> *blam*
12:25:53 <dcoutts_> quite
12:25:54 <ndm> dcoutts_ - fesability of adding any checking which you could turn on?
12:26:14 <ndm> dcoutts - since the failure case is likely to be working fine and silently corrupting the odd bits of memory...
12:26:14 <dcoutts_> ndm, you'd have to put a check in just about every operation :-(
12:26:24 <dcoutts_> exactly, :-( :-(
12:26:28 <paolino> anyone has a pointer to an STArray example  ?
12:26:44 <mahogny> well. compared to the code I have on my desk now, some qt+c++ a thesis worker has done over half a year, anything towards better gui for haskell is a dream
12:26:49 <ndm> still, 100 times better than the previous release where the only alternative was to go at glacial speeds
12:27:12 * mahogny has spotted over 10 memory leaks and 20 illegal delete's so far :(
12:27:37 <ndm> i had heard QT was quite nice
12:27:43 * dcoutts_ -> out
12:27:46 <xerox> paolino: if there is Storable STArray you can do |with starray $ \ptr -> do ...|.
12:27:55 <ndm> i guess more foot ammo, but nicer than Gtk
12:27:59 <mahogny> QT is nice. I wish I could say the same about the host language
12:28:34 <mahogny> QT is rather cancerogenous though
12:28:38 * mahogny no like
12:29:06 <paolino> :t starray
12:29:08 <lambdabot> Not in scope: `starray'
12:29:23 <xerox> paolino: with starray I mean a value of the type you want to get a pointer to.
12:29:23 <ndm> ?hoogle array
12:29:24 <lambdabot> Array.array :: Ix a => (a, a) -> [(a, b)] -> Array a b
12:29:24 <lambdabot> Data.Array.array :: Ix i => (i, i) -> [(i, e)] -> Array i e
12:29:24 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
12:29:28 <ndm> ?hoogle starray
12:29:29 <lambdabot> Data.Array.ST.STArray :: data STArray s i e
12:29:29 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
12:29:29 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
12:30:48 <paolino> xerox , an example ?
12:31:57 <xerox> It hasn't got a Storable instance
12:32:57 <xerox> ?docs Data.Array.Storable
12:32:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Storable.html
12:33:03 <xerox> uhu
12:33:24 <xerox> :t Data.Array.Storable.withStorableArray
12:33:25 <paolino> @instances Storable
12:33:26 <lambdabot> forall a e i. Data.Array.Storable.StorableArray i e -> (GHC.Ptr.Ptr e -> IO a) -> IO a
12:33:26 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
12:33:30 <xerox> ta-da :)
12:34:08 <paolino> IO ?
12:34:18 <xerox> you want pointers, you need to be in IO
12:34:35 <paolino> isn't ST enough ?
12:34:46 <xerox> So you want an STRef containing an array?
12:35:24 <bd_> paolino: Ptr doesn't do bounds checking, and can escape ST
12:35:26 <paolino> I don't want unsafePerformIO to exit
12:35:31 <kolmodin> ndm: do you run your windows "asis" or have you unixified it somehow? http://lennartkolmodin.blogspot.com/2007/02/fish-out-of-water.html
12:35:34 <lambdabot> Title: Bits and Bytes: Fish out of water, http://tinyurl.com/22ckgk
12:35:47 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html
12:35:49 <lambdabot> http://tinyurl.com/2xk8oz
12:36:11 <ndm> kolmodin: as is, no mingw or cygwin, but i do have UnxUtils installed
12:36:28 <kolmodin> right, ~same as gnuwin32
12:36:38 <mauke> I'm trying to write a parser (again)
12:37:00 <mauke> is there a sane way to do error reporting in the presence of notFollowedBy?
12:37:04 <ndm> kolmodin: kind of like comparing an ant to an 800 pound gorilla - same idea, but unxutils is a lot lighter
12:37:16 <kolmodin> ndm: oh, ok
12:37:29 <kolmodin> I tried to download it today without success
12:37:31 <ndm> kolmodin: i just have a zip of binaries which i put on my path, not custom installers etc
12:37:42 <kolmodin> right
12:37:44 <ndm> kolmodin: yes, its 404'ing, i do intend to make a mirror shortly of that
12:37:58 <bd_> paolino: What do you mean by unsafePerformIO exiting?
12:38:05 <ndm> kolmodin: give me 2 secs, and i'll mirror it
12:38:13 <kolmodin> ok, I'll try it tomorrow then
12:38:26 <paolino> my function shuffles a list
12:38:27 <kolmodin> (no windows machine here))
12:38:29 <ndm> ah, and i couldn't live without open command prompt here
12:38:43 <paolino> shuffle :: [a] -> [a]
12:38:46 <ndm> and textpad over vim/emacs
12:38:53 <paolino> no IO
12:39:00 <bd_> paolino: What's wrong with just using STArray? With Ptrs you wouldn't be able to do that any, as you'd need Storable a
12:39:17 <ndm> and winzip 9 does all winrar does, plus more and more integrated and user friendly - but just as powerful
12:39:18 <kolmodin> ndm: yeah, windows needs to be customized before it's (kind of) usable
12:39:31 <kolmodin> ah, cool
12:39:37 <paolino> I asked an example of STArray !
12:39:48 <kolmodin> clearly I haven't been using windows very long!
12:40:02 <kolmodin> much has happened since I converted
12:40:10 <paolino> I'm scared of Ptrs also
12:40:27 <ndm> yeah, i love Windows - but without textpad its not half the system it otherwise is
12:40:38 <kolmodin> ndm: do you use virtual desktops?
12:41:00 * nomeata already confuses textpad, notepad and wordpad.
12:41:03 <kolmodin> that and copy paste with the mouse is whan I miss most
12:41:08 <nomeata> Does MacOS have an iPad?
12:41:11 <glguy> what do pointers have to do with starrays?
12:41:23 <ndm> kolmodin: no, since i've never had it i never miss it - ditto for copy with mouse
12:41:25 <sjanssen> very little
12:41:39 <kolmodin> ndm: try it and you'll be hooked :)
12:41:50 <ndm> nomeata: notepad is ultra simple, wordpad is ultra simple plus formatting (almost ultra useless), textpad is ultra perfect for text
12:42:10 <ndm> kolmodin: i did once, but the addon i had for it was a bit clunky so never got the hang of it
12:42:18 <xerox> Prelude Data.Array.ST> runSTArray (newListArray (0,6) "paolino")
12:42:18 <xerox> array (0,6) [(0,'p'),(1,'a'),(2,'o'),(3,'l'),(4,'i'),(5,'n'),(6,'o')]
12:42:19 <kolmodin> ndm: a always end up with 20 windows and cant manage it.. I like the idea of having different desktops for different things
12:42:24 <ndm> i want Mac desktops and hit things to flip between them
12:42:25 <TuringTest> glguy: STArrays have little to do with pointers.   STUArrays are wrappers around a pointer
12:42:37 <ndm> i use a double row for the taskbar at the bottom, 20 is feasible with that
12:43:33 <kolmodin> I did that too, but it doesn't compare to grouping a few related apps in a desktop
12:43:43 <paolino> > array (0,6) [(0,'p'),(1,'a'),(2,'o'),(3,'l'),(4,'i'),(5,'n'),(6,'o')] :: STArray Int Char
12:43:44 <lambdabot>   Not in scope: type constructor or class `STArray'
12:43:45 <kolmodin> ndm: but it's a habit, I guess
12:44:15 <glguy> paolino: STArrays use: newArray
12:44:18 <glguy> and newListArray
12:44:39 <TuringTest> paolino: See "Data.Array.MArray" for the api
12:45:29 <xerox> runSTArray (do {a <- newListArray (0,6) "paolino"; mapIndices (0,6) (\n -> (n + 2) `mod` 7) a})    ==>    array (0,6) [(0,'o'),(1,'l'),(2,'i'),(3,'n'),(4,'o'),(5,'p'),(6,'a')]
12:47:33 <bd_> ?paste
12:47:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:47:59 <hpaste>  bd_ pasted "STArray example for paolino" at http://hpaste.org/377
12:48:25 <bd_> ST is ugly :)
12:49:02 <shaleh> anyone know of a nice example using something like wxhaskell?
12:49:22 <paolino> what's that s around ?
12:49:35 <ndm> shaleh: is Gtk2Hs enough like wxhaskell?
12:49:38 <shaleh> beyond darcs I haven't seen many released haskell apps not intended for haskell coders
12:49:45 <shaleh> ndm: I suppose (-:
12:49:55 <bd_> paolino: s is the state variable. It's the trick behind how ST isolates the mutable state
12:50:03 <bd_> paolino: basically, nothing which uses s in its type can escape the ST monad
12:50:04 <Binkley> shaleh: well, there's pugs, that's not exactly intended for haskell coders :-)
12:50:07 <ndm> shaleh: there are plenty of examples on teh gtk2hs home page, and in the install package
12:50:20 <bd_> paolino: with the exception that runSTArray will cast such an array
12:50:40 <shaleh> right, but has anyone written a "real world" program and released it? I have seen the demo calculators and the like
12:50:46 <bd_> paolino: runST for example has type: runST :: (forall s. ST s a) -> a; the forall means that no matter what type s is instantiated, it must return the same type a
12:51:06 <Binkley> shaleh: you're looking for a "real world" program that also has a GUI, in particular?
12:51:21 <glguy> All programs use IO and therefore use RealWorld#
12:51:22 <shaleh> Binkley: preferably, but GUI not required
12:51:28 <ndm> shaleh: there was a wxhaskell paper on Blobs
12:51:33 <bd_> paolino: thus if you try to do runST (newSTRef 42), that'll try to do (forall s. ST s (STRef s Int)) -> STRef s Int, which is illegal, because s in the return value will change as the argument s changes
12:51:37 <shaleh> ndm: link?
12:51:53 <ndm> shaleh: http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.cs.uu.nl%2Fdazzle%2Ff08-schrage.pdf&ei=TDvKRfPJAp-GQMHnnfAG&usg=__6qx3HI8Wrbafh3CeFuXqB_xq3SE=&sig2=qJmkTJpjgUgSdq8LDxPQdQ
12:51:56 <lambdabot> http://tinyurl.com/2267sr
12:52:12 <ndm> fucking google! rewriting my u rls to track me!
12:52:13 <ndm> www.cs.uu.nl/dazzle/f08-schrage.pdf
12:52:22 <TuringTest> paolino: all ST code exists runs (in analogy with IO) in the ST monad.  One difference is that runST :: forall s . ST s a -> a lets you take the "a" value out of the ST monad, making it a pure value.  But the "s" is only on the left-hand-side, so you can prove that no type tagged with "s" can exist on the right-hand-side.  Thus the mutable bit STRef and STArray data cannot escape to runST.
12:52:55 <xerox> paolino: I've got something
12:52:56 <shaleh> ndm: thanks, will read through thatr
13:00:43 <nomeata> goodle doesnt do that always, do they? is it just random probes?
13:01:34 <ndm> nomeata: always, for me, since i'm logged in
13:02:25 <paolino> xerox ,what is something ?
13:02:50 <paolino> uhm (ST s) has no tranformer
13:02:55 <xerox> paolino: hehe I have got a problem, my random numbers are too random.
13:04:41 <sjanssen> paolino: you can't write a transformer version of ST -- it'd break referential transparency
13:05:20 <mauke> IOT!
13:05:37 <chessguy> what is ST?
13:05:49 <glguy> an IO monad without all the IO
13:06:05 <chessguy> ...
13:06:10 <mauke> so it's just a monad?
13:06:19 <glguy> all monads are "just monads"
13:06:48 <emu> if IO is considered World -> (World, a) then ST is forall s. s -> (s,a)
13:06:49 <sjanssen> chessguy: a monad that has mutable references and arrays, but has a "run" function that is referentially transparent
13:07:05 <rahikkala> Some monads are more monadic than others
13:07:14 <TuringTest> chessguy: You pass in normal Haskell values and then use ST to allocate mutable memory, then you initialize and play with it, then you put it away and return a normal Haskell value.
13:07:15 <rahikkala> (ref. strictness issues in IO, ListT)
13:07:32 <glguy> rahikkala: sure, like QuickCheck's monad doesn't follow all the monad laws to the letter
13:07:45 <glguy> it's less of a monad in my eyes ;)
13:08:27 <TuringTest> ST lets you implement algorithms that are much more efficient with mutable memory used internally.  But the whole "thread" of computation cannot exchange mutable state with the outside world, it can only exchange immutable state.
13:09:43 <DapperDan2> TuringTest: I'm looking at the API doc for ST and it says none of that. It says "provides support for strict state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads." but I think your explanation is a lot better :)
13:09:46 <TuringTest> Haskell's type system is used to prove that no mutable state that gets allocated during runST is part of the value that runST returns.
13:09:57 <emu> in-place qsort within ST monad: http://hpaste.org/274
13:10:20 <TuringTest> DapperDan2: documentation by paper references is for library implementors, not library users.
13:10:34 <DapperDan2> is there a page on the Haskell wiki for ST where I could paste in this stuff?
13:10:55 <ndm> @wiki ST
13:10:55 <lambdabot> http://www.haskell.org/haskellwiki/ST
13:11:08 <ndm> DapperDan2: if there isn't, you should create one!
13:11:24 <sjanssen> DapperDan2: I don't think there is -- but it'd be great if you'd start one
13:11:29 <emu> Section 7 of the Haskell History paper mentions ST
13:11:34 <TuringTest> DapperDan2: The wiki is very flat -- there is no strong hierarchy in which to place things.
13:11:58 <TuringTest> DapperDan2: You could add to section 8.1 of http://haskell.org/haskellwiki/A_brief_introduction_to_Haskell
13:11:59 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki
13:12:06 <DapperDan2> http://www.haskell.org/haskellwiki/Control.Monad.ST. Work in progress.
13:12:09 <lambdabot> Title: Control.Monad.ST - HaskellWiki
13:12:12 <glguy> ?seen dons
13:12:13 <lambdabot> dons is in #haskell, #happs, #ghc, #haskell.hac07 and #haskell-overflow. I last heard dons speak 7h 56m 21s ago.
13:12:19 <glguy> ?localtime dons
13:12:21 <lambdabot> Local time for dons is Thu Feb  8 08:09:51 2007
13:12:32 <glguy> time to wake up dons!
13:12:39 <TuringTest> glguy: nearly time...
13:12:42 <dons> ?yow!
13:12:43 <lambdabot> Spreading peanut butter reminds me of opera!!  I wonder why?
13:12:47 <glguy> it worked!
13:12:48 <DapperDan2> URL for the log of this channel?
13:12:54 <TuringTest> dons: hi
13:12:54 <glguy> DapperDan2: /topic
13:12:55 <dons> DapperDan2: in the topic
13:12:57 <dons> ?logs <--
13:12:58 <lambdabot> <-- not available
13:12:59 <Binkley> http://tunes.org/~nef/logs/haskell
13:13:02 <lambdabot> Title: Index of /~nef/logs/haskell
13:13:03 <dons> ?where ogs
13:13:04 <lambdabot> I know nothing about ogs.
13:13:12 <glguy> dons: why do you always have to contradict my reddit rants? :)
13:13:14 <dons> TuringTest: so the regex-dna is ready to go?
13:13:22 <dons> glguy: cause you get all antsy-ranty ;)
13:13:26 <Binkley> do you have a link for this reddit rant?
13:13:33 <glguy> dons: that doesn't mean I'm *wrong*
13:13:36 <TuringTest> dons: I would prefer you to have a look at it first.
13:13:44 <Cale> reddit rants?
13:13:49 <TuringTest> dons: As a sanity check.  I did the update alone.
13:13:50 <glguy> short little ones
13:13:51 <dons> TuringTest: ok. will do.
13:13:58 <dons> TuringTest: then i should submit it?
13:14:01 <TuringTest> yes
13:14:17 <nomeata> ?logs Variables are in Haskell
13:14:17 <lambdabot> Variables are in Haskell not available
13:14:19 <TuringTest> dons: It is ooodles faster
13:14:26 <glguy> we used to have a ?last
13:14:40 <nomeata> ?logs Answers
13:14:41 <lambdabot> Answers not available
13:14:48 <TuringTest> dons: less than 2% of the time was in the GC.
13:14:57 <nomeata> ?logs Sorry, by boss is
13:14:58 <lambdabot> Sorry, by boss is not available
13:15:05 <nomeata> ok ok, I stop :-)
13:15:17 <TuringTest> dons: I estimate we will be 1-2 places behind Perl
13:15:31 <dons> ok.
13:15:33 <TuringTest> (Which is still not fantastic)
13:16:22 <dons> regex-dna and the last couple of Double-based entries are the only ones with still poor performance, so anything is better
13:17:10 * TuringTest nods
13:17:36 <TuringTest> I used a mix of Strict ByteString and List of Strict ByteString
13:18:12 <hpaste>  (anonymous) pasted "No" at http://hpaste.org/378
13:18:47 --- mode: ChanServ set +o glguy
13:19:01 --- mode: glguy set -b master_baiter!*@*
13:19:01 <TuringTest> On my PPC box, Perl is 19 seconds, and haskell is 26.5 seconds
13:19:06 --- mode: glguy set -o glguy
13:19:11 <TuringTest> (on regex-dna)
13:19:14 <dons> TuringTest: yeah, that's a good thing to do
13:19:26 <chessguy> sigh.
13:19:30 <dons> since the strict ones get optimised very nicely, and the lazy ones help keep memory usage down
13:19:52 <chessguy> i'm at the end of the 4th haskell lecture, each an hour and a half long, and the guy has covered like the first 2 pages of yaht
13:19:57 <TuringTest> dons: But I did B.concat after removing the header lines and newlines.  It seemed a good tradeoff.
13:20:22 <dons> yeah ok.
13:20:28 <dons> you could just read the lot, and B.copy
13:20:30 <TuringTest> chessguy: Maybe he is just lazy?
13:20:34 <dons> (see the knuc entry)
13:20:46 <chessguy> no, he's just excruciatingly detailed
13:20:47 <TuringTest> dons: I will go look
13:21:12 <TuringTest> chessguy: So you don't need inference to understand him?
13:21:36 <chessguy> indeed
13:22:04 <chessguy> i think it'll be good, once he actually gets into interesting stuff. he's just taking his grand old time doing so
13:22:05 <DapperDan2> I put some stuff in http://www.haskell.org/haskellwiki/Control.Monad.ST . Feel free to add if I missed anything.
13:22:06 <lambdabot> Title: Control.Monad.ST - HaskellWiki
13:23:30 <DapperDan2> Is Data.Array.ST a module that uses the ST monad to provide in-place/faster array ops?
13:24:41 <dons> DapperDan2: yeah
13:24:47 <dons> the IO Array lib is just sugar over ST
13:24:55 <dons> ST is a monadic abstraction on to mutable memory
13:25:02 <glguy> Data.Array.ST.Unboxed for great justice!
13:25:15 <DapperDan2> is there a cross-reference where I can find all the uses of the ST monad?
13:25:29 <glguy> ST is for mutable references and arrays
13:25:33 <DapperDan2> in standard libraries say
13:25:39 <dons> well, you can grep the src
13:25:42 <dons> ?darcs
13:25:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:25:48 <dons> ?source Data.Array
13:25:49 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array.hs
13:25:52 <glguy> ?docs Data.STRef
13:25:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html
13:27:00 <DapperDan2> it strikes me that ST is like a lexical scope, where all the variables/state disappear when the function returns.
13:27:14 <TuringTest> DapperDan2: Precisely
13:27:46 <DapperDan2> i'll add that in to the wiki page as well so.
13:28:01 <dons> these CAL guys should have just written a Java backend for ghc :/
13:28:51 <Binkley> because GHC needs a slower backend?
13:28:58 <dons> yeah!
13:29:00 <Binkley> heh
13:29:03 <Binkley> IT'S NOT SLOW ENOUGH
13:29:12 <dons> well, they want community support for a Java haskell-ish language
13:29:19 <dons> and its not going to happen if they fork and write their own tools
13:29:37 <kolmodin> early and often: syntax support for cabal in vim: http://haskell.org/~kolmodin/code/vim/syntax/cabal.vim
13:29:46 <Binkley> what would a "Java haskell-ish language" look like?
13:29:47 <dons> nice!
13:29:56 <dons> Binkley: have you seen the CAL posts this year and last on haskell@
13:29:57 <ndm> yeah, i spotted that announcement - had to scan it twice looking for where the haskell relevance was
13:30:06 <dons> ndm, the syntax? :)
13:30:13 <kolmodin> hah
13:30:24 <ndm> dons: i didn;t follow the link, just read the announcement
13:30:41 <TuringTest> I read the CAL docs...very close to "just Haskell"
13:30:47 <emu> does anyone have a pointer to a nice formal description of the deterministic finite automata simplification algorithm?
13:30:50 <glguy> Java / Haskell-ISH language like Scala?
13:30:54 <Binkley> dons: haven't been following, do you have a link? (or something that would turn it up?)
13:31:06 <TuringTest> http://resources.businessobjects.com/labs/cal/cal_for_haskell_programmers.pdf is a good overview
13:31:09 <lambdabot> http://tinyurl.com/284kgm
13:31:16 <paolino> bd_: I don't want to to run the State monad
13:31:17 <paolino> shuffle :: (MonadState g m,RandomGen g) => [a]        -- ^ list to shuffle
13:31:17 <paolino>                                                                         -> m [a]   -- ^ shuffled list
13:31:17 <paolino> is it possible ?
13:31:22 <Binkley> emu: Sipser's _Intro to the Theory of Computation_
13:31:25 <Binkley> if you don't mind dead trees
13:31:28 <dons> http://www.haskell.org/pipermail/haskell/2007-February/019094.html
13:31:31 <lambdabot> Title: [Haskell] ANN: Open Quark Framework for Java released as Open Source, http://tinyurl.com/28fzja
13:31:37 <Binkley> ah, yes, ok, I saw that
13:31:39 <emu> Binkley: i have that in front of me
13:31:41 <Binkley> didn't know what to make of all the business-speak
13:31:46 <ndm> i first thought it was spam
13:31:50 <Binkley> heh, yes
13:31:53 <bd_> paolino: You'd need to use newStdGen or similar in the MonadRandom
13:31:57 <dons> they wrote their own haskell, CAL, compiled to JAva
13:31:59 <bd_> paolino: since ST can't be used as a STT
13:32:09 <dons> but its not quite haskell
13:32:12 <tom__> hi all
13:32:21 <kolmodin> I'd love feedback on the syntax
13:32:22 <dons> hey tom__ . welcome!
13:32:29 <kolmodin> but for now I have to sleep, g'night!
13:32:36 <glguy> hello
13:32:43 <hpaste> hello
13:32:49 <tom__> I need to access a serial port from Haskell, can anyone point me in the right direction?
13:33:03 <emu> Binkley: unless i'm missing it, there is no simplification algorithm in here
13:33:17 <Binkley> emu: hmm, ok. I don't have the book in front of me, but I would've thought it would have it
13:33:27 <Binkley> sorry to be unhelpful :\
13:33:40 <TuringTest> emu: What are you using a DFA for?
13:33:58 <DapperDan2> can anybody answer a question about persistent data structures as mentioned in the Okasaki Purely Functional Data Structures book.
13:33:59 <glguy> tom__: I don't know that there is a platform independent / standard way to do that
13:34:02 <emu> an implementation of DFAs =)
13:34:19 <dons> tom__: just open up the device and write to it?
13:34:25 <TuringTest> emu: ( I used one for the regex-tdfa package for Posix regular expressions in Haskell)
13:34:27 <tom__> I'll settle for something that works on Linux
13:34:28 <dons> there's no standard library.
13:34:41 <dons> i'd use Data.ByteString to write bytes out directly into a Handle attached to the device
13:34:45 <DapperDan2> i wonder can they be used to implement Undo.
13:34:46 <emu> yes, i have a simple regex->NFA->DFA and back
13:34:52 <dons> failing that, use a C ffi import to get at the device
13:34:52 <emu> not for real work
13:34:59 <tom__> I can do that? (I've not programmed a serial port in linux before)
13:35:11 <tom__> cool, thanks
13:35:21 <sjanssen> DapperDan2: sure, you can just keep track of each old copy of the data structure
13:35:24 <dons> afaik, yeah. but you'll want to read up on how to do serial port programming first :)
13:35:26 <emu> just for investigating properties of regular languages
13:36:01 <DapperDan2> sjanssen: what kind of data structure would i use, e.g. in a text editor for a text buffer. or if you have another example.
13:36:02 <TuringTest> ?google "minimize dfa"
13:36:04 <lambdabot> http://www.cs.duke.edu/csed/jflap/new/DOCS/gui.minimize.MinimizePane.html
13:36:04 <lambdabot> Title: Minimize DFA
13:36:46 <emu> i've got some decent informal descriptions (lecture notes etc) was just wondering if anyone had a good formal one
13:36:58 <sjanssen> DapperDan2: a 2-3 finger tree might work nicely for a text editor
13:36:59 <DapperDan2> would i push each old copy onto a stack, and then just pop them as i undo?
13:37:18 <sjanssen> DapperDan2: yeah, you'd use a stack
13:37:25 <sjanssen> maybe two stacks if you want redo
13:37:29 <DapperDan2> yeah
13:37:37 <glguy> look for MonadUndo :)
13:37:47 <DapperDan2> sounds pretty cool, like i don't think anybody has done it that way before
13:37:56 <DapperDan2> at least not that i've heard of
13:38:10 <sjanssen> you might have to be careful about memory use
13:38:31 <DapperDan2> i'm thinking of a MVC GUI app where the model is a haskell program, and the view/controller are in cocoa.
13:38:34 <TuringTest> emu: I did not use much in the way of "formal" documentations.
13:39:17 <dons> TuringTest: looking at your code now.
13:39:27 <dons> and giving it a clean up
13:39:31 <DapperDan2> sjanssen: a model like that should make it easier to present a 'history window' like in dreamweaver.
13:40:01 <DapperDan2> or even fork history, if you rewind through some steps and then 'try something different'
13:40:06 <TuringTest> dons: I got fatigued doing all the "change a tiny bit and recheck the speed" iterations.
13:40:16 <sjanssen> DapperDan2: yeah, I think it'd be fun to write a text editor with a persistent data structure
13:40:31 <TuringTest> ?where yi
13:40:32 <DapperDan2> it 'feels' like this is something a functional language would be better at. as in this would play to its strengths.
13:40:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
13:40:34 <glguy> vim does fork history I beleive
13:40:35 <sjanssen> I wonder if yi's editor structures could use a rewrite . . . :)
13:41:44 <TuringTest> dons: Be careful when doing small cleanup tasks -- some simple things reduced the performance for no good reason.
13:41:49 <dons> ok
13:42:23 <dons> yeah, off the bat it runs 4x faster than the old version
13:42:26 <dons> good ork!
13:43:07 <TuringTest> thanks
13:43:25 <kep> dons did you get yesterdays link to the acme editor ?
13:44:14 <dons> TuringTest: space usage is way down too!
13:44:32 <TuringTest> dons: I hammered the space usage until the GC got really really bored.
13:44:32 <dons> kep, I saw the link. sorear and jyp are the main yi hacker these days though :)
13:44:38 <dons> great :)
13:44:42 <vincenz> dons: so any news on that code?
13:44:44 <dons> yeah, just ran through the test data in 22s
13:44:58 <dons> vincenz: so i rewrote the whole thing very carefully, and the Core code looks great to me.
13:45:11 <dons> and we get ... 12x slower
13:45:13 <vincenz> dons: are we talking about mandel?
13:45:32 <dons> now Isaac over at the shootout sent me some clues for what could be going wrong (differences in the shootout box setup)
13:45:39 <dons> so i'll need to investigate
13:45:40 <dons> yeah, mandel
13:45:51 <vincenz> hmm
13:46:02 <vincenz> dons: was my version quicker??
13:46:24 <kep> dons i hope they read that :)
13:46:30 <dons> can you check it against the new version? (the one on the shootout now)
13:46:44 <vincenz> link?
13:46:49 <dons> ?shootout
13:46:50 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
13:46:55 <vincenz> thx
13:48:25 <dons> make sure you test it with large enough data, i.e. 10-20s runtime
13:48:53 <vincenz> dons: yeah, mine is faster
13:49:02 <vincenz> dons: but if your new one is faster than your old one
13:49:08 <vincenz> dons: I can reapply my techniques to your new one
13:49:13 <vincenz> let me experiment on that
13:49:17 <dons> its a fair bit faster. so yeah, do that.
13:49:30 <vincenz> dons: it's not really fair bit faster..
13:49:36 <augustss> we're doing better
13:49:38 * vincenz gets the same user time, better real time
13:49:39 <dons> well, 12x v 20x :)
13:49:44 <glguy> whoa , GHC was in last place for regex-dna?
13:49:45 <dons> yeah me too.
13:49:51 <dons> nut look at the shootout times
13:49:59 <TuringTest> glguy: [Char] is slow
13:50:24 <TuringTest> glguy: I have given dons a ByteString conversion that is faster
13:50:34 <glguy> like... 10x faster?
13:50:37 <vincenz> dons: no really, I don't get such significant differences
13:50:48 <dons> i know! neither do I here. like 1%
13:50:51 <TuringTest> glguy: like 1.3 to 1.4 times the time that Perl takes
13:50:55 <dons> but its a huge speedup on the shootout...
13:50:56 <vincenz> dons: I mean with your new version!
13:50:59 <vincenz> oh!
13:51:06 <vincenz> dons: ok
13:51:08 <vincenz> gimme a bit
13:51:15 <dons> compare the runing times on the shootout box
13:51:15 * vincenz is reapplying his techniques to your new one
13:51:17 <vincenz> should go even faster
13:51:35 <glguy> the TCL solution is beautiful :)
13:51:54 <dons> glguy: good regex libs. it all comes down to which regex libs you bind to
13:52:06 <shaleh> does the Monad Reader have a more up to date website? or did it die?
13:52:14 <glguy> which lib does tcl bind, which does haskell?
13:52:18 <dons> ?where TMR
13:52:18 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
13:52:20 <TuringTest> The Haskell entry has no bindings -- it has to do it all itself. Luckily this is easy in Haskell.
13:52:26 <dons> shaleh: the atest edition came out last week
13:52:42 <TuringTest> glguy: TCL has a custom regexp engine as part of the TCL language.
13:52:49 <shaleh> dons: the haskell wiki's last update was like 2005
13:53:10 <glguy> maybe we need to bind to tcl ;)
13:53:31 <sjanssen> shaleh: check again, the most recent update is 10:45, 5 February 2007
13:53:38 <TuringTest> glguy: I have regex-pcre bindings to libpcre which does Perl regular expressions.
13:53:49 <TuringTest> glguy: But no such library on the shootout.
13:54:14 <shaleh> sjanssen: mmutable page (last edited 2005-10-12 07:05:20 by c-24-17-241-135)
13:54:22 <shaleh> http://www.haskell.org/hawiki/TheMonadReader
13:54:24 <lambdabot> Title: TheMonadReader - The Haskell Wiki
13:54:25 <shaleh> did it move?
13:54:55 <Binkley> shaleh: http://www.haskell.org/haskellwiki/The_Monad.Reader
13:54:57 <lambdabot> Title: The Monad.Reader - HaskellWiki
13:55:20 <Binkley> the new wiki is under haskellwiki, not hawiki
13:55:23 <Binkley> hawiki is the old one
13:56:00 <Botje> ?index newListArray
13:56:01 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
13:56:43 <sjanssen> is it fairly easy to modify hawiki's style/layout?  I want "THIS IS THE LEGACY WIKI" in big red letters at the top of every hawiki page
13:57:26 <xerox> *Shuffle Control.Monad> (shuffle "paolino" `fmap`) `fmap` (replicateM 10 newStdGen)
13:57:27 <xerox> ["piolano","plaonio","poailon","lpoiona","oilapon","looapin","aloiopn","ionapol","pliaono","nlapooi"]
13:57:30 <xerox> yeehaa!
13:57:43 <shaleh> Binkley: thanks, google finds the old one when you type in "monad reader"
13:57:43 <gvdm_other> well google is stupid, come on people, knowledge of the masses and all that
13:58:01 <chessguy> heh. 7 hours of lecturing about haskell, and he's finally talking about polymorphism
13:58:06 <Binkley> shaleh: well, yeah, someone should really make it so the old wiki pages have some pointers to the new ones
13:58:07 <shaleh> sjanssen: that would rock
13:58:18 <Binkley> like what sjanssen said 5 lines up :-0
13:58:31 * shaleh liks wiki books, but hates having to be online to read them
13:59:03 <Gwern> shaleh: get the printable versions then
13:59:22 <Gwern> dunno if the haskell wiki does, but I'm fairly sure wikibooks does
13:59:46 <Binkley> oh, heh, hey, Gwern
13:59:50 <Binkley> I'm SparsityProblem on wikipedia
14:01:01 <Gwern> Binkley: you've seen me around?
14:01:16 <Binkley> Gwern: on the GHC article. if that was you, that is. at least, someone with the same username :-0
14:01:30 <Gwern> oh. sorry about that. none too good with the names :)
14:01:41 <Binkley> heh, that's ok
14:01:54 <Binkley> back when i was a more prolific wikipedia editor, I wouldn't have remembered anything anyone did
14:01:56 <chessguy> is the term as-hoc polymorphism the same as overloading?
14:01:58 <Binkley> nowadays I just focus on a few articles
14:02:07 <Binkley> chessguy: overloading is one specific form of ad-hoc polymorphism
14:02:51 <Gwern> Binkley: I have a good memory for people who were around back in '04 and '05 - they were my generation so to speak. but these youngsters who grow up wiht a wikipedia where there's always been anon-page creation disabled - I don't know'em
14:03:16 <chessguy> Binkley, what would be an example of ad-hoc polymorphism in haskell?
14:03:54 <Binkley> Gwern: Heh. Well, back in the day -- where "the day" is fall 2005-spring 2006, SO LONG AGO, I was using the name Catamorphism
14:03:58 <Gwern> maybe he's thinking of operators like +?
14:04:19 <Gwern> Binkley: that does ring a bell, actually. think I'll look up the contribs and see where I saw you
14:04:36 <Binkley> chessguy: well, you can think of anything involving type classes in haskell as being "ad hoc polymorphism"
14:04:36 <Gwern> 'course, I was using a different nick back then too
14:04:50 <Binkley> except that type classes make it less ad hoc, as the paper title goes
14:05:06 <Binkley> Gwern: yeah, I left after a huge cluster-you-know-what over my RfA
14:05:09 <Binkley> and didn't edit for a while
14:05:13 <Binkley> and then came back under a new name to avoid all the drama
14:05:25 <vincenz> dons: you think it's a good idea to do fromIntegral each loop ?
14:05:58 <hi2> hi sam you dere
14:06:04 <hi2> ** here
14:07:10 <hi2> I think haskell is one of the highest level and most complcated languges ive seen
14:07:25 <Gwern> hi2: I'm sure there are higher-level languages
14:07:35 <Gwern> I often find myself wondering about Qi's type system
14:07:54 <augustss> How does one measure height?
14:08:04 <TuringTest> hi2: The truth of your statement is knowable only to those who know what you have seen...
14:08:17 <TuringTest> augustss: With a barometer
14:08:59 <Binkley> I thought Haskell was tall, but then I realized it just waved its arms around a lot
14:09:03 <augustss> aha!
14:09:07 <Gwern> Binkley: hey, I just remembered. it was your User:Catamorphism/Wikipedia Song
14:09:18 <Binkley> Gwern: haha, yes. I can't believe someone else read that :-)
14:09:32 <Gwern> (not as good as, say, A Modern Wikipedian or Hotel Wikipedia, but I thought it was one of the better ones)
14:09:36 <Binkley> heh
14:09:47 <Binkley> I've read "A Modern Wikipedian", but not the other one
14:10:04 <Gwern> Binkley: think parody of Hotel California
14:10:14 <Gwern> y'can find it in meta:category:humor
14:10:23 <hi2> just a bit ago I was testing 15 Windows irc clients to see wich one would best soot my own webserver's irc's needs ( irc : srv256.homelinux.net ) and I pituclulary found that Bersirc is the best;
14:11:32 <hi2> I have been having some problems trying to admin the irc if any one has any sujestions meet me there #test
14:11:43 <Binkley> Gwern: heh, yeah, saw it, it's pretty good
14:12:07 <Binkley> I have no pretentions of being good at filk, I just have a good time writing it :-)
14:15:24 <dons> vincenz: well, it avoids passing Doubles all the way down (Clean does this)
14:15:36 * vincenz hmms
14:15:40 <vincenz> damn
14:15:46 <vincenz> too many funcparams and your func slows down
14:20:15 <dons> ?users
14:20:16 <lambdabot> Maximum users seen in #haskell: 322, currently: 302 (93.8%), active: 45 (14.9%)
14:24:29 <gvdm_other> vincenz: how is too many? 4? 5?
14:24:38 <gvdm_other> 5 i would think...
14:24:51 <vincenz> 7
14:25:47 <gvdm_other> i remember in comp203 we did functions in assembly and there was a point where you couldn't store the arguments in registers anymore, you had to pass a memory address
14:26:08 <gvdm_other> then again, this was ancient MIPS
14:26:21 <Botje> ?src replicateM
14:26:22 <lambdabot> replicateM n x = sequence (replicate n x)
14:26:24 <Binkley> well, every machine has a limited number of registers
14:26:29 <gvdm_other> not functions, procedures...
14:26:30 <a-priori|work> that number depends on the architecture
14:26:31 <gvdm_other> heh
14:27:09 <hyrax42> gvdm_other: usually on the "stack"?
14:27:14 <a-priori|work> for x86, it's no more than 5-6, but maybe less
14:28:02 <nomeata> ?src seq
14:28:03 <lambdabot> Source not found. stty: unknown mode: doofus
14:28:05 <hyrax42> yeah asm on x86 must be a headache
14:28:34 <nomeata> lambdabot: doofus yourself!
14:28:41 <dons> we've not got many registers to play with, and gcc steals even more
14:29:24 <a-priori|work> yeah, like if you're generating PIC (position-independent code), it reserves one to store the relocation address
14:29:35 <a-priori|work> and ebp is also always used for the stack frame
14:30:13 <vincenz> dons: eh...
14:30:25 <vincenz> dons: my original pasted version is faster than your new version
14:30:30 <gvdm_other> CELL! goddamit, we need an over-bloody-haul of the architecture. x86 is broken, having learnt both MIPS and x86 in university briefly, i very quickly saw why people called x86 broken and ugly
14:30:32 <vincenz> dons: and my new version based on your pasted version is also faster
14:30:33 <a-priori|work> there's a reason very few people do x86 assembly :)
14:30:37 <vincenz> dons: but between the two it's hard to tell
14:30:45 <vincenz> dons: one beats on user, one on real time
14:30:55 <dons> great!1
14:30:57 <Binkley> well, go convince intel of that :-)
14:31:10 <augustss> x86 is broken, but it's also the fastest you can get :(
14:31:17 <earthy> x86 just has massive resources invested into it
14:31:18 <dons> vincenz: have you extended it out to say, n=5000 ?
14:31:19 <Binkley> and it's what everyone has on their desktop
14:31:20 <Binkley> or lap
14:31:20 <a-priori|work> personally, I think they should expose the microcode
14:31:28 <a-priori|work> internally, it's pretty much a RISC
14:31:33 <earthy> horror of horrors no
14:31:40 <dons> TuringTest: old code, 53.968s, new code, 7.124s :)
14:31:49 <vincenz> dons: I only test at 5k
14:31:50 <dons> TuringTest: I'll submit it now
14:31:53 <TuringTest> dons: :)
14:31:53 <augustss> i would not expose the microcode
14:31:55 <earthy> then you get into the mess that is called IA64
14:32:00 <gvdm_other> as it bloody should be, RISC is easier on the compilers
14:32:07 <dons> vincenz: ok. hpaste it. i can then investigate, and submit :-)
14:32:14 <vincenz> dons: both of em?
14:32:23 <dons> whichever is faster/allocates less
14:32:29 <earthy> b'sides, x86-64 actually isn't all that bad
14:32:36 <earthy> afaiui
14:32:45 <dons> vincenz: put 'em both on hpaste if you're unsure
14:32:50 <earthy> decent numbers of registers and such
14:32:53 <gvdm_other> and no people code assembly by hand anymore (apologies to my friend who coded a PIC micro controller)
14:32:58 <hpaste>  vincenz pasted "version A" at http://hpaste.org/379
14:33:12 <hpaste>  vincenz annotated "version A" with "version B" at http://hpaste.org/379#a1
14:33:20 <augustss> earthy: yes, a much better number of registers :)
14:33:28 <dons> thanks vincenz
14:33:34 <dons> i'l just put up the regex-dna entry
14:33:35 <augustss> but a few more would be even better
14:33:37 <dons> then have a look
14:33:57 <augustss> maybe x86-128 will have more registers ;)
14:34:03 <a-priori|work> haha
14:34:09 <a-priori|work> I hope such a beast never sees the light of day
14:34:14 * earthy thinks there won't be an x86-128. ;)
14:34:22 <gvdm_other> my laptop is running 256 bits :P (transmeta efficeon)
14:34:27 <Binkley> what, because the world will have been destroyed by nuclear war first?
14:34:32 <a-priori|work> probably by then we'll be using quantum computers or some other crazy shit
14:34:37 <gvdm_other> of course, it then emulates a p4, but what the hell
14:34:41 <Binkley> or cybernetic implants in our skulls
14:34:42 <dons> earthy: you know, ghc has stubbed-in support for Word128 native in its code gen :-)
14:34:45 <dons> just in case ...
14:34:47 <augustss> gvdm_other: so did my old laptop.  until it died :(
14:34:55 <earthy> apple has shown that given a good base porting from hardware architecture to hardware architecture is doable
14:35:17 <earthy> dons: scary, that. :)
14:35:24 <augustss> earthy: "apple has shown"?  it has been done long before that
14:35:30 <gvdm_other> earthy: its been incredibly possible since C
14:35:32 <dons> > maxBound :: Word128
14:35:34 <lambdabot>  340282366920938463463374607431768211455
14:35:37 * earthy knows it has been possible
14:35:38 <dons> > maxBound :: Word256
14:35:41 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639935
14:35:45 <Binkley> > maxBound :: Word512
14:35:48 <dons> should be enough bits for anyone!
14:35:48 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
14:35:49 <earthy> possible and economically feasible are two different things
14:35:54 <Binkley> > maxBound :: Word1024
14:35:55 <siti> woah, when's the 256bit machines coming out?
14:35:57 <earthy> I tried to imply the latter
14:35:58 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
14:36:00 <Binkley> heh
14:36:01 <earthy> (but I'm slightly tired)
14:36:02 <Binkley> I think I'll stop now
14:36:04 <dons> siti, lambdabot has a dedicated machine
14:36:06 <augustss> We have Word1024?
14:36:10 <Binkley> apparently so!
14:36:17 <dons> augustss: from the crypto ib
14:36:19 <dons> lib.
14:36:26 * Syzygy- droooooools
14:36:27 <gvdm_other> earthy: no money on linux (well, read it how you want) and that's running on any major architecture you can care to name
14:36:30 <augustss> > maxBound :: Word513
14:36:31 <lambdabot>   Not in scope: type constructor or class `Word513'
14:36:33 <Syzygy-> This makes me want to poke at crypto in Haskell!
14:36:37 <dons> should go into base, imo.
14:36:44 <earthy> gvdm_other: but binaries don't port on linux
14:36:45 <dons> Word64..Word4096, iirc
14:36:52 <augustss> dons: yes!  I've nedded bigger than 64
14:36:52 <earthy> whereas they do with Mac OS X
14:36:54 <dons> and you can roll your own custom multiples
14:36:56 <Binkley> > maxBound :: Word8192
14:36:56 <lambdabot>   Not in scope: type constructor or class `Word8192'
14:36:59 <Binkley> darn
14:37:05 <Syzygy-> > maxBound :: Word4096
14:37:10 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
14:37:21 <TuringTest> > minBound :: Word4096
14:37:25 <lambdabot>  0
14:37:27 <gvdm_other> earthy: there is this really cool thing called free software, it means you can compile to any architecture you care to
14:37:30 <TuringTest> same old, same old
14:37:31 <dons> > maxbound :: LargeWord Word4096 Word4096
14:37:32 <lambdabot>   Not in scope: `maxbound'
14:37:40 <dons> > maxBound :: LargeWord Word4096 Word4096
14:37:41 <lambdabot>      Class `LargeWord' used as a type
14:37:42 <Syzygy-> > (\x -> log x/ log 2) maxBound :: Word4096
14:37:42 <lambdabot>     In the type `LargeWord Word4096 Wor...
14:37:43 <lambdabot>   add an instance declaration for (Floating Word4096)
14:37:46 <gvdm_other> given a compiler that targets it
14:37:48 <augustss> > logBase 2 (fromIntegral (maxBound :: Word4096))
14:37:51 <earthy> (and yes, NeXTStep e.g. already had fat binaries, and I know about pcode and all that ;))
14:37:53 <Syzygy-> > (\x -> log x/ log 2) (maxBound :: Word4096) :: Integer
14:37:53 <lambdabot>  Infinity
14:37:54 <lambdabot>  Couldn't match `Integer' against `Word4096'
14:38:07 <dons> oh, maybe I didn't export the LargeKey constructor
14:38:14 <Syzygy-> > log (maxBound::Word4096) / log 2
14:38:14 <dons> > maxBound :: LargeKey Word4096 Word4096
14:38:15 <earthy> gvdm_other: there is still a large contingent of developers and users that want binary distribution
14:38:15 <lambdabot>   add an instance declaration for (Floating Word4096)
14:38:15 <lambdabot>   Not in scope: type constructor or class `LargeKey'
14:38:27 <earthy> yes, I know about a few solutions to even that problem
14:38:30 <gvdm_other> earthy: i run gentoo ;-)
14:38:37 <augustss> Syzygy-: we have logBase
14:38:37 <gvdm_other> anyway
14:38:39 <dons> TuringTest: btw, squeezed a few more seconds out with unsafeIndex
14:38:41 <earthy> (e.g. plan 9's mounting stuff, nix, some others)
14:38:47 <TuringTest> dons: excellent
14:38:52 <dons> avoids 2 bounds checkes in the inner loop of lexOne
14:38:59 <Syzygy-> ?ty logBase
14:39:01 <lambdabot> forall a. (Floating a) => a -> a -> a
14:39:15 <augustss> > logBase 10 2
14:39:16 <lambdabot>  0.30102999566398114
14:39:19 <earthy> gvdm_other: I never saw the lure of gentoo. got distracted by Haskell. :)
14:39:41 <earthy> anyway, off to bed. the gf seems to have stopped messing around with where things should be.
14:39:53 <Gwern> (bah. debian is all one needs. not to start a distro flamewar or anything)
14:39:55 <TuringTest> dons: Ah...B.unsafeIndex   I should have looked for that.
14:40:26 <earthy> gwern: them's fighting words! :P
14:40:34 <earthy> back to haskell :)
14:40:36 <Binkley> personally, I use VMS for everything
14:40:40 <Binkley> what's this "Unix" nonsense?
14:40:48 <quicksil1er> I use an OS I wrote myself
14:40:51 <TuringTest> dons: did you use unsafeTake and unsafeDrop as well?
14:40:54 <dons> yep
14:40:57 <quicksil1er> and interpret programs on a turing machine simulator in my head
14:41:02 <dons> unsafeIndex was the key improvement
14:41:10 <earthy> binkley: KeyKOS. :)
14:41:33 <Binkley> heh, "EROS" is an excellent acronym
14:42:13 * earthy didn't want to refer to that without context. ;)
14:42:22 <augustss> It seems that ghc needs to have an index analyzer so we don't have to use all the unsafeXXX functions.
14:42:25 <dons> TuringTest: https://alioth.debian.org/tracker/index.php?func=detail&aid=304449&group_id=30402&atid=411646
14:42:27 <lambdabot> http://tinyurl.com/ytlhjh
14:42:29 <Gwern> quicksil1er: did you toggle it into the computer, in octal, using the front panel switches? :)
14:42:32 <dons> submitted, should be updated in the next 10 hours sometime
14:42:58 <Binkley> personally, I like to write my programs by singing into a 300 baud modem
14:43:15 <dons> heh
14:44:02 <quicksil1er> Gwern: no, it's all in my head
14:44:09 <TuringTest> dons: Thanks.
14:44:14 <quicksil1er> Gwern: compiling GHC into turing machine instructions was the hard part
14:44:18 <Gwern> quicksil1er: using a prebuilt computer? I'm disapointed in you
14:44:42 <Binkley> quicksiller: eh, that's nothing
14:44:49 <Binkley> if you ran it with -dcore-lint on, then I'd be impressed
14:45:01 <Gwern> I mean, if you hadn't gotten that computer from your parents, then maybe I'd be impressed
14:46:18 <gvdm_other> so when do we get to see haskell above ocaml and eiffel on http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all ?
14:46:20 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/lepfo
14:46:48 <Gwern> why're you guys so focused on that? all it is bragging rights and maybe some indicators of where GHC isn't optimizing very well
14:46:59 <Gwern> right?
14:47:07 <Binkley> Gwern: other people take it seriously
14:47:15 <Binkley> if your goal is to popularize Haskell, then it's a productive thing to do, I think
14:47:16 <quicksil1er> Gwern: there are some more subtle points about lazy evaluation, I think
14:47:26 <quicksil1er> lazy evaluation has surprising performance effects
14:47:38 <quicksil1er> which are interesting to explore
14:47:46 <Gwern> Binkley: people take it seriously? I think perhaps that's the real problem here...
14:48:01 <Gwern> quicksil1er: are you thinking of any examples in particular?
14:48:02 <Binkley> Gwern: well, if you're trying to get Haskell used in "the larger world..."
14:48:04 <TuringTest> Gwern: It motives us to locate some parts of GHC that *cannot* be tweaked to run well.
14:48:10 <bringert> dons: which one are you hacking on?
14:48:12 <Binkley> people out there in the real world have strange reasons for adopting the languages they do
14:48:18 <Binkley> it's good PR
14:48:19 * bringert is too lazy to check the logs
14:48:36 <Gwern> so we can say, "Haskell: not *that* much worse than C!"?
14:48:38 <Binkley> and TuringTest has a good point, too
14:48:46 <gvdm_other> if you're trying to popularise haskell you can point them there and say, "look its up above these other languages you like!" (maybe java, or whatever)
14:48:46 <Binkley> well, maybe someday Haskell will be better than C :-)
14:48:58 <Binkley> performance obviously isn't all-important
14:49:12 <gvdm_other> but its nice
14:49:16 <TuringTest> Binkley: look at http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
14:49:16 <Binkley> but improving performance does take away one more excuse from the naysayers
14:49:18 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
14:50:11 <Binkley> Heh, cool
14:50:25 <TuringTest> Binkley: That is what dons did with the ByteString code.
14:50:26 <Binkley> haskell is the best *and* the worst :-)
14:50:28 <hpaste> ats
14:50:42 <gvdm_other> go dons!
14:50:45 <hpaste> glguy is cut off from irc!!? sorry for breakage
14:51:05 <dons> bringert: mandelbrot now, just finished with regex-dna
14:51:13 <TuringTest> This benchmark is horrible for GHC: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=all
14:51:15 <lambdabot> Title: n-body benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ..., http://tinyurl.com/og2cd
14:51:32 <dons> bringert: the 3 left that need updating are: nbody, spectral-norm, fannkuch
14:51:55 <TuringTest> GHC cannot work with Double worth a damn.  That is a real shame for computational projects.
14:51:58 <xic> man i'm having a really hard time with MonadTrans
14:52:06 <bringert> it's fun working on that stuff, unfortunately I don't have time right now
14:52:21 <quicksil1er> dons: is the 'compiler' part of hs-plugins GHC? or something else?
14:52:45 <dons> TuringTest: i think we can do better now
14:52:53 <dons> ghc 6.6 is really a better compiler
14:53:04 <Binkley> so what's the big proiblem with nbody? is it the use of lists of Doubles or...?
14:53:07 <dons> but yeah, Doubles are hard
14:53:20 <dons> i'm not sure why they're hard. the generated Cmm is fine
14:53:30 <dons> the Core is certainly ok
14:53:36 <Binkley> well, I would think that unboxing wouldn't be happening
14:53:42 <glguy> I'm
14:53:43 <Binkley> since GHC can't unbox inside non-product types
14:53:43 <dcoutts> dons, so the backend doesn't do well with floating point?
14:53:47 <Binkley> but I don't know how much of a difference it makes
14:53:57 <glguy> I'm telneting in :(
14:54:03 <dons> dcoutts: yeah, missing optimisatoins? missing knowledge about floating point?
14:54:10 <dons> we should ask augustss to sort it out ;)
14:54:23 <dcoutts> heh
14:54:34 <glguy> I tried to add fifo support to hpaste but you probably saw how that turned out
14:54:34 <TuringTest> dons: I was hoping the data parallel haskell project would have to sort it out once they get that far.
14:54:40 <dcoutts> I find it hard to bring myself to care about floating point stuff
14:54:52 <augustss> dons: perhaps when we need it at work, so I have a reason to fix it
14:54:55 <dons> e.g the mandelbrot entry generates perfect Core from what I can tell
14:55:39 <augustss> But what about from Core to machine code
14:55:52 <dons> let me put up some code.
14:56:01 <hyrax42> ?index gmapQ
14:56:01 <lambdabot> Data.Generics.Basics, Data.Generics
14:56:02 <vincenz> dons: any luck?
14:56:10 <hyrax42> ?docs Data.Generics
14:56:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
14:56:16 <TuringTest> dons: Does --via-C show good code?
14:57:04 <dons> vincenz: haven't got there yet. wil do so soon
14:57:11 <vincenz> okies
14:57:49 <augustss> I've never seen assembly code from gcc that makes me happy.
14:57:51 <glguy> someone stumbled into hpaste.org earlier and added a paste "what is this!?"
14:57:58 <augustss> ghc, i mean
14:58:16 <hpaste>  dons pasted "mandelbrot: Haskell level" at http://hpaste.org/381
14:58:40 <hyrax42> > toConstr [1]
14:58:41 <lambdabot>   Not in scope: `toConstr'
14:58:48 <emu> is Data.Set strict? ie. can you write cyclic definitions of sets with it?
14:58:50 <hyrax42> > Data.Generics.toConstr [1]
14:58:51 <lambdabot>   Not in scope: `Data.Generics.toConstr'
14:59:27 <hyrax42> question for the linux users here:
14:59:40 <hyrax42> for "nice" haskell packages, ubuntu or debian is better?
14:59:44 <hyrax42> or equivalent?
15:00:02 <hpaste>  dons annotated "mandelbrot: Haskell level" with "mandelbrot: Core" at http://hpaste.org/381#a1
15:00:14 <glguy> do people install their haskell libraries through a package manager? isn't that a good way to use outdated libraries?
15:01:11 <Cale> hyrax42: Well, ubuntu uses debian's packages for GHC, but they're often a version behind.
15:01:34 <Cale> (e.g. GHC 6.4 rather than 6.6)
15:01:36 <Gwern> even in unstable?
15:01:51 <Cale> Debian unstable has 6.6
15:02:06 <Cale> Ubuntu has 6.4.2
15:02:09 <Cale> (in Edgy)
15:02:51 <Gwern> cognominal: so multiplication then. not too bad
15:02:57 <Botje> @pl \a b -> (fromIntegral a) / (fromIntegral b)
15:02:57 <lambdabot> (. fromIntegral) . (/) . fromIntegral
15:03:00 <hpaste>  dons annotated "mandelbrot: Haskell level" with "mandelbrot: C--" at http://hpaste.org/381#a2
15:03:13 <quicksil1er> Is the Cmm compiler standalone? Could compilation via C-- be an interesting option for a DSL -> native code pathway?
15:03:37 <hyrax42> Cale: ok, I guess I'll go with debian
15:03:38 <Cale> The generic linux package for 6.6 works fine in Ubuntu though.
15:03:56 <hyrax42> I don't want to have to compile GHC, and if new versions go to debian first
15:03:57 <Cale> Personally, I find Ubuntu way more convenient to get running.
15:04:02 <hyrax42> then that suits me better
15:04:08 <Cale> Oh, you still don't have to compile it.
15:04:11 <hyrax42> Cale: it's to be a server system
15:04:15 <Cale> There's a binary generic package.
15:04:21 <hyrax42> I'm getting a virtual private server account
15:04:24 <Cale> ah, okay
15:04:36 <Cale> Debian would probably be good for that.
15:04:49 <hyrax42> if it was for home, I'd go ubuntu
15:05:15 <Cale> yeah
15:05:49 <Binkley> quicksiller: it looks from their web page like it is - http://cminusminus.org/
15:05:51 <lambdabot> Title: C-- Home
15:06:07 <Binkley> it says you can download a "Quick C--" compiler
15:06:15 <xic> Cale: hi, remeber that XEither problem you helped me with?
15:06:35 <hpaste>  dons annotated "mandelbrot: Haskell level" with "mandelbrot: asm" at http://hpaste.org/381#a3
15:07:04 <dons> augustss: so there's some scary looking fmul and friends in long stretches there
15:07:12 <Cale> xic: yeah
15:07:24 <augustss> dons: yeah, it looks pretty good!
15:07:26 <quicksil1er> Binkley: yeah, just reading that page. Thank you.
15:07:34 <xic> Cale: i'm having trouble havine an XEitherT be an instance MonadTrans
15:07:37 <xic> Cale: is it possible?
15:08:05 <augustss> dons: some parts look less nice, but I bet those are the weird entry points that are not used
15:08:23 <dons> yeah
15:08:23 <augustss> dons: it would be nice to get rid of dead code for readability.
15:08:32 <dons> glguy: oh, does hpaste truncate now?
15:08:35 <Cale> um, what's XEitherT ?
15:08:59 <dons> augustss: so i can't spot obvious reasons why that runs slower. i'll need to check against the C/gcc output I think
15:09:00 <glguy> hpaste
15:09:00 <Cale> data XEitherT m e a = XLeft e | XRight (m a)
15:09:01 <Cale> ?
15:09:32 <augustss> dons: it would be nice with an instruction level profiler
15:09:43 <augustss> there used to be tools like that
15:09:50 <dons> mm. yes. maybe some of these PAPI numbers
15:10:01 <dons> the new rts low level info.
15:10:38 <xic> Cale: well actually i've been doing it the way MaybeT works: newtype XEitherT m a b = XEitherT { runXEitherT :: m (XEither a b) }
15:10:40 <augustss> all you to do is to instrument every basic block with a counter
15:10:51 <dcoutts> dons, every time I read stg/core/cmm I want to rewrite something to have it better presented
15:11:09 <augustss> dcoutts: me too!  I even started once
15:11:13 <Cale> okay, that seems reasonable
15:11:17 <dcoutts> dons, eg, we should generate cmm using cmm local vars and using the cmm stack
15:11:19 <hyrax42> Cale: so debian testing should be all right?
15:11:20 <dons> dcoutts: i'd really like to be able to add a bang patterns, and have the Core for that code appear in a window next to it
15:11:21 <dcoutts> augustss, oh?
15:11:24 <Cale> hyrax42: I think so
15:11:25 <augustss> dcoutts: it's so ugly
15:11:38 <dons> so it would show on the fly the effect in Core of tweaking the src level
15:11:39 <Cale> hyrax42: check first that it has GHC 6.6
15:11:44 <augustss> dcoutts: yeah, but I didn't get very far
15:11:45 <dons> then after that, what does the C-- result look like
15:11:48 <Cale> But I think it would by now.
15:11:48 <hyrax42> Cale: 6.6-3, I just checked
15:11:51 <Cale> good :)
15:12:08 <xic> Cale: i was able to write "return" and ">>=" functions for XEitherT so that it is an instance of Monad. but i can't seem to get it to be an instance of MonadTrans
15:12:21 <dcoutts> augustss, yeah. I also want to see the operational interpretation of the STG code, ie imperative order but still in the STG machine model. Eg with push/enter and allocations explicitly annotated.
15:12:26 <Cale> xic: well, lift shouldn't be too hard...
15:12:45 <Cale> lift x = XEitherT (fmap XRight x)
15:12:48 <Cale> I think.
15:12:50 <xic> Cale: my problem is just getting the "instance" line right... i keep getting kind errors
15:12:59 <augustss> dcoutts: yes, that would be nice
15:13:05 <Cale> er, or
15:13:10 <Cale> lift x = XEitherT (liftM XRight x)
15:13:11 <dcoutts> dons, and then have a cmm -> cmm pass that converts the local vars to the current I32[SP] := ; SP := SP + 4; style.
15:13:46 <dcoutts> dons, so that at least the first version of the cmm would be readable and more easily matched to the STG code.
15:13:56 <Cale> instance MonadTrans XEitherT where
15:14:02 <dons> dcoutts: yeah
15:14:12 <dcoutts> dons, though if we had an imperative print of the STG code then that might not be so important.
15:14:40 <dons> dcoutts: you could maybe get a summer of code funding to add this :-)
15:14:43 <dcoutts> dons, SPJ did suggest that I rewrite the core/stg pretty printer. He says it's not much code.
15:14:45 <dons> (you're still a phd student ...)
15:14:51 <dons> right. that's pretty easy
15:15:06 <xic> Cale: i get: `XEitherT' is not applied to enough type arguments. Expected kind `(* -> *) -> * -> *', but `XEitherT' has kind `(* -> *) -> * -> * -> *'
15:15:19 <dcoutts> I might do a simple version in preparation for use looking at the core more for the list fusion stuff.
15:15:39 <Cale> oh, of course
15:15:41 <Cale> make it
15:15:57 <Cale> data XEitherT a m b = ...
15:15:58 <dons> vincenz: oh good, your second example does seem faster.
15:16:10 <Cale> then (XEitherT a) is a monad transformer.
15:16:33 <xic> Cale: hm... but then will i still be able to have XEitherT be a Monad?
15:16:45 <vincenz> dons: cool
15:17:40 <Cale> (XEitherT a m) will be the monad
15:18:23 <xic> Cale: cool thanks, i'll try this!
15:18:50 <xic> Cale: i still find it disturbing though that the order of type arguments matters so much :(
15:18:51 <Binkley> dcoutts, watch out, SPJ told me that rewriting ticky-ticky wouldn't be that much code and it took me 2 months :-)
15:18:59 <dons> vincenz: the first example generates the wrong output for N=3k, and is a bit slower than the second
15:19:08 <dcoutts> Binkley, heh heh :-)
15:19:23 <vincenz> dons: ah, thanks
15:19:26 <dons> vincenz: same output for n=2k,
15:19:34 <dons> i noticed this with gotaku's yesterday, things go funny at 3k
15:19:53 <vincenz> there is a pixel problem on the first row
15:19:57 <vincenz> and several other places as well
15:19:58 <vincenz> I traced
15:20:06 <vincenz> it seems sometimes rounding errors build up enough to cause a proble
15:20:15 <vincenz> dependong on how you build cr
15:20:19 <dons> yeah
15:20:25 <Cale> xic: Yeah, it is a bit disturbing, but fixing it is pretty hard.
15:21:49 <vincenz> dons: funnily enough there are plenty of rounding errors, but it is always only a proble on the first row
15:22:00 <vincenz> dons: for one pixel... on multiple resolutions...
15:22:22 <vincenz> (well for one pixel at the same location on multiple resolutions)
15:23:52 <pzpz> Hey all. Off-topic question, which linux distributions are used by you folk?
15:24:00 * heatsink uses debian
15:24:26 <Binkley> I'm using Ubuntu Edgy Eft
15:24:29 <Binkley> I've been mostly happy with it
15:24:38 <xic> using crux here
15:24:40 <Pseudonym> G'day.
15:24:42 <dons> openbsd
15:24:47 <dons> heya Pseudonym
15:24:51 <augustss> Linux?  It's for weenies.
15:24:53 <Pseudonym> dons, got a newbie question.
15:24:56 <Pseudonym> Trying to install fps.
15:25:02 <dons> with which ghc?
15:25:03 <Pseudonym> But it doesn't seem to install fpstring.h
15:25:07 <Syzygy-> Gentoo.
15:25:10 <Pseudonym> 6.4.1
15:25:14 <dons> oh, sounds like an old version of Cabal.
15:25:18 <Pseudonym> Aha.
15:25:20 <Pseudonym> So upgrade, then.
15:25:24 <Pseudonym> Gotcha.
15:25:27 <dons> yeah, grab 6.4.2 or 6.6
15:25:30 <dons> or update cabal
15:25:49 <dons> i'd just go to 6.6 if you can. everythings shinier
15:25:49 <Pseudonym> I figured it'd be something simple like that.
15:26:02 <Botje> my first real haskell program is coming along nicely.
15:26:06 <Binkley> augustss: so if Linux is for weenies, what are you using? :-)
15:26:17 <dons> Botje: good stuff!
15:26:29 <dons> Binkley: netbsd (maybe?)
15:26:31 <Botje> it's a terrain generator!
15:26:39 <pzpz> xic: Any reason your'e using Crux over Arch?
15:26:43 <augustss> I used NetBSD on my machines for about 15 years, now I have a MacBook.
15:26:44 <Syzygy-> CTCP VERSION reply from augustss: Colloquy 2.1 (3558) - Mac OS X 10.4.8 (Intel) - http://colloquy.info
15:26:45 <Botje> the viewer will be for tomorrow, i think
15:26:45 <lambdabot> Title: Colloquy: IRC & SILC Client
15:27:02 <dons> ah right
15:27:09 <augustss> Binkley: I still run NetBSD on my server(s)
15:27:09 <dons> yes.. betrayal!
15:27:37 <augustss> MacOS X has a LOT of NetBSD userland.
15:27:46 <xic> pzpz: haven't tried Arch, but i tried frugalware which is a fork of arch, and i didn't like it
15:27:49 <Binkley> I used Mac OS X for years, now I use Linux instead
15:27:52 <augustss> Most of it.
15:27:56 <Pseudonym> Botje: Still, you could grab an off-the-shelf renderer that handles heightfields.
15:27:59 <siti> is that why I hated the mac's terminal and console apps?
15:28:01 <Pseudonym> And then you'd get to see something.
15:28:04 <dons> do you use the mac like a bsd system, augustss ?
15:28:09 <Binkley> I was thinking about switching to *BSD when I quit using my Mac
15:28:18 <augustss> dons: kinda.
15:28:28 <siti> I tried freebsd because I have a few friends in to it.
15:28:32 * TuringTest uses colloquy
15:28:32 <Binkley> but it seems all the Haskell people use Debian. And if everyone else jumped off a cliff, I'd do it too
15:28:35 <augustss> siti: the terminal and console are apples.  they suck
15:28:39 <pzpz> My gentoo laptop is lost in transit, so I've been using FreeBSD. It's driving me crazy :(
15:28:41 <sorear> tell foddle.
15:28:51 <dons> Binkley: there's a lot of gentoo guys though. see kolmodin, dcoutts, kosmikus
15:28:52 <siti> I forcefully closed vmware, and the filesystem died.  I can't belive people use an OS without journaling :S
15:29:00 <siti> filesystem*
15:29:02 <pzpz> How far has Ubuntu strayed from its Debian roots? Are they still using the same apt repositories?
15:29:09 <TuringTest> no
15:29:19 <TuringTest> (though they can interoperate somehwat)
15:29:25 <augustss> I enjoyed using NetBSD.  Most new machines I got made me write some device drivers.
15:29:41 <dcoutts> Binkley, there's #gentoo-haskell
15:29:50 <Binkley> well, so far I'm happy with Ubuntu
15:30:03 <Binkley> and the things about it that haven't made me happy are mostly related to the POS laptop that I unwisely chose
15:30:03 <dons> augustss: hehe
15:30:03 <dcoutts> aye it's pretty good
15:30:34 <dcoutts> Binkley, ah yes, I chose parts for my laptop fairly carefully
15:30:37 <augustss> but I actually got paid to write the USB stack :)
15:30:47 <dons> oh, that's nice.
15:31:13 <augustss> Ericsson needed it for Linux, but I convinced them it was better to write it for NetBSD first.
15:31:32 <augustss> We actually had it running on Linux too.
15:31:48 <augustss> These were the days before Linux got USB support.
15:31:57 <Binkley> I bought the first laptop that caught my eye at Fry's that wasn't too expensive
15:32:00 <Binkley> which was a bad mistake
15:32:09 <Binkley> but I just wanted the whole computer-shopping ordeal to be *over*
15:32:10 <dons> yeah, i remember having usb support on my openbsd machine, via netbsd, a year or so before linux
15:32:16 <Binkley> so this resulted in hours crying over ndiswrapper
15:32:22 <Pseudonym> In Australia, Fry's is a self-storage company.  That always confuses me.
15:32:31 * TuringTest goes to bed and hopes the shootout-fairy will bring a happy tomorrow...
15:32:41 <dons> night TuringTest
15:32:49 <TuringTest> dons and vincenz : good luck with the mandelbrot entry
15:33:35 <augustss> Good work on the shootout everyone!  It's looking better again. :)
15:35:46 <heatsink> Pseudonym: In the US, Lowe's is a hardware store.
15:36:16 <mahogny> augustss, nice to hear I am not the only netbsd zealot around here :)
15:36:46 <augustss> NetBSD rulez!
15:37:32 <augustss> It has the cleanest code base of the open source OSs that I've seen.
15:37:56 <augustss> Well, dunno about Solaris.
15:38:21 <mahogny> well, they don't seem to hyped about adding all the latest stuff as soon as possible. I guess that adds to it
15:38:56 <ndm> hmm, no netbsd port for Yhc :(
15:39:05 <mahogny> and I kinda think it shows. my linux boxes can't match the uptime of my bsd boxes in any way
15:39:10 <heatsink> Profiling question: if -hc attributes memory to a CAF, does that mean the memory is retained by the CAF?
15:39:10 <augustss> It's a bit like Haskell.  Don't compromise, do it right, even if it takes longer.
15:39:11 <sorear> isn't yhc supposed to be ansi c?
15:39:33 <sorear> (doesn't netbsd have an ansi c compiler?)
15:39:54 <ndm> sorear: it probably does, but we don't count an architecture as ported until we've got a buildbot for it
15:39:57 <augustss> mahogny: my server has not crashed it years, but i have rebooted now and then for hardware upgrades.
15:40:14 <ndm> sorear: in reality the average port time is somewhere around 15 minutes :)
15:40:14 <siti> yet the power goes out and your filesystem dies
15:40:18 <siti> sounds pretty bad to me ;)
15:40:23 <mahogny> augustss, mine keeps going down for power outages. I need a UPS. only problem is, the UPS would be more expensive than the server :)
15:40:42 <augustss> sorear: netbsd uses gcc as everyone else.  but there are coding guidelines about not using gcc specific features.   it's very frowned upon
15:40:43 <sorear> siti: my journaling filesystems die
15:41:10 <ndm> my windows box has only crashed once in the last 2 years
15:41:19 <sorear> siti: in this part of the US, bad ram causes much more damage to computers than power outages
15:41:20 <mahogny> augustss, the main memory is even broken. but that doesn't seem to affect BSD. it's my slowest server with most services. by modern standards it shouldn't be able to take the load :P
15:41:27 <astrolabe> ot question.  I've hardly used unix systems, only windows.  If I wanted to try Linux, what would be a good flavour to start with?
15:41:35 <mahogny> ubuntu
15:41:38 <augustss> and the netbsf code base is compiled with -Werror so any warning is considered an error
15:41:48 <astrolabe> mahogny: thankyou
15:42:00 <mahogny> -Werror... oooh. how it should be
15:42:28 <ndm> mahogny: only if -warnings are't broken
15:42:34 <mahogny> not like the piece of shit I got handed over recently which in realtime complains about free'ing already free'd memory :P
15:43:25 <ndm> but that isn't spotted by -Werror, only by -use-gc :)
15:43:34 <mahogny> (and some people why my most efficient days start with rm -Rf...)
15:43:43 <mahogny> *wonder
15:44:14 <mahogny> hmmm. -use-gc? in gcc?
15:44:16 <Botje> ?instance Functor UArray
15:44:17 <lambdabot> Maybe you meant: instances instances-importing
15:44:25 <Botje> grmbl.
15:44:29 <olliej|meet> ndm: you aware of any relatively simple papers/workshop/tutorials on type inference/unification?
15:44:37 <Botje> Array has a Functor instance but UArray doesn't.
15:44:48 <Binkley> olliej: a lot of people like the book _Term Rewriting and All That_, but I haven't read it
15:44:52 <Binkley> (even though I'm not ndm)
15:44:54 <ndm> mahogny: sadly not yet - although shoving in boem sometimes work
15:45:03 <olliej> Binkley: :D
15:45:05 <astrolabe> Botje: Same for Read!
15:45:25 * astrolabe grumbles too
15:45:26 <Botje> nobody likes unboxed arrays
15:45:28 <ndm> olliej: no, but i would like to read one some day - as it appears i have to write a type checker at some point... :(
15:45:33 <Botje> luckily I can just use amap instead of fmap :)
15:45:37 <mahogny> ndm, of some reason the system default seems to give *a lot* of warnings. which is nice; -Wall should be default at minimum
15:45:50 <olliej> also, is there an equivalent to splitAt which takes a function?
15:46:05 <augustss> Botje: it would be nice if UArray could be made a Functor somehow
15:46:21 <ndm> @type splitAt
15:46:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:46:23 <pzpz> To debian, or to Arch. :(
15:46:24 <augustss> olliej: span, scan
15:46:38 <ndm> @hoogle (a -> Bool) -> [a] -> ([a], [a])
15:46:40 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
15:46:40 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:46:40 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:46:41 <olliej> ndm: hehe, i'm also currently trying to write a type inferrer... well.. actually i'm working, but when not at work, i'm writing a type inferer
15:46:53 <olliej> ndm, augustss: cheers
15:46:57 <ndm> olliej: i have a design, but no time to implement or check it...
15:47:06 <Botje> hmm
15:47:13 <Botje> generating a 1024x1024 heightmap takes forever.
15:47:19 <Binkley> olliej: a type inferrer for haskell? or for something else?
15:47:31 <pzpz> @hoogle (a->Bool) -> [a] -> [[a]]
15:47:32 <lambdabot> No matches, try a more general search
15:47:32 <olliej> Binkley: well, for damas-milner, so technically yes
15:47:40 <pzpz> @hoogle words
15:47:41 <olliej> Binkley: certainly haskell would be the final goal
15:47:41 <lambdabot> Prelude.words :: String -> [String]
15:47:41 <lambdabot> Data.PackedString.wordsPS :: PackedString -> [PackedString]
15:47:41 <lambdabot> Prelude.unwords :: [String] -> String
15:48:02 <olliej> Binkley: largely because my current haskell compiler produces code that is frequently horrific
15:48:09 <pzpz> There should be a generic prelude method like words that takes a function f .
15:48:28 <pzpz> splitBy :: (a -> Bool) -> [a] -> [[a]]
15:48:32 <Binkley> olliej: yeah. well, when I was writing one, I certainly couldn't find any particularly understandable papers/etc. on it
15:48:36 <Binkley> it was rough going for me
15:48:43 <olliej> Binkley: yeah
15:48:47 <ndm> pzpz: yes, there really really really should be!
15:49:09 <pzpz>  ndm: IT's simple to write. It's just puzzling to me why it's not there.
15:49:10 <olliej> i've found a couple recently which actually touch on the basic algorithm, rather than expounding type rules continuoussly
15:49:23 <ndm> pzpz: yes, i know!
15:49:33 <ndm> pzpz: plus its fiddly to write, more than anything
15:50:06 <sorear> Botje, augustss: instance Functor (UArray i) is impossible
15:50:25 <sorear> this falls under the heading of "constructor classes considered harmful"
15:50:32 <augustss> sorear: I know it's impossible as things stand
15:50:38 <sorear> a constructor class must work at EVERY type
15:50:50 <siti> lithyum: hah on your host name it has dialup.adsl
15:50:53 <siti> which one is it :D
15:50:54 <augustss> sorear: yes, and sometimes that's overly restrictive
15:51:03 <lithyum> adsl :P
15:51:07 <siti> heh ok
15:51:09 <sorear> augustss: hence "considered harmful" :)
15:51:58 <augustss> I have several types at work that would be very nice to have as Functor&Monad, but they need a context
15:52:01 <augustss> :(
15:52:03 <olliej> Binkley: my haskell compiler was based off of GHC Core, so i avoided type inference altogether, but it had a large number of draw backs
15:52:40 <ndm> olliej: does that mean its currently broken, given GHC Core is broken?
15:52:45 <Binkley> olliej: you mean you used GHC's front end and read in External Core?
15:52:48 <Binkley> or something else?
15:53:00 <olliej> Binkley: yes
15:53:03 <Binkley> yeah
15:53:06 <Binkley> that's what I was doing, back in the day
15:53:07 <ndm> olliej: and are you aware that Core haskell has rank-2 types, which can't be inferred?
15:53:09 <olliej> ndm: i was working from ghc 6.4
15:53:20 <ndm> Use Yhc.Core, its more fun (and less broken)
15:53:24 <Binkley> ndm: but depending what you're trying to do, you can still do type inference on Core
15:53:31 <Binkley> given that there's so much explicit type information there already
15:53:41 <Binkley> for example, I was doing type inference for deforestation
15:53:42 <ndm> Binkley: its hardly type inference, given just how much is there!
15:53:42 <olliej> ndm: yes, but ghc core has already infered all the types (kinds were a problem, but meh)
15:53:45 <Binkley> which, in theory, was a snap
15:54:04 <Binkley> well, yes. but there are situations, like my deforestation stuff, where you want to erase some of the type information that GHC's front end put in...
15:54:05 <ndm> isn't there a Core annotator, which annotates every term in a syntax tree?
15:54:06 <Binkley> and infer the rest
15:54:18 <ndm> i thought i saw that somewhere
15:54:30 <Binkley> not sure, but it's easy to write one
15:54:36 <Binkley> given the existence of the Note construct in GHC Core
15:54:42 <olliej> ndm: problems in ghc core -- the documentation lies, it isn't compatible with ghc internal rep (ghc supports 16bit characters, hc core doesn't)
15:54:50 <Binkley> olliej: yes; it's being worked on, though
15:54:57 <Binkley> there's been some mailing list discussion about it
15:55:02 <Binkley> and yes, the documentation has *always* lied
15:55:04 <olliej> however the big problem is
15:55:18 <olliej> that i wanted Core so i could avoid type inference
15:55:31 <olliej> and some of the optimisation passes
15:55:36 <ndm> Yhc.Core is 100% Yhc Haskell, everything totally - that was one of the goals
15:56:05 <ndm> and it has some uber-funky optimisations - strictness analyser, first-order reduction, generalised Neil-deforestation
15:56:08 <olliej> butghc. Core ha already taken the original haskell, and lost most symantic info (eg. class functions, etc)
15:56:31 <olliej> and has also taken it a few steps closer to g machine
15:56:59 <olliej> most of my copmilers code (and brokenness) were involved in trying to reshape the tree into something more practical
15:57:01 <olliej> ..
15:57:17 <olliej> well that and arity matching, which was almost continuously broken in some case
15:58:04 <Binkley> olliej: so, what was the goal of your compiler?
15:58:12 <olliej> ndm: oh yes, and i had to do strictness analysis myself... this is not hard if you just say screw it, and be conservative
15:58:23 <olliej> Binkley: to target the CLR
15:58:25 <ndm> olliej: thats all the GHC one does
15:58:27 <Binkley> Ah
15:58:40 <ndm> Did you ever compare it to the Yhc CLR target?
15:58:40 <olliej> Binkley: with as much static type info as was conceivably possible
15:58:50 <Binkley> Well, I guess if that was the point, I don't quite see what the problem is optimization-wise
15:58:51 <Binkley> I mean
15:58:58 <Binkley> GHC dumps external core post-optimization
15:59:00 <olliej> ndm: when last i checked yhc for .net just did type erasure?
15:59:09 <ndm> olliej: yes, definately
15:59:15 <olliej> Binkley: it's optimising for a gmachine
15:59:38 <olliej> ndm: my compiler maintained static types for everything other than higher kinded types
15:59:44 <Binkley> Ah, so you found that some of GHC's optimizations were anti-optimizations for you?
15:59:53 <olliej> ndm: which unfortunately required a dynamic cast
15:59:56 <olliej> Binkley: yeah
16:00:07 <ndm> that is quite impressive - mapping between two such diverse type systems
16:00:17 <olliej> ndm: it was my thesis :D
16:00:52 <olliej> ndm: simple parametric types are obviously trivial given .net supports them
16:01:12 <olliej> ndm: inside a single module higher ranked types are also fairly trivial
16:01:16 <ndm> this would be before .NET got support for true generics?
16:01:36 <olliej> ndm: nope, this is .net with type parameterisation
16:01:44 <olliej> ndm: so the trivial case is taken care of
16:02:05 <olliej> ndm: basically my thesis was on lazy evaluation, higher kinded, and higher ranked types
16:02:54 <Binkley> olliej: is your thesis online somewhere?
16:03:04 <olliej> Binkley: it's still being marked
16:03:07 <olliej> *grumble*
16:03:12 <olliej> i hadned it in in june last year
16:03:13 <Binkley> heh
16:03:27 <Binkley> but was this for undergrad, master's, or...?
16:03:29 <ndm> can we get a sneak peak before its marked?
16:03:30 <olliej> masters
16:03:48 <olliej> but it might have embarassing mistakes
16:03:51 <olliej> ;)
16:03:56 <olliej> i'll see if i have it here
16:03:58 <olliej> (work machine)
16:03:59 <siti> where'd you do the masters?
16:04:10 <olliej> canterbury uni -- under nigel perry
16:04:16 <siti> ok I used to go there :P
16:04:18 <ndm> i never spot embarassing mistakes in my work, i don't see why yours should be any different ;)
16:04:32 <siti> I heard someone had done .net and haskell :)
16:04:35 <sorear> olliej: so, you want us to keep our review secret?  or do they cloister the examiners? :)
16:04:39 <olliej> siti: when?
16:04:45 <siti> last year, just finished
16:04:48 <olliej> sorear: hah
16:04:59 <Binkley> I know my thesis is full of embarassing mistakes, but I put it online anyway
16:05:07 <Binkley> since if I waited to fix all the mistakes, it would never see the light of day
16:05:10 <SamB> isn't that the best thing to do in that situation?
16:05:15 <Binkley> It was so embarassing to re-read it, though
16:05:16 <sorear> gah...
16:05:16 <Binkley> I thought
16:05:17 <sorear> stefan@stefans:~$ ?dict-all cloister
16:05:19 <olliej> al those people *actually* interested pm your email addys
16:05:30 <siti> someone said that a person got a job at apple is that you, you're in #webkit?
16:05:31 <Binkley> "wow, this point that I thought I discovered was actually in someone else's thesis 10 years before"
16:05:32 <SamB> I mean, how are you going to get people to fix those embarrassing mistakes for you without putting it online?
16:05:40 <ndm> nah, lots of people don't - if you are just casually interested
16:05:41 <olliej> siti: yup
16:05:47 <siti> small world :p
16:05:48 <SamB> Binkley: that still sorta counts as discover
16:05:52 <SamB> er. discovery
16:05:53 <olliej> siti: hehe
16:06:00 <Binkley> sure, I discovered it for myself, that's something...
16:06:04 <Binkley> but I kind of have high expectations for myself
16:06:10 <Binkley> such as omniscience about previous work
16:06:20 <SamB> heh
16:06:25 <olliej> i was halfway through my thesis when i heard about yhc for .net
16:06:34 <olliej> that was terror inducing
16:06:48 <ndm> yeah, it wasn't something i found out about until the patch dropped in on the mailing list...
16:06:51 <SamB> which, yhc's code, or you hearing about Yhc?
16:07:11 <ndm> he's refering to Yhc's .NET back end
16:07:16 <SamB> yeah
16:07:40 <augustss> is it useable?
16:07:52 <ndm> augustss: The Yhc .NET back end?
16:07:56 <augustss> yes
16:08:15 <olliej> augustss: mine isn't alas
16:08:29 <olliej> augustss: i managed to coax core rep of most of ghcs base libraries
16:08:38 <ndm> augustss: yes, it works and generates native CLR code, but doesn't expose Haskell function's to .NET - so you can run it as a .NET process but not interoperate much (if at all)
16:08:48 <olliej> augustss: but my arity fixing code kept getting horked
16:09:00 <olliej> ndm: mine generated c#
16:09:06 <olliej> ndm: *lots* of c#
16:09:13 <augustss> ndm: can you call .NET from Haskell?
16:09:23 <ndm> augustss: i don't think so
16:09:33 <Binkley> olliej: so what was the arity problem, again?
16:09:37 <augustss> ndm: and how is the speed?
16:09:40 <ndm> augustss: but adding that side of things should be relatively simple, i'd guess
16:10:00 <ndm> augustss: i think it was a factor of 2 from the C bytecode back end
16:10:09 <olliej> Binkley: take a function of the type a -> b -> c -> d
16:10:25 <augustss> ndm: i was hoping more like close to ghc speed ;)
16:10:34 <olliej> Binkley: the actual implementation could be a -> ( b -> (c -> d))
16:10:53 <olliej> Binkley: or (a,b)-> ... or (a,b,c)->d
16:10:57 <olliej> Binkley: and so on
16:11:01 <Binkley> right
16:11:12 <ndm> augustss: it doesn't use strictness information, and it doesn't take advantage of Yhc's optimiser - so its maybe 4-8 times slower than GHC
16:11:13 <sorear> just like ghc's decurrying
16:11:37 <siti> steve2: :p
16:11:55 <olliej> Binkley: so we say a function type is defined as a tuple of it's "type" and its arity
16:11:58 <steve2> :P
16:12:03 <steve2> yeah brb ;)
16:12:07 <augustss> ndm: still, it's interesting.  I'm afraid .NET it big at work.
16:12:13 <coffee-mug> good evening
16:12:21 <Binkley> olliej: ok, go on
16:12:27 <pzpz_> Any of you debian users have any complaints about apt and the package repository?
16:12:37 <ndm> augustss: its been a while since anyone prodded it - we literally got a patch dump and then the person disappeared - but should still work (however it did before)
16:12:44 <olliej> Binkley: so now we can have two functions say, (a -> b -> c -> d, 3) and ( a->b->c->d, 2)
16:12:47 <coffee-mug> I'm a ubuntu user and I love the packaging
16:12:47 <sorear> I think I solved the decurrying problem over a year ago but didn't think it important ...
16:12:51 <coffee-mug> I suppose debian is the same
16:12:53 <coffee-mug> or similar
16:12:54 <olliej> Binkley: to haskell they are the same type
16:13:10 <olliej> Binkley: but there arity is different
16:13:21 <Binkley> right...
16:13:26 <sorear> pzpz_: I love it.  get everything from darcs however 'cause I <3 bleeding edge
16:13:28 <Binkley> well, GHC does maintain internal information about the arity
16:13:35 <Binkley> or rather, about its guess of what the arity might be
16:13:38 <olliej> Binkley: so if you want to use a function with arity 3 where a function of arity 2 is expected
16:13:50 <sorear> my system could desugar currying into fundeps
16:13:50 <ndm> augustss: but i'd be very wary about using Yhc for work stuff yet, it still has that nasty nhc smell floating around it
16:13:52 <olliej> Binkley: you have to bludgeon the arity
16:14:13 <Binkley> hmm, I'm not sure I understand that last part
16:14:15 <sorear> maybe I should try to reformulate it now - my intel seems to have quadrupled in the last year
16:14:21 <olliej> Binkley: which is actually trivial in the simple/ordinary case
16:14:33 <augustss> ndm: and it probably doesn't support multi-parameter type classes?
16:14:45 <Binkley> actually, it's fine to use a function with arity 3 where one of arity 2 is expected, right? just not the other way around
16:14:46 <Binkley> or am I confused?
16:14:56 <ndm> augustss: all those things that nhc lacks, all those places nhc goes crazy, Yhc follows...
16:15:03 <sorear> Binkley: both are legal.
16:15:06 <ndm> no MPTC at all
16:15:07 <olliej> Binkley: no, in damas milner a function doesn't have arity
16:15:19 <olliej> Binkley: so it isn't a problem for the haskell type system
16:15:22 <sorear> Binkley: arity is just a performance hack
16:15:36 <sorear> Binkley: a very cool one I might add :)
16:15:40 <olliej> sorear: it's a different choice in wevaluation model
16:15:42 <augustss> ndm: I don't use many extensions, but MPTC and existential types I do use
16:15:54 <ndm> sorear: if you make Haskell first order, then it's critical
16:16:08 <ndm> augustss: existential's as in forall in a data structure? Yhc supports that
16:16:20 <Binkley> olliej: sure. but GHC does do all sorts of stuff with approximating arity info and trying to preserve it, too
16:16:25 <ndm> MPTC is alas not yet supported, but will be when we get to the big rewrite - but thats a way off
16:16:27 <sorear> ndm: since when is first order not itself a subcategory of performance hack?
16:16:34 <olliej> ndm: so did my compiler... in places.. on occasion.. if i hadn't broken it at that particular moment
16:16:38 <ndm> olliej: have you seen the GHC paper on arity analysis?
16:16:47 <Binkley> which I'd guess isn't in the External Core representation
16:16:49 <Binkley> but should be
16:16:50 <ndm> sorear: for me its a performance hack and an analysis hack
16:16:52 <augustss> ndm: yes, that's the one
16:16:55 <sorear> ndm: "how to make a faster curry" -- that one?
16:17:03 <ndm> sorear: no
16:17:03 <olliej> hehe
16:17:16 <ndm> Dana Xu, unpublished tech report
16:17:34 <olliej> ndm/Binkley: anyhoo, that was where the largest number of continual bugs occured in my compiler
16:17:35 <ndm> http://www.cl.cam.ac.uk/~nx200/research/arity.ps
16:18:02 <olliej> it would have been better/easier if my copmiler wasn't written in c#
16:18:06 <olliej> so much badness
16:18:40 <audreyt> ookk: yeah. I'm reuploading yet another build
16:18:40 <lambdabot> audreyt: You have 10 new messages. '/msg lambdabot @messages' to read them.
16:18:53 <sorear> wow, you're popular
16:18:56 <Binkley> I was trying to extend on some of Dana's work and integrate it with the demand analyzer, last fall
16:19:02 <Binkley> but I'm not done yet either
16:19:08 <coffee-mug> lambdabot supports messages?
16:19:08 <xic> anyone know what's supposed to happen if the handler in catchError throws an error?
16:19:23 <sorear> xic: demons fly out your nose?
16:19:29 * sorear checks
16:19:33 <Binkley> olliej: back up, you *wrote* your compiler in C#?
16:19:33 <olliej> ndm: the most annoying part of ghc's core is you lose the connection between class dictionaries and the associated function names
16:19:35 <Binkley> rather than just generating it?
16:19:48 <olliej> Binkley: well the parser was generated
16:20:03 <ndm> olliej: generating it from Haskell
16:20:08 <olliej> Binkley: but when i started my haskell was basically non-existant
16:20:13 <xic> sorear: in java/c++ the old exception disappears, and the new exception propogates out
16:20:26 <olliej> ndm: even now my haskell isn't particularly good
16:21:31 <Binkley> olliej: yeah, I went from not knowing Haskell to hacking -- if not GHC -- then stuff that used External Core -- pretty quick
16:21:34 <Binkley> and my old code sure shows it
16:21:47 <olliej> Binkley: hehe
16:21:49 <Binkley> but writing a compiler in C# seems like it would be painful
16:22:04 <olliej> Binkley: it's quite funny if you look at parts of the code
16:22:16 <ndm> Binkley: if not Haskell, what would you write a compiler in? C# would be my second choice...
16:22:19 <olliej> Binkley: you can see as i slowly convert to writing more and mre "functionally"
16:22:30 <Binkley> ndm: well, OCaml or SML wouldn't be bad
16:22:34 <olliej> ndm: any language that isn't C/C++?
16:22:38 <Binkley> I just wouldn't write a compiler in a non-functional language
16:22:41 <siti> c ftw ;)
16:22:46 <ndm> Binkley: lets say not functional, given ML ~= Haskell for most purposes
16:22:47 <Binkley> or at least, would try to avoid to as best as I could
16:23:01 <Binkley> keep in mind, I don't know C#
16:23:07 <sorear> xic: I can't find what's *supposed* to happen, but fwiw (6.7):
16:23:10 <Binkley> but it seems like Java wouldn't be totally horrible for writing a compiler in
16:23:10 <ndm> do you know Java?
16:23:12 <Binkley> if you were sane about it
16:23:16 <Binkley> yeah, I know Java. somewhat.
16:23:23 <ndm> Java ~= C# (certainly closer than ML ~= Haskell)
16:23:28 <sorear> Control.Exception> catch (Prelude.fail "foo") (\_ -> Prelude.fail "bar")
16:23:28 <sorear> *** Exception: user error (bar)
16:23:28 <Binkley> Ok
16:23:29 <Binkley> Well
16:23:34 <Binkley> I'd still much rather use ML or Haskell than Java
16:23:36 <Binkley> no questiona bout it
16:23:49 <ndm> in industry people don't get these choices ;)
16:24:07 <Binkley> Well, olliej was talking about a thesis for school
16:24:33 <Binkley> in an academic setting you generally get to use whatever language you want
16:24:55 <olliej> Binkley: in my case, the wrong one :D
16:25:15 <Binkley> haha
16:25:26 <olliej> Binkley: on the other hand, using C# gave me access to the .net runtime... so i could just store symbol table info in generated assemblies
16:25:52 <olliej> Binkley: and then do multiple module compilation without any external dependencies, other than the compiled modules
16:26:07 <Binkley> yeah, I don't know much about .net
16:26:19 <Binkley> so, if you say that's a good thing, I believe it :-)
16:26:30 <olliej> Binkley: think of it as an evolution of the jvm
16:26:33 * augustss wrote a C compiler in assembly code.  It was something of a pain.
16:26:35 <ndm> the .NET runtime is VERY Nice
16:26:44 <ndm> and the libraries
16:26:49 <olliej> it's certainly a lot more friendly to other languages than the jvm
16:26:54 <olliej> and the type system is a little nicer
16:27:00 <ndm> yes, tail calls, something absent in JVM
16:27:05 <olliej> ndm: yeah
16:27:13 <olliej> but its tail calls are slower than actual recursion
16:27:36 <olliej> ndm: according to an ms guy i was talking to about it, it's due to security info in the frames or something
16:27:44 <ndm> but don't break the stack into pieces
16:27:55 <olliej> true
16:28:06 <ndm> with Haskell, you can't compile to recursion, you need to do a stack trampoline - which is expensive
16:28:12 <augustss> can't you turn off the security nonsense?
16:28:19 <ndm> its what our Python back end does
16:28:29 <ndm> augustss: yes, install Windows 95 again :)
16:28:31 <olliej> ndm: my compiler turned self recursion into while(1) directly
16:28:39 <augustss> ndm: in .NET, I mean :)
16:28:42 <olliej> ndm: and i played with catch stack overflows
16:29:01 <ndm> augustss: no, you can't
16:29:05 <olliej> ndm: eg try { .. } catch(StacOverflow) { spawn new thread to carry on }
16:29:15 <ndm> olliej: that sounds painful!
16:29:19 <olliej> ndm: it worked
16:29:33 <olliej> ndm: but you could do *bad* things to system resources accidentally
16:29:41 <olliej> so i concluded it was a  bad plan
16:29:54 <augustss> ndm: You don't really have to trampoline much if you also merge mutually recursive functions.
16:30:02 <glguy> !say test
16:30:36 <siti> > putStrLn "test"
16:30:38 <lambdabot>  <IO ()>
16:30:41 <Botje> DONE!
16:30:41 <ndm> augustss: our translation was at the bytecode level, the semantics made it a pain to do anything else
16:30:42 <siti> oh man :(
16:30:43 <glguy> what nick do I show up as?
16:30:46 <siti> > "test"
16:30:48 <lambdabot>  "test"
16:30:49 <ndm> glguy: glguy
16:30:52 <glguy> hmm
16:30:53 <glguy> ok
16:30:57 <glguy> !paste
16:30:57 <hpaste> Haskell paste bin: http://hpaste.org/
16:30:59 <glguy> !say test
16:31:05 <Botje> I used the nehe tutorial's renderer
16:31:07 <Botje> worked like a charm :)
16:31:23 <glguy> !say test
16:31:23 <hpaste> test
16:31:26 <glguy> there we go :)
16:31:27 <xic> Botje: screenshots please
16:31:36 <glguy> Colloquy gets confused on what nick it is sometimes
16:32:26 <sorear> !say test
16:33:24 <olliej> ndm: i've actually been pondering making an imperative looking language based on the damas milner type system
16:34:01 <olliej> ndm: it surprising just how many imperative constructs can be converted directly to haskell
16:34:11 <ndm> olliej: i considered that, when first learning Haskell - after a while you realise Haskell is a much better choice
16:34:15 <Binkley> well, haskell *is* the world's finest imperative language, after all ;-)
16:34:27 <ndm> Binkley: that statement is a complete lie...
16:34:42 <olliej> ndm: yeah, but i want to see if it's a) possible, and b) nice
16:34:46 <Binkley> then blame SPJ, not me
16:34:53 <olliej> "nice" meaning not awful
16:34:56 <olliej> :D
16:35:01 <ndm> Binkley: i know it's origins, it just shows he's never tried C# ;)
16:35:31 <augustss> ndm: Haskell has some very good features for imperative programming that are hard to find else where
16:35:49 <olliej> augustss: an example being?
16:36:01 <augustss> olliej: first class statements
16:36:06 <olliej> augustss: ?
16:36:07 <ndm> augustss: all wrapped up in a tidy monad, which is where it fails to be user friendly - for experience Haskell programmers it's a good imperative language, for others its much harder than a real imperative language
16:36:29 <olliej> augustss: first class *statements*?
16:36:33 <sorear> augustss: bah. first class statement == side effectful firstclass functions
16:36:42 <sorear> augustss: I think
16:36:45 <Binkley> ndm: well, you're probably right that he hasn't :-)
16:36:48 <augustss> ndm: I don't think it's perfect, but it has nice abstraction capabilities that most languahes lack
16:37:06 <augustss> sorear: yes, that's what I mean
16:37:07 * sorear has not seriously used an strictly imperative language in months
16:37:14 <Binkley> I don't think monads aren't "user friendly"
16:37:32 <Binkley> the difficulty of monads is socially constructed
16:37:59 <ndm> Binkley: i really do, its not a social problem, its a problem of concept and unnatural abstraction
16:38:00 <olliej> Binkley: i don't understand them/can't use them -- they confuse me immensely
16:38:21 <ndm> Binkley: calling them warm-fuzzy-things would just make people cry as much
16:38:26 <olliej> apparently spelling does as well :-/
16:38:35 <Binkley> ndm: I wasn't saying that calling them warm-fuzzy-things would help, as funny as it would be
16:38:41 <Binkley> but I don't think any abstraction is "natural" or "unnatural"
16:38:51 <Binkley> there was a person from Apple, I forget who, who said...
16:38:53 <sorear> augustss: scheme has first class functions with side effects
16:39:00 <Binkley> "Sucking on your mother's breast is 'intuitive'; nothing else is"
16:39:17 <ndm> Binkley: i disagree - set's and map's are natural abstractions, monad's aren't (integer's are, int's aren't)
16:39:37 <augustss> sorear: but the only way to put statements in a list, say, is to quote them.  otherwise they will be executed
16:39:41 <Binkley> well, Ints certainly probably seem more natural than Integers to people who are used to C
16:40:04 <sorear> augustss: doesn't Java have first class functions now?
16:40:04 * sorear hasn't used it since 1.3
16:40:10 <ndm> Binkley: i doubt C programmers ever expect to see n+1 < n - its not natural to anyone
16:40:16 <dibblego> sorear, no
16:40:17 <Binkley> sorear: Java does have first-class functions, but it's extremely awkward
16:40:25 <Binkley> welol
16:40:26 <Pseudonym> The nipple is actually not intuitive.  It's a learned skill.
16:40:27 <augustss> sorear: depends of what you mean, I'd say no
16:40:28 <Binkley> ok, anonymous functions
16:40:30 <Binkley> not first-class
16:40:33 <Botje> xic: http://img364.imageshack.us/my.php?image=200702080130551280x1024ah3.png
16:40:37 <lambdabot> Title: ImageShack - Hosting :: 200702080130551280x1024ah3.png, http://tinyurl.com/2fwr9j
16:40:40 <Pseudonym> My then-one-day-old daughter found this out the hard way.
16:40:44 <olliej> Binkley: what's the java syntax?
16:40:55 <Binkley> olliej: google for "anonymous inner classes"
16:40:56 <olliej> the c# anonymous function syntax is fine
16:40:57 <Binkley> it's fairly awful
16:41:03 <dibblego> new T(){U f(V v){}}
16:41:20 <Botje> agreed, it's ugly, but it's _MY_ ugly.
16:41:21 <olliej> Binkley: ah -- i though you were refering to an anonymous function syntax
16:41:27 <olliej> i know anonymous inner class
16:41:29 <augustss> olliej: the C# 3.0 syntax for lambda is good
16:41:37 <Binkley> yeah, but if you have anonymous inner classes, that gives you higher-order functions
16:41:41 <olliej> augustss: is it different from C#2?
16:41:46 <augustss> yes
16:41:50 <olliej> augustss: which wasn't *bad*
16:41:52 <Binkley> ndm: well, it's not natural if you've learned arithmetic
16:41:54 * olliej looks
16:41:59 <Binkley> arithmetic is something almost everyone learns
16:42:02 <Binkley> but that doesn't mean it's natural
16:42:08 <Binkley> it just happens to be in the base of common knowledge
16:42:20 <Binkley> monads typically don't get explained in a way that appeals to what people already know
16:42:24 <Binkley> doesn't mean they're not natural
16:42:29 <Binkley> or maybe I'm splitting hairs here and we basically agree
16:42:31 <Binkley> I'm not sure
16:42:32 <Pseudonym> "Natural", in this case, means "part of nature".
16:42:39 <Binkley> well, everything is part of natura
16:42:40 <Binkley> nature, even
16:42:41 <ndm> we'll just agree to agree :)
16:42:44 <Binkley> you are, I am, this computer is
16:43:02 <ndm> i found Monad's hard, but haskell easy - despite reading no Haskell tutorials but lots specifically on monads
16:43:06 <Pseudonym> Phil Wadler argues that "universal" is too limiting when it comes to, say, logic.
16:43:08 <Botje> and the code that goed with it http://sial.org/pbot/22870
16:43:09 <lambdabot> Title: Paste #22870 from "Botje" at 213.118.64.61
16:43:21 <olliej> augustss: wow, you're right, that is much nicer
16:43:23 <ndm> either the monad tutorials actively stole knowledge from my brain, or monads are (to me) an unnatural concept
16:43:23 <Binkley> I found monads hard
16:43:24 <Pseudonym> You can imagine a universe with a different value for the speed of light, but you can't imagine one where modus ponens doesn't hold.
16:43:29 <Binkley> I found Haskell easy because I already knew Scheme
16:43:29 <Binkley> But
16:43:37 <Binkley> I still write Haskell as if I'm writing Scheme, a lot of the time
16:43:42 <xic> Botje: cool! another wmii user
16:43:52 <Botje> :)
16:43:55 <sorear> Botje: I'm pretty sure you knew, but ...  we have hpast
16:43:58 <sorear> +e
16:44:01 <Binkley> Pseudonym: that perspective in particular isn't original to Wadler
16:44:10 <Botje> sorear: yes, but I can't paste to it from the commandline with pbotutil.pl
16:44:12 <ndm> Binkley: how? i knew scheme first, but dropped every scheme habit the second i could
16:44:17 <Botje> maybe i'll look into fixing that next.
16:44:29 * olliej does back to bludgeoning objective-c
16:44:32 <Binkley> ndm: well, I haven't internalized a lot of the higher-order functions and my usual instinct is to just write a fold
16:44:34 * olliej hates obj-c
16:44:41 <sorear> Botje: we have a cat2hpaste - dunno where to get it though
16:44:46 <Pseudonym> Binkley: I agree, but I've seen him argue it in person.
16:44:47 <Philippa> monads took me a short while to get comfortable with as a user, and a while to get used to which ones were good for what (the folklore wasn't so common at the time)
16:44:50 <Binkley> where a more l33t person would use mapAccum or some other thing that would let me write something more concise
16:44:54 <Pseudonym> Others I have not.
16:44:54 <Philippa> implementing and thoroughly grokking was tougher
16:45:02 <sorear> @quote syntaxfree lift
16:45:03 <lambdabot> syntaxfree says: I'm overwhelmed. I mean, the entire financial modelling industry = liftM2
16:45:03 <Binkley> I also took a long time to understand monads other than the IO monad
16:45:08 <ndm> Binkley: oh, i still do that - maybe i haven't got over Scheme after all
16:45:17 <Binkley> then again, maybe it's OK
16:45:20 <Philippa> I guess State and variants were easier for you than [] and Maybe?
16:45:38 <Binkley> I was just looking at the GHC style guidelines recently and there was a comment like "don't over-generalize, it's better to have code that's easy to understand than to use as many abstractions as possible" :-)
16:45:47 <Philippa> heh
16:45:48 <Binkley> Philippa: yeah, State was easy. well, easy after months of being lost
16:45:54 <Pseudonym> I understood the list monad first, mostly because it was back in the days of monad comprehensions.
16:46:02 <Philippa> heh, figures
16:46:04 <Binkley> I never comprehended monad comprehensions
16:46:09 <sorear> Monads were easy.  I'm not sure how, but I just seem to innately grok abstract axiomatic mathematical structures.  wierd.
16:46:23 <Pseudonym> [ () | s <- getLine, putStrLn s ]
16:46:36 <Philippa> sorear: for that, I'm going to have to ask you what it /means/
16:46:39 <Binkley> I never even write list comprehensions
16:46:41 <dibblego> ?where liftM2
16:46:41 <lambdabot> I know nothing about liftm2.
16:46:45 <dibblego> ?doc liftM2
16:46:46 <lambdabot> liftM2 not available
16:46:49 <Binkley> I understand them, it just never occurs to me to use them
16:46:58 <Philippa> yeah, I don't do list comprehensions any more - been too long since I was working with sets, so they're not 'natural' for me
16:47:27 <Pseudonym> I generally only reach for them if I'm doing some kind of Cartesian product thing.
16:47:37 <Pseudonym> I rarely use do-notation if I know it's lists.
16:48:18 <Binkley> yeah, the only occasion when I have to think about the list monad is when I get my do-notation wrong and GHC gives me some type error message that assumes I'm trying to use the list monad
16:48:25 <Binkley> when in reality, I just left out a return, or added an extra one
16:48:28 <Binkley> I'm not as smart as GHC thinks I am
16:49:45 <Philippa> yeah, but to GHC you're a brain surgeon
16:50:04 <Binkley> GHC is smarter than me about most things
16:50:06 <gvdm_other> i'm pretty sure computer programmer is closer to the mark
16:50:09 <Binkley> most things that are within its domain, anyway
16:50:20 <Binkley> I don't expect GHC to do my laundry for me
16:50:57 <Philippa> yeah, we've got Java for that
16:51:29 <xic> is there a better way to write: foo x = let (Y y) = bar x in y
16:52:14 <Philippa> xic: arguably foo x | Y y <- bar x = y
16:53:31 <Anon4888> Y foo = bar    :)
16:53:32 <sorear> xic: foo = unY . bar
16:54:06 <sorear> where newtype Y = Y { unY :: ... }
16:54:15 <Anon4888> heh
16:54:32 <Anon4888> I was going to be impressed if Haskell came with an unY function :)
16:56:40 <audreyt> @tell ookk http://perlcabal.org/~audreyt/ghc-6.6-i386-apple-darwin.tar.bz2 has the .h
16:56:41 <lambdabot> Consider it noted.
16:57:20 <audreyt> @tell Igloo sorry, but ookk noticed the OpenGL .h was missing in addition to the .o and .a -- I've repackaged under http://perlcabal.org/~audreyt/ghc-6.6-i386-apple-darwin.tar.bz2
16:57:21 <lambdabot> Consider it noted.
16:58:10 <sorear> wow, cabal is so good perl is copying it! :p
16:58:37 <bd_> sorear: oh?
16:58:50 <bd_> oh, right, perlcabal XD
16:58:57 <sorear> bd_: wrt perlcabal.org, and emphasis on ":p"
16:59:01 <bd_> I think the perl one predates the haskell one, doesn't it?
17:00:47 <gotaku> Who made the new mandelbrot program?
17:01:12 <sorear> a committee
17:01:27 <sorear> dons, gotaku, someone I can't remember
17:01:37 <glguy> woohoo, beating ocaml
17:02:02 <sorear> sorear massively optimized nornagon's mandlebrot last week, possibly contributing ideas to the shootout entry
17:02:18 <gotaku> glguy: Overall?
17:02:24 <glguy> yeah
17:02:49 <Anon4888> The "language shootout" seems to be largely a "clever programmer shootout"
17:02:59 <Binkley> Anon4888: as it should be
17:03:04 <gvdm_other> well, haskell wins again ;-)
17:03:05 <Binkley> the language with the cleverest programmers wins
17:03:13 <Binkley> it takes a good language to attract clever programmers!
17:03:25 <Anon4888> Right, so for all we know perl has the best compiler ever
17:03:36 <Binkley> perl has a compiler?
17:03:39 <gotaku> Ocaml is still slightly ahead on full spu time.
17:03:41 <sorear> Binkley: yes
17:03:47 <siti> ruby is the fastest language ;)
17:03:53 <gvdm_other> i doubt it, its written in perl (not the pugs, actual perl)
17:04:03 <sorear> Binkley: bytecode iirc, but still it's not a pure interpreter
17:04:27 <gotaku> Full CPU time of course.
17:04:56 <sjanssen> ooh, we're almost tied with C++
17:05:04 <siti> link?
17:05:14 <sjanssen> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
17:05:16 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/lepfo
17:05:43 <glguy> @shootout
17:05:44 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
17:06:22 <sorear> there needs to be a "development time shootout"
17:06:26 <Binkley> heh
17:06:30 <Binkley> it's a lot harder to quantify that
17:06:35 <siti> yep
17:06:37 <glguy> when it comes to only considering memory usage, haskell does pretty well too
17:06:41 <Binkley> does time spent thinking about code in the shower count?
17:06:50 <glguy> best of all the languages you'd want to write a project in :)
17:06:51 <siti> lol
17:06:52 <sorear> Binkly: IIRC it's called the ICFP, and we've one three years going
17:06:57 <siti> someone else does that too?
17:07:07 <sorear> siti: me
17:07:13 <Binkley> sorear: the ICFP contest is great, but it's not exactly a realistic test
17:07:27 <gotaku> sorear: Define winning.
17:07:31 <Binkley> usually you have longer than a weekend to do your development
17:07:41 <sorear> gotaku: ask lambdabot
17:07:44 <Anon4888> Wow, GHC is currently 12x (or 20x) slower than g++?
17:07:45 <gvdm_other> 3 days aint it?
17:07:54 <gvdm_other> only on mandelbrot
17:08:00 <Anon4888> ya on mandelbrot I meant
17:08:06 <sorear> Anon4888: yup.
17:08:09 <Anon4888> which is why it's being worked on I suppose :)
17:08:18 <gotaku> Didn't the winners name 2D as their language of choice though? ;)
17:08:22 <Anon4888> Can you state briefly what's the problem?
17:08:23 <sorear> gotaku:
17:08:28 <sorear> @topic-tell #haskell
17:08:28 <lambdabot> ["The Haskell programming language: the lambda revolution will be declared!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/
17:08:29 <lambdabot> yowkle","The language of ICFP winners 3 years running"]
17:08:53 <dons> ok. the regex-dna entry has been updated
17:09:04 <Anon4888> As in, what is it that Haskell is bad at there?
17:09:06 <dons> (on the shootout)
17:09:24 <Anon4888> Haskell = GHC
17:09:34 <dons> about 10x faster :)
17:09:38 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
17:09:40 <lambdabot> Title: regex-dna benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/mgdtj
17:09:57 <dons> great memory usage too
17:10:04 <siti> how is tcl so fast :S
17:10:13 <dons> tcl regex lib
17:10:18 <siti> ok
17:10:21 <dons> it all comes down to what regex algos you're using
17:10:25 <siti> the memory usage sucks on it though
17:10:30 <dons> haskell using the regex-tre binding would likely do very well
17:10:46 <siti> wow haskell owns at memory usage !
17:10:46 <dons> yeah, so we move up 1 spot overall, ahead of ocaml now
17:11:01 <dons> ghc is pretty zippy, and bytestrings help a *huge* amount to keep down usage
17:11:47 <siti> pfft cheats using pcre
17:11:53 <ozone> dons: yay for artificial benchmarks
17:12:09 <sjanssen> dons: tracked down the mandelbrot issues yet?
17:12:13 <gotaku> Wow haskell uses the least memory of all other listed programs for regex-dna.
17:12:22 <siti> gotaku: yes, it's amazing :)
17:12:29 <dons> sjanssen: done a lot better
17:12:37 <dons> but still not 100% sure its sorted
17:12:37 <gotaku> Surprisingly it's also the largest.
17:12:39 <Binkley> dons: if I wanted to understand why it is that this bytestring stuff has such a big impact, would your PADL paper be a good place to start?
17:12:56 <dons> Binkley: exactly. page 2 of that paper :-)
17:13:01 <Binkley> ok :-)
17:13:10 <gotaku> PADL paper?
17:13:16 <ozone> Binkley: in a nutshell, bytestring uses contiguous memory, like a C array, whereas [Char] is a list of pointers to Char
17:13:42 <dons> ozone: I think they're not so artificial. it took a lot of work to get haskell to the point re. speed and memory that it is now. it really pin pointed particular areas
17:14:01 <dons> they certainly reflect real world issues
17:14:17 <ozone> dons: oh, i think the benchmarks are quite useful for nailing down particular performance problems
17:14:20 <dons> yeah
17:14:28 <Binkley> So it was the benchmarks that led to this work on ByteStrings?
17:14:36 <dons> numerics is really the last hold out in ghc now
17:14:46 <ozone> i still maintain my opinion that they're dangerous because there are far too many idiots who will decide that a language is or isn't "good" based on the benchmarks
17:14:48 <dons> Binkley: it did inform the implementation somewhat
17:15:01 <dons> ozone: ah well. as long as good languages do well eh ? ;)
17:15:05 <Binkley> I mean, was that the original motivation?
17:15:10 <dons> poor erlang
17:15:16 <ozone> i've converted a few people to o'caml who still shy away from haskell because of that stupid alioth shootout
17:15:46 <ozone> dons: right, and things such as erlang or lua don't do well at all, despite being wonderful languages for the domain they're addressing
17:16:10 <Binkley> well, I wouldn't call them "dangerous" because of that
17:16:12 <ozone> i had a long flamewar with one of the guys who wrote those benchmarks :)
17:16:18 <dons> well, erlang does well on concurrency
17:16:22 <dons> that's its domain, right? ;)
17:16:27 <Binkley> because even if you got rid of the benchmarks, people would *still* come up with dumb reasons to choose a language
17:16:29 <agocorona> what about k-nucleotide?
17:16:45 <dons> k-nuc is a very intereseting problem
17:16:50 <dons> you are required to use a mutable hashtable
17:17:06 <dons> even though a Trie ByteString beats all in practice, we're forced to use a mutable array
17:17:08 <ozone> dons: which was a thing added recently.  and still gives you little insight into why erlang kicks ass at it -- a cheap threading model is only part of the picture
17:17:35 <ozone> dons: right, another problem with the benchmarks :)
17:17:55 <dons> the languages you expect to do well at concurrency do do well though. so seems reasonable.
17:18:00 <ozone> i think when the author of the benchmark confesses to having to rewrite the haskell program because it statically computed the answer, the benchmark is flawed
17:18:05 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
17:18:07 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
17:18:19 <dons> ozone: no, there were some benchmarks that assumed strictness
17:18:28 <siti> a multicore machine would rock, to show off erlang and haskell's concurrency
17:18:47 <xic> isn't haskell also supposed to have good cheap threads?
17:18:54 <dons> xic, it does. see the above link
17:18:55 <sjanssen> xic: yes
17:19:09 <dons> haskell dominates the two concurrency benchmarks, and has done for the last year and a bit
17:19:27 <siti> dons: what two are they?
17:19:49 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all and http://shootout.alioth.debian.org/gp4/benchmark.php?test=message&lang=ghc&id=0
17:19:50 <ozone> dons: shrug.  i agree that the benchmarks are useful, it's just open to far too much misinterpretation.  i guess blaming the benchmark authors for that is the wrong thing to do, though
17:19:51 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
17:20:27 <dons> i think you get enough useful info to be worth while. i.e. [Char] sucks, posix regex sucks, cheap concurrency == good, bit packing Bool arrays good
17:20:33 <ozone> and Binkley's right... despite D placing third overall with the default ratios, i don't know anyone sane that would use it for a real project
17:20:37 <xic> dons: do you know why c is so slow in that example?
17:20:46 <dons> slow threads
17:20:53 <glguy> os level concurrency
17:20:55 <dons> (can you write fast posix thread code??)
17:20:56 <glguy> slow
17:20:56 <siti> it uses pthreads
17:22:43 <dons> also, the shootout scores for ghc have reflected real world improvements in various aspects of the libs and compilers
17:22:54 <dons> so if you were following from afar you would notice ghc getting better.
17:23:09 <dons> it is easier to write fast haskell than it was 2 years ago
17:23:23 <ozone> of course dons, i entirely agree with that
17:23:26 <xic> dons: would STM be suited to that chameneos problem?
17:23:42 <dons> and ruby sucks. that's clear
17:23:46 <dons> 'nuf said.
17:23:52 <dons> mwhahaha
17:23:59 <ozone> btw dons, interesting article for you: http://patricklogan.blogspot.com/2007/02/misguided-road-not-to-be-travelled.html
17:24:04 <lambdabot> Title: Making it stick.: Misguided: The Road Not To Be Travelled, http://tinyurl.com/2n7gbd
17:24:04 <ozone> patrick logan goes to town on STM
17:24:16 <ozone> (with cale gibbard responding)
17:24:20 <ozone> (and sigfpe)
17:24:59 <gvdm_other> when you do x <- someFunc "arg", would it be accurate to say that you are adding the result of someFunc "arg" to the state being carried in the "do" construction and making it accesible via x?
17:25:05 <dons> yeah, seen it.
17:25:08 <ozone> would be fun to get him + spj together in a room to argue about it :)
17:25:35 <agocorona> n-body : It seems that haskell is not the best thing for numerical computation
17:25:47 <Botje> gvdm_other: you're executing the action that "someFunc arg" embodies
17:25:48 <Binkley> so who's this "patrick logan" person?
17:25:54 <dons> if STM becomes a bottleneck, you'll just see distributed haskell rise to the fore
17:25:54 <ozone> agocorona: it will be, once dons finishes ByteNumerics :)
17:25:55 <Botje> and binding the return value to x
17:26:11 <dons> agocorona: yeah, Double math is hard, and I'm not sure why yet. gcc doesn't like us.
17:26:14 <allbery_b> seems to me that on the one hand, he's right, but on the other hand, the real world isn't quite so amenable to shared-nothing
17:26:17 <ozone> dons: well, STM is a ton better than no STM, that's for sure
17:26:21 <dons> yeah.
17:26:30 <dons> but its reasonable to say its the last hope for shared state concurrency
17:26:35 <allbery_b> ...so you end up needing some way to share state
17:27:05 <sorear> `par` ftw
17:27:22 <sorear> (`par` ftw) -- oops invalid section
17:28:00 <Botje> gvdm_other: what someFunc does to the state (side effects) and what it returns aren't necessarily related.
17:28:04 <Cale> STM isn't the only concurrency abstraction you'd use anyway. It's the foundation on which you build others.
17:28:22 <agocorona> STM is greath
17:28:39 <ozone> Cale: i think patrick (who's normally quite sane) is doing an RMS and declaring that share-nothing is the only one true path
17:28:40 <Cale> Locks and condition variables are a ridiculous way to form a basis for concurrency abstractions.
17:29:07 <SamB> even worse: they aren't too compatible between OSes...
17:29:14 <Cale> If you're *really* sharing nothing, your threads do no communication whatsoever.
17:29:32 <Cale> As soon as you have message passing, that's sharing information between threads.
17:29:43 <SamB> sharing nothing means fork!
17:29:48 <sorear> Pipes are very natural in the real world ... but real cpus /= real world, and real cpus like shared memory
17:29:48 <Cale> You're taking the state of one thread and making another thread's state depend on it.
17:30:19 <allbery_b> pipes are shared memory via kernel abstraction
17:30:35 <SamB> allbery_b: ... potentially
17:30:35 <dons> hehe, with the regex lib fixed, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=python  becomes funny
17:30:38 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2deng4
17:30:49 <Cale> It doesn't really solve very much, except that it allows for threads to limit access to their state relative to the shared-mutable-variables-with-unsafe-locks approach.
17:30:51 * SamB wonders how often that actually works out
17:30:53 <dons> only k-nuc allocates too much now
17:31:00 <sorear> allbery_b: when I say pipes I'm thinking at the level of transistors and wires
17:31:13 <allbery_b> ah.  bit-pipes :)
17:31:20 <Cale> While that's good relative to locks and CVs, it doesn't really compose much better.
17:31:32 <dons> this shows the numerics issue: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=sbcl
17:31:35 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/27u4hk
17:31:51 <ozone> Cale: part of the problem is that STM is new; message-passing's been around for a while (and has been proven to work successfully to build large systems)
17:31:52 <Philippa> *reads up*
17:31:54 <dons> (and that SBCL is a memory hungry monster)
17:32:08 <Philippa> I think Patrick's forgetting that within Haskell you can force "grunt" coders to work within a non-STM monad of your choice
17:32:09 <Cale> You run into the same issues of having to rework components which are already working in order to make them work together.
17:32:24 <Philippa> that is, Haskell having STM doesn't necessarily have to cause the same kinds of problems that Java having it would
17:32:40 <ozone> Cale: the verdict's still out about whether STM will solve that, though
17:32:43 <Cale> Well, in Java, you'd need to do a whole lot more work to support STM.
17:32:44 <sorear> unfortunately *large* systems use pipes becuase *large* systems are distributed and have to deal with the real world
17:32:45 <Philippa> if you want nothing but message-passing, with an underlying STM implementation, you can have it
17:32:59 <sorear> *large* systems have disgusting mismatch of scales
17:33:01 <ozone> Philippa: the article in question is talking about implementing transactional memory in the mainstream languages
17:33:11 <Cale> ozone: Well, it certainly does a better job of it than these other systems.
17:33:18 <Philippa> ozone: sure. It also complains about Haskell going down the STM path though
17:33:40 <Philippa> we tend to get away with our own madnesses in a way the mainstream languages can't
17:33:50 <Philippa> we really *can* do imperative code better ;-)
17:34:02 <xic> didn't someone add expirimental STM support to c#?
17:34:04 <Cale> If you implement STM in Java, you're going to need to extend the type system in some fairly significant ways.
17:34:10 <ozone> Cale: than message-passing?  i dunno.  not proven in the field == not proven, as far as i'm concerned
17:34:36 <Cale> ozone: You can see it even in fairly small examples.
17:35:07 <Cale> It doesn't take anything very complicated to start seeing STM give compositionality benefits.
17:35:11 <allbery_b> well, except that sometimes it takes large examples to point out flaws
17:35:38 <Philippa> you certainly get a very different kind of compositionality with message-passing
17:35:58 <Cale> I'm fairly sure you could show that any flaws in the STM model would also be flaws in message-passing.
17:36:08 <ozone> Cale: sure, but there may be other issues.  functional languages do very well in small examples, but lack of extensible data types is a really big issue when designing bigger systems
17:36:21 <Cale> You can implement message-passing safely on top of STM.
17:36:33 <xic> Cale: so you're saying that this patrick logan guy is completely off his noodle?
17:36:38 <Cale> xic: yes.
17:37:09 <Binkley> he sure sounds like he is
17:37:12 <dibblego> link?
17:37:17 <Cale> http://patricklogan.blogspot.com/2007/02/misguided-road-not-to-be-travelled.html
17:37:18 <Philippa> ozone: most of those I suspect are going to be dataflow-related
17:37:19 <lambdabot> Title: Making it stick.: Misguided: The Road Not To Be Travelled, http://tinyurl.com/2n7gbd
17:37:21 <ozone> so what do you advocate, cale?  you believe using STM as a programming paradigm will be better (scale better, compose better, etc) than using message passing?
17:37:35 <Philippa> I suspect they'll have solutions not unakin to the way we use State, Reader etc monads
17:37:52 <Cale> ozone: Yep. I hope it's not the last abstraction we come up with, but it's a much better approach as far as I can see.
17:37:58 <Philippa> with you on extensible datatypes btw - though you're hopefully aware it's also a problem under attack in multiple directions as a result
17:38:16 <ozone> logan's a smart guy.  a bit too much in favour of dynamic typing, but in general, he's pretty cluey
17:39:09 <ozone> Cale: right.  let's hope that STM gets into the mainstream sooner rather than later... at any rate, it's going to be a ton better than our current piss-poor mainstream way of dealing with concurrency (shared mutable state with no transactions)
17:39:16 <Cale> I can't decide whether it's worthwhile to respond again.
17:39:16 <Philippa> for in-the-field work on large enough systems I'd quite probably have been in favour of dyntyping much of the time too
17:39:32 <ozone> Cale: i wouldn't bother, he seems quite RMS-like on his share-nothing idea :)
17:39:48 <Cale> Message passing *is* sharing state.
17:39:52 <ozone> Philippa: good point
17:40:02 <agocorona> The problen with STM is how to do IO in a STM block.
17:40:08 <ozone> Cale: you're missing the point, he's talking about using it as a programming model
17:40:22 <ozone> obviously there's state shared underneath somewhere
17:40:32 <Cale> agocorona: You don't, though you might queue IO to occur when the transaction commits.
17:40:34 <Philippa> Cale: it's rather limited in and of itself, though
17:40:57 <ozone> i think you & patrick both know that underneath, it's just all atomic test-and-sets :)
17:40:58 <Philippa> and building ordinary shared state on top of it again forces you to implement at least some of the safeguards
17:41:18 <Philippa> considered STM on top of message-passing? :-)
17:42:23 <Cale> ozone: What I'm saying is that message passing essentially takes the state of one thread and makes it depend on the state of another. It's just an indirect form of shared state, and while that indirection can help the user control exactly how things are shared, you still end up implementing either transactional or locking semantics on top of it.
17:42:35 <Cale> (In order to do that)
17:43:07 <Philippa> locking comes more or less for free though
17:43:18 <Cale> Sort of, it depends.
17:43:23 <Philippa> true
17:43:28 <Philippa> depends how long you want the lock available for
17:44:00 <Cale> Right, as soon as you need one client thread to have exclusive access to a piece of state for more than one message, you need something more.
17:45:05 <ozone> Cale: a message-passing model generally doesn't generally do that, though
17:45:06 <Cale> Either you write another thread which interprets transactions and acts as a marshaller to talk to the original thread object in the right order, or you implement locking, or you end up modifying your original thread.
17:45:23 <Cale> Well, that's what I'm talking about with regard to loss of composability.
17:45:49 <xic> btw, what happens when two threads simultaneously access the same IORef?
17:45:55 <ozone> ah, now we're getting somewhere
17:46:01 <Philippa> I think only having STM is, at least to start with, also a loss though
17:46:07 <dons> you use an MVar , xic :-_ (or atomicModifyIORef)
17:46:09 <Philippa> message passing gives you pipes to glue together
17:46:19 <xic> dons: yeah, but what happens if you don't?
17:46:27 <dons> there's no locking.
17:46:31 <dons> so you've got a race
17:46:32 <ozone> Cale: usually in message-passing systems you just compose the state internally, and treat the messages as atomic to deliver all the information necessary
17:46:41 <Cale> Philippa: Oh yeah, you certainly need other data structures and abstractions built on top of it.
17:46:41 <ozone> there's no multi-phase preparation going on
17:47:08 <ozone> rather, there is, but not at the message (i.e. state-sharing) level
17:47:42 <Cale> ozone: Right, so unless you're careful to make your messages composable from the beginning, your clients will have problems as soon as they want to communicate anything which is compound in terms of your API.
17:48:24 <Cale> You can, if you're careful, ensure that things are composable, but it's sort of like implementing STM for yourself in a broken way.
17:48:35 <Philippa> I don't know /broken/ is necessarily true
17:48:37 <ozone> sure, but that's not a usual situation
17:48:40 <Cale> well, maybe not
17:48:52 <Philippa> sometimes transaction semantics aren't appropriate
17:48:58 <Philippa> you can't unfire the nuke
17:49:09 <Cale> You're unlikely to spend as much effort on it as was put into the compiler though.
17:49:23 <Philippa> so put it into a library instead
17:49:29 <Philippa> no biggie
17:49:39 <Cale> Well, sure. So you have transactions which communicate IO to be performed when they finish.
17:49:49 <Philippa> I believe erlang's got exactly that in mnesia?
17:49:57 <Philippa> well, rather more than that
17:50:24 <Philippa> now *that* sounds suspiciously non-compositional
17:50:42 <ozone> meh, i'm gonna grab me some lunch
17:50:48 <ozone> thanks for the discussion cale, philippa
17:50:58 <ozone> continued at another time, perhaps
17:51:00 <Cale> Philippa: what, queuing IO?
17:51:23 <Philippa> hmm. I guess in fairness you just end up with an awful lot of short transactions
17:51:23 <Cale> Sure, it has its problems, but those are not easy problems in any system.
17:51:49 <Cale> Oh, STM transactions are not meant to be extremely complicated.
17:53:58 <Philippa> if you don't need the transactional semantics too often whereas you're doing message-passing a lot then that sure has its implications though
17:55:40 <Philippa> FWIW, I've used message-passing in anger and strongly thought about STM for a different system I had in mind - one where I was pretty intent on not going distributed
17:55:55 <coffee-mug> ok, I just made emacs customizations that make it perfect
17:56:07 <coffee-mug> in particular, I made some emacs commands available even in viper mode
17:56:09 <Philippa> you used rm?
17:56:16 <coffee-mug> now I have emacs and vi in one package
17:56:21 <coffee-mug> the best of both worlds :-D
17:58:54 <thedward> viper didn't quite do it for me last time I tried it out.
17:59:15 <thedward> though I am gett frustrated with vim's limitations as far as extensibility goes
17:59:23 <thedward> s/gett/getting/
17:59:30 <ddarius> coffee-mug: Unfortunately, w.r.t. scripting languages the best of both worlds is... underwhelming.
18:00:36 <thedward> I was trying to make Yi go, but hs-plugins doesn't seem to play well with ghc-6.6 yet
18:01:51 <coffee-mug> thedward: it takes some time getting used to
18:02:05 <coffee-mug> you also need to do some major customizations to viper
18:02:12 <coffee-mug> because out of the box it isn't really useable
18:02:23 <coffee-mug> I had no choice because emacs was killing my left hand
18:02:30 <coffee-mug> but now I'm a happy camper :)
18:02:39 <coffee-mug> all I need now is to learn dvorak
18:02:44 <coffee-mug> :)
18:03:38 <fons> hi all
18:03:53 <fons> I'm gatting this error from ghc
18:04:12 <fons>     Constraint is no smaller than the instance head
18:04:12 <fons>       in the constraint: PortIndex a
18:04:19 <thedward> coffee-mug: I've been typing dvorak for years now.
18:04:37 <coffee-mug> thedward: do you like it?
18:04:46 <coffee-mug> thedward: I know a few people that swear by it
18:04:50 <Procyon_> coffe-mug: make sure you remap caps-lock to ctrl.  It doesn't kill your hand near as much that way.
18:04:59 <fons> any idea about why a does that happen
18:05:04 <audreyt> fons: try {-# GHC_OPTIONS -fallow-undecidable-instances #-}
18:05:29 <fons> audreyt, that should work, but why does ghc complain?
18:05:36 <thedward> coffee-mug: It works for me. I'm not sure how much difference it actually makes, but I get a kick out of watching folks expression when they try and use my keyboard (I've rearranged all the keys)
18:05:41 <audreyt> fons: for deep theoretical reasons, http://research.microsoft.com/%7Esimonpj/papers/fd%2Dchr/
18:05:43 <lambdabot> Title: Simon Peyton Jones: papers
18:05:46 <augustss> fons: you'll have to read simon's paper
18:06:21 <audreyt> basically, GHC complains because it's unsure if the compilation will take an infinite amount of time
18:06:42 <audreyt> -- which is silly; diverging compilation should be just accepted as a fact of life...
18:06:53 <coffee-mug> thedward: so you'd say you didn't notice egronomic benefits?
18:06:54 <fons> but there is no restriction by haskell98 right?
18:07:02 <dons> hmm. changing -optc-O3 to -optc-O1 and mandelbrot runs 2x faster ...
18:07:06 <dons> gcc--
18:07:24 <augustss> fons: whatever you are doing is not legal H98
18:07:31 <audreyt> fons: H98 can't even express it
18:08:05 <allbery_b> dons: I thought -O3 (and to a lesser extent -O2) were known to do some "optimizations" that could pessimize instead
18:08:19 <dons> yeah. though -optc-O3 is on by default on the shootout...
18:08:20 <Philippa> audreyt: not everyone's happy accepting divergence all the time, and some of them have good reason. They know where the flag is :-)
18:08:20 <allbery_b> the gcc docs warn about it
18:08:21 <thedward> coffee-mug: well, I've never had any wrist problems from typing; I started with dvorak when I was 19 and am 31 now, but I might not have anyway. Once I got up to speed I did type a lot faster, but then again I spent more time trying to type properly with dvorak than with qwerty.
18:08:24 <dons> so there could be some issues there
18:08:31 <fons> augustss, it is perfect legal haskell 98
18:08:47 <augustss> fons: what does it look like?
18:09:03 <fons> but I passed the -fglasgow-exts to ghc cause I'm using extensions in other modules
18:09:11 <audreyt> Philippa: sure, it's merely a question of default policy :)
18:09:25 <augustss> fons: show me the instance declaration
18:09:47 <fons> I'll use hpaste, hold on a second
18:09:59 <ddarius> coffee-mug: I've also been typing Dvorak for a while.  I noticed no major speed difference but it is noticeably more comfortable for me.
18:10:25 <SamB> ddarius: perhaps because you are a programmer?
18:10:30 * augustss can't touch type, but with Haskell it doesn't matter.
18:10:34 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x) in f4
18:10:42 <SamB> typing isn't supposed to be the issue when you program
18:10:49 <lambdabot> thread killed
18:10:56 <Binkley> one time I tried to switch to Dvorak and I took apart my keyboard and rearranged all the key caps
18:10:58 <Binkley> that was a mistake
18:11:04 <Philippa> augustss: heh. One of these years I'll type up that article about why Haskell's a good language for me as someone who has a high thinking time:doing time ratio...
18:11:10 <ddarius> SamB: I don't think so w.r.t. the comfort.
18:11:23 <SamB> ddarius: I meant, typing *speed*
18:11:34 <xpika> how do i change my keyboard to dvorak?
18:11:38 <Philippa> I once had someone walk into a chan I was in having done that but not found where to change the layout in software
18:11:55 <siti> the issue with different layouts is the hotkeys all suck
18:12:03 <SamB> xpika: go into the gnome control center and...
18:12:10 <siti> also programming and unix command line really rely on the qwerty layout
18:12:11 <ddarius> coffee-mug: I can also now touch type both QWERTY and Dvorak at a decent rate.  (Originally, after I had switched my QWERTY suffered significantly.)
18:12:34 <ddarius> xpika: What OS are you using?
18:12:41 <xpika> linux
18:12:53 <SamB> what stuff are you running?
18:12:56 <ddarius> siti: Change them.  I have to munge vim's default bindings to get them back to acceptable.
18:12:59 <siti> stuff like "ls" is designed to be done by only using the home keys :(
18:13:23 <ddarius> xpika: For the console or the whole system there is setkblayout or something like that, I've forgotten.
18:13:41 <ddarius> xpika: For KDE or Gnome you should be able to find it without too much searching.
18:13:48 <thedward> console is loadkeys, for X it is setxkbmap
18:14:02 <thedward> (or use the system preferences panel of your desktop environment)
18:15:30 <thedward> If I had it to do over again, I don't know if I'd bother with dvorak, but neither do I have any interest in switching back to qwerty. (I can type qwerty still, but I never got back up to full speed on it)
18:15:30 <sorear> how do you free memory allocated with Foreign.Marshal.Array.mallocArray?
18:15:31 <ddarius> Binkley: I've never rearranged my keyboard, but then you should be touch typing so why would you need to?
18:15:53 <ddarius> thedward: Bah, I mashed them together.  It's been probably two or three years.
18:16:10 <gvdm_other> thedward: another dvoraker!
18:16:30 <sorear> back on topic ... I have a FFI question
18:16:34 <sorear> how do you free memory allocated with Foreign.Marshal.Array.mallocArray?
18:16:46 <siti> spammer :P
18:16:47 <sorear> the docs don't say
18:16:51 <ddarius> sorear: Isn't there a generic free?
18:16:54 <sorear> I'd guess free
18:16:56 <thedward> someone wrote a program that would watch your typing habits for awhile (as long as you wanted) and a another program to analyze the log and come up with an optimal keymap based on your acutal usage of keys.
18:17:04 <Binkley> ddarius: I touch-type now
18:17:08 <Binkley> in those days, I couldn't
18:17:30 <Binkley> I don't understand people who don't touch-type, actually
18:17:34 <Binkley> I never learned to touch-type
18:17:41 <Binkley> I started using a computer and eventually, my fingers taught themselves
18:17:45 <siti> I type subconciouslly :)
18:17:48 <Binkley> yeah
18:17:59 <xpika> i not fin kees!!!!!
18:18:50 <thedward> I have a cousin who still looks at the keyboard when he types, but he can type around 160 wpm
18:18:53 <resiak> Fellow Dvorakkers!  http://interglacial.com/~sburke/tpj/as_html/tpj20.html is fun.
18:18:54 <emu> you could try Colemak
18:18:54 <lambdabot> Title: Simulating Typos with Perl
18:18:58 <ddarius> xpika: What I did when I was first learning Dvorak was have a pdf with the layout up.  Rearranging the keys would be helpful for learning.
18:19:01 <hpaste>  fons pasted "Instantiation error" at http://hpaste.org/382
18:19:13 <emu> it's supposed to be better than Dvorak and tries not to destroy too many hotkey bindings
18:19:15 <Binkley> Dvorak users of the world flgkd!
18:19:25 <xpika> :(
18:19:26 <ddarius> thedward: Looking at the keyboard isn't going to slow you down.
18:19:39 <fons> augustss, there we go, it must be something really stupid but I need to get some sleep
18:20:18 <allbery_b> um.  making a class an instance?
18:21:25 <Anon4888> 160 wpm? Is that like "in at in at in at in at in at in at... ?
18:21:48 <siti> yeah 160wpm is a world record ;)
18:21:48 <emu> n'at
18:22:01 <thedward> siti: the world record I think is around 220 or so
18:22:12 <Anon4888> i a i a i a
18:22:23 <siti> what layout does the world record holder use?
18:22:24 <siti> I wonder
18:22:27 <siti> I'll look it up
18:22:36 <emu> it was some secretary
18:22:58 <allbery_b> not a court recorder?
18:22:59 <Anon4888> The record holder has a keyboard with whole words on each key
18:23:08 <siti> cheats!
18:23:09 <emu> yea stenotypists are different
18:23:19 <thedward> siti: unless its in chinese
18:23:28 <emu> they use a code
18:23:29 <sorear> "If any of the allocation functions fails, a value of Ptr.nullPtr is produced." -- wtf?  I thought we had proper exceptions here!
18:23:31 <gvdm_other> probably qwerty, if it was some office and she was typing up stuff, would have been standard far office equipment shed of trained on
18:23:41 <siti>  Dvorak Simplified Keyboard
18:23:50 <siti>  Barbara Blackburn if anyone cares
18:23:51 <gvdm_other> yeah?
18:23:56 <emu> Dvorak predates computers
18:24:03 <ddarius> Someone reply to this for me, ok? http://lambda-the-ultimate.org/node/2030#comment-24993  It's straight forward enough, I just don't feel like it right now.
18:24:05 <lambdabot> Title: Termination Checking with Types | Lambda the Ultimate
18:24:07 <Anon4888> The guy or the keyboard layout?
18:24:10 <thedward> colemak looks interesting, but if I was going to switch again, I'd won't something specfically optimized for programming in addition to English.
18:24:17 <emu> the layout
18:24:26 <allbery_b> they keyboard layout was originally proposed for typewriters
18:24:43 <emu> i thought about doing Colemak, maybe after the semester
18:24:55 <siti> yeah I am looking at it now
18:24:59 <siti> it looks much better than dvorak
18:25:03 <siti> for hotkeys and programming
18:27:03 <Anon4888> So I assume the language shootout has rules against embedding the solution is an giant _asm block...
18:27:39 <Anon4888> If not I have a great idea about how Haskell could at least tie gcc...
18:28:45 <sorear> haskell doesn't have asm
18:28:48 <siti>  'L' and 'S' form a frequent same-finger digraph on the right pinky. Same-finger for the pinky is very rare in Colemak. In particular, Unix commands such as 'ls -l' are very uncomfortable to type.
18:28:49 <siti> :D
18:28:58 <Philippa> sorear: it doesn't need to
18:29:13 <sorear> best it has is unsafeCoerce# "machineCode"#
18:29:16 <Philippa> all it has to do is embed the actual machine code and link it in somewhere
18:29:47 <SamB> what, with foreign import dynamic?
18:29:54 <sorear> wrapper!!
18:29:58 <allbery_b> unsafeCoerce# to a function type?
18:30:03 <sorear> no dynamic sorry
18:30:38 <SamB> I'm assuming you'd just convert the Addr# of a packed string to a pointer in the usual way?
18:30:41 <allbery_b> (presumably code in a bytestring or unboxed array)
18:31:08 <SamB> and then use a foreign import dynamic to treat it as a C-compatible function
18:35:31 <gotaku> Hm, I still don't really understand the concept of lifting thing into a monad.
18:36:31 <Anon4888> Philippa: I just saw your "impure thoughts: part 1" and had a question:
18:36:41 <Philippa> go for it
18:37:05 <Anon4888> The way you've written your code the AST is parsed out "first" and then compiled
18:37:25 <Anon4888> Do you know if a compiler like GHC can optimize that to not load the whole AST at once?
18:37:52 <Anon4888> with some kind of lazy fold optimization...
18:38:09 * ddarius would have to look again, but would this be a fusion like optimization.
18:38:18 <SamB> I don't think so
18:38:34 <SamB> thats more of a problem for XMLy stuff, I think, though
18:38:48 <Philippa> you want it to just not do the whole parse at once? You need to finish the pass before it generates the final executable anyway
18:39:06 <Philippa> that is, GHC treats its stages strictly AFAIK
18:39:33 <SamB> Philippa: I'm sure
18:39:33 <Philippa> no doubt you could do it lazily if you wanted, it'd be fairly trivial to do in a lisp for example
18:39:50 <SamB> how would it know when to stop them if it didn't look at the results?
18:39:53 <Philippa> "could" not necessarily meaning "with GHC as it stands"
18:40:26 <Philippa> point, they do IO so it really can't be lazy with them
18:40:40 <Anon4888> That's what I was interested in
18:40:49 <dino-> gotaku: Thinking about it in the container way, it's like you have something in a monad: m a  But you have a function of type a -> b
18:41:04 <Philippa> you might want to consider using hs-plugins and TH together
18:41:04 <Anon4888> It only does input and then processing
18:41:05 <dino-> gotaku: liftM can make that function m a -> m b
18:41:26 <dino-> @type liftM
18:41:29 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
18:41:37 <Philippa> if the parser's lazy (parsec can't be, a different one could) it could generate the AST as-needed
18:41:48 <Philippa> but it's still all going to be demanded before the stage's finished
18:42:06 <Philippa> well, unless your AST-to-code function's not strict :-)
18:42:31 <Anon4888> hmm
18:42:37 <allbery_b> :t liftM (subtract :: Int -> Int)
18:42:39 <lambdabot>     Expecting a function type, but found `Int'
18:42:39 <lambdabot>       Expected type: Int -> Int
18:42:47 <allbery_b> hm
18:42:59 <fons> can someone check this error? http://hpaste.org/382
18:43:05 <allbery_b> :t liftM subtract
18:43:07 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m (a1 -> a1)
18:43:08 <ddarius> Philippa: Exactly.
18:43:14 <allbery_b> oh, duh
18:43:21 <gotaku> dino-: Can you give me an example?
18:43:23 <fons> why is this instantiation ilegal? instance PortIndex a => SubPort a where
18:43:26 <allbery_b> :t liftM (+1) -- try not being so fancy
18:43:28 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m a1
18:43:28 <ddarius> Philippa: Also pipelining behavior could result.
18:43:49 <allbery_b> fons: an instance is a type, not a typeclass
18:43:56 <allbery_b> SUbPort is a typeclass
18:44:02 <Philippa> ddarius: sure, and that's the most useful possibility for laziness there
18:44:11 <allbery_b> at least, if this is the same thing as before
18:44:17 <dino-> Has lambdabot always taken : commands like the interpreter?
18:44:40 <fons> allbery_b, maybe I'm not writing it properly
18:45:10 <fons> allbery_b, I want an SubPort instance of a given that a is a PortIndex
18:46:03 <dons> sjanssen: around? want to try out  a really fast mandelbrot (I think I sorted it out this time!)
18:46:09 <ddarius> Philippa: Most useful.  In theory, though, if the compiler were dynamic you could end up not having certain code compiled at all.  By prodding the parser right you could make this rather handy (e.g. lazily compiling exception handlers).
18:46:41 <hpaste>  dons pasted "mandelbrot: don't let gcc break things!" at http://hpaste.org/383
18:47:10 <ddarius> Philippa: Albeit, that'd be too fragile for my tastes.
18:47:22 <Philippa> heh, yeah
18:48:04 <Philippa> well, it could potentially be useful for performance tweaking if you eg specialise lazily based on significant demand
18:48:14 <Philippa> (thus avoiding code explosion)
18:48:42 <allbery_b> fons: no idea
18:49:59 <dino-> I'm having trouble coming up with something quick and practical to show off liftM.
18:50:33 * fons wonders why instance PortIndex a => SubPort a where ... isn't correct
18:50:48 <ddarius> dino-: No re your lambdabot question (though I may be projecting far too far back in time for your question).
18:51:14 <dino-> ddarius: Last May
18:52:01 <ddarius> dino-: Can't help you there.  I was off #haskell from before then until very recently.
18:52:08 <allbery_b> fons: afaik to subclass a class you do it in the class header, but you'd need -fallow-undecidable-instances -fallow-overlapping-instances to have SubPort and SubPort-that-is-also-PortIndex
18:52:43 <ddarius> dino-: As to your other question, liftM is more convenient than some awesome thing.  It's just a shortcut.
18:52:50 <allbery_b> that is, class PortIndex a => SubPort a where ...
18:53:00 <allbery_b> (also requires -fglasgow-exts)
18:53:50 <fons> allbery_b, so  "PortIndex a => SubPort a" is not proper Haskell98?
18:53:54 <ddarius> dino-: It lets you use an applicative syntax more often which most Haskellers (surprise!) prefer.
18:54:03 <allbery_b> not in a class IIRC
18:54:06 <allbery_b> I may be wrong there
18:54:13 <fons> allbery_b, what do you mean by "do it in the class header"
18:54:14 <allbery_b> instances are ok
18:54:23 <allbery_b> <allbery_b> that is, class PortIndex a => SubPort a where ...
18:54:27 <allbery_b> not in the instance
18:54:36 <allbery_b> instances are types, not typeclasses
18:54:45 <SamB> :t was added recently
18:54:46 <dons> gotaku: around?
18:54:47 <lambdabot> Not in scope: `was'
18:54:47 <lambdabot>  
18:54:47 <lambdabot> <interactive>:1:4: Not in scope: `added'
18:54:58 <dons> i think we've fixed the mandelbrot issue.
18:55:01 <dons> and i blame gcc!
18:55:06 <gotaku> dons: Yep.
18:55:10 <SamB> I'm not aware of any other : commands that lambdabot supports...
18:55:26 <allbery_b>  :t, :k
18:55:31 <allbery_b> :k Maybe
18:55:33 <lambdabot> * -> *
18:55:34 <gotaku> dons: What's the problem?
18:55:35 <dons> gotaku: can you give this a run on your box, http://hpaste.org/383
18:55:36 <fons> allbery_b, yes, but on the other hand PortIndex a => SubPort [a] would be perfectly legal
18:55:46 <gotaku> Ok
18:55:51 <dons> gotaku: i think it fixes the whole slow mandel issue (gcc was getting in the way)
18:55:55 <dons> try with n=3k
18:55:59 <dons> (runs in 2.9s here)
18:57:06 <allbery_b> fons: perl the H98 report, an instance is a *type* nto a type*class*
18:57:32 <allbery_b> no variation of SubPort should be legitimate as an *instance*
18:57:36 <allbery_b> as I understand it
18:58:01 <allbery_b> where's someone who actually understands this stuff (including whatver extensions GHC permits)?
18:58:18 <fons> allbery_b, I know a class in not a typ
18:58:20 <fons> type
18:58:21 <dino-> > liftM (+ 1) $ Just 2
18:58:22 <lambdabot>  Just 3
18:58:28 <dino-> > liftM (+ 1) $ Nothing
18:58:29 <lambdabot>  Nothing
18:58:40 <gotaku> dons: It fails the diff
18:58:41 <ddarius> narf
18:58:46 <dino-> Ok, there's a silly example.
18:58:55 <fons> but when you write instance Index a => SubPort [a] where ...
18:58:55 <dons> gotaku: check against a known valid one
18:58:59 <dons> gotaku: like the C program.
18:59:10 <dons> both of vincenz, and your last entry, failed against C from my testing
18:59:10 * allbery_b sighs
18:59:18 <dino-> Lifting the function (+ 1) to operate on things :: Num a => Maybe a
18:59:18 <fons> uhm ... ok I think I get it now
18:59:26 <gotaku> dons: Holt crap, it's fast.
18:59:28 <dons> gotaku: do you have the current haskell submitted entry?
19:00:01 <fons> so subclasses are not allowed in haskell then?
19:00:05 <gotaku> dons: Why?
19:00:08 <allbery_b> not as types
19:00:17 <dons> to check that it matches the last known valid haskell entry in the diff
19:00:52 <dons> or can you compare against the C versoin?
19:01:03 <dons> gotaku: against this C program: http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=gcc&id=2
19:01:06 <lambdabot> Title: mandelbrot C gcc #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/2g9wyc
19:01:08 <allbery_b> if you want to constrain a typeclass based on another typeclass, you say class AClass a => BClass a where ...
19:01:23 <allbery_b> instances are types
19:01:54 <allbery_b> and typeclasses are, at least in theory, never usable directly as types (e.g. you can never declare something to be Num, but you can declare it to be Num a => a
19:01:55 <allbery_b> )
19:02:27 <SamB> allbery_b: unfortunately :k doesn't work on them either :-(
19:02:34 <allbery_b> however I'm not sure why ghc lets you write that at all; maybe it assumes SubPort s a type it just hasn't seen yet
19:02:35 <fons> allbery_b, well, thats what I'm actually meaning
19:02:43 <fons> Num a => a is a type right?
19:02:47 <allbery_b> yes
19:02:53 <allbery_b> btu Num is a typeclass
19:03:10 <fons> why is then Eq a => Myclass a ilegal
19:03:30 <allbery_b> likewise SubPort is a typeclass, and you could use SubPort a => a but in the instance that won't do what yu want
19:03:37 <dons> gotaku: it passes the diff here (and I've submitted it), so I need that confirmed :-)
19:03:39 <fons> maybe what I'm meaning is somehting such as
19:03:44 <dons> the diff against the C program we know to be valid
19:03:55 <fons> Myclass (Eq a => a)
19:04:14 <allbery_b> where are they type experts???
19:04:18 <allbery_b> -y
19:04:35 <allbery_b> and why is it unacceptable to declare the class that way, instead of the instance?
19:05:08 <fons> allbery_b, beacuse a subport can be other things appart from an portindex
19:05:29 <allbery_b> I think you might really want a third class then
19:05:52 <allbery_b> class (PortIndex a, SubPort a) => IndexedSubPort a where ...
19:05:58 <gotaku> dons: The current haskell program passes the diff, your new one doesn't.
19:06:08 <dons> against C? hmm. on what arch?
19:06:10 <allbery_b> or, at least potentially:
19:06:15 <dons> let me check I posted the right one...
19:06:24 <allbery_b> (this will cause all sorts of undecidable instanbce issues, I think)
19:06:35 <allbery_b> instance (PortIndex a, SubPort a) => a where ...
19:06:46 <fons> allbery_b, a list of indexes is a subport as well
19:06:58 <hpaste>  dons pasted "submitted version" at http://hpaste.org/384
19:07:19 <fons> allbery_b, actually an index can be respresented by a unit list
19:07:19 <dons> gotaku: can you check that one ^^ (and you're checking against C?)
19:07:44 <fons> allbery_b, but I wanted to allow the user to provide just an index and not the whole list
19:07:49 <gotaku> dons: I'm checking against the offcial n=200 data from the site.
19:07:50 <allbery_b> try that last, with -fallow-undecidable-instances -fallow-overlapping-instances
19:08:24 <dons> gotaku: what happens at n=3000 ?
19:09:05 <dons> at n=200 things match here.
19:09:20 <fons> allbery_b, a fake data type such as data PortIndex a => FakeWrap = FakeWrap a would work
19:09:22 <dons> though the two entries vincenz posted don't.
19:09:41 <fons> allbery_b, but it's not elegant at all
19:10:22 <gotaku> dons: This is strange...
19:10:32 <dons> yes?
19:10:32 <allbery_b> instance (PortIndex a, SubPort a) => a where ...
19:10:43 <allbery_b> see if that lets you do what you want
19:10:44 <dons> gotaku: what arch are you on?
19:10:59 <gotaku> dons: An arch without sse or sse2
19:11:12 <dons> oh, that's interesting!
19:11:49 <allbery_b> hm, no, that's wrong
19:12:04 <allbery_b> not sure how you write that peorperly
19:12:04 <dons> works here without -sse flags
19:12:10 <dons> gotaku: so you removed the sse flags?
19:12:30 <gotaku> dons: Yes.
19:13:09 <allbery_b> oh, pick one to be the master.  I think in this case:  instance SubPort a => PortIndex a where
19:13:20 <allbery_b> oh, wait, I get it
19:13:21 <dons> on the pentium m, and a p4 (like the shootout box) things seem to work. so I'll guess we just see
19:13:22 <allbery_b> duh
19:13:28 <allbery_b> so, now I'm thoroughly lost
19:13:30 <dons> otherwise, i'd be worth just using the new flags on one you have.
19:13:34 <dons> to see if it helps also
19:13:50 <allbery_b> fons: at this point I suggest finding augustss, as I'm quite confused :/
19:15:18 * allbery_b realized he was misreadingt he instace decl, and is now not sure what's going on
19:15:36 <allbery_b> but probably you need the undecidable/overlapping instance flags to get anything sane to happen anyway
19:19:56 <fons> allbery_b, thanks
19:20:03 <fons> :)
19:21:16 <gotaku> dons: So what was the problem with gcc?
19:22:00 <dons> -optc-O3 was just badly miscompiling
19:22:14 <dons> so there was a 3 fold (or so) jump switching back down to -optc-O1
19:23:46 <dons> phew!
19:23:53 <ddarius> dons: In what way was it miscompiling?
19:24:31 <dons> not sure. the generated C code by ghc was good, but gcc was doing something nasty to it
19:24:38 <dons> such that it ran a lot slower
19:25:45 <gvdm_other> can we fix?
19:26:03 <xpika> dons what CPU do you use?
19:26:15 <dons> this was on a range of machines, p4, pentium m, the shootout p4
19:26:23 <dons> gvdm_other: yeah, fixed. {-# OPTIONS -optc-O #-}
19:26:32 <gvdm_other> yay!
19:26:39 <dons> so i've submitted this, doing the same for nbody now (immediate 2x speed up)
19:26:43 <araujo> hello
19:26:44 <dons> probably similar effect for spectral-norm
19:26:56 <dons> gcc doesn't like ghc's idea of 'C' code
19:27:08 <ddarius> dons: That's not unreasonable
19:27:14 <gotaku> I just ran my original entry with the new flags...
19:27:36 <gotaku> 18s compared with 1m1s
19:27:42 <dons> wow
19:27:56 <dons> how's that compare against my latest version?
19:27:56 <gotaku> dons what gcc version?
19:28:04 <gotaku> 5s
19:28:12 <dons> ok. so the flags help a lot
19:28:16 <dons> bad gcc!
19:28:32 <gotaku> I'm runnng gcc 4.1.2
19:28:35 * SamB isn't familiar with the "bad gcc" project
19:28:43 <gotaku> What version is the shootout running.
19:29:10 <dons> 4.x ?
19:29:14 <gotaku> dons: I think it's a problem with gcc 4
19:29:59 * araujo reads somebody proposing lazyness and referential transparency to ruby :-)
19:30:04 <dons> i got similar results with 3.3.5
19:30:21 <gotaku> dons: Becuase when I was working on my original entry I was using gcc 3 so I was really disappointed and confused why the results were so different when finally posted on the shootout site.
19:30:30 <gotaku> dons: I think I was using 3.3.1
19:30:43 <dons> ah right.
19:30:46 <dons> yeah, that could be it.
19:31:13 <dons> though i was using 4.0.3
19:31:52 <gotaku> Still I'm confused why your latest program doesn't pass the diff check.
19:32:21 <gotaku> I tried check my entry with the same flags and it works fine.
19:32:28 <gotaku> checking
19:32:30 <ddarius> araujo: I don't even use ruby and I think that would be insane.
19:32:49 <dons> gotaku: yeah. its odd.
19:33:06 <araujo> ddarius, well, they came to the conclusion that'd be just Haskell :-)
19:33:09 <siti> ouch who got me to learn colemack my brain is exploding (I am doing qwerty atm) :P
19:34:04 * araujo would like to use a purely functional scripting language though
19:34:12 <ddarius> araujo: No, no it wouldn't unless you threw out a lot of Ruby.  Actually doing it would be tricky in an interesting way.  You'd want to preserve reflection.
19:34:26 <ddarius> araujo: What's wrong with Haskell?
19:34:32 <araujo> ddarius, i don't know ruby, so don't argue with me that :-)
19:34:40 <araujo> join #ruby-lang
19:34:52 <araujo> ddarius, nothing, Haskell is perfect
19:34:56 <dons> heh
19:35:22 * araujo is serious :-}
19:35:27 <dino-> I've been doing the #! /usr/bin/runhaskell thing lately more.
19:35:30 <TomMD> ddarius: Fields within a data structure pollute the name space - that's the problem.
19:35:35 <ddarius> araujo: Bah, do I have to re #ruby-lang.  I don't know ruby either.
19:35:44 <xpika>  :t liftM (+)
19:35:46 <ddarius> TomMD: W.r.t. scripting?
19:35:48 <dino-> But it does noticeably take some time to get that bad boy compiled first time.
19:35:54 <mbishop> @botsnack
19:35:55 <lambdabot> :)
19:36:00 <araujo> Nevertheless ; i find Haskell not enough scripting friendly _yet_
19:36:26 <araujo> There could be an implementation taking Haskell more towards the scripting world.
19:36:28 <TomMD> ddarius: No, just in general I can't have data Foo = Foo { blah :: Int } ; data Bar = Bar { blah :: a } ;
19:37:19 <ddarius> TomMD: I agree, but it should actually be much less of a problem for scripts.
19:37:38 <allbery_b> * SamB isn't familiar with the "bad gcc" project
19:37:41 <gotaku> dons: Ok I just set n=32 and it passes...
19:37:50 <allbery_b> that would be red hat's semi-infamous "gcc 2.96" :)
19:38:04 <SamB> allbery_b: heh
19:38:07 <TomMD> This is because 'blah' would be blah :: Foo -> Int (or :: Bar -> a)  It should be syntatical sugar for making both Foo and Bar of a hidden class and have a class instance for both Foo and Bar extracting field 'blah'
19:38:10 <gotaku> dons: n=200 and 3000 don't.
19:38:16 <ddarius> araujo: That was my question.  What's wrong with Haskell/Haskell implementations with regards to it being used for scripting?
19:38:22 <dons> gotaku: hmm. interesting..
19:38:24 <allbery_b> haskell doesn't need a new implementation for scripting, just a convenience library for ghci/hugs, IMO
19:38:29 <dons> rounding errors on your machine?
19:38:40 <dons> (i got rounding errors from vincenz on mine..)
19:38:45 <Philippa> TomMD: I'd be careful about that "should", though that's one way to start building a record system
19:39:22 <dino-> Would hugs be quicker for doing scripts than ghc?
19:39:37 <dons> ghci uses compiled libs, so tends to run faster
19:39:54 <TomMD> Philippa: No, the should belongs there - I'll get the Simons on board and before you know it poof you will have field names as just a sugar for hidden classes and instances.
19:40:00 <allbery_b> when the libns it uses are compiled, sure.  purely interpreted code is faster in hugs
19:40:07 <TomMD> :-)
19:40:25 <araujo> ddarius, scripting languages are more oriented to handle processes. That's actually the main purpose. It still takes too much line for doing something on Haskell than you can do in other scripting language.
19:40:30 <allbery_b> so,  on one, half dozen on the other
19:40:50 <allbery_b> araujo: a library for scriping foo would solve most of that
19:41:09 <araujo> allbery_b, There are many of them. Saddly, not that popular.
19:41:15 <allbery_b> and, well, I'd say perl scripts are not usually abut processes.
19:41:23 <araujo> I think a slight modification to an implementation would be nice.
19:41:28 <chessguy> ?where hide
19:41:28 <lambdabot> http://haskell.org/haskellwiki/HIDE
19:41:31 * araujo been working on something like that
19:41:33 <ddarius> Do the Simons still come by here often?
19:41:36 <chessguy> hi haskellers
19:41:51 <allbery_b> shell scripts certainly, but there you have little choice:  to do anything interesting you need external commands.  hence the popularity of perl / python / ruby for scripting :)
19:41:53 <araujo> allbery_b, i am not talking about perl; but scripting languages in general.
19:41:55 <olliej> yoyo chessguy
19:42:03 <TomMD> ddarius: I've not seen them unless I don't recognize their nicks.
19:42:24 <araujo> To define what a scripting language is, it's difficult; but that's the most common definition ive found
19:42:52 <ddarius> If I coax google just right it will tell some of what I want to know.
19:43:36 <allbery_b> see, I'd claim it's more about ad-hoc data manipulation without requiring compilation
19:44:10 <allbery_b> I'll also note that I often build up such manipulations iteratively, which (from recnet experience) goes *very* well with function composition
19:44:11 <SamB> JaffaCake is Simon Marlow
19:44:15 <TomMD> I would say that is what scripting is where as the other is a primary example of what scripting is for
19:44:18 <allbery_b> (compare to unix pipelines)
19:44:30 <SamB> I haven't heard of Simon Peyton-Jones being here
19:44:34 <allbery_b> *recent
19:44:58 <araujo> It got nothing to do with it; but those commands you just talked about, that scripting language offers to handle processes.
19:45:06 <araujo> That's the main task of a scripting language.
19:45:18 <dons> gotaku: recursive runs twice as fast too...
19:45:29 <dons> pretty much everything with a Double in it..
19:45:34 <araujo> To offer enough abstractions on a clear and concise way for manipulating processes.
19:45:35 <allbery_b> but aside from relatively simple system() calls, which haskell can do just as easily, I do more file manipulation than process manipulation (again, except specifically in shell scripts where there's no real choice in the matter)
19:45:36 <gotaku> dons: Did you go through the submitted programs looking for other occurrences of optc-O3?
19:45:57 <dons> I'm looking for Doubles first.
19:46:08 <dons> then yeah, we need to check
19:46:09 <araujo> I am really willing to see if the community can come up with some purely functional alternative :-)
19:46:27 <gotaku> dons: nsieve seems to use it.
19:46:34 <araujo> Ive really not found any language claiming such a description.
19:48:08 <allbery_b> now, at sme point I'd seriously like to see if Haskell provides a better basis for system configuration management a la cfengine/puppet/bcfg2/etc., but I'm nowhere near good enough at it yet to really play with it much
19:48:16 <TomMD> When talking about Haskell to the uninitiated, have you guys ran into people saying "but recursion is slow!" ?  I'm not sure how to respond to that - I almost laughed last time.
19:48:18 <ddarius> SamB: He's apparently been on within the last year.  His nick is simply simonpj.
19:48:22 <allbery_b> *that* will certainly involve some process manipulation
19:48:30 <dons> TomMD: tell them that goto is slow then... :)
19:48:39 <dons> not every language can do recursion as poorly as ruby ;)
19:48:43 <allbery_b> TomMD: recursion is slow in procedural languages
19:48:46 <allbery_b> in general
19:48:50 <gotaku> dons: Will options specified in the source override the command line?
19:48:54 <SamB> ddarius: how intuitive
19:49:10 <dons> gotaku: yes.
19:49:11 <allbery_b> in functional languages recursion is in general much faster
19:49:22 <dons> and we ca have the command line changed if it turns out to be appropriate
19:49:31 <dons> i'm currently fixing up any entries with Doubles that benefit
19:50:27 <gotaku> dons: Doubles? What's wrong with them?
19:50:38 <allbery_b> that's what gcc is screwing up with -O3
19:50:39 <dons> gcc miscompiles them!
19:50:45 <ddarius> allbery_b: In sane language implementations recursion is fast.
19:50:51 <dons> so nbody, pec-norm, mandelbrot, recursive
19:50:55 <allbery_b> ddarius: "exactly" :)
19:51:02 <Philippa> does GHC still treat Doubles better than Floats, btw?
19:51:22 <ddarius> Hmm, the scoping of "sane" is somewhat ambiguous...
19:51:25 <Philippa> I know of cases where using Float is clearly preferable for bandwidth reasons...
19:51:36 <dons> Float is often faster
19:51:42 <dons> but usually on the shootout you're not allowed to use them
19:51:56 <gotaku> I see...
19:52:00 <Philippa> *nod*
19:52:13 <Philippa> there used to be a bit in the GHC manual about specialisations for Double but not Float
19:52:33 <dino-> Do the Haskell compilers do tail call optimization?
19:53:29 <dons> yeah
19:53:34 <ophelix> dino-: I've barely started playing with Haskell, but I'm fairly sure the answer is yes.  ^_^
19:53:36 <dons> a recursive call is just a jmp
19:53:49 <dons> (a tail recursive call)
19:54:16 <TomMD> dons: Still O(n) right?  If it kept a count then that could violate some lazy properties if they aren't very careful.
19:54:37 <allbery_b> until ANSI C was modified to demand it, C compilers used to do float math by upcasting to double and downcasting back (operators were fine, functions were required by K&R C (and later lazily left alone by implementors) to upcast floats to doubles
19:55:34 <ddarius> dino-: Haskell would be rather useless if they didn't.
19:55:48 <chessguy> anybody here tried to build hIDE lately?
19:56:12 <ddarius> I don't think the Report says anything, though, that would require it.
19:56:13 <chessguy> src/Hide/Plugin/LoaderMidLevel.hs:126:26: Not in scope: `moduleFS'
19:57:03 <TomMD> chessguy: I just checked and vi *.hs still works fine for me ;)
19:57:48 <chessguy> wow, you're a real comedian, aren't you?
19:58:06 <TomMD> Sorry, I think I'm just too tired.
20:05:55 <sorear> bah, erc logged me out without telling me
20:06:56 <SamB> sorear: yes.
20:07:06 <SamB> it has integration with doctor, you know!
20:07:41 <jcreigh> "I feel like I'm wasting my life on IRC" "What does that have to do with your mother?"
20:07:58 <allbery_b> not all IRC channels are like M-x psychoanalyze-pinhead, you know :p
20:08:06 <SamB> that is not doctor, that is freud
20:19:17 <sorear> @bot
20:19:18 <lambdabot> :)
20:19:27 <glguy> > printf "%4d" 5 :: String
20:19:29 <lambdabot>  Add a type signature
20:19:36 <glguy> > printf "%4d" (5 :: Int) :: String
20:19:37 <lambdabot>  "   5"
20:19:43 <glguy> > printf "%4d0" (5 :: Int) :: String
20:19:45 <lambdabot>  "   50"
20:19:50 <glguy> > printf "%04d" (5 :: Int) :: String
20:19:52 <lambdabot>  "0005"
20:23:44 <allbery_b> hm
20:23:58 <allbery_b> > printf "%4.4d" (5 :: Int) :: String
20:23:59 <lambdabot>  "   5"
20:24:04 <allbery_b> tsk
20:24:11 <sorear> ?
20:24:42 <allbery_b> ANSI C changed the way %-specs work; that's the modern version of %04d
20:24:54 <sorear> @users
20:24:55 <lambdabot> Maximum users seen in #haskell: 322, currently: 295 (91.6%), active: 35 (11.9%)
20:25:09 <allbery_b> (the problem being that there was no way to specify leading zeroes via a *-spec)
20:26:11 <allbery_b> not, of course, that I expect Text.Printf.printf to do *
20:26:34 <sorear> > printf "%*d" (5 :: Int) (5 :: Int) :: String
20:26:36 <lambdabot>  "    5"
20:27:43 <glguy> > printf "%0*d" (5 :: Int) (5 :: Int) :: String
20:27:45 <lambdabot>  "00005"
20:29:44 <allbery_b> huh
20:30:04 <allbery_b> maybe it should be taught ANSI printf syntax at some point
20:31:15 <sjanssen> @fptools Text.Printf
20:31:16 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
20:31:22 <sjanssen> allbery_b: hack away :)
20:31:31 <allbery_b> heh
20:31:40 <dons> ok. updated 4 (!) entries that were running slower due to -optc-O3 :-)
20:31:48 <dons> in particular mandelbrot should really kic kit.
20:32:04 <dons> sjanssen: can you try the mandelbrot here,https://alioth.debian.org/tracker/index.php?func=detail&aid=304450&group_id=30402&atid=411646
20:32:06 <lambdabot> http://tinyurl.com/2cpgyg
20:32:08 <glguy> > printf "%-0*d" (5::Int) (6::Int) ::String
20:32:10 <lambdabot>  "60000"
20:32:12 <dons> and just confirm it passes the diff at n=3k ?
20:32:40 <glguy> > printf "%04.4" (4.4::Double) :: String
20:32:41 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
20:32:49 <glguy> > printf "%04.4d" (4.4::Double) :: String
20:32:51 <lambdabot>  Exception: Printf.printf: bad argument
20:32:56 <glguy> > printf "%04.4f" (4.4::Double) :: String
20:32:57 <lambdabot>  "4.4000"
20:35:30 <sjanssen> @paste
20:35:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:36:28 <hpaste>  sjanssen pasted "mandel3 output" at http://hpaste.org/385
20:36:42 <sjanssen> dons: ^^^ a bit less than 2x C
20:36:51 <dons> correct output?
20:37:19 <sjanssen> yep
20:37:22 <dons> those numbers are what I get here.
20:37:28 <dons> great!
20:37:36 <dons> ghc really can do numerics after all :-)
20:37:54 <sorear> ghc + #haskell :)
20:37:58 <abz> Can lambda bot execute code of hpaste? Because that would be really cool.
20:38:12 <dons> its been asked a couple of times. sounds like a nice plugin to try
20:38:24 <sorear> abz: no, lambdabot doesn't have HAppS installed
20:38:24 * sjanssen works on -O#haskell ghc flag
20:38:30 <sjanssen> and -Odons
20:38:32 <glguy> sorear: I could do lambdabot inform over a TCP socket
20:38:42 <SamB> sjanssen: no, not GHC flag
20:38:50 <dons> sjanssen: you should have a look at the generated Core from that mandelbrot, its about as good as i can imagine getting
20:38:57 <dons> so its all up to the backend after that
20:38:58 <sorear> @quote clever.*Oleg
20:38:59 <lambdabot> No quotes match. My mind is going. I can feel it.
20:39:03 <sorear> @quote clever.*oleg
20:39:04 <lambdabot> No quotes match. You type like i drive.
20:39:06 <sorear> @quote clever
20:39:07 <lambdabot> No quotes match. My pet ferret can type better than you!
20:39:09 <SamB> see, if you make it a GHC flag, it will happen every compile
20:39:10 <monochrom> Haha -Odons
20:39:15 <sjanssen> @quote rsa
20:39:15 <lambdabot> Robert_Dockins says: A Turing-complete type-checker isn't enough!  Our work is not complete until the parser is a universal machine as well!
20:39:23 <fons> sometimes, while folding a list, if the accumulated value meets certain proposition it is returned and there is no need to continue transversing the list
20:39:26 <dons> @quote oleg
20:39:27 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
20:39:28 <allbery_b> @qquote sufficiently.*Oleg
20:39:29 <lambdabot> No quotes match. It can only be attributed to human error.
20:39:42 <dons> fons, right.
20:39:46 <allbery_b> @quote type.*Oleg
20:39:47 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
20:39:49 <allbery_b> @quote type.*Oleg
20:39:50 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
20:39:51 <dons> you want laziness to allow you to short circuit a fold like that
20:39:55 <allbery_b> @quote type.*oleg
20:39:56 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
20:40:00 <sorear> laziness DOES
20:40:06 <sorear> laziness ROCKS
20:40:09 <fons> dons, but if I use foldr the list has to continue beeing transversed
20:40:14 <sorear> fons: nope.
20:40:20 <sjanssen> @quote RSA
20:40:21 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
20:40:32 <fons> sorear, no?
20:40:35 <allbery_b> @quote Oleg.*who
20:40:36 <sorear> > foldr (&&) True $ map (<5) [0..]  -- fond
20:40:36 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
20:40:37 <lambdabot>  False
20:40:43 <dons> fons, if you're producing values as you go, scanl might be better/
20:40:47 <monochrom> (False && foldr ...) doesn't look like an O(n) operation at all.
20:40:48 <sorear> fons: see that?  foldr bailed early
20:40:49 <allbery_b> thatwhat you're looking for?
20:41:18 <sorear> monochrom: exactly.  laziness short circuits the fold.  as fons wanted.
20:41:36 <monochrom> Why don't people understand lazy evaluation?
20:41:44 <monochrom> It's just macro expansion.
20:41:52 <fons> sorear, imagine we want to calculate the sum of a list but whe are only interested in knowing the result if it's lower than 100
20:41:53 <newsham> people are lazy
20:41:54 <dons> its not taught from birth in CS courses, I guess
20:42:10 <dons> otherwise, its very natural. you just inline / macro expand, as monochrom o says
20:42:11 <fons> sorear, otherwise we consider it an error
20:42:19 <sjanssen> fons: sounds like the job for a scan
20:42:24 <monochrom> Everyone understands macro expansion from natural birth.
20:42:28 <fons> sorear, how could we do that with foldr without transversing the whole list?
20:42:33 <fons> scan then?
20:42:37 <fons> thanks
20:42:37 <sorear> fons: a custom data type!
20:42:43 <allbery_b> ...then why do people never manage to figure out m4?
20:42:48 <allbery_b> :)
20:43:01 <dons> > take 100 $ scanl (+) 0 [1..]
20:43:02 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
20:43:03 <sorear> @let foo (Just x) y | x + y < 100 = Just (x + y) ; foo _ _ = Nothing
20:43:03 <lambdabot> Defined.
20:43:17 <sorear> > foldr foo (Just 0) [1..10]
20:43:18 <lambdabot>      Occurs check: cannot construct the infinite type: b = Maybe b
20:43:18 <lambdabot>       Expe...
20:43:29 <monochrom> foldr (\x y -> if x>100 then undefined else x+y) 0 xs
20:43:34 <sorear> @unlet
20:43:35 <lambdabot> Defined.
20:43:39 <sorear> @undef
20:43:40 <lambdabot> Undefined.
20:43:47 <sorear> @let foo y (Just x) | x + y < 100 = Just (x + y) ; foo _ _ = Nothing
20:43:48 <lambdabot> Defined.
20:43:49 <ddarius> > (head . dropWhile (<100) . scanr (+) 0) [1..100]
20:43:51 <lambdabot>  5050
20:44:02 <sorear> > foldr foo (Just 0) [ 1.. 10]
20:44:04 <lambdabot>  Just 55
20:44:07 <sorear> > foldr foo (Just 0) [ 1.. 10]
20:44:09 <lambdabot>  Just 55
20:44:09 <sorear> > foldr foo (Just 0) [ 1.. 12]
20:44:12 <lambdabot>  Just 78
20:44:14 <sorear> > foldr foo (Just 0) [ 1.. 100]
20:44:16 <lambdabot>  Nothing
20:44:16 <sjanssen> sorear: that's tail strict, won't work on infinite lists
20:44:18 <sorear> > foldr foo (Just 0) [ 1.. ]
20:44:20 <lambdabot>  Exception: stack overflow
20:44:34 <fons> head.scanr then?
20:44:34 <sorear> oh right ...
20:44:45 <sjanssen> you need to simulate foldl via foldr here
20:44:51 <sorear> fons: scanr is your friend, then
20:44:58 <sorear> er scanl
20:45:36 <fons> sorear, then I I'm exchanging time complexity for space complecity
20:45:47 <sorear> fons: no!
20:45:51 <ddarius> Burning a DVD is quicker than reading it...?
20:45:52 <sorear> fons: laziness
20:45:57 <fons> sorear, no? ahm ok ok
20:46:02 <Anon4888> Are "a->a" and "forall a.a->a" the same type and the only difference would arise if you tried to substitute those strings into larger type expressions?
20:46:05 <sorear> ddarius: esp if reading is in real time!
20:46:09 <sorear> ddarius: :)
20:46:18 <sorear> Anon4888: exactyl
20:46:22 <Anon4888> thanks
20:46:30 <glguy> > flip runCont id $ callCC $ \out -> foldM (\acc x -> if acc > 100 then out 0 else return (acc + x)) 0 [1..]
20:46:32 <lambdabot>  0
20:46:33 <glguy> > flip runCont id $ callCC $ \out -> foldM (\acc x -> if acc > 100 then out 0 else return (acc + x)) 0 [1..10]
20:46:35 <lambdabot>  55
20:46:53 <nornagon> tasty
20:47:00 <sorear> Anon4888: actually, the first is more portible, but systems that support both (GHC, Jhc) treat them the same
20:47:13 <nornagon> glguy: callCC is beautiful :)
20:47:21 <Anon4888> thanks sorear
20:47:30 <glguy> > foldM (\acc x -> if acc > 100 then Nothing else Just (acc + x)) 0 [1..10]
20:47:32 <lambdabot>  Just 55
20:47:34 <nornagon> you could write dropWhile with a fold using callCC :)
20:47:35 <glguy> > foldM (\acc x -> if acc > 100 then Nothing else Just (acc + x)) 0 [1..100]
20:47:36 <lambdabot>  Nothing
20:47:44 <dons> glguy: oh , nice. :-)
20:47:45 <glguy> foldM for great justice!
20:47:59 <fons> sorear, I'll give you an example
20:48:06 <nornagon> ooh.
20:48:08 <nornagon> :t foldM
20:48:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:48:13 <monochrom> Wow, you people know when to use callCC...
20:48:17 <fons> sorear, I want the sum of a list _only_ if there are no negative numbers
20:48:19 * sorear > homework
20:48:22 * nornagon too.
20:48:25 <dons> monochrom: freaky, eh!
20:48:32 <fons> sorear, sumPos :: [Int] -> Maybe Int
20:48:35 * glguy isn't sure if he's being made fun of or not
20:48:45 <fons> sorear, If there is a negative number Nothing should be resturned
20:48:52 <ddarius> monochrom: Meh, that was just an overly elabore implementation of exceptions.
20:48:54 <sorear> fons: I'd go for call/cc here ...
20:49:02 --- mode: ChanServ set +o dons
20:49:04 <sorear> (or explicit recursion)
20:49:07 <ddarius> glguy's version is less baroque
20:49:08 --- topic: set to '["The Haskell programming language: we know when to use callCC!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
20:49:12 <monochrom> How much work must the computer do to find out there is no negative number in your list?
20:49:15 --- mode: ChanServ set -o dons
20:49:21 <allbery_b> heh
20:49:21 <dons> :-)
20:49:26 <nornagon> :P
20:49:35 <fons> sorear, call/cc?
20:49:43 <glguy> > foldM (\acc x -> if x < 0 then Nothing else Just (acc + x)) 0 [1..10]
20:49:45 <lambdabot>  Just 55
20:49:57 <glguy> > foldM (\acc x -> if x < 0 then Nothing else Just (acc + x)) 0 $ [1..10] ++ [-1,2,3]
20:49:59 <lambdabot>  Nothing
20:50:02 <sorear> fons: also call-with-current-continuation.  my week of scheme is showing
20:50:04 <ddarius> er his second one to be clear
20:50:18 <sjanssen> @let foldlWhile :: (b -> a -> b) -> (b -> Bool) -> b -> [a] -> Maybe b; foldlWhile f p z xs = foldr (\x xs y -> if p y then xs (f y x) else Nothing) Just xs z
20:50:19 <lambdabot> Defined.
20:50:31 <glguy> ddarius: my foldM + Maybe?
20:50:33 <sjanssen> > foldlWhile (+) (<100) 0 [1..]
20:50:34 <sorear> bbl
20:50:34 <lambdabot>  Nothing
20:50:39 <ddarius> > foldM (\acc x -> do guard (acc < 100); return (acc+x)) :: Maybe Int
20:50:40 <lambdabot>      Expecting a function type, but found `Maybe Int'
20:50:40 <lambdabot>       Expected type: Ma...
20:50:54 <sjanssen> fons: there you go ^^^
20:50:56 <ddarius> > foldM (\acc x -> do guard (acc < 100); return (acc+x)) 0 [1.10]:: Maybe Int
20:50:57 <lambdabot>   add an instance declaration for (Fractional Int)
20:50:58 <lambdabot>     In the list element: 1.1
20:51:08 <fons> foldM?
20:51:09 <ddarius> > foldM (\acc x -> do guard (acc < 100); return (acc+x)) 0 [1..10]:: Maybe Int
20:51:10 <lambdabot>  Just 55
20:51:29 <sjanssen> d'oh -- I forgot foldM!
20:51:45 <nornagon> :t guard
20:51:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:51:51 <glguy> sjanssen: but I said "foldM for great justice!" and everything
20:51:53 <ddarius> glguy: Yes.
20:52:02 <sjanssen> glguy: I was in the coding zone
20:52:07 <fons> thanks all
20:52:37 * sjanssen has tunnel vision when abusing foldr
20:52:57 <fons> so foldM then ...
20:53:45 <glguy> :t foldM
20:53:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:53:50 <sjanssen> foldM++
20:53:58 <sorear> wait ...
20:53:59 <nornagon> callCC++
20:54:13 <sjanssen> @karma callCC
20:54:13 <lbwin> callCC has a karma of 0
20:54:14 <lambdabot> callCC has a karma of 1
20:54:19 <newsham> @version
20:54:19 <lbwin> lambdabot 4p497, GHC 6.6 (CYGWIN_NT-5.1 i686 2.00GHz)
20:54:19 <lbwin> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:54:19 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
20:54:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:54:20 <lambdabot> Title: Index of /~dons/lambdabot
20:54:21 <lbwin> Title: Index of /~dons/lambdabot
20:54:25 <nornagon> um.
20:54:38 <dons> lbin eh?
20:54:48 <glguy> aw many, and I had my kicking finger out and everything
20:54:51 <glguy> man* :)
20:54:57 <procyon_> call/cc in scheme hurts my brain as it is.  callCC in a language with no explicit thread state gives me nightmares.
20:54:59 <monochrom> lambdabot::lbwin : SamB:SamXP
20:55:16 <SamB> it was SamB_XP
20:55:18 <xpika> procyon_: me too!
20:55:18 <sorear> lbwin is newsham!
20:55:23 <dons> yeah
20:55:24 <SamB> and he needs a new CPU fan
20:55:28 <monochrom> oops
20:55:32 <newsham> just testing the bot out
20:55:33 <ddarius> procyon_: How does that make any sense?
20:55:35 <sorear> newsham: how's SILC ?
20:55:37 <dons> newsham++ doing the hard work
20:55:43 <SamB> 120 mm, I believe
20:55:48 <ddarius> State + call/cc = too much
20:55:52 <newsham> sorear: bots still running in their hacked form.
20:56:11 <newsham> i need to figure out what needs to be torn apart and built back up to abstract out the chat system properly
20:56:16 <nornagon> is callCC a big performance hit in Haskell?
20:56:22 <audreyt> nornagon: no.
20:56:37 <SamB> nornagon: it isn't particularly special, you see
20:56:45 <ddarius> GHC is optimized for higher order function uses.
20:56:49 <sorear> it's an ordinary function!
20:56:50 <newsham> thats one of the reasons i built lamdabot on win32... my winxp box is faster than my linux box.. so it will be a better platform for me to dev and test on
20:56:53 <nornagon> okay :)
20:56:59 <sorear> callCC is a LIBRARY!! muahahaha!!!
20:57:03 <SamB> nornagon: no primitives or anything!
20:57:09 <nornagon> neato.
20:57:11 <sorear> not like scheme!
20:57:13 <SamB> no stack dumps or anything
20:57:29 <SamB> your brain explosions will mainly be due to the types
20:57:29 <allbery_b> @source Control.Monad.Cont
20:57:30 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
20:57:31 <audreyt> "Haskell provides no call trace and we call it a feature"
20:57:33 <nornagon> yeah, i was thinking about scheme/setjmp/longjmp and how horrible they are.
20:57:34 <Cale> callCC just uses the usual trick for embedding classical logic in intuitionist logic
20:57:37 <audreyt> "Prelude.head: empty list"
20:57:43 <ddarius> A library that requires global changes to your code.  Which -is- not like Scheme.
20:57:44 <nornagon> :t callCC
20:57:46 <lambdabot> forall (m :: * -> *) a b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:57:55 <Cale> The classical type for callCC is ((a -> b) -> a) -> a
20:58:09 <SamB> ddarius: not necessarily
20:58:13 <syntaxfree> @tell dons lol! the shootout comment on the reddit discussion for my parser thingie is a cheap shot, heh. I'm sure python with a couple of regexes outperforms my hacky parsec solution.
20:58:13 <sorear> yes, classical logic is a monad
20:58:13 <lambdabot> Consider it noted.
20:58:14 <Cale> In the case of the Cont monad,  Cont r a = ((a -> r) -> r)
20:58:34 <audreyt> ddarius: beg your pardon, but when I adopted callCC, I changed none of my code, just a type synonym is all
20:58:36 <fons> ok, the foldM trick doesn't work for me
20:58:36 <sorear> muahahaha!
20:58:37 <glguy> ?unmtl Cont Int Double
20:58:38 <lambdabot> (Double -> Int) -> Int
20:58:40 <SamB> unless maybe you call changing your monad "global", in which case I heartily agree ;-)
20:58:55 <fons> I'll rephrase the simplified problem
20:59:18 * glguy realizes that the parameter in runCont c <this parameter> is applied to the early exit type!
20:59:18 <ddarius> Meh.  Monadic style is a particularly flexible global transformation.
20:59:33 <Cale> It's interesting how it doesn't translate that first a, though it makes sense from a library perspective.
20:59:39 <glguy> > runCont (return 1) show
20:59:40 <lambdabot>  "1"
20:59:46 <glguy> wait...
20:59:48 <glguy> oh
21:00:11 <glguy> > runCont (callCC ($ 1)) show
21:00:12 <lambdabot>  "1"
21:00:19 <glguy> nvm
21:00:20 <SamB> :t runCont
21:00:21 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
21:00:43 <Cale> @djinn ((((a -> r) -> r) -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
21:00:44 <lambdabot> f a b = a (\ c _ -> c b) b
21:00:57 <sorear> that function looks familiar
21:00:58 <glguy> :t flip runCont show
21:00:58 <Cale> @djinn (((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
21:00:59 <lambdabot> Cannot parse command
21:01:00 <lambdabot> forall a. (Show a) => Cont String a -> String
21:01:02 <Cale> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
21:01:03 <lambdabot> f a b = a (\ c _ -> b c) b
21:01:04 <fons> Image you have a list of numbers and you want to sum them if they are not divisible by 3 or give an error (providing which number didn't meet the condition)
21:01:04 <newsham> > ($ 1) show
21:01:05 <sorear> I want to call it "pierce" :p
21:01:06 <lambdabot>  "1"
21:01:07 <fons> Imagine*
21:01:08 <newsham> huh
21:01:17 <glguy> > runCont (callCC ($ "test")) show
21:01:19 <lambdabot>  "\"test\""
21:01:23 <glguy> oh
21:01:24 <SamB> @src runCont
21:01:25 <lambdabot> Source not found. My mind is going. I can feel it.
21:01:35 <sorear> SamB: it's a field
21:01:35 <fons> thus the function sumDiv3 :: [Int] -> Either Int String
21:01:36 <glguy> callCC is still returning the value buy the time runCont is hit
21:01:38 <sorear> @src Cont
21:01:39 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
21:01:41 <Cale> fons: I'd use partition.
21:01:44 * chessguy ties down lambdabot's brain 
21:01:44 <SamB> sorear: oh.
21:01:47 <sorear> SamB: source of runcont ^^
21:01:47 <SamB> right ;-)
21:01:54 <Cale> fons: and check to see if one part was empty or not.
21:02:09 * SamB thinks @src runCont should show you the source for Cont
21:02:25 <fons> Cale, it is a simplified example of my problem in which I have to fold a list
21:02:37 <Cale> > partition ((/= 0) . (`mod` 3)) [1,2,5,7,8,6,2,4,2,8,9]
21:02:39 <lambdabot>  ([1,2,5,7,8,2,4,2,8],[6,9])
21:02:40 <monochrom> @remember sorear classical logic is a monad
21:02:41 <lambdabot> Done.
21:02:50 <ddarius> fons: foldM with the Error monad (Either being treated as the error monad) throwError if not divisible by 3
21:03:12 <fons> ddarius, Error monad?
21:03:16 <glguy> Either Int String isn't a defined Monad
21:03:18 <dons> http://programming.reddit.com/info/13g3o/comments
21:03:18 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
21:03:19 <lambdabot> Title: Don&#39;t hate the for loop: just use a fold! (reddit.com)
21:03:21 <sorear> fons: it's ccalled Either
21:03:27 <fons> we are getting somewhere now
21:03:29 <heatsink> glguy: Either String Int is
21:03:29 <allbery_b> Either String a, more precisely
21:03:47 <ddarius> Bah fail!
21:03:47 <allbery_b> see Control.Monad.Error
21:03:52 <glguy> heatsink: I'm aware :)
21:04:33 <audreyt> ghci built with -fdebugging is 300% (or more) slower :/
21:05:01 <newsham> > do { throwError "oops, I did it again"; return 5 }
21:05:02 <lambdabot>   add an instance declaration for (Show (m a))
21:05:10 <dons> audreyt: huh. better tell mnislaih
21:05:27 <dons> audreyt: he's keen for feedback from actual users
21:05:44 <dons> (just dropping a note by haskell-cafe@ would be useful)
21:06:14 <audreyt> maybe I really should subscribe -cafe@.
21:06:21 <procyon_> I wrote Haskell late last night, and got up for work this morning.  As I walked out to my car, and I swear to god I'm not making this up, my tired mind considered for an instant if my state of being at work wasn't already evaluated and my drive would not ever resolve, at which point I quickly reasoned that I was in a Monad and would still have to drive, at which point I caught myself and realized I was insane.
21:06:28 <ddarius> either read id $ foldM (\acc x -> if x `mod` 3 /= 0 then throwError (show x) else return (acc + x)) 0 [1..10]
21:06:33 <ddarius> > either read id $ foldM (\acc x -> if x `mod` 3 /= 0 then throwError (show x) else return (acc + x)) 0 [1..10]
21:06:34 <lambdabot>  1
21:06:51 <dons> procyon_: its good to be explicit about sequencing
21:06:51 <bd_> procyon_: Careful there, once your brain hits the bottom there's no coming back.
21:06:54 <ddarius> > either read id $ foldM (\acc x -> if x `mod` 3 /= 0 then throwError (show x) else return (acc + x)) 0 [3,6..12]
21:06:55 <lambdabot>  30
21:07:16 <ddarius> > either (Left . read) Right $ foldM (\acc x -> if x `mod` 3 /= 0 then throwError (show x) else return (acc + x)) 0 [3,6..12]
21:07:18 <lambdabot>  Add a type signature
21:07:34 <newsham> procyon: you're too lazy
21:07:41 <procyon_> :)
21:08:19 * glguy thinks that using read on the String instance of Error is bad form :-p
21:08:40 <glguy> better off using Cont for this
21:08:47 <ddarius> procyon_: When crap like that happens that when I know I'm already essentially asleep.
21:08:54 <fons> (Either e) is a monad?
21:09:13 <allbery_b> see Control.Monad.Error foro the MnadError instances
21:09:14 * ddarius thinks fail is annoying.
21:09:21 <allbery_b> er, MonadError
21:10:36 <glguy> > flip runCont id $ callCC $ \ out -> fmap Right $ foldM (\acc x -> if x `mod` 3 /= 0 then out (Left x) else return (acc + x)) 0 [3,6..12]
21:10:38 <lambdabot>  Right 30
21:10:49 <glguy> > flip runCont id $ callCC $ \ out -> fmap Right $ foldM (\acc x -> if x `mod` 3 /= 0 then out (Left x) else return (acc + x)) 0 [3,6,7,9]
21:10:50 <lambdabot>  Left 7
21:10:57 <glguy> hurrah for Cont!
21:13:48 * glguy admits that that example isn't totally "accessible"
21:13:52 <fons> allbery_b, I checked that: class Monad m => MonadError e m | m -> e where
21:14:03 <fons> instance Error e => MonadError e (Either e)
21:14:25 <fons> but I don't see where (Either e) is instanciated as a Monad
21:14:38 <glguy> ?instances Monad
21:14:40 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:15:23 <geekagent> :t ST
21:15:25 <lambdabot> Not in scope: data constructor `ST'
21:15:36 <glguy> :k ST
21:15:38 <lambdabot> Not in scope: type constructor or class `ST'
21:15:52 <glguy> :k Control.Monad.ST.ST
21:15:54 <lambdabot> * -> * -> *
21:16:15 <joakim> good morning
21:16:16 <geekagent> what's the difference between ST and State?
21:16:27 <sorear> geekagent: vvv
21:16:37 <sorear> @google "lazy functional state threads"
21:16:41 <lambdabot> http://www.cse.ogi.edu/~jl/Papers/stateThreads.ps
21:16:55 <sorear> ST uses deep parametric black magic to be faster than State
21:17:13 <sorear> and it supports references (kinda like non-const pointers)
21:17:32 <ddarius> sorear: Wtf?  ST and state are simply totally different things.
21:17:53 <fons> glguy, In what module is the instantiation made?
21:18:20 <sorear> ddarius: the interface and implentation are totally different, but they are comparable since they occupy the same niche (pure state threading)
21:18:23 <glguy> instance (Error e) => Monad (Either e)
21:18:23 <glguy>   -- Defined in Control.Monad.Error
21:18:58 <fons> thanks glguy
21:19:50 <ddarius> sorear: Actually, you can implement State fairly straightforwardly as ReaderT (ST s)
21:20:16 <ddarius> sorear: But there areas of use barely overlap.
21:20:50 <sorear> ddarius: you can implement ST pretty straightforwardly using State (Int, Map Int a)
21:21:49 <ddarius> sorear: Oh?  Do it.
21:21:49 <sorear> ddarius: I've implemented graph algorithms with pointers indirecting through a State'd Map
21:22:22 <newsham> sorear: not interested in using one of the existing graph libraries?
21:22:42 <fons>  :m +Control.Monad.Error
21:22:42 <fons> Could not find module `Control.Monad.Error'
21:22:42 <ddarius> sorear: I require do writeSTRef refBool True; writeSTRef refString "foo" to work
21:22:44 <fons> :S
21:22:48 <sorear> newsham: this was a long time ago
21:23:06 <newsham> ahh.
21:23:23 <sorear> ddarius: I reserve the right to use phantom types and unsafeCoerce in my implementation
21:23:48 <glguy> fons: they are part of the extra-libs. did you install those when you installed GHC?
21:24:15 <fons> glguy, is that a package?
21:24:29 <ddarius> sorear: Then I further want the same time complexities for the operations.
21:25:03 <ddarius> sorear: And what happened to "straightforwardly"
21:25:42 <fons> glguy, I'm using the ghc package which comes with my linux distribution (debian sid)
21:26:34 <glguy> fons: ah, I don't deal with linux, I'll defer to someone that tolerates linux more than I do ;)
21:27:07 <fons> I give up, I'll just transverse the bloody list
21:27:14 <sorear> fons: the extralibs are packaged seperately in sid
21:27:33 <sorear> libghc6-mtl-dev
21:27:50 <glguy> You'll want those whether or not you use them for this little function
21:28:14 <sorear> mtl is required by just about every nontrivial haskell program
21:28:31 <fons> sorear, ok, then I'm not gonna use it
21:28:36 <fons> :S
21:29:07 <sorear> :S <-- does not parse (I'm too new)
21:29:39 * fons shows 6am frustation
21:30:04 <glguy> fons: you don't need the instance of Monad for Either anyway
21:30:13 <glguy> that would be an inappropriate use of it
21:30:26 <ddarius> sorear: It's not a #haskell thing, but you've never read Peanuts or seen Charlie Brown?
21:30:31 <monochrom> Why are you frustrated at us everytime?
21:30:37 <fons> glguy, then the problem remains unsolved
21:30:49 <glguy> fons: no, the problem has been solved many times so far
21:31:13 <fons> Image you have a list of numbers and you want to sum them if they are not divisible by 3 or give an error (providing which number didn't meet the condition)
21:31:18 <fons> (I meant unsolved for me)
21:31:28 <sorear> ddarius: I have, why?
21:31:32 <glguy> i meant in the scrollback
21:31:34 <glguy> scroll up
21:31:52 <fons> glguy, it was solved for a maybe type
21:31:57 <ddarius> sorear: Charlie Brown often has an expression like that.-
21:32:06 <glguy> fons: Cale solved it without even using a Monad
21:32:11 <sorear> ah. memoized.
21:32:12 <glguy> fons: I solve it with a Cont monad
21:32:15 <sorear> ty
21:32:45 <nornagon> eek, i'm starting to see haskell in my english homework
21:32:47 <fons> glguy, yes, but as I said the problem is a simplification, I need to fold the list
21:32:55 <nornagon> "Photographers are like monads because they wander the earth."
21:33:03 <Cale> fons: yes, my way allows you to do that
21:33:22 * ddarius wonders if he will see a monad in Japan or Hawaii.
21:33:37 <glguy> > foldr (\x xs -> if x `mod` 3 /= 0 then error (show x) else x + xs) 0 [1..10]
21:33:37 <Cale> In fact, I didn't even do anything to the list yet, all I did was separate the elements which met the criteria from those which didn't.
21:33:38 <lambdabot>  Exception: 1
21:33:53 <glguy> > foldr (\x xs -> if x `mod` 3 /= 0 then error (show x) else x + xs) 0 [3,6,9,12]
21:33:55 <lambdabot>  30
21:34:26 <monochrom> nornagon: is that sentence original from you?
21:34:29 <Cale> If the list of elements which don't meet the criterion is empty, then you'd take one branch, perhaps summing the rest, or folding whatever over them. If it wasn't, you'd return an error.
21:34:33 <fons> glguy, I didn't read your previous solution
21:34:38 <Cale> Either seems like a sane way to do things.
21:34:55 <fons> Cont monad ... I didn't even know it existed
21:35:09 <glguy> so what time is this due?
21:35:14 <monochrom> You don't have to pursue the Cont method just now.
21:35:31 <fons> glguy, it requires the mtl package again
21:35:47 <glguy> fons: it's not my fault you didn't finish installing GHC
21:36:01 <fons> glguy, hahah, sorry, I'm not blaming you :)
21:36:06 <monochrom> Aw, please don't argue about these peripheral issues.
21:36:09 <Cale> > case partition ((/= 0) . (`mod` 3)) [1,6,4,5,2,7,32] of (xs,[]) -> Right (sum xs); (xs, ys) -> Left ("Error, the following are divisible by 3:" ++ show ys)
21:36:11 <lambdabot>  Left "Error, the following are divisible by 3:[6]"
21:36:18 <sorear> whoever removed mtl from base was ... ... ... error: failed to find polite phrasing
21:36:21 <Cale> > case partition ((/= 0) . (`mod` 3)) [1,4,5,2,7,32] of (xs,[]) -> Right (sum xs); (xs, ys) -> Left ("Error, the following are divisible by 3: " ++ show ys)
21:36:23 <lambdabot>  Right 51
21:36:28 <monochrom> haha sorear
21:36:43 <fons> glguy, and I did finish it is just that I don't want my code to depend on nonstandard libraries
21:36:48 <glguy> lol
21:37:10 <sorear> libraries are worthless if people resist using them
21:37:55 <newsham> sorear: thats why you should use FGL ;-)
21:38:06 <fons> sorear, true but still it is better to stick to the base libraries when possible
21:38:17 <monochrom> well if it's homework there is a dependency question.  if it's self-education there shouldn't be any hesitation.
21:38:24 <newsham> fons: depends on your goals.
21:38:33 <sorear> mtl is as standard as it gets without being part of base
21:38:41 <nornagon> monochrom: yeah
21:38:55 <sorear> it has been included with every Haskell compiler wothy of the name since time immemorial.
21:38:55 <monochrom> OK, I hope this is legit:
21:39:11 <monochrom> @remember nornagon Photographers are like monads because they wander the earth.
21:39:12 <lambdabot> Done.
21:39:12 <ddarius> You could always of course implement the monad instance(s) yourself.
21:39:19 <dons> yeah, thinks like StateT are practially part of the language spec :-)
21:39:41 <glguy> I don't even think of the mtl as a separate library
21:39:44 <glguy> I've never been without it
21:40:15 <fons> monochrom, well, it's not homework, I'm writing an embedded compiler for my Master's thesis
21:40:17 <monochrom> What I don't understand is: one newcomer says "haskell lacks something like CPAN", and another newcomer (even the same one) says "I don't use nonstandard libraries".  Do you see a dilemma for the haskell community here?
21:40:28 <glguy> monochrom: too many newcomers?
21:40:43 <monochrom> HOW DO WE ****ING SATISFY EVERYONE?!
21:40:52 <glguy> monochrom: +b's
21:40:56 <glguy> ;)
21:41:02 <dons> ?where hackage
21:41:03 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
21:41:06 <ddarius> monochrom: Make every library part of the standard.
21:41:15 <newsham> mono: so can I use hackage to auto pull down and compile stuff?
21:41:24 <newsham> the web page said it was supposed to happen but didnt say much else
21:41:28 <newsham> (speaking of cpan)
21:41:32 <bd_> To be fair, something like CPAN would be nice. One-command install of a library and its dependencies, plus a central location to search for packages and read their documentation...
21:41:32 <dons> using cabal-get, yeah. but its alpha atm.
21:41:39 <dons> cabal-install, i mean.
21:41:53 <dons> this is the very essence of what hackage is to provide
21:42:06 <newsham> hmm.. I dont have that yet.  is that part of hackage or part of cabal/ghc?
21:42:07 <sorear> bd_: now imagine what it'll be like once my dreams of the apt-hackage proxy are realized...
21:42:12 <dons> it already has the central repo. haddocks are almost done, and cabal-get/put are in the repo
21:42:17 <newsham> does it have good --help or a man page?
21:42:19 <dons> newsham: in the cabal repo (darcs version)
21:42:27 <newsham> ahh, thanks.
21:42:29 <dons> i'd say we'd have this ready to go for the next ghc release
21:42:33 <monochrom> Well a point of CPAN is it's mostly non-standard but everyone uses it anyway.  A perl monk happily tells a perl newbie "just grab it from CPAN and stop whining" and everyone thinks the perl monk is right.
21:43:08 <newsham> mono: a rich collection of prewritten libraries is great for any programming environment..  doesnt need to be "standard"
21:43:09 <bd_> sorear: Not so much a proxy as an auto-builder, you mean?
21:43:10 <nornagon> hey, CPAN's the only thing going for perl.
21:43:19 <sorear> bd_: both.
21:43:26 <newsham> norn: what about punctuation?  they seem to excell at it
21:43:29 <bd_> sorear: both?
21:43:38 <glguy> can you even download a compiled GHC from h.o without mtl?
21:43:39 <ulfdoz> cpan is slow and painful.
21:43:39 <sorear> bd_: apt-get install hackage-foo
21:43:44 <nornagon> newsham: that's not "going for" it :P
21:44:14 <bd_> sorear: so, auto-builder? :)
21:44:15 <sorear> bd_: autobuilds, autopackages, memoizes (server side), gives you a binary package
21:44:19 <monochrom> For the record, I don't believe in "standard" either.
21:44:23 <bd_> ah, so build on-demand?
21:44:31 <bd_> I'm not sure if that would work with APT though
21:44:34 <nornagon> ooh, nice
21:44:45 <nornagon> automatically doing cabal -> deb would be v.cool
21:45:07 <sorear> bd_: sure it would. apt uses a documented API to communicate with mirrors; we would simulate one.
21:45:11 <glguy> fons: OK, I have your answer, mtl *is* a standard library. goto http://haskell.org and click on STANDARD LIBRARIES ;)
21:45:12 <lambdabot> Title: Haskell - HaskellWiki
21:45:32 <monochrom> glguy: what if it's Network.HTTP tomorrow? :)
21:45:33 <newsham> <lst> so what exactly is this bot? :)  <lst> haskell?  <lst> yeah.. but haskell? :-p  <lst> no, but haskell is like c++ crossed with python :) <lst> with a splash of perl
21:45:56 <sorear> newsham: where's that?
21:46:06 <newsham> <lst> ::, -> vs >>, <- vs << <lst> i dont know, just reminds me of c++ <lst> and looks like python on crack
21:46:07 <sorear> and don't forget the INTERCAL!
21:46:13 <glguy> monochrom: what if what is Network.HTTP?
21:46:14 <newsham> sorear: silc channel where the bot runs
21:46:37 <bd_> sorear: Yes, but don't package listings include the md5 of the binary package?
21:46:44 <chessguy> hmm, how would you go about implementing a monadic stack?
21:46:50 <monochrom> Network.HTTP is not standard yet.  Someone may ask "I want http client side, but I refuse non-standard libraries" tomorrow.
21:46:57 <bd_> sorear: If you implement a new APT protocol, maybe...
21:47:09 <sorear> bd_: gah.  ok, build-on-demand won't work, I'll have to do build-on-push.  no big loss.
21:47:11 <newsham> chess: like State [a] ?
21:47:21 <glguy> monochrom: ah, OK
21:47:24 <bd_> sorear: Build-on-push would still be quite nice :)
21:47:37 <newsham> push x = modify (x:) ?
21:48:24 <chessguy> hmm, i'm thinking along the lines of being able to bind pushes and pops together
21:49:04 <monochrom> I should open a thread on haskell-cafe titled "the futility and impossibility of a haskell success".  In it I should document all these observations about contradictary or double-standard wishlists from "real world" people.
21:49:11 <newsham> > let push x = modify (x:); pop = (do { x <- gets head; modify tail; return x}) in runState (do { push 3; push 4; x <- pop; return x}) []
21:49:13 <lambdabot>  (4,[3])
21:49:23 <newsham> chess: something like that?
21:49:33 <sorear> chessguy: gah.  A long time ago I thought about how to add damas-milner to forth.
21:49:50 <sorear> chessguy: I just realized damas milner forth is a Haskell EDSL :)
21:49:54 <nornagon> damas-milner?
21:50:12 <sorear> appearantly, it's the correct version of hindley-milner
21:50:25 <chessguy> mm, i'm not making myself clear. i'm wondering if you could do: instance Monad (Stack a) where ...
21:50:39 <sorear> nornagon: IOW it's the proper name of Haskell's type system
21:50:54 <glguy> chessguy: how would it be different than instance Monad [a]
21:50:57 <nornagon> IOW?
21:51:00 <nornagon> >.>
21:51:03 <glguy> in other words
21:51:05 <sorear> "In other words"
21:51:09 <nornagon> oh
21:51:38 <glguy> blasphemy!
21:51:40 <chessguy> mm, i'm not sure
21:51:52 <newsham> i'm not sure i understand why you want it to be instance Monad
21:52:00 <newsham> do you have something in mind for return and bind?
21:52:01 <sorear> glguy: ?
21:52:19 <glguy> sorear: that talk of correct name of Haskell's type system
21:52:24 <glguy> I'm *joking* though
21:52:54 <chessguy> ok, time to 'fess up. i'm actually looking at some code which is, in fact, a monadic Stack. and i'm trying to figure out myself what the benefit is :)
21:53:29 <newsham> beats me
21:53:47 <glguy> chessguy: link?
21:53:51 <dons> :k ContT
21:53:53 <lambdabot> * -> (* -> *) -> * -> *
21:53:55 <glguy> since [a] is a stack...
21:54:03 <chessguy> !paste
21:54:03 <hpaste> Haskell paste bin: http://hpaste.org/
21:54:12 <dons> :k ConT [Char] Maybe Int
21:54:14 <lambdabot> Not in scope: type constructor or class `ConT'
21:54:20 <dons> :k ContT [Char] Maybe Int
21:54:21 <lambdabot> *
21:54:27 <dons> @unmtl ContT [Char] Maybe Int
21:54:27 <lambdabot> (Int -> Maybe [Char]) -> Maybe [Char]
21:54:36 <dons> so, no need to stack our monads :-)
21:54:54 <glguy> or use them at all
21:54:58 <dons> :k StateT
21:55:00 <lambdabot> * -> (* -> *) -> * -> *
21:55:27 <dons> @unmtl ContT [Char] (StateT Int IO Bool) Int
21:55:28 <lambdabot> err: Unknown MTL(3)
21:55:29 <glguy> Maybe and [Char] aren't used as Monads in the result of @unmtl :-p
21:55:35 <hpaste>  chessguy pasted "Monadic stack" at http://hpaste.org/386
21:55:47 <glguy> dons: that doesn't type-check :)
21:55:59 <dons> @unmtl ContT [Char] (StateT Int IO) Int
21:55:59 <newsham> so i was thinking last night (uh oh) about coding stuff with persistent state.  you define your record type and (sometimes) write code to pickle/marshall it to stable store.  that part is pretty easy, but what gets hard is when you later add and remove fields and you have different versions of the same record, so you have to write code to recognize old versions, convert them, and put version records in...
21:56:00 <lambdabot> (Int -> Int -> IO ([Char], Int)) -> Int -> IO ([Char], Int)
21:56:06 <sorear> dons: my Ptr Int-based vty just typechecked
21:56:14 <dons> scrap your mtl!
21:56:18 <dons> sorear: cool!
21:56:42 <dons> newsham: right. standard version tagging problem
21:56:43 <newsham> it would be nifty if the programming system itself could take care of that, so that I told the programming system "I want to add a field to the Foo record with default value 9"  and it went and bumped the revision number, made up code for inserting the default value into old records, etc.
21:57:03 <newsham> (on the recurring theme of computers not helping programmers nearly as much as they could)
21:57:07 <dons> i think there must be standard ways to implement that
21:57:17 <glguy> sounds like you were using an sql database and adding columns with default values before you went to bed
21:57:21 <sorear> dons: I'm kinda imitating Builder - I have pure looking combinators (<->) (<|>) packBS etc but behind your back they rearrange monadic array filling code
21:57:32 <newsham> glguy: no, i dont use sql.
21:57:33 <dons> nice
21:57:37 <audreyt> newsham: the Prevaylor pattern deals with it
21:57:53 <audreyt> but I'm not sure there is a Haskell implementaiton
21:58:04 <audreyt> er, Prevayler,.
21:58:20 <newsham> got any recommendations on where to start reading about that, audrey?
21:58:25 <sorear> newsham: better yet - add support for default values somewhere SYB/DrIFT/etc can see them.
21:58:41 <sorear> newsham: then you could have extensible Binary instances
21:58:46 <sorear> and general fun
21:59:02 <newsham> its more than just defaulting, though...
21:59:20 <newsham> for example, if you are serializing in binary, you have to know which versions have which fields in which orders
21:59:46 <newsham> (in more complex cases you might want to perform transformations on old versions to generate new versions that go beyond just adding default values)
22:01:14 * lispy oscillates
22:01:16 <chessguy> glguy, so any guess what this code is all about?
22:01:24 <glguy> chessguy: paste almost done
22:01:50 <hpaste>  glguy annotated "Monadic stack" with "Stack using MTL" at http://hpaste.org/386#a1
22:01:59 <glguy> chessguy: it was just: State [a] b
22:02:18 <glguy> like someone (nornagon?) suggested
22:02:44 <newsham> *raises hand*
22:02:48 <glguy> I didn't type-check that paste, so any part of it could be wrong
22:02:57 <chessguy> what's the b though?
22:02:58 <newsham> > let push x = modify (x:); pop = (do { x <- gets head; modify tail; return x}) in runState (do { push 3; push 4; x <- pop; return x}) []
22:03:00 <lambdabot>  (4,[3])
22:03:06 <glguy> chessguy: the return type of the computation
22:03:20 <newsham> > let push x = modify (x:); pop = (do { x <- gets head; modify tail; return x}) in runState (do { push 3; push 4; x <- pop; return "booyah"}) []
22:03:22 <lambdabot>  ("booyah",[3])
22:03:30 <newsham> StateT [Int] String
22:03:30 <chessguy> but if the Stack has values of type a, won't any return always be of type b?
22:03:34 <chessguy> err
22:03:36 <newsham> err State
22:03:37 <chessguy> but if the Stack has values of type a, won't any return always be of type a?
22:03:44 <glguy> chessguy: only if you return a value from the stack
22:03:47 <newsham> chess: see "booyah"
22:04:04 <glguy> chessguy: you can use the stack without returning it's values directly
22:04:47 <chessguy> ohhhh
22:05:06 <glguy> it wouldn't be a Monad if the return type was constrained in any way
22:05:45 <glguy> :t liftM read getLine
22:05:47 <lambdabot> forall a. (Read a) => IO a
22:06:28 <glguy> isEmpty :: Stack a Bool
22:07:20 <chessguy> by tye way, i've got a really stupid question
22:07:32 <newsham> i can probably come up with an equally stupid answer
22:07:40 <chessguy> i keep seeing this acronym mtl, and i don't know what it stands for
22:07:40 <glguy> there are no really stupid questions, only really stupid people
22:07:45 <glguy> monad template library
22:07:46 <newsham> monad template library
22:08:01 <newsham> its the StateT and ErrorT type thing
22:08:09 <newsham> (vs State and Error)
22:08:23 <glguy> ?
22:08:28 <chessguy> i thought the T in StateT was for transformer
22:08:42 <ddarius> chessguy: It is.
22:08:49 <glguy> newsham: I think that both State and StateT are in the mtl
22:08:54 <newsham> arent the transformers from the template library?
22:09:30 <sjanssen> mtl is actually the "Monad transformer library"
22:09:37 <chessguy> so basically it's just all the monads and transformers that we all know and love
22:09:45 <newsham> I told you I can come up with a stupid answer!
22:09:53 <ddarius> chessguy: Yes.
22:09:56 <sjanssen> but it contains both transformer and non-transformer versions of all the monads
22:09:58 <ddarius> well...
22:09:58 * glguy grew up on the STL
22:10:05 <glguy> and lives *in* STL
22:10:14 <newsham> glguy: hmm.. rough neighborhood :(
22:10:29 <glguy> certain parts of the city are rougher than others :)
22:10:34 <sorear> night
22:10:35 <newsham> Announcing version 0.1 of the
22:10:35 <newsham> Haskell Monad Template Library
22:10:43 <newsham> Looks like "template" to me
22:10:50 <ddarius> newsham: It is.
22:11:06 <sjanssen> huh
22:11:19 <sjanssen> the .cabal file calls it the monad transformer library
22:11:25 <glguy> mtl
22:11:26 <newsham> revisionism?
22:11:26 <glguy> A monad transformer library, inspired by the paper Functional Programming with Overloading and Higher-Order Polymorphism, Mark P Jones (http://www.cse.ogi.edu/~mpj/) Advanced School of Functional Programming, 1995.
22:11:27 <lambdabot> Title: Redirect: Web resource has moved
22:11:32 <glguy> http://haskell.org/ghc/docs/latest/html/libraries/
22:11:49 <newsham> we were never "template", we were always "transformer!"
22:11:53 <glguy> maybe this explains why there is disagreement here over the name
22:12:23 <hpaste>  avnit pasted "parse field" at http://hpaste.org/387
22:12:34 <sjanssen> newsham: where is that announcement?
22:12:49 <chessguy> ?poll
22:12:49 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
22:12:52 <newsham> we were never 'stay the course.'
22:13:00 <newsham> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg05564.html
22:13:01 <lambdabot> Title: ANNOUNCE: The Haskell Monad Template Library
22:13:07 <chessguy> ?poll-add What does MTL stand for?
22:13:07 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
22:13:28 <chessguy> ?poll-add WhatDoesMTLstandFor
22:13:29 <lambdabot> Added new poll: "WhatDoesMTLstandFor"
22:13:58 <newsham> ?list poll
22:13:58 <chessguy> ?poll-show WhatDoesMTLstandFor
22:13:58 <ddarius> @oldwiki MonadTemplateLibrary
22:13:58 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
22:13:59 <lambdabot> []
22:13:59 <lambdabot> http://www.haskell.org/hawiki/MonadTemplateLibrary
22:14:11 <newsham> ?help vote
22:14:11 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
22:14:41 <newsham> ?help choice-add
22:14:42 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
22:14:52 <glguy> It does make sense for "Monad Template Library" since State isn't a monad but State Int is
22:15:03 <chessguy> vote WhatDoesMTLstandFor MonadicTerroristLambdas
22:15:09 <chessguy> ?vote WhatDoesMTLstandFor MonadicTerroristLambdas
22:15:10 <lambdabot> "MonadicTerroristLambdas" is not currently a candidate in this poll
22:15:14 <chessguy> boo!
22:15:25 <glguy> just like the C++ STL has generic lists... mtl has generic monads
22:15:50 <chessguy> ?choice-add WhatDoesMTLstandFor MonadTransformerLibrary
22:15:51 <lambdabot> New candidate "MonadTransformerLibrary", added to poll "WhatDoesMTLstandFor".
22:15:58 <chessguy> ?choice-add WhatDoesMTLstandFor MonadTemplateLibrary
22:15:59 <lambdabot> New candidate "MonadTemplateLibrary", added to poll "WhatDoesMTLstandFor".
22:16:14 <chessguy> ?poll-result WhatDoesMTLstandFor
22:16:14 <lambdabot> Poll results for WhatDoesMTLstandFor (Open): MonadTemplateLibrary=0, MonadTransformerLibrary=0
22:16:16 <bd_> @vote WhatDoesMTLstandFor MonadTransformerLibrary
22:16:16 <lambdabot> voted on "MonadTransformerLibrary"
22:16:29 <glguy> @vote WhatDoesMTLstandFor MonadTemplateLibrary
22:16:29 <lambdabot> voted on "MonadTemplateLibrary"
22:16:55 <glguy> !say @vote WhatDoesMTLstandFor MonadTemplateLibrary
22:16:55 <hpaste> @vote WhatDoesMTLstandFor MonadTemplateLibrary
22:16:56 <lambdabot> voted on "MonadTemplateLibrary"
22:16:59 <glguy> ha!
22:17:07 <newsham> ?vote WhatDoesMTLstandFor MightTryLater
22:17:07 <lambdabot> "MightTryLater" is not currently a candidate in this poll
22:17:13 <jcreigh> vote early and often. :)
22:17:13 <bd_> cheater!
22:17:17 <chessguy> ?choice-add WhatDoesMTLstandFor MonadicTerroristLambdas
22:17:18 <lambdabot> New candidate "MonadicTerroristLambdas", added to poll "WhatDoesMTLstandFor".
22:17:24 <bd_> ?vote WhatDoesMTLstandFor MetaFunctorLambda
22:17:24 <lambdabot> "MetaFunctorLambda" is not currently a candidate in this poll
22:17:45 <newsham> ?vote WhatDoesMTLstandFor MuchToLearn
22:17:46 <lambdabot> "MuchToLearn" is not currently a candidate in this poll
22:18:07 <chessguy> hmm, that one's appropriate
22:18:23 <jcreigh> @choice-add WhatDoesMTLstandFor MuchToLearn
22:18:24 <lambdabot> New candidate "MuchToLearn", added to poll "WhatDoesMTLstandFor".
22:18:34 <jcreigh> @vote WhatDoesMTLstandFor MuchToLearn
22:18:35 <lambdabot> voted on "MuchToLearn"
22:18:50 <glguy> yess... spread your votes thin... hpaste and I shall be victorious!
22:18:56 <ddarius> @vote WhatDoesMTLstandFor MuchTooLazy
22:18:57 <lambdabot> "MuchTooLazy" is not currently a candidate in this poll
22:19:24 <bd_> glguy: Because of course IRC polls are a statistically significant, accurate, and reliable source of information :)
22:19:27 <jcreigh> glguy: hmm...good point. We may need to abandon the "first past the post" system. :)
22:19:28 <newsham> ?vote WhatDoesMTLstandFor MyThirdLanguage
22:19:29 <lambdabot> "MyThirdLanguage" is not currently a candidate in this poll
22:20:00 <bd_> jcreigh: Hm... condorcet model? :)
22:20:04 <chessguy> ?vote MysteriouslyTroublesomeLambdas
22:20:04 <lambdabot> usage: @vote <poll> <choice>
22:22:20 <chessguy> ?poll-list
22:22:20 <lambdabot> ["WhatDoesMTLstandFor","Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
22:22:44 <chessguy> ?poll-result Written_a_compiler_or_interpreter
22:22:45 <lambdabot> No such poll: "Written_a_compiler_or_interpreter"
22:22:47 <chessguy> ?poll-result Written_a_compiler_or_interpreter?
22:22:48 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=4, Yes=15
22:23:39 <kolmodin> ?help vote
22:23:39 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
22:23:49 <abz> @vote Written_a_compiler_or_interpreter Yes
22:23:49 <lambdabot> No such poll:"Written_a_compiler_or_interpreter"
22:24:02 <dons> ?
22:24:08 <kolmodin> ?vote Written_a_compiler_or_interpreter? Yes
22:24:08 <lambdabot> voted on "Yes"
22:24:27 <abz> ?vote Written_a_compiler_or_interpreter? Yes
22:24:28 <lambdabot> voted on "Yes"
22:24:34 <chessguy> ?vote Written_a_compiler_or_interpreter? No
22:24:34 <lambdabot> voted on "No"
22:24:44 * chessguy hangs his head in shame
22:24:47 <beelsebob> ?vote Written_a_compiler_or_interpreter? Yes
22:24:48 <lambdabot> voted on "Yes"
22:25:04 <steven_ashley> ?vote Written_a_compiler_or_interpreter? Yes
22:25:05 <lambdabot> voted on "Yes"
22:25:14 <chessguy> ?poll-result Written_a_compiler_or_interpreter?
22:25:15 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=5, Yes=19
22:25:23 <jcreigh> hmmm...hard to know how to vote on that one. I've written a handful of toy interpreters, but nothing you could really do anything with.
22:25:27 <ddarius> @vote Written_a_compiler_or_interpreter? Yes
22:25:28 <lambdabot> voted on "Yes"
22:25:43 <jcreigh> I usually get it to where I can write factorial and call it good. :)
22:25:54 <beelsebob> Jam
22:26:02 <chessguy> > (20/25) - (15/19)
22:26:03 <lambdabot>  1.0526315789473717e-2
22:26:07 <beelsebob> ?vote Written_a_compiler_or_interpreter? Jam
22:26:08 <lambdabot> "Jam" is not currently a candidate in this poll
22:26:11 <beelsebob> bah
22:26:19 <beelsebob> lambdabot too clever
22:27:12 <chessguy> ?rember jcreigh I've written a handful of toy interpreters, but nothing you could really do anything with. I usually get it to where I can write factorial and call it good.
22:27:13 <lambdabot> Done.
22:27:19 <chessguy> heh.
22:27:24 <chessguy> it knows how to 'rember' things
22:27:26 <ibid> ?vote Written_a_compiler_or_interpreter? Yes
22:27:26 <lambdabot> voted on "Yes"
22:28:21 <chessguy> > (21/26) - (15/19)
22:28:22 <lambdabot>  1.8218623481781382e-2
22:28:59 <newsham> Written_a_compiler_and_then_written_an_interpreter_with_it?
22:29:21 <chessguy> > 21/26
22:29:22 <lambdabot>  0.8076923076923077
22:29:30 <jcreigh> well, a self-hosting compiler is the holy grail, of course.
22:29:36 <chessguy> wow, 80%. that's staggering
22:29:45 <mauke> I've done the interpreter->interpreter thing
22:30:00 <chessguy> i bet it's more like .8% in most languages
22:30:03 <ddarius> mauke: That's pretty easy.
22:30:28 <ddarius> I wrote a lambda calculus interpreter (as a lambdabot module) and then implemented Joy in it.
22:30:57 <ddarius> It was impressively slow, especially considering I could have trivially added first class state to the LC interpreter.
22:31:45 <jcreigh> gah, now people are going to talk about how many orders of magnitude smarter they are than me. #haskell is the only channel where, if somebody said, "I invented the internet", I would believe them. :)
22:32:20 <chessguy> jcreigh, did i ever tell you about the time i worked for Arpanet...?
22:32:22 <mauke> I'm not smarter, I'm just more efficiently stupid
22:32:26 <jcreigh> chessguy: lol
22:33:45 <jcreigh> But I've been thinking about the self-hosting compiler thing. Seems like you could bootstrap an interpreter in, eg, Haskell fairly easily. The problem is making the language advanced enough to write a compiler in it, but still simple enough to write a compiler for it.
22:34:10 <ddarius> jcreigh: That's actually fairly easy to do.
22:34:39 <mauke> is there a tutorial for writing non-retarded compilers?
22:34:43 <newsham> > do { x <- [1..]; y <- [3*x .. 4*x]; if abs (y/x - pi) < 0.1 then return (y,x) else [] }
22:34:45 <lambdabot>  [(16.0,5.0),(19.0,6.0),(22.0,7.0),(25.0,8.0),(28.0,9.0),(29.0,9.0),(31.0,10....
22:35:05 <Pseudonym> mauke: Not for Scheme.
22:35:14 <Pseudonym> You can only write retarded compilers for Scheme.
22:35:20 <chessguy> so what does "newtype Stack a b = Stack ([a] -> ([a],b))" actually do? i understand (now) that it's just simply saying that Stack a b is pretty much just short-hand for...that other expression, but...what does the declaration actually do? does Stack then automatically derive things like Show, Eq, etc...?
22:35:22 <procyon_> ?vote Written_a_compiler_or_interpreter? Yes
22:35:23 <lambdabot> voted on "Yes"
22:35:37 <ddarius> Self had a very non-retarded compiler, but the documents aren't very "tutorial"
22:35:48 <Pseudonym> Yeah, that's the catch.
22:35:58 <mbishop> I hear "Modern Compiler Construction in ML" or some such is good
22:36:07 <Anon4888> What are the constraints on the "self-hoisting compiler" problem?
22:36:42 <newsham> I wrote a parser generator that used itself to parse spec files.
22:36:46 <newsham> that was a pain to bootstrap
22:36:55 <jcreigh> Anon4888: well, it would be cool if it used a real instruction set. But I'm flexible. You guys think it would be easier to compile to LLVM or something?
22:36:59 <newsham> (and always had to keep old versions around just in case something went wrong)
22:37:02 <mbishop> http://www.cs.princeton.edu/~appel/modern/ml/
22:37:03 <lambdabot> Title: Modern Compiler Implementation in ML
22:37:48 <newsham> early versions had the grammar hard wired in, and then later i rewrote it with a grammar from a spec file
22:37:49 <ddarius> Kay's paper on LtU got me back into wanting to write an image-based system again.
22:38:01 <ddarius> s/paper/proposal/
22:38:09 <procyon_> I want a tutorial on interpreter writing that is heavy on type inference.  Those seem to be in short supply.
22:39:16 <ddarius> procyon_: Writing an intepreter and writing a type checker are somewhat orthogonal.
22:40:43 <Cale> Well, typeclasses put a bit of a wrench into that idea.
22:41:13 <procyon_> But, unless you are doing a scheme interpreter (which is trivial) then they go hand in hand.
22:41:27 <ddarius> Cale: True.
22:43:37 <jcreigh> if you answered "yes" to the "written a compiler?" question: What instruction set did you target?
22:43:39 <ddarius> procyon: In many cases, you can write an interpreter for a manifestly typed language or an untyped one.  And write a completely separate type inferer/checker.
22:43:57 <procyon_> Getting my mind around evaluating AST's was easy (thanks in no small part to SICP)  Type inference algorithms still stretch my mind, and the available tutorials are either WAY too advanced to someone learning the subject, or way too dismissive of the intricacies (PLAI)
22:44:34 <ddarius> Hindley-Milner is pretty straight-forward.
22:45:19 <Anon4888> Is type inference usually implemented in a stateful way?
22:45:25 <procyon_> ddarius: the only good tutorial on the subject I've seen for it though is Implementation of Functional languages... written for Miranda in the mid 80's.
22:45:56 * ddarius should download a C++ compiler.
22:45:58 <Anon4888> (ie maintaining a growing environment of type variable bindings)?
22:46:01 <procyon_> Anon4888: no.  It's a non-statefil algorithm
22:46:44 <Anon4888> hmm, does TAPL have a section on that?
22:46:51 <ddarius> Anon4888: Most likely a stateful implementation of unification is used.
22:47:02 <Anon4888> Yes unification is what I was talking about
22:47:04 <ddarius> For real type checkers.
22:47:05 <Anon4888> sorry
22:48:25 <procyon_> I haven't read TAPL yet (on my list) but I hear it's only in the second book in the series that inference algorithms are covered, and then lightly.
22:51:57 <Anon4888> I just got TAPL and ATAPL a couple of days ago (crappy european economy addition, but cheap :).  I'm about half way through TAPL and it seems pretty
22:52:01 <Anon4888> basic
22:52:41 <newsham> > 3%2
22:52:42 <lambdabot>  3%2
22:52:48 <newsham> where is % defined?
22:53:04 <Lemmih> @index (%)
22:53:05 <lambdabot> Data.Ratio
22:53:27 <kolmodin> morning Lemmih
22:54:27 <procyon_> Why aren't there generic AST and Type Inference libraries for haskell?  We have lexer/parser libraries, which are hard by comparison.
22:54:28 * ddarius isn't really interested in TAPL. ATTAPL though...
22:55:04 <ddarius> procyon_: ASTs and type systems are fairly language specific and monolithic.
22:56:10 <procyon_> ddarius: AST's are, but there are a finite number of permutations that are reasonable... arguably less than Parser semantics, and there are tons of commonalities.
22:57:04 <procyon_> ddarius: Type Inference algorithms, given a standard AST should also be pretty stock, especially for HM.
22:58:19 <newsham> > do { x <- [1..]; y <- [3*x .. 4*x]; let r = y%x; if abs (fromRational r - pi) < 0.05 then return r else [] }
22:58:19 <lambdabot>  Parse error
22:58:20 <procyon_> It just seems like DSL's would be much more common if those were available.
22:58:25 <newsham> whats my error?
22:59:21 <glguy> newsham: let { a = b}
23:01:17 <ddarius> procyon_: DSLs wouldn't find a "stock" HM type inferencer handy.
23:01:45 <newsham> how does it parse without the {}'s?
23:02:02 <glguy> like you are defining a function named if
23:02:21 <procyon_> hmmm.
23:02:56 <glguy> > do { x <- [1..]; y <- [3*x .. 4*x]; let { r = y%x}; if abs (fromRational r - pi) < 0.05 then return r else [] }
23:02:58 <lambdabot>  [19%6,22%7,25%8,28%9,31%10,35%11,19%6,41%13,22%7,47%15,25%8,51%16,53%17,54%1...
23:03:21 <newsham> is there a generalization of "min" and "max" for taking a "best" value from a list?
23:03:29 <glguy> maximumBy
23:03:33 <glguy> :t maximumBy
23:03:35 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
23:03:40 <glguy> :t minimumBy
23:03:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
23:04:57 <procyon_> ddarius: my current one would ;)
23:05:19 <newsham> I often which there were variants for those types of functions where they did :   maximumBy (\a b -> f a `compare` f b)
23:05:27 <newsham> (similar for sortBy)
23:05:31 <ddarius> procyon_: What's the domain?
23:06:11 <glguy> comparing f x y = f x `compare` f y
23:06:40 <glguy> on f g x y = g x `f` g y
23:07:18 <newsham> *nod* i end up writing one, but i shouldnt have to
23:07:21 <newsham> its a common idiom.
23:07:34 <glguy> OK.. then compile GHC HEAD
23:07:34 <newsham> sortByKey snd
23:10:04 <newsham> ?where tails
23:10:04 <lambdabot> I know nothing about tails.
23:10:14 <newsham> ?index tails
23:10:15 <lambdabot> Data.List
23:10:23 <procyon_> ddarius: I'm doing a strongly typed S,K,I + Y + Bool/Int/Char primitives for GP.  The code I'm writing seems *very* stock and I'm wondering why there's no libs for such a thing.
23:10:49 <procyon_> ddarius: (where S,K,I and Y are the standard combinators)
23:12:48 <procyon_> ddarius: It's so stock I'm wondering why I had to learn the domain of Type inference (I already know interpreter writing) to write such a thing.  I envision that a standard haskell lib should contain a function that takes an AST and returns it's type :)
23:15:18 <procyon_> ddarius: I'm almost beginning to suspect that it's conspicuously missing, as is a Parsec.Language lexer for Lisp langs (even though it has obscure ones) to encourage people to do their CS homework ;)
23:15:19 <ddarius> http://www.program-transformation.org/Stratego/WebHome perhaps
23:15:21 <lambdabot> Title: Stratego / Web Home
23:19:20 <procyon_> ddarius: I want to stay in haskell, as the GP is a small component of the whole project.
23:20:21 <ddarius> procyon_: The simplest thing would be to use a(n) (partial) EDSL approach.
23:21:01 <newsham> > scanl (\a b -> if d a < d b then a else b) 0 [y%x | x<-[1..], y<-[3*x..4*x]] where d x = abs $ fromRational x - pi
23:21:02 <lambdabot>  Parse error
23:21:32 <newsham> > let d x = abs (fromRational x - pi) in scanl (\a b -> if d a < d b then a else b) 0 [y%x | x<-[1..], y<-[3*x..4*x]]
23:21:34 <lambdabot>  [0%1,3%1,3%1,3%1,3%1,3%1,3%1,3%1,3%1,3%1,3%1,13%4,13%4,13%4,13%4,13%4,16%5,1...
23:21:49 <hpaste>  setuid_w00t pasted "let and where abuse" at http://hpaste.org/388
23:22:11 <procyon_> ddarius: That I'm doing, but I need to reflect the type at run time in order to grow the AST in legal ways, so I'm limited to embedding only function application and primitives.
23:22:23 <newsham> ?list vote
23:22:24 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
23:22:34 <newsham> ?help poll-show
23:22:34 <lambdabot> poll-show <poll>            Shows all choices for some poll
23:23:22 <setuid_w00t> If someone could take a look at that, I would appreciate it.  I think It will be easy to fix if you know haskell.
23:25:30 <procyon_> setuid_w00t: it would appear your last line is indented too far, so it's inside the let clause instead of part of the where defines
23:26:33 <ddarius> With GADTs you can use Haskell's type system to type check the AST
23:27:27 <setuid_w00t> procyon_: I want it to be inside the let clause.  Maybe I can move the line with the 'in' infront of it up above the 'let' line
23:28:01 <procyon_> ddarius: Interesting.  I haven't done anything with GADTs yet, as I'm still learning the language (forcing myself, through much pain, to do this project in haskell in order to learn it)
23:28:29 <ddarius> procyon_: There are other ways but GADTs are the most direct.
23:28:41 <procyon_> setuid_w00t: no, put a where in front of the last line.
23:30:40 <procyon_> setuid_w00t:  you can't do a function definition inside your "in" without explicitly saying "where" again ;)
23:31:13 <setuid_w00t> procyon_: ahh, that makes sense
23:32:45 <procyon_> setuid_w00t: or you could move it up before your in and make it one of your let declarations (you can have more than one).  It's a style choice.
23:32:55 <newsham> ?hoogle [a] -> [a]
23:32:56 <lambdabot> Prelude.cycle :: [a] -> [a]
23:32:56 <lambdabot> Prelude.init :: [a] -> [a]
23:32:56 <lambdabot> Prelude.reverse :: [a] -> [a]
23:33:57 <nmessenger> @where hoogle
23:33:58 <lambdabot> http://www.haskell.org/hoogle
23:34:03 <nmessenger> ^^ if you want more results
23:34:17 <newsham> is there a function on lists that removes adjacent duplicates?
23:34:21 <newsham> (like nub, but more local)
23:34:42 <nmessenger> map head . group?
23:35:10 <nmessenger> > map head . group $ [1,1,1,2,6,12,12,6,7,1,1,2,3,9]
23:35:11 <lambdabot>  [1,2,6,12,6,7,1,2,3,9]
23:35:28 <newsham> > map head . group "foobarr"
23:35:29 <lambdabot>      Expecting a function type, but found `[[a]]'
23:35:29 <lambdabot>       Expected type: a1 -> ...
23:35:34 <newsham> > map head . group $ "foobarr"
23:35:36 <lambdabot>  "fobar"
23:35:37 <mauke> @poste
23:35:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:35:40 <newsham> yah, that'll do
23:38:27 <newsham> > let d x = abs (fromRational x - pi) in (map head).group $ scanl (\a b -> if d a < d b then a else b) 0 [y%x | x<-[1..], y<-[3*x..4*x]]
23:38:31 <lambdabot> Terminated
23:38:46 <newsham> > let d x = abs (fromRational x - pi) in take 5 $ (map head).group $ scanl (\a b -> if d a < d b then a else b) 0 [y%x | x<-[1..], y<-[3*x..4*x]]
23:38:48 <lambdabot>  [0%1,3%1,13%4,16%5,19%6]
23:40:58 <newsham> > let d x = abs (fromRational x - pi) in take 14 $ (map head).group $ scanl (\a b -> if d a < d b then a else b) 0 [y%x | x<-[1..], y<-[3*x..4*x]]
23:41:00 <lambdabot>  [0%1,3%1,13%4,16%5,19%6,22%7,179%57,201%64,223%71,245%78,267%85,289%92,311%9...
23:41:11 <newsham> > 355/113
23:41:13 <lambdabot>  3.1415929203539825
23:41:14 <newsham> > pi
23:41:16 <lambdabot>  3.141592653589793
23:43:03 <nmessenger> > 355/113 - pi
23:43:04 <lambdabot>  2.667641894049666e-7
23:43:36 <newsham> not too shabby
23:44:25 <nmessenger> > abs (22/7 - pi) - abs (355/113 - pi)
23:44:26 <lambdabot>  1.2642225031602727e-3
23:45:30 <newsham> > let d x = abs (fromRational x - pi) in d (179%57)
23:45:31 <lambdabot>  1.2417763968106676e-3
23:45:39 <newsham> > let d x = abs (fromRational x - pi) in d (201%64)
23:45:40 <lambdabot>  9.67653589793116e-4
23:46:36 <newsham> whats a function that returns undefined?
23:46:46 <nmessenger> const undefined or error
23:46:56 <newsham> > error "foo"
23:46:58 <lambdabot>  Add a type signature
23:47:00 <nmessenger> or are you asking what it means?
23:47:06 <nmessenger> > error "foo" :: ()
23:47:07 <lambdabot>  Exception: foo
23:47:19 <newsham> > undefined
23:47:20 <lambdabot>  Add a type signature
23:47:21 <nmessenger> > const undefined "foo" :: ()
23:47:23 <lambdabot>  Undefined
23:47:32 <newsham> > undefined :: Int
23:47:33 <lambdabot>  Undefined
23:48:25 <nmessenger> though "returns undefined" is, strictly speaking (lazily speaking?), pretty meaningless :P
23:49:23 <setuid_w00t> What is the correct function to call in order to convert an Int to a Float?
23:49:32 <nmessenger> @type fromIntegral
23:49:34 <lambdabot> forall b a. (Num b, Integral a) => a -> b
23:49:59 <nmessenger> > fromIntegral (1 :: Int) :: Float
23:50:01 <lambdabot>  1.0
23:51:45 <nmessenger> > error "I haven't implemented this function yet!" :: Int -> Bool
23:51:47 <lambdabot>  <Int -> Bool>
23:52:31 <nmessenger> > it 5
23:52:32 <lambdabot>   Not in scope: `it'
23:52:42 <nmessenger> :(
23:54:31 <mbishop> > atan 1 * 4
23:54:32 <lambdabot>  3.141592653589793
23:54:37 <mbishop> > pi
23:54:39 <lambdabot>  3.141592653589793
23:55:03 <Thunder> @src pi
23:55:03 <lambdabot> Source not found. That's something I cannot allow to happen.
23:55:12 <nmessenger> @src Double pi
23:55:13 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:55:29 <Thunder> Sad. It should be pi = 4 * atan 1
23:56:33 <mbishop> > atan (sqrt 3) * 3
23:56:34 <lambdabot>  3.141592653589793
23:57:19 <newsham> > 52163 / 16604
23:57:21 <lambdabot>  3.141592387376536
23:58:13 <newsham> > 104348/33215
23:58:13 <procyon_>  e**atan (sqrt 3) * 3 * i =0
23:58:15 <lambdabot>  3.141592653921421
23:58:19 <procyon_> :D
23:58:56 <nmessenger> > i
23:58:57 <lambdabot>   Not in scope: `i'
23:59:24 <newsham> > 833719/265381
23:59:25 <lambdabot>  3.141592653581078
