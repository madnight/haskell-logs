00:02:24 <Stinger> @seen dcoutts
00:02:24 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 9h 17m 11s ago.
00:02:31 <Stinger> hmm
00:06:00 <hpaste>  chessguy pasted "a few possible type definitions" at http://hpaste.org/476
00:07:01 <chessguy> sorry, that wasn't really meant for the channel
00:07:28 <vagif> question
00:07:40 <vagif> how to use function randoms ?
00:07:49 <chessguy> ?hoogle randoms
00:07:49 <lambdabot> Random.randoms :: (Random a, RandomGen b) => b -> [a]
00:07:49 <lambdabot> System.Random.randoms :: (Random a, RandomGen g) => g -> [a]
00:08:08 <vagif> it does not tell me anything. but 1 line example would do
00:08:49 <vagif> in other words how to get list of random numbers ?
00:09:50 <chessguy> do { g <- mkStdGen; return $ take 10 (randoms g); }
00:09:55 <chessguy> > do { g <- mkStdGen; return $ take 10 (randoms g); }
00:09:56 <lambdabot>  Add a type signature
00:10:44 <chessguy> do { g <- mkStdGen; return $ (take 10 (randoms g))::[Int]; }
00:10:50 <chessguy> > do { g <- mkStdGen; return $ (take 10 (randoms g))::[Int]; }
00:10:51 <lambdabot>  Couldn't match `Int' against `[a]'
00:11:23 <allbery_b> mkStdGen needs an argument
00:11:30 <chessguy> oh, whoops
00:11:47 <chessguy> > do { g <- mkStdGen 42; return $ (take 10 (randoms g))::[Int]; }
00:11:48 <lambdabot>  Couldn't match `t t1' against `StdGen'
00:12:00 <allbery_b> :t mkStdGen
00:12:01 <lambdabot> Int -> StdGen
00:12:17 <chessguy> ?hoogle RandomGen
00:12:18 <lambdabot> System.Random.RandomGen :: class RandomGen g
00:12:23 <chessguy> ?hoogle StdGen
00:12:24 <lambdabot> System.Random.StdGen :: data StdGen
00:12:24 <lambdabot> Random.getStdGen :: IO StdGen
00:12:24 <lambdabot> Random.mkStdGen :: Int -> StdGen
00:12:51 <chessguy> hmm, guess they're not the same
00:13:25 <allbery_b> StdGen is a RandomGen
00:13:40 <chessguy> i'm way too tired to think about this tonight
00:13:55 <chessguy> allbery_b, what'd i do wrong then?
00:14:21 <allbery_b> only thing I can think of is that in the absence of other monads it decided you were in []
00:14:35 <allbery_b> (mkStdGen is not in IO)
00:14:40 <chessguy> sure
00:15:11 <allbery_b> > let g = mkStdGen 42 in take 10 ((randoms g) :: [Int])
00:15:12 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
00:15:18 <allbery_b> ding
00:15:23 <chessguy> nice
00:15:29 <vagif> thx
00:15:48 <chessguy> i've probably seen examples very similar to that
00:16:01 <chessguy> but hey, it's after 3 am :)
00:16:06 <allbery_b> yeh
00:16:33 * allbery_b should probablytry to nap, since getting home so late today fouled any chance of going to bed at a sane time and must be up early for meeting :/
00:16:44 <chessguy> ?localtime allbery_b
00:16:45 <lambdabot> Local time for allbery_b is Tue Feb 13 03:15:29
00:17:24 <chessguy> bleah, i've been hacking away for the last 8 hours or so
00:17:26 <chessguy> off and on
00:17:34 <vagif> actually what i needed is shuffling the list, but i thought i'll zip it with random list and then order by
00:17:49 <vagif> is there simpler way to randomize list ?
00:18:25 <chessguy> i just read an article or something about doing that
00:20:01 <chessguy> perhaps this will interest you: http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers?action=highlight&value=shuffle
00:20:03 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/2e6qz6
00:21:27 <hpaste>  kolmodin pasted "'darcs get bnfc' fails" at http://hpaste.org/477
00:21:42 <xpika> i get error make: hugs-package: Command not found
00:21:48 <kolmodin> bringert: http://hpaste.org/477
00:21:55 <xpika> how should i set it to ghc?
00:21:55 <vagif> wow ! thx
00:22:21 <vincenz> holy cow\
00:22:25 <vincenz> that's just messed up
00:22:29 <vincenz> math books that teach geography
00:22:33 <vincenz> and 'how to use calculators'
00:22:44 <xpika> --prefix ZQg GHCi.
00:22:45 <xpika> [xpika@fedbox ~]$ IRSSI
00:22:53 <xpika> sorry
00:23:00 <xpika> paste mucked up
00:23:04 <xpika> g GHCi.
00:23:05 <xpika> [xpika@fedbox ~]$ IRSSI
00:23:08 <xpika> damn
00:23:21 <vincenz> xpika: use @paste?
00:23:22 <vincenz> @paste
00:23:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:23:25 <xpika> again
00:23:28 <xpika> lol
00:23:36 <xpika> im trying to paste from xterm
00:23:41 <vincenz> xpika: use @paste
00:23:41 <xpika> 1 line
00:24:29 <bringert> kolmodin: use --partial
00:24:52 <kolmodin> bringert: ok
00:25:03 <bringert> kolmodin: I'm not sure what it is, but it could be one of those case-change things
00:25:12 <xpika> --prefix /usr/lib/ghc-6.6/?
00:25:43 <kolmodin> bringert: I thought those only happened under windows
00:25:59 <xpika> for make-configuring a haskell package?
00:26:07 <vincenz> @tell ndm Basically you want first-class patterns :)
00:26:07 <lambdabot> Consider it noted.
00:26:28 <bringert> kolmodin: they happen on any case-insensitive file system
00:27:01 <bringert> kolmodin: there's another class that fails on Windows: using a reserved filename, like NUL, CON, etc.
00:27:20 <kolmodin> bringert: right...
00:28:14 <kolmodin> bringert: ok, my friend says it works with --parial
00:28:19 <kolmodin> --partial
00:28:40 <kolmodin> bringert: thanks a bunch
00:29:10 <vagif> here's my try on randomizing lists:
00:29:12 <vagif> randomList n = let g = mkStdGen 42 in take n ((randoms g) :: [Int])
00:29:12 <vagif> randomize l = fst $ unzip $ sort $ zip l (randomList $ length l)
00:33:47 <vagif> ups that was wrong
00:33:54 <vagif> randomize l = snd $ unzip $ sort $ zip (randomList $ length l) l
00:34:10 <vagif> but the problem is - it always returns ó same randomized list
00:34:58 <MechaBlue> It looks like you aren't setting the seed properly at some point
00:35:59 <Stinger> yes set seed based on time, not just constant in mkStdGen
00:38:19 <Cale> @type newStdGen
00:38:20 <lambdabot> IO StdGen
00:38:44 <Cale> This will give you a new generator, in the IO monad, which you can then pass down to your pure code.
00:39:06 --- mode: ChanServ set +b *!*@pool-71-105-96-215.lsanca.dsl-w.verizon.net
00:39:20 <Stinger> anyone got gtk2hs working with ghc 6.6 in windows?
00:39:44 <dons> > map fst $ sortBy (\(_,a)(_,b)->a`compare`b) $ zip "haskell" (randoms (mkStdGen 42) :: [Integer])
00:39:45 <lambdabot>  "hlsleka"
00:39:52 <dons> > map fst $ sortBy (\(_,a)(_,b)->a`compare`b) $ zip "haskell" (randoms (mkStdGen 44) :: [Integer])
00:39:54 <lambdabot>  "ahkslle"
00:41:27 <MechaBlue> randomList n = let g = getStdGen in take n ((randoms g) :: [Int])
00:41:44 <MechaBlue> Will that work well?
00:42:18 <allbery_b> no reason to use the let, actally; I did so only to mimic the monadic syntax
00:42:39 <MechaBlue> randomList n = take n ((randoms getStdGen) :: [Int])
00:42:48 <allbery_b> > take 6 ((randoms (mkStdGen 42)) :: [Int])
00:42:49 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631]
00:43:01 <Cale> MechaBlue: it's a type error
00:43:05 <Cale> @type getStdGen
00:43:06 <lambdabot> IO StdGen
00:43:20 <allbery_b> getStdGen requires IO monad, yeh
00:43:23 <Cale> getStdGen is an IO action which gets the current random generator
00:43:28 <MechaBlue> Right, right.  I guess I need a lift in there somewhere
00:43:33 <Cale> You defined g to be the same IO action
00:43:36 <allbery_b> go back to chessguy's original version but with getStdGen
00:43:38 <Cale> no, you need a do
00:43:46 <Cale> (or bind)
00:44:19 <allbery_b> > do { g <- getStdGen; return $ (take 10 (randoms g))::[Int]; }
00:44:20 <lambdabot>  Couldn't match `Int' against `[a]'
00:44:24 <allbery_b> hm
00:44:36 <MechaBlue> Yeah
00:44:56 <Cale> > do { g <- getStdGen; return $ (take 10 (randoms g) :: [Int]); }
00:44:57 <lambdabot>  <IO [Int]>
00:45:12 <allbery_b> durrr, idn't notice the misplaced paren
00:45:18 <Cale> Type signatures scope over the entire expression.
00:45:25 <Cale> (even with $ :)
00:45:25 * allbery_b should really be in bed, sigh
00:45:41 <Cale> anyone looked at the new fusion technique?
00:45:48 <Cale> It looks pretty awesome.
00:46:18 <Cale> Hopefully we can get something like that into GHC soon :)
00:47:04 <vincenz> Cale: it's on reddit ;)
00:47:11 <Cale> vincenz: yes
00:47:17 <Cale> vincenz: I know you've seen it :)
00:47:55 <Cale> This looks like a pretty big step forward, for such a clever little trick :)
00:54:30 <MechaBlue> Link?
00:55:41 <allbery_b> this is from LtU?
00:55:52 <Cale> http://www.pllab.riec.tohoku.ac.jp/~ohori/research/OhoriSasanoPOPL07.pdf
00:55:55 <lambdabot> http://tinyurl.com/2xoonv
00:56:07 <Cale> http://programming.reddit.com/info/14a3f/comments
00:56:08 <lambdabot> Title: Novel fusion techniques (reddit.com)
00:56:25 <Cale> oh, it's also on LtU
00:58:13 <MechaBlue> Thank you :)
01:08:14 <Syzygy-> Gmrrrrrn
01:10:08 <Cale> huh?
01:17:34 <dcoutts> Stinger, yes, I build gtk2hs with ghc 6.6 in windows. Have you tried the latest release candidate?
02:00:20 <dcoutts_> Igloo, some of the cabal verbosity levels are messed up
02:00:34 <dcoutts_> with the current darcs Cabal version
02:01:05 <dcoutts_> eg a normal build is showing me the ghc --make command it's running.
02:03:17 <tuukkah> hello dcoutts_, got time to help with a small gtk wrapping problem?
02:03:27 <dcoutts_> tuukkah, sure
02:03:42 <pjd> f = fix f.Î»x.E_f
02:04:12 <pjd> is that first dot application?
02:04:21 <tuukkah> dcoutts, this compiles but doesn't work right: makeNewGObject mkStyle $ liftM castPtr $ {# call gtk_rc_get_style #} $ castPtr $ unsafeForeignPtrToPtr $  unWidget $ toWidget widget
02:07:02 <Stinger> ah dcoutts, any idea why the g2khs windows installer wont find my installation of ghc 6.6?
02:07:06 <pjd> can anyone help me decipher that definition?
02:07:10 <quicksilver> pjd: that came out as weird 8bit rubbish on my screen
02:07:19 <pjd> quicksilver: sorry, UTF-8
02:07:37 <pjd> f = fix f.\x.E_f
02:07:58 <pjd> where \ is lambda, _f is a subscripted f
02:08:33 <pjd> this is from the "Lightweight Fusion by Fixed Point Promotion" paper
02:08:40 <dcoutts_> Stinger, did you use the normal ghc installer or did you install manually? if the latter you need ghc.exe on the path. If the former then perhaps I'm looking for the wrong registry keys (in which case I need your help).
02:09:26 <quicksilver> pjd: yes, probably just application. That's what dots tend to mean in maths
02:09:33 <dcoutts_> tuukkah, hmm ok. So what goes wrong?
02:10:11 <tuukkah> dcoutts, g_object_ref: assertion `G_IS_OBJECT (object)' failed
02:11:26 <dcoutts_> tuukkah, hmm
02:14:09 <Stinger> dcoutts, I used the ghc installer
02:14:12 <Stinger> but I will check the path
02:14:37 <Stinger> oh right keys, yeah I can have a poke in the registry
02:17:12 <pjd> quicksilver: that notation still confuses me
02:17:39 <quicksilver> pjd: blame haskell for adopting a non-standard dot :)
02:17:58 <quicksilver> pjd: although to be honest mathematicians routinely conflate composition and application
02:18:08 <dcoutts_> tuukkah, I'm just trying it myself
02:18:23 <quicksilver> pjd: not really distinguishing between f$g$a and (f.g)$a
02:18:30 <quicksilver> pjd: (because, why should they, they're the same thiing)
02:18:39 <tuukkah> dcoutts, one thing to check would be for null pointer i suppose
02:18:47 <dcoutts_> tuukkah, indeed
02:19:37 <dcoutts_> Stinger, the gtk2hs installer is looking in HKCU and HKLM for \Software\Haskell\GHC\ghc-6.6
02:19:50 <dcoutts_> Stinger, could you check if those exist?
02:20:12 <nornagon> is there a haskell version of C's system()?
02:20:21 <dcoutts_> @hoogle system
02:20:21 <lambdabot> System.system :: String -> IO ExitCode
02:20:21 <lambdabot> System :: module
02:20:21 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
02:20:25 <pjd> quicksilver: what i mean is, i would expect something more along the lines of
02:20:26 <pjd> f' = \f.\x.E_f
02:20:26 <pjd> f = fix f'
02:20:29 <nornagon> (also, how do i access environment variables? like $EDITOR)
02:20:34 <nornagon> dcoutts_: ah :)
02:20:38 <nornagon> @hoogle env
02:20:38 <lambdabot> System.Environment :: module
02:20:39 <lambdabot> System.getEnv :: String -> IO String
02:20:39 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
02:20:43 <nornagon> :)
02:20:46 <nornagon> @botsnack
02:20:47 <lambdabot> :)
02:20:57 <quicksilver> pjd: yes, well I thought that was odd
02:21:08 <quicksilver> pjd: but without the paper in front of me I'm not sure what they meant ;)
02:21:09 <pjd> i'm missing how the fixed point operator is supposed to come into that example
02:21:12 <nornagon> why IO [(String, String)] and not some kind of hash map?
02:21:50 <quicksilver> premature optimization is the root of all evil!
02:22:02 <quicksilver> why bother with a hash map for something as small as the environment?
02:22:17 <quicksilver> it probably costs long to create the buckets than build that whole linked list
02:23:23 <osfameron> isn't it premature optimization not to use a hash map which is the obvious data structure for a key=>value pair ?
02:23:34 <osfameron> (or is that just my perl background showing?)
02:23:34 <dcoutts_> nornagon, because System.getEnv can already do efficient lookup
02:23:43 <nornagon> dcoutts_: i see
02:23:57 <quicksilver> osfameron: no
02:24:00 <quicksilver> osfameron: yes
02:24:02 <quicksilver> osfameron: (respectively)
02:24:03 <nornagon> main = getEnv "EDITOR" >>= system -- i feel dirty :(
02:24:26 <quicksilver> osfameron: hash map is a complex thing and pulls in a dependency on a non-prelude library
02:24:39 <quicksilver> lists are prelude-native and perfectly adequate for this simple task
02:24:41 <nornagon> how can I make the above safe?
02:24:46 <Cale> pjd: fix f. <expr> is the fixed point of the function \f. expr
02:25:04 <osfameron> quicksilver: oh.  Is using libraries a complicated thing in haskell?
02:25:05 <Cale> pjd: and \x. <expr> is just the usual lambda abstraction
02:25:08 <quicksilver> osfameron: no
02:25:15 <Cale> which in Haskell would be \x -> <expr>
02:25:35 <Cale> huh?
02:25:36 <quicksilver> osfameron: but managing dependencies sensibly is something to think about for any library system
02:25:45 <osfameron> fair enough
02:25:49 <quicksilver> osfameron: why pull in a dependency un-necessarily
02:25:49 <Cale> oh, getEnvironment?
02:25:51 <pjd> Cale: ok; it's the first i wasn't sure about
02:25:59 <Cale> It really should be a Map String String
02:26:09 * quicksilver grins and gives up
02:26:12 <Cale> It's just that Data.Map didn't exist.
02:26:14 <quicksilver> Cale's with you, clearly
02:26:37 <pjd> i haven't seen that notation before
02:26:38 <quicksilver> Cale: I was arguing that an assoc-list was perfectly adequate for a small structure like that :p
02:26:41 <osfameron> as I say, to a Perl programmer, almost everything's best implemented with a hash or a regex
02:26:42 <nornagon> so, anyone care to suggest how to make the above program not hilariously broken?
02:26:47 <quicksilver> pjd: 'fix' is a special binder
02:26:49 <Cale> Data.Map is almost always more convenient and gives better performance than a list of pairs of strings
02:26:55 <nornagon> i.e, main = getEnv "EDITOR" >>= system
02:27:04 <quicksilver> pjd: fix is like a 'special lambda with built in fix'
02:27:07 <Cale> It's true that since the environment is usually small, it won't matter too much
02:27:10 <quicksilver> pjd: it's sometimes written \mu
02:27:18 <pjd> quicksilver: is there any place you can look this kind of stuff up? :)
02:27:38 <quicksilver> osfameron: true. And with hashes native, like in perl, they are the right structure for very many tasks
02:27:40 <Cale> pjd: no, I just figured out what it was from context :)
02:27:48 <quicksilver> pjd: mathematical notation? not really
02:27:53 <Cale> That's a slightly unusual notation
02:27:53 <quicksilver> pjd: it tends to change from paper to paper
02:28:05 <quicksilver> pjd: papers choose the notation which makes what they're trying to say look simplest
02:28:07 <dcoutts_> tuukkah, I can't make it fail.
02:28:08 <pjd> Cale: i guessed as much too, but i'm trying to resist the urge to guess in the face of unknown notation
02:28:12 <Cale> usually it's written  fix \f. <expr>
02:28:28 <dcoutts_> tuukkah, -> #haskell-overflow
02:28:37 <quicksilver> a large proportion of mathematics is about inventing the notation which makes your problem look simple
02:29:01 <pjd> quicksilver: and then not explaining said notation? :)
02:29:19 <quicksilver> well, ideally, they'd explain it :)
02:29:20 <osfameron> nice phrase
02:29:34 <quicksilver> but sometimes they copy notation from an earlier paper they worked on and forget to copy the definitions
02:29:44 <quicksilver> or they get so used to their favourite notation it seems natural to them
02:30:53 <TuringTest> The main reason is space constraints when publishing on dead trees....
02:32:30 <TuringTest> But giving up on brevity makes reading other papers more tedious.  The balance is set by the practitioners -- and is optimized for academics, not students.
02:33:44 <dcoutts_> Stinger, any luck? found out if those reg keys exist?
02:36:24 <nornagon> getEnv "EDITOR" >>= system -- horrible horrible, someone fix for me pls :(
02:37:06 <dcoutts_> nornagon, what's wrong with that?
02:37:17 <Stinger> HKEY_CURRENT_USER\Software\Haskell\GHC\ghc-6.6 for me
02:37:29 <Stinger> has InstallDir
02:37:30 <nornagon> dcoutts_: export EDITOR="rm -rf /"
02:37:45 <dcoutts_> nornagon, then don't do it :-)
02:37:48 <quicksilver> nornagon: well don't do that, then ?
02:37:54 <quicksilver> doctor, it hurts when I do this?
02:38:09 <quicksilver> plenty of unix-land programs use EDITOR or VISUAL, they all share that problem...
02:38:11 <nornagon> quicksilver: my point is not that *i* can do it
02:38:21 <dcoutts_> Stinger, hmm, that's exactly the key the installer looks for.
02:38:30 <nornagon> it's that a malicious program might.
02:38:33 <quicksilver> nornagon: if you can't trust your environment, you're probably fucked
02:38:34 <pjd> nornagon: the same thing can be said about $SHELL
02:38:41 <nornagon> I guess :?
02:38:42 <pjd> yeah, what quicksilver said
02:38:42 <nornagon> :/
02:38:49 <quicksilver> nornagon: your environment can be set up in all kinds of ways to cause you pain
02:38:59 <dcoutts_> Stinger, can you run with logging on and send/paste the interesting part of the log?
02:39:01 <osfameron> quick!  wipe your computer and switch it off immediately!  it's the only way to be sure
02:39:09 <pjd> nornagon: if environment compromise is a risk, the correct solution is a secure wrapper, like super
02:39:10 <nornagon> heh
02:39:16 <nornagon> super?
02:39:19 <Stinger> dcoutts_ : no, I'm a noob :D
02:39:24 <Stinger> how do I do that
02:39:28 <pjd> nornagon: it's sort of like sudo, but saner :)
02:39:31 <nornagon> ah.
02:39:49 <pjd> it can act as a safe setuid wrapper
02:39:49 <dcoutts_> Stinger, gtk2hs-0.9.10.6.exe /LOG="foo.log"
02:39:53 <nornagon> cool.
02:39:55 <pjd> among other things
02:40:02 <Stinger> right, will take a look
02:40:28 <dcoutts_> Stinger, look for the bit of the log with messages starting with "DetectValidGhcInstallation: ..."
02:40:53 <quicksilver> nornagon: to be more precise, if you can't trust your environment, then before calling 'system' you need to completely clear the environment and populate it with known-safe values
02:41:08 <quicksilver> nornagon: this is somewhat painful and it's not clear to me that's what you really want
02:41:13 <nornagon> fair.
02:41:16 <quicksilver> (but you haven't told us what you want :)
02:41:32 <nornagon> I guess I'll just ignore it for now :)
02:41:43 <nornagon> i have severe paranoia around system, exec, etc
02:41:43 <osfameron> you could use config values in a dotfile in $HOME
02:41:50 <nornagon> that's true.
02:41:52 <osfameron> oops, $HOME is in the environment too :-)
02:42:14 <nornagon> :P
02:42:33 <nornagon> sounds like symlink exploit time
02:42:57 <Stinger> @paste
02:42:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:43:40 <hpaste>  (anonymous) pasted "gtk2hs log" at http://hpaste.org/478
02:43:53 <pejo> I'd call $HOME a feature, great when you log in to machines which can't mount your home directory.
02:44:37 <Stinger> anonymous was me btw :)
02:45:00 <nornagon> @hoogle tmp
02:45:00 <lambdabot> Data.Generics.Aliases.extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
02:45:06 <nornagon> @hoogle file
02:45:06 <lambdabot> System.Win32.File :: module
02:45:06 <lambdabot> System.Console.Readline.filenameCompletionFunction :: String -> IO [String]
02:45:06 <lambdabot> Distribution.Compat.FilePath :: module
02:45:10 <nornagon> @hoogle tmpfile
02:45:11 <lambdabot> No matches found
02:45:14 <nornagon> :/
02:45:16 <dcoutts_> Stinger, hmm, that's pretty odd. It finds D:\Program Files\ghc-6.6\bin\ghc.exe but when it runs it with --print-libdir it fails. Can you try that youself manually and see what happens?
02:45:29 <nornagon> @hoogle temp
02:45:29 <lambdabot> Distribution.Extension.TemplateHaskell :: Extension
02:45:30 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
02:45:30 <lambdabot> System.IO.openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
02:45:39 <nornagon> @hoogle tempfile
02:45:39 <lambdabot> System.IO.openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
02:45:39 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
02:46:00 <nornagon> what's the difference between openBinaryTempFile and openTempFile?
02:46:16 <Stinger> dcoutts : outputs my ghc dir
02:46:25 <dcoutts_> Stinger, wierdy
02:46:36 <Stinger> do you check the exit code?
02:46:45 <dcoutts_> yes
02:47:14 <nornagon> @src System.IO.openTempFile
02:47:14 <lambdabot> Source not found. My pet ferret can type better than you!
02:47:42 <Stinger> hmm is there an easy way to print the exit code of a command in the windows command line shell?
02:48:55 <osfameron> %ERRORLEVEL% ?
02:49:33 <Cheery> http://www.hal-pc.org/~rcanup/evil.html
02:49:35 <lambdabot> Title: The Types of evil personalities
02:49:36 <Stinger> hmm is 0
02:49:39 * osfameron forgets win32 shell (yay Cygwin!) but try HELP SET  if it isn't that
02:52:45 <Stinger> windows accepts / in paths for most things doesnt it?
02:53:07 <dcoutts_> Stinger, yes
02:53:08 <dcoutts_> Stinger, ah, more precisely it's running: cmd.exe /C D:\Program Files\ghc-6.6\bin\ghc.exe --numeric-version > tmpfile
02:53:58 <Stinger> aaarh hmmm
02:54:06 <Stinger> does it put quotes around the path?
02:55:00 <nornagon> openTempFile seems to want an argument for which directory to create a temp file in -- is it okay to just say /tmp and hope nobody runs it on windows? is there a better way to express such a thing?
02:56:51 <nornagon> ahar
02:56:57 <nornagon> @hoogle gettemporarydirectory
02:56:58 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
02:59:23 <Stinger> dcoutts just dumping that into cmd it balks on the space in Program Files
02:59:40 <dcoutts_> Stinger, hmm ok
02:59:59 <dcoutts_> try it with "" quotes
03:00:53 <Stinger> likes that
03:01:11 <dcoutts_> Stinger, ok thanks. I'll make the installer do that.
03:01:42 <Stinger> and meanwhile, I'll install ghc somewhere else :)
03:01:56 <dcoutts_> sorry :-)
03:02:16 <Stinger> hehe no worries man, good to get the bug fixed so easily
03:02:56 <dcoutts_> it's a bit odd this didn't get reported before, most people install in "Program Files"
03:04:18 <Stinger> I use w2k, could handle it slightly differntly
03:04:28 <dcoutts_> possibly yeah
03:06:02 <Stinger> yep installs now with ghc in D:\ghc\ghc-6.6
03:22:36 <dancor> no built-in to test for being whitespace?
03:26:00 <mauke> @index isSpace
03:26:00 <lambdabot> Data.Char
03:27:04 <dancor> ooh confusion
03:27:15 <dancor> dangerzone
03:34:14 <dancor> is there a cooler way to say   test x = test1 x || test2 x || test3 x
03:34:27 <dancor> @pl f x = isPrefixOf "yay" x || isPrefixOf "boo" x || isPrefixOf "ok" x
03:34:28 <lambdabot> f = ap ((||) . isPrefixOf "yay") (ap ((||) . isPrefixOf "boo") (isPrefixOf "ok"))
03:34:33 <dancor> that doesn't seem cool
03:34:33 <nornagon> :t or
03:34:34 <lambdabot> [Bool] -> Bool
03:34:47 <dancor> but they are [a -> Bool]
03:34:50 <nornagon> test x = or [test1 x, test2 x, test3 x]
03:35:01 <nornagon> you can further coolinate that.
03:35:15 <dancor> multimap [test1, test2, test3] x
03:35:19 <nornagon> test x = or $ foldr ($x) [test1,test2,test3]
03:35:19 <dancor> pam
03:35:22 <nornagon> oh.
03:35:27 <nornagon> not foldr, map
03:35:45 <nornagon> :t or $ map ($1) [(\a -> True)]
03:35:47 <lambdabot> Bool
03:36:05 <nornagon> :t multimap
03:36:06 <lambdabot> Not in scope: `multimap'
03:36:14 <nornagon> @hoogle multimap
03:36:14 <dancor> i wish that existed
03:36:14 <lambdabot> No matches found
03:36:16 <nornagon> oh.
03:36:18 <Saizan> :t or $ [(\a -> True)] `sequence` 1
03:36:20 <lambdabot> Bool
03:36:26 <nornagon> nifty.
03:36:55 <Saizan> ((->) r) monad
03:37:07 <dancor> we want [a -> Bool] -> ([a] -> Bool) though right?
03:37:16 <mauke> :t any
03:37:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:37:50 <mauke> > any (flip id 'x') [isSpace, isAlpha, (== ';')]
03:37:50 <Saizan> dancor, why?
03:37:51 <lambdabot>  True
03:38:20 <quicksilver> :t any
03:38:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:38:42 <dancor> sorry we want [a -> Bool] -> a -> Bool
03:38:55 <xerox> :t or . sequence (map isPrefixOf ["yay","boo","ok"])
03:38:56 <quicksilver> dancor: mauke solved it for you, though
03:38:56 <lambdabot> [Char] -> Bool
03:39:00 <dancor> yes
03:39:00 <nornagon> :t sequence any
03:39:02 <lambdabot>     Expecting a function type, but found `[m a]'
03:39:02 <lambdabot>       Expected type: [m a]
03:39:04 <nornagon> oops.
03:39:26 <dancor> :t \x -> any (flip id x)
03:39:28 <lambdabot> forall b. b -> [b -> Bool] -> Bool
03:39:31 <xerox> ?type (or .) . sequence . map isPrefixOf
03:39:33 <lambdabot> forall a. (Eq a) => [[a]] -> [a] -> Bool
03:39:54 <quicksilver> @pl \x -> any (flip id x) [test1,test2,test3]
03:39:54 <lambdabot> flip any [test1, test2, test3] . flip id
03:40:03 <quicksilver> badadom
03:41:06 <xerox> ?type (((or .) . sequence) .) . map
03:41:08 <lambdabot> forall a a1. (a1 -> a -> Bool) -> [a1] -> a -> Bool
04:43:15 <araujo> Could not find module `Distribution.Simple':
04:43:30 <araujo>   use -v to see a list of the files searched for
04:43:30 <araujo>   (imported from Setup.hs)
04:43:52 <araujo> What does it mean when 'runhaskell Setup.hs configure' ?
04:44:06 <Saizan> mmh have you package Cabal installed?
04:45:01 <araujo> yes .. but ....
04:46:16 * araujo re-installing
04:48:52 <rahikkala> Hmm
04:48:58 <rahikkala> http://mjr.iki.fi/eucd/haaste/haaste4.png (Finnish)
04:50:37 <rahikkala> Apparently Einar Karttunen wrote a DeCSS implementation and sold it to some guy named Mikko Rauhala for 0.05 euros
04:51:35 <Saizan> DeCSS?
04:52:11 <rahikkala> ... and got prosecuted for it under what I guess is Finland's DMCA-equivalent
04:52:47 <rahikkala> Saizan: A program for decrypting DVD video content
04:57:55 <Japsu> ;D
05:03:04 <matthew_-> is there anything like Perl's LWP for Haskell? I just want to fetch pages from a server
05:07:40 <wolverian> matthew_-, http://www.haskell.org/http/
05:07:41 <lambdabot> Title: Haskell HTTP package
05:08:32 <wolverian> not quite as simple as, say, LWP::Simple, but close. :)
05:10:36 <xic> what we need is something like curl, that will also work with ftp links
05:10:49 <matthew_-> wolverian: many thanks.
05:18:17 <dmhouse> Is there much of a performance penalty to passing large structures to functions, or is pass-by-reference employed?
05:23:15 <opqdonut> dmhouse: in many cases a copy will have to be made
05:23:27 <opqdonut> to maintain transparency of reference
05:23:42 <opqdonut> erm
05:24:05 <opqdonut> not actually many cases but when the structure is modified. otherwise i'd think references are used
05:24:25 <cl4proze> hi, I am trying to compile glr examples for happy and I am getting the error message that I don't have package data. Where can I get it?
05:24:31 <cl4proze> I am using ghc 6.6
05:25:49 <pejo> opqdonut, is the copy done upon read, not write?
05:26:19 <opqdonut> i'm not acquainted with the exact mechanisms here
05:26:50 <dmhouse> I don't see why a copy would have to be made.
05:27:10 <opqdonut> nevermind, i'm probably misremembering something
05:27:22 <dmhouse> The callee function can't modify its reference to the value as you can't modify variables.
05:27:52 <opqdonut> it was probably lists then, that this applied to
05:28:48 <dmhouse> Why would it differ for lists?
05:32:46 <kosmikus> ?seen ndm
05:32:47 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 15h 35m 5s ago, and .
05:34:07 <opqdonut> dmhouse: for example appending to a list will make a copy of it etc
05:34:30 <opqdonut> as opposed to for example lisp where list operations behave differently
05:34:48 <opqdonut> (but then again, they don't have transp. of ref.)
05:35:02 <dmhouse> Ah, okay.
05:35:11 <dmhouse> Well in which case it's a bit more obvious you're making a copy.
05:35:36 <dmhouse> If you do let xs = [1..5]; xs' = 0 : xs in ..., then it's clear that xs' is a copy of xs.
05:35:42 <dmhouse> And that you're duplicating space.
05:37:29 <LoganCapaldo> I'm pretty sure append copies the first list in lisp as well
05:39:03 <dmhouse> LoganCapaldo: what, even if you did (let ((l (1 2 3))) (setq l (concat (0) l)))?
05:39:20 <dmhouse> (That call to concat might not be right; I can't remember my Lisp lists.
05:39:40 <LoganCapaldo> dmhouse: No, I was just thinking of the case of (append list1 list2)
05:40:11 <LoganCapaldo> (IOW not assigning afterwards or doing a setf cdr)
05:42:04 <twanvl> (:) will NOT create a copy of the list (at least, it does not in any currently available implementation)
05:42:08 <LoganCapaldo> list1 will be copied IIRC
05:42:50 <dmhouse> twanvl: depends what you mean.
05:43:00 <dmhouse> Wait, no it doesn't. I see.
05:43:55 <dmhouse> 'let xs = [1..5]; xs' = 0 : xs in ...'. xs and xs' are both pointers to elements of a linked list with elements 0, 1, 2, 3, 4 and 5; xs points to the 1, xs' points to the 0.
05:44:13 <dmhouse> No copying. Clever.
05:44:42 <LoganCapaldo> yes welcome to cons lists <g>
05:45:31 <LoganCapaldo> Hence why ++ is O(n) where n is proportional to the length of the first list
05:45:42 <LoganCapaldo> @src (++)
05:45:42 <lambdabot> (++) []     ys = ys
05:45:43 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
05:46:49 <Heffalump> do people generally use Network.CGI and Text.Html these days?
05:48:40 <dmhouse> Heffalump: I use Text.XHtml over Text.XHtml.
05:48:50 <dmhouse> Err, the latter was meant to be Text.Html, obviously.
05:49:04 <Heffalump> ok, I was just looking at that. Might use bringert's NewCGI too
05:49:17 <dmhouse> Depends what you're doing, I guess. You want a lightweight HTTP server?
05:49:32 <Heffalump> no, I want to use Apache
05:49:41 <matthew_-> Heffalump: I think I use NewCGI
05:49:49 <matthew_-> ...with lighttpd
05:50:02 <xic> Heffalump: there's also fastcgi
05:50:13 <Heffalump> I don't really need it to be fast
05:50:21 <matthew_-> import Network.FastCGI
05:50:31 <matthew_-> ^^- is what I seem to have in my code
05:51:15 <matthew_-> but then I always use the runFastCGIorCGI function so it doesn't require fastcgi configuring on the server
05:51:16 <Cale> xs ++ ys is O(length xs) assuming that you use at least length xs elements. If you use fewer, then it won't bother to do the rest of the work of course.
05:51:53 <Cale> well O(length xs) elements anyway :)
05:52:19 * LoganCapaldo pretends he was talking about the secret strict version of Haskell
05:53:26 <Cale> :)
05:53:59 <Cale> Well, it's probably most convenient to talk about how much things will cost when you completely reduce any recursive calls they make.
05:55:06 * Heffalump wonders what happened to CosmicRay's ITP for haskell-newcgi
05:55:17 <Cale> You could also talk about the minimum cost, and say that (++) is O(1) because it returns either a cons cell or its right parameter immediately.
06:00:12 <opqdonut> dmead: that actually isn't a copy
06:00:21 <opqdonut> : doesn't need to copy while append needs
06:00:29 <opqdonut> if you think about how a linked list works
06:00:37 <opqdonut> oh, you figured that out
06:00:38 <opqdonut> np
06:25:18 <matthew_-> :t filter
06:25:19 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:25:37 <opqdonut> :t filterM
06:25:38 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:29:01 <dcoutts_> dons, hmm, I think Bulat's points need a robust defense. We should list last year's SoC projects and say a little. I think only 2 were unsuccessful, correct?
06:29:22 <dcoutts_> and the process was open and he chose not to participate
06:29:31 <dcoutts_> though it was somewhat rushed
06:30:20 <merritt> may i ask a short noob-question? i want to define a guarded conditional with one of the conditions being that a certian function applied to a certain argument terminates (no matter with which output) -- how do i formulate such a condition?
06:32:24 <dcoutts_> merritt, that's not really the kind of thing one can formulate
06:32:29 <dcoutts_> since if it doesn't terminate...
06:32:34 <dcoutts_> erm well it doesn't terminate
06:32:48 <sieni> merritt: by solving the halting problem
06:32:55 <sieni> merritt: http://en.wikipedia.org/wiki/Halting_problem
06:33:08 <dcoutts_> you can do ungly hacky impure things like running it for 10 minutes and if it's not stopped then guess that it'll never stop
06:34:18 <merritt> yes, ok, probably 'terminates' is the wrong word. the condition is supposed to say "if the functin applied to this argument yields *some* value (and doesn't yield an error)"...
06:34:52 <dcoutts_> that's still impossible in a pure language
06:35:16 <dcoutts_> since if the function yields and error then the whole thing is an error
06:35:23 <bd_> You can do hacky impure things with Control.Exception and unsafePerformIO ...
06:35:43 <dcoutts_> you can't catch exception in pure code
06:36:18 <merritt> hm. so, i can't express something like "func arg == _|_"?
06:36:37 <dcoutts_> merritt, you can write a function that always gives _|_, sure
06:36:51 <Cale> (x == _|_) = _|_ :)
06:36:55 <dcoutts_> merritt, but you can't write another function that distinguishes that function from another
06:37:21 <merritt> (the problem is that i don't know what value it will yield, so i can't match it to a particular value)
06:37:30 <dcoutts_> > (\f -> undefined) 3
06:37:35 <lambdabot>  Add a type signature
06:37:42 <dcoutts_> > (\_ -> undefined) ()
06:37:43 <bd_> Matching it to a particular value makes the function strict on its argument
06:37:43 <lambdabot>  Add a type signature
06:37:59 <dcoutts_> > (\_ -> undefined) () :: ()
06:38:03 <lambdabot>  Undefined
06:38:03 <xic> why is there no modifyTVar function?
06:38:53 <dcoutts_> merritt, what are you really trying to do?
06:39:09 <Cale> xic: There should be, but it's inessential, due to the T :)
06:39:51 <xic> Cale: yeah, but it's really useful and probably ends up being written over and over again by each person who uses STM
06:39:57 <Cale> xic: right
06:40:17 <Cale> STM needs polishing.
06:40:39 <merritt> dcoutts_: i want to define a function that does one thing if another certain function applied to a certain argument yields some value (and not an error) and i want it do some other thing otherwise
06:40:44 <Cale> The Haddock documentation is sort of sketchy too.
06:41:00 <xic> Cale: also, the docs mention that TArray is currently not optimized, do you know if there are plans to optimize it?
06:41:51 <chessguy> 'morning haskellers
06:41:52 <Cale> I don't know.
06:42:01 <Cale> Probably, given the hint :)
06:42:42 <xic> Cale: ok. what's better: (a) modifyTVar :: Tvar a -> (a -> a) -> STM ()     or (b) modifyTVar :: (a -> a) -> TVar a -> STM ()    ?
06:43:05 <merritt> dcoutts_, something like: func1 (func2,foo) (bar,arg) | func2 arg == some_value = ... | otherwise = ...
06:43:36 <bd_> xic: the latter I think would be better, as it allows things of the form modifyTVar foo $ \x -> do ...
06:43:37 <Lemmih> xic: The former.
06:43:42 <bd_> er, former
06:43:57 <Thunder> xic: The latter is better, because you can define:   modifyConfig = modifyTVar config
06:43:58 <dcoutts_> merritt, then you need to know the some_value, could it perhaps be a parameter?
06:44:02 <Cale> er, and maybe make that a -> STM b  ?
06:44:17 <Cale> er, hmm
06:44:21 <Lemmih> xic: It's not clear what an optimized TArray would look like.
06:44:22 <Thunder> s/latter/former/
06:44:37 <Cale> no, a -> STM a
06:44:53 <merritt> dcoutts_, the only thing i know about some_value is of which type it is... (the exact value will vary from case to case)
06:45:16 <dcoutts_> merritt, then it almost certainly wants to be a parameter
06:45:39 <xic> Cale: why?
06:45:47 <merritt> sorry, i don't quite understand..
06:45:53 <Cale> Well, that's the way it's done with MVars
06:45:57 <Cale> (in IO)
06:46:18 <Cale> I suppose that IORefs have modifyIORef :: IORef a -> (a -> a) -> IO ()
06:46:39 <xic> TVar is closer to IORef then to MVar i think
06:47:13 <xic> with MVar, unless modifyMVar returns the result, there is no other way to get it
06:47:23 <dmhouse> > let foo | length foo == 4 = [1..4] in foo
06:47:24 <lambdabot>  Exception: <<loop>>
06:47:30 <dmhouse> Why does that happen?
06:47:52 <bd_> dmhouse: GHC can detect infinite loops in certain cases. Don't rely on it for anything complex
06:47:53 <dcoutts_> merritt, you've got (func2,foo) (bar,arg) as parameters to your func1, can you make some_value a parameter too?
06:48:04 <dmhouse> bd_: but why does it loop?
06:48:04 <Cale> dmhouse: because length foo must be computed to know what foo is.
06:48:21 <merritt> dcoutts_: but don't i need to know the value for that?
06:48:54 <dcoutts_> merritt, you'd need to know the value when you call func1 as you'd have to pass a value for some_value.
06:48:56 <Cale> dmhouse: and the pattern match in length will force the evaluation of foo, which is already being evaluated.
06:49:02 <Cale> dmhouse: hence, a loop
06:49:04 <dmhouse> Ah, I see.
06:49:08 <dmhouse> Conceptually, it should work though.
06:49:21 <Cale> well, it's sort of silly :)
06:49:43 <dmhouse> Match 'foo' against [1..4]. If successful, check that the length of what we just matched is 4, otherwise pattern match failure.
06:49:52 <dmhouse> Not at all. I just came across it in a real application,.
06:49:55 <Cale> Conceptually, I'm not sure if I'd want it to work. We can't say that foo has length 4 unless we really knew what it was.
06:50:19 <Cale> and we don't know that it's [1,2,3,4] unless we already know somehow that it's going to have length 4
06:50:20 <dmhouse> I wanted let (this, rest) | length this > 0 = break (=='.') qualName
06:50:32 <dmhouse> Thankfully I'm in a monad so I can just use guard.
06:50:35 <Cale> why the guard?
06:50:57 <merritt> dcoutts_: there's no nice way to know the value beforehand... hm, but anyway: thanks for pointing it out to me
06:51:15 <Cale> dmhouse: Were you going to handle the other case?
06:51:25 <Cale> length is a pretty evil function
06:51:35 <dmhouse> What I wanted to express is let 'this' be everything up to the first period, and rest everything thereafter. Also ensure that length this > 0, otherwise it should be a pattern match failure.
06:51:44 <Cale> If you can avoid applying it, do so :)
06:52:01 <Cale> (this@(x:xs), rest) = ...
06:52:13 <dmhouse> Oh, so perhaps let (this@(_:_), rest) = ...?
06:52:19 <Cale> sure
06:52:31 <Cale> but pattern match failure is pretty bad :)
06:52:31 <dcoutts_> merritt, ultimately there must be some way to find that value otherwise the whole thing is impossible (or perhaps there's a different way to solve the problem)
06:52:36 <dmhouse> Cale: I'm in a monad.
06:52:48 <Cale> are you on the lhs of <- ?
06:53:09 <Cale> There's no failing for let, even in a monad.
06:53:14 <dmhouse> No, but I thought pattern match failure in lets caused fail in monads too.
06:53:18 <Cale> Nope
06:53:20 <dcoutts_> merritt, when you say some_value, do you mean any value?
06:53:20 <dmhouse> Oh, that's worth knowing.
06:53:25 <dmhouse> Any obvious reason why not?
06:53:46 <Cale> do {let <decls>; <stmts>} = let <decls> in do {<stmts>}
06:53:54 <merritt> dcoutts_, probably there's another way.. yes, i mean any value (the exact value depends on which case of the condition applies)
06:54:03 <Cale> That's all there is to that translation.
06:54:11 <dmhouse> Okay.
06:54:24 <Cale> Whereas we have something like:
06:54:36 <sjanssen> dmhouse: let bindings are still lazy when in a do construct
06:55:14 <sjanssen> and when the return value of the let isn't a monadic value it just isn't possible to use fail on pattern match failure
06:55:28 <merritt> dcoutts_, could i use a wild card and say something like "func arg == _" as a condition?
06:55:41 <dmhouse> > do x <- undefined; [5]
06:55:42 <lambdabot>  Undefined
06:55:45 <Cale> do { <pat> <- <expr>; <stmts> } = let ok <pat> = do { <stmts> }; ok _ = fail "..." in <expr> >>= ok
06:56:15 <Cale> fail is really evil, but we have to put up with it for now, I suppose.
06:56:36 <dcoutts_> merritt, but that makes no sense, that couldn't actually check anything, it'd either always be true or always false.
06:56:53 <dcoutts_> merritt, it doesn't ask any question with a yes/no answer
06:56:56 <Cale> The right translation as far as I'm concerned, is the one which Haskell 1.4 had, and uses MonadZero when <pat> is a refutable pattern.
06:57:27 <dcoutts_> merritt, expect possibly asking if it's not _|_ which as we've said is also impossible.
06:57:31 <Cale> But translates as do { <pat> <- <expr>; <stmts> } = <expr> >>= \<pat> -> do {<stmts>}
06:57:33 <Cale> otherwise.
06:57:48 <merritt> hm, then i'll have to think of another way...
06:58:05 <dcoutts_> merritt, I think you need to reevaluate what exactly is the problem you're trying to solve.
06:58:29 <merritt> dcoutts_, yeah, probably true :) thanks anyway
07:02:23 <xs> > 1/0
07:02:24 <lambdabot>  Infinity
07:02:29 <xs> > round (1/0)
07:02:30 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:03:09 <cjay> omg
07:04:01 <cjay> ah, it is finite
07:04:21 <xs> alas
07:05:00 <Cale> > log (fromIntegral (round (1/0)))
07:05:01 <lambdabot>  Infinity
07:05:10 <Cale> oh, duh.
07:05:12 <Cale> hehe
07:05:28 <Cale> > length . show $ round (1/0)
07:05:29 <lambdabot>  309
07:05:47 <bd_> > fromInteger (round (1/0 :: Double) + 1) :: Double
07:05:48 <lambdabot>  Infinity
07:05:53 <bd_> > fromInteger (round (1/0 :: Double) - 1) :: Double
07:05:54 <lambdabot>  Infinity
07:06:53 <Cale> > dropWhile (\k -> isInfinite . fromInteger (round (1/0 :: Double) - k)) [1..]
07:06:54 <lambdabot>      Expecting a function type, but found `Bool'
07:06:54 <lambdabot>       Expected type: Bool
07:06:54 <lambdabot>   ...
07:07:06 <Cale> > dropWhile (\k -> isInfinite . fromInteger . round $ (1/0 :: Double) - k)) [1..]
07:07:06 <lambdabot>  Parse error
07:07:09 <Cale> > dropWhile (\k -> isInfinite . fromInteger . round $ (1/0 :: Double) - k) [1..]
07:07:13 <lambdabot> Terminated
07:07:32 <Cale> > dropWhile (\k -> isInfinite . fromInteger . round $ (1/0 :: Double) - k) [0,100000000000..]
07:07:36 <lambdabot> Terminated
07:07:42 <Cale> It's probably quite large :)
07:07:48 <bd_> > 2 ** 1024
07:07:50 <lambdabot>  Infinity
07:07:54 <bd_> > 2 ^ 1024
07:07:55 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:08:26 <Cale> > dropWhile (\k -> isInfinite . fromInteger . round $ (1/0 :: Double) - k) [0,2^1023..]
07:08:30 <lambdabot> Terminated
07:08:52 <Cale> oh...
07:09:02 <Cale> > dropWhile (\k -> isInfinite . fromInteger $ (round (1/0 :: Double)) - k) [0,2^1023..]
07:09:03 <lambdabot>  [898846567431157953864652595394512366808988489471153286367150405788663379027...
07:09:13 <Cale> > dropWhile (\k -> isInfinite . fromInteger $ (round (1/0 :: Double)) - k) [0,2^1022..]
07:09:15 <lambdabot>  [449423283715578976932326297697256183404494244735576643183575202894331689513...
07:10:03 <chessguy> @hoogle isInfinite
07:10:04 <lambdabot> Prelude.isInfinite :: RealFloat a => a -> Bool
07:11:44 <mightybyte> @hoogle factorial
07:11:45 <lambdabot> No matches found
07:11:52 <chessguy> > fac 3
07:11:52 <lambdabot>   Not in scope: `fac'
07:11:57 <chessguy> > L.fac 3
07:11:58 <lambdabot>   Not in scope: `L.fac'
07:12:29 <mightybyte> Can lambdabot bind identifiers?
07:13:19 <mightybyte> let fac n = if n == 1 then 1 else n * fac (n-1)
07:13:19 <xs> > product [1..3]
07:13:21 <lambdabot>  6
07:13:33 <mightybyte> Ahhh, that works
07:13:35 <mightybyte> fac 5
07:13:36 <Cale> @let fac = product . enumFromTo 1
07:13:37 <lambdabot> Defined.
07:13:42 <Cale> > L.fac 5
07:13:43 <lambdabot>  120
07:13:47 <Cale> > L.fac 10
07:13:48 <merritt> dcoutts_, FYI: i defined a function dummy which yields 1 for any value, that some_value could be. then i can define my condition as "dummy (func arg) == 1", and this should work.. :)
07:13:48 <lambdabot>  3628800
07:14:04 <mightybyte> L.fac 1024
07:14:17 <Cale> > L.fac 1024
07:14:18 <lambdabot>  5418528796058857283076921944683854738001553963538013444482870270683210612073...
07:14:43 <Cale> > length . show . L.fac $ 1024
07:14:44 <lambdabot>  2640
07:15:05 <dcoutts_> merritt, ok, it works in the sense that it doesn't go wrong, however it doesn't actually do anything
07:15:07 <Cale> > reverse . show . L.fac $ 1024
07:15:08 <lambdabot>  "000000000000000000000000000000000000000000000000000000000000000000000000000...
07:15:16 <dcoutts_> "dummy (func arg) == 1" could be replaced with True
07:15:22 <mightybyte> Cale: Why can you run fac, but not me?
07:15:25 <Cale> > length . takeWhile (== 0) . reverse . show . L.fac $ 1024
07:15:25 <lambdabot>   add an instance declaration for (Num Char)
07:15:31 <Cale> > length . takeWhile (== '0') . reverse . show . L.fac $ 1024
07:15:32 <lambdabot>  253
07:15:39 <mightybyte> Does it have a different namespace for each user?
07:15:40 <Cale> mightybyte: you forgot the >
07:15:48 <dcoutts_> merritt, in fact the compiler might do precisely that.
07:16:00 <Cale> > this is interpreted as an expression
07:16:00 <lambdabot>   Not in scope: `expression'
07:16:04 <Cale> this is not
07:16:14 <mightybyte> Ahhh, I didn't even see it. :)
07:16:18 <Cale> >nor is this
07:17:58 <dcoutts_> merritt, I can't believe that the task is to write a complex version of 'True' :-) there must be some misunderstanding.
07:18:12 <merritt> dcoutts_: but if (func arg) yields an error, then dummy (func arg) should not yield 1, right? and that's what i need.
07:18:14 <tuukkah> does ghc on windows include the unix package with module System.Posix?
07:18:19 <dcoutts_> merritt, no
07:18:42 <merritt> then i don't know anymore.. ;)
07:18:54 <dcoutts_> dummy (func arg) == 1; dummy _ = 1 therefore dummy (func arg) == 1 reduces to 1 == 1 which is True.
07:19:19 <dcoutts_> merritt, Haskell is lazy. So dummmy _ = 1 does not evaluate it argument
07:19:23 <dcoutts_> merritt, try this...
07:19:31 <merritt> ah, no, dummy is differently defined :)
07:19:40 <dcoutts_> > let dummy _ = 1 in dummy (error "Arrrar!")
07:19:41 <lambdabot>  1
07:19:50 <dcoutts_> how do you define it ?
07:19:51 <merritt> yes, i see
07:20:00 <hpaste>  lutz@iks-jena.d annotated "Finding squares where rows and columns are primes" with "Reduced 1.8 * 10^33 bytes space requirement to a working programm" at http://hpaste.org/339#a1
07:21:41 <merritt> ok, some_value is of data type "Cat", which roughly is Foo or Constructor Foo (just with some more possibilities), so i can define dummy as dummy Foo = 1 and dummy (Constructor Foo) = 1
07:23:30 <merritt> (that was a stupid example, but maybe you know what i mean...)
07:23:38 <dcoutts_> merritt, ok, so dummy can now distinguish the different constructors of type Cat
07:24:27 <merritt> everything of type Cat should yield 1 and everything else (error) should not
07:25:43 <hpaste>  Saizan pasted "need help to get this to typecheck" at http://hpaste.org/479
07:25:44 <dcoutts_> merritt, but since you can only pass things of type Cat to that function then it's always 1
07:25:52 <dcoutts_> merritt, even error can be of type Cat
07:26:23 <dcoutts_> merritt, and as we said, you can't distinguish the error value of any type because that just propagates the error.
07:26:48 <dcoutts_> you can ignore errors, but if you try and look at one then that's an error :-)
07:26:59 <merritt> no, if (func arg) doesn't yield an error, then dummy (func arg) yields a pattern match failure (i just tried)
07:27:33 <merritt> sorry, meant: if (func arg) yields an error
07:27:58 <dcoutts_> merritt, sorry, I don't follow.
07:28:02 <dcoutts_> what did you try?
07:28:40 <dcoutts_> you can certainly define a partial function that only matches some of the constructors of Cat and maps the others to _|_
07:29:31 <merritt> sorry, i'm probably totall unclear... i tried "dummy (catap N N)" (catap is my func and N is something of type Cat; (catap N N) yields an error, and dummy (catap N N) yields a pattern match failure)
07:29:47 <dcoutts_> pattern match failure is an error
07:29:52 <dcoutts_> it's all _|_
07:30:17 <dcoutts_> semantically there is no difference between error "foo" and error "bar"
07:32:34 <merritt> dcoutts_: yes, but i don't care. i only want to distinguish between error and not error but some value. and dummy does this (though it's not avery elegant way) -- sorry for being so confusing
07:34:39 <dcoutts_> merritt, I think we're talking at cross purposes
07:35:01 <dcoutts_> when I say distinguish I mean that we could have a function that returns say Bool, True or False
07:35:16 <dcoutts_> you mean that it returns error or not
07:35:25 <dcoutts_> in which case there's a simpler solution
07:35:26 <dcoutts_> seq
07:36:01 <dcoutts_> or: dummy x = x `seq` 1
07:36:24 <dcoutts_> > let dummy x = seq x 1 in dummy (error "aargh!") == 1
07:36:25 <lambdabot>  Exception: aargh!
07:36:31 <dcoutts_> > let dummy x = seq x 1 in dummy 3 == 1
07:36:32 <lambdabot>  True
07:36:44 <merritt> ah, i see
07:36:46 <dcoutts_> > let dummy x = seq x 1 in dummy 3 != 1
07:36:46 <lambdabot>   Not in scope: `!='
07:36:49 <dcoutts_> > let dummy x = seq x 1 in dummy 3 /= 1
07:36:50 <dcoutts_> doh
07:36:50 <lambdabot>  False
07:37:10 <dcoutts_> merritt, this is know as being strict in that argument
07:37:18 <dcoutts_> the 'x' argument
07:37:49 <dcoutts_> what it does is if that value is an error then it propagates
07:38:03 <dcoutts_> but it does not distinguish in the sense I mean
07:38:13 <dcoutts_> there is no such function as isBottom
07:38:22 <dmhouse> Are we allowed infix class names?
07:38:23 <dcoutts_> isBottom :: a -> Bool
07:38:33 <dcoutts_> it cannot be defined
07:39:18 <merritt> yeah, but i think seq does what i need, because it propagates an error
07:39:24 <dmhouse> (You can have isBottom :: (forall a. a) -> Bool, though.)
07:39:41 <dcoutts_> merritt, right, and that is the same as doing an pattern match for your Cat type
07:40:08 <dcoutts_> the difference is that seq works for any type
07:40:14 <dmhouse> (The functions are different. dcoutts_'s tells whether, given a value of an arbitrary type, that value is the bottom value. Mine tells whether, given an arbitrary value of the type forall a. a, which contains only bottom, whether that value is bottom.)
07:40:20 <merritt> dcoutts_: aha
07:40:40 <dcoutts_> but in your case it's probably better to use the pattern matching on Cat, it's simpler.
07:40:53 <merritt> very cool. thanks a lot :)
07:41:10 <merritt> (and sorry for confusing things)
07:41:16 <dcoutts_> s'ok :-)
07:41:45 <dcoutts_> dmhouse, right, it'd be isBottom _ = True :-)
07:42:12 <dmhouse> dcoutts_: yep, and it is a special case of magic :: forall b. (forall a. a) -> b
07:42:25 <dmhouse> (Actually isBottom _ = False is valid too ;))
07:43:06 <dmhouse> 'Valid' meaning 'has that type signature'.
07:43:23 <dcoutts_> dmhouse, a special case? hmm. But magic must always return _|_
07:43:54 <dmhouse> I meant in terms of the types.
07:44:39 <dmhouse> magic always returns _|_ because in the general case _|_ is the only value from the range type you know exists. In the special case of Bool, you're free to pick True, False, or _|_.
07:44:40 <dcoutts_> ok
07:45:18 <dcoutts_> aye, but only True would be 'right' in that it satisfies the spec for isBottom
07:45:24 <dmhouse> Yes.
07:45:28 <dcoutts_> ie isBottom _|_ = True
07:45:29 <glguy> When using ghc-timing what does MUT stand for?
07:45:38 <dcoutts_> glguy, I think it's mutating
07:46:06 <glguy> I'm compiling in a VirtualPC and it's running EXTREMELY slow
07:46:18 <glguy> and I didn't know if this was part of it:  39.11 MUT (592.81 elapsed)
07:48:27 <Cale> Mutator time.
07:48:40 <matthew_-> mmm. if you link with -threaded then does forkIO and forkOS do the same thing? Cos I'm seeing cpu activity on both cores and about the same performance regardless of whether I use forkIO or forkOS
07:48:41 <glguy> should those two numbers match up at all?
07:48:58 <Cale> hmm, they're usually a lot closer than that.
07:49:29 <glguy> Loooks like there is a lot of HD access, maybe it's mutating to a temp file?
07:50:03 <Cale> I think it means time spent doing anything other than initialisation or garbage collection, basically.
07:50:39 <Cale> but yeah, perhaps you're swapping a whole lot, and it's having to wait?
07:50:50 <glguy> nope, 55 meg of free mem
07:50:57 <glguy> I didn't allocate a lot
07:51:00 <glguy> but I allocated enough
07:51:06 <glguy> only 5meg of swap was being used
07:51:09 <glguy> and much more free
08:03:29 <givi> the newbie has commen
08:04:49 <glguy> is that a disease?
08:24:46 <givi> hello, everybody! Please, help me with this: I need to read stdin while there's not EOF and for each line that has only one number produce some numeric result
08:24:46 <sjanssen> @type getContents
08:24:46 <lambdabot> IO String
08:24:46 <glguy> fmap (sum . map read . lines) interact
08:24:46 <shapr> Good morning #haskell!
08:24:46 <Saizan> ?type interact
08:24:46 <lambdabot> (String -> String) -> IO ()
08:24:46 <sjanssen> > fmap (sum . map read . lines) interact -- type error?
08:24:46 <lambdabot>  Couldn't match `String' against `IO ()'
08:24:46 <glguy> oops
08:24:46 <glguy> show
08:24:46 <glguy> oh well, I lose
08:24:46 <givi> :)
08:24:46 <Saizan> no fmpa i suppose
08:24:46 <sjanssen> @type interact (show . map read . lines)
08:24:46 <lambdabot> IO ()
08:24:46 <glguy> interact (show . sum . map read . lines)
08:24:46 <glguy> sjanssen: I got there on my own :-p
08:24:46 <givi> ?index list
08:24:46 <lambdabot> bzzt
08:24:46 <chessguy> hm, that doesn't do anything with his requirement that each line only have one line
08:24:46 <givi> what's list?
08:24:46 <givi> oops
08:24:46 <givi> what's lines?
08:24:46 <chessguy> (though to be fair, it's a vague requirement)
08:24:46 <chessguy> ?src lines
08:24:46 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:24:46 <chessguy> @type lines
08:24:46 <glguy> chessguy: he doesn't say to enforce that
08:24:46 <lambdabot> String -> [String]
08:24:46 <twanvl> > lines "something\nsomething\nsomething"
08:24:46 <lambdabot>  ["something","something","something"]
08:24:46 <glguy> chessguy: he simply says that it is true
08:24:46 <givi> oooh///
08:24:46 <chessguy> glguy, no, he says FOR each line for which it's true, do something
08:24:46 <glguy> givi: do you have to check that there is only one number on each line?
08:24:46 <givi> no
08:24:46 <chessguy> bah. then why say it?
08:24:46 <glguy> chessguy: You need to improve your homework question interpretation module ;)
08:24:46 <chessguy> lol
08:24:46 <chessguy> i always over-analyze homework questions
08:24:46 <givi> )))))
08:24:46 <givi> \me loves this channel
08:24:46 <glguy> givi: #lisp is over there
08:24:46 <chessguy> i wonder what lisp would look like if it had $
08:24:46 <vincenz> chessguy: it already does, it's ]
08:24:46 <chessguy> oh wow
08:24:46 <vincenz> ((define (foo x) (+ x 1]
08:24:46 <glguy> ?
08:24:46 <vincenz> at least for some dialects of lisp :P
08:24:46 <chessguy> mm, that's not the same
08:24:46 <emu> ($) == funcall
08:24:46 <tuukkah> $ gives you one letter shorter expressions than ]
08:24:46 <glguy> is ] designed to accomodate people programming in notepad?
08:24:46 <emu> probably. but i'm not aware of any modern lisp that has it.
08:24:46 <emu> scheme uses [] as synonym for ()
08:24:46 <nrb23> dons: it's gonna be a while before I have anything ready for sharing :->
08:24:46 <glguy> I've only seen scheme use [] in a hygenic macro, so I'd always assumed that they had something to do with macro expansion
08:24:46 * nrb23 heads to work
08:24:46 <tuukkah> right, $ helps a reader by telling there are no more argument coming later, which the ('s mathing the ] can't do
08:24:46 <givi> it works!
08:24:46 <givi> glguy: thanks!
08:24:46 <rahikkala> vincenz: I'd hate to use ]... there's a certain pleasure in finishing a function in Lisp, when you write that string of closing parentheses and watch the cursor bounce around the matching '('s :)
08:24:46 <givi> thanks everybody ;)
08:24:46 <vincenz> rahikkala: you assume everyone uses the OS as editor (emacs)
08:24:46 <vincenz> but afaik, edscheme used to do this
08:24:46 <emu> paren matching is pretty basic
08:24:46 <Botje> vim does it too..
08:24:46 <tuukkah> more like every editor has paren matching
08:24:46 <vincenz> Botje: nowadays...
08:24:46 <glguy> I prefer OpenBSD to emacs
08:24:46 <Botje> paren matching?
08:24:46 <Botje> it's always done that
08:24:46 <glguy> but I'm going to start playing with emacs again soon, so who knows
08:24:46 <vincenz> Botje: vm?
08:24:46 <vincenz> +i
08:24:46 <Botje> yes
08:24:46 <vincenz> hmm
08:24:46 <vincenz> anyways, edscheme had the ] thingy
08:24:46 <vincenz> and since it's for windows, I'm presuming it's targetting people with less fancy editors
08:24:46 <rahikkala> Does the 'ed' mean it's meant to be edited with ed?
08:24:46 <vincenz> rahikkala: google?
08:24:46 <rahikkala> http://www.gnu.org/fun/jokes/ed.msg.html
08:24:46 <lambdabot> Title: Ed, man! !man ed- GNU Project - Free Software Foundation (FSF)
08:24:46 <Botje> the "new" addition to vim7 was highlighting the paren corresponding to the one you're on
08:24:46 <glguy> I think that's "Erectile disfunction"
08:24:46 <tuukkah> givi, to make sure you understood what's going on, you might like to fix it to work with decimal numbers too :-)
08:24:46 <glguy> or if it is for a class they might not have expected you to use interact :-o
08:24:46 <tuukkah> glguy, bad class if they don't start with interact ;-)
08:24:46 <sjanssen> Botje: I don't think that is new in vim 7
08:24:46 <glguy> start or not, that doesn't mean they want it used in every assignment
08:24:46 <Botje> sjanssen: ParenMatch.vim? sure it is.
08:25:06 <Botje> but highlighting the corresponding paren when you're closing a () pair has been there for some time
08:26:21 <Botje> see the matchpairs and matchtime options
08:26:49 <tuukkah> glguy, better make other kind of excercises then, or every optimal answer includes a new implementation of interact %-)
08:29:08 <givi> ?src lines
08:29:08 <lambdabot> Source not found. You type like i drive.
08:29:09 <tuukkah> more seriously, would someone know what's wrong when hackagedb check and preview says "no fatal errors" but doesn't give a preview either?
08:29:23 <shapr> lambdabot: Don't drink and derive!
08:29:26 <givi> ?type lines
08:29:27 <lambdabot> String -> [String]
08:29:33 <vincenz> @yow
08:29:33 <lambdabot> -- I have seen the FUN --
08:29:48 <vincenz> poor lambdabot, having to stare at ml
08:30:10 <givi> ?type string
08:30:12 <lambdabot> Not in scope: `string'
08:30:23 <shapr> ooh yeah, I have seen the FUN!
08:30:46 <vincenz> fun x => x
08:31:19 <givi> how does one do [1,2,3] -> '1\n2\n3\n' ?
08:31:36 <givi> ?index join
08:31:37 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:31:57 <givi> is this the answer&
08:32:00 <givi> ?
08:33:11 <emu> givi: unlines
08:35:23 <givi> > join '\n' ['1','2','3']
08:35:23 <lambdabot>  Couldn't match `t -> t -> a' against `Char'
08:35:52 <dmhouse> givi: that doesn't do what you think it does.
08:36:04 <givi> ? what does it
08:36:15 <chessguy> > join '\n' ["1","2","3"]
08:36:15 <lambdabot>  Couldn't match `t -> t -> a' against `Char'
08:36:15 <dmhouse> > join [[1..5], [100, 101, 105], [98], [94, 32]]
08:36:17 <lambdabot>  [1,2,3,4,5,100,101,105,98,94,32]
08:36:25 <chessguy> @type join
08:36:27 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:36:27 <dmhouse> It joins a list of lists into a single list. It's the same as concat.
08:36:42 <chessguy> ?hoogle joinWith
08:36:43 <lambdabot> No matches found
08:36:44 <dmhouse> Actually, it does more than that, but to express more fully what it does you'd have to know about monad.s
08:36:56 <givi> ?type unlines
08:36:58 <lambdabot> [String] -> String
08:37:05 <dmhouse> > concat $ intersperse "\n" ["hello", "foo"]
08:37:06 <lambdabot>  "hello\nfoo"
08:37:19 <glguy> [xs | (xs,"") <- readP_to_S (many (get `manyTill` char '\n')) "this\ntest\n"]
08:37:56 <chessguy> ?src intersperse
08:37:57 <lambdabot> intersperse _   []     = []
08:37:57 <lambdabot> intersperse _   [x]    = [x]
08:37:57 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
08:38:35 <chessguy> > intersperse 3 [1..10]
08:38:36 <shapr> good morning sm!
08:38:36 <lambdabot>  [1,3,2,3,3,3,4,3,5,3,6,3,7,3,8,3,9,3,10]
08:38:46 <chessguy> cute
08:39:13 <sm> mnng sha, all
08:39:42 <sm> sms my kybad s stll akng
08:39:45 <shapr> I think so.
08:39:59 <shapr> @remember sm sms my kybad s stll akng
08:40:00 <lambdabot> Done.
08:40:05 <sm> my poor old dell laptop : )
08:40:06 <chessguy> hehe
08:40:09 <chessguy> @quote sm
08:40:09 <lambdabot> sm says: sms my kybad s stll akng
08:40:13 <chessguy> @quote sm
08:40:13 <lambdabot> sm says: sms my kybad s stll akng
08:40:23 <chessguy> @quote shapr
08:40:23 <lambdabot> shapr says: Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
08:40:43 <glguy> Text.ParserCombinators.ReadP> [xs | (xs,"") <- readP_to_S (chainl (fmap read (get `manyTill` char '\n')) (return (+)) 0) "12\n45\n"]
08:41:07 <shapr> That quote irritates some of my friends.
08:41:26 <glguy> shapr: because they abuse or are?
08:41:41 <shapr> Because they can't seem to let go of Windows.
08:41:50 <glguy> ah, so they are?
08:42:14 <shapr> But I'm persuading them bit by bit. The most recent bit was that they couldn't stop using Windows because they're addicted to World of Warcraft. So I started playing WoW on Linux.
08:42:16 <givi> ?type concat
08:42:18 <lambdabot> forall a. [[a]] -> [a]
08:42:31 <chessguy> shapr, and beating them? :)
08:42:34 <glguy> shapr: sounds like they sucked *you* in
08:43:04 <shapr> glguy: Could be, but their computer crashes and they have to reboot.
08:43:11 <vincenz> shapr: yeah, soono you'll switch to windows just to have better WoW
08:43:14 <chessguy> glguy, he can stop *any* time he wants
08:43:21 <shapr> vincenz: I have a better WoW on Linux!
08:43:34 <glguy> better WoW is still WoW
08:43:37 <shapr> true
08:43:44 <chessguy> shapr, what do you do, use WINE? or was it ported?
08:43:46 <shapr> On the good side, WoW is scripted in Lua, and that's been fun.
08:43:47 <velco> I thoughr WoW just started in Vista...
08:43:51 <shapr> Yeah, I use wine.
08:44:12 <vincenz> wow, you use WoW in wine, that must be a pain, yet I don't see oyu whining
08:44:44 <glguy> I'll tell you what the pain was... watching my old roommate spend all day gathering herbs
08:44:45 <shapr> Nah, it's not a pain, I get better FPS and resolution than most win32 laptops.
08:44:49 * shapr laughs
08:44:55 <shapr> Yeah, some of the things in WoW are very silly.
08:45:17 <givi> concat $ ["1","2"]
08:45:22 <givi> >concat $ ["1","2"]
08:45:22 <glguy> I played during the free beta period
08:45:25 * vincenz is proud he never got a WoW addiction, my mud addiction kept me too busy to get started with wow
08:45:29 <givi> > concat $ ["1","2"]
08:45:30 <lambdabot>  "12"
08:45:38 <dmhouse> > concat ["1", "2"]
08:45:39 <lambdabot>  "12"
08:45:49 <givi> > concat "3" ["1","2"]
08:45:50 <lambdabot>      The function `concat' is applied to two arguments,
08:45:50 <lambdabot>     but its type `[[a...
08:45:52 <dmhouse> givi: strings are list of characters. "1" is the same as ['1']
08:46:03 <shapr> It's interesting to notice that more and more of the Lua functions are "protected" meaning that only Blizzard-signed extensions can call them. 'Goldfarmers' were writing bots to earn items and money and sell them for real cash.
08:46:23 <vincenz> shapr: now that'd be fun :) writing scripts to do the stuff for you :P
08:46:29 <vincenz> it's metaplaying
08:46:43 <givi> what is $?
08:46:45 * vincenz thinks they should invent a game where part of the goal is the metagame
08:46:52 <edwinb> why play a game when you can write a program to play it for you? saves all the effort.
08:47:01 <edwinb> or have I missed the point of gaming again?
08:47:06 <mux> vincenz: I think there are several already where the scripting part is very important
08:47:08 <shapr> Lots of end users have picked up Lua scripting so they could improve their playing, it's an interesting way to bring programming to the masses.
08:47:19 * mux fully agrees with edwinb :)
08:47:39 <glguy> edwinb: you don't understand the concept of an e-penis?
08:47:41 <vincenz> mux: such as?
08:47:45 <mux> edwinb: now, it'll be harder to program something to play a game on the Wii
08:47:51 <glguy> when you can kill someone else, you get to think you have a bigger e-penis
08:47:55 <edwinb> although you could then write a program which writes the program to play the game for you
08:47:58 <edwinb> hooray for metaprogramming
08:48:11 <mux> vincenz: I don't remember the exact name, but I think heroes of might and magic or something falls into that category
08:48:20 <chessguy> i've never really understood the point of all the RPGs out there
08:48:22 <chessguy> i think i'm glad
08:48:44 <mux> I've heard of guys writing scripts to do all the harvesting and such
08:48:56 <chessguy> i've thought before that it would be cool to write a game that required programming tasks
08:49:09 <emu> like a MOO?
08:49:14 <glguy> wow is hardly an rpg :-p
08:49:29 <shapr> I'd like to play a game where the programming is the point. You program your units and part of the game is stealing bits of code from killed enemy units.
08:49:31 <pjd> chessguy: there are the various bot-battle type games
08:49:40 <vincenz> emu: moos are cool, sadly they're ither a) unpopulated or b)seriously lagging
08:49:41 <Slarba> hm
08:49:45 <vincenz> emu: and besides, coldc is way better than mo
08:49:48 <glguy> moo?
08:49:49 <pjd> shapr: corewars 2.0!
08:49:50 <chessguy> pjd, sure, but i'm talking more like puzzle-solving games
08:49:55 <vincenz> shapr: corewars... but it's rather ...meh
08:50:02 <shapr> MIT's StarLogo is all about writing small simple bits of code that solve problems elegantly.
08:50:04 <vincenz> shapr: I was hoping more for an rpg or such with coding integrated
08:50:07 <emu> MUD-Object-Oriented
08:50:12 <pjd> chessguy: that would be awesome
08:50:33 <pjd> it could be a programming course in disguise
08:50:34 <Stinger> second life is something like that isnt it?
08:50:43 <Stinger> it just doesnt have a point :P
08:50:46 <Slarba> haskell-reedcode! :D
08:50:53 <Slarba> redcode even
08:50:57 <vincenz> emu: coldc is much more object-oriented and better in framework
08:50:57 <chessguy> pjd, exactly
08:51:05 <vincenz> Stinger: exactly :/
08:51:23 <shapr> I played with Second Life scripting for a bit, it's interesting.
08:51:24 <chessguy> pjd, like pythonchallenge.com, but with an emphasis on programming instead of esoteric riddles
08:51:25 <vincenz> Stinger: the lackinig a point is rather *big*
08:51:31 <vincenz> shapr: what kind of language?
08:51:39 <shapr> They're using a homebuilt crappy subset of C
08:52:02 <Stinger> quakec was pretty fun
08:52:02 <shapr> You upload scripts to the server where they're compiled and attached.
08:52:22 <Stinger> making crazy different weapons
08:52:37 <shapr> With Second Life you can easily 'export' events via http, so you could write all your scripts with Haskell if you wanted to.
08:52:56 <vincenz> Stinger: I remember implementing quake-soccer :)
08:52:57 <shapr> WoW tries hard to deny total scriptability.
08:53:24 <vincenz> Stinger: everything became a rocket launcher with huge-blast radius and strength but no damage and water would insta kill... with low grav...
08:53:37 <Stinger> heh
08:53:38 <vincenz> Stinger: you'd try to shoot each other into the water while jumping from platf to platf :)
08:53:51 <Stinger> I just made cluster grenades, proximity mines
08:53:52 <vincenz> sadly my two alltime favourite quakec scripts were never compatible :/
08:54:08 <vincenz> the grapplehook (the nice one with swining et al) and the reaperbot
08:54:11 <shapr> Second Life runs into problems with server side scripts eating resources.
08:54:12 <vincenz> swinging
08:54:40 <shapr> WoW does everything on the client side, and that leads to goldfarming/scripting done anyway by use of runtime debuggers, etc.
08:54:56 <pjd> chessguy: you could have bosses like the Y combinator
08:55:04 <chessguy> pjd,  :)
08:55:25 <shapr> Does anyone know of other popular scriptable games?
08:55:29 <vincenz> shapr: it's basically a measure of, who's got the fanciest tools
08:55:47 <shapr> It's fascinating from both social and CS perspectives.
08:57:19 <pjd> #haskellwars ?
08:57:49 <givi> > unlines intersperse "\n" ["1","2"]
08:57:50 <lambdabot>      The function `unlines' is applied to three arguments,
08:57:50 <lambdabot>     but its type `...
08:58:00 <givi> > unlines (intersperse "\n" ["1","2"])
08:58:01 <lambdabot>  "1\n\n\n2\n"
08:58:23 <givi> > unlines (intersperse "" ["1","2"])
08:58:25 <lambdabot>  "1\n\n2\n"
08:58:37 <givi> > unlines (intersperse $ ["1","2"])
08:58:38 <lambdabot>  Couldn't match `[String]' against `[[[Char]]] -> [[[Char]]]'
08:59:05 <givi> > unlines ["1","2"]
08:59:06 <lambdabot>  "1\n2\n"
08:59:13 <shapr> pjd: Yeah, you'd have to setup an environment where the way to access your units was also a way to take over control of the enemies' units.
08:59:17 <chessguy> i was thinking you could make it so that your character only executes a script. that's entirely how you control the guy
08:59:22 <givi> ?src unlines
08:59:23 <lambdabot> unlines = concatMap (++ "\n")
08:59:32 <chessguy> provide a small but flexible API
08:59:53 <chessguy> a little simple syntax
08:59:59 <chessguy> could lead to a lot of fun
09:01:26 <pjd> chessguy: sort of like driving a golem
09:02:20 <shapr> We could start out with Hudak's Dance DSL.
09:02:38 <shapr> It has an OpenGL viewer for choreography that animates a torso and limbs.
09:02:41 <shapr> :-)
09:04:08 <pjd> hah, great
09:05:45 * cjeris looks around for #haskellhaskellrevolution
09:06:08 <chessguy> pjd, hmm. i don't know what that is
09:06:21 <ibid> has it already been mentioned here that haskell has been mentioned in an indictment? :)
09:06:34 <pjd> chessguy: what, a golem?
09:06:38 <cjeris> ibid: ?
09:06:40 <chessguy> ya
09:06:55 <pjd> chessguy: check Wikipedia
09:07:18 <chessguy> i thought golem was that thing on Lord of the Rings
09:07:40 <ibid> cjeris: a couple of guys got charged for copyright (actually, eucd) violation by writing a haskell program :)
09:07:55 <pjd> short version: an artificially-animated construction that's activated by a scroll of words inscribed or attached to its head
09:07:55 <Saizan> that's gollum
09:08:16 <shapr> ibid: What??
09:08:20 <chessguy> hmm
09:08:23 <SyntaxNinja> y0
09:08:40 <shapr> y0 y0
09:09:04 <pjd> chessguy: Terry Pratchett's Discworld has a particularly interesting conception of them
09:09:16 <chessguy> hm
09:09:17 <ibid> shapr: it's the stupid "you must not circumvent copy protection" rule. i think it's a good idea that they're testing it in court
09:09:58 <pjd> in there, the words are the golems' "programming"
09:10:16 <ibid> shapr: aiui, the guys did that specifically to get indicted :)
09:10:56 <pjd> so, you could imagine writing your golem's scroll, REPL-like, as you go along :)
09:10:59 <shapr> Where can I read more?
09:11:07 <ibid> shapr: can you read finnish?
09:11:13 <shapr> ei ole
09:11:22 <rahikkala> http://mjr.iki.fi/eucd
09:11:24 <lambdabot> Title: Organisoitu keskustelu -kampanja
09:11:54 <shapr> Hey, I know this name..
09:12:19 <rahikkala> Basically, Einar Karttunen wrote an implementation of DeCSS in Haskell (he even got paid 0.05 euros for it)
09:12:55 <Lemmih> 0.05 euros?
09:13:05 <shapr> I know Einar Karttunen...
09:13:28 <ibid> Lemmih: makes it professional :)
09:13:34 <ibid> Lemmih: ie for money
09:13:48 <shapr> Oh my.
09:17:59 <chessguy> so they picked a fight, just to make a point?
09:18:05 <ibid> it should be noted that they turned themselves in, and aiui had to push the authorities for the indictment :)
09:18:09 <ibid> chessguy: yes
09:18:36 <chessguy> yeesh
09:18:56 <givi> process i
09:18:56 <givi>    | i < 12    = i
09:18:56 <givi>    | otherwise = max i (process(i/4)+process(i/3)+process(i/2))
09:19:12 <givi> it won't work!
09:19:30 <ibid> please define "it won't work"
09:19:42 <givi> :)
09:19:48 <ibid> what are you expecting, what does it do?
09:19:57 <ibid> :)
09:21:00 <vincenz> givi: I presume that's on floats?
09:21:02 <givi> ghc says: "Probable fix: add an instance declaration for (Fractional Integer)"
09:21:15 <bd_> givi: For integers, use `div`
09:21:23 <givi> yes! :)
09:21:25 <bd_>  / is for precise divition, `div` rounds
09:23:16 <vincenz> > let foo x = if x < 12 then x else max x (foo (x `div` 4) + foo (x `div` 3) + foo (x `div` 2)) in map foo [1..100]
09:23:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,13,13,14,15,17,17,19,19,21,22,23,23,27,27,27,28,30,...
09:23:32 <vincenz> eh
09:23:34 <chessguy> lol
09:24:19 <vincenz> > let foo x = if x < 4 then x else max x (foo (x `div` 4) + foo (x `div` 3) + foo (x `div` 2)) in map foo [1..100]
09:24:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,13,13,14,15,17,17,19,19,21,22,23,23,27,27,27,28,30,...
09:24:49 <vincenz> > let foo x = if x < 4 then x else max x (foo (x `div` 4) + foo (x `div` 3) + foo (x `div` 2)) in map drop 50 $ foo [1..100]
09:24:50 <lambdabot>      Expecting a function type, but found `[b]'
09:24:50 <lambdabot>       Expected type: a -> b
09:24:50 <lambdabot>  ...
09:24:52 <vincenz> ack
09:24:59 <vincenz> > let foo x = if x < 4 then x else max x (foo (x `div` 4) + foo (x `div` 3) + foo (x `div` 2)) in drop 5 $ map foo [1..100]
09:25:00 <lambdabot>  [6,7,8,9,10,11,13,13,14,15,17,17,19,19,21,22,23,23,27,27,27,28,30,30,32,32,3...
09:25:02 <vincenz> > let foo x = if x < 4 then x else max x (foo (x `div` 4) + foo (x `div` 3) + foo (x `div` 2)) in drop 50 $ map foo [1..100]
09:25:03 <lambdabot>  [57,57,57,60,60,63,63,63,63,68,68,68,69,74,74,76,76,76,76,76,76,87,87,87,87,...
09:25:09 <opqdonut> ah quit messing around
09:25:14 <vincenz> sorr
09:25:15 <vincenz> y
09:25:17 <opqdonut> np
09:25:18 <chessguy> opq!
09:25:26 <opqdonut> the first two or so were fine but :)
09:25:28 <opqdonut> chessguy: hi
09:25:30 <vincenz> opqdonut: just curious why he was making this func
09:25:36 <vincenz> opqdonut: I agree :)
09:25:45 * vincenz should learn to write typolessly
09:26:03 <opqdonut> chessguy: how's the genetic stuff coming along?
09:26:09 <chessguy> opqdonut, got a minute? i've been looking for a haskeller to kick around some ideas with me for a genetic programming framework in haskell
09:26:33 <opqdonut> well, i should be consetrating on chemistry but yeah i can spare a while
09:26:39 <opqdonut> tho i'm no hc haskeller :)
09:26:56 <vincenz> chessguy: out of curiousity, what datatype do you use?
09:26:58 <chessguy> !paste
09:26:59 <hpaste> Haskell paste bin: http://hpaste.org/
09:27:07 <chessguy> vincenz, for what?
09:27:26 <vincenz> chessguy: representing your gene-set
09:27:35 <opqdonut> ah, depends on the problem
09:27:45 <chessguy> vincenz, i don't have any code yet, still trying to decide what the framework should look like
09:27:53 * vincenz nods
09:27:59 <opqdonut> lists as a chromosome worked better than arrays
09:27:59 <chessguy> http://hpaste.org/476
09:28:03 <opqdonut> that's all i can really say
09:28:11 <monochrom> Does Bulat ever read those messages he responds to?  I said, "how to host a huge program linking in GHC on a cheapo server..."  He said, "for cheapo solution try hugs..."  OK, I made up a hypothetical scenerio, but does it ever cross his mind that hugs doesn't provide the GHC API?!
09:28:25 <vincenz> I guess some collection (list..) of chromosomes, not sure if I'd go with lists for chromoses however, I think splicing would get expensive
09:28:49 <vincenz> I'd go as far as suggest tuples if your chromosomes are fixed-length
09:28:58 <vincenz> (or whatever other data-cons)
09:29:06 <chessguy> vincenz, there's a difference between genetic algorithms and genetic programming
09:29:16 <opqdonut> yeah but n-tuples are really sucky in haskell
09:29:22 <vincenz> chessguy: care to elucidate?
09:29:47 <chessguy> genetic algorithms evolve a solution. genetic programming evolves an algorithm for deriving a solution
09:29:55 <vincenz> chessguy: yes, which at an abstract level is the same
09:30:07 <sjanssen> monochrom: that's our Bulat!
09:30:10 <vincenz> you're still doing splicing, except now on the algo considered as data
09:30:12 <chessguy> to some degree, but there are a lot of practical differences
09:30:22 <opqdonut> chessguy: could you elaborate on those definitions a bit
09:30:27 <vincenz> so I take it you have some minimamlistic language?
09:30:28 <chessguy> e.g., the fundamental data structure of GP is a tree, not a fixed-length string
09:30:53 <vincenz> chessguy: right, I said "presuming your chromosomes are fixed length'
09:31:04 <chessguy> which wouldn't make sense for GP
09:31:07 <vincenz> chessguy: anyways, if you're going for that type of chromoses, the representation is rather obvious, some sort of AST
09:31:12 <vincenz> chessguy: that is not true
09:32:05 <chessguy> at least, i've never seen an implementation for which it's true
09:32:08 <monochrom> programs are data too
09:32:23 <opqdonut> haskell with reflection sounds really nice for this :)
09:32:29 <vincenz> chessguy: if you're going for op-code based instead of AST based it is very possible that you have a fixed-size instruction memory
09:32:40 <chessguy> anyway, any thoughts on the paste?
09:32:48 * vincenz rememmbers seeing a demonstration on that at the EU
09:33:29 <chessguy> hm, i've never heard of a non-tree-based implementation of GP
09:33:33 <vincenz> they used real robots to show the final solutions and the code that was generated for them even learned to slow down near small passageways
09:33:55 <vincenz> this is quite a few years ago, however.
09:34:01 <opqdonut> chessguy: hmm could you explain newtype Program = Program Tree ([Program] -> DataType) please?
09:34:09 <chessguy> ok, i'll try
09:34:47 <chessguy> so any individual in the population is a function from its children to whatever domain-specific data type the problem deals with
09:35:42 <chessguy> and of course, each of its children is itself a program
09:36:13 <glguy> is there a proper way to use readHex as a read?
09:36:34 <rahikkala> @type readHex
09:36:35 <lambdabot> forall a. (Num a) => ReadS a
09:36:36 <opqdonut> chessguy: ahh now i understand
09:37:00 <opqdonut> i thought the ([P] -> DT) was a parameter to Tree
09:37:01 <opqdonut> :)
09:37:19 <opqdonut> but yeah, uh gotta do these excercises now, see you in a while
09:37:45 <rahikkala> @type fst . head . readHex
09:37:47 <rahikkala> ;)
09:37:47 <lambdabot> forall a. (Num a) => String -> a
09:38:23 <glguy> ?src read
09:38:24 <lambdabot> read s = either error id (readEither s)
09:38:29 <glguy> but I've never seen readEither
09:38:49 <chessguy> ok
09:39:05 <monochrom> meNeither
09:39:07 <monochrom>  :)
09:42:25 <chessguy> ?hoogle neither
09:42:25 <lambdabot> No matches found
09:43:39 <xic> is simon marlow's readfile.hs good?
09:47:03 <xic> it doesn't seem to close the file
10:16:24 <glguy> does the actor model allow for shared mutable data?
10:19:11 <pjd> not as such
10:19:34 <Saizan> i thought it was only message passing
10:19:47 <pjd> yeah
10:20:08 <pjd> you'd model shared state as another actor
10:21:32 <Saizan> mmh so it's also mutable
10:34:04 <glguy> That criticism of STM said that it took him hours to implement the actor model using STM, and I just didn't understand how those two were related
10:34:25 <glguy> I thought that an actor model in Haskell would just be forks and would use Chan for message passing
10:34:37 <Botje> that's because the actor model is based on message queues.
10:34:52 <Botje> so if he'd implemented those first ..
10:34:57 <shapr> Where's this criticism?
10:35:06 <Botje> giggle for patrick logan
10:35:14 <glguy> tee hee
10:35:33 <sjanssen> glguy: link?
10:36:20 <glguy> http://patricklogan.blogspot.com/
10:36:22 <lambdabot> Title: Making it stick.
10:36:43 <glguy> this website suffers from a lack of margins
10:37:36 <glguy> his title speaks volumes  Misguided: The Road Not To Be Travelled
10:39:17 <sjanssen> glguy: I think you're misinterpreting
10:39:23 <glguy> I probably am
10:39:44 <sjanssen> he's talking about the difficulty of implementing STM vs implementing the actor model
10:40:07 <sjanssen> which is just a stupid argument
10:40:39 <vincenz> he doesn't really seem like a very informed person
10:40:43 <glguy> right, one is much more primitive and simple than the other, they both accomplish different tasks
10:41:14 <sjanssen> how much work is it to write a garbage collector?
10:41:25 <glguy> 7
10:41:28 <vincenz> no
10:41:31 <vincenz> 7.43
10:41:32 <sjanssen> how much work is it to just offer C style malloc and free?
10:41:36 <glguy> 3
10:41:53 <glguy> 3 < 7
10:42:03 <sjanssen> obviously C style is easier (between 4 and 4.3 easier to be exact), so it /must/ be better
10:42:14 <vincenz> glguy: 3 !< 7 and 7 !< 3 but  _|_  < 3 and _|_ < 7
10:42:16 <sjanssen> s/4.3/4.43
10:42:28 <cjay> what units of work are you using? :)
10:42:38 <vincenz> cjay: microOlegs
10:42:55 <glguy> I'm using a logrithmic scale
10:43:06 <vincenz> logoleg
10:43:10 <vincenz> or legolog?
10:43:15 <cjeris> vincenz: what's the conversion factor between uO and cr (crack rocks) ?
10:43:38 <vincenz> oy
10:43:40 <vincenz> no idea
10:43:49 <vincenz> I did math with the clustering methodology at school
10:44:42 * glguy wishes that there was a more severe button you could click than the down-arrow in reddit that went on that person's profile
10:44:54 <benja_> @tell dcoutts_ we haven't gotten the style thing to work yet, but if you're interested in what we're doing with gtk2hs, have a look at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fenfire-0.1 :-)
10:44:54 <glguy> shaming them for having posted uninformed blog posts
10:44:54 <lambdabot> Consider it noted.
10:45:04 <cjeris> glguy: labeled "You, sir, are an ass" ?
10:45:13 * shapr grins
10:45:44 <sjanssen> it'd be fun there were a slashdot-like article tagging feature
10:46:05 <vincenz> -50, ubertroll or -100, gavino meets kt?
10:46:51 <paolino> delicious ?
10:47:07 <sjanssen> the tags are often hilarious
10:47:13 <sjanssen> I'm trying to find an example
10:48:10 <sjanssen> http://games.slashdot.org/article.pl?sid=07/02/12/2212248&from=rss -- for example, one of the tags is "defectivebydesign"
10:48:14 <lambdabot> Title: Slashdot | Vista Not Playing Nice With FPS Games, http://tinyurl.com/252foo
10:50:32 <rahikkala> Hilarious because it's true, or hilarious because it's not true?
10:50:37 <paolino> :t (<).when
10:50:38 <lambdabot> forall (m :: * -> *). (Ord (m () -> m ()), Monad m) => Bool -> (m () -> m ()) -> Bool
10:59:45 <reilly> Anybody familiar with HsJudy?
11:01:25 <dcoutts> benja_, interesting!
11:01:38 <benja_> dcoutts: =)
11:02:24 <chessguy> paolino!
11:03:27 <dcoutts> benja_, so where did we get to? discover anything more useful/interesting?
11:04:11 <benja_> well, we dropped working on the style stuff after you left because we needed to work on the release =)
11:04:22 <benja_> so nothing new on that front
11:07:01 <dcoutts> benja_, ok, I'll have another look now
11:07:44 <benja_> oh, thanks!
11:26:03 <xic> why aren't there mutexes in haskell?
11:27:41 <dcoutts> xic, see MVar
11:28:20 * shapr boings cheerfully
11:28:31 <gly> shapr: boing ;)
11:28:32 <ohmega> shapr!
11:28:55 <xic> hm....
11:28:56 <pjd> referential transparency: my anti-mutex
11:29:39 <shapr> hiya ohmega!
11:29:43 * shapr boings at gly
11:29:50 <shapr> Wow, more unicyclists on #haskell
11:30:06 <arcatan> I would love to try unicycling
11:30:19 <gly> shapr: How can i do [ f x | f <- [f1,f2,f3] without list comprehensions?
11:31:14 <velco> [f f1, f f2, f f3]
11:31:28 <velco> err, swapped
11:31:43 <velco> [f1 x, f2 x, f3 x]
11:32:09 <pjd> map ($ x) ?
11:32:27 <gly> I do in this case, but I'd like to know for the case were I don't know all the fs before..
11:32:43 <benja_> gly: what pjd said
11:33:37 <xerox> > [(+2),(*3),(^2)] `ap` return 10
11:33:39 <lambdabot>  [12,30,100]
11:33:54 <chessguy> @type (ap)
11:33:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:34:21 <chessguy> ?src ap
11:34:21 <lambdabot> ap = liftM2 id
11:36:15 <xerox> > [(+2),(*3),(^2)] `sequence` 10
11:36:16 <lambdabot>  [12,30,100]
11:37:59 <gly> ap [f1..fx] . return is what I have now
11:38:47 <Jaak> > map ($ 10) [(+2),(*3),(^2)] -- is imho clearest
11:38:48 <lambdabot>  [12,30,100]
11:39:13 <Jaak> oh, pl
11:39:44 <xerox> (pl doesn't know about that, it gives you (. return) . ap)
11:42:22 <gly> thanks
11:44:38 <glguy> gly: what's this "gly" business?
11:45:09 <gly> i dunno ;)
11:45:20 <malsyned> is there a utility, even a shoddy, half-working utility, for converting a latex lhs file into a regular haskell source file?  I find trying to read through the latex source distracting.
11:45:46 <allbery_b> unlit in the ghc library directory
11:45:54 <malsyned> allbery_b: thanks
11:46:37 <malsyned> How do I call it?  does it dump the source to stdout or to a file?
11:47:07 <allbery_b> I think it's a filter
11:47:30 <malsyned> well, unlit file.lhs file.hs works.
11:47:44 <allbery_b> hm, not a filter, yeh
11:47:54 <allbery_b> and it has a usage message, which is a good thing :)
11:48:06 <malsyned> right.  that's how I figured it out ;-)
11:48:31 <malsyned> And now, a related non-haskell question: is there a good unix command for collapsing multiple newlines into one?
11:49:13 <benomatic> malsyned: uniq?
11:49:36 <benomatic> not sure if u can force it to select only blank lines
11:49:59 <xerox> Pipe it through grep -ev '^$'.
11:50:00 <malsyned> doesn't matter, I don't expect there are a lot of adjacent identical lines in haskell source.  uniq will do.
11:50:51 <malsyned> xerox: oddly, that kills all lines.  taking out the -e fixes it.
11:51:03 <xerox> (-:
11:51:07 <benomatic> cuz -ev == -e 'v'
11:51:16 <benomatic> -ve '^$' might work tho
11:51:33 <benomatic> but then you lose all blank lines, not just redundancies
11:51:38 <malsyned> right.  that's the problem with that.
11:52:01 <malsyned> it's ok tho, uniq is good enough.
11:52:20 <benomatic> u could use diff to verify that only blanks got killed, if you're automating it
11:52:40 <malsyned> not automating it, though. Just trying to read the darcs source without tripping over the latex
11:52:51 <allbery_b> more -s is your friend
11:53:02 <allbery_b> (also works with less)
11:53:10 <vincenz> less is more
11:53:12 <benomatic> new thing for the day learned
11:53:15 <malsyned> bingo.  excellent.
11:53:18 <malsyned> thanks!
11:55:49 <njd> @users
11:55:49 <lambdabot> Maximum users seen in #haskell: 322, currently: 310 (96.3%), active: 48 (15.5%)
11:56:03 <paolino> :t ap when
11:56:05 <lambdabot> forall (m :: * -> *). (Monad m) => (Bool -> m ()) -> Bool -> m ()
11:57:12 <paolino> :t ap $ (<).when
11:57:12 <kniv7s> hi
11:57:13 <lambdabot> forall (m :: * -> *). (Ord (m () -> m ()), Monad m) => (Bool -> m () -> m ()) -> Bool -> Bool
11:57:22 <kniv7s> wht if I do (winHugs)=> a :: Int
11:57:26 <kniv7s> it says to me: ERROR - Undefined variable "a"
11:57:31 <kniv7s> ?
11:58:27 <paolino> :t ap $ when.(<)
11:58:28 <allbery_b> you can't do toplevel declrations at the hugs prompt
11:58:28 <lambdabot>     Expecting a function type, but found `b'
11:58:28 <lambdabot>       Expected type: a -> Bool
11:58:49 <allbery_b> (or at ghci, for that matter, although ghci lets you do:  let a :: Int; a = ...
11:59:05 <allbery_b> (those will be forgotten when you :reload or etc., though)
11:59:09 <kniv7s> <allbery_b> you can't do toplevel declrations at the hugs prompt <-- why not? it's nonsense
11:59:37 <kniv7s> have I to close it into a file ?
11:59:54 <kniv7s> and then use :load ?
11:59:57 <allbery_b> long story, you're not the only one who doesn't like it, but it's easier to implement.  there's discussion in the logs (see the /topic)
12:00:06 <allbery_b> and yes, that's what you have to d
12:00:11 <allbery_b> do
12:00:12 <glguy> kniv7s: GHCi lets you type ":", Hugs lets you click the refresh button
12:00:44 <kniv7s> mmmh ok thx
12:01:11 <kniv7s> what about opensource haskell IDEs ?
12:01:23 <malsyned> There's an eclipse plugin for haskell, right?
12:01:47 <allbery_b> http://eclipsefp.sourceforge.net
12:01:48 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
12:01:51 <glguy> visual haskell is, itself, open sores
12:01:57 <kniv7s> thanks
12:02:12 <dmead> boink
12:02:12 <glguy> but it requires VS.NET 2003 or VS 2005
12:02:26 <kniv7s> can you advise me about a study path ?
12:02:43 <dmead> yes
12:02:45 <dmead> learn emacs
12:02:54 <xic> no, learn vim!
12:03:00 <malsyned> ed!
12:03:00 <dmead> no, learn emacs!
12:03:16 <glguy> :-/
12:03:32 <malsyned> Isn't there a document outlining good tutorial intros to Haskell somewhere on haskell.org?
12:03:49 <dmead> aye
12:04:00 <dmead> read "yet another haskell tutorial"
12:04:13 <malsyned> kniv7s: the "gentle introduction" is a pretty good starting place: http://www.haskell.org/tutorial/
12:04:14 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
12:04:18 <dmead> err
12:04:19 <dmead> yea
12:04:20 <dmead> thats it
12:04:26 <benomatic> any vim'ers have a superior-to-default vim [l]haskell syntax/indent/* setup worth sharing?
12:04:26 <kniv7s> thx
12:04:30 <kniv7s> what means  Missing binding for variable "a" in type signature?
12:04:46 <chessguy> ?seen paolino
12:04:47 <lambdabot> paolino is in #haskell. I last heard paolino speak 6m 19s ago.
12:04:53 <kniv7s> ok i've seen
12:04:57 <dmead> it means the interpreter can't make an inference about the type of that variable
12:05:08 <dmead> make a usefult type signature
12:05:14 <dmead> instead of a -> b
12:05:17 <dmead> do int -> int
12:05:21 <dmead> or something like that
12:05:43 <chessguy> paolino, ping
12:06:48 <allbery_b> hrm?  "missing binding" when I've seen it means a type signature needs a definition to apply to
12:06:58 <paolino> pong
12:06:59 <allbery_b> a :: Int is useless without a = ...
12:07:24 <chessguy> hey. i've pretty much gone back to the drawing board for this GP stuff
12:07:27 <kniv7s> yes i've seen
12:07:32 <chessguy> it was really getting messy, and i didn't like it
12:08:10 <chessguy> i've sketched out some ideas for what a framework might look like. see what you think: http://hpaste.org/476
12:10:26 <ctkrohn> So do the Haskell OpenGL libraries only support OpenGL 1.5?  No support for 2.0?
12:10:47 <xic> i'd also like to see opengl 2.0 support
12:10:58 <xic> if only for VBO
12:11:12 <ctkrohn> I'm interested in playing around a little bit with GPGPU stuff
12:11:15 <ctkrohn> just for kicks
12:11:40 <chessguy> what's GPGPU?
12:11:45 <siti> when are we going to have a functional shading language?
12:12:18 <ctkrohn> chessguy: general purpose GPU programming
12:12:19 <xic> siti: didn't some guy from microsoft do that already?
12:12:26 <ctkrohn> chessguy: using the GPU to do non-graphics computations
12:12:33 <ctkrohn> xic: yeah, he wrote this system called Vertigo
12:12:39 <ctkrohn> on top of DirectX 8
12:12:40 <xic> yeah, that's the one
12:12:41 <chessguy> ctkrohn, hmm. for what purpose?
12:12:47 <siti> I guess ghc outputs c code, and some of those shading languages are near to c
12:13:00 <siti> xic: I haven't heard about it...
12:13:10 <chessguy> oh to make use of the fast hardware?
12:13:23 <ctkrohn> chessguy: yeah,g raphics cards are very fast for certain applications
12:13:30 <chessguy> interesting
12:13:50 <ctkrohn> chessguy: basically, they have hardware support for maps over lists of vectors
12:14:17 <siti> it would be sweet if ghc could use streaming platforms like graphics cards, cell processor etc :)
12:14:18 <chessguy> oh, that could be useful for FP
12:14:33 <ctkrohn> yeah, I've wanted to play with the Cell CPU as well :)
12:14:37 <siti> @users
12:14:37 <lambdabot> Maximum users seen in #haskell: 322, currently: 309 (96.0%), active: 51 (16.5%)
12:14:42 <siti> close!
12:14:48 <ctkrohn> the cell shouldn't be hard to target since there's already a C compiler for it, and GHC just outputs C code, right?
12:14:55 <paolino> chessguy, I must reach a fix point for my clusterer tonight. If you want to spend a little time commenting those types (especially genes) and the limits of the framework I will think about the all story for a couple of days
12:14:56 <ctkrohn> rather, GHC can be told to output C code
12:15:24 <chessguy> paolino, ok
12:15:33 <siti> ctkrohn: yes, but it doing the spes or ppes dynimcally would be cool
12:15:49 <siti> is the asm different though
12:16:07 <ctkrohn> the PPE just uses regular PPC asm, the SPEs have their own instruction set if I recall
12:16:12 <siti> ok
12:16:17 <malsyned> is there a good reference for all of the extensions to the language (both in language features and in libraries) that GHC supports?
12:16:30 <allbery_b> chapter 7 of the ghc user's manual?
12:16:31 <siti> that would make it more tricky to hide the details then
12:16:42 <allbery_b> well, doesn't list libraries
12:16:49 <ctkrohn> siti: its too bad that the GPU is disabled in the playstation 3 under linux... otherwise that would be a great testbed for stream programming
12:17:11 <siti> yeah, it's pretty silly that they disable it
12:17:20 <allbery_b> that said, anything only present in hierarchical libs is an extension :)
12:17:39 <ctkrohn> eh, it makes commercial sense... otherwise people would just make games for Linux and avoid paying Sony the massive fees to use their PS3 game dev kits
12:17:57 <siti> maybe, but there are no nvidia drivers
12:18:07 <siti> for ppc
12:18:15 <ctkrohn> oh, good point
12:18:30 <siti> and that open source nvidia driver is still work in progress
12:18:47 <malsyned> allbery_b: thanks
12:18:52 <siti> they have glxgears... and are trying to get q3 ...
12:19:06 <ctkrohn> yeah I was fighting with nvidia drivers on my linux machine yesterday... not pleasant
12:19:13 <ctkrohn> anyway, time for class... later
12:19:29 <xic> eventually the nvidia drivers will be Free Software
12:19:51 <siti> why do you think that xic?
12:20:57 <xic> just an optimistic hunch
12:21:02 <siti> lol
12:21:52 <shapr> Nvidia's next generation of GPUs will be accessible as parallel processing units, so I think that's the future.
12:22:04 <siti> there drivers on linux are really good :) but I think they would be better if open sourced but I don't think that will happen
12:22:06 <xic> hey, intel released the source for their linux gpu drivers
12:22:45 <siti> yes but there are some parts that aren't but optional (for performance) iirc
12:23:01 <njd> there are plenty of multi-core systems out there - network processors, cell processors etc
12:23:02 <shapr> The only intel graphics stuff I've heard about was for a chipset that's included in the motherboard, or comes with laptops.
12:23:23 <velco> can intel's GPUs compete with nv and ati ?
12:23:37 <xic> velco: no, but they are still good enough for lots of purposes
12:23:37 <velco> e.g. are they programmable at all ?
12:23:42 <xic> velco: yep
12:23:50 <velco> GLSL ?
12:23:53 <siti> well there are rumors they are doing non-embedded video cards
12:24:01 <xic> velco: yes
12:24:36 <shapr> I use nvidia's binary only drivers, but it sure does irritate me. I'd like to switch to a non-Intel arch.
12:26:41 <shapr> I can barely wait till the OpenGraphics project has a release.
12:27:07 <siti> ok
12:28:51 <dcoutts> shapr, the older ATI cards are perfectly good
12:28:57 <dcoutts> and these days they're cheep too
12:29:31 <dcoutts> the 9250 is the last model with open source drivers for accelerated 3D
12:29:46 <shapr> My worry is that they're no longer made.
12:29:53 <dcoutts> you can still get them
12:30:03 <dcoutts> get one now while stocks last :-)
12:30:07 * dcoutts has 2
12:30:19 <shapr> I think the nvidia reverse engineering project won't succeed because it'll have to be redone when new hardware is released.
12:30:49 <siti> shapr: no most of there hardware is similar
12:30:50 <shapr> That's why I have great hopes for OGD, in that case people will always be able to make their own drivers.
12:31:10 <siti> listen to the linux.conf.au talk
12:31:25 <siti> ati changes things every upgrade
12:31:27 <xic> problem with old ati cards is that they suck :P a new intel card would be a better choice
12:31:53 <bos> and intel uses functional languages to verify their hardware designs!
12:31:58 <dcoutts> xic, I get pretty decent desktop and 3D with my Radeon9250
12:32:18 <dcoutts> bos, aye colleagues of mine develop some of that stuff
12:32:26 <bos> dcoutts: very nice
12:33:00 <dcoutts> bos, Intel were very original in their choice of names "FL" for "Functional Language". Yeah, great.
12:33:08 <siti> lol
12:33:13 <bos> well, you have to take what you can get.
12:33:22 <dcoutts> at least F# fits the still naming scheme
12:33:27 <dcoutts> still/silly
12:33:47 <dcoutts> do# you# F#?
12:33:57 * velco tries to sing F# ...
12:33:59 <dcoutts> No F# off!
12:34:31 <siti> the problem with haskells name is that people think you are saying pascal and give you a funny look
12:34:43 <dcoutts> yeah, true
12:34:44 <siti> when you say you use it...
12:34:51 <bos> the good thing is that haskell googles well.
12:35:13 <siti> oh yeah, searching for c sucks
12:35:58 <shapr> Yeah, J and K were bad languages names for googling.
12:36:23 <siti> the worst would be "I"
12:37:14 <nornagon> @hoogle exec
12:37:14 <lambdabot> Directory.executable :: Permissions -> Bool
12:37:14 <lambdabot> Distribution.PackageDescription.executables :: PackageDescription -> [Executable]
12:37:14 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
12:37:19 <nornagon> @hoogle execve
12:37:20 <lambdabot> No matches found
12:39:24 <bos> @hoogle executeFile
12:39:24 <lambdabot> No matches found
12:39:47 <bos> nornagon: you want System.Posix.Process.executeFile
12:40:02 <nornagon> Okay :)
12:40:10 <nornagon> bd_ has pointed me at runProcess
12:40:10 <LordBrain> hey, i want to build ghc under cygwin, has this been done?
12:40:10 <bos> all the posixy stuff got renamed. it's a tad annoying.
12:40:18 <bos> runProcess is not the same.
12:40:32 <bd_> runProcess forks first, right?
12:40:34 <LordBrain> i dont have any version of ghc to start with, so i guess i have the boot strapping problem
12:40:36 <bd_> does it check the path?
12:40:41 <bos> yes, it's more like system(3)
12:40:58 <LordBrain> i suppose i could use the windows binary
12:41:28 <LordBrain> hmmm but if i do that it wont understand the cygwin paths
12:45:36 <LordBrain> if i get the visual studio version of ghc, will i still be able to use it normally as with the command line?
12:48:06 <pejo> LordBrain, you probably don't want to build ghc under windows. Someone else asked the exact same question the other day and those who run Windows said what I just said.
12:48:07 <glguy> I don't know... I have both installed
12:48:20 <LordBrain> ok pejo, i wont
12:48:26 <LordBrain> i'll just get a pre-built version
12:48:28 <dcoutts> LordBrain, I'd install the normal command line version
12:48:45 <LordBrain> well i do have visual studio here, with a vim plugin
12:48:55 <LordBrain> hmm
12:49:09 <LordBrain> ok.. i guess i'll get the command line
12:49:17 <glguy> why do you have to pick?
12:49:20 <glguy> dial-up?
12:49:26 <LordBrain> yeah i dont
12:49:33 <LordBrain> i'm already downloading the visual one
12:49:37 <glguy> visual haskell installs the command-line stuff
12:49:41 <glguy> in the visual haskell directory
12:49:46 <LordBrain> i'll see if it gives me the commandline tools, and if it doesnt i'll get those
12:49:53 <glguy> because it uses them
12:49:57 <LordBrain> ok
12:50:08 <glguy> but I don't know if it is easy to manually use them or not
12:50:10 <LordBrain> so i dont really need both then right?
12:50:18 <LordBrain> hmm
12:50:30 <glguy> but it *looks* like the same thing
12:50:35 <glguy> at casual glance
12:50:42 <LordBrain> i probably dont need both
12:50:56 <LordBrain> i'll try it with just the visual version, and if i run into a problem grab the other one
12:51:08 <LordBrain> i want hugs too
12:51:41 * mbishop kicks LordBrain out
12:52:05 <LordBrain> i meant the interpretter of course
12:53:09 * mbishop throws LordBrain's stuff out the window
12:53:36 <xic> @hoogle bracket
12:53:36 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:53:37 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
12:53:37 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
12:55:43 <paolino> is deriving (..) legal ?
12:56:07 <dmead> ?src foldr
12:56:07 <lambdabot> foldr k z xs = go xs
12:56:07 <lambdabot>     where go []     = z
12:56:07 <lambdabot>           go (y:ys) = y `k` go ys
12:56:14 <xic> why is there a subtract function but no add function?
12:56:24 <allbery_b> because subtract is a hack
12:56:32 <Botje> because parsing for eg (-5) is wonky
12:56:39 <allbery_b> subtract exists because (-1) is negative one instead of a section on (-)
12:56:40 <Botje> whereas (+5) is unambiguous
12:57:04 <Botje> well, not really, but no sane people write +5 when they mean 5
12:57:05 <nornagon> (-1) would be (1-) anyway.
12:57:19 <nornagon> oh, wait
12:57:20 <nornagon> nm.
12:57:23 <nornagon> :$
12:57:30 <Botje> (1-) is unambiguous
12:57:39 <Botje> but (-1) can mean either the section or the number
12:57:43 <nornagon> right.
12:57:44 <Botje> :t (1-)
12:57:46 <lambdabot> forall a. (Num a) => a -> a
12:57:48 <Botje> :t (-1)
12:57:50 <lambdabot> forall a. (Num a) => a
12:57:56 <bd_> :t (- 1)
12:57:58 <lambdabot> forall a. (Num a) => a
12:58:07 <paolino> :t (+)(-1)
12:58:08 <lambdabot> forall a. (Num a) => a -> a
12:58:09 <allbery_b> :t ((-) 1)
12:58:11 <lambdabot> forall a. (Num a) => a -> a
12:58:17 <nornagon> :t (flip (-)) 1
12:58:18 <lambdabot> forall b. (Num b) => b -> b
12:58:22 <allbery_b> :t (- (1))
12:58:24 <lambdabot> forall a. (Num a) => a
12:58:40 <nornagon> @src subtract
12:58:40 <lambdabot> subtract x y = y - x
12:59:13 <kaol> > 4 `subtract` 3 -- whee
12:59:14 <lambdabot>  -1
12:59:25 <dmead> ?src fold
12:59:25 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:59:37 <dmead> fu lambdagizmo
12:59:56 <allbery_b> ?src foldl
12:59:56 <lambdabot> foldl f z xs = lgo z xs
12:59:56 <lambdabot>     where lgo z []     =  z
12:59:56 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:00:02 <allbery_b> ?src foldr
13:00:02 <lambdabot> foldr k z xs = go xs
13:00:02 <lambdabot>     where go []     = z
13:00:02 <lambdabot>           go (y:ys) = y `k` go ys
13:00:05 <xic> @seen kolmodin
13:00:05 <lambdabot> kolmodin is in #darcs, #gentoo-haskell, #haskell.hac07 and #haskell. I last heard kolmodin speak 15m 49s ago.
13:01:36 <kolmodin> hia xic
13:01:44 <xic> kolmodin: hey man!
13:02:42 <xic> kolmodin: is it safe to call inotify_init several times?
13:02:56 <dcoutts> sure
13:03:00 <kolmodin> yep
13:03:09 <dcoutts> it allocates a new inotify descriptor
13:04:08 * kolmodin just finished writing an ebuild for HAppS
13:04:09 <xic> what is the difference between adding 2 watches on a single inotify descriptor vs adding 2 watches each on a seperate inotify descriptor?
13:04:20 <kolmodin> you have no idea how much cabal has simplified my life :)
13:04:55 * glguy has never had to figure out how to install a library without Cabal :)
13:05:01 <kolmodin> xic: not much really, you'll hardly notice a difference
13:05:13 <kolmodin> xic: you'll have twice as many threads running though
13:06:06 <xic> kolmodin: and thus the watch event handlers will run concurrently?
13:06:21 <kolmodin> xic: yes
13:06:35 <kolmodin> xic: I intend to provide a non threaded version some day too
13:06:54 <kolmodin> xic: and make the API a little better
13:07:28 <xic> kolmodin: ok so the punch line is that it's safe to call inotify_init several times, in code places that aren't logically related to each other?
13:08:08 <dcoutts> xic, it's just like openFile
13:08:30 <xic> except there is not matching hClose :D
13:09:06 <xic> will the GC automatically clean things up when i stop using the INotify handle?
13:10:58 <kolmodin> xic: exactly, it's safe. and I'll provide a close in the next release :)
13:11:19 * shapr hugs kolmodin 
13:11:28 <kolmodin> xic: no, as there are threads running that still might get events
13:11:34 * kolmodin hugs shapr back
13:11:38 <shapr> kolmodin: Got any HAppS feedback?
13:11:40 <glguy> openFile hClose smells like malloc free ;)
13:11:42 <shapr> Any ideas, suggestions, etc?
13:11:54 <kolmodin> shapr: haven't tried it yet, just made an ebuild
13:12:11 <kolmodin> don't worry though, it's the first step towards trying it :)
13:12:11 <shapr> Ok, if you come up with anything, I'd like to hear about it.
13:12:15 * shapr cheers
13:13:14 * heatsink watches the snow fall horizontally
13:13:25 <glguy> the drive home today is going to *suck*
13:13:36 <shapr> kolmodin: Does the ebuild mean that HAppS is now available on Gentoo?
13:13:44 * allbery_b looks at the 6+ inches already on he ground and nervusly eyes the approach of the freezing rain
13:13:49 <kolmodin> shapr: nice to see that you try to provide a DBMS
13:14:05 <kolmodin> shapr: curryntly only in the gentoo haskell overlay
13:14:10 <shapr> ok
13:14:13 * heatsink lives two blocks away ^_^
13:14:26 <shapr> That's good to hear.
13:14:53 <kolmodin> shapr: have you heard of the DBMS written in erlang?
13:15:03 <shapr> Yeah, mnesia rocks
13:15:36 <shapr> But it rocks not because it's a DBMS, but more because it automatically migrates data for failover and can dynamically add and remove nodes without losing data
13:15:38 * allbery_b lives ~25 miles away from campus, didn't make it in today (mostly because he overslept and was dizzy when he woke up, damn ear infection), not sure if he';ll make it in tomorrow with the forecast overnight
13:15:39 <shapr> That is *way* cool.
13:16:01 <shapr> Where are you guys? It's warm enough to wear shorts here in Birmingham.
13:16:17 <newsham> i'm wearing shorts
13:16:20 <glguy> and you are camping out in #haskell?
13:16:20 * heatsink is in mid-Illinois
13:16:23 <dcoutts> shapr, we had inches and inches of snow here the other day
13:16:27 <newsham> and a tshirt, and no shoes.
13:16:29 * glguy in St. Louis city
13:16:29 <kolmodin> it snowed today..
13:16:49 <mbishop> It's warm enough to swear here in louisiana :/
13:17:00 <shapr> I'm almost naked! Well, except for this t-shirt, and these other clothes.. I guess it's not that exciting after all.
13:17:03 <dcoutts> shapr, I was thinking of you and your massive-tired unicycle as I struggled on my thin tyre through the snow :-)
13:17:05 <newsham> dcoutts: do you know if its possible to use runhaskell and ghci with gtk2hs (in win32)?
13:17:09 <shapr> dcoutts: haha!
13:17:18 <dcoutts> newsham, yes and yes.
13:17:26 <dcoutts> newsham, with ghc-6.6 it works perfectly
13:17:45 <sjanssen> I'm jealous of shapr's warm weather
13:17:45 <shapr> dcoutts: Did you see my Mountain Unicycling album? I've been up and down the mountain bike trails recently, it's fun!
13:17:53 <newsham> dcoutts: not perfectly here :(
13:17:56 <dcoutts> shapr, I've not seen it
13:17:58 <dcoutts> newsham, oh?
13:17:59 <shapr> sjanssen: This is winter... you won't be jealous when summer hits.
13:18:00 <heatsink> shapr: cool
13:18:12 * kolmodin is off to bed, g'night!
13:18:29 <shapr> sjanssen: This is the coldest part of the year. In the summer the streets melt and the asphalt slowly forms puddles.
13:18:29 <dcoutts> g'night kolmodin
13:18:33 <shapr> g'nite kolmodin!
13:18:35 <shapr> Thanks for the ebuild!
13:18:44 <kolmodin> np
13:18:49 <newsham> ?paste
13:18:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:19:55 <hpaste>  ndm pasted "lhs2tex output" at http://hpaste.org/480
13:19:57 <hpaste>  newsham pasted "GTK2HS runhaskell error on win32" at http://hpaste.org/481
13:19:59 <shapr> dcoutts: http://picasaweb.google.com/shae.erisson/ has two albums that include mountain unicycling.
13:20:01 <lambdabot> Title: Picasa Web Albums - shapr
13:20:18 <dcoutts> newsham, use the latest Gtk2Hs release candidate
13:20:36 <newsham> ?where gtk2hs
13:20:36 <lambdabot> http://haskell.org/gtk2hs/
13:20:57 <dcoutts> shapr, nice :-)
13:21:07 <newsham> I'm using http://haskell.org/gtk2hs/gtk2hs-0.9.10.6.exe
13:21:12 <ndm> @seen kosmikus
13:21:12 <lambdabot> kosmikus is in #darcs, #ghc, #gentoo-haskell and #haskell. I last heard kosmikus speak 13m 7s ago.
13:21:36 <dcoutts> newsham, are you sure? that restriction was in 0.9.10.5 and was lifted in .6
13:21:47 <ndm> kosmikus: i replied with the tex document, but just got a bounce message - i've resent and pastebotted the tex document
13:21:47 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
13:21:48 <newsham> i'll reinstall..  1 sec
13:22:06 <shapr> dcoutts: I've been think of your speedy street unicycle every time I ride on the road. I want a coker! And maybe even a geared hub!
13:22:16 <dcoutts> hah hah
13:22:27 <ndm> how come hpaste is limited to 5k?
13:22:38 <ndm> seems overly restrictive :(
13:22:49 <shapr> If you paste GHC, my server will cry.
13:22:56 <dcoutts> shapr, with a nice firm tyre you can really speed along on roads
13:23:16 <ndm> shapr: yeah, i can see why you are for a restriction if you are the one with the server
13:23:21 <shapr> dcoutts: Yeah, my monster tire just doesn't get much speed. It doesn't slow down for anything, but neither does it go fast.
13:23:33 <dcoutts> shapr, I'd go for a 28" or there abouts before going all the way with a coker
13:23:45 <dcoutts> with a street tyre
13:23:54 <shapr> My arctic muni is 29" or so on the outside.
13:24:38 <shapr> So cruising speed is faster than the average jogger, and about the same speed as a non-sport bicycle.
13:24:55 <shapr> Are the 28s cheaper than a Coker?
13:25:02 * shapr wonders if he should swap to #unicycling for a bit...
13:25:24 <newsham> dcoutts: uninstalled, installed 0.9.10.6, same error.
13:25:32 <newsham> is it possible there are stale files not getting updated?
13:25:45 <hpaste>  chessguy annotated "a few possible type definitions" with "commented version of some thoughs on a GP framework" at http://hpaste.org/476#a1
13:25:48 <newsham> (I made sure the entire /c/Program Files/Gtk2HS was cleared out)
13:25:51 <glguy> " Dynamic Typing != No Typing   (rollamonkey.com)" -- I guess it would be inappropriate to write a comment "but it does mean 'poor typing'"
13:26:06 <chessguy> @tell paolino http://hpaste.org/476#a1 has my comments
13:26:06 <lambdabot> Consider it noted.
13:26:12 <newsham> (btw, I coulda swore I was getting a different error message previously)
13:26:24 <allbery_b> mmm, nancy typing
13:26:28 <kosmikus> ndm: ok
13:26:43 <ndm> kosmikus: i just resent, let me know if you don't get it
13:27:01 <ndm> kosmikus: i'm really looking forward to using lhs2tex :)
13:27:04 <alexj> newsham: are you friends with aaronb?
13:27:19 <newsham> everything works fine when I compile with ghc --make, btw.
13:27:26 <newsham> alexj: yup!  he mentioned he met you...
13:28:19 <kosmikus> ndm: the code looks ok.
13:28:28 <dcoutts> newsham, run ghci, run this: System.Environment.getProgName  what does it say exactly?
13:29:04 <ndm> kosmikus: i got a config error during configure that poly* would nto be installed because it was unable to find my texmf directory
13:29:05 <kosmikus> ndm: ah no, I can reproduce the error
13:29:57 <newsham> Prelude System.Environment> getProgName -> "<interactive>"
13:30:10 <kosmikus> ndm: could this be a problem with line endings?
13:30:10 <newsham> newsham@lenoxp$ which ghci
13:30:11 <newsham> /c/ghc/ghc-6.6/bin/ghci
13:30:30 <kosmikus> ndm: there shouldn't be blank lines between every two lines
13:30:43 <ndm> kosmikus: could easily be, i can try removing those...
13:31:51 <dcoutts> newsham, that's pretty odd then since that's exactly what initGUI checks for
13:32:09 <dcoutts> newsham, you clearly have the new code since I changed the error message at the same time
13:32:43 <dcoutts> newsham, it does:
13:32:44 <dcoutts> initGUI = do
13:32:44 <dcoutts>   name <- getProgName
13:32:44 <dcoutts>   when (rtsSupportsBoundThreads && name /= "<interactive>") $ fail
13:34:21 <ndm> kosmikus: you are indeed right, its the blank lines - removing them fixes everything
13:34:41 <dcoutts> newsham, so when you just do Graphics.UI.Gtk.initGUI in ghci it says that?
13:34:48 <ndm> kosmikus: plus because polytable is on ctan, it even gets automatically downloaded and installed by tex distribution :)
13:34:51 <kosmikus> ndm: then you can probably fix the problem by recoding lhs2TeX.sty and co.
13:35:07 <kosmikus> ndm: by yours, maybe ;)
13:35:25 <ndm> kosmikus: given i now know what it is, i'll see if i can fix it and submit a patch
13:36:55 <newsham> lemme see if runhaskell reports different than ghci
13:37:15 <kosmikus> I'm not entirely sure why this happens. Unix makes use of \n, Windows of \r\n, right, so why would including a Unix-encoded file in a Windows-encoded file cause blank lines to appear?
13:37:35 <newsham> runhaskell foo.hs
13:37:36 <newsham> "foo.hs"
13:37:55 <newsham> my error message was from runhaskell, btw, not ghci.
13:37:57 <glguy> kosmikus: maybe it treated the whole file as UNIX encoded
13:38:06 <glguy> and then threw up on the \r
13:38:21 <kosmikus> glguy: ah, that's possible
13:38:30 <ndm> kosmikus: the file type is reported as "unknown" - the mixing and matching confuses everyone!
13:38:32 * glguy is speculating wildly
13:38:54 <ndm> kosmikus: if you readFile, lines, unlines all the files which are included, that should work
13:39:07 <allbery_b> so it's in raw mode, which is effecitely unix mode?
13:39:13 <allbery_b> *effectively
13:39:20 <kosmikus> ndm: yes, I can do that on Windows
13:39:48 <ndm> kosmikus: plus, are you going to move to darcs at any point?
13:39:58 <ndm> (i recently deleted svn as Yhc no longer depends on it!)
13:40:04 <kosmikus> :)
13:40:15 <kosmikus> for now, you can send me a patch by mail
13:40:24 <kosmikus> yes, I might change to darcs, but I'm not particularly motivated
13:40:25 <ndm> hmm, thats a lot harder
13:40:31 <ndm> since i first have to install svn
13:40:52 <ndm> i've been going off the tarball from the last release
13:41:11 <kosmikus> that's fine
13:41:28 <kosmikus> the changes currently in svn are minimal
13:41:34 <kosmikus> patch against current release is ok
13:41:46 <ndm> plus doing diffs and patchs on windows is a pain, but will give it a go tomorrow
13:41:57 <ndm> don't have lhs2tex installed on this machine, only my office one so far
13:42:40 <dcoutts> newsham, oh runhaskell, well no you don't get let off for that one. You have to read the error message and believe it.
13:42:41 <ndm> i'll probably put together an lhs2tex binary, for me if no one else
13:42:57 <kosmikus> yes, that'd be great.
13:43:21 * kosmikus is away for dinner
13:43:47 <newsham> how do I relink my program with -threaded?
13:43:51 <newsham> when I'm not even linking it?
13:43:58 <matthew-_> you using ghc --make?
13:44:19 <dcoutts> newsham, use ghc --make rather than runghc
13:44:29 <paolino> :t lift
13:44:30 <lambdabot> paolino: You have 1 new message. '/msg lambdabot @messages' to read it.
13:44:31 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:44:32 <dcoutts> newsham, runghc itself is linked with -threaded
13:44:49 <matthew-_> just rm *.o *.hi then ghc --make -threaded
13:45:17 <matthew-_> cos annoyingly, ghc --make has exactly the same problem as gnu make in that it doesn't spot when compile flags have changed
13:45:28 <dcoutts> newsham, I make an exception for ghci since people typically do not use threads in ghci but for stand alone programs you have to understand the threading restriction.
13:45:37 <newsham> ok, so ghci good, but runhaskell no go...
13:45:53 <newsham> next problem :)   when using ghci I was seeing some weirdness where it would go out to lunch processing events
13:46:06 <dcoutts> newsham, were you using forkIO ?
13:46:09 <newsham> nope.
13:46:14 <dcoutts> good
13:46:33 <newsham> ghci square.hs   (shows picture, but wont refresh, and wont accept close window action)
13:47:02 <newsham> square.hs is here:  http://www.thenewsh.com/%7Enewsham/x/machine/turtle/
13:47:04 <lambdabot> Title: Directory /~newsham/x/machine/turtle/
13:47:08 <glguy> GTK + ghci = no good
13:47:20 <newsham> ok, so no ghci, no runhaskell?  :)
13:47:38 <matthew-_> just ghc I guess ;)
13:47:41 <dcoutts> glguy, I've allowed ghci
13:47:52 <glguy> oh
13:47:56 <dcoutts> since it's convenient
13:48:05 <glguy> is that new?
13:48:10 <dcoutts> but don't even think about using forkIO in ghci with gtk :-)
13:48:10 <glguy> is this a joke? http://www.windevpowertools.com/default.aspx
13:48:11 <lambdabot> Title: Windows Developer Power Tools
13:48:16 <dcoutts> glguy, yep, new
13:48:42 <glguy> link clouds are the new <blink> tag
13:49:01 <newsham> dcoutts: is it because I'm using the Gtk SOE stuff?
13:49:18 <glguy> I'd like to see some retro link clouds that blink!
13:49:31 <dcoutts> newsham, maybe
13:49:48 <mauke> <blink frequency="PARTY HARD!">
13:50:15 <dcoutts> newsham, yes. it is soe. It uses forkIO so you can't use it in GHCi.
13:51:16 <dons> ?yow!
13:51:17 <lambdabot> The Osmonds!  You are all Osmonds!!  Throwing up on a freeway at
13:51:17 <dcoutts> newsham, yeah, when I run it I get Xlib errors
13:51:17 <lambdabot> dawn!!!
13:51:22 <dons> ?users
13:51:22 <lambdabot> Maximum users seen in #haskell: 322, currently: 307 (95.3%), active: 50 (16.3%)
13:51:23 <dcoutts> g'morning dons
13:51:31 <dons> morning dcoutts !
13:51:32 <dcoutts> Xlib: unexpected async reply (sequence 0xc3)!
13:51:35 <dcoutts> newsham, ^^
13:51:36 <mbishop> mauke: was that a 4chan reference?
13:51:47 <mauke> mbishop: possibly
13:51:47 <dcoutts> newsham, and that'll be because of using multiple OS threads with Xlib
13:51:49 <newsham> ok.. that makes sense i guess.
13:51:53 * shapr hugs dons
13:52:05 <dons> :)
13:52:13 * dons waves at shapr 
13:52:16 * shapr boings fractiously
13:52:38 <newsham> oh well, i was hoping maybe to modify it to run as two halves, and interactive client and a server that does the gui commands
13:52:48 <newsham> but i guess that wont be possible in ghci with either SOE or straight gtk?
13:53:01 <newsham> i wanted interactive turtles in ghci
13:53:17 <dcoutts> newsham, you'll have to compile a standalone prog
13:53:47 <dcoutts> newsham, using threads with Gtk is possible if you follow the rules
13:54:07 <dons> TuringTest: http://lambda-the-ultimate.org/node/2064
13:54:08 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast | Lambda the Ultimate
13:54:16 <dcoutts> newsham, see the demo/concurrent examples
13:54:18 <newsham> so i'll have to use hs plugins to do interactive haskell w/ gtk?
13:54:21 <TuringTest> hmm?
13:54:21 <lambdabot> TuringTest: You have 1 new message. '/msg lambdabot @messages' to read it.
13:54:35 <dons> TuringTest: a) the C program now uses pcre.h on the shootout
13:54:57 <dons> b) hacked up an implementation of Thompson NFA yet?
13:55:11 <dcoutts> dons, isn't that cheating? using an external pcre ?
13:55:31 <dons> i'd have though so ... but C has certain flexibility in this matter
13:55:44 <dons> hence we'd be able to at least put the case to use regex-tre or regex-pcre
13:55:50 <dcoutts> newsham, I don't see how hs-plugins as anything to do with it
13:55:55 <dons> TuringTest: speaking of which, can I upload those packages to hackage?
13:56:09 <newsham> dcoutts: i want interactive haskell commands to use the turtle.
13:56:21 <newsham> and you said "no ghci"
13:57:09 <dcoutts> newsham, ah I see. If you can do it by following the threading rules then you can even do it in ghci
13:58:20 <newsham> hmm.. but dont I need to let the ghc main loop run between ghci commands?  wont that require a second thread?
13:58:37 <dcoutts> newsham, or I could see about making the soe impl thread safe.
13:58:55 <newsham> i can ditch SOE and code straight to gtk if necessary
13:59:05 <newsham> the graphics code itself is fairly small
13:59:11 <TuringTest> dons: I am taking a delivery and busy....I'll get back to you in a few minutes
13:59:27 <dcoutts> newsham, see the concurrent demos, especially the threaded RTS one
13:59:43 <newsham> thanks.
13:59:53 <TuringTest> dons: Upload regex-* wherever you want....they are on darcs.haskell.org at the moment.
14:00:41 <dons> TuringTest: where are the tar balls for the stable releases?
14:02:34 <dino-> Is it possible to compile against shared libs?
14:02:48 <dino-> In this case, I build something with HXT in it and out plonks a 6.4M binary.
14:03:02 <dino-> And I think, man, all that static stuff in there.
14:03:53 <dino-> s/compile against/link with/
14:06:35 <TuringTest> dons: The "stable" is at ...
14:07:03 <TuringTest> http://darcs.haskell.org/packages/regex-pcre http://darcs.haskell.org/packages/regex-XXXXXX
14:07:04 <lambdabot> Title: Index of /packages/regex-pcre
14:07:20 <TuringTest> dons: I have no tarballs
14:07:44 <TuringTest> dons: regex-pcre is faster than regex-tre on the benchmark, last I checked.
14:09:11 <TuringTest> I have been trading several e-mails back and forth with same Russ Cox mentioned on http://lambda-the-ultimate.org/node/2064
14:09:12 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast | Lambda the Ultimate
14:11:26 <TuringTest> As for the NFA...our entry right now builds a DFA which, algorithmically, is even better.  In practice the regexps used in the shootout are not very complicated.
14:11:33 <dons> TuringTest: so if I want to get regex-* on hackage, I'll need to roll my own tarballs I think
14:11:40 <dons> yeah true.
14:12:00 <dons> btw, its really a must that new libs are hosted on hackage, http://hackage.haskell.org/packages/archive/pkg-list.html
14:12:13 <dons> with over 100 packages up there now, its rapidly approaching the critical mass
14:12:19 <TuringTest> dons: The regex-* are cabal-ized so it should be able to "sdist" a source tarball
14:12:23 <dons>  yep. ok.
14:12:57 <dons> shapr, wow, hackage is catching projects i've never heard of, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fenfire-0.1
14:12:59 <lambdabot> http://tinyurl.com/yvclat
14:13:34 <xic> hackage is meant for libraries only, right?
14:13:45 <dons> nope. libraries and applications
14:13:53 <dons> check the list, progs are marked as 'program'
14:13:58 <xic> hm... what's the point of putting an application in there?
14:14:00 <dons> i.e. all haskell src fit to cabalise
14:14:08 <dons> xic, so you can find it
14:14:33 <allbery_b> xic: hackage : Haskell :: CPAN : Perl
14:14:35 <xic> usually people who are looking for a program don't really care if it's written in haskell or not :D
14:14:37 <dons> (then people can depend on it, and have cabal take care of that dependency, they can also find the src at any time in the future)
14:14:38 <allbery_b> (ore Pear : PHP)
14:14:56 * dufflebunk wishes there was a cpan type interface to cabal and hackage
14:15:16 <TuringTest> dons: I'll put the regex-* up on hackage  soon.  I am concentrating on getting regex-tdfa reworked under ST to get good speed & memory usage.  That plus regex-pcre gives us most everything we could want.
14:15:30 <dino-> dufflebunk: The thing I always wished they had in CPAN was uninstall.
14:15:45 <dino-> Perhaps I'm spoiled by apt.
14:15:56 <dons> TuringTest: ok. yeah, just darcs dist/cabal sdist your next tagged repos
14:16:17 <TuringTest> check
14:16:26 <allbery_b> sadly cabal punts on uninstall
14:16:42 <dino-> I'm kind of terrified to install things without a .deb archive. :o
14:16:45 * TuringTest curses systems that cannot handle uninstall
14:17:25 <mwc> allbery_b, if you leave it to your package system to handle the files, cabal will hapilly generate install and uninstall scripts for you to include in your package
14:18:59 <dino-> mwc: If I have something that I built from source and installed with cabal, I could generate an uninstall script?
14:19:41 <mwc> yeah, you use copy to install it to a destdir, and then register and unregister take --gen-script options
14:20:02 <shapr> dons: Cool!
14:20:07 <mwc> they'll output a script that you can run to install the package once the files are their final places and one to uninstall it from the haskell system before you delete the files
14:20:46 <dino-> mwc: mm, sounds like maybe too late for something not done from a destdir..
14:21:23 <mwc> right, it'll remove libs from  the haskell system but you're on your own for the files
14:21:38 <dino-> mwc: Still, doable. Thanks.
14:22:02 <astrolabe> I see OpenGL is in hackage
14:22:25 <astrolabe> Is there a way to see from that which dlls I need, and where to get them?
14:22:31 <astrolabe> (for windows)
14:23:16 <dons> I think in this case you'd need to check the package description for OpenGL
14:23:41 <xic> holy shit my program works
14:23:57 <dons> not possible!
14:24:08 <astrolabe> dons: So I click on OpenGL on that hackage page..., then what?
14:24:26 <astrolabe> xic: funny how haskell programs really work.  Seems like magic.
14:25:30 <Pseudonym> A working program?  In HASKELL?!
14:25:37 <dcoutts> astrolabe, I think the dlls it needs come with windows as standard.
14:26:10 <siti> lol
14:26:24 <xic> astrolabe: but it's buggy :'(
14:26:29 <chessguy> @quote work
14:26:29 <lambdabot> Lemmih says: dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
14:27:00 * dufflebunk thinks Lemmih was doing Java development too much
14:27:09 <mwc> xic, now that you've got it working, it's a good time to check it into Darcs.
14:27:21 <mwc> Darcs saved my ass this weekend in a mathematical modelling contest
14:27:23 <Pseudonym> Ship it!
14:27:31 <xic> mwc: i've been using darcs for a while with this project already :)
14:27:33 <Pseudonym> mwc: Oooh!  What did you model?
14:28:39 <mwc> Pseudonym, we came up with a better way to seat passengers on large aircraft. Our system is 3 times faster than the average case performance of any currently used seating procedure. Catch is you need 4.2 CPU-days on an operton cluster to do it :P
14:28:48 <astrolabe> dons, dcoutts_: Ug, my trivial openGL program seems to be working now.  It wasn't before.  You must have scared it with your uber hackerdom.
14:28:49 <Pseudonym> :-)
14:29:00 <dcoutts> astrolabe, hah
14:29:12 <Pseudonym> That sounds impractical, but it would work for, say, stadium events.
14:29:18 <edwinb> you also need people to not be incompetent at getting their bags in the overhead racks
14:29:20 <Pseudonym> Which are booked out months in advance.
14:30:30 <mwc> Pseudonym, Well, we observed that it can be done as soon as you know basic passenger information from checkin. It took about 4 hours on 20 CPUs, and i hadn't even remotely hit the parallization wall. I was getting >99.5% CPU utilization.
14:31:28 <chessguy> so how did darcs have anything to do with it?
14:31:41 <siti> mwc: is this with haskell?
14:31:56 <Pseudonym> You don't need to use Haskell to keep your source in darcs.
14:32:25 <mwc> siti, no, I used ocaml because I was more confident in my ability to get it running on the clusters.
14:32:28 <Pseudonym> Source control, for a small project, is mostly to protect you from your own stupidity.
14:32:34 <mwc> Pseudonym, exactly :)
14:32:57 <mwc> chessguy, I did something to my simulation that caused horrible brokenness. I spent twenty minutes trying to unfutz it\
14:33:07 <mwc> Then I just reverted and tried again and it worked.
14:33:12 <mwc> saved me at least another hour
14:33:32 <chessguy> nice
14:33:39 <siti> ok
14:34:00 <siti> bzr is easier to use ;)
14:34:11 <mwc> bzr?
14:34:15 <dcoutts> benja_, according to my experiment all the GdkGC entries in the GtkStyle are NULL.
14:34:35 <careo> but bzr's python, and darcs is haskell
14:34:50 <xic> i've heard really bad things about bzr
14:34:55 <careo> and having used neither, that's all I know
14:35:00 <careo> mercurial's pretty nice though
14:36:28 <siti> I've used git, bzr and darcs
14:36:49 <mwc> dcoutts, props on the flurry of commits on gtk2hs and c2hs in the past few days
14:37:11 <mwc> does this mean that gtk2hs is merging it's c2hs with the motherproject?
14:37:41 <dcoutts> mwc, yes, eventually
14:37:45 <dcoutts> that's the aim
14:43:52 <mwc> Ahh, I wondered if this was a sign it was imminent
14:45:57 <dcoutts> not imminent, no
14:46:12 <dcoutts> what I'm really trying to do at the moment it fix c2hs's C parser
14:46:25 <dcoutts> to make it correct
14:46:34 <dcoutts> and to extend the GNU extensions it can parse
14:46:58 <dcoutts> C is really a pain to parse at least if you want to do it 100% correctly
14:46:59 <mwc> I don't envy you the job of hacking a C parser\
14:47:03 <dcoutts> because of the typedef issue
14:47:18 <newsham> "if you've ever seen a monad, that is to know what true pain and suffering is"
14:47:19 <newsham> heh!
14:47:34 <newsham> Shriram's web continuations talk at microsoft
14:47:42 <mwc> Yeah, I've heard that most parsers don't do it correctly and just defer what are really parse errors to semantic analysis
14:48:04 <dcoutts> mwc, ah, no it's worse than that
14:48:07 <mwc> That's silly. Monads are the feature I miss most when I can't use Haskell
14:48:11 <givi> hello!
14:48:13 <givi> process :: (Integer -> Integer)
14:48:13 <givi> process i
14:48:13 <givi>    | i < 12    = i
14:48:13 <givi>    | otherwise = max i (process(div i 4)+process(div i 3)+process(div i 2))
14:48:29 <dcoutts> mwc, eg consider "int a=sizeof(a);"
14:48:41 <xic> newsham: isn't shriram the guy behind flapjax?
14:48:59 <newsham> dunno.
14:49:03 <dcoutts> mwc, if there is an existing 'a' in an outer scope as a typedef
14:49:09 <givi> I need to remember some of the values into an array for acceleration. How is it done in Huskell?
14:49:14 <newsham> i think he was joking around  alittle
14:49:28 <givi> Or is there any other way to make the function faster?
14:49:48 <xic> newsham: i don't think that's funny
14:49:54 <newsham> thats ok, I did :)
14:50:17 <givi> it's supposed to compute process(1000000000) very fast (<10 sec)
14:50:23 <xic> "if you've ever had to program in java, that is to know what true pain and suffering is"
14:50:25 <xic> now that's funny
14:50:34 <xic> :P
14:50:56 <mwc> givi, I was gonna suggest an array, but that's a little long
14:51:20 <dcoutts> mwc, then that code is a redeclaration of 'a' as a local var. Then the sizeof(a) refers to the var 'a' not the type 'a'. But we must enter the 'a' into the symbol table after parsing "int a" but BEFORE parsing "=sizeof(a)" or we'll get it wrong! Aaarg!
14:51:23 <mwc> Are you going to be hitting values sparsely?
14:51:25 <givi> mwc: what do you mean by long?
14:51:58 <mwc> givi, an array from 1 to 10000000000 or however many zeroes that is
14:52:22 <givi> an array can be 1 to 1000000
14:52:32 <dcoutts> mwc, so that makes life quite hard for a standard parser generator like happy since it only executes the semantic action for the grammar production after recognising the whole production, but here we need to do something half way through because it affects how we recognise the later bit.
14:52:35 <givi> but we need to compute up to 1e9
14:52:43 <mwc> right, but if you just store the values of process into the array, you'll need a giant array.
14:52:44 <allbery_b> IntMap seems like the right thing to use here
14:52:48 * shapr boings cheerfully
14:52:50 <allbery_b> wrapped in a State monad
14:53:07 <mwc> So if you're not hitting all the vaues, then a map is what you want, or as allbery_b pointed out, an IntMap ;)
14:53:23 <Botje> yes, intmap.
14:53:33 <mwc> dcoutts, is this something that could be fixed by switching to a Parsec parser
14:53:34 <mwc> ?
14:53:37 <Botje> allbery_b: what kind of optimizations does intmap have over map?
14:53:39 <givi> ?index IntMap
14:53:39 <lambdabot> Data.IntMap
14:53:43 <Botje> (or should I just RTFM?)
14:54:02 <givi> Thanx :)
14:54:06 <mwc> Botje, I assume that since it's not polymorphic there's no dictionary passing involved
14:54:08 <allbery_b> RTFM, I think.  I know IntMap is specialized compared to Map but couldn't tell you details
14:54:10 <dcoutts> mwc, I fear it may be worse since then we can't detect if we've written an ambiguous grammar.
14:54:22 <TuringTest> Another IntMap question.  Is IntMap much better than (Map Char) ?
14:54:24 * allbery_b is not a Haskell expert, is really not so far beyond a beginner
14:54:26 <mwc> probably a constant factor faster.
14:55:04 <TuringTest> mwc: I should change the regex-tdfa to use (ord) and IntMap then...
14:55:39 <dcoutts> TuringTest, of course if the map is constant then an array might be appropriate (if it's not sparse)
14:55:53 <xic> dcoutts: i remember reading in "the design of evolution of c++" by bjarne stroupstroup, how he had to write his own c parser instead of yacc because yacc wasn't powerful enough, but later he found out that people had actually done c parsers in yacc
14:55:56 <xic> dcoutts: or something like that
14:56:02 <dons> TuringTest: yeah, IntMap is better than Map Char
14:56:09 <dcoutts> xic, that makes sense.
14:56:29 <mwc> I've heard that at UWaterloo, undergrad students in compiler courses don't get to use parser generators period.
14:56:32 <dcoutts> xic, I started by porting a yacc C grammar to happy.
14:56:46 <TuringTest> dcoutts: The heuristic to switch to Array from IntMap is something I might add at a later stage.  That requires some tuning.
14:56:48 <xic> dcoutts: was the yacc c grammar a monster?
14:56:54 <dcoutts> xic, not really
14:57:06 <mwc> C actually isn't too bad
14:57:13 <dpiponi> I'm having a monad problem, I wonder if anyone can help.
14:57:15 <mwc> the declaration syntax is kinda boneheaded,
14:57:20 <mwc> but C++ is where the real pain starts
14:57:21 <TuringTest> dpiponi: Ok.
14:57:45 <dpiponi> It's embarassing. I can't solve the problem I set on my blog.
14:58:00 <dcoutts> mwc, I think that isn't helpful really, since parser generators are great tools, writing recursive decent parser by hand is terribly error prone and one of the major advantages is in detecting if the grammar is ambiguous.
14:58:28 <dpiponi> Can you port the scheme code here to Haskell using the Cont monad? http://sigfpe.blogspot.com/2007/02/exceptions-disjunctions-and.html
14:58:30 <lambdabot> Title: A Neighborhood of Infinity: Exceptions, Disjunctions and Continuations, http://tinyurl.com/23evrr
14:58:30 <dcoutts> mwc, yeah, it's the declaration bit and the typedef problem that make it hard, the rest is easy.
14:58:37 <edwinb> I'm not so sure there's much point in making students write parsers by hand
14:58:50 <edwinb> there are much more interesting and useful bits of compilers/interpreters to learn to write
14:59:11 <dcoutts> edwinb, right, it'll just make them think that parsers are mysterious and hard
14:59:29 <dcoutts> they should use parser combinators or a generator
14:59:35 <edwinb> I'm teaching compiling this year, and basically gone as quickly as possible into interpreting ASTs
14:59:40 <edwinb> because that's more fun
14:59:43 <TuringTest> dpiponi: reading...
14:59:44 <dcoutts> aye
14:59:48 <dons> dpiponi seems doable. you want some one to do it?
15:00:01 <dons> ?users
15:00:02 <lambdabot> Maximum users seen in #haskell: 322, currently: 306 (95.0%), active: 49 (16.0%)
15:00:13 <dpiponi> dons: yes. I'd like something that looks vaguely like the scheme code.
15:00:20 <dibblego> why is newtype MyBool = MyBool Int faster than Prelude.Bool?
15:00:28 <dcoutts> edwinb, we use some of the TAPL exercises as practicals and that's almost all post-parsing stuff.
15:00:41 <mahogny> can someone elaborate on hsc2hs and c2hs? are these supposed to complement each other?
15:00:41 <dons> dibblego: code please. if that's true its a bug..
15:00:42 <dibblego> and was there a conversation/mailing list thread about it once? (I vaguely recall something)
15:00:51 <dibblego> dons, I'll work on it
15:01:07 <dons> depends on how you use it too, since Bool is. e.g. a bit vector when used in an array
15:01:12 <dpiponi> Feel free to write an alternative to callCC because I'm really talking about a function with type not (not a)->a instead of Peirce's law.
15:01:13 <dons> whereas MyBool won't
15:01:19 <dons> (so the instances might be different)
15:01:26 <dibblego> not using arrays
15:01:28 <dcoutts> mahogny, at the moment they are somewhat complementary, when I'm done there will be little that hsc2hs can do that c2hs can't and plenty the other way around.
15:01:28 <mwc> edwinb, I think the point is to teach them about DFA's and NFA"s in the lexer stage and about how parsers work in the parsing state
15:01:48 <edwinb> that depends on the point of the course I suppose
15:01:58 <edwinb> here, they've already covered DFAs/NFAs in other courses
15:02:06 <dcoutts> edwinb, our compilers course skips past lexers and parsers pretty quickly too
15:02:55 <dcoutts> edwinb, when I did it years ago the lecturer basically told us that lexers and parsers are easy solved problems and the interesting stuff is later on in the compiler.
15:03:05 <dcoutts> which is right of course
15:03:08 <edwinb> I wish we'd have a course liike that...
15:03:11 <edwinb> had, sorry
15:03:19 <dons> whoa, anyone in .se know this guy, http://blog.nurd.se/hype/?p=30
15:03:22 <lambdabot> Title: Stuff Â» Blog Archive Â» Eldora: Reinventing IRC
15:03:26 <shapr> Would anyone else be interested in hosting their HAppS apps somewhere?
15:03:32 <dons> (irssi in haskell)
15:03:44 <dons> shapr: on hackage perhaps?
15:03:50 <edwinb> we don't teach Haskell at all, so now I'm entertaining myself by hacking up interpreters live in lectures in an effort to convince them that learning Haskell will save them pain for the coursework...
15:04:05 <edwinb> I wonder if it'll work...
15:04:09 <dons> edwinb: he, I used to do that trick in my perl course
15:04:15 <dons> show them ghci+darcs
15:04:18 <dons> teach them perl
15:04:23 <dons> see if they get the subiminal mesage
15:05:11 <shapr> dons: I mean I was wondering if people want a server to run their HAppS apps on.
15:05:19 <dibblego> ?hoogle Eq a => [a] -> a -> ([a], Maybe a)
15:05:21 <lambdabot> No matches, try a more general search
15:05:37 <Botje> allbery_b: the source doesn't reveal much tricksiness. but I guess using Int everywhere is faster than "any type"
15:05:39 <shapr> dons: Or did you mean the hackage server for HAppS app hosting?
15:05:48 <dibblego> ?hoogle Eq a => [a] -> a -> Int
15:05:49 <lambdabot> No matches, try a more general search
15:05:52 * shapr is distracted and not thinking clearly...
15:05:58 <dons> shapr: no, I thought you meant src hosting
15:06:02 <dibblego> ?hoogle Eq a => [a] -> a -> Maybe Int
15:06:02 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
15:06:02 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
15:06:14 <shapr> I gotta pick up hackage tomorrow...
15:07:55 <glguy> Is there a simple math notation for an ordered list of things?
15:08:17 <xic> shapr: do you mean you have a server lying around unused?
15:08:19 <glguy> say if I was writing out an algorithm for a class
15:08:32 <dpiponi> glguy: Just use tuple notation (a,b,c,...) ?
15:08:34 <glguy> the haskell equivalent of:   p :: [Point]
15:10:35 <shapr> xic: It's more that I could set up a way for people to easily host their own HAppS apps if there's interest, but I don't know how many people want that.
15:10:55 <Saizan> P =p1,p2,..pn where pi is a Point -- i've seen only things like this
15:10:57 <shapr> I'm hosting hpaste on my ScannedInAvian.com server, and dmhouse wrote a forum that he was hosting there.
15:11:00 <sorear> tell fodder
15:11:31 <Mushy-pea> Hi.
15:11:43 <xic> shapr: well i am working on a competitor to happs, designed for "ajax" webapps
15:11:43 <mwc> glguy, you could just call it a set and state that there is an ordering relation on it that orders the elements into a list
15:11:43 <shapr> But if there are ten or more people wanting to host HAppS apps, I can organize a real server and an easier way to upload and run apps.
15:12:02 <shapr> xic: Sounds like an addition instead of a competitor :-)
15:12:17 <shapr> It's hoped that HAppS will have an ajax plugin at some point.
15:12:24 <xic> shapr: yeah :) i already have a simple chat example app working, and it would be awesome to test it on the internet
15:12:29 * dylan doesn't like the zopeyness of happs
15:12:48 <shapr> dylan: Tell me more?
15:12:55 * mbishop rinses dylan off
15:13:10 <xic> shapr: i'm probably gonna end up renting a virtual private server
15:13:12 <Mushy-pea> Is there a pre defined function that can be used with "filter" that will remove all list elements above a certain integer value?
15:13:13 <dylan> I really like my operating system, and I like the idea of fastcgi/cgi. image-y based things bother me.
15:13:24 <glguy> Any guesses on which would be more clear:
15:13:26 <shapr> dylan: Why so? implicit state?
15:13:34 <glguy> 1. For each p <- <p1,...,pn>
15:13:39 <edwinb> Mushy-pea: you could use an operator section, e.g. (>5)
15:13:46 <glguy> 2. For each p \elem <p1....
15:14:13 <sorear> I hate unix.
15:14:31 <shapr> dylan: I'd like to hear more..
15:14:31 <dylan> I like unixy things.
15:14:32 <dons> dylan: its a very easy set up to get working though. that's what I like about happs (e.g. hpaste.org was trivial just about)
15:14:37 <sorear> I am however a firm believer that Gabriel was right.
15:14:37 <glguy> > let mushypea n xs = filter (> n) xs in mushypea 4 [1..10]
15:14:39 <lambdabot>  [5,6,7,8,9,10]
15:14:51 <glguy> oops
15:14:56 <glguy> reverse the < :)
15:14:58 <dylan> dons: indeed, but it is not asthetically pleasing to me.
15:15:59 <dylan> the best analog I can think of is mbox vs. maildir. happs seems very mbox-y to me.
15:16:04 <givi> can anyone point out an example of using IntMap
15:16:07 <givi> ?
15:16:19 <Mushy-pea> Thanks.  I'll look into that.
15:16:31 <shapr> dylan: Can you give some description of what a maildir-y happs would be like? Or how it would be different?
15:16:36 <dons> > I.singleton 'x'
15:16:36 <lambdabot>  Couldn't match `Int' against `Char'
15:17:02 <bd_> hmm, why isn't IntMap just a specialization of Data.Map?
15:17:21 <sorear> shapr: wrt yesterday and HAppS website - can you regenerate the Current haddocks? they are extremely dated, older even than the Stable ones!!!
15:17:23 <dylan> shapr: each application would be a fast-cgi script using path-info to control what resource (page) was shown.
15:17:30 <sorear> bd_: it is a specialization
15:17:30 <dons> you get better code if you can assume Int keys, (even better than just SPECIALISE provides)
15:17:38 <sorear> bd_: but a VERY optimized one
15:17:39 <shapr> sorear: Oops, I'll put that on my list.
15:17:42 <bd_> sorear: Well, I mean, type IntMap v = Map k v, with a specialization?
15:18:02 <sorear> bd_: no, the data structure is subtly different
15:18:12 <dons> bd_ because you can get better code its purely a pragmatic response
15:18:14 <sorear> bd_: IntMap uses tries, Map uses trees.
15:18:18 <dons> yeah
15:18:21 <bd_> ah
15:18:29 <siti> tries?
15:18:34 <dons> ?docs Data.IntMap
15:18:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
15:18:38 <dons> givi: ^^
15:18:39 * sorear <3 tries
15:18:40 <dylan> tries are fun.
15:18:57 <siti> what are they?
15:19:00 <dons> > M.fromList (zip [1..10] "haskell") :: Map Int Char
15:19:00 <lambdabot>   Not in scope: type constructor or class `Map'
15:19:04 <bd_> hmm, I wonder if there'd be some way to make them the same type... Adding constructors to a type which already has more than one shouldn't affect performance negatively, right?
15:19:05 <dons> > M.fromList (zip [1..10] "haskell") :: M.Map Int Char
15:19:06 <lambdabot>  {1:='h',2:='a',3:='s',4:='k',5:='e',6:='l',7:='l'}
15:19:19 <dons> bd_, yeah, using associated types
15:19:34 <dons> you can define the IntMap type as just the special associated representation type to use when Map Int x
15:19:43 <bd_> dons: Well, I mean more like data Map = Nil | Tip ... | GeneralBin ... | IntBin ...
15:19:43 <dons> see the ATs wiki page
15:19:58 <bd_> and then use specialize pragmas to implement it using IntBin for Ints
15:20:02 <TuringTest> dpiponi: I have the haskell version...going to hpaste
15:20:07 <dons> you could at least provide the Map a b interface, and have the type system pick IntMap magically
15:20:12 <bd_> the implementation might be a bit ugly, but it would remove the duplication at the user level.
15:20:14 <dons> that seems nicer to me than having a more general structure
15:20:38 <dons> since there's often a good gain by hand crafting a specialised structure, which you don't want to lose
15:20:40 <dpiponi> TuringTest: I'm intrigued...
15:20:51 <shapr> dylan: That much like what HAppS already is... the tutorial shows a regex match on the url requested, and handlers are given the request and they can do whatever.
15:20:56 <bd_> dons: class Map m k v | m -> k v where ... ?
15:21:08 <dons> ?where ATs
15:21:08 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/AssociatedTypes
15:21:16 <dons> hmm, not that one.
15:21:17 <hpaste>  TuringTest pasted "(no title)" at http://hpaste.org/482
15:21:24 <dons> ?where indexed-types
15:21:25 <lambdabot> I know nothing about indexed-types.
15:21:43 <dons> bd_ basically, but using Ats, and index type families, not FDs
15:21:44 <TuringTest> dpiponi: That is sort of a haskell version of the Scheme code with left/right/either
15:22:09 <dons> bd_ since you don't want to expose the representation type for the Map
15:22:23 <dons> (i.e. whether it uses IntMap Trie or [(a,b)] or what have you should be hidden)
15:22:30 <dpiponi> TuringTest: Looks similar. I'll have to play with it of course.
15:22:48 <shapr> dylan: I'd like to discuss it more later, I'm off for now.
15:23:03 <hpaste>  TuringTest annotated "(no title)" with "use in ghci" at http://hpaste.org/482#a1
15:23:32 * bd_ nods
15:24:37 <dpiponi> TuringTest: Nice! Your implementation of right and left is what I expected, but my either was going horribly wrong.
15:26:28 <TuringTest> dpiponi: "compose" for monads is not a common operator.
15:27:50 <dons> dpiponi: ever thought of packing up the comonads stuff as a nice haddocked library with some examples
15:27:58 <dons> so people actually start playing with them (e.g. in here)
15:28:15 <dpiponi> dons: that means learning haddock!
15:28:27 <dons> oh, but its easy
15:28:30 <dons> !
15:28:31 * TuringTest goes to bed...
15:28:51 <dons> really, if you want people to appreciate comonads, we need a comonad lib as easy to get hold of as the arrows or mtl lib on hackage
15:29:02 <dons> but it needs a champion to pack things up together
15:29:04 <dons> and write docs
15:29:05 <Saizan> i've actually used the comonad for 2-dimensional cellular automata and got huge space leaks..
15:29:12 <dpiponi> dons: I'm guilty of not bothering to read up on darcs, cabal, haddock and all that stuff that makes people's lives easier!
15:29:25 <dons> Saizan: and things like that: profiling.
15:29:34 <dons> since its unlikely that untested code will be optimal ..
15:29:46 <dpiponi> Saizan: Do you know what causes the leaks? I find it very hard to reason about Haskell space usage.
15:29:55 <dons> dpiponi: hehe ok. but we have a complete tutorial on the tool chain
15:30:12 <Saizan> -hc pointed to the "right" function
15:30:47 <dons> dpiponi: re toolchain use, http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
15:30:49 <lambdabot> Title: How to write a Haskell program - HaskellWiki
15:31:06 * dons hints that its very satisfying to get 100s of people using your nice library..
15:31:11 <Saizan> the space usage was half when i translated from lists to Data.Sequence
15:31:28 <dpiponi> I'll check it out, maybe this weekend.
15:31:47 <sorear> dons: heh. I was ... the most suprised I'd been in years when someone actually bit the vty announce.
15:31:52 <dons> heh
15:31:58 <dpiponi> There are already some libraries. What's this: http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
15:32:41 <dons> right. even that should be packaged up . the comonad cadre needs to push things more!
15:33:26 <dpiponi> BTW I had this wacky idea about comonads...I'd like to bounce it off people to see if it sounds even vaguely plausible that it might work.
15:33:54 <xic> parsec should work on unicode strings, right?
15:34:20 <sorear> dpiponi: go ahead. I like wacky ideas.
15:34:36 <dpiponi> Zippers have semantics remarkably like C pointers. I was wondering if maybe it might be possible to somehow wrap (some) pointers in a Comonad
15:34:37 <dons> xic, it should, if you can get unicode string input to it
15:34:50 <xic> dons: yeah
15:34:53 <dons> xic, the problem will be doing IO that actually produces valid unicode
15:35:02 <dpiponi> An application would be, for example, the 2D cellular automata with a space leak.
15:35:03 <dons> (the libs exist, they're just not cleanly bundled atm)
15:35:31 <dons> ok i'm going to attempt to update lambdabot to ghc 6.6 now
15:35:46 <dons> so the bot might be a bit unstable as i change ghc's on that box
15:35:50 <dons> ?bot ok with you?
15:35:50 <lambdabot> :)
15:35:55 <dons> good enough for me
15:35:58 <xic> dons: well i use that infamous UTF8.lhs for reading utf8 from the network
15:36:00 <dpiponi> You wouldn't have to do all that back and forth zipper shuffling. You'd really have a pointer. And incrementing and decrementing it would call some C code that looks like --ptr or ++ptr
15:36:02 <xic> dons: seems to work
15:36:07 <dons> xic, oh great!
15:36:17 <dons> we should stick *that* in cabal then, if you found it easy enough to use
15:36:20 <Pseudonym> q+r)`div`t-10*n)l else g(q*k)((2*q+r)*l)(t*l)(k+1)((q*(7*k+2)+r*l)`div`(t*l))(l+
15:36:24 <dons> xic, want some mega karma points?
15:36:29 <xic> dons: always
15:36:45 <Pseudonym> q+r)`div`t-10*n)l else g(q*k)((2*q+r)*l)(t*l)(k+1)((q*(7*k+2)+r*l)`div`(t*l))(l+q+r)`div`t-10*n)l else g(q*k)((2*q+r)*l)(t*l)(k+1)((q*(7*k+2)+r*l)`div`(t*l))(l+2)in g 1 0 1 1 3 3
15:36:47 <dons> do you want to stick UTF8.lhs into a new darcs repo, add a .cabal file, and a README
15:36:49 <Pseudonym> Aargh.
15:36:53 <dons> i can give you hints and advice
15:37:01 <dons> (good chance to get semi famous in the community ... ;)
15:37:26 <xic> dons: i think it would be better to stick UTF8.lhs into ghc base :)
15:37:28 <bd_> dpiponi: It'd need to be pure; Data.Array.Diff may be more like it
15:38:23 <dons> xic, right. but first step is to get into into a separate package
15:38:24 <dpiponi> Yeah, an array would be fine too. The interface would look like a zipper but the underlying mechanism might be quite different.
15:38:42 <dons> so people can use it, improve it, and you get commuity consensus
15:39:23 <xic> dons: do you have a preference of where you'd want the darcs repos hosted?
15:40:16 <dons> well, no. i can host it if you need space.
15:40:23 <dons> or we could put it on darcs.haskell.org
15:40:31 <bd_> dpiponi: finite-length, I guess, then?
15:40:35 <bd_> [circular?]
15:40:49 <dons> the main thing though would be to rapidly (ie. within a week or so) get it tagged as unicode 0.1
15:40:52 <dons> and onto hackage
15:40:59 <dons> so people get a chance to use it and play with the interface
15:41:03 <dpiponi> Probably finite length.
15:41:04 <Mushy-pea> Just out of interest, what does lambdabot do?
15:41:09 <dons> > 1+2
15:41:17 <lambdabot>      Bad interface file: ShowQ.hi
15:41:17 <lambdabot>         mismatched interface file versions:...
15:41:17 <bd_> ... heh
15:41:18 <dons> well, when i'm not updating the bot ...
15:41:20 <dons> :)
15:41:31 <dpiponi> ...
15:41:35 <dons> i just reinstalled its compiler, so its going to be a little bit flakey for a few minutes till i sort out everything
15:41:38 <dons> ?list
15:41:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:41:42 <dpiponi> Where did my line of test go?
15:41:44 <dons> Mushy-pea: its a haskell ide ^^
15:41:50 <xic> dons: why the rush?
15:42:20 <dpiponi> Anyway, as I was trying to say: the application would be efficient arrays for things like ceullular automata and image processing, but still having an interface that's nicely functional
15:43:11 <sorear> MUAHAHAHA!!
15:43:18 <sorear> @version
15:43:18 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
15:43:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:43:20 <dons> xic, well, agile development practices, of course :-)
15:43:22 <Saizan> mmh, how will you let the function fetch the "neighbors"?
15:43:29 <dons> sorear: not there yet...
15:43:35 <dons> i just built ghc 6.6 first
15:43:43 <dons> now to rebuild all the deps
15:43:50 <xic> dons: ok. i guess i could host it on my website.... i'll have an answer for you if i am up to this task or not within 12 hours
15:43:54 <siti> that was fast :p
15:43:56 <bd_> dpiponi: hm, diff arrays actually might not be the best actually, seems like it might be O(n ^ 2)...
15:44:28 <bd_> seems useful though
15:44:37 <dpiponi> Zippers have semantics a lot like *, ++ and --. So you'd fetch neighbours through the Haskell equivalents
15:45:03 <dpiponi> (That's C's *, ++ and --)
15:45:04 <chessguy> 'evening haskellers
15:45:19 <augustss> evenin
15:45:29 <dons> hey augustss
15:45:39 <augustss> hey dons
15:49:18 <sorear> @ty const `asTypeOf` seq
15:49:21 <lambdabot> forall b. b -> b -> b
15:52:02 <Saizan> dpiponi: for high performance one should maybe use 2 mutable arrays, one for reading and one for writing the next state? and exchange the roles on the next =>>
15:52:51 <bd_> Saizan: What happens in the presence of sharing? :)
15:53:15 <dpiponi> I'm not even sure you need mutable arrays. I'm thinking of things like cellular automata where you operate on the entire grid.
15:54:20 <dpiponi> The comonad interface is basically about applying operations everywhere, not piecemeal. (I think.)
15:54:45 <bd_> right, you can just construct a new immutable array... but that may have an unacceptably high allocation rate, for large grids...
15:54:52 <Saizan> well for what i've experienced DiffUArrays are not very fast at this (though they resolve space leaks)
15:55:38 <bd_> right, diffarray access is O(number of updates since the older state)
15:55:52 <bd_> so changing everything with reference to the original state becomes O(n^2)
15:56:34 <Saizan> well, i'm collecting the list of changes to the next state and committing it only after
15:56:52 <dpiponi> bd_: Yeah, but you'd only be alocating a new grid each time you did a 'cobind' (or whatever you want to call it).
15:56:53 <Saizan> (if i've managed to not get tricked by lazy eval)
15:56:54 <bd_> ah
15:57:08 <bd_> Saizan: then you might as well just build a new strict array, right?
15:57:13 <dpiponi> bd_: when you do a cobind you usually want a new grid (I think)
15:57:31 <bd_> dpiponi: yeah, I'm just thinking if you do a `cobind` b `cobind` c `cobind` d it might be bad for performance
15:57:37 <bd_> though maybe clever rewrite rules can fix that
15:58:02 <dpiponi> I was hoping the earlier ones might quickly get garbage collected.
15:58:07 <Saizan> bd_: mmh, it could be
15:58:24 <dpiponi> I haven't really thought this through: I'm just brainstorming around the idea that a zipper looks like a pointer.
15:59:01 <Saizan> i thought the same for the list implementation..
15:59:05 <bd_> I think it's a useful idea, but the implementation /may/ be nontrivial (or it may not, who knows :)
15:59:32 * bd_ wonders how usefully those cobinds can be fused...
15:59:42 <dpiponi> I definitely think it's non-trivial
15:59:52 <Pseudonym> > let g q r t k n l=if 4*q+r-t<n*t then shows n.g(10*q)(10*(r-n*t))t k(10*(3*q+r)`div`t-10*n)l else g(q*k)((2*q+r)*l)(t*l)(k+1)((q*(7*k+2)+r*l)`div`(t*l))(l+2) in g 1 0 1 1 3 3""
15:59:54 <lambdabot>      Bad interface file: ShowQ.hi
15:59:54 <lambdabot>         mismatched interface file versions:...
16:00:00 <Pseudonym> Huh?
16:00:03 <Saizan> can they be fused at all?
16:00:16 <sorear> Pseudonym: talk to dons
16:00:20 <Pseudonym> @let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])
16:00:20 <lambdabot> L.hs:39:0:     Bad interface file: ShowQ.hi         mismatched interface file...
16:00:24 <sorear> Saizan:
16:00:24 <Pseudonym> Grrr.
16:00:34 <dons> not bot @eval for a few mins
16:00:36 <bd_> well, maybe it can rewrite a chain of cobinds into some unsafe* operations...
16:00:37 <dons> i'm updating to ghc 6.6
16:00:41 * sorear invokes the {-# RULES #-}
16:00:43 <dons> and rather than take the whole bot down
16:00:45 <Pseudonym> Ah, OK.
16:00:51 <Mushy-pea> I've been reading about the map function in a tutorial.  I was wondering, do lists have indicies?  So, can the position in a list be a parameter to the function you pass to map?
16:00:53 <dons> i just leave it up, in semi-broken (well, @eval won't work...)
16:01:06 <Pseudonym> Gotcha.
16:01:16 <sorear> dons: is @dynamic-reload ever going to be supported again?
16:01:20 <dons> on the plus side, lots of new features are about to land.
16:01:24 <dons> sorear: year
16:01:24 <bd_> a `cobind` f `cobind` g -> a `unsafeMutating` (unsafeMap f >> unsafeMap g) ? if f and g are (a -> a)
16:01:35 <dons> yarr
16:01:51 <bd_> where those unsafeMaps are messing with a mutable array in IO :)
16:01:55 <sorear> dons: is that a typoed "yea" or a shorthand "in a year" ?
16:02:09 <dons> no. it will be supported again. i'm not sure when. within a year though ;)
16:02:22 <sorear> hehehe.
16:02:22 <bd_> Mushy-pea: They don't have indices, but you can create a parameter if you want. use something like (zip [0..] yourList)
16:02:36 <sorear> by the way, just seen in #darcs:
16:02:39 <Mushy-pea> OK.
16:02:39 <sorear> @quote 1866
16:02:40 <lambdabot> xic says: and i imagine that lisp hasn't changed since it's creation in 1866
16:02:45 <dons> hehe
16:02:52 <dons> xic++ hehe
16:02:59 <edwinb> heh
16:03:32 <sorear> @ysers
16:03:32 <lambdabot> Maximum users seen in #haskell: 322, currently: 294 (91.3%), active: 48 (16.3%)
16:09:06 <dons> ok. hackage makes building lambdabot about 20x easier
16:09:06 <dons> yay for hackage
16:09:23 <dons> since i can find my zlib, binary and arrows pkgs with no fuss. now just need to get plugins and lambdabot itself up there....
16:09:35 <dons> this is so much better than the bad old days before cabal
16:09:48 <dons> when there were like 4 haskell libraries, and they all used incompatible Makefiles
16:09:55 <dpiponi> bd_: I wish I understood what that was you just said involving unsafeMutating!
16:10:48 <bd_> dpiponi: the idea is unsafeMutating :: FastComonad a -> FCMut a -> FastComonad a, where FCMut is a monad based on IO to mess with a mutable version of a
16:10:57 <bd_> actually I guess it's not really all that unsafe if you do it right
16:11:28 <bd_> anyway, the idea is it would unsafePerformIO, create a /mutable/ array, FCMut actions mutate this in some way, and then it'll unsafeFreeze it at the end to make it all pure
16:11:34 <Saizan> bd_: building a new UArray each time killed space usage down to 4mb (from 35mb)
16:11:44 <bd_> Saizan: vs diff arrays?
16:11:51 <Saizan> yeah
16:11:58 <bd_> diff arrays are not designed for 'let's mutate everything all at once!'
16:11:59 <bd_> :)
16:12:34 <Saizan> :)
16:12:51 <dons> IOUArray?
16:12:53 <dpiponi> Yup. By restricting people to the comonad interface you kinda force people to update entire arrays at a time.
16:12:55 <Saizan> hey, time was halfed
16:12:56 <dons> or just UArray (non mutable?)
16:13:02 <bd_> dons: or IOArray...
16:13:02 <Saizan> just UArray
16:13:11 <dons> so you copy?
16:13:21 <dons> (and that's ok?)
16:13:30 <Saizan> yeah i copy
16:13:33 <bd_> but the idea is to give an interface which lets you fuse cobinds into a single action which doesn't involve multiple copies - just one copy, and a series of mutations
16:14:04 <dons> yeah, fusion should give you the uniqueness there you need.
16:14:06 <bd_> hm, wait, that might not work
16:14:08 <Saizan> listArray bounds' (arrmap rule oldarray) -- something like this
16:14:16 <bd_> since it still needs the old version of its neighbors
16:14:24 <bd_> well it can alternate between two arrays anyway
16:14:27 <bd_> I wonder if it would be safe to fuse (a -> b) mappings with unsafeCoerce#...
16:15:12 <bd_> [if you could force them to be boxed somehow...]
16:15:35 <dpiponi> I see it's time to take off the protection and start indulging in some unsafe Haskell.
16:15:56 <dons> ?version
16:15:58 <sorear> > 2 ^ 2
16:16:04 <lambdabot> lambdabot 4p504, GHC 6.6 (OpenBSD i386)
16:16:10 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:16:12 * sorear claps
16:16:12 <lambdabot>  4
16:16:26 <dons> note that now with extended defaulting, you'll not need to type so many type sigs
16:16:27 <sorear> dons: don't worry, autojoin is filling the sendq
16:16:29 <dons> > reverse []
16:16:38 <lambdabot>  []
16:16:46 <bd_> dpiponi: Unsafe haskell is fun! :)
16:16:53 <dons> would normally require a type sig!
16:16:54 <dons> so that's new with ghc 6.6
16:17:02 <bd_> It's boring when you don't get segfaults >.>
16:17:02 <dons> also, we have lots of new libs visible in @eval
16:17:04 <bd_> > typeOf []
16:17:05 <lambdabot>  Add a type signature
16:17:07 <bd_> :t []
16:17:10 <lambdabot> forall a. [a]
16:17:12 <bd_> hm
16:17:15 <dons> the full arrows lib, and what else. Control.Applicative
16:17:16 <dons> and friends
16:17:22 <bd_> just polymorphic length then?
16:17:24 <sorear> > GHC.Prim.unsafeCoerce# 2#
16:17:25 <lambdabot>  Parse error
16:17:27 <sorear> aww
16:17:30 <dons> not that kind of thing ;)
16:17:33 <dpiponi> bd_: Maybe I should listen to my conscience. You're trying to corrupt me!
16:17:47 <dons> possibly some unsafe things. we'll need to check that. but should be ok
16:18:01 <sorear> > array (minBound :: Int, maxBound) [(2,'a')]
16:18:03 <dons> some other plugins might have broken in the update, so we'll see.
16:18:19 <sorear> > array (minBound :: Int, maxBound) [(0,'a')]
16:18:24 <bd_> dpiponi: It's all in the name of speed ;)
16:18:33 <sorear> > 'x'
16:18:35 <dons> I think its just ignoring you there sorear
16:18:35 <lambdabot>  'x'
16:18:53 <bd_> dpiponi: I'm sure you can fuse a sequence of cobinds without changing the type, the tricky bit is fusing it when the type's changing, while keeping reallocations to a minimum...
16:18:53 <Pseudonym> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in p 100
16:18:56 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
16:18:58 <Pseudonym> Woo.
16:19:08 <dpiponi> bd_: It's just that I spend my day writing unsafe C++ already
16:19:21 <dons> > C.pack "foo"
16:19:22 <lambdabot>   Not in scope: `C.pack'
16:19:25 <sorear> I should compress my theorem prover to below 512 chars
16:19:32 <sorear> then we won't need @djinn
16:19:45 <dons> > Sc.pack "foo"
16:19:46 <lambdabot>   Not in scope: `Sc.pack'
16:19:53 <dons> > SC.pack "foo"
16:19:55 <lambdabot>  "foo"
16:19:58 <dons> bytestrings!
16:20:08 <dons> (scary, I know.... ;)
16:20:10 <sorear> SC? what kind of abbreviation is that?
16:20:18 <bd_> :t SC.pack
16:20:21 <lambdabot> Couldn't find qualified module.
16:20:24 <sorear> every programmer I know uses B, L, B8
16:20:28 <bd_> > typeOf (SC.pack)
16:20:29 <sorear> and S
16:20:30 <lambdabot>  [Char] -> Data.ByteString.Base.ByteString
16:20:31 <dons> strict /strict char/ lazy /lazy char
16:20:38 <dons> so S, SC, L , LC
16:20:46 <dons> B8, never seen that
16:20:51 <sorear> what's Base imported as?
16:20:53 <sorear> what's Base imported as?
16:20:55 <sorear> :p
16:20:59 <dons> its not...
16:21:02 * ddarius uses BS
16:21:15 * sorear calls it BS
16:21:20 * ddarius has a wonderful monad: BSProcessor.
16:21:52 * sorear audits the 6.6 libs behind dons' back
16:21:53 * allbery_b thought that was more commonly known as javac
16:22:13 <Saizan> faster and less space consuming updates with immutable arrays.. that's kind of surprising..
16:22:19 <dons> so the new libs include qualified Data.Foldable, qualified Data.Sequence, Data.Fixed, Data.Traversable, Control.Paralell
16:23:00 <dons> ?uptime
16:23:00 <lambdabot> uptime: 7m 34s, longest uptime: 2d 17h 27m 21s
16:23:03 <dons> ?users
16:23:03 <lambdabot> Maximum users seen in #haskell: 322, currently: 292 (90.7%), active: 8 (2.7%)
16:23:53 <sorear> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `pseq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 20
16:23:55 <lambdabot>   Not in scope: `pseq'
16:24:18 <xic> is Debug.Trace thread safe? if not it's a big problem
16:24:19 <sorear>    pseq :: a -> b -> b
16:24:25 <sorear> ^^^ is that a 6.7 only thing?
16:24:36 <dons> hmm. maybe
16:24:41 <dons>  I think it might be exported as 'seq' ?
16:24:50 <dons> (rongly too)
16:24:53 <dons> w.
16:25:06 <dons> xic, thread safe. yes.
16:25:12 <sorear> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `par` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 20
16:25:14 <lambdabot>  /tmp/ghc31651_0/ghc31651_0.hc: In function `s36m_entry':
16:25:14 <lambdabot>  
16:25:14 <lambdabot> /tmp/ghc31651_0/gh...
16:25:19 <sorear> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 20
16:25:21 <lambdabot>  /tmp/ghc29195_0/ghc29195_0.hc: In function `s37c_0_alt':
16:25:21 <lambdabot>  
16:25:21 <lambdabot> /tmp/ghc29195_0/gh...
16:25:27 <sorear> Muahahaha!
16:25:27 <allbery_b> I have seq and par in Control.Parallel (6.6)
16:25:28 * dons tries this locally first
16:25:32 <allbery_b> per :browse
16:26:07 <sorear> dons: is runplugs using +RTS -N16 -RTS yet?
16:26:14 <dons>      warning: implicit declaration of function `newSpark'
16:26:18 <dons> is the error
16:26:22 <dons> now, I can fix that...
16:26:47 <sorear> so, now @run is 16x faster!
16:26:47 <dons> sorear: not yet.
16:26:53 <dons> not yet.
16:27:13 <dons> but soon
16:28:14 <sorear> dons: should we abandon RLIMIT_CPU?  3 CPU-seconds might only be 0.2 wall time
16:28:43 <dons> I guess we'll cross that bridge when we get there
16:29:05 <sorear> fine enough.
16:29:31 <hpaste>  Mushy-pea pasted "Simple program with a problem" at http://hpaste.org/483
16:29:49 <dons> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 20
16:29:51 <lambdabot>  10946
16:29:53 <dons> mwhahah!
16:30:25 <dons> the worlds first implicitly parallel irc-bot plugin
16:30:30 <siti> lol
16:30:45 <chessguy> Mushy-pea, what error are you getting?
16:30:47 <hpaste>  sorear annotated "Simple program with a problem" with "remove unsupported monadic tuple, fix i/t/e keyword" at http://hpaste.org/483#a1
16:31:22 <sorear> monadic tuples have nothing to do with monads, BTW
16:31:37 <Mushy-pea> Could someone take a look at this and tell me what I'm doing wrong?  Parse error: test.hs: 8: 3: parse error on input then
16:32:09 <allbery_b> Mushy-pea: sorear just beat you to it :)
16:32:10 <sorear> er, no, I made an unneeded correction
16:32:42 <TomMD> Does anyone here know why a recursive forkIO call will crash the program instead of throw an exception?
16:32:43 <sorear> the if/then/else/then was biting you, the monadic tuples thing is unneeded
16:32:54 <sorear> recursive forkIO ?!
16:33:06 <dons> TomMD: um, fork bomb? :-)
16:33:09 <TomMD> Browsing GHC source, it looks like the RTS was supposed to handle such a thing and throw an exception.
16:33:10 <sorear> TomMD: If it's true it's a GHC bug
16:33:17 <TomMD> dons: yes, fork bomb.
16:33:22 <dons> but yeah, check with the latest ghc
16:33:28 <dons> if it still crashes, file a bug
16:33:30 <TomMD> I'm using 6.7
16:33:33 <TomMD> roger
16:33:42 <dons> ah ok.
16:34:04 <dons> then yes, a simple test case, and a discussion of the expected result, filed here:
16:34:08 <chessguy> when you use bleeding-edge software, expect a little blood :)
16:34:10 <dons> ?bog <--
16:34:10 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:34:16 <dons> ?bug I mean ;)
16:34:17 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:34:24 <sjanssen> the bug bog
16:34:41 <dons> since I guess you want to be able to catch the inability tofork, and deal with that gracefully
16:34:58 <Mushy-pea> sorear: thanks.  I'll give that a try.
16:41:21 <chessguy> suppose i have a State A and a state B. Would it be preferable to use a StateT to combine these (is that even possible?), or have data C = C { a :: A, b :: B}, and State C ?
16:41:47 * allbery_b is reminded to see if 6.7 is still whingingabout StgTicky.h
16:42:00 * sorear tries to build 6.7
16:42:03 <allbery_b> chessguy: how closely are they related?
16:42:18 <chessguy> allbery_b, i don't have a particular instance necessarily in mind
16:42:22 <allbery_b> and I'd expect you could stack a StateT B on top of a State A (or vice versa), sure
16:42:37 <allbery_b> but it'd be slower if you were doing a lot of manipulation of both states
16:42:54 <augustss> chessguy: I'd just stick both of them in C
16:43:21 <chessguy> hm, ok
16:43:30 <mbishop> http://nlp.stanford.edu/links/statnlp.html
16:43:31 <lambdabot> Title: Statistical NLP / corpus-based computational linguistics resources
16:43:39 <allbery_b> I'm using State (well, StateT ... IO) with a record type, myself
16:43:49 <augustss> but there could be reasons to split them
16:43:58 <chessguy> augustss, like what?
16:44:17 <sorear> lambdabot uses StateT with a map of modules to existentially typed MVars
16:44:32 <augustss> if you have, say, a ListT between them so they behave different;y with respect to that transformer
16:44:50 <chessguy> huh?
16:45:19 <sorear> if I rebuild GHC6.7, how likely will I need to rebuild my libs?
16:45:21 <augustss> If you have both StateT and ListT you can combine the in two way.  They have differet behaviour
16:45:50 <augustss> chessguy: and sometimes you might want both behaviours.  It happened to me once
16:46:07 <chessguy> can you give me any more detail?
16:46:50 <augustss> say that you are using ListT to do backtracking.  You might want some state to reset when you backtrack, and some state to survive
16:47:17 <chessguy> ok
16:48:03 <chessguy> ?hoogle ListT
16:48:04 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
16:48:05 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
16:48:05 <lambdabot> Language.Haskell.TH.ListT :: Type
16:50:53 <allbery_b> hm.  wonder if I need to blow away my ghc6.7 and start over
16:51:03 <allbery_b> still getting the missing StgTicky.h error
16:51:13 <Mushy-pea> OK, I made the changes: http://hpaste.org/483#a1 .  But now I get: 10:0: parse error on input module
16:51:24 <augustss> allbery_b: do a 'make distclean'
16:51:41 <sorear> dons: ooh, lambdabot is using -fasm now?  any reason beyone performance?
16:51:49 <chessguy> Mushy-pea, you can't have two modules in the same file
16:51:58 <sorear> dons: dumb me.  newSpark I guess :)
16:52:16 <allbery_b> yeh, just did a grep and found a comment about it going away and references only in depends
16:52:17 <augustss> chessguy: none of the implementations allows that, afaik
16:52:29 * allbery_b updates his auto-update-and-rebuil;d script
16:52:32 <dons> sorear: newSpark :-)
16:52:33 <chessguy> augustss, allows what?
16:52:37 <dons> also, why not eh?
16:52:52 <augustss> chessguy: multiple modules per file
16:52:58 <chessguy> augustss, ...
16:53:03 <chessguy> isn't that what i just said?
16:53:30 <augustss> chessguy: yes, but it's an implementation restriction, not a language restriction
16:53:39 <chessguy> so?
16:53:42 <chessguy> he still can't do it ;)
16:54:00 <augustss> very true
16:55:01 * sorear prepares to upload the final vty-3.0.0
16:55:26 <Mushy-pea> OK, It works now.  Put it all in module Main.
16:55:41 <dons> sorear: ok. sounds good.
16:55:48 <dons> you need help getting it into hackage before the announce?
16:56:04 <Mushy-pea> Thanks guys.
16:56:18 * Mushy-pea goes to bed zzzz....
16:57:09 <chessguy> @quote sleep
16:57:10 <lambdabot> StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
16:57:12 <augustss> hackage.haskell.org seems half dead
16:57:47 <sorear> heh.
16:58:02 <sorear> too bad that won't show up on @quote sorear *hint hint*
16:58:26 <chessguy> @quote sorear StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
16:58:27 <lambdabot> No quotes match. Where did you learn to type?
16:58:29 <chessguy> says who?
16:58:30 <chessguy> whoops
16:58:37 <chessguy> @remember sorear StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
16:58:38 <lambdabot> Done.
16:59:39 <augustss> @pl seq (\ x -> undefined x) 0
16:59:39 <lambdabot> seq undefined 0
16:59:43 <augustss> well, well
17:00:07 <sorear> augustss: come on.  lambdabot has broken semantics for YEARS.
17:00:22 <augustss> :)
17:00:32 <jcreigh> @quote courage to implement
17:00:33 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
17:00:34 <sorear> @pl let a x = 2 in (a 0 :: Int, a 0 :: Double)
17:00:35 <lambdabot> (2 :: Int, 2 :: Double)
17:00:50 <sorear> well, that didn't quite work
17:01:04 <chessguy> @quote courage
17:01:04 <lambdabot> shapr says: I encourage my competitors to use Windows.
17:01:09 <jcreigh> hmm...what's with the '@remember <nick> <real name> says:" thing?
17:01:09 <dons> augustss: half dead, how so?
17:01:12 <sorear> but anyways @pl desugars lets into lambdas internally
17:01:25 <sorear> @quote courage.to
17:01:26 <lambdabot> sorear says: StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
17:01:27 <bd_> jcreigh: quote database
17:01:32 <augustss> dons: There was an error: user error (Could not find module `Distribution.ParseUtils':...
17:02:37 <dons> your cabal is too old, I think?
17:02:55 <dons> you need a reasonable cabal, then everything should just work
17:03:07 <dons> Cabal-1.1.7 seems to work fine
17:03:09 <sorear> hmm.  when was StefanO'Rear quoted?  I can't find it in the clogs
17:03:11 <augustss> my cabal?  it's using my cabal when I go to the web page?
17:03:20 <jcreigh> bd_: right, sorry. I was wondering if saying "StefanO'Rear says" would make lambdabot say "StefanO'Read says:" instead of "sorear says". Obviously not.
17:03:22 <dons> um, hmm. you mean, the web site reported that error?
17:03:27 <augustss> yes
17:03:31 <dons> urgh
17:03:34 <dons> ok. sounds like something broke
17:03:47 <dons> maybe Ross is fiddling with things
17:03:58 <dons> what were you doing?
17:04:09 <allbery_b> I vaguely recall when that was @remember-ed, from a -cafe email
17:04:19 <chessguy> sorear, perhaps on cafe?
17:04:42 <augustss> dons: I entered the URL http://hackage.haskell.org/
17:04:43 <lambdabot> Title: HackageDB: introduction
17:04:44 <allbery_b> someone was asking about pointfree code
17:04:44 <xic> hm... my parsec parser gives very bad error messages
17:04:47 <augustss> dons: but it's back now
17:05:04 <allbery_b> or maybe that was the core thread
17:05:10 <dons> ok. I suspect Ross was rebuilding something
17:05:52 <sorear> chessguy, allbery_b: I remember writing it.  I just don't remember the @remember.
17:06:11 <allbery_b> I saw it go by a few days ago, but don't recall exactly when
17:06:19 <allbery_b> (the @remember here, that is)
17:06:49 <chessguy> i remember remembering the @remember, but now i've forgotten it
17:07:23 <ddarius> wtf am I doing?
17:07:34 * ddarius goes to gets an email client.
17:07:54 <allbery_b> hm, maybe it ws in -blah or -overflow though
17:08:08 <allbery_b> if it was it's gone past by scrollback limit
17:08:45 <mbishop> http://hemalathag.blogspot.com/2005/12/collection-of-good-technical-websites.html
17:08:48 <lambdabot> Title: Hema, http://tinyurl.com/2d546a
17:08:49 <mbishop> that's a pretty big collection
17:11:54 <sorear> what's a good rule of thumb for how often to darcs optimize --checkpoint?
17:16:16 <sorear> dons: http://members.cox.net/stefanor/vty ; http://members.cox.net/stefanor/vty/dist/doc ; http://members.cox.net/stefanor/vty/dist/vty-3.0.0.tar.gz
17:16:18 <lambdabot> Title: Directory listing
17:18:49 <ddarius> "When our safe strings have finally reached their ultimate, beautiful state, we can render them into regular strings and pass them bravely into the cruel outside world â where, most likely, somebody elseâs broken code will screw them up anyway. But at least we tried."
17:27:34 <dons> sorear: ok. i'll upload the tarball to hackage?
17:28:36 <dons> checking it builds...
17:28:36 <dons>     
17:28:40 <dons> /tmp/ghc22454_0/ghc22454_0.hc:6:20:
17:28:40 <dons>      gwinsz.h: No such file or directory
17:28:55 <dons> can i send you a patch.
17:28:58 * dons does so
17:29:14 <sorear> "that's odd"
17:29:34 <sorear> It SHOULD have a proper include in the cabal file
17:30:45 <gotaku> Is there no way to tell by a glance what monad a function is working with if there is no type signature?
17:30:56 <sorear> :t foobar
17:30:58 <sorear> :p
17:30:59 <lambdabot> Not in scope: `foobar'
17:31:11 <sorear> or C-c C-t, your choice
17:31:18 <dons> yeah, ask the typechecker, gotaku
17:31:23 <dons>  
17:31:27 <dons> it always knows
17:32:25 <gotaku> I think haskell needs a real IDE with an integrated type checker where you can just mouse over things.
17:32:49 <emu> you can sort-of get that with emacs haskell-mode
17:33:22 <emu> at least the changes i sent to cvs will remember types and redisplay them in the minibuffer
17:33:25 <chessguy> hey sorear, question for you
17:33:26 <siti> well emacs is well umm yeah...
17:33:30 <sorear> yes?
17:33:31 <dons> sorear: hmm. the darcs repo builds fine. the vty 3.0.0 snapshot fails
17:33:40 <sorear> double funny
17:33:51 <dons> did you miss a file in cabal dist?
17:33:52 <sorear> maybe cabal sdist borked
17:33:58 <dons> yeah. try darcs dist
17:33:59 <dons> ..
17:34:03 <chessguy> i'm trying to remember something you said the other day. something about monad transformers not being necessary until a program gets large, like the size of lambdabot?
17:34:54 <jz87> Could not find module `Outputable':
17:34:54 <jz87>       it is a member of package ghc-6.6, which is hidden
17:34:58 <jz87> what does this error mean?
17:35:19 <dons> you're trying to use the ghc-api ?
17:35:22 <jz87> yes
17:35:23 <sorear> you're trying to use the GHC-api ?
17:35:26 <dons> and it is hidden for some reason
17:35:37 <dons> can you add --make or -package ghc to your command line flags?
17:35:42 <sorear> jz87: add 'Build-depends: ghc' to your cabal file
17:35:55 <jz87> well I'm running this in ghci
17:36:20 <dons> -package ghc on the command line, then, I think
17:36:23 <jz87> ok
17:36:44 <jz87> I see, now it works
17:36:47 <sorear> dons: is it too late to unrecord rel-3.0.0 ?
17:36:53 <chessguy> sorear, do you remember saying that?
17:36:55 <dons> no.
17:36:55 <jz87> what does it mean though when something is hidden?
17:37:02 <dons> sorear: i've got another patch for you, btw.
17:37:32 <dons> sorear: http://www.cse.unsw.edu.au/~dons/tmp/cbits.patch
17:37:47 <dons> (cbits is more idiomatic)
17:37:58 <sorear> chessguy: yes
17:38:23 <chessguy> i'm trying to come to grips with that statement. why is that?
17:39:19 <sorear> monad transformers contain large amounts of structured state, but they are just a nuisance in small programs.
17:40:08 <reilly> anybody willing to take a look at a problem I'm having with Data.Binary?
17:40:12 <sorear> yes
17:40:16 <jz87> oh yeah, dons
17:40:17 <gotaku> Should recursive functions always be tail recursive?
17:40:20 <jz87> I've been meaning to ask you
17:40:22 <hpaste>  reilly pasted "Problem with Data.Binary" at http://hpaste.org/484
17:40:33 <chessguy> hmm. even using the technique cale described in his transformer tutorial?
17:40:34 <chessguy> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
17:40:35 <ddarius> gotaku: No
17:40:38 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
17:41:04 <jz87> I tried to install Yi
17:41:08 <jz87> it says I need vty
17:41:13 <sorear> @where vty
17:41:14 <lambdabot> http://members.cox.net/stefanor/vty/
17:41:16 <jz87> but then vty needs unix-any
17:41:18 <sorear> but don't do it now
17:41:27 <jz87> I'm trying to install this on windows
17:41:27 <sorear> jz87: that's in extralibs
17:41:41 <sorear> jz87: use the gtk version
17:41:48 <sorear> cd gtk
17:42:00 <jz87> gtk version of Yi?
17:42:06 <sorear> yes :)
17:42:12 <jz87> where do I download it?
17:42:18 <jz87> I just downloaded the darcs one
17:42:34 <gotaku> ddarius: Why?
17:42:50 <chessguy> jz87, the darcs one has a directory called gtk
17:43:04 <jz87> ok
17:43:14 <gotaku> Why is Yi different then just a text editor?
17:43:16 <jz87> so I just run setup from that subdir?
17:43:20 <chessguy> yes
17:43:41 <jz87> isn't yi supposed to be like emacs but scriptable in haskell?
17:43:47 <ddarius> gotaku: Not all recursive functions are tail-recursive.  Not all patterns of recursion are loops.  Two examples: tree recursion and foldr
17:43:51 <sorear> jz87: same repo - just cd gtk before configuring
17:44:53 <jz87> I need gtk2hs?
17:46:15 <bla123> how do i parse optional words (like in "A ::= b? c") with parsec?
17:48:57 <sorear> gotaku: tail recursion interacts badly with laziness
17:48:57 <sorear> @bot
17:48:58 <lambdabot> :)
17:48:59 <sorear> @bah
17:49:00 <lambdabot> Maybe you meant: bf bug faq map
17:49:28 <sorear> jz87: yes, that's the only haskell gtk binding ;)
17:49:33 <sorear> modern
17:49:51 <emu> bla123: take a look at 'option'
17:49:59 <glguy> and 'optional'
17:52:26 <jz87> it won't start
17:52:36 <gotaku> I'm having trouble trying to build up a string with recursion inside a State monad...
17:52:53 <jz87> it gives me a Core.startE mkstemp filed
17:52:55 <jz87> failed
17:52:56 <jz87> error
17:53:20 <chessguy> @faq
17:53:21 <lambdabot> The answer is: Yes! Haskell can do that.
17:53:23 <beschmi> sorear: cool, yi already has better haskell syntax highlighting than emacs (doesn't consider the rest of buffer as string if you type the starting ")
17:53:36 <beschmi> *of the buffer
17:53:48 <bla123> glguy: i only found "option" in the reference manual but not "optional"
17:54:00 <jz87> yeah, I've been trying to work with yi
17:54:08 <jz87> but the setup is just hard for some reason
17:54:14 <jz87> I've been trying to setup up yi for months
17:54:20 <Saizan> ?where yi
17:54:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:54:24 <jz87> and haven't managed to get it working on any machine
17:54:32 <jz87> I have tried windows, linux and os x
17:55:14 <beschmi> jz87: just compiled the newest vty and yi from darcs on ubuntu without any problems
17:55:34 <jz87> I'm trying to run yi-gtk right now under windows
17:55:35 <glguy> optional :: GenParser tok st a -> GenParser tok st ()
17:55:40 <glguy> option :: a -> GenParser tok st a -> GenParser tok st a
17:55:43 <jz87> installed gtk 2.10
17:55:51 <jz87> with gtk2hs (the latest build)
17:55:59 <jz87> compiled yi
17:56:04 <jz87> and it won't start
17:56:20 <jz87> it gives me a core.startE mkstemp failed
17:56:29 <jz87> which isn't very helpful
17:56:48 <beschmi> jz87: oh, i didn't try the gtk version
17:57:02 <jz87> is there something with windows
17:57:05 <jz87> that make it not work?
17:57:17 <jz87> should I reboot in linux to try it again?
17:58:38 <sorear> dons: I've fixed both issues and moved the tag, you can try again now
17:58:48 <bla123> glguy: the docs i looked at seem to be out of date, but now i found it on haskell.org, thanks a lot
18:00:42 <dons> sorear: tarball url?
18:00:48 <sorear> dons: same
18:01:07 <sorear> http://members.cox.net/stefanor/vty/dist/vty-3.0.0.tar.gz
18:01:25 <sorear> I moved the tag ... I hope that won't be a problem
18:01:38 <jz87> haskell can really use an ide with integration with lambdabot and code completion
18:02:05 <sorear> we have it
18:02:13 <sorear> emacs + erc + shim
18:02:15 <gotaku> How can I make a random string while using a State to thread the StdGen?
18:02:41 <sorear> QuickCheck has code for generating random strings
18:02:45 <jz87> what's erc?
18:02:49 <jz87> and what's shim?
18:03:00 <Nafai> ?where shim
18:03:01 <lambdabot> http://shim.haskellco.de/trac/shim
18:03:11 <mbishop> erc is an irc client
18:03:15 <sorear> in emacs
18:03:28 * mbishop nods
18:03:47 <jz87> well I was thinking more along the lines of integrating lambdabot with parsing
18:04:00 <jz87> to display inline type help
18:04:22 <jz87> is lambdabot using GHI api for the typing?
18:04:30 <chessguy> so, i'm starting to get the concept of monads (have been "starting" for months), but i'm not sure how to use them to structure my programs
18:05:24 <sorear> jz87: no, lambdabot uses good ol UNIX pipes
18:05:34 <xic> chessguy: what program are you making?
18:05:36 <sorear> echo ':t foo' | ghci -v0
18:05:50 <jz87> oh
18:05:52 <sjanssen> and some crufty regexes
18:06:05 <dons> sorear: can you check the tarball again,
18:06:09 <chessguy> xic, well, i'd like to learn general principles. but right now i'm specifically thinking about how to design a framework for genetic programming
18:06:11 <sorear> @t (undefined :: Int, undefined :: Integer)
18:06:12 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
18:06:12 <dons> [3 of 4] Compiling Graphics.Vty.Cursor ( Graphics/Vty/Cursor.hs, /usr/obj/cabal/Graphics/Vty/Cursor.o )
18:06:15 <dons> /tmp/ghc15519_0/ghc15519_0.hc:7:20:
18:06:16 <sorear> @ty (undefined :: Int, undefined :: Integer)
18:06:18 <dons>      gwinsz.h: No such file or directory
18:06:19 <lambdabot> (Int, Integer)
18:06:20 <dons>  
18:06:23 <dons>   
18:06:24 <sorear> ooh!
18:06:30 <dons> does the tarball build for you?
18:06:45 <dons> or can you darcs dist -d vty-3.0.0 and try that?
18:06:52 <jz87> does shim rely on unix?
18:07:02 <Saizan> mf <- mkstemp "/tmp/yi.XXXXXXXXXX" <-- hardcoded unix-style path are not good for portability :)
18:07:13 <sorear> dons: my tarball has the files...
18:07:36 <sorear> testing 6.7 build
18:08:19 <beschmi> jz87: i think newsham tracked down some unixisms, but i'm not sure how far he got
18:08:25 <xic> chessguy: i suggest you just start writing your program then without monads. you'll know you want a monad when in some places you end up threading state through a bunch of functions, or when you end up threading errors, or when you end up threading results, or when you end up threading anything :)
18:08:26 <sorear> 6.7 tarball build sucessfull
18:08:59 <xic> a :: A -> B -> C         b :: C -> D           how can i combine these to get c :: A -> B -> D   ?
18:09:00 <jz87> ok, I'm going to reboot in linux
18:09:02 <jz87> and try this again
18:09:21 <sorear> @pl \a b -> g (f a b)
18:09:22 <lambdabot> (g .) . f
18:09:25 <sorear> xic: ^^
18:09:40 <sorear> actually that's fairly idiomatic for @pl output
18:09:47 <dons> sorear: ghc 6.6 ?
18:09:53 <sorear> 6.6 tarball build FAILED
18:09:58 <dons> ah ok.
18:10:04 <dons> cabal's fault, or yours?
18:10:21 <gotaku> Anyone?
18:10:31 <dons> hmm, Include-Dirs:        . looks a bit dodgy
18:11:04 <dons> i have
18:11:04 <dons> include-dirs:        cbits
18:11:04 <dons> c-sources:           cbits/fpstring.c
18:11:04 <dons> in fps.
18:11:04 <dons> which works fine.
18:11:22 * xic wonders if there is a nice way to write (g .) . f
18:11:31 <allbery_b> gotaku: I don't understand the question
18:12:04 <allbery_b> xic: g (f a b)?
18:12:05 <dons> xic, yeah, dot = (.) . (.)
18:12:05 <dons> g `dot` f
18:14:06 <xic> dons: dot should be in Prelude :)
18:18:00 <chessguy> ?type ((.) . (.))
18:18:02 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:18:02 <Saulzar> Could have a whole family of `dot` 's with a typeclass, for  (b -> c) -> (x1 -> x2 .. xn -> a) -> x1 -> x2 ... xn -> c, hmm - if that works :)
18:18:39 <chessguy> > ((.) . (.)) (*2) (+) 2 3
18:18:41 <lambdabot>  10
18:19:35 <Saulzar> Hmm, then again .. is that covered by fmap already?
18:20:02 <Saulzar> > let f = fmap (*2) (+) in f 1 1
18:20:03 <lambdabot>   add an instance declaration for (Num (a -> a))
18:20:24 <Cale> fmap = (.)
18:20:34 <Cale> > (fmap . fmap) (*2) (+) 2 3
18:20:36 <lambdabot>  10
18:20:51 <allbery_b> :t fmap fmap fmap
18:20:52 <Cale> > (fmap fmap fmap) (*2) (+) 2 3
18:20:55 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:20:55 <lambdabot>  10
18:21:09 <Cale> hehe
18:21:24 <Cale> > ((.) (.) (.)) (*2) (+) 2 3
18:21:25 <lambdabot>  10
18:21:37 <sorear> [1]+  Done                    make >&make.log  (wd: /usr/local/src/ghcbuild)
18:21:38 <bd_> :t ((.)(.)(.))
18:21:41 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:21:45 <sorear> yay!
18:21:46 <Saulzar> Oh I see, you can't have instances for a -> b  and a -> b -> c, as they're overlapping..
18:22:09 <bd_> -fallow-incoherent-instances to the rescue(?)!
18:22:23 <Cale> You kind of have to allow overlapping instances to get most of the typeclass swindling to work.
18:22:38 <sorear> -fallow-idiotic-instances FTW!!
18:22:40 <chessguy> Saulzar, right, that would force the argument to the first function to be the same type as the first argument to the second function, and so on
18:22:54 <chessguy> you could do it, but you would be restricting the type
18:23:50 <sorear> make install finished
18:24:04 <Cale> Throw enough olegs at it, and it'll work.
18:24:39 <chessguy> hey Cale, question about your monad transformer article
18:24:42 <Cale> sure
18:25:03 <mbishop> It's cold in my room
18:25:06 <mbishop> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/6154282c209d2f7f/d3137d088adcc07f#d3137d088adcc07f
18:25:06 <chessguy> you suggest a process at the end, is that a process for applying monad transformers, or a general design process?
18:25:10 <mbishop> that should warm me up :/
18:25:12 <lambdabot> Title: ML vs. Lisp - comp.lang.functional | Google Groups, http://tinyurl.com/yu4vzk
18:25:39 <Cale> Let me look...
18:25:54 <Cale> oh, that's the process that you generally carry out.
18:26:03 <allbery_b> mbishop: bah, just build ghc from source on all available machines
18:26:05 <allbery_b> :)
18:26:06 <sorear>     Not in scope: type constructor or class `DocOption'
18:26:08 <Cale> When using monad transformers to construct a monad.
18:26:23 <Cale> It's a design pattern, which means that it'll probably someday be a language feature.
18:26:25 <sorear> mbishop: JHC is better
18:26:31 <chessguy> ok
18:26:37 <sorear> mbishop: JHC actually blew my CPU temp alarm
18:26:56 <sorear> (rather, using JHC to compile base did)
18:27:04 <chessguy> can you suggest a general thought process for modularizing a program design into monads and transformers?
18:27:16 <sorear> anyway ... ^^^ anyone get haddock-ghc working?
18:27:36 <allbery_b> 1. mindmeld with the Simons :)
18:27:37 <Cale> Well, that's kind of tricky -- what you're really doing when you're creating monads is creating (usually small) programming languages.
18:27:41 <chessguy> e.g., for OOP, you would think about nouns and implement them as classes. that's one simple way of thinking
18:27:51 <Cale> Very domain-specific languages, generally.
18:28:16 <Cale> So you look at your problem, and you have to think to yourself "what would be the ideal programming language to solve this in?"
18:28:18 <sorear> @users
18:28:19 <lambdabot> Maximum users seen in #haskell: 322, currently: 296 (91.9%), active: 27 (9.1%)
18:28:53 <Cale> It's kind of tricky, isn't it? :) But that's basically what combinator libraries are, and monadic libraries are a kind of those.
18:29:32 <Cale> If you manage, then the solution you get is usually really nice and flexible, but it can take a bit of reflection and insight into your problem domain.
18:30:16 <sorear> dons: gak, it's still not working
18:30:31 <chessguy> hmm, ok. i was kind of thinking in the right direction then
18:30:37 <Cale> Parsec is a good example -- it's not so hard to write parsers by hand, but doing so gives you inflexible code.
18:30:59 <Cale> It's much simpler to modify a parsec parser than to modify something handwritten.
18:30:59 <chessguy> i want to design a framework, and i started by thinking about how i would want to write the code that would make use of the framework
18:31:49 <dons> sorear: find otu with -v4 why ghc isn't getting the flag tothe linker
18:31:56 <dons> or to gcc, I mean
18:34:06 <Cale> The essense of functional programming is simplifying the construction of domain specific languages, building, and then using those languages to solve problems. Monads are a tool to standardise many common parts of those domain specific languages.
18:34:23 <sorear> dons: it doesn't even mention cbits/gwinsz.h in Graphics/Vty/Types.hs - why is GCC trying to find it?
18:34:27 <sorear> install-includes?
18:34:36 <Cale> Monad transformers are a tool to simplify the construction of monads.
18:34:54 * sorear re-re-reads the Cabal manual
18:35:29 <sm> are monads used like aspects ? AOP that really works ?
18:36:00 <mightybyte> So does re-re-reads have the same meaning as re-(re-reads)? :)
18:36:09 <Cale> sm: hmm, sort of.
18:36:29 <dons> sorear: can you {-# OPTION -#include "gwinsz.h" #-}
18:36:30 <chessguy> Cale, so you're suggesting a bottom-up approach to problem-solving?
18:36:51 <dons> sorear: eg. like {-# OPTIONS -#include "YiUtils.h" #-}
18:37:00 * sm has been practicing that bottom up approach.. it's fun
18:37:06 <sm> practising.. one of those
18:37:10 <sorear> dons: it builds now, fixing a misunderstanding of the install-includes facility
18:37:20 <mbishop> @spell practicing
18:37:21 <lambdabot> practicing
18:37:23 <sorear> (would a pragma be Better?)
18:37:30 <antoine> I've got a question on haskell syntax:  is there a way to express a list across multiple line?
18:37:30 <Cale> chessguy: Well, yes -- you're creating these nice languages in which it's easy to solve lots of problems, rather than decomposing a problem into small bits, and solving each of those separately.
18:37:41 <sorear> antoine: yes
18:37:42 <Cale> antoine: certainly.
18:37:49 <antoine> good!  ^_^
18:37:51 <antoine> any tips?
18:37:53 <sorear> foo = [1, 3, 4, 4,
18:37:58 <sorear> 8, 10, 17]
18:38:03 <Cale> antoine: It's possible to break any line in two. Simply indent the second line further than the first.
18:38:14 <sorear>   testing
18:38:14 <chessguy> Cale, so i need to think about the basic building blocks of my problem
18:38:18 <Cale> (or the same level)
18:38:18 <chessguy> first
18:38:21 <sorear>  testing
18:38:22 <antoine> hmm ... I thought I tried that.  maybe it wasn't indent dar enough
18:38:24 <Cale> chessguy: yeah
18:38:41 <sorear> hmm, erc doesn't eat leading space ... typo then
18:39:47 <Cale> antoine: yeah, where the indentation level starts is something that takes a little getting used to. Remember that the next non-whitespace character after {let, where, of, do} sets the current level.
18:41:03 <Cale> You have to be careful about things indented to the same level -- in some contexts, this inserts a semicolon between them, so it's a good idea to avoid that when you really want nesting.
18:42:18 <Cale> The golden rule of indentation is that if something is inside or part of something else, it should be indented more.
18:43:07 <cod3po37> I'm thinking about a Haskell version of iCommand or ruby-nxt for the Lego Mindstorms NXT brick. Now, I don't actually have one yet so this is a sort of still germinating idea. Looking at the ruby version, some sort of serial port library is being used to communicate over Bluetooth. For example,
18:43:32 <Cale> cod3po37: Your line ended "For example,", in case it got cut off.
18:43:51 <cod3po37> ...it so much a cut off as a RETURN error ;) @tty = SerialPort.new("/dev/tty.NXT-B", 57600, 8, 1, SerialPort::NONE)
18:44:08 <cod3po37> does Haskell have a serial package?
18:44:16 <chessguy> heh. it got cut off before the "cut off" :)
18:44:42 <sorear> cod3po37: writeFile "/dev/ttyS0" "foobar"
18:44:44 <sorear> unix++
18:44:50 <Cale> cod3po37: I don't think there's anything specific. I'd probably just talk to /dev/ttySn directly, but I'm a linux user :)
18:45:09 <monstre> Has anyone read Graham Hutton's book: "Programming in Haskell"?
18:45:14 <Cale> What to do on Windows is a good question though.
18:45:17 <sorear> dons: try again :)
18:45:28 <cod3po37> yeah, I'm on OS X. I'm just curious why the developer of ruby-nxt didn't do that...perhaps the Windows is the reason.
18:45:30 <allbery_b> well, serial libraries are useful for setting speeds, etc. --- in particular doing the clocal foo
18:45:42 <Cale> monstre: nope, but it looks like it might be good.
18:45:42 <mbishop> cod3po37: you might want to check out LiNXT too, it's perl, but might give you some ideas
18:45:43 <sorear> allbery_b: termios?
18:45:45 <chessguy> ugh. haskell books are a sore topic for me right now. i'm *still* waiting for the two books i ordered weeks ago
18:46:01 <sorear> stty!
18:46:02 <allbery_b> sorear: yes, but may also do some usb stack trickery in this case
18:46:05 <Cale> chessguy: who'd you order them from?
18:46:15 <chessguy> amazon
18:46:21 <cod3po37> okay, thanks.
18:46:23 <beschmi> shim has support for showing the type of the identifier under the cursor now. (return 'a') ++ [] shows the right type for return now
18:46:35 <sorear> beschmi: Yay!
18:46:41 <sorear> beschmi++
18:46:44 <Cale> Hmm. My amazon delivery was surprisingly fast.
18:46:55 <allbery_b> termios can do it, sure, but people tend not to understand what they're doing and it *is* a little finicky, so hiding details in a library can be a good thing evne on unix
18:46:57 <mbishop> amazon is quite fast
18:46:59 <chessguy> i've never had trouble with amazon before
18:47:10 <sorear> dons: poke, you may try again now
18:47:14 <sorear> hello michaelw
18:47:18 <chessguy> the only thing i can figure is they don't have haskell books in stock much
18:47:19 <sorear> er micahcowan
18:47:32 <beschmi> JaffaCake++
18:47:34 <micahcowan> hi sorear :)
18:47:51 <beschmi> sorear: it was already in vshaskell ;)
18:48:25 <Cale> New Haskell user?
18:49:10 <chessguy> fresh meat? where?
18:49:49 <Saizan> is there some nearly plain format for video? like pbm for images..
18:49:56 <Pseudonym> Yes.  mpeg
18:50:00 <Pseudonym> Oh.
18:50:02 <Pseudonym> No, plain.
18:50:05 <Pseudonym> Uncompressed AVI.
18:50:09 <Cale> Hehe, I just haven't seen micahcowan before, I don't think
18:50:11 <micahcowan> Who me? Not yet. Hopefully before too long. :)
18:50:18 <Cale> ah, :)
18:50:27 <chessguy> @users
18:50:28 <lambdabot> Maximum users seen in #haskell: 322, currently: 295 (91.6%), active: 32 (10.8%)
18:50:29 <Cale> Let us know if you have any questions
18:50:30 <micahcowan> Just came here to lurk, but sorear never lets me just lurk :)
18:50:36 <Pseudonym> It's not great, but it's the closest.
18:50:36 <Cale> hehe
18:50:40 <Pseudonym> LOL
18:50:48 <Pseudonym> That's it, you'll have to join in now.
18:50:57 <Cale> I lurked for the first couple months, stealing other people's homework to do for myself :)
18:51:13 <Pseudonym> Cale: And now you know exactly where the "any" key is!
18:51:17 <aFlag> hey, how do I statically link ghc generated binaries on windows? I've tried -optl-static, but it doesn't seem to work
18:52:14 <Cale> Pseudonym: Yes! I used xmodmap to bind one.
18:52:39 <sorear> loadkeys is better :p
18:53:45 <allbery_b> hm, I thought things were lays linked statically on Windows
18:53:55 <allbery_b> ...well, not to the system libs, but you can't really get around that
18:54:05 <allbery_b> I don't think most of those *exist* in static form
18:54:11 <dons> sorear: url, i'm too lazy to scroll back
18:54:27 <allbery_b> (or if they do you need to buy some expensive deluxe development package to get them)
18:54:39 <sorear> http://members.cox.net/stefanor/vty/dist/vty-3.0.0.tar.gz
18:54:50 <aFlag> hum, I wanted glut32.dll to be statically linked, would that be a system lib?
18:55:30 <allbery_b> in the sense of "provided with Windows", yes,  think so
18:56:52 <allbery_b> hm, no, not provided with Windows.  but only provided in .dll form, not .lib
18:57:09 <allbery_b> provided with various drivers and other packages
18:57:43 <dons> sorear: builds!
18:57:57 <dons> i'll check against yi
18:58:04 <allbery_b> so, absent a .lib version of it, you can't link it statically
18:58:14 <sorear> dons: 6.7, 6.6, and with *gr* *gr* *gr* simple modifications 6.4.2
18:58:26 <dons> shrug. no one has 6.4.2 any more ;)
18:58:33 <aFlag> hm, I was under the impression it would be possible because there's a libglut32.a on ghc's gcc-lib
18:58:45 <Nafai> I guess I must be no one.
18:58:55 <aFlag> but none of my effords work :(
18:58:59 <Cale> dons: All the Ubuntu users do.
18:59:03 <sorear> Nafai: I'm no one too!
18:59:07 <Cale> dons: Very unfortunately.
18:59:13 <sorear> we're all nobody!
18:59:21 <sorear> we're all the same!?
18:59:21 <dons> yi builds
18:59:28 <Nafai> I'm not quite ready to jump to Feisty
18:59:31 <sorear> yay!
18:59:39 <dons> sorear: how do I turn syntax on?
18:59:42 <dons> its not :syntax on ?
18:59:43 <Cale> dons: I think the GHC release cycle and Ubuntu release cycle are just barely misaligned so that Ubuntu always gets an old release of GHC.
18:59:53 <dons> sorear: and if not, why not ? (we should follow vim...)
19:00:01 <dons> Cale: ah maybe
19:00:03 <sorear> dons: gah, I'd forgotten vim even had :syn on
19:00:06 <rashakil> ubuntu users can dip into debian and nab 6.6 though :)
19:00:14 <dons> sorear: feels noticeably faster
19:00:27 <sorear> dons: I thought syntax was always on and you 'enabled' it using ':set ft=haskell' :)
19:00:28 <Cale> rashakil: that doesn't seem to work for me.
19:00:32 <dons> though 1G seems to be broken in vim mode
19:00:36 <rashakil> Cale: maybe I'm just lucky
19:00:44 <mightybyte> Cale: I think the same is true for Gentoo.  GHC 6.6 isn't even in the package system yet.
19:00:51 <dons> ok. this is almost usable now!
19:01:00 <dons> just a little laggy, but a lot lot better
19:01:03 <Cale> mightybyte: hmm, if that's true, then talk to dcoutts, he's responsible for that.
19:01:22 <dons> i notice the vim mode is different from the old days
19:01:23 <sorear> dons: there's still no incremental hl
19:01:25 <aFlag> there's no ghc 6.6 for ubuntu yet?
19:01:25 <dons> i should fix it up
19:01:28 <dons> sorear: ah right.
19:01:32 <dons> so just get that and we'll be done!
19:01:37 <mightybyte> Cale: Ok, great.
19:01:40 <Cale> aFlag: no, it'll be in Feisty, but not Edgy.
19:01:44 <dons> yeah, the 'G' command seems to have disappeared
19:01:46 <sorear> dons: jyp just rewrote all the uis
19:01:50 <dons> yeah
19:01:54 <rashakil> Cale: I just added the debian unstable repository, grabbed it, and dropped the repository, and it seems happy :/
19:01:55 <dons> sorear: so, i'll upload that tarball to hackage now?
19:02:02 <sorear> fine with me!
19:02:09 <Cale> Unfortunately, GHC 6.8 will probably be released just in time to not make it into Feisty.
19:02:34 <Cale> rashakil: nice, I'll probably try that.
19:02:44 <sorear> Feisty =~ sid ?
19:02:49 <Cale> rashakil: I have the generic linux one installed, but not as default.
19:03:08 <Cale> (I'm running a lambdabot)
19:03:17 <aFlag> hmm, there are some software that I rather compile myself than use the one that comes with the distribution
19:03:18 <sorear> Cale:
19:03:25 <sorear> @version
19:03:26 <lambdabot> lambdabot 4p504, GHC 6.6 (OpenBSD i386)
19:03:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:03:32 <dons> sorear: ok, do you have a web page up for vty?
19:03:38 <dons> and some generated haddocks?
19:03:48 <dons> if so, you should add:   homepage: http://foo.org/vty
19:03:50 <lambdabot> Title: foo.org
19:03:54 <Cale> sorear: yeah, it can be compiled with 6.6, but eval doesn't work.
19:03:58 <dons> to the .cabal file, so the docs can be found from hackage
19:04:01 <sorear> Cale:
19:04:03 <sorear> > 2 + 2
19:04:05 <lambdabot>  4
19:04:06 <Cale> You still need 6.4.2 for that.
19:04:17 <sorear> nope, hs-plugins supports 6.6 now
19:04:20 <chessguy> ?hoogle bracket
19:04:21 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:04:21 <Cale> Or perhaps not any more, but this was the case when I compiled it.
19:04:21 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
19:04:21 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
19:04:23 <dons> Cale: oh, yeah, we have a lot of 6.6-isms in @eval now
19:04:30 <Cale> ah, okay
19:04:32 <dons> e.g. Control.Applicative, pmap and friends
19:04:33 <sorear> > Control.Applicative.pure 3 :: [Int]
19:04:35 <lambdabot>  [3]
19:04:39 <Cale> cool
19:04:47 <dons> also, extended defaulting
19:04:49 <dons> > reverse []
19:04:50 <lambdabot>  []
19:04:51 <Cale> So I can probably switch wholesale.
19:04:53 <dons> no type sig!
19:04:56 <sorear> ?hoogle pure
19:04:57 <Cale> right :)
19:04:57 <lambdabot> Control.Arrow.pure :: Arrow a => (b -> c) -> a b c
19:05:01 <Cale> > undefined
19:05:02 <sorear> aww
19:05:03 <lambdabot>  Undefined
19:05:10 <Cale> > error "Hello"
19:05:12 <lambdabot>  Exception: Hello
19:05:19 <dons> sorear: is there a vty website? with the haddocks?
19:05:41 * dons pulls out the quality control whip
19:05:42 <sorear> dons: the haddocks are online, but no website as such
19:05:49 <dons> what's the url of the haddocks?
19:05:53 <Cale> :t 5 :: Int
19:05:56 <lambdabot> Int :: Int
19:06:04 <Cale> that bug's still there though :)
19:06:08 <sorear> http://members.cox.net/stefanor/vty/dist/doc
19:06:10 <dons> regexes rocks
19:06:10 <lambdabot> Title: Directory listing
19:06:13 <Cale> (not that it has anything to do with 6.6)
19:06:19 <dons> sorear: i'll just manually tweak the .cabal file here then
19:06:24 <chessguy> :t (5 :: Int)
19:06:25 <sorear> tsk tsk, even the grammar has errors
19:06:27 <lambdabot> Int
19:06:29 <dons> is that dist/ dir going to stay around?
19:06:33 <chessguy> heh
19:06:46 <dons> sorear: or can you move it somewhere more permanent?
19:06:57 <dons> i.e. mv dist/html into ~/vty
19:06:57 <sorear> dons: ? the haddock/tarballs are there, so I uploaded it
19:07:00 <dons> or some such
19:07:11 <dons> sorear: i'd like to link to this stuff: http://members.cox.net/stefanor/vty/dist/doc/html/
19:07:27 <dons> but I need to know if vty/dist/doc/html/ is not going to get scrubbed on the next make clean
19:07:46 <bd_> hackage really should have a documentation interface like search.cpan.org...
19:07:57 <dons> bd_, yes, that's #1 on the todo  list
19:07:59 <Cale> It's funny how when using torrents, I almost always get 75% of the file from a single user.
19:08:04 <dons> i notice today already there are improvements
19:08:07 <bd_> ah
19:08:13 <dons> bd_ the trick is making sure its safe
19:08:21 <dons> since you can insert Setup.hs hooks
19:08:27 <Cale> and then maybe 5% from 3 more users or so, and then the rest from everyone else.
19:08:30 <bd_> or just insert main = evilcode in setup.hs :)
19:08:40 <dons> right. since we don't run setup.hs at all on ahckage atm.
19:09:03 <sorear> dons: members.cox.net is not live from my computer, it's FTP hosting, so as long as I remember to rerun ./Setup haddock before uploading...
19:09:14 <bd_> would it be enough just to run haddock on anything listed as a hs-src-dirs in the cabal file?
19:09:21 <chessguy> ?hoogle asks
19:09:22 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
19:09:37 <sorear> bd_: no, you need preprocessor symbols, -hide options, etc
19:09:40 <Cale> The fact that the file download is distributed almost doesn't matter, it just degrades into a slow way of finding someone with a good connection to send the file.
19:09:43 <dons> sorear: so you expect that url to continue working/
19:09:44 <bd_> oh
19:09:55 <sorear> dons: @hoogle is still not using 6.6
19:09:58 <sorear> dons: yes
19:10:05 <dons> a) yes, b) ok i'll upload
19:10:59 <sm> shouldn't this be legal: type AccountTree = (Account, [AccountTree]) ? Cycle in type synonym declarations
19:11:15 <ddarius> sm: no
19:11:23 <sm> I mean, I bet it shouldn't, but why.. I've seen crazy recursive stuff
19:11:53 <sorear> sm: type isn't recursive.  this is fixable, but the powers that be think it's a feature
19:11:58 <sorear> (and FTR I agree)
19:11:59 <bd_> sm: you need a newtype or something. Types can't refer to themselves, but type constructors can refer to any type. Since type equates a synonym with a type, rather than making a new constructor, it's illegal.
19:12:01 <ddarius> Equirecursive types cause problems.  That said, they are not insurmountable (e.g. O'Caml has them)
19:12:14 <bd_> sm: newtype AccountTree = AT { unAT :: (Account, [AccountTree]) }
19:12:21 <sm> I see.. thanks all!
19:12:25 <ddarius> It would be nice to have equirecursive (as opposed to isorecursive) types some times.
19:12:27 <sorear> ddarius: oh, what kind of problems?
19:12:36 <SamB> > iterate head
19:12:37 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
19:12:37 <lambdabot>       Expected...
19:12:47 <SamB> you wouldn't really want that to work, would you?
19:12:51 <sorear> ddarius: I wrote an engine for infering anonymous recursive types
19:12:53 <dons> sorear: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty-3.0.0
19:12:57 <lambdabot> http://tinyurl.com/2ycx9g
19:13:11 <ddarius> sorear: One problem is that a lot of type errors end up looking like equirecursive types.
19:13:25 <sorear> dons++ thanks
19:13:34 <sorear> ddarius: eh?
19:13:46 <SamB> sorear: see above
19:13:50 <sorear> ddarius: interestingly my original impl didn't generate type errors at all
19:14:29 <glguy> ddarius: cant unify a and [a] stuff?
19:14:35 <sorear> the occurs check is the ONLY error condition in pure (functions only) unification!
19:14:39 <ddarius> sorear: No. The issue is that actual errors end up being typeable as some ridiculous equirecursive type.
19:14:40 <rashakil> sorear: if you ask me, it adds unnecessary mental complexity.
19:14:54 <sorear> pure + recursive types = no errors at all
19:15:08 <SamB> exactly!
19:15:22 <SamB> or.
19:15:28 <chessguy> ?type forkIO
19:15:30 <lambdabot> Not in scope: `forkIO'
19:15:41 <chessguy> ?hoogle forkIO
19:15:42 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
19:15:45 <SamB> wouldn't "iterate head" work in a "recursive types" typesystem?
19:16:04 <ddarius> glguy: That may be an example.  Pretty much any time GHC says blah would produce an infinite type would typecheck if equirecursive types were supported.
19:16:07 <sorear> before I added sums and products to fixtypes, EVERY sequence of ski was typeable
19:16:15 * ddarius wouldn't mind explicitly declared equirecursive types.
19:16:19 <dufflebunk> Anyone know of good documentation for Happs? (No, the haddoc isn't good. No a hello world app isn't good)
19:16:30 <sorear> ddarius: we have those. see "newtype"
19:16:37 <sorear> dufflebunk:
19:16:42 <sorear> @where hpaste
19:16:43 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
19:16:45 <sorear> ^^ ?
19:16:55 <gotaku> Why doesn't HOpenGL use := instead of $=?
19:17:11 <sorear> because := must be free
19:17:38 <ddarius> sorear: I only want equirecursive types when I give an explicit signature, I don't want them inferred.  But I don't want the constant revalidation of isorecursive types.
19:17:52 <araujo> hello
19:17:55 <dons> dufflebunk: I believe there is a series of tutorials
19:18:04 <dons> dufflebunk: visit #happs ?
19:18:20 <dons> http://haskell.org/haskellwiki/HAppS_tutorial
19:18:21 <dons> ?
19:18:21 <lambdabot> Title: HAppS tutorial - HaskellWiki
19:18:24 <sorear> ddarius: so basically, you want something like the MR.
19:18:57 <dufflebunk> sorear, dons: Thanks those will both help a lot
19:18:59 <rashakil> gotaku: isn't := (or anything with a colon in the front) an infix dataconstructor?  While $= is not?
19:19:03 * dufflebunk join #happs as well
19:20:19 <SamB> sorear: why do you say := must be free?
19:20:24 <SamB> is that some sort of joke?
19:20:31 <dons> ?where+ xcodeplugin http://www.hoovy.org/HaskellXcodePlugin/
19:20:32 <lambdabot> Done.
19:20:32 <sorear> no
19:20:45 <sorear> free, as in free structure
19:20:53 <sorear> free objects can be deconstruced
19:20:55 <dons> now I have to ask, what's xcode? some mac thingy? :)
19:21:15 <SamB> dons: yes
19:21:16 <mbishop> a dumbed down emacs
19:21:19 <sorear> well, I don't want anything with X in it
19:21:30 <Pseudonym> Hell, emacs is a dumbed down emacs./
19:21:33 <SamB> heh
19:21:37 <bd_> sorear: No Xorg?
19:21:47 <SamB> sorear might like an XGA monitor
19:21:48 <sorear> not even that.
19:21:50 <ddarius> sorear: It'd be kind of like polymorphic recursion.
19:21:53 <SamB> if anyone has one to offer
19:21:58 <SamB> ;-)
19:22:02 <dons> sorear: we can't split windows anymore in yi?
19:22:05 <bd_> sorear: no futeX()? :)
19:22:12 <gotaku> No DirectX even? ... oh, nevermind.
19:22:22 <dufflebunk> mutex?
19:22:37 <SamB> gotaku: he'd need (1) a screen and (2) windows for that...
19:22:41 <sorear> dons: you should be able to, but I wouldn't be suprised if it crashes
19:22:52 <bd_> futex is the Fast Userspace muTEX, in linux. The uncontested case avoids entering the kernel.
19:22:55 <Cale> fÃ¼tplex
19:23:35 <sorear> bd_: Just Say No to threading paraphernalia
19:23:37 <Pseudonym> All modern OSes have that, of course, but only Linux gives it a name.
19:23:46 <SamB> heh
19:24:10 <dons> sorear: ah well. its all good. i notice that vim mode doesn't behave exactly like vim. i'll need to go back in and tune that i think.
19:24:14 <Pseudonym> It probably also has a mascot.
19:24:34 <dons> so we lost a bunch of features? and gained syntax highlighting and word wrapping, and better emacs support?
19:24:42 <sorear> Pseudonym: isn't linux, like, the only OS where the kernel writers hate the libc writers and conversely?
19:25:06 <sorear> I hardly touched that code
19:25:06 <SamB> sorear: probably not
19:25:14 <SamB> I bet some others have that too
19:25:23 <SamB> but not with such public mailing lists ;-)
19:27:29 <gotaku> What kind of type constructor name is TOD?
19:27:38 <Cale> gotaku: TimeOfDay
19:27:47 <gotaku> Yes I know...
19:27:52 <Cale> gotaku: It used to be private.
19:27:54 <sorear> :k TOD
19:27:54 <allbery_b> :t TOD
19:27:58 <lambdabot> Not in scope: data constructor `TOD'
19:27:58 <lambdabot> Not in scope: type constructor or class `TOD'
19:28:03 <allbery_b> ?index TOD
19:28:04 <lambdabot> System.Time
19:28:11 <allbery_b> :t System.Time.TOD
19:28:14 <lambdabot> Integer -> Integer -> System.Time.ClockTime
19:31:22 <nrb23> > System.Time.ClockTime 12 15
19:31:23 <lambdabot>   Not in scope: data constructor `System.Time.ClockTime'
19:31:35 <Cale> Is darcs opening separate connections for each of the patches it downloads?
19:31:40 <nrb23> > System.Time.TOD 12 15
19:31:41 <lambdabot>   Not in scope: data constructor `System.Time.TOD'
19:32:14 <SamB> Cale: yes
19:32:20 <SamB> generally
19:33:40 <Cale> I wonder if there's any easy way around that. I suppose HTTP generally has that issue.
19:34:00 <SamB> well, not quite generally
19:34:04 <SamB> you can pipeline
19:34:17 <SamB> but it doesn't always work
19:36:30 <mwc> Borken servers
19:36:41 <mwc> I wonder if it could pipeline using ssh/sftp?
19:37:08 <mwc> Or rather, do it over one connectoin. I assume it is since it only propmpts me once for a pw, but it could just as easily be caching it
19:37:59 <SamB> mwc: do you have sshagent running?
19:38:13 <mwc> no
19:38:18 <SamB> then I'm guessing it does
19:38:32 <nrb23> anyone have thoughts on tabs vs spaces for haskell syntax?
19:38:42 <SamB> because whenever I try to scp multiple files, it asks me every damn time
19:39:01 <sorear> tabs are enough spaces to make the column number divisible by 8
19:39:12 <sorear> any other definition, is blasphemy
19:39:47 <mwc> nrb23, I find that spaces lead to much less grief
19:40:14 <nrb23> mwc: that's been my finding for Python code
19:40:22 <mwc> the haskell standard says that for the purposes of layout, a tab moves to the next divisble-by-eight column
19:40:35 <mwc> so if your editor is set differently, you'll miss important things
19:40:44 <SamB> doesn't ASCII say so too?
19:41:05 <mwc> SamB, afaik, ASCII is an encoding, and doesn't impose any interpretation on a tab\
19:41:14 <SamB> aww.
19:41:20 <sorear> if your editor is set differently, the author of your editor is too dumb to deserve a coding license
19:41:22 <allbery_b> no more than it defines vertical tab
19:41:30 <SamB> eww
19:41:38 <SamB> I don't have a clue what that is yet!
19:41:38 <allbery_b> 8-space tabs are a unixism; typewriters used 5-space tabs IIRC
19:41:50 <allbery_b> well, the on es we used
19:42:07 <sorear> "what's a typewriter?" :)
19:42:15 <allbery_b> > '\VT'
19:42:16 <Stinger> 4 space tab ftw :)
19:42:17 <lambdabot>  '\v'
19:42:21 <sorear> (I actually DO know ...)
19:42:57 <allbery_b> actually I recall some fanci IBM Selectric jobs that tabbed to the next word on the previous line
19:43:26 <allbery_b> > ord '\v'
19:43:28 <lambdabot>  11
19:43:30 <sorear> ooh ... did it have some kind of semiconductor memory?
19:44:16 <allbery_b> not only that, it had an LCD display of the current line and I think the previous line was available via primitive scrollback
19:44:46 <allbery_b> typed and updated display simultaneously, unless you switched it to word or line mode
19:45:07 <allbery_b> (type a word or line, displayed on the lcd onlyuntil you hit space or return
19:45:10 <allbery_b> )
19:46:12 <sorear> did it have rubout?
19:48:06 <allbery_b> yes, dual ribbon (whiteout and normal)
19:48:56 <allbery_b> was kind of the last gasp of the typewriter before it gave in to the terminal/PC+printer
19:49:12 <nrb23> mmm, old wordprocessors
19:52:07 <chessguy> so are Reader and Writer basically just State monads where you can only get or put (respectively)?
19:52:50 <bd_> chessguy: You can implement their interfaces in terms of State, certainly
19:52:56 <bd_> but the operations are a bit different
19:53:09 <bd_> eg, with reader, you can use local to alter the value temporarily
19:53:17 <chessguy> but broadly
19:53:23 <bd_> and the writer isn't like put, it uses monoid addition to merge its inputs
19:53:27 <bd_> broadly... maybe
19:53:32 <bd_> >.>
19:56:17 <SamB> if it helps, there are RWS and RWST, so apparantly each is usefull in its own right...
19:56:35 <chessguy> what are they?
19:56:41 <bd_> chessguy: ReaderWriterState :)
19:56:46 <SamB> yeah
19:56:53 <bd_> it's just the three composed, in something probably more efficient than tossing them in ad-hoc
19:57:00 <sorear> @k Control.Monad.RWS.RWST
19:57:01 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . v
19:57:03 <sorear> :k Control.Monad.RWS.RWST
19:57:06 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
19:57:07 <bd_> > mempty :: ()
19:57:08 <lambdabot>  ()
19:57:21 <SamB> or perhaps it just saves you from fiddling with the nesting ;-)
19:57:23 <sorear> bd_: yea, just one level of tupling
19:57:25 <bd_> :)
19:57:32 <SamB> or trying to figure out if it matters which way you nest
19:57:52 <SamB> hmm, one level of tupling...
19:57:57 <SamB> this is true
19:58:02 <chessguy> well, that makes it much more confusing. thanks, SamB !
19:58:04 <bd_> sorear: and the indirects from invoking function pointers in the dictionaries passed around, assuming it doesn't inline/specialize automatically
19:58:37 <sorear> FWIW, John has a UnboxedRWS floating around
19:58:48 <sorear> s/John/\&Meacham/
19:58:56 <SamB> @instances-importing Control.Monad.RWS MonadReader
19:58:58 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
19:59:02 <SamB> @instances-importing Control.Monad.RWS MonadWriter
19:59:04 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
19:59:07 <SamB> @instances-importing Control.Monad.RWS MonadState
19:59:09 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
19:59:17 <gotaku> How do you search the gtk2hs docs?
19:59:20 <SamB> chessguy: does that make it any more clear?
19:59:26 <chessguy> not really
19:59:33 <sorear> @google Gtk2Hs
19:59:35 <lambdabot> http://haskell.org/gtk2hs/
19:59:36 <lambdabot> Title: Gtk2Hs
19:59:44 <sorear> @google Gtk2Hs button
19:59:45 <SamB> RWS is an instance of all three
19:59:46 <lambdabot> http://eddy.writelinux.com/gtk2hs/GladeGtk2Hs.html
19:59:46 <lambdabot> Title: Developing Gnome Apps with with Glade and Haskell Gtk2Hs
20:00:45 <SamB> with different types for the environment, the state, and the output
20:00:47 <chessguy> i still don't get the difference between State and MonadState
20:00:57 <bd_> MonadState is a generalization
20:01:01 <SamB> State is a type constructor
20:01:06 <bd_> well, a class
20:01:09 <SamB> MonadState is a class
20:01:34 <SamB> you know the difference between a type and a class don't you?
20:01:39 <chessguy> sure
20:01:49 <SamB> good ;-)
20:02:01 * SamB is glad to know that he (SamB) isn't going insane
20:02:21 <chessguy> ohhhhhh
20:02:40 <jcreigh> @hoogle Word8 -> Char
20:02:41 <lambdabot> No matches, try a more general search
20:02:44 * chessguy holds up a light bulb sign over his head
20:02:58 <jcreigh> toEnum wants an Int. What's the easiest way to get a Word8 to a Char?
20:03:13 <allbery_b> toEnum . fromEnum?
20:03:44 <allbery_b> > ((toEnum . fromEnum) (8 :: Word8)) :: Char
20:03:45 <lambdabot>  '\b'
20:03:55 <jcreigh> oooh, clever.
20:03:57 <jcreigh> allbery_b++
20:04:10 <jcreigh> It feels silly to have to do that, though.
20:04:11 <chessguy> allbery_b, that's got to be cheating, s omehow :)
20:04:23 <allbery_b> afaik it's not cheating, it's how you do it
20:04:35 <allbery_b> and I *think* most of that is internally optimized away
20:05:53 <allbery_b> actually fromIntegral should also work instead of fromEnum
20:06:03 <allbery_b> @instances-importing Data.Word Integral
20:06:04 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
20:06:43 <allbery_b> and chr instead of toEnum, but AFAIK chr is just (toEnum :: Char)
20:06:45 <allbery_b> :t chr
20:06:48 <lambdabot> Int -> Char
20:06:51 <jcreigh> same problem with chr
20:06:53 <allbery_b> @src chr
20:06:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:07:32 <allbery_b> no, I mean (chr . fromIntegral) works, or any combination of (chr or toEnum) . (fromEnum or fromIntegral)
20:08:06 <jcreigh> oh, right.
20:14:19 * sorear > homework
20:14:57 <jcreigh> sorear: Does that have type IO () or Bool? :)
20:16:11 <sorear> I think it has type State# RealWorld -> Bool
20:16:33 <allbery_b> looks like a shell redirection ot me, so State# RealWorld -> IO ()
20:17:48 <bd_> allbery_b: unsafeReplaceWorld# :: State# RealWorld -> IO a ? [the a being because it doesn't return >.>]
20:22:45 <glguy> why is the use of "ReadWorld" in IO considered such a hack?
20:22:51 <glguy> Real*
20:23:29 <allbery_b> because it doesn't really exist and gets optimized away by the compiler, IIRC
20:23:56 <SamB> @src IO
20:23:57 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:24:00 <SamB> hmm.
20:24:02 <SamB> well.
20:24:11 <allbery_b> it's just a magic state value that gets not-really-passed-around; eveyr "IO action" is secretly a paprtial function application awaiting a RealWorld#
20:24:14 <allbery_b> cfL
20:24:16 <SamB> I don't see what ioToST has to do with it...
20:24:16 <allbery_b> er.
20:24:17 <allbery_b> cf:
20:24:22 <SamB> @hoogle ioToST
20:24:22 <allbery_b> @src unsafePerformIO
20:24:23 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
20:24:23 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
20:24:23 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
20:24:27 <dibblego> "But even Haskell isn't [functional]. The reason is the IO-monad." -- is this crazy or *really* crazy talk?
20:24:29 <SamB> hmm.
20:24:35 <SamB> re.
20:24:36 <SamB> er.
20:24:43 <SamB> I got it backwards :-(.
20:24:45 <allbery_b> note how all it does is feed a realWorld# to the IO actin
20:24:49 <SamB> @hoogle stToIO
20:24:50 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
20:25:01 <allbery_b> and then deconstruct the resulting unboxed tuple
20:25:09 <SamB> that seems fairly unrelated to the usage in the definition of the IO datatype
20:25:50 <allbery_b> well, I'm thinking it actually ends up like a "runIO"
20:25:59 <allbery_b> like:
20:26:08 <allbery_b> :t runState
20:26:11 <lambdabot> forall s a. State s a -> s -> (a, s)
20:26:22 <glguy> what does newtype A a = A Whatever a *do*
20:26:33 <allbery_b> so you need to feed it an initial state.  with IO, you feed it an initial realWorld# to make it actually happen
20:27:03 <SamB> allbery_b: which we can pretend the operating system provides ;-)
20:27:18 <allbery_b> usually, yes
20:27:22 <SamB> (does the operating system need it back later?)
20:27:28 <allbery_b> barring the evil of unsafePerformIO
20:27:44 <aFlag> is there a standard function that will replace the first occurrence of an element on a list by other element?
20:27:54 <glguy> SamB: it uses split on RealWorld ;) like randomgen
20:28:22 <allbery_b> so running a program is secrely unsafeInterleaveIO main?
20:31:03 <bd_> @src unsafeInterleaveIO
20:31:03 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
20:31:05 <sorear> State# RealWorld is a GHC-specific hack
20:31:51 <sorear> Jhc uses RealWorld__, Hbc uses (pure!) [Request] -> [Response], Yhc uses something completely different
20:32:12 <sorear> er, flip that arrow
20:32:22 <allbery_b> sure, I took that as understood
20:33:02 <allbery_b> Hbc's using the pre-monad Haskell version, isn't it?
20:33:10 <xpika_> @index plain
20:33:10 <lambdabot> Distribution.PreProcess.Unlit
20:33:21 <xpika_> @index ok
20:33:22 <lambdabot> Test.QuickCheck, Debug.QuickCheck
20:33:31 <glguy> xpika_: those are HAppS functions
20:33:35 <xpika_> yep
20:33:46 <glguy> so they won't be listed in the standard library lookup
20:34:01 <xpika_> im getting -- hello.hs:9:21: Not in scope: `ok'
20:34:03 <glguy>  @index plain  -> HAppS
20:34:14 <xpika_> yep
20:34:22 <glguy> xpika_: and they are 0.9.0 specific
20:34:37 <glguy> xpika_: so if you are using 0.8.4 (release version) you are using the wrong tutorial
20:34:37 <dmead> @remember
20:34:38 <lambdabot> Incorrect arguments to quote
20:34:44 <sorear> @quote
20:34:45 <lambdabot> simonpj says: You may not like this but this should work..
20:34:46 <dmead> @remember I think a quote from Cylons of the Lambs would be most appropriate: 'Would you frak me? I'd frak me. I'd frak me hard.
20:34:46 <lambdabot> Done.
20:34:55 <sorear> @quote I
20:34:56 <lambdabot> I says: think a quote from Cylons of the Lambs would be most appropriate: 'Would you frak me? I'd frak me. I'd frak me hard.
20:35:04 <dmead> =p
20:35:23 <sorear> what did you mean?
20:35:23 <allbery_b> woo, by ghc build is up to way=p
20:35:28 <allbery_b> *my
20:35:46 <sorear> how long ago did you start?  how slow is your computer?
20:35:59 <allbery_b> G4 Mac mini, so not very fast
20:36:37 <sorear> mkdir ghcbuild ; cd ghcbuild; lndir ../ghcfull/ghc ; autoreconf; ./configure ; make ; su -c make\ install --> 90 mins here (extralibs included!)
20:36:52 <allbery_b> little over 3 hours ago, from a distclean
20:36:58 <sorear> GHC HEAD is soo easy to build
20:37:36 <jcreigh> *three hours*? Is that the normal build time?
20:37:41 <allbery_b> G4 minis aren't exactly high end hardware, and it's complicated by being on an external firewire drive (my case-dependent filesystem lives there)
20:37:44 <xpika_> neither the Happs website or the hawiki told me that
20:37:52 <sorear> allbery_b: I imagine a fresh symlink farm from a fresh pull is as good as a distclean?
20:37:52 <xpika_> but thanks
20:38:07 <xpika_> i found a tutorial in the cabal file which looks up to date
20:38:08 <sorear> xpika_: don't EVER go to hawiki
20:38:09 <allbery_b> jcreigh:  for a full build from ground level, sure.  keep in mind it builds the compiler twice
20:38:29 <sorear> xpika_: hawiki is massively out of date and should be deleted *hint hint hint*
20:38:32 <xpika_> s/hawiki/haskell.org
20:38:50 <allbery_b> second time it also builds the libraries twice (without and with profiling)
20:39:24 <xpika_> http://www.haskell.org/haskellwiki/HAppS_tutorial which was linked from the happs.org website
20:39:26 <lambdabot> Title: HAppS tutorial - HaskellWiki
20:40:57 * allbery_b could make it just do the stage2 build but likes the assurance that the compiler built correctly, provided by having the stage1 compiler do the stage2 build
20:41:02 <glguy> I think that running OpenBSD in VMWare  on Windows XP and using Cygwin/X for XCDMP is nearly ideal for me... good hardware support (audio and video) simple appearance (fullscreen X11) full power of obsd
20:42:01 <sorear> <-- linux, running on bare metal, full hardware support.  don't buy sheep-only computers.
20:42:12 <bohanlon> glguy: that is close to the most terrible thing that I have ever heard
20:42:16 <glguy> lol
20:42:33 <glguy> I don't care for the linux distros that I've tried
20:42:44 <bohanlon> (FreeBSD and NetBSD here)
20:43:01 <glguy> and openbsd doesn't have the hardware support for the full feature set of my SB soundcard and nvidia vidcard
20:43:34 <bohanlon> Yeah, someone convinced nvidia to release drivers for my nvidia card .. it is quite nice.
20:43:45 <bohanlon> (for FreeBSD, that is)
20:43:46 <allbery_b> <-- freebsd and OSX/PPC
20:44:17 <glguy> I've used FreeBSD with success before, I just have a slight bias towards obsd from knowing where everything is
20:44:24 <glguy> (that I need at least)
20:44:33 <glguy> I use OS X on my powerbook still
20:44:46 <dmead> why do you want to make linus cry, glguy?
20:44:46 <aFlag> I'm on debian :)
20:44:53 <nrb23> @hoogle (Num b, Integral a) => b -> a
20:44:54 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
20:44:54 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
20:44:54 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
20:44:57 <Korollary> Everybody is on something.
20:45:04 <glguy> dmead: nothing against the kernel really
20:45:10 <glguy> dmead: so nothing against linux ;)
20:45:14 <dmead> =p
20:45:22 <bohanlon> I had run OBSD on my powerbook... but it is back to OSX
20:45:32 <glguy> I tried Ubuntu on my powerbook
20:45:37 <aFlag> glguy: what do you like so much on openbsd distribution that you won't find on linux?
20:45:39 <bohanlon> APT is wonderful, but I stick to BSD
20:45:41 <glguy> but I'm not going to pay too much for a lapto
20:45:43 <xpika_> ok, i fixed the happs wiki tutorial
20:45:51 <glguy> to get less hardware support
20:46:25 <glguy> aFlag: fewer wizards and alyers of things to configure
20:46:33 <glguy> aFlag: and general familiarity
20:46:55 <MechaBlue> Linux = pain!
20:46:56 <allbery_b> nrb23: what are you really trying to do?
20:47:19 <aFlag> hmm, I have netbsd on one of my computers, but for doing desktop things I find my linux much better than the netbsd
20:47:24 <allbery_b> @hoogle (RealFrac a, Integral b) => a -> b
20:47:25 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
20:47:25 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
20:47:25 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
20:47:48 <nrb23> convert Word8 to Int
20:47:52 <nrb23> I had it backwards
20:48:05 <MechaBlue> I've tried running Ubuntu and Fedora Core and it seems that I always run into a major issue.
20:48:43 <allbery_b> fromIntegral or fromEnum
20:49:06 <aFlag> hmm I never had a major issue, but I usually use debian stable, when things start to get too old, I move to testing
20:49:17 <MechaBlue> I've had problems where the onboard LAN had it's MAC set randomly on boot, making it very difficult to use with my DSL provider.  After a few days, I managed to have the boot scripts automatically set it.
20:49:20 <aFlag> I've been doing that for quite a while, and things seem fine :)
20:49:58 <MechaBlue> With Ubuntu, getting WPA-PSK working was a lot of effort and it would often freeze the system when I tried to start WiFi.
20:50:45 <MechaBlue> Then there were the nVidia drivers that gave nifty 3D but resulted in an uptime worse than Win95.
20:50:46 <Nafai> I've never tried any of the *BSD's
20:51:20 <glguy> I originally switch to OpenBSD for PF and the man pages
20:51:36 <glguy> I don't know the state of linux's kernel firewall or manpages anymore
20:51:50 <glguy> so I'm not arguing if they are still better or nif they have been improved
20:52:03 <glguy> if the others*
20:52:04 <Nafai> I've heard good things about PF
20:52:53 <MechaBlue> I monetized the time lost and came up with a figure that corresponded to a high-end iBook, so here I am ;)
20:53:59 <glguy> MechaBlue: I think that "PowerBook" is "Apple" for "high-end iBook" ;)
20:54:23 <bohanlon> glguy: that is actually true for the 12"; the 15 and 17", not so much.
20:54:46 <sorear> Linux just works for me.  then again, I've never tried anything else, but it seems hard to do more than tie perfection :)
20:54:48 <MechaBlue> It wasn't quite that much money :P  I just got 1.25 GB of RAM and WiFi, which was pretty good 2 years ago.
20:55:07 <glguy> 1.25 is the max for an iBook?
20:55:54 <MechaBlue> glguy: I believe so.  Integrated 256MB with a slot capable of 1GB.  The new MacBooks are at least 2GB capable.
20:56:20 <glguy> once GHC's build process is making libraries with ../../compiler/ghc-inplace... it is past boot strap and recompiling everything again / finishing up?
20:56:42 <allbery_b> libraries are only built in stage 2
20:57:01 <allbery_b> if you enables profiling libs (default) the libs get built twice, second time shows "way=p" if you look closely
20:57:03 <glguy> anyone remember how far along readline is built? :)
20:58:11 <glguy> I'm on the way=p step now
20:58:31 <allbery_b> it's after haskell98 and template-haskell according to my current build log
20:58:31 <glguy> == gmake way=p all;
20:58:38 <allbery_b> (I'm lready past it in way=p)
20:58:47 <glguy> i'm on regex-posix now
20:58:54 <glguy> parsec!
20:58:55 <allbery_b> but if you';re; into way=p then it already built the non-prfofiling libvs successfully
20:58:57 <sorear> I'm long since finished
20:59:14 <sorear>  / /_\// /_/ / /  | |      GHC Interactive, version 6.7.20070213, for Haskell 98.
20:59:30 <allbery_b> parsec is after readline
20:59:56 <glguy> yup, I'm calling them out as I hit them (and I've stopped ) :)
21:00:28 <glguy> does HEAD build any faster or slower than 6.6?
21:00:31 <allbery_b> Recursively making `all' in base haskell98 template-haskell readline regex-base regex-posix regex-compat parsec Cabal unix haskell-src html network QuickCheck HUnit mtl fgl X11 time HGL OpenGL GLUT OpenAL ALUT stm xhtml cgi ...
21:00:49 <sorear> glguy: 90 mins ... but I've never build 6.6 so I can't compare
21:02:27 * allbery_b 's buid is up to time, in way=p
21:07:12 <brad_> hello
21:07:29 <brad_> i was hoping someone here could help me with a small problem
21:07:36 <allbery_b> ask
21:07:53 <brad_> there is a function "permute" listed at http://www.mail-archive.com/haskell@haskell.org/msg19030.html
21:07:54 <lambdabot> Title: Re: [Haskell] String permutation
21:08:09 <brad_> and i can't seem to figure out why it permutes
21:08:13 <brad_> the line:
21:08:21 <brad_> xs <- permute (delete x str)
21:08:28 <brad_> seems the most confusing
21:08:45 <robreim> Data.Binary.encode "a"
21:08:48 <robreim> > Data.Binary.encode "a"
21:08:49 <lambdabot>   Not in scope: `Data.Binary.encode'
21:08:54 <brad_> if x <- str, then isn't (delete x str) simply ""?
21:08:59 <brad_> how can this recurse?
21:09:24 <dons> is it using the list monad?
21:09:26 <dons> i.e. foldr
21:09:36 <robreim> d'oh. Is there any way to use Data.Binary.encode without it producing leading junk characters? ie encode "a" currently produces: LPS ["\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOHa"]
21:09:38 <allbery_b> it's using the list monad, yes
21:09:41 <brad_> i believe so
21:09:53 <brad_> i think thats the part i can't understand
21:09:57 <allbery_b> and I think it deletes the first character, then permutes the rest of the listm then recombines the first character
21:09:59 <sorear> robreim: that's not junk
21:10:04 <dons> robreim: use Code.Compression.GZip
21:10:05 <sjanssen> brad_: x is any element in str
21:10:06 <sorear> robreim: that's the list length
21:10:18 <dons> yeah, its not necessarily junk
21:10:19 <allbery_b> but because it's using the list monad, this implicitly operates on all of the list in parallel
21:10:22 <robreim> Ohh right
21:10:26 <allbery_b> not just the first character
21:10:26 <dons> also, Int is encoded as Int64
21:10:34 <sorear> robreim: a [Char] is encoded as a 64-bit length, followed by a list of utf8 chars
21:10:35 <dons> so you could just use ,say, zlib
21:10:40 <dons> and write:   compress . encode $ foo
21:10:44 <brad_> ah, thanks sjanssen and allberry_b, i guess i should look up the list monad to understand that
21:10:59 <brad_> are you saying that x <- str is the magic bit?
21:11:03 <robreim> *nods* ok, that makes sense. So if I want to just deal with raw characters, I should probably not use encode.
21:11:10 <sorear> right.
21:11:13 <brad_> from the list monad that operates on all of the chars in str?
21:11:14 <sjanssen> brad_: do you understand list comprehensions?
21:11:21 <sorear> use the UTF8 code directly
21:11:23 <allbery_b> the "magic bit" is the fact that the list monad operates in paralel on all the elements of the list
21:11:46 <brad_> sjanssen - i believe i understand list comprehensions and i use them, but i have no doubt i can always learn more
21:11:54 <allbery_b> so you write a "proototype" operating on one element (in this case it looks like you ugrb the first character, then permute the rest of the list, then put it back on the front of the permuutation)
21:11:58 <brad_> thanks allberry_b
21:12:24 <sjanssen> > [(x, y) | x <- [1..3], y <- [1..3]] -- do you understand that this code will produce all pairs of the list [1..3]?
21:12:25 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
21:12:34 <allbery_b> and the list monad then runs it not just on the first character but on all the characters, and the same recursively, so it quietly does every possible combination for you
21:12:42 <brad_> yes sjanssen i am with you there
21:13:04 <robreim> thanks for the help
21:13:08 <sorear> yw
21:13:08 <sjanssen> brad_: okay, the "<-" in the list monad's do construct is the same as the "<-" in a list comprehension
21:13:18 <brad_> AH
21:13:22 <brad_> i see
21:13:37 <sorear> once, comprehensions and do were the same in every case.
21:13:40 <sorear> sigh.
21:13:47 <brad_> i suppose if i rtfm'd on the list monad i would learn this!
21:14:04 <sorear> there's a fm on the lift monad?
21:14:07 <sjanssen> comprehensions were actually the original syntax, I think
21:14:08 * sorear is suprised
21:14:20 <brad_> hmmm, very interesting sjanssen, i did not know this!
21:14:30 * allbery_b hasn't seen one, he'd have figured out the list monad a lot earlier if there had been
21:14:43 <allbery_b> instead I just kept looking at code that used it and it finally clicked one day
21:14:54 <sjanssen> I'm sure the nomaware monad tutorial presents the list monad
21:15:13 <brad_> i was working through nomaware, but got a little sidetracked
21:15:22 <brad_> i think i probably should finish it!
21:15:42 <brad_> well thanks so much for the help everyone!
21:15:43 <allbery_b> I think I read All About Monads early but didn't get it at the time
21:15:52 <brad_> you are very helpful as usual!
21:15:58 <brad_> bye bye!
21:18:48 <kolmodin> morning!
21:19:34 <sjanssen> evening!
21:19:40 <dons> afternoon!
21:19:42 <sorear> night!
21:19:58 <dons> yes, we're all crazy in here
21:20:08 <allbery_b> ahh, internet :)
21:21:05 <Blacksitox> hi D
21:21:07 <Blacksitox> :D*
21:21:13 <sorear> hi!
21:21:29 <Blacksitox> araujo, aquÃ­ estoy xD
21:21:45 <Blacksitox> hello sorear !
21:33:38 <araujo> Blacksitox, :-)
21:34:05 <Blacksitox> vaya que aquÃ­ hay muchos :p
21:35:04 <robreim> ?hoogle forever
21:35:04 <araujo> :-)
21:35:05 <lambdabot> No matches found
21:35:11 <robreim> ?hoogle IO () -> IO ()
21:35:12 <lambdabot> System.Mem.Weak.addFinalizer :: key -> IO () -> IO ()
21:35:12 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
21:35:12 <lambdabot> GHC.Conc.addMVarFinalizer :: MVar a -> IO () -> IO ()
21:35:21 <sorear> the - in aqu- somehow seems to have defeated the /mode #haskell +c !
21:35:50 <sorear> robreim: forever is what dons called repeatM_ before it was added to base
21:35:51 <mbishop> > putStr "?hoogle IO ()"
21:35:53 <lambdabot>  <IO ()>
21:36:11 <sorear> @msg #haskell ?hoogle IO ()
21:36:11 <robreim> ?hoogle repeatM_
21:36:12 <lambdabot> ?hoogle IO ()
21:36:12 <lambdabot> No matches found
21:36:22 <sorear> @ty Control.Monad.repeatM_
21:36:25 <lambdabot> Not in scope: `Control.Monad.repeatM_'
21:36:26 <robreim> Yeah, I knew there was a new name for it, just couldn't remember what
21:36:27 <robreim> Thanks
21:36:52 <sorear> @ty (sequence_ . repeat) -- until it is in your local ghc
21:36:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
21:37:32 <robreim> cleaner than my implementation, thanks! :)
21:38:58 <sorear> robreim: better yet!
21:39:03 <sorear> @ty fix . (>>)
21:39:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
21:39:14 <sorear> pointfree to the rescue!!
21:39:24 <robreim> oh! That's nice :)
21:39:32 * robreim vows to one day understand fix
21:39:37 <sorear> @src fix
21:39:38 <lambdabot> fix f = let x = f x in x
21:40:04 <robreim> yeah, I know the implementation, but I don't understand it in the sense of know how to use it well
21:40:36 <sorear> @pl let forever x = x >> forever x in forever
21:40:37 <lambdabot> fix (ap (>>))
21:43:19 <dmead> > "for" ++ "ev" ++ "er"
21:43:20 <lambdabot>  "forever"
21:50:45 <dmead> ?src foldmap
21:50:46 <lambdabot> Source not found. Wrong!  You cheating scum!
21:50:50 <dmead> xD
21:50:55 <dmead> ?hoogle foldmap
21:50:56 <lambdabot> No matches found
21:51:00 <dmead> @hoogle foldmap
21:51:01 <lambdabot> No matches found
21:51:06 <dmead> ?src foldl
21:51:06 <lambdabot> foldl f z xs = lgo z xs
21:51:07 <lambdabot>     where lgo z []     =  z
21:51:07 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
21:51:11 <dmead> ?src foldr
21:51:12 <lambdabot> foldr k z xs = go xs
21:51:12 <lambdabot>     where go []     = z
21:51:12 <lambdabot>           go (y:ys) = y `k` go ys
21:51:25 <sjanssen> dmead: foldMap is in Data.Foldable IIRC
21:51:33 <dmead> ah
21:51:35 <sjanssen> new in ghc 6.6
21:51:37 <dmead> ?src foldMap
21:51:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:51:52 <sjanssen> (and lambdabot's index hasn't caught up)
21:51:58 <dmead> rats
21:52:16 <sjanssen> dmead: it's an overloaded function, so source probably isn't very useful
21:52:25 <sorear> @src Foldable
21:52:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:52:28 <dmead> well
21:52:44 <dmead> i'm trying to switch my prover to using the fold syntax
21:52:50 <sjanssen> @type \f xs -> mconcat (map f xs) -- I believe this is foldMap for lists
21:52:52 <dmead> but i'm not sure if it's "better" cause it's haskell specific
21:52:53 <lambdabot> forall a a1. (Monoid a1) => (a -> a1) -> [a] -> a1
21:54:20 <sorear> oh, so your prover is a Haskel/ML polyglot? :p
21:55:12 <dmead> o0
21:55:15 <dmead> polygot?
21:55:27 <sjanssen> other languages have foldish operations
21:57:14 <dmead> hmm
21:57:25 <dons> > let nfib 0 = 1; nfib 1 = 1; nfib x = a `par` b `seq` (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 20 -- sjanssen ;)
21:57:27 <lambdabot>  10946
21:57:38 <dons> (not on the 16 core box though)
21:57:48 <dons> but there you go, parallel haskell, live in channel
21:57:52 <dmead> expected type bool -> bool
21:57:55 <dmead> inferred type bool
21:57:57 <dmead> so close!
21:58:51 <sjanssen> > let nfib 0 = 1; nfib 1 = 1; nfib x = (a+b) where a = nfib (x - 2); b = nfib (x - 1) in nfib 20 -- will this finish in time?
21:58:53 <lambdabot>  10946
21:59:00 <dmead> ?paste
21:59:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:59:15 <sjanssen> dons: still on a mono-core machine?
21:59:19 <dons> yeah
21:59:30 <Pseudonym> > let pow2 [] = 1; pow2 (x:xs) = p1 `par` p2 `seq` (p1+p2) where p1 = length (pow2 xs); p2 = length (pow2 (map (x:) xs))
21:59:30 <lambdabot>  Parse error
21:59:35 <nrb23> :t HostAddress -> String
21:59:36 <Pseudonym> > let pow2 [] = 1; pow2 (x:xs) = p1 `par` p2 `seq` (p1+p2) where p1 = length (pow2 xs); p2 = length (pow2 (map (x:) xs)) in pow2 [1..8]
21:59:37 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
21:59:38 <lambdabot>       Expected...
21:59:38 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
21:59:39 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
21:59:39 <lambdabot>  
21:59:45 <dons> huh
21:59:53 <nrb23> @hoogle HostAddress -> String
21:59:54 <lambdabot> No matches, try a more general search
21:59:56 <Pseudonym> > let pow2 [] = 1; pow2 (x:xs) = p1 `par` p2 `seq` (p1+p2) where p1 = length (pow2 xs); p2 = length (pow2 xs) in pow2 [1..8]
21:59:57 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
22:00:00 <dons> looks like my regexes went a bit ary
22:00:11 <dons> :t HostAddress
22:00:14 <lambdabot> Not in scope: data constructor `HostAddress'
22:00:21 <dons> :t HostAddress -> String
22:00:24 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
22:00:24 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
22:00:24 <lambdabot>  
22:00:29 <dons> hehe
22:00:35 <dons> :t 8
22:00:38 <lambdabot> forall t. (Num t) => t
22:01:00 <bd_> :t intercalate
22:01:03 <lambdabot> Not in scope: `intercalate'
22:01:17 <dons> did it make ghc 6.6?
22:01:20 <dons> I'm not sure it did
22:01:26 <bd_> apparently not...
22:01:38 * nrb23 wonders if there's a decent HostAddress -> String function
22:02:14 <sorear> wait, we're using GHCi now?
22:02:14 <sorear> @let log2 1 = 0; log2 x = 1 + log2 (x `div` 2)
22:02:14 <sorear> @ty L.log2
22:02:14 <sorear> @botsnack
22:02:14 <sorear> *prod*
22:02:15 <dons> ?hoogle HostAddress
22:02:15 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
22:02:17 <lambdabot>     Interface file inconsistency:
22:02:17 <lambdabot>       home-package module `L' is mentioned,
22:02:17 <lambdabot> :)
22:02:17 <lambdabot> Network.Socket.HostAddress :: type HostAddress
22:02:17 <lambdabot> Network.BSD.hostAddress :: HostEntry -> HostAddress
22:02:19 <lambdabot> Network.BSD.hostAddresses :: HostEntry -> [HostAddress]
22:02:21 <dons> sorear: for @type, we always have
22:02:43 <dons> sorear: but the output changed just enough with ghc 6.6, and the lcaol defs, to break the regexe
22:02:51 <hpaste>  dmead pasted "how to foldify?" at http://hpaste.org/485
22:02:57 <dmead> ^^
22:03:09 <dons> @undefine
22:03:11 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
22:03:21 <dons> @let log2 1 = 0; log2 x = 1 + log2 (x `div` 2)
22:03:23 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
22:03:24 <dmead> i'm missing something subtle there
22:03:25 <Pseudonym> > let pow2 [] = [[]]; pow2 (x:xs) = xs1 `par` xs2 `seq` (xs1++xs2) where xs1 = pow2 xs; xs2 = map (x:) (pow2 xs) in genericLength (pow2 [1..8])
22:03:26 <lambdabot>  256
22:03:28 <Pseudonym> > let pow2 [] = [[]]; pow2 (x:xs) = xs1 `par` xs2 `seq` (xs1++xs2) where xs1 = pow2 xs; xs2 = map (x:) (pow2 xs) in genericLength (pow2 [1..16])
22:03:30 <lambdabot>  65536
22:03:32 <Pseudonym> > let pow2 [] = [[]]; pow2 (x:xs) = xs1 `par` xs2 `seq` (xs1++xs2) where xs1 = pow2 xs; xs2 = map (x:) (pow2 xs) in genericLength (pow2 [1..32])
22:03:44 * Pseudonym waits...
22:03:45 <dons> so @let is a little bit broken
22:03:47 <Pseudonym> How many CPUs you got?
22:03:51 <dons> 1
22:04:00 * Pseudonym waits some more...
22:04:08 <dons> ghc 6.6 fun fun !
22:04:11 <allbery_b> @bot
22:04:12 <lambdabot> :)
22:04:18 <Pseudonym> Fun!
22:04:23 <Pseudonym> So I didn't kill it.
22:04:24 <dons> yeah, the Terminated message does seem to get through
22:04:27 <dons> nah.
22:04:30 <dons> it just didn't print any result
22:04:35 <Pseudonym> Hmm.
22:04:40 <Pseudonym> > let pow2 [] = [[]]; pow2 (x:xs) = xs1 `par` xs2 `seq` (xs1++xs2) where xs1 = pow2 xs; xs2 = map (x:) (pow2 xs) in genericLength (pow2 [1..24])
22:04:45 <dons> s/doesn't seem to get through/
22:04:50 <Pseudonym> Oh well.
22:04:53 <dons> > 1+2
22:04:54 <Pseudonym> Nice, though.
22:04:55 <lambdabot>  3
22:05:07 <dons> > let loop () = loop () in loop ()
22:05:09 <lambdabot>  Exception: <<loop>>
22:05:28 <dons> > last [1..]
22:05:33 <dons> @bot
22:05:33 <lambdabot> :)
22:05:37 <Pseudonym> > let loop _ = loop () in loop ()
22:05:38 <dons> so no Terminated mesage, it seems
22:05:39 <lambdabot>  Exception: <<loop>>
22:05:44 <Pseudonym> > let loop x = loop x in loop ()
22:05:52 <Pseudonym> That's it.
22:05:53 <Cale> > let loop | loop == loop = loop in loop
22:05:55 <lambdabot>  Exception: <<loop>>
22:05:59 <Stinger> hmm is there something special you have to do after mainQuit to shut down gtk2hs cleanly?
22:06:07 <Pseudonym> > let omega = omega + 1 in omega
22:06:09 <lambdabot>  Exception: <<loop>>
22:06:54 <Pseudonym> OK, so it's only black holes that make it.
22:07:06 <dons> yeah, its just not spotting the timeout string anymore
22:08:14 <Pseudonym> > let f = f `par` f in f
22:08:15 <lambdabot>  Exception: <<loop>>
22:08:28 <Pseudonym> > let f x = f x `par` f x in f ()
22:08:30 <lambdabot>  Exception: <<loop>>
22:12:29 <sorear> > array (0::Int,maxBound) [(0,'x')]   -- does this still wokr?
22:12:34 <sorear> > array (0::Int,maxBound) [(1,'x')]   -- does this still wokr?
22:12:38 <sorear> > array (0::Int,maxBound) [(2,'x')]   -- does this still wokr?
22:12:41 <sorear> > array (0::Int,maxBound) [(3,'x')]   -- does this still wokr?
22:12:44 <dons> remember, death mean no output
22:12:50 <dons> so no need to DOS my box ;)
22:13:19 <dons> it allocates, then crashes
22:13:28 <sorear> I hope you have ulimit -c 0 on lambdabot :p
22:13:31 <dons> $ ./runplugs
22:13:32 <dons> array (0::Int,maxBound) [(3,'x')]
22:13:32 <dons> runplugs: internal error: EVACUATED object entered!
22:13:36 <dons> yeah
22:13:56 <sorear> I imagine GHC produces pretty big core files ...
22:14:15 <dons> hmm 5M?
22:14:17 <nrb23> woot!
22:14:20 * nrb23 does the happy dance
22:14:44 <sorear> (appearantly some versions of linux dump core with realtime priority ... instant DOS)
22:14:49 * dons tweaks the regexes a bit
22:14:55 <dons> huh
22:15:05 <sorear> bye
22:15:14 <dons> night
22:15:26 <nrb23> """Some people, when confronted with a problem, think âI know, Iâll use regular expressions.â Now they have two problems. """
22:15:46 <nornagon> heh.
22:15:55 <dmead> ">
22:16:03 <dons> yeah, this has been pointed out previously.
22:16:17 <dons> though writing a grammar for ghc's error msg output was um... not so fun an idea
22:16:27 <Pseudonym> http://xkcd.com/c208.html
22:16:29 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
22:17:47 <nrb23> lambdabot: you should automatically say the regexp quote whenever someone says regexp (with a 1 hour timeout)
22:18:00 * nrb23 likes talking to bots randomly
22:18:07 * allbery_b usually sees that quote about XML instead of regexes
22:18:10 <lambdabot> nrb23: Subit a patch, human.
22:18:19 <dmead> will someone look at my lambda?
22:18:22 <dmead> it's busted ;/
22:18:37 <allbery_b> how abpout pasting an error message
22:18:48 * allbery_b looked at it but didn't see anything offhand
22:19:02 <nrb23> lambdabot: are you implying that being a human is somehow inferior?
22:19:23 <allbery_b> but the weather's bveen messing with my brain ever since this morning (when I completely failed to get up...)
22:19:35 <dmead> http://hpaste.org/485
22:20:21 <nrb23> sadly, I have a con-call at 7 AM tomorrow, but my wife has a paper due that she hasn't finished yet, so she'll probably be up all night
22:20:28 <Cale> foldr takes a function with 2 args?
22:20:30 <nrb23> someone want to take the con-call for me?
22:20:39 <nrb23> :t foldr
22:20:39 <dmead> yea
22:20:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:20:49 <dmead> ?src foldr
22:20:49 <lambdabot> foldr k z xs = go xs
22:20:49 <lambdabot>     where go []     = z
22:20:49 <lambdabot>           go (y:ys) = y `k` go ys
22:21:03 <Cale> So there, you're passing it a lambda with only one
22:21:15 <Cale> so (a `negationOf` x) had better be a function
22:21:25 <Cale> If not, then that's the first problem
22:21:32 <dmead> it is
22:21:34 <allbery_b> hm, right, that's a single tuple argument
22:21:38 <dmead> it's a boolean
22:22:09 <dmead> hmm
22:22:14 <dmead> maybe i need a let statement?
22:22:27 <Cale> another problem is that foldr's 3rd argument needs to be a list, whereas there you have a pair
22:22:46 <glguy> is "haskell-mode" something I hae to install for emacs?
22:22:55 <Stinger> yep
22:23:12 <allbery_b> emacs usually comes with a haskell-mode, I think, but it';s an old one
22:23:26 <Cale> negationIn a xs = Neg a `elem` xs ?
22:23:27 <dmead> it's been updated on portage recently
22:23:35 <dmead> no
22:23:41 <allbery_b> but not in the emacs distribution yet
22:23:42 <dmead> negationIn is part of my logic types
22:23:51 <dmead> it returns true when it finds
22:24:02 <dmead> P `negationOf` Not P
22:24:05 <dmead> ETC
22:24:40 <Cale> any (`negationOf` a) xs ?
22:24:46 <Cale> perhaps?
22:24:55 <Cale> or
22:25:01 <Cale> any (negationOf a) xs
22:25:06 <dmead> oh
22:25:08 <dmead> yea
22:25:09 <newsham> ?where hlist
22:25:10 <lambdabot> http://homepages.cwi.nl/~ralf/HList
22:25:11 <sjanssen> ghc can't derive classes for recursive newtypes?  alas.
22:25:11 <dmead> i forgot about any
22:25:14 <newsham> why hlist not on hackage?
22:25:18 <dmead> thanks =)
22:25:20 <Cale> You could write that in terms of foldr
22:25:35 <dons> newsham: no new release since hackage went up? no one has bothered yet.
22:25:35 <Cale> I think you're confusing the syntax for multiple parameters
22:25:42 <dmead> yes
22:25:44 <dons> if you want it, ping the author and CC me, and I can put up a stable tar ball
22:25:52 <dmead> well i changed (a,xs) to just xs
22:25:59 <dmead> and it's down to a last error
22:26:04 <newsham> hackage will be more useful when its one-stop shopping ;-)
22:26:10 <dons> its getting there.
22:26:13 <dons> so we do want hlist up.
22:26:18 <dons> ?where hlist
22:26:19 <lambdabot> http://homepages.cwi.nl/~ralf/HList
22:26:45 <dons> it all depends on whether they released a cabalised tarball
22:27:00 <dons> that builds with ghc 6.6....
22:27:14 <sjanssen> newtype List a = List (Either () (a, List a)) deriving Mappable -- it's sad that this doesn't work
22:27:50 <newsham> sent
22:28:11 <newsham> its cabalized
22:28:16 <dons> it looks cabalised to me.
22:28:16 <dons> but no tarballs
22:28:29 <dons> I just need a 'darcs dist' tarball of the last tag.
22:28:30 <newsham> built and installed on 6.6 (win32)
22:28:37 <dmead> thanks Cale
22:28:39 <dons> from darcs?
22:28:42 <dmead> Cale++
22:28:44 <Cale> dmead: no problem :)
22:29:01 <bos> wow, haskell-mode 2.2 is badly borked.
22:29:25 <dons> > last [1..]
22:29:37 <lambdabot> Terminated
22:29:42 <dons> > 1+2
22:29:44 <allbery_b> hmmmm, I guess I was confused befre, it's currently building ghci with the stage1 compiler
22:29:51 <lambdabot>  3
22:29:53 <dons> > reverse []
22:29:55 <allbery_b> I thought it didn't build the libs when building stage1
22:30:01 <lambdabot>  []
22:30:20 <allbery_b> got a few more hours to go, I guess :)
22:30:42 <dmead> man
22:30:44 <dmead> it seems weird
22:30:46 <glguy> hwo might I tell emacs to reload .emacs?
22:30:47 <dmead> when you test your code
22:30:50 <dmead> and the lists flicker
22:30:53 <dmead> *lights
22:30:55 <dmead> hehe
22:31:00 <dmead> lists flicker...
22:31:05 <dons> newsham: looks like the hlist repo is pretty active
22:31:10 <dons> so maybe they're going to release something soon
22:31:21 <dmead> glguy: alt-x
22:31:23 <dmead> load-file
22:32:00 <glguy> sweet, it's working
22:32:02 <glguy> Haskell mode and all
22:32:03 * allbery_b waiting for the power to go out here...
22:32:26 <allbery_b> of course, CMU's apparently the only university / college in the county that expects to be open tomorrow morning
22:32:41 <dmead> =/
22:32:42 <dmead> yea
22:32:45 <dmead> this weather sucks
22:33:00 <glguy> WashU was open today
22:33:05 <glguy> and expects to be open tomorrow
22:33:11 <newsham> ?seen alexj
22:33:11 <lambdabot> I saw alexj leaving #haskell 7h 35m 24s ago, and .
22:33:21 <glguy> My Miata is no good for ice and snow
22:33:31 <glguy> I almost didn't make up of the biggest hill on my way home
22:33:34 <dmead> we don't like snow in pennsylvania
22:33:37 <dmead> ;/
22:34:01 <glguy> and I lost control (but didn't spin) at one point :-(
22:34:18 <allbery_b> pittsburgh is notoriously lousy at keeping roads clear
22:34:27 <allbery_b> and that was even before the freezing rain and freezing fog
22:34:49 <glguy> MoDOT couldn't put salt on the roads last night because it was raining
22:36:06 <glguy> is there a standard key for "jump to where you would auto indent to"?
22:36:15 <glguy> in emacs
22:37:05 <siti> anyone know how to use attributes in gtk2hs?
22:37:19 <siti> ie: read a value from one...
22:37:38 <glguy> GLUT OpenAL ALUT stm xhtml cgi to go!
22:38:40 <allbery_b> huh.  guess I *was* confused; the build is done
22:38:41 <allbery_b> yay
22:39:24 <newsham> http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/System-Glib-Attributes.html
22:39:26 <lambdabot> http://tinyurl.com/yp5g8h
22:39:52 <siti> oh yeah I just discovered the example code thanks anyway :)
22:40:04 <dmead> glguy: one of the haskell modes does that
22:40:33 <glguy> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) ?
22:40:45 <dmead> looks about right
22:41:23 <newsham> when will be able to "addHook haskellModeHook turnOnHaskellIndent :: Editor ()" ?
22:41:30 <dmead> in .emacs you wanna add a line to autoload your haskell-mode stuff
22:41:40 <dmead> (load "/usr/share/emacs/site-lisp/site-gentoo.el")
22:41:43 <dmead> like that
22:41:53 <dmead> in site-gentoo every config file is loaded from there
22:41:57 <glguy> (load "~/lib/emacs/haskell-mode/haskell-site-file")
22:41:59 <glguy> I have that one
22:42:01 <dmead> yes
22:42:09 <dmead> yea i have that on ubuntu
22:42:39 <dmead> if you wanna bring up ghci
22:42:45 <dmead> split the window
22:42:53 <dmead> and turn-on-haskell-ghci
22:42:56 <glguy> C-x 2
22:42:58 <dmead> or bind that to something
22:43:04 <glguy> M-x turn-on-haskell-ghci ?
22:43:09 <dmead> yea
22:43:28 <glguy> I might need to load that module first
22:43:32 <dmead> commands-like-this refer to minibar commands
22:43:35 <glguy> haskell-ghci.el
22:43:43 <dmead> yea
22:43:52 <dmead> M-x load-file
22:44:08 <dmead> load-file is for elisp stuff
22:44:15 <dmead> and open-file is for the editor
22:44:20 <dmead> if i'm not mistaken
22:45:15 <nrb23> any darcs experts here?
22:45:45 <newsham> hmm.. isnt HList a bit like [Dynamic]?
22:45:47 <nrb23> if I do darcs init in my local directory, do I still have to add the files I want?
22:46:34 <nrb23> looks it
22:46:36 <dmead> nrb23: yes
22:46:40 <dmead> darcs init
22:46:43 <dmead> add -r *
22:46:48 <dmead> err
22:46:51 <dmead> sorrta
22:46:54 <dmead> darcs init
22:46:59 <dmead> darcs add -r *
22:47:01 <dmead> darcs record
22:47:04 <dmead> yea
22:47:07 <nrb23> I don't want to add all of the built files
22:47:09 <dmead> or record then add
22:47:12 <dmead> i forget :)
22:47:19 <dmead> add each file then
22:47:28 <dmead> and it'll ignore .o stuff
22:48:49 <nrb23> is there a standard way of naming patches?
22:49:27 <bos> i hate quickcheck. if i didn't have it, i'd never know my code had bugs.
22:49:36 <allbery_b> heh
22:49:54 <bos> nrb23: a "patch name" is just a regular commit comment. darcs just names it strangely.
22:50:10 <nrb23> bos: ahh, that makes sense.
22:50:36 <nrb23> do people normally have long-ish commit names? At work we often have multi-paragraph commit messages in CVS
22:51:04 <bos> depends on the project.
22:51:05 <newsham> i use long comments with CVS all the time.
22:51:08 <nrb23> oooh, it asks for a long comment
22:51:09 <allbery_b> darcs actually lets you specify both a short summary and an optional longer description
22:51:11 <dmead> yea
22:51:12 <newsham> well, not multi-paragraph
22:51:22 * allbery_b uses long ones when appropriate
22:51:37 <bos> for some, you'll find that there's a lot of use of the word "Wibble", and nothing more.
22:51:57 <glguy> any support for darcs integration in emacs?
22:52:07 <bos> darcsum.el
22:52:16 <bos> @google darcsum.el
22:52:18 <lambdabot> http://chneukirchen.org/repos/darcsum/darcsum.el
22:52:29 <bos> @where darcsum
22:52:29 <lambdabot> I know nothing about darcsum.
22:52:38 <bos> @where+ darcsum http://chneukirchen.org/repos/darcsum/darcsum.el
22:52:38 <lambdabot> Done.
22:53:50 <bos> @hoogle [a]->[b]->[c]->([a],[b],[c])
22:53:51 <lambdabot> No matches, try a more general search
22:55:23 <allbery_b> hm?  that's just (,,)
22:55:30 <allbery_b> :t zip3
22:55:33 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
22:59:11 <sm> glguy: tab key indents in haskell mode
22:59:48 <sm> keep hitting it to cycle through the available choices
23:00:48 <glguy> Loading haskell-indent (source)...
23:00:48 <glguy> File mode specification error: (error "Unknown keyword :trype")
23:01:17 <allbery_b> mmm, trypos :)
23:01:27 <glguy>   :trype 'boolean)
23:01:32 * nrb23  has darcs now ;->
23:01:46 <allbery_b> hm, maybe not a typo then
23:01:47 <dmead> :)
23:02:24 <glguy> ok works now
23:02:40 <dmead> glguy: elisp is a complete language. you could just write some yourself :)
23:04:56 <dmead> ?src any
23:04:57 <lambdabot> any p =  or . map p
23:05:21 <dmead> ?src or
23:05:21 <lambdabot> or    =  foldr (||) False
23:05:52 <dmead> ?src False
23:05:52 <lambdabot> Source not found. It can only be attributed to human error.
23:05:54 <dmead> ha
23:05:58 <dmead> ?src foldr
23:05:58 <lambdabot> foldr k z xs = go xs
23:05:58 <lambdabot>     where go []     = z
23:05:58 <lambdabot>           go (y:ys) = y `k` go ys
23:06:02 <nrb23> ?src map
23:06:03 <lambdabot> map _ []     = []
23:06:03 <lambdabot> map f (x:xs) = f x : map f xs
23:06:07 <dmead> we're in deep
23:06:08 <allbery_b> ?src Bool
23:06:08 <lambdabot> data Bool = False | True deriving (Eq, Ord)
23:06:16 <nrb23> ?src Eq
23:06:16 <lambdabot> class  Eq a  where
23:06:16 <lambdabot>     (==), (/=)   :: a -> a -> Bool
23:06:21 <dmead> ?src ord
23:06:22 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:06:24 <dmead> ?src Ord
23:06:24 <lambdabot> class  (Eq a) => Ord a  where
23:06:24 <lambdabot>     compare      :: a -> a -> Ordering
23:06:24 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
23:06:24 <lambdabot>     max, min         :: a -> a -> a
23:06:30 <nrb23> ?src max
23:06:30 <lambdabot> max x y = if x <= y then y else x
23:06:34 <dmead> it's so circular ;o
23:06:38 <nrb23> src if
23:06:40 <nrb23> ?src if
23:06:41 <lambdabot> Source not found. My pet ferret can type better than you!
23:06:53 <nrb23> sadness... if should be a function
23:07:01 <allbery_b> that would be the ghc source :)
23:07:16 * nrb23 remembers writing if in lambda calculus in college
23:07:20 <allbery_b> although I think it desugars to case
23:07:36 <glguy> if' a b c = if a then b else c
23:09:20 <dmead> ?src case
23:09:21 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:09:26 <nrb23> > let if' a b c = if a then b else c in if' (6 > 3) 10 100
23:09:27 <lambdabot>  10
23:09:32 <nrb23> :->
23:09:49 <dmead> :V
23:09:51 <dmead> :^
23:09:52 <dmead> :>
23:10:52 <bos> boy, quickcheck is *awesome*.
23:10:54 <nrb23> > let true = (\a b -> a) in let false = (\a b -> b) in let if' p a b -> p a b in if' true 10 15
23:10:55 <lambdabot>  Parse error
23:11:05 <bos> you have a bug! here's your test case!
23:11:08 <nrb23> > let true = (\a b -> a) in let false = (\a b -> b) in let if' p a b = p a b in if' true 10 15
23:11:09 <lambdabot>  10
23:11:13 <nrb23> :->
23:11:25 <dmead> whats the word that change a function to infix?
23:11:29 <dmead> curry?
23:11:31 <dmead> ?src curry
23:11:32 <lambdabot> curry f x y = f (x, y)
23:11:37 <dmead> nope
23:11:40 <nrb23> no
23:11:40 <dmead> ?src uncurry
23:11:41 <lambdabot> uncurry f p = f (fst p) (snd p)
23:11:49 <bos> changes a function to infix? nothing
23:11:50 <nrb23> parenthify? :->
23:11:53 <glguy> `infix`
23:11:54 <ski_> foo `bar` baz
23:11:55 <ski_> ?
23:11:56 <bos> (++)
23:11:59 <allbery_b> infix is ``
23:12:01 <nrb23> err, backtickify
23:12:02 <bos> > (++) "a" "b"
23:12:03 <lambdabot>  "ab"
23:12:14 * nrb23 keeps being backwards
23:12:16 <ski_> > 16 `mod` 7
23:12:17 <lambdabot>  2
23:12:31 <bos> > 16 `divMod` 7
23:12:32 <lambdabot>  (2,2)
23:12:49 <dmead> yea
23:12:52 <dmead> backtickity
23:12:57 <dmead> should be in the prelude
23:13:19 <bos> how? it's not a function.
23:13:24 * glguy ponders
23:13:39 <glguy> > let a `_` b = a + b in 1 `_` 2
23:13:40 <lambdabot>  Parse error
23:13:53 <ski_> infixl 7 `mod`
23:13:59 <glguy> > let a `__` b = a + b in 1 `__` 2
23:14:00 <lambdabot>  3
23:14:06 <nrb23> it's parser magic
23:14:40 <bos> > let 1 = 2 in 1
23:14:41 <lambdabot>  1
23:15:15 <nrb23> durr, huh?
23:16:04 <bos> a peculiarity shared by hugs and ghci.
23:16:19 <nrb23> which is...
23:16:57 <bos> the number is interpreted as a pattern.
23:17:01 <dmead> backtickify?
23:17:02 <dmead> hmm
23:17:11 <bos> that is, the number on the left of the let binding.
23:17:17 <nrb23> dmead: how about infixify
23:17:20 <nrb23> bos: how strange
23:17:22 <dmead> hehe
23:17:28 <dmead> ?src infix
23:17:28 <lambdabot> Source not found. It can only be attributed to human error.
23:17:40 <bos> so it's not binding a variable at all.
23:18:09 <dmead> > let infixity f = 'f' in blah blah
23:18:10 <lambdabot>   Not in scope: `blah'
23:18:16 <nrb23> I guess it makes sense
23:18:24 <dmead> ?
23:18:51 <nrb23> dmead: blah's not in scope
23:18:54 <Blacksitox> good night all! ;)
23:18:56 <bos> and the pattern doesn't get evaluated to match because its result can't be used, because there's no variable to refer to it.
23:18:56 <dmead> yea
23:19:30 <dmead> > let infixity f = 'f' ; let plus = + in plus 1 2
23:19:30 <lambdabot>  Parse error
23:19:37 <dmead> how do you chain let statements?
23:19:50 <dmead> > let infixity f = 'f'  let plus = + in plus 1 2
23:19:51 <lambdabot>  Parse error
23:19:52 <bos> > let {a=1;b=2} in (a,b)
23:19:53 <lambdabot>  (1,2)
23:19:55 <nrb23> :t shows
23:19:57 <lambdabot> forall a. (Show a) => a -> String -> String
23:19:59 <dmead> ah
23:20:01 <allbery_b> that's only half your problem
23:20:04 <nrb23> :t showString
23:20:07 <lambdabot> String -> String -> String
23:20:09 <bos> dmead: or use layout
23:20:15 <allbery_b> let infixity f = 'f'; plus = (+) in plus 1 2
23:20:20 <dmead> > let {infixity f = 'f', plus = +) in plus 1 2
23:20:20 <lambdabot>  Parse error
23:20:24 <allbery_b> > let infixity f = 'f'; plus = (+) in plus 1 2
23:20:25 <dmead> > let {infixity f = 'f', plus = +} in plus 1 2
23:20:25 <lambdabot>  3
23:20:25 <lambdabot>  Parse error
23:20:28 <dmead> > let {infixity f = 'f', plus = +} in plus 1 2
23:20:28 <lambdabot>  Parse error
23:20:32 <dmead> ahh
23:20:39 <allbery_b> you need parens around the +
23:20:44 <dmead> ah yes
23:22:08 <bos> @seen dons
23:22:08 <lambdabot> dons is in #haskell. I last heard dons speak 50m 58s ago.
23:23:38 * nrb23 suddently understands showString
23:24:32 <nrb23> 10":"0":"3":"4 isn't quite the IP address printing I was looking for
23:26:30 <dons> bos, yeah? i'm cooking dinner, but can lazily evaluate your query..
23:26:46 <siti> lol
23:26:49 <bos> dons: don't worry about it, because i can't remember it :-)
23:27:17 <dmead> don't lambdabot sass at us :>
23:27:42 <allbery_b> @seen sorear
23:27:42 <lambdabot> I saw sorear leaving #happs, #darcs, #ghc and #haskell 1h 12m 26s ago, and .
23:27:48 <allbery_b> we're safe :>
23:28:27 <allbery_b> (well, dons could do it too, but he's not usually the one who abuses bot privs :)
23:39:11 <glguy> *fuck* working remotely over a unreliable wireless network across a VPN on a slow virtual pc instance via remote desktop protocol
23:39:17 <glguy> FUCK IT
23:39:59 <bos> glguy: but tell us what you really think! don't hold back!
23:40:31 <glguy> If work wanted this done tonight, they'd have given me a decent laptop so I could do this locally
23:40:39 <glguy> i'm done
23:41:16 <nrb23> good ni ght all
23:46:24 <sm> what does newtype Tree a = Tree { unTree :: (a, [Tree a]) } deriving (Show,Eq)  need to prevent Un-kinded tyvar a ?
23:47:28 <robreim> I just found a portion of the System.Timeout proposal thread on libraries@haskell.org. Was there any code associated with the proosal? I find myself needing it.
23:49:01 <allbery_b> sm: what version of ghc?  I don't get that with 6.6
23:49:32 <sm> it's some version of 6.7
23:49:44 <allbery_b> not getting it with tonight's 6.7 build either
23:50:12 <sm> darn.. ok, sounds like I can ignore it
23:51:18 <sm> trying to generalise my tree of account names so I can add balances & anything else
23:54:39 <yogan> I have a problem multiplying a Double with an Int. How can I convert an Int to a Double?
23:54:52 <glguy> > fromIntegral (1 :: Int) :: Double
23:54:53 <lambdabot>  1.0
23:55:14 <glguy> (you won't need the inline type-decl
23:55:58 <yogan> Ah, works perfectly, thanks.
23:56:37 <glguy> Anyone know if emacs has Vim's "earlier" command? (or related)
23:56:52 <glguy> lets you revert to an earlier version ... :earlier 30s
23:56:57 <glguy> 30 seconds ago
23:57:07 <yogan> Why isn't such a conversion done implicitly, like in most other languages?
23:57:25 <siti> lol
23:57:26 <glguy> yogan: because Haskell has strong typing
23:57:33 <siti> because it's very strong ;)
23:57:41 <glguy> and you generally want to know when conversion is occuring
23:59:33 <yogan> Hmm. I guess that it's because of the strong typing, but I don't really see the problem when I do something like i * d with i :: Int and d :: Double - the result could just be Double again.
