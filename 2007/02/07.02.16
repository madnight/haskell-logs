00:00:03 <DynWind> yeah
00:00:06 <dons> you could do a lambdabot binding fairly cheaply
00:00:06 <quicksilver> and lifting local lets to the level above
00:00:07 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:00:12 <quicksilver> and vice versa
00:00:13 <dons> ?where hare
00:00:13 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
00:00:17 * quicksilver nods
00:00:21 <dons> is supposed to support all this kind of stuff
00:00:32 <quicksilver> Code existing for some of this, but haskell-mode integration for it would be lovely
00:00:40 <dons> though it's a bit hard to build. i wonder if the new ghc-api version is available
00:00:41 <quicksilver> dons: have you seen eclipse's java refactoring?
00:00:44 <DynWind> thanks for the link dons
00:00:50 <dons> quicksilver: nope
00:00:56 <quicksilver> it's ruly beautiful
00:01:03 <DynWind> I was thinking that maybe I could do this as a SoC 2007 project
00:01:06 <quicksilver> you can select a chunk of code and ask it to make a function out of it
00:01:17 <quicksilver> it will correctly pull out all the local variables referenced
00:01:22 <dons> DynWind: yeah, that's possible. Though you'd have to make a strong case. e.g. full emacs and vim integration
00:01:23 <quicksilver> make them paramters (with the correct type)
00:01:41 <dons> and you'd want to start with hare, I think.
00:01:56 <dons> there is scope for a proper interactive emacs mode for haskell as a SoC project though
00:01:58 <newsham> mental note: hare+shim+yi+...
00:02:03 <newsham> lambdabot
00:02:11 <dons> just would need a strong case that the developer could handle all the different tools
00:02:17 <dons> elisp+haskell+ ...
00:02:28 <quicksilver> DynWind: while you're at it, you should enable 'evaluate sub expression in region'
00:02:31 <newsham> i can do without elisp :)
00:02:49 <dons> DynWind: if you want to do this for SoC i suggest getting hacking now.
00:02:53 <quicksilver> DynWind: and a type-safe common sub expression lifter
00:03:03 <dons> if you can demonstrate that you can pretty much do the project on your own, that greatly increases the chances you'd be picked
00:03:06 <DynWind> dons: yes
00:03:12 <quicksilver> (i.e. more than just a regexp based one)
00:03:29 <DynWind> I do need to get up to speed on my haskell (last I've used it is about a year ago)
00:03:42 <dons> yeah, definitely
00:03:51 <DynWind> so the basic idea is sound, yes?
00:03:58 <dons> active contributions to modern projects is a great way to establish your ability
00:04:01 <dons>  DynWind yeah
00:04:05 <dons> look at shim, and hare
00:04:12 <DynWind> ok
00:04:18 <dons> and ghc-api. and hang out here, since its a hot topic at the momeent
00:05:27 <DynWind> ?where shim
00:05:27 <lambdabot> http://shim.haskellco.de/trac/shim
00:06:46 <DynWind> shim seems to be exactly what we're talking about
00:06:54 <DynWind> is it in active development?
00:07:03 <dons> yeah
00:07:35 <newsham> some wishlist notes i've been making - http://www.thenewsh.com/~newsham/x/editor.txt
00:08:13 <DynWind> newsham: duly noted
00:08:21 <DynWind> thanks
00:09:02 <DynWind> Google pulled a fast one this time. I was expecting to have until June to brush up on Haskell!
00:09:44 <dons> yeah, they want to start earlier, and give everyone more time
00:09:51 <dons> it was very rushed last year :-)
00:11:12 <DynWind> it was fun last year :)
00:13:14 <dons> did you participate?
00:16:55 <DynWind> yes. This was mine: http://code.google.com/soc/gnu/appinfo.html?csaid=12DB3A2CE9FF2E1A
00:16:59 <lambdabot> Title: Google Code - Summer of Code - Application Information, http://tinyurl.com/2bb583
00:18:24 * sm gets a grip on module declarations
00:18:45 <newsham> hmm.. i should look at that,  i wrote a small jabber client last year thats not entirely done.
00:19:02 <DynWind> in haskell? :)
00:19:11 <newsham> (dont really like the protocol that much.. but need jabber)
00:19:20 <newsham> no, this was python
00:20:01 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/curchat/
00:20:03 <lambdabot> Title: Directory /~newsham/x/machine/curchat/
00:20:12 <DynWind> I'm sick of coding in C & C++. Which is why I decided that next time I'm gonna do something in Haskell
00:21:35 <newsham> hmm.. this freetalk thing might be what I want
00:22:14 <DynWind> :)
00:22:54 <DynWind> it needs some spit and polish, but is functional
00:22:59 <Vq^> DynWind: good for you :)
00:25:42 <newsham> dyn: where's ortp?
00:26:22 <DynWind> http://download.savannah.nongnu.org/releases/linphone/ortp/sources/ortp-0.7.1.tar.gz
00:26:24 <lambdabot> http://tinyurl.com/2ulh4u
00:26:44 <DynWind> for some reason libjingle only wants 0.7.1, so watch out
00:27:20 <newsham> is it possible to build without the rtp/jingle stuff?
00:28:11 <DynWind> sorry no
00:28:30 <newsham> how's the 0.69 release?  pretty functional if I dont want voice stuff?
00:28:39 <DynWind> for that you might want to try the older version without voice chat support (it'll need loudmouth, though)
00:29:22 <newsham> wuzzat?
00:29:26 <encryptio> there's a function somewhere that removes duplicates. what is it?
00:29:33 <sm> nub
00:29:39 <encryptio> thanks
00:29:41 <DynWind> loudmouth is another XMPP library
00:29:44 * sm goes wild and splits all types into separate modules
00:30:07 <DynWind> 0.69 is pretty good, yes, and without voice
00:30:22 <sm> my classses.. my methodss, precious
00:30:56 <newsham> dyn: do you know if recent versions of LM will work ok or do I need a retro version?
00:31:57 <DynWind> recent versions should work, AFAIK
00:40:13 <sm> is there a good tool for visualising module import structure ?
00:44:21 <flux-> let's say I have a gadt datatype List which can be Empty or NonEmpty, per the wiki page http://haskell.org/haskellwiki/GADT, how do I write an instance of Show for it?
00:44:22 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
00:44:34 <flux-> or where should I place the 'deriving'-keyword?
00:45:22 <flux-> hm, actually, I might've cracked it, explaining the problem does help ;-)
00:47:08 <flux-> no. I've got instance Show (List a Empty) where show Nil = "[]" which works
00:47:13 <Cale> sm: instance Show (List a Empty) where ...
00:47:30 <Cale> instance (Show a) => Show (List a NonEmpty) where ...
00:47:30 <flux-> but instance Show (List a NonEmpty) where show (Cons el els) = show el doesn't
00:48:00 <Cale> you need the fact that a is showable
00:48:13 <dcoutts> dmead, do you mean tutorial docs for gtk2hs, of course there's lots of reference docs.
00:48:35 <flux-> ah, that was it, thanks
00:49:02 <dcoutts> dmead, the demo collection has several examples that do not use glade
00:49:55 <dcoutts> dmead, oh and the gtk2hs website has a hoogle search of it's api docs
01:08:02 <flux-> cale, (still bugging..) how would I create a non-empty conversion from a list? nonEmpty els = foldr (\elem list -> Cons elem list) (Cons (last els) Nil) (init els) works but isn't very elegant
01:08:04 <sm> is there any harm in importing a bunch of unused libraries into a module ? won't slow compilation, will it ?
01:08:44 <flux-> (not to mention not lazy)
01:11:13 <dcoutts> sm, it'll slightly slow compilation but not much
01:11:29 <dcoutts> sm, it won't make the compiled code any slower though :-)
01:12:23 <sm> great. I'd like to do a bunch of frequently-used imports in one utils module and import that everywhere
01:15:01 <Itkovian> it seems like the School of SPAM has been busy: http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
01:15:04 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/fl2dw
01:15:50 <dons> yeah, we need to clean up the page
01:16:47 <dcoutts> dons, we need to upgrade to trac 0.10 with spam filtering
01:17:58 <Cale> flux-: nonEmpty :: [a] -> List a NonEmpty
01:17:58 <Cale> nonEmpty [x] = Cons x Nil
01:17:58 <Cale> nonEmpty (x:xs) = Cons x (nonEmpty xs)
01:19:02 <flux-> figured it at the same time as you wrote it out :), but is there no way to use fold?
01:19:13 <Cale> flux-: the key is that functions returning values of type List x y must always return nonempty lists, or always return empty lists.
01:19:48 <flux-> hm, and the parameters must also be one or the other?
01:20:12 <Cale> The parameters to the function don't matter as much
01:21:33 <Cale> If you try to write it with foldr in the obvious way, then it'll get caught up by the fact that it might return Nil (it's not smart enough to prove that it won't even if you set the pattern matching up so that the input list must have an element)
01:23:25 <flux-> well, thanks for the help, off to hack other things :)
01:26:43 <flux-> apparently there is no sense in having a 'safeTail', because even if it were always safe to perform on a non-empty list, it could return either one of the list types
01:38:38 * dcoutts can parse gtk/gtk.h again
01:38:40 <dcoutts> @yarr!
01:38:41 <lambdabot> What be a priate's favourite cheese?
01:38:41 <lambdabot> Yarrlsburg!
01:40:08 <opqdonut> @yow!
01:40:08 <lambdabot> On the other hand, life can be an endless parade of TRANSSEXUAL
01:40:09 <lambdabot> QUILTING BEES aboard a cruise ship to DISNEYWORLD if only we let it!!
01:41:41 <encryptio> is there an introduction to writing your own monads?
01:42:11 <Slarba> just instantiate your type into Monad typeclass and check your laws ;)
01:43:05 <fuzan> Hey, anyone here use the gentoo haskell overlay?
01:43:12 <siti> yes I am
01:43:44 <siti> btw there is a channel, #gentoo-haskell
01:44:30 <fuzan> siti: how well is it maintained?
01:44:44 <siti> it seems to be good :)
01:44:57 <fuzan> is ghc maintained in it?
01:45:12 <fuzan> i couldn't seem to find it while browsing through it online
01:45:13 <siti> I believe so
01:45:40 <siti> well I installed ghc 6.6 when it was in the overlay
01:45:53 <fuzan> Seems a little silly for it to use darcs though :)
01:45:55 <siti> I think you can install ghc-darcs to fetch latest source
01:46:05 <siti> hehe
01:46:07 <siti> yeah
01:47:09 <fuzan> ghc-darcs isn't a package I can find :\
01:47:12 <siti> people that like haskell seem to love darcs, I am not one of them though
01:47:36 <fuzan> well, it's somewhat nice for smaller projects,
01:47:44 <siti> I have it here hmm I'll try updating...
01:47:55 <fuzan> But after like 500 patches it's a little silly.
01:48:00 <siti> ok
01:48:11 <dons> everything's in darcs. makes sense to have access to that code
01:48:15 <siti> don't you do --partial then it's fine
01:48:54 <fuzan> --partial does what? grab the most recent build?
01:49:55 <siti> yes not the whole repository
01:53:05 <siti> I only have to fetch 282 patches with --partial on the gentoo-haskell repo...
01:53:24 <siti> still more than I would like though
01:53:47 <fuzan> there needs to be another level of revisions with darcs
01:54:31 <fuzan> like after a specific amount of patches, a maintainer can specify that current source tree as a specific revision
01:55:47 <fuzan> and by default, darcs get grabs patches based on the current revision
01:55:55 <fuzan> maybe this is implemented now, but i'm unaware :)
01:58:46 <Itkovian> dons: otoh, working on lesbian prOn might not be such a bad idea :-)
02:00:08 <dons> yeah. great project. important for the community too
02:01:09 <fuzan> ah, i see. --partial does use a "checkpoint" mechanism!
02:02:29 <Itkovian> dons: indeed. we do not wish to exclude minorities, eh
02:02:56 <Itkovian> I mean, the intersection between Haskellers and Lesbians who do prOn is obviously not empty
02:03:20 <Itkovian> So why should they not get sponsored by Google to bring out the best in themselves
02:03:49 <fuzan> Itkovian: How do you know it's not empty?
02:04:35 <Itkovian> Think of it as the Haskell version of the Lesbian Spanking Inferno, as shown in Coupling
02:04:47 <Itkovian> fuzan: A man can hope, can't he?
02:05:06 <Itkovian> fuzan: also, see the SoC Haskell page
02:05:17 <Syzygy-> ...
02:05:46 <resiak> Itkovian: four independent lesbian software developers deciding they need a bit of a spanking?
02:06:00 <Itkovian> resiak: for example, yes.
02:06:10 <Itkovian> But the spanking should be non-discriminatory
02:06:23 <Itkovian> Maybe there's a Spanking Monad lying around
02:07:09 <Itkovian> As all side-effects (I leave those to your vivid imagination) should obviously be contained
02:11:02 <fuzan> woot, paludis + haskell overlay = Coolness
02:18:35 <dcoutts> fuzan, oh?
02:19:05 <fuzan> dcoutts: play yet with paludis?
02:19:11 <dcoutts> nope
02:19:15 <fuzan> know of it?
02:19:18 <dcoutts> yep
02:19:36 <fuzan> it's pretty slick.  i think my portage days are now over.
02:19:48 <dcoutts> so how is it better?
02:19:50 <velco> does it have its loops unrolled ?
02:20:02 <fuzan> yah, it has a couple methods of handling cycles
02:20:08 <dcoutts> velco, now now, no need to be rude :-)
02:20:13 <fuzan> :)
02:20:29 <velco> hard to resist :D
02:20:36 <dcoutts> yeah, I know ;-)
02:21:23 <fuzan> it's proven to be quick, determistic, and complete.
02:21:48 <fuzan> documentation is a little sparse, the project admin is a bit of an elitist
02:22:04 <dcoutts> fuzan, you know there's also a portage dep resolver written in Haskell
02:22:14 <fuzan> Oh yah? name of the projecT?
02:22:28 <dcoutts> I can never remember if it's exi or eix
02:22:43 <dcoutts> but at the moment it needs a bit of maintenance
02:22:54 <dcoutts> to keep up with portage
02:22:58 <fuzan> poo, ghc6.6 build failed :(
02:23:03 <dcoutts> for a while we had several people using it
02:23:12 <fuzan> how's the performance?
02:23:18 <dcoutts> fine
02:23:23 <dcoutts> much better than portage
02:24:12 <fuzan> I've been really compelled lately to attempt writing a package manager. School is just too much work tho :\
02:25:24 <siti> I was doing something of rewriting portage in c... was a learning experience but everyone seems to be doing it now ;)
02:25:39 <fuzan> yah, it is kindof a fad.
02:26:05 <siti> there's pkgcore which is written by one of the portage guys, it's modular and done in python
02:26:21 <fuzan> paludis is pretty slick I must say though ;)
02:26:36 <siti> and there's paludis, there's alot of fighting with lead dev and gentoo devs
02:26:40 <dcoutts> fuzan, well, look at exi and Nix
02:26:46 <siti> it's aweful c++ though...
02:26:53 <fuzan> c++ isn't so awful.
02:26:58 <siti> yes it is :p
02:27:03 <nornagon> *cough*
02:27:17 <siti> haskell trolls help me out ;)
02:27:28 <fuzan> if huge budget games can use it to push millions of polygons, I think it can manage some packages :)
02:27:30 <dcoutts> siti, well if you want a portage replacement in a nice language you could pick up maintenance of exi
02:28:19 <dcoutts> @where exi
02:28:19 <lambdabot> I know nothing about exi.
02:28:21 <siti> well I did have a tiny look at it, but I am wanting to do really small projects that I can complete now I have done to many big ides projects in the past ...
02:28:26 <dcoutts> @where+ exi http://www.iai.uni-bonn.de/~loeh/exi
02:28:26 <lambdabot> Done.
02:28:33 <fuzan> http://www.informatik.uni-bonn.de/~loeh/exi/
02:28:35 <lambdabot> Title: exi
02:28:39 <siti> idea*
02:29:07 * dcoutts -> office
02:29:30 <fuzan> take care all, time to mosee on.
02:29:59 <siti> but haskell would is an awesome language for writing a package management system :)
02:32:15 <dons> ?users
02:32:15 <lambdabot> Maximum users seen in #haskell: 292, currently: 290 (99.3%), active: 36 (12.4%)
02:32:24 <nornagon> :<
02:32:46 <dons> i zapped the state by accident when tearing apart all the hardware in my office
02:33:00 <siti> nooooooo :p
02:33:06 <nornagon> just hax it >:)
02:33:22 <siti> /dev/mem ;)
02:33:32 <nornagon> ouch
02:33:38 <dons> nah, its in darcs, i could revert if i cared enough
02:33:47 <siti> cat /dev/urandom > /dev/mem works wonders
02:33:48 <dons> but likely the high score will be broken again in the next few days
02:33:51 <dons> so, *shrug*
02:37:17 <siti> unsafeInterleaveIO <-- a bit to much of this in exi...
02:39:43 <dons> oh? I guess kosmikus knows what he's doing though...
02:40:02 <siti> ok
02:40:03 <dons> its just the (fairly intuitive) primitive for lazy IO
02:40:09 <dons> ?src unsafeInterleaveIO
02:40:10 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
02:40:18 <dons> i.e. allocate a thunk for the action
02:40:25 <dons> and it will be forced on demand
02:40:29 <siti> ok
02:40:52 <siti> why didn't kosmikus stop working on it?
02:41:13 <dons> no idea.
02:41:17 <siti> ok
02:43:06 * earthy can ask
02:43:39 <earthy> but I guess it's because he was applying for an associate professorship here. ;)
02:44:24 <earthy> and didn't have the time to fix stuff like that
02:45:24 <dcoutts_> siti, ask him but there was one particular problem with non-blocking IO and the tee program.
02:45:24 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
02:49:09 <siti> ok
03:02:56 <nornagon> @hoogle split
03:02:56 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
03:02:57 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
03:02:57 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
03:03:01 <nornagon> @hoogle splitBy
03:03:01 <lambdabot> No matches found
03:03:08 <nornagon> @hoogle [a] -> [a]
03:03:09 <lambdabot> Prelude.cycle :: [a] -> [a]
03:03:09 <lambdabot> Prelude.init :: [a] -> [a]
03:03:09 <lambdabot> Prelude.reverse :: [a] -> [a]
03:03:21 <nornagon> @hoogle (a -> Bool) -> [a] -> [a]
03:03:22 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
03:03:22 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
03:03:22 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
03:07:01 <rahikkala> nornagon: Was one of those what you were looking for, or were you thinking of partition perhaps?
03:07:19 <nornagon> no
03:07:20 <nornagon> :(
03:07:52 <nornagon> i'm looking for something that will take "a\tb\tc" and (== '\t') and return ["a","b","c"]
03:08:05 <nornagon> @hoogle (a -> Bool) -> [a] -> [[a]]
03:08:06 <lambdabot> No matches, try a more general search
03:16:43 <nornagon> haskell.org down? :(((
03:18:45 <dcoutts_> nope
03:18:48 <dcoutts_> not for me
03:19:04 <nornagon> hm
03:19:17 <dcoutts_> I can get to it via http and ssh
03:22:39 <nornagon> fixed, it seems
03:22:45 <nornagon> i just got a timeout.
03:23:09 <nornagon> so, there appears to be no splitBy
03:23:16 <nornagon> i want something like wordsBy
03:27:22 <matthew_-> nornagon: partition?
03:27:46 <matthew_-> mmm. maybe not actually.
03:28:22 <nornagon> not quite.
03:28:26 <quicksilver> I think what you want is to unfold span
03:28:48 <nornagon> that sounds good.
03:30:33 <nornagon> > unfoldr (\a -> Just (span a)) "foo\tbar\tbaz"
03:30:34 <lambdabot>  Couldn't match expected type `(a, a1 -> Bool)'
03:30:59 <nornagon> > unfoldr (\a -> Just (span a)) [] "foo\tbar\tbaz"
03:31:00 <lambdabot>  Couldn't match expected type `(a, a1 -> Bool)'
03:31:10 <nornagon> er.
03:31:40 <nornagon> er.hm.
03:31:42 <nornagon> glah.
03:31:46 <nornagon> can't type today, it seems.
03:32:57 <nornagon> > unfoldr (\a -> Just (span (== '\t') a)) "foo\tbar\tbaz"
03:32:59 <lambdabot>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
03:33:02 <nornagon> hm.
03:33:11 <nornagon> > unfoldr (\a -> Just (span (/= '\t') a)) "foo\tbar\tbaz"
03:33:13 <lambdabot>  ["foo","","","","","","","","","","","","","","","","","","","","","","","",...
03:33:27 <nornagon> > (span (/= '\t')) "foo\tbar\tbaz"
03:33:28 <lambdabot>  ("foo","\tbar\tbaz")
03:34:18 <nornagon> > unfoldr (\a -> let b = (span (/= '\t') a) in (fst b, drop 1 snd b)) "foo\tbar\tbaz"
03:34:19 <lambdabot>  Couldn't match expected type `Maybe (a, [Char])'
03:34:26 <nornagon> > unfoldr (\a -> let b = (span (/= '\t') a) in Just (fst b, drop 1 snd b)) "foo\tbar\tbaz"
03:34:27 <lambdabot>  Couldn't match expected type `[a]'
03:35:04 <nornagon> > unfoldr (\a -> let b = (span (/= '\t') a) in Just (fst b, drop 1 $ snd b)) "foo\tbar\tbaz"
03:35:05 <lambdabot>  ["foo","bar","baz","","","","","","","","","","","","","","","","","","","",...
03:35:32 <earthy> lambdabot *can* be messaged
03:35:38 <nornagon> sorry.
03:35:53 <int-e> > unfoldr (liftM2 (>>) (guard . not . null) (Just . second (drop 1) . span (/= '\t'))) "foo\tbar\tbaz"
03:35:54 <lambdabot>  ["foo","bar","baz"]
03:36:16 <matthew_-> lol.
03:36:28 <nornagon> cool.
03:36:30 <nornagon> I came up with:
03:36:32 <nornagon> > unfoldr (\a -> let b = (span (/= '\t') a) in case fst b of "" -> Nothing ; _ -> Just (fst b, drop 1 $ snd b)) "foo\tbar\tbaz"
03:36:34 <lambdabot>  ["foo","bar","baz"]
03:36:43 <quicksilver> and, indeed, you can practice in ghci/hugs before playing here, which is what I tend to :)
03:37:07 <int-e> nornagon: that will break for "\tabc"
03:37:27 <nornagon> i see.
03:37:29 <matthew_-> my my - there is just so much, even in the prelude that I've never used/seen. let alone all the libraries...
03:37:51 <Cale> iterate (dropWhile (/= '\t')) "foo\tbar\tbaz"
03:37:54 <Cale> > iterate (dropWhile (/= '\t')) "foo\tbar\tbaz"
03:37:55 <lambdabot>  ["foo\tbar\tbaz","\tbar\tbaz","\tbar\tbaz","\tbar\tbaz","\tbar\tbaz","\tbar\...
03:38:02 <Cale> > iterate (drop 1 . dropWhile (/= '\t')) "foo\tbar\tbaz"
03:38:03 <lambdabot>  ["foo\tbar\tbaz","bar\tbaz","baz","","","","","","","","","","","","","","",...
03:38:35 <Cale> > map (takeWhile (/= '\t')) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= '\t')) "foo\tbar\tbaz"
03:38:36 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
03:38:59 <Cale> > map (takeWhile (/= '\t')) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= '\t')) $ "foo\tbar\tbaz"
03:39:01 <lambdabot>  ["foo","bar","baz"]
03:39:08 * Cale is sleepy :)
03:39:12 <int-e> but unfoldr is so much more fun :)
03:39:15 <dons> matthew_-: yeah, you used Control.Applicable or Control.Parallel lately? :-)
03:39:21 <earthy> that looks like it's a lot simpler. :)
03:39:23 <dons> Applicative
03:39:52 <quicksilver> it's surprising there isn't already an unfold of span, though
03:39:56 <quicksilver> seems like a natural enough concept
03:39:59 <matthew_-> dons, err no. Most recent fun and games was with the Control.Concurrent stuff
03:40:32 <Cale> @let unfoldr' p f g = map f . takeWhile p . iterate g
03:40:34 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
03:40:55 <matthew_-> dons: ahh! I see why you pointed out applicative ;-)
03:41:50 <dons> Cale: @let is broken, due to: not sure why
03:41:58 <quicksilver> @pl \p f g -> map f . takeWhile p . iterate g
03:41:58 <lambdabot> flip ((.) . (.) . map) . (. iterate) . (.) . takeWhile
03:42:03 <Cale> Control.Applicable is a magical module that just contains things which are applicable to whatever you're doing right now.
03:42:12 <dons> sounds cool!
03:42:15 <nornagon> quicksilver: much more understandable :)
03:42:21 <nornagon> heh
03:42:31 <earthy> looks like titties.
03:42:34 <quicksilver> Control.Monster contains monster operators which can do anything, but will eat you if you don't keep them under control.
03:42:45 <earthy> so it *must* be hot, right? :)
03:42:48 <quicksilver> yup, it's the well known boobie combinator
03:43:12 <nornagon> lmao
03:43:23 <matthew_-> Control.WorldConquering...
03:43:29 <int-e> > words . map (ap fromMaybe (flip lookup [('\t',' ')])) $ "abc\tdef\thij"
03:43:31 <lambdabot>  ["abc","def","hij"]
03:43:42 <int-e> (cheating)
03:43:47 <nornagon> :P
03:44:03 <Cale> > words . map (ap fromMaybe (flip lookup [('\t',' ')])) $ "abc\tdef hij"
03:44:06 <lambdabot>  ["abc","def","hij"]
03:44:24 <int-e> Cale: I could *swap* ' ' and '\t', twice :)
03:44:36 <quicksilver> better to map '\t' to Nothing
03:44:37 <Cale> indeed you could :)
03:44:42 <quicksilver> and (anything else) to Just foo
03:44:52 <quicksilver> I.e. mayb String to [Maybe Char]
03:44:57 <quicksilver> hmm
03:45:00 <quicksilver> but then you can't use words
03:45:01 <quicksilver> duh :P
03:45:05 <int-e> quicksilver: right.
03:45:20 <quicksilver> think before you type. think before you type. etc.
03:46:06 <matthew_-> wow. Applicative has appeared fast. I guess that's cos it's a library.
03:46:29 <matthew_-> I was thinking the other day that it seems to take about 2 years from a new language feature being proposed to seeing it in ghc stable
03:46:41 <quicksilver> but applicative isn't a new language feature, is it?
03:46:43 <earthy> > words . map (\ x -> if x == '\t' then ' ' else x ) $ "foo\tbar\tbaz"
03:46:44 <lambdabot>  ["foo","bar","baz"]
03:46:45 <matthew_-> eg functional dependencies, associative types etc etc
03:46:50 <matthew_-> quicksilver: indeed!
03:46:55 <quicksilver> although I'm sure conor was muttering to me about applicative more than 2 years ago
03:46:57 <earthy> there, now a first year student can understand it again ;)
03:47:01 <Cale> I hope that the new fusion stuff makes it into GHC
03:47:04 <quicksilver> so I'm not sure it has been faster
03:47:24 <matthew_-> oh ok, my "starting date" was when the paper comes out
03:47:57 <matthew_-> oh, except that one is into a journal so it could  be about 2 years late anyway... ;)
03:48:08 <quicksilver> :)
03:48:08 <dons> Cale: yeah, I think we can do it
03:48:12 <dons> for lists and bytestrings
03:48:21 <dons> we've got simon pj helping, so that's a good sign :-)
03:48:37 <Cale> dons: I mean that generalised fusion stuff from the recent paper
03:48:37 <dons> we really need foldl fusing
03:48:55 <dons> ah, that. not so sure.
03:49:21 <dons> the algo was fun, but the speedup was "never worse" from what I remember about the talk
03:49:43 <dons> a pragmatic response is to use a ghc-optimised fusion mechanism for the main data structures we use ;)
03:49:48 <Cale> http://www.pllab.riec.tohoku.ac.jp/~ohori/research/OhoriSasanoPOPL07.pdf
03:49:51 <lambdabot> http://tinyurl.com/2xoonv
03:49:53 <dons> yeah
03:49:58 <dons> i attended the talk
03:50:41 <Cale> It seemed like he was trying it on the least likely programs to get any benefit out of it.
03:50:45 <dons> the fusion turns loops into doubly nested ones, iirc, which won't be very nice for ghc
03:51:16 <dons> also, the funny example of how often 'foldr' fuses was just broken: they grepped for foldr in the ghc src, not for how often foldr/build fusion happens
03:51:26 <dons> (which is mostly from things like concatMap and list comprehensions)
03:52:18 <Cale> Did they have anything to say about exactly which cases it doesn't apply to?
03:52:42 <dons> there were issues with let-bindings getting in the way, iirc
03:52:49 <dons> its really just the first step in this area
03:53:07 <dons> i'd expect more research to sort out these kind of issues
03:57:16 <dons> a general fusion mechanism, along with more specialised ones for particular data structures, would work though
03:57:40 <dons> i don't think it'll be easy to beat stream fusion on bytestrings, for example, since the domain knowledge is leant on so deeply
03:57:49 <dcoutts_> @arr
03:57:49 <lambdabot> Yeh scurvy dog...
03:57:57 <dons> and ghc is effectively tuned to compile stream fused code
03:58:12 <dcoutts_> yeah, we have the advantage of being able to cheat
03:58:18 <dons> dcoutts_: so we got the 16 core behemoth set up today
03:58:22 <dcoutts_> woo!
03:58:23 <dons> and its *loud* and *hot*
03:58:26 <dcoutts_> hah
03:58:32 <dons> so we had to move it off my desk, and into a spare room
03:58:38 <dcoutts_> good idea
03:58:55 <dons> and then, sometime after I left uni, it shutdown. so I think it might have got too hot
03:58:58 <dons> or the air con stopped working
03:59:05 <dons> anyway, 16 cores, damn fast. and ghc is on it
03:59:06 <dcoutts_> oh dear :-)
03:59:12 <dons> would you like an account? :-)
03:59:22 <dcoutts_> yes please :-)
03:59:28 <dcoutts_> duncan@ ...
03:59:33 <dons> rl said we should only give you one, after you implement the static argument transformation though
03:59:38 <dcoutts_> hah hah
03:59:53 <dcoutts_> how about a nicer core / stg pretty printer?
04:00:00 <dons> mm. ok. that will do.
04:00:04 <dcoutts_> I was re-reading the stg paper
04:00:24 <pjd> map putStrLn $ filter (isMatch myRegex) $ hGetLines stdin
04:00:28 <dcoutts_> I still think it'd be great to have a more operational notation for stg
04:00:29 <pjd> isn't that lazy?
04:00:32 <dons> dcoutts_: oh yes?
04:00:45 <dons> pjd, yep
04:00:54 <dons> though a bit unidiomatic
04:00:59 <pjd> so what's http://cmars.wordpress.com/2007/02/16/untying-the-monad-ian-knot/ complaining about, then?
04:01:00 <lambdabot> Title: Untying the Monad-ian knot « Snakes on a Brain
04:01:13 <dcoutts_> dons, so the paper gives the operational semantics of stg, and perhaps it's just me, but the operational semantics doesn't jump out at me when I look at stg code
04:01:22 <dons> main = getContents >>= mapM_ putStrLn . filter (match re) . lines
04:01:23 <dcoutts_> dons, eg when we're doing an enter or eval etc
04:01:40 <dons> oh, yeah. enter/eval is a bit obscured (and the fast/slow entry points)
04:01:41 <dcoutts_> dons, I want to see very clearly the jumps and the allocations
04:02:06 <dons> pjd, he's a newbie, and a bogging newbie. they always complain ;)
04:02:12 <dons> blogging. I should say
04:02:33 <dons> dcoutts_: hmm.
04:02:36 <dons> the jumps eh?
04:02:49 <dons> you want to compiled stg down one more layer
04:02:59 <dons> but stay in a Core-ish language?
04:03:07 <dons> the allocations are the 'let's though.
04:03:10 <pjd> dons: oh, i see you already commented
04:03:21 <dons> yeah, but i was tired, so didn't both fixing the markup
04:03:53 <dons> so I have this idea to write a core Factor in 100 lines of haskell
04:04:11 <dons> pjd, do you know enough Factor for that to sound plausible?
04:04:37 <dcoutts_> dons, ok, not all the low level jumps, but jumps at the level of the stg abstract machine, ie enter
04:04:37 <pjd> dons: heavens, no
04:04:54 <pjd> but it doesn't sound implausible
04:04:56 <dons> dcoutts_: ah ok. enter foo
04:05:36 <dons> dcoutts_: i want vim (though I guess i'd switch to emacs) support for interactively modifying code and seeing the Core and asm produced for marked regions
04:05:39 <pjd> (the "heavens no" was directed at the "know enough Factor" part)
04:05:42 <dons> can you write that for me? :)
04:05:53 <dcoutts_> hmm
04:05:59 <dons> pjd, yeah, I guessed that . thanks :)
04:06:03 <dcoutts_> needs notes in the code I reckon
04:06:07 <dcoutts_> code/core
04:06:09 <dons> yeah
04:06:12 <dcoutts_> which we do have
04:06:31 <dons> and might need to control inlining
04:06:45 <dcoutts_> well, probably not
04:06:51 <dcoutts_> you don't want to interfere in that
04:06:58 <dcoutts_> just for the sake of tracking
04:07:06 <dons> dcoutts_: did I tell you about my fun experiment with breeding best gcc flags to compile a shootout entry with?
04:07:11 <dons> using this genetic programming library
04:07:16 <dcoutts_> no
04:07:18 <dcoutts_> sounds fun
04:07:29 <dons> it found some bizarre combiation of 50 odd flags, that was 8% faster than the best I could come up with
04:07:34 <dcoutts_> wow
04:07:40 <dons> turning off some sse stuff, turning on other things
04:07:45 <quicksilver> dons: and still produced correct code?
04:07:46 <dons> weird flags i've never heard of
04:07:49 <dons> quicksilver: yeah.
04:07:52 <quicksilver> nice
04:08:02 <dons> it took all day to run (a 4 s benchmark, evolved over 4000 generations)
04:08:07 <dons> but it was fun
04:08:11 <dcoutts_> dons, -fricer?
04:08:28 <quicksilver> -fdons-and-sharon-on-the-windshield
04:08:30 <dons> i should send off a mail to the haskell-cafe about this
04:08:55 <dcoutts_> dons, so these were gcc flags for ghc -fvia-C ?
04:09:26 <dons> yeah, i first wrote a model for the ghc flags, then added the gccflags
04:09:32 <dcoutts_> because if they're generally good then I'm sure Simon M would like to know
04:09:35 <dons> and the tool experiments with the flags breeding the best set
04:09:47 <dcoutts_> if the set is reasonably stable
04:09:52 <dons> right. i think this might be the way to work out what values of -fliberate-case and so on are most useful
04:10:06 <dons> since it does automatically what we try to do manually
04:10:11 <dons> and you can control what flags it uses
04:10:26 <dons> so you could have it just work out what value of a particular N is best
04:12:11 <dons> after a day's work, it (alcovea) suggested I use this for the 'recurisve' benchmark, ghc -no-recomp -O -optc-march=pentium4 -fcase-merge -fdo-eta-reduction -fno-full-laziness -funfolding
04:12:15 <dons> -update-in-place -fliberate-case-threshold=10 -optc-fno-merge-constants -optc-fno-thread-jumps -optc-
04:12:18 <dons> fno-guess-branch-probability -optc-fno-if-conversion -optc-fno-if-conversion2 -optc-ftree-ccp -optc-f
04:12:21 <dons> tree-dse -optc-ftree-sra -optc-ftree-fre -optc-ftree-ch -optc-fmerge-constants -optc-fcrossjumping -o
04:12:25 <dons> ptc-fcse-follow-jumps -optc-fcse-skip-blocks -optc-fgcse -optc-fexpensive-optimizations -optc-fstreng
04:12:28 <dons> th-reduce -optc-frerun-cse-after-loop -optc-frerun-loop-opt -optc-fcaller-saves -optc-fregmove -optc-
04:12:31 <dons> fdelete-null-pointer-checks -optc-fsched-spec -optc-freorder-blocks -optc-freorder-functions -optc-fa
04:12:32 <LoganCapaldo_> LOL theres a -fdo-eta-reduction?
04:12:34 <dons> lign-loops -optc-falign-labels -optc-ftree-pre -optc-finline-functions -optc-funswitch-loops -optc-fprefetch-loop-arrays -optc-ftracer -optc-fbranch-target-load-optimize -optc-fno-function-cse -optc-fgcse-las -optc-fvariable-expansion-in-unroller -optc-mno
04:12:34 <LoganCapaldo_> Awesome
04:12:38 <dons> -push-args -optc-mno-align-stringops -optc-minline-all-stringops -optc-mfpmath=sse
04:12:41 <dons> (sorry, but I just had to ;)
04:12:50 <dons> some of the flags are probably noise
04:12:55 <LoganCapaldo_> there needs to be a version that uses the unicode eta symbol
04:13:07 <dons> it tries to pick a reasonable subset, and decided on, -optc-march=pentium4 -fcase-merge -fdo-eta-reduction -optc-fno-if-conversion -optc-fcse-skip-blocks -optc-freorder-blocks -optc-fgcse-las -optc-mfpmath=sse
04:13:35 <dons> dcoutts_: know what -optc-freorder-blocks does? sounds useful..
04:13:47 <dcoutts_> I've heard of it
04:14:30 <dcoutts_> dons, though apparently it's included in -O2
04:14:51 <dons> right. so its the interaction with other things that alcovea handles
04:14:58 <dons> since it sectively can turn on and off flags
04:15:04 <dons> fun!
04:16:46 <dcoutts_> dons, erm but presumably it's using -optc-O2  too?
04:16:53 <dcoutts_> -freorder-blocks
04:16:53 <dcoutts_>     Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.
04:16:53 <dcoutts_>     Enabled at levels -O2, -O3.
04:17:27 <quicksilver> sounds like an eminently sensible optimisation for a language like haskell where block order is arbitrary anywhere
04:17:48 <dcoutts_> dons, -freorder-functions is more interesting :-)
04:17:51 <dcoutts_> http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Optimize-Options.html#Optimize-Options
04:17:54 <lambdabot> Title: Optimize Options - Using the GNU Compiler Collection (GCC), http://tinyurl.com/ys5zg4
04:25:54 <roconnor> > [x*10^^(-y)|[x<-[0.5,0.25,0.2,0.1],y<-[1..]]
04:25:55 <lambdabot>  Parse error
04:26:36 <roconnor> > [x*10^^(-y)|x<-[0.5,0.25,0.2,0.1],y<-[1..]]
04:26:38 <lambdabot>  [5.0e-2,5.0e-3,5.0e-4,5.0e-5,5.0e-6,5.0e-7,5.0e-8,5.0e-9,5.0e-10,5.0e-11,5.0...
04:26:55 <roconnor> > [x*10^^(-y)|y<-[1..]x<-[0.5,0.25,0.2,0.1]]
04:26:56 <lambdabot>  Parse error
04:27:02 <roconnor> > [x*10^^(-y)|y<-[1..],x<-[0.5,0.25,0.2,0.1]]
04:27:04 <lambdabot>  [5.0e-2,2.5e-2,2.0000000000000004e-2,1.0000000000000002e-2,5.0e-3,2.5e-3,2.0...
04:27:39 <roconnor> > [x*10**(-y)|y<-[1..],x<-[0.5,0.25,0.2,0.1]]
04:27:40 <lambdabot>  [5.0e-2,2.5e-2,2.0000000000000004e-2,1.0000000000000002e-2,5.0e-3,2.5e-3,2.0...
04:38:00 <sm> night all
04:39:45 <matthew_-> > length $ takeWhile (/= 0.0) [x*10**(-y)|y<-[1..],x<-[0.5,0.25,0.2,0.1]]
04:39:46 <lambdabot>  1289
04:44:35 <quicksilver> that will vary y and never vary x, I believe
04:54:29 <dons> pjd, btw, the entire apotheon thread is truly bizarre and scary. he had some kind of brain explosion, and inflicted it on us all
04:57:56 <matthew_-> > null $ filter ((==3).snd) [(x,y)|x<-[1..],y<-[1,2,3]]
04:57:57 <lambdabot>  False
04:58:06 <matthew_-> quicksilver: other way round ;)
04:58:42 <matthew_-> oh, sry, that test is wrong for your belief.
04:59:02 <quicksilver> > [(x,y)|x<-[1..],y<-[1,2,3]]
04:59:03 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5,...
04:59:11 <matthew_-> yep, that'll do!
04:59:11 <quicksilver> nonetheless, I was wrong
04:59:14 <quicksilver> :)
04:59:25 <quicksilver> > [(x,y)|x<-[1,2,3],y<-[1..]]
04:59:27 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
04:59:34 <matthew_-> you see - testing stuff out in ghci is harder cos it doesn't do the nice pruning of output the lb does
04:59:46 <quicksilver> just use 'take 10' :P
04:59:50 <dons> matthew_-: hmm!
05:00:03 <matthew_-> > null $ filter ((/=1).fst) [(x,y)|x<-[1..],y<-[1,2,3]]
05:00:04 <lambdabot>  False
05:00:10 <matthew_-> ...is what I was after!
05:00:29 <matthew_-> > null $ filter ((/=1).fst) [(x,y)|x<-[1,2,3],y<-[1..]]
05:00:30 <pjd> dons: heh, yeah, it's very strange
05:00:33 <lambdabot> Terminated
05:00:53 <pjd> i bailed ship early
05:01:42 <pjd> jumped ship, even
05:39:11 * ulfdoz wants a progress bar for ghc-build.
05:47:21 <chessguy> 'morning haskellers
05:55:03 <quicksilver> "Peirce, by the way, is pronounced like purse."
05:55:22 <quicksilver> thus spake Dan Piponi. I beg to differ. I've always pronounced him 'pierce'
06:08:55 <vincenz> dons: hmm, maybe a quick haskell-based reddit :)
06:09:07 <pjd> haddit
06:09:29 <vincenz> hadit
06:09:32 <quicksilver> haddit, diddit, woretheshirt?
06:09:39 <quicksilver> worethehairshirt?
06:09:51 <vincenz> eatslambdasforbreakfast
06:10:25 <psnl> so that was the crewy bit in the porrige
06:11:28 <vincenz> http://www.xkcd.com/
06:11:31 <vincenz> *snickers*
06:12:46 <pjd> "Let there be brackets..."
06:12:51 <pjd> "(moments later) No! Not that many!"
06:13:16 <vincenz> (no ((no ((( ( ) (()()((( NOOOOOO!!!!!))))))))))
06:17:14 * vincenz cough
06:17:46 <chessguy> hehe
06:18:07 <SamB> so... did god use the Evil Mangler and Evil Driver and pugs?
06:19:09 <chessguy> i'm curious, does anyone read the xkcd alt texts? or is it just me?
06:19:27 <SamB> when I remember/accidentally hover over them
06:19:58 <SamB> read the regexes... heh.
06:20:03 <chessguy> i always make a point to check them. they're almost as good as the comic
06:20:22 <SamB> except they are actually "title"
06:20:25 <SamB> not "alt"
06:20:34 <vincenz> chessguy: alt?
06:20:41 <chessguy> yeah, title, sorry
06:20:47 <chessguy> i thought they were in the alt tag
06:20:57 <vincenz> chessguy: where are these?
06:21:05 <chessguy> right-click the picture
06:21:07 <SamB> vincenz: xkcd.com
06:21:11 <chessguy> for today's, look for "We lost the documentation on quantum mechanics.  You'll have to decode the regexes yourself."
06:21:16 <SamB> or hover over it
06:21:30 <vincenz> SamB: oh!
06:21:44 <vincenz> doesn't show it all :/
06:21:51 <SamB> right click
06:21:56 <SamB> choose "properties"
06:22:16 <SamB> resize window to be able to see "title" text
06:22:44 * vincenz nods
06:22:44 <vincenz> th
06:22:45 <vincenz> x
06:22:50 <chessguy> or view source and search on jpg" title="
06:23:36 <SamB> don't ask how it works in ie ;-)
06:24:04 <SamB> though that last suggestion, of course, would apply
06:24:18 <SamB> since notepad has a search command
06:29:07 <earthy> ?seen lambdabot
06:29:07 <lambdabot> Yes, I'm here. I'm in #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #
06:29:07 <lambdabot> haskell
06:36:04 <hpaste>  Cheery pasted "Trouble with monads again." at http://hpaste.org/513
06:38:19 <Cheery> Could somebody explain what is wrong with the code I pasted?
06:41:39 <vincenz> Cheery: >>= is of type : a -> m b
06:41:45 <vincenz> Cheery: you're constraining it to be a -> m a
06:42:09 <vincenz> Fetch (a -> FetchPipe b)
06:42:12 <vincenz> try that in your fetchpipe def
06:42:35 <Cheery> vincenz: ok...
06:43:35 <twanvl> This happens because in \n -> ..., n is of type b (because that is what you are returning), and 'pipe' is a function (a -> ...)
06:43:51 <vincenz> twanvl: more like the other way around
06:43:52 <Cheery> vincenz method, no luck.
06:44:23 <Cheery> Kind error: `FetchPipe b' is not applied to enough type arguments
06:45:36 <chessguy> ?src (>>=)
06:45:37 <lambdabot> Source not found. I feel much better now.
06:45:43 <chessguy> ?src Monad
06:45:43 <lambdabot> class  Monad m  where
06:45:44 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
06:45:44 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
06:45:44 <lambdabot>     return      :: a -> m a
06:45:44 <lambdabot>     fail        :: String -> m a
06:45:50 <quicksilver> chessguy: I don't understand how that can be a monad
06:45:56 <quicksilver> Cheery: oops that was for you
06:46:07 <quicksilver> Cheery: monads have a single type parameter
06:46:34 <quicksilver> and >>= is suppose to bind 'a' monads to 'b' monads
06:46:46 <quicksilver> I'm not sure how you can bind an 'a' FetchPipe to a 'b' FetchPipe
06:47:04 <vincenz> quicksilver: yeah, I think his daata-type is not monadic
06:47:35 <quicksilver> Cheery: maybe you can explain a little of the intuition behind the type
06:48:06 <chessguy> maybe somehow Pipe a could be a monad
06:48:16 <Cheery> Hmm, so it simply does not fit?
06:48:43 <Slarba> Cheery. (\x -> return [x]) is of type (a -> m [a]). look at the first param of (>>=) ?
06:48:45 <chessguy> Cheery, our crystall ball is currently out of order. you're going to have to give us a description of what you're doing
06:49:05 <quicksilver> you might have a monoid there
06:49:35 <Cheery> quicksilver: my intention is to write nondeterministic incremental parsers.
06:49:37 <quicksilver> that's not clear either
06:49:53 <quicksilver> nondeterministic? tricky, on a turing machine
06:50:04 <quicksilver> or do you mean breadth-first find-all-parses?
06:50:23 <Cheery> they'd simply take a value, then either return lambda which does same, match or fail,
06:51:57 <twanvl> Maybe you want: data FetchPipe input a = Fetch (input -> FetchPipe input a) | ... ? So input is the same everywhere, and it is not the same as the returned type.
06:52:17 <chessguy> ?src Monoid
06:52:18 <lambdabot> class Monoid a where
06:52:19 <lambdabot>     mempty  :: a
06:52:19 <lambdabot>     mappend :: a -> a -> a
06:52:19 <lambdabot>     mconcat :: [a] -> a
06:53:04 <Cheery> I'm not sure whether this fits monad thought, I can check it yet once.
06:53:10 <quicksilver> twanvl: I still don't see how bind would work on that
06:53:23 <Cheery> I were before thinking a bit different thing, but this turned out to be 'shortcut'
06:53:33 <quicksilver> twanvl: how do you bind a pipe with inputa to a pipe with inputb?
06:54:09 <Cheery> return a >>= f ..
06:54:10 <twanvl> quicksilver: You have an instance Monad (FetchPipe input), so input is the same type.
06:54:27 <Cheery> FetchSuccess a >>= f = f a
06:54:54 <Cheery> m >>= return ..
06:55:30 <paolino> hi, I have another leak report after Cont. Also Writer leaks and consequently (I think) RWS
06:56:04 <Cheery> this may also apply.
06:57:43 <Cheery> the last monad law I'm not sure about, but lets consider. it means that (a >> b) >> c would be same as a >> (b >> c) ?
06:58:03 <quicksilver> Cheery: no, that's not true
06:58:15 <paolino> runWriter (runStateT (let loop = get >> loop  in loop >> tell [()]) ()) ()
06:58:15 <quicksilver> erm
06:58:21 <quicksilver> Cheery: yes, that is true :)
06:58:24 <quicksilver> Cheery: sorry, misread it
06:58:26 <paolino> this makes my mmory explode
06:58:56 <chessguy> paolino, ouch. more problems? :(
06:59:13 <paolino> try that and see
06:59:19 <paolino> not here please
06:59:41 <Cheery> so, if I've few lifted list constructors, how I couple them shouldn't matter.
07:00:58 <paolino> chessguy: should be noted that tell is not in the loop, I put it there to fix the type
07:01:46 <paolino> so, Writer leaks even if you don't use it
07:02:08 <paolino> it's the binding mechanism which leaks, I suspect
07:02:31 <chessguy> ?src Writer
07:02:31 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:02:47 <chessguy> ?source Writer
07:02:48 <lambdabot> Writer not available
07:02:51 * chessguy sighs
07:03:06 <Cheery> lets see. I take (\x -> return [x]) >>= (\a y -> return $ y:a) >>= (\a z -> return $ z:a)
07:03:30 <Saizan> paolino: but but you have an infinte amount of closures there
07:03:32 <paolino> also, Reader and State don't
07:03:55 <paolino> runReader (runStateT (let loop = get >> loop  in loop) ()) ()
07:04:00 <paolino> this is safe
07:04:02 <chessguy> so Cheery's problem raises an interesting question. how do you know, intuitively, without working out all the details, whether or not what you have is a monad?
07:04:43 <Saizan> you make graphs?
07:04:52 <paolino> Saizan also in the Reader example
07:04:59 <hpaste>  twanvl annotated "Trouble with monads again." with "Is this what you want?" at http://hpaste.org/513#a1
07:05:54 <Cheery> twanvl, yes, and I fixed it.
07:06:05 <vincenz> twanvl: you prolly mean 'input of type 'a'' not i
07:06:11 <twanvl> yes
07:06:53 <paolino> Saizan, but fortunately , the Reader and State don't leak, so we can put up a service without seeing it explode after a while
07:08:01 <paolino> (if we don't use Writer for logging)
07:08:21 <quicksilver> paolino: you should probably post that memory leak to haskell-cafe
07:08:30 <quicksilver> paolino: I'm not qualified to comment on it :)
07:08:48 <quicksilver> chessguy: intuitively, a monad is a container which encapsulates computation
07:08:58 <quicksilver> chessguy: in practice, I would attempt to define return and join
07:09:04 <quicksilver> (or return and bind)
07:09:10 <paolino> My question is, what is the difference between State and Writer so that Writer is unusable?
07:09:27 <paolino> thanks quicksilver I will
07:09:57 <bd_> chessguy: If you suspect you have a monad, but don't know, try defining the monad operations on it and seeing if the monad laws hold
07:10:00 <Slarba> HAHA job security index = 1 / maintainability
07:10:25 <quicksilver> in his case, I'd look hard at join : FetchPipe FetchPipe a -> FetchPipe a
07:10:28 <quicksilver> and see if I could work it out
07:10:28 <bd_> Slarba: 1 / (maintainability * time needed to rewrite)
07:10:56 <Slarba> bd_: that may be more accurate ;)
07:11:25 <quicksilver> the hard case is the Fetch case
07:11:38 <Slarba> but you want to maximize the denominator... so you should minimize the rewrite time
07:11:45 <Slarba> eh minimize
07:11:56 <qwr> time needed to rewrite decreases job security index?
07:12:03 <Cheery> quicksilver: it works correctly when I read it with left precedence.
07:12:06 <Cheery> I test with right.
07:12:31 <Slarba> hm
07:12:40 <Slarba> Friday logic
07:12:42 <Slarba> :D
07:17:30 <Cheery> ok, I think it obeys third law.
07:18:20 <gour> what's the recommended library for db-related stuff for sqlite3?
07:18:39 <cmarcelo> ahoy. who's the right person to ask for an account in (darcs.)haskell.org? (I want to host HsJudy library there...)
07:18:56 <Cheery> But I'm not sure whether it is a monad.
07:20:03 <quicksilver> Cheery: can you define 'join' ?
07:20:35 <bakert> How can I get a copy of a file as it used to be at patch "foo" using darcs?  Make a patch and apply it?
07:20:38 <Cheery> it kind of binds computations together too, but there's one weird thing about it.
07:20:50 <quicksilver> nah, not bind. join.
07:20:58 <quicksilver> I often find join simpler to understand than bind
07:21:09 <quicksilver> > join (Just (Just 6))
07:21:14 <lambdabot>  Just 6
07:21:19 <vincenz> cmarcelo: ask lemmih
07:21:24 <quicksilver> > join [[1,2],[3,4,4]]
07:21:25 <lambdabot>  [1,2,3,4,4]
07:21:32 <quicksilver> > join (Just Nothing)
07:21:33 <lambdabot>  Nothing
07:21:37 <vincenz> > join (+) 1
07:21:38 <lambdabot>  2
07:21:43 <chessguy> if you can defind bind, you can define join
07:21:45 <quicksilver> vincenz: I don't think that's helpful :P
07:21:49 <quicksilver> clearly
07:21:56 <vincenz> fine fine
07:21:58 <vincenz> > join join
07:21:58 <quicksilver> but since cheery doesn't know if he has a monad yet, and bind seems tricky
07:21:59 <lambdabot>      Occurs check: cannot construct the infinite type:
07:21:59 <lambdabot>       m = (->) (m (m a...
07:22:11 <quicksilver> I was wondering if join would be easier :)
07:22:14 <quicksilver> maybe it isn't
07:22:17 <vincenz> > join const 1
07:22:18 <lambdabot>  1
07:22:44 <dons> cmarcelo: hi!
07:22:51 <dons> cmarcelo: you ask Simon Marlow
07:23:00 <dons> cmarcelo: and, yay, about time! :-)
07:23:03 <dons> we want that code
07:23:29 <vincenz> hsjudy = judy trees?
07:23:33 <Cheery> quicksilver: so.. join removes the 'container' ?
07:23:39 <earthy> almost
07:23:41 <dons> bakert: one thought would be to darcs get your repo into /tmp/ , revert back to the patch you want
07:23:44 <dons> and then you have the file
07:23:48 <quicksilver> Cheery: it explains how to flatten a double container into a single
07:23:53 <dons> :t join
07:23:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:23:57 <earthy> join collapses double containers into single containers
07:24:19 <dons> if the inner and outer container are the same
07:24:28 <dons> you may as we just use one container right/
07:25:12 <quicksilver> If we pretend for a moment that IO is implemented as 'list of syscalls to perform before finally producing value' then join IO IO a -> IO a is just concatenating the syscall lists, for example
07:25:39 <Cheery> Fetch (i -> FetchSuccess o)    this is that tricky thing?
07:25:45 <Cheery> and this:
07:26:07 <quicksilver> well you need join : FetchPipe (FetchPipe a)
07:26:13 <quicksilver> in your original design at least
07:26:18 <quicksilver> -> FetchPipe a, I mean
07:26:53 <quicksilver> so in that 'Fetch' case, we have 'Fetch f' where f :: FetchPipe a -> FetchPipe FetchPipe a
07:27:08 <bd_> quicksilver: sounds like a comonad?
07:27:27 <quicksilver> bd_: http://hpaste.org/513
07:27:31 <quicksilver> bd_: I"m not sure :)
07:29:18 <Cheery> Hmm...
07:29:49 <bd_> hmm
07:30:13 <bd_> If Fetch (a -> FetchPipe a)
07:30:24 <bd_> and we want to apply an a -> b to that
07:30:32 <bd_> we'd end up making a Fetch (a -> FetchPipe b), right?
07:30:35 <bd_> Which is disallowed
07:30:42 <bd_> what's the purpost of this thing? :)
07:30:53 <cmarcelo> dons: tks.. I'll email simon then. Actually we temporarily dropped HsJudy usage in Pugs since my trickery for finalizing the structures was causing some GC errors.
07:31:01 <Cheery> Fetch (\a -> Fetch (\b -> FetchSuccess (a+b)))
07:31:28 <bd_> right, but here >>= would be constrained to FetchPipe a -> (a -> FetchPipe a)
07:31:31 <bd_> but needs to be
07:31:37 <bd_> FetchPipe a -> (a -> FetchPipe b)
07:31:46 <bd_> err, not quite right, forgot the last ->
07:32:00 <bd_> but bascially I don't see how the bind operation could change the contained type
07:32:01 <quicksilver> bd_: yes, that's the other problem
07:32:04 <bd_> more importantly
07:32:09 <bd_> I don't think we can define fmap for this
07:32:16 <quicksilver> bd_: I'm not sure it's a monad at all, I wondered if it was merely a monoid
07:32:23 <bd_> hmm
07:32:24 <cmarcelo> dons: when things are up I'll send a mail to cafe and to chris k...
07:32:34 <quicksilver> Cheery: fmap is another good one to think about
07:32:35 <bd_> mempty = FetchFail
07:32:47 <bd_> mappend (FetchSuccess a) _ = FetchSuccess a...
07:32:51 <bd_> probably works
07:32:53 <quicksilver> Cheery: I often prefer fmap + join to return + bind for 'thinking about monads'
07:33:12 <quicksilver> bd_: that mappend case for Fetch is a bit of a mess, I was too lazy to write it all down
07:33:13 <dons> cmarcelo: GC errors eh? Still, need the code in public, and cabalisable
07:33:16 <dons> then it will live on
07:33:25 <Cheery> quicksilver: I don't find any useful 'join' on doublefetch.
07:33:29 <dons> ?users
07:33:30 <lambdabot> Maximum users seen in #haskell: 296, currently: 296 (100.0%), active: 35 (11.8%)
07:33:41 <quicksilver> Cheery: that may be a sign that this isn't a monad :)
07:33:52 <Cheery> yep.
07:34:22 <Cheery> lets see that fmap.
07:34:34 <Cheery> > fmap (+2) [2,3]
07:34:36 <lambdabot>  [4,5]
07:34:44 <quicksilver> > fmap (+2) (Just 4)
07:34:45 <lambdabot>  Just 6
07:35:00 <quicksilver> fmap (+2) Nothing
07:35:10 <quicksilver> (fmap also know as 'liftM')
07:35:12 <matthew_-> > fmap (+2) Nothing
07:35:14 <lambdabot>  Nothing
07:35:17 <Cheery> > fmap (+2) (Right 20)
07:35:18 <lambdabot>  Right 22
07:35:31 <quicksilver> > fmap (+2) (Left "bugger it broke")
07:35:32 <lambdabot>  Left "bugger it broke"
07:35:36 <hpaste>  bd_ annotated "Trouble with monads again." with "monoid instance" at http://hpaste.org/513#a2
07:35:58 <bd_> that FetchPipe a b looks like an arrow
07:36:15 <cmarcelo> dons: I'll try to get things in shape ASAP.. question: other people can have write access to the repo besides me (in darcs.haskell.org)?
07:36:24 <bd_> or Reader + ErrorT
07:36:32 <quicksilver> @karma+ bd_
07:36:32 <lambdabot> bd_'s karma raised to 3.
07:37:38 <earthy>  5632 dazzle      56.0%  3:11.96   3   100   293   101M  31.2M   124M   267M
07:37:41 <earthy> hm. drat.
07:37:52 <dons> cmarcelo: yes
07:38:03 <Cheery> fmap (+2) (Fetch (\x -> (Fetch (\y -> FetchSuccess (x+y)))))
07:38:04 <dons> you make the group darcs writeable (simon can do this)
07:38:18 <hpaste>  bd_ annotated "Trouble with monads again." with "using the MTL... " at http://hpaste.org/513#a3
07:38:19 <cmarcelo> dons: great.
07:38:38 <Cheery> I can neither think of what that would do.
07:39:56 <Cheery> bd_: I'm not sure.
07:40:17 <bd_>  what is the purpose of FetchPipe?
07:40:43 <chessguy> @undo do { x <- foo; }
07:40:44 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 16}) "Parse error"
07:40:52 <chessguy> awwww
07:40:58 <bd_> Cheery: not valid syntax :)
07:42:13 <Cheery> bd_: I'm writing a kind of parser -thing, which would allow me to stop parsing when there's no input, indicate which states are on and make signals to activate things.
07:43:04 <Slarba> Cheery: Parsec?
07:43:29 <bd_> Cheery: so it should have operations such as take :: a -> Fetch a b ?
07:43:37 <bd_> er
07:43:39 <bd_> a -> Fetch a a
07:44:44 <Cheery> hmm.. yes.
07:46:36 <bd_> you could implement that based on State...
07:47:17 <Slarba> Cheery: in Parsec you can set user states
07:47:24 <Slarba> why do you want to build your own parser?
07:47:25 <Slarba> :)
07:48:16 <hpaste>  bd_ annotated "Trouble with monads again." with "how's this?" at http://hpaste.org/513#a4
07:48:49 <bd_> er, not error, but whatever the throw thing is?
07:49:02 <quicksilver> Cheery: As a general design principle, I don't normally start by thinking 'this is a monad'
07:49:17 <quicksilver> I normally start by thinking 'this is what I want to do, and these are the combinators I need'
07:49:28 <quicksilver> further down the line I may *notice* that I've made a Monad
07:49:35 <hpaste>  bd_ annotated "Trouble with monads again." with "fix the throw" at http://hpaste.org/513#a5
07:49:45 <quicksilver> I have written several parser libraries which turned out to be monadic but I never bothered giving them a monad instance
07:50:07 <quicksilver> (and some which turned out not to be monadic because I did something odd)
07:53:16 * Syzygy- wooots.
07:53:25 <Syzygy-> I'm getting paid to think about Haskell again.
07:54:05 <Syzygy-> Basically, I discovered a pretty damned serious bug in the maths package I'm using, so my prof wants to see feasability of producing a Haskell package doing serious amounts of homological algebra by this time next week.
07:54:09 <Cheery> I reboot my thinking with this thing.
07:55:11 <quicksilver> Syzygy-: homological algebra from scratch in a week? Here, let me get you some coffee :P
07:55:21 <Syzygy-> quicksilver: I don't need to write it.
07:55:27 <Syzygy-> I need to write a specification.
07:55:31 <quicksilver> oh
07:55:35 <quicksilver> 'see feasibility in a week'
07:55:43 <quicksilver> not 'produce haskell package in a week'
07:55:44 <quicksilver> :)
07:55:59 <Syzygy-> Half because my advisor wants to see how the Cool Guys doing Software do it, and half because we need to figure out what "produce haskell package" looks like in terms of time.
07:56:20 <Syzygy-> This, if I write it, which looks pretty darn plausible now, will end up being a very significant part of my PhD. :)
07:57:04 <chessguy> what's homological aglebra?
07:57:38 <quicksilver> like a mathsy-version of those 'make your own bracelet' kits young girls like
07:57:50 <quicksilver> you have a long piece of string and you attach different shapes along the length
07:57:54 <quicksilver> they call them chains, IIRC
07:58:06 <Syzygy-> chessguy: Is this a serious question? Or will you fade out once I start explaining? ;)
07:58:08 <quicksilver> and chain complexes
07:58:54 * Syzygy- has math-overloaded this channel enough as it is: I want confirmation that I have an audience before I outgeek most residents. :P
07:59:01 <Syzygy-> (at least this once ;)
07:59:08 <chessguy> i don't promise to be able to follow, but i'm curious
07:59:16 <Syzygy-> quicksilver: I HAVE to quote that by the way ;)
07:59:39 <quicksilver> Syzygy-: feel free :)
07:59:48 <Syzygy-> chessguy: In topology, we pick a topological space, and calculate its homology and cohomology by transforming it into a sequence of vectorspaces with maps between them in a specific way.
08:00:06 <chessguy> oh, topology
08:00:31 <Syzygy-> The easy way is if you take a cell decomposition: think of a sphere. Place out, say, two vertices, two different paths between them, and stretch sheets to cover the two hemispheres.
08:00:35 <chessguy> that stuff makes my head hurt, even though i don't know anything about it
08:00:50 <Syzygy-> This gives you a canonical decompositions of the sphere into two points, two lines and two sheets.
08:01:37 <Syzygy-> Now, this decomposition, we turn into a _chain complex_ - just as quicksilver was talking about - by putting a 2d vectorspace in degrees 0, 1 and 2: with each dimension corresponding to a building block in our decomposition.
08:02:11 <chessguy> you lost me long ago :)
08:02:18 <Syzygy-> Then we let the _boundary_ of a vertex be the empty set, the boundary of a line be the difference between the vertices, and the boundary of a sheet be the alternating sum of the lines along its real boundary.
08:02:32 <Syzygy-> Then we get a bunch of linear maps, the boundary maps, between a bunch of vector spaces.
08:02:55 <Syzygy-> This construction lets us, in the end, count holes and cavities in the starting space by just taking vector space quotients.
08:03:16 <Syzygy-> Homological algebra is about working with chain complexes, regardless of whether they come from topological spaces or not.
08:04:14 <paolino> eh
08:04:22 <Syzygy-> Hmmm?
08:04:56 <cjeris> Q. How many homological algebraists does it take to change a light bulb?  A. Four.  One to compute the cell decomposition of the old light bulb, two to construct a chain isomorphism between the old one and the new one, and one to declare that the resulting diagram obviously commutes and leave carrying out the actual change to the student.
08:05:28 <Slarba> :D
08:05:46 <quicksilver> I think the bracelets-with-pretty-shapes description was more concise.
08:07:04 <paolino> Syzygy-: An application for dummies ?
08:07:35 <Cale> cjeris: hahaha
08:08:08 <Syzygy-> paolino: Application?
08:08:09 <chessguy> topology is too abstract for me
08:08:15 <Syzygy-> Ehmmmm..... Ehhhh..... Application?
08:08:41 <Syzygy-> Now you listen to me, young boy, this addiction you have to APPLYING things all the time! It's DANGEROUS!
08:08:46 <quicksilver> application of pur mathematics? heresy!
08:08:52 <Syzygy-> This is your brain. This is your brain with applications.
08:09:00 <Syzygy-> Yech.
08:09:02 <quicksilver> paolino: it can be used to proof various deep theorems about stuff
08:09:04 <Syzygy-> ;)
08:09:14 <quicksilver> paolino: you can use it to prove the euler constant business, for example
08:09:19 <Syzygy-> That's probably the best that can be said in a for-dummies area.
08:09:31 <quicksilver> number of points + number of lines - number of cells = X
08:09:34 <Syzygy-> quicksilver: You're still talking about topology, and not homological algebra though...
08:09:36 <quicksilver> or whatever that damn thing is called
08:09:54 <quicksilver> Syzygy-: I thought there was a way to couch that proof in homology theory? I thought I'd been shown it
08:10:04 <Syzygy-> Probably.
08:10:06 <paolino> Which system we often met during life which has a homological aspect ?
08:10:13 <Syzygy-> paolino: Carry bits.
08:10:24 <Syzygy-> http://blog.mikael.johanssons.org/archive/2006/07/carry-bits-and-group-cohomology/
08:10:27 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » Carry bits and group cohomology, http://tinyurl.com/2cyobm
08:11:14 <pjd> @remember quicksilver paolino: it can be used to proof various deep theorems about stuff
08:11:14 <lambdabot> Done.
08:11:37 * cjeris reads that blog entry, then immediately gropes for the nearest crack pipe
08:12:44 <Syzygy-> lambdabot: Crack helps.
08:12:47 <Syzygy-> :)
08:12:53 <glguy> Vertices - Parts + Segments - Faces = 1?
08:13:09 <Syzygy-> glguy: Depends. And I don't know what your parts means?
08:13:13 <quicksilver> glguy: for example
08:13:22 <quicksilver> glguy: but there are a whole family of such equations
08:13:34 <quicksilver> depending what kind of geometry you're talking about
08:13:44 <glguy> 2d euclidian
08:13:55 <Syzygy-> Basically, for a topological space, you can define the Euler characteristic as the alternating sum of the ranks of the homology groups. And this ends up being a topological invariant.
08:14:08 <rethiak> I wish that I understood that blog bost :(
08:14:42 <Syzygy-> So if you work on the plane, then you'll end up with 1, I think. On the sphere, you'll get 0. On a torus, something else.... Something along those lines.
08:15:00 <Syzygy-> rethiak: People give me that a lot. :/
08:15:34 <Syzygy-> To describe WHY I want to do this, I'd offer http://blog.mikael.johanssons.org/archive/2006/11/a-for-the-layman/
08:15:36 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » A&infin; for the layman, http://tinyurl.com/2cegk8
08:16:03 <Syzygy-> It was said, by the carnival of mathematics inaugural poster to be one of the easier posts I have on algebraic topology. With the carry bits being tagged the most difficult.
08:20:07 <rethiak> Syzygy-: I ought to at least understand some of it, but I guess this shows how badly I failed to grok the groups courses I've taken
08:21:26 <quicksilver> Syzygy-: did you really send a letter to your grandparents containing the phrase "a group G is a set of elements together with a binary operation * such that..." ?
08:23:56 <Syzygy-> Yes.
08:24:23 <Syzygy-> And they enjoyed the letters very, very much.
08:24:29 <quicksilver> Syzygy-: awesome. You're the greatest.
08:24:46 <Syzygy-> Both recipients keep (kept: my grandfather died this christmas) them lying around open all the time.
08:24:51 <Syzygy-> :)
08:40:10 <kolmodin> ?tell waern ZTE har (tillsammans med Samsung) utvecklat en basstation som man kan ha i hemmet, för att få bättre mottagning. samtalen går sen via internet. stog en artikel om det i computer sweden. kan det vara något för dig kanske? :)
08:40:11 <lambdabot> Consider it noted.
08:40:39 <Syzygy-> kolmodin: SÃ¥ sÃ¶tt!
08:40:54 <kolmodin> mm?
08:41:07 <kolmodin> hurså? ;)
08:41:29 <ctkrohn> wow, nvidia publicly released the C compiler for the GeForce 8800-series video cards
08:41:40 <ctkrohn> wonder how long until someone ports a haskell compiler to the geforce :)
08:41:47 <kolmodin> killen bor mer eller mindre i en betongbunker och får typ en halv pinne på mobilen om han sträcker ut den genom fönstret
08:42:21 <Syzygy-> Ahhhhhh.
08:42:39 <araujo> morning
08:42:46 <kolmodin> morning araujo!!1
08:42:56 <araujo> kolmodin!!
08:44:29 <dbremner> ctkrohn-the page seems to be down for maintenance right now
08:46:48 <moonlite> ctkrohn: url?
08:50:12 <dbremner> moonlite- this seems to be the right url, but it's down. http://developer.nvidia.com/cuda
08:50:13 <lambdabot> Title: NVIDIA CUDA
08:52:39 <quicksilver> lambdabot was able to fetch enough to get the title..
08:53:51 <quicksilver> @yarr
08:53:52 <lambdabot> Har de har har!
09:06:58 <ctkrohn> moonlite: developer.nvidia.com/object/cuda.html
09:07:13 <ctkrohn> oh, dbremner got it
09:07:32 <dbremner> has any implementation tried this dictionary free approach? http://web.cecs.pdx.edu/~mpj/pubs/pepm94.html
09:07:33 <lambdabot> Title: Dictionary-free Overloading by Partial Evaluation
09:08:47 <dbremner> ctkrohn- nope, the URL I found didn't work. Yours seems to.
09:09:05 <earthy> meh. there's a nasty inefficiency in Dazzle.
09:09:14 <earthy> oh well. on the to do list for next week
09:09:37 <chessguy> ?src Monad
09:09:38 <lambdabot> class  Monad m  where
09:09:38 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:09:38 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:09:38 <lambdabot>     return      :: a -> m a
09:09:38 <lambdabot>     fail        :: String -> m a
09:21:39 <slowriot> has anyone here used yampa?
09:22:47 <erider> yampa.exe?
09:23:23 <slowriot> functional reactive programming
09:23:37 <quicksilver> dbremner: interesting, that woudl appear to be an example of what I was trying to describe yesterday
09:24:50 <Cheery> quicksilver: I think I will try implementing this with continuation passing style.
09:25:03 <quicksilver> Cheery: buzzword-compliance!
09:25:49 <Cheery> hoh, it's really one of things I've most well-understood.
09:26:00 <quicksilver> :)
09:28:06 <Cheery> I originally tried to implement it as a Monad because monads have so nice syntax in haskell. I guess thought that with CPS, it does not look any worse and may actually prove as a tool which I can wrap it around monad later.
09:30:53 <dbremner> quicksilver-I find the idea interesting, largely because I'm skeptical about the code bloat claims.
09:32:12 <quicksilver> dbremner: to me, that is the 'obvious' way to implement it
09:32:25 <quicksilver> dbremner: I was surprised to learn that haskell bothers to pass around dictionaries
09:32:37 <quicksilver> dbremner: I can see you need it over module boundaries, (for separate compilation)
09:32:49 <quicksilver> dbremner: but within a module, you know statically what types you have, in the end
09:50:30 <glguy> ?where haskell-mode
09:50:31 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
09:51:57 <dbremner> quicksilver- http://repetae.net/john/repos/jhc/docs/type-classes.txt from reading this, I gather you need a dictionary to handle some cases.
09:52:05 <slowriot> I guess no one has used yampa :(
09:53:52 <chessguy> slowriot, it's a little slow in the channel right now. maybe ask a little later
09:54:51 <Saizan> ?type \f -> lift $ liftM f get
09:54:55 <lambdabot> forall (t :: (* -> *) -> * -> *) a1 r (m :: * -> *). (MonadTrans t, MonadState a1 m) => (a1 -> r) -> t m r
09:59:05 * dcoutts_ notes that c2hs can parse all the C code generated by ghc when it compiles c2hs -fvia-C
09:59:26 <dcoutts_> next up, glibc and the kernel
10:05:24 <DynWind> ?where ghc-api
10:05:25 <lambdabot> http://www.haskell.org/ghc/
10:06:25 <Slarba> hmm. has anyone tried to use ghc runtime "on bare metal" using flux oskit?
10:11:01 <sjanssen> @google "Eine Kirche, eine Sprache, eine Partei, ein Volk"
10:11:03 <lambdabot> No Result Found.
10:11:25 <sjanssen> @google "one church, one language, one party, one people"
10:11:27 <lambdabot> No Result Found.
10:13:17 <ctkrohn> Slarba: some people tried to make a haskell operating system called House, I don't know if it runs a haskell compiler though
10:13:44 <pjd> http://www.haskell.org/haskellwiki/Libraries_and_tools/Operating_system
10:13:47 <lambdabot> Title: Libraries and tools/Operating system - HaskellWiki, http://tinyurl.com/yhvr5j
10:13:53 <sjanssen> ah yes, it's Nazi rhetoric
10:16:04 <quicksilver> anyone awake with enough tuits to help me remember the hierarchy of termination?
10:16:26 <quicksilver> arithmetic (say, interger) every well typed expression terminates
10:16:50 <quicksilver> simply-typed lambda calculus over the ints, no recursion, it's still true, right?
10:22:06 <roconnor> @type foldr
10:22:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:23:19 <quicksilver> it's only recursion which introduces non-termination
10:23:24 <quicksilver> and \x -> x x isn't typeable
10:23:44 <quicksilver> dbremner: intresting, thanks
10:24:16 <roconnor> @hoogle first
10:24:17 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
10:24:17 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:24:17 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
10:25:01 <Codex_> quicksilver: look for proofs of "strong normalisation" for termination...
10:25:55 <quicksilver> Codex_: right, I'm familiar with that result. familiar, but rusty.
10:26:01 <quicksilver> Codex_: it's been a few years :)
10:26:39 <quicksilver> SO, my next question is, how far can you go without recursion?
10:26:47 <quicksilver> Say, in a minilanguage, I want to be able to manipulate lists. Without explicit recursion I clearly can't work over the constructor in the normal way.
10:27:10 <quicksilver> Are there results about whether (e.g.) map and fold are 'enough'?
10:27:27 <quicksilver> I think 'unfold' will inevitably introduce non-termination, though.
10:29:17 <roconnor> @type isJust
10:29:19 <lambdabot> forall a. Maybe a -> Bool
10:30:17 <roconnor> @type liftM snd
10:30:20 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a, b) -> m b
10:30:29 <roconnor> @type join . liftM snd
10:30:32 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => m (a1, m a) -> m a
10:30:43 <roconnor> @pl join . liftM snd
10:30:43 <lambdabot> (snd =<<)
10:31:21 <pjd> quicksilver: i think you might find this paper very relevant: http://www.jucs.org/jucs_10_7/total_functional_programming
10:31:24 <lambdabot> Title: (D. A. Turner) Total Functional Programming
10:32:40 <quicksilver> pjd: Ah! Turner! Clever chap he is.
10:32:43 <quicksilver> pjd: thanks
10:32:59 <pjd> quicksilver: it's a compelling read
10:33:51 <quicksilver> I may be going down blind alleys to be honest
10:34:11 <quicksilver> but I'm trying to find a simpler way of present lists in a DSL than constructor-matching
10:34:46 <quicksilver> and it occured to me that a good set of combinators might be chosen which were all termination guaranteed
10:34:51 <dpiponi> quicksilver: http://www.nps.gov/dewa/historyculture/upload/cmsstgPEIRC.pdf (.gov so it's gotta be true :-)
10:35:29 <quicksilver> dpiponi: :)
10:36:41 <sjanssen> I've read that "foldr is universal"
10:38:07 <quicksilver> sjanssen: you can't build unfolds with folds though, can you?
10:38:27 <dbremner> quicksilver-IIRC, the Charity language guarantees termination.
10:39:03 <quicksilver> e.g. \x -> [0..x] -- can't be built with fold?
10:39:33 <dpiponi> quicksilver: after reading Bernie Pope's TMR article you can do anything with folds (but I consider it cheating)
10:39:34 <sjanssen> no, you'd need something else for that
10:39:45 <quicksilver> dpiponi: that's folds + general recursion
10:39:50 <dcoutts_> dpiponi, no, he used unfolds too to get fix
10:40:10 <quicksilver> dpiponi: I'm assuming we don't have recursion (or fix)
10:40:30 <dcoutts_> you can make fix with the combination of fold and unfold
10:40:31 <dpiponi> dcoutts: yes, I saw the cheating going on
10:40:51 <quicksilver> I can't think of a terminationn-gauranteed variation of unfold
10:40:57 <quicksilver> unfold just feels inherently (possibly) partial
10:43:54 <astrolabe> quicksilver: did you see a recent paper by Turner on a similar subject?
10:44:47 <alexj_> anyone know who is in charge of the Network.HTTP code at http://cvs.haskell.org/darcs/http/ ?
10:44:49 <lambdabot> Title: Index of /darcs/http
10:45:39 <alexj_> where is Zord64_Hard or Zord64_Easy?
10:47:48 <quicksilver> astrolabe: pjd just pointed me to one
10:48:19 <quicksilver> astrolabe: JUCS 2004?
10:48:22 <astrolabe> Ah :)
10:48:32 <quicksilver> am reading it now :)
10:49:25 <waern> has anyone had problems with the ghc-6.6 in macports?
10:49:25 <lambdabot> waern: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:49:30 <tibbe> the spam among the SoC project ideas doesn't look good
10:50:00 <chessguy> > let double x = 2*x in show double
10:50:03 <lambdabot>  "<Integer -> Integer>"
10:51:01 <DynWind> where are the SoC project ideas, tibbe?
10:51:28 <Igloo> alexj_: That shouldn't be needed these days. You should be able to just use Word64 instead
10:52:23 <tibbe> @google SoC 2007
10:52:26 <lambdabot> http://www.vlsisoc2007.gatech.edu/
10:52:26 <lambdabot> Title: IFIP VLSI SoC 2007
10:52:31 <tibbe> bah
10:52:32 <tibbe> sec
10:52:40 <sjanssen> tibbe: the page hasn't been updated in a year anyway
10:52:59 <tibbe> DynWind, http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
10:53:03 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/fl2dw
10:53:05 <DynWind> ah, I thought the list of ideas for this year was already up :)
10:53:16 <tibbe> sjanssen, then it would be good if it was updated since SoC has started
10:54:35 <tibbe> all haskell.org mentor information seems to be out of date
10:54:42 <tibbe> the old projects are listed as current projects
10:55:12 <alexj_> Igloo: ok then someone should clean it out of Network.HTTP.MD5Aux?
10:55:32 <Igloo> alexj_: Yes
10:55:32 <sjanssen> tibbe: it doesn't seem like google gave haskell.org much (any?) warning
10:56:00 <DynWind> there's still another month until the application period starts
10:57:11 <alexj_> igloo: is that a five min fix or is there more complexity?
10:59:10 <Igloo> alexj_: should be trivial
11:00:22 <tibbe> sjanssen, :/
11:00:57 <alexj_> igloo: ok I don't think I understand the difference btween ZordEasy and ZordHard in that code enough to do it correctly.
11:01:29 <alexj_> mainly I am objecting to #include Foo.hs
11:02:38 <Igloo> alexj_: Unless I'm misremembering, it's just defining a Word64 type called Zord64
11:02:41 <Igloo> Just use Word64
11:04:34 <alexj_> why the #ifdef glasgow_haskell there?
11:04:48 * dmhouse rarghs by way of entrance
11:05:12 * dmhouse hugs 'Every noun can be verbed'
11:05:47 <alexj_> can i just send in a patch that wipes out the ifdef section?
11:07:39 <alexj_> actually everything within the "Nasty kludge" comment?
11:08:41 <Igloo> I don't have the code in front of me, but seriously, just use Word64
11:10:28 <alexj_> ok to whome do I send a patch?
11:10:42 <tibbe> anyone written a web crawler in haskell?
11:12:53 <alexj_> igloo: the comment says there are issues with nhc and/or hugs
11:13:29 <chessguy> tibbe, i doubt it,  haskell's HTTP library is not the best
11:17:26 <hpaste>  (anonymous) pasted "parser fails" at http://hpaste.org/514
11:18:41 <fasta> I think the problem is that the parser cannot understand where the nodes end.
11:19:48 <fasta> I.e. it tries to parse the first number in the triple as a part of nodes.
11:20:37 <fasta> I am not sure how to fix it.
11:21:10 <glguy> say I want to find a key stroke that "joins" two lines in emacs , is there a commmand (similar to C-h k) that would help for searching the docs?
11:21:23 <glguy> C-h a
11:21:58 <glguy> it says "M-x join-line RET"
11:21:59 <ADEpt> glguy: C-h w (where-command)
11:22:12 <glguy> so that means that join-line is not a common command then?
11:22:21 <Slarba> M-^ joins a line to the previous
11:22:39 <glguy> ah, cool
11:22:40 <glguy> thanks
11:22:58 <dr_strangelove> is there a tutorial / documentation on how to use HAppS.DBMS.{Table|Index} ?
11:23:20 <ADEpt> fasta: "parser fails" is yours?
11:23:28 <dmhouse> dr_strangelove: try asking on #happs, or ping alexj_ if he's around.
11:23:28 <Slarba> one macro I found extremely useful is one that moves a line through text
11:23:29 <dr_strangelove> besides the Example.hs which I do not really understand
11:23:31 <fasta> ADEpt: yep, it should be trivial.
11:23:58 <ADEpt> fasta: you seem to be unsure about which parser consumes trailin space/newline, and which not
11:24:00 <Slarba> it's like you grab the line with Ctrl-Shift and then move it up and down with cursor keys
11:24:04 <ADEpt> fasta: hence the problems
11:24:10 <dr_strangelove> dmhouse, ok, didn't know it exist
11:24:27 <ADEpt> fasta: then again, maybe I'm wrong.
11:24:40 <fasta> ADEpt: I am sure of what should do what. I am not sure of how to communicate to the machine, though.
11:25:43 <fasta> ADEpt: Hmm, well, this version isn't a good example.
11:26:19 <inv2004> hi all
11:27:14 <fasta> ADEpt: ignore the line containing newline in parseFlow
11:27:20 <ulfdoz> one day later, still no darcs in sight.
11:27:28 <inv2004> what's remainder of x/y in haskell ?
11:27:38 <ulfdoz> Is the huge amount of memory really necessary for ghc to compile?
11:27:39 <allbery_b> ?hoogle rem
11:27:40 <lambdabot> Prelude.rem :: Integral a => a -> a -> a
11:27:40 <lambdabot> Directory.removeDirectory :: FilePath -> IO ()
11:27:40 <lambdabot> Directory.removeFile :: FilePath -> IO ()
11:27:41 <fasta> ADEpt: even then, it succeeds with only the nodes parsed.
11:27:53 <allbery_b> > 3 `rem` 2
11:27:55 <lambdabot>  1
11:28:32 <fasta> ulfdoz: 800MB or so, right?
11:28:38 <fasta> ulfdoz: it has been that for years
11:29:38 <fasta> ADEpt: do you know have any pointer on making it work?
11:29:52 <ulfdoz> fasta: At least more than 64, which makes it damn slow here. I even created a second swapfile, because it ran out of memory when tried earlier.
11:30:06 <xerox> ?check \x y -> rem x y == mod x (y :: Int)
11:30:06 <fasta> ulfdoz: This is 2007
11:30:07 <lambdabot>  Exception: divide by zero
11:30:22 <xerox> ?check \x y -> (y :: Int) /= 0  ==>  rem x y == mod x y
11:30:23 <lambdabot>  Falsifiable, after 2 tests: 1, -2
11:30:39 <ADEpt> fasta: try combining node and edge parser into one with options (<|>), then 'sepMany ... newline' it
11:30:46 <glguy> what's a faster way to copy a line than C-a C-SPC C-e C-w C-y RET C-y
11:30:48 <ulfdoz> fasta: This is my router and girl for everything I'd like to have darcs on. ;)
11:30:54 <glguy> I'm trying to C-h a and C-h w an answer
11:31:05 <fasta> ulfdoz: cross-compilation?
11:31:07 <glguy> but I'm not quite proficient on the naming convention
11:31:10 <Slarba> glguy: transpose-line
11:31:16 <ulfdoz> glguy: C-a, C-k, C-y
11:31:29 <ulfdoz> fasta: Not yet supported by pkgsrc.
11:31:37 <ulfdoz> I have heard, they work on.
11:31:40 <ADEpt> fasta: or forget anout sepMany for reading nodes - it's too eager for you
11:31:50 <glguy> C-x C-t swaps two lines, but I want to copy one
11:32:10 <rashakil> C-k C-k C-y C-y
11:32:14 <fasta> glguy: C-SPC End M-w
11:32:14 <glguy> OK, the the C-k works
11:32:16 <rashakil> maybe, C-a.
11:32:28 <fasta> glguy: C-k is kill
11:32:33 <glguy> right
11:32:43 <glguy> I just wondered if there was a way to do it without killing first
11:32:43 <Slarba> hm. let me find the nice "move line around" -macro
11:32:46 <fasta> glguy: C-c also works
11:32:51 <fasta> glguy: when you enable CUA
11:35:37 <inv2004> thx
11:36:50 <fasta> ADEpt: sepMany is not in the API
11:37:22 <fasta> ADEpt: I think not using Parsec is easier in this case.
11:38:17 <Slarba> http://slarba.hopto.org/move-lines.el
11:38:24 <Slarba> glguy, check that
11:38:30 <glguy> is it a hassle to get the mouse wheel to scroll emacs?
11:38:47 <DynWind> why do you want to touch the mouse if you're using emacs? :)
11:39:09 <glguy> DynWind: because I use the mouse for other things
11:39:19 <fasta> glguy: emacswiki.org
11:39:25 <glguy> cool
11:39:55 <fasta> emacswiki actually contains information unlike 99% of the websites out there.
11:40:19 <fasta> And you can visit it with w3m :)
11:40:42 <fasta> (but it requires customization before you can search on it)
11:40:55 <fasta> You expected that, didn't you? :)
11:41:27 <glguy> you have to customize the wiki to search the wiki?
11:41:36 <fasta> No, w3m
11:42:08 <fasta> Some UI parts of w3m are better than the popular browsers.
11:42:15 <glguy> C-s C-w is a nifty little trick :)
11:43:09 <fasta> glguy: what does it do? AFAIK, C-s does incremental search, and C-w cuts.
11:43:29 <glguy> C-s does incremental search, but C-w puts the rest of the word after the point in the search
11:43:39 <glguy> C-y puts the rest of the line in
11:44:27 <psi> cool :)
11:44:30 <fasta> ADEpt: I see what you mean, but it requires an extra data structure for holding a value of type EdgeOrNode
11:46:01 <ADEpt> fasta: yep
11:46:03 <tibbe_> if I do a sequence and end up with: m [[a]] what's the idiomatic way to concat those lists to m [a] ?
11:46:14 <glguy> liftM concat
11:47:48 <tibbe_> :t join
11:47:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:48:11 <glguy> yeah, liftM join -- is the same
11:48:34 <mauke> [] join = concat
11:49:25 <glguy> Exchange TextCursor position (Point) and Mark: âC-x C-xâ
11:50:12 <fasta> glguy: did you already do the tutorial?
11:50:22 <glguy> yeah
11:50:29 <glguy> I know the *basic* stuff
11:50:38 <fasta> glguy: what did you use before?
11:50:41 <glguy> http://www.emacswiki.org/cgi-bin/emacs-en/EmacsNewbieKeyReference#EmacsNewbieKeyReference1 -- I'm reading this now
11:50:44 <glguy> fasta: Vim
11:50:44 <lambdabot> Title: EmacsWiki: EmacsNewbieKeyReference, http://tinyurl.com/yw9tt4
11:50:48 <glguy> (and I still do :)
11:51:09 <tibbe_> @type [Maybe a] -> [a]
11:51:11 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
11:51:12 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
11:51:12 <lambdabot>  
11:51:17 <tibbe_> @hoogle [Maybe a] -> [a]
11:51:18 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
11:51:41 <fasta> glguy: I use VIM sometimes (I know the basic stuff), but I use nano more, since it starts to fast.
11:52:04 <glguy> You can tell the difference between how fast your vim and nano start?
11:52:52 <fasta> glguy: yes
11:53:08 <glguy> are you on an older computer?
11:53:28 <fasta> rating 2800+
11:53:45 <fasta> I am not in the multi-core business, yet.
11:54:15 <fasta> I don't see the point in a computer that's not even twice as fast.
11:54:28 <tibbe_> @hoogle guard
11:54:29 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
11:54:29 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
11:54:29 <lambdabot> Language.Haskell.TH.Guard :: data Guard
11:54:34 <fasta> When a 10000+ comes out, I might be interested.
11:54:58 <tibbe_> I want to say, if this value is Nothing return an empty list in the IO monad
11:55:04 <fasta> glguy: what's your opinion on that?
11:55:09 <glguy> I'm on a 2.8ghz p4 running inside vmware... but the delay isn't dramatic
11:55:22 <fasta> glguy: I run native.
11:55:29 <glguy> so it should be faster?
11:55:47 <fasta> glguy: yes, it probably is too.
11:56:05 <fasta> optimized kernel, so you can't win there.
11:56:14 <fasta> dual channel memory
11:56:23 <siti> awesome another nano user :D nano > vim ;)
11:56:36 <glguy> siti: only when you compare the length ;)
11:56:42 <siti> hehe
11:56:54 <fasta> vim when started is also really fast.
11:56:55 <siti> or alphabetical order..
11:56:56 <DynWind> in that case, emacs > nano
11:57:09 <fasta> Too bad none of those editors scales.
11:57:25 <fasta> I.e. editing >100MB files is not fun.
11:57:45 <glguy> both emacs and vim don't keep the whole file in memory though... right?
11:57:55 <fasta> glguy: don't know
11:57:57 <glguy> neither*
11:58:03 <glguy> s/don't//
11:58:09 <glguy> s/and/nor :)
11:58:11 <dmhouse> I can open files > 512MB, so, no.
11:58:47 <dmhouse> Actually, I haven't done that in a while, it might swap, so don't quote me on that.
12:00:32 * Syzygy- uses emacs, nano -and- vim.
12:01:14 * glguy uses emacs (now) vim -and- vi.
12:01:16 <dmhouse> Syzygy-: why?
12:01:37 <dmhouse> One of the tips from The Pragmatic Programmer was to learn one editor, and use it for _everything_.
12:01:37 <Slarba> heh
12:01:40 <fasta> I do use vi, but that's only because some default has it that way, and I can't be bothered to change it.
12:01:47 <Syzygy-> dmhouse: Different tasks, different editors.
12:01:50 <Slarba> I've never managed to learn vi beyond the basics
12:02:01 <glguy> I still like using vim or vi for simple config file editing
12:02:04 * DynWind uses emacs and sed
12:02:05 <siti> my HCI lecturer said people liked vim because it was so hard to learn :)
12:02:09 <pejo> fasta, export EDITOR=nano
12:02:11 <dmhouse> I basically use Emacs, Firefox and Konqueror for day-to-day tasks.
12:02:17 <fasta> pejo: no, some other default
12:02:21 <Syzygy-> If I want to code on a machine where I don't want to fire up X; or if I want to swap back and forth between ghci and an editor quickly, I use vim.
12:02:28 <glguy> I think I could get used to using emacs for longer-term editing, like writing haskell code
12:02:31 <fasta> pejo: and even then it works different on my OS.
12:02:34 <dmhouse> Besides, real men use cat.
12:02:36 <siti> so because they dedicated so much time they have to say they like it otherwise it was a waste of time...
12:02:38 <Syzygy-> If I want to do a quick, tiny edit of something, it's about 50-50 between vim and nano.
12:02:50 <Syzygy-> If I want to write LaTeX seriously, or for occasional coding, I use emacs.
12:03:01 <Syzygy-> AUCTeX+Previewmode+RefTeX = WIN.
12:03:10 <glguy> siti: those sound like the words of someone who couldn't pick up vi and wants to rationalize that it's ok
12:03:11 <Syzygy-> So it depends a lot on what I'm doing at the moment.
12:03:20 <pejo> siti, it's very consistent. Only thing I remember from HCI was "Know the user, know the task" - and the users who prefer vi aren't average users.
12:03:32 <siti> I like kile for latex
12:03:35 <tibbe> how does =~ works, how do I retrieve matched groups?
12:03:43 <Syzygy-> siti: Previewmode though.
12:03:46 <pejo> Syz, I found TeXShop a killer, with an external editor. But thats macos only.
12:03:47 <siti> no he used vim :)
12:04:11 <Syzygy-> pejo: Yeah... I need to sit on linux in order to have access to all things I need to work.
12:04:25 <Syzygy-> And I never could stand the funky TeX-specialised editors.
12:04:29 <glguy> Syzygy-: are those three different programs?
12:04:35 <glguy> Syzygy-: auxtex, reftex and previewmode
12:04:43 <Syzygy-> glguy: Naaaa, they're a bundle of Emacs-modes.
12:04:49 <Syzygy-> Make things pretty and easy in Emacs.
12:04:55 <glguy> Syzygy-: so if I install auctex, that's enough?
12:05:01 <pejo> Syz, it's not an editor - use whatever external editor you like. It's the blazingly fast pdf-viewer that is great.
12:05:04 <CosmicRay> http://xkcd.com/c224.html
12:05:05 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
12:05:11 <Syzygy-> glguy: Probably.
12:05:19 <fasta> glguy: watch out, though. Once you start customizing Emacs....
12:05:22 <Syzygy-> pejo: I dunno, xpdf is fast enough for my reads. :)
12:05:43 <Syzygy-> glguy: The really REALLY funky thing with that combo is the previewmode, which comes bundled with modern enough auctex.
12:05:47 <fasta> wc -l .emacs
12:05:47 <fasta> 1055 .emacs
12:05:56 <Syzygy-> fasta: Whoa!
12:06:02 <fasta> And that's not even all....
12:06:09 <Slarba> fasta huh
12:06:31 <glguy> Syzygy-: I've almost got it installed, I'll have to try it out
12:06:41 <Syzygy-> glguy: mpc723.mati.uni-jena.de/~mik/blingbling.png
12:06:51 <Syzygy-> ^^  That's AucTeX with Preview-mode in action.
12:07:01 * allbery_b used to have a stub .emacs which loaded a .emacs-rc.elc (yes, byte-compiled)
12:07:21 <Syzygy-> RefTeX is gold if you write academically: you can do regexp-searches in your bibtex-files...
12:07:33 <glguy> ah, nifty :)
12:08:14 <dylan> hmm, google summer of code. I should look into that.
12:08:51 <pejo> Syz, close to the picture on http://www.uoregon.edu/~koch/texshop/
12:08:52 <lambdabot> Title: TeXShop
12:08:53 <Syzygy-> And then C-c C-s for a section, C-c C-e for an environment and C-c C-m for a macro. Comfy, and lets you dump options on the things that the package already knows about.
12:08:57 <Syzygy-> With tabcompletion.
12:09:19 <Syzygy-> pejo: Not in my opinion.
12:09:20 <fasta> AucTeX is not bug-free, though.
12:09:29 <Syzygy-> That picture has different windows for the different things.
12:09:31 <fasta> Most of it is great, though.
12:09:33 <Syzygy-> Mine had everything inline.
12:09:36 <Syzygy-> fasta: I believe you.
12:09:47 <Syzygy-> Care to name one, though? I haven't run into any myself.
12:10:05 <fasta> Syzygy-: Well, it's in the preview more.
12:10:27 <Syzygy-> Oh yeah... I have, actually, seen one annoying preview-mode bug.
12:10:29 <fasta> Syzygy-: Smooth scrolling doesn't work like it should.
12:10:41 <mbishop> http://www.haskell.org/hashell/
12:10:42 <lambdabot> Title: Hashell :: Home Page
12:10:49 <fasta> Syzygy-: the parser for math formulas also stinks
12:10:59 <fasta> Syzygy-: Probably just a regex
12:11:11 <Syzygy-> Editing one edge of a math-mode bit may throw the closing $ out of the math-mode thingie; which gets you compile errors on future previews.
12:11:30 <Syzygy-> mbishop: Oh, bugger. I was hoping you'd be Marcus Bishop instead.
12:11:38 <mbishop> Heh, nope
12:11:48 <Syzygy-> Darn.
12:11:59 <Syzygy-> I need to tell Marcus that I found a bug in his code, and get him to fix it.
12:12:19 <mbishop> http://patryshev.com/monad/m-intro.html
12:12:20 <lambdabot> Title: Crash Monad Tutorial
12:12:31 <hpaste>  (anonymous) annotated "parser fails" with "(no title)" at http://hpaste.org/514#a1
12:12:36 <Syzygy-> Yeah, that one. It's -really- good.
12:12:46 <fasta> ADEpt: You mean like this>
12:12:49 <fasta> ADEpt: ?
12:13:20 <ADEpt> fasta: it works?
12:13:29 <fasta> ADEpt: no
12:14:08 <fasta> ADEpt: I don't understand why it doesn't, though. The try should do the right thing
12:15:12 <ADEpt> fasta: let me take a look
12:15:19 <tibbe> I'm trying to find a regex tutorial but I'm not having any luck
12:17:58 <tibbe> anyone?
12:18:12 <fasta> tibbe: can you be more specific?
12:18:27 <fasta> tibbe: since there are a zillion pages on google.
12:18:29 <dcoutts_> @google regex tutorial
12:18:31 <lambdabot> http://www.regular-expressions.info/
12:18:31 <lambdabot> Title: Regular-Expressions.info - Regex Tutorial, Examples and Reference - Regexp Patte ...
12:18:43 <fasta> Right, that's the first hit on google.
12:18:53 <fasta> So, I assume you want something else.
12:19:08 <Igloo> dcoutts_: What were you saing about cabal verbosities the other day, BTW?
12:19:14 <glguy> Syzygy-: is there a command to load auctex mode (I'm in LaTeX mode)
12:19:17 <tibbe> fasta, how do I do a simple group match?
12:19:24 <glguy> I added the required line to my .emacs
12:19:29 <glguy> as instructed by my package manager
12:19:31 <fasta> tibbe: there are different regular expression languages.
12:19:31 <tibbe> fasta, in haskell of course ;)
12:19:36 <glguy> (which differs from the docs :-/)
12:19:37 <dcoutts_> Igloo, oh that it seems to be interpreted inconsistently or the default verbosity is wrong
12:19:44 <tibbe> fasta, posix or pcre
12:19:51 <dcoutts_> Igloo, when doing normal stuff you get lots of verbose output
12:19:53 <fasta> tibbe: and I need to look it up too, since I prefer real parsers most of the time.
12:19:58 <DynWind> http://weitz.de/regex-coach/http://weitz.de/regex-coach/
12:20:03 <DynWind> grr
12:20:05 <DynWind> http://weitz.de/regex-coach/
12:20:06 <lambdabot> Title: The Regex Coach - interactive regular expressions
12:20:10 <dcoutts_> Igloo, ie a normal compile you get the preprocessor and ghc commands printed
12:20:10 <tibbe> fasta, I don't get the documentation of =~ in Text.Regex.Posix (ie there is none)
12:20:14 <Syzygy-> glguy: I don't know, really. I got my .emacs pitched in with the manual stuffits.
12:20:23 <Igloo> dcoutts_: OK, I didn't make any attempt to make them sensible, I just added a "quiet" verbosity
12:20:34 <fasta> tibbe: then I suggest you take a look at some non-Haskell documentation.
12:20:39 <Syzygy-> Which is to say (load "auctex.el" nil t t)
12:20:42 <dcoutts_> Igloo, ok, well it's a regression :-)
12:20:50 <Igloo> Oh, it is? That's odd
12:21:06 <dcoutts_> Igloo, sure, it never used to give us useless verbosity by default :-)
12:21:09 <glguy> Syzygy-: I think that auctex is loaded, I just need to figure out how to get the preview mode ot owrk :)
12:21:17 <Syzygy-> Oh, that's easy.
12:21:22 <tibbe> fasta, I know regex, I need a bloddy function that takes one and return matches!
12:21:28 <Syzygy-> C-c C-p C-p
12:21:48 <dcoutts_> Igloo, I'm not sure if it's just inconsistent or if the default is currently -v1 rather than -v0
12:22:06 <Syzygy-> ?doc Text.Regex.Posix
12:22:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex-Posix.html
12:22:10 <pjd> mbishop: nifty tutorial!
12:22:13 <chessguy> ?hoogle infinity
12:22:14 <lambdabot> No matches found
12:23:08 <tibbe> Syzygy-, the docs doesn't given one example of even doing the simplest things!
12:23:12 <ADEpt> fasta: btw, "space" matches newline as well
12:23:17 <chessguy> yet another monad tutorial?
12:23:28 <Syzygy-> tibbe: Yeah, that was more me wanting to see the docs than telling you to go there.
12:23:29 * mbishop nods
12:23:38 <tibbe> Syzygy-, ah, ok
12:23:54 <mbishop> Hmm, anyone here a stumbleupon subscriber?
12:23:58 <fasta> ADEpt: oh, I was bitten by that earlier. Thanks
12:24:07 <pjd> mbishop: aye
12:24:12 <tibbe> Syzygy-, there's a =~ function but it's not documented
12:24:16 <fasta> tibbe: I looked at it, and I think the interface is horrible.
12:24:16 <tibbe> and a =~~
12:24:21 <fasta> tibbe: I would not use it.
12:24:25 <tibbe> fasta, I agree
12:24:31 <tibbe> but I need something
12:25:10 <mbishop> pjd: then why haven't you made a haskell group yet? :)
12:25:16 <Igloo> dcoutts_: Ah, there already was a level 0, it was just the default rather than silent
12:25:37 <pjd> mbishop: i haven't really been active in the SU groups for a while
12:25:59 <fasta> tibbe: I don't know. Sorry
12:26:11 <tibbe> fasta, ok, thanks anyway :)
12:26:34 <Syzygy-> tibbe: I seem to get it to work with Text.Regex instead.
12:26:47 <Syzygy-> Prelude Text.Regex> let azPlus = mkRegex "[a-z]+"
12:26:49 <tibbe> Syzygy-, ok, I'll have a look
12:26:52 <Syzygy-> Prelude Text.Regex> matchRegex azPlus "foobar"
12:26:52 <Syzygy-> Just []
12:26:56 <Syzygy-> Prelude Text.Regex> matchRegex azPlus "4"
12:26:56 <Syzygy-> Nothing
12:27:03 <dcoutts_> Igloo, erm I'm not sure I follow, anyway what is the solution?
12:27:22 <fasta> Syzygy-: yep, that interface looks much easier
12:27:27 <Igloo> dcoutts_: (a) come up with a policy for the verbosity levels (b) sweep through the code implementing it
12:28:37 <Syzygy-> fasta: Yeah, with Text.Regex, you should be able to figure things out well enough.
12:29:35 <dcoutts_> Igloo, ok, I see basically 3 levels, normal: no echoing of commands but no suppression of output from commands, verbose 1: echo commands, verbose 2: echo commands and pass -v to those commands that support it.
12:29:54 <Igloo> dcoutts_: Gnnnghh!
12:30:06 <dcoutts_> huh?
12:30:20 <Igloo> dcoutts_: There needs to be a silent level too
12:30:33 <dcoutts_> which mean no output ever ever ever?
12:30:37 <Igloo> Yes
12:30:41 <dcoutts_> no warnings, no errors
12:30:45 <dcoutts_> just an exit code
12:30:54 <dcoutts_> ok, fine.
12:31:29 <Igloo> Well, I'm not actually sure what's normal for errors, but following standard practice for them, yes
12:31:51 <Igloo> I think -v1 should be normal, and -v should be a synonym for -vn for some n, too
12:32:05 <dcoutts_> but normal can't be -v
12:32:19 <Igloo> Right
12:32:30 <dcoutts_> -v is "I want verbose"
12:32:33 <dcoutts_> so what is silent ?
12:32:41 <dcoutts_> and -v1 == v right?
12:32:46 <dcoutts_> erm -v1 == -v
12:33:15 <dcoutts_> -v-1 ? :-)
12:33:31 <dcoutts_> what's standard practice here?
12:33:45 <Igloo> I'm not sure if I trust it given it looks wrong about the default level, but ./Setup build --help claism "-v alone is equivalent to -v3"
12:34:52 <Igloo> I would say    -v0 = silent (which is what the head has now), -v1 = default, -v2 = cabal talks more, -v = -v3 = cabal talks more and tells everything else to talk more
12:35:03 <mbishop> pjd: so you gonna make that group or not? :P
12:35:11 <Igloo> Although there's the question of how much it should ask everything else to talk
12:35:32 <Igloo> Oh, and -v0 should ask everything else to not talk either
12:37:32 <pjd> mbishop: i could :)
12:37:42 <pjd> tagline suggestion?
12:37:59 * mbishop shrugs
12:38:52 <pjd> hmm, know of a good version of the logo?
12:39:12 <Syzygy-> -q silent?
12:40:43 <chessguy> hoo-boy. i've got a potential employer asking me what attracts me to haskell and functional programming
12:40:58 <Syzygy-> Oooooh?
12:41:16 <chessguy> how do i manage not to write a 10-page response? :)
12:41:57 <pjd> chessguy: is the employer familiar with FP?  then you can probably just focus on personal angles
12:42:02 <chessguy> he is
12:42:47 <alexj_> chessguy: what industry?
12:42:50 <chessguy> AI
12:42:59 <chessguy> more or less
12:43:47 * glguy got preview-mode working... quite sick
12:44:46 <mbishop> pjd: last.fm uses http://static.last.fm/groupavatar/64e88b02ad08079e342d827715ab4eca.jpg
12:44:49 <lambdabot> http://tinyurl.com/2fsr7p
12:45:37 <mnislaih_> what last.fm group is that ?
12:46:04 <pjd> mbishop: this one looks a bit better: http://www.math.duke.edu/~wgm/HaskellLogo.png
12:46:14 <mnislaih_> mbishop: I would like to join
12:46:21 <mbishop> mnislaih_: which?
12:46:34 <mbishop> the last.fm group, or the stumbleupon group?
12:46:35 <pjd> ah, http://haskell.org/haskellwiki/Haskell_logos
12:46:36 <lambdabot> Title: Haskell logos - HaskellWiki
12:47:04 <mnislaih_> the last.fm group. I only saw the groupavatar, which is the actual group?
12:47:05 <pjd> eh, that's a tinier version anyway
12:47:44 <mbishop> mnislaih_: http://www.last.fm/group/haskell
12:47:48 <lambdabot> Title: haskell &ndash; Groups at Last.fm
12:48:03 <mnislaih_> hmm cool !
12:48:09 <pjd> haha, "Is that a banana in your pocket or are you just programming with catamorphisms?"
12:48:32 <pjd> working tagline
12:49:55 <DynWind> :)
12:52:00 <fasta> ADEpt: It's working, but the space wasn't the only problem. The semantics for sepBy aren't DWIM.
12:53:14 <ADEpt> fasta: yep, seems so
12:54:21 <fasta> ADEpt: it's also odd that eof isn't in the same module as newline.
13:08:32 <mabs29> Hello, #haskell.
13:09:05 <dmead> sup.
13:09:09 <chessguy> yeesh
13:09:23 <chessguy> nothing like getting asked a question like that out of nowhere
13:10:14 <encryptio> i need to find out if an element is in a list: head $ filter (\x -> element == x) list  -- is there a cleaner way to do that?
13:10:22 <dmead> YEA
13:10:23 <inv2004> re
13:10:26 <dmead> encrpytio:
13:10:36 <inv2004> what's ERROR - Unresolved overloading
13:10:37 <inv2004> *** Type       : (RealFrac a, Integral a) => [a]
13:10:37 <inv2004> *** Expression : mkseq 13 ?
13:10:48 <chessguy> ?hoogle elem
13:10:49 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
13:10:49 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
13:10:49 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
13:10:56 <dcoutts_> > 'f' `elem` "foo"
13:10:56 <chessguy> ?src elem
13:10:57 <lambdabot>  True
13:10:57 <dmead> any (x 'elem') y
13:10:57 <lambdabot> elem x    =  any (== x)
13:11:05 <dmead> where y is a list
13:11:27 <inv2004> ?hoogle Unresolved overloading
13:11:28 <lambdabot> Did you mean: Unresolved Overloading
13:11:38 <inv2004> ?hoogle Unresolved Overloading
13:11:39 <lambdabot> No matches, try a more general search
13:11:39 <encryptio> indeed, thanks
13:12:44 <chessguy> inv2004, hoogle can't search for error messages
13:12:44 <pjd> inv2004: try adding a type signature to it?
13:13:33 <inv2004> Instance of RealFrac Integer required for definition of mkseq. what does it mean ?
13:13:51 <inv2004> I wrote: mkseq::Integer -> [Integer]
13:14:05 <pjd> hpaste: url?
13:14:05 <hpaste> Haskell paste bin: http://hpaste.org/
13:14:10 <mbishop> pjd: still no haskell group? (also, I added you as a friend :P)
13:14:12 <chessguy> that type signature is fine
13:14:20 <chessguy> please paste your code on that site ^^
13:14:33 <pjd> mbishop: it's submitted for approval :)
13:14:36 <chessguy> ?hoogle Integer -> [Integer]
13:14:38 <lambdabot> No matches, try a more general search
13:14:52 <chessguy> (note, chances are good that you actually want Int, and not Integer)
13:15:20 <chessguy> ?hoogle Int -> [Int]
13:15:21 <lambdabot> No matches, try a more general search
13:15:26 <chessguy> ?hoogle a -> [a]
13:15:27 <lambdabot> Prelude.repeat :: a -> [a]
13:15:27 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:15:27 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
13:16:01 <hpaste>  inv2004 pasted "Unresolved top-level overloading" at http://hpaste.org/516
13:16:19 <inv2004> here it is
13:16:36 <ndm> Web hoogle would find that...
13:17:03 <encryptio> inv2004: it doesn't know what type mkseq is - it could be Int, Integer, Double, Float... give mkseq a type definition that's more specific than Num a => a -> [a]
13:17:13 <encryptio> or
13:17:24 <encryptio> use main = mkseq (13 :: Integer) -- or similar.
13:18:08 <inv2004> is it ok? mkseq::Integer -> [Integer]
13:18:45 <inv2004> main = mkseq (13::Integer) doesn't help
13:18:48 <encryptio> should be. oh - one more thing - you probably want a (main = putStrLn $ show $ mkseq 13) ...
13:19:26 <ndm> or print $ mkseq 13,    print == putStrLn . show
13:19:38 <inv2004> Instance of RealFrac Integer required for definition of mkseq
13:20:03 <encryptio> and that would be because you're dividing an Integer...
13:20:28 <encryptio> but i don't know a good haskellish way to fix that.
13:20:54 <ndm>  (/) divides reals
13:21:01 <inv2004> floor ?
13:21:01 <ndm> `div` divides integers
13:21:04 <ndm> just use `div`
13:21:06 <inv2004> thx
13:21:14 <ndm> > 4 `div` 2
13:21:15 <lambdabot>  2
13:21:25 <chessguy> > 4 / 2
13:21:27 <lambdabot>  2.0
13:21:30 <encryptio> > 7 `div` 3
13:21:31 <lambdabot>  2
13:21:36 <encryptio> > 8 `div` 3
13:21:37 <lambdabot>  2
13:21:42 <inv2004> works fine! thx
13:22:01 <inv2004> anyone take part in http://projecteuler.net ?
13:22:02 <lambdabot> Title: Project Euler
13:22:10 <inv2004> yes
13:23:23 <dmead> looks cool
13:29:24 * shapr boings cheerfully
13:29:27 <shapr> yow!
13:29:37 <Nafai> Hey shapr!
13:30:35 <Syzygy-> Hey shapr
13:30:36 <chessguy> inv2004, dmead, glguy is/was big into that
13:30:45 <Syzygy-> inv2004: I used to solve a big bunch of those.
13:30:50 <dmead> cool cool
13:30:50 <Syzygy-> Then I forgot my login. :P
13:30:57 <dmead> :p
13:31:05 <Syzygy-> I had a very high percentage on "Pen and paper" as solution method though. :)
13:32:21 <inv2004> :)
13:32:56 <inv2004> grrr, "Segmentation fault
13:33:30 <inv2004> I use Q (k4/apl) on the task, it did segfault too :) funny
13:33:50 <shapr> hiya Nafai, Syzygy-, how's code?
13:34:09 <Nafai> shapr: It's Java :)
13:34:18 <shapr> Nafai: Ouch. How's that going?
13:34:48 <Nafai> Okay...doing some work so I can do more of my work in Jython
13:34:51 <shapr> Cool
13:35:04 <shapr> I think I played with some Jython J2EE servelets for a bit, they worked nicely.
13:35:15 <Slarba> off topic: http://www.ninjapants.org/files/index.php?image=Good%20Cause.jpg&d=d.html
13:35:18 <lambdabot> Title: Good Cause.jpg, http://tinyurl.com/yv4z7b
13:35:42 <hpaste>  conal annotated "I can't write arrow code" with "compare with this code" at http://hpaste.org/515#a2
13:36:24 <hpaste>  (anonymous) annotated "programming subreddit test" with "(no title)" at http://hpaste.org/512#a1
13:41:00 * pjd aways for the day
13:42:02 <glguy> is that subreddit annotations factor?
13:52:11 <dmhouse> What's the standard name for patterns involving a '@'?
13:52:18 <Heffalump> as patterns
13:52:29 <dmhouse> I've always called them 'at-patterns', but I saw 'as-patterns' in the report.
13:52:35 <Heffalump> you pronounce the '@' as "as" too, at least I do
13:53:01 <dmhouse> Heffalump: really? I thought '@' was pretty universally 'at'.
13:53:18 <Heffalump> well, only when reading Haskell :-)
13:53:25 <dmhouse> Ah, righty.
13:53:39 <Heffalump> possibly I sometimes mentally think 'at', now I think about it
13:53:41 <dmhouse> Anyone else's take on this?
13:53:58 <Heffalump> but certainly my initial reaction to yuor question was "as"
13:54:14 <bos> they are danish pastry capture machines.
13:54:29 * Igloo thinks it's the wrong way round for "as" to read right
13:54:35 <ndm> i would have called them at patterns
13:54:43 * Syzygy- is with ndm on this.
13:54:44 <bos> they take your pattern and enfold it in custardy goodness.
13:54:45 <ndm> but i haven't read the report
13:55:19 <dmhouse> Igloo: that's true.
13:56:58 <Boney> this languages is awesome.  first currying,  now custard!  YUM!
13:57:20 <Syzygy-> Curry and custard? At the same time? Ewwwwwww.
13:57:29 * Boney wonders if haskell has "steak"
13:57:55 <Boney> Syzygy-: meal and desert.
13:59:45 <augustss> Haskell is vegetarian
14:00:01 <Boney> oh.
14:00:51 <augustss> i can feel it.  full of stuff that's good for you
14:02:48 <bos> hmm, it's next to impossible to find a link to the cabal darcs repo.
14:03:09 <Igloo> dons: Why the change cons' -> cons2?
14:03:10 <ndm> @where cabal
14:03:10 <lambdabot> http://www.haskell.org/cabal
14:03:29 <ndm> darcs get http://darcs.haskell.org/Cabal
14:03:52 <ndm> bos: http://darcs.haskell.org/cabal/
14:03:53 <lambdabot> Title: Index of /cabal
14:03:56 <bos> there oughter be a link somewhere on one of the cabal pages.
14:04:13 <bos> ndm: thanks
14:04:13 <ndm> or http://darcs.haskell.org/packages/Cabal
14:04:15 <lambdabot> Title: Index of /packages/Cabal
14:04:29 <ndm> annoyingly there are two links, to the same place, with different capitalisation!
14:04:51 <ndm> bos: http://www-users.cs.york.ac.uk/~ndm/projects/windows.php
14:04:52 <bos> actually  http://darcs.haskell.org/Cabal doesn't work
14:04:53 <lambdabot> Title: Neil Mitchell - Windows Packages
14:05:11 <ndm> bos: lower case c
14:05:17 <bos> ah, yes.
14:05:26 <ndm> thats a page of links to cabal repos, including for things which have no explicit link anywhere
14:07:30 <Heffalump> anyone used heap profiling in GHC recently, btw?
14:11:37 <Heffalump> hmm, guess not..
14:16:30 <augustss> You have. ;)
14:19:20 <Syzygy-> ?type uncurry
14:19:23 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:23:58 <Syzygy-> Is there some decent way to get a darcs repository at darcs.haskell.org to rebuild the haddock documentation?
14:24:09 <Syzygy-> Or do I have to poke the maintainer of the package until he reacts?
14:24:44 <chessguy> ?type curry
14:24:47 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:25:20 <Syzygy-> At some point I probably should write a post or something about what curry/uncurry is in category theoretic terms.
14:25:26 <augustss> ?type curry . uncurry
14:25:30 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
14:25:33 <Syzygy-> And thus why it's the most natural thing there is. :P
14:25:37 <Syzygy-> @pl curry . uncurry
14:25:38 <lambdabot> id
14:25:46 <Syzygy-> @pl uncurry.curry
14:25:46 <lambdabot> id
14:25:58 * Syzygy- just proved them to be two halves of an isomorphism. Yay me! :)
14:26:16 <augustss> You had help ;)
14:26:24 <Syzygy-> Well, yeah.
14:26:36 <Syzygy-> But doing it using the source code isn't much more difficult. :)
14:26:41 <Syzygy-> ?src curry
14:26:42 <lambdabot> curry f x y = f (x, y)
14:26:44 <Syzygy-> ?src uncurry
14:26:44 <lambdabot> uncurry f p = f (fst p) (snd p)
14:26:53 <augustss> I know
14:27:13 <Syzygy-> Or for that matter doing the same thing with Hom(AxB,C) -> Hom(A,Hom(B,C))
14:27:15 <augustss> wonder why it's written like that
14:27:33 <augustss> uncurry f ~(x, y) = f x y
14:27:34 <Syzygy-> Instead of uncurry f (x,y) = f x y
14:27:40 <Syzygy-> Oh. Why the ~?
14:27:45 <Syzygy-> What does it do?
14:27:54 <augustss> lazy pattern matching
14:28:00 <dmhouse> > uncurry (const 4) undefined
14:28:02 <lambdabot>   add an instance declaration for (Num (b -> c))
14:28:33 <dmhouse> > uncurry (\_ _ -> 4) undefined
14:28:34 <Syzygy-> > let uc f ~(x,y) = f x y in uc (const 4) undefined
14:28:35 <lambdabot>  4
14:28:35 <lambdabot>   add an instance declaration for (Num (t -> t1))
14:28:40 <xerox> > uncurry const 4 undefined
14:28:40 <lambdabot>   add an instance declaration for (Num (a -> a1, b))
14:28:46 <Syzygy-> > let uc f ~(x,y) = f x y in uc (const 4) undefined
14:28:47 <lambdabot>   add an instance declaration for (Num (t -> t1))
14:29:32 <dmhouse> > let uc f ~(x, y) = f x y in uc (\_ _ -> 4) undefined
14:29:34 <lambdabot>  4
14:29:37 <dmhouse> > let uc f (x, y) = f x y in uc (\_ _ -> 4) undefined
14:29:39 <lambdabot>  Undefined
14:29:53 <dmhouse> The difference is because f is a lazy function.
14:30:00 <dmhouse> (I.e. f undefined /= undefined)
14:30:02 <Syzygy-> Ah.
14:30:16 <dmhouse> If you pass a strict function, there's no difference.
14:30:25 <augustss> things always get messy around _|_
14:30:29 <dmhouse> > let uc f ~(x, y) = f x y in uc (+) undefined
14:30:30 <lambdabot>  Undefined
14:30:36 <dmhouse> > let uc f (x, y) = f x y in uc (+) undefined
14:30:38 <lambdabot>  Undefined
14:31:21 <dmhouse> Syzygy-: http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching may help.
14:31:25 <lambdabot> http://tinyurl.com/ykch9p
14:31:32 <dmhouse> It uses the example of (***), but uncurry is very similar.
14:31:48 <dmhouse> If it doesn't help, whinge (to me; I wrote it).
14:32:06 <Syzygy-> ?type (***)
14:32:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:32:26 <dmhouse> It allows you to apply two different functions to two different parts of a pair.
14:32:41 <dmhouse> > (succ *** not) (1, True)
14:32:43 <lambdabot>  (2,False)
14:32:52 <Syzygy-> So, that's basically like the f (x) g :: A (x) B -> C (x) D construction in monoidal categories, right?
14:33:00 <dmhouse> Yeah.
14:33:14 <augustss> I want this function all the time, but I always hesitate to import Arrows
14:33:32 <Syzygy-> Or ... rather ... f x g, since tensor products'll be not quite the intuition for tuples. IIRC.
14:34:34 <chessguy> paolin1 :)
14:34:41 <chessguy> @quote paolin1
14:34:41 <lambdabot> No quotes match. Wrong!  You cheating scum!
14:34:45 <chessguy> @quote paolino
14:34:45 <lambdabot> quicksilver says: paolino: it can be used to proof various deep theorems about stuff
14:34:55 <dmhouse> I know nothing of tensors. It's often called Ã in the literature, i.e. succ Ã not.
14:34:57 <augustss> dmhouse: "Prelude> (const 1 *** const 2) undefined [14:33]"
14:34:57 <Syzygy-> Oh yeah
14:35:04 <paolin1> ola
14:35:06 <Syzygy-> dmhouse: Yeah. That'd be it.
14:35:18 <augustss> dmhouse: the [14:33] looks odd
14:35:33 <waern> augustss, why do you hesitate?
14:35:49 <dmhouse> augustss: oops, I bet that was pasted from IRC. Thanks.
14:36:12 <shapr> shazam!
14:36:30 <paolin1> chessguy: finally I erased the Writer from my horizon, and.. my clusterer runs in 6 Meg instead of exploding my machine
14:36:40 <chessguy> woohoo!
14:36:52 <chessguy> paolin1++
14:37:00 <paolin1> Writer--
14:37:24 <paolin1> RWS--
14:37:30 <paolin1> Cont--
14:37:42 <dmhouse> Cont++
14:37:45 <slowriot> Has anyone here used yampa?
14:37:48 <bd_> WriterList--
14:38:05 <bd_> WriterSequence++ >.>
14:38:28 <paolin1> dmhouse: ok, if you really love a leaker get that :P
14:39:11 <Cale> paolin1: how's that working out?
14:39:17 <Cale> paolin1: did you get it figured out?
14:39:19 <paolin1> finished
14:39:23 <Cale> awesome
14:39:33 <paolin1> running in 6 Meg now
14:39:44 <paolin1> stable
14:39:55 <Cale> Yeah, it was just a really bad interaction between WriterT and State
14:39:57 <paolin1> for half an hour
14:40:04 <dmhouse> Is there any way to convince the compiler that there will only be one type that satisfies a list of constraints?
14:40:04 <paolin1> mmhh
14:40:12 <Cale> er, Writer and StateT, rather
14:40:30 <Cale> The other way around isn't quite as bad, except that it has other problems.
14:40:37 <paolin1> Cale, I don't feel so
14:40:50 <paolin1> I think Writer is leaking anyway
14:40:58 <dmhouse> I.e., I have Foo f, Bar f => f, and I know that, e.g. String will be the only type that ever meets both those constraints, so I want to unify f with String, but then the compiler gives me a 'Couldn't match expected type ... against type ... (a rigid type variable)' error.
14:41:15 <dmhouse> Do I need existentials?
14:41:21 <Cale> nah, it can run in constant space, it's just that when you State transformed it, bind ended up doing something really bad.
14:42:27 <Cale> You could say that there's a real problem with RWST though.
14:42:36 <Cale> because it's always going to create that issue
14:42:39 <paolin1> RSW also
14:42:45 <Cale> yeah
14:42:47 <paolin1> RWS
14:43:24 <Cale> dmhouse: I don't think you can express that to the compiler so easily.
14:43:46 <Cale> dmhouse: because someone could always come along and add some more instances
14:43:58 <Cale> The solution is just to write String when you mean String.
14:44:44 <dmhouse> I don't think that's possible here. Let me elaborate my situation.
14:45:25 <paolin1> Cale...
14:45:27 <paolin1> runWriter (let loop x = loop (x+1) >> return () in loop 0 >> tell [()])
14:45:30 <paolin1> explodes
14:45:32 <dmhouse> I'm writing software for forums, so I have something of a hierarchy: forum -> conversation -> post.
14:46:27 <dmhouse> I have a class Path p c | p -> c, meaning that p is the type of a path that uniquely specifies something of type c within the hierarchy (i.e., one of Forum, Conversation or Post).
14:46:39 <Cale> paolin1: that's fairly unavoidable.
14:47:07 <dmhouse> I also have a class ParentOf c d | d -> c, which encodes my hierarchy. It means c is a parent of d in the hierarchy described.
14:47:09 <Cale> paolin1: the only way that could fail to explode is if you're in a monad with no output side effects
14:47:18 <Cale> and bind is lazy
14:47:38 <dmhouse> One of the methods of the Path class is parentPath :: (ParentOf prnt c, Path q prnt) => p -> q
14:47:39 <Cale> That is, a monad where a >> b = b
14:48:27 <dmhouse> For any t, one of Forum, Conversation or Post, there will only be one type c such that ParentOf c t (hence the functional dependency in ParentOf).
14:48:57 <dmhouse> So there will only ever be one possible type q in the signature of parentPath.
14:49:13 <paolin1> Cale, the Writer monad is selled as a good thing for logging !
14:49:36 <Cale> paolin1: and it generally is
14:49:40 <paolin1> noone says don't use it too much
14:49:51 <Cale> paolin1: however, it's not good to State transform it.
14:50:02 <Cale> (which is an interesting thing to know)
14:50:17 <dmhouse> I've got to dash, I'll pick up any ideas, if anyone's got them, when I get back in 15 mins or so.
14:50:33 <Cale> at least, if you do state transform it, you want all your computations to complete fairly quickly.
14:51:35 <paolin1> RWS should be deleted from stdllib
14:52:27 <Cale> There have been places that it's been used quite effectively without too many problems.
14:52:55 <Cale> However, perhaps there should be more warning labels on it :)
14:53:13 <Cale> Actually, I think perhaps it would be best to simply redesign it to work around the problem.
14:53:53 <Cale> There's a better way to write that monad which avoids the space leak. The transformers just interact poorly.
14:54:01 <paolin1> yeah
14:54:52 <paolin1> it took some time to make the Worker work
14:55:50 <Cale> You could actually make it a full instance of MonadWriter
14:56:26 <Cale> might not be worth the trouble if you don't need that though
14:57:30 <Cale> runState (let loop x = loop (x+1) >> return () in loop 0) () -- note that this blows up too.
15:00:30 <dons> ?users
15:00:31 <lambdabot> Maximum users seen in #haskell: 307, currently: 292 (95.1%), active: 43 (14.7%)
15:08:48 <dons> Igloo: I thought I only changed cons' -> cons2 where a local cons' shadowed the top level defn
15:08:49 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:09:12 <dons> to obey the -Wall police
15:09:14 <Igloo> dons: Ah, OK, I didn't look too carefully
15:09:24 <Igloo> Three cheers for the -Wall police!
15:10:04 <dmhouse> I find it really hard to parse -Wall as two separate lexemes. I always just read it as "wall" (think bricks).
15:10:45 <Igloo> I do too. I certainly wouldn't want to spend time reading it as "double you all"
15:11:40 <dmhouse> It's one of language's ironies that 'World Wide Web' is three syllables, yet its abbreviation 'WWW' is nine.
15:11:57 <resiak> âdub dub dubâ
15:12:07 <allbery_b> wubwubwub :)
15:12:12 <sadasdsadad> http://axeofwar.zapto.org/go_sp.php?69 Join Please
15:12:14 <lambdabot> Title: Death World - [ Ãëàâíàÿ ]
15:12:41 <Syzygy-> dmhouse: I only count three: "ve ve ve"
15:13:08 <Syzygy-> OTOH, that's in german. :P
15:14:24 <abz> ?doc Control.Concurrent
15:14:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
15:15:18 <dmhouse> Syzygy-: imagine if it were 'YYY', though ;)
15:17:03 <resiak> Yesterday's Yeoman's YouTube?
15:17:04 <augustss> Syzygy-: ve ve ve in swedish too
15:17:24 <augustss> (incorrectly)
15:18:14 <abz> Does anyone know of a good paper on haskell threads and forks?
15:18:50 <dmhouse> abz: maybe the Awkward Squad paper by SPJ et al.
15:19:18 <dmhouse> Depends. There are many ways of achieving Haskell concurrency.
15:19:27 <dmhouse> You'd do well to start at the wiki.
15:19:30 <dmhouse> ?wiki Concurrency
15:19:30 <lambdabot> http://www.haskell.org/haskellwiki/Concurrency
15:19:46 <dmhouse> Nope, not there. Hold on.
15:19:53 <augustss> looks a bit empty
15:20:22 <dmhouse> http://www.haskell.org/haskellwiki/GHC/Concurrency
15:20:24 <lambdabot> Title: GHC/Concurrency - HaskellWiki
15:20:27 <abz> Ok then. I'll look at both. Thanks.
15:20:43 <sorear> hello #haskell
15:21:36 <augustss> hello sorear
15:22:58 <dmhouse> abz: I don't have much hands-on experience with concurrency, but from a 'Ooh, that looks cool' perspective, I'd recommend you follow the Software Transactional Memory link on that wiki page.
15:23:02 <beschmi> hey sorear
15:23:39 <augustss> abz: do you need concurrency or parallelism?
15:23:48 <sorear> oh, I got two widely separated responces ... I should attach some significance to this, right?
15:25:38 <abz> I need parallelism...I'd like to spark off a daemon
15:25:59 <abz> and then within that daemon, spark of some threads
15:26:26 <abz> wait
15:27:09 <dmhouse> In which case you can probably get by with forkIO and MVars.
15:27:17 <abz> I need to spark a new process... and then within that process I need a some concurrency
15:28:05 <abz> using forkIO, that gets me a new process right?
15:28:46 <sjanssen> abz: forkIO gets you a new thread
15:29:03 <sorear> @ty System.Posix.Process.fork
15:29:06 <lambdabot> Not in scope: `System.Posix.Process.fork'
15:29:24 <abz> arrr....that's sounds more like it
15:29:26 <sorear> @ty System.Posix.Process.forkProcess
15:29:29 <lambdabot> IO () -> IO System.Posix.Types.ProcessID
15:29:43 <abz> ?doc System.Posix.Process
15:29:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html
15:29:47 <sorear> why do you want a new process?  there might be a better way
15:30:20 <sorear> abz: also, that forks a process to run an action.  it only returns once.
15:32:23 <sorear> hehe.  forkProcess doesn't directly use fork(2), it calls pid_t forkProcessPrim(HsStablePtr /* StablePtr (IO ()) */);
15:32:26 <abz> I need a new process since the parent process is a CGI process and I would like it to render a page, and then exit, while some daemons are started up in the waiting for and doing other things
15:32:36 <sorear> ah.
15:33:02 <abz> the other process is going to talk to some payment gateway servers
15:33:18 <sorear> in that case you shouldn't need to recover the twice-return hack :)
15:33:56 <sorear> also haskell supports FastCGI, which *might* be better for you (no need to worry about forking, etc)
15:36:12 <abz> ok, but I'm going to need more information on haskell support for FastCGI
15:37:50 <sorear> I don't have more information, sorry, except a stdlibs ptr
15:37:57 <sorear> @docs Network.FastCGI
15:37:58 <lambdabot> Network.FastCGI not available
15:38:31 <sorear> I thought it was in the standard libs. ... oh well
15:38:44 <sorear> in any event, I've only heard of it.
15:38:53 <bd_> ?where fastcgi
15:38:53 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/doc/
15:39:08 <givi> hello! stdin contains data of the following form: "N1\n a1 a2 a3 ... aN1\n N2\n b1 b2 ... bN2\n ..." so on. My program has to perform some operations on M testcases each beeing "<number of numbers in a sequence>\n <sequence>". How can I read these testcases in the most effective way?
15:39:47 <givi> The <sequence> is beeing a sequence of integer numbers
15:40:03 <abz> what is the difference between FastCGI and Network.CGI?
15:40:19 <sorear> I don't know
15:40:25 <Cale> Yay, Karsten Wagner finally gets monads!
15:40:36 <sorear> the difference between FastCGI and CGI is protocol
15:40:39 <Philippa> FastCGI has substantially better performance than CGI
15:40:43 <Philippa> but yeah, protocol
15:40:52 <sorear> who is Karsten Wagner? is she related to Andrew Wagner?
15:41:10 <abz> is there a paper for FastCGI i can read? (I've read E.M. one for Network.CGI)
15:41:19 <pejo> sorear, I would have guessed it's a he, but I have no idea.
15:42:05 <allbery_b> hm.  karsten wagner = chessguy, I think?
15:42:15 <dons> I don't think so?
15:42:18 <sorear> andrew wagner = chessguy
15:42:24 <allbery_b> oh
15:42:27 <allbery_b> oh
15:42:29 <allbery_b> er
15:42:30 <allbery_b> ok
15:43:40 <sorear> givi: so IOW your format is unlines . map (\lst -> show (length lst) ++ "\n" ++ unwords (map show lst))
15:43:50 <michaelw> sorear: fwiw, Karsten is a male name, I'd say.
15:44:07 <sorear> > unlines . map (\lst -> show (length lst) ++ "\n" ++ unwords (map show lst)) $ [[],[1],[2,3],[4,5,6]]
15:44:09 <lambdabot>  "0\n\n1\n1\n2\n2 3\n3\n4 5 6\n"
15:44:23 <sorear> givi: ^^^ look right?
15:44:30 <givi> yes
15:44:43 <givi> this is the format I have to READ
15:44:49 <sorear> that's a very redundant format
15:45:05 <sorear> yeah, I got that, I just wasn't sure I correctly read your spec :)
15:45:59 <givi> redundant? I agree
15:46:03 <sorear> are there any extra lines?
15:46:08 <sorear> (like comments)
15:46:19 <sorear> or any variable whitespace?
15:46:46 <givi> no. But is possible that a <sequence> breaks into multiple lines
15:46:58 <sorear> ah
15:47:04 <sorear> makes it harder :)
15:47:21 <givi> yeap
15:47:33 <sorear> sounds almost like it was designed for parsing in an imperative language :)
15:47:46 <givi> yes, it does :)
15:47:50 <pejo> Cale, and for some stupid reason you made me read his blog. Now he's going after evaluation order. Bleh.
15:47:52 <sorear> do you want error detection/recovery
15:47:53 <sorear> ?
15:48:05 <givi> no :)
15:48:15 <sorear> ok.
15:48:22 * sorear goes to hpaste
15:48:45 <Cale> pejo: he is?
15:48:55 <Cale> pejo: His most recent article is the one about monads
15:49:28 <Cale> He spent a long time talking about how monads were evil, and just finally got it :)
15:50:19 <pejo> Cale, yeah, february. "if evaluation order is specified, side effects are there and <..>, it's an imperative language".
15:50:45 <Cale> That's fairly wrong :)
15:51:04 <Cale> However, it's converse is fairly true.
15:51:10 <Cale> its*
15:51:39 <dons> not everyone should have a blog, is the lesson we learn here.
15:51:49 <givi> Cale: is the article about evil monads? are you guys taking a Haskell class together or something?
15:52:02 <pejo> And even comments say that in order to be pure, a language has to have lazy evaluation.
15:52:04 <Cale> givi: no
15:52:11 <Cale> (on both accounts)
15:52:15 * allbery_b has also seen it spelled "carsten" and in that context it was masculine, fwiw
15:52:21 <augustss> Evil Monads!
15:52:24 <Cale> givi: One of his previous articles was about monads being evil though.
15:52:25 <dons> though, he does seem to try, he misses some basic things like checking the definition of a particular monad in the src. instead he guesses
15:52:26 <givi> ^)
15:52:30 <givi> :)
15:52:35 <dons> or using @undo to desugar
15:52:37 <dons> ah well
15:53:11 <Cale> dons: yeah, there are some relatively minor errors, and I think ricercar corrected most of them
15:53:12 <augustss> I must say I didn't get how the "macro" thing explained monads.
15:53:26 <Cale> dons: but the important thing is that his overall idea is right
15:53:41 <dons> it was an obfuscated explanation of do-notation, wasn't it, augustss ?
15:53:43 <Cale> augustss: macros are also used to build domain specific languages
15:54:01 <Cale> no
15:54:05 <augustss> It's seems he finally understood what the do notation means
15:54:11 <dons> ah right. higher order functions and type classes as macros
15:54:12 <Philippa> dons: that, and that the desugaring is into something that you can 'patch into', because >>= is overloaded. But yeah
15:54:37 <edwinb> okay, you've made me look now
15:54:43 <augustss> lol
15:54:52 * Philippa would hand edwinb the goggles, but you all know the quote
15:54:59 <pejo> See. Blogs are bad for our blood pressure.
15:55:04 <Cale> well, yeah, okay :)
15:55:11 <edwinb> should I have another beer first, or something stronger?
15:55:24 <givi> Philippa: I don't :(
15:55:26 <Cale> But it's really about what the monadic abstraction means, as I read it.
15:55:47 <Philippa> givi: "My eyes! The goggles, they do nothing!". Simpsons.
15:56:03 <Cale> (and he's right, it's about creating a framework for domain specific languages)
15:56:10 <sjanssen> poor Renier Wolfcastle
15:56:15 <Philippa> yeah, it's a poor shot at the idea monads let you shift into a slightly different language which meets certain rules
15:56:26 * ddarius hasn't seen The Simpsons for quite a few years now.
15:56:42 <ddarius> I vaguely remember that episode though.
15:58:41 <givi> how to produce that "* givi thinks" thingy in an obscure Visual Basic IRC-chat client?
15:59:05 <resiak> /me thinks
15:59:12 * allbery_b thinks
15:59:21 <allbery_b> if it doesn't d /me, try /action
15:59:23 <sjanssen> givi: generally you prefix your message with /me
15:59:24 <hpaste>  sorear pasted "my "take"" at http://hpaste.org/518
15:59:25 <allbery_b> *do
15:59:55 <sorear> ^AACTION foo^A
16:00:02 * sorear foo
16:00:06 * givi is from Ukraine - he watches Simpsons in Ukrainian... sometimes
16:00:12 <givi> hehe
16:00:26 <sorear> hmm, was the second line of mine * sorear foo ?
16:00:40 <sorear> erc displayed it using ^A so I wondered
16:00:49 <givi> no, but the next one is
16:00:50 <sorear> givi: see hpaste
16:00:51 <givi> hehe
16:00:56 <givi> thanks!
16:00:58 <allbery_b> <sorear> ^AACTION foo^A
16:00:59 <allbery_b> * sorear foo
16:01:09 <sorear> lesson of the day, how to do raw CTCP
16:01:33 <sorear> allbery_b: yes, I did use C-q C-a ACTION SPC foo C-q C-a
16:01:35 <givi> (nevermind)
16:02:25 <sorear> givi: how does the paste look?
16:04:10 <givi> oh, I like it! much more pretty than my variant :)
16:04:14 <augustss> Perhaps I should write a monad tutorial.  I must soon be the only person who hasn't.
16:04:49 <givi> I must soon be the next one ;)
16:04:54 <sorear> augustss: I haven't either
16:04:55 <Saizan> why not a comonad tutorial?
16:05:05 <Philippa> I haven't /finished/ a monad tutorial. Mostly on implementation though.
16:05:22 <edwinb> I don't know anything about monads, I just use them...
16:05:24 <augustss> sorear: hey, we could start a club!
16:05:45 * allbery_b hasn't and doesn't plan to
16:06:11 <augustss> I can see the temptation to write one.  There are so many bad ones.
16:06:27 * ddarius might write an article about free monads... but probably not a monad tutorial.
16:06:41 * allbery_b wishes the quote about monads-as-bad-analogies hadn't gotten lost
16:06:50 <LoganCapaldo_> free as in freedom or free as in beer?
16:06:54 <augustss> ddarius: can a BDSM language have free monads? ;)
16:07:09 <Philippa> sure, someone's got to top
16:07:30 * givi writes an introduction to Python for high school students...
16:07:37 <augustss> Philippa: ah, but it's more subtle than that :)
16:07:39 <Philippa> givi: "don't"?
16:07:49 <ddarius> LoganCapaldo_: Technically, freedom.
16:08:40 <givi> Philippa: what "don't"?" ? :)
16:09:16 <sorear> givi: hey, some hsers can handle haskell.
16:09:17 <allbery_b> you'd rather he taught them perl?  tcl, perhaps? :)
16:09:18 <augustss> I think Haskell needs a top.  Why should bottoms have all the fun?
16:09:29 <sorear> givi: I speak from personal experience :)
16:09:33 <Philippa> yeah, forall a.a just isn't the same
16:09:44 * edwinb tries not to think about bottoms
16:09:56 <mbishop> _|_
16:10:17 <sorear> ~|~
16:10:35 <ddarius> forall r. (forall a.a -> r) -> r
16:11:01 <Philippa> edwinb: it's gone midnight on a friday and we're in here, I think it's safe to say we've failed to do anything else with them just now...
16:11:01 <augustss> looks like an encoded top
16:11:03 <Cale> Ï
16:11:10 <Cale> nope
16:11:13 <Cale> hmm
16:11:21 <edwinb> Philippa: what better way to spend a Friday evening!
16:11:24 <givi> sorear: :). let me = guess  ;) in hsers == (Haskell users)
16:11:36 <sorear> high scool
16:11:40 <sorear> school
16:12:01 <ddarius> Bah, I'm not going to spend a Friday evening better.  A Sunday, Monday, Tuesday, Wednesday, and Thursday evening, yes.
16:12:02 <Cale> â¤
16:12:03 <sorear> <-- atypically young
16:12:09 <Philippa> edwinb: I guess I can't complain too much, was in london most of the week
16:12:19 <edwinb> I'd complain about that myself...
16:12:30 <Philippa> I'm guessing you don't have a boyfriend there?
16:12:31 * augustss is in London now
16:12:45 <mbishop> http://kawagner.blogspot.com/2007/02/understanding-monads-for-real.html
16:12:48 <edwinb> no, indeed I don't
16:12:48 <lambdabot> Title: Karsten Wagner's Blog: Understanding Monads. For real., http://tinyurl.com/2gslra
16:12:52 <Philippa> ...bad timing, augustss :-)
16:12:57 <edwinb> heh
16:13:02 <givi> sorear: how young are you? ;)
16:13:12 <sorear> 16, if you care
16:13:19 <ddarius> There was a 14 year old here at one time.
16:13:23 <augustss> cool
16:13:36 <Cale> No \top in my scim table
16:13:47 <Philippa> I guess it makes a change from gamedev, and the demo scene isn't what it once was for the kids :-)
16:14:17 <givi> sorear: cool! I'm just sorry I had never heard of Huskell when I was 16
16:14:19 * mbishop is 22, and feels old
16:14:21 * ddarius never really got into Gamedev or the demo scene, but at least the demo scene was somewhat cool.
16:14:35 * ddarius is also 22, but was first here when he was 18.
16:14:39 <LoganCapaldo_> mbishop, hah! I'm 23
16:14:43 <LoganCapaldo_> So there!
16:14:50 * mbishop pokes LoganCapaldo_
16:15:10 * Botje turned 20 this school year.
16:15:28 <Philippa> restaurant staff seem to think I'm under 21 whenever I don't have ID handy
16:15:40 <edwinb> I got asked for id in the supermarket the other week
16:15:41 * givi is 20. I'm a newbie in Huskell
16:15:44 <Philippa> thankfully pub staff're more sensible
16:15:45 <edwinb> I was somewhat astonished.
16:16:01 <Philippa> yeah
16:16:06 <ddarius> I've never really had that issue, but then again, I don't drink.
16:16:09 <edwinb> by someone considerably younger than me...
16:16:20 <tibbe> @sources
16:16:20 <lambdabot>  not available
16:16:23 <tibbe> @source
16:16:24 <lambdabot>  not available
16:16:29 <augustss> Go to Cambridge, Mass if you want to be carded.  They must get ID from everyone buying alcohol.
16:16:30 <bos> @hoogle forM_
16:16:30 <lambdabot> No matches found
16:16:34 <bos> hmph.
16:16:35 <tibbe> @where haskell-98
16:16:35 <lambdabot> I know nothing about haskell-98.
16:16:48 * ddarius again resists the temptation.
16:16:51 <Botje> oh $DEITY. I don't read #haskell-cafe for 3 days, 300 mails
16:16:55 <notsmack> augustss: i'd say that's the rule in most of the US
16:17:05 <edwinb> they never ask me...
16:17:19 <augustss> notsmack: not in my experience.
16:17:22 * allbery_b doesn't get carded for alcohol
16:17:28 <edwinb> although I got asked for ID when trying to pay by credit card in Texas once, and they had to have a debate over whether a British passport was valid ID
16:17:49 <givi> sorear: what's your location on the Earth?
16:17:53 <allbery_b> then again, beyond a certain point it's kind of hard to be mistaken for a young'un :)
16:18:28 <ddarius> Apparently being a grandmother does not necessarily mean you are past that point.
16:19:53 <dons> ?src forM_
16:19:54 <lambdabot> forM_ = flip mapM_
16:21:04 * bos is part of the way through teaching cabal to build binary RPMs.
16:21:16 <sorear> great!!
16:21:35 <bos> yeah :-)
16:21:40 <LoganCapaldo_> @src mapM
16:21:40 <lambdabot> mapM f as = sequence (map f as)
16:21:45 <LoganCapaldo_> @src mapM_
16:21:45 <lambdabot> mapM_ f as = sequence_ (map f as)
16:21:56 <LoganCapaldo_> I can't remember what the _ means
16:21:59 <ddarius> Bah.  Googling my name turns up a mix of that Christian guitarist and me.  That other one seems to dropped off the face of the Earth unsurprisingly.
16:22:02 <Botje> discard output
16:22:11 <ddarius> @type (mapM_,mapM)
16:22:13 <lambdabot>     Ambiguous occurrence `mapM'
16:22:13 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
16:22:23 <Botje> mapM returns an IO something
16:22:23 <sorear> dons...
16:22:25 <sorear> :)
16:22:29 <Botje> whereas mapM_ returns IO (). always
16:22:32 <LoganCapaldo_> Thats what i thought
16:22:36 <ddarius> @type (Control.Monad.mapM,Control.Monad.mapM_)
16:22:39 <lambdabot> forall a (m :: * -> *) b a1 (m1 :: * -> *) b1. (Monad m, Monad m1) => ((a -> m b) -> [a] -> m [b], (a1 -> m1 b1) -> [a1] -> m1 ())
16:23:01 <LoganCapaldo_> ergo, IMO forM = flip mapM_, and forM_ shouldn't exist :)
16:23:16 <LoganCapaldo_> Just like return is exactly like it is in imperative languages :)
16:23:20 <dons> ah yes. need to fix that.
16:30:23 <sjanssen> @hoogle mapM
16:30:24 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:30:24 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
16:30:24 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:30:31 <sjanssen> there's more than one mapM?
16:30:47 <sorear> sure!
16:30:54 <sorear> Data.Traversable
16:30:56 <sorear> new in 6.6
16:31:08 <sorear> @ty Data.Traversable.mapM
16:31:11 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:31:24 <sorear> @ty Data.Traversable.sequenceA -- very elegant type
16:31:27 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Traversable t, Applicative f) => t (f a) -> f (t a)
16:31:32 <Saizan> @ty Control.Monad.Writer.mapM -- this is strange
16:31:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:31:53 <sorear> Saizan: all the MTL modules re-export Control.Monad
16:32:11 <Saizan> ah
16:32:59 <Saizan> uhm, and ghci can realize that's the same mapM?
16:33:34 <sorear> they aren't
16:33:51 <sorear> Data.Traversable.mapM is a class method of Traversable
16:34:05 <sorear> Control.Monad.mapM is (sequence .) . map
16:34:32 <Saizan> i was talking of Control.Monad.mapM vs. Constrol.Monad.Writer.mapM
16:34:54 <sorear> oh
16:34:59 <sorear> those are the same
16:35:08 <sorear> ghci has always been able to see that
16:35:29 <sorear> lambdabot / 6.5 imported both C.M and C.M.W and got no ambiguity errors
16:36:09 <sorear> does anyone else have a very recent HEAD ghc?  -fvia-C seems broken
16:36:18 <augustss> they should have the same original name, so there should be no ambiguity
16:36:54 <tibbe> where are the Hs98 sources?
16:36:54 <augustss> I have a ghc HEAD from a few days ago
16:37:12 <sorear> darcs.haskell.org/packages/haskell98 ?
16:37:23 <sorear> augustss: huh? wrt original names
16:37:41 <sorear> C.M.mapM and D.T.mapM are ***completely different***
16:37:58 <augustss> sorear: nono, C.M and C.M.W
16:38:03 <sm> hum.. is there no way to get Text.Regex with the september 2006 version of hugs ?
16:38:23 <sorear> C.M.mapM and C.M.W.mapM are the same, and I'm *not denying that* - infact old lambdabot could tell they were the same
16:38:31 <tibbe> sorear, um, only almost empty files
16:38:33 <dons> sm, you're using hugs?
16:38:40 <tibbe> there's a @ command that displays them I think
16:38:46 <dons> sm, Text.Regex should be in base
16:38:49 <sm> hi dons.. I'm exploring it
16:39:07 <dons> otherwise, you'd need to build the regex-base and regex-compat packages
16:39:10 <dons> available from hackage
16:39:14 <sm> docs say: the following modules are gone: Text.Regex: moved out of the base 		  package and replaced with a new version that uses 		  too much type class overlapping for Hugs.
16:39:29 <dons> try adding +98
16:39:37 <sorear> tibbe: a lot of the modules in haskell98 delegate all work to http://darcs.haskell.org/packages/base
16:39:39 <lambdabot> Title: Index of /packages/base
16:40:19 * sorear likes the Yhc discussions but could stand to receive fewer buildbot spams
16:40:39 <sm> ok.. hackage and -98 it is.. is there a standard command for installing from hackage ?
16:40:47 <sorear> yes
16:40:48 <dons> they should move buildbot on to yhc-darcs or something
16:40:53 <dmhouse> If you do |data Foo f = forall g. Bar f g => g|, does the 'f' in 'Bar f g' refer to the parameter or is it implicitly universally quantified?
16:40:58 <dons> sm, yeah, they all build using cabal
16:40:59 <sorear> @where yhc-darcs
16:41:00 <lambdabot> I know nothing about yhc-darcs.
16:41:19 <sorear> dons: I want to receive devel discussions - won't all those move to yhc-darcs too?
16:41:35 <dons> maybe
16:41:38 <sorear> dmhouse: the parameter
16:41:49 <sorear> @where mailman
16:41:49 <lambdabot> I know nothing about mailman.
16:41:53 <sorear> @where lists
16:41:54 <lambdabot> I know nothing about lists.
16:42:02 <dmhouse> Hrm. That's good, but means I don't know where my type error's coming from.
16:42:16 <sorear> @where+ lists http://www.haskell.org/mailman/listinfo
16:42:17 <lambdabot> Done.
16:42:31 <sorear> dons: I see no 'yhc-darcs'
16:44:32 <sorear> augustss: everything I've compiled recently using ghc -fvia-C has segfaulted or otherwise misbehaved on running... can you confirm?
16:45:08 <augustss> sorear: even simple programs?
16:45:19 <sm> so, to install the cabal pkg for hugs, I'd do runhugs Setup.hs configure etc. ?
16:46:07 <sm> ah, but with -98 (always.. got to make that default somehow)
16:46:10 <sorear> augustss: relatively simple.  5-line pastes yes.  havent' tried hello world.
16:46:21 <augustss> sorear: I compiled hello world, it worked
16:46:22 <sjanssen> sorear: hello world builds and runs for me
16:47:07 <sorear> hello world works for me
16:47:59 <sm> aiee.. that was working very well, but ERROR "dist/build/Text/Regex/Posix/Wrap.hs":154 - Cannot derive instances of class "Bits" on regex-posix
16:48:04 <sm> well I might not need that one
16:48:19 <sorear> ouch
16:48:30 <sorear> sounds like cunning newtype deriving
16:49:05 <hpaste>  sorear pasted "small program with different behavor under -fasm and -fvia-C" at http://hpaste.org/519
16:49:23 <sorear> augustss, sjanssen: ^^^ my most recent case
16:49:33 <sorear> -fasm - works
16:49:42 <sorear> -fvia-C - internal error panic
16:49:55 <augustss> I'm rebuilding ghc from scratch
16:49:55 <sorear> -fvia-C -O2 -optc-O2 - no output or input
16:51:10 <sm> hugs sep-2006 will load current regex-base from hackage, but complains Text/Regex/Base/Context.hs":196 - Overlapping instances for class "RegexContext" even with -98 and +O
16:52:14 <sjanssen> sorear: works for me
16:52:22 <dons> bah. you should complain vocally to Chris the author, sm.
16:52:23 <dcoutts> sorear, is it ghc or gcc that gets an internal error?
16:52:40 <dons> i'm not convinced the regex packages are as clean as they could be.
16:52:45 <sorear> sjanssen: did you try running it, or did you just compile it
16:52:48 <sorear> dcoutts: neither
16:52:53 <sorear> dcoutts: the executable
16:53:18 <dcoutts> sorear, and yeah it works for me with -fasm and -fvia-C, compiling and running, they get identical results.
16:53:22 <sorear> a.out: internal error: stg_ap_p_ret
16:53:24 <JohnnyL> what does $ stand for?
16:53:34 <dibblego> money!
16:53:37 <sorear>     (GHC version 6.7.20070213 for i386_unknown_linux)
16:53:38 <dcoutts> JohnnyL, it's a function well, and operator
16:53:39 <dibblego> :type ($)
16:53:39 <sjanssen> sorear: I ran it
16:53:42 <sm> dons, thanks, will do
16:53:48 <sorear> oh joy
16:53:50 <dibblego> ?type ($)
16:53:52 <lambdabot> forall a b. (a -> b) -> a -> b
16:54:02 <JohnnyL> And are there many avenues of haskell that you don't need to know, in order to make useful programs under it?
16:54:16 <sorear> yes
16:54:23 <dons> there are many avenues you don't need to know, yes :-)
16:54:26 <ddarius> JohnnyL: Are there many avenues of C++ that you don't need to know.
16:54:37 <sorear> I for one have used list comprehension exactly once in a real program.
16:54:38 <JohnnyL> ddarius, yeah, like templates.
16:54:46 <JohnnyL> and overdone pointer math.
16:55:01 <sjanssen> sorear: I built ghc somewhere around Feb 13
16:55:18 <dons> JohnnyL: have you got a tutorial, and started writing? that's the best way to start.
16:55:26 <sorear> sjanssen: me too
16:55:30 <dons> you could get the basic core of haskell under your belt by the end of the weekend
16:55:35 <sorear> augustss: can you run the paste, with -fvia-C ?
16:55:46 <sorear> (and 6.7.20070213 or similar)
16:56:15 <augustss> sorear: I can run it as soon as I have rebuilt ghc
16:56:33 <sorear> augustss: why are you rebuilding ghc?
16:57:27 <augustss> to make sure I have todays version
16:57:34 <ddarius> @seen shapr
16:57:35 <lambdabot> I saw shapr leaving #happs and #haskell 1h 49m 32s ago, and .
16:59:06 <tibbe> can you encode several things with Binary and write them to a file in sequence and then read them back? ie does the instances for list etc put an end marker after them?
16:59:51 <hpaste>  sorear annotated "small program with different behavor under -fasm and -fvia-C" with "much smaller failing case" at http://hpaste.org/519#a1
17:00:00 <sorear> tibbe: yes, but no
17:00:11 <sorear> tibbe: instance Binary [a] uses a length Int64
17:01:00 <allbery_b> fwiw, with 20070213 I also get the internal error with -fvia-C
17:01:04 <dons> tibbe: you can do that yes.
17:01:10 <allbery_b> (powerpc_apple_darwin)
17:01:58 <sorear> nice.  glad to know I'm not alone.
17:02:15 <sorear> i'll spend a few minutes trying to figure it out on my own, then file a bug
17:03:23 <hpaste>  allbery_b annotated "small program with different behavor under -fasm and -fvia-C" with "whee, internal error" at http://hpaste.org/519#a2
17:08:14 <fnord123> hi all. has anyone here built gtk2hs? For some reason, configure refuses to build with glade support. im wondering which packages on ubuntu i need to satisfy it
17:10:56 <JohnnyL> dons, i like the tutorials i've read, but just as soon as it gets around named fields and data types I hit a wall.
17:11:44 * sm likes the haskell wikibook
17:11:47 <ddarius> JohnnyL: named fields?  Those are extremely straight forward.  Data types are also fairly straightforward.  What's your issue?
17:12:08 <ddarius> If the Haskell wikibook was what I saw, then I don't think I like it.
17:12:10 <sm> and graham hutton's book slides
17:12:38 <tibbe> dons, how would I read a list of Binary a values from a file using hGetContents from BS.Lazy?
17:12:39 <Philippa> pattern-matching was the one thing from Graham's lectures that /really/ stuck with me
17:12:56 <Philippa> though I must've missed it if we got told about named fields in my year. Which is possible, I didn't make every lecture
17:13:07 <JohnnyL> ddarius, well when I see 'pointer foo' where foo is the instance and pointer x is the named field it just makes my head spin. (because the order of other such accessors are the opposite)
17:13:33 <JohnnyL> is $ like ()?
17:13:47 <tibbe> dons, the file is full of Binary a's and I want to read them lazily
17:14:08 <titus> fnord123: have you got libglade2-dev installed?
17:14:52 <dons> tibbe: decodeFile "foo" ?
17:15:09 <tibbe> dons, do I get a [Binary a] from that?
17:15:41 <sorear> sjanssen: what is ghc -V on your system?
17:15:53 <sorear> (and what is your archstring, if you can find it)
17:16:03 <givi> I can't sleep
17:16:16 <tibbe> @paste
17:16:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:16:20 <augustss> sorear: I get no failure with todays ghc
17:16:49 <hpaste>  tibbe pasted "How to read a list of Binary a from file?" at http://hpaste.org/520
17:16:52 <augustss> sorear: freshly built from source
17:16:58 <sorear> augustss: archstring?
17:17:08 <tibbe> dons, ^^
17:19:13 <fnord123> ah i had libglade-dev
17:19:16 <givi> > [x|(x,i) <- zip [6..10] [1..5] if even i]
17:19:16 <lambdabot>  Parse error
17:19:35 <sorear> augustss: I'd like to know what your ghc platform is, for the sake of including a known-no-reproduce system in the bugreport.
17:19:42 <givi> > zip [6..10] [1..5]
17:19:43 <lambdabot>  [(6,1),(7,2),(8,3),(9,4),(10,5)]
17:19:57 <augustss> sorear: i386, MacOS X
17:20:10 <givi> ?index even
17:20:10 <lambdabot> Prelude
17:20:16 <givi> ?src even
17:20:16 <lambdabot> even n = n `rem` 2 == 0
17:20:34 <fax> hi!
17:20:41 <givi> hello!
17:21:05 <fax> I was just wondering about currying and functions that take a variable number of args
17:21:13 <fax> do that exist in haskell?
17:21:17 <fax> does that*
17:21:37 <dufflebunk> Yes it does support currying
17:21:41 <Cale> fax: You can, with some typeclass hackery, get functions with variable number of parameters
17:21:43 <fax> I mean, how is it dealt with (the two of them)
17:21:55 <Cale> All functions in Haskell are curried.
17:21:56 <tibbe> fax, well, depends on what you mean by variable number of args, essentially all haskell functions are functions of one parameter
17:22:00 <Cale> By default.
17:22:04 <fax> tibbe: oh really?
17:22:07 <tibbe> yes
17:22:14 <Cale> I'm lagged badly and I have no idea why.
17:22:15 <fax> ok thats thrown me :D
17:22:24 <givi> > [x|(x,i) <- zip [6..10] [1..5], even i]
17:22:25 <lambdabot>  [7,9]
17:22:45 <tibbe> fax, even operators
17:22:55 <fnord123> not all functions in haskell are curried. surely single arg functions aren;t.
17:23:05 <tibbe> > let inc = (+ 1) in inc 2   -- fax
17:23:07 <lambdabot>  3
17:23:29 <tibbe> it's called a section when used with binary (?) operators
17:24:02 <sorear> augustss, sjanssen, allbery_b: http://hackage.haskell.org/trac/ghc/ticket/1151 -- if anyone cares
17:24:04 <lambdabot> Title: #1151 (small program misbehaves with -fvia-C) - GHC - Trac
17:24:08 <Cale> pedantasaur: Depends on what counts as curried I suppose :)
17:24:42 <Cale> Single variable functions might be considered curried in some vacuous sense.
17:25:08 <ddarius> Categorically, they are considered that way.  Not that this is helpful or germane...
17:25:11 <Cale> You can simulate uncurried functions by functions which take tuples as parameters.
17:25:13 <titus> currying and partial application are different things, no?
17:25:24 <Cale> titus: yes, but related
17:25:44 * dufflebunk watches as people make things more complicated than they have to be
17:25:56 <Cale> currying is the process of making functions take only one parameter and return functions which take the remaining parameters
17:25:58 * ddarius wonders where this confusion of Currying and partial application comes from.
17:26:02 <fax> I think its quite simple to write a function which currys another function
17:26:10 <ddarius> @src curry
17:26:10 <lambdabot> curry f x y = f (x, y)
17:26:13 <titus> Cale: people often seem to say currying when they mean partial application
17:26:22 <Cale> Partial application is the act of applying a curried function to some, but not all of the parameters possible.
17:26:27 <fax> but Im sort of confused about how you knwo whether or not to curry when theres a function call for a function that takes a variable number of args
17:26:32 <Cale> They're easy to confuse.
17:26:41 <Cale> fax: It will just happen.
17:26:56 <ddarius> dufflebunk: It is my theory that most trouble people have with learning most anything is complexity they assume must exist.
17:26:58 <Cale> > let f x y = x + y in map (f 5) [10,20,30]
17:27:00 <lambdabot>  [15,25,35]
17:27:04 * givi solving problems on https://www.spoj.pl/ - the only (known) Online Judge to accept Huskell programms
17:27:08 <Cale> argh, stupid lag :)
17:27:15 <fax> Cale: but f takes two args in that example
17:27:26 <fax> what if it was a different function f which took a variable number of arguments?
17:27:29 <Cale> fax: and look, I applied it to 1 arg :)
17:27:34 <allbery_b> :t let f x y = x + y in f 3
17:27:34 <fax> I understand currying
17:27:36 <Cale> fax: ah, okay
17:27:37 <lambdabot> forall t. (Num t) => t -> t
17:27:49 <Cale> fax: okay, I get what you're asking
17:27:50 <fax> sorry, I must have put my question forward in a pretty confusing way
17:27:56 * givi got "Time Limit Exceeded"...
17:28:06 <fax> im trying to sort out the terminology at the same time as figure this out
17:28:06 <Cale> fax: To get variable numbers of args, you have to play around with the type system a bit.
17:28:07 <allbery_b> short for:  f = \x -> \y -> x + y
17:28:20 <fax> is there any example of that?
17:28:30 <Cale> Text.Printf
17:28:42 <ddarius> @type Text.Printf
17:28:43 <Cale> @source Text.Printf
17:28:44 <lambdabot> Couldn't find qualified module.
17:28:44 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
17:28:45 <allbery_b> and in Haskell you can'
17:28:51 <ddarius> @type Text.Printf.printf
17:28:53 <lambdabot> forall r. (PrintfType r) => String -> r
17:29:04 <allbery_b> t "really" make an uncurried function; it's really a function taking a single tuple as an argument
17:29:31 <Cale> PrintfType is a class which has both function and non-function types as instances
17:30:03 <Cale> It's a pretty clever trick, but not one which you want to play every day.
17:30:17 <Cale> Basically, there should be a really really good reason.
17:30:42 <Cale> I'm not sure if even printf really qualifies -- I don't use it myself :)
17:31:26 <sorear> @source Text.Printf
17:31:27 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
17:31:51 <ddarius> @type Prelude..
17:31:53 <lambdabot> parse error on input `Prelude..'
17:32:09 <Cale> @type (Prelude..)
17:32:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:32:23 <fax> ok so printf takes on argument a string, then it returns a new function which takes one argument (whatever was in the format string), and so on until it gets all the tokens for the format string it needed?
17:32:29 <fax> (am I totally wrong?)
17:32:37 <Cale> fax: Well, hopefully :)
17:32:48 <ddarius> @type Text.Printf.printf
17:32:51 <lambdabot> forall r. (PrintfType r) => String -> r
17:32:51 <Cale> fax: there's no way for the type system to know what the format string actually is
17:32:51 <fax> ahh hehe, well I dont know how this printf works
17:33:02 <JohnnyL> in:    getField :: (BE.BDecodable a, BE.BEncodeKey b) => b -> Torrent -> a     getField key (Tor _ be) = BE.get key be.... is b=key and (Tor _ be) = Torrent, if so where is 'a'?
17:33:09 <ddarius> fax: Printf takes a String and produces ... something.
17:33:12 <fax> Cale: yeah so it makes sense as a runtime error
17:33:38 <Cale> fax: right
17:33:46 <fax> im not seeing how it can read in the numbers and such that it requires
17:33:48 <LoganCapaldo_> I seem to recall seeing a printf-esque function in ML that used constructors instead of a format string
17:33:55 <Cale> fax: It's also overloaded over the final result type
17:34:00 <LoganCapaldo_> Is/can that be more type safe?
17:34:09 <Cale> fax: It could be an IO action for printing the string, or just a String
17:34:09 <ddarius> fax: But as far as varargs is concerned the trick is the (a -> r) instance of the Printf class.
17:34:22 <Cale> Which means that it's also sprintf at the same time :)
17:34:31 <fax> Cale: thats cool :D
17:34:38 <ddarius> LoganCapaldo it both can and is.
17:34:39 <fax> ddarius: what does (a -> r) mean ?
17:34:50 <JohnnyL> fax from #opengl?
17:34:57 <Cale> fax: functions from a to r
17:35:00 <fax> im there right now JohnnyL
17:35:07 <ddarius> fax: It's a function type but without the context the a and r don't make as much sense.
17:35:12 * JohnnyL waves to fax
17:35:17 <fax> JohnnyL: :)
17:35:56 <ddarius> The trick: instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) where
17:36:00 <fax> aha
17:36:08 <fax> I was just looking at that line
17:37:06 <ddarius> Let's say you want a "function" sum' so that sum' 1 2 == 3 and sum' 1 2 3 4 == 10 etc.
17:37:15 <fax> ah yeah
17:37:49 <nornagon> wuh.
17:38:01 <LoganCapaldo_> sum [1,2,3,4]
17:38:06 <nornagon> that's creepy :O
17:38:07 * LoganCapaldo_ whistles innocently
17:38:10 <fax> ddarius: so what do you do next?
17:38:58 <sorear> beschmi++
17:39:08 <ddarius> You make a class, class SumFunction a where sum :: a then an instance, instance SumFunction Int where sum = 0
17:40:02 <sorear> @users
17:40:03 <lambdabot> Maximum users seen in #haskell: 307, currently: 278 (90.6%), active: 42 (15.1%)
17:40:20 <sorear> dons: you lost the seen state again
17:41:22 <dons> sorear: right. i'm in the process of moving it over to the smp box
17:41:36 <fax> ddarius: but then sum will always give 0 ?
17:41:48 * sorear laughs at the speed of dons' lan
17:42:00 <ddarius> I'm working on the tricky part, but I may have slightly jacked up.  Give me a sec.
17:42:02 * sorear bites his tonge
17:42:12 <dons> sorear: ?
17:42:15 * sorear wonders what a tonge is
17:42:26 <fax> oh cool I just thought the whole explanation went right past me
17:42:26 <dons> my lan?
17:42:27 <sorear> the seen state isn't that big, i thought
17:43:07 <dons> hmm?
17:43:07 <slowriot> has anyone here used yampa?
17:43:32 <dons> oh, i'm not literally moving it now. i.e. the state is gone because it got zapped yesterday when i had to shutdown all the boxes with extreme prejudice
17:43:52 <dons> but, as i am moving it soon, i couldn't be bothered haxoring the state
17:44:03 <sorear> @flush ftw :)
17:44:29 <sorear> explanation adequate
17:44:32 <ddarius> fax: Let me make some working code first actually or find some of my old code.
17:46:14 <sorear> so, do we need a bytestring printf yet?
17:48:58 <dons> sorear: hmm. maybe. i hacked a binding to the C printf. but we could always port the 'true' haskell printf
17:49:04 <dons> would be a nice little cabal package
17:49:28 <sorear> ooh?
17:49:36 <sorear> what did you use FFI printf for?
17:49:40 <LoganCapaldo_> hey is there a bytestring parsec?
17:49:58 <sorear> there's a bytestring ReadP ...
17:50:09 <dons> sorear: for hmp3 printing of title strings
17:50:18 <dons> i.e. just for fun
17:50:47 <dons> printfPS :: P.ByteString -> Int -> Int -> P.ByteString
17:50:47 <dons> printfPS fmt arg1 arg2 =
17:50:47 <dons>     unsafePerformIO $ B.createAndTrim lim $ \ptr ->
17:50:47 <dons>         B.useAsCString fmt $ \c_fmt -> do
17:50:52 <dons>             sz' <- c_printf2d ptr (fromIntegral lim) (castPtr c_fmt)
17:50:52 <dons>                         (fromIntegral arg1) (fromIntegral arg2)
17:50:52 <dons>             return (min lim (fromIntegral sz')) -- snprintf might truncate
17:50:55 <dons> :-)
17:51:09 <dons> foreign import ccall unsafe "static stdio.h snprintf"
17:51:09 <dons>     c_printf2d :: Ptr Word8 -> CSize -> Ptr Word8 -> CInt -> CInt -> IO CInt
17:51:22 <dons> "Just a simple functional language"
17:51:59 <LoganCapaldo_> Woah
17:52:07 <LoganCapaldo_> Monads++
17:52:11 <veritos> hey, i have a question. how would one convert a float to a digit-by-string
17:52:24 <sorear> dons: is Data.Binary.Builder something I can "build" on yet?
17:52:39 <dons> > read "3.1415" :: Double
17:52:40 <sorear> > show "2.0"
17:52:41 <lambdabot>  3.1415
17:52:42 <lambdabot>  "\"2.0\""
17:52:52 <sorear> er,
17:52:56 <sorear> > show 2.0
17:52:58 <lambdabot>  "2.0"
17:52:58 <dons> sorear: yeah
17:53:08 <dons> you can build on it
17:53:21 <dmead> hmm
17:53:24 <dmead> SoC page is up
17:53:25 <veritos> i'm trying to get interact to work with it though.
17:53:25 <dmead> apparently
17:53:45 <veritos> i'm learning parsing, and i have:
17:53:52 <veritos> calc :: String -> [Float]
17:53:55 <veritos> main = do
17:53:59 <veritos>  interact calc
17:54:01 <veritos> end code.
17:54:09 <sorear> veritos: type error
17:54:14 <LoganCapaldo_> @type interact
17:54:17 <lambdabot> (String -> String) -> IO ()
17:54:18 <sorear> veritos: interact $ show . calc
17:54:28 <veritos> oh. i like it, thanks.
17:54:28 <dons> interact $ show . calc
17:54:35 <LoganCapaldo_> @type show . calc
17:54:38 <lambdabot> Not in scope: `calc'
17:54:42 <LoganCapaldo_> err oops
17:54:43 <LoganCapaldo_> :)
17:55:01 <dons> String ->D String
17:55:02 <LoganCapaldo_> You get the idea already anyway :)
17:55:12 <sorear> dons: is Builder properly lazy, ie builderToLazyBs (mconcat (repeat (bsToBuilder "foo"))) == "foofoofoo..." | _|_ ?
17:55:25 <veritos> works now, thanks.
17:55:49 <dmead> someone should add documentation for gtk2hs to the list
17:56:38 <dmead> now this is truly an interesting proposition
17:56:39 <dmead> * hyper\ has quit (Read error: 110 (Connection timed out))
17:56:42 <dmead> not that
17:56:53 <sorear> :p
17:57:15 <dmead> http://hackage.haskell.org/trac/summer-of-code/ticket/967
17:57:17 <lambdabot> Title: #967 (hardcore office sex) - Haskell.org Google Summer of Code - Trac
17:57:21 <dmead> ahh spam bots
17:57:49 <dmead> yea
17:57:52 <sorear> wow, google pays for that kind of activity?
17:57:54 <dmead> the whole page is spam'd to hell
17:57:58 <dmead> lol
17:58:10 <sorear> is it possible to delete tickets?
17:58:14 <dmead> not sure
17:58:34 <dmead> yea the whole page is rather f'd up with spam
17:59:01 <dmead> dons
17:59:12 <dmead> delete em man
17:59:14 <dons> we're just going to update trac
17:59:20 <dons> rather than spend time fighting spammers
17:59:24 <dmead> coo coo
17:59:25 <dons> maybe we can just move to the wiki...
17:59:31 <LoganCapaldo_> Can Haskell's type system gurantee things like x + y == y + x ?
17:59:52 <dmead> if you define a type like that sure
18:00:02 <dmead> look at newtype
18:00:06 <fax> how would you define that type?
18:00:16 <dmead> newtype blah = x + y
18:00:17 <LoganCapaldo_> what fax said :)
18:00:31 <Cale> LoganCapaldo_: no
18:00:33 <LoganCapaldo_> dmead, but how does that ensure that + is communative?
18:00:35 <ddarius> Bah, that example is a bit more complicated than I thought.
18:00:46 <dmead> oh
18:00:46 <twanvl> instance Num () where ... :)
18:00:48 <dmead> cause...
18:00:48 <fax> ddarius: :[
18:00:57 <ddarius> It's doable though, but Haskell's helpfulness is a hindrance in this case.
18:00:57 <LoganCapaldo_> Cale, thanks :)
18:00:57 <dmead> how is it not?
18:00:59 <dmead> o0
18:01:27 <dons> Cale: you could check that in the type, given enough olegs , no?
18:01:35 <LoganCapaldo_> dmead, (+) x y = if x == 0 then -y else x + y
18:01:37 <dons> in practice, you'd use QuickCheck
18:01:38 <Cale> dons: okay, maybe :)
18:01:47 <Cale> It would take quite a few olegs though.
18:01:47 * allbery_b vaguely recalls oleg saying on -cafe it *could* be done
18:01:49 <dons> ?check \x y -> x + y == y + (x :: Int)
18:01:51 <lambdabot>  OK, passed 500 tests.
18:01:59 <dons> LoganCapaldo_: ^^
18:02:02 <allbery_b> but, well, saying Oleg can do it is not saying anyone else can do it :)
18:02:12 <Cale> and you'd end up encoding other axioms about + somewhere
18:02:15 <dons> much easier to use QuickCheck
18:02:36 <LoganCapaldo_> dons: I'm not really interested in making sure it is, I'm more curious about making sure anyone who made a Num instance had to have a communative (+)
18:02:48 <LoganCapaldo_> I'm not really talking practically here :)
18:02:51 <dons> ah ok. then yeah, type class hackery
18:02:56 <hpaste>  ddarius pasted "vararg sum" at http://hpaste.org/521
18:02:57 <LoganCapaldo_> just random thoughts popping in my head
18:03:04 <Cale> LoganCapaldo_: right, there's no reasonable way to statically ensure that
18:03:15 <fax> oh wow thanks ddarius :D
18:03:28 * fax tries to undrstand it
18:04:46 <CloudiDust> Hi all, I'm now self-studying the book AIMA, and want to implement the vacuum-cleaner world in Haskell, but could you tell me how I can represent a 2-dimensional map of squares with state in each square and update them effeciently?
18:04:52 * LoganCapaldo_ gets a little far afield
18:05:02 <LoganCapaldo_> Could epigram's type system gurantee it?
18:05:23 * LoganCapaldo_ doesn't even know if epigram has overloading come to think of it
18:05:24 <Cale> fax: basically, variable args is something which you can technically do, but it's more trouble than it's worth. Usually you're better off working with lists of some kind.
18:05:42 <Philippa> I don't think it does, but it can express the requirement
18:06:09 <Cale> CloudiDust: How big of an array?
18:06:50 <Cale> CloudiDust: well, you could use a mutable array, but it might be nicer to use, say, an unboxed immutable array, or potentially a DiffArray.
18:06:56 <dmead> LoganCapaldo_: i'm not sure thats like, useful
18:07:32 <LoganCapaldo_> dmead, this specific example, or the idea in general?
18:07:33 <Cale> (DiffArrays have O(1) update, but you pay for it if you hang on to old copies.)
18:08:02 <dmead> the specific example... not sure if thatd be useful in general
18:08:07 <dmead> and int is an int is an int
18:08:25 <Cale> If you choose to go with a mutable array, you'll have to do your computation in ST or IO.
18:08:49 <CloudiDust> Cale: Oh, Thanks for your suggestion. I prefer the pure way. :)
18:08:52 <LoganCapaldo_> Well you can add more than ints
18:09:03 <dmead> right
18:09:11 <dmead> but i can't think of a type that it would be useful for
18:09:16 <dmead> or isn't already true for
18:09:53 <LoganCapaldo_> well this is jsu pie in the sky stuff
18:10:40 <dmead> maybe
18:10:48 <LoganCapaldo_> Also when the idea came to me I was thinking in the context of certain other languages that are loosely about how you can overload/override thing slike +
18:10:50 <dmead> if it's like imaginary styff
18:10:52 <dmead> like
18:10:53 <hpaste>  sorear pasted " LoganCapaldo_ : abuse GADTs to perform dependant programming at the type level" at http://hpaste.org/522
18:10:58 <dmead> 4 + 3i
18:11:01 <dmead> or 3i + 4
18:11:02 <sorear> muahahahaha!!!
18:11:03 <dmead> etc
18:11:21 <Cale> CloudiDust: DiffUArray is good, though sometimes it can work out that just making copies on update with UArray is easier to get good performance out of.
18:11:33 <LoganCapaldo_> sorear, well I'll be :)
18:11:46 <Cale> If you need to store more complicated values in each cell, you won't be able to unbox though.
18:11:49 <LoganCapaldo_> dmead, well + is a constructor in that case
18:12:02 <LoganCapaldo_> @type 2 :+ 3
18:12:04 <lambdabot> forall t. (RealFloat t) => Complex t
18:12:25 <dmead> i'm thinking mathmatically
18:12:25 <LoganCapaldo_> @type (2 :+ 3) + (1 :+ 0)
18:12:28 <lambdabot> forall t. (RealFloat t, Num (Complex t)) => Complex t
18:12:33 <dmead> but nm anyway
18:12:36 <dmead> hmm
18:12:40 <dmead> i dunno
18:12:54 <dmead> i'm trying to think of a place where communicablity of + is relavant
18:13:10 <sorear> elementary school?
18:13:12 <sorear> :p
18:13:14 <dmead> xD
18:13:28 <Cale> dmead: commutativity?
18:13:35 <dmead> ah ah yea
18:13:36 <LoganCapaldo_> sorear, I feel like you actually did the Curry-Howard thing for that
18:13:43 <dmead> it's an operator, not a disease
18:13:47 <sorear> ?
18:13:47 <Cale> hehe
18:13:55 <LoganCapaldo_> Add a b c implies Add b a c and proved it with a function
18:13:55 <sorear> it IS a curry-howard proof
18:14:02 <sorear> ah yes
18:14:04 <LoganCapaldo_> so that was cool :)
18:14:13 <LoganCapaldo_> (at least to me)
18:14:14 <dmead> logan
18:14:24 <LoganCapaldo_> ?
18:14:39 <dmead> only place i can think of that being important is set concatenation
18:15:34 <LoganCapaldo_> commutativity was just a random example :)
18:15:41 <Cale> + failing to be commutative would make things very very complicated.
18:15:48 <LoganCapaldo_> I was really asking if you could do what sorear just did
18:15:52 <fnord123> has anyone used gtk2hs with anger? I'm just trying to get the tutorial at http://haskell.org/gtk2hs/docs/tutorial/glade/  running, but when I run mainGUI, nothing happens. The program seems to go into the main loop, but no window appears.
18:15:53 <lambdabot> Title: Gtk2Hs » Documentation » Glade Tutorial
18:16:57 <dmead> logan
18:17:02 <dmead> i found where + is relevant
18:17:08 <dmead> i had to ask a pal of mine who teaches math
18:17:25 <dmead> http://en.wikipedia.org/wiki/List_of_small_groups
18:17:40 <dmead> ytea
18:17:45 <LoganCapaldo_> ok :)
18:17:51 <dmead> fnord123: it drove me nuts last night too
18:18:06 <Cale> You could have basically any of those groups as an additive group if + was allowed to be noncommutative
18:18:56 <LoganCapaldo_> Next time I ask a question like this, I'll be sure to use some arbitrary property that doesn't apply in the real world :)
18:19:24 <LoganCapaldo_> Like bar `foo` baz == baz `foo` bar
18:19:31 <Cale> The only real reason we don't talk about noncommutative addition is that we'd just use another notation which didn't involve that symbol.
18:19:46 <dmead> =P
18:19:48 <Cale> + is suggestive of Abelian groups.
18:20:04 * ddarius hugs the geometric product.
18:21:03 <fax> what s geometric?
18:22:10 * LoganCapaldo_ continues to ask about type system fun
18:22:22 <ddarius> @google Geometric Algebra
18:22:24 <lambdabot> http://www.mrao.cam.ac.uk/~clifford/
18:22:24 <lambdabot> Title: Cambridge University GA Research Group
18:22:38 <LoganCapaldo_> So has anyone done anything like using the type system to type check things like m/s^2 ?
18:22:54 <LoganCapaldo_> i.e. dimensional analysis?
18:23:05 <ddarius> LoganCapaldo_: Yes.
18:23:06 <Cale> I've written a type system which did that. I haven't done it in Haskell.
18:23:07 <Philippa> doable, but you need to rip out the existing Num class or use new operators
18:23:32 <LoganCapaldo_> huzzah :)
18:23:36 <Philippa> oh, and you'll need unsafeDimensions for defining certain constants
18:23:51 <LoganCapaldo_> Philippa, please do elaborate?
18:23:54 <dmead> * ddarius hugs the geometric product.
18:23:54 <dmead> <fax> what s geometric?
18:23:54 <dmead> * uebayasi (n=Masao@i218-47-86-201.s02.a014.ap.plala.or.jp) has joined #haskell
18:23:57 <dmead> omg
18:23:59 <dmead> what is up with kde
18:24:02 <dmead> sorry
18:24:13 <dmead> clipboard is freaking out
18:24:20 <Philippa> well, you can probably find a prettier way to do it
18:24:39 <Philippa> but you'll need some kind of coercion
18:24:49 <Philippa> it doesn't have to be a language-level one though
18:24:55 * mbishop pulls out a big stick
18:25:11 <fnord123> der, the tutorial needs windowShow window
18:26:01 <Philippa> mbishop: -blah is thataway -> :-)
18:26:26 * mbishop goes back to hiding
18:26:41 <fnord123> mbishop: are you martinbishop?
18:26:41 <Cale> fnord123: bah, who needs to actually see their windows?
18:26:59 <mbishop> fnord123: yes
18:27:09 <ddarius> Think about the visually impaired!
18:27:13 <fnord123> Cale, I do when ghci hangs as it waits for a mainQuit event :P
18:27:17 <Cale> fnord123: Be content just to construct them and sit in quiet admiration
18:27:20 <fnord123> mbishop: may I message you?
18:27:26 <mbishop> fnord123: sure
18:27:31 <fnord123> if a window is created but does not show, did it exist?
18:27:40 <ddarius> fnord123: Yes.
18:27:51 <ddarius> fnord123: Try creating several billion of them.
18:27:53 <LoganCapaldo_> (/) :: (Unit a, Num b, Unit c) => a b -> c b -> (Over a c) b would be a start I imagine ...
18:30:11 <LoganCapaldo_> I guess maybe you have a new set of dimesioned operators
18:30:21 <LoganCapaldo_> (./.) or something
18:30:30 <ddarius> @google Haskell Dimensional Analysis
18:30:31 <lambdabot> http://www.cse.unsw.edu.au/db/publications/by_year/2004.html
18:30:46 <LoganCapaldo_> that would be good actually because then you define it in terms of (/)
18:30:47 <LoganCapaldo_> err
18:30:55 <LoganCapaldo_> I just realized that type was wrong
18:30:58 <lispy> LoganCapaldo_: i would expect the return type to also be a unit
18:31:16 <allbery_b> @go DimensionH
18:31:17 <allbery_b> ?
18:31:20 <lambdabot> http://dimensionh.com/
18:31:20 <lambdabot> Title: Home
18:31:20 <LoganCapaldo_> @instances Unit --> Over, etc.
18:31:21 <lambdabot> Couldn't find class `Unit --> Over, etc.'. Try @instances-importing
18:31:26 <LoganCapaldo_> ooops
18:31:27 <allbery_b> hm, wrong one
18:31:27 <LoganCapaldo_> ;)
18:32:00 <LoganCapaldo_> if a and c are the same type the result should have the type b
18:32:05 <LoganCapaldo_> Mmm
18:32:12 <LoganCapaldo_> pain in the butt <g>
18:33:30 * LoganCapaldo_ has a negative Oleg rating ;)
18:33:53 * sorear > dinner
18:34:17 <LoganCapaldo_> sorear is greater than dinner?
18:34:27 <sorear> `awayTo`
18:34:37 <allbery_b> you could say he's encompassing it, so obviously :)
18:37:02 <dmead> http://developer.nvidia.com/object/cuda.html
18:37:03 <lambdabot> Title: NVIDIA CUDA
18:38:32 <ihope> @type ap . const
18:38:35 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
18:38:46 <ihope> @type (.)
18:38:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:38:53 <ihope> Not bad.
18:39:04 <LoganCapaldo_> heh
18:39:06 <LoganCapaldo_> hehehhe
18:39:54 <ihope> @type flip
18:39:56 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:40:12 <ihope> Is there a monadic version of that? m (b -> c) -> b -> m c?
18:40:19 <araujo> hello!
18:40:28 <ihope> Ello.
18:41:16 <LoganCapaldo_> @djinn (Monad m) => m (b -> c) -> b -> m c
18:41:17 <lambdabot> Cannot parse command
18:41:19 <allbery_b> :t liftM flip
18:41:21 <lambdabot> forall a b c (m :: * -> *). (Monad m) => m (a -> b -> c) -> m (b -> a -> c)
18:41:38 <ihope> @hoogle m (b -> c) -> b -> m c
18:41:39 <lambdabot> Prelude.asTypeOf :: a -> a -> a
18:41:39 <lambdabot> Prelude.const :: a -> b -> a
18:41:39 <lambdabot> Prelude.seq :: a -> b -> b
18:41:46 <ihope> @hoogle m (m a) -> m a
18:41:47 <lambdabot> Prelude.id :: a -> a
18:41:47 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
18:41:47 <lambdabot> Prelude.asTypeOf :: a -> a -> a
18:41:51 <allbery_b> :t liftM
18:41:54 <ihope> Guess Hoogle doesn't do that.
18:41:54 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:42:29 <LoganCapaldo_> @type (>>= (\x y -> liftM x y))
18:42:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (m a1 -> a1 -> r) -> m a1 -> m r
18:42:37 <LoganCapaldo_> erm
18:42:50 <ddarius> @type (>>= flip ($))
18:42:52 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
18:43:06 <ddarius> @type (>>= return . flip ($))
18:43:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m ((a -> b) -> b)
18:43:11 <ihope> @type \x y -> ap x (return y)
18:43:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
18:43:30 <allbery_b> @pl \f x -> liftM f (return x)
18:43:31 <lambdabot> (return .)
18:43:40 <ihope> @pl \x y -> ap x (return y)
18:43:41 <lambdabot> (. return) . ap
18:43:47 <ihope> How nice.
18:43:51 <LoganCapaldo_> @type (\x y -> do { f <- x; (return . f) y})
18:43:53 * allbery_b thinks he didn't do that right
18:43:54 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> a -> m b
18:44:13 <allbery_b> :t (return .)
18:44:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
18:44:25 <ihope> @type \f x -> f >>= \g -> return (g x)
18:44:27 <lambdabot> forall t (m :: * -> *) b. (Monad m) => m (t -> b) -> t -> m b
18:44:32 <ihope> @pl \f x -> f >>= \g -> return (g x)
18:44:33 <lambdabot> flip (fmap . flip id)
18:44:51 <ihope> I declare (. return) . ap the winner.
18:45:10 <allbery_b> :t (. return) . ap
18:45:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
18:45:17 <allbery_b> yep
18:45:26 <LoganCapaldo_> Yerp
18:47:21 <ihope> @hoogle >	(a -> a -> b) -> a -> b
18:47:21 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>	(a -> a '
18:47:27 <ihope> ...That's not right, now, is it?
18:47:32 <ihope> @hoogle (a -> a -> b) -> a -> b
18:47:32 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
18:47:43 <ihope> Good job, hoogle!
18:48:10 <LoganCapaldo_> @djinn (a -> b -> c) -> b -> a -> c
18:48:10 <lambdabot> f a b c = a c b
18:54:52 <LoganCapaldo_> @djinn when -> will -> you -> learn -> about -> typeclasses
18:54:52 <lambdabot> -- f cannot be realized.
18:55:12 <LoganCapaldo_> good to know ;)
18:55:38 <Cale> @djinn when -> will -> you -> learn -> about -> you
18:55:39 <lambdabot> f _ _ a _ _ = a
18:56:03 <LoganCapaldo_> heh
18:56:23 <ddarius> @type \x y z w u v -> undefined
18:56:25 <lambdabot> forall t t1 t2 t3 t4 t5 a. t -> t1 -> t2 -> t3 -> t4 -> t5 -> a
19:02:47 <glguy> is there a symbol for line intersection?
19:08:23 <dmead> yea
19:08:29 <dmead> it's just like bottom i think
19:08:39 <dmead> wait
19:08:42 <dmead> thats perpendicular
19:08:58 <mbishop> Hmm
19:09:04 <mbishop> fnord123 never did message me
19:09:38 <JohnnyL> i heard that i should stay away from 'do' syntax.
19:10:33 <Cale> glguy: I suppose you could cross out the "parallel to" symbol.
19:12:12 <KEAL> omg i was high as hell. i just found my old logs using google.
19:12:16 <KEAL> XD
19:13:01 <fax> lol wat
19:13:18 <KEAL> google +trk +keal and find the haskell bot code
19:13:37 <KEAL> that was from when i was high as hell and off meds
19:14:05 <Cale> hehe
19:14:07 <Cale> @keal
19:14:08 <lambdabot> endian mirrors the decimal
19:14:11 <mbishop> Maybe it's time to get back on them?
19:14:13 <KEAL> ^-^
19:14:13 * mbishop runs
19:14:17 <KEAL> :P
19:14:22 <KEAL> mbishop is badass
19:14:23 <Cale> @keal
19:14:24 <lambdabot> with KealDigit quantum crackproof encryption possible
19:14:42 * mbishop hides behind Cale
19:14:45 <KEAL> but isnt it m bison? or do i have xmen 2099 confused with street fighter?
19:15:21 <mbishop> m bison is from street fighter, yes, but the m stands for martin, from the movie Sneakers :)
19:15:27 <ray> they changed his name to mbishop so they wouldn't get sued
19:16:26 <KEAL> wasnt Bishop's from xmen 2099 always referred to using only the first initial 'M' when refering to him formally?
19:16:49 <mbishop> Don't know, never saw/played/read xmen 2099
19:16:58 <KEAL> like 'mister M Bishop'
19:17:15 <KEAL> blink was my favorite xmen 2099 character
19:17:35 <KEAL> amazingly gambit was still around for xmen 2099 i think, dont know how he pulled that one off
19:18:07 <sorear> Just two days ago (?) someone asked if Keal was a real person
19:18:13 <KEAL> haha
19:18:36 <KEAL> i have many fans amongst the wallflowers
19:18:41 <KEAL> for my sites and quotes
19:19:07 <KEAL> just yesterday someone popped out of nowhere asking what happened to one of my sites
19:19:52 <KEAL> truth is, it got damn near scary. odd crap going on like being refused to fly aboard an airplane etc
19:20:39 <KEAL> stuff happening like the house being emaculate and all the doors still locked yet my computer room being in shambles and booting a rediculously potent virus
19:21:10 <KEAL> either disturbed fans or the 'feds' really are out to get me ;)
19:21:32 <sorear> @all-dicts emaculate
19:21:35 <lambdabot> *** "Emaculate" gcide "The Collaborative International Dictionary of English v.0.48"
19:21:35 <lambdabot> Emaculate \E*mac"u*late\, v. t. [L. emaculatus, p. p. of
19:21:35 <lambdabot>    emaculare to clear from spots. See {Maculate}.]
19:21:35 <lambdabot>    To clear from spots or stains, or from any imperfection.
19:21:35 <lambdabot>    [Obs.] --Hales.
19:21:37 <lambdabot>    [1913 Webster]
19:21:43 <KEAL> a month ago someone from the internet showed up at the corner store by my house asking for me :(
19:21:57 <sorear> congrats keal, not often someone makes me do that :)
19:22:16 <KEAL> :P
19:22:34 <KEAL> http://mediaplague.com/proxy/?dict=wordgoeshere
19:22:55 <sorear> actually this one uses dict.org
19:22:57 <KEAL> that dictionary allows you to click any word in the definition to forward to another defintion
19:23:14 <KEAL> mine scrapes from dictionary.com
19:23:18 <sorear> sounds not-hard to hack into a dictd client
19:23:29 <sorear> aw, you don't need to do that
19:23:41 <sorear> DICT is a standard protocol any client can speak
19:23:42 <KEAL> i rather just scrape
19:23:51 <KEAL> eventually i intend to cross-scrape
19:23:52 <LoganCapaldo_> @all-dicts immaculate
19:23:54 <lambdabot> *** "Immaculate" gcide "The Collaborative International Dictionary of English v.0.48"
19:23:54 <lambdabot> Immaculate \Im*mac"u*late\, a. [L. immaculatus; pref. im- not +
19:23:54 <lambdabot>    maculatus, p. p. of maculare to spot, stane, fr. macula spot.
19:23:54 <lambdabot>    See {Mail} armor.]
19:23:54 <lambdabot>    Without stain or blemish; spotless; undefiled; clear; pure.
19:23:56 <lambdabot> [51 @more lines]
19:23:57 <sorear> apt-cache search dictd-client or whatever
19:23:58 <Cale> http://dictionary.oed.com/cgi/entry/50112391?single=1&query_type=word&queryword=immaculate
19:24:01 <lambdabot> Title: Oxford English Dictionary immaculate, a., http://tinyurl.com/2axemo
19:24:38 <ray> so am i allowed to endorse this channel as the friendliest one in the world
19:24:43 <KEAL> however ?dict does quite a good job using just dictionary.com
19:24:49 <sorear> jc - is your nick allcaps because chanserv has a tool-long memory
19:25:15 <mbishop> ray: I can't see why not, it'd be hard to prove you wrong :P
19:25:30 <sorear> most of the users with @nick commands have been set AKICK
19:26:01 <KEAL> i'd like to watch a node/thread mapping of all the google spiders as they crawl my ?dict generator ^-^
19:26:42 <encryptio> KEAL: you could run some pagerank-ish algorithm on a set of words and see which ones come out on top
19:26:43 <sorear> general uptospeed stuff - we have a new pastebin, written in Haskell
19:26:47 <sorear> @paste
19:26:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:27:47 <KEAL> i rather had been planning on making a human crawler game where you attempt to crawl thru the definitions using the links without hitting a dead end or hitting the same word's defintion twice
19:29:05 <KEAL> basically akin to the all roads lead to rome courier service math prollem
19:29:26 <KEAL> and making an entire website for just that one thing
19:29:36 <sorear> you are in a maze of twisty little passages, all alike
19:30:49 <nrb23> quick note about the topic: because there are no spaces, this IRC client (Colloquy) doesn't get the URLs split up right at all...
19:31:21 <Cale> ray: absolutely :)
19:31:22 <sorear>  @tell dons that
19:31:46 <KEAL> btw yesterday was my 26th bday
19:31:50 <nrb23> @tell dons  because there are no spaces, this IRC client (Colloquy) doesn't get the URLs split up right at all... Use  ["The Haskell programming language: we know when to use callCC!", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "History: http://tinyurl.com/yowkle", "The language of ICFP winners 3 years running"]
19:31:51 <sorear> yay!
19:31:51 <lambdabot> Consider it noted.
19:31:57 <encryptio> happy birthday!
19:32:03 <nrb23> KEAL: happy bday
19:32:14 <KEAL> if the bot is still capturing what i say, it is going to result in watering down the keal bot
19:32:24 <KEAL> thankers ^-^
19:32:42 <sorear> KEAL: it records what you say - but @keal uses a list literal
19:32:46 <sorear> @where lambdabot
19:32:47 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:32:47 <KEAL> if i still have another bot of me, the database for it, i will submit that for the bot if you'd like
19:32:52 <Cale> KEAL: nah, it just has a database :)
19:33:13 <dons> whoa. is that you keal?
19:33:14 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
19:33:15 <KEAL> the db i have for some other bot is a halbot db
19:33:16 <sorear> and anyway, when we make e.g. @siti we pick the best anyway
19:33:22 <KEAL> yes its me
19:33:36 <KEAL> made by Shea in #quickbasic on efnet
19:33:45 <Cale> <KEAL> omg i was high as hell. i just found my old logs using google.
19:33:48 <nrb23> I find it interesting that the term "Haskell" isn't on this page at all: http://www.cse.unsw.edu.au/~dons/binary/Data-Binary-Get.html
19:33:51 <dons> Cale: ah
19:34:02 <dons> so you're on planet earth now, keal?
19:34:06 <sorear> nrb23: why should it be?
19:34:08 <KEAL> yeppers :P
19:34:26 <nrb23> sorear: it means that googling for "haskell Data.Binary.Get" is not that useful
19:34:26 <newsham> ?seen alexj
19:34:27 <lambdabot> I haven't seen alexj.
19:34:42 <dons> nrb23: interesting. try visiting hackage?
19:34:43 <nrb23> sorear: but if you just google for Data.Binary.Get, you'll find it as the fist link
19:34:47 <dons> ?where hackage
19:34:47 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
19:34:53 <KEAL> atleast i try to be, i am schizophrenic, when my meds either fail to work for some reason, or the lithium i take fails to leave my bladder i go nutzo
19:35:13 <nrb23> dons: I know where to get it.. but I wanted the docs
19:35:19 <dons> nrb23: ok. cool.
19:35:21 <dons> ?where binary
19:35:21 <lambdabot> http://darcs.haskell.org/binary
19:35:30 <dons> ?where+ binary http://www.cse.unsw.edu.au/~dons/binary.html
19:35:30 <lambdabot> Done.
19:35:56 <KEAL> two in every 50 pyche pills i found fail to be potent for some reason, my estimate anyways
19:36:47 <dons> ok. better try to stay on topic though :-) this is a Haskell programming channel after all
19:36:51 <KEAL> when i ran the probability numbers against how i behaved in my blog anyways
19:38:07 <KEAL> yes, i still havent got gci to work proper
19:38:25 <KEAL> and i may have uninstalled it or not transferred it to this new puter
19:38:48 <Cale> ghci. What OS are you running?
19:38:49 <KEAL> first prollem with gci, is no cut/copy/paste in xp
19:39:18 <nrb23> @tell dons Clicking on the ByteString link at http://www.cse.unsw.edu.au/~dons/binary/Data-Binary-Get.html brings you to a 404
19:39:18 <lambdabot> Consider it noted.
19:39:32 <nrb23> @tell nrb23 Test?
19:39:32 <lambdabot> You can tell yourself!
19:39:39 <ray> haha
19:39:48 <nrb23> @tell Lambdabot why should I?
19:39:49 <lambdabot> Consider it noted.
19:39:50 <dons> nrb23: which bytestring link?
19:39:50 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
19:40:01 <KEAL> next difficulty i had with ghci(?) there is no pop up help system that i could find
19:40:03 <nrb23> dons: any of them
19:40:03 <Cale> KEAL: It runs in a standard console window, doesn't it? Or are you talking about something else?
19:40:04 <dons> nrb23: oh, the one for the type 'ByteString'
19:40:09 <dons> nrb23: right I see.
19:40:21 <KEAL> i am talking about the console edition
19:40:24 <Cale> Yeah, there's no pop up help. The documentation is all on the web.
19:40:42 <nrb23> this page too http://www.cse.unsw.edu.au/~dons/binary/Data-Binary.html
19:41:01 <KEAL> without context sensitive pop up help, and clipboard routines, i don't have much ability to make use of it
19:41:32 <Cale> Well, ghci is mostly for testing out short expressions
19:41:34 <KEAL> another prollem: it doesnt use 120 column display for widescreen
19:41:41 <sorear> sure it does?
19:42:06 <sorear> my ghci uses >80 columns
19:42:06 <KEAL> i either need it to do 80x50 or 120x50
19:42:17 <sorear> ghci is a line oriented app
19:42:24 <encryptio> my ghci uses 100 columns
19:42:27 <sorear> it doesn't care how big your screen is
19:42:37 <KEAL> 80x50 with 8x8 glyphset would make for square aspect ratio on my widescreen display
19:42:39 <Cale> GHCi should run in whatever text mode you run it in, and adapt if you change the size while it's running.
19:43:03 <Cale> (because as sorear said, it's just printing characters and newlines)
19:43:27 <KEAL> oh so it is PURE nongraphical console?
19:43:32 <Cale> right.
19:43:45 <KEAL> i don't see much use for that when graphing
19:44:02 <Cale> It's just a console app, and if you have problems with the UI, they're probably the fault of the windows console.
19:44:11 <sorear> haskell is not a graphing calculator?
19:44:20 <Cale> If you want to do graphics, you need a GUI library.
19:44:28 <Cale> (like Gtk2Hs)
19:44:38 <sorear> remember some of us would fork GHCI if it stopped running on a text-only system
19:44:45 <sorear> myself included
19:44:46 <KEAL> what is haskell for then? i was told by a few people that it was simply a mathematics based scripting engine
19:44:55 <KEAL> for producing programs
19:44:58 <Cale> It's a general purpose language.
19:45:29 <KEAL> programs of which no general purpose was predefined
19:45:39 <sorear> > fix ((1:) . scanl (*) 1)  -- why should I need graphics to run this, keal?
19:45:39 <Cale> :)
19:45:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:45:48 <sorear> > fix ((1:) . scanl (+) 1) --bugfix
19:45:50 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:45:54 <Cale> I think you wanted a (+)
19:46:01 <Cale> > fix ((1:) . scanl (+) 1)
19:46:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:46:21 <Cale> Things like mathematical constructions it tends to be pretty good at.
19:46:29 <KEAL> is lambdabot identical to how ghci output works?
19:46:37 <sorear> no, but it's pretty close
19:46:56 <sorear> eg in ghci that won't truncate, it will print fibs forever
19:47:00 <KEAL> do they have ghci scrapers that use the output in the form of a backend?
19:47:03 <Cale> almost, except that lambdabot cuts things off which are longer than a certain amount, and shortens some of the errors.
19:47:08 <KEAL> other than lambdabot i mean
19:47:11 <sorear> KEAL: why?  GHC has an API
19:47:32 <sorear> KEAL: also, lambdabot doesn't use GHCi, it uses the GHC-API directly
19:47:37 <Cale> There's a library called hs-plugins which lets you compile Haskell code at runtime.
19:47:53 <KEAL> like would i be able to use ghci output to run a 3d simulation of a collapsing star for example?
19:47:54 <dons> slava is so funny :-)
19:47:55 <dons> Intercal: a real-world enterprise language which eschews useless academic features
19:47:58 <dons> posted 41 minutes ago by slava_pestov
19:48:00 <Cale> sorear: It actually uses a program called RunPlugs doesn't it? :)
19:48:02 <gravity> hehe
19:48:06 <dons> Cale: right.
19:48:25 <dons> i.e. its own eval system based on compiled objects and dynamic linking
19:48:28 <Cale> dons: sometimes I find him a little tiring :)
19:48:39 <mbishop> Shhh, he can hear you :P
19:48:47 <Cale> He's a little hard on people.
19:49:07 <sorear> whatever caused him to leave the first time?
19:49:10 <Korollary> "A monad is like a 'macro': All it does is a code-transformation." Huh?
19:49:35 <sorear> Korollary: pure functions like >>= do nothing but transform code in normal order :)
19:49:36 <Cale> Korollary: Think of what replacing bind with its definition does.
19:49:56 <Cale> (and return)
19:50:02 <Korollary> it's not syntactic
19:50:37 <dons> Cale: slava's a refreshing glass of bitter bitter lemonade :-)
19:50:40 <KEAL> i don't think i have been answered as to how or why i would want to use haskell for entertainment media purposes
19:51:23 <Cale> KEAL: Well, it's pretty fun to program in it, and there are things like OpenGL bindings and such, but you're free to choose whatever language you like :)
19:51:26 <dons> KEAL: because you're not being specific enough about what you're trying to do (if you're trying to do anything at all with Haskell). and given your past history here, people know you can quickly lead people into off-topic far away lands
19:51:39 <Korollary> no objections to the not syntacticness?
19:51:56 <Cale> Korollary: sure, but he's trying to make an analogy
19:52:01 <KEAL> i want to model stuff like materials etc
19:52:02 <allbery_b> syntactic macros korollary: arguably, in a pure lazy functional language, you don't need syntactic macros.  or at least nowhere near as often
19:52:06 <allbery_b> whoops
19:52:09 <nrb23> this seems silly to me... getBytes takes an int.. but remaining returns an Int64... which means I can't do
19:52:10 <KEAL> in an actual game environmnet
19:52:27 <Cale> Korollary: lazy evaluation lets you do things which people normally to with static syntax transformations at runtime
19:52:27 <Korollary> strange analogy to make
19:52:31 <Cale> do*
19:52:40 <nrb23> do { r <- remaining ; rest <- getBytes r }
19:52:40 <Cale> I think it's actually fairly apt :)
19:52:59 <Cale> What you're really doing when you create a monad is designing a small embedded domain specific language.
19:53:00 <Korollary> We're going off. What does lazy eval to do with it?
19:53:04 <Cale> That's just what people use monads for.
19:53:52 <Cale> Korollary: well, I suppose you don't *need* lazy evaluation, but it helps.
19:53:55 <KEAL> i am a mathematician, a crazy one, but still a mathematician, how would i make use of ghci in order to illustrate to those dumb as a post, complex mathematical theories?
19:54:03 <Korollary> That means it's irrelevant to my question.
19:54:04 <nrb23> > fromIntegral (5 :: GHC.Int.Int64)
19:54:05 <lambdabot>   Not in scope: type constructor or class `GHC.Int.Int64'
19:54:13 <KEAL> my idea would be in the form of entertainment media, such as a video game
19:54:14 <nrb23> > fromIntegral (5 ::Int.Int64)
19:54:15 <lambdabot>   Not in scope: type constructor or class `Int.Int64'
19:54:20 <nrb23> > fromIntegral (5 ::Int64)
19:54:22 <lambdabot>  5
19:54:29 <LoganCapaldo_> Korollary, one of the main things for macros is that it gives you implicit quoting of the arguments so you can control the number of times and the order of evaluation
19:54:31 <allbery_b> @where frag
19:54:31 <lambdabot> http://www.haskell.org/haskellwiki/Frag
19:54:48 <LoganCapaldo_> laziness lets you get away with not needing to control that in many cases
19:54:58 <Korollary> LoganCapaldo_: No, that's one of the "uses" of macros.
19:54:59 <Cale> KEAL: Frag is a simple proof-of-concept first-person-shooter
19:55:16 <dons> KEAL: really, if you're serious, do some research, hack up some code, and then come back and ask us when you get stuck.
19:55:17 <KEAL> bbl afk
19:55:21 <Korollary> In general macros mean syntactic transformations, and that's in no way similar to monads.
19:55:27 <sorear> bye!!
19:55:49 <LoganCapaldo_> Korollary, it's the destination that matters, not the journey ;)
19:55:51 <Cale> Korollary: but the most common use of macros is creating embedded domain specific languages
19:56:03 <Cale> Korollary: and that's what most people associate with them
19:56:12 <Cale> monads have that same goal
19:56:31 <Korollary> You can't say a knife and a pistol are alike because you can "use" them towards the same goal.
19:56:38 <LoganCapaldo_> sure you can
19:56:40 <Cale> Sure you can :)
19:56:41 <LoganCapaldo_> they are both weapons
19:56:42 <araujo> hi
19:56:55 <araujo> dons, hi there
19:57:03 <araujo> dons, join lambdabot to haskell.es !
19:57:06 <Cale> Yeah, we even have a name for the abstraction which they are both instances of.
19:57:08 <LoganCapaldo_> jsut like a car and a boat are alike
19:57:08 <araujo> please :-)
19:57:09 <KEAL> they are similiar in that, 'alike' is a loaded word that is ambiguous as to the translation
19:57:12 <fax> thanks!
19:57:12 <fax> bye
19:57:16 <allbery_b> korollary: mathematically you can, given the right algebra :)
19:57:37 <Korollary> Ok, then everything is a "thing" so we have analogies for any two things.
19:57:45 <glguy> arguing the metaphor serves no useful purpose beyond establishing the correctness of the metaphor :-p
19:58:10 <LoganCapaldo_> Yes just take it to a ridiculous extreme, you win, sorry for bothering. Macros and monads have nothing in common
19:58:44 <allbery_b> macros and monads are very different techniques used to address a common problem space
19:58:55 <newsham> the burning sensation wont last long, eternal peace you must be strong, sahes to ashes dust to dust, a metaphor will never turst
19:58:56 <allbery_b> the same can be said for FP vs. OO, etc.
19:58:58 <Cale> No nonidentical things have anything in common.
19:59:08 <glguy> could macros be used to define continuations? could monads be used to generate compile time class definitions?
19:59:17 <KEAL> my gf is mocking me by whispering dirty into my bluetooth while i do research on the puter -.-
19:59:36 <glguy> KEAL: that same word over and over again?
19:59:44 <glguy> I'd probably take the headset off ;)
19:59:45 <KEAL> no
19:59:51 <LoganCapaldo_> I'm pretty sure you can do continuations w/ macros assuming you have tail calls for instance
19:59:54 <newsham> in a sense arent macros and functions equivalent (or closely related at least) in a pure language?
20:00:09 <newsham> (macros might not have strong type restrictions as functions)
20:00:13 <Cale> newsham: In a lazy language, kind of.
20:00:17 <glguy> newsham: assuming that everything in yourlanguage is firstclass?
20:00:21 <newsham> referential transparency says you can expand definitions
20:00:36 <Cale> newsham: Nonstrict semantics matters
20:00:43 <newsham> *nod*
20:00:49 <newsham> ok, so "pure, non-strict"
20:01:01 <glguy> totally first-class :)
20:01:13 <Cale> yeah
20:01:31 <Cale> Macros which construct values, anyway
20:01:45 <Cale> Macros which construct other things, like types, would be a problem.
20:01:46 <newsham> so anyone wanna write a monad system for CPP?
20:01:49 <Korollary> LoganCapaldo_: Maybe I should highlight what I originally posted: "A monad is like a 'macro': ___All it does is a code-transformation.___" Code transformation?
20:01:54 <Cale> haha
20:02:41 <Cale> I'm lagged 11 seconds from myself.
20:02:49 <Cale> ugh
20:02:57 <Cale> What the heck is going on?
20:03:05 <glguy> drugs?
20:03:08 <Cale> I'm going to reset my connection.
20:03:10 <newsham> [18:00] < Cale> I'm going to reset my connection.
20:03:21 <sorear> @localtime Calse
20:03:24 <sorear> @localtime Cale
20:03:32 <lambdabot> Local time for Cale is Fri Feb 16 23:01:54
20:03:36 <JohnnyL> what's the alternate to 'do syntax'?
20:03:41 <glguy> @localtime sorear
20:03:41 <sorear> 16 seconds by my count
20:03:42 <lambdabot> Local time for sorear is Fri Feb 16 20:02:03 2007
20:03:43 <nrb23> hmm.. I just read the "A monad is like a 'macro': All it does is a code-transformation." line
20:03:44 <glguy> JohnnyL: >>=
20:03:50 <sorear> what, you mean I have a clock? oh well.
20:03:50 <nrb23> should I avoid this blog entry?
20:03:53 <LoganCapaldo_> define code transformation and I'll let you know if I agree with it :)
20:04:01 <JohnnyL> glguy, oh ok. thanks.
20:04:05 <newsham> do { x <- act1; act2expr }  ->   act1 >>= (\x -> act2expr)
20:04:08 <LoganCapaldo_> (the answer is probably not)
20:04:19 <nrb23> http://kawagner.blogspot.com/2007/02/understanding-monads-for-real.html
20:04:21 <lambdabot> Title: Karsten Wagner's Blog: Understanding Monads. For real., http://tinyurl.com/2gslra
20:04:32 <newsham> > [1,2,3,4] >>= (\x -> return (x*2))
20:04:33 <lambdabot>  [2,4,6,8]
20:04:38 <hpaste>  sorear annotated " LoganCapaldo_ : abuse GADTs to perform dependant programming at the type level" with "I can't stop!" at http://hpaste.org/522#a1
20:04:39 <Korollary> LoganCapaldo_: I refuse that. I'd rather quote one more thing from the same entry: "What is a macro? It's something which get some data and dices and splices them."
20:04:42 <newsham> > do { x <- [1,2,3,4]; return (x*2) }
20:04:44 <lambdabot>  [2,4,6,8]
20:04:44 <sorear> LoganCapaldo_: poke ^^^
20:05:25 <beschmi> newsham: I applied your patches and added some (if (shim-windows-p) ...) to shim.el. I don't think the mount .shim to / hack is needed since .shim is only used for logfiles
20:06:04 <newsham> beschmi: emacs creates the logfile and passes the path name to shim, no?
20:06:07 <sorear> @localtime Cale
20:06:08 <JohnnyL> are there macros in haskell?
20:06:11 <newsham> I got some errors in emacs at some point.
20:06:13 <JohnnyL> like lisp?
20:06:13 <sorear> no
20:06:14 <LoganCapaldo_> Well if a macro dices and splices data a monad is obviously exactly like a macro :)
20:06:18 <newsham> johnnyL: temlatehaskell
20:06:21 <newsham> non-standard
20:06:25 <lambdabot> Local time for Cale is Fri Feb 16 23:04:47
20:06:30 <sorear> 18 seconds
20:06:32 <LoganCapaldo_> So yes, with more context
20:06:36 <sorear> using a clock this time
20:06:41 <LoganCapaldo_> I don't think that's valid
20:06:47 <Cale> hmm, still behaving poorly.
20:06:57 <newsham> beschmi: do you know of a way to handle the two build environments in the same cabal file?  or does it need a separate cabal file for win32?
20:06:57 <beschmi> newsham: i see. i don't use the cygwin emacs, so i didn't notice
20:07:02 <Cale> Must be at the ISP level. I wonder what's going on.
20:07:21 * sorear ping(8)s Cale
20:07:26 <Korollary> Cale: run a dsl benchmark
20:07:26 <newsham> beschmi: is there a mingw emacs?  if so thats probably the best recommendation for people who arent married to cygwin
20:07:27 <beschmi> newsham: perhaps ifdefs in Setup.hs
20:07:31 <sorear> 64 bytes from CPE004854805910-CM000e5cdd834a.cpe.net.cable.rogers.com (74.114.58.144): icmp_seq=1 ttl=52 time=80.9 ms
20:07:37 <sorear> ^^^ looks quite fast to me
20:07:55 <LoganCapaldo_> sorear, you've done gone and broken my brain some ;)
20:08:23 <newsham> beschmi: ah, one solution.. cygwin has a utility:  cygpath -w <pathname>  will give back the windows path
20:08:30 <Cale> sorear: that's interesting
20:08:40 <KEAL> that haskell frag game just looks like doom maps with 3d models instead of prerendered sprites for 3d entities
20:08:43 <newsham> if you can detect cygwin in the elisp file and run cygpath that would eliminate the need for a mount
20:08:44 <KEAL> :(
20:09:00 <newsham> newsham@lenoxp$ cygpath -w `which ghc`
20:09:01 <newsham> c:\ghc\ghc-6.6\bin\ghc
20:09:10 <beschmi> newsham: this was just the first emacs installer i found http://ourcomments.org/Emacs/EmacsW32.html
20:09:11 <lambdabot> Title: EmacsW32 Home Page
20:09:39 <newsham> besch: cool.
20:10:04 <newsham> if its not too hard would be good to support cygwin and non-cygwin emacs...
20:10:05 <sjanssen> has anyone actually listened to the LugRadio/Haskell trainwreck?
20:10:08 <beschmi> newsham: or i just make shim-directory customizable (with ~/.shim as default)
20:10:29 <newsham> its already customizable by the .emacs file, isnt it?
20:10:46 <beschmi> newsham: then cygwin users  can just set it to "C:/tmp/shim"
20:10:53 <newsham> you mean env var?
20:11:10 <newsham> that would be fine I think
20:11:19 <Korollary> sjanssen: What is LugRadio anyway?
20:11:26 <newsham> i wonder if there can be other headaches due to cygwin vs. non-cygwin paths...
20:11:34 <beschmi> newsham: i forgot that emacs has to create the directory
20:12:29 <newsham> might be easiest to just have the elisp detect if its cygwin or not, and if it is, run cygpath before passing any paths on to shim.
20:12:54 <newsham> i dunno how easy that is :)
20:13:14 <sjanssen> Korollary: it's an internet radio show -- Linux and free software oriented
20:13:25 <sorear> beschmi: Unexpected error while trying the second compile: "Shim/Hsinfo.hs:538:8-33: Irrefutable pattern failed for pattern (_ : modulename : _)
20:13:26 <sjanssen> I think it kinda sucks
20:13:27 <beschmi> newsham: sounds like the cleanest solution, should be pretty easy
20:13:30 <Korollary> sjanssen: Do they have a lot of listeners or something? Why would we care?
20:14:25 <sjanssen> Korollary: it was just some ignorant bashing
20:14:32 <emu> beschmi: i use emacs with mingw all the time
20:14:46 <emu> er, newsham
20:14:47 <newsham> emu: well now you should be able to use shim too :)
20:15:07 <sorear> back
20:15:09 <Korollary> sjanssen: I see no reason to be sensitive to correct every random Joe's ignorance.
20:15:10 <sorear> @botsnack
20:15:11 <lambdabot> :)
20:15:11 <beschmi> sorear: should be fixed, can you look if you're a patch?
20:15:29 <sorear> beschmi: I pulled about a minute ago
20:15:57 <sorear> and it still fails after restarting emacs
20:16:00 <sjanssen> Korollary: okay
20:16:01 <newsham> ?where shim
20:16:02 <lambdabot> http://shim.haskellco.de/trac/shim
20:16:11 <sorear> no new patches on pull
20:16:33 <beschmi> sorear: what does the file look like?
20:16:58 <sorear> beschmi: full text: http://hpaste.org/522/1/plain
20:17:06 <sorear> in a file "/tmp/com+/X.hs"
20:17:16 <beschmi> sorear: i had the same error message when there were no imports and fixed that, but there seem to be be other cases
20:17:59 <newsham> (_:modulename:_) = words s
20:18:44 <newsham> why is that an compile-time error?
20:19:07 <sorear> beschmi: the problem is that the module header is missing
20:19:15 <dons> :t let f s (_:x:_) = words s in f
20:19:18 <beschmi> sorear: yes, didn't think about it
20:19:21 <lambdabot> forall t. String -> [t] -> [String]
20:19:44 <sorear> beschmi: and what are you doing using incomplete patterns!
20:19:47 <sorear> :)
20:20:00 <newsham> if you look a few lines higher you see that the string always has several words
20:20:05 <sorear> newsham: wrong
20:20:05 <newsham> he bulids the string before he runs words on it
20:20:15 <Korollary> Haha: "Since I am not interested in microbenchmarks, I haven't measured the
20:20:16 <Korollary> runtimes. Can your version easily be extended at runtime?"
20:20:26 <sorear> newsham: no
20:20:28 <beschmi> sorear: if the current buffer fails to compile, i load a file that contains only the import lines
20:20:38 <newsham> s = "module "++modulename++" () where\n" ++onlyimports
20:20:41 <dons> Korollary: hmm?
20:20:43 <newsham> (_:modulename:_) = words s
20:20:48 <beschmi> sorear: so that you get completion
20:20:53 <sorear> dropExports s = "module "++modulename++" () where\n" ++onlyimports
20:20:53 <sorear>  
20:20:59 <sorear> see! s is lambda bound
20:20:59 <Korollary> dons: from http://groups.google.com/group/comp.lang.functional/tree/browse_frm/thread/6154282c209d2f7f/21537dd4f5a7cddb?rnum=161&hl=en&_done=%2Fgroup%2Fcomp.lang.functional%2Fbrowse_frm%2Fthread%2F6154282c209d2f7f%2Fd3137d088adcc07f%3Ftvc%3D1%26hl%3Den%26#doc_024ca002340e3abb
20:21:03 <lambdabot> Title: comp.lang.functional | Google Groups, http://tinyurl.com/27wpbr
20:21:07 <newsham> oh, sorry, my bad
20:21:14 <newsham> didnt read very carefully :)
20:21:16 <beschmi> sorear: i don't think the module header makes any difference there
20:21:25 <sorear> beschmi: I tried it.
20:21:28 <beschmi> sorear: so i can just drop it
20:21:35 <sorear> beschmi: adding a module header fixed the problem.
20:21:52 <sorear> beschmi: ergo the lack of a module header is guilty.
20:22:04 <Korollary> dons: ocaml beats sbcl by 6x in a "microbenchmark", which is why Pascal Costanza is "uninterested" in it.
20:22:09 <dons> hehe
20:22:31 <beschmi> sorear: dropExports s = unlines . dropWhile (lineNotPrefixed ["import "]) . lines $ s
20:22:51 <beschmi> sorear: yeah i know
20:23:37 <sorear> what if "module Foo where import ..." ? can your system handle that?
20:23:38 <beschmi> sorear: i try to find out the module name from the module header to create a new one without exports
20:23:52 * sorear is beginning to strongly dislike shim's ad hoc haskell parser
20:24:08 <dmead> hey guys
20:24:16 <dmead> is it just me
20:24:19 <dmead> or is firefox slow
20:24:20 <dmead> like
20:24:23 <beschmi> sorear: i'm not sure these fallbacks are a good idea
20:24:26 <dmead> rly slow
20:24:29 <Korollary> dmead: It happened to me, too.
20:24:42 <sorear> beschmi: what do you mean "fallbacks"?
20:24:56 <Korollary> dmead: I ended up saving my bookmarks and importing into a new profile.
20:25:06 <sorear> I just use elinks
20:25:10 <beschmi> sorear: there are some fallbacks if ghc can't parse the current file
20:25:11 <dmead> profile in firefox?
20:25:26 <sorear> beschmi: shim is complaining about a file ghc has *no trouble* with
20:25:28 <dmead> or netscape
20:25:35 <beschmi> sorear: e.g you want to have completion when you create a new file
20:25:53 <sorear> beschmi: this file exists, is clean, is type correct.
20:26:01 <beschmi> sorear: hmm, then it's another bug ;)
20:26:01 <Korollary> dmead: Yes. Firefox.
20:26:33 <beschmi> sorear: all this ad hoc parsing should only happen if the first load fails
20:26:44 <dmead> i wasn't aware ff used profile
20:26:46 <dmead> s
20:27:48 <newsham> latest shim builds on my system (with cabal edit), but not working properly...
20:27:58 <newsham> trying to track it down...
20:28:50 <beschmi> newsham: i think it's the logfile thing
20:29:11 <newsham> beschmi: i think you got the wiat-for-socket wrong for win32
20:29:27 <sorear> beschmi: how much simpler would shim be if there was a semi-standard library for extracting as much parsable text as possible from an incomplete source file?
20:29:29 <newsham> wait, nevermind.. my bad reading of lisp code ;-)
20:29:50 <newsham> logfile shouldnt be a problem for me since I have the mount in place
20:29:57 <sorear> (let's assume it works well :) )
20:30:37 <newsham> shim-server exited unexpectedly: exited abnormally with code 1
20:30:38 <beschmi> sorear: a bit simpler, but it could do much more
20:30:52 <sorear> ? on the second clause
20:31:11 <newsham> if i run shim manually it seems to be working though.. so must be the args getting passed in?
20:31:38 <beschmi> sorear: for now, it drops everything but the imports. so if more of the source could be extracted, you could do much more
20:32:08 <beschmi> newsham: yes, i forgot that cygwin emacs passes shim a cygwin path
20:32:33 <newsham> beschmi: but I still have my cygwin mount in place so the cygwin path should agree with the ghc path.
20:32:44 <newsham> (mount c:\.shim /.shim)
20:33:33 <beschmi> newsham: i changed that back to ~/.shim
20:33:38 <newsham> oh
20:34:13 <newsham> so do I have to install shim in ~/.shim now?
20:34:19 <sorear> beschmi: imagine if GHC had "fatal warnings" that produce interpass output but disable code generation.  Now imagine that the parser errors are fatal warnings, and you get some subset of the definitions/imports, along with a "this is semi-bogus" flag.  how does this world sound?
20:34:27 <goban> are there any go libraries in haskell?
20:35:15 <dons> goban: not that i'm aware of.
20:35:26 <dons> would be a good domain though
20:35:43 <magnus_> goban: there's a go ai written in a functional language but I can't remember which language nor its name
20:35:45 <beschmi> sorear: i think some of this is already possible, e.g you can get HsSyn with RdrNames even if typechecking fails
20:36:25 <sorear> beschmi: I know that.  but if a pass fails, you can't get that pass's output.  what if you could?
20:36:37 <goban> magnus_: im making a AI client for chess variants and go for my server, was thinking id see some examples :)
20:36:59 <sorear> beschmi: as in, unparsable lines are skipped with a fatal warning - but shim can still see the others in the HsSyn
20:37:49 <sorear> beschmi: this is just me brainstorming the future, trying to get a little feedback from the one (?) person who understands shim's architecture
20:37:55 <Korollary> actually, SBCL is doing great at the shootouts. When did it replace CMUCL?
20:38:38 <magnus_> goban, where is your server?
20:38:39 <beschmi> sorear: i think that would help, but i didn't think much about advanced features
20:40:00 <beschmi> sorear: and haskell's layout rules should make it easier to skip unfinished parts/parts with error than in other languages
20:40:50 <chessguy> 'evening haskellers
20:41:30 * sorear waves
20:41:32 <beschmi> sorear: The main function `main' is not defined in module `Main'\nWhen checking the type of the main function `main'
20:42:23 <sorear> I'm afraid I don't properly understand the significance of that string.
20:42:35 <goban> magnus_: the server/normal client are both in java since i didnt know haskell yet when i started
20:43:01 <newsham> beschmi: shim doesnt catch IO exceptions and log them, does it?
20:43:25 <goban> currently 16 chess variants and go are supported http://figs.cvs.sourceforge.net/figs/FIGS/
20:43:26 <lambdabot> Title: SourceForge.net Repository - [figs] Index of /FIGS
20:43:49 <goban> someone is donating their 4 processor 100mbps server :))))
20:44:06 <goban> and chessguy said he would help with the AI client (in haskell)
20:44:19 <araujo> hola chessguy
20:44:20 <JohnnyL> what's so bad about using 'do' syntax?
20:44:25 <nornagon> nothing
20:44:26 <araujo> JohnnyL, nothing
20:44:26 <beschmi> sorear: ghci loads your file, but ghc -c and shim fail because there is no main
20:44:27 <sorear> @hoogle Bits a => a -> Int
20:44:28 <Korollary> JohnnyL: Nothing
20:44:28 <chessguy> who, me? :)
20:44:29 <lambdabot> Data.Bits.bitSize :: Bits a => a -> Int
20:44:29 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
20:44:29 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
20:44:35 <nornagon> it's just that you should understand what's going on behind it
20:44:37 <allbery_b> some people feel it's confusing
20:44:38 <chessguy> hola amigo!
20:44:42 <araujo> :-)
20:44:46 <nornagon> it's misleading
20:44:48 <sorear> ah
20:44:48 <nornagon> at first
20:44:54 <sorear> beschmi: ah.
20:45:00 <newsham> some people disagree that everyone needs to understand whats going on behind it.
20:45:02 <goban> chessguy: hey :) this is rc-1
20:45:03 <allbery_b> many of us find monads make a lot more sense when you understand what's going on with >>=
20:45:03 <sorear> > bitSize (0::Int)
20:45:06 <lambdabot>  32
20:45:09 <sorear> awww :(
20:45:11 <LoganCapaldo_> The problem with do-syntax is that it's impossible to use it on reddit ;)
20:45:14 <chessguy> ,howdy
20:45:19 <beschmi> newsham: not when starting
20:46:13 <dons> LoganCapaldo_: that's been fixed as of last night
20:46:22 <dons> so feel free to toss < around all you want
20:46:58 <LoganCapaldo_> huzzah
20:47:54 <newsham> ahh, its passing in a path to the windows version
20:48:02 <newsham> not sure why...
20:48:31 <newsham> beschmi: a big catch around the whole thing would be useful to catch errors like this
20:48:40 <newsham> right now it dies silently
20:48:51 <newsham> (when trying to convert the path to an integer)
20:49:06 <newsham> shim-windows-p must not be working right for cygwin.
20:49:14 <beschmi> newsham: your emacs doesn't get detected as windows?
20:49:33 <newsham> can I print system-type from emacs somehow?
20:49:50 <beschmi> newsham: can you try M-: system-type
20:50:20 <newsham> ahh cygwin32
20:51:55 <newsham> ok.. with "~/.shim/" -> "/.shim/" and 'cygwin -> 'cygwin32  its working again
20:52:11 <newsham> 
20:53:37 <newsham> so just need the "32" and a cygpath hack and should be good to go
20:54:07 <newsham> (an error catcher/logger would be useful in the future)
20:54:17 <goban> eeeeek at {- for comments -}
20:54:29 <lispy> goban: it's not so bad once you get used to them
20:54:30 <newsham> > "how about" -- comments
20:54:33 <lambdabot>  "how about"
20:54:43 <lispy> goban: they kinda seem like anything else after a bit
20:54:58 <goban> yeah -- isnt so bad but { makes my brain scream BLOCK :)
20:55:06 <lispy> although, MLs (* this is a comment *) is hard for me after being a lisper
20:55:07 <newsham> haskell has {blocks}
20:55:12 <sorear> BLOCK ?
20:55:19 <newsham> > do { x <- [1,2]; return (x*9) }
20:55:20 <lambdabot>  [9,18]
20:55:39 <newsham> its a block of quotes...
20:55:47 <lispy> (* this is a comment) -- could be valid lisp if "this", "is", "a", and "comment" are variables...
20:55:55 <LoganCapaldo_> > [ x * 9 | x <- [1,2] ]
20:55:57 <lambdabot>  [9,18]
20:56:17 <goban> lispy you need a trailing *
20:56:33 <goban> (* this is a comment *)
20:56:33 <lispy> goban: ah yeah, sorry...but since we can say (setf * 1), it's all good
20:56:42 <orbitz> woo i got hudaks book
20:56:43 <LoganCapaldo_> (* this is an operator section in haskell that doesnt type check)
20:56:44 <lispy> because then we could use * as a function or a value
20:57:01 <sorear> lispy: you use lisp-2 *gulp*
20:57:06 <gravity> I'm importing System.IO.Error, but ghc --make is telling me that the IOError data constructor is out of scope. Anyone know why?
20:57:17 <lispy> sorear: er, well that _is_ lisp, i never mentioned scheme :)
20:57:19 <sorear> IOError is private IIRC
20:57:39 <sorear> or rather abstract
20:57:52 <sorear> so you can't ref the dcon from a diff module
20:58:19 <gravity> sorear: So do I just not use it? I'm trying to catch an EOF exception and throw the exception if it's not EOF
20:58:23 <LoganCapaldo_> (* well this could type check) -- assuming someone did something silly like made (Sometype -> Sometype) an instance of Num
20:59:16 <allbery_b> isEOFError
20:59:27 <lispy> LoganCapaldo_: silly?
20:59:32 <sorear> @localtime Cale
20:59:34 <lispy> LoganCapaldo_: iirc, someone had a good use for that :)
20:59:40 <LoganCapaldo_> let f * g = (\x y -> (f x) * (g x)) in ((+2) * (-2)) 2 2
20:59:43 <lambdabot> Local time for Cale is Fri Feb 16 23:58:02
20:59:44 <gravity> allbery_b: Yeah, I use that in the if test, but what do I use for the else?
20:59:49 <LoganCapaldo_> > let f * g = (\x y -> (f x) * (g x)) in ((+2) * (-2)) 2 2
20:59:50 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
20:59:50 <lambdabot>     Probab...
20:59:58 <sorear> Cale: 10secondes
20:59:59 <allbery_b> Church numerals?
21:00:12 <LoganCapaldo_> lispy, I mean silly in the nicest way possible :)
21:00:53 <sorear> ouch midnight :/
21:00:57 <allbery_b> also consider Control.Exception.catchJust
21:01:09 <bd_> :t Control.Exception.catchJust
21:01:12 <lambdabot> forall b a. (GHC.IOBase.Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
21:01:40 <sorear> :t Prelude.catchJust
21:01:42 <lambdabot> Not in scope: `Prelude.catchJust'
21:01:45 <gravity> That's more advanced than where I'm at, but I'll have a look
21:01:47 <sorear> :t System.IO.catchJust
21:01:50 <lambdabot> Not in scope: `System.IO.catchJust'
21:01:54 <sorear> :t System.IO.Error.catchJust
21:01:57 <lambdabot> Not in scope: `System.IO.Error.catchJust'
21:38:44 <sorear> @seen shapr
21:38:45 <lambdabot> I saw shapr leaving #happs and #haskell 6h 30m 41s ago, and .
21:38:46 <sorear> @users
21:38:47 <lambdabot> Maximum users seen in #haskell: 307, currently: 273 (88.9%), active: 32 (11.7%)
21:39:01 <Cale> hey, hmm
21:39:14 <sorear> vhat?
21:39:18 <Cale> seems that things have gotten better regarding my connection
21:39:31 <Cale> I'm back to 0.1s ping.
21:39:44 <Cale> (maybe less)
21:40:14 <Cale> and reddit loads all at once, rather than a few headlines at a time :)
21:40:52 <sorear> yay!
21:43:26 <sorear> hmm, your client uses very differt ping codes than mine
21:45:12 <Cale> I'm seeing things like "* Ping reply from sorear: 2553.66 second(s)"
21:45:23 <Cale> when I haven't sent you a ping
21:45:35 <Cale> (I did send you one, and it gave me a sane reply)
21:45:52 <sorear> dumb client then
21:46:03 <sorear> must be using the ping code as a simple timestamp
21:46:12 <sorear> which I've been playing with
21:46:27 <sorear> about 3 hrs?
21:46:34 <Cale> 251.92 second(s)
21:46:48 <Cale> > 251.92 / 60 / 60
21:46:50 <lambdabot>  6.997777777777776e-2
21:46:52 <sorear> ok, not a count of seconds then
21:48:02 <sorear> ah, well, I've got more fun things to do than reverse engineer xchat
21:48:12 <sorear> esp given that apt-get source is so close :)
21:49:00 <sorear> I've used 4 irc clients, and ERC is the only one that lets me send what I want, when I want so send it
21:49:19 <sorear>  /ctcp is so confusing I don't bother to use it
21:49:29 <sorear>  /msg Cale VERSION
21:49:53 <sorear> hmm, a few actually responded to that!
21:50:34 <Cale> hehe
21:50:34 <sorear> BitchX and IRCII
21:50:50 <sorear> erm uebayasi is using Riece
21:51:01 <sorear> ooh, SunOS 5.8
21:51:20 <sorear> and a 5.9
21:51:25 <sorear> how old is that? :p
21:55:09 <sorear> > bitSize 'x'
21:55:10 <lambdabot>   add an instance declaration for (Bits Char)
21:55:11 <lambdabot>     In the expression: bitSize ...
21:55:14 <sorear> > bitSize 0
21:55:15 <lambdabot>  Add a type signature
21:55:19 <sorear> > bitSize 0::Int
21:55:20 <lambdabot>  Add a type signature
21:55:23 <sorear> > bitSize (0::Int)
21:55:24 <lambdabot>  32
21:55:36 <sorear> still waiting I see
21:57:19 * sorear is now building HAppS
21:57:28 <sorear> glguy: poke
21:57:42 <sorear> glguy: what is the current procedure for running a test hpaste?
21:57:50 <sorear> @localtime glguy
21:57:52 <lambdabot> Local time for glguy is Fri Feb 16 23:56:13 2007
21:58:09 <sorear> hm, I hope he *doesn't* respond :/
21:58:44 <Cale> @localtime Cale
21:58:46 <lambdabot> Local time for Cale is Sat Feb 17 00:57:07
21:59:02 <Cale> I had coffee not so long ago, I'm wide awake
22:00:08 <sorear> gak, HAppS has failed to compile
22:00:10 <sorear>     No instance for (?style::Element -> XML Element)
22:00:38 <Cale> Implicit parameters?
22:01:27 <bd_> dynamic parameters I thought?
22:02:27 <bd_> oh, no, implicit
22:02:47 <sorear> yeah :/
22:13:29 <dons> boo on implicit params
22:13:35 <dons> you can always rewrite them to use a monad anyway
22:16:26 <sorear> looks like I won't become an hpaste dev today :/
22:17:43 <dons> hmm. you using a new ghc /
22:17:47 <dons> 6.6 should work fine
22:19:04 <sorear> "not in scope: thefor"
22:19:28 <sorear> 6.6 might work, but the version of xhtml associated with 6.6 won't.
22:19:34 <sorear> extralibs--
22:19:59 <bos31337> any cabal hackers around?
22:21:05 <dons> sorear: that's an older version of xhtml or haxml, iirc you need the darcs repo of haxml
22:26:24 <araujo> dons, ?
22:27:33 <sorear> dons: is it possible to use the darcs version of an extralib with the non-darcs version of GHC?
22:28:20 * sorear is trying it now ... but doubts sucess
22:28:39 <dons> you can, yes.
22:28:46 <dons> but 'thefor' was in haxml I thought....
22:28:48 <dons> not xhtml
22:29:04 <dons> i have xhtml-2006.9.13, HaXml-1.13.2
22:29:10 <dons> HAppS-0.9.0
22:30:07 <malsyned> what does everybody recommend for dealing with xml?  HaXml?  HXT?  A third thing?
22:30:20 <sorear> dons: those are the versions I have, unsucessfully
22:30:27 <dons> malsyned: haxml or hxt
22:30:33 <dons> with xhtml for some things
22:30:45 <dons> sorear: due to ghc head breaking on implicit params?
22:30:48 <dons> or missing 'thefor' ?
22:31:03 <malsyned> what's the pros/cons for haxml and hxt?  why would you use one or the other?
22:31:10 <sorear> dons: no, I'm trying with 6.6 now
22:31:20 <araujo> dons, can you get lambdabot into haskell.es please?
22:31:23 <sorear> malsyned: one is much older than the other, I believe
22:31:28 <sorear> @join #haskell.es
22:32:15 <sorear> araujo: there are several admins - me, dons, and Cale (maybe more) are awake now
22:32:32 <sorear> @where lambdabot
22:32:33 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:32:59 <sorear> araujo: http://www.cse.unsw.edu.au/~dons/lambdabot/online.rc
22:34:54 <dons> araujo: oh hmm. no lambdabot2?
22:35:06 <sorear> @seen lambdabot
22:35:06 <lambdabot> Yes, I'm here. I'm in #haskell.es, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow,
22:35:06 <lambdabot> #haskell-blah and #haskell
22:35:18 <dons> right. but lambdabot2 should be there.
22:35:19 <sorear> @part #haskell.hac07
22:35:22 <sorear> @join #haskell.es
22:35:24 <dons> i guess it died in the update
22:35:34 <sorear> araujo: is it there yet?
22:35:52 <sorear> d'oh
22:36:03 <sorear> "I'm in #haskell.es"
22:36:08 <dons> ah, but i can just run normal lambdabot with a different online.rc now
22:36:18 <dons> (i.e. the nick is configurable now?)
22:36:32 <dons> yes. looks like it
22:36:38 <sorear> yes, it's the fourth(?) token on the connect line
22:36:42 <dons> yep
22:36:49 <sorear> you can even have two connect lines in the online.rc file
22:38:03 <sorear> dons: after upgrading to xhtml 3000, hpaste compiles
22:38:53 <sorear> dons: what is the local hpaste procedure now?
22:40:02 <dons> don't recall. glguy knows.
22:43:31 <sorear> apparently a nick collision is enough :)
22:45:48 <sorear> dons: local hpaste is workign
22:45:53 <dons> good
22:49:09 <araujo> dons, no
22:49:21 <araujo> ok, now lambdabot is there :-)
22:49:40 <araujo> Good to know sorear
22:50:22 <sorear> araujo: why is #haskell.es still +sp?
22:50:36 <sorear> private+secret
22:50:42 <bos> what's the first argument of formatTime supposed to look like?
22:50:53 <bos> it wants a TimeLocale.
22:50:59 <sorear> means I can't see who is there (except be joining)
22:51:16 <bos> i guess defaultTimeLocale.
22:52:04 <dons> bos, like formatCalendarTime defaultTimeLocale fORMAT time
22:52:37 <dons> and , eg., fORMAT   = "%d_%m_%Y.html"
22:53:45 <araujo> sorear, is it? :-|
22:53:50 * araujo checls
22:53:52 * araujo checks
22:54:11 <araujo>  Channel #haskell.es modes: +sn
22:54:19 <sorear> ERC> /who #haskell.es
22:54:19 <sorear> ERC>
22:54:34 <int-e> +s :/
22:54:46 <sorear> I just assumed it was +sp, since I couldn't see them
22:54:50 <araujo> yes
22:54:55 <araujo> i can see them
22:55:05 <bos> and i get time via what, Data.Time?
22:55:29 <int-e> /mode #haskell.es  works without joining
22:55:34 <sorear> and as a english monolingual, some unseen force appears to be preventing me from just joining :)
22:55:49 <araujo> uh?
22:55:59 <araujo> you can't join?
22:56:09 <sorear> I'm sure I could ...
22:56:23 <araujo> oh
22:56:30 <araujo> sorear, we welcome everybody :-)
22:56:57 <araujo> some english speakers visit the channel too
23:01:54 <gmh33> I forget, does Haskell have a mechanism for tail recursion optimization?
23:02:04 <sorear> yes
23:02:08 <sorear> but be careful
23:02:18 <gmh33> I assumed it would :)
23:02:27 <sorear> lazyness and tail recursion interact in strange ways
23:02:36 <gmh33> ah, right..
23:02:49 <gmh33> it's demanding the resolts from.. itself..
23:03:11 <sorear> for instance, this is usually good: f n = if n /= 0 then 'x' : f (n-1) else []  -- not tail recursive
23:04:05 <sorear> and this is usually bad: f lst acc = case lst of [] -> acc ; x : xs -> f xs (x+acc)  -- tail recursive
23:04:29 <sorear> the second one might be optimized to a stricter form, but don't count on it
23:04:48 <sorear> accumulating parameters can hurt you badly
23:05:08 <sorear> > foldl (+) 0 [0..1000000]  -- tail recursive
23:05:13 <lambdabot>  500000500000
23:05:17 <sorear> > foldl (+) 0 [0..10000000]  -- tail recursive
23:05:21 <lambdabot> Terminated
23:05:38 <bd_> > foldl' (+) 0 [0..10000000]
23:05:42 <lambdabot> Terminated
23:05:48 <bd_> or just plain too slow :)
23:05:48 <sorear> hmm.  apparently lambdabot is optimizing a bit more now :)
23:07:11 <int-e> using ghc 6.6 now.
23:09:32 * sorear goes off to write HAppS.Protocols.IRC
23:11:08 <gmh33> Type classes seems like such a great feature, I wonder why more languages haven't adopted it..
23:12:16 <skew> They're still a bit rough
23:12:28 <skew> like, you can't declare something an instance of a type class in more than one way
23:13:30 <gmh33> it seems to make more sense then the ML/O'Caml way
23:13:48 <gmh33> ML uses overloading and O'Caml uses ugliness
23:14:29 <dons> than ML modules?
23:14:41 <skew> The basic idea is great though, give the compiler partial definitions and let it put them together for whatever type you are using
23:15:17 <gmh33> which should be determinable, yay
23:15:27 <dons> the reason no other languages have typeclasses, is that those other languagges are older than haskell. the  newer research FP langs do have them
23:15:31 <dons> oh, and Isabelle
23:15:42 <dons> though F# is a special case, I guess
23:15:53 <gmh33> does F# count?
23:16:11 <skew> ML just overloads for arithmetic and equality, right? If you get into functors the ML module system resembles type classes a lot, except you have to put instances together yourself
23:16:18 <skew> see "Modular Type Classes"
23:17:21 <skew> Hey dons, have you looked into that bug with recursive evals?
23:17:41 <dons> yeah, they're a superset of typeclsas functionality
23:17:46 <dons> skew, nope.
23:17:58 <dons> i'd need a use case and a proper bug report. :-)
23:18:22 <skew> Now that I think about it, it might even have some practical applications - consider trying to dynamically load something that itself tries to load stuff
23:18:50 <sorear> dons: my first nontrivial bugrep: #1151
23:19:09 <sorear> *overly excited*
23:19:21 <skew> That example just came to mind because I had been puzzling over the logical soundness of Epigram extended with eval.
23:20:08 <skew> How about I send a bug report if I have a good reason to actually do that and it breaks - or I figure out how to fix it.
23:37:15 <coffee-mug> wow, I just played around with seaside (the web framework)
23:37:18 <coffee-mug> it's very very impressive
23:40:23 <abz> coffee-mug: whats impressive about it?
23:44:59 <gmh33> closures/continuations?
23:48:17 <coffee-mug> closures/continuations are definetly impressive
23:48:22 <dons> and more importanly,  can you hack it up in haskell over the weekend? :-)
23:48:23 <coffee-mug> but I'm not sure how useable it is
23:48:38 <coffee-mug> it's only useable if you want "modal" pages
23:48:42 <coffee-mug> which is rare
23:48:49 <coffee-mug> dons: I was thinking of that :)
23:49:14 <coffee-mug> the thing with Haskell is that GHC's support for complicated SYB situations kind of sucks
23:49:19 <coffee-mug> you have to do a lot of stuff manually
23:49:28 <dons> yeah. so you don't see a lot of SYB
23:49:34 <abz> what does: "internal error: evacuate: strange closure type" this mean (in the content of a ghc error message)
23:49:37 <dons> though, have you looked at the new unified generics package?
23:49:41 <dons> abz, runtime system bug
23:49:43 <malsyned> wtf SYB?
23:49:48 <coffee-mug> dons: no, when was that in?
23:49:54 <coffee-mug> malsyned: Scrap Your Boilerplate
23:50:03 <malsyned> thx
23:51:04 <abz> right. thanks.
23:51:19 <coffee-mug> dons: I only see a reference to it from some time in October
23:51:22 <coffee-mug> but no real information
23:51:49 <malsyned> OK.  Trying to install HXT as a regular user.  what am I doing wrong?  ./setup --prefix=$HOME/local --user --ghc configure; ./setup build; ./setup install    ==>  setup: /usr/local/lib/hxt-7.1: createDirectory: permission denied (Permission denied)
23:51:58 <coffee-mug> without excellent reflection support good web apps just aren't going to happen
23:52:32 <coffee-mug> also, one thing I constantly ran into was lack of symbols
23:52:44 <coffee-mug> I don't know
23:52:47 <coffee-mug> it's hard :)
23:53:36 <dons> abz, if you can reproduce it with ghc 6.6 , please report a bug
23:53:45 <dons> ?bug <--
23:53:46 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
23:54:00 <dons> coffee-mug: btw, i'm not sure how aware people in the community are of the need for generics to do web apps
23:54:10 <dons> it might be worth a query on the -cafe@
23:54:11 <int-e> do the options work if they're placed before the 'configure'?
23:54:23 <dons> coffee-mug: http://haskell.org/haskellwiki/Libraries_and_tools/Generic_programming
23:54:25 <lambdabot> Title: Libraries and tools/Generic programming - HaskellWiki, http://tinyurl.com/284ro7
23:54:28 <skew> coffee-mug: lack of symbols?
23:54:33 <malsyned> oh.  interesting question int-e.  I'll try that.
23:54:44 <dons> there's a mailing list, darcs get http://darcs.haskell.org/generics
23:54:46 <lambdabot> Title: Index of /generics
23:54:53 <coffee-mug> skew: basically I can't pass a name of a function to some other function
23:55:03 <coffee-mug> and then have it call that function by name
23:55:12 <dons> not sure how far along the repo is.
23:55:32 <malsyned> int-e: ay!  that worked!
23:55:37 <dons> coffee-mug: right, you'd have to do your own symbol table. but tell me, why do you want to do that kind of thing?
23:55:41 <malsyned> except, package.conf: does not exist
23:55:42 <dons> the use case is not obvious to me
23:55:55 <gmh33> malsyned: how about throwing a sudo or su - in there?
23:56:04 <malsyned> gmh33: the whole point is that I don't want to do that.
23:56:21 <coffee-mug> dons: essentially I did do my own symbol table and I wrote some stuff in TH to generate it which was a pain in the ass
23:56:23 <gmh33> create the necessary directories first then?
23:56:28 <coffee-mug> anyway, the reason I want to do it is the following
23:56:46 <malsyned> Is there something I have to do to initialize a regular user cabal system before I try to install packages to it?
23:56:48 <coffee-mug> in a web app when I send the user HTML
23:56:53 <coffee-mug> on the next request all I have is text
23:57:06 <abz> dons: that URL lambda bot gave is broken
23:57:18 <coffee-mug> so, for example, I have something like "add_to_cart"
23:57:21 <dons> oh hmm.
23:57:24 <abz> or miss configured
23:57:34 <coffee-mug> so I need to map "add_to_cart" to a similarly named function
23:57:36 <sorear> works for me
23:57:36 <coffee-mug> in my code
23:57:42 <abz> better now, the DB was locked
23:57:45 <skew> Ah, right. Sounds like a reasonable thing to do, as opposed to reflection in general which kinda break parametericity and other nice stuff, and thus needs to be boxed up somehow
23:57:54 <sorear> abz: you need a special password
23:57:59 <dons> coffee-mug: but you know statically all the valid symbols?
23:58:03 <sorear> abz: we've done otherwise in the past
23:58:08 <dons> so you can do your own symbol table, Map String Function
23:58:10 <dons> ?
23:58:13 <sorear> @where soc
23:58:14 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
23:58:15 <coffee-mug> dons: yes
23:58:21 <coffee-mug> dons: that's what I ended up doing
23:58:24 <sorear> abz: check out the soc page
23:58:31 <dons> ok. interesting. might be a good puzzle to post to the generics guys
23:58:41 <sorear> abz: you'll see quickly why the ghc trac is configured the way it is
23:58:45 <abz> sorear: soc page?
23:58:45 <dons> abz, yeah, just log in as guest
23:58:58 <sorear> abz: http://hackage.haskell.org/trac/summer-of-code/ <-- read this
23:59:00 <coffee-mug> I should really take some time and publish an article on problems I ran into
23:59:03 <dons> abz, he's just pointing out that the non-login trac we also have, is covered in spam
23:59:04 <lambdabot> Title: Haskell.org Google Summer of Code - Trac
23:59:12 <dons> sorear: i'm not sure that's helpful :)
23:59:21 <coffee-mug> 'cause when people only write positive stuff it doesn't give others the chance to improve :)
23:59:22 <int-e> malsyned: echo '[]' > package.conf  (in the right directory of course) works, I don't know if there's a proper way.
23:59:35 <skew> how did the TH work? I imagine you could just wrap the whole module in a quote, and have a macro that makes a map covering that file
23:59:55 <dons> coffee-mug: you should participate in the community, i.e. the mailing list, since the blogosphere doesn't get read by the guys doing generics.
23:59:56 <malsyned> int-e: perfect.  thanks!
23:59:58 <Korollary> Can a webuser's interactions with the server not be represented by a grammar? Why would one need reflection?
