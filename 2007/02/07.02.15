00:09:56 <cjs> Hm. That didn't seem to work for me before; I must have been unwittingly doing something different. Well, thanks.
00:13:00 <dons> hehe /topic on ##c++ "this is C++, we all have our segfaults"
00:13:06 <lispy> > reverse $ dropWhile isSpace $ intersperse ' ' (reverse "haskell")
00:13:08 <lambdabot>  "h a s k e l l"
00:13:26 <lispy> > reverse $ filter (not.isSpace) $ intersperse ' ' (reverse "haskell")
00:13:28 <lambdabot>  "haskell"
00:14:09 <lispy> ?scheck \s -> reverse $ filter (not.isSpace) $ intersperse ' ' (reverse "s") == s
00:14:10 <lambdabot> Couldn't match expected type `[Char]' against inferred type `Bool'
00:14:23 <lispy> ?scheck \s -> reverse $ filter (not.isSpace) $ intersperse ' ' (reverse s) == s
00:14:24 <lambdabot> Couldn't match expected type `[Char]' against inferred type `Bool'
00:14:30 <lispy> gah, what am i doing wrong?
00:18:19 <dons> parens
00:18:44 <lispy> ?scheck \s -> (reverse $ filter (not.isSpace) $ intersperse ' ' (reverse s)) == s
00:18:46 <lambdabot>   Completed 1957 test(s) without failure.
00:18:49 <lispy> ah, right
00:18:57 <lispy> well, it must be abosuletly true
00:19:11 <lispy> > reverse $ filter (not.isSpace) $ intersperse ' ' (reverse " haskell") == " haskell"
00:19:11 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Bool'
00:19:12 <dons> that many unit tests can't be wrong
00:19:19 <lispy> > (reverse $ filter (not.isSpace) $ intersperse ' ' (reverse " haskell")) == " haskell"
00:19:21 <lambdabot>  False
00:19:24 <lispy> oh snap!
01:28:38 <Cheery> Hi. I'd like to write a text editor and some interactive graph software, what could I use?
01:29:14 <quicksilver> in this channel, I'm strongly inclined to suggest you could use haskell
01:30:48 <Cheery> quicksilver: I'm looking for a less obvious answer, like stuff I could use to write GUI software in haskell.
01:31:08 <dons> gtk2hs makes a good gui for a text editor
01:31:13 <dons> we used it in hIDE and yi
01:31:32 <dons> if you want to start with a mostly complete text editor,
01:31:37 <dons> ?where yi
01:31:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
01:32:05 * mux wonders what kind of software hasn't been written in haskell by dons already :)
01:32:05 <Cheery> dons: gtk2hs == gtk bindings to haskell?
01:32:13 <dons> integrati ve graph software. mm. Dazzle is pretty nice for this
01:32:17 <dons> oh, it also uses gtk2hs
01:32:19 <dons> Cheery: yeah
01:32:22 <dons> ?where dazzle
01:32:23 <lambdabot> I know nothing about dazzle.
01:32:28 <dons> ?google dazzle haskell
01:32:31 <lambdabot> http://www.cs.uu.nl/dazzle/
01:32:31 <lambdabot> Title: Dazzle
01:32:45 <dons> ?where+ dazzle http://www.cs.uu.nl/dazzle/
01:32:45 <lambdabot> Done.
01:33:00 <dons> so, i'd start with yi or hIDE, gtk2hs and dazzle
01:33:55 <Cheery> dons: thanks!
01:34:08 <dons> mux, i haven't written a web browswer
01:34:14 <mux> ah. :-)
01:35:57 <Cheery> I could have expected that, otherwise there would be a reasonable choice among web browsers. ;)
01:36:27 <profmakx> hey, i get a load of IRCRaised Data.Binary.Get.takeExactly exceptions from my lambdabot, anything known about that?
01:44:17 <Axioplase> are there (famous) games written in haskell ?
01:44:58 <ibid> you mean famous implementations of games or implementations of famous games?
01:45:09 * ibid wrote an n-in-a-row a year ago
01:45:34 <kolmodin> there is an fps called frag
01:47:40 <musasabi> I think there is a rogue-like too.
01:50:21 <siti> me and a friend are writing a game in haskell, I don't know what you mean by famous, do you mean commercial games?
01:50:39 <musasabi> nethack is famous and not commercial.
01:51:08 <siti> ahh yeah, but there are few good free games :p
01:51:25 <siti> I never have got in to nethack though
01:52:05 <nornagon> nethack ftw
01:56:09 * mux doesn't play nethack since he finished it
01:56:13 <mux> I play ToME now :)
02:01:15 <TSC> It looks similar to Nethack; is it much different?
02:04:20 <mux> TSC: it's the same kind of game, but quite different yeah
02:04:31 <TSC> Sounds like worth trying out
02:04:37 <mux> ToME has a much more vast world, with many different dungeons, a lot more objects and monsters
02:08:16 <vincenz> Anyone know a good paper on the denotational semantics of records?
02:12:01 <dons> profmakx: rm State/seen
02:12:04 <dons> the binary format changed
02:12:28 <profmakx> i checked out a clean copy from darcs
02:12:36 <profmakx> but i`ll try anyway
02:13:05 <dons> ah ok. i might hvae left the old format in darcs
02:13:15 <profmakx> yep. it works now ;)
02:13:22 <dons> right. i'll fix that
02:13:59 <profmakx> thanks ;)
02:21:18 <quicksilver> is there a reason why (!) isn't defined in a typeclass?
02:21:33 <quicksilver> so I don't have to faff around with Map.! and Array.!! etc?
02:23:47 <vincenz> quicksilver: the type for ! and !! are incompatible
02:24:02 <vincenz> afaict
02:24:08 <vincenz> @type (!)
02:24:09 <vincenz> @type (!!)
02:24:10 <nornagon> :t (!)
02:24:10 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
02:24:11 <nornagon> oh.
02:24:13 <lambdabot> forall a. [a] -> Int -> a
02:24:13 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
02:25:08 <Cale> Not that incompatible. You could perhaps make things manageable with a fundep.
02:25:41 <quicksilver> :t Data.Array.!!
02:25:43 <lambdabot> parse error on input `Data.Array.!!'
02:31:00 <dcoutts> Cheery, do you mean graphs like plots of data/functions or like graphs as nodes and edges?
02:39:00 <RemiTurk> good morning
02:41:44 <dcoutts> @seen aking
02:41:45 <lambdabot> aking is in #gentoo-haskell and #haskell. I don't know when aking last spoke.
02:41:58 <michaelw> hmm, could please somebody remind me how to cast an integer value to float?  IOW, make (2::Integer / 3) work
02:42:07 <dcoutts> dons, good SoC summary in reply to Bulat
02:42:25 <dons> dcoutts: oh, btw, rl is back at unsw
02:42:28 <dcoutts> > fromIntegral (3 :: Int) :: Double
02:42:29 <lambdabot>  3.0
02:42:33 <dcoutts> dons, ah right
02:42:35 <dons> so i'll be sending out a mail about icfp and stream fusion
02:42:38 <dons> and what we need to do
02:42:41 <dcoutts> ok
02:42:59 <michaelw> dcoutts: thanks
02:43:29 <dcoutts> michaelw, of course you don't need the explicit type annotations
02:44:28 <michaelw> dcoutts: I have a variable of type integer already which I want to use
02:45:58 <quicksilver> dcoutts: you won't need the (::Integer) part with a variable, since haskell will already know what type that is, probably
02:46:04 * quicksilver blinks
02:46:12 <quicksilver> dcoutts: didn't really mean to say that to you, but whatever :)
02:46:41 <quicksilver> michaelw: you won't need the Double part either if you have given your function type annotations or given the inferrer clues in other places
02:47:06 <nornagon> @instances Num
02:47:07 <lambdabot> Double, Float, Int, Integer
02:51:46 <michaelw> quicksilver: i have let prob = 2 / fromIntegral i, really, and i is of type Integer, so there are no extra type annotations
02:52:41 <michaelw> heh, and my random tester found the first error while we were speaking :)
03:19:26 <Cheery> dcoutts: nodes and edges.
03:19:50 <dcoutts> Cheery, so are you just displaying or you need interactive drag style editing?
03:20:06 <dcoutts> if it's not fully interactive then I use graphviz + gtk2hs for this
03:20:23 <dcoutts> I've done an app before for displaying and editing constraint graphs
03:20:44 <dcoutts> using graphviz to generate a png or svg which I load up in the gui
03:20:57 <dcoutts> http://haskell.org/~duncan/gtk2hs/Constraints%20Viewer.png
03:22:13 <Cheery> dcoutts, interactive.
03:22:26 <Cheery> but possibly not necessary, I know how to make them interactive myself.
03:22:35 <dcoutts> ok
03:25:26 <huschi> any maintainer of missingh here?
03:25:43 <quicksilver> @seen jgoerzen
03:25:44 <lambdabot> I haven't seen jgoerzen.
03:26:07 <quicksilver> maybe he doesn't IRC. If he doesn't I have clearly forgotten his nickname.
03:26:22 <Cheery> http://i.thefairest.info/funniest_thumbs/IHbAB4.jpeg
03:26:27 <Cale> @seen CosmicRay
03:26:27 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 1h 22m 30s ago, and .
03:26:41 <huschi> quicksilver: do you know, how i can send him a patch for missingh?
03:27:00 <Cale> CosmicRay is John Goerzen
03:28:03 <huschi> Cale: how can i send him a patch? there is no information about this on the missingh website.
03:28:57 <Igloo> dons: I have no objection re uncons
03:29:02 <Cale> good question. I'd probably e-mail him
03:29:13 <huschi> Cale: do you know his email?
03:29:24 <Cale> one sec, I'll get it
03:29:39 <Cale> jgoerzen@complete.org
03:29:43 <huschi> ah, i found it in the docs.
03:29:47 <huschi> thx, although.
03:34:48 <quicksilver> why is the "fold" page on the haskellwiki just a copy-paste of the wikipedia page?
03:34:56 <quicksilver> How does that add value over a link to wikipedia?
03:35:49 <Cale> quicksilver: It was suggested that I duplicate it there, so I did.
03:36:20 <Cale> quicksilver: Wikipedia is in more danger of being edited to hell than the Haskell wiki :)
03:36:49 <Cale> (I basically wrote that article wholesale)
03:37:04 <xic> man, i'm having a big problem understanding HXT
03:37:07 <xic> like the deep function, it's supposed to take a predicate, but it's argument has the form: Tree t => a (t b) (t b)
03:37:09 <xic> how am i supposed to create such a predicate?
03:37:28 <Cale> xic: the arrows you use are filters
03:37:57 <quicksilver> Cale: hmm, I guess so
03:38:00 <Cale> deep takes a filter which decides whether to keep something or not, and applies it everywhere, down to the levels where it matches
03:38:02 <quicksilver> Cale: seems odd to me :)
03:38:25 <Cale> quicksilver: it's also good seeding for the Haskell wiki
03:38:43 <xic> Cale: so the predicate arrow would be either the identity arrow, or an arrow that outputs an empty tree?
03:38:45 <Cale> It creates new dead links that people might want to fill in with new content :)
03:38:54 <Cale> xic: typically
03:39:08 <Cale> xic: it doesn't have to be, but that's usually the idea
03:39:18 <xic> Cale: what happens if the predicate arrow outputs something else?
03:39:37 <Cale> xic: then you get those things rather than the original content
03:40:19 <Cale> So it's like a map and filter at the same time
03:40:25 <xic> Cale: hm... ok. the deep function returns an arrow, what is the result of this arrow? a root node with children that are all of the matching elements?
03:40:51 <Cale> Okay, all the arrows are processing streams of XML trees, turning them into other streams of XML trees.
03:41:35 <Cale> They do this in such a way that they act on individual elements of the stream independently.
03:41:48 <Cale> Producing zero or more results in the output stream.
03:42:11 <Cale> (well, nearly so, technically, you can thread some state along)
03:42:51 <xic> this sounds pretty complicated :\
03:43:43 <Cale> What (deep x) does when it gets a tree is that it runs x on all of the subtrees of that tree, recursively, until it gets a nonempty response
03:44:11 <Cale> (by "until" there, I mean it won't recurse any deeper -- it will still continue with siblings)
03:44:32 <Cale> and it returns a stream of all the responses it gets collected together
03:44:37 <Cale> it's used to locate things
03:45:03 <Cale> It's hard to explain, but actually pretty simple to use.
03:45:08 <Cale> Let's look at some examples.
03:45:31 <Cale> okay...
03:45:58 <Cale> I have in my RSS aggregator a function called atTag
03:46:09 <Cale> atTag tag = deep (isElem >>> hasName tag)
03:46:40 <Cale> If I have an HTML document, and I use  atTag "a"
03:47:11 <Cale> then it will give me a list of all the links on the page
03:47:15 <xic> ok
03:47:45 <Cale> isElem tests to see if the thing is an element (and not an attribute, text block, etc.)
03:48:04 <Cale> and hasName tag checks to see that the name of that element is tag
03:48:27 <Cale> deep recursively applies this to everything in the HTML document
03:48:37 <Cale> and collects all the results
03:48:38 <xic> ok
03:49:09 <Cale> (or XML document, of course)
03:49:13 <quicksilver> "the Real World is strict - in order to drink tea, you have to put the cattle on the fire, wait until water boils, brew tea and then drink"
03:49:25 <quicksilver> I'm thinking that's more like a beef stew, than tea
03:49:27 <quicksilver> but whatever
03:49:41 * xic hopes that is not from another blog post bashing haskell
03:49:47 <quicksilver> xic: mailing list
03:49:54 <Cale> xic: does that help a bit?
03:49:56 <quicksilver> xic: to be fair, I believe he's copy-pasting from a forum
03:50:02 <RemiTurk> hi everybody
03:50:06 <Cale> xic: Let's try something a little more interesting :)
03:50:15 <xic> Cale: yeah, up till here i think i understand, but i still don't get the thing about "streams"
03:50:32 <Cale> xic: well, okay
03:51:10 <Cale> It's fairly fundamental to the way that HXT works, so I'll do my best to explain it -- you could probably get by without really thinking too much about it, but things make more sense if you do.
03:51:32 <dons> quicksilver: the real world is _sequenced_, not necessarily strictly
03:51:36 <dons> e.g. http://xkcd.com/c222.html
03:51:37 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
03:51:44 <dons> lazy evaluation
03:52:25 <SimonRC> I just thought up an unofficial slogan for Haskell:
03:52:25 <dons> and an awful lot of things are call by name: that's why you never understand something till you write it down and you *force/seq* that knowledge :)
03:52:40 <SimonRC> "Forever between the two elephants."
03:52:41 <vincenz> http://www.cs.rit.edu/~bja8464/lambdavm/
03:52:42 <vincenz> o.O
03:52:42 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
03:52:58 <Igloo> dons: Pah, he'd already said he'd been well
03:53:08 <Cale> Basically everything in HXT works at some level by turning lists of XmlTrees into some other kind of lists, usually also lists of XmlTrees
03:53:18 <dons> hehe. no sharing Igloo !
03:53:20 <dons> dear oh dear
03:53:24 <Cale> xic: are you familiar with the list monad?
03:53:46 <dons> vincenz: yeah, we should get the author to releae /anounce on the mailing list
03:53:47 <Igloo> no sharing?
03:53:47 <xic> Cale: i've read about it, but never actually used it
03:53:49 <dons> since i'd never heard of this
03:53:51 <Cale> okay
03:53:56 <Cale> well, how about list comprehensions?
03:54:00 <vincenz> dons: that's pretty impressive
03:54:09 <Cale> The list monad is basically the same as list comprehensions
03:54:14 <quicksilver> dons: yes, I know. I was mainly pointing figures at 'putting cattle(sic) on the fire'
03:54:26 <Cale> > do { x <- [1,2,3,4]; y <- [10,20,30,40]; return (x+y) }
03:54:27 <lambdabot>  [11,21,31,41,12,22,32,42,13,23,33,43,14,24,34,44]
03:55:00 <SimonRC> I am trying to find the reference for that odd remark...
03:55:01 <Cale> 'x' and 'y' are elements chosen non-deterministically from those lists
03:55:17 <quicksilver> [(x+y) | x <- [1,2,3,4], y <- [10,20,30,40]] # syntactic sugar
03:55:51 <xic> Cale: ok
03:55:51 <Cale> different syntactic sugar :)
03:56:15 <Cale> > do { x <- [1,2,3,4]; y <- [1,2,3,4]; guard (x < y); return (x,y) }
03:56:17 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
03:56:33 <xic> @type guard
03:56:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
03:56:37 <Cale> We also have ways to ensure that elements not matching a criterion are dropped.
03:56:57 <Cale> guard introduces backtracking when a condition fails
03:57:16 <xic> Cale: i think what really confuses me about HXT is that there are about 10 different arrow classes
03:57:36 <Cale> xic: Yeah, you can mostly ignore that
03:58:15 <Cale> They're all extensions of the same basic idea to include more and more side effects
03:58:58 <Cale> newtype LA a b = LA { runLA  :: (a -> [b]) } -- this is almost never the arrow you're really working in, but captures the essence of the idea best
03:59:16 <Cale> The arrow you're usually using is IOSLA
03:59:31 <Cale> which is just like that one, but also allows for IO and state
03:59:45 <SimonRC> gotcha!   http://students.depaul.edu/~jabsher/apoc_eleph/apoc_eleph.html
03:59:46 <lambdabot> Title: Apocalypse of the two elephants
03:59:55 <SimonRC> now it makes sense for me to say:
03:59:58 <Cale> The important idea is really that of LA though
03:59:59 <SimonRC> "Haskell: Forever between the two elephants."
04:00:21 <quicksilver> Cale: Is it wrong to feel slightly unhappy about the idea of using (Monad m) => as the constraint for might-fail operations, using 'fail' as the failure primitive
04:00:23 <Cale> an LA arrow from a to b is a function which takes 'a' elements and turns them into lists of 'b' elements.
04:00:30 <quicksilver> to me this doesn't seem like a genuinely monadic idea
04:00:36 <Cale> quicksilver: not at all, because it's absolutely wrong
04:00:58 <Cale> quicksilver: the right class for that is MonadZero, but it was stupidly removed going from 1.4 -> 98
04:01:09 <quicksilver> ah
04:01:23 <quicksilver> what would MonadZero mean in category theory?
04:02:02 <Cale> Most category theorists wouldn't have a name for it. The basic idea is that mzero >>= f = mzero though.
04:02:26 <Cale> (and if there's a plus, it should be the zero with respect to that plus)
04:02:46 <quicksilver> SimonRC: Ah, I thought yo were making some kind of reference to http://www.amazon.com/Sketches-Elephant-Theory-Compendiumm-Oxford/dp/0198534256
04:02:50 <lambdabot> http://tinyurl.com/yob42u
04:02:50 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
04:02:52 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
04:02:53 <Cale> read that :)
04:03:04 <quicksilver> Cale: /me goes away to get a pencil and draw some morphism triangles
04:03:05 <Cale> xic: Okay, so back on track...
04:03:11 <xic> ...
04:03:22 <Cale> xic: To chain two such arrows together, what do we do?
04:03:40 <Cale> Suppose we have x :: (LA a b) and y :: (LA b c)
04:03:46 <Cale> we want to make an LA a c
04:03:59 <Cale> well, x is really a function a -> [b]
04:04:06 <Cale> and y is really a function b -> [c]
04:04:28 <Cale> the natural thing to start out doing is to map y over the results of x
04:04:57 <vincenz> assume C = A -> B_bottom  ... is C == C_bottom?
04:05:11 <Cale> map y . x :: "a -> [[c]]" -- the quotes are there because I'm ignoring the data structure
04:05:31 <Cale> but that's not quite right yet, is it?
04:05:31 <xic> ok so far so good
04:05:45 <Cale> the natural thing to do at that point would be to concatenate
04:05:54 <xic> ok
04:05:55 <Cale> concat . map y . x :: "a -> [c]"
04:06:23 <Cale> and that's exactly what >>> for LA does
04:06:46 <Cale> Now, what sort of things can an LA express that ordinary functions can't?
04:07:12 <Cale> Well, one thing it can do is to decide to return an empty list -- no results at all.
04:08:44 <Cale> There's a class which comes with HXT called ArrowList
04:08:56 <Cale> and one of the methods of that class is called  isA
04:09:20 <Cale> isA :: (ArrowList a) => (b -> Bool) -> a b b
04:09:21 <xic> i've tried the find the source for that function
04:09:25 <Cale> Or if you want,
04:09:30 <Cale> isA :: (b -> Bool) -> LA b b
04:09:37 <Cale> Let's implement it.
04:09:43 <Cale> (for LA)
04:09:57 <Cale> isA p = LA (\x -> ...)
04:10:22 <Cale> If x matches the predicate, what isA does is give the list containing just x
04:10:33 <Cale> if x fails the predicate, then it gives the empty list
04:10:46 <xic> \x -> if p x then [x] else []
04:10:49 <Cale> right
04:10:59 <Cale> this is, incidentally, what guard does in the list monad.
04:11:22 <Cale> er, well, almost
04:11:42 <Cale> it just takes a Bool, and either returns [()] or [] depending
04:11:50 <Cale> but the effect is basically the same
04:11:54 <xic> ok
04:12:27 <Cale> isA acts as a filter on the the list of results of the previous computation
04:12:47 <Cale> remember that it's going to be mapped over that list of results, and its results are going to be concatenated
04:13:01 <Cale> (Imagine something like  x >>> isA p)
04:13:23 <quicksilver> Cale: mzero is a natural choice of element (initial arrow) at each object, such that composition with *any* kleisli arrow takes you to the 'mzero object' in the codomain?
04:13:58 <quicksilver> (too many years since I studied category theory, words are probably wrong)
04:14:03 <Cale> quicksilver: yes
04:14:21 <Cale> mzero arrow
04:14:32 <Cale> er, element :)
04:14:39 <quicksilver> and by 'initial arrow' I fear I should say 'arrow from the terminal object'
04:14:42 <xic> Cale: ok your HRSS code is slowly starting to make sense
04:14:48 <Cale> xic: :)
04:15:27 <Cale> xic: the really sneaky bit, that I'm not completely happy with, but which works out okay is the catA . map (readDocument ...)
04:15:28 <quicksilver> Cale: so it's something like saying "this monad behaves like a container"
04:15:43 <quicksilver> Cale: and mzero represents empties
04:15:43 <Cale> quicksilver: yes, which may be empty
04:15:46 <Cale> indeed
04:16:17 <Cale> all monads behave like containers to some extent, this makes it moreso :)
04:16:53 <xic> Cale: hm... ok. i have another question. couldn't the type be used more to ensure that things like "hasName" always get an XElem as input, and not a general XNode?
04:17:14 <quicksilver> can the haskell type system understand the deduction "MonadPlus m" ==> forall a . Monoid m a ?
04:17:21 <Cale> xic: not easily in Haskell, due to the lack of subtyping.
04:17:51 <Cale> quicksilver: yes, with GHC at least.
04:18:00 <Cale> Monoid (m a)
04:18:22 <quicksilver> Cale: can it autogenerate the instances?
04:18:38 <Cale> the trouble is that gets you into overlapping instances problems
04:18:42 * quicksilver nods
04:18:44 <Cale> You can write
04:18:55 <Cale> instance MonadPlus m => Monoid (m a) where
04:18:56 <Cale> ...
04:18:59 <quicksilver> We also have Monad m, Monoid a => Monoid m a
04:19:05 <quicksilver> (which might generate a different monoid)
04:19:26 <xic> Cale: thanks man! i'll play around with this some more until i hopefully figure things out
04:19:27 <quicksilver> (in fact which *will* generate a different monoid except in degenerate cases)
04:19:40 <Cale> but this will create strange issues with any other instances for monoid which look like m a for any m and a, regardless of whether m is a Monad.
04:19:45 * quicksilver nods
04:19:59 <Cale> xic: cool, let me know if you have any more questions
04:20:01 <quicksilver> need a systemic way to choose between the various ways that 'm a' might be a monoid
04:20:14 <Cale> quicksilver: (because we don't know that m won't eventually be a monad)
04:20:16 <quicksilver> and to me it's not clear that that is possible without a load of syntactic annotations
04:20:27 <xic> Cale: oh yeah, i also have some ideas for STM if you are interested
04:20:31 <Cale> The way that people have been choosing to do is just to newtype things.
04:20:37 <Cale> which is actually pretty sane
04:20:42 <Cale> xic: cool.
04:21:16 <quicksilver> Cale: yes the newtype makes plenty sense for doing it manually
04:21:27 <quicksilver> Cale: but if you somehow wanted to access the automatic instances
04:21:56 <quicksilver> You almost want a dictionary-choosing bind construct
04:21:57 <Cale> Things are too often monoids in many many ways.
04:22:12 <Cale> yeah, there's been some research into that
04:22:18 <Cale> Named instances of classes and such
04:22:19 <quicksilver> with [Int] as Monoid defined by MonadPlu instance, { expr }
04:22:34 <Cale> It does make Haskell a bit strange though.
04:22:38 <quicksilver> or you annotate every use of an instance function, but that would be horribly verbose
04:22:43 <Cale> It's a bit like implicit parameters at that point.
04:22:52 <quicksilver> since the nice thing about instances when they work is that they DTRT very concisely
04:23:14 <xic> Cale: having your shared state be a big (TVar (Map a b)) is bad, since if you change a single element, then a transaction that was reading from a different element must restart. an improvement would be (TVar (Map a (TVar b)). this way you can change an element without affecting transactions that work with other elements. but if you add an element top the Map, then a transaction that was reading from the map must restart....
04:23:32 <xic> Cale: i'm thinking of a new primitive, unsafeWriteDoesntAffectOtherReadsTVar
04:23:42 <mux> oh, great, HsJudy!
04:23:58 <xic> Cale: so that you could add an element to your map, and other threads that are reading other elements wouldn't have to restart, since they are not affected by add
04:24:12 <Cale> xic: doesn't that happen with the latter type?
04:24:32 <Cale> xic: You could newtype that latter type, and call it a TMap :)
04:25:20 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/15/io-doesnt-matter/
04:25:21 <lambdabot> Title: IO doesn&#8217;t matter: telling C programmers the key to the Haskell weltanscha ...
04:25:23 * syntaxfree hits and runs
04:25:28 <Cale> Well, it's a bit of a shame that the Map operations aren't in classes, but you'd still save trouble by wrapping them up over TMap.
04:25:35 <xic> if i add an element to the latter type, then i still am modifying the base TVar, and so another transaction that read an unrelated value from the TVar must be restarted anyway
04:27:39 <Cale> xic: hmm, if another thread has one of the element TVars, it can still read and write to it without problems
04:27:54 <Cale> It's only if it's working with the map as a whole that it will have to restart.
04:28:24 <xic> Cale: right, and that's when you'd want something like unsafeWriteTVarDoesntAffectOtherReads
04:28:50 <Cale> But if you change the Map, it *will* affect other reads to the map.
04:29:02 <xic> not if i change it by only adding an element
04:29:16 <Cale> uh, what?
04:29:43 <Cale> If you add an element, then a lookup which failed might succeed.
04:30:35 <xic> yeah, but it's ok if it fails, as long as that same lookup fails again within the transaction
04:30:58 <vincenz> hi ADEpt
04:31:14 <Cale> Except that it won't.
04:31:37 <Cale> and you lose the percieved atomicity
04:32:47 <quicksilver> Cale: incidentally, I came up with that train of thought while reading the docs for Edison
04:33:11 <quicksilver> Cale: Edison uses 'Monad' to mean 'thing that can fail' quite pervasively
04:33:14 <xic> Cale: hm... in that case we need a mutable TMap
04:33:21 <ADEpt> vincenz:
04:33:38 <Cale> xic: It'll be exactly the type you described.
04:33:47 <Cale> (I think)
04:34:03 <quicksilver> Cale: Is there a reason not to simply use Maybe, and then provide combinators to 'lift' Maybe's simple failure paradigm into other MonadZeros?
04:34:17 <Cale> quicksilver: Not usually, that I can see.
04:34:59 <quicksilver> Cale: also, Edison uses the suffix 'M' for functions which signal failure in a monad. Normally the M suffix is for functions which actually lift their arguments into the monad in some sense :(
04:36:14 <Cale> quicksilver: yes, that's a shame
04:36:50 <quicksilver> Cale: but the principle of having a unified structure of typeclasses for containers is a nice one
04:36:52 <Cale> Edison has some really good data structure implementations, but the interface is strange.
04:37:03 <Cale> Well, yes
04:37:25 <Cale> I'm not completely certain that Edison gets that right, but at least it's trying :)
04:37:35 <Cale> Using monads for failure is really really wrong though.
04:37:58 * quicksilver nods
04:38:06 <quicksilver> :t Data.Map.lookup
04:38:08 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
04:38:20 * quicksilver points finger accusingly
04:38:21 <Cale> indeed, it's a plague
04:38:43 <quicksilver> Not sure why they don't use Either String or one of its newtypes
04:38:53 <quicksilver> clearly either string can be 'combined' into other monads easily enough
04:39:13 <Cale> Or MonadError m
04:39:14 <quicksilver> (I say Either String because fail has type String -> a)
04:39:17 <Cale> right
04:39:37 <quicksilver> my own home grown stuff uses Maybe or Either String
04:39:37 <Cale> er, MonadError String m
04:39:44 <quicksilver> depending how verbose I feel like being
04:39:52 <Cheery> I may have just found out a way to make haskell generated code *faster* than C can ever be.
04:40:04 <Cale> But yeah, Maybe and Either String seem like the right ideas to me, since they're simple and easily lifted to a variety of situations.
04:40:12 <Cale> At least, in the absence of better classes.
04:40:17 <Cheery> thought I yet need to confirm and think about it.
04:40:25 <quicksilver> Cheery: please share
04:40:38 <Cale> The real right way would be to reinstate MonadZero
04:41:09 * vincenz wishes  haskell had the option of defining unary surrounding operators
04:41:11 <Cheery> well, I read about TIGRE and how it allows the graphs to be executed.
04:41:15 <vincenz> like
04:41:21 <vincenz> {| x |} = ...
04:41:35 <pejo> quicksilver, it could be argued that partial evaluation or simliar on Haskell is possible, so if your problem has lots of known input data we can optimize way further than the c compiler.
04:41:35 <quicksilver> vincenz: 'outfix' operators
04:41:42 <mauke> circumfix!
04:41:42 <vincenz> quicksilver: right, thanks for the name :)
04:41:42 <Cheery> ..There's a thing about imperative code I were thinking before.
04:41:53 <vincenz> those woudl rock
04:42:01 <quicksilver> vincenz: you can do that if you're into type hackery
04:42:04 * vincenz sighs wistfully
04:42:12 <vincenz> quicksilver: how exactly/
04:42:30 <Cheery> by turning it into hilbert space, we can possibly reduce the graphs made by TIGRE even further.
04:42:32 <vincenz> afaict you can't define unary operatos...
04:42:44 <quicksilver> vincenz: sure you can, they're called 'functions'
04:42:44 <vincenz> so not sure how you'd force it to parse .| |.
04:42:52 <vincenz> quicksilver: ah, with letters
04:43:04 <Cale> Cheery: er, what's the inner product?
04:43:34 <Cale> for that matter, what's the scalar field?
04:43:59 <quicksilver> Cheery: sounds like you're just saying 'we may be able to express cleverer optimisations using abstraction'
04:44:05 <quicksilver> I'm quite sure that's true :)
04:44:14 <quicksilver> although gcc has moderately clever optimisations too
04:44:27 <pejo> Cheery, what is TIGRE, and where is it mentioned?
04:44:33 <Cale> http://www.ece.cmu.edu/~koopman/tigre/index.html
04:44:40 <lambdabot> Title: An Architecture for Combinator Graph Reduction (TIGRE)
04:44:42 <Cale> @where+ tigre http://www.ece.cmu.edu/~koopman/tigre/index.html
04:44:42 <lambdabot> Done.
04:45:40 <Cale> Cheery: You're at least right in that it seems natural that eventually higher level languages will outperform lower level ones at least in terms of what it's practical for humans to write.
04:45:47 <Cale> We're already seeing that.
04:46:13 <Cheery> Lets assume for a while that we have a turing tape with multiple paths, representing random-access -memory linearly.
04:46:38 <Cale> multiple paths?
04:47:29 <Cheery> Cale: think jump instruction as an intersection.
04:49:06 <Cheery> by creating algorithms for reducing the paths in this tape and then applying the algorithm to the code generated by TIGRE, one could reduce the code even further.
04:51:30 <pejo> I'm not following on the math here. Is a hilbert space basically a complete metric space?
04:52:03 <Cale> pejo: I have no idea how that entered into it. It's an inner product vector space which is complete under the metric induced by the norm.
04:52:24 <Cheery> I'm not sure whether thing I'm talking about is a hilbert space.
04:52:58 <Cheery> It's a kind of graph.
04:53:00 <Cheery> http://xanadu.com/zigzag/
04:53:02 <lambdabot> Title: ZIGZAG
04:53:48 <quicksilver> graph implies discrete whereas the hilbert spaces I'm familiar with tend to be continuous in nature
04:54:21 <Cale> quicksilver: Not just tend to be, but basically must be.
04:54:32 <pejo> Ok. This is too deep for me. There has been work performed on program transformers in the metric space of trees however.
04:54:54 <pejo> But that was for guaranteeing termination, they didn't do much with the transformer itself.
04:55:22 <Cheery> pejo: and I'm poor at explaining things.
04:55:40 <quicksilver> Cale: well they have a clear notion of continuity which comes from the norm, but off the top of my head I wasn't sure if you couldn't make a hilbert space out of finite fields and thus have one where the induced topology contains finite open sets
04:55:50 <quicksilver> Cale: and 'finite open sets' sounds discrete to my mind
04:55:57 <quicksilver> although I'm not sure if the technical definition differs
04:56:04 <Cale> quicksilver: you can't, the field must be R or C
04:56:13 <quicksilver> ah, right. Good. :)
04:56:57 <pejo> Cheery, it's not that. I just don't know the math, that's all.
04:58:12 <Cale> Those Zigzag people seem kind of crazy. This guy is basically talking about edge-labelled graphs, and somehow decides that "quantum hyperspace" is a good term to throw around with no rationale for that decision.
04:58:14 <kzm> With recent ghci, I have imported FPS qualified as B.  If I ask for the type of a nonexistent function (I tried B.nub :-), I get 'failed to load interface for B'.
04:58:21 <kzm> Known issue?  Expected behavior?
04:58:38 <pejo> Cale, a good indication tend to be which conference they publish at.
04:58:55 <vincenz> > let a .... b = a + b in 1 .... 4
04:58:56 <lambdabot>  5
04:59:02 <vincenz> > let a ... b = a + b in 1 ... 4
04:59:04 <lambdabot>  5
04:59:33 <kzm> (Oh, well.  Lecture to attend.  With free cookies.  I can feel an unquenchable thirst for wisdom emerging)
04:59:43 <vincenz> kzm:  you mean hunger
04:59:43 <Cale> kzm: I don't know
05:00:04 <Cale> kzm: Does anything work? "Failed to load interface" usually means that the module's not there.
05:00:21 <kzm> Cale, yes - asking for B.map works fine.
05:00:27 <Cale> huh
05:00:39 <kzm> So IMO, the message should say something about B not exporting nub instead.
05:00:49 <Cale> by recent ghci, do you mean 6.6 or 6.7?
05:00:56 <kzm> vincenz, I don't think hunger can be quenched.
05:01:09 <kzm> Cale, 6.7.  A few weeks old, I guess.
05:01:09 <quicksilver> is the magical auto-importer conflicting with your explicit import in some subtle way?
05:01:13 <vincenz> kzm: unsatiable hunger
05:01:19 <vincenz> kzm: you mentioned cookies, unless you drink cookies
05:01:23 <Cale> kzm: okay, I don't know -- sounds possibly buggy
05:01:25 <kzm> vincenz, right.  Yes.
05:01:45 <kzm> Then again, it's supposedly the fountain of wisdom.  You don't get cookies from a fountain either.
05:01:49 <kzm> And now I shall be late.
05:01:50 <kzm> :-)
05:04:59 <Cale> Well, okay, they're a little more than that. They're edge labelled directed graphs where every vertex can have at most one incoming or outgoing arc with a given label.
05:06:16 <Cale> (it may have both)
05:06:36 <Cale> btw: http://programming.reddit.com/info/14pfn/comments
05:06:38 <lambdabot> Title: IO doesnâ€™t matter: telling C programmers the key to the Haskell weltanschauung ...
05:07:10 <quicksilver> Cale: that's a link to syntaxfree's blog, I presume?
05:07:15 <Cale> yep
05:07:50 <bakert> Can I ask my boring darcs question here?  No response in #darcs :(
05:07:57 <Cale> sure
05:08:02 <bakert> How do I say "give me the diffs between the current version of foo.txt and the version of foo.txt before patch with name 'bar'"
05:08:05 <bakert> ?
05:08:54 <Cale> darcs diff ?
05:09:09 <bakert> mmm .. but i can't work out what flags i need to use
05:09:18 <Cale> darcs diff --from-patch=REGEXP
05:09:28 <vincenz> Cale: or --from-tag=bar
05:09:33 <Cale> yeah
05:09:41 <vincenz> bakert: simply typing `darcs diff` gave me that knowhow :)
05:09:53 <bakert> vincenz, i tried that.  it confused me
05:09:53 <vincenz> bakert: typing `darcs command` typically gives you good descriptions of the flags
05:10:03 <Cale> darcs diff --help
05:10:12 <vincenz> `Specifying just --from-patch will get you a diff against
05:10:13 <vincenz> your working copy. `
05:10:22 <bakert> i didn't trust my reading of the help ...
05:10:30 <bakert> but i trust you guys!
05:10:41 <vincenz> don't trust Cale, never trust Cale!
05:11:00 <Cale> hehe
05:11:52 <vincenz> And by extension, don't trust me cause I gave you the same answer as Cale, however at htat point you should not trust me when making the assesment of not trusting Cale...hmm...
05:12:05 <bakert> When I do that it prints out loads of patch names.  I guess that's just the ones between "then" and "now"??
05:12:30 <bakert> ah, and i can give it a filename which definitely improves things.  cool.  thanks folks
05:18:28 <pejo> Cale, why are we reading this?
05:18:48 <vincenz> existential answer: you clicked on it
05:19:15 <Cale> pejo: hm?
05:19:51 <Cale> pejo: mostly to decide if you'd like to mod it up -- I think it's a nice response to the other recent article about why Haskell tutorials fail to make C programmers happy :)
05:21:56 <pejo> Cale, doesn't just reading it give mod points?
05:22:07 <Cale> pejo: no, you have to click the arrows
05:22:52 <pejo> Oh, doh.
05:27:41 <quicksilver> Cale: quite surprised at syntaxfree's opinion of the best monad tutorial out there
05:28:18 <quicksilver> Cale: I really don't think people need (or should be particularly encouraged) to understand category theory in order to use monads in haskell
05:28:27 <Cale> yeah, that's true
05:28:41 <Cale> I don't think that's a reasonable monad tutorial for programming use.
05:28:52 <Cale> It's fine for mathematics, perhaps.
05:29:04 <Cale> (though a little terse in that case)
05:29:26 <Cale> If you were learning monads for mathematical purposes, you'd probably lead up to them via adjoint functors.
05:31:32 <quicksilver> Cale: I'm pretty sure I was tought adjoint functors first, yes
05:31:53 <quicksilver> Cale: None of it made much sense to me until I was shown a few applications of the adjoint functor theorems, though
05:32:14 <Cale> I'm still not sure I fully "get it"
05:33:00 <quicksilver> Cale: which part? (I know there are lots of parts I don't get)
05:33:36 <quicksilver> part of the reason I don't get it is that I always go back to thinking of objects in a category as being concrete things implemented as sets (groups, e.g.)
05:33:52 <quicksilver> the *things* under study are elements of the category
05:34:16 <quicksilver> then the whole adjointness/kleisli vibe is about studying the algebras formed by arrows between objects
05:34:25 <quicksilver> and I feel like I've failed to type check
05:34:37 <Cale> Well, just the intuitive idea of what it means for one functor to be left adjoint to another. The technical description isn't so much of a problem, but to be able to look at some functors and think "oh yeah, that'll have a left/right adjoint, and it'll probably be this"
05:34:39 <quicksilver> (moved from studying elements of A to arrows A -> FA)
05:35:36 <quicksilver> Cale: adjointness is like the relationship between one thing which 'destroys information' and another thing which 'tries to recreate that information in a canoncial way', is as close as I got
05:35:52 <Cale> yeah, that seems like a reasonable idea of it
05:36:08 <Syzygy-> quicksilver: Two good first places to poke at to cure yourself of that view of objects would be things like "Every group is a category", "Every po-set is a category" and "The naturals form the objects of a category, with matrices at the arrows"
05:36:09 <Cale> especially with regard to free objects and forgetful functors
05:36:22 <Syzygy-> *three
05:37:01 <Cale> It's true though that non-category-theorists at least at present mostly don't care about non-concrete categories.
05:37:55 <Cale> Perhaps if we had some more functors involving Cat and the common categories from around mathematics :)
05:38:14 <Cale> The group/monoid one is good.
05:39:04 <Cale> Pi_1: Haussdorf Topological Spaces -> Groupoids is decent.
05:39:29 <jacobian> how are dependent types and type classes related?
05:39:31 <Cale> Though people seem to care more about fundamental groups than fundamental groupoids.
05:40:01 <Syzygy-> Cale: Fundamental groups are easier, and it works out as long as you cope with only pathconnected bits, and the arbitrary choice of basepoint.
05:40:17 <Syzygy-> A lot of sane people, however ,are pushing groupoids. But this is a very modern development in homotopy crowds.
05:40:17 <Cale> jacobian: well, typeclasses allow values to depend on the type at which they're applied
05:40:28 <Syzygy-> So it hasn't percolated down to "most people" quite yet.
05:40:42 <Cale> jacobian: dependent types allow types to depend on values
05:40:50 <dcoutts> Matrix 3 3
05:40:57 <dcoutts> for example
05:41:41 <jacobian> ok, so a bit like system F
05:41:42 <Cale> Syzygy-: I like Brown's generalisation of S-vK to groupoids. That's actually how we did the proof of S-vK in my algebraic topology course.
05:42:03 <quicksilver> Syzygy-: I am familiar with those examples
05:42:25 <quicksilver> Syzygy-: I was just saying that, despite my best efforts, my intuition tends towards 'Grp' and 'Mon' and suchlike as 'what categories are'
05:42:48 <jacobian> I thought dependent types was a general term.  i.e. dependent types ~ martin lof type theory
05:42:57 <quicksilver> Syzygy-: i.e. my brain has failed to absorb how abstract categories really are, despite the examples being in front of me
05:43:16 <Cale> I tend to use Top a whole lot as my example idea of a category. :)
05:44:11 <quicksilver> jacobian: since you can mirror certain values, in certain senses, into the type layer
05:44:23 <quicksilver> jacobian: you can use type classes to implement a particular fraction of dependent types
05:45:13 <Cale> You can use typeclasses with functional dependencies to define operations on the naturals represented at the type level, for example.
05:45:28 <Cale> But it's a bit awkward :)
05:45:51 <quicksilver> FVO 'bit' approaching 'syntactic error message hell'
05:49:39 <jacobian> What do people call the ">>" function
05:50:03 <Cale> good question :)
05:50:03 <jacobian> in the context of monads in haskell
05:50:07 <mauke> comma
05:50:13 <Cale> It's commonly read as "then"
05:50:27 <Cale> It's a restriction of bind
05:50:34 <jacobian> yeah, I know how it works
05:50:52 <Cale> so you might just call it bind if you were being a little sloppy
05:51:06 <jacobian> I need the name bind too
05:51:06 <quicksilver> Cale: is there a classification for monads such that (a >> b) == b ?
05:51:32 <mauke> what would you call (<<)?  where a << b = do {x <- a; b; return x}
05:51:35 <quicksilver> Cale: intuitively such monads are stateless
05:51:55 <Syzygy-> Sorry - was answering email at $OTHERWINDOW
05:52:03 <Syzygy-> Cale: S-vK?
05:52:16 <Cale> Syzygy-: Seifert-van Kampen
05:52:32 <Syzygy-> quicksilver: Have you seen constructions of the derived category in homological algebra?
05:52:43 <Syzygy-> Or for that matter Bousfield localistaion?
05:52:44 <Cale> http://en.wikipedia.org/wiki/Seifert%E2%80%93van_Kampen_theorem
05:52:56 <Syzygy-> That's also a good place to get cured of any concrete thought models for categories. :)
05:52:59 <Syzygy-> Cale: Kk.
05:53:44 <Cale> I like to say it as "The fundamental groupoid functor preserves pushouts."
05:53:46 <Syzygy-> You end up getting various diagrams being the arrows, and composition being the assertion that in a specific diagram type, certain things compose Just Right.
05:53:57 <Syzygy-> Cale: Riiiiight. That's a REALLY neat way to phrase it. :)
05:54:37 <velco> scary.
05:55:07 <Syzygy-> velco: Not really.
05:55:10 <Cale> Hopefully our mathing-out isn't scaring away Haskell beginners :)
05:55:40 <Syzygy-> Cale: You -do- know that I only started learning Haskell BECAUSE of the mathing-out? ;)
05:55:45 <Cale> Don't worry! You don't need to know any algebraic topology to learn Haskell!
05:55:50 <Syzygy-> Back a few months ago when I was still beginner....
05:55:52 <velco> ;)
05:55:53 <Syzygy-> HEhehehe!
05:56:17 <Syzygy-> Hmmm.. Wonder what a progrmaming language would look like where you WOULD need algebraic topology to be able to write code.
05:56:37 <quicksilver> Syzygy-: No, my homological algebra didn't go further than a course in knot theory and one in basic algebraic topology
05:56:39 <velco> anyway, in the next lunch with co-workers, I'll mention that the fundamental groupoid functor preserves pushouts.
05:56:55 <Syzygy-> quicksilver: Ok. The idea is to invert a specific subfamily of arrows in a category.
05:57:06 <Cale> Yeah, that would make for a great obfuscated language.
05:57:27 <Syzygy-> And you do it by defining a new category, with the same objects, but with arrows being certain equivalence classes of certain diagrams on the shape B <- A -> C
05:57:43 <Syzygy-> And composition is defined through drawing a huge diagram and asserting commutativity.
05:58:14 <Syzygy-> In the end you get a category without a really neat way to think about the arrows, but where your specific class of arrows now all are isomorphisms.
05:59:25 <Cale> Maybe some sort of language where the fundamental operations all act on chain complexes of some sort.
06:00:03 <Cale> Find some way to relate boundary maps to some sort of "evaluation"
06:00:46 <LoganCapaldo_> It's too early in the morning for this channel
06:01:20 <LoganCapaldo_> I shoulda just stayed in #visual_basic
06:01:44 <Cale> Bonus points for requiring understanding of differential k-forms and de Rham cohomology.
06:02:05 <Cale> But I think that's pretty unlikely ;)
06:02:10 * nmessenger slaps Cale.  "Down boy!"
06:03:08 <quicksilver> Cale: that sounds awesome
06:03:48 <quicksilver> Cale: please write a compiler which uses chain complexes as an intermediate representation of programs
06:04:02 <quicksilver> Cale: and uses carefully chosen homomorphisms as optimisations!
06:04:39 <Syzygy-> Cale: de Rham cohomology is just yet another chain complex homology anyway, and it's the same as singular cohomology on nice enough things.
06:04:45 * Syzygy- doesn't see what the big deal is. :P
06:05:09 <quicksilver> I still want a name for monads such that (a >> b) == b
06:05:27 <Cale> Syzygy-: yeah, but involving it in a less-than-trivial way would mean that you'd need some knowledge of analysis as well
06:06:19 <quicksilver> @src [] ask
06:06:19 <lambdabot> Source not found. My pet ferret can type better than you!
06:06:31 <quicksilver> @src [x] ask
06:06:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:06:44 <quicksilver> how do I do that? get the source for ask in the [] instance?
06:07:00 <LoganCapaldo_> @src []
06:07:00 <lambdabot> data [] a = [] | a : [a]
06:07:12 <LoganCapaldo_> ?
06:07:20 <nmessenger> [] is a reader?
06:07:26 <nmessenger> @instances MonadReader
06:07:28 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
06:07:55 <Cale> quicksilver: trivial monads?
06:08:03 <Cale> Not completely trivial :)
06:08:09 <quicksilver> nmessenger: shouldn't 'head' make [] into a reader?
06:08:12 <quicksilver> or am I confused?
06:08:22 <Cale> But nearly so.
06:08:26 <wolverian> oh, wow, http://www.patryshev.com/monad/m-intro.html sees nice.
06:08:27 <nmessenger> ask = head?  I dunno.
06:08:28 <lambdabot> Title: Crash Monad Tutorial
06:08:30 <wolverian> s/sees/seems/
06:08:42 <Cale> Side-effect free monads, I suppose.
06:09:13 <quicksilver> Any Monoid can be a Writer, it seems like any 'producer' should be a reader?
06:09:17 <LoganCapaldo_> huzzah, more category theory
06:09:24 <Cale> wolverian: Only if you're only tangentially interested in how they might be used in programming.
06:10:29 <wolverian> Cale, or I know that bit, but am interested in the theory?
06:10:43 <Cale> wolverian: then it might be a good start :)
06:10:55 <wolverian> yay :)
06:11:11 <Cale> Perhaps less shocking than starting from http://planetmath.org/encyclopedia/Monad.html
06:11:13 <lambdabot> Title: PlanetMath: monad
06:11:23 <wolverian> though the algebra 1 course I'm on looks promising too.
06:11:25 <LoganCapaldo_> That page is perty
06:11:31 <wolverian> purty?
06:11:33 <wolverian> or perky? :)
06:11:39 <LoganCapaldo_> Haskell's syntax should look like that
06:11:50 <LoganCapaldo_> I can spell perty however I want :
06:11:54 <LoganCapaldo_> :)
06:12:13 <Cale> That's what the LaTeX literate Haskell form is for ;)
06:12:27 <LoganCapaldo_> Cale: But it can't parse it can it?
06:12:33 <wolverian> someone write a haskell binding for texmacs
06:12:44 <quicksilver> two-dimensional syntax for Control.Arrow!!!
06:12:55 <Cale> LoganCapaldo: there are tools for automatically prettying up Haskell code which has been written like that
06:12:58 <wolverian> I am very much in love with texmacs+axiom
06:13:04 <LoganCapaldo_> I can't use \o instead of . rigth? (I've probably gotten the LaTeX wrong)
06:13:11 <Cale> http://www.informatik.uni-bonn.de/~loeh/lhs2tex/
06:13:12 <lambdabot> Title: lhs2TeX
06:13:13 <wolverian> \circ
06:13:16 <dino-> Speaking of arrows, is there some URL where I can look at the source of Control/Arrow.hs ?
06:13:27 <Syzygy-> > let (\o) = () in (+2) \o (*3) 5
06:13:28 <lambdabot>  Parse error
06:13:32 <Syzygy-> Doh.
06:14:17 <Cale> @source Control.Arrow
06:14:18 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
06:14:58 <wolverian> hm, that monad tutorial page uses a circle aligned at the text baseline. that looks weird.
06:14:59 <nmessenger> If you know your instance, you can ask for specific methods on Arrow
06:15:03 <nmessenger> @src (->) (***)
06:15:04 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
06:15:28 <wolverian> or maybe it's just my font
06:15:29 <Cale> wolverian: might be your font.
06:15:33 <Syzygy-> One problem with coding things that way in its entirety is that you'd probably want to have some haskell equivalent to: T(id_C(A)) & \rTo^{T(\eta_C)} & T^2(C) & \lTo_{\eta_{T(C)}} & \id_C(T(C)) \\ & \rdTo_{\id_C} & \dTo_{\mu_C} & \ldTo^{\id^C} \\ && T(C)
06:15:48 <Syzygy-> (which is the LaTeX+diagrams-code I'd have used to typeset the unit diagram)
06:15:50 <Cale> It uses the degree sign, which is still wrong.
06:15:59 <Cale> It's more likely to occur too high than too low.
06:16:02 <quicksilver> ah, erm
06:16:09 <quicksilver> I misunderstood readers. Right.
06:16:10 <Cale> Oh, it's subscripting it
06:16:13 <Cale> that's dumb
06:16:17 <wolverian> ...heh
06:16:19 <quicksilver> Reader is just a single environment
06:16:21 <Syzygy-> > let (:o:) = (.) in (+2) :o: (*3) 5
06:16:21 <lambdabot>  Parse error
06:16:23 <jacobian> funny how mostly only smart people seem to be using functional programming, when the people who can really benefit are the sloppy slow witted ones like me :)
06:16:29 <Syzygy-> > let (:o:) = (.) in ((+2) :o: (*3)) 5
06:16:30 <lambdabot>  Parse error
06:16:32 <quicksilver> Reader feels not dual to Writer, then?
06:16:44 <quicksilver> Why does Reader not use a comonoid in the way writer uses a monoid?
06:16:45 <Syzygy-> > let o = (.) in (+2) `o` (*3) 5
06:16:46 <lambdabot>   add an instance declaration for (Num (a -> b))
06:16:55 <Syzygy-> > let o = (.) in ((+2) `o` (*3)) 5
06:16:56 <lambdabot>  17
06:17:00 <quicksilver> (well I can see why the current reader is useful, but it doesn't feel like it matches)
06:17:02 <Cale> âˆ˜ is the right unicode symbol to use for composition
06:17:11 <Syzygy-> > let _o = (.) in ((+2) _o (*3)) 5
06:17:12 <lambdabot>   add an instance declaration for (Num (a -> b))
06:17:23 <Syzygy-> Huh, why that now?
06:17:32 <mauke> `_o`
06:17:34 <Syzygy-> > let _o = (.) in ((+2) `_o` (*3)) 5
06:17:34 <Cale> jacobian: that's very true :)
06:17:35 <lambdabot>  17
06:17:39 <LoganCapaldo_> jacobian, I have a theory about that. I think its that Haskell _makes_ em smart
06:17:46 <Syzygy-> mauke: So, what characters force infix?
06:18:01 <mauke> punctuation
06:18:04 <LoganCapaldo_> So if they weren't smart before they will be after a little while
06:18:10 <Syzygy-> > let (.o) = (.) in ((+2) .o (*3)) 5
06:18:10 <lambdabot>  Parse error in pattern
06:18:16 <Syzygy-> ??
06:18:22 <quicksilver> Syzygy-: pure punctuation
06:18:25 <Cale> jacobian: Like LoganCapaldo, I think that learning functional programming teaches you a lot about programming in general.
06:18:25 <quicksilver> Syzygy-: no letters allowed
06:18:26 * LoganCapaldo_ is rtrying to soak up smartness by osmosis
06:18:26 <Syzygy-> Bugger.
06:18:29 <mauke> .o isn't a symbol
06:18:47 * nmessenger does like Logan
06:18:56 <quicksilver> Syzygy-: otherwhise a+b would lex as a single symbol
06:18:59 <mauke> (hmm, how would you qualify that? Main..o?)
06:19:07 <Syzygy-> quicksilver: Good point.
06:19:11 <Cale> quicksilver: It's sort of tempting to do that.
06:19:14 <Syzygy-> mauke: Hehe
06:19:19 <Cale> Look what we've already done with .
06:19:20 <quicksilver> Cale: it is very tempting to do it
06:19:34 <quicksilver> Cale: but you need spaces everywhere and that would annoy people :)
06:19:45 <quicksilver> yeah, . is a mess mess mess!
06:19:46 <Cale> The one operator I'd really feel uncomfortable putting spaces next to is exponentiation though.
06:19:59 <Syzygy-> > 3 ^ 5+2
06:20:01 <Cale> I'd rather use | as the module path separator.
06:20:01 <lambdabot>  245
06:20:14 <Cale> Data|Map|map
06:20:17 <Cale> and so on
06:20:21 <mauke> I use spaces around infix operators anyway
06:20:32 <Cale> yeah, especially composition
06:20:34 <quicksilver> mauke: many people use them around some
06:20:34 <nmessenger> Cale: does @ have a special meaning on the RHS?  It could be used.
06:20:42 <quicksilver> mauke: but few people  use them around *all*
06:20:47 <quicksilver> (like commas, for example)
06:20:48 <mauke> why not?
06:20:59 <Cale> nmessenger: no, that's true
06:21:06 <mauke> since when is comma an infix operator?
06:21:13 <Cale> It has a special meaning in patterns though
06:21:17 <quicksilver> hmm that's true
06:21:20 <quicksilver> comma is special
06:21:23 <Cale> which might make things wierd
06:21:40 <Cale> I never put spaces around ^
06:21:41 <nmessenger> well | has special meaning in datatypes
06:21:48 <Syzygy-> > let (.:.) = (.) in ((*2).:.(+3)) 5
06:21:49 <jacobian> comma should be an infix operator I think
06:21:50 <lambdabot>  16
06:21:59 <Syzygy-> Hey, there's an idea.
06:22:07 <mauke> jacobian: [1,2]
06:22:12 <Cale> nmessenger: And guards, but it's pretty easy to insist on spaces in those cases
06:22:12 <Syzygy-> > let (Â·) = (.) in ((*2)Â·(+3)) 5
06:22:12 <lambdabot>  Illegal character ''\183''
06:22:15 <Syzygy-> Doh.
06:22:19 <nmessenger> | might also clash with guards or something
06:22:38 <Cale> in most cases, you already have a space on at least one side of the |
06:23:07 <Cale> At least, that's a less common clash than using .
06:23:21 <nmessenger> regardless of choice, it does seem like a good idea to change from '.'
06:23:51 <mauke> no :(
06:23:58 <jacobian> mauke: Even in (1,2,3)
06:23:59 <nmessenger> ModuleOrConstructor.name -- which is it?!?!
06:24:20 <Cale> That's possibly even harder at this point than my idea of swapping the associativity of ($)
06:24:33 <mauke> jacobian: is your (,) left or right associative?
06:24:42 <Cale> You almost have to fork the language to do it.
06:24:52 <quicksilver> actually I wish we could make (,) truly associative
06:24:56 <Cale> Which is really really unfortunate.
06:25:07 <jacobian> mauke: I'd pick one :)
06:25:14 <Cale> Damn you popularity! Damn you!
06:25:21 <nmessenger> so f $ g $ h $ x = (((f g) h) x)?
06:25:23 * Cale shakes his fist
06:25:23 <quicksilver> although there are good reasons why you can't :(
06:25:28 <Cale> nmessenger: yes
06:25:36 <quicksilver> nmessenger: since you have . for the other
06:25:43 <quicksilver> nmessenger: f . g . h $ x
06:25:56 <pejo> Cale, C'Haskell!
06:26:08 <nmessenger> O'?
06:26:17 <Cale> O'Haskell already existed.
06:26:27 <nmessenger> C for Cale, gotcha :)
06:26:38 <bakert> ?hoogle in
06:26:39 <lambdabot> Prelude.in :: keyword
06:26:39 <lambdabot> Array.indices :: Ix a => Array a b -> [a]
06:26:39 <lambdabot> Char.intToDigit :: Int -> Char
06:26:51 * nmessenger was wondering what the C language had to do with this
06:26:55 <Cale> hehe, is of type keyword
06:27:08 <nmessenger> @hoogle Prelude
06:27:08 <lambdabot> Prelude :: module
06:27:09 <lambdabot> Language.Haskell.Syntax.prelude_mod :: Module
06:27:09 <lambdabot> Distribution.Extension.NoImplicitPrelude :: Extension
06:27:55 <Cale> O'Haskell had some neat ideas in it
06:28:13 <nmessenger> strange that 'in' is in the Prelude module though.  If I NO_IMPLICIT_PRELUDE do I lose my syntax :-)
06:28:59 <dons> @pl f $ g $ h $ x
06:28:59 <lambdabot> f (g (h x))
06:30:48 <pejo> Cale, i'm sure Nordlander would welcome someone importing the good ideas to Haskell.
06:33:41 <nmessenger> @type runState . mapM State
06:33:51 <lambdabot>     Ambiguous occurrence `mapM'
06:33:51 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
06:34:27 <nmessenger> blech, LB should import hiding duplicates
06:36:56 <nmessenger> @type runState . Control.Monad.mapM State
06:36:59 <lambdabot> forall s a. [s -> (a, s)] -> s -> ([a], s)
06:37:32 <nmessenger> ^^ I felt so proud of myself when I used that yesterday, my first use of the State monad.
06:37:41 <quicksilver> @type runState
06:37:43 <lambdabot> forall s a. State s a -> s -> (a, s)
06:37:51 <quicksilver> hmph
06:38:04 <quicksilver> how did lambdabot constrain your mapM to the list monad there?
06:38:12 * LoganCapaldo_ names a Monad Away
06:38:14 <LoganCapaldo_> runAway
06:39:04 <dino-> Cale: thanks for the source URL for arrows.
06:39:17 <nmessenger> quicksilver: it's a list of functions, the mapM just sequences the results from map State
06:39:31 <nmessenger> @src Control.Monad.mapM
06:39:31 <lambdabot> Source not found. I feel much better now.
06:39:33 <quicksilver> :t mapM
06:39:35 <lambdabot>     Ambiguous occurrence `mapM'
06:39:35 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
06:39:37 <pjd> has anyone here heard of "sequential algorithms"?
06:39:42 <quicksilver> :t Control.Monad.mapM
06:39:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:39:53 <quicksilver> nmessenger: ah, right, being stupid
06:40:01 <pjd> a la Berry and Curien, apparently
06:40:09 <nmessenger> quicksilver: I've done enough of that for the both of us :)
06:40:35 <quicksilver> nmessenger: I'll try to stop, then
06:40:40 <quicksilver> nmessenger: doubt I'll succeed
06:41:10 <dons> mwhahaha http://programming.reddit.com/info/14pfn/comments
06:41:11 <lambdabot> Title: IO doesnâ€™t matter: telling C programmers the key to the Haskell weltanschauung ...
06:41:43 <dons> i guess it only makes sense if you read the earlier article about why IO mades FP/Haskell hard
06:41:49 <dino-> My quest to use Haskell for XML processing (instead of Perl or Java, say) has pulled me right into arrow studies. :o
06:41:50 <nmessenger> gezundheit -- /me doesn't know German, sorry for horrible misspelling
06:41:53 <quicksilver> dons: I like syntaxfree's article apart from the bit where he recommends that very mathematical monad article
06:42:03 <dons> yeah, that's a weird one, I agree
06:42:29 <dons> ?babel de en weltanschauung
06:42:30 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
06:42:33 <dons> oops
06:42:38 <dons> so that plugin broke in the update too
06:44:19 <dons> ?users
06:44:20 <lambdabot> Maximum users seen in #haskell: 328, currently: 303 (92.4%), active: 38 (12.5%)
06:45:16 <pjd> dons: weltanshauung -> worldview
06:45:37 <dons> yeah, i just wanted to test @babel. usually its quite funny :)
06:45:44 <dons> ?quote kidney
06:45:44 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:45:46 <dons> bah.
06:46:32 <dons> ?babel fr en je vais et je viens, contre tes reins, et je me retiens
06:46:33 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
06:46:38 <pjd> no one's heard of sequential algorithms?
06:46:39 <dons> <lambdabot>   I go and I come, counter your kidneys, and I retain myself
06:47:05 * nmessenger votes that for @topic-cons
06:47:25 <dons> heh
07:02:49 <holmin> how do i write an equivalent of getBounds for IOArray so I can use it in ghc 6.4?
07:03:40 <Lemmih> holmin: return . bounds ?
07:03:55 <Lemmih> Maybe not.
07:04:31 <holmin> well it compiled, at least :)
07:05:14 <Lemmih> Great. Then it probably works.
07:06:10 <holmin> yeah, seems like it. thanks
07:06:41 <Lemmih> You're welcome.
07:07:31 <SamB> yeah, that ought to work the same on anything that has a "bounds" method...
07:07:49 <dino-> heh "it could be argued that a gazillion batch files makes for a Turing-complete system"
07:08:15 <Lemmih> Haloed be the type-checker.
07:08:45 <pjd> hallowed, even?
07:08:47 <SamB> dino-: if you have two stack files and means to push and pop things to/from them, its true!
07:09:30 <nmessenger> Haloed works.  It -is- practically angelic.
07:10:23 <dino-> Still, seems gramatically.. ugly. I see "haloed" in the same sense as "bespectacled".
07:10:50 <SamB> I don't think the typechecker can play xbox
07:11:01 <nmessenger> bespectacled is an *awesome* word!  Are you crazy?!
07:11:23 <dino-> nmessenger: I didn't mean ugly word, just crass application of word in the sentence.
07:11:30 <nmessenger> heh
07:12:04 <allbery_b> "bespectacled" isn't ugly, it's just Germanic :)
07:12:09 <nmessenger> I shall utilize whichever allocution I deem fit.  You silly.
07:12:21 <xic> i can't seem to find the source for fail function of STM monad
07:12:26 <SamB> be carefull that you don't get elocuted
07:12:50 <dons> how long have you been waiting to use that line, SamB ?   ;)
07:12:55 <SamB> @src STM fail
07:12:56 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:12:58 <RemiTurk> good afternoon again
07:13:13 <SamB> dons: I've used variations a number of times at home ;-)
07:13:32 <SamB> in other words, I haven't waited ;-)
07:13:56 * SamB wonders why emacs is making a buzzing noise when he has it in the foreground
07:14:07 <pjd> bespectacled++
07:14:16 <dcoutts_> tired monitor?
07:14:19 <SamB> @karma bespectacled
07:14:20 <lambdabot> bespectacled has a karma of 1
07:14:22 <pitecus> is there some library to read files through HTTP?
07:14:30 <SamB> dcoutts: I don't see why it matters what window is in front
07:14:46 <SamB> oh, you mean you think the pixels are making the noise?
07:14:48 <SamB> hmm.
07:14:53 <SamB> interesting idea.
07:15:01 <dcoutts_> SamB, the patterns of light and dark can make a difference to CRT monitor hum
07:15:10 <dcoutts_> eg text vs something else
07:15:20 <pjd> it could be the video card too
07:15:30 <nmessenger> my PS2 makes a horrible buzzing noise when I watch DVDs with too much light
07:15:32 <SamB> makes much more sense than my worries that my hard drive is about to crap out or something ;-)
07:15:51 <SamB> hmm, my emacs is set to a black-on-white colorscheme...
07:16:01 * SamB wonders how much work that is to change.
07:16:23 <SamB> (See, I'd probably have to change a bunch of other colors, too...)O
07:16:42 <pjd> my PC at home has a wonky bus... certain graphical activity, like dragging certain windows, shows up as sound card interference
07:16:53 <SamB> I wasn't dragging though
07:17:00 <RemiTurk> SamB: I think it's just enjoying being in the focus of attention
07:17:14 <SamB> just having it show up on screen makes this noise
07:17:15 <pjd> SamB: certain redrawing, too :)
07:17:25 <SamB> I mean, after its drawn
07:17:29 <quicksilver> pjd: not that unusual, actually
07:17:30 <SamB> it still makes the noise, so...
07:17:31 <pjd> that sounds more like a monitor thing, yeah
07:17:42 <pjd> quicksilver: yeah, i know.  my PC is particularly bad, though
07:17:43 <waern> dcoutts, hey! I'm going to present the bytestring paper tomorrow at school. 15 min presentation
07:17:49 <SamB> I guess either the monitor or my poor video card...
07:17:55 <dcoutts_> waern, cool!
07:18:37 <waern> dcoutts, I think I need to make my own slides to summarize the paper
07:18:41 <SamB> I'd be happy if dragging windows had no worse consequences than sound card interference ;-)
07:18:55 <pjd> more fun is the old computers where you can actually hear differences in CPU activity
07:19:10 <SamB> it tends to cause whatever was playing sound to get stuck until I let go of the window...
07:19:16 <dcoutts_> waern, aye. Well if you're allowed to start from ours then I can forward them. My PADL talk was about 23 min.
07:19:35 <SamB> hmm. I wonder what I could hear on our old P166 MMX
07:19:50 <waern> dcoutts, okay, is that fusion-talk.ps?
07:20:12 <dcoutts_> waern, that might be dons's previous 15 min version
07:20:29 <waern> dcoutts, oh :) that might work well
07:20:38 <dcoutts_> waern, yep :-)
07:21:07 <kolmodin> heh :)
07:21:08 <waern> ehm, no this one is 58 slides
07:21:27 <dcoutts_> waern, that might just be "text reveal" or something
07:22:07 <waern> dcoutts, yep
07:22:18 <xic> hm... there is no findM function :(
07:23:36 <waern> dcoutts, the fusion-talk.ps I have goes into Quickcheck model checking dsl at the end
07:23:48 <dcoutts_> waern, skip that stuff
07:23:56 <waern> yes, but is it the 15min talk?
07:23:59 <waern> :)
07:24:11 <dcoutts_> hmm
07:24:46 <Stinger> dcoutts, sorry for the nooby question, but is there anything I should be doing as cleanup when using gtk2hs?
07:25:24 <xic> @src liftM
07:25:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:25:31 <dcoutts_> Stinger, no, unless you using stuff interactively in ghci
07:25:54 <Stinger> ah yes I am :) I see my problem is known about heh
07:27:04 <xic> @src find
07:27:04 <lambdabot> find p          = listToMaybe . filter p
07:27:15 <waern> dcoutts, ah, okay.. there seems to be several versions of these slides
07:27:18 <dcoutts_> Stinger, look at what the gtksoe does, it calls flush to send all the commands to the X server before returning to ghci
07:27:27 <dcoutts_> waern, yeah, use the streams-padl-talk
07:27:28 <xic> @src listToMaybe
07:27:29 <lambdabot> listToMaybe []        =  Nothing
07:27:29 <lambdabot> listToMaybe (a:_)     =  Just a
07:27:46 <waern> dcoutts, could you send that to me? or is it online somehwere?
07:27:57 <dcoutts_> waern, same place you found the other one
07:28:06 <dcoutts_> http://www.cse.unsw.edu.au/~dons/fps.html
07:28:06 <lambdabot> Title: Data.ByteString
07:28:11 <Stinger> I did add a flush, but as a stab in the dark, I'll look into it more closely
07:29:01 <nmessenger> @type liftM find
07:29:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ([a] -> Maybe a)
07:29:16 <nmessenger> @type \p -> liftM (find p)
07:29:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> m [a] -> m (Maybe a)
07:29:24 <dcoutts_> Stinger, you're using mainGUI and mainQuit I presume ?
07:29:32 <waern> dcoutts, thanks
07:30:08 <dcoutts_> Stinger, then I think all you need is flush
07:30:24 <dcoutts_> Stinger, see also demo/cairo/CairoGhci.hs
07:31:34 <xic> is filterM lazy? if i only use the first item from the resulting list, will the monadic action still be performed on all elements of the list? i guess it would have to be :(
07:31:35 <nmessenger> given a predicate and a monadic list of 'a', (liftM . find) will result in a monadic 'Maybe a'.  Is that what you wanted, xic?
07:31:42 <mwc> Found a reference to an inlinePerformIO in a paper by dons, but hoogle doesn't know it
07:31:49 <mwc> what's its type?
07:31:52 <xic> nmessenger: hm...
07:32:01 <mwc> It seems like it's IO a -> a
07:33:21 <Stinger> dcoutts yeah mainGui and mainQuit, flush after mainGUI?
07:33:31 <xic> @type liftM . find
07:33:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> m [a] -> m (Maybe a)
07:33:44 <Stinger> when I change my prog and reload in ghci, and run main, I get...
07:33:54 <xic> nmessenger: no i don't think that's what i want
07:33:55 <dcoutts_> Stinger, yes.
07:34:19 <mwc> @hoogle inlinePerformIO
07:34:20 <lambdabot> No matches found
07:34:31 <mwc> nope, lambdabot doesn't know either
07:34:50 <dcoutts_> mwc, it's not standard
07:34:59 <mwc> what's it do?
07:35:08 <dcoutts_> it's like unsafePerfomIO
07:35:10 <Stinger> I get a GThread-ERROR : GThread system may only be initialized once aborting, and ghci closes
07:35:14 <Saizan> > let findM p = let listToM (a:_) = return a; listToM [] = fail "not found" in listToM . filter p in findM (==3) [1] :: Maybe Int
07:35:15 <lambdabot>  Nothing
07:35:23 <dcoutts_> Stinger, oh, hmm, that's odd.
07:35:36 <mwc> I got that from the type, but is it somehow... safer?
07:35:48 <dcoutts_> mwc, hah hah hah. No. It's less safe :-)
07:36:11 <mwc> oh.... s/inlinePerformIO/reallyUnsafePerformIO/
07:36:20 <dcoutts_> Stinger, I thought I'd made it do that only once for exactly that reason. What do you do exactly to get that error?
07:36:23 <mwc> what does it do?
07:36:40 <dcoutts_> mwc, it 'does' exactly the same thing, but it gets inlined
07:36:54 <dcoutts_> unlike unsafePerformIO which never gets' inlined or CSE'd
07:36:56 <Stinger> basically it happens whenever I reload my .hs file with :r and run main
07:37:10 <mwc> wow, that sounds freakin dangerous
07:37:25 <nmessenger> s/.../freakinDangerousPerformIO/
07:37:30 <Stinger> if I dont reload I can run my program multiple times
07:37:38 <dcoutts_> Stinger, ah oh. Right, it'll be discarding the top level ref I use to check if it's been initialised already.
07:37:48 <dcoutts_> Stinger, I'm not sure there's a lot I can do about that.
07:38:27 <Stinger> is there a way to manually shutdown the threading engine?
07:38:32 <dcoutts_> Stinger, I tried using C code to check if it's initialised but that wouldn't link properly on windows.
07:38:52 <dcoutts_> Stinger, no, you can't unstart it. You can only not restart it.
07:39:03 <Stinger> bummer :(
07:39:07 <dcoutts_> aye, sorry
07:39:25 <waern> dcoutts, about that "this is compiled to..." example in the slides - why is that an example of creating/destroying temp arrays?
07:39:26 <dcoutts_> I can have another look some time to make the via C route work, but I'm not hopeful
07:39:41 <dcoutts_> waern, page?
07:39:45 <waern> dcoutts, 7-A
07:39:55 <waern> dcoutts, you know.. case expression
07:40:11 <waern> does case have allways that effect even if you don't pattern match? :)
07:40:14 <moonlite> waern: preparing your speech tomorrow? :)
07:40:25 <waern> moonlite, yep :)
07:40:36 <moonlite> bytestrings?
07:40:39 <waern> yep
07:40:42 <dcoutts_> Stinger, it works with the normal linker but GHCi's linker can't handle it.
07:40:43 <moonlite> neat
07:41:19 <dcoutts_> waern, I'm not quite sure I understand your question.
07:43:49 <waern> dcoutts, I don't understand how rewriting the first expression into the case expression illustrates the temporary arrays
07:43:49 <Stinger> hmm I'll have to figure some other way of playing around with this
07:44:39 <waern> dcoutts, couldn't there be an imaginary fusion technique that could fuse the case expression stuff as well? :)
07:45:26 <Baughn> How well does GHC scale to multi-core systems? Assuming that I write the code right, could I expect to get decent performance from an 80-core system?
07:46:29 <xic> Baughn: please send me an 80 core system and i'll give you an answer
07:46:58 <Baughn> xic: You'll have to wait a few months (year or two?) for that, but emulators work fine
07:47:17 <Baughn> Simics will happily pretend to be a 200-core system if you ask it to. ;)
07:47:32 <xic> Baughn: from what i understand, ghc should work good on an 80 core system
07:48:17 <Baughn> xic: Using 80 worker threads, then. That's good to know.
07:48:22 <xic> it will create 80 os threads, and juggle haskell threads between them
07:48:58 <dcoutts_> waern, but the point is that as it stands, it's not fused and each of those s, s', s'' etc are the intermediate values - intermediate arrays.
07:49:04 <mux> there's a paper out there where people show that Haskell with GHC scales well at 10 million threads :-)
07:49:05 <xic> if you have less then 80 haskell threads then each one will probably end up getting it's own dedicated os thread
07:49:18 <dcoutts_> waern, it's not impossible that something could take that and fuse it, but as it stands, it's not fused.
07:49:25 <mwc> Baughn, I have no idea how it well it scales to 80 threads. In principle it works but it may start to lose efficiency as the number of OS threads goes up. Another alternative you could consider if your workload is very much SIMD or MIMD is to use MPI
07:49:51 <mux> there's still some discussion on whether implicit parallelism is "good enough" or if explicit parallelism is required
07:49:58 <mux> I wish I attended to POPL'07
07:50:18 <Baughn> mwc: Really, I'm just pondering what sort of language would work best with the massively-multicore systems Intel appears to be building. With any luck we'll get rid of C at least.
07:50:54 <mux> Baughn: my very hope too
07:50:57 <moonlite> xic: that's really cool (that the ghc scheduler uses os-threads and software-threads when needed)
07:51:19 <mux> I think massive parallelism will finally kill C
07:51:20 <Baughn> Implicit parallelism? You wouldn't have fork haskell threads every single time you could.. or would you?
07:51:34 <mwc> Well, if you have the luxury to be in a uniform address space, threading should be awesome. Today you're more likely to see NUMA architectures or clusters (which I consider to be an extreme of NUMA)
07:51:37 <quicksilver> implicit parallelism is hard, I believe
07:51:38 <mux> the OpenMP extension of GCC is funny
07:51:38 <xic> Baughn: forking a haskell thread is very cheap
07:52:03 <Baughn> xic: /That/ cheap?
07:52:10 <sjanssen> we do have an explicit parallelism combinator in ghc right now
07:52:12 <sjanssen> @hoogle par
07:52:12 <lambdabot> Control.Parallel.par :: a -> b -> b
07:52:12 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
07:52:12 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
07:52:16 <mux> yeah
07:52:28 <mux> and there's parallel arrays too
07:52:29 <dcoutts_> and parallel evaluation 'strategies'
07:52:45 <quicksilver> why doesn't par have type a -> b -> (a,b) ?
07:53:07 <sjanssen> quicksilver: par is complementary to seq (which has the same type)
07:53:09 <Cale> quicksilver: because it's like seq
07:53:10 <mwc> Baughn, that being said, this weekend I moved an ocaml program from a single pc to a cluster using MPI in about 20 lines of code. FP langauges are phenomenal for that sort fo thing, since so many steps in your process seem to involve a map (parallelism candy) and then a reduce
07:53:11 <dcoutts_> quicksilver, par is more primitive
07:53:37 <quicksilver> but seq throws away the result of its first calculation
07:53:42 <dcoutts_> quicksilver, the type you suggest looks like a synchronisation point, par doesn't have that
07:53:49 <quicksilver> doesn't a useful par want access to the other calculation?
07:53:50 <sjanssen> quicksilver: generally you'll use a let, like let x = fibs (n-1); y = fibs (n-2) in x `par` y `seq` (x+y)
07:54:08 <quicksilver> oh
07:54:12 <Maddas> mux: Why would it kill C? I doubt the popular operating systems will be rewritten anytime soon
07:54:16 <mwc> Baughn, also, from what i understand, the 80 core CPU's intel are forecasting will be full of special purpose "coprocessors."
07:54:25 <quicksilver> 'evaluate this to WHNF in another thread but then I can still demand the value in this thread' ?
07:54:37 <Cale> quicksilver: 'if possible'
07:54:37 <mux> Maddas: not in that sense of "killing"
07:54:46 <dcoutts_> Maddas, the popular OSs are very good with threads, but they're pretty special C programs. Most don't deal with threads well.
07:54:53 <Baughn> mwc: Well, I'm looking forward to it. At that level of parallelism, memory usage efficiency will be far more important than cpu usage - how does ghc fare there?
07:54:54 <mwc> so a good language should expose a highlevel programming model for each type, eg, a stream processor
07:54:59 <Cale> quicksilver: it 'sparks' the computation, which means that if there's a processor available, it will use it to compute the result in parallel
07:55:03 <Maddas> mux: ok
07:55:06 <quicksilver> I also doubt it will kill C
07:55:09 <quicksilver> not for many years
07:55:12 <mux> Maddas: I don't think C will disappear from the surface of Earth the very day very massive CPUs exist
07:55:21 <Maddas> mux: neither do I.
07:55:25 <quicksilver> it will just foster the development of clever librarys which export a C API to do this stuff
07:55:29 <mux> but there will finally be a good *hard* reason for people to ditch C
07:55:33 <Baughn> mux: Neither do I, but it's a further nail in the coffin
07:55:41 <dcoutts_> I'm not sure multi-core will kill C, but going more and more NUMA might
07:55:43 <mux> C actually sucks at threading, when compared to Haskell for instance
07:55:45 <Maddas> mux: But aren't there enough of those reasons already? :-\
07:55:55 <dcoutts_> once it's no longer a flat address space C is dead (I reckon)
07:56:05 <mux> Maddas: in my experience, there are still many cases where Haskell performance is sub-optimal
07:56:12 <Baughn> Multicore CPUs might actually make bytecode interpretation faster than native code, unless there's a breakthrough in memory speed
07:56:21 <velco> heh, why?
07:56:22 <Maddas> mux: Oh, you're talking about high-performance computing specifically?
07:56:27 <mux> and while writing programs in Haskell can be much easier than in C, it seems to me optmization in haskell is more complicated
07:56:28 <dcoutts_> mux, dons and I are working on it :-)
07:56:30 <Baughn> velco: Native code is larger. ;)
07:56:34 <mwc> Baughn, to some extent, IA32 is already a form of bytecode
07:56:34 <mux> dcoutts_: yeah, that's great :-)
07:56:49 <velco> Baughn: not *that* larger.
07:56:52 <mwc> It gets decodes into many more microops.
07:56:53 <Baughn> velco: And keeping a /single/ core fed is already a chore. Scaling up to 80 virtually overnight...
07:57:12 <Baughn> velco: We could write bytecodes that are optimized for size instead of speed
07:57:25 <mux> Maddas: I agree that performance is often not the most critical point of a program, but still, many programmers can't be convinced to lose a couples of seconds when switching to something not C
07:57:26 <dcoutts_> see eg yhc
07:57:26 <Maddas> mux: if it's HPC, I'm curious about how well Fortress will hold up
07:57:52 <nrb23_> mmm.. opimizing for size
07:58:06 <mux> programs are less and less CPU-bound every day, but programmers are still very emotionally attached to raw performance :-)
07:58:23 <RemiTurk> when running with 80 cores, wouldn't GHC's currently single threaded GC become a mayor bottleneck?
07:58:33 <Baughn> RemiTurk: Definitely
07:58:47 <nrb23_> sadly, I still have CPU bound stuff at work
07:58:51 <Baughn> At that point, dedicating a core to running continuous incremental GC becomes quite reasonable
07:59:42 <waern> dcoutts, yes I got that point... But how does the case snippet *imply* that temporary arrays are created for the s,s',s''? I mean it's likely, but couldn't a compiler just transform that expression back into the first one? :)
07:59:49 <velco> at that point, shared mutable state prallal programming will suddenly appear necessary even for purists.
08:00:06 <dcoutts_> waern, the first one does the same, the second just makes it explicit.
08:00:09 <dons> RemiTurk: yeah, simon hopes to have the parallel GC in by ghc 6.8, next release
08:00:23 <Maddas> mux: But do you think Haskell will be the fastest choice if memory becomes the bottleneck instead? :-)
08:01:01 <waern> dcoutts, "explicit" when the reader assumes how the compiler works then, ok
08:01:02 <RemiTurk> dons: then I probably don't have to worry as I still have only one core ;)
08:01:08 <nrb23_> is haskell locality of reference friendly?
08:01:12 <Baughn> velco: I can adapt to whatever happens; I'm just happy that there will be further changes to the way programs are built. Not *every* breakthrough was made in the 80s.
08:01:19 <dcoutts_> waern, I guess so
08:01:20 <waern> dcoutts, okay this discussion is a bit silly, I'll end it now :)
08:01:27 * dcoutts_ grins
08:01:45 <velco> Baughn: I was envisioning the implementation of the collector itself.
08:02:24 <Baughn> velco: Oh, that. Yes, but isn't that true by definition for parallel GCs?
08:03:56 <quicksilver> Baughn: doesn't continous incremental GC on a core make some assumptions about memory access and cache coherency?
08:04:10 <quicksilver> Baughn: I could see that really biting you in the arse if it was screwing with your caches all the time
08:04:34 <Baughn> quicksilver: It makes assumptions that appear to be true for future Intel systems at least, but yes.
08:05:11 <Baughn> quicksilver: Really, I just want incremental GC. Even if it slows things down slightly, it makes Haskell /so/ much more usable for UIs of various kinds.
08:05:29 <quicksilver> Baughn: *nod*
08:06:20 <Baughn> quicksilver: Mind you, continuous incremental GC would be a problem if the GC area doesn't fit in the L3 cache (which will be a rather large bit of DRAM at that point).
08:06:46 <xic> i don't think that haskell's current GC is a problem for gui apps
08:06:56 <quicksilver> Baughn: that's one of the issues I was driving at
08:07:14 <quicksilver> Baughn: but with the right tunable parameters it could be fine I suspect
08:07:17 <pjd> Baughn: there's also region allocation
08:07:25 <Baughn> xic: I tried to write ping-pong in it, and the ball.. jerked. THat'd be the GC.
08:07:36 <pjd> (instead of, or in addition to GC)
08:07:37 <quicksilver> what about that quake-style FPS in haskell?
08:07:41 <quicksilver> does that jerk?
08:07:42 <paolino> :t freeze
08:07:44 <lambdabot> Not in scope: `freeze'
08:08:07 <quicksilver> Baughn: normally for graphical games it suffices to have a performGC() primitive you can call between frames
08:08:29 <Baughn> pjd: Hard to integrate with haskell, I expect, but go ahead and try. The nice thing about incremental GC is that you can divide memory into arbitrarily small regions, of which only one needs to be in cache at a time.
08:09:20 <Baughn> quicksilver: It would suffice if it didn't run for just barely too long at random intervals. Generational full-gc cycle?
08:09:49 <Baughn> pjd: s/about inc/about one particular style of inc/
08:10:04 <xic> Baughn: i doubt that was the GC
08:10:32 <Baughn> xic: Hmm. Perhaps I'll take the opportunity to learn how to use the profiling tools.
08:10:35 <xic> Baughn: try running with +RTS -B
08:10:51 <paolino> hi, \arr -> runSTArray (thaw arr >>= return) will evaluate everything hold by the arr recursively ?
08:11:00 <xic> Baughn: if you hear a beep when the jerk happens, *then* you may be right about the GC causing it
08:11:12 <bd_> paolino: it'd just copy the array I think
08:11:35 <bd_> paolino: the values of a STArray are boxed and nonstrict
08:12:02 <pjd> Baughn: actually, http://www.haskell.org/haskellwiki/Monadic_regions
08:12:03 <lambdabot> Title: Monadic regions - HaskellWiki
08:13:07 <paolino> so there is really no easy way for my state to get fully evaluated at one point
08:13:27 <Baughn> pjd: O..kay. Now it just needs to be integrated with the GC.
08:13:52 <pjd> a Small Matter Of Programming, i'm sure
08:15:09 <paolino> is it possible to make a Set type strict ?
08:18:21 <sjanssen> Set is already strict IIRC
08:18:56 <sjanssen> scratch that, Set is only spine strict
08:20:22 <inv2004> hi all
08:20:57 <inv2004> does haskell have "key" function ? in Kx !10 = 0 1 2 3 4 5 6 7 8 9
08:21:20 <quicksilver> inv2004: I didn't understand your example, can you explain better?
08:21:22 <dmead> what?
08:21:23 <dmead> you mean
08:21:30 <dmead> > [0..9]
08:21:31 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
08:21:40 <dino-> I'm going through the Understanding arrows part of wikibooks and also looking at the Control.Arrow source. I see something in the definition of second: swap ~(x,y) = (y,x)
08:21:45 <dino-> What is this ~ thing?
08:21:53 <inv2004> fun1 10 = [0,1,2,3,4,5,6,7,8,9]. yes
08:21:54 <mux> dino-: irrefutable pattern
08:22:04 <dino-> Huh, never saw it before today.
08:22:08 <quicksilver> inv2004: yes, it's built in as ..
08:22:09 <mux> also called lazy pattern
08:22:21 <quicksilver> inv2004: [0..9] is that array
08:22:28 <inv2004> wow, thx!
08:22:32 <quicksilver> inv2004: you might write fun1 n = [0..(n-1)]
08:22:45 <sjanssen> paolino: if you want to evaluate every item in a Set to RNF, this function should work:
08:22:47 <quicksilver> inv2004: erm by 'array' I mean 'list' sorry
08:23:15 <sjanssen> > foldr seq () . Data.Set.toList $ [1, 2, 3, 4]
08:23:16 <lambdabot>  Couldn't match expected type `Data.Set.Set a'
08:23:24 <mux> I admit I'm not sure what's the use of the lazy pattern in swap ~(x,y) = (y,x)
08:23:38 <mux> since given the definition of the function, it'll end up evaluating the pair anyway
08:23:41 <mux> wouldn't it?
08:23:47 <dino-> I don't really understand what it means, lazy pattern.
08:24:08 <quicksilver> normally a pattern match forces the program to evaluate the thunk to WHNF
08:24:14 <quicksilver> in order to check the construct
08:24:17 <quicksilver> constructor
08:24:30 <mauke> it's the same as swap t = (snd t, fst t)
08:24:35 <Cale> mux: not if the resulting pair isn't used
08:24:45 <mux> Cale: oh, right
08:24:48 <mux> stupid me.
08:25:45 <Cale> Putting a ~ before a pattern makes it always match, and only destructure the data if one of the variables matched is forced. If the data doesn't actually match at that point, an exception is raised.
08:26:24 <Remii> sjanssen: I heard (on haskell-libraries) that you're writing a haskell window manager?
08:26:38 <sjanssen> Remii: yep
08:27:45 <Remii> sjanssen: I'm really interested, 'cause I have some code lying around for over a year now.. ;)
08:28:06 <sjanssen> Remii: oh, you do?  How far did you get?
08:28:17 <pjd> Cale: that sounds like it has high foot-shooting potential
08:29:01 <Cale> pjd: well, yes, quite often
08:29:08 <Cale> not with things like pairs, obviously
08:29:23 <Cale> But with lists, it could be a problem :)
08:29:27 <Remii> I'm running it right now, but I've been postponing publishing it until it supports "frames" (reparenting windows to its own windows, which is apparently necessary to do input focussing correctly)
08:29:41 <Cale> You have to be just as careful as you would be with using head or tail.
08:29:51 <Remii> and I don't really seem to get around to implementing that ;)
08:31:55 <jre2> can anyone give their opinions on erlang vs haskell for a large simulation (each entity in simulation running their own AI thread)- this is for someone without much experience in either language
08:33:13 <paolino> if a function need to evaluate a structure in every piece, all the reference hanging around to those pieces are automatically updated to the computed vlue right ?
08:33:15 <sjanssen> Remii: I'm still at a very early stage of development, but I'll be sure to ping you when the code is online
08:34:02 <Remii> sjanssen: if you're interesting in my code (to see how you shouldn't do it ;)) I can pass you a link
08:34:17 <sjanssen> Remii: that would be great!
08:34:39 <Remii> :)
08:35:03 <Cale> paolino: well, yes
08:36:04 <Cale> paolino: When you write something like  double x = x + x, the duplication of the parameter x is represented by having both copies be a pointer to the real value to be computed, which is code until it is evaluated.
08:36:46 <Cale> (and, the way GHC does things, is still code after, it's just code which returns immediately with the result)
08:36:57 <quicksilver> jre2: I would choose haskell for the strong typing
08:37:10 <quicksilver> jre2: and I'd probably fake the threads rather than using true threading
08:37:24 <quicksilver> jre2: I don't generally find true threading is particularly helpful for simulation
08:37:48 <quicksilver> (you have to take care the threads don't get out of step, at which point you might as well be timestepping them yourself, frankly)
08:38:13 <jre2> yea, i don't need to preempt them
08:38:37 <quicksilver> doing the timesteps yourself lets you be precise about your semantics
08:38:41 <quicksilver> i.e. predictable
08:38:48 <quicksilver> normally simulations want to be predictable :)
08:39:15 <paolino> Cale, if ever I find the bastard holding the past in this program , I turn it in a piece of assembler
08:39:55 <Cale> paolino: hehe
08:40:16 <Cale> paolino: I think it sounds like you need retainer profiling, but I've never done that myself.
08:40:35 <Cale> Maybe try it out and see if it's of any use in tracking down what's holding on to your data.
08:40:44 <sjanssen> paolino: what sort of data are you holding in your set?
08:42:29 <sjanssen> most of the operations in Data.Set should be essentially strict -- because comparison is generally strict in both arguments
08:43:55 <paolino> sjanssen: I'm not sure the retainer is there
08:44:41 <Igloo> dons, dcoutts: Do we have a nice way to write the same code for more than one of String, ByteString, LazyByteString?
08:44:59 <paolino> data (Metrics s) => Node s = Node {  value :: s , sorteds :: S.Set (Float,Int), db :: IM.IntMap (Float,Int)}
08:45:10 <sjanssen> Igloo: I have the start of a Stringable class in my summer of code repo
08:45:45 <Igloo> sjanssen: Any idea what the overhead of that is?
08:46:03 <sjanssen> Igloo: no, I never got to that point
08:46:26 <quicksilver> classes shouldn't have an overhead
08:46:32 <quicksilver> they're resolved at compile-time
08:46:36 <inv2004> what type of the 9999999999999999999999 ?
08:46:42 <sjanssen> Igloo: should be fairly low
08:46:49 <quicksilver> unless the indirection needed to make a common API is noticeable
08:46:55 <nmessenger> @type 9999999999999999999999
08:46:57 <lambdabot> forall t. (Num t) => t
08:47:06 <nmessenger> it's a number.
08:47:08 <nmessenger> :)
08:47:12 <quicksilver> inv2004: Integer is the only type big enough to hold it, of the standard Num instances
08:47:15 <Igloo> quicksilver: There's that and the inability to do optimisations like inlining
08:47:17 <inv2004> how to define data Cell = Cell Num ?
08:47:25 <quicksilver> 9999999999999999999999 :: Double
08:47:29 <quicksilver> > 9999999999999999999999 :: Double
08:47:30 <lambdabot>  1.0e22
08:47:32 <inv2004> what's the constructor of the type ?
08:47:37 <inv2004> double? thx
08:47:42 <quicksilver> inv2004: it doesn't really have one, stricly
08:47:44 <quicksilver> inv2004: no, use Integer
08:47:51 <quicksilver> (9999999999999999999999 :: Integer)
08:47:57 <quicksilver> like that, if you want to be explicit
08:48:05 <nmessenger> data Cell = Cell Double -- or whichever type you want to use instead of Double
08:48:18 <quicksilver> Igloo: hmm it can't inline through a typeclass even if the class is known at compile time?
08:48:48 <Igloo> quicksilver: The instance won't be known at compile time
08:49:21 <inv2004> what is size of Integer ? isn't it int ?
08:49:21 <nmessenger> Are class method invocation specialized at the call site at compile-time?
08:49:27 <quicksilver> inv2004: Integer is unbounded
08:49:28 <sjanssen> Igloo: essentially all the instances look like "instance Stringable ByteString where head = ByteString.head ..." -- I imagine that ghc will inline those wrappers if the function that calls them is sufficiently specialized
08:49:43 <sjanssen> nmessenger: sometimes
08:49:54 <inv2004> thx, its what I need :)
08:49:59 <inv2004> that
08:50:16 <Igloo> sjanssen: Right, but I mostly have recursive calls inside a single module
08:51:15 <sjanssen> Igloo: I'm sure you know ghc's optimizer better than I do
08:51:39 <quicksilver> hmm
08:51:54 <quicksilver> without using existential types, is it not true that instances are always known at compile time?
08:52:49 <sjanssen> Igloo: perhaps you can operate on lazy bytestrings internally, and convert on output?
08:52:51 <Igloo> quicksilver: Consider compiling "module Foo (foo) where foo :: Stringable a => a -> a; foo = ..."
08:53:49 <sjanssen> Igloo: what happens if you include {-# SPECIALIZE foo :: ByteString -> ByteString #-} ?
08:54:13 <Igloo> sjanssen: Right, I could do that (on each function), but it's a bit ugly
08:54:37 <sjanssen> yeah
08:54:46 <inv2004> Undefined qualified variable "List.sort"
08:54:46 <nmessenger> Igloo: would "module Bar (bar) where import Foo(foo); bar = foo :: String -> String" have a runtime penalty?
08:55:03 <sjanssen> 3 * n specialization pragmas == no fun
08:55:10 <Remii> sjanssen: darcs get http://www.science.uva.nl/~rturk/hswm
08:55:15 <lambdabot> Title: Index of /~rturk/hswm
08:55:18 <Igloo> nmessenger: bar would have exactly the same performance as foo
08:55:29 <nmessenger> hmm
08:56:05 <Igloo> Oh, I guess any part of foo that gets inlined will get specialised
08:56:55 <sjanssen> Remii: thanks
08:57:13 <Remii> sjanssen: there's also some sort of TODO and a few cursor-xbm's there. I'm personally running it using a script (runhswm.sh) that restarts it when it dies (which does happen). And if it dies and isn't (cannot be) restarted it may leave you unable to change focus to other windows, which sucks ;)
08:57:21 <Saizan> so we should all go for whole program compilation?
08:57:25 <Saizan> :D
08:57:29 <nmessenger> sjanssen: what methods does Stringable have?  I'm curious.
08:58:06 <inv2004> is where sort_with_function function ? :)
08:58:12 <nmessenger> sortBy
08:58:16 <inv2004> thx
08:58:18 <inv2004> List ?
08:58:20 <Remii> sjanssen: Most of the code is inside a somewhat strange X Monad, which abstracts some things like error handling, although not entirely the way one would like to
08:58:28 <nmessenger> @hoogle sortBy
08:58:29 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
08:58:32 <inv2004> hx
08:58:35 <inv2004> thx
08:58:53 <nmessenger> though I usually use the heirarchical modules (Data.List)
08:59:05 <sjanssen> nmessenger: http://darcs.haskell.org/SoC/fps-soc/Data/Stringable.hs
08:59:57 <sjanssen> nmessenger: in short, Stringable is a medium sized subset of the ByteString API
09:00:04 <nmessenger> cool
09:05:22 <quicksilver> Igloo: but that's the only case? I.e. it's only cross-module compilation where it matters?
09:05:38 <inv2004> show = string of int, what is integer of string ?
09:05:58 <quicksilver> you can use read
09:06:00 <Igloo> quicksilver: I'm not sure I understand
09:06:00 <nmessenger> read :: String -> Int
09:06:04 <inv2004> thx!
09:06:07 <nmessenger> > read "20" :: Int
09:06:09 <lambdabot>  20
09:06:22 <Igloo> quicksilver: GHC will inline etc where it can (and thinks it will be advantageous)
09:06:37 <quicksilver> Igloo: it's only if you wish to have a module which exports a function quantified over a typeclass, that instance isn't known at compile time
09:06:40 <Igloo> quicksilver: I'm also not an expert on GHC's optimiser incidentally, but this is my understanding
09:06:40 <quicksilver> in other cases it is
09:06:50 <moonlite> > read "Just 10" :: Maybe Int
09:06:52 <quicksilver> (IMO this is why haskell really needs whole-program compilation)
09:06:52 <lambdabot>  Just 10
09:07:48 <Igloo> quicksilver: No, if you have a large function used with two different types in a module, then it also won't be specialised (it won't get inlined, and without specialise pragmas it wouldn't get copied once for each type)
09:08:05 <quicksilver> Igloo: *ah* nod
09:08:08 <quicksilver> hmmm
09:08:16 <nmessenger> I never looked into whole-program compilation before.  I think I understand this application, though.
09:08:24 <quicksilver> intuitively passing around dictionaries at runtime feels clumsy
09:08:38 <quicksilver> I'd have plumped for specialise by default
09:08:45 <quicksilver> However I'm sure they had their reasons :)
09:09:26 <pejo> Incidentially, Mark P. Jones has some article from mid 90's about partially evaluating that kind of stuff. (How I love to jump into the middle of a discussion).
09:09:48 <kolmodin> ?seen dons
09:09:48 <lambdabot> dons is in #haskell. I last heard dons speak 1h 9m 39s ago.
09:10:04 <kolmodin> so lamdbabot requires plugins again
09:10:23 <quicksilver> Because, I suppose, I would 'hope' that abstracting over a typeclass woudln't be a runtime overhead
09:10:34 <quicksilver> it feels like I've given the type checker enough information for it not to be
09:10:51 <quicksilver> (but independent compilation of quantified functions is obviously a blocker)
09:11:34 <bd_> kolmodin: hs-plugins darcs supports 6.6 though, so it's not too much of a problem... :)
09:11:35 <nmessenger> meh.  I almost never worry about runtime gymnastics.  Haskell frees me from it and I trust the smart folks behind the compilers.
09:12:22 <Igloo> @paste
09:12:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:12:24 <bd_> I wonder if run-time code generation could be used to specialize instances? Particularly if it could be moved to a seperate core...
09:12:49 <kolmodin> bd_: ok, then my problem hasn't to do with that
09:12:57 <kolmodin> I get a segfault :/
09:13:13 <hpaste>  Igloo pasted "classes" at http://hpaste.org/503
09:13:28 <inv2004> what's (at) in haskell ? 5th in list
09:13:40 <nmessenger> > [1..10] !! 4
09:13:42 <lambdabot>  5
09:13:43 <Igloo> quicksilver: For that paste, you'd have to specialise for an infinite number of instances
09:13:50 <inv2004> thx, I tried @@ :)
09:14:22 <nmessenger> > [1..10] !! 15 -- oh noes!
09:14:23 <lambdabot>  Exception: Prelude.(!!): index too large
09:14:26 <bd_> Igloo: Isn't that program _|_, though?
09:14:43 <Igloo> bd_: Sure, but do you want your compiler to diverge when you tell it to compile _|_?
09:15:19 <Igloo> Or rather, to compile a program that when run is _|_
09:15:20 <bd_> Igloo: No, but that doesn't mean it can't specialize using a heuristic at least :)
09:15:29 <quicksilver> Igloo: but Foo[a] is a single instance
09:15:53 <quicksilver> Igloo: foo[a] is truly polymorphic, the type of 'a' doesn't matter at all, no dictionary needed there
09:16:26 <Igloo> quicksilver: In this case, sure, but in general you could do more inlining if you specialised for [Int] and [Integer]
09:16:27 <quicksilver> bd_: in principle definitely. In practice that means embedding the compiler itself in your compiled code
09:16:50 <quicksilver> Igloo: right, but whole-program analysis will tell you exactly which types you need to specialise for
09:17:12 <Igloo> quicksilver: Yes, but it can be infinite
09:17:34 <quicksilver> hmm
09:17:42 <pejo> Igloo, I agree the compiler shouldn't diverge when fed with bottom. But that's not the common case, so maybe something could be done in particular (useful) instances of programs.
09:17:44 <quicksilver> probably I don't understand enough about ghc's code generation then
09:18:11 <quicksilver> Igloo: are you saying that length :: [Int] -> Int and length :: [Integer] -> Int potentially produce different code?
09:18:28 <quicksilver> Igloo: i was assuming that truly polymorphic functions were immune from specialisation
09:18:34 <quicksilver> it was typeclass specialisation I was worry about
09:18:52 <Igloo> quicksilver: No, for it to matter you'd have to put a class constraint in
09:18:56 <bd_> pejo: Actually, it is possible to get ghc to diverge already... :)
09:19:26 <pejo> bd, I know.
09:20:05 <Igloo> pejo: It would probably have to be relatively common to be worth doing; for individual cases you can direct GHC with pragmas
09:20:54 <quicksilver> Igloo: Ok, so if it only matters for classes, then I don't see how you can generate an infinite number of specialisations
09:21:00 <pejo> Igloo, oh, nods - definitely. I don't understand how big the problem is, there's probably something more urgent around the corner.
09:21:06 <quicksilver> Igloo: since your example only contains two, Int and forall a.[a]
09:21:27 <RemiTurk> sjanssen: I'm leaving #haskell for now. In case you have any questions, comments or darcs repos, my mail is rturk@science.uva.nl
09:25:10 <Igloo> quicksilver: Well, OK, you could just do that, but to really do what I thought you were suggesting you'd then want to inline different things into different instances of the forall a.[a] instance, right?
09:25:36 <quicksilver> not into that instance, no
09:25:51 <quicksilver> since it's truly polymorphic there can't be interesting calculations happening in there anyway
09:25:54 <Igloo> Although given limited inlining you might be OK anyway
09:26:06 <quicksilver> what I want to do is make sure that you don't pay a cost for abstracting into a typeclass
09:26:11 <quicksilver> it feels wrong that you should :)
09:26:12 <chessguy> hi haskellers
09:26:30 <pejo> Igloo, happen to know if there is any work related to the inliner?
09:26:44 <pejo> Uh, going on now that is. I'm aware of the article describing the secrets of it.
09:26:53 <quicksilver> if I have two functions foo_Int and foo_Integer and I abstract them out into a type class, that should just amount to saying to the type system "you decide which one to use"
09:27:05 <chessguy> paolino, ping
09:27:10 <quicksilver> in the presence of whole-program analysis, the type system should know which
09:27:18 <quicksilver> and be able to specialise them back
09:27:29 <Igloo> pejo: Ermm, I don't think I know of any, but that doesn't mean none is going on. I think SPJ just committed some changes to the specialiser
09:35:53 <ulfdoz> @where darcs
09:35:54 <lambdabot> http://darcs.net/
09:46:49 <xic> @seen Lemmih
09:46:49 <lambdabot> Lemmih is in #haskell-blah and #haskell. I last heard Lemmih speak 2h 38m 34s ago.
09:47:01 <Lemmih> @seen xic
09:47:01 <lambdabot> xic is in #happs, #darcs and #haskell. I last heard xic speak 12s ago.
09:47:27 <xic> Lemmih: hey... do you know where the most recent darcs repos is for haskell SDL bindings?
09:48:13 <Lemmih> @where hssql
09:48:13 <lambdabot> I know nothing about hssql.
09:48:26 <quicksilver> @where hssdl
09:48:27 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
09:48:37 <Lemmih> There is it.
09:48:45 <xic> cool thanks!
09:48:52 <xic> Lemmih: btw, how is hIDE going?
09:58:18 <ddarius> @seen Riastradh
09:58:19 <lambdabot> Riastradh is in #oasis and #darcs. I last heard Riastradh speak 13h 8m 57s ago.
09:59:08 <xic> @hoogle maybePeek
09:59:09 <lambdabot> Foreign.Marshal.Utils.maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)
09:59:30 <xic> @hoogle newForeignPtr_
09:59:31 <lambdabot> Foreign.ForeignPtr.newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
10:02:10 <Lamperi_> ~.
10:04:42 <givi> hello! how can I read n integers from a string?
10:04:58 <ddarius> @type reads
10:05:00 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:05:35 <givi> ?index reads
10:05:36 <lambdabot> Text.Read, Prelude
10:05:38 <ddarius> > reads "1 2 3" :: [(Int,String)]
10:05:40 <lambdabot>  [(1," 2 3")]
10:05:41 <glguy> > map read . words $ "1 2 33 44" :: [Int]
10:05:42 <lambdabot>  [1,2,33,44]
10:06:10 <givi> what does "$" stands for?
10:06:17 <vincenz> function application
10:06:18 <glguy> f $ x = f x
10:06:20 <vincenz> f $ x == f x
10:06:26 <vincenz> f $ g $ x == f (g x)
10:06:35 <vincenz> f . g $ x == (f .g ) x == f (g x)
10:06:48 <vincenz> it's right associative and has a low binding, hence it's use :)
10:07:14 <glguy> by using    f . g $ x, you can clearly see what part of my example is the function, and what is the sample input
10:07:25 <glguy> and if you just copy the f.g part right out of the irc window
10:07:32 <glguy> you won't need to edit for parentheses!
10:07:42 <givi> oh cool!
10:07:52 <glguy> it's like I did your homework for you!
10:07:53 <glguy> ;)
10:07:58 <nmessenger> > map read (words "1 2 33 44") -- same thing
10:07:59 <lambdabot>  [1,2,33,44]
10:10:15 <ddarius> @type foldM
10:10:18 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:11:04 <givi> glguy: :))) thanks!
10:11:40 <ddarius> @index listToMaybe
10:11:41 <lambdabot> Data.Maybe
10:12:09 <givi> > reads " 2 3" :: [(Int::String)]
10:12:09 <lambdabot>  Parse error
10:12:20 <givi> > reads "2 3" :: [(Int::String)]
10:12:20 <lambdabot>  Parse error
10:12:37 <givi> > reads " 2 3" :: [(Int,String)]
10:12:38 <lambdabot>  [(2," 3")]
10:12:42 <Laney> @type words
10:12:45 <lambdabot> String -> [String]
10:14:01 <nmessenger> @let readMaybe x = case reads x of {[(y,_)] -> Just y; _ -> Nothing}
10:14:03 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
10:14:22 <nmessenger> :O!
10:23:56 <chessguy> Lemmih, hi
10:24:23 <Lemmih> chessguy: yo
10:24:52 <chessguy> Lemmih, someone suggested i talk to you about using some space for a publicly-accessible darcs repo?
10:26:42 <Lemmih> chessguy: Right, mail me your pubkey and I'll create an account for you.
10:26:58 <chessguy> pubkey?
10:28:19 <vincenz> chessguy: ssh
10:28:22 <vincenz> ssh-keygen
10:34:42 <chessguy> ?users
10:34:42 <lambdabot> Maximum users seen in #haskell: 328, currently: 317 (96.6%), active: 49 (15.5%)
10:55:52 <glguy> ?where xhtml
10:55:52 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml
10:57:42 <glguy> ?where+ xhtml http://darcs.haskell.org/packages/xhtml/
10:57:42 <lambdabot> Done.
10:58:27 <titus> hi, can anyone help with building lambdabot?
10:58:31 <glguy> ?where binary
10:58:31 <lambdabot> http://darcs.haskell.org/binary
10:59:22 <titus> I'm using ghc 6.6 - the build script says cannot meet dependency arrows-any
11:01:02 <glguy> ?where missingh
11:01:02 <lambdabot> http://software.complete.org/missingh
11:01:29 <xic> what's the performance difference in Data.Map between key lookup and index lookup?
11:02:16 * paolin1 found the leak
11:02:41 <glguy> xic: the docs don't say?
11:02:58 <paolin1> the continuation monad leaks like hell
11:03:12 <xic> glguy: no, the docs just say O(log n) for both
11:04:16 <sjanssen> xic: index lookup does O(log n) Int comparisons, key lookup does O(log n) comparisons for whatever your key type is
11:05:13 <xic> sjanssen: so you're saying that if my key type is Int, then performance is the same? that doesn't seem to make much sense
11:05:27 <sjanssen> xic: yeah, should be about the same
11:05:34 <glguy> xic: if your key type is an Int, why not IntMap?
11:05:35 <sjanssen> xic: why doesn't it make sense?
11:06:52 <titus> what is the lambdabot dependency `arrows-any' about?
11:07:01 <xic> ok, i guess it does sort of make sense... i guess the indexing isn't what i was hoping it was
11:07:33 <sjanssen> titus: what platform are you on?
11:07:53 <titus> sjanssen: ubuntu linux ghc 6.6
11:08:34 <sjanssen> titus: ghc 6.6 split up the libraries a bit, and the arrows package is now an "extralib"
11:08:56 <sjanssen> see if your distribution has a package called "arrows" or "extralibs"
11:09:28 <titus> sjanssen: is this related to fptoolsPath in Configure.hs?
11:09:37 <sjanssen> titus: no
11:11:45 <titus> sjanssen: I built ghc 6.6 from source, the base and extralibs and did ./configure with no options - did I need to build something in? There is an arrows dir in /libraries
11:12:22 <Igloo> titus: Then you don't have extralibs
11:12:36 <Igloo> Oh, sorry, misread that
11:12:56 <Igloo> No, that should work. What does ghc-pkg -l say?
11:13:27 <titus> jim@unicorn:~/ghc-6.6$ ghc-pkg -l
11:13:27 <titus> /usr/local/lib/ghc-6.6/package.conf:
11:13:27 <titus>     Cabal-1.1.6, HGL-3.1, HUnit-1.1, QuickCheck-1.0, X11-1.1, base-2.0,
11:13:27 <titus>     cgi-2006.9.6, fgl-5.2, (ghc-6.6), haskell-src-1.0, haskell98-1.0,
11:13:27 <titus>     html-1.0, mtl-1.0, network-2.0, parsec-2.0, readline-1.0,
11:13:29 <titus>     regex-base-0.71, regex-compat-0.71, regex-posix-0.71, rts-1.0,
11:13:31 <titus>     stm-2.0, template-haskell-2.0, time-1.0, unix-1.0, xhtml-2006.9.13,
11:13:33 <titus>     zlib-0.3
11:14:11 <Igloo> You're sure that's the ghc-pkg that you built?
11:14:37 <titus> Igloo: yes
11:14:52 <Igloo> Hmm, you have some extralibs but not all of them
11:14:54 <titus> I can go :m Control.Arraow in ghci and it works OK
11:15:00 <titus> Arrow
11:15:42 <Igloo> Control.Arrow is in base
11:15:51 <sjanssen> titus: that module is part of the base package
11:16:12 <titus> oh, maybe that's why it works :-)
11:16:40 <Igloo> Ah, arrow isn't mentioned in libraries/Makefile
11:16:48 <paolin1> this function makes my memory explode in 5 seconds (512 Meg)
11:16:49 <paolin1> evolution x = callCC breakable where
11:16:49 <paolin1>   breakable exit = loop where
11:16:49 <paolin1>     loop = loop >> exit "ciao"
11:17:01 <Igloo> Either add it or build it with cabal
11:17:16 <titus> Igloo: how do I build with Cabal?
11:17:26 <givi> ?type readList
11:17:28 <lambdabot> forall a. (Read a) => String -> [([a], String)]
11:17:35 <sjanssen> titus: cd ghc/libraries/arrows; runghc Setup.hs configure
11:17:40 <sjanssen> then build, then install
11:17:51 <givi> > readList "1 2 3"
11:17:53 <lambdabot>  []
11:18:11 <titus> sjanssen: thanks I'll give it a go
11:18:22 <givi> > readList "1 2 3" :: ([Int],String])
11:18:23 <lambdabot>  Parse error
11:18:40 <givi> > readList "1 2 3" :: [([Int],String)]
11:18:41 <lambdabot>  []
11:20:22 <paolin1> @seen Cale
11:20:23 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 2h 39m 46s ago.
11:21:37 <titus> sjanssen: thanks, that worked for the arrows dependency, I now need to install binary
11:22:41 <sjanssen> hackage is your best bet there
11:22:43 <sjanssen> @where hackage
11:22:44 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
11:24:47 <paolin1> @tell Cale, the leak is in the continuation monad
11:24:48 <lambdabot> Consider it noted.
11:27:05 <nmessenger> I think that'll try to tell "Cale," something, not "Cale"
11:27:57 <nmessenger> @tell paolin1, test
11:27:58 <lambdabot> Consider it noted.
11:29:35 <paolin1> @tell Cale  the leak is in the continuation monad
11:29:36 <lambdabot> Consider it noted.
11:29:47 <paolin1> thanks nmessenger
11:30:06 <nmessenger> sure
11:30:07 <oklopol> @tell oklopol something
11:30:08 <lambdabot> You can tell yourself!
11:30:10 <oklopol> :P
11:30:25 <oklopol> i love this bot
11:30:48 <nmessenger> @yow!
11:30:49 <lambdabot> I wonder if I ought to tell them about my PREVIOUS LIFE as a COMPLETE
11:30:49 <lambdabot> STRANGER?
11:31:01 <opqdonut> @yow!
11:31:01 <lambdabot> As President I have to go vacuum my coin collection!
11:32:31 <flaggy> hello
11:32:51 <flaggy> does anyone know where's the code for the ghc windows installer? I can't seem to find it
11:35:21 <dcoutts_> flaggy, it's not open source :-(
11:35:32 <flaggy> oh :(
11:35:38 <flaggy> why not?
11:35:43 <dcoutts_> flaggy, ndm has been trying to get ahold of it for years
11:36:02 <flaggy> is it written in haskell?
11:36:04 <flaggy> do you know?
11:36:52 <dcoutts_> no idea, sorry
11:37:01 <flaggy> ok, thanks
11:37:01 <dcoutts_> I think it is Haskell though
11:37:21 <nmessenger> The download page links to the maintainer, maybe you could email him?
11:37:47 <flaggy> I wanted to learn how to make those .msi installers
11:38:40 <Igloo> ndm plans to make open source Haskell installers for ghc, yhc and other stuff
11:39:22 <dcoutts_> flaggy, at the moment I'd recommend finding one of the many .msi builder tools that generate .msi files from a text description.
11:39:27 <nmessenger> I've no idea if there's a Haskell library that will, but you could consult google for "making msi files"
11:41:36 <flaggy> hm i didn't know about those
11:42:57 <titus> while building plugins with Cabal I have an error
11:43:02 <titus> [18 of 24] Compiling AltData.Typeable ( src/AltData/Typeable.hs, dist/build/AltData/Typeable.o )
11:43:03 <titus> src/AltData/Typeable.hs:452:0:
11:43:03 <titus>     parse error (possibly incorrect indentation)
11:43:26 <titus> this is from the tarball in hackage
11:44:03 <moonlite> @seen dons
11:44:04 <lambdabot> dons is in #haskell. I last heard dons speak 3h 43m 54s ago.
11:45:30 <moonlite> i'm thinking of implementing an FTP server in Haskell as a course project. How much do you guys think i can benefit (performance wise) with the new bytestring-library?
11:46:00 <dcoutts_> about a factor of 10 max
11:46:05 <opqdonut> :)
11:46:11 <moonlite> im concerned about that all the network-tools take normal Strings of input
11:46:19 <moonlite> dcoutts_: that would be acceptable :))
11:46:38 <moonlite> umm, network functions.
11:46:45 <flaggy> everyone is talking about that bytestring-library lately
11:46:54 <dcoutts_> that's because it's cool.
11:46:57 <opqdonut> ?yow!
11:46:57 <lambdabot> I'm continually AMAZED at th'breathtaking effects of WIND EROSION!!
11:47:34 <dcoutts_> moonlite, don't you get a Handle with the networking stuff? so you can use normal IO functions, including the ByteString ones. It's not limited to String.
11:47:53 <moonlite> ooh
11:48:26 <dcoutts_> I know HAppS uses ByteStrings in it's networking code
11:49:40 <xic> that's right, the bytestring library comes with a bunch of functions for sending/receiving bytestrings through Handles
11:49:48 <moonlite> ok. so i actually hadn't checked the API up. sorry about that, and thanks for the help. :)
11:50:14 <xic> and do use them instead of the regular String functions if you need performance
11:53:43 <flaggy> why not to use bytestring then?
11:54:08 <dcoutts_> there's no [] : pattern matching
11:54:17 <flaggy> oh, i see
11:54:20 <dcoutts_> direct recursive construction is harder
11:54:38 <dcoutts_> they're not so efficient for very short strings
11:54:58 <flaggy> very short being what? 10 chars?
11:55:37 <dcoutts_> iirc ByteString has a 20 byte overhead
11:55:48 <dcoutts_> String has a 12 byte cost per char
11:56:33 <flaggy> i see
11:56:38 <SamB> how can bytestring really only have 20 byte overhead?
11:56:46 <SamB> what all does that include?
11:57:17 <dcoutts_> data ByteString = BS (ForeignPtr Word8) Int Int
11:57:19 <EvilTerran> 4 bytes of buffer length, 4 bytes of stored string length, 12 bytes of Other Stuff?
11:57:25 <EvilTerran> I'm guessing.
11:57:37 <dcoutts_> data ForeignPtr = FP Addr# ForeignPtrContents
11:57:58 <SamB> what about the cost of the actual pointed-at area?
11:58:12 <Igloo> That's not overhead
11:58:16 <SamB> doesn't that pointed-at area have overhead?
11:58:29 <dcoutts_> data ForeignPtrContents = PlainPtr (MutableByteArray# RealWorld) | ...
11:58:47 <dcoutts_> then the MutableByteArray# itself had a header word and a length
11:58:54 <opqdonut> SamB: probably just a raw char array
11:59:10 <Igloo> dcoutts_: Do you mean word rather than byte above?
11:59:43 <SamB> dcoutts: okay
12:00:07 <SamB> I guess that probably *is* everything, except for GHC's block allocation overhead
12:00:54 <dcoutts_> so in words, that's 1 for the ByteString header, 2 for the Ints, 1 for the Addr#, 1 for the ForeignPtrContents pointer. 1 for the ForeignPtrContents header, 1 for the MutableByteArray# pointer, 1 for the MutableByteArray# header and 1 for theMutableByteArray# size.
12:01:19 * EvilTerran is away: eats
12:01:39 <dcoutts_> > 9 * 4
12:01:41 <lambdabot>  36
12:01:48 <dcoutts_> ok, 36 Bytes overhead
12:02:02 <dcoutts_> on a 32bit machine
12:02:07 <dcoutts_> > 9 * 8
12:02:09 <lambdabot>  72
12:02:13 <dcoutts_> on a 64 bit box
12:02:21 <dcoutts_> 36 / 12
12:02:29 <dcoutts_> > 36 / 12
12:02:30 <lambdabot>  3.0
12:02:52 <dcoutts_> so ByteString wins on space vs a String of length 4
12:04:07 <dcoutts_> if we had a more cunning ForeignPtr we could shave off 2 words
12:05:48 <pejo> On a long string those 36 bytes are noise anyways.
12:06:00 <dcoutts_> true
12:06:31 <dcoutts_> for short strings I might use a different representation
12:07:23 <dcoutts_> newtype ShortString = SS ByteArray#
12:07:38 <dcoutts_> but that doesn't provide efficient head/tail
12:08:03 <dcoutts_> but it'd only have 2 words overhead
12:08:36 <dcoutts_> useful for tokens/words in some applications
12:08:41 <SamB> huh
12:08:55 <SamB> er.
12:09:22 <SamB> wouldn't it have at least 3 words of overhead?
12:09:22 <dcoutts_> SamB, confused?
12:09:36 <syntaxfree> jesus. I didn't expect the Spanish Inquistion on the I/O article. I made a point of being specially noncontroversial.
12:09:36 <dcoutts_> oh, yes 1 for the pointer
12:09:37 <SamB> info pointer for SS...
12:09:47 <dcoutts_> no
12:09:54 <dcoutts_> it's a newtype not a box
12:09:58 <SamB> oh
12:10:03 <SamB> he
12:10:03 <nmessenger> syntaxfree: this is the internets.  You expected something different?
12:10:27 <SamB> dcoutts: I don't think you count the pointer to an object in its cost
12:10:31 <dcoutts_> but there's one for the pointer to the ByteArray#, but then everything has that
12:10:35 <dcoutts_> right, exactly
12:10:49 <dcoutts_> so by that count it's just 2 words
12:10:54 <syntaxfree> I mean, I'm a devil's advocate. I often set out to stir controversy, with varying degrees of success.
12:11:02 <SamB> that pointer goes into the cost of whatever things reference it
12:11:21 <syntaxfree> But not with that!
12:11:32 <dcoutts_> SamB, aye
12:11:42 <Botje> syntaxfree: to quote yegge: it's a sign you're saying the right thing :p
12:11:59 <syntaxfree> don't get me started on Yegge ; )
12:12:28 <nmessenger> strong generalizations like "IO doesn't matter" can put many on the defensive.
12:12:46 <syntaxfree> does IO matter?
12:13:36 <syntaxfree> I mean, are we talking about programming or are talking about baking cheesecakes?
12:14:32 <nmessenger> heh.  If by "matter" you mean "is it necessary for a useful program", than it does.  If you mean "it is necessary while thinking of the problem at hand", then not really.
12:14:48 <syntaxfree> @info sqrt
12:14:49 <lambdabot> sqrt
12:15:06 <syntaxfree> @instances sqrt
12:15:07 <lambdabot> Couldn't find class `sqrt'. Try @instances-importing
12:15:19 <nmessenger> @src sqrt
12:15:19 <lambdabot> Source not found. Where did you learn to type?
12:15:24 <syntaxfree> @instances Fractional
12:15:25 <lambdabot> Double, Float
12:15:33 <nmessenger> cheesecakes?
12:18:31 <nmessenger> Joe Random Hacker will see the assertion you make, believe it to be of the first type, and dismiss you out of hand since they know it false.
12:19:16 <nmessenger> Not much to worry about, though.  Communication is a difficult task and there are more important things to be done :)
12:19:20 <syntaxfree> I/O beyond the REPL and/or "interact" is not necessary for an useful program.
12:20:07 <SamB> depends on what the usefull program is supposed to do
12:20:31 <nmessenger> exactly, I'm not disagreeing, just showing why such an assertion would cause the controversy
12:21:41 <nmessenger> @help info
12:21:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:21:46 <nmessenger> @info blah
12:21:46 <lambdabot> blah
12:21:52 <nmessenger> perhaps it's @id?
12:26:59 <JohnnyL> in "data Point = Pt {pointx, pointy:: Float} given ":t pointx" yields "pointx :: Point -> Float. How does Point come before float? I'm not sure the order of evaluation of how Point is thrown in there.
12:27:57 <nmessenger> pointx is a function that takes a Point and results in a Float, i.e. it extracts the 'x' portion of the Point
12:27:59 <JohnnyL> pointx is Float, but how does Point get in there when it's the result of Pt {pointx}.
12:28:11 <Stinger> pointx is a function
12:29:01 <nmessenger> the record syntax is just a shorthand for "data Point = Pt Float Float; pointx (Pt x _) = x; pointy (Pt _ y) = y"
12:30:06 <nmessenger> that is, a Point has two Float fields, and two functions are created for extracting their value.
12:30:43 <chessguy> JohnnyL, if you do foo :: Point, foo = Point {pointx=3,pointy=4}, then you (pointx foo) would return 3. That is, pointx takes a Point,  foo in this case, and returns a float, 3
12:30:51 <hpaste>  syntaxfree pasted "sometimes things just don't work the way I expect'em too." at http://hpaste.org/504
12:31:05 <hpaste>  (anonymous) annotated "sometimes things just don't work the way I expect'em too." with "(no title)" at http://hpaste.org/504#a1
12:32:39 <titus> I need some help building the plugins library...
12:33:05 <titus> Here's what I got:
12:33:08 <titus> Building plugins-1.0...
12:33:08 <titus> [18 of 24] Compiling AltData.Typeable ( src/AltData/Typeable.hs, dist/build/AltData/Typeable.o )
12:33:08 <titus> src/AltData/Typeable.hs:452:0:
12:33:08 <titus>     parse error (possibly incorrect indentation)
12:33:08 <titus> jim@unicorn:~/haskell/plugins-1.0$
12:33:19 <syntaxfree> titus: please use
12:33:20 <syntaxfree> !paste
12:33:21 <hpaste> Haskell paste bin: http://hpaste.org/
12:34:04 <titus> syntaxfree: sorry, new round here
12:34:29 <syntaxfree> :)
12:34:57 <JohnnyL> chessguy, that helps a bit, but my head is still spining.
12:35:14 <chessguy> JohnnyL, just keep asking questions
12:35:53 <chessguy> have you seen the record example in YAHT by the way?
12:36:16 <JohnnyL> np
12:36:26 <chessguy> that's a good one
12:36:32 <hpaste>  (anonymous) annotated "sometimes things just don't work the way I expect'em too." with "(no title)" at http://hpaste.org/504#a2
12:36:37 <chessguy> ?where yaht
12:36:37 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
12:36:37 <maskd> titus: are you building the latest version from darcs?
12:36:38 <hpaste>  titus pasted "build error on plugins lib" at http://hpaste.org/505
12:36:48 <chessguy> search for "named field"
12:37:21 <titus> maskd: no, this is the tarball from hackage - should I get it from darcs?
12:38:31 <titus> @where plugins
12:38:32 <lambdabot> I know nothing about plugins.
12:39:19 <maskd> http://darcs.haskell.org/~lemmih/hs-plugins/
12:39:21 <lambdabot> Title: Index of /~lemmih/hs-plugins
12:39:50 <bd_> It hasn't been released yet?
12:40:08 <titus> maskd: OK, I'll give that a go
12:46:25 <tibbe> @paste
12:46:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:47:05 <glguy> is links the text-browser with a graphical mode?
12:48:21 <mbishop> links -g
12:48:24 <hpaste>  tibbe pasted "Maybe and IO" at http://hpaste.org/506
12:48:31 <JohnnyL> getHostData (Configuration {localhost = lh, remotehost = rh}) = (lh rh), what are the names of the individual items in this example. For example localhost is a 'Named field'?
12:48:56 <JohnnyL> opps (lh,rh)
12:49:01 <tibbe> Is there a way to get Maybe's binding strategy to work in the IO monad ^^
12:49:03 <Saizan> yes, it is
12:49:18 <bd_> ?where MaybeT
12:49:19 <lambdabot> I know nothing about maybet.
12:49:21 <bd_> hmm
12:49:44 <tibbe> you can't wrap IO
12:50:18 <bd_> tibbe: there was a MaybeT on the haskell wiki somewhere...
12:50:34 <bd_> ?wiki New_Monads/MaybeT
12:50:34 <lambdabot> http://www.haskell.org/haskellwiki/New_Monads/MaybeT
12:50:37 <Saizan> ?hoogle parseURI
12:50:38 <lambdabot> Network.URI.parseURI :: String -> Maybe URI
12:50:38 <lambdabot> Network.URI.parseURIReference :: String -> Maybe URI
12:50:42 <hpaste>  tibbe annotated "Maybe and IO" with "(no title)" at http://hpaste.org/506#a1
12:50:53 <bd_> http://www.haskell.org/haskellwiki/New_monads/MaybeT here it is
12:50:54 <chessguy> http://www.haskell.org/haskellwiki/New_monads/MaybeT
12:50:55 <lambdabot> Title: New monads/MaybeT - HaskellWiki
12:50:56 <lambdabot> Title: New monads/MaybeT - HaskellWiki
12:50:58 <chessguy> lol
12:51:02 <chessguy> i win!
12:51:04 <bd_> ?quote stereo
12:51:04 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
12:51:28 <bd_> tibbe: anyway, MaybeT IO should be roughly what you want
12:51:44 <chessguy> good old Yitzhak
12:51:52 <tibbe> bd_, thanks
12:52:05 <kpreid> chessguy: IRC has no global message order; bd_ 'won' from my view
12:52:40 <chessguy> kpreid, you're free to be wrong
12:52:42 <chessguy> :)
12:53:01 <bd_> chessguy: As are you :)
12:53:09 <chessguy> pfff
12:53:10 <Saizan> [21·49·20] <bd_> http://www.haskell.org/haskellwiki/New_monads/MaybeT here it is
12:53:10 <Saizan> [21·49·21] <chessguy> http://www.haskell.org/haskellwiki/New_monads/MaybeT
12:53:11 <lambdabot> Title: New monads/MaybeT - HaskellWiki
12:53:12 <chessguy> ?quote wrong
12:53:12 <lambdabot> Title: New monads/MaybeT - HaskellWiki
12:53:12 <lambdabot> metaperl says: Haskell is like the lady who never gets married because there is something wrong with every potential suitor
12:53:30 <Saizan> bd_ was one whole second ahead!
12:53:48 <chessguy> heh. i don't have that much detail on my timestamps
12:54:31 * chessguy adds seconds to his timestamps
12:55:06 <bd_> ?where+ maybet http://www.haskell.org/haskellwiki/New_monads/MaybeT
12:55:06 <lambdabot> Done.
12:55:07 <chessguy> [15:49:23] <chessguy> http://www.haskell.org/haskellwiki/New_monads/MaybeT
12:55:07 <chessguy> [15:49:24] <bd_> http://www.haskell.org/haskellwiki/New_monads/MaybeT here it is
12:55:08 <bd_> ?where MaybeT
12:55:08 <lambdabot> Title: New monads/MaybeT - HaskellWiki
12:55:09 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
12:55:09 <lambdabot> Title: New monads/MaybeT - HaskellWiki
12:55:12 <bd_> there :)
12:56:11 <tibbe> I'm a bit confused, wouldn't MaybeT (IO a) imply that IO is no longer properly referential transparent
12:56:17 <tibbe> or is that the other way around?
12:56:29 <tibbe> n/m
12:56:42 <chessguy> tibbe, by the way,  you said "<tibbe> you can't wrap IO" -  i think what you're referring to is that IO can't transform another monad
12:56:45 <bd_> tibbe: No; you can't write a function (MaybeT IO a -> a) any more than you can with (IO a -> a)
12:56:52 <bd_> tibbe: also, it's MaybeT IO a, not MaybeT (IO a)
12:57:33 <chessguy> that is, IO *must* be at the "bottom" of a "stack" of monads
12:57:44 <tibbe> chessguy, right, thanks
12:58:05 <tibbe> bd_, thanks
13:04:23 <tibbe> @hoogle liftIO
13:04:24 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
13:04:34 <tibbe> @hoogle lift
13:04:35 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
13:04:35 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
13:04:35 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
13:07:03 <Stinger> msg lambdabot help
13:07:08 <Stinger> hmmm
13:10:37 <tibbe> um, if I put my MaybeT.hs in Control/Monad in my project dir why can't I import Control.Monad.MaybeT?
13:11:12 <JohnnyL> does => mean the same as 'is equivilent to'?
13:11:28 <SamB> tibbe: what happens when you try?
13:11:38 <siti> JohnnyL: in what context?
13:12:00 <tibbe> SamB, ghci says: Could not find module `Control.Monad.MaybeT':
13:12:00 <JohnnyL> (>=) :: Ord a => a -> a ->Bool
13:12:39 <sjanssen> tibbe: you have module Control.Monad.MaybeT where ... in the file too?
13:12:40 <siti> it means a has to have an instance of the class Ord
13:12:50 <tibbe> my project dir looks like: ~/proj/Foo/Bar.hs which import Control.Monad.MaybeT from ~/proj/Control/Monad/MaybeT.hs
13:13:18 <JohnnyL> siti, ok thanks.
13:13:23 <tibbe> sjanssen, ooops, it was named Control.Monad.Maybe
13:13:28 <tibbe> got it from the wiki
13:13:43 <tibbe> so transformer modules doesn't get a T added at the end?
13:14:07 <glguy> ?seen sorear
13:14:07 <lambdabot> I saw sorear leaving #happs, #darcs, #ghc and #haskell 15h 8m 55s ago, and .
13:14:09 <siti> JohnnyL: I hope that makes sense :)
13:14:32 <roconnor> > length [1.0,1.25..10.0]
13:14:33 <lambdabot>  37
13:14:37 <roconnor> > length [1.0,1.2..10.0]
13:14:39 <lambdabot>  46
13:15:33 <tibbe> sjanssen, I renamed the import now but that didn't help
13:15:38 <sjanssen> tibbe: the convention is for both the non-transformer and transformer versions to live in the same module
13:16:08 <sjanssen> tibbe: so the import, the file name, and the module declaration all match?
13:16:21 <tibbe> sjanssen, yes
13:16:35 <sjanssen> should just work then
13:16:43 <mwc> Uhm, does GHCi not perform tail recursion on functions defined at the prompt?
13:16:46 <roconnor> > length [1.0,1.5..10.0]
13:16:47 <lambdabot>  19
13:17:10 <bd_> mwc: GHCi doesn't do very much optimization. tail recursion can be acheived by laziness in many cases though
13:17:12 <tibbe> sjanssen, could it be running ghci from within emacs?
13:17:19 <sjanssen> tibbe: and you're running ghc from the root of the hierarchy?
13:17:30 <mwc> bd_: ah, wondering abotu this:
13:17:31 <mwc> Prelude> let g x = x*(3 - x*x)
13:17:31 <mwc> Prelude> let iter n f x = if n == 0 then x else iter (n - 1) f (f x)
13:17:31 <mwc> Prelude> iter 1000000 g 1.05
13:17:31 <mwc> *** Exception: stack overflow
13:17:55 <bd_> mwc: It's probably not strict enough
13:17:56 <sjanssen> tibbe: it's possible that emacs isn't setting the correct directory
13:18:04 <bd_> mwc: you're building this big f (f (f (f (f ( ...... thing
13:18:04 <mwc> bd_: thx
13:18:19 <bd_> mwc: so seq in strategic places, or use bang patterns
13:18:50 <tibbe> sjanssen, hmm
13:18:57 <mwc> yeah, I just switched to iter (n - 1) f $! (f x)
13:19:03 <mwc> works now
13:19:08 <tibbe> sjanssen, I'll try to set it manually
13:19:56 <tibbe> sjanssen, that did it
13:25:15 <Vq^> what is the meaning of the "GZip Bytes" comparison at the shootout?
13:26:12 <Vq^> is it meant to reflect language expressiveness?
13:27:09 <tibbe> if I convert Maybe a code to MaybeT m a code I need to lift all the actions that previosuly used the Maybe bind to use the MaybeT bind right?
13:27:57 <tibbe> ie. foo <- someMaybe bar    --->    foo <- lift $ someMaybe bar
13:29:11 <Vq^> tibbe: isn't it the m monad you lift into?
13:30:36 <JohnnyL> what exactly does deriving actually do, set up templates for a set of functions?
13:30:57 <bd_> JohnnyL: It automatically creates instance declarations
13:31:09 <JohnnyL> oh ok.
13:31:17 <tibbe> @paste
13:31:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:32:52 <nmessenger> "data Foo = Bar | Baz | Quux deriving (Eq)" automatically defines "instance Eq Foo where Bar == Bar = True; Baz == Baz = True; Quux == Quux = True; _ == _ = False"
13:32:55 <hpaste>  tibbe pasted "Combining MaybeT and IO" at http://hpaste.org/507
13:33:08 <tibbe> I'm having some problems with this ^^
13:33:36 <bd_> tibbe: MaybeT is not in the default mtl, you'll need to create a mdoule with it
13:33:39 <bd_> module*
13:33:43 <tibbe> bd_, I have
13:33:54 <tibbe> it's the lifting that I don't quite get
13:34:12 <glguy> you need to "liftIO" anything with an IO a result
13:34:21 <glguy> so that it has a MaybeT IO a type
13:34:34 <tibbe>     Couldn't match expected type `MaybeT m t'
13:34:34 <tibbe> 	   against inferred type `Maybe URI'
13:34:34 <tibbe>     In a 'do' expression: uri <- parseURI url
13:34:46 <bd_> MaybeT :: IO (Maybe a) -> MaybeT IO a
13:34:57 <Vq^> where is MaybeT defined?
13:35:11 <Saulzar> You can't use a Maybe as a MaybeT m t
13:35:14 <tibbe> I'm getting confused about what monad I'm currently in
13:35:17 <bd_> tibbe: parseURI is not monadic; you can do uri <- MaybeT . return . parseURI $ url
13:35:23 <bd_> parseURI /should/ arguably be monadic :)
13:35:33 <bd_> actually, better:
13:35:37 <hpaste>  glguy annotated "Combining MaybeT and IO" with "my MaybeT" at http://hpaste.org/507#a1
13:35:37 <tibbe> bd_, I haven't written that function though
13:35:41 <bd_> Just uri <- return (parseURI url)
13:35:51 <bd_> hmm, does fail work with let, I wonder?
13:36:20 <glguy> fail is a function like any other
13:36:31 <sjanssen> bd_: you mean the pattern matching fail behavior?
13:36:43 <sjanssen> in short, no
13:36:54 <bd_> :(
13:37:10 <bd_> let pattern = match should desugar to the same as pattern <- return (match)
13:37:26 <tibbe> bd_, does it have to be that ugly to use MaybeT instead of Maybe
13:37:34 <tibbe> that kinda defeats my whole point of doing it
13:37:47 <tibbe> (ie avoiding some case expression when combining failure with IO)
13:37:48 <sjanssen> bd_: what about functions and mutually recursive let bindings?
13:37:50 <bd_> tibbe: When you have functions of type IO (Maybe a), you can use the MaybeT constructor to convert
13:37:59 <bd_> sjanssen: only the do-statement let form :_)
13:38:17 <bd_> tibbe: when you have functions of type (Maybe a) you can use Just a <- return m
13:38:20 <sjanssen> bd_: the do-statement let form has functions and mutually recursive bindings
13:38:21 <bd_> which is ugly
13:38:29 <bd_> or you can make an adapter function:
13:38:33 <glguy> instance MonadTrans MaybeT where lift m = MaybeT (liftM Just m)
13:38:39 <bd_> toMaybeT = MaybeT . return
13:38:44 <bd_> sjanssen: oh, hm
13:38:59 <bd_> sjanssen: mfix? >.>
13:40:19 <tibbe> bd_, no liftMaybeT or something?
13:40:28 <tibbe> ie is there some idiomatic naming for these things
13:40:32 <bd_> tibbe: You're writing the monad yourself, you can make one :)
13:40:51 <bd_> I'm not sure if there's an idiomatic naming though
13:41:08 <bd_> toMonad (Just x) = return x; toMonad Nothing = fail "got nothing" perhaps
13:41:18 <sjanssen> you want the name of Maybe a -> MaybeT m a?
13:41:27 <tibbe> bd_, oh MaybeT has a lift
13:41:41 <bd_> tibbe: lift :: m a -> MaybeT m a
13:41:45 <bd_> Well, with Monad m =>
13:41:45 <glguy> lift :: m a -> MaybeT m a
13:42:17 <sjanssen> @type maybe (fail "Nothing") return
13:42:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
13:42:38 <bd_> returnMaybe?
13:42:46 <bd_> maybeReturn?
13:42:58 <sjanssen> maybe mzero return -- yet shorter
13:43:10 <bd_> sjanssen: That introduces a MonadPlus constraint
13:43:11 <fasta> IIRC, the hash table implementation in Java only requires the user to specify an equality function. Assuming that Haskell is "powerful", why do I need to specify more than an equality function in Data.HashTable?
13:43:27 <bd_> fasta: the hash table implementation in Java requires both equality and hashing
13:43:35 <bd_> Object.equals() and Object.hashCode()
13:43:39 <fasta> bd_: Ah, right
13:43:48 <fasta> bd_: Ok, I remember again.
13:43:52 <sjanssen> fasta: because Java has a hackish default method for hashing
13:44:05 <sjanssen> that relies on reference equality
13:44:15 <fasta> sjanssen: right, but what's hackish about that?
13:44:34 <sjanssen> I think reference equality is hackish in general
13:44:48 <fasta> sjanssen: The Haskell implemenentation also knows about addresses at some point.
13:44:52 <sjanssen> especially in a language like Haskell
13:45:12 <bd_> fasta: addresses change :)
13:45:18 <augustss> exactly
13:45:22 <sjanssen> do you really want "let x = 1 in do insert x; insert x" and "do insert 1; insert 1" to have different behavior?
13:45:23 <fasta> bd_: ah, ok
13:45:30 <fasta> bd_: GC implementations...
13:45:32 <bd_> fasta: two references which have different addresses at one point... may point to the same location after a major GC
13:45:50 <bd_> or even a minor one, maybe
13:46:09 <sjanssen> or the behavior might even change if you use -O
13:46:14 <fasta> bd_: one could argue that the GC shouldn't move hash tables, then.
13:46:31 <sjanssen> or if you compile with -threaded and use multiple threads
13:46:42 <bd_> fasta: That sounds like a flawed argument :)
13:46:56 <hpaste>  tibbe annotated "Combining MaybeT and IO" with "Updated retrieve" at http://hpaste.org/507#a2
13:47:02 <augustss> fasta: it's the objects that must not move
13:47:16 <fasta> augustss: right
13:47:17 <tibbe> how do I return Nothing for example? ^^
13:47:20 <fasta> augustss: that's what I meant
13:47:41 <fasta> augustss: In the same way that some people mean 343 when they say 892 ;)
13:47:48 <bd_> tibbe: mzero
13:47:55 <bd_> tibbe: I prefer guard though
13:47:56 <augustss> fasta: but doing anything with addresses is just nasty
13:48:06 <bd_> guard True = return (); guard False = mzero -- in Control.Monad
13:49:10 <tibbe> bd_, ok, but if I want to return Just ...
13:49:24 <tibbe> liftIO $ return $ ... ?
13:49:30 <bd_> tibbe: no, just return
13:49:30 <augustss> fasta: e.g., how would you guarantee that two things that are == will have the same hash code?
13:50:49 <hpaste>  tibbe annotated "Combining MaybeT and IO" with "Type error" at http://hpaste.org/507#a3
13:51:17 <fasta> augustss: Java can do it, so there must be some way, I suppose.
13:51:19 <tibbe> oh parsePort is wrong but I fixed that
13:51:32 <sjanssen> fasta: no, Java doesn't do it
13:51:49 <augustss> fasta: but Java hashing is based on identity, not equality
13:51:52 <cjs> Java can't do it.
13:52:14 <fasta> augustss: well, the "equality" is the comparison of addresses.
13:52:20 <sjanssen> augustss: I suppose you could do hash consing on a global scale :)
13:52:41 <augustss> fasta: which is not even close to what equality should be :)
13:52:48 <fasta> augustss: sure
13:52:50 <augustss> sjanssen: possibly
13:52:53 <sjanssen> does Java use .equals() or == in it's hashtable
13:53:02 <bd_> .equals()
13:53:16 <bd_> but the default implementation of .equals() uses ==
13:53:29 <tibbe> bd_, I still get a type error: http://hpaste.org/507#a3
13:53:43 <cjs> Funny, but I'm an old Java guy who was just explaining last night to my business partner how cool `Eq' is, and how Haskell avoid so much unit testing on just that thing.
13:54:23 <fasta> Thanks, for rectifying some wrong beliefs.
13:54:31 <bd_> tibbe: lift doesn't convert from Maybe to maybeT
13:54:53 <bd_> tibbe: also, don't return Nothing, use mzero (though I'm not sure returning Nothing makes sense here...)
13:55:11 <bd_> tibbe: maybeReturn = maybe mzero return <-- use this function instead of lift there
13:56:14 <cjs> fasta: One thing that Ruby (which is what I'm mostly using currently) and Java and so on do, but in a hard way, is make you start to think about just what "equality" should be.
13:56:47 <tibbe> bd_, I'm going to return Just something later but I want to make the types work out first
13:57:03 <allbery_b> ?
13:57:04 <tibbe> bd_, what does lift convert to in all the other cases I use it?
13:57:21 <bd_> tibbe: return Just will result in your final function being IO (Maybe (Maybe a)) ...
13:57:22 <allbery_b> in Maybe (or MaybeT) return is Just
13:57:27 <tibbe> bd_, lift = MaybeT . liftM return
13:57:40 <tibbe> bd_, that's a Maybe to much
13:57:42 <bd_> tibbe: lift is IO a -> MaybeT IO a
13:58:04 <bd_> tibbe: yes, use mzero to return Nothing, or just return a to return a Just
13:59:42 <pejo> cjs, equality is a hard problem.
14:00:19 <bd_> maybe there should be a class Eq a => Hashable a where hashCode :: a -> Int ...
14:00:41 <bd_> though I guess hashtables aren't used often enough to really justify that
14:00:48 <cjs> Yeah.
14:01:48 <_Stinger_> and you lock yourself into one hash function
14:03:13 <augustss> bd_: I thought we used to have a class Hashable
14:03:45 <cjs> Wouldn't that be something more like class Hashable?
14:03:48 <augustss> Or maybe it was only in hbc :)
14:04:44 <hpaste>  tibbe annotated "Combining MaybeT and IO" with "Type error, bd_" at http://hpaste.org/507#a4
14:04:52 <cjs> Hmmm. Maybe that wouldn't work so well after all....
14:05:28 <tibbe> still type error
14:06:30 <hpaste>  bd_ annotated "Combining MaybeT and IO" with "try this, tibbe" at http://hpaste.org/507#a5
14:14:55 <RemiTurk> goeienavond
14:15:40 <roconnor> > log 10
14:15:42 <lambdabot>  2.302585092994046
14:15:55 <roconnor> > log 10000
14:15:57 <lambdabot>  9.210340371976184
14:16:25 <roconnor> exp(10)
14:16:28 <roconnor> > exp(10)
14:16:30 <lambdabot>  22026.465794806718
14:17:08 <augustss> > exp (10 :+ 1)
14:17:10 <lambdabot>  11900.950259059777 :+ 18534.631864193456
14:19:01 <roconnor> @check \a b c -> abs(a**(b*c)  - (a**b)**c) < 10
14:19:03 <lambdabot>  Add a type signature
14:19:31 <roconnor> @type abs
14:19:33 <lambdabot> forall a. (Num a) => a -> a
14:19:42 <roconnor> @check \a b c -> abs(a**(b*c)  - (a**b)**c)::Complex < 10
14:19:42 <lambdabot>  Parse error
14:19:48 <roconnor> @check \a b c -> (abs(a**(b*c)  - (a**b)**c)::Complex) < 10
14:19:49 <lambdabot>      `Complex' is not applied to enough type arguments     Expected kind `?',...
14:19:55 <roconnor> @check \a b c -> (abs(a**(b*c)  - (a**b)**c)::Complex Double) < 10
14:19:56 <lambdabot>        add an instance declaration for (Arbitrary (Complex Double))     In th...
14:19:56 <tibbe> @hoogle PortID
14:19:57 <lambdabot> Network.PortID :: data PortID
14:20:10 <tibbe> how do I get an PortID from an Int?
14:20:25 <Saulzar> Hmm, wouldn't it be easier to rewrite the various sub parts in terms of Monad, eg. parsePort ... = mzero, ... = return Foo?
14:21:08 <tibbe> hmm?
14:21:40 <augustss> No arbitrary for Complex, eh?  feeble!
14:21:55 <xerox> YEah :-(
14:22:09 <roconnor> should be fixable
14:22:12 <Saulzar> That is,  parsePort :: Monad m => String -> m Port,  instead of String -> Maybe Port
14:22:22 <cjs>  /brick aguustss
14:23:02 <tibbe> Saulzar, and use fail?
14:23:09 <tibbe> or MonadZero m =>
14:23:29 <Saulzar> yeah
14:23:38 <tibbe> but I can only rewrite parsePort since the others are library functions, otherwise I have to wrap them all
14:23:47 <Saulzar> Ah right
14:24:04 <augustss> cjs: your brick missed ;)
14:25:02 <tibbe> how difficult can it be to use connectTo?
14:25:06 <tibbe> @type connectTo
14:25:08 <lambdabot> Not in scope: `connectTo'
14:25:13 <tibbe> @hoggle connectTo
14:25:14 <lambdabot> Network.connectTo :: HostName -> PortID -> IO Handle
14:25:14 <lambdabot> Network.CGI.connectToCGIScript :: String -> PortID -> IO ()
14:25:32 <tibbe> how do I get a PortID
14:27:07 <fasta> Is Data.HashTable a genuine hash table (that is does lookup etc, take O(1) amortized over n operations)?
14:28:28 <sjanssen> fasta: I believe so
14:28:36 <augustss> if it's not, it's a bug
14:28:50 <sjanssen> however, I have heard that Data.HashTable is plagued with performance problems
14:29:10 <augustss> but Data.HashTable has a poor API
14:29:44 <augustss> sjanssen: yes, I think so.  I never use it.  It's all icky IO anyway.
14:29:48 <sjanssen> fasta: so bad that you might be better off with a Data.Map or IntMap in certain cases
14:30:32 <mwc> maybe I should try rewriting it with an ST interface, and a pure one for lookup
14:30:38 <mwc> might be a good weekend project.
14:31:27 <sjanssen> I know edwardk attempted to write a polymorphic hashtable that works in several monads
14:31:27 <RemiTurk> mwc: you should try to make it work for both ST and IO then I think. (Possibly based on bulat's new array+ref library?)
14:31:29 <augustss> mwc: good idea!
14:31:32 <sjanssen> I don't know if he finished
14:31:54 <sjanssen> if you write the ST version, you get IO practically for free with stToIO
14:32:07 <RemiTurk> the polymorphic version used to ( ? ) have the problem that GHC refused to specialize the (ST s) version (it didn't like the extra s)
14:32:09 <augustss> Too many people use IO when ST would do
14:32:26 <SamB> augustss: probably because ST is so nastily typed
14:32:40 <RemiTurk> and too many people use IO when ST + stToIO would do
14:32:57 <sjanssen> SamB: aye, like the runSTUArray issue
14:33:13 <augustss> SamB: well, ST is typed so you can keep track of what you are doing :)
14:33:26 <SamB> yes, but the compilers are all idiots
14:33:35 <SamB> when it comes to ST's typing
14:34:01 <augustss> SamB: do you have a (sound) way of improving it?
14:34:03 <cjs> Oh, yeah, not like us  programmers!
14:35:09 <RemiTurk> SamB: are you talking about runST $ ?
14:35:46 <RemiTurk> SamB: because SPJ "finally caved in" and made GHC HEAD accept that
14:36:00 <sjanssen> RemiTurk: there are worse issues
14:36:02 <mwc> What's Bulat's homepage? Trying to find that array+ref lib
14:36:14 <SamB> RemiTurk: did he write a paper about how that works?
14:36:26 <SamB> because, if not, I still say the typing is bad.
14:36:27 <sjanssen> for example, you can't use runSTUArray polymorphically
14:36:38 <sjanssen> mwc: I think it's on haskell.org
14:36:48 <RemiTurk> SamB: It's the "Add left-to-right impredicative instantiation" patch. No paperse (yet) AFAIK
14:36:54 <sjanssen> @google site:haskell.org arrayref
14:36:56 <lambdabot> http://www.haskell.org/haskellwiki/Library/ArrayRef
14:36:56 <lambdabot> Title: Library/ArrayRef - HaskellWiki
14:37:06 <SamB> sounds very primitive
14:37:22 <mwc> Ah, found it myself :)
14:38:13 <RemiTurk> sjanssen: can you explain the runSTUArray one?
14:39:31 <glguy> I want to meet the person that made the installer for VS2005 SP1 so that I can laugh hysterically at him
14:40:02 <sjanssen> RemiTurk: say you want to write the function "f x = runSTUArray (newArray (0, 10) x)"
14:40:07 <fasta> glguy: I installed the latest VS2005 and had a similar experience.
14:40:22 <augustss> Unboxed data is a second class citizen in Haskell in general :(
14:40:58 <sjanssen> RemiTurk: try to write a type signature for that function such that x can be any unboxable value
14:41:19 <JohnnyL> how do I trace a function?
14:41:30 <allbery_b> Debug.Trace.trace?
14:41:32 <sjanssen> get out a piece of then paper and a pencil . . .
14:41:35 <augustss> JohnnyL: Debug.Trace.trace?
14:41:36 <sjanssen> s/then/thin
14:41:51 <sjanssen> I even fail at the lame jokes
14:42:00 <allbery_b> there's also hat, but sadly it's a bit of a toy currently
14:42:05 <glguy> fasta: someone with a law degree should find a way to sue him and require that he put that he was the responsible person on his resume
14:42:33 <fasta> glguy: I was amazed that the installer wasn't completely perfect.
14:42:42 <fasta> glguy: They have _700_ people working on it.
14:42:48 <RemiTurk> sjanssen: thanks. I see. But isn't that (will that not be... ;)) solved by ArrayRef?
14:42:50 <tibbe> @paste
14:42:50 <tibbe> lambdabot?
14:42:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:42:58 <allbery_b> never read The Mythical Man-Month, have you?
14:43:01 <glguy> fasta: not using 4 gigs of HD would have been enough for me
14:43:02 <JohnnyL> augustss, ok, how do I implement that?
14:43:03 <fasta> glguy: Their goal is to spread this stuff like the plague.
14:43:04 <RemiTurk> (with its Unboxed typeclass)
14:43:07 <glguy> or needing 4 hours to install
14:43:34 <glguy> I could have gone without it crashing at the end too
14:43:37 <fasta> glguy: The installer requires a restart when there's too little diskspace at one point during the installation.
14:43:38 <sjanssen> RemiTurk: I'm not sure
14:43:59 <hpaste>  (anonymous) pasted "Type errors" at http://hpaste.org/508
14:44:08 <augustss> JohnnyL: foo x = trace "here we are in foo" $ x + 5
14:44:09 <tibbe> that was me
14:44:12 <sjanssen> RemiTurk: the problem is the instance for MArray mentioning the 's' parameter to ST
14:44:25 * glguy considers deleting all (anonymous) and (no title) pastes after 1 day
14:44:28 <tibbe> what's the correct way of using IO a actions in a monad transformer?
14:44:30 <fasta> mwc: I would be happy if you implemented it using ST.
14:44:43 <fasta> mwc: it would mean I could throw out IO out of my monad.
14:44:53 <RemiTurk> sjanssen: "Unboxed arrays now can be used in polymorphic functions, they are defined for every element type that belongs to the classes Unboxed and HasDefaultValue (again, look at http://www.haskell.org/pipermail/haskell-cafe/2004-July/006400.html). You can add new instances to these classes" (from http://haskell.org/haskellwiki/Library/ArrayRef#Reimplemented_Arrays_library)
14:44:55 <lambdabot> http://tinyurl.com/2b6zs7
14:45:07 <fasta> allbery_b: I did read it.
14:45:24 <RemiTurk> although I'm not sure whether that also means you can do that "across runST"
14:46:00 <mwc> I like the look of this lib by bulat
14:46:20 <mwc> I make a note to use this for something
14:46:28 * RemiTurk compiles ArrayRef
14:46:31 <fasta> mwc: if he didn't change it, it doesn't compile.
14:46:56 <fasta> mwc: otherwise, I agree
14:47:12 <RemiTurk> sjanssen: I'm the Remii from this afternoon, btw. No idea why xchat decided that Remii was a better name
14:47:23 <mahogny> 700 people working on an installer? I am impressed they managed to release something. the administrative overhead got to be huge
14:47:34 <hpaste>  JohnnyL pasted "quicksort trace" at http://hpaste.org/509
14:47:36 <fasta> mahogny: not on the installer, but on Visual Studio
14:47:40 <mahogny> phew
14:47:41 <hpaste>  JohnnyL pasted "quicksort trace" at http://hpaste.org/510
14:47:48 <glguy> they had an intern do the installer
14:47:59 <glguy> a kind of practical joke on all the devs
14:48:07 <mahogny> hm :)
14:48:12 <fasta> mahogny: they did work two years with >20 people on the start menu of Vista, so I have read.
14:48:35 <mahogny> well. that explains why it's so unusable :P
14:48:37 <fasta> It's more like Mythical Horror, if you read those websites.
14:48:58 <JohnnyL> augustuss, please see the trace
14:49:05 <mahogny> where the heck did you pick this up?
14:50:10 <hpaste>  augustss annotated "quicksort trace" with "Some trace" at http://hpaste.org/510#a1
14:50:55 <fasta> mahogny: http://moishelettvin.blogspot.com/2006/11/windows-shutdown-crapfest.html
14:50:59 <lambdabot> Title: moblog: The Windows Shutdown crapfest, http://tinyurl.com/y2g6ye
14:51:16 <mahogny> thanks
14:51:23 <hpaste>  augustss annotated "quicksort trace" with "More trace" at http://hpaste.org/510#a2
14:51:29 <titus> don't use it then
14:53:43 <mwc> Ahahahahahah! Bulat hit me with a tarbomb!
14:55:31 <sjanssen> man down!
14:56:23 <augustss> tarbomb on the starboard bow!
14:57:48 <JohnnyL> augustss, thanks alot!
14:58:18 <glguy> ?where zlib
14:58:18 <lambdabot> darcs get http://haskell.org/~duncan/zlib
14:58:32 <dcoutts> it's also on hackage
14:58:38 <dcoutts> which has tarballs
14:58:50 <glguy> I don't mind from source
14:58:54 <sjanssen> I wish Bulat would put ArrayRef in darcs
14:58:55 <glguy> I've installed everything else from source
14:59:18 <augustss> JohnnyL: just remember, trace is only for debugging
15:04:23 <dons> ?users
15:04:23 <lambdabot> Maximum users seen in #haskell: 328, currently: 300 (91.5%), active: 43 (14.3%)
15:06:29 <mwc> sjanssen: I was just looking around for it myself. Too bad eh?
15:06:44 <Pseudonym> The Monad.Reader is so good we should start a Haskell podcast.
15:06:53 <Pseudonym> We could call it Radio Free Theorem.
15:07:01 <sjanssen> mwc: yeah, the ideas behind it are great but it fails in execution
15:07:24 <sjanssen> for example, I'd like to try only the syntax sugar without using Bulat's reimplementation of Data.Array.*
15:09:10 <augustss> Pseudonym: someone reading aloud from the Monad Reader?
15:09:20 <bd_> ArrayRef?
15:11:00 <Pseudonym> Maybe.
15:11:03 <Pseudonym> Oh, I've just noticed something.
15:11:08 <Pseudonym> http://haskell.org/onlinereport/list.html
15:11:09 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
15:11:19 <Pseudonym> The standard doesn't declare the fixity/precedence for (!!) or (++).
15:11:46 <Pseudonym> Oh, it's in PreludeList.
15:11:49 <Pseudonym> Never mind!
15:12:32 <sjanssen> @google arrayref site:haskell.org
15:12:34 <lambdabot> http://www.haskell.org/haskellwiki/Library/ArrayRef
15:12:35 <lambdabot> Title: Library/ArrayRef - HaskellWiki
15:12:39 <sjanssen> bd_:^^^
15:14:02 * RemiTurk fixes all the GHC 6.4 -> 6.6 type-annotation breakage in ArrayRef
15:14:32 <bd_> sjanssen: oh, looks nice :)
15:16:08 * edwardk waves hello.
15:16:48 <sjanssen> hey edwardk
15:17:02 * Lemmih waves g'night.
15:17:17 <sjanssen> you were working on a poly-monadic hash table at some point, right?
15:17:25 <RemiTurk> good evening & good night
15:24:54 <dcoutts> @seen aking
15:24:54 <lambdabot> aking is in #gentoo-haskell and #haskell. I don't know when aking last spoke.
15:25:16 <tibbe> what's currently the best available HTTP lib?
15:25:59 <siti> curl?
15:26:27 <dcoutts> tibbe, depends on your requirements I think
15:26:59 <dcoutts> not sure if the HAppS one is available yet as a separate lib
15:27:33 <tibbe> dcoutts, just simple page fetches
15:27:43 <tibbe> siti, for haskell
15:27:44 <siti> wget ;)
15:27:46 <dcoutts> tibbe, try the standard one
15:27:47 <siti> ok
15:27:53 <tibbe> dcoutts, ok, thanks
15:29:48 <jjinux> Cale here?
15:30:02 <dibblego> [Cale] idle 06:49:17
15:30:59 <jjinux> Silly me, I don't spend a lot of time on IRC.  Thanks.
15:43:46 * edwinb rejoices, for I may get to Fun in the Afternoon after all
15:49:58 <dcoutts> edwinb, see you there
15:50:20 <edwinb> possibly ;)
15:53:35 <RemiTurk> I'm not sure it works (it works at home, but fails with some weird error at my university) but for now: darcs get http://www.science.uva.nl/~rturk/ArrayRef
15:53:38 <lambdabot> Title: Index of /~rturk/ArrayRef
15:53:57 <RemiTurk> did I ask lambdabot anything?
15:54:26 <dons> is there a testsuite?
15:56:00 <RemiTurk> there isn't. although there are a few examples. really the only thing I did is darcsify + ghc6.6ing
15:57:01 <dons> ok. cool
15:57:55 <ddarius> RemiTurk: Apparently lambdabot grew the ability to read webpage titles of any links given in chat while I was away.
15:59:03 <RemiTurk> ddarius: I wonder how long it'll take before it grows the ability to guess our types before we show it our code
15:59:35 <RemiTurk> does this error look familiar to anyone? (it's the one ArrayRef still gives me at my uni)Prelude> :m +Data.ArrayBZ.IO
15:59:35 <RemiTurk> module main:Data.ArrayBZ.IO is not loaded
16:00:23 <Saizan> have you tried :l ?
16:01:35 <RemiTurk> Saizan: I don't understand. I'm trying to load a module from an installed package. I can't :load those anyway, can I?
16:02:00 <Saizan> mmh no, don't think so
16:02:02 <dons> ddarius: a lot of patches have landed in the last 2 years, http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:02:03 <lambdabot> Title: lambdabot
16:02:15 <dons> some 1600
16:08:28 <ddarius> There was a lambdabot on cyberarmy... and where is a web-based interface to lambdabot?
16:09:05 <dons> ?where lambdaweb
16:09:05 <lambdabot> http://lambdabot.codersbase.com
16:11:12 <slava> so 'currying' is the isomorphism between Hom(AxB,C) and Hom(A,Hom(B,C)), whereas a 'section' is a partial application?
16:11:24 <dons> heya slava
16:11:36 <slava> if so, i'm quite embarrased because i've been using the term 'currying' incorrectly for several years
16:12:10 <dons> those definitions look right to me.
16:12:12 <dons> :t curry
16:12:14 <dons> :t uncurry
16:12:14 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:12:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:12:22 * slava nods
16:12:32 <Philippa> Slava: a 'section' is a partially applied operator
16:12:36 <Saizan> a section is syntactic sugar for the partial application of operators
16:12:36 <dons> :t (+1)
16:12:39 <lambdabot> forall a. (Num a) => a -> a
16:12:42 <dons> :t (+)
16:12:45 <lambdabot> forall a. (Num a) => a -> a -> a
16:12:46 <dons> :t (+) 1
16:12:47 <slava> is there one word which means 'partial application'?
16:12:49 <lambdabot> forall t. (Num t) => t -> t
16:12:54 <slava> scheme calls this 'cut'
16:13:01 <Philippa> 'sectioned' is something else rather different, at least in the UK
16:13:04 <slava> basically i need to rename my curry function to something else :)
16:13:23 <dons> apply ?
16:13:23 <Saizan> pepper?
16:13:34 <dons>  (+) `ap` 1
16:13:35 <Philippa> we're possibly not the people to ask, we curry by default so we don't have an explicit notion of partial application
16:13:56 <slava> well, i'll give it some thought. thanks for the clarifications
16:13:57 <Pseudonym> In category theory, a "section" is something else again.
16:14:11 <dons> slava: did you ever get darcs up on the arm machine?
16:14:16 <Pseudonym> If r . s = id, then s is a section.
16:14:44 <slava> Pseudonym: yes, i'm familiar with this usage from algebraic topology
16:15:00 <slava> dons: i broked the arm machine before i could. now that its reflashed i'm going to try to set up a development environment again
16:15:10 <dons> yikes. sounds fun :)
16:15:21 <RemiTurk> sjanssen, you still there?
16:17:21 <RemiTurk> sjanssen: \x -> runSTUArray (newArray (0, 10) x) :: (Num t, Ix t, HasDefaultValue e, Unboxed e) => e -> UArray t e
16:18:59 <allbery_b> <slava> basically i need to rename my curry function to something else :)
16:19:06 <allbery_b> curryPowder :)
16:19:20 <dons> spice ?
16:19:26 <slava> chili ?
16:19:27 <Botje> yellowStuff
16:19:36 <dons> garammasala
16:19:42 <dons> I like this idea though allbery_b :-)
16:19:48 <dons> we need a whole suite of such operators
16:19:53 <ddarius> caribbeanJerk
16:19:54 <dons> maybe these can be useful names for the set of
16:19:54 <allbery_b> (which, of course, doesn't contain curry :)
16:19:56 <dons> :t (.) . (.)
16:19:57 <dons> and
16:19:58 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:20:00 <tibbe_> when giving package dependencies in cabal, do I have to give the transative closure?
16:20:02 <dons> :t (.) . (.)  (.)
16:20:04 <lambdabot> forall a b c a1 a2. (a2 -> b -> c) -> (a -> a2) -> a -> (a1 -> b) -> a1 -> c
16:20:08 <tibbe_> i.e. both network & http or just http
16:20:11 <Botje> dons: the first one is definitely the "boobs" combinator.
16:20:26 <dons> :t (.) $ (.)
16:20:28 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
16:20:47 <slava> dons: you'd make a good diagram chaser :)
16:21:36 <dons> heh
16:22:20 <dons> hey slava, how many loc do you think a core Factor implementation would take in something like haskell?
16:22:29 * dons ponders a tutorial
16:22:30 <slava> perhaps 50, 100?
16:22:36 <dons> mm. tasty
16:22:38 <slava> just a simple stack evaluator?
16:22:50 <dons> yeah, and enough of the prelude to do some useful things
16:23:24 <slava> you might want to ask doublec in #concatenative. he's working on a factor to javascript compiler.
16:23:34 <slava> i have to run now, later
16:23:45 <dons> ciao. i might see if I can whip this up over the weekend
16:30:23 <jre2> does anyone know a good resource on doing a (quite) large simulation with user interaction (almost like a MUD)?  I've been considering erlang, as the actor model fits nicely, but maybe one of the concurrency haskell libraries would give it a run for its money?
16:32:49 <xic> you mean like a server?
16:34:05 <dons> jre2: you could certainly use Control.Concurrent.Chan to do message passing concurrency, or something else from Control.Concurrent if you wanted a different concurrency model
16:34:15 <dons> jre2: if you could elaborate on the design a bit?
16:34:20 <jre2> well, one that would support 50,000+ objects running their own individual AIs...calling it just a server sounds demeaning..
16:34:54 <dons> so 50k lightweight threads?
16:35:05 <xic> jre2: it would be interesting to see if YAMPA would work with this
16:35:09 <dons> or are you thinking a cluster of machines and processors?
16:36:14 <SamB> probably erlang...
16:36:47 <jre2> dons: ideally as many entities as the system could handle. distributed across multiple machines would be a plus (erlang gets this nearly for free), but not completely neccessary
16:37:25 <dufflebunk> Yay, someone finally explained monads in a way that I understood!
16:37:36 <dons> right. so I think a reasonabe smp machine, using haskell threads could just about do that. Or you might want to consider the user-land threads library (over epoll)
16:37:45 <dons> they've managed up to 10M threads
16:37:57 <dons> however, 50k threads doing a lot of computation: not trivial
16:38:03 <jcreigh> dufflebunk: cool. What article/tutorial/whatever are you refering to, specifically?
16:38:15 <dufflebunk> jcreigh: http://www.alpheccar.org/en/posts/show/67
16:38:16 <lambdabot> Title: Haskell Study Plan
16:38:43 <jre2> dons: of course, most of them are doing quite trivial computation
16:38:59 <dons> ah ok. so just normal haskell lightweight threads might handle it
16:39:09 <dons> and then move on to an smp machine if you need more grunt
16:39:13 <jre2> good to hear
16:39:45 <dons> the kind of lightweight thread stuff on a single (maybe smp) machine, that we see on the shootout, haskell and erlang are quite comparable
16:39:58 <dons> once you move onto separate processes on separate machines, erlang has the advantage
16:40:26 <xic> what's the point of threads if you have only one cpu? why not just run them one after the other in a loop?
16:40:30 <dons> there are other consideratoins like fault tolerance, and state serialisation. though I'd not be too afraid to tackle this in haskell now.
16:40:39 <dons> xic, as an abstraction mechanism
16:40:52 <dons> one that just happens to scale nicely onto multiple cores
16:40:54 <xic> i think that yampa would act much better as an abstraction mechanism
16:41:02 <dons> possibly. its quite nice for some things
16:41:20 <dons> though mapping yampa streams onto smp threads, has that been done?
16:41:25 <dons> if not, why not!?
16:41:36 <xic> that sounds like a winning idea
16:41:56 <dons> i.e. frag. take frag, map the yampa-based game entities onto their own haskell thread
16:42:07 <dons> which then run on 'm' OS threads over 'k' real cores
16:42:16 <ptolomy> Does there need to be a Data.IntMap and a Data.Map? Is it possible to specialize transparently?
16:42:25 <xic> dons: it actually shouldn't be too hard to do
16:42:32 <dons> ptolomy: with associated types, yes.
16:42:35 <dons> xic, yeah, that's what I'm thinking.
16:42:41 <dons> the structure is already there
16:42:49 <dons> hmm, would make a good HW or ICfP paper ....
16:42:58 <dons> "Yampa in the age of concurrency"
16:43:30 <jre2> dons: right now I'm begining to prototype and fully flesh out the design in stackless python (not familiar/brave enough with haskell to attempt it just now) with the hopes to port it to something faster after it works; good to hear haskell can compete with erlang for this
16:43:58 <ptolomy> dons: So are they two separate modules because it is a cleaner interface that way, because nobody has gotten around to it, for backward compatibility, or other?
16:44:42 <dons> jre2, yeah, if you can do it in stackless python, then haskell shouldn't be a problem at all. haskell and erlang would both make great choices for this kind of project.
16:45:02 <dons> and they both should blow python out of the water for speed, http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
16:45:05 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
16:45:36 <jre2> well, do it vastly scaled down ;)
16:45:42 <dons> ptolomy: they're separate because someone wrote a specialised Map for Int keys, that means you can make some nice assumptions
16:45:55 <dons> but, we now have the type system rich enough to do associated representation types for particular types
16:46:06 <xic> Map should have been a type class
16:46:08 <dons> e.g. Map Int x can have an associated representation type, IntMap x
16:46:13 <dons> that would be used transparently
16:46:17 <ptolomy> Neato. :)
16:46:32 <dons> it'd make a nice library, actually
16:46:40 <dons> a new Data.Map that used specialised forms for a number of types
16:46:49 <tibbe_> @where libraries
16:46:50 <lambdabot> I know nothing about libraries.
16:46:53 <dons> and where those specialised forms were specfied using an associated type
16:46:56 <tibbe_> @where source
16:46:56 <lambdabot> I know nothing about source.
16:47:09 <sorear> sorry I'm late, inet outage :)
16:48:18 <dons> hey sorear
16:48:43 * ddarius didn't realize you could be late to an IRC channel... or at least the #haskell IRC channel.
16:49:58 <dons> sorear: so how are we going to change the world today?
16:50:54 <allbery_b> @brain -- :)
16:50:54 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
16:51:00 <jtokle> does getChanContents block on an empty Chan?
16:51:51 <jtokle> also, if a new value is put on the channel after the cal to getChanContents but before the result is evaluated, does it appear in the list?
16:52:51 <sjanssen> RemiTurk: re: runSTUArray, nice
16:54:21 <ddarius> @help brain
16:54:21 <lambdabot> brain. Pinky and the Brain
16:55:52 <RemiTurk> sjanssen: indeed, I was quite happy to finally see it work after all the fixed type-annotations ;)
16:56:33 <dons> jtokle: yeah, the chan behaves like a lazy list
16:57:20 <dons> oh, i know how we're going to change the world! monadically!
16:57:44 <dons> newWorldOrder <- runWorld (do change the world) oldWorld
16:58:04 <RemiTurk> Is there any categorical concept called "Radi" or something similar?
16:58:06 <ihope> Wow!
16:58:19 <ddarius> @hoogle Int -> [a] -> [[a]]
16:58:20 <lambdabot> No matches, try a more general search
16:58:48 <sorear> dons: Jhc doesn't like parafins and tries to constant fold all of exp3_8
16:58:49 <tibbe_> where's the library source?
16:58:56 <Pseudonym> Linear types can change the world.
16:58:59 <sorear> @source Prelude
16:59:00 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
16:59:07 <sorear> ^^^ edit name appropriately
16:59:10 <Pseudonym> Monads can't change the world, but they can tell the world how to change itself.
16:59:14 <sorear> @source Data.List
16:59:14 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:59:19 <sorear> ^^^ example w/ .
16:59:26 <dons> sorear: so still trying to get the pidigits example to compile?
16:59:39 <ddarius> RemiTurk: The closest thing I can get is a right Kan extension usually written Ran
17:00:03 <RemiTurk> Ranically changing the world doesn't really do it, does it ;)
17:00:07 <sorear> dons: no, I gave up ... which is how I know about parafins and exp3_8
17:00:28 <sorear> I couldn't access the shootout w/o inet, so I used the yhc testsuite
17:00:30 <Pseudonym> BTW, I have a suggestion for a SoC project.
17:00:43 <Pseudonym> Might be tricky, though.
17:00:52 <sorear> which is called "nofib", so I hope it is a useful benchmark
17:01:02 <dons> Pseudonym: yeah?
17:01:08 <dons> sorear: yeah, nofib is pretty nice
17:01:20 <Pseudonym> dons: Add compiler support for implicit configuration to GHC.
17:01:30 <Pseudonym> Implicit configuration as in the Oleg paper.
17:01:33 <tibbe_> sorear, thanks
17:01:33 <dons> hmm. bit tricky for an undergrad :-)
17:01:39 <Pseudonym> Yeah, probably. :-)
17:01:53 <Pseudonym> Although.
17:02:11 <Pseudonym> Writing an industrial-strength module based on the Oleg et al paper might not be so hard.
17:02:18 <Pseudonym> Ignoring the GC problem.
17:02:29 <Pseudonym> Or ignoring the performance problem if you don't ignore the GC problem.
17:02:56 <Pseudonym> Get the interface working first, then someone can add it to GHC later.
17:03:18 <Pseudonym> Hmm.
17:03:22 <Pseudonym> Maybe that's too small a job,
17:08:44 <RemiTurk> it seems to be time to go sleep
17:08:50 <RemiTurk> it certainly is for me
17:08:53 <RemiTurk> good night everyone
17:09:19 <tibbe_> can network and network-2 coexist?
17:12:48 <sorear> what, no jyp patches?
17:13:38 <sorear> tibbe: cabal packages with different major versions can always coexist
17:13:55 <sorear> tibbe: that's the big thing that makes cabal superior to apt
17:14:13 <sorear> (minor, too)
17:14:26 <sorear> @users
17:14:26 <lambdabot> Maximum users seen in #haskell: 328, currently: 290 (88.4%), active: 38 (13.1%)
17:14:37 <malsyned> sorear: I'd say it's one of two - the other being that it cleanly supports installing user-specific packages without needing root privilege.
17:15:01 <tibbe> sorear, but when I try to build I get a message that network-2.0 is hidden
17:15:09 <sorear> malsyned: wholeheartedly agreed.  I forgot about that :)
17:15:31 <tibbe>     Could not find module `Network.URI':
17:15:31 <tibbe>       it is a member of package network-2.0, which is hidden
17:15:50 <sorear> tibbe: if your package authors idiotically left out the ... you may need to edit the cabal file
17:15:52 <malsyned> hey, how do I get lambdabot to give me the source of a function when it exists in a package other than the prelude?
17:16:01 <sorear> tibbe: but first try just reconfiguring
17:16:02 <malsyned> (like Control.Monad.State.get, for example)
17:16:07 <sorear> @src unsafePerformIO
17:16:07 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
17:16:14 <sorear> ^^^ is THAT in the prelude?
17:16:16 <sorear> :)
17:16:22 <Pseudonym> ?src get
17:16:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:16:31 <sorear> @src State get
17:16:31 <Pseudonym> ?src Control.Monad.State.get
17:16:31 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:16:31 <lambdabot> Source not found. My mind is going. I can feel it.
17:16:34 <tibbe> sorear, should I give the package version explicitly in the dependency then
17:16:53 <Pseudonym> lambdabot: You know, you could really stand to drop the attitude.
17:16:54 <sorear> tibbe: yes.  and make sure the newer package is actually installed :)
17:17:21 <malsyned> OK, so it's just that lambdabot doesn't have the source to get.
17:17:22 <sorear> tibbe: but first clrean and reconfigure the package that wants Network.URI
17:18:10 <Pseudonym> ?src shows
17:18:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:18:17 <Pseudonym> That _is_ in the Prelude.
17:18:20 <sorear> ?src Char shows
17:18:20 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:18:23 <sorear> ?src Char showsPrec
17:18:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:18:24 <Pseudonym> But I think it doesn't like typeclass instances.
17:18:25 <tibbe> sorear, works, thanks
17:18:26 <sorear> ?src Char show
17:18:27 <lambdabot> Source not found. Wrong!  You cheating scum!
17:18:38 <malsyned> oh, that makes sense.
17:18:38 <Pseudonym> ?src show
17:18:38 <sorear> tibbe: which recommendation
17:18:39 <lambdabot> show x = shows x ""
17:18:46 <sorear> ?src shows
17:18:46 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:18:52 <sorear> ?2src showsPrec
17:18:52 <lambdabot> showsPrec _ x s = show x ++ s
17:19:04 <malsyned> Maybe you have to give it a context?
17:19:18 <Pseudonym> No, I think it's just not smart enough.
17:19:25 <malsyned> oh well.
17:19:34 <tibbe> sorear, explicit package verion, although I can't see why that is needed since the data type I use, URI, exists in both versions
17:19:36 <Pseudonym> lambdabot: Which makes the attitude pretty rich.
17:20:04 <tibbe> sorear, I think HTTP uses network-2 but the rest of my code only need 1.0
17:20:24 <tibbe> sorear, without the -2.0 it complains
17:21:45 <Stinger__> theres not an application operator with lower precedence than $ is there?
17:22:07 <sorear> )$(
17:22:29 <sorear> :)
17:23:00 <Pseudonym> $ deliberately has the lowest possible precedence.
17:23:19 <Pseudonym> Shared only by $! and `seq`
17:28:31 <ihope> )$(, eh? Fun.
17:28:41 <ihope> I take it ))$(( would be even lower.
17:32:58 <sorear> ihope: my source: http://en.wikipedia.org/wiki/Operator-precedence_parser#Alternatives_to_Dijkstra.27s_Algorithm
17:33:00 <lambdabot> http://tinyurl.com/28srjk
17:33:54 <ddarius> @type group
17:33:56 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
17:34:07 <sorear> > group "aabbcddde"
17:34:08 <lambdabot>  ["aa","bb","c","ddd","e"]
17:35:04 <bd_> > map head . group . sort . words $ "a bunch of words, some of which may be duplicated, such as words or a"
17:35:06 <lambdabot>  ["a","as","be","bunch","duplicated,","may","of","or","some","such","which","...
17:35:52 <sorear> snub ftw
17:37:05 <bd_> :t snub
17:37:08 <lambdabot> Not in scope: `snub'
17:37:17 <bd_> sort nub?
17:37:27 <sorear> yeh
17:37:36 <sorear> std name, nonstd func
17:38:23 <ddarius> > sort . nub $ "a bunch of words, some of which may be duplicated, such as words or a"
17:38:24 <lambdabot>  " ,abcdefhilmnoprstuwy"
17:38:35 <ddarius> > sort . nub . words $ "a bunch of words, some of which may be duplicated, such as words or a"
17:38:36 <lambdabot>  ["a","as","be","bunch","duplicated,","may","of","or","some","such","which","...
17:39:11 <bd_> :t nub
17:39:14 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:39:16 <bd_> oh
17:39:25 <bd_> sort . nub still O(n^2)
17:39:29 <sorear> > nub "Hello, World!!"
17:39:31 <lambdabot>  "Helo, Wrd!"
17:39:36 <ddarius> Anyways what I want is a function that takes a list and an Int a produces a list of list as of the given length (excepting the last list)
17:39:45 <sorear> bd_: yes.  that's why we have snub rather than just sort . nub
17:39:50 <sorear> snub is O(n log n)
17:39:57 <bd_> I know, I was responding to ddarius :)
17:40:11 <sorear> ddarius: std name --> chunks.  again, nonstd func :(
17:40:17 <lispy> we have snub? hmm...never notice that before
17:40:23 <lispy> :t snub
17:40:25 <lambdabot> Not in scope: `snub'
17:40:31 <ddarius> @type unfoldr
17:40:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:40:36 <lispy> ?hoogle snub
17:40:36 <lambdabot> No matches found
17:40:39 * sorear scrolls back
17:40:41 <sorear> <sorear> std name, nonstd func              [17:36]
17:40:41 <sorear>  
17:41:19 <lispy> where do you define snub?
17:42:26 <ddarius> > unfoldr (\x -> let (begin,end) = splitAt 3 in if not $ null begin then Just (begin,end) else Nothing) [1..20]
17:42:27 <lambdabot>  Couldn't match expected type `(t, t1)'
17:42:39 <sorear> :t mapAccumL
17:42:42 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:43:02 <ddarius> > unfoldr (\x -> let (begin,end) = splitAt 3 x in if not $ null begin then Just (begin,end) else Nothing) [1..20]
17:43:03 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
17:43:17 <sorear> @let snub = catMaybes . snd . mapAccumL (\st x -> if S.member x st then (st, Nothing) else (S.insert x st, Just st))
17:43:18 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:43:31 <sorear> > let snub = catMaybes . snd . mapAccumL (\st x -> if S.member x st then (st, Nothing) else (S.insert x st, Just st)) in snub "Hello, World!!"
17:43:31 <lambdabot>   Not in scope: `S.insert'
17:43:53 <sorear> > let snub = catMaybes . snd . mapAccumL (\st x -> if Data.Set.member x st then (st, Nothing) else (Data.Set.insert x st, Just st)) Data.Set.empty in snub "Hello, World!!"
17:43:54 <lambdabot>  [fromList "",fromList "H",fromList "He",fromList "Hel",fromList "Helo",fromL...
17:44:05 <sorear> > let snub = catMaybes . snd . mapAccumL (\st x -> if Data.Set.member x st then (st, Nothing) else (Data.Set.insert x st, Just x)) Data.Set.empty in snub "Hello, World!!"
17:44:07 <lambdabot>  "Helo, Wrd!"
17:44:15 <sorear> lispy: ^^^
17:44:34 <lispy> sorear: it seems like snub could be something along the lines of, concatMap head (group . sort)
17:44:52 <lispy> (with a suitable head function)
17:45:07 <sorear> no
17:45:08 <lispy> head' [] = []; head' xs = head xs
17:45:13 <MechaBlue> If I might beg a cup of advice?  I want to efficiently emulate a real-time system where multiple entities pass messages to each other.  Would STM be a good library to look at?
17:45:13 <sorear> > map head . group . sort $ "Hello, World!!"
17:45:15 <lambdabot>  " !,HWdelor"
17:45:23 <sorear> see, very different
17:45:25 <lispy> so what is the s then?
17:45:52 <sorear> MechaBlue: no
17:46:04 <sorear> MechaBlue: stm is intrinsically NONdeterministic
17:46:45 <sorear> MechaBlue: last time I faced a concurrency simulation problem (nethack clone), I hacked something up with ContT State
17:46:57 <sorear> (or maybe it was StateT Cont)
17:47:10 <lispy> you had a concurrency simulation in nethack?
17:47:29 <sorear> lispy: you mean the monsters take turns moving? :p
17:47:43 <MechaBlue> sorear: Thank you
17:48:10 <lispy> sorear: well, in angband (I know not exactly nethack) the person with the most energy moves first, and i don't know how they break the ties
17:49:02 <sorear> that's one way of implenting a concurrency simulation
17:49:14 <lispy> please tell, what was your way?
17:49:23 <sorear> but I thought a monad with 'yield' calls would be much more elegant
17:49:53 <lispy> how do you deal with the problem of two monsters trying to occupy the same space at the same time?
17:50:15 <lispy> they both try and only the first one gets it? so what does the second do? try again or just collides? fails?
17:50:35 <sorear> lispy: the scheduler serializes.  just like linux runs at most one process at a time.
17:51:10 <fnord123> in building gtk2hs, are there flags i need to give ghc 6.6 to happily compile Data.FiniteMap?
17:51:49 <sorear> "happily"
17:51:58 <siti> use the rc then it works
17:52:05 <sorear> you must not be trying to compile a recent version
17:52:18 <sorear> hint: if it's released, it's not recent :)
17:52:26 <siti> lol
17:52:32 <siti> http://haskell.org/gtk2hs/archives/2007/02/02/gtk2hs-0911-release-candidate-available-for-testing/
17:52:34 <lambdabot> Title: Gtk2Hs » Blog Archive » Gtk2Hs 0.9.11 release candidate available for testing, http://tinyurl.com/25otd7
17:52:38 <sorear> Data.FiniteMap has been obsolete for longer than I've been a haskeller
17:52:38 <siti> "works with GHC-6.6 and Gtk+ 2.10.x"
17:52:47 <ddarius> @google Poor Man's Concurrency Monad
17:52:50 <lambdabot> http://www.cs.chalmers.se/~koen/pubs/jfp99-monad.ps
17:52:56 <sorear> and missing from head for almost as long
17:54:08 <fnord123> i was using the one on the download page
17:54:29 * ddarius doesn't think Data.FiniteMap was in the libraries when he started programming in Haskell, but then the hierarchical libraries were not standard at that time either...
17:56:14 <dmead> hmm
17:56:30 <dmead> does anyone else agree with me that i/o in haskell is seriously overcomplicated?
17:56:37 <notsmack> dmead: no
17:56:38 <sorear> yes
17:56:45 <dmead> hehe
17:56:48 <sorear> I'm not one of them AT ALL
17:56:56 <dmead> ?
17:57:11 <notsmack> main = putStrLn "What's so complicated?"
17:57:16 <sorear> there are people who agree with you, so I said yes
17:57:25 <dmead> ah hehe
17:57:26 <dmead> yea
17:57:32 <sorear> even though I myself find haskell IO simple and easy
17:57:33 <dmead> i'm not talking about reallly simple shit
17:58:02 <fnord123> its as complicated as it needs to be imo
17:58:05 <dmead> having IO as part of the typing system needs work i think
17:58:46 <fnord123> having done io in other languages, it bloats horribly into huge monolithic grammar files
17:58:47 <dmead> I just don't understand why it's requires any effort at all =/
17:58:50 <encryptio> haskell i/o is a little odd compared to imperative languages, but it's not at all overcomplicated or wrong given haskell's features.
17:58:58 <sorear> IO isn't part of the type system.  aside from the fact that it's automatically in scope, the parser, renamer, optimizer, etc.  consider it just another library
17:59:22 <Philippa> dmead: it's a really, really useful thing to have it visible to the type system
17:59:38 <dmead> oh, i'm aware
17:59:49 <dmead> seems like there could be a better way to fit it in
18:00:03 <dmead> that doesn't require
18:00:04 <notsmack> dmead: for instance?
18:00:04 <dmead> like
18:00:08 <dmead> knowing what a monad is
18:00:08 <sorear> how does it "fit in"
18:00:12 <sorear> it's not magic
18:00:14 <encryptio> that's what i thought when i didn't know monads
18:00:20 <sorear> it's just another library
18:00:24 <dmead> hmm
18:00:35 <dmead> well, i'm just trying to be a bit pragmatic
18:00:35 <sorear> the type system doesn't know IO exists
18:00:52 <encryptio> sorear: it knows, it just doesn't care that it's any different
18:00:54 <dmead> like
18:01:04 <ddarius> dmead: There were IO systems before monadic IO.  It was chosen for a reason.
18:01:11 <dmead> if there was some exceptions made to the strict typing system
18:01:24 <dmead> where you could coerce IO blah to blah
18:01:27 <sorear> we have exceptions
18:01:32 <sorear> > fail "foo"
18:01:33 <lambdabot>   add an instance declaration for (Show (m a))
18:01:37 <sorear> > error "foo"
18:01:39 <lambdabot>  Exception: foo
18:01:42 <dmead> hmm
18:01:49 <sorear> oh, that's not what you meant ;)
18:01:53 <encryptio> lol.
18:01:56 <dmead> hehe yea
18:01:58 <ddarius> dmead: There's a reason you can't do that.  If you are having trouble getting IO code to type check you are misunderstanding how to use it.
18:02:18 <dmead> exactly my point
18:02:24 <allbery_b> there are ways to coerce IO a to a.  if you don't understand why things work the way they do, using those ways will only lead to massive pain
18:02:25 <sorear> IO in haskell is a very clever hack.
18:02:27 <dmead> one shouldn't have to go an extra mile to do i/o
18:02:28 <bd_> dmead: there's an exception. you really, really don't want to use it :)
18:02:50 <sorear> dmead: you have to go an extra inch to NOT use IO.  "return "
18:02:55 <allbery_b> really.  your programs will fail in exceedingly bizarre ways
18:02:57 <sorear> since main is automatically IO
18:03:03 <dmead> hmm
18:03:04 <ddarius> dmead: The type system is not getting in your way, if you did what you wanted to do you'd be doing something wrong.  The typechecker is actually helping by telling you that that is wrong.
18:03:50 <dmead> maybe i should come up with a concrete example of what i'm talking about
18:04:11 <beschmi> dmead: one should go an extra mile, that's the only reason why IO and easy to understand pure code is nicely separated
18:04:49 <dmead> hmm
18:05:17 <dmead> right
18:05:42 <emu> coercing IO a to a would break the whole point of it
18:06:18 <dmead> i'm just a bit frustrated at this point that good languages lack the "pragmatic" features which seem to be needed for wider acceptance
18:06:29 <dmead> thats exactly what i'd want to do
18:06:46 <encryptio> somehow i think "wider acceptance" doesn't matter much to haskellers
18:06:53 <gravity> Is IO really that hard to use though? It's hard to understand, but once you get it it's very practical to use it.
18:06:53 <emu> it would probably be a turnoff
18:07:03 <emu> it's not hard to use at all
18:07:16 <sorear> haskell's IO system is very beneficial
18:07:17 <bd_> If you could turn IO a to a safely... STM wouldn't be possible :)
18:07:18 <ddarius> dmead: What you have said so far suggest more that you don't understand how Haskell IO works not that it isn't "pragmatic".
18:07:27 <jcreigh> :t unsafePerformIO
18:07:30 <lambdabot> forall a. IO a -> a
18:07:33 <sorear> it prevents us from growing a large user community
18:07:42 <jcreigh> you *can* do it...it's just a bad idea 99% of the time.
18:07:42 <dmead> haha sorear
18:07:47 <sorear> lots of users BAD
18:07:52 <emu> dmead: Haskell IO is the way it is not because Haskellers like to torture newbies but because it preserves the essential properties that make Haskell good and worthwhile in the first place
18:07:56 <sorear> look at Java, C, ...
18:08:00 <bd_> @remember sorear haskell's IO system is very beneficial - it prevents us from growing a large user community
18:08:00 <lambdabot> Done.
18:08:03 <dmead> jcreigh: maybe thats what i'm thinking of ;o
18:08:11 <emu> though, torturing newbies does have some appeal hmm..
18:08:17 <dmead> =P
18:08:21 * emu rubs his hands wickedly
18:08:49 <gravity> emu: I think learning the ins and outs of haskell is probably tortuous enough :-)
18:08:51 <fnord123> c++ programmers are so happy that java and c# took all the braindead NBL programmers with them
18:09:07 <jcreigh> dmead: The backdoor is there, in case you need it for some strange reason (FFI is one example). But they call it "unsafe" for a reason.
18:09:08 <fnord123> since then C++ community has been more useful
18:09:08 <beschmi> sorear: yeah, then you have lots of libraries, but all the APIs  look like java (see ocaml)
18:09:26 <dmead> yea
18:09:29 <dmead> if you use boost
18:09:32 <jcreigh> NBL?
18:09:33 <dmead> it's nearly identical to java
18:09:36 * sorear doesn't know what NBL means ... and is probably glad
18:09:41 <dmead> Next Big language
18:09:43 <encryptio> i'm going to try to teach a friend of mine haskell. she's going to depsise it for a month or four, i'm sure. hopefully she'll get over the hey-this-isn't-C-like monads and like it
18:10:06 <jcreigh> Is that a Yegge-ism?
18:10:14 <dmead> i think so
18:10:17 <dmead> it was on a big blog
18:10:20 <dmead> forget which one
18:10:26 <dmead> NBL, etc
18:10:27 <fnord123> i dont even read yegge. he's a fucking moron
18:10:31 <gravity> Yeah, it was Yegge
18:10:55 <dmead> i thought he made some decent points in his NBL article
18:11:52 <encryptio> experienced haskellers: what do you think of ocaml?
18:12:01 <fnord123> i cant read yegge without falling asleep or getting angry at how stupid his writing style is... the gist i got from the reddit thread was that yegge had no interesting points
18:12:37 <mbishop> encryptio: I'm no experienced haskeller by any means, but I like ocaml
18:13:17 * beschmi would kill for Caml with typeclasses
18:13:20 <encryptio> where do you think its strengths lie as opposed to haskell and the C family?
18:13:23 <emu> encryptio: +. vs + kills me
18:13:25 <beschmi> i never liked the object system
18:13:31 <fnord123> good night and thanks for the gtk2hs tips
18:14:03 <fnord123> .vs?
18:14:12 <emu> 1.0 +. 2.0
18:14:16 * edwardk waves hello
18:14:28 <ihope> Typeclasses are nice.
18:14:36 <ihope> When are they useful?
18:14:39 <beschmi> emu: and print_string, print_int is painful too
18:14:42 <emu> yep
18:15:01 <fnord123> whats .vs?
18:15:05 <emu> type-classes are a necessity
18:15:15 <ihope> Sure, I guess it is convenient to not have to write everything twice...
18:15:24 <emu> fnord123: +. is the function which adds two float point numbers in caml
18:15:30 <encryptio> it's easy to say what's bad about it... but what's good about ocaml? what does it kick butt at?
18:15:37 <emu> the compiler is really good
18:15:57 <fnord123> oh ok
18:15:57 <allbery_b> ford: "vs" meaning "versus"
18:16:04 <emu> it's call-by-value which sits well with some people
18:16:09 <beschmi> encryptio: you need some low-level code that you would otherwise write in C/C++ => use ocaml
18:16:13 <allbery_b> and silly +. nonsense
18:16:15 <allbery_b> whee
18:17:03 <dmead> @hoogle gtk2hs
18:17:03 <lambdabot> No matches found
18:17:07 <emu> i did a bunch of SML really
18:17:11 <dmead> yea
18:17:15 <dmead> i did sml in school too
18:17:21 <mbishop> there is an extension called GCaml, which allows for "overloading", so you can make + and +. "smart"
18:17:28 <emu> ocaml almost a few times -- but then i wondered, why? i liked sml better.
18:17:47 <mbishop> I like SML, but ocaml seems to have stolen all it's users :P
18:17:54 <dmead> yo
18:18:01 <emu> and then i decided tha tif i was going to get back into statically typed functional programming, it would be via Haskell
18:18:02 <dmead> is gtk2hs included in ghc?
18:18:08 <sorear> no
18:18:12 <dmead> rats
18:18:33 <emu> because it was radically different
18:18:39 <allbery_b> @where gtk2hs
18:18:40 <lambdabot> http://haskell.org/gtk2hs/
18:18:44 <dmead> yea
18:18:47 <dmead> its on portage
18:18:48 <dmead> :)
18:18:51 <ddarius> > replicate -1 'a'
18:18:52 <lambdabot>        add an instance declaration for (Num (Char -> Int -> a -> [a]))
18:18:53 <encryptio> heh.
18:19:03 <ddarius> > replicate (-1) 'a'
18:19:05 <lambdabot>  ""
18:19:43 <beschmi> emu: i learned ocaml first. so i got used to the syntax and missed some things in SML (eg pattern guards)
18:19:51 * allbery_b learned some ML because it's used by his compatriots over in CMU SCS.  he's not inclined to follow up on it much, though; being able to read e.g. jhutz's snippets is more than sufficient :)
18:20:52 <mbishop> ocaml fixes a lot of missing stuff in SML
18:21:04 <emu> there is definitely missing stuff in SML
18:21:15 <emu> beschmi: yea i could never get used to the syntax
18:21:31 * allbery_b still thinks let rec is silly
18:21:39 <emu> ;; here, ; there, let here, let rec there, let rec foo = function x -> match x with (wtf is this so long to make a function)
18:22:08 <mbishop> well really, ;; is hardly ever used, except at the top level
18:22:34 <mbishop> and let rec is indeed a little weird, but I don't think it's that bad..I mean, you know your function is going to be recurisve anyway
18:23:04 <beschmi> and you can use let x = x*x
18:23:07 <allbery_b> I didn't say it was weird; I said it was *silly*...
18:23:14 <ddarius> Packing mutually recursive functions/types together is a pain
18:23:18 <emu> oh man
18:23:40 <emu> i remember refactoring an SML program just to arrange two mutually recursive types to be together when i really wanted them to be in separate modules
18:23:46 <encryptio> i love haskell, but i'm going to be doing some heavy real-time image crunching. C is a pain in the ass (soooo unsafe) and ghc doesn't quite cut it for this. i'm looking for a good language with a really fast compiler/runtime for number crunching.
18:23:46 * johnnowak thinks a Haskell programmer complaining about ocaml syntax is throwing rocks in a glass house
18:24:12 <emu> no-- a functional programming language should make function syntax very brief, and Haskell does that well enough
18:24:21 <sorear> no++
18:24:37 <emu> ah yes, apologies to Dr. No
18:24:56 * emu mutters: crummy C-style karma syntax
18:25:02 <ddarius> emu: How much briefer could they be in a lambda based language?
18:25:22 <emu> i don't know, but i do know that let rec foo = function x -> match x with is not it
18:25:33 <johnnowak> is brevity even the number one concern?
18:25:45 <sorear> how do you feel about (defun (foo x) ..)
18:25:59 <emu> less bad. the worst part is repeating the formal parameters.
18:26:02 <ddarius> sorear: Doesn't beat 'foo x = ... '
18:26:08 <sorear> under what circumstances is Map Int better than IntMap ?
18:26:24 <johnnowak> ddarius: it does if your language has macros
18:27:01 <mbishop> It will be nice when GHC starts to make native code as good as ocamlopt
18:27:13 <encryptio> hell yeah.
18:27:21 <allbery_b> encryptio: number crunching?  fortran (and may g-d have mercy on your soul... :)
18:27:22 <mbishop> I still think something needs to be done for IO to be nicer in haskell
18:27:25 <ddarius> For syntax manipulating macros, Haskell's syntax is somewhat rich in areas but function definition is not one of them.
18:27:31 <encryptio> allbery_b: nooooo, not fortran!
18:27:54 <beschmi> encryptio: seems like ocaml would be a nice choice for that for now. just make sure to use extlib and tuareg
18:27:56 <sorear> encryptio: write a Haskell DSL which evaluates to a fortran term!
18:28:05 <ddarius> mbishop: What's not nice about Haskell IO?
18:28:23 <allbery_b> that said, what's wrong with number crunching in haskell?  aside from ghc and gcc bugs that are easily worked around?
18:28:35 <sorear> something needs to be done to make haskell IO more confusing
18:28:48 <allbery_b> get sigfpe to implement an IO comonad?
18:28:50 <ddarius> We could go back to stream based IO.
18:28:51 <sorear> encryptio: remember to @paste any excessivelt slow code
18:29:04 <ddarius> allbery_b: There was already an OI comonad.
18:29:37 <sorear> newtype IO a = IO (OI a) deriving (Comonad)
18:29:50 <encryptio> ...Comonad?
18:29:58 <sorear> don't ask
18:30:06 <encryptio> s/\?$//
18:30:07 <sorear> unless you are really prepared
18:30:31 <encryptio> erf. punctuation puke. still in my perl mindset
18:30:46 <glguy> ?seen SyntaxNinja
18:30:46 <lambdabot> SyntaxNinja is in #haskell, #darcs and #haskell-blah. I don't know when SyntaxNinja last spoke.
18:31:36 <bd_> sorear: I'm pretty sure OI breaks referential transparency... since you can have cojoin :: OI a -> a, and foo c = let a = cojoin c; b = cojoin c; in (a,b)
18:31:44 <bd_> pass in a reading function, and you have problems
18:31:56 <ddarius> bd_: It did.
18:32:14 * SyntaxNinja spekas
18:32:14 <ddarius> @google Comonadic IO
18:32:15 <SyntaxNinja> er
18:32:16 <SyntaxNinja> speaks
18:32:16 <encryptio> can someone please define referential transparency?
18:32:16 <lambdabot> http://lambda-the-ultimate.org/node/988
18:32:16 <lambdabot> Title: The essence of Dataflow Programming by Tarmo Uustalu and Varmo Vene | Lambda the ...
18:32:25 <ddarius> hmm
18:33:20 <ddarius> encryptio: You can replace a term by a reference to the term without changing the meaning.
18:33:40 <Philippa> normally defined the other way round, no?
18:34:00 <Philippa> hmm, no. Never mind :-)
18:34:00 <ddarius> and vice versa.
18:34:09 <araujo> hello
18:34:15 * araujo back from univ
18:34:46 <encryptio> ddarius: where the definition of "meaning" includes only the behavior, not performance or outputted code. right?
18:34:59 <dons> dmead: you serious about doing Java io being simpler than learning Haskell IO?
18:35:03 <ddarius> encryptio: Yes.  The semantics of the code.
18:35:04 <mbishop> encryptio: in plain terms, a function given the same parameters will give the same result
18:35:16 <dmead> i'm serious about the time investment
18:35:34 <encryptio> kay, kewl.
18:35:44 <dons> I don't understand. How hard is it to write:  do x <- readFile "foo"; print x
18:35:57 <araujo> IO is very simple on Haskell
18:35:58 <dons> is it just that you didn't have time to learn the IO api?
18:36:03 <dons> ?docs System.OI
18:36:03 <lambdabot> System.OI not available
18:36:05 <dons> ?docs System.OI
18:36:05 <lambdabot> System.OI not available
18:36:07 <dons> ?docs System.IO
18:36:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
18:36:13 <dons> argh. doesn't seem too counter intuitive ^^
18:36:30 <dmead> well
18:36:33 <mbishop> IO is simple, but using it with other non IO stuff is a pain I find :(
18:36:49 <dmead> some of the haskell IO is very impractical
18:36:50 <araujo> why!?
18:36:50 <dmead> like
18:36:57 <dmead> if your going to allow a do construct at the top level
18:37:02 <dmead> to simulate imperative style
18:37:06 <dmead> why not make it EXACTLY imperative
18:37:10 <araujo> mbishop, An IO is just a data type
18:37:21 <dons> dmead: it is though?
18:37:27 <araujo> Following the same principle of any other data type on Haskell
18:37:30 <ddarius> mbishop: It should only be difficult when you want IO in pure code, using pure code in monadic code is easy.
18:37:30 <dmead> it seems a bit perfectionist, yes
18:38:01 <gvdm_other> dmead: the perfectionism buys us referential transparency
18:38:04 <araujo> dmead, you mean ... making Haskell a non-pure lang?
18:38:09 <ddarius> dmead: Do constructs are allowed anywhere... btw.
18:38:11 <encryptio> dmead: do notation is just syntax sugar. actually having imperative, strict code in a lazy functional language would make things really a pain in the ass.
18:38:13 <dmead> lol
18:38:15 <dons> can you be more concrete dmead? Did you actually have trouble with doing IO? or you just didn't have time to use the API?
18:38:15 <mbishop> araujo: I suppose, but I just seem to run into problems, because some type a ended up being IO a, and I didn't want it to, etc
18:38:18 <dmead> *ducks*
18:38:23 <dmead> *hides*
18:38:50 <dons> its concerning that you wrote a fair amount of code in haskell, but gave up on the IO and did that in Java. I find that boggling. More info please!
18:38:56 * mbishop checks if his reddit link got any upvotes
18:38:59 <gvdm_other> and the ability to be able to reason about code without having to think about state, making programs provable (and if you follow through with the curry-howard isomorphism, they actually are proofs)
18:39:00 <araujo> mbishop, IO a ; is a one way monad. You can't take values out of it (at least if you want to preserve purity)
18:39:01 <dmead> well
18:39:06 <dmead> i'll put it this way
18:39:16 <mbishop> araujo: See, that went right over my head :)
18:39:28 <ddarius> gvdm_other: In an inconsistent logic...
18:39:32 <dmead> i'm all for experimenting with languages and purly functional stuff seems the way to go to solve complex problems
18:39:33 <araujo> mbishop, It's easy. Think of it as a container.
18:39:36 <dmead> BUT
18:39:42 <allbery_b> IO hotel!  data checks in but it never checks out!  :>
18:39:47 <dmead> for simple stuff, you overcomplicate it by trying to remain pure
18:39:52 <encryptio> lol.
18:40:07 <encryptio> dmead: howso?
18:40:09 <EvilTerran> I find laziness more than compensates, dmead
18:40:10 <mbishop> Aww, stupid reddit users downmodded my link :[
18:40:11 * EvilTerran is back (gone 06:38:50)
18:40:14 <mbishop> http://programming.reddit.com/info/14th0/comments
18:40:16 <lambdabot> Title: MIT AI Lab memos (Click &#39;comeletebrowse.shtml&#39; to see descriptions for a ...
18:40:16 <dons> dmead: concrete examples please!
18:40:28 <dmead> well, the do notation for instance
18:40:30 <dons> how is:   main = do x <- getLine ; putStr x -- overly complicated?
18:40:32 <dons> seriously.
18:40:33 <EvilTerran> and you can't have laziness _and_ io
18:40:44 <ddarius> EvilTerran: Sure you can.
18:40:45 <EvilTerran> main = putStr =<< getLine
18:40:50 <encryptio> EvilTerran: we do
18:41:00 <EvilTerran> s/io/normal imperative io/, i mean
18:41:02 <EvilTerran> sorry, it's late
18:41:07 <ddarius> EvilTerran: Sure you can.
18:41:15 <dmead> well
18:41:15 <allbery_b> getContents
18:41:20 <dmead> minus the do i suppose
18:41:22 <araujo> yu need bunch of verbose stuff on java to do that.
18:41:34 <encryptio> but java is verbose everwhere
18:41:37 <encryptio> *everywhere
18:41:47 <araujo> badly verbose
18:41:50 <dmead> if it's going to be simulating an imperative style, why not make it imperative?
18:41:55 <EvilTerran> ok, haskell's a damn slight less verbose about imperative IO than a language that's imperative everywhere is about laziness, in general
18:41:58 <siti> java = most verbose lang ever :)
18:42:04 <allbery_b> anyone who thinks java is verbose hasn't programmed in cobol :>
18:42:12 <allbery_b> or, for that matter, C
18:42:15 <araujo> dmead, the 'do' notation gives it an imperative look&feel
18:42:15 <EvilTerran> or OO cobol
18:42:21 <mbishop> I saw java 7 is supposed to clean up java a bit
18:42:22 <dmead> dons: i'm just trying to raise some pragmatic issues
18:42:24 * mbishop still won't use it
18:42:28 <EvilTerran> (aka ADD ONE TO COBOL GIVING COBOL  =P)
18:42:31 <SamB> allbery_b: C isn't so much verbose as pathetic
18:42:40 <SamB> that is, you have to do so many things in C
18:42:41 <araujo> allbery_b, C is less verbose than java.
18:42:44 <siti> c is way less verbose
18:42:47 <siti> lol
18:42:52 <encryptio> C is unsafe, but it's less verbose
18:42:53 <mbishop> C is way more stupid, however
18:43:09 * araujo prefers C than java
18:43:09 <siti> c is good for what it was designed for
18:43:14 <dmead> dons: what i guess i'm really saying is that there should be a simpler way to seperate the pure functional world from the impure one
18:43:14 <siti> extremely good
18:43:19 <araujo> At least i know what paradigm i am programming at
18:43:27 <allbery_b> tell me it's less verbose after the 3000th time I've done strcpy(foo, bar); ...
18:43:29 <araujo> java is an ugly hybrid language.
18:43:35 <encryptio> siti: do you personally think that C is good for writing userspace applications?
18:43:42 <Cale> If I'm not mad, there's some people working on slime-like Haskell support for Emacs?
18:43:42 <dons> dmead: you really need to provide a concrete example of where it was overly complex.
18:43:42 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:43:44 <bd_> dmead: How would one have a simpler way? The very idea of seperation is you can go io->pure but not the other way
18:43:45 <araujo> Ok, off to eat
18:43:47 <EvilTerran> dmead, write a paper, get it published, become famous in the compsci world :P
18:43:54 <dmead> kay
18:43:57 <dmead> hmm
18:44:02 <allbery_b> cale:
18:44:06 <allbery_b> @where shim
18:44:06 <lambdabot> http://shim.haskellco.de/trac/shim
18:44:13 <Cale> thanks :)
18:44:16 <siti> encryptio: depends what type and requirements... but it is needed less and less...
18:44:20 <Cale> I couldn't remember the name
18:44:27 <encryptio> siti: for things like firefox and such
18:44:29 <dons> I'm using Haskell IO every single day, and it seems rather concise, and flexibe (in that the actions are first class values). So I need some help understanding what was so problematic that you couldn't use that native IO at all. Its very strange
18:44:54 <siti> well firefox mainly uses c++ iirc ;)
18:45:09 <encryptio> i hate c++ more than i dislike c
18:45:19 <siti> yeah, I am the same...
18:45:21 <allbery_b> c++ and javascript and xbel, oh my!
18:45:36 <dons> dmead: you realise that in a public forum, "I/O in Haskell is seriously NOT worth the effort." is pretty inflammatory?
18:46:16 <dons> so I would like to get to the bottom of the issue. If it means better tutorials, ok. If it means better docs. good. But I don't think we can improve without a more concrete example
18:46:18 <dmead> dons: would you disagree with the idea that pure FP should be reserved for solving problems and that things like I/O are just more simply done in say C-like languages?
18:46:21 <mbishop> sadly I think programming.reddit.com is being like Usenet, as in "Flaming is the point of usenet"
18:46:26 <dmead> hehe no actually
18:46:36 <dmead> i didn't think people would find it so objectionable
18:46:41 <mbishop> being/becoming*
18:46:43 <encryptio> siti: but say you were writing a web browser that was originally meant to be fast but slows down after every release. is C a good language for that? (you can strip out the firefox disses there too)
18:47:27 <dons> dmead: are you serious? How could IO be simpler in C. Its uniformly more concise in Haskell, and more flexible, since the IO action is a first class value, can be stored in data structures, and manipulated.
18:47:41 <siti> well I think you will go insane writing a big piece of software in c.... it's not a good choice IMO
18:47:44 <dons> main = interact sort -- is a lot lot nicer than sort.c
18:47:49 <sorear> encryptio: I'd use haskell there.  nothing like a browser that allows IO (exploits) from it's pure renderHtml function
18:47:58 <emu> people who think IO is simpler in C are the same people responsible for all the buffer overflow exploits :/
18:48:04 <siti> but maybe a c library with higher level languages using it might be ok
18:48:37 <siti> e.g. the new firefox is using cairo which is written in c
18:48:53 <dmead> dons: i've not seen anyone ever raise issues about catagory theory when doing i/o in C
18:48:56 <sorear> you mean firefox itself isn't?
18:49:11 <dons> dmead: that's FUD and you know it. Do you use Hoare logic when doing your C IO?
18:49:26 <jcreigh> @hoogle Word32 -> [Char]
18:49:26 <dons> just because there's a solid framework for reasoing about IO, doesn't mean you need it to write code
18:49:27 <lambdabot> No matches, try a more general search
18:49:50 <dmead> dons: the idea of I/O in haskell seems like we're trying to graft on something to pure FP that is simple better done somewhere else
18:49:58 <dmead> *simply
18:50:03 <siti> the best thing about c is most languages can call it :) so it's quite good for libraries...
18:50:14 <Philippa> take it from experienced users: IO is done better in Haskell than in C
18:50:14 <bd_> siti: We've got the FFI ;)
18:50:20 <Cale> dmead: That's not really true though.
18:50:23 <dmead> hehe no, i don't really think involking a logic for just reading values will really help anything
18:50:24 <dons> dmead: that's an opinion. I guess you need more experience with first class IO in Haskell to be able to make that call.
18:50:28 <sorear> siti: foreign export ccall ftw
18:50:38 <encryptio> dmead: well, haskell is a pure language, and IO is by nature not pure. you're right in that sense. but can you make it better and keep haskell pure?
18:50:41 <siti> yeah
18:50:44 <Cale> IO in Haskell is totally in the spirit of functional programming.
18:50:58 <dmead> hmm
18:51:03 <Cale> You can write your own control structures without even needing macros!
18:51:04 <dmead> MAYBE
18:51:10 <dmead> and i'm just thinking outloud
18:51:18 <sorear> dmead: Haskell is the standard lazy pure language.
18:51:22 <encryptio> imo the IO monad is a very pretty way of dealing with it
18:51:23 <dmead> if there was a construct that was like do...
18:51:31 <dmead> wherein you could treat code like java or something
18:51:37 <dmead> and have it all handled by monads, ETC
18:51:37 <newsham> Clean is the non-standard lazy pure language?
18:51:37 <encryptio> ew
18:51:44 <sorear> dmead: if you made haskell impure, you would be violating its very reason for existance.
18:51:48 <sorear> newsham: one of them
18:51:58 <dmead> i don't think thats what i mean
18:52:02 <dons> newsham: yeah, its the minority lazy, pure language that wasn't merged into Haskell 1.0
18:52:03 <dmead> i'll have a think about it
18:52:05 <sorear> newsham: alongside Gofer, Lazy ML, Miranda, etc, etc, etc
18:52:30 <dons> sorear: though all those have since been subsumed into Haskell.
18:52:42 <dons> well, Miranda just died I think.
18:52:54 <emu> licensing issues oto
18:53:08 <Cale> The thing is, when we first started using monadic IO, it was somewhat reasonable to think, hey, this is a little unnatural of a hack, using something from category theory to do things which other programming languages do naturally. But in fact, it turns out that the result is pretty simple, and ends up being more expressive than those other languages are.
18:53:08 <dons> yeah, Haskell is not a trademark of anyone
18:53:13 <newsham> gone the way of lang d'oc?
18:53:15 <edwardk> haskell would need to pick up some notioin of uniqueness typing in order to subsume clean though
18:53:19 <sorear> well its users have been adsorbed by the lambda hivemind, so, ...
18:53:29 <sorear> (on miranda)
18:53:33 <edwardk> er notion even
18:53:45 <Cale> edwardk: Thanks for the invite by the way.
18:53:47 <dmead> Cale: i don't think alot of people are interested in being expressive to accomplish i/o
18:53:48 <Philippa> edwardk: yeah. Not that that (or another form of substructural typing) would be a bad thing
18:53:54 <newsham> cale: well, the other languages do all the "lift"ing for you....
18:54:08 <edwardk> i am a big fan of substructural types, so you won't hear any arguments here ;)
18:54:09 <Philippa> dmead: I don't think a lot of people know it's possible
18:54:13 <newsham> also some of them do optimizations which reorder computations across statements
18:54:19 <dmead> also true
18:54:46 <glguy> Haskell does all the lifting for you too
18:54:47 <Cale> newsham: you mean in the sense of liftM?
18:54:48 <Philippa> newsham: the latter's doable in Haskell *if* you can show it's valid
18:54:57 <glguy> State isn't thye only instance of MonadState
18:55:03 <newsham> cale: yah, in the since of liftM or lift (io)...
18:55:18 <SamB> Philippa: same as other languages, really...
18:55:22 <newsham> phila: *nod* but as of yet?
18:55:23 <Cale> lift is a whole different can of worms, in my opinion
18:55:31 <Philippa> newsham: the monad transformer case is... special. Other languages can't do it at all
18:55:32 <dmead> is it a contraction in terms to say that impure code is expressible as pure?
18:55:38 <Philippa> newsham: as of yet, go write the rewrite rules
18:55:52 <Philippa> dmead: ITYM "contradiction"?
18:55:55 <Cale> Combining monads with monad transformers is something which no other language does anything like. There's nothing analogous to that.
18:56:02 <dmead> yea
18:56:07 <dmead> *contradiction
18:56:11 <Philippa> dmead: it's not, and that's what monads do
18:56:16 <newsham> thats a strange argument, because in other languages you (mostly) get a large collection of all the monad transformers built into the language
18:56:24 <newsham> (which you cant modify at all, of course)
18:56:27 <Cale> newsham: In other languages, you just get IO.
18:56:29 <Philippa> no, you get a monad
18:56:30 <SamB> newsham: not all
18:56:35 <newsham> cale: I dont get State?
18:56:37 <Cale> Well, a monad somewhat like IO
18:56:40 <Philippa> except you don't even get return
18:56:41 <newsham> I dont get Error?
18:56:43 <glguy> in other languages you can't add monads
18:56:44 <Cale> no, but you get something like IORefs.
18:56:49 <Cale> and IO has exceptions
18:56:59 <newsham> *shrug* seems like a rather fine point.
18:57:00 <dons> ?users
18:57:01 <lambdabot> Maximum users seen in #haskell: 328, currently: 294 (89.6%), active: 42 (14.3%)
18:57:06 <Cale> Maybe in some of them, you get continuations.
18:57:33 <encryptio> jeez. after weeks of experimenting, i finally find out why i get "/usr/bin/ld: can't locate file for: -lHShaskell98"
18:57:36 <Philippa> it's a big one if you realise that languages offering you preset transformers instead still let you choose which of a multiplicity to work with
18:57:39 <Cale> But that's about it. IO already has most of the major features offered by the virtual monads used in other programming languages to do IO.
18:57:47 <Philippa> there're some like that, usually they feel like big, clunky languages
18:57:58 <encryptio> the fink packager for ghc split up ghci and "everything else" into two seperate packages
18:58:36 <newsham> cale: ok, I guess if we go back to the IO monad (not how I'd usually code in haskell), most languages do liftM'ing and reading and writing of IORefs
18:58:46 <Cale> newsham: right
18:58:50 <Cale> I agree with you there.
18:58:52 <newsham> (though I think StateT is a better analogy for many languages, like C)
18:59:10 <SamB> newsham: only if you have just one variable
18:59:11 <Cale> However, I think that *not* automatically applying liftM to everything actually buys you some very interesting properties.
18:59:12 <dmead> hmmmmmmmmm
19:00:03 <Cale> In particular, it lets you conveniently pass IO actions as parameters to other functions which are going to stick them together, with no risk of missiles being launched inadvertently while the surgery is taking place.
19:00:13 <Philippa> dmead: you'll find you learn a lot of interesting possibilities watching the people with more experience argue about definitions :-)
19:00:20 <dmead> =)
19:00:32 <Cale> This means that you can write your own control structures.
19:00:54 <Cale> (which is a very handy thing to be able to do)
19:01:18 <Philippa> "no risk" isn't quite true - the IO monad is the one monad that lets you screw with your own substrate system
19:01:25 <Cale> The price you pay for it, is having to be a little more explicit about the order of execution of things whose order of execution potentially matters anyway.
19:01:44 <encryptio> what are the .hi files that ghc creates?
19:01:45 <Cale> Philippa: but pure functions on IO actions are safe
19:01:47 <Philippa> if the surgery's being performed on the computer you're running on (or you're poking into your own code space, etc etc), expect complications still
19:01:50 <Philippa> yep
19:01:51 <sorear> encryptio: haskell interface
19:02:17 <encryptio> sorear: analogous to C's .h files?
19:02:26 <Philippa> nope, more analogous to a pre-compiled header
19:02:26 <sorear> encryptio: exactly
19:02:26 <allbery_b> no
19:02:33 <Cale> Usually you don't need to do IO in order to decide how to glue the IO actions together.
19:02:42 <Cale> (but it's interesting that you very well can)
19:02:45 <allbery_b> well, I think 'd say it's more like the linker information that the linker can't store
19:02:47 <sorear> encryptio: except that they are auto-generated, they are just like .h files
19:02:56 <Philippa> um, no
19:03:14 <Philippa> they're maybe a bit like .h files for core, maybe
19:03:18 <newsham> without going into lots of details, its not a bad first aproximation ;-)
19:03:39 <sorear> the impl is very different
19:03:47 <encryptio> i don't need details, i'm not going to try to modify ghc itself. yet. (i have a few things i'd like to try to implement)
19:03:58 <sorear> but idiomatic C programmers use .h files the same way GHC uses .hi files
19:04:05 <Cale> One thing which I'd really really like to have in Haskell is a way to safely take IO actions and produce nicely linked executables on the host system from them.
19:04:07 <newsham> this channel doesnt like quick'n'easy first order answers
19:04:20 <sorear> IOCCC programmers behave differently.
19:04:22 <Cale> (Which can be run by the user)
19:04:50 <newsham> cale: compile :: IO a -> Filename -> IO ()   kind athing?
19:04:54 <allbery_b> this channel starts arguing category thery that sails over most folks' heads at the drop of a lambda :)
19:04:57 <Cale> newsham: exactly
19:04:58 <jcreigh> Cale: echo 'main = ...' > foo.hs; ghc foo.hs; ./a.out :)
19:05:06 <Cale> jcreigh: yeah, not the same :)
19:05:06 <mbishop> ?
19:05:12 <Cale> (but close :)
19:05:12 <sorear> IO a -> ByteString ftw!!
19:05:18 <Cale> sorear: yeah!
19:05:20 <encryptio> Cale: so you could make (for example) a set of standard unix tools in one haskell source file and be able to compile them all to seperate files?
19:05:31 <Cale> encryptio: yes, by simply running the program
19:05:34 <newsham> cale: seems like something someone writing an editor with good compiler integration might make available...
19:05:41 <encryptio> yeah, that'd be cool
19:05:49 <newsham> ie. yi+haskell extensions or emacs shim.
19:06:02 <Cale> You could automatically turn interpreters into "compilers"
19:06:14 <jcreigh> Cale: but really, I can't immediately see how that would be useful. What would be an example use case for a "compile" function?
19:06:16 <Cale> (scare quotes due to abuse of the term)
19:06:28 <newsham> I think a good haskell development environment would be a nice project.
19:06:34 <mcnster> is there a std fn that would read a string of hex digits and return its Int value?
19:06:35 <allbery_b> jcreighh: lambdabot's runplugs? :)
19:06:49 <allbery_b> (well, fsvo "compile")
19:06:50 <Cale> jcreigh: Well, it would basically let you save the progress of your computation where it was, and simply resume it later.
19:06:51 <newsham> with stuff like functions for compilation, functions for introspecting, etc.
19:07:21 <sjanssen> Cale: you'd have to be able to compile arbitrary functions
19:07:29 <newsham> ?hoogle hex
19:07:30 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
19:07:30 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
19:07:30 <lambdabot> Numeric.readHex :: Integral a => ReadS a
19:07:50 <jcreigh> but it seems like that would be really, really hard to implement because of all the thunks laying around.
19:07:53 <encryptio> the only major thing i see that's horribly missing from ghc's standard libraries is binary packing/unpacking. i.e. packInt :: Int -> PackOptions -> [Char] ; to pack an integer into the binary representation of that integer
19:07:53 <sjanssen> from the runtime structures.  None of the Haskell compilers can do that right now
19:07:56 <allbery_b> as for saving state, it occurs to me that I never liked the undump hack in any other environment either :)
19:08:07 <allbery_b> @where binary
19:08:07 <lambdabot> http://darcs.haskell.org/binary
19:08:08 <mcnster> ahso.  thank you newsham!
19:08:09 <Cale> sjanssen: I mean, just take the whole current heap and stack, and write code to reinstate it.
19:08:13 <allbery_b> it's coming...
19:08:15 <sorear> encryptio: we have it ... se allbery_b
19:08:32 <jcreigh> encryptio: heh, I'm just about to have to write a Word32 -> [Char] function for my toy assembler...
19:08:34 <newsham> :t readHex "1ab"
19:08:36 <lambdabot> forall a. (Num a) => [(a, String)]
19:08:39 <allbery_b> it's not standard yet, it's still evolving somewhat
19:08:42 <dons> ok. lambdabot's going down for a little while
19:08:43 <sjanssen> Cale: ah, so like a (Unix) fork() and then freeze?
19:08:46 <dons> Cale: got an mbot you can host?
19:08:49 <Cale> sjanssen: yeah.
19:08:49 <sjanssen> that'd be kind of cool
19:08:52 <dons> i need to plug in 4 power points....
19:09:01 <dons> 16 cores, 4 power points. bye bye lambdabot
19:09:05 <newsham> > (fst $ readHex "1ab") :: Int
19:09:06 <lambdabot>  Couldn't match expected type `(a, b)'
19:09:14 <sorear> nooo!
19:09:23 <newsham> not too familair with the readS stuff
19:09:25 <encryptio> jcreigh: i did a similar one for 4 and 2 byte signed integers for an audio file processing program
19:09:41 <allbery_b> > readHex "1a4" :: [(Int,String)]
19:09:43 <allbery_b> whoops
19:09:45 <allbery_b> duh
19:09:51 <dmead> @hoogle gtk2hs
19:09:54 * allbery_b slaps self with wet noodle
19:10:00 <allbery_b> > readHex "1a4" :: [(Int,String)]
19:10:02 <sorear-lambdabot>      Bad interface file: ShowQ.hi
19:10:02 <sorear-lambdabot>         mismatched interface file versions:...
19:10:05 <Cale> mbot is coming back online.
19:10:09 <Cale> er...
19:10:13 <allbery_b> hm, right, the one thing missing from sorear-lambdabot :)
19:10:37 <sorear> allbery_b: well, it won't be that hard to fix now that lb supports 6.6
19:10:37 * dmead wonders why ghc 6.6 isn't on portage yet
19:10:45 <sorear>  sorear-lambdabot: quit
19:10:45 <allbery_b> anyway:  ReadS returns a list of possible parses, in the form [(parse,leftover),...]
19:10:53 <allbery_b> er, not returns, *is*
19:11:03 <sorear> Cale: feel free - sorear-lambdabot will vanish
19:11:04 <sjanssen> dmead: Top Men are looking at it
19:11:12 <dmead> cool cool
19:11:15 <allbery_b> I think you had a leading space there
19:11:24 <dmead> yea
19:11:26 <newsham> allberry: isnt there a simpler interface to it though?
19:11:33 <encryptio> looks like Data.Binary is a good start but i need little endian and big endian binary (un)pack functions.
19:11:39 <Cale> something odd is going on when I'm trying to connect.
19:11:48 <dmead> i'll write up my complaints about haskell i/o
19:11:52 <dmead> so i can be told why i'm wrong
19:11:54 <mbishop> Hmm, is there a way to make random more uh...random? it seems to repeat more often than it should
19:12:03 <dmead> or how to fix it up
19:12:08 <dmead> probably not the latter
19:12:11 <sorear> > 2 + 2
19:12:11 <newsham> dmead: more likely you'll be pointed to n other writeups on the same topic
19:12:12 <sorear-lambdabot>      Failed to load interface for `ShowQ':
19:12:12 <sorear-lambdabot>       Use -v to see a list of the ...
19:12:16 <Cale> dmead: http://programming.reddit.com/info/14pfn/comments/c14trz?context=5 -- I actually just wrote about it :)
19:12:19 <sorear-lambdabot> Title: IO doesnâ€™t matter: telling C programmers the key to the Haskell weltanschauung ..., http://tinyurl.com/36ucf6
19:12:23 <newsham> this one is popular (though not as popular as monad tutorials)
19:12:27 <Cale> well, sort of :)
19:12:40 <mbishop> jesus
19:12:43 <encryptio> how would one implement `dd conv=swab` in haskell?
19:12:46 <Cale> NOTICE: ["AUTH",":*** Found your hostname"]
19:12:46 <Cale> irc[freenode] error: IRCRaised <socket: 5>: hGetChar: end of file
19:12:46 <Cale> Exception: all servers detached
19:12:49 <sorear> > 2+2
19:12:50 <sorear-lambdabot>      Bad interface file: ShowQ.hi
19:12:50 <sorear-lambdabot>         mismatched interface file versions:...
19:12:58 <Cale> anyone know why that would be happening?
19:13:11 <mbishop> Cale: perhaps your bot was on that netsplit? :P
19:13:17 <dmead> :s
19:13:20 <encryptio> Cale: bad server - try another
19:13:21 <Cale> Well, it won't even connect.
19:13:26 <sorear> Cale: that's typical for a sudden server closed-connection
19:13:39 <Cale> ah, now it can
19:14:01 <Ytinasni> > 1 + 2
19:14:03 <mbot>  3
19:14:10 <newsham> > let swab a:b:xs = b:a: swab xs; swab xs = xs in swab "this is a test"
19:14:10 <mbot>  Parse error in pattern
19:14:19 <newsham> > let swab (a:b:xs) = b:a: swab xs; swab xs = xs in swab "this is a test"
19:14:20 <mbot>  "htsii  s aetts"
19:14:52 <newsham> encryption: that do it for you?
19:15:00 <encryptio> indeed. thanks
19:19:54 * Daveman waves to encryptio
19:20:03 <encryptio> hiya Daveman. =)
19:21:45 <sorear> @localtime beschmi
19:21:45 <mbot> Local time for beschmi is Fri Feb 16 04:43:53
19:22:00 <sorear> shim-users, anyone?
19:22:19 <sorear> Unexpected error while trying the second compile: "buffer needs preprocesing; interactive check disabled":  0 errors  0 warnings  0 infos  -- this message looks very wrong to me
19:23:54 <encryptio> :t $!
19:23:56 <mbot> parse error on input `$!'
19:24:03 <encryptio> :t ($!)
19:24:05 <mbot> forall a b. (a -> b) -> a -> b
19:24:19 <encryptio> :src $!
19:24:31 <encryptio> @src $!
19:24:31 <mbot> Source not found. I've seen penguins that can type better than that.
19:24:32 <Daveman> :)
19:24:38 <encryptio> what does $! do?
19:24:42 <Daveman> yay penguins
19:24:50 <allbery_b> strict application
19:25:00 * jcreigh is stupid
19:25:16 <beschmi> sorear: hmm, the typo is from GHC-api. right now i'm checking why there is a second compile if the first one succeeds
19:25:20 <allbery_b> foo a $! b makes b strict, IIRC
19:25:20 <jcreigh> I just spent 10 minutes wondering why (x `shiftL` 8) .&. was 0...
19:25:28 <dons> this new machine sounds like a jet engine taking off!
19:25:35 <dons> 16 cores of jet powered lambdas!
19:25:53 <encryptio> =o
19:26:09 <sorear> beschmi: jc, are you actually awake at 4:30 AM or is mbot lying?
19:26:29 <sorear> I would have pinged you specifically if I thought you were awake :)
19:26:55 <sorear> *vomit* an html only message just made it to the list
19:27:12 <newsham> sorear: the first signs of success?
19:27:26 <sorear> newsham: ?
19:27:39 <sorear> every message before has had a plain text alternative
19:27:43 <newsham> haskell success -> users who use html mail on mailing list
19:28:01 <sorear> scary.
19:28:03 <sjanssen> sorear: whodunit?
19:28:09 <sorear> Nick
19:28:40 <beschmi> sorear: local time is right, it's really that bad for me atm.
19:28:41 <sjanssen> hmm, guess my mail client handles that better than I thought
19:28:48 <sjanssen> good to know
19:29:49 <sorear> From: Nick <nick.linker@rambler.ru>
19:29:49 <sorear> the one who was very obviously corrupted by Bulat
19:30:23 <bd_> newsham: HTML email is nothing a procmail rule can't fix :)
19:30:35 <sorear> @bot
19:30:35 <mbot> :)
19:30:49 <newsham> bd_: i delete them manually.
19:31:17 <bd_> At the list server I mean :)
19:31:45 <sorear> too bad you can't set a procmail action to delete the *sender* of the email
19:32:06 <encryptio> you can with some scripting
19:32:29 <newsham> why?  email aside, they are mostly benign.  and you know how to eliminate their email.
19:33:52 * allbery_b wonders how to write a procmail script that applies a 2x4 to the sender's skull
19:34:02 <jcreigh> text/html; lynx -assume-charset=%{charset} -dump -stdin; copiousoutput
19:34:06 <jcreigh> ^^ in ~/.mailcap
19:34:13 <newsham> i think some of you need to go outside (you know, offline) omre often ;-)
19:34:19 <jcreigh> or your text-based browser of choice.
19:34:28 <allbery_b> (that said, I just accept html email; can't train the dept. secretaries out of sending it...)
19:35:44 <newsham> physical violence is a non-proportional response to a poor choice of email encoding
19:36:16 <int-e> sorear, sjanssen: it was a multipart/alternative mail, with a plain text part. so it was only half evil ;)
19:36:35 <sorear> int-e: really?
19:36:40 * sorear looks again
19:37:09 <sorear> no it wasn't
19:37:17 <sorear> the first was, but the lastest wasn't
19:37:35 <int-e> oh right.
19:37:39 <int-e> :(
19:38:17 <int-e> that one hadn't arrived yet.
19:38:19 <dons> nice. if you buy 16 cores, you get a free tshirt
19:38:22 <dons> thanks amd
19:38:40 <mbishop> aww I want a free tshirt :(
19:38:58 <newsham> heh
19:39:09 <jcreigh> I don't think that really "free"...more like a "hidden cost" t-shirt.
19:39:10 <int-e> there must be cheaper ways to get a free tshirt.
19:39:22 <sorear> "I bought 16 idle dice and all I got was this T-shirt"
19:39:27 <dons> hehe
19:39:40 <dons> its so nice getting a box with 8 shiny amd64's sitting in it
19:39:56 <dons> but, damn, its loud. 7 fans ..
19:39:59 <int-e> and a t-shirt?
19:40:02 * sorear wonders how often %us will exceed 5%
19:40:02 <dons> i guess this is suitable for ghc
19:40:10 <int-e> oh, you switched it on? you barbarian! ;)
19:40:14 <mbishop> maybe the tshirt is for the box, to muffle the sound?
19:40:42 <newsham> ?dice 1d6
19:40:42 <mbot> 1d6 => 6
19:40:44 <allbery_b> time to switch to LN2-cooled? :)
19:41:08 * sorear thinks L3He is cooler
19:41:22 <newsham> that would make a nice plan9 cpu server, dons ;-)
19:41:43 <dons> i think it will make a nice lambdabot server
19:41:48 <sorear> or even LH20
19:41:54 <sorear> *LH2O
19:42:03 <newsham> expensive chat bot server
19:42:19 <allbery_b> water cooling is kinda unfortunate when the containment fails, though
19:42:59 <allbery_b> @bot
19:42:59 <mbot> :)
19:43:12 <newsham> ?farber
19:43:12 <mbot> Unknown command, try @list
19:43:12 <allbery_b> yay
19:43:25 <mathewm> http://code.google.com/soc/
19:43:57 <sorear> @seen lambdabot
19:43:57 <mbot> Unknown command, try @list
19:44:01 <mathewm> how did last year's soc go for the Haskell community?
19:44:08 <int-e> @version
19:44:08 <mbot> lambdabot 4p508, GHC 6.6 (Linux i686 2.40GHz)
19:44:08 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:44:18 <allbery_b> there was just a message about that to the haskell-cafe list
19:44:22 <allbery_b> 7 of 9 projects successful
19:45:19 <allbery_b> 2 of them have made their way into the development version of ghc
19:46:09 <mbishop> I wish there was function for producing a random element in the standard
19:46:26 <mbishop> I stole lambdabot's RandomElem stuff and made it into a module for my own use heh
19:46:33 <jcreigh> mbishop: you mean randomElem :: Int -> [a] -> a?
19:47:21 <mbishop> jcreigh: No, randomElem :: [a] -> IO a
19:47:49 <newsham> choice xs = do { n < - randomRIO (0,lenght xs); return xs !! n }  ?
19:47:59 <newsham> (choiceIO perhaps)
19:48:07 <jcreigh> mbishop: oh, right.
19:48:18 <mbishop> newsham: I was trying something like that before, didn't work
19:48:26 <newsham> why not?
19:48:32 <newsham> (aside from me getting the bounds wrong)
19:48:44 <mbishop> !! really didn't like getting IO a heh
19:48:57 <newsham> thats why I used the do block.
19:48:57 <jcreigh> I have no idea what I was thinking when I wrote that type signature.
19:49:11 <newsham> (need parens around xs !! n btw)
19:49:13 <mbishop> newsham: I used that too, still didn't work :\
19:49:54 <allbery_b> :t \xs -> randomRIO (0, length xs - 1) >>= return . (xs !!)
19:49:56 <mbot> forall a. [a] -> IO a
19:52:04 <mbishop> hmm actually that does seem to work
19:52:14 <newsham> http://www.thenewsh.com/~newsham/x/rs.hs
19:52:15 <mbishop> I was probably forgetting those parens around xs !! n
19:52:18 <newsham> works for me, mbishop.
19:56:28 <Cale> :t \xs -> fmap (xs !!) (randomRIO (0, length xs - 1))
19:56:30 <mbot> forall a. [a] -> IO a
19:58:11 <newsham> or with automatic lifting   xs !! (randomRIO (0, length xs - 1))  ;-)
19:58:22 <beschmi> sorear: I got no idea how that could happen, can you reproduce it?
19:58:52 <sorear> easily
20:01:20 <Cale> newsham: yeah, but that'd prevent me from passing it as an action to other functions, so I wouldn't want it :)
20:01:47 <newsham> not sure I follow.
20:02:15 <Cale> consider  sequence (replicate 20 (randomRIO (0, length xs - 1)))
20:02:29 <Cale> or replicateM 20 (randomRIO (0, length xs - 1))
20:02:35 <sorear> ok, I sucessfully fatfingered the buffer menu
20:02:37 <sorear> beschmi: is there an M-x unshim?
20:02:39 <sorear> C-x k SPC *shim-io* is messy
20:02:47 <emk> @seen syntaxfree
20:02:47 <mbot> Unknown command, try @list
20:02:48 <sorear> lookup ::
20:02:48 <sorear>   forall a (f :: * -> *).
20:02:48 <sorear>   (Typeable a, Typeable (f (Maybe a)), Monad f, Functor f) =>
20:02:49 <sorear>   PList -> f (Maybe a)
20:02:50 <Cale> It's essential there that the action doesn't get run too early.
20:02:51 <sorear>   	-- Defined at /home/stefan/yi/Lib/PList.hs:13:0
20:03:00 <sorear> ^^^ ugly C-c C-d output :(
20:03:05 <emk> @list
20:03:05 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:03:20 <Cale> There might be a place for some syntax to autolift actions.
20:03:27 <newsham> cale: right.. and?
20:03:33 <beschmi> sorear: shim-quit should work
20:03:35 <Cale> But I don't think I'd want it to occur automatically.
20:04:17 <sorear> beschmi: wrt the sample, I'm especially refering to the forall and the -- Defined ...
20:04:33 <Cale> perhaps something like  xs !! (| randomRIO (0, length xs - 1) |)
20:04:39 <newsham> sequence (replicate 20 (IO Int)),  sequence [IO Int], ...
20:04:50 <newsham> compare that to xs !! (IO Int)
20:04:57 <newsham> here its clear that lifting is necessary
20:05:03 <newsham> ?type (!!)
20:05:05 <mbot> forall a. [a] -> Int -> a
20:05:10 <sorear> beschmi: interesting
20:05:10 <Cale> You'll end up with ambiguous cases.
20:05:28 <newsham> possibly, but you havent shown me any :)
20:05:31 <Cale> Where lifting could either be applied or not, and the meaning would be different.
20:05:33 <Cale> Okay
20:05:37 <emk> I've been hacking on probability monads, and was wondering if anybody around here this evening is interested in them...
20:05:39 <beschmi> sorear: yeah, it's just what vshaskell shows on mouseover. i prefer the old output
20:05:41 <sorear> beschmi: when I get into the state (where every save fails with the preprocessing error), M-x shim RET y fixes it
20:05:48 <newsham> I get what you're saying though..
20:06:05 <newsham> I'm thinking maybe this would be a nifty feature of an editor.  it could highlight a type error and offer to auto-lift it for you
20:07:25 <Cale> do {x <- sort ys; ...} -- is this  do {y <- ys; x <- sort y; ...} or just what it says?
20:07:43 <beschmi> sorear: it even fails after you save the buffer once?
20:08:05 <sorear> I think so.
20:08:28 <sorear> no
20:08:39 <newsham> cale: are there ambiguous cases with IO, though?  (what about StateT involving IO?)
20:08:52 <Cale> Sure, though they're slightly rarer.
20:09:13 <Cale> You need things of type IO (IO a) around, which actually does show up in real programs.
20:09:51 <Cale> (usually when you're doing something like constructing actions which will only run a specific number of times)
20:10:10 <newsham> *nod*
20:10:35 <newsham> FFI with callbacks for example
20:10:39 <Cale> yeah
20:11:16 <newsham> seems like there are lots of cases when there is no ambiguity
20:11:21 <newsham> where it would be useful.
20:11:49 <Cale> You could only do it when there'd otherwise be a type error, but then you might turn things which were actually errors into programs which ran and did something unexpected.
20:11:52 <beschmi> sorear: fixing preprocessing is next on my todo list, it would be much better to check if a file needs preprocessing, ask the user "save file before compiling?" instead of just catching the ghc exceptions
20:12:13 <Cale> It's a tricky problem :)
20:12:16 <sorear> beschmi: why is preprocessing special?
20:12:32 <sorear> why can't you use the same trick that you must use for an ordinary file?
20:12:37 <Cale> I think I prefer the route of adding a little syntax sugar for specifying where the lifting should happen.
20:13:15 <Cale> (if anything -- it's not like it's all *that* cumbersome with what we have :)
20:13:15 <beschmi> sorear: if a file has changed, i can give load just a buffer and last-changed time
20:13:56 <sorear> beschmi: the GHC api knows what buffers are?!
20:14:22 <beschmi> sorear: but if the source file needs preprocessing, the right version of the file needs to be saved since that's where cpp/... looks for the file
20:14:23 <encryptio> how would i define a (/) operator on my data types so i can use it like (a / b)?
20:14:44 <beschmi> sorear: bytestrings are called stringbuffers in ghc
20:14:48 * sorear thought CPP read from stdin
20:14:55 <sorear> ah.
20:15:21 <sorear> encryptio: instance Num MyNumericType where (+) = ... ; (*) = ...; (-) = ...
20:15:37 <sorear> instance Fractional MyNumericType where (/) = ...
20:16:06 <chessguy> 'evening haskellers
20:16:18 <sorear> evening chessguy
20:16:22 <encryptio> it's a number attached to a (set of) dimension(s)... are those type classes applicable?
20:16:57 <chessguy> no bot? :(
20:17:02 <encryptio> @bot
20:17:03 <mbot> :)
20:17:21 <sjanssen> encryptio: do you want dimension mismatch to be a static or dynamic error?
20:17:44 <encryptio> sjanssen: dynamic
20:18:00 <beschmi> newsham: how far did you get with shim on windows?
20:18:03 <dons> we have mbot till my new machine is up
20:18:07 <sjanssen> encryptio: then yes, the standard num classes should work for you
20:18:45 <araujo> oh no!
20:18:58 <encryptio> and i just use error ("Can't add numbers of " ++ ... ++ " and " ++ ... ++ " dimensions.")
20:19:01 <encryptio> ?
20:19:04 * araujo will feel incomplete without lambdabot
20:19:06 <sjanssen> right
20:19:14 <sorear> araujo: the bot is comming back
20:19:19 <bd_> ?bots
20:19:19 <mbot> :)
20:19:21 <sorear> araujo: with +RTS -N16
20:19:26 <bd_> see? we have a lambdabot
20:19:39 <araujo> i need it on #haskell.es!
20:19:41 <sorear> araujo: dons need to get special power arangements for the 16-core behemoth
20:19:59 <dons> yeah. so everything in my cubicle is unplugged now
20:20:05 <dons> since i had to donate 4 powerpoints to the server
20:20:07 <chessguy> @join #haskell.es
20:20:08 <mbot> Not enough privileges
20:20:32 <araujo> mm...
20:20:37 <sorear> @join #haskell.es
20:20:37 <mbot> Not enough privileges
20:22:31 <newsham> beschmi: its working.  i can run commands in emacs with it
20:23:05 <Cale> @join #haskell.es
20:23:11 <Cale> there you go :)
20:23:20 <araujo> yay1
20:23:20 <newsham> beschmi: some of the build stuff was a bit hacky but i dont really know the proper fix (not being an elisp guy...  also can you do conditionals in a cabal file?)
20:23:23 <araujo> Thanks Cale !
20:23:50 <beschmi> cool, can you send me the patches? then i can try it out this weekend and add a windows section to the howto
20:24:05 <beschmi> i mean the patches for the ghc libdir issue
20:24:15 <newsham> cale: yah, perhaps machine-assisted lifting is best (ie. editor that offers help)
20:24:23 <Cale> newsham: yeah
20:24:30 <newsham> beschmi; i sent you full patches
20:24:51 <sjanssen> machine-assisted lifting?
20:24:55 <newsham> the last one i sent you should have everything in working order
20:24:57 <sjanssen> just lift with your knees
20:25:12 <newsham> sjanssen:   xs !! (randomRIO (0, length xs - 1))
20:25:41 <fuzan> Aye, internet is being goofy... Don't know if my last question made it through the nether. Anyone here using the Gentoo Haskell overlay?
20:26:11 <sjanssen> fmap (xs!!) (randomRIO (0, length xs - 1))
20:26:16 <beschmi> newsham: oh, the second mail you talked about. I only got one: "shim and win32" with the newSession comment
20:26:54 <beschmi> newsham: can you send it again (beschmi at cloaked.de or the shim mailing list)?
20:27:18 <newsham> sjanssen: yes
20:27:32 <newsham> besch: resending now
20:27:43 <encryptio> for that multidimensional number type, is this a good definition: data UnitType = UnitType { unitMult :: Double, unitDimensions :: [Dimension] } ; data Dimension = Dimension { dimPower :: Integer, dimType :: DimensionType } ; data DimensionType = Length | Time | ...
20:27:47 <encryptio> ?
20:30:12 <newsham> resent.
20:30:44 <newsham> sjanssen: we were discussing automatic lifting and assisted lifting.
20:32:46 <sjanssen> newsham: and I was just trying to make a bad joke
20:32:54 <sjanssen> I was always told to lift with my knees
20:34:19 <newsham> i was told to let the machines do the heavy lifting
20:35:05 <newsham> where's the mailing list?  are there archives?
20:35:22 <newsham> ?where shim
20:35:23 <mbot> I know nothing about shim.
20:36:00 <beschmi> ?where+ shim http://shim.haskellco.de
20:36:00 <mbot> Done.
20:36:14 <allbery_b> <lambdabot> http://shim.haskellco.de/trac/shim
20:37:09 <newsham> ahh, yah, diff bot
20:39:09 <sorear> alter ::
20:39:09 <sorear>   forall a a.
20:39:09 <sorear>   (Typeable a, Typeable a) =>
20:39:09 <sorear>   (Maybe a -> Maybe a) -> PList -> PList -- ooh fun!
20:40:06 <bd_> type PList = [Dynamic] ?
20:40:31 <sorear> beschmi: wishlist: add a customizable var for H98-style type signatures.
20:40:36 <sorear> bd_: logically
20:40:37 <nornagon> @index tan
20:40:37 <mbot> Unknown command, try @list
20:40:41 <nornagon> um.
20:40:45 <nornagon> @hoogle tan
20:40:46 <mbot> http://www.latan.com/
20:40:46 <mbot> Title: .:: L.A.TAN.com&reg;. .::.&nbsp; The Tanning & Skin Care Professionals&nbsp; ::.
20:40:52 <nornagon> do not want.
20:40:52 <sorear> bd_: Lisp-style property lists
20:41:01 <bd_> property lists?
20:41:07 <allbery_b> mbot apparently doesn't have any of the hoogle stuff
20:41:12 <allbery_b> anyway, I think tan is in Prelude
20:41:19 <sorear> bd_: in yi, we need a way to store buffer-local vars
20:41:27 <bd_> ah
20:41:33 <nornagon> allbery_b: thanks :)
20:41:37 <nornagon> should've just tried it.
20:41:37 <bd_> Map String Dynamic, sort of thing
20:41:38 <bd_> ?
20:41:47 <nornagon> what about e?
20:42:02 <allbery_b> doesn't exist
20:42:06 <allbery_b> > log 1
20:42:08 <mbot>  0.0
20:42:10 <allbery_b> > exp 1
20:42:10 <sorear> bd_: sorta.  for the sake of type safety, I'm using IntMap Dynamic
20:42:11 <allbery_b> sorry
20:42:11 <mbot>  2.718281828459045
20:42:15 <nornagon> ah, okay
20:42:27 <sorear> bd_: where the keys come from unsafePerformIO . typeRepKey
20:42:35 <allbery_b> pi, however, is Prelude
20:42:37 <sorear> bd_: so it's effectively type-indexed
20:42:44 <bd_> clever
20:43:03 <nrb23> mbot?
20:43:09 <sorear> Cale
20:43:25 <allbery_b> dons is upgrading his hardware, so lambdabot is down
20:43:34 <allbery_b> along with the machine it lives on
20:43:35 <sorear> mbot : Cale :: lambdabot : dons
20:43:37 <beschmi> newsham: i found 4 of your mails (including the one you just sent) in my spam folder. thanks for the patch and sorry for the trouble
20:44:01 <encryptio> :t not
20:44:03 <mbot> Bool -> Bool
20:44:30 <sorear> alter ::
20:44:30 <sorear>   forall a a.
20:44:30 <sorear>   (Typeable a, Typeable a) =>
20:44:30 <sorear>   (Maybe a -> Maybe a) -> PList -> PList -- beschmi: this looks wrong :)
20:45:12 <sorear> beschmi: also, a (setq shim-h98-typesigs 't) might be nice
20:47:57 <beschmi> sorear: i opened a ticket so that i don't forget it. gotta get some sleep now
20:51:38 <newsham> beschmi: no worries.
20:51:43 <newsham> thanks for the warez :)
20:51:51 <encryptio> if i have a data definition such as data DimensionType = Length | Time, do i need to do anything special to add an Eq instance to it?
20:52:00 <encryptio> like, define ==?
20:52:10 <newsham> deriving(Eq, Show)
20:53:15 <encryptio> instance Eq DimensionType deriving(Eq, Show) -- ?
20:53:46 <sorear> data DimensionType = Length | Time deriving (Eq, Show)
20:54:05 <bd_> Ord is useful to derive too
20:54:16 <bd_> since then you can use it in Map
20:54:50 <sorear> occasionally: and Enum, and Bounded [Length..Time], and Ix, and Read
20:55:15 <encryptio> ah. cool.
20:55:35 <encryptio> anyone got a link for a haskell type system cheat sheet?
20:55:59 <bd_> sorear: Typeable? Data? :)
20:56:15 <sorear> hehe.  there's one page of incomprehensible gibberish for SysFC, but I dunno about HDM+TC
20:56:29 <sorear> bd_: Not in scope: class 'Typeable' :)
20:56:37 <dmead> is there gtk2hs examples that dont use glade?
20:56:39 <dmead> ;/
20:56:44 <bd_> sorear: import Data.Generics >.>
20:56:50 <Cale> dmead: hehe :)
20:57:04 <Cale> dmead: I'm sure there are some. It's so much more convenient to use it though.
20:57:08 <sorear> bd_: Parse error: . after import :p
20:57:19 <bd_> sorear: import Data.Generics -- >.>
20:57:53 <sorear> import Data --> . <-- Generics, h98 forever
20:58:10 <Cale> sigh
20:58:12 <Cale> hehe
21:00:30 <dibblego> if I construct a huge list from some file input, then do computations on it that require memoisation (e.g. Int) that would traverse the list, is it usual to instead create your own data type and do the memoisation straight up as the list is constructed? e.g. data MemoIntList a = Nil | Cons a (MemoIntList) !Int
21:03:04 <sorear> dibblego: no, that's a kind error
21:03:36 <dibblego> what is exactly?
21:04:07 <bd_> dibblego: It's probably more general to fold over the list to make a list of pairs instead...
21:04:13 <sorear> data MemoIntList a = Nil | Cons a (MemoIntList) !Int
21:04:27 <dibblego> sorear, I'm missing an a
21:04:30 <sorear> because of the second term in the second alternative, MemoIntList :: *
21:04:51 <sorear> but because there is a type arg, MemoIntList :: something -> somethingelse
21:04:55 <Gwern> > let negatel l = map (-) l
21:04:55 <mbot>  Parse error
21:04:56 <sorear> those don't match
21:05:00 <newsham> ?seen alexj
21:05:00 <mbot> Unknown command, try @list
21:05:03 <dibblego> bd_, [([a], Int)] ?
21:05:09 <bd_> [(a, Int)]
21:05:10 <Gwern> > negatel [1..10]
21:05:11 <mbot>   Not in scope: `negatel'
21:05:23 <dibblego> ah of course
21:05:25 <Gwern> what happened to lambdabot?
21:05:35 <bd_> memoBuild :: (Int -> a -> Int) -> [a] -> [(a, Int)]
21:05:37 <bd_> @djinn memoBuild :: (Int -> a -> Int) -> [a] -> [(a, Int)]
21:05:37 <mbot> Unknown command, try @list
21:05:43 <araujo> it took vacations
21:05:44 <sorear> Gwern: dons killed it
21:05:54 <sorear> it is being upgraded
21:06:04 <sorear> it saw that resistance was futile
21:06:19 <Gwern> sorear: I hope it will rest in peace
21:06:25 <Gwern> it did yeoman's work, that it did
21:06:38 <Gwern> so anyway, why does negatel l = map (negate) l work, and negatel l = map (-) l not work?
21:06:45 <encryptio> :t (-)
21:06:47 <mbot> forall a. (Num a) => a -> a -> a
21:06:49 <encryptio> ^ that's why
21:06:55 <sorear> Gwern: (-) is subtraction, not negation.
21:07:03 <Gwern> oh. that makes sense.
21:07:05 <encryptio> :t (0-)
21:07:08 <mbot> forall t. (Num t) => t -> t
21:07:11 <sorear> don't you just love prefix negation?
21:07:20 <Gwern> sorear: I was just about to ask how you did that
21:07:20 <dons> we had to move the new machine into its own room
21:07:24 <dons> it was just too noisy :)
21:07:25 <sorear> SML sidesteps the problem by creating (~)
21:07:27 <Gwern> *do that
21:08:00 <sorear> Gwern: how I do what?
21:08:08 <Gwern> sorear: do a negation through the prefix -
21:08:30 <sorear> ugly special cases, that's how.
21:08:35 <Gwern> I guess you just use -, except where there's something in front of it, in which case it is interpreted as substraction?
21:08:42 <sorear> yes
21:08:51 * Gwern shakes head dubiously
21:09:00 <sorear> in SML, ~ is always prefix and - is always infix
21:09:06 <sorear> we in haskell didn't do that
21:09:19 <dibblego> bd_, how about data MemoIntList a = L [a] !Int ?
21:09:24 <encryptio> that (sml's ~ and -) is messy imo
21:09:32 <bd_> dibblego: I don't think that's needed
21:09:44 <dibblego> but I'd like to memo as the list is built
21:09:47 <bd_> dibblego: You can just make a function returning ([a], Int), with the latter being in whnf
21:09:50 <dibblego> so that a second pass isn't needed
21:10:11 <brad__> hi
21:10:13 <brad__> a question
21:10:59 <sorear> go ahead!!!
21:11:10 <bd_> :t \f i l -> foldl (\(l, s) e -> let v = f s e in v `seq` (e:l, s)) i l
21:11:13 <mbot> forall t b a. (t -> b -> a) -> ([b], t) -> [b] -> ([b], t)
21:11:14 * nrb23 likes ~ vs -
21:11:17 <Gwern> brad__: indeed. I've asked many questions, never been bit yet
21:11:20 <bd_> hmm
21:11:22 <brad__> recently i asked people here about a function to permute a string.
21:11:27 <brad__> it used the list monad
21:11:31 <bd_> :t \f i l -> foldl (\(l, s) e -> let v = f s e in v `seq` (e:l, s)) ([], i) l
21:11:32 <newsham> gwern: you werent trying hard enough
21:11:33 <mbot> forall t b a. (t -> b -> a) -> t -> [b] -> ([b], t)
21:11:35 <bd_> dibblego: How about that?
21:11:36 <nrb23> > let f = 5
21:11:36 <mbot>  Parse error
21:11:38 <sorear> brad__: it just gets on my nerves somehow when people think they need to ask before asking.
21:11:42 <bd_> wait, not quite...
21:11:43 <Gwern> newsham: I shall endeavour to do better going forward then
21:11:49 <brad__> i am confused as to knowing when i am indeed using this monad
21:12:01 <brad__> is it any function that takes a list and has "do" in it?
21:12:05 <brad__> that seems simplistic
21:12:08 <sorear> nah
21:12:09 <nrb23> > let f = 5 in f - 5
21:12:10 <dibblego> bd_, that requires me to construct the list, then make a second pass to memo - if I understand seq correctly
21:12:10 <mbot>  0
21:12:16 <newsham> gwern: you might want to try asking to ask, that may get you a bite
21:12:17 <sorear> do is type-insensitive
21:12:21 <nrb23> > let f x = 5 in f - 5
21:12:22 <mbot>   add an instance declaration for (Num (t -> t1))
21:12:22 <mbot>     In the expression: let ...
21:12:31 <Gwern> newsham: may I ask to ask to reply to you?
21:12:34 <nrb23> > let f x = 5 in f -5
21:12:34 <mbot>   add an instance declaration for (Num (t -> t1))
21:12:35 <mbot>     In the expression: let ...
21:12:38 <newsham> gwern: ask sorear.
21:12:38 <bd_> hmm
21:12:41 <nrb23> > let f x = 5 in f (-5)
21:12:42 <mbot>  5
21:12:46 <bd_> dibblego: hold on a sec, I need to think about tihs :)
21:12:49 * nrb23 wonders how the parser figures that out
21:12:50 <sorear> brad__: do uses the monad type of the first action in the set
21:12:55 <Boney> Hi Guys.  I'm looking for a little help with Monads.
21:13:01 <dibblego> bd_, me too - I see your point, but I see a corollary as well :)
21:13:08 <Boney> I want to turn my filename, into a "Value" after it's been parsed.
21:13:09 * sorear bites his fingernails
21:13:20 <sorear> er, fingers
21:13:21 <nrb23> also, what happened to lambdabot?
21:13:26 <Boney> I have readFile which takes filenames and gives IO String.
21:13:27 <sorear> upgrading
21:13:33 <sorear> resistance is futile
21:13:35 <brad__> sorear, does "first action in the set" mean the first function arg?
21:13:41 <sorear> you will be upgraded
21:13:41 <Boney> and I have parse which takes Strings and returns Maybe Value.
21:13:44 <sorear> brad__:
21:13:48 <Boney> How can I "glue" these togeather?
21:13:49 <dons> sorear: what's the getting-the-bot-online command again?
21:13:50 <encryptio> nrb23: mbot is filling in for lambdabot until LB gets moved to an upgraded system
21:13:51 <newsham> brad: if you'reusing a list with return or (>>=)  (and that means on the right hand side of "<-" in do-blocks)
21:13:51 <sorear> f x y z = do a ; b ; c
21:13:54 <glguy> boney: liftM
21:14:01 <sorear> x, y, z, not important
21:14:05 <nrb23> mbot is inferior to lambdabot?
21:14:06 <sorear> a sets the type of the do
21:14:06 <newsham> > return 3 :: [Int]
21:14:08 <mbot>  [3]
21:14:10 <newsham> for example
21:14:11 <brad__> ah, i see
21:14:21 <dons> sorear: ./lambdabot -e online.rc ?
21:14:23 <sorear> dons: ./dist/build/lambdabot/lambdabot -e rc\ online.rc
21:14:27 <glguy> Boney: readFile "name" >>= \contents -> return (operation contents)
21:14:28 <dons> ah
21:14:29 <newsham> > do { x <- [1,2,3]; return (x + 3) }
21:14:30 <mbot>  [4,5,6]
21:14:46 <encryptio> o.O
21:14:46 <newsham> > [1,2,3] >>= (\x -> return (x+3))
21:14:47 <brad__> so i take it there are monads for other types too?
21:14:47 <mbot>  [4,5,6]
21:14:49 <newsham> for example
21:14:51 <Boney> glguy: thanks.  I'll give it a try.
21:15:03 <dons> the bot is on its old machine for the time, till i get the new box set up
21:15:04 <sorear> brad__: many type constructorshave monad instances.
21:15:04 <newsham> brad: yes.  Maybe for example (similar to a list that can have zero or one element)
21:15:08 <dons> at least it has its power supply back
21:15:14 <dons> mbot: @part
21:15:19 <dons> mbot: @part #haskell
21:15:20 <brad__> okay, cool, well now i know! thanks sorear
21:15:21 <newsham> > return 3 :: Maybe Int
21:15:31 <sorear> @botslap
21:15:36 <dons> just give the network a chance to settle
21:15:41 <lambdabot>  Just 3
21:15:43 <lambdabot> Unknown command, try @list
21:15:47 <sorear> oh right
21:15:48 <bd_> dibblego: how about: memolist f init [] = []; memolist f init (h:t) = s' `seq` (h, s'):memolist f s' t where s' = f init h
21:15:53 <Boney> glguy: Yep.  Works :-)
21:15:54 <nornagon> @hoogle liftIO
21:15:57 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
21:16:05 <bd_> dibblego: s' will be in whnf before it returns the list cons
21:16:16 <brad__> dons - is goa in hackage?
21:16:21 <glguy> my my the channel is lively tonight
21:16:21 <sorear>  yes
21:16:32 <dibblego> bd_, thanks, I'll take a look
21:16:33 <sorear> don't expect it to work though :)
21:16:36 <Boney> glguy: I can show you what I was trying.  Would you mind explaining what I was doing wrong and how your solution works?
21:16:37 <nrb23> we should have a party
21:16:41 * nrb23 does a dance
21:16:52 <glguy> Boney: You'll want to read about Monads to better understand >>=
21:17:05 <nrb23> woot food
21:17:09 <sorear> >>= is an overloaded operation, like + or /
21:17:14 <glguy> sorear: can I ask you something?
21:17:20 <Boney> glguy: I've read a fair bit aboout them.  at least 3 different sources..
21:17:23 <glguy> haha! i just did
21:17:26 <sorear> it works on IO a, [a], Maybe a
21:17:29 <Boney> I'm having trouble understanding it.
21:17:33 <sorear> ,etc
21:17:38 <Boney> read_config file = do { config <- readFile file; parse config; }
21:17:50 <brad__> when is ghc 6.7 planned?
21:17:53 <nornagon> @instances MonadIO
21:17:55 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
21:17:55 <sorear> return (parse config)
21:17:58 <brad__> any new groundbreaking features?
21:18:00 <glguy> Boney: if parse doesn't return a value in the IO monad
21:18:01 <sorear> brad__: it already exists
21:18:01 <bd_> Boney: read_config file = readFile >>= \config -> parse config -- this is what the compiler turns it into
21:18:12 <glguy> Boney: then you need to use return
21:18:27 <sorear> brad__: ATs, a debugger, haddock-ghc, etc
21:18:32 <Boney> so return wraps it in an IO monad?
21:18:35 <glguy> Boney: the result of return is a monadic action, that when run returns the value you specified
21:18:45 <brad__> sorear: i take it that 6.7 is in an acceptance/debug phase?
21:18:46 <glguy> Boney: yes
21:18:46 <sorear> brad__: it will never be released, if that's what you're asking
21:18:49 <gmh33> Boney: there is not escaping the monad! :P
21:18:52 <bd_> Boney: return wraps it in a monad; exactly which it determined from context. But in this case, yes, IO :)
21:18:54 <allbery_b> brad: 6.7 is a development version.  dunno what the schedule for 6.8 is but 6.7 is still in active development (as opposed to release engineering)
21:18:55 <encryptio> Boney: return wraps it in any monad, including IO
21:18:58 <Boney> Ok..
21:19:03 <bd_> :t return
21:19:07 <Boney> Isn't maybe also a monad?
21:19:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:19:08 <sorear> brad__: 6.even will be released. 6.odd won't.
21:19:10 <bd_> Boney: yep!
21:19:13 <brad__> ah, okay, so you are following linux kernel numbering
21:19:15 <bd_> Boney: In maybe, return is the same as Just
21:19:17 <glguy> Boney: Maybe is, so there , return is Just
21:19:21 <brad__> even = release, odd = devel
21:19:31 <sorear> ye
21:19:34 <sorear> +a
21:19:34 <glguy> ?losers
21:19:35 <lambdabot> Maximum users seen in #haskell: 284, currently: 282 (99.3%), active: 13 (4.6%)
21:19:36 <sorear> +h
21:20:06 <sorear> > logBase 2 (1 + fromIntegral (maxBound :: Word))
21:20:08 <lambdabot>  32.0
21:20:11 <sorear> aw
21:20:11 <brad__> well i look forward to a debugger that lets me inspect code, printf debugging is a little harder in haskell!
21:20:12 <glguy> sorear: one line per letter isn't going to make the channel scroll any less :-D
21:20:18 <bd_> brad__: Debug.Trace :)
21:20:28 <brad__> thanks bd_!
21:20:35 <glguy> "printf debugging" isn't "debugging"
21:20:43 <nrb23> ug.. printf debugging
21:20:45 <brad__> worked for me so far glguy!
21:20:47 <Boney> How is the context determined?  from the first monad in my "do"?
21:20:50 * nrb23 works for a debugger company
21:20:59 <sorear> Boney: yes
21:21:05 <sorear> or the last
21:21:12 <sorear> they must all be the same anyway
21:21:40 <glguy> Boney: Haskell allows functions parameterized on their return types
21:21:43 <bd_> Boney: The compiler works it out based on the context. It's possible to have a single function which can be called from multiple contexts - though at each call site it has to pick one specific one to work on
21:21:47 <bd_> :t liftM
21:21:49 <bd_> eg,
21:21:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:21:54 <glguy> Boney: the return type is decided by how that value is used
21:22:00 <bd_> liftM is polymorphic - it can work in any Monad m
21:22:10 <brad__> thanks for the info folks! informative as always, bye!
21:22:16 <sorear> yw!
21:22:28 <bd_> Boney: in your case since you use something in IO, the compiler knows it /must/ be IO. If you try to use it as something non-IO, it'll complain
21:22:51 <Boney> Hrm.  Ok.  I think I'm getting it,  but it'll take a little to all sink in, (and pratice).
21:23:02 <nornagon> @hoogle bracket_
21:23:03 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
21:23:03 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
21:23:27 <gmh33> type classes is one of the best ideas...
21:23:40 <Boney> Thanks heaps guys.
21:24:12 <nornagon> what's Control.Exception.bracket_ do?
21:24:17 <gmh33> I'm finally reading lazy with class : )
21:24:32 <bd_> nornagon: bracket_ getResource doSomethingWithIt freeResource
21:24:50 <bd_> nornagon: whether doSomethingWithIt exceptions or not, freeResource will be called
21:25:07 <nornagon> ah.
21:25:15 <nornagon> as opposed to bracket?
21:25:16 <bd_> :t bracket
21:25:18 <lambdabot> Not in scope: `bracket'
21:25:22 <bd_> :t IO.bracket
21:25:25 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:25:36 <nrb23> exceptions == _|_ ?
21:25:38 <bd_> in bracket freeResource gets the resource :)
21:25:42 <nornagon> what's the difference between IO.bracket_ and Control.Exception.bracket_?
21:25:54 <newsham> withSocketsDo $ bracket (listenOn (UnixSocket "/tmp/foobar")) (\_ -> removeLink "/tmp/foobar") (stuff here)
21:25:55 <bd_> nrb23: exceptions thrown from pure code are _|_, but certain forms of _|_ are not exceptions (eg, nontermination)
21:26:08 <bd_> nornagon: IO.bracket only handles IO exceptions; Control.Exception gets all types of exceptions
21:26:16 <bd_> nornagon: Control.Exception has more detail
21:26:18 <nornagon> i see.
21:26:23 <nrb23> exceptions \elm _|_
21:26:27 <bd_> the haddock of it anyway
21:27:18 <bd_> nrb23: exceptions are isomorphic to a subset of _|_... there's an exception datatype, which is properly defined, and there's the thrown exception, which is _|_
21:27:39 <nornagon> hm... I don't get what it's doing in http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:27:41 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
21:27:54 <nornagon> seems like if the socket fails to connect, the program will just happily trundle along
21:28:09 <nrb23> bd_: any good literature on the?
21:28:14 <bd_> nrb23: the... what?
21:28:14 <nrb23> bd_:  *that
21:28:24 <bd_> ?where denotational_semantics
21:28:25 <lambdabot> I know nothing about denotational_semantics.
21:28:26 <bd_> hmm
21:28:30 <nrb23> bd_: yeah, that
21:28:44 <bd_> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
21:29:39 <nrb23> thanks, I'll read it at some point
21:29:42 <nrb23> soon, I hope
21:29:52 <nrb23> ?where +denotational_semantics http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
21:29:52 <lambdabot> I know nothing about +denotational_semantics.
21:30:01 <nrb23> ?where+ denotational_semantics http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
21:30:01 <lambdabot> Done.
21:30:15 <newsham> norn: "bracket connect disconnect loop" ?
21:32:52 <nornagon> newsham: no, the notify part
21:33:50 <newsham> that juts makes it print the start and end msg before and after doing something, no?
21:35:39 <nornagon> yes
21:35:44 <nornagon> but i'm unsure what happens in the failure case
21:36:09 <newsham> whether exceptions propogate or not...
21:37:21 <bd_> nornagon:
21:37:22 <bd_> Prelude IO> bracket_ (return ()) (const undefined) (putStrLn "foo")
21:37:22 <bd_> foo
21:37:22 <bd_> *** Exception: Prelude.undefined
21:38:49 <sorear> bd_: tsk tsk
21:39:03 <sorear> bd_: you need a evaluate in there, I believe
21:39:13 <bd_> sorear: nah, it's undefined :: IO ()
21:39:18 <sorear> oh
21:39:41 <sorear> nm then
21:40:12 <sorear> hello
21:40:12 <bd_> Prelude IO> fmap (const ()) $ bracket_ (return ()) (const undefined) (putStrLn "foo")
21:40:15 <bd_> foo
21:40:18 <bd_> *** Exception: Prelude.undefined
21:40:20 <bd_> :)(
21:40:35 <s1> evening all
21:41:45 <sm> hugs on ubuntu edgy has a syntax error in the parsec library - something wrong with forall - would anyone know why ?
21:41:48 <nrb23> > bracket_ (return ()) (const undefined) (putStrLn "foo")
21:41:48 <lambdabot>   Not in scope: `bracket_'
21:41:57 <sm> I see forall used in other hugs libs
21:42:00 <nrb23> > IO.bracket_ (return ()) (const undefined) (putStrLn "foo")
21:42:01 <lambdabot>   Not in scope: `IO.bracket_'
21:42:45 <hpaste>  sm pasted "hugs parsec error" at http://hpaste.org/511
21:43:06 <bd_> nrb23: lambdabot does not allow IO
21:43:11 <bd_> for security reasons
21:43:15 <nrb23> bd_: makes sense
21:43:33 <nrb23> why not put it in a jail?
21:43:50 <SamB> nrb23: doesn't want people to delete lambdabot?
21:44:02 <sm> ghc complains on the same file: Not in scope: type variable `forall'
21:44:57 <sorear> -fglasgow-exts?
21:45:06 <SamB> why would parsec use it?
21:45:19 <sorear> parsec compiles fine on yhc!
21:45:20 <SamB> sm: where did you get parsec?
21:45:41 <sm> it's part of the hugs package on ubuntu/debian
21:45:47 <SamB> oh.
21:45:52 <sm> in fact, those other hugs libs with forall seem broken too
21:45:53 <SamB> and it doesn't load properly?
21:45:56 <SamB> even with -98?
21:46:04 <SamB> which means "not 98"
21:46:05 <SamB> btw
21:47:20 <sm> I'll try that -
21:47:49 <Pseudonym> http://xkcd.com/c224.html
21:47:51 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
21:48:47 <sorear> I seem very clumsy today :/
21:50:21 <sm> SamB: that was it.. haskell mode needs the -98 flag for hugs
21:50:34 <sjanssen> Pseudonym: the tooltip popup is priceless
21:51:23 <Nafai> Heh
21:51:56 * sm tries to figure out all the haskell mode features
22:01:59 <sm> how do I pass arguments to main at the hugs prompt ?
22:04:57 <slowriot> has anyone here used yampa?
22:05:51 <sm> I think hugs in edgy is old
22:06:20 <sorear> goodnight
22:06:45 <dibblego> I think * in edgy is old
22:07:56 <sm> true enough.. but 200503
22:08:28 <sm> is hugs still used a lot, or has ghc absorbed what it did ?
22:12:13 <slowriot> eh... I gotta go to bed. Maybe I'll ask later
22:12:16 <Gwern> sm: it is still used, I think. I knoew I see it mentioned oft enough here
22:12:48 <Gwern> sm: also, doesn't 'main foo' work for arguments? it's not the sort of thing I'd expect to vary
22:13:11 <sm> no.. :main foo is supposed to I think, but seems to be a newer feature
22:13:34 <sm> not recognised by this version
22:13:48 <Gwern> you can't run main as a function?
22:13:58 <sm> yes, but it doesn't expect args
22:14:30 <sm> I have main :: IO ()
22:14:52 <sm> isn't that standard ?
22:15:33 <bd_> are you looking for the command line args?
22:15:39 <bd_> use getArgs in System.Environment
22:16:01 <sm> thanks, doing that now
22:16:20 <dibblego> can I ask hoogle if Num is a specialised type of Ord somehow?
22:17:19 <bd_> dibblego: :i Num at the ghci prompt
22:17:22 <bd_> class (Eq a, Show a) => Num a where
22:17:23 <bd_> [...]
22:17:31 <dibblego> of course /me slaps /me
22:17:41 <sm> how often do you all program top down, vs. bottom up ?
22:18:09 <sm> I have reached a point where I'm kind of stuck
22:19:25 <sm> should I keep modelling the problem in ever more detail from the bottom up and wait for it to gel, or write the functions I want and hope they're sensible ?
22:19:50 <sm> when I write from the top down, it can be hard to guess the right api
22:20:06 <bd_> you could go from both directions, then figure out what glue goes in the middle... :)
22:21:20 <sm> that's pretty much what I'm  doing.. I seem to make more solid code starting from the bottom, but I think I need some more steering from the top now
22:21:53 <sm> just means I can't compile it for a while
22:22:27 <bd_> you can stub out functions with undefined if you just want to check types...
22:22:41 <sm> oh, please tell me more ..
22:22:55 <bd_> frobTheThing :: Foo -> (Bar -> Baz) -> Quux
22:23:01 <bd_> fromTheThing = undefined -- implement later
22:23:15 <bd_> it can be useful to use this to figure out if the code you've written so far is sane, at least
22:23:16 <sm> cool, thanks
22:23:27 <bd_> mind you, it'll crash easily if you try to run it :)
22:23:47 <sm> at least, though, it will let me load in hugs/ghci and poke around
22:23:57 <bd_> yep
22:23:57 <encryptio> i find undefined good for type-checking partial programs
22:24:00 <dons> ?users
22:24:00 <lambdabot> Maximum users seen in #haskell: 284, currently: 280 (98.6%), active: 23 (8.2%)
22:24:08 <dons> bah lost the high score. oh well
22:25:05 <sjanssen> dons: is the lambdabot running with +RTS -N16?
22:25:22 <dons> not yet. we're building ghc on the new machine
22:25:29 <dons> it has its own dedicated room now, i should take some photos
22:25:52 <sjanssen> dons: hmm, shouldn't that be essentially instant? :)
22:26:02 <dons> trying to work out how to use fedora ;)
22:26:11 <dons> but yeah, i want to do a -N32 build :-)
22:28:25 * sm really likes the unicode symbols in haskell-mode
22:29:01 <dons> mm. 16G ram, 16 amd64 cores
22:29:06 * dons is in geek heaven
22:29:16 <dons> a machine truly fit for ghc
22:29:34 <sm> dons: nice!
22:29:50 <sjanssen> dons: make sure you unpack the ghc source into /dev/shm
22:30:28 <dons> oh, what's /dev/shm a ram disk?
22:30:33 <sjanssen> right
22:30:43 <Gwern> encryptio: ah. I thought I was the only one who used undefined that way
22:34:05 <glguy> sm: how do you turn on the unicode symbols (emacs?)
22:34:59 <allbery_b> if you have a MULE build, it should just work
22:35:01 <sm> yes Emacs - at least with the new haskell-mode 2.3: Haskell menu -> customize -> haskell font lock symbols
22:35:03 <allbery_b> I think
22:35:21 * allbery_b doesn't really know how fsfemacs deals with that; he uses xemacs
22:35:31 <sm> I think it's off by default because of messing up indentation slightly
22:35:34 <glguy> mule?
22:36:07 <allbery_b> mule is emacs unicode/multilanguage support
22:37:43 <glguy> sm : did you have to pick a font that had those symbols?
22:37:57 <sm> yes
22:38:15 <sm> most of the fonts in my emacs do .. that may not be true for all
22:38:31 <glguy> did you pick the japanese one or the unicode?
22:38:36 <sm> I'm running latest emacs-snapshot package from http://debs.peadrop.com edgy backports
22:38:38 <sm> unicode
22:38:39 <lambdabot> Title: The Core Repository
22:39:49 <glguy> ah, i have MULE apparently
22:40:10 <newsham> are there logs of this channel online?
22:40:17 <glguy> try the topic
22:40:38 <newsham> thank you
22:41:04 * dons `ap` home
22:47:24 <MarcWebe1> Is there a big difference between ghc -syslib and ghc -package ?
22:53:45 <sm> this hs-boot dance is a bit awkward, isn't it ?
22:55:52 <sm> I'm guessing most people avoid mutually importing modules
22:56:31 <bd_> sm: it's mostly used in GHC itself, I think :)
22:57:06 <sm> I'd certainly use it here if it were simpler
22:59:03 <glguy> haskell-font-mode is quite pretty
22:59:23 <glguy> I'm adding type-declaration just to see the ::, => and ->'s more
23:01:29 <sm> surprisingly fun, eh :)
23:01:40 <sm> emacs starts to feel like a grown up ide
23:02:49 <sm> ie, one with pretty fonts
23:03:39 <glguy> as IDEs go, I've been most impressed with Visual Haskell
23:04:05 <sm> I expect that's rather nice
23:08:22 <sm> something I'm confused about - is it possible for two records in a data type to reference the same data values ? eg if you want to cache two expensive views of the data ?
23:09:36 <bd_> sm: Constructor { field1 = foo data, field2 = bar data } ?
23:10:02 <sm> eg: I have a ledger, which has a list of entries.. I calculate the accounts and the entries in each account dynamically. It's slow and I feel the urge to save the dynamic stuff in the ledger as well
23:11:14 <sm> Ledger {entries = es, accounts = accountsFromEs}.. that sounds right
23:11:17 <bd_> sm: you could do eg: fix $ \r -> inputRecord { view1 = makeView1 r, view2 = makeView2 r }
23:11:21 <bd_> sort of thing
23:12:36 <sm> bd_: thanks.. I'm not clear on what fix does
23:12:53 <bd_> fix f = let r = f r in r :)
23:12:54 <dmead> the lack of docs for gtk2hs makes me cry
23:12:58 <bd_> it passes the function's result to itself
23:13:35 * sm 's head spins
23:13:39 <bd_> :)
23:13:51 <bd_> the idea is then makeView1 could use view2
23:13:54 <bd_> or vice versa
23:14:07 <bd_> (careful if you do both of course :)
23:17:19 <sm> just a wild guess - does fix call itself until the answer stops changing ?
23:17:36 <sm> fix 1 is 1, fix id seems to keep going..
23:17:50 <sm> I mean fix (\x -> 1) == 1
23:18:25 <sm> and fix (==) "would give infinite type"
23:19:16 <sm> making a haskell program seems never dull..
23:19:40 <siti> lol
23:19:52 <quicksilver> sm: the definition of fix is roughly that it calls itself until the answer stops changing, yes
23:20:22 <quicksilver> sm: it represents the least fixed point of the function, which informally is reached by applying the function to itself \omega times
23:20:42 <quicksilver> sm: of course, for any particular value hopefully only a finite number of times is needed
23:21:14 <lucca> ```sii``sii, senor
23:22:40 <newsham> ?babel es en si, senor
23:22:42 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
23:23:11 <sm> so bd_ has dropped the record into a singularity.. where it can see the back of its own head
23:23:18 <nrb23> I found the fixpoint of my binary protocol "get message size" function
23:23:42 <bd_> sm: nah, fix only runs once
23:23:45 <bd_> it uses laziness :)
23:23:50 <nrb23> found some c code that read: getMessageSize( getMessageSize( MESSAGE_FOO ) )
23:24:09 <bd_> sm: if it doesn't converge... that's _|_
23:24:23 <nrb23> luckily, getMessageSize(MESSAGE_FOO) == MESSAGE_FOO :-> (stupid C datatypes)
23:24:25 <bd_> sm: in other words, for fix f to be valid, f must not be strict on its argument
23:24:41 <bd_> otherwise... well, you'll probably get a nontermination exception - or maybe just nontermination :)
23:24:55 <newsham> blah hasktags+vim (not sure which or if both) dont do operators or names with ticks in them
23:25:05 <quicksilver> actually I think sm summarised it quite well
23:25:26 <quicksilver> I think you *did* drop the record into a singularity where it can see the back of its own head :)
23:26:03 <bd_> well, fix won't run more than once
23:26:13 <bd_> moreover it has no initial value
23:26:19 <bd_> so it can't just look for a convergence
23:26:22 <quicksilver> bd_: fix itself doesn't, but it does apply the function you give it to itself
23:26:36 <bd_> yes
23:26:40 <bd_> 02:15 < sm> just a wild guess - does fix call itself until the answer stops
23:26:40 <bd_>             changing ?
23:26:47 * quicksilver nods
23:26:51 <quicksilver> I was being imprecise
23:27:03 <encryptio> quicksilver: what does it apply that function to though?
23:27:09 <encryptio> the first time
23:27:10 <quicksilver> I was also deliberately obscuring the difference between f and \f -> (defn of f)
23:27:25 <quicksilver> encryptio: well it helps to explain with an example
23:27:44 <quicksilver> encryptio: let f n = if n == 0 then 1 else (n * (f (n-1)))
23:28:20 <quicksilver> encryptio: this function only makes sense if you know what a recursive definition is. Lambda calculus doesn't have recursive definitions so a priori this doesn't make sense in a lambda-based language
23:28:43 <quicksilver> encryptio: however you can do this : \f n -> if n == 0 then 1 else (n * (f (n-1)))
23:29:11 <quicksilver> encryptio: this is no longer a recursive definition. It's a function which takes a function 'f' as its parameter
23:29:17 <quicksilver> encryptio: and returns a function
23:29:29 <quicksilver> :t \f n -> if n == 0 then 1 else (n * (f (n-1)))
23:29:30 <encryptio> hmm.
23:29:32 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
23:29:44 <quicksilver> (a -> a) -> (a -> a)
23:29:44 <encryptio> interesting.
23:29:49 <quicksilver> takes a function, returns a function
23:29:52 <newsham> ?let let theFunc f n = if n == 0 then 1 else (n * (f (n-1)))
23:29:53 <lambdabot>  Parse error
23:30:02 <quicksilver> that is what you apply, to itself
23:30:02 <newsham> ?let theFunc f n = if n == 0 then 1 else (n * (f (n-1)))
23:30:05 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
23:30:26 <bd_> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in ()
23:30:28 <lambdabot>  ()
23:30:35 <quicksilver> encryptio: so 'fix' is a special combinator which applies that function to itself
23:30:35 <encryptio> so how does fix fit in?
23:30:41 <encryptio> mmm.
23:30:50 <bd_> @tell dons the following causes an error in lambdabot: ?let theFunc f n = if n == 0 then 1 else (n * (f (n-1)))
23:30:51 <lambdabot> Consider it noted.
23:31:25 <quicksilver> encryptio: but 'fix' is built in to haskell (and ML, and all similar languages)
23:31:29 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in theFunc id 0
23:31:30 <lambdabot>  1
23:31:38 <quicksilver> encryptio: 'fix' is what they use internally to implement recursive definitions
23:31:40 <bd_> definitely a bug
23:31:42 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in theFunc id 1
23:31:44 <lambdabot>  0
23:31:54 <bd_> quicksilver: it's what's used to specify it, not to implement it
23:31:58 <quicksilver> encryptio: however, if you have a kind of recursion which can't be expressed in a definition, then you can use fix by hand
23:32:00 <bd_> the implementation's the other way around:
23:32:01 <bd_> @src fix
23:32:02 <lambdabot> fix f = let x = f x in x
23:32:21 <quicksilver> bd_: *mathmatically* fix is what is used to implement it
23:32:29 <quicksilver> bd_: *practically* recursion is used to implement fix :)
23:32:29 <bd_> that's not implementation though :)
23:32:55 <quicksilver> encryptio: then as you can see the definition of fix in haskell looks trivial, because it just uses recursion
23:33:00 <quicksilver> encryptio: fix is the essence of recursion
23:33:21 <encryptio> i see.
23:33:36 <quicksilver> haskell doesn't allow recursion in record constructors, per se
23:33:44 <quicksilver> which is why bd used fix in that example explicitly
23:33:53 <quicksilver> (although he could have just used a recursive let)
23:34:00 <quicksilver> (fix is just a recursive let itself)
23:34:10 <newsham> encryption: notice how in the definition of "theFunc" it doesnt matter what "f" is if n is zero.
23:34:52 <bd_> @check (fix . const) (f :: [Int] -> [Int]) == id f
23:34:54 <lambdabot>   Not in scope: `f'
23:34:59 <bd_> @check \f -> (fix . const) (f :: [Int] -> [Int]) == id f
23:35:00 <lambdabot>   add an instance declaration for (Eq ([Int] -> [Int]))     In the expression...
23:35:14 <bd_> @check \f -> (fix . const) (f :: [Int]) == id f
23:35:16 <lambdabot>  OK, passed 500 tests.
23:37:17 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (fix theFunc) 5
23:37:19 <lambdabot>  120
23:39:43 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc id) 0
23:39:45 <lambdabot>  1
23:39:52 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc id)) 1
23:39:54 <lambdabot>  1
23:40:02 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc id))) 1
23:40:04 <lambdabot>  1
23:40:06 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc id))) 2
23:40:08 <lambdabot>  2
23:40:17 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc (theFunc id)))) 3
23:40:19 <lambdabot>  6
23:40:27 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc (theFunc (theFunc id))))) 4
23:40:29 <lambdabot>  24
23:40:36 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc (theFunc (theFunc (theFunc id)))))) 5
23:40:38 <lambdabot>  120
23:40:39 <encryptio> aha, now i get it
23:40:50 <newsham> except "id" isnt in the middle
23:40:59 <encryptio> yeah, "id" is just a placeholder
23:41:10 <encryptio> a better function would be error "eep"
23:41:11 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc (theFunc (theFunc (theFunc (\x -> undef))))))) 5
23:41:12 <lambdabot>   Not in scope: `undef'
23:41:15 <encryptio> or undefined
23:41:36 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc (theFunc (theFunc (theFunc (\x -> error "too deep!"))))))) 5
23:41:38 <lambdabot>  120
23:41:44 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc (theFunc (theFunc (theFunc (\x -> error "too deep!"))))))) 6
23:41:46 <lambdabot>  Exception: too deep!
23:41:58 <Korollary> Oh man. Philosophy on haskell-cafe.
23:42:02 <encryptio> and the (\x -> .. ) isn't needed because error :: a
23:42:11 <encryptio> "a" can be a function. =)
23:42:21 <newsham> anyway, you get the point.
23:42:25 <encryptio> yeah.
23:42:30 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (fix theFunc) 5
23:42:31 <lambdabot>  120
23:42:36 <newsham> fix does the unrolling for you
23:44:29 <newsham> when the arg is small, most of those theFunc's arent needed
23:44:35 <newsham> > let theFunc f n = if n == 0 then 1 else (n * (f (n-1))) in (theFunc (theFunc (theFunc (theFunc (theFunc (theFunc (\x -> error "too deep!"))))))) 2
23:44:37 <lambdabot>  2
23:44:50 <newsham> as was seen earlier (2 worked when I didnt nest as many)
23:46:47 <encryptio> heh, i was trying to implement a play lazy language in a procedural strict language... i just figured out how i messed up: there are no zero argument functions
23:47:01 <encryptio> rather, they're no different from "values"
23:47:54 <nrb23> good night!
23:48:08 <encryptio> how would i make a pattern matching expression that both unwraps a type and captures the whole thing?
23:48:11 <encryptio> i.e.
23:48:16 <sm> modules don't re-export their imports by default, am I right ?
23:48:36 <encryptio> fun (Unit a b c),d = ... -- where d == Unit a b c
23:48:42 <newsham> > let x@(y:ys) = [1,2,3,4,5] in (x, y, ys)
23:48:43 <lambdabot>  ([1,2,3,4,5],1,[2,3,4,5])
23:48:47 <newsham> like that?
23:48:56 <encryptio> much like that, yes
23:51:46 <ulfdoz> Are there good chances, to successful compile ghc in 64MB physical RAM and about 1.25GB of swap?
23:52:00 <ulfdoz> arch netbsd3.0/i386
23:52:04 <encryptio> successfully yes .. speedily is very unlikely though
23:52:21 <ulfdoz> I don't need speed, I need darcs. ;)
23:53:34 <newsham> does darcs require ghc?  can it run in hugs?
23:53:42 <newsham> (or yhc?)
23:54:20 <ulfdoz> at least 256MB swap haven't been enough.
23:55:51 <dons> ?yow!
23:55:51 <lambdabot> SANTA CLAUS comes down a FIRE ESCAPE wearing bright blue LEG WARMERS
23:55:52 <lambdabot> ... He scrubs the POPE with a mild soap or detergent for 15 minutes,
23:55:52 <lambdabot> starring JANE FONDA!!
23:56:29 <ulfdoz> newsham: Ag least my pkg-manager does not support this configuration. ;)
23:56:58 <DynWind> hi guys
23:57:16 <DynWind> I have an idea. How about adding refactoring support to haskell-mode?
23:57:30 <newsham> dyn: explain?
23:58:35 <DynWind> for example: rename-function would rename the function at its definition and all references to it in the module
23:59:22 <DynWind> perhaps other things like converting from do-notation to >>= notation automatically
23:59:48 <dons> ?undo do x <- getChar ; putChar (toUpper x) -- like this?
23:59:49 <lambdabot> getChar >>= \ x -> putChar (toUpper x)
23:59:53 <quicksilver> it would be a beautiful think indeed
23:59:54 <dons> ?. pl undo do x <- getChar ; putChar (toUpper x) -- like this?
23:59:55 <lambdabot> putChar . toUpper =<< getChar
