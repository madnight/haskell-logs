00:00:12 <ttmrichter> One thing that this blog series is going to do for me is make me dig like crazy to research.
00:00:27 <dons> cool. we've got a list on the Monads page on the wiki, but new ones keep appearing weekly
00:00:49 <ttmrichter> I know.
00:00:52 <ttmrichter> It's a cottage industry.  :D
00:01:05 <dons> i.e. the recent Q monad for quantum stuff
00:01:07 <dons> and the Probalistic monad femk worked on
00:01:10 <ttmrichter> "I'm new to the community.  How can I contribute.  I know!  I'll do a tutorial on monads!"
00:01:39 <ttmrichter> As I wrap my mind more comfortably around the things, I begin to get staggered by how useful they are.
00:02:22 <dons> yeah, its a fundamentally powerful thing to have in a language: the ability to define your own evaluation strategies
00:03:09 <ttmrichter> When I read your thing in reddit I began to reel.  There's stuff there I hadn't considered as monadic, yet in retrospect it is obviously so.
00:03:23 <dons> great!
00:03:36 <antonioc> dons: what article was that?
00:03:46 <ttmrichter> I link to it in that blog entry.  ;)
00:03:57 <dons> i'm not sure if you've considered it, ttmrichter. but it might be a good idea to start with a concrete example on the first page
00:03:58 <ttmrichter> All this from two lousy functions and three simple rules.  Who'd've thunk it?
00:04:09 <ttmrichter> My first draught did.
00:04:18 <dons> just a teaser code example would do
00:04:30 <ttmrichter> The problem was that it was too trivial (to fit in the space constraints) to show why monads are good.
00:04:42 <ttmrichter> And making one that did show it would be... well, scary.
00:04:53 <dons> say, adding continuations, or just mentioning say, the poor mans's concurrency monad.
00:04:55 <antonioc> dons: now, that's a comment! ;)
00:04:56 <ttmrichter> I'm open to ideas for a short, simple, useful example, though.
00:05:05 <dons> something to drive home the simplicity and and usefulness
00:05:15 <dons> maybe even without explanation, just to hook them in to reading the rest
00:05:22 <dons> antonioc: :)
00:06:09 <antonioc> dons: that's the right attitude I think
00:06:19 <fuzan> are all bytestring.char8's nullterminated?
00:06:20 <ttmrichter> OK, that's one I hadn't thought of.
00:06:47 <ttmrichter> Give an example of monads in use -- or perhaps something done without monads and then with monads to drive home the point -- and then explain it in a later installment.
00:06:54 <ttmrichter> Drop off a comment to that effect?
00:07:30 <Thunder> ttmrichter: Use it for state passing in both directions simultanusely ;-)
00:07:53 <Thunder> Then ask you student to translate it to Java.
00:08:04 * ttmrichter points to the part where he's saying that he's doing this to help LEARN monads.  :D
00:08:17 <ttmrichter> I'll dig for a good, cool example.
00:08:27 <ttmrichter> One that would be next to impossible in languages like C/C++/et al.
00:08:56 <ttmrichter> It's a really nice trick -- show Haskell solving a non-trivial problem in trivial amounts of code and effort.
00:10:04 <ttmrichter> Part of the problem with such is that C/C++/et al programmers are conditioned to assume that if it's difficult to do in C/C++/et al it isn't of interest.
00:10:09 <osfameron> perhaps writing a tutorial on monads is the best way to learn monads ?
00:10:26 <ttmrichter> I'd need an example that's POSSIBLE in C++, but finicky and irritating.
00:10:27 <antonioc> I love how, one of the main criticisms of Haskell I heard, is the lack of OO, and OOHaskell proves Haskell's flexibility behind the reach of any other Object Oriented language
00:10:36 <osfameron> ttmrichter: which is worrying, as almost *everything* is hard to do in C...
00:11:06 <ttmrichter> Read my blog entry on only using wrenches....
00:12:29 <ttmrichter> osfameron, as a teacher, I can only say that I learned more in subjects that I've taught than I ever learned in studying them.
00:13:13 <osfameron> antonioc: it looks like OOHaskell is a separate project?  You can probably safely say that if it doesn't exist in core, it doesn't exist (at least to someone looking at haskell from the outside)
00:13:28 <osfameron> ttmrichter: yeah, that figures
00:13:33 <antonioc> ttmrichter: that's so true
00:13:42 <ttmrichter> It's why in my jobs I always tried to shoot for a mentor-like role.  In one company I was the "go to guy" for the summer students because I was the only one that would patiently explain things to them.  Not because I was particularly great, but because I found it was the best way to crystalise my own thoughts.
00:13:56 <Thunder> ttmrichter: Passing State from up to down and from down to up is nontrivial in other languages and trivial in haskell.
00:14:05 <siti> isn't the main criticism, that haskell is hard to learn?
00:14:19 <Thunder> siti: No.
00:14:25 <antonioc> osfameron: what I meant is that Haskell flexibility allows developer to enable OO features despite being a purely functional programming language
00:14:27 <ttmrichter> Haskell is hard to learn because it is, in my opinion, often very badly explained.  Although this is changing.
00:14:47 <ttmrichter> And yes, I could see ways of doing "OO" in Haskell.  I'm just increasingly wondering why I'd want to.
00:15:04 <ttmrichter> I used to be an OOP fanatic.  Then I ran headlong into the limits of it.
00:15:38 <antonioc> ttmrichter: I think Haskell is often taught like you teach Calculus 2. Most programmers won't get it.
00:15:47 <Thunder> ttmricher: OOP is data driven, Haskell is function driven.
00:15:53 <ttmrichter> That's exactly right, antonioc.
00:16:05 <Vq^> antonioc: whats Calculus 2?
00:16:09 <ttmrichter> Haskell is taught as applied mathematics, not engineering.
00:16:42 <antonioc> Vq^: calculus in multiple variables
00:16:51 <Thunder> ttmrichter: If you confuse OOP and Haskell you will run into serious namespace problems. Let the objects away an concentrate on the algorithms.
00:17:25 <ttmrichter> Thunder, I know.  I'm saying that I'm increasingly distancing myself from OOP because I ran into OOP's limitations, not Haskell's.  ;)
00:17:38 <osfameron> Haskell School of Expression is a lovely book... but it goes into things like correctness proofs and things that are very different to the approach of a jobbing programmer
00:17:43 <ttmrichter> Dylan showed me both the limitations of OOP thought and the escape route.
00:17:50 <Thunder> ttmrichter: Haskell is programming C++-Templates without the syntatic glibber.
00:17:52 <antonioc> Vq^: http://www.maths.leeds.ac.uk/~kisilv/courses/math152.html
00:17:53 <lambdabot> Title: Calculus II
00:18:04 <osfameron> so it's probably an easier book to read if you're starting programming than if you're coming from C/Java/Perl/etc.
00:19:18 <Vq^> antonioc: thanks
00:19:36 <Vq^> apparantly im reading calculus 1 at the moment :)
00:19:54 <Thunder> osfameron: Proofs are essential for programming. Personally I came from Assembler, Basic, C, C++, Ada, Java, Spark to Haskell. I'd admit, that the combination of Spark and Haskell does the job. I do not have the time to fix bugs at customer side.
00:20:03 <antonioc> Vq^: Calculus I is a lot of fun
00:21:30 <antonioc> Thunder: I'm not familiar with Spark
00:21:50 <osfameron> Thunder: maybe.  I'm trying to go through the proof exercises in HSoE too, to give them a try.  But it's unfamiliar.  I'd be happier with a unit testing approach (and even that's weird to 99% of jobbing programmers, apparently)
00:23:00 <ttmrichter> osfameron, Testing is alien to most programmers.  They too firmly believe in their own perfection.
00:23:04 * Vq^ came from a C background
00:23:12 <Vq^> so i lack the OOP thinking
00:23:18 <Korollary> who doesnt
00:23:20 <antonioc> osfameron: I'm in three different communities, and there are incredible discrepancies in terms of programming understanding and practices
00:23:36 <siti> I am similar and come from c background but done 3 years of java
00:23:47 <siti> and came to the conclusion OOP is overrated
00:24:02 <antonioc> @where HSoE
00:24:03 <lambdabot> I know nothing about hsoe.
00:24:14 <antonioc> @where Haskell School of Expression
00:24:15 <lambdabot> http://haskell.org
00:24:15 <ttmrichter> siti, OOP has its place.  It's just not the panacea it's advertised to be.
00:24:30 <osfameron> ttmrichter: I don't think it's even that they believ in perfection - they just don't know any different.  Everything is done on superstition, "It might work, it might not"  It's a very fragile and scary way of programming
00:24:36 <antonioc> a big lol for lambdabot's answer
00:25:00 <siti> guis is the only place I now believe it really belongs well
00:25:28 <osfameron> antonioc: yeah, different communities stress on different things, it's one of the tangential benefits to learning different languages :-)
00:25:30 <Vq^> python twisted is a good example of OO as well
00:25:31 <ttmrichter> Ironically, siti, I'm not sure it's suited to GUIs.  ;)
00:25:41 <ttmrichter> It's great for simulations, though.
00:25:42 <siti> hah ok
00:25:50 <antonioc> I love the mathematical certainity of Haskell
00:26:13 <siti> head [] <-- breaks ;)
00:26:44 <siti> but generally haskell code has a much smaller bug rate
00:26:58 <osfameron> siti: OO is also quite well suited to adventure game programming
00:27:02 <ttmrichter> antonioc, The mathematical certainty has little weight to most work-a-day programmers.  Whatever math they've learned has been beaten out of them by brutal regimes of unreasonable deadlines, impossible project goals (I had one boss tell me seriously to prove that P=NP....) and whining users.
00:27:24 <dons> fuzbytestrings are not null terminated, unless you add a null byte to the end yourself
00:27:28 <osfameron> though apparently these days all the cool kids are using Logic programming for text adventures (even Inform 7, though that /is/ implemented atop an OO system)
00:27:32 <dons> fuzan. oh gone.
00:27:55 <siti> text adventures what are those things ;)
00:27:59 <siti> obsolete hah
00:28:10 <osfameron> old fashioned certainly :-)
00:28:44 <osfameron> I think if I actually played a graphical computer game on a modern console I might catch fire.  I haven't played anything more advanced than Frozen Bubble in years.
00:28:56 <osfameron> are there any games written in Haskell ?
00:29:01 <siti> crazy is that how you get work done
00:29:07 <siti> there's an fps named frag
00:29:16 <siti> it's 3D but segfaults for me
00:29:22 <Thunder> osfameron: Proofing is much better than  testing, because your programm will not compile unless your compiler finds a rigeros proof thate the progamm meets the specification first. I do this regularly in Spark and find a lot of corner cases where no checker has any chance.
00:29:29 <siti> I am making draughts (sometimes called checkers) in haskell :)
00:29:37 <osfameron> oh, I wouldn't say I get work done.  IRC tends to suck up the time that gaming would otherwise be taking.
00:29:39 <siti> using cairo, gtk2hs
00:29:44 <Vq^> i'm doing some experiments with a rougealike
00:30:02 <Thunder> Proofing is pushing the corner cases from inside to outside. Testing goes the other direction.
00:30:17 <osfameron> Thunder: yeah, for a pure functional language with a powerful type system that makes sense.  I come from Perl where proofing would be more or less worthless, probably explaining why I think it's weird :D
00:30:34 <Thunder> Proofing does not vanish testing, because a lot of problems come from the specification itself.
00:31:24 <Thunder> osfa: Give Spark a chance. Go to Praxis Critical Systems in Bath, UK and learn why Haskell is lovely.
00:32:16 <antonioc> Thunder: when do you feel that you have to use Spark rather than Haskell?
00:32:21 <Thunder> The fine thing in proofing is, that proofs _simplify_ your code. You can ensure, that certain cases can never happen, so you do not have to deal with.
00:32:36 <osfameron> Thunder: do you have an url?
00:32:57 <siti> http://en.wikipedia.org/wiki/SPARK_programming_language
00:33:03 <osfameron> ta
00:33:10 <Thunder> antonioc: Spark is used whenever FFI in Haskell is needed. Sometimes there must somebody do the really dirty job.
00:33:16 <siti> ada + a bit better?
00:34:10 <osfameron> looks like Design By Contract stuff ?
00:34:24 <siti> hmm
00:34:37 <siti> I never liked dbc unless it was statically checked
00:34:39 <Thunder> Spark allows you to replace error handling code by preconditions. The compiler ensures, that the function is never called without matching precoditions.
00:35:12 <matthew-_> mmm. is that not just guards?
00:35:12 <Thunder> osfa: No, it's  not that high level like Eiffel.
00:35:15 <siti> it would be best if it could not compile without matching preconditions :(
00:35:33 <Thunder> siti: That's exactly the point.
00:35:50 <siti> ok
00:35:55 <siti> I see
00:36:05 <Thunder> You can't compile without a vaild check.
00:36:43 <siti> :)
00:37:06 <Thunder> The numbers are impressive: You get about 9x% of all lines proofed automatically. You get about 0.2 to 1% of your code in a undeciable state. Most of those lines are errors.
00:37:26 <siti> ok
00:37:38 <siti> is there a free spark compiler?
00:37:40 <osfameron> I don't understand how SPARK integrates with Haskell
00:37:51 <siti> I don't think it does
00:38:48 <Thunder> The best point on Spark is the "infections". You get dependant information visible. This way you can define and enforce an information flow. You can staticaly proof the no bits of your private key can leak the maintance module.
00:39:16 <osfameron> like compile time taint-checking ?
00:39:45 <Thunder> osfa: Spark is very hard to code. You deal with aritifically proof elements in every line. (axiomatic proofs). Therefor you can't really write large programms in Spark.
00:40:37 <Thunder> If you seperate your programm in "highly critical low level" modules to be coded in Spark and "global working process" modules in Haskell they come together.
00:40:51 <araujo> hello
00:41:33 <Thunder> Spark exposes the functional equivalent of "proof anchors" to Haskell and obtains the functional borders for it's own proofs.
00:42:01 <Thunder> You have an FFI with proof annotations. Very cool.
00:42:41 <osfameron> Thunder: ah.  it sounds interesting, but I think I will bookmark it and maybe come back to it after I have learnt enough haskell
00:42:44 <beschmi> Thunder: does spark in any way help with side channel attacks (information flow based on timing)?
00:43:09 <Thunder> beschmi: No, unless you model it by hand. Then it will do.
00:43:40 <beschmi> Thunder: ok, seems like you need a pretty detailed machine model for that
00:44:08 <Thunder> beschmi: Side Channels are complicated, i.e. differential power analysis can only be prevented by special designed hardware.
00:45:16 <Thunder> There is not way to prevent side channels on high level other than cryptographically: I.e. mixing a random value in the computation first and get it out at the end.
00:45:43 <beschmi> oh, yes. i've been mainly thinking about timing.
00:46:07 <Thunder> beschmi: Timing issues vanish if you mix random data in and out.
00:46:19 <beschmi> i think you still have to compute with the real value at some place (before/after blinding it)
00:46:27 <Thunder> You can do this in Haskell very easily.
00:46:50 <Thunder> beschmi: *grin* of course you have to blind the real data.
00:47:24 <Thunder> Schneier has a cute chapter of computations in alien, untrusted enviroments.
00:48:48 <Lemmih> @seen dons
00:48:48 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 21m 16s ago.
00:53:56 <dons> Lemmih: ?
00:54:43 <Lemmih> dons: Are you about to release version 1.0 of hs-plugins?
00:55:11 <dons> i should. yes. and stick it on hackage
00:55:33 <Lemmih> Did you fix the bugs in my patches?
00:56:03 <dons> i only applied one merge patch, afaik
00:56:13 <dons> i've not bee working on hs-plugins
00:57:27 <Lemmih> The code I sent you does not work and the testsuite doesn't catch it.
00:58:59 <dons> > 1+2 -- i know this works, but don't trust anything else ;)
00:59:01 <lambdabot>  3
00:59:19 <Lemmih> It works for simple cases.
00:59:48 <Lemmih> But it can't load functions from packages.
01:00:36 <dons> ok.
01:37:03 <ttmrichter> The Hell?!
01:38:38 <quicksilver> bad netsplit
01:38:40 <Boney> it's a network split..
01:38:44 <quicksilver> freenod seems to be having a bad week
01:39:44 <dons> ?users
01:39:45 <lambdabot> Maximum users seen in #haskell: 312, currently: 297 (95.2%), active: 19 (6.4%)
01:39:56 <dons> at least the bot stuck around
01:44:14 <ClaudiusMaximus> are there any caveats to be aware of with hs-plugins with a plugin split into multiple files? i got this when trying to load my plugin ("Hyperspace.hs", depending on "Grid.lhs") and the app crashed.  "./Hyperspace.o: unknown symbol `Grid_rotation_closure'    \n   user error (resolvedObjs failed.)"
01:45:46 <ClaudiusMaximus> ghc-6.4.2, hs-plugins-1.0_rc0
01:45:50 <dcoutts> siti, checkers? cool :-)
01:46:23 <dcoutts> @seen fuzan
01:46:24 <lambdabot> I saw fuzan leaving #haskell 1h 34m 48s ago, and .
01:48:16 <dcoutts> @tell fuzan not sure if you got a reply to your Q, but ByteStrings are not always null terminated, in fact they're usually not.
01:48:17 <lambdabot> Consider it noted.
01:50:44 <ttmrichter> Anybody know how one would go about getting a chess-like game coded in Haskell?  It's a trivial problem to solve, right?
01:50:47 * ttmrichter ducks and runs away.
01:52:44 <siti> dcoutts: yeah, it's good fun
01:53:03 <quicksilver> ttmrichter: yes, trivial. It's just a single fold over the infinite tree of possible games
01:55:08 <siti> lol
01:55:36 <siti> well haskell hasn't been to bad for doing checkers, but chess would be much harder but probably easier than other languages
01:55:41 <dcoutts> siti, might be nice to include in the Gtk2Hs demo collection, like we've got the noughts & crosses demo
01:56:01 <quicksilver> chess is a fairly simple problem, except for the hard bit
01:56:15 <quicksilver> the basic notion of alpha-beta is well discussed and well understood
01:56:20 <quicksilver> and wouldn't be hard to code at all
01:56:23 <siti> dcoutts: it's quite large, bzr branch http://siti.geek.nz/draughts.bzr
01:56:25 <lambdabot> Title: Index of /draughts.bzr
01:56:31 <quicksilver> picking the heuristic function and tuning the pruner, on the other hand
01:56:35 <quicksilver> htat's the hard bit :)
01:56:37 <dcoutts> siti, oh ok
01:56:45 <quicksilver> (although it's also well discussed in the literature I guess)
01:56:47 <siti> but you should have a look anyway :)
01:56:56 <siti> it uses gtk2hs/cairo alot :)
01:57:24 <dcoutts> ok :-)
01:58:23 <Chad> Hey, i'm playing with until for the first time and I'd thought to do something less obvious such as read from a handle a null-terminated string. is this even possible with the until syntax?
01:59:03 <Lemmih> @type until
01:59:05 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
02:00:16 <Chad> i'm aware of the type, my problem is that I'm still pretty poor at combining functions such as until/map/etc with monadic functions, etc.
02:00:54 <Lemmih> Chad: Well, you can't use 'until' to do any IO.
02:05:28 <Chad> Lemmih: I can't seem to think of an elegant method for reading from a handle a variable length null-terminated string.
02:06:01 <Chad> other than the naiive recursive method
02:08:43 <Lemmih> Chad: I think the recurive method is the best way to go. What do you want exactly?
02:09:27 <Chad> Lemmih: I'm comfortable with writing code now in Haskell. I'm trying now however to make more use of folds, until, lifts, etc.
02:09:46 <Chad> Lemmih: I'm sure there's many nice functions that I'm unaware of
02:11:53 <Lemmih> Chad: 'until' doesn't fit in this case.
02:20:14 <Chad> Lemmih: alright, well. time to retire for the night. thanks!
02:20:18 <Chad> \quit
02:27:26 <ClaudiusMaximus> d'oh, forgot to add the directory containing the source file to the paths i was giving hs-plugins...
02:33:44 <chessguy> 'morning, haskellers
02:34:33 <Boney> hi chessguy
02:35:43 <chessguy> anyone care to brainstorm about what the usage of a genetic programming framework in haskell should look like?
02:36:36 <fishkandy> worms :-)
02:38:35 <fishkandy> like, combinators for mutation and crossover, or perhaps some helpers to genetically encode the solution space?
02:38:36 <chessguy> worms?
02:38:37 <jql> it would probably be lazy, and only calculate the fittest dataset when read?
02:40:54 <chessguy> well, at the moment, i'm not so much concerned with features as just general usage. i want to have the engine code which does the actual evolving separate from the problem-specific code, but that requires two modules that import each other (i think)
02:56:42 <fishkandy> why would the engine code need to import the problem specific code?
02:59:54 <chessguy> because the problem-specific code defines things like the datatype it will use
03:00:22 <chessguy> and the genetic material, the fitness measure, etc.
03:00:30 <fishkandy> ah, so you're not talking about a generic enginet hat manipulates bitstrings?
03:01:00 <chessguy> no, not bit-strings. s-expressions which are trees representing programs
03:01:36 <fishkandy> ah, koza-style
03:01:52 <chessguy> correct
03:04:36 <fishkandy> then perhaps have the engine define a typeclass (for the terminals of the s-expressions) that it knows how to operate on?
03:05:08 <chessguy> hmm
03:05:58 <chessguy> i already have, for example:
03:05:58 <chessguy> data Gene = Gene {
03:05:58 <chessguy>     -- every node is a function from its children to a new value of
03:05:58 <chessguy>     -- the problem-specific datatype
03:05:58 <chessguy>     node :: [DataType]->State Environment DataType,
03:05:59 <chessguy>     arity :: Int,
03:06:01 <chessguy>     name :: String
03:06:03 <chessguy> }
03:06:34 <therp> chessguy: still writing on your genetic algorithm/programming toolkit?
03:06:55 <chessguy> therp, indeed. and starting to have some success!
03:06:59 <therp> chessguy: after I finished my Liskell emacs, I seriously going to port my GP framework from common lisp over to Liskell
03:07:08 <therp> s/emacs/emacs mode/
03:07:27 <therp> as I want to present a PhD purposal for GP in essex in April.
03:07:28 <fishkandy> chessguy, well, no need for the engine to know exactly what the DataType is then :-)
03:07:38 <therp> but I think I can't hold that deadline..
03:08:01 <fishkandy> Cheery, but the real question is, how big is the secret compute cluster in your basement? :-)
03:08:14 <chessguy> therp, what specifically are you going to do your PhD on?
03:08:29 <chessguy> fishkandy, hmm. i'd like for that to be true
03:08:51 <therp> chessguy: meta-programming in genetic programming. but totally different than the pedo architecture
03:09:05 <therp> wait, I have a set of papers..
03:09:17 <chessguy> ugh, i can't read papers right now
03:09:50 <chessguy> it's 6 in the morning. i can barely talk coherently. and i'm trying to get this code ready to send to a potential employer
03:10:06 <therp> err, I meant meta-evolution. not meta-programming. I'm a bit obsessed with liskell terminology it seems
03:10:15 <fishkandy> chessguy, sounds like a cool employer
03:10:15 <therp> chessguy: http://citeseer.ist.psu.edu/kantschik99metaevolution.html
03:10:16 <lambdabot> Title: Meta-Evolution in Graph GP - Kantschik, Dittrich, Brameier, Banzhaf (ResearchInd ...
03:10:29 <therp> chessguy: but I'm not using Graph GP as underlying computation architecture
03:10:31 <chessguy> fishkandy, would be my dream job
03:11:13 <fishkandy> chessguy, good luck then, and if you get it, let me know if they've got any openings in about 2 1/2 years time ;-)
03:11:19 <Cheery> My computer crashed but I managed to see here somebody mentioned my nameq
03:11:36 <fishkandy> Cheery, yeah, sorry it was just a typo, no offense :-)
03:11:39 <Cheery> ok.
03:11:40 <therp> cheery: public logs are available, see topic
03:11:41 <Cheery> :P
03:12:02 <chessguy> Cheery, people seem to mistake you for me a lot.
03:12:34 <chessguy> sorry, you don't deserve such bad treatment
03:13:13 <chessguy> int-e!
03:13:37 <int-e> hi chessguy, did you find out where your tree builder went wrong?
03:13:59 <chessguy> int-e, i just pretty much dropped in your code, and it works fine
03:14:13 <int-e> chessguy: but that was your code
03:14:17 <chessguy> yeah
03:14:19 <chessguy> go figure
03:14:41 <chessguy> i'm still scratching my head on that one
03:14:51 <benny_> [offtopic] how do I check if I need to commit my changed to a cvs repository? (like svn status)... is it cvs status | grep "Locally Modified"?
03:15:06 <sek> yes
03:15:25 <benny_> thanks, pretty slow :-D
03:15:41 <sek> there's probably a better way but thats what i use:p
03:19:24 <quicksilver> benny_: [offtopic] don't use CVS :P
03:21:01 <chessguy> fishkandy, so i have something in my problem-specific code like type DataType = Double
03:21:09 <pejo> benny, how can you not know if you need to commit your changes? (I'd use cvs diff, to see them while I'm at it).
03:21:11 <chessguy> i can't decide how to "import" that
03:21:23 <chessguy> (using the term loosely)
03:21:30 <gaal> where do I get the arrows package needed by recent lambdabots?
03:21:41 <fishkandy> chessguy, what sort of operations does the engine ever do on DataType ?
03:22:05 <gaal> and.. any chance of it entering debian?
03:22:42 <chessguy> fishkandy, well, it runs a program, which produces a value of type DataType
03:23:14 <fishkandy> chessguy, ok, and where does that program come from, and what is its type?
03:23:46 <chessguy> fishkandy, the engine creates the program. the type is Tree Gene
03:24:44 <fishkandy> so "run the program" evaluates using an instance of the solution?
03:25:33 <fishkandy> i guess all i meant was, does the engine need to know specific things about eg. Doubles, like does it try to do arithmetic or anything Double-specific?
03:25:37 <chessguy> it runs a member of the population, to see how well it performs
03:25:44 <chessguy> fishkandy, no
03:25:52 <chessguy> but it does see it
03:26:10 <fishkandy> ok, what if Gene was parametrized over Doubles ?
03:26:27 <gaal> actually: is any lambdabot admin around?
03:26:40 <chessguy> ohhh, nice
03:26:51 <chessguy> very nice :)
03:27:01 * chessguy slaps himself around
03:27:01 <gaal> could you add #haskell on irc.perl.org to online.rc please?
03:27:23 <osfameron> there is a #haskell on the perl irc?!
03:27:50 <fishkandy> osfameron, haskell is the new perl, or perl the new haskell, or something like that :-)
03:28:06 <osfameron> golly
03:28:32 <fishkandy> osfameron, http://www.pugscode.org/
03:28:33 <lambdabot> Title: Pugs - pugscode
03:29:00 <osfameron> fishkandy: yeah, that's why I heard of haskell too
03:29:11 <osfameron> just didn't know there was an irc chan there
03:29:28 <fishkandy> heh
03:29:39 <gaal> it's new. recruit more haskell minions! join up! :)
03:29:49 <osfameron> I have
03:32:51 <gaal> what's the non-root version of cabal's runghc Setup.hs install?
03:33:05 <Igloo> runghc Setup.hs install --user
03:33:13 <Igloo> You'll also need to have given --prefix to configure
03:33:44 <gaal> oh! okay, thanks
03:37:52 <chessguy> ?src Show
03:37:52 <lambdabot> class  Show a  where
03:37:52 <lambdabot>     showsPrec :: Int -> a -> ShowS
03:37:52 <lambdabot>     show      :: a   -> String
03:37:52 <lambdabot>     showList  :: [a] -> ShowS
03:39:16 <nominolo> @where withOpenFile
03:39:17 <lambdabot> I know nothing about withopenfile.
03:39:32 <nominolo> @where withFile
03:39:33 <lambdabot> I know nothing about withfile.
03:40:34 <fishkandy> @hoogle openFile
03:40:35 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
03:40:48 <quicksilver> @hoogle with
03:40:49 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
03:40:49 <lambdabot> Network.withSocketsDo :: IO a -> IO a
03:40:49 <lambdabot> Distribution.PackageDescription.withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
03:40:51 <nominolo> hm, would be nice to have a ith open file
03:41:04 <quicksilver> I thought there was withHandle or something
03:44:02 <nominolo> withOpenFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
03:44:03 <nominolo> withOpenFile n m f = finally (do h <- openFile n m; f h) (hClose h)
03:44:17 <nominolo> whoops
03:44:21 <nominolo> wrong
03:44:34 <fishkandy> chessguy, good luck, i'm off to dinner, tell kfish if you get your engine working :-)
03:44:51 <chessguy> kfish, it's working. lol
03:45:04 <nominolo> withOpenFile n m f = do h <- openFile n m; finally (f h) (hClose h)
03:45:05 <chessguy> it's been working, it's just in need of refactoring
03:47:24 <nominolo> any ideas where to put this on the wiki? maybe http://www.haskell.org/haskellwiki/Prelude_function_suggestions ?
03:47:25 <lambdabot> Title: Prelude function suggestions - HaskellWiki
03:53:21 <benny_> pejo: basically, I don't use cvs... I just wrote a small script that shows me if I need to commit something and I use it for the vcs of choice... I just wanted to make it more useful for others by including more vcs' (why in one word: forgetfulness)
03:55:12 <notsmack> benny_: doesn't every vcs already do that?
03:56:10 <benny_> notsmack: well yes... it's basically very silly: but my prompt shows me when I'm in a vcs repository by putting [respective vcs] on the right hand side of the prompt
03:56:22 <benny_> and depending if I need to commit something or not it will show red, or green.
03:56:55 <notsmack> oh, in the prompt, that's kind of cool.  i couldn't imagine the utility of what you were describing
03:57:14 <quicksilver> that is quite cool
03:57:29 <quicksilver> would be rather slow with some vcs' though unless you have something clever going on
03:57:47 <benny_> quicksilver: it's asynchronous... so the first time it will show white and just run in the background
03:58:02 <quicksilver> neat
03:58:03 <benny_> so it's basically always one prompt off... but one prompt is just a ^C away :-)
03:58:40 <notsmack> it'd be cool if it checked if there was anything to pull
04:18:34 <Cheery> What was the notation for defining your own infix operators?
04:18:42 <Cheery> If there were one.
04:19:10 <dons> JaffaCake: hey. got some numbers now for head vs stable, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
04:19:11 <lambdabot> Title: nobench: Haskell implementation shootout
04:19:20 <dons> thanks for the happy patch, i'll add it now.
04:19:28 <JaffaCake> ta
04:19:31 <JaffaCake> ghc-old is 6.6?
04:19:37 <dons> yep
04:19:45 <quicksilver> Cheery: a + b = 5
04:19:46 <nominolo> ChanServ: infix (op) <precendence>
04:19:47 <dons> integrate is a bit suspicious though, i'm rerunning that.
04:19:55 <nominolo> oops
04:19:55 <quicksilver> Cheery: a +++ b = 5
04:19:58 <JaffaCake> hmm, so head is faster
04:20:02 <quicksilver> nominolo is speaking ML
04:20:03 <quicksilver> :P
04:20:05 <JaffaCake> that's a surprise
04:20:09 <nominolo> Cheery: infixr
04:20:12 <quicksilver> Cheery: infixness is a lexical property
04:20:22 <quicksilver> infixr/l is only needed to override the precedence
04:20:25 <rahikkala> let a +++ b = a + b + 5 in 5 +++ 6
04:20:31 <quicksilver> (or associativity)
04:20:40 <quicksilver> Cheery: anything which 'looks like' an infix operator is one
04:20:43 <earthy> hm. interesting. why does ghc-old win for loop? 1.40 == 1.40, right?
04:20:50 <quicksilver> if it begins with ':' it's an infix constructor
04:20:55 <rahikkala> Or:
04:20:57 <quicksilver> (except '::' is special)
04:20:59 <rahikkala> > let (+++) a b = a + b + 5 in 5 +++ 6
04:21:01 <lambdabot>  16
04:21:11 <dons> earthy, must be == on some lower end bits
04:21:13 <nominolo> quicksilver: but only in new GHC's, isn't it?
04:21:26 <quicksilver> nominolo: no, since forever
04:21:35 <quicksilver> nominolo: I think this is haskell report stuff
04:21:44 <dons> it compaD[Dres doubles, then prints the result to 2 decimal places.
04:21:47 <quicksilver> > let a +++ b = a + b + 5 in 5 +++ 6
04:21:49 <lambdabot>  16
04:21:50 <dons> i should probably round first
04:21:55 <quicksilver> -- infix definitions are cuter
04:22:25 <earthy> ah. yeah, probably
04:22:36 <earthy> interesting to note also that ghci is as fast as yhc
04:22:59 <nominolo> heh
04:23:15 <nominolo> jhc might be fast
04:23:32 <nominolo> but i didn't have enough ram to compile base
04:24:23 <nominolo> and i don't quite believe in whole-program-compilation
04:24:36 <nominolo> maybe before deployment
04:37:40 <dons> nominolo: http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
04:37:41 <lambdabot> Title: nobench: Haskell implementation shootout
04:37:49 <dons> jhc is is fast, but only 10% of your programs will compile :-)
04:38:02 <dons> and no real programs.
04:38:09 <dons> so if you have a lot of micro benchmarks in h98 :-)
04:38:09 <SamB> is that how it runs so fast?
04:38:21 <pejo> nominolo, the Mlton people claims whole-program-optimization is viable.
04:38:42 <dons> well, jhc is an example of that. it seems viable, if you can get it to compile fast enough
04:38:58 <dons> needs a team of hackers, and not just john
04:39:07 <SamB> by skipping 90% of the code?
04:39:25 <nominolo> SamB: no, by resolving most of the indirect jumps
04:39:36 <nominolo> and by whole-program register allocation
04:39:41 * SamB was attempting a joke
04:39:41 <pejo> MLton actually compiles real world code though, so it's a better proof of concept judging from the comments about what jhc manages to compile. :-)
04:39:57 * nominolo got it but replied anyways
04:40:03 <SamB> tell me when Parsec compiles
04:40:17 <tuomov_> I was looking into HaskellDB... it does not seem to allow you to create new tables on the fly?
04:40:40 <dons> isn't HDBC preferred?
04:41:00 <tuomov_> does it provide similar nice combinators?
04:41:21 <pejo> Is the gains from interprocedural registerallocation quantified somewhere?
04:41:26 <pejo> For Haskell, that is.
04:41:30 <dons> ah, it might be the low level layer. check on haskell-cafe@ perhaps, tuomov_
04:41:31 <dons> http://haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
04:41:34 <lambdabot> Title: Libraries and tools/Database interfaces - HaskellWiki, http://tinyurl.com/3xb8dd
04:41:55 <tuomov_> is creating new tables all the time even something that is done often with DBs and efficient?
04:42:07 <tuomov_> (/me has never used a db, and is not sure if he'll use one now either)
04:42:19 <dons> JaffaCake: we need to find a way to get more parallelism out of the ghc build system. i could only get it to utilise 5 cores during a -j16 build
04:42:33 <dons> JaffaCake: perhaps building the non-base packages concurrently?
04:42:53 <dons> or maybe splitting some of the bottleneck points, like Parser.hs and Handle.hs
04:43:00 <SamB> dons: hmm. that would be extremely easy, wouldn't it?
04:43:04 <JaffaCake> there are dependencies between the packages, but we could tell make about that
04:43:13 <SamB> the non-base parallism
04:43:14 <nominolo> pejo: jhc is based on a 1999 thesis, there are some evaluations
04:43:20 <dons> I think that would be the easiest attack point
04:43:28 <dons> libs : $(DIRS)
04:43:34 <dons> then specify any deps in extra rules
04:43:39 <JaffaCake> yes
04:43:52 <pejo> nominolo, guess  I should read my Boquist again.
04:44:02 <dons> i did that for nobench (which has zero deps, obviously) and -j16 works a charm
04:44:09 <tuomov_> the HDBC docs are missing
04:44:24 <tuomov_> (a broken trac site... *surpise*... NOT!)
04:44:26 * nominolo too
04:44:29 <JaffaCake> dons: nice
04:44:44 <dons> no more @for i in $(DIRS) for me :)
04:45:07 <dons> tuomov_: also, have a look on hackage
04:45:09 <dons> ?where hackage
04:45:10 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
04:45:15 <dons> some db stuff may have been uploaded by now
04:45:29 <dons> tuomov_: oh, you might like to know, yi has syntax highlighting now :)
04:45:50 * notsmack woots.
04:46:26 <notsmack> dons: has the vi-input gotten any better lately?
04:47:09 <dons> i've not been working on it. jyp has been doing a huge amount of dev, so i'm not sure what state it is in. i'd say, slightly bitrotted, but most of vi should be there
04:48:00 <tuomov_> yeah, hdbc seems to be a low-level library as well
04:48:37 <dons> right. its the low level, that other things like haskelldb utilise, i think
04:48:40 <dons> and takusen.
04:50:33 <tuomov_> a database may be too inefficient for what I want, though
04:50:43 <tuomov_> how efficient is INTERSECT usually?
04:51:00 <araujo> hello
04:53:06 <tuomov_> but not using a db means: using C
04:53:28 <dons> you're doing what? serialising state?
04:54:02 <tuomov_> no, the age-old setfs idea..
04:54:22 <tuomov_> names of files described by sets of tags
04:54:33 <dons> ah. a file system eh? :-)
04:54:39 <dons> well, there's Halfs, that's not written in C
04:54:54 <dons> or you prototype in haskell, then rewrite core pieces in C
04:54:58 <tuomov_> low-level manipulation is too painful in haskell
04:55:00 <dons> which is what i'd do
04:55:38 <DukeDave> Hey gang, classic Monad question for you; I need randomness in my program so I'm finally having to tackle them :)
04:55:38 <DukeDave> I wish to use iterate, but it will be of type:     iterate :: (a -> IO a) -> IO a -> IO [a]
04:55:38 <DukeDave> How may I 'transform' the prelude iterate into a version like this ?
04:55:49 <dons> well, at least you get to have strong typing on the few data structures you need :-)
04:56:01 <dons> i mean, people write kernels and file systems in haskell now, so there must be some benefit
04:56:08 <dons> (safety)
04:56:27 <SamB> who actually writes real kernels that they actually use in Haskell?
04:56:33 <tuomov_> well, if you could describe raw structures as they're stored in memory or disk...
04:56:48 <dons> tuomov_: that's the the FFI is for.
04:56:52 <dons> have a look at halfs
04:56:58 <dons> that's full of inode ptrs and so on
04:57:01 <tuomov_> yeah, so you end up writing most in C anyway!
04:57:07 <dons> yeah :-)
04:57:18 <dons> but the big data structures just get packed into those low level representatoins
04:57:23 <tuomov_> with the extra work of writing wrappers
04:57:25 <dons> SamB: nicta.
04:57:37 <dons> ah wel, write the C then. its not a bad choice.
04:57:53 <dons> i wouldn't, but i guess i play with Ptr CChar all day long anyway
04:57:55 <tuomov_> if I used a DB, I could do without C, but I'm not sure if a DB is good enough..
04:57:58 <SamB> how do they compile them?
04:58:08 <dons> SamB: with a compiler
04:58:21 <fax> hi
04:58:42 <fax> do you think haskell would be a good language to write interpreters in?
04:58:45 <therp> pah, DBs are retro, just use allegrocache ;)
04:59:06 <tuomov_> now, if haskelldb did what I wanted, it would have made use of the db at least very easy... but alas, it doesn't seem to
04:59:08 <dons> fax, i think so. see the compilers and interpreters catalog on haskell.org
04:59:17 <fax> dons: ill do that, cheers
04:59:36 <dons> fax, in particular, pattern matching on data structurs, and monadic state, should make the job easier
04:59:49 <dons> certainly made perl 6 easier to write
05:00:02 <dons> fax, here, http://www.haskell.org/haskellwiki/Libraries_and_tools/Compilers_and_interpreters
05:00:05 <lambdabot> Title: Libraries and tools/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2xadpm
05:00:11 <JohnMeacham> it is particulary difficult to benchmark things when you have one of those variable clock-rate cpus.
05:00:24 <fax> woah
05:00:25 <fax> :D
05:00:42 <JohnMeacham> anyone know a way in linux to temporarily fix your cpu frequency? I am guessing it can be done somewhere in /proc
05:00:52 <dons> hmm. i can do it on openbsd
05:01:00 <dons> hw.sysctl.perf=100
05:01:05 <SamB> huh
05:01:09 <benny_> JohnMeacham: sys/devices/system/cpu/cpu0/cpufreq
05:01:14 <benny_> leading /
05:01:31 <dons> JohnMeacham: btw, done any testing on amd64?
05:01:48 <dons> i was getting quite a few runtime errors today. actually, i don't think any programs managed to run
05:01:55 <JohnMeacham> yeah. my main system is amd64.
05:01:58 <dons> oh ok.
05:02:02 <dons> so jhc should just work then?
05:02:06 <JohnMeacham> jhc is much more consistantly faster than ghc on it.
05:02:19 <dons> hmm. ok. so head jhc should just work?
05:02:24 <dons> jhc-ghc? or jhc-grin?
05:02:25 <JohnMeacham> yeah. it is more likely to work on that than x86.
05:02:59 <JohnMeacham> both. though, jhc-ghc is not terribly well supported. jhc-grin should compile a lot more successfully I think.
05:03:06 <dons> hmm. ok. i'll try again tomorrow and let you know if anything goes wrong.
05:03:15 <dons> and i should switch to testing jhc-grin then, in nobench?
05:03:38 <JohnMeacham> and I just pushed out the beginnings of 'fgrin' (fast-grin) though, it is not optimized yet. but I hope to switch over to it as the default soon.
05:04:33 <JohnMeacham> perhaps. I'd like to see both. but if that will kill your system, then don't worry about it. you can reuse the 'ho' intermediate files between the two back ends. no need to rebuild those.
05:05:01 <dons> nah, i've got cpu cycles to burn here
05:05:08 <dons> a 20 noded cluster, and a 16 core amd64
05:05:31 <JohnMeacham> ah. cool.
05:05:35 <pejo> dons, just laying around, or intended for _Hasekll research?
05:05:36 <dons> ah ok. as long as i don't clean between jhc-ghc and jhc-grin, the .ho files will get reused?
05:05:44 <dons> pejo, just keeping me warm
05:05:46 <JohnMeacham> yup.
05:05:51 <dons> cool. will do then.
05:05:56 <DukeDave> I wish to use iterate, but it will be of type:     iterate :: (a -> IO a) -> IO a -> IO [a]
05:05:56 <DukeDave> There isn't an iterateM in the prelude, does anyone have a suggestion? :S
05:05:57 <basvd> Any people around here with a little HAppS experience?
05:05:59 <pejo> dons, ah. Bet that is needed down there.
05:06:10 <dons> basvd: possibly check #happs
05:06:25 <basvd> yeah I know but nowbody is responding
05:06:28 <basvd>  I'm trying to serve a static file like this: basicFileServe "static/style.css" "/static/style.css" GET... but when I make the request "GET /static/style.css" I get a file not found message. And the log sais: static/style.css/: openBinaryFile: inappropriate type (Not a directory)
05:06:53 <pejo> dons, since I disappeared the other night, and other people had suggested a TR for nobench - was there any conclusion? :-)
05:07:31 <dons> well, no. not yet.
05:07:42 <dons> i'd need to work out more T-style content I think :-)
05:07:42 <JohnMeacham> benny_: cool. hmm.. which one to tweak now..
05:08:12 <pejo> dons, "T"?
05:08:24 <dons> T for Tecnical ;)
05:08:44 <benny_> JohnMeacham: /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed I would guess, if you have that.
05:09:26 <pejo> dons, ah, nods. The nobench page won't disappear anytime in the near future though, I take it?
05:10:06 <JohnMeacham> benny_: scaling_min_freq seems to have done the trick. cool, thanks.
05:10:13 <dons> pejo, nope.
05:14:41 <JohnMeacham> dons: hmm.. things still run faster with -m32 though. the C files jhc generates are portable, and can be compiled on systems of any bitwidth or endian independent of what type of machine they were created on.
05:14:54 <JohnMeacham> I made sure jhc was inherently a cross-compiler.
05:15:23 <dons> so what compilation flags would be best to pass to jhc?
05:15:44 <dons> currently i don't use any args
05:15:51 <dons> there's no -O I take it ;)
05:17:07 <JohnMeacham> dons: no. it always tries to optimize. (unless you pass -fdebug)
05:17:22 <JohnMeacham> in which case it anti-optimizes
05:17:39 <dons> ok. so jhc on its own, should compile via grin, and do the right job on amd64?
05:18:06 <JohnMeacham> yes. it should do the right job with both backends. but ghc's 64 bit support is pretty wonky.
05:18:39 <JohnMeacham> however, it may be faster with -m32 on amd64, I am still trying to figure out why.
05:18:52 <JohnMeacham> (but so is ghc, so I am not too concerned)
05:21:27 <JohnMeacham> the patches I just pushed to my darcs repo fool with the gcc flags for x86 speeding up fgrin considerably. not sure what they do for grin yet.
05:21:39 <dons> ok. i'll just grab them now then.
05:21:55 <Thunder> @pl \x -> span (x==)
05:21:55 <lambdabot> span . (==)
05:22:24 <fax> is there somthing like IOCCC for haskell?
05:22:30 <Thunder> @pl \x -> span (==x)
05:22:31 <lambdabot> span . (==)
05:22:38 <Thunder> Clever.
05:22:42 <dons> fax, yeah
05:22:46 <dons> ?wiki Obfuscation
05:22:47 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
05:22:50 <fax> cool
05:22:55 <fax> thanks again
05:23:15 <JohnMeacham> if you are bored, you can test the fgrin backend with '-mfgrin' as well.
05:23:21 <dons> ok. sure.
05:23:32 <dons> i just run them overnight.
05:23:32 <resiak> of course, the Zeroth and Succ Zeroth links are broken#
05:23:36 <dons> yeah.
05:23:45 <dons> we need to get shapr's harddrive for the results
05:25:55 <dons> JohnMeacham: so at some point you'll have to write up what jhc does, you know :-)
05:26:08 <dons> JohnMeacham: and move material onto the haskell wiki, use Trac, and other community building things
05:26:13 <Thunder> The wiki page on Obfuscating is itself obfuscated. The link to 1993 points to 2004, the links to 2003 and 2004 are plain wrong.
05:26:42 <JohnMeacham> there was a jhc page on the old wiki. only me and musasabi ever updated it though.
05:27:09 <hpaste>  syntaxfree pasted "is this in the prelude?" at http://hpaste.org/688
05:27:59 <dons> JohnMeacham: does jhc pass nice flags down to gcc?
05:27:59 <JohnMeacham> but if you want a preview of my new runtime, it is somewhat documented here: http://repetae.net/repos/jhc/data/jhc_rts2.c
05:28:05 <dons> things like -optc-march=opteron?
05:28:21 <dons> since they can help some specific cases in ghc, at least (FP code, in particular)
05:29:42 <JohnMeacham> dons: you can use --optc to pass flags down. there is a script utils/recomp.prl  can be used to recompile the final C code with differing flags, to quickly test out how they affect them. recomp.prl foo_code.c -march=opteron for instance.
05:30:08 <dons> ok
05:31:35 <JohnMeacham> every option jhc accepts isin the 'jhc --help' output (or its subpages like jhc -dhelp or -fhelp)
05:32:30 <dons> like --optc='-march=opteron'
05:32:55 <syntaxfree> I always imagine large server-like boxes marching with robotic feet when I see that .
05:33:18 <syntaxfree> march ia64! march itanium! march opteron! *clank clank clank clank*
05:33:30 <dons> the march of the opterons, yes. i like
05:33:45 <syntaxfree> like the robots are taking over.
05:33:55 <syntaxfree> as you might know by now, if the robots win, we'll have to listen to techno.
05:34:02 <dons> you will submit to lord opteron!
05:34:13 <JohnMeacham> I suppose I could have it pass through flags starting with '-march' easily.
05:34:23 <syntaxfree> http://www.youtube.com/watch?v=YxZJYbVd1hE
05:34:35 <syntaxfree> sorry for the comic relief interruption.
05:34:44 <JohnMeacham> ls
05:35:28 <dons> #haskell: Permission denied
05:39:43 <SamB> march i686?
05:40:04 <SamB> or would that be march pentium2?
05:47:54 <syntaxfree> http://www.codinghorror.com/blog/archives/000781.html
05:47:56 <lambdabot> Title: Coding Horror: Why Can't Programmers.. Program?
05:48:05 <syntaxfree> hmm. sorry, thought this was -blah
05:48:57 <osfameron> it's a nice little problem, lots of ways to do it
05:49:03 <osfameron> I didn't much like his ruby example
05:49:32 <syntaxfree> it's a silly problem.
05:50:12 <syntaxfree> I mean, I'm kinda feeling ahead of the pack after reading that :)
05:50:17 <JohnMeacham> i686 is pentium pro I think.
05:50:19 <chessguy> @ty runStateT
05:50:21 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
05:50:36 <syntaxfree> I can be struggling with monad transformers, but at least I can freaking write fizzbuzz ;)
05:51:10 <osfameron> heh, indeed
05:51:26 <JohnMeacham> I debugged an interesting bug in jhc earlier where -march=pentium4 would cause a (!!) index too large error. but -march=pentium3 wouldn't. turns out pentium4 no longer needs a certain alignment on functions I was assuming would be true.
05:51:39 <osfameron> it's actually a nice problem because when you try to code it up, it has a few pitfalls if you're trying to do it elegantly
05:52:55 <chessguy> @type (->)
05:52:55 <pejo> JohnMeacham, p4 is less strict with alignment than p3?
05:52:56 <lambdabot> parse error on input `->'
05:53:59 <JohnMeacham> pejo. yes, apprently jumps need not be aligned for good performance on p4. at least that is what i can gather from the generated assembly by gcc.
05:54:25 <JohnMeacham> I have not read the optimization manual though. (those are interesting though, lots of generally useful tips)
05:54:35 <syntaxfree> a few pitfalls, eh?
05:54:45 <JohnMeacham> @kind (->)
05:54:47 <lambdabot> ?? -> ? -> *
05:55:54 <syntaxfree> osfameron: I suggest moving this conversation to #haskell-blah
05:55:57 <chessguy> ?src liftIO
05:55:57 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:57:07 <syntaxfree> annoying error messages!
05:57:10 <syntaxfree> kill kill kill!
05:57:56 <fons> Hi all
05:58:27 <fons> did anyone ever use Text.PrettyPrint.HughesPJ ?
05:58:40 <fons> I don't know how to add vertical spaces
06:00:03 <dons> $+$ ?
06:00:09 <dons> was was that $$ empty $$
06:00:13 <Igloo> $$ text "" $$
06:00:21 <dons> ah yes, i think that's it. needs a combinator
06:00:24 <dons> lets call it $+$
06:00:52 <fons> dons,  $+$ is already defined
06:01:04 <fons> it's vertical concatenation without overlapping
06:01:09 <fons> thanks to both :)
06:01:34 <dons> ah yes. $$ almost
06:02:28 <fons> a vertical combinator with spacing would be really useful
06:02:46 <fons> in the same way there is a horizontal combinator with spacing
06:02:49 <fons> thanks to both
06:02:56 <dons> <+> $+$ makes sense to me
06:06:38 <fons> dons, yep, actually I think $+$ wasn't properly named
06:09:05 <dcoutts_> fons, I agree
06:09:16 <dcoutts_> fons, in a lib I did, I renamed it locally
06:09:28 <kombinator> dcoutts_: hello
06:09:38 <dcoutts_> kombinator, hia
06:09:52 <kombinator> dcoutts_: thanks for the tip about editing text entry, it works
06:10:14 <fons> it is well named in the sense that $+$ might add a vertical space compared to the $$ (in case there's overlapping)
06:10:32 <fons> but ... there's never real vertical blank space
06:10:38 <dcoutts_> kombinator, oh great
06:11:07 <dcoutts_> kombinator, it'd be nice to have a canonical example of that in the demo collection actually, if you have something small
06:11:44 <kombinator> dcoutts_: well, it's small but it's also quite complicated as it is an arrow toolkit;)
06:12:44 <dcoutts_> kombinator, I guess I just mean of the code to filter the input to an entry, eg doing the upper case example
06:12:55 <dcoutts_> or restricting input to be numerical or whatever
06:13:23 <kombinator> dcoutts_: the example in the docs is not bad btw.
06:15:37 <matthew_-> dcoutts_: was that you on Weds with the unicycle?
06:17:15 <dcoutts_> matthew-_, in Nottingham? if so, yes.
06:17:15 <chessguy> sigh. how does an OS manage to let an application get so out of control that it *can't* shut it down, even to soft-reboot the machine?
06:18:28 <apfelmus> apparently, the OS in question is not strongly typed :)
06:18:36 <matthew_-> dcoutts_: yep, for the Fun in the afternoon. I should have said hi. Was it just me or were others generally slightly drowned by James's talk?
06:18:43 <chessguy> yeah, or something
06:19:06 <dcoutts_> matthew-_, oh the first talk? yeah that was a little bit of a struggle to follow.
06:19:11 <matthew_-> yep
06:19:20 <chessguy> by the way, apfelmus, my GP system is working! i've evolved some very basic solutions
06:19:42 <apfelmus> good :)
06:20:10 <chessguy> it's in serious need of a refactor, but it's definitely progressing
06:20:52 <apfelmus> dcoutts_: say concerning the fun in the afternoon, is there any chance to get lennart's slides?
06:21:32 <dcoutts_> apfelmus, no idea, check the website or bug him directly
06:22:05 <apfelmus> it says "Lennart's slides are unavailable (pat. pending)"
06:22:44 <dcoutts_> hah
06:22:57 <matthew_-> also, Lennart should be convinced to make the benchmarks work in his paradise stuff and then we can compare ghc-compiled code to lennart-compiled-and-exec'd-in-Excel code.
06:23:50 <dcoutts_> I bet the Haskell code would win
06:24:17 <dcoutts_> I cant believe that a C++ interpreter marshaling stuff via excel would win
06:24:59 <dcoutts_> mind you, the examples he showed were not calling any heave duty numerics stuff
06:25:49 <dcoutts_> mind you could still use the tuned numerics libs via the FFI anyway
06:26:29 <matthew_-> the amusing part would be the floating maths stuff that would probaly give different answers
06:29:14 <ClaudiusMaximus> @hoogle (Integral a) => CFloat -> a
06:29:15 <lambdabot> No matches, try a more general search
06:29:38 <ClaudiusMaximus> @hoogle (Integral a) => Float -> a
06:29:41 <lambdabot> No matches, try a more general search
06:32:28 <ClaudiusMaximus> @type round
06:32:38 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:07:37 * dcoutts_ finds H98 infidelity in Hugs and GHC's implementations of splitAt
07:08:07 <sjanssen> oh?
07:08:09 <dcoutts_> http://hackage.haskell.org/trac/ghc/ticket/1182
07:08:11 <lambdabot> Title: #1182 (splitAt does not implement H98 report behaviour, it is too strict in 'n') ...
07:09:23 <sjanssen> tricky tricky
07:10:52 <resiak> Doesn't lambdabot use GHC's source?
07:10:57 <resiak> (for @src, that is)
07:11:22 <dcoutts_> @src splitAt
07:11:22 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
07:11:30 <dcoutts_> well that's not what GHC uses
07:11:36 <dcoutts_> nor hugs
07:11:43 <dcoutts_> that's what the H98 report says
07:11:49 <sjanssen> resiak: @src takes info from several locations
07:12:09 <resiak> sjanssen: Then I had misremembered discussions about it!
07:12:17 <sjanssen> so some definitions are from the report, and some are from GHC
07:12:39 <resiak> hrm, okay.
07:18:58 <fantasma> do you need semicolons after guards?
07:19:04 <dcoutts_> no
07:19:11 <dcoutts_> you never need semicolons
07:19:17 <fantasma> > let divi a b | b < 0 = 1 + divi (a+b) b | b >= 0 = 1 + divi (a-b) b in divi 10 5
07:19:19 <dcoutts_> they're always optional if you use layout
07:19:21 <lambdabot> Terminated
07:20:14 <fantasma> i don't understand what's wrong with that
07:20:23 <gaal> so, how does one go about creating a .deb out of a package that already uses cabal? (lambdabot wants arrows)
07:20:44 <Igloo> fantasma: In no case does it terminate
07:21:29 <Igloo> gaal: apt-get install libghc6-arrows-dev
07:21:43 <fantasma> > let divi a b | b < 0 = 1 + divi (a+b) b | b >= 0 = 1 + divi (a-b) b | True = 0 in divi 10 5
07:21:46 <lambdabot>  Exception: stack overflow
07:22:04 <sjanssen> fantasma: you'll never reach the True branch
07:22:17 <fantasma> i just messaged the same thing to the bot and it worked
07:22:37 <sjanssen> fantasma: the program will always take the first or second branch
07:22:54 <fantasma> yah
07:23:12 <fantasma> should I add a base case?
07:24:10 <gaal> Igloo: oh, I missed that. what provides the zlib dependency it looks for?
07:24:19 <Igloo> Nothing
07:24:49 <gaal> is there an easy way to create .debs for haskell packages?
07:25:27 <sjanssen> fantasma: yes, and it needs to be before the first two cases
07:25:35 <Igloo> If you get the source for the arrows deb then you should be able to package zlib just by copying the debian/ directory and changing only the meta-data
07:26:20 <gaal> Igloo: okay, thanks
07:26:53 <Igloo> Feel free to yell if you get stuck
07:26:58 <fantasma> thanks sjanssen
07:27:27 <xs> sjanssen, if b :: Double, then NaN is not < 0 nor >= 0.
07:27:36 <Igloo> gaal: Oh, you want to change the .in files where they exist and then run update-haskell-control
07:28:34 <gaal> before dpkg, right?
07:28:40 <Igloo> Yup
07:29:03 <kombinator> dcoutts_: I wanted to make some example where I would underline misspelled words in a text entry, but I don't know if that's possible
07:29:27 <xs> > if (0/0) < 0 then "heh" else (if (0/0) >= 0 then "heh2" else "hmm")
07:29:29 <lambdabot>  "hmm"
07:29:32 <kombinator> dcoutts_: or I have to use TextView
07:29:42 <dcoutts_> kombinator, hmm, not sure either. It's certainly possible with a TextView/TextBuffer, but the Entry is a good deal simpler.
07:31:08 <sjanssen> xs: this is true (but it is a fact I'd rather ignore :)
07:32:59 <xs> sjanssen, :) it can lead to amusing bugs.
07:33:38 <Saizan> > compare (0/0) 0
07:33:40 <lambdabot>  GT
07:33:58 <xs> > compare 0 (0/0)
07:33:59 <lambdabot>  GT
07:34:03 <xs> <3
07:34:43 <sjanssen> > let x = 0/0 in compare x x
07:34:45 <lambdabot>  GT
07:35:08 <xs> > compare (1/0) (0/0)
07:35:10 <lambdabot>  GT
07:35:11 <xs> > compare (1/0) (1/0)
07:35:12 <lambdabot>  EQ
07:35:34 <xs> floating point numbers are horrid.
07:35:36 <Saizan>  mmh, is it implemented something like if x == y then EQ else (if x < y then LT else GT) ? :D
07:35:59 <xs> no, because:
07:36:04 <xs> > compare (0/0) (0/0)
07:36:07 <lambdabot>  GT
07:36:15 <Saizan> > NaN == NaN
07:36:16 <lambdabot>   Not in scope: data constructor `NaN'
07:36:19 <Igloo> Urgle, compare a b == GT <=> a > b   really ought to hold
07:36:31 <Saizan> > (0/0) == (0/0)
07:36:33 <lambdabot>  False
07:36:56 <xs> it should :)
07:36:58 <michaelw> well, floating point comparison with equality is problematic anyway
07:37:08 <Igloo> Should compare (0/0) (0/0) diverge?
07:37:31 <sjanssen> Igloo: I think 0/0 is well defined in the IEEE spec
07:37:53 <xs> it's quite nasty how NaN can propagate. makes the source very hard to find.
07:37:59 <Igloo> sjanssen: OK, but that doesn't tell us what compare (0/0) (0/0) should be, does it?
07:38:05 <Saizan> 0/0 is NaN, and is not equal, gtreter  or less than any other number even NaN
07:38:07 <sjanssen> oh, but you're asking whether the comparison should diverge
07:38:32 <sjanssen> Igloo: it should either diverge or return EQ
07:40:46 <sjanssen> EQ might be justified, because we already have some bogus comparisons
07:41:07 <sjanssen> like compare inf inf = EQ
07:42:55 <Saizan>  > sort $ [1..(10::Double)]++[(0/0)]++[6..(10::Double)] -- ugly
07:43:03 <Saizan> > sort $ [1..(10::Double)]++[(0/0)]++[6..(10::Double)]
07:43:05 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,6.0,7.0,7.0,8.0,8.0,9.0,10.0,NaN,9.0,10.0]
07:43:32 <xs> heh
07:43:41 <alexj> hmm.  seems like referential integrity would require that fun x y = fun x y
07:43:49 <alexj> fun x y == fun x y
07:43:58 <alexj> s/integrity/transparency/
07:44:07 <xs> why is NaN a value instead of a run-time error btw? i never understood this.
07:44:30 <sjanssen> > foldl (flip insert) [] $ [1..(10::Double)]++[(0/0)]++[6..(10::Double)]
07:44:31 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,6.0,7.0,7.0,8.0,8.0,9.0,9.0,10.0,10.0,NaN]
07:44:56 <sjanssen> > foldr insert [] $ [1..(10::Double)]++[(0/0)]++[6..(10::Double)]
07:44:58 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,6.0,7.0,7.0,8.0,8.0,9.0,9.0,10.0,10.0,NaN]
07:45:11 <alexj> fun x y == fun x y (even if fun = (/) and x=0 and y=0)?
07:45:16 <Saizan> ?type insert
07:45:17 <sjanssen> xs: IEEE 754 says that NaN is a value
07:45:20 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
07:45:28 <Saizan> ?src sort
07:45:29 <lambdabot> sort = sortBy compare
07:45:31 <xs> sjanssen, but why?
07:45:55 <Saizan> heh, instert uses Ord methods, sort uses compare, it the src is what is done in ghc
07:46:18 <xs> ?src insert
07:46:18 <lambdabot> insert e ls = insertBy (compare) e ls
07:46:27 <xs> ?src insertBy
07:46:28 <lambdabot> insertBy _   x [] = [x]
07:46:28 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
07:46:28 <lambdabot>                                  GT -> y : insertBy cmp x ys'
07:46:28 <lambdabot>                                  _  -> x : ys
07:46:41 <Saizan> ?src sortBBy
07:46:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:46:45 <Saizan> ?src sortBy
07:46:45 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:47:08 <sjanssen> xs: I have no idea
07:47:36 <sjanssen> Saizan: that is the definition in the report -- ghc and hugs use a nice merge sort in reality
08:20:26 <Laney_> Is there an IO function to clear the screen?
08:20:53 <apfelmus> ?hoogle launchMissiles
08:20:54 <lambdabot> No matches found
08:21:19 <apfelmus> ?hoogle clear
08:21:20 <lambdabot> Text.Html.clear :: String -> HtmlAttr
08:21:20 <lambdabot> Data.Bits.clearBit :: Bits a => a -> Int -> a
08:21:20 <lambdabot> System.Console.Readline.clearMessage :: IO ()
08:22:18 <apfelmus> Laney: most likely, you'd have to use a curses binding or similar.
08:22:27 <apfelmus> @where vty
08:22:28 <lambdabot> http://members.cox.net/stefanor/vty/
08:23:02 <Laney> Ah, I'll check it out. Thanks apfelmus
08:23:57 <fantasma> is there a way to include an OR statement in a guard without using another guard
08:23:57 <apfelmus> you're welcome
08:25:02 <sjanssen> fantasma: || ?
08:25:07 <sjanssen> > True || False
08:25:09 <lambdabot>  True
08:26:07 <arcatan> > False || True
08:26:08 <lambdabot>  True
08:27:29 <fantasma> in the guard i want to "say" if a OR b > 0 then blah....
08:27:49 <fantasma> i dont want a boolean
08:28:20 <ClaudiusMaximus> > let a = 1; b = -1 in a > 0 || b > 0
08:28:21 <lambdabot>  True
08:28:34 <apfelmus> > let f n |n == 0 || n < 0 = 1 | otherwise = n * f (n-1) in f 6
08:28:35 <lambdabot>  720
08:29:14 <fantasma> ah, works :)
08:37:40 <vincenz> @paste
08:37:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:38:01 <hpaste>  vincenz pasted "for #squeak" at http://hpaste.org/689
08:45:36 <nmessenger> style question for everyone: which do you find clearer? (let loop = ... loop ... in loop) or (fix $ \loop -> ... loop ...)?
08:46:33 <glguy> we have to pick one of the two?
08:46:55 <nmessenger> you don't *have* to, I'm just asking for style points.
08:47:09 <glguy> the first then
08:47:12 <sjanssen> I don't have a strong preference for either
08:47:36 <glguy> though, generally I would prefer to see you use a higher order function
08:47:52 <glguy> forever x = x >> forever x
08:47:56 <glguy> and iterate
08:48:07 <emu> @hoogle forever
08:48:07 <lambdabot> No matches found
08:48:11 <malcolmw> Laney: putStrLn Language.Haskell.HsColour.ANSI.cls
08:48:21 <malcolmw> Laney: or equivalently, putStrLn "\ESC[2J"
08:48:41 <nmessenger> I'm using it in the middle of a 'do' block to implement a language's while loop, and using a higher-order function wasn't obvious to me.
08:49:04 <fantasma> is there a way to switch the values around of two variables? (eg. a and b)
08:49:19 <nmessenger> it's actually (let loop = ... when (blah) (foo >> loop) ... in loop)
08:49:24 <glguy> whileM pred body = pred >>= flip when (body >> whileM pred body)
08:49:56 <glguy> whileM pred body = aux where aux = pred >>= flip when (body >> aux)
08:50:54 <syntaxfree> I think I don't understand why MonadFix/mfix is interesting.
08:51:08 <sjanssen> fantasma: no, variables aren't mutable in Haskell
08:51:19 <glguy> it lets you refer to an object while constructing that object
08:51:25 <glguy> like in a C++ constructor
08:51:29 <syntaxfree> fantasma: an interesting initial mental model of Haskell is that of a spreadsheet.
08:51:43 <syntaxfree> a simultaneous system of equations is a nice mental model as well.
08:52:18 <syntaxfree> (both are flawed at some point)
08:52:49 <fantasma> so I would have to write a new function for the variable?
08:53:26 <fantasma> i mean a new guard
08:54:11 <fantasma> nvm ;) im asking stupid questions
08:54:33 <earthy> hm. shuffling data to and from C code can be quite expensive
08:55:05 <apfelmus> nmessenger: most often, mapM or foldM can do
08:55:11 <earthy> but let's see if I can fix the memory churn problems in the haskell code first
08:55:12 <syntaxfree> I arrived late. What's going on?
08:55:21 <syntaxfree> (with fantasma)
08:55:47 <glguy> ?hoogle unfoldM
08:55:48 <lambdabot> No matches found
08:56:04 <fantasma> I'm new to haskell and I'm trying to write a recursive integer division function
08:56:18 <araujo> m
08:56:22 <shapr> r
08:56:22 <fantasma> > let divi a b | a < 0 = (-1) + divi (a+b) b | a >= b = 1 + divi (a-b) b | True = 0 in divi 10 5
08:56:23 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
08:56:24 <lambdabot>  2
08:56:24 <araujo> fantasma, spanish speaker?
08:56:34 <Vq^> 'lo shapr
08:56:40 <fantasma> araujo, un poco
08:56:41 <apfelmus> > let min a b = if a >= b then a else min b a in min 2 4
08:56:42 <lambdabot>  4
08:56:50 <apfelmus> fantasma: ^^
08:57:14 <fantasma> what's the function min do?
08:57:26 <apfelmus> oops :)
08:57:37 <glguy> > let divi a b | a > b = 1 + divi (a-b) b | otherwise = 0 in divi 25 4
08:57:39 <lambdabot>  6
08:57:50 <araujo> fantasma, ok, i just though so because of your nick .. in any case , we also have #haskell.es for spanish speakers
08:58:05 <fantasma> my primary language is english, i just like the word :)
08:58:13 <araujo> haha ok
08:58:23 <apfelmus> min is a max in disguise
08:58:38 <fantasma> i also want to be able to divide negatives
08:59:10 <syntaxfree> > let divi = div in divi -2 5
08:59:11 <lambdabot>        add an instance declaration for (Num (t -> a -> a -> a))
08:59:32 <glguy> > (-2) `div` 5
08:59:34 <lambdabot>  -1
08:59:49 <apfelmus> > (-2) `mod` 5
08:59:50 <lambdabot>  3
08:59:53 <bd_> > {-# OPTIONS -fno-monomorphism-restriction #-} let divi = div in divi -2 5
08:59:54 <lambdabot>        add an instance declaration for (Num (t -> a -> a -> a))
08:59:57 <bd_> tsk
09:00:04 <nmessenger> glguy: cool, I think it works
09:00:21 <syntaxfree> jeez. I didn't realize compiler pragmas were allowed in @eval.
09:00:25 <glguy> > let divi a b | a < 0 = divi (-a) b - 1 | a > b = 1 + divi (a-b) b | otherwise = 0 in divi (-2 ) 5
09:00:26 <lambdabot>  -1
09:00:30 <glguy> > let divi a b | a < 0 = divi (-a) b - 1 | a > b = 1 + divi (a-b) b | otherwise = 0 in divi (-6 ) 5
09:00:32 <lambdabot>  0
09:00:38 <glguy> oops :)
09:00:46 <sjanssen> syntaxfree: they're not supposed to be allowed
09:00:48 <fantasma> glguy, yes divide works but only when a is negative
09:00:58 <glguy> > let divi a b | a < 0 = -(divi (-a) b + 1) | a > b = 1 + divi (a-b) b | otherwise = 0 in divi (-6 ) 5
09:01:00 <fantasma> glguy, i want it to work when b is negative
09:01:00 <lambdabot>  -2
09:01:03 <glguy> ah
09:01:39 <fantasma> i was thinking just switching a and b around with b is negative but I guess this wont work since haskell is not mutable
09:01:49 <glguy> > let divi a b | b < 0 = divi (-a) (-b) | a < 0 = -(divi (-a) b + 1) | a > b = 1 + divi (a-b) b | otherwise = 0 in divi 3 (-2)
09:01:51 <lambdabot>  -2
09:02:19 <fantasma> hmmm
09:02:48 <fantasma> > let divi a b | b < 0 div (-a) (-b) | a < 0 = (-1) + divi (a+b) b | a >= b = 1 + divi (a-b) b | True = 0 in divi 10 (-5)
09:02:48 <lambdabot>  Parse error
09:02:57 <fantasma> oops
09:03:13 <nmessenger> > div 10 (-2)
09:03:15 <lambdabot>  -5
09:03:22 <fantasma> > let divi a b | b < 0 = div (-a) (-b) | a < 0 = (-1) + divi (a+b) b | a >= b = 1 + divi (a-b) b | True = 0 in divi 10 (-5)
09:03:23 <lambdabot>  -2
09:03:36 <fantasma> > let divi a b | b < 0 = divi (-a) (-b) | a < 0 = (-1) + divi (a+b) b | a >= b = 1 + divi (a-b) b | True = 0 in divi 10 (-5)
09:03:37 <lambdabot>  -2
09:03:39 <fantasma> nice
09:04:32 <hpaste>  glguy pasted "simple divi" at http://hpaste.org/690
09:04:56 <syntaxfree> test :: State Int String
09:04:57 <syntaxfree> test = State 2 "Oh bitty box!"
09:05:00 <sjanssen> fantasma: can you call "divi b a" in the case that b is negative?
09:05:05 <syntaxfree> jeeze, why can't I simply use a data constructor?
09:05:16 <nmessenger> @type State
09:05:18 <sjanssen> of course you'll get an infinite loop if both are negative
09:05:18 <lambdabot> forall s a. (s -> (a, s)) -> State s a
09:05:23 <nmessenger> needs a function
09:05:28 <sjanssen> syntaxfree: because that isn't the type of State
09:05:38 <syntaxfree> ah, of course.
09:05:43 <fantasma> > let divi a b | b < 0 = div (-a) (-b) | a < 0 = (-1) + divi (a+b) b | a >= b = 1 + divi (a-b) b | True = 0 in divi (-10) (-5)
09:05:44 <lambdabot>  2
09:05:44 <syntaxfree> sure, sure, it's defined as a record.
09:05:46 <syntaxfree> I just saw it.
09:05:48 <fantasma> wow fantastic
09:05:52 <fantasma> thank you glguy
09:05:59 <syntaxfree> the record syntax confused me.
09:06:13 <nmessenger> yeah, I'm not sure I like it a whole lot.
09:06:25 <fantasma> I have to go to class now, thanks everyone
09:06:39 <syntaxfree> yes, yes. Sorry.
09:06:46 <nmessenger> data State s a = State (s -> (a, s); runState (State f) st0 = f st0
09:07:02 <nmessenger> (oops missed a right paren)
09:07:13 <syntaxfree> yes, the record syntax made me thing State s a was the data constructor, when it's the type constructor.
09:07:32 <syntaxfree> mo' fool me.
09:07:47 <syntaxfree> (the record syntax in the Control.Monad.State source)
09:07:56 <glguy> syntaxfree: that had nothing to do with record syntax..
09:08:08 <syntaxfree> newtype State s a = State { runState :: s -> (a, s) }
09:08:23 <syntaxfree> of course, this is equivalent to State (s -> (a, s))
09:08:26 <nmessenger> test = return "Oh bitty box!"
09:09:00 <nmessenger> {- or more low-level: -} test = State (\s -> ("Oh bitty box!", s))
09:09:03 <syntaxfree> I'm trying to rebuild things from the ground up, so to speak.
09:09:09 <syntaxfree> yes, yes.
09:10:02 <glguy> State ((,) "Oh bitty box!")
09:10:03 <syntaxfree> I just got confused by the record-as-automatic-destructor thing.
09:10:09 <nmessenger> heh
09:10:32 <nmessenger> (State . (,)) is State's return :)
09:13:58 <syntaxfree> hmm. the definition of MonadState uses a fundep.
09:14:53 <nmessenger> syntaxfree: yeah.  I don't understand fundeps but it's use in MonadState makes sense to me
09:14:59 <nmessenger> @src MonadState
09:14:59 <lambdabot> Source not found. That's something I cannot allow to happen.
09:15:39 <syntaxfree> I'm always stumbling into fundeps in whatever I try to do.
09:15:56 <syntaxfree> I keep on trying to use type classes to define super general interfaces because I'm not sure of what data structures to use, and.
09:16:03 <syntaxfree> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
09:16:41 <nmessenger> MonadState m s | m -> s, i.e. 'm' is the full Monad, so it contains the 's'.  The 's' needs to be included in the class def in order to be used in the methods, so we tell the compiler "when you have 'm', you'll have 's' since it's a part of it"
09:17:08 <syntaxfree> yes, yes.
09:18:44 <hpaste>  nmessenger pasted "No question, just showing my while-loop code with whileM" at http://hpaste.org/691
09:24:10 <LordBrain> hmmmmmm readFile must do some kind of conversion on linefeeds or something
09:24:36 <syntaxfree> :src readFile
09:24:41 <syntaxfree> @src readFile
09:24:42 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
09:24:56 <chessguy> gotta love haskell one-liners
09:24:57 <syntaxfree> bah, hGetContents is blackboxy, I think.
09:25:29 <chessguy> ?src hGetContents
09:25:30 <lambdabot> Source not found. Are you on drugs?
09:25:36 <nmessenger> readBinaryFile name = openBinaryFile name ReadMode >>= hGetContents
09:25:57 <nmessenger> @src hGetContents
09:25:57 <lambdabot> Source not found. I feel much better now.
09:26:11 <chessguy> @quote feel
09:26:11 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
09:26:18 <LordBrain> its giving me some kind of unix dos linefeed strangeness
09:26:24 <LordBrain> i'm running it under cygwin
09:26:44 <LordBrain> oh
09:26:52 <LordBrain> readBinaryFile... i should just use that
09:27:16 <nmessenger> so you're getting '\x0A's at the end of each line?
09:27:36 <LordBrain> well
09:27:50 <LordBrain> i was looking at a text file i made to test... but i really do mean this to be a binary file
09:28:01 <LordBrain> anyway, i had the text file in dos format
09:28:22 <LordBrain> and i was searching for the  0d it was putting in beore the 0A
09:28:55 <LordBrain> hmmm
09:29:39 <LordBrain> oh, you just wrote that, i thought it was in there already
09:30:04 <nmessenger> :)
09:32:22 <chessguy> nmessenger, did you hear? my GP framework is up and running
09:32:29 <chessguy> in desparate need of a refactor, but it runs
09:32:30 <nmessenger> \o/
09:33:05 <norpan> nmessenger: is that an obscene image? :)
09:33:06 <shapr> hiya Vq^
09:33:23 <nmessenger> \o/ <-- hands thrown in the air "Yay!"
09:33:31 <chessguy> shapr!
09:34:00 <nmessenger> chessguy: first thing I'd do is instance MonadRandom GlobalState
09:34:00 <shapr> chessguy!
09:34:20 <LordBrain> its a shame they didnt make dos unix compatable in the first place.... when it comes to text files, and its especially odd when you consider that the unix format is the tighter one of the two..
09:34:23 <fons> @source intersperse
09:34:23 <lambdabot> intersperse not available
09:34:31 <chessguy> shapr, sent my code over this morning
09:34:31 <nmessenger> er, RandomGen GlobalState
09:34:35 * chessguy crosses fingers
09:34:46 <chessguy> ermm
09:35:05 <chessguy> well, GlobalState will have more than just a randomGen
09:35:06 <shapr> chessguy: Cool! I hope it works out for ya!
09:35:33 <nmessenger> chessguy: yes but since it has a StdGen inside it, it can be treated directly like an RNG source.
09:35:51 <chessguy> hmmm
09:36:42 <chessguy> i'm not sure how that would look
09:37:08 <nmessenger> instance RandomGen GlobalState where next gs = (x,gs{randomGen = g}) where (x,g) = next (randomGen gs)
09:37:33 <chessguy> but how would the client look?
09:37:53 <nmessenger> randomR (0,blah) someGlobalState
09:38:46 <chessguy> hmmm]
09:38:56 <nmessenger> that gets the randomGen, gets the number, and updates the randomGen all at once.
09:39:58 <nmessenger> inside a State GlobalState a, it'll look just like "do x <- State $ randomR (0,blah)"
09:40:21 <nmessenger> (if I haven't made any errors)
09:40:22 <chessguy> huh?
09:40:25 <chessguy> State $ ?
09:40:36 <nmessenger> @type randomR undefined
09:40:39 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
09:40:42 <nmessenger> @type State
09:40:45 <lambdabot> forall s a. (s -> (a, s)) -> State s a
09:41:00 <nmessenger> State turns the (g -> (a, g)) into a (State s a)
09:41:11 <nmessenger> er, (State g a)
09:41:32 <chessguy> interesting
09:41:38 <chessguy> and i'd have to import MonadRandom, right?
09:41:59 <nmessenger> I goofed, I didn't mean MonadRandom, I meant RandomGen
09:42:27 <chessguy> oh, in the standard library
09:42:49 <bos> @where regex-tdfa
09:42:49 <lambdabot> I know nothing about regex-tdfa.
09:43:09 <bos> @where+ regex-tdfa http://darcs.haskell.org/packages/regex-tdfa/
09:43:10 <lambdabot> Done.
09:43:11 <bos> @where regex-tdfa
09:43:12 <lambdabot> http://darcs.haskell.org/packages/regex-tdfa/
09:43:14 <bos> better.
09:43:15 <nmessenger> a MonadRandom is just a State g for some RandomGen g, (modulo Monad Transformers)
09:43:37 <nmessenger> so that'd get rid of *more* boilerplate :)
09:43:42 <chessguy> interesting
09:43:57 <chessguy> getting rid of boilerplate is a good thing
09:44:56 <chessguy> i'll play around with that, thanks
09:45:07 <nmessenger> so above, if you make GlobalState a RandomGen, it can be used in randomR, and the State constructor makes it into a (State GlobalState a) action.
09:45:39 <chessguy> my first concern is better separation between the library and client code
09:45:54 <chessguy> right now it's all one giant file
09:46:19 <chessguy> well, giant by haskell standards, by which i mean about 200 LOC
09:46:25 <nmessenger> :D
09:47:17 <earthy> that's not giant.
09:47:38 <earthy>      439 src/XTC.hs
09:47:44 <earthy>      336 src/PersistentDocument.hs
09:47:54 <earthy>     1023 src/LauritzenSpiegelhalter.hs
09:48:07 <earthy>      612 src/DataBrowser.hs
09:48:12 <chessguy> for a newbie hobbyist who has a heckuva time finding time to hack on it, it is
09:48:12 <earthy>    16729 total
09:48:19 * earthy grins
09:48:25 <earthy> yeah, then it is. :)
09:48:37 <chessguy> it represents several weeks of hard work
09:48:49 * earthy understands that
09:49:16 <earthy> this is about two years worth, of, by now, 3 programmers. I think it amounts to 3.2 manyears
09:49:27 <chessguy> by the way, your algorithm didn't make the cut, earthy :)
09:49:42 <earthy> hm? which algorithm?
09:49:59 <chessguy> finding a random subtree
09:50:07 <earthy> ah. ;)
09:50:18 <earthy> why not?
09:50:21 <chessguy> sjanssen had a pretty suggestion
09:50:36 <chessguy> he had an O(n) way to generate the paths to all the subtrees
09:50:37 <sjanssen> I did?!
09:50:53 <chessguy> sjanssen, wasn't that you?'
09:50:57 <earthy> um, generating a full subtree is O(log n)
09:51:13 <earthy> assuming sharing
09:51:19 <earthy> otherwise it's O(n), yeah
09:51:24 <sjanssen> chessguy: yeah, I remember now
09:51:44 <bos> does chris kuklewicz ever hang out in #haskell?
09:52:53 <earthy> hm. am I going to wait for another 40 minutes for that profile to be calculated or am I going to go home and start cooking dinner
09:53:37 <fantasma> anyone know what languages Project Euler problems can be done in?
09:53:57 <sjanssen> bos: I think his nick is TuringTest
09:54:01 <chessguy> i think they're listed on the site
09:54:02 <sjanssen> @seen TuringTest
09:54:03 <lambdabot> I haven't seen TuringTest.
09:54:30 <shapr> aww
09:54:55 <sjanssen> shapr: can you corroborate?
09:55:07 <bos> sjanssen: thanks
09:55:26 <bos> i'm trying to build his regex-tdfa package, and failing.
09:55:39 <fantasma> chessguy, it doesn't say
09:56:51 <chessguy> fantasma, hmm. i'd @ask glguy
09:57:08 <fantasma> thanks
09:57:09 <taras> what would be a good channel to ask about general compiler stuff? i'm trying to find the name of the algorithm that inferes domain of variables based on conditionals ie if(x) { if (!x) {obviously this code wont execute}}
09:57:18 <Saizan> fantasma: why would that count? you just have to solve the problems, i've seen solve them using assembly,J,Java, python etc..
09:57:36 <earthy> taras: you're looking for data flow or control flow analysis
09:57:36 <fantasma> Saizan, I'm just wondering how it works
09:57:45 <fantasma> do they check to see if you're right?
09:57:53 <taras> earthy i'm looking for this so i can optimize my control flow graph
09:58:22 <ddarius> fanasma: Presumably hey simply provide the correct output.
09:58:50 <earthy> does http://www.cs.uu.nl/wiki/Apa/CourseLiterature help?
09:58:51 <lambdabot> Title: APA / Course Literature
09:59:00 <Saizan> fanstasma: you just have to enter the correct computed solution in the input field
09:59:38 <fantasma> Saizan, ah, I see! Thanks!
10:05:59 <taras> earthy i dont see anything for infering value of a variable based on how it's used in a conditional
10:09:39 <chessguy> is there an abstraction i'm missing if i do something like this?
10:09:40 <chessguy> data Foo1 = Bar1 | Baz1 | Bah1 | Custom1 Some->Type
10:09:40 <chessguy> data Foo2 = Bar2 | Baz2 | Bah2 | Custom2 Some->Other->Type
10:09:40 <chessguy> data Foo3 = Bar3 | Baz3 | Bah3 | Custom3 Yet->Another->Type
10:09:40 <chessguy> ...
10:09:49 <taras> earthy nm i didnt see your last message, thanks!
10:11:32 <nmessenger> chessguy: you're missing parens for one thing :).  Do the various Bars Bazzes and Bahs represent the same thing?
10:11:37 <allbery_b> data Foo a = Bar | Baz | Bah | Custom a
10:11:39 <allbery_b> ?
10:12:00 <chessguy> parens where? and no, they're not the same
10:12:20 <chessguy> the different datatypes aren't really related
10:12:34 <opqdonut> well then i guess there is no abstraction really
10:12:38 <chessguy> it's for parameters
10:13:21 <nmessenger> (you need parens around the function types, but I'm still thinking about your question)
10:13:37 <chessguy> oh you mean Custom1 (Some->Type)
10:13:42 <nmessenger> yep
10:13:48 <chessguy> yeah, ok
10:14:11 <chessguy> there's really no relation between the Foo's, it's just something i have to do many times
10:14:14 <opqdonut> as those cases really don't have anything in common except the final case takes a function argument
10:14:30 <opqdonut> s/except/& that/
10:14:41 <nmessenger> chessguy: maybe a more concrete example'll give us more ammo?
10:14:44 <nmessenger> @paste
10:14:44 <chessguy> basically, for each one, i want to provide several possible ways to do something, or let you define your own custom way
10:14:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:14:56 <chessguy> i don't have any code yet
10:15:30 <opqdonut> chessguy: couldn't you just make it data Foo1 = Custom a->b and have "constructors" that handle the default cases?
10:15:31 <chessguy> hmm. nmessenger, are you familiar with GP?
10:15:34 <opqdonut> just an idea
10:15:37 <nmessenger> nope
10:15:44 <chessguy> i know opqdonut is :)
10:15:52 <opqdonut> :)
10:16:17 <opqdonut> chessguy: about that paper, i'll probably have to translate it into english in a few months
10:16:17 <chessguy> well, say you Foo1 was a parameter for selecting an item from a list
10:16:35 <opqdonut> because of external reasons, but i'll forward it to you if you're still interested
10:16:46 <chessguy> opqdonut, cool! by that time, maybe my framework will be working well enough that i'll rewrite your code to use it, for fun :)
10:16:48 <opqdonut> i'll just have to get these exams out of the way before starting on it
10:16:58 <opqdonut> heh sounds nice :)
10:17:23 <chessguy> nmessenger, one method might be First, which just takes the head
10:17:35 <chessguy> nmessenger, another might be Last, which takes the last member
10:17:55 <chessguy> but you also want to leave open the possibility of defining your own way, and setting the parameter to that
10:18:36 <opqdonut> i really recommend making first and last functions
10:18:37 <nmessenger> then perhaps newtype ListGetter = LG ([a] -> a), and ready-made functions of this type?
10:18:37 <chessguy> so that you can you can do Select :: [a] -> Foo1 -> a
10:18:52 <opqdonut> and then you can instaniate with "first" as the argument
10:18:57 <opqdonut> would be easier
10:19:19 <nmessenger> depends on how much you need to encode directly in the type.
10:19:32 <chessguy> opqdonut, yeah, but i want to provide them through the library, but setting a parameter
10:19:39 <chessguy> s/but/by/
10:20:15 <opqdonut> but you could provide the functions in the library
10:20:22 <nmessenger> chessguy: you'd export Bar1, Baz1, and Bah1 anyway, right?  So you could export bar1, baz1, and bah1 of the ListGetter type instead.
10:20:29 <opqdonut> of course then you can't match against Last which might be suboptimal
10:20:40 <chessguy> well, that's the point, i don't want to export Bar, Baz, and Bah
10:20:52 <chessguy> well, not the functions they represent anyway
10:20:56 <opqdonut> chessguy: btw heard about eurogen07?
10:21:02 <opqdonut> http://www.mit.jyu.fi/scoma/Eurogen2007/
10:21:04 <lambdabot> Title: EUROGEN 2007, Jyvskyl, Finland, June 11-13, 2007
10:21:05 <fantasma> why is (x:xs) used to represent a list as opposed to [x:xs]?
10:21:12 <opqdonut> sadly my paper was not accepted
10:21:17 <chessguy> opqdonut, :(
10:21:24 <xerox> fantasma: that's because (:) is the list constructor.
10:21:27 <chessguy> finland is a long way for me to go
10:21:28 <opqdonut> my first submission ever, my abstract was probably miserable
10:21:29 <nmessenger> [x:xs] = ((x:xs):[])
10:21:54 <fantasma> xerox, nmessenger: thanks
10:21:57 <int-e> @type (:)
10:22:00 <lambdabot> forall a. a -> [a] -> [a]
10:22:03 <opqdonut> > 1:[2,3]
10:22:05 <lambdabot>  [1,2,3]
10:22:05 <chessguy> so i want the user to be able to say "use the First method of selection", without worrying about how to implement it
10:22:13 <opqdonut> > 1:2:3:[]
10:22:14 <lambdabot>  [1,2,3]
10:22:30 <opqdonut> chessguy: yeah but you could offer these methods of selection as library functions
10:22:34 <opqdonut> same level of abstraction
10:22:38 <fantasma> > 1==1
10:22:38 <xerox> > let f [a,b,c] = b in f [1,2,3] -- fantasma, you can do that, but the list length becomes fixed, for the match to be right.
10:22:40 <lambdabot>  True
10:22:40 <lambdabot>  2
10:22:58 <nmessenger> chessguy: you'll have to actually implement the extract at some point, right?
10:23:14 <chessguy> nmessenger, you mean select?
10:23:22 <nmessenger> yeah
10:23:29 <chessguy> yes, but i don't want to export that
10:23:32 <fantasma> > [1,2,3] == ((1,2,3):[])
10:23:33 <lambdabot>   add an instance declaration for (Num (t, t1, t2))
10:23:33 <lambdabot>     In the expression: 3
10:23:43 <chessguy> i just want to export the names of the methods, or the ability to custom-define their own
10:23:49 <xerox> > 1 : 2 : 3 : [] -- which associates to the right.
10:23:51 <lambdabot>  [1,2,3]
10:23:55 <fantasma> > [1,2,3] == (1,2,3):[]
10:23:56 <lambdabot>   add an instance declaration for (Num (t, t1, t2))
10:23:56 <lambdabot>     In the expression: 3
10:24:08 <int-e> fantasma: those two lists have different types
10:24:09 <nmessenger> be it by matching select First (x:xs) = x, or first = LG (\(x:xs) -> x)
10:24:13 <int-e> @type [1,2,3]
10:24:15 <lambdabot> forall t. (Num t) => [t]
10:24:18 <int-e> @type (1,2,3):[]
10:24:18 <chessguy> like data Selection = First | Last | Custom [a] -> a
10:24:20 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => [(t, t1, t2)]
10:24:31 <chessguy> Custom ([a] -> a)
10:24:41 <int-e> fantasma: (1,2,3):[] is a list of triplets, because (1,2,3) is a triplet
10:24:57 <fantasma> > [x:xs] == ((x:xs):[])
10:24:58 <lambdabot>   Not in scope: `xs'
10:25:16 <xerox> fantasma: check out the type of (:).
10:25:17 <int-e> > [1:[]] == (1:[]):[]
10:25:19 <lambdabot>  True
10:25:33 <opqdonut> int-e: trivially :)
10:25:36 <chessguy> i want to hide the underlying plumbing of the library, but make it accessible to the client
10:26:01 <int-e> @check \x xs -> [x :: Int:xs] == ((x:xs):[])
10:26:01 <lambdabot>  Parse error
10:26:05 <fantasma> thanks int-e
10:26:26 <opqdonut> chessguy: i still haven't understood why you can't export the preset functions
10:27:02 <chessguy> i think it would complicate the interface
10:27:08 <opqdonut> not necessarily
10:27:15 <opqdonut> you could, say, put them into a submodule
10:27:32 <opqdonut> it's up to you, i'm just saying there's nothing inherently wrong with this alternative
10:27:40 <opqdonut> (except that you lose matching)
10:27:40 <chessguy> there are already-known methods for doing a lot of these things, and the client should just be able to call them by name
10:27:49 <nmessenger> @check \x xs -> [(x::I):xs] == ((x:xs):[])
10:27:51 <lambdabot>  OK, passed 500 tests.
10:28:00 <chessguy> I??
10:28:05 <nmessenger> type I = Int
10:28:06 <opqdonut> well they would have names even if they were defined in the library
10:28:32 <nmessenger> not sure where that's defined, though.  I saw SamB using it yesterday.
10:28:46 <jyasskin> I discovered today that Data.Graph.Inductive.Tree has really weird performance. Who'da thunk that buildGr would be faster than mkGraph? Including reading the data from disk, the time went from 5s to .3s.
10:28:47 <opqdonut> "f = Foo last" vs. "f = Last"
10:29:15 <chessguy> opqdonut, hmm
10:29:29 <opqdonut> would also simplify calling them
10:29:42 <opqdonut> as you wouldn't have to handle the preset ones as special cases
10:29:50 <chessguy> parameters { SelectionMethod = tournamentSelection }
10:29:54 <opqdonut> you could just add a function into the library instead of updating the case
10:29:57 <chessguy> i guess that's pretty much the same
10:30:06 <opqdonut> yup
10:30:29 <opqdonut> bah, i'm losing my haskell intuition... haven't coded anything high-level since that paper
10:30:32 <opqdonut> just C
10:30:35 <opqdonut> and a bit of python
10:30:45 <opqdonut> oh well quite a lot of lua also
10:30:47 <nmessenger> except in the second case you'll have to define select Last = last
10:31:06 <nmessenger> and select (Custom f) = f
10:31:19 <opqdonut> exactly
10:31:25 <chessguy> there's just not a nice neat list any more
10:31:44 <chessguy> that says "here are your options, and if you don't like them, define your own"
10:32:01 <chessguy> and yeah, i guess that's what documentation is for
10:32:22 <opqdonut> :)
10:32:31 <opqdonut> -- your options are: ...
10:32:47 <_frederik_> hello
10:32:56 <_frederik_> what do i do when ghc says: <no location info>: file name does not match module name `Main'
10:33:05 <opqdonut> ok, i'm totally in lua groove. i can't see that comment as haskell
10:33:07 <chessguy> but the type signature of the custom option could be uglier than what i want them to be able to write too
10:33:09 <glguy> !say uncle
10:33:30 <nmessenger> again, it depends how much you want to put in your type.  The first is more direct.  The second more abstract.  But the interface can be the same for both.
10:34:07 <glguy> fizzbuzz with foldr and no mod :) http://hpaste.org/636#a3
10:34:21 <chessguy> nmessenger, what are you referring to with the first and the second?
10:34:24 <chessguy> !say uncle
10:34:29 <glguy> !say no wai!
10:34:30 <hpaste> no wai!
10:34:35 <nmessenger> evil!
10:34:35 <chessguy> bah
10:34:53 <nmessenger> chessguy: first and second implementations of your Selection type.
10:34:58 <_frederik_> there aren't any files in my current directory with module name 'Main'
10:35:06 <_frederik_> so i don't know what to do
10:35:21 <_frederik_> since ghc is giving me <no location info> as the source location
10:35:52 <chessguy> hmm, i'll have to think about it some more. because i'll be doing a lot of parameters similarly
10:35:57 <jyasskin> _frederik_: Did you forget the "module Whatever where" at the top of a file?
10:36:07 <nmessenger> first: data Selection = First | Last | Custom ([a]->a);  second: newtype Selection = Sel { select :: [a]-> a }
10:36:51 <bla123> "runhaskell Setup.hs haddock" just returns "ghc-pkg failed" for my module
10:37:13 <bla123> with no further explanation
10:37:28 <_frederik_> jyasskin: sure enough, that fixes it
10:37:37 <_frederik_> jyasskin: is it a known bug or should i report it?
10:38:19 <chessguy> see, the first way almost documents itself
10:39:16 <chessguy> and the type of the custom option may not actually be [a]->a, because of various monads that i don't want the user to have to worry about.
10:39:31 <jyasskin> _frederik_: http://haskell.org/onlinereport/modules.html section 5.1: "An abbreviated form of module, consisting only of the module body, is permitted. If this is used, the header is assumed to be `module Main(main) where'."
10:39:32 <lambdabot> Title: The Haskell 98 Report: Modules
10:39:46 <nmessenger> implementing: first: select First = head, select Last = last, select (Custom f) = f;  second: first = Sel head, last = Sel last, custom = Sel
10:39:48 <Pastorn_> >maxBound :: Int
10:39:57 <nmessenger> > maxBound :: Int
10:39:59 <lambdabot>  2147483647
10:40:00 <hpaste>  glguy annotated "FizzBuzz" with "is there anything foldM can't do?" at http://hpaste.org/636#a4
10:40:25 <Pastorn_> thanks
10:41:17 <xerox> glguy: what dishes.
10:41:21 <xerox> wash*
10:41:43 <chessguy> hmm. custom = Sel?
10:42:48 <nmessenger> IOW, custom f = Sel f
10:42:49 <chessguy> oh, yes
10:42:53 <chessguy> duh
10:43:49 <nmessenger> if you export only first, last, custom, and select, you can implement the Selection type however you like.
10:44:23 <SamB> nmessenger: grep lambdabot's tree for "type I = Int"
10:46:46 <_frederik_> jyasskin: i was talking about the fact that the error message is useless
10:47:01 <_frederik_> jyasskin: that should be fixed
10:47:26 <jyasskin> Oh, right, sorry. I don't know if it's known.
10:48:16 <_frederik_> jyasskin: i will mail the list
10:48:24 <chessguy> this is kind of fun, because i know what's about to come next. my 200 LOC are going to melt to like 100
10:48:28 <chessguy> @quote melt
10:48:28 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
10:52:26 * wkh forgot all the stuff he learned about lisp
10:52:28 <nmessenger> Windows' grep-like is *damned* braindead.
10:52:48 <nmessenger> but I got it: scripts\ShowQ.hs
10:54:32 <glguy> woohoo, Institutionalized on expert complete, one more expert song to go
10:54:51 <nmessenger> glguy: Guitar Hero?
10:54:57 <glguy> 2
10:55:24 <nmessenger> naturally, I meant "Guitar Hero" in the generic sense :P
10:55:47 <glguy> Oh, well then yes, I am
10:55:53 <glguy> :-D
10:55:58 <kc5tja> hmmm
10:56:05 <glguy> I have all buy 7 songs beat with 5 stars on "hard"
10:56:08 <glguy> but*
10:56:17 * nmessenger wants that game *sooo bad*!
10:56:18 <kc5tja> I'm trying to test some home-grown code using ghc (not ghci), and I'm routinely getting these errors:
10:56:20 <mahogny> mmm... guitar hero :)
10:56:21 <kc5tja> /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `__stginit_ZCMain'
10:56:24 <kc5tja> /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `ZCMain_main_closure'
10:56:27 <kc5tja> collect2: ld returned 1 exit status
10:56:29 <kc5tja> Any ideas?
10:56:35 <SamB> hmm
10:56:45 <SamB> lets see...
10:56:52 <SamB> what was the :Main module again?
10:56:54 <kc5tja> Compiling with: ghc Cut.hs (where Cut is the name of the module I'm trying to compile)
10:57:04 <Lemmih> kc5tja: Use -c?
10:57:14 <sjanssen> kc5tja: does "ghc --make Cut.hs" work?
10:57:22 <kc5tja> sjanssen: No.  That just produces a .o file
10:57:29 <Lemmih> kc5tja: Or '-main-is Cut.main'.
10:57:57 <kc5tja> Nope.
10:58:09 <SamB> but why is it :Main, and not Main, that GHC is complaining about?
10:58:10 <kc5tja> ghc -main-is Cut.main Cut.hs fails the same way.
10:58:13 <Lemmih> kc5tja: You have to recompile the file.
10:58:48 <kc5tja> Lemmih: Ahh, that works.
10:58:52 <kc5tja> All I have to say is, WTF?
10:59:03 <SamB> Lemmih: you haven't answered my question yet!
10:59:03 <kc5tja> SamB: Where are you getting ":Main" from?
10:59:15 <SamB> kc5tja: ZCMain means ":Main"
10:59:34 <Lemmih> SamB: What question?
10:59:36 <SamB> its a z-coded symbol
10:59:56 <SamB> Lemmih: why GHC is complaining about missing symbols from :Main, and not from Main
11:01:15 <glguy> fawk yeah!! I beat that song too, time for FREEBIRD
11:01:35 <Lemmih> SamB: I have no idea.
11:02:29 <SamB> Lemmih: fair enough
11:02:43 <SamB> would anyone like to hear my guess?
11:02:46 <kc5tja> :(*
11:02:53 <kc5tja> I'm already running into problems.
11:03:04 <kc5tja> It looks like I'll just never, ever, ever grok Haskell.
11:03:22 <SamB> kc5tja: heh
11:03:28 <SamB> linker errors are not Haskell
11:03:33 <kc5tja> No
11:03:37 <kc5tja> has nothing to do with linker errors.
11:03:43 <SamB> oh
11:03:55 <kc5tja> I'm trying to process a command-line argument list, and the static typing is 100% getting in my face.
11:04:23 <kc5tja> Well, static typing + purity of its functional nature
11:04:37 <Lemmih> kc5tja: Static typing is a bit of a misfeature in Haskell. Just use 'unsafeCoerce#'; it'll solve your problems.
11:04:51 <kc5tja> Lemmih: Still does not solve the problem.
11:04:59 <kc5tja> I need mutable state.
11:05:06 <hpaste>  apfelmus annotated "FizzBuzz" with "applicative FizzBuzz with effects" at http://hpaste.org/636#a5
11:05:28 <Lemmih> kc5tja: We have 'unsafePerformIO' to deal with that pesky IO type.
11:05:33 <SamB> kc5tja: have you tried monads yet?
11:06:17 <kc5tja> SamB: I have tried to write my own monad for weeks without success.
11:06:29 <SamB> kc5tja: why your own?
11:06:33 <kc5tja> But I haven't asked here because I haven't put much priority on it.
11:06:38 <kc5tja> SamB: To understand it.
11:06:42 <SamB> oh.
11:06:50 <SamB> well, usually I just make it out of lego.
11:06:58 <SamB> er, I mean, mtl.
11:07:06 <nmessenger> :)
11:07:36 <kc5tja> The problem with using a monad is that, frankly, now you need monad transformers because I'd like to print out the results of the processing.
11:07:51 <nmessenger> transformers are neato, but they look a lot scarier than they are
11:08:02 <kc5tja> nmessenger: They still require that you grok monads.
11:08:12 <nmessenger> I just used a StateT s IO () for the first time today! :D
11:08:15 <SamB> kc5tja: there really is not that much to grok
11:08:35 <SamB> nmessenger: did you implement unlambda?
11:08:48 <nmessenger> SamB: False.
11:08:59 <astrolabe> kc5tja: It should be possible to do what you want to without monads (except IO).  That way, when you learn monads, you will apprechiate them more.
11:08:59 <kc5tja> SamB: My experience begs to differ.
11:09:04 <nmessenger> @go false programming language
11:09:05 <lambdabot> http://wouter.fov120.com/false/
11:09:05 <lambdabot> Title: Wouter's False page
11:09:09 <kc5tja> astrolabe: I'm trying.
11:09:12 <kc5tja> But failing.
11:09:16 <Lemmih> kc5tja: How about looking at a simple monad like Maybe or lists?
11:09:22 * SamB used StateT Char IO () to translate the standard C interpreter
11:09:46 <apfelmus> glguy: buzz. fizzle. fuzzn' the bizzbazz
11:09:53 <astrolabe> kc5tja: for instance if you want to 'change' a state, just make a function change :: State -> State
11:10:04 <nmessenger> I understood my program when I wrote it in terms of (s -> IO s), translating to (StateT s IO ()) was a *lot* less painful than I had assumed it'd be.
11:10:09 <SamB> It turned out that the standard C interpreter for unlambda was a perfect fit for Haskell
11:10:26 <nmessenger> 'twas downright easy once I could fit the types together!
11:10:36 <shapr> @yow !
11:10:37 <lambdabot> I think I'll KILL myself by leaping out of this 14th STORY WINDOW while
11:10:37 <lambdabot> reading ERICA JONG'S poetry!!
11:11:18 <kc5tja> Lemmih: Useless.  I've already tried.
11:11:21 <nmessenger> and it looks so *pretty*!
11:11:43 <kc5tja> astrolabe: I'm trying to pass state around explicitly, basically doing what you're describing now.
11:12:22 <nmessenger> do that until it works, then get fed up with it, hang around here for a few weeks, and decide to translate it to StateT s IO :)
11:12:28 <nmessenger> that's what I did :D
11:13:23 <shapr> kc5tja: look at these http://www.scannedinavian.com/~shae/steve_atkins_monads/
11:13:24 <lambdabot> Title: Index of /~shae/steve_atkins_monads
11:13:41 <nmessenger> op '$' = modifyStack $ \(x : xs) -> (x : x : xs) -- doesn't get much more lucid!
11:14:22 <DynWind> you're writing a forth interpreter?
11:14:24 <DynWind> ;)
11:14:27 <nmessenger> forthlike
11:14:33 <nmessenger> it's called False
11:15:08 <DynWind> ah, cool
11:15:08 <nmessenger> (and written months ago, just translating it to StateT now)
11:15:25 * DynWind makes mental note to finish the scheme interpreter
11:17:09 <astrolabe> kc5tja: So, what's the problem?
11:18:18 <newsham> ?farber
11:18:19 <lambdabot> Unknown command, try @list
11:18:31 <kc5tja> astrolabe: The problem is that I don't know what precisely the problem IS.
11:19:11 <astrolabe> Ah
11:20:05 <astrolabe> Maybe you could try to program something easier first
11:21:57 <kc5tja> astrolabe: huh, processing a list of strings can't possibly BE any easier.  :)
11:22:23 <astrolabe> kc5tja: What are you doing to the strings?
11:22:40 <kc5tja> Just doing checking for things like -h and setting flags and so forth (which I think I just now got working)
11:23:12 <astrolabe> Congratulations
11:23:28 <nmessenger> aye! congrats!
11:23:59 <kc5tja>   process :: [String] -> (Maybe String, Bool, [String]) -> (Maybe String, Bool, [String])
11:24:02 <kc5tja>   process [] result = result
11:24:05 <kc5tja>   process ("-h":args) (output, _, inputs) = (output, True, inputs)
11:24:08 <kc5tja>   process ("-o":output:args) (_, requestedHelp, inputs) = (output, requestedHelp, inputs)
11:24:10 <kc5tja>   process (aName:args) (output, requestedHelp, inputs) = (output, requestedHelp, aName:inputs)
11:24:13 <kc5tja>   
11:24:17 <kc5tja> Horrifyingly bad code, but it *seems* to work as I expect.
11:24:48 <kc5tja> The one for -o should return "Just output", not output.
11:24:50 <kc5tja> Sorry.
11:25:26 <nmessenger> as a first step, you could define a type MyState s = (s -> s) and then type that as [String] -> MyState (Maybe String, Bool, [String])
11:27:20 <Cheery> I'm looking for almost-as-good channels as #haskell, do you know any?
11:28:26 * nmessenger 's only ever been on freenode/#haskell.  Still an IRC neophyte.
11:28:30 <astrolabe> I like #haskell-blah, but it is quite different.
11:29:22 <Cheery> I'd need to tune up my ability to communicate and I'm just looking for a channel or a person who could be of help in doing it.
11:29:47 <kc5tja> @hpaste
11:29:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:30:32 <hpaste>  kc5tja pasted "My first "cut" at processing arguments" at http://hpaste.org/693
11:30:34 <shapr> Cheery: It's pretty rare to find a channel as friendly as #haskell.
11:31:01 <LordBrain> hmmm i just noticed we changed paste bins
11:31:19 <Nafai> Speaking of friendly, hi shapr!
11:31:22 <kc5tja> My next attempt will be to use algebraic types, I think.
11:31:28 <kc5tja> It's pretty code, but cluttered code.
11:31:55 * nmessenger hacks on it
11:32:39 <bos> is Either not an instance of Monad in the standard libraries?
11:33:27 <nmessenger> Either String should be
11:33:51 <Cheery> shapr: but not impossible, right?
11:33:58 <Nafai> bos: I keep forgetting to tell you when I see you active...your description of esh on your blog was fascinating
11:34:07 <nmessenger> @instances Monad
11:34:09 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:34:25 <bos> Nafai: thanks
11:34:47 <bos> i can't find where it's declared as an instance
11:38:30 <LordBrain> where's bos's log?
11:38:36 <LordBrain> blog
11:38:40 <LordBrain> :)
11:38:50 <bos> http://www.serpentine.com/blog
11:38:52 <lambdabot> Title: teideal glic deisbhalach
11:39:43 <lupo__> question on optimization: if i have a function that goes like fct a b = fct maximum [((fct (a-1) (b-1)) + something), ((fct a (b-1)) + something), ((fct (a-1) b) + something)], this takes very long for larger values of a and b, at least in hugs. is that optimized in ghc or is the long run time a general problem? this is a matrix-filling algorithm and quite fast if implemented imperatively.
11:40:06 <lupo__> sorry, drop the fct after the =
11:41:47 <cpage> How large?
11:42:31 <fons> I don't see where a and b affect the Order of a and b, and neither I see the stop condition of fct
11:42:46 <fons> the Order of fct, sorry
11:43:13 <fons> lupo__, why don't you paste the full code at hpaste?
11:43:27 <lupo__> fons: good idea, wait :)
11:44:01 <pejo> lupo, interpreters are quite slow, you will probably get better performance with compiled code.
11:44:01 <SamB> lupo__: "what not how" only goes so far
11:44:53 <cpage> pejo: Do you mean interpreters generally or just Haskell interpreters specifically?
11:45:12 <SamB> any interpreters that just interpret are
11:45:23 <hpaste>  lupo__ pasted "Dynamic Programming algorithm (matrix filling part)" at http://hpaste.org/694
11:45:26 <SamB> though sometimes it doesn't really matter
11:45:36 <cpage> That's simply not necessarily true.
11:45:36 <SamB> because the interpreting isn't the bottleneck anyway
11:45:57 <SamB> oh?
11:46:04 <lupo__> it's a very noob-ish code and may be very verbose :)
11:47:16 <lupo__> but it works in theory; the point is that it's just damn slow in hugs.
11:47:26 <pejo> cpage, if interpreters are quicker than compiled code, the compiler can just embed an interpreter - that would guarantee that the compiler is always at least as good as the interpreter.
11:47:29 <bos> hugs is damn slow.
11:47:30 <LordBrain> hugs did outperform ghc in some on some of those nobench programs
11:47:42 <cpage> "interpreter" and "compiler" exist along a spectrum, so they're imprecise terms.
11:47:46 <LordBrain> but those are bugs...
11:48:18 <hpaste>  nmessenger annotated "My first "cut" at processing arguments" with "unfoldr ftw!" at http://hpaste.org/693#a1
11:48:54 <pejo> cpage, the compiler can still embed the interpreter, regardless of where on that spectrum.
11:48:55 <lupo__> fons: as you can see, the stop condition is in the second- and third-to-last line
11:49:28 <SamB> cpage: i said "that just interprets"
11:49:32 <cpage> pejo: I have no idea what you're trying to say about embedding. You can embed compilers and interpreters inside one another ad infinitum.
11:49:55 <SamB> cpage: funny, I usually run out of RAM when I try that
11:50:13 <apfelmus> lupo__: http://chneukirchen.org/blog/archive/2006/03/dynamic-programming-in-haskell.html
11:50:17 <lambdabot> Title: chris blogs: Dynamic Programming in Haskell, http://tinyurl.com/2o6s75
11:50:33 <cpage> SamB: So, by "just interprets" you mean that it reads text source files, then parses and evaluates each line of code every time each line is evaluated?
11:50:59 <lupo__> apfelmus: cool, thanks!
11:51:13 <SamB> cpage: er.
11:51:16 <apfelmus> you're welcome
11:51:22 <cpage> Many (most?) "interpreters" involve first compiling to some virtual machine code.
11:51:26 <SamB> I actually meant an ordinary while/switch bytecode interpreter
11:51:34 <pejo> cpage, well, ok. My suggestion can't possibly make it worse, since the interpreter can just embed a compiler and vice versa then.
11:51:44 <cpage> Many "interpreters" generate and execute machine code.
11:51:48 <cpage> Many
11:51:58 <nmessenger> splitty today
11:52:31 <SamB> cpage: I didn't mean that kind
11:52:35 <lupo__> erm, what does the traceback function do? cannot find anything useful on google
11:52:35 <cpage> Many "compilers" generate virtual machine code. Many "compilers" are simplistic and generate far from the most efficient possible machine code (virtual or otherwise).
11:52:51 <hpaste>  kc5tja annotated "My first "cut" at processing arguments" with "attempt #2 using algebraic types" at http://hpaste.org/693#a2
11:52:59 * lupo__ slaps himself
11:53:12 <lupo__> ignore me, it seems to be a custom written function in that program :)
11:53:20 <cpage> SamB: So, you see my point? That it cannot accurately be said that all "interpreters" are necessarily slower than all "compilers".
11:53:37 * dcoutts_ has a re-implementation of Prelude.words that is ~30% faster than the standard impl
11:53:47 <SamB> cpage: I qualified my statement!
11:53:53 * glguy beats guitar hero on expert
11:54:04 <SamB> also, I never said anything about compilers being faster than them
11:54:10 <cpage> Just as it cannot accurately be said that any given language is "an interpreted language" or "a compiled language".
11:54:22 <cpage> SamB: You were participating in a thread of discussion.
11:54:31 <cpage> The thread of discussion did say that. :-)
11:55:02 <SamB> I believe he was talking about the execution techniques as well as the UI
11:55:19 <SamB> (or maybe more the execution techniques)
11:55:39 <LordBrain> dcoutts, why is your implementation so much faster?
11:55:44 <cpage> Let's not argue about who said what.
11:56:02 <dcoutts_> LordBrain, because it's not totally naive
11:56:11 <cpage> My real point is that performance must be measured.
11:56:14 <dcoutts_> LordBrain, the current impl is just the spec from the H98 report
11:56:35 <dcoutts_> @paste
11:56:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:56:37 <jmillikin> I have what is probably a very easy question, but I can't find the answer everywhere - what is the 'Just' keyword? I'm following YAHT, and they just popped it in with no explanation
11:56:51 <nmessenger> @src Maybe
11:56:52 <lambdabot> data Maybe a = Nothing | Just a
11:56:53 <bos> it's not a keyword; it's a constructor.
11:57:28 <kpreid> jmillikin: no Haskell keyword starts with an uppercase letter
11:57:30 <bos> it lets you construct a "Maybe" value, where whatever you're doing might fail.
11:57:37 <nmessenger> ^^ that line defines two new values, 'Nothing', and 'Just', which is a function that takes an 'a' and give a 'Maybe a'
11:57:45 <jmillikin> Ah, I see, thank you
11:57:52 <bos> so if you're going to fail, you use Nothing. and if you're going to succeed, use e.g. "Just 3"
11:58:09 <SamB> cpage: well, actually, I bet he meant that programs running in hugs and ghci bytecode interpreters run slower than GHC-compiled programs...
11:58:26 <hpaste>  dcoutts pasted "Current implementation of 'words'" at http://hpaste.org/695
11:58:36 <dcoutts_> LordBrain, ^^
11:58:42 <lupo__> what is that @@ operator called? (just a name, so that i can look it up in the wikibook or somewhere else)
11:58:59 <cpage> SamB: That's exactly what I asked. :-)
11:58:59 <nmessenger> @index (@@)
11:58:59 <lambdabot> bzzt
11:59:06 * nmessenger shrugs
11:59:11 <cjeris> stupid question: what's codata?
11:59:23 <dcoutts_> lupo__, is that Kliesly (sp?) composition
11:59:32 <kc5tja> @src unfoldr
11:59:33 <lambdabot> unfoldr f b  = case f b of
11:59:33 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
11:59:33 <lambdabot>    Nothing        -> []
11:59:41 <lupo__> dcoutts_: what composition?
11:59:58 <lupo__> dcoutts_: i just read it in the example program that apfelmus sent me a link to
11:59:59 <dcoutts_> lupo__, named after a logician
11:59:59 <nmessenger> (f >=> g) x = f x >>= g
12:00:03 <fantasma> > let my_map p [] = []; my_map p (x:xs) = (p x) : my_map p xs in my_map Char.isUpper ['H','e','L','L','o'] --excercise 3.9 yaht
12:00:05 <lambdabot>  [True,False,True,True,False]
12:00:13 <jbone_> hey, anybody here feel like a small programming challenge?  I'm collecting "good" solutions to a recruiting problem my company uses, and am not a Haskell hack myself but would love a submission in Haskell...
12:00:30 <kc5tja> nmessenger: I do not understand your implementation.  What exactly does unfoldr do, versus foldr?
12:00:37 <sm-biab> sure, jbone_ :)
12:00:41 <jbone_> it's a small problem, should only take a half-hour or so:
12:00:43 <jbone_> http://www2.rgmadvisors.com/public/problems/orderbook/
12:00:44 <lambdabot> Title: Order Book Programming Problem
12:00:56 <jbone_> you can send solutions to jbone@rgmadvisors.com
12:01:05 <lupo__> dcoutts_: you mean my program or that @@ operator?
12:01:09 <lupo__> nmessenger: thanks
12:01:17 <dcoutts_> lupo__, that operator
12:01:37 <lupo__> dcoutts_: i don't even know what it is right now :)
12:01:57 <dcoutts_> cjeris, data types that are the image of unfolds, it's a bit subtle, look it up.
12:01:59 <nmessenger> kc5tja: unfoldr gives the seed ([String]) to the f.  If the result is Nothing, then it gives an empty list,  If Just (x, y), then it gives (x : unfoldr f y)
12:02:51 <fantasma> is unfoldr part of prelude?
12:03:02 <nmessenger> Data.List
12:03:02 <kc5tja> @src foldr
12:03:03 <lambdabot> foldr k z xs = go xs
12:03:03 <lambdabot>     where go []     = z
12:03:03 <lambdabot>           go (y:ys) = y `k` go ys
12:03:07 <nmessenger> @index unfoldr
12:03:08 <lambdabot> Data.List
12:03:22 <cjeris> dcoutts_: can you point me to a reference?
12:03:52 <lupo__> > :t @index
12:03:53 <lambdabot>  Parse error
12:04:06 <nmessenger> foldr combines the bits of a list into a new value, unfoldr extracts a value into bits, then puts them in a list.
12:04:45 <lupo__> damnit, google ignores the @ character.
12:04:55 <SamB> yeah...
12:05:22 <kc5tja> nmessenger: I guess I just don't "see" how it works.
12:05:27 <SamB> it would be nice if you could get it to sift through the results and pull out only the ones with something punctuated just so
12:06:02 <xerox> kc5tja: search for cale's drawings on cale.yi.org, they might be helpful to "see"
12:06:38 <nmessenger> xerox: Cale has an unfoldr drawing?
12:06:42 <lupo__> so, any hint where i find some information on what @index does ?
12:07:04 <dcoutts_> cjeris, I can't find a good reference
12:07:18 <xerox> nmessenger: I don't know
12:07:23 <SamB> it tells you what modules in its database export variables with a given name
12:07:28 <xerox> ?help index
12:07:28 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
12:07:32 <Nafai> dcoutts_: How's your C parser coming?
12:07:52 <lupo__> > :t index
12:07:52 <lambdabot>  Parse error
12:07:55 <lupo__> > index
12:07:56 <lambdabot>  Add a type signature
12:08:07 <xerox> Ah.
12:08:07 <dcoutts_> Nafai, it can parse the whole kernel. I've been gradually pushing patches into the main c2hs darcs repo.
12:08:09 <xerox> ?hoogle index
12:08:10 <lambdabot> Ix.index :: Ix a => (a, a) -> a -> Int
12:08:10 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
12:08:10 <lambdabot> Data.Generics.Basics.indexConstr :: DataType -> ConIndex -> Constr
12:08:19 <Nafai> dcoutts_: Awesome
12:08:22 <xerox> You mean the Array index function, lupo__ ?
12:08:34 <lupo__> xerox: nope, i mean @@
12:08:42 <cjeris> dcoutts_: ok, thanks for checking
12:08:59 <xerox> lupo__: then it just tell you in which module (in the hierarchical libraries) a given function is defined.
12:09:11 <xerox> ?index liftM
12:09:11 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:09:21 <xerox> ?index showFFloat
12:09:22 <lambdabot> Numeric
12:10:39 <lupo__> xerox: that doesn't make sense in the context i have it here
12:10:52 <xerox> When do you want such information? For example when you want to use that function in a program of yours and you need to know which module you have to import to be able to do so.
12:12:05 <lupo__> xerox: score x y = maximum [(x-1 @@ y-1) + difference x y, x-1 @@ y, x @@ y-1]
12:12:43 <kc5tja> xerox: Nope; diagrams don't cover unfold.
12:12:55 <SamB> @index @@
12:12:55 <lambdabot> bzzt
12:12:57 <fantasma> can lambdabot do import?
12:13:00 <SamB> @index (@@)
12:13:01 <lambdabot> bzzt
12:13:11 <xerox> lupo__ - The @@ function must be defined somewhere else than the standard library. If you inspected the module's source code, and didn't fint its definition, you should check the (non-standard) modules that the given module imports.
12:13:53 <lupo__> xerox: Array module perhaps?
12:14:04 <xerox> lupo__: what modules does your module import?
12:14:24 <lupo__> only Array
12:16:59 <lupo__> OH SHIT
12:17:15 <lupo__> everybody retreat mentally. it's defined in the program
12:17:16 <lupo__> SORRY
12:17:23 <lupo__> infix 5 @@
12:17:30 <lupo__> (@@) i j = memscore ! (i, j)
12:18:25 <xerox> Good.
12:18:43 <lupo__> still don't understand it, but feel better now.
12:19:04 <lupo__> (haskell noob mentality. *g*)
12:19:19 <xerox> It returns the (i,j) item of the array "memscore"
12:20:15 <lupo__> xerox: thought so. if that operator would have been used in a (@@) x y manner in the program, i would have understood faster.
12:20:47 <kc5tja> lupo__: Don't feel bad.  It took me something like three hours just to work with command-line arguments.  >:/
12:20:49 * nmessenger prefers "x ?? y = ..." syntax for some operator ??
12:20:52 <kc5tja> But it's lessons learned.
12:21:24 <lupo__> kc5tja: thanks. i'll need that some time later
12:22:04 <fantasma> is WinHugs known for being very slow?
12:22:18 <xerox> You want to make ndm feel very bad?
12:22:44 <kc5tja> My approach is here: http://hpaste.org/693?lines=true
12:22:47 <kc5tja> But it is NOT the best.
12:22:49 <dcoutts_> jbone_, heh, I like the co-efficiency :-)
12:23:04 <kc5tja> There is a getopts package for it, but I wanted to work with the metal, so to speak, to learn more about the language itself.
12:23:32 <kc5tja> My solution is actually rather crude, all things considered.  :)
12:23:34 <lupo__> kc5tja: you know, whatever approach one uses in haskell, i have the feeling that there is somewhere out there who knows how to do it better, easier understandable, faster and in fewer lines.
12:23:43 <nmessenger> @karma unfoldr
12:23:44 <lambdabot> unfoldr has a karma of 7
12:23:48 <xerox> lupo__: and we gather here for a reason! (-:
12:24:06 <lupo__> xerox: (-:
12:24:08 <jbone_> dcoutts:  ;-) :-)
12:24:09 <dcoutts_> jbone_, that's quite a nice problem and should yield a nice functional solution
12:24:42 <jbone_> agreed.
12:25:09 <kc5tja> nmessenger: However, unfoldr solution doesn't break out inputs from outputs, from other flags, and so forth.
12:29:05 <fantasma> @index say
12:29:06 <lambdabot> bzzt
12:29:10 <fantasma> @index echo
12:29:10 <lambdabot> bzzt
12:29:12 <fantasma> @index map
12:29:13 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
12:29:19 <fantasma> thanks lambdabot
12:29:31 <fantasma> @cookie
12:29:31 <lambdabot> Unknown command, try @list
12:30:05 <opqdonut> @botsnack
12:30:05 <lambdabot> :)
12:30:14 <lupo__> @botsmack
12:30:14 <lambdabot> :)
12:30:23 <lupo__> oh, he likes it.
12:30:31 <opqdonut> @botrape
12:30:31 <DynWind> *she
12:30:31 <lambdabot> Unknown command, try @list
12:30:33 <opqdonut> :/
12:31:02 <lupo__> DynWind: nasty girl.
12:31:07 <bos> how does one pronounce ((->) e)?
12:31:13 <xerox> "Reader Monad"
12:31:27 <opqdonut> :)
12:31:49 <xerox> "Function from e" if you want.
12:32:51 <bos> really? i thought that MonadReader was the Reader.
12:33:09 <xerox> newtype Reader e a = Reader { runReader :: e -> a }
12:33:27 <bos> ah, ok.
12:41:28 <Cale> I don't have an unfoldr drawing, but I do have diagrams for folds and scans
12:42:35 <kc5tja> Cale: Your Monads as Containers article has a link to "All About Monads" -- but the link is broken.  Do you know of an updated URL for that?
12:42:41 <kc5tja> bbiab -- going to lunch.
12:42:58 <dons> kc5tja: its on haskell.org now
12:43:06 <Cale> kc5tja: ah, yeah
12:43:08 <bos> nomaware's been down for a week or so.
12:43:20 <Cale> Usually nomaware isn't down for this long.
12:45:41 <apfelmus> i think noware moved
12:47:57 <apfelmus> yep,  remembered correctly.
12:47:59 <apfelmus> http://www.haskell.org/all_about_monads/html/index.html
12:48:00 <lambdabot> Title: All About Monads
12:48:06 <apfelmus> @where all about
12:48:07 <lambdabot> I know nothing about all.
12:48:12 <apfelmus> @where monads
12:48:13 <lambdabot> http://mbishop.esoteriq.org/stuff/allaboutmonads.pdf
12:49:19 <dons> ?users
12:49:20 <lambdabot> Maximum users seen in #haskell: 330, currently: 330 (100.0%), active: 57 (17.3%)
12:49:26 <dons> cool
12:50:33 <edwinb> cor
12:50:53 <apfelmus> mh, why does @where monads point to a pdf printout?
12:50:59 <dcoutts> g'morning dons
12:51:01 <edwinb> maybe lambdabot should do a happy dance when there's a new record set
12:51:35 <apfelmus> @where+ monads http://www.haskell.org/all_about_monads/html/index.html
12:51:36 <lambdabot> Done.
12:52:58 <dons> ?users
12:52:59 <lambdabot> Maximum users seen in #haskell: 331, currently: 331 (100.0%), active: 58 (17.5%)
12:53:20 <apfelmus> does lambdabot track renames?
12:53:45 <dons> 336 is actually the record
12:53:48 <dons> apfelmus: yeah
12:53:54 <apfelmus> cool
12:54:13 <flip-dons> ?seen dons
12:54:14 <lambdabot> dons has changed nick to flip-dons.
12:54:14 <lambdabot> You are in #haskell and #haskell-overflow. I last heard you speak just now.
12:54:21 <apfelmus> ?users
12:54:21 <lambdabot> Maximum users seen in #haskell: 331, currently: 331 (100.0%), active: 58 (17.5%)
12:54:41 <Igloo> That's simultaneous users, so renames are irrelevant
12:55:12 <apfelmus> yeah, right. renaming myself doesn't change the total number of users :)
12:55:31 <dons> i note the channel average is now ...
12:55:35 <dons> 297 :)
12:55:45 <dons> so we're doing something right
12:55:50 <siti> wooho record :)
12:59:15 <shapr> What's the max active?
12:59:37 <int-e> 336 according to dons, 331 according to lambdabot
12:59:40 <dons> hmm 58 is pretty high. i think i've seen 60 though
13:00:02 <kaol> > 1+1
13:00:04 <lambdabot>  2
13:00:16 <int-e> @users
13:00:16 <lambdabot> Maximum users seen in #haskell: 331, currently: 331 (100.0%), active: 60 (18.1%)
13:00:16 <siti> oh ok
13:01:20 <bos> ?seen fons
13:01:21 <lambdabot> fons is in #haskell. I last heard fons speak 1h 18m 6s ago.
13:01:22 <dons> shapr: 4 times we've been above 60 active, record is 64
13:01:27 <bos> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
13:01:29 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
13:02:24 <bos> heh. reddit says "1 point posted 974 milliseconds ago by bos"
13:02:29 <bos> i like the units used.
13:02:35 <dons> :)
13:02:45 <dmhouse> Pah. It should use microfortnights.
13:03:15 <dons> bos, i'd seriously consider ping Chris (regex author) with this, to get it added to the haddocks
13:03:31 <dons> since i found the interface daunting too :)
13:03:43 <dons> you might also mention the regex.pcre, regex.tre and regex.parsec packages
13:03:55 <bos> yeah, i'll write about those later :-)
13:04:03 <dmhouse> dons: don't suppose you know, when do SoC applicants find out whether they're successful or not?
13:04:11 <bos> and i've pinged chris already, because regex-tdfa doesn't build right now.
13:04:12 <malcolm_> hi dons: I sent you an fps patch and a nobench patch earlier
13:04:28 <dons> also, check out the native haskell regexes on the shootout -- laziness is a big win for memory use http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
13:04:30 <lambdabot> Title: regex-dna benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/mgdtj
13:04:35 <dons> malcolm_: ah great!
13:04:44 <dons> malcolm_: all in the one mail? (i saw the fps byte swap patch)
13:04:54 <malcolm_> no, separately
13:05:07 <dons> i got a nobench patch this time yesterday
13:05:07 <malcolm_> dons: the fps one is an API-extend
13:05:17 <dons> but no nobench patches today
13:05:27 <bos> dons: yeah, i'm planning to write about the laziness aspect, too. see the end of the existing posting :-)
13:05:50 <malcolm_> dons: the nobench one was sent from my laptop, but I suspect its MTA isn't configured properly
13:05:50 <dons> malcolm_: btw, with the new -m32 stuff, will nhc happily run on an amd64?
13:06:17 <dons> ok. haven't got it then.
13:06:21 <malcolm_> dons: re -m32, I'm hoping so, but can't confirm until someone tries it...
13:06:26 <dons> dmhouse: won't be for a while
13:06:35 <dons> malcolm_: i shall try it now then
13:06:44 <dons> having a fresh nhc on and amd64, right here ...
13:07:38 <dons> it runs...
13:07:44 <dmhouse> dons: found it on code.google.com. It's April 9th, apparently.
13:07:45 <dons> and produces output!
13:07:51 <malcolm_> dmhouse: March 24: Student application deadline. April 9: List of accepted student applications published
13:08:16 <dmhouse> malcolm_: I have a feeling you're looking at the same page as I :)
13:08:43 <dons> malcolm_: do the happy dance!
13:08:45 <dons> serenity$ ./exp3_8 9 +RTS -H128M -RTS
13:08:45 <dons> 19683
13:08:45 <dons> serenity$ uname -m
13:08:45 <dons> x86_64
13:08:48 <dons> serenity$ nhc98 --version
13:08:50 <dons> /home/dons/bin/nhc98: v1.19 (darcs version)
13:08:53 <malcolm_> we really need to get the mentoring bit of google SoC up and running
13:09:05 <dons> yeah. i want to look at that in the next couple of days
13:09:31 <malcolm_> dons: I sent a post to soc-mentors a couple of hours ago
13:09:56 <malcolm_> we've got about a week until mentor applications start (and two weeks until they finish)
13:10:25 <dons> ok.
13:10:38 * malcolm_ is pleased that nhc98 now works on 64-bit machines (albeit in 32-bit mode)
13:10:55 <dons> yeah, that's a big win.
13:11:29 <dons> so i'll run my 64 bit benchmarks now, with all the compilers except hbc
13:11:58 <dons> make -j16
13:12:11 <chessguy> dons, i have a 64-bit machine at home, if you want help in a couple hours
13:12:25 <malcolm_> hmm, I don't think hmake can use -j16 :-)
13:12:26 <chessguy> only ghc 6.6 on it currently though
13:12:56 <dons> malcolm_: right. need to fix that. also the nhc build system breaks on -j >= 2
13:13:05 <malcolm_> I suppose I'll need to update our webpages to remove the "32-bit machine only" restriction ;-)
13:13:17 <dons> yay :)
13:13:28 <dons> jhc could really do with -jN builds too, rather than --make
13:14:05 <dons> but at least with -j16 the nobench suite runs in 2 hrs, instead of 16
13:14:10 <dons> (with all compilers enabled)
13:14:52 <malcolm_> yeah, I was shocked to see how long the plain run took
13:15:05 <dons> its 15 mins if I just use ghc
13:15:22 <dons> timeouts hurt, as does jhc build times
13:15:54 <Igloo> "timeouts" meaning programs incorrectly don't terminate and get timed out?
13:15:59 <dons> but when some programs run 8000x slower in hugs...
13:16:04 <dons> Igloo: they time out after 20 mins
13:16:13 <Igloo> But due to being slow, or being broken?
13:16:18 <dons> slow
13:16:25 <dons> well, they might be broken too
13:16:28 <dons> i don't know ;)
13:16:45 <dons> Igloo: http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
13:16:46 <lambdabot> Title: nobench: Haskell implementation shootout
13:16:47 <Igloo> OK, so it's not really timeouts hurting, then, it's just slowness really
13:16:59 <dons> fair enough
13:17:20 <dons> code that takes 20 mins to terminate, run over 7 compilers, x 64 tests
13:17:36 <dons> + the slow compile times on jhc
13:18:13 <dons> malcolm_: thanks, got the patch
13:18:19 <zeeeee> is there any standard function that is like intersperse, but injects the next element from the second list only after every n elements of the first list (instead of after every element of the first list)?
13:18:32 <dons> malcolm_: i guess that'll fix yhc's error on the same program too
13:18:42 <malcolm_> probably
13:18:48 <Igloo> Hmm, I'd be surprised if the integrate timeout for nhc was real (just to look at the first one)
13:18:55 <dons> zeeeee: hmm . let (a,b) = splitAt 7 in a ++ intersperse ... b
13:19:39 <malcolm_> darn it, I was fixing nhc98 build in order to widen the gap between nhc and yhc, but had completely forgotten that I was probably fixing their builds too :-(
13:19:45 <zeeeee> dons: i can't parse that...
13:20:20 <dons> malcolm_: right. they've got 3 or 4 type related errors that you'll end up fixing
13:20:29 <dons> however, there's runtime errors that are quite different
13:20:36 <fons> zeeeee, it's not complete, just a guideline of what you should do
13:20:54 <dons> > let (a,b) = splitAt 4 "haskell"
13:20:55 <lambdabot>  Parse error
13:20:58 <dons> > let (a,b) = splitAt 4 "haskell" in (a,b)
13:20:59 <lambdabot>  ("hask","ell")
13:21:06 <Igloo> malcolm_:  :-)
13:21:24 <dons> > let (a,b) = splitAt 4 "haskell" in a ++ intersperse '!' b
13:21:26 <lambdabot>  "haske!l!l"
13:21:42 <bos> dons: what's happened with hwn lately? too busy to write it?
13:21:46 <nmessenger> use one of the many splits/chunking functions, intersperse ["whatever"], concat, concat
13:21:48 <dons> Igloo: seems like a legitimate timeout
13:21:56 <dons> bos, yeah. but.... there's an issue mostly prepared
13:22:04 <dons> if i just dont' get distracted with other things today...
13:22:19 <bos> dons: :-)
13:22:20 <Igloo> dons: Hmm, fair enough
13:22:36 <dons> Igloo: talk to malcolm ;)
13:22:39 <Igloo> dons: It would be really neat if you could click on the various error cells and be taken to a page with the error output, BTW
13:22:41 <malcolm_> Igloo: re integrate, I think I could believe the timeout, but will check
13:22:41 <zeeeee> that's not what i meant
13:22:44 <zeeeee> after *every* n characters
13:22:58 <dons> Igloo: agreed. yes, i could do that now, since the error results are stored in a standard url
13:23:16 <nmessenger> > (\n -> unfoldr (let f[]=Nothing; f xs=Just(splitAt n xs)in f)) 3 "foobarbaz"
13:23:18 <lambdabot>  ["foo","bar","baz"]
13:23:33 <dons> unfoldr++
13:23:44 <Igloo> malcolm_: OK. There's nothing there that looks like it obviously might be slow to me, so 60 times slower than hugs seems impressive
13:23:58 <nmessenger> > concat . concat . intersperse "!" $ ((\n -> unfoldr (let f[]=Nothing; f xs=Just(splitAt n xs)in f)) 3 "foobarbaz")
13:23:59 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
13:24:08 <nmessenger> > concat . concat . intersperse ["!"] $ ((\n -> unfoldr (let f[]=Nothing; f xs=Just(splitAt n xs)in f)) 3 "foobarbaz")
13:24:09 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:24:09 * malcolm_ compiles and runs integrate
13:24:21 * nmessenger /msg's LB
13:25:10 <apfelmus> dons: is the lines and unlines in ByteString or am i missing something?
13:25:14 <apfelmus> *there
13:25:22 <nmessenger> > concat . intersperse "!" . (\n -> unfoldr (let f[]=Nothing; f xs=Just(splitAt n xs)in f)) 3 $ "foobarbaz"
13:25:24 <lambdabot>  "foo!bar!baz"
13:25:28 <dons> in Data.ByteString.Char8
13:25:52 <apfelmus> duh, thanks
13:26:48 <dcoutts> dons, I was thinking about a lines/unlines fusion rule again, it's rather annoying :-)
13:27:03 * malcolm_ thinks it was a bad idea to ask for +RTS -H128M on his laptop which has only 256M real mem
13:27:51 <dcoutts> so of course unlines always appens a '\n' but that's not the worst problem, lines . unlines on a list of lines with embedded '\n' is always going to be different since it flattens them out
13:27:56 <dons> vim header.mk, malcolm_
13:28:05 <dons> mmm.
13:28:18 <dcoutts> dons, so it'd be something like lines . unlines = flattenNLs
13:28:36 <dcoutts> and that'd also take care of the trailing '\n'
13:28:42 <nmessenger> @scheck (\xs -> lets xs' = xs ++ "\n" in unlines (lines xs) == xs) :: String -> Bool
13:28:42 <lambdabot>  Parse error
13:28:58 <dcoutts> dons, but the point is, it's not as cheap as it looks
13:29:01 <nmessenger> @scheck (\xs -> let xs' = xs ++ "\n" in unlines (lines xs') == xs') :: String -> Bool
13:29:03 <lambdabot>   Completed 1957 test(s) without failure.
13:29:19 <Igloo> dcoutts: Would that rule every really be triggered?
13:29:23 <nmessenger> it works on strings ending with '\n'
13:29:45 <Igloo> Oh, I guess for composing two things that both were unlines . f . lines it would
13:29:47 <malcolm_> dons: actually, for some reason I am running it by hand rather than using the facility I added to the Makefile ?-)
13:29:52 <dcoutts> Igloo, think  grep | sed
13:30:15 <dcoutts> Igloo, yes exactly
13:30:30 <dons> malcolm_: yeah, make nhc98 is rather nice
13:31:39 <malcolm_> dons: oh?  I don't think I am responsible for that one
13:31:54 <dons> i thought you added the patch that let us run jobs in subdirs/
13:31:58 <dons> and with explicit compiler names
13:32:20 <dons> at leats,   'make nhc98' in  test works :)
13:34:40 <lupo__> btw, is hpaste.org written in haskell? :)
13:34:55 <dmhouse> lupo__: yep.
13:35:14 <lupo__> dmhouse: nice.
13:35:32 <dmhouse> I can't remember who wrote it. It may have been glguy.
13:35:45 <dmhouse> Yeah, it was (so says the website).
13:37:01 <lupo__> btw, does this karma stuff work actually?
13:37:03 <lupo__> dons++
13:37:05 <lupo__> dmhouse++
13:37:10 <lupo__> apfelmus++
13:37:13 <lupo__> nmessenger++
13:37:17 <icarroll> @karma dons
13:37:17 <lambdabot> dons has a karma of 122
13:37:35 <chessguy> @karma+ dons
13:37:35 <lambdabot> dons's karma raised to 123.
13:37:36 <lupo__> correct syntax?
13:37:42 <bos> chris kuklewicz++
13:37:47 <dmhouse> ?karma lupo__
13:37:47 <lambdabot> lupo__ has a karma of 0
13:37:52 <dmhouse> lupo__++
13:37:54 <dmhouse> ?karma lupo__
13:37:54 <lambdabot> lupo__ has a karma of 1
13:37:55 <nmessenger> the @karma+ commands show a message, the nick++/nick-- commands are silent
13:38:09 <dmhouse> IMO the nick{
13:38:14 <lupo__> :-) my first karma point! :)
13:38:22 <dmhouse> IMO the nick{++,--} ones should show a message too.
13:38:31 <nmessenger> kuklewicz--  chris_kuklewicz++
13:39:02 <lupo__> yes that would be a clue to noobs like me
13:39:31 <nmessenger> c++
13:39:35 <nmessenger> @karma c
13:39:35 <lambdabot> c has a karma of 15
13:39:39 <lupo__> you stuble into a language channel and wonder what kind of inside joke this nickname++ stuff is.
13:39:42 <dons> c-- is cool
13:39:43 <dons> oops
13:39:48 <nmessenger> :3
13:39:56 <nmessenger> @karma c
13:39:56 <lambdabot> c has a karma of 15
13:40:02 <lupo__> c--
13:40:05 <lupo__> never heard of that
13:40:08 <lupo__> @karma c
13:40:08 <lambdabot> c has a karma of 15
13:40:09 <int-e> @karma+ c
13:40:10 <lambdabot> c's karma raised to 16.
13:40:10 <lupo__> ?
13:40:14 <nmessenger> "c" is special cased
13:40:21 <nmessenger> @karma- c
13:40:21 <lambdabot> c's karma lowered to 15.
13:40:26 <dons> yeah, you can't get at them with nick++/--
13:40:35 <trurl> how do I get the column number that I have to pass to treeModelGetValue (gtk2hs, the new tree/list api)?
13:40:58 <dcoutts> trane, the new tree/list api doesn't use column numbers
13:41:05 <siti> c++
13:41:08 <dcoutts> so don't use treeModelGetValue it will not help you
13:41:38 <dcoutts> trurl, the specific models provide functions to look up values
13:42:06 <dons> serenity$ uptime
13:42:06 <dons>  08:39:20 up 4 days, 15:59,  2 users,  load average: 27.70, 39.91, 35.66
13:42:08 <dons> yikes!
13:42:16 <lupo__> dons: looking at http://www.cse.unsw.edu.au/~dons/irc/, i wonder if it wouldn't be better to log-scale the y axis ;-)
13:42:17 <lambdabot> Title: Haskell IRC Activity
13:42:25 <dons> hehe
13:42:50 <trurl> dcoutts: ok, then I probably need listStoreGetValue
13:43:00 <dcoutts> trurl, yep
13:43:14 <lupo__> and the haskell-cafe acitivity chart is cool. everybody seems to hack during the winter :)
13:43:56 <Excedrin> hey dons, you should fix the nobench results.html so that ties for the lowest time are colored the same
13:44:25 <trurl> dcoutts: unfortunately the docs don't say much about it (http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-ModelView-ListStore.html#v%3AlistStoreGetValue)
13:44:27 <lambdabot> http://tinyurl.com/273m6w
13:44:47 <dons> Excedrin: yes. will do
13:44:54 <Excedrin> at first glance, it looks like there's a lot of regressions between ghc and ghc-old, but many of them are ties
13:45:08 <Excedrin> if the source for that exists somewhere I'd fix it
13:45:15 <trurl> dcoutts: btw., the "Int" links on that page are broken
13:45:34 <dcoutts> trurl, oh yes, so they are
13:45:45 <malcolm_> Igloo: so i think nhc98's problem with integrate is that there are lots of top-level CAFs, which it doesn't GC in the same way as ghc, so most of the time is spent in memory management I reckon
13:46:11 <Igloo> Ah, OK
13:47:26 <malcolm_> primes had the same problem, and JaffaCake told me he would prefer that ghc was less clever at GCing CAFs, (and in the process it would become slower on these benchmarks)
13:48:03 <dons> Excedrin: right.
13:48:11 <malcolm_> ah, integrate has terminated after 20 minutes
13:48:12 <apfelmus> jbone_: the problem has a nice efficient solution with 2-3-finger trees
13:48:23 <malcolm_> ... with a "run out of heap error"!
13:48:54 <lupo__> i forgot ...
13:48:55 <chessguy> are 2-3-finger trees different from what would be just called "2-3 trees"?
13:48:56 <lupo__> SamB++
13:49:01 <lupo__> xerox++
13:49:04 <lupo__> :)
13:49:05 <jbone_> apfelmus:  would love to see it.  would actually love to see any idiomatic Haskell solution. ;-)
13:49:16 <dons> malcolm_: don't worry, i had to give yhi a 2G heap yesterday to get it to finish one job
13:49:24 <SamB> what was that for?
13:49:45 <trurl> dcoutts: what I'm trying to do is to extend the treeList/DirList.hs demo s.t. it prints the selected file to stdout when I close the window.  I'm using treeViewGetSelection and then treeSelectionGetSelected to get an TreeIter of the selected row.  what should I use now (or am I already on the wrong track)?
13:50:08 <sjanssen> chessguy: yes, 2-3 finger trees have fingers :)
13:50:31 <apfelmus> jbone_: the only problem is that finger trees are "external code" though they can be reproduced on three pages or less
13:50:54 <sjanssen> chessguy: they're structured such that the left most and right most nodes are at the top for O(1) access
13:51:13 <chessguy> sjanssen, want to see one of my fingers? :)
13:51:46 <chessguy> hmm. interesting
13:52:02 * malcolm_ tries adding dummy arguments to the CAFs to see if it improves the runtime
13:52:17 <zeeeee> thanks nmessenger
13:52:52 <nmessenger> zeeeee: sure
13:54:42 <dcoutts> trane, that's slightly tricky actually, more tricky than I'd like. You'll have to get the path corresponding to the iter using treeModelGetPath and then the first component of that is the Int index you can use with listStoreGetValue
13:54:57 <lupo__> @zvon
13:54:58 <lambdabot> Unknown command, try @list
13:55:19 <jbone_> apfelmus:  any solution would be good, but a solution that abstracts the underlying data structure would be better.  I.e., could you write a harness that works over lists w/ suboptimal time complexity, in such a way that you could "plug in" finger trees later?
13:55:36 <dcoutts> trane, I should just change the API to use Paths everywhere and not expose Iters at all
13:56:37 <trurl> dcoutts: thanks
13:57:18 <apfelmus> jbone_: yes, though it's a bit unnatural. but the nice point about 2-3-finger trees is that you actually don't see much of them. they "just" provide a good sequence implementation with a twist
13:57:49 <apfelmus> the twist allows to mass produce complicated data structures
13:58:45 <apfelmus> in the sense that they're quite easy to produce :)
13:59:38 <trurl> dcoutts: it works, good night
13:59:57 <shapr> afaiu, the good point of finger trees is that they aren't bad at anything, right?
14:00:49 <apfelmus> shapr: yes and no. the point is that they are much more than sequences
14:01:05 <dcoutts> trurl, oh good
14:01:39 <chessguy> dcoutts, don't sound so surprised :)
14:01:44 * malcolm_ wonders if adding -ffast-math -mfpmath=sse -msse to building the nhc98 runtime interpreter would speed up all floating point programs.
14:01:47 <dcoutts> heh
14:01:53 <shapr> I want 23FTs in the base libs!
14:02:07 <dcoutts> shapr, huh? what's that?
14:02:09 <apfelmus> yeah, me too!
14:02:12 <shapr> 2-3 Finger Trees
14:02:23 <dcoutts> oh, but they are in the base lib
14:02:26 <shapr> oh they are?
14:02:33 <icarroll> Data.Sequence right?
14:02:37 <dcoutts> right
14:02:43 <sjanssen> Data.Sequence isn't as general
14:02:54 <shapr> Oh!
14:02:55 <apfelmus> Data.Sequence is a meager shadow of the 2-3 Finger Tree's raw power
14:02:56 <dcoutts> that doesn't expose the underlying general impl
14:04:05 <apfelmus> they're missing the ultra-important Measured class
14:04:24 <apfelmus> 2-3 Finger Trees! 2-3 Finger Trees! and now everybody, 2-3 Finger Trees! 2-3 Finger Trees!
14:04:36 * Igloo throws sausages at people who want everything in the base libs
14:04:40 <lupo__> lambdabot is so cool. i had him in the query for ten minutes and he didn't bore me.
14:04:43 <chessguy> mmmm, sausage
14:04:49 * nmessenger grabs a sausage and munches
14:04:53 <mbishop> lupo__: that sounded dirty
14:04:56 * chessguy is hungry
14:05:06 * apfelmus uses a 2-3-Finger-Tree to catch sausages
14:05:07 <sjanssen> maybe Paterson/Hinze would cabal Data.FingerTree up and put it on hackage?
14:05:16 <chessguy> lupo__, "he"s a she
14:05:24 <lupo__> okay, _she_ didn't bore me.
14:05:34 <lupo__> the point is that she knows so much.
14:05:37 <lupo__> @girll9
14:05:37 <lambdabot> I have been into not actually hacking, but social engineering
14:05:45 <lupo__> @yarr
14:05:46 <lambdabot> I heard andersca is a pirate
14:05:51 <lupo__> and so on...
14:05:56 <nmessenger> @list quote
14:05:57 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
14:06:01 <nmessenger> ^^ great module indeed
14:06:13 <icarroll> @protontorpedo
14:06:13 <lambdabot> what echniques can be used to scael application in haskell?
14:06:14 <nmessenger> @. elite protontorpedo
14:06:14 <lambdabot> h0\/\/ 48u+ v5 ap|
14:06:14 <chessguy> @quote nmessenger
14:06:15 <lambdabot> nmessenger says: EVERYONE ADMIRE MY ELDERBY HAT!!
14:06:28 <icarroll> wow
14:06:37 <lupo__> @quote dons
14:06:37 <lambdabot> dons says: Welcome to computer science, we count from 0.
14:06:56 <icarroll> how does the quote database get populated?
14:06:59 <apfelmus> Igloo: 2-3 Finger Trees are not just "a" data structures, they're a data structure factory. you can kick out Data.Map, Data.Set, Data.Sequence if you put them in the libs
14:07:11 <nmessenger> icarroll: people say @remember someone something
14:07:26 <nmessenger> @help remember
14:07:26 <sjanssen> apfelmus: I vote against removing Map and Set :)
14:07:26 <lambdabot> quote <nick>
14:07:26 <lambdabot> remember <nick> <quote>
14:07:26 <lambdabot> Quote somebody, a random person, or save a memorable quote
14:07:50 <lupo__> @help help
14:07:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:07:52 <apfelmus> sjanssen: obviously, you don't know 23FTs ;)
14:07:58 <lupo__> great.
14:08:04 <nmessenger> lupo__: try /msg lambdabot @
14:08:14 <nmessenger> lupo__: just '@'
14:08:16 <mbishop> @quote
14:08:21 <lambdabot> PaulPotts says: Haskell is an even "redder" pill than Lisp or Scheme
14:08:44 <mbishop> @quote C
14:08:45 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
14:08:54 <nmessenger> :D
14:09:10 <earthy> yaaay. from 3886.45 secs down to 2693.20 secs time usage
14:09:10 <chessguy> that's such a great error
14:09:16 <earthy> with a rather simple change
14:09:22 <earthy> and 8 times less allocation.
14:09:30 * earthy does a small dance
14:09:41 <nmessenger> @quote dance
14:09:41 <lambdabot> JohnMeacham says: her name is lambda and she dances on the sand
14:09:45 <maskd> @quote c\+\+
14:09:46 <lambdabot> psykotic says: monochrom, i'm reminded me of that alan kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
14:10:02 <opqdonut> @quote
14:10:02 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
14:10:06 <sjanssen> apfelmus: I know them, but I'm sure there is a performance hit to defining Data.Map and friends in terms of Data.FingerTree
14:10:06 <nmessenger> @quote vending
14:10:07 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
14:10:07 <lambdabot> of insight hits and it all makes sense.
14:10:13 <nmessenger> ^^ re: /topic
14:10:44 <apfelmus> sjanssen: ah, just a constant factor :)
14:11:02 <lupo__> some day you will curse at this channel because people will be here not for the language but the atmosphere and the nice bot.
14:11:03 <profmakx> *roll*
14:11:19 <nmessenger> @dice 2d6
14:11:19 <lambdabot> 2d6 => 3
14:11:21 <chessguy> lupo__, you don't know haskell very well yet
14:11:22 <apfelmus> sjanssen: also, tries are the way to go if you want to have a performant Map
14:11:24 <sjanssen> apfelmus: famous last words of a computer scientist
14:11:28 <lupo__> chessguy: right.
14:11:31 <sjanssen> apfelmus: right
14:11:37 <chessguy> sjanssen, right
14:11:39 <icarroll> I don't know about you, but I _am_ just here to talk to lambdabot
14:11:56 <apfelmus> @slap icarroll
14:11:57 * lambdabot slaps icarroll
14:11:59 <earthy> um. PATRICIA trees.
14:12:05 <earthy> but yeah, those are tries. ;)
14:12:08 <chessguy> @quote earthy
14:12:08 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
14:12:14 <lupo__> apfelmus: wonderful. you don't even have to do the slapping for yourself.
14:12:21 <apfelmus> hehe
14:12:29 <chessguy> that's a good one
14:12:30 <earthy> traverseAndFreeCoordinates     SmileUtil             66.5   21.2
14:12:30 <earthy> exportFastEvidence'            SmileExport           22.1    1.8
14:12:31 <sjanssen> I can't wait for ghc 6.8, associated data types make for a really nice generic trie
14:12:40 <earthy> damn. that's not gonna be an easy fix.
14:12:41 <nmessenger> @quote chessguy
14:12:41 <lambdabot> chessguy says: i didn't think pennsylvania had anybody cool enough to know haskell in it
14:12:56 <earthy> 88% of the time in the binding to the external lib...
14:13:03 <apfelmus> sjanssen: yeah, i'm eagerly waiting for associated types too.
14:13:05 <mbishop> qwe1234 says: all scripting languages are the same.
14:13:07 <earthy> oh well. time for bed.
14:13:09 <mbishop> heh I laughed
14:13:22 <nmessenger> mbishop: qwe's always good for a laugh
14:13:22 <mbishop> where's that qwe1234 been anyway? I miss his trolling
14:14:44 <chessguy> darn. i was going to ask something in here, but now i can't remember what it was. now i'm going to have to work until i remember it :(
14:14:57 <lupo__> oops
14:16:27 <mbishop> darn, someone removed my one quote from lambdabot
14:16:33 <mbishop> now I'll never be famous :(
14:17:41 <icarroll> @remember mbishop darn, someone removed my one quote from lambdabot now I'll never be famous :(
14:17:41 <lambdabot> Done.
14:17:49 <nmessenger> :)
14:17:53 <mbishop> haha >_<
14:17:59 <nmessenger> mbishop: what was your (first) quote?
14:18:12 <mbishop> something about nambla calculus and using little boys for numbers
14:18:19 <nmessenger> ah yes I remember
14:18:48 * nmessenger spends too much time on #haskell :/
14:19:48 <chessguy> @quote pennsyvlania
14:19:48 <lambdabot> No quotes match. That's something I cannot allow to happen.
14:19:58 <chessguy> @quote pennsylvania
14:19:58 <lambdabot> chessguy says: i didn't think pennsylvania had anybody cool enough to know haskell in it
14:20:06 <nmessenger> @quote chessguy
14:20:06 <lambdabot> chessguy says: [in regards to #haskell] man, it's amazing the difference between what happens when someone asks for help here, and what happens when they ask for help in another language channel
14:20:25 <chessguy> @quote nmessenger
14:20:26 <lambdabot> nmessenger says: <chessguy> lambdabot drives? <nmessenger> ...men wild!
14:20:33 <mbishop> wait, chessguy? I always thought your name was cheeseguy haha
14:20:45 <chessguy> grrr
14:20:50 <matthew-_> mbishop: you're not the only one to think that
14:20:58 <chessguy> chess >> cheese
14:21:18 <chessguy> why would you want to be named after mold
14:21:21 * nmessenger <3 chess and cheese
14:21:30 <kc5tja> chessguy: Because cheese ftw!!
14:21:34 * mbishop prefers Go and milk
14:21:37 <nmessenger> 'cause cheese is mold+awesome!
14:21:55 <kc5tja> Cheese+wine = <3
14:22:01 <chessguy> l like cheese, but not as much as chess
14:22:07 <chessguy> s/l /i
14:22:15 <lupo__> question: suppose i have a function somewhere in the "where" of another function, can i call that function from the outside?
14:22:20 <dons> nope
14:22:35 <nmessenger> lupo__: that's what the 'where' is for.  To restrict its scope
14:22:39 <mbishop> I don't like chess, I went play on FICS the other day and got beat by some new guy :(
14:23:23 <chessguy> as has been well-said, chess is an ocean that a gnat can drink from and an elephant can bathe in
14:23:53 <kc5tja> mbishop: Dude, I was playing billiards today with a coworker, and I wiped the table clean; and on the last ball to be pocketed, namely the 8 ball, I scratched.  GGAHHHH!!  So I don't want to hear it.  >:)
14:24:24 <kc5tja> chessguy: But the ocean that is chess is but a drop of rain compared to a 19x19 Go game.  :)
14:24:26 <lupo__> is there a shorter notation for "x :: Int\nx = someconst" ?
14:24:28 <mbishop> haha
14:24:31 <mbishop> kc5tja: had money on it?
14:24:39 <kc5tja> mbishop: No, I'm not stupid.  :)
14:24:41 <nmessenger> x = someconst :: Int
14:24:45 <sjanssen> lupo__: x = someconst :: Int
14:24:48 <chessguy> kc5tja, bah, go may have a bigger BF, but it's far less elegant
14:24:50 <lupo__> ah, that way round :)
14:24:59 <lupo__> noob tried x :: Int = const
14:25:15 <kc5tja> chessguy: Elegance is subjective.
14:25:20 <nmessenger> it's an annotation on an expression, i.e.:  x = (blah :: Int)
14:25:36 <sjanssen> lupo__: (x :: Int) = const -- works with GHC extensions
14:25:40 <chessguy> kc5tja, yes. and you're free to be wrong :)
14:25:46 <kc5tja> chessguy: As are you.
14:25:48 <lupo__> thanks
14:25:57 * mbishop nibbles on chessguy
14:26:10 <chessguy> @quote bite
14:26:11 <lambdabot> No quotes match. You speak an infinite deal of nothing
14:26:17 * nmessenger tears chunks from mbishop's skin.
14:26:24 <chessguy> lambdabot, you're not helping me out here
14:26:48 <icarroll> @slap lambdabot
14:26:48 <lambdabot> why on earth would I slap lambdabot
14:27:01 <dmead> @slap yourself
14:27:01 * lambdabot slaps yourself
14:27:06 <nmessenger> :)
14:27:09 <dmead> @slap myself
14:27:09 * lambdabot smacks myself about with a large trout
14:27:12 <dmead> :)
14:27:13 <chessguy> ?remember mbishop mbishop nibbles on chessguy
14:27:13 <lambdabot> Done.
14:27:15 <chessguy> take taht
14:27:29 <edwinb> @slap himself
14:27:29 <lambdabot> why on earth would I slap himself
14:27:33 <edwinb> curses
14:27:37 <nmessenger> *HER*self
14:27:40 <dmead> i win
14:27:41 <dmead> !
14:27:47 <edwinb> oops, I do beg her pardon
14:27:48 <Cale> chessguy: less elegant?
14:28:30 <nmessenger> @quote female
14:28:30 <lambdabot> lambdabot says: Of course i'm female
14:28:38 <chessguy> look, go's fine and all, but every move is just putting the same kind of piece onto the board
14:29:11 <Cale> Sort of :)
14:29:25 <Cale> I actually like the idea that there's only one kind of piece.
14:29:41 <Cale> Makes the game description much simpler :)
14:29:45 <kc5tja> Right.  But the interactions between the pieces are many.  From a game with so few rules comes all sorts of chaos.
14:29:46 <chessguy> in chess, you have pawn storms and races, and vicious sacrifices to rip open the king's defenses, and difficult long-term maneuvering games, and lots of different kinds of things
14:30:15 <kc5tja> (Chaos in the mathematical sense)
14:31:09 <edwinb> why argue about the relative merits of chess and go anyway?
14:31:13 <edwinb> they're both great games
14:31:37 <edwinb> go has "lots of different kinds of things" too
14:32:18 <chessguy> i've always had a much harder time learning and remembering the rules of go than chess
14:32:25 <qwr> chaos describes go pretty well, if you look go board from distance :)
14:32:27 <nmessenger> chessguy: I'd presume you've played a lot less go than chess?  :)  I'm of the same situation.  I don't make judgements about go since I know nothing about it.  I'd like to learn one day, though.
14:32:42 <bos> really? go's rules are trivial. it's all the patterns that are hard.
14:32:44 <kc5tja> chessguy: /me points to Monads versus objects.  :)  Now you know what boat *I* am in.  :)
14:32:44 <dibblego> I play both, including a state chess title - Go rocks
14:32:56 <chessguy> nmessenger, i'm not making judgements about go. i don't claim to know anything about it
14:33:06 <chessguy> dibblego, what state?
14:33:10 <kc5tja> dibblego: I don't think he said Go didn't rock.  He just said chess was more elegant.
14:33:11 <dibblego> Queensland
14:33:22 <sieni> bos: well, chess rules are trivial as well
14:33:23 <chessguy> they play chess in canada?
14:33:27 <Cale> chessguy: http://homepages.ihug.co.nz/~barryp/rules.htm has one of the nicest descriptions of the rules.
14:33:28 <lambdabot> Title: New Zealand Go Society Rules Of Go
14:33:32 <dibblego> never been there, but I assume so
14:33:42 <bos> sieni: chess has more rules than go.
14:33:44 <chessguy> wait...
14:33:49 <chessguy> oh queensland is australia?
14:33:53 <dibblego> yes
14:33:54 <tibbe> I'm reading "You could have invented monads" and I find this very confusing:
14:33:59 <tibbe> "We now must work out how to compose two randomised functions, f and g. The first element of the pair that f returns needs to be passed in as an input to g. But the seed returned from the g also needs to be passed in to f. Meanwhile the 'real' return value of g needs to be passed in as the first argument of f. So we can give this signature for bind:"
14:34:15 <tibbe> why does the seed have to be passed in the opposite direction?
14:34:26 <Cale> tibbe: good question :)
14:34:37 <tibbe> makes no sense to me
14:34:44 <allbery_b> I think sigfpe noted that as a typo but hasn't fixed it yet
14:34:47 <tibbe> couldn't the seed thing work like a state monad?
14:35:13 <Cale> I think that's just backward
14:35:18 <tibbe> yes
14:35:34 <tibbe> bind f x seed = let (x',seed') = x seed in f x' seed'
14:35:37 <Cale> So yeah, swap the f and g there with regard to where the seed is being passed.
14:35:38 <tibbe> he defines bind like that
14:35:38 <chessguy> Cale, i'll make a note of that for later. i actually have wondered if go wouldn't be an even better candidate for my GP ideas for chess than chess would be
14:36:33 <astrolabe> The nicest rules for go that I have seen are the Tromp-Taylor rules.  John Tromp has hung around in #haskell a lot.  I don't know if he still does.
14:36:39 <astrolabe> @seen tromp
14:36:39 <lambdabot> I haven't seen tromp.
14:36:39 <kc5tja> Hehe -- this is even more awesome a quote:
14:36:41 <kc5tja> "In Haskell a monad is represented as a type constructor (call it m), a function that builds values of that type (a -> m a), and a function that
14:36:44 <kc5tja> combines values of that type with computations that produce values of that type to produce a new computation for values of that type"
14:37:29 <monochrom> The code "bind f x seed = let (x',seed') = x seed in f x' seed'" says that x takes old seed and produces new seed, and new seed is given to f.
14:37:38 <monochrom> code doesn't lie. people do.
14:38:09 <nmessenger> m a {- a computation that produces a -} -> (a -> m b) {- a function from results to new computations -} -> m b {- the combined computation -}
14:38:14 <nmessenger> @type (>>=)
14:38:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:38:37 <monochrom> english is a great language for lying in.
14:39:15 <Cale> chessguy: If you'd like, I could give a demonstration of the rules and/or we could have some 9x9 games on KGS.
14:39:21 <monochrom> "m a -> (a -> m b) -> m b" is much more to the point than "mumble computation mumble computation mumble computation mumble"
14:39:37 <chessguy> ?remember nmessenger m a {- a computation that produces a -} -> (a -> m b) {- a function from results to new computations -} -> m b {- the combined computation -}
14:39:37 <lambdabot> Done.
14:39:40 <chessguy> nmessenger++
14:39:47 <chessguy> one of the best summaries of monads i've seen
14:40:03 <chessguy> s/monads/bind/
14:40:04 <nmessenger> :)  True, but concision isn't great when you don't have a good understanding of the basics
14:40:10 <sjanssen> @remember monochrom "m a -> (a -> m b) -> m b" is much more to the point than "mumble computation mumble computation mumble computation mumble"
14:40:10 <lambdabot> Done.
14:40:12 <chessguy> Cale, perhaps another time
14:40:23 <Excedrin> chessguy: if you're looking for some AI to code, what about Poker?
14:40:38 <chessguy> Excedrin, i don't recall saying i was looking for some AI to code
14:40:48 <nmessenger> chessguy: I stand upon the shoulders of giants.  Most of that is Cale's I believe.
14:40:49 <chessguy> i have plenty of AI i already want to code
14:41:00 <monochrom> It's almost like object oriented programming. "everything is an object."  the whole treatise is like "mumble object mumble method mumble object mumble method mumble".  I thought we fled from OOP precisely because of that.
14:41:04 <Excedrin> chessguy: GP for chess and go has been done to death
14:41:26 <chessguy> Excedrin, you spean an infinite deal of nothingness.
14:41:31 <chessguy> *speak
14:41:43 <Cale> I don't understand the interest in Poker. The difference between the best players and the weakest players is about 0.1 ranks, where a single rank is defined by one player beating another 75% of the time.
14:42:00 <tibbe> @srs Monad.State.(>>=)
14:42:01 <lambdabot> Source not found. That's something I cannot allow to happen.
14:42:12 <nmessenger> @src State (>>=)
14:42:12 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:42:13 <lupo__> chessguy: as long as you evaluate this speech in a lazy manner, you won't necessarily spend infinite time on it.
14:42:39 <chessguy> Excedrin, name one project that has done any GP in chess, much less "done it to death"
14:42:43 <monochrom> Cale: that explains the interest in Poker.  Everyone thinks "I can easily trump the best players".
14:42:45 <SamB> Cale: well, maybe the best players can get 75% of the worst players' money?
14:42:56 <tibbe> i still don't get sigfpe's bind
14:43:00 <Cale> SamB: I said 0.1 ranks :)
14:43:21 <monochrom> It also explains the interest in OOP.  Everyone thinks "I can BS my way just like the best players."
14:43:23 <Excedrin> chessguy: just google it, there's thousands of research papers for it
14:43:31 <SamB> that wouldn't be the same thing though
14:43:34 <chessguy> Excedrin, wrong again :)
14:43:59 <Excedrin> ok, 756,000 google results for chess gp
14:44:26 <Cale> I suppose it does mean that there's a relatively level playing field, but on the other hand, there's very little room for improvement.
14:44:45 <monochrom> It also explains the interest in certain BS treatises of monads.  Everyone thinks "wow, '... computation ... computation ... computation ... computation' must be very deep!"
14:44:55 <chessguy> yeah, and 1.1 million hits on "pool fart". what's your point?
14:45:23 <Excedrin> Cale: that's untrue, Poker is easily as complicated as Chess. It's interesting from an AI point of view because there isn't perfect information
14:45:24 <dons> Igloo: can we move fps into the core libs , and out of base, for 6.8 :)
14:45:42 <nmessenger> monochrom:  :)  Heh, one must show the 'return' computation in a bunch of monads to dispel that one.
14:45:49 <Igloo> dons: Sounds good to me  :-)
14:45:50 <chessguy> Excedrin, i've spent the past 5 years researching chess AI and genetic programming, and seen 1 paper on it
14:46:05 <Igloo> dons: Although preferably renaming it in the process
14:46:06 <chessguy> trust me, you don't know what you're talking about
14:46:14 <dons> Igloo: to what, bytestring ?
14:46:17 <dons> -package bytestring ?
14:46:37 <Igloo> That would be my first choice, although I wouldn't hugely object to bs
14:46:39 <chessguy> (1 paper on both, that is)
14:46:43 <Cale> Excedrin: The problem is that even if you make use of all that information, the randomness in the game obliterates most of the benefit to making use of it.
14:47:05 <dcoutts> dons, Igloo, I want to make other core bits take advantage of ByteString
14:47:10 <dcoutts> so I'd rather keep it in
14:47:28 * chessguy reminds himself not to feed the trolls
14:47:31 <Excedrin> Cale: that's not correct either, the goal of a poker strategy should be to win more than you lose, and a strong strategy will achieve that despite randomness
14:47:33 <dcoutts> I want to allow ordinary String programs to use ByteString transparently
14:47:56 <Cale> Excedrin: but only by a pretty small margin
14:47:57 <dcoutts> dons, I still think we can make the readFile thing work and preserve semantics
14:48:19 <Cale> Excedrin: you can't hope to be good enough to beat a beginner consistently 75% of the time, for instance
14:48:29 <dons> dcoutts: ok. i'm happy to work this out once you're here
14:48:38 <dcoutts> dons, that is, readFile = fmap B.unpack B.readFile and get things to fuse and preserve the semantics of []
14:48:44 <dons> we can decide what to do, when time comes to commit fps 1.0 (streams)
14:48:46 <dcoutts> ok
14:48:46 <Excedrin> Cale: part of the reason poker is popular is that a 1% margin translates to millions of dollars
14:48:48 <lucca> I don't think you grok poker
14:48:54 <lucca> you don't need to win consistently
14:49:18 <lucca> you need to have hire stakes when you win and lower stakes when you lose
14:49:32 <Saizan> is there a typeclass similar to Show but that doesn't quote the String? e.g. customshow (x::String) = x
14:49:36 <lucca> which is done through understanding the probabilities
14:49:41 <Cale> It's a measurement of the depth of the game. This is independent of concerns about stakes.
14:50:00 <lucca> poker should not be evaluated in terms of one hand
14:50:02 <glguy> it's call *statistics*, Cale ;)
14:50:02 <SamB> Cale: stakes are part of the game, though
14:50:10 <glguy> called*
14:50:25 <Cale> SamB: Well, only up to scalar multiples :)
14:50:34 <SamB> Cale: what the?
14:50:35 <dcoutts> Saizan, you can make a newtype if you want it
14:50:40 <lucca> ideally you also track how your opponents bet and what they had and form models of the flaws in their scoring algorithms which can be exploited
14:50:41 <monochrom> I think Cale groks Poker, the game.  I think Cale is admitting he doesn't grok Poker, the social phenomenon.  I think one has to grok human psychology for the latter.
14:50:44 <SamB> the game lasts longer than a hand. it is a lifelong process!
14:50:46 <dons> malcolm_: when adding something like that byteswap, (though simple) it'd be nice to have a QC property too :)
14:50:54 <SamB> or something
14:51:03 <Excedrin> Cale: the UofA poker guys have an open poker server where you can play your AI vs theirs, I'd love to see a Haskell bot that beats Poki consistently :)
14:51:26 <Saizan> dcoutts: i can't do that because i don't know the input types
14:51:32 <dons> ?users
14:51:32 <lupo__> yeah. i love this language. task: setting up a dynamic programming matrix (not optimized for speed, educ purposes). result: 9 lines of code, thereof 2 lines type definition and 3 lines constants definition.
14:51:32 <lambdabot> Maximum users seen in #haskell: 332, currently: 317 (95.5%), active: 63 (19.9%)
14:51:40 <Igloo> dcoutts: core or base?
14:51:46 <Cale> Excedrin: I doubt you could beat a random player consistently.
14:51:47 <lucca> Excedrin: sounds interesting, but Go is of more interest to me
14:52:08 <lucca> Cale: what do you mean by random player?
14:52:15 <Cale> A player who plays randomly.
14:52:16 <dcoutts> Igloo, base
14:52:20 <glguy> here we go..
14:52:28 * glguy shoves the irc client onto the dwm stack
14:52:29 <Igloo> dcoutts: Have you got any examples?
14:52:31 <Excedrin> Cale: that's totally incorrect, any reasonably strong amature can beat a random player 90% of the time
14:52:45 <Cale> Oh?
14:52:51 <monochrom> lupo__: yeah, dynamic programming using an array in a lazy language is trivial :)
14:53:11 <Igloo> dcoutts: And FWIW, I'm hoping any such examples are things that we can pull out of base into their own package  :-)
14:53:18 <Excedrin> if not 100%
14:53:40 <lucca> Excedrin: that sounds about right, anecdotally, but do you have any papers on that?
14:53:45 <glguy> Excedrin: the random player *could* just have better cards, couldn't be 100%
14:53:45 <SamB> and probably the random player would lose an awful lot of money from all the random bets...
14:53:45 <bos> it's fun to read conversations without scrollback. e.g. " any reasonably strong amature can beat a random player 90% of the time". what could the game in question be? go? roulette? wedgies?
14:53:46 <malcolm_> dons: noted
14:54:01 <lupo__> monochrom: tell that the poor students at my dept who struggle with imp. languages :)
14:54:08 <Cale> bos: He's talking about poker. I don't believe it :)
14:54:13 <dons> malcolm_: nhc seems to be running very happily on the amd64
14:54:16 <dons> good work!
14:54:47 <Excedrin> glguy: sure, they have better cards sometimes, but they'd lose pot after pot before they hit a big hand so the other player has no problem to win by simply playing good hands and going all in repeatedly
14:54:51 <malcolm_> dcoutts: i'm very keen to get fps out of base.  at the moment I'm prevented from using any new feature of fps, because of clashes with the base versions
14:54:57 <chessguy> Cale, well, there is a difference between winning on a given hand, and winning a game
14:55:07 <dons> malcolm_: initial results, http://www.cse.unsw.edu.au/~dons/tmp/results.html
14:55:08 <lambdabot> Title: nobench: Haskell implementation shootout
14:55:08 <lucca> Cale: a non-random player can adjust their risk/reward stakes as they gain knowledge through each hand.  A random player cannot
14:55:14 <Excedrin> glguy: the few times that the random player happens to hit a winning hand the pot is too small to matter
14:55:36 <lucca> Cale: even a 50.1% chance of winning a given hand means they'll beat a random player in the end.
14:55:39 <glguy> I'm just arguing that 100% is impossible since the random player can randomly make all the right decisions
14:55:42 <SamB> random players aren't very skillfull
14:55:42 <Cale> lucca: I know that a non-random player will have an advantage, I'm just claiming that this advantage is comparatively small.
14:55:42 <dcoutts> malcolm_, it's easy to have a developmental version of fps outside of base, I do that now for developing the streams version
14:55:50 <LoganCapaldo> @hpaste new
14:55:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:56:01 <SamB> I bet I could beat a random player 99% of the time at an FPS
14:56:13 <Cale> SamB: good example :)
14:56:13 <monochrom> Hey! If you extend the random monad to playing Poker, do you call the new monad... Pokermon? :)
14:56:15 <lucca> okay.  I think the argument then is whether the poker state stabilizes or not
14:56:31 <hpaste>  LoganCapaldo pasted "Saizan: this is probably abusive, but hereyou go" at http://hpaste.org/696
14:56:40 <dcoutts> Igloo, no I'm thinking of simple H98 examples, like: foo . lines =<< readFile bar
14:56:41 <chessguy> ?remember monochrom Hey! If you extend the random monad to playing Poker, do you call the new monad... Pokermon? :)
14:56:41 <malcolm_> dons: the geometric mean for nhc98 on spectral looks suspicious
14:56:41 <lambdabot> Done.
14:56:41 <SamB> there is always the chance that he cross a nuke launcher or something
14:56:44 <Excedrin> I suppose there's definite differences between diffferent poker games, no-limit holdem would be easiest to beat a random player (or no limit omaha or any no-limit game)
14:56:49 <monochrom> hee hee hee!
14:56:53 <chessguy> on that note...i'm on my way home
14:56:58 <malcolm_> dcoutts: how?
14:57:11 <dons> malcolm_: oh, the 0.0 :)
14:57:26 <dcoutts> malcolm_, prefix the modules with Experimental. or whatever
14:58:11 <dcoutts> Igloo, I want to transform that example into something like: foo . map unpack . B.lines =<< B.readFile
14:58:11 <malcolm_> dcoutts: so I have to manually darcs rename all the modules in fps ?
14:58:30 <dcoutts> malcolm_, you're hacking on fps too then?
14:58:46 <dcoutts> malcolm_, I didn't realise everyone else was doing it
14:59:06 <malcolm_> dons: yeah, running more than 100x faster on a single benchmark is rather skewing the geometric mean downwards :-)
14:59:24 <dcoutts> malcolm_, we could make our fps repo use that convention, the fps-unstable repo already does.
14:59:35 <malcolm_> dcoutts: not so much hacking on it, more like trying to use it, but needing a few extra features
14:59:55 <dcoutts> malcolm_, oh yes, like what?
15:00:08 <Saizan> LoganCapaldo: i've written something very similar, i was only wondering if it was yet somewhere
15:00:10 <malcolm_> I sent dons a patch today to implement byteswapping
15:00:15 <Igloo> dcoutts: core is fine for simple examples, it doesn't need to be in base
15:00:23 <LoganCapaldo> Saizan: ah k
15:00:35 <dcoutts> Igloo, not if Prelude.readFile uses it
15:00:35 <LoganCapaldo> takes forever to compile <g>
15:00:35 <malcolm_> we want to interpret the bytestring as 4-byte quantities (e.g. Float)
15:00:57 <dcoutts> malcolm_, it's ok to implement extras outside of the fps package of course, you do have direct access to the ByteString constructor
15:01:08 * dcoutts -> sleep
15:01:21 * dmhouse -> too
15:01:24 <Igloo> dcoutts: Do you mean you want Prelude.readFile to have type String -> IO ByteString?
15:01:29 <malcolm_> dcoutts: yeah, I did that for testing.
15:02:01 * Igloo is lost
15:02:07 <lupo__> it's 11:58pm here. have a nice day, bye, and thanks to everyone! :)
15:04:21 <malcolm_> dcoutts: there was a time when I wanted map' but it was only in fps, not base, which was a minor pain
15:11:20 <ddarius> @oldwiki WrapperType  Saizan
15:11:20 <lambdabot> http://www.haskell.org/hawiki/WrapperType  Saizan
15:12:26 <ddarius> @oldwiki TypeclassWrapper
15:12:27 <lambdabot> http://www.haskell.org/hawiki/TypeclassWrapper
15:15:00 <dons> JohnMeacham: i'm getting quite a few jhc errors about " hPutStr: illegal operation (handle is finalized)"
15:17:36 <nmessenger> @type \x -> fromMaybe (show x) (cast x)
15:17:39 <lambdabot> forall a. (Show a, Typeable a) => a -> String
15:18:36 <nmessenger> > (\x -> fromMaybe (show x) (cast x)) 5
15:18:38 <lambdabot>  "5"
15:18:40 <nmessenger> > (\x -> fromMaybe (show x) (cast x)) "5"
15:18:41 <lambdabot>  "5"
15:19:36 <nmessenger> TYPESAFE CAST = FUN
15:21:04 <allbery_b> hrm.  I assumed the only inhabitant of that type was _|_ just because both sides were independently forall'd, thus making the a on the right different from the one on the left
15:21:35 <allbery_b> well, a little moe complex than that
15:25:33 <ray> bos: nice post (the regex one)
15:26:00 <hpaste>  nmessenger annotated "Saizan: this is probably abusive, but hereyou go" with "Saizan, LoganCapaldo: why use extensions when you don't have to?  :D" at http://hpaste.org/696#a1
15:27:18 <OneSadPengWin> I'm having trouble figuring out why Integer is coming up in my program :(
15:27:28 <ray> now perl is obsolete :)
15:27:39 <OneSadPengWin> I have genGroupIndices f = map (\x -> map (f x) [0 .. 8]) [0 .. 8]
15:27:59 <OneSadPengWin> which hugs (and ghci) claim has type  (Num a, Enum a, Num b, Enum b) => (a -> b -> c) -> [[c]]
15:28:12 <allbery_b> defaulting
15:28:21 <OneSadPengWin> and if I ask either for :type genGroupIndices (\x y -> (9 * x) + y)
15:28:36 <OneSadPengWin> they say (Enum a, Num a) => [[a]]
15:28:38 <muddybike_> OneSadPengWin: use type signatures if you want Int instead
15:28:52 <OneSadPengWin> yet when I have rowGroupIndices = genGroupIndices (\x y -> (9 * x) + y)
15:29:04 <OneSadPengWin> the compiler claims it has type [[Integer]]
15:29:09 <allbery_b> ohhh
15:29:10 <OneSadPengWin> which seems random
15:29:18 <allbery_b> monomorphism restriction
15:29:35 <dons> bos, yes. very nice. =~ is more magical than I realised!
15:29:56 * OneSadPengWin googles "monomorphism restriction"
15:30:14 <mbishop> Hot monomorphic action!
15:30:20 <mbishop> Restricted Access!
15:30:25 <allbery_b> basically, any time you have foo = ... with no variables haskell98 is required to restrict polymorpism, so it assgns Integer as  aconcrete type via defaulting
15:30:26 <oren> I'm embarassed to ask this... but how does convert an Int to a Double? 'toDoub;e doesn't seem to exist...
15:30:32 <bd_> oren: fromIntegral
15:30:39 <bd_> > (fromIntegral (42 :: Int)) :: Double
15:30:40 <oren> Wow, that was quick
15:30:41 <lambdabot>  42.0
15:30:47 <oren> Coo,, thanks
15:30:51 <bd_> :t truncate
15:30:53 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:30:57 <bd_> for the other direction :)
15:30:58 <nmessenger> oren: simple questions like that usually are :D
15:31:22 * OneSadPengWin ducks as explanations of monomorphism restriction whoosh over his head
15:31:33 <oren> Should have looked at the fromXXX functions as well as the toXXX ones :-)
15:31:35 <LoganCapaldo> nmessenger: I said it was probably abusive. :) Plus when the only hammer you have a is a compiler flag, every problem starts looking like a, err, something that can be solved with compiler flags :)
15:31:38 <allbery_b> don't worry about t too much
15:31:58 <OneSadPengWin> the problem was, I wanted Int instead :)
15:32:03 <allbery_b> just recognze that hen you say foo = ... without any arguments to foo, it's safest to give an explicit type signature
15:32:06 <OneSadPengWin> so if I put an explicit type signature, I can avoid it?
15:32:11 <nmessenger> LoganCapaldo: heh.  Once again, TYPESAFE CASTS = MUCH FUN!
15:32:12 <OneSadPengWin> 'k'k
15:33:11 <LoganCapaldo> :t cast
15:33:14 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
15:33:19 <nmessenger> OneSadPengWin: short story: it's to ease inferencer implementation.  long story: I don't understand :D
15:33:36 <LoganCapaldo> :t fromMaybe
15:33:38 <lambdabot> forall a. a -> Maybe a -> a
15:33:54 <OneSadPengWin> thanks, allbery_b, everyone, the type signature works great
15:33:56 <LoganCapaldo> :t maybe
15:33:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:34:10 <nmessenger> fromMaybe default = maybe default id
15:34:32 <LoganCapaldo> nmessenger: I gathered, I was trying to do it with flip :)
15:35:15 <LoganCapaldo> wait
15:35:22 <LoganCapaldo> flip is not the combinator I'm looking for
15:35:30 <LoganCapaldo> oh yes it is
15:35:35 <LoganCapaldo> :t flip maybe id
15:35:37 <lambdabot> forall a. a -> Maybe a -> a
15:35:47 <LoganCapaldo> :t fromMaybe
15:35:49 <lambdabot> forall a. a -> Maybe a -> a
15:35:53 <LoganCapaldo> huzzag
15:35:58 <bd_> @djinn a -> Maybe a -> a
15:35:59 <lambdabot> f a b =
15:35:59 <lambdabot>     case b of
15:35:59 <lambdabot>     Nothing -> a
15:35:59 <lambdabot>     Just c -> c
15:36:04 <Darius> nmessenger: That's not the reason for the monomorphism restriction's existance at all (in that case)
15:36:21 <nmessenger> Darius: see long story :P
15:41:02 <LoganCapaldo> Can you deriving (Typeable) ?
15:41:18 <LoganCapaldo> Sure I could just try and do that
15:41:20 <monochrom> Yes.
15:41:27 <nmessenger> LoganCapaldo: with extensions I believe :D
15:41:37 <kpreid> LoganCapaldo: you can and should, in GHC
15:41:41 <LoganCapaldo> But if the answer was no, thered be a neat explanation along with why
15:41:46 <LoganCapaldo> :)
15:41:56 <nmessenger> @src Typeable
15:41:57 <lambdabot> Source not found. Take a stress pill and think things over.
15:42:15 <nmessenger> class Typeable a where typeOf :: a -> TypeRep
15:42:22 <nmessenger> not much magic
15:42:22 <monochrom> Oh, monomorphism restriction.  In imperative languages, it saves you a soundness embarrassment.  In pure languages, it helps code optimization.
15:43:00 <nmessenger> just a runtime representation of the type, so it can be compared, and safe casts can be made
15:43:37 <LoganCapaldo> Casts, or "polymorphic conversions"?
15:44:07 * LoganCapaldo doesn't believe the word cast and typesafe can be used in the same sentence :)
15:44:17 <LoganCapaldo> but that could be the C talking
15:44:21 <siti> :D
15:44:29 <nmessenger> casts, it changes what type the compiler thinks it is, and if it's not the right type, cast returns Nothing
15:44:51 <SamB> @hoogle cast
15:44:52 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
15:44:52 <lambdabot> Foreign.ForeignPtr.castForeignPtr :: ForeignPtr a -> ForeignPtr b
15:44:52 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
15:44:53 <ddarius> If you have a proof of type equality then even an unsafe cast would be safe, alternatively the proof could be the properly typed identity.
15:45:15 <LoganCapaldo> Oh so it just does a typesafe "downcast"?
15:45:19 <SamB> LoganCapaldo: what do you say to cast :: (Typeable a, Typeable b) => a -> Maybe b
15:45:24 <mbishop> technically haskell and others do 'coercion', I suppose
15:45:40 <SamB> ddarius: isn't that how System F_C works?
15:46:09 <LoganCapaldo> SamB: I would name that function "convert" was what I was getting at originally
15:46:30 <ddarius> SamB: Probably.  I'd have to know more about it than it's title though.
15:46:36 <SamB> LoganCapaldo: but it doesn't *do* anything
15:46:45 <LoganCapaldo> apparently
15:46:46 <nmessenger> but it doesn't actually *change* anything.  It just prods the compiler towards its type.
15:47:08 <LoganCapaldo> hence my "downcast" question
15:47:18 <LoganCapaldo> if I can abuse terminology thusly :)
15:47:27 <SamB> it doesn't do downcasts
15:47:29 <ddarius> It just reminds the compiler that two types are actually equal in the cases where it forgets.
15:47:45 <nmessenger> LoganCapaldo: technically, Haskell doesn't have subtypes, but your comment does have the right intuition.
15:48:11 <SamB> but you can't pass polymorphic types into that
15:48:14 * nmessenger waits to be told that Haskell *does* have subtyping
15:48:40 <sieni> does it?
15:48:47 <sieni> who wants subtyping?
15:48:55 <liquidengineer> Hi
15:49:01 <LoganCapaldo> So a goes from being "at least" an Typeable something to a String
15:49:02 <liquidengineer> I'm feeling sort of silly right now
15:49:12 <nmessenger> sieni: Heck, Oleg's probably hacked something in that direction.
15:49:12 <audreyt> haskell does have subtyping. :)
15:49:15 <liquidengineer> I can't figure out how to convert the length of a list to a FLoat
15:49:33 <audreyt> (forall a. (Show a, Read a) => a) is a subtype of (forall a. (Show a) => a)
15:49:39 <SamB> liquidengineer: fromIntegral
15:49:45 <siti> genericLength :p
15:49:45 <dons> > fromIntegral (length "haskell") :: Float
15:49:47 <lambdabot>  7.0
15:49:56 <SamB> siti: that may not be safe
15:50:02 <siti> > genericLength "test" :: Float
15:50:03 <lambdabot>  4.0
15:50:08 <siti> maybe
15:50:16 <siti> close enough isn't it :p
15:50:26 <kpreid> well, length might not be safe either.
15:50:31 <siti> if you work with floats you should not want 100% accuracy :p
15:50:48 <kpreid> > fromIntegral (genericLength "haskell" :: Integer) :: Float
15:50:50 <lambdabot>  7.0
15:50:51 <kpreid> -- that's safe :-)
15:50:57 <siti> lol
15:50:58 * LoganCapaldo is suspecting that polymorphic functions and overloaded functions are not implemented the way he originally imagined
15:51:00 <SamB> > genericLength [minBound .. maxBound :: Int] :: Float
15:51:04 <lambdabot>  Exception: stack overflow
15:51:07 <SamB> hmm.
15:51:11 <SamB> see what I mean?
15:51:13 <SamB> not safe!
15:51:15 <monochrom> Don't implement anything.
15:51:22 <siti> hah
15:51:24 <SamB> > length [minBound .. maxBound :: Int]
15:51:27 <JohnMeacham> dons: hmmm.. that is because ghc closes stderr before it can print out a proper error a lot of the time.. probably due to a stack overflow.
15:51:28 <lambdabot> Terminated
15:51:44 <siti> > length [1..]
15:51:48 <lambdabot> Terminated
15:52:04 <SamB> LoganCapaldo: how had you imagined?
15:52:31 <LoganCapaldo> SamB: that it basically filled in the type variable(s) at the call site and compiled for the given types
15:52:37 <dons> JohnMeacham: http://www.cse.unsw.edu.au/~dons/tmp/results.html
15:52:38 <lambdabot> Title: nobench: Haskell implementation shootout
15:52:50 <nmessenger> cast x = r
15:52:50 <nmessenger>        where
15:52:50 <nmessenger> 	 r = if typeOf x == typeOf (fromJust r)
15:52:50 <nmessenger>                then Just $ unsafeCoerce x
15:52:51 <nmessenger> 	       else Nothing
15:52:51 <dons> a few compilation errors. i'll investigate further
15:53:03 <SamB> LoganCapaldo: that would be nice
15:53:36 <LoganCapaldo> which is why the cast thing threw me off
15:53:57 <LoganCapaldo> I figured when you called it it _knew_ it was a string cause that had been "filled in"
15:54:02 <SamB> actually, I think ndm has code that essentially does that, except it also does that with higher-order functions...
15:54:27 <LoganCapaldo> and that you jsut had a bunch of cast functions defined for various pairs of types
15:54:42 <SamB> nope. only one..
15:54:45 <SamB> @src cast
15:54:46 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:54:54 <nmessenger> SamB, LoganCapaldo: ^^ cast
15:54:58 <SamB> @src Data.Typeable.cast
15:54:59 <lambdabot> Source not found. Where did you learn to type?
15:55:03 <LoganCapaldo> but it looks like to me now that the compiler only knows that its some type thats Typeable
15:55:16 <kpreid> LoganCapaldo: you mean such that e.g. instance Cast X X  where cast = Just; instance Cast X Y where cast _ = Nothing ?
15:55:19 <LoganCapaldo> and cast just says "I promise this is actually a string"
15:55:21 <SamB> it also has a dictionary with the methods for the class
15:55:28 <SamB> LoganCapaldo: no it doesn't
15:55:30 <nmessenger> LoganCapaldo: yep, the Typeable class just lets you get at a TypeRep, given a value
15:55:33 <JohnMeacham> dons: hrm... better switch back to jhc-ghc. I'll look at the logs and see if there is something obvious.
15:55:44 <LoganCapaldo> kpreid: yeah sorta like that :)
15:55:57 <dons> JohnMeacham: just le me copy the logs over now
15:56:02 <SamB> Prelude Data.Typeable> cast "Hi!" :: Maybe Int
15:56:02 <SamB> Nothing
15:56:03 <LoganCapaldo> SamB: err
15:56:07 <LoganCapaldo> that came out wront
15:56:09 <LoganCapaldo> *wrong
15:56:15 <LoganCapaldo> I didn't really mean it :)
15:56:38 <JohnMeacham> I expected more to compile, but perhaps more run-time errors. odd.
15:56:39 <LoganCapaldo> cast says "try this on for size as a string, if you like it, keep wearing it" :)
15:57:32 <audreyt> GHC.Exts> unsafeCoerce# "Hi!" :: Int
15:57:33 <kpreid> Data.Generics, Data.Dynamic, and making your own existential types can be enlightening.
15:57:39 <nmessenger> LoganCapaldo: a TypeRep is just an ordinary datatype that represents "types" as Haskell values.  The typeable class gives you a TypeRep for each value in it, cast just compares that the TypeReps are equal, and unsafeCoerces
15:57:58 <dons> JohnMeacham: here, logs appearning now,http://www.cse.unsw.edu.au/~dons/nobench/x86_64/logs/
15:57:58 <LoganCapaldo> nmessenger: yeah
15:57:58 <nmessenger> (which should be safe, since we're coercing to the type that it already is)
15:58:00 <lambdabot> Title: Index of /~dons/nobench/x86_64/logs
15:58:02 <SamB> audreyt: which is why we call it unsafeCoerce#, and not cast
15:58:04 <LoganCapaldo> I get that now
15:58:26 <LoganCapaldo> until some one lies in their instance Typeable part :)
15:58:42 <nmessenger> LoganCapaldo: that's why you don't do things like that :D
15:58:49 <nmessenger> BOOM!
15:59:19 <JohnMeacham> dons: could you start passing '-v' to all the jhc builds? it makes it much easier to debug from the logs.
15:59:23 <SamB> Prelude GHC.Exts> unsafeCoerce# "Hi!"# :: Int
15:59:23 <SamB> -1209999024
15:59:26 <dons> ok.
15:59:33 <bd_> ""#?
15:59:41 <bd_> is that a byte array or something?
15:59:49 <nmessenger> prolly a strict list
15:59:54 <SamB> Prelude GHC.Exts> :t "Hi!"#
15:59:54 <SamB> "Hi!"# :: Addr#
15:59:55 <audreyt> yes, that's a byte array or something.
15:59:56 <dons> unboxed string
16:00:00 <bd_> ic
16:00:13 <LoganCapaldo> yuck
16:00:25 <SamB> how about...
16:00:31 * LoganCapaldo pretends he can't see # symbols
16:00:41 <SamB> hmm
16:00:47 <SamB> maybe that crashed it though
16:00:59 <LoganCapaldo> You guys are destroying my innocence
16:01:07 <bos> @hoogle forkIO
16:01:07 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
16:01:14 <LoganCapaldo> Haskell was supposed to be safe
16:01:15 <SamB> LoganCapaldo: I think that doesn't actually work
16:01:44 <SamB> oh, well, don't play with sharp implements unless you either (a) know what you are doing or (b) are trying to crash ghci
16:02:18 <monochrom> I am trying to launch missiles.
16:02:38 <allbery_b> haskell is plenty safe as long as you ignore anything named "unsafe" or "#" :)
16:03:06 <LoganCapaldo> ah yes, Haskell is safe because it has namespaces for the dangerous things :)
16:03:06 <SamB> and its a good idea to avoid hClose, too
16:03:17 <nmessenger> allbery_b: especially as those are not "Haskell" things, but "GHC" things :)
16:03:21 <LoganCapaldo> hClose... as in closing a file?
16:03:34 <SamB> well, it seems the most popular usage is...
16:03:40 <LoganCapaldo> @type hCloase
16:03:42 <lambdabot> Not in scope: `hCloase'
16:03:44 <LoganCapaldo> @type hClose
16:03:47 <lambdabot> Not in scope: `hClose'
16:03:51 <LoganCapaldo> oh fine
16:04:03 <SamB> do text <- hGetContents handle; hClose handle
16:04:09 <JohnMeacham> dons: among other things, it spits out the whole command line and other info right at the beginning.
16:04:20 <SamB> (with some more stuff after that that tries to use the text)
16:04:21 <nmessenger> @remember LoganCapaldo You guys are destroying my innocence
16:04:22 <lambdabot> Done.
16:04:32 <LoganCapaldo> heh
16:04:48 <SamB> @quote LoganCapaldo
16:04:49 <lambdabot> LoganCapaldo says: You guys are destroying my innocence
16:05:19 <muddybike_> @quote psnl
16:05:20 <nmessenger> happy to help :D
16:05:20 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
16:05:28 <dons> JohnMeacham: i'm rerunning the suite now with -v
16:05:28 <muddybike_> @quote psnl
16:05:29 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
16:05:32 <nmessenger> LOL
16:06:00 <muddybike_> @quote edwinb
16:06:00 <lambdabot> edwinb says: I think I'd panic if I had to write something that wasn't a compiler.
16:06:02 <Mushy-pea> Hi.
16:06:09 * nmessenger actually laughs aloud, for quite a while.  :D
16:06:09 <SamB> heh
16:06:19 <SamB> nmessenger: at which?
16:06:31 <nmessenger> metaphor = leaky screwdriver
16:06:32 <LoganCapaldo> I would think that the close would be lazily evaluated too :)
16:06:50 <SamB> LoganCapaldo: heh
16:07:01 <LoganCapaldo> It could get computed when you ran out of fds :)
16:07:13 * edwinb *is* completely unusable outside of compiler and theorem prover writing...
16:07:41 <SamB> edwinb: can you write a compiler for CPU core emulators?
16:07:55 <edwinb> No
16:07:59 <muddybike_> ... and what about go programs?
16:08:01 <edwinb> I'm quite unusable in those fields too
16:10:53 <astrolabe> I've written a haskell go program
16:10:58 <astrolabe> Sadly, it is crap
16:11:17 <astrolabe> but perhaps I'll be able to make it better
16:11:26 <Mushy-pea> What is a go program?
16:11:36 <astrolabe> go is an oriental board game
16:11:48 <muddybike_> edwinb: have you seen the monte-carlo stuff for go programming?
16:11:59 <edwinb> yes, looks interesting
16:12:19 <Mushy-pea> I've heard of it.  I wasn't sure that was what you meant.
16:13:23 <Mushy-pea> Does anyone know of websites that host Haskell discussion forums?
16:13:42 <gravity> Mushy-pea: Heh, reddit is probably the closest thing
16:15:10 <dons> we don't have a proper forum. the mailing list, haskell-cafe, is used instead
16:15:13 <dons> ?where mailing-list
16:15:14 <lambdabot> I know nothing about mailing-list.
16:15:16 <dons> ?where mailing-lists
16:15:17 <lambdabot> I know nothing about mailing-lists.
16:15:31 <dons> find it from haskell.org :)
16:15:39 <dons> ?where mailinglist
16:15:39 <lambdabot> http://haskell.org/haskellwiki/Mailing_lists
16:15:44 <Mushy-pea> The reason I asked is; I have been working on some open source forum software recently....
16:15:55 <dons> oh . nice.
16:16:05 <dons> in haskell i hope ..
16:16:13 <dons> since there's too much php already in the world
16:16:42 <Mushy-pea> perl.  It's called perlBB.
16:17:13 <dons> there's too much perl as well ;)
16:17:37 <dons> actually, wouldn't be too hard to turn hpaste.org into a forum
16:17:42 <dons> ?paste
16:17:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:17:54 <Mushy-pea> When it's ready I was planning to open some programming related forums on my home page.
16:18:23 <Mushy-pea> Mostly about less popular languages like Haskell.
16:18:42 <dons> LtU is actually the main forum for this kind of thing
16:19:22 <psnl> muddybike_: Do I know you?
16:19:26 <SamB> heh
16:19:34 <Mushy-pea> Could you give me an address for that (assuming it is a website)?
16:19:36 <SamB> a pastebin forum
16:19:45 <SamB> @google lambda the ultimate
16:19:49 <lambdabot> http://lambda-the-ultimate.org/
16:19:49 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
16:21:00 <Mushy-pea> lambdabot: thanks.
16:21:16 <Mushy-pea> Looks interesting.
16:21:33 <SamB> lambdabot is a bot ;-)
16:21:33 <muddybike_> psnl: yes.
16:21:56 <Mushy-pea> Out of interest, does anyone write web applications in Haskell?
16:22:33 <SamB> @paste
16:22:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:22:40 <SamB> Mushy-pea: see that
16:23:34 <chessguy> hi haskellers
16:23:36 <edwinb> muddybike_: how are the twins?
16:23:45 <dons> > let why'don't'people'write'identifiers'like'this = 7 in why'don't'people'write'identifiers'like'this -- ?
16:23:47 <lambdabot>  7
16:24:11 <psnl> edwinb: good to see you reached the same answer as me
16:24:15 <muddybike_> edwinb: the twins mastered "Maybe" today
16:24:16 <chessguy> dons, because we'd have to maim them
16:24:43 <dons> > let head'n'tail xs = (head xs, tail xs) in head'n'tail "haskell"
16:24:45 <lambdabot>  ('h',"askell")
16:24:55 <mwc> Mushy-pea, yes, look up Happs... happs.org I believe
16:25:08 <dons> muddybike_: yes, hpaste.org is the example I cited
16:25:11 <gravity> hrmpf, the happs install on debian is seriously broken.
16:25:12 <dons> ?paste <-- HERE :)
16:25:12 <mwc> Now here's a question... anybody know of a place to host a HApp?
16:25:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:25:20 <dons> mwc, shapr's box
16:25:36 <mwc> dons, lol, think he'd host a small business :)
16:25:37 <Pseudonym> Hack root on shapr's box, you can host anything you like.
16:25:53 <mwc> gravity, try the stale or rusting repos instead ;)
16:25:56 <dons> mwc, hmm. for a fee, maybe
16:26:01 <gravity> mwc: :-p
16:26:02 <dons> he hosts hpaste.org for free
16:26:56 <mwc> happs looks pretty cool, and I have the opportunity to make a few bucks doing a bit of web dev, but it looks like I'll be going with some sort of php monster because it's dirt cheap to host it.
16:27:47 <mwc> Hosting it with some guy I know on ISP probably won't sell.
16:28:01 <mwc> There must be some hosting company that lets you replace the httpd
16:29:25 <mwc> s/ISP/IRC
16:33:09 <hpaste>  ptolomy pasted "regex replace example" at http://hpaste.org/697
16:33:56 <chessguy> ?where parsec
16:33:57 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
16:38:18 <syntaxfree> this fizzbuzz crap is just unbelievable.
16:39:19 <ptolomy> syntaxfree: Which part of it?
16:39:57 <syntaxfree> that people with programming-related degrees can't do it.
16:40:00 <emk> mwc: There's a bunch of good virtual Linux hosts starting at $20/month. I'm fond of Linode, but there's got to be at least a dozen more out there.
16:40:24 <emk> Getting a root account on a virtual Linux server is cheap these days, and then you can run your choice of distro and servers.
16:40:59 <emk> syntaxfree: At least in the US, those folks definitely exist.
16:42:08 <syntaxfree> Jesus. I have to apply for a worker visa or something.
16:42:14 <emk> You wouldn't believe some of the horror stories I could tell you.
16:42:18 <syntaxfree> Of course, I can code only in Haskell :)
16:43:22 <emk> Yeah, but as folks keep pointing out, there's a huge number of applicants who apply to every open job and never get hired, and they're (mostly) the ones that get filtered by fizzbuzz. People who are actually employed steadily have higher average skill.
16:43:45 * emk programs in Scheme at work
16:43:55 <syntaxfree> I do know *some* scheme.
16:44:06 <syntaxfree> I had a Scheme course that was equivalent to maybe the first third of SICP.
16:44:13 * ptolomy programs in ruby and haskell at work, despite being paid to program in C++/C#..
16:44:49 <syntaxfree> "This program should be in PHP"
16:45:05 <syntaxfree> "<?php system("runhaskell "actualprogram.hs") ?>"
16:45:31 <emk> syntaxfree++
16:47:03 <monochrom> There is a syntax error.
16:47:16 <syntaxfree> I don't know if "system" is an actual php function.
16:47:19 <siti> no semicolon!!!
16:47:31 <syntaxfree> That's how one called the shell in QBASIC.
16:47:35 <monochrom> I'm referring to the " symbols
16:47:39 <syntaxfree> siti: no semicolon needed for a one-liner.
16:47:48 <siti> k
16:47:49 <syntaxfree> monochrom: true.
16:48:01 <monochrom> hee hee
16:48:10 * monochrom likes being a computer.
16:48:50 <syntaxfree> I have this running gag where someone says something I don't understand and I say "Parse error on token blah".
16:49:08 <emk> monochrom: If you're a computer, you clearly owe us all a good blog post on strong AI in Haskell. :-)
16:49:50 <syntaxfree> I once got to tell a friend who was flirting heavily with me "Error: please set -fnomonomorphism restriction or add explicitly type signature".
16:50:02 <syntaxfree> of course, she stared at me blankly.
16:50:03 <monochrom> I should hack into other people's blogs for that. At least Hollywood thinks so. :)
16:50:58 <dons> Igloo: pretty links on errors now: http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
16:50:59 <lambdabot> Title: nobench: Haskell implementation shootout
16:51:33 <emk> syntaxfree: I'm trying hard to imagine the circumstances under which GHC error messages are good pickup lines.
16:51:46 <Igloo> dons: Cool, ta
16:51:47 <dons> JohnMeacham: clicking on 'errors' should now show the -v version of the logs, at the nobench url, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
16:51:48 <lambdabot> Title: nobench: Haskell implementation shootout
16:52:03 * dons <3 xhtml + css
16:52:20 <dons> you just map data constructors to css div tags. then let your css file do instance Ppr Type where ... :)
16:52:36 <Igloo> dons: OK, so the ghci failures are mostly stack overflows, but that could be increased complexity rather than just constant factors
16:52:42 <syntaxfree> emk: come on, that was a good one.
16:52:59 <syntaxfree> it wasn't really a pick-up line, it was more of "well, this is starting to get confusing. State your intentions"
16:53:11 <dons> Igloo: right. I wasn't able to get them to pass with even 512M stack
16:53:34 <dons> ah, and missing -cpp for the happy benchmark
16:53:59 <emk> I'm currently splitting my probability stuff into modules and making a nice Cabal package.
16:54:17 <JohnMeacham> dons: you should put a 'AddDefaultCharset utf-8' in your .htaccess file so the output looks okay.
16:54:32 <monochrom> The next web revolution is "instance Ppr CSS".
16:55:20 <dons> JohnMeacham: there you go.
16:55:22 <dons> seems to work
16:55:24 <monochrom> DSL ppr code in haskell that gets mapped to css. :)
16:55:39 <dons> yeah.
16:56:29 <dons> JohnMeacham: so are those compilation errors making sense?
16:56:35 <JohnMeacham> pretty. :)  utf8 is the only reasonable character set nowadays.
16:56:58 <JohnMeacham> dons: odd. they look like bugs I had fixed before. but now am not sure.
16:57:00 <monochrom> Hear hear!
16:59:35 <dons> JohnMeacham: maybe grab the nobench suite and see if you can reproduce those failures?
17:01:22 <JohnMeacham> dons: that is what I will try to do. I will also modify jhc to spit out some other pertinent stuff by default like the hash of the libraries it is using that will be helpful for debugging someones remote run.
17:02:07 <JohnMeacham> in unix there is only one way to suceed, but there are 2^8 - 1 ways to fail.
17:02:14 <dons> :)
17:03:35 <dons> Igloo:right, so the only ghci errors now are 3 stack overflows
17:04:12 <dons> the performance of 'atom' might warrant investigation
17:04:42 <dons> seems much slower on amd than on x86
17:04:46 * dons pokes around
17:15:37 <orbitz> compeltley unrelated to haskell, but has anyone had any experience with K/J?
17:16:00 <Cale> orbitz: I think some people around here have. I've played around with them briefly.
17:16:22 <mwc> emk, thanks, looking into that
17:16:29 <dons> shapr's hacked a little J I think
17:16:37 <orbitz> Cale: everyone first reaciton to it is it's so ugly, but it seem to relaly be elegant in its own way, is that your reaciton to it?
17:16:56 <Cale> orbitz: They're like saner versions of APL
17:17:06 <Cale> and yeah
17:17:25 <dons> Cale, up for a quick hacking challenge?
17:17:27 <dons> http://factorlang-fornovices.blogspot.com/2007/02/practical-factor-writing-reddit-reader.html
17:17:41 <lambdabot> Title: Factor Language for Novices: Practical Factor - writing a reddit reader and some ..., http://tinyurl.com/26lgvs
17:17:51 <dons> teak the arrow feed aggregator to be shorter andcleaner than the factor code :)
17:17:55 <dons> tweak/
17:18:11 <allbery_b> I worked with J a bit... in the 80s.  forgotten most of it by now :)
17:18:40 <Cale> dons: Oh, I was about to say, "I've already done that haven't I?" :)
17:19:48 <dons> you just need to tweak it, represent the code, make some comments about how easy it was to refactor :)
17:19:50 <Cale> dons: I wonder how well HBC would stand up in the nobench shootout.
17:20:08 <dons> quite well, see on x86: http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
17:20:09 <lambdabot> Title: nobench: Haskell implementation shootout
17:20:17 <Cale> aha
17:20:31 <dons> lennart's actually started poking around the src again
17:20:49 <Cale> Yeah, there are some areas where it puts GHC to shame. It would be good to know why.
17:21:10 <Cale> Wow, look at calendar.
17:21:20 <dons> yeah, calendar is a bug.
17:21:24 <dons> simon's looking into it
17:21:28 <JohnMeacham> does it still compile via lml? where is the "current" hbc source anyway?
17:21:28 <dons> (ghc wins with -Onot)
17:21:33 <dons> ?where hbc
17:21:34 <lambdabot> I know nothing about hbc.
17:21:35 <dons> :)
17:21:39 <dons> grr
17:21:40 <JohnMeacham> @where hbc
17:21:41 <lambdabot> I know nothing about hbc.
17:21:47 <dons> ?where+ hbc http://www.cse.unsw.edu.au/~dons/code/hbc
17:21:48 <lambdabot> Done.
17:21:52 <dons> yeah, still via lml
17:21:57 <dons> so you need an lml binary first
17:22:23 <JohnMeacham> ah. cool.
17:22:27 <Cale> also, we had some issues with performance of arrays the other day, where HBC did a much better job of optimisation.
17:22:56 <JohnMeacham> oh. and it's _written_ in lml too? hmm.. not as good.
17:23:36 <JohnMeacham> I am so glad haskell did away with handwritten 'hi' files.
17:23:58 <Pseudonym> Yes, and .hi-boot files, too.
17:24:10 <Cale> GHC has?
17:24:25 * Pseudonym <- sardonic
17:24:29 <Cale> Does that mean we have proper support for mutually recursive modules?
17:25:12 * LoganCapaldo still doesn't get why you'd want / need mutually recursive modules
17:25:26 <dons> simplifies code in larger projects
17:25:34 <Cale> LoganCapaldo: not every project breaks down logically into a tree
17:25:39 <dons> since you don't have to worry about breaking module dependencies
17:25:47 <LoganCapaldo> But at the module level!?!?!?!
17:25:50 <Cale> (or even a dag)
17:25:52 * LoganCapaldo boggles
17:25:53 <JohnMeacham> jhc does. it compiles groups of mutually recursive modules at once.
17:25:55 <dons> seems to only matter once you're above 20 or 30 modules though
17:26:02 <Pseudonym> LoganCapaldo, the alternative is making your module huge.
17:26:09 <Cale> Yeah, I've had issues with it, where I had to awkwardly factor modules out.
17:26:19 <Pseudonym> Putting the entire SCC, plus anything that logically belongs with it, in one module.
17:26:25 <dons> LoganCapaldo: programming in the large :)
17:26:25 <JohnMeacham> I mean, in the past, you used to have to write 'hi' files manually for every 'hs' file you had, like 'h' files for c or 't' files for lml.
17:27:05 <dons> JohnMeacham: let me know when you have some jhc patches I should try out
17:27:11 <Pseudonym> Sure.  My point is that they're not entirely gone.
17:27:11 <Cale> The most common thing is where you have a module declaring a type and some operations on that type, but some of those operations want to make use of code that's in another module, which needs to know about the type you're defining.
17:27:22 <JohnMeacham> dons: sure thing.
17:27:24 <LoganCapaldo> dons: I think you haskell people like saying the word "recursive" and come up with excuses to use it :)
17:27:37 <dons> no no. *mutually recursive*
17:27:40 <Cale> The usual fix is to separate out the type declaration into its own module, but that's annoying.
17:27:41 <dons> that's the fun part.
17:27:41 <JohnMeacham> Psudonym: they are in jhc.
17:27:51 <Pseudonym> Cale: In that case, it's possible to declare just the type in one module.
17:27:57 <Pseudonym> That's a common hack that I use.
17:28:05 <Cale> Yeah, what I just said :)
17:28:08 <Pseudonym> It's not great, but it's often better than .hi-boot files.
17:28:09 <Pseudonym> Right.
17:28:28 <Pseudonym> It can break abstraction, if you don't want the concrete type exposed.
17:28:36 <LoganCapaldo> Oh you know what my problem is?
17:28:37 <Cale> I've run into more complicated issues as well and really had to work out my module dependencies on paper.
17:28:45 <LoganCapaldo> Too much ruby
17:28:46 <Pseudonym> JohnMeacham: Yes, and that's fabulous. :-)
17:28:55 <Olathe> Heresy ! ;)
17:29:03 <LoganCapaldo> I normally just _use_ the code from the other module
17:29:21 <LoganCapaldo> I don't think about how its technically mutually recursive
17:29:37 <LoganCapaldo> cause ruby will just assume it'll show up eventually :)
17:30:22 <Pseudonym> You pay a price for that, and it's a bigger price than you pay for lazy evaluation.
17:30:37 <LoganCapaldo> (I still don't do things like require a from b and require b from a though)
17:30:42 <Pseudonym> Modern programming languages that care about performance depend highly on compile-time optimisation.
17:30:55 <Pseudonym> And, increasingly, inter-module optimisation.
17:30:55 <LoganCapaldo> Performace? What performance :)
17:31:17 <Pseudonym> LogalCapaldo: Language shootout numbers, of course.  What other kind of performance is there?
17:31:20 <LoganCapaldo> there are no performance concerns in ruby code, it just does whatever :)
17:31:32 <dcnstrct> ouuuh you guys are talking about Ruby
17:31:39 <LoganCapaldo> no we aren't
17:31:40 <dcnstrct> does whatever indeed
17:31:47 <LoganCapaldo> we're talking about mutually recursive modules
17:32:13 <JohnMeacham> I'm talking about pizza and chinchillas. I don't know what these guys are going on about.
17:33:01 <dons> this is my favourite graph, it really shows you what static typing and native code compilers get you: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ruby
17:33:03 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/veo3w
17:34:07 <Cale> dons: haha
17:34:08 <narain> :pf map2 f = map . (map f)
17:34:25 <narain> @pf map2 f = map . (map f)
17:34:25 <lambdabot> Maybe you meant: bf pl
17:34:32 <narain> @pl map2 f = map . (map f)
17:34:32 <lambdabot> map2 = (map .) . map
17:35:18 <dcnstrct> speaking of Ruby, I wish I could inline Haskell code in my Ruby the same way I do with C
17:35:33 <dcnstrct> that would kick serious ass
17:35:43 <LoganCapaldo> dcnstrct: I don't think it would be that hard to do
17:35:53 <narain> @pl map2 f l = map (map f) l
17:35:54 <lambdabot> map2 = map . map
17:35:55 <LoganCapaldo> you should write the it :)
17:36:31 <LoganCapaldo> dons: hey I see something that ruby's better at on that graph <g>
17:37:04 <Philippa> LoganCapaldo: I've done some sick and interesting things with mutually recursive modules
17:37:14 <LoganCapaldo> Philippa: you would ;)
17:37:38 <LoganCapaldo> You're alll crazy
17:37:40 <dcnstrct> LoganCapaldo, I'll certainly look into it... zenspider in #ruby-lang thinks it should not be too difficult, and he wrote the inline c stuff
17:37:45 <LoganCapaldo> I'm alone in the sanity
17:37:55 <ptolomy> Yeah, should just be another builder class for RubyInline.
17:38:06 <Philippa> the alternatives were piling it all into one module or adopting a significantly worse design - it was just what was natural for the (admittedly mildly non-trivial) structure I was building
17:38:09 <LoganCapaldo> dcnstrct: yeah you don't have to start from scratch. Inline can do more than just C
17:38:10 <dons> hehe. you could use haskell for your inner loops! :)
17:38:11 <ptolomy> .. for very large values of "just".
17:38:23 <dons> there's already inline haskel in perl6, btw.
17:38:26 <dons> so definitely possible
17:38:33 <LoganCapaldo> ptolomy: I'd say medium values of just
17:38:42 <dcnstrct> Logan, cool! I'll take a closer look
17:38:46 <LoganCapaldo> I saw the python haskell binding dance recently
17:39:07 <ptolomy> LoganCapaldo: You're probably right. Haskell has a pretty friendly FFI, and ruby can be twisted any which way.
17:39:23 <dcnstrct> if python can do it
17:39:26 <LoganCapaldo> the biggest pain is gonna be the (expected) auto conversions that you get from inline most likely
17:39:29 <dcnstrct> by god ruby can do it too
17:39:52 <LoganCapaldo> dons: Inline haskell in perl 6 eh?
17:39:59 <LoganCapaldo> thats totally unbelievable
17:40:15 * LoganCapaldo goes out of his way not to say anything about pugs
17:40:20 <dons> hehe :)
17:40:21 <LoganCapaldo> ;)
17:48:51 <JohnMeacham> what was the ghc overhead for haskell strings again?
17:49:31 <LoganCapaldo> Theres a string overhead??
17:49:36 <LoganCapaldo> For what?
17:49:54 <dons> a lot
17:49:57 <dons> 12 words, iirc
17:49:58 <LoganCapaldo> please tell me it caches something useful or something cool like that
17:50:03 <dons> details on page 2 of the bytestring paper
17:50:18 <JohnMeacham> 12 per character, or twevle per link in the linked list?
17:50:36 <dons> per node in the list
17:51:01 <JohnMeacham> ah. so 8 for the list then 4 for the char? what about the code pointer for the char?
17:51:31 <LoganCapaldo> Is Char UCS-4?
17:51:48 <dons> 12 bytes per character, sorry
17:51:54 * LoganCapaldo he said ruining their conversation with inane questions
17:52:09 <JohnMeacham> yes. well, the standard guarentees 20 bits. but they all are effectively UCS-4
17:52:29 <LoganCapaldo> goody
17:52:54 <JohnMeacham> ah. I have jhc down to 8 bytes for a whole link and character in a standard haskell list :)
17:52:59 <jcreigh> 12 *words*?
17:53:18 <jcreigh> I'm thinking word == 4 bytes on most archs. Is that wrong?
17:53:26 <LoganCapaldo> jcreigh: what did you miss the correction?
17:53:34 * jcreigh blushes
17:53:35 <sjanssen> LoganCapaldo: UCS-4 is an encoding -- Haskell strings are higher level than encoding
17:53:38 <LoganCapaldo> <dons> 12 bytes per character, sorry
17:53:46 <jcreigh> LoganCapaldo: thank you, I did miss that.
17:53:52 <sjanssen> String is a sequence of Unicode code points
17:54:20 <jcreigh> Why do the IO functions take strings? Do they just truncate to 8 bits?
17:54:25 <LoganCapaldo> You just can't use the wrong term in this channel, or you'll die a horrible death :)
17:54:35 <Cale> 2 words for the cons cell and one for the unboxed char?
17:54:46 <lispy> how many bytes in a word?
17:54:48 <sjanssen> jcreigh: the behavior isn't specified in the Haskell standard
17:54:52 <Philippa> LoganCapaldo: nope, you'll just get corrected
17:55:01 <Cale> er, Char box, more likely.
17:55:04 <lispy> i've been working with a program at work which considers a word to be an unsigned byte
17:55:17 <LoganCapaldo> Philippa: corrected to death slowly, over a period of many months
17:55:21 <sjanssen> jcreigh: current ghc truncates Chars to Word8s
17:55:46 <jcreigh> hmmm...so if you want Unicode IO, you have to convert to utf8 or whatever yourself.
17:56:04 <LoganCapaldo> is that a Word of 8bits or an 8byte word?
17:56:06 <Cale> It's funny, we bother to store unicode code points, but all the IO routines ignore them.
17:56:21 <sjanssen> jcreigh: or wait for the day when Haskell implementations do the right thing
17:56:24 <jcreigh> LoganCapaldo: 8 bits, if it follows the same naming convention all the other Word types do.
17:56:30 <JohnMeacham> there is no need for any header at all on heap nodes in jhc, since you can tell from which memory pool it was allocated whether it is in WHNF or not, so a cons cell is literally just a pair of pointers. and since char is small enough to fit in a pointer, it is just placed in there directly. it is a nice effect of having a fully typed garbage collector. no need for tagging anything. :)
17:56:57 <JohnMeacham> this is with the new backend though. the old one had a more traditional header word on each heap node.
17:57:04 * LoganCapaldo glowers jealously at jhc
17:57:27 <LoganCapaldo> My Haskell compiler can't even make lists
17:57:41 <LoganCapaldo> or anything else :)
17:57:53 <bd_> LoganCapaldo: Do you support ()? :)
17:58:10 <LoganCapaldo> Only in HEAD, but its still a little buggy
17:58:23 <bd_> heh
18:00:07 <JohnMeacham> it is actually kind of fun. since everything is fully typed, there is no need for a common representation format at all. so some wacky stuff is plausable like data Foo = Foo !Bool !Bool !Bool !Bool !Word16 could be packed as a 4 bit bitfield and a 16 bit word all packed into the pointer (so no need for heap). not that it does that (yet) but the new backend was specifically designed to allow that sort of thing.   embedded
18:00:07 <JohnMeacham>  processors being a specific target I had in mind.
18:02:15 <Cale> JohnMeacham: You'd probably want some way to tell it whether that was really what you wanted.
18:02:52 <JohnMeacham> Cale: oh. lots of pragmas you mean :) yeah.
18:04:05 <JohnMeacham> Cale: I need a better name for grin mk 2 than fgrin though. jgrin? it is still boquist's monad (a great invention), but I have diverged in my compilation path enough that perhaps it should get a new name...
18:04:30 <JohnMeacham> Graph Reduction INtermediate form is still representative though.
18:05:31 <Cale> Grinch? :)
18:05:45 <Cale> Not sure what the C or H would stand for
18:07:24 <newsham> > zipWith ($) (cycle [id, toUpper]) "hello #haskell"
18:07:25 <lambdabot>  "hElLo #HaSkElL"
18:07:55 <LoganCapaldo> @. elite run "hello #haskell"
18:07:57 <lambdabot> "|-|E11O #|-|4zKEL1"
18:08:10 <newsham> ?elite hello #haskell
18:08:10 <lambdabot> |-|3l|O #HAsxELL
18:08:20 <glguy> !say @. elite id hello hpaste
18:08:21 <hpaste> @. elite id hello hpaste
18:08:22 <lambdabot> HE|10 hPAstE
18:08:36 <LoganCapaldo> heh
18:08:39 <kc5tja> @src elite
18:08:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:08:53 <LoganCapaldo> glguy: everyone knows it was you. WHo you trying to fool? :)
18:08:58 * kc5tja sighs
18:09:04 <glguy> i have no idea what you are talking about!
18:09:13 <glguy> kc5tja: elite is a plug-in, not a function
18:09:13 <Pseudonym> @. id hello hpaste
18:09:14 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "hello"
18:09:29 <chessguy> @help elite
18:09:29 <lambdabot> elite <phrase>. Translate English to elitespeak
18:09:51 <nmessenger> @help .
18:09:52 <lambdabot> . <cmd1> <cmd2> [args].
18:09:52 <lambdabot> . [or compose] is the composition of two plugins
18:09:52 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
18:09:57 <SamB> @. elite read "hello #haskell"
18:09:58 <lambdabot> he1L0 #ha5kE1|
18:10:04 <chessguy> elitespeak, the ebonics of the internet
18:10:10 <Pseudonym> @. elite id hello hpaste
18:10:14 <Pseudonym> Aha.
18:10:18 <Pseudonym> That's a security risk.
18:10:24 <bd_> heh
18:10:41 <Pseudonym> @id hello hpaste
18:10:42 <lambdabot>  hello hpaste
18:10:43 <bd_> @id TEST
18:10:43 <lambdabot>  TEST
18:10:47 <bd_> trick
18:10:47 <bd_> y
18:10:48 <Pseudonym> Right.
18:10:57 <Pseudonym> @. id id hello hpaste
18:10:58 <lambdabot>   hello hpaste
18:11:08 <nmessenger> @. elite id test
18:11:08 <lambdabot> +ezT
18:11:10 <LoganCapaldo> @help id
18:11:11 <lambdabot> id <arg>. The identiy plugin
18:11:12 <nmessenger> ^^ no space!!
18:11:37 <LoganCapaldo> id So I can make lambdabot say arbitrary things?
18:11:47 <LoganCapaldo> @id So I can make lambdabot say arbitrary things?
18:11:48 <lambdabot>  So I can make lambdabot say arbitrary things?
18:11:49 <bd_> @id yep
18:11:49 <lambdabot>  yep
18:11:57 <nmessenger> ...with a space prepended
18:12:05 <LoganCapaldo> @id apparently he can't. At least not in one try
18:12:05 <lambdabot>  apparently he can't. At least not in one try
18:12:16 <bd_> @iq test
18:12:16 <lambdabot>  test
18:12:33 <lambdabot> I'm a she, foolish humans.
18:12:42 <nmessenger> @elite ACTION dies
18:12:43 * lambdabot dIES
18:12:52 <nmessenger> :D
18:13:22 <bd_> @id /me tests
18:13:22 <lambdabot>  /me tests
18:13:30 <bd_> @elite /me tests
18:13:31 <lambdabot> /mE tES7s
18:13:38 <LoganCapaldo> @. id action tests
18:13:38 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "action"
18:13:49 <LoganCapaldo> @id action tests
18:13:49 <lambdabot>  action tests
18:14:02 <LoganCapaldo> @ACTION tests
18:14:03 <lambdabot> Unknown command, try @list
18:14:09 <nmessenger> @elite ACTION will kill all of you!
18:14:33 <nmessenger> heh, elite has to preserve the spelling of actoin
18:14:36 * nmessenger too
18:14:41 <Pseudonym> @elite ACTION TIME
18:14:43 <rahikkala> :D
18:14:44 <Pseudonym> @elite ACTION TIME
18:14:48 <Pseudonym> @elite ACTION TIME
18:14:51 <Pseudonym> @elite ACTION TIME
18:14:52 <kc5tja> glguy: That doesn't warrent an insult though.  Am I overly sensitive?  Yes.  I'm really not a fan of its insults.
18:14:56 <Pseudonym> This could take a while.
18:15:02 <Pseudonym> @elite TIME
18:15:02 <nmessenger> I got lucky!
18:15:05 <Pseudonym> Woo!
18:15:09 <Pseudonym> I spammed #haskell!
18:16:53 <dons> you're all very smart people. who'll send the first patch ? :)
18:17:05 <glguy> dons: can we just whine about it a bit longer please
18:17:14 <jcreigh> Pseudonym: ha! In my IRC client, all I have to do is type some text and whack enter and it automatically spams the whole channel! :)
18:17:18 <glguy> at least to the end of the week?
18:17:18 <Pseudonym> Actually, I want to see if I can break it further.
18:17:31 <glguy> dons: ohhh, the elite patch :)
18:18:11 <glguy>  @elite ^APART #haskell^A?
18:18:23 <glguy> Ohh, nevermind
18:18:28 <glguy> ACTION is part of PRIVMSG
18:18:46 <dons> just filter illegal chars from @elite's input
18:18:55 <dons> restricting to printable should be enough i think
18:19:03 <glguy> why would that be done in elite?
18:19:12 <glguy> shouldn't that be done in the common function used for output?
18:19:28 <dons> yeah, maybe. darc ssend
18:20:22 <dons> so, anyone else got a nice h98-ish program of 2-20 modules that runs in longer than 1sec?
18:20:26 <dons> and would make a good benchmark?
18:20:32 <dons> any lisp interpreters?
18:20:56 <Pseudonym> Does it have to be deterministic?
18:21:01 <dons> yeah
18:21:04 <Pseudonym> Ah.
18:21:11 <Pseudonym> Is pseudoknot in there?
18:21:12 <dons> more numerical stuff would be welcome
18:21:14 <dons> nope.
18:21:24 <dons> sounds useful.  i just need the url of the src, basically
18:21:31 <dons> and an assurance that the license is 'free' :)
18:21:47 <dons> so if you have some nice mathy progs :)
18:21:57 <bd_> I have an int64-heavy hacky thing which runs MUCH slower on i386 than x86_64... but only one module. (I wrote it for project euler... totally brute force though)
18:22:07 <dons> that sounds useful, bd_
18:22:12 <Pseudonym> Well the spec is free, but I don't know where the source is.
18:22:13 <dons> i don't think we test int64 anywhere atm
18:22:42 <Pseudonym> See, I've got a bunch of genetic/annealing stuff, but it's all nondeterministic.
18:23:09 <Pseudonym> I'll bet one or both of the Simons have Pseudoknot.
18:23:09 <dons> anyway to summarise the output to hide that?
18:23:12 <Pseudonym> Might be worth an ask.
18:23:28 <bd_> dons: http://uguu.us/Euler.hs <-- very hacky. and slow. It's for problem 141. Don't look if you don't want spoilers. ;)
18:23:33 <LoganCapaldo> case :: [(a -> Maybe b, b->c)] -> a -> c -- this type close, assuming a "primitive" maybe thing?
18:23:37 <bd_> run with the minimum and max to search as command line args
18:24:02 <Pseudonym> Aha!
18:24:03 <bd_> there's a lot of dead code there mind you :)
18:24:27 <Pseudonym> Damn, URL rot.
18:24:54 <Pseudonym> http://www.science.uva.nl/pub/functional/packages/
18:24:55 <Pseudonym> Got it.
18:24:56 <lambdabot> Title: Index of /pub/functional/packages
18:24:56 <dons> ooking bd_
18:25:16 <LoganCapaldo> @djinn [(a -> Maybe b, b->c)] -> a -> c
18:25:16 <lambdabot> -- f cannot be realized.
18:25:29 <dons> bd_, looks good! $ ./Euler 1 10000
18:25:31 <LoganCapaldo> @type f :: [(a -> Maybe b, b->c)] -> a -> c
18:25:33 <lambdabot> Not in scope: `f'
18:25:37 <dons> for example. now. what's the name of this puzzle?
18:25:45 <LoganCapaldo> @type undefined :: [(a -> Maybe b, b->c)] -> a -> c
18:25:48 <lambdabot> [(a -> Maybe b, b->c)] -> a -> c :: forall a b c. [(a -> Maybe b, b -> c)] -> a -> c
18:25:59 <bd_> dons: if you have a PE acct, http://projecteuler.net/index.php?section=problems&id=141
18:26:01 <lambdabot> Title: Project Euler
18:26:06 <nmessenger> LoganCapaldo: what are you trying to do?
18:26:15 <LoganCapaldo> type "case"
18:26:22 <LoganCapaldo> if case was a function
18:26:52 <nmessenger> looks about right
18:26:57 <bd_> dons: It should probably be cleaned up a bit before being used in a benchmark, but that's certainly very int64-heavy for you.
18:27:27 <dons> i'm cleaning it up as we speak
18:27:42 <dons> I don't have a PE account. but caling the test 'Euler' doesn't seem right.
18:27:46 <dons> what's a good name?
18:28:20 <bd_> "Find the sum of all progressive perfect squares below one trillion " is the puzzle (following a description of what progressive numbers are)
18:28:36 <nmessenger> progperf?
18:28:42 <dons> ok. good
18:29:41 <nmessenger> also reminds of "program performance" :D
18:31:00 <nmessenger> @where nobench
18:31:00 <lambdabot> I know nothing about nobench.
18:31:43 <LoganCapaldo> @type case of
18:31:46 <lambdabot> parse error on input `of'
18:31:49 <dons> using trace like that is pretty evil, bd_
18:31:49 <LoganCapaldo> ah well
18:31:54 <bd_> dons: :)
18:32:09 <bd_> dons: Well, I wanted to get an idea of its progress... when I was doing a parallel filter...
18:33:12 <bd_> I was surprised there wasn't a direct parFilter abstraction actually.
18:36:44 <LoganCapaldo> par as in parallel (like multiple threads)?
18:37:11 <LoganCapaldo> or par as in parallel like walking thru multiple lists in step and filtering?
18:37:30 <bd_> parallel :)
18:37:37 <bd_> Control.Parallel.Strategies sort of thing
18:37:44 <LoganCapaldo> delicious
18:37:52 <Pseudonym> ?where evil
18:37:56 <Pseudonym> Woo.
18:37:57 <LoganCapaldo> Haskell has the best toys
18:38:17 <Pseudonym> That was easier than I thought.
18:38:30 <Pseudonym> ?where+ evil ACTION owns you
18:38:31 <lambdabot> Done.
18:38:32 <Pseudonym> ?where evil
18:38:32 * lambdabot owns you
18:39:20 <LoganCapaldo> mmm
18:39:27 <Pseudonym> If only there was another bot present.
18:39:28 <mdmkolbe> @pl \o f x y -> f (o x) (o y)
18:39:29 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
18:39:32 <Pseudonym> ?where+ evil ?where evil
18:39:33 <lambdabot> Done.
18:39:35 <Pseudonym> ?where evil
18:39:36 <lambdabot> ?where evil
18:39:40 <Pseudonym> Recursive fun.
18:39:41 <nmessenger> no!!!!
18:39:51 <nmessenger> er, wait
18:39:57 <LoganCapaldo> thats why lambdabot needs to lazily evaluate commands :)
18:40:15 <bd_> ?where+ evil <<loop>>
18:40:16 <lambdabot> Done.
18:40:23 * Pseudonym laughs
18:42:28 <mbishop> ?where evil
18:42:29 <lambdabot> <<loop>>
18:42:56 <Pseudonym> http://andrew.bromage.org/test.html
18:42:57 <lambdabot> Title: foo
18:43:00 <Pseudonym> Ah.
18:43:07 <Pseudonym> OK.  It sticks the Title: in there.
18:43:17 <Pseudonym> http://andrew.bromage.org/test.html
18:43:18 <lambdabot> Title: foo
18:43:24 <Pseudonym> And it cuts off at the first \n
18:44:00 <Pseudonym> http://andrew.bromage.org/test.html
18:44:01 <lambdabot> Title: foo
18:44:12 <mdmkolbe> @pl \f x y -> f (o x) (o y)
18:44:12 <lambdabot> flip flip o . ((.) .) . (. o)
18:44:44 <nmessenger> mdmkolbe: that function is called 'on' in the HEAD
18:44:54 <nmessenger> i.e. (compare `on` fst)
18:45:04 <nmessenger> (flipped)
18:46:26 <araujo> hello
18:46:47 <fons> is there a Standard function that checks if a String is a valid filename (before creation) or the one way top check that is creating the file itself?
18:46:56 * araujo throws sugar lambdas at everyone
18:47:12 <fons> hola araujo :)
18:47:43 <araujo> hola fons !
18:48:02 <jcreigh> a "valid" filename?
18:48:11 <fons> jcreigh, a valid filepath
18:48:29 <fons>  "/sjh/ksd" this is  nota a valid filename in Unix
18:48:36 <jcreigh> fons: why not?
18:48:40 <jcreigh> looks fine to me.
18:48:43 <dons> bd_: so what I did was ditch all the non-h98 code, and strip it down to the bare bones
18:48:54 <jcreigh> You mean it probably doesn't exist?
18:48:55 <dons> bd_, now, since this is going into the repo long term, attribution please :)
18:48:58 <bd_> dons: Int64 isn't h98, is it?
18:48:58 <fons> not if you consider it relative
18:49:05 <dons> so someone digging around in 10 years knows who the author was ..
18:49:11 <dons> bd_, no, i'm working on h98-ish
18:49:14 <bd_> dons: I, Bryan Donlan, wrote it, and put it under whatever licence you like :)
18:49:15 <dons> i.e. if hugs and nhc can dig it
18:49:27 <dons> so, Contributed by Bryan Donlan for project euler
18:49:37 <bd_> for solving a project euler puzzle anyway
18:49:41 <dons> cheers
18:49:47 <smitty1e> I just heard someone claiming that it's impossible to write quicksort in Haskell.  Would a guru care to reply?
18:49:53 <mbishop> public domain!
18:49:57 <mbishop> make it public domain!
18:49:58 <araujo> smitty1e, wth?!
18:50:01 <dons> smitty1e: false. i guess that's even trolling
18:50:24 <dons> since there's a 2 line quicksort that's used as a teaching example
18:50:28 * glguy wonders if there is a better way to write: a . b =<< c . d =<< return e
18:50:29 <smitty1e> No, I'm not trolling, just a newb repeating something I'd heard
18:50:44 <dons> ok. :) let me find you a quicksort then
18:50:44 <jcreigh> smitty1e: I think dons was refering to whoever told you that.
18:50:57 <Pseudonym> @let quicksort [] = []
18:50:59 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
18:51:04 <dons> sorry Pseudonym
18:51:11 * Pseudonym is upset
18:51:14 <dons>  qsort []     = []
18:51:14 <dons>  qsort (x:xs) = qsort less ++ [x] ++ qsort more
18:51:14 <dons>      where less = filter (<x)  xs
18:51:14 <dons>            more = filter (>=x) xs
18:51:15 <nmessenger> smitty1e: probably they're thinking "it's not update-in-place so it's not quicksort!"
18:51:18 <dons> smitty1e: see above
18:51:21 <Pseudonym> ?where+ upset ACTION is upset tooA
18:51:22 <lambdabot> Done.
18:51:26 <Pseudonym> ?where+ upset ACTION is upset too
18:51:26 <lambdabot> Done.
18:51:28 <Pseudonym> ?where upset
18:51:28 * lambdabot is upset too
18:51:35 <bd_> *groan*
18:51:41 <dons> i bet you're not so upset now Pseudonym ;)
18:51:48 <Pseudonym> :_)
18:51:50 <Pseudonym> OK.
18:52:03 <Pseudonym> The thing is, of course, in Haskell, quicksort expressed this way ain't so quick.
18:52:03 <dons> smitty1e: how's that? :) want it on a web page so you can link to it?
18:52:08 <glguy> ?where stats
18:52:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:52:21 <chessguy> dons, it's on the wiki
18:52:21 <glguy>  ?where+ loop ?where loop
18:52:23 <Pseudonym> But the fact is, it's often not so quick in other languages either compared to merge sort or radix sort.
18:52:36 <fons> jcreigh, it is a bit complicated ... I have to generate a file in CWD and I take the name of the file from an Identifier chosen by the user (whose original purpose is not a filename)
18:52:40 <dons> chessguy: indeed
18:52:48 <dons> glguy: won't work
18:52:51 <glguy> good
18:52:59 <fons> jcreigh, It can any character
18:53:04 <fons> It can contain
18:53:13 <mbishop> haha fons
18:53:28 <araujo> this is the joke of the day.
18:53:53 <nmessenger> smitty1e: it should be possible to write an update-in-place quicksort in IO.
18:53:56 <dons> smitty1e: its actually quite funny if you think about it :) suggesting that some simple algorithm can't be written in some general purpose language X :)
18:54:05 <fons> mbishop, funny?
18:54:13 <dons> more fun would be"you can't write quicksort in sed"
18:54:25 <Pseudonym> Or in sendmail.
18:54:27 <dons> since you'd have to at least think a bit to solve that(you can)
18:54:31 <dons> or postscript
18:54:38 <chessguy> or BF
18:54:38 <bd_> nmessenger: or ST
18:54:49 <jcreigh> fons: well, on Unix you can use any character in a filename except NUL and / I assume you want to restrict this is printable characters? (or something like [A-Za-z0-9_-]?)
18:54:50 <bd_> nmessenger: no need for fully-general IO right? :)
18:54:56 <Pseudonym> You may not be able to write one in Malbolge, of course.
18:55:01 <nmessenger> bd_: what does ST stand for?  I've not used it yet.
18:55:06 <jcreigh> well, on Linux anyway. I don't know about other unixen.
18:55:12 <bd_> nmessenger: it's like IO without the IO :)
18:55:31 <jcreigh> s/this is/this to/
18:55:32 <smitty1e> dons: yes, your anticipated rebuttal on the quicksort was the response.  Someone else pointed out that you can use IOArray.
18:55:47 <mbishop> > cycle A
18:55:48 <lambdabot>   Not in scope: data constructor `A'
18:55:55 <mbishop> > cycle "A"
18:55:57 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
18:55:58 <bd_> nmessenger: in other words, you have STRefs and STArrays for mutable data, and mutable data isn't allowed to escape the ST monad
18:55:58 <chessguy> bd_, that's about as useless of an answer as you could possibly give
18:56:02 <dons> right. or IOUArray, or bytestring, or ...
18:56:05 <nmessenger> > "aah!" >>= replicate 10
18:56:05 <bd_> nmessenger: so you can safely enter ST from pure code
18:56:06 <lambdabot>  "aaaaaaaaaaaaaaaaaaaahhhhhhhhhh!!!!!!!!!!"
18:56:09 <mbishop> it's over 10 thousand megafonsies
18:56:29 <Pseudonym> BTW, everyone knows that arrays in Haskell are kinda hard to use.
18:56:43 <Pseudonym> That's why you're encouraged to be creative instead.
18:56:44 <nmessenger> bd_: yes I know about it, just wondering what it stood for
18:56:45 <dons> parallel arrays are ok ;) since they look like list comprehensions
18:56:53 <dons> [: ... | ... :]
18:56:55 <bd_> nmessenger: not sure... State Transformer, I think?
18:57:01 <dons> and bytestring arrays are also ok, since they look like lists
18:57:20 <dons> prizes to anyone who rolls a Data.Array.List lib
18:57:48 <bd_> O(n) bounds?
18:58:03 <dons> bd_ nice benchmark. its stressing ghci nicely
18:58:10 <bd_> dons: :)
18:58:13 <dons> though i really want to break ghc. i'll have to keep hunint
18:58:16 <bd_> dons: It really does need optimization
18:58:17 <dons> hunt-ing
18:58:26 <bd_> er, -O whatever
18:58:26 <dons> ghc                  16.810    seconds            (1.0 x)
18:58:27 <dons> ghc-old              16.930    seconds            (1.0 x)
18:58:28 <dons> ghci                 322.600    seconds            (19.2 x)
18:58:34 <bd_> heh
18:58:52 <bd_> Data.Array.List couldn't act directly on lists, though, as it wouldn't be able to set bounds for ix, right?
18:58:55 <fons> thanks jcreigh
18:59:00 <bd_> hm, though...
18:59:04 <dons> bd_, no, it would just provide the combinators
18:59:08 <dons> like map/fold/filter/ ...
18:59:14 <bd_> oh!
18:59:15 <dons> i.e. bytestring-like interface to arrays
18:59:16 <bd_> I see what you mean
18:59:20 <bd_> other way around :)
18:59:23 <dons> taking subarray slices in O(1)
18:59:30 <dons> and copying on filters and so on
18:59:35 <bd_> implementations of Foldable, Traversable, etc?
18:59:39 <dons> yeah
18:59:44 <dons> since that's what makes this stuff usable
18:59:44 <bd_> dons: that would require changing the type though, for slices
18:59:45 <mbishop> What is the difference between arrays, vectors and lists now a days anyway
18:59:53 <dons> arrays that only provide ! aren't useable
19:00:01 <dons> bd_, sure.
19:00:12 <bd_> slice :: (Array a i e) => (i, i) -> a -> GenArray i e ?
19:00:33 <dons> we're actually almost there now with the DPH project. that provides a small bytestring-like interface to STUArrays, as well as parallel arrays
19:01:27 <chessguy> if you have some state that's always only read, and some that's both read and changed, is it better form to separate them into State and Reader, or just leave them all in State
19:03:54 <dons> this is why we submit articles to reddit, http://shuad.wordpress.com/2007/02/28/no-sleep-til-brooklyn/
19:03:56 <lambdabot> Title: No Sleep &#8216;Til Brooklyn  Contracting to a Product
19:03:57 <dons> :)
19:05:17 <dons> ?quote liberat
19:05:17 <lambdabot> dons says: my feeling is that the Java programmers will welcome us as liberators
19:05:40 <gravity> heh
19:06:09 <ddarius> http://www.hpaste.org/581 in place quick sort
19:07:07 <mbishop> dons: really? and here I thought reddit karma was worth $2 USD
19:07:14 <mbishop> darn, I'm ruined!
19:11:48 * ddarius just realizes that ST and STArray are the only fixed types in that code's type declarations.
19:12:11 <ddarius> Oh, and ().
19:12:22 <chessguy> so, no comments on my question? what are you all, programmers or politicians? :)
19:13:29 <ddarius> Do whatever's more convenient and you think will be more maintainable.
19:13:38 <chessguy> psst, nmessenger, you've got a 1 stuck to your butt
19:13:49 <ddarius> There are reasons to split, but often it's not all that worthwhile if you have the code already.
19:14:12 <chessguy> ddarius, i don't. that's why i'm asking now
19:14:27 <chessguy> i'm trying to learn good design practices
19:14:31 * mbishop is hungry for cheese
19:14:35 <nmessenger> how embarrising *'.'*,  thanks chessguy
19:14:38 <ddarius> In that case, I'd probably use a Reader and State.
19:14:51 <chessguy> ddarius, for what reasons?
19:15:28 * chessguy leaves some milk out to curdle overnight for mbishop 
19:16:03 <ddarius> chessguy: It more clearly states your intentions.  It loosens up the code (for the compiler) a little bit.  It can simplify and speed up the State part of it.
19:17:53 <nmessenger> @unmtl StateT s (Reader r)
19:17:53 <lambdabot> err: Unknown MTL(1)
19:18:22 <nmessenger> @unmtl StateT s (Reader r) a
19:18:23 <lambdabot> s -> r -> (a, s)
19:18:32 <nmessenger> @unmtl ReaderT s (State r) a
19:18:32 <lambdabot> s -> r -> (a, r)
19:19:00 <chessguy> hmmm
19:19:25 <nmessenger> chessguy: I think it's maybe better to put the read-only stuff in a Reader
19:19:26 <chessguy> so what would be the downside to splitting it?
19:20:17 <nmessenger> having to 'lift'?  Not much of a downside.
19:20:20 <ddarius> It means working with stacked monads, if you change your mind about the variable being read-only you need to make a few changes.
19:20:34 <ddarius> As I said, it's mostly an issue if you already have code.
19:21:36 <chessguy> well, if a particular variable in the Reader were to need to be mutable, you'd just have to move it to the State, and change the references to it, right?
19:23:07 <ddarius> Yes for the most part.  The rest should work itself out if you've written the code correctly.
19:24:17 <chessguy> what do you mean by 'the rest'
19:24:26 <jcreigh> raptors
19:24:29 <jcreigh> :)
19:24:37 <nmessenger> Oh shit raptors noooo!!
19:24:56 <ddarius> chessguy: For example, changing it from ReaderT ... State to just State. Not lifting anymore etc.
19:38:07 <max22> does anyone arnd here know how distributed modules are compiled in haskell?
19:43:43 <ddarius> ideas.txt keeps growing.
19:48:11 <dons> bd_ nice, hugs can't get through that code in under 20 mins :)
19:48:26 <bd_> :)
19:48:33 <bd_> i386 or x86_64?
19:49:50 <dons> the latter
19:49:54 <bd_> *nod*
19:51:49 <dons> wow, and a bizrre nhc faiure:
19:51:50 <dons> nhc98comp: infoDepend InfoUsed 60 [(Type class,Control.Arrow.ArrowZero,"evitacilppA.lortnoC",93:11-93:33)]
19:51:57 <dons> how cool is that!
19:54:18 <sjanssen_> > reverse "evitacilppA.lortnoC" -- huh?
19:54:19 <lambdabot>  "Control.Applicative"
19:54:52 <kpreid> I wonder if that might be a deliberate reversal for lookup purposes since the end of a module name varies more than the beginning
19:55:11 <dons> but i'm surprised there's even arrows inside nhc
19:55:14 <dons> sounds suspicous
20:02:35 <dons> bd_, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html !
20:02:35 <lambdabot> Title: nobench: Haskell implementation shootout
20:03:00 <dons> turns out perfectsquares is a good bench mark after all :) ghc head is running much slower, and that will need checking
20:06:57 <bd_> dons: progressive, not perfect :)
20:07:45 <dons> you said "progressive perfect squares" ?
20:07:49 <dons> but that's too long for a file name ;)
20:08:19 <dons> got any more of these funny programs around?
20:09:34 <bd_> well, "perfect" binds to squares, the progressive part is what makes it slow
20:09:42 <bd_> and, afraid not really. maybe at some future point :)
20:10:07 <dons> good probblem anyway. that's exactly the kind of perf issue i'm looking to expose
20:10:44 <dons> @tell Igloo perfectsquares needs looking at, 4x slower in the head
20:10:45 <lambdabot> Consider it noted.
20:10:51 <dons> @tell url, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
20:10:51 <lambdabot> Consider it noted.
20:10:59 <dons> @tell Igloo url, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
20:11:00 <lambdabot> Consider it noted.
20:11:05 <url> hey
20:11:10 <nmessenger> url,
20:11:10 <jcreigh> url,
20:11:11 <dons> foiled
20:11:16 <dons> can't have ,
20:11:28 <dons> noep
20:11:33 <jcreigh> bah, silly IRC limitations.
20:11:59 <nmessenger> will LB just keep it indefinitely?
20:12:15 <dons> probably
20:12:18 <dons> until heat death
20:12:40 <nmessenger> @vera uthdotu
20:12:44 <ddarius> Heat death = 16 cores overheating
20:12:44 <lambdabot> No match for "uthdotu".
20:12:57 <dons> hehe
20:12:57 <mbishop> lambdabot doesn't have a morse code command?
20:12:59 <mbishop> pfft
20:13:13 <dons> ?go remorse haskell
20:13:17 <lambdabot> http://adrastos.blog-city.com/the_eddie_haskell_factor.htm
20:13:18 <lambdabot> Title: THE EDDIE HASKELL FACTOR [adrastos.blog-city.com]
20:13:21 <dons> nah
20:13:29 * nmessenger tiries to introduce the acronym "uthdotu" for "until the heat death of the universe"
20:13:30 <mbishop> -. ---  ... .. .-. --..--  ..  -.. --- -. -  .-.. .. -.- .  .. -
20:13:35 * ddarius has no idea why he wrote this Lisp interpreter.
20:13:43 <dons> there's a nice IOHCC example that encodes to and from mores
20:14:03 <dons> > let (-.) = 1 ; (.-.) = 2 in (-.) - (.-.)
20:14:05 <lambdabot>  -1
20:14:07 <dons> :)
20:14:34 <Pseudonym> A Morse plugin would be a handy simple project for someone.
20:15:15 * ddarius is thinking about making that time of day statistics module sorear wanted.
20:15:21 <chessguy> handy?
20:15:24 <chessguy> for what?
20:15:25 <SamB> you know, I think it is perfectly legal to encode XML in an extended morse code
20:15:27 <ddarius> It should take like 5 minutes.
20:15:40 <jeeves_bond> Hi, I'm trying to compile cabal but it doesn't seem to be working all seems fine when running 'sudo make install' (see http://hpaste.org/698 ) but when typing 'cabal-setup' at the command line I get an error. Any ideas why this isn't working?
20:15:44 <Pseudonym> For people who want to encode and decode Morse, duh.
20:15:54 * ddarius also needs to go to Interpreter Writer's Anonymous.
20:15:56 <chessguy> lol
20:16:18 <SamB> ddarius: what? you write interpreters as lambdas?
20:16:19 <dons> ?where yhc-bugs
20:16:19 <lambdabot> http://code.google.com/p/yhc/issues/list
20:16:25 <Pseudonym> I'm just saying, if someone wants to learn some Haskell but doesn't have any inspiration...
20:16:30 <jeeves_bond> Sorry to interrupt your XML/morse fun with a daft question. :)
20:16:46 <dons> jeeves_bond: can you ask the question in morse code? :-)
20:16:51 <ddarius> My Prolog interpreter has a type inferred lambda calculus interpreter as an example.
20:17:00 <Cale> jeeves_bond: where's your error?
20:17:08 <dons> http://hpaste.org/698
20:17:11 <SamB> ddarius: okay, that *is* a bit overboard...
20:17:12 <ddarius> dons: If we had @unmorse he could!
20:17:15 <Cale> (I'm looking at that paste)
20:17:24 <Cale> Perhaps it's cut off?
20:17:27 <SamB> ddarius: no, morse
20:17:33 <SamB> er.
20:17:34 <dons> ddarius: quite so. looks like WE NEED THIS PLUGIN!
20:17:35 <SamB> @morse
20:17:43 <Pseudonym> Actually, nobody has come up with a way to express XML in Morse.
20:17:45 <SamB> then we could just read the command and see what he said
20:17:47 <ddarius> SamB: I also wrote a joy interpreter in lambdabot obsolete @eval which was a pure-ish lambda calculus interpreter.
20:17:59 <SamB> Pseudonym: you just need support for the wiggly bits
20:18:01 <chessguy> @bot
20:18:01 <lambdabot> :)
20:18:02 <dons> @go hello in morse code
20:18:05 <lambdabot> http://terrax.org/comm/morsecode/morsecode.aspx
20:18:05 <lambdabot> Title: TerraX.org Morse Code Page
20:18:10 <dons> bah
20:18:14 <newsham> @farber
20:18:15 <lambdabot> Unknown command, try @list
20:18:20 <dons> seems like an obvious feature for google
20:18:25 <chessguy> @go hello in spanish
20:18:27 <Pseudonym> Google Morse.
20:18:27 <lambdabot> http://www.ipl.org/div/hello/spanish.html
20:18:28 <lambdabot> Title: IPL Kidspace: Say Hello to the World
20:18:43 <SamB> @go calculate hello in morse code
20:18:47 <lambdabot> http://mac.softpedia.com/get/Dashboard-Widgets/Calculate-Convert/Morse-Code-Translator.shtml
20:18:47 <lambdabot> Title: Download Morse Code Translator 1.9 for Mac - Morse Code Translator converts text ...
20:18:50 <SamB> hmm.
20:19:03 <chessguy> boooo!
20:19:07 <chessguy> mod down google!
20:19:09 <jeeves_bond> That's the thing, I don't get an error. It seems fine, but the command 'cabal-setup' returns: bash: cabal-setup: command not found
20:19:24 <jeeves_bond> dash dash dot dash dot dot etc.
20:19:46 <ddarius> I thought I'd written quite a few interpreters, but mostly in relation to something, now I realize I've written ridiculously many, several just for the hey of it.
20:19:53 <jeeves_bond> chessguy: stop corrupting us with your evil slashdot ways
20:20:03 <chessguy> LOL
20:20:24 <SamB> @go 0x7d3 in roman numerals
20:20:25 <lambdabot> 0x7d3 = MMIII
20:20:26 <chessguy> i actually never read slashdot. i learned the phrase "mod {up,down}" on this channel
20:20:29 <Pseudonym> BTW, it's not dash and dot.
20:20:34 <SamB> google--
20:20:43 <Pseudonym> Morse is not a written language.
20:20:48 <Pseudonym> It's dit and dah.
20:21:04 <jeeves_bond> Looks like poor old hpaste cut off most of my install log, I can make it available somewhere else if needs be.
20:21:29 <chessguy> silly bot
20:21:32 <ddarius> @go 2+2
20:21:34 <lambdabot> 2 + 2 = 4
20:21:45 <ddarius> Who needs @eval?
20:21:58 <ddarius> @go 3 m + 2 ft
20:22:00 <lambdabot> (3 meters) + (2 feet) = 3.6096 meters
20:22:00 <mbishop> .. .-.. .-..  -.. .. -  -.-- --- ..- .-.  -.. .- .... --..--  .--. ... . ..- -.. --- -. -.-- --
20:22:03 <jeeves_bond> *sigh* well sorry, all I can remember about Morse was what I got on the back of a walkie-talkie set when I was about 10 :D
20:22:25 <ddarius> @go 3 m + 2 ft in angstroms
20:22:27 <lambdabot> (3 m) + (2 ft) = 36,096,000,000 angstroms
20:22:43 <Pseudonym> @go the speed of light in furlongs per fortnight
20:22:45 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
20:22:56 <SamB> a bit overboard, eh?
20:23:15 <jeeves_bond> Someone should write a Haskell program that comes in here and asks the bot whenever any arithmetic needs to be performed.
20:23:29 <SamB> heh
20:23:54 <jeeves_bond> Why get the processor to do it when there's a perfectly good bot in the #haskell channel?
20:24:05 <dons> yeah, my processor :)
20:24:07 <chessguy> @go 6 seconds in microfortnights
20:24:09 <lambdabot> http://en.wikipedia.org/wiki/List_of_strange_units_of_measurement
20:24:09 <lambdabot> Title: List of unusual units of measurement - Wikipedia, the free encyclopedia
20:24:14 <chessguy> haha
20:24:22 <SamB> dons: I thought you said you had a bajillion of those
20:24:34 <dons> only one running lambdabot. go nuts!
20:24:39 <dons> > product [1..]
20:24:41 <nmessenger> @go 1 au in attoparsecs
20:24:43 <lambdabot> 1 Astronomical Unit = 4.84813681 x 10^12 attoParsecs
20:24:43 <lambdabot> Terminated
20:24:56 <Pseudonym> @go pi seconds in nanocenturies
20:24:59 <lambdabot> http://forum.literotica.com:81/archive/index.php/t-9807.html
20:24:59 <lambdabot> Title: Literotica Discussion Board - wedding day cheating
20:25:05 <dons> interesting
20:25:06 <Pseudonym> Glood heavens.
20:25:11 <SamB> it would be especially silly to write a Haskell program that has lambdabot query google for the calculations ;-)
20:25:17 <ddarius> That... was great
20:25:18 <nmessenger> pi isn't a time, silly
20:25:27 <Pseudonym> @go 3.13159 seconds in nanocenturies
20:25:29 <lambdabot> No Result Found.
20:25:43 <Pseudonym> It doesn't recognise non-pi numbers.
20:25:59 <SamB> @go pi*1 seconds in nanocenturies
20:26:00 <lambdabot> No Result Found.
20:26:03 <dons> @go pi meters in centimeters
20:26:04 <lambdabot> pi meters = 314.159265 centimeters
20:26:07 <chessguy> how in the world did it pull that page?
20:26:20 <dons> @go pi seconds in minutes
20:26:22 <lambdabot> pi seconds = 0.0523598776 minutes
20:26:22 <Pseudonym> Is it work-safe, BTW?
20:26:24 <SamB> @go 1 second in nanocenturies
20:26:29 <lambdabot> http://www.math.wisc.edu/~propp/141/Feb7.doc
20:26:36 <ddarius> Pseudonym: It's a forum.
20:26:40 <nmessenger> no nanocenturies for you!
20:26:45 <Pseudonym> Ah.
20:26:47 <Pseudonym> Hmmm.
20:26:56 <dons> you on ssl irc anywya?
20:27:00 <Pseudonym> Yes, indeed, this is the oddest result I've ever gotten for a Google calculator search.
20:27:03 <dons> or is it too late already :)
20:27:30 <dons> i guess irc isn't going over port 80, so they don't see those urls unless they look
20:27:42 <nmessenger> @go 1 siriometer in angstroms
20:27:50 <lambdabot> http://links.jstor.org/sici?sici=0027-8424(19200615)6%3A6%3C349%3AROTOOT%3E2.0.CO%3B2-C
20:27:50 <lambdabot> Title: JSTOR: Proceedings of the National Academy of Sciences of the United States of A ...
20:32:04 <jeeves_bond> Anyway, no-one know anything about cabal? Does the cabal-setup work for you?
20:32:51 * ddarius looks at his I-have-no-idea-how-or-why-this-works-but-it-does beginning to a reflective OO language interpreter.
20:32:54 <SamB> @go pi seconds / 100 in nano years
20:32:58 <lambdabot> http://everything2.com/index.pl?node_id=1423055
20:32:59 <lambdabot> Title: pi seconds is a nanocentury@Everything2.com
20:33:19 <SamB> @go 1 nanosecond in seconds
20:33:20 <lambdabot> 1 nanosecond = 1.0 x 10^-9 seconds
20:33:37 <jeeves_bond> Am certain I'm missing something here because it's put some stuff in /usr/lib/ there just doesn't seem to be a cabal-setup binary. I'm trying to get conjure working (or at least in a state where I can study it) ... http://darcs.haskell.org/~lemmih/conjure/INSTALL
20:33:58 <SamB> @go pi seconds / 10^11 in years
20:33:59 <lambdabot> (pi seconds) / (10^11) = 9.95531902 x 10^-19 years
20:34:09 <SamB> hmm.
20:34:18 <SamB> @go pi seconds x 10^7 in years
20:34:20 <lambdabot> pi seconds x (10^7) = 0.995531902 years
20:34:25 <SamB> hmm.
20:34:37 * ddarius incidentally didn't know how or why it worked when he wrote it.
20:35:23 <chessguy> ddarius, sounds like most of the code i write ;)
20:35:37 <nmessenger> @go (pi / 100) seconds in years
20:35:38 <lambdabot> (pi / 100) * seconds = 9.95531902 x 10^-10 years
20:36:08 <wkh> @go 40 rods/hogshead in miles/gallon
20:36:09 <lambdabot> 40 (rods / hogshead) = 0.00198412698 miles / US gallon
20:36:22 <wkh> apparently grandpa abe's car was actually pretty inefficient.
20:36:40 <nmessenger> :)
20:36:48 <SamB> who is grandpa abe?
20:36:53 <wkh> simpsons
20:36:57 <nmessenger> @go 1 hoshead in US gallons
20:37:00 <lambdabot> http://www.breweryarts.org.uk/aboutus.html
20:37:01 <lambdabot> Title: BREWERY ARTS - ABOUT US
20:37:04 <nmessenger> @go 1 hogshead in US gallons
20:37:05 <lambdabot> 1 hogshead = 63 US gallons
20:37:08 <wkh> "the metric system is the devil's tool. my car gets 40 rods to a hogshead and that's the way i likes it"
20:37:34 <nmessenger> @go 1 rod in feet
20:37:36 <lambdabot> 1 rod = 16.5 feet
20:38:29 <SamB> well, I guess you can see why he likes it that way, eh?
20:38:36 <jeeves_bond> *sigh* never mind I'll leave you to your conversions! Night all. :)
20:39:07 <SamB> you need cabal-setup for conjure now?
20:39:12 <SamB> boy, its been a while...
20:39:44 <hpaste>  jcreigh pasted "The google calculator isn't the only game in town" at http://hpaste.org/699
20:40:22 <jcreigh> but yes, it's sad google doesn't support prefixes for centuries...
20:41:53 <nmessenger> frink does :)
20:42:43 <jcreigh> really? You can literally say "nanocenturies" in frink?
20:42:49 <monochrom> Interesting!  A pi second and a nanocentury are pretty close!
20:43:07 <nmessenger> frink's got everything!
20:43:55 * nmessenger considers writing @frink
20:49:03 <ddarius> Late-binding is taken too far when you are not sure where the -bottom- layers bottom out.
20:50:10 <monochrom> really?
20:54:34 <RichN> in learning Haskell, I recently stumbled across STRef and Control.Monad.ST. Are these still used often? Or are people shifting more towards the State monad and IORefs/MVars/TVars?
20:56:17 <dons> right. the latter are much more often used
20:56:24 <dons> ST arrays are very useful though
20:56:36 <dons> for encapsulating some pure action that does mutable work under the hood
20:56:38 <flaggy> in this text, could someone tell me what the || means? I couldn't figure it out. http://homepages.dcc.ufmg.br/~rafaelc/Screenshot.png
20:56:44 <dons> which isn't so easy with IO arrays
20:56:51 <RichN> ah.
20:58:09 <mauke> flaggy: (,)
20:58:37 <ddarius> RichN: All of those are used for different things.
20:58:40 <RichN> I read "Lazy State Threads" today and noticed the date was '94, so I wondered whether STRefs were historical, but not used much anymore.
20:58:44 <ddarius> They are not interchangeable.
20:58:51 * wkh is a fan of the Euler font family
20:59:02 <dons> RichN: they're very much still around
20:59:17 <dons> IORefs are jsut a wrapper over STRefs
20:59:26 <ddarius> RichN: They are very much alive.  Most of Haskell technically dates from the 70's, or 60's, or 30's depending on how you want to count.
20:59:55 <RichN> so using ST and STRefs is different than embedding an IORef in a State monad?
21:00:04 <dons> yeah.
21:00:18 <dons> you can't embded an IORef in a state monad directly anyway, you'd need to use StateT
21:00:24 <dons> then what's the point? since you'd just use State directly
21:00:39 <RichN> yup, you're right....
21:00:42 <dons> ST is for getting at raw mutable stuff in memory, quite different to Monad.State
21:01:45 <RichN> "raw mutable stuff" like mutable arrays?
21:04:10 <ddarius> yes
21:04:11 <RichN> I don't quite see how STRefs fit in. There was discussion in the paper on how you can't get at STRefs from outside the ST and you can't share STRefs between STs. How is that different than using the state as in State? I'm obviously missing something...
21:04:16 <sjanssen> RichN: yeah, arrays 'n references
21:04:24 <dons> anyone think this is funny? :)  -->
21:04:25 <dons> 23266 dons      25   0 2132m 2.1g 9120 R  100 13.4   2:51.50 jhc
21:04:28 <dons> 23416 dons      25   0 1973m 1.9g 8360 R  100 12.4   1:53.41 jhc
21:04:31 <dons> 23522 dons      25   0 1520m 1.5g 8048 R  100  9.5   1:10.06 jhc
21:04:34 <dons> 23536 dons      25   0 1530m 1.5g 8032 R  100  9.5   1:06.84 jhc
21:04:37 <dons> 23599 dons      25   0 1073m 980m 1256 R  100  6.2   0:16.38 runhugs
21:04:45 <sjanssen> lol
21:05:15 <glguy> if anyone is writing apps against HAppS' darcs version, your app will break if you do a darcs pull
21:05:45 <glguy> (I think)
21:05:46 <sjanssen> RichN: ST is a bit more flexible than State
21:05:53 <ddarius> RichN: State simulates state, but is only good for small pieces of state.  It does not support mutable arrays or references.
21:06:04 <glguy> depends on which repo http://happs.org exposes
21:06:07 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8.4 )
21:06:07 <ddarius> You cannot even simulate ST with State.
21:06:21 <jcreigh> presumably the reverse is true.
21:06:42 <sjanssen> RichN: you can allocate as many mutable references as you want in ST, whereas State is limited to one mutating bit
21:06:58 <glguy> State has one hidden reference
21:07:03 <glguy> ST has many explicit mutable ones
21:07:04 <sjanssen> ddarius: you can simulate ST with State and Data.Dynamic
21:07:05 <RichN> okay... now I'm seeing the advantage.
21:07:27 <ddarius> sjanssen: Not without restricting the interface or using unsafeCoerce#
21:07:44 <sjanssen> ddarius: Data.Dynamic has everything you need
21:08:30 <ddarius> sjanssen: Show me the implementations newSTRef/readSTRef/writeSTRef with the equivalent of their current types.
21:08:33 <RichN> isn't there some "magic" going on to associate an STRef to a given ST?
21:08:53 <ddarius> RichN: Not really.  There's a trick, but it's not magical.
21:09:08 <RichN> but is there a performance hit that State doesn't pay?
21:09:24 <RichN> (albeit State has less flexibility)
21:09:48 <ddarius> RichN: State and ST are used in different situations.  They aren't really comparable in that regard.
21:11:09 <glguy> You don't find yourself wondering "hmm, which should I use in this case.... ST or State"
21:12:00 <dons> RichN: rarely, rarely do you need ST.
21:12:12 <dons> only if you plan mutating raw memory, when often you'd use the FFI for that anyway
21:12:29 <dons> State however, is a lovely monadic way to deal with global and local state
21:12:42 <dons> > runState (do x <- get ; put (x+1) ; return "done") 7 -- like this
21:12:43 <ddarius> RichN: One (further) difference is that State adds a single piece of "global" state. STRefs would have to be passed around to accomplish a similar thing in ST.
21:12:44 <lambdabot>  ("done",8)
21:13:28 <RichN> cool. thanks for the insights.
21:13:35 <glguy> ST is the S transformer
21:13:57 <ddarius> And incidentally, State s a = ReaderT (STRef s) ST a
21:13:58 <dons> wel, not sure. its a State Thread, afaik
21:14:03 <mauke> SKIT
21:14:13 <RichN> I've never had so much fun learning a new language  :)
21:14:24 <glguy> dons: I'm being a pest, I know that's not true :-p
21:14:24 <dons> ddarius: cute
21:14:35 <dons> glguy: don't be a pest
21:15:03 <glguy> I didn't beat Guitar Hero II today so that I could be a productive person
21:26:48 <jcreigh> is it normal to use the State monad a lot when writing a compiler?
21:27:35 <jcreigh> I'm using it in the core of my toy compiler, and I'm afraid I might be like the "OO" programmer who likes the singleton pattern...
21:27:37 <ddarius> It's not abnormal.
21:28:10 <dons> not at all, ghc is full of monads carrying around contexts
21:28:22 <dons> and you can write some nice interpreters with Reader monads
21:28:50 <dons> any time you have a large chunk of data you need to thread around some group of functions, but which isn't needed outside
21:30:06 <sjanssen> @paste
21:30:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:30:34 <hpaste>  sjanssen pasted "ST with State+Data.Dynamic" at http://hpaste.org/700
21:30:44 <glguy> woohoo, 700 :)
21:30:58 <sjanssen> ddarius: ^^^
21:31:09 <monochrom> You have to forgive your brothers 700 times 70 times.
21:31:18 * jcreigh 's current gaming outlet is NFS4 running under wine
21:31:30 <sjanssen> I wasn't able to write runST, but I'm sure that's just my unfamiliarity with rank 2
21:31:31 <jcreigh> 320x240 w/ software rending, but it's running, darn it!
21:32:28 <hpaste>  sjanssen annotated "ST with State+Data.Dynamic" with "oops, bug!" at http://hpaste.org/700#a1
21:33:48 <dons> i can now confirm that 6 jhcs will gladly use 16 G of ram
21:34:03 <siti> ouch
21:34:23 <dons> but john hasn't profiled jhc in a while, I suspect
21:34:53 * jcreigh wonders how much of the Web is in RAM at any given time a Google's server farms.
21:35:09 <jcreigh> s/\<a\>/at/
21:37:06 <ddarius> @type readSTRef
21:37:08 <lambdabot> Not in scope: `readSTRef'
21:37:26 <ddarius> @type Data.STRef.readSTRef
21:37:29 <lambdabot> forall s a. GHC.STRef.STRef s a -> ST s a
21:37:50 <ddarius> sjanssen: You're type is not polymorphic enough.
21:38:06 <sjanssen> ddarius: yes, but the Typeable constraint is both trivial and bogus
21:39:06 <ddarius> sjanssen: My point was that you can't implement the STRef interface in Haskell.  It must be "magic" behind it.
21:39:36 <ddarius> Then of course, there is the time complexity requirements.
21:41:12 <sjanssen> ddarius: you said interface, not complexity :)
21:42:39 <sjanssen> a more clever data structure could yield the right complexity too
21:47:56 <glguy> I love it when your fingers learn complex passage in songs and it's only when you stop focusingon the notes that you can play them
21:51:59 <ddarius> sjanssen: Are you sure?  O(1) readSTRef, O(1) writeSTRef, O(1) newSTRef  (also I consider time/space complexity part of the interface of a library)
21:52:16 <ddarius> glguy: I agree.
21:52:38 * ddarius is getting better at Pachelbel's Canon
21:53:24 <jcreigh> glguy: http://www.ctrlaltdel-online.com/comic.php?d=20060419
21:53:26 <lambdabot> Title: Ctrl+Alt+Del
21:55:10 <sjanssen> ddarius: it can be done in O(1) amortized with DiffArray
21:56:28 <glguy> jcreigh: excellent!
21:56:45 <jcreigh> heh
21:56:50 * glguy has only *3* songs left to go from 4 -> 5 stars on hard :-D
21:57:08 <glguy> I'm getting better by the minute! ;)
21:59:35 <ddarius> sjanssen: Including newSTRef?
21:59:53 <ddarius> I guess you could double the array size each time it overflows.
22:00:07 <sjanssen> ddarius: yeah, when you run out of slots in the array, you double the size
22:00:17 <sjanssen> that is O(1) amortized
22:02:09 <sjanssen> and if unsafeCoerce# is allowed, you can do it without the Typeable constraints
22:02:14 <ddarius> I won't mention the fact that you need unsafePerformIO and that to a slight extent you are implementing refs in terms of refs (but that admittedly is very very fuzzy).
22:02:47 <sjanssen> yeah, DiffArray is a nasty little hack in it's own right
22:03:24 <bos> @hoogle sleep
22:03:25 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
22:03:37 <jcreigh> @hoogle threadDelay
22:03:38 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
22:03:44 <jcreigh> the unit is *microseconds*
22:03:48 <jcreigh> IIRC
22:03:51 <bos> thx :)
22:04:03 <hpaste>  brian pasted "consecutive sequences" at http://hpaste.org/701
22:04:33 <brad_> a question regarding a small code chunk i saw in a blog article recently:
22:04:43 <brad_> let powerset = filterM (const [True, False])
22:04:52 <brad_> powerset ['a','b']
22:05:01 <brad_> ["ab","a","b",""]
22:05:18 <brad_> i know that this is using the list monad, just not sure how powerset functions
22:05:32 <glguy> > map concat $ mapM ((:[]).(:[]).(:[])) "ab"
22:05:43 <glguy> > map concat $ Control.Monad.mapM ((:[]).(:[]).(:[])) "ab"
22:05:44 <lambdabot>  [["a","b"]]
22:05:56 <glguy> > map concat $ Control.Monad.mapM (([]:).(:[]).(:[])) "ab"
22:05:57 <ddarius> Jesus Christos, 146
22:05:58 <lambdabot>  ["","b","a","ab"]
22:06:00 <sjanssen> brad_: a better name for that function is "subsequences"
22:06:31 <sjanssen> brad_: do you know the list monad well?
22:06:42 <brad_> sjanssen - perhaps not well enough
22:06:58 <glguy> > replicateM 2 [True,False]
22:07:00 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
22:07:05 <brad_> i am not sure how filtering 'const [True, False]' operates in this case
22:08:08 <newsham> > [x++y | x<-["", "a"], y<-["", "b"]]
22:08:09 <lambdabot>  ["","b","a","ab"]
22:08:34 <mauke> True/False decide whether to keep or to filter the current list element
22:08:41 <brad_> ah newsham, that illuminates a bit
22:08:45 <mauke> returning [True,False] means to do both
22:08:56 <mauke> and filterM does that for each element
22:09:05 <brad_> thanks mauke!
22:10:41 <newsham> > let p x ys = [ys, x:ys] in p 'a' [] >>= p 'b'
22:10:43 <lambdabot>  ["","b","a","ba"]
22:10:47 <newsham> > let p x ys = [ys, x:ys] in p 'a' [] >>= p 'b' >>= p 'c'
22:10:49 <lambdabot>  ["","c","b","cb","a","ca","ba","cba"]
22:13:27 <glguy> > foldM (\ys x -> [ys, x:ys]) [] "abc"
22:13:28 <brad_> thanks newsham for the code snippets!
22:13:29 <lambdabot>  ["","c","b","cb","a","ca","ba","cba"]
22:13:36 <brad_> and glguy!
22:13:45 <newsham> tada.
22:13:51 <brad_> hmmm, you guys know a lot of ways to skin a cat
22:13:58 <sjanssen> glguy: we need foldrM
22:13:59 <newsham> foldM is a good cat skinner
22:14:23 <glguy> sjanssen: why? foldM can be used to implement reverse
22:14:27 <glguy> sjanssen: :-D
22:14:51 <sjanssen> glguy: where M == identity monad?
22:14:55 <glguy> sure
22:14:58 <sjanssen> or do you have something more interesting?
22:15:04 <glguy> naw, that's all
22:15:38 <newsham> ?let powSet = foldM (\ys x -> [ys, x:ys]) []
22:15:40 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
22:15:41 <brad_> thanks guys for the various explanations! seeing it written in different ways is educational. take care!
22:16:03 <newsham> ?tell dons error when ?let powSet = foldM (\ys x -> [ys, x:ys]) []
22:16:03 <lambdabot> Consider it noted.
22:16:32 <sjanssen> newsham: @let has been broken for a while
22:16:45 <sjanssen> happened when dons changed boxes or some such
22:17:18 <sjanssen> > logBase 2 . fromInteger $ maxBound
22:17:19 <lambdabot>   add an instance declaration for (Bounded Integer)
22:17:41 <sjanssen> > logBase 2 . fromIntegral $ (maxBound :: Int)
22:17:43 <lambdabot>  30.999999999328196
22:17:57 <lispy> er?
22:18:06 <lispy> is that right?
22:18:12 <sjanssen> awww, still on the 30.999999999328196 box :(
22:18:16 <newsham> > map unwords $ foldM (\ys x -> [ys, x:ys]) [] (reverse $ words "lets test this")
22:18:18 <lambdabot>  ["","lets","test","lets test","this","lets this","test this","lets test this"]
22:18:28 <ddarius> @type bitSize
22:18:31 <lambdabot> forall a. (Bits a) => a -> Int
22:18:34 <sjanssen> lispy: yeah, twos complement says maxBound = 2^31 - 1
22:18:51 <lispy> sjanssen: oh, right Ints are signed :)
22:19:20 <lispy> > logBase 2 . fromIntegral $ (maxBound :: Word32)
22:19:22 <lambdabot>  31.999999999664098
22:19:22 <ddarius> > bitSize (undefined :: Word)
22:19:24 <lambdabot>  32
22:20:03 <lispy> > logBase 2 . fromIntegral $ (maxBound :: Word32 + 1)
22:20:03 <lambdabot>  Parse error
22:20:09 <lispy> > logBase 2 . fromIntegral $ ((maxBound :: Word32) + 1)
22:20:10 <lambdabot>  -Infinity
22:20:13 <lispy> nice!
22:20:48 <ddarius> log 0
22:20:52 <ddarius> > log 0
22:20:54 <lambdabot>  -Infinity
22:20:54 <lispy> right
22:21:11 <newsham> > (maxBound  + 1) :: Word32
22:21:13 <lambdabot>  0
22:21:13 <siti> > -Infinity * -Infinity
22:21:14 <lambdabot>   Not in scope: data constructor `Infinity'
22:21:18 <newsham> > (maxBound) :: Word32
22:21:20 <lambdabot>  4294967295
22:21:30 <lispy> > (log 0) * (log 0)
22:21:32 <lambdabot>  Infinity
22:22:08 <newsham> > showHex (maxBound :: Word32) ""
22:22:10 <lambdabot>  "ffffffff"
22:22:17 <newsham> > showHex (maxBound :: Int) ""
22:22:19 <lambdabot>  "7fffffff"
22:23:19 <lispy> 22:19 <lispy> > logBase 2 . fromIntegral $ (maxBound :: Int)
22:23:19 <lispy> 22:19 <SiR>  63.0
22:23:25 <siti> @botsnack
22:23:26 <lambdabot> :)
22:23:43 <lispy> so apparantly, on EM64T it's 63 bits
22:23:59 <glguy> > foldM (liftM2 (.) (:) ((.) (:[]) . (flip (:)))) [] "abc"
22:24:01 <lambdabot>  ["","c","b","cb","a","ca","ba","cba"]
22:24:02 <newsham> makes sense
22:24:05 <sjanssen> lispy: probably a truncation issue
22:24:07 <glguy> hand pl'ed :)
22:24:43 <sjanssen> lispy: the mantissa of a Double is only 53 bits
22:25:20 <newsham> praying mantissa is only 3bits
22:25:26 <mauke> is "pl'ed" pronounced like "peeled"?
22:26:33 <lispy> ah, but bitSize (undefined :: Int) gives 64
22:27:10 <monochrom> sjanssen: I can get "runST :: (forall s. ST s a) -> a" to work.  Do you want to know how?
22:27:20 <newsham> lispy: is that unexpected?
22:27:23 <sjanssen> monochrom: yes please
22:27:37 <lispy> newsham: it's what i had hoped, actually
22:27:47 <lispy> newsham: just glad to confirm it :)
22:28:48 <monochrom> runST :: (forall s. ST s a) -> a;  {- need explicit sig -}  runST s = case s of ST p -> evalState p Map.empty
22:28:59 <newsham> > logBsae 2 $ fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int)
22:29:01 <lambdabot>   Not in scope: `logBsae'
22:29:05 <newsham> > logBase 2 $ fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int)
22:29:07 <lambdabot>  31.999999999664098
22:29:17 <monochrom> A point to note is that "runST (ST p) = ..."  will run into type errors.
22:29:48 <sjanssen> monochrom: yeah, all my attempts were with the declaration syntax
22:29:49 <newsham> > flip showHex "" $ fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int)
22:29:50 <lambdabot>  "ffffffff"
22:30:00 <newsham> > flip showHex "" $ fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int) + 1
22:30:01 <sjanssen> monochrom: do you know why the case version works?
22:30:02 <lambdabot>  "100000000"
22:30:06 <monochrom> It is amusing that "f (X y) = ..." is not the same as "f x = case x of X y -> ..." for the type engine :)
22:30:20 <newsham> > logBase 2 $ fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int) + 1
22:30:22 <lambdabot>  32.0
22:30:25 <newsham> tada
22:30:51 <monochrom> I don't actually know.  I just run into it.  "runST s = let ST p = s in ..." also works.  Just don't pattern-match on the LHS. :)
22:31:07 <sjanssen> weird
22:31:32 <sjanssen> I thought runST (ST m) would desugar to the case version anyway
22:31:37 <monochrom> It's likely that pattern-matching on the LHS causes some type variables to become rigid or something.
22:31:42 <newsham> ?check \x y -> length [x .. y] == y - x + 1
22:31:43 <lambdabot>  Falsifiable, after 0 tests: 2, -1
22:31:52 <newsham> ?check \x y -> length [x,1 .. y] == y - x + 1
22:31:54 <lambdabot>  Falsifiable, after 0 tests: -1, 3
22:32:34 <monochrom> I think the desugarer treats them the same, but the type checker treats them different, and they are two separate ghc stages.
22:32:57 <mauke> ?check \x y -> length [x .. y] == if x > y then 0 else y - x + 1
22:32:59 <lambdabot>  OK, passed 500 tests.
22:33:59 <dons> haskell's great. its so fun that it could almost typecheck this ;)
22:34:00 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
22:34:00 <dons>                 s <- readFile db
22:34:01 <dons>                 let v = read v :: Results
22:34:03 <dons> :)
22:34:22 <monochrom> "almost" is almost never good enough :)
22:34:43 <dons> that's one of my most common bugs. the worse case is when it does check, and then loops at runtime
22:35:10 <dons> i wonder how I could stop doing that. hmm.
22:35:11 <monochrom> Oh, "almost" is good enough!
22:35:25 <dons> yeah, it want it to fail badly
22:35:26 <monochrom> Apply SP2 to your brain? :)
22:36:28 <ddarius> You could use case instead of let.
22:36:46 <glguy> ?check \x y -> length [x .. y] == max 0 (y - x + 1)
22:36:48 <lambdabot>  OK, passed 500 tests.
22:36:56 <monochrom> I use case instead of let.
22:37:05 <newsham> > length [(minBound :: Int) .. maxBound]
22:37:11 <lambdabot> Terminated
22:37:13 <newsham> heh
22:37:24 * ddarius never uses case instead of let.
22:38:06 <monochrom> When I want more eagerness, I use case instead of let.
22:38:24 <newsham> rewrite rule:   length [s .. e] => if ee > ss then ss - ee + 1 else 0 where ss = fromEnum s; ee = fromEnum e
22:39:25 <glguy> ?check \x y -> length [x .. y] == max 0 (fromEnum y - fromEnum x + 1)
22:39:26 <lambdabot>  Add a type signature
22:39:35 <ddarius> monochrom: I was implicitly assuming cases where they would be equivalent.
22:39:38 <glguy> ?check \x y -> length [(x :: Bool) .. y] == max 0 (fromEnum y - fromEnum x + 1)
22:39:39 <lambdabot>  OK, passed 500 tests.
22:40:10 <mauke> ?check \e s -> length [e .. s] == let ee = fromEnum e; ss = fromEnum s in if ee > ss then ss - ee + 1 else 0
22:40:11 <lambdabot>  Add a type signature
22:40:19 <newsham> ?check \x y -> length [(x :: Char) .. y] == max 0 (fromEnum y - fromEnum x + 1)
22:40:22 <monochrom> In that case, let enjoys better indentation. :)
22:40:24 <lambdabot>  OK, passed 500 tests.
22:40:25 <mauke> ?check \e s -> length [e :: Double .. s] == let ee = fromEnum e; ss = fromEnum s in if ee > ss then ss - ee + 1 else 0
22:40:26 <lambdabot>  Falsifiable, after 0 tests: 0.0, 0.0
22:40:27 <glguy> arg, the "if" burns my eyes!
22:40:39 <mauke> huhu
22:40:48 <newsham> > [0.3 .. 10.5]
22:40:50 <lambdabot>  [0.3,1.3,2.3,3.3,4.3,5.3,6.3,7.3,8.3,9.3,10.3]
22:40:54 <newsham> hum :)
22:41:16 <ddarius> dons: Also,  v <- return (read v)
22:43:12 <dons> ddarius: in terms of generating more obvious type errors?
22:48:35 <ddarius> dons: It should give a variable not defined error.
22:49:56 <dons> oh, of course. yes. that's cute
22:51:00 <newsham> Many mistakenly assume Richard Nixon was impeached, but he wasn't. While the House Judiciary Committee did approve articles of impeachment against him (by wide margins) and did report those articles to the full House, Nixon resigned prior to House consideration of the impeachment resolutions.
22:51:03 <ddarius> Of course, if a 'v' is defined you're screwed in this case.
22:51:07 <newsham> oops, wrong channel
22:51:46 <ddarius> Unless it's not a String.
22:52:20 <dons> well, combined with -Wall -Werror
22:52:26 <dons>  to catch variable shadowing
22:52:44 <dons> of course it means never using 'let' ;)
22:52:56 <dons> who votes for letnorec ? :-)
22:53:12 <ddarius> Yeah, I was thinking about that a bit ago.
22:58:14 <dons> oh, cute. instead of grappling with nested ` ` invocations in the shell,
22:58:15 <dons> $ pwd | xargs dirname | xargs basename
22:58:16 <dons> imaginary
22:58:25 <dons> e.g. basename (dirname pwd)
22:58:53 * dons notes to use '| xargs' more often
22:59:53 <TSC> $() is easier to nest than ` `
23:00:22 <TSC> Although xargs looks nicer (:
23:00:46 <dons> $ basename $(dirname $(pwd))
23:00:48 <dons> imaginary
23:00:48 <dons> not so bad
23:01:30 <dons> though for some reason i never remember $() in the shell. maybe because the only shell I write is in makefiles, where $(X) is something else :)
23:04:24 <notsmack> isn't $() bash only?
23:04:55 <dons> zsh too. probably not sh though
23:05:06 <notsmack> right
23:05:20 <notsmack> not a big deal, but the xargs way is nice if you need that
23:05:36 <arcatan> works in pdksh too :)
23:05:49 <dcoutts> Igloo, no, readFile would have the same type but it'd have a different impl
23:24:56 <JohnMeacham> wacky. good compiler options seem radically different for different computers.
23:28:55 <dons> hehe
23:29:15 <dons> so runing 8 concurrent jhcs was straining the ram on my new box
23:29:28 <dons> even though the results weren't changing
23:29:42 <dons> so you can now selectively run a compiler, and have its results merged into the database
23:29:56 <dons> which should save me having to run jhc every night, maxing out ram ;)
23:41:08 * glguy using $(</var/run/example.pid) a lot
23:41:11 <glguy> uses*
23:46:59 <max22> does anybody know how separate modules are compiled ??
23:47:16 <TSC> One at a time?
23:47:39 <mwc> max22, seperately? :)
23:47:43 <TSC> What do you mean?
23:47:50 <max22> meanin..
23:48:02 <glguy> *FAWK* i misssd the *last* note in the song
23:48:09 <dons> max22: you mean, with --make ?
23:48:18 <dons> max22, ghc --make -O Main.hs
23:48:24 <max22> in cabal..
23:48:24 <max22> when u build
23:48:43 <max22> ok then hows it done with make?
23:48:43 <max22> yeh using ghc
23:48:49 <dons> are you building a library or an executable?
23:49:01 <max22> like in c..
23:49:13 <max22> the preprocessor includes the files rii
23:49:18 <dons> ghc --make -O Main.hs
23:49:19 <max22> hows it done in haskell?
23:49:27 <dons> see above
23:49:58 <max22> yeh..but do u know how its done internaly?
23:50:15 <max22> i'm tryin 2 write a distributed compilation tool
23:50:24 <dons> for ghc?
23:50:35 <max22> so the independent files hhav 2 b shipped across the networks
23:50:40 <max22> yeh using ghc
23:50:46 <dons> your spelling is scaring me.
23:51:09 <max22> so the tool has 2 calculate a dependecy tree..
23:51:11 <dons> its not trivial to explain how ghc builds its module graph and compiles it
23:51:20 <dons> best grab the src, and then look at DriverPipeline.hs
23:51:23 <dons> in the ghc source.
23:52:09 <max22> ok..and?
23:52:27 <TSC> "Read it" is probably the next step
23:52:36 <max22> well the idea is similar to distcc..the distributed compiler for C
23:52:45 <dons> yes. this has be discussed before for ghc
23:52:54 <dons> the problem is getting .hi files around the network
23:53:01 <dons> and forking multiple copies of ghc on each node
23:53:13 <dons> there should be some notes on the ghc developers wiki on what needs to be done.
23:53:24 <max22> ok..well
23:53:42 <max22> mayb i can explaain a li'l more with how distcc works
23:53:55 <max22> in that the preprocessing is done locally..
23:54:07 <max22> then the preprocessed source files r distributed
23:54:11 <dons> there's no preprocessing phase with haskell though
23:54:26 <max22> which means u dont need the headers at every node
23:54:34 <max22> yeh..i'v heard that..
23:55:04 <max22> so exactly what happens when u import a module??
23:56:00 <dons> a graph describing the entire programs module dependencies is built
23:56:09 <dons> then each node in that graph is compiled to a .hi file and a .o file
23:56:13 <max22> u mean 2 say that .hi files contain all the info that is necessary to build thhe program?
23:56:27 <max22> ok..
23:57:31 <dons> what you should do is grab the ghc source, build it, then look at the ghc commentary. once you've got your head around how the module graph is built, then you can think about how to break that graph up into pieces which might be executed on remote nodes
23:57:32 <max22> so where can i extract that graph?
23:57:43 <max22> oh ok..
23:58:03 <dons> best to write some code now :-)
23:58:09 <max22> and what abt cabal?
23:58:16 <dons> snce a huge technical task like this is probably not solved well on irc.
23:58:17 <max22> wat if i want 2 use cabal 2 build the source?
23:58:21 <dons> cabal just uses ghc --make
23:58:29 <dons> so solve ghc --make first
23:58:54 <dons> have you done much haskell programming?
23:59:09 <max22> oh..
23:59:27 <max22> well..the prob is i'm kinda new 2 haskell..n i'm doin the codin in C
23:59:35 <max22> is it possible for u 2 help me with this part?
23:59:38 <max22> not really
23:59:41 <dons> nope.
