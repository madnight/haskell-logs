00:12:37 <SamB> @vixen asl
00:12:37 <lambdabot> <undefined>
00:12:45 <SamB> oh rats. I forgot....
00:14:39 <nornagon> heh
00:26:22 * kfish bakes some lambdacake
00:27:52 <newsham> shim.exe: exception :: GhcException
00:28:42 <nornagon> yo kfish
00:31:00 <davidmccabe> in the following statement true in spirit?
00:31:02 <davidmccabe> "When a Haskell program is compiled, the compiler simply expands expressions into their definitions until it has reduced everything to built-in functions and types."
00:31:39 <kfish> nornagon, heya, how goes things?
00:31:53 <dons> davidmccabe: yeah, that's basically it
00:32:08 <kfish> davidmccabe, for various values of "simply"
00:32:08 <dons> it just unfolds everything down to primops and closures and raw math
00:32:11 <norpan> that's basically it for any compiler
00:32:16 <norpan> any  language :)
00:32:37 <dons> inlining is more widely used, and more critical in ghc, than most other compilers though
00:32:39 <davidmccabe> ok, wanted to make sure I wasn't catastrophically misunderstanding Haskell here ;)
00:32:50 <dons> since purity makes inlining a kind of killer optimisation
00:33:03 <davidmccabe> technical details don't really matter for my purposes.
00:33:10 <davidmccabe> thanks :)
00:34:57 <_roconnor> > 20*logBase 2 (10)
00:34:59 <lambdabot>  66.43856189774725
00:35:19 <sorear> inlining subsumes:
00:35:29 <sorear> - unboxing (worker/wrapper)
00:35:33 <sorear> - loop unrolling
00:35:40 <sorear> - specialization
00:37:44 <dons> sorear: and evaluation :-)
00:40:21 <_roconnor> > 25*logBase 2 (6)
00:41:09 <lambdabot>  64.62406251802891
01:06:43 <nornagon> kfish: pretty awesomely
01:07:07 <nornagon> kfish: yourself?
01:07:14 <kfish> good :-)
01:07:35 <kfish> just hacking, studying maths, studying japanese :-)
01:08:34 <nornagon> :-)
01:08:41 <nornagon> I wish I was doing more hacking and less studying maths
01:08:52 <nornagon> I want to do more procedural content stuff
01:09:07 <nornagon> but haskell's graphics offerings are fairly slim
01:09:22 <kfish> hmm
01:09:35 <kfish> haskell's procedural offerings are pretty good though :-)
01:09:37 <nornagon> all the opengl tutorials i've seen have presented hilariously unscalable approaches
01:09:44 <nornagon> right, but there's not much point if i can't see them :p
01:09:54 <nornagon> s/them/the results/
01:10:08 <kfish> unscalable because the tutorial doesn't do things the right way for opengl?
01:10:35 <nornagon> more in the way they pass various state IORefs around
01:11:26 <kfish> ah ok
01:11:37 <nornagon> I should read All About Monads.
01:11:38 <kfish> well, i guess the idea is to be instructive about the opengl calls
01:11:42 <kfish> nornagon, yep :-)
01:11:48 <nornagon> since i don't grok the state monads yet
01:12:02 <kfish> i suggest dons' tute "Roll your own IRC bot"
01:12:14 <nornagon> @where roll your own irc bot
01:12:15 <lambdabot> I know nothing about roll.
01:12:25 <nornagon> @where monads
01:12:25 <lambdabot> http://mbishop.esoteriq.org/stuff/allaboutmonads.pdf
01:12:46 <nornagon> oh, i already have it
01:12:57 <kfish> ?wiki Roll_your_own_IRC_bot
01:12:57 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
01:13:03 <nornagon> ahr.
01:13:27 <kfish> if you work through that, you will understand how to use ReaderT, and then StateT
01:14:25 <nornagon> Cool. :)
01:14:40 <kfish> and then you can write a tutorial about how to use opengl properly with haskell :-)
01:18:45 <dons> ?go roll your own irc bot
01:18:47 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
01:18:47 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
01:24:07 <therp> good morning everyone
01:24:10 <nornagon> > fix (const 1)
01:24:11 <lambdabot>  1
01:24:25 <nornagon> ^- does that happen for any function with a lazy pattern match?
01:26:59 <nornagon> hm, doesn't appear to have to be lazy
01:27:51 <augustss_> @seen dons
01:27:51 <lambdabot> dons is in #haskell. I last heard dons speak 9m 5s ago.
01:28:04 <augustss_> dons: ping
01:28:24 <augustss_> @seek ookk
01:28:24 <lambdabot> I saw ookk leaving #haskell 7h 13m 15s ago, and .
01:29:31 <nornagon> @src seq
01:29:32 <lambdabot> Source not found. That's something I cannot allow to happen.
01:29:56 <augustss_> nornagon: there can be no source for seq
01:30:04 <osfameron> morning
01:31:19 <osfameron> i'm on ghc 6.4.2 on ubuntu, and i can't work out how to get ghci to see libraries like graphics and parsec
01:32:14 <osfameron> i tried setting-L to the imorts/ subdirectry which is where synaptic had installed them
01:33:24 <osfameron> but doing :set --print-libdir still only shows the parent dir . any suggestions?
01:34:34 <bringert> osfameron: -package parsec
01:34:56 <osfameron> ah, thanks
01:35:30 <nornagon> cute, All About Monads is telling me that there is no function IO a -> a
01:35:36 <nornagon> i, however, am from the Dark Side
01:35:42 <nornagon> :t unsafePerformIO
01:35:43 <lambdabot> Not in scope: `unsafePerformIO'
01:35:44 <osfameron> why doesn't it dtrt when it sees the import statement, i wonderr...
01:35:54 <nornagon> lambdabot is good and holy, it seems.
01:36:08 <augustss_> as it should be!
01:37:14 <sorear> :t System.IO.Unsafe.unsafePerformIO
01:37:15 <lambdabot> forall a. IO a -> a
01:37:23 <sorear> and more
01:37:25 <sorear> @src unsafePerformIO
01:37:25 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
01:38:06 <osfameron> bringert: ok for parsec but says unknown package for graphics Graphics SOEGraphics Graphics::SOE etc.
01:38:24 <bringert> osfameron: that doesn't come with ghc
01:39:20 <osfameron> bringert: it's in my installation under imports/ from the ubuntu package
01:39:26 <augustss_> sorear: some things are better not to know!
01:39:41 <bringert> osfameron: ok, maybe the package is called something else
01:39:48 <bringert> osfameron: try ghc-pkg list
01:40:24 <augustss_> sorear: interestingly, when I switch the ookk's planet program from using the IO monad to the ST monad it went faster
01:40:26 <osfameron> ah, maybe HGL
01:41:55 <osfameron> ok -package HGL allows me to import Graphics.SOE
01:42:41 <osfameron> the hudak book is cute but it doesn't do any handholdng on getting the exercises to compile
01:44:19 <osfameron> bringert: thanks!
01:44:25 <nornagon> @src [] mplus
01:44:25 <lambdabot> mplus = (++)
01:55:50 <augustss> rehowdy
01:56:59 <ohmega> phb2 :)
02:01:00 <nornagon> @src [] (>>=)
02:01:00 <lambdabot> m >>= k     = foldr ((++) . k) [] m
02:02:19 <profmakx> does anyone here know why cse.unsw.edu.au is not reachable from germany anymore? terrorist content blocked?
02:03:18 <sorear> dons: sounds like it's for you
02:03:25 <profmakx> no it isnt
02:03:33 <profmakx> because it is reachable for different providers
02:03:38 <profmakx> but not for me :/
02:04:05 <sorear> profmakx: ping 129.94.242.51
02:04:06 <sorear> ?
02:04:17 <profmakx> does not work
02:04:31 <profmakx> traceroute stops at fra.aarnet.au
02:04:40 <sorear> dns wouldv'e been such a good explanation...
02:04:43 <profmakx> i do not even get an ip adress
02:05:11 <sorear> @seen vincenz
02:05:11 <lambdabot> vincenz is in #oasis, #haskell.dut and #haskell. I don't know when vincenz last spoke.
02:07:27 <dons> there was some dns issue yesterday
02:07:33 <dons> seems like its still propagating
02:07:37 <dons> ?bot <-- still here though
02:07:38 <lambdabot> :)
02:08:20 <dons> profmakx: does http://129.94.242.51/ work?
02:08:20 <lambdabot> Title: School of Computer Science & Engineering
02:08:30 <profmakx> yeah dns does not work but i cannot even reach the ip address, so some isp/peering does have a problem.
02:08:34 <profmakx> no dons, it doesnt
02:08:48 <dons> weird.
02:08:50 <dons> :/
02:08:53 <dons> what page were you after/
02:09:03 <dons> hmm, not that there's much I can do about it.
02:09:08 <profmakx> lambdabot darcs repo
02:09:13 <profmakx> no its okay
02:09:17 <profmakx> i thought anyone knew
02:09:38 <profmakx> if the problem persists i will ask our uni`s noc
02:10:20 <nornagon> @version
02:10:20 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
02:10:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:10:41 <profmakx> thanks anyway ;)
02:43:23 <TuringTest> the shootout is looking great.  Ignoring "cheap concurrency
02:43:43 <TuringTest> "since Ocaml has no entry: Haskell is better at memory and Ocaml is only slightly better at CPU time.
02:43:45 <sorear> TuringTest: I think you have that backward
02:43:59 <sorear> oh.
02:44:59 <TuringTest> I re-checked:  Cheap-Concurrency to zero, just CPU time: OCaml / Clean / Haskell.
02:45:25 <TuringTest> Just Memory : Haskell / Fortran G95 / Clean / OCaml
02:45:31 <tuukkah> the new gtk2hs failed to build in debian on ia64 and alpha :-(
02:46:19 <TuringTest> An interesting way to compare 2 languages with this tradeoff is what CPU / Memory ratio makes them into a tie...
02:51:22 <paolino> hi , how do I decompose a record in pattern matching ?
02:51:31 <paolino> state{nodes = (Nodes ps)} <- get
02:51:44 <paolino> nodes is the accessor ?
02:51:59 <TuringTest> hmmm  n-body and partial-sums still are pending shootout updates.
02:52:50 <Saizan> paolino: yes, is the name of the field
02:53:08 <tuukkah> paolino, no need for "state" there
02:53:46 <paolino> state @ NetState {nodes = Nodes ps} <- get
02:53:52 <paolino> :)
02:53:58 <paolino> trial and error paid
02:54:15 <tuukkah> right :-)
02:55:12 <tuukkah> "On Alpha, I can only handle 32 bytes of non-floating-point arguments to foreign export dynamic" - who am i ?-)
02:57:38 <augustss> @seen dons
02:57:38 <lambdabot> dons is in #haskell. I last heard dons speak 48m 35s ago.
02:57:52 * matt__r is trying to sort out a few more details on ghc's core
02:58:36 * matt__r is wondering exactly how important operational and/or denotational semantics for core are
02:59:13 <matt__r> anyone here got some insights on core?
03:00:26 <sorear> night all
03:00:33 <matt__r> night
03:00:35 <augustss> TuringTest: I have a nicer looking n-body now, but 5% slower.
03:02:05 <ookk> augustss, can i see?
03:02:05 <lambdabot> ookk: You have 1 new message. '/msg lambdabot @messages' to read it.
03:02:11 <pejo> matt, you're probably better off with the GHC commentary - it's somewhere on the wiki.
03:02:30 <matt__r> pejo: been there
03:02:41 <augustss> ookk: when i switch from IO to ST it ran faster again :)
03:03:03 <ookk> nice
03:03:08 <matt__r> pejo: plenty of interesting stuff, but I have yet to find anything on where and how known semantics for core are used
03:03:16 <ookk> well it should be able to optimize ST more than IO i guess
03:03:17 <augustss> ookk: i'm at an airport lounge so the darcs push is very slow
03:03:35 <TuringTest> ?local augustss
03:03:35 <lambdabot> Maybe you meant: localtime localtime-reply docs eval keal lojban
03:03:46 <ookk> augustss, i see
03:03:53 <pejo> augustss, heh, back in Sweden?
03:04:27 <augustss> @paste
03:04:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:04:48 <matt__r> I am yet to even find a description of the semantics of core
03:05:01 <hpaste>  augustss pasted "Nicer n-body" at http://hpaste.org/450
03:05:17 <matt__r> besides the sketch in "a transforamtion-based optimiser for haskell"
03:20:09 <matt__r> quiet night
03:37:14 <defcon8> hello
03:37:19 <defcon8> can someone explain YAHT's 4.4.3 to me, please?
03:37:56 <defcon8> I don't get where IOString changes to String
03:41:09 <defcon8> oh and I've also found a typo in YAHT. Who should I notify?
03:42:54 <_roconnor> @where YATH
03:42:55 <lambdabot> I know nothing about yath.
03:42:57 <_roconnor> @where YAHT
03:42:57 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
03:44:05 <_roconnor> defcon8: IO String never changes into string
03:44:22 <_roconnor> instead we use a function called bind to processs IO String (IO anything)
03:44:47 <roconnor> @type (=<<)
03:44:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
03:44:59 <roconnor> =<< is called bind
03:45:10 * nmessenger looks at 4.4.3 in the wikibook
03:45:14 <roconnor> it takes a function from a -> IO b and returns an IO a -> IO b
03:45:22 <Japsu> @where wikibook
03:45:22 <lambdabot> http://en.wikibooks.org/wiki/Haskell
03:45:42 <roconnor> So if you have an IO String, and you want to process it, you make a function String -> IO Whatever
03:45:44 <defcon8> I've never understand monads
03:45:48 <defcon8> haven't read about them yet
03:46:02 <roconnor> then using bind, it lifts converts your function into an IO String -> IO Whatever
03:46:30 <roconnor> Then the do notation hides this use of bind from you
03:46:42 <roconnor> the do notation is both convienent and confussing
03:47:01 <ookk> defcon8, <- is basically >>=
03:47:03 <defcon8> would the following be a valid type declaration?
03:47:19 <defcon8> square :: Int a => a -> a
03:47:30 <ookk> IO something >>= function  is really  IO (function something)
03:47:36 <der_eq> defcon8: Int is not a class
03:47:42 <der_eq> Num is
03:47:43 <defcon8> oh
03:47:44 <nmessenger> classes go to the right of =>, you want Int -> Int
03:47:45 <defcon8> okay
03:47:49 <defcon8> wanted to find the difference
03:47:52 <nmessenger> left*
03:47:53 <roconnor> square :: Num a => a -> a is good
03:48:02 <roconnor> @type (^2)
03:48:03 <defcon8> is Int called an instance?
03:48:03 <lambdabot> forall a. (Num a) => a -> a
03:48:22 <nmessenger> Int is a type which happens to be an instance of the Num type class, yes
03:48:47 <nmessenger> @instances Num
03:48:48 <lambdabot> Double, Float, Int, Integer
03:49:00 <nmessenger> all of those types are also in the Num type class
03:49:58 <nmessenger> a class defines a set of operations, an instance defines an implementation for those operation on a specific type.
03:50:02 <nmessenger> @src Num
03:50:02 <lambdabot> class  (Eq a, Show a) => Num a  where
03:50:02 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:50:02 <lambdabot>     negate, abs, signum     :: a -> a
03:50:02 <lambdabot>     fromInteger             :: Integer -> a
03:50:32 <defcon8> okay thank you
03:50:36 <defcon8> I think I get it now
03:50:38 <nmessenger> a Numeric type has add, subtract, multiply, etc operations, and each type defines its own
03:50:59 <nmessenger> @src Int (+)
03:51:00 <lambdabot> Source not found. You speak an infinite deal of nothing
03:51:13 <nmessenger> ^^ its primitive, so there's no source
03:52:30 <defcon8> count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l
03:52:36 <defcon8> is c saved for the next iteration or something?
03:52:44 <nmessenger> @src foldr
03:52:44 <lambdabot> foldr k z xs = go xs
03:52:45 <lambdabot>     where go []     = z
03:52:45 <lambdabot>           go (y:ys) = y `k` go ys
03:53:07 * nmessenger looks at that to try to explain
03:53:47 <defcon8> oh
03:53:51 <defcon8> it saves the value that the function returns
03:53:54 <Botje> defcon8: the outcome of that lamda becomes the next c.
03:53:55 <defcon8> of course
03:54:04 <defcon8> yeah sorry, brainfart
03:54:11 <nmessenger> for the empty list, the fold results in 0, otherwise your function, here called 'k', operates on the first item and the folded rest
03:54:58 <nmessenger> you could say c "starts out" as zero, and the result gets repeatedly passed into your function
03:56:08 <roconnor> http://cale.yi.org/index.php/Fold_Diagrams
03:56:13 <lambdabot> Title: Fold Diagrams - CaleWiki
03:56:22 <defcon8> nmessenger, is it just default for a number to start at 0?
03:56:41 <roconnor> foldr takes : and replaces it with k and takes [] and replaces it with c
03:56:46 <Cale> foldr f z replaces each (:) in your list with f and the [] at the end with z
03:56:47 <nmessenger> defcon8: you passed a 0 in: foldr (\x c -> ...) *0* ...
03:56:58 <defcon8> but that gets put into x?
03:57:00 <roconnor> Cale: :)
03:57:30 <defcon8> isn't it the wrong way round?
03:58:00 <defcon8> but if z's at the end, I think I get it
03:58:26 <Saizan> mapM_ print . take n . iterate (\a -> runSTArray (doSomething =<< (unsafeThaw a)) $ initial_array  -- is it reasonable to write the processing of an array like this?
04:01:22 <roconnor> @type repeatM
04:01:24 <lambdabot> Not in scope: `repeatM'
04:01:44 <roconnor> Saizan: seqeunce (repeat doSomething)
04:02:18 <Saizan> ?type \some -> sequence (repeat some)
04:02:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
04:02:24 <Cale> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1,2,3]
04:02:25 <lambdabot>  "(f 1 (f 2 (f 3 z)))"
04:02:48 <Saizan> roconnor, replicateM?
04:02:55 <roconnor> @type replicateM
04:02:56 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
04:03:03 <roconnor> an right, replicateM n
04:03:25 <roconnor> replicateM n doSomething
04:03:46 <Saizan> but replicateM doesn't feed the previuos array to doSomething
04:03:57 <Cale> > foldl (\y x -> concat ["(f ", y, " ", show x, ")"]) "z" [1,2,3]
04:03:58 <lambdabot>  "(f (f (f z 1) 2) 3)"
04:04:04 <roconnor> Saizan: I think it does
04:04:15 <nmessenger> Cale++
04:04:17 <roconnor> we are dealing with mutable arrays, right?
04:04:22 <Saizan> right
04:04:58 <Cale> > scanl (\y x -> concat ["(f ", y, " ", show x, ")"]) "z" [1,2,3]
04:04:59 <lambdabot>  ["z","(f z 1)","(f (f z 1) 2)","(f (f (f z 1) 2) 3)"]
04:05:11 <Cale> > scanr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1,2,3]
04:05:13 <lambdabot>  ["(f 1 (f 2 (f 3 z)))","(f 2 (f 3 z))","(f 3 z)","z"]
04:05:19 <roconnor> Saizan: what is the type of doSomething?
04:05:26 <Saizan> ah, so  doSomething needs only a reference to the array..
04:05:59 <roconnor> Saizan: I think something like this should work
04:08:59 <yip> anyone know how to get darcs to tell me which new files it finds that aren't versioned yet?
04:21:07 <tuukkah> yip, darcs add --dry-run -r .
04:22:29 <Cheery> kuinka moni ymmÃ¤rtÃ¤Ã¤ mitÃ¤ mÃ¤ sanon?
04:23:14 <KD-Misafir922> slm alamin güzel insanlar0131 parma011f0131n0131zdan gülücükler eksilmesin.))
04:23:16 <tuukkah> pretty many, i'd expect
04:23:18 <Cheery> I just wonder, it seems there would be unusual big dose of Finnish people.
04:24:11 <dons> ?users #haskell.fi
04:24:11 <lambdabot> Maximum users seen in #haskell.fi: 1, currently: 0 (0.0%), active: 0 (NaN%)
04:24:17 <dons> oh, there's more than that.
04:24:33 <dons> lambdabot2 lives there now
04:25:38 <kolmodin> ?users
04:25:38 <lambdabot> Maximum users seen in #haskell: 322, currently: 287 (89.1%), active: 34 (11.8%)
04:26:10 <syntaxfree> ok, I'm fascinated about modal logic.
04:26:15 <syntaxfree> What can I do to learn more about it?
04:26:19 <Japsu> :E
04:26:23 <Japsu> take an university course in it
04:27:01 <Japsu> or well
04:27:06 <Japsu> I did, and I'm none the wiser
04:27:21 <syntaxfree> that's not currently an option.
04:27:41 <syntaxfree> any pointers on stuff you read in that course?
04:28:18 <Cheery> syntaxfree: what is interesting in modal logic?
04:28:57 <syntaxfree> It seems a much clearer system to clarify scientific theoretical discourse.
04:29:07 <syntaxfree> It's like it was in "reverse order".
04:29:24 <Japsu> syntaxfree: hmm, we didn't have a real book or anything on that course, just some pages copied out of one and it was in Finnish
04:29:58 <syntaxfree> Instead of saying "A will cause B", there's "if we have B necessarily there was A"
04:30:02 <tuukkah> Cheery, currently 19 people with a .fi host, 6.6%
04:30:09 <syntaxfree> I'm in a field were theories are way too fuzzy.
04:30:35 <Japsu> tuukkah: hehe
04:30:39 <Cheery> tuukkah: that's a quite lot from 300 people.
04:30:51 <oklopol> yes, about 6.6%
04:30:54 <oklopol> :)
04:31:22 <roconnor> syntaxfree: those are two different statements
04:31:30 <syntaxfree> I know.
04:31:39 <syntaxfree> One isn't really a logical statement.
04:31:44 <tuukkah> of course irc is the home ground for finns
04:31:45 <syntaxfree> Apparently the second one can be well qualified.
04:31:48 <Japsu> googling for "modal logic" gave me http://plato.stanford.edu/entries/logic-modal/ and it looks somewhat familiar
04:31:49 <lambdabot> Title: Modal Logic (Stanford Encyclopedia of Philosophy)
04:31:58 <Japsu> but dunno if that'll be useful on its own
04:32:26 <roconnor> syntaxfree: doesn't ``A will cause B'' mean ``if we have A then necessarily there will be B''
04:32:44 <Cheery> well, tuukkah, sometimes I feel everybody around would be either from near german or US. :)
04:32:51 <syntaxfree> yes, yes. "Causality" isn't really a well-grounded concept in any system.
04:33:02 <syntaxfree> (or maybe it is, dunno)
04:33:07 <Syzygy-> Yo syntaxfree, roconnor
04:33:08 <velco> heh
04:33:15 * roconnor likes the theory that Causality is a symmetric relation.
04:33:34 <syntaxfree> But I'm fascinated by modal logic because it seems like a good foundation for statements very close to causality statements.
04:33:35 <ookk> dons, i saw your modified nbody, looks really nice!
04:33:53 <syntaxfree> "If we have B then necessarily we have A" is much better than "A and B are correlated".
04:34:06 <syntaxfree> I'm an econometrician; we deal in correlations, basically.
04:34:12 <roconnor> syntaxfree: :)
04:34:19 <Cheery> syntaxfree: so in advance it allows more intuitive statements when relations are fuzzy?
04:34:20 <Syzygy-> Hmmm....
04:34:26 <Syzygy-> I -really- wanna grok synthetic topology.
04:34:33 <syntaxfree> we have a concept called "Granger causality".
04:34:34 <Syzygy-> Gotta find somewhere I can read up on it.
04:34:52 <syntaxfree> Basically, linear regression is a method to find "partial", ceteris paribus correlations.
04:34:57 <ookk> dons, it runs 1s faster on my machine to
04:35:06 <ookk> for n=20M
04:35:48 <syntaxfree> if the correlation of x_{t-1} and y_t is stronger than y_{y-1} with  x_t, for a qualified idea of "correlation" that requires some econometrics to describe well, then we say x "Granger causates" y.
04:36:04 <syntaxfree> but that's not really a good logic concept, it's just built around the tools we have.
04:36:24 <syntaxfree> s/y-1/t-1/
04:37:05 <syntaxfree> I like that the necessity modality maps much better into that Granger causality than causality itself.
04:37:39 <syntaxfree> I mean, what is really being shown with Granger causality is  "If we have B, then the probability of having had A is p"
04:38:06 <syntaxfree> not "A causes B with probability p". That's almost a probabilistic box operator.
04:40:00 <Cheery> hmm, I guess there must be lots of mathematical concepts and ideas which have been used rarely in applications.
04:40:38 <Cheery> at least more and more it starts looking like that.
04:41:22 <syntaxfree> I'd like to be able to add probabilities to S5.
04:41:31 <syntaxfree> but for that I need to learn the system inside out.
04:42:31 <Cheery> It's not really that those concepts are unusable, rather most people do not understand or be capable to understand them.
04:42:52 <Cheery> or ignores them for their own personal dogmas.
04:43:35 <syntaxfree> or for comfort.
04:46:22 <mattam> maybe you should come to ##logic sometime :)
04:46:30 <KD-Misafir922> .D
04:47:06 <Cheery> it fascinates me because it means one actually wouldn't need to invent anything new to make awesome things.
04:48:39 <tuukkah> can i now start to rave about "innovation" ;-)
04:48:43 <mattam> inventing is a bold statement anyway in my opinion.
04:48:51 <Syzygy-> syntaxfree: If x granger causates y with probability p, and y causates z with proabbility q, then what can be said about x to z?
04:48:59 <Syzygy-> Is there some parametrized transitivity going on?
04:49:04 <syntaxfree> Syzygy-: it's not that direct, I'm afraid.
04:49:21 <KD-Misafir922> selm ben türkey ok ???
04:49:29 <KD-Misafir922> .DDDDD
04:49:39 <syntaxfree> Most econometrics fits in data within an equation.
04:49:45 <syntaxfree> say, interest rate and unemployment.
04:50:09 <KD-Misafir922> lan dilinizi bilmiyom bilsem burda k0131z b0131rakmam valla
04:50:10 <KD-Misafir922> ???
04:50:15 <syntaxfree> unemp = a0 + a1*interest + unforeseen
04:50:46 <syntaxfree> classical econometrics makes unforeseen stochastic, and a0 and a1 deterministic parameters. Nowadays there are models where a0 and a1 are stochastic as well.
04:51:17 <syntaxfree> in any case, there is a bunch of ways to qualify that a1 parameter -- whether it's too close to zero to be meaningful, whether it accurately describes variation in unemp, etc. etc.
04:51:26 <Syzygy-> KD-Misafir922: Please stick to something we can read?
04:51:29 <KD-Misafir922> kafan0131za göre aran0131zda 015fimdilik idare edein ben canlar0131m
04:51:38 <KD-Misafir922> öpüldünüz ok
04:51:39 <KD-Misafir922> .)))
04:51:44 <syntaxfree> now, actual econometric models have dozens of variables and often dozens of equations as well.
04:52:04 <syntaxfree> so you really have "partial" correlations subject to the conditions of the Fritsch-Waugh-Lovell theorem.
04:52:11 <syntaxfree> Heck, I'm not making any sense, am I?
04:52:17 <Syzygy-> Not really, no.
04:52:21 <Syzygy-> :)
04:53:06 <syntaxfree> well, it is a whole body of statistical theory and a bunch of research programs on its own.
04:53:13 <syntaxfree> Been studying it for years. Hard to summarize.
04:53:48 <Syzygy-> I'd imagine.
04:54:09 <Syzygy-> It only gets worse when you take into account that I've done my best to completely avoid analysis, statistics and applied mathematics completely so far.
04:54:36 <yip> what do you guys think about Data.Dynamic? should i use it?
04:54:39 <syntaxfree> I enjoy applied statistical analysis.
04:54:52 <syntaxfree> even though it's higher theory that gets my rocks off.
04:54:59 <syntaxfree> anyway, look what I found on wikipedia's external links!
04:55:00 <syntaxfree> http://www.csc.liv.ac.uk/~frank/MLHandbook/
04:55:04 <Axioplase> Syzygy-: your nick reminds me comuter algebra and so on...
04:55:21 <Syzygy-> Axioplase: Ayup.
04:55:30 <Syzygy-> The word you're looking for is 'commutative' btw.
04:55:55 <Axioplase> i wanted to write "computer" :)
04:56:11 <Syzygy-> Ah.
04:56:15 <Syzygy-> Yeah, it's related to that too.
04:56:23 <Axioplase> (don't ask me why.. I just thought of CAS)
04:59:24 <syntaxfree> hmm. apparently there has been research on applications of modal logic to economic game theory.
04:59:39 <syntaxfree> Yacas has one-letter operators.
04:59:49 <syntaxfree> like D(y)(z*y)
04:59:58 <syntaxfree> or S(y)(z*y=g*y)
05:00:54 <ejt> is readIO just return . read ?
05:01:05 <Syzygy-> ?src readIO
05:01:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:01:13 <ejt> tried that ;)
05:01:20 <Syzygy-> ?index readIO
05:01:20 <lambdabot> System.IO, Prelude
05:04:07 <waern> dons, why is your homepage down?
05:11:23 <Syzygy-> So .... before I died, I dug up the source for readIO
05:11:26 <Syzygy-> readIO          :: Read a => String -> IO a
05:11:27 <Syzygy-> readIO s        =  case (do { (x,t) <- reads s ;
05:11:27 <Syzygy->                               ("","") <- lex t ;
05:11:27 <Syzygy->                               return x }) of
05:11:27 <Syzygy->                         [x]    -> return x
05:11:29 <Syzygy->                         []     -> ioError (userError "Prelude.readIO: no parse")
05:11:32 <Syzygy->                         _      -> ioError (userError "Prelude.readIO: ambiguous
05:11:34 <Syzygy-> parse")
05:12:57 <nmessenger> vs...
05:12:59 <ejt> so there must be one complete parse ?
05:13:00 <nmessenger> @src read
05:13:00 <lambdabot> read s = either error id (readEither s)
05:13:51 <waern> has anyone got the Rewriting Haskell Strings paper? I need it, and it's not available online
05:14:01 <kolmodin> hia waern
05:14:04 <kolmodin> it's not online?
05:14:15 <waern> dons univ server seems to be down
05:14:21 <waern> I can't find it anywhere else
05:14:26 <kolmodin> ah
05:14:31 <syntaxfree> interesting. apparently Robert Aumann, the economist, basically reinvented modal logic in the 1970s, unaware that it had been done before.
05:16:47 <waern> kolmodin, anyway. how's code?
05:17:15 <kolmodin> waern: sorry, can't find it
05:17:29 <waern> kolmodin, doh
05:17:34 <kolmodin> waern: so so, can't really deside what to hack on
05:18:18 <kolmodin> waern: dcoutts has a mirror of the paper online on his workstation, don't find the url to that either thogh... :/
05:18:37 <syntaxfree> I'm not sure of what semantic "means" in a logic context.
05:18:39 <syntaxfree> help?
05:19:17 <ibid> context?
05:20:17 <Syzygy-> syntaxfree: Generally speaking, semantics is about meaning, as opposed to syntax, which is about form.
05:20:33 <waern> syntaxfree, truth tables?
05:20:52 <ibid> syntaxfree: what Syzygy- says is true, but could you expand a bit so we can give a better answer?
05:20:53 <Syzygy-> So my guess would be that semantics in logic would be a lot about models for logic
05:21:06 <ibid> that's exactly what it is
05:21:06 <syntaxfree> well, I understand that.
05:21:20 <joelr1> good morning
05:21:22 <syntaxfree> wait. so semantics is the non-"formal" aspects of logic?
05:21:23 <joelr1> dons: ping
05:21:27 <syntaxfree> formal meaning symbol juggling.
05:21:31 <ibid> syntaxfree: nope
05:21:36 <ibid> syntaxfree: well, depends
05:21:44 <ibid> syntaxfree: you can have formal semantics for a logic
05:21:56 <syntaxfree> I mean, logical axioms can be described in a purely formal way.
05:22:06 <syntaxfree> in modal logic, put the box, the diamond and work theorems away.
05:22:18 <syntaxfree> then you can say the box is necessity and the diamond is possibility. Is this the semantics?
05:22:29 <ibid> syntaxfree: not formal semantics
05:22:33 <syntaxfree> hm
05:22:43 <syntaxfree> then I don't know what it is.
05:22:43 <ibid> syntaxfree: informally, you could say that is semantics, though
05:22:55 <ibid> syntaxfree: formal semantics is basically about embedding your logic in another formal system
05:23:05 <syntaxfree> ah.
05:23:15 <syntaxfree> formal system meaning..?
05:23:23 * syntaxfree blushes
05:23:23 <joelr1> does anybody know if hs-plugins can load dynamic libraries?
05:23:28 <ibid> syntaxfree: syntax + manipulation rules
05:23:34 <syntaxfree> oh sure.
05:23:39 <syntaxfree> like the lambda calculus.
05:24:15 <kolmodin> waern: and your code?
05:24:18 <ibid> syntaxfree: yeah. the standard semantics of sentential logic is truth table (well, a formal encoding of them)
05:24:28 <waern> kolmodin, not much lately
05:24:38 <syntaxfree> oh, okie.
05:24:44 <ibid> syntaxfree: for first-order logic, you create a first-order model and a mapping from the logic symbols to the model
05:25:04 <syntaxfree> I understand what first-order logic is, but not what a  "model" is.
05:25:11 <kolmodin> waern: I'd like to get cabal to play well with preprocessors
05:25:17 <syntaxfree> it's just a mathematical structure containing FOL?
05:25:28 <syntaxfree> like truth table is for propositional logic?
05:26:19 <ibid> syntaxfree: a first-order model is a nonempty set of individuals and a set of relations and properties of them (ie. subsets of the set of individuals and subsets of its cartesian products with itself)
05:26:34 <syntaxfree> ah, yes. a maethematical model.
05:26:36 <waern> kolmodin, right
05:26:54 <KD-Misafir922> alemin güzel insanlar0131
05:26:56 <Syzygy-> syntaxfree: http://en.wikipedia.org/wiki/Semantics_of_logic
05:26:57 <lambdabot> Title: Semantics of logic - Wikipedia, the free encyclopedia
05:26:58 <kolmodin> waern: ie, proper dependency analysys (preprocessing files in the right order, etc), preprocessor chaining, a new field in the .cabal that states which preprocessors and versions you're using
05:26:59 <KD-Misafir922> ben kac0131yom
05:27:01 <syntaxfree> cool. thanks.
05:27:09 <KD-Misafir922> size iyi sohbetler
05:27:11 <KD-Misafir922> ok
05:27:15 <KD-Misafir922> .))
05:27:17 <Syzygy-> KD-Misafir922: Would you PLEASE stop talking turkish in here.
05:27:26 <ibid> syntaxfree: obviously, this is all relative to some other formal system. "absolute" semantics, if it exists, cannot be formal in this sense
05:27:27 <waern> kolmodin, as a step towards cabalizing gtk2hs?
05:27:38 <kolmodin> waern: that would help brining larger projects to use cabal. even my tiny hdbus can't be compiled with cabal
05:27:42 <kolmodin> waern: exactly
05:27:49 <syntaxfree> of course.
05:27:50 <syntaxfree> I see.
05:28:09 <waern> kolmodin, can gtk2hs be built with ghc --make, after such a preprocess step?
05:29:16 <kolmodin> waern: not at the moment. gtk2hs is many smaller libraries. you'd have to build each of them and install before compiling the next. I think
05:29:51 <waern> kolmodin, aha.. should those be cabalized then?
05:30:20 <kolmodin> waern: yeah, gtk2hs has to be split up into those modules, and then each of them cabalized with the proper dependencies
05:30:35 <kolmodin> then cabal-install should be able to pull and compile in the right order
05:30:55 <waern> okay... So the direction is not to move away from ghc --make then
05:31:28 <waern> that's good, because haddock.ghc can only process libs that can be built with --make
05:31:33 <kolmodin> waern: kind of, we'd like cabal to handle those details
05:32:22 <waern> I wonder if the base can be built with --make after a preprocess step
05:32:30 <kolmodin> cabal will still internaly use --make
05:32:33 <waern> the base library, I mean
05:33:35 <waern> Right now haddock.ghc can't process nor link to the base library because of this issue
05:33:50 <kolmodin> ok
05:34:28 <waern> If you manage to build base with the simple build system, you're my hero :)
05:34:48 <kolmodin> so what was the issue of older apps not beeing able to be built by your tool?
05:34:51 <kolmodin> heh :)
05:35:02 <waern> kolmodin, that's the issue
05:35:10 <kolmodin> ah, ok :)
05:35:33 <kolmodin> that's why you want to have two tools, haddock and haddock.ghc
05:35:34 <kolmodin> ?
05:35:38 <kolmodin> atm
05:35:49 <waern> yep
05:35:54 <kolmodin> right, gotcha
05:36:10 <waern> the ndp people are going to use haddock-ghc
05:36:14 * emk thinks that probability monads are cool
05:36:18 <waern> and they need it quite soon
05:36:24 <kolmodin> ndp?
05:36:32 <waern> nested data parallellism
05:36:54 <kolmodin> cool
05:36:55 <emk> wearn: Ooh, I can't wait for ndp in Haskell.
05:37:00 <emk> That's going to be really slick.
05:37:23 <waern> emk, they're planning to release it soon I think
05:37:38 <malebria> @hoogle FilePath -> String -> IO ()
05:37:38 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
05:37:39 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
05:37:41 <emk> waern: Is it likely to wind up in standard GHC?
05:37:45 <Igloo> waern: What problem are you having building base with --make?
05:37:48 <emk> Or will I need a special compiler?
05:38:00 <Igloo> waern: I've built it with cabal, which uses --make, in the past (although you need the HEAD, not 6.6, IIRC)
05:38:42 <kolmodin> Igloo: looks like you're his hero :)
05:38:43 <waern> Igloo, I don't know, I just noticed that it isn't cabalized, and thought it's because of the GHC bits need a more sophisticated build process
05:38:52 <waern> but maybe that was just a false assumption :)
05:39:16 <kolmodin> might just be very old :)
05:40:03 <waern> emk, dunno...
05:40:35 <emk> Well, I shall continue to wait impatiently, then. ;-)
05:40:50 <kolmodin> http://research.microsoft.com/Users/simonpj/papers/ndp/ndp.pdf
05:40:56 <kolmodin> neat
05:44:35 <malebria> Is there a way to make writeFile from ByteString use Binary mode (like openBinaryFile)?
05:45:47 <waern> kolmodin, what are you doing today? want to have a mini-hacathon?
05:46:33 <kolmodin> waern: that could be fun
05:46:55 <araujo> morning
05:46:57 <emk> The Haskell standings in the Shootout have improved tremendously on all the string benchmarks...
05:47:02 <kolmodin> morning araujo
05:47:09 <araujo> kolmodin!!!
05:47:12 <kolmodin> :D
05:47:21 <araujo> :-)
05:47:49 <TuringTest> malebria: hPut or putString is a binary dump of the ByteString contents
05:48:06 <waern> kolmodin, "could"? :)
05:48:15 <kolmodin> :)
05:48:20 <kolmodin> "would"
05:48:33 <waern> okay, your place or mine? :)
05:49:03 <kolmodin> I haven't been to your new place
05:49:14 <waern> I've never been to your place =)
05:49:24 <waern> but oh well :)
05:49:29 <waern> I'm in NC now
05:49:34 <kolmodin> ah
05:49:42 <kolmodin> that's why you have an IRC client :)
05:49:46 <waern> hehe
05:50:09 <kolmodin> I'm not sure what to hack on
05:51:19 <waern> well, I'll go home now in any case
05:51:41 <kolmodin> ait
05:51:52 <kolmodin> I have to do some.. um.. cleaning
05:52:01 * waern too
05:52:25 <kolmodin> usually save that to the weekends :D
05:53:18 <waern> brb
05:55:23 <malebria> TuringTest: but does it uses CRLF or plain LF on windows?
05:55:37 <malebria> TuringTest: This is the difference between binary mode..
05:55:52 <TuringTest> malebria: Depends on what is inside the Bytestring .  There is no translation of the line endings
05:56:42 <malebria> TuringTest: hum... nice. Cause in Prelude.openFile there's this translation.
05:56:46 <TuringTest> If you use the putStrLn  functions you get an extra "newlin character"
05:57:58 <TuringTest> malebria: Where is that openfile documented?
05:58:33 <TuringTest> Ah.  System.IO.openFile
05:58:36 <malebria> TuringTest: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AopenBinaryFile
05:58:54 <TuringTest> Not in Prelude.
05:59:21 <malebria> Sorry.
06:01:20 <TuringTest> The ByteString library's functions do no translation.
06:03:45 <SamB> ... which is kinda what you'd expect from the name, isn't it?
06:04:23 <Syzygy-> ?index ByteString
06:04:23 <lambdabot> bzzt
06:04:27 <malebria> Yes, this is good, I don't want any translations.
06:04:31 <Syzygy-> ?where ByteString
06:04:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
06:09:08 <JKnecht> @version
06:09:09 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
06:09:09 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:56:46 <earthy> hm. that's interesting.
06:56:59 <earthy> I can't seem to find the unsw dns servers
07:10:29 <chessguy> 'morning haskellers
07:12:25 <chessguy> ?losers
07:12:25 <lambdabot> Maximum users seen in #haskell: 322, currently: 299 (92.9%), active: 32 (10.7%)
07:15:00 <kfish> ?winners
07:15:00 <lambdabot> Unknown command, try @list
07:15:06 <kfish> :-(
07:15:08 <xic> what type do i want for a date + time?
07:15:25 <chessguy> ?time
07:15:26 <lambdabot> Local time for chessguy is Sun Feb 11 10:13:12
07:15:44 <nmessenger> @hoogle time
07:15:44 <lambdabot> System.Time :: module
07:15:44 <lambdabot> Time :: module
07:15:44 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
07:15:54 <nmessenger> @docs System.Time
07:15:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
07:16:41 <ookk> dons, i removed the "inc" function and it runs faster
07:41:22 <augustss> yo!
07:41:27 <malebria> http://www.abridgegame.org/repos/darcs-unstable/Lock.lhs
07:41:50 <malebria> In the writeToFile function, there's a `catchall` that I can't understand very well.
07:41:56 <malebria> It's in the end of the file.
07:42:33 <augustss> @seen dons
07:42:33 <lambdabot> dons is in #haskell. I last heard dons speak 3h 18m ago.
07:42:42 <malebria> Is indentation making the difference there?
07:45:06 <vincenz> re
07:51:22 <fasta> If I do let a = <some _huge_ value> in <some function using a in multiple places>, will these be shared?
07:51:53 <fasta> I am currently assuming they are.
07:52:08 <vincenz> yes
07:52:19 <vincenz> I assume you mean
07:52:21 <Igloo> It's not guaranteed by the language, but probably
07:52:23 <vincenz> let a = < some long calcultion>
07:52:38 <fasta> vincenz: I care about memory here
07:53:01 <fasta> Igloo: ok, assuming GHC.
07:54:20 <chessguy> hmm
07:54:23 <fasta> let a = array (1,100000) (zip [1..] [1..]) in replicate 10000 a
07:54:30 <fasta> > let a = array (1,100000) (zip [1..] [1..]) in replicate
07:54:30 <fasta>               10000 a
07:54:35 <lambdabot>  Add a type signature
07:54:57 <chessguy> i want to run a stateful computation some number of times, using the new state each time. how can i go about this?
07:55:22 <fasta> chessguy: runState?
07:55:29 <fasta> chris2: just map it
07:55:41 <fasta> chessguy: just map it.
07:55:52 <chessguy> but runstate requires me to give it the new state each time
07:56:21 <fasta> So?
07:56:30 <fasta> You remember the state, call it s.
07:56:47 <fasta> Then you run within the state monad runState with that same s a couple of times.
07:57:03 <fasta> chessguy: is this what you mean?
07:57:21 <fasta> chessguy: I did this before in another program.
07:57:51 <chessguy> so like map (const $ runstate {s <- get; statefulComputation}) [1..n]
07:57:52 <chessguy> ?
07:58:01 <Igloo> Is replicateM_ what you want?
07:58:25 <chessguy> Igloo, if i knew what i wanted, there wouldn't be much point in asking :)
07:58:31 <vincenz> just replicate and sequence
07:58:37 <chessguy> ?hoogle replicateM_
07:58:37 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
07:58:45 <vincenz> @type sequence
07:58:46 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:59:34 <chessguy> well, i need to collect a list of the results. i didn't say that
07:59:43 <vincenz> > runState ((sequence_ . replicate 10  $ (modify (+1))) >> get) 0
07:59:44 <Igloo> replicateM then?
07:59:46 <lambdabot>  (10,10)
07:59:59 <chessguy> ?hoogle replicateM
08:00:00 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
08:00:00 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
08:00:23 <chessguy> hmm, that might be it
08:00:42 <fasta> chessguy: oh, right, using the _new_ state.
08:00:56 <chessguy> yes
08:00:57 <fasta> chessguy: that would be a fold then
08:01:14 <chessguy> eh?
08:01:21 <chessguy> i need a list when i'm done
08:01:22 <allbery_b> with intermediate results?  scan maybe
08:01:23 <vincenz> chessguy:
08:01:24 <vincenz> > runState ((sequence_ . replicate 10  $ (modify (+1))) >> get) 0
08:01:26 <lambdabot>  (10,10)
08:01:42 <yip> why isn't ClockTime Typeable?
08:01:43 <vincenz> oh a list?
08:01:45 <chessguy> i think replicateM is what i want
08:01:54 <vincenz> > runState (sequence . replicate 10  $ (modify (+1))) 0
08:02:31 <vincenz> @bot
08:02:39 <vincenz> is the bot down?
08:03:27 <chessguy> hmm, wierd
08:03:29 <chessguy> > runState (replicateM 10 $ (modify (+1))) 0
08:03:29 <chessguy> Loading package mtl-1.0 ... linking ... done.
08:03:29 <chessguy> ([(),(),(),(),(),(),(),(),(),()],10)
08:03:53 <vincenz> chessguy: ping?
08:04:01 <chessguy> vincenz, i'm here
08:04:02 <paolino> execState
08:04:07 <vincenz> ah ok, thought I was lagged
08:04:12 <vincenz> > runState (sequence . replicate 10  $ (modify (+1) >> get)) 0
08:04:18 <vincenz> modiy returns ()
08:04:25 <chessguy> paolino, no, i want a list of results
08:04:47 <vincenz> chessguy: try the second
08:04:51 <paolino> then evalState
08:04:55 <chessguy> (in this case, [1,2,3,...])
08:05:05 <vincenz> paolino: runState does both
08:05:11 <chessguy> vincenz, send what?
08:05:13 <paolino> well tose are the states
08:05:15 <chessguy> second
08:05:15 <vincenz> > runState (sequence . replicate 10  $ (modify (+1) >> get)) 0
08:05:18 <vincenz> chessguy: that one
08:05:42 <chessguy> ah, that worked
08:05:57 <chessguy> wait
08:06:01 <chessguy> that's not what i want
08:06:11 <chessguy> i don't want intermediate states
08:06:13 <paolino> :)
08:06:16 <chessguy> i want the results of each action
08:06:20 <chessguy> in the list
08:06:50 <chessguy> which means replicateM was right after all
08:07:57 <chessguy> runState (replicateM 10 $ (modify (+1))) 0 should do what i want
08:08:12 <vincenz> replicateM == sequence . replicate
08:08:30 <vincenz> well not quite
08:08:45 <vincenz> \n a -> replicateM n a == \n a -> sequence . replicate n $ a
08:09:53 <paolino> those actions are evaluating all to ()
08:10:18 <chessguy> well, all the actions are returning (), yes
08:10:23 <paolino> :t modify
08:10:27 <dancor> i'm dealing with an rpc system that allows versioning so fcn call args can actually no longer be supplied
08:10:30 <chessguy> the actual actions i'm using won't be
08:10:32 <paolino> ok
08:10:39 <dancor> should i use Maybe for everything?
08:10:51 <chessguy> that's what threw me off when i saw [(),(),...]
08:10:59 <dancor> or would default values (int = 0, etc) be more weildy?
08:18:59 <chessguy> woohoo!
08:19:01 <chessguy> it typechecks!
08:19:26 <rahikkala> ship it!
08:24:34 <augustss> don't run it!  that can only lead to disappointment.
08:24:44 <chessguy> lol
08:24:48 <chessguy> it's not ready to run yet :)
08:26:02 <ndm> @where nofib
08:26:32 <ndm> @where lambdabot
08:26:57 <Igloo> http://darcs.haskell.org/nofib/
08:27:21 <ndm> @botsnack Igloo
08:27:33 <Igloo> :-)
08:27:49 <chessguy> @undo do { s<- get; return $ fst $ runState $ replicateM n $ (randomProgram 0) s; }
08:27:55 <chessguy> oh, duh
08:30:13 <paolino> mmh, looks like you're complicating things
08:30:57 <chessguy> paolino, i'm doing something else now
08:31:27 <paolino> if the outside state is the same that the inside one , why keep the states nested ?
08:31:54 <chessguy> hmm?
08:32:28 <allbery_b> getting a state and doing an inner runState with it?
08:33:07 <chessguy> well, randomProgram is of type State ProgramState Program
08:33:18 <paolino> that expression has type StateT s (State s) a  or something
08:33:58 <paolino> s == ProgramState
08:34:21 <chessguy> hmm. but don't i need to pass randomProgram the current state?
08:35:04 <paolino> it can use get to get it
08:35:17 <ookk> @src pokeArray
08:35:27 <ookk> @where pokeArray
08:35:32 <allbery_b> bot dead :(
08:35:37 <chessguy> so i should use evalState instead of runState?
08:35:39 <lispy> oh nos
08:35:50 * lispy weeps at the loss of lambdabot
08:35:55 <paolino> that's not my point
08:36:06 <chessguy> paolino, i'm trying to understand
08:36:21 <allbery_b> you're already *in* a state monad, runState is unnecessary
08:36:24 <lispy> chessguy: you can get at the state from inside the monad
08:36:37 <paolino> I think nested states are necessary when the outside state is "bigger"  then the inside one
08:36:58 <chessguy> well, they are the same
08:37:21 <paolino> so you don't need the outside shell
08:37:37 <chessguy> so i should do...what, replicate n (randomProgram 0) instead?
08:38:10 <paolino> evalState (replicateM randomProgram) s
08:38:33 <paolino> evalState (replicateM randomProgram 0) s
08:38:43 <paolino> uff
08:38:59 <paolino> evalState (replicateM $ randomProgram 0) s --must sleep next night
08:39:19 <chessguy> but what's s?
08:39:34 <lispy> initial state, right?
08:39:59 <chessguy> well then i still need the do and the s <- get;
08:40:03 <paolino> is it the 0 ?
08:40:21 <chessguy> no
08:40:26 <chessguy> 0 is a paremeter
08:40:28 <hpaste>  fasta pasted "Keeping the spirit of a real "forever" loop" at http://hpaste.org/451
08:40:28 <paolino> inside randomProgram
08:40:29 <chessguy> to randomProgram
08:40:32 * allbery_b thoroughly confused as to what chessguy is trying to do
08:40:33 <lispy> type evalState
08:40:34 <lispy>  forall a s. State s a -> s -> a
08:41:06 <allbery_b> you are obviously in a state monad.  you are, internally, doing a runState with the *same* state.
08:41:07 <fasta> Could anyone look at the paste? I am having trouble to express a "forever" loop.
08:41:18 <lispy>  forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
08:41:22 <lispy> (that's replicateM)
08:41:23 <allbery_b> this makes no sense.
08:41:37 <paolino> randomProgram = do {s<- get; put $ dosomethingwith s}
08:42:32 * lispy would need to see more of chessguy's code to help...but needs to leave soon
08:42:48 <paolino>  randomProgram x = do {s<- get; modify s; return $ f x s} -- probably
08:43:17 <chessguy> hmm
08:43:31 <chessguy> i can pastebin my code if you'd like
08:44:07 <lispy> chessguy: it would be a good idea, but like i said, I can't help much because i'm leaving in 3 minutes
08:44:16 <paolino> do that
08:44:20 <chessguy> but that might make it worse :)
08:44:25 <allbery_b> see, if you're already *in* the same state monad, you can just r <- computation.  or r <- replicateM 20 $ computation
08:44:57 <paolino> yep worse is a never ending story
08:46:26 <allbery_b> fasta: not enough information.  in particulalr, not clear why you can't arrange for the callCC to let you throw () instead of the current state of an unspecified state monad
08:47:28 <hpaste>  chessguy pasted "the beginnings of a genetic programming approach to symbolic regression" at http://hpaste.org/452
08:47:49 <fasta> allbery_b: The idea is that callCC should return the answer.
08:48:18 <fasta> allbery_b: I will see whether I can do without.
08:48:20 <chessguy> ugh, 95 lines of code already
08:48:44 <chessguy> that's like 950 lines in another language
08:49:28 <lispy> chessguy: i think you misspelled Regression (unless that's a word and i'm junt not familiar with it)
08:49:36 <fasta> Heh, I hope you are not serious
08:50:01 <chessguy> to the best of my knowledge it's spelled right
08:50:16 <chessguy> linear regression?
08:50:22 <lispy> oh you're right
08:50:24 <paolino> randomPrograms n = replicateM n (randomProgram 0)i
08:50:26 <paolino> is my guess
08:50:28 <lispy> not sure what i was thinking
08:51:03 <lispy> gotta go, what you have looks fine
08:51:26 <paolino> but randomProgram should put somewhere
08:51:47 <chessguy> paolino, ah, put the new state you mean?
08:51:55 <paolino> yep
08:52:09 <Le-Chuck_IT1> Hi there
08:52:11 <chessguy> ok, that makes sense
08:52:40 <chessguy> i imagine eval should also
08:52:56 <paolino> no
08:53:05 <Le-Chuck_IT1> I am desperately struggling with google to find a categorial generalization of the power-set functor, and, guys, you're my last resort :)
08:53:07 <paolino> not with those signatures
08:53:10 <chessguy> why not?
08:53:13 <yip> how can i make Data.Time.LocalTime.LocalTime an instance of Typeable?
08:53:48 <paolino> all those functions are returning in the State ProgramState
08:54:12 <chessguy> all which functions?
08:55:04 <paolino> they live in the same "flow"
08:55:28 <Le-Chuck_IT1> eheh my question will stay unanswered also for today
08:55:37 <Brandon`> lol
08:55:38 <paolino> those with State ProgramState a  signature
08:56:20 <chessguy> or b -> State ProgramState a ?
08:56:56 <paolino> randomPrograms, randomProgram,eval
08:57:10 <chessguy> ok
08:57:21 <chessguy> so then why does randomProgram need to put if the others don't
08:57:34 <Le-Chuck_IT1> bye all and have fun
08:57:48 <paolino> and getRand I suppose
08:57:57 <fasta> Cool, a function with a type that fills three screens. :(
08:58:07 <fasta> A working function, though.
08:58:11 <fasta> :)
08:58:18 <paolino> it was a guess
08:58:33 <dcoutts> tuukkah, got any more details on how/why the new gtk2hs failed to build in debian on ia64 and alpha ?
08:58:47 <allbery_b> yip: looking at the docs for Data.Typeable I think I see how it would be done, but not certain
08:59:07 <astrolabe> Le-Chuck didn't wait very long
08:59:44 <Igloo> dcoutts: Have you seen http://buildd.debian.org/fetch.cgi?&pkg=gtk2hs&ver=0.9.10.5-1&arch=alpha&stamp=1171056036&file=log and http://buildd.debian.org/fetch.cgi?&pkg=gtk2hs&ver=0.9.10.5-1&arch=ia64&stamp=1171052755&file=log ?
08:59:48 <tuukkah> dcoutts, the logs are here: http://buildd.debian.org/build.php?&pkg=gtk2hs
08:59:53 <dcoutts> cheers
09:00:23 <chessguy> paolino, so now you're saying p=randomProgram shouldn't put somewhere?
09:00:45 <allbery_b> you'd have to define a typeOf instance which used mkTyCon and mkTyConApp to build the TypeRep
09:00:51 <paolino> (trying to understand the all story)
09:01:09 <chessguy> paolino, it's not done yet
09:01:41 <chessguy> paolino, know anything about genetic algorithms?
09:01:55 <paolino> yes
09:02:08 <chessguy> ok, well this is genetic programming. similar idea
09:02:13 <paolino> something I like
09:02:21 <chessguy> each member of the population is a program instead of a solution
09:02:43 <chessguy> in this case, a program to compute a value for some unknown function
09:02:44 <sorear> tell fodder
09:02:57 <chessguy> g'morning, sorear
09:03:30 <chessguy> sorear, got an extra lambdabot lying around?
09:04:36 <dcoutts> Igloo, do you know what the "Error: file number 2 already allocated" is all about on ia64?
09:04:47 <paolino> I start focusing
09:04:52 <Igloo> No idea
09:04:54 <paolino> so yes
09:05:02 <Igloo> Never seen it before
09:05:04 <dcoutts> Igloo, as for the alpha, there's not much to be done except not building those functions that break GHC's FFI.
09:05:19 <paolino> you are doing right
09:05:33 <chessguy> ok
09:05:34 <Igloo> Yup, and fixing GHC for a future release
09:05:41 <paolino> they are nested computations
09:05:52 <chessguy> and randomPrograms n = replicateM n (randomProgram 0)
09:05:57 <dcoutts> Igloo, oh you think that's fixable?
09:06:04 <Igloo> dcoutts: Actually, presumably you could write a C wrapper and pass it a pointer to a struct or something
09:06:08 <sorear> @bot
09:06:09 <sorear-lambdabot> :)
09:06:15 <Igloo> Well, I assume it is, but I haven't looked
09:06:20 <dcoutts> Igloo, yeah, perhaps. I recall we used to have the same problem on sparc.
09:06:45 <chessguy> @type replicateM 3
09:06:51 <sorear-lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
09:06:54 <paolino> wait I'm on the singular one
09:07:06 <chessguy> ok
09:09:05 <dcoutts> Igloo, wow, it built on arm!? I'm impressed. I didn't know ghc worked on arm.
09:09:13 <e_e_coli> @paste
09:09:13 <sorear-lambdabot> Haskell pastebin: http://hpaste.ath.cx:8000/new
09:09:45 <hpaste>  e_e_coli pasted "Type troubles" at http://hpaste.org/453
09:09:58 <e_e_coli> Hello. I'm doing Hudak
09:10:11 <e_e_coli> and I'm punding my head aganst type inference problems
09:10:14 <Igloo> Well, as of 6.6 it does  :-)
09:11:03 <e_e_coli> In the code I just pasted, it seems to be inferring that dt is an Int i nthe definition of regularPolygon
09:11:08 <e_e_coli> but why?
09:11:32 <dcoutts> Igloo, nice.
09:12:04 <chessguy> @type 2.0 * pi / (3::Int)
09:12:06 <sorear-lambdabot>     No instance for (Floating Int)
09:12:06 <sorear-lambdabot>       arising from a use of `pi' at <interactive>:1:6-7
09:12:10 <paolino> mmhh, randomPrograms n = gets $ runState (replicateM n $ randomProgram 0)
09:12:50 <allbery_b> regularPolygon's first argument is an Int, you're using it in 2.0 * pi / n
09:12:50 <paolino> does it typecheck ?
09:13:06 <chessguy> @type gets $ runState
09:13:09 <sorear-lambdabot> forall (m :: * -> *) s a. (MonadState (State s a) m) => m (s -> (a, s))
09:13:31 <allbery_b> try 2.0 * pi / (fromInteger n)
09:13:37 <e_e_coli> already did; thank you very much
09:13:44 <e_e_coli> chessguy++
09:13:44 <paolino> I'm not sure everything is fair with that state logic, anyway
09:14:05 <allbery_b> ah right, missed chessguy's response
09:14:10 <e_e_coli> that's ok
09:14:19 <e_e_coli> his was "leading"; yours was explicit
09:14:26 <chessguy> eh? what'd i do?
09:14:28 <e_e_coli> for some folks leading is good
09:14:32 <e_e_coli> :)
09:14:47 <e_e_coli> now I have to figure out why my call to "points" never terminates
09:14:57 <chessguy> paolino, that doesn't typecheck
09:14:57 <paolino> randomPrograms n = gets $ evalState (replicateM n $ randomProgram 0)
09:15:27 <chessguy> that does though
09:15:28 <e_e_coli> ah
09:15:33 <chessguy> ?type gets
09:15:35 <sorear-lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
09:16:27 <e_e_coli> My main problem in learning haskell is that kind of type error, where I cannot understand how the error message relates to the error. Is this a common failing in learning Haskell, or is it just my own problem?
09:16:27 <paolino> you are aware you are using the same thread of rng in every path ?
09:16:29 <chessguy> paolino, why is the gets needed?
09:16:59 <chessguy> paolino, that's fine, as long as the rng is getting updated on every call to it
09:17:18 <paolino> it's like get, just don't want to type dp { ...
09:17:18 <paolino> *do
09:17:55 <chessguy> oh, so it's equivalent to do { s<-get; ... } --?
09:18:32 <ndm> get >>= \s -> ....
09:18:46 <chessguy> ndm, same thing :)
09:19:01 <ndm> indeed :)
09:19:21 <paolino> gets f = do {s <- get;return $ f s}
09:20:27 <paolino> gets f = get >>= return.f
09:20:32 <qwr> e_e_coli: it takes some time to get used. but type signatures usually localise the "moving" errors caused by type inference
09:20:51 <chessguy> so many ways to say the same thing :)
09:21:10 <paolino> @pl \f -> get >>= return.f
09:21:11 <sorear-lambdabot> (get >>=) . (return .)
09:21:13 <benja_> I'm trying to get Cabal to run preprocessors (c2hs and a custom one), but I can't figure out how to do it. anyone know?
09:21:21 <chessguy> lol
09:21:27 <kowey> e_e_coli: it often helps to add type annotations, just to see if your expectations match the compiler's
09:21:28 <benja_> (I put in a hook for the custom one in the Setup.hs file)
09:21:38 <chessguy> @pl \f -> gets f
09:21:38 <sorear-lambdabot> gets
09:21:40 <kowey> that also helps to 'localise' the errors
09:22:12 <paolino> I wonder if your code is logically correct
09:22:15 * qwr actually meant type annotations by signatures...
09:22:21 <chessguy> paolino, how so?
09:22:37 <kowey> (whoops, didn't see qwr's response :-) )
09:23:56 <allbery_b> e_e_coli:  points x theta = ... : (points (n - 1) ...)
09:26:11 <paolino> nm, I get back to my monster for a while , darcs it when you have a running version,if you like
09:26:42 <chessguy> paolino, i don't have a server, but i'll try to get it to someone who does. i'd like to turn it into a whole GP framework
09:26:45 <chessguy> eventually
09:27:21 <yip> this is kind of funny: http://weblog.raganwald.com/2007/02/program-in-java-you-must-be-joking.html
09:28:47 <chessguy> yip, that URL doesn't typecheck for me
09:28:54 <chessguy> i mean, doesn't work :)
09:29:50 <paolino> ask lemmih
09:30:10 <paolino> he's been kind offering space to me
09:30:20 <chessguy> ok
09:30:33 <chessguy> it's still a long ways from working anyway :)
09:33:29 <paolino> then I suggest stop coding complexities and try to run it with what is there, then you can still kick me if it's correct :P
09:33:56 <yip> chessguy: are you sure? it works for me
09:34:14 <chessguy> ah, now it does
09:34:27 <chessguy> paolino, i'm not doing any complexities yet
09:35:14 <chessguy> i suppose i could try generating some random programs now
09:38:36 <chessguy> oh, that's a good one :)
09:40:32 <paolino> mmh I have this error
09:40:33 <paolino> Urk! Inventing strangely-kinded void TyCon:
09:40:33 <paolino>     ZCt{tc a7BC}
09:40:33 <paolino>     (* -> *) -> * -> *
09:40:33 <paolino> who offers more ?
09:40:48 <syntaxfree> wow.
09:40:56 <syntaxfree> new post. not a rant, or a quick hack, too ; ) http://syntaxfree.wordpress.com/2007/02/11/making-a-monad-martin-erwigs-dist/
09:40:57 <chessguy> lol
09:41:09 <chessguy> ?google strangely-kinded void TyCon
09:41:13 <sorear-lambdabot> http://hackage.haskell.org/trac/ghc/ticket/959
09:41:13 <sorear-lambdabot> Title: #959 (Debugging info(?) leaks out: &#34;Urk! Inventing strangely-kinded void TyC ...
09:42:09 <chessguy> i'm trying to remember, i got that message the other week when i was doing something
09:42:16 <chessguy> it's just a warning, i think
09:42:47 <paolino> I erased it with an -fno-monomor..blah
09:43:37 <syntaxfree> "Urk!" is a GHC error message?
09:44:09 <chessguy> yes, believe it or not
09:44:18 <syntaxfree> cool!
09:46:50 <paolin1> :t RWST
09:46:52 <sorear-lambdabot> Not in scope: data constructor `RWST'
09:47:07 <paolin1> @hoogle RWST
09:47:07 <sorear-lambdabot> Control.Monad.RWS.RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
09:47:08 <sorear-lambdabot> Control.Monad.RWS.RWST :: newtype RWST r w s m a
09:47:08 <sorear-lambdabot> Control.Monad.RWS.evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
09:48:52 <paolin1> @hoogle runRWST
09:48:53 <sorear-lambdabot> Control.Monad.RWS.runRWST :: RWST r w s m a -> (r -> s -> m (a, s, w))
09:49:56 <Heffalump> syntaxfree: it probably helps if you imagine SPJ saying it :-)
09:50:15 <syntaxfree> Hahaha
09:51:43 <chessguy> ?t execState
09:51:43 <sorear-lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:51:52 <chessguy> @type execState
09:51:54 <sorear-lambdabot> forall s a. State s a -> s -> s
09:52:01 <chessguy> @type evalState
09:52:03 <sorear-lambdabot> forall s a. State s a -> s -> a
09:52:11 <chessguy> i can never remember which is what :(
09:53:46 <allbery_b> eval says value to me :)
09:56:24 <paolin1> @pl let f (a,b,c) = (a,b) in map f
09:56:25 <sorear-lambdabot> (line 1, column 11):
09:56:25 <sorear-lambdabot> unexpected ","
09:56:25 <sorear-lambdabot> expecting letter or digit, operator or ")"
09:56:25 <sorear-lambdabot> ambiguous use of a non associative operator
09:57:31 <paolin1> mah
10:03:39 <allbery_b> @ghc
10:03:39 <sorear-lambdabot> ghc says: Can't splice the polymorphic local variable
10:06:34 <malverian> If I want a function that works with float and integer values, is "Fractional" my best bet?
10:08:41 <ndm> malverian: Num
10:08:54 <allbery_b> @instances Fractional
10:08:56 <sorear-lambdabot> Double, Float
10:09:03 <ibid> depends on what you want to do with the number. Num is the most general
10:09:22 <malverian> Let me re-read the section on types :-P
10:09:24 <malverian> Thanks.
10:09:48 <ookk> open ghci and do :i Fractional, :i Num, :i Integral
10:10:10 <ookk> and see which behaviour you need
10:13:53 <malverian> ookk: Well.. I'm trying to create a polymorphic function for determining area.. but I only want it to work for numbers. So I initially thought "area :: Num a => a -> a -> a" (but that isn't valid)
10:14:24 <ookk> malverian, area of what?
10:14:27 <malverian> Obviously I don't want someone to do foo <- area "string1" "string2"
10:14:33 <malverian> ookk: Well, in this case a triangle.
10:14:44 <malverian> ookk: It's very simple, I'm just trying to grasp syntax right now :-P
10:14:57 <ookk> malverian, well then a -> a -> a is not what you want
10:15:14 <ookk> what are the arguments?
10:15:17 <ookk> base and height?
10:15:24 <malverian> base and height
10:15:25 <malverian> Yes.
10:15:34 <ookk> if base and height are integers, the area doesnt have to be
10:15:42 <ookk> you a has to be float
10:16:32 <malverian> ookk: Oh.. because 1 arg could be int and one could be float.
10:16:57 <malverian> Well, I ended up settling on "area :: Fractional a => a -> a ->a" which works fine.
10:17:14 <malverian> But it always returns a float even if base/height are Int
10:17:20 <TuringTest> Base == 1 and Height == 1 Then Area is 0.5 which is not an integer
10:17:25 <ookk> malverian, then you have to do: area h b = (fromIntegral h)*(fromIntegral b)/2
10:17:40 <ookk> and area :: (Integral a, Integral b) => a -> b -> Double
10:17:49 <malverian> Ah.
10:17:56 <ookk> and area :: (Num a, Num b) => a -> b -> Double
10:18:00 <ookk> i think that is better
10:18:33 <ookk> or area :: (Num a, Num b, Fractional c) => a -> b -> c
10:19:56 <TuringTest> area :: (Real a, Real b , Fractional c) => a->b->c
10:24:17 <paolino> is there a Monoid constraint on Writer
10:24:36 <paolino> ?
10:25:26 <paolino> @instances Monoid
10:25:28 <sorear-lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
10:25:47 <bringert> paolino: yes
10:25:54 <bringert> class (Monoid w, Monad m) => MonadWriter w m | m -> w where
10:26:23 <sorear> hello
10:26:56 <paolino> my bad,i  must vim up everything again
10:28:43 <paolino> when types get big, haskell is a mess
10:29:08 <paolino> uhm, life is a mess anyway
10:44:29 <paolino> type Net s h g r q e w = RWST (Env r q e) w (NetState s h) (State g) ---where each arg has at least a constraint :/
10:44:34 <paolino> evolve :: (Monoid w, Metrics s, Scheduler h,RandomGen g, Collect r,Tag q,Refine e) => Net s h g r q e w ()
10:44:36 <paolino> is this normal in haskell ?
10:45:00 <ibid> define normal
10:45:08 <ibid> i've seen that kind of code very rarely
10:46:11 <ibid> but yeah, the more specialized our typeclasses become, the more complex our constraints become :)
10:48:28 <ddarius> paolino: You can collect multiple ones into a single typeclass if you'd like.
10:50:21 <ddarius> paolino: Also it's not uncommon to provide more specialized variants for actual use, e.g. Parsec's Parser type v. it's GenParser type.
10:51:19 * ddarius should have been paying attention.
10:52:40 <ddarius> [12:47] <ddarius> paolino: You can collect multiple ones into a single typeclass if you'd like.
10:52:40 <ddarius> [12:49] <ddarius> paolino: Also it's not uncommon to provide more specialized variants for actual use, e.g. Parsec's Parser type v. it's GenParser type.
10:53:55 <newsham> what's exception :: GhcException ?
10:53:57 <dino-> I have something I'm installing that uses Cabal. Does this stuff support uninstall?
10:54:04 <sorear> no
10:54:17 <dino-> <- Debian user, nervous when something isn't packed in a .deb archive.
10:54:38 <sorear> use ./Setup.lhs register --inplace --user instead, until the cabalites figure out people want uninstall
10:54:54 <tuukkah> perhaps there's a cabal2deb thingy
10:55:27 <dino-> sorear: Does that basically tell it to config to install it entirely in a user's ~ ?
10:55:36 <sorear> dino-: no
10:55:51 <sorear> dino-: --user means register in ~/.ghc/
10:56:04 <sorear> dino-: --inplace means no files are copied
10:57:21 <dino-> So, it's making a record of what would be intsalled, in this ~/.ghc ?
10:57:39 <sorear> not quite
10:58:07 <sorear> it stores in .ghc records that allow ghc to find the library you just registered
10:58:18 <newsham> ghc needs a debugger :\
10:58:33 <sorear> stuff like "vty is available in /usr/local/src/vty-for-6.4.2"
10:58:40 <sorear> newsham: ghci has a debugger :)
10:59:03 <dino-> sorear: Sorry to be dense. I'm not following why this is useful.
10:59:05 <newsham> how do I tell where an exception occurred and who called it?
10:59:11 <sorear> readlink `which ghci` is ghci-6.7 here
10:59:35 <sorear> newsham: recompile with profiling support (-prof -auto-all), then run with +RTS -xc
11:00:19 <sorear> newsham: it's a fairly dirty hack, supported since 6.4.2 if not long before, leveraging the fact that the profiler needs to keep a stacktrace anyway for cost attribution purposes
11:00:44 <newsham> -xc is for?
11:01:13 <sorear> ghc --make -prof -auto-all Main.hs
11:01:18 <sorear> ./Main +RTS -xc
11:01:27 <newsham> cost-center-stack
11:02:22 <sorear> unless you use manual {-# SCC #-} annotations, the cost center stack corresponds to the call site stack
11:03:00 <newsham> *nod* used profiling once
11:03:14 <sorear> also, it fails miserably (segfault) on one common version of ghc (6.6 or 6.4.2, can't remember which)
11:03:28 <newsham> we'll see if its 6.6 cause thats what i'm using
11:05:50 <newsham> I just have to add "-prof" to Ghc-Options of any dependant libraries right?
11:06:13 <Cheery> There has something weird happened since I changed to Haskell.
11:06:19 <Cheery> my projects... they. erm.
11:06:24 <Cheery> they make progress.
11:06:28 <Cheery> unbelievable!
11:06:33 <ibid> what a scary thought
11:06:43 <ibid> actually getting something done
11:06:51 <ibid> what are we do after?
11:06:52 <ibid> +to
11:07:03 <newsham> really?  since i switched to hsakell i spend lots of time makin gmy code pretty
11:08:13 <Cheery> newsham: It's because now I actually have a consistent system where I can reason and operate, and where there's very good reasons to hone your skills instead of just pushing forwards.
11:08:37 <Cheery> and it a bit amplifies my own personality as well.
11:08:43 * allbery_b kinda wishes he had more excuses to write code
11:08:43 <newsham> all, cabal has -p option for configure
11:08:55 <paolino> ddarius , can you explain me a bit more how specialized variants can reduce complexity (if that's the case) ?
11:08:56 <allbery_b> (of course then my coworkers would kill me :)
11:09:25 <Cheery> haskell is lazy and it does not even prohibit me from being lazy. :)
11:09:33 <ddarius> paolino: They would only reduce complexity for the end-user.
11:09:52 <augustss> @seen dons
11:09:52 <sorear-lambdabot> Plugin `seen' failed with: IRCRaised Data.Binary.Get.takeExactly: Wanted 8 bytes, found 0.. Failed reading at byte position 8
11:10:00 <Cheery> :D
11:10:06 <ddarius> paolino: But you can make a subclass of several type classes to shrink your contexts.
11:10:08 <Cheery> @seen Cheery
11:10:09 <sorear-lambdabot> Plugin `seen' failed with: IRCRaised Data.Binary.Get.takeExactly: Wanted 8 bytes, found 0.. Failed reading at byte position 8
11:10:18 <Cheery> @seen paavo
11:10:18 <sorear-lambdabot> Plugin `seen' failed with: IRCRaised Data.Binary.Get.takeExactly: Wanted 8 bytes, found 0.. Failed reading at byte position 8
11:10:23 <Cheery> It's broken.
11:10:46 <allbery_b> the real bot is broken, this is the emergencybackup bot
11:10:52 <augustss> and why is it sorear-lambdabot that is answering, anyway?
11:10:56 <augustss> ah
11:11:12 <augustss> the less capable cousin
11:11:13 <allbery_b> not even clear why dons' LB went away, just stopped responding
11:11:23 <allbery_b> dons's
11:11:50 <augustss> it went to search for its master
11:12:48 <newsham> blah.. this package uses ghc internal libs which werent compiled with profiling.
11:13:00 <Cheery> maybe it got a gf.
11:13:02 <newsham> i would have to rebuild ghc
11:13:48 <allbery_b> @vixen
11:13:49 <sorear-lambdabot> Plugin `vixen' failed with: IRCRaised Data.ByteString.last: empty ByteString
11:13:53 <allbery_b> o well :)
11:14:34 <Cheery> @help
11:14:35 <sorear-lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:14:40 <Cheery> @list
11:14:41 <sorear-lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:15:18 <sorear> sorear-lambdabot is not faring very well from the transition to Data.Binary
11:15:20 * ddarius wouldn't be here if his girlfriend wasn't in Hawaii.
11:15:33 <newsham> i'm in hawaii.  send her over.
11:15:34 <paolino> ddarius, I see. Would make sense to build a type class made of type unrelated methods just to reduce constraint complexity ?
11:16:19 <ddarius> paolino: I would try to group ones that are related, but no -I- would probably not just make a convenience class.
11:16:38 <ddarius> newsham: I like the idea of sending myself over better.
11:16:59 <kolmodin> ?unmtl State Int a
11:16:59 <sorear-lambdabot> State Int a
11:17:17 <allbery_b> unmtl is too new, I think
11:17:22 <kolmodin> yeah
11:17:23 <allbery_b> that looks like you got @unpl
11:17:27 <newsham> ?faber
11:17:28 <sorear-lambdabot>   bzzt.
11:17:42 <bd_> ?mtl a -> (a, b)
11:17:42 <sorear-lambdabot> Maybe you meant: ft map msg pl url
11:17:47 <paolino> ops, you already answered, sorry I have a very bad connection
11:18:14 <bd_> ?unmtl StateT Int Identity a
11:18:14 <sorear-lambdabot> StateT Int Identity a
11:21:55 <sorear> I actually have @unmtl
11:22:07 <sorear> I just haven't recompiled in the last month :)
11:22:14 <yip> anyone know how i can make Data.Time.LocalTime.LocalTime an instance of Typeable?
11:22:53 <sorear> "derive instance Typeable LocalTime" -- I believe - head only, and the syntax changes daily
11:23:11 <Heffalump> someone had some TH code for "deriving" Typeable (i.e. it generated the instance)
11:23:54 <yip> sorear: you mean ghc head?
11:23:56 * ddarius was going to do that a long time ago so he could make the TH AST Typeable and use the Scrap Your Boilerplate techniques on it.
11:24:13 <sorear> yip: yes
11:24:19 <yip> sorear: how can i do it with ghc 6.6?
11:24:56 <sorear> edit the baselib and add "deriving (Typeable)" :)
11:25:30 <yip> :'(
11:27:45 <sorear> there IS a way .. lemme find it...
11:27:46 <yip> sorear: maybe there is a better way to solve my problem, instead of using Data.Dynamic?
11:27:51 <sorear> @source Data.Typeable
11:27:52 <sorear-lambdabot> http://darcs.haskell.org/packages/base/Data/Typeable.hs
11:28:25 <sorear> well, if you can give a higher level description, I wouldn't mind.  but your subgoal is tractible.
11:29:05 <Heffalump> yip: http://www.cs.helsinki.fi/u/ekarttun/haskell/DeriveTH/
11:29:07 <sorear-lambdabot> Title: Index of /u/ekarttun/haskell/DeriveTH
11:31:33 <ddarius> "Transformating"?  Some kind of joke?
11:32:42 <yip> sorear: well, i'm trying to implement some sort of scripting language. the scripting language can access haskell values that are passed into it. like: runProgram :: ScriptProgram -> Map String HaskellValue -> ScriptProgramResult
11:33:06 <yip> sorear: where the keys of the map are strings that represent variable names that the script program can access
11:33:16 <hpaste>  sorear pasted "yip: instance Typeable LocalTime" at http://hpaste.org/454
11:33:31 <ddarius> Is Data.ByteString.intersperse actually used?
11:33:34 <yip> sorear: so a script program might be something like "$a + $b", where it expects "a" and "b" to be HaskellValues that were passed in
11:33:50 <yip> sorear: so i am thinking of using Data.Dynamic for my HaskellValue type
11:33:52 <sorear> yip: of course, full Hindley-Damas-Milner is preferred here :)
11:34:18 <sorear> but I haven't gotten around to writing Data.Dynamic.SystemFw yet :)
11:35:20 <ddarius> hmm
11:35:26 * ddarius wants to see something.
11:35:33 <sorear> something.
11:35:40 <sorear> :)
11:36:27 <yip> sorear: did i explain my problem ok?
11:37:36 <sorear> yip: I've been in that situation and I used Dynamic.
11:37:49 <sorear> yip: next time however I will use hs-plugins
11:38:11 <sorear> (IE my scripting language *is* Haskell)
11:38:32 <yip> hs-plugins isn't an option, because the point of my scripting language is to *not* use haskell :)
11:38:56 <dcoutts> ddarius, we were just keeping the same set of functions as provided by the Data.List module, so that's why we've got Data.ByteString.intersperse
11:39:35 * syntaxfree is working on Control.Stochastic ; )
11:39:51 * sorear eggs on syntaxfree 
11:39:53 <ddarius> dcoutts: I don't think I've ever used intersperse on lists of lists or lists of functions, never Strings.
11:40:08 * ddarius is working on Control.Everything.
11:40:09 <syntaxfree> I *finally* found some work that (a) has already been started by someone (b) interests me (c) I'm very knowledgeable about, even more than the average Haskeller.
11:40:25 <dcoutts> ddarius, yeah, I'm sure it's less useful on [Char]
11:40:57 <sorear> syntaxfree: also, to avoid combinatorial explosion - take a good long look at GHC.Prim.reallyUnsafePointerEq#
11:41:47 * ddarius realizes that at some point there will probably be a module called Control.User.
11:42:06 <ddarius> Unfortunately, it will probably not do what the name suggests...
11:42:19 <syntaxfree> ah, I'm avoiding the unsafe stuff.
11:42:30 <syntaxfree> There need be no combinatorial explosion iff you're lazy enough.
11:43:15 <syntaxfree> (I realize PFP is not lazy enough right now, but I'm thinking of a thing or two to improve that)
11:43:44 <syntaxfree> Anyway, what I'm mainly interested in is stochastic transitions.
11:44:41 <syntaxfree> Many a simulation model should become easier. Once I've finished making sense of the current PFP code (a lot of it could be really cleaned; he rewrites monadic combinators here and there) I want to try and *really* grok that sigfpe zipper/CA comonad; it's percolation -in-a-box.
11:49:43 <yip> sorear: that code doesn't work :(
11:50:01 <sorear> yip: cpp error, or ghc error?
11:50:16 <sorear> yip: run 'locate Typeable.h', and fix the path
11:50:46 <yip> sorear: ghc error: Not in scope: data constructor `LocalTimeTc'
11:50:50 <sorear> hmm, it seems ghc is smart enough to pass -I options
11:50:56 <syntaxfree> the lambdabot web interface doesn't have @tell!
11:52:12 <sorear> yip: I believe you mistyped the code
11:52:31 <vincenz> sorear: you called?
11:52:54 <sorear> if you accidentally capitalize the second parm, I get that error
11:53:21 <yip> sorear: oops, sorry :^ it works now :)
11:53:28 <sorear> vincenz: @seen ?
11:53:29 <yip> sorear: but is there a cleaner way to do it?
11:54:02 <sorear> yip: no, that's the code used in Data.Typeable itself - if there was a cleaner way I'm sure GHC would use it
11:54:04 <vincenz> sorear: yes :)
11:54:41 <yip> sorear: i don't like this #include line. maybe there is a better way to solve my general problem?
11:55:24 <sorear> vincenz: there was a German complaining about being unable to access www.cse.unsw.edu.au from a German provider, so I ran @seen on the only other German haskeller I could think of at the time.  to ask if it was local to the one user.
11:55:37 <vincenz> sorear: I'm not german :)
11:56:13 <sorear> oops
11:56:19 <sorear> sorry then
11:56:22 <vincenz> no prob
11:56:56 <ookk> i cannot access that http://www.cse.unsw.edu.au/
11:56:57 <sorear-lambdabot> Title: School of Computer Science & Engineering
11:57:54 <pejo>  > host www.cse.unsw.edu.au
11:57:54 <pejo> ;; connection timed out; no servers could be reached
11:58:22 <pejo> I had the same phenomenon the other day. Unsure why, it worked a couple of hours later.
11:58:39 <vincenz> yep, seems down
11:58:43 <sorear> well at one point yesterday the site itself was down for repairs.
11:58:46 <vincenz> Bot
11:58:49 <vincenz> @bot
11:58:49 <sorear-lambdabot> :)
11:58:53 <vincenz> lol
11:58:58 <sorear> http://www.cse.unsw.edu.au/
11:59:00 <sorear-lambdabot> Title: School of Computer Science & Engineering
11:59:06 <pejo> sorear, it was before yesterday.
11:59:15 <sorear> ^^^ sorear-lambdabot (San Diego) can access the site
11:59:38 <LoganCapaldo> Is there a hugs or GHC internals type book? (Short of the actual source code)?
11:59:53 <pejo> sorear, because some DNS you're using has cached the result. What is the IP?
12:00:06 <ddarius> Uhh... there is (was?) kind of one for GHC, but not really.
12:00:08 <pejo> LoganCapaldo, the ghc commentary, somewhere on the wiki.
12:00:42 <pejo> LoganCapaldo, and Mark P. Jones has a research report linked from his homepage describing hugs, but it's probably for 1.2 or so.
12:00:51 <hpaste>  stefanha pasted "<- vs let" at http://hpaste.org/455
12:01:18 <LoganCapaldo> pejo, thanks. I don;t really care if the info is all that current its just to satisfy some curiosity
12:02:07 <pejo> LoganCapaldo, oh. Then whatever Mark has written is worth a read. :-)
12:02:28 <ddarius> Including that paper no less.
12:02:50 <stefanha> Newbie question: I would like to do "cellPos <- read (getLine)" to input an Int.  Any suggestions?  http://hpaste.org/455
12:02:53 <yip> sorear: btw, do you know why LocalTime isn't already a Typeable instance?
12:02:56 <sorear> pejo, oook: http://129.94.242.51/
12:02:56 <lambdabot> Title: School of Computer Science & Engineering
12:02:57 <sorear-lambdabot> Title: School of Computer Science & Engineering
12:03:08 <sorear> sorear-lambdabot: @quit
12:03:15 <ookk> stefanha, cellPos <- readIO getLine
12:03:20 <sorear> hurrar!!
12:03:21 <stefanha> Thanks :)
12:03:31 <ookk> stefanha, readIO is basically return.read
12:03:43 <pejo> ookk> stefanha, cellPos <- readIO getLine
12:03:43 <ookk> @src readIO
12:03:43 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:03:48 <pejo> Ups, sorry about that.
12:03:56 <dancor> can i have files with  #!/usr/bin/env runhaskell
12:04:02 <LoganCapaldo> this looks perfect: http://web.cecs.pdx.edu/~mpj/pubs/goferimp.html
12:04:03 <sorear> dancor: yes
12:04:04 <lambdabot> Title: The implementation of the Gofer functional programming system
12:04:05 <LoganCapaldo> thanks again
12:04:18 <pejo> sorear, I actually get stuck on the way there too.
12:04:19 <sorear> dancor: indeed, that is runhaskell's raison d'etre
12:04:20 <dancor> pima ~ args
12:04:21 <dancor> Could not find module `/home/danl/bin/args':
12:04:54 <sorear> pejo: indeed.  the german user from yesterday had working DNS but couldn't even ping the IP.
12:05:00 <dancor> #!/usr/bin/env runhaskell
12:05:00 <dancor> main = putStrLn "hi"
12:05:02 <dancor> is the file
12:05:17 <sorear> hmm
12:05:24 <ookk> stefanha, or you have to do, cellPos <- readIO =<< getLine
12:05:30 <sorear> does it work if the filename ends in .{l,}hs ?
12:05:43 <dancor> yes
12:06:18 <dancor> is there any way to not need that
12:06:25 <stefanha> ookk: thanks, I've just found readLn after looking at readIO.
12:07:42 <dancor> the raison d'etre of #! is to not need .ext  :)
12:08:56 <sorear> well, it sounds like a "bug", for a definition of bug that includes a large chunk of "misfeature"
12:09:04 <sorear> I'd report it
12:11:14 <allbery_b> hm.  I just tried to derive a proper Typeable instance for LocalTime and ran into Fixed not having a visible constructor so I can't typeOf its enclosed type
12:11:49 <allbery_b> (LocalTime -> TimeOfDay -> Pico == Fixed E12)
12:13:32 <ddarius> allbery_b: You should be able to make a Typeable instance anyway, by hand at least.
12:15:20 <hpaste>  SamB pasted "test" at http://hpaste.org/456
12:15:21 <allbery_b> hm?  if I'm doing typeOf a Micro or Pico (Fixed E6 and Fixed E12 respectively) how do I determine whch I have?
12:17:05 <hyrax42> who chose the type of hpaste?
12:17:24 <sorear> allbery_b: what do you need a constructor for!!
12:17:29 <dancor> why can't i use ^d to tell getContents that stdin is over
12:17:35 <allbery_b> maybe I don't understand hw the typeable stuff worked
12:17:52 <sorear> allbery_b: what do you *think* you need a constructor for
12:17:59 <allbery_b> for a paramaterized type I thought I needed to delve inside the parameter and feed it to mkTyConApp
12:18:00 <dancor> haskell appears to be militantly at odds with scripting..
12:18:35 <sorear> dancor: hs-plugins, MissingPy, ...
12:19:16 <sorear> SamB: don't worry, your paste is already gone
12:19:47 <allbery_b> Data.Typeable's documentation isn't exactly clear on how to build your own instances
12:19:51 <dancor> sorear: that will make ^D work?
12:20:05 <dancor> i have both of those installed
12:20:32 <tuukkah> dancor, ghc -e "getContents"
12:20:42 <allbery_b> dancor: I think something else is wrong in that case
12:21:20 <sorear> allbery_b: just use typeOf (undefined :: Type)
12:21:36 <redson> Is there a decent Haskell debugger?
12:21:41 <allbery_b> I wasn't clear I guess.
12:21:43 <redson> Or built in trace capabilities?
12:21:58 <dancor> tuukkah: what is -e?  i can't find it searching http://www.haskell.org/ghc/docs/latest/html/users_guide/using-ghc.html#id3130151
12:22:04 <dancor> or anywhere in fact
12:22:06 <cjay> redson: hat
12:22:14 <cjay> ?where hat
12:22:14 <lambdabot> http://www.haskell.org/hat/
12:22:16 <dancor> execute?
12:22:20 <tuukkah> dancor, evaluate an expression from command line
12:22:20 <allbery_b> instance Typeable a => Typeable (Fixed a) where typeOf (MkFixed a) = mkTyConApp tcFixed [typeOf a] -- ?
12:22:26 <allbery_b> except MkFixed isn't exported
12:22:28 <dons> $ ghc -e '1+2'
12:22:29 <dons> 3
12:22:45 <ddarius> allbery_b: The typeable instances are just tags, they don't need to know the implementation.
12:22:56 <redson> cjay: thanks
12:22:56 <allbery_b> and I can't instance Fixed E12 (given type Pico = Fixed E12)
12:22:59 <dancor> tuukkah: your line does not wait for any input from me (lazy eval i guess)
12:23:21 <ddarius> typeOf _ = mkTyConApp tcFixed []
12:23:25 <allbery_b> and I don't see how I do both Fixed E6 and Fixed E12 without being able to determine which I have
12:23:29 <ddarius> or whatever.
12:23:37 <tuukkah> works for me. i have ghc6.6, might be that these things have progressed in time
12:23:49 <sorear> allbery_b: typeOf *must* be lazy
12:24:12 <sorear> typeOf undefined is expected to work at any type
12:24:41 <dons> the argument is just a phantom, to look up the correct dictionary
12:24:51 <dons> > typeOf (undefined :: Int)
12:24:52 <lambdabot>  Int
12:25:02 <tuukkah> dancor, anyway, my point was that these things vary between how you run your script
12:25:40 <allbery_b> I guess I'm confused as to what mkTyConApp is supposed to do with its list argument
12:25:45 <vincenz> lambdabot: !
12:25:47 <vincenz> @bot
12:25:47 <lambdabot> :)
12:26:04 <dancor> tuukkah: sounds like blaming the victim.  i'll try 6.6
12:26:15 <ddarius> @type Data.Typeable.mkTyConApp
12:26:16 <lambdabot> TyCon -> [TypeRep] -> TypeRep
12:26:39 <ddarius> @src TyCon
12:26:40 <lambdabot> Source not found. It can only be attributed to human error.
12:26:53 <ddarius> @src Data.Typeable.TyCon
12:26:53 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:26:54 <sorear> The requested URL /~eric/hpaste/accounts.txt was not found on this server.  :(
12:27:17 <augustss> dons: you have a keen Core eye.  Can you have a look at what generated from my version of the n-body code and tell me why if there's something obviously wrong?  darcs.augustsson.net/Darcs/Planets/
12:27:24 <tuukkah> dancor, saying that things vary i'm blaiming the specification or implementations that don't follow one
12:27:34 <sorear> augustss: I'll look too
12:27:42 <augustss> that'd be great
12:27:58 <sorear> augustss: I can't dl: darcs: darcs.augustsson.net/Darcs/Planets/_darcs/inventory: openBinaryFile: does not exist (No such file or directory)
12:28:12 <augustss> hmmm
12:28:22 <sorear> augustss: http://fixed it
12:28:59 <augustss> oh, ok
12:29:27 <dons> augustss: ok. looking.
12:29:28 <augustss> don't worry about the energy function, it's only used twice
12:29:55 <augustss> It's 10% slower than ookk version with global variables and IO
12:31:14 <dancor> how is o'haskell vs haskell usage
12:31:33 <dancor> is o'haskell just a toy or is it like the future
12:31:43 <sorear> WOW!
12:31:55 <dons> dancor: its unused, afaik.
12:31:57 <ddarius> dancor: O'Haskell was never really alive and now it's fairly dead.  It got succeeded by Timber.
12:31:58 <sorear> Auto-save? (y or n) n
12:31:58 <sorear> Abort (and dump core)? (y or n) y
12:32:12 <sorear> ^^^ I just hit the emacs double C-g auto stop
12:32:35 <ddarius> dancor: Timber, if it's still active, is more of a side branch rather than the future or a dead end.
12:32:38 <augustss> sorear: emacs does that now and then :(
12:32:44 <pejo> dancor, there's one german professor using it.
12:32:56 <pejo> (And his grad students).
12:33:07 <dancor> heh.  and how is timber doing
12:33:17 <sorear> augustss: btw, -ddump-rn on your code generates a single line with 13 million spaces ... I'm glad I ran a second emacs
12:33:33 <augustss> lol
12:33:34 <ddarius> dancor: I haven't looked in a long time.  Last I checked (years ago) they hadn't publically released the implementation.
12:34:31 <sorear> gak
12:34:35 <sorear> 1150 lines o core
12:34:57 <augustss> yeah.  but core is kinda verbose
12:35:31 <pejo> dancor, there's progress on Timber. No compiler ready yet though.
12:36:26 <sorear> I should write Pretty-Core one of these days
12:36:50 <sorear> (un-rename, infix ops, layout, but stay isomorphic)
12:37:31 <pejo> (And as ddarius says, it's more of a side branch - lazy evaluation was taken away for example).
12:38:05 <augustss> sorear: that would be a boon
12:38:28 <sorear> I am so embarassed
12:38:32 <sorear> @web1913 boon
12:38:34 <lambdabot> *** "Boon" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:38:34 <lambdabot> Boon \Boon\, a. [F. bon. See {Boon}, n.]
12:38:34 <lambdabot>    1. Good; prosperous; as, boon voyage. [Obs.]
12:38:34 <lambdabot>  
12:38:36 <lambdabot>    2. Kind; bountiful; benign.
12:38:38 <lambdabot> [30 @more lines]
12:39:22 <dons> a lovely day, coffee, Bach, and tuning GHC Core!
12:39:33 <sorear> is there a way to get easily parsable Core out of GHC?
12:39:44 <sorear> -ddump-simpl doesn't exactly look machine readable
12:39:45 <dons> -fext-core
12:40:03 <pejo> dons, let me guess, it's sunny too?
12:40:27 <ddarius> cloudy day, tea, Pachelbel, and 16 long pipe from yore
12:40:49 <dons> nah, its raining today. quite heavily.
12:41:08 <augustss> sorear: just hack a new core pretty printer into ghc
12:41:49 <dons> augustss: the core definitely looks worse than our global variable version.
12:41:56 <dons> but maybe fixable, let's see...
12:42:33 <augustss> it must be worse. :)
12:42:41 <augustss> dons: did you use -funfolding-keeness-factor=10 -funfolding-use-threshold=2 ?
12:43:21 <augustss> tweaking the unfolding numbers at random make some improvement sometimes.
12:43:40 <augustss> I'm considering writing a search program to tweak them for me
12:43:43 <pejo> Heh, was just going to ask about that. Is there any heuristics available for that?
12:43:47 <jcreigh> heh, GHC command line pragmas are so funny. -fflux-capacitor-level=13
12:43:55 <sorear> augustss: have you heard of acovea?
12:44:02 <augustss> sorear: no
12:44:09 <dons> oh, that helps a little bit
12:44:14 <Philippa> did they ever actually add -fno-killing-kittens?
12:44:48 <dons> Core is really a lot more manageable when piped into HsColour
12:44:59 <augustss> we need -fenergize-warp-drive
12:45:28 <yip> augustss: hey
12:45:29 <sjanssen> -fredirect-power-from-life-support
12:45:34 <dons> hehe
12:45:53 <yip> -funroll-infinite-loops
12:45:54 <augustss> -fwe-need-all-speed-we-can-get
12:46:05 <int-e> -fadd-f-option=energize-warp-drive -fenergize-warp-drive ;)
12:46:23 <sorear> augustss: you may want to look at acovea.  It is a program which uses genetic optimization to tweak g*c*c's notoriously numerous optimization knobs.
12:46:40 <augustss> sorear: ah, cool
12:46:42 <sorear> I don't know if it can be made to support ghc tthough
12:47:11 <augustss> yip:hey
12:47:23 <sorear> and it's automatic so you can run it overnight :)
12:47:24 <yip> augustss: there was something i wanted to ask you but i don't remember what
12:47:35 * sorear has it installed but keeps meaning to try it
12:48:59 <ookk> dons, i made a small speed improvement to your modified version
12:49:35 <ookk> dons, removing inc and using plusPtr directly
12:50:59 <dons> ah right. yeah, I did that in some place. but that makes sense.
12:51:07 <dons> we can update in a day or two
12:51:36 <augustss> is there some way to get a Ptr from a MutableByteArray#?
12:52:32 <dons> hmm. there's an unsafe primop that turns a MutableByteArray# into an Addr#
12:52:39 <dons> and a Ptr is a Ptr Addr#
12:52:47 <dons> but I think that's a bit dangerous
12:53:02 <augustss> I tried unsafeCoerce, but that was just bad
12:53:28 <augustss> I guess MutableByteArray# has a tag?
12:53:35 <dons> primop  ByteArrayContents_Char "byteArrayContents#" GenPrimOp
12:53:35 <dons>    ByteArr# -> Addr#
12:53:36 <dons>    {Intended for use with pinned arrays; otherwise very unsafe!}
12:53:42 <dons> yeah, and a size field and so on
12:54:00 <sorear> augustss: a MutableByteArray# is MOVABLE
12:54:07 <sorear> iirc
12:54:23 <augustss> sorear: that's ok, i just need it to stay still for a few instructions :)
12:54:39 <sorear> augustss: can you guarantee the GC won't run?
12:54:44 <dons> yeah, that's probably ok ...
12:54:47 <augustss> sorear: there's no allocation
12:54:48 <dons> though a bit scary.
12:55:15 <sorear> augustss: doesn't our GC start spontaneously now, in parallel, on a timer?
12:55:38 <augustss> sorear: it only starts at well defined points, not arbitrary program points
12:55:38 <Cheery> writing software in haskell..
12:55:39 <Cheery> darn.
12:55:45 <Cheery> this is easy. :)
12:56:06 <Cheery> especially after you find out what you should waste your intelligence.
12:56:14 <Cheery> *how
12:56:16 <augustss> the reason I want this, is that I think that anything Storable should be able to be kept in an STUArray
12:56:24 <sorear> augustss: me too.
12:56:29 <sorear> augustss: BUT
12:56:35 <Cheery> for example, nondeterministic parsers.
12:56:49 <sorear> augustss: try writing (efficiently) instance Storable Bool
12:56:49 <bd_> augustss: Storable's put operation might allocate, though
12:56:58 <Cheery> I can simply concentrate on four things.
12:57:22 <bd_> sorear: -fincoherent-instances? Or a type other than STUArray but still in ST
12:57:31 <augustss> sorear: I guess I can invent a new class that is like Storable
12:57:36 <Cheery> - getting the next value for the parser.
12:57:52 <Cheery> - defining successive parsing cases.
12:57:54 <Saizan> is there a reason why there's no DiffUArray i Bool?
12:58:09 <Cheery> - defining failure points.
12:58:30 <ddarius> Cheery: Now you'll understand where Post-doc Haskell programmer comes from on http://www.willamette.edu/~fruehr/haskell/evolution.html
12:58:31 <lambdabot> Title: The Evolution of a Haskell Programmer
12:58:34 <bd_> augustss: Why not just use unsafeIOToST and allocate ForeignPtrs to store the data?
12:58:35 <sorear> Cheery: why can't you just use parsec/ReadP/ReadS
12:58:47 <pejo> Is there an obvious way to get darcs to send emails upon pushing to a repository, like most projects have for cvs when committing?
12:59:01 <sorear> pejo: use send?
12:59:16 <dons> yeah, you attach a hook to the apply function,  a darcs hook
12:59:23 <sorear> pejo: As I understnad it darcs send usually uses email for sendign
12:59:24 <dons> that runs the mail program. check darcs.net for examples
12:59:26 <augustss> bd_: yes, probably possible
12:59:37 <Cheery> sorear: I want to suspend them and have some indication about in what state they are.
12:59:40 <sorear> pejo: also #darcs exists and is (lightly) staffed
12:59:43 <dancor> do you ever feel like string escaping could be better
12:59:48 <pejo> dons, thanks.
13:00:03 <pejo> sorear, I'm in no position to help, struggling to get by myself. :-)
13:00:06 <Cheery> if I could use parsec some way, I'd be more than satisfied.
13:00:18 <newsham> I have shim working in win32.
13:00:23 <matt__r> I asked this last night, so apologies for the re-post - Is there anyone here with some insight into ghc's core language?
13:00:31 <sorear> Cheery: you wouldn't by any chance be trying to write an incremental syntax highlighting engine, would you?
13:00:42 <sorear> newsham: booyah!  newsham++ newsham++
13:00:54 <dancor> i think  @"yay"  @'i said "hi"'  @%this one is "wacky'!%  might be a good escaping mechanism
13:00:58 <sorear> newsham: tell beschmi!
13:01:06 <Cheery> sorear: I don't know, why?
13:01:26 <dancor> @xyayx = "yay"
13:01:26 <lambdabot> Unknown command, try @list
13:01:27 <newsham> i sent him patches.  the code patches are pretty clean, but I had to botch the .cabal and shim.el a little bit in a non-portable way
13:01:31 <newsham> hopefully he knows how to fix :\
13:01:34 <dancor> hah sorry lb
13:01:40 <dancor> that @ wasn't for you
13:01:49 <sorear> Cheery: I'm asking about your goals ... anyway I had a similar problem with synhl
13:02:03 <sorear> (I'm vaguely on the yi team)
13:02:25 <Cheery> my goal is to experiment with one idea I thought about few days ago.
13:02:38 <Cheery> It's user interface related.
13:02:39 <dons> urgh, too polymorphic.
13:02:39 <sorear> ok. that's fine :)
13:03:08 <Cheery> sorear: I'm planning to use the parser on parsing SDL events. :D
13:03:26 <yip> what is SDL?
13:03:28 <sorear> SDL, yuk
13:03:37 <Cheery> if you have better idea, tell me.
13:03:38 <sorear> yip: a gamedev toolkit :(
13:03:40 <Cheery> I agree, SDL sucks.
13:03:51 <yip> simple direct media layer?
13:03:56 <Cheery> but I need to test it on to something.
13:03:57 <Cheery> yep.
13:04:09 <yip> SDL has always worked for me
13:04:26 <sorear> it's too ...
13:04:26 <yip> and Lemmih's haskell bindings seem to also work just great
13:04:31 <sorear> imperative
13:04:48 <dons> augustss: ok, starting to get some speedups
13:04:49 <yip> sorear: well, the machine is imperative
13:04:58 <Cheery> anyways, I'm planning to parse input and deduce current user interface states from it, etc. :)
13:05:02 <Philippa> and gamedev involves a lot of highly state-oriented stuff
13:05:03 <dons> advance is too polymorphic for one,
13:05:05 <dons> advance :: Bodies s -> ST s ()
13:05:05 <dons> advance !planets = do
13:05:07 <dons> helps
13:05:29 <yip> i've done some yampa with sdl and opengl
13:05:34 <Cheery> I can't yet imagine where this ends to.
13:06:13 <matt__r> no go I guess - you think I might have better luck on haskell-cafe?
13:06:15 <sorear> @slap me
13:06:15 <lambdabot> why on earth would I slap sorear
13:06:20 <sorear> *Main> :br *Main | less
13:06:20 <sorear> syntax:  :browse <module>
13:06:22 <LoganCapaldo> @type (n+1) = 43 in n
13:06:23 <lambdabot> parse error on input `='
13:06:37 <LoganCapaldo> @type let (n+1) = 43 in n
13:06:39 <lambdabot> forall a. (Integral a) => a
13:06:44 <LoganCapaldo> @type let n+1 = 43 in n
13:06:46 <lambdabot> Not in scope: `n'
13:07:05 <newsham> i would really like these shim functions in an editor I'm more comfortable with (and written in haskell!)
13:07:19 <newsham> just got it built in win32 to play with and learn how it works
13:07:23 <ddarius> LoganCapaldo: Yep.  Down with n+k patterns.
13:07:48 <gotaku> autoconf seems to fail for my in the gtk2hs darcs build.
13:08:09 <sorear> newsham: what editors are you comfortable with?
13:08:14 <newsham> vim is fine :)
13:08:25 <sorear> shim vim is planned
13:08:34 <augustss> dons: getting speedups?  nice!
13:08:38 <newsham> i've been wanting to write an editor for a while, so maybe if i get some free time i'll take a crack at fixing up yi to my liking or writing my own
13:09:00 <newsham> i would like something that integrates some of the ideas from "sam"
13:09:14 <augustss> dons: I don't see why advance should be too polymorphic.  ghc should specialize it
13:09:15 <ddarius> Yay Haskell'!
13:09:16 <newsham> but perhaps with some of the vim feel
13:09:16 <LoganCapaldo> sam but not acme?
13:09:42 <gotaku> Can anyone else build gtk2hs?
13:09:46 <newsham> logan: to do acme right requires more infrastructure.. i'm not looking to make a file windowing system or a plumber, etc..
13:09:56 <siti> gotaku: what version?
13:09:56 <newsham> s/file/full/
13:10:14 <newsham> i do like acme, but i dont want to just write a hack of acme.
13:10:16 <gotaku> siti: darcs
13:10:41 <sorear> augustss: does adding 'module Main(main) where' at the beginning help at all?
13:10:48 <siti> umm I built the rc ok.... I have not tried darcs
13:11:14 <sorear> augustss: how do I run tihs?
13:11:21 <augustss> sorear: that should make no difference, since saying nothing means 'module Main(main)'
13:11:39 <augustss> sorear: give it the argument 2000000
13:11:40 <sorear> augustss: that's what H98 says.
13:11:50 <sorear> augustss: GHC works differently
13:11:52 <newsham> hmm.. shim only looks up types of functions?
13:12:04 <sorear> augustss: GHC : nothing -> module Main where
13:12:09 <sorear> ie everything is exported
13:12:14 <newsham> it would be really nice to be able to hilight any expression and lookup its type within its context
13:12:18 <sorear> and inlining is harder
13:12:27 <augustss> sorear: that's broken!
13:12:55 <dons> sorear: nothing is module Main(main) where ..
13:13:00 <Heffalump> sounds more convenient in practice, though
13:13:03 <dons> that's why putting in module Main where slows things down
13:13:22 <augustss> Heffalump: in practice you should always write 'module ...'
13:13:30 <Heffalump> especially if you're in ghci and you compiled the file, so it doesn't see the unexported things
13:13:38 <Heffalump> augustss: right, so nothing is really for beginners
13:13:38 <augustss> omitting it is just for showing how short it can be in Haskell ;)
13:13:54 <dons> yeah
13:14:14 * sorear tries to find the relevant section of the user's guide
13:14:25 <pejo> Or get a weird error message from GHC if you have a broken module as dependency to what you're compiling.
13:14:26 <augustss> Heffalump: I don't think writing 'module Main where' is any more onerous than many other languages.  It's just an incantation
13:14:35 <dons> sorear: have a look at the -ddump-desugar output
13:14:50 <Heffalump> "not more onerous than other languages" isn't really much of an argument for it, though
13:15:03 <augustss> Heffalump: :) true
13:15:11 <Heffalump> given that it's only a default for lazy/ignorant people, I think erring on the side of convenience rather than speed is better
13:15:54 <augustss> Heffalump: I'd rather remove the option of omitting it.  It's just one more special case to explain that buys very, very little
13:16:49 <Heffalump> it's not a very complicated special case, though
13:16:58 <Heffalump> very easy to detect, very easy to explain
13:17:35 <sorear> dons: I ran the -ddump-ds - now what?
13:19:09 <sorear> stefan@stefans:/tmp/Planets$ ghc-6.6 --make -O2 -funbox-strict-fields Planets.hs
13:19:09 <sorear> [1 of 1] Compiling Main             ( Planets.hs, Planets.o )
13:19:09 <sorear> Linking Planets ...
13:19:09 <sorear> stefan@stefans:/tmp/Planets$ ./Planets 2000000
13:19:13 <sorear> Segmentation fault
13:19:16 <sorear> stefan@stefans:/tmp/Planets$
13:19:38 <augustss> Heffalump: i'm not heavily against it, just mildly
13:19:56 <Heffalump> I'm only mildly for it, it's not really very important either way :-)
13:20:45 <sorear> augustss: turning off all the optimizations ends the problem
13:21:06 <augustss> hmmm, I'm running HEAD.  maybe it's a ghc bug
13:21:21 <Philippa> it's a special case that's occasionally a PITA when compilers expect module names and file names to match
13:21:23 <Heffalump> turning off optimizations probably stops it unexporting things
13:21:35 <dons> augustss: so the advance loop is now basically generating the same loop body as the Ptr Double version
13:21:47 <Heffalump> Philippa: I think the whole requirement for Main.main to be the entry point is a real pain, actually.
13:21:49 <dons> however, the Ptr Double version just passes a new Addr# in on each loop iteratoin
13:22:04 <dons> whereas the STUArray has to do the index + offset math for each lookup
13:22:10 <augustss> dons: interestingly, when removed the global IO variables it slowed down the code a lot.  and then when I changed from IO to ST I got back almost all that speed.
13:22:23 <Philippa> Heffalump: potentially, but it's not quite so bad if multiple filenames can be Main because you can just have stub files
13:22:26 <allbery_b> I see no indcation in the differences-from-H98 that no module declaration == "module Main where" (vs. Main(main) where) fwiw
13:22:35 <Heffalump> you mean if multiple module names can be?
13:22:40 <dons> I'd like to be able to get a Ptr to the STUArray ! planet
13:22:47 <sorear> no segfault if I remove -optc-msse2 :)
13:22:47 <sorear> oh /proc/cpuinfo DOES list sse2
13:22:47 <sorear> augustss: about how long shoult ./Planets 2000000 take?
13:22:47 <sorear> it's been running for a full minute
13:22:49 <dons> so only do that calculation once
13:22:54 <augustss> sorear: about 2s
13:23:07 <dons> anyway, i'll profile now and see how close it is to the Ptr version
13:23:16 <augustss> dons: yes, I'd like C's & too :)
13:23:24 <Philippa> that's not quite so critical because even if the implementation's in a module with another module name it's not hard work to import it and bind it to main
13:23:24 <Heffalump> I don't think the report should specify that all programs must have a Main.main :: IO t
13:23:37 <Heffalump> I typically just use GHC's -main-is
13:23:45 <dons> augustss: right, which I think is what happens when we use Ptr Double's readDoubleOffAddr#
13:24:01 <Heffalump> but it's a pain because that works by renaming as it compiles, so the object files aren't compatible with ones that expect a different main.
13:24:02 <int-e> allbery_b: which should it be? ghc only exports main.
13:24:04 <allbery_b> hm, it doesn't mention IO t either.  tsk
13:24:15 <sorear> augustss: or were you talking andInt# ?
13:24:21 <Heffalump> so I have to use makefiles to build .o and .main.o files separately for each source file that might or might not be an entry point
13:24:28 <augustss> sorear: no, the addressOf operator
13:24:34 <allbery_b> ghc should only export main  per the report.  Heffalump, based on sorear's confusion earlier, wants everything exported
13:25:00 <dons> whereas STUArray becomes readDoubleArray# arr (index + off)
13:25:06 <allbery_b> (report says Main.main :: IO ())
13:25:13 <Heffalump> no, report said IO t
13:25:13 <dons> whilst Ptr Double is only, readDoubleOffAddr# ptr off
13:25:17 <Heffalump> s/said/says/
13:25:20 <Heffalump> I just looked at it :-)
13:25:23 <Heffalump> it says t is ignored.
13:25:28 <int-e> allbery_b: I wasn't following that but it only exports main as far as I know.
13:25:29 <augustss> dons: a clever enough backend could hide those address calculations in various ways
13:25:29 <Heffalump> or rather the value of type t is thrown away
13:25:41 <dons> yeah. it should be able to
13:26:13 <dons> so i've got STarray at 3.484 total, and Ptr Double at 3.296
13:26:17 <dons> for n= 2000000
13:26:18 <augustss> dons: but we don't have such a backend.  well, maybe gcc
13:27:28 <augustss> dons: so less than 10%
13:27:48 <augustss> dons: it would be nice if cleaner code would be as fast
13:28:47 <dons> I updated the entry to be a lot cleaner, (the Ptr version), but I think we can't avoid that cost while using offset/array math
13:29:19 <dons> here's my tweaked Planets.hshttp://www.cse.unsw.edu.au/~dons/tmp/Planets.hs
13:29:34 <dons> oh, hang on. got to remove those inlines
13:29:47 <sorear> gah. ghc is generating illegal instructions.  I have an early P4 that apparently can't handle XORPD ... what's the -optc-massume-obsolete-processor ?
13:30:09 <augustss> dons: most of the inlines and type signatures are not needed
13:30:20 <dons> yeah, the NOINLINES are for debugging purposes
13:30:30 <dons> so that advance et al get turned into top level Core
13:30:39 <dons> when its all inlined, its a big gunk of unreadable
13:30:53 <dons> ah ha!
13:31:03 <dons> ./P 2000000  3.58s user 0.00s system 98% cpu 3.635 total
13:31:18 <dons> oh, that's worse.
13:31:19 <dons> :/
13:31:31 <dons> so there's too much inlining..
13:31:41 <Igloo> sorear: Are you going via C or the NCG?
13:31:50 <sorear> Igloo: C
13:32:08 <augustss> dons: yes, I noticed that turning up inlining too much was bad
13:32:31 <dons> so sometimes you have to explicitly NOINLINE your main loops
13:32:53 <dons> here's my best Ptr based version, http://www.cse.unsw.edu.au/~dons/tmp/nbody3.hs
13:35:02 <sorear> real    0m5.895s
13:35:07 <chessguy> @type mapM
13:35:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:35:18 <dons> so, in summary, STUArray, good, Ptr Double, few percent better
13:35:34 <sorear> ^^^ on my box - both -msse2 and -march=pentium4 cause segv, so I'm using -msse -march=pentium3
13:35:42 <dons> nice
13:35:54 <dons> gcc is a kewl kompiler
13:35:58 <sorear> (I have a P4 - go figure)
13:36:59 <chessguy> @type runState
13:37:00 <lambdabot> forall s a. State s a -> s -> (a, s)
13:37:07 <chessguy> @type evalState
13:37:09 <lambdabot> forall a s. State s a -> s -> a
13:39:00 <augustss> dons: it would be nice if the shootout examples were not only fast, but also good examples of how to write Haskell code.  And I don't think Ptr belongs in normal code.
13:39:19 <augustss> I still have some unsafe in there, though
13:39:43 <int-e> we should add a Shootout library to the next ghc release ;)
13:39:50 <dons> yeah. its hard. the shootout demands we compete with C all the way down to the machine. this is getting easier, but you still often have to step into the scarier waters
13:39:51 <Igloo> I don't think you'll manage to get arrays, no unsafe and fast
13:40:05 <Igloo> The bounds checking for these sorts of benchmarks will kill you
13:40:22 <dons> bytestrings helped a lot, as did the better simplifier in ghc 6.6 -- it was a lot easier to chase C this time, than a year ago
13:40:35 <dons> but we could do with nicer array syntax/faster arrays
13:41:03 <dons> Igloo: oh, did you see the -fexcess-precision bug report?
13:41:15 <int-e> hmm, ghc still doesn't extract loops, does it? (say, compile tail recursion to a while loop in the intermediate C)
13:41:15 <augustss> Igloo: any good fortram compiler would be able to eliminate those bounds checks
13:41:19 <dons> that I think was the #1 reason numerics problems appeared to be so so bad on the shootout
13:41:35 <sorear> int-e: it *does*, *badly*
13:41:37 <dons> int-e, it generates a computed goto, which sometimes gcc spots and turns back into a loop
13:41:47 <dons> but that is the main bottleneck now, I think.
13:41:49 <pejo> augustss, clearly we need a book about advanced fp!
13:41:58 <sorear> int-e: http://hpaste.org/447
13:41:58 <dons> if we could get slightly better code out of ghc's asm backend..
13:42:00 <int-e> dons: as far as I know, gcc doesn't do that; the evil mangler has an optimization for that.
13:42:23 <dons> int-e, for tail calls yes, and gcc -optc-O3 spots some of them, turning them into jmp .Lable
13:42:31 <dons> only some of them though
13:42:34 <sorear> int-e: I forgot to paste the CMM, but if you look the generated C has a while loop - but do to aliasing GCC can't use registers
13:42:46 <Igloo> augustss: Oh, it's possible to do, yes, but not with today's GHC
13:42:58 <sorear> dons: did you see the inner loop in my asm?  all the reloading?
13:43:04 <dons> yeah.
13:43:09 <dons> we lose too many registers to gcc
13:43:09 <tibbe> hmm, I checked the Haskell' status page and timeline, when is it supposed to be finished?
13:43:24 <Igloo> dons: Hmm, odd
13:43:26 <sorear> tibbe: Jan 07, iirc
13:43:29 <dons> has anyone tried a quick test with the Intel c compiler, btw?
13:43:31 <Igloo> (re -fexcess-precision)
13:43:32 <augustss> It's also sickening that we are back to FORTRAN66 data structures in  Haskell now.  You have to encode everything in an array.  That's just stupid.  I want data types in my array.  And it's not even hard to implement (and it's just Haskell code)
13:43:38 <tibbe> sorear, oh, I missed it? ;)
13:43:45 <dons> it'd be interesting to dump unregisterised code into icc
13:43:59 <int-e> sorear: ok, that's an improvement.
13:44:01 <dons> augustss: yeah, esp. the manual flattening transforms.
13:44:11 <augustss> dons: exactly
13:44:12 <dons> but the DPH array library should help a *lot* there
13:44:18 <sorear> int-e: huh?
13:44:25 <dons> since it can do the flattening, and provides a bytestring interface.
13:44:28 <int-e> sorear: over not generating loops at all *g*
13:44:31 <dons> so that's upcoming in the next year or so
13:44:44 <Heffalump> flattening into a struct of arrays?
13:44:57 <sorear> int-e: still, you agree to code sucks? :)
13:45:03 <sorear> s/to/the/
13:45:10 <augustss> dons: I'll probably write something myself to help with this kind of code.  it's just some packing and unpacking.  The hard part will be to add deriving for it. :)
13:45:17 <int-e> sorear: oh yes, not having the loop variable in registers is bad.
13:45:25 <dons> Heffalump: e.g. UArray Int (P !Double !Double !Double) -> UArray Int Double
13:45:40 <gotaku> Why is State defined as "State s a" but it returns a result in the reverse order of (a, s)?
13:45:58 <dons> yeah, deriving woudl be good
13:46:18 <sorear> gotaku: that's the type - the actual data structure for state is identical to the return value of runState
13:46:20 <Heffalump> dons: but how is the data laid out? abcabcabcabcabc or aaaaabbbbbccccc?
13:46:22 <dons> derive the array instance with the associated type specifying the primitive type you pack to
13:46:32 <dons> abcabcabc currently
13:46:39 <dons> in our nbody benchmark
13:46:46 <dons> for the DPH array,s better check the src (I'm not sure)
13:46:46 <int-e> sorear: but the code still beats having an indirect jump in addition to that loop body.
13:46:57 <wishbone_> hi all
13:47:00 <augustss> dons: I've done that packing/flattening code both for Bluespec, and now at the bank
13:47:04 <dons> it'd be abcabcabc too I think, since you want to break into chunks and map
13:47:23 <wishbone_> I need help... how do I calculate th radix of 4
13:47:24 <dons> augustss: ah. nice. so we need that for UArrays now!
13:47:32 <augustss> dons: I know
13:47:35 <dons> ?hoogle radix
13:47:35 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
13:47:41 <sorear> wishbone_: numbers have radices?
13:48:03 <Heffalump> dons: yeah, precisely
13:48:08 <dons> > floatRadix 4 -- probably not what you want?
13:48:09 <lambdabot>  2
13:48:25 <augustss> > floatRadix pi
13:48:26 <lambdabot>  2
13:48:38 <dons> > decodeFloat pi
13:48:39 <lambdabot>  (7074237752028440,-51)
13:48:43 <sorear> > floatRadix (undefined :: Double)
13:48:44 <lambdabot>  2
13:48:54 <Saizan> can a Binary istance for an MArray be done? or should i freeze it before serializing?
13:48:58 <sorear> > floatRadix undefined
13:48:59 <lambdabot>  2
13:49:00 <augustss> > floatRadix undefined
13:49:01 <lambdabot>  2
13:49:08 <sorear> Saizan: absolutely node.
13:49:13 <sorear> s/node/not
13:49:24 <dons> Saizan: I'd freeze first.
13:49:42 <dons> which can be a non-copying operation..
13:49:47 <sorear> Saizan: bytestrings don't mutate. MArrays do.  therefore there can be no isomorphism
13:49:47 <wishbone_> ex radiz 4 = 2
13:49:55 <wishbone_> *radix
13:50:01 <sorear> wishbone_: OH - you mean the logarithm!
13:50:03 <dons> yeah, so your binary instance would need to freeze the array anyway
13:50:04 <sorear> > log2 3
13:50:04 <lambdabot>   Not in scope: `log2'
13:50:06 <sorear> > log
13:50:07 <gotaku> What is the "value" of a State represent? Why couldn't you just return the final state?
13:50:07 <lambdabot>  Add a type signature
13:50:09 <sorear> > log 2
13:50:10 <lambdabot>  0.6931471805599453
13:50:17 <sorear> > log 4 / log 2
13:50:19 <lambdabot>  2.0
13:50:24 <dons> > logBase 2 4
13:50:25 <lambdabot>  2.0
13:50:36 <Heffalump> gotaku: there's the value computed by the monadic computation, too
13:50:53 <sorear> @let log2 0 = undefined; log2 1 = 0 ; log2 x = 1 + log2 (x `div` 2)
13:50:54 <lambdabot> Defined.
13:50:58 <sorear> > log2 4
13:50:59 <lambdabot>  2
13:51:06 <sorear> wishbone_: this what you want?
13:51:09 <sorear> > log2 8
13:51:10 <lambdabot>  3
13:51:10 <sorear> > log2 9
13:51:12 <lambdabot>  3
13:51:13 <sorear> > log2 15
13:51:15 <lambdabot>  3
13:51:16 <sorear> > log2 16
13:51:18 <lambdabot>  4
13:51:31 <gotaku> Heffalump: Wouldn't the value just be the final State?
13:51:33 <sorear> > map (ap (,) log2) [1..]
13:51:35 <lambdabot>  [(1,0),(2,1),(3,1),(4,2),(5,2),(6,2),(7,2),(8,3),(9,3),(10,3),(11,3),(12,3),...
13:51:50 <sorear> > M.fromList $ map (ap (,) log2) [1..]
13:51:54 <lambdabot> Terminated
13:51:55 <sorear> that was stupid
13:51:56 <chessguy> gotaku, not necessarily. consider a function that uses a stack
13:52:02 <dons> I think you scared wishbone_ off, sorear
13:52:30 <chessguy> gotaku, the state would be the list of values on the stack, but the return value might be some particular value
13:52:44 <sorear> dons: with ap? :)
13:52:59 <chessguy> sorear, with like 30 lines of interaction with lambdabot
13:53:12 <wishbone_> sorear, I wanna calculate the distance between to points... to do this I need calculate radix of (x2 - x1)^2 + (y2 -y1)^2
13:53:23 <sorear> oh
13:53:26 <sorear> wishbone_: sqrt
13:53:27 <Heffalump> gotaku: it's like a computation of type IO a producing a value of type a
13:53:35 <gotaku> chessguy: Why not include this final value in the State?
13:53:38 <Heffalump> as well as affecting the state of the world
13:54:05 <sorear> > sqrt 2
13:54:06 <lambdabot>  1.4142135623730951
13:54:08 <chessguy> gotaku, consider a function that returns the sum of the values currently in the stack
13:54:22 <chessguy> say the stack contains [4,2]
13:54:22 <wishbone_> sorear, thanks! where can I see all functions I have?
13:54:31 <chessguy> you want to return 6, but not have it be in the state any more
13:54:32 <sjanssen> dons: the current typeof repo is broken
13:54:39 <dons> sjanssen: yeah, I know
13:54:41 <chessguy> err
13:54:44 <chessguy> s/any more/
13:54:47 <dons> oh, the *repo* ?
13:54:50 <dons> or the src.
13:54:51 <sorear> wishbone_: look at
13:54:55 <sorear> @docs
13:54:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:55:05 <sjanssen> dons: the repo is fine, but the vimscript doesn't work anymore
13:55:08 <sorear> also check out haskell.org/hoogle
13:55:12 <dons> yeah. that I noticed.
13:55:19 <gotaku> chessguy: Why not make the state a tuple then?
13:55:19 <sorear> @hoogle Double -> Double
13:55:20 <lambdabot> No matches, try a more general search
13:55:30 <sorear> @hoogle Floating a => a -> a
13:55:31 <lambdabot> Prelude.acos :: Floating a => a -> a
13:55:31 <lambdabot> Prelude.acosh :: Floating a => a -> a
13:55:31 <lambdabot> Prelude.asin :: Floating a => a -> a
13:55:51 <chessguy> gotaku, you certainly could, but that would get messy. 6 isn't really a part of the state
13:56:03 <ddarius> gotaku: Let's say you are labelling the leaves of a tree.  The state you have is a counter, an Int, the end result will be a Tree (Int,a).
13:56:30 <ddarius> gotaku: So you'd have a State Int (Tree (Int,a))
13:56:32 <chessguy> ddarius, changing the example in the middle is only going to make it more confusing
13:57:16 <ddarius> chessguy: I wanted an example where a) the result type is different than the state type and b) the state is only supporting the computation.
13:57:34 <wishbone_> @docs
13:57:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:57:58 <gotaku> Ok, I follow so far.
13:58:18 <wishbone_> sorear, ok, thanks!
13:59:13 <chessguy> ddarius, well, by all means, i'm sure i couldn't possibly be saying anything relevant. don't let me get in the way
14:02:03 <sjanssen> dons: unrecording maleberia's "Doesn't print decl again" fixes it.  But I bet you knew that
14:02:07 <nomeata> @where Probability
14:02:07 <lambdabot> I know nothing about probability.
14:02:28 <nomeata> On planet haskell, there was a blog involving some Probabilty module. Where can I find that?
14:02:32 * ddarius resists making the corny joke.
14:02:53 <chessguy> nomeata, i saw that, and it seems to me there was a citation with it
14:04:38 <dons> sjanssen: ah right. hmm. I thought he made sure vim didn't break :/
14:04:52 * dons should read patches more closely
14:05:32 <dons> I asked for the don't-print-decl feature (emacs only) be enabled with a flag
14:05:39 <chessguy> nomeata, hmmm. i must be thinking of something else. sorry
14:05:40 <newsham> where might I find documentation on GHC parsing/typing functions?
14:05:41 <nomeata> http://blog.mikael.johanssons.org/archive/2007/02/response-to-heath-raftery/ is the post, but I canât find it
14:05:46 <newsham> (ie. stuff called by shim)
14:05:47 <lambdabot> Title: Michi&#8217;s blog Â» Blog Archive Â» Response to Heath Raftery, http://tinyurl.com/28gdu3
14:06:04 <sorear> newsham:
14:06:11 <sorear> @where commentary
14:06:11 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
14:06:25 <sorear> gak, that's the old obsolete one
14:06:52 <chessguy> ?google filetype=hs Probability
14:06:53 <sorear> @where+ commentary http://hackage.haskell.org/trac/ghc/wiki/Commentary
14:06:54 <lambdabot> http://tunes.org/~nef/logs/haskell/05.05.30
14:06:54 <lambdabot> Done.
14:07:06 <newsham> thank you
14:08:32 <chessguy> ?hoogle filetype:hs Probability
14:08:33 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':hs Probab'
14:08:35 <dons> sjanssen: oh, :map ty :.w !typeof %
14:08:39 <dons> (I think?)
14:08:40 <chessguy> ?google filetype:hs Probability
14:08:41 <lambdabot> http://www.csse.monash.edu.au/~lloyd/tildeFP/II/200309/02Classes.hs
14:08:58 <wishbone_> please, what's wrong here...
14:08:59 <wishbone_> distance :: Point -> Point -> Float
14:09:00 <wishbone_> distance (x1, y1) (x2, y2) = sqrt( ((x2 -x1)^2) + ((y2 - y1)^2) )
14:09:10 <chessguy> hmm, that's not it either
14:09:15 <nomeata> nope :-(
14:09:19 <dons> wishbone_: always paste what error you get.
14:09:22 <dons> ?paste <-- here
14:09:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:09:35 <wishbone_> ERROR "/mnt/backup/cin/plc/triangulo.hs":6 - Type error in explicitly typed binding
14:09:36 <wishbone_> *** Term           : distance
14:09:36 <wishbone_> *** Type           : Point -> Point -> Int
14:09:36 <wishbone_> *** Does not match : Point -> Point -> Float
14:09:36 <sorear> @ty (^)
14:09:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:09:50 <nomeata> Or is there another library that easily gives me std. derivation etc.
14:09:59 <sorear> wishbone_: the pastebin makes it mcuh easier for us.
14:10:01 <chessguy> @type sqrt
14:10:02 <lambdabot> forall a. (Floating a) => a -> a
14:10:03 <sorear> ?paste
14:10:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:10:17 <nomeata> I mean standard distribution. Or was ist normal distribution?
14:10:26 <chessguy> nomeata, i'd try the applications & libraries link on the main wiki
14:10:28 <wishbone_> sorry
14:10:30 <ddarius> @type sqrt
14:10:31 <lambdabot> forall a. (Floating a) => a -> a
14:10:45 <sorear> wishbone_: np.  Every newbie makes that mistake (once)
14:11:15 <wishbone_> ?paste ERROR "/mnt/backup/cin/plc/triangulo.hs":6 - Type error in explicitly typed binding
14:11:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:11:15 <wishbone_> *** Term           : distance
14:11:15 <wishbone_> *** Type           : Point -> Point -> Int
14:11:15 <wishbone_> *** Does not match : Point -> Point -> Float
14:11:23 <sorear> wishbone_: what is the definition of Point
14:11:49 <sorear> wishbone_: you got the wrong window again :)
14:12:15 <sorear> oh no
14:12:20 * kolmodin goes to bed, good night!
14:12:24 <tibbe> night
14:12:54 <wishbone_> sorry again, how should I paste?
14:13:02 <sorear> the idea is you paste the code into the textbox on the page ?paste refers you to, then it temporarily hosts your code, nicely formatted and colored
14:13:13 <sorear> it also automatically gives the URL
14:13:24 <wishbone_> ?paste
14:13:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:13:32 <dons> sjanssen: this seems to work, :map ty yy:.!typeof -fbang-patterns %^Mp
14:13:37 <rodrigobamboo> hi, any HaXml guru around? I'm trying to port some scripts to haskell to get a feel for it
14:13:56 <sorear> anyway, looking at what you've already given us...
14:14:05 <sorear> wishbone_: what is the definition of Point?
14:14:12 <sorear> type Point = (Double, Double) ?
14:14:39 <nomeata> chessguy: actually, the Probabilty.hs from the planet was linked from there: http://web.engr.oregonstate.edu/~erwig/pfp/
14:14:41 <lambdabot> Title: PFP - Probabilistic Functional Programming in Haskell
14:14:41 <wishbone_> type Point = (Int, Int)
14:14:46 <rodrigobamboo> using HaXml, how can I select the "name" attribute for every "member" tag which contains an "exclude" child?
14:14:48 <hpaste>  wishbone_ pasted "(no title)" at http://hpaste.org/458
14:15:00 <chessguy> ahhh, ok
14:15:07 <chessguy> i wondered what PFP stood for
14:15:14 <sorear> ah.
14:15:19 <rodrigobamboo> <root><member name="foo" /><member name="bar"><exclude /></member></root>
14:15:31 <sorear> wishbone_: haskell doesn't automatically coerce Int to Float the way C does
14:15:39 <chessguy> nomeata, that must be the link i followed
14:15:43 <wishbone_> hummm
14:16:17 <dons> fromIntegral must be used to transform Int -> Double or Float
14:16:28 <nomeata> chessguy: with there, I mean the library list on the wiki
14:16:36 <nomeata> chessguy: well, I found it, so thanks :-)
14:16:42 <hpaste>  sorear annotated "(no title)" with "fixed" at http://hpaste.org/458#a1
14:16:47 <chessguy> sure. that's the important thing :)
14:17:17 <chessguy> he links to that page from his blog, too.
14:17:34 <sorear> dons: how would you feel about yi getting major modes?
14:18:10 <sorear> I've thunk a nice typesafe way to do it
14:18:17 <dons> sounds reasonable. as long as vim behaves like vim
14:18:30 <hpaste>  ookk annotated "(no title)" with "less like lisp" at http://hpaste.org/458#a2
14:18:32 <dons> you just need to associate a keybinding with a buffer
14:18:38 <dons> or a window
14:18:40 <chessguy> ?where yi
14:18:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
14:18:52 <dons> sorear: how's vty coming along?
14:19:04 <dons> have you ported yi to the new interface? is it usable?
14:19:17 <sorear> not yet :(
14:19:20 <gotaku> chessguy: What if I only care about the final state of a computation?
14:19:33 <gotaku> What is Yi anyway?
14:19:39 <dons> ?where yi
14:19:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
14:19:40 <wishbone_> sorear, oh thanks! it's working! sorry for the newbie error ;)
14:19:42 <chessguy> ?hoogle runState
14:19:42 <dons> ^^ explains all
14:19:42 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
14:19:42 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
14:19:46 <sorear> gotaku: a super-secret text editor
14:19:55 <chessguy> ?hoogle evalState
14:19:55 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
14:19:55 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
14:20:01 <chessguy> ?hoogle executeState
14:20:01 <lambdabot> No matches found
14:20:04 <allbery_b> execState
14:20:11 <chessguy> ?hoogle execState
14:20:11 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
14:20:12 <lambdabot> Control.Monad.State.execStateT :: Monad m => StateT s m a -> s -> m s
14:20:12 <sorear> ?hoogle exeState
14:20:12 <lambdabot> No matches found
14:20:22 <allbery_b> ?hoogle execState
14:20:23 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
14:20:23 <lambdabot> Control.Monad.State.execStateT :: Monad m => StateT s m a -> s -> m s
14:20:27 <chessguy> gotaku, look at those three. the only difference is in what they return'
14:20:45 <chessguy> gotaku, one returns just the value, one returns the state, one returns both
14:20:49 <gotaku> chessguy: But what type would the State be?
14:21:01 <gotaku> Yi has no syntax highlighting?
14:21:04 <chessguy> whatever you want it to be
14:21:08 <dons> gotaku: it does now, yes.
14:21:12 <dons> darcs version only.
14:21:23 <dons> the next release will support syntax highlighting, amongst other things
14:21:33 <dons> (oh, and a new gtk frontend)
14:21:35 <chessguy> does it do delimiter-matching?
14:21:44 <sorear> it will
14:21:45 <dons> not that I know of. wouldn't be hard though now.
14:21:46 <newsham> how feasible would it be to take a complex expression (say a large function), parse and type check it, and then track back the types to some subexpression in the original text?
14:22:05 <sorear> newsham: very
14:22:29 <newsham> isnt there a lot of renaming and desugaring going on though?
14:22:36 <dons> I think its time lambdabot updated to ghc 6.6
14:22:38 <gotaku> Ah, 750 patches...
14:22:50 <sorear> newsham: renaming yes. desugaring no.
14:22:59 <newsham> dons: builds/runs in ghc6.6 on win32 ;-)
14:23:01 <sorear> newsham: GHC does typechecking *before* desugaring
14:23:35 <sorear> (and de-renaming isn't hard - just delete qualifiers)
14:23:51 <gotaku> Would it be possible to automatically add type signatures to sourcecode?
14:24:04 <sorear> gotaku: yes.
14:24:20 <sorear> gotaku: in shim, C-c C-n to add a typesig to the current function.
14:24:31 <gotaku> shim?
14:24:47 <dons> gotaku: yeah, and with typeof
14:24:52 <newsham> > (dropWhile (\y -> magnitude y <= 2.0) $ take 256 $ iterate (\y -> y*y+c) 0) (0.5 :+ 0.9)
14:24:53 <dons> ?where typeof
14:24:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/typeof/
14:24:57 <lambdabot>   Not in scope: `c'
14:25:14 <newsham> > let c = (0.5 :+ 0.9) in (dropWhile (\y -> magnitude y <= 2.0) $ take 256 $ iterate (\y -> y*y+c) 0)
14:25:22 <lambdabot>  [(-2.7364) :+ 0.6839999999999998,7.520028960000001 :+ (-2.8433951999999993),...
14:25:35 <newsham> > let c = (0.5 :+ 0.9) in length $ (takeWhile (\y -> magnitude y <= 2.0) $ take 256 $ iterate (\y -> y*y+c) 0)
14:25:36 <lambdabot>  3
14:25:54 <newsham> i would like to be able to do things like ask what is the type of the takeWhile... subexpr
14:26:24 <gotaku> Does yi have a gtk2hs interface?
14:26:29 <newsham> got: yes
14:26:36 <newsham> build in the gtk subdir of yi
14:27:09 <dons> hmm. I wonder how much faster some things will be if I build the whole base libs with -march=pentium4
14:27:27 <newsham> dons: 1 way to find out :)
14:27:39 <newsham> ?where shim
14:27:39 <lambdabot> http://shim.haskellco.de/trac/shim
14:27:49 <benomatic> anybody here ever done the scheme in 48 hrs tutorial?
14:28:11 <gotaku> I think I'm going to wait until the new penryn chips come out before I upgrade my aging AMD Thunderbird.
14:28:18 <dons> @seen nostrademons
14:28:18 <lambdabot> I saw nostrademons leaving #haskell and #oasis 17h 38m 17s ago, and .
14:28:23 <chessguy> benomatic, i've looked at it, but it's pretty tough
14:28:27 <dons> benomatic: you just missed the author ^^
14:28:58 <chessguy> dons, who, bringert?
14:29:08 <dons> nostrademons
14:29:19 <sjanssen> say I have functions with types like (a -> IO b) -> IO b (alloca is one example) -- I want to write a function that lifts the alloca into a StateT.  Is there a preexisting function that does this?  What's a good name for this function?
14:29:43 <dons> hmm.
14:29:59 <dons> ?hoogle (a -> IO b) -> IO b
14:30:00 <lambdabot> Control.Concurrent.MVar.withMVar :: MVar a -> (a -> IO b) -> IO b
14:30:00 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:30:00 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
14:30:09 <dons> ?hoogle+
14:30:09 <lambdabot> Control.Exception.catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
14:30:09 <lambdabot> Control.Exception.handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
14:30:09 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
14:30:14 <dons> fixio eh?
14:30:15 <sjanssen> withMVar is another good one
14:30:19 <newsham> sjanssen: cant you just use "lift" to run any IO within the StateT?
14:30:25 <benomatic> heh.  i'm stuck fairly early on (3.3), primarily cuz i don't have a full grip on monads (shocking).  rather than spewing out my broken code, was trying to find a sol'n so i can step on.  problem is that i haven't found one posted online yet :)
14:30:38 <sjanssen> dons: the concrete function is allocaXEvent
14:30:48 <dons> ?paste the code, perhaps?
14:30:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:31:01 <sjanssen> newsham: but I also want the lifted function to modify the state in StateT
14:31:05 <dons> sjanssen: hmm. I'm sure there's a combinator for this, it just might not be written anywhere yet
14:31:34 <gotaku> Well that was easy... I got that Monadius game to run in Linux.
14:31:42 <newsham> sjanssen:  do { x <- lift $ alloca ...; modify $ set_x x} ?
14:32:41 <hpaste>  sjanssen pasted "the issue" at http://hpaste.org/459
14:32:54 <sjanssen> this does what I want, but it's quite ugly
14:33:23 <gotaku> Why is initializing glut not a requirement on Windows?
14:33:35 <sjanssen> and it also leaks the fact that Wm is a MonadState -- which I'd like to abstract
14:34:32 <sorear> sjanssen: you want metalift
14:34:51 <sjanssen> sorear: is that an existing combinator, or just a name suggestion?
14:35:27 <sjanssen> (forall b. (a -> IO b) -> IO b) -> (a -> Wm c) -> Wm c -- is the type of what I need (I think)
14:35:32 <sorear> sjanssen: existing yes, standard no.  it's something I want added to the stdlibs, and I believe it handles your case well
14:35:36 <sorear> sjanssen: what's l?
14:35:46 <sjanssen> sorear: liftIO
14:35:56 <sorear> ok.
14:36:07 <sorear> now rewriting in terms of metalift ...
14:36:17 <sjanssen> sorear: what's the type of metalift?
14:37:09 <sorear> metalift :: (Monad m1, Monad m2, Metalift t) => (forall a. m1 a -> m2 a) -> t m1 b -> t m2 b
14:37:26 <sorear> Metalift might be MonadTrans, I'm not sure
14:38:07 <sorear> someone pointed out a couple weeks ago that metalift is a very fundamental operation in CT - it is the natural transformation of a monad transformer
14:38:24 <sorear> not that I really understand what a natural transformation is ..
14:39:46 <ddarius> sorear: You don't understand polymorphic functions?
14:43:12 <newsham> ahh.. allocaXEvent takes a function/action thingy
14:43:33 <sjanssen> newsham: right
14:43:39 <sorear> anyway sjanssen:
14:44:35 <sorear> metalift can be typed at (forall a. ReaderT r IO a -> IO a) -> StateT s (ReaderT r IO) b -> StateT s IO b
14:45:05 <sorear> ReaderT commutes with StateT, so that is isomorphic to the type you want for your lifter
14:45:43 <newsham> can you capture the state in a closure that gets passed ti allocaXEvent and then have it written back to the state when done?
14:46:03 <newsham> doesnt lambdabot have a lifter thing like this?
14:46:22 <sorear> newsham: yes.
14:46:30 <newsham> lbIO
14:46:40 <sorear> liftLB, mapReaderT, lbIO, etc - all adominations
14:46:47 <sorear> we need this generical
14:47:07 <Syzygy-> liftLB??
14:47:18 <newsham> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
14:47:18 <newsham> lbIO k = LB . ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
14:47:53 <gotaku> ... I'm still having trouble with just the concept of lifting.
14:49:08 <sjanssen> sorear: are you sure I can write my function with metalift?
14:49:11 <dibblego> ?docs NonEmptyList
14:49:11 <lambdabot> NonEmptyList not available
14:49:44 <sorear> sjanssen: yes
14:49:53 <newsham> to be generic you'd have to know how to run your machine, and how to put back any modifications, no?
14:50:13 <newsham> ie. parameterized on runStateT and put.
14:50:20 <newsham> and get.
14:50:43 <sjanssen> sorear: can you demonstrate?
14:50:46 <sorear> sjanssen: well, I'll also need a function (WmT (ReaderT r) b -> ReaderT r Wm b), but that's just a small matter of fiddling newtypes...
14:51:06 <sjanssen> note that I need to put the state changes back
14:51:12 <sorear> since r -> s -> IO (a, s) and s -> r -> IO (a, s) are the same
14:51:30 <sorear> sjanssen: I believe mine will put them back
14:51:48 <sjanssen> sorear: the Wm stuff is inconsequential, StateT a m b is fine
14:53:15 <sorear> ok
14:53:36 <sorear> gah, this type inference stuff is soo confusing
14:54:03 <sorear> Right now I think I'd be better off with System-Fw style type lambdas and type-d lambdas
14:54:13 <sorear> all explicit
14:55:01 <sorear> oh wait, GHC allows typed lambda bindings
14:55:16 <sorear> I think I'll use that and type erase right before pasting :)
14:56:09 <hpaste>  sjanssen annotated "the issue" with "final solution -- I'm still not sure about the withIO name" at http://hpaste.org/459#a1
14:57:36 <newsham> Wm is StateT IO ?
14:58:11 <sjanssen> newtype Wm a = Wm (StateT WmState IO a)
14:59:53 <newsham> hmm.. if you instance MonadState Wm you can avoid "Wm get" and "Wm put" no?
15:00:25 <sjanssen> newsham: I want to avoid writing that instance -- because it breaks the Wm abstraction
15:00:37 <dibblego> data NonEmptyList a = NEL a [a] -- is it possible to reverse this in O(n)? my intuition says of course, but I keep failing
15:00:44 <newsham> oh, you dont want people peeking into the state normally?
15:00:57 <Igloo> But you can make a MonadWm with getWm or whatever in it, and have that do the lifting for you
15:01:34 <sjanssen> say my application goes multithreaded -- it might go from StateT x to ReaderT (MVar x)
15:01:55 <dcoutts> gotaku, what's the problem with autoconf & gtk2hs?
15:01:58 <newsham> is this a case for withStateT?
15:02:26 <sorear> dobblego: revNel (NEL a as) = NEL b bs where (b:bs) = reverse (a:as)
15:02:28 <newsham> withStateT (l $ f $ \x -> runWm (g x)) ?
15:02:30 <dcoutts> dons, so today I'm going to send some patches reorganising the fps-experimental repo
15:02:40 <dibblego> sorear, of course, thanks
15:02:53 <sjanssen> newsham: I don't think that will work -- g :: a -> Wm b
15:03:02 <sorear> sjanssen: gha, I give up.  too many newtype constructors.
15:03:06 <dcoutts> dons, removing the old fusion stuff, putting the newest streams stuff in and adding list bits
15:03:10 <Igloo> dcoutts: Where are you? Or is that today for dons?
15:03:13 <sjanssen> g isn't just a state transformation -- it's a full-fledged Wm action
15:03:31 <dcoutts> Igloo, erm ok today for me in an hour, ie Monday.
15:03:43 <dons> dcoutts: ok. sounds good!
15:03:57 <Igloo> hmm, OK
15:04:07 <sjanssen> dcoutts: in fps-unstable or base?
15:04:09 <Cale> @where fptools
15:04:09 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
15:04:14 <gotaku> dcoutts: Something about an unknown macro.
15:04:17 <dcoutts> sjanssen, fps-unstable
15:04:39 <dcoutts> gotaku, can you @paste ? and what autoconf & automake versions?
15:04:43 <Cale> @src Data.Dynamic
15:04:43 <lambdabot> Source not found. You speak an infinite deal of nothing
15:04:49 <Cale> @libsrc Data.Dynamic
15:04:49 <lambdabot> Unknown command, try @list
15:04:55 <Cale> hmm
15:05:00 <dons> is the arrows package only in the head?
15:05:04 <gotaku> dcoutts: No,I using the tar.gz source now so I can't really remember the error.
15:05:04 <sjanssen> dcoutts: making Stream polymorphic too?
15:05:06 <dons> Control.Arrow.Transformer.* ?
15:05:12 <Cale> @list
15:05:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:05:21 <dcoutts> gotaku, oh but then you didn't need to autoreconf right?
15:05:23 <chessguy> @source Data.Dynamic
15:05:23 <lambdabot> http://darcs.haskell.org/packages/base/Data/Dynamic.hs
15:05:25 <dons> Cale, any requests for extra modules to include with @eval in ghc 6.6?
15:05:30 <dons> I'm updating right now.
15:05:32 <chessguy> Cale, ^^ perhaps this is what you want?
15:05:36 <dons> Control.Applicative, for one..
15:05:38 <dcoutts> gotaku, I mean the tar.gz already contains the ./configure
15:05:38 <gotaku> dcoutts: Guess not.
15:05:44 <Cale> dons: The new stuff :)
15:06:01 <Cale> dons: Data.Traversable Data.Sequence Data.Foldable, etc. would be cool :)
15:06:02 <dons> I'm thinking of adding Control.Arrow.Transformer* (in the arrows package) too
15:06:03 <sjanssen> dons: import Data.Foldable qualified might be nice
15:06:04 <dcoutts> dons, and I might send some stuff to convert the LPS data rep
15:06:05 <newsham> heavy lifting.
15:06:07 <dons> yeah got those.
15:06:11 <dons> dcoutts: ok.
15:06:19 <newsham> too bad a compiler cant do all the heavy lifting :)
15:06:27 <Cale> chessguy: yes, thanks
15:06:55 <gotaku> dcoutts: Ok, I just ran autoreconf and got no error.
15:06:56 <dcoutts> dons, I really want to play with the new spec const stuff with a nicer LPS representation. I want to do automatically that transform that you did manually for the shootout.
15:07:00 <sorear> dons: I'd like pretty much all of hackage available to the non-eval commands (@type, @index, etc)
15:07:10 <beschmi> hey newsham, just read your mail about shim on win32. i'll try to set up ghc and emacs on windows later, can you try if a minimal program using newSession crashes too?
15:07:11 <bd_> dons: Does this mean hs-plugins works in 6.6 now? :)
15:07:16 <dons> dcoutts: yes. that sounds like a good plan
15:07:17 <dons> bd_ yes
15:07:24 <newsham> besch: see latest email.. i solved.
15:07:25 <bd_> nice!
15:07:49 <newsham> i wrote minimal program and tracked it down to the path having \r\n and only the \n being stripped
15:07:54 <dons> is there any pure STM we can play with?
15:08:05 <dons> sjanssen: also, how about Parallel.Strategies?
15:08:07 <dons> :-)
15:08:22 <sjanssen> dons: yes, strats might be useful
15:08:28 <sorear> dons: is your 16-core box unboxed yet?
15:08:29 <beschmi> newsham: oh, cool
15:08:42 <dons> sorear: not yet. Its too wet today to go into uni
15:08:46 <sorear> dons: how does PQC sound?
15:09:05 <dons> hmm. nice.
15:09:23 <sjanssen> dons: not many interesting things you can do with STM without forkIO and atomic -- which have IO types
15:09:32 <dons> yeah.
15:09:33 <dons> oh well
15:09:50 <sorear> you can disprove the monad laws! </flamebait>
15:10:17 <sjanssen> I'm really tired of monad laws emails :)
15:10:21 <dons> heh
15:10:23 <sorear> I'd like fuller HPaste integration
15:10:57 <sjanssen> I want hpaste to attempt typechecking pastes
15:11:12 <newsham> then you couldnt include error messages and such...
15:11:15 <sjanssen> that'd be really nice for newbies that just say "it doesn't work!"
15:11:15 <gotaku> dcoutts: The the darcs branch of gtk2hs requires happy?
15:11:17 <sorear> sjanssen: and running them!
15:11:27 <mightybyte> I'm looking to learn haskell by developing a web app.  Any suggestions as to what libraries I should use/look at?
15:11:28 <sorear> newsham: {- -}
15:11:38 <sorear> mightybyte: HAppS
15:11:41 <sjanssen> sorear: small steps first
15:11:43 <newsham> yah, hpaste should run writeFile "/etc/passwd" "pwned"
15:11:48 <sorear> @where hpaste
15:11:48 <newsham> ;-)
15:11:48 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
15:11:51 <dons> mightybyte: the network package, happs, and haxml
15:11:56 <dons> i.e. start with hpaste and haxml
15:12:06 <mightybyte> What about HSP?
15:12:08 <newsham> ?where pass.net
15:12:09 <sorear> newsham: the problem has already been solved.  see Plugins/Eval.hs
15:12:09 <lambdabot> I know nothing about pass.net.
15:12:15 <newsham> sorear: i'm aware.
15:12:29 <newsham> > writeFile "/tmp/gotcha" "dootdeedoo"
15:12:32 <lambdabot>  <IO ()>
15:12:55 <sorear> newsham: security through visibility - how about allowing IO but only importing putStr etc?
15:13:37 <newsham> i like no-IO :)
15:13:43 <sorear> (better idea - import a phony IO module which uses continuations to implement putStr etc)
15:14:22 <newsham> ?uptime
15:14:22 <lambdabot> uptime: 3h 13m 51s, longest uptime: 2d 17h 27m 21s
15:14:27 <newsham> ?farber
15:14:27 <lambdabot> Unknown command, try @list
15:14:35 <sorear> ?make
15:14:35 <lambdabot> Maybe you meant: map more
15:14:37 <sorear> ?reload
15:14:37 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
15:14:43 <sorear> :)
15:15:31 <chessguy> ?hoogle MonadState
15:15:32 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
15:15:50 <chessguy> ?source MonadSTate
15:15:51 <lambdabot> MonadSTate not available
15:15:53 <chessguy> ?source MonadState
15:15:53 <lambdabot> MonadState not available
15:16:31 <newsham> LogoIn48Hours?
15:16:53 <dons> RubyIn24Hours?
15:16:56 <sorear> chessguy:
15:17:03 <sorear> @source Control.Monad.State
15:17:03 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
15:17:06 <newsham> dons: can it be done?
15:17:11 <sorear> ^^^ explains everythingk
15:17:20 <chessguy> ya, found it
15:17:31 <chessguy> not sure i understand the difference between State and MonadSTate
15:17:37 <sorear> ?src MonadState
15:17:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:17:48 <newsham> chess:  State is just one instance of MonadState
15:17:51 <sorear> chessguy: MonadState is a class.  State is a tycon
15:18:19 <chessguy> oh, so MonadState is a subclass of Monad?
15:18:30 <newsham> MonadState is something that gives you "get" and "put"
15:18:40 <newsham> StateT and State both do that
15:21:18 <newsham> chess: if I define some other complex monad thingamabob that also lets me get and put some state, I can make it an instance of MonadState and inherit all the modify/gets goodness
15:28:23 * ddarius understands his old code again.
15:29:07 <dcoutts> gotaku, yes. Since c2hs's C parser uses happy.
15:31:19 <DukeDave> Hey gang, slightly off topic question; but I know someone here is bound to know the answer :)  ..
15:31:27 <HaskellNoob> how do you extract a char from a string? For example say I want to extract C from "thisChar".
15:31:38 <russo> he is there a function in haskell like reduce
15:31:56 <DukeDave> in an equation like     = ax + by + c        what are a, b, c called?
15:32:09 <Saizan> coefficients?
15:32:22 <ndm> @seen syntaxfree
15:32:22 <DukeDave> that rings a bell :)
15:32:22 <lambdabot> I saw syntaxfree leaving #haskell-blah, #haskell-overflow and #haskell 1h 29m 20s ago, and .
15:32:24 <russo> something that takes all the elements of the function and applies a function using infix operation
15:32:47 <Saizan> russo: that sounds like foldr
15:32:49 <russo> i.e. reduce + [a,b,c] = a + b + c
15:32:53 <ddarius> russo: or foldl'
15:32:57 <dons> > filter (=='C') "thisChar"
15:32:59 <lambdabot>  "C"
15:33:00 <russo> aha
15:33:07 <DukeDave> HaskellNoob,  do you want the character at a certain position (index) ?
15:33:09 <dons> :t find
15:33:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:33:13 <Saizan> > foldr (+) 0 [1..3]
15:33:14 <lambdabot>  6
15:33:20 <russo> sweet
15:33:21 <dons> > find (=='C') "thisChar"
15:33:23 <lambdabot>  Just 'C'
15:33:29 <DukeDave> > "thisChar"!!4
15:33:30 <lambdabot>  'C'
15:33:30 <dons> > elemIndex 'C' "thisChar"
15:33:32 <lambdabot>  Just 4
15:33:36 <ddarius> > foldl' (+) 0 [1,2,3]
15:33:37 <lambdabot>  6
15:33:41 <dons> ?docs Data.List
15:33:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:33:44 <dons> HaskellNoob: ^^
15:33:50 <DukeDave> cheers Saizan  :)
15:34:01 <Saizan> :)
15:34:35 <russo> > foldr (and) true map (=1) [1..6]
15:34:36 <lambdabot>  Parse error
15:34:38 <russo> doh
15:35:11 <Saizan> > foldr (and) True (map (==1) [1..6])
15:35:11 <russo> do i need commas there
15:35:11 <lambdabot>      Expecting a function type, but found `Bool'
15:35:11 <lambdabot>       Expected type: [Bool] ...
15:35:18 <russo> oh crap
15:35:19 <russo> thanks :P
15:35:23 <DukeDave> makes my documentation read a little more authoritative than "the numbers you multiply the other things by"  ;)
15:35:32 <bd_> russo:
15:35:38 <russo> bd_:
15:35:40 <bd_> > foldr (&&) True (map (==1) [1..6])
15:35:41 <lambdabot>  False
15:35:44 <russo> yeah :)
15:35:45 <russo> i got it now
15:35:49 <bd_> :)
15:35:58 <bd_> and = foldr (&&) True
15:35:59 <russo> > :type &&
15:35:59 <lambdabot>  Parse error
15:36:00 <bd_> > and []
15:36:01 <lambdabot>  True
15:36:05 <bd_> :t (&&)
15:36:06 <lambdabot> Bool -> Bool -> Bool
15:36:35 <russo> aha :)
15:36:37 <russo> cool
15:36:57 <russo> > foldr (&&) True map (==1) [1..6]
15:36:58 <lambdabot>  Couldn't match `Bool' against `t -> t1 -> t2'
15:37:06 <russo> doh :P i thought it might work without ()
15:37:08 <russo> but no
15:37:17 <ddarius> @src and
15:37:18 <lambdabot> and   =  foldr (&&) True
15:37:18 <Saizan> > foldr (&&) True $ map (==1) [1..6]
15:37:20 <lambdabot>  False
15:37:27 <sorear> > and (map (==1) [1..6])
15:37:28 <lambdabot>  False
15:37:32 <russo> what does $ do?
15:37:35 <sorear> > all (==1) [1..6]
15:37:37 <lambdabot>  False
15:37:38 <russo> is that an escape character?
15:37:43 <ddarius> Technically, ($) = id
15:37:47 <russo> oic
15:37:48 <bd_> :t ($)
15:37:49 <lambdabot> forall b a. (a -> b) -> a -> b
15:37:52 <bd_> ?src ($)
15:37:52 <lambdabot> f $ x = f x
15:37:53 <Saizan> it's like an open braket that extends till the end of the expression
15:38:05 <russo> man i love functional languages :)
15:38:05 <bd_> hm, @src should report fixitys
15:38:10 <ddarius> Except that it's just a normal user-defined operator.
15:38:27 <Saizan> @info ($)
15:38:28 <lambdabot> ($)
15:38:44 <gotaku> dcoutts: Did someone update the gtk2hs source recently? I'm not getting the error anymore.
15:39:18 <chessguy> ?hoogle abs
15:39:19 <lambdabot> Prelude.abs :: Num a => a -> a
15:39:19 <lambdabot> System.IO.AbsoluteSeek :: SeekMode
15:39:19 <lambdabot> Language.Haskell.Syntax.HsEAbs :: HsQName -> HsExportSpec
15:39:55 <newsham> > abs $ 3 - 10
15:39:56 <lambdabot>  7
15:41:28 <sorear> If I want to understand the design space for syntax highlighting, what editors should I look at besides emacs and vim?
15:42:52 <dons> > reverse []
15:42:53 <lambdabot>  Add a type signature
15:42:59 <dons> that's fixed in ghc 6.6
15:43:04 <dons> (yay), more defaulting!
15:43:16 <dcoutts> gotaku, yeah, axel added some macros to acinclude.m4 so that it'd still work with older versions of autoconf
15:43:23 <ddarius> What are the choices in syntax highlighting?  Isn't it essentially just how smart you want to be about parsing the text?
15:43:37 <sorear> ddarius: efficiency
15:43:44 <sorear> how to cache, etc
15:43:45 <dcoutts> gotaku, I was using things from autoconf 2.61 and many people still use 2.59 (eg Axel)
15:43:47 <newsham> sorear: source insight?  visual studio?
15:43:55 <sorear> I'm studying implementation techniques
15:44:02 <ddarius> Doesn't Eclipse do some interesting things?
15:44:14 <newsham> also what about the haskell prettyprinters (ie. .lhs -> latex)
15:44:24 <sorear> newsham: aren't there like, major restrictions on what you can do after looking at the VS sources?
15:44:28 <sorear> :_
15:44:29 <sorear> :)
15:44:31 <dcoutts> ddarius, you can do regex stuff or proper lexing
15:44:51 <newsham> you didnt say source.
15:45:05 <gotaku> dcoutts: I'm using autoconf 2.61 as well.
15:45:07 <sorear> I did
15:45:14 <dcoutts> gotaku, dunno then
15:45:16 <sorear> newsham: ddarius didn't start this
15:45:26 <ddarius> dcoutts: Or proper parsing
15:45:44 <ddarius> and continue with semantic features.
15:45:48 <sorear> I want to implement good synhl in yi, and I am not one to ignore prior art
15:46:08 <dcoutts> ddarius, right but that's rarely necessary just for syntax highlighting
15:46:30 <ddarius> dcoutts: It's nice though.
15:46:50 <ddarius> As I said, it depends on how smart you want to be.
15:46:51 <dcoutts> ddarius, and even if it allowed you to do more syntax highlighting, I'm not sure it's a great idea since then the code looks different when it compiles vs when you've got a mistake.
15:47:16 <dcoutts> with just lexical stuff it's less sensitive to syntactic correctness
15:47:18 <ddarius> dcoutts: That makes mistakes more glaring.
15:47:35 <sorear> I want editor suggestions, not idea suggestions
15:47:49 <dcoutts> ddarius, well you can do that with squiggly red underlining etc for all compiler errors. hIDE did that.
15:48:03 <ddarius> sorear: Visual Studio, Eclipse, maybe Epigram
15:48:39 <yip> dons: you have an archive of all of the messages to a haskell@cs.glasgow.ac.uk mailing list on your website.... have you read all of these messages?
15:48:46 <ddarius> dcoutts: I'd consider potentially part of syntax highlighting depending on how it was presented (albeit syntax becomes a somewhat weak work then)
15:49:35 <ddarius> sorear: Some of the Lisp environments perhaps, CLIM, SLIME, ?
15:49:46 <ddarius> s/work/word
15:49:48 <newsham> genera ;-)
15:50:12 <newsham> hopefully i'll hvae a machine capable of running genera next month
15:50:28 <sorear> ddarius: how different is SLIME/CLIM from raw emacs? I'm not writing the whole editor, just designing the basic abstractions.
15:50:31 <newsham> i think it will be enlightening
15:50:40 <dons> yip, not all. i've read a lot of them though
15:50:58 <ddarius> sorear: 'haven't the foggiest.  I've never used either.
15:51:02 <gotaku> How do I have ghc place the .o and .hi files in a different directory?
15:51:13 <dons> -odir foo
15:52:14 <yip> dons: is it worth it to read through them all?
15:52:36 <dons>  umm. maybe?
15:52:40 <dons> there's some good ones
15:52:49 <newsham> sorear: some lisp environments are quite a bit more advanced than emacs.  see this video for example: http://ftp.linux.org.uk/pub/lisp/lispm/lispm-3.mov
15:53:02 <ddarius> sorear: DrScheme may also be worth looking at.
15:53:06 <MarcWebe1> Do you know where I can find the binary package used by darcs version of HAppS?
15:53:25 <newsham> ?where hackage
15:53:25 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
15:53:31 <newsham> its on the package page, marc
15:53:51 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.2
15:53:53 <lambdabot> http://tinyurl.com/25xp35
15:54:04 <dons> everything good is on hackage! :-)
15:54:22 <ddarius> dons: Wow.  That simplifies life.
15:54:34 <newsham> System.FilePath is not on hackage.  therefore not good?
15:54:43 <gotaku> dons: GHC is still putting .hi files in my source directory.
15:54:50 <yip> anyone know who Mark P Jones is?
15:54:50 <dons> -hidir foo
15:54:52 <dons> -odir foo
15:54:55 <dons> (check the docs)
15:55:06 <dons> yip, yeah, inventor of Gofer, Hugs, MPTCs (well, sort of ;)
15:55:28 <dons> ddarius: right. CPAN for haskell
15:55:43 <dons> its only a couple of weeks old, but already it is the only place I go to for new stuff
15:55:44 <MarcWebe1> Thanks. Will http://haskell.org/haskellwiki/Libraries_and_tools be included in hackage then one day?
15:55:45 <lambdabot> Title: Libraries and tools - HaskellWiki
15:55:50 <gotaku> What are .hi files anyway?
15:55:53 <dons> all of it, yeah.
15:55:58 <dons> as things are released with cabal
15:56:06 <ndm> newsham: no, its very good
15:56:10 <hyrax42> dons: is it already getting far enough along for that?
15:56:15 <dons> yeah
15:56:25 <dons> there's some 100 packages up there now, we could add another 500 or so I guess
15:56:30 <ndm> newsham: and will be in base very shortly - the things in hackage are arbitrary for now, i think
15:56:34 <hyrax42> hmmmm
15:56:35 <dons> there's a lot of small cabalised code around now
15:56:43 <hyrax42> cool
15:56:50 <hyrax42> what are the rough edges that are left
15:56:52 <newsham> ndm: (everything good is on hackage) and (System.FilePath is not on hackage)
15:56:55 * ndm would add FilePath to base now, if he had time
15:57:06 <allbery_b> gotaku: import files, which ghc uses to determine what names and types are exported by a module
15:57:14 <dons> ndm should put FilePath on hackage!
15:57:16 <ndm> newsham: System.FilePath is going into base, it has had permission for 2 months - i just haven't had the time
15:57:26 <ndm> dons should do it for ndm ;)
15:57:30 <newsham> my logic system has been confused
15:57:42 <ndm> newsham: base is not in hackage...
15:58:05 <sjanssen> but we won't observe the changes in base for quite some time
15:58:24 <ndm> dons: last time i uploaded to hackage i crashed it once, exposed 2 new bugs in cabal and created the "Safe" category - not a pleasant experience
15:58:57 <dons> fixed. don't give up.
15:59:28 <dons> its pretty pain free now, I've not had any trouble
15:59:29 <ndm> the bugs in Cabal are still there, it fails to create an appropriate tarball to upload
15:59:38 <dons> oh, use darcs dist
15:59:39 <ndm> they are windows cabal bugs...
15:59:49 <dons> assuming you use darcs...
16:00:08 <ndm> of course ;)
16:00:19 <sorear> Cabal doesn't make good tarballs?
16:00:25 <ndm> not on windows
16:00:39 <dons> darcs dist is nicer, imo. since even if you miss some things in the .cabal file about extra-files (e.g. README), darcs dist wil get it
16:00:47 <sorear> so I should stop using ./Setup.lhs sdist to generate my release tars?
16:00:55 <sjanssen> probably because Windows doesn't have tar
16:00:58 <ndm> on windows it runs the entire command on a directory that doesn't exist-  cabal gets upset, tar gets upset
16:01:12 <ndm> sjanssen: i have tar, its nothing to do with that
16:01:14 <dons> sorear: if cabal's sdist works, use it
16:01:14 <sorear> dons: that's an anti-feature, since it encourages people to sloppily omit things
16:01:34 <tuukkah> fenfire-hs starts to look like a real gtk app: http://iki.fi/Tuukka/tmp/fenfire-hs_darcs-2007-02-12.png
16:01:36 <dons> yeah, if cabal's sdist works for you, use it. otherwise darcs dist is a reasonable quick fix.
16:04:00 * ndm curses latex and underscores
16:04:26 <newsham> <- underscores curses and latex
16:05:37 <russo> what is the non list kind of or
16:05:43 <russo> so like and (&&)
16:05:46 <russo> but for or
16:05:49 <dons> ||
16:05:50 * nomeata likes latex and to score under curses
16:06:01 <dons> > False || True
16:06:09 <lambdabot>  True
16:06:37 <russo> > "russo" > "lambdabot"
16:06:39 <lambdabot>  True
16:06:41 <russo> :)
16:07:08 <ddarius> @hoogle Bool -> Bool -> Bool
16:07:09 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
16:07:09 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
16:08:03 <allbery_b> > "Î»bot" > "everyone"
16:08:05 <lambdabot>  True
16:08:09 <LoganCapaldo> @pl (\x y -> or [x, y])
16:08:09 <lambdabot> (or .) . (. return) . (:)
16:08:32 <russo> what?
16:08:41 <ndm> when writing an academic paper, should functions be in Haskell or Maths?
16:08:43 <russo> what does @pl do
16:08:52 <LoganCapaldo> @help pl
16:08:52 <lambdabot> pointless <expr>. Play with pointfree code.
16:08:53 <ddarius> ndm: Depends on the paper.
16:09:06 <russo> ndm: i'd think in maths
16:09:12 <ndm> mathematical functions, but which are obviously implemented in haskell for the underlying system, but which are in the mathematical domain
16:09:18 <russo> ndm: unless this is for a funcitonal programming class
16:09:20 * ndm misses pattern matching and types in maths
16:09:30 <LoganCapaldo> > (or .) . (. return) . (:) True False
16:09:31 <russo> not that this would differ too much :P
16:09:31 <lambdabot>      Expecting a function type, but found `[a]'
16:09:31 <lambdabot>       Expected type: a1 -> m ...
16:09:33 <ndm> an ICFP paper
16:09:42 <LoganCapaldo> > ((or .) . (. return) . (:)) True False
16:09:44 <lambdabot>  True
16:09:51 <russo> @pl what?
16:09:52 <lambdabot> (line 1, column 6):
16:09:52 <lambdabot> unexpected end of input
16:09:52 <lambdabot> expecting white space or simple term
16:09:53 <dons> mm, i wonder could we use http://www.coyotegulch.com/products/acovea/index.html to find optimal ghc/gcc flag sets
16:09:54 <lambdabot> Title: Acovea Overview
16:09:57 <russo> :)
16:10:23 <ndm> dons: not portable between two systems - so you'd have to run it on the target system
16:10:23 <russo> wait so what does @pl do again
16:10:34 <russo> i mean i saw the help
16:10:42 <russo> @pl 1 + 2
16:10:42 <lambdabot> 3
16:10:48 <LoganCapaldo> russo: basically it gets rid of variables (points)
16:10:49 <russo> hmm you lambda bot you
16:10:50 <dons> ndm, sure.
16:11:01 <LoganCapaldo> @pl (\x y -> x + y)
16:11:01 <lambdabot> (+)
16:11:06 <russo> aha!
16:11:07 <russo> ok
16:11:08 <dons> looks like its configurable for other compilers. hmm...
16:11:12 <LoganCapaldo> bindings I should say, not variables
16:11:18 <ndm> dons: once Yhc is done enough, are people going to optimise code for it?
16:11:19 <ddarius> ndm: Hom about this?  What is the proposed title? what is the content matter?
16:11:41 <ndm> ddarius: http://www-users.cs.york.ac.uk/~ndm/downloads/paper-a_static_checker_for_safe_pattern_matching_in_haskell-future.pdf
16:11:42 <russo> @pl (\x y -> if x > y then x else y fi)
16:11:42 <lambdabot> (`ap` ($ fi)) . (flip =<< (if' .) . (>))
16:11:44 <lambdabot> http://tinyurl.com/v2dnv
16:11:48 <russo> :S
16:11:54 <dons> ndm, I'm not sure I follow.
16:11:56 <ndm> ddarius: pattern match checking for haskell, i.e. no pattern match errors at runtime
16:11:57 <russo> > max(1,2)
16:11:58 <lambdabot>  Add a type signature
16:12:07 <russo> > max 1 2
16:12:09 <lambdabot>  2
16:12:12 <ndm> dons: once we add an optimising backend to Yhc, how easy is it to get that into the shootout?
16:12:20 <russo> > :type max
16:12:20 <lambdabot>  Parse error
16:12:28 <russo> > :t max
16:12:28 <lambdabot>  Parse error
16:12:31 <allbery_b> :t max
16:12:31 <russo> :S
16:12:32 <lambdabot> forall a. (Ord a) => a -> a -> a
16:12:34 <russo> oic
16:12:37 <dons> ndm, ah right. you need a debian and gentoo package for your compiler and its libraries
16:12:40 <LoganCapaldo> russo: Yeah it has a set of rewrite rules, it doesn't neccessarily know the "shortest" way
16:12:40 <allbery_b> @ty max -- same thing
16:12:42 <lambdabot> forall a. (Ord a) => a -> a -> a
16:12:58 <dons> ndm, such that the shootout guys can just install it
16:13:07 <ndm> dons: that can be done easily enough, i guess - will prod the build people once i've got the compiler done
16:13:15 <dons> but they're unlikely to do that unless you can compile 90% of the benchmarks
16:13:22 <dons> or implement 90%, I should say
16:13:32 <russo> man i love haskell :) its so much fun :D just making silly 1 line programs :)
16:13:37 <kosmikus> ndm: I'd love to see a yhc Gentoo ebuild. I'm certainly willing to help create one.
16:13:50 <ddarius> ndm: In general I would format/mathify it slightly e.g. \rarr instead of -> \forall instead of forall, but I would not do something like \conj instead of &&.
16:13:52 <ndm> ddarius: that isn't hte paper, thats an early version from 2 years ago - the new paper has the same introduction
16:14:08 <dons> ndm, its more like to be accepted if you wrote demo solns for the various benchmarks that yhc could compile
16:14:10 <ndm> kosmikus: i think we did have one at some point
16:14:20 <kosmikus> ndm: yeah, there is one from darcs.
16:14:39 <ndm> dons: that shouldn't be too hard - i'll wait til there is a finished optimising backend first
16:14:46 <kosmikus> ndm: not sure if it still works though. anyway, it's better to have ebuilds for stable releases.
16:14:55 <ddarius> ndm: In some contexts, more mathematical ones where Haskell is just a convenient language and not critical I may use more mathematical operators.
16:14:58 <ndm> kosmikus: yes, we're just waiting on the base libraries for a stable release
16:15:14 <sorear> now, how about getting Jhc into the shootout? :)
16:15:18 <ndm> kosmikus: -O11 will be release 2
16:15:32 <russo> @pl (\x y -> or [x,y])
16:15:32 <lambdabot> (or .) . (. return) . (:)
16:15:35 <ndm> sorear: Yhc with -O11 is likely to beat GHC at some of the benchmarks
16:15:38 <dons> @tell augustss how about using this http://www.coyotegulch.com/products/acovea/index.html to find the optimial unfolding flags for ghc...
16:15:38 <MarcWebe1> Do you know which is the dependecy HList of HAppS? There is a HList on darcs.haskell.org but there is no HList module which HAppS expects..
16:15:38 <lambdabot> Consider it noted.
16:15:46 <dons> ndm, show us the numbers :-)
16:15:51 <russo> oh that what you did :)
16:16:03 <ddarius> @pl \f g x -> f x (g x)
16:16:03 <lambdabot> ap
16:16:05 <russo> yeah but thats rediculous... what its spits out :)
16:16:35 <russo> ap is an operator in haskell?
16:16:38 <russo> :t ap
16:16:40 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
16:16:46 <sorear> wha .. how is Yhi going to outperform GHC!?
16:16:46 <ndm> dons: writing now, give me a few months...
16:17:11 <dons> ah, so it currently doesn't outperform GHC, but you speculate it will, for some programs.
16:17:15 <ndm> ddarius: yes, maths is usually better - but doesn't have the same pattern matching etc
16:17:25 <ndm> dons: it does for the Primes in the nofib benchmark, and for exp3_8
16:17:31 <ddarius> russo: This is why point-free code is often referred to as pointless code.  However, usually you don't mechanically translate to point-free style.
16:17:39 <dons> ok. is that compiling the polished code through ghc?
16:17:41 <ndm> sorear: using our native backend and super optimiser - not going via Yhi
16:17:49 <russo> ddarius: ic
16:18:00 <ndm> dons: yes, but we have a backend which is also a bit faster going direct to C
16:18:02 <sorear> ndm: hmm.  how will it compare with Jhc? :)
16:18:16 <dons> ndm, if so, couldn't we just dump the current Yhc haskell core output, and submit that?
16:18:17 <ndm> sorear: whole program optimisation - yes, really slow compile times - no
16:18:28 <dons> you want to check now if its faster for partial-sums or recursive?
16:18:44 <ndm> dons: we might be able to...
16:18:49 <dons> (these are very simple benchmarks that could possible be improved, though I'm not sure how ...)
16:18:57 <ndm> dons: ok, will take a look at one of those
16:18:59 <dons> this one, http://shootout.alioth.debian.org/gp4/benchmark.php?test=recursive&lang=ghc&id=5
16:19:01 <lambdabot> Title: recursive Haskell GHC #5 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Com ..., http://tinyurl.com/2ov5wa
16:19:09 <dons> and this one, http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=ghc&id=0
16:19:11 <lambdabot> Title: partial-sums Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Com ..., http://tinyurl.com/26cegm
16:19:19 <ddarius> On vaguely related topic, as abusive as using ap is it does point out (when you understand what's happening) the idea behind the S combinator.
16:19:55 <dons> ndm, 'recursive' in particular you should have a crack at.
16:20:08 <ndm> dons: does GHC generate optimised versions specialised to Int/Double etc?
16:20:12 <dons> yes
16:20:24 <dons> to Int# and Double#
16:20:45 <ndm> dons: is it a requirement to use a bad version of fib?
16:20:51 <dons> yeah
16:21:07 <sorear> ie a memoizing compiler would be much better
16:21:08 <dons> spec here, http://shootout.alioth.debian.org/gp4/benchmark.php?test=recursive&lang=all
16:21:12 <lambdabot> Title: recursive benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/qua9o
16:21:17 <dons> "Each program should use the same naÃ¯ve recursive-algorithms .."
16:21:26 <ndm> thats just stupid....
16:21:45 <dons> no, its a test of loop generation/recursion
16:21:56 <dons> e.g. spot the langauges that don't do tail calls
16:22:06 <newsham> ?type randoms
16:22:08 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
16:22:10 <dons> 267   Python                  641.65          14,220        344
16:22:10 <dons> 352   Perl #2                 844.74          10,788        369
16:22:10 <dons> 435   Tcl                     1,044.83        28,868        445
16:22:10 <dons> 459   PHP #2                  1,101.43        17,932        299
16:22:10 <dons> 620   Ruby #2                 1,487.80        48,352        285
16:22:22 <dons> ;)
16:22:22 <dons> 3.4   Haskell GHC #5          8.13            1,392         431
16:22:33 <newsham> ?type mkStdGen
16:22:34 <ndm> my -O11 may be able to optimse fib to the better version
16:22:35 <lambdabot> Int -> StdGen
16:22:48 <dons> ndm, you mean, find a different implementation?
16:22:50 <ndm> i.e. a linear version
16:23:01 <ndm> dons: transform the existing implementation automatically to generate the better version
16:23:30 <dons> if it changed the algo, possibly itd be disallowed
16:23:36 <sorear> ndm: how crazy will -O11 be? dissertation crazy or just blood-and-sweat crazy?
16:23:51 <ddarius> "Oh no! My compiler is sufficiently smart!"
16:24:10 <ndm> dons: changed the algorithm in teh compiler without any special purpose code to spot that situation?
16:24:17 <sorear> ndm: ie is there a paper about it?
16:24:36 <nrb23> question about storing info in Haskell Records...
16:24:43 <dons> ndm, that'd be ok I think. but I'd like to see that happen first :-)
16:24:44 <nrb23> I'm working on something to represent IP headers
16:24:46 <ndm> sorear: it will be both crazy - no papers yet, but it will be a topic in my thesis in the end
16:24:52 <sorear> nrb23: foo { field = newvalue } ?
16:24:54 <ndm> dons: just let me do the calculations...
16:24:55 <nrb23> the Version and the header length are each 1 nibble
16:25:16 <nrb23> in C, I'd use bitfields
16:25:26 <sorear> ndm: wait, Catch is growing an optimizer!?
16:25:39 <dons> nrb, ok. you might want to consider using Data.Word/Data.Bits to pack the data
16:25:43 <ndm> sorear: yes, its from the same work, but more as a prepass
16:25:45 <dons> nrb23: or Data.Binary
16:25:50 <dons> ?where binary
16:25:50 <lambdabot> http://darcs.haskell.org/binary
16:26:11 <nrb23> in my ethernet header, I'm using Data.Word{8, 16, 32, 64}
16:26:12 <dons> nrb23: so, you read the input as a bytestring, and shift out the fields you need
16:26:16 <sorear> ndm: hmm - I suppose Boquistian points-to is not that far from Mitchellian case incompleteness disproving
16:26:23 * ddarius wonders about supercompilation and optimizing fib or whatever.
16:26:31 <dons> right. and then some kind of binary-based parser (e.g. Data.Binary) to pull out the fields into a struct
16:26:32 <ndm> sorear: doesn't use either of those
16:27:00 <sorear> ddarius: fib has been optizable to the linear version for DECADES.  It's called "maximal sharing"
16:27:24 <ndm> sorear: well, not quite ;) - Catch is first order, the first order transformation can be given steroids and make into a full optimiser
16:28:35 * ddarius needs to get his RHCP and SOAD back.
16:30:00 <nrb23> dons: as in Data.ByteString
16:31:49 <dons> yeah
16:32:17 <gotaku> Has anyone written the Nehe OpenGL tutorials in Haskell yet?
16:32:55 <dons> yeah
16:33:31 <dons>    http://codersbase.com/index.php/Nehe-tuts
16:33:33 <lambdabot> Title: Nehe-tuts - CodersBase
16:34:19 <ddarius> Coding and Bad Religion.  It's been awhile.
16:35:23 <Mushy-pea> Hi.
16:35:46 <dons> elcome.
16:35:51 <dons> s/^/w/
16:36:05 <Mushy-pea> I've been using GHC on Windows 98 a bit recently....
16:36:26 <dons> good. how's that experience been?
16:36:37 <ndm> not as pretty as using WinHugs ;)
16:36:46 <dons> but faster!
16:36:52 <Mushy-pea> It's works fine, except it produces really large .exe files for really simple programs.
16:36:55 <ndm> at runtime only
16:37:04 <ndm> Mushy-pea: yes, alas GHC does that...
16:37:14 <dons> Mushy-pea: yeah, you statically link the runtime. It helps if you strip the binaries or use 'split objs'
16:37:17 <ndm> Mushy-pea: it has to statically link in all the runtime logic
16:37:18 <gotaku> Speaking of Windows, does anyone here know of anyone that has actually spent money to upgrade to Vista?
16:37:21 <dons> but i'm not sure if that's supported on windows
16:37:33 <dons> luckily disk space is cheap. so the 300k or so rts overhead doesn't cost much
16:37:38 <ndm> dons: I didn't think so, but dcoutts managed to get something going in Gtk2Hs
16:37:44 <dons> cool
16:37:45 <ndm> dons: its more like 1Mb overhead
16:38:04 <dons> its around 230k on x86/linux
16:38:38 <dons> the ghc win32 package is also much larger than the unix versions for some reason too
16:38:42 <Mushy-pea> I don't mind.  I was just wondering why.  I thought it might be to do with linking loads of libraries.
16:38:55 <dons> just the base library and the runtime system.
16:39:06 <dons> if you've not go split objs, then any library you use will be linked in, in its entirety
16:39:11 <ndm> Mushy-pea: its mainly the runtime system - if its any consolation as the size of your program goes up, the size of the .exe goes up much slower
16:39:44 <ndm> Mushy-pea: or you can use Yhc, which has a non-linked runtime, and get small (10K) binaries - but requiring people to install their own runtime
16:40:24 <dons> and write their own libraries ;)
16:40:26 <Gwern> gotaku: I have. the stupid git
16:40:27 <sorear> ... or you can use hugs and get NO BINARIES AT ALL!!!
16:40:34 <sorear> :)
16:40:45 <ndm> dons: the libraries are almost done...
16:40:46 <Gwern> hugs doesn't do binaries?
16:40:55 <ndm> Gwern: no, it doesn't
16:41:03 <dons> hugs is an interpreter in the ruby or python sense.
16:41:04 <ndm> Gwern: and Yhc doesn't use QuickCheck ;)
16:41:09 <dons> so src files only
16:41:11 <sorear> ndm: no, parsec, mtl, haskell98, not working for me
16:41:20 <dons> no mtl?!
16:41:23 <dons> yikes
16:41:27 <ndm> sorear: haskell98 works, the others are still waiting on
16:41:32 <Gwern> ndm: what can I say? when I see quickcheck imports in source files, I sort of jump to conclusions
16:41:38 <dons> bytestrings? did we get that working (nhc works...)
16:41:41 <sorear> ndm: Directory is missing, it's not h98
16:41:56 <ndm> Gwern: yeah, i can see why - i didn't even realise Map had QuickCheck imports
16:41:57 <sorear> ndm: I tried to bootstrap yhc :)
16:42:07 <hyrax42> how does newtype deriving work?
16:42:10 <ndm> sorear: well one day we'll get that one too :)
16:42:12 <Mushy-pea> OK.  Thanks for the info.
16:42:15 <Mushy-pea> Bye.
16:42:26 <hyrax42> can I derive IArray on newtype Table = T (Array (Int,Int) Int)?
16:42:44 <sorear> no iirc
16:42:57 <ddarius> dons: ByteString.tail just (essentially) returns an incremented pointer correct.
16:42:57 <dons> maybe? how far does newtype deriving go?
16:42:59 <hyrax42> hmm
16:43:01 <sorear> actually, probably yes
16:43:04 <dons> ddarius: yes.
16:43:11 <hyrax42> well I'm getting an error
16:43:13 <sorear> ddarius: yes, and a bounds check :)
16:43:16 <hyrax42> but might be i didn't enable the extensions
16:43:18 <ndm> however we _should_ use quickcheck properties! its on the todo list
16:43:19 <dons> hyrax42: you certainly need -fglasgow-exts for that
16:43:21 <ddarius> dons: I just realized it'd have to to be O(1)
16:43:22 <sjanssen> hyrax42: no, because arrays must be polymorphic in the index and element types
16:43:31 <dons> ddarius: and indeed it is :-)
16:43:39 <dons> ddarius: most substring -taking ops are O(1)
16:44:14 <hyrax42> sjanssen: oh
16:44:17 <hyrax42> d'oh
16:44:23 <ddarius> dons: Why is the 'word' "Transformating" used in the docs?
16:44:41 <dons> heh.
16:44:49 <dons> @spell Transformating
16:44:50 <lambdabot> Trans formating Trans-formating Transformation Transforming Transformations
16:44:55 <dons> its a good word!
16:45:05 <hyrax42> > undefined == undefined
16:45:06 <lambdabot>  Add a type signature
16:45:21 <hyrax42> > (undefined :: Int) == undefined
16:45:21 <dons> typo fixed. patch applied thanks ddarius
16:45:23 <lambdabot>  Undefined
16:45:54 <ddarius> That was quick.
16:46:23 * hyrax42 feels wrong about using maxBound as a way to mark "useless" entries of the table
16:47:56 <LoganCapaldo> hyrax42: maxBound -> Nothing, usefulEntry -> Just usefulEntry ?
16:48:10 <hyrax42> LoganCapaldo: it'll make my code all horrible ugly
16:48:13 <hyrax42> I thought about it
16:48:34 <LoganCapaldo> Even with do? :(
16:48:48 <hyrax42> well the table is generated with a list comprehension
16:49:01 <hyrax42> I'd have to go in and throw Just's around lots of stuff
16:50:04 <dons> finally,   * add --enable-optimization/--disable-optimization config options (on by default)
16:50:09 <dons> ross++
16:50:13 <dons> (for cabal!)
16:51:29 <hyrax42> cool!
16:51:29 <dibblego> > True > False -- why?
16:51:36 <lambdabot>  True
16:51:56 <yip> > let ep = 0.1; sqrt' x guess = if (abs (guess*guess - x)) < ep then guess else (if guess*guess < x then sqrt' x (guess*1.5) else sqrt' x (guess*0.5)); sqrt x = sqrt' x (x/2) in sqrt 2
16:51:58 <lambdabot>  1.423828125
16:52:04 <hyrax42> till now I always had a pair of lines, one with optimisation one without
16:52:15 <sorear> @src Bool
16:52:15 <lambdabot> data Bool = False | True deriving (Eq, Ord)
16:52:22 <ddarius> dibblego: It's convenient and the more 'natural' choice.
16:52:22 <sorear> dibblego: ^^^
16:52:26 <yip> > let ep = 0.0001; sqrt' x guess = if (abs (guess*guess - x)) < ep then guess else (if guess*guess < x then sqrt' x (guess*1.5) else sqrt' x (guess*0.5)); sqrt x = sqrt' x (x/2) in sqrt 2
16:52:28 <lambdabot>  1.4142315650884936
16:52:30 <dibblego> ok cheers
16:52:59 <allbery_b> > fromEnum False
16:53:00 <lambdabot>  0
16:53:12 <allbery_b> seems natural enough to me
16:53:22 <ddarius> > [False..True]
16:53:23 <lambdabot>  Parse error
16:53:31 <ddarius> > [False .. True]
16:53:32 <sorear> > [False .. True]
16:53:33 <lambdabot>  [False,True]
16:53:33 <lambdabot>  [False,True]
16:53:48 <dons> cool, i've got this program evolving which gcc flags are best suited for a C program
16:53:54 <dons> now, to find out how to configure it for ghc..
16:54:39 <LoganCapaldo> dons: Could you not tell ghc to emit c and then use the program directly?
16:55:02 <dons> I could yes. but I'd like to find the combination of ghc *and* gcc flags that are best to use
16:55:07 <dons> I think that's possible with this framework
16:55:37 <allbery_b> > [minBound :: Bool .. maxBound]
16:55:39 <lambdabot>  [False,True]
16:56:01 <LoganCapaldo> > maxBound :: Bool
16:56:03 <lambdabot>  True
16:56:09 <gvdm_other> possibly that could be in an -O4 or something, takes an insane amount of time to compile but tries to get the best flags for your program?
16:56:20 <ddarius> dons: Couldn't you just kind go via -optc as well.
16:56:29 <LoganCapaldo> > if maxBound then "Hehe" else ":("
16:56:31 <lambdabot>  "Hehe"
16:56:34 <sorear> gvdm_other: -OOO ?
16:56:39 <allbery_b> well, we did discover -O3 did nasty things t Doubles the other day
16:56:39 <dons> ddarius: yes, exactly
16:56:43 <dons> yeah
16:57:41 <LoganCapaldo> @pl (\x -> if maxBound then "this just screams obfuscated haskell contest" else x)
16:57:41 <lambdabot> if' maxBound "this just screams obfuscated haskell contest"
16:58:23 <dons> heh
16:58:23 <LoganCapaldo> @src if'
16:58:23 <lambdabot> Source not found. My pet ferret can type better than you!
16:58:42 <LoganCapaldo> @djinn Bool -> a -> a -> a
16:58:43 <lambdabot> f a b c =
16:58:43 <lambdabot>     case a of
16:58:43 <lambdabot>     False -> c
16:58:43 <lambdabot>     True -> b
16:58:58 <sorear> LoganCapaldo: if' doesn't exist - it's pl's way of saying your code can't be pointfreed
16:59:14 <sjanssen> dons: can acovea also make sure the compiler doesn't break the program?
16:59:18 <LoganCapaldo> I thought djinn just wrote me if' :)
16:59:21 <sorear> (well, in this case it can, but that's beside the point)
16:59:45 <sorear> @pl myif' a b c = [b,c] !! fromEnum a
16:59:45 <lambdabot> myif' = flip (flip . ((!!) .) . (. return) . (:)) . fromEnum
16:59:49 <ddarius> sorear: if' is essentially just another base combinator.
16:59:50 <dons> sjanssen: hehe. i guess we'll find a few fun results in there.
16:59:52 <sorear> MUAHAHAH!
17:00:00 <dons> its pretty easy to get gcc to segfault a haskell program with the right flags
17:00:15 <LoganCapaldo> sorear: Well played!
17:00:20 <dons> ok, so now I have to write a config file to teach alcova about ghc flags
17:00:49 * sorear bows
17:03:19 <hyrax42> is the defaulting mechanism only for numeric types?
17:03:30 <Pseudonym> Yes,.
17:03:30 <sorear> yes
17:03:36 <Pseudonym> And even then, only some numeric tyoes.
17:03:54 <hyrax42> d'oh
17:04:00 <hyrax42> I wanted to set a "default" array type
17:04:10 <sorear> numeric typoes would've been funnier
17:04:27 <hyrax42> so I don't have to litter :: Array Blah Bloo all over the place
17:05:27 <LoganCapaldo> > let (`at` 0) = fst in (1,0) `at` 0
17:05:27 <lambdabot>  Parse error in pattern
17:05:31 <LoganCapaldo> drat
17:05:54 * LoganCapaldo needs more sugar
17:07:35 <ddarius> > let (x,_) `at` 0 = x in (1,0) `at` 0
17:07:38 <lambdabot>  1
17:09:46 <LoganCapaldo> ddarius: Thats not the point ;)
17:10:18 <ddarius> LoganCapaldo: I know.
17:10:56 * ddarius has thought about making a language that was just a mass of rewrite rules on terms.
17:12:11 <hyrax42> ?hoogle (Fractional a, Integral b) => a -> b
17:12:13 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:12:13 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
17:12:13 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
17:12:30 <hyrax42> :t truncate
17:12:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:12:36 <hyrax42> :t round
17:12:37 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:13:03 <hyrax42> :t log
17:13:04 <lambdabot> forall a. (Floating a) => a -> a
17:13:19 <LoganCapaldo> Why do those three show up for every hoogle like that?
17:13:41 <hyrax42> oh is that common?
17:14:04 <LoganCapaldo> I mean I guess I can see that for some monad m m () could be anstance of Integral
17:14:24 <LoganCapaldo> but at that point its obviously not the function you were looking for
17:14:40 <gotaku> I'm actually thinking of getting a Ps3...
17:14:46 <sorear> LoganCapaldo: I think it has to do with the fact that C is the third letter in the alphabet
17:15:07 <sorear> (remember @hoogle truncates whatever hoogle returns to three entries)
17:15:27 <LoganCapaldo> AHA
17:15:37 <LoganCapaldo> that at least makes some sense :)
17:15:52 <gotaku> GHC can run on PowerPC right?
17:15:59 <allbery_b> sure
17:16:02 <LoganCapaldo> theres probably a whole mess of inappropiate results that type check then :)
17:16:23 <ddarius> The Data.Bits docs should give a precedence table.
17:16:34 * ddarius just assumes the precedences are the "right" ones.
17:16:44 <glguy> that's why we have ?hoogle+ and /msg
17:18:15 <LoganCapaldo> ten pages of em in fact
17:18:21 <allbery_b> speaking of which, darcs pull ghc, find conflict in rts/Linker.c --- meaning my patch for ppc was accepted, yay
17:19:05 <allbery_b> (a little unfrtunate that the only notification I got was posting-to-moderated-list-by-nonmember...)
17:21:20 <ddarius> @type ord
17:21:21 <lambdabot> Char -> Int
17:21:33 <sorear> ord == fromEnum
17:21:55 <LoganCapaldo> @type fromEnum
17:21:56 <lambdabot> forall a. (Enum a) => a -> Int
17:22:19 <ddarius> @type fromIntegral . ord :: Char -> Word8
17:22:20 <lambdabot> Char -> Word8 :: Char -> Word8
17:23:15 <LoganCapaldo> @type undefined :: Char -> [Int] -- I predict the type will be Char -> [Int]
17:23:17 <lambdabot> Char -> [Int] :: Char -> [Int]
17:24:09 <ddarius> @index htons
17:24:09 <lambdabot> bzzt
17:24:14 <ndm> LoganCapaldo: Hoogle shows them up because it doesn't understand MPTC's so sees them as very general
17:26:14 <LoganCapaldo> MPTC?
17:26:26 <glguy> multi parameter type class
17:26:38 <LoganCapaldo> aha
17:26:55 <glguy> or constructor..
17:28:17 <kfish> how to use random numbers outside of IO: http://xkcd.com/c221.html
17:28:18 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
17:29:39 <sorear> kfish: you're not the first
17:29:44 <sorear> Dougal Stanton
17:30:55 <sorear> kfish: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022311.html
17:30:57 <lambdabot> Title: [Haskell-cafe] Random numbers without IO, http://tinyurl.com/29upnf
17:31:43 <nrb23> sorear: brillant!
17:31:59 <kfish> sorear: dammit, someones procrastinating harder than I am :-)
17:32:02 <sorear> nrb23: I am not Dougal Stanton
17:32:18 <sorear> nor am I the xkcd author
17:32:19 <nrb23> sorear: still brilliant
17:32:36 <sorear> @localtime nrb23
17:32:37 <lambdabot> Local time for nrb23 is 2007-02-11 17:31:28 -0800
17:32:47 <nrb23> posting it here, at least
17:34:06 <ddarius> http://xkcd.com/c55.html arguably one of those has an answer.
17:34:06 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
17:34:34 <dons> ok. cool. acovea is evolving me some optimal flags for the recursive benchmark
17:35:10 <sorear> muahaha
17:35:22 <sorear> dons: nice wrt lambdabot
17:35:44 <LoganCapaldo> ddarius: which one?
17:35:56 * sorear tries to crash a major freenode server
17:36:07 <sorear> jkoc
17:36:49 <ddarius> LoganCapaldo: The one that applies the identity matrix to it. The arguably part is that I doubt <3 is an element of a linear space or even a module.
17:37:15 <sorear> wha?
17:37:26 <sorear> window error?
17:37:34 <LoganCapaldo> I only vaguely recall this, but if <3 was for instance [1 2 3 4 5 6] wouldn't that not work anyway?
17:38:27 <ddarius> LoganCapaldo: It wouldn't even be sensical, as it also wouldn't if it wasn't an element of any module.
17:42:26 <allbery_b> hm, oops.  no StgTicky.h.  try again later :)
17:47:28 <ddarius> @index hton
17:47:28 <lambdabot> bzzt
17:47:39 <allbery_b> it's no there :(
17:47:49 * allbery_b rolled his own when he needed it
17:47:51 <dons> sorear: btw, -fmax-worker-args
17:48:12 <sorear> ?
17:48:13 <dons> "If a worker has that many arguments, none will be unpacked anymore (default 10)
17:48:19 <dons> we were wondering about this the other day
17:49:57 <ddarius> allbery_b: I'll probably fold it into the parsing.  This doesn't need to be portable.
17:50:03 <ddarius> For now.
17:50:14 <LoganCapaldo> dons: they'll be so busy arguing they won't get any work done and all the boxes will stay packed?
17:51:15 <hyrax42> ?src Data.IArray.ixmap
17:51:15 <lambdabot> Source not found. That's something I cannot allow to happen.
17:51:20 <hyrax42> ?src ixmap
17:51:20 <lambdabot> Source not found. Are you on drugs?
17:51:51 <ddarius> @src Array ixmap
17:51:51 <lambdabot> Source not found. That's something I cannot allow to happen.
17:52:15 <hyrax42> ?fptools Data.Array.IArray
17:52:15 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/IArray.hs
17:54:03 <ddarius> @type gets
17:54:04 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
17:58:07 <JohnnyL> the contents of this channel are usually for learning haskell?
17:58:30 <dons> JohnnyL: yes, exactly.
18:00:03 <JohnnyL> everytime I try a haskell tutorial, i can't get past the examples because there is usually one for topic. then after lack of use i forget the topics. It'd be nice if there was like a video of haskell programming ala http://www.opensolaris.org/os/community/zfs/demos/selfheal/
18:00:04 <lambdabot> Title: ZFS Self Healing at OpenSolaris.org
18:00:11 <JohnnyL> s/for/per
18:00:34 <JohnnyL> woah, lambdabot is smart.
18:00:53 <ohmega> hm, there are some lectures on funcional programming online i think. let me check hm.
18:01:06 <dons> yeah, visit haskell.org, there's video lectures, and other turoials
18:01:10 <JohnnyL> oh ok
18:01:11 <JohnnyL> thx.
18:02:20 <ohmega> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
18:02:25 <lambdabot> Title: S-INF.de - Vorlesungsvideos, http://tinyurl.com/y4m979
18:02:25 <ohmega> that's what i was thinking of :)
18:05:26 <maskd> does anyone know why the lambdabot i compiled keeps showing this error message? "Main: caught (and ignoring) IRCRaised Data.Binary.Get.takeExactly: Wanted 8 bytes, found 0.. Failed reading at byte position 16"
18:05:50 <dons> rm state/seen
18:05:54 <dons> rm State/seen
18:06:04 <dons> (yes, the ata.Binary format for the seen file changed)
18:07:19 <ddarius> The C++ code that I'm rewriting into Haskell is actually rather pretty.
18:08:06 <maskd> there's also this error (when using '>'): "Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString"
18:08:24 <orbitz> >
18:08:29 <orbitz> > 2 + 2
18:08:31 <lambdabot>  4
18:08:40 <allbery_b> isn't that related to hs-plugins?
18:09:00 * allbery_b isn't sure if hs-plugins finally works on 6.6 or not
18:09:14 <allbery_b> but if it's not there you get that error IIRC
18:09:49 <orbitz> any suggestions for a somwat interesting haskell project to work on?, ugh I hate that question
18:11:44 <hpaste>  benomatic pasted "how to cleanup "space" decoding?" at http://hpaste.org/460
18:13:06 * benomatic seeks suggestions at cleaning up this (part of scheme tutorial) code snippet
18:16:10 <allbery_b> off the top of my head, oneOf "sS"; oneOf "pP"; ...
18:17:31 <benomatic> allbery_b: that would help a touch, but i was looking to find something that could do the case dropping and then bind via string (w/o writing it myself, since getting to this point was hard enough for me)
18:17:45 <dons> maskd, can you just check if ./runplugs works?
18:17:52 <dons> (it works for me here with 6.6)
18:18:11 <benomatic> allberry_b: any other style suggestions, btw?
18:18:12 <allbery_b> yeh, I didn't see anything offhand that would do it but there's probably some trick somewhere
18:18:27 <gotaku> How are strings compared?
18:18:40 <orbitz> gotaku: strings are just lists, so jsut liek lists?
18:18:47 <sorear> right
18:18:50 <dons> ?src [] Eq
18:18:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:19:32 <orbitz> all (==) (zip l1 l2) ?
18:20:01 <maskd> dons: seems to work, it doesn't throw any error messages
18:20:02 <dons>     []     == []     = True
18:20:02 <dons>     (x:xs) == (y:ys) = x == y && xs == ys
18:20:04 <dons>     _xs    == _ys    = False
18:20:32 <dons> ?src [] (==)
18:20:32 <lambdabot> []     == []     = True
18:20:32 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
18:20:32 <lambdabot> _xs    == _ys    = False
18:20:35 <dons> ther we go
18:21:18 <orbitz> is the 'all' call poor?
18:21:23 <allbery_b> something like sequence_ . mapM (\c -> satisfy (\p -> toLower c == p)) "space" -- ?
18:21:36 <dons> maskd, try again, seems to work here:
18:21:36 <dons> lambdabot> > 1+2
18:21:36 <dons>  3
18:21:44 <newsham> and $ zipWith (==) ?
18:21:52 <dons> orbitz: its not defined yet.
18:21:55 <dons> those instances are in GHCBase
18:22:02 <dons> long before the List library is implemented
18:22:13 <orbitz> oh
18:22:15 <benomatic> allbery_b: i may give that a go, but both sequence_ and mapM are outside of my haskell vocab :-)
18:22:16 <gotaku> > "Test" ++ "ing"
18:22:20 <allbery_b> :t sequence_ . mapM (\c -> Text.ParserCombinators.Parsec.satisfy (toLower c ==)) "space"
18:22:24 <lambdabot>     Couldn't match `(->) a'
18:22:24 <lambdabot>            against `Text.ParserCombinators.Parsec.Prim.GenParser Char st'
18:22:25 <lambdabot>  "Testing"
18:22:44 <dons> the machine is a bit loaded atm, as I'm building ghc 6.6 on it
18:22:45 <maskd> dons: what's the expected behaviour when running runplugs?
18:22:55 <allbery_b> .me probably doing something dumb as usual
18:22:56 <hpaste>  sorear annotated "how to cleanup "space" decoding?" with "my take" at http://hpaste.org/460#a1
18:23:04 <dons> $ echo '1+2' | ./runplugs
18:23:05 <dons> 3
18:23:10 <allbery_b> :t sequence_ . map (\c -> Text.ParserCombinators.Parsec.satisfy (toLower c ==)) "space"
18:23:12 <lambdabot>     Expecting a function type, but found `[b]'
18:23:12 <lambdabot>       Expected type: a1 -> [m a]
18:23:27 <sorear> benomatic: ^^^
18:24:05 <benomatic> sorear: danke, looking...
18:24:13 <maskd> dons: runplugs: Ix{Int}.index: Index (1024) out of range ((0,29))
18:24:31 <allbery_b> hs-plugins
18:24:45 <sorear> maskd: IIRC that error is characteristic of trying to use hs-plugins on a 64-bit computer
18:25:08 <sorear> (might also be a /= 6.6 issue)
18:25:26 <maskd> i don't have a 64-bit computer, and i'm using 6.6
18:25:40 <allbery_b> do you have the latest darcs hs-plugins?
18:26:02 <benomatic> sorear: nice.  thanks!
18:26:36 <maskd> i guess so
18:27:40 <allbery_b> durrr
18:28:32 <allbery_b> :t mapM (\c -> Text.ParserCombinators.Parsec.satisfy ((c ==) . toLower)) "space"
18:28:33 <lambdabot> forall st. Text.ParserCombinators.Parsec.Prim.GenParser Char st [Char]
18:29:19 <allbery_b> istring s = mapM (\c -> Text.ParserCombinators.Parsec.satisfy ((c ==) . toLower)) s
18:29:22 <bonfyre> how about,  mapM letter "space" ?
18:30:01 <allbery_b> letter matches any letter, not a specified letter
18:30:15 <dons> maskd, make sure you have ghc 6.6, have done a 'make clean', and completely rebuilt hs-plugins from the darcs repo
18:30:36 <dons> sorear: not 64 bits, hs-plugins supports amd64 fine, last I heard
18:30:51 <dons> it is characterisitic of using hs-plugins compiled for ghc 6.4 with ghc 6.6
18:30:56 <bd_> ?where hs-plugins
18:30:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
18:31:01 <dons> or having old .hi files from ghc 6.4 lying around
18:31:24 <maskd> hm, maybe i have those
18:31:47 <allbery_b> @pl \c -> satisfy (\p -> c == toLower p)
18:31:47 <lambdabot> satisfy . (. toLower) . (==)
18:33:01 <benomatic>  @pl does a refactoring of some sort i see?
18:33:08 <allbery_b> istring s = mapM (satisfy . (. toLower) . (==)) s -- that's not bad
18:33:28 <allbery_b> rewrites in point-free (no variables) s tyle
18:33:58 <benomatic> nope, not bad at all.  my naive guess involved satisfy, but i still struggle w/ . $ and return, so i didn't venture very far :-)
18:33:59 <allbery_b> were it not for the monomorphism restriction (which, actually, might not mtter here) you culd drop the "s"s too
18:34:43 <benomatic> well, '.' isn't so bad, but $ and return confuse me a bit.  i presume they will become natural w/ experience.
18:35:06 <allbery_b> $ is just magic parentheses
18:35:12 <allbery_b> a $ b is (a) (b)
18:35:38 <rahikkala> Well, it's not *actually* magic parentheses
18:35:51 <allbery_b> so, function application but with parentheses assumed.  (and a is taken to be as long as possible)
18:36:11 <rahikkala> applyFns fns value = map ($ value) fns
18:37:22 <allbery_b> could also expand it into a series of anyOf-s instead of satisfy, which might prove faster --- or might not.  have to time it on very large input
18:38:12 <benomatic> heh.  i'm just concerned about learning haskell (and a little scheme along the way), so i'm more concerned w/ learning than speed
18:38:24 <benomatic> well, idiomatic learning, really
18:39:29 <benomatic> allbery_b: one more question then: in my original code "return $ c" is the $ necessary?
18:39:40 <allbery_b> nope
18:40:30 <rahikkala> You're doing Write Yourself a Scheme in 48 hours? I hope you're much more intelligent than I am... I could hardly make any sense of what was going on when I was starting out. I went off to try some simpler tutorials, implemented a few small programs on my own, and had learned to understand the concepts involved a whole lot better than if I had just stayed there trying to figure that one tutorial out...
18:40:33 <allbery_b> basically you use $ when you have a parenthesized expression at the end of some larger expression, so you can drop the parens
18:41:00 <allbery_b> foo bar (baz gorp gleep)  can be rewritten as  foo bar $ baz gorp gleep
18:41:13 <benomatic> i'd previously (a month ago) done 2/3 of the "two dozen" tutorial, and since then i skimmed part of the "gentle intro"
18:41:26 <allbery_b> but if it's a single token (' ', or c, etc.) you don't need parens or $
18:41:26 <benomatic> so i didn't start completely naive, but i've jumped around as needed.
18:42:09 <benomatic> rahikkala: i also have need to learn scheme so that initially pushed me in this direction
18:43:07 <benomatic> allbery_b: gotcha
18:44:07 <benomatic> rahikkala: i've also been debating whether this is really the way to go... but so far i haven't gone over-the-top-crazy yet.
18:45:29 <rahikkala> benomatic: Well, you seem to be doing fine (read: I did the two dozen questions thing, too, and I liked it) ;)
18:48:47 <benomatic> thanks for the help
18:49:27 <benomatic> ok, funny note: my wife just looked @ my screen while i was typing, and said "there's a phallus on your screen."  she was referring to the "i" in the ghci logo.
18:49:38 <JohnnyL> factorial n = n * factorial (n-1)          the n-1 is in () because of the the '-' function?
18:49:59 <Pseudonym> benomatic: Paging Dr. Freud.
18:50:16 <Pseudonym> JohnnyL: Yes.
18:50:17 <allbery_b> JohnnyL: function application has highest precedence, so it would be read as (factorial n) - 1 otherwise
18:50:36 <sieni> benomatic: lol
18:50:36 <JohnnyL> thanks guys.
18:50:54 <JohnnyL> hey, can someone point me to the online video tutorings of haskell? the site has SOO much.
18:56:14 <benomatic> Pseudonym: My wife *is* a doctor, although not a shrink, so who knows...
18:58:39 <`> woo funk
19:00:32 <dons> you probably should pick a better nick ;) gmh33
19:00:37 <dons> 06.10.11:19:54:12 <gmh33__> woo types
19:00:49 <dons> since it makes me dive into the logs to see if its a trol attack ;)
19:00:51 <gmh33> dons: I just need to reset my prefs
19:02:09 <dino-> @seen kowey
19:02:09 <lambdabot> I saw kowey leaving #darcs and #haskell 1d 11h 32m 8s ago, and .
19:02:13 <gmh33> does gmh33 hurt your brain?
19:02:23 <dons> no, that's fine
19:02:45 <gmh33> was it `?
19:03:02 <gmh33> my chat client kinda set itself to use that by default.. I just fixed that :)
19:03:08 <dons> heh
19:10:26 <TomMD> @users
19:10:27 <lambdabot> Maximum users seen in #haskell: 322, currently: 290 (90.1%), active: 36 (12.4%)
19:11:40 <dons> you know you're a pure functional programmer when .... the idea of untarring a src bundle over a directory feels 'unsafe'
19:12:16 <TomMD> unsafePerformIO $ /msg lambdabot ...
19:12:31 * gmh33 wonders about guis..
19:12:44 <TomMD> ICFP '05 had the best GUI
19:13:18 <gmh33> I wrote the vm in common lisp and factor...
19:13:31 <gmh33> I was going to write one in c just to get a decent one :/
19:13:53 <Pseudonym> Can anyone think of an elegant way to runSTUArray, only with more than one array being returned?
19:19:16 <ddarius> @type runSTUArray
19:19:21 <lambdabot> Not in scope: `runSTUArray'
19:19:31 <ddarius> @index runSTUArray
19:19:32 <lambdabot> Data.Array.ST
19:19:40 <ddarius> @type Data.Array.ST.runSTUArray
19:19:41 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
19:19:55 <Pseudonym> It turns a STUArray into a UArray.
19:20:07 <Pseudonym> But I've got four of them.
19:21:09 <sorear> DIY?
19:21:23 <sorear> (runST + unsafeFreeze)
19:23:36 <Pseudonym> I did some array index hackery instead.
19:23:43 <Pseudonym> The arrays are all the same size and all the same type.
19:25:16 <sorear> Pseudonym: are these like color components?
19:25:31 <sorear> perhaps you should use an extra index?
19:25:47 <sorear> data Component = Red | Green | Blue | Alpha deriving(Ix)
19:26:46 <sjanssen> @hoogle unsafeFreeze
19:26:47 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
19:29:12 <Pseudonym> No, it's not color components.
19:29:21 <Pseudonym> Bitmaps, actually.
19:29:34 <Pseudonym> Bit vectors.
19:30:05 <sorear> does the extra index make sense in your context?
19:30:21 <Pseudonym> Kinda.
19:30:27 <Pseudonym> More or less.
19:30:36 <Pseudonym> It's over all integers in some range.
19:30:51 <Pseudonym> But it's only defined for n mod 12 = 1, 5, 7 and 11
19:31:00 <Pseudonym> Hence I was using four bitvectors.
19:31:16 <sorear> oh.
19:33:58 <sorear> you've said too much
19:33:58 <sorear> I know you are writing a sieve
19:34:13 <Pseudonym> Yup.
19:34:22 <Pseudonym> It's no secret.
19:34:29 <Pseudonym> But it's too much detail for the question.
19:35:16 <sorear> I wonder if it would make sense to newtype Int with a custom Ix instance.
19:37:12 <JohnnyL> man there are orders of magnitude in difference between compiling hugs or ghc as compared to SBCL lisp.
19:37:44 <sorear> ?
19:37:55 <sorear> hugs doesn't compile
19:38:16 <Cale> sorear: I think he's referring to compiling the compiler/interpreter itself.
19:38:18 <sorear> oh right
19:38:21 <Cale> JohnnyL: you basically don't compile GHC unless you're going to change it.
19:38:29 <LoganCapaldo> sorear: you compile hugs though don't you?
19:38:30 <sorear> how slow is compiling SBCL?
19:38:40 <Cale> There are binary releases :)
19:39:05 <sorear> JohnnyL: < or > ?
19:39:09 * LoganCapaldo hearts binary releases of ghc
19:39:17 <LoganCapaldo> I compiled it once
19:39:21 <LoganCapaldo> never again
19:39:44 <sorear> I compile it weekly
19:39:47 <sorear> it's fun
19:40:16 <benomatic> you have a twisted sense of fun
19:40:18 <chessguy> 'evening haskellers
19:40:26 <LoganCapaldo> Your computer most be beefier than mine or you must have more patience than me
19:40:31 <benomatic> my laptop was screaming hot when i installed ghc from ports
19:40:41 <benomatic> took sth like 5 hours
19:40:54 <sorear> odd
19:40:59 <sorear> usually 90min here
19:41:16 <sorear> and it runs in the background so I don't notice
19:41:30 <LoganCapaldo> Maybe he was doing a bootstrapping compile?
19:41:32 <sorear> then suddenly my ghci gets some cool new feature
19:41:37 <sorear> like a debugger
19:41:49 <bd_> sorear: and all your installed libraries break? :)
19:41:52 <LoganCapaldo> lol
19:41:55 <sorear> LoganCapaldo: ghc must be bootstrapped to work properly
19:41:57 <benomatic> ja, i think macports does a bootstrap first, then compiles ghc, then builds all the tests, libs, etc.
19:42:14 <sorear> LoganCapaldo: where properly is defined as "GHCi"
19:42:20 <LoganCapaldo> sorear: I meant the whole starting off w/o Haskell kind of bootstrap
19:42:35 <allbery_b> macports downloads a binary boostrap, I think
19:42:37 <Pseudonym> Woo!
19:42:40 <Pseudonym> My sieve works!
19:42:48 <allbery_b> and 5 hours sounds like my G4 mini
19:42:49 <sorear> LoganCapaldo: wouldn't that be faster?  (since you have .hc files)
19:43:13 * Pseudonym computes how many primes there are up to 1,000,000,000
19:43:17 <sorear> P4, 2Ghz, "I always thought it was the slowest computer left in the western world"
19:43:17 <benomatic> my old g4 laptop was probably cpu faster than a mini but disk slower
19:43:27 <LoganCapaldo> not if you wanted it to be "right"
19:43:33 <sorear> very fast disks, however
19:43:36 <chessguy> Pseudonym, how many are there?
19:43:38 <LoganCapaldo> I'm assuming that you'd compile it and then compile it again
19:43:46 <Pseudonym> Dunno, hasn't finished yet.
19:43:57 * Pseudonym is timing it against Eratosthenes
19:44:06 <Pseudonym> Which is kinda slow up in this range.
19:44:15 * sorear keeps meaning to write SHC
19:44:31 <chessguy> SHC?
19:45:05 <sorear> polyvariate predication analysis (for an optimizing haskell compiler) keeps popping into my head ... it sounds very fun
19:45:12 <chessguy> sorear's haskell compiler?
19:45:25 <sorear> True
19:46:49 <Binkley> I've always wondered what it would have been like to move to Texas and name a Haskell compiler after it
19:47:14 * ddarius is in Texas... but he wouldn't name a compiler after it.
19:47:28 <Binkley> well, how could you *not* name a Haskell compiler after it?
19:47:39 <chessguy> name a haskell compiler after texas?
19:48:06 <LoganCapaldo> Binkley: Are you on drugs or something?
19:48:09 <Binkley> LOL
19:48:10 <chessguy> ddarius, whereabouts? my fiancee is in texas
19:48:11 <LoganCapaldo> ;)
19:48:16 <Binkley> I wish I was!
19:48:18 * sorear tried in vain to figure out what was so funny about "the haskell channel"
19:48:30 <ddarius> chessguy: San Angelo
19:48:47 <chessguy> hmm. i don't have a clue where that is
19:48:50 <chessguy> it's a big state
19:49:01 * chessguy googles
19:49:43 <sieni> the guys from Tampere could make their own Haskell Compiler as well
19:49:45 <chessguy> oh you're west of where she is by a few hours
19:50:22 <ddarius> It's the biggest city in Texas without a major highway." *sigh*
19:50:51 * rahikkala considers the Oulu Haskell Compiler and does not find it a good idea
19:51:32 <sieni> or "funny"
19:51:51 * ddarius will be in Oahu for a week, but won't have time to program at all let alone implement a Haskell compiler.
19:51:55 <TomMD> THC = Tampere Haskell Compiler.  Often known as the Glorious Tampere Haskell Compiler.
19:52:19 <Binkley> well, I certainly think a trip to Oahu would be wasted if you didn't write a Haskell compiler while there
19:53:39 <ddarius> Binkley: If I -have- time to program at all then the trip will be wasted.
19:53:39 <LoganCapaldo> someone should write a HC in this room
19:53:45 <LoganCapaldo> then it could be #HC
19:55:45 <Binkley> ddarius: well, when I went to Oahu it was almost as if I'd have been better off staying inside writing a compiler
19:55:49 <Binkley> since I got sick from the humidity
19:55:53 <Binkley> but it was beautiful
19:56:06 <Binkley> hey, I have an idea, someone should write a Haskell compiler entirely in lambdabot
19:56:11 <Binkley> or rather, several people should
19:56:14 <Binkley> on the channel
19:56:23 * ddarius doesn't really intend to site-see or do much touristy things at all.
19:56:24 <bd_> import GHC.someinternalmodule? :)
19:57:11 <Binkley> yeah, avoid the touristy things at all costs
19:57:18 <Binkley> tourists in Oahu will make you want to hate life
19:57:21 <Binkley> like tourists anywhere, really
19:59:33 <chessguy> hmm, Oahu is in Hawaii?
19:59:45 <Binkley> it's one of the islands of Hawaii
20:00:06 <chessguy> ok, i was close
20:00:15 <Binkley> well, sure, it is in Hawaii
20:00:21 <Binkley> Hawaii is a set of islands that includes Oahu :-)
20:03:21 <chessguy> i'm gonna see hawaii in less than 13 months!
20:03:24 <sieni> Hawaii is also an island in Hawaii
20:04:01 <Binkley> this is true
20:04:45 <ddarius> I'm going to Hawaii in less than a month.
20:05:16 <chessguy> oh yeah? well *I*'m going for my honeymoon. so there!
20:05:43 * ddarius is going for his girlfriend.
20:06:21 <chessguy> and my fiancee's dad is springing for the cost of the trip!
20:06:47 * ddarius paid for the tickets, but doesn't have to worry about lodging.
20:07:21 <chessguy> nice
20:07:46 <chessguy> we'll be having to get a hotel or something
20:08:08 <ddarius> For you the hotel costs will probably be more than my ticket costs.
20:08:08 <chessguy> but that's quite alright!
20:08:15 <Binkley> well, I went there with my girlfriend and we broke up on the third day of the trip
20:08:17 <Binkley> so watch out1
20:08:25 <Binkley> I think it's very valid to conclude from that that Hawaii causes breakups
20:08:29 <ddarius> Binkley: I'm going to meet her.
20:08:31 <chessguy> lol
20:08:33 <Binkley> heh
20:08:39 <ddarius> Binkley: She lives there.
20:08:40 <LoganCapaldo> Hawaii is a category of islands where a morphism exists between two islands iff there is some crazy guy with a beat up boat that travels between the two
20:08:50 <Binkley> my girlfriend-at-the-time had lived there in the past
20:09:10 <ddarius> Ironically, my girlfriend is from Texas.
20:09:19 <Binkley> so Hawaii is a natural meeting place then!
20:09:27 <chessguy> lol
20:09:55 <chessguy> well, my fiancee (from Texas) and i (from pennsylvania) are talking about living in Ohio when we get married
20:10:04 <Binkley> why would anyone aspire to live in Ohio?
20:10:06 <Binkley> I've been to Ohio
20:10:07 <Binkley> I know
20:10:21 <ddarius> I've only been in Ohio a month.
20:10:26 <chessguy> there's a haskell job there that i want to try to get
20:10:27 * ddarius is from Northern Virginai.
20:11:11 <Binkley> well, good luck getting it
20:11:19 <Binkley> it's what we all dream of, isn't it?
20:11:21 <Binkley> I mean, Haskell jobs
20:11:24 <Binkley> not Ohio
20:11:27 <Binkley> I know I don't dream about Ohio
20:11:28 <jcreigh> lol
20:11:30 <chessguy> lol
20:11:32 * ddarius will probably take a stab at working at Galois Connections in some odd years.
20:11:33 <Binkley> and when I do, I wake up in a pool of sweat
20:11:57 <davidmccabe> What would be the correct symbol to use for "evaluates to" in print?
20:12:00 <davidmccabe> =>  ?
20:12:00 <chessguy> what's so bad about ohio?
20:12:12 * allbery_b lived in Ohio for most of his life
20:12:14 <Binkley> davidmccabe: some kind of arrow, but there's no real agreement on what kind
20:12:20 <davidmccabe> Binkley: but an arrow?
20:12:21 <Binkley> just be sure you state your notation explicitly and then use it consistently
20:12:24 <chessguy> allbery_b, whereabouts?
20:12:28 <Binkley> usually it's an arrow, by convention
20:12:32 <allbery_b> ...then I moved to Pittsburgh, which is a wannabe-Cleveland (apparently including defaulting...)
20:12:32 <Binkley> but some people like squiggly arrows
20:12:36 <Binkley> others like the non-squiggly kind
20:12:53 <ddarius> some use the big step reduction downward arrow
20:12:58 <allbery_b> various suburbs and small towns around the Cleveland area
20:13:00 <chessguy> eww, i don't like pittsburgh
20:13:12 <Binkley> yeah, I'm not the world's biggest fan of Pittsburgh either
20:13:17 <Binkley> even though my life did change there once
20:13:22 <ivanm> Hey everyone... is there a version of nubBy which removes _both_ elements from the list if they equal each other?
20:13:28 <chessguy> ok, i once spent 6 weeks in dayton. the job would be in columbus
20:13:48 <Binkley> Columbus has a good bookstore
20:13:50 <Binkley> the Book Loft
20:13:55 <Binkley> if you go there to interview, it's worth stopping at :-)
20:14:05 <chessguy> haskell books?
20:14:07 <ddarius> filter (null . tail) . groupBy pred
20:14:24 * allbery_b would not cry much if Oakland and Squirrel Hill remaind and the rest of Pittsburgh were ejected into the sun...
20:14:52 <Binkley> I didn't see any Haskell books
20:14:54 <Binkley> but that's no shock
20:15:00 <chessguy> yeah
20:15:08 <chessguy> you pretty much have to buy haskell stuff online
20:15:13 <Binkley> from Canada
20:15:23 <Binkley> because in the US you need a prescription
20:15:25 <chessguy> i ordered HSOE and Craft, and both of them are taking weeks
20:16:26 <dmead> god
20:16:31 <dmead> i'm reading the mailing list
20:16:34 <ivanm> ddarius: thanks, that works, just have to map head onto the results (it returns a list of lists)
20:16:35 <dmead> there should be like
20:16:46 <dmead> a warning posted so people don't treat haskell like perl
20:16:48 <Binkley> hahaha
20:16:50 <SamB> you need a prescription for Haskell books?
20:16:54 <Binkley> there should be a warning posted for the mailing list
20:16:56 <Binkley> about reading it
20:17:01 <dmead> hehe
20:17:04 <Binkley> SamB: yes. Haskell books in the wrong hands can be deadly
20:17:05 <ddarius> @google Haskerl
20:17:10 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:17:10 <lambdabot> Title: The Haskerl index
20:17:22 <chessguy> treat it like perl how?
20:17:23 <dmead> ;o
20:17:38 <dmead> like
20:17:45 <dino-> Does anybody know, with HXT, can I use an XPath string to get back a subtree from a parsed document? Or is it all about the XSLT transformations with that thing?
20:17:51 <dmead> if you go 5 or more haskell words
20:17:51 <sorear> dons: the good news is yi compiles with vty 3.
20:17:51 <sorear> dons: the bad news is it immediately goes into an infinite loop.
20:17:54 <dmead> withouth typing english
20:17:59 <dmead> and using all operators
20:18:14 <dmead> it should be looked on like making a run on sentence in english
20:18:16 <SamB> dino-: "subree"?
20:18:28 <dino-> I spent some time with some of the docs, but the arrow stuff is wiping me out. :o
20:18:30 <SamB> I think you can get the result of an XPath query on a tree...
20:18:36 * sorear just piped darcs w | HsColor -tty
20:19:23 <SamB> sorear: at least the compiler doesn't...
20:19:29 <sorear> gah.
20:19:36 <sorear> I see the (a?) bug
20:19:52 <sorear> code that was perfectly illegal with vty 2
20:20:02 <sorear> but happened to dtrt regardless :(
20:20:25 <SamB> how insidious
20:20:34 <jcreigh> "perfectly illegal"?
20:20:49 <allbery_b> evidently not perfectly, since it worked anyway...
20:20:55 <ddarius> @type liftIO
20:21:00 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
20:21:54 <ddarius> @type lift
20:21:56 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:23:43 <LoganCapaldo> Haskerl is apparently an april fools joke, however I find it interesting that it appears to have been written before do notation, but describes what essentially amounts to do notation as a feature to make Haskell more perlish
20:24:40 <LoganCapaldo> do { -- Oh no perl mode!
20:26:33 <Binkley> arguably, Haskell is also an April Fool's joke :-)
20:27:02 <chessguy> what's the punch line?
20:27:26 <Pseudonym> "...and it's actually useful!"
20:27:30 <Binkley> heh
20:27:31 <SamB> was pugs an april fools joke too?
20:27:49 <Pseudonym> Yeah.  The punch line to pugs is "and Perl 6 is actually implementable!"
20:27:54 <Binkley> haha
20:28:56 <allbery_b> they talk about christmas but it's actually an easter egg?
20:29:16 <Binkley> Why do computer scientists confuse Halloween and Christmas, etc.
20:29:34 <allbery_b> actually the scarier part is that the most complete implementation of perl6 is in haskell, that might be the real april fools joke
20:30:01 <bd_> allbery_b: Then you realize it's not a joke... and begin to fear.
20:31:46 * allbery_b notes that he's already done some p6 hacking, so is rather more amused than scared
20:31:47 <bd_> mm, how does one build hs-plugins to install to a user directory? It has a configure script to invoke cabal...
20:32:04 <allbery_b> er?  cabal usually runs configure
20:32:22 <bd_> ... oh
20:32:44 <bd_> >.>;
20:34:29 <sorear> now yi at least has the dignity to error
20:34:35 <sorear> or rather _|_
20:35:12 <LoganCapaldo> _|_s up
20:38:38 <dmead> :>
20:44:14 <ddarius> @type showHex
20:44:15 <lambdabot> forall a. (Integral a) => a -> ShowS
20:44:35 <ddarius> @index showHex
20:44:36 <lambdabot> Numeric
20:49:42 <nrb23> ?where paste
20:49:42 <lambdabot> http://kakapo.scannedinavian.com:8000
20:49:53 <nrb23> ?where hpaste
20:49:53 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
20:50:19 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Prime.hs
20:50:23 <Pseudonym> Atkin-Bernstein sieve.
20:51:43 <allbery_b> @paste --- here?
20:51:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:51:55 <allbery_b> (those both point to the same place, btw)
20:52:24 <allbery_b> hm, no, the second is the source, sorry
20:52:25 <hpaste>  nrb23 pasted "there's gotta be a better way" at http://hpaste.org/462
20:52:54 <nrb23> there's gotta be a better way to pull bits of a list into values
20:54:07 <nrb23> seems like it might be a monad
20:54:18 <nrb23> but, I don't know what I'm doing :->
20:56:09 <Thomas2> you can define a state monad over lists, and an operator that gets you the head and leaves the tail in the state
20:56:29 * Thomas2 looks at the actual paste
20:57:22 <nrb23> it seems that what I'm trying to do resembles what Parsec can do, but is even simpler
20:58:19 <Thomas2> is the type coercion really needed?
20:58:44 <nrb23> the :: ([Word8], [Word8]) ?
20:58:56 <nrb23> I don't think so.. I believe that was put in when I was confused about something else
20:59:22 <Binkley> that's not a type coercion
20:59:24 <Binkley> it's a type declaration
20:59:32 <nrb23> yes
20:59:40 <Binkley> it never hurts to have them in there, if they help you debug the type error messages
20:59:42 <nrb23> but, I believe that's what Thomas2 was refering to
20:59:51 * allbery_b thought Data.Binary had a Get monad for this kind of thing...
20:59:57 <Thomas2> meh, I think about it as coercion. yes, you're not coercing from one type to another, but it does coerce the compiler to pick a particular option sometimes
21:00:42 <Thomas2> probably a poor choice of wording
21:01:27 <Binkley> yeah, "type coercion" has a specific technical meaning in GHC Haskell
21:01:30 <Binkley> so be careful there :-)
21:01:57 <Thomas2> yeah, I think we've established I'm in the wrong :-)
21:03:31 <nrb23> hm.. Data.Binary.Get uses a ByteString
21:03:42 <nrb23> I'll have to figure out how to coerce my stuff into a ByteString
21:04:56 <nrb23> Binkley: cool.. this is kinda what I was looking for
21:06:52 <nrb23> hmm: http://haskell.org/hoogle/?q=ByteString
21:06:53 <lambdabot> Title: ByteString - Hoogle
21:07:25 <sjanssen> nrb23: hoogle's index is out of date
21:07:33 <nrb23> sadness
21:07:51 <sjanssen> @docs Data.ByteString.Lazy
21:07:51 <lambdabot> Data.ByteString.Lazy not available
21:07:55 <sjanssen> erg
21:08:21 <Binkley> try http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
21:08:23 <lambdabot> http://tinyurl.com/y58jn8
21:08:25 <ddarius> Bah big endian insanity.
21:08:38 <Binkley> tired of big-endian/little-endian conflicts? Try bytesexuality
21:09:01 <nrb23> thanks, that works
21:09:06 <ddarius> It's not a conversion issue, it's that big endian is insane.
21:09:34 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Lazy.html -- you want Data.ByteString.Lazy if you're interfacing with the binary library
21:09:36 <lambdabot> http://tinyurl.com/244l36
21:09:40 <sjanssen> nrb23: ^^^
21:09:41 <Binkley> I think endianness is too controversial
21:09:45 <Binkley> let's talk about trailing commas instead
21:10:50 <nrb23> sjanssen: what about converting from Ptr Word8 ?
21:12:19 <sjanssen> nrb23: you'll probably need both the Data.ByteString and Data.ByteString.Lazy modules for that
21:13:22 <nornagon> class MonadState m s | m -> s where -- what?
21:13:45 <sjanssen> nrb23: packCString would be a good place to start
21:14:03 <sjanssen> nrb23: where are you getting these Ptr Word8's?
21:14:11 <sjanssen> nornagon: which part confuses you?
21:14:24 <nrb23> sjanssen: from the pcap module
21:14:39 <nornagon> sjanssen: the m -> s
21:14:47 <nornagon> and the | before it
21:14:47 <nornagon> :P
21:14:48 <sjanssen> actually, packCString is bad advice, probably
21:15:01 <sjanssen> nornagon: the | means a functional dependency
21:15:17 <nornagon> which is..?
21:15:26 <sjanssen> it says that: for any "m", there is only only potential "s"
21:16:06 <nornagon> um.
21:16:17 <nrb23> sjanssen: if not packCString, then what?
21:16:39 <sjanssen> so, for any given state monad m, it can contain only one type of state s
21:17:07 <Jaak> yawrning
21:17:07 <nornagon> i see... sort of
21:18:14 <sjanssen> nrb23: packCStringLen is probably better
21:18:49 <sjanssen> nrb23: or use the bytestring constructor directly (which you can find in Data.ByteString.Base)
21:19:29 <nrb23> what are the two things after it?
21:19:44 <nrb23> PS !(ForeignPtr Word8) !Int !Int
21:19:50 <sjanssen> first thing is offset, second is length
21:19:54 <nrb23> ah
21:19:58 <nrb23> what should be in the docs :->
21:20:24 <sjanssen> nrb23: yeah, it should
21:20:37 <Binkley> the notation is meant to suggest "m implies s", which is vaguely the right interpretation
21:21:14 <nornagon> hmm.
21:29:43 <nornagon> @index isPrefixOf
21:29:43 <lambdabot> Data.List
21:31:20 <nornagon> @tell dons The Roll your own IRC bot doesn't tell the reader to import Data.List before the refactoring section... so the code at that point doesn't run. Also the 'privmsg' function isn't defined at that point in the tutorial.
21:31:20 <lambdabot> Consider it noted.
21:38:32 <nornagon> @pl (\a -> flip (bracket a))
21:38:33 <lambdabot> flip . bracket
21:40:10 <ddarius> ... ... that would explain it.
21:42:35 <nrb23> why can't I import Data.Binary.Get ?
21:44:54 <nrb23> @docs Data.Binary.Get
21:44:54 <lambdabot> Data.Binary.Get not available
21:45:06 <nornagon> @index Data.Binary.Get
21:45:06 <lambdabot> bzzt
21:46:40 * nrb23 loses
21:46:49 * nornagon loses :(
21:47:38 <sjanssen> nrb23: have you installed the binary library?
21:47:48 <nrb23> sjanssen: it's not part of the base?
21:48:02 <sjanssen> nrb23: no
21:48:09 <nrb23> oh, well, that would do it
21:48:31 <nrb23> http://darcs.haskell.org/binary/ ?
21:48:32 <lambdabot> Title: Index of /binary
21:48:55 <nrb23> is there a better way to get it other than grabbing that via darcs?
21:48:57 <sjanssen> nrb23: that's the development version -- it should be in hackage too
21:49:04 <sjanssen> @where hackage
21:49:05 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
21:50:00 * nrb23 downlaods
22:03:30 <ddarius> success or close enough
22:18:28 <nrb23> well, bedtime for me
22:18:31 <nrb23> 'night
22:18:36 <nrb23> thanks for your help
22:40:11 <gavin_on_archlnx> If I am new to programming and the tutorial another haskell tutorail get to a part where he starts talking about folding left and my brain freezes is that normal?
22:40:32 <lispy> gavin_on_archlnx: yup
22:40:39 <lispy> gavin_on_archlnx: let's try some examples
22:40:48 <lispy> > foldl (+) 0 [1..3]
22:40:52 <lambdabot>  6
22:40:59 <lispy> gavin_on_archlnx: does that example make any sense?
22:42:15 <bd_> gavin_on_archlnx: foldl.com can be ... enlightening
22:42:34 <bd_> and foldr.com of course
22:42:34 <lispy> foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
22:42:50 <lispy> (that's pasted from the ghc docs)
22:43:10 <gavin_on_archlnx> hm
22:43:32 <lispy> in my example, foldl (+) 0 [1..3] == (((0 + 1) + 2) + 3)
22:43:54 <gavin_on_archlnx> well I have seen some lisp and the + just gets applied from 1 to 3, so 1+2+3=6
22:43:57 <sorear> \NUL
22:44:20 <lispy> gavin_on_archlnx: are you comfortable with recursion?
22:44:32 <gavin_on_archlnx> nope
22:44:41 <lispy> ah, okay, that's part of why this might seem confusing
22:44:53 <gavin_on_archlnx> I mean I can kinda venture there mentally
22:45:05 <lispy> personally, i think map is easier than fold, so you may want to go back and study map a bit then try fold again
22:45:06 <gavin_on_archlnx> but I can't claim I understand it
22:45:26 <lispy> when you get it, you'll see than fold is actually quite simple
22:45:35 <lispy> but you have to play enough to have it "click"
22:45:43 <gavin_on_archlnx> hm
22:46:59 <lispy> > foldl (==) True [True, True]
22:47:00 <lambdabot>  True
22:47:04 <lispy> > foldl (==) True [True, False]
22:47:05 <lambdabot>  False
22:47:10 <ddarius> exit
22:47:27 <gavin_on_archlnx> I mean I get that you start at 0, then goto the first number, then apply the function, hold the result, and then apply function to 2nd number but insteada using 0 u use held result
22:47:40 <gavin_on_archlnx> then continue along
22:47:45 <gavin_on_archlnx> until last number in list
22:48:12 <gavin_on_archlnx> am I close?
22:48:43 <lispy> sounds good
22:49:13 <lispy> in lisp they call this function, "reduce"
22:49:21 <gavin_on_archlnx> I think as with linux, the trick is to find what not to worry about, which is most
22:49:24 <lispy> because it takes a binary function and reduces a list to a single value
22:49:33 <gavin_on_archlnx> hm
22:50:12 <lispy> > foldl (-) 0 [1..3]
22:50:13 <lambdabot>  -6
22:50:15 <gavin_on_archlnx> what lisp do you prefer?
22:50:17 <lispy> > foldr (-) 0 [1..3]
22:50:18 <lambdabot>  2
22:50:30 <lispy> gavin_on_archlnx: when i used to use lisp i preferred sbcl
22:50:37 <lispy> gavin_on_archlnx: these days i use haskell in place of lisp
22:50:38 <tessier> gavin_on_archlnx: Hillcrest or Castro.
22:50:54 <gavin_on_archlnx> tess?
22:51:31 <gavin_on_archlnx> wait explain foldr on
22:51:37 <Cale> foldr is more natural than foldl
22:51:38 <lispy> > ((((0 + 1) + 2) + 3), (((0 - 1) - 2) - 3))
22:51:40 <lambdabot>  (6,-6)
22:51:50 <Cale> You know how lists are built up from (:) and [] ?
22:52:13 <gavin_on_archlnx> my messenger put a smiley face there
22:52:15 <gavin_on_archlnx> lol
22:52:16 <Cale> hehe
22:52:21 <Cale> cons and nil
22:52:43 <Cale> foldr f z replaces each cons with f and the nil at the end with z
22:52:45 <lispy> > ((((0 - 1) - 2) - 3), 0 - (1 - (2 - 3))) == (foldl (-) 0 [1..3], foldr (-) 0 [1..3])
22:52:45 <gavin_on_archlnx> not that familiar with that
22:52:46 <lambdabot>  False
22:52:49 <Cale> ah, okay
22:52:56 <lispy> heh, i must have a typo
22:52:57 <Cale> > 1 : (2 : (3 : []))
22:52:58 <lambdabot>  [1,2,3]
22:53:12 <gavin_on_archlnx> hm
22:53:25 <Cale> Every list is either x : xs for some element x and list xs, or it's [], the empty list.
22:53:29 <Botje> > foldr (:) [] [1..3]
22:53:30 <lambdabot>  [1,2,3]
22:53:36 <Botje> ta-dah
22:53:41 <gavin_on_archlnx> explain the foldr (-) 0 [1..3]
22:53:53 <Cale> 1 - (2 - (3 - 0))
22:54:04 <Cale> = 1 - (2 - 3)
22:54:08 <Cale> = 1 - (-1)
22:54:13 <Cale> = 2
22:54:20 <gavin_on_archlnx> oh crap yes the -
22:54:24 <gavin_on_archlnx> heh
22:55:21 <Cale> > foldr (\x xs -> concat ["(", show x, " : ", xs, ")"]) "[]" [1,2,3,4,5]
22:55:23 <lambdabot>  "(1 : (2 : (3 : (4 : (5 : [])))))"
22:55:50 <Cale> > foldr (\x xs -> concat ["(f", show x, " ", xs, ")"]) "z" [1,2,3,4,5]
22:55:52 <lambdabot>  "(f1 (f2 (f3 (f4 (f5 z)))))"
22:55:58 <Cale> er, missed a space :)
22:56:01 <Cale> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1,2,3,4,5]
22:56:02 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
22:56:25 <gavin_on_archlnx> ok, Every list is either x : xs for some element x and list xs, or it's [], the empty list.
22:56:37 <Cale> > foldl (\y x -> concat ["(f ", y, " ", show x, ")"]) "z" [1,2,3,4,5]
22:56:38 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
22:57:00 <gavin_on_archlnx> so if i have a list
22:57:16 <gavin_on_archlnx> customer1,customer2,customer3,customer4
22:57:26 <gavin_on_archlnx> ..
22:57:44 <gavin_on_archlnx> well shoot now we are dealing with non numerical
22:57:44 <Cale> It's customer1 : [customer2, customer3, customer4]
22:57:51 <gavin_on_archlnx> ok
22:57:59 <gavin_on_archlnx> so 1st element, rest fo list?
22:58:02 <Cale> yes
22:58:04 <Cale> exactly
22:58:11 <gavin_on_archlnx> so any list is part of bigger list
22:58:23 <gavin_on_archlnx> ..
22:58:26 <gavin_on_archlnx> potentially
22:58:35 <Cale> well, depending on what you mean by "bigger" exactly, but yeah.
22:58:44 <gavin_on_archlnx> ok
22:59:00 <gavin_on_archlnx> well
22:59:04 <Cale> Once a list is infinitely long, it doesn't get much larger, but it can still be the tail of another list.
22:59:18 <gavin_on_archlnx> should I jsut kinda start with yet another haskell tutorail and bang thru it?
22:59:24 <Cale> Sure :)
22:59:35 <Cale> Feel free to ask lots of questions here though
22:59:41 <gavin_on_archlnx> only cool thing is I have 0 programming
22:59:47 <gavin_on_archlnx> except for minimal bash
22:59:54 <Cale> ah, that's actually perhaps a good thing.
22:59:55 <gavin_on_archlnx> so no preconcieved notion
22:59:57 <gavin_on_archlnx> :)
23:00:09 <gavin_on_archlnx> tabula r
23:00:27 <Cale> Yeah, knowing C and such can actually get in the way at first.
23:00:47 <gavin_on_archlnx> I just got the jernighan book today
23:00:53 <gavin_on_archlnx> kernighan
23:00:57 <gavin_on_archlnx> Im thinking
23:01:15 <gavin_on_archlnx> c is pretty common in unix, maybe its jsut hype that its brittle,
23:01:26 <gavin_on_archlnx> maybe if I learn it ill kick butt
23:01:29 <gavin_on_archlnx> hm
23:01:31 <pjd> Cale: probably more having C habits ingrained from long-term use, rather than just knowing C
23:01:50 <gavin_on_archlnx> wel thanks
23:01:52 <gavin_on_archlnx> :)
23:01:59 <pjd> so no harm in learning both C and Haskell :)
23:02:13 <Cale> pjd: yeah
23:02:14 <gavin_on_archlnx> oh?
23:02:25 <gavin_on_archlnx> hm
23:02:26 <pjd> C is really nice, in its own way
23:02:35 <gavin_on_archlnx> fast eh?
23:02:40 <Cale> Knowing C isn't so much the problem as being biased towards its way of doing things.
23:02:49 <pjd> gavin_on_archlnx: not so much fast, as low-level
23:03:10 <gavin_on_archlnx> whats the most high level lang?
23:03:24 <pjd> gavin_on_archlnx: Haskell is close :)
23:03:32 <gavin_on_archlnx> cool
23:03:38 <sieni> gavin_on_archlnx: Java
23:03:48 <gavin_on_archlnx> I like to peek at lots of free software
23:03:55 <pjd> there's no higher-level language than Haskell in common/"production" use, i think
23:04:19 <pjd> gavin_on_archlnx: if you're looking for another language to put on your list, try Scheme
23:04:34 <gavin_on_archlnx> I have plt scheme here and scsh
23:04:38 <gavin_on_archlnx> its interesting
23:04:43 <Cale> Haskell is probably the highest level language available at the moment which you can get practical use out of, not counting special-purpose languages.
23:04:51 <gavin_on_archlnx> scsh is kinda interesting since it mixes in with unix
23:05:01 <gavin_on_archlnx> ah
23:05:28 <sorear> I used to know C
23:05:29 <Cale> There are some research languages like Epigram which are pretty cool, but not yet at the point where they're really practical.
23:05:31 <vincenz> meurning
23:05:38 <sorear> now my C mostly looks like
23:05:53 <sorear> int main () = printf "Hello World" ; return ()
23:06:03 <sorear> it's amazing what Haskell can do
23:06:17 * vincenz wonders why there is no class
23:06:25 <vincenz> instance (Num a, Monad m) => Num (m a) where ...
23:06:36 <vincenz> that would allow you to do cool things like
23:06:38 <vincenz> [1..4] + 3
23:07:24 <Cale> sorear: hehe
23:08:24 <Cale> vincenz: Well, that would be cool, but it would sometimes overlap with instances you might want to write.
23:09:00 <gavin_on_archlnx> hm
23:09:28 <gavin_on_archlnx> is haskell a memory hog?
23:09:35 <sorear> depends :)
23:09:45 <sorear> what compiler, what problem, what reference
23:09:51 <gavin_on_archlnx> linux ghc
23:10:09 <sorear> rarely needs more than 20MB for me (runtime)
23:10:19 <sorear> ... which is rarely a problem here
23:10:48 <vincenz> Cale: such as?
23:10:59 <sorear> Haskell in resource constrained environments is considered "PhD dissertation territory"
23:11:05 <vincenz> Cale: and -fallow-overlapping-instances
23:11:05 <Cale> vincenz: using lists of numbers as coefficients for polynomials
23:11:30 <gavin_on_archlnx> hm
23:11:40 <gavin_on_archlnx> scheme seems to have plenty of power
23:11:42 <pjd> Cale: isn't it possible to distinguish the two?
23:11:50 <gavin_on_archlnx> how do scheme v haskell compare?
23:11:55 <sorear> gavin_on_archlnx: what is "power" in this context?
23:12:01 <Cale> pjd: by using newtypes, sure.
23:12:09 <sorear> gavin_on_archlnx: scheme is much older and has way more compilers
23:12:17 <gavin_on_archlnx> well, ability to create apps of many kinds that perform well
23:12:20 <pjd> gavin_on_archlnx: the biggest difference is that Scheme is dynamically typed, and generally much simpler
23:12:30 <gavin_on_archlnx> simpler?
23:12:32 <sorear> gavin_on_archlnx: haskell performs well.
23:12:37 <sorear> not great
23:12:44 <sorear> but not noticably bad
23:12:45 <pjd> gavin_on_archlnx: Scheme's simplicity is legendary :)
23:12:45 <Cale> gavin_on_archlnx: The largest difference in my mind is that scheme is dynamically typed, which means that the compiler doesn't check the types at compile time, only when the operations are performed on the data.
23:13:24 <pjd> the entire language core is defined in something like 50 pages
23:13:24 <Cale> another big difference is that scheme is strictly evaluated, and has primitives for mutating the values of references.
23:13:28 <sorear> Haskell's complexity is largely superficial
23:14:06 <sorear> if you strip out all the rarely used sugar, you get something not a great deal bigger than scheme
23:14:11 <Cale> Haskell has lots of complexity, but it's well-designed, so it seems simple :)
23:14:55 <sorear> if you drop ALL the sugar, a language like GHC Core is quite comparable to scheme .. perhaps even simpler, since there is no need for an evaluation order
23:15:28 <sorear> (explaining System F-C + unboxed kinds might take a few pages, however)
23:15:41 <pjd> Scheme is a good counterpoint to Haskell
23:15:55 <pjd> both are the basis of a lot of programming language research
23:16:19 <gavin_on_archlnx> hm
23:16:59 <gavin_on_archlnx> so for attacking problems like large numbers of people, like governmetn DMV for example, is haskell useful? or does one end up re implementing a database?
23:17:00 <sorear> for me plain old system-f (no recursion, no higher kinds) made monads look duh
23:18:22 <Cale> gavin_on_archlnx: There are database interoperability libraries.
23:19:32 <pjd> "problems like large numbers of people, like governmetn DMV for example" ?
23:19:57 <gavin_on_archlnx> hey has anyone done something liek scsh for haskell? like created a unix shell with haskell as the shell language and some stuff to interface with unix?
23:20:20 <gavin_on_archlnx> dmv meaning tracking data on many people
23:20:22 <sorear> for dealing with large numbers of people, euthenasia beats haskell in every way
23:20:28 <gavin_on_archlnx> lol
23:20:37 <gavin_on_archlnx> neutron bomb?
23:20:49 <tessier> What's all this controversy about the youth in asia?
23:22:08 <sorear> gavin_on_archlnx: I'm not sure ... | ghc -e fi | has almost completely replaced | perl -e foo | for me, and I keep threatening to chsh /usr/bin/ghci
23:22:55 <Cale> gavin_on_archlnx: Some people have played around with the idea. I haven't really seen anything which I'd replace my day-to-day shell with, but there are some nice shell tools written to integrate with GHC by dons, and there are also some neat libraries out there to make shell programming like tasks simpler.
23:23:46 <Cale> http://www.cse.unsw.edu.au/~dons/h4sh.html
23:23:47 <lambdabot> Title: h4sh
23:24:52 <Cale> iirc, the Linspire guys are using Haskell for all their scripting.
23:26:36 <siti> that scripting looks cool
23:27:17 <gavin_on_archlnx> linspire?
23:27:34 <siti> linux distro :p
23:27:35 <gavin_on_archlnx> thats a distro or something
23:28:18 <siti> based on debian owned by the guy who done mp3.com
23:28:36 <sorear> formerly kown as Lindows
23:29:03 <Cale> http://www.eecs.tufts.edu/~rdocki01/shellac.html -- this is a pretty cool library.
23:29:04 <lambdabot> Title: Shellac
23:29:19 <sorear> Any yi hackers awake?
23:29:29 <Cale> It's a library for constructing shells in Haskell.
23:30:46 <sorear> newsham, dons: under what conditions can windows differ in width?
23:30:53 <gavin_on_archlnx> I have zsh on my archlinux
23:30:56 <gavin_on_archlnx> :)
23:31:07 <gavin_on_archlnx> but Ill be damned if I know how to exploit it
23:32:02 <Cale> zsh is pretty nice. I used to use it, but bash caught up to it in most of the respects that I cared about.
23:32:50 <Cale> (So the benefits of using it were outweighed by the inconvenience of using a non-bash shell.)
23:33:10 <sorear> hello!
23:33:24 <pjd> Cale: why is using a non-bash shell inconvenient?
23:33:47 <Japsu> zsh is inconvenient because it doesn't do unicode
23:34:07 <Cale> pjd: It's not so bad, but every once in a while, you'll run into a script which doesn't have a #! header and assumes bash.
23:35:37 <pjd> Japsu: since 4.3.1, it does, doesn't it?
23:35:38 <Cale> Plus, once bash had the feature I really wanted zsh for in the first place (programmable completion), the support for smart completion for things in bash quickly got very good.
23:35:59 <Japsu> pjd: hmm, I must check it out again, then
23:36:18 <sorear> ADEpt: there is growing interest in properly making lambdabot handle non-irc protocols ... newsham has a silc bot, and stepcut has a jabber bot (completely intependent from yours).  now that lambdabot has proper server abstraction support, there needs to be discussion on the subject of how to abstract out the protocol type.
23:36:24 <Japsu> pjd: however, back then when I did use zsh, their FAQ said they're unlikely to implement unicode support anytime soon
23:38:26 <ADEpt> sorear: unfortunately, my take at refactoring lambdabot is slightly abandoned at the moment :(
23:39:28 <sorear> ADEpt: mine too, alas.
23:39:58 <sorear> <-- was responsible for @irc-connect ... multi server turns out to be less useful than it sounds
23:52:28 <gavin_on_archlnx> programmable completion?
23:52:31 <gavin_on_archlnx> hm
23:53:25 <pjd> it's been said that zsh will complete anything short of a random number
23:53:58 <vincenz> @remember pjd it's been said that zsh will complete anything short of a random number
23:53:59 <lambdabot> Done.
23:55:27 <gavin_on_archlnx> lol
23:55:38 <gavin_on_archlnx> nothing like an arsenal of one liners
23:55:41 <gavin_on_archlnx> ;)
23:56:01 <gavin_on_archlnx> http://www.urbandictionary.com/define.php?term=pooned throws this in the mixe
23:56:02 <lambdabot> Title: Urban Dictionary: pooned
23:56:58 <gavin_on_archlnx> r2 should be able to interpret the entire imperial network
