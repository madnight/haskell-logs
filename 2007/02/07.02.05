00:00:20 <nmessenger> kfish: ??
00:01:15 <glguy> http://www.overstock.com/?page=proframe&prod_id=2085239
00:01:17 <glguy> lol
00:01:22 <nornagon> it's a LLAM(bd)A
00:03:22 <nmessenger> You save -$37.46!  (-37%)
00:03:29 <nmessenger> What a great great deal!
00:03:49 <glguy> Next up, coupons that add 10 cents to the price of canned goods
00:04:21 <glguy> apparently newegg sells that same drive for around 70$
00:06:12 <dancor> is there a unix args library
00:06:23 <glguy> System.Console.GetOpt
00:06:32 <dancor> thanks
00:25:41 <moconnor> Is there an HTTP library for Haskell which can speak SSL?  Network.HTTP appears to not be able to.
00:28:28 <nmessenger> @. elite keal
00:28:29 <lambdabot> tHEY dumbifIed yoU
00:30:35 <dons> ?where http
00:30:35 <lambdabot> http://www.haskell.org/http/
00:30:43 <dons> happs can, I think
00:30:49 <dons> double check with Lemmih or musasabi
00:31:34 <explicitjelly> je vais et je viens, contre tes reins, et je me retiens...
00:33:06 <dons> umm
00:35:02 <earthy> I go and I see, against your wishes, and I remember?
00:35:45 <dons> ?babel fr en je vais et je viens, contre tes reins, et je me retiens
00:35:46 <lambdabot>   I go and I come, counter your kidneys, and I retain myself
00:35:49 <dons> heh
00:35:58 <dons> software rocks
00:36:09 * earthy laughs
00:38:03 <Korollary> maybe it's slang
00:38:38 <earthy> nah, it sounds like a sentence from a movie or a poenm or some such
00:38:52 <earthy> kowey would know
00:41:39 <nmessenger> The babelified version reads like a Zen koan.
00:42:01 <nmessenger> @remember lambdabot I go and I come, counter your kidneys, and I retain myself
00:42:02 <lambdabot> Done.
00:43:49 <earthy> 'I go and I come, against your rule, and I control myself' is more like it.
00:48:39 <musasabi> With HAppS we use just an apache proxy in front of it for ssl.
00:48:46 <musasabi> hsgnutls supports SSL.
01:01:54 <robreim> an apache proxy probably won't help if moconnor is trying to use Network.HTTP for client-side stuff
01:35:13 <ivanm> I've got my own version of autrijus' quote on haskell.org about impossible things
01:35:33 <ivanm> "Solvable problems run quickly, unsolvable problems take forever"
01:35:39 <ivanm> At least in my experience :s
01:35:46 <ivanm> (Not that I have much)
02:07:22 <ivanm> Would anyone be willing to look at my code and tell me how I can improve it if I email it to them or post it online somewhere?
02:07:31 <bringert> @where paste
02:07:32 <lambdabot> http://kakapo.scannedinavian.com:8000
02:07:42 <nmessenger> ?paste
02:07:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:07:52 <bringert> hmm
02:07:58 <bringert> why is that different?
02:08:03 <nmessenger> @where+ paste Haskell pastebin: http://hpaste.org/new
02:08:04 <lambdabot> Done.
02:08:06 <nmessenger> old url
02:08:11 <earthy> @where paste
02:08:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:08:17 <earthy> that's better. ;)
02:09:43 <dcoutts> @where haddock-ghc
02:09:43 <lambdabot> I know nothing about haddock-ghc.
02:12:02 <kolmodin> dcoutts: http://darcs.haskell.org/SoC/haddock.ghc/
02:12:03 <lambdabot> Title: Index of /SoC/haddock.ghc
02:12:53 <bringert> ivanm: that paste url was for you
02:13:01 <dcoutts> kolmodin, does it work?
02:13:23 <ivanm> bringert: sorry, didn't realise
02:13:31 <kolmodin> dcoutts: I haven't tried it against HEAD
02:13:32 <ivanm> but its too long for hpaste
02:13:35 <ivanm> I'll try pastebin
02:13:36 <kolmodin> dcoutts: but it should work
02:13:37 <dcoutts> kolmodin, davve sent in these patches for cabal to support it but I've never seen haddock-ghc 'in the wild'
02:14:18 <kolmodin> when did he send you them?
02:14:18 <dcoutts> kolmodin, and quite honestly I don't know why we're making another haddock tool rather than just merging his changes into the main haddock.
02:14:26 <dcoutts> he resent them today
02:14:30 <kolmodin> oh, ok
02:14:41 <kolmodin> naturally we should merge his tool into the main haddock
02:14:51 <kolmodin> but it was easier to develop as a separate branch
02:14:56 <dcoutts> of course
02:15:20 <dcoutts> so I'm not sure we really need separate support
02:15:24 <kolmodin> does his patches treat haddock.ghc as a separate program?
02:15:29 <dcoutts> I think so
02:15:32 <kolmodin> hmm, ok
02:15:40 <dcoutts> yes.
02:15:46 * dcoutts quickly reads patches
02:15:55 <dcoutts> hunk ./Distribution/Setup.hs 92
02:15:55 <dcoutts> +            | HaddockGHCCmd           -- haddock-ghc
02:15:56 <dcoutts> etc
02:16:11 <kolmodin> right.
02:16:26 <dcoutts> of course if he's adding new flags to haddock then we need to support those in Cabal
02:16:37 <ivanm> OK, if anyone was willing to look at my code, its at: http://rafb.net/p/lgI0mu47.html (warning!!! its around 630 lines long!!!)
02:16:39 <lambdabot> Title: Nopaste - Latin Square solver
02:17:25 <kolmodin> he adds new flags to GHC as well, I belive
02:18:28 <jeeves_bond> I'm a Haskell n00b, just learning the language and am wondering what the point (practically) of currying is. Why/when would it be used in a real world application?
02:19:38 <ivanm> In my own (first-time) program, I've used currying to let me do matrix operations on either rows or columns without worrying which, then passing through the row or cols operator to determine that
02:19:57 <nmessenger> ?google the point of pointfree
02:19:59 <lambdabot> http://www.vex.net/~trebla/weblog/pointfree.html
02:19:59 <lambdabot> Title: The Point of Pointfree
02:20:05 <kolmodin> dcoutts: I guess the patches just are preliminary tests, to be fixed once his haddock is merged
02:20:16 <dcoutts> kolmodin, I'm emailing to ask
02:20:56 <kolmodin> dcoutts: he's known as 'waern' in here
02:21:03 <jeeves_bond> Ok, thanks ivanm. It's probably something I won't understand until I get there. :)
02:21:05 <kolmodin> not online currently though
02:21:07 <jeeves_bond> But I see your point
02:21:22 <dcoutts> kolmodin, oh yes, he's davve on email
02:21:33 <kolmodin> still too early, he sent the patches 00.50 :)
02:21:45 <quicksil1er> jeeves_bond: More generally, the ability to partially apply functions and pass them around in the partially applied state
02:21:57 <quicksil1er> jeeves_bond: this is part of the parcel of currying
02:22:05 <quicksil1er> jeeves_bond: consider map (+5) [1,2,3,4,5]
02:22:10 <kolmodin> yep, we from chalmers are good at confusing
02:22:28 <jeeves_bond> quicksil1er: Yes, I could understand that much, but just can't imagine ever using it for anything. :)
02:22:34 <kolmodin> I tricked a friends gf for a year that I was tree different people
02:22:35 <nmessenger> jeeves_bond: all point-free programs should be expressible in pointful terms with lambdas, point-free, however, often seems more higher-level
02:22:37 <jeeves_bond> Ok...
02:23:03 <dcoutts> kolmodin, heh :-)
02:23:10 <kolmodin> by mistake, that is. under the nicknames kolmodin, lenny and lennart
02:23:13 <quicksil1er> jeeves_bond: it enables you to abstract program chunks in a way you couldn't in less expressive languages
02:23:28 <nmessenger> in most cases, \x -> f x = f, so just using 'f' is more direct
02:23:29 <kolmodin> different in RL and IRC, can be quite confusing
02:23:54 <nmessenger> jeeves_bond: did you read the "Point of Point-free" thing?
02:24:00 <jeeves_bond> Yes: but why would I want to do that?
02:24:13 <jeeves_bond> Is nmessenger a bot?
02:24:33 <ivanm> I don't think so....
02:24:40 <nmessenger> uh, I don't *think* I'm a bot.  *checks self*.  Doesn't seem so.
02:24:58 <jeeves_bond> *poke* ooops, flesh and blood. Sorry. :)
02:25:11 <ivanm> for one thing, he seems slightly more intelligent than lambdabot ;)
02:25:25 <nmessenger> but LB is rather useful!
02:25:38 <jeeves_bond> No way: I saw lambdabot google something a minute ago!
02:25:39 <ivanm> I never said it (he? she?) wasn't
02:25:48 <nmessenger> she
02:26:12 <profmakx> when will people learn that lambdabot is a "she"
02:26:27 <nornagon> when they look at her site
02:26:32 <ivanm> when dons produces decent lambdabot docs and puts them on his site?
02:26:34 <nornagon> @where lambdabot
02:26:35 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:26:48 <nmessenger> ^^ with pics :D
02:27:04 <ivanm> OK, there's a pic, whatever ;)
02:27:27 <nmessenger> my name is actually "Nick Messenger" if the "messenger" thing threw you.
02:27:30 <jeeves_bond> Yes, I did read that nmessenger. I didn't realise that it was a form of currying. Heck if it's like my beloved pipes I'm sold!
02:27:30 <ivanm> I normally just look at text, you know, the thing that actually gives you information, which is kind of the point of the net?
02:28:32 <jeeves_bond> nmessenger: yes the 'messenger' bit made me think of that nasty Microsoft thingy
02:28:35 <nmessenger> currying isn't exactly the same as point-free, but they are related.
02:28:54 <jeeves_bond> Oh now you tell me! :D
02:29:08 <kolmodin> dcoutts: I spoke to waern/davve about haddock in oxford. apparently it's not quite finished. doesn't really do what the old haddock did yet
02:29:10 <ivanm> Yeah, that confused me for a bit when you googled that link
02:29:22 <dcoutts> kolmodin, right
02:29:26 <kolmodin> dcoutts: but I guess it could go into haddock HEAD
02:29:33 <dcoutts> indeed
02:29:39 <kolmodin> dcoutts: that would probably get more people involved
02:29:47 <dcoutts> is JaffaCake thinks it's ok
02:29:47 <kolmodin> instead of doing your own thing
02:29:51 <dcoutts> true true
02:29:55 <nmessenger> for instance, 'map' takes several arguments, if I only pass one, I get a new function that can be passed around and easily smashed together with other functions using (.)
02:30:17 <ivanm> Yeah... viva la (.) !!!
02:30:31 <nmessenger> @src (.) -- not very complex, either
02:30:32 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:30:36 <nmessenger> @src (.)
02:30:36 <lambdabot> (.) f g x = f (g x)
02:30:42 <nmessenger> bleh, no comments in @src
02:31:05 <kolmodin> does @src use haskell-srcL
02:31:07 <kolmodin> ?
02:31:17 <kolmodin> @unmtl State Int a -- test
02:31:17 <lambdabot> err: Unterminated end-of-line comment
02:31:22 <kolmodin> @unmtl State Int a
02:31:22 <lambdabot> Int -> (a, Int)
02:31:24 <nornagon> Viva la âŽ„! (Also, unicode.)
02:31:36 <ivanm> In the craft of functional programming, they define an inverse of (.) ... is there one like that defined by default in the libs?
02:32:09 * nmessenger ponders inverse composition
02:32:09 <ivanm> nornagon: what was that character meant to be (I guess xchat doesn't use unicode)?
02:32:11 <kolmodin>  @unmtl should add a nl after the code
02:32:19 <jeeves_bond> Basically all the examples have show things like: (\x y -> x + y) 3 5 then they make some function called plus5... I'd think: that's nice, but why on earth would I need it?!
02:32:20 <kolmodin> I'll fix that some day
02:32:21 <nornagon> ivanm: you probably just don't have the glyph (I don't)
02:32:26 <nornagon> it's the composition symbol
02:32:35 <ivanm> That could be it I suppose...
02:33:08 <jeeves_bond> But your map example makes more sense. :)
02:33:23 <careo> jeeves_bond: consier the contrived case of a database library with a find function you're using in a webapp.
02:33:25 <jeeves_bond> Especially when put in terms of piping. :)
02:33:44 <jeeves_bond> careo: ok... am considering :)
02:34:25 <careo> jeeves_bond: and where some of the arguments to find() include stuff for a where clause, like "user_id". you can use currying to make a function to always find where user_id=1
02:34:40 <quicksil1er> ivanm: you don't mean inverse, do you? you just mean with inputs reversed?
02:34:53 <careo> and create a crude type of view
02:35:18 <ivanm> well, where (f . g) x = f (g x), they have (f >.> g) x = g (f x)
02:35:37 <ivanm> so functions are applied from left to right, rather than right to left
02:35:40 * quicksil1er nods
02:35:48 <quicksil1er> Control.Arrow has that
02:36:01 * ivanm hasn't really touched Monads yet, let alone arrows
02:36:07 <nmessenger> ivanm: isn't (>.>) = flip (.)?
02:36:16 <quicksil1er> yes, it is
02:36:26 <quicksil1er> ivanm: FYI, that's really not an 'inverse' though :)
02:36:30 <jeeves_bond> careo: Hmmm, that would make sense. Especially if you knew that was going to be used often, like the Admin always being user_id=1
02:36:36 <ivanm> Yeah, but using (>.>) is a lot easier to chain them together
02:36:39 <nmessenger> also, for the (->) Arrow, (>>>) is flip (.)
02:36:42 <ivanm> than flip (.) that is
02:37:03 <nmessenger> > (+1) >>> (*3) $ 5
02:37:05 <lambdabot>  18
02:37:38 <jeeves_bond> nmessenger: what the funk was that?!
02:37:47 <nmessenger> add one, then multiply by 3, the number 5
02:37:49 <careo> jeeves_bond: yeah. or you could get your curried fuction elsewhere based on some input. the use the curried function everywhere to force some arguments to be set. saves typing, saves you from having to keep track of it, and adds some amount of security I'd imagine
02:38:13 <nmessenger> > ((+1) >>> (*3)) 5 -- without the weird ($) operator
02:38:25 * ivanm likes currying, as he's a big fan on function passing
02:38:32 <nmessenger> @bot
02:38:37 <jeeves_bond> careo: WOW!
02:38:39 <nmessenger> :(
02:38:42 <careo> jeeves_bond: but really I'm just guessing, as I'm a haskell n00b too :). I *do* use that sort of thing in Ruby a fair bit though.
02:38:54 <nornagon> @botsmack
02:39:00 <ivanm> @botsnack
02:39:08 <ivanm> ?botsnack
02:39:09 <jeeves_bond> Ah, I see. Do Ruby developers Curry often then?
02:39:16 <nmessenger> more commands will just add to LB's queue
02:39:17 <nornagon> jeeves_bond: hahahhahaha
02:39:20 <nornagon> you make funny joke
02:39:24 <lambdabot> :)
02:39:24 <lambdabot> :)
02:39:24 <lambdabot> :)
02:39:24 <lambdabot> :)
02:39:25 <lambdabot>  18
02:39:27 <nornagon> :O
02:39:31 <ivanm> well, you mis-spelled botsnack
02:39:35 <nornagon> @botsmack
02:39:36 <lambdabot> :)
02:39:38 <nornagon> :)
02:39:40 <nmessenger> @botsnake
02:39:41 <lambdabot> :)
02:39:44 <careo> jeeves_bond: hehe. not as such, no. you *can* do it, but it's not as friendly as haskell
02:39:46 <nmessenger> @bostonack
02:39:47 <lambdabot> :)
02:39:51 <nornagon> @botsuck
02:39:52 <lambdabot> :)
02:39:56 <ivanm> OK, lambdabot likes being smacked and having snakes, does she?
02:39:57 <dons> um...
02:40:01 <kfish> eww
02:40:04 <ivanm> thats just disturbing...
02:40:12 * nornagon lols
02:40:28 <ivanm> is there anyway of reducing nmessenger's karma for that?
02:40:32 <ivanm> nmessenger--
02:40:39 <nmessenger> ivanm: yeah, that did it.
02:40:40 <nmessenger> @karma
02:40:41 <lambdabot> You have a karma of 3
02:40:42 <jeeves_bond> lol
02:40:52 <ivanm> goog, I wasn't sure if that would work ;)
02:40:56 <ivanm> *good
02:41:20 * nmessenger accepts his punishment without objections
02:41:26 <ivanm> btw, has anyone had a chance to look at the code I put up on nopaste?
02:41:38 <ivanm> nmessenger++
02:41:46 <ivanm> for accepting it so gracefully ;)
02:41:52 <ivanm> @karma nmessenger
02:41:52 <lambdabot> nmessenger has a karma of 4
02:42:13 <jeeves_bond> Hey, wasn't that a destructive update?!
02:42:20 <jeeves_bond> I thought those weren't allowed?
02:42:36 <nmessenger> jeeves_bond: heh, not simply in function-land, they aren't
02:42:42 * careo waves hands and mentions monads
02:43:04 <jeeves_bond> Hehehe
02:43:06 * ivanm just nods and tries to look intelligent
02:44:01 <careo> I could perhaps speak more intelligently about it, but amazon is taking their sweet little time getting School of Expression to me
02:44:11 <jeeves_bond> Well, I'll stop telling crap jokes and give you chaps some karma for helping me... Let's see if I can get this right...
02:44:19 <jeeves_bond> careo++
02:44:24 <jeeves_bond> @karma careo
02:44:25 <lambdabot> careo has a karma of 1
02:44:29 <careo> (it's either an insanely popular book they can't keep in stock, or so unloved they don't bother keeping it in stock)
02:44:37 <nmessenger> do {x <- newIORef 1; print (readIORef x); modifyIORef x (+1); print (readIORef x)}
02:44:50 <jeeves_bond> nmessenger++
02:44:50 <pejo> Mark P. Jones has some article from a summer school in 95 about monads on his homepage. Well worth a read, imho.
02:44:53 * ivanm likes 2nd hand books: $20 for craft of functional programming instead of $100+ new
02:45:08 <ivanm> pejo: do you know the link?
02:45:15 <careo> ivanm: damn. where at?
02:45:26 <jeeves_bond> I'd like to see that...
02:45:29 <pejo> ivanm, www.cs.pdx.edu/~mpj somewhere, I think.
02:45:42 <beelsebob> Igloo: seems to be something slightly wrong with the buildbot config -- while it DCed at your end it didn't stop building at this end
02:45:49 <beelsebob> I had to manually stop it
02:45:53 <careo> ooh cool, he's a Portlander
02:46:39 <ivanm> careo: I bought it 2nd hand off someone I found from a website... textbookexchange.com.au.... mainly uni textbooks for australian unis
02:46:48 <nmessenger> ivanm, jeeves_bond: 'nick++/nick--' is silent, '@karma+/@karma- nick' shows a message
02:47:08 <ivanm> Ahhh.... that explains it!
02:47:28 <nmessenger> @karma nick
02:47:31 <careo> ivanm: cool
02:47:34 <pejo> (There's a bunch of tutorials around for monads too, others probably have suggestions for which are good/useful/others found useful).
02:47:51 <jeeves_bond> nmessenger: Oh, I see. Well you're up one karma point :)
02:48:00 <jeeves_bond> @karma nmessenger
02:48:17 <syntaxfree> @paste
02:48:18 <ivanm> careo: yeah, especially since there was only about 3 people willing to sell haskell-related books, and he was the only one in the same city (Brisbane) as me
02:48:58 <nmessenger> LB seems laggy today.
02:49:10 <syntaxfree> pejo: apparently monads are four our generation what LSD was to the 60s.
02:49:18 <syntaxfree> s/four/for
02:49:20 <ivanm> syntaxfree: lol!
02:49:20 <careo> weird. alibris lists it at $100 new, bookpool $40
02:49:44 <lambdabot> nick has a karma of 0
02:49:44 <lambdabot> nmessenger has a karma of 5
02:49:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:49:57 <hpaste>  syntaxfree` pasted "why does this simple pattern-matching fail?" at http://hpaste.org/321
02:50:04 <ivanm> careo: its a pretty good book... the only thing I found is that I prefer ghci, and they use hugs. Also, I wish they had more stuff on monads
02:50:15 <Igloo> beelsebob: I'm not sure I follow?
02:50:30 <nmessenger> do {x <- newIORef 1; print =<< readIORef x; modifyIORef x (+1); print =<< readIORef x} -- works this time
02:50:40 <careo> ivanm: how similar are hugs and ghci?
02:50:47 <beelsebob> Igloo: if you look at the log -- you lost contact with the client at 10am
02:51:01 <beelsebob> but the process was still running on my machine at 20 past 4
02:51:09 <beelsebob> when I manually stopped it
02:51:15 <Igloo> beelsebob: I continue to be perplexed by your problem, BTW. x86/HEAD and PPC/6.6 have similar problems, but x86/6.6 works for you and PPC/6.6  works for Thorkill
02:51:17 <beelsebob> (and you see buildbot disconnect)
02:51:33 <Igloo> beelsebob: 10am in which timezone?
02:51:40 <ivanm> careo: the only real differences I've found are that 1) ghci has "it", hugs has "$$" for the last value calculated, 2) I needed ghc anyway and 3) lambdabot works with ghci (GOA), not hugs ;)
02:51:48 <beelsebob> Igloo: it compiled successfully through stage 1 last night
02:51:50 <beelsebob> Igloo: GMT
02:51:56 <nmessenger> syntaxfree: is it possible to reuse names on the lhs like that?
02:52:03 <jeeves_bond> I'm off. Thanks for the help everyone.
02:52:06 <careo> ivanm: heh. cool
02:52:11 <Igloo> beelsebob: Right, that's the x86/6.6 one
02:52:11 <ivanm> syntaxfree: same as nmessenger (he beat me to it!!!)
02:52:13 <syntaxfree> Well, it should.
02:52:21 <beelsebob> yeh
02:52:44 <syntaxfree> if f a a is a valid pattern-match, f (Constructor a) (Constructor a) should too.
02:53:06 <quicksil1er> syntaxfree: f a a is not a valid pattern-match
02:53:06 <ivanm> is it? (shrugs)
02:53:14 <beelsebob> Igloo: if you want to give it a bit more time to build, you could start it at 2:30am (GMT)
02:53:19 <quicksil1er> the best you could hope for would be a pattern-match if Eq (typeOf a)
02:53:41 <nmessenger> syntaxfree: 'f x x = undefined' doesn't compile for me.  Is that a glasgow-ext?
02:53:42 <syntaxfree> bah, they need to fix Haskell ; )
02:53:44 <quicksil1er> but patternmatches are not conditional on the typeclasses of the bindings
02:53:46 <Igloo> beelsebob: Wait, I'm confused. I see a disconnect at about 10 (2), but there hasn't been a 20 past 4 since then?
02:53:48 <quicksil1er> syntaxfree: you can't fix it
02:53:55 <quicksil1er> syntaxfree: not without enforcing all types to be Eq
02:53:57 <beelsebob> Igloo: sorry, 20 past 10
02:54:07 <quicksil1er> syntaxfree: which makes you remove functions from the language :P
02:54:07 <beelsebob> my mind's not working yet today
02:54:07 <syntaxfree> quicksil1er: well, that's true.
02:54:13 <Cale> I think that some versions of Miranda supported nonlinear pattern matches.
02:54:21 <beelsebob> note the log shows it stopped building at 02:02
02:54:26 <ivanm> syntaxfree: sorry, looks like u need to make ur code a bit uglier ;)
02:54:29 <beelsebob> but only d/ced at 02:18
02:54:37 <Cale> (and yes, the types have to have defined equality)
02:54:40 <Igloo> Ah, I see
02:54:53 <beelsebob> between 02:02 and 02:18 it was still running on my machine
02:54:54 <Igloo> Err, wait, no I don't
02:55:02 <beelsebob> no?
02:55:29 <dons> sjanssen: do you want to comment on the unicode bytestring thread on haskell@?
02:55:31 <beelsebob> at 20 past ten (just before I killed it) it was reporting "idle" at the top
02:55:37 <syntaxfree> ivanm: yep. I apparently also need to specify that OrderFacts only apply to Eq types.
02:55:47 <Igloo> The way buildbot works is that it expects the client to run all the time, but when not building it will be idle
02:55:55 <beelsebob> indeed
02:55:58 <beelsebob> it certainly wasn't idle
02:56:05 <beelsebob> it was using 120% CPU
02:56:22 <syntaxfree> I don't like this; the problem description specifically asks for a partial order. Uh, do partial orders satisfy anything like a commutative property?
02:56:42 <ivanm> @google partial order commutative
02:56:44 <lambdabot> http://user.it.uu.se/~victor/Express/99/abstracts.shtml
02:56:45 <lambdabot> Title: EXPRESS'99 Abstracts
02:56:48 <Igloo> Ah, I see
02:57:06 <ivanm> well, that's not very helpful :s
02:57:30 * ivanm should know this, as he's tutored it :s
02:57:33 <quicksil1er> syntaxfree: not sure what would be 'like commutative' about partial orders...
02:57:52 <syntaxfree> I like the type-checking forces me to be somewhat consistent about my algebraic model.
02:57:54 <quicksil1er> a partial order is transitive and reflexive...
02:58:08 <syntaxfree> reflexive meaning a > a?
02:58:11 * quicksil1er nods
02:58:12 <syntaxfree> er, a >= a
02:58:38 <tennin> commutative?
02:58:53 <ivanm> a f b = b f a
02:59:13 <nmessenger> `f` if you want Haskell notation :P
02:59:17 <ivanm> or, in more haskell-like notation: f a b = f b a (I meant f as being the relation)
02:59:25 <quicksil1er> syntaxfree: maybe you're thinking of 'antisymettric'
02:59:29 <nmessenger> heh
02:59:30 <ivanm> probably should have used R, as that's the traditional symbol
02:59:38 <quicksil1er> that's a bit like commutative only not
02:59:49 <syntaxfree> now that I'm thinking of it, since data Ordering = EQ  | LT | GT, doesn't it imply Eq structure already?
02:59:51 <tennin> actually, I think most books define partial orders as necessarily antisymmetric (a > b -> !(b > a))
02:59:57 <tennin> but I've seen a couple that don't
03:00:10 <ivanm> antisymetric: if a 'R' b and b 'R' a then a = b
03:00:10 <nmessenger> ?google haskell 98 prelude
03:00:12 <syntaxfree> antisymmetric, yes.
03:00:13 <lambdabot> http://www.informatik.uni-bremen.de/~cxl/docs/haskell98-report/prelude-index.html
03:00:13 <lambdabot> Title: Haskell 98 Prelude Index
03:00:14 <quicksil1er> I would normally call them 'pre-orders' if they weren't antisymmetric
03:00:16 * nmessenger checks def of Ord
03:00:23 <quicksil1er> or quasiorders
03:00:34 <tennin> the books that don't are older
03:00:43 <syntaxfree> I'm modelling consumer choice theory.
03:00:50 <tennin> so maybe the terminology was standardized at some point
03:00:55 <nmessenger> yep, Eq a => Ord a
03:01:07 <syntaxfree> It basically starts with consumers having an (>=) operation over baskets/bundles of goods.
03:03:45 <syntaxfree> nmessenger: not here. It complains about Eq not being in the context of OrderFact
03:03:59 <syntaxfree>     No instance for (Eq a)
03:03:59 <syntaxfree>       arising from use of `==' at OrderInference.hs:8:48-54
03:04:07 <syntaxfree> I have to use compare a b == EQ, apparently.
03:05:12 <syntaxfree> or instance (Ord b) Eq b, apparently.
03:05:30 <syntaxfree> instance (Ord b) => Eq b
03:05:40 <nmessenger> you can't 'a == b'?  I don't understand how OrderFact can be ordered without an equality test.
03:05:59 <syntaxfree> I can. What I'm saying is that Ord doesn't carry (==)
03:06:49 <syntaxfree> I need something like
03:06:50 <syntaxfree> instance (Ord b) => Eq b where a == b = (compare a b) == EQ
03:06:57 <quicksil1er> syntaxfree: Ord *requires* (==)
03:07:06 <quicksil1er> syntaxfree: class  (Eq a) => Ord a  where
03:07:18 <quicksil1er> you can't define Ord on a type which doesn't have an Eq instance already
03:07:38 <syntaxfree> why do I get that error, then?
03:07:54 <syntaxfree> I specified Ord in the context of the data type definition for OrderFact
03:07:58 <nmessenger> @wiki Class_system_extension_proposal
03:07:59 <lambdabot> http://www.haskell.org/haskellwiki/Class_system_extension_proposal
03:08:01 <nmessenger> ^^ if only
03:08:04 <syntaxfree> data OrderFact a = (Ord a) => OF a a Ordering
03:08:25 <quicksil1er> syntaxfree: paste your current version of your code, then
03:08:37 <syntaxfree> hence, the a's should already have Eq functions!
03:09:34 <nmessenger> then class Ord a would have a == b = case compare a b of {EQ->True;_->False}
03:09:57 <hpaste>  syntaxfree annotated "why does this simple pattern-matching fail?" with "new version, new error" at http://hpaste.org/321#a1
03:11:56 <quicksil1er> syntaxfree: scratch taht Eq instance, you don't need it
03:12:16 <syntaxfree> yes, it seems so. It doesn't work at least.
03:12:17 <quicksil1er> syntaxfree: just add an (Ord a) => constraint to the type signature of antisymmetric
03:12:37 <syntaxfree> but isn't the constraint already at the data type definition?
03:12:48 <ToRA> ord needs it's type to be eq: (Ord defined in prelude as ... class Eq a => Ord a where
03:12:53 <syntaxfree> OrderFacts are defined only for things that are Ordable!
03:13:03 <Bourbaki> moin
03:13:16 <Bourbaki> is there any site where this book is available for free? http://www.amazon.com/Haskell-Road-Logic-Maths-Programming/dp/0954300696
03:13:17 <quicksil1er> syntaxfree: that doesn't make the type signature magically right
03:13:20 <lambdabot> http://tinyurl.com/m2wtq
03:13:24 <nmessenger> you need an instance Eq (OrderFact a), too.  Ord can't provide a (==) with Haskell's class system.
03:13:24 <quicksil1er> syntaxfree: you gave it the wrong type signature, that's all
03:13:37 <quicksil1er> nmessenger: No, he does not
03:13:54 <quicksil1er> nmessenger: I have run his code, and it compiles
03:13:58 <Narrenschiff> Hmmn. I've just installed the binary of the OS X PPC version of ghc.
03:14:05 <quicksil1er> syntaxfree: I don't recommend the use of type signatures during development
03:14:06 <syntaxfree> wait, wait. what use is the class constraint at the type definition then?
03:14:13 <quicksil1er> syntaxfree: all they do is generate error messages
03:14:15 <syntaxfree> Narrenschiff: congratulations! welcome to the club.
03:14:22 <Narrenschiff> it seems to have set everything up with permissions that could best be described as "hatstand"
03:14:33 <quicksil1er> syntaxfree: let the compiler/interpreter do the type inference
03:14:35 <Narrenschiff> or possibly "completely not working"
03:14:41 <syntaxfree> quicksil1er: well, I'd like to understand *why* this is a probelamtic signature.
03:14:52 <Narrenschiff> I was just wondering if this was a known issue?
03:14:56 <syntaxfree> s/probelamtic/problematic.
03:15:00 <nmessenger> nvm then.  I only half-understand this stuff.
03:15:14 <quicksil1er> syntaxfree: because, it was wrong
03:15:23 <quicksil1er> syntaxfree: the signature you had implied that function was defined for all a
03:15:30 <quicksil1er> syntaxfree: in fact, that function is only defined for Ord a
03:15:40 <rahikkala> Is there a good name in English for (any . (not .))? I'm calling (all . (not .)) "none" and am into comprehensiveness :)
03:15:41 <syntaxfree> the function is defined for all OrderFact a
03:15:49 <syntaxfree> data OrderFact a = (Ord a) => OF a a Ordering
03:15:53 <AStorm> ?src any
03:15:54 <lambdabot> any p =  or . map p
03:16:09 <AStorm> or . not . map p? :>
03:16:24 <syntaxfree> The real question here is, what use are class constraints in data type definitions if they're not carried over in type signatures?
03:16:28 <quicksil1er> syntaxfree: that's not really how the type system works
03:16:30 <nmessenger> or . map (not . p)?
03:16:34 <AStorm> Or maybe not . $ or . map p
03:16:35 <quicksil1er> syntaxfree: 'OrderFact' is not a type constraint
03:16:37 <dcoutts_> syntaxfree, almost none.
03:16:38 <quicksil1er> syntaxfree: it's a type name
03:16:53 <AStorm> (whoops, one dot too many)
03:16:58 <dcoutts_> syntaxfree, there is a plan to 'fix' that for Haskell'
03:17:06 <syntaxfree> dcoutts_: that's a serious wart.
03:17:10 <AStorm> rahikkala, the first one is: does not exist
03:17:12 <Bourbaki> is that book any good has anyone read it?
03:17:14 <quicksil1er> antisymmetric :: OrderFact a -> OrderFact a -> Consistency
03:17:18 <AStorm> the second is: none
03:17:19 <quicksil1er> ^^^ this signature means 'forall a'
03:17:36 <syntaxfree> it should mean forall a that satisfied OrderFact.
03:17:41 <Bourbaki>  interesting enough the 5th book is available for free on the authors site
03:17:42 <syntaxfree> I mean, I understand what you're saying here.
03:17:43 <dcoutts_> syntaxfree, when Haskell98 was made there was no notion of putting class dictionaries in data constructors.
03:17:47 <quicksil1er> OrderFact is not a constraint!
03:17:56 <AStorm> rahikkala, I'd call the first one nonexistent
03:17:56 <quicksil1er> 'satsifying OrderFact' doesn't mean anything
03:17:58 <AStorm> :>
03:18:01 <quicksil1er> OrderFact is a type construct
03:18:04 <quicksil1er> or
03:18:13 <syntaxfree> the definition of OrderFact contains a constraint.
03:18:31 <dcoutts_> syntaxfree, but we now have that with existential data type constructors anyway and SPJ has now made it work 'right' for GATD's and suggested we fix it for normal ones for Haskell'
03:18:32 <syntaxfree> If constraints are to be syntactically allowed at all in data type definitions, they should be carried over.
03:18:55 <syntaxfree> dcoutts_: Oh. One more reason to wish I understood existential types.
03:18:57 <quicksil1er> syntaxfree: even if they were 'carried over' that still wouldn't allow you to write an INCORRECT type signature and expect it to work
03:19:10 <quicksil1er> the signature you gave simply does not mean what you want it to mean
03:19:21 <quicksil1er> (you might expect a better error message, I agree)
03:19:28 <quicksil1er> (but that's true of a lot of things)
03:19:48 <syntaxfree> quicksil1er: uh, what is *wrong* with you? Cut the arrogance, it's not helpful *or* intimidating.
03:19:56 <syntaxfree> I know intimidation is fun when you wake up on the wrong foot, but.
03:20:01 <quicksil1er> it's not arrogance, and I apologise if it's unhelpful
03:20:08 <quicksil1er> it certainly isn't intended to be intimidating
03:20:13 <quicksil1er> it was just emphasis
03:20:31 * Narrenschiff fixes permissions (kind of) and finds readline has gone walkies. "Sod this for a game of soldiers!"
03:20:38 <syntaxfree> I don't expect anyone to be "helpful". You just got exaperated, it looked like the Monty Python Parrot sketch.
03:20:42 <syntaxfree> @spell exasperation
03:20:45 <lambdabot> exasperation
03:20:58 <quicksil1er> :)
03:21:08 <quicksil1er> I was trying to emphasise something which I believed you had misunderstood
03:21:12 <quicksil1er> this was intended to be helpful
03:21:41 * nmessenger didn't sense exasperation, though tone is notoriously difficult to encode in text
03:22:09 <quicksil1er> it's a valuable thing to understand that unqualified type variables in signatures are understood as 'forall's
03:23:28 <matt__r> chaps, I have a blindspot for version control
03:23:37 <matt__r> I know I need it, but it always seems too complicated
03:23:45 <matt__r> at the moment I use darcs init
03:23:49 <matt__r> darcs add
03:23:51 <matt__r> darcs record
03:23:53 <nmessenger> I think the intended definition of OrderFact *is* existential, but I don't really understand it, so I cannot assert ofr sure
03:23:57 <matt__r> and that is it
03:24:00 <matt__r> ....
03:24:20 <matt__r> I guess I want to know, am i missing anything important?
03:24:22 <Saizan> so, data Foo a = (Class a) => Foo a  only restricts you to use Foo only on instances of Class?
03:24:27 <nmessenger> s/it/existential types/
03:24:35 <AStorm> matt__r, yes, proper commit messages? :P
03:24:41 <careo> heh
03:24:52 <matt__r> ahh - I do put some in, but I don't know the protocol
03:24:59 <earthy> matt__r: darcs whatsnew ?
03:25:04 <quicksil1er> I believe that the constraint is effectively just a constraint on the 'constructor function'
03:25:08 <matt__r> ohh - and I use the test on commit thingy
03:25:13 <AStorm> That's nice too, but not for own repo.
03:25:14 <quicksil1er> so you're contraining 'Foo' as a function
03:25:17 <AStorm> Ah, testing :D
03:25:17 <earthy> there isn't a protocol for commit messages per se
03:25:26 <AStorm> Good if you forget to do your own.
03:25:33 <earthy> you just need to make the commit messages descriptive of what you're committing
03:25:43 <matt__r> earthy: i guess not, but I bet if i saw other people in action, I would pick up lots
03:25:47 <AStorm> Yes. And the first line should look like a title.
03:25:49 <earthy> furthermore, if you use a tracking system, references to the tracker tickets do help
03:25:56 <matt__r> I have been mulling over an idea...
03:26:12 <earthy> well, some of my commit messages:
03:26:21 <matt__r> do you think you could use darcs to make a poor-mans wiki?
03:26:26 <earthy> - Cabalized the code, builds beautifully now
03:26:30 <careo> matt_r: I'd check out a couple of Trac sites for various open source projects, get a feel for what their commit messages are like
03:26:31 <earthy> - Ported to GHC 6.6.
03:26:39 <matt__r> people push patches instead of edit pages
03:26:49 <matt__r> careo: good idea
03:27:04 <AStorm> matt__r, well, I did that once :>
03:27:09 <careo> matt_r: yeah. I've actually been thinking of something like that
03:27:10 <matt__r> earthy: I think i need to get cabalized
03:27:15 <AStorm> Worked nice (though not with darcs, but with git)
03:27:20 <dons> matt__r: there's a couple of wikis around with darcs backends
03:27:25 <dons> ikiwiki for one, there's another one as well
03:27:32 <matt__r> dons: does that mean you can edit offline
03:27:35 <dons> you commit, the commit hook regenerattes the page
03:27:45 <matt__r> there is nothing I hate more than online editing
03:27:48 <dons> matt__r: yeah, though not sure how page generation works offline.
03:27:59 <dons> i just download haskell.org pages into my own repo and edit offline
03:28:04 <dons> then when i'm done, upload
03:28:05 <careo> is there a markdown library for haskell?
03:28:09 <matt__r> I am also toying with putting some time into an lhs publishing script
03:28:14 <earthy> careo: write your own, it isn't hard
03:28:15 <dons> careo: yeah, check haskell.org's  libraries page
03:28:19 <dcoutts_> dons, they should be backed by a darcs repo
03:28:23 <dons> right
03:28:25 <dcoutts_> so we can pull & push
03:28:26 <earthy> there is alreadY!? damn. ;)
03:28:33 <matt__r> careo: there is, but it is complicated
03:28:41 <Igloo> matt__r: http://matrix.chaos.earth.li/~ian/diki/Index
03:28:44 <lambdabot> Title: Diki
03:28:49 <matt__r> careo: I had better luck with markdown.pl
03:28:53 <dcoutts_> dons, I'll start by making the cabal webpages a darcs repo :-)
03:29:03 <matt__r> I have used latex lhs before and it is horrible
03:29:13 <matt__r> I have recently become hooked on markdown
03:29:15 <dons> careo: http://sophos.berkeley.edu/macfarlane/pandoc/
03:29:17 <lambdabot> Title: Pandoc
03:29:23 <matt__r> and now I want to join the two
03:29:34 <careo> dons: cool, thanks
03:30:10 <earthy> ah, Pnadoc.
03:30:12 <matt__r> something simple to allow people to pop lhs on the web and have them browsable in a sensible format
03:30:17 <earthy> schweetlooking, that.
03:30:24 <matt__r> pandoc is amazing
03:30:30 <dcoutts_> dons, hmm interesting. I'd need txt2tags input format too :-)
03:30:42 <matt__r> but I wanted to modify it and I just could not get my head around it.
03:31:09 <AStorm> matt__r, like a coloring and hyperlinking engine? :P
03:31:13 <matt__r> instead i modified markdown.pl, which is really easy
03:31:22 <dons> why's it hard?
03:31:33 <dons> is it very general?
03:31:53 <earthy> yup
03:31:53 <matt__r> dons: ery general
03:32:00 <matt__r> it does everything properly
03:32:09 <dons> good
03:32:11 <dons> :)
03:32:15 <matt__r> whereas markdown.pl just regex matches and transforms
03:32:22 <matt__r> its seems more fragile
03:32:23 <dons> that's the perl way
03:32:31 <matt__r> dons: indeed
03:32:47 * dons `ap` sleep
03:32:50 <matt__r> AStorm: more like just mark it up and perhaps colourise the code
03:32:51 <careo> and it's three lines, right? ;)
03:33:31 <nmessenger> dons, what type are you? Yesterday you did /me `put` sleep.
03:33:34 <earthy> From LaTeX to markdown... yowza
03:33:50 <matt__r> AStorm: I find it impossible to comment my code without maths though, so I need to incorporate latex somehow
03:33:58 <matt__r> but publishing to pdf is no good
03:34:00 <matt__r> I need html
03:34:11 <matt__r> I just discovered jsmath, which is great
03:34:31 <AStorm> matt__r, mathml?
03:34:46 <AStorm> Latex is ok too, IMO
03:34:57 <earthy> especially with tth
03:35:21 <AStorm> Who needs tth, when you can render (almost) directly to gifs?
03:35:21 <matt__r> AStorm: mathml is not human writable, you need an editor, jsmath allows you to write tex and it gets typeset by the browser after the page is loaded
03:35:22 <earthy> which will give you png's to inline
03:35:37 <earthy> astorm: 'almost'. ;) tth takes the gruntwork out of it ;)
03:35:44 <matt__r> yuck - that all sounds horrible
03:35:56 <AStorm> earthy, when you're writing the framework, you already do the gruntwork :P
03:36:08 <earthy> :)
03:36:50 <earthy> http://www1.chapman.edu/~jipsen/mathml/asciimath.html
03:36:51 <lambdabot> Title: ASCIIMathML: Math on the web for everyone
03:36:58 <matt__r> I want to be able to put tex (or something) in my lhs and have it render properly in the browser when someone finds it on the web
03:37:23 <careo> whoa. jsmath is crazy
03:37:28 <matt__r> earthy: with jsmath, i didn't need to learn a new syntax
03:37:31 <matt__r> everyone know latex
03:37:33 <careo> inspired, but crazy
03:37:51 <matt__r> careo: I have no idea how they did it, and it works really well in practice too
03:38:48 <earthy> whoa. cool.
03:39:05 <earthy> matt__r: basically, it's a TeX-like typesetter in javascript
03:39:16 <matt__r> I wish I could show you the source I have been writing with latex in the comments being rendered so wonderfully, but I don't have it set up on a public server yet
03:39:16 <earthy> and it works with safari, which asciimath doesn't
03:39:19 <matt__r> earthy: yep
03:39:33 <careo> yeah. looks good in konqueror
03:40:17 <matt__r> it is one of those gems of open source
03:40:23 <matt__r> really makes your life easier
03:40:36 * ivanm wants to know if anyone has had a chance to look over his code, as he needs it to be as fast as possible
03:40:55 <earthy> me like
03:42:10 <matt__r> i always thought javascript had the chance to improve my life (beyond onmouseover effects of course), but I think this is the first time I have been really impressed by something other than google maps
03:44:30 <careo> javascript's a pretty awesome language.
03:44:48 <AStorm> As in "aweful"?
03:44:55 <AStorm> :P
03:45:06 <matt__r> careo: I had cause to take a good look at for the first time this year and was pleasantly surprised
03:45:20 <matt__r> not tempted to use it of course......
03:45:24 <careo> AStorm: well, it has some flaws, but I have to like it's prototype-ness
03:51:42 <ivanm> Please... can someone look at the code I put up on nopaste and see if there's anything I can do to speed it up?
03:51:56 <ivanm> I stupidly chose a super-exponential growth problem as my first go at using Haskell :s
03:53:28 <AStorm> ivanm, link?
03:54:07 <ivanm> http://rafb.net/p/lgI0mu47.html
03:54:08 <lambdabot> Title: Nopaste - Latin Square solver
03:54:31 <ivanm> I put it up a few hours ago.... no-one seemed to have read it then :(
03:55:09 <dcoutts_> ivanm, we all use hpaste.org ;-)
03:55:11 <dcoutts_> @psate
03:55:11 <lambdabot> Maybe you meant: gsite paste
03:55:15 <dcoutts_> @paste
03:55:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:55:20 <dcoutts_> (doh!)
03:55:31 <ivanm> dcoutts: my codes too big :s
03:55:35 <ivanm> 600+ lines
03:55:38 <dcoutts_> oh, heh
03:55:48 <ivanm> its my full program.... in literate form to help explain it
03:56:18 <matthew_-> right, is there an off the shelf haskell parser (i.e. a haskell program that parses haskell)?
03:56:27 <dcoutts_> matthew-_, yep
03:56:31 <dcoutts_> Language.Haskell.*
03:56:37 <quicksil1er> see also hsplugins
03:56:55 <quicksil1er> erm, what was it called?
03:57:02 <matthew_-> tnx
03:57:28 <quicksil1er> http://www.cse.unsw.edu.au/~dons/hs-plugins/
03:57:29 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
03:57:43 <mwc> So, somebody told me that January would see the GHC native code generator project get into high gear
03:57:46 <mwc> what's the good news?
03:59:10 <dcoutts_> mwc, I was at GHC HQ the other day and there wasn't a great deal of talk about that
03:59:17 * mwc weeps
03:59:29 <dcoutts_> we did look at some low level loop stuff
03:59:40 <dcoutts_> and discovered that it's better than we had thought
04:00:23 <dcoutts_> mwc, of course if you have some time to look at code gen issues it could be made better quicker :-)
04:00:31 <dcoutts_> it's mostly a man power thing
04:00:38 <dcoutts_> or the lack thereof
04:01:08 <mwc> I'm not really competent to hack on ghc, but maybe I'll take a look at the gtk2hs bugs... is the bugtracker fixed?
04:01:37 <dcoutts_> mwc, we need to bug SyntaxNinja and co to upgrade Tack on hackage.haskell.org
04:01:49 <dcoutts_> so, no the bug tracker isn't fixed yet, sigh
04:02:01 <dcoutts_> mwc, but there are a few bugs reported on the mailing list recently
04:02:08 <dcoutts_> eg the newListStore []
04:02:18 <dcoutts_> I've identified but not fixed that one
04:02:32 <mwc> Maybe I'll have a look this afternoon
04:02:45 <mwc> did you post your observation?
04:02:48 <dcoutts_> not yet
04:03:00 <dcoutts_> mwc, let me pin point it for you...
04:03:28 <mwc> could always just check tags for newListStore :P
04:03:31 <dcoutts_> ./gtk/Graphics/UI/Gtk/ModelView/ListStore.hs.pp :
04:03:32 <dcoutts_> if n >= fromIntegral (Seq.length rows) - 1
04:03:45 <dcoutts_> the problem is that if Seq.length rows == 0
04:03:55 <dcoutts_> note that n :: Word
04:04:10 <dcoutts_> aaarg! unsianged integer underflow
04:04:40 <dcoutts_> so we're doing 0 - 1 and converting to Word :-)
04:05:32 <mwc> Heh, well, I'll see what I can do
04:05:52 * mwc checks the local windchill
04:06:13 <Bacta> I'm gonna have to learn Haskell this year :((
04:06:29 <dcoutts_> Bacta, no no, that's a good thing :-) cheer up!
04:06:40 <Bacta> never touched functional languages before
04:06:43 <mwc> -31 Centigrade. Perfect
04:06:48 <dcoutts_> mwc, wow
04:07:01 <mwc> Pah, this is wimp weather, I grew up in far worse
04:07:04 <Bacta> Finland?
04:07:06 <mwc> -46 in still air.
04:07:11 <dcoutts_> Bacta, in that case, welcome to the light side :-)
04:07:15 <mwc> Bacta: southern Canada ;P
04:07:30 <Bacta> dcoutts_: I'm not a mathematician
04:07:36 <mwc> I grew up in central canada, much further north
04:07:46 <dcoutts_> Bacta, doesn't matter
04:08:01 <mwc> Bacta: neither, I suspect, is Paul Graham. And he's ALMOST a competent FP guy
04:08:03 <amiddelk> dcoutts: I guess Haskell should be the dark side... since it's seductive and offers the easy way out :P
04:08:10 <dcoutts_> hah hah
04:08:54 <pejo> dcoutts_, is the ncg supposed to stay, and no switch to C--?
04:09:16 <dcoutts_> pejo, it uses C-- internally, ghc is a c-- compiler.
04:09:21 <Bacta> so it's B++ :P
04:09:25 <mwc> "unsafe is a gateway to abilities some find to be... unnatural."
04:09:56 <mwc> Yeah, what's the deal there... GHC has its own C-- compiler? I thought the C-- website was distributing an Ocaml based compiler
04:10:11 <Bacta> the way I see languages like this is they are experimental toys
04:10:11 <AStorm> Bacta, no
04:10:12 <dcoutts_> mwc, ghc only compiles a subset of C--
04:10:12 <Bacta> am i right?
04:10:31 <AStorm> No, once again.
04:10:45 <Bacta> but you wouldn't seriously develop a game in it
04:10:51 <dcoutts_> Bacta, I write all my serious programs in Haskell, I wouldn't trust myself to do it in a more lax language, I'd have no hope of getting them right.
04:10:55 <mwc> In other news, I have the contacts to get a copy of GHC 6.6 installed on an 128-way IA-64 SMP system
04:10:58 <AStorm> You do if you write in Haskell :>
04:11:07 <dcoutts_> mwc, woo!
04:11:48 <dcoutts_> mwc, talk to dons and rl. They do parallel array programming on massive SMP systems, I'm sure they'd love to supply you with some programs to run on that box.
04:11:53 <Bacta> so Haskell in essence computes based on what it is you want to compute rather than HOW to compute it?
04:12:00 <dcoutts_> mwc, in Haskell of course.
04:12:02 <mwc> I have no idea if it would work, but there's a guy who who's hugely interested in threading stuff, he fine tunes MPI and OpenMP for the cluster. If I mention it's some threading-like thing, he'd probably jump on it
04:12:30 <mwc> or so says a prof who works with him
04:13:13 <AStorm> Bacta, all functional programming is more or less like this
04:13:32 <dcoutts_> mwc, dons and rl just acquired this 16way x86 system to test the scalability of their Haskell parallel array stuff. A run or two on a 128-way would be very much appreciated I'm sure.
04:13:34 <AStorm> You describe a result of a function, not steps to achieve it.
04:14:03 <mwc> dcoutts_: It's IA-64, so I have no idea if it would even work
04:14:15 <dcoutts_> mwc, I had ghc-6.4.1 build on ia64.
04:14:25 <dcoutts_> mwc, registerised too I think.#
04:14:40 <dcoutts_> mwc, it runs linux right?
04:15:08 <Bacta> ok :)
04:15:11 <mwc> to be honest, not sure. SGI, so I assume Linux and not IRIX
04:15:42 <dcoutts_> Bacta, right, that's how one starts out. It is possible to tune a functional program by giving hints on evaluation order. So often one can quickly write a prototype and then refine it into an efficient implementation if necessary.
04:15:54 <AStorm> He went away :>
04:15:58 <dcoutts_> oh :-(
04:16:00 <dcoutts_> nm
04:16:28 <AStorm> I still have to force myself to write something serious in Haskell.
04:16:40 <matthew_-> yeah, SGI have been putting linux on their high end kit for some time now
04:16:58 <ivanm> AStorm: so what do you use when you want to write something serious then?
04:17:58 <AStorm> I used Python or C++. Now I have nothing serious on mind.
04:19:33 <AStorm> Slowly writing an SMTP server using Parsec. Very slowly (RL caught up :P )
04:20:00 <quicksil1er> I still find parsec syntax clunky
04:20:06 <quicksil1er> maybe my mind isn't looking at it right
04:20:08 <ivanm> ?google parsec
04:20:11 <lambdabot> http://en.wikipedia.org/wiki/Parsec
04:20:22 <Cale> Clunky compared to what? BNF?
04:20:26 <AStorm> quicksil1er, it's really nice and tidy.
04:20:40 <dcoutts_> @where parsec
04:20:41 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
04:20:45 <dcoutts_> ivanm, ^^
04:20:54 <yaarg> does hs-plugins work with 6.6 yet?
04:21:07 <dcoutts_> yaarg, yep
04:21:16 <yaarg> woo, great
04:21:22 * yaarg gets
04:21:23 <yaarg> thanks
04:21:35 <quicksil1er> Cale: compared to writing my own combinator parser by hand
04:21:39 <ivanm> dcoutts_: yeah, going to the disambiguation page on wikipedia led me to it... from the way AStorm was talking, I thought it was another language :s
04:21:40 <dcoutts_> though we're still waiting for dons to do a 1.0 release tarball, hint hint :-)
04:21:45 <quicksil1er> AStorm: well clearly that's a matter of opinion :)
04:22:00 <dcoutts_> ivanm, well it sort of is a sub-language
04:22:00 <Cale> quicksil1er: which combinators would you write?
04:22:19 <dcoutts_> ivanm, a DSEL "Domain Specific Embedded Language"
04:22:25 <yaarg> AStorm: have you seen postmaster?
04:22:32 <AStorm> ?
04:22:32 <ivanm> OK, thanks dcoutts_!
04:22:48 <yaarg> AStorm: http://postmaster.cryp.to/
04:22:51 <lambdabot> Title: Postmaster ESMTP Server
04:23:16 <quicksil1er> Cale: I don't like the noise introduced by 'try', for starters
04:23:34 <AStorm> yaarg, thanks, I'll borrow some ideas.
04:23:36 <Cale> ah, yeah. You might like ReadP or Parsek then.
04:24:11 <quicksil1er> and smoe of the recommendations in the docs scare me :
04:24:25 <quicksil1er> or an even better version: do{ try (string "(a"); char ')'; return "(a)" }
04:24:33 <quicksil1er> (how is that 'better'? It's fugly!)
04:24:38 <quicksil1er> :)
04:24:57 <quicksil1er> it is all subjective, but for me the point is to keep the program looking as much like the grammar as possible
04:25:15 <AStorm> quicksil1er, you don't need try most of the time
04:25:32 <Cale> It's better because a smaller parser is inside the try.
04:25:43 <quicksil1er> Cale: I understand in what sense it's better
04:25:50 <Cale> The left-factored parser is of course the right idea.
04:25:57 <quicksil1er> Cale: but it smells a bit like premature optimization, and it's ugly
04:26:13 <quicksil1er> of course, I don't have a wonderful beautiful solution to left-recursion either
04:26:37 <AStorm> quicksil1er, write your own then and stop crying :>
04:26:46 <quicksil1er> AStorm: I have written many of my own
04:26:57 <quicksil1er> AStorm: I just thought it was an interesting thing to talk about
04:27:00 <AStorm> I reckon you'll be able to write a parser for SMTP commands by hand :P
04:27:00 <Cale> I'd just use ReadP.
04:27:09 <quicksil1er> AStorm: someone might have insight deeper than I had
04:27:15 <AStorm> Kudos on that.
04:27:16 <Cale> Though I've also written my own parser combinators.
04:27:19 <ivanm> AStorm: did you end up having a look at my program?
04:27:23 <quicksil1er> (or advice, like looking at ReadP which I hadn't heard of)
04:27:30 <AStorm> ivanm, yes. No idea.
04:27:44 <Cale> ReadP is nice in that it has commutative choice.
04:27:44 <ivanm> OK, thanks for at least having a look!
04:28:05 <Cale> and it doesn't hold on to the beginning of the input string any longer than it has to.
04:28:18 <quicksil1er> Cale: *nod* it looks a little more like the ones I tend to write.
04:29:08 <AStorm> ivanm, replace dropUntil by partition maybe?
04:29:22 <ivanm> :hoogle partition
04:29:30 <ivanm> @hoogle partition
04:29:31 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
04:29:31 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
04:29:31 <lambdabot> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
04:29:51 <ivanm> OK, I'll have a look at that. Thanks AStorm!
04:29:58 <ivanm> @where partition
04:29:59 <lambdabot> I know nothing about partition.
04:30:07 <ivanm> @where List.partition
04:30:07 <lambdabot> I know nothing about list.partition.
04:30:14 <ivanm> @src partition
04:30:15 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
04:30:15 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
04:30:15 <lambdabot>                               | otherwise = (ts, x:fs)
04:31:09 <Cale> hmm
04:33:24 <ivanm> The only thing about partition, is that I need it to return the last value in the list if none of them fulfill the predicate....
04:33:42 <ivanm> Or, I suppose I could get it to return a Nothing and make the return type a Maybe
04:33:49 <AStorm> tail $ snd $ partition blahp thelist
04:34:03 <AStorm> Ah, none of them.
04:34:29 <ivanm> It needs to be 1. the first item to satisfy the predicate or 2. if none satisfy, the last one
04:34:52 <AStorm> Use a pattern match on ([],_)
04:34:56 <ivanm> but I test the value returned with the predicate again anyway, IIRC, so it mightn't matter
04:35:14 <AStorm> Or maybe on (_,[]), dunno. Depends on how you write the predicate.
04:35:19 <ivanm> and if the pattern fails return the last element?
04:35:48 <AStorm> No. If it succeeds.
04:35:49 <ivanm> will that cause it to go through the whole list again, or will it know which is th elast due to its laziness?
04:36:08 <AStorm> Ugh, the [] is a singleton anyway :>
04:36:20 <ivanm> btw: does Haskell do memoization?
04:36:49 <AStorm> Not by default.
04:37:31 <AStorm> But if you write the algorithm correctly, you'll get it by laziness :-)
04:38:26 <matt__r> done
04:38:50 <ivanm> Well, the only thing is, I've got a function (not posted with the rest of my code), where I go through all my values in the matrix and create a list of matrices in which one of the previous values has been unset
04:38:58 * matt__r has modified markdown to process literate haskell (birdtracks) and incorporate hscolor and jsmath
04:39:06 <ivanm> I then map a function over that list, and as part of it they all get unset again
04:39:25 <ivanm> so a second function is then repeated twice over each type of input
04:39:28 <AStorm> Throw them away earlier, as in - don't add to the list?
04:39:42 <ivanm> I'm not expressing myself clearly...
04:39:45 <matt__r> perl hacking is horrible
04:39:57 <ivanm> I have a list [1,2,3,4,5]
04:40:19 <ivanm> I then go and generate a list of lists, each of which is missing one of the previous elements
04:40:41 <ivanm> restarting: original list is [1,2,3], new list is [[1,2],[1,3],[2,3]]
04:40:43 <matthew_-> matt__r: markdown as in the daringfireball markup language?
04:40:48 <matt__r> yup
04:41:03 <matthew_-> matt__r: I have a javascript implementation of markdown
04:41:22 <matt__r> cool - you mean it runs on the browser client?
04:41:42 <quicksil1er> ivanm: yes, following so far
04:41:45 <ivanm> I map a function over them all, and as part of that function I repeat the same procedure, so I have [[[1],[2]],[[1],[3]],[[2],[3]]] and do another function each sublist in that
04:41:57 <matthew_-> matt__r: yep: http://hikij.wellquite.org/
04:41:59 <lambdabot> Title: Hikij
04:42:11 <ivanm> so f [1,2,3] = [[1,2],[1,3],[2,3]]
04:42:13 <matthew_-> matt__r: firefox only though I'm afraid
04:42:22 <un-brice> hello world !
04:42:36 <matt__r> matthew_-: damn, that's a really nice idea though
04:42:57 <ivanm> I then map g over [[1,2],[1,3],[2,3]], and as part of it it basically produces [[[1],[2]],[[1],[3]],[[2],[3]]]
04:42:57 <araujo> morning
04:43:20 <ivanm> part of g is "map h", so I thus have h of each input calculated twice
04:43:30 <matthew_-> yeah, I just use too much stuff that's only in the recent versions of javascript. which means firefox only until redmond gets serious about writing a browser
04:43:39 <ivanm> the actual code is slightly more complicated (I only unsplit if a predicate is fulfilled)
04:43:40 <matt__r> matthew_-: I am impressed
04:44:05 <matt__r> matthew_-: is the markdown stored on the server and just served up with the javascript to the client
04:44:08 <matthew_-> matt__r: tnx. It took some doing, let me tell you! The haskell backend was a piece of cake in comparison
04:44:16 <matthew_-> yes, that's right
04:45:03 <matt__r> matthew_-: probably exactly the right way to do it. we use wikis all over the joint here, I think I might check it out
04:45:08 <quicksil1er> ivanm: and what's your question?
04:45:39 <ivanm> well, I wanted to know if haskell had memoization so that I didn't have to re-do all those calculations twice
04:45:45 <matthew_-> matt__r: cool. There is at least one bug that I know of with the markdown processing which I know how to fix - I'm just too lazy to do it. Prod me if you want.
04:46:00 <quicksil1er> ivanm: no, it doesn't :)
04:46:01 <ivanm> Since I couldn't work out any way to not repeat them without losing generality and changing the meaning of some of the functions
04:46:02 <matt__r> matthew_-will  do
04:46:12 <quicksil1er> ivanm: it's not really what 'haskell has'
04:46:19 <quicksil1er> ivanm: it's what the compilers do
04:46:31 <quicksil1er> ivanm: but ghc doesn't optimise such except for very simple cases
04:46:32 <ivanm> quicksilver: yeah, AStart said... I just thought I read somwhere that it did
04:46:56 <quicksil1er> it's an extremely hard thing to optimise, I believe
04:46:59 <ivanm> Oh well, what can't be helped can't be helped
04:47:07 <quicksil1er> since you can't jsut keep loads of stuff 'lying around in case it's used again'
04:47:17 <ivanm> yeah, that's what I was thinking
04:47:22 <quicksil1er> and you can't tell in advance what parameters functions will be called with
04:47:37 <ivanm> I don't know why I thought haskell had memoization... I just thought it did as part of its laziness...
04:47:56 <quicksil1er> it will share thunks
04:48:00 <quicksil1er> but that isn't the same thing :)
04:48:00 <AStorm> Not really, though you can "abuse" laziness to do memoisation easily.
04:48:11 <ivanm> AStorm: how?
04:48:38 <AStorm> Create a lazy buffered list-alike structure
04:48:50 <pejo> ivanm, Simon and Simon has pondered the question - Cale gave me a reference the other week. http://www.haskell.org/~simonmar/papers/weak.pdf
04:48:51 <ivanm> example please?
04:48:55 <AStorm> (a certain Monad springs to mind)
04:49:03 <pejo> ?where memoization
04:49:03 <lambdabot> I know nothing about memoization.
04:49:18 <ivanm> yeah, that might help if I knew how to use Monads... they're still confusing me
04:49:18 <pejo> @where+ memoization http://www.haskell.org/~simonmar/papers/weak.pdf
04:49:19 <lambdabot> Done.
04:49:37 <Cale> Using the stuff in that paper is the hardcore way to memoize though. You can usually get the effect you want through sharing.
04:49:45 <ivanm> I ended up just starting to code without them instead finishing off the monad parts of the tutorials
04:50:13 <SamB> ivanm: not a bad way to start out
04:50:17 <pejo> True, Cale is hardcore. :-)
04:50:29 <Cale> Simply define a datastructure which will hold the results of your recursive function, and have that function refer back to the structure for its calls.
04:50:38 <mauke> yay, recursive arrays
04:50:47 <Cale> Exactly.
04:51:32 <ivanm> the function isn't recursive: its just that function f uses function g, then maps function h over the results, and h uses function g again then uses function i over the results
04:52:04 <ivanm> but as part of what applying function g twice does, function i does each set of calculations twice (assuming some predicates are fulfilled)
04:53:56 <ivanm> then, because I'm using function f as a filter predicate, the possibility is that the inputs into function i will actually be used even more times
04:54:31 <Saizan> f = map (i.g) . g?
04:54:55 * AStorm wants H' really bad!
04:55:43 <ivanm> Saizan: its not quite that siimple, unfortunately...
04:56:00 <SamB> AStorm: hmm, for a second there I thought you were looking for japanese porn...
04:56:11 <AStorm> SamB, :P
04:56:16 <AStorm> H' == Haskell Prime
04:56:25 <SamB> yes I figured it out
04:56:33 <ivanm> if you look at my code at http://rafb.net/p/lgI0mu47.html, and in particular the criticalSet function, that's the function g
04:56:34 <lambdabot> Title: Nopaste - Latin Square solver
04:57:21 <ivanm> function f is similar, but it uses a different predicate initially (which I have been told I can't reveal/tell people about, as what I'm looking for is the intellectual property of someone else, or something like that)
04:58:47 <Saizan> O_o
04:59:34 <Saizan> mmh do you use a "divide et impera" approach?
04:59:53 <SamB> what? you don't have a way of testing for someone's IP without including it in the predicate?
04:59:54 <ivanm> ?google divide et impera
04:59:56 <lambdabot> http://en.wikipedia.org/wiki/Divide_and_rule
05:00:26 <Cale> AStorm: why?
05:00:48 <ivanm> SamB: the type of Latin Square I'm trying to generate is someone's IP... and I've been told by my supervisor at uni not to reveal it just in case, because he wasn't sure of the legal stuff behind it
05:01:02 <Cale> AStorm: The goal of H' is effectively to write down what's already been done.
05:01:09 <SamB> ivanm: it is patented?
05:01:18 <ivanm> I doubt it ;)
05:01:28 <SamB> then what the hell could the problem be?
05:01:30 <Eelis> what's the point of having a separate "map" when there is the more general "fmap" ?
05:01:30 <ivanm> especially as I have to give a talk and write a paper on this after I've finished
05:01:41 <Cale> AStorm: It should be a subset of what's actually been implemented already.
05:01:56 <Cale> Eelis: very little.
05:02:02 <Eelis> Cale: historical accident?
05:02:06 <SamB> Eelis: well, map is less polymorphic
05:02:11 <ivanm> SamB: I'm just doing what I've been told, as I don't want to get inito any trouble with the lawyers
05:02:31 <Cale> Eelis: ask the Haskell 98 committee. It wasn't like that in 1.4
05:02:36 <SamB> some people in the h98 group were against too much polymorphism in the most commonly used functions
05:02:38 <ivanm> Saizan: not quite sure how divide et impera applies here...
05:03:03 <Eelis> Cale/SamB: i see. thanks
05:03:03 <quicksil1er> Eelis: c.f. also liftM :P
05:03:06 <SamB> considering how inefficiently GHC supports overloading, they may have had a point
05:03:24 <SamB> JHC should have no trouble with that, but you might need a gig of RAM to run it
05:03:26 <pejo> SamB, thats more a case for fixing ghc though.
05:03:29 <Cale> liftM, fmap, map, (.) could all be unified.
05:03:36 <SamB> pejo: I agree most heartilly
05:04:03 <Cale> If it were up to me, I'd keep map and (.) and make them exactly the same thing.
05:04:06 <SamB> but anyway, there is also an argument that map gives easier to understand error messages for newbies
05:04:35 <pejo> SamB, heh, yet another case for fixing ghc.
05:04:47 <Cale> (that is, functorial map)
05:05:17 <SamB> also I think we night nead Meachem's class synonym stuff
05:05:31 <Cale> Oh, to fix the rest of the problems, yes.
05:05:40 <Cale> Not for this in particular, I don't think.
05:27:53 <ivanm> I'm off, if anyone else has the time and is bothered enough to read through my code (URL above), please email me at the address listed there with any suggestions/comments/abuse
05:46:46 <nomeata> Hi. I have a list of values and I have to sort them into a tree, depth first. Is there some higher order function that I should use there?
05:46:58 <pejo> @tell ndm Check man 5 crontab, search for "@reboot"
05:46:59 <lambdabot> Consider it noted.
05:47:26 <ndm> pejo: ?
05:47:26 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
05:47:28 <dcoutts_> nomeata, what kind of tree? a binary search tree?
05:47:30 <nomeata> (Basically the list elements have a â€œlevelâ€ attribute, and all elements with level n+1 are childs of the level n element before it)
05:48:02 <dcoutts_> nomeata, ah ok, see the functions in Data.Tree for building trees
05:48:05 <nomeata> dcoutts_: A PDF fileâ€™s index, that the acrobat reader presents in the left bar
05:48:29 <dcoutts_> there are ones for unfolding trees and forests
05:48:40 <swiert> dcoutts_: Did you see the CUP email?
05:49:06 <dcoutts_> swiert, no, but I've not looked in the last 3 hours
05:49:41 <nomeata> unfoldTree might be the right one, but then I have to use the Tree data type (not too bad, but is there a generatlized version)
05:50:00 <dcoutts_> g'afternoon xerox
05:50:24 <swiert> \msg dcoutts_: They'll resend the book - I was just need you to confirm your address.
05:50:25 <pejo> ndm, oh, you're here. About starting things upon booting.
05:50:33 <dcoutts_> swiert, ah ok
05:50:39 * xerox hugs dcoutts_
05:50:47 <nomeata> or maybe a â€œclass UnfoldableTreeâ€?
05:50:57 <ndm> pejo: its really not that simple, apparently - permissions etc complicate things
05:51:08 <ndm> pejo: it really needs to be someone who's actually got it working
05:51:10 <dcoutts_> swiert, postal address: http://web.comlab.ox.ac.uk/oucl/about/contact.html
05:51:12 <lambdabot> Title: Oxford Computing Lab: contact information
05:51:33 <dcoutts_> swiert, so just "Duncan Coutts" at that postal address.
05:52:07 <pejo> ndm, why would the user have different permissions at startup rather than when executing?
05:52:08 <dcoutts_> nomeata, or just grab the code and change it to your tree type, or convert the tree into your custom tree type.
05:52:31 <xerox> Hylomorphisms!
05:52:32 <dcoutts_> xerox, how're the exams going?
05:52:43 <nomeata> true, getting the code is probably easiest
05:52:47 <dcoutts_> xerox, yeah, fold . unfold
05:52:53 <ndm> pejo: i do not own a mac, but our mac people have said its hard that it first appears
05:52:56 <xerox> dcoutts_: yeah :D
05:53:23 <xerox> dcoutts_: I think it's going on nicely. Didn't got the results yet.
05:53:32 <xerox> (Sorry for the bad phrasing.)
05:53:41 <nomeata> actually, they are oneliners, I can just do it myself :-)
05:54:31 <dcoutts_> xerox, bad phrasing excused :-)
05:54:54 <swiert> dcoutts_: Should be sorted now (fingers crossed).
05:55:38 <dcoutts_> swiert, ok great :-)
06:02:10 <timbod> dcoutts_: Hi.
06:03:03 <dcoutts_> timbod, gotta go, I'm running a programming languages practical in 1 minute :-)
06:03:21 <Lemmih> A what?
06:03:33 <timbod> dcoutts_: I want to ask about separating cairo from gtk2hs - I'll do it some other time.
06:05:33 <xerox> Lemmih: students come to the lab and start hacking, when they get stuck, they bug Duncan, he gently replies to each of them in order until it gets _very_ late. Then he turns everything off and wanders home jumping bridges.
06:09:42 <kolmodin> Lemmih: basically the same thing he does here, but IRL :)
06:29:31 <cperfumo> Hi! I just installed conjure (BitTorrent Client written in haskell) but I can't download anything, sometimes I get the error "Error: Not a list: peers" and some other times i get something like "file doesn't exist". I am typing "conjure something.torrent". Any idea? (I know the question is o directed related to Haskell, but I'm interested in working on STM and conjure claims to use it quite heavily)
06:32:08 <Lemmih> cperfumo: Hm, that's an error message from the torrent parser.
06:32:27 <Lemmih> cperfumo: Are you feeding it an invalid torrent?
06:33:32 <Lemmih> It's probably more likely that the parser is broken.
06:34:01 <cperfumo> Lemmih: im feeding it with some files that ktorrent can open and download
06:34:31 <Lemmih> cperfumo: It might be choking on the tracker response.
06:34:41 <Lemmih> cperfumo: Can you paste the full output?
06:35:13 <cperfumo> of course
06:35:17 <cperfumo> @paste
06:35:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:37:53 <hpaste>  cperfumo pasted "conjure" at http://hpaste.org/322
06:39:14 <Lemmih> Hm, that's a weird tracker response.
06:40:27 <cperfumo> Lemmih: done. I'm thinking maybe I'm using a too complex torrent file (very new version or so). I just need to download something with conjure. Maybe someone (likely the authors) can provide me with a torrent file that conjure can download (that's all I need by now)
06:41:45 <Lemmih> I usually test with this one: http://thepiratebay.org/tor/3545844/Tipping_the_Velvet_(Lesbian_drama)
06:41:47 <lambdabot> Title: Tipping the Velvet (Lesbian drama) - The Pirate Bay, http://tinyurl.com/yv2jgb
06:42:59 <cperfumo> ok :)
06:43:25 <kzm> Anything to motivate people to volunteer to help with testing... :-)
06:45:09 <nomeata> Strange that there is no "ifMaybe :: Bool -> a -> Maybe a". Would it be the same as "ifMaybe cond val = guard cond >> return val"?
06:45:26 <nomeata> @type let ifMaybe cond val = guard cond >> return val in ifMaybe
06:45:28 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Bool -> a -> m a
06:45:30 <mux> @type maybe
06:45:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:45:37 <nomeata> @type let ifMaybe cond val = guard cond >> Just val in ifMaybe
06:45:37 <hpaste>  cperfumo pasted "conjure2" at http://hpaste.org/323
06:45:39 <lambdabot> forall a. Bool -> a -> Maybe a
06:45:40 <mux> @type fromMaybe
06:45:42 <lambdabot> forall a. a -> Maybe a -> a
06:46:07 <cperfumo> now I got the other error (file doesn't exist). I pasted it
06:46:49 <Lemmih> cperfumo: Oh right. Conjure doesn't create any directories yet. Create 'Tipping The Velvet' and try again.
06:47:20 <Lemmih> cperfumo: It'd be great if you would fix that, btw (:
06:48:28 <mauke> @type let toMaybe c = if c then const Nothing else Just in toMaybe
06:48:30 <lambdabot> forall b. Bool -> b -> Maybe b
06:49:29 <nomeata> mauke: that would do it as well. you donâ€™t know of a library function that does it?
06:49:40 <nomeata> @djinn  Bool -> b -> Maybe b
06:49:41 <lambdabot> f a b =
06:49:42 <lambdabot>     case a of
06:49:42 <lambdabot>     False -> Nothing
06:49:42 <lambdabot>     True -> Just b
06:50:12 <nomeata> I really think that djinn should be integrated into ghc, so I can just write "djinn" whereever I am too lazy to define the function.
06:50:23 <mauke> @hoogle Bool -> a -> Maybe a
06:50:24 <lambdabot> No matches, try a more general search
06:50:43 <Lemmih> nomeata: We can probably do that with Template Haskell.
06:50:51 <mauke> nomeata: IIRC there's a djinn implementation in the typesystem
06:51:06 <nomeata> @type let toMaybe c = (>>) guard c . return
06:51:07 <lambdabot> not an expression: `let toMaybe c = (>>) guard c . return'
06:51:12 <nomeata> @type let toMaybe c = (>>) guard c . return in toMaybe
06:51:14 <lambdabot>     Couldn't match `Bool' against `m a'
06:51:14 <lambdabot>       Expected type: a -> Bool
06:51:34 <nomeata> @type let toMaybe c = (>>) (guard c) . return  in toMaybe
06:51:36 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Bool -> a -> m a
06:52:33 <nomeata> we could name it toMonadPlus and it would work for lists and other types as well.
06:52:38 <quicksil1er> if b then return else fail ""
06:52:54 <mauke> nomeata:  http://okmij.org/ftp/Haskell/de-typechecker.lhs
06:52:57 <cperfumo> Lemmih: it's downloading now. Thank you
06:54:38 <Lemmih> cperfumo: No problem. Oh and if the MPAA calls, you don't know me. (:
07:02:18 <nomeata> @pl let toMaybe c = (>>) guard c . return in toMaybe
07:02:18 <lambdabot> (. return) . (guard >>)
07:22:22 <malebria> Is there a fill function for text, that breaks a text in column 80?
08:12:19 <Igloo> Any Darwin users know how I can find the portfile(?) for http://ghc.darwinports.com/dports/lang/ghc/Portfile ?
08:15:10 <swiert> Igloo: it should just be ghc.darwinports.com
08:15:33 <Igloo> swiert: That's just the same thing?
08:15:36 <noj> Igloo, on your local filesystem?
08:15:45 <noj> in that case: cd `port dir ghc`
08:15:53 <Igloo> Ah...how would I find it if I don't have a mac?
08:16:28 <swiert> Igloo: I see your point. Hang on.
08:16:36 <noj> http://trac.macports.org/projects/macports/browser/trunk/dports/lang/ghc
08:16:42 <lambdabot> Title: /trunk/dports/lang/ghc - MacPorts - Trac, http://tinyurl.com/22zwl5
08:17:12 <Igloo> Cool, thanks!
08:23:21 <paolino> hi, anyone knows if  there is a sqlite3 wrapper running on freebsd ?
08:26:26 <hpaste>  DukeDave pasted "Discrete fuzzy sets example" at http://hpaste.org/325
08:46:02 <bringert> hi shankys_
08:46:15 <bringert> how's your web app framework coming along?
08:46:15 <shankys_> bringert: hey
08:46:33 <shankys_> bringert: Its coming along fairly well
08:46:47 <shankys_> bringert: We've decided to delay releasing it though
08:47:04 <shankys_> bringert: We wanted to do more features for our startup before we launch that
08:47:30 <shankys_> bringert: And we had pretty much decided that the framework and the startup should be released hand in hand
08:49:11 <shankys_> bringert: One of the big reasons for delaying launching was to make things more scalable by doing things like adding caching, connection pooling, etc...
08:49:45 <bringert> shankys_, I saw that the new takusen includes pooled connections. I guess that's your doing?
08:50:02 <shankys_> well, more of Oleg's doing really
08:52:12 <blsecres> is there a prelude function similar to scanl that doesn't pass the result on to the next step?  fcn f [a, b, c, d...] = [f a b, f b c, f c d...]
08:53:04 <_roconnor> blsecres: I'm not sure that type checks
08:53:11 <_roconnor> f would need to take infinite argumetns
08:53:20 <nmessenger> @type \f xs -> zipWith f xs (tail xs)
08:53:21 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
08:53:41 <blsecres> nmessenger: thanks
08:54:07 <nmessenger> @let adjacent f xs = zipWith f xs (tail xs)
08:54:08 <lambdabot> Defined.
08:54:22 <nmessenger> > adjacent (<=) [1,4,6,7]
08:54:22 <lambdabot>  [True,True,True]
08:54:31 <nmessenger> > adjacent (<=) [1,10,6,7]
08:54:33 <lambdabot>  [True,False,True]
09:04:14 <bringert> shankys_, ok, sounds like a good marketing strategy
09:04:23 <bringert> shankys_, good luck
09:06:40 <shankys_> bringert: That's what I'm hoping... Ideally, I'd like to do for Haskell what 37signals did for Ruby
09:07:23 <glguy> what did 37signals do for ruby?
09:07:30 <shankys_> ruby on rails
09:07:51 <glguy> but don't the ruby users hate them for that?
09:07:55 <shankys_> ruby really took off after ruby on rails got popular
09:08:03 <quicksil1er> shankys_: you mean, bring it into terrible disrepute and fill internet forums with idiots talking crap about the language?
09:08:08 <quicksil1er> Ah, that's not what you meant :)
09:08:12 <shankys_> hehe
09:08:52 <shankys_> There are drawbacks to having your language be popular
09:09:05 <shankys_> But I'd like lots of useful Haskell libraries so...
09:09:07 <glguy> the users :)
09:09:40 <glguy> Haskell already has its share of people who don't know what they are talking about blogging about Haskell
09:13:16 * syntaxfree raises his hand.
09:13:57 <syntaxfree> it's curious that I focused on this window the moment that was said ; )
09:16:48 <glguy> ?yow
09:16:49 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me to
09:16:49 <lambdabot> Minnesota but don't EMBARRASS me!!
09:19:51 <syntaxfree> anyway. given the Monad class the Prelude or Control.Monad provide, you can't define join and let bind be autodefined from that -- or can you?
09:20:24 <Saizan> you can't
09:20:29 <Saizan> ?src Monad
09:20:30 <lambdabot> class  Monad m  where
09:20:30 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:20:30 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:20:30 <lambdabot>     return      :: a -> m a
09:20:30 <lambdabot>     fail        :: String -> m a
09:20:37 <quicksil1er> in principle one could define join and return, and have bind defined from that
09:20:42 <quicksil1er> and fmap
09:20:50 <quicksil1er> but in practice that's not how it's written
09:21:05 <quicksil1er> (to clarify, define join and fmap, bind could be derived)
09:21:25 <syntaxfree> in principle you mean, in theory?
09:21:28 <quicksil1er> yes
09:21:37 <syntaxfree> I see.
09:21:51 <quicksil1er> but haskell doesn't allow you to let the user choose
09:21:57 <quicksil1er> you can provide defaults for some
09:22:09 <quicksil1er> but you can't provide 'recursive defaults' and leave the user to choose an independent set
09:22:12 <syntaxfree> yes, yes. I thought there might be a Monad' class or something. Thanks.
09:22:23 <quicksil1er> I don't think there is a technical reason, just it would be a bit confusive
09:22:29 <Saizan> quicksil1er: you can write recursive default
09:22:37 <quicksil1er> Saizan: oh, you can?
09:22:48 <bd_> You could define a join', and a Functor instance, and just do (>>=) m f = join $ fmap f m
09:22:52 <bd_> join' even
09:22:53 <Saizan> yes, it's done in Eq or Ord, i don't remember
09:23:05 <quicksil1er> then I don't know why they don't
09:23:08 <bd_> Saizan: they all have to be in the same typeclass though, I think
09:23:08 <syntaxfree> that is true.
09:23:19 <Saizan> bd_: sure
09:23:27 <bd_> and Monad doesn't imply Functor :/
09:23:32 <quicksil1er> well there is liftM
09:23:39 <quicksil1er> you could define join and liftM
09:23:43 <syntaxfree> I don't even know if I have a proper monad, it just striked (stroke?) me that a liftM2 would be useful.
09:23:45 <quicksil1er> (to me, this would be more natureal)
09:23:47 <bd_> quicksil1er: liftM is not a class functor
09:23:49 <bd_> function*
09:23:52 <xerox> syntaxfree: yeah you can define your own hierarchy of classes that work any other way around.
09:23:58 <quicksil1er> bd_: no, but it could be?
09:24:05 <bd_> hmm
09:24:08 <bd_> I guess that would work
09:24:11 <syntaxfree> xerox: sure, but I'd have to rewrite all the fun monad utils.
09:24:12 <quicksil1er> join isn't a class function either
09:24:19 <bd_> and derive Monad m => Functor m where fmap = liftM
09:25:01 <quicksil1er> I've always found lift and join more natural, but I think that is just a personal bias
09:26:15 <bd_> I find it depends on the monad... join makes a lot of sense with eg [] or Maybe, but for Cont, bind's more clear to me
09:29:16 <syntaxfree> join's more clear for the simpler monads.
09:29:32 * glguy tests an irssi script
09:29:39 <nmessenger> @wiki The_Other_Prelude
09:29:40 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
09:29:50 <glguy> (nevermind)
09:30:13 <nmessenger> syntaxfree: ^^ you're not the only one who's commented about the Monad heirarchy
09:30:46 <syntaxfree> I was reading the Numeric Prelude code today.
09:30:55 <syntaxfree> I like the idea of a better Num tower.
09:32:00 <syntaxfree> maybe there should be a better Prelude process.
09:32:13 <Saizan> process?
09:33:19 <syntaxfree> ah, yes. a separate Prelude standard, to be defined via a process much like Haskell is standardized.
09:33:19 <syntaxfree> Except faster, because it's less deep and more people can chime in.
09:34:13 <syntaxfree> Haskell' has a lot to decide about type system extensions and suchlike -- maybe it's a good idea to separate discussions like the Num hierarchy from that specific, more complex, standardization process.
09:35:01 <quicksil1er> Haskell' is not (as I understand it) about big new changes, either
09:35:15 <quicksil1er> it's about "which parts of what we already have in GHC and other extensions should we standardise)
09:35:21 <syntaxfree> yes, I know.
09:35:42 <glguy> does someone want to volutenteer to be auto removed from the channel by chanserv? if this works for active users, I would use it over opping, and kick banning when that spamer comes back
09:35:51 <glguy> (I'd undo it right away!)
09:35:56 <nmessenger> glguy: me first!
09:35:56 <syntaxfree> of course, I could always work with one of the alternate preludes immediately.
09:36:16 <nmessenger> ADULT FORUM!
09:36:17 <syntaxfree> it's just that they don't seem actively developed or discussed enough.
09:36:26 <quicksil1er> glguy: help yourself
09:36:45 <glguy> nmessenger: I added you... looks like it only works on joins
09:36:51 <nmessenger> test
09:37:03 * nmessenger /parts and tries to /join
09:37:10 --- mode: ChanServ set +b nmessenger!*@*
09:37:20 <quicksil1er> heh
09:37:25 --- mode: ChanServ set +o glguy
09:37:28 <quicksil1er> only on joins isn't very clever
09:37:33 --- mode: glguy set -b nmessenger!*@*
09:37:37 <quicksil1er> purely nick-based banning isn't that clever either, really
09:37:42 <glguy> quicksil1er: i was testing
09:37:44 <nmessenger> seems to work
09:37:49 <quicksil1er> ah :)
09:37:58 <glguy> hmm, so it's only on joins :(
09:38:43 <syntaxfree> anyway, back to coding.
09:39:00 <syntaxfree> I finally found a project I can possibly contribute significantly to.
09:39:03 --- mode: glguy set -o glguy
09:41:43 <chessguy> 'morning haskellers
09:43:40 <mwolak> does anyone here know much about dll's on windows?
09:45:20 <Rheiny> what exactly do you need, mwolak?
09:45:37 <mwolak> I'm trying to get the zlib bindings to work in windows
09:45:46 <Saizan> mmh
09:45:50 <Rheiny> in Haskell I assume?
09:45:56 <mwolak> yup
09:45:57 <Saizan> do you get an error message?
09:46:14 <Saizan> i've had to rename zlib1.dll to z.dll
09:46:23 <mwolak> I managed to get it to compile by copying cygwin's libz stuff into the gcc-lib directory in my ghc installation
09:46:34 * chessguy sighs
09:46:47 <mwolak> but when I run a test program, it freezes
09:46:51 <chessguy> we need to find a way to convince people not to just answer simple newbie questions
09:46:58 <chessguy> but to guide them along the way
09:47:44 <Rheiny> does the program freeze right at the start or when you call a zlib function?
09:47:52 <monochrom> Yes, but it's hard to do on IRC.  It's more feasible face-to-face and with a blackboard.
09:48:28 <tuukkah> irc with a whiteboard extension...
09:48:43 <koala_man> yay, cloud shaped diagrams ftw
09:48:46 <mwolak> Rheiny: it definately does some stuff before freezing
09:48:56 <chessguy> monochrom, i was more referring to -cafe, but both there and here, a lot can be done by giving similar examples and using the socratic method
09:48:59 <monochrom> The blackboard is only half of the story.
09:49:21 <tuukkah> face-to-face, nick-to-nick :-)
09:49:22 <Rheiny> are you sure you're calling the zlib functions properly?
09:49:40 <monochrom> There is something about face-to-face that effectuates the socratic method.
09:49:41 <mwolak> Rheiny: it works on a linux box and a freebsd one
09:49:56 <chessguy> ?src take
09:49:57 <lambdabot> take n _      | n <= 0 =  []
09:49:57 <lambdabot> take _ []              =  []
09:49:57 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
09:50:14 <Rheiny> ok, can you try if you can use the DLL from C or C++?
09:50:14 <tuukkah> monochrom, perhaps irc doesn't give you enough feedback as there isn't any implicit
09:50:17 <Rheiny> or something else
09:50:21 <Rheiny> just to make sure the DLL works
09:50:56 <monochrom> Heh!  One property of face-to-face is that you can effectively lock yourself and the newbie in a room and there is no third party to distract your socratic method by giving away answers!
09:51:10 * quicksil1er smiles at the blatant homework questions on the mailing list
09:51:12 <mwolak> Rheiny: I'm not sure how to do that... I tried, but couldn't get ghc to stop complaining about the missing -lz
09:51:30 * ibid gets a government-issued electronic id tomorrow
09:51:42 <tuukkah> monochrom, that might have led to the part about convincing all people
09:52:39 <tuukkah> ibid, that will be your method to prove your questions aren't homework %-)
09:52:53 <monochrom> No-third-party is only one quarter of the story.
09:52:57 <Saizan> mwolak, you have the .dll on your path, right? (just to check the basic)
09:53:15 <ibid> tuukkah: hah, my questions definitely *are* homework!
09:53:18 <Igloo> mwolak: For inflate/deflate http://urchin.earth.li/darcs/ian/inflate should now work FWIW, although I haven't done any benchmarking or performance tweaking
09:53:20 <lambdabot> Title: Index of /darcs/ian/inflate
09:53:23 <ibid> tuukkah: ... to the person i direct them to :)
09:53:42 <Igloo> Oh, and the .cabal file is out of date
09:53:42 <xerox> monochrom: one quarter of the story is left, and then I can go to sleep.
09:54:11 <monochrom> Heh yeah.
09:54:11 <Rheiny> mwolak: there are some examples in the zlib source (examples directory), maybe you can try your compiled dll with them
09:54:58 <tuukkah> would the last quarter be the part about cathing the learner's attention for more than 30 seconds. Student joins #haskell. Student asks a question. Student leaves #haskell.
09:55:21 <Rheiny> I fear that I can't help you with the DLL any further because I've never used zlib with Haskell
09:55:31 <monochrom> An important part of the socratic method is: you get the newbie to pursue your path, not his path. (Clearly his path is most probably unfruitful.)
09:55:44 <syntaxfree> hey, is sequence lazy?
09:56:03 <glguy> ?src sequence
09:56:03 <lambdabot> sequence ms = foldr k (return []) ms
09:56:04 <monochrom> When face-to-face, when you speak, he has to listen, and in a few seconds he's absorbed into your path and has forgotten his.
09:56:04 <lambdabot>     where
09:56:04 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
09:56:17 <glguy> looks like it
09:56:29 <monochrom> On IRC, when you type, the newbie goes on to ponder how to make his futile path work.
09:56:36 <glguy> > take 2 $ sequence [succ,pred,undefined] 5
09:56:38 <lambdabot>  [6,4]
09:56:39 <xerox> monochrom: do you believe in reverse engineering the socratic method?
09:56:42 <glguy> > take 3 $ sequence [succ,pred,undefined] 5
09:56:44 <lambdabot>  Undefined
09:56:59 <monochrom> I haven't thought of that.
09:57:19 <monochrom> Well I have.  The result would be telepathy.
09:57:48 <cjeris> is there a better noun for "that which adjoins" than "adjunction", which is taken with a specific meaning for functors?
09:57:58 <monochrom> adjunct
09:58:13 <monochrom> associated. associate.
09:58:17 <cjeris> no... i mean "that which performs the act of adjoining".
09:58:41 <monochrom> adjunction manager  XD
09:58:52 * monochrom throws in a few OO terms
09:58:56 <xerox> Of associated press?
09:58:57 * cjeris shoots himself in the head at the prospect of switching to Java
09:58:59 <rahikkala> adjunctor? Or is that already used somewhere? Or is it just a silly word?
09:59:11 <cjeris> actually, it's a javascript program X(
09:59:34 <monochrom> adjuntizer
09:59:38 <rahikkala> I mean, I'm not completely sure what a functor is, but I don't think it's something that performs the act of functing
09:59:39 <monochrom> err missing a c
10:00:13 <cjeris> rahikkala: this is an educational institution, we can't funct in public here yet :)
10:00:42 <syntaxfree> well, I tested it.
10:00:47 <cjeris> hm.  i could always switch to 'staple' and 'stapler'...
10:01:13 <glguy> It isn't a "functer" :)
10:01:37 <cjeris> staplor? :0
10:03:55 <glguy> Haskell is a Category, right?
10:03:57 <monochrom> haha stapler
10:05:41 <glguy> When we talk of the class "Functor" we are refering to "endofunctors"
10:05:58 <glguy> "Given a category C an endofunctor is a functor T:C->C"
10:06:17 <glguy> so that is to say you map from things in Haskell, to things in Haskell?
10:08:15 <monochrom> Yes.
10:08:31 <glguy> and the classs isn't so much the functor as the function "fmap" right?
10:08:49 <glguy> things in class Functor are elligible to be used by a functor?
10:09:10 <monochrom> That is self-confusing.
10:09:16 <glguy> I am confused
10:09:30 <monochrom> You are unifying things that shouldn't be unified.
10:10:03 <glguy> What is a concrete example of an "endofunctor" in haskell?
10:10:10 <glguy> [1]? fmap succ?
10:10:13 <glguy> neither?
10:10:38 <glguy> fmap succ [1] -- I'm trying to figure out which of these is "T"
10:10:40 <monochrom> Any type constructor is an endofunctor.
10:10:52 <glguy> Just
10:11:06 <monochrom> type constructor
10:11:12 <glguy> oh
10:11:13 <glguy> Maybe
10:11:17 * monochrom is demonstrating the socratic method
10:11:29 <xerox> hahaha
10:11:31 <Saizan> ah so if i have something of kind * -> *, that is T and * is C?
10:12:52 * monochrom was not purely socratic yet, as you can see.
10:13:32 <zarvok> you need a monad for the non-socratic hints
10:13:42 <zarvok> to retain purity
10:13:43 <monochrom> hahahaa
10:13:47 <glguy> that would make sense then when they say: "A monad over a category C is a triple..."
10:14:04 <glguy> since a monad is parameterized over a type
10:14:07 * xerox falls from the chair
10:15:30 <glguy> (T,eta,mu) where T is an endofunctor of C, eta is a natural transformation from the identity functor on C, and mu is a natural transformation from T o T to T
10:15:37 <glguy> http://planetmath.org/?op=getobj&from=objects&name=Monad
10:15:41 <glguy> (what I'm reading)
10:15:41 <lambdabot> Title: PlanetMath: monad
10:16:14 <Saizan> a bit like (fmap,return,join)?
10:16:22 <Syzygy-> glguy: Ayup.
10:16:26 <Syzygy-> Saizan: More or less, yeah.
10:16:30 <Syzygy-> ?type join
10:16:32 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
10:16:36 <Syzygy-> Yeah, precisely that.
10:16:48 <Syzygy-> That's the translation from category monad to haskell monad.
10:17:00 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/327
10:17:20 <monochrom> Who is anonymous?
10:17:27 <Saizan> well fmap is not exactly the endofunctor, "m" is, if i understand correctly
10:17:27 <Syzygy-> And the endofunctor language says that you map types to types by using the monad, and functions follow along using the impled fmap.
10:17:29 <paolino> uhm, me
10:17:42 <Syzygy-> m is the endofunctor. fmap is what you use to lift a map into the functor.
10:17:52 <glguy> (T,Î·,Î¼) -- T isn't the type constructor?
10:18:17 <Syzygy-> glguy: T is the endofunctor, i.e. T maps any type to a new type (such as IO :: Int -> IO Int)
10:18:18 <paolino> the code I pasted is not reading lines , why ?
10:18:58 <monochrom> delete hClose
10:19:24 <paolino> uh, why ?
10:19:36 <monochrom> For more information, reading between the lines of the doc of hGetContents, and also probably look for mailing list discussions on it.
10:22:07 <glguy> is that the same eta as in "eta-reduction"
10:22:19 <Syzygy-> Nope.
10:22:23 <Syzygy-> Those are different
10:22:28 <glguy> ok
10:23:22 <Syzygy-> glguy: Viewing the monad as a monoid in the category of endofunctors on the Haskell category, you get eta the identity and mu the multiplication of that particular monoid.
10:25:32 <Saizan> ?type join . join . fmap
10:25:34 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
10:25:34 <lambdabot>       Expected type: (a -> b) -> f a -> f a -> a1
10:26:13 <Syzygy-> ?type join . join
10:26:14 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
10:26:20 <glguy> ?type join . join . Just
10:26:21 <Syzygy-> ?type fmap
10:26:22 <lambdabot> forall a. Maybe (Maybe a) -> Maybe a
10:26:23 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
10:26:24 <xerox> hehe
10:26:34 <glguy> ?type join . Just . join
10:26:36 <xerox> Oleg did deep'join when I got stuck and asked him for advice.
10:26:36 <lambdabot> forall a. Maybe (Maybe a) -> Maybe a
10:26:50 <xerox> deep'join :: Monad m => m (m (m .. a ..)) -> m a
10:26:55 <Syzygy-> glguy: Note that Just is the return of Maybe.
10:27:04 <glguy> right
10:27:10 <glguy> so that's not what I want?
10:27:31 <Syzygy-> I'm not certain of what you want, but combining join and return is just one of the monad laws...
10:27:34 <glguy> because Î· is the return?
10:27:45 <Syzygy-> glguy:  I get your characters as ?
10:27:55 <Syzygy-> Use 'mu' and 'eta' instead, would you?
10:28:04 <Syzygy-> eta is return. mu is join.
10:28:24 <glguy> I'm trying to write: mu . (mu . T) === mu . (T . mu)
10:29:00 <xerox> :t join . (join . fmap)
10:29:02 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
10:29:02 <lambdabot>       Expected type: (a -> b) -> f a -> f a -> a1
10:29:09 <xerox> :t join . (fmap . join
10:29:11 <lambdabot> parse error (possibly incorrect indentation)
10:29:12 <xerox> :t join . (fmap . join)
10:29:14 <Syzygy-> Ah. Well, .... hmmmm.
10:29:14 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
10:29:14 <lambdabot>       Expected type: (a -> a -> a2) -> f a -> f a -> a1
10:29:24 <glguy> :t \f -> join . (join . fmap f)
10:29:26 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f (f a)) -> f a1 -> f a
10:29:35 <glguy> :t \f -> join . (fmap f . join)
10:29:36 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a1 -> m a) -> m (m a1) -> m a
10:29:54 <glguy> :t \f -> join . (f . join)
10:29:56 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m, Monad m1) => (m1 a1 -> m (m a)) -> m1 (m1 a1) -> m a
10:29:57 <Syzygy-> They don't look the same.
10:29:59 <glguy> :t \f -> join . (join . f)
10:30:01 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (m (m a))) -> a1 -> m a
10:30:14 <Syzygy-> Oh well, I'm off.
10:31:37 <bd_> ?where vty
10:31:37 <lambdabot> http://members.cox.net/stefanor/vty/
10:33:02 <Saizan> ?type \f a -> join $ fmap f (return a)
10:33:04 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a1 -> m a) -> a1 -> m a
10:33:37 <Saizan> ?type \f a -> join $ return (fmap f)
10:33:39 <lambdabot> forall (f :: * -> *) a b t. (Functor f) => (a -> b) -> t -> f a -> f b
10:34:20 <Saizan> ?type \f a -> join $ return (fmap f a)
10:34:23 <lambdabot> forall (f :: * -> *) b a. (Monad f, Functor f) => (a -> b) -> f a -> f b
10:35:53 <ToRA> ?type join.return.fmap
10:35:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f a -> f b
10:36:00 <ToRA> ?type join.return.liftM
10:36:02 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:51:20 <dcoutts_> hia timbod
10:51:43 <dcoutts_> xerox, hah hah, nice description of what a practical is :-)
10:53:19 <dcoutts_> timbod, yeah, it'd be nice to separate them all eventually
10:53:35 <dcoutts_> the plan is to cabalise all the gtk2hs packages
10:53:51 <dcoutts_> then they can be distributed individually
10:54:16 <dcoutts_> however that's not an easy job to improve cabal and c2hs to the point where we can make that work well
10:54:44 <Gwern> so, a question on haskell cafe got me thinking, what is the best way to take a list of Ints and return a list consisting only of Ints that are divisble by a given number? I came up with:
10:54:48 <Gwern> rmFact x ys = [n | n<-ys , ((mod n 2) == 0)]
10:55:09 <dcoutts_> Gwern, that seems very reasonable
10:55:12 <Gwern> ack, replace the 2 with a x
10:55:55 <Gwern> yeah, but using the mod somehow feels wrong.
10:56:07 <Gwern> and I'd have to add a branch for dealing with zeros
10:56:15 <astrolabe> I'd prefer a filter because I think it's quicker to get an approximate idea of what it does.
10:56:27 <astrolabe> but I'm being picky and idiosyncratic
10:56:57 <dcoutts_> @pl \n -> (mod n 2) == 0
10:56:58 <lambdabot> (0 ==) . flip mod 2
10:57:18 <dcoutts_> filter (\n -> n `mod` 2 == 0)
10:57:43 <Gwern> hmm. that's a good idea. I immediately thought of list comprehensions and never even thought about filters
10:58:22 <dcoutts_> Gwern, filter p xs = [ x | x <- xs, p x ]
10:58:33 <dcoutts_> map f xs = [ f x | x <- xs ]
10:58:33 <sjanssen> filter even
10:59:05 <Gwern> they're equivalent? that's clever
10:59:38 <Gwern> so list comprehensions are just convenient forms of filters?
11:00:14 <Botje> test >>= \x -> guard (x`mod`2 ==0) >> return x
11:00:20 <Botje> that also works.
11:00:21 <sjanssen> list comprehensions are technically more powerful than filter/map
11:00:25 <Botje> (where test is that list
11:00:47 <int-e> > [x*y | x<-[1..2], y <- [1..2]]
11:00:49 <lambdabot>  [1,2,2,4]
11:04:42 <Gwern> hmm hmm. I think I see now. Thanks for the help guys
11:05:20 <Botje> I wonder how you'd write that using arrows.
11:05:31 <Gwern> Botje: please, don't mention arrows in front of me :)
11:06:06 <Botje> they're not too bad.
11:06:42 <Gwern> maybe, but I have not worked my way up to monads yet, which I understand as a prerequisite for arrows
11:06:52 <quicksil1er> If you're interface a module which uses maybe for errors and a module which uses Either for errors, can you expect to keep writing : maybe (Left "foo had some kind of error") Right (foo p1 p2 p3)
11:07:10 <quicksil1er> or is there a more idiomatic way?
11:18:00 <paolino> how implement  a takeWhile with state ?
11:20:10 <paolino> probably s/state/accum
11:25:53 <aFlag> hi, is there a function that will make a try-catch-finally behaviour inside a monad?
11:26:09 <aFlag> actually
11:26:13 <aFlag> I only need the finally
11:26:22 <aFlag> and a if
11:26:55 <glguy> finally :: IO a -> IO b -> IO a         -- Defined in Control.Exception
11:27:27 <glguy> mplus can be used to that effect as well
11:27:56 <glguy> > (do { a <- Just 1; b <- Nothing; return a}) `mplus` Just 3
11:27:58 <lambdabot>  Just 3
11:28:03 <glguy> err
11:28:11 <glguy> that might not be what you meant
11:28:21 <glguy> that's more of a catch :)
11:29:43 <aFlag> nice, thanks :)
11:30:43 <quicksil1er> paolino: sounds like using foldl or foldr, in composition with takeWhile
11:35:53 <mwolak> hmm... got everything to compile and run by using dlltool on zlib1.dll, but output isn't quite right
11:36:48 <paolino> > let aTakeWhile f z c xs = map snd . takeWhile (\(s,_) -> c s). tail. scanl (\(s,_) x -> (f s x,x)) (z,head xs) $ xs in aTakeWhile (+) 1 (<100) [1..]
11:36:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13]
11:37:16 <paolino> something like this but in haskell :)
11:40:28 <paolino> aTakeWhile f z c = map snd . takeWhile (\(s,_) -> c s). tail. scanl (\(s,_) x -> (f s x,x)) (z,undefined)
11:40:35 <paolino> better
11:46:47 <newsham> ?farber
11:46:48 <lambdabot> Unknown command, try @list
11:47:13 <titus> @list
11:47:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:47:53 <titus> @babel
11:47:54 <lambdabot>   bzzt.
11:50:04 <titus> @help
11:50:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:50:13 <titus> @help babel
11:50:14 <lambdabot> babel <lang1> <lang2> <phrase>.
11:50:15 <lambdabot> Translate a phrase in lang1 to lang2.
11:50:15 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
11:51:00 <titus> @babel "en" "de" "Sir, you are giving me People Horror"
11:51:00 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language "en" not supported
11:51:31 <titus> @babel "english" "german" "Sir, you are giving me People Horror"
11:51:31 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language "english" not supported
11:51:50 <titus> @babel english german "Sir, you are giving me People Horror"
11:51:52 <lambdabot>   "geehrter Herr, geben Sie mir Leute-Grausigkeit"
11:52:15 <titus> @babel english french "Sir, you are giving me People Horror"
11:52:19 <lambdabot>   "monsieur, vous me donnez l'horreur de personnes"
11:52:51 <titus> @help karma
11:52:51 <lambdabot> karma <polynick>. Return a person's karma value
11:53:06 <titus> @karma titus
11:53:07 <lambdabot> You have a karma of 0
11:53:14 <titus> @karma dons
11:53:15 <lambdabot> dons has a karma of 120
11:53:50 <titus> @help url
11:53:51 <lambdabot> url <key>. Return element associated with key
11:54:01 <gotaku> What's the reason multi-parameter type classes were never added to Haskell 98?
11:58:32 <titus> @help fortune
11:58:33 <lambdabot> fortune. Provide a random fortune
11:58:40 <titus> @fortune
11:58:41 <lambdabot> Hackathon Raisin Rice
11:58:41 <lambdabot>  
11:58:41 <lambdabot> 10 cups rice
11:58:41 <lambdabot> 5 Onions, chopped fine
11:58:41 <lambdabot> 10 cloves garlic, crushed
11:58:43 <lambdabot> [17 @more lines]
12:05:59 <titus> @version
12:06:00 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
12:06:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:10:28 <newsham> ?babel fr en je ne veux pas dejeuner, je ne veux pas travailler, je veux seulment d'oublier, et puis je fume
12:10:29 <lambdabot>   I do not want dejeuner, I do not want to work, I want seulment to forget, and then I smoke
12:12:38 <benja_> hpaste: uri
12:12:44 <titus> @babel en fr right on :-)
12:12:45 <lambdabot>   droit dessus : -)
12:13:23 <benja_> @paste
12:13:23 <glguy> !paste
12:13:24 <hpaste> Haskell paste bin: http://hpaste.org/
12:13:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:13:32 <glguy> hpaste: url
12:13:33 <hpaste> Haskell paste bin: http://hpaste.org/
12:13:38 <benja_> oh
12:14:14 <hpaste>  benja_ pasted "class Hashable" at http://hpaste.org/328
12:14:40 <benja_> I'm thinking that something like this should be in the standard library, in Data.HashTable most likely
12:15:09 <benja_> anyone see something obviously wrong with the idea?
12:15:30 <glguy> benja_: (3,3)'s hash is the same as (5,5)'s?
12:15:39 <glguy> oh
12:15:40 <glguy> nevermind
12:15:46 <glguy> you hash the right side twice
12:16:02 <benja_> yup
12:16:16 <benja_> dunno if there's a better way =)
12:20:50 <titus> building lambdabot I've got "Could not find module `Data.ByteString.Char8':
12:20:50 <titus>   use -v to see a list of the files searched for
12:20:50 <titus>   (imported from scripts/BotPP.hs)
12:20:50 <titus> "
12:21:14 <titus> Do I need to let build know about the package?
12:21:20 <allbery_b> what version of ghc?
12:21:35 <titus> allbery_b: 6.4.1
12:21:37 <allbery_b> (I'm not sure 6.4.x is even supported any more)
12:21:45 <allbery_b> install fps
12:21:46 <titus> oh
12:21:55 <allbery_b> (it's standard in 6.6)
12:21:55 <titus> fps?
12:21:55 <allbery_b> ?where fps
12:22:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
12:22:27 <allbery_b> you'll also need to add a dependency on fps to the cabal file
12:22:46 <allbery_b> but I suspec you may run into bigger problems with 6.4, I was under the impression other dependencies only worked with 6.6 these days
12:23:19 <titus> OK - I will upgrade. 6.4.1 is the latest package for ubuntu...
12:23:42 <titus> thanks.
12:24:13 <allbery_b> hm, thought debian's 6.6 was in universe
12:24:25 <allbery_b> (a port thereof at least)
12:24:40 * allbery_b not an ubuntu user though, not certain
12:25:54 <titus> well it would probably install if forced to do so
12:26:23 <titus> but not part of the (slightly annoying) ubuntu scheme of things
12:26:49 <glguy> Haskell's lack of reference-equality make it impossible to determine that the list: xs = 1 : 2 : 3 : ys where ys = 4 : 5 : ys  -- is a loop
12:26:51 <benja_> feisty has 6.6
12:26:52 <glguy> right?
12:27:00 * benja_ got it from there
12:27:15 <gotaku> Yes, feisty uses 6.6
12:27:57 <glguy> (or contains a loop, rather)
12:28:01 <titus> benja_: does it? I am on dapper and scared
12:28:02 <benja_> glguy: depends on what libraries you're willing to use and how sure you want to be able to detect loops :)
12:28:16 <titus> of breaking my setup with another apt upgrade :-)
12:28:31 <benja_> mhm, I can understand =)
12:28:39 <glguy> crazy linux users :-p
12:28:47 <benja_> perhaps better to compile it yourself then?
12:28:51 <glguy> benja_: what library are you refering to?
12:28:55 <benja_> (unfortunately not even edgy has 6.6)
12:29:03 <benja_> glguy: Data.StableName
12:29:09 <titus> benja_: yes, that's what I'd rather do
12:30:05 <gotaku> Not even edgy? Isn't edgy the current one?
12:30:12 <benja_> it is
12:30:17 <gotaku> I don't use ubuntu anymore.
12:30:20 <benja_> only the development version (feisty) has it
12:30:30 <glguy> @version
12:30:31 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
12:30:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:30:39 <glguy> OpenBSD ftw ;)
12:30:41 <benja_> oh, then again I don't know whether backports has it
12:31:04 <titus> I don't think so
12:31:22 <glguy> and vim is best
12:31:48 <gotaku> Bsd's problem is that it doesn't have a cute logo.
12:32:24 <glguy> netbsd and freebsd have decent logos
12:32:29 <glguy> I'll admit that I don't like openbsd's
12:32:32 <nominolo> ?djinn (a->b->c) -> ([a] -> [b] -> [c])
12:32:33 <lambdabot> -- f cannot be realized.
12:32:53 <glguy> ?type zipWith
12:32:55 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
12:33:10 <nominolo> i'm looking for a generalization
12:33:29 <nominolo> ie, a generalized lift
12:33:34 <glguy> ?type liftM2
12:33:36 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:34:07 <nominolo> ?type liftM3
12:34:09 <lambdabot> forall r (m :: * -> *) a3 a2 a1. (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:34:13 <nominolo> ah, nice
12:34:19 <nominolo> thanks
12:34:24 <glguy> that doesn't do what zipWith does
12:34:42 <glguy> > liftM2 (,) [1,2,3] [4,5,6]
12:34:43 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
12:34:44 <nominolo> yup
12:34:48 <glguy> > zipWith (,) [1,2,3] [4,5,6]
12:34:50 <lambdabot>  [(1,4),(2,5),(3,6)]
12:35:07 <nominolo> i was just using [] as a something of kind * -> *
12:35:21 <glguy> ah
12:36:23 <nominolo> but this zip2, zip3, zip4, ... stuff is really annoying.  are there any suggestions for making haskell "a little bit more dependently typed"?
12:38:57 <benja_> nominolo: you could use a type class
12:38:58 <nominolo> maybe using generics?
12:39:52 <nominolo> yes, but i'd rather have it contain only one lift function instead of lift1, lift2, lift3, ...
12:40:10 <benja_> no, I mean a type class for the tuples
12:41:07 <benja_> or the zip function, actually. *tries to work it out*
12:41:38 <benja_> class Zip a where zip' :: a
12:41:42 <nominolo> you mean like instance MyClass (a) where ...  and instance MyClass (a,b) ..., etc
12:41:56 <benja_> instance Zip ([a] -> [b] -> (a,b)) where zip' = zip
12:42:06 <benja_> instance Zip ([a] -> [b] -> [c] -> (a,b,c)) where zip' = zip3
12:42:07 <benja_> ...
12:42:35 <nominolo> hm, k. let's see if that'll work for my particular problem
12:43:21 <benja_> of course then (zip' [1,2,3] "abc") is overloaded -- it's both of type [(Int,Char)] and of type [a] -> [(Int,Char,a)]
12:43:37 <benja_> to fix that, you could make it
12:44:00 <benja_> instance Zip ([a] -> [b] -> () -> [(a,b)]) where ...
12:44:05 <benja_> instance Zip ([a] -> [b] -> [c] -> () -> [(a,b,c)]) where ...
12:44:09 <benja_> and call as
12:44:18 <benja_> zip' [1,2,3] "abc" ()
12:44:39 <benja_> (or make a new type if you don't like using ())
12:57:23 <zem> g'day
12:58:41 <zdiles> Hi zem.
13:02:04 <zdiles> Greetings all, I'm trying to compile LambadaBot for local use and am having trouble at the configure stage, when I enter "./Setup.hs configure" it performs a list of configurations and ends with "Setup.hs: cannot satisfy dependency network-any" any idea how I go about filling this dependency?
13:02:05 <abz> ?doc Control.Exception
13:02:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
13:03:06 <allbery_b> zdiles: depends on your distribution, on debian it's the libghc6-network-dev package IIRC
13:03:42 <allbery_b> if you're using the tarball from the ghc download page, go back and install the extralibs tarball
13:05:02 <zdiles> allbery_b: Thanks, I thought that I had, I'll doubleback and give it another shot.
13:08:58 <kolmodin> dons: lambdabot patch in your mailbox, ?unmtl related
13:09:07 <kolmodin> good night haskellers!
13:09:21 <glguy> ?unmtl Cont a b
13:09:22 <lambdabot> (b -> a) -> a
13:09:51 <glguy> ?unmtl ContT a (Cont b) c
13:09:52 <lambdabot> (c -> (a -> b) -> b) -> (a -> b) -> b
13:11:37 <kolmodin> makes it quite easy to shoot off your leg.. :)
13:12:10 <zdiles> allbery_b: There doesn't seem to be any unified installation point for extralibs, I can't imagine that I'm just supposed to drop it in the imports folder.
13:12:10 <Vq^> @. unpl pl \(x,_) (y,_) -> compare x y
13:12:11 <lambdabot> (\ g -> (\ s _ -> compare (fst g) (fst s)) >>= \ x -> snd >>= \ w -> return (x w))
13:12:33 <glguy> comparing f x y = f x `compare` f y
13:12:33 <Botje> ehh. what?
13:13:14 <glguy> ?type let comparing f x y = f x `compare` f y in comparing fst
13:13:16 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
13:13:52 <allbery_b> zdiles: wait.  how did you initially install ghc?
13:14:43 <zdiles> albery_b: Initially from the source tarball, I'm on a debian system without admin access so installing in my home dir.  I just upgraded from 6.4.
13:15:17 <allbery_b> ah.  using the source, you need to install extralibs on top of the ghc source tree *before* building it
13:16:03 <zdiles> allbery_b: So if I download the source tree, then drop extralibs on top and just do the normal make process it should workout correctly?
13:16:15 <allbery_b> you might be better getting the .tar.gz binary distribution, which you can configure to install under $HOME
13:16:25 <allbery_b> yes
13:16:42 <zdiles> allbery_b: Not a bad idea, I'll give it a try and see how I fare.
13:21:01 <gotaku> That's strange... the debian ghc hopengl package doesn't seem to install the required X libraries.
13:21:48 <monochrom> eh!
13:59:58 <dons> morning
14:00:26 <Igloo> Yo
14:00:29 <dons> oh, we've climbed another rung on the shootout.
14:00:36 <dons> now we beat java and sml for raw speed
14:00:49 <Igloo> You should sleep more often. Everytime you wake up I find Haskell is faster.
14:00:51 <dons> though the hash table is so slow
14:01:33 <Igloo> Data.HashTable, or something in the code?
14:01:38 <dons> yeah, Data.HashTable
14:01:51 <dons> I did my best, but it just won't inline, and looks pretty slow to me anyway
14:01:57 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=ghc&id=6
14:02:00 <dons> memory use is good though
14:02:01 <lambdabot> Title: k-nucleotide Haskell GHC #6 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4  ..., http://tinyurl.com/27mhjd
14:02:23 <dons> we should just steal whatever it is that Clean is using
14:02:59 <dons> oh, they roll their own
14:03:00 <dons> hmm
14:03:14 <dons> maybe i could do that.
14:03:30 <dons> it'd be specialised to bytestrings, so might actually perform
14:03:39 <Igloo> It would be interesting to know if the problem is the extra generality of D.H, or if it's just slow
14:03:43 <Heffalump> how mature is cabal-install these days?
14:04:02 <mbishop> nomaware is down again :/
14:04:13 * Igloo has never tried to use cabal-install, but I'm told it works
14:04:22 <dons> Igloo: well, it doesn't inline anything, and the update function can't be unboxed
14:04:46 <dons> Heffalump: it could be made mature, but its not yet in wide use (or any use?)
14:04:49 <Igloo> dons: DYM it doesn't have INLINE pragmas, or that nothing gets inlined?
14:04:55 <dons> right.
14:05:10 <Igloo> dons: Which did you mean?  :-)
14:05:14 <dons> you can strictify a HashTable arg, and it is unwrapped to 3 functions and the hash itself
14:05:21 <Igloo> Actually there are a couple
14:05:24 <dons> those functions should be unboxed though
14:05:42 <dons> all the overhead, anyway, is in lookup and update
14:05:46 <Igloo> But lots of the functions look small enough I'd have thought GHC would inline them itself
14:05:51 <dons> 70% of the work. so i think its also just slow
14:06:00 <Igloo> Oh, but bigger things get inlined into them
14:06:08 <dons> considering that it is almost on par with ruby ;)
14:06:47 <dons> chris did a quick binding to a very basic C hashtable, over the ffi, and it runs 4x the C program, instead of 20
14:06:52 <Igloo> Hmm, should update really be using a let there? Isn't it all strict?
14:07:34 <dons> looks bad
14:08:34 <dons> mm. maybe I should file a bug report, just to note that it needs work
14:08:42 <dons> even if its me who'll have to fix it :)
14:08:47 <Igloo> :-)
14:09:53 <dons> I bet if I reimplement the simmple hash in the Clean entry, it'll run faster.
14:13:13 <vincenz> dumdumdum
14:13:36 <Heffalump> dons: well, I'm thinking of using it.
14:14:45 <dons> Heffalump: have a go. report a bug/send a patch, if it doesn't do what it should
14:19:56 <Vq^> @karma+ glguy
14:19:57 <lambdabot> glguy's karma raised to 48.
14:20:08 <glguy> hurrah!
14:20:23 * TuringTest waves
14:20:41 <Vq^> glguy: that comparing trick was great :)
14:20:48 <dons> hey TuringTest
14:20:59 <dons> TuringTest: two questions/points to discuss..
14:21:04 <TuringTest> Okay
14:21:17 <dons> one, I updated the hashtable/knuc benchmark, http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=ghc&id=6
14:21:20 <lambdabot> Title: k-nucleotide Haskell GHC #6 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4  ..., http://tinyurl.com/27mhjd
14:21:22 <dons> but HashTable still sucks :/
14:21:49 <dons> two,want to write a comparative regex-dna entry using your nice shiny libraries?
14:21:53 <TuringTest> I wrote a simple c hash table to FFI into Haskell and it was much much uber faster.
14:21:59 <TuringTest> (on that benchmark)
14:22:03 <dons> yeah i know
14:22:12 <dons> note that clean just implements the simple C one directly
14:22:15 <dons> so i'm going to do that
14:22:37 <dons> i've updated almost all the entries to use bang-patterns and bytestrings now
14:22:48 <dons> cept regex-dna, nbody, spectral-norm
14:23:03 <TuringTest> dons: My wrappers for regex-posix replacements are not included with GHC-base.
14:23:04 <DapperDan2> what does $ (dollar) mean in haskell syntax? and where should i look to not ask stupid questions. example: sresult 200 $ result
14:23:22 <dons> TuringTest: yeah, so we only have posix + bytestrings in the core libs?
14:23:27 <dons> ?src ($)
14:23:28 <Igloo> That $ is redundant
14:23:28 <lambdabot> f $ x = f x
14:23:38 <gotaku> dons: Did I tell you that the mandelbrot shootout entry actually works for all input sizes?
14:23:42 <TuringTest> dons: Correct.  The base minimum for GHC itself to work.
14:23:49 <Igloo> f x $ g y = f x (g y), for example
14:23:53 <dons> gotaku: yours? is it faster?
14:24:06 <dons> TuringTest: but is the TRE lib much better?
14:24:18 <DapperDan2> Igloo: necessary in this? : put $ WikiState $ M.insert pagename (lookS 600 rq "contentstring") pages
14:24:21 <TuringTest> dons: TRE is buggy -- QuickCheck killed it
14:24:28 <Igloo> DapperDan2: Yup
14:24:33 <DapperDan2> code is comming from http://www.scannedinavian.com/~shae/happswiki/wiki.hs
14:24:37 <TuringTest> The maintainer / author is looking into some of the bugs, but is very busy.
14:24:38 <dons> i'd like a decent regex lib in the core libs.
14:24:42 <DapperDan2> i'm just trying to understand it
14:24:42 <dons> ah ok
14:24:51 <dons> so you caught a bug in tre.c or what have you?
14:24:56 <Igloo> DapperDan2: It's used to avoid loads of parentheses, e.g. put (WikiState ( M.insert pagename (lookS 600 rq "contentstring") pages))
14:25:06 <gotaku> dons: Yes, the one I submitted awhile ago. Turns out that all the inputs for the test are divisible by 8 so my padding the bytes to fit the format is not needed.
14:25:10 <dons> TuringTest: maybe pcre would be more sensible.
14:25:14 <TuringTest> dons: I never read any source for TRE.  I just tested it...
14:25:16 <dons> gotaku: oh!
14:25:23 <dons> gotaku: but your entry hasn't appeared on the shootout
14:25:33 <DapperDan2> thanks Igloo.
14:25:35 <dons> gotaku: which means that I think it go dropped in the ghc 6.6 update
14:25:43 <dons> gotaku: do you know what happened to it?
14:25:43 <Igloo> DapperDan2: It's just function application, but lowest precedence and infixr, unlike juxtaposition which is highest precedence and infixl
14:25:44 <TuringTest> dons: regex-tdfa will replace regex-posix using pure Haskell (and methods from thesis of author of TRE).
14:25:47 <gotaku> dons: It's mandelbrot GHC #3
14:25:58 <Cale> I wish $ was infixl
14:25:59 <TuringTest> dons: But for speed benchmarks we want regex-pcre wrapper
14:25:59 <dons> TuringTest: ah, and its much faster?
14:26:05 <dons> ok
14:26:16 <dons> can we distribute pcre.{ch}
14:26:17 <TuringTest> dons: Anything is much faster than regex-posix.  It is slower than libtre.
14:26:26 <TuringTest> pcre is BSD
14:26:31 <TuringTest> (the c lib)
14:26:49 <gotaku> http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&id=3
14:26:51 <lambdabot> Title: mandelbrot Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Co ..., http://tinyurl.com/39svnz
14:27:09 <dons> gotaku: ah
14:27:13 <dons> very good
14:27:18 <dons> but can we do better?
14:27:24 <dons> I think it should be possible
14:27:31 <gotaku> dons: Yes.
14:27:43 <DapperDan2> Igloo: I only thought to search on hoogle after asking, and it worked perfectly, I just typed in $ and it linked me to the the Prelude API documentation.
14:27:58 <DapperDan2> pretty cool, i wouldn't have expected that to work.
14:28:07 <gotaku> dons: I made a new one that changes some things but I'm still not happy with it. It is slightly faster though.
14:28:24 <dons> TuringTest: you can see here which benchmarks haven't been updated, basically the ones where clean wins: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=clean
14:28:26 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2aslsn
14:28:32 <xerox> gotaku: what does it output?
14:28:33 <dons> gotaku: hmm, but i think it should be possible to go much much faster
14:28:48 <dons> we should be aiming at Clean-like speed. if we can't , its a ghc bug of some kind
14:28:58 <TuringTest> dons: ok
14:29:05 <xerox> Clean is really fast?
14:29:13 <gotaku> xerox: What does what output?
14:29:18 <dons> its pure and lazy, so ghc should be the same speed
14:29:19 <xerox> gotaku: the program
14:29:27 <dons> it seems to be, 'cept for the mandelbrot problem
14:29:31 <dons> and the HashTable problem
14:29:37 <xerox> I see
14:29:48 <xerox> gotaku: is that a pbm?
14:29:52 <dons> and the regex dna problem
14:29:59 <dons> those 3 need fixing
14:30:14 <TuringTest> dons: and spectral-norm?
14:30:28 <dons> oh yeah
14:30:28 <gotaku> xerox: Yeah, P4
14:30:32 <Cale> xerox: Clean has uniqueness types, which help the compiler know when it's safe to reuse allocated space for something else.
14:30:33 <dons> another numerics one
14:30:44 <xerox> Saizan has got a PBM Binary instance
14:31:10 <xerox> Cale: I didn't know it had a good compiler.
14:31:20 <dons> bug ghc runs between 2x faster and 2x slower than Clean for everything else
14:31:26 <dons> so that's good.
14:31:35 <xerox> Yeah.
14:32:08 <sjanssen> dons: has anyone tried a solution that uses Data.Map instead of Data.HashTable?
14:32:16 <dons> sjanssen: haven't tried it yet.
14:32:20 <dons> it'd be worth doing
14:32:22 <Cale> Data.HashTable is ugly.
14:32:22 <sjanssen> maybe even Data.IntMap
14:32:40 <dons> just using the current working entry, then port it to Map
14:32:51 <KloBass> hi
14:32:55 <dons> (the current entry is very clever about not encoding the length in any string)
14:32:58 <quicksil1er> Cale: why do you wish $ was left associative?
14:33:01 <dons> hey KloBass
14:33:18 <dons> sjanssen: want to help finish off these last hard problems?
14:33:26 <TuringTest> sjanssen: The shooutout spec is very specific about it :"define a procedure/function to update a hashtable of k-nucleotide keys and count values,"
14:33:28 <hpaste>  gotaku pasted "modified mandelbrot" at http://hpaste.org/329
14:33:36 <dons> nbody,spec-norm,regex-dna and knuch. also fannkuch could be updated
14:33:42 <Cale> quicksil1er: because people abuse it when they really want composition (.), and it would allow removal of certain parens which can't be removed presently.
14:33:44 <dons> TuringTest: though Maps have been accepted in the past
14:33:46 <KloBass> i have q : is f x y = g ( g x y ) equal to f = (.) g .g ???
14:33:47 <dons> just not Tries
14:33:48 <sjanssen> TuringTest: true.  hashtable is even in bold
14:34:16 <Cale> @pl f x y = g (g x y)
14:34:16 <lambdabot> f = (g .) . g
14:34:19 <gotaku> That's my modified version though like I said, I'm still not happy with it.
14:34:23 <Cale> KloBass: yes
14:34:23 <dons> we should have a ByteString Trie lib, and just call it Data.Hash ;)
14:34:28 <quicksil1er> Cale: you mean, current uses of $ could in  many cases be replace (.) and one single pair of parens, whilst a left-assoc $ would help in other cases?
14:34:34 * monochrom agrees with dons
14:34:42 <Cale> quicksil1er: or (.) and a single ($)
14:34:44 <Cale> yeah
14:34:44 <quicksil1er> s/replace/replaced by/
14:34:45 * quicksil1er nods
14:34:49 <KloBass> Cale: oooo mighty bot :)
14:34:52 <Cale> a (b c) (d e)
14:34:56 <Cale> for instance
14:35:01 <Cale> a $ b c $ d e
14:35:01 <vincenz> $ has some nifty uses
14:35:08 <Cale> that would be nice
14:35:15 <vincenz> > map ($1) [(+1),(+2)]
14:35:17 <lambdabot>  [2,3]
14:35:26 <vincenz> > let double x = x * 2 in map ($1) [(+1),(+2), double]
14:35:28 <lambdabot>  [2,3,2]
14:35:32 <quicksil1er> vincenz: that would work just as well if it was left assoc
14:35:33 <Cale> also, $! should be left associative, because its present right associativity is *really* irritating.
14:35:42 <vincenz> quicksil1er: point taken
14:36:01 <dons> ?check \g x y -> g ( g x y ) == ((g .) . (g :: Int -> Int)) x y
14:36:03 <lambdabot>  Couldn't match `Int' against `t -> Int'
14:36:11 <quicksil1er> Cale: but, equally, they should be consistent? *nod*
14:36:13 <vincenz> dons: g is multi-arged
14:36:14 <Cale> You end up awkwardly parenthesizing things just to apply multiple parameters strictly.
14:36:18 <Cale> yes
14:36:25 <vincenz> dons: g x y ...
14:36:42 <vincenz> @check \g x y -> g (g x y) == ((g .) . (g :: Int -> Int -> Int)) x y
14:36:43 <lambdabot>   add an instance declaration for (Eq (Int -> Int))     In a lambda abstracti...
14:36:47 <Cale> Some people have suggested that we should have left-associative variants, but there are only so many symbol characters to go around.
14:36:55 <vincenz> Cale: let's take the euro
14:37:02 <quicksil1er> on the other hand, hard to deprecate a widely used operator
14:37:03 <Cale> hehe :)
14:37:05 <dons> you need an extra param to apply to
14:37:07 <vincenz> dollar is for right-wingers, euro for left-wingers :P
14:37:13 <NichardRixon> :D
14:37:19 <vincenz> dons: how does generation of g work tho?
14:37:24 <Cale> Well, that's why I tell people not to abuse $ for composition
14:37:25 <dons> cleverly
14:37:28 <vincenz> @check \g x y z -> g (g x y) z == ((g .) . (g :: Int -> Int -> Int)) x y z
14:37:30 <lambdabot>  OK, passed 500 tests.
14:37:33 <vincenz> dons: and how would that be?
14:37:38 <Cale> Hopefully if enough people fail to abuse it, changing it at some point won't be so bad.
14:37:45 <dons> in a cunning manner
14:37:50 <dons> (see the coarbitrary method)
14:37:55 <KloBass> @help
14:37:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:38:01 <vincenz> @src coarbitrary
14:38:02 <KloBass> @list
14:38:02 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:38:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:38:10 <bd_> coarbitrary scares me :(
14:38:24 <dons> scares me too
14:38:47 <gotaku> I don't know what it means, so I'm not scared.
14:39:11 <dons> so where's the new mandelbrot, gotaku ? i'm keen to update it
14:39:39 <bd_> dons: Does e.g., instance Gen (Int -> Int) have a coarbitrary, even?
14:39:42 <dons> any program that is slower than lisp either needs updating to bytestrings, or a bug reported to ghc HQ, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=sbcl
14:39:43 <Cale> ((g .) . g) x y z = ((g .) (g x)) y z = (g . (g x)) y z = g (g x y) z
14:39:45 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/27u4hk
14:40:26 <dons> instance (Arbitrary a, Arbitrary b) => Arbitrary (a -> b) where
14:40:26 <dons>   arbitrary         = promote (`coarbitrary` arbitrary)
14:40:26 <dons>   coarbitrary f gen = arbitrary >>= ((`coarbitrary` gen) . f)
14:40:29 <dons> :)
14:40:47 <dons> ?pl coarbitrary f gen = arbitrary >>= ((`coarbitrary` gen) . f)
14:40:48 <lambdabot> coarbitrary = fix ((((arbitrary >>=) .) .) . flip . ((.) .) . flip)
14:40:55 <gotaku> dons: I don't have a new program... just a slightly better one, maybe.
14:41:15 <dons> ah ok. submit submit! the push is on!
14:41:22 <xerox> dons O_O
14:41:35 <dons> i want to catch Clean for speed by the end of the week
14:41:46 <dons> or else have a todo/bug filed away for that library
14:42:32 <siti> wow dons, you're a performance legend ;)
14:42:34 <xerox> Good luck
14:43:23 <oklopol> i've been here for 26 hours and there hasn't been one damn moment of silence 8|
14:43:48 <siti> oklopol: well look at how many people are in this room :P
14:44:01 <sjanssen> #haskell never seeps
14:44:23 <siti> sleeps* :P
14:44:24 <pejo> sjanssen, only misses out on etters?
14:44:25 <Cale> There are people here from every part of the world, and some of us don't get much sleep.
14:44:37 <gotaku> dons: The whole mandelbrot program will need to be redone I think. A slight change won't make a difference.
14:44:49 <Cale> The sun never sets on #haskell.
14:44:52 <oklopol> siti true but i've still never seen a channel without 10 minutes of silence here and there...
14:44:58 * sjanssen means what he wrote.  #haskell does not leak
14:45:01 <sjanssen> :)
14:45:12 <rahikkala> Still, at least the activity is sane and you can always follow the discussion easily when you're around
14:45:39 <rahikkala> Some of the more tech-supporty channels scroll by so fast with all the questions sometimes that it's impossible to discuss anything there
14:45:52 <oklopol> i can't, i don't know this lang that well :\
14:46:26 <Cale> There was a 10 minute silence back around 15:40 EST.
14:46:42 <yaarg> nobody said anything between 13:01 - 13:21 (GMT) :)
14:47:09 <oklopol> i knew you'd correct me, should've checked more thoroughly :P
14:47:13 <Cale> hehe
14:47:22 <Cale> But you're right, it's quite chattery.
14:47:43 <yaarg> ;-)
14:48:01 <yaarg> but yeah active channel never the less
14:48:06 <oklopol> except when this thread dies... i bet there's nothing to talk about after this!
14:48:11 <Cale> oklopol: I learned haskell by lurking here and stealing other people's homework assignments for myself.
14:48:17 <oklopol> :p
14:49:00 <oklopol> i've done c++ mainly, haskell is quite different
14:49:20 <Cale> For sure
14:49:31 <oklopol> maybe i'll catch on by glancing every other hour
14:49:32 <oklopol> :D
14:49:34 <Cale> It's basically like learning to program all over again :)
14:49:46 * zem seems to be learning haskell by getting lost in a twisty little maze of monads all alike
14:50:14 <oklopol> basically i'm in the wtf-are-monads phase
14:50:41 <oklopol> maybe i'll read this whole log and learn haskell from that
14:53:09 <gotaku> I'm starting to learn monads and I think that when someone says that they don't know what monads are, they really mean they don't know how to use certain monads.
14:55:14 <TuringTest> dons: Question about regex-dna and ByteStrings.  We need to use a regexp to search/delete the comment lines and the newline characters.  Is there a Lazy-bytestring trick for punching holes in a chunk to make many smaller chunks or a new chunk?
14:56:57 <dons> yeah, lazy bytestrings would be better.
14:57:07 <dons> you can always generate a lazy bytestring by breaking up a strict one into a list
14:57:17 <dons> so zero-copying
14:57:32 <dons> and the resulting list of strict chunks can be written out with lazy bytestring ops
15:00:30 <gotaku> Are band patterns new?
15:00:34 <gotaku> bang patterns.
15:01:55 <monochrom> yes
15:02:17 <norpan> they were invented at bang camp
15:02:46 <TuringTest> dons: I have that compiling....
15:03:29 <mbishop> one time, at ! camp...
15:03:35 <norpan> exactly
15:06:18 <monochrom> Oh, yeah gotaku, no one ever really needs to know "what is ___".  Philosophical question anyway.  The important thing is what are its properties and how to use.
15:06:48 <monochrom> Consider for example putting "life" into that ___.
15:08:02 <gotaku> Instead of writting tutorials about monads, the tutorials should really be able using State, Reader, Error, etc.
15:08:28 <notsmack> that doesn't help with the question of when to write a monad.
15:08:28 <monochrom> Even if you put "computer" there, I assure you 99% of the programmers don't know the answer.  But since when did they care?
15:08:29 <gotaku> "be about" rather.
15:09:10 <dons> gotaku: yeah, i think mandelbrot needs rewriting
15:09:23 <gotaku> notsmack, I don't think you should worry about writing monads until you know how the standard ones are used.
15:09:42 <monochrom> "when" is an advanced topic.
15:09:42 <dons> sorear rolled a quick mandelbrot inner loop
15:10:37 <monochrom> "when" is also better answered by becoming an apprentice of someone who knows.
15:10:45 <gotaku> dons: Where is it?
15:10:53 <sorear> tell fodder
15:11:08 <dons> sorear: can you show gotaku the fast mandelbrot inner loop code you paste on hpaste?
15:11:20 <sorear> er, ok...
15:11:44 * dons forks a sorear thread
15:12:01 * monochrom joins threads
15:12:15 <norpan> i'm confused
15:12:23 <sorear> http://hpaste.org/158#a5
15:12:31 <dons> gotaku: ^^
15:12:35 <dons> might have some ideas
15:12:53 <sorear> what, is someone else trying to optimize a mandlebrot?
15:13:02 <dons> to update the shootout entry
15:13:21 <dons> here, you can see what needs working on, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=sbcl
15:13:23 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/27u4hk
15:13:26 <dons> anything that's slower than sip
15:13:29 <dons> lisp.
15:13:29 <sorear> dons: btw: I think I've figured out a solution to the abstraction/performence problem wrt vty (yay)
15:13:37 <dons> yay!
15:14:03 <sorear> gotaku: warning!
15:14:12 <sorear> gotaku: I manually unrolled a loop
15:15:48 <siti> is there a substring like function in haskell?
15:15:48 <sorear> oh, lots of patches in ghc today
15:16:03 <sorear> no, but it's easy enough to do it yourself
15:16:10 <dons> siti for bytestrings, yeah. easy enough to do yourself for String
15:16:10 <siti> or strncmp?
15:16:21 <sorear> > take 5 . drop 5 $ "Hello, World!  This good enough?"
15:16:23 <lambdabot>  ", Wor"
15:16:28 <siti> yeah, I just didn't want to reinvent the wheel :p
15:16:33 <dons> `compare`
15:16:35 <sorear> dons: where is bytestring substr?
15:16:41 <dons> > "woo" `compare` "foo"
15:16:43 <lambdabot>  GT
15:16:44 <sorear> dons: strcmp /= strncmp.
15:16:54 <dons> take/drop :)
15:16:57 <sorear> dons: I know how much you like to forget C :)
15:17:21 <dons> C schmee
15:18:58 <dons> ?where+ hsxwm http://www.golubovsky.org/repos/hsxwm/
15:18:59 <lambdabot> Done.
15:19:51 <monochrom> hey dons, what's that?
15:20:11 * zem wonders what fraction of freenode's #language channels are running a bot written in that language
15:20:35 <dons> monochrom: apparently its a binding to the X protocol, and a demo window manager
15:20:54 <monochrom> Interesting.
15:20:55 <dons> not complete though
15:21:41 <augustss> woo!
15:21:42 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
15:26:14 <sorear> augustss: useful?
15:27:21 <siti> oklopol: it's quiet!!!
15:27:58 <dons> ?yow!
15:27:58 <lambdabot> I want you to MEMORIZE the collected poems of EDNA ST VINCENT MILLAY
15:27:58 <lambdabot> ... BACKWARDS!!
15:28:02 <vincenz> augustss: porque woo?
15:28:46 <gotaku> Can I use hPutBuf to print a [Word32] ?
15:29:09 <bd_> @hoogle Handle -> [Word32] -> IO ()
15:29:10 <lambdabot> No matches, try a more general search
15:29:17 <dons> pack it into a UArray ?
15:29:31 <dons> ah, I know
15:29:34 <dons> binary encode :)
15:29:40 <dons> S.putStr . encode $ xs
15:29:54 <sorear> castIOArray
15:30:01 <sorear> @ty castIOUArray
15:30:03 <lambdabot> Not in scope: `castIOUArray'
15:30:42 <sorear> @ty Data.Array.IO.castIOUArray
15:30:44 <gotaku> encode?
15:30:44 <lambdabot> forall b ix a. Data.Array.IO.Internals.IOUArray ix a -> IO (Data.Array.IO.Internals.IOUArray ix b)
15:30:54 <sorear> gotaku: ^^^
15:31:04 <sorear> it's a raw pointer cast
15:31:27 <dons> gotaku: ah, you have a list of Words to write. hmm.
15:31:44 <dons> getting it into an IOUArray seems the best bet
15:31:54 <dons> otherwise you can bit shift it into a bytestring
15:32:03 <dons> (or rely on endianness to do that for you perhaps)
15:33:57 <gotaku> How would I bit shift into a bytestring? I don't know much about the bytestring library yet.
15:33:58 <augustss> All computers should be little endian!  Big endian is unnatural!  Kill, kill, kill!
15:34:18 <olliej> augustss: ???
15:34:41 <augustss> I prefer little endian. :)
15:35:17 <sorear> augustss: was that link useful?
15:35:56 <augustss> sorear: well, it kinda explained things.  I've not given jhc another try yet
15:36:39 <dons> hmm. i like the sight of all these native codegen patches landing
15:36:47 <dons> in connection with the PAPI stuff
15:37:29 <astrolabe> 'The very term big-endian comes from Jonathan Swift's satiric novel Gulliver’s Travels, where tensions are described in Lilliput and Blefuscu because a faction called the Big-endians prefer to crack open their soft-boiled eggs from the big end, contrary to Lilliputian royal edict.'
15:37:50 <KloBass> @pl f x y = g x . h y
15:37:51 <lambdabot> f = (. h) . (.) . g
15:37:52 <augustss> indeed!
15:38:07 <sorear> ackh! what's a \222 ?
15:38:19 <EvilRanter> KloBass, I think that warrants using the non-pf version O.o
15:38:21 <sorear> looks like a Smart Quote to me
15:38:26 <augustss> I like how Swift transfers so easily to our time.
15:38:48 <astrolabe> augustss: was it you who commented on the turtle and hare algorithm recently?
15:38:57 <augustss> astrolabe: yes
15:39:28 <astrolabe> Do you know of any online papers describing the algorithm in a more general context than lists?
15:39:56 <augustss> ummmmm, no, it was ages ago that i studies this
15:40:12 <astrolabe> augustss: That's fine.  Thanks anyway.
15:40:55 <KloBass> EvilRanter: sorry :) dont know what u mean :) iam just trying to understand point-free :))
15:41:50 <chessguy> greetings, haskellers
15:41:50 <EvilRanter> KloBass, that's fair enough. I mean I hope you don't use the pointsfree in a serious project, because the normal version is infinitely more understandable to us mere humans
15:41:58 <Daveman> Hey chessguy :)
15:42:00 <Daveman> \o/
15:42:09 <gotaku> dons: Is there a way to efficiently build a bytestring from single bits?
15:42:10 <chessguy> Daveman, :)
15:42:16 <vincenz> o/\
15:42:31 <augustss> astrolabe: but googling finite state machine equivalence should give some good hit
15:42:32 <KloBass> EvilRanter: no it is serious exam :D
15:42:46 <KloBass> sad0ur: ahoj
15:42:53 * astrolabe googles
15:43:06 <chessguy> hmm, shapr's not in #haskell these days?
15:43:38 <EvilRanter> I see.
15:43:39 <dons> gotaku: from a stream of bits? there is, but its best done in a library. or use , say, unfoldrN (or a loop)
15:43:55 <dons> gotaku: you could do a draft, and i could write the bytestring packing code
15:45:53 <gotaku> unfoldrN?
15:46:07 <sorear> yep
15:46:14 <sorear> it's kinda like strncpy
15:46:22 <sorear> it sets a maximum length
15:46:30 <sorear> since ByteString uses malloc,
15:46:38 <dons> no it doesn't :)
15:46:46 <dons> but it does allocate buffers strictly
15:46:49 <sorear> it needs to know the maximum length a priori
15:47:11 <dons> its ghc's storage manager, not malloc
15:47:29 <gotaku> I can find any docs on unfoldrN
15:47:49 <chessguy> ?hoogle unfoldrN
15:47:50 <lambdabot> No matches found
15:48:00 <sorear> well it's called malloc :)
15:48:02 <mosch> Can anybody help me build ghc on freebsd-amd64?
15:48:09 <sjanssen> unfoldrN is mainly used for Data.ByteString.Lazy's unfoldr
15:48:14 <sorear> chessguy: Data.ByteString.Base
15:48:34 <sorear> er no
15:48:37 <dons> sorear: nope, its in Data.ByteString
15:48:53 <chessguy> ?doc Data.ByteString
15:48:53 <lambdabot> Data.ByteString not available
15:48:57 <sorear> @index unfoldrN
15:48:58 <lambdabot> bzzt
15:49:02 <dons> @docs Data.List
15:49:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:49:10 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
15:49:11 <sorear> @docs GHC.List
15:49:12 <lambdabot> http://tinyurl.com/wn5rt
15:49:12 <lambdabot> GHC.List not available
15:49:31 <chessguy> @slap herself
15:49:32 * lambdabot beats up herself
15:50:24 <chessguy> well, that was a conversation-stopper
15:50:27 <monochrom> woah!
15:50:49 <augustss> @slap chessguy
15:50:50 <lambdabot> why on earth would I slap chessguy
15:50:55 <monochrom> haha!
15:50:58 * chessguy grins
15:51:15 <chessguy> @karma chessguy
15:51:16 <lambdabot> You have a karma of 4
15:51:32 <augustss> @karma augustss
15:51:33 <lambdabot> You have a karma of 3
15:51:41 <vincenz> @karma vincenz
15:51:42 <lambdabot> You have a karma of 18
15:51:47 <augustss> guess I've gotta work harder
15:51:49 <chessguy> @slap augustss
15:51:50 <lambdabot> why on earth would I slap augustss
15:51:55 <vincenz> @slap chessguy
15:51:56 * lambdabot beats up chessguy
15:51:57 <sorear> @karma
15:51:58 <lambdabot> You have a karma of 40
15:52:04 <sorear> @karma glg
15:52:05 <vincenz> @karma dons
15:52:05 <lambdabot> glg has a karma of 0
15:52:05 <lambdabot> dons has a karma of 120
15:52:08 <sorear> 40!?!
15:52:10 <vincenz> @karma cale
15:52:10 <lambdabot> cale has a karma of 0
15:52:14 <vincenz> @karma Cale
15:52:15 <lambdabot> Cale has a karma of 40
15:52:17 <sorear> @karma glguy
15:52:18 <lambdabot> glguy has a karma of 48
15:52:19 <chessguy> ooooh
15:52:27 <sorear> @karma audrey
15:52:28 <lambdabot> audrey has a karma of 0
15:52:30 <augustss> @karma lennart
15:52:30 <sorear> @karma audreyt
15:52:31 <lambdabot> lennart has a karma of 4
15:52:31 <lambdabot> audreyt has a karma of 83
15:52:31 <vincenz> @karma Haskell
15:52:32 <lambdabot> Haskell has a karma of 9
15:52:34 <vincenz> @karma haskell
15:52:35 <lambdabot> haskell has a karma of 21
15:52:38 <vincenz> @karma lambdabot
15:52:39 <lambdabot> lambdabot has a karma of 44
15:52:44 <sorear> @karma-all
15:52:45 <lambdabot>  "dons"                120
15:52:45 <lambdabot>  "audreyt"              83
15:52:45 <lambdabot>  "fglock"               52
15:52:45 <lambdabot>  "glguy"                48
15:52:45 <lambdabot>  "lambdabot"            44
15:52:47 <lambdabot> [703 @more lines]
15:52:49 <sorear> @more
15:52:50 <lambdabot>  "dcoutts"              42
15:52:51 <lambdabot>  "Cale"                 40
15:52:53 <lambdabot>  "putter"               40
15:52:55 <lambdabot>  "sorear"               40
15:52:57 <chessguy> who the heck is fglock?
15:52:57 <lambdabot>  "Lemmih"               38
15:52:58 <gotaku> You guys done?
15:52:59 <lambdabot> [698 @more lines]
15:52:59 <augustss> who is fglock?
15:53:08 <sorear> @seen fglock
15:53:08 <lambdabot> I saw fglock leaving #perl6 11h 19m 29s ago, and .
15:53:18 <audreyt> the guy over there in #perl6 that implements the Perl6 VM on top of perl5
15:53:31 <audreyt> in addition to our existing GHC VM
15:53:37 <augustss> hmmm, wonder why has has so much #haskell karma?
15:53:46 <sorear> augustss: @karma is global
15:53:50 <augustss> ah
15:54:03 <EvilRanter> lambdabot watches #perl6?
15:54:23 <augustss> LB is omniscient
15:54:31 <EvilRanter> hunh
15:54:40 <gotaku> dons: I see that unfoldrN produces (ByteString, Maybe a). What is the "Maybe a"  for?
15:54:46 <sorear> @seen Lambdabot
15:54:47 <lambdabot> Yes, I'm here. I'm in #happs, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #
15:54:47 <lambdabot> haskell
15:54:54 <sorear> gotaku: remaining seed?
15:55:41 <gotaku> I guess.
15:56:26 <sjanssen> yes, it is the remaining seed
15:57:43 * augustss curses himself
15:57:53 * sorear blesses augustss
15:58:15 * EvilRanter blinks at his annoying geometry problem, and glares at #math for being completely unhelpful
15:58:22 <EvilRanter> @karma
15:58:22 <lambdabot> You have a karma of 1
15:58:30 <dons> can anyone read this Clean code:   :: HashTable = { table::!.{!Buckets} }
15:58:36 <dons> is that an array of Buckets?
15:58:43 <dons> htNew :: !Int -> *HashTable
15:58:44 <dons> htNew n = { table = createArray nprime EmptyBucket } where
15:58:58 <sorear> gah, that's completely illegible
15:59:00 <dons> !.{ .. } is an array?
15:59:09 <vincenz> {} is prolly a struct
15:59:13 <sorear> do cleaners call haskell illegible? :p
15:59:18 <vincenz> oh !.
15:59:23 <vincenz> that is rather illegible, yes
15:59:32 <augustss> as is haskell
15:59:33 <vincenz> sorear: only the ones that clean with vim
15:59:37 <augustss> or java
15:59:39 <sorear> and what's all these !}{*@=?
15:59:42 <augustss> or snobol
15:59:51 <dons> augustss: can you read Clean? does !.{ } give us an array?
15:59:55 <Igloo> It's presumably a strict .{ } or strict Buckets
15:59:58 <Igloo> s/or/of/
16:00:05 <vincenz> Igloo: why two ! then?
16:00:05 <Axioplase> sorear: that's a perl uniline :)
16:00:08 <vincenz> !.{!...}
16:00:11 <dons> yeah, is .{ } an array though ? :)
16:00:14 <augustss> dons: i can't read clean without a little refresher
16:00:36 <Igloo> vincenz: Because the array is strict, as are the buckets
16:00:37 <dons> vincenz: strict in the elements
16:00:37 <vincenz> you mean refreshener
16:00:41 <sorear> Axioplase: is a uniline some arcane new Perl6 data type?
16:00:46 <dons> e.g
16:00:47 <dons> :: Buckets = EmptyBucket | Bucket !Item | Buckets ![!Item!]
16:00:56 <vincenz> Igloo: right, assuming array syntax cause it's using {} for records as well
16:00:57 <dons> a strict spine of strict elems
16:00:58 <EvilRanter> sorear, yeah, they all print "Just another perl hacker." when evaluated
16:01:03 <vincenz> dons: I know
16:01:06 <Axioplase> sorear: no. uniline is a mistake I just did, thinking about "one-liner"
16:01:18 <dons> ok, i think it has to be magic array syntax
16:01:20 <dons> .{ }
16:01:55 <Igloo> "clean" is an inconvenient language name when you want to google for things about it
16:01:55 <Axioplase> I mean, this !}{*@=? *could* evaluate to something in perl :)
16:02:47 <SamB> Igloo: so is "self"
16:03:02 <dons> and nice
16:03:02 <vincenz> dons: yeah array
16:03:03 <sorear> Igloo: try "happy"
16:03:11 <SamB> happy haskell
16:03:11 <vincenz> dons: {Type} = array
16:03:14 <edwinb> I once googled "Sparkle Clean" without thinking, and got told about domestic cleaners
16:03:19 <sorear> Igloo: google #6 is a "parser generator for haskell"
16:03:20 <dons> erlang and ocaml, however. good names
16:03:22 <Igloo> For happy you can at least put haskell in teh search terms too
16:03:24 <Axioplase> (and it does !  perl -eF '!}{*@=?' )
16:03:32 <dons> vincenz: ah ok.
16:03:33 <dons> cheers
16:03:35 <Igloo> Or do you mean there's a language called happy?
16:04:00 <Igloo> vincenz: What's the . then?
16:04:03 <sorear> nope, meant the lalr preproc
16:04:19 <vincenz> Igloo: not sure
16:04:45 <vincenz> ArrayType = {[ArrayKind] Type}
16:04:49 <vincenz> ArrayKind can be # or !
16:04:53 <vincenz> but then in the examples they use the .
16:04:58 <vincenz> maybe a syntactic delimiter
16:05:01 <vincenz> to enable proper parsing
16:05:12 <vincenz> oh
16:05:17 <vincenz>                                    Arrays are created unique (the * or. attribute in front of the type, see Chapter 4) to
16:05:20 <vincenz> make destructive updates possible.
16:05:25 <TuringTest> dons: Preliminary speed (not quite optimized) of strict bytestring counting for regex-dna (500k file), not doing the replacements yet: PCRE: 15.6 second, my TDFA: 32.3 seconds
16:05:35 <dons> nice!
16:05:39 <vincenz> dons: .{} is a unique array, aka destructively updateable
16:05:44 <dons> yeah
16:06:01 <dons> data Hash   = HT { keysize :: !Int
16:06:01 <dons>                  , table   :: !(IOArray Int Buckets) }
16:06:03 <dons> :)
16:06:12 <TuringTest> I have not optimized my ByteString code recently, so it will get a bit better.  Unfortunately I cannot load the TDFA code into the shootout.
16:06:21 <dons> right
16:06:27 <vincenz> heh
16:06:29 <sorear> too long? licenses?
16:06:35 <dons> sorear: not in the core libs
16:06:38 <vincenz> they differentiate between strict and unboxed types....
16:06:44 <vincenz> {!Int} = array of strict ints
16:06:48 <TuringTest> the regex-posix code is impossibly slow (killed after 3 minutes of no output).
16:06:49 <vincenz> {#Int} = array of unboxed ints
16:06:56 <dons> sorear: if we ask really nicely, we might be able to get it put on
16:07:06 <sorear> dons: I meant inline.
16:07:17 <dons> ie.. if turing test had a simple, low-dependency regex package
16:07:25 <dons> i might be able to ask isaac gouy to install it
16:07:53 <vincenz> TuringTest: but erm...it's slower than PCRE?
16:08:01 <sorear> as in, (too long? licenses?) referred to the tdfa code itself.
16:08:30 <TuringTest> vincenz: PCRE is a tuned C library.  TDFA is my pure Haskell code.
16:08:35 <dons> hey emk, how's code?
16:08:56 <sorear> Does pure mean untuned in this context? :)
16:09:27 <emk> dons: Looking good! I'm getting better at making things go fast.
16:09:33 <dons> cool
16:09:34 <dons> me too!
16:09:51 <dons> we're ahead of SML on the shootout
16:09:58 <dons> and still lots more to improve!
16:09:59 <emk> dons: Glad to hear it!
16:10:00 <SamB> sorear: I don't thik it necessarily does
16:10:08 <vincenz> TuringTest: oh, nice :)
16:10:10 <TuringTest> sorear: A bit untuned
16:10:13 <sorear> is the S in ML even remotely true anymore?
16:10:25 <monochrom> Yes it is true.
16:10:33 <SamB> sorear: I think it means "without abusing the FFI" and possibly "without abusing unsafePerformIO" as well
16:10:48 <emu> standard? yes
16:10:50 <TuringTest> sorear: The size of TDFA's *.hs files is 4021 lines totaling 182902 bytes
16:10:55 <mosch> anybody have any ideas on building ghc on FreeBSD-amd64?  The port is broken, and bootstrapping from source fails on what appear to be autoconf issues.
16:11:03 <emu> SML'97
16:11:04 <sorear> so, we're ahead of SML? even MLton?
16:11:07 <newsham> ?farber
16:11:08 <lambdabot> Unknown command, try @list
16:11:16 <emu> sml/nj isn't always the greatest
16:11:22 <dons> sorear: yeah
16:11:30 <dons> ?shootout
16:11:31 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:11:31 <emu> MLton is whole-program analysis
16:11:41 <sorear> is JHC still better than GHC?
16:11:42 <dons> so is ghc, when you've got enough inlining :)
16:12:04 <Igloo> mosch: There shouldn't be any major problems, but there are a number of small wrinkles that need to be ironed out
16:12:06 <dons> sorear: i'm not sure its 'better'. some microbenchmarks reported onthe mailing list were faster
16:12:10 <TuringTest> sorear: GHC beat MLton barely (when just shootout CPU is considered)
16:12:21 <augustss> S in SML is as true as 98 in Haskell98
16:12:33 <emu> MLton probably makes program size explode
16:12:40 <mosch> Igloo: as it stands, the problem seems to be that the autoconf files don't quite understand what amd64-unknown-freebsd is
16:12:49 <emu> the S is even more true, since there is a published denotational semantics
16:12:53 <mosch> it seems like it would likely build, if I could get them all in a row
16:13:29 <Igloo> mosch: You can fix that just by adding it to configure.ac in the obvious place and then rerunning autoreconf
16:13:39 <augustss> "standard" = "published denotational semantics" ?
16:13:53 <emu> no
16:14:06 <emu> just "more so" for some concocted relation "more so"
16:14:19 <mbishop> I wonder if there will be an update to SML97
16:14:31 <augustss> does the standard interpretation of quantum mechanics have a publish denotational semantics? :)
16:14:46 <emu> if that were true, only scheme and sml would have standards oO
16:15:01 <augustss> Almost Ada
16:15:15 <sorear> does the standard notation for denotational semantics have itself denotational semantics?
16:15:22 <SamB> sorear: heh
16:15:28 <monochrom> heehehehe
16:15:28 <emu> so which test does ghc do poorly on?
16:15:34 <SamB> it probably has connotational semantics or something
16:16:03 <trurl> mbishop: there is "successor ml", but it seems that only a handful of people care about it
16:16:18 <monochrom> it's a bad name.
16:16:22 <emu> ghc isn't using byte-string
16:16:25 <augustss> haven't heard much about ML3000 lately
16:16:50 <mbishop> Well I think ocaml has usurped SML's userbase anyway
16:17:00 <augustss> it has
16:17:07 <emu> not the hard-core academics
16:17:52 <emu> (isn't it great when a language's audience is only academics?)
16:18:21 <SamB> yeah, isn't it?
16:18:40 <augustss> oh, like haskell used to be?
16:18:41 <emu> ha, someone did submit a bytestring version of sum-file, and it smokes everyone.
16:19:03 <sorear> dons
16:19:09 <emu> however that sumamry is using the h98 string version which is dead last
16:19:17 <monochrom> I like it best when the audience is only educated programmers.
16:19:22 <sorear> me too.
16:19:42 <augustss> it has advantages
16:20:05 * sorear is hoping Jhc will avoid consuming all memory, now that it has an RSS limit set at 90%
16:20:07 <dons> the dead last entry is super naive
16:20:14 <dons> (doesn't even know about 'print' :/
16:20:26 <dons> i asked them to remove it, in favour of GHC #3
16:20:32 <dons> but i think they like to poke fun ;)
16:20:33 <emu> that's pretty impressive though, that it's better tha nC
16:20:38 <emu> good work =)
16:20:47 <emu> are they compiling -fvia-C?
16:20:50 <sorear> is the deadlast one the one liner?
16:20:51 <dons> yeah
16:20:55 <sorear> ?shootout
16:20:56 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:20:58 <dons> its 3 lines, 3 ugly lines
16:21:14 <dons> its very old though, before any haskell people got involved
16:21:21 * monochrom frowns.  Why does the shootout accept dumb entries and reject smart and legal entries?  And after all these years?
16:21:45 <emu> the purpose is to make gcc look good?
16:22:26 <sorear> I'm gonna start my own shootout
16:22:27 <dons> monochrom: they just do what they can. i'm submitting a better 'naive' version now
16:22:40 <emu> there's a naive byte-string version too
16:22:44 <emu> #3 i think
16:22:48 <monochrom> I would not complain at the beginning of this century.
16:22:50 <sorear> no rules, excepty that you must do it in the language you say you do it in
16:23:06 <augustss> How can Lua be above Haskell?
16:23:27 <SamB> shouldn't there also be rules like "don't try to delete the competition"?
16:23:34 <dons> augustss: where?
16:23:51 <augustss> the link above
16:23:52 <emu> memory
16:24:12 <sorear> SamB: oh that's legal.  trying that is.  everything will be sandboxed anyways.
16:24:23 <SamB> heh
16:24:28 <dons> hmm. augustss try 'reset'
16:24:31 <EvilRanter> isn't that gonna turn into corewars?
16:24:36 <emu> i just noticed that the scripting langs came above SBCL, but that's because compilers tend to bloat code and memory use
16:24:45 <EvilRanter> well, corewars with an objective. corewars CTF?
16:24:45 <dons> its not above from what i can see
16:24:54 <dons> 1.0	C gcc 	187.8	1
16:24:54 <dons> 1.1	D Digital Mars 	172.7	
16:25:03 <dons> 1.4OCaml 135.02
16:25:09 <dons> 1.5Haskell GHC 127.51
16:25:12 <SamB> where does MARS come in?
16:25:14 <dons> 1.7Lua 108.8
16:25:37 <augustss> reset helped
16:25:50 <SamB> oh wait, you can't implement these things in redcode can you?
16:26:18 <emu> i found a way to make PHP come in first
16:27:00 <augustss> hmmm, they don't have the intel c compiler?
16:27:01 <sorear> lines of code to serve a one-line webpage? :p
16:27:07 <augustss> it's much better than gcc
16:27:10 <emu> 0 x 0 x 0 multipliers =)
16:27:45 <emu> yae but then they'd have to pay ;). Intel should donate a copy of icc just to look good.
16:28:02 <augustss> yeah
16:28:59 <augustss> intel should give their compiler away anyway.  they are a hardware company
16:29:20 <sorear> it actually seems to have helped
16:29:38 <emu> ghc does pretty well on memory usage actually
16:29:44 <sorear> my system is 1s laggy, not 20s laggy like it was without the rss limit on jhc
16:30:08 <dcoutts> dons, and that super naive one isn't even that short!
16:30:13 <dcoutts> it should use interact
16:30:24 <dcoutts> one liner
16:30:32 <augustss> using multipliers 0,0,1 makes me very unhappy
16:30:51 <emu> nbody test failed to compile because lacking mtl. they need to compile with --make.
16:30:57 <augustss> it shows how complicated the fast haskell programs are
16:31:15 <sorear> dons: "main=interact$show.sum.map read.lines" ftw!!
16:31:16 <Igloo> Or to install it
16:31:26 <gotaku> I'm trying to figure out how to make the mandelbrot program elegant.
16:31:32 <gotaku> Oh, and fast too.
16:31:34 <emu> ah yes, they do -package mtl
16:31:41 <sorear> > length . Codec.Compression.GZip.gzip $ "main=interact$show.sum.map read.lines"
16:31:42 <lambdabot>   Not in scope: `Codec.Compression.GZip.gzip'
16:31:46 <sorear> aww :)
16:32:30 <augustss> sorear: i like that code, but i bet it performs like crap
16:33:19 <sorear> augustss: don't forget the shootout has a gzip category
16:33:34 <gotaku> Anyone know anything about the ghc packages in debain etch? Seems like libxi and libxmu are not dependencies of the ghc glut or opengl packages when they are needed.
16:34:25 * augustss considers switching to Ruby
16:34:43 <emu> try multipliers 1,0,0 ;)
16:34:43 <dcoutts> nooooo!
16:35:10 <dcoutts> augustss, you can't fool us, we know you're not serious :-)
16:35:31 <augustss> Ruby is 1.7 times better than Haskell
16:35:49 <dcoutts> hah, what are you measuring ?
16:36:01 <vincenz> augustss: yes, especially 1.8
16:36:02 <vincenz> oh wait
16:36:06 <vincenz> htat's 5 years old
16:36:27 <dcoutts> oh! version numbers
16:36:28 <dons> http://alioth.debian.org/tracker/index.php?func=detail&aid=304443&group_id=30402&atid=411646
16:36:30 <augustss> dcoutts: just gzipped bytes
16:36:31 <lambdabot> Title: Alioth: The Computer Language Shootout Benchmark: Detail: 304443 naive sum-file  ..., http://tinyurl.com/25mr7h
16:36:33 * dcoutts catches on slowly
16:36:34 <dons> updated naive sum-file
16:36:40 <gotaku> meteor-contest? When did they add that too the shootout?
16:36:41 <dcoutts> dons, ho good
16:36:47 <dons> gotaku: about a month ago
16:36:47 <dcoutts> ho/oh
16:36:56 * dcoutts has cold fingers and can't type
16:37:46 <dcoutts> g'night folks
16:38:03 <EvilRanter> 'night
16:38:38 <SimonRC> I miss the presence of first-class varaibles in Java.
16:39:09 <SimonRC> Haskell, it seems, is also a great imperative language.
16:39:31 <augustss> wowm the Haskell nbody code is immensely ugly
16:39:36 <dons> truly
16:39:58 <dons> for some reason nbody and spectral-norm are really hard to get good performance out of ghc 6.4
16:40:06 <dons> i wonder if this has changed with 6.6
16:40:16 <dons> augustss: lots of numerics in there... feel free to hack!
16:40:27 <augustss> ghc sucks at numerics
16:40:43 <augustss> no hacking until we need it
16:41:14 <dons> a quick fix would be to de-mtl-ise nbody
16:41:18 <dons> at least then it would compile and run
16:41:31 <dons> we'd probably level with ocaml then
16:41:48 <dons> and people could stop sending abusive emails to the lists about shootout performance of ghc
16:41:53 <gotaku> I just noticed the g++ program is beating gcc in the mandelbrot benchmark.
16:41:54 <siti> lol
16:42:03 <dons> well, whinging emails anyway ;)
16:42:06 <gotaku> Oh my... look at the code.
16:42:17 <dons> gotaku: is it sse stuff?
16:42:26 <dons> they could play games with getting at sse instructions
16:42:27 <augustss> I think any haskell program with unsafePerformIO should be banned from the hootout
16:42:28 <gotaku> dons: Yeah
16:42:44 <dons> augustss: heh. but the FFI + unsafePerformIO makes a good ST monad
16:43:03 <dons> with a rich interface
16:43:11 <augustss> If it's good and safe then it belongs in a library
16:43:17 <dons> right.
16:43:25 <Igloo> Are you implying the ST monad doesn't make a good ST monad?
16:43:38 <augustss> any use of unsafePerformIO should at least have an informal proof that it's correct
16:43:43 <dons> Igloo: too restricted. the ffi is a more fun place to do st monad stuff
16:44:20 <augustss> improve ST instead
16:44:37 <augustss> or restrict IO.  IO has far to much stuff in it
16:44:55 <Philippa> unfortunately IO has to have at least the capacity to do everything from it
16:44:57 <SamB> wouldn't it be simply wonderfull if IO couldn't be used for I/O
16:45:14 <sorear> @quote sin.bin
16:45:15 <lambdabot> No quotes match. Do you think like you type?
16:45:47 <dons> a memory-only IO would be useful
16:45:48 <augustss> Philippa: capacity. maybe.  But I think it's misused.  People use IORef&co when STRef would suffice
16:45:50 <dons> i.e. ST on speed
16:46:02 <dons> since i want to call C to do memchr and memcpy
16:46:22 <Philippa> yeah, I agree there
16:46:31 <sorear> dons: then wrap *those* using unsafeIOtoST
16:47:04 <Philippa> thing is, if you insist all ST-ish things be done via ST RealWorld then code that does genuinely belong in the IO monad can get somewhat painful
16:47:23 <sorear> no
16:47:33 <sorear> the *types* get painful
16:47:44 <sorear> but those can be inferred anyway
16:47:48 <TuringTest> dons: I am done for the night.  I have a "has started working" TDFA running the full regex-dna benchmark at 69.48 seconds versus 22.80 seconds for regex-pcre.  It uses a mix of Lazy and Strict ByteStrings.
16:47:57 <Philippa> not just the types
16:48:00 <augustss> I don't think ST RealWorld should ever be used
16:48:07 <dons> TuringTest: ok.
16:48:15 <Philippa> you end up having to interleave a pile of different limited-feature monad calls
16:48:18 <sorear> @src IO
16:48:19 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:48:37 <dons> TuringTest: i'd be interested in seeing what regex-posix could do if we use lazy bytestrings to avoid memcpys
16:48:40 <augustss> And that is just wrong.  IO is an abstract type
16:48:42 <emu> @src RealWorld
16:48:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:48:59 <Philippa> augustss: it's an improvement over IORefs if you want to take advantage of polymorphism without introducing a Ref typeclass
16:49:00 <gotaku> Is there a way to run the shootout benchmark locally?
16:49:05 <emu> no no no i don't call myself a rocket scientist!
16:49:11 <dons> gotaku: you just have to download the files and build them
16:49:18 <TuringTest> dons: regex-posix using bytestrings against the full benchmark does not finish in a sufficiently finite time.
16:49:33 <Philippa> obviously a Ref class is the Right Thing if you can manage to settle on a single class
16:49:49 <augustss> But ST RealWorld assume there is a RealWorld
16:50:06 <sorear> gah
16:50:06 <gotaku> dons: What files? I mean the memory and CPU benchmarks that they use.
16:50:15 <sorear> this is not #philosophy :)
16:50:21 <Philippa> sure. But I don't think it's unreasonable to have that so long as you can only run it from IO
16:50:27 <dons> gotaku: ah, for cpu I just use 'time'
16:50:32 <dons> for memory I use ghc -prof
16:50:37 <Philippa> in which case you at least have a real World or the equivalent thereof
16:50:41 <augustss> sorear: the IO monad can be implemented in ways that don't involve RealWorld
16:51:01 * edwinb doesn't want to know about the RealWorld
16:51:22 * augustss thinks edwinb is wise
16:51:22 <sorear> I know, I mis-interpreted the question
16:51:29 <Philippa> yeah. If you have to deal with the RealWorld you might end up having to deal with a wunch of bankers like I'm going to tomorrow...
16:51:46 <gotaku> dons: Did you ever get around to writing that article on profiling in ghc?
16:52:06 <augustss> bankers don't live in the real world ;)
16:52:15 <Philippa> yeah, this is part of the problem
16:52:22 <augustss> they think the world is about oney
16:52:25 <augustss> money
16:52:32 <Philippa> I need to sort out some corrections on behalf of my housemate/caree
16:52:35 <SamB> wunch of bankers?
16:52:48 <Philippa> SamB: wunch being the plural noun
16:52:55 <Philippa> sorry, collective noun
16:52:59 <SamB> @all-dict wunch
16:53:03 <lambdabot> No match for "wunch".
16:53:23 <augustss> probably related to lunch
16:53:34 <Philippa> no. It's a spoonerism
16:53:38 <emu> lunches with bankers are probably correlated with wunches of bankers
16:54:07 <augustss> wunch of bankers = bunch of wankers ?
16:54:18 <Philippa> I couldn't possibly comment :-)
16:54:22 <jcreigh> heh
16:54:43 <Philippa> I don't think it's actually in the OED. Yet.
16:56:05 <Gwern> correct. "wunch" is not in fact in the online OED
16:56:11 <emu> you could have a show called "ST RealWorld" on HaskellTV
16:56:15 <augustss> edwinb: so what are you doing these days?
16:56:26 <Philippa> emu: about running ghci on an old Atari?
16:56:26 <vincenz> emu: and talk about the fun of 'binding' ?
16:56:43 <edwinb> augustss: I'm working for Kevin Hammond in St Andrews
16:56:56 <augustss> edwinb: I know that much.
16:57:06 <edwinb> oh, okay ;)
16:57:23 <emu> with multiple threads of plotline
16:57:37 <edwinb> more specifically, playing with dependent types for resource aware programming
16:57:52 <augustss> Ah, yes.
16:59:11 <augustss> Could we get more Haskell users if we renamed variable binding to variable bondage?
16:59:33 <olliej> augustss: possibly
16:59:35 <edwinb> would we get more than we'd lose?
16:59:35 <emu> i'm not sure we want that kind of user
16:59:38 <Philippa> I tried something similar, I don't think I'm responsible for that many converts :-)
16:59:38 <Gwern> augustss: we might, but they wouldn't be the rigt sort...
16:59:43 <olliej> augustss: but the conversation might get scarily OT
16:59:49 <Philippa> Gwern: Oi!
16:59:56 <emu> new meaning to unsafePerform*
17:00:03 <Philippa> olliej: too late, BTDT - that's why we have #haskell-blah
17:00:09 <olliej> hehe
17:00:10 <augustss> safeWordPerformIO
17:00:31 <wolverian> heh, google for "gt2hs" gives the gtk2hs page as the first hit.. with the title "gt2hs"
17:00:32 <Philippa> augustss: you may not've read the article where I dubbed those functions "unsafewords"?
17:00:48 <augustss> Philippa: I don't think I have :)
17:01:02 <wolverian> btw, is there a haskell interface to gtkglext?
17:01:15 <wolverian> or something similar that'll allow be to embed opengl in gtk apps
17:01:29 <Philippa> http://www.haskell.org/tmrwiki/ImpureThoughts_2f2
17:01:30 <lambdabot> Title: ImpureThoughts/2 - TmrWiki
17:01:35 <edwinb> augustss: we've just started looking at hardware design as well, although my background on that is somewhat limited
17:01:39 <edwinb> we're having fun though ;)
17:02:04 <augustss> As long as Kevin can provide some fun. :)
17:02:21 <edwinb> he provides beer occasionally. Does that count?
17:02:21 <Philippa> edwinb: you likely to make it to FitA?
17:02:29 <edwinb> Philippa: no chance, unfortunately
17:02:40 <edwinb> for my sins, I have to teach this semester...
17:02:45 <Philippa> oh dear
17:02:52 <Philippa> that rules out the Cam one as well, I take it?
17:02:52 <wolverian> "new OpenGL widget added", I guess that might be it.. )
17:02:56 <wolverian> ;)
17:03:07 <edwinb> might make the Cambridge one, depending when it is
17:03:21 <Philippa> *nod*
17:03:31 <Philippa> barring another train disaster I should - got crashspace sorted already, too
17:03:37 <augustss> edwinb: beer is probably as good as it's gonna get
17:06:03 <augustss> Philippa:  8)
17:08:21 <edwinb> oh, Cambridge one is in May, so I'll probably manage it if somebody will pay for it ;)
17:08:44 <Philippa> I'll buy you a drink if that helps?
17:09:36 <edwinb> that will help :)
17:12:11 <augustss> The Cambridge what?
17:12:30 <Philippa> Fun in the Afternoon
17:12:41 <augustss> Ah, I should come.
17:13:40 <edwinb> the last one was, er, fun.
17:14:33 <chessguy> glguy!
17:14:40 <augustss> Oh, there's one soon!
17:14:57 <augustss> perhaps I should jump on a train
17:15:11 <edwinb> a train? where are you now?
17:15:11 <glguy> chessguy!
17:15:28 <augustss> edwinb: London
17:16:03 <edwinb> oh, right. Working there or visiting?
17:16:39 <augustss> Working
17:16:53 <augustss> Gonna live in Greenwich
17:17:51 <chessguy> @type put
17:17:53 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => s -> m ()
17:20:03 <chessguy> put $ s {randomGen = g}
17:20:12 <chessguy> this is using named fields?
17:20:25 <glguy> yes
17:21:26 <chessguy> so it sets the generator in the local copy of the state, and then saves the state to the overall state, right?
17:23:12 <gotaku> All google videos link to youtube now...
17:23:57 <siti> gotaku: yes they are making google video like a search engine
17:23:57 <monochrom> Google begins to own everything.
17:24:06 <siti> and youtube a site where you watch them
17:24:35 <SamB> hmm.
17:24:48 <SamB> well, it makes more sense than having youtube and a youtube wannabe!
17:24:51 <glguy> which one has the ignorant comments section?
17:25:07 <EvilRanter> they both always have
17:25:11 <siti> yeah :P
17:25:37 <Gwern> that is not good. google video allowed vastly larger file sizes
17:25:44 <Gwern> the technical talks were quite good on google video
17:25:51 <SamB> Gwern: probably they fixed youtube?
17:25:52 <EvilRanter> youtube in particular, tho. i'm perpetually amused/irritated by people who double/triple/n-ple post so that they can better make their argument when having a flamewar
17:26:04 <EvilRanter> the character limit was there for a reason, dagnabbit!
17:26:08 <Gwern> SamB: I hope they did, at least
17:26:28 <SamB> how else would they have moved the videos over?
17:26:50 <EvilRanter> massive re-encoding fest?
17:26:59 <SamB> heh
17:27:16 <glguy> lol, just because they moved big videos doesn't mean they allow *you* to upload videos of the same size
17:27:19 <EvilRanter> actually, just allowing the larger videos'd probably be easier, even if they had to buy more disk space and/or bandwidth
17:27:44 <SamB> they should just delete duplicate posts to make up for it
17:27:45 <quazimodo> hello people
17:27:48 <sorear> hello
17:27:55 <glguy> hello
17:28:04 <SamB> hello monsters
17:28:05 <mbishop> hello
17:28:05 <EvilRanter> SamB, or not allow them in the first place
17:28:11 <quazimodo> wow
17:28:16 <quazimodo> most hellos ive ever seen in irc
17:28:23 <EvilRanter> hello
17:28:26 <chessguy> hello
17:28:28 <quazimodo> +2
17:28:29 <quazimodo> !!
17:28:29 <SamB> hello hello hello
17:28:31 <dons> hi!
17:28:34 <quazimodo> ok stop
17:28:37 <glguy> zomg dups
17:28:39 <quazimodo> stimulus overload
17:28:40 <dons> > cycle "hello "
17:28:41 <chessguy> leave it to dons to spoil everything
17:28:41 <lambdabot>  "hello hello hello hello hello hello hello hello hello hello hello hello hel...
17:28:59 <SamB> dons: that is the most hellos I havenn't seen in irc
17:29:26 <chessguy> oh brother
17:29:27 <monochrom> hahahahaha
17:29:28 <quazimodo> i just remembered, as a highschool kid the word stimulate was funny in a dirty way
17:29:30 <quazimodo> i dont get it now
17:29:39 <EvilRanter> well, at least dons' well-timed haskell evaluation kept us vaguely on-topic
17:29:47 <glguy> hello
17:29:58 <glguy> How are you I'm fine
17:30:03 <quazimodo> im pro
17:30:07 <SamB> isn't "hello" always on-topic?
17:30:14 <quazimodo> i always make people change topic
17:30:17 <EvilRanter> google video aint
17:30:40 <glguy> ?yow
17:30:41 <lambdabot> Thank god!! ... It's HENNY YOUNGMAN!!
17:30:42 <monochrom> They use MapRedue
17:30:50 <quazimodo> hey dons, when is unsw oweek?
17:30:55 <quazimodo> 19th or 26th?
17:31:00 <augustss> @quote
17:31:00 <lambdabot> ##C++ says: [asking about C++ rules] vincenz: how should we know what those rules mean ?
17:31:19 <chessguy> so who's going to the FP conference in New York in....April?
17:31:21 <augustss> C++ rulez!
17:31:29 <glguy>  c++ rules?
17:31:38 <SamB> how much does it cost to go to new york?
17:31:45 <SamB> what days is it on?
17:31:50 <sorear> a week of hacking?
17:31:55 <Philippa> glguy: how dare you question el presidente!
17:32:05 <augustss> chessguy: I might, if I can persuade the higher powers.
17:32:17 <chessguy> SamB, http://tltc.shu.edu/tfp2007/
17:32:18 <edwinb> I'm going, with any luck
17:32:19 <lambdabot> Title: TFP 2007 at Seton Hall University
17:32:24 <glguy> what are the "C++ rules"
17:32:31 <chessguy> SamB, i'll meet and ride up with you if you want, we can split the gas
17:32:31 <quazimodo> i went to ruxcon in 2004
17:32:39 <quazimodo> i have the phrack.org booklet
17:32:41 <chessguy> err, wait
17:32:47 <chessguy> it's in the middle of the week, i forgot
17:32:54 <quazimodo> the limited edition one with a half nipples chick drawing on the front
17:33:07 <chessguy> it's ridiculous
17:33:14 <chessguy> monday through wednesday
17:33:29 <SamB> oh, I can't go then either
17:33:39 <SamB> also I don't have a vehicle or money to speak of
17:33:51 <chessguy> ah, a true haskell programmer
17:34:39 <zarvok> heh
17:34:45 <monochrom> Academic meetings are scheduled in the middle of the week.
17:34:46 <zarvok> will typecheck for food
17:34:50 <sorear> which is 'better':
17:35:01 <sorear> newtype Color = Color Int  -or-
17:35:06 <quazimodo> hey guys
17:35:06 <monochrom> This is to give profs an excuse to tell students "classes are cancelled next week"
17:35:13 <chessguy> what's the difference between a profession chess player and a large pizza? the pizza can feed a family of 4
17:35:15 <quazimodo> what do you do with haskell?
17:35:16 <sorear> data Color = Color {-# UNPACK #-} !Int
17:35:29 <quazimodo> i mean, i know what haskell does, but what do *you* do with it in terms of making a living?
17:35:34 <augustss> sorear: newtype, I'd say
17:35:39 <bd_> sorear: the former gives you generalized newtype deriving
17:36:01 <augustss> And it is isomorphic to Int
17:36:01 <chessguy> ?remember zarvok will typecheck for food
17:36:02 <lambdabot> Done.
17:36:04 <sorear> are there any advantages to the latter?
17:36:15 <monochrom> newtype doesn't make my brain explode.
17:36:16 <bd_> augustss: They're both isomorphic to int, but the latter may have a representation
17:36:50 <sorear> the latter is transformed into data Color = Color Int# , which modulo names *is* Int
17:37:01 <augustss> bd_: I mean *really* isomorphic, as in semantics and representation
17:37:09 <Philippa> sorear: causing fun when you run it through a different haskell implementation might be an advantage if you're sadistic
17:37:25 <augustss> Also, newtype is Haskell98
17:37:32 <sorear> Philippa: in the Real World I use -funbox-strict-fields
17:37:54 <sorear> the explicit pragma was for illustration only
17:38:14 <sorear> and yes, this is going into a public library :)
17:38:15 <augustss> sorear: for a single field, go with newtype
17:38:17 <monochrom> hehehehe sadistic
17:38:24 <sorear> ok.
17:38:46 <sorear> I suppose there's no Word4 :)
17:39:02 <coffeemug> hey guys
17:39:10 <augustss> sorear: you could make one :)
17:39:20 <bd_> augustss: but it wouldn't be packed into a bit field :)
17:39:28 <augustss> nope
17:39:33 <chessguy> hi coffeemug
17:39:37 <glguy> hello
17:39:41 <coffeemug> does anyone know where I could get reasonably cheap access to academic journals?
17:39:55 <augustss> coffeemug: library?
17:39:58 <quazimodo> nvm then
17:40:02 <coffeemug> preferrably in electronic form
17:40:11 <chessguy> augustss, you mean a public library? :)
17:40:17 <coffeemug> I'm not a student
17:40:23 <augustss> chessguy: probably university library
17:40:29 <JKnecht> coffeemug: go to a suny library.
17:40:32 <chessguy> lol
17:40:34 <monochrom> get papers from authors' websites.
17:40:48 <coffeemug> monochrom: that's what I usually do but some aren't available :)
17:40:52 <chessguy> augustss, was a play off sorear's comment about making a public library earlier
17:41:27 <monochrom> university libraries are open to public.  can dine-in.  just no take-out for non-university-people.
17:41:39 <coffeemug> some evil sources online sell them for like $25 per paper
17:41:45 <coffeemug> which is a ripoff :)
17:42:06 <coffeemug> monochrom: some universities :)
17:42:08 <chessguy> monochrom, not the university i just graduated from. no free parking
17:42:11 <sorear> coffeemug: check Google Scholar - the cache did evil things last time I checked (months ago)
17:42:34 <coffeemug> sorear: yeah, I usually get them for free, just in some cases they're not available
17:42:48 <monochrom> ask us to smuggle out specific papers
17:42:53 <JKnecht> no, those services can do things your local library often can't. They're aggregated in dbs like Dialog and usually locale and or subject matter specific.
17:42:59 <sorear> no, this was a for-money-only paper google-scholar's cache gave me.
17:44:23 <dons> hey coffeemug
17:44:29 <coffeemug> I'm looking for a paper Lennart mentioned on haskell-cafe
17:44:31 <coffeemug> hey dons
17:44:33 <sorear> which is faster:
17:44:37 <sorear> Word16 or Int?
17:44:38 <coffeemug> long time no speak :)
17:44:47 <coffeemug> original combinator paper
17:44:50 <coffeemug> let me look it up
17:45:03 <dons> Int?
17:45:14 <coffeemug> dons: how goes it?
17:45:14 <chessguy> oh, the one about bananas and barbed wire or something?
17:45:35 <coffeemug> A new implementation technique for applicative languages
17:45:54 <sorear> and yes I am benchmarking ... just I have a very awkward benchmark :(
17:46:04 <dons> coffee-mug: good!
17:46:33 <glguy> ?google -100K in celsius
17:46:34 <lambdabot> (-100) kelvin = -373.15 degrees Celsius
17:46:41 <coffee-mug> stupid nickserv
17:46:43 <glguy> *breakin the law*!
17:46:48 <coffee-mug> makes me change my nick to register :)
17:47:28 <sorear> aside from monochrom, are there any regulars here who don't identify?
17:47:41 <coffee-mug> ok, I'm stuck with a dash :)
17:47:43 <monochrom> wow I'm special
17:47:56 <glguy> so are the kids in the special school district :(
17:48:07 <coffee-mug> well, I'd like to not identify
17:48:20 <sorear> eh?
17:48:23 <coffee-mug> but then I can't speak in the rails channel (don't spam me for this blasphemy)
17:48:31 <coffee-mug> spam=flame
17:48:37 <glguy> not really
17:49:36 <sorear> why flame when you can oh-so-subtly pressure?  I registered of my own volition!
17:49:40 <coffee-mug> does anyone have Dave Turner's combinator paper on hand?
17:50:56 <coffee-mug> if someone could send it to me, I'd be most grateful :)
17:56:02 <coffee-mug> am I still here?
17:56:03 * emu finally found the bug in his finite automata impl
17:56:10 <coffee-mug> ah, I am
17:56:12 <coffee-mug> cool :)
17:57:00 <monochrom> You have not died yet.
17:57:42 <coffee-mug> I spent some time playing around with Lisp and Ruby
17:57:51 <glguy> hey, who was that person that admitted to using rails earlier?
17:57:53 <coffee-mug> back to Haskell now for a bit
17:58:00 <coffee-mug> glguy: it was me :)
17:58:16 <coffee-mug> I really miss optional parameters now
17:58:26 <coffee-mug> and keyword argumnets
17:58:30 <coffee-mug> arguments
17:58:42 <coffee-mug> would be awesome if Haskell could implement some sugar for that
17:58:43 <bd_> coffee-mug: This sounds like a job for a typeclass hack! ;)
17:58:56 <coffee-mug> bd_: yeah
17:58:59 <emu> coffee-mug: records
17:59:00 <bd_> Probably beyond my abilities though
17:59:02 <coffee-mug> not sure how that would work though :)
17:59:17 <emu> as for optional parameters, perhaps take a look at the Printf class?
17:59:22 <bd_> x $ y { param1 = foo } ...
17:59:56 <coffee-mug> emu: that's polyvariadic though
18:00:04 <coffee-mug> a bit different
18:00:08 <coffee-mug> from keyword arguments
18:00:13 <emu> not really; optional params are poly variadic
18:00:20 <Cale> Who needs optional arguments when you have currying? :)
18:00:21 <emu> no; record types give you keyword params
18:01:01 <emu> also; semi-colons -- fun to use
18:01:24 <coffee-mug> emu - yeah, that's true
18:01:33 <coffee-mug> you just pass a record, set what you want
18:01:37 <emu> i'm giddy from fixing that dumb bug.  now i need to prove this program is correct.
18:01:50 <coffee-mug> wouldn't you get undefined runtime errors though?
18:01:57 <coffee-mug> for stuff that hasn't been set
18:02:01 <coffee-mug> when you access it in a function?
18:02:11 <emu> no because you can't not set it
18:02:22 <emu> so you'd have to make something like "defaultConfig"
18:02:37 <coffee-mug> yeah
18:02:39 <emu> foo $ defaults { ... }
18:02:42 <coffee-mug> but that's a little dirty though :)
18:03:03 <Cale> Well, you could set it to undefined, but that obviously will have problems.
18:03:10 <emu> perhaps you should supplicate Oleg and see what happens?
18:03:22 <sorear> imagine a record system with anonymous literals and merging
18:03:27 <sorear> function {foo = bar}
18:03:38 <emu> there's a lot of things which could be done to the record system i imagine
18:03:44 <mbishop> Hmm nomaware still down
18:03:44 <sorear> function = real_function . merge defaults
18:04:04 <emu> how about name-based currying?
18:04:12 <coffee-mug> sorear: also, if you could specify a default record for each constructor, that would be great
18:04:24 <sorear> coffee-mug: amen.
18:04:31 <coffee-mug> the type system could figure out which default you want
18:04:42 <coffee-mug> and then you'd get optional params for free :)
18:08:03 <coffee-mug> Any chance Haskell' people could incorporate that? :)
18:08:39 <emu> come up with a static semantics for it and incorporate that into the report
18:09:45 <coffee-mug> I'm afraid I'm not quite qualified though
18:11:04 <emu> got TAPL?
18:12:14 <coffee-mug> yeah, tapl is a great book
18:12:51 <olliej> tapl?
18:13:10 <olliej> i recall the acronym... i can't remember what it actually is
18:13:24 <augustss> great book!  even if it's not entirely accurate
18:13:32 <crathman> Types and Programming Languages, Benjamin Pearce
18:13:47 <augustss> just minor things wrong
18:14:01 <emu> the only thing that annoys me is the chapters wasted on OO crud
18:14:27 <augustss> it should have had more on type classes and dependent types
18:14:37 <sorear> is there any way to get ghc to unbox a foo :: Attr -> Color where Attr and Color are both newtypes of Int?
18:14:54 <monochrom> Pierce
18:14:56 <emu> well it does cover System F omega iirc
18:15:20 <augustss> Fw is neither type classes nor dependent
18:15:24 <dons> ah hA!
18:15:33 <dons> my hand written hash table is *miles* faster than the standard one
18:15:39 <sorear> yay!
18:15:43 <sorear> aw :(
18:15:43 <crathman> there is the second Advanced TAPL book
18:15:45 <dons> 8x without optimising yet
18:15:46 <emu> frick, i always mix up those damn 1-letter system names
18:15:50 <augustss> sorear: what doesn your question mean?  unbox the function?
18:16:04 <dons> this was too easy to write :/
18:16:06 * emu picks up hsi copy
18:16:07 <sorear> augustss: I want ghc to go worker/wrapper on my function
18:16:27 <augustss> but foo is the identity function
18:16:36 <augustss> it will disappear
18:16:37 <sorear> "Fast or typesafe: pick one"
18:16:45 <coffee-mug> dons: functional, or c based? :)
18:16:49 <emu> dons: is it specific?
18:16:51 <sorear> :(
18:17:21 <sorear> augustss: foo is NOT the itentity, it is (+1) (in my test)
18:17:40 <augustss> sorear: oh, ok
18:17:43 <sorear> augustss: the final foo will be (.&. 15) . (uncheckedShiftR 4)
18:17:56 <sorear> augustss: since ghc can't do bitfields itself
18:18:00 <monochrom> emu: for better or worse, they are all called F-blahblahblah :)
18:18:11 <dons> coffee-mug: functional
18:18:12 <sorear> one is called E!
18:18:22 <monochrom> Darn!
18:18:32 <emu> gotta love F_omega^{<:}
18:18:32 <sorear> no wait that's an entire language
18:18:33 <augustss> sorear: sounds like there's a good chance ghc will do the right thing
18:18:37 <monochrom> hehe
18:18:48 <emu> or was it F^omega_{<:}?
18:18:56 <sorear> augustss: even if -ddump-simpl says there's only one function?
18:19:04 <sorear> <-- idiot
18:19:07 <monochrom> the <: stands for subtyping.  it is to model those OO stuff.
18:19:11 <emu> yes yes
18:19:11 <coffee-mug> dons: check it in :)
18:19:16 <sorear> Gah I am so dumb
18:19:18 <emu> dirty OO chapter
18:19:21 <hpaste>  dons pasted "fast hashtable type" at http://hpaste.org/331
18:19:27 <emu> i just can't remember which was subscripted
18:19:36 <sorear> augustss: I suppose unboxing is more likely to happen *with* -O ?
18:19:38 <dons> of course, its a hashtable specialised to bytestrings
18:19:43 <dons> which would actually be better off as a Trie
18:19:53 <augustss> sorear: absolutely
18:20:00 <emu> i haven't used Data.Hashtable yet actually, always gotten by with Data.Map
18:20:02 <augustss> dons: why IO and not ST?
18:20:04 <monochrom> The <: part makes things very complicated.  Not sure if I should blame <: or F.
18:20:10 * augustss dislikes IO
18:20:14 <emu> i'd blame <:
18:20:14 <dons> augustss: no reason. it should be ST I guess :)
18:20:21 <emu> it's a screwy relation
18:20:44 <emu> especially when dealing with function types i recall
18:21:06 <augustss> F^omega_<: has undecidable type checking
18:21:10 <monochrom> In the long run, OO and <: are just transitional things towards something greater and more elegant.
18:21:54 <emu> elegance oriented programming?
18:21:54 <sorear> augustss: 6.6 -O2 -ddump-simpl saz: X.foo = \ (ds_dlh :: X.A) -> case ds_dlh of wild_als { GHC.Base.I# x_alu -> GHC.Base.I# (GHC.Prim.+# x_alu 1) }
18:21:58 <slowriot> Why doesn't Haskell have a readNextToken function that reads in the next group of characters separated by whitespace?
18:22:04 <monochrom> YES!
18:22:04 <slowriot> I could use "words"
18:22:07 <sorear> see all those boxes!
18:22:21 <emu> @type break
18:22:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:22:26 <sorear> slowriot: parsec! parsec! parsec!
18:22:32 <augustss> sorear: nasty.  but what do uses of foo look like?
18:22:33 <coffee-mug> dons: you're really determined to get GHC to beat everything on the shootout, aren't you? :)
18:22:42 <slowriot> parsec, okay
18:22:51 <glguy> ?shootout
18:22:52 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
18:23:05 <emu> skipMany space?
18:23:12 <glguy> was Haskell beating Clean yesterday?
18:23:13 <dons> coffee-mug: yes :)
18:23:49 <dons> coffee-mug: its very useful a pinpointing library and compiler weaknesses
18:23:56 <dons> e.g. look! now we have Data.ByteString :)
18:24:03 <dons> and a suite of regex libs
18:24:24 <emu> how about that new regex lib for ghc?
18:24:41 <dons> yeah, talking to TuringTest, the author, he says we should go with regex-pcre or regex-tre
18:24:46 <dons> but they're not in the core libs, on regex-posix
18:24:51 <dons> and posix re's aren't so hot
18:25:11 <dons> glguy: we were just behind clean yesterday
18:25:36 <glguy> when you compare clean and haskell's scores side by side... it isn't clear why haskell is ahead though
18:25:51 <emu> memory?
18:26:02 <coffee-mug> someone sent me an email today
18:26:10 <coffee-mug> pointing me to Steve Yegge's article
18:26:10 <dons> glguy: shorter code, better memory
18:26:15 <dons> glguy: and faster on a few
18:26:20 <dons> clean is missing 5 entries too
18:26:20 <coffee-mug> regarding "Pinoccio" software
18:26:26 <glguy> in general the clean solutions look faster though
18:26:29 <audreyt> dons: so is there already instance IsString ByteString?
18:26:38 <dons> audreyt: a demo, I think
18:26:42 <dons> audreyt: check with augustss
18:26:51 <coffee-mug> so I started thinking
18:27:00 <dons> you want some bytestring warez, audreyt /
18:27:02 <coffee-mug> it would be a hack of the century to get GHC to support live coding
18:27:12 <emu> hs-plugins?
18:27:26 <coffee-mug> yeah, hs-plugins are very good
18:27:28 <audreyt> dons: yes, and crackz and codegen and serial numbers
18:27:30 <dons> coffee-mug: you mean live as in on a stage in front of people?
18:27:32 <monochrom> what is live coding?
18:27:37 <coffee-mug> dons: yeah :)
18:27:39 <coffee-mug> lol
18:27:41 <dons> that's already happening: check yaxu's live haskell music performances
18:27:56 <dons> there's some clips on youtube of him live coding in ghc
18:27:59 <dons> with hs-plugins, yeah
18:28:14 <audreyt> dons: but seriously, that is just one line "fromString = pack"
18:28:22 <monochrom> how about live embarrasment, i.e., the computer scolds you for type errors in front of people.
18:28:27 <dons> there were some articles on reddit, and he's doing some gigs this week or next?
18:28:28 <coffee-mug> I'm talking about GHC starting a server and people sending it updated code line by line
18:28:37 <audreyt> what I meant by the question is that whether it's part of default library/base/ (not currently, but seems reasonable)
18:28:45 <monochrom> ghc is already way ahead of perl in terms of live embarrasment.
18:29:38 <emu> No instances for (Show Foo) perhaps you meant to not suck?
18:29:57 <audreyt> ...and there's the occasional gore in the form of brain explosion...
18:30:15 <monochrom> someone should set up a shootout for computer scolding people for coding errors.
18:30:21 <emu> perhaps add the lambdabot error message plugin to ghc
18:30:28 <emu> @src RealWorld
18:30:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:30:42 <allbery_b> bad enough openbsd has it :)
18:31:12 <glguy> dons, have you started tinkering with regex-dna?
18:31:22 <glguy> dons is that one that you just mentioned needs the new regex library?
18:31:54 <dons> right
18:31:58 <dons> haven't looked at it yet
18:32:04 <coffee-mug> brb
18:32:08 <dons> but a demo using the regex-tre binding would be a good test to see what we can do
18:32:13 <dons> ?where regex-tre
18:32:14 <lambdabot> http://darcs.haskell.org/packages/regex-tre/
18:33:12 <gotaku> I'm watching the 2006 ICFP contest results and did they ever put alot of effort into this one...
18:34:35 <coffee-mug> hmm
18:34:46 <coffee-mug> KDE's Konversation is a pretty good IRC client
18:35:50 <coffee-mug> I'd go for one of emacs' irc modes but I still resist to spending some time to learn it :)
18:36:20 <emu> C-h m
18:36:49 <SamB> gotaku: I wish they would have figured out how to make it not need so much RAM!
18:37:07 <mutjida> ?where trie
18:37:07 <lambdabot> I know nothing about trie.
18:37:17 <mutjida> ?where tries
18:37:18 <emu> ?where state secrets
18:37:18 <lambdabot> I know nothing about tries.
18:37:18 <lambdabot> I know nothing about state.
18:37:58 <emu> @google trie
18:38:00 <lambdabot> http://en.wikipedia.org/wiki/Trie
18:38:42 <emu> ?where the-money-for-the-horse
18:38:43 <lambdabot> I know nothing about the-money-for-the-horse.
18:40:16 <mutjida> any good trie libraries out there?
18:42:45 <sorear> @where HsJudy
18:42:46 <lambdabot> http://perlcabal.org/~audreyt/darcs/pugs/third-party/HsJudy/
18:42:51 <sorear> good enough?
18:42:52 <dons> they're pretty easy to roll your own though
18:43:02 <dons> there's an example on the knuc page of the shootout wiki
18:43:03 <dons> ?wiki Shootout
18:43:04 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
18:43:06 <mutjida> i'm doing just that. thought i'd see what's there already.
18:43:13 <sorear> well, judy is a Massively Tuned C Library
18:43:40 <emu> hm, do other people pepper their code with things like `S.insert` when dealing with Data.Set.Sets?
18:43:54 <emu> or come up with some clever scheme
18:43:58 <sorear> i usually use previx
18:44:05 <mutjida> i want lazy tries
18:44:11 <emu> i meant not the arity but the name
18:44:30 <xpika> > replicate 10 $ replicate 10 '#'
18:44:32 <lambdabot>  ["##########","##########","##########","##########","##########","#########...
18:44:47 <sorear> > transpose $ replicateM 4 "# "
18:44:48 <lambdabot>  ["########        ","####    ####    ","##  ##  ##  ##  ","# # # # # # # # "]
18:44:56 <nornagon> :t replicateM
18:44:58 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
18:45:02 <xpika> whats a simpler way to write that
18:45:14 <nornagon> :t transpose
18:45:16 <lambdabot> forall a. [[a]] -> [[a]]
18:45:26 <sorear> > foldr replicate '#' [20, 20]
18:45:27 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
18:45:27 <lambdabot>       Expected...
18:45:29 <nornagon> > replicateM 4 "# "
18:45:31 <lambdabot>  ["####","### ","## #","##  ","# ##","# # ","#  #","#   "," ###"," ## "," # #...
18:45:32 <emu> > transpose [[1..10],[1..10]]
18:45:34 <lambdabot>  [[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]
18:45:36 <sorear> gah, no dependent types?
18:45:45 <mutjida> also looking for intelligent filtering operations
18:45:52 <bd_> nornagon: Do you see why that works? :)
18:46:00 <nornagon> bd_: mostly :)
18:46:02 <mutjida> :t replicateM
18:46:04 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
18:46:25 <nornagon> it's like [x:y:[] | x <- "# ", y <- "# " ] or so?
18:46:35 <sorear> yes
18:46:45 <xpika> > replicate 10 $ replicate 10 '#'
18:46:46 <lambdabot>  ["##########","##########","##########","##########","##########","#########...
18:46:52 <bd_> ?src replicateM
18:46:53 <lambdabot> replicateM n x = sequence (replicate n x)
18:47:09 <nornagon> i'm still not sure about sequence :P
18:47:19 <emu> > sequence [[1..4],[1..4]]
18:47:21 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,...
18:47:35 <nornagon> @src sequence
18:47:35 <lambdabot> sequence ms = foldr k (return []) ms
18:47:36 <lambdabot>     where
18:47:36 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:47:43 <nornagon> scary
18:47:51 <emu> what, product?
18:48:01 <nornagon> :t sequence
18:48:03 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:48:09 <nornagon> ^- not just [[a]]
18:48:13 <emu> > sequence [[1..2],[1..2]]
18:48:14 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
18:48:21 <emu> yea, it just does monadic actions in sequence
18:48:22 <bd_> nornagon: it's not that scary. It just takes a list of monad actions and does them all :)
18:48:31 <emu> @src mapM
18:48:32 <lambdabot> mapM f as = sequence (map f as)
18:48:34 <bd_> ?src sequence_
18:48:35 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
18:48:47 <mutjida> sequence [[1,2]]
18:48:50 <nornagon> oh, that makes sense, sort of
18:48:57 <Cale> sequence = foldr (liftM2 (:)) (return [])
18:48:58 <nornagon> what's >> do in the context of []?
18:49:02 <bd_> mutjida: need the >
18:49:05 <sorear> nornagon:
18:49:10 <sorear> @src [] >>
18:49:10 <lambdabot> Source not found. That's something I cannot allow to happen.
18:49:16 <mutjida> > sequence [[1,2]]
18:49:16 <sorear> in that case...
18:49:18 <lambdabot>  [[1],[2]]
18:49:25 <nornagon> @src [] (>>)
18:49:26 <lambdabot> m >> k      = foldr ((++) . (\ _ -> k)) [] m
18:49:37 <sjanssen> @src >>
18:49:38 <lambdabot> Source not found. I feel much better now.
18:49:41 <emu> const?
18:49:48 <nornagon> concat?
18:49:50 <sorear> nornagon: (>>) l1 l2 = concat $ replicate (length l1) l2
18:49:51 <emu> well map const
18:49:56 <bd_> nornagon: What does (>>) do in all monads?
18:50:00 <Cale> > [1,2,3] >> [4,5]
18:50:02 <lambdabot>  [4,5,4,5,4,5]
18:50:04 <bd_> ?src [] join
18:50:05 <lambdabot> Source not found. Do you think like you type?
18:50:08 <bd_> tsk
18:50:15 <Cale> @src join
18:50:16 <lambdabot> join x =  x >>= id
18:50:16 <bd_> (>>=) should be defined in term of join for lists
18:50:17 <sorear> bd_: hah. that's not a method
18:50:18 <chessguy> bd_, it discards the result of the first monad
18:50:18 <nornagon> bd_: 'then' is how i usually think of >>
18:50:23 <emu> @type think
18:50:25 <lambdabot> Not in scope: `think'
18:50:25 <bd_> sorear: I thought it was a defaulted one?
18:50:26 <Cale> chessguy: the first action
18:50:36 <sorear> bd_: nope.  just return fail >>= >>
18:50:38 <bd_> nornagon: Do you know the formal definition?
18:50:38 <Cale> the values typed in a monad are not called monads
18:50:46 <nornagon> bd_: in terms of >>=? yes.
18:51:01 <Cale> [], IO, Maybe, State s, Reader r, etc. are monads.
18:51:07 <bd_> sorear: aw. Monad really should imply Functor, and let you define either in terms of the other... :/
18:51:08 <nornagon> a >> b = a >>= (\_ -> b)
18:51:09 <nornagon> right?
18:51:14 <bd_> nornagon: yep
18:51:22 <Cale> bd_: Yes, join *should* be a method of Monad
18:51:27 <bd_> nornagon: So do you know (>>=) for List?
18:51:29 <sorear> MonadZero forever!!!
18:51:33 <nornagon> bd_: no :|
18:51:38 <nornagon> @src [] (>>=)
18:51:38 <lambdabot> m >>= k     = foldr ((++) . k) [] m
18:51:39 <sorear> =<< = concatMap
18:51:58 <Cale>  @src gives odd definitions
18:52:00 <bd_> (>>=) l f = join $ fmap f l
18:52:02 <bd_> :)
18:52:06 <Cale> Where is it taking its definitions from?
18:52:09 <bd_> where join = concat
18:52:14 <emu> @. pl src join
18:52:15 <lambdabot> (line 1, column 1):
18:52:15 <lambdabot> unexpected end of input
18:52:15 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
18:52:22 <emu> @. pl src foldr
18:52:23 <lambdabot> (line 1, column 1):
18:52:23 <lambdabot> unexpected end of input
18:52:23 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
18:52:30 <nornagon> :t fmap
18:52:32 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:52:35 <Cale> I'd write it as   x >>= f = join (fmap f x)
18:52:49 <bd_> nornagon: fmap on lists is the same as map, but it's more general and can be used for types other than lists
18:52:52 <nornagon> > fmap (\k -> k + 1) [1,2,3]
18:52:53 <lambdabot>  [2,3,4]
18:53:01 <nornagon> i see
18:53:02 <Cale> > fmap (+1) (Just 5)
18:53:04 <lambdabot>  Just 6
18:53:10 <bd_> eg, Data.Sequence, any Monad (provided the author remembered to define fmap -_-)
18:53:21 <emu> > (+1)`fmap`(+2) $ 3
18:53:23 <monochrom> > liftM (+1) (Just 5)
18:53:23 <lambdabot>  6
18:53:24 <lambdabot>  Just 6
18:53:26 <bd_> nornagon: for monads, fmap is equivalent to liftM, provided the monad satisfies the Monad Laws
18:53:32 <monochrom> > liftM (+1) [1,2,3]
18:53:34 <lambdabot>  [2,3,4]
18:53:39 <monochrom> hee hee hee
18:53:41 <bd_> and provided the monad author didn't forget to define the Functor instance
18:53:42 <xpika> > sequence (replicate 2$replicate 10) '#'
18:53:43 <lambdabot>  ["##########","##########"]
18:53:53 <nornagon> i still don't properly understand liftM (I know the definition, though)
18:54:05 <monochrom> Don't worry.  It takes time.
18:54:09 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in (+1) . (*2) . [1,2,3,4,5]
18:54:28 <nornagon> i'm trying to read stuff in #haskell and planet haskell and hope i learn by osmosis :)
18:54:29 <emu> @yow
18:54:30 <monochrom> When you become as old as me, you'll even find F_omega^whatever trivial. XD
18:54:37 <Cale> er, huh
18:54:41 <Cale> @bot
18:54:42 <emu> @botsnack
18:54:47 <Cale> dead.
18:54:48 <chessguy> Cale broke the bot!
18:54:50 <emu> you killed it
18:55:02 <monochrom> Murder!
18:55:03 <chessguy> burn him!
18:55:17 <newsham> norn: hmm.. the definition is pretty much all there is to understand.
18:55:17 <sorear> @part #haskell
18:55:27 <newsham> do { x <- action; return (f x) }
18:55:27 <sorear> @msg sorear foo
18:55:41 <emu> well, bots gone, fun's over
18:55:41 <newsham> get a result from an action and return f applied to that result
18:55:48 <chessguy> newsham, that's the kind of thinking that makes haskell difficult for newbies
18:55:49 <bd_> nornagon: liftM converts a function on values, into a function on monad actions. That is, it converts from (a -> b) to (m a -> m b)
18:55:49 <bd_> 'lifting' the function into the monad
18:55:51 <lambdabot> Are we live or on tape?
18:55:51 <lambdabot> :)
18:55:51 <nornagon> newsham: right, but it's function isn't immediately obvious when i see it in code to me
18:55:51 <lambdabot> :)
18:55:51 <lambdabot>  [3,5,7,9,11]
18:56:03 <monochrom> ...
18:56:09 <allbery_b> huh
18:56:12 <monochrom> Now sorear is the new murderer
18:56:18 <newsham> norn: do { x <- getContents; return (lines x) }
18:56:20 <chessguy> understanding the definitions for monads and related things is far, far different from understanding the implications
18:56:23 <newsham> does that make sense?
18:56:26 <nornagon> bd_: hmm
18:56:48 <nornagon> that makes sense, i guess -- example?
18:56:51 <allbery_b> still responds to /msg at least
18:56:54 <monochrom> I agree with both chessguy and newsham.
18:57:11 <monochrom> who is lamby? :)
18:57:11 <nornagon> also, my battery's been telling me it has 9 minutes left for the past five or ten minutes
18:57:16 <emu> chessguy: what helps is writing code, realizing that you're writing what is actually already defined as a HOF, and then substituting it in =)
18:57:24 <olliej> > let fib = 1:1:(zipWith (+) fib (tail fib)) in take 10 fib
18:57:24 <bd_> nornagon: newsham's example with getContents and lines can be rewritten as: liftM lines getContents
18:57:33 <chessguy> emu, or any other abstraction
18:57:40 <sorear> bah.
18:57:40 <sorear> it's not even taking /msgs
18:57:40 <sorear> or maybe it's just still lagging
18:57:42 <sorear> anyways ... ERC> /msg lambdabot @join #haskell
18:57:53 <newsham> norn: so by the definition of liftM in that statement the action is "getContents" and the function is "lines"
18:58:00 <sorear> gah I hate server lag
18:58:02 <allbery_b> it responded pretty quickly to me fwiw
18:58:05 <newsham> so you could do    liftM lines getContents
18:58:09 <nornagon> hm :)
18:58:10 <emu> > 1
18:58:11 <lambdabot>  1
18:58:27 <nornagon> > liftM (+3) [1,2,3]
18:58:29 <lambdabot>  [4,5,6]
18:58:36 <nornagon> I think I get it!
18:58:41 <sorear> allbery_b: it was ME this time ,(cycle ":( ")
18:58:47 <newsham> here's a small example we can run here:  do { x <- Just 3; return (x + 2) }
18:59:00 <newsham> > do { x <- Just 3; return (x+2) }
18:59:02 <lambdabot>  Just 5
18:59:08 <newsham> > liftM (+ 2) (Just 3)
18:59:09 <nornagon> > liftM (+2) (Just 3)
18:59:09 <lambdabot>  Just 5
18:59:11 <lambdabot>  Just 5
18:59:12 <nornagon> :)
18:59:18 * sorear forgets the TH notation for unquote
18:59:20 <bd_> > (+2) `fmap` return 3 :: Maybe Int
18:59:22 <lambdabot>  Just 5
18:59:36 <newsham> norn: liftM is just a commonly used pattern that was abstracted out
18:59:36 <nornagon> liftM == fmap, didn't you say?
18:59:41 <nornagon> or is that just for lists?
18:59:47 <nornagon> newsham: *nod*
18:59:47 <bd_> nornagon: Only for monads.
18:59:53 <newsham> ?type fmap
18:59:55 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:59:59 <newsham> ?type liftM
19:00:00 <bd_> nornagon: There are Functors which are not Monads. Eg, Data.Sequence and Data.Map.
19:00:01 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
19:00:03 <nornagon> ahh.
19:00:08 <allbery_b> liftM == fmap, but liftM is monad and fmap is functor.  ideally all monads are functors
19:00:11 <emu> > let a 0 n = n + 1; a m 0 | m > 0 = a (m - 1) 1; a m n = a(m-1) (a m (n-1)) in map a [1..]
19:00:12 <lambdabot>  Add a type signature
19:00:22 <newsham> liftM is a specific instance of fmap.
19:00:39 <bd_> nornagon: Unfortunately due to limitations in haskell's type system, we can't ensure that Monad m implies Functor m. :/
19:00:39 <nornagon> i haven't seen much functor stuff yet.
19:00:45 <nornagon> aw :(
19:00:50 <newsham> norn: you just have :)
19:01:05 <nornagon> >.>
19:01:06 <bd_> nornagon: Easy way to think of functors: Functors are container data types. fmap lets you act upon the contained value.
19:01:16 <nornagon> that's just like monads..?
19:01:33 <bd_> nornagon: right, in the theory, all monads are functors, but not always vice versa
19:01:38 <coffee-mug> nornagon: fmap is just like map, except fmap allows ability to be overloaded
19:01:44 <newsham> for a Functor f,  fmap takes function (a -> b) and makes function f a -> f b
19:01:47 <coffee-mug> nornagon: that's really all there's to it
19:01:51 <nornagon> so what's an example of a functor that isn't a monad? (an example of the use, that is)
19:01:55 <newsham> ?src [] fmap
19:01:56 <lambdabot> fmap = map
19:01:57 <nornagon> coffee-mug: ability?
19:02:09 <newsham> ?src Maybe fmap
19:02:09 <lambdabot> fmap _ Nothing       = Nothing
19:02:10 <lambdabot> fmap f (Just a)      = Just (f a)
19:02:10 <bd_> > fmap (succ :: Int -> Int) ()
19:02:11 <lambdabot>  Couldn't match `f Int' against `()'
19:02:16 <coffee-mug> nornagon: yes, because fmap is part of a typeclass, you can overload it for different types
19:02:17 <bd_> aw, () isn't a functor?
19:02:30 <nornagon> coffee-mug: i see
19:02:31 <newsham> ?src () fmap
19:02:32 <lambdabot> Source not found. That's something I cannot allow to happen.
19:02:32 <emu> > let a 0 n = n + 1; a m 0 | m > 0 = a (m - 1) 1; a m n = a (m-1) (a m (n-1)) in take 3 $ zipWith a [1..] [2..]
19:02:33 <coffee-mug> nornagon: since map isn't, you can't overload it and it behaves in the same way for all types
19:02:33 <lambdabot>  [4,9,125]
19:02:38 <nornagon> coffee-mug: ah. :)
19:02:39 <allbery_b> <bd_> nornagon: There are Functors which are not Monads. Eg, Data.Sequence and Data.Map.
19:02:43 <bd_> > fmap (succ) $ Map.fromList [("foo", 1), ("bar", 2)]
19:02:43 <lambdabot>   Not in scope: `Map.fromList'
19:02:46 <bd_> > fmap (succ) $ M.fromList [("foo", 1), ("bar", 2)]
19:02:48 <lambdabot>  {"bar":=3,"foo":=2}
19:02:48 <emu> > let a 0 n = n + 1; a m 0 | m > 0 = a (m - 1) 1; a m n = a (m-1) (a m (n-1)) in take 4 $ zipWith a [1..] [2..]
19:02:53 <lambdabot> Terminated
19:02:55 <bd_> nornagon: there's a simple example :)
19:02:56 <coffee-mug> nornagon: another way to look at it is that map really should have been like fmap
19:03:01 <coffee-mug> and fmap shouldn't have existed
19:03:09 <nornagon> bd_: M?
19:03:14 <emu> (.) should be fmap!
19:03:23 <bd_> nornagon: Data.Map
19:03:27 <nornagon> ah
19:03:30 <nornagon> nice
19:03:32 <bd_> > fmap (+1) (+1) 1
19:03:34 <lambdabot>  3
19:04:02 <newsham> import qualified Data.Map as M
19:04:08 <nornagon> bd_: uhr
19:04:11 <coffee-mug> one cool thing when you "get" monads and functors
19:04:11 <nornagon> that's scary :O
19:04:18 <coffee-mug> is when you realize that it's just another type class
19:04:22 <nornagon> mm :)
19:04:24 <bd_> nornagon: heh, the map is less scary :p
19:04:35 <nornagon> :t fmap (+1)
19:04:37 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => f a -> f a
19:04:40 <nornagon> :t fmap (+1) (+1)
19:04:40 <SamB> coffee-mug: what do you mean about map behaving the same on all types?
19:04:42 <lambdabot> forall a. (Num a) => a -> a
19:04:45 <SamB> it only works on lists, silly!
19:04:53 <nornagon> ghci gave me something scarier
19:04:55 <bd_> nornagon: The latter (+1) here is using the reader monad
19:04:58 <nornagon> fmap (+1) (+1) :: (Num a, Functor ((->) a)) => a -> a
19:05:01 <bd_> Control.Monad.Reader
19:05:04 <coffee-mug> SamB: right :)
19:05:22 <nornagon> bd_: whose purpose i am blissfully unaware of :)
19:05:25 <bd_> nornagon: yes, it doesn't have the instance for Functor ((->) a) unless you :m + Control.Monad.Reader
19:05:30 <nornagon> or perhaps not so blissfully
19:06:05 <bd_> Reader's actually quite useful, it's just sometimes it's a bit confusing at first
19:06:20 <newsham> > runReader (do { x <- ask; return (x+1) }) 5
19:06:22 <lambdabot>  6
19:06:58 <nornagon> > runReader (liftM (+1)) 5
19:07:00 <lambdabot>      Expecting a function type, but found `Reader r a'
19:07:00 <lambdabot>       Expected type: R...
19:07:03 <bd_> nornagon: if (a -> b) is a Monad m => m b, how do you think it would be implemented?
19:07:04 <newsham> > runReader (do { x2 <- asks (** 2); x <- ask; return (3*x2 + 5*x) }) 5
19:07:06 <lambdabot>  100.0
19:07:46 <nornagon> bd_: uh, not quite sure what you mean
19:07:47 <newsham> > runReader (liftM (+1) ask) 5
19:08:09 <xpika> can someone fix this.
19:08:09 <xpika> > foldr (.) id [replicate 2,replicate 10] $ '#'
19:08:09 <xpika>  >foldr (.) id [replicate 2,replicate 10] $ '#'
19:08:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
19:08:09 <lambdabot>       Expected...
19:08:12 <lambdabot>  6
19:08:36 <coffee-mug> what happens when lambdabot gets a non-terminating computation?
19:08:42 <coffee-mug> how does it work in that case?
19:08:46 <bd_> coffee-mug:
19:08:46 <mbishop> By the way, while nomaware is down, you can use http://mbishop.esoteriq.org/stuff/allaboutmonads.pdf
19:08:47 <newsham> > last [1..]
19:08:48 <bd_> > last [1..]
19:08:48 <nornagon> > foldl (flip (.)) id [replicate 2,replicate 10] $ '#'
19:08:50 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
19:08:50 <lambdabot>       Expected...
19:09:03 <nornagon> heh
19:09:04 <lambdabot> Terminated
19:09:29 <allbery_b> apparenly a bit laggy still.  should time out computations after 3sec or thereabouts IIRC
19:09:35 <bd_> nornagon: try some things like: > (do { return 4 }) 42 or > (do { e <- ask; return $ 4 + e }) 42
19:09:44 <bd_> nornagon: you'll need to :m + Control.Monad.Reader
19:09:48 <coffee-mug> yeah, but how does it work?
19:09:48 <nornagon> blah, i was supposed to be doing some work... then haskell distracted me :(
19:09:56 <bd_> XD
19:10:04 <coffee-mug> how does it determine that a computation is non-terminating?
19:10:17 <heatsink> It uses a heuristic
19:10:17 <newsham> its just gives up
19:10:30 <heatsink> Greater than ten seconds or so = nonterminating
19:10:43 <sorear> it sets ulimit -C 3
19:10:57 <sorear> so it gets a fatal SIGXCPU after 3 cpu seconds
19:11:04 <coffee-mug> ah, so it spawns it off in a separate thread and times it
19:11:06 <sorear> (it == runplugs subprocess)
19:11:12 <sorear> coffee-mug: process
19:11:22 <nornagon> bd_: return 4 :: (Num t, Monad m) => m t
19:11:36 <nornagon> (scary how you can apply something of (Monad m) => m t!)
19:11:40 <coffee-mug> cool :)
19:11:56 <bd_> nornagon: That's because there's an instance Monad (a ->) where ...
19:12:01 <bd_> nornagon: Can you fill in the where... ?
19:12:06 <Cale> :t let a x = (x,x); b x = a (a x); c x = b (b x); d x = c (c x); e x = d (d x) in e
19:12:21 <lambdabot> thread killed
19:12:37 * allbery_b wonders if dons is abusing his machine
19:12:47 <allbery_b> @source Control.Monad.Reader
19:12:48 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
19:12:52 <Cale> No, that type calculation is.
19:13:05 <Cale> :t let a x = (x,x); b x = a (a x); c x = b (b x) in c
19:13:07 <lambdabot> forall a. -> ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))
19:13:13 <nornagon> bd_: no :(
19:13:21 <Cale> :t let a x = (x,x); b x = a (a x); c x = b (b x); d x = c (c x) in d
19:13:23 <lambdabot> forall a. -> ((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a,
19:13:23 <lambdabot>  a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
19:13:23 <lambdabot> a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a,
19:13:23 <lambdabot> a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
19:13:25 <lambdabot>  a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), (
19:13:26 <nornagon> eek
19:13:28 <lambdabot> (a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
19:13:31 <lambdabot>  a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))))
19:13:34 <allbery_b> yow
19:13:36 <newsham> > last [1..1000]
19:13:37 <bd_> nornagon: Here's a hint: return = const
19:13:38 <olliej> Cale: you are a bad, bad person
19:13:40 <lambdabot>  1000
19:13:40 <mbishop> way to go cale :[
19:13:42 <newsham> > last [1..100000]
19:13:44 <lambdabot>  100000
19:13:47 <newsham> > last [1..10000000]
19:13:50 <lambdabot>  10000000
19:13:53 <newsham> > last [1..1000000000]
19:13:55 <allbery_b> @source Control.Monad.Instances -- actually here I think
19:13:56 <lambdabot> Control.Monad.Instances -- actually here I think not available
19:13:57 <lambdabot> Terminated
19:13:58 <Cale> I think it should probably limit the output there.
19:14:02 <allbery_b> @source Control.Monad.Instances
19:14:03 <lambdabot> Control.Monad.Instances not available
19:14:08 <allbery_b> hrm
19:14:08 <Cale> What happened to the more module?
19:14:10 <nornagon> bd_: (>>=) = (.) ?
19:14:26 <mbishop> @quote
19:14:27 <lambdabot> emu says: hijack the stack and take this compiler to Fun-land!
19:15:07 <bd_> nornagon: hm, not quite. You have to distribute the environment parameter (the a in (a ->)) across both of the monads produced... that's a terrible way to explain it XD
19:15:13 <bd_> nornagon: Do you know about join?
19:15:15 <nornagon> XD
19:15:18 <nornagon> not so much.
19:15:20 <nornagon> @src join
19:15:21 <lambdabot> join x =  x >>= id
19:15:23 <bd_> heh
19:15:27 <bd_> :t join
19:15:28 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:15:28 <sorear> I can *quite easily* get lambdabot to consume infinite time.
19:15:28 <sorear> I won't even give a hint until it is fixable :(
19:15:46 <bd_> nornagon: Can you see how to implement join directly for the (a ->) monad?
19:15:47 <newsham> ?farber
19:15:48 <lambdabot> Unknown command, try @list
19:15:51 <nornagon> > join [[1,2],[3,4]]
19:15:52 <newsham> :(
19:15:53 <lambdabot>  [1,2,3,4]
19:16:03 <bd_> nornagon: neat, isn't it? :)
19:16:08 <newsham> ?type join (*)
19:16:08 <nornagon> bd_: you're breaking my head :<
19:16:09 <lambdabot> forall a. (Num a) => a -> a
19:16:11 <bd_> > join (Just (Just 4))
19:16:12 <lambdabot>  Just 4
19:16:14 <William1> hi
19:16:15 <William1> EXOTICS ADULT FORUM ::::::::::::::: http://exotics.ezbbforum.com ...
19:16:16 <William1> EXOTICS ADULT FORUM ::::::::::::::: http://exotics.ezbbforum.com ...
19:16:18 <William1> EXOTICS ADULT FORUM ::::::::::::::: http://exotics.ezbbforum.com
19:16:18 <William1> EXOTICS ADULT FORUM ::::::::::::::: http://exotics.ezbbforum.com
19:16:19 <lambdabot> Title: EXOTICS :: Index
19:16:20 <lambdabot> Title: EXOTICS :: Index
19:16:20 <lambdabot> Title: EXOTICS :: Index
19:16:20 <lambdabot> Title: EXOTICS :: Index
19:16:21 <newsham> > join (*) 3
19:16:22 <lambdabot>  9
19:16:29 <nornagon> eek.
19:16:34 <mbishop> Where's glguy's script? :P
19:16:37 <sorear> can we ban the turks yet?
19:16:38 <bd_> nornagon: Think of it like this: If a monad is like a box, then join takes a thing in a box in a box, and removes the inner box.
19:16:46 <aFlag> lambdabot: stop browsing pornography!
19:16:50 <nornagon> bd_: okay.
19:16:59 <bd_> nornagon: more importantly, what would the specific type of join be, if m is (a ->)?
19:17:23 <nornagon> join :: (a -> (a -> a)) -> (a -> a)?
19:17:26 <bd_> yep
19:17:32 <bd_> Now can you see how to implement it? :)
19:17:36 <bd_> wait
19:17:39 <bd_> yep
19:18:02 <nornagon> @djinn (a -> a -> a) -> (a -> a)
19:18:04 <lambdabot> f a b = a b b
19:18:08 <bd_> cheater! :P
19:18:10 <nornagon> :)
19:18:19 <nornagon> i had that, but i thought it'd be cooler to do it with djinn.
19:18:38 <nornagon> @src join
19:18:39 <lambdabot> join x =  x >>= id
19:18:40 <bd_> anyway, it turns out there's (in /theory/ but not in practice) two ways to define it: By defining return, fmap, and join, or by defining return and (>>=)
19:19:07 <bd_> now, the theory says either works
19:19:07 <bd_> but limitations in haskell typeclasses means only the latter can be literally done
19:19:27 <bd_> so, with (a ->), we have return = const, join f a = f a a. What would fmap be?
19:19:34 <nornagon> haskell's type system has limitations?! :O
19:19:38 <bd_> nornagon: yes :P
19:19:43 <nornagon> :t fmap
19:19:45 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
19:19:47 <bd_> Functor's in a different typeclass than Monad
19:19:53 <bd_> so we can't give a default >>=
19:19:56 <bd_> alas!
19:20:04 <nornagon> fmap :: (a -> b) -> (a -> a) -> (a -> b), right?
19:20:07 <nornagon> in this case
19:20:27 <bd_> nornagon: in this case, fmap :: (a -> b) -> (e -> a) -> (e -> b)
19:20:37 <bd_> careful with the names of your type variables :)
19:20:38 <nornagon> oh, right.
19:20:44 <nornagon> fmap f a = f a then?
19:20:51 <bd_> close
19:20:55 <nornagon> @djinn (a -> b) -> (e -> a) -> (e -> b)
19:20:56 <lambdabot> f a b c = a (b c)
19:20:59 <nornagon> oh.
19:21:02 <newsham> ?src (-> r) fmap
19:21:02 <lambdabot> Source not found. That's something I cannot allow to happen.
19:21:06 <bd_> f a b = a . b
19:21:08 <bd_> :)
19:21:12 <newsham> ?src ((->) r) fmap
19:21:12 <nornagon> yeah
19:21:13 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:21:23 <bd_> the only last step is to derive >>= from join and fmap
19:21:30 <bd_> if fmap :: (a -> b) -> m a -> m b
19:21:35 <bd_> and join :: m (m a) -> m a
19:21:42 <nornagon> :t (>>=)
19:21:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:21:46 <bd_> can you see how to get (>>=) :: m a -> (a -> m b) -> m b?
19:22:27 <nornagon> (>>=) = join . fmap?
19:22:42 <nornagon> ... wait
19:22:49 <bd_> /almost/
19:22:52 <Botje> :t join . fmap
19:22:54 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
19:22:55 <lambdabot>       Expected type: (a -> b) -> f a -> f a -> a1
19:22:57 <bd_> . only works with one additional argument
19:22:57 <nornagon> cool.
19:23:01 <bd_> but:
19:23:05 <bd_> (>>=) m f = join (fmap f m)
19:23:21 <bd_> and now we have our basic Reader monad.
19:23:23 <bd_> the last addition is
19:23:25 <bd_> ask = id
19:23:28 <bd_> asks f = f
19:23:29 <Botje> :t (join .) . fmap
19:23:31 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
19:23:36 <bd_> to allow us to query the 'environment' variable
19:23:58 <bd_> nornagon: Do you understand the reader monad now? >.>
19:24:16 <nornagon> i guess, but it'll need a little more settling in my brain :)
19:24:20 <bd_> nornagon: :)
19:24:28 <nornagon> it's almost a function-monad, or something
19:24:41 <bd_> nornagon: In terms of actual use, you'd use it when you have a complex computation, where you have some constant value you want it to refer to
19:25:11 <bd_> nornagon: There's a local function which lets you change the environment value locally too
19:25:18 <nornagon> zany
19:25:25 <bd_> nornagon: the canonical example is if you're writing some kind of interpreter - a reader monad can hold all the local variables
19:25:41 <bd_> you can then use asks to extract values, and local to add them
19:26:11 <nornagon> pretty cool.
19:26:15 <bd_> :)
19:26:27 <bd_> nornagon: As your next exercise, implement the Cont monad ;)
19:26:41 <bd_> ooh, or an arrow :P
19:27:09 <nornagon> :<
19:29:53 <sorear> Cont is fun
19:30:11 <sorear> in some sense that I can't make formal enough to avoid ridicule, it is the free monad
19:30:36 <chessguy> free?
19:30:50 <sorear> like free monoids and free groups
19:32:55 <chessguy> if i have a maximum allowable number of nodes, M, and i want any number from 1 to M to be uniformly possible, and any configuration uniformly possible, how do i construct such a binary tree? (just trying to work out an algorithm, not actual code [yet])
19:34:12 <sorear> @botsnack
19:34:12 <sorear> argh! not AGAIN!
19:34:12 <lambdabot> :)
19:34:20 <bd_> sorear: http://www-swiss.ai.mit.edu/~dae/notes/monads-algebra mentions a free monad
19:34:25 <bd_> not sure I understand it at all though
19:34:55 <sorear> it's ... categorical
19:35:18 <allbery_b> the bot is mocking you :)
19:35:20 <newsham> lambdabot is a great advocacy tool
19:35:32 <newsham> i have it running in some channels and people are getting curious about the haskell thing
19:36:31 * allbery_b has beentempted to start one up in #lopsa but the bot rules are a bit stricter over there
19:36:56 * chessguy almost does ?t #lopsa to see what it is
19:37:06 <bd_> chessguy: lopsa# you mean? :)
19:37:23 <allbery_b> over on cognet.  http://www.lopsa.org
19:37:27 <lambdabot> Title: League of Professional System Administrators | leagues ahead
19:37:34 <newsham> need to get some freetime soon to clean up silc code for lambdabot
19:38:48 <dons> sorear: have you used the {-# UNPACK #-} pragma?
19:38:54 <dons> that forces a field to be unpacked in place
19:39:37 <dons> sorear: are you using -O@ ?
19:39:39 <dons> -O2
19:40:16 <sorear> dons: no, just -O -funbox-strict-fields
19:40:23 <sorear> I'll try {-# UNPACK #-}
19:40:25 <newsham> dons: @farber ?
19:40:31 * sorear doubts it'll do any good
19:40:34 <sorear> newsham: @uptime ?
19:40:44 <newsham> @uptime
19:40:45 <lambdabot> uptime: 6d 5h 50m 3s, longest uptime: 6d 5h 50m 3s
19:41:00 <sorear> newsham: contrary to popular belief, the bot does NOT have dynamic plugin updating.
19:41:06 <sorear> the paper is lying :)
19:41:33 <glguy> do all of the adult forums spams come from 88.232.?
19:41:48 <LoganCapaldo> Almost
19:41:58 <LoganCapaldo> I'm pretty sure its all 88.
19:42:56 <newsham> hmm,  sent my patch in probably 6 days ago, just missed it!
19:42:57 <sorear> glguy: they all come from TurkTelecom
19:43:21 <coffee-mug> if the adult forums were actually good, we could keep 'em
19:43:22 <NichardRixon> sorear, then we should rewrite lambdabot in erlang!
19:43:29 <coffee-mug> but since they suck and require registration
19:43:33 <sorear> raise your hand if you are a productive Haskell using Turk!
19:43:37 <coffee-mug> let's ban them :)
19:43:47 * glguy already did a /who 88.232.
19:44:05 * glguy already instructed chanserv to kickban that "hostname"
19:44:12 <glguy> hostmask rather
19:44:33 <sorear> glguy: I think you need a wildcard there
19:44:40 <glguy> I did use one :)
19:44:46 <sorear> / /who 88.232. turns up nothing
19:44:52 <sorear> / /who 88.232.* turns up users
19:44:58 <glguy> two of them
19:45:01 <sorear> (3, and non-haskellers all)
19:45:04 <glguy> not in #haskell
19:45:48 <glguy> if they are serious about wanting to come to #haskell, they can get custom host aliases
19:45:57 <glguy> turkey/unaffiliated
19:46:45 <chessguy> so....any ideas about my binary tree question?
19:47:14 <sorear> dons: -O2 and explicit unboxing helps a little with the core ... 2 Int# and 5 lazy boxed Bool
19:47:40 <newsham> chess: i dont understand your question
19:47:58 <newsham> you want a binary tree, and you want to pull values out of it (in which way?) such that they are uniformly distributed?
19:48:25 <chessguy> newsham, i want to construct a binary tree. the tree may not contain more than M nodes. i want the size of the tree to be equally likely to be any number from 1 to M
19:48:39 <newsham> the size in nodes?
19:48:50 <chessguy> and i want every possible configuration to be equally likely
19:48:50 <chessguy> yes
19:49:15 <sorear> @tell dons -O2 and explicit unboxing helps a little with the core ... 2 Int# and 5 lazy boxed Bool
19:49:16 <lambdabot> Consider it noted.
19:49:20 <newsham> so you want a mapping from integers to trees.
19:49:34 <newsham> so that if you pick a random integer, you can get a random tree
19:49:57 <chessguy> mmmm
19:50:15 <chessguy> yes, but the interval of random integers isn't 1 to M, if that's what you're thinking
19:52:04 <chessguy> the interval would be from 1 to f(M), where f(n) is the number of trees of size n
19:52:36 <newsham> so there's one tree of size 1.
19:52:42 <newsham> there are two trees of size 2.
19:53:11 <newsham> 5 of size 3?
19:53:13 <chessguy> 5 of size 3
19:54:15 <dons> sorear: use Int instead of Bool perhaps?
19:54:16 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
19:55:01 <sorear> *rech*
19:55:24 <newsham> seems like an interesting problem :)
19:55:37 <sorear> If I can't use true/false I need wrappers ... which brings me back to the verbosity problem.
19:55:41 <newsham> http://citeseer.ist.psu.edu/161114.html
19:55:42 <lambdabot> Title: Generating Random Binary Trees - A Survey - Makinen (ResearchIndex)
19:55:52 <chessguy> aww, that's cheating :)
19:56:04 <newsham> yah, why would we want to draw on the history of human knowledge?
19:56:11 <chessguy> hehe
19:56:34 <sorear> *sigh*
19:56:38 <chessguy> sorry, i refuse to read a paper with a typo in the abstract
19:56:50 <newsham> want me to read it and blurt out the answer?
19:56:58 <chessguy> go for it
19:57:00 * sorear gets back to copy/paste programming
19:57:03 <chessguy> i'll probably read it anyway :)
19:57:14 <chessguy> but i had to complain, on principle
19:57:56 <newsham> heh, first equation is number of binary trees with n nodes and talks of numbering trees :)
19:59:29 <chessguy> oh of course, the nth Catalan number
20:00:03 <newsham> obviously! (didnt know the catalans knew math)
20:00:56 <chessguy> hmm, wonder how fast that grows
20:01:46 <sorear> Why is it that when Jim Karmaless asks a question on -cafe they get answers, while when I ask questions I get sympathy? :(
20:02:04 <sorear> 4^n iirc
20:02:09 <sorear> O(4^n)
20:02:15 <chessguy> awww, poor sorear
20:02:17 <monochrom> Your question is too hard.
20:02:17 <sorear> @google oeis catalan
20:02:20 <lambdabot> http://www.research.att.com/~njas/sequences/Sindx_Per.html
20:02:20 <lambdabot> Title: Index to OEIS (Section Per)
20:02:36 <sorear> did you only just get my complaint?
20:02:39 <chessguy> ouch, it's roughly exponential
20:02:50 <chessguy> sorear, who me?
20:03:01 <sorear> @botsack
20:03:02 <lambdabot> :)
20:03:17 <newsham> http://en.wikipedia.org/wiki/Catalan_number
20:03:17 <sieni> let's sack lambdabot!!!1!
20:03:23 <sorear> Oh I hate this lag problem...
20:04:00 <sorear> chessguy: everyone
20:04:00 <newsham> 4^n / (n^(3/2) sqrt(pi))
20:04:01 <monochrom> I love this lag problem.  It's like the "eye killer" game.  "Who is the murderer?" :)
20:05:24 <chessguy> newsham, like i said, roughly exponential :)
20:05:47 <newsham> odd that.. exponential growth in bin trees
20:06:27 <monochrom> Not odd at all.
20:07:01 <chessguy> newsham, ah, that paper deals with encoding binary trees
20:07:32 <xpika>  >foldr (.) id [replicate 2,replicate 10] $ '#'
20:07:37 <xpika> > foldr (.) id [replicate 2,replicate 10] $ '#'
20:07:38 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
20:07:38 <lambdabot>       Expected...
20:07:44 <xpika> can anyone fix that/
20:07:57 <sorear> xpika: s/(.)/($)/
20:08:08 <xpika>  >foldr ($) id [replicate 2,replicate 10] $ '#'
20:08:14 <xpika> > foldr ($) id [replicate 2,replicate 10] $ '#'
20:08:15 <lambdabot>  Couldn't match `a -> a' against `[a -> a]'
20:08:35 <sorear> nm
20:08:41 <sorear> xpika: upgrade to Epigram
20:08:46 <bd_> > foldr (.) id [concat . replicate 2, concat . replicate 10] $ '#'
20:08:47 <lambdabot>  Couldn't match `[a]' against `Char'
20:08:47 <xpika> lol
20:08:50 <bd_> > foldr (.) id [concat . replicate 2, concat . replicate 10] $ "#"
20:08:52 <lambdabot>  "####################"
20:09:15 <newsham> > ((replicate 2).id) '#'
20:09:17 <sorear> xpika: Haskell's type system Isn't strong enough to type a function whose listiness depends on the length of an imput list.
20:09:17 <lambdabot>  "##"
20:09:24 <newsham> > ((replicate 10).(replicate 2).id) '#'
20:09:26 <lambdabot>  ["##","##","##","##","##","##","##","##","##","##"]
20:09:39 <sorear> xpika: you need a dependent system as found in Epigram or Cayanee to do that
20:09:43 <xpika> lambdabot: bzzt
20:10:40 <newsham> ?type foldr (.) id [replicate 2, replicate 10]
20:10:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
20:10:42 <lambdabot>       Expected type: a -> a
20:10:52 <monochrom> The first "replicate 2" has type [Char]->[[Char]], the second "replicate 10" has type Char->[Char], can't be in the same list.
20:11:13 <xpika> monochrom: thanks
20:11:40 <monochrom> Similarly you can't foldr (.) id [show, negate] True
20:11:52 <monochrom> err s/negate/not/
20:12:49 <xpika> monochrom: is it posible to existentially qualify the list?
20:13:39 <xpika> or use a monad?
20:13:44 <monochrom> Yes but I doubt if it helps.
20:14:07 <newsham> you want a list of functions such that the input to one item in the list is the output of the previous item in the list?
20:14:14 <newsham> what type is that?
20:14:22 <olliej> ?seen ndm
20:14:23 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 11h 35m 4s ago, and .
20:15:22 <nornagon> newsham: an infinite type! :)
20:15:36 <nornagon> haskell should have those.
20:15:38 <bd_> nornagon: [a->a]
20:15:42 <sorear> infinite types are FUN
20:15:44 <bd_> nornagon: and you can if you use newtypes
20:15:51 <newsham> its not necessarily an "infinite type"
20:16:00 <nornagon> bd_: right:
20:16:01 * sorear has written a type inference engine for anonymous infinite types
20:16:05 <newsham> its just not a type that haskell can do
20:16:12 <nornagon> > pipeline [(+2),(*3),(-1)] 1
20:16:13 <lambdabot>   Not in scope: `pipeline'
20:16:15 <nornagon> blah.
20:16:19 <nornagon> used to be there.
20:16:33 <sorear> nornagon: mconcat
20:16:38 <nornagon> > mconcat [(+2),(*3),(-1)] 1
20:16:39 <lambdabot>   add an instance declaration for (Num (a -> a))
20:16:40 <lambdabot>     In the list element: (- 1)
20:16:44 <sorear> also, don't try it on 6.6
20:16:46 <nornagon> > mconcat [(+2),(*3),((-)1)] 1
20:16:48 <lambdabot>  2
20:17:00 <nornagon> that's, uh, backwards.
20:17:14 <newsham> > ((-) 1) 3
20:17:16 <lambdabot>  -2
20:17:54 <monochrom> Oh, people have strong religious preference concerning right-to-left vs left-to-right... :)
20:18:03 <nornagon> > (mconcat . reverse) [(+2),(*3),((-)1)] 1
20:18:05 <lambdabot>  -8
20:18:15 <monochrom> They fight "intuition wars" over that.
20:18:27 <newsham> norn:  ((-)1)   ?
20:18:30 <monochrom> After a while you just think endian wars are better pastimes.
20:18:33 <nornagon> monochrom: how about start-to-finish? :)
20:18:56 <nornagon> a list has a clear start, no matter how you define show.
20:18:56 <newsham> > (subract 1) 3
20:18:57 <lambdabot>   Not in scope: `subract'
20:19:06 <nornagon> > (-) 1 3
20:19:07 <lambdabot>  -2
20:19:18 <nornagon> hm, flip (-) then :)
20:19:27 <newsham> > (sub 1) 3
20:19:28 <lambdabot>   Not in scope: `sub'
20:19:32 <nornagon> > (mconcat . reverse) [(+2),(*3),((flip (-))1)] 1
20:19:34 <lambdabot>  8
20:19:46 <newsham> > (minus 1) 3
20:19:47 <lambdabot>   Not in scope: `minus'
20:19:52 <newsham> grr.. isnt there a function?  i cant remember
20:19:54 <nornagon> :t subtract
20:19:56 <lambdabot> forall a. (Num a) => a -> a -> a
20:20:00 <newsham> oh, i mispelled
20:20:02 <nornagon> not subract :)
20:20:12 <newsham> ?spell subract
20:20:14 <lambdabot> subtract bract subject subtracts subtracter
20:20:19 <newsham> bot shoulda fixed it! ;-)
20:21:23 <monochrom> @botfix
20:21:24 <lambdabot> Unknown command, try @list
20:21:27 <newsham> > (1 (-)) 3
20:21:28 <lambdabot>   add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
20:21:28 <lambdabot>     In the...
20:34:13 <TSC> > (1 `subtract`) 3
20:34:15 <lambdabot>  2
20:34:42 <LoganCapaldo> > flip subtract 1 3
20:34:44 <lambdabot>  -2
20:34:57 <LoganCapaldo> hmm
20:35:07 <LoganCapaldo> > flip flip subtract 1 3
20:35:08 <lambdabot>   add an instance declaration for (Num (a -> (a1 -> a1 -> a1) -> c))
20:35:19 <TSC> > 1 `subtract` 3
20:35:21 <lambdabot>  2
20:35:26 <LoganCapaldo> > flip . flip subtract 1 3
20:35:27 <lambdabot>   add an instance declaration for (Num (a1 -> a -> b -> c))
20:35:38 <LoganCapaldo> > flip $ flip subtract 1 3
20:35:39 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
20:36:19 <LoganCapaldo> > (flip . flip) subtract 1 3
20:36:21 <lambdabot>  2
20:36:51 <LoganCapaldo> > subtract 1 3
20:36:53 <lambdabot>  2
20:37:10 <LoganCapaldo> That doesn't strike anyone else as backwards?
20:37:15 <gotaku> How would I read a Word32 from a file?
20:37:23 <LoganCapaldo> > flip subtract 3 1
20:37:25 <lambdabot>  2
20:37:38 <LoganCapaldo> oh I guess not
20:37:42 <dons> gotaku: read a bytestring, then shift off the 4 bytes
20:37:42 <LoganCapaldo> subtract 1 from 3
20:37:56 * LoganCapaldo wishes it was minus
20:38:20 <gotaku> Ok, thanks.
20:38:56 <sorear> dons: should I just use TH?
20:39:53 <dons> not very portable
20:40:46 <sorear> so ... I'm stuck writing a hundred lines of field access boilerplate by hand.  Yay.
20:42:21 <allbery_b> you could write a program to write the code :)
20:42:49 <LoganCapaldo> And then generalize it into some sort of code templating system :)
20:42:56 <LoganCapaldo> You could call it TH for short :)
20:42:58 <LoganCapaldo> Oh wait...
20:43:09 <LoganCapaldo> Not very portable is it?
20:43:19 * LoganCapaldo recurses
20:43:22 <allbery_b> TH (that is, templating built in to the compiler) is nonpotable
20:43:26 <allbery_b> the program could be H98
20:43:32 <allbery_b> nonportable
20:43:36 <sjanssen> you can't drink it?
20:43:40 * allbery_b doesn't think he'd drink TH anyway :)
20:43:52 <sorear> I'd *much* rather see GHC get support for Bool# .
20:44:02 <LoganCapaldo> allbery_b: Why don' you ruin the joke by bringing facts into the equation? :)
20:44:23 <jcreigh> So I guess there isn't a Template Haskell directive to dump the generated AST back into a .hs file, is there?
20:44:51 <heatsink> There's -ddump-splices
20:44:57 <sorear> is there a {-# STOP_ACTING_STUPID #-} pragma? :)
20:45:01 <heatsink> You have to copy it manually into the file
20:47:10 <sorear> I get the feeling that none of the mailing list gurus are responding for some profoundly simple reason that I have failed to grasp.
20:48:33 <heatsink> Wait, did you say that GHC doesn't unbox bool?
20:48:39 <sorear> yup.
20:48:40 <dons> I think it does actually
20:48:46 <dons> since Bool is handled specially in the compiler
20:48:49 <dons> check the C--
20:48:52 <sorear> tell that to my -ddump-simpl output
20:49:01 <dons> (GHC knows all the way down that Bool can be an Int#)
20:49:17 <dons> you need to check the next level past -simpl
20:49:24 <dons> i.e. what does the codegen do to Bool types
20:49:34 <dons> (it hsa to know about Bool since it introduces them during optimisation)
20:49:38 <sorear> dons: the simpl output is extremely lazy
20:50:04 <dons> an Word32 would make a better bit set, btw :)
20:50:08 <dons> or an UArray Int Bool
20:50:20 <sorear> dons: better than?
20:50:32 <sorear> also my type is heterogenous
20:50:38 <dons> a bunch of Bool fields
20:51:02 <sorear> dons: I'm trying to use Int but I'm allergic to copy/paste.
20:52:34 <sorear> dons: ok, I have the cmm - where's the type definition?
20:52:48 <sorear> or rather I know it doesn't exist; how do I reconstruct it?
20:53:01 <sorear> (why does GHC have to have a type erasure phase...)
20:56:45 <dons> heh
20:57:44 <sorear> I'm tempted to just expose the bitflags as constants
20:57:55 <LoganCapaldo> Because the mental image of a giant eraser running thru my source code erasing everything after :: is just too ridiculous for it not to have one?
20:58:42 <sorear> why is [type safety, speed, programmer sanity :: pick any two]?
20:58:52 <coffee-mug> all right
20:58:54 <coffee-mug> time to sleep
20:59:03 <ulfdoz> I have a design problem: There's parse-tree. I want to add anotations, thus I associated a type annotation with each possible node (tokens) in the parse-tree. When working with the parse-tree, annotations may change, thus I need something to encapsulate those "side-effects". Any ideas?
20:59:10 <coffee-mug> good night everyone
20:59:37 <sjanssen> sorear: maybe something like: newtype Field = Field Int; get :: Attr -> Field -> Bool; get (Attr a) (Field f) = a .&. f /= 0
20:59:43 <LoganCapaldo> I thought type safety excluded programmer sanity?
20:59:54 <sjanssen> ie. wrap the bitfield constants in a newtype, and introduce helper functions
21:00:02 * LoganCapaldo is less sane after Haskell
21:00:17 <sorear> sjanssen: oh, writing the functions is easy.
21:00:18 <sjanssen> you could even use a nice operator symbol instead of get/set
21:00:30 <sorear> sjanssen: I need 3 lines per function
21:00:33 <sorear> the code
21:00:45 <sorear> the type signature, since haddock is very dump
21:00:55 <sorear> the haddock comment
21:01:49 <sorear> four, if you count the blank line the stops the contents of my brain from swirling together like sewage under sodium illumination
21:02:23 <dons> i'm really happy with this, got the hashtable down to 2x C
21:02:25 <dons> instead of 20x
21:02:32 <sjanssen> we're talking LOC per field in the attribute, yeah?
21:02:40 <sorear> sjanssen: yes
21:02:56 <sorear> sjanssen: oh yea and I need is/set/clear/toggle
21:03:04 <sorear> that's ... 16 loc per field
21:03:08 <sjanssen> with my system, you have 1 LOC (plus an optional blank line) per field
21:03:21 <sorear> sjanssen: what about haddock?
21:03:44 <sorear> where will it eat?
21:03:59 <sjanssen> okay, and an extra line for typesigs
21:04:08 <sjanssen> then you can abstract out the get/set/clear/toggle
21:04:23 <dons> https://alioth.debian.org/tracker/index.php?func=detail&aid=304444&group_id=30402&atid=411646
21:04:25 <lambdabot> http://tinyurl.com/yryrj5
21:04:28 <dons> get 'cha hashtables here!
21:05:14 <dons> that should really help wipe off 1/4 of our problematic submissions
21:05:29 <dons> now just regex-dna, and the two numerics problems: nbody and spectral-norm
21:08:50 <dons> the thing that has really struct me over the last 3 days is how much better performance we're getting from ghc 6.6 than from 6.4.1
21:09:16 <sjanssen> !paste
21:09:31 <sjanssen> @paste
21:09:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:09:39 <sjanssen> hpaste is down ?!?!
21:10:32 <dons> wow
21:10:33 <dons> The server is temporarily unable to service your request due to maintenance downtime or capacity problems.
21:10:36 <dons> glguy: !!
21:10:42 <glguy> ?
21:10:53 <sjanssen> sorear: ^^^
21:11:15 <dons> glguy: ?
21:11:21 <sjanssen> erm, don't look up, look down! http://paste.lisp.org/display/36455
21:11:24 <glguy> I'm checking into it
21:11:25 <glguy> !paste
21:11:25 <jcreigh> I though happs was its own webserver...
21:11:28 <jcreigh> *thought
21:11:59 <dons> apache is a proxy over to port ;8000 iirc
21:12:04 <jcreigh> ah
21:12:05 <sorear> jcreigh: I suspect the entire machine is down?
21:12:10 <sjanssen> sorear: this is a bit of a hack, essentially emulating your own record system, but it seems that it'd work
21:12:50 <glguy> eric@kakapo:~$ uptime
21:12:50 <glguy>  00:09:07 up  1:03,  2 users,  load average: 0.04, 0.01, 0.00
21:12:53 <xpika_> can you serialize functions in haskell?
21:12:55 <glguy> looks like the machine was rebooted
21:13:02 <dons> xpika_: not directly
21:13:09 <dons> (you mean like:   encode (\x -> x)
21:13:15 <dons> would give you a bytestring representing a function?
21:13:17 <xpika_> yep
21:13:29 <sorear> xpika_: sure! get unsafeCoerce# and hPutBuf handy!
21:13:29 <dons> no easy way
21:13:40 <sorear> xpika_: *de*serializing is much trickier
21:13:51 <dons> we call it 'compiling' :)
21:14:16 <jcreigh> xpika_: sure!
21:14:21 <hpaste>  sjanssen pasted "bitfield" at http://hpaste.org/332
21:14:28 <jcreigh> > "\x -> x + 2"
21:14:28 <lambdabot>  Illegal escape sequence
21:14:33 <jcreigh> > "\\x -> x + 2"
21:14:34 <lambdabot>  "\\x -> x + 2"
21:14:37 <jcreigh> :)
21:15:31 <jcreigh> I don't know of any serious implementation of function serialization (ie, people actual use it, not just proof of concept) in any language.
21:15:33 <sjanssen> xpika_: the two major Haskell implementations can't serialize functions, but an implementation that can isn't inconceivable
21:16:03 <jcreigh> ...not to say it doesn't exist.
21:16:23 <heatsink> jcreigh: There was an MMO written in Python where the client downloads most of the code at runtime.
21:16:36 <sorear> instance (Enum a, Bounded a, Binary b) => Binary (a -> b) where ...
21:16:36 <allbery_b> pugs serializes its prelude via syck, actually.
21:16:44 <allbery_b> of course, pugs isn't released yet
21:16:58 <dons> for example, you could send ghci bytecode
21:17:02 <dons> should be trivial (almost) to serialise in an interpreter
21:17:03 <dons> just show the AST
21:17:19 <xpika_> function :: (a -> b) -> ghc bytecode
21:17:25 <jcreigh> heatsink: are we talking .pyc files here? Or something like serialize(lambda x: x*x)?
21:17:39 <sjanssen> sorear: what do you think about my suggestion?
21:18:13 <sorear> sjanssen: haven't seen the Code, hpaste was down...
21:18:17 <heatsink> jcreigh: I don't know.  It could have been serialized bytecode.
21:18:35 <heatsink> Python's internal representation of functions is kind of heavyweight, so it wouldn't be so hard to do that.
21:20:14 <sorear> sjanssen: nice ... but I also have two Word8 fields :)
21:20:47 <sjanssen> hmm
21:21:14 <sjanssen> why not use actual fields for those Word8s?
21:21:40 <heatsink> jcreight: It just came to mind as a non-illegal use for (de)serializing executable code in a running program.
21:21:45 <sjanssen> it's attractive to pack everything into a single machine word, but is it really worth the effort?
21:22:43 <sorear> sjanssen: well, a loop performing equality on this datatype consumes 50% of yi's runtime
21:22:50 <sorear> and dons has declared yi Too Slow
21:22:54 <sorear> (and I agree)
21:23:05 <sjanssen> okay
21:23:15 <sjanssen> my system could be extended with typeclasses
21:24:23 * sorear decides sjanssen's solution is too clever and opts to eliminate the getters entirely
21:24:52 <sjanssen> you're going to export the bitmasks?
21:26:05 <sorear> no, I'm gonna make the datatype write-only
21:27:14 <dons> ?users
21:27:21 <lambdabot> Maximum users seen in #haskell: 322, currently: 277 (86.0%), active: 37 (13.4%)
21:27:39 <dons> ?uptime
21:27:40 <lambdabot> uptime: 6d 7h 37m, longest uptime: 6d 7h 37m
21:28:07 * heatsink wishes someone would comment about handling large mutable data structures
21:28:29 <dons> they're not too hard, but not trivial
21:28:34 <sorear> by mutable you mean threaded with STRefs?
21:28:47 <sorear> /Ptrs?
21:29:01 <dons> what other kinds of comments would you like? :)
21:29:04 <dons> its a lot easier to write fast code with mutable arrays than it was a year ago
21:29:58 <heatsink> I mean given a data structure that you want to implement that you know will be large and (conceptually) mutable, how do you implement it so that you can avoid too much chasing down of space leaks and still have reasonably composable pieces?
21:30:24 <dons> space leaks?
21:30:47 <dons> you do it in IO. spacee leaks are no special problem
21:30:50 <heatsink> From updates that are sitting as closures.
21:30:56 <heatsink> unevaluated closures.
21:30:58 <dons> strict fields
21:31:04 <sorear> the solution is to restrict yourself to glasgow haskell
21:31:06 <dons> make sure they're evaluated.
21:31:19 <sorear> then when things break you cna use the glasgow profiler
21:31:44 <dons>  here's a swishy hashtable that seems competive with C for the 10M files i've tried it on. http://haskell.org/haskellwiki/Shootout/Knucleotide#Custom_HashTable_.2B_ByteStrings
21:31:50 <lambdabot> Title: Shootout/Knucleotide - HaskellWiki, http://tinyurl.com/2ecfpc
21:32:05 <dons> lots of mutable data there. nothing terribly hard to do, 'cept to make sure things are strict in the update
21:32:24 <dons> there's really no conceptual or technical problems to efficient mutable data in haskell
21:32:50 <dons> so i'm not sure what your concern is heatsink. is it just a worry? or do you in practice have a problem with some code?
21:34:16 <dons> i notice you asked this a few days ago, you could have written debugged and optimised the code by now :)
21:34:43 <heatsink> Well, I do have a problem with some code.  What I'd like to do is to learn some ways to avoid space leaks before they happen :)
21:35:02 <dons> i just use -fbang-patterns and strict fields
21:35:16 <dons> and then if i find a leak, i profile, insert some strictness to fix it, and repeat
21:35:30 <dons> usually only takes 1 or 2 iterations
21:35:44 <dons> then, for tuning futher, i enter a -ddump-simpl phase
21:35:55 <dons> where i read the core for specific functions, if its not good enough, i tune it, and repeat
21:35:59 <dons> until the core looks good
21:36:10 <dons> then sometimes i check the asm for key inner loops
21:36:14 <dons> though that's pretty rare
21:36:31 <dons> (if the asm is bad, i might manually write the unboxed primop code for the inner loop)
21:37:11 <dons> this is all assuming you have the right data structures and algorithms
21:37:14 <dons> since they'll matter more
21:39:08 <heatsink> So, right now I'm using a data structure containing some lists and IntMaps, and it's a bit awkward to force the contenst of those.
21:39:22 <sorear> heatsink: rnf?
21:39:34 <heatsink> wha?
21:39:34 <sorear> @index uncheckedShiftL
21:39:35 <lambdabot> bzzt
21:39:54 <sorear> > Control.Parallel.Strategies.rnf [ 2,3,4,5 ] `seq` 2
21:39:55 <lambdabot>   Not in scope: `Control.Parallel.Strategies.rnf'
21:40:01 <sorear> > Control.Paralell.Strategies.rnf [ 2,3,4,5 ] `seq` 2
21:40:02 <lambdabot>   Not in scope: `Control.Paralell.Strategies.rnf'
21:40:08 <sorear> @spell Parallel
21:40:08 <lambdabot> Parallel
21:40:22 <sorear> anyway, ignore the module name
21:40:31 <sorear> it has nothing to do with parallelism
21:40:46 <sorear> but it forces data deep inside e.g. intmaps
21:41:04 <heatsink> reduce to normal form?
21:41:09 <sorear> yes
21:41:17 <heatsink> ok.  Is it builtin?
21:41:23 <sorear> heatsink: no
21:41:29 <dons> there are some strict insertion functions for IntMap now
21:41:32 <dons> and Map, I believe
21:41:44 <dons> but that's not mutable data
21:42:04 <chessguy> ?hoogle MonadRandom
21:42:05 <lambdabot> No matches found
21:42:37 <heatsink> dons: By mutable I meant that I'm using it in a mutable manner, not that it's implemented in a mutable way.
21:42:39 <sorear> ?google MonadRandom
21:42:42 <lambdabot> http://haskell.galois.com/~paolo/darcs/nymphaea/MonadRandom.hs
21:42:52 <sorear> it's also on the wiki
21:43:18 <heatsink> sorear: rnf should be helpful, thanks.
21:43:22 <chessguy> how come it hasn't been added to the base yet?
21:43:24 <dons> heatsink: you mean you're doing a lot of updates on a purely functional structure?
21:43:33 <heatsink> dons: currently, yes.
21:43:48 <dons> (note there's insert' and friends now, for strict updates (i.e. nodes are forced)
21:43:56 <dons> and you can always use DeepSeq or similar to force before you insert
21:44:05 <geekagent> has anyone else had problems with slow random number generation?
21:44:26 <heatsink> I've been thinking about using something like a hash table, but worried I'll lose some capability if I put things in IO.
21:44:26 <dons> geekagent: using what random generator?
21:44:28 <dons> System.Random?
21:44:38 <geekagent> yeah, System.Random, ghc 6.6
21:44:51 <dons> (if your app relies on randoms, there's some bindings to the mersenee prime lib which should help)
21:44:57 <dons> have you profiled?
21:45:16 <heatsink> Me? yes.
21:45:19 <dons> System.Random is pretty good for all but the most demanding situations
21:45:31 <geekagent> yeah, I have profiled. It's a quick/hull algorithm spends about 90% of it's time generating random numbers
21:45:42 <geekagent> I'll paste the code if you'd like
21:45:48 <dons> ok. i recommend using the mersenne twister bindings then
21:46:02 <dons> (i had to do that for a monte carlo simulator)
21:48:09 <dons> since you can just call the mersenne functions directly over the ffi
21:48:16 <dons> are you able to find the src to do this?
21:49:27 <glguy> does anyone know how to set up a crontab to run a program with a specific current directory
21:49:37 <sorear> (cd foo ; bar)  :)
21:49:42 <dons> cd foo ; ..
21:49:42 <glguy> I'm going to add an @reboot line for hpaste
21:49:49 <geekagent> I found haskell mersenne sources, I'll let you know that goes
21:50:12 <dons> it would be only marginally harder to use the C srcs
21:50:14 <dons> (that's what i did)
21:50:33 <geekagent> I'd have to download gcc for windows and compile them.
21:51:28 <glguy> eric@kakapo:~$ crontab -l
21:51:28 <glguy> # m h  dom mon dow   command
21:51:28 <glguy> @reboot (cd /home/eric/pastebot; ./hpaste)
21:51:29 <lambdabot> Unknown command, try @list
21:51:32 <glguy> look right?
21:51:43 <glguy> I can't really test this
21:52:30 <jcreigh> is @reboot a standard crond thing?
21:52:51 <nrb23> anyone familiar with the pcap stuff from the networktools?
21:53:07 <glguy> jcreigh: no idea, but  Ifound it in man 5 crontab on this machine
21:53:12 <dons>  seems a bit weird
21:53:35 <glguy> Instead of the first five fields, one  of  eight  special  strings  may appear:
21:53:44 <ibid> jcreigh: it's a vixie cron extension
21:53:53 <jcreigh> ibid: ah, okay
21:59:34 <blackdog> so, cabal question
21:59:39 <blackdog> i try to install something
21:59:57 <blackdog> it informs me i'm missing a dependency (HaXML in this case)
22:00:13 <blackdog> is my next step some clever apt-get-ish thing, or plain old google-and-try-again?
22:00:46 <hyrax42> what system?
22:01:04 <blackdog> macos. (am trying to install HAppS)
22:01:08 <allbery_b> I think right now it's google, although hackage is coming along
22:01:17 <hyrax42> do you run darwinports?
22:01:28 <hyrax42> or are you building everything yoruself?
22:01:55 <blackdog> no, i use ... ah, crap. you know, the apt-get drop-in one. name escapes me
22:02:02 <allbery_b> fink?
22:02:04 <hyrax42> fink
22:02:04 <blackdog> but most haskell stuff i'm just installing from source
22:02:07 <blackdog> that's the one
22:02:09 <hyrax42> ah ok
22:02:13 <allbery_b> http://hackage.haskell.org btw
22:02:15 <lambdabot> Title: HackageDB: introduction
22:02:28 <hyrax42> j that haxml happens to be in darwinports
22:02:30 <allbery_b> that will, eventually, let you do fancy installs a' la cpan or ruby-gems
22:02:40 <blackdog> i mean, installing from source is no problem, but it's a bit stone-age for such a thoroughly modern language :)
22:02:48 <hyrax42> but you'd have to have built ghc through darwinports too
22:02:58 <blackdog> yeah, fair enough.
22:03:06 <hyrax42> so it's a google for you, unless fink has it
22:03:11 <hyrax42> and you installed ghc through fink
22:03:24 <allbery_b> hackage has it :)
22:03:28 <hyrax42> whi is involved with hackage?
22:03:37 <hyrax42> *who
22:03:45 <allbery_b> hackage is the next-gen cabal
22:04:24 <allbery_b> which will eventually let you install with automatic dependency following etc.
22:06:02 <hyrax42> happs is in there to it looks like
22:07:45 <sorear> dons: yay! -> GHC.Prim.Int#  -- in a Core type signature, the slot where the attr goes
22:07:58 <dons> cool
22:10:55 <kolmodin> morning!
22:11:10 <sorear> now I just get to ... fix yi and re-profile
22:16:04 <dons> morning kolmodin
22:16:18 <gotaku> Ok, I'm trying to implement the  ICFP 2000 contest's UM in Haskell but I'm confused about how to handle the arrays.
22:16:25 <gotaku> 2006 rather
22:17:27 <skew> IOUArray works pretty well
22:18:50 <sorear> yi feels faster...
22:19:11 <sorear> but the profile says no difference.
22:19:20 <sorear> goodnight.
22:20:04 <sorear> skew: no
22:20:15 <sorear> skew: IOUArray only works on primitive types
22:20:28 <sorear> skew: I want to keep my abstraction!
22:20:39 <skew> The UM works in 32 bit words
22:20:57 <kolmodin> hia dons, hacked all (my) night long? :)
22:21:05 <sorear> skew: oh, sorry, thought you were talking to me. :)
22:22:22 <gotaku> skew: Thanks.
22:24:14 <dons> kolmodin: yeah, wrote a fast hashtable
22:24:23 <kolmodin> ST, IO?
22:24:54 <kolmodin> how about someone write a pure read-only hashtable? that would be useful too
22:25:02 <dons> its in IO, but could be ST (compiles down to ST), runs around 2x C, instead of Data.HashTable (20x C), https://alioth.debian.org/tracker/index.php?func=detail&aid=304444&group_id=30402&atid=411646
22:25:03 <lambdabot> http://tinyurl.com/yryrj5
22:25:08 <dons> yeah, would be posisble
22:25:19 <skew> oh, 2x slower?
22:25:39 <dons> yeah, 2x slower than the C entry (but everything is two times slower than C in this problem)
22:25:46 <skew> if it's you, you need to specify which direction
22:26:05 <kolmodin> dons: oh, it's for the shootout :)
22:26:06 <dons> C x 2 :)
22:26:09 <kolmodin> I should have known :)
22:26:11 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=all
22:26:14 <lambdabot> Title: k-nucleotide benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/mnnkb
22:26:33 <dons> so I think it should drop into about hmm, somewhere round SML or better
22:27:27 <dons> we'll see if that's enough to get close to Clean overall
22:28:17 <kolmodin> dons: hey, are you toutching the pure bytestrings in io? :)
22:28:49 <dons> umm. don't look
22:29:03 <blackdog> ignore the man behind the curtain
22:29:03 <skew> hey, what about hs-plugins?
22:29:03 <dons> well, its not too bad
22:29:21 <dons> they're all just Ptrs to the single input bytestring
22:29:29 <dons> skew, yeah? its ported to ghc 6.6
22:29:33 <dons> what else do you want? :)
22:29:42 <skew> I just grabbed the 1.0-rc archive, and I'm getting a parse error in Typeable
22:29:49 <dons> grab the darcs repo
22:31:39 <glguy> 209K Feb  6 01:10 checkpoint-0000000972
22:31:43 <glguy> 1/5 of the way there :)
22:31:51 <skew> I saw the same thing when I updated an old repo. New repo seems to work
22:32:17 <glguy> (That isn't a challenge!)
22:38:04 <skew> seems to actually work
22:39:18 <dons> that's a surprise
22:39:25 <dons> its fairly untested, but most of the test suite runs
22:39:32 <dons> so most uses should be ok, i think
22:39:35 <skew> well, I can evaluate "1" anyway
22:39:40 <dons> good
22:39:55 <dons> the tricky stuff might be plugins with funny depends
22:41:20 <gotaku> What's a space leak in Haskell?
22:41:25 <glguy> LAWL at this guy on the public tv station, interviewing P J O'Rourke about his book "On the wealth of nations" he asks o'rourke "why do I owe a *shout out* to Adam Smith"
22:45:56 <dons> gotaku: ausually a loop that isn't strict in its accumulator, and thus builds up a long chain of unevaluated results.
22:46:58 <hpaste>  skew pasted "why does this terminate?" at http://hpaste.org/333
22:47:11 <dons> e.g
22:47:14 <dons> > foldl (+) 0 [1..1000000]
22:47:16 <lambdabot>  Exception: stack overflow
22:47:18 <dons> lazy accumulator
22:47:21 <dons> > foldl' (+) 0 [1..1000000]
22:47:23 <lambdabot>  500000500000
22:47:24 <dons> strict accumulator
22:48:05 <skew> dons? Is this maybe something to do with funny depends?
22:48:09 <dons> if you generalise this situation to arbitrary loops or lazy datastructures with lots of updates, that aren't demanded for a long time, you can get a space leak. usually they're glaringly obvious, nand easy to fix
22:48:47 <dons> heh. nasty
22:48:59 <dons> i'm not sure
22:49:07 <skew> hmm, maybe saying the result is () has something to do with it
22:49:07 <dons> you'd have to compile with -DDEBug
22:49:14 <dons> ah yes
22:49:27 <skew> that says Just ""
22:49:28 <dons> still, you want to dyn link the dynamic linker
22:49:30 <dons> could be tricky
22:49:43 <skew> sure, I expected it would loop or explode
22:49:50 <dons> or melt the cpu
22:49:53 <dons> that's another optoin
22:50:28 <skew> hmm, at type Int it comes up with Just 131073
22:50:42 <vincenz> moin
22:51:28 * dons laughs at chalmers and utrecht fighting for smart masters students on haskell-cafe@
22:53:00 <skew> I was wondering about the logical strength of eval recently
22:53:21 <dons> i've done some loops like this, a long time ago
22:53:27 <dons> but its a bit tricky on the dynamic linker
22:53:31 <dons> so i'm not too surprised if it breaks
22:53:34 <skew> it seems like it might actually have something to do with inaccessible cardinals
22:53:42 <dons> hmm, not sure about that :)
22:53:47 <dons> more about inaccessible pointers ;)
22:54:03 <dons> there is some modal logic at play though
22:54:14 <dons> if you want to understand what it means to splice at runtime, and when that is safe
22:54:22 <skew> well, an inacessible cardinal happens to be a model of ZFC with not quite as strong an inacessible cardinal
22:57:36 <skew> adding eval to a language like Epigram, that is
23:01:13 <skew> hi roconnor
23:01:40 <nornagon> @djinn a -> Maybe a
23:01:40 <lambdabot> f = Just
23:01:58 <skew> nice TMR article
23:02:14 <dons> yeah, lots of blog noise regarding TMR
23:02:18 <dons> very good
23:02:24 <nornagon> TMR?
23:02:28 <dons> (though methinks we need html presentation for non-core readers)
23:02:29 <nornagon> @where TMR
23:02:29 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
23:02:36 <skew> I like the advice about avoiding the temporal security agency.
23:03:38 <geekagent> Hmm, the mersenne twister only uses about 80% of the cpu time instead of the 90 that the system uses
23:03:54 <nrb23> I don't understand what's wrong with this line: foreign import ccall unsafe pcap_open_offline :: Ptr CChar   -> Ptr CChar -> IO (Ptr PcapTag)
23:04:13 <nrb23> any ideas?
23:04:15 <skew> I'm pretty sure the string part is requires
23:04:51 <nrb23> ?
23:04:58 <skew> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3
23:05:00 <lambdabot> Title: 3 Foreign Declarations, http://tinyurl.com/yezf7t
23:06:05 <skew> like, foreign import ccall unsafe "pcap.h pcap_open_offline" pcap_open_offline :: ....
23:06:42 <nrb23> hm
23:07:01 <dons> geekagent: is that the C or Haskell one?
23:07:11 <geekagent> Haskell
23:07:17 <dons> (The haskell one was a demo, at least lennart's one was)
23:07:21 <dons> i.e. not designed for spped..
23:07:24 <geekagent> I guess I'll have to do it in C
23:07:39 <dons> just call the mersenne. lib that's already out there
23:07:40 <nrb23> foreign import ccall unsafe "pcap.h pcap_open_offline" pcap_popen_offline :: Ptr CChar   -> Ptr CChar -> IO (Ptr PcapTag)
23:07:42 <dons> its a 2 line ffi binding
23:07:46 <nrb23> still get an error message
23:07:49 <dons> i've got the code handy.. let me find it ...
23:07:58 <dons> newsham: around?
23:08:11 <dons> got that mersenne twister binding somewhere?
23:08:16 <geekagent> dons: yeah, It's lennart's
23:08:29 <dons> not that one
23:08:35 <dons> the C library, with a Haskell ffi binding
23:08:40 <geekagent> OK, I won't use that one
23:08:45 <dons> oh?
23:08:49 <skew> nrb23: what is the error?
23:08:52 <dons> its much faster, that's the one I use.
23:08:59 <nrb23> skew: Pcap.hsc:264:8: parse error on input `import'
23:09:07 <geekagent> No, I won't use lennart's if it's slower.
23:09:22 <nrb23> skew: it's also possible my .cabal file is stupid
23:09:29 <dons> geekagent: no, use the C binding, there's an example in here, http://www.isecpartners.com/files/fileh.zip
23:09:48 <nrb23> I got the source from http://www.haskell.org/networktools/src/pcap/
23:09:50 <lambdabot> Title: Index of /networktools/src/pcap
23:10:02 <dons> (mtrandom.c is the C code, FastRand.hs is the bidning)
23:10:51 * vincenz is off to his communication course
23:11:47 <skew> whoa, "`show' is not a (visible) method of class `Show'", building Data/Generics/Basics.hs
23:12:12 <vincenz> http://www.geekculture.com/joyoftech/joyarchives/920.html
23:12:13 <lambdabot> Title: The Joy of Tech comic... laughter is the best tech support.
23:12:18 <nrb23> well, I have to go to bed
23:13:16 <nrb23> I guess i'll have to beat on this more tomorrow
23:13:18 <nrb23> 'night
23:21:59 <nornagon> mm, i'm reading TMR 6 now
23:22:01 <nornagon> good stuff
23:28:15 <blackdog> any HAppS hackers around?
23:28:58 <dons> blackdog: check on #happs ?
23:29:08 * blackdog slaps head
23:29:11 <blackdog> yeah, good idea. :)
23:29:15 <dons> we have channels for our haskell apps now
23:29:21 <dons> #darcs, #perl6 and #happs :)
23:29:30 <skew> how about GHC hackers?
23:29:39 <dons> oh yeah, and #ghc
23:29:57 <dons> blackdog: did you see hpaste.org?
23:30:01 <dons> that's a nice little demo happs app
23:30:16 <blackdog> haven't looked into it yet
23:30:17 <dons> for those of you with real jobs, but lambda sensibilities
23:30:22 <blackdog> still trying to get it set up
23:30:33 <blackdog> but i've realised i just need to pull the latest version
23:30:37 <blackdog> ah well
23:30:55 <dons> blackdog: so you got the thai and dubai hackers all onto haskell now??
23:31:06 <blackdog> ha
23:31:18 <dons> or is it too hot?
23:31:20 <blackdog> there aren't a lot of hackers in doha
23:31:26 <dons> (why does haskell do well near the arctic circle?)
23:31:39 <blackdog> i'm in chiang mai again now - nice and cool
23:31:41 <blackdog> comparatively speaking
23:32:08 <dons> i had a brief stop over in bangkok when, 2 weeks ago?, and it was 40 something
23:32:09 <dons> oh man
23:32:41 <blackdog> bangkok is invariably awful. :)
23:32:54 <dons> the new airport is very swishy though
23:33:06 <blackdog> suvarnabhuni?
23:33:12 <blackdog> people are bitching about it mightily
23:33:18 <dons> i think that's it. the glass and steel one
23:33:32 <dons> with the signs that say 'long live the king' everywhere
23:33:34 <blackdog> something about it being built on a swamp a million miles from the city :)
23:33:38 <blackdog> ha
23:33:43 <blackdog> they're everywhere, everywhere
23:34:02 <dons> hehe
23:34:09 <dons> monarchies rule!
23:34:13 <blackdog> it's dangerous
23:34:22 <blackdog> it always makes me think of the sex pistols
23:34:29 <dons> heh
23:34:34 <blackdog> and joking about the monarchy is Not Done
23:34:41 <blackdog> same thing in Doha
23:34:44 <dons> that might be culturally insensitive
23:35:22 <blackdog> just a bit
23:39:39 <nornagon> hm, Dan Piponi's article lost me :)
23:50:32 <careo> the same bankgok airport with the golf course going through it? or is there a newer one since?
23:50:42 <dblhelix> @hoogle Int -> Int
23:50:44 <lambdabot> Test.QuickCheck.configSize :: Config -> Int -> Int
23:50:55 <dblhelix> @hoogle Float -> Float
23:50:56 <lambdabot> No matches, try a more general search
23:52:50 <heatsink> There we go.
23:53:22 * heatsink got some good improvement through manually pipelining this thing 
23:54:13 * heatsink shall celebrate by going to sleep!
