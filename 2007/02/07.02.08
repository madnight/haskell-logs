00:00:11 <mbishop> > exp 1
00:00:12 <lambdabot>  2.718281828459045
00:00:23 <nmessenger> > sqrt (-1)
00:00:24 <lambdabot>  NaN
00:00:36 <nmessenger> @where imports
00:00:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/Pristine.hs
00:00:37 <newsham> should rank these by the amount of entropy (ie. how many bits in the numerator+denominator vs. how many bits of accuracy for pi)
00:00:39 <mbishop> > 3 / 0
00:00:41 <lambdabot>  Infinity
00:00:58 <newsham> > let x = 1 :+ 2 in x*x
00:01:00 <lambdabot>  (-3.0) :+ 4.0
00:01:08 <nmessenger> @index (:+)
00:01:09 <lambdabot> Data.Complex
00:02:56 <newsham> > length $ takeWhile ((<= 2.0).magnitude) $ take 256 $ iterate (\x -> x*x + (0.1 :+ 1.3)) 0
00:02:58 <lambdabot>  2
00:03:08 <newsham> > length $ takeWhile ((<= 2.0).magnitude) $ take 256 $ iterate (\x -> x*x + (0.1 :+ 0.9)) 0
00:03:10 <lambdabot>  5
00:03:25 <newsham> mandelbrotsville
00:03:52 <nmessenger> why the (takeWhile (...) . take 256)?
00:05:47 <newsham> > length $ takeWhile ((<= 2.0).magnitude) $ take 256 $ iterate (\x -> x*x + (0.1 :+ 0.1)) 0
00:05:49 <lambdabot>  256
00:06:19 <newsham> values in the mandelbrot set cycle infinitely without ever growing larger than 2.0 (and going off to infinity)
00:06:32 <newsham> 256 is an artificial cap
00:06:45 <newsham> a pragmatic stand-in for Infinity
00:07:16 <nmessenger> oh, I didn't recognize the mandelbrot thing.  Not terribly familiar.  Cool, though.
00:07:40 <nmessenger> I know *of* it, I just didn't recognize the algorithm as it.
00:09:12 <nmessenger> > null . drop 256 . takeWhile ((<= 2.0).magnitude) $ iterate (\x -> x*x + (0.1 :+ 0.9) 0
00:09:12 <lambdabot>  Parse error
00:09:17 <newsham> http://www.thenewsh.com/~newsham/x/machine/mand3.hs.txt
00:09:37 <newsham> generates pbms of mandelbrots, julias and moire patterns
00:10:25 <newsham> http://www.thenewsh.com/~newsham/ <- picture near the bottom of my page is an example (julia set)
00:10:28 <lambdabot> Title: Tim Newsham
00:11:23 <newsham> http://www.thenewsh.com/~newsham/x/machine/mand2.hs.txt <- ascii versions
00:12:31 <nmessenger> heh, alien dude from ATHF.  nice.
00:14:07 <newsham> nmess: http://www.thenewsh.com/~newsham/moon.html
00:18:12 <sjanssen> is select exported in any of the standard libraries?
00:18:51 <nmessenger> @index select
00:18:52 <lambdabot> Text.Html
00:19:02 <newsham> file descriptor selection?  isnt that "baked-in" to the file handle/threading code?
00:19:41 <sjanssen> it is baked in, but I need to use the raw file descriptors
00:20:40 <newsham> if you use fdRead, will it block?
00:21:02 <newsham> what about fdToHandle?
00:21:30 <sjanssen> the thing is, I don't actually want to read anything
00:21:44 <newsham> hReady ?
00:21:50 <newsham> ?hoogle hReady
00:21:51 <lambdabot> IO.hReady :: Handle -> IO Bool
00:22:02 <sjanssen> ah, good idea
00:22:52 <mauke> is it me or is hpaste.org broken?
00:25:50 <hpaste>  nmessenger pasted "test paste (site broken?)" at http://hpaste.org/392
00:26:06 <mauke> have a look at http://hpaste.org/390
00:26:13 <mauke> (the last line)
00:26:27 <hpaste>  dcoutts annotated "test paste (site broken?)" with "doesn't seem broken :-)" at http://hpaste.org/392#a1
00:26:32 <mauke> the file got cut off in the middle
00:26:47 <mauke> second attempt, using w3m: http://hpaste.org/391
00:26:47 <dcoutts> mauke, there's a lines limit
00:26:58 <nmessenger> @seen glguy
00:26:59 <lambdabot> I saw glguy leaving #happs and #haskell 1h 11m 34s ago, and .
00:27:18 <mauke> dcoutts: then why do I get different results for pasting the same file twice?
00:27:31 <mauke> and why did it stop in the middle of a line
00:27:31 <sjanssen> newsham: worked, thanks
00:27:40 <dcoutts> mauke, ok fair enough, I've no idea.
00:30:56 <newsham> cool
00:32:31 <kzm> Hmm.. I need to convert a data structure to a bytestring.  But I need to keep track of position (basically, I have the contents in packed form, plus a list of modifications by position).  Any hints?
00:32:50 <dcoutts> kzm, like back-patching ?
00:32:56 <kzm> Thought about using Data.Binary, but not sure about the position issue.
00:33:15 <kzm> Maybe - what's that?
00:33:21 <dcoutts> how about doing the first pass and then do the modifications in a second pass
00:33:39 <dcoutts> do the modification spans overlap each other ?
00:33:43 <kzm> Can do that, but for efficiency, I'd like to do it in one go.
00:34:13 <kzm> Two different types of modifiactions: lower case or erased.  Can be both at the same time, yes.
00:34:25 <kzm> I can always collapse them into a single one, of course.
00:34:33 <dcoutts> ok, so work out where spans start and stop
00:34:36 <dcoutts> then do a single pass
00:34:56 <kzm> using Binary?  Or some other building function?  unfoldr?
00:35:06 <dcoutts> unfoldr would be ok I guess
00:35:14 <dcoutts> as you cross span boundaries you switch state
00:35:18 <kzm> How does it deal with sequence lenght?
00:35:26 <dcoutts> hmm?
00:35:53 <kzm> How large a BS will it allocate?
00:36:02 <dcoutts> oh it does it in chunks
00:36:09 <dcoutts> st least if you use a lazy bytestring
00:36:21 <kzm> Right, so there will be at worst a chunk-sized overhead (which is fine)
00:36:23 <dcoutts> so it doesn't waste that much, 4k max.
00:36:26 <dcoutts> iirc
00:36:57 <kzm> Right.  unfoldr it is then.  Thanks.
00:37:09 <kzm> Or maybe I should say: 'please hold' :-)
00:39:50 <dcoutts> kzm, you may find that the Builder from the binary package is more convenient than unfoldr
00:41:15 <kzm> Hm, okay.  But I'm more familiar with unfoldr, and I think it will work nicely.  I'm using Binary already, but at the 'other end' of things (between external and intermediate format, the unfoldr will be between intermediate and internal).
00:42:11 <kzm> What's a name for two bits (between bit and nibble)?
00:43:16 <fuzan> tubit ?
00:43:44 <mauke> kzm: http://www.catb.org/~esr/jargon/html/N/nybble.html
00:43:46 <lambdabot> Title: nybble
00:45:25 <kzm> Okay, that was more than I asked for.  Thanks!
00:45:32 * kzm likes crumbs.
00:45:55 <nmessenger> tydbit :D
00:57:52 <beelsebob> Igloo: I take it it's down to being your lot's fault now, yeh?
01:12:38 <mauke> here's my simple parser transformer: http://hpaste.org/393
01:13:06 <mauke> I still have no idea what to do about error reporting :(
01:19:48 <nmessenger> wouldn't Kleisli m a be a better name for Inject a m?
01:20:35 <mauke> maybe
01:20:39 <mauke> I have no idea what Kleisli is
01:20:48 <nmessenger> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#t%3AKleisli
01:20:50 <lambdabot> http://tinyurl.com/y6yt3s
01:21:42 <Cale> not quite -- that would only be Kleisli arrows from a to a
01:21:56 <nmessenger> so Kleisli m (Endo a) :)
01:23:02 <nmessenger> EndoKleisli?
01:23:17 * nmessenger doesn't know squat of category theory
01:25:45 <ivanm> When looking at the core code output, does a let affect performance or space? How about a letrec?
01:31:19 <nmessenger> afaik, haskell doesn't have a non-rec let.  Not sure about performance implications, though.
01:31:44 <ivanm> well, in the core code output there is both let and letrec
01:31:55 <ivanm> and in the ghc users guide, it says that let == bad
01:35:02 <nmessenger> when evaluating (let (x,y) = exp1 in exp2 x y), 'exp1' is guaranteed to be chosen, so evaluation of 'x' and 'y' can be defered.  In (case exp1 of {(x,y) -> exp2 x y}), the evaluator must deconstruct the tuple to see which case to choose (even though there is only one case).  That's all that I know.
01:36:32 <nmessenger> Does anyone know if any of that is incorrect?
01:36:38 <ivanm> Hmmm.... OK....
01:37:30 <ivanm> Another question: is there a more efficient transposition function/method available than the one in Data.List? I wouldn't think so, but transpose is my most costly function (taking approx. 20% of my CPU time when I profile it)
01:37:50 <nmessenger> @src transpose
01:37:51 <lambdabot> transpose []             = []
01:37:51 <lambdabot> transpose ([]   : xss)   = transpose xss
01:37:51 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
01:38:21 <ivanm> I've tried searching for "transpose haskell", but I wouldn't have a clue if one I found was more efficient
01:38:53 <ivanm> for example, the code used by helium for transposition seems different....
01:39:08 <ivanm> http://www.google.com/codesearch?hl=en&q=+lang:haskell+transpose+show:KZ6svcoYw9U:KHUboaFteMU:tEH58gopGpE&sa=N&cd=2&ct=rc&cs_p=http://gentoo.osuosl.org/distfiles/helium-1.1-src.tar.gz&cs_f=helium-1.1/heliumNT/lib/List.hs#a0
01:39:10 <lambdabot> Title: helium-1.1/heliumNT/lib/List.hs - Google Code Search, http://tinyurl.com/ynmafy
01:40:17 <tessier> Interesting. So in haskell instead of a for loop you would do something like foldr, foldr, map, etc. And pass it a function which would be like the body of the for loop
01:40:28 <nmessenger> looks identical to the above @src
01:40:50 <tessier> I've been hoping to learn lisp/scheme first but the more I learn about haskell purely accidentally the more I want to pick up my haskell book and dive in.
01:40:58 <tessier> Just wondering how quickly I will get lost.
01:41:04 <ivanm> nmessenger: whoops, it does too... just looked different to me
01:41:40 <ivanm> tessier: well, lisp/scheme might be easier to start with as you don't have to worry about types as much (I learnt scheme first at Uni for a semester, just started using haskell)
01:41:52 <nmessenger> tessier: It's easy to write imperative-style code in Scheme.  It's less easy in Haskell, but possible.  Haskell encourages pure data-mashing by making it the easiest to write.
01:42:13 <tessier> nmessenger: Exactly. That is part of the appeal.
01:42:17 <Syzygy-> Or it might be an idea to figure out the type system - once you know what it says, it's a tremendous support in your coding.
01:42:19 <ivanm> tessier: a good scheme book is "structure and interpretation of computer programs" by abelson and sussman
01:42:35 <tessier> ivanm: Already got it. Also have Simply Scheme. And a couple other lisp books I have found online.
01:42:49 <tessier> An embarassment of riches. I still don't know where to start. :)
01:42:56 <ivanm> tessier: and I've found "the craft of functional programming" by thompson good for haskell
01:43:03 <ivanm> lol
01:43:42 <tessier> ivanm: I have the actual dead tree version of that book open in my lap right now. :)
01:43:45 <ivanm> I find the type system quite useful in haskell... work out the type of a function, and most of the work is done
01:43:50 <tessier> I'm on page 5. :)
01:44:26 <nmessenger> I don't understand how Helium can be very useful without typeclasses :/
01:44:31 <ivanm> tessier: geez, you're on the ball! (I ended up skipping many pages, as I knew a lot of the function-passing stuff, and I needed to start coding)
01:44:48 <ivanm> nmessenger: agreed, though I couldn't even install helium :s
01:44:54 <tessier> nmessenger: It's good for lifting balloons
01:44:59 <nmessenger> heh
01:45:56 <ivanm> nmessenger: I've found what seems to be the old, non-lazy transpose function: would it be more efficient for finite lists?
01:46:03 <ivanm> transpose           = foldr (\xs xss -> zipWith (:) xs (xss ++ repeat [])) []
01:46:28 <nmessenger> @src zipWith
01:46:29 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
01:46:29 <lambdabot> zipWith _ _      _      = []
01:47:02 <nmessenger> not sure.
01:47:06 <ivanm> I found a mail archive (can't remember the url) suggesting that they changed to the current one since it was lazy and worked for infinite lists
01:47:19 <ivanm> hmmm... I was hoping for a faster version
01:47:28 <ivanm> thanks anyway... anyone else know?
01:47:33 <nmessenger> try it, rename it to transpose'
01:47:44 <nmessenger> that'd be the best way to find out :)
01:48:35 <nmessenger> or even import Data.List hiding (transpose) and then plug it in.
01:49:24 <ivanm> well, I was aliasing transpose as a "cols" function, so I'm just replacing that function instead
01:49:38 <ivanm> hmmm.... doesn't seem to be too much more efficient... the run time is approximately the same
01:50:41 <tessier> It is interesting to me that haskell can be both interpreted and compiled. Why aren't perl and python and other languages that way also?
01:50:46 <ivanm> I take it back... it might be _slightly_ faster (run time dropped to 17.* seconds, instead of the normal 18-19 seconds)!
01:50:55 <tessier> I think scheme and lisp can usually be both interpreted and compiled depending on what implementation you are using right?
01:51:03 <ivanm> tessier: python can be compiled, but not as efficiently
01:51:25 <tessier> ivanm: Not really. Doesn't it just bundle the code with the actual interpreter and put it into an executable?
01:51:30 <ivanm> I'm guessing that it only does it to byte code or something, and that it's normally used as a wrapper language
01:51:56 <ivanm> tessier: I think the .pyc codes are meant to be at least byte-compiled... I could be wrong (but its still faster than Matlab!!!)
01:52:08 <tessier> I think ghc generates C which is fed to gcc which generated assembler which goes to gas to make a real elf executable
01:52:13 <tessier> Yes, .pyc is byte compiled
01:52:19 <nmessenger> tessier: well, with a more dynamic a language, I'm not sure how you could get away without a runtime system.
01:52:24 <tessier> But that isn't quite the same as actually compiled. That just saves parsing.
01:52:43 <tessier> Are perl/python that much more dynamic than haskell? I've never been quite clear on what is meant by dynamic anyhow.
01:52:56 <ivanm> Umm... would ghc use gcc on windows platforms? I've found mentions of it using its own internal c compiler...
01:53:04 <mauke> tessier: eval()
01:53:18 <nmessenger> name lookups, function call bindings and stuff are done at runtime instead of compile time
01:53:19 <tessier> mauke: I never use it.
01:53:22 <ivanm> perl/python are primarily scripting languages.... from what I can tell, haskell was originally designed to be compiled
01:53:24 <mauke> tessier: oh, and perl programs can run arbitrary code at parse time and have access to their own symbol table
01:54:08 <ivanm> I know that when I learnt scheme, the lecturer used to do a lot of haskell stuff, so for one of our assignments we had to do a basic haskell to scheme converter
01:54:11 <tessier> ivanm: scripting language is another term without much of a definition. Are scripting language and programming language mutually exclusive?
01:54:23 <ivanm> tessier: good question
01:54:28 <ivanm> @wikipedia scripting language
01:54:30 <lambdabot> No Result Found.
01:54:37 <ivanm> @wikipedia scripting
01:54:39 <lambdabot> No Result Found.
01:54:50 <ivanm> @google define:scripting language
01:54:51 <lambdabot> No Result Found.
01:55:00 <ivanm> OK, that failed
01:55:05 <nmessenger> @all-dicts scripting language
01:55:08 <kolmodin> seems the internet is offline :)
01:55:09 <lambdabot> No match for "scripting".
01:55:09 <lambdabot>  
01:55:09 <lambdabot> *** "Language" gcide "The Collaborative International Dictionary of English v.0.48"
01:55:09 <lambdabot> Language \Lan"guage\, n. [OE. langage, F. langage, fr. L. lingua
01:55:09 <lambdabot>    the tongue, hence speech, language; akin to E. tongue. See
01:55:11 <lambdabot> [230 @more lines]
01:55:14 <mauke> A script is what you give the actors.  A program is what you give the audience.
01:55:23 <ivanm> http://en.wikipedia.org/wiki/Scripting_language
01:55:24 <lambdabot> Title: Scripting language - Wikipedia, the free encyclopedia
01:55:28 <nmessenger> tessier: regardless of whether you use eval or not, some libraries you use might.
01:55:44 <nmessenger> so it *must* be supported
01:56:01 <yaarg> a script language is one in which people think they're writing scripts, and a programming language is one in which they think they're writing programs :)
01:56:07 <tessier> Isn't something like eval required for metaprogramming?
01:56:08 <kolmodin> tessier: python can be compiled with psyco
01:56:20 <mux> psyco is not a compiler
01:56:26 <tessier> kolmodin: Doesn't that just bundle the bytecode with the interpreter?
01:56:45 <kolmodin> well it does something that makes it faster, can't remember ;)
01:57:03 <mux> actually, they call it a "specializing" compiler, so I guess compiler is correct :-P
01:57:49 <ivanm> the whole definition of lisp is the eval... I'm sure I read somewhere that lisp was originally an academic pipe dream, until a grad student worked out that if he implemented eval, he'd have a lisp interpreter (and he did)
01:58:19 <tessier> ivanm: Yes, I've read about that also. One of McCarthy's grad students
01:58:32 <tessier> But lisp can be compiled to an executable afaik.
01:58:36 <ivanm> that's right... couldn't remember off the top of my head
01:58:45 <kolmodin> it is possible to compile dynamic languages, but it's harder to make them go fast.. late bindings and stuff makes it difficult
01:58:54 <ivanm> yeah, but originally it would have been interpreted (or else run on a lisp machine!)
01:59:04 <tessier> I see.
01:59:14 <tessier> Haskell does not have late binding. Does not have access to its own symbol table ec.
01:59:15 <tessier> etc/
01:59:16 <nmessenger> @google Paul Graham lisp accident
01:59:18 <lambdabot> http://www.paulgraham.com/icad.html
01:59:18 <lambdabot> Title: Revenge of the Nerds
01:59:23 <nmessenger> ^^ that'd be the paper
01:59:34 <tessier> Paul Graham is the reason I am here. :)
01:59:50 <nmessenger> "What happened next was that, some time in late 1958, Steve Russell, one of McCarthy's grad students, looked at this definition of eval and realized that if he translated it into machine language, the result would be a Lisp interpreter."
01:59:53 <ivanm> I didn't think he mentioned haskell...
01:59:56 <tessier> I read Hackers and Painters a couple years ago and got into lisp and scheme and now haskell. Although I barely know how to do anything with any of them.
02:00:07 <ivanm> nmessenger: that's the quote I was thinking of!
02:01:33 <ivanm> but graham seems a bit fanatical to me (from his papers that I read anyway)...
02:01:47 <tessier> Lisp seems to be the second oldest programming language next to fortran.
02:02:04 <tessier> ivanm: Yeah, but he's still a good evangelist for functional programming
02:02:31 <ivanm> tessier: wouldn't it only be the second oldest still in use?
02:02:35 <mauke> dude, graham thinks python is more lispy than perl
02:02:38 <ivanm> wasn't cobol before fortran?
02:02:53 <ivanm> mauke: yeah, but python is going to lose a lot of its lisp-like stuff
02:03:06 <mauke> ivanm: I think that's obviously wrong
02:03:07 <nmessenger> http://www.levenez.com/lang/history.html
02:03:08 <tessier> ivanm: They say list comprehensions can be used to replace map and filter etc.
02:03:08 <ivanm> they're keeping list comprehensions, and dropping maps, etc. AFAIK
02:03:49 <nmessenger> ivanm: I read the same Guido post.  I think he may have changed his mind.
02:04:57 <mauke> ah yeah, excellent example: python distinguishes between expressions and statements. lisp doesn't.
02:05:06 <ivanm> nmessenger: well, I haven't looked at python for over 6 months, I just remember reading that somewhere, since guido wanted python to be a more "one way of doing everything"
02:05:10 <nmessenger> @google Guido van Rossum recursion loops
02:05:10 <mauke> perl does, but it lets you interconvert between them
02:05:12 <lambdabot> http://www.artima.com/weblogs/viewpost.jsp?thread=4550
02:05:12 <lambdabot> Title: News from Python UK
02:05:24 <nmessenger> "I'd say that a loop is a higher-level concept than recursion; recursion is more powerful, but also more low-level, like assembly language." -- GvR
02:05:36 * nmessenger rolls eyes
02:05:40 <mauke> and that is the reason why python's lambda is so retarded
02:06:15 * tessier yum installs hugs
02:06:24 <ivanm> http://en.wikipedia.org/wiki/Python_3#What.27s_new
02:06:49 <ivanm> "moving map, filter and reduce out of the built-in namespace (the rationale being that map and filter are expressed more clearly as list comprehensions, and reduce more clearly as an accumulation loop)"
02:07:09 <nmessenger> (='o'=) !!
02:07:17 <mauke> C-style for loops are expressed more clearly as conditional jumps
02:07:23 <quicksil1er> !!!!!!
02:07:30 <mauke> we don't need higher-level abstractions
02:07:45 <nmessenger> *no steeeenking
02:07:46 <ivanm> nmessenger: then again, it's only wikipedia, it could be wrong ;)
02:07:49 <quicksil1er> 'more clearly' is just relative to what you're used to, of course
02:08:10 <quicksil1er> a list comprehension is clearer than a map, until you get used to map
02:08:13 <ivanm> tessier: if you're going to be installing ghc anyway, why not just use ghci instead of hugs (assuming you want to be able to compile your code)?
02:08:42 * nmessenger expends effort trying to understand list comps
02:08:45 <tessier> ivanm: The Craft of Functional Programming assumes hugs. I thought it would be safest to use the same thing.
02:08:48 <mauke> quicksil1er: heh, a map is obvious. python's list comprehensions look weird until you get used to the syntax
02:08:49 <ivanm> quicksil1er: but there are nice things you can do more clearly in a list comprehension, IMHO
02:08:57 <quicksil1er> right
02:08:57 <tessier> And I want to be able to run the code at the prompt and not have a compile step to slow me down.
02:09:08 <quicksil1er> mauke: my whole point is that its subjecting
02:09:13 <quicksil1er> mauke: s/ing/ive/
02:09:19 <tessier> It's just trivial stuff like square n = n*n
02:09:20 <ivanm> tessier: only difference I've found is the use of "it" instead of "$$" for last value calculated... and it doesn't have much hugs-based stuff
02:09:21 <quicksil1er> mauke: a map is obvious to people used to using map
02:09:30 <quicksil1er> tessier: that's what ghci does
02:09:34 <tessier> oh
02:09:40 <quicksil1er> ghcInteractive :)
02:10:21 <ivanm> singles xs = [ x | [x] <- xs] => to find all the elements in a list of lists which are the only elements in a given list
02:10:21 <mauke> @where goa
02:10:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
02:10:38 <nmessenger> tessier: hugs doesn't allow REPL definitions, you'll have to define names in a file and :load them.  Ghci does, however, support them.
02:10:43 <ivanm> I found a map version of the above function was a lot uglier
02:11:06 <nmessenger> tessier: but you could use 'let localName = ... in ... localName ...' in both
02:11:57 <quicksil1er> ivanm: that's not a list comprehension in the python sense, though
02:12:04 <ivanm> nmessenger: how else can you define something in ghci? I've only been able to add something at the prompt using "let foo x = x + 1"
02:12:28 <mauke> ivanm: yes, that's how you do it
02:12:30 <quicksil1er> ivanm: that's leveraging the full power of monads and the (controversial) pattern-match-failure-as-fail feature
02:12:32 <ivanm> quicksil1er: true, but my point was that there are some things which can be expressed more cleanly in a list comprehension than using a map
02:13:08 <nmessenger> ivanm: "let foo x = x + 1 in foo 5" is an expression that wholly contains foo, which is discarded afterwards
02:13:29 <beelsebob> there are many many things that are nicer in list comprehensions than map and filter
02:13:42 <beelsebob> tbh... I wish list comprehensions were more powerful though
02:13:47 <ivanm> nmessenger: OK... can't you define functions at the hugs prompt, even using let?
02:13:53 <quicksil1er> beelsebob: more powerful how?
02:14:11 <beelsebob> two secs, and I'll dig up the one I wanted the other day
02:14:11 <mauke> > filter (liftM2 (&&) (not . null) (null . tail)) ["", "foo", "b", "ar", "ba", "z"]
02:14:13 <lambdabot>  ["b","z"]
02:14:22 <nmessenger> ivanm: not just a name define.  It has to be a complete expression with an 'in' clause.
02:14:36 <dons_> ?uptime
02:14:37 <lambdabot> uptime: 8d 12h 25m 20s, longest uptime: 8d 12h 25m 20s
02:14:38 <dons_> ?users
02:14:39 <ivanm> nmessenger: ahhhhh
02:14:39 <lambdabot> Maximum users seen in #haskell: 322, currently: 295 (91.6%), active: 33 (11.2%)
02:15:39 <nmessenger> ivanm: though hugs does support using 'where' as if it were an expression (i.e. foo 5 where foo x = x + 1).
02:15:53 <nmessenger> ^^ equivalent to the 'let' form
02:16:14 <beelsebob> quicksil1er: I'd like to be able to do this one... [fdtMef g o | q <- edtRes m, nodeValue m = n' o && nodeLast g n' = n]
02:16:24 <beelsebob> so pattern matching happens on the wrong side of the equation
02:16:40 <beelsebob> yes, I appreciate that this in general requires a full type space search
02:16:49 <ivanm> nmessenger: ahhh.....
02:17:08 <beelsebob> bah, where did q come from in that
02:17:09 <beelsebob> oops
02:17:16 <quicksil1er> beelsebob: erm, are NodeValue and NodeLast suppoesd to be constructors or?
02:17:25 <beelsebob> quicksil1er: they're functions
02:17:40 <beelsebob> it's a bit of a broken transliteration
02:17:50 <quicksil1er> what are those = signs?
02:17:51 <beelsebob> there should actually be some more constructors in there - let me try again
02:17:56 * quicksil1er looks thoroughly confused
02:18:09 <quicksil1er> you seem to have definitions inside that expression, but not introduced by let
02:18:21 <beelsebob> [fdtMef g q | q <- edtRes m, nodeValue m == Application n' o && nodeLast g n' = Atom n]
02:18:32 <tessier> Prelude> square :: Int -> Int
02:18:33 <beelsebob> no, I just have pattern matches in the wrong places
02:18:36 <tessier> <interactive>:1:0: Not in scope: `square'
02:18:42 <tessier> I need to start some other way?
02:18:48 <quicksil1er> tessier: don't give the signature
02:18:57 <mauke> tessier: what is square?
02:19:00 <quicksil1er> (people learning haskell always give too many signatures, I blame the tutorials)
02:19:09 <ivanm> tessier: > let square x  = x * x
02:19:10 <nmessenger> tessier: :browse Prelude would give you a start
02:19:10 <quicksil1er> part of the fun is watching it infer the type for you
02:19:13 <tessier> square n = n*n
02:19:20 <mauke> tessier: where is that defined?
02:19:20 <tessier> ah, let
02:19:24 <beelsebob> quicksil1er: people should always give type signaturens
02:19:28 <tessier> mauke: I just tried to define it. :)
02:19:33 <mauke> oh
02:19:34 <quicksil1er> beelsebob: I disagree strongly
02:19:39 <beelsebob>  > let square x = x * x :: (Int -> Int)
02:19:40 <quicksil1er> beelsebob: especially during development/playing
02:19:42 <nmessenger> tessier: hugs or ghci?
02:19:46 <tessier> ghci
02:19:47 <ivanm> tessier: but its usually better if you write all your code in a file and then load it using :load <blah>
02:19:58 <beelsebob> quicksil1er: they should be learning to know what type they want and why
02:20:03 <quicksil1er> true
02:20:16 <quicksil1er> but the right way to do that is not to try and give a signature, get it wrong, and get a ridiculous error message
02:20:17 <ivanm> beelsebob: but can you use type signatures at the ghci prompt?
02:20:20 <tessier> I'll have to dig up the haskell mode for emacs
02:20:29 <quicksil1er> (this is a particular problem with classes)
02:20:30 <nmessenger> I have my editor set so that F9 = runhaskell, F10 = load into ghci, F11 = darcs, F12 = shell
02:20:32 <dcoutts> @google Lazy Asynchronous I/O
02:20:36 <beelsebob> ivanm: I don't see why not - it's all part of it being an expression
02:20:37 <ivanm> tessier: its pretty good, I use it myself
02:20:38 <beelsebob> *tries*
02:20:38 <lambdabot> http://www.cs.rice.edu/~kdiaa/laio/
02:20:39 <lambdabot> Title: Lazy Asynchronous I/O (LAIO)
02:20:44 <dcoutts> mmm LAIO
02:20:56 <quicksil1er> the interesting way to do it is to try some expressions, watch what type it infers, and learn from that
02:20:58 <tessier> Anyhow, I just wrote my first line of haskell code. My cherry is popped.
02:21:02 <beelsebob> quicksil1er: no, the right way to do it is to think about the signature, try it, and see if you get an error - if you do then think some more
02:21:18 <velco> doesnotwork
02:21:20 <quicksil1er> beelsebob: I have to agree to disagree with you there
02:21:31 <beelsebob> quicksil1er: but that's the point - it doesn't tell you what type it infers unless you actually force it to check it against what you think it shold be
02:21:36 <quicksil1er> beelsebob: that is completely diametrically opposite to the way I teach, and the way I learn myself
02:21:53 <ivanm> beelsebob: then again, if my code has the wrong signature, I remove the one I supplied and then re-load the file to see what signature it _does_ have
02:21:56 * nmessenger throws lambdas around.  "Let's celebrate tessier's introduction into FPdom!"
02:22:14 <ivanm> tessier++
02:22:16 <beelsebob> ivanm: if my code has the wrong signature it's a sure sign that there's a bug in the code, not the type signature
02:22:17 <dcoutts> dons_, strict bytestrings would be perfect for lazy async IO. You ask for some range of data and then when you actually force the ByteString you block for completion. That should give a lovely programming model for high perf IO.
02:22:30 <quicksil1er> beelsebob: that is not the case for most beginners though
02:22:35 <ivanm> beelsebob: yeah, but that way I can start working on what the problem is
02:22:41 <quicksil1er> beelsebob: you clearly have a good understanding of the type system
02:22:45 <quicksil1er> and you think in types (good for you)
02:22:50 <quicksil1er> however beginners tend to think in expressions
02:22:52 <beelsebob> quicksil1er: no, but that's the point - the beginners are thinking "I'll make my code do this and then figure out it's signature"
02:22:56 <ivanm> beelsebob: especially when I'm changing what a function does and I'm trying to do it in a pointfree style
02:22:57 <quicksil1er> and I think they should be encouraged to do so
02:22:57 <dcoutts> dons_, it's much like the XCB latency hiding thing that someone pointed to yesterday when discussing Xlib bindings.
02:23:02 <beelsebob> wherase the first step should be "what's my code converting to what"
02:23:08 <Vq^> tessier: congratulations
02:23:17 <beelsebob> before they even write it they should be writing the type signature down
02:23:20 <quicksil1er> beelsebob: no, I don't agree
02:23:28 <quicksil1er> the first step is 'what am I trying to acheive'
02:23:31 <beelsebob> indeed
02:23:38 <quicksil1er> I frequently build up subexpressiosn which do part of the job
02:23:42 <quicksil1er> (in ghci, possibly)
02:23:45 <beelsebob> and you go "I'm trying to convert that string into a list of integers"
02:23:45 * nmessenger agrees with beelsebob.  Though it's a difficult task.
02:23:49 <beelsebob> ohh... got a type signature
02:23:53 <quicksil1er> and observe the type signatures as I go
02:24:04 <ivanm> I try and define the signatures first... but removing them to find out what the functions actual signature _is_ sometimes helps me with debugging
02:24:12 <beelsebob> now... what list did I actually want
02:24:19 <ivanm> lol
02:24:31 <dcoutts> dons_, it's complementary to the unifying threads & events work.
02:24:42 <beelsebob> because if you know what result you want you know what type you want, you do not necessarily know the reverse
02:24:50 <ivanm> tellier: here's the haskell-mode for emacs if you haven't found it yet: http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
02:24:52 <lambdabot> Title: Emacs Lisp packages
02:24:53 <nmessenger> tessier: you will reimplement *many* library functions before you start to get comfortable.  It's simply unavoidable.
02:25:08 <ivanm> too true...
02:25:51 <nmessenger> tessier: but despair not!  Writing them yourself will build confidence that you understand the standard definitions and what the heck they do.
02:26:03 <quicksil1er> Well this is how I see it: If you try some code with no type signature, it may compile. If it does, even if it isn't right, you learn somethin.
02:26:04 <beelsebob> tis interesting that actually - in other languages the library functions are the things you would never want to touch with a barge pole
02:26:10 <beelsebob> in Haskell they're the ones you give beginners
02:26:30 <quicksil1er> if you try code with a type signature (especially if you're a beginner) you could have a frustrating half hour of type error
02:26:33 <quicksil1er> before it even compiles
02:26:34 <nmessenger> the Prelude is *chock full* of smart stuff
02:26:36 <ivanm> beelsebob: then again, would you _really_ want to re-implement a hash map in Java?
02:26:39 <quicksil1er> *I* don't think that's good for teaching
02:26:45 <ivanm> but I agree with you: at first you avoid them in most languages
02:26:48 <dons_> dcoutts: check out the lazy bytestring based regex chris wrote, http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
02:26:54 <dons_> dcoutts: note the memory use.
02:26:56 <beelsebob> quicksil1er: this is how I see it: First think what your code should be doing in a general sense - at this point you should already know what the types are
02:27:06 <quicksil1er> beelsebob: I'm talking about exploration and teaching
02:27:10 <quicksil1er> beelsebob: not engineering
02:27:11 <beelsebob> *then* you should think "maybe I'm getting the hang of what I'm trying to do"
02:27:17 <beelsebob> quicksil1er: so am I
02:27:24 <beelsebob> this is what we teach here
02:27:44 <JKnecht> that sound pretty fucked up, if I do say so myself. A library is supposed to be largely usable as is otherwise it's a stub or a template or something. Maybe I misunderstand.
02:27:45 <beelsebob> write down the really top level abstract stuff first
02:27:46 <ivanm> beelsebob: did you manage to define a type signature in ghci?
02:27:49 <beelsebob> then everything else fits into place
02:27:55 <beelsebob> ivanm: been too busy arguing :D
02:28:07 <nmessenger> quicksil1er, beelsebob: you both make good points.  I don't think learning *requires* sticking to just one way or the other.  I switch often myself.
02:28:36 <beelsebob> I think nmessenger has it
02:28:40 <ivanm> beelsebob: fair enough! but if someone's learning via the prompt, and you can't define signatures at the prompt, the question becomes rather moot, doesn't it?
02:28:49 <beelsebob> indeed it does
02:28:53 <quicksil1er> My point was really about the advice we should be giving tessier
02:28:58 <quicksil1er> (at least, that's how I came in)
02:28:59 <beelsebob> I'd suggest they shouldn't learn at the prompt then :P
02:29:02 <nornagon> dons_: hm, why does haskell do so badly there?
02:29:08 <nornagon> worse than ruby, even
02:29:13 <quicksil1er> Ah well, that's another thing I can't agree with
02:29:16 <beelsebob> ivanm: they should be typing into a file and repeatedly doing ":r"
02:29:20 <quicksil1er> having a REPL is an awesome teaching tool
02:29:30 <quicksil1er> you can evaluate any subexpression at will
02:29:30 <beelsebob> absolutely
02:29:34 <beelsebob> they should have a prompt
02:29:39 <quicksil1er> that's a great way to understand how code works
02:29:41 <beelsebob> but they should be using a file to define functions
02:29:43 <ivanm> beelsebob: yeah, I originally tried using the prompt, but gave up (the prompt isn't as good as using lisp or python)...
02:29:46 <beelsebob> so they can look at their code after
02:29:51 <quicksil1er> well that's true
02:29:56 <quicksil1er> but for playing/testing with ideas
02:30:10 <quicksil1er> hmm, what does filter isLower "aBCde" do?
02:30:16 <ivanm> I actually learnt a lot by going through the sudoku code by graham hutton
02:30:18 <quicksil1er> that's interesting, what about filter isUpper
02:30:25 <quicksil1er> and so on
02:30:33 <quicksil1er> the prompt is great for this kind of exploration
02:30:38 <beelsebob> quicksil1er: sure, certainly you shouldn't have type signatures there
02:30:39 <nornagon> > filter isLower "aBCde"
02:30:46 <beelsebob> you should be just going "how does this built in actually work"
02:30:47 <nornagon> oh, it was a rhetorical question
02:30:57 <quicksil1er> nornagon: :)
02:30:58 <nornagon> @botsnack
02:31:06 <beelsebob> but when they're trying to actually define something and they know what they're trying to do, they should put the signature in first
02:31:09 <nornagon> fooey.
02:31:17 <nmessenger> LB seemed a little sleepy a few minutes ago.
02:31:31 <quicksil1er> incidentally, I don't agree about libraries you wouldn't touch with a barge pole, either :)
02:31:47 <beelsebob> quicksil1er: you would want to code hashmap in java?
02:31:50 <beelsebob> as a beginner?
02:31:51 <beelsebob> o.O
02:31:52 <quicksil1er> if you're not competent to read the source of the library you're using, you shouldn't be doing (professional) work with it
02:32:01 <quicksil1er> ah, well, I'm not talking about beginners at this point
02:32:05 <beelsebob> oh, okay then
02:32:11 <quicksil1er> obviously beginners can assume the library to start with
02:32:12 * nmessenger likes slapping people and randomly picks quicksil1er to slap.
02:32:14 <ivanm> beelsebob: hey, I said that ;)
02:32:14 <nornagon> quicksil1er: so if you can't comprehend gcc, you shouldn't write C?
02:32:19 <beelsebob> my point was that in Haskell the beginner exercises are writing the library
02:32:23 <dons_> nornagon: check it out, its a custom regex library
02:32:28 <beelsebob> ivanm: yeh, I just thought it was a good example
02:32:31 <nornagon> dons_: O_o
02:32:32 <dons_> i.e. not a binding to some C regex-tre lib
02:32:41 <quicksil1er> nornagon: I agree that's a kind of correct generalisation of what I said
02:32:44 <dons_> if you just used regex-tre package, it would probably zip along too
02:32:50 <quicksil1er> nornagon: but I'd rather say 'if you can't understand the gcc runtime'
02:32:57 <quicksil1er> (fortuantely the gcc runtime is fairly small)
02:33:17 <nornagon> i'm not quite sure what you mean by 'gcc runtime'
02:33:31 <quicksil1er> the runtime is a small library that gcc links into every progam it builds
02:33:35 <nornagon> (i don't spend much time peering at gcc; it usually Just Works for me.)
02:33:35 <nornagon> ah.
02:33:39 <nornagon> libc?
02:33:42 <beelsebob> nornagon: if you couldn't write your own C compiler, then certainly, you shouldn't be working in the proffesional computer industry - especially not using such an unstable tool as C
02:33:43 <nornagon> glibc, even
02:33:55 <quicksil1er> no, glibc is a stupendously huge library
02:33:57 <mux> not libc, and certainly not glibc
02:34:01 <mux> crt0.c
02:34:05 <nornagon> oh.
02:34:10 <quicksil1er> which links a superset of the POSIX api to your kernel primitives
02:34:16 <ivanm> beelsebob: yeah, I agree its a good example... but I demand credit next time!!! :D
02:34:18 <nornagon> beelsebob: if you applied that to everyone in the IT industry, there'd be very few people left :)
02:34:31 <beelsebob> ivanm: sorry, I thought about a page of scroll buffer was enough credit
02:34:37 <quicksil1er> nornagon: there are very few people in the IT industry who are qualified to work there :)
02:34:38 <beelsebob> nornagon: exactly
02:34:46 <nornagon> quicksil1er: sadly.
02:34:48 <beelsebob> :P
02:34:51 <quicksil1er> there are a lot of incompetents and cowboys :)
02:36:16 <ivanm> beelsebob: kidding!!! (don't people understand sarcasm anymore?)
02:36:32 <beelsebob> ivanm: I don't think so when it's over text
02:36:45 <beelsebob> sure if I could see your face or hear your voice
02:36:55 <nmessenger> ivanm: how do you know he wasn't making a sarcastic retort?  :P
02:36:58 <ivanm> hence the ":D" at the end of my comment before
02:37:06 <ivanm> nmessenger: lol ;)
02:37:13 <beelsebob> :DD
02:37:24 <ivanm> OK, I'll start using <sarcasm> blah </sarcasm> tags
02:37:29 <beelsebob> <-- must be boing more sarcasti
02:37:31 <beelsebob> fai
02:37:33 <beelsebob> bah
02:37:33 <ivanm> Or let's use haskell : sarcasm "blah"
02:37:37 <beelsebob> typing fails totally
02:37:43 <nmessenger> *soooorry*, I /thought/ about a page of scroll buffer was enough credit.  *rolls eyes*
02:37:56 <beelsebob> oh god no!
02:38:00 <beelsebob> no AOLisms in here please!
02:38:15 <nmessenger> what?  *rolls eyes*?
02:38:18 <ivanm> LOLOLOLOLOLOLOLOLOLOLOLOL!!!!!!!!!!!!!!!!!!!!!!!!!
02:38:20 <beelsebob> next thing is we'll have pages and pages of "ME TOO"
02:38:35 <nmessenger> @. read run cycle "LO"
02:38:41 <beelsebob> lol
02:38:52 <ivanm> now that's just mean.... assuming LB was here ;)
02:38:55 <beelsebob> @. replicate "LO"
02:39:06 <beelsebob> > concatMap $ replicate "LO"
02:39:07 <nmessenger> that'd be ["LO","LO","LO"...
02:39:13 <beelsebob> fail
02:39:14 <beelsebob> why map
02:39:17 <beelsebob> brain not work today
02:39:26 <beelsebob> and where's lambdabot gone anyway?
02:40:24 <JKnecht> @version
02:40:52 <beelsebob> lambdabot go splode!
02:40:56 <JKnecht> looks wedged to me
02:41:03 * nmessenger thinks that sometime soon, LB'll spam #haskell
02:41:12 <beelsebob> > concat $ replicate "LO"
02:41:31 <ivanm> beelsebob: please, I think that's enough!!!!!!!!!!!!!!!!!!!!
02:42:14 <nmessenger> totally!!!!!!!!!!!!!!111
02:42:16 <Stinger> enough exclamation marks?
02:42:44 <ivanm> Stinger: enough_exclamation_marks :: Maybe
02:42:46 <ivanm> ;)
02:42:50 <mauke> this is not enough broccolis
02:43:03 <nmessenger> Maybe isn't of the first kind, you ninny!
02:43:28 <nmessenger> Maybe () is
02:43:32 <ivanm> whatever
02:43:44 <nmessenger> *rolls eyes* :)
02:43:57 <mauke> you rolled a 12!
02:44:10 * nmessenger almost tried @dice 2d6
02:44:12 <ivanm> the whole point was the vaguely haskellish tie in anyway, rather than proper syntax
02:45:30 <nmessenger> > dice 2d6
02:45:30 <nmessenger> 2d6 => 5
02:45:39 <nmessenger> http://lambdabot.codersbase.com/
02:46:20 <ivanm> seems rather slow... but I'll have to remember that site, as a way of using LB at uni
02:46:54 <nmessenger> vixen Are you slow?
02:46:54 <nmessenger> let me answer that later, okay?
02:47:42 <ejt> morning
02:47:52 <nmessenger> she's an older version, though.  No src.
02:47:53 <ivanm> ejt: good evening!
02:48:06 <ejt> :)
02:48:09 <nmessenger> ejt: good now!
02:48:14 <ivanm> nmessenger: how can I get my local LB to use src?
02:48:26 * nmessenger 's never built LB
02:49:12 <ivanm> ejt: well, now = evening (I'd do @localtime, but LB is down)
02:49:33 <ivanm> nmessenger: fair enough...
02:49:46 <nmessenger> sorry :/
02:50:16 <ejt> s/morning/hello/
02:50:53 <nmessenger> s/good now!/I've nothing clever to say/
02:51:08 <ivanm> nmessenger: heh, doesn't really matter... but they've blocked irc at uni, and where I'm at there's no wireless signal, so I'm doing most of my coding on my laptop with LB, then having to go to another computer if I want to go check the source code of the library or just find anything in general
02:51:28 <ivanm> ejt: sure, take the cop-out, try and avoid the argume :D
02:52:41 <ejt> ivanm: not arguing with #haskell, you're all too bright, I'd go to #java for that
02:53:12 <ivanm> ejt: me, bright? If I was so bright, why would I use a super-exponentially large problem for my first go at using haskell? ;)
02:54:18 <ejt> with one sentence I've made ivanm admit he's an idiot ;)
02:54:57 <ivanm> ejt: yep, you should feel proud (normally, I make everyone _else_ admit they're idiots, present company excepted)
02:55:37 <ivanm> aggghhh!!!!! whenever I want to use ap, I need to import Control.Monad.List, but if I want to profile, it doesn't like C.M.L!!!!!!!!!!!
02:57:02 <ivanm> for some reason, the only way I've managed to work out to fix it is to import control.monad and data.map instead of control.monad.list :@
03:03:06 <ivanm> nmessenger: that other transpose function I found earlier does seem to be faster, but on the other hand it also uses up a greater percentage of cpu time :s
03:04:22 * ivanm wishes there was a way his program could use more memory but run faster
03:05:29 <Syzygy-> ivanm: You can always do a CTCP-lookup yourself instead of bouncing it off of lambdabot:
03:05:34 <Syzygy-> CTCP TIME reply from ivanm: Thu Feb  8 21:04:35
03:05:59 <ivanm> what? when did I do that?
03:06:04 <Syzygy-> (11:47) ( ivanm) ejt: well, now = evening (I'd do @localtime, but LB is down)
03:06:25 <ivanm> oh, I thought that it wouldn't work since the command was in the middle of a line... :s
03:06:25 <Syzygy-> @localtime just has lambdabot send a CTCP TIME to the indicated user, and then report the results.
03:06:26 <ivanm> sorry
03:06:45 <ivanm> I didn't realise that
03:06:56 <Syzygy-> No need to apologize! :)
03:07:24 <ivanm> I wish someone would do better documentation for lambdabot and how to use her...
03:10:14 <ejt> is lambdabot awake, it doesn't seem to be responding
03:10:16 <ejt> ?
03:10:53 <george--> > 1 + 1
03:11:38 <ivanm> doesn't look like it... :(
03:12:15 <ivanm> We'll probably get a whole lot of urls  and whatever from before as soon as she wakes up, though ;)
03:12:17 <ejt> is it single threaded ?
03:16:38 <ivanm> I'd guess so.....
03:17:03 <ivanm> btw, in haskell, how much work has to be done to turn a single-threaded program into multi-threaded?
03:17:08 <ejt> ... so did anyone ask it the meaning of life recently ?
03:17:27 <ivanm> not that I noticed...
03:17:45 <AWizzArd> Moin
03:18:03 <ivanm> the last mention I can find of LB is the title of the web-page containing the haskell-mode for emacs...
03:18:41 <ivanm> dcoutts then pasted another link, but LB hasn't responded to that yet...
03:19:23 <AWizzArd> about polymorphism in Haskell: as far I understand it, it means that functions work for containers, like lists, regardless of the types of the data inside the container. Is that right so far? Is there more to it?
03:21:08 <ivanm> Only if the data inside the container supports that type of functions
03:22:03 <ivanm> e.g. for Show: each new type has to implement the show function
03:22:27 <pejo> AWizzArd, I wouldn't say that 'id' takes a 'container', yet it works for all terms.
03:22:50 <ejt> ivanm: polymorphism exists even without classes
03:23:30 <ivanm> ejt: oh, yeah, I suppose "id" doesn't depend on a class (generic base class that everything is an instance of?)
03:24:01 <AWizzArd> ok
03:24:33 <ejt> if you're thinking about 'base classes' then you're still using a C++/Java frame of mind
03:25:10 <ejt> AWizzArd: your first statement was correct, except it's not limited to containers, just easy to find examples with containers
03:25:54 <pejo> ejt, there's nothing inherent in subtyping that prevents it from being a part of a functional language.
03:26:20 <ivanm> ejt: I wasn't thinking entirely in terms of OO, its just that for many functions, they work on instances of a type (e.g. show, succ, etc.), so I was idly wondering whether _all_ types could be considered to be instances of some underlying base type, for the generic functions like id, head, etc.
03:26:48 <ejt> hmm
03:26:51 <nmessenger> forall a. a
03:27:00 <pejo> ivanm, since our type system is polymorphic we don't need to encode everything as inherited from a common base class.
03:27:30 <nmessenger> unfortunately, you can't do anything useful with a (forall a. a) except pass it around
03:27:34 <ivanm> pejo: it was just idle speculation, just wondering if you could consider it that way...
03:27:52 <ejt> ivanm: this base class would have no properties though
03:28:10 <ivanm> ejt: I know, its just an interesting mental image
03:28:11 <nmessenger> I think GHC does have a top type of sorts internally
03:28:16 <ejt> ivanm: y
03:28:20 <nmessenger> GHC.Prim.Any or something
03:28:29 <ivanm> well, it has to be defined in binary eventually...
03:29:04 <pejo> nmessenger, is 'sort' in this context the type of kinds?
03:29:42 <nmessenger> "top type of sorts" = "some variety of top type" :P
03:30:33 <nmessenger> "of sorts" isn't code, it's an English weakening phrase
03:31:21 * nmessenger just now gets the "type of kinds" thing.  Metakinds FTW!
03:31:32 <pejo> nmessenger, ok. I don't understand. Since we don't have subtyping, how can you have a top type?
03:32:16 <nmessenger> I don't understand it myself.  Apparently it's used as a placeholder when GHC can't unify yet.
03:32:36 <nmessenger> s/placeholder/placeholder of sorts/ :P
03:32:47 <pejo> nmessenger, so what is being discussed here is the implementation of the type checker in GHC=?
03:33:06 <nmessenger> yep, that's why I said "internally"
03:34:00 <pejo> Aha. I think that appears in let-nodes in combination with type classes. My impression is that it basically pushes everything 'up' in the tree, unifying later.
03:34:38 <ivanm> so my mental construct isn't so mental after all?
03:35:09 <nmessenger> so, implementation detail.  The Haskell report doesn't really mention a top type.
03:35:24 <nmessenger> but (forall a. a) can be any type at all.
03:36:19 <nmessenger> @tell lambdabot Wake Up!
03:40:04 <dons_> ?bot
03:40:30 <dons_> nmessenger: any value at all, you mean (hmm, not things of unboxed kind though ;)
03:40:39 <dons_> any value of kind *
03:41:16 <ivanm> @botsnack
03:41:21 <nmessenger> dons: heh, my knowledge of these things isn't very sophisticated, but I can sure fake it :)
03:41:28 <lambdabot> :)
03:41:37 <dons_> :t 1#
03:41:38 <ivanm> Ahhhh, LBs finally back!!!!!!!!!!1
03:41:48 <lambdabot> GHC.Prim.Int#
03:41:55 <ivanm> a bit slow though.......
03:42:00 <nmessenger> @. kind type 1#
03:42:03 <dons_> takes a little whie to settle
03:42:05 <ivanm> what are unboxed types?
03:42:08 <lambdabot> #
03:42:13 <ivanm> s/types/values
03:42:32 <dons_> ivanm: to distinguish normal heap objects (which may contain bottom (or undefined)), from strict machine values
03:42:43 <dons_> the types for these values are partitioned into separate kinds
03:42:52 <dons_> so types have their own types, either * or #
03:42:58 <dons_> and for type constructors, * -> * and so on
03:43:02 <nmessenger> * (* -> *) ? ?? #
03:43:06 <ivanm> what is bottom? I saw it mentioned in terms of 'seq', but didn't get it
03:43:09 <dons_> for example, the kind of Int
03:43:11 <pejo> dons, so the kind of unboxed values is #?
03:43:11 <nmessenger> it's like swearwords!
03:43:13 <dons_> :k Int
03:43:14 <lambdabot> *
03:43:23 <dons_> :k GHC.Base.Int#
03:43:24 <lambdabot> #
03:43:29 <dons_> :k Either
03:43:31 <lambdabot> * -> * -> *
03:43:39 <dons_> a type constructor, that takes two types of kind * as arguments
03:43:42 <dons_> :k (->)
03:43:44 <lambdabot> ?? -> ? -> *
03:43:58 <ivanm> so what's the difference between * and #?
03:44:00 <dons_> the function arrow type constructor can take types of any kind, yielding a boxed value
03:44:00 <nmessenger> > let infiniteLoop = infiniteLoop in infiniteLoop -- <- is bottom
03:44:02 <lambdabot>  Add a type signature
03:44:07 <nmessenger> > let infiniteLoop = infiniteLoop in infiniteLoop :: () -- <- is bottom
03:44:10 <lambdabot>  Exception: <<loop>>
03:44:11 <dons_> ivanm:values of kind # are strict
03:44:17 <dons_> and map to raw primitive types on the machine
03:44:19 <dons_> so
03:44:24 <dons_> > undefined :: Int -- has kind *
03:44:26 <lambdabot>  Undefined
03:44:29 <ivanm> so bottom is when things loop infinitely?
03:44:57 <ivanm> like infinite = infinite + 1?
03:44:59 <dons_> or an exception, or a segfault :-)
03:45:05 <nmessenger> that's one good way to look at it, basically, bottom is the "return value" from a function that doesn't return.
03:45:10 <dons_> :t undefined :: Int
03:45:12 <lambdabot> Int :: Int
03:45:14 <ivanm> OK, that makes sense then
03:45:18 <dons_> :t undefined :: GHC.Base.Int# -- kind error
03:45:19 <lambdabot>     Couldn't match kind `#' against `*'
03:45:19 <lambdabot>     When matching the kinds of `GHC.Prim.Int# :: #' and `a :: *'
03:45:24 <nmessenger> so it doesn't *actually* exist
03:45:27 <ivanm> so what's the use/point of unboxed values? more grunt?
03:45:39 <dons_> so when you have a value of kind #, you know it can never be bottom (this is useful for the strictness analyser)
03:45:49 <dons_> ivanm: and yeah, ultimately you want to compile down to strict machine words
03:45:51 <nmessenger> strictness, efficiency
03:45:56 <dons_> so its useful to have a notion of them in the compiler
03:46:17 <pejo> It's almost like .. we're trying to avoid laziness. :P
03:46:23 <dons_> but strict machine words have funny properties (i.e. they're not lazy), so they better have their own type.
03:46:31 <dons_> their own kind.
03:46:34 <ivanm> how does the use of Int#, say, differ from normal Int?
03:46:44 <ivanm> :t 1#
03:46:46 <lambdabot> GHC.Prim.Int#
03:46:53 <ivanm> [1#..5#]
03:46:54 <dons_> an Int can be evaluated lazily, and stored in the heap
03:46:58 <dons_> as a closure
03:47:09 <ivanm> > [1#..5#]
03:47:09 <nmessenger> heh, strict languages have trouble with laziness, strictness in Haskell is similarly problematic
03:47:09 <lambdabot>  Parse error
03:47:10 <dons_> and Int# is strict, and not boxed
03:47:12 <TwigEther> a/win 2
03:47:20 <TwigEther> fail
03:47:29 <dons_> :k [] -- note the kind
03:47:31 <ivanm> OK, so boxed is???
03:47:31 <lambdabot> * -> *
03:47:47 <dons_> so its a static (kind) error to store a value whose type has kind # in a list
03:47:51 <nmessenger> :k Int
03:47:53 <lambdabot> *
03:47:54 <nmessenger> :k [Int]
03:47:56 <lambdabot> *
03:47:59 <dons_> ivanm: another name for a ptr to a value on the heap
03:48:07 <dons_> like a Java object
03:48:13 <ivanm> dons_: ahhh, OK
03:48:14 <dons_> versus a java primitive type
03:48:17 <dons_> Integer vs int
03:48:29 <dons_> i'm not sure if they actually distinguish the kinds in Java (?)
03:48:30 <nmessenger> Int vs. GHC.Prim.Int#
03:48:32 <ivanm> so when exactly would you use Int# rather than Int? (as in an example)?
03:48:52 <dons_> sometimes its useful for hand compiling your code (i.e. efficiency)
03:48:53 <nmessenger> ivanm: in the shootout :P
03:48:56 <ivanm> in Java, you have primitive ints and Integer, which is int wrapped in an object
03:49:12 <dons_> but generally its not that useful. since a bang pattern is enough to have the compiler assume the strictness, and then unbox for you
03:49:23 <dons_> ivanm: right, that's what an Int is
03:49:25 <dons_> ?src Int
03:49:26 <lambdabot> data Int = I# Int#
03:49:28 <dons_> see!
03:49:29 <ivanm> so, does Int# instantiate Ord, Eq, etc?
03:49:36 <dons_> a constructor that wraps an Int#
03:49:42 <ivanm> ahhh, OK
03:49:45 <nmessenger> Int is to Int# as Integer is to int
03:49:46 <pejo> nmessenger, how do strict languages have trouble with laziness?
03:49:50 <dons_> no, you have primops on Int#
03:49:55 <dons_> like <# ># and so on
03:50:10 <dons_> pejo: they do it verbosely, if at all?
03:50:39 <nmessenger> "have trouble with" < "can't do"
03:50:40 <dons_> :k (# 1, 2 #)
03:50:42 <lambdabot> Only unit numeric type pattern is valid
03:50:42 <pejo> dons, can't you just wrap your expression in a lambda abstraction?
03:50:53 <dons_> :t (# 1, 2 #)
03:50:55 <lambdabot> forall t t1. (Num t, Num t1) => (# t, t1 #)
03:51:03 <dons_> that's an unboxed pair
03:51:08 <nmessenger> @. kind type (# 1, 2 #)
03:51:11 <lambdabot>     Kind mis-match
03:51:11 <lambdabot>     Expected kind `*', but `(# t, t1 #)' has kind `(#)'
03:51:15 <dons_> which ghc knows it can stick on the stack, and otherwise compile to efficient code
03:51:26 <dons_> avoiding any heap allocation
03:51:54 <dons_> :k (# Int, Bool #)
03:51:55 <lambdabot> (#)
03:52:11 <dons_> its of unboxed pair kind
03:52:16 <dons_> :k (,)
03:52:17 <lambdabot> * -> * -> *
03:52:31 * nmessenger was referred to a section of the GHC source that discussed the various kinds
03:53:12 <quicksil1er> Is GHC using a C-- backend now? or is it C and asm?
03:53:17 <nmessenger> now we need higher-metakinded kind constructors!
03:53:26 <dons_> it compiles  ghc Core to a C-- like language internally
03:53:31 <dons_> then transates that to C or asm
03:53:40 <dons_> some of the runtime system is written in C--
03:53:46 <dons_> and compiled to C/asm by ghc
03:54:02 <dons_> but it doesn't use any of the wacky cisc-ish C-- features :-)
03:54:06 <quicksil1er> dons_: so ghc includes a built-in C-- compiler?
03:54:08 * quicksil1er nods
03:54:14 <dons_> quicksil1er: for a subset of C--, yeah
03:54:18 * quicksil1er nods
03:54:22 <Syzygy-> :k (,) Int
03:54:23 <nmessenger> wouldn't (->) on the kind level be a higher-metakinded kind constructor? :)
03:54:23 <lambdabot> * -> *
03:54:27 <Syzygy-> :k (,) Int Int
03:54:27 <pejo> dons, is it me or is www.cse.unsw.edu.au out of DNS servers?
03:54:28 <lambdabot> *
03:54:28 <xpika> how does haskell treat the infix notation for functions with an arity greater than 2?
03:54:30 <xic> can C-- be used for JIT compiling?
03:54:31 <Syzygy-> Hah!
03:54:45 <quicksil1er> xpika: the infixy part just applies to the first two paramters, basically
03:54:48 <Syzygy-> xpika: I would guess first infix second third
03:55:01 <quicksil1er> xpika: haskell doesn't actually know or care about the arity of functions, in general
03:55:07 <kosmikus> more like (first infix second) third
03:55:10 <nmessenger> (f . g) x or f . g $ x
03:55:11 <dons_> (a `f` b) c
03:55:13 <quicksil1er> it just complains if you try to apply something which turns out not to be a function
03:55:16 <nmessenger> @src (.)
03:55:16 <lambdabot> (.) f g x = f (g x)
03:55:31 <dons_> @src (***)
03:55:32 <lambdabot> f *** g = first f >>> second g
03:55:36 <nmessenger> @src (->) (***)
03:55:37 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
03:55:44 <dons_> that's the one :-)
03:56:02 <nmessenger> @quote drops.dead
03:56:03 <lambdabot> No quotes match. It can only be attributed to human error.
03:56:11 <dons_> heh
03:56:12 <quicksil1er> occasionally I think I'd like "outfix" operators
03:56:15 <quicksil1er> custom brackets
03:56:23 <quicksil1er> but normally there are tricks you can play to get that syntax
03:56:24 <dons_> yeah, people like custom brackets
03:56:25 <nmessenger> dons_: does LB lose her state when you restart her?
03:56:33 <ivanm> apart from ghc, is c-- actually used for anything? (I thought simon peyton jones invented/developed c-- for ghc :s )
03:56:33 <dons_> only if something bad happens
03:56:40 <dons_> nmessenger: usually not, but it has been known to happen
03:56:43 <nmessenger> I added a quote with drops.dead earlier
03:56:54 <dons_> supposedly sigterm flushes the state, but it doesn't always seem to work
03:57:04 <pejo> ivanm, Norman Ramsey and his students have done a lot of good research on compiler backends with C--
03:57:39 <xpika> seems that by default `infix` notation has a low precedence?
03:57:58 <dons_> hehe, i see we're now ahead of ocaml on the shootout. yay
03:58:06 <dons_> ?shootout
03:58:07 <nmessenger> the report specifies default infixl 9 `f` I think
03:58:07 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
03:58:16 <nmessenger> @where report
03:58:17 <lambdabot> http://www.haskell.org/onlinereport/
03:58:32 <dons_> and there's still some queued up fixes for the numerics benchmarks waiting to apply as well, which should lift the score further
03:58:41 <ivanm> pejo: so C-- is meant to be a generic/portable backend to any C compiler?
03:58:57 <xpika> ivanm: indeed.
03:59:03 <nmessenger> @where+ fixity http://www.haskell.org/onlinereport/decls.html#sect4.4.2
03:59:03 <lambdabot> Done.
03:59:30 * dons_ graph of the day: which high level language with lambda and closures do you prefer? http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ruby
03:59:38 <nmessenger> "Any operator lacking a fixity declaration is assumed to be infixl 9"
04:00:50 <pejo> ivanm, backend to any compiler rather. But yeah, that is the idea. You have a pluggable GC api, and things. Very nice design.
04:01:04 <ivanm> pejo, xpika: OK, thanks
04:01:21 <quicksil1er> yes, I've seen one of SPJ's C-- talks
04:01:25 <quicksil1er> he makes a most convincing case :)
04:01:39 <quicksil1er> (one wonders why he didn't manage to convince himself, though...)
04:01:41 <ivanm> dons: I just looked at the shootout page... how is haskell beating ocaml?
04:01:56 <dons> the score is higher.
04:01:59 <pejo> quicksil1er, he's rather convicning no matter what he's talking about though, so that doesn't say much. :-)
04:01:59 <ivanm> quicksil1er: in that he doesn't fully use C-- for ghc?
04:02:06 <dons> 1.3   Haskell GHC             136.4
04:02:07 <quicksil1er> ivanm: yes, in that
04:02:09 <dons> 1.4   OCaml                   133.6 2
04:02:11 <dons> :-)
04:02:17 <nmessenger> ivanm: by having crazy people like dons to write crazy code
04:02:19 <quicksil1er> pejo: fair point, although I like to think I'm a fairly critical listenrer
04:02:33 * quicksil1er suggests integrating the shootout code into the GHC runtime :P
04:03:00 <ivanm> dons: whoops, something went wrong there... the memory use and gzip bytes sections were "0" for me for some reason...
04:03:19 <dons> it remembers old defaults. hit 'reset'
04:03:33 <dons> we clean up ocaml on memory usage too
04:03:59 <ivanm> dons: yep, just did... but I don't remember touching any of the values there though (unless the meaning of "default" changed...)
04:04:00 <Thunder> Clean is better in almost all cases.
04:04:11 <dons> ivanm: maybe they changed the defaults back to include all 3 numbers?
04:04:17 <Thunder> So let's close this channel and learn Clean asap.
04:04:25 <dons> its missing a community
04:04:42 <Thunder> This benchmark compares programmers, not languages.
04:04:43 <dons> and 5 benchmarks too, it seems. hmm, missing libraries?
04:04:47 <ivanm> Thunder: ummm..... but the clean score is 1.6 to ghc's 1.3, so how is it better? ;)
04:05:00 <nmessenger> Thunder: precisely!
04:05:06 <dons> Thunder: it also measures libraries
04:05:21 <dons> Thunder: though i still think it will be hard to make ruby do well
04:05:29 <dons> not matter how good the programmer. sometimes it is just the language
04:05:34 <pejo> Regardless of what a benchmark measures, people will look at it, and draw conclusions from it.
04:05:41 <dons> the implementation,i should say
04:05:53 <Thunder> dons: Every adavanced programmer can code Fortran in any language.
04:05:54 <ivanm> hmmm.... comparing clean to ghc, though, clean seems to be better in more benchmarks...
04:06:04 <dons> Thunder: please do so :-) its quite hard
04:06:04 <quicksil1er> clean gets docked points for it's large number of failures, I suspect
04:06:18 <ivanm> Thunder: which version of Fortran? ;)
04:06:55 <dons> its a useful exercise just to chase C down in a high level language
04:06:55 * Thunder suggests a better array operator notation. On IRC most programms contains little yellow faces.
04:06:55 <sieni> ivanm: there's no other FORTRAN than FORTRAN IV. The other FORTRANs are cheap imitations.
04:07:07 <dons> we were all very surprised when haskell ghc starting beating C in some of the benchmarks
04:07:15 <dons> until we did that, i'm not sure anyone believed it was possible
04:07:18 <Thunder> sieni: Exacty!
04:07:21 <quicksil1er> If you were designing a simple bytecode-ish system as a DSL compilation target, what shape would it be? Forth-like? (stack based)?
04:07:32 <dons> now we at least know it is possible, some of the time
04:07:45 <ivanm> sieni: even the standardised ones? Fortran 90 isn't too bad...
04:07:54 <quicksil1er> or should I go the whole hog and use hs-plugins and embed my DSL in haskell? somehow that doesn't feel right.
04:07:57 <ivanm> and its now "Fortran", not "FORTRAN"
04:08:28 <dons> I think we should rename Haskell' to HASKELL-PRIME
04:08:37 <dons> leader of the autobots
04:08:53 <Thunder> My code on http://hpaste.org/339 requires 1.8 * 10^33 bytes at least.
04:09:16 <Thunder> dons: Like Ada'Succ?
04:09:35 <dons> might be a good idea to profile your code, then use a better algorithm
04:09:58 <Thunder> dons: I'd use a berrer algorithm first.
04:10:03 <Jaak> > (minBound, maxBound) :: (Int, Int)
04:10:05 <lambdabot>  (-2147483648,2147483647)
04:10:58 <nmessenger> > (minBound, maxBound) :: (Char, Char)
04:10:59 <lambdabot>  ('\NUL','\1114111')
04:11:33 <dons> > (minBound, maxBound) :: (Word256,Word256)
04:11:37 <lambdabot>  (0,1157920892373161954235709850086879078532699846656405640394575840079131296...
04:11:51 <wilx|wrk> Word256? :)
04:11:56 <dons> lambdabot is 256 bit ready
04:12:02 <sieni> <3
04:12:02 <wilx|wrk> Heh.
04:12:17 <nmessenger> > ord (maxBound :: Char)
04:12:18 <lambdabot>  1114111
04:13:03 <ejt> that's an odd number, is that unicode ?
04:13:20 <nmessenger> @hoogle hex
04:13:20 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
04:13:21 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
04:13:21 <lambdabot> Numeric.readHex :: Integral a => ReadS a
04:13:56 <nmessenger> > showHex (ord (maxBound)) ""
04:13:58 <lambdabot>  "10ffff"
04:14:21 <nmessenger> yepppers
04:14:25 <ejt> :)
04:14:38 <pejo> dons, what year does that correspond to? ;)
04:15:18 <Thunder> nmessenger: Why is "showHex" not hoggleable?
04:15:48 <nmessenger> > shows (1970 + (maxBound :: Word8) `div` (86400 * 365.24)) " years"
04:15:48 <dons> pejo: good question!
04:15:49 <lambdabot>   add an instance declaration for (Fractional Word8)
04:16:10 <dons> > printf "%x" (ord (maxBound)) :: String
04:16:11 <lambdabot>  "10ffff"
04:16:22 <quicksil1er> @type printf
04:16:24 <lambdabot> forall r. (PrintfType r) => String -> r
04:16:26 <nmessenger> > shows (1970 + (maxBound :: Word256) `div` floor (86400 * 365.24)) " years"
04:16:31 <lambdabot>  Exception: scripts0: No instance nor default method for class operation GHC....
04:16:38 <nmessenger> eh?
04:16:40 <Thunder> dons: printf is an interpreter. You should not use that.
04:16:55 <dons> works for me.
04:17:14 <Thunder> WFM is the root of a lot of bad programms out there.
04:17:23 <dons> printf "%s %s %d" "this" "is" pi :: String
04:17:30 <dons> > printf "%s %s %d" "that" "is" pi :: String
04:17:31 <lambdabot>  Add a type signature
04:17:38 <dons> > printf "%s %s %d" "that" "is" (pi::Double) :: String
04:17:39 <lambdabot>  Exception: Printf.printf: bad argument
04:17:56 <dons> > printf "%s %s %f" "that" "is" (pi::Double) :: String
04:17:56 <Thunder> Usually it is combined with DIC (documention is C-code) and NIH (not invented here).
04:17:57 <lambdabot>  "that is 3.141592653589793"
04:18:00 <dons> its a handy wrapper for show
04:18:21 <dons> and its not a binding to C's printf, so i wouldn't worry too much :-)
04:18:21 <matthew_-> printf "%s %s %d" :: String -> String -> Int -> IO () -- as cayenne, some crazy ML, and associated types will tell you!
04:18:26 <Thunder> printf is very hard to optimise.
04:18:43 <dons> its not C's printf, don't stress!
04:18:53 <dons> :t printf "%d %c %c" (1 :: Int) 'x'
04:18:54 <quicksil1er>  its a neat proof of concept of some very clever type hackery, IMO
04:18:55 <lambdabot> forall t. (PrintfType (Int -> Char -> t)) => t
04:18:57 <nmessenger> > showString "a word256 would expire in AD " $ shows (1970 + (maxBound :: Word256) `div` (86400 * 365))
04:18:58 <lambdabot>      Expecting a function type, but found `a'
04:18:59 <lambdabot>       Expected type: String
04:18:59 <lambdabot>    ...
04:19:00 <Thunder> It has to parse the first argument.
04:19:02 <nmessenger> > showString "a word256 would expire in AD " $ shows (1970 + (maxBound :: Word256) `div` (86400 * 365)) $ ""
04:19:07 <lambdabot>  Exception: scripts0: No instance nor default method for class operation GHC....
04:19:13 <nmessenger> ^ what's that?
04:19:14 <dons> quicksil1er: yeah, quite useful in practice in fact
04:19:23 <dons> nmessenger: the Word* types greater than 64 are missing some methods
04:19:28 <dons> I think * is one of them :-)
04:19:35 <nmessenger> heh
04:19:35 <quicksil1er> Thunder: all programs of significance include parsers
04:19:39 <dons> just enough there to do crypto
04:20:00 <araujo> morning
04:20:16 <dons> the haskell printf is just a little edsl for concat and show, its quite cute
04:20:38 <audreyt> and any performance worry over printf parsing its argument is paled by comparison with the [Char] type it works with.
04:20:42 <dons> also, its overloaded in the return type, so you can get sprintf for free
04:20:49 <nmessenger> but it isn't typesafe, though, right?
04:21:05 <dons> > printf "%d" "checked at runtime"
04:21:06 <lambdabot>  Add a type signature
04:21:10 <dons> > printf "%d" "checked at runtime" :: String
04:21:11 <lambdabot>  Exception: Printf.printf: bad argument
04:21:17 <dons> the static version uses TH
04:21:39 <audreyt> TH is probably the "right" solution here
04:21:50 * nmessenger misunderstood "typesafe" to mean "statically typesafe"
04:22:05 <audreyt> a compiler that spends time parsing and compiling is...
04:22:14 <audreyt> ...just a compiler doing its usual work. :)
04:22:17 <dons> heh
04:23:06 <nmessenger> mayhap some type hackery and a more specific pattern type could move checking to compile-time without TH?
04:23:08 <dons> morning apfelmus
04:23:21 <dons> nmessenger: a GADT for the format string
04:23:42 <dons> just embed the AST for the fmt interpreter, rather than a string, and check the type of this embedded lang statically
04:23:53 <dons> i think there's even a few in here who could just about code that up
04:24:04 <dons> audreyt: sound reasonable?
04:24:12 <apfelmus> dons: hi!
04:24:23 <audreyt> sure, and that's what TH does, esentially, by emitting to its metalanguage
04:24:26 <audreyt> (in this case haskell)
04:24:30 <dons> of course, once you start writing the format string as a bunch of constructors its not so concise any more
04:24:33 <audreyt> s/TH/TH printf/
04:24:36 <dons> yeah
04:24:45 <nmessenger> very true
04:25:26 <dons> there's enough dependent typery in GADTs to scrape through
04:25:55 <dons> apfelmus: want to hack up a little demo of a printf-like function using a GADT based eval for the format string? such that the format string is statically checked?
04:25:55 * nmessenger adds "dependant typery" to his notebook
04:26:15 * nmessenger then scratches out the 'a' and writes in an 'e'
04:26:16 <audreyt> runghc should probably accept a -e flag...
04:26:27 <audreyt> runghc -e 'random haskell oneliner'
04:26:32 <dons> ghc -e "foo" ?
04:26:44 <dons> $ ghci -e "1+2"
04:26:44 <dons> 3
04:26:47 <audreyt> aha.
04:27:00 <dons> one char shorter:
04:27:01 <dons> $ ghc -e "1+2"
04:27:02 <dons> 3
04:27:06 <nmessenger> take THAT perl!
04:27:07 <audreyt> then ghc needs -M :)
04:27:38 <audreyt> ghc -M Text.Printf -e 'printf "hi %s" "foo"'
04:27:50 <dons> yeah, that is shorter than perl. huh
04:27:55 <dons> nice of ghci to show the result
04:27:59 <mux> then we need Cabal.Shell
04:28:06 <dons> audreyt: yeah
04:28:29 <quicksil1er> time ghc -e "1+2" real    0m2.106s
04:28:37 <quicksil1er> time perl -e "print qq(1+2\n)" real    0m0.114s
04:28:47 <nmessenger> dons: too bad all the library function have clear names or else Haskell one-liners could STOMP on perl's :o)
04:28:50 <apfelmus> dons: why not. but how to supply the arguments to eval? and how to code the format string?
04:28:54 <dons> $ ghc -e 'Text.Printf.printf "%s\n" "foo" :: IO ()'
04:28:55 <dons> foo
04:28:57 <apfelmus> i mean String is not enough
04:29:08 <dons> audreyt: you've got ghci's auto-importing there to play with
04:30:06 <dons> quicksil1er: yeah, you're watching ghci link the base library dynamically
04:30:18 <quicksil1er> dons: *nod* I guessed that was the case
04:30:29 <dons> there's a hack floating around to statically linke the base lib, and fake a dynamic export (ld trick)
04:30:32 <dons> that avoids that cost
04:30:48 <dons> but it breaks some things in the rts , simon said (though *shrug* 1second faster1)
04:34:11 <dons> audreyt: i noticed a 3 fold speedup today in some Double-heavy code when using -optc-march=pentium4
04:34:24 <dons> audreyt: might be of interest (not sure how you do Double math, but I guess its with Doubles?)
04:34:31 <audreyt> yeah.
04:34:34 <audreyt> cool
04:35:02 <dons> much much better asm generated (ike half the size)
04:35:07 <ivanm> what other compiler options are available that aren't listed in the ghc guide? all the gcc compiler flags?
04:35:14 <dons> ivanm: yeah
04:35:19 <dons> and ld's flags
04:35:46 <ivanm> OK, I'll have a look at them tomorrow and see if they give me any more of a speedup (I hope they do!!!)
04:35:47 <dons> e.g. to auto strip your haskell executable, -optl-Wl,-s
04:35:57 <audreyt> #define BEGIN(x) $(runIO(x) >> [| return () |])
04:36:02 <dons> ivanm: the main ones to watch for are the arch specific stuff for floating point
04:36:07 <ivanm> btw, is there a way to profile a program that doesn't finish?
04:36:08 <audreyt> # nice perl emulation thing
04:36:11 <dons> and hmm, -optc-O2 is sometimes better
04:36:20 <dons> audreyt: mm :)
04:36:24 <audreyt> main = BEGIN(print "Hey this is during compilation")
04:36:26 <ivanm> dons: well, I'm not using any floating point calcs..... mainly just list manipulation
04:36:35 <dons> ivanm: the new ghc 6.6 can do that (you mean, if it is termianted somehow?)
04:36:48 <dons> ivanm: gcc won't help much. you've got to get the right data structures first
04:37:09 <dons> gcc only helps once ghc starts producing perfect Core code
04:37:16 <dons> then  gcc effects start to dominate
04:37:22 <dons> (and things like cache misses)
04:37:26 <ivanm> dons: when I terminate it manually... my code takes <20 seconds for 4*4 Latin Squares, but has gone for just under 3 days without giving me any results for 5*5
04:37:39 <dons> i think maybe you need a better algorithm
04:37:48 <ivanm> I know the problem is super-exponential, but I was hoping it'd take at most a day
04:38:01 <ivanm> dons: yeah, I know, but its a bit too late to start ;)
04:38:03 <quicksil1er> you haven't given us enough data points to extrapolate :)
04:38:07 <dons> that's a hard one. termiatning it should produce a profile though
04:38:19 <quicksil1er> it could be 300 years for 5*5
04:38:24 <dons> yeah, try 6*6, it might go faster
04:38:40 <dons> back to 20 seconds. it just an effect of being a multiple of 5 ;)
04:38:45 <xic> i'm having trouble understanding how lift works
04:38:47 <ivanm> quicksil1er: the same program I've been asking questions about for the past few weeks here, so it uses [[Int]] as a matrix
04:38:52 <nmessenger> @type lift
04:38:54 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
04:38:57 <quicksil1er> ivanm: yes, I know :)
04:39:07 <ivanm> dons: lol! well,l I know that it _should_ give me results for 5*5...
04:39:11 <dons> ivanm: an IOUArray (Int,Int) Int might be better
04:39:11 <mauke> what's an interesting simple grammar I could use to test my parser library?
04:39:27 <quicksil1er> but you don't actually know if it's 2^2^n or 2^2^(4n) or even 2^2^(n^2 lg n)
04:39:49 <ivanm> dons: well, I'll have a look but I think its a bit too late to re-write it... but does it support iterating through rows and columns?
04:39:55 <nmessenger> @google false programming language
04:39:56 <audreyt> hm, slightly more useful:
04:40:00 <dons> ivanm: arrays, yes.
04:40:01 <audreyt> #define BEGIN(x) $(runIO(x) >>= return . LitE . StringL)
04:40:04 <audreyt> main = print $ BEGIN( readFile "/etc/passwd" )
04:40:11 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
04:40:12 <audreyt> -- readFile runs at compile time
04:40:20 <nmessenger> @google false programming language
04:40:20 <ivanm> I know that ~20% of my CPU time is spent transposing the matrix to get the columns....
04:40:30 <ivanm> well, I'll have a loook at IOArray tomoorw
04:40:33 <dons> audreyt: very nice. have you seen the gcc trick Igloo wrote?
04:40:34 <ivanm> *tomorrow
04:40:35 <nmessenger> hmm
04:40:36 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
04:40:42 <audreyt> dons: no. where?
04:40:43 <nmessenger> @google google
04:40:44 <dons> it generates some C, compiles it with gcc, loads the result back in to haskell and compiles that
04:40:45 <lambdabot> http://www.google.com/
04:40:46 <lambdabot> Title: Google
04:40:55 <dons> oh, its a famous early TH hack from 2003 or so
04:41:15 <quicksil1er> ivanm: the ratio between 2^2^4 and 2^2^5 is 65k
04:41:25 <quicksil1er> ivanm: so by that estimate, I'd expect to wait 15 days :)
04:41:30 <ivanm> quicksil1er: I know :(
04:41:32 <dons> @google hoogle
04:41:34 <lambdabot> http://haskell.org/hoogle/
04:41:34 <lambdabot> Title: Hoogle
04:41:42 <quicksil1er> @hoogle google
04:41:42 <dons> phew, it used to be something else
04:41:43 <lambdabot> No matches found
04:41:43 <ivanm> quicksil1er: I got 15000 days...
04:41:47 <dons> hehe
04:41:49 <nmessenger> @zoogle boogle
04:41:50 <lambdabot> Maybe you meant: google hoogle
04:41:53 <quicksil1er> now you see that's just unfair
04:42:06 <audreyt> dons: nice!
04:42:06 <quicksil1er> if google's goign to link to hoogle hoogle should return the favour!
04:42:49 <audreyt> dons: so I'm going to give a talk at google.tw next monday. I intend to focus on metaprogramming and parallelism, since that's where Pugs (and really, haskell) shines
04:43:06 <audreyt> dons: any recent progress that I should be aware of, on the GPU front or other related front?
04:43:20 <ivanm> quicksil1er: But the annoying thing is, my mentor's C code was fast enough to give him results in a reasonable amount of time... and know he's telling me I'm stupid for not choosing C!!! (then again, his code had errors!!!)
04:44:40 <nmessenger> if it has errors!!! then it doesn't matter what language it's written in!!! it doesn't count!!!
04:45:19 <ivanm> nmessenger: I know!!! his assumptions were wrong!!!
04:45:35 <Jaak> > replicate 20 '!' ++ "111one1"
04:45:37 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!111one1"
04:45:43 <ivanm> lol, I think we can get over the exclamation marks ;)
04:45:53 <ivanm> (I didn't even realise I was doing it at first)
04:46:13 <earthy> ivanm: can you simply rewrite the code to use UArray Int instead of [[Int]]?
04:46:13 * audreyt quietly contemplates larry's choice of making !!! a builtin macro in perl 6 that throws fatal exceptions
04:46:21 <nmessenger> heh
04:46:25 <dons> audreyt: there's the paper from DAMP, the state of the data parallel haskell project
04:46:37 <dons> audreyt: also, the user level threads work was presented, (10M threads in ghc)
04:46:44 <dons> you want the refs?
04:46:44 <vincenz> dons: I take it that the final version was not that efficient?/
04:46:52 <dons> vincenz: hmm?
04:46:55 <audreyt> Data Parallel Haskell: a status report
04:47:04 <audreyt> reading. thanks!
04:47:11 <dons> vincenz: oh, yours. it broke the diff. *but* i found a huge speedup elsehere
04:47:15 <pejo> dons, was it the damp paper that presented 10M threads in ghc?
04:47:23 <vincenz> dons: ooh, what was it?
04:47:25 <ivanm> earthy: at the moment, I don't know... too tired to have a look at it right now (also hoping that the optimizations I did today had an effect when I go check the results tomorrow)
04:47:29 <dons> pejo, the invited talk
04:47:47 <quicksil1er> > concat $ concatMap (uncurry replicate) [(20,"!"),(3,"1"),(3,"one")]
04:47:48 <dons> vincenz: some tricks with gcc flags meant we got the right asm
04:47:48 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!111oneoneone"
04:47:55 <vincenz> dons: nice
04:48:37 <dons> audreyt: also (Simon was saying something about all of ghc's threads looking like this) http://www.seas.upenn.edu/~lipeng/homepage/unify.html
04:48:38 <lambdabot> Title: Unifying events and threads
04:48:59 <dons> basically, user land threads and user land schedulers
04:49:06 <dons> on top of epoll
04:49:14 <audreyt> I've read that...
04:49:39 <dons> so they were the main things I can think of.
04:49:45 <mux> mmm, interesting
04:49:49 <audreyt> under unify, the thread abstraction will be the same as today right?
04:49:56 <audreyt> it's just we gain new event abstraction primitives
04:49:58 <dons> i think so, yeah.
04:50:17 <audreyt> mmm.
04:50:50 <dons> audreyt: also, stream fusion for distributed array rebalancing
04:50:52 <audreyt> dons: so is this aio thing checked into 6.5 tree?
04:50:59 <audreyt> or at least "6.6 planned"?
04:51:07 <dons> using stream fusion on DPH arrays to remove redistribution points for parallel arrays
04:51:32 <dons> not in the tree, afaik.
04:51:50 <audreyt> (in Perl we have this Coro.pm that does the same thing and provides both interfaces, which emulates AIO with various tricks on platforms without aio. may be useful to compare)
04:51:55 <dons> 6.7 tree you mean ;)
04:52:05 <audreyt> yeah :)
04:52:10 <audreyt> <- on OSX, not linux, at the moment
04:52:18 <dons> oh, that's interesting
04:55:00 <audreyt> yeah. the emulation layer (AIO::AIO) really has nothing perl specific
04:55:11 <audreyt> er, IO::AIO
04:55:28 <audreyt> and so might be interesting to simply ship it as part of unify...
04:55:39 <pejo> audrety, so the OS strives to make IO synchronous, and perl to make it asynchronous again?
04:56:11 <pejo> (Or is IO::AIO something else?)
04:56:17 <audreyt> it's IO::AIO
04:56:22 <audreyt> and used by Coro.pm
04:56:34 <audreyt> which is a userland scheduler that provides event and thread "views" of the VM state
04:56:51 <audreyt> ...which if I'm not mistaken is what lipeng's unify for GHC is about
04:56:56 <apfelmus> ?paste
04:56:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:57:26 <dons> dont' tell me ... apfelmus have you done it?
04:57:55 <apfelmus> dons: of course i did :) though i don't know whether it's what you want
04:58:15 <dons> hehe
04:58:20 * dons can't wait to see!
04:58:22 <hpaste>  apfelmus pasted "printf with GADTs" at http://hpaste.org/394
04:58:53 <dons> yep, that looks reasonable
04:59:08 <dons> just need some sugar for the fmt string constructors
04:59:29 <quicksil1er> possibly infix
04:59:34 <dons> what type error do you get from an invalid format string?
05:00:06 <dons> ah yes, looks like a job for the dlist library too, apfelmus
05:00:07 <apfelmus> i think there are no invalid format strings
05:00:13 <dons> very good!
05:00:39 <audreyt> I read the intentional programming paper at OOPSLA the other day, and I can't help but think that this futuristic shiny vision they have, is but the kind of TH/GADT usercdoe that we see oleg post every week or so
05:00:48 <dons> apfelmus: ah, I see.
05:00:49 <dons> all Strings
05:01:11 <dons> apfelmus: how about cases for Int/ Float/Char, that call show automatically?
05:01:21 <audreyt> (however, the Shiny Visual IDE bit is indeed missing:))
05:01:33 <apfelmus> well, you can do VarCons show.
05:01:47 <apfelmus> this way, you can even decide later whether you want to show Chars or Ints :)
05:01:52 <SamB> > printf "%"
05:01:52 <dons> ah right
05:01:53 <lambdabot>  Add a type signature
05:01:59 <SamB> > printf "%" :: String
05:02:00 <quicksil1er> apfelmus: but sometimes you *want* to constrain the type, I think
05:02:01 <lambdabot>  Exception: Printf.printf: argument list ended prematurely
05:02:02 <dons> yeahh, i've though our printf should have a Showable tag
05:02:07 <SamB> > printf "%" 1 :: String
05:02:08 <lambdabot>  Add a type signature
05:02:12 <dons> "%S" or something, tat accepts anything showable
05:02:18 <SamB> > printf "%" (1::Int) :: String
05:02:20 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
05:02:41 <SamB> > printf "% %d" (1::Int) :: String
05:02:43 <lambdabot>  Exception: Printf.printf: bad formatting char
05:02:48 <dons> so its a bit of a pretty printer builder, definitely on the right track
05:02:50 <SamB> oh good
05:02:54 <quicksil1er> Is there an extension proposal to handle static inference of subtypes for ADTs?
05:03:04 <dons> SamB: you were expecting a segfault?
05:03:10 <apfelmus> quicksil1er: yes. but you can do by hand: intcons = VarCons (show :: Int -> String)
05:03:13 <quicksil1er> that is, keeping track of which constructors a function can actually return?
05:03:24 <SamB> dons: I was afraid I might get "% 1"
05:03:32 <quicksil1er> apfelmus: *nod* just saying that sugar might be useful
05:03:42 <apfelmus> of course, sugar is essential
05:03:59 <dons> i could handle a light AST-style syntax though
05:04:09 <dons> it'd need to be one or two char tags
05:04:29 <quicksil1er> some infix combinators with carefully chosen precedences
05:04:34 <quicksil1er> can work sugary wonders
05:04:44 <dons> printf (%c 'x' .: %d 7 .: End
05:05:22 <SamB> is that a micky mouse combinator?
05:05:49 <audreyt> dons: why not just use infixl % :)
05:06:16 <quicksil1er> Stuff like, data foo = Foo Int | Bar String;  f x = Foo x
05:06:22 <quicksil1er> f has type Int --> foo
05:06:26 <paolino> @type Data.Array.ST.newListArray
05:06:28 <lambdabot> forall e i (a :: * -> * -> *) (m :: * -> *). (Ix i, Data.Array.Base.MArray a e m) => (i, i) -> [e] -> m (a i e)
05:06:33 <quicksil1er> but *really* f will only ever return one constructor
05:06:53 <nmessenger> @pl f x = Foo x
05:06:53 <lambdabot> f = Foo
05:07:10 <quicksil1er> nmessenger: yes but not quite the point I was trying to make :P
05:07:29 <audreyt> printf %s %s %d $ "foo" "bar" 123
05:07:48 <audreyt> (assuming printf, s, and d are all terms that implements infix (%))
05:08:00 <quicksil1er> but do you want to stamp on 's' in the global namespace?
05:08:04 <audreyt> %_s then
05:08:06 <quicksil1er> could be a bit harsh
05:08:07 * quicksil1er nods
05:08:43 <audreyt> %S %D -- works too, and less likely to clash
05:08:51 <audreyt> data PrintfTerms = S | D | ...
05:09:15 <audreyt> actually, make them GADT
05:09:36 <audreyt> the type of % can be dependently-defined, and produce a prettyprinter
05:10:01 <audreyt> and since it's infixl, the "printf" is a nice initial term
05:10:21 <syntaxfree> @pl f >@> g = (>>= g) . f
05:10:22 <lambdabot> (line 1, column 9):
05:10:23 <lambdabot> unexpected "="
05:10:23 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
05:10:35 <syntaxfree> @pl (\f g -> (>>=g) . f)
05:10:36 <lambdabot> flip ((.) . (=<<))
05:10:51 <syntaxfree> hmm. That shows up on some professor's code.
05:10:58 <paolino> what is the a of a mutable array ?
05:11:07 <syntaxfree> He also rewrote liftM2, so I thought that would be a silly rewrite as well.
05:11:10 <syntaxfree> anyway, back to hacking.
05:11:19 <quicksil1er> I've never much like the 'mammary combinators' though
05:12:15 <nmessenger> @tell syntaxfree you know, there's always http://lambdabot.codersbase.com/ if you need a quick LB fix :)
05:12:15 <lambdabot> Consider it noted.
05:13:00 <quicksil1er> or GOA!
05:13:09 <nmessenger> quicksil1er: @tell him!
05:13:15 <quicksil1er> :)
05:14:10 <resiak> audreyt: This is offtopic, but  a while ago I think I saw one of your presentations done in xul.  What did you use to make that?
05:14:40 <paolino> newArray allocates  a "mutable cell" on the heap ?
05:15:03 <dons> it allocates an array
05:15:04 <paolino> so ST is a list of states ?
05:15:30 <quicksil1er> no, ST is a 'thread' which encapsulates a single mutable state
05:15:42 <quicksil1er> (although that state can be arbitrarily complex)
05:16:05 <quicksil1er> thread in an abstract sense, not the ordinary computing sense
05:16:11 <paolino> I mean I can make it bigger
05:16:30 <quicksil1er> make what bigger?
05:16:37 <paolino> the state
05:17:15 <paolino> make it hold new things during the computation
05:17:21 <quicksil1er> yes
05:17:24 <nmessenger> the state itself can be a list, but it can't change type
05:17:30 <quicksil1er> you can put any amount of stuff in the state
05:17:35 <quicksil1er> nmessenger: that's not true
05:17:51 <quicksil1er> nmessenger: you can stuff as many variables as you like in the ST state
05:18:01 <quicksil1er> nmessenger: using newArray and newSTRef and friends
05:18:05 <paolino> mmh, but then I have runSTArray which freeze only one ?
05:18:23 <nmessenger> quicksil1er: I'm thinking of StateT?
05:18:27 <quicksil1er> nmessenger: yes, you are :)
05:18:46 <quicksil1er> paolino: this is 'probably' not what you want to do
05:18:50 <nmessenger> what does ST stand for?
05:18:59 <quicksil1er> paolino: true mutable state using ST is rather seldom needed
05:19:08 <quicksil1er> and in some sense it's "not idiomatic'
05:19:21 <quicksil1er> it's really just an optimisation for when you really need it
05:19:24 * nmessenger checks the docs
05:20:24 <quicksil1er> paolino: runSTArray 'pulls the mutable array out' and gives you an ordinary immutable copy for ordinary use
05:20:32 <paolino> I can't escape a STRef together with a STArray
05:20:54 <quicksil1er> paolino: you need to explain a little more about what you're trying to do
05:21:59 <SamB> paolino: yeah
05:22:01 <SamB> that is a feature
05:22:08 <paolino> say I create a STref an an STArray in  the computation
05:22:19 <SamB> unfortunately you also can't write generic STUArray code :-(
05:22:43 <paolino> how I pull both out ?
05:23:11 <paolino> SamB, a feature ?
05:23:28 <quicksil1er> you can write ST code which returns a pair, of the value inside the ref and the array
05:23:31 <SamB> paolino: why would you put an STRef in an STArray?
05:23:44 <quicksil1er> you can pull anything you want out of the ST monad
05:23:54 <quicksil1er> your ST calculation can return any arbitrarily complex haskell type
05:23:58 <paolino> SamB not inside, aside
05:24:04 <SamB> paolino: oh
05:24:20 <SamB> well, you just have to use runST and do your own unsafeFreezing
05:24:35 <quicksil1er> SamB: you don't have to use unsafe, though
05:24:38 <quicksil1er> you could just use freeze
05:24:53 <SamB> quicksil1er: but who wouldn't use it when it is, in fact, safe?
05:25:11 <paolino> quicksil1er: example ?
05:25:20 <paolino> :t freeze
05:25:21 <lambdabot> Not in scope: `freeze'
05:25:26 <SamB> @hoogle freeze
05:25:27 <lambdabot> Data.Array.MArray.freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
05:25:27 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
05:26:10 <quicksil1er> paolino: just a minute, I'm struggling to remember exact STRef syntax.
05:26:12 <paolino> same signature ?
05:26:19 <quicksil1er> paolino: are you *sure* this is what you want to do?
05:26:35 <paolino> s/do/learn
05:27:05 <quicksil1er> most uses of ST are like using a rotary-petrol-powered nail gun when a hammer would do
05:27:16 <SamB> paolino: freeze makes a copy *always*
05:27:32 <SamB> unsafeFreeze can sometimes use the same actual array
05:27:40 <paolino> quicksil1er: DiffArrays are way too slow when they are big
05:28:20 <SamB> (GHC has RULES for unsafeFreeze that allow this)
05:28:47 <paolino> and as I cannot have a STT I also need to pull out log informations  from the computation of the array
05:29:13 <xpika> night all!
05:29:47 <SamB> but, say, unsafeFreeze :: IOUArray i a -> IO (Array i a) can't exactly avoid the copy ;-)
05:30:12 <SamB> paolino: what do you mean, when they are big?
05:30:46 <SamB> unsafeFreeze is a lot safer than unsafeThaw, that is for sure ;-)
05:30:51 <paolino> SamB shuffling a 10000 list via DiffArray taked 40 seconds here
05:31:19 <SamB> paolino: hmm.
05:31:52 <SamB> well, how do you know that has anything to do with the array being big, as opposed to with access to it being expensive in general?
05:32:24 <Saizan> do you apply the diffs all at once at the end or as you make them?
05:32:32 <paolino> 40 seconds to access 20000 times an array ?
05:32:46 <mwc> l http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all Haskell turns in amazing performance and uses 1/4 the memory of the next fastest competitor. Has anybody analyzed this yet to find out what went right?
05:33:12 <paolino> Saizan there is no function to make it all together
05:33:14 <SamB> paolino: well. or maybe you read from old versions of it?
05:33:23 <paolino> shouldn't
05:33:34 <mwc> Is it nothing more than the unboxing and use of unsafe read/write?
05:33:38 <paolino> Or my code is wrong
05:33:38 <SamB> paolino: yeah there is
05:33:41 <SamB> / [] does that
05:33:43 <SamB> er.
05:33:50 <SamB> "// []" does that
05:33:52 <Saizan> paolino: why not? let diffs = ... in a // diffs
05:34:09 <SamB> @docs Data.Array.Diff
05:34:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Diff.html
05:34:29 <paolino> Saizan swapping elements can't work with that in my opinion
05:34:45 <paolino> multiple swapping
05:35:01 <paolino> uhm
05:35:22 <SamB> paolino: you don't keep old arrays around?
05:35:27 <Saizan> well anyhow what's important is to not access an old version of the array
05:35:59 <SamB> there almost ought to be an environment variable you could use to have it tell you if that happened...
05:36:10 <paolino> swap a i j = a // [(j,a!i),(i,a!j)]
05:36:12 <paolino> swapper xs (l,n) = liftM (take n . elems) $ foldM (randSwap l) (dA l xs) [1 .. n]
05:36:12 <paolino>   where randSwap a u l = liftM (swap a u) (getRandomR (u,l))
05:36:15 <paolino> this is all
05:36:16 <SamB> (maybe another version of DiffArray?)
05:36:31 <SamB> try...
05:37:21 <paolino> dA d = listArray (1,d) :: [a] -> DA a
05:37:24 <paolino> type DA s = DiffArray Int s
05:37:24 <paolino> getRandomR range = do
05:37:24 <paolino>   (x,g) <- gets (randomR range)
05:37:24 <paolino>   put g
05:37:24 <paolino>   return x
05:37:26 <paolino> with this
05:37:35 <SamB> swap a i j = let x = a!i; y = a!j in x `seq` y `seq` a // [(j,x), (i,y)]
05:38:05 <SamB> what monad are you working in?
05:38:19 <SamB> also... doesn't hpaste work?
05:38:36 <paolino> @hpaste
05:38:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:39:05 <fatalis> how would you counter it, if I said that haskell is mostly for code narcissists?
05:39:23 <kaol> what's wrong with being a code narcissist?
05:39:25 <Jaak> hmm. my *ber* terrible algo generates all 5x5 latin squares in about 30 secs
05:39:55 <hpaste>  paolino pasted "shuffle with DiffArray" at http://hpaste.org/395
05:40:00 <fatalis> the syntax looks like ascii dunghill, as opposed to languages that have mostly english keywords for syntax
05:40:22 <paolino> the ST part is still not tried
05:40:40 <Botje> fatalis: you're stating opinion as fact.
05:40:50 <SamB> what does code narcissist even mean?
05:40:52 <quicksil1er> YHBT. HAND.
05:40:56 <kaol> I see that you've never seen any perl code
05:41:31 <paolino> fatalis: haskell has almost no keywords
05:41:41 <SamB> fatalis: well, Unicode was not practical for source code
05:41:55 <SamB> so of course it uses ASCII
05:42:00 <quicksil1er> > runST (do { a <- newArray (1,10) 5 ; 12 })
05:42:01 <lambdabot>   Not in scope: `newArray'
05:42:09 <hpaste>  audreyt pasted "main = putStrLn$ ("A number "%d%", then a string: "%s) 1 "foo"" at http://hpaste.org/396
05:42:14 <quicksil1er> > runST (do { a <- newSTArray (1,10) 5 ; 12 })
05:42:15 <lambdabot>   Not in scope: `newSTArray'
05:42:25 <quicksil1er> @hoogle STArray
05:42:25 <lambdabot> Data.Array.ST.STArray :: data STArray s i e
05:42:26 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
05:42:26 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
05:42:33 <audreyt> (the above paste is ByteString-ready, even.)
05:42:51 <quicksil1er> audreyt: sexy
05:43:12 <paolino> SamB , your stricter correction is above my knowledge, can you comment it please ?
05:43:18 <audreyt> thanks :)
05:43:33 <roconnor> Is the haskell wiki written in haskell?
05:43:44 <quicksil1er> can someone show me the syntax for making a new STArray? I'm thrashing around in a sea of type errors feeling stupid.
05:43:45 <audreyt> instance Appendable ByteString ByteString ByteString where (%) = ByteString.append
05:46:25 <quicksil1er> No instance for (MArray a e (ST s))
05:46:28 <quicksil1er> is what I keep getting
05:46:54 <quicksil1er> > runST (do { a <- newSTRef 12; a} )
05:46:55 <lambdabot>   Not in scope: `newSTRef'
05:47:36 <audreyt> > runST (newSTArray (1, 4) 0)
05:47:37 <lambdabot>   Not in scope: `newSTArray'
05:47:52 <paolino> > Data.Array.ST.newListArray (1,10) [1..]
05:47:54 <lambdabot>   Not in scope: `Data.Array.ST.newListArray'
05:48:06 <mwc> I wonder if the Haskell' folks would consider any new syntax
05:48:29 <paolino> @hoogle newListArray
05:48:29 <quicksil1er> Ah, OK, it can't infer
05:48:29 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
05:48:30 <mwc> IT'd be kind of nice to translate [|4,4,6,1,3|
05:48:38 <quicksil1er> I got it working with an explicit annotation
05:48:52 <mwc> IT'd be kind of nice to translate [|4,4,6,1,3|] into a call to newArray wihtout me having to count how many indices I need :)
05:49:37 <quicksil1er> mwc: fromList isn't too taxing though...
05:49:50 <paolino> @hoogle newListSTArray
05:49:51 <lambdabot> No matches found
05:49:58 <fasta> Can I express that two different sets of contexts both lead to a class Foo?
05:51:23 <mwc> quicksil1er, I just don't like leaving it until runtime to find the length of the array if I don't need to.
05:52:02 <quicksil1er> mwc: you might believe that the compiler can execute fromList at compile time
05:52:07 <quicksil1er> mwc: in principle it could
05:52:20 <quicksil1er> paolino: I have the asnwer to your question, sorry about the delay
05:52:21 <mwc> I know it could, but I doubt it does
05:52:23 <nmessenger> fatalis: If you dislike the standard operator names, you can always alias them: http://paste.lisp.org/display/33494
05:52:51 <mwc> I should probably just shut up and drink the coolaid :)
05:52:51 <quicksil1er> paolino: I was having a tough time remembering the syntax
05:52:55 <quicksil1er> paolino:  runST (do { a <- newSTRef 1; b <- newArray (1,10) 5 :: ST s (STArray s Int Int) ; b_froz <- freeze b; a_val <- readSTRef a; return (b_froz,a_val)})
05:53:03 <hpaste>  fasta pasted "classes" at http://hpaste.org/397
05:53:08 <quicksil1er> mwc: I think the 'party line' is that one day compiler will be good enough to do that
05:53:31 <quicksil1er> mwc: compiler will evaluate 'compile-time constant' expressions at compile time
05:53:51 <quicksil1er> paolino: you can 'return' as many values as you like out of your ST
05:54:26 <paolino> ok, I must freeze them before
05:54:40 <paolino> @src runSTArray
05:54:41 <lambdabot> Source not found. You speak an infinite deal of nothing
05:55:01 <quicksil1er> paolino: right
05:55:19 <quicksil1er> paolino: but in a sense "freeze"ing an array is perfectly analogous to 'readSTRef'ing a reference
05:55:29 <quicksil1er> paolino: you can just think of it at 'choosing the value at this point in time'
05:56:25 <quicksil1er> paolino: you could, in fact, use unsafeFreeze but I seriously doubt array copies add to your runtime
05:57:10 <paolino> runSTArray a = runST (a >> freeze)  ??
05:57:26 <quicksil1er> rather more like unsafeFreeze
05:57:28 <paolino> >>= probably
05:57:29 <quicksil1er> but yes, basically
05:58:18 <quicksil1er> runSTArray has the cute attribute of separating out small chanks of immutable using code
05:58:21 <quicksil1er> from a mostly 'pure' program
05:58:35 <quicksil1er> runST is for when you have complex interleaving of that state
05:58:40 <quicksil1er> (but preferably, use neither!)
06:00:21 <paolino> SamB, your correction makes it really faster
06:00:33 <paolino> can you comment it ?
06:03:07 <paolino> wouldn't this be the same
06:03:08 <paolino> swap !a i j = a // [(j,a!i),(i,a!j)] ?
06:04:21 <paolino> it doesn't compile :/
06:05:10 <chessguy> 'morning haskellers
06:05:43 <Nafai> Morning chessguy
06:10:04 <quicksil1er> @type \a i j -> a // [(j,a!i),(i,a!j)]
06:10:06 <lambdabot> forall i e. (Ix i) => Array i e -> i -> i -> Array i e
06:10:16 <quicksil1er> paolino: compiles for me :P
06:10:52 <paolino> with !a on the left hand size ?
06:11:11 <fasta> paolino: left hand side?
06:11:38 <paolino> ehm
06:12:24 <bakert> how do you deal with optional arguments in haskell?  just pass in ()?
06:12:34 <nmessenger> @type Just 5
06:12:36 <lambdabot> forall a. (Num a) => Maybe a
06:12:44 <nmessenger> @type Nothing
06:12:46 <lambdabot> forall a. Maybe a
06:12:54 <quicksil1er> bakert: typically, choose a datatype which suits the args list
06:13:07 <quicksil1er> bakert: sometimes two versions of the function (one calling the other)
06:13:10 <nmessenger> bakert: for an optional int, pass a Maybe Int :)
06:13:27 <quicksil1er> yup, Maybe is a good solution for certain simple cases
06:13:41 <quicksil1er> bakert: for really complex args lists, there was a good discussion recently on haskell-cafe
06:14:25 <malebria> How does c2hs' get know the size of a variable in a struct?
06:14:25 <nmessenger> @let f (Just x) = "You passed a " ++ show x; f Nothing = "Didn't pass nothing"
06:14:27 <lambdabot> Defined.
06:14:31 <nmessenger> > f 5
06:14:32 <lambdabot>   add an instance declaration for (Num (Maybe a))
06:14:36 <nmessenger> blah
06:15:02 <Lemmih> malebria: It asks gcc.
06:15:05 <quicksil1er> > f Just 5
06:15:06 <lambdabot>      The function `f' is applied to two arguments,
06:15:06 <lambdabot>     but its type `Maybe a ...
06:15:07 <nmessenger> > f (Just 5)
06:15:09 <lambdabot>  "You passed a 5"
06:15:12 <quicksil1er> > f Nothiing
06:15:13 <lambdabot>   Not in scope: data constructor `Nothiing'
06:15:16 <quicksil1er> heh
06:15:21 <nmessenger> heh indeed
06:15:21 <malebria> I'm trying sizeOf (undefined :: CInt), and getting 4, but in a struct {int x; int y} in y it puts peekByteOff ptr 8
06:15:22 <quicksil1er> > f Nothing
06:15:23 <lambdabot>  Add a type signature
06:15:32 <malebria> Lemmih: Why is it different from sizeOf CInt?
06:15:34 <quicksil1er> malebria: 64 bit machine?
06:15:34 <nmessenger> > f (Nothing :: Maybe Int)
06:15:36 <lambdabot>  "Didn't pass nothing"
06:15:44 <quicksil1er> malebria: aligning to 64 bit words, perhaps
06:16:02 <malebria> quicksil1er: yes, 64.
06:16:06 <bakert> quicksil1er, nmessenger, thanks.  it's an http client, possibly passing in a list of additional headers like referer, useragent, etc..  was just trying to avoid putting [] on the end a lot.  and wondering in general about optional arguments
06:16:09 <chessguy> hmm, you didn't pass nothing, but you did pass Nothing
06:16:24 <Lemmih> malebria: Why is what different from sizeOf CInt?
06:16:32 <quicksil1er> malebria: I expect gcc on 64bit archs aligns structs to 64 bit boundaries
06:16:32 <nmessenger> @undef f
06:16:34 <lambdabot> Undefined.
06:16:38 <malebria> Lemmih: sizeOf CInt is 4 and get is using 8
06:16:44 <quicksil1er> malebria: this lets it generate much faster code
06:16:50 <quicksil1er> malebria: at the cost of a little space
06:16:51 <malebria> hum...
06:17:17 <malebria> quicksil1er: but how does c2hs gets this difference?
06:17:22 <quicksil1er> by asking gcc
06:18:07 <malebria> but shouldn't sizeOf CInt return the same value?
06:18:21 <pejo> malebria, the size of something is not the same as the alignment.
06:18:22 <Lemmih> malebria: CInt is an Int32 for some reason.
06:18:45 <pejo> (Look at sparc in 32 bit mode - large alignment, small ints).
06:19:03 <quicksil1er> malebria: it's just wasting 4 bytes
06:19:03 <bakert> What's the normal way to split a string literal over multiple lines in haskell?  i have a sneaking suspicion that breaking it apart and using ++ and brackets is the wrong thing to do.
06:19:22 <quicksil1er> malebria: to get faster access
06:19:38 <quicksil1er> bakert: That's all I do... dunno if there's a better way
06:19:49 <nmessenger> bakert: I've seen \ and line end, then \ to start the next line
06:19:50 <malebria> But alignment (undefined :: CInt) is also 4
06:19:55 <nmessenger> s/and/at/
06:20:17 <Lemmih> > "Hello\             \ world"
06:20:19 <lambdabot>  "Hello world"
06:20:24 <malebria> Where does this 8 come from? alignment (undefined :: Int) ?
06:20:28 <abz> ?poll-list
06:20:29 <lambdabot> ["Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
06:21:06 <chessguy> ?poll-show Written_a_compiler_or_interpreter?
06:21:06 <lambdabot> ["No","Yes"]
06:21:09 <abz> ?poll-result Written_a_compiler_or_interpreter?
06:21:10 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=4, Yes=14
06:21:20 <chessguy> wha?
06:21:23 <bakert> hmm i'm not sure which of the multiline string methods i like best.
06:21:30 <chessguy> i could've sworn it was more than that last night
06:21:40 <chessguy> that's weird
06:21:41 <pejo> chessguy, LB was restarted
06:21:49 <abz> same... it was up to 18 before I left
06:22:01 <chessguy> ahhh, it must not have recorded everything
06:22:04 <chessguy> ?seen lambdabot
06:22:04 <lambdabot> Yes, I'm here. I'm in #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #
06:22:05 <lambdabot> haskell
06:22:20 <chessguy> ?uptime
06:22:20 <lambdabot> uptime: 2h 41m 30s, longest uptime: 2d 3h 42m 19s
06:22:37 <chessguy> longest uptime is only 2 days?
06:22:47 * nmessenger remembers longer than that
06:23:17 <Lemmih> Two lambdabot days is probably like 8 human days.
06:23:24 <abz> lol
06:23:38 <quicksil1er> Lemmih: how did that \ thing work, syntactically?
06:23:45 <quicksil1er> I knew that one \ "escapes the new line"
06:23:47 <nmessenger> *that's* gettin' @remembered!
06:23:52 <quicksil1er> but what escaped all the other spaces?
06:23:53 <nmessenger> @remember Lemmih Two lambdabot days is probably like 8 human days.
06:23:54 <lambdabot> Done.
06:25:21 <malebria> But how do I ask gcc then? In C, sizeof(int) is also returning 4.
06:26:41 <paolino> @hoogle ST
06:26:42 <lambdabot> Control.Monad.ST :: module
06:26:43 <lambdabot> Data.Array.ST :: module
06:26:43 <lambdabot> Control.Monad.ST.ST :: data ST s a
06:28:41 <Lemmih> quicksil1er: It cuts out the spaces, newlines and tabs between the two backslashes.
06:29:40 <quicksil1er> Lemmih: in a string constant only? or anywhere?
06:29:51 <quicksil1er> malebria: not very straightforwardly
06:29:58 <chessguy> ?instances Show
06:30:13 <lambdabot> Couldn't find class `Show'. Try @instances-importing
06:30:17 <quicksil1er> malebria: struct { int a; int b } c; printf("%d\n",&c.a - &c.b)
06:30:27 <Lemmih> quicksil1er: In string constants only, I think.
06:30:28 <quicksil1er> something along those lines
06:30:35 <quicksil1er> Lemmih: thanks
06:30:49 <paolino> eh with STArray  is 5 times faster than stricter DiffArray :)
06:31:26 <nmessenger> > ma\    \p (+1) [1..10]
06:31:27 <lambdabot>  Parse error
06:31:35 <fasta> Do the associated types already work in GHC HEAD?
06:31:52 <nmessenger> \ is already lambda
06:32:05 <malebria> quicksil1er: hum..
06:33:23 <quicksil1er> Lemmih: interesting, that is an obscure little feature :) Just foudn it in the lexer part of the report.
06:33:38 <quicksil1er> Out of interesting does ghc compile-time-evaluate constant string concats?
06:34:16 <malebria> quicksil1er: this is show -1
06:36:09 <malebria> quicksil1er: this shows -1
06:36:58 <quicksil1er> malebria: bah, cast them both to (void*)
06:37:16 <quicksil1er> ((void*)&c.a) - ((void*)&c.b)
06:37:40 <malebria> 4
06:37:55 <malebria> The same as sizeof int, but different from what c2hs is generating.
06:38:40 <quicksil1er> malebria: in that case, I'm as confused as you :)
06:39:16 <fasta> quicksil1er: GHC doesn't even constant fold 2^16
06:39:34 <malebria> quicksil1er: =D
06:39:38 <fasta> quicksil1er: SamB tried that last time.
06:39:53 <malebria> I tried to find in C2hs code where this is defined, but I'm still searching.
06:51:48 <mauke> *Main> runParser (sepBy1S anyToken getStream) "lambda"
06:51:48 <mauke> Right [(["lambda","ambda","mbda","bda","da","a",""],"")]
07:03:27 <Nshag> probablement le plus petit serveur web volant au monde, sous linux: http://gridswarms.essex.ac.uk/technologies.html :-)
07:03:54 <mauke> wie bitte?
07:04:25 <Nshag> oups sorry, wrong chan :)
07:07:58 <nmessenger> @babel fr en volant
07:07:58 <audreyt> hm. why is there no
07:07:59 <audreyt> updateP :: [: a :] -> Int -> a -> [: a :]
07:07:59 <lambdabot>   flying
07:08:01 <audreyt> ?
07:09:16 <vincenz> audreyt: [: a :] ??
07:09:22 <audreyt> vincenz: GHC.PArr
07:09:55 <vincenz> What sort of syntax is that...
07:16:39 <hpaste>  paolino pasted "rubSTUArray escapes s" at http://hpaste.org/398
07:17:33 <paolino> I can't make it compile
07:18:17 <quicksil1er> paolino: you just want 'a' not 'return a'
07:18:25 <quicksil1er> I think
07:18:38 <paolino> mhh
07:19:12 <paolino> a is unmonaded
07:19:14 <quicksil1er> and I think you want mapM_ not mapM, since you're ignoring the result
07:19:30 <paolino> the error is subtle
07:19:37 <paolino> (to me)
07:19:56 <paolino>     Inferred type is less polymorphic than expected
07:19:57 <paolino>       Quantified type variable `s' escapes
07:19:57 <paolino>       Expected type: ST s (STUArray s i1 e1) -> Array i e
07:19:57 <paolino>       Inferred type: (forall s1. ST s1 (STUArray s1 i1 e1))
07:19:57 <paolino>                      -> Data.Array.Base.UArray i1 e1
07:19:57 <paolino>     In the second argument of `(.)', namely `runSTUArray'
07:21:12 <dino-> I'm working on something where I just started importing Text.Regex  I'm now getting linker errors like: (.text+0x761): undefined reference to `regexzmcompatzm0zi71_TextziRegex_mkRegex_closure'
07:21:26 <dino-> Does anyone know what I need to do about that? I'm guessing some -package perhaps.
07:21:28 <paolino> using --make ?
07:21:32 <mauke> dino-: does it work with ghc --make?
07:21:34 <dino-> paolino: Using hmake
07:21:56 <dino-> I can try that..
07:22:02 <vincenz> audreyt: is it builtin syntax?
07:22:09 <audreyt> vincenz: yes with ghc -fparr
07:22:50 <quicksil1er> paolino: ah I mislead you
07:23:00 <vincenz> audreyt: ah, thanks
07:23:03 <dino-> Huh, that worked fine. :/
07:23:22 <paolino> dino-: never used hmake sorry
07:23:40 <glguy> paolino: You can't use $ after runSTUArray
07:24:08 <paolino> 0_O
07:24:39 <hpaste>  glguy annotated "rubSTUArray escapes s" with "fixed" at http://hpaste.org/398#a1
07:24:46 <dino-> paolino, mauke: Thank you.
07:24:56 <quicksil1er> paolino: bah I got there just after glguy
07:25:06 <dino-> I'll try to figure out what hmake is doing wrong. Perhaps it's args I can add.
07:25:11 <quicksil1er> make it runSTUArray ( do ... ) instead
07:25:23 <glguy> I saw the paste and jumped in the channel to be the one to answer ;)
07:25:50 <quicksil1er> :)
07:26:23 <glguy> after I deleted all the "test" pastes
07:26:41 <paolino>     Couldn't match `Array i e' against `Data.Array.Base.UArray i1 e1'
07:26:42 <paolino>       Expected type: Array i e
07:26:42 <paolino>       Inferred type: Data.Array.Base.UArray i1 e1
07:27:00 <glguy> paolino: if you just want the elems
07:27:21 <glguy> you should probably use: runST (do ... ; getElems yourArray)
07:27:41 <glguy> paolino: also, swappedSt should not have ST in it's type sig
07:29:47 <hpaste>  glguy annotated "rubSTUArray escapes s" with "corrected functionality and type-declaration" at http://hpaste.org/398#a2
07:29:58 <glguy> also, you should probably remove the import Data.Array
07:30:14 <glguy> (I guess that doesn't really matter though)
07:30:17 <glguy> (but ST isn't using it)
07:30:41 <glguy> ?hoogle zipWithM
07:30:42 <lambdabot> Monad.zipWithM :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a [d]
07:30:42 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
07:30:42 <lambdabot> Monad.zipWithM_ :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a ()
07:31:39 <glguy> you should use mapM_ instead of mapM when you don't need the result
07:31:41 <paolino> glguy: if I remove the import I have elems undefined
07:31:55 <glguy> paolino: that means you aren't looking at the paste I made for you
07:31:57 <glguy> but hold on
07:32:01 <glguy> I've got an even better one!
07:32:33 <paolino> glguy, I'm learning slowly
07:32:47 <hpaste>  glguy annotated "rubSTUArray escapes s" with "using zipWithM_" at http://hpaste.org/398#a3
07:33:23 <emu> rubSTUArray and ST genie pops out?
07:33:31 <glguy> zomg!
07:33:40 <glguy> paolino: what were your wishes?
07:36:01 <paolino> ok, it compiles now.
07:36:06 <bd_> emu: Yes, but anything you wish for is constrained to remain within the ST monad
07:36:09 <paolino> also cleaner
07:36:22 <bd_> [there's always a catch]
07:39:47 * emu pulls out the unsafeSTtoIO genie
07:40:12 <paolino> the zipWithM_ doesn't compile
07:40:35 <paolino> Shuffle.hs:18:39:
07:40:36 <paolino>     Couldn't match `m c' against `()'
07:40:36 <paolino>       Expected type: (b, b) -> b1 -> m c
07:40:36 <paolino>       Inferred type: (b, b) -> b1 -> ()
07:40:36 <paolino>     In the application `swapSt a'
07:44:13 <quicksil1er> I wonder if haskell-cafe could be filtered so that messages containing the phrase OOHaskell are dumped...
07:46:43 <hpaste>  mroth pasted "forM_ Not in scope: `forM_'" at http://hpaste.org/399
07:47:51 <realspace> Hello all. I have a problem with 'forM_'. ghc doesn't know it. Any suggestions?
07:48:22 <quicksil1er> @hoogle forM_
07:48:22 <lambdabot> No matches found
07:48:39 <quicksil1er> @hoogle forM
07:48:40 <lambdabot> Text.Html.form :: Html -> Html
07:48:40 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
07:48:40 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
07:49:33 <realspace> According to http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3AforM_
07:49:50 <mauke> realspace: upgrade ghc or use flip mapM_
07:50:06 <realspace> What version of ghc do I need?
07:50:12 <mauke> 6.6
07:51:02 <realspace> Ah. Gentpp still have 6.4. ...
07:51:51 <quicksil1er> realspace: mapM (\i -> putStrLn $ show i) [1..5] is one way of doing it
07:52:02 <paolino> year, now it shuffles a 100000 elements list in 3.97 seconds in ghci
07:52:23 <paolino> hooray for ST
07:52:55 <realspace> quicksilver: yes i know. but the do body used in reality is a little bit larger
07:53:08 <quicksil1er> putStrLn.unlines.(map show) $ [1..5]
07:53:14 <quicksil1er> is arguably more idiomatic
07:53:20 <mauke> flip mapM_ [1..5] (putStrLn . show)
07:53:31 <nmessenger> realspace: define forM_ = flip mapM_ in your code
07:53:49 <nmessenger> @src forM_
07:53:50 <lambdabot> forM_ = flip mapM_
07:55:23 <realspace> I will install ghc 6.6. Thanks for your support.
07:56:34 <quicksil1er> it's really not work installing ghc6.6 for one function which can be defined in 10 characters at the top of your file :)
07:56:42 <quicksil1er> there may be other reasons to want it though
08:01:10 <bakert> I don't suppose there's a library that will escape any regex special chars for haskell, is there?
08:01:47 <Igloo> The set of characters that needs escaping varies depending on what regex library you're using
08:01:51 <bakert> True
08:01:54 <mauke> should be trivial once you know your set of special characters
08:02:07 <bakert> yeah that's what i'm trying to avoid having to work out!
08:03:14 <mauke> concatMap (\c -> if isAlphaNum c then [c] else '\\' : [c])  -- works for perl-style regexes :-)
08:03:38 <bakert> mauke, ah yes overkill.  that's a good idea.
08:03:57 <Igloo> overkill won't work with POSIX basic regexps though
08:03:59 <mauke> you can never have too much overkill!
08:04:12 <Igloo> As \ makes parentheses (amongst others) special
08:04:18 <nmessenger> > cycle "OVERKILL! "
08:04:22 <bakert> !!!
08:04:22 <lambdabot>  "OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERK...
08:04:39 <mauke> yeah, you can't really win there
08:04:49 * nmessenger likes cycle'ing things
08:04:52 <Igloo> Like I said, it depends
08:04:56 <mauke> is there a regex library where < or > are special?
08:05:09 <bakert> Text.Regex seems to have ( and ) as special not \( and \).  But it is not PCRE, it's posix, or perhaps i am confused.
08:07:14 <Igloo> That's POSIX extended regular expressions (see http://www.haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html)
08:07:51 <Igloo> Specifcally in the doc for mkRegex
08:10:49 <bakert> So do you reckon I can get away with mauke's concatMap thing?
08:11:31 <bakert> ?hoogle isAlphaNum
08:11:32 <lambdabot> Char.isAlphaNum :: Char -> Bool
08:11:37 <nmessenger> why do you need to escape regex magic chars?
08:11:58 <nmessenger> @src isAlphaNum
08:11:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:12:11 <mauke> @src Data.Char.isAlphaNum
08:12:11 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:12:28 <nmessenger> though if you really want to be clever, you could use (=<<), which is concatMap
08:12:29 <bakert> nmessenger, because i need to create a regex that matches some special stuff and a string i already have.  but the string may have brackets (or, conceivably, almost anything) in it
08:13:03 <mauke> can it contain '\0'?
08:13:19 <nmessenger> so you're plopping ordinary strings into strings bound for mkRegex?
08:13:25 <bakert> nmessenger, sorry that wasn't very clear.  I have a string.  I need to glue it together with some regex stuff and then match against some text.  But the string i already have may have brackets in it.
08:13:45 <bakert> So as I glue it together with the regex stuff i need to escape the brackets.
08:13:51 <nmessenger> gotcha
08:14:10 <bakert> As I was at it I thought I'd create a general regex escaper because there's nothing to say that later strings might not have square brackets in or something similar.
08:14:46 <bakert> but as i'm only really escaping brackets for now I kind of wanted to do it on the cheap so I thought I'd ask here if such a thing already existed.
08:14:54 <bakert> mauke, no, no \0
08:15:13 <bakert> only "normal" chars
08:15:39 <nmessenger> the concatMap oughta do it, but if you really wanna be awesome, you'll use:
08:15:43 <nmessenger> @pl concatMap f xs
08:15:44 <lambdabot> f =<< xs
08:15:54 <bakert> i DO want to be awesome!
08:16:02 <bakert> haskell wants me to be awesome!
08:16:26 <nmessenger> "awesome" in this case meaning "far too clever for your own good" :)
08:16:50 <bakert> @pl map regexEscape [usr, bookieCode, currency]
08:16:50 <lambdabot> map regexEscape [usr, bookieCode, currency]
08:17:02 <bakert> oop
08:17:18 <bakert> ?pl map concatMap (\c -> if isAlphaNum c then [c] else '\\' : [c])
08:17:19 <lambdabot> map (=<<) (ap (liftM2 if' isAlphaNum return) (('\\' :) . return))
08:17:23 <bakert> waaah!
08:17:27 <nmessenger> geh.
08:17:27 <bakert> too scary!
08:17:43 <bakert> ?pl map $ concatMap (\c -> if isAlphaNum c then [c] else '\\' : [c])
08:17:44 <lambdabot> map (ap (liftM2 if' isAlphaNum return) (('\\' :) . return) =<<)
08:18:17 <bakert> i never know if pl is going to give me dreams or nightmares!
08:18:46 <nmessenger> @pl \o r l y -> y a r l y
08:18:46 <lambdabot> const (flip flip id . (ap .) . flip . flip ($ a))
08:19:09 <jeroeng> Can someone give me some pointers on how to use the typeclasses to define a divide-function?
08:19:10 <glguy> concatMap (\x -> (if isAlphaNum x then id else ('\\':)) [x]) xs
08:19:23 <glguy> nmessenger: nowai!
08:19:43 <nmessenger> jeroeng: you have a type that you want to divide with?
08:20:26 <Taral> @seen audreyt
08:20:26 <lambdabot> audreyt is in #perl6 and #haskell. I last heard audreyt speak 1m 30s ago.
08:20:59 * fasta thinks jeroeng just wants to divide numbers
08:21:05 <rahikkala> I wonder if it's possible to get a string of tree flips out of @pl
08:21:06 <jeroeng> Sort of, I have two Peano-numbers x and y encoded in the type-system, and I want to findp, q, 0<=q< y such that y*p+q = y
08:21:12 <rahikkala> @type flip flip flip
08:21:14 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
08:21:14 <fasta> Ah, I was wrong.
08:22:04 <fasta> class (Num a) => Fractional a where
08:22:04 <fasta>   (/) :: a -> a -> a
08:22:09 <jeroeng> Today I saw a presentation on defining the faculty in the typesystem. Now I am wondering whether I can do *anything* within the typesystem, and I'm having a hard time defining this divide
08:22:15 <quicksil1er> bakert: thanks to nmessenger I have a better 'pointless \x -> [x]'
08:22:29 <quicksil1er> bakert: @pl always gives you 'return' but I favour (:[])
08:22:36 <nmessenger> @src Integral
08:22:37 <lambdabot> class  (Real a, Enum a) => Integral a  where
08:22:37 <lambdabot>     quot, rem, div, mod :: a -> a -> a
08:22:37 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
08:22:38 <fasta> Hmm, again, never mind.
08:22:38 <lambdabot>     toInteger           :: a -> Integer
08:22:40 <quicksil1er> bakert: (a) it looks like the cookie monster and (b) I can see what it does
08:22:45 <nmessenger> @quote (:[])
08:22:46 <lambdabot> Plugin `quote' failed with: IRCRaised Text.Regex.Posix.regcomp: error in pattern
08:22:48 <jeroeng> fasta: Not like that.
08:22:50 <fasta> I finally read what he said
08:22:54 <nmessenger> @quote \(\:\[\]\)
08:22:54 <lambdabot> dcoutts says: (:[]) looks like a monster
08:22:55 <fasta> jeroeng: Yes, I now understand.
08:23:21 <fasta> jeroeng: You are basically asking how to do generic type level computation, right?
08:23:36 <jeroeng> I suppose so :)
08:23:40 <nmessenger> @quote \(\:\[
08:23:40 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
08:23:47 <jeroeng> They called it meta-level
08:24:07 <fasta> jeroeng: meta-level is heavily overloaded.
08:24:49 <fasta> jeroeng: I suggest you first write out the division algorithm in normal Haskell.
08:25:03 <nmessenger> I've not really tried hacking type-level numbers, so I don't think I can help much
08:25:15 <fasta> jeroeng: (meaning with the primitives you intend to have on the type-level)
08:25:23 <jeroeng> Ah yes
08:25:26 <jeroeng> I shall do so
08:26:11 <nmessenger> @quote \(\:\[
08:26:11 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
08:26:23 <fasta> jeroeng: then you look at some example to see how conditionals and general recursion work at the type level (I am not sure what exactly you need). Then you combine those two ideas and you are done.
08:26:30 * fasta is meta-meta computing 
08:26:32 <fasta> ;)
08:26:43 <jeroeng> Thanks for the advice
08:27:08 <nmessenger> metavalues are types, metatypes are kinds, metakinds haven't been given a name beyond metakinds
08:27:22 <jeroeng> I had an algorithm that I thought did the trick, but it messed-up the dependencies
08:29:44 <robert__> hi all
08:29:52 <robert__> i have a question about using haskell FFI from gcc
08:29:58 <robert__> probably a stupid question :-)
08:30:10 <robert__> is there someone who knows how to compile using FFI?
08:30:22 <glguy> (canned autoresponse) there are no stupid questions only stupid people
08:30:26 <fasta> robert__: probably it's not a stupid question
08:30:37 <robert__> i'm just a gcc noob thats all
08:30:38 <robert__> i get
08:30:44 <robert__> ain_stub.c:(.text+0x8): undefined reference to `rts_lock'
08:30:45 <robert__> Main_stub.c:(.text+0x13): undefined reference to `rts_mkInt'
08:30:45 <robert__> Main_stub.c:(.text+0x1c): undefined reference to `Main_zdfhandleEvent_closure'
08:30:45 <robert__> Main_stub.c:(.text+0x21): undefined reference to `rts_apply'
08:30:45 <robert__> Main_stub.c:(.text+0x2a): undefined reference to `GHCziTopHandler_runIO_closure'
08:30:45 <robert__> Main_stub.c:(.text+0x2f): undefined reference to `rts_apply'
08:30:47 <robert__> and so on
08:30:54 <robert__> oops sorry for flood
08:31:10 <fasta> robert__: have you searched Google?
08:31:15 <robert__> yep
08:31:16 <JaffaCake> ooh, #haskell full of GHC build errors
08:31:16 <lambdabot> JaffaCake: You have 1 new message. '/msg lambdabot @messages' to read it.
08:31:19 * JaffaCake runs away
08:31:20 <nmessenger> @paste next time you can use this -->
08:31:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:32:02 <robert__> i guess that i have to feed GCC with a library it can link against or something?
08:32:06 <JaffaCake> bringert: do you have a darcs repo for your exif binding?
08:32:21 <fasta> robert__: I don't think you need to call GCC.
08:32:27 <fasta> robert__: You should only use GHC.
08:32:46 <robert__> i guess so but i want to do this: run compiled haskell code from within a c program
08:33:04 <robert__> using the foreign function interface
08:33:05 <fasta> robert__: I forgot the specifics and don't have time to help you further. Sorry
08:33:09 <robert__> ok np
08:34:41 <robert__> anyone else who ever called compiled haskell code from C?
08:34:51 <JaffaCake> bringert: never mind, I found it
08:36:22 <paolino> runST (f a) /= runST f $ a ?
08:36:43 <glguy> paolino: bad example
08:36:53 <glguy> paolino: that doesn't work, but not for the same reason
08:37:11 <nmessenger> (.)
08:37:21 <glguy> you meant: runST (f a) /= runST $ f a
08:38:01 <glguy> (and the latter doesn't work)
08:38:21 <paolino> somef $ runST (f a) /= somef . runST f $ a ?
08:38:44 <paolino> why ?
08:38:51 <quicksil1er> it's not that they aren't the same
08:38:51 <glguy> higher kinded types
08:38:56 <quicksil1er> it's "just" that GHC can't infer the types
08:39:29 <quicksil1er> higher kinded types are intractable, and GHC has a simple conservative algorithm which gets it right in certain very simple cases
08:39:39 <quicksil1er> there was a thread about this just recently on cafe IIRC
08:41:19 <paolino> mhmh, so runST must be given a complete type
08:41:25 <Taral> @seen audrety
08:41:25 <lambdabot> I haven't seen audrety.
08:41:26 <xic> what is local supposed to do?
08:41:26 <Taral> @seen audreyt
08:41:27 <lambdabot> audreyt is in #perl6 and #haskell. I last heard audreyt speak 2s ago.
08:41:59 <xic> @src local
08:41:59 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:42:03 <xic> @hoogle local
08:42:03 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m a
08:42:04 <lambdabot> Distribution.Simple.Configure.localBuildInfoFile :: FilePath
08:42:04 <lambdabot> Distribution.Simple.GHCPackageConfig.localPackageConfig :: IO FilePath
08:42:35 <paolino> xic it changes the environment for the argument computation
08:42:36 <quicksil1er> xic: guessing from the type I'd say it "locally mutables" the common reader value
08:43:08 <xic> paolino: it applies the current environment to the (r -> r) function?
08:43:25 <paolino> flip that sentence
08:43:46 <xic> paolino: right... so i'd probably use ask to implement this, in order to get the current environment value?
08:43:59 <nmessenger> @docs Control.Monad.Reader
08:44:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
08:44:13 <xic> those docs really help
08:44:18 <nmessenger> heh
08:44:36 <paolino> it runs (m a) under the modified by (r->r) environment
08:44:42 <nmessenger> iirc, the effect is *only* visible in the argument action
08:44:52 <nmessenger> = what paolino said
08:45:31 <paolino> > runReader (local (+1) ask) 0
08:45:33 <lambdabot>  1
08:47:22 <paolino> s/runs/build the action
08:47:28 <xic> someone really should improve those mtl docs. all they have is the type of each function, without any explanation of what they are supposed to do
08:48:26 <quicksil1er> xic: some are better than others
08:48:35 <quicksil1er> some do have more than just the types
08:48:46 <xic> why is the local function even necessary at all for MonadReader? isn't ask enough?
08:48:50 <quicksil1er> (although normally there's only one possible function of each type, you can guess what it must do)
08:49:09 <quicksil1er> > runReader (ask) 0
08:49:10 <lambdabot>  0
08:49:13 <Saizan> > runReader (local (+1) ask >>= \x -> fmap ((,) x) ask) 0
08:49:14 <lambdabot>  (1,0)
08:49:18 <quicksil1er> ask 'reveals' the current value
08:49:27 <quicksil1er> local 'temporarily changes it'
08:49:53 <xic> the local action can have side effects in addition to returning a value, right?
08:50:11 <quicksil1er> well if you're only in the reader monad
08:50:15 <quicksil1er> there aren't really any side effects
08:50:19 <quicksil1er> the reader monad is very simple!
08:50:27 <xic> ok but what about ReaderT IO a?
08:50:29 <quicksil1er> if it was ReaderT over another monad, then yes
08:50:58 <quicksil1er> the reader monad in most cases is just like a variable binding
08:51:17 <quicksil1er> (and a 'single' binding at that)
08:51:29 <nmessenger> and Monad ((->) r) allows some serious type hackery!
08:51:35 <quicksil1er> certainly true
08:51:42 <quicksil1er> @pl runReader (local (+1) ask >>= \x -> fmap ((,) x) ask) 0
08:51:43 <lambdabot> runReader (flip fmap ask . (,) =<< local (1 +) ask) 0
08:51:48 <quicksil1er> I love, you, @pl
08:52:06 <nmessenger> syntaxfree: remember last time when you came in and used LB real quick?
08:52:15 <xic> i still don't understand why local can't be implemented generically using ask for all MonadReaders
08:52:26 <quicksil1er> are there 'completeness' proofs for @pl?
08:52:36 <quicksil1er> xic: all ask does is reveal the current value, it doesn't allow to change it
08:52:36 <syntaxfree> ah, yes. I got your message : )
08:52:48 <quicksil1er> @src local
08:52:48 <lambdabot> Source not found. That's something I cannot allow to happen.
08:52:59 <quicksil1er> @src (->) local
08:52:59 <lambdabot> local f m = m . f
08:53:00 <Syzygy-> Ooooooh! Bot is back!
08:53:05 <Syzygy-> @botsnack
08:53:05 <lambdabot> :)
08:53:08 <Syzygy-> @botsnack
08:53:09 <lambdabot> :)
08:53:11 <xic> quicksil1er: does the implementation of local need to use ask?
08:53:12 <quicksil1er> @src (->) ask
08:53:13 <Syzygy-> There ya go!
08:53:13 <lambdabot> ask = id
08:53:40 <quicksil1er> xic: conceptually, yes
08:53:50 <quicksil1er> xic: it uses 'ask', then transforms the result, and then passes that on
08:53:53 <nmessenger> but (->) isn't a Monad!  ((->) r) is!  I'm confused.
08:54:08 <quicksil1er> nmessenger: (->) is just short hand to help @src find the right defn
08:54:23 <quicksil1er> @src Reader local
08:54:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:55:10 <quicksil1er> @src Reader r local
08:55:10 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:55:12 <quicksil1er> bah
08:55:37 * nmessenger instructs a pet pirana to munch on lambdabot's shoulder blades
08:55:37 <quicksil1er> why isn't the a 'source here' button on the haddock?\
08:55:52 <MarcWebe1> Which is the way to convert a string constant into a ByteString? using foldr ?
08:56:02 <nmessenger> HydraIRC's /slap is weird o.O
08:58:56 <syntaxfree> hahaha
09:00:06 <glguy> MarcWebe1: pack
09:00:10 * nmessenger breaks out the slapping rod and looks sternly at himself
09:00:18 * nmessenger likes slapping people and randomly picks everyone to slap.
09:00:40 <quicksil1er> xic: to be more precise, the implementation of local doesn't use ask
09:00:47 <quicksil1er> xic: but ask is somehow 'implicitly there'
09:01:05 <quicksil1er> ask is like a 'no-op' in the reader monad, since you 'always' have that paramter available
09:01:10 <quicksil1er> @src local'
09:01:11 <lambdabot> Source not found. Do you think like you type?
09:01:19 <quicksil1er> @src ReaderT local'
09:01:20 <lambdabot> Source not found. It can only be attributed to human error.
09:01:24 <quicksil1er> @src ReaderT local
09:01:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:01:48 <glguy> > ( do { a <- id; b <- id; return (a + b) } ) 5
09:01:49 <lambdabot>  10
09:02:08 <nmessenger> cool
09:02:20 <glguy> ?type local
09:02:22 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
09:02:24 <quicksil1er> right, because ask is 'id' anyway :)
09:03:20 <quicksil1er> > (do{a<-id;b<-local (const 12); return (a,b)}) 5
09:03:21 <lambdabot>   add an instance declaration for (Num (m a))
09:03:34 <glguy> > let local f m = fmap m f in ( do { a <- id; b <- local (*2) id; return (a + b) } ) 5
09:03:36 <lambdabot>  15
09:03:41 <quicksil1er> > (do{a<-id;b<-local (const 12) id; return (a,b)}) 5
09:03:42 <lambdabot>  (5,12)
09:04:06 <glguy> > let local' f m = fmap m f in ( do { a <- id; b <- local (*2) id; return (a + b) } ) 5 -- testing for same result
09:04:07 <lambdabot>  15
09:04:18 <glguy> ?type local f m = fmap m f
09:04:19 <lambdabot> parse error on input `='
09:04:23 <glguy> ?type \ f m = fmap m f
09:04:25 <lambdabot> parse error on input `='
09:04:26 <glguy> ?type \ f m -> fmap m f
09:04:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
09:05:04 <quicksil1er> @pl (do{a<-id;b<-local (const 12) id; return (a,b)}) 5
09:05:04 <lambdabot> (line 1, column 4):
09:05:05 <lambdabot> unexpected "{"
09:05:05 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
09:05:12 <quicksil1er> ooh
09:05:17 <quicksil1er> @pl ( do { a<-id;b<-local (const 12) id; return (a,b)}) 5
09:05:18 <lambdabot> (line 1, column 6):
09:05:18 <lambdabot> unexpected "{"
09:05:18 <lambdabot> expecting variable, "(", operator or ")"
09:05:30 <paolino> @. pl undo
09:05:30 <lambdabot> (line 1, column 21):
09:05:31 <lambdabot> unexpected "{"
09:05:31 <lambdabot> expecting variable, "(", operator or ")"
09:05:35 <quicksil1er> @pl do { a<-id;b<-local (const 12) id; return (a,b)} $5
09:05:35 <lambdabot> (line 1, column 4):
09:05:36 <lambdabot> unexpected "{"
09:05:36 <lambdabot> expecting variable, "(", operator or end of input
09:05:37 <glguy> > let local = liftM in ( do { a <- id; b <- local (*2) (+3); return (a + b) } ) 5 -- testing for same result
09:05:38 <lambdabot>  21
09:05:51 <glguy> > let local' = liftM in ( do { a <- id; b <- local (*2) (+3); return (a + b) } ) 5 -- testing for same result
09:05:52 <lambdabot>  Add a type signature
09:06:10 <quicksil1er> @pl do { a<-id;b<-local (const 12) id; return (a,b)}
09:06:10 <lambdabot> (line 1, column 4):
09:06:11 <lambdabot> unexpected "{"
09:06:11 <lambdabot> expecting variable, "(", operator or end of input
09:06:15 <paolino> @. pl undo { a<-id;b<-local (const 12) id; return (a,b)} $5
09:06:16 <lambdabot> (line 1, column 21):
09:06:17 <lambdabot> unexpected "{"
09:06:17 <lambdabot> expecting variable, "(", operator or ")"
09:06:37 <paolino> @. pl undo do { a<-id;b<-local (const 12) id; return (a,b)} $5
09:06:37 <lambdabot> (local (const 12) id >>=) . flip flip 5 . (return .) . (,) =<< id
09:06:49 <glguy> > let local = liftM in ( do { a <- id; b <- local (const 1) id; return (a + b) } ) 5
09:06:51 <lambdabot>  6
09:06:56 <quicksil1er> paolino: thanks
09:07:09 <quicksil1er> flip flip 5? that's awesome :)
09:07:13 <paolino> :)
09:07:16 <quicksil1er> is that a lambdabot high five?
09:07:27 <glguy> I think that local is just liftM for ((->) r)
09:07:38 <Syzygy-> > flip flip 5
09:07:39 <lambdabot>  Add a type signature
09:07:43 <Syzygy-> > flip flip 5 :: Int
09:07:44 <lambdabot>      Expecting a function type, but found `Int'
09:07:45 <lambdabot>       Expected type: Int
09:07:45 <lambdabot>     ...
09:07:48 <glguy> oops, nope
09:07:51 <Syzygy-> > flip flip (5 :: Int)
09:07:52 <lambdabot>  Add a type signature
09:08:00 <Syzygy-> o.O
09:08:01 <quicksil1er> @type flip flip 5
09:08:02 <lambdabot> forall a c b. (Num b) => (a -> b -> c) -> a -> c
09:08:21 <Syzygy-> So ....
09:08:34 <Syzygy-> > (flip flip 5) + 3
09:08:35 <lambdabot>   add an instance declaration for (Num ((a -> b -> c) -> a -> c))
09:08:41 <Syzygy-> No....
09:08:44 <quicksil1er> (flip flip 5) (+) 3
09:08:48 <quicksil1er> > (flip flip 5) (+) 3
09:08:50 <lambdabot>  8
09:08:52 <Syzygy-> Ah.
09:08:52 <quicksil1er> is what you meant :)
09:08:59 <Syzygy-> Yeah....
09:09:00 <jeroeng> dblhelix: Do you know where I can find the speaker of today's ST-colloquium? I'm trying to do something resembling what he did, but I can't get it to work properly.
09:09:05 <quicksil1er> enough flips and you have forth!
09:09:14 <Syzygy-> forth?
09:09:18 <Syzygy-> How's that?
09:09:19 <quicksil1er> stack based language
09:09:22 <Syzygy-> Ah.
09:09:23 <quicksil1er> 5 3 +
09:09:32 <Syzygy-> @type flip flip flip 5
09:09:34 <lambdabot> forall a c. (Num (a -> ((a -> b -> c) -> b -> a -> c) -> c)) => a -> c
09:09:48 <Syzygy-> O.o
09:10:33 <paolino> @type iterate flip
09:10:35 <lambdabot> forall a c. (a -> a -> c) -> [a -> a -> c]
09:10:36 <quicksil1er> @pl \x y f -> f x y
09:10:37 <lambdabot> flip . flip id
09:10:51 <quicksil1er> > flip . flip id 3 5 (+)
09:10:51 <lambdabot>        add an instance declaration for (Num (b1
09:10:52 <lambdabot>                              ...
09:10:59 <quicksil1er> > (flip . flip id) 3 5 (+)
09:11:00 <lambdabot>  8
09:11:15 <quicksil1er> who wrote @pl? was it dons or?
09:11:18 <Syzygy-> So a double flip and id gives us forth?
09:11:22 <Syzygy-> :)
09:11:41 <matthew_-> is that the same as reverse polish notation?
09:11:44 <quicksil1er> matthew_-: yes
09:12:02 <quicksil1er> matthew_-: stack machine: a literal 'pushes' the args onto the stack, an operator 'pops' as many args as it needs
09:12:15 <matthew_-> yup
09:12:16 <quicksil1er> you can embed it in haskell as a state monad, actually
09:12:37 <paolino> the stack monad
09:12:42 <matthew_-> aka list
09:12:42 <quicksil1er> indeed :)
09:12:47 <sjanssen> quicksil1er: a guy named TheHunter wrote it
09:12:50 <quicksil1er> not list, no
09:12:54 <sjanssen> I don't think he hangs around here anymore
09:12:56 <quicksil1er> sjanssen: I'm sure he's not the only one though
09:13:04 <quicksil1er> sjanssen: it's a farily obvious notion
09:13:18 <quicksil1er> sjanssen: I embedded Joy ( which is a modern forth alike) into haskell when I first saw it
09:13:28 <matthew_-> in what way do haskell lists differ from stacks?
09:13:30 <quicksil1er> (or maybe I embedded it into ocaml and wrote the monad the long way, I don't remember)
09:13:35 <quicksil1er> matthew_-: they don't
09:13:41 <quicksil1er> matthew_-: but the stack monad isn't hte list monad
09:13:42 <syntaxfree> @hoogle Foreign
09:13:43 <lambdabot> Foreign :: module
09:13:44 <lambdabot> Language.Haskell.TH.Foreign :: data Foreign
09:13:44 <lambdabot> Foreign.ForeignPtr :: module
09:13:45 <sjanssen> quicksil1er: I mean TheHunter wrote @pl
09:13:46 <matthew_-> oh sure
09:13:51 <quicksil1er> sjanssen: oh, sorry :)
09:13:53 <quicksil1er> sjanssen: thank you
09:14:12 <quicksil1er> sjanssen: any idea if it's complete?
09:14:25 <sjanssen> quicksil1er: yeah, emulating stack languages is fairly common -- I've done it myself
09:14:45 <sjanssen> quicksil1er: pl is reasonably complete, but it could still use some work
09:14:53 <quicksil1er> I think for @pl to work it needs to know a 'dual' to all constructors
09:14:59 <quicksil1er> in some sense which I can't make precise
09:15:04 <quicksil1er> like the 'dual' to (,) is uncurry
09:15:17 <quicksil1er> @pl \a b -> (a,b)
09:15:17 <lambdabot> (,)
09:15:32 <sjanssen> it uses it's own hacked-up Haskell parser, we'd like it to use haskell-src instead
09:15:39 <sjanssen> quicksil1er: yes, pattern matching is a problem
09:15:48 <quicksil1er> @pl \(a,b) f -> f a b
09:15:49 <lambdabot> uncurry (flip . flip id)
09:15:57 <quicksil1er> that's the example I wanted
09:16:06 <quicksil1er> in some sense uncurry is dual to (,) in a pattern match
09:16:24 <sjanssen> unfortunately many datatypes in Haskell don't have catamorphisms in the standard libs
09:16:30 <quicksil1er> sjanssen: catamorphism, thank you
09:16:34 <quicksil1er> sjanssen: I knew there was a word :)
09:16:47 <quicksil1er> sjanssen: I read a very good paper on cata and ana morphisms many years ago
09:17:12 <sjanssen> @pl could learn the common ones: maybe, either, uncurry, foldr
09:17:13 <lambdabot> (line 1, column 35):
09:17:13 <lambdabot> unexpected ","
09:17:13 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++" or end of input
09:17:23 <sjanssen> heh
09:17:30 <quicksil1er> sjanssen: it uses 'return' for [x]
09:17:52 <quicksil1er> @pl \[x] -> x
09:17:52 <lambdabot> (line 1, column 2):
09:17:52 <lambdabot> unexpected "["
09:17:52 <lambdabot> expecting pattern
09:17:59 <quicksil1er> oh, it odesn't know that pattern
09:18:00 <quicksil1er> :)
09:18:09 <quicksil1er> @pl \x:xs -> x
09:18:09 <lambdabot> head
09:18:10 <sjanssen> right, because it doesn't use a real Haskell parser
09:18:26 <quicksil1er> @pl \x:[] -> x
09:18:26 <lambdabot> (line 1, column 4):
09:18:27 <lambdabot> unexpected "["
09:18:27 <lambdabot> expecting natural, identifier, "_" or "("
09:18:40 <quicksil1er> sjanssen: still, it does very well in most cases
09:18:54 <paolino> @hoogle RWS
09:18:55 <lambdabot> Control.Monad.RWS :: module
09:18:56 <lambdabot> Control.Monad.RWS.RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
09:18:56 <lambdabot> Control.Monad.RWS.RWS :: newtype RWS r w s a
09:18:59 <quicksil1er> sjanssen: I had this really nasty tuple match and it produced a beautifully ugly solution
09:19:17 <sjanssen> quicksil1er: my favorite thing is pl + djinn
09:19:23 <quicksil1er> @pl  (\((((((_,_),ns),_),_),ts),_) -> (Just ns,ts))
09:19:24 <lambdabot> uncurry (uncurry ((const .) . (,) . Just . snd . fst . fst))
09:19:51 <paolino> @hoogle runRWS
09:19:52 <lambdabot> Control.Monad.RWS.runRWS :: RWS r w s a -> (r -> s -> (a, s, w))
09:19:52 <lambdabot> Control.Monad.RWS.runRWST :: RWST r w s m a -> (r -> s -> m (a, s, w))
09:20:28 <sjanssen> @. pl djinn (a, (b, (c, ()))) -> (c, (b, (a, ())))
09:20:31 <lambdabot> f = uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .) . flip (,)) .) . flip (,) . (,))
09:20:31 <paolino> :t execRWS
09:20:33 <lambdabot> Not in scope: `execRWS'
09:20:36 <sjanssen> @pl ()
09:20:37 <lambdabot> ()
09:20:40 <quicksil1er> sjanssen:  :)
09:21:27 <sjanssen> @unpl uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .) . flip (,)) .) . flip (,) . (,))
09:21:28 <lambdabot> uncurry (\ ad -> (\ bl -> (\ r _ -> (,) (fst r) ((,) (fst bl) (((,)) ad))) >>= \ ay -> snd >>= \ ax -> return (ay ax)) >>= \ bw -> snd >>= \ bv -> return (bw bv))
09:21:56 <quicksil1er> @pl \ns aaa -> "[" ++ (maybe "" (("<"++).(++"> : ").(concat_with ",")) ns) ++ concat_with "," (map (pp.Tuple) (Set.toList aaa)) ++ "]"
09:21:57 <lambdabot> (('[' :) .) . (. ((++ "]") . concat_with "," . map (pp . Tuple) . (Set .) . toList)) . (++) . maybe [] (('<' :) . (++ "> : ") . concat_with ",")
09:22:01 <paolino> lambdabot is getting nervous
09:22:16 <sjanssen> paolino: she is?
09:22:16 <quicksil1er> doh, it split a qualified name there
09:22:20 <quicksil1er> Set. is not a composition
09:22:24 <quicksil1er> it's a qualifier :P
09:22:34 <sjanssen> quicksil1er: see, it needs a real parser :)
09:22:37 <quicksil1er> @pl \ns aaa -> "[" ++ (maybe "" (("<"++).(++"> : ").(concat_with ",")) ns) ++ concat_with "," (map (pp.Tuple) (toList aaa)) ++ "]"
09:22:38 <lambdabot> (('[' :) .) . (. ((++ "]") . concat_with "," . map (pp . Tuple) . toList)) . (++) . maybe [] (('<' :) . (++ "> : ") . concat_with ",")
09:22:41 <quicksil1er> sjanssen: *nod*
09:23:07 <quicksil1er> it 'optimises' "a" ++ to 'a' : though...
09:23:15 <Saizan> http://www.haskell.org/haskellwiki/Modern_array_libraries#Unsafe_indexing.2C_freezing.2Fthawing.2C_running_over_array_elements <-- in the example here there's a unsafeAt function, but i can't find it in the docs or in hoogle, was it removed?
09:23:45 <sjanssen> quicksil1er: nice, easy project for a budding lambdabot hacker :)
09:24:09 <quicksil1er> sjanssen: I can't decide if replacing "x" ++ with 'x' : is good or bad, really
09:24:18 <paolino> RWS is OOHaskell ?
09:24:19 <quicksil1er> sjanssen: it could be slightly faster if your compiler is bad, but...
09:24:43 <sjanssen> @pl 'x':'y':z
09:24:44 <lambdabot> 'x' : 'y' : z
09:24:58 <sjanssen> @pl "xy"++z
09:24:59 <lambdabot> "xy" ++ z
09:25:10 <quicksil1er> @pl \x -> "a" ++ x ++ "b"
09:25:11 <lambdabot> ('a' :) . (++ "b")
09:25:13 <quicksil1er> see?
09:25:14 <quicksil1er> :)
09:25:20 <quicksil1er> it's only if it's one char
09:26:10 <sjanssen> Saizan: it's in Data.Array.Base
09:26:31 <sjanssen> Saizan: it's undocumented because it's unsafe and it's use is strongly discouraged
09:27:23 <Syzygy-> @pl \x -> "ab" ++ x ++ "cd"
09:27:24 <lambdabot> ("ab" ++) . (++ "cd")
09:27:27 <Syzygy-> Heh
09:27:35 * quicksil1er nods
09:27:40 <quicksil1er> only for 1 char
09:27:48 <quicksil1er> curious keyhole optimisation :)
09:27:54 <Syzygy-> @pl \x -> "" ++ x ++ "cd"
09:27:54 <lambdabot> ("\195\166" ++) . (++ "cd")
09:27:59 <Syzygy-> Heh
09:28:00 <quicksil1er> @pl \x -> 'a' : 'b' : x
09:28:01 <lambdabot> ("ab" ++)
09:32:37 <bakert_> ?paste
09:32:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:33:09 <hpaste>  bakert pasted "Adding commas to large decimal numbers." at http://hpaste.org/400
09:33:32 <bakert_> With the help of some people on this channell I wrote a little function to add commas like this:
09:33:44 <bakert_> 300000.93 -> "300,000.93"
09:33:59 <bakert_> I just wondered if you think it is a monstrosity or beautiful.  I can't decide.
09:34:09 <bakert_> http://hpaste.org/400
09:37:25 <bakert> I warn you I may post it to reddit as "Top 10 Haskell Design Patterns And George W. Bush"
09:38:12 <bakert> How many columns wide do you make your haskell code?
09:38:16 <paolino> :t runReader
09:38:18 <lambdabot> forall a r. Reader r a -> r -> a
09:38:37 <paolino> :t Control.Monad.RWS.runRWS
09:38:39 <lambdabot> forall w s a r. Control.Monad.RWS.RWS r w s a -> r -> s -> (a, s, w)
09:38:43 <sjanssen> Saizan: I just fixed that page, it references Data.Array.Base now
09:39:34 <Saizan> sjassen: oh, nice, shouldn't Data.Array.Base also be linked from http://www.haskell.org/ghc/docs/latest/html/libraries/index.html ?
09:39:36 <paolino> mmhh looks like runRWS is wrongly typed in the docs !?
09:39:42 <quicksil1er> bakert: 78
09:40:15 <paolino> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html
09:40:17 <quicksil1er> bakert: algorithmically it looks fine to me
09:40:32 <quicksil1er> bakert: stylistically, if you're going to bother to have 'named' sub-functions (fmt',fmt'')
09:40:40 <quicksil1er> bakert: then you might as well give them meaningful names ;)
09:40:43 <Binkley> what I want to know is what George W. Bush has to do with it
09:41:15 <matthew_-> mmm. rename a function as "surge" ?
09:41:22 <quicksil1er> shock and awe?
09:41:29 <quicksil1er> (maybe that's tasteless)
09:41:49 <Syzygy-> surge >> shock >> awe >> return . dead
09:41:56 * Syzygy- couldn't resist...
09:42:15 <Binkley> that would imply that shock and awe don't return values, though
09:42:16 <matthew_-> wow - all >> and no >>= ?
09:42:27 <Syzygy-> Binkley: Not necessarily. Only that we ignore the values.
09:42:42 <matthew_-> mmm. I guess that makes sense ;)
09:42:48 <Syzygy-> matthew_-: Does it seem to you as if any of Bush's actions actually depend on previous events?
09:42:49 <Binkley> because Bush knows the cost of everything and the value of nothing?
09:43:02 <matthew_-> Syzygy- : quite
09:43:45 <Binkley> I guess Bush would definitely need a function for adding commas to large decimal numbers
09:43:48 <matthew_-> if only haskell were applied to politics. You should write to Bush and say "You should use >>= more and >> less"
09:43:51 <Binkley> I mean, he has a lot of those large numbers to deal with
09:44:30 <Binkley> If you think Haskell isn't *already* about politics, well...
09:44:40 <Binkley> HAY GUYS what do you think about trailing commas in lists?
09:44:47 <Binkley> but I guess that's applying politics to Haskell, not the other way around
09:45:07 <quicksil1er> I like trailing commas actually
09:45:13 <quicksil1er> not sure if there is a strong counterargument
09:45:18 <Binkley> No
09:45:21 <Binkley> trailing commas eat babies
09:45:21 * matthew_- misses the reference, presumes it's related to -cafe?
09:45:23 <Binkley> end of story.
09:45:29 <Binkley> matthew_: it's on the haskell-prime list
09:45:30 <Binkley> read it and weep
09:45:36 <Binkley> I was foolish enough to get involved, but I wish I hadn't
09:45:45 <gotaku> Trailinh commas?
09:45:50 <gotaku> Trailing
09:45:58 <Syzygy-> > [2,3,4,]
09:45:58 <lambdabot>  Parse error
09:46:02 <Syzygy-> Hmmmm.
09:46:12 <Binkley> Basically the point of the discussion was
09:46:17 <Binkley> they're allowed in import lists
09:46:20 <Binkley> but not in list or tuple literals
09:46:26 <Binkley> some people think this is bad, evil and horrible
09:46:27 <quicksil1er> @pl \x -> x * x
09:46:27 <lambdabot> join (*)
09:46:38 <Syzygy-> > join (*) 3
09:46:39 <lambdabot>  9
09:46:40 <quicksil1er> @type join (*)
09:46:41 <lambdabot> forall a. (Num a) => a -> a
09:46:46 <quicksil1er> @type join
09:46:47 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
09:46:51 <gotaku> What would be the point?
09:46:53 <Binkley> http://thread.gmane.org/gmane.comp.lang.haskell.prime/2002/focus=2085
09:46:54 <quicksil1er> it's that bloody arrow monad, again
09:46:56 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2oefju
09:46:59 <Binkley> I really don't recommend reading it, though
09:47:01 <Syzygy-> quicksil1er: Of course it is.
09:47:05 <Binkley> you'll wish you had that 40 minutes of your life back
09:47:11 <quicksil1er> Syzygy-: the arrow monad solves all known problems!
09:47:27 <Syzygy-> @type join join
09:47:29 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m (m a))
09:47:29 <lambdabot>       Expected type: m (m a) -> m (m a) -> a1
09:47:33 <Syzygy-> @type join . join
09:47:34 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
09:47:40 <Syzygy-> @type join . join . (*)
09:47:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
09:47:42 <lambdabot>       Expected type: a -> a -> a -> a1
09:47:46 <quicksil1er> Binkley: can you summarise in 15 words or less why it's a bad thing to allow trailing commas in lists?
09:47:48 <Syzygy-> @type join . join (*)
09:47:50 <lambdabot> forall (m :: * -> *) a. (Monad m, Num (m (m a))) => m (m a) -> m a
09:48:06 <matthew_-> ...riiiiiiiight. I'm not sure I get why the trailing commas is at all important.
09:48:11 <quicksil1er> > (join.join) (*) 3
09:48:12 <Binkley> quicksil1er: well, for one thing, I don't think it's very important either way
09:48:12 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
09:48:12 <lambdabot>       Expe...
09:48:22 <quicksil1er> matthew_-: it's handy when you're adding new entries at the end
09:48:23 <Binkley> but, I think it's ugly
09:48:31 <quicksil1er> matthew_-: (assuming one entry per line)
09:48:42 <Binkley> if you have a list literal that you're modifying a lot, maybe you should have a config file or something like that instead
09:48:43 <quicksil1er> matthew_-: if you just add a new entry at the end, you need to remember to 'comma' the last one
09:49:40 <matthew_-> quicksil1er: a challenge to remember to be sure
09:49:51 <quicksil1er> matthew_-: *shrug* it's a minor convenience :)
09:49:57 <matthew_-> quite.
09:50:01 <quicksil1er> matthew_-: much like the layout rule for do
09:50:02 <Binkley> Yeah, that's the point, it's minor
09:50:05 <quicksil1er> but we have that...
09:50:18 <Binkley> but somehow this sparked like a 30-message thread with multiple 6-paragraph emails about how this reflects deep points about human cognition
09:50:20 <Binkley> and so on
09:50:30 <quicksil1er> (or the layout rule for 'case', which just saves us using the occasional '|' like ML does)
09:51:30 <quicksil1er> @pl \x -> x * x * x
09:51:30 <lambdabot> (*) =<< join (*)
09:51:39 <matthew_-> mmm. You should have invited Larry Wall to comment
09:51:49 <Binkley> haha
09:51:54 <quicksil1er> why does lambdabot always do its monadic combinators backwards?
09:52:08 <quicksil1er> (join (*) >>= (*)) 3
09:52:10 <Binkley> lambdabot does everything that you do, but backwards and in high heels
09:52:12 <quicksil1er> > (join (*) >>= (*)) 3
09:52:13 <lambdabot>  27
09:52:15 <rahikkala> lambdabot likes to be contrary
09:52:18 <quicksil1er> Binkley: interesting
09:52:43 <paolino> is putStrLn strict ?
09:53:20 <quicksil1er> paolino: well, not until it gets 'executed', no
09:53:35 <quicksil1er> but once it gets executed it consumes all its arguments
09:53:43 <quicksil1er> if it just sits around "being an IO type" then it won't
09:54:05 <quicksil1er> (putStrLn undefined) won't break until you stuff it into main somewhere
09:54:06 <Saizan> it possibly starts to peint on stdout before evaluating all the string, however
09:54:11 <quicksil1er> (or unsafePerformIO)
09:54:15 <Binkley> well, the usual definition of strictness is that if its argument diverges, it diverges
09:54:19 <Saizan> s/peint/print
09:54:20 <Binkley> So in that sense, then, putStrLn is strict
09:54:35 <quicksil1er> Binkley: yes, that's a much better answer than mine
09:54:37 <paolino> I mean if I mapM putStrLn on the Writer state , it will print the log as it is produced ?
09:54:56 <quicksil1er> paolino: it won't do anything unless you are binding that into some IO action that actually happens
09:55:11 <quicksil1er> paolino: it will just build up a nice big IO action buried in your writer monad...
09:55:27 <quicksil1er> Binkley: still I suspect my answer was closer to what paolino meant :)
09:55:39 <paolino> I mean when I run main !
09:55:41 <Binkley> I'm not very good at reading minds, so I don't know what paolino meant :-)
09:55:45 <quicksil1er> paolino: you can construct IO values at will
09:55:59 <quicksil1er> paolino: they don't do anything unless you (a) 'run' the value produced in main
09:56:01 <xerox> paolino: you need to make that lazy to print the value as it is produced!
09:56:05 <quicksil1er> or (b) unsafePerformIO thenm
09:56:16 <paolino> eheh
09:56:35 <paolino> poor mind behind my skull
09:56:41 <quicksil1er> @type map putStrLn ["foo","bar","baz"]
09:56:43 <lambdabot> [IO ()]
09:56:54 <quicksil1er> this is a perfectly sensible piece of haskell, but it doesn't print anything
09:56:56 <Saizan> quicksil1er, i suspect the question is more "do putStrLn waits for the whole string to be evaluated before starting to print?"
09:57:06 <paolino> right
09:57:20 <quicksil1er> it doesn't print anything until you actually *perform* those actions, e.g. by feeding that list to sequence in the IO monad
09:57:21 <paolino> or the all list
09:57:25 <quicksil1er> in the main action
09:57:58 <quicksil1er> Saizan: it sounds like paolino has a pure Writer monad, which has no IO in its type
09:58:15 <quicksil1er> paolino: you may want WriterT IO, if you want to interleave IO with your monadic writer
09:58:21 <paolino> files :: String -> RWST r [String] [String] IO ()
09:58:42 <xerox> quicksil1er: no, he can actually have the writer computing the log and print it out as it is computed
09:58:58 <Saizan> :t runWriter
09:59:00 <lambdabot> forall w a. Writer w a -> (a, w)
09:59:09 <paolino>  execRWST (files ".." >>  shuffle) () [] >>= mapM putStrLn.snd
09:59:40 <paolino> will print the log of the 2 action as they are telled ?
09:59:58 <quicksil1er> looks like it to me
10:00:40 <gotaku> How do I stop the shell from being displayed when running gtk2hs programs in Windows?
10:01:46 <bakert> quicksil1er, can you think of any names for the subordinate functions?
10:01:51 <bakert> http://hpaste.org/400
10:02:06 <paolino> ..interesting
10:02:44 <quicksil1er> bakert: fmt'' looks like "add_commas"
10:03:07 <xerox> paolino: :m + Control.Monad.Writer  and   mapM_ print $ execWriter (let loop = do {tell [show (10^10)]; loop} in loop)   I think it does what you want it to do
10:03:12 <quicksil1er> bakert: fmt' looks like 'handle_decimal_point'
10:03:30 <quicksil1er> bakert: something like that :)
10:03:39 <bakert> like it.  that's going to make me line wrap the first line though.  a tragedy!
10:04:17 <quicksil1er> @pl \l -> case splitAt 3 l of ([], _) -> Nothing; p-> Just p
10:04:18 <lambdabot> (line 1, column 30):
10:04:18 <lambdabot> unexpected ","
10:04:18 <lambdabot> expecting variable, "(", operator or ")"
10:04:22 <bakert> also because fmt'' is called from in fmt' that means handle_decimal_point appears twice in the top line but nothing about adding commas
10:04:41 <bakert> i was calling the function commify before but i went off it.
10:05:07 <bakert> (also, i never use _ in my haskell function names except for tests ... is that bad?)
10:05:09 <quicksil1er> true, well you could go mad Handle_decimal_point_and_commas_and_padding
10:05:15 <bakert> eek!
10:05:20 <quicksil1er> I don't recommend it
10:05:22 <bakert> fmt' is definitely shorter!
10:05:26 <quicksil1er> I'm just saying 'some name is better than no name'
10:05:33 <bakert> i hear ya.
10:05:37 <quicksil1er> even if it's not a full perfect description of everything it does
10:05:58 <quicksil1er> @pl \l -> case splitAt 3 l of {([], _) -> Nothing; p-> Just p}
10:05:59 <lambdabot> (line 1, column 27):
10:05:59 <lambdabot> unexpected "{"
10:05:59 <lambdabot> expecting variable, "(", operator or end of input
10:06:02 <bakert> addCommasToPositiveDecimalHandlingDecimalPoint is definitely overkill!
10:06:04 <mauke> @ghc
10:06:05 <lambdabot> ghc says: Illegal constraint
10:06:05 <quicksil1er> hmph
10:06:37 <bakert> > cycle "OVERKILL! "
10:06:38 <lambdabot>  "OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERKILL! OVERK...
10:06:43 <mauke> @ghc
10:06:44 <lambdabot> ghc says: Malformed predicate
10:08:00 <bakert> quicksil1er, My desire to keep the names fmt' and fmt'' comes from wanting to keep 80 col limit.  Perhaps I need to abandon 80 cols.
10:08:17 <bakert> freeing myself to write big long function names.
10:09:02 <matthew_-> bakert: My screen is 1680 pixels wide. Fullscreen emacs. I still have lines of haskell that wrap.
10:09:24 <bakert> matthew-_, that is just SICK!  Sick I tell you!  I have four vims all alongside one another!
10:09:33 <bakert> but filling the whole screen vertically.
10:09:35 <bakert> pretty!
10:09:44 <matthew_-> bakert: you should investigate vims frames and tabs
10:10:05 <bakert> matthew-_, i use split.  that's good enough for me.  don't like tabs.
10:10:27 <bakert> matthew-_, those wrapping lines of haskell must be disturbing.
10:10:39 <matthew_-> nah. you get used to it.
10:11:04 <matthew_-> though it is annoying when I move to my laptop which is 1024 wide and suddenly the wrapping looks a bit worse
10:11:21 <Binkley> 78 columns is all that anyone will ever need
10:11:26 <matthew_-> rubbish
10:11:40 <matthew_-> I have java class names which are 78 chars long
10:11:50 <matthew_-> hence programming in a proportional font
10:12:52 <Binkley> every time you name a Java class something 78 characters long, god kills a kitten
10:13:06 <Wallbraker> matthew_-: whats it called?
10:13:15 <matthew_-> err, I'd have to go digging
10:13:15 <xerox> mew.
10:13:37 <gotaku> 78 char long class name?
10:14:28 <bakert> Proportional font emacs with no line breaks.  You are the anti-me!
10:16:22 <matthew_-> ok, I lie. 51. IViewQueryTreeAttributeValueContainsCaseInsensitive
10:16:37 <bakert> I do sometimes get jealous of wide lines.  But you have to draw the line somewhere.
10:16:40 <bakert> Don't you?
10:17:04 <Binkley> no, I don't have line envy
10:17:11 <Binkley> it's not the size of your lines, anyway, it's what you do with them
10:17:15 <sjanssen> bakert: I think you're out of line
10:18:00 <bakert> sjanssen, what do you mean??!
10:18:07 <xerox> > 229044644/1024/1024/1024
10:18:08 <lambdabot>  0.2133144475519657
10:18:20 <Binkley> I think that was supposed to be a pun
10:18:22 <Binkley> "out of line"
10:18:25 <Binkley> ha ha ha ha ha ha ha
10:18:38 <bakert> oh sorry.  i thought my semi-slagging of emacs had upset someone!
10:18:52 <Binkley> nah, RMS isn't on this channel
10:19:00 <Binkley> *or is he???* *looks around*
10:19:07 <Binkley> No, no, it smells okay in here. Carry on.
10:19:16 <matthew_-> O.o
10:19:49 <dcoutts_> gotaku, -optl-mwindows  see http://haskell.org/gtk2hs/archives/2005/06/23/hiding-the-console-on-windows/
10:19:53 <bakert> Binkley, tsk.
10:21:18 <bakert> So is anyone else going to reveal what column width they work with?
10:21:28 <bakert> It's an ongoing quest of mine to work this one out.
10:21:53 <bakert> What I really want is super super intelligent wrapping from my editor.
10:22:24 <dcoutts_> bakert, 79
10:23:22 <vincenz> bakert: 1
10:23:27 <kolmodin> bakert: 76
10:23:29 * vincenz prefers 1 character per column
10:23:34 <Binkley> bakert: pi
10:23:44 <vincenz> or were you asking in pixels?
10:23:51 <Binkley> and believe me, getting my X drivers to accept those fractional pixels was a bitch
10:24:02 <kolmodin> 42. 56. 23. 94. 34. sorry, what was the question again?
10:24:34 <shapr> shazam!
10:24:35 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
10:24:35 <bakert> The question is, what column do you wrap at?  Or if you don't wrap religiously, what roughly do you do.
10:24:46 * Binkley only wraps agnostically
10:24:49 <bakert> though there are some here who thing that it is an unimportant consideration!
10:24:57 <bakert> (judging from the sarcasm!)
10:25:04 <chessguy> shapr!
10:25:09 <chessguy> @shapr
10:25:10 * lambdabot beats up
10:25:18 <hpaste>  paolino annotated "shuffle with DiffArray" with "STShuffle" at http://hpaste.org/395#a1
10:25:37 <vincenz> bakert: why the concern with column width?
10:25:40 <shapr> hiya chessguy
10:25:44 <vincenz> bakert: use whatever the size of your vim is ;)
10:25:50 <chessguy> how goes it?
10:25:56 <vincenz> bakert: not to mention, instead of placing vims next to each other, get a real vim, like 7.0 and get tabbing
10:26:11 <newsham> > let f (x%y) = x in f (3%2)
10:26:12 <lambdabot>  Parse error in pattern
10:26:23 <mauke> % is not a constructor
10:26:23 <vincenz> newsham: o.O
10:26:31 <vincenz> > 3%2
10:26:32 <lambdabot>  3%2
10:26:45 <newsham> > numerator (3%2)
10:26:47 <lambdabot>  3
10:26:49 <vincenz> :t (3%2)
10:26:51 <lambdabot> forall a. (Integral a) => Ratio a
10:27:03 <newsham> > log 3
10:27:04 <vincenz> @src Ratio
10:27:05 <lambdabot>  1.0986122886681098
10:27:05 <lambdabot> data (Integral a) => Ratio a = !a :% !a
10:27:18 <vincenz> > let f(x:%y) = x in f(3%2)
10:27:19 <lambdabot>   Not in scope: data constructor `:%'
10:27:47 <chessguy> shapr, did you have time to look at my code?
10:27:59 <newsham> > log (numerator (3%2))
10:28:00 <lambdabot>  Add a type signature
10:28:39 <newsham> > log $ fromIntegral $ numerator $ 3%2
10:28:41 <lambdabot>  1.0986122886681098
10:28:41 <vincenz> @type numerator
10:28:43 <lambdabot> forall a. (Integral a) => Ratio a -> a
10:28:49 <shapr> chessguy: Sorry no, life has been distracting.
10:29:07 <shapr> Yesterday, a large truck ran over a utility pole and I was without power or network for the whole day!
10:29:16 <chessguy> yikes!
10:29:43 <vincenz> shapr: what an idea to leave these lying down...if it had stood up at least the truck would not have been able to drive over it
10:30:10 <shapr> vincenz: huh?
10:30:16 <bakert> vincenz, well it's a decision you can't avoid making so i try to make it consciously.  i've never heard much of an argument for anything other than 72, 78 or 80 cols.  but sometimes i feel a bit restricted in 80.
10:30:51 <bakert> vincenz, the original discussion was about my function:
10:30:58 <bakert> http://hpaste.org/400
10:31:17 <bakert> which has two subsidiary functions fmt' and fmt'' which i am reluctant to rename because that would add 3 lines to the function (!!!)
10:31:32 <vincenz> bakert: you do realize that `wrapping` is purely defined by how wide you make your vim window, unless you get "textwidth" at which case it'll really wrap your code and make it illegal
10:31:47 <vincenz> bakert: yeah, clarity is an evil succubus
10:31:48 <astrolabe> bakert: why not call them 'f' and 'g'?  :)
10:32:09 <bakert> astrolabe, that's definitely a possiblity.  not sure if you are being sarcastic but i'm not!
10:32:10 <vincenz> bakert: most people put the 'where' on the next line
10:32:28 <bakert> vincenz, yeah i have been ummming and ahhing about that one
10:32:52 <bakert> vincenz, i actually put line breaks in all my code.  there is no wrapping as such going on.
10:32:58 <gotaku> Can someone tell me what the point of flip is?
10:32:59 <astrolabe> If I use a variable a lot, and it is local, I give it a short name, with a comment if necessary.
10:33:28 <astrolabe> gotaku: lots of uses
10:33:35 <hpaste>  vincenz annotated "Adding commas to large decimal numbers." with "reasonably saner bakert code" at http://hpaste.org/400#a1
10:33:42 <astrolabe> It is useful sometimes for accumArray
10:33:54 <astrolabe> and for pointsfree code
10:34:44 <bakert> hmm yeah i do like the where on the next line vincenz
10:34:45 <hpaste>  vincenz annotated "Adding commas to large decimal numbers." with "somewhat better " at http://hpaste.org/400#a2
10:35:26 <pejo> bakert, didn't dcoutts post a nice piece of code for that problem from the gtk2hs examples?
10:37:08 <pejo> bakert, http://hpaste.org/336
10:37:57 <bakert> pejo, doesn't deal with negative numbers, or decimals.  it is the basis of my function.
10:37:59 <vincenz> pejo: note how bakert handels negative numbers as well as floating point....
10:38:16 <pejo> bakert, ah, bummer.
10:38:17 <bakert> yeah what he said!
10:38:18 <vincenz> bakert: btw...compare with 0
10:39:29 <bakert> vincenz, not sure what you mean ... you mean that mine gives "0.00"?
10:39:44 <vincenz> no but nm
10:39:47 * vincenz is going home
10:40:06 <bakert> bye
10:40:33 <bakert> Can a "darcs optimize --reorder-patches" conceivably take a very long time?
10:46:36 <pejo> bakert, fmt d | d < 0.0 = = "-" ++ (fmt' (-d)) RET | otherwise = fmt' d is shorter than the if-statement, if that was what bothered  you.
10:47:05 <pejo> bakert, uh, minus the double = on the first line. Sorry about that.
10:47:27 <bakert> pejo, i'm always happy to see code get shorter.
10:48:09 <bakert> i hardly ever think about guard clauses.  terrible.
10:54:07 <dblhelix> jeroeng: at work, arie's in the same room as I am
10:54:44 <jeroeng> dblhelix: I've got some stuff working, but I can't manage to make a good division in the type system
10:55:02 <dblhelix> jeroeng: from time to time, he's on #haskell, his nick is amiddelk
10:55:19 <dblhelix> jeroeng: a type-level integer division?
10:56:03 <jeroeng> dblhelix: indeed
10:56:56 <dblhelix> jeroeng: and how've you encoded the integers? or are they just peano naturals?
10:57:05 <chessguy> > printChar 'a'
10:57:06 <lambdabot>   Not in scope: `printChar'
10:57:13 <jeroeng> dblhelix: Yes they are
10:57:18 <chessguy> > putChar 'a'
10:57:20 <lambdabot>  <IO ()>
10:57:31 <chessguy> :t putChar 'a'
10:57:33 <lambdabot> IO ()
10:57:37 <jeroeng> dblhelix: The compiler complains about non-matching functional dependencies
10:58:55 <dblhelix> jeroeng: mmm, I've never tried that... shall we have a look at it tomorrow? somewhere between the exercise sessions and the lab sessions?
10:59:25 <jeroeng> dblhelix: That'd be nice. But isn't that only a 15-minute-gap?
11:00:05 <dblhelix> jeroeng: we'll tweak the schedule a little ;)
11:00:46 <jeroeng> dblhelix:   Allright then :)
11:01:00 <jeroeng> dblhelix: I think this is rather cool: (fac (undefined:: Succ ( Succ (Succ Zero)))) :: Integer = 6
11:01:03 <newsham> > readFile "/etc/passwd" >>= print
11:01:05 <lambdabot>  <IO ()>
11:01:18 <dblhelix> jeroeng: so you liked the talk?
11:01:23 <xerox> jeroeng: I've got type-level roman numerals (:
11:02:33 <jeroeng> dblhelix: I sure did, from now on I'll try to be at the colloquium whenever I get the chance :-)
11:02:43 <xerox> http://haskell.org/haskellwiki/User:PaoloMartini#Roman_.28type-.29numerals
11:02:46 <lambdabot> Title: User:PaoloMartini - HaskellWiki, http://tinyurl.com/2as2s2
11:04:50 <Saizan> newtype (IArray arr (Int,Int) a) => PBM a = PBM arr <-- what's the right way to write this, if there's one?
11:05:03 <lmbdwr> is there a keyword in haskell to make the compiler aware of the purity of an object ?
11:06:55 <lmbdwr> (which should be different than a type)
11:08:54 <pejo> lmbdwr, out of curiousity - why do you feel this is necessary?
11:08:57 <allbery_b> well, no, it's not different from a type.  anything not in IO is pure, more or less
11:09:45 <allbery_b> (hopefully more ,btu if you're doing unsafe* behind its back tha's your lookout)
11:10:30 <psnl> has there been a big argument over the STM thing on LtU?
11:11:39 <pejo> psnl, it's mentioned every now and then. Think the video was linked too.
11:11:58 <psnl> no, the blog article...
11:12:44 <jeroeng> dblhelix: It was so interesting, that I just spend 2 hours on building some basic operations in the type system (such as addition, subtraction, multiplication, faculty). The cool part is that I can actually compute the Integer value :)
11:13:19 <paolino> Saizan : PBM (arr (Int,Int) a)  ?
11:13:27 <dblhelix> jeroeng: have you ever had a look at oleg's collection of scary programs?
11:14:02 <lmbdwr> allbery_b, its different from a type because then you cannot use the keyword "pure" before the type system, that you might want to do for doing code elimination, or you would have to mix your type checker and your compiler
11:14:16 <dblhelix> jeroeng: http://okmij.org/ftp/Haskell/
11:14:17 <lambdabot> Title: Haskell Programming: Miscellanea
11:14:35 <Saizan> paolino: right, but i lose the IArray constraint, however that's not a big problem
11:14:49 <jeroeng> dblhelix: One of thos links is purple, so I guess I did :>
11:15:00 <dblhelix> :)
11:15:49 <pejo> lmbdwr, I still don't understand.
11:16:52 <lmbdwr> pejo, the info can be useful to avoid too heavy program analysis at compile time, in some case you want code to be without side effect in order to make sure you can avoid to generate it
11:17:03 <allbery_b> erm
11:17:14 <allbery_b> all Haskell code is pure unless you put it in IO
11:17:28 <lmbdwr> sorry, did my sentence appeared correctly ?
11:17:37 <lmbdwr> or was it cut in the middle
11:18:07 <lmbdwr> allbery_b, yea IO is an obvious problem I see
11:19:34 <pejo> lmbdwr, the lazy evaluation atleast lets you avoid running it if there is no use for it. I'm not sure I see how your non-monadic expressions would have side effects in any way though, or why it would need annotations.
11:20:53 <lmbdwr> pejo, what if the code appears in filtering ?
11:21:27 <lmbdwr> higher order filtering, that is
11:21:59 <lmbdwr> I dont know haskell really, I just wondered how it dealt with this
11:22:39 <lmbdwr> and my remark was only if you are writing a compiler
11:23:27 <pejo> Surprisingly many are doing that kind of stuff in here.
11:23:57 <lmbdwr> which kind ?
11:24:03 <pejo> Writing compilers.
11:24:26 <pejo> Or which kind of compilers?
11:24:51 <lmbdwr> just a simple compiler for a functional langage towards an modern SECD abstract machine
11:26:29 <Hunter_wow> @ checkNum
11:26:49 <Hunter_wow> any ideas what I need to import for checkNum?
11:28:18 <Hunter_wow> WinHugs
11:28:46 <Cale> checkNum?
11:29:00 <Cale> @index checkNum
11:29:00 <lambdabot> bzzt
11:29:05 <Cale> @hoogle checkNum
11:29:06 <lambdabot> No matches found
11:29:14 <Cale> It's not in the libraries, afaict.
11:29:45 <gvdm_other> well done on the mandelbrot don, chris, trevor and spence
11:29:56 <Hunter_wow> aha, ok ty =)
11:30:44 <gvdm_other> now for the n-body ;-)
11:31:12 <xerox> lmbdwr - Maybe you can find your answers in the "Compiler Technology" papers listed here http://research.microsoft.com/%7Esimonpj/Papers/papers.html
11:31:13 <lambdabot> Title: Simon Peyton Jones: papers
11:31:22 <gvdm_other> ouch, upon closer inspection we are getting owned by java for n-body
11:32:37 <bos> @pl \rs -> map (/ sum rs) rs
11:32:37 <lambdabot> map =<< flip (/) . sum
11:36:06 <bos> pl's fascination with =<< is a bit off-putting :)
11:36:52 <allbery_b> pl loves Monad ((->) r)
11:38:47 <kolmodin> during the test of a 'darcs record', how can I see what happened in the patch?
11:38:49 <kolmodin> dons ^^
11:41:28 <xerox> ?djinn (e -> a) -> (a -> e -> b) -> (e -> b)
11:41:28 <lambdabot> f a b c = b (a c) c
11:41:55 <bos> what's the complement of fromIntegral to convert a Floating to an Integral?
11:42:48 <dylan> @hoogle from
11:42:49 <lambdabot> Maybe.fromJust :: Maybe a -> a
11:42:49 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
11:42:49 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
11:43:01 <allbery_b> round, truncate, floor, ceiling
11:43:08 <bos> > fromRat 3.2 :: Int
11:43:09 <lambdabot>   add an instance declaration for (RealFloat Int)
11:43:09 <lambdabot>     In the expression: from...
11:43:35 <bos> > floor 3.2
11:43:36 <lambdabot>  3
11:43:44 <bos> allbery_b: thanks
11:45:15 <kolmodin> ?seen dons
11:45:16 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 6h 30m 23s ago.
11:45:32 <bos> must be bedtime in nsw
11:46:22 <bos> @hoogle sizeOf
11:46:23 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
11:49:24 <gotaku> The language shootout has been updated and Haskell moved up another 2 places!
11:49:49 <bd_> ooh, it's beating ocaml now
11:50:33 <gotaku> Ocaml is just close because of Gzip bytes.
11:50:49 <gotaku> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all&calc=Calculate&xfullcpu=1&xmem=1&xloc=0&binarytrees=1&chameneos=1&message=1&fannkuch=1&fasta=1&knucleotide=1&mandelbrot=1&meteor=0&nbody=1&nsieve=1&nsievebits=1&partialsums=1&pidigits=1&recursive=1&regexdna=1&revcomp=1&spectralnorm=1&hello=0&sumcol=1
11:50:51 <gotaku> Ah
11:50:52 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/ykuwfz
11:50:56 <gotaku> Sorry.
11:52:12 <glguy> so what was the trick to getting mandelbrot to be amazing?
11:52:45 <gotaku> glguy: You won't believe it.
11:52:46 <allbery_b> discovering that gcc was doing evil things to Doubles with -O3
11:53:11 <gotaku> gcc was botching Doubles, really really badly.
11:54:15 <thedward> if one language is more compressible than another, shouldn't that indicate more redundancy?
11:54:21 <xerox> @babel en it botching
11:54:22 <lambdabot>   botching
11:54:27 <allbery_b> heh
11:55:17 <Hunter_wow> is it not possible to type something like this:   x == Int; where x = 5     -> True
11:55:58 <Hunter_wow> ?
11:57:01 <mwc> Holy crap... I just got authorized on the entire metacluster... Anybody ever run Parallel Haskell on a 3000-core cluster? :)
11:57:49 <titus> Hunter_wow: is your question about conditionals?
11:58:24 <xerox> Hunter_wow -  f :: Int -> Bool  f 5 = True  f _ = False
11:59:52 <Hunter_wow> xerox: but that will give type error if there isent an integer. Whant to check if its an Int
12:00:00 <woggle> :t 5
12:00:01 <Hunter_wow> or not
12:00:02 <lambdabot> forall t. (Num t) => t
12:00:10 <Hunter_wow> aha :O
12:00:13 <fasta> Oh, fuck: *** Exception: No match in record selector Var.tcTyVarDetails
12:00:20 <woggle> Hunter_wow: As you can see, '5' is not necessairily an Int.
12:00:34 <fasta> I am pushing GHC beyond its limits :(
12:00:49 <fasta> I am not even doing type-level functions, yet....
12:00:57 <Hunter_wow> '5' = Num?  And Num is a number at least right?
12:01:15 <fasta> Only fundeps + MPTC
12:01:29 <Hunter_wow> double, int, float = Num?
12:01:33 <Hunter_wow> :t Num
12:01:35 <lambdabot> Not in scope: data constructor `Num'
12:01:39 <Cale> fasta: GHC bug?
12:01:48 <fasta> Cale: must be
12:02:20 <allbery_b> Num is the base numeric typeclass
12:03:18 <Cale> Hunter_wow: x :: (Num t) => t means that if t is any type of number (instance of the Num typeclass), then x can have type t.
12:03:57 <Hunter_wow> Cale: aha, roger, thanks
12:04:09 <fasta> Cale: Particularly annoying is that I have no idea of how to communicate to anyone how to reproduce it.
12:04:28 <Cale> fasta: working on proprietary code?
12:04:30 <gotaku> What is (Num t) => called again? I know what it does just not the name.
12:04:37 <Cale> gotaku: a class context
12:04:42 <gotaku> Right, thanks.
12:04:59 <fasta> Cale: well, I am not sure whether it stays proprietary.
12:05:06 <fasta> Cale: but currently it is.
12:05:52 <Cale> fasta: Well, maybe compress a copy of the whole thing, and if it ever becomes open, send it to the GHC bugtracker.
12:06:14 <shapr> fasta: Can you boil the code down to something smaller?
12:06:19 <Cale> Might be worth looking for a subset of the code which still produces the problem though.
12:06:27 <fasta> Cale: That doesn't hurt GHC, I know.
12:06:41 <fasta> Cale: Sure, but MPTC and fundeps are pretty new to me.
12:06:54 <fasta> shapr: That was for you
12:06:54 <abz> ?users
12:06:55 <lambdabot> Maximum users seen in #haskell: 322, currently: 313 (97.2%), active: 49 (15.7%)
12:07:06 <fasta> ?lusers
12:07:06 <lambdabot> Maximum users seen in #haskell: 322, currently: 313 (97.2%), active: 49 (15.7%)
12:07:12 <glguy> @losers
12:07:13 <lambdabot> Maximum users seen in #haskell: 322, currently: 313 (97.2%), active: 49 (15.7%)
12:07:13 <fasta> lusers >> users
12:07:44 <Cale> fasta: that's unfortunate, I've never had any troubles with them myself.
12:07:46 <fasta> I do know that adding one function call triggers the bug.
12:08:19 <Cale> fasta: okay. How large is the set of dependencies of the function which has that call in it?
12:08:31 <Cale> Maybe just immediate dependencies would do.
12:08:54 <Cale> You can define things with undefined, but give them the right types.
12:09:10 <fasta> Cale: Ok, in this case that might be feasible.
12:10:08 <fasta> Cale: I also could try with ghc-6.6 first.
12:10:23 <fasta> Cale: (this is a three week old copy of 6.7)
12:12:22 <shapr> nmessenger: SHAZAM!
12:13:26 * nmessenger is too lazy to turn into anything clever
12:13:34 * shapr grins
12:13:38 * nmessenger turns into CAPTIAN LAZY!
12:14:04 <shapr> w00!
12:18:32 <nmessenger> @quote drops.dead
12:18:32 <lambdabot> syntaxfree says: * syntaxfree often uses (&) = flip (.)  for additional clarity.   <nmessenger> @src (->) (>>>)   <lambdabot> f >>> g = g . f   * syntaxfree drops dead.
12:26:00 <jeroeng> dblhelix: How about this: let {?base = 0; ?func = (+1)} in compute (three <^> three) = 27
12:26:45 <shapr> Wow, Laurie Williams (of pair programming fame) is publishing Haskell oriented papers!
12:26:57 <dblhelix> jeroeng: context?
12:27:20 <jeroeng> dblhelix: indeed
12:27:38 <shapr> dons: Hey, have you read "Tool Support For Estimating Software Reliability in Haskell Programs" by M Sherriff, L Williams - Student Paper, IEEE International Symposium on Software ~, 2004 - ncsu.edu ?
12:27:48 <monochrom> &&&*** programming? :)
12:27:57 <dblhelix> jeroeng: I meant, in what context does this code arise? :)
12:28:08 <jeroeng> Oh :)
12:28:47 <jeroeng> dblhelix:  three is just a synonym for undefined:: Succ (Succ ( Succ Zero)), <^> is a power-function defined within the type-system and compute translates the type to a value
12:29:44 <dblhelix> jeroeng: ah, cool
12:30:58 <jeroeng> dblhelix: It took me quite some time to realize those implicit parameters are the way to go, they are truly lovely :-). By the way, are you still at work in Utrecht?
12:31:34 <oklopol> will [1..] crash lambdabot? it runs haskell right?
12:31:42 <nmessenger> > [1..]
12:31:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:31:54 <oklopol> thought something like that
12:31:59 <nmessenger> > fix (1+)
12:32:00 <lambdabot>  Exception: <<loop>>
12:32:13 <oklopol> GHC crashes, can you point me a better one?
12:32:25 <dblhelix> jeroeng: no, I'm at home now, but, indeed, still working
12:32:31 <oklopol> i don't like it crashing when i fail... which i do all the time since i don't know the lang
12:33:03 <gvdm_other> how does lambdabot deal with possibly malicious input?
12:33:12 <Cale> oklopol: crashes?
12:33:51 <Cale> gvdm_other: It checks that the expression is really a haskell expression (parses it), and then it evaluates the expression, and applies show to the result.
12:34:09 <nmessenger> > length [1..]
12:34:13 <lambdabot> Terminated
12:34:18 <gvdm_other> and what if it's a valid haskell expression designed to fail and screw it?
12:34:20 <Cale> It also does some time limiting.
12:34:26 <Cale> > undefined
12:34:27 <lambdabot>  Add a type signature
12:34:31 <Cale> > undefined :: Int
12:34:33 <lambdabot>  Undefined
12:34:35 <gvdm_other> ah, ok
12:34:39 <Cale> > error "Hello" :: Int
12:34:41 <lambdabot>  Exception: Hello
12:35:06 <nmessenger> > putStr "IO actions aren't executed"
12:35:08 <lambdabot>  <IO ()>
12:35:23 <Cale> It does evaluate the IO action, but it doesn't execute it :)
12:35:35 <gvdm_other> seems pretty robust
12:35:37 <oklopol> Cale crashes as in loops forever, unless i press ctrl+C in which case it jams and i can't do anything but force it to shut down
12:35:55 <Cale> oklopol: oh, that's strange, Ctrl-C should give you back your prompt.
12:36:02 <monochrom> ??  If you learn computer programming, you can't avoid infinite loops.
12:36:07 <oklopol> might've been a random failure
12:36:10 <nmessenger> Cale: unless it's on Windows :/
12:36:16 <glguy> Cale: windows doesn't do well with ^C and GHC
12:36:21 <Cale> Oh, does Windows have a problem with that?
12:36:27 <oklopol> it seems to :\
12:36:29 <Cale> I wonder why?
12:36:36 <monochrom> Don't use Windows for learning programming.
12:36:41 <Cale> hehe
12:36:58 <monochrom> Even DOS 3.3 is a better substrate.
12:36:59 <nmessenger> oklopol: I'm a windowser and I've just learned not to send ghci into an infinite loop :)
12:37:06 <oklopol> i've programmed for 10 years, i'm just new to haskell
12:37:12 <oklopol> okay
12:37:13 <nmessenger> > take 10 $ [1..]
12:37:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:37:21 <fons> Can (->) be userd as a type constructor?
12:37:22 <Cale> That's such a shame. It's rather fun to send it into infinite loops.
12:37:31 <Cale> fons: yes, it is one
12:37:33 <nmessenger> fons: yep, that's what it is
12:37:37 <fasta> nmessenger: doesn't C-c work on Windows?
12:37:46 <monochrom> If on Windows and learning Haskell, WinHugs may be a more babysitting environment than ghci.
12:37:50 <fasta> Cale: I made a test case.
12:37:52 <DannoHung> Hi Haskellers.  Are there any particularly good Haskell books?  I know a lot of people just jump in, but I like learning through reading.
12:38:02 <fons> Cale, so I can make constructur classes with it?
12:38:02 <nmessenger> fasta: it stops execution, but it also freezes ghci :(
12:38:05 * emu remembers DOS 3.3
12:38:08 <fasta> Cale: I only discovered that it does work on ghci-6.6
12:38:15 <fons> constructor*
12:38:34 <nmessenger> @kind (->) Int ((->) Char Double)
12:38:35 <oklopol> i have 6.6
12:38:36 <lambdabot> *
12:38:36 <emu> http://haskell.org/haskellwiki/Books_and_tutorials
12:38:37 <lambdabot> Title: Books and tutorials - HaskellWiki
12:38:39 <oklopol> and it doesn't work
12:38:43 <DannoHung> Thanks emu
12:38:44 <fasta> Cale: So, it could be that they just temporarily broke it.
12:39:19 <gotaku> I think a new Haskell book is coming out soon.
12:39:30 <shapr> Yup, from gmh I think.
12:39:35 <fons> gotaku, which one?
12:39:51 <fons> I'm dying for a proper Haskell book
12:39:51 * dcoutts_ has seen an advance copy
12:39:52 <bos> gmh's is already out.
12:40:09 <bos> it's another cs101 book.
12:40:09 <fons> which explains the advance features
12:40:10 <dcoutts_> bos, I thought it was only pre-order atm
12:40:14 <chessguy> i can't wait, i've got HSOE and AOFP coming in a couple weeks
12:40:19 <fons> advanced
12:40:29 <Cale> fons: absolutely, it's an instance of Arrow already
12:40:45 <bos> dcoutts_: it's available in the US as of jan 15, at least
12:40:56 <DannoHung> I hope to find a proper one too, I've been programming for a quite some time and I became interested in Haskell particularly because of the functional paradigms presented in SICP
12:41:08 <chessguy> DannoHung, me too
12:41:24 <chessguy> well, with regards to SCIP. i wouldn't say i've been programming for all that long
12:41:40 <chessguy> SICP, even
12:41:43 <monochrom> Bird's "intro to functional programming using haskell" has advanced topics: monad transformer, parser combinator, calculating a program from a specification.
12:41:57 <bos> what does "AOFP" expand to?
12:42:07 <nmessenger> @. elite run length [1..]
12:42:11 <lambdabot> teRMIna73d
12:42:14 <shapr> Art of Functional Programming?
12:42:20 <monochrom> aspect oriented functional programming XD
12:42:42 <DannoHung> Oh, are there any books that get into depth on the type system?
12:42:43 <fons> the most complete book I'm aware about (apart from the report :P which is not really friendly) is Thomsons book but it doesn't cover "The awkward squad"
12:42:45 <emu> atomically operated functional programs
12:42:48 <humasect> monochrom =)
12:42:54 * xerox sedates monochrom 
12:43:13 <monochrom> Please don't sedate me.  But seductions are welcome.
12:43:24 <bos> dons says someone is working on a "practical haskell" book, but didn't mention who.
12:44:26 <fons> I would like to see a book which covered monads, FFI, exceptions, (and maybe existentials and multiparameter classes even if they are not still standard haskell)
12:44:53 <fasta> FFI are way too practical for any book coming from the academic world. ;)
12:45:06 <fasta> is*
12:45:13 <fons> fasta, True, it doesn't have to be academic
12:45:38 <DannoHung> what's FFI?
12:45:45 <fasta> @where FFI
12:45:46 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
12:45:51 <fons> fasta, actually something like that is required to begin to show that Haskell is not merely academic
12:45:53 <monochrom> But the FFI was drafted and approved by the academic.
12:45:59 <DannoHung> ohhhh
12:46:12 <DannoHung> This channel has the most awesome bot ever, incidentally
12:46:20 <monochrom> I don't think it's practical to care what is academic.
12:46:22 <fasta> DannoHung: nah
12:46:27 <nmessenger> @quote lambdabot
12:46:27 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
12:46:34 <fasta> DannoHung: have you ever met sarahbot?
12:46:46 <DannoHung> Don't believe I've had the pleasure
12:46:48 <fasta> DannoHung: It does some NLP, IIRC.
12:47:14 <fasta> lambdabot's architecture is quite interesting, though.
12:47:21 <nmessenger> @all-dicts nlp
12:47:22 <lambdabot> *** "NLP" wn "WordNet (r) 2.0"
12:47:23 <lambdabot> NLP
12:47:23 <lambdabot>      n : the branch of information science that deals with natural
12:47:23 <lambdabot>          language information [syn: {natural language processing},
12:47:23 <lambdabot>           {human language technology}]
12:47:25 <lambdabot> [20 @more lines]
12:47:59 <paolino> @more
12:47:59 <lambdabot>  
12:48:00 <lambdabot> *** "nlp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
12:48:00 <lambdabot> NLP
12:48:00 <lambdabot>      Natural Language Processing
12:48:00 <lambdabot>  
12:48:01 <lambdabot> [15 @more lines]
12:50:04 <chessguy> hmmm. "Monad is not a type class"....is that right?
12:50:12 <DannoHung> So the Richard Bird book would be good for a Haskell newb/Functional paradigm non-newb
12:50:12 <nmessenger> @src Monad
12:50:13 <lambdabot> class  Monad m  where
12:50:14 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:50:14 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:50:14 <lambdabot>     return      :: a -> m a
12:50:14 <lambdabot>     fail        :: String -> m a
12:50:19 <nmessenger> looks like one :)
12:50:40 <fons> Now that I'm spending some time in the channel I would like to begin making use of the bot, is ther a command reference?
12:50:49 <jeroeng> dblhelix: Is there a way to omit implicit parameters when they are not used? Or can you give them a pre-defined value?
12:50:51 <nmessenger> @list
12:50:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:50:59 <fons> thanks
12:51:00 <chessguy> this is wierd. this professor is saying that m is a type constructor in that declaration, and that Monad is a class of type constructors, not a class of types
12:51:56 <nmessenger> Hmm, a type constructor could be considered a type, just like a function is considered a value.
12:52:04 <glguy> m is a type constructor, it takes a type "a" in this case and returns the type
12:52:20 <fons> @uptime
12:52:21 <lambdabot> uptime: 9h 11m 40s, longest uptime: 2d 3h 42m 19s
12:52:22 <chessguy> i thought type constructors were supposed to start with a capital letter
12:52:25 <dblhelix> jeroeng: you mean when calling a function?
12:52:38 <glguy> chessguy: it's a variable
12:52:41 <jeroeng> dblhelix: Yes
12:53:05 <dblhelix> chessguy: sometimes people refer to types of kind * -> * only as type constructors
12:53:07 <chessguy> ah, ok. so it *stands* for a type constructor
12:53:12 <jeroeng> dblhelix: I've got this situation where I don't really want to define it, I could define it as undefined, but that's silly
12:53:17 <nmessenger> *all* types start with capital letters, all type *variables* start with lowercase
12:53:23 <glguy> I don't know that I like the idea that Monad is a class of type *constructors* though...
12:53:29 <glguy> OH
12:53:31 <glguy> never mind
12:53:39 <glguy> hmm..
12:53:57 <dblhelix> jeroeng: I'm not aware of the ability to default them... but I'm really not an implicit-parameter expert
12:54:00 <nmessenger> that just means that a monad (Maybe for example) is of kind * -> *
12:54:05 <chessguy> are there other examples of classes of constructers?
12:54:07 <glguy> Monad (Maybe a) means that given some 'a' "Maybe a" is an instance of Monad
12:54:10 <glguy> that doesn't mean that Maybe is
12:54:15 <nmessenger> chessguy: Functor
12:54:27 <jeroeng> dblhelix: Allright. I'll just puzzle around a bit :-).
12:54:55 <nmessenger> @type return
12:54:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
12:55:04 <nmessenger> m is of kind * -> *
12:55:06 <nmessenger> :k Maybe
12:55:07 <lambdabot> * -> *
12:55:23 <glguy> oh
12:55:29 <glguy> instance Monad Maybe where -- right?
12:55:30 <nornagon> how does one get information out of a CalendarTime? i.e, what week/month/etc. it is?
12:55:36 <nmessenger> I believe so
12:55:37 <glguy> ?src Maybe Monad
12:55:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:55:48 <chessguy> ?src Maybe
12:55:49 <nornagon> glguy: instance Monad (Maybe a) where, wouldn't it be?
12:55:49 <lambdabot> data Maybe a = Nothing | Just a
12:55:58 <glguy> nornagon: I don't think so
12:55:58 <nornagon> ?src Monad Maybe
12:55:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:56:05 <glguy> ?fptools Data.Maybe
12:56:06 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
12:56:17 <nmessenger> @vote cheeky-off GoddammitYes!
12:56:18 <lambdabot> "GoddammitYes!" is not currently a candidate in this poll
12:56:22 <glguy> instance  Monad Maybe  where (Just x) >>= k      = k x Nothing  >>= _      = Nothing
12:56:25 <glguy> that makes sense
12:56:32 <glguy> Monad is a class of type constructors
12:56:37 <glguy> I agree with your prof :)
12:56:51 <nornagon> oh, pattern matching
12:56:55 <nornagon> to answer my own question
12:57:04 <paolino> :t modify
12:57:06 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
12:57:30 <fons> Is there a standard function to replace the nth element of a list?
12:57:37 <glguy> no
12:57:51 <chessguy> how many classes of type constructors are there?
12:58:00 <nornagon> ?src CalendarTime
12:58:01 <lambdabot> Source not found. That's something I cannot allow to happen.
12:58:07 <nornagon> ?src System.Time.CalendarTime
12:58:08 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:58:21 <nmessenger> take n xs ++ [replacement] ++ drop (n+1) xs
12:58:25 <nornagon> gr, how does one pattern match on records?
12:58:30 <nornagon> I've forgotten the syntax
12:58:42 <glguy> This { field = x }
12:58:55 <nornagon> ah.
12:59:01 <chessguy> @pl \n xs replacement ->  take n xs ++ [replacement] ++ drop (n+1) xs
12:59:02 <lambdabot> ap (ap . (((.) . (++)) .) . take) ((flip (:) .) . drop . (1 +))
12:59:07 <nmessenger> heh
12:59:09 <chessguy> clearly :)
12:59:29 <fons> pl?
12:59:34 <nornagon> pointless
12:59:34 <nmessenger> clearly pointless :)
12:59:37 <nornagon> aka 'pointfree'
12:59:48 <glguy> > \n x xs -> let (as, _:bs) = splitAt n xs in as ++ x : bs
12:59:50 <lambdabot>  Add a type signature
12:59:52 <nmessenger> aka 'perlish'
12:59:56 <nmessenger> :P
13:00:03 <glguy> ?pl \n x xs -> let (as, _:bs) = splitAt n xs in as ++ x : bs
13:00:04 <lambdabot> (line 1, column 16):
13:00:04 <lambdabot> unexpected "("
13:00:04 <lambdabot> expecting natural, identifier or "in"
13:00:04 <fons> heheh
13:00:20 <glguy> I don't know why I thought that would work :)
13:00:52 <bos> @src (>>=)
13:00:52 <lambdabot> Source not found. stty: unknown mode: doofus
13:01:03 <bos> @src (>>=) :: Either a b
13:01:04 <lambdabot> Source not found. My mind is going. I can feel it.
13:01:27 <nmessenger> @src Either (>>=)
13:01:27 <lambdabot> Left  l >>= _ = Left l
13:01:28 <lambdabot> Right r >>= k = k r
13:01:35 <glguy> ?pl \n x xs -> (\ a -> fst a ++ x : tail (snd a)) (splitAt n xs)
13:01:36 <lambdabot> flip ((.) . liftM2 (++) fst . (. (tail . snd)) . (:)) . splitAt
13:01:44 <chessguy> how many classes of type constructors are there?
13:02:39 <glguy> chessguy: how many first names are there?
13:02:55 <chessguy> glguy, i mean standard ones, obviously
13:02:56 <xerox> fons: it's a wonderful theorem in action, as you see it converts an expression with arguments into a combinator. Sometimes it has found beautiful results.
13:03:07 <chessguy> Monad, Functor, what else?
13:03:22 <glguy> 16 at least in Haskell98
13:03:43 <chessguy> glguy, where did you get that?
13:03:43 <glguy> Eq Show Read Ord Num Bounded Enum Real Fractional Integral RealFrac Floating Monad RealFloat MonadPlus Functor
13:03:57 <chessguy> ?src Eq
13:03:58 <lambdabot> class  Eq a  where
13:03:58 <lambdabot>     (==), (/=)   :: a -> a -> Bool
13:04:12 <chessguy> oh
13:04:22 <chessguy> so Monad isn't any different from any other type constructor
13:04:46 <nmessenger> a *specific* type in the Monad class isn't any different...
13:04:56 <xerox> Monad is not a type constructor, and Eq isn't a class of type constructors, but of types.
13:05:21 <chessguy> ?src Monad
13:05:22 <lambdabot> class  Monad m  where
13:05:22 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:05:22 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:05:22 <lambdabot>     return      :: a -> m a
13:05:22 <lambdabot>     fail        :: String -> m a
13:05:25 <nmessenger> "type constructor" just means type that takes other types as parameters
13:05:41 <xerox> nmessenger: ... and produces types.
13:06:00 <nmessenger> @kind Int
13:06:00 <chessguy> ok, so clearly all those that glguy just cited aren't all classes of type constructors, but some are classes of just types
13:06:01 <lambdabot> *
13:06:03 <nmessenger> @kind Maybe
13:06:04 <SamB> so, Eq is as much a class of type constructors as () is a function
13:06:05 <lambdabot> * -> *
13:06:07 <nmessenger> @kind Maybe Int
13:06:09 <lambdabot> *
13:06:43 <Eelis> what must i import to get the  Functor ((->) r)  instance? or better yet: how is one expected to find this information? the instance is listed in the prelude documentation on haskell.org, but is as far as i can see not actually part of the prelude
13:06:53 <xerox> Eelis - Control.Monad.Instances
13:07:18 <Eelis> ah, thank you.
13:07:43 <xerox> You're welcome.
13:08:08 <litb> hi!
13:08:10 <glguy> chessguy: you wanted the list of Arrow, Functor, Monad, MonadPlus?
13:08:12 <Saizan> everytime i define a typeclass i end up in multiparameter and undecidable instances..
13:08:26 <nmessenger> litb: greetings and salutations!
13:08:30 <glguy> hello
13:08:34 <hpaste> hello
13:08:51 <litb> is this channel only for haskell qquestions? i have a questions about time complexity about an algorithm
13:08:52 <nmessenger> hpaste: how come you don't talk more?
13:09:01 <hpaste> hello
13:09:03 <Eelis> is lambdabot capable of locating instance declarations?
13:09:12 <nmessenger> @instances Functor
13:09:13 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:09:18 <litb> i'm aware of dont-ask-to-ask but i'm frankly :)
13:09:24 <Eelis> nmessenger: that's listing, i want locating :)
13:09:33 <xerox> Saizan: you should use functional dependencies
13:09:56 <Saizan> mmh
13:09:58 <chessguy> glguy, if i knew what list i wanted, there wouldn't be much point in asking for it :)
13:10:03 <chessguy> ?src MonadPlus
13:10:04 <lambdabot> Source not found. Take a stress pill and think things over.
13:10:10 <xerox> Saizan: that way, some parameters uniquely choose other parameters.
13:10:57 <oklopol> hmm, is x :: Int -> Int haskell for declaring a function x?
13:11:06 <xerox> Eelis: yeah. ?src Maybe (>>=)
13:11:07 <nmessenger> oklopol: yep
13:11:26 <nmessenger> oklopol: it's type, at least.  You'd still need to define it.
13:11:29 <oklopol> good, i seem to have adapted some skill then
13:11:30 <oklopol> i know
13:11:41 <chessguy> ?instances MonadPlus
13:11:42 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
13:11:45 <oklopol> but, it didn't work on the ghci
13:11:46 <Eelis> xerox: that still doesn't reveal the module, i'm afraid
13:12:00 <oklopol> but i'm using the command line thingie, maybe that's why?
13:12:08 <xerox> Eelis: most are easy to guess.
13:12:12 <nornagon> gr, is there any way to get the current week of the year?
13:12:26 <xerox> Anyway, there is ?docs which lists them all.
13:12:31 <nornagon> i guess i could just get the ctYDay and divide by 7
13:12:43 <xerox> ?docs Control.Monad
13:12:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
13:12:56 <Eelis> xerox: true. Control.Monad.Instances was sort of a non-obvious one since Functors aren't particularly related to Monads, but in general i manage to find things pretty quickly
13:12:58 <nmessenger> oklopol: you can use 'let' to define local names in ghci
13:13:19 <nmessenger> let f :: Int -> Int; f 1 = 2; f 3 = -37; f x = x * 2
13:13:23 <glguy> typically "x :: Int -> Int" can be inferred and doesn't need to be explicitly specified
13:13:23 <oklopol> not in scope 'x'
13:13:35 <oklopol> it says with or without let
13:13:59 <nmessenger> @wiki Haskell_in_5_steps
13:14:00 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
13:14:00 <xerox> Eelis: it might also help to know that ((->) e) is actually the Reader monad. newtype Reader e a = Reader { runReader :: e -> a } so it's really in Control.Monad.Reader.
13:14:10 <nmessenger> ^^ with show you how to get started writing stuff
13:14:14 <glguy> oklopol: it's a lot better to define these in a file, have that file with GHCi and reload that file with the ":" command
13:14:15 <nmessenger> will*
13:14:20 <fasta> nornagon: date +%U works on Linux
13:14:34 <glguy> ?docs System.Time
13:14:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
13:14:54 <oklopol> glguy i don't like using another editor too
13:15:03 <oklopol> just the console would be nice: \
13:15:15 <oklopol> if i could make progs in it
13:15:20 <glguy> oklopol: well, then you are introducing your own artificial constraints :-/
13:15:33 <nmessenger> you could :! cat > Main.hs
13:15:35 <glguy> and you can't save functions defined in ghci
13:15:35 <nmessenger> :P
13:15:40 <oklopol> i might be, yes
13:15:48 <glguy> well, good luck then :)
13:16:03 <glguy> formats calendar times using local conventions and a formatting string. The formatting string is that understood by the ISO C strftime()  function.
13:16:09 <glguy> formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
13:16:15 <glguy> %U ought to work
13:16:32 <fasta> glguy: hmm, I didn't know that function
13:16:32 <jeroeng> dblhelix: Would it be (necessary/handy) for me to be at the lecture tomorrow morning?
13:16:40 <xerox> oklopol: Emacs has got haskell-mode which let you interact with the interpreter nicely.
13:16:55 <fasta> glguy: It's easy to miss.
13:17:04 <oklopol> i have windows
13:17:10 <oklopol> emacs is a linux thingie?
13:17:13 <xerox> That's unimportant.
13:17:33 <fasta> oklopol: It runs a dozen of OS's.
13:17:36 <nmessenger> oklopol: what editor do you usually use?
13:17:39 <fasta> oklopol: er on
13:17:47 <fasta> oklopol: including this thing called Windows.
13:18:01 <oklopol> depends on the purpose
13:18:05 <oklopol> edit.exe often
13:18:08 <oklopol> or notepad
13:18:09 <dblhelix> jeroeng: I'm quite sure that you already know the stuff that's taught at the lecture... and the exercises in the afternoon are simple enough to guide without having visited the lecture...
13:18:20 <fasta> notepad FTW :P
13:18:28 <oklopol> python luckily supports direct use from the ide
13:18:33 <oklopol> with a command lie
13:18:34 <oklopol> *line
13:18:39 <nmessenger> notepad'll work, though *I* wouldn't want to use it.
13:18:43 <oklopol> so i don't have to store files etc
13:18:48 <jeroeng> dblhelix: allright then. I just saw your mail, I'll read it right away
13:19:13 <glguy> fmap (formatCalendarTime defaultTimeLocale "%U")$  toCalendarTime =<< getClockTime
13:19:31 <dblhelix> jeroeng: okay, I head for bed now... I've a long day ahead
13:19:35 <glguy> "06"
13:19:59 <glguy> (that line requires System.Time and System.Locale)
13:20:09 <jeroeng> dblhelix: Sleep well then, thansk for all the good advice today :)
13:20:16 <xerox> dblhelix: what are these lecture and exercises?
13:20:19 <glguy> oklopol: Visual Haskell might be more what you are looking for
13:20:28 <nmessenger> oklopol: try 'let square x = x * x' in ghci
13:20:29 <glguy> oklopol: if you have VS.NET 2003 or VS 2005
13:20:30 <dblhelix> jeroeng: you're welcome... cu tomorrow
13:20:37 <nmessenger> oklopol: then 'square 5'
13:20:40 <SamB> glguy: why would he have either of those?
13:21:04 <glguy> SamB: Umm. because he uses windows, and VS 2005 is a free download
13:21:06 <dblhelix> xerox: I'm a TA in doaitse's FP course... jeroeng is a student assistant in that course
13:21:14 <xerox> Oh nice.
13:21:24 <SamB> glguy: oh right
13:21:37 <nmessenger> but the free version doesn't support plugins (like Visual Haskell)
13:21:44 <glguy> it doesn't?
13:21:45 <glguy> :(
13:21:50 <nmessenger> it *didn't*
13:22:04 * nmessenger doublechecks
13:22:05 <oklopol> heyyy it works, nmessenger :DD
13:22:09 <Binkley> getting VS is easy. just befriend somebody who works for microsoft
13:22:20 <glguy> I've got an MSDN subscription, so I haven't played with the Express editions
13:23:34 <nmessenger> oklopol: awesome, now: let fac x = case x of {0->0; 1->1; x -> fac (x-1) + fac (x-2)}
13:24:13 <astrolabe> hmmm. fac is an odd name for that
13:24:37 <oklopol> fib
13:24:38 <dino-> More like fib, eh?
13:24:39 <glguy> fibonacci a. c.
13:24:40 <nmessenger> oops, switched my standbys (:
13:25:10 <oklopol> fac is  let fac x = case x of {0->1; 1->1; x -> x * fac (x-1)} ?
13:25:20 <glguy> lol, who put "we know when to use callCC!" in the topic
13:25:31 <nmessenger> dons, check today's logs
13:26:10 <nmessenger> oklopol: you're on the ball! (though the 1->1 case isn't necessary)
13:26:10 <oklopol> OMG it worked :DDD
13:26:49 <ejt> is there a lambdabot command to tell me what classes a data type is an instance of ?
13:26:54 <xerox> oklopol: now :m + Control.Monad.Fix and fix ((1:) . scanl (+) 1) -- (:
13:26:57 <nmessenger> ejt: nope
13:27:00 <vincenz> oklopol: the 1 is redundant
13:27:01 <bringert> SyntaxNinja: I'm thinking of implementing a log-structured file system in Haskell
13:27:03 <oklopol> i just don't get the $ thing... prolly something to do with lisp's `
13:27:09 <chessguy> ?instances Int
13:27:11 <lambdabot> Couldn't find class `Int'. Try @instances-importing
13:27:14 <vincenz> bringert: what is a log-structured fs exactly
13:27:21 <chessguy> ?instances-importing Int
13:27:23 <lambdabot> Couldn't find class `Int'. Try @instances-importing
13:27:34 <oklopol> i know it's redundant, i just used copypaste :D
13:27:36 <xerox> (chessguy: Int is not a class.)
13:27:42 <glguy> nmessenger: I was there when it happened apparently (my example inspired the phrase) I just didn't see the topic change :)
13:27:45 <bringert> vincenz: all writes are done sequentially to the disk
13:27:45 <nmessenger> some long function definition $ big argument exp = (some long function definition) (big argument exp)
13:27:54 <chessguy> xerox, ii know
13:27:56 <bringert> vincenz: so files move on every write
13:28:00 <xerox> oklopol: f $ x = f x  it's just function application
13:28:05 <chessguy> i thought instances did what ejt wanted
13:28:06 <vincenz> bringert: and then?
13:28:16 <chessguy> but i had it backwards
13:28:18 <glguy> > ($ 5) (*2)
13:28:19 <lambdabot>  10
13:28:23 <vincenz> bringert: what if you reach the end?
13:28:24 <bringert> vincenz: this is meant to improve write performance, since the current large caches make most reads fast
13:28:34 <nmessenger> f $ g $ h $ j $ x = f (g (h (j x))) -- saves parens
13:28:35 <bringert> vincenz: you garbage collect
13:28:42 <vincenz> bringert: and what if you have fragmentation?
13:28:52 <fasta> How can I install Debug.QuickCheck in ghc-6.6?
13:28:55 <bringert> vincenz: and you keep an index of where all the files are sitting, so you know where to read from
13:28:56 <glguy> f . g . h . j $ x     -- I've got your back , Cale
13:29:01 <nmessenger> heh
13:29:03 <xerox> oklopol: the nice thing is that binds with a lower precendence than normal function application, so you can do f . g . h $ x
13:29:11 <nmessenger> @quote \(\$\)
13:29:11 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
13:29:15 <bringert> vincenz: you do copying garbage collection to avoid fragmentation
13:29:20 <vincenz> bringert: but I guess the log-structure must be written somewhere as well?
13:29:23 <vincenz> bringert: oh I see... incrementally?
13:29:51 <bringert> right, it's reasonable to divide the disk into segments, and write each segment sequentially
13:30:02 <glguy> man... the channel is *active* today
13:30:04 <glguy> ?losers
13:30:04 <lambdabot> Maximum users seen in #haskell: 322, currently: 319 (99.1%), active: 54 (16.9%)
13:30:06 <vincenz> bringert: ah cool, thanks for the info :)
13:30:14 <glguy> ?where stats
13:30:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
13:30:17 * vincenz wonders when you GC however.
13:30:17 <xerox> 322.. whew
13:30:20 <bringert> then when you are running out of free segments, you go through some of them and copy the live stuff to new logs
13:30:30 <fasta> 300 bots, surely ;)
13:30:40 <vincenz> bringert: what if you have files with a size > than a segment?
13:30:53 <bringert> vincenz: use multiple segments
13:31:00 * vincenz nods
13:31:05 * vincenz ponders
13:31:11 * glguy frowns
13:31:19 * glguy wanders
13:31:19 * nmessenger explodes!
13:31:24 * vincenz ops and kicks
13:31:29 <bringert> the index might have to take that into account, I can't remember
13:31:32 * nmessenger stops quickly
13:31:49 --- mode: ChanServ set +o hpaste
13:31:58 <dino-> oo, I didn't know that about the f . g $ x
13:32:00 <dino-> neato
13:32:03 <hpaste> prepare to die!
13:32:16 <nmessenger> > "aah!" >>= replicate 5
13:32:18 <lambdabot>  "aaaaaaaaaahhhhh!!!!!"
13:32:26 <bringert> I was thinking that a tar file + an index could be used to implement a log-structured file system
13:32:47 <bringert> droundy gave me the idea when he suggested that darcs could use a tar file for the pristine cache
13:32:47 --- mode: ChanServ set +o glguy
13:32:50 --- mode: glguy set -o hpaste
13:32:53 --- mode: glguy set -o glguy
13:33:05 <reilly> are we under attack by pastebots?
13:33:28 <dino-> reilly: Ah, no talking about it. You'll just embolden the pastebots.
13:33:30 <vincenz> bringert: sounds interesting...why not a zip file?
13:33:39 <chessguy> ?remember nmessenger [hpaste] prepare to die! [nmessenger]  > "aah!" >>= replicate 5
13:33:40 <lambdabot> Done.
13:33:52 <vincenz> bringert: afaik they have individually accessible entries
13:33:53 <bringert> vincenz: because I have implemented tar in haskell already :-)
13:33:55 <fasta> I am willing to fix something in darcs, but for that I need to be able to build it first.
13:33:56 <nmessenger> :)
13:34:03 <vincenz> bringert: but tars aren't compressed
13:34:11 <Cale> Embolden is such a funny word. It seems to have been overused by the US government lately.
13:34:25 <fasta> Anyone willing to tell me how I can get Debug.QuickCheck is ghc-6.6 or how to build it otherwise?
13:34:27 <bringert> vincenz: tar files can be written incrementatlly
13:34:34 <bringert> fasta: what's the problem?
13:34:46 <vincenz> Cale: yes, sort of like embossed
13:34:55 <fasta> bringert:  checking for module Debug.QuickCheck( quickCheck )... no; and neither in package QuickCheck
13:34:56 <oklopol> is (a, b, c) an array?
13:34:56 <fasta> configure: error: Cannot find Debug.QuickCheck; try installing package quickcheck?
13:34:59 <dino-> And emblazoned.
13:35:14 <glguy> emphatic
13:35:20 <vincenz> glguy: you're missing the b
13:35:20 <bringert> fasta: ah, it's called Test.QuickCheck these days
13:35:26 <fasta> bringert: The actual problem I am willing to solve is:  darcs: <stdin>: hSetBuffering: unsupported operation (Illegal seek)
13:35:42 <fasta> bringert: Yes, I know how it's called these days.
13:35:45 <bringert> I get that when I hit 'y' too quickly
13:35:49 <fasta> bringert: Me too
13:35:51 <glguy> vincenz: :(
13:35:52 <oklopol> (1, 2, 3, 4) seems to be *SOMETHING* but !! won't work at least
13:35:56 <fasta> bringert: I want to fix it.
13:35:58 <glguy> EMBROILED!
13:36:01 <vincenz> glguy: embarassed
13:36:01 <fasta> bringert: On Linux at least.
13:36:14 <nmessenger> oklopol: it's a a 4-tuple, !! works on lists
13:36:17 <vincenz> oklopol: (1,2,3,4) is a tuple, tuples aren't indexable
13:36:29 <bringert> fasta: QuickCheck-1.0 seems to have it: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck-1.0
13:36:32 <lambdabot> http://tinyurl.com/225ea7
13:36:35 <oklopol> really? tuples are fast to index, seems weird
13:36:38 <glguy> embellish?
13:36:39 <bringert> fasta: try cabal-install install QuickCheck
13:36:41 <fasta> bringert: According to the wiki they "support" GHC-6.6
13:36:47 <glguy> embezzle!
13:36:48 <oklopol> (i'm c++ :P)
13:36:54 <fasta> bringert: ok, I am not sure whether I have cabal-install
13:36:54 <dino-> embargo
13:37:04 <glguy> embitter >:-/
13:37:05 <fasta> bringert: nope
13:37:11 <nmessenger> oklopol: you can pass it to an anonymous function to deconstruct it:
13:37:13 <fasta> bringert: Can I get it as deb?
13:37:13 <nmessenger> >  (\(_,x,_,_) -> x) (1,2,3,4)
13:37:15 <lambdabot>  2
13:37:15 <vincenz> oklopol: wow, you're big and hairy
13:37:23 <hpaste> emblematicize
13:37:24 <bringert> fasta: the QuickCheck package I have installed has Debug.QuickCheck
13:37:24 <fasta> bringert: cabal-install, that is.
13:37:31 <dino-> oklopol: The items in a tuple don't have to be the same type. Not so for lists.
13:37:35 <bringert> fasta: no that I know
13:37:50 <oklopol> is there a fast-index thingie?
13:37:58 <bringert> fasta: so you have the QuickCheck package installed, but there is no Debug.QuickCheck?
13:37:59 <nmessenger> @src fst
13:37:59 <glguy> vincenz: last one,  I promise :) dis-embowelled
13:37:59 <lambdabot> fst (x,_) =  x
13:38:01 <fasta> @where cabal-install
13:38:02 <lambdabot> I know nothing about cabal-install.
13:38:02 <dino-> The tuple is like making a little 'struct' of possibly disparate things.
13:38:06 <nmessenger> that works on 2-tuples
13:38:17 <bringert> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
13:38:18 <lambdabot> Title: CabalInstall - Hackage - Trac
13:38:21 <nmessenger> you usually want to patten-match tuples
13:38:26 <bringert> @where+ cabal-install http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
13:38:26 <nmessenger> pattern*
13:38:26 <lambdabot> Done.
13:38:44 <fasta> bringert: I have QuickCheck-1.0 installed
13:38:50 <fasta> bringert: But also QuickCheck-2.0
13:39:11 <bringert> fasta: ah, so you are getting QuickCheck-2.0 which doesn't have Debug.QuickCheck
13:39:22 <bringert> fasta: try ghc -package QuickCheck-1.0 ...
13:39:38 <fasta> bringert: ok, I will hack the MakeFile.
13:39:52 <bringert> fasta: or hide QuickCheck 2.0
13:40:00 <fasta> bringert: how do I hide it?
13:40:03 <bringert> ghc-pkg hide QuickCheck-2.0
13:40:08 <bringert> iirc
13:40:40 <bringert> hmm, that might not work if the Makefile uses the -package flag
13:40:43 <bringert> not sure
13:40:45 <nmessenger> oklopol: a tuple can be seen kinda like a C struct, i.e. a bunch of values grouped together as a whole
13:40:46 <oklopol> how do i take a sublist? is there something like takeFromTo <beginning> <end> <list>
13:41:00 <bringert> oklopol: use take and rop
13:41:04 <bringert> drop
13:41:14 <fasta> bringert: problem persists
13:41:19 <nmessenger> > take 5 (drop 2 ([1..20]))
13:41:21 <lambdabot>  [3,4,5,6,7]
13:41:21 <SamB> take (end-beginning) . drop beginning
13:41:32 <oklopol> yeah, the named gave it away
13:41:35 <oklopol> *names
13:41:37 <bringert> fasta: what did you try?
13:42:00 <fasta> bringert: ghc-pkg-6.6 hide QuickCheck-2.0
13:42:14 <oklopol> take 3 $ drop 4 [2,4,3,6,4,8,5,7,54,6,32] haha i figured that out!
13:42:25 <bringert> yeah, I relalized that probably doesn't help if the Makefile uses -package
13:42:34 <nmessenger> awesome!  ($) is odd-looking, but sometimes handy
13:42:41 <bringert> try changing to -package QuickCheck-1.0
13:43:00 <fasta> Where's the MakeFile? All I see is a configure script.
13:43:30 <oklopol> i've used almost the same thing in my own APL kinda lang... but haskell has it all :\
13:43:51 <bringert> fasta: what is this? the darcs quickcheck properties?
13:44:16 <nmessenger> the cool thing about Haskell operators is that they're ordinary functions.  You can write your own or even redefine 'em.
13:44:20 <fasta> bringert: I have no idea
13:44:43 <bringert> fasta: but what are you trying to compile / run?
13:44:48 <nmessenger> > let (+) = (Prelude.*) in 3 + 5
13:44:49 <lambdabot>  15
13:44:57 <fasta> bringert: I am trying to compile the whole thing.
13:45:10 <fasta> bringert: It should be a matter of 5 minutes.
13:45:12 <bringert> fasta: what whole thing?
13:45:16 <fasta> bringert: darcs
13:45:25 <bringert> sh
13:45:27 <bringert> ah
13:45:29 <fasta> bringert: I want to see whether it's already fixed.
13:45:42 <fasta> bringert: if it's not I fix it, unless this takes much longer.
13:45:52 <bringert> fasta: easiest might just be to uninstall QuickCheck-2.0 for now
13:46:04 <bringert> I've gotta go
13:46:06 <bringert> good luck
13:46:17 <fasta> I can't use that solution...
13:47:33 <fasta> It doesn't seem like darcs wants to have developers. Imho, if you want people to develop your code, you make sure it's trivial to build.
13:50:26 <olliej> Binkley: ping?
13:52:08 <chessguy> Cale, you still here?
13:52:26 <Cale> yeah?
13:52:45 <chessguy> you've seen the haskell lecture videos from ltu, right?
13:52:53 <Cale> which ones?
13:53:03 <chessguy> there's more than one set?
13:53:23 <chessguy> i'm talking about the ones linked here: http://lambda-the-ultimate.org/node/1303
13:53:25 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
13:53:50 <Cale> ah, yes, I've seen those, though I didn't find them through ltu
13:53:52 <Binkley> olliej: pong
13:54:14 <olliej> Binkley: my thesis has now been exxamined! the day after i said it hadn't been
13:54:15 <olliej> woo!
13:54:23 <Cale> They're unfortunately kind of boring.
13:54:41 <chessguy> i just finished the lecture on monads. it sounds like the rest is pretty much on how to implement haskell, as opposed to write in haskell?
13:54:53 <Cale> Though maybe they get better, I didn't see them all.
13:55:14 <Cale> Well, he basically goes through the whole syntax of the language.
13:55:25 <dibblego> aren't they 700MB each?
13:55:35 <chessguy> they're big, yeah
13:55:35 <Cale> I'm not sure if they end up implementing it. I should download them now that I have a fast link.
13:55:48 <dibblego> the quantity scared me away - can you recommend one in particular?
13:55:59 <Cale> You have to get the high quality version if you want to have a chance of reading the blackboard.
13:56:04 <defcon8> hello. trying to compile ghc but it said ghc required
13:56:06 <defcon8> ghc is*
13:56:11 <defcon8> isn't this a bit paradoxical?
13:56:18 <monochrom> No.
13:56:22 <defcon8> unless bootstrapping from .hc files or something
13:56:23 <Cale> defcon8: no, it's normal
13:56:30 <monochrom> gcc would also say "gcc required"
13:56:31 <chessguy> i'm trying to decide if i want to bother watching the rest
13:56:34 <Syzygy-> defcon8: You'll want a binary ghc, or if it isn't available, you'll need to bootstrap.
13:56:39 <Cale> defcon8: Usually compilers are written in the language which they compile.
13:56:47 <defcon8> how do I bootstrap?
13:56:52 <chessguy> which came first, the compiler or the code?
13:56:56 <Cale> defcon8: Have you got a *really* good reason to want to compile GHC?
13:56:58 <sjanssen> defcon8: what's your platform?
13:57:05 <defcon8> Cale, oh sorry, thought they were mostly written in C (not sarcastic or anything)
13:57:07 <defcon8> sjanssen, cygwin
13:57:12 <defcon8> Cale, yeah, cygwin
13:57:16 <monochrom> Of course, it is paradoxical, for those uninitiated in the daily business of computer science.
13:57:20 <Cale> defcon8: You don't want to compile GHC. :)
13:57:27 <defcon8> okay
13:57:31 <defcon8> what should I do?
13:57:31 <sjanssen> defcon8: do you really want cygwin, or is a Windows binary okay?
13:57:32 <nmessenger> C is written in C, usually
13:57:41 <dino-> I've been told, for new platforms who will be getting ghc for the first time, the ghc is compiled elsewhere into C source and then massaged on the target platform.
13:57:43 <defcon8> sjanssen, I want to be able to get access from school and I've figured how to use ssh there
13:58:02 <nmessenger> dino-: sounds ugly
13:58:23 <dino-> nmessenger: But I guess there's no other way since it's written in Haskell.
13:58:24 <sjanssen> I'm no cygwin/windows guru, but I think you can access normal windows command line apps from cygwin
13:59:12 <sjanssen> defcon8: so I recommend installing the standard windows version of ghc, and then figure out how to run it from cygwin
13:59:13 <chessguy> i do like these lectures because he's very thorough and precise, though it does get a little tedious sometimes
13:59:24 <defcon8> sjanssen, hrmm
13:59:25 <dino-> sjanssen: That should be true, yeah. defcon8: I would install the Windows ghc and try to use that from cygwin's shell.
13:59:28 <Cale> Bootstrapping is not somehting you probably want to do unless you're a GHC hacker already.
13:59:32 <defcon8> how?
13:59:54 <Binkley> Cale: or unless you want to become a GHC hacker
14:00:03 <dino-> defcon8: You have no Haskell at all yet on your Windows box?
14:00:15 <nmessenger> http://haskell.org/ghc/download_ghc_66.html#windows
14:00:16 <lambdabot> Title: GHC: Download version 6.6
14:00:19 <defcon8> dino-, I do
14:00:20 <Philippa> Binkley: that seems like more have than want. How's the yak?
14:00:44 <Binkley> olliej: congrats! (Sorry, got distracted)
14:00:55 <olliej> Binkley: :D
14:00:55 <Binkley> Philippa: well, mind you, *I* never wanted to become a GHC hacker. it just happened
14:01:03 <Binkley> and as for the yak, I got lambdabot to build!
14:01:05 <dino-> In you cygwin shell, what happens when you try: ghc --version
14:01:06 <Binkley> why I wanted to, I'm not sure
14:01:33 <defcon8> dino-, I guess I'll just copy the ghc dir into one of cygwin's folders and see what happens
14:01:36 <dino-> I'm vaguely envisioning executable path problems now. But to be honest, I purged my life of all Windows 4 years ago.
14:01:49 <dino-> defcon8: You don't need to do that.
14:01:55 <monochrom> /ghc-6.6/bin/ghc --version
14:01:55 <Philippa> GOA?
14:02:01 <Philippa> I mean, I'd be tempted to try that sometime
14:02:04 <defcon8> dino-, what do I do?
14:02:12 <dino-> defcon8: I believe there's a system to how the C drive paths are exposed in the cygwin.
14:02:21 <gotaku> Weird, Anna Nicole Smith is dead.
14:02:24 <Binkley> actually, I just wanted to read the quotes file
14:02:30 <defcon8> dino-, nvm
14:02:34 <defcon8> I'll look into it
14:02:43 <nmessenger> gotaku: off-topic but *really*??!
14:02:48 <defcon8> goban, who the hell is that?
14:02:52 <Binkley> nmessenger: apparently so. google news
14:03:01 <dino-> defcon8: But it may be better to add the ghc bin dir to your executable search path.
14:03:01 <Binkley> defcon8: she's someone who probably never got to learn what a monad is
14:03:02 <Binkley> it's a pity
14:03:06 <gotaku> I know it's off-topic but I just heard it on cnn
14:03:12 <monochrom> windows is really a poor environment for studying computers.  it's only good for babysitting and "wow".
14:03:20 <defcon8> Binkley, how sad!
14:03:29 <glguy> monochrom: that's WoW to you!
14:03:31 <Binkley> monochrom: well, I think there are a few people who use it for development
14:03:41 * nmessenger is watching it on local news right now!
14:03:46 * glguy is stuck doing .NET dev on a winbox
14:03:58 <Philippa> also, windows is plenty good for examining what legacy issues do to a system
14:04:09 <tibbe> I currently use emacs and haskell-mode for development. Is there any tools/emacs-plugins that could help development?
14:04:18 <monochrom> there are always a few people using poor environments for ____
14:04:23 <Philippa> *nix is better for learning about building stuff generally because the guys're more accessible
14:04:23 <Binkley> tibbe: grep is my favorite haskell development tool :-)
14:04:47 <SamB> Binkley: funny
14:04:49 <defcon8> EMACS!
14:04:51 <Philippa> it's not a particularly poor environment for a lot of development, and it's still a preferred one for eg PC-targetted gamedev
14:04:55 <SamB> it is my favorite ASM and C development tool!
14:04:56 <nmessenger> 39 years, jeez
14:05:04 <Binkley> it's not so much funny as true
14:05:07 <Nafai> tibbe: If you are using GHC 6.6, this looks interesting: http://shim.haskellco.de/trac/shim
14:05:08 <lambdabot> Title: shim - Trac
14:05:31 <defcon8> dino-, wow, it works
14:05:58 <tibbe> Binkley, oh :) for what do you use it most?
14:06:06 <dino-> defcon8: Awesome.
14:06:16 <Binkley> tibbe: I use it to figure out where functions are defined
14:06:23 <Binkley> I mean, I know IDEs can do that, at least for other languages I've used
14:06:27 <Binkley> but it never works right
14:06:34 <tibbe> ok
14:06:43 <sjanssen> Binkley: every try hasktags?
14:06:49 <sjanssen> s/every/ever
14:06:51 <Cale> hmm... this looks like it might work: http://www.haskell.org/ghc/dist/stable/dist/ghc-6.6.20070208-i386-unknown-mingw32.tar.bz2
14:06:54 <lambdabot> http://tinyurl.com/23tucs
14:07:07 <Binkley> sjanssen: I've heard of it, but I just can't bring myself to spend the time installing more things
14:07:31 <sjanssen> Binkley: I think hasktags is packaged with ghc
14:07:46 <Binkley> or not so much "installing more things" as "figuring out how to use more things"
14:08:32 <sjanssen> I run: hasktags --both */**.hs
14:09:02 <sjanssen> I mean, hasktags --both **/*hs
14:09:22 <sjanssen> then you use your editor's tags support
14:09:31 <audreyt> usually I just use ghci
14:09:36 <audreyt> then :ctags
14:09:38 <dino-> sjanssen: Cool, I didn't know hasktags existed.
14:09:54 <audreyt> echo ":ctags" | ghci YourCodeHere.hs
14:10:05 <audreyt> ditto for :etags / haskell
14:10:32 * allbery_b stillwants cscope for haskell :/
14:10:34 <audreyt> echo ":etags" | ghci YourCodeHere.hs
14:10:38 <audreyt> (builds emacs tags)
14:24:50 <bos> @pl \ds -> 10 - (sum (zipWith (*) (reverse ds) (cycle [3,1])) `mod` 10)
14:24:50 <lambdabot> (-) 10 . (`mod` 10) . sum . flip (zipWith (*) . reverse) (cycle [3, 1])
14:25:05 <bos> ugh.
14:25:11 <chessguy> hm, i thought haskell hadn't been formally defined in denotational semantics
14:25:38 <bos> it hasn't.
14:25:57 <shapr> audreyt: I just use hasktags **/*hs~_darcs
14:27:02 <tibbe> shapr, please excuse my ignorance, what does hasktags do?
14:27:17 <audreyt> shapr: it doesn't quite work with pugs source code :)
14:27:33 <chessguy> hmm, this prof says he's going to do it
14:27:37 <chessguy> in the lecture
14:27:53 <audreyt> shapr: GADTs, etc.
14:28:37 <gotaku> What prof?
14:28:39 <Binkley> chessguy: if he's going to provide a denotational semantics for full haskell, well... he has his task cut out for him :-)
14:28:47 <Binkley> perhaps he's going to give the semantics for a simpler core language?
14:28:52 <chessguy> Geisl, it's in the video  lecture
14:29:07 <gotaku> The german guy?
14:29:22 <chessguy> yes
14:29:53 <dino-> tibbe: It creates ctags/etags data for Haskell source code.
14:30:05 <gotaku> chessguy: I stopped watching them at that point... I had trouble understanding.
14:30:13 <tibbe> dino-, how do i use those in emacs and where are they stored?
14:30:35 <chessguy> well, i'm not going to try to grok everything, but i think it's be good to have a listen
14:30:44 <chessguy> besides, i need something to listen to while i'm pretending to work
14:30:55 <dino-> I'm not an emacs user, but somebody here must know this.
14:31:55 <cjeris> tibbe: IIRC, for ctags, they're stored in the current directory, and you can go to a tag definition with M-.
14:32:15 <gotaku> chessguy: Although from what I did watch, now I know what bottom and strictness mean.
14:32:33 <quicksil1er> tibbe: M-x visit-tags-table
14:32:37 <chessguy> ?quote bottom
14:32:38 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
14:32:42 <quicksil1er> (to find the tags on the first place)
14:33:15 <gotaku> ?quote _|_
14:33:16 <lambdabot> ghc says: eval_thunk_selector: strange selectee
14:33:23 <tibbe> cjeris, quicksil1er , thanks
14:33:25 <quicksil1er> then M-. to find a definition or M-x tags-search to toa 'multi-file search'
14:34:04 <dino-> Interesting that Exuberant Ctags has Lisp, Scheme even ML but no Haskell yet.
14:34:52 <dino-> Huh, it can do Erlang too. :o
14:35:24 <quicksil1er> are there builtins to 'pad a string to N chars aligning left or right' ?
14:35:36 <ookk> im impressed by this, almost 2x faster than c, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
14:35:37 <quicksil1er> clearly it's not hard to write, just wondering if there was a builtin
14:35:38 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ..., http://tinyurl.com/ncjpk
14:35:39 <ookk> how is it possible?
14:36:03 <quicksil1er> ookk: some things can't be expressed in C
14:36:08 <quicksil1er> ookk: tail recursion, for example
14:36:39 <ookk> quicksil1er, c has for-loops instead
14:38:02 <quicksil1er> @pl (\s -> (replicate (20 - length s) ' ') ++ s)
14:38:03 <lambdabot> (++) =<< flip replicate ' ' . (-) 20 . length
14:38:28 <quicksil1er> ookk: nonetheless I believe there are things you can't express. Maybe I misundersttod something
14:39:25 <quicksil1er> @pl (\n s -> (replicate (n - length s) ' ') ++ s)
14:39:26 <lambdabot> join . ((++) .) . flip flip ' ' . (replicate .) . (. length) . (-)
14:41:34 <sjanssen> the Haskell nsieve program is technically cheating
14:41:47 <ookk> quicksil1er, you should be able to do everything in c that haskell can
14:42:24 <ookk> quicksil1er, what do you mean by cannot express?
14:42:58 <ookk> c is closer to the hardware, you should always be able to exactly controll how something is computed for best performance
14:43:05 <sjanssen> the problem description says "don't use bit flags".  The Haskell program uses IOUArray Int Bool which uses bit flags internally
14:44:08 <sjanssen> Haskell can be compiled to C, therefore C can express everything that Haskell can
14:44:10 <ookk> yeah then that explains it
14:44:32 <ookk> if c also used bitflags it would be faster
14:45:03 <sjanssen> however, it often isn't tractable for a human to write C that approximates Haskell
14:45:17 <sjanssen> ookk: there are benchmarks where Haskell wins fair and square
14:45:34 <ookk> like this one? http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
14:45:35 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
14:46:14 <ookk> sjanssen, yeah haskell programs tend to look far better than c programs
14:46:17 <sjanssen> I see binary-trees, chameneos, cheap-concurrency and sum-file
14:46:50 <ookk> sjanssen, but sometimes haskell looks really ugly when alot om low-level primitives are used to speed up some imperative algorithm
14:47:28 <procyon_> quicksil1er: A program in any turing complete language is tranformable to a program in any other.  There is a proof to such an effect.  Now whether the transformation will be pretty is a completely different question :)
14:47:33 <ookk> haskell wins cheap-concurrency because forkIO doesnt really fork a thread?
14:48:02 <ookk> forkOS would do the same as c does there?
14:48:42 <quicksil1er> procyon_: equivalence is completely not the point
14:48:49 <quicksil1er> procyon_: we're talking about performance here
14:49:21 <ookk> procyon_, the more like assembler the language can become, the better performance
14:49:22 <xerox> quicksil1er: it's a fabulous result, that you can actually translate EVERY lambda term in the SKI calculus. It's quite amazing, due to the people that were trying to find the simplest combinators that entailed all computation (brief explanation, sorry, I ought to go to bed.)
14:49:26 <quicksil1er> sjanssen: I don't accept this logic "Haskell can be compiled to C, therefore C can express everything that Haskell can"
14:49:30 <quicksil1er> xerox: I know this well :)
14:49:34 <ookk> if you can controll exactly what is happening to get best performance
14:49:40 <quicksil1er> equivalence is different from performance
14:49:52 <quicksil1er> sjanssen: well I accept it for 'expression' but not for performance
14:50:05 <quicksil1er> C compilers tie you to a rather straightforward stack + register discipline
14:50:19 <quicksil1er> theoretically a haskell compiler which doesn't use C can bypass this discipline
14:50:29 <quicksil1er> in some cases that may win you some performance
14:50:33 <quicksil1er> (not very much, typically)
14:51:01 <quicksil1er> of course theoretically a different C compiler might not work like that
14:51:06 <quicksil1er> but in practice, the ones we have do
14:51:07 <pejo> ookk, it's very hard to perform partial evaluation on asm. It's a lot easier on some sort of lambda calculus.
14:51:25 <SamB> http://programming.reddit.com/info/u719/comments
14:51:27 <lambdabot> Title: Expressive power of languages: design patterns considered harmful ... (1990) (re ...
14:51:35 <procyon_> ookk: Performance concerns can become intractable to humans in low level languages though.  For instance, C often outperforms assembly because the compiler can align pipes in optimal ways that would be extremely difficult for the programmer to see.
14:51:36 <SamB> quicksil1er: you like that paper, no?
14:51:36 <sjanssen> quicksil1er: ghc's fastest backend is a C generator
14:51:58 <pejo> ookk, so it's not necessarily a good idea to get as close to the metal as possible. (Just look at all dissertations written on alias analysis).
14:52:22 <dibblego> what's the title of that new haskell book?
14:52:31 <ookk> pejo, but for such small tasks as the nsieve, close to the metal would be better i think
14:52:33 <sjanssen> theoretically you could write C code thats a byte array of asm, then cast it to a function pointer and call it :)
14:52:36 <pejo> dibblego, the one by Hutton?
14:52:45 <ookk> pejo, that is why is was supprised that haskell won that benchmark
14:52:47 <dibblego> pejo, maybe, just released
14:52:55 <SamB> sjanssen: if that is the case, why did dons have to turn it off for those four benchmarks?
14:53:09 <quicksil1er> sjanssen: that wouldn't be C though
14:53:16 <procyon_> ookk: I would expect naively written haskell to outperform naively written C on massively parallel systems because C idioms do not encourage parallelization.
14:53:22 <sjanssen> SamB: not always the fastest backend -- but usually
14:53:38 <Pseudonym> Gah, yet another pundit who doesn't grok design patterns.
14:53:41 <quicksil1er> procyon_: only if we had a compiler capable of exploiting implicit parallelism
14:53:45 <dibblego> pejo, that's the one, thanks
14:53:49 <ookk> procyon_, but the haskell code and the c code for nsieve is 1:1
14:53:51 <SamB> Pseudonym: hmm?
14:53:52 <pejo> ookk, what is the task. Is the input known beforehand?
14:53:54 <SamB> pundit?
14:53:57 <ookk> procyon_, they use exactly the sam constructs
14:54:15 <Pseudonym> OK, not a pundit.
14:54:20 <Pseudonym> They got a research quantum out of it.
14:54:20 <ookk> pejo, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
14:54:23 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ..., http://tinyurl.com/ncjpk
14:54:27 <procyon_> ookk: I was talking in general ;)
14:54:31 <Pseudonym> Basically, this boils down to "pattern hypesters are wrong".
14:54:33 <Pseudonym> Well duh.
14:54:41 <SamB> Pseudonym: this was written in 1990
14:54:47 <Pseudonym> They were wrong in 1990, too.
14:54:47 <SamB> at latest
14:54:55 <SamB> well it was less well known
14:55:00 <Pseudonym> True.
14:55:05 <Pseudonym> OK, so he's ahead of the curve.
14:55:18 <Binkley> however, "pattern hypesters are wrong" is something that we here all know, but doesn't seem to have sunk in in the larger world
14:55:22 <Binkley> even after 17 years
14:55:28 <SamB> also... not only does it show how they are wrong, it shows how to correctly argue about the expressiveness of programming languages
14:55:57 <Pseudonym> The thing is, "pattern hypesters are wrong" tends to degenerate into "design patterns are bunk".
14:56:04 <dibblego> Binkley, the prospects are bleak, aren't they?
14:56:05 <Pseudonym> Which is WRONG.
14:56:12 <SamB> Pseudonym: it doesn't say that, though
14:56:19 <Binkley> well, all I know is that one time during a job interview, I got asked "what do you think about design patterns?"
14:56:29 <Binkley> and I sort of gave the "patterns reflect flaws in the language" argument in 1 sentence
14:56:32 <Binkley> and the interviewer was all
14:56:33 <SamB> it says basically that the need for design patterns is undesirable
14:56:37 <Binkley> "huh, never thought of that"
14:56:45 <Binkley> and I thought, "crap, I shouldn't have opened my big mouth"
14:56:56 <pejo> ookk, so the input is statically known. Wouldn't a program specialized to those inputs be much faster than any c implementation that calculates it?
14:57:01 <SamB> Binkley: huh
14:57:03 <Binkley> I don't know about the prospects being bleak, though
14:57:08 <Pseudonym> That argument is appealing, but not every pattern represents a flaw.
14:57:13 <Binkley> perhaps *some* people will eventually realize that massive code bloat is bad
14:57:16 <SamB> Pseudonym: well, no
14:57:23 <Pseudonym> The state monad pattern does not reveal the flaw that Haskell has no mutable global state.
14:57:24 <SamB> but I think it means boilerplate
14:57:37 <dibblego> Pseudonym, which book purports the state monad pattern?
14:57:44 <ookk> pejo, well the whole point of the benchmark is that you shall compute the result using a naive nsieve algorithm
14:57:50 <SamB> like writing the same linked list manipulation code for ten different types of item...
14:57:51 <Pseudonym> dibblego: Sorry, it needs a book?
14:58:01 <Pseudonym> To be a design pattern?
14:58:05 <dibblego> Pseudonym, no, but I think that is the point
14:58:10 <Binkley> the whole point of the state monad is it's not a pattern
14:58:13 <pejo> ookk, but with a strong compiler that could be done offline, and the program would reduce to just printing a long list of them.
14:58:16 <Binkley> you only have to write the code that's specific to your problem
14:58:21 <Binkley> the rest is an abstraction
14:58:23 <SamB> yeah, you can use a real state monad too...
14:58:24 <dibblego> Pseudonym, the paradox is that the 'hypesters' won't recognise it if it doesn't have a book (or some such)
14:58:33 <Binkley> or at least, according to my understand of patterns, it means that you write the same code over and over again
14:58:33 <Pseudonym> The state monad itself isn't a pattern, but the ways to use it are.
14:58:37 <Binkley> rather than just defining it as an abstraction
14:58:42 <Pseudonym> For example, the reader-monad-of-iorefs is a pattern.
14:58:46 <Binkley> maybe I don't understand patterns
14:58:46 <Pseudonym> A common one, in fact.
14:58:55 <SamB> Pseudonym: yes it is
14:58:59 <Pseudonym> The nested-state-monad idiom is a pattern.
14:59:18 <Pseudonym> All patterns to overcome the fact that Haskell doesn't have mutable global state.
14:59:31 <SamB> yeah... but that isn't supposed to be a flaw...
14:59:35 <Pseudonym> Correct.
14:59:38 <dibblego> Pseudonym, you should write a book
14:59:46 <Pseudonym> And the fact that C++ doesn't have SQL embedded isn't a flaw in C++ either.
14:59:50 <SamB> that is on the "feature" list
14:59:55 <SamB> Pseudonym: oh yes it is!
14:59:59 <gotaku> How do I create a pixbuf from a list of pixels in gtk2hs?
15:00:01 <SamB> Haskell has!
15:00:11 <Pseudonym> Haskell does not have SQL embedded!
15:00:24 <SamB> oh?
15:00:27 <Pseudonym> It has an equivalently-powered language provided as an abstraction.
15:00:33 <Pseudonym> In a library.
15:00:35 <SamB> yeah.
15:00:40 <SamB> C++ doesn't have that!
15:00:42 <Pseudonym> That's not the same as embedded SQL.
15:00:44 <Pseudonym> Sure it does.
15:00:56 <Pseudonym> It's just that the abstractions aren't quite as elegant as in Haskell.
15:01:08 <dcoutts> gotaku, you make a Pixbuf and then access the PixbufData
15:01:12 <paolino> which library ?
15:01:25 <dcoutts> gotaku, see the docs for Graphics.UI.Gtk.Gdk.Pixbuf and the fastdraw demo program
15:01:50 <Pseudonym> paolino: Well it doesn't have any that are standard.  Not yet, anyway.  Boost is working on it.
15:02:05 <Pseudonym> But there's SQLAPI++, the DB2 library... bunch of stuff.
15:02:45 <Pseudonym> Now here's the thing:
15:02:48 <Pseudonym> What is a pattern anyway?
15:03:13 <quicksil1er> a solution to a common problem
15:03:16 <Pseudonym> You look through code that clever engineers have written, looking for ways that they solve problems which seem to turn up again and again.
15:03:33 <paolino> something you recognise easily without even understand it
15:03:39 <dibblego> a solution to a common problem, that cannot be abstracted away because mainstream languages are not expressive enough
15:03:40 <Pseudonym> So you define it, you give it a name, and now you can reason about it independently of any particular program.
15:03:48 <quicksil1er> dibblego: not at all
15:03:57 <quicksil1er> dibblego: that's a haskell-hypesters answer
15:04:12 <Pseudonym> Mathematicians do that, too, only they call it "category theory".
15:04:12 <quicksil1er> it's not part of the *definition* of pattern that it exposes language flaws
15:04:19 <quicksil1er> it just happens that they tend to
15:04:35 <quicksil1er> (because a 'common problem' is often an 'abstraction problem with your language')
15:04:39 <dibblego> quicksil1er, I'm referring to the mainstream opinion of what a pattern is
15:04:43 <quicksil1er> but that's not the only kind of common problem
15:05:14 <Pseudonym> Terms like "terminal object", "functor", "adjunction" etc are just terms which describe patterns which show up in maths independent of the particular mathematical structures that exhibit them.
15:05:18 <quicksil1er> haskell has abstraction problems too and oleg has all kinds of solutions to them.
15:05:26 <dibblego> quicksil1er, agreed
15:05:34 <quicksil1er> if more of us were capable of reading what oleg writes, we'd probably call them patterns ;)
15:05:54 <norpan> all programming is abstracting and unless the programming language has all possible programs already written you have to do some abstracting yourself
15:06:33 <Pseudonym> One of the reasons why it's not so obvious that Haskell has patterns is that from their earliest days (even pre-Haskell), most of them were expressible as abstractions.
15:06:36 <Pseudonym> Like "map".
15:07:13 <Pseudonym> It's only in the last few years that C++ programmers have realised that you can have an abstraction that represents "singleton" or "observer".
15:07:14 <paolino> hof vs patterns
15:07:30 * Philippa is tempted to point to the catamorphism as a counterexample
15:07:31 <Pseudonym> Such things can be turned into libraries.
15:08:34 <Philippa> there's a more general pattern that captures something Arrows, Idioms and Monads have in common but isn't arrows, too
15:08:46 <Cale> hehe, typeclasses :)
15:08:57 <Pseudonym> Typeclasses are a good example.
15:09:05 <Pseudonym> When they were introduced, they couldn't express monads.
15:09:21 <paolino> the only good thing of java
15:09:22 <Pseudonym> A pattern developed, it signalled a defect in the language, and now we have constructor classes.
15:09:50 <pejo> quicksil1er, well. There just needs to be one Oleg->English translator around to spread his insights to the rest of the world.
15:09:53 <dibblego> paolino, what good thing is there about Java?
15:09:55 <Philippa> yeah, though as a counterexample we still haven't got a single Ref class
15:09:59 <sorear> constructor classes are still bad - they encourage people to write classes like Monad that force parametricity.
15:10:03 <quicksil1er> pejo: :)
15:10:11 <Philippa> pejo: reading them in order is generally a good start
15:10:11 <paolino> interfaces
15:10:15 <Cale> Philippa: that's not for any *good* reason :)
15:10:23 <Pseudonym> The only good thing of Java is that you can run untrusted code.
15:10:31 <Pseudonym> And that's a VERY good thing, actually.
15:10:35 <Cale> sorear: hm?
15:10:39 <Philippa> Cale: I don't think there's been a single covers-all-cases possibility proposed?
15:10:45 <sorear> Pseudonym: you can do that with haskell and only a little regexing...
15:10:50 <quicksil1er> there are all kinds of nits in the type class system
15:10:55 <quicksil1er> like impredicativity
15:10:56 <sorear> Cale: instance Monad Set
15:11:00 <Cale> Philippa: well, most of the proposals would have been better than nothing
15:11:05 <quicksil1er> and the failure of inference at higher order kinds
15:11:07 <Philippa> sorear: yerwhat? I think your problem is actually that Monad isn't further parameterised
15:11:08 <Pseudonym> sorear: It is a bit hard to install a Haskell compiler in your 1995-era digital set top box.
15:11:18 <quicksil1er> and the terribly sensitivity to the order of parameters
15:11:22 <Cale> sorear: Yeah, that's a hard typing problem though.
15:11:33 <Pseudonym> And 1995's digital set top box is tomorrow's smart card.
15:11:37 <pejo> Philippa, what was your catamorphism an example of?
15:11:56 <sorear> Pseudonym: I think that's mostly a function of closed source
15:11:57 <Philippa> something that's an identifiable pattern without a single abstraction available for it in haskell
15:12:09 <Pseudonym> sorear: No, it's a function of mobile code.
15:12:24 <Pseudonym> You don't want to have to ship the source code over a network just to run it.
15:12:26 <Philippa> Pseudonym: cross-compilers are your friend
15:12:50 <Philippa> though I get your point more generally
15:12:53 <Pseudonym> Today we have proof-carrying code, which I think is a better solution.
15:12:56 <Pseudonym> But in 1995 we didn't.
15:13:10 <SamB> JVMs aren't a good target for much...
15:13:22 <Philippa> except universality
15:13:26 <Philippa> they're pretty good for that by now
15:13:38 <SamB> I don't think I have one!
15:13:52 <Philippa> my washing machine probably doesn't have one, but my next one might
15:13:58 <Pseudonym> BTW, I say this as a former Java enthusiast.  In 1995, I was pretty optimistic about it.
15:14:05 <shapr> me too!
15:14:05 <Pseudonym> But then people used it where they shouldn't.
15:14:13 <shapr> Like php-gtk ...
15:14:14 <Philippa> SamB: do you own a mobile phone?
15:14:28 <SamB> Philippa: no
15:14:40 <Pseudonym> I haven't written any Java since 1998.
15:15:18 <paolino> cobol-java-haskell-....
15:15:52 <paolino> bed
15:16:14 <paolino> nite
15:16:31 <gotaku> I tired java but never really got into it.
15:16:36 <gotaku> tried
15:16:43 <sorear> tired works too :)
15:17:36 <Pseudonym> BTW, dibblego, I actually did start writing a book once.
15:17:41 <Pseudonym> Every now and then I do a little more.
15:17:50 <Pseudonym> At this rate, it should be finished in about 15 years.
15:17:53 * ddarius should start writing a book.
15:18:04 <dibblego> Pseudonym, :)
15:18:09 <Pseudonym> The working title is "Abstract Nonsense: Category Theory for the Armchair Computer Scientist".
15:18:54 <sek> that sounds quite interesting
15:19:08 <Pseudonym> Yeah, the thrust of the book is precisely this.
15:19:13 <seliopou> Your publisher would change that title immediately
15:19:20 <seliopou> :P
15:19:24 <Pseudonym> That in Haskell, category theory is design patterns.
15:20:30 <Pseudonym> I actually thought that there should be a whole series of books for the armchair scientist.
15:20:53 <Pseudonym> Book on science are either "popular science" or neck-deep in detail.
15:21:11 <Pseudonym> Most of us don't really want either.
15:22:39 <seliopou> It's easy to say, Shoot for the middle. It's hard to actually hit it. :(
15:22:43 <pejo> Pseudo, would you consider TAPL neck-deep?
15:23:00 <hyrax42> tapl starts off badly
15:23:02 <Pseudonym> Actually, no.  That's a very well-written book.
15:23:05 <Pseudonym> Yeah.
15:23:18 <hyrax42> apparently I just need to skip the first 5 chapters, then it'll be fine
15:23:21 <Pseudonym> I haven't read the sequel.
15:23:27 <pejo> hyrax, "badly"? It's definitely one of the nicest books I've come across in the last few years.
15:23:35 <hyrax42> the untyped lambda calculus chapter is a terrible bore
15:23:46 <pejo> Pseudonym, well. The chapters there are written by experts in the field.
15:24:03 <Pseudonym> Sure.
15:24:10 <hyrax42> pejo: I can't speak for the book as a whole; I haven't yet read any of the actual type system parts
15:24:14 <pejo> Pseudonym, so less consistent than the first, I'd say.
15:24:16 <Pseudonym> I really enjoyed "The Implementation of Functional Programming Languages".
15:24:26 <Pseudonym> It was a formative book in my upbringing.
15:24:29 <hyrax42> as I thought it was crucial for me to know all this church numeral/representing every thing as a lambda term stuff
15:24:33 <Pseudonym> Because it was so well-written.
15:24:48 <pejo> hyrax, well, what other except Barendregt is there on Lambda calculus?
15:24:50 <Pseudonym> It didn't delve too deep into the esoterica, but it wasn't handwavy either.
15:25:11 <Pseudonym> And it kept up the sense of narrative.  You could almost read it like a novel.
15:25:55 <pejo> For some reason I'm the only one in here who hasn't read that book I think.
15:26:04 <hyrax42> pejo: I had thought that it was important to understand that before moving on
15:26:20 <hyrax42> and wasn't in the mood of implementing addition/multiplication/exponentiation on church numerals
15:26:23 <hyrax42> so stopped reading
15:26:23 <pejo> hyrax, but lambda calculus is good for your health!
15:26:43 <hyrax42> no doubt, no doubt
15:26:48 <pejo> (My perception of the first chapters were that they were quite lightweight).
15:26:57 <pejo> (And well written, just like the rest of the book).
15:27:07 <hyrax42> pejo: I will give it another look
15:27:11 <hyrax42> it sits on my shelf
15:27:15 <hyrax42> out of library
15:27:18 <hyrax42> just time is short
15:27:21 * sorear <3 esoterica
15:33:16 <profmakx> 2jetzt flieg ich vom server runter
15:33:16 <profmakx> 78
15:33:16 <profmakx> 83
15:33:16 <profmakx> 88
15:33:21 <profmakx> ups
15:33:22 <profmakx> sorry
15:33:23 <cjeris> Pseudonym: how would your "abstract nonsense" book compare to Paul Taylor "Practical foundations of mathematics" or Lambek/Scott "Intro to higher order categorical logic" ?  I've been looking for something just a tiny bit gentler than those two for a while.
15:33:54 <monochrom> The part of category theory useful for Haskell is not the same part of category theory useful for other pursuits.
15:33:59 <cjeris> I have no problem with basic category theory but my logic background is weak.
15:34:04 <Pseudonym> It'd be gentler and more practical.
15:34:20 <Pseudonym> My problem with most category theory books is they tend to be heavy on the topology.
15:34:44 <Pseudonym> Which makes historical sense, but if I wanted a history book, I know where to go for that.
15:34:53 <monochrom> For example we are more interested in natural transformations and catamorphisms.  Other pursuits are more interested in adjunctions.
15:37:07 <monochrom> There is also a pursuit in which you have a category that has a lot more extra axioms (e.g., exponentials exist, something that looks like elementhood exists, ...) than the basic ones, and by the 25th axiom you go like "ok this is just trying to set up a set theory without saying so, what the heck..."
15:37:51 <cjeris> monochrom: yeah, I think something like that is what Taylor calls "Zermelo type theory"
15:37:57 <Pseudonym> It could also be argued that some software design problems are like that.
15:38:07 <Pseudonym> "Look, you don't actually want an ABSTRACT data type here."
15:38:40 <monochrom> Clearly, for the purpose of haskell, you don't need a generalized set theory.
15:38:56 <Pseudonym> Well ZF set theory doesn't cut it.
15:39:02 <Pseudonym> Not in Haskell.
15:39:25 <Pseudonym> You do need things that are like sets but aren't.
15:39:51 <Pseudonym> newtype Foo = Foo (Foo -> Bool)
15:40:03 <Pseudonym> That's a fancy way of saying that Foo is isomorphic to the power object of Foo.
15:40:09 <Pseudonym> Which is not true of any set.
15:40:36 <Pseudonym> And yet Foo exists in Haskell.
15:40:41 <Pseudonym> So it's clearly not a set.
15:41:05 <dibblego> @users
15:41:06 <lambdabot> Maximum users seen in #haskell: 322, currently: 292 (90.7%), active: 55 (18.8%)
15:41:27 <Anon4888> You can interpret everything in Haskell as sets
15:41:34 <Pseudonym> No you can't.
15:41:38 <Anon4888> Of course you can
15:41:44 <ddarius> Topos theory is more interesting than it seems at first blush.
15:41:46 <Pseudonym> I just proved that Foo is not a set.
15:42:00 <Anon4888> Under some assumption of the interpretation
15:42:21 <sorear> long live NST! :p
15:42:24 <Pseudonym> :-)
15:42:34 <ddarius> Anon4888: As structured sets, not naively.
15:42:40 <Pseudonym> Right.
15:42:47 <Pseudonym> You can think of Foo as having a carrier set.
15:42:51 <Pseudonym> But it's not an unstructured set.
15:42:58 <Pseudonym> Sets are unstructured.
15:43:21 <ddarius> Sets have tons of structure, it's just that their morphisms, functions, don't preserve most of it.
15:43:45 <Pseudonym> Homomorphisms, by definition, respect structure.
15:44:21 <sorear> *Homo*morphisms don't apply to sets, I thought.
15:44:23 <monochrom> Pseudonym just proved that ((Foo is not a set) or (-> is not function))
15:44:33 <Anon4888> All of Haskell can be modelled by sets
15:45:00 <Anon4888> The question is the interpretation (in the model theory sense)
15:45:11 <Pseudonym> monochrom: Eith either Foo is not a set, or (->) does not denote the power object of the category Set.
15:45:12 <sorear> "Begin by letting S be the set of things Pseudonym thinks are not sets, ..."
15:45:32 <Pseudonym> sorear: I reserve the right to be inconsistent.
15:45:59 <Pseudonym> Proving the Pseudonym incompleteness theorem is almost trivial.
15:46:56 * shapr hugs Pseudonym 
15:47:04 <Anon4888> I'm having trouble parsing the Haskell
15:47:07 <ddarius> Hey shapr
15:47:07 <monochrom> Pseudonym is incomplete, inconsistent, and undecidable.
15:47:23 <Pseudonym> And undecided.
15:47:24 <Anon4888> How is "newtype Foo = Foo (Foo -> Bool)" parsed?
15:47:39 <monochrom> (Proof: Pseudonym is a homo sapiens.)
15:47:46 <Pseudonym> Anon: It's like saying that type Foo = Foo -> Bool
15:47:57 <Pseudonym> Except that you're not allowed to have recursive types like that.
15:48:02 <Pseudonym> So you have to introduce a constructor.
15:48:04 <monochrom> Try this: newtype FType = FCons (FType -> Bool)
15:48:09 <Pseudonym> Right.
15:48:13 <Pseudonym> That's a good way of thinking about it.
15:48:46 <Anon4888> So you have a set of objects, and each object in the set can pair with any other object in the set and give you a bool
15:48:51 <monochrom> "module Foo where data Foo = Foo ..."  is a great way to intimidate the uninitiated :)
15:49:31 <Pseudonym> Anon, do you agree taht Foo -> Bool is 2^Foo?
15:49:38 <Anon4888> No
15:49:45 <Anon4888> It doesn't have to be in the model
15:49:59 <sorear> Bool includes _|_ :)
15:50:08 <kombinator> \query lambdabot
15:50:11 <Pseudonym> sorear: Yes, I did think about that briefly.
15:50:18 <shapr> ddarius: hiya! long time no see!
15:50:22 <shapr> ddarius: How's life treating you?
15:50:22 <sorear> kombinator: I think you want /
15:50:40 * Pseudonym thinks about that
15:50:43 <sorear> shapr: he came back over two days ago
15:50:51 <kombinator> sorear: yes, sorry
15:50:57 <shapr> sorear: Yeah, but I haven't spoken to him yet!
15:51:01 <ddarius> shapr: Actually, I'd have to say my life has gotten a whole lot better this past year.
15:51:03 <sorear> heh.
15:51:06 <sorear> yay!
15:51:07 <shapr> ddarius: awesome!
15:51:17 <Pseudonym> Woo!
15:51:22 <Pseudonym> ddarius++ -- the good life
15:51:45 <shapr> ddarius: Have you had any time to learn stuff or create new things?
15:52:00 * shapr hugs ddarius 
15:52:20 <monochrom> It's ok.  Pseudonym is proving: (Foo cannot be a set) or (Fool->Bool cannot be 2^Foo) or (Bool cannot be the set {true,false}).  The point stands: a haskell data type is not a usual set-theoretic things.
15:52:56 <ddarius> shapr: Until fairly recently, I haven't really had much access to a computer or the Internet.  Definitely for the past six months or so.
15:53:10 <shapr> ddarius: Was that helpful, or not?
15:53:13 <Pseudonym> I bet you've got a LOT of spam in your inbox.
15:53:26 <shapr> I think I'd get more stuff done if I only had access to the 'net every other week.
15:53:27 <chessguy> !paste
15:53:27 <hpaste> Haskell paste bin: http://hpaste.org/
15:53:30 <Anon4888> monochrom: I'd agree with something like that... probably that exactly if I thought about it more
15:54:04 <ddarius> shapr: It made me focus very strongly on other areas of interest I have, but not being able to look up a research paper when you want one is annoying.
15:54:45 <shapr> Yeah, I agree.
15:55:13 <ddarius> I also did get around to doing some things I've been meaning to, and learned some other just random things.
15:55:38 <ddarius> shapr: I can knit and crochet now for example. (Example of which of those is left as an exercise for the reader.)
15:55:38 <shapr> ddarius: Oh, I got a copy of the Hamming book, "The Art of Doing Science and Engineering : Learning To Learn"
15:55:41 <shapr> I think you'll like it!
15:55:44 <shapr> haha, cool!
15:56:05 <Pseudonym> Woo!
15:56:10 <Pseudonym> Multi-skilled.
15:56:12 <shapr> I'm sure that understanding lazy evaluation and the credit card transform helped there ;-)
15:56:33 <ddarius> Actually I was (re)prompted to get into crochet by hyperbolic manifolds.
15:57:02 <shapr> Never heard of 'em
15:58:02 <_magus_> is there a more elegant way of converting "AAFF" to an integer than this? read ("0x" ++ str) :: Integer?
15:58:11 <sorear> readHex?
15:58:16 <sorear> > readHex
15:58:17 <lambdabot>  Add a type signature
15:58:23 <sorear> > readHex "AAFF"
15:58:25 <lambdabot>  [(43775,"")]
15:58:27 <hpaste>  chessguy pasted "Kruskal's algorithm, pseudo-code" at http://hpaste.org/401
15:58:36 <_magus_> sorear: ah, cool, thanks
15:58:39 <ddarius> http://www.math.cornell.edu/~dtaimina/crochetinghypplane.htm
15:58:40 <lambdabot> Title: Untitled Document
15:58:53 <chessguy> so, i'm looking at this algorithm for finding a minimum spanning tree, and i can't even begin to picture what it would look like in haskell
15:59:52 <shapr> ddarius: Anything else interesting?
16:00:42 <chessguy> (assuming we even had union-find and heap data-structures, which i don't think we do
16:01:00 <chessguy> i'm just trying to figure out what those data structures would look like
16:01:24 <ddarius> shapr: I have a paper (of some sort) on category theory that I'm finally laying out in LaTeX.  I've greatly deepened my understanding of electrical engineering and greatly expanded my appreciation of generating functions and "complex" analysis.
16:01:54 <sorear> heaps are available in edison, and it's pretty easy to rig one (asymptotically but not constant factor optimal) from Data.Map
16:01:56 <Nafai> shapr: Hey, do you use Ubuntu?
16:02:03 <shapr> Nafai: Not yet
16:02:05 <shapr> Considering it.
16:02:07 <ddarius> shapr: I can do and understand the math to get to the Riemann Hypothesis.
16:02:11 <shapr> ddarius: Wow
16:02:22 <shapr> ddarius: nice
16:02:25 <ddarius> Nafai: I may be really soon.  I'm downloading the installation CD now.
16:02:48 <sorear> I understand the riemann hypothesis, *easy* ...
16:02:49 <Nafai> I was asking wondering if you were using GHC 6.6, since it is only available in Feisty, not Edgy
16:02:59 <sorear> its significance is totally beyond me.
16:03:06 <sorear> :(
16:03:32 <ddarius> sorear: Can you see where the \zeta function comes from?
16:03:39 <sorear> limits and infinite series and zeros ?
16:03:41 <chessguy> sorear, i'm mostly wondering what an implementation of Union-Find (disjoint sets) would look like. how one would even want to use it
16:04:03 <shapr> Nafai: I'm using GHC 6.6 in Debian.
16:04:23 <shapr> Nafai: Linspire's recent switch to an Ubuntu base rather than a Debian base has me interested.
16:04:45 <ddarius> Ubuntu is based on Debian!
16:04:46 <Nafai> I've been using Ubuntu since last April and am pretty pleased
16:05:07 <sorear> chessguy: union find structures are a strongly mutable-graphy algorithm ... you want ST or a Map
16:06:20 <chessguy> well, i have an idea for how to implement it, but i'm not sure how someone would want to use it
16:09:21 <matthew-_> ?where beautiful code
16:09:22 <lambdabot> I know nothing about beautiful.
16:09:24 <matthew-_> grr
16:09:33 <sorear> the wiki
16:09:35 <matthew-_> that paper/chapter spj was writing
16:09:43 <matthew-_> yeah, been searching. can't find it
16:10:03 <matthew-_> oh . http://research.microsoft.com/~simonpj/tmp/beautiful.ps
16:10:34 <ddarius> shapr: I've just recently gotten so that I can now switch between both QWERTY and Dvorak with little difference.
16:10:49 <matthew-_> ddarius: ooh! another dvoraker.
16:11:14 * ddarius has been one for, say, three years now (?)
16:11:29 <matthew-_> mmm. I switched autumn 2005.
16:11:40 <matthew-_> I can still cope with qwerty but have to look at the keys
16:11:41 <Pseudonym> Oh, nice paper.
16:11:54 <chessguy> ddarius, what do you have that uses Dvorak?
16:12:31 <matthew-_> Pseudonym : http://research.microsoft.com/%7Esimonpj/papers/stm/beautiful.ps
16:12:39 <Pseudonym> Oh, a friend of mine has finally convinced his employer to let him write a non-locking (STM) B-tree implementation in Haskell.
16:12:40 <matthew-_> not sure if it's different
16:12:50 <Pseudonym> Disk-backed and everything.
16:13:00 <ddarius> chessguy: I don't understand the question.
16:13:04 <matthew-_> finance sector?
16:13:12 <Pseudonym> Nope.
16:13:25 <matthew-_> ok, I'm not going to be able to guess then?
16:13:25 <Pseudonym> Start-up, can't say much under NDA.  But not finance.
16:13:28 <chessguy> ddarius, dvorak is a layout of keys on a keyboard, right?
16:13:37 <matthew-_> Pseudonym: ahh, ok.
16:13:52 <matthew-_> chessguy: yes, that's right.
16:14:11 <Pseudonym> The impression that I get is it's something more like a Tivo.  But it's not like a Tivo.
16:14:19 <chessguy> so what kind of machine still has a Dvorak-style keyboard
16:14:22 <resiak> This channel has become #dvorak now.
16:14:39 <mbishop> As long as John C. Dvorak doesn't come in, we're fine
16:15:25 <JohnCDvorak> did i hear my name being taken in vain in here?
16:15:50 <ddarius> chessguy: Usually you can change the layout in software (and optionally rearrange the key caps).  But there are hardware Dvorak keyboards.
16:15:58 <mbishop> No John, go write more trollbait articles
16:16:03 <dons> Pseudonym: do they have the skills to make it practical? (and fast?)
16:16:13 <matthew-_> meh. I learnt dvorak on a qwerty keyboard. Just don't look at the keys
16:16:29 <resiak> Isn't the whole point not to look at the keys? :)
16:16:33 <monochrom> haha, don't look at the keys
16:16:34 <Pseudonym> dons: I have no idea.  They can't tell me under NDA.
16:16:41 <matthew-_> and yeah, on X it's just setxkbmap gb dvorak
16:16:46 <Pseudonym> But I know they were using Python and ran into the interpreter lock.
16:16:52 <ddarius> sorear: Can you derive either of the equations at http://en.wikipedia.org/wiki/Prime_counting_function#Formulas_for_prime_counting_functions ?
16:16:54 <Pseudonym> So now they're started looking at haskell.
16:16:54 <lambdabot> http://tinyurl.com/9k3sy
16:17:06 <matthew-_> resiak: indeed. Hence why I now use a "Das Keyboard II". Blank keys.
16:17:08 <dons> well, that should't be hard to improve on then :-)
16:17:10 <shapr> ddarius: I still can't touchtype on a qwerty, takes me forever to do anything in BIOS setup
16:17:44 <siti> is the das keyboard noisy?
16:18:04 * ddarius would like to have blank key caps, but that's probably not prudenty.
16:18:06 <shapr> Pseudonym: Python's GIL really irritates me. So does its recursion limit.
16:18:11 <dons> Pseudonym: good idea if they care about speed, but need a high level language, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=python
16:18:13 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2deng4
16:18:22 <sorear> ddarius: I still can't figure out what the riemann hypothesis even has to do with primes.
16:18:35 <dons> Pseudonym: i wonder, do they know about halfs, the file system Isaac wrote?
16:18:40 <matthew-_> siti: yes. but it's really good for me as I don't get rsi with in
16:18:42 <matthew-_> -in +it
16:18:50 <siti> I was thinking about getting one
16:18:55 <siti> ok
16:18:57 <ddarius> sorear: It states the relationship right on that page.
16:19:11 <shapr> I was just thinking about Halfs.
16:19:17 <Pseudonym> dons: Dunno.
16:19:20 <dons> sjanssen: did you see the updated mandelbrot scores?
16:19:21 <monochrom> I can touch type but I am not confident
16:19:24 <ddarius> shapr: So how's life been?
16:19:39 <shapr> ddarius: Interesting... I'm back in the USA.
16:19:46 <monochrom> My confidence underestimates my ability in this case. :)
16:19:56 <siti> I am learning colemack layout!!! it's so hard
16:19:57 <ddarius> shapr: Where?
16:20:02 <shapr> Birmingham, AL
16:20:15 <shapr> But if you're somewhere close by I can drive over and buy you coffee.
16:20:20 <matthew-_> siti: what is that?
16:20:27 <siti> http://colemak.com/Learn
16:20:30 <lambdabot> Title: Learn - Colemak
16:20:45 <fasta> I deleted one file from my darcs repo, how do I get it back?
16:20:49 <ddarius> monochrom: That's not unusual.  I sometimes just sit back and watch myself play guitar.  I'm amazed at what my hands can do.  I certainly can't do it.
16:20:57 <sorear> fasta: darcs revert foo/bar
16:21:10 <fasta> sorear: I only deleted it from the fs
16:21:12 <monochrom> hehe
16:21:22 <ddarius> shapr: San Angelo, Texas is where I'll be for the next four years... except when I'm not...
16:21:24 <sorear> fasta: btw, that kind of thing is more OnT on #darcs
16:21:41 <fasta> sorear: I know.
16:21:47 <sorear> fasta: exactly.  darcs revert foo/bar will undo rm foo/bar (assuming it's in the repo)
16:22:05 <fasta> sorear: ok, well, apparently it wasn't in the repo.
16:22:06 <ddarius> sorear: Maybe I'll make an article on the Riemann Hypothesis that I have been considering.
16:22:23 <fasta> I am trying to build GHC, but I think it's broken.
16:22:29 <fasta> I am missing a header file.
16:23:06 <shapr> ddarius: Looks like a 14 hour drive.. do you have a floor I can sleep on?
16:24:16 <fasta> make[1]: *** No rule to make target `StgTicky.h', needed by `mkDerivedConstants.o'.  Stop.
16:24:16 <fasta> make: *** [stage1] Error 1
16:24:35 <sorear> fasta: that file was modified *very* recently
16:24:54 <sorear> fasta: GHC is in the process of merging in a fix-ticky-ticky branch
16:25:03 <sorear> fasta: expect it to be broken
16:25:12 <sorear> fasta: see the GHC Wiki for details
16:25:17 <fasta> sorear: fix-ticky-ticky branch O.O
16:25:25 <fasta> sorear: will do
16:25:28 <fasta> sorear: thanks
16:25:46 <ddarius> shapr: In theory no, but a night or so may not be an issue.  Also I may be able to make available relatively cheap lodging.
16:25:52 <sorear> fasta: sorry
16:25:56 <sorear> fasta: not on the wiki
16:27:05 <sorear> fasta: sorry sorry
16:27:12 <sorear> fasta: yes on the wiki
16:27:18 <sorear> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Profiling
16:27:20 <lambdabot> Title: Commentary/Profiling - GHC - Trac
16:27:48 <shapr> ddarius: Sounds good. Probably won't happen until May or later.
16:27:50 <ddarius> shapr: So what brought you back home? and ... other things I should know? /msg me if you think that is appropriate.
16:27:57 <sorear> oh ... "Ticky-ticky should now be working in the HEAD,"
16:28:13 <sorear> fasta: ^^^ repull, recompile, and tell g-h-u
16:29:17 <shapr> ddarius: Swedish immigration said I needed to make more money to prove to them that I wouldn't be a burden on the social system, and I was unable to crank up my contract work in time. Much of the problem is that I was on a self-employed permit, which does not allow employment.
16:31:59 <ddarius> I guess in theory that makes sense on their part.
16:32:24 <shapr> I understood their reasoning, but I didn't like it much.
16:32:43 <shapr> I have enjoyed seeing my family lots over the last few months.
16:34:35 <Nafai> ddarius: I'm in Austin!
16:35:22 <Pseudonym> Gah!
16:35:31 <gotaku> shapr: They deported you?
16:36:03 <shapr> No, they just said that I needed to appeal the decision or get a lawyer or something if I couldn't bring my income up.
16:36:09 <ddarius> shapr: I was in Biloxi for a while ending about a month ago.
16:36:23 <shapr> Ah, I haven't been to Biloxi in decades.
16:36:55 <gotaku> shapr: Or you could marry a Swedish woman :)
16:36:55 <ddarius> I had passed through it a year before I ended up there.  I got to see it a bit before and a chunk after Katrina.
16:37:05 <shapr> gotaku: But since I understood their reasoning, and did not believe that I could stay in the spirit of the law, I left.
16:37:11 <shapr> gotaku: Oh, I've got one I'm trying to marry.
16:37:21 <ddarius> shapr: How is Bea?
16:37:24 <shapr> gotaku: That's why I wanted to stay, and that's why I want to go back.
16:37:24 <Pseudonym> Ho hard are you trying?
16:37:31 <gotaku> I see.
16:37:45 <shapr> ddarius: I broke up with Bea ... two years ago? She's married now!
16:38:34 <ddarius> Damn.  How long have I been away?
16:38:40 <shapr> It's been awhile :-)
16:39:08 <shapr> But also, I don't usually talk about my relationship or family sort of stuff on #haskell unless someone specifically asks me.
16:39:36 <shapr> Not that I mind talking about that sort of thing, I just don't want to distract the people who are learning stuff.
16:39:52 <ddarius> Unfortunately, there's a good possibility of me having a year hiatus from the Internet in about eight months or so.
16:39:56 <shapr> ddarius: Speaking of which, #haskell-blah was created for just that purpose!
16:40:07 <Pseudonym> http://bp3.blogger.com/_FBXGhy-QmVw/RclUgCusgII/AAAAAAAAAdU/CzI1AERJoqA/s1600-h/card650.JPG
16:40:10 <lambdabot> Title: card650.JPG (image), http://tinyurl.com/yqvpot
16:40:10 <ddarius> shapr: Talking about shapr's private life?
16:40:13 <shapr> ddarius: heh!
16:40:15 <shapr> No!
16:40:18 * shapr laughs
16:40:35 <Pseudonym> Anyone's private life is on-topic there.
16:41:18 <ddarius> Pseudonym: re the image: That is a fundamental difficulty in life.
16:42:02 <ddarius> (the multiplicity of solutions for y = k)
16:42:32 <Pseudonym> Yes.
16:43:24 <Pseudonym> http://bp2.blogger.com/_FBXGhy-QmVw/Rb6e4f_dxdI/AAAAAAAAAaU/UH-5eVEK6C4/s1600-h/card634.JPG
16:43:26 <lambdabot> Title: card634.JPG (image), http://tinyurl.com/2pb4qc
16:43:29 <Pseudonym> That one is poetry.
16:44:51 <ezenu> if y and x are ints, how can I make "y < sqrt x" work? "y < floor sqrt x" doesn't work either..
16:45:07 <Pseudonym> x and y are non-negative?
16:45:13 <Pseudonym> Then y*y < x works fine.
16:45:14 <ezenu> yes
16:45:57 <ezenu> okay, guess that'll work. don't understand the type errors with the other statements though
16:46:21 <Pseudonym> sqrt doesn't work on integers.
16:46:24 <Pseudonym> :t sqrt
16:46:26 <lambdabot> forall a. (Floating a) => a -> a
16:46:26 <ddarius> ezenu: That is actually a much better way of doing it.
16:46:32 <Pseudonym> It requires that a be Floating.
16:46:34 <Pseudonym> Not Integral.
16:46:47 <TomMD> ezenu: You are probably looking for functions like "fromIntegral" and "fromRational"
16:46:50 <Pseudonym> Now if x doesn't change much, then computing an integer square root may not be a bad idea.
16:47:01 <Pseudonym> But that's another story.
16:47:03 <matthew-_> mmm. straw poll to decide the future of the world. Raise you hands if you like the idea of STM.
16:47:20 <matthew-_> oh look. No votes. The prosecution rests.
16:47:27 <matthew-_> night night.
16:47:35 <TomMD> matthew - I love STM!
16:47:35 <Pseudonym> I like the _idea_...
16:47:43 <Pseudonym> But I'd like HTM better.
16:47:51 <ezenu> yeah, I realize its probably much faster.. I think i'm set.. those from functions should be useful
16:47:56 <sorear> I like `par` better
16:48:08 <matthew-_> I like no shared mutable state
16:48:23 <Pseudonym> I like toilet seats made out of solid gold.
16:48:33 <Pseudonym> Until I get one, I'll stick with STM.
16:48:40 * ddarius would prefer silver for hygiene reasons.
16:48:45 <Pseudonym> OK, fair enough.
16:48:48 <matthew-_> how do you know you like it if you've never used one?
16:49:05 <matthew-_> and no shared mutable state is easily achieveable.
16:49:11 <TomMD> Are you saying you haven't used STM?
16:49:32 * matthew-_ is guilty as chared.
16:49:34 <ddarius> matthew-_: For certain definitions of "shared"
16:49:41 <matthew-_> I've read several papers on em.
16:49:58 <matthew-_> mailboxs can be implemented without shared mutable state.
16:50:02 <Pseudonym> How would you write a database server with no shared mutable state?
16:50:03 <TomMD> I've used them several times and they do help with numerous issues.
16:50:13 <Pseudonym> Make it single-threaded?
16:50:29 <matthew-_> Pseudonym: yeah, that's the example people come up with. You can still do it with mailboxes
16:50:37 <TomMD> Pseudonym: Don't reveal Oracles secret!
16:50:37 <matthew-_> the commit gets a bit more complex
16:50:49 <Pseudonym> LOL!
16:50:55 <Pseudonym> I used to work for an Oracle competitor.
16:50:57 <matthew-_> but the problem is that the whole database transaction thing is just that
16:51:02 <matthew-_> it's transactions
16:51:05 <sieni> well,
16:51:16 <sieni> STM just works
16:51:24 <sieni> mutex masturbation is just a pain in the ass
16:51:27 <Pseudonym> The database server is the classic example of a problem that can't be completely partitioned and isn't single-threaded.
16:51:35 <matthew-_> and so saying "how do you implement this paradigm using your paradigm" is always going to result in an unpleasant answer
16:52:01 <ddarius> matthew-_: Not necessarily.
16:52:43 <matthew-_> also, don't forget that mnesia is a database in Erlang and has good performance
16:52:55 <matthew-_> ok, it's not Oracle or Postgres
16:53:02 <matthew-_> but it's reasonable.
16:54:45 <dibblego> is there a Haskell STM implementation?
16:54:50 <matthew-_> err, yes
16:54:54 <dibblego> err, where?
16:55:12 <matthew-_> control.concurrent.stm ?
16:55:19 <matthew-_> ?where STM
16:55:20 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
16:55:25 <dibblego> oh thanks
16:55:33 <dibblego> what applications use it?
16:55:34 <matthew-_> ?hoogle Control.Concurrent.STM
16:55:35 <lambdabot> No matches, try a more general search
16:55:44 <matthew-_> ?hoogle STM
16:55:45 <lambdabot> Control.Concurrent.STM :: module
16:55:45 <lambdabot> GHC.Conc.STM :: data STM a
16:55:45 <lambdabot> Language.Haskell.TH.Stmt :: data Stmt
16:55:59 <dibblego> has anyone written a database server with it yet?
16:56:36 <psnl> argh, you tempt...
16:56:38 <sorear> HAppS
16:57:02 <dibblego> HAppS is a database?
16:57:17 <sorear> HAppS is everything, man
16:57:18 <sorear> :)
16:57:34 <dibblego> I'm only asking since it seems I have reinvented shit once again - so hopefully someone else has implemented for me (my consolation) :)
16:57:36 <sorear> honestly, I've never used it
16:58:30 <chessguy> are Data.Map look-ups O(1)
16:58:33 <chessguy> ?
16:58:42 <dibblego> O log n iirc
16:59:20 <sorear> but as consolation you get order features, and persistance
16:59:39 <dibblego> what are order features?
16:59:51 <sorear> maxView, minView
16:59:55 <chessguy> doesn't really help as a base for a disjoint-set data structure
16:59:55 <sorear> split
17:00:00 <dibblego> ah, I can guess what they are
17:00:01 <sorear> alas
17:00:41 <gotaku> So this D-Wave company claims it has made a 16-qubit quantum computer...
17:01:30 <dons> gotaku: see the shootout result for mandelbrot?
17:01:39 <gotaku> dons: Yep ;)
17:02:05 <gotaku> dons: It's 1.1 times slower then the clean version... so close.
17:02:42 <dons> yeah, i'm pretty happy with that
17:03:12 <davidmccabe_> Have they ported GHC to the quantum computer yet?
17:03:14 <ddarius> gotaku: Through a new approach or old approaches with greater care?
17:03:52 <gotaku> ddarius: Not sure but they are going to to a live demo at the computer history museum on the 13th.
17:04:50 <chessguy> the problem is, for the Find operation, it doesn't really make sense, because you don't really maintain references to the individual elements in the structures in a non-mutable language
17:05:48 <gotaku> dons: Also GHC has jumped two more places on the overall list.
17:05:57 <sorear> davidmccabe_: no QC in existance is powerful enough to run GHC.  (I expect a retarget will occur long before a port, but both are far away)
17:06:00 <chessguy> ?where shootout
17:06:00 <lambdabot> http://shootout.alioth.debian.org/
17:06:07 <davidmccabe_> sorear: was a joke.
17:08:49 <davidmccabe_> Say, I am giving a brief talk along the lines of, "Hey, Haskell is really neat and you might want to check it out" to some maths undergrads.
17:09:13 <ddarius> CH
17:09:17 <chessguy> !say I am giving a brief talk along the lines of, "Hey, Haskell is really neat and you might want to check it out" to some maths undergrads.
17:09:19 <davidmccabe_> I've written in Haskell but not enough to really understand it deeply. I wonder if there are any good resources to assemble some things to point out?
17:09:38 <chessguy> ?wiki
17:09:38 <lambdabot> http://www.haskell.org/haskellwiki/
17:09:38 <dons> davidmccabe_: show some nice maths (i.e. from the Haskell Road to Maths textbook?), show the good speed,show the wide libs, active community..
17:09:52 <chessguy> davidmccabe_, that's a good place to start
17:10:05 <davidmccabe_> chessguy: I was looking for something more specific or I wouldn't have asked :P
17:10:20 <ddarius> davidmccade_: What aspects are you trying to highlight? What do you want the students to get from the talk?
17:10:23 <chessguy> well your question wasn't more specific
17:10:51 <davidmccabe_> ddarius: Well, thing is, I'm so new to haskell myself that I'm afraid I'll leave out some of the best parts.
17:11:10 <chessguy> the quicksort example is a classic
17:11:16 <chessguy> very effective
17:11:25 <ddarius> davidmccabe_: They might want to check it out for use or theory?
17:11:31 <davidmccabe_> ddarius: But, essentially, the fact that it's very different mindset, the fact that you can express algorithms elegantly, that it has good libraries and tools...
17:12:27 <mwolak> you should definitely show off infinite lists, like with the primes filter
17:12:36 <Botje> show off \bot!
17:12:45 <chessguy> some elegant algorithm examples: quicksort, the sieve of eratosthenes, the fibonacci sequence, the hamming problem
17:13:05 <ddarius> mwolak: Jerzy's differentiation code would be a much more interesting example in that vein.
17:13:09 <Botje> yeah.
17:13:19 <davidmccabe_> this? primes (n:ns) = n : primes (filter (\v -> v `mod` n /= 0) ns)
17:13:22 <Botje> haskell is the only language I know where a quicksort is easier to write than a bubblesort
17:13:51 <mwolak> ddarius: probably, but I'm biased towards number theory :)
17:13:52 <chessguy> davidmccabe_, that's the sieve or eratosthenes, yes
17:13:59 <chessguy> s/or/of/
17:14:05 <mbishop> primes :: [Integer]
17:14:06 <mbishop> primes = primes' [2..]
17:14:06 <mbishop>   where filterOut i = filter (\x -> x `mod` i /= 0)
17:14:06 <mbishop>         primes' [] = []
17:14:06 <mbishop>         primes' (x:xs) = x : (primes' (filterOut x xs))
17:14:26 <mbishop> something I wrote a while back :o
17:14:36 <chessguy> you can leave out the primes' [] case
17:14:52 <mbishop> yeah, good point
17:14:53 <mwolak> and then play with that, ie: let twinprimes = filter (\(a,b) a == (b+2)) $ zip primes (tail primes)
17:14:58 <Adamant> why are x and xs used?
17:15:07 <Adamant> as names.
17:15:21 <chessguy> mbishop, and the line davidmccabe_ just gave is more elegant overall
17:15:33 <davidmccabe_> mbishop: have we met before?
17:16:00 <ddarius> mwolak, davidmccabe_: Generating functions may be an interesting example doubly in mwolak's vein
17:16:15 <mbishop> davidmccabe_: I believe so, in that channel for an online radio station
17:16:18 <chessguy> davidmccabe_, if you want to draw a distinction between haskell and, say, C++ or java, use an example like http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
17:16:19 * mbishop can't remember the name
17:16:21 <lambdabot> Title: Introduction - HaskellWiki, http://tinyurl.com/eogyw
17:16:41 <ddarius> Adamant: Why 'x' as opposed to 'number' say? or why 'x:xs' as opposed to 'hd:tl' say?
17:16:44 <davidmccabe_> mbishop: yes.
17:16:59 <davidmccabe_> as opposed to car:cdr? :P
17:17:04 <davidmccabe_> thanks for your pointers; bbl.
17:17:08 <Adamant> yes! :)
17:17:36 <chessguy> it's just a convention. like the reason most people use QWERTY instead of Dvorak
17:17:38 <Adamant> hd:tl, I understand why car:cdr aren't used, this isn't Lisp.
17:17:58 <mbishop> x and xs are just simple pattern matching variables, x is head, xs (As in "Xes") is the rest
17:18:04 <Adamant> chessguy, but what's the rationale behind the convention?
17:18:07 <ddarius> Adamant: For the former, many times there isn't really a meaningful name, especially when the variable is universally polymorphic.
17:18:30 <NichardRixon> mbishop, interesting, I've always read it as "excess"
17:18:35 <ddarius> Adamant: As mbishop said, in x:xs the xs is supposed to read as plural.
17:18:45 <ddarius> As in item:items
17:18:47 <Adamant> ah, ol.
17:18:51 <Adamant> ok. :)
17:18:54 <chessguy> x is frequently used in many domain as an arbitrary instance of an object
17:18:58 <mbishop> well it's pronounced "excess" really heh, but it's ment to be "more than one x"
17:19:07 <Adamant> chessguy, right, but the xs was throwing me off
17:19:27 <chessguy> Adamant, it's nice once you get used to it
17:19:27 <Adamant> all my xs live in Texas
17:19:32 <norpan> hey haskell
17:19:55 <mbishop> Adamant: That's why I hang my hat in Tennessee
17:19:58 * ddarius dislikes Texas.
17:20:13 <Adamant> ddarius, do you dislike Texas or GWB?
17:20:18 <Adamant> two different things
17:20:23 <ddarius> Yes
17:20:27 <Pseudonym> In Australia, we have one cattle ranch that's bigger than Texas.
17:20:44 <Pseudonym> Unfortunately, it has limited bragging appeal, since it's owned by Texans.
17:20:47 <mbishop> In soviet russia, cattle ranch YOU!
17:20:50 * mbishop hides
17:22:57 <norpan> all your cattle are belong to US
17:23:08 <norpan> and so on
17:23:21 <Pseudonym> I don't have any cattle, you insensitive clod.
17:23:24 <ddarius> norpan: Excellent job.
17:23:38 <ddarius> Pseudonym: For shame! Then what he says is true.
17:24:17 <Adamant> I made a "give this man a NAND" joke when I was in Digital Design
17:24:25 <norpan> i, for one, welcome our new cattle-ranching australian-texan overlords
17:24:27 <Adamant> it was funny. for about 4 seconds.
17:24:34 <orbitz> are deterministic gc's well researched and common (is it something many peopel usign gc's woud want?)
17:24:43 <orbitz> we are looking into some realtiem gc's for java at work
17:25:45 <mbishop> So what is #haskell going to get me for my birthday?
17:26:01 <Nafai> mbishop: When's your birthday?
17:26:08 <norpan> and where
17:26:18 <mbishop> Nafai: Saturday
17:26:19 <orbitz> mbishop: maybe #erlang will get you somethign too!
17:26:28 <Nafai> mbishop: Mine too!
17:26:29 <dibblego> anyone doing a PhD with STM?
17:26:31 <Adamant> you better hope nobody says "a birthday spanking"
17:26:34 <mbishop> Nafai: :)
17:26:42 * mbishop will be 22
17:26:48 * Nafai will be 30
17:26:55 <mbishop> haha, old fat :P
17:26:55 <norpan> younglings!
17:26:56 * orbitz will be neither
17:27:30 <norpan> spankogram perhaps
17:28:40 * ddarius loves illwillpress.
17:29:32 <davidmccabe_> Hey, I just had a birthday... where are my spankings?!
17:29:44 <hpaste>  ookk pasted "what is the difference?" at http://hpaste.org/402
17:29:46 <Botje> the RNG has them.
17:30:01 <norpan> davidmccabe_: they are being evaluated, be patient
17:30:32 <ookk> anyone could enlighten me about why the first example produces an error?
17:30:55 <davidmccabe_> ookk: you may want to have a lambda instead of just a $.
17:31:47 <ookk> why cant i have a $?
17:32:04 <davidmccabe_> I don't really know haskell, but it looks like runST takes a function as its argument.
17:32:39 <mbishop> :t runST
17:32:41 <lambdabot> Not in scope: `runST'
17:32:50 <ookk> :t Control.Monad.ST.runST
17:32:52 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
17:33:18 <allbery_b> the do block is a function
17:33:36 <allbery_b> I'm wondering if it's something about ($) not being polymorphic enough
17:33:47 <norpan> where do you run it
17:33:49 <allbery_b> but, well, where's the error mesage?
17:34:02 <dolio> ($) is the problem.
17:34:06 <ddarius> With impredicativity I think this would work, but Haskell probably does not infer polymorphic enough types.
17:34:12 <ookk> allbery_b, i im almost certain i used $ on functions taking funcitons as arguments before
17:34:28 <allbery_b> ookk: ($) is not polymorphic enough for some cases
17:34:33 <ddarius> ookk: But as dolio said, if you use parens instead of $ then it will work in the first case.
17:34:36 <ookk> maybe something to fix for Haskell' ?
17:34:43 <allbery_b> ST is known to be a bit odd because it's existentially qualified
17:34:54 <dolio> The problem is with ST's higher rank type. It doesn't work with $, at least in older versions.
17:36:24 <ookk> what is "old" ?
17:36:28 <ookk> i have the latest ghc
17:36:34 <norpan> that's too old :)
17:36:40 <dolio> Pre 6.6, at least. :)
17:36:44 * allbery_b thought that was all versions
17:36:46 <ookk> i have 6.6 :P
17:36:55 <dolio> Well, then it doesn't work with that, either. :)
17:37:17 <dolio> I thought the impredicativity changes were to allow that to work, but I guess not.
17:37:26 <dolio> Or, that among other things.
17:37:40 <ddarius> dolio: They probably require type annotations
17:37:43 <ookk> !paste
17:37:43 <hpaste> Haskell paste bin: http://hpaste.org/
17:38:00 <TomMD> Why is the thread limit 163?
17:38:00 <hpaste>  ookk pasted "so i have to write something like this?" at http://hpaste.org/403
17:38:13 <ookk> or does anyone know any nicer way to do it
17:38:14 <ookk> ?
17:38:21 <ddarius> ookk: No.  Just use parens instead of $
17:38:29 <TomMD> I just made a recursive forkIO call (f = 2x forkIO g, g = 2x forkIO f) and i only get 163 threads then a lockup.
17:38:38 <ddarius> runST (blah ...) will work
17:38:53 <norpan> 163 threads ought to be enough for anybody!
17:39:08 <TomMD> Thats not the point - it should throw an exception that I can catch.
17:39:11 <Botje> in a comment to "don't hate the for loop", someone said you can use foldr on infinite lists
17:39:15 <ookk> yeah that is probably the nicest way then
17:39:21 <ookk> its a shame $ doesnt work
17:39:24 <ookk> i like to use it alot
17:39:40 <ddarius> Botje: Yes...
17:39:44 <Botje> can anyone give me an example?
17:39:50 <dolio> > head (foldr (:) [1..])
17:39:51 <lambdabot>      Expecting a function type, but found `[a]'
17:39:51 <lambdabot>       Expected type: [a]
17:39:51 <lambdabot>     ...
17:39:53 <newsham> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style#Example:_coroutines
17:39:56 <lambdabot> http://tinyurl.com/yn66zz
17:39:56 <newsham> oops!  empty!
17:40:00 <Botje> (except for variations on foldr (:) [])
17:40:17 <ddarius> @src filter
17:40:18 <lambdabot> filter _ []     = []
17:40:18 <lambdabot> filter p (x:xs)
17:40:18 <lambdabot>     | p x       = x : filter p xs
17:40:18 <lambdabot>     | otherwise = filter p xs
17:40:23 <ddarius> Bah
17:40:35 <TomMD> Oh, it chews through the memory and the CPU power!  How nice!
17:40:38 <Botje> I know you can rewrite filter and map using foldr, but are there _OTHER_ uses?
17:40:50 <dolio> Anything that doesn't require the entire list to produce a partial result.
17:41:12 <Botje> that much is clear.
17:41:25 <Botje> i'll try to think of some functions like that, then
17:41:30 <Botje> thanks!
17:41:35 <ddarius> concat = foldr (++) []
17:41:46 <newsham> > foldl (\n ch -> 10*n + digitToInt ch) 0 "31336"
17:41:48 <lambdabot>  31336
17:41:56 <mbishop> Oh neat, GEB author has another book coming out
17:42:12 <Anon4888> Of course you could use a for-loop on infinite lists too
17:42:54 <newsham> > scanl (+) 0 [1..]
17:42:56 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
17:43:04 <dolio> > True : repeat False
17:43:06 <lambdabot>  [True,False,False,False,False,False,False,False,False,False,False,False,Fals...
17:43:16 <dolio> > foldr (||) False (True : repeat False)
17:43:17 <lambdabot>  True
17:51:08 <Jessehk> I'm having a few problems with inferred types and the prime sieve. Any tips? http://paste.lisp.org/display/36592
17:53:29 <newsham> prime = head list.    then    ++ prime
17:53:31 <allbery_b> looks right to me
17:53:33 <newsham> ?type (++)
17:53:35 <lambdabot> forall a. [a] -> [a] -> [a]
17:54:00 <allbery_b> hm, no, Integral [a]
17:54:10 <newsham> therefore prime is a list.
17:55:09 <Jessehk> newsham, Thanks. I've made that mistake before. :)
17:55:14 <Jessehk> fixed
17:55:15 <allbery_b> primesFound ++ [prime]
18:06:03 <glguy_> ?hoogle moveFile
18:06:04 <lambdabot> System.Win32.File.moveFile :: String -> String -> IO ()
18:06:04 <lambdabot> System.Win32.File.moveFileEx :: String -> String -> MoveFileFlag -> IO ()
18:06:04 <lambdabot> System.Win32.File.mOVEFILE_COPY_ALLOWED :: MoveFileFlag
18:06:10 <glguy_> ?hoogle rename
18:06:11 <lambdabot> Language.Haskell.TH.Lib.rename :: Pat -> Q ([(Name, Name)], Pat)
18:06:11 <lambdabot> Directory.renameDirectory :: FilePath -> FilePath -> IO ()
18:06:11 <lambdabot> Directory.renameFile :: FilePath -> FilePath -> IO ()
18:06:40 <glguy_> renameFile ftw
18:09:00 <newsham> > renameFile "/etc/passwd" "/etc/oldpasswd"
18:09:01 <lambdabot>   Not in scope: `renameFile'
18:11:21 <sorear> tell fodder
18:19:47 <tessier_> Wow. "Programming in Haskell" is pricey. Anyone know if this book is any good?
18:19:51 <tessier_> I just read about it on someones blog.
18:21:31 <dons> its an introductory textbook
18:22:55 <sorear> dons: Ptr Int vty works ... not too quickly but still
18:23:13 <dibblego> anyone using CAL?
18:30:01 <dons> dibblego: not that I know of
18:30:19 <dibblego> looks pretty funky
18:30:26 <dibblego> a nicer alternative than Scala perhas
18:30:29 <dibblego> *perhaps
18:30:38 <dons> yeah
18:30:52 <dons> grumble, could have written a jvm backend to ghc, and had the community as well *grumble*
18:30:53 <dibblego> by the way, how many cores has your beastiest machine got these days? I was just talking about it at lunch with parallel map function
18:31:06 <dibblego> yep
18:31:11 <dons> 16 here, 32 in berline.
18:31:18 <dons> some talk of a 128 core box somewhere
18:35:50 <dibblego> I wish I'd read about CAL before writing all that Scala code
18:35:54 <dibblego> damn I hate that
18:36:58 <JKnecht> scroll up today in log and you'll see mention of someone getting access to a 3000 core host
18:37:08 <dibblego> cripes
18:40:35 <sjanssen> dons: I've started hacking on a window manager
18:41:16 <gvdm_other> a haskell window manager?
18:41:27 <sjanssen> gvdm_other: yeah
18:42:05 <gvdm_other> what would be nice is a OS built with haskell, not just a kernel like house, but the tools, the library, the userspace
18:42:20 <gvdm_other> sort of unix, but with haskell, not C
18:42:22 <Binkley> well, there's nothing stopping us
18:42:26 <gvdm_other> and modern concepts of course
18:42:30 <siti> lol, simple or beryl like?
18:43:00 <sjanssen> siti: it's a slavish clone of dwm
18:43:08 <siti> ok
18:44:20 <gvdm_other> is dwm a lot like wmii?
18:44:24 <gvdm_other> i used to use wmii
18:45:12 <sjanssen> it's similar
18:45:13 <mbishop> slavish?
18:45:46 <sjanssen> mbishop: "showing no attempt at originality, constructive interpretation, or development"
18:45:49 <dibblego> http://resources.businessobjects.com/labs/cal/cal_for_haskell_programmers.pdf "In addition, there is a superclass constraint in that Functor is a superclass of Monad." -- yay!
18:45:52 <lambdabot> http://tinyurl.com/284kgm
18:46:14 <mbishop> sjanssen: oh
18:46:29 <mbishop> A haskell version of ratpoison would probably be nice
18:46:57 <allbery_b> hm, monadsh :)
18:52:30 <TomMD> The best program to reimplement in Haskell would be NS2 (imo).
18:54:01 <sorear> NS2?
18:54:06 <sorear> @google NS2
18:54:08 <lambdabot> http://www.isi.edu/nsnam/ns/
18:54:08 <lambdabot> Title: The Network Simulator - ns-2
18:54:58 <ookk> if i define a function with a let-statement, how can i add a type declaration?
18:56:35 <sorear> > let foo :: Int -> Int ; foo x = x + 1 in foo maxBound
18:56:35 <sorear> @bot
18:56:35 <sorear> *drums fingers*
18:56:35 <sorear> gah, /who isn't working either
18:56:35 <lambdabot> :)
18:56:36 <lambdabot>  -2147483648
18:56:54 <sorear> ookk: good?
18:57:05 <ookk> sorear, thx i will try it
18:59:22 <ookk> yeah it works
19:09:12 <sorear> @ask dons can you find the massive time leak in http://members.cox.net/stefanor/vty/Graphics/Vty.hs : diffs ?  the core looks reasonable to me
19:09:13 <lambdabot> Consider it noted.
19:43:42 <sorear> @users
19:43:43 <lambdabot> Maximum users seen in #haskell: 322, currently: 286 (88.8%), active: 33 (11.5%)
19:45:05 <mbishop> http://web.cecs.pdx.edu/~sheard/Omega/index.html
19:45:06 <lambdabot> Title: Omega Download Page
19:54:38 <dons> Binary hackers, just added Binary Float and Binary Double instances (yay for encodeFloat!)
19:54:39 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
19:56:14 <DannoHung>  @coffee
19:56:21 <DannoHung> It doesn't make coffee?
19:57:27 <sorear> yay!
19:57:30 <chessguy> @quote coffee
19:57:30 <lambdabot> No quotes match. My mind is going. I can feel it.
19:57:56 <DannoHung> @quote daisy
19:57:57 <lambdabot> No quotes match. I feel much better now.
19:58:12 <chessguy> @quote dons
19:58:13 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
19:58:13 <lambdabot> true functional programming), and you've got haskell
19:59:30 <Gwern> @quote dons
19:59:31 <lambdabot> dons says:  its like you can really see the guy's brain melting
20:12:51 <bsmntbombdood> When does the compiler/interpreter know when to actually evaluate an expression?
20:13:05 <sorear> when it is needed, and no sooner
20:13:07 <jcreigh> bsmntbombdood: when it'd needed.
20:13:09 <jcreigh> *it's
20:13:19 <bsmntbombdood> And when is it needed?
20:13:43 <dibblego> yesterday!
20:13:58 <jcreigh> bsmntbombdood: Ultimately, when you do IO with it.
20:15:12 <gotaku> dons: You around?
20:19:58 <jeeves_bond> Newbie question! I'm having trouble understanding what 'Either' means and how to use it. I understand 'Maybe' but am not sure how 'Either' would be used. Can anyone help?
20:20:22 <jeeves_bond> (I just asked in newbie help, but there doesn't seem to be anyone there)
20:20:35 <sorear> jeeves_bond: it's a disjunction type
20:20:36 <nrb23> anyone mind helping a noob with type constraints?
20:20:40 <sorear> nope
20:20:50 <sorear> jeeves_bond: it's like a C union, only safe
20:21:00 <audreyt> jeeves_bond: it's like Maybe, only that Nothing carriest an error message type
20:21:01 <jcreigh> @src Either
20:21:02 <lambdabot> Source not found. Wrong!  You cheating scum!
20:21:09 <nrb23> I'm messing around with the pcap library
20:21:15 <sorear> data Either a b = Left a | Right b
20:21:29 <audreyt> jeeves_bond: typically, "Left" is used for the error case and Right is used for the Just case
20:21:40 <sorear> so if your function can return in two ways with different types, you can use Either way1 way2
20:21:48 <jeeves_bond> Hmmmm. I've haven't used C for a long time. :)
20:21:52 <audreyt> f :: SomeInput -> Either ErrorMessage NormalResult
20:21:53 <sorear> *usually*, way1 is an error case
20:22:02 <audreyt> is a usual use case
20:22:04 <sorear> jeeves_bond: I came from C and assume everyone else did
20:22:26 <nrb23> ahh, C
20:22:57 <jeeves_bond> So, it's used when you want Maybe, but with a return value instead of nothing?
20:23:06 <sorear> jeeves_bond: also, we're trying to create newbie land but few of the experts know it exists (yet)
20:23:10 <sorear> jeeves_bond: exactly.
20:23:14 <audreyt> jeeves_bond: yup.
20:23:16 <mauke> myParser :: Parser Error Result
20:23:22 <mauke> er, Either Error Result
20:23:34 <sorear> @type Language.Haskell.Parser.parseModule
20:23:37 <lambdabot> String -> Language.Haskell.ParseMonad.ParseResult Language.Haskell.Syntax.HsModule
20:23:41 <bd_> mauke: String -> Parser Error Result, I hope :)
20:23:53 <mauke> I'm so confused :(
20:24:06 <audreyt> bd_: ah, but you see, (Parser Error) is actually a monad :)
20:24:16 <mauke> Parser = String -> Either Error Result
20:24:16 <bd_> audreyt: ooh, tricky
20:24:18 <sorear> @quote explote
20:24:19 <lambdabot> No quotes match. That's something I cannot allow to happen.
20:24:21 <sorear> @quote explode
20:24:21 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
20:24:23 <hpaste>  nrb23 pasted "ambigous type variable" at http://hpaste.org/405
20:24:25 <bd_> audreyt: Is the Error even needed there then? :)
20:24:27 <sorear> @quote exploded
20:24:28 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
20:24:33 <jeeves_bond> sorear: that's ok, as long as you don't mind me asking in here. :)
20:24:39 <audreyt> bd_: so maybe it's an Arrow
20:24:42 <nrb23> can anyone give a hand with the error I'm getting in that paste?
20:24:44 <audreyt> j/k :)
20:24:51 <bd_> audreyt: Ah, it's an error-message parser? Makes sense.
20:25:00 <audreyt> it parses textual errors
20:25:02 <audreyt> into structured ones
20:25:03 <audreyt> exactly
20:25:43 <audreyt> I wrote a module for that... to enable adhoc localization
20:25:44 <bd_> audreyt: The question now is, of course, does it have a fixpoint?
20:25:45 <jeeves_bond> So why the left and right? That sort of confused me
20:26:14 <bd_> jeeves_bond: Either is more general than just an error monad, and Left/Right are just as good at expressing a dichotomy as anything else.
20:26:15 <sorear> jeeves_bond: so you can tell the difference between the two types an either can hold.
20:26:18 <audreyt> jeeves_bond: right is what's Right; left is what's left
20:26:25 <bd_> Plug 'Right' is sort of like 'it worked Right'
20:26:27 <nrb23> please?
20:26:28 <bd_> plus*
20:26:44 <sorear> nrb23: you need a more specific type on Nothing
20:27:03 <sorear> nrb23: all Nothings print the same, but the typechecker doesn't know that
20:27:11 <sorear> nrb23: try (Nothing :: Maybe ())
20:27:18 <nrb23> hm
20:27:22 <bd_> sorear: Would GADTs help here?
20:27:35 <bd_> hmm
20:27:40 <sorear> bd_: no
20:27:52 <gotaku> On pattern matching a Maybe what is the point of matching first Just, Nothing and then _?
20:27:57 <bd_> sorear: Show a => [...] -> Maybe a -> ... ?
20:28:09 <sorear> gotaku: none, which is why ghc will warn you (with -Wall)
20:28:25 <hpaste>  nrb23 annotated "ambigous type variable" with "try again" at http://hpaste.org/405#a1
20:28:27 <sorear> bd_: wouldn't help
20:28:30 <allbery_b> gotaku: f the Just case also matches some other pattern, e.g. Just (Foo a)
20:28:37 <nrb23> sorear: it still doesn't work :<
20:28:42 <allbery_b> is the only reason I can think of
20:28:47 <bd_> sorear: Why not? You might need to manually write a Show instance...
20:29:01 <gotaku> http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&id=3
20:29:03 <lambdabot> Title: mandelbrot Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Co ..., http://tinyurl.com/39svnz
20:29:04 <bd_> Of course you'd need to also put Typeable in the context so you could cast it to something useful
20:29:08 <sorear> oh right...
20:29:11 <bd_> or actually
20:29:16 <gotaku> ^^^ That is the code I'm curious about. In the "go" function.
20:29:19 <bd_> parameterize it, but constrain the constructor to Show
20:29:26 <dibblego> :t memo
20:29:28 <lambdabot> Not in scope: `memo'
20:29:31 <dibblego> :t memoize
20:29:33 <lambdabot> Not in scope: `memoize'
20:29:46 <bd_> actually!
20:29:49 <dibblego> ?hoogle Ord a => (a -> b) -> a -> b
20:29:51 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
20:29:51 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
20:29:51 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
20:29:52 <jeeves_bond> Ok, that's brilliant. Thanks very much for the help! helpJeeves :: StupidJeeves -> CleverJeeves
20:29:58 <bd_> hmm maybe not
20:29:58 <sorear> nrb23: bah, sorry.  you need a specific type *that is an instance of Pkt*.  since there are none in your paste...
20:30:17 <allbery_b> sure, so _ matches the case where the guard fails?
20:30:41 <hpaste>  nrb23 annotated "ambigous type variable" with "fixed!" at http://hpaste.org/405#a2
20:30:41 <hpaste>  sorear annotated "ambigous type variable" with "Loosen constraint :(, allowing code to typecheck" at http://hpaste.org/405#a3
20:31:14 <sorear> I suppose both will work :)
20:31:54 <sorear> gotaku, allbery_b: yes. if guard fails.
20:32:00 <bd_> sorear: If one adds a Show constraint, will that add an appropriate dictionary to the type representation, allowing one to use show without using a specific type?
20:32:10 <chessguy> > let f = execState . mapM modify [(*2),(+1)] 3
20:32:10 <lambdabot>  Parse error
20:32:33 <chessguy> > let f = execState . mapM modify in f [(*2),(+1)] 3
20:32:35 <lambdabot>  7
20:32:37 <sorear> bd_: it would only shift the problem - the caller would need to provide an appropriate type
20:32:51 <sorear> chessguy: f = mconcat . reverse
20:32:53 <bd_> hmm, I see.
20:32:54 <nrb23> cool.. now I just need to come up with a good representation for the MAC addresses
20:33:00 <bd_> since Nothing still needs to be instantiated
20:33:01 <xpika> @hoogle Maybe a -> a
20:33:02 <lambdabot> Maybe.fromJust :: Maybe a -> a
20:33:03 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
20:33:03 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
20:33:10 <chessguy> @type execState . mapM modify
20:33:12 <lambdabot> forall s. [s -> s] -> s -> s
20:33:16 <sorear> ?quote spryn
20:33:17 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
20:33:26 <sorear> xpika: for you ^^^
20:33:32 <chessguy> how can this work outside the state monad?
20:33:47 <sorear> chessguy: huh?  mconcat.reverse doesn't do it?
20:33:52 <gotaku> I didn't know you could use guards like that...
20:33:53 <bd_> :t foldr (.) id
20:33:55 <lambdabot> forall a. [a -> a] -> a -> a
20:34:00 <bd_> that's how it works :)
20:34:01 <chessguy> sorear, i'm talking about my code
20:34:11 * xpika gasps :O!
20:35:25 <allbery_b> hm, actually, I didn't either.  I thought the case pattern was already "committed" at that point
20:35:33 <chessguy> > let f = mconcat.reverse in f [(*2),(+1)] 3
20:35:34 <lambdabot>  7
20:36:13 <bd_> :t mconcat
20:36:15 <lambdabot> forall a. (Monoid a) => [a] -> a
20:36:23 <bd_> aha
20:36:30 <chessguy> anyway, how can that not have some kind of State in its type signature?
20:36:36 <sorear> don't try this on 6.6, kids
20:36:42 <bd_> chessguy: Why would it need State?
20:36:50 <sorear> chessguy: execState removes the stateyness
20:37:02 <bd_> oh, right
20:37:09 <bd_> didn't see the scrollup
20:37:11 <chessguy> ?type execState
20:37:12 <lambdabot> forall s a. State s a -> s -> s
20:37:16 <bos31337> @src guard
20:37:16 <lambdabot> guard True  =  return ()
20:37:17 <lambdabot> guard False =  mzero
20:37:23 <bos31337> @hoogle guard
20:37:24 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
20:37:24 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
20:37:24 <lambdabot> Language.Haskell.TH.Guard :: data Guard
20:37:37 <sorear> bos31337: are you looking for "when" ?
20:37:48 <sorear> or "assert"
20:37:59 <bos31337> assert, i think.
20:38:03 <bos31337> thanks.
20:38:14 <bd_> @check \f g a -> ((f :: Int -> Int) . (g :: Int -> Int) $ a) == (f `mappend` g) a
20:38:14 <bos31337> @t assert
20:38:15 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:38:16 <lambdabot>  OK, passed 500 tests.
20:38:27 <bos31337> @type assert
20:38:29 <lambdabot> Not in scope: `assert'
20:38:38 <sorear> @ty GHC.Exts.assert
20:38:40 <lambdabot> Not in scope: `GHC.Exts.assert'
20:38:42 <bd_> @index assert
20:38:42 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
20:38:46 <bos> ah
20:38:49 <sorear> @ty Control.Exception.assert
20:38:51 <lambdabot> forall a. Bool -> a -> a
20:39:21 <sorear> if you're in a monad, use unless good $ fail "yow!"
20:39:45 <bd_> @index failWhen
20:39:45 <lambdabot> bzzt
20:39:47 <bd_> hmm
20:39:51 <bd_> that really should exist
20:40:05 <sorear> @pl (unless .) . fail
20:40:06 <lambdabot> (unless .) . fail
20:40:15 <bd_> @unpl (unless .) . fail
20:40:16 <lambdabot> (\ d g -> unless (fail d g))
20:40:18 <chessguy> @quote sequence
20:40:18 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
20:40:23 <chessguy> @quote sequence
20:40:24 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
20:40:27 <chessguy> @quote sequence
20:40:27 <lambdabot> skew says: [monads are] just like the sequences of statements in other languages. Except very rarely have they thought so deeply about what that sequencing means
20:40:29 <bd_> @pl \c f -> unless c $ fail f
20:40:30 <lambdabot> (. fail) . unless
20:40:37 <chessguy> @quote aahh
20:40:37 <lambdabot> No quotes match. You speak an infinite deal of nothing
20:40:41 <bd_> @ghc
20:40:41 <lambdabot> ghc says: Its main purpose is to encapsulate the Horrible State Hack
20:40:45 <bd_> heh
20:41:00 <nrb23> any suggestions for a good way to represent 6 Uint8 values?
20:41:03 <bd_> what's that from? zero google hits...
20:41:03 <chessguy> ?uptime
20:41:04 <lambdabot> uptime: 17h 36s, longest uptime: 2d 3h 42m 19s
20:41:11 <bd_> nrb23: Depends, what are you going to do with them?
20:41:15 <bd_> There are many options
20:41:39 <chessguy> @quote seq
20:41:40 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
20:41:42 <sorear> !Word8 !Word8 !Word8 !Word8 !Word8 !Word8
20:41:57 <nrb23> bd_: not quite sure yet...
20:42:00 <bd_> Starting with: data Thingy = Thingy !Word8 !Word8 !Word8 !Word8 !Word8 !Word8 -- with -funbox-strict-fields
20:42:31 <nrb23> can I automatically generate derving Eq for that?
20:42:41 <sorear> yes!!
20:43:14 <nrb23> cool, I'll try it
20:43:38 <nrb23> does -fglasgow-exts imply -funbox-strict-fields ?
20:43:56 <bd_> I don't think so. -funbox-strict-fields isn't an extension, it's a change to the codegen.
20:44:06 <bd_> I think it's valid in an OPTIONS_GHC pragma though
20:44:12 <nrb23> ok
20:44:15 <bd_> it's not strictly needed, but it'll improve CPU and memory usage
20:44:20 <bd_> [why isn't it default, or is it?]
20:44:30 * nrb23 wants improved CPU usage :->
20:44:48 <bd_> nrb23: You can derive Ord, Show, Enum, Bounded, and Read, too :)
20:45:02 <bd_> well maybe not Enum, its range is wider than Int
20:45:15 <bd_> you'll need to import Data.Word of course
20:45:26 <nrb23> I'm not sure I want Ord or Bounded
20:45:47 <nrb23> these are Ethernet MAC addresses... I'll mostly just be comparing them
20:46:04 <bd_> nrb23: Ord is useful to put them in a Data.Map
20:46:15 <nrb23> bd_: ahh, good point
20:46:30 <bd_> and if you don't use it, it's free anyway, so might as well.
20:46:37 <nrb23> true
20:47:15 <bos> is it unusual to have an expression of this kind of length? fmap fromJust . listToMaybe . map (matchDigits . fixMatches) . sortBy cmpScores . catMaybes . map bong . tails
20:47:49 <sorear> no
20:48:15 <bos> would it be more normal to break it up into chunks with a let or where clause?
20:48:22 <chessguy> map bong?
20:48:45 <rahikkala> @type (fmap fromJust . listToMaybe)
20:48:46 <sorear> catMaybes . map foo ==> mapMaybe foo
20:48:47 <lambdabot> forall a. [Maybe a] -> Maybe a
20:49:01 <bos> i tend to run out of good names when i'm hacking without a clear idea of where i'm going.
20:49:09 <sorear> listToMaybe commutes with map/fmap
20:49:35 <bos> ooh, didn't know about mapMaybe.
20:49:52 <sorear> listToMaybe . map (fromJust . matchDigits . fixMatches) . sortBy cmpScores . mapMaybe bong . tails
20:50:17 <bd_> hmm
20:50:29 <bd_> :t catMaybes
20:50:30 <chessguy> @pl fmap fromJust . listToMaybe . map (matchDigits . fixMatches) . sortBy cmpScores . catMaybes . map bong . tails x
20:50:31 <lambdabot> fmap fromJust . listToMaybe . map (matchDigits . fixMatches) . sortBy cmpScores . catMaybes . map bong . tails x
20:50:31 <sorear> fmap (fromJust . matchDigits . fixMatches) . listToMaybe . sortBy cmpScores . mapMaybe bong . tails
20:50:31 <lambdabot> forall a. [Maybe a] -> [a]
20:50:47 <bd_> > listToMaybe []
20:50:47 <bos> yes, that tidies it up nicely.
20:50:48 <lambdabot>  Add a type signature
20:50:52 <bd_> > listToMaybe [] :: Maybe Int
20:50:53 <lambdabot>  Nothing
20:50:54 <bd_> > listToMaybe [1] :: Maybe Int
20:50:56 <lambdabot>  Just 1
20:50:58 <bd_> > listToMaybe [1,2] :: Maybe Int
20:50:59 <lambdabot>  Just 1
20:51:33 <chessguy> ?src listToMaybe
20:51:33 <lambdabot> listToMaybe []        =  Nothing
20:51:34 <lambdabot> listToMaybe (a:_)     =  Just a
20:51:44 <bos> i suspect that my haskell code has the readability of ass.
20:51:49 <bd_> join . fmap (matchDigits . fixMatches) . listToMaybe . sortBy cmpScores . mapMaybe bong . tails
20:52:00 <bd_> fromJust considered harmful :)
20:52:46 <allbery_b> mmm, partial functions considered harmful
20:53:06 <bos> bd_: yes, fromJust is actually wrong in that case.
20:53:18 <bd_> heh :)
20:53:38 <bos> it's easy to use it in the belief that you'll never get Nothing
20:53:51 <bd_> in that case... maybe the listToMaybe should be elsewhere?
20:54:09 <sorear> if you believe that so badly, why don't you change the type of the rhs :)
20:54:13 <bos> i need to fiddle further with the expression.
20:54:18 <sorear> doh!
20:54:29 <bos> i literally just got it to typecheck and produce a correctish result.
20:54:39 <bos> refactoring it is still very much in need :-)
20:54:40 <bd_> join . listToMaybe . filter (isJust . fmap (matchDigits . fixMatches) . sortBy cmpScores . mapMaybe bong . tails
20:54:43 <bd_> ?
20:54:48 <bd_> er, no ( before isJust ofc
20:54:52 <sorear> \x -> (matchDigits . fixMatches) =<< (listToMaybe . sortBy cmpScores . mapMaybe bong . tails) x
20:55:14 <sorear> (matchDigits . fixMatches) <=< (listToMaybe . sortBy cmpScores . mapMaybe bong . tails)
20:55:30 <sorear> monads++
20:56:35 <bos> ok, tidier, and less obviously buggy: listToMaybe . mapMaybe (matchDigits . fixMatches) . sortBy cmpScores . mapMaybe bong . tails
20:56:48 <chessguy> ?type mapMaybe
20:56:50 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
20:57:06 <nrb23> hmm, here's a question, how do I convert 2 Word8s into one Word16
20:57:19 <bos> nrb23: bitfiddle them
20:57:21 <nrb23> in C I'd do w1 << 8 | w2
20:57:27 <nrb23> @bitfiddle
20:57:27 <lambdabot> Unknown command, try @list
20:57:29 <sorear> how about
20:57:32 <sjanssen> nrb23: use Data.Bits.shiftL and fromIntegral
20:57:33 <nrb23> @:t bitfiddl
20:57:35 <chessguy> @google bitfiddle
20:57:35 <lambdabot>  There was an error in the type: (line 1, column 4):
20:57:35 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
20:57:37 <lambdabot> http://www.info.uni-karlsruhe.de/~uebprakt/WS0506/doc/a00402.html
20:57:39 <bos> w1 `shiftL` 8
20:57:42 <sorear> w1 `shiftL` 8 .|. w2
20:57:55 <lispy> > 2 `shiftL` 8 .|. 5
20:57:56 <lambdabot>  Add a type signature
20:57:59 <lispy> > 2 `shiftL` 8 .|. 5 :: Int
20:58:00 <lambdabot>  517
20:58:02 <bos> w1 `shiftL` 8 .|. w2
20:58:05 <sorear> (fromIntegral w1) `shiftL` 8 .|. (fromIntegral w2)
20:58:23 <nrb23> huh.. when I tried that it hated me
20:59:12 <sorear> nrb23: didja "import Data.Bits" ?
20:59:18 <nrb23> yes
20:59:47 <nrb23> ah, the fromIntegral one works
20:59:53 <nrb23> but without it, it doesn't
20:59:58 <sorear> true.
21:00:05 <nrb23> :t fromintegral
21:00:07 <lambdabot> Not in scope: `fromintegral'
21:00:12 <nrb23> :t fromIntegral
21:00:14 <lambdabot> forall b a. (Num b, Integral a) => a -> b
21:00:14 <sorear> haskell doesn't do automatic upcoercions like C
21:00:25 <sorear> so your expression must all be one type
21:00:35 <nrb23> sorear: yeah, that makes sense
21:00:39 <sorear> fromIntegral generically converts between integral types
21:00:48 <nrb23> I just wasn't thinking about the types.. I was thinking about the classes
21:00:49 <sorear> rather, from integral types
21:00:59 <sorear> > (1 :: Int) :: Int64
21:01:00 <lambdabot>  Couldn't match `Int64' against `Int'
21:01:08 <sorear> > fromIntegral (1 :: Int) :: Int64
21:01:10 <lambdabot>  1
21:01:16 <sorear> > fromIntegral (1 :: Int) :: Double
21:01:17 <lambdabot>  1.0
21:01:23 <sorear> > fromIntegral (1 :: Double) :: Int
21:01:24 <lambdabot>   add an instance declaration for (Integral Double)
21:01:24 <nrb23> what's the implementation of that look like?
21:01:24 <lambdabot>     In the expression: fr...
21:01:36 <sorear> @src fromIntegral
21:01:36 <lambdabot> fromIntegral = fromInteger . toInteger
21:02:00 <nrb23> @src fromInteger
21:02:00 <lambdabot> Source not found. I feel much better now.
21:02:03 <sorear> both toInteger and fromInteger are overloaded, in Integral and Num respectively
21:02:09 <nrb23> ah
21:02:22 <nrb23> @src fromInteger :: Word8
21:02:22 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:02:35 <sorear> so everyone who defines a type of integer needs to implement toInteger, and everyone who impleements a number needs to write fromInteger
21:02:42 <sorear> @src Word8 fromInteger
21:02:43 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:02:53 <sorear> ^^ would be the correct syntax
21:02:57 <chessguy> @quote penguin
21:02:57 <lambdabot> int-e says: PHP is a programming language like penguins are birds. And people try to make it fly.
21:03:50 <nrb23> heh
21:03:52 <sorear> nrb23: http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Word.hs
21:04:01 <sorear> about 25% down
21:04:45 <sorear> wtf? "Word8 is represented in the same way as Word."
21:04:48 <nrb23> I'm not familar with S#
21:04:54 <nrb23> or i# for that matter
21:04:59 <sorear> nrb23: ie a Word8 uses 32 bits
21:05:12 <sorear> nrb23: they're the constructors of Integer
21:05:15 <sorear> @src Integer
21:05:16 <lambdabot> data Integer = S# Int#
21:05:16 <lambdabot>              | J# Int# ByteArray#
21:05:31 <sorear> this is pretty deep in the compiler
21:05:32 <bd_> nrb23: anything with a # in it is GHC-internal magic
21:05:36 <nrb23> ah
21:05:36 <nrb23> ok
21:05:54 <sjanssen> wow -- Word8 is actually a Word#?
21:06:13 <sorear> sjanssen: you're suprised too?
21:06:16 <nrb23> so, crazy GHC magics in ther
21:06:19 <sjanssen> sorear: yes
21:08:02 <sjanssen> seems ridiculous to perform word arithmetic and mask the result every time
21:09:04 <nrb23> @pl ethTypeFromList f:f2:[] = (fromIntegral f) `shiftL` 8 .|. (fromIntegral f2) :: Word16
21:09:04 <lambdabot> (line 1, column 25):
21:09:05 <lambdabot> unexpected "="
21:09:05 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
21:09:30 <sorear> nrb23: sorry. @pl doesn't do pattern matching.
21:09:38 <nrb23> oops
21:09:45 <allbery_b> or full functions
21:09:50 <nrb23> @pl ethTypeFromList f f2 = (fromIntegral f) `shiftL` 8 .|. (fromIntegral f2)
21:09:51 <lambdabot> ethTypeFromList = (. fromIntegral) . (.|.) . (`shiftL` 8) . fromIntegral
21:10:01 <allbery_b> hm, gues it does
21:10:11 <nrb23> hm.. the pointful version is easier to read
21:12:11 * nrb23 can't remember how to pattern match lists :-<
21:13:07 <nrb23> macFromList w1:w2:w3:w4:w5:w6:[] = MACAddr w1 w2 w3 w4 w5 w6
21:14:10 <sorear> macFromList (w1:w2...:[])
21:14:14 <sorear> -OR-
21:14:17 <lispy> > let foo a:b:c:d:[] = 1 in foo ['a','b','c','d']
21:14:18 <lambdabot>  Parse error in pattern
21:14:23 <lispy> > let foo (a:b:c:d:[]) = 1 in foo ['a','b','c','d']
21:14:24 <lambdabot>  1
21:14:28 <sorear> macFromList [w1,w2,w3,w4,w5,w6]
21:14:44 <sorear> > let foo [a,b,c,d] = 1 in foo "abcd"
21:14:45 <lambdabot>  1
21:17:34 <nrb23> wait, If I have data MACAddr = MACAddr !Word8 !Word8 !Word8 !Word8 !Word8 !Word8, how do I construct one?
21:17:52 <sjanssen> MACAddr w1 w2 w3 ...
21:17:58 <nrb23> hm
21:18:06 <nrb23> must have a typo somewhere
21:18:34 <sorear> It might be better to store it as a single Word64
21:18:46 <bd_> sorear: Less convenient to work with though
21:18:51 <bd_> well, depending
21:18:57 <sorear> newtype MACAddr = MACAddr Word64 deriving (Eq,Ord,Num,Bits)
21:19:16 <nrb23> yeah, that might work better
21:19:31 <sjanssen> sorear's solution will occupy much less memory
21:19:37 <lispy> i'd go with whatever reperesentation most directly fits what you'll be doing with it...transforming data in haskell is easy...so just use what is convienent and transform as needed
21:19:46 <sjanssen> (even if you unboxed those strict Word8 fields)
21:19:48 <sorear> bd_: Wor64 gives non-tedious vector ops (or, and, etc) and less chance of accidentally permuting the vector...
21:19:57 <bd_> hm, point
21:20:07 <sjanssen> I'm really disappointed that Word8 is Word#
21:20:09 <sorear> sjanssen: I should mention both solutions were mine :)
21:20:32 <sorear> @src Char
21:20:33 <lambdabot> data Char = C# Char#
21:20:45 <sorear> mm. what's the range of Char#?
21:20:54 <allbery_b> > maxBound :: Char
21:20:55 <lambdabot>  '\1114111'
21:21:11 <sjanssen> sorear: it should be stored as a Word32#
21:21:29 <sjanssen> (if there is such a thing)
21:26:16 <sjanssen> anybody have ghc on a 64 bit machine?
21:26:23 <bd_> sjanssen: I do.
21:26:33 <bos> me too.
21:26:33 <sjanssen> what is the output of "GHC.Base.unsafeChr maxBound"?
21:26:48 <bd_> '\9223372036854775807'
21:26:59 <sjanssen> sorear: ^^^ there is your answer
21:27:48 <sjanssen> also fun: unsafeChr (-1)
21:28:06 <bd_> '\-1'
21:28:07 <bd_> heh
21:28:37 <allbery_b> fun
21:29:40 <sorear> ow.
21:29:40 <bd_> Prelude> GHC.Base.unsafeCoerce# GHC.Base.realWorld# :: ()
21:29:43 <bd_> and then, the world exploded
21:29:50 <sorear> CompactString ftw
21:30:14 <sorear> how badly ?  *morbid curiousity*
21:30:46 <sjanssen> just a segfault for me
21:30:58 <bd_> sorear: The RealWorld vanished down a segmentation fault line, alas
21:32:28 <sjanssen> thats what you get for thinking outside the Box#
21:32:43 <master_baiter> http://www.fysh.org/~katie/computing/surgeons.txt
21:33:00 <bd_> Haskell: We make easy things easy, hard things possible, and impossible things segfault.
21:33:59 <sorear> so, is a segfault considered _|_? :p
21:34:16 <olliej> bd_: wow, that *is* unsafe
21:34:23 <bd_> I suppose that is a valid interpretation :)
21:34:45 <sjanssen> segfault `seq` x <=> segfault
21:34:58 <nrb23> @pl ethTypeFromList f f2 s = (fromIntegral f) `shiftL` s .|. (fromIntegral f2)
21:34:59 <lambdabot> ethTypeFromList = (. fromIntegral) . flip . ((.|.) .) . shiftL . fromIntegral
21:37:05 <sorear> the linux disk cache is so good here that "disk light flashed" almost invariably means "you have mail" ...
21:41:02 <bos> @pl \x -> concatMap (take 1) x
21:41:03 <lambdabot> (take 1 =<<)
21:41:55 <sorear> or mapMaybe listToMaybe
21:42:07 <sorear> or head . transpose
21:42:27 <hyrax42> :t mapMaybe
21:42:29 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
21:42:44 <sorear> > transpose [[1],[],[2]]
21:42:46 <lambdabot>  [[1,2]]
21:42:48 <sorear> > transpose []
21:42:50 <lambdabot>  Add a type signature
21:42:54 <sorear> > transpose [] :: [[Int]
21:42:55 <lambdabot>  Parse error
21:42:56 <sorear> > transpose [] :: [[Int]]
21:42:57 <lambdabot>  []
21:43:01 <sorear> gah.
21:43:12 <sorear> head . (++[[]]) . transpose
21:43:12 <bos> > concatMap (take 1) [[1,2],[3,4]]
21:43:14 <lambdabot>  [1,3]
21:43:28 <nrb23> if I have a list of functions [a->b], and a list [a], is there a standard function to make a list [b]
21:43:30 <sorear> > map head [[1,2],[3,4]]
21:43:31 <lambdabot>  [1,3]
21:43:32 <bos> > concatMap (take 1) [[1,2],[],[3,4]]
21:43:33 <lambdabot>  [1,3]
21:43:39 <sorear> nrb23: zipWith ($)
21:43:49 <sorear> > zipWith ($) [negate, (*2)]  [3, 5]
21:43:51 <lambdabot>  [-3,10]
21:43:56 <sorear> nrb23: good?
21:44:06 <nrb23> that's what I was looking for, thanks
21:44:09 <dibblego> :t orList
21:44:11 <sorear> zipWith id is shorter ...
21:44:11 <lambdabot> Not in scope: `orList'
21:44:16 <sorear> :t or
21:44:17 <lambdabot> [Bool] -> Bool
21:44:21 <sorear> :t any
21:44:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:44:29 <sorear> :t zipWith (||)
21:44:31 <lambdabot> [Bool] -> [Bool] -> [Bool]
21:44:37 <sorear> dibblego: one of those?
21:44:45 <dibblego> sorear, yeah, wrong language :)
21:44:57 <sorear> dibblego: what's orList in? (jc)
21:45:03 <dibblego> CAL
21:45:13 <vincenz> Moin
21:45:29 <sorear> I knew it!  Dons is everyone! :p
21:46:10 <nrb23> hmm zipWith id $  map (flip (shiftL . fromIntegral. (*8)))  [0..5] $ [1,1,1]
21:46:29 <nrb23> hates me :<
21:46:33 <nrb23> > zipWith id $  map (flip (shiftL . fromIntegral. (*8)))  [0..5] $ [1,1,1]
21:46:34 <lambdabot>      Expecting a function type, but found `[b]'
21:46:34 <lambdabot>       Expected type: a -> b
21:46:34 <lambdabot>  ...
21:46:36 <sorear> mm.
21:46:41 <sorear> needs more points.
21:47:13 <sorear> (I assume your market is *not* the IOHCC?) :p
21:47:25 <nrb23> ?
21:47:45 <sorear> IOHCC : IOCCC  ::  Haskell : C
21:47:48 <allbery_b> obfuscated haskell contest :)
21:47:53 <nrb23> ah
21:48:00 <mauke> > zipWith (\x y -> shiftL x . fromIntegral $ y*8) [1,1,1] [0..5]
21:48:01 <lambdabot>  Add a type signature
21:48:34 <vincenz> sorear: what?
21:48:59 <mauke> > zipWith (\x y -> shiftL x . fromIntegral $ y*8) [1,1,1] [0..5] :: [Int]
21:49:01 <lambdabot>  [1,256,65536]
21:49:15 <xpika> @hoogle Ix i => [(i,a)] -> array (i,i) [(i,a)]
21:49:16 <lambdabot> Did you mean: Ix i => [(i, a)] -> Array (i, i) [(i, a)]
21:49:31 <xpika> @yes
21:49:32 <lambdabot> Maybe you meant: let yow
21:49:38 <mauke> @yow
21:49:39 <lambdabot> Kids, the seven basic food groups are GUM, PUFF PASTRY, PIZZA,
21:49:39 <lambdabot> PESTICIDES, ANTIBIOTICS, NUTRA-SWEET and MILK DUDS!!
21:49:42 <vincenz> > zipWith (flip (shiftL . fromIntegral . (*8))) [1,1,1] [0..5]
21:49:42 <lambdabot>  Add a type signature
21:49:48 <vincenz> > zipWith (flip (shiftL . fromIntegral . (*8))) [1,1,1] [0..5] :: [Integer]
21:49:49 <lambdabot>  [0,16,32]
21:49:53 <sorear> vincenz: announcing with moin may be german but it's still *very* characteristic dons
21:49:59 <vincenz> sorear: oh roight
21:50:07 <vincenz> I will get my own signature phrase then :)
21:50:16 <xpika> @hoogle Ix i => [(i, a)] -> Array (i, i) [(i, a)]
21:50:17 <lambdabot> No matches, try a more general search
21:50:33 <xpika> does anyone know such a function?
21:50:49 <sorear> flip (//)
21:50:50 <vincenz> > zipWith (flip shiftL . fromIntegral . (*8)) [1,1,1] [0..5] :: [Integer]
21:50:52 <sjanssen> xpika: what does it do?
21:50:52 <lambdabot>  [0,256,512]
21:50:53 <sorear> :t flip (//)
21:50:55 <lambdabot> forall i e. (Ix i) => [(i, e)] -> Array i e -> Array i e
21:51:11 <vincenz> > zipWith (flip(flip shiftL . fromIntegral . (*8))) [1,1,1] [0..5] :: [Integer]
21:51:13 <lambdabot>  [1,256,65536]
21:51:16 <vincenz> there you go
21:51:18 <sjanssen> xpika: you want to automatically determine the bounds?
21:51:19 <bd_> xpika: You need to provide the range of the array to construct it... and... I think you might have the array type confused?
21:51:22 <bd_> :t listArray
21:51:24 <lambdabot> forall e i. (Ix i) => (i, i) -> [e] -> Array i e
21:51:28 <sorear> :t \ l a -> map (first (a !)) l
21:51:29 <bd_> :t array
21:51:30 <lambdabot> forall b d e. (Ix b) => [(b, d)] -> Array b e -> [(e, d)]
21:51:31 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
21:51:37 <nrb23> woot
21:51:54 <nrb23> vincenz: thanks, I see where my stupidity lay
21:51:56 <xpika> listArray would work, however i need to set the positions aswell
21:52:03 <vincenz> nrb23: you had to flip the shiftL as well
21:52:18 <vincenz> nrb23: I only figured it out after rethinking it twice as well
21:52:57 <nrb23> > foldr1 (.|.) $ zipWith (flip (flip (shiftL . fromIntegral . (*8))))  [0..5] [1, 1, 1] :: Word64
21:52:59 <lambdabot>  48
21:53:08 <xpika>  array (0,51) [(10,[50]),(35,[10]),(50,[]),(8,[35]),(46,[8]),(40,[28]),(28,[])]
21:53:12 <xpika> array (0,51) [(0,*** Exception: (Array.!): undefined array element
21:53:24 <mauke> @unpl foldr1 (.|.) $ zipWith (flip (flip (shiftL . fromIntegral . (*8))))  [0..5] [1, 1, 1]
21:53:24 <lambdabot> (foldr1 (.|.) (zipWith (\ b c -> shiftL (fromIntegral (b * 8)) c) [0 .. 5] [1, 1, 1]))
21:53:34 <sorear> xpika: you need to set *all* elements...
21:54:17 <xpika> yea, i need it padded out with []'s
21:54:59 <sorear> hello dmead
21:55:14 <dmead> hi
21:55:49 <hpaste>  bos pasted "i assume findEAN is in better style?" at http://hpaste.org/406
22:13:53 <fishkandy> erm ... can anyone tell me the physical thickness of the paperback version of Hudak's "The Haskell school of expression"?
22:14:52 <mbishop> fishkandy: hmm, half an inch? I can measure if you like
22:15:17 <fishkandy> ah ok -- I'm just wondering whether the paperback or hardcover is a better option
22:17:30 <fishkandy> ie. if it was bulky, the hardcover would probably get less damaged over time
22:19:39 <vincenz> fishkandy: you could cast it into lucite after having read it
22:21:32 <fishkandy> vincenz, good idea, that should prevent the zombies from the math department getting their hands on it
22:21:55 <vincenz> :)
22:23:50 <glguy> ?seen shapr
22:23:50 <lambdabot> I saw shapr leaving #haskell-blah and #haskell 5h 30m 50s ago, and .
22:26:11 <bos> is there a less horrible way to pick apart a list into two 24-element chunks separated by a 5-element chunk than this?
22:26:14 <bos> let (l, (_, r)) = (second (second (take 24) . splitAt 5) . splitAt 24) rl
22:28:53 <fishkandy> bos: one splitAt 29 and one drop 5?
22:29:27 <fishkandy> erk
22:30:03 <nrb23> so, why would I get a Not In Scope error on a type declaration line?
22:32:11 <fishkandy> bos: perhaps i meant one splitAt 24 and one drop 5 :-)
22:35:26 <allbery_b> @paste -- nrb23, show us your source
22:35:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:35:57 <hpaste>  nrb23 pasted "sadness" at http://hpaste.org/407
22:36:52 <allbery_b> and the error is where?
22:36:58 <nrb23> line 22
22:37:28 <nrb23> test2.hs:22:0: Not in scope: `ethTypeFromlist'
22:37:33 <allbery_b> typo
22:37:44 <allbery_b> ethTypeFromList != ethTypeFromlist
22:37:48 <nrb23> damnit
22:37:59 <nrb23> I shouldn't try to do this after a long day at work
22:41:23 <hpaste>  nrb23 annotated "sadness" with "more sadness" at http://hpaste.org/407#a1
22:47:15 <bos> @pl \f x -> (sum . map f) x
22:47:16 <lambdabot> (sum .) . map
22:49:18 <allbery_b> hm, I ask ghci for the type of combineWords and get (Bits b) => [Int] -> b
22:53:27 <allbery_b> ah.  you have the arguments to shiftL reversed, I think
22:53:49 <fishkandy> ah finally, good advice about books on type theory: http://www.yellow5.com/pokey/archive/index473.html
22:54:14 <allbery_b> but after you fix that you'll run into the problem that you're working with Word8 and expecting a Word64 result
22:55:02 <allbery_b> I think you want a fromIntegral on c to force it to upconvert to Word64
22:58:20 <hpaste>  allbery_b annotated "sadness" with "fix Word8-Word64 and flip arguments to shiftL" at http://hpaste.org/407#a2
23:01:21 <hpaste>  allbery_b annotated "sadness" with "cleanup: second fromIntegral not needed" at http://hpaste.org/407#a3
23:06:52 <nrb23> I seem to have it now
23:06:53 <nrb23> :->
23:06:56 <nrb23> thanks again
23:08:14 <abz> ?poll-list
23:08:15 <lambdabot> ["Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
23:08:37 <abz> ?poll-results Written_a_compiler_or_interpreter?
23:08:38 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=4, Yes=14
23:10:34 <nrb23> how do I participate in a poll?
23:10:37 <nrb23> @help poll
23:10:37 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
23:10:43 <nrb23> vote
23:10:46 <nrb23> @vote
23:10:46 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
23:10:51 <nrb23> @help vote
23:10:51 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
23:11:04 <nrb23> @vote "Written_a_compiler_or_interpreter?" Yes
23:11:05 <lambdabot> No such poll:"\"Written_a_compiler_or_interpreter?\""
23:11:13 <nrb23> @vote Written_a_compiler_or_interpreter? Yes
23:11:14 <lambdabot> voted on "Yes"
23:15:46 <allbery_b> @quote compiler.*tutorial
23:15:46 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
23:17:38 <vincenz> x@vote Written_a_compiler_or_interpreter? Yes
23:17:41 <vincenz> @vote Written_a_compiler_or_interpreter? Yes
23:17:42 <lambdabot> voted on "Yes"
23:44:42 <nrb23> @poll-show cheeky-off
23:44:43 <lambdabot> ["MakeItAbuseCowboyNeal","AddFlag","No","Yes"]
23:45:37 * nrb23 doesn't get it
23:48:43 <allbery_b> @src flibble
23:48:44 <lambdabot> Source not found. My mind is going. I can feel it.
23:49:11 <allbery_b> the error messages from @src are just a bit cheeky after the novelty wears off
23:50:13 <vincenz> @src foobar
23:50:13 <lambdabot> Source not found. Take a stress pill and think things over.
23:55:50 <nrb23> thanks for all your help tonight
23:56:01 <nrb23> 'night
