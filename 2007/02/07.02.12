00:01:18 <vincenz> Anyone have a nice one sentence to concisely and clearly explain a continuation?
00:01:55 <ibid> a continuation is what should happen next
00:02:07 <sorear> A continuation is a return address
00:02:10 <pjd> vincenz: "the remaining evaluation", or "the call stack", among others
00:02:14 <sorear> except bigger
00:02:26 <ibid> not so sure there is a clear explanation, but that one is concise :)
00:02:43 <vincenz> ibid: rather ambiguous :)
00:02:50 <ibid> vincenz: nope :)
00:03:14 <vincenz> hmm, you're right
00:03:14 <ibid> sorear: so if my return address is 42, then 43 is a continuation? ;)
00:03:19 <vincenz> ibid: I meant vague :)
00:03:29 <pjd> vincenz: "an evaluation site" might also work
00:03:42 <vincenz> I'll just use an explicit piece of code to hopefully explain it
00:03:59 <ibid> vincenz: as i said, i don't think there is a explanation that is both clear and concise; it's the uncertainty principle
00:04:08 <ibid> :)
00:04:27 <pjd> ibid: there always is! :)
00:04:49 <ibid> pjd: well, i'm sure there is as soon as one allows it to be incorrect :)
00:10:16 <pjd> vincenz: context?
00:12:42 <vincenz> pjd: hmm?
00:12:57 <vincenz> pjd: you mean as definition for continuation or are you asking the context of this definition?
00:13:09 <pjd> vincenz: the latter :)
00:13:40 <vincenz> Ah, well I am presenting my research internally.  Most of the people are rather smart but more from the EE community though they are working on software (mostly C background).  So I want to explani what a continuation is.
00:14:38 <sieni> continuation is like a setjmp()/longjmp(), but you can longjmp() even after the stack has been unwound
00:14:49 <sieni> well, rather call/cc
00:14:51 <vincenz> sieni: setjmp/longjmp are not oft-used features
00:14:51 <pjd> vincenz: if they're comfortable with the idea of the C stack, that's probably the best place to start
00:14:52 <sieni> but anyway
00:15:13 <sieni> vincenz: you talked about C background
00:15:25 <vincenz> I will just use a short definition and use a visual element as example.  And then ask if it is clear :)
00:15:27 <pjd> in C terms, a continuation is most literally just a copy of the stack
00:15:36 <vincenz> Otherwise I will reinvoke the continuation captured at the beginning of the slide
00:15:44 <sorear> night all
00:16:05 <pjd> capturing it is memcpying the stack to somewhere, restoring it is memcpying it back
00:16:27 <pjd> (with appropriate pointer adjustments and other fiddlyness)
00:16:35 <pjd> (instruction pointer, even)
00:19:41 <pjd> vincenz: on the off chance that they're familiar with getcontext/setcontext, you could relate it to that
00:20:02 <vincenz> pjd: I will poll, thanks
00:20:13 <vincenz> pjd: otherwise reinvoke the continuation captured at the beginning of the slide :)
00:20:30 <pjd> :)
00:20:49 * vincenz wishes he could hide slide elements
00:20:58 <vincenz> overlapping elements that are part of an animation are a hassle
00:22:02 <pjd> vincenz: if they're quite at home with threads, you could describe continuations as a frozen, copy-on-resume thread
00:23:04 <pjd> or rather a permanent snapshot of a thread
00:50:58 <pebblest`> I still don't know what's needed for a haskell source file to be compiled by ghc. the trivial hello-world program compiles but this one doesn't: main = do putStrLn (last [[x, y] | x <- [1..500], even x, y <- [(x+1)..500], odd y])
00:50:58 <pebblest`>  Could anyone give me a hint?
00:53:42 <opqdonut> how does it not compile
00:54:58 <velco> pebblest`: putStrLn outputs a String
00:55:05 <pebblest`> No instance for (Integral Char) arising from use of `even' at test.hs:2:50-55 Possible fix: add an instance declaration for (Integral Char) In a list comprehension: even x In the first argument of `last', namely `[[x, y] | x <- [1 .. 500], even x, y <- [(x + 1) .. 500], odd y]' In the first argument of `putStrLn', namely `(last ([[x, y] | x <- [1 .. 500], even x, y <- [(x + 1) .. 500], odd y]))'
00:55:16 <pebblest`> velco: yes?
00:55:27 <pebblest`> velco: I see....
00:55:34 <velco> so it should be putStrLn $ show $ ....
00:56:41 <vincenz> o.O
00:56:43 <pebblest`> now , it's ok. I need some time to get use to the compiler error message.
00:56:50 <vincenz> why is Show or Eq required for Num???
01:00:30 <pebblest`> it seems lazy eval costs more memory.
01:00:50 <pebblest`> even compiled.
01:00:52 <velco> depends on what you don't evaluate :)
01:01:21 <pebblest`> velco: yeah, the benefit is greater than the lost I think.
01:01:24 <velco> > take 5 [1..]
01:01:25 <lambdabot>  [1,2,3,4,5]
01:01:26 <vincenz> @pate
01:01:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:01:28 <vincenz> @paste
01:01:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:01:39 <hpaste>  vincenz pasted "funky :)" at http://hpaste.org/463
01:02:17 <velco> heh
01:02:26 <pjd> pebblest`: it can also save you memory by avoiding work that eager evaluation would have done
01:02:51 <pjd> so it's give-or-take
01:04:13 <pebblest`> pjd: you're right, the example I've done is trivial and biased to eager eval.
01:39:34 <Syzygy-> ?doc Data.List
01:39:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
01:41:07 <Syzygy-> > deleteFirstsBy (\x y -> x==y) [1,2,2,3,4,3,2,3,2,1] [2]
01:41:09 <lambdabot>  [1,2,3,4,3,2,3,2,1]
01:41:33 <Syzygy-> ?index deleteFirsts
01:41:34 <lambdabot> bzzt
01:52:51 <pebblest`> why every hs file needs a main function otherwise it cannot be compiled by ghc?
01:54:52 <velco> it can.
01:55:20 <velco> mayne you don't have ``module Foo wjate'
01:55:25 <velco> ^where
01:55:29 <pebblest`> velco: ok, my bad. I'll read the ghc manual in detail.
01:55:37 <pebblest`> velco: thanks. :
02:40:58 <dcoutts> @seen waern
02:40:59 <lambdabot> I saw waern leaving #gentoo-haskell and #haskell 12h 54m 4s ago, and .
03:06:45 <hpaste>  dcoutts pasted "cabal/c2hs pre-processing problem" at http://hpaste.org/464
03:18:55 <dcoutts> aking, can I get you to test a fix for that gtk2hs build bug you reported?
03:28:17 <explicitjelly> is the lambdabot sourcecode available?
03:28:48 <bakert> ?where lambdabot
03:28:49 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:29:03 <bakert> explicitjelly, ^^
03:29:11 <explicitjelly> thanks!
03:30:27 <explicitjelly> think I can learn something from its sourcecode? well, I know there will be many interesting things in there. question is: are there any interesting things that I might be able to *understand*? :)
03:32:03 <explicitjelly> PLUGIN Babel
03:32:07 <explicitjelly> what does that line mean?
03:32:23 <explicitjelly> is that a haskell keyword, "PLUGIN"?
03:32:36 <explicitjelly> or is that some kind of macro expansion?
03:33:49 <bakert> ?hoogle [a] -> [[a]]
03:33:50 <lambdabot> List.inits :: [a] -> [[a]]
03:33:50 <lambdabot> List.tails :: [a] -> [[a]]
03:33:50 <lambdabot> List.group :: Eq a => [a] -> [[a]]
03:33:58 <bakert> ?src List.group
03:33:59 <lambdabot> Source not found. Wrong!  You cheating scum!
03:34:03 <bakert> ?src group
03:34:03 <lambdabot> group = groupBy (==)
03:34:08 <bakert> ?src groupBy
03:34:08 <lambdabot> groupBy _  []       =  []
03:34:08 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
03:34:08 <lambdabot>     where (ys,zs) = span (eq x) xs
03:34:37 <nmessenger> > group "foobarbazzizzyzaz"
03:34:38 <lambdabot>  ["f","oo","b","a","r","b","a","zz","i","zz","y","z","a","z"]
03:41:19 <qwr> explicitjelly: depends, how much haskell you know ;)
03:41:41 <explicitjelly> qwr, true.. I'm browsing now, some things seem interesting
03:41:44 <quicksilver> explicitjelly: PLUGIN isn't a haskell keyword. haskell has few keywords.
03:41:58 <quicksilver> explicitjelly: maybe that's a macro defined in template haskell
03:42:04 <quicksilver> (that's 100% guesswork though)
03:42:17 <explicitjelly> template haskell. i see.
03:43:25 <nmessenger> explicitjelly: which file did you see it in?
03:46:26 <araujo> morning
03:50:19 <mauke> explicitjelly: it's expanded by a custom preprocessor
03:51:31 <bakert> @pl groupReports = groupBy (\a b -> rpAccount a == rpAccount b)
03:51:32 <lambdabot> groupReports = groupBy ((. rpAccount) . (==) . rpAccount)
03:54:17 <ski> @type let (r `on` f) a b = f a `r` f b in on
03:54:19 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
03:54:50 <ski> groupReports = groupBy ((==) `on` rpAccount)
03:58:18 <quicksilver> there must be a way to do that with arrows, too
03:58:20 <quicksilver> :t (***)
03:58:21 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:59:55 <quicksilver> hmph
04:00:09 <quicksilver> not sure how you idiomatically use arrows on binary functions (or, indeed, binary relations)
04:00:55 <opqdonut> with uncurry
04:01:02 <opqdonut> :t uncurry
04:01:04 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
04:01:10 <quicksilver> nod
04:01:23 <opqdonut> but dunno how idiomatic it is any more
04:02:00 <quicksilver> (uncurry (==)) . (rpAccount *** rpAccount)
04:02:38 <quicksilver> then curry that whole thing, I suppose
04:04:49 <ski> :t \rpAccount -> (arr . uncurry $ (==)) <<< (rpAccount *** rpAccount)
04:04:51 <lambdabot> forall (a :: * -> * -> *) b c. (Eq c, Arrow a) => a b c -> a (b, b) Bool
04:06:52 <quicksilver> :t \rpAccount -> (arr . uncurry $ (==)) <<< (join (***) rpAccount)
04:06:54 <lambdabot> forall (a :: * -> * -> *) b c. (Eq c, Arrow a) => a b c -> a (b, b) Bool
04:07:08 <quicksilver> @pl \rpAccount -> (arr . uncurry $ (==)) <<< (join (***) rpAccount)
04:07:09 <lambdabot> (arr (uncurry (==)) <<<) . join (***)
04:07:33 <quicksilver> although I think your original `on` was better :)
04:12:22 <bakert> ?type on
04:12:23 <lambdabot> Not in scope: `on'
04:12:51 <bakert> ski, that is crazy stuff
04:16:08 <bakert> ?src sortBy
04:16:09 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:16:20 <bakert> nice
04:16:35 <bakert> Is there a function that combines sorting and grouping?
04:16:57 <ski> bakert : eh ?
04:17:00 <bakert> So that thisFunc [1,2,3,1,2,3] == [1,1,2,2,3,3]
04:17:14 <quicksilver> @pl \f -> (groupBy f).(sortBy f)
04:17:14 <lambdabot> liftM2 (.) groupBy sortBy
04:17:15 <bakert> groupBy seems to only do "runs" if you know what I mean
04:17:39 <rahikkala> @type (group .) . sort
04:17:39 <quicksilver> bakert: just do groupBy sortBy :)
04:17:40 <lambdabot>     Couldn't match `a1 -> [a]' against `[a2]'
04:17:40 <lambdabot>       Expected type: [a2] -> a1 -> [a]
04:18:03 <nmessenger> @type group . sort
04:18:04 <lambdabot> forall a. (Ord a) => [a] -> [[a]]
04:18:08 <quicksilver> the groupBy part consumes its data linearly anyway
04:18:11 * rahikkala nods
04:18:17 <quicksilver> so it's sensible in a 'pipeline'
04:18:20 <quicksilver> at least, I assume it does
04:18:35 <quicksilver> sort obviously can't work like that
04:22:46 <quicksilver> anyone got any references about implicit parallelism and haskell?
04:23:05 <bakert> is (\a b -> f a == fb) the same thing as (comparing f) ?
04:23:12 <bakert> ?src comparing
04:23:12 <lambdabot> Source not found. I feel much better now.
04:23:17 <bakert> ?src List.comparing
04:23:18 <lambdabot> Source not found. That's something I cannot allow to happen.
04:23:26 <bakert> no
04:23:36 <bakert> actually it can't be because of GT LT and all that jazz
04:23:41 <bakert> blech
04:26:37 <bakert> @pl groupReports = groupBy (comparing rpAccount) . sortBy (comparing rpAccount)
04:26:37 <lambdabot> groupReports = groupBy (comparing rpAccount) . sortBy (comparing rpAccount)
04:26:39 <nmessenger> comparing = (compare `on`)
04:27:08 <bakert> oh dear I've broken it.
04:27:24 <nmessenger> there are no point for pl to remove
04:27:28 <nmessenger> points*
04:27:34 <bakert> sorry i mean i've broken my code.
04:28:01 <bakert> with the previous thing i was just wondering if there was a way to squish the two comparing rpAccount calls together.
04:28:22 <nmessenger> let f = comparing rpAccount in ... f ... f ... ?
04:28:33 <bakert> i spose
04:28:44 <bakert> it normally comes out nicer than that if i think about it long enough!
04:29:04 <bakert> that's not too bad though
04:29:20 <bakert> have to fix my code first though!  i think deriving Ord was a mistake
04:29:32 <bakert> without overriding the default implementation
04:29:58 <nmessenger> let groupSortBy f = groupBy ((==EQ) . f) . sortBy f
04:30:10 <bakert> woah.
04:30:48 <quicksilver> @pl \f -> groupBy ((==EQ) . f) . sortBy f
04:30:48 <lambdabot> ap ((.) . groupBy . ((EQ ==) .)) sortBy
04:32:17 * nmessenger prefers the pointful version
04:32:27 <bakert> ?hoogle a -> [a]
04:32:28 <lambdabot> Prelude.repeat :: a -> [a]
04:32:28 <lambdabot> List.intersperse :: a -> [a] -> [a]
04:32:28 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
04:32:47 <nmessenger> > repeat 'A'
04:32:48 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
04:34:03 <bakert> > let f = (:[]) . sort in f [4,3,2,1]
04:34:04 <lambdabot>  [[1,2,3,4]]
04:34:08 <bakert> huzzah
04:34:27 <nmessenger> monster operator saves the day again!
04:34:39 <bakert> > let f x = [sort x] in [4,3,2,1]
04:34:40 <lambdabot>  [4,3,2,1]
04:34:51 <bakert> > let f x = [[sort x]] in [4,3,2,1]
04:34:53 <lambdabot>  [4,3,2,1]
04:34:56 <nmessenger> eh?
04:35:07 <bakert> hmmm
04:35:09 <nmessenger> [x] should equal (:[]) x
04:35:13 <bakert> comprehension limited
04:35:39 <nmessenger> @check (\x -> (:[]) x == [x]) :: Int -> Bool
04:35:41 <lambdabot>  OK, passed 500 tests.
04:35:52 <bakert> > let f x = [sort x] in f [4,3,2,1]
04:35:53 <lambdabot>  [[1,2,3,4]]
04:35:56 <bakert> silly typo
04:36:03 <nmessenger> heh
04:36:34 <nmessenger> > (\x -> [sort x]) [4,3,2,1] -- names 'r bad, mmmkay?
04:36:35 <lambdabot>  [[1,2,3,4]]
04:37:15 <bakert> (:[]) .sort [4,3,2,1]
04:37:20 <bakert> > (:[]) .sort [4,3,2,1]
04:37:20 <lambdabot>      Expecting a function type, but found `[a]'
04:37:21 <lambdabot>       Expected type: a -> b
04:37:21 <lambdabot>  ...
04:37:29 <bakert> > ((:[]) . sort) [4,3,2,1]
04:37:30 <lambdabot>  [[1,2,3,4]]
04:37:30 <mux> @src init
04:37:31 <lambdabot> init [x]    = []
04:37:31 <lambdabot> init (x:xs) = x : init xs
04:37:31 <lambdabot> init []     = undefined
04:37:46 <ski> > [[1..4]]
04:37:47 <lambdabot>  [[1,2,3,4]]
04:38:51 <bakert> Could the default behaviour of deriving Ord somehow lead to an undefined in
04:38:58 <bakert> groupReports = (:[]) . sortBy (comparing rpAccount)
04:38:59 <bakert> ?
04:39:08 <bakert> Is there some stuff I /have/ to define?
04:39:11 <ndm> bakert: no
04:39:22 <quicksilver> :t sortBy
04:39:24 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
04:39:28 <ndm> bakert: is rpAccount total?
04:39:35 <bakert> what does total mean?
04:39:37 <bakert> (sorry!)
04:39:44 <ndm> bakert: does it produce undefined
04:39:47 <bakert> no
04:39:56 <ndm> bakert: sure?
04:40:15 <bakert> well, it shouldn't.  but that's what i'm going to look at I guess!  it's a field accessor.  but i suppose the field could be undefined somehow
04:40:32 <defcon8> hello
04:40:34 <bakert> aha.  i know what it will be.  thanks ndm
04:40:36 <ndm> bakert: paste your data type
04:40:37 <nmessenger> greets
04:40:53 <bakert> (password is a field of account but not all accounts need passwords so i guess they are undefined somewhere
04:40:54 <bakert> )
04:41:11 <bakert> So I need to write the code for Ord so it doesn't look at password.
04:41:31 <bakert> What's the minimum I can write?  Can I get away with just compare?
04:41:46 <nmessenger> compare = compare . getFieldYouWantToCompare
04:42:04 <bakert> Actually no sod it.  I'm going to do it at the sortBy end.  It doesn't make much sense for Account to derive Ord.
04:42:14 <bakert> I'm only trying to get them in "order" so I can groupBy.
04:42:37 <ndm> bakert: i typically define Ord as an extraction
04:42:42 <bakert> ?
04:42:55 <ndm> bakert: compare (Field a b c d) (Field e f g h) = compare (a,b,c) (e,f,g)
04:43:05 <ski>     -- Minimal complete definition: (<=) or compare
04:43:08 <ndm> bakert: define compare in terms of the things you actually are about
04:43:09 <bakert> that's a nice way of doing it
04:43:11 <nmessenger> Ord makes sense if there is one preffered and default ordering on your type
04:43:13 <quicksilver> bakert: I favour doing a custom ordering for the sortBy
04:43:23 <bakert> quicksilver, i'm heading that way too.
04:43:24 <quicksilver> bakert: if you don't think the underlying data type really has a natural order
04:43:37 <SamB> you could write it ndm's way though
04:43:41 <bakert> wellllll ... it would make sense for it to be alphabetical ordering.
04:43:44 <bakert> i suppose.
04:44:00 <ndm> bakert: personally if password is not always present, i'd have it as Maybe String, rather than just String which might bite you if you try and do anything with it
04:44:17 <nmessenger> alphabetical on what?  Name?  Is there an account number that might also be used?
04:45:33 <DukeDave> Hey everyone, as loosely as it is possible to answer this question...
04:45:42 <quicksilver> DukeDave: maybe
04:45:48 <DukeDave> how easy is it to 'interface' between Haskell and Java
04:45:48 <quicksilver> (that was pretty loose?)
04:46:08 <bakert> nmessenger, Account is three things: company name, username, passowrd
04:46:22 <bakert> So I could have a default ordering on company name then username.
04:46:26 <bakert> Would make sense.
04:46:30 <quicksilver> DukeDave: someone wrote a haskell JNI thingy
04:46:31 <DukeDave> quicksilver,  somewhere between degree and PhD level  &&  less then 4 lines   ;)
04:46:43 <quicksilver> DukeDave: no idea if it is complete + working or just a proof of concept
04:46:52 <nmessenger> bakert: if that seems "natural", then Ord would be okay
04:46:54 <bakert> ndm, I will implement your Maybe String thing for password.  Thanks.
04:46:55 <vincenz> @seen sorear
04:46:56 <lambdabot> I saw sorear leaving #darcs, #ghc and #haskell 4h 29m 48s ago, and .
04:47:07 <DukeDave> yeah I discovered that on sourceforge; any experience?
04:47:15 <quicksilver> DukeDave: lambada ?
04:47:39 <DukeDave> one of those "I can't afford to spend 2 weeks setting up" projects :(
04:48:15 <DukeDave> http://sourceforge.net/projects/jvm-bridge/
04:48:16 <lambdabot> Title: SourceForge.net: Java VM Bridge for Functional Languages
04:50:09 <bakert> Is the default behaviour of compare to go through each field left-to-right or is it less defined than that?  (Now I don't have undefined passwords I'm thinking I might get away with just deriving Ord)
04:50:11 <bakert> ?
04:50:21 * vincenz thinks there should be a new sourceforge for darcs-based projects that are more lightweight
04:50:33 <quicksilver> DukeDave: I never used it personally, no
04:50:49 <quicksilver> DukeDave: I think jvm-bridge might be the new name for lambada but I don't know and google doesn't seem to want to tell me
04:50:52 <SamB> darcsforge?
04:51:13 <bakert> darcsforge.net IS available
04:51:35 <nmessenger> bakert: I'm checking what the report says on tuple Ord instances
04:51:48 <ndm> bakert: thats the behaviour, top to bottom (if you have more than one constructor), then left to right within a constructor
04:51:52 <SamB> nmessenger: you had to check?
04:52:00 <bakert> data Account = Account String String String
04:52:16 <bakert> ooops no lies!
04:52:18 <bakert> data Account = Account { acBookie :: String, acUsr :: String, acPwd :: String }
04:52:18 <bakert>     deriving (Eq, Ord, Show)
04:52:26 <bakert> sorry - that was the old way
04:52:43 <nmessenger> SamB: I was pretty sure it was as ndm said, but I wanted to be sure.
04:52:53 <bakert> So is field notation syntactic sugar for tuples?
04:53:07 <bakert> acBookie = fst
04:53:10 <hpaste>  DukeDave pasted "Java VM Bridge - Hello World" at http://hpaste.org/466
04:53:13 <bakert> acUsr = snd?
04:53:15 <bakert> etc.
04:53:16 <bakert> ???
04:53:19 <quicksilver> yes and no
04:53:21 <DukeDave> seems pretty sensible :)
04:53:23 <quicksilver> conceptually yes
04:53:30 <vincenz> no
04:53:44 <nmessenger> bakert: tuples are convenient constructors with a specific number of fields :)
04:53:46 <SamB> bakert: field notation is sugar for the "data Account = Account String String String"
04:54:01 <vincenz> what SamB said
04:56:09 <bakert> ahhh.
04:56:12 <bakert> thanks folks.
04:56:59 <bakert> i'm very pleased I've managed to solve my problem by adding ", Ord" to the code.  Succinctness is power I tell ye!
04:57:55 <SamB> well... it is a timesaver for sure...
04:58:37 <bakert> @pl (\x y -> rpAccount x == rpAccount y)
04:58:37 <lambdabot> (. rpAccount) . (==) . rpAccount
04:58:43 * SamB is thinking about that paper from 1990
04:58:46 <bakert> I'm sure there's some better way to say that!
04:59:17 <nmessenger> (==) `on` rpAccount
04:59:30 <bakert> oh yeah.  god i forgot about that.
04:59:33 <bakert> doh
04:59:40 <bakert> time to scroll backwards
04:59:42 <nmessenger> on is in the latest GHC, but you could define it: op op f x y = f x `op` f y
04:59:50 <nmessenger> s/op op/on op/
05:01:19 <nmessenger> @pl \op f x y -> f x `op` f y
05:01:20 <lambdabot> join . ((flip . ((.) .)) .) . (.)
05:01:25 <nmessenger> hwh
05:01:33 <nmessenger> heh*
05:13:20 <bakert> nmessenger, what module is "on" in?
05:13:48 <nmessenger> I'm not sure, I'd just heard from others that it's in ghc HEAD
05:13:59 <bakert> oh i see, that kind of latest version!
05:16:32 <quicksilver> bakert: you can always define it at the top of your module safe in the knowledge that you will one day not need to
05:16:41 <quicksilver> bakert: it's not exactly a 'long' definition :)
05:17:06 <bakert> yeah, that's what i'm doing.  i just thought he meant 6.6 when he said latest version!
05:17:32 <nmessenger> I should probably just have said "the HEAD"  (8
05:17:54 <bakert> In ghci why does :t on give
05:17:55 <bakert> *Utils> :t on
05:17:55 <bakert> on :: (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
05:18:06 <bakert> and not a, b and c?
05:18:33 <nmessenger> it randomly generates type variables, blame it on whoever wrote the generator
05:18:44 <nmessenger> :P
05:19:07 * bakert prefers a, b and c
05:19:19 * nmessenger prefers alpha, beta, and gamma
05:19:36 * bakert thinks nmessenger is letting this maths stuff go to his head
05:19:50 <quicksilver> aleph, beth and gimel for the win!
05:19:50 <ski> (bar -> bar -> baz) -> (foo -> bar) -> (foo -> foo -> baz)
05:19:59 <bakert> nice
05:20:20 <matthew_-> bar -> bar -> black -> sheep -> (have,you,any,wool?)
05:20:35 * nmessenger tries to one-up ski with longer names but realizes he is too lazy
05:21:02 <quicksilver> There was a proof that all haskell programs were alpha-equivalent
05:21:18 <quicksilver> which worked by encoding the program itself into the variable names
05:21:20 <quicksilver> very cute
05:21:23 <ski> matthew_- : cheating to use '->' in 'matthew_-> bar ..' ;)
05:22:09 * nmessenger didn't notice that.  *rollicking laughter*
05:22:23 <opqdonut> buhahahaha
05:22:25 <opqdonut> yupyup
05:22:41 <quicksilver>   
05:23:16 <matthew_-> lol. I didn't notice that either!
05:23:59 <matthew_-> >= laugh
05:43:43 <bakert> ?hoogle [[a]] -> [a]
05:43:44 <lambdabot> Prelude.concat :: [[a]] -> [a]
05:43:51 <bakert> ?src concat
05:43:51 <lambdabot> concat = foldr (++) []
05:44:18 <bakert> > foldr (head) [[1,2,3], [4,5,6], [7,8,9]]
05:44:19 <lambdabot>  Add a type signature
05:44:29 <nmessenger> map head?
05:44:35 <bakert> ah yes
05:44:50 <bakert> map head [[1,2,3]. [4,5,6], [7,8.9]]
05:44:53 <bakert> > map head [[1,2,3]. [4,5,6], [7,8.9]]
05:44:54 <lambdabot>  Couldn't match `b -> c' against `[a]'
05:45:03 <bakert> > map head [[1,2,3], [4,5,6], [7,8.9]]
05:45:04 <lambdabot>  [1.0,4.0,7.0]
05:45:13 <bakert> > map head [[1,2,3], [4,5,6], [7,8.9]] :: [Int]
05:45:14 <lambdabot>   add an instance declaration for (Fractional Int)
05:45:14 <lambdabot>     In the list element: 8...
05:45:19 <bakert> gak
05:45:21 <nmessenger> 8.9
05:45:31 <bakert> > map head [[1,2,3], [4,5,6], [7,8,9]]
05:45:32 <lambdabot>  [1,4,7]
05:45:38 <bakert> yeah typing ... never could get the hang of it!
05:45:44 <nmessenger> :D
05:46:03 <earthy> but the type system is so much fun! You can easily specify any primitive-recursive function in it!
05:46:12 <quicksilver> FSOV 'easily'
05:46:15 <earthy> (provided you have mptcs and fundeps)
05:46:15 <nmessenger> keyboarding is less fun though
05:46:37 <bakert> tsk
05:46:41 <bakert> haskell jokes.
05:46:43 <bakert> what next.
05:46:50 <bakert> :)
05:47:22 <nmessenger> (_|_) <-- haha look at my bottom!
05:47:44 <bakert> oh lord.  save me.
05:47:46 <bakert> !
05:47:53 <nmessenger> @yow!
05:47:53 <lambdabot> A dwarf is passing out somewhere in Detroit!
05:47:54 <bakert> :t (<--)
05:47:56 <lambdabot> parse error (possibly incorrect indentation)
05:47:59 <bakert> @kind (<--)
05:48:00 <lambdabot> parse error (possibly incorrect indentation)
05:48:01 <bakert> !!!
05:48:16 <bakert> :type (!!!)
05:48:18 <bakert> for that matter
05:48:23 <bakert> ?type (!!!)
05:48:24 <lambdabot> Not in scope: `!!!'
05:48:46 <nmessenger> "I just want, bang-bang-bang!"
05:49:08 <nmessenger> @google bang bang bang
05:49:10 <lambdabot> http://www.starterupsteve.com/swf/Group_X_video.html
05:49:10 <lambdabot> Title: i just want BANGBANGBANG! BANG BANG BANG
05:51:12 * nmessenger apologizes for... that
05:51:47 <bakert> nsfw i imagine...
05:51:54 <bakert> not that anyone here would care i suppose
05:52:05 <bakert> this being linux geek central
05:52:19 <bakert> as a colleague described it earlier today
05:52:58 * quicksilver blinks
05:53:08 <quicksilver> of all the channels I'm on this is among the least linuxy
05:53:17 <quicksilver> I hardly ever hear the OS mentioned here
05:53:21 <bakert> sorry  i meant my workpalce, not #haskell
05:53:24 <bakert> *workplace
05:53:27 <quicksilver> oh, I see :)
05:53:31 <bakert> following on from my nsfw comment.
05:53:49 <bakert> oh the perils of jabbing at a keyboard and thinking people are understanding you!
05:54:07 <earthy> ;)
05:54:24 <bakert> that's why we have haskell.  unambiguous communication!
05:54:29 <bakert> ish
05:55:00 <bakert> ddarius so gglad you could jjoin us
05:55:15 <bakert> oh dear, i'm in a silly mood now.
05:55:28 * nmessenger finds the closest large object and gives bakert a slap with it
05:55:42 * bakert is grateful, though bruised
05:55:42 * vincenz handns nmessenger a fish with an infinite tail
05:55:48 <vincenz> bakert: feel that _|_
05:57:53 <quicksilver> infinite but, presumably lazily evaluated
05:58:00 <quicksilver> otherwise you wouldn't be able to lift it
05:58:45 <nmessenger> @type lift (cycle "fish")
05:58:47 <lambdabot> forall (t :: (* -> *) -> * -> *). (MonadTrans t) => t [] Char
05:58:54 <nmessenger> it typechecks
05:58:57 * bakert is enjoying watching the functions melt away now he is approaching the problem correctly.
05:59:39 <vincenz> quicksilver: Well yes, fortunately bakert's face acts like a deepSeq
06:00:12 * bakert isn't knowledgeable enough to know if he is being insulted or REALLY insulted
06:00:25 * nmessenger goes for REALLY insulted
06:00:57 * vincenz tends to act like a deepSeq when discussing with hsi advisor
06:01:01 <nmessenger> it's totally uncool to be so strict in here
06:01:56 <pjd> @poll-show OperatingSystem
06:01:56 <lambdabot> ["DragonflyBSD","NetBSD","OpenBSD","Gentoo","Debian","Ubuntu","FreeBSD"]
06:02:29 <nmessenger> @vote OperatingSystem WindowsAndIDontCare
06:02:29 <lambdabot> "WindowsAndIDontCare" is not currently a candidate in this poll
06:02:35 <vincenz> @vote OperatingSystem Ubuntu
06:02:35 <lambdabot> voted on "Ubuntu"
06:02:41 <pjd> heh
06:02:54 <pjd> @choice-add OperatingSystem Windows
06:02:55 <lambdabot> New candidate "Windows", added to poll "OperatingSystem".
06:03:02 <dvekravy> @vote OperatingSystem FreeBSD
06:03:02 <lambdabot> voted on "FreeBSD"
06:03:41 <mauke> @vote OperatingSystem Gentoo
06:03:41 <lambdabot> voted on "Gentoo"
06:03:52 <matthew_-> @vote OperatingSystem Debian
06:03:53 <lambdabot> voted on "Debian"
06:03:57 <Lemmih> ?vote Ubuntu
06:03:57 <lambdabot> usage: @vote <poll> <choice>
06:04:07 <Lemmih> ?vote OperatingSystem Ubuntu
06:04:07 <lambdabot> voted on "Ubuntu"
06:04:16 <matthew_-> @choice-add OperatingSystem TheWoWIsNowVista
06:04:16 <lambdabot> New candidate "TheWoWIsNowVista", added to poll "OperatingSystem".
06:04:23 <opqdonut> ?vote OperatingSystem Debian
06:04:24 <lambdabot> voted on "Debian"
06:04:27 <opqdonut> ?vote OperatingSystem Gentoo
06:04:27 <lambdabot> voted on "Gentoo"
06:04:32 <opqdonut> ?vote OperatingSystem OpenBSD
06:04:32 <lambdabot> voted on "OpenBSD"
06:04:35 <opqdonut> np
06:04:47 <musasabi> ?vote OperatingSystem Debian
06:04:48 <lambdabot> voted on "Debian"
06:04:53 <musasabi> ?vote OperatingSystem NetBSD
06:04:53 <lambdabot> voted on "NetBSD"
06:05:10 <mauke> ?vote OperatingSystem Emacs
06:05:10 <lambdabot> "Emacs" is not currently a candidate in this poll
06:05:18 <rahikkala> @vote OperatingSystem Gentoo
06:05:19 <lambdabot> voted on "Gentoo"
06:05:22 <nmessenger> @choice-add OperatingSystem House
06:05:22 <lambdabot> New candidate "House", added to poll "OperatingSystem".
06:05:22 <pejo> Heh, signs of a biased vote: Windows and MacOS aren't even in the possible choices.
06:05:44 <vincenz> @choice-add OperatingSystem MacOS
06:05:44 <lambdabot> New candidate "MacOS", added to poll "OperatingSystem".
06:06:15 <vincenz> matthew_-: honestly thewowisnowvista is a rather poor poll-choice
06:06:25 <kfish> ?vote OperatingSystem Schoenfinkel
06:06:25 <lambdabot> "Schoenfinkel" is not currently a candidate in this poll
06:06:50 <matthew_-> vincenz: sorry, was trying to be funny.
06:06:57 <nmessenger> @google schoenfinkel
06:06:59 <lambdabot> http://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel
06:06:59 <lambdabot> Title: Moses Schönfinkel - Wikipedia, the free encyclopedia
06:07:25 <vincenz> matthew_-: the lazy approach of hsakell is not applicable to humor
06:07:54 <opqdonut> ?poll-results OperatingSystem
06:07:54 <lambdabot> Poll results for OperatingSystem (Open): MacOS=0, House=0, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=3, Debian=3, Ubuntu=2, FreeBSD=2
06:08:36 <ibid> ?vote OperatingSystem Debian
06:08:37 <lambdabot> voted on "Debian"
06:08:39 <matthew_-> vincenz: uh hu. Mmmm. Given that there are several flavours of linux there, we really should also have all the versions of Vista there too. As taken from http://www.penny-arcade.com/comic/2007/02/02
06:08:40 <lambdabot> Title: Penny Arcade! - The Manifold Faces of Vista
06:09:10 * nmessenger wonders about Vista AIDS
06:09:27 <vincenz> nmessenger: is that Vista AID in plural?
06:09:37 <pjd> does lambdabot keep track of the voting nicks?
06:09:52 <pjd> or can you end up voting more than once for an option?
06:10:21 <ibid> ?vote OperatingSystem Debian
06:10:22 <lambdabot> voted on "Debian"
06:10:28 <ibid> apparently you can
06:10:49 <nmessenger> @poll-add RestrictToOneVote
06:10:50 <lambdabot> Added new poll: "RestrictToOneVote"
06:10:58 <nmessenger> @choice-add RestrictToOneVote Yes
06:10:59 <lambdabot> New candidate "Yes", added to poll "RestrictToOneVote".
06:11:01 <nmessenger> @choice-add RestrictToOneVote No
06:11:01 <lambdabot> New candidate "No", added to poll "RestrictToOneVote".
06:11:18 <ibid> ?poll RestrictToOneVote Yes
06:11:18 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
06:11:25 <ibid> ?vote RestrictToOneVote Yes
06:11:25 <lambdabot> voted on "Yes"
06:11:27 <ibid> ?vote RestrictToOneVote Yes
06:11:28 <lambdabot> voted on "Yes"
06:11:29 <ibid> :)
06:11:40 <nmessenger> :P  *I* was gonna do that
06:11:44 <pjd> @vote RestrictToOneVote Yes
06:11:44 <lambdabot> voted on "Yes"
06:11:55 <pjd> nmessenger: one vote per poll or per option, though?
06:12:05 <pjd> the latter makes more sense to me
06:12:06 <mauke> @choice-add RestrictToOneVote FileNotFound
06:12:06 <lambdabot> New candidate "FileNotFound", added to poll "RestrictToOneVote".
06:12:13 <nmessenger> @choice-add RestrictToOneVote PerPoll
06:12:13 <lambdabot> New candidate "PerPoll", added to poll "RestrictToOneVote".
06:12:18 <nmessenger> @choice-add RestrictToOneVote PerOption
06:12:19 <lambdabot> New candidate "PerOption", added to poll "RestrictToOneVote".
06:12:29 <pjd> @vote RestrictToOneVote PerOption
06:12:30 <lambdabot> voted on "PerOption"
06:12:33 <vincenz> Ok, let's cut the spam?
06:12:38 <vincenz> -> #haskell-blah
06:13:04 <vincenz> thx :)
06:17:29 <ndm> any lhs2tex people here?
06:17:34 <ndm> i'm having Windows issues....
06:17:45 <ndm> kosmikus: are you the lhs2tex guy?
06:18:01 * ndm has a poor irc -> face -> name mapping system
06:18:53 <earthy> well, that was a correct mapping at least. ;)
06:19:22 <ndm> now let's see if he's available
06:19:33 <vincenz> ndm: your second parameter is not useful
06:19:41 <ndm> i get Setup.hs type errors, followed by extra pain of not having kpsewhich
06:19:56 <ndm> i've met him, and can remember his face
06:20:00 <ndm> and i remember his name
06:20:14 <ndm> but was failing at the irc mapping - but best to give all the information i have to the mapping function
06:21:35 <kzm> Was there a trick to avoid ghci printing monadic values as they are assigned?
06:21:58 <vincenz> kzm: assigned?
06:22:12 <vincenz> let x = comp
06:22:14 <vincenz> does not print
06:22:34 <kzm> x <- comp
06:22:43 <vincenz> oh
06:23:40 <vincenz> no idea, sorry
06:23:42 <quicksilver> kzm: by 'monadic' you mean 'IO' :P
06:23:47 <kzm> I thought there was a workaround ... well, I can assign to something without a Show instance
06:24:05 <kzm> Yeah, sorry.  I was referring to the syntax (<-)
06:24:35 <kzm> ..and not, you know, let x = Just 4 :-)
06:24:49 <quicksilver> well x <- Just 4
06:24:55 <quicksilver> is equally monadic
06:25:03 <quicksilver> but ghci won't do anything with it on its own
06:25:12 <vincenz> quicksilver: the toplevel of ghci is the IO monad
06:25:18 <vincenz> x <- Just 4 won't work afaict
06:25:19 * quicksilver considers adding "IO is not the only monad" to the topic
06:25:22 <quicksilver> vincenz: correct
06:25:27 <quicksilver> vincenz: that is exactly my point
06:26:58 <quicksilver> kzm: it doesn't print the value for me, only the type
06:27:06 <kzm> ?
06:27:16 <kzm> It's a 6.6 thing, I think.
06:27:16 <quicksilver> or, I think so
06:27:18 <quicksilver> ah
06:27:23 <quicksilver> that would explain it
06:27:27 <quicksilver> I'm 6.4
06:27:59 <kzm> Which means that 6.6 is too strict also.
06:28:11 <kzm> > x <- return (1,undefined)
06:28:11 <lambdabot>  Parse error
06:29:28 <quicksilver> I guess it's just handy for testing out IO thingies
06:49:31 <vincenz> kzm: you mean the interpreter is strict
07:02:44 <ndm> @seen kosmikus
07:02:44 <lambdabot> kosmikus is in #darcs, #ghc, #gentoo-haskell and #haskell. I last heard kosmikus speak 14h 47m 55s ago.
07:09:37 <xs> i'm trying to make an 'interact' that works over tcp sockets. however, if i use hGetContents, then the socket handle will be semi-closed, so i cannot hPutStr? is there a portable way to duplicate a Handle?
07:21:37 <LoganCapaldo> @hoogle IO Handle -> IO Handle
07:21:38 <lambdabot> No matches, try a more general search
07:21:58 <LoganCapaldo> @hoogle Handle -> Handle
07:21:58 <lambdabot> No matches, try a more general search
07:22:08 <LoganCapaldo> @hoogle Handle
07:22:08 <lambdabot> System.IO.Handle :: data Handle
07:22:08 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
07:22:08 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
07:23:22 <xs> @hoogle Handle -> IO Handle
07:23:22 <lambdabot> No matches, try a more general search
07:23:30 <xs> there's GHC.Handle.hDuplicate
07:23:33 <xs> but that's not portable
07:24:02 <LoganCapaldo> Ah well, I tried :)
07:24:49 <xs> ta :)
07:25:18 <quicksilver> xs: I think you don't want hGetContents
07:25:33 <quicksilver> xs: since you don't want to do the 'semi-closed' thiing
07:25:43 <xs> but i want lazy semantics
07:26:35 <allbery_b> afaik you need to use System.Posix.IO to do handle duplication
07:26:36 <nominolo> hm, how does one usually track down infinite recursion problems?
07:27:12 <allbery_b> convert Handle to Fd, duplicate Fd, convert Fds to Handles
07:27:13 <xs> hm, okay. thanks!
07:28:11 <LoganCapaldo> nominolo: use doesHalt :: (Program p) => p -> Bool ;)
07:28:17 <xs> lazy i/o is such a pain
07:28:20 <vincenz> LoganCapaldo: that should be
07:28:27 <vincenz> doesHalt :: (Program p) => p -> m Bool
07:28:28 <vincenz> erm
07:28:35 <vincenz> with 'Monad m' as constraint
07:29:16 <LoganCapaldo> vincenz: Why so?
07:29:16 <allbery_b> of course the return values are True and _|_ :)
07:29:30 <allbery_b> in IO
07:29:54 <nominolo> er, i appreciate the humor, but is there maybe a useful way of tracing?
07:30:27 <LoganCapaldo> Sorry, :)
07:30:40 <allbery_b> Debug.Trace.trace at key points?
07:30:41 <emu> -prof
07:30:55 <allbery_b> (carefully, as tracing _|_ doesn't help much :)
07:31:42 <vincenz> allbery_b: no, you can optimize it to return False at times
07:31:55 <vincenz> allbery_b: `while true do skip` is known not to terminate
07:33:44 <nominolo> but prof probably doesn't work in ghci
07:34:32 <allbery_b> seriously, Debug.Trace
07:34:48 <allbery_b> or maybe pull down ghc HEAD and see if the ghci debugger is worth anything
07:35:01 <ndm> allbery_b: it is
07:35:20 <ndm> allbery_b: its the best haskell debugger i've ever seen
07:35:24 * allbery_b should see if last night's build error is fixed yet, speaking of which
07:35:49 <ski> possibly there should be a 'hInteract :: Handle -> (String -> String) -> IO ()'
07:36:11 <nominolo> I am pretty sure it is related to a problematic call to mfix or something.
07:36:36 <xs> ndm, but that's not saying much as it's practically the only one that works?
07:36:36 <ski> (for 'Handle's 'open'ed with 'ReadWriteMode' ..)
07:36:38 <nominolo> though, arrow syntax abscures quite a bit
07:36:50 <xs> ski, yes, that would be very nice :)
07:36:55 <ndm> xs: alas yes, but i was pretty impressed with it - and i've done work with Hat etc.
07:38:31 <allbery_b> hm, nope, no changes since las night.  StgTicky.h presumably still MIA
07:40:58 * quicksilver notes that arrow type annotations would be more legible if a 'symbolic infix' type variable was used
07:41:02 <quicksilver> instead of Arrow a b c
07:41:12 <quicksilver> Arrow b -*-> c
07:41:24 <quicksilver> or b -a-> c even
07:41:35 <quicksilver> (but that last breaks the lexical conventions we have)
07:41:50 <nmessenger> Arrow a => b `a` c?
07:42:04 <quicksilver> well it isn't =>
07:42:11 <quicksilver> Arrow takes three parameters
07:42:16 <quicksilver> but yes, `a` is better than nothing
07:42:21 <quicksilver> Arrow b `a` c
07:43:06 <nmessenger> @src Arrow
07:43:06 <lambdabot> class Arrow a where
07:43:07 <lambdabot>     arr, pure   :: (b -> c) -> a b c
07:43:07 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
07:43:07 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
07:43:07 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
07:43:08 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
07:43:10 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
07:44:03 <quicksilver> oh
07:44:06 <quicksilver> sorry :)
07:44:43 <nmessenger> The Arrow class parameterizes over a (*->*->*) type variable :P
07:44:48 <ski> @type (arr :: Arrow (~>) => (a -> b) -> a ~> b)
07:44:49 <lambdabot> forall a b (~> :: * -> * -> *). (Arrow ~>) => (a -> b) -> ~> a b
07:45:21 <quicksilver> nmessenger: yes, knickers in a twist there, thanks
07:45:23 <nmessenger> geh, shouldn't that be (~>) a b at least?
07:45:46 <ski> printed strange, yes .. but appears to work
07:46:01 * nmessenger tries in ghci
07:47:04 <nmessenger> seems to do the same
07:47:52 <vincenz> what's ~>
07:48:02 <nmessenger> a type variable
07:48:12 <nmessenger> like 'a'
07:49:01 <vincenz> oh there's no actual definition
07:50:56 <nmessenger> "Warning: Accepting non-standard infix type constructor `~>'
07:50:56 <nmessenger>          Use -fglasgow-exts to avoid this warning
07:50:56 <nmessenger> but it works
07:51:24 <chessguy> wheeee
07:51:30 <chessguy> @bot
07:51:31 <lambdabot> :)
07:51:47 <chessguy> good, at least the split didn't kill LB
07:52:03 <allbery_b> no, the bot dies at the rejoin, usually
07:52:24 <LoganCapaldo> Don't die lambdabot
07:52:30 <LoganCapaldo> LIVE!
07:53:31 <allbery_b> sorear tracked it down to a race condition processing all the apparent re-joins, IIRC
07:53:46 <paolin1> chessguy , how is going the genetic algo ?
07:53:54 <bd_> And this is why lambdabot should use STM I guess :)
07:54:02 <LoganCapaldo> race condition in Haskell? Impastable!
07:54:22 <chessguy> hi paolin1 , it's going
07:54:23 <LoganCapaldo> No one proved the correctness of lambdabot yet for their thesis?
07:54:43 <chessguy> i need to change the way random variables are handled, but it's testing ok
07:54:48 <chessguy> (so far)
07:54:54 <paolin1> ah, great
07:55:13 <pejo> Logan, to paraphrase a teacher I had - "ploofs ale booling".
07:55:22 <paolin1> my bad feelings were wrong then
07:55:35 <chessguy> what did you have bad feelings about?
07:56:27 <paolin1> those nested runStates forking the states
07:57:15 <chessguy> hmm. i think it's ok. but my testing hasn't been really thorough yet
07:57:20 <allbery_b> @bot
07:57:20 <lambdabot> :)
07:58:14 <glguy> !paste
07:58:14 <hpaste> Haskell paste bin: http://hpaste.org/
07:58:45 <chessguy> 'morning glguy
07:59:37 <glguy> good morning
08:01:17 <chessguy> paolin1, do you suspect there was a better way to do it?
08:01:18 <paolin1> is it possible for an haskell library to "work" with unknown types , defined by the end user ?
08:01:31 <quicksilver> paolin1: in various ways, yes
08:01:42 <quicksilver> paolin1: the most common way is to define a type with a parameter
08:01:47 <quicksilver> like list, or maybe
08:01:55 <quicksilver> other more exotic possibilities exist
08:03:17 <paolin1> mmhh, that is not enough for me.
08:03:55 <paolin1> that way I must know the number of types
08:04:08 <paolin1> example.
08:04:37 <paolin1> I have an object called Cell
08:05:09 <paolin1> I want the end user to be able to plug in activities for the cell
08:05:23 <paolin1> possibly stateful ones
08:05:37 <allbery_b> @bot
08:05:37 <lambdabot> :)
08:05:39 <allbery_b> yay
08:06:18 <paolin1> My library doesn't know the types of the activities state
08:07:06 <glguy> activity's state? activities' states?
08:07:38 <kosmikus> ndm: just ask the question. I'll try to answer later ...
08:07:40 <chessguy> paolin1, what are you working on?
08:07:40 <paolin1> type of the states
08:08:02 <kosmikus> ndm: never mind, I see you wrote mails
08:08:05 <ndm> kosmikus: i've sent 3 emails to the lhs2tex email you gave - the last one is the biggest problem
08:08:12 <ndm> kosmikus: the first 2 emails are issues i've got over
08:08:44 <ndm> basically I get "undefined control sequence, SkipToFmtEnd" errors
08:08:47 <paolin1> chessguy , cellular automata applied to data clustering
08:08:55 <chessguy> wow
08:08:59 <chessguy> sounds really i nteresting
08:09:08 <chessguy> s/i /i/
08:09:34 <Syzygy-> @pl \(x, y) -> show x ++ " " ++ show y
08:09:35 <lambdabot> uncurry ((. ((' ' :) . show)) . (++) . show)
08:09:53 <paolin1> my code is going to mess. I must learn new haskell ways for frameworks
08:10:00 <Syzygy-> @pl \x y -> show x ++ " " ++ show y
08:10:00 <lambdabot> (. ((' ' :) . show)) . (++) . show
08:10:57 <paolin1> glguy , how I keep a "list" of those states, which are all of different and unknown type ?
08:12:35 <cjeris> Syzygy-: my irc client just turned inserted fat yellow smileys in @pl's output :p
08:12:35 <paolin1> and the "list" of functions needing them as state ?
08:13:14 <chessguy> lol
08:13:56 <Syzygy-> cjeris: BWAHAHA!
08:14:04 <Syzygy-> cjeris: Use a sane client instead.
08:14:53 <bakert> that is classy.
08:15:05 <bakert> (:[])
08:15:43 <pxfont> how do you write backslash in a haskell string?
08:15:49 <Syzygy-> "\\"
08:15:53 <Syzygy-> > "\\"
08:15:54 <lambdabot>  "\\"
08:16:00 <pxfont> it looks like \\ when printed
08:16:04 <Syzygy-> Hmmm.
08:16:08 <bakert> > print "\\"
08:16:09 <lambdabot>  <IO ()>
08:16:13 <bakert> tsk
08:16:15 <Syzygy-> Prelude Data.List> putStrLn "\\"
08:16:15 <Syzygy-> \
08:16:18 <ski> > show "\\"
08:16:19 <lambdabot>  "\"\\\\\""
08:16:29 <Syzygy-> > show "\"
08:16:29 <lambdabot>  Improperly terminated string
08:16:33 <pxfont> no monads
08:16:38 <pxfont> just show "\\"
08:16:48 <bakert> show is not printing though, exactly
08:16:54 <Syzygy-> pxfont: putStrLn "\\" gives the printout \ though.
08:17:02 <Syzygy-> As my cut-n-paste from my ghci above shows.
08:17:09 <paolin1> \ is the ecape char
08:17:28 <pxfont> the translation of escape is a side-effect??
08:17:37 <emu> show is returning a readable version of the sequence ['\"','\\','\"']
08:17:45 <pxfont> very strange
08:17:47 <ski> > length "\\"
08:17:48 <lambdabot>  1
08:17:51 <bakert> i think it's just a question of what ghci shows you when you ask certain questions.
08:18:03 <pxfont> this is weird (not optimal IMO)
08:18:04 <ski> > map (\x -> (x,x)) "\\"
08:18:05 <lambdabot>  [('\\','\\')]
08:18:39 <pxfont> show '\\'
08:18:40 <pxfont> "'\\\\'"
08:18:49 <emu> you are confusing yourself
08:18:55 <Lemmih> pxfont: It'll become clear once you understand it.
08:19:14 <paolin1> > lenght "\n" == length "\\" == 1
08:19:14 <lambdabot>      precedence parsing error
08:19:14 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
08:19:33 <ski> @read "\\a\tb\ac\""
08:19:33 <lambdabot>  \a	bc"
08:23:06 <paolin1> quicksilver, is generic haskell a way to solve my problem or, haskell is enough ?
08:23:38 * paolin1 hopes badly haskell is enough
08:26:40 <kpreid> paolin1: you need to use generic haskell, Data.Typeable, or keep the state together with the function
08:27:12 <kpreid> paolin1: but in the general case, a library not knowing the types its clients use is *normal*
08:27:17 <kpreid> that's what type variables are for
08:27:28 <kpreid> map doesn't care what you put in your lists, for example
08:27:51 <kpreid> paolin1: can you explain more about what you want to do?
08:28:10 <bakert> ?pl summary reports = (h2 << "Summary") +++ (map trDisc $ map head $ groupReports reports)
08:28:10 <lambdabot> summary = ((h2 << "Summary") +++) . map trDisc . map head . groupReports
08:29:18 <glguy> pxfont: I was just reading the backlog... do you understand what was happening with the \\?
08:29:47 <paolin1> kpreid: I'll try to put up an example
08:29:58 <glguy> (also, did you notice that that didn't use monads?)
08:30:38 <sorear> tell fodder
08:31:41 <chessguy> 'morning sorear
08:33:36 <dylan> can a cabal file have multiple executables?
08:34:25 <sorear> yes
08:34:35 <roconnor> @type runST
08:34:37 <lambdabot> Not in scope: `runST'
08:34:40 <sorear> eg lambdabot.cabal does it
08:34:41 <roconnor> @hoogle runST
08:34:41 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
08:34:41 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
08:34:41 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
08:34:45 <sorear> @uptime
08:34:45 <lambdabot> uptime: 20h 34m 11s, longest uptime: 2d 17h 27m 21s
08:34:52 <sorear> @version
08:34:52 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
08:34:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:34:52 <roconnor> @type Control.Monad.ST.runST
08:34:53 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
08:35:33 <bakert> i hate text.html
08:35:40 <ndm> bakert: me too
08:35:54 <bakert> got to be a better way.
08:35:54 <ndm> (i especially hate haddocks version which is 90% text.html and has no documentation)
08:36:00 <ndm> why not text.xhtml ?
08:36:04 <sorear> ... is text.xhtml any better
08:36:06 <bakert> oh same thing
08:36:10 <bakert> i am using text.xhtml
08:36:11 <ndm> alegedly
08:36:31 <bakert> ?paste
08:36:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:36:50 <hpaste>  bakert pasted "something rotten in the state of text.xhtml" at http://hpaste.org/467
08:36:59 <bakert> there's got to be a better way ^^
08:37:47 <bakert> not that i have figured out what it is, mind.  templating ???!
08:39:34 <alexj_> bakert: in general producing html directly in haskell seems difficult.  My general preference is to produce xml and then use xslt to convert to some html format.
08:40:08 <bakert> alexj_, that just makes me want to hurt myself.
08:40:33 <bakert> XHTML /is/ a type of XML.  So why not just produce it in the first place?
08:40:43 <bakert> I'll work out the perfect answer shortly and write a library.
08:40:49 <bakert> Just after I cure cancer.
08:41:10 <alexj_> there are straightforward methods for automaticaly generating xml from haskell types.
08:41:22 <alexj_> there are no standard methods for generatingthe html you want from haskel types.
08:41:24 <bakert> are there?  that's interesting
08:41:34 <bakert> if only it didn't involve xslt!
08:42:04 <alexj_> if you really hate xslt, there are also other xml transformation/manipulatio languages.
08:42:04 <roconnor> @hoogle STref
08:42:05 <lambdabot> Data.STRef :: module
08:42:05 <lambdabot> Data.STRef.STRef :: data STRef s a
08:42:05 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
08:42:06 <rahikkala> Well, you know, cancer is after all caused by runaway side effects in a process that should just purely be a -> (a, a)
08:42:07 <ndm> bakert: tables in HTML/XHTML are crap
08:42:15 <bakert> ndm, they sure are
08:42:23 <glguy> I want to solv my problm but I rally don't want to us th lttr ''
08:42:49 <ndm> bakert: in the Haddock version of Text.Html they are much worse, if thats any consolation
08:42:50 <bakert> glguy, i think you'll find the letter "e" is a teensy bit more useful and whole lot less ugly than xslt
08:43:06 <bakert> so that's not a very fair comparison.
08:43:08 <roconnor> @type newSTRef
08:43:09 <lambdabot> Not in scope: `newSTRef'
08:43:16 <roconnor> @type Data.STRef.newSTRef
08:43:18 <lambdabot> forall a s. a -> GHC.ST.ST s (GHC.STRef.STRef s a)
08:43:20 <glguy> bakert: I disagree, but we could have both figured that out already ;)
08:43:39 <ndm> bakert: you can create a haskell data type that is the "XML", and then generate the HTML in one place - neater than XSLT and quite easy as well
08:43:51 <bakert> i guess so.  although i'm sure if it came down to it you'd do without xslt rather than the letter "e".
08:43:53 <glguy> alexj_: if you have it registered, /msg nickserv ghost alexj <yourpassword>
08:44:50 <alexj_> glguy: that killed alexj but how do I now become alexj?
08:44:58 <glguy> . /nick alexj
08:45:13 <alexj_> ./nick alexj
08:45:25 <bakert> :)
08:45:25 <glguy> no no, the period was to keep me from becoming alexj
08:45:27 <chessguy> don't type the .
08:45:31 <sorear> alexj: s/^.//
08:45:31 <alexj_> it tells me the nick is already in use
08:45:41 <alexj_> yeah I tried it both ways.
08:45:46 <bakert> sometimes i think IRC was designed intentionally to cause minor humiliations like
08:45:47 <bakert> that
08:46:18 <sorear> I think you just got bad timing
08:46:21 <glguy> alexj_: oh, the squatter got it back, you'll need nickserv's recover
08:46:46 <glguy> alexj_: /msg nickserv help recover
08:47:21 <sorear> gah I forgot erc had auto-rename ... that and it doesn't tell you when you've changed nicks
08:47:35 <glguy> alexj_: if it becomes an issue, you just /stats p, find a IRCop and get the guy klined
08:47:43 <sorear> <-- is sorear, but his IRC client is very messed up now
08:48:10 <alexj_> glguy: some guy is bothering to squat my name?  I assume this is a system issue.
08:48:21 <glguy> alexj_: no, it's a guy with a .ro name
08:48:29 <chessguy> p :0 staff members
08:48:29 <glguy> n=AlexJ@p5.pub.ro
08:48:41 <sorear> now how is the REAL alexj_ doing :)
08:48:52 <sorear> alexj_: /msg nickserv help recover
08:49:01 <glguy> in the case of 0 on-call members, you /join #freenode, it redirects you somewhere where you'd do a /who *staff/freenode* or something to that effect
08:49:04 <glguy> and ask one of them :)
08:49:53 <glguy> alexj_: or just /msg nickserv ghost and /nick really fast
08:50:03 <glguy> alexj_: faster than he can reconnect and get your nick :)
08:50:30 <sorear> alexj_: type them both into an editor, and paste into your client
08:50:53 <glguy> alexj_ has "recovered" the nick now (according to /whois) and just needs to release and then claim it :)
08:51:00 <alexj> I am now alexj!@
08:51:02 <alexj> yay!
08:51:07 <glguy> huzzah!
08:51:08 <alexj> what a PITA.
08:51:14 <glguy> victory goes to the good guy
08:51:37 <sorear> "<alexj_> <-- is sorear, but his IRC client is very messed up now"  <-- I suspect ERC actually lost track of its own nick there ... gah
08:51:37 <sorear>  
08:52:35 <alexj> thanks everyone for the advice on doing this.
08:52:42 <sorear> np
08:52:54 <alexj> bakert: you generally want to separate data structure stuff from presentation stuff.
08:52:57 <sorear> #haskell helps with anything
08:53:27 <earthy> e.g. 'Network.hs' and 'NetworkUI.hs'
08:53:27 <sorear> alexj: the presentation stuff has to be written ... is haskell a bad language?
08:53:30 <glguy> aw fuck, this new keyboard doesn't have an INSERT key!
08:53:48 * sorear has heard bad rumors about XSLT-as-a-language
08:53:59 * JKnecht confirmgs
08:54:07 <sorear> glguy: can I have it? :P
08:54:11 <chessguy> glguy, what'd you do, dig it out of a dumpster?
08:54:15 * earthy shudders at the thought of coding in xslt
08:54:36 <alexj> sorear: xslt is built into opera/firefox/ie so you can do all the work on the client.
08:54:37 <glguy> I wanted to buy a split keyboard, I returned the first one I bought because it had crappy soft keys
08:54:43 <glguy> (soft key presses)
08:55:04 <JKnecht> but in fairness it's not mean to be a language
08:55:04 <alexj> but my main point is that the code for presentation should be separate from the code for doing stuff.
08:55:05 * sorear hates the way Emacs keeps setting Ovwrt when sorear's oversized pinky hits Insert while using arrow keys
08:55:06 <glguy> I grabbed this one and now it doesn't have a proper 2 rows of 3 keys block
08:55:47 <glguy> (I was in a hurry when I grabbed it up)
08:56:09 <sorear> alexj: how about writing an easy-to-use Haskell DSEL, which after inlining fu becomes an XSLT string literal?
08:56:22 <JKnecht> (lemme ask here) anybody use Chinese in Emacs?
08:56:45 <sorear> alexj: after you finish curing cancer, of course :p
08:57:21 <alexj> sorear: mutjida is doing that for javascript
08:57:49 <alexj> as for cancer, I am good friends with the CEO of SNTA
08:57:53 <sorear> I knew there was something like that for js, hence inspiration :)
08:58:03 <sorear> @vera SNTA
08:58:04 <lambdabot> No match for "SNTA".
08:58:11 <alexj> snta is a stock quote.
08:58:18 <sorear> @google SNTA
08:58:20 <lambdabot> http://www.snta.com/
08:58:29 <sorear> ... cmon Title:
08:58:40 <alexj> http://syntapharma.com/
08:58:41 <lambdabot> Title: Synta Pharmaceuticals Corp.
08:59:38 <alexj> sorear: if you don't like xslt, use hsxml, or haxml, or xmltoolkit.
08:59:58 <alexj> my point is that xml->xml transforms belong in separate code.
09:00:31 <allbery_b> hm.  M-: (global-unset-key [insert]) or some such?
09:00:46 <alexj> personally, I like xslt because you can cut/paste from html produced by people whose job is to make nice looking html.
09:01:23 <yip> alexj: are you familiar with any of the many python template engines?
09:01:24 <JohnnyL> json is better than xml.
09:01:54 <sorear> so are ADTs, but that's beside the point.
09:01:59 <sorear> (i think)
09:02:10 <chessguy> > let und True _ = id; und _ _ = False in und True True
09:02:10 <lambdabot>  Couldn't match `a -> a' against `Bool'
09:02:28 <alexj> yip: I built one about 6 years ago and then deciced it was simpler just to use xslt.
09:02:42 <alexj> s/6/7/
09:03:01 <chessguy> hmm, why doesn't that work?
09:03:07 <alexj> but I am not at all current on how they are today.
09:03:28 <xic> alexj: oh, well i'm making a clone of the python django framework's template engine in haskell
09:03:32 <Vq^> chessguy: shouldn't it be  und True = id ?
09:03:33 <xic> alexj: i don't like xslt
09:03:47 <Lemmih> > let und True = id; und _ = const False in und True True
09:03:48 <chessguy> > let und True = id; und _ _ = False in und True True
09:03:48 <lambdabot>  True
09:03:48 <lambdabot>  arity mismatch for 'und'
09:03:57 <Lemmih> Greetings alexj.
09:04:09 <chessguy> > let und True = id; und _ = False in und True True
09:04:09 <lambdabot>  Couldn't match `a -> a' against `Bool'
09:04:23 <alexj> lemmih: greetings
09:04:25 <chessguy> > let und True = id; und _ = const False in und True True
09:04:26 <lambdabot>  True
09:04:28 <chessguy> hmm
09:04:34 <alexj> xic: ok cool!
09:09:00 <dmhouse> chessguy: the more natural way is und True b = b; und _ _ = False.
09:09:01 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
09:09:11 <dmhouse> ?code (&&)
09:09:11 <lambdabot> Maybe you meant: more todo vote
09:09:20 <chessguy> dmhouse, bah. natural is boring :)
09:09:34 <chessguy> just kidding. i just wanted to play with it
09:09:44 <sorear> ?src &&
09:09:44 <lambdabot> Source not found. stty: unknown mode: doofus
09:09:47 <sorear> ?src (&&)
09:09:48 <lambdabot> True  && x = x
09:09:48 <lambdabot> False && _ = False
09:09:52 <sorear> dmhouse: ^^^
09:09:57 <dmhouse> That's the one.
09:10:06 <kpreid> paolin1: how's it going?
09:12:05 <tuukkah> i wonder what i'm doing wrong here: makeNewGObject mkStyle $ liftM castPtr $ {# call gtk_rc_get_style #} $ castPtr $ unsafeForeignPtrToPtr $ unWidget $ toWidget widget
09:13:11 <sorear> replace the first $ with a =<< maybe?
09:13:22 <sorear> (I assume you're tring to fix type errors)
09:13:26 <quicksilver> paolin1: from your initial description it sounds to me like a parametric data type is enough
09:13:31 <sorear> and then parenize the RHS
09:13:35 <quicksilver> paolin1: possibly parametric in the type of state
09:13:41 <tuukkah> the type is actually correct
09:13:43 <quicksilver> paolin1: or possibly parametric in a monad, or something
09:14:09 <tuukkah> but it looks ugly and doesn't work =)
09:15:27 <tuukkah> of course there's the unsafe part which must be a hint to me...
09:15:34 <hpaste>  paolino pasted "freetyped plugins" at http://hpaste.org/468
09:16:51 <paolin1> now I want to substitute the second add1 with addchar
09:18:11 <paolin1> and the second state with ""
09:18:23 <kpreid> paolin1: since the actions don't change you can pair them with the states and hide the variation
09:20:25 * allbery_b doesn't see why it can't be parameterized with something like MonadState s m => ...
09:20:26 <paolin1> mmh I'm not getting that  :/
09:21:08 <kpreid> paolin1: since the type of the state elements varies, the only thing you can do to it is apply the corresponding action
09:21:28 <quicksilver> MonadState s m was the kind of thing I was thinking of
09:21:58 <kpreid> paolin1: therefore, you can model it as a data type hiding the internal state type, using a function or an existential type
09:26:08 <kpreid> paolin1: oh, that won't quite work because you're trying to return the list of results; you can't have a polymorphic list, so you need to do this some other way (possibly with a function which converts the states to a uniform type)
09:26:38 <kpreid> that function could be 'show', for example, to make the program you gave work
09:26:38 <quicksilver> you can return a polymorphic list. But there may be better ways to do it :)
09:27:23 <paolin1> what should go in the states ?
09:27:33 <kpreid> paolin1: what are you trying to accomplish?
09:27:51 <kpreid> paolin1: where do these differing-type states come from, and what are you going to do with them afterward?
09:28:47 <paolin1> let the user define which actions a cell should do in its life
09:29:09 <paolin1> and schedule them whenever the cell living time has come
09:29:53 <paolin1> not very different from the code I pasted
09:30:44 <allbery_b> well, at worst I'd think a Cell typeclass with, say, schedule and action functions and parametric in a state type
09:31:36 <allbery_b> and runCell which you would provide, which uses only the attributes visible from the Cell class
09:31:43 <paolin1> the user decided every time the cell is alive it should add1 and addchar to the 2 relative states
09:32:56 <dylan> hmm
09:33:13 <paolin1> newtype ActionInt = ActionInt Int
09:33:14 <paolin1> instance Action ActionInt where
09:33:14 <paolin1>    action = ....
09:33:14 <paolin1>    
09:33:15 <dylan> Graphics.X11.Xlib has no getProperty
09:34:33 <paolin1> what signature should action have ?
09:38:51 <paolin1> newtype (Action s)  => Runner s = Runner $ RWS [State s a] () [s] ?
09:39:18 <hpaste>  kpreid annotated "freetyped plugins" with "hidden state" at http://hpaste.org/468#a1
09:39:34 <kpreid> paolin1: this annotation shows the minimal change to do it the way I proposed
09:40:06 <allbery_b> action takes a function parameter which takes a CellAction and produces an a, and its result type is CellState s a => a?  or something similar
09:40:33 <allbery_b> you can pass as many other things as you want to your function, as long as the partial application matches the expected type
09:40:38 <kpreid> paolin1: it produces the output ["10","\"pppppppppp\""]
09:45:22 <paolin1> I suppose I can exit the B stuff instead of using show right ?
09:46:37 <kpreid> paolin1: you can supply any suitable function in place of show
09:46:59 <kpreid> paolin1: but if you're going to put them in a list of results, the functions must have the same result type
09:47:27 <paolin1> like B v o x ?
09:47:30 <kpreid> no
09:47:38 <kpreid> it has to be of type x -> o
09:47:55 <kpreid> in the case of show, o is String
09:48:28 <kpreid> the whole purpose of that function is to get a value you can use without knowing the type hidden by B
09:49:03 <kpreid> the type variable names for B are a bit confusing, unfortunately
09:49:10 <kpreid> I should have thought about it more
09:49:51 <kpreid> the first type parameter of B is the type of the return value from the transition functions (in this case, Bool)
09:50:05 <kpreid> the second parameter is the output type
09:50:33 <kpreid> the first field of B is the transition function; the second is the output function; and the third is the actual state
09:53:13 <paolin1> uhm , [B add1 show 0, B addchar show ""] , why the output can't be like this ?
09:54:39 <kpreid> you mean, have the type [B ...]?
09:54:41 <kpreid> sure it can
09:54:55 <kpreid> the only thing is that you can't do much with Bs
09:55:26 <paolin1> (\B _ _ x -> x).head ?
09:55:30 <kpreid> that's why outB exists: to get information out of the box
09:56:09 <kpreid> paolin1: what is the type of (\B _ _ x -> x)?
09:56:30 <kpreid> it has no correct type, and is disallowed
09:56:33 <paolin1> error ?
09:56:38 <kpreid> because the type variable is not part of B's type
09:57:00 <kpreid> paolin1: what are you actually going to do with these things? display them somehow?
09:57:16 <paolin1> sure
09:57:29 <kpreid> then replace 'show' with functions which display the values how you want
09:57:53 <paolin1> anyway I must project them to a unique type
09:58:14 <paolin1> if I want to list them
09:58:14 <kpreid> sorry, I don't understand that
09:58:21 <kpreid> a *uniform* type, yes
09:58:30 <paolin1> uniform ok
09:59:02 <paolin1> what is that forall ?
09:59:13 <paolin1> the hider ?
09:59:26 <xic> has anyone ever propsed adding Data.Map syntax to haskell, like python: { "foo": 3, "bar": 4 }
10:00:16 <ndm> xic, [("foo",3), ("bar", 4)] - not really that much work
10:00:49 <ndm> xic, and if you want to do better, ["foo" $= 3, "bar" $= 4]
10:01:02 <xic> ndm: you also need to call fromList on that
10:01:05 <ndm> you wonder if you need new syntax for 1 character per item
10:01:12 <ndm> xic: true, but its hardly that much more
10:01:12 <Saizan> ?hoogle ($=)
10:01:13 <lambdabot> Did you mean: ($=)
10:01:13 <lambdabot> Prelude.undefined :: a
10:01:13 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:01:24 <ibid> the show/read syntax seems to be fromList [("fii",3)]
10:01:26 <kpreid> paolin1: it establishes the scope of the type variable x
10:01:36 <ndm> Saizan: i was introducing my own ($=) = (,)
10:02:03 <ndm> ?hoogle $=
10:02:03 <lambdabot> No matches found
10:02:25 <Saizan> ndm: oh ok, i've seen that before, something of HOpengl?
10:02:46 <ndm> Saizan: i haven't seen it before, hence why i picked it, but every operator means something in some combinator library
10:03:14 <xic> <#<@@!!|>
10:03:33 <paolin1> thanks kpreid, I do some work on to digest it
10:03:35 <Saizan> yeah, we don't have enough symbols on our keyboards :)
10:03:48 <ddarius> The good ole =^.-= operator.
10:03:52 <ndm> Saizan: you can use unicode in GHC 6.6, if you are crazy and hate your users
10:04:24 <ddarius> Hey, I might fit into that category.
10:04:42 <Saizan> i'm too lazy just to use them for myself :D
10:11:09 <ddarius> Hmm, would anybody be interested in a Midi -> Guitar tab converter, do you thinkL
10:11:53 <ndm> ddarius: best to do things you'd like, rather than for other people
10:14:07 <ddarius> ndm: Oh, I've already done it.
10:14:40 <ndm> ddarius: oh, in that case i'm sure someone might be interested in either it, or the code behind it
10:15:17 <ddarius> The code is pretty simple, but it is kind of interesting in that it goes through a textual intermediate that can be used to make midi files.
10:24:24 <paolin1> @type liftM2
10:24:25 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:25:31 <flaggy> hello, is there some tutorial that will help me with modularization on haskell?
10:26:08 <chessguy> flaggy, hmm. do you know monads yet?
10:26:14 <flaggy> yes
10:26:38 <chessguy> you might be interested in Cale's monad transformer article, on using monad transformers to modularize your code
10:26:47 <chessguy> ?where calewiki
10:26:47 <lambdabot> I know nothing about calewiki.
10:26:51 <chessguy> ?where cale
10:26:51 <lambdabot> http://cale.yi.org/
10:27:10 <chessguy> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
10:27:14 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
10:28:09 <flaggy> I have a more general function, called genericClip, which takes Polygons as parameters and returns a Storable. Now, I have two storable classes, the Polygon class and a class named Strip. I have the Polygon class and its functions on a module and the Strip class and its functions on another module, I'm unsured where I place the genericClip function, which both modules need.
10:28:15 <sorear> flaggy: monad transformers are mostly used with really BIG programs, lambdabot big, most programs can get by with just teh module system
10:28:24 <flaggy> hm
10:28:27 <flaggy> let me see that
10:29:27 <sorear> hmm, sounds like excessive use of classes - I think Strip and Polygon can get by being monomorphic, and what are you using Storable for!?
10:30:00 <sorear> or is your Storable unrelated to Foreign.Storable.Storable?
10:30:08 <flaggy> I'm doing a wrapper from a C code
10:30:15 <flaggy> no, it's related
10:30:21 <flaggy> it's that one
10:30:30 <sorear> ah
10:30:57 <flaggy> Strip and Polygon are types from the C code, that's why I made them into haskell classes
10:31:58 <sorear> unless you need subtyping (a GtkButton is a GtkWidget), usually you just use data/newtypes
10:32:13 <sorear> like newtype Strip = StripP (Ptr Strip)
10:36:01 <flaggy> I did it like that because I wanted the people using the haskell code to be able to create polygons on haskell, and not only load a polygon from some file and use it with the C operations
10:37:40 <sorear> C-wise, is a Polygon mutable?  and do you want to expose the mutability?
10:38:09 <sorear> Ie for usage do you want intersect (triangle x y z) (square x y)
10:38:44 <sorear> or do { t <- newTriangle x y z ; sq <- newSquare x y ; intersectEq t sq ; return t }
10:40:12 <flaggy> yes, you can add or remove vertices from the polygon on the C code, I want to be able to do that on haskell
10:40:33 <flaggy> i didn't quite understand your point on those two examples
10:41:25 <yip> which fold is the best?
10:41:32 <sorear> well, you understood my actual question, so I suppose the examples don't matter :)
10:41:37 <sorear> yip: foldr.
10:41:44 <yip> sorear: thanks
10:41:45 <sorear> foldr is a catamorphism
10:41:57 <sorear> foldl is an ugly ad-hoc recursive function
10:42:12 <sorear> foldr corresponds to the actual structure of the lists
10:43:06 <sorear> yip: note that foldr works best wih lazy functions, and with strict ones like GHC.Num.+ @ GHC.Int.Int, foldl' is pragmatically better
10:47:02 <dancor> fOnFst :: [(a, b)] -> (a -> c) -> [(c, b)]
10:47:26 <dancor> @hoogle [(a, b)] -> (a -> c) -> [(c, b)]
10:47:26 <lambdabot> No matches, try a more general search
10:48:29 <xerox> :t flip (map . first)
10:48:30 <lambdabot> forall b c d. [(b, d)] -> (b -> c) -> [(c, d)]
10:49:22 <dancor> ooh first
10:49:32 <xic> so foldl' is better?
10:50:01 <flaggy> no
10:50:08 <flaggy> it all depends on what you want to do
10:50:48 <Saizan> foldl' is better if you are going to consume all the list before returning something
10:51:23 <xic> Saizan: i think i am
10:51:26 <dancor> i'm aligning ='s
10:51:51 <dancor> in  getContents >>= lines
10:52:09 <xerox> :t lines `fmap` getContents
10:52:11 <lambdabot> IO [String]
10:52:15 <dancor> so if we call that l i'm doing  map (splitAt '=') l
10:52:36 <dancor> and then i want to right pad all the fst's of that to make them the same size
10:52:43 <dancor> pad with spaces
10:52:57 <dancor> and then recombine them
10:53:20 <dancor> ok not splitAt
10:54:27 <dancor> is there a splitAt that splits at a certain value
10:55:23 <sorear> like Eq a => a -> [a] -> ([a],[a]) ?
10:55:39 <sorear> I think you want then
10:55:45 <sorear> @ty break . (==)
10:55:46 <lambdabot> forall a. (Eq a) => a -> [a] -> ([a], [a])
10:55:54 <dancor> ah nice
10:56:02 <sorear> > (break . (==)) ' ' "Hello, world!"
10:56:03 <lambdabot>  ("Hello,"," world!")
10:56:23 <sorear> ^^ good?
10:58:34 <Cheery> Anyone here working for google?
11:00:22 <Cheery> If one is, do you really have chick robot army there who knows all the languages in world?
11:01:15 <sorear> Cheery: did you check the date on the page? *hint* *hint* *hint*
11:01:33 <Cheery> how so? :P
11:02:09 <Cheery> hmm. sorear, your break command is interesting.
11:02:10 <sorear> I haven't seen that specific statement, but it has all the makings of a Google AFJ announce.
11:02:28 <sorear> s/AFJ/AFD/
11:02:51 <Cheery> I see. I would just have been interested to ask to what it bases on. :)
11:03:42 * sorear is now compiling jhc for heap profiling :(
11:05:49 <Cheery> > (filter . (<)) 'l' "hello, fucker!"
11:05:50 <lambdabot>  "our"
11:06:02 <Cheery> LHS notation rulez.
11:06:38 <glguy> Is "image-based persistence" necessarily at odds with "static type-checking"?
11:06:59 <sorear> non!!
11:07:03 <sorear> no!!
11:07:28 <sorear> you can perform full tc on definitions as they are added
11:07:31 <glguy> sorear: do you know any examples of image-based languages with static type-checking?
11:07:37 <Cheery> nil.
11:07:39 <sorear> see ... gah I haven't written it yet.
11:08:27 <sorear> how does Yale haskell sound? (never used it so I don't know if it qualifies)
11:08:38 <glguy> I haven't used it either...
11:08:46 <shapr> dbremner: Improper programming breaking an FPGA should be the user's problem. I'm not convinced about the device changes, ATI & Nvidia do that already.
11:10:47 <sorear> shapr: dbremner hasn't spoken here in >48 hrs
11:10:57 <dancor> so why wasn't hoogle able to tell me what xerox did
11:11:02 <dancor> too hard?
11:11:08 <shapr> sorear: I know, but we've been swapping lambdabot messages, and for once we're both online.
11:11:34 <glguy> sorear: do you use xemacs or emacs?
11:11:47 <dancor> or are there all kinds of combinations of 3 (4?  i guess . counts?) things that would match
11:11:48 <shapr> What was the wm to try other than wmii?
11:11:53 <glguy> dwm?
11:12:12 <shapr> Ok, I'll try that one now, thanks.
11:12:55 <alexj> glguy: happs is drifting into becoming an image based framework with static typechecking.
11:13:16 <dylan> dwm is good, as long as you patch it. ;)
11:13:19 <glguy> alexj: How so? (I hadn't noticed)
11:13:19 <sorear> glguy: rmsmacs .. why?  I've never tried xemacs and I'm sure I wouldn't notice the difference, but I don't use X so it didn't sound appealing.
11:13:37 <xic> anyone know how to do parse an escaped string with parsec?
11:13:41 <alexj> glguy: state is maintained and you update state by sending it events.
11:13:42 <sorear>  4364 stefan    18   0  378m 339m 7404 D  7.9 89.9  11:56.23 ghc-6.6
11:13:46 <sorear> ^^^ YAYA!!!
11:13:56 <sorear> GHC is thrasing!
11:13:58 <alexj> you don't specifically load/save state.  you don't start/end a program.
11:14:01 <sorear> I <3 linux VM
11:14:12 <glguy> sorear: I was thinking of trying emacs out again and didn't know what one to use
11:14:33 <TuringTest> glguy: Which platform?
11:14:45 <glguy> Win32 and Openbsd (I'd like to pick one for both)
11:15:05 <glguy> alexj: and with HList you wont have to jump through hoops to change the state type
11:15:13 <TuringTest> glguy: What type of documents do you edit?  Do you use cygwin or X11 on Win32?
11:15:49 <glguy> TuringTest: I will mostly use it to edit Haskell code.  Ido have cygwin installed but wouldn't mind running the application from openbsd and using cygwin/x
11:16:00 <alexj> that is my hope.
11:16:27 <glguy> alexj: will there eventually be a console interface to running transformations on the state?
11:16:35 <TuringTest> glguy: If you use latex, then I suggest whatever auctex suggests.  For just haskell: the ghc compiler is not a cygwin executable...hmm....
11:17:01 <glguy> TuringTest: why does ghc need to be a cygwin executable?
11:17:28 <alexj> glguy: not sure what you mean.  does http count?
11:17:30 <emu> glguy: i also use fsf emacs
11:17:30 <sorear> Linking jhcp ... -- finally!
11:18:00 <emu> frankly, i thought x emacs was dying (the x has nothing to do with X, btw)
11:18:02 <glguy> alexj: I suppose I actually meant more of an hs-plugins interface where new functions could be loaded and executed at runtime
11:18:12 <glguy> alexj: like with lambdabot
11:18:22 <glguy> so you could > transformState (\x -> whatever x)
11:18:27 <glguy> or
11:18:36 <glguy> similarly: > queryState someQuery
11:18:46 <sorear> ---11:17 6.83----  STILL LINKING
11:18:52 <alexj> i'd love it if someont implemented that.  I was assuming it would be ghc-api rather than hsplugins based but yes either way.
11:19:17 * sorear never knew linkers could be this slow
11:19:33 <glguy> alexj: I just thought that that level of interaction with the application would be quite beneficial (I don't know what the ghc-api does)
11:19:54 <alexj> ghc-api lets you dynamically load haskell code -- hsplugins rides on top of it.
11:19:59 <glguy> alexj: I suppose that a HTTP interface to such functionality makes more sense for HAppS than a console interface
11:20:27 <sorear>  5230 stefan    18   0  137m  35m  824 D  0.7  9.4   0:06.68 ld
11:20:34 <alexj> it would not be very hard to write an actual console interface.  just not on my todo list.
11:20:45 <TuringTest> glguy: You don't need cygwin.  For GNU emacs, I suggest reading http://www.emacswiki.org/cgi-bin/wiki/EmacsW32
11:20:47 <lambdabot> Title: EmacsWiki: EmacsW32
11:21:28 <dpiponi> Anyone out there played much with PFP? (http://web.engr.oregonstate.edu/~erwig/pfp/)
11:21:29 <lambdabot> Title: PFP - Probabilistic Functional Programming in Haskell
11:21:34 <sorear> load avg at 7.80 and rising
11:21:41 <TuringTest> glguy: For XEmacs, go to the http://www.xemacs.org/ homepage.
11:21:43 <lambdabot> Title: XEmacs: The next generation of Emacs
11:21:44 <sorear> dpiponi: syntaxfree
11:21:51 <TuringTest> glguy: I use GNU, but both should work.
11:21:58 <glguy> TuringTest: that's what I was trying to figure out, emacs vs xemacs :)
11:22:04 <sorear> FINALLY!!
11:22:14 <sorear> Linking finished!
11:22:38 <sorear> -rwxr-xr-x 1 stefan src 33M Feb 12 10:57 jhcp  Huge binaries, eh?
11:23:06 <alexj> glguy: the thing that worries me about pure image based stuff is that publishing code to a live server using a different state gets very complex.
11:23:08 <sorear> 23M stripped
11:23:17 <dpiponi> sorear: thx
11:23:24 <TuringTest> glguy: If Xemacs were going to displace emacs it would have by now.  XEmacs has a better package management system for extensions.   But as I said, I use GNU.
11:23:59 <glguy> alexj: how do you think that HAppS addresses that concern?
11:24:33 <sorear> jhc: no input files \n\n real    0m0.011s
11:24:40 * sorear <3 demand paging
11:24:41 <abz> ?doc Control.Monad
11:24:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
11:24:50 <TuringTest> sorear: What is the status of jhc these days?
11:24:51 <alexj> glguy: the main value to me of the ghc-api code is that you don't have to restart the server to test new code.
11:25:14 <alexj> you just update the source in your dev instance and the running instance reflects teh new source.
11:25:23 <glguy> alexj: I was looking at it from the prespective of not having to recompile to alter a running state or to check the status of it
11:25:25 <abz> ?doc Control.Arrow
11:25:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
11:25:37 <sorear> jhcp is 7x larger than msword.exe was on an old computer of mine, and loads in about 1/1000 the time
11:25:42 <sorear> TuringTest: big
11:26:00 <sorear> TuringTest: It want 500MB of ram, I have 384M.
11:26:06 <alexj> glguy: yes.  that is really useful.  it would also be nice not to have to restart the server everytime you update its code.
11:26:15 <glguy> alexj: agreed
11:26:18 <TuringTest> sorear: Ah...not big per se, but hungry....
11:26:25 <alexj> they are somewhat different issues.
11:26:36 <sorear> TuringTest: Linux VM is you'd-never-consider-turning back, but still it thrashes hard.
11:26:38 <alexj> in one case, you want to make your dev process really easy.
11:26:57 <alexj> in the other case, you want to minimize live server downtime during upgrades.
11:27:16 <TuringTest> sorear: But the main question is: for what programs does it work?
11:27:37 <glguy> alexj: could there simply be a mechanism for requiring a state transformation to be executed before the new code is loaded?
11:27:47 <glguy> "simply"
11:27:56 <sorear> TuringTest: none.  it fails to compile "Hello world" by throwing a StefanHasLostPatienceException.
11:28:08 <TuringTest> heh
11:28:19 <abz> ?src hoogle
11:28:19 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:28:31 <sorear> that happened after about 4h real, 30m user
11:28:39 <sorear> as I said, VM rocks
11:28:55 <alexj> glguy: yes.  my hope is that the hlist code makes this easier.
11:28:55 <Jaak> http://term.ie/data/coder_lifecycles.png
11:28:57 <sorear> ?where hoogle
11:28:57 <lambdabot> http://www.haskell.org/hoogle
11:31:51 <abz> thanks.
11:35:39 <EvilTerran> is there any way to get text in HGL to appear in its normal proportions? i'm confused by mkFont and whatnot requesting a Size, especially in the case of non-monospaced fonts
11:38:40 <kolmodin> have you guys seen this? http://img232.imageshack.us/img232/4391/hugshanvr7.jpg
11:39:44 <EvilTerran> i hadn't, and i wish that were still the case.
11:39:46 <EvilTerran> ><
11:39:58 <tibbe> when's the next hackathon?
11:40:22 <sorear> #haskell.hac07 is still populated!
11:40:25 <kolmodin> tibbe: in a year, probably
11:40:43 <tibbe> oh, when was the last one?
11:40:53 <kolmodin> tibbe: jan 9-13
11:41:09 <tibbe> oh
11:41:24 <tibbe> I've been missing out
11:41:27 <tibbe> in the US?
11:41:28 <kolmodin> gothenburg was quite well represented
11:41:33 <kolmodin> tibbe: no, oxford
11:41:34 <tibbe> or UK?
11:41:36 <tibbe> ok
11:41:57 <tibbe> I'm in Zurich now so anything in Europe should be in reach.
11:42:34 <kolmodin> yeah, the US is a bit far (and expensive)
11:42:58 <Maddas> tibbe: Do you live in Zurich? (Just curious)
11:43:15 <tibbe> Maddas, yes, at the moment
11:43:21 <tibbe> kolmodin, agreed
11:43:34 <Maddas> tibbe: Neat. Any interesting Haskell activity around there?
11:43:51 <tibbe> Maddas, not that I know of but I move here 4 weeks ago so...
11:43:53 <Maddas> (I'm asking because I study in Zurich ;-) But I'm in Gothenburg now)
11:44:00 <Maddas> tibbe: ah, okay :-)
11:44:13 <sorear> what effect does profiling normally have on memory use?
11:44:16 <tibbe> Maddas, o cool
11:44:25 <glguy> it increases it :)
11:44:43 <sorear> JHC seems much better behaved (25% from 150%) now that I recompile it for profiling ...
11:45:24 <augustss> sorear: oh, you got jhc to work?
11:45:25 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
11:45:35 <sorear> augustss: it RUNS
11:45:59 <ndm> anyone got lhs2tex working on windows?
11:46:01 <sorear> augustss: doesn't mean I've obtained output yet :)
11:46:09 <augustss> ah
11:46:27 <sorear> augustss: now, I'm feeding JHC through the heap profiler - hopefully I'll shrink it enough to run
11:46:48 <augustss> heh
11:46:52 <augustss> ok
11:47:05 <sorear> (JohnMeacham said himself there is a great deal of "low hanging fruit" that he never bothered to deal with)
11:47:35 * glguy uninstalls all of his personal interest programs from his work computer and reinstalls them in a virual openbsd machine
11:48:26 <ndm> glguy: half way between virtual and viral?
11:49:18 <augustss> it's the openbsd virus
11:49:33 <Eelis> is there such a thing as a separate derived instance declaration? that is, can i have the compiler derive an instance for some data type separately from the data type definition?
11:50:29 <ndm> Eelis: in GHC 6.8 (not yet released), yes, otherwise, no
11:50:38 <Eelis> ndm: i see. thanks
11:50:44 <ndm> Eelis: or you can use Drift, which lets you do the same thing but with a preprocessor
11:51:33 <Eelis> i take it that for Drift to work it needs to be able to see the data type definition in the source?
11:51:47 <ndm> Eelis: yes
11:51:49 <vincenz> hiya Eelis
11:51:50 <Eelis> i want to make library types such as OpenGL vectors readable (instances of Read)
11:51:58 <Eelis> vincenz: hiya
11:52:06 <ndm> Eelis: why? if the answer is to do serialisation, thats a bad choice
11:52:18 <Eelis> ndm: not serialization, configuration.
11:52:29 <vincenz> Eelis: why not just do "deriving (Read)" ?
11:52:41 <vincenz> Eelis: or otherwise you can easily define the instance for Read, I don't think it'd be a lot of work
11:52:46 <Eelis> vincenz: because the data type definition isn't in my own code, it's somewhere in the HOpenGL library
11:52:57 <vincenz> Eelis: you -can- however define your own read instance if none exist
11:53:11 <vincenz> instance Read TheTypeYou'reInterested in where ...
11:53:17 <ndm> vincenz: but its not fun at all...
11:53:22 <Eelis> yeah, i know, but then i have to spell it all out myself
11:53:22 <ndm> (esp for read)
11:53:23 <vincenz> ndm: nor is it difficult
11:53:32 <ndm> vincenz: Read is non-trivial at best
11:53:43 <vincenz> ndm: meeh
11:53:55 <vincenz> ndm: not for the auto-generation that deriving(Read) would generate
11:53:58 <sorear> list compos make Read easy
11:54:40 <sorear> it's like the 1993 version of Parsec, and almost as nice
11:55:19 <Eelis> i currently use a different workaround. when i want to make library type X readable, i define X' which is identical except that it derives from Read, and then define an instance of Read for X which invokes the read function for X' and converts the result into an X
11:55:52 <vincenz> Eelis: eww
11:55:58 <Eelis> it's simple and concise, but indeed eww
11:56:02 <vincenz> Eelis: just define your own read, it's not that difficult if you want to mirror deriving(Read)
11:56:20 <ndm> DrIFT can derive Read
11:56:25 <vincenz> or use drift :)
11:56:49 <Eelis> i'll have a look at drift.
11:57:32 <glguy> what is this "DrIFT"
11:57:48 <TuringTest> ?where DrIFT
11:57:49 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
11:58:37 <chessguy> ?where drift
11:58:38 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
12:07:31 <sorear> jhc's heap profile is very interesting
12:08:05 <sorear> the avg memory use is half the max memory use, and the entire difference is accounted for by one cost center context
12:08:22 <sorear> if I can fix applySubst, jhc's memory use will be cut IN HALF
12:09:06 <sorear> 500MB-before-I-gave-up -> 250MB at same point, no swapping, 30m real 30m user MAX
12:10:24 <JohnnyL> @users
12:10:24 <lambdabot> Maximum users seen in #haskell: 322, currently: 311 (96.6%), active: 44 (14.1%)
12:12:58 <tibbe> if I would to write a Trac for Haskell/Darcs/Cabal what featues would be nice?
12:13:11 <joakim> good evening folks
12:13:48 <tibbe> evening
12:13:56 <joakim> how's life?
12:14:20 <defcon8> it's haskelly
12:14:22 <tibbe> swimming
12:14:38 <tibbe> in need of haskell project
12:15:20 <joakim> know of any tutorial where i can learn how to use scanner generators?
12:15:26 <joakim> flex
12:15:27 <kowey> http://www.haskell.org/haskellwiki/Ideas_for_projects
12:15:28 <lambdabot> Title: Ideas for projects - HaskellWiki
12:16:00 <kowey> (oops, sorry, i thought somebody was looking for a project idea)
12:16:19 <EvilTerran> this doesn't seem to exist in the context of an "import Graphics.HGL"; am i missing something? -- http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL-Draw-Text.html#v:textInfo
12:16:21 <lambdabot> http://tinyurl.com/33qdel
12:16:42 <glguy> anyone know what program you use to host XDMCP sessions?
12:16:46 <ndm> tibbe: being identical to the Google bug tracker
12:16:51 <tibbe> kowey, I am
12:17:01 <tibbe> ndm, what's good about it?
12:17:11 <tibbe> is it Google's SF look alike?
12:17:22 <ndm> tibbe: it acts like it was written by Google, rather than a drunken monkey
12:17:45 <bryanl> i'm just starting with haskell on the mac.  should i start with hugs or should i start with ghc?
12:17:53 <ndm> tibbe: SF look alike is quite a way off, wiki/bug tracker/source code hoster - a lot nicer interface than Sourceforge
12:17:56 <EvilTerran> ah. "$packages/HGL/Graphics/HGL/Draw/Texths: -- ToDo: add textInfo to Win32"
12:17:59 <ndm> bryanl: hugs is usually easier to start
12:18:13 <bryanl> glguy: the X server hosts XDMCP sessions
12:18:19 <tibbe> ndm, I'll check it out
12:18:25 <EvilTerran> rats
12:18:38 <ndm> tibbe: the Yhc project uses the bug tracker extensively, if you want to take a look at a sample project
12:18:39 <glguy> bryanl: what if I *only* want to host remote XDMCP sessions
12:18:50 <ndm> tibbe: http://code.google.com/p/yhc/issues/list
12:18:51 <lambdabot> Title: yhc - Google Code
12:18:52 <tibbe> ndm, url?
12:18:54 <allbery_b> glguy: [xkg]dm, with appropriate configuruation
12:18:59 <jeroeng> Can someone tell me whether it is possible to write filterC::ArrowChoice a => a b Bool -> a [b] [b] in terms of filterA :: ArrowChoice a => a b Bool -> a [b] [b] ?
12:19:01 <bryanl> glguy: you'll still have to run the X server
12:19:43 <allbery_b> it used to be possible to configure xdm, at least, to not run an X server on the console; kdm, on the other hand, didn't work when I tried it.  it might be possible these days
12:19:46 <ndm> tibbe: the tagging is particularly nice and light weight in their bug tracker
12:19:46 <sorear> jeroeng: what difference do you want? those sigs look identical
12:20:06 <allbery_b> the console is no different from any other session as far as xdm is concerned
12:20:19 <tibbe> thanks
12:20:20 <bryanl> ndm: thanks :)
12:20:46 <tibbe> ndm, I will definately check it out, the thing is that someone turned on the laundry machine in the room next door so my internet connection isn't working well ;)
12:20:54 <tibbe> ie it'll take time ;)
12:20:57 <ndm> tibbe: lol :)
12:20:58 <jeroeng> sorear: My bad, filterC should be of type ArrowChoice a => a (b, c) Bool -> a (b, [c]) [c] . I can define it explicitly, but I can't do it in terms of filterA
12:21:09 <ndm> @quote+ tibbe I will definately check it out, the thing is that someone turned on the laundry machine in the room next door so my internet connection isn't working well ;)
12:21:09 <lambdabot> No quotes for this person. It can only be attributed to human error.
12:21:18 <ndm> @help quote+
12:21:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:21:28 <ndm> @remember tibbe I will definately check it out, the thing is that someone turned on the laundry machine in the room next door so my internet connection isn't working well ;)
12:21:28 <lambdabot> Done.
12:21:48 * allbery_b knows that one too well
12:21:49 <ndm> @tell dons why doesn't quote+ do a remember? its an inconsistent user interface, given where and where+
12:21:49 <lambdabot> Consider it noted.
12:22:59 <sorear> ndm: so where can I find more information on the design of -O11? is it in the catch draft paper?
12:23:09 <ndm> sorear: no, its in my brain
12:23:49 <ndm> sorear: but at some point it will move into my thesis, or perhaps a paper (depending on performance results in the real world) - it won't make it to the Catch paper
12:24:13 <ndm> although the firstification algorithm will make it into the Catch paper, which is a cutdown version of the -O11
12:25:45 <tibbe> ndm, I don't see that many tags in use, for what do you find them useful?
12:25:56 <[ira]> I just checked out the shootout again... ghc is kicking serious butt
12:26:21 <ndm> tibbe: component, difficulty, os-specificness, beginner
12:26:24 <[ira]> cpu: 6th, mem: 8th
12:26:25 <sorear> [ira]: it's more a question of the brains in #haskell.
12:26:45 <ndm> tibbe: they are much more light weight, i think you might need an account on a project to play with them in detail
12:26:54 <[ira]> fair enough, y'all are kicking serious butt :)
12:26:58 <sorear> [ira]: dons has admitted to incrementally tweaking the entries, *while diffing the generated assembly*
12:27:12 <tibbe> ndm, I guess I'll develop my PM system using my PM system and see what I find useful ;)
12:27:19 <tibbe> automatic build using cabal would be nice
12:27:29 <tibbe> and quickcheck tests
12:27:36 <ndm> tibbe: oh yes, it has no integration with anything else
12:27:45 <ndm> tibbe: but as bug trackers go, its simple and beautiful
12:27:59 <glguy> hurrah, xdm works now
12:28:33 <sorear> ndm: does -O11 start from Yhc Core, or does it use a richer (I'm thinking types) input?
12:29:02 <ndm> sorear: untyped Yhc Core
12:29:04 <tibbe> ndm, simple will surely be the key if I'm going to write it, I'm a lazy programmer
12:29:28 <ndm> tibbe: Google bug tracker is beautiful and simple, its easy to make stupid and simple unless you are careful ;)
12:29:40 <tibbe> :)
12:29:54 <tibbe> I wish I had some UI design talent
12:30:18 <defcon8> who needs ui?
12:30:54 <tibbe> ndm, oh I see it now, priority and everything is implemented using just tags, didn't get that at first
12:31:07 <tibbe> defcon8, your computer? :)
12:31:18 <defcon8> well I guess cli is okay
12:31:21 <ndm> tibbe: yes, thats the cute bit - a lot less than trac, but a lot more powerful at the same time
12:31:45 <sorear> defcon8: CLI *is* ui
12:31:52 <defcon8> yes
12:32:02 <defcon8> but I don't think tibbe was referring to that
12:32:10 <pejo> defcon, some members in this channel has written their own device drivers for laptops they bought in the past. Oddly enough - it turns out they prefer to have all hardware supported and things to just work when asked though.
12:32:47 <defcon8> pejo, sorry, I don't know what you're talking about. Haven't been reading.
12:32:47 <sorear> @where catch
12:32:47 <tibbe> ndm, how does it block spam? didn't see any login button when submitting, captcha?
12:32:47 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
12:32:54 <dylan> hey-ho, another florida person.
12:33:16 <pejo> defcon8, user interface. People want it, really.
12:33:59 <ndm> tibbe: only gmail users may submit bugs, which i guess stops the spam issue
12:34:14 <pejo> ndm, doesn't that sort of stop bug reports as well?
12:34:24 <sorear> everyone uses gmail
12:34:26 <sorear> except me
12:34:38 <ndm> pejo: we're happy for users to email us bug reports, which is probably easier than filing bugs
12:34:49 <ndm> we tend to use the bug tracker for communicating with each other more than anything else
12:35:06 <ndm> i submit feature requests to our build team by opening a bug and assiging it at them
12:35:25 <pejo> ndm, ah. That way bugs wont' be silently dropped.
12:35:56 <ndm> pejo: we get full emails of all bugtracker changes on a separate list, which most of the developers are subscribed to
12:36:25 <tibbe> ndm, oh, I was logged in on my account I guess
12:36:34 <tibbe> ndm, how does it integrate with gmail?
12:36:38 <tibbe> or does it?
12:36:49 <ndm> tibbe: logged in with gmail == logged in to bug tracker, no more than that
12:36:55 <tibbe> ok
12:37:06 <ndm> you can set up an email to be emailed on after changes, but that doesn't have to be gmail
12:37:17 <ndm> although we have a google groups account for that purpose
12:38:11 <tibbe> would an RSS feed be useful?
12:38:18 <ndm> why not
12:38:38 <ndm> i'm surprised google code doesn't have one actually
12:38:43 <ndm> give it a few weeks :)
12:41:04 <tibbe> :)
12:41:41 <tibbe> hmm, I think Amazon has some free storage service nowadays, I wonder if one could use that to store the repos
12:42:03 <ndm> it would be nice if google allowed darcs hosting...
12:42:09 <ndm> but alas its svn only for now
12:42:15 <tibbe> yeah
12:42:29 <ndm> there was talk of a machine for community darcs projects being set up
12:42:33 <tibbe> I could make it my 20% project ;)
12:42:46 <ndm> are you a googler?
12:42:49 <tibbe> yes
12:42:59 <ndm> that would be very handy
12:43:11 <ndm> and why do you want to clone google code, if you already work for google?
12:43:15 <tibbe> but I won't have time the net 3 months at least
12:44:43 <tibbe> hmm, the Amazone S3 wasn't exactly free
12:45:01 <tibbe> ndm, I really don't want to do that, I want an integrated haskell experience for me
12:45:40 <tibbe> to be honest I'm just looking for a pet project
12:45:50 <tibbe> it's the least boring I could come up with right now
12:46:29 <ndm> darcs hosting on google code would give a very integrated experience
12:46:42 <ndm> esp if you could link commits to bug reports
12:47:11 <tibbe> yes
12:47:16 <ndm> although perhaps some buildbot service for all would be handy, or something to do with hackage as the portal for the haskell world
12:47:22 <tibbe> now, I have to come up with some other spare time project though
12:47:31 <tibbe> a HaskellForge
12:48:50 <ndm> fixing Cabal would be a nice spare project
12:48:55 <ndm> if it doesn't make you kill yourself
12:50:14 <tibbe> I must admit that all my excitement centra in my brain don't fire at once at the idea
12:51:15 <SamB> ndm: "spare projects" are not in much demand, I think
12:51:25 <SamB> most of us have more than we can remember
12:51:43 <ndm> SamB: i have a list stapled to my office wall, otherwise i'd never remember them!
12:52:18 <SamB> ndm: I'm not sure if it would be good for me to remember all of mine
12:52:18 <pitecus> how do i get a list of random numbers? I can never rember how its supposed to work...
12:52:35 <glguy> > randoms (mkStdGen 42)
12:52:35 <lambdabot>  Add a type signature
12:52:40 <glguy> > randoms (mkStdGen 42) :: [Int]
12:52:41 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
12:52:55 <pitecus> what is 42 for?
12:53:00 <NichardRixon> Initial seed
12:53:11 <pitecus> does it matter what it is?
12:53:21 <glguy> lambdabot doesn't support IO, which is where you normally get your StdGen
12:53:21 <bd_> pitecus: You'll get the same results if you use the same seed
12:53:24 <SamB> 42 is the answer
12:53:28 <bd_> > randoms (mkStdGen 24) :: [Int]
12:53:29 <lambdabot>  [-366020861,-377602204,-520035400,-296722707,-179042358,-736242970,165988357...
12:53:30 <mbishop> > randoms (mkStdGen 42) :: [Int]
12:53:32 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
12:53:32 <bd_> > randoms (mkStdGen 24) :: [Int]
12:53:33 <lambdabot>  [-366020861,-377602204,-520035400,-296722707,-179042358,-736242970,165988357...
12:53:54 <glguy> anyone remember what the default --prefix for ghc is?
12:53:59 <xerox> @check \n m l -> take l (randoms (mkStdGen n)) :: [Int] == take l (randoms (mkStdGen m) :: [Int]
12:53:59 <glguy> (when installing it from source)
12:53:59 <lambdabot>  Parse error
12:54:02 <xerox> pft.
12:54:04 <tibbe> ndm, I forgot my idea notebook back in sweden
12:54:14 <pitecus> isnt there something with a different seed on each invocation?
12:54:28 <bd_> pitecus: yes but it needs IO
12:54:33 <pitecus> its OK
12:54:34 <ndm> tibbe: :( - i have about 10 of them
12:54:35 <bd_> which lambdabot doesn't allow for obvious security reasons
12:55:06 <SamB> also it only works if your computer has a clock
12:55:09 <SamB> or something
12:55:37 <pitecus> it probably does have a clock
12:55:50 <pitecus> so which function is it?
12:56:20 <glguy> ?docs System.Random
12:56:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
12:56:24 <glguy> ^^^
12:56:58 <glguy> fmap randoms newStdGen
12:57:32 <pitecus> thanks glguy
12:59:16 <mbishop> Haskell needs better time functions
12:59:48 <roconnor> @check \n m l -> take l (randoms (mkStdGen n)) :: [Int] == take l (randoms (mkStdGen m))
12:59:48 <lambdabot>  Parse error
13:00:08 <roconnor> @check \n m l -> take l ((randoms (mkStdGen n)) :: [Int]) == take l (randoms (mkStdGen m))
13:00:09 <lambdabot>  Falsifiable, after 9 tests: 1, 0, 1
13:00:43 <roconnor> @check \n m l -> (take l ((randoms (mkStdGen n)) :: [Int]) == take l (randoms (mkStdGen m))) (<= n==m)
13:00:44 <lambdabot>      The operator `<=' [infix 4] of a section         must have lower precede...
13:00:52 <roconnor> @check \n m l -> (take l ((randoms (mkStdGen n)) :: [Int]) == take l (randoms (mkStdGen m))) <= (n==m)
13:00:53 <lambdabot>  Falsifiable, after 0 tests: -1, 2, -2
13:01:54 <roconnor> @check \n m l -> 0<l ==> (take l ((randoms (mkStdGen n)) :: [Int]) == take l (randoms (mkStdGen m))) <= (n==m)
13:01:55 <lambdabot>  Falsifiable, after 0 tests: 3, -3, 1
13:02:18 <roconnor> (randoms (mkStdGen 3))
13:02:22 <roconnor> > (randoms (mkStdGen 3))
13:02:23 <lambdabot>  Add a type signature
13:02:29 <roconnor> > (randoms (mkStdGen 3))::[Int]
13:02:30 <lambdabot>  [-1704185953,2104023132,-163578927,1526256091,1280102991,-620124265,-9891238...
13:02:35 <roconnor> > (randoms (mkStdGen (-3)))::[Int]
13:02:36 <lambdabot>  [-1704185953,2104023132,-163578927,1526256091,1280102991,-620124265,-9891238...
13:02:44 <roconnor> :(
13:04:01 <fasta> What happens when Control.Monad.State.fail is called?
13:04:35 <fasta> And the same question for Control.Monad.Cont.fail
13:04:38 <ndm> fasta: i would guess its not defined, and so defaults to error
13:04:48 <roconnor> > runState (fail "What happens when Control.Monad.State.fail is called?") ()
13:04:49 <lambdabot>  Add a type signature
13:04:58 <roconnor> @type runState
13:05:00 <lambdabot> forall s a. State s a -> s -> (a, s)
13:05:10 <glguy> > runState (fail "who knows") () :: (Int,())
13:05:11 <lambdabot>  Exception: who knows
13:05:32 <fasta> Can I redefine fail for an newtype derived monad?
13:05:37 <glguy> > runState (fail "who knows") () :: ([Int],())
13:05:38 <lambdabot>  Exception: who knows
13:05:42 <fasta> er a
13:05:52 <roconnor> fasta: you can certainly reimplement the monad class for a new type
13:05:57 <glguy> fasta: if you don't use newtype deriving you could
13:06:07 <fasta> roconnor: Yes, I know that.
13:06:12 <fasta> glguy: I expected so.
13:06:17 <sorear> gak, they weren't kidding when they said retainer profiling was slow.
13:06:18 <fasta> Thanks
13:06:34 <roconnor> fasta: Oh good.  I figured you should have known that
13:06:42 <sorear> jhc has been going 20x slower .. at least
13:07:45 <pbx> Is there a list of freely-available Haskell-related audio (podcasts) anywhere? E.g. I'd love to hear audio of this course -- http://www.cs.washington.edu/education/courses/cse506/CurrentQtr/ -- I found MP3 files from the previous course in that sequence but the site is a maze of twisty little passages, all alike...
13:07:46 <lambdabot> Title: CSE506, Winter 2007
13:07:54 <pbx> Thanks lammy
13:08:54 <mbishop> pbx: It's pitch black.  You are likely to be eaten by a Grue
13:09:18 <sorear> ndm: I just read the "Catch, Lazy Termination" slides, and it seems to say last x has WHNF only if x has WHNF ... which is wrong, consider last [undefined, 1] ... but I'm not sure I understand the notations
13:09:40 <pbx> mbishop: My epitaph!
13:09:53 <sorear> ndm: s/WHNF/NF/, that was a typo not a reado
13:10:02 <sorear> ndm: s/WHNF/NF/g
13:10:11 <ndm> sorear: i think its saying that would be a conservative approximation - i'm no longer using the Catch framework for termination stuff
13:10:14 * glguy was about to disagree
13:12:05 <pbx> (FWIW I see that the T/A for that course studied with Hudak as an undergrad)
13:13:37 <ndm> ooh, that course looks fun!
13:15:00 <pbx> ndm: Yeah!  I actually learned a lot from listening to several hours of the preceding one. The lectures involving OCaml helped certain concepts (e.g. currying) to gel for me.
13:15:33 <ndm> i've done a basic FP course before, but never an advanced one
13:20:56 <resiak> @pl \x -> (x, f x)
13:20:57 <lambdabot> ap (,) f
13:21:03 <resiak> :t ap
13:21:04 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
13:21:18 <Syzygy-> :t ap (,)
13:21:19 <lambdabot> forall a a1. (a1 -> a) -> a1 -> (a1, a)
13:21:28 <resiak> what monad is (,) in?
13:21:52 <ihope> Reader.
13:21:53 <augustss> e->
13:21:58 <ihope> That.
13:22:12 <resiak> heh, I should really get to grips with that
13:22:16 <dons> ?users
13:22:17 <lambdabot> Maximum users seen in #haskell: 322, currently: 310 (96.3%), active: 52 (16.8%)
13:22:49 <augustss> seems the user numbers keep climbing :)
13:23:15 <sorear> @uptime
13:23:15 <lambdabot> uptime: 1d 1h 22m 40s, longest uptime: 2d 17h 27m 21s
13:23:18 <sorear> @version
13:23:18 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
13:23:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:24:23 <shapr> @yow
13:24:23 <lambdabot> over in west Philadelphia a puppy is vomiting ...
13:24:26 <shapr> eww
13:24:38 <resiak> What's the combinator for applying a function to sort on?
13:24:42 <nmessenger> shapr: SHAZAM!!
13:24:54 <bd_> resiak: sortBy (comparing someComparisonFunction) ?
13:24:59 <bd_> needs 6.6 and Data.Ord
13:25:01 <resiak> that's the badger
13:25:02 <bd_> and Data.List
13:25:33 <resiak> Hrm.  I thought I had 6.6 here :(
13:26:04 <resiak> @src comparing
13:26:04 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:26:11 <resiak> sorry, I'll move over to /msg
13:26:23 <glguy> damn, I started ./configure over 30 minutes ago for GHC
13:26:26 <sorear> resiak: you probably need 6.7
13:26:30 <nmessenger> comparing f x y = compare (f x) (f y)
13:26:35 <sorear> resiak: also, you are well under the limit
13:26:39 <sorear> resiak: come back!
13:26:43 <pejo> Suppose I'm in a monad, let's call it M. There I do name <- newName "h"; res <- runStateT (runReaderT (func exp) ..) (..), and inside func I can't get a hold of newName again. How should I do this?
13:26:59 <sorear> resiak: don't take the bot's insults as a request to leave
13:27:24 <shapr> nmessenger: CAPTAIN LAMBDA!
13:27:25 <sorear> pejo: lift (lift (newName "h"))
13:27:32 <dylan> the insults are really annoying
13:27:44 <sorear> dylan: tell dons next time
13:27:46 <resiak> sorear: Oh, I'm not taking the bot's insults thusly, I'm remembering how annoying I find people making the channel scroll while they play with the bot
13:27:50 <shapr> dylan: Patch it!
13:27:52 <dylan> especially since I can't find a heurestic to filter them out.
13:28:37 <pejo> sorear, doh. Thank you.
13:28:46 <sorear> dylan: the code you want to reverse engineer / delete is at line 489 of Lib/Util.hs
13:28:51 <glguy> it's just a computer bot quoting the sudo error message file... nothing to take offense that :-p
13:29:02 <glguy> the bot doesn't *actually think* you are dumb ;)
13:29:14 <shapr> Ok, I like wmii-3.5 so far.
13:29:14 <bd_> It's from sudo? oO
13:29:38 <glguy> bd_: pretty sure...
13:29:44 <dylan> shapr: it's nice but slow.
13:29:46 <resiak> nmessenger: thanks :)
13:29:49 <sorear> bd_: it even says so in the code
13:29:53 <glguy> bd_: the insult messages sudo uses when you enter a bad password
13:29:54 <sorear> -- Amusing insults from OpenBSD sudo
13:30:17 <bd_> oh, openbsd sudo, not whatever-debian-uses sudo
13:30:17 <glguy> is there a sudo not made by OpenBSD?
13:30:29 <bd_> at least mine only says 'Sorry, try again.'
13:30:39 <glguy> bd_: there is a flag for turning them on
13:30:50 <glguy> bd_: if your sudo version has a p in it, it's probably OpenBSD
13:31:02 <shapr> dylan: Since it uses 9P, the slow shell scripts could be replaced with speedier Haskell programs, yeah?
13:31:04 <bd_> ...ah
13:31:28 <glguy> or that same version at least
13:31:31 <dylan> shapr: sure, but it's a lot of work.
13:32:03 <sorear>  5617 stefan    25   0 99.0m  92m  17m R 98.5 24.5  82:14.35 jhcp  -- they weren't kidding about retainer profiling being slow
13:32:23 <pejo> glguy, um, isn't the p for either portable or patch-level?
13:32:47 <glguy> pejo: OpenBSD stuff uses p for portable
13:33:08 <glguy> http://sudo.ws/sudo/man/sudoers.html -- search for "insults"
13:33:09 <lambdabot> Title: Sudoers Manual
13:33:24 <pejo> glguy, yeah, but I have 1.6.5p2 installed on this machine, among others, and this is not obsd.
13:33:41 <glguy> pejo: right, but your OpenSSH is
13:34:00 <glguy> pejo: unless you use a different one
13:35:29 <glguy> pejo: I just made a mistake about sudo
13:37:10 <realspace> Hello all. I would like to do something like this:  data Object = Point Int Int | Line Point Point
13:37:18 <realspace> But this doesn't work...
13:37:42 <Botje> are Point and Line declared elsewhere?
13:37:48 <bd_> realspace: Point is constructor in your example, not a type :)
13:37:53 <bd_> data Point = Point Int Int
13:37:57 <bd_> data Line = Line Point Point
13:37:58 <realspace> Botje: no
13:38:11 <Botje> well, go with bd_'s suggestion then
13:38:12 <mauke> type Object = Either Point Line
13:38:32 <realspace> ok, but i would like to have a general function with like:  "foobar :: Ref -> Object"
13:39:01 <mauke> ok, do it
13:39:07 <bd_> realspace: What's Ref?
13:39:12 <bd_> And why do you want to do this?
13:39:57 <realspace> bd_: type Ref = Int (long description follows:)
13:40:17 <Botje> realspace: if it's long, you might want to put it on a pastebot
13:40:19 <Botje> (hpaste.org)
13:40:23 <bd_> realspace: If you cast it to an int, how can the garbage collector determine whether the object is still alive?
13:40:28 <bd_> :)
13:40:30 <glguy> !paste
13:40:30 <hpaste> Haskell paste bin: http://hpaste.org/
13:40:35 <bd_> You /can/ manually manage these things
13:40:37 <bd_> but... it's a pain
13:41:00 <bd_> Look into Data.Typeable, Data.Dynamic, Foreign.StablePtr - but you /really/ don't want to do this unless you absolutely have to
13:41:25 <realspace> i would like to build some "object store" where i assign references with data. then i would like to use a function like "lookup :: Ref -> Storage -> Object"
13:41:43 <bd_> realspace: Data.Map?
13:41:54 <nmessenger> Storage = Map Ref Object
13:42:25 <pejo> :t lookup
13:42:27 <mauke> Storage = Ref -> Object
13:42:27 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
13:42:30 <mauke> lookup = flip id
13:42:31 <nmessenger> @type Data.Map.lookup
13:42:32 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
13:42:43 <bd_> > let storageThingy = M.fromList [(1, "foo"), (2, "bar"), (3, "quux")] in M.lookup  2 storageThingy :: Maybe String
13:42:44 <lambdabot>  Just "bar"
13:43:17 <realspace> hmm... maybe I'm thinking in the wrong direction...
13:44:25 <bd_> realspace: could be :) Types are your friend, if you try to subvert them it'll usually just make more work for you as you replicate all that stuff you just subverted
13:46:21 <realspace> ok, imagine: you have a "world". in this world you create two points at some position. the points having the reference '1' and '2'. now you create a line from point '1' to '2'. ok, now the funny thing: some time later, i would like to move point '1' and the line should be "recalculated" . the world should have a State. I'm thinking about using Control.Monad.State
13:47:02 <realspace> the line should be stored as a function wich reuses the modified point in the world
13:47:40 <bd_> hmm
13:47:45 <bd_> In what way should the line be recalculated?
13:48:07 <realspace> it's like an auto-update for other objects in the world. like lines, other points, circles and so on.
13:48:26 <bd_> Perhaps your query function should take a world? getPoint :: Point -> World -> (Int, Int)
13:48:36 <bd_> and eg, lineLength :: Line -> World -> Int
13:48:39 <bd_> or Double or whatever
13:48:54 <realspace> hmm.
13:48:56 <bd_> hm, but there's no guarentee the points will be found in the world
13:49:02 <bd_> which is the kind of annoying part
13:49:26 <bd_> You'll need to decide what to do if the line refers to point A but there is no point A
13:49:33 * cjeris still wants print-syntax extensions to apply ANSI colors to monad operators to indicate the monad they come from :)
13:49:37 <bd_> if you want to make that strictly impossible, you can work in the ST monad
13:49:39 <bd_> but that's ugly
13:49:39 * cjeris still wants print-syntax extensions to apply ANSI colors to monad operators to indicate the monad they come from :)
13:49:50 <augustss> A line doesn't have a length
13:49:54 <bd_> it would prevent you from creating a Point which doesn't exist though
13:50:35 <realspace> yes. i', playing with a concept of data represantaion for a CAD-system. you create points and lines that depend on the points. later you move points an the lines should move to. more complicated action like cross-points can move to etc.
13:50:53 <bd_> hm, ST monad not appropriate in that case
13:51:06 <augustss> realspace: what operations do you expect to do on lines?
13:51:30 <realspace> i thought about storing monad action in the state moand which refernce to each other via the Ref-types.
13:51:45 <SamB> ?
13:51:48 <realspace> augustss: at least, showing on the screen
13:52:25 <bd_> realspace: While using a State monad can be convenient, keep in mind that it's possible to escape it. For example, say you have a runWorld which sets up an empty world to work in:
13:52:26 <dr_strangelove> are there bindings for imagemagick?
13:52:46 <dr_strangelove> or something similar?
13:52:46 <bd_> let point = runWorld (newPoint 0 0) in runWorld (lineLength (Line point point)) <-- oops
13:52:58 <bd_> because they're different worlds, and the point isn't registered
13:53:03 <emu> Cale: how's VB working out?
13:53:06 <bd_> so there needs to be some kind of behavior in that case
13:53:20 <bd_> if you're working on a CAD sort of thing, using IORefs may be a good solution
13:53:22 <bd_> [or TVars etc]
13:53:24 <augustss> Being pedantic, I once again point out that a line doesn't have a length.  It's infinite :)
13:53:31 <Cale> emu: The video seems to have downloaded.
13:53:40 <Cale> If that's what you're referring to.
13:54:17 <realspace> yes. i thought about. i reality, the monad action should result in an "Maybe Object" for example, if a point is moved somewhere that a depending object could not be "recalculated"
13:54:38 <bd_> realspace: How will this appear in the operations you'll be doing to query these?
13:54:56 <realspace> augustss: yes i know. but i doesn't know the english word for a line wich have an length.. in german it is called a "Strecke"
13:55:11 <glguy> segment
13:55:12 <bd_> line segment
13:55:13 <Saizan> Segment?
13:55:24 <realspace> thank you all. :-)
13:55:28 <augustss> sträcka in swedish :)
13:55:31 <nmessenger> segment possibly? :P
13:55:41 <bd_> @quote stereo
13:55:41 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:55:49 <Syzygy-> Strecke == segment
13:55:51 <bd_> Apparently we've upgraded to 5.1 :)
13:55:53 <nmessenger> heh
13:55:57 <augustss> quadrophony!
13:56:03 <Syzygy-> This is bloody THX. :)
13:56:11 <augustss> with echo
13:56:40 <nmessenger> that should get @topic-cons'ed
13:56:48 <realspace> this cad thing is just a experiment while i'm learning haskell. i thought, hey, in haskell i can store functions an monadic actions in states and so on...
13:57:39 <bd_> realspace: one possibility is to have the world be of type (Point -> (Int, Int)) - that is, your world is just a query function to return the coordinates of points
13:57:41 <augustss> realspace: the caching aspect could be tricky
13:59:05 <augustss> realspace: but doable, of course :)
14:00:16 <realspace> augustss: yes. complicated problems are a sort of fun and enjoy, at least to me... ;-)
14:00:39 <pejo> I always find it scary when people in here say something is doable. It doesn't give me any sense of how hard it might be.
14:00:42 <augustss> realspace: I'd start without caching.  Design a World type that has the operations you want
14:00:51 <mauke> <PoppaVic> anyone ever notice that life is not fully EVENT-DRIVEN?
14:01:11 <augustss> pejo: heh!
14:01:13 <sjanssen> @yow
14:01:14 <lambdabot> America!!  I saw it all!!  Vomiting!  Waving!  JERRY FALWELLING into
14:01:14 <lambdabot> your void tube of UHF oblivion!!  SAFEWAY of the mind ...
14:01:44 <pejo> augustss, a valid concern though, for those of us who don't write compilers for a living!
14:02:08 <augustss> pejo: So I have an idea how I would do it.  It's not that hard, but there might be better ways than mine.
14:02:55 <augustss> pejo: To get caching to work I'd timestamp the point so you can detect if a point has moved since it was involved in a computation last.
14:03:17 <realspace> my inital plan was, to store a objects in the world as function of type "World -> Object". so a point which was created by the user on a position would be a "const Point x y" function. a objects which must be calculated on other objects in the world are functions which hold some reference to the other objects in the world.
14:03:20 <augustss> It's just a matter of having an abstract World type that hides these things.
14:03:35 <bd_> augustss: I wonder if Arrows could help here. Somehow. >.>
14:04:06 <bd_> To pass back the list of which points the computation depends on, that is
14:04:24 <bd_> if you reverse the mapping, you could build a list, for each point, of what objects need updating
14:04:50 <bd_> I'm not sure how a pure timestamp would help though - by the time you're computing that you've already committed far too much work to the problem
14:06:15 <augustss> bd_: depends on what you are computing.  some things are faster to recompute than cache, that's true
14:06:47 <realspace> the funny thing is somehow, that in haskell there isn't a sort of "identity". in haskell ist only data without identity.
14:07:06 <bd_> I'm just not sure what the point of having only a timestamp would be - you still need to know what points the thing uses, otherwise you'll not know until it examines all the points it's looking at, at which point all that's left is some simple computation.
14:08:12 <TuringTest> Hmm....  Is there a space efficient mutable bit array hidden anywhere in the GHC 6.6 libs?
14:08:31 <bd_> TuringTest: STUArray s ix Bool, or IOArray ix Bool :)
14:08:36 <bd_> er
14:08:38 <bd_> IOUArray
14:09:08 <cjeris> IOUArray :: forall agency. (IRS agency) => agency
14:09:10 <bd_> DiffUArray too but that'll be somewhat slower due to the maintenance of older copies
14:09:11 <TuringTest> And how bits/bytes  per Bool?
14:09:24 <TuringTest> bd_ There is no DiffUArray for Bool data
14:09:27 <bd_> TuringTest: In an unboxed array, 1.
14:09:44 <bd_> type DiffUArray = IOToDiffArray IOUArray
14:09:50 <bd_> MArray IOUArray Bool IO
14:10:53 <TuringTest> bd_: 1 bit per Bool .... would that also work with STUArray? Hmm....
14:11:42 <bd_> hm wait
14:11:49 <bd_> I guess there isn't a bool instance for DiffUArray
14:12:03 <bd_> I believe it works for STUArray thouhg
14:12:07 <bd_> MArray (STUArray s) Bool (ST s)
14:12:19 <Saizan> yeah, i've had to edit Data.Array.Diff to have a Bool instance..
14:14:23 <hyrax42> is it really 1 bit per bool?
14:14:43 <hyrax42> I don't think bool arrays are 1 bit per bool even in Java
14:15:12 <bd_> well, there'll be header stuff of course
14:15:18 <hyrax42> ?docs Data.Array.Unboxed
14:15:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Unboxed.html
14:15:23 <Saizan> mmh, reading them would be quite an alignment mess
14:15:34 <hyrax42> yeah
14:15:41 <dons> TuringTest: IOUArray Int Bool is bit packed, TuringTest
14:15:42 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
14:15:48 <hyrax42> I think you just leave them as 0 :: Word8 and 1 :: Word8
14:15:59 <dons> TuringTest: see the nsieve-bits benchmark
14:16:07 <hyrax42> oh it is
14:16:09 <hyrax42> hmm
14:16:45 <dons> unboxed bool arrays are indeed 1 bit per Bool
14:16:56 <realspace> ok, so far thank you all for your ideas. i will rethink my cad-problem.
14:17:21 <realspace> maybe i will use caching and a different approach to the whole thing
14:17:30 <Saizan> are IO/STUArray much faster than DiffUArrays?
14:17:55 <hyrax42> Saizan: it shouldn't be a huge difference
14:18:20 <hyrax42> there's a bit of reading/writing mvar in there iirc
14:22:29 <TuringTest> I have always found DiffArrays are big performance hits in my code.
14:22:46 <hyrax42> even if you never access an old version?
14:24:30 <TuringTest> dons: I see, thanks.  STUArray Int Bool has 2 ints for the bounds, and an Word32 for the allocation size, and then 1 bit per element.
14:25:28 <TuringTest> dons: My imperative ST form of the regex-tdfa code is finally running slightly faster/much smaller memory than the UArray version.
14:25:40 <TuringTest> I had forgotten how annoying manual memory management was.
14:28:22 <dons> ok.
14:41:07 <sorear> ... done readign the Catch papers
14:50:15 <huschi> bringert: are you here?
14:50:21 <bringert> huschi: yeah
14:50:43 <huschi> bringert: i've got another patch for haskelldb.
14:51:06 <bringert> huschi: ok, wanna send it?
14:51:43 <huschi> yes. i'm trying to remember the necessary steps
14:52:50 <bringert> huschi: darcs send -o file
14:53:04 <bringert> huschi: if you don't have sendmail / postfix / ...
14:53:10 <huschi> bringert: thx. i've just remembered.
14:55:41 <huschi> bringert: and i've got a suggestion for haskelldb.
14:55:56 <bringert> huschi: yeah?
14:56:01 <huschi> but i'm not sure if it is possible to implement my suggestions.
14:56:20 <huschi> there is an combinator called _in.
14:56:49 <huschi> but it accepts only a set as right hand argument and no subqueries.
14:57:18 <dons> http://programming.reddit.com/info/147wi/comments
14:57:20 <lambdabot> Title: Generalised algebraic data types: dependent types for the masses (reddit.com)
14:57:51 <huschi> is it possible to have an operator that allows queries like 'SELECT a FROM t1 WHERE b IN (SELECT c FROM t2);'?
15:01:30 <EvilTerran> you could do the same thing with a JOIN...
15:02:23 <huschi> EvilTerran: i did it this way for now. but with an IN (SELECT ...) it becomes shorter.
15:02:30 <EvilTerran> true
15:02:41 <huschi> and there is another important fact.
15:04:55 <huschi> if you allow 'IN (SELECT ...)' queries it becomes possible to define a datatype for filters and each filter can be converted to an 'Expr Bool'.
15:05:43 <huschi> e.g. if you want to get all cities that are in a given country you can't render this filter to an 'Expr Bool' for now.
15:06:11 <bringert> huschi: yeah that would be nice. see http://sourceforge.net/tracker/index.php?func=detail&aid=961869&group_id=101095&atid=629043
15:06:13 <lambdabot> Title: SourceForge.net: Detail: 961869 - Allow queries in expressions, http://tinyurl.com/2jusyo
15:07:41 <sjanssen> @hoogle (Storable b) => (Ptr b -> IO a) -> b -> IO a
15:07:42 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
15:07:42 <lambdabot> Foreign.Marshal.Utils.withObject :: Storable a => a -> (Ptr a -> IO b) -> IO b
15:09:27 <huschi> bringert: there isn't any content yet. am i right?
15:10:13 <bringert> huschi: in the RFE? yeah, noone has gotten around to figuring out how ro implement it
15:11:24 <shapr> @yow !
15:11:24 <lambdabot> It don't mean a THING if you ain't got that SWING!!
15:15:02 <sorear> @users
15:15:03 <lambdabot> Maximum users seen in #haskell: 322, currently: 290 (90.1%), active: 49 (16.9%)
15:18:57 <sm> good afternoon all.. I'm trying to make a bidirectional "pointer" between parent and child types
15:19:07 <shapr> sm: Tie the knot?
15:19:15 <shapr> Oh wait, between *types* ?
15:19:39 <sm> an entry contains transactions, but this isn't going to work is it: let entry = Entry date status code description (map (\t -> t{tentry=entry}) transactions)
15:19:59 <kpreid> sm: why wouldn't that work?
15:20:04 <sorear> why won't it work?
15:20:14 <sm> I shall find out :)
15:20:22 <kpreid> sm: it might not be as useful as you hope, though
15:22:01 <sorear> sm: anytime you think you need "object identity", what's actually happening is you're trying to write a graph algorith ; haskell has proper graph datatypes instead of supporting the (ab)use of address equality.
15:22:17 <sm> hmm
15:22:21 <sm> ok
15:23:29 <sm> my first data model was Entry containing [Transaction].. however I'd like to deal most of the time with just a list of all the Transactions from all Entries
15:23:48 <sm> but still be able to reliably group them by their parent Entry again
15:25:27 <sm> in OO, I would say an entry knows it's transactions, and a transaction knows it's entry. what's the graph datatype way of expressing this bidirectional link ?
15:26:42 <Cale> hmm
15:26:59 <xic> yeah
15:27:19 <Cale> sm: What are you trying to compute?
15:28:27 <sm> right now, I want to filter transactions (across all entries)
15:28:27 <Cale> The hierarchical libraries need a proper implementation of relations.
15:28:36 * sm is porting http://newartisans.com/ledger.html
15:28:38 <lambdabot> Title: New Artisans LLC
15:28:45 <ddarius> sorear: Proper graph algorithms that abuse address equality for you if they want to be fast.
15:29:35 <shapr> hiya ddarius
15:29:46 <Cale> We have Data.Map which is an excellent finite map implementation, but nothing for general relations. There's various graph libraries, but the way of thinking about graphs is different enough from thinking about relations that it would be worthwhile to have another library.
15:29:47 <ddarius> heya shapr
15:29:53 <Cale> I think that Dr. Kahl has something.
15:30:23 <astrolabe> sm: I think maybe the code you have above will work
15:31:19 <astrolabe> as long as you don't want to test whether two transactions come from the same entry
15:31:40 <sm> astrolabe: that's exactly what I want to do..
15:32:00 <sm> to give more gory details, I can filter transactions fine but now I want to show the entry details only for the first txn of that entry..
15:32:05 <hpaste>  sm pasted "example" at http://hpaste.org/470
15:32:56 <Cale> So you have an Entry with many Transactions in it. Why is it that transactions need to know which entry they belong to?
15:33:25 <Cale> If you have both the entry that the transaction came from, and the entry itself, then you have everything.
15:33:54 <Cale> So you could perhaps pass around entry/transaction pairs when you need that.
15:34:28 <ddarius> "Problems with Existing Logics: ... Constructive type theory is, well, constructive and hence not classical."
15:34:37 <sm> hmm.. that was my previous implementation.. I was hoping to make something simpler
15:34:37 <Cale> It seems from your paste that you really want to print entries, and not transactions.
15:35:01 <sm> Cale: not really
15:35:09 <Cale> hmm
15:35:11 <Cale> why not?
15:36:09 <ddarius> wtf?
15:36:34 <sm> eg I filter on "vacation", I want to show only the expenses:vacation transactions, to see the cumulative balance - not the complete entries, which always balance out to 0
15:37:01 <ddarius> shapr: How goes it?
15:37:05 <Cale> Well, you'd be filtering inside each of the entries then right?
15:37:29 <shapr> ddarius: It's okay, how goes it with you?
15:37:35 <chessguy> 'evening haskellers
15:37:39 <chessguy> @shapr
15:37:40 * lambdabot smacks  about with a large trout
15:37:50 <sm> yes, I can do that.. it just seemed over complicated, I thought maybe I could slice and dice the transactions en masse
15:37:51 <chessguy> @get-shapr
15:37:52 <lambdabot> shapr!!
15:38:18 <ddarius> shapr: Today has been excellent.  I don't understand all of why.
15:38:20 <shapr> chessguy: You screamt?
15:38:27 <shapr> ddarius: Hey, excellent is good enough by itself.
15:38:28 <chessguy> no, lb did :)
15:38:31 <xic> Cale: do you remember that dinosaur comics issue that you liked?
15:38:42 * shapr throws a lambda at chessguy 
15:39:02 * chessguy giggles
15:43:20 <chessguy> @quote lambda
15:43:20 <lambdabot> dons says: [lambdabot]  Source not found. Your mind just hasn't been the same since the electro-shock, has it? [dons] not yet
15:44:09 <george--> > 10^(-15)
15:44:10 <lambdabot>  Exception: Prelude.^: negative exponent
15:44:18 <george--> anyone tell me how to evaluate this?
15:44:56 <chessguy> @type (^)
15:44:57 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:45:45 <chessguy> @type (**)
15:45:47 <lambdabot> forall a. (Floating a) => a -> a -> a
15:46:00 <chessguy> > 10 ** (-15)
15:46:01 <lambdabot>  1.0e-15
15:46:12 <george--> arg. horrid notation
15:46:16 <george--> i think this is what fortran uses?
15:46:22 <Saizan> @type (^^)
15:46:24 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
15:46:43 <Saizan> > 10^^(-15)
15:46:44 <lambdabot>  1.0e-15
15:46:50 <chessguy> oh, much better
15:47:23 <chessguy> > 1.0e-15 :: Double
15:47:24 <lambdabot>  1.0e-15
15:47:30 <chessguy> > 1.0e-15 :: Float
15:47:31 <lambdabot>  1.0e-15
15:47:36 * chessguy shrugs
15:48:16 <chessguy> what do you want, .000000000000001 ?
15:48:25 <chessguy> > .000000000000001
15:48:25 <lambdabot>  Parse error
15:48:33 <chessguy> > 0.000000000000001
15:48:34 <lambdabot>  1.0e-15
15:50:51 <george--> heh. the ** works thanks =)
15:52:46 <Cale> xic: I like most of them
15:53:12 <xic> Cale: yeah, but one of them was really good
15:54:20 <george--> how do i cast an int to a double?
15:54:28 <Cale> george--: fromIntegral
15:54:34 <chessguy> @type fromIntegral
15:54:36 <lambdabot> forall b a. (Num b, Integral a) => a -> b
15:55:43 <chessguy> hmm, can i have a tree of nodes where each node is a function from its children to some other datatype?
15:56:08 <Cale> chessguy: like an expression?
15:56:20 <chessguy> mm, i guess
15:56:44 <Cale> You could work out something with GADTs
15:56:52 <chessguy> what i want is like Tree ([a] -> b)
15:57:01 <chessguy> where i can specify the b
15:57:18 <augustss> chessguy: that looks like a fine type
15:57:22 <chessguy> err
15:57:28 <chessguy> that's not it
15:57:55 <chessguy> Tree ([Tree _] -> Foo
15:57:57 <chessguy> )
15:58:06 <chessguy> but i don't know what to put for the _
15:59:35 <augustss> you need to name [Tree xxx] -> Foo with a newtype, and use some mutual recursion
16:00:03 <chessguy> huh?
16:00:32 <augustss> Do you have the type Tree already?
16:01:01 <chessguy> i want to be able to do something like eval :: Tree xxx -> Foo ; Eval t = (rootLabel t) (subForest t)
16:01:06 <chessguy> i was going to use Data.Tree
16:02:34 <chessguy> but i don't know what to put for the xxx
16:03:34 <augustss> newtype T = T ([Tree T] -> Foo)
16:04:11 <chessguy> and then make a Tree of T's
16:04:12 <chessguy> ?
16:04:19 <augustss> Yeah
16:05:54 <chessguy> that sounds like fun
16:06:55 <ddarius> http://www.mangust.dk/skalberg/mt.php Map Theory makes me retch.
16:07:09 <lambdabot> Title: Map Theory
16:08:33 <LoganCapaldo> How much therory can be invovled with (a -> b) -> [a] -> [b] ? :-p
16:08:59 <george--> ?paste
16:09:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:09:24 <bd_> @free (a -> b) -> [a] -> [b]
16:09:24 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
16:09:28 <bd_> @free f :: (a -> b) -> [a] -> [b]
16:09:29 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
16:09:34 <bd_> ^^^ quite a lot of theory
16:09:56 <LoganCapaldo> Is @free djinn + pl?
16:09:58 <bd_> What's $map anyway? fmap?
16:09:59 <hpaste>  george-- pasted "numerical method for a problem" at http://hpaste.org/471
16:10:01 <bd_> no :)
16:10:07 <LoganCapaldo> @help free
16:10:07 <lambdabot> free <ident>. Generate theorems for free
16:10:14 <george--> anyone could look at that please?
16:10:19 <bd_>  @free does some complicated logic on the type to generate a theorem that it MUST satisfy
16:10:23 <bd_> no matter how you implement it
16:10:56 <bd_> @free f :: a -> b
16:10:56 <lambdabot> h . f = f . g
16:11:04 <bd_> @free f :: a -> a
16:11:04 <lambdabot> g . f = f . g
16:11:22 <bd_> @free f :: a -> a -> a
16:11:22 <lambdabot> g . f x = f (g x) . g
16:11:50 <sorear> hmm, it'd be nice if @free could @unpl
16:12:01 <sorear> @ft f :: a -> a -> a
16:12:01 <bd_> @. unpl free f :: a -> a -> a
16:12:02 <lambdabot>  There was an error in the type: (line 1, column 4):
16:12:02 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
16:12:02 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 3, srcColumn = 1}: Parse error in pattern
16:12:24 <sorear> @ft a -> a -> a
16:12:26 <lambdabot>  There was an error in the type: (line 1, column 7):
16:12:26 <lambdabot>  unexpected "e"
16:12:26 <lambdabot>  expecting "->" or end of input
16:12:40 <sorear> @ft (fo :: a -> a -> a)
16:12:41 <lambdabot>  There was an error in the type: (line 1, column 4):
16:12:41 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
16:14:31 <dons> @free sort
16:14:33 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
16:14:38 <george--> anyone looking into my problem, i have solved it. missed a * in it
16:14:45 <dons> @free foldl
16:14:47 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
16:15:09 <bd_> @free undefined
16:15:10 <lambdabot> f undefined = undefined
16:15:22 <bd_> hmm
16:15:24 <dons> its a strict language ;)
16:15:27 <bd_> ah :)
16:15:27 <LoganCapaldo> let flip const = f
16:15:44 <dons> the original free theorems algo, which @free uses, anyway
16:15:53 <dons> @free foldl1
16:15:54 <lambdabot> (forall x. f . g x = h (f x) . f) => f . foldl1 g = foldl1 h . $map f
16:15:58 <dons> @free scanr
16:16:00 <lambdabot> (forall x. f . h x = k (g x) . f) => $map f . scanr h y = scanr k (f y) . $map g
16:16:18 <dons> ^^ this is why haskell is cool. free properties for your IDE!
16:16:52 <LoganCapaldo> You can use this generalize stuff like map fusion too, correct?
16:17:07 <sorear> almost
16:17:08 <dons> well, to find fusion rules, or quickly check the correctness of one
16:17:13 <dons> its related
16:17:13 <sorear> @ty map
16:17:15 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
16:17:29 <sorear> @ty (\f l -> reverse $ map f l)
16:17:30 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
16:17:34 <xic> anyone know for sure where the most recent darcs repos of hinotify is?
16:17:39 <dons> with all this talk of 80 cores, i couldn't resist, http://programming.reddit.com/info/148ef/comments
16:17:40 <lambdabot> Title: Shared-nothing Haskell: data parallel Haskell on 40 cpus. Now! (reddit.com)
16:17:42 <dons> xic, hmm.
16:17:48 <dons> ?where hinotify
16:17:48 <lambdabot> http://haskell.org/~kolmodin/code/hinotify/
16:18:00 <sorear> these two functions have exactly the same type, but the second has half as many fusion rules.
16:18:12 <xic> dons: what about the stuff in hackage.haskell.org?
16:18:15 <sorear> revMap f . revMap g /= revMap (f . g)
16:18:19 <dons> hackage is the binary tarball
16:18:28 <dons> i.e. the stable snapshot
16:20:03 <xic> dons: have you ever tried using hinotify with hs-plugins, to automatically reload the plugin when it is changed?
16:21:09 <sorear> dons: status: yi has a number of race conditions that, while harmless (?) with vty-2.0.2, are interacting badly with vty-3.0.0's optimizations ... I do so love +RTS -xc
16:22:25 <ddarius> sorear: But revMap f . revMap g == reverse . revMap (f . g) and map f . map g /= reverse . map (f . g)
16:23:11 <dons> xic, hmm. nice idea.
16:23:25 <dons> currently i usually just poll, which checks the creation date on the .o file
16:23:29 <dons> and does a reload
16:23:36 <dons> but hinotify would be cuter
16:23:51 <dons> sorear: ok. interesting. i wasn't aware of any races. care to elaborate?
16:24:01 <dons> have they appeared due to the new ui?
16:25:07 <sorear> dons: I think it's a race ... anyway, the new array images must be rectangular, and somehow (I think it has to do with asynch size setting) yi is trying to connect windows of mismatched sizes
16:25:48 <sorear> also, a few takes were missing, so several of the lines in the current yi are infinitely long ... but vty-2.0.2 was lazy enough you didn't notice
16:25:55 <dons> interesting. I think the width was set across all windows previously.
16:26:09 <dons> ok. so that's all new ui/line wrap code, most likely.
16:26:11 <dons> as long as I didn't write it!
16:26:23 <dons> good to see progress
16:27:32 <sm> woohoo! got my entries printing nicely
16:28:05 <Cale> I wonder why the "Type classes: not quite overloading" entry on reddit says 5 comments, when there only appear to be 3.
16:28:15 <dons> it seems to be some new reddit feature
16:28:16 <dibblego> Cale, I get that sometimes too
16:28:19 <dons> i've noticed it for the last week or so
16:28:27 <dons> I *think* it means the total number of edit clicks
16:28:33 <sm> using pairs as Cale suggested (type EntryTransaction = (Entry,Transaction)) .. it seems best for now, the data is not large
16:28:41 <dons> whether you amend a comment, add a new one, or only attempt to write one, then cancel
16:28:45 <dons> frankly, its confusing.
16:29:30 <dibblego> how do you delete the element before your pointer to a node in a singly linked list in C?
16:30:16 <EvilTerran> you'll need to jump back to the start, then advance thru 'til you get to a node with its next-pointer = your pointer
16:30:17 <george--> what is a higher precision than double?
16:30:19 <dons> use a double linked list? ;-)
16:30:32 <dibblego> apparently, this is a google interview question and it has a O(1) answer
16:30:37 <dons> george--: hmm. Data.Ratio
16:30:52 <dons> otherwise, one of the numerics libs that provide arbitrary precision types
16:31:08 <dons> george--: though also, compiling with -fexcess-precision in your module gives you a bit more hardware-based precision
16:31:09 <dibblego> and apparently, the answer is incredibly simple
16:31:37 <dons> keep a ptr to the previous node always cached?
16:31:46 <dibblego> nope, only one pointer
16:31:49 <siti> this is a haskell chanel btw ;)
16:31:51 <EvilTerran> dibblego, linear scan the entire heap to find the previous node, not terminating early
16:32:00 <EvilTerran> that'll always take the same amount of time on any one setup
16:32:02 <EvilTerran> .'. O(1) :P
16:32:03 <dibblego> siti, #haskell is the best channel for C questions - haven't you noticed? :)
16:32:09 <george--> im really struggling... im trying to numerically solve an equation which basically takes the form k cot(kR) = -a
16:32:11 <siti> lol
16:32:28 <dons> george--: ok, where's your code?
16:32:30 <dons> ?paste <--
16:32:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:32:44 <george--> but my problem is for small k (of the magnitude 10**-15) k cot k = 1
16:32:45 <george--> always
16:32:49 <dons> dibblego: remember we have augustss  in here, he's won the IOCCC twice I think
16:32:52 <xic> anyone know what the "searchable" field of Permissions is?
16:32:58 <sorear> x
16:33:03 <sorear> 111
16:33:12 <hpaste>  george-- pasted "numerical method" at http://hpaste.org/472
16:33:15 * dibblego slaps augustss on the cheek
16:33:22 <george--> im kinda fiddling with that
16:33:38 <sorear> dibblego: I just figured it out
16:33:43 <dibblego> sorear, don't tell me
16:33:56 <dibblego> sorear, I haven't given it proper thought yet
16:34:07 <dons> function is a funny name for a functoin ;-)
16:34:30 <dons> george--: can you include some expected input and output?
16:34:32 <george--> dons, the fact im never going to use it again :P
16:34:44 <george--> i think actually i am working on the wrong order of magnitude
16:35:43 <EvilTerran> sorear, rot13 it? I'm intrigued
16:36:08 <ddarius> sorear: Is it an actual answer or is it word play?
16:36:59 <dibblego> sorear, apparently, it's simple - no word play
16:37:06 <dibblego> er, ddarius
16:37:30 <george--> ok. this confusion is my fault. program works flawlessly i just misread a fm^-1 for a fm (femto metres) so i was out by 30 orders of magnitude in my expected input
16:38:34 <sorear> my method is ... too clever
16:40:40 <chessguy>  george-- what, do you work for NASA?
16:40:43 <sorear> Big hint: tr a-z n-za-m vgvfjbeqtnzrfvslbhpnagpunatrgurcbvagreinyhrfpunatrgurzrnavatbsgurfnzrinyhrf
16:40:59 <george--> chessguy, no. but this is physics related :)
16:41:14 <george--> nasa normally dont care so much for femto metres
16:41:19 <sorear> chessguy: nice try
16:41:22 <dons> Cale: see this, unicode on reddit, http://programming.reddit.com/info/12axj/comments/c12er1
16:41:23 <lambdabot> Title: Seriously, let’s make fonts not suck! (reddit.com)
16:41:30 <chessguy> sorear, ?
16:41:34 <sorear> chessguy: the space at BOL is ignored now
16:41:53 <chessguy> sorear, what are you babbling about?
16:42:01 <sorear> george++
16:42:34 <sorear> chessguy: I thought you were trying to defeat the karmabot by putting a space before "george-" ++ "-"
16:42:39 <Cale> dons: cool
16:42:42 <chessguy> @karma george
16:42:42 <lambdabot> george has a karma of -8
16:42:51 <Cale> I'm missing 20D1
16:43:04 <chessguy> sorear, i'm not exactly a precision typist :)
16:43:19 <george--> ge n-m a-mn-z itiswordgamesifyoucantchangethepointervalueschangethemeaningofthesamevalues
16:43:21 <Cale> (combining right harpoon above)
16:43:23 <george--> ?
16:43:51 <sorear> george--: it was rot13 for a reason :)
16:43:56 <chessguy> lol
16:44:07 <Cale> also, firefox does a terrible job of aligning things properly.
16:44:16 <george--> sorry :P
16:46:24 <ddarius> Um if it is word play, a much simpler answer would be free(ptr - 1)
16:46:44 <ddarius> If that's the answer then I very much dislike the problem.
16:46:51 <Cale> It seems to completely ignore combining characters, displaying them to the right of the characters they're supposed to modify.
16:47:09 <dibblego> you change the meaning of a node's next pointer?
16:47:17 <ddarius> (or not necessarily free but whatever)
16:47:25 <Cale> Thai looks all wrong. I think there's probably a way to fix that -- perhaps using a better font for Thai.
16:48:36 <sorear> EvilTerran, dibblego: ignore my answer resp. hint, I misread the problem description
16:49:21 <xic> @seen kolmodin
16:49:21 <lambdabot> kolmodin is in #darcs, #gentoo-haskell, #haskell.hac07 and #haskell. I last heard kolmodin speak 3h 6m 45s ago.
16:53:23 <sorear> dons: found it!  it was an uncaught runtime type error - I use (x,y) consistently in vty, jyp/you (?) uses (y,x) (consistently?) in yi, so the line I added used the wrong width for a modeline.
16:53:49 <sorear> Haskell' should specify an order for coordinate pairs :p
16:54:51 <LoganCapaldo> data CoordPair a = CoordPair { x :: a, y :: a } ?
16:55:54 <dibblego> I got it
16:56:04 <sorear> ?
16:56:40 <LoganCapaldo> well naming x and y would solve that right?
16:57:12 <sorear> dibblego: that ? was for you :)
16:57:16 <LoganCapaldo> lol
16:57:20 <dibblego> oh
16:57:34 <dibblego> want the answer?
16:57:38 <sorear> yes
16:57:51 <chessguy> do tell
16:58:08 <sorear> @tell dons YI RUNS!!  (x,y) vs (y,x) strikes again.
16:58:08 <lambdabot> Consider it noted.
16:58:09 <dibblego> copy the next element's data/next pointer to the current, reassign current.next and free it
16:58:17 <dibblego> I don't tihnk it will work for the last node though
16:58:49 <sorear>  /msg EvilTerran do { struct node *nextcache = ptr->next; memcpy(ptr, nextcache, sizeof(struct node)); free(nextcache); } while(0); // disclaimer I haven't used C in months
16:59:03 <sorear> ^^^ is that your idea? if so, it won't work
16:59:34 <sorear> it deletes the pointed-to node, not the previous one as you specified
17:00:05 <dibblego> you need to reassign the current.next
17:00:13 <dibblego> oh wait
17:00:23 <bd_> I thought the problem was to erase the /previous/ node?
17:00:27 <sorear> jyp deleted my benchmark!
17:00:33 <dons> sorear: ah nice.
17:00:33 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:00:35 <dibblego> yeah that's pretty much the answer
17:00:46 <dons> we need better typing for this
17:00:54 <bd_> Hmm, if you only have a pointer to the node after, it should be impossible to ever reach the one before, much less the one before /that/, in order to edit the list structure. The only way I can see is to attach a flag of some sort to the current
17:00:59 <dons> Point = Point X Y
17:01:05 <dons> newtype X = X Int
17:01:18 <sorear> dons: unfortunately my benchmark of choice, scrolling up and down Yi/Lexers.hs, fails now.
17:01:28 <sorear> dons: jyp deleted that file :/
17:01:45 <dons> ah well, you know how to get it back.
17:01:53 <sorear> so I'll have to find an old version before I can bla bla
17:01:57 <dons> you think newtype X = X { unX :: Int } makes sense ?
17:02:11 <dons> does this happen enough that we shoudl statically check it?
17:03:10 <sorear> I don't know.  in any event it was caught by an assertion in vty, and a few {-# SCC #-} pragmas narrowed down the area I had to search considerably.
17:03:39 <dons> I'd be inlined to tag this statically. seems like an easy thing to get wrong.
17:03:56 <sorear> the things that looked like race conditions remain, but can only be triggered if you resize yi (so don't do that! ;P)
17:03:56 <dons> hey coffee-mug
17:04:05 <dons> ok. that should be fixed then.
17:04:32 <coffee-mug> hey dons
17:04:44 <Gwern> hey, does anyone have the time & inclination to look over a Wikibook answer for me?
17:04:56 * Gwern points to http://en.wikibooks.org/wiki/Talk:Haskell/Simple_input_and_output#Partial_answer
17:04:58 <lambdabot> http://tinyurl.com/274esh
17:05:14 <dons> yeah, just ask. if someone has spare brain cycles, they might take a look. :-)
17:05:39 <dons> its a lossy queue, you queue up jobs, if the #haskell hive mind has cycles, it will run the jobs, sometimes in peak load, jobs get dropped
17:05:46 <dons> also, if they're uninteresting :-)
17:05:51 <Gwern> dons: hmm. who has authority to nice up jobs?
17:06:09 <dons> that's a political issue
17:06:27 <dons> e.g. an op can say, "Hey X, can you look at this?"
17:06:30 <dons> then maybe they will
17:06:52 <sorear> this looks messy, can anyone comment on my unix-fu:
17:06:52 <sorear> stefan@stefans:~/yi$ darcs diff --match 'name .*Lexer.*' | head -n -6 | tail -n +15 | cut -c 3- > /tmp/Lexers.hs
17:07:08 <dons> sorear: i'd darcs get to another repo
17:07:14 <dons> darcs unrecord till you get Lexers.hs back
17:07:16 <dons> then copy it out
17:07:42 <ddarius> darcs diff --match 'name .*Lexer.*' | ghc -e ...
17:10:50 <sorear> wow, even without additional optimizations yi has doubled in speed
17:11:04 <sorear>         total time  =       12.80 secs   (256 ticks @ 50 ms)  |         total time  =        7.75 secs   (155 ticks @ 50 ms)  -- from diff -y yi.prof.[34]
17:11:36 <mbishop> So yi is still alive?
17:12:19 <sorear> mbishop: for certain definitions of alive.
17:12:32 <sorear> like lambdabot, yi has forgotten its reason for existing
17:12:50 <mbishop> @yow
17:12:51 <lambdabot> What I need is a MATURE RELATIONSHIP with a FLOPPY DISK ...
17:12:51 <Gwern> why does yi exist? is it emacs envy?
17:12:53 <sorear> it has wandered far from its original purpose
17:13:02 <Cale> Gwern: first thing I noticed is that there are lots of spurious return ()'s
17:13:06 * ddarius remembers lambdabot's reason for existance.
17:13:19 <sorear> ddarius: ooh, what was it?
17:13:23 <Gwern> Cale: are you sure? I thought they were necessary to avoid havin to "quit" multiple times
17:13:26 <sorear> (hs-plugins, right?)
17:13:36 <Gwern> although that may an artifiact of my original if..then implementation
17:13:38 <sorear> 'cause yi has lost dynamism too
17:13:40 <Cale> return () is an action which does nothing
17:13:47 <Cale> and returns the value ()
17:13:49 <coffee-mug> I've always wanted to rewrite emacs until I actually got comfortable with it
17:13:52 * Gwern will try that out
17:14:21 <ddarius> We wanted a bot of our own, we felt like hacking on something, and we wanted something to do the things lambdabot now does where we = #haskell.
17:14:26 <Cale> main has the same type as return (), but it actually does something
17:15:01 <Gwern> huh. Cale: I guess you're right. removing the returns doesn't seem to affect the functionality
17:15:06 <dons> ddarius: so you think the original lambdabot goals have been met?
17:15:07 * sorear always vaguely suspected lambdabot predated #haskell@freenode
17:15:09 <dons> ?seen lambdabot
17:15:10 <lambdabot> Yes, I'm here. I'm in #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #
17:15:10 <lambdabot> haskell
17:15:21 <ddarius> sorear: Quite definitely.
17:15:27 <ddarius> sorear: And then a lot.
17:15:29 <Cale> Gwern: check out what happens when you put a return in the middle of a block of commands
17:15:41 <Cale> (see if you can guess beforehand :)
17:16:12 <Gwern> it aborts the sequence like a break would?
17:16:18 <Cale> nope
17:16:21 <Cale> it's a no-op
17:16:39 <Gwern> eh? how does that work? return returns stuff...
17:16:49 <Cale> do { putStr "a"; return (); putStr "b" } will print "ab"
17:16:57 <mbishop> returning () is nothing
17:17:10 <Gwern> > do { putStr "a"; return (); putStr "b" }
17:17:11 <lambdabot>  <IO ()>
17:17:18 <sorear> returning ANYTHING is nothing, at least in IO
17:17:18 <mbishop> since () is unit, an old MLism for nothing
17:17:37 <sorear> what, ML didn't call it 1?
17:17:37 <Cale> (return x) is an action which when run, does nothing and simply returns x.
17:17:53 <Gwern> hmm. so returning the empty set is equivalent to doing nothing
17:18:01 <sorear> with the emphasis on the algebra in adt
17:18:08 <Cale> Putting it in the middle of the block, it will run, but do nothing, and we're not even capturing its result.
17:18:24 <Cale> If we had something like:
17:18:27 <Cale> x <- return 5
17:18:41 <sorear> ... and since return is lazy, not even unsafePerformIO will compell return to have an effect
17:18:45 <Cale> though bad style, this would bind x to the result of return 5, which is 5.
17:19:12 <Cale> do { x <- return 5; print x }
17:19:15 * sorear wonders if it might be ever useful to force monomorphism like that
17:19:16 <Cale> should print 5.
17:19:25 <jcreigh> Gwern: "return" is just a function that lifts something into a monad. The fact that it has the same name as something that breaks out of the execution of a function in other languages is just an unfortunate mishap.
17:20:00 <Cale> return is an okay name for it overall, but it does carry baggage with it from other languages :)
17:20:07 <bd_> unit 5 `bind` print :)
17:20:15 <Gwern> I'll try to remember that.
17:20:18 <xic> "unfortunate mishap"? it's not like they didn't know what the keyword "return" does in the most popular programming language on earth
17:20:36 <sorear> mu (fmap print (eta 5)) :)
17:20:38 <Cale> xic: It's just that we don't care what it means in other languages :)
17:20:50 <jcreigh> okay, sorry, "confusing [to newcomers] design choice"
17:21:02 <sorear> er, \mu (fmap print (\eta 5))
17:21:09 <Cale> mu (IO print (eta 5))
17:21:18 <Cale> hehe
17:21:34 <xic> Cale: what really bugs me is, == && ||, but not !=, and "not" instead of !
17:21:35 <sorear> I thought haskell was designed specifically FOR newbie resistance? :P
17:21:48 <Cale> xic: /=
17:21:59 <xic> Cale: yeah, i know. it really should be != though
17:22:03 <sorear> xic: you get use to it .. and then you lose C
17:22:12 <Cale>  /= looks more like "not equals" to me than !=
17:22:16 <sorear> xic: != ... that's strict definition, right? :p
17:22:50 <newsham> "two dozen short lessons" seems designed specifically for newbies.
17:22:51 <Gwern> ok. I've rewritten it a bit to factor out the return ()s
17:23:00 <Cale> Haskell wasn't the first language to use /= for not-equals.
17:23:09 <Gwern> however, I'm not sure how I can avoid use of return () in  filterStringAndWrite
17:23:28 <Gwern> is there a better way to say "do nothing and exit this function"?
17:23:32 <LoganCapaldo> wishes && and || were and and or
17:23:37 <Cale> Gwern: it's fine there, you're using it as a no-op :)
17:23:39 <sorear> Gwern: return () IS useful - it's like Python's pass
17:23:41 <newsham> gwern: "return" does not mean "exit this function"
17:23:53 <newsham> be careful
17:24:07 <sorear> it says "don't do anything, but satisfy the syntactic construct that wants a statement"
17:24:14 <Cale> The only way to end an IO computation is to run all the way to the end of it.
17:24:28 <newsham> "dont do anything EXCEPT set the result"
17:24:40 <xic> Cale: or throw an exception
17:24:49 <Cale> or throw an exception, sure.
17:24:52 <Cale> Which seems odd at first, but it actually helps readability.
17:25:08 <jcreigh> LoganCapaldo: What would "and" and "or" be, then? (and, or :: [Bool] -> Bool)
17:25:15 <SamB> Cale: it won't seem odd to ex-C programmers
17:25:19 <Gwern> sorear: well, if I don't have an expression on the other side of the case ->, then it complains.
17:25:23 <xic> would be cool if there were a base IO monad that didn't have exceptions
17:25:25 <Cale> Because you don't have to be wary about things terminating the block from the middle -- if something is listed, it will be run.
17:25:37 <Cale> SamB: oh?
17:25:45 <LoganCapaldo> jcreigh: class BoolStuff where and ::, or ::
17:25:45 <Cale> SamB: I've had people confused about it.
17:25:59 <LoganCapaldo> I suspect that wouldn;t actually work
17:26:00 <SamB> xic: and it would be cool if there were filesystems that let you do anything
17:26:04 <LoganCapaldo> but I can dream
17:26:06 <newsham> > do { return 1; return 2; return 3; return 4; return 5 } :: (Just Int)
17:26:07 <lambdabot>   Not in scope: type constructor or class `Just'
17:26:12 <newsham> > do { return 1; return 2; return 3; return 4; return 5 } :: (Maybe Int)
17:26:13 <lambdabot>  Just 5
17:26:18 <SamB> Cale: ex-C, meaning they've gone on to use something with exceptions
17:26:18 <Cale> Gwern: right, your usage of return () there is idiomatic
17:26:25 <Gwern> still, I appreciate the help. It's pleasingly short now. I'm not sure it'd be any shorter in java, and it certainly looks cleaner than its equivalent
17:26:27 <Cale> SamB: ah
17:26:39 <jcreigh> LoganCapaldo: err, maybe I'm not very clear.
17:26:41 <Gwern> *the help, everyone.
17:26:42 <Cale> Gwern: well, another thing you could do is to use readFile
17:26:42 <jcreigh> @src and
17:26:42 <lambdabot> and   =  foldr (&&) True
17:26:49 <LoganCapaldo> I know
17:27:00 <Cale> rather than openFile/hClose/hGetContents
17:27:01 <jcreigh> okay...why would you want a class for that?
17:27:12 <Gwern> Cale: I thought about it, but I'm trying to use stuff covered in the wikibook chapter
17:27:17 <Cale> ah, okay
17:27:19 <Gwern> just using case expressions is pushing it
17:27:20 <LoganCapaldo> if the arg was a list it would act like  foldr (&&). If it was a Bool it would act like &&
17:27:24 <LoganCapaldo> hence the class
17:27:30 <LoganCapaldo> so you can overload and and or
17:27:31 <Gwern> readFile *is* mentioned in the chapter, but only fleetingly
17:27:35 <jcreigh> oh, magic.
17:27:42 <LoganCapaldo> (I realize you can't actually do that)
17:27:52 <LoganCapaldo> Or if you can I don't know the magic :)
17:28:38 <jcreigh> instance BoolClass [Bool] where and = foldr (&&) True ...?
17:28:59 <sorear> instance BoolClass a => BoolClass [a] !!!
17:29:01 <LoganCapaldo> but doesn't and have to have the same arity for every instance?
17:29:04 <sorear> MUAHAHAHA!!!
17:29:15 <sorear> LoganCapaldo: nah
17:29:24 <newsham> class Boolable a =>  (&&) :: a -> a -> Bool
17:29:32 <sorear> LoganCapaldo: PrintfType has instances with different arities for printf!
17:29:35 <Cale> Gwern: you could also read all the text before writing it to a file
17:29:47 <LoganCapaldo> Ok, so good :)
17:29:49 <bd_> newsham: class Boolable a where toBool :: a -> Bool would be more general
17:29:55 <LoganCapaldo> Someone write up a patch :)
17:30:00 <bd_> newsham: then you can define (Boolable a, Boolable b) => a -> b -> Bool
17:30:04 <Gwern> Cale: hmm. how so?
17:30:43 <Gwern> in java, I'd append to a string each loop, but I'm not sure how I could modify filterStringAndWrite in that way
17:30:49 <newsham> I dont understand what you want toBool [Bool] to do
17:31:32 <Cale> Gwern: I'll write you an example
17:31:38 <Cale> !paste
17:31:38 <hpaste> Haskell paste bin: http://hpaste.org/
17:31:42 <newsham> hmm.. wait, you want     Bool && Bool -> Bool,  but  [Bool] && ?? -> Bool?
17:32:53 <LoganCapaldo> newsham: I want Bool and Bool <and also> and [Bool] -> Bool
17:33:14 <hpaste>  Cale pasted "getLinesUntilDot" at http://hpaste.org/473
17:33:25 <newsham> cant do that.
17:33:28 <LoganCapaldo> Its hard to talk about this with all the ands flying around :)
17:33:37 <LoganCapaldo> newsham: That was my impression
17:34:07 <LoganCapaldo> But I gather you can use a Printf style trick to acheive it?
17:34:10 <newsham> you could do   and (Bool,Bool) -> Bool.   *AND*   and [Bool] -> Bool
17:34:20 <newsham> yah i imagine you can do it in TH
17:34:55 <newsham> doesnt sound like its buying a whole lot though :)
17:35:01 <Cale> Gwern: is it reasonably clear how that works?
17:35:02 <jcreigh> but and :: (Bool, Bool) -> Bool is bad because you lost (a `and` b)
17:35:05 <jcreigh> *lose
17:35:16 <jcreigh> LoganCapaldo: see? This is why. :)
17:35:39 <newsham> and False _ = False; and _ False = False; and True True = True;  ands = foldr and True
17:35:49 <LoganCapaldo> newsham: Actually i don't really care about and [Bool], this is mostly me expressing my hatred for && ;)
17:36:25 <newsham> && is where its at!
17:37:02 <Gwern> Cale: I think so. it's recursively building a list?
17:37:10 <Cale> Gwern: yeah
17:37:56 <Gwern> Cale: I'll think about adding it later. now I need to take a nap
17:38:24 <jcreigh> LoganCapaldo: well && and || are kinda nice because you don't need to use `backticks` all the time for infix. But taste differs.
17:39:09 * sorear cleans yi/vty-3.0.0 for submission
17:39:37 <LoganCapaldo> jcreigh: This is why Haskell needs backtick inference ;)
17:42:04 <newsham> upgrade your human to prefix.
17:42:52 * LoganCapaldo prefers postfix
17:43:01 * sorear prefers exim
17:43:03 * ddarius uses outfix.
17:43:14 <LoganCapaldo> mixfix ftw
17:43:15 <newsham> n $$ f = f n
17:43:39 <LoganCapaldo> newsham: Seriously?
17:43:44 <LoganCapaldo> @src $$
17:43:44 <lambdabot> Source not found. You speak an infinite deal of nothing
17:43:54 <LoganCapaldo> @src ($$)
17:43:54 <lambdabot> Source not found. It can only be attributed to human error.
17:43:59 <LoganCapaldo> le sigh
17:43:59 <newsham> roll your own postfix :)
17:44:09 <newsham> make sure to make it right assoc
17:44:31 <ddarius> @google Embedding postfix languages into haskell
17:44:34 <lambdabot> http://www.eecs.usma.edu/webs/people/okasaki/hw02.ps
17:44:49 <newsham> > let ($$) = flip ($) in (1 $$ (2 $$ (+)))
17:44:52 <lambdabot>  3
17:45:16 <LoganCapaldo> .
17:45:20 <LoganCapaldo> oops
17:45:28 <newsham> lambdabot wont let you define something right assoc as far as i know
17:51:35 <ddarius> @google Typed Quote/AntiQuote
17:51:37 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
18:02:33 <monochrom> ?seen conal
18:02:34 <lambdabot> I saw conal leaving #haskell 4h 14m 25s ago, and .
18:02:41 <monochrom> ?seen conals
18:02:42 <lambdabot> I haven't seen conals.
18:04:45 <monochrom> I can't reproduce conal's problem of re-exporting instances :)
18:05:26 <perspectival> does anyone know how to get greencard (for use with Cabal/Setup.hs) installed on Ubuntu amd64?
18:06:10 <monochrom> methinks greencard is a bit out-of-date, few people use it, no longer maintained
18:06:22 <monochrom> you may be able to do without greencard
18:06:48 <monochrom> wait, greencard is what gets you to hook up with COM?
18:06:57 <perspectival> i'm really trying to install regex-base, but when i run "sudo runhaskell Setup.hs configure --ghc --prefix=/usr" i get, at the end of input:
18:06:57 <perspectival> configure: Using hsc2hs: /usr/bin/hsc2hs
18:06:57 <perspectival> configure: Using c2hs: /usr/bin/c2hs
18:06:57 <perspectival> configure: Using cpphs: /usr/bin/cpphs
18:06:57 <perspectival> configure: No greencard found
18:07:16 <perspectival> and i'm assuming setup.hs is complaining about greencard
18:07:57 <monochrom> You can ignore it.  It is just FYI not an error.
18:08:49 <monochrom> Setup.hs is very generic, tests for everything, but not all are real dependencies.
18:08:54 <perspectival> so it should have installed, but in ghci i get: Prelude> :m Text.Regex.Parsec
18:08:54 <perspectival> Could not find module `Text.Regex.Parsec':
18:08:54 <perspectival>   Use -v to see a list of the files searched for.
18:09:24 <monochrom> Have you also "runhaskell Setup.hs build" and "runhaskell Setup.hs install"?
18:09:34 <perspectival> aha ;-)
18:09:35 <johanatan> hi
18:10:37 <johanatan> i'm having trouble running ghci on mac os x tiger..  it says 'getCurrentDirectory: does not exist (No such file or directory)'.. anyone have an idea?
18:11:00 <monochrom> Hmm regex-base has Text.Regex.Parsec?
18:11:54 <perspectival> it does export it i think
18:12:03 <perspectival> i'm still getting "could not find module..."
18:12:08 <perspectival> it did install correctly
18:12:20 <perspectival> Installing: /usr/lib/regex-base-0.71/ghc-6.6 & /usr/bin regex-base-0.71...
18:12:20 <perspectival> Registering regex-base-0.71...
18:13:18 <monochrom> My GHC comes with regex-base-0.71 too.  It only has: Text.Regex.Base, Text.Regex.Base.RegexLike, Text.Regex.Base.Context, Text.Regex.Base.Impl
18:13:39 <monochrom> You can try Text.Regex.Base first.
18:14:21 <perspectival> right, i'm seeing those now...
18:14:22 <perspectival> Prelude> :m Text.Regex.Base
18:14:22 <perspectival> module main:Text.Regex.Base is not loaded
18:14:30 <perspectival> cheers for the help monochrom
18:15:01 <orbitz> hrm
18:15:05 * orbitz considers buyign Maple
18:15:16 <perspectival> so it looks like i should only load Text.Regex, and it works...
18:15:38 <perspectival> but is Text.Regex.Base not a module?
18:15:43 <monochrom> But Text.Regex is from another package altogether.
18:16:03 <monochrom> ghc-pkg list   --- what do you get?
18:16:34 <perspectival> this: /usr/lib/ghc-6.6/package.conf:
18:16:34 <perspectival>     Cabal-1.1.6, Cabal-1.1.6.1, base-2.0, (ghc-6.6), haskell98-1.0,
18:16:34 <perspectival>     parsec-2.0, readline-1.0, regex-base-0.71, regex-compat-0.71,
18:16:34 <perspectival>     regex-posix-0.71, rts-1.0, stm-2.0, template-haskell-2.0, unix-1.0
18:17:26 <monochrom> um, have you also ditched existing ghci session (those running before you installed regex-base) and started new ones for the test? :)
18:17:34 <perspectival> yes ;-)
18:18:42 <monochrom> Do the test in some other directory - any directory, just never that of regex-base itself
18:20:30 <johanatan> can any of you guys help get ghci working for me?
18:21:09 <perspectival> monochrom: it can find Text.Regex and Text.Regex.Posix, but not the others, like Text.Regex.DFA/PCRE/TRE
18:22:43 <perspectival> but i think i don't need to find Text.Regex.DFE, because the interface is loaded
18:22:49 <perspectival> so i think it's correct
18:22:58 <perspectival> thanks for the help ;-)
18:24:44 <monochrom> I have seen "module main:<blahblah> is not loaded" before.  It was because I let ghci see both the package and its source code.  If I cd to another directory (so that ghci doesn't find the source code) it's ok.
18:26:18 <perspectival> i'll keep that in mind. i was wondering how you thought of that. i never would have...
18:26:57 <monochrom> It was also an accident for me. :)
18:31:09 <johanatan> is Haskell the best functional language to start with?
18:31:58 <johanatan> it sounds really neat 'in theory' but in practice, i can't get very much use out of Hugs or GHCi
18:32:32 <johanatan> i'm beginning to think i should try another lang.. such as LISP or something
18:32:39 <johanatan> Scheme
18:33:50 <sjanssen> johahatan: "can't get very much use"?
18:34:31 <monochrom> I am on Ubuntu, GHCi works out of the box.  Perhaps it's time you revised your assumptions.
18:34:31 <johanatan> yea, well Hugs is not very useful from the interpreter standpoint.. i mean, i can write txt files and load them and run.. but i prefer something like the python CLI when learning a lang
18:34:49 <johanatan> so that led me to GHCi, but now that i'm there, it complains that it can't find the current directory :)
18:35:22 <johanatan> here's the msg i'm getting: getCurrentDirectory: does not exist (No such file or directory)
18:35:46 <sjanssen> johanatan: anything strange about your platform?
18:36:03 <johanatan> well, it's a mac...  so, things are always a little funky installing on it
18:36:14 <johanatan> but, it was the package that was for mac
18:38:29 <sjanssen> johanatan: you downloaded the latest release, 6.6?
18:38:43 <johanatan> hmm
18:38:47 <johanatan> ok, i think i figured it out
18:38:56 <johanatan> running from within /usr/local/bin seems to work
18:39:05 <johanatan> i guess i need to add that to my path
18:39:16 <johanatan> (yea, it was 6.6)
18:40:53 <allbery_b> Macs don't put much of anything in the path for you; you need to make sure your terminals start up as login shells and set the PATH in your shell startup file (.profile or .login depending on sh/bash/zsh/etc. vs. csh/tcsh).  And don't launch stuff from icons because the PATH will be .:/bin:/usr/bin.
18:41:08 <fuzan> What's the link to the haskell gentoo overlay? Tyring to find it now.
18:41:39 <johanatan> cool..  thx for the tips
18:41:41 <mbishop> ?where gentoo
18:41:41 <lambdabot> I know nothing about gentoo.
18:41:47 <mbishop> ?where gentoo-haskell
18:41:48 <lambdabot> I know nothing about gentoo-haskell.
18:41:50 <fuzan> lambdabot, is stupid!
18:41:59 <mbishop> the #gentoo-haskell channel would probably know
18:41:59 <chessguy> @slap fuzan
18:42:00 * lambdabot slaps fuzan
18:42:07 <fuzan> @slap lambdabot
18:42:08 * lambdabot smacks lambdabot about with a large trout
18:42:09 <sjanssen> fuzan: use layman
18:42:10 <fuzan> haha.
18:42:43 <johanatan> allbery: yea, i've put so much stuff in /usr/local/bin that i can't believe it isn't already part of the path
18:43:23 * monochrom grins evilly
18:43:42 <monochrom> The mac doesn't come with a "paperclip" ala MS Word.
18:43:53 <allbery_b> fink and macports edit your .profile to add themselves to $PAHT, but neither adds /usr/local/bin
18:44:15 <allbery_b> (/sw/bin and /opt/local/bin, respectively)
18:44:17 <monochrom> If it did, it would jump out and say "hey you've been putting much much stuff under /usr/local/bin lately, want a tips?" :)
18:45:37 <johanatan> monochrom: true..  but, overall, macs are more user-friendly than windows... as long as you stay away from the command line ...  but, still, it's quite strange that ghci can't run from anywhere if you fully qualify it..
18:45:54 <sjanssen> lambdabot needs a clippy-like mode
18:46:29 <chessguy> http://www.appscout.com/2007/02/to_kill_a_paperclip.php
18:46:31 <lambdabot> Title: To Kill a Paperclip - AppScout
18:46:37 <NichardRixon> It looks like you're writing a monad?  Do you want help with syntactic sugaring?
18:46:49 <monochrom> I find the unix shell the most user-friendly.
18:47:34 <allbery_b> perhaps the mac is not for you, then :)
18:48:17 <monochrom> A few years ago I was attracted to the mac because it added the unix shell.
18:48:20 <allbery_b> the unix shell is rather strange on Macs.  it's even stranger from x11.app which does some bizarre things when starting stuff from its menu.  (I don't think Apple even understood my bug report.)
18:48:44 <johanatan> yea, go with bsd or some other flavor of unix..
18:49:10 <johanatan> roll your own linux or something
18:49:54 * allbery_b likes the combination of gui and shell but has had to work around quite a few peculiarities to get there
18:50:05 <sjanssen> allbery_b: X11.app really makes me grumpy
18:50:39 <dons> ?where+ urlcheck http://www.cse.unsw.edu.au/~dons/urlcheck.html
18:50:40 <lambdabot> Done.
18:50:48 <allbery_b> you're not the only one
18:50:50 <johanatan> allbery:  johanatan agrees.. it's a nice marriage.. beauty and power :)
18:50:54 * allbery_b *really* wishes cut&paste worked
18:51:26 * fuzan wonders why people like aqua.
18:51:26 <sjanssen> ironically, I've switched to Linux because I want my developery tools to "just work"
18:52:00 <sjanssen> I bet very few people switch to Linux because they want things to "just work"
18:52:21 <fuzan> no, most people use linux because they want things to "work".
18:52:50 <fuzan> the bleeding-edge doesn't really count.
18:52:53 <sjanssen> fuzan: did you figure out how to use the gentoo overlay?
18:53:07 <fuzan> sjanssen: I'm doing 500 things at once, so not yet :)
18:53:26 <fuzan> sjanssen: accidentally deleted / yesterday, so I'm rebuilding my system :)
18:54:58 <dancor> is there a shorter notation for let { MyVarA = MyArr!!0; MyVarB = MyArr!!1; MyVarC = MyArr!!2 }
18:55:41 <dancor> something like (a, b, c) = arr in python
18:56:09 <fuzan> Could you possibly use a data structure as opposed to an array?
18:56:14 <sjanssen> dancor: (x:y:z:rest) = someList
18:56:15 <fuzan> Then you could use record syntax
18:56:53 <sjanssen> dancor: note that !! is a list indexing operator, it isn't used for arrays
18:57:06 <sjanssen> and your variables need to be lower case :)
18:58:18 <nrb23> @pl let q n f = foldr1 (.) $ replicate n f
18:58:19 <lambdabot> (line 1, column 39):
18:58:19 <lambdabot> unexpected end of input
18:58:19 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
18:58:53 <nrb23> @pl  q n f = foldr1 (.) $ replicate n f
18:58:53 <lambdabot> q = (foldr1 (.) .) . replicate
18:59:04 <dancor> hah lowercase yes
18:59:28 <johanatan> guys, i have a quick question about prime numbers in haskell..  obviously, coming from imperative languages, i'm tempted to keep a finite list of prime numbers up to a certain threshold which i deem to be 'enough' for my purposes, but the feature of haskell that deals with infinite lists is very appealing too..  so, which would you guys recommend??  creating a func that can compute infinite primes or 'priming' my algo with a finite
18:59:53 <nrb23> my co-worker and I were discussing the function I just wrote... can anyone think of a better way to write it?
19:00:23 <Pseudonym> johnatan: It depends on your purposes.
19:00:39 <Pseudonym> If you're computing hash table moduli, for example, it makes no sense to have an infinite list.
19:00:39 <dancor> johanatan: well of course infinite is more reusable unless you can do finite more efficiently and need to
19:00:50 <Pseudonym> Infinite is also more leaky, memory-wise.
19:01:05 <Pseudonym> I rarely need a list of all prime numbers.
19:01:12 <Pseudonym> I'm more likely to need a list of prime numbers in some range.
19:01:14 <sjanssen> nrb23: I'd prefer "foldr (.) id" instead of "foldr1 (.)"
19:01:31 <nrb23> sjanssen: why's that?
19:01:34 <sjanssen> nrb23: then you can handle the n == 0 case
19:01:43 <nrb23> ah
19:01:47 <nrb23> good point
19:02:09 <Pseudonym> johnatan: http://andrew.bromage.org/darcs/numbertheory/
19:02:09 <lambdabot> Title: Index of /darcs/numbertheory
19:02:13 <Pseudonym> Check out Math/Prime in particular.
19:02:15 <sjanssen> otherwise, I like your definition
19:02:21 <monochrom> johanatan: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022387.html
19:02:24 <lambdabot> Title: [Haskell-cafe] Genuine Eratosthenes sieve [Was: Optimization fun], http://tinyurl.com/2fb4rd
19:02:39 <nrb23> sjanssen: is there a better way to write it? we weren't happy w/ replicate
19:03:03 <dancor> fuzan: good idea but i'm pulling from getArgs
19:03:14 <johanatan> Pseudonum & monochrom: thx
19:03:23 <sjanssen> nrb23: an alternate version is: \n f x ->iterate f x !! n -- but it isn't much better
19:03:51 <sjanssen> nrb23: the only other option I see is using explicit recursion
19:03:54 <johanatan> lambdabot: thx
19:04:17 <nrb23> sjanssen: yeah, I thought as much
19:04:28 <lambdabot> You're welcome, but I'm a bot.
19:04:42 <sjanssen> or: map (const f) [1..n]
19:04:57 <dancor> lambdabot: thank you
19:05:06 <dancor> lambdabot: tx
19:05:18 <lambdabot> Did you expect a different response by repeating yourself?
19:05:34 <johanatan> that's ok, bots need recognition/respect too :)
19:05:50 <sorear> tellfodder
19:06:23 <sorear> @uptime
19:06:24 <lambdabot> uptime: 1d 7h 5m 48s, longest uptime: 2d 17h 27m 21s
19:06:26 <fuzan> \quit
19:07:17 <johanatan> wow.  i think you should try to pass the turing test, lambda
19:07:31 <lambdabot> We were discussing you --not me.
19:07:42 <sjanssen> johanatan: one of the lambdabot admins is screwing with you
19:08:06 <Pseudonym> It's sometimes easy to tell who, too.
19:08:17 <sorear> VERY easy
19:08:28 <sjanssen> sorear: is there a command to do it?
19:08:32 <sorear> indeed a new lambdabot command tattles
19:08:41 <sjanssen> oh do tell
19:08:45 <dancor> @tattle
19:08:45 <lambdabot> Unknown command, try @list
19:09:12 <dancor> lambdabot: i'll never know for sure if you really wanted to say that, or someone made you
19:09:15 <sorear> er, no, gah.
19:09:37 <lambdabot> I wanted to say it
19:09:38 <sorear>  @activity only works on the output side.
19:09:39 <dancor> so much lambdatrust ..gone
19:10:07 <bd_> @activity
19:10:07 <lambdabot> 4*total 2*private 2*#haskell
19:10:26 <dylan> I thought lambdabot was bound to honesty!
19:10:27 <sorear> you see it breaks down by destination
19:10:49 <sorear> @activity-full
19:10:50 <lambdabot> 4*total 2*Pseudonym 2*#haskell
19:11:03 <Pseudonym> Oh, interesting.
19:11:05 <sorear> all that says is that lambdabot said somethingto Pseudonym
19:11:18 <Pseudonym> Yeah, I was trying to work out who it was.
19:11:24 <sorear> ... but if Pseudonym used @msg it would show up under #haskell
19:11:32 <sorear> @activity-full 600
19:11:32 <lambdabot> 12*total 10*#haskell 2*Pseudonym
19:11:35 <sorear> @activity-full 60000
19:11:35 <lambdabot> 650*total 320*#haskell 62*gly__ 39*nmessenger 38*ski 34*#gentoo-uy 23*pjd 19*#unicycling 14*ohmega 12*matthew_- 11*Lemmih 10*resiak 10*dons 8*#gentoo-haskell 6*Binkley 6*#perl6 5*rahikkala 5*#oasis
19:11:36 <lambdabot> 4*TuringTest 3*heatsink 2*xerox 2*shapr 2*glguy 2*dcoutts_ 2*chessguy 2*augustss 2*Pseudonym 1*dpiponi 1*dmhouse 1*allbery_b 1*ToRA 1*#jtiger 1*#darcs 1*#Haskell-blah
19:12:15 <sorear> @activity 60000
19:12:15 <lambdabot> 652*total 322*#haskell 255*private 34*#gentoo-uy 19*#unicycling 8*#gentoo-haskell 6*#perl6 5*#oasis 1*#jtiger 1*#darcs 1*#Haskell-blah
19:12:25 <sorear> "that's funny"
19:12:26 <heatsink> Are these people and channels, or just channels?
19:12:33 <Pseudonym> Both.
19:12:50 <heatsink> Oh, counts for people are private comms.
19:12:52 <Pseudonym> A message can be to a channel or a user; it's the same command.
19:13:06 <Pseudonym> Right.
19:13:25 <sorear> in LB code jargon, @activity works by target
19:13:37 <sorear> it's just an OutputFilter
19:15:37 <svref> what's the idiom for reading a string and converting to a number, where some fool user could have caused the string to be "fjsalkfj" ?
19:16:26 <svref> String -> Maybe Float
19:16:46 * heatsink would suggest parsec, but that's probably too heavyweight for your purposes
19:17:01 <sorear> reads
19:17:02 <Pseudonym> > reads (undefined::Int) "foobar"
19:17:07 <lambdabot>      The function `reads' is applied to two arguments,
19:17:07 <lambdabot>     but its type `Read...
19:17:16 <Pseudonym> Erm.
19:17:19 <Pseudonym> :t reads
19:17:20 <sorear> > reads "foobar" :: [(Int,String)]
19:17:22 <lambdabot> forall a. (Read a) => ReadS a
19:17:22 <allbery_b> reads "foo" :: Int
19:17:23 <lambdabot>  []
19:17:27 <Pseudonym> Right.
19:17:32 <Pseudonym> > reads "10foo"
19:17:32 <lambdabot>  Add a type signature
19:17:36 <Pseudonym> > reads "10foo" :: Int
19:17:36 <lambdabot>  Couldn't match `Int' against `[(a, String)]'
19:17:42 <Pseudonym> > reads "10foo" :: [(Int,String)]
19:17:43 <lambdabot>  [(10,"foo")]
19:17:46 <Pseudonym> That's it.
19:17:59 <sorear> > map (\(x,y) -> (y,x)) . reads $ "foobar" :: [(Int,String)]
19:18:00 <lambdabot>  Couldn't match `Int' against `String'
19:18:05 <sorear> > (map (\(x,y) -> (y,x)) . reads $ "foobar") :: [(Int,String)]
19:18:06 <lambdabot>  Couldn't match `Int' against `String'
19:18:19 <sorear> > (lookup "" . map (\(x,y) -> (y,x)) . reads $ "foobar") :: [(String,Int)]
19:18:20 <lambdabot>  Couldn't match `[(String, Int)]' against `Maybe a'
19:18:30 <sorear> > (lookup "" . map (\(x,y) -> (y,x)) . reads $ "foobar") :: Maybe Int
19:18:32 <lambdabot>  Nothing
19:18:37 <sorear> > (lookup "" . map (\(x,y) -> (y,x)) . reads $ "27") :: Maybe Int
19:18:38 <lambdabot>  Just 27
19:19:22 <sorear> @let readMB :: Read a => String -> Maybe a ; readMB = lookup "" . map (\(x,y) -> (y,x)) . reads
19:19:24 <lambdabot> Defined.
19:19:27 <svref> > reads "26" :: (Int,String)
19:19:28 <lambdabot>  Couldn't match `(Int, String)' against `[(a, String)]'
19:19:31 <sorear> > readMB "23" :: Maybe Int
19:19:32 <lambdabot>  Just 23
19:19:39 <heatsink> It seems to be a greedy parser.  What is the list of results for?
19:19:49 <sorear> heatsink: backtracking
19:20:14 <sorear> heatsink: the Int parser doesn't use it, but some others do
19:20:19 <heatsink> oh, ok.
19:20:21 <svref> C-Q quits xchat, apperantly :~[
19:20:51 <nrb23> last night, someone, (can't remember who :-< ) was helping me with ByteStrings and the Get Monad
19:21:00 <svref> LatLongitude pairs, [0-9]+[.][0-9]*
19:21:04 <nrb23> I had to go to bed before piecing it all together
19:21:20 <nrb23> and now I'm nearly able to build it
19:21:28 <nrb23> but I'm having trouble with ForeignPtr vs Ptr
19:21:31 <sorear> nrb23: dons/kolmodin/ndm/bringert ?
19:21:39 * araujo loves Haskell
19:21:44 * dancor concurs
19:21:46 <nrb23> I think it may have ben sjanssen
19:21:55 <Pseudonym> araujo: You're in the right channel.
19:21:58 <monochrom> It is possible to write a parser that parses "26xxx" into [(2,"6xxx"), (26,"xxx")].  Just in case "6xxx" makes sense later on.
19:22:17 <Pseudonym> monochrom: Sure.
19:22:40 <Pseudonym> If you want to do a Read instance, you could even do it with a newtype wrapper.
19:22:52 <araujo> I think it's the only language which i am able to get back after  ~1 year, and i can fix/add new stuff as if i wrote it yesterday
19:23:11 <araujo> get back to code*
19:23:25 <sjanssen> nrb23: I recall telling you that you can download binary from hackage
19:23:37 <nrb23> sjanssen: yeah, I got that to work
19:23:41 <sjanssen> I don't think I answered any technical questions
19:23:41 <nrb23> sjanssen: thanks for that
19:23:58 <nrb23> sjanssen: perhaps not
19:24:14 <Pseudonym> BRB
19:24:41 <hpaste>  nrb23 pasted "ForeignPtr vs Ptr?" at http://hpaste.org/474
19:25:55 <sjanssen> nrb23: a ForeignPtr is a Ptr with garbage collection/finalization support
19:26:06 <sjanssen> nrb23: are you currently managing your own memory?
19:26:07 <sorear> nrb23: there are at least two bugs there ...
19:26:23 * svref 's been learning Haskell for 3 months, then I "Taught myself Javascript in 2 weeks", now its amazing how much my hard-won how-to-do-itude in Haskell has evaporated in those 2 weeks.
19:26:39 <nrb23> I got the majority of that code from the example in the pcap library
19:26:42 <nrb23> ?where pcap
19:26:42 <lambdabot> I know nothing about pcap.
19:27:05 <nrb23> http://www.haskell.org/networktools/src/pcap/Pcap.hsc
19:27:46 <allbery_b> see?  javascript rots your mind!
19:28:18 <hpaste>  sorear annotated "ForeignPtr vs Ptr?" with "fixed (I hope)" at http://hpaste.org/474#a1
19:30:07 <hpaste>  nrb23 annotated "ForeignPtr vs Ptr?" with "(no title)" at http://hpaste.org/474#a2
19:30:19 <nrb23> sorear: still borked ;-<
19:30:33 <sorear> awww :(
19:31:18 <sorear> well, the first time I didn't check the docs, so ...
19:31:40 <sorear> you can probably fix the problem with judicious use of castPtr
19:31:46 * sorear checks for a safer way
19:32:33 <nrb23> ooh!
19:32:36 <nrb23> fromForeignPtr
19:32:44 <nrb23> http://www.cse.unsw.edu.au/~dons/fps/Data-ByteString-Base.html#v%3AfromForeignPtr
19:32:45 <lambdabot> http://tinyurl.com/2xxpev
19:32:48 <araujo> http://www.fmap.us/index.html
19:32:49 <lambdabot> Title: Luis Araujo
19:32:53 <araujo> new site!
19:32:54 <araujo> :-)
19:33:07 <sjanssen> > fmap us
19:33:07 <lambdabot>   Not in scope: `us'
19:33:45 <heatsink> nice render
19:34:24 <nrb23> oh
19:34:30 * nrb23 smacks himself
19:34:58 <nrb23> there's  unsafeCreate
19:35:30 <sorear> nrb23: you see fundamentally what the problem is - CChar is not Word8
19:35:49 <sorear> it COULD be, it probably is, but haskell keeps them separate
19:36:34 <nrb23> wait, I thought the problem was ForeignPtr != Ptr
19:36:52 <sorear> nrb23: I fixed that already in my paste, using packCStringLen
19:37:06 <sorear> but looking at the source of packCStringLen
19:37:14 <sorear>     fp <- newForeignPtr_ (castPtr ptr)
19:37:18 <nrb23> oh, right
19:41:03 <sorear> @where haddock-ghc
19:41:03 <lambdabot> I know nothing about haddock-ghc.
19:41:10 <nrb23> well, the wife is home, so I need to go cook
19:41:39 * mbishop cracks a whip
19:42:57 * jcreigh throws a heavy, blunt object at C++'s IO manipulators
19:43:11 <jcreigh> c'mon guys, printf is not a bad idea.
19:43:28 <heatsink> Your IO manipulators now globally print numbers in hex.
19:44:12 <Pseudonym> jcreigh: I hope for your sake that you're being sardonic.
19:44:50 <sorear> Pseudonym: printf is in Haskell, therefore it is good. QED.
19:44:54 <sorear> :)
19:45:08 <Pseudonym> sorear: Implicit arguments are in Haskell.  QED.
19:45:09 <araujo> nobody uses it though.
19:45:09 <jcreigh> Pseudonym: about printf or C++'s IO system?
19:45:11 * araujo runs
19:45:16 <sjanssen> I think printf is a terrible idea
19:45:38 <Pseudonym> jcreigh: I was thinking about printf, but the other works too.
19:45:49 <Pseudonym> The worst thing about C++'s IO system is the syntax, IMO.
19:46:05 <Pseudonym> It's not the only bad thing, but it's the worst thing.
19:46:11 <dibblego> implicit arguments - search for an argument of that type in scope?
19:46:15 * sorear invokes Wadler's Law
19:46:23 <Pseudonym> sorear: Quite.
19:46:34 <LoganCapaldo> @where Wadler's Law
19:46:35 <lambdabot> I know nothing about wadler's.
19:46:40 <LoganCapaldo> Fine
19:46:46 <LoganCapaldo> @go Wadler's Law
19:46:48 <lambdabot> http://www.informatik.uni-kiel.de/~curry/listarchive/0017.html
19:46:48 <lambdabot> Title: Re: Curry from Philip Wadler on 1996-12-19 (Curry mailing list)
19:46:54 <Pseudonym> Well, I could spend a lot of time ranting about std::locale, but it's more time than people have actually spent using it.
19:47:02 <Pseudonym> Given that nobody uses it.
19:47:12 <sjanssen> the C++ guys are totally nuts, bitshifting as the IO operator?  Obviously += makes more sense
19:47:20 <sjanssen> -= for input
19:47:35 <LoganCapaldo> I think += is as bad as <<
19:47:51 <sjanssen> LoganCapaldo: I was being sarcastic :)
19:48:00 <LoganCapaldo> I was being serious
19:48:06 <LoganCapaldo> deadly seriious
19:48:08 <sjanssen> *= if you want nonbuffered output
19:48:34 <LoganCapaldo> Because we all know the true IO operator is &
19:48:51 <jcreigh> sjanssen: I think printf is handy, for, eg, in my case printf("0x%04X: 0x%08X\n", ip, opcode); How is that terrible?
19:49:10 <Pseudonym> jcreigh: It's not type safe.
19:49:11 <sorear> it's C's pathetic attempt at an EDSL
19:49:19 <jcreigh> Pseudonym: yeah, well, gcc typechecks it for you.
19:49:19 <sjanssen> jcreigh: the formatting aspect is nice, but where are the types?
19:49:21 <Pseudonym> And it's not terribly efficient, either.
19:49:28 <Pseudonym> sfio!
19:49:43 <sorear> @vera sfio
19:49:45 <lambdabot> No match for "sfio".
19:49:45 <dibblego> is sfio an acronym or a noise that Pseudonym just made?
19:49:47 <LoganCapaldo> @where+ Wadler's Law http://www.informatik.uni-kiel.de/~curry/listarchive/0017.html
19:49:48 <lambdabot> Done.
19:49:54 <LoganCapaldo> @where Wadler's Law
19:49:54 <lambdabot> Law http://www.informatik.uni-kiel.de/~curry/listarchive/0017.html
19:49:59 <LoganCapaldo> erm
19:50:08 <sjanssen> jcreigh: and printf specific checking/optimizations are hacks on top of hacks
19:50:18 <Pseudonym> It is an acronym.
19:50:20 <LoganCapaldo> @where- Wadler's
19:50:20 <lambdabot> Maybe you meant: where where+
19:50:30 <LoganCapaldo> Oh I can't delete?
19:50:32 <LoganCapaldo> Ah well
19:50:36 <Pseudonym> http://www.research.att.com/~gsf/download/ref/sfio/sfio-fmt.pdf
19:50:43 <LoganCapaldo> we'l all just have to suffer :)
19:50:52 <sorear> LoganCapaldo: submit a patch to State/where :)
19:51:12 <sjanssen> sorear: isn't that a binary/gzipped file now?
19:53:23 <sjanssen> in which case, I wish LoganCapaldo the best of luck in fashioning a patch :)
19:53:44 <dons> there's a better page on Wadler's Law on the haskell.org wiki
19:54:16 <LoganCapaldo> dons: I'd happily change it if I could <g>
19:56:12 <jcreigh> <shrug> I don't disagree with any specific point. But if you happen to be coding in C(++) with gcc, there's a typechecked version of printf() that you can use right now, regardless of how ugly the underlying code is.
19:57:08 <jcreigh> varargs is, of course, a bad idea to start with. Get it wrong, kiss the stack goodbye...
19:58:34 <SamB> unless you have dependant typing
19:59:56 <jcreigh> SamB: hmm? What's that? (if that was indeed directed at me)
20:00:23 <SamB> varargs is okay with dependant typing
20:04:26 <sorear> jcreigh: only with pascal calling
20:04:40 <sorear> jcreigh: with ccall, get it wrong, get garbage
20:05:46 <allbery_b> well, get it wrong and write to it and kiss who-knows-what goodbye (e.g. pointers)
20:05:58 <allbery_b> I don't recall if there's v* versions of the scanf() family
20:06:54 <LoganCapaldo> allbery_b: there is on my machine fwiw
20:07:48 <allbery_b> wait, even regular scanf is varargs, never mind v*scanf.
20:08:19 <allbery_b> of course, I've been avoiding scanf() for years anyway; if the data isn't in the format you expect, you lose
20:08:31 <SamB> yeah
20:08:40 <sorear> allbery_b: varargs is read only
20:08:44 <SamB> thats what they always say in ##c, too
20:08:56 <allbery_b> sorear: yes, it is, but you may pass pointers which get written *through*
20:08:59 <sorear> scanf ("%d", my_var);  /* no such trick */
20:09:06 <allbery_b> which is a coredump waiting to happen
20:09:46 <allbery_b> int my_var; scanf("%f", &my_var); /* what just got trashed? */
20:10:45 <benomatic> does haskell (or any other technique) offer anthing near the simplicity and compactness of sscanf tho?
20:11:04 <sorear> allbery_b: nothing, because on 98% of PCs float and int are the same size!
20:11:25 <allbery_b> sorear: but %f expects a (double *)
20:11:26 <sorear> allbery_b: --> complacency --> 50th user --> catastrophic failure
20:11:37 <bd_> benomatic: read?
20:11:40 <allbery_b> float is %hf or something like that IIRC
20:11:52 <sorear> allbery_b: *gag*
20:12:02 <sm> why would I get : /usr/local/lib/ghc-6.7/HSunix.o: unknown symbol `lstat' ghc-6.7: unable to load package `unix-1.0'
20:12:05 <sorear> <-- no longer a C programmer, and proud of it
20:12:09 <allbery_b> the ""f" means "fixed deciimal", vs. %e exponential format
20:12:11 <sorear> sm: you need -fvia-C
20:12:30 <sm> I see, thx
20:12:32 <benomatic> can u use read to convert and assign a la "%d %d %d %x"?
20:12:38 <allbery_b> sm: glibc does strange things with the stat symbols
20:12:51 <sm> what's a robust platform-agnostic way to getHomeDirectory ?
20:12:52 <sorear> sm: http://hackage.haskell.org/trac/ghc/ticket/1086
20:12:54 <lambdabot> Title: #1086 (unix package cannot be compiled with -fasm, due to lstat()) - GHC - Trac
20:12:57 <allbery_b> if you use -fvia-C the C include files deal with it; ;from assembler, you lose
20:13:14 <SamB> benomatic: we could use type hackery to make it let you do that if you use the right type
20:13:32 <SamB> where the right type would be really darn ugly
20:13:40 <benomatic> heh
20:13:40 <sm> allbery_b: this is for the tildeExpand fn you kindly gave me
20:14:06 <allbery_b> reads can do that without too much trouble, and with better error handling than scanf gives you if the data are wrong (scanf just sillently stops filling in values)
20:14:20 <sorear> of course, before 6.7 -fvia-C was pretty much the default, so noone noticed
20:14:22 <benomatic> i don't like writing simple parsers in C, but do it often enough to appreciate sscanf and strtok
20:14:36 <allbery_b> it worked for me, but I have freebsd and osx which don't have the stat problem glibc does
20:14:56 * allbery_b hates strtok, actually
20:15:04 <allbery_b> destructive string lparsing, faugh
20:15:15 <jcreigh> it's not thread-safe either, is it?
20:15:18 <Pseudonym> No.
20:15:21 <allbery_b> no, no it is not
20:15:24 <sm> hmm.. getHomeDirectory worked there in ghci..
20:15:25 <allbery_b> not even remotely
20:15:27 * sorear has learned to hate asciz
20:15:39 <Pseudonym> But strtok_r isn't necessarily any better.
20:15:45 <allbery_b> that whole destructive modification of the  source string thing
20:15:50 * benomatic learned to hate threads instead
20:15:57 <allbery_b> writes NULs into the string at token delimiters
20:16:01 <allbery_b> yak
20:16:08 <Pseudonym> Really, the problem there isn't strtok(), but C strings.
20:16:21 <benomatic> that's a fair assessment.
20:16:21 <Pseudonym> C "strings" aren't really strings.  At best they're a building block to build real strings out of.
20:16:48 <jcreigh> C isn't really a language. At best, it's a building block to build a real language out of.
20:16:57 <Pseudonym> C is adequate for implementing Unix.
20:17:05 <allbery_b> and even there, cmm is better
20:17:12 <Pseudonym> jcreigh: That's true of most languages.
20:17:13 <Nafai> cmm?
20:17:23 <sorear> Nafai: c--
20:17:32 <allbery_b> "c--" a saner subset of C.  I thnk ghc uses it internally
20:17:43 <Pseudonym> Ideally, a language should be a system for writing domain-specific abstractions in, and then using them to build programs.
20:17:47 <sorear> almost a subset
20:17:48 <Korollary> Can you feed c-- to ghc to produce executables?
20:17:55 <Pseudonym> Programming language == DSL framework.
20:18:08 <Nafai> How much of GHC is C and how much is Haskell?
20:18:32 <sorear> Korollary: Cmm (the GHC intermediate language) is very closely related to, but subtly different from, C--.
20:18:48 <Korollary> sorear: so, can you feed cmm_ghc to ghc?
20:18:48 <sorear> IIRC Cmm doesn't have function arguments, for instance.
20:19:05 <sorear> Korollary: -package GHC ?
20:19:30 <Korollary> sorear: what does that do?
20:19:45 <sorear> Korollary: yes, much of the GHC RTS is written in textual Cmm which is read by GHC
20:19:45 <Korollary> I thought we were talking about different input formats
20:19:58 <LoganCapaldo> No function arguments? So it's asm with loops?
20:20:40 <Gwern> so I've been wondering something. why doesn't haskell allow implicit type coercions w/r/t to numbers (like with scheme)? I find it really annoying to be told expecting a double instead of an int. does it Just Not Work with the type system? (assuming I am correct you must be explicit about such conversions)
20:21:35 <allbery_b> it works with literals.  otherwise, no, one of the points of a strict type system is no automatic coercion
20:21:40 <sorear> Gwern: it could work but it would be very ambiguous naively implemented
20:22:06 <sorear> (2 + 2 :: Double) -- does that coerce before or after adding?
20:22:19 <Gwern> sorear: you mean it could be ambiguous if you produce an int, which gets converted to a double, and then later on passes to a function expecting an int?
20:22:20 <jcreigh> Gwern: oh, I'm sure the type system could be made to do it, but Integers and Doubles aren't the same.
20:22:24 <Gwern> I was thinking about it myself
20:22:25 <siti> sorear: before
20:23:01 <Pseudonym> siti: So if x :: Integer and y :: Integer, x+y :: Double should convert to Double before adding?
20:23:19 <allbery_b> doesn't that parse as 2 + (2 :: Double), forcing the second and then determining the first via the type of (+) applied to 2::Double?
20:23:25 <siti> I think that would be a type error
20:23:25 <Pseudonym> Integer, of course, being an arbitrary-precision integer.
20:23:40 <Pseudonym> siti: How would you express that?
20:23:53 <allbery_b> but even if it applies Double to (2 + 2) it still infers types via the signature of (+) before evaluation
20:23:55 <LoganCapaldo> The coercions should be lazy
20:24:02 <sorear> Pseudonym: IIRC C only does conversions that are guaranteed to be lossless - Int -> Double but not Long -> Double
20:24:13 <siti> ((5 :: Integer) + (4 :: Integer)) :: Double
20:24:15 <Gwern> LoganCapaldo: man, that's a haskeller's answer to everything. "make it more lazy"
20:24:19 <siti> >((5 :: Integer) + (4 :: Integer)) :: Double
20:24:24 <siti> hmm
20:24:26 <allbery_b> space
20:24:29 <siti> ok
20:24:33 <siti> > ((5 :: Integer) + (4 :: Integer)) :: Double
20:24:35 <allbery_b> "> " is the command
20:24:37 <lambdabot>  Couldn't match `Double' against `Integer'
20:24:39 <allbery_b> the space is mandatory
20:24:42 <siti> see :p
20:24:44 <LoganCapaldo> Gwern: yes put off the problem until later ;)
20:24:48 <Pseudonym> sorear: But in C, you know the types of the arguments.
20:24:51 <Korollary> I thought C assumed string literals were doubles and coerced them to ints.
20:24:56 <Korollary> err number literals
20:25:01 <araujo> > 2 + 2.0
20:25:04 <lambdabot>  4.0
20:25:12 <siti> > (fromIntegral ((5 :: Integer) + (4 :: Integer))) :: Double
20:25:13 <lambdabot>  9.0
20:25:22 <araujo> > fromRational 2
20:25:23 <lambdabot>  2.0
20:25:23 <Korollary> but, this is not about literals, so forget it.
20:25:55 <LoganCapaldo> @type let a = 2 in (a + (1 :: Integer), a + 3.4)
20:25:56 <lambdabot>     No instance for (Fractional Integer)
20:25:57 <lambdabot>       arising from the literal `3.4' at <interactive>:1:38-40
20:25:57 <sorear> Is @remembering typos legit?
20:26:11 <Korollary> You can invent a scheme, but then the user will have to know the scheme. It's the precedence versus prefix problem expressed in another way.
20:26:22 <LoganCapaldo> @type let a = 2 in (a + 1, a + 3.4)
20:26:24 <lambdabot> forall a. (Fractional a) => (a, a)
20:26:29 <LoganCapaldo> drat
20:26:42 <Pseudonym> You can finesse the problem with subtyping, but HM + subtyping is undecidable IIRC.
20:26:52 <Gwern> HM?
20:26:54 <LoganCapaldo> I thought that would work
20:26:57 <Gwern> hedly-milner or whatever?
20:26:59 <Pseudonym> Hindley-Milner.
20:27:01 <Pseudonym> Yeah.
20:27:07 <Gwern> och. I was close. :(
20:27:10 <allbery_b> @type let a :: Num r => r; a = 2 in (a + 1, a + 3.4)
20:27:12 <lambdabot> Num r => r; a = 2 in (a + 1, a + 3.4) :: forall r r1. (Fractional r1, Num r) => (r, r1)
20:27:15 <LoganCapaldo> ?let two = 2
20:27:16 <lambdabot> Defined.
20:27:30 <sorear> wow, nice type :)
20:27:33 <allbery_b> monomorphism restriction strikes again?
20:27:39 <LoganCapaldo> allbery_b: yeah that was the effect I was going for :)
20:27:45 <LoganCapaldo> closer anyway
20:27:49 <Pseudonym> In fact, it's kinda rare that you need coercion, and when you do, it can be hidden inside an abstraction.
20:28:11 <Pseudonym> The notable exception is generic numeric programming.
20:28:13 <LoganCapaldo> @type (two + 1, two + 3.4)
20:28:15 <lambdabot> Not in scope: `two'
20:28:15 <lambdabot>  
20:28:15 <lambdabot> <interactive>:1:10: Not in scope: `two'
20:28:29 <allbery_b>  @tyope still doesn't do @let
20:28:29 <LoganCapaldo> @type (L.two + 1, L.two + 3.4)
20:28:30 <sorear> LoganCapaldo: crash the bot first
20:28:31 <lambdabot> Couldn't find qualified module.
20:28:40 <LoganCapaldo> Oh
20:28:54 <sorear> > (two + (1 :: Int), two + 3.4)
20:28:55 <lambdabot>  Couldn't match `Integer' against `Int'
20:28:59 <Korollary> I don't think you ever *need* coercion except for pressing fewer keys.
20:29:22 * allbery_b suspects this is the monomorphism restriction rearing its ugly head
20:29:37 <sorear> yeah, if key count was a non issue I'd program in raw System FC
20:29:37 <Pseudonym> You don't need _implicit_ coercion except for pressing fewer keys.
20:29:46 <araujo> coercion is too overrated
20:29:46 <Pseudonym> But occasionally you need explicit coercion.
20:29:54 <Korollary> right.
20:30:07 <Pseudonym> And when you do, it's almost always a good thing to hide it behind an abstraction.
20:30:13 <allbery_b> which is why I tossed in the type
20:30:39 <Korollary> I am not sure if it's being abstracted away. You know that it's happening.
20:34:07 <dmead> hey peoples
20:34:13 <sorear> hiya dmead!
20:34:25 <sorear> how's halp?
20:34:25 <dmead> can someone give me a rule of thumb for when to choose a tuple over  curried form?
20:34:31 <dmead> peachy
20:34:39 <dmead> learning predicate logic atm and cleaning up my code
20:34:48 <sorear> when the objects are easy to mix up
20:35:05 <sorear> like coordinates should usually be curried
20:35:11 <sorear> s/curried/tupled/
20:35:43 <dmead> hmm
20:35:50 <sorear> but when you tuple things, think if a named data type would be better
20:36:18 <dmead> hmm alright
20:36:19 <monochrom> In Haskell try to curry.  In MLs try to tuple.
20:36:21 <dmead> i'm just thinking
20:36:50 <dmead> i've got alot of recursive functions that have a tuple like (item, list)
20:36:57 <dmead> i wonder if using a fold might be better
20:37:02 <sorear> haskell has better support now for uncurried functions (see the Control.Arrow combinators), but you're still going to have an easier time combining curried function
20:37:19 <dibblego> ?hoogle Ord a => [a] -> a
20:37:20 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
20:37:20 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
20:37:20 <lambdabot> Prelude.head :: [a] -> a
20:37:50 <sorear> folds (esp. foldr) are better than explicit recursion except with very complicated functions
20:38:00 <sorear> they're shorter and harder to mess up
20:38:07 <jcreigh> dmead: most recursion turns into folds, if you stare at them long enough.
20:38:07 <dmead> right right
20:38:23 <sorear> foldr w/o general recursion *cannot* induce infinite loops
20:38:23 <dmead> i've got some complicated shit going on as well
20:38:39 <dmead> right right
20:39:24 <LoganCapaldo> sorear, it can't?
20:39:29 <sorear> of course that means foldr isn't infinitely useful, by the standard Church/Turing argument
20:39:34 <LoganCapaldo> > foldr (+) 0 [1..[
20:39:35 <lambdabot>  Parse error
20:39:38 <LoganCapaldo> > foldr (+) 0 [1..]
20:39:40 <lambdabot>  Exception: stack overflow
20:39:49 <jcreigh> LoganCapaldo: see? It terminated. :)
20:40:04 <sorear> LoganCapaldo: now write enumFrom w/o fix  :)
20:40:19 <dmead> whats the version of fold with an acculator?
20:40:32 <sorear> fold
20:40:46 <sorear> a fold without an accumulator is a map
20:40:52 <dmead> ah
20:40:54 <dmead> hmm
20:40:54 <dmead> well
20:41:07 <dmead> for a good bit of my prover
20:41:26 <dmead> the structure of the list changes in every recursive call
20:41:28 <dmead> like
20:41:34 <LoganCapaldo> a fold with an accumlator where the accumlator happens to build a list is a map too :)
20:41:36 <dmead> x:y:z:xs
20:41:44 <sorear> foldl' does left to right, and is tail recursive, but loses the performance advantages of laziness
20:41:50 <dmead> becomes x:z:y:xs in the recursive call
20:41:58 <dmead> hmm
20:42:03 <sorear> well, that's not a fold
20:42:13 <dmead> yea
20:42:19 <dmead> you can't change the list structure like that i guess
20:42:25 <sorear> it might be some other recursion pattern though ...
20:42:48 <sorear> dmead: yea, foldr only does structural induction. no GR funny business.
20:43:00 <dmead> GR?
20:43:06 <monochrom> general relativity
20:43:14 <sorear> general recursion
20:43:29 <dmead> =P
20:47:48 <chessguy> !paste
20:47:48 <hpaste> Haskell paste bin: http://hpaste.org/
20:49:50 <LoganCapaldo> Couldn't you have a foldr (\f x -> f x) f xs where f was a state machine and transistion function? I guess you still couldn't do any funny business
20:50:51 <LoganCapaldo> (or any funny business that occured will all happen inside of f anyway)
20:58:42 <dmead> @hoogle fold
20:58:42 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
20:58:42 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
20:58:42 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
20:59:25 <dmead> hmm
20:59:27 <sorear> there are three list folds, foldl, foldl', and foldr
20:59:37 <dmead> folds?
20:59:53 <dmead> @hoogle folds
20:59:54 <lambdabot> No matches found
20:59:57 <dmead> oh
20:59:58 <dmead> lol
21:00:07 <sorear> foldr is normally prefered because it is very lazy and corresponds to the structure of the list
21:00:11 <sorear> @src foldr
21:00:11 <lambdabot> foldr k z xs = go xs
21:00:11 <lambdabot>     where go []     = z
21:00:11 <lambdabot>           go (y:ys) = y `k` go ys
21:00:28 <sorear> simple structural recursion
21:00:47 <sorear> foldl' is used with strict, usually primitive, operations
21:00:47 <dmead> hmm
21:00:50 <sorear> @src foldl'
21:00:51 <lambdabot> foldl' f a []     = a
21:00:51 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:01:03 <jcreigh> foldl' is in Data.List, not Prelude, BTW. Took me a while to find that one.
21:01:09 <dmead> so i've got a bool function, and item and a list of items
21:01:17 <siti> sooo many folds !
21:01:20 <dmead> !
21:01:24 <sorear> note that foldl' is tail recursive
21:01:29 <jcreigh> paper airplance contest!
21:01:34 <jcreigh> *airplane
21:01:38 <sorear> usually, that doesn't matter in haskell
21:01:45 <dmead> hmm
21:01:51 <sorear> > foldl' (+) 0 [1..1000000]
21:01:51 <dmead> so...
21:01:53 <lambdabot>  500000500000
21:02:00 <sorear> > foldr (+) 0 [1..1000000]
21:02:01 <lambdabot>  Exception: stack overflow
21:02:02 <dmead> hmm
21:02:47 <dmead> given an int and a list of ints
21:03:06 <dmead> how would you use fold to figure out if that int is a member of a list
21:03:20 <dmead> ie
21:03:27 <dmead> fold member x xs
21:03:27 <dibblego> why is foldl' considered tail recursive?
21:03:34 <dmead> would that be right?
21:03:37 <dibblego> because the last operation is 'seq'?
21:04:51 <monochrom> fold (||) (map (member x) xs)
21:05:14 <sorear> dibblego: seq is weird
21:05:22 <dibblego> sorear, I'm beginning to think that
21:05:35 <sorear> dibblego: in scheme terms, in (seq x y) y is in tail position
21:05:43 <monochrom> what is "tail recursive"?
21:06:09 <glguy> result of the function call is the result of the recursive call
21:06:13 <sorear> monochrom: iterative, running in constant space
21:06:29 <sorear> insert "capable of" in an appropriate place :)
21:06:31 <jcreigh> > let isMember x xs = foldr (\y found -> (x == y) || found) False xs in isMember 5 [1..10]
21:06:34 <lambdabot>  True
21:07:03 <dibblego> is seq handled specially by the compiler?
21:07:04 <sorear> syntaxfree: dpiponi called a while ago, asking for PFP users
21:07:09 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/13/ugh-such-a-proud-display-of-sheer-irrationality/
21:07:10 <sorear> dibblego: sorta
21:07:11 <jcreigh> dibblego: yes
21:07:12 <lambdabot> Title: Ugh! Such a proud display of sheer irrationality « Data.Syntaxfree, http://tinyurl.com/25zktu
21:07:24 <dibblego> ok, that explains a lot of my misunderstanding
21:07:33 <syntaxfree> i tried to post that video directly to reddi, but the captcha system seems to be broken.
21:07:41 <syntaxfree> so i embedded it in a post with my comments.
21:07:47 <Pseudonym> (1 + sqrt 5) / 2   -- My display of irrationality.
21:08:01 <syntaxfree> hehehe
21:08:12 <syntaxfree> watch the video. it's angers me to no end.
21:08:23 <syntaxfree> I'm going to sleep now.
21:08:37 <dmead> jcreigh: thanks
21:09:19 <sorear> .b(X~.**O..*`*&^_**S****9J*B]H*P*.*J@15|**{...**i -- a typical excerpt from this amazingly clear "video"
21:09:22 <sorear> :)
21:09:36 <Pseudonym> sorear: Hey, that's a Quine in Malbolge!
21:10:17 <LoganCapaldo> jcreigh is way faster than I
21:10:23 <glguy> but she's a weather lady!
21:10:38 <LoganCapaldo> > let memberOf x xs = foldr (\e y -> if y then y else x == e) False xs in memberOf 2 [1,4,2,3]
21:10:39 <lambdabot>  True
21:10:46 <Pseudonym> Good heavens, she draws her 8's as two circles.
21:10:52 <Pseudonym> And she's a meteorology major?!
21:11:56 <dmead> mmm complex
21:12:30 <LoganCapaldo> @pl (\x xs -> foldr (\e y -> if y then y else x == e) False xs)
21:12:30 <lambdabot> flip foldr False . (flip (join if') .) . (==)
21:12:57 <LoganCapaldo> @pl (\x xs -> foldr (\e y -> y || (x == e)) False xs)
21:12:57 <lambdabot> flip foldr False . (flip (||) .) . (==)
21:13:44 <LoganCapaldo> > (flip foldr False . (flip (||) .) . (==)) 2 [1,3,4]
21:13:46 <lambdabot>  False
21:13:53 <LoganCapaldo> > (flip foldr False . (flip (||) .) . (==)) 2 [1,3,4,2]
21:13:55 <lambdabot>  True
21:14:05 <dmead> whats the . do?
21:14:10 <dmead> composition right?
21:14:20 <jcreigh> dmead: the thing that helps me is to remember that in foldr (\a b -> ...) "a" is the current element of the list, and b is the result of folding the rest of the list.
21:14:22 <LoganCapaldo> @src (.)
21:14:23 <lambdabot> (.) f g x = f (g x)
21:14:26 <glguy> Pseudonym: the two circle way is traditional engineering handwriting
21:14:27 <LoganCapaldo> ye
21:14:52 <jcreigh> > let map f = foldr (\x xs -> f x : xs) [] in map (*2) [1..10]
21:14:53 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
21:15:05 <dmead> yea mmm
21:15:14 <dmead> i don' really understand whats going on here
21:15:26 <jcreigh> "here" == my map example?
21:15:39 <dmead> yea
21:15:44 <dmead> fold example
21:15:52 <jcreigh> map defined as a fold, anyway.
21:16:11 <chessguy> heh. cute
21:16:28 <chessguy> but can you do foldr in terms of map? :)
21:16:54 <jcreigh> anyway, in the fold function, "xs" is the rest of the list, *already folded* and x is the current element.
21:17:11 <dmead> right
21:17:14 <dmead> what about the bit
21:17:38 <dmead> folr (\y found -> (x == y) || found) false xs
21:17:41 <dmead> *foldr
21:18:05 <dmead> foldr takes a function accumulator and the rest of the list?
21:18:35 <glguy> If my kids are taught "cluster methods" I'll teach them how to do it correctly though :)
21:18:58 <jcreigh> well, in that case, we're folding a list down to a Bool.
21:19:02 <LoganCapaldo> > let take n = snd . foldr (\e (n, es) -> if n == 0 then (n, es) else (n - 1, e:es)) (n, []) in take 2 [1,2,3]
21:19:04 <lambdabot>  [2,3]
21:19:14 <LoganCapaldo> lol
21:19:21 <LoganCapaldo> Shoulda used foldl
21:19:29 <jcreigh> the initial value is False (ie, if we have an empty list, whatever we have isn't a member of it.)
21:19:35 <dmead> right
21:20:01 <dmead> why are you using found instead of true?
21:20:19 <LoganCapaldo> > let take n = snd . foldl (\(n, es) e -> if n == 0 then (n, es) else (n - 1, e:es)) (n, []) in take 2 [1,2,3]
21:20:21 <lambdabot>  [2,1]
21:20:27 <jcreigh> dmead: well, "found" is whether or not the element is a member of the rest of the list.
21:20:53 <LoganCapaldo> > let take n = reverse . snd . foldl (\(n, es) e -> if n == 0 then (n, es) else (n - 1, e:es)) (n, []) in take 2 [1,2,3]
21:20:55 <lambdabot>  [1,2]
21:21:05 <LoganCapaldo> yay
21:21:39 <LoganCapaldo> > let take n = reverse . snd . foldl (\(n, es) e -> if n == 0 then (n, es) else (n - 1, e:es)) (n, []) in take 2 [1..]
21:21:46 <lambdabot> Terminated
21:21:49 <jcreigh> dmead: so we say "if the current element is the element we're looking for *or* the element we're looking for is in the rest of the list, then the element we're looking for is in the list. Otherwise, it's not."
21:21:54 <LoganCapaldo> drat
21:21:59 <jcreigh> (x == y) || found
21:22:09 <jcreigh> Haskell is so much more concise than English.
21:22:15 <dmead> hehe yea
21:22:17 <LoganCapaldo> oh because of the reverse
21:22:19 <dmead> ?src foldr
21:22:19 <lambdabot> foldr k z xs = go xs
21:22:19 <lambdabot>     where go []     = z
21:22:19 <lambdabot>           go (y:ys) = y `k` go ys
21:22:31 <LoganCapaldo> no wait thats not it
21:22:38 <LoganCapaldo> mmm
21:23:11 <jcreigh> foldr f z [1,2,3] = (1 `f` (2 `f` (3 `f` z))
21:24:20 <jcreigh> foldr is the basic pattern of recursion. Because we're forever writing functions like:
21:24:23 <jcreigh> sum [] = 0
21:24:28 <jcreigh> sum (x:xs) = x + sum xs
21:25:00 <jcreigh> The Smart FP Guys thought, hey, let's just abstract away the common "base case + general case" pattern and say "foldr (+) 0 xs"
21:25:40 <dmead> hmm
21:25:44 <jcreigh> dmead: is any of this making sense?
21:25:47 <dmead> yes
21:26:07 <dmead> it's just hard to look at the fold syntax and understand whats happening
21:26:36 <jcreigh> yeah.
21:26:41 <dmead> wait..
21:27:09 <jcreigh> hmm?
21:27:22 <dmead> foldr f z [1,2,3] = (f  1 (f 2 (f 3 z))
21:27:24 <dmead> yea?
21:27:38 <jcreigh> yeah
21:28:46 <dmead> err
21:28:50 <dmead> wai
21:28:51 <dmead> t
21:28:54 <dmead> not f 3 z
21:28:55 <dmead> isn't it
21:29:04 <LoganCapaldo> Another way to think about it is that z replaces [] and f replaces (:)
21:29:08 <dmead> foldr f z [1,2,3] = (f  1 (f 2 (f z 3))
21:29:08 <jcreigh> no, that's right.
21:29:17 <jcreigh> dmead: no, f 3 z
21:29:26 <LoganCapaldo> No you were right the first time
21:29:55 <jcreigh> @type foldr
21:30:01 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
21:30:40 <jcreigh> the second argument to the foldr has to be the result of folding (or the initial value) because the list elements and the initial value don't have to be the same type.
21:30:53 <jcreigh> "to the folding function", sorry.
21:30:58 <LoganCapaldo> > foldr (:) [] [1,2,3]
21:31:01 <lambdabot>  [1,2,3]
21:31:37 <dmead> > foldr + [] [1..10]
21:31:38 <lambdabot>      The function `[]' is applied to one arguments,
21:31:38 <lambdabot>     but its type `[a]' ha...
21:31:42 <LoganCapaldo> > 1:2:3:[]
21:31:44 <lambdabot>  [1,2,3]
21:31:53 <dmead> > foldr + 0 [1..10]
21:31:54 <lambdabot>        add an instance declaration for (Num ([a1] -> (a -> b -> b) -> b -> [a...
21:32:09 <LoganCapaldo> (+)
21:32:11 <dmead> how do i eval it?
21:32:30 <dmead> > let x = foldr (+) 0 [1..10]
21:32:30 <lambdabot>  Parse error
21:32:35 <LoganCapaldo> > foldr (+) 0 [1..10]
21:32:37 <lambdabot>  55
21:32:46 <dmead> >oh
21:32:47 <dmead> (+)
21:32:54 <jcreigh> to use an infix function normally, you wrap parens around it. To use a normal function "infix-ly", you wrap backticks around it.
21:33:05 <jcreigh> > elem 5 [1..10]
21:33:06 <lambdabot>  True
21:33:10 <dmead> ah
21:33:12 <jcreigh> > 5 `elem` [1..10]
21:33:13 <lambdabot>  True
21:33:39 <jcreigh> > 2 + 2
21:33:41 <lambdabot>  4
21:33:44 <jcreigh> > (+) 2 2
21:33:46 <lambdabot>  4
21:33:51 <dmead> ahh
21:33:53 <dmead> hmm
21:34:36 <LoganCapaldo> > let operator_sections_are_fun_too = (+2) in operator_sections_are_fun_too 4
21:34:37 <lambdabot>  6
21:34:42 <dmead> oh
21:34:44 <dmead> starting to get it
21:34:48 <jcreigh> yeah
21:34:58 <glguy> http://patricklogan.blogspot.com/2007/02/misguided-road-not-to-be-travelled.html -- simply addresses the problems STM can cause when your type system isn't powerful enough to express STM
21:34:59 <jcreigh> > map (2^) [1..16]
21:35:00 <lambdabot> Title: Making it stick.: Misguided: The Road Not To Be Travelled, http://tinyurl.com/2n7gbd
21:35:00 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536]
21:35:07 <lispy> > (+1) `map` [1..10]
21:35:09 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
21:35:37 <dmead> > foldr (\x y -> x == y) [1,1,2,3]
21:35:37 <lambdabot>  Couldn't match `Bool' against `[a]'
21:35:40 <lispy> > let foo = ((+1) `map`) in foo [1..10]
21:35:42 <dmead> hmm
21:35:42 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
21:35:59 <LoganCapaldo> > let plus1_map = ((+1) `map`) in plus1_map [1,2,3]
21:36:01 <lambdabot>  [2,3,4]
21:36:05 <LoganCapaldo> nvm
21:36:10 <LoganCapaldo> too slow I am
21:36:20 <jcreigh> talk like yoda you do
21:36:29 <LoganCapaldo> dmead: You need an initial value
21:37:05 <LoganCapaldo> Also that is unlikely to type check unless you make it a list of Bools
21:37:18 <dmead> > let repeates x:xs = foldr (\x y -> x == y) xs in repeates [1..10] ++ [10..20]
21:37:18 <lambdabot>  Parse error in pattern
21:37:24 <dmead> aarrr
21:37:39 <LoganCapaldo> (x:xs)
21:37:41 <int-e> glguy: the fun thing is that starvation isn't even mentioned as a problem in the article
21:37:45 <dmead> err
21:37:52 <int-e> glguy: (although some comments bring it up)
21:37:52 <LoganCapaldo> You still need an initial value before the xs
21:38:08 <LoganCapaldo> foldr (\x y -> x == y) SOMETHING_HERE xs
21:38:09 <dmead> > let repeates y xs = foldr (\x y -> x == y) xs in repeates 2 [1..10] ++ [10..20]
21:38:10 <lambdabot>      Expecting a function type, but found `[a]'
21:38:10 <lambdabot>       Expected type: [a]
21:38:10 <lambdabot>     ...
21:38:15 <dmead> oh
21:38:42 <dmead> > let repeates y xs = foldr (\x y -> x == y)  y xs in repeates 2 [1..10] ++ [10..20]
21:38:43 <lambdabot>  Couldn't match `[a]' against `Bool'
21:38:45 <glguy> int-e: i dont know what that business about sprinkled atomicly was
21:38:53 <LoganCapaldo> @type foldr1
21:38:54 <dmead> > let repeates y xs = foldr (\x y -> x == y)  2 xs in repeates 2 [1..10] ++ [10..20]
21:38:54 <lambdabot>  Couldn't match `[a]' against `Bool'
21:38:55 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
21:39:16 <jcreigh> @type foldr
21:39:17 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
21:40:02 * LoganCapaldo been up too late
21:40:06 <jcreigh> dmead: the problem is that you're trying to do Int == Bool
21:40:09 <LoganCapaldo> Leave you all now I must
21:40:14 <jcreigh> LoganCapaldo: heh
21:40:20 <jcreigh> LoganCapaldo: goodnight
21:40:23 <int-e> glguy: I don't think that really applies to Haskell
21:40:29 <LoganCapaldo> jcreigh: night
21:40:54 <glguy> int-e: I don't see how it's even worth discussing STM if you can't express it at the type level
21:40:59 <dmead> o0
21:40:59 <dmead> i don
21:41:07 <glguy> that's a huge part of the composability
21:41:08 <dmead> i don't see how x or y is a bool
21:41:32 <int-e> glguy: he's right at one point though, in my opinion, namely that the amount of shared state should be minimized. but that's not a problem of STM.
21:41:35 <LoganCapaldo> @type (\x y -> x == y)
21:41:37 <lambdabot> forall a. (Eq a) => a -> a -> Bool
21:41:44 <glguy> int-e: exactly
21:41:48 <jcreigh> dmead: well, the result of your fold is Bool (becuase you're using ==), and y is the result of folding the rest of the list. So y has to be a Bool.
21:41:59 <dmead> oh
21:42:35 <chessguy> what happens if you want to stack three monads instead of two? would you use nested monad transformers?
21:43:09 <dmead> > let repeates y xs = foldr (\x y -> x == y)  False xs in repeates 2 [1..10] ++ [10..20]
21:43:09 <lambdabot>  Couldn't match `[a]' against `Bool'
21:43:12 <dmead> uf kj dh
21:43:28 <glguy> chessguy: a monad transformer creates a monad, which can be transformed
21:44:05 <chessguy> so, essentially, yes
21:44:29 <glguy> non-transformer monads except for IO, STM, Identity are just transformers on Identity basically
21:45:08 <glguy> (ST)
21:45:27 <jcreigh> dmead: what is "repeates" supposed to do?
21:45:37 <chessguy> so what are IO and STM transformers on?
21:45:40 <Pseudonym> Aynyone know of any good differential geometry texts/course notes online?
21:45:47 <glguy> chessguy: they can't be transformers
21:46:08 <chessguy> bummer
21:46:11 <chessguy> sucks to be them
21:46:12 <dmead> find a duplicate of item x in list L
21:46:26 <dmead> err
21:46:26 <dmead> wait
21:46:30 <dmead> it's just wrong
21:46:40 <dmead> on so many levels!
21:46:44 <jcreigh> heh
21:46:46 <chessguy> so, they have to be at the bottom of the monad stack?
21:46:53 <sjanssen> chessguy: correct
21:46:59 <glguy> chessguy: yes, because they hide actual mutabilty
21:47:17 <Pseudonym> You can fix that somewhat by combining monads differently.
21:47:25 <chessguy> so you can't use both IO and STM?
21:47:28 <Pseudonym> There's a huge conceptual simplicity to using transformers, though.
21:47:33 <Pseudonym> chessguy: Definitely not!
21:47:34 <glguy> right, IO can't be rolled back
21:47:38 <Pseudonym> That's the point of STM!
21:47:39 <sjanssen> chessguy: yes, that is one of the major features of STM
21:47:46 <glguy> Whaa!!
21:47:53 <chessguy> i don't have a clue what STM is
21:47:57 * chessguy looks it up
21:47:57 <Pseudonym> But there's no reason in principle why you couldn't, say, use a combined IO and ST.
21:48:07 <glguy> software transactional memory
21:48:14 <chessguy> oh right, for concurrency, right?
21:48:14 <glguy> Pseudonym: stToIo
21:48:20 <Pseudonym> glguy: Even so.
21:48:31 <chessguy> Pseudonym, wait, what?
21:48:40 <chessguy> combined how?
21:48:44 <dibblego> I wish my operating system states could be rolled back
21:48:55 <Pseudonym> Well, for example, so you didn't need separate STArrays and IOArrays.
21:49:05 <lispy> dibblego: i wish RL mistakes could be rolled back :)
21:49:08 <sjanssen> I wish real world states could be rolled back
21:49:10 <glguy> dibblego: it would be unnerving to see document editors jump back in time :)
21:49:19 <Pseudonym> I wish my printer would take back the paper and lift the toner off.
21:49:37 <chessguy> sigh. i was starting to get it until Pseudonym muddied the waters
21:49:37 <jcreigh> oh, I'm sure there's some clean, elegant research OS that nobody actually uses that can do that.
21:49:55 <Pseudonym> chessguy: ST also isn't a transformer.
21:49:56 <dibblego> the pure functional file system
21:49:59 <glguy> chessguy: because I simplified it more than he wanted me to
21:50:01 <Pseudonym> And can't be.
21:50:13 <chessguy> Pseudonym, yes, we covered that
21:50:17 <Pseudonym> Right.
21:50:17 <chessguy> ditto for IO
21:50:27 <Pseudonym> But it would make sense to have ST and IO operations in the one monad.
21:50:27 <chessguy> so both have to be at the bottom of the stack
21:50:41 <Pseudonym> In a way that wouldn't make sense for STM and IO.
21:51:02 <chessguy> oh wait, so there's ST, STM *and* IO
21:51:13 <Pseudonym> Yes./
21:51:17 <chessguy> and ST and IO can combine, but STM and IO can't?
21:51:17 <Pseudonym> ST is just State,.
21:51:24 <Pseudonym> No.  They can't.
21:51:28 <glguy> ST is the mutable array and reference subset of IO
21:51:30 <Pseudonym> But combining ST and IO at least makes sernse.
21:51:39 <bd_> chessguy: ST is like a limited form of IO, which you can (with restrictions of course) use outside of IO
21:51:55 <bd_> chessguy: But since it's a subset of IO, there's a function ST RealWorld v -> IO v
21:52:08 <bd_> which of course lets STRefs leak - but that's okay, since hte IO monad will give sequencing
21:52:09 <sjanssen> chessguy: Pseudonym is saying that one great unified framework could express the similarities between ST and IO -- but that isn't really how it works today
21:52:14 <glguy> (though, ironically? ST is generalized IO)
21:52:17 <Pseudonym> Right.
21:52:25 <chessguy> hmm. i think i shouldn't have asked :)
21:52:27 <bd_> sjanssen: print :: Show t => t -> ST RealWorld ()? :)
21:52:47 <sjanssen> bd_: someday, maybe?
21:52:57 <chessguy> anyway, what i really wanted to know was about stacking more than two monads, and that question was answered
21:52:59 <chessguy> so, thanks
21:53:01 <chessguy> i think :)
21:53:05 <bd_> @hoogle STRef RealWorld a -> IORef a
21:53:06 <hooby> hello? i have a question about a homework thing im doing
21:53:06 <lambdabot> No matches, try a more general search
21:53:13 <sjanssen> or we could lift all the common IO functions to MonadIO, and instance MonadIO (ST RealWorld)
21:53:26 <glguy> :t stToIO
21:53:28 <lambdabot> Not in scope: `stToIO'
21:53:37 <glguy> ?hoogle stToIO
21:53:37 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
21:53:39 <sjanssen> hooby: feel free to ask
21:53:44 <Pseudonym> ?hoogle ioToST
21:53:45 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
21:53:45 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
21:54:06 <Pseudonym> ?hoogle IO a -> ST RealWorld a
21:54:06 <lambdabot> No matches, try a more general search
21:54:16 <bd_> hooby: What's your question? :)
21:54:29 <hooby> thanks, sjanssen! well, i was looking at chessguy's removeFST program
21:54:43 <hooby> im new to haskell btw
21:54:47 <chessguy> my who-what program?
21:54:55 <bd_> http://paste.lisp.org/display/27057 this one?
21:55:00 <hooby> yup
21:55:05 <glguy> !paste
21:55:05 <hpaste> Haskell paste bin: http://hpaste.org/
21:55:14 <bd_> long time ago... :)
21:55:16 <chessguy> oh my
21:55:20 <chessguy> that was a long time ago
21:55:29 <hooby> i hope its a fond memory
21:55:30 <glguy> before you knew of "delete"?
21:55:35 <bd_> That paste suffers from a clear lack of generality :)
21:55:39 <chessguy> i don't even remember it :)
21:55:56 <hooby> well, i think it works
21:56:03 <chessguy> heh
21:56:05 <chessguy> how embarrassing
21:56:19 <hooby> but i dont really understand the last two lines
21:56:32 <chessguy> hooby, you really shouldn't study such awful code
21:56:38 <bd_> @src delete
21:56:39 <lambdabot> delete = deleteBy (==)
21:56:42 <bd_> @src deleteBy
21:56:42 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:56:45 <bd_> tsk
21:56:54 <kolmodin> morning
21:56:59 <hooby> well i just googled removeFST
21:57:01 <glguy> ?fptools Data.List
21:57:01 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
21:57:19 <glguy> deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]
21:57:19 <glguy> deleteBy _  _ []        = []
21:57:20 <glguy> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
21:57:21 <chessguy> hooby, anyway, the idea of the last two lines is this:
21:57:38 <chessguy> for a list with at least one element
21:58:04 <chessguy> if the first element matches what we're looking for, then we just simply return the rest of the list, without that element
21:58:39 <chessguy> if it doesn't, then the first element of the list stays, and we have to recursively remove the first element in the rest of the list that matches what we're looking for
21:59:21 <glguy> > let removeFST x xs = foldr (\this continue -> if null this || head this == x then tail this else continue) (tails xs) in removeFST 3 [1..10]
21:59:22 <lambdabot>   add an instance declaration for (Num [a])
21:59:40 <glguy> > let removeFST x xs = foldr (\this continue -> if null this || head this == x then tail this else continue) [] (tails xs) in removeFST 3 [1..10]
21:59:42 <lambdabot>  [4,5,6,7,8,9,10]
21:59:49 <glguy> oops :)
22:00:12 <chessguy> hooby, does that make any sense?
22:01:01 <lispy> glguy: neat
22:01:20 <sjanssen> glguy: the One True Solution to removeFst requires the para combinator :)
22:02:07 <glguy> > let removeFST x xs = foldr (\this continue -> if null this || head this == x then tail this else head x : continue) (tails xs) in removeFST 3 [1..10]
22:02:08 <hooby> the last line is still confusing
22:02:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
22:02:09 <lambdabot>       Expected...
22:02:13 <abz> ?doc Data.ByteString.Lazy
22:02:13 <lambdabot> Data.ByteString.Lazy not available
22:02:19 <abz> ?doc Data.ByteString
22:02:20 <lambdabot> Data.ByteString not available
22:02:20 <glguy> > let removeFST x xs = foldr (\this continue -> if null this || head this == x then tail this else head this : continue) (tails xs) in removeFST 3 [1..10]
22:02:21 <lambdabot>   add an instance declaration for (Num [a])
22:02:28 <chessguy> let f _ [] = []; f x (x:xs) = xs; f x (y:ys) = f ys in f 3 [1..10]
22:02:30 <glguy> > let removeFST x xs = foldr (\this continue -> if null this || head this == x then tail this else head this : continue) [] (tails xs) in removeFST 3 [1..10]
22:02:31 <chessguy> > let f _ [] = []; f x (x:xs) = xs; f x (y:ys) = f ys in f 3 [1..10]
22:02:32 <lambdabot>      Conflicting definitions for `x'
22:02:32 <lambdabot>     In the definition of `f'
22:02:32 <lambdabot>  [1,2,4,5,6,7,8,9,10]
22:02:47 <glguy> yea, i fixed it
22:03:40 <hooby> does haskell automatically take each element one at a time?
22:04:00 <chessguy> > let f _ [] = []; f x (y:ys) = if (x == y) then ys else (x:(f ys)) in f 3 [1..10]
22:04:01 <lambdabot>      Expecting a function type, but found `[a]'
22:04:01 <lambdabot>       Expected type: [a]
22:04:01 <lambdabot>     ...
22:04:40 <chessguy> hooby, i'm not sure what you mean
22:04:51 <sorear> laziness rules
22:05:56 <sjanssen> hooby: the "one element at a time" thing is handled by the (y:ys) part
22:06:03 <hooby> ah
22:06:28 <sjanssen> (y:ys) matches a list -- y is the first element, and ys is the part after the first element
22:06:34 <chessguy> the last line says "if the list has more than one element, and the first is not what we're looking for (that's the otherwise), then keep the first element of the list (y), and append the result (:) of recursively (removeFst) removing the first occurrence of what we're looking for (x) from the rest of the list (ys)"
22:06:42 <chessguy> did that get cut off?
22:07:35 <sjanssen> chessguy: your message ended with: from the rest of the list (ys)"
22:07:44 <chessguy> ok good
22:08:45 <sorear> lambdabot's log module needs @tail-last
22:08:48 <hooby> okay! i think i understand!
22:08:56 <chessguy> well, as painful as that code is to look at, it's nice to know i've learned something about haskell in the last 4 months and 2 weeks :)
22:08:56 * sorear applauds
22:08:58 <hooby> now im going to try and write a removeALL
22:09:09 <chessguy> hooby, i would challenge you to try to improve that function
22:09:31 * sorear narrowly avoided typing a 11-char removeALL
22:09:33 <chessguy> hooby, you don't have to do anything fancy with maps or foldrs or anything, just play with what's already there
22:09:58 <dufflebunk> I'm looking at a happs program and I'm seeing syntax I don't recognize:
22:10:04 <sorear> and hoogle can be useful!
22:10:08 <dufflebunk> $(inferRecordUpdaters ''MyState)
22:10:15 <sorear> @hoogle a -> [a] -> [a]
22:10:16 <lambdabot> List.intersperse :: a -> [a] -> [a]
22:10:16 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
22:10:16 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
22:10:18 <dufflebunk> Can anyonep oint me to where it's discussed?
22:10:21 <sorear> dufflebunk: that's a splice
22:10:24 <sorear> dufflebunk: TH
22:10:46 <hooby> well, this is all new to me
22:10:51 <hooby> but i'll keep that in mind
22:11:01 <chessguy> hooby, this is a good first assignment
22:11:02 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/template-haskell.html
22:11:04 <lambdabot> Title: 7.6. Template Haskell, http://tinyurl.com/29wwbz
22:11:13 <xpika> who manages haskell.org?
22:11:17 <dufflebunk> Thanks sorear
22:11:23 <sorear> shapr, iirc
22:11:27 <sorear> @wiki Haskell.org
22:11:28 <lambdabot> http://www.haskell.org/haskellwiki/Haskell.org
22:11:33 <chessguy> hooby, are you working through the book "Haskell road to programming, math and logic"?
22:12:08 <hooby> yes
22:12:20 <chessguy> ah, good book
22:12:26 <sorear> xpika: sorry
22:12:31 <xpika> ok, its yale then.
22:12:35 <chessguy> that really opened my eyes to haskell syntax and what could be done with it
22:12:43 <chessguy> though i didn't really finish the book
22:12:51 <Cale> dufflebunk: It's probably easier to understand what it means in the context of the library you're using (presumably HAppS) than to understand TH in general.
22:12:56 <hooby> cool
22:13:12 <hooby> im taking a functional programming college course
22:14:06 <chessguy> heh. consider yourself lucky. in the CS program i went through, the only acknowledgement of the existence of FP was 4 weeks of scheme
22:14:11 <sorear> dufflebunk: TH is one of the many attempts to retrofit Lisp macros on haskell.  it does a fairly good job, but like all such attempts it is doomed to look stupid.
22:14:44 <Gwern> sorear: what about liskell? that's weird enough it might work
22:14:49 <Cale> HR is sort of strange though. It doesn't quite cover enough Haskell to really be a Haskell book, and not quite enough mathematics to really be a mathematics book. It fits in somewhere though :)
22:14:52 <Gwern> and it doesn't look much stupider than lisp..
22:15:04 <dufflebunk> looks like bash
22:15:12 <chessguy> Cale, yeah, it was a nice mix for me
22:15:20 <Gwern> anyway, I'm kind of curious. has anyone else had trouble with indentation in haskell-mode for emacs?
22:15:25 <glguy> That's "more stupid", stupid ;)
22:15:46 <sorear> Gwern: it has many imprefections.  define "trouble".
22:15:50 <chessguy> any fans of genetic programming around? i have some ideas that i'd like to kick around with someone for implementing GP in haskell
22:16:07 <Gwern> sorear: it indents to the wrong level for if then else clauses, for example
22:16:28 <sorear> Gwern: it will mangle your if/then/elses, it will barf on mismatched parens, it will scramble your types on guard insertion, ...
22:16:29 <Cale> The only thing you'd really need macros for are the things which really must be done at compile time due to their very nature. Laziness gives you most of what lisp macros seem to be used for in ordinary practice.
22:16:30 <Gwern> and C-c C-l works... if you hit it twice
22:16:45 <Gwern> Cale: sounds like template haskell, imo
22:17:01 <Cale> Well, yeah, that's all that template haskell is really used for :)
22:18:07 <Cale> Things lisp macros are more commonly used for, like adding functions which behave like syntax, you get for free via laziness.
22:18:22 <Gwern> Cale: really? how does that work?
22:18:23 <sorear> Cale: part of the problem is that haskell's top level is not first class.  if it were treated as some kind of mutant arrow, and definitions could be abstracted over, and <THUNK of type [Musing], request forcing if desired>
22:18:31 <glguy> Cale, am I reading oed.com correctly (in a text browser) in that "stupid" isn't in the OED?
22:18:43 <glguy> Cale: nvm
22:18:57 <Cale> glguy: it's there
22:19:09 <glguy> Cale: I'm not used to elinks yet :)
22:19:14 <sorear> page 806 of my 3rd ed AHD
22:19:19 <Cale> Gwern: basically, because the outermost things are evaluated first -- that's what laziness means
22:19:53 <sorear> wow, I can flip to the right page in a paper dictionary faster than I can type into google
22:19:55 <Cale> Gwern: so those outermost things (your defined syntax) have absolute ability to recombine the inner things in any way they want before further evaluation
22:19:58 <dons> does anyone think its dangerous to expose the writings of Oleg to the masses, via reddit ?  :-)
22:20:11 <Cale> dons: I'm not sure they're ready :)
22:20:11 <Pseudonym> "A mathematician may say anything he pleases, but a physicist must be at least partially sane."  -- J. Willard Gibbs
22:20:14 <siti> oleg?
22:20:19 <glguy> > let if' b t e = if b then t else e in if' False (error "Don't eval this") "macros for free"
22:20:21 <lambdabot>  "macros for free"
22:20:22 <dons> ?quote oleg
22:20:23 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
22:20:24 <Pseudonym> You have to understand that Gibbs lived in an era before string theory.
22:20:31 <dons> ?quote oleg
22:20:32 <lambdabot> emu says: olegarithmic
22:20:35 <dons> ?quote oleg
22:20:36 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
22:20:37 <Cale> Pseudonym: hehe
22:20:42 <sorear> dons: "it will rain shoes when the masses learn map fusion" -- syntaxfree
22:21:07 <dons> siti, an oleg is a unit of type hacker/cleverness here in #haskell, due to the writings of Oleg Kiselyov
22:21:09 <Cale> dons: thanks for the recent posts on reddit too.
22:21:09 <Gwern> Cale: that's weird alright
22:21:24 <dons> Cale: I woke up this morning and saw *othing* I wanted to read
22:21:34 <Cale> dons: me too
22:21:35 <dons> so time to do something about it, eh ? :)
22:21:55 <sorear> night all
22:21:59 <dons> night sorear
22:22:04 <dons> ?time sorear
22:22:05 <lambdabot> Local time for sorear is Mon Feb 12 22:20:47 2007
22:22:12 * dons wonders how sorear fits school in amongst the hacking
22:22:32 <dons> sorear: do you do any computer-related subjects at school?
22:22:34 <sorear> not amongst, it's nicely segregated
22:22:39 <sorear> no
22:22:41 <chessguy> ?time
22:22:42 <lambdabot> Local time for chessguy is Tue Feb 13 01:20:16
22:22:43 * nrb23 wonders how to get a foreign pointer out of a ptr
22:22:45 <dons> sorear: that's good!
22:22:48 <glguy> when I was in HS, you could just get your homework done in class
22:23:04 <dons> yeah, if you're organised, should be pretty easy to keep an open source life going
22:23:07 <glguy> if you didn't mind not paying attention at certain points
22:23:15 <dons> schools only 9-3 or what have you.
22:23:35 <sorear> nrb23: withForeignPtr
22:23:55 <dons> nrb23: you mean, get a Ptr from a ForeignPtr ?
22:24:01 <nrb23> dons: yes
22:24:08 <dons> yeah, withForeignPtr
22:24:15 <dons> e.g. withForeignPtr fp $ \ptr -> do something on the raw Ptr
22:24:18 <nrb23> wait, no, I'm an idito
22:24:27 <nrb23> I mean I have a Ptr
22:24:33 <nrb23> and I want to make a ByteString
22:24:41 <Cale> glguy: yeah, there was so much wasted time in highschool
22:24:44 <nrb23> but all the ByteString construction methods require a ForeignPtr
22:24:55 <dons> not quite. how did you get hold of the Ptr ?
22:25:02 <dons> is it from C?
22:25:05 <nrb23> it got passed to me from a C callback
22:25:16 <dons> ok. so its a Ptr CChar or something?
22:25:22 <dons> or a proper C string?
22:25:24 <nrb23> Ptr Word8
22:25:28 <dons> (null terminated?)
22:25:32 <glguy> Cale: yup, they have to slow down the bus so the kids that got left behind can walk along side
22:25:34 <nrb23> no, but I have the length
22:25:40 <dons> ok. good.
22:25:43 * dons looks up the api
22:25:54 <dons> packCStringLen,         -- :: CString -> IO ByteString
22:26:04 <dons> CStringLen = (Ptr CChar, Int)
22:26:20 <dons> so, you'd have:
22:26:27 <nrb23> yes, but Word8 != CChar
22:26:28 <dons> packMyPtr p len = packCStringLen (castPtr p, len)
22:26:40 <Cale> glguy: They should run things more like universities do.
22:26:46 <nrb23> castPtr fixes that?
22:26:49 <dons> :: Ptr Word8 -> Int -> ByteString
22:26:51 <dons> yeah, its a cast
22:27:01 <dons> if you know the types are right
22:27:08 <dons> e.g. Ptr CChar == Ptr Word8
22:27:20 <glguy> Cale: I hear that in Germany at least, by the time you are in Highschool, the slower and slowest kids are already separated out to trade and remidial schools
22:27:25 <dons> I assume you know what you're doing if you're getting a Word8 from C land, instead of CChar
22:27:34 <glguy> remedial*
22:27:46 <Cale> I don't think that's so much necessary, they just have to be less afraid to fail students and have them retake the course.
22:27:48 <chessguy> i think trade schools are becoming more popular in the US
22:27:54 <dons> Cale: imagine if we'd been hacking out here when we were 12..
22:27:59 * nrb23 tries it
22:28:04 <glguy> being 12?
22:28:19 <Cale> dons: That too. I wish I'd known about Haskell about 5 years earlier.
22:28:33 <chessguy> ugh, so nobody here has any knowledge of genetic programming?
22:28:35 <dons> yeah. sorear is very lucky.
22:28:50 <nrb23> sweet, that makes that part typecheck!
22:29:06 <chessguy> a year ago, i hadn't even heard of haskell
22:29:12 <JKnecht> well you'd have been ready for Haskell but would Haskell have been ready for you?
22:29:14 <chessguy> and i'm 25
22:29:15 <dons> nrb23: that's good, but you better be sure you told me the right info. the length needs to be correct, and note that that string has no finaliser attached.
22:29:27 <dons> so nrb23 its up to you to know how it gets deallocated
22:30:47 <dons> nrb23: also, the old packCStringLen uses zero-copy to build the bytestring
22:30:57 <dons> so you better ensure you don't later modify the Ptr Word8 contents
22:30:57 <nrb23> dons, I think it will be okay here
22:31:02 <nrb23> I won't
22:31:07 <glguy> "I’ve always said that digg is for people not smart enough to realize that every commenter on slashdot is an idiot. ;)"
22:31:15 <dons> ok. sounds ok then.
22:31:16 * nrb23 is using trying to use the Get monad
22:31:24 <dons> ah ok. good.
22:31:59 <chessguy> is Get base?
22:32:07 <chessguy> ?hoogle Get
22:32:08 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
22:32:08 <lambdabot> Text.ParserCombinators.ReadP.get :: ReadP Char
22:32:08 <lambdabot> Text.ParserCombinators.ReadPrec.get :: ReadPrec Char
22:32:11 <glguy> Get is Binary
22:32:23 <dons> chessguy: nope. might make it into the extralibs package, but given the success of hackage, i'm not sure its worth it
22:32:25 <Adamant> I realized that every commenter on Slashdot is an idiot, that was why I originally went for Digg - before they made a real comment system.
22:32:32 <nrb23> Data.Binary.Get
22:32:48 <dons> nrb23: doing some binary parsing?
22:33:13 <nrb23> dons: yeah, I'm experimenting with writing something that parses TCP/IP out of pcap dumps
22:33:29 <dons> ah right. yes. this is exactly what we hope to be able to do, and do nicely
22:33:32 <nrb23> I'm trying to learn haskell and get a better handle on TCP at the same time
22:33:45 <nrb23> I'm calling it "etherbunny" :->
22:33:46 <dons> so any experience reports would be worth it. (send us the code when you're done, or if you get stuck)
22:33:51 <dons> hehe
22:34:04 <nrb23> okay
22:34:19 <nrb23> also, I've added cabal support to Pcap, which seems to have been abandonded
22:34:27 <dons> i'd probably define a TCP header type, newtype any Ints and what not, then just map instnace Binary directly onto TCP's header writing and reading
22:34:35 <dons> who's the author?
22:34:45 <nrb23> --  Copyright	: (c) Antiope Associates LLC 2004
22:34:52 <dons> if you've added cabal support, i'd be inclined to tag and release it. then get it on hackage
22:35:06 <dons> is it an open license?
22:35:18 <nrb23> BSD
22:35:24 <nrb23> ?where pcap
22:35:24 <lambdabot> I know nothing about pcap.
22:35:29 <dons> cool. so you can just fix it, and host a darcs repo if you want
22:35:44 <dons> and then if its solid, let me know, and we can put up a stable tarball on hackage
22:36:09 <nrb23> ?where+ pcap http://www.haskell.org/networktools/src/pcap/
22:36:09 <lambdabot> Done.
22:37:19 <nrb23> also, I was trying to build lambdabot just now, and i realized I needed the plugin package
22:37:28 <nrb23> but it wouldn't build
22:37:31 <nrb23> src/AltData/Typeable.hs:452:0:
22:37:31 <nrb23>     parse error (possibly incorrect indentation)
22:37:58 <dons> you need the darcs repo version.
22:38:34 <dons> (i'll put out a release soon)
22:38:35 <nrb23> ah
22:38:39 <nrb23> ok
22:41:20 <dons> Cale: heh, http://www.almostserio.us/articles/2007/02/13/optimizations-using-functional-programming
22:41:23 <lambdabot> Title: optimizations using functional programming, http://tinyurl.com/yslol9
22:41:43 <dons> I'm almost inclined to help him out. But I'd need more info, I think, on where his head exploded
22:42:18 <Cale> dons: hehe
22:44:22 <glguy> hmm... time to put the language interpreter example to bed for GADTs
22:47:09 <siti> "But it's sooo fun to sacrifice OOP to the lambda gods!"
22:47:36 <siti> so many haskell trolls on reddit ;)
22:47:47 <dons> *cough*
22:48:06 <glguy> who said that, siti?
22:48:11 <siti> dons
22:48:15 <glguy> and what's in your throat, dons?
22:48:18 <glguy> ;)
22:48:31 <dons> I think I swallowed a object
22:49:25 <Cale> dons: I posted a little bit.
22:49:32 <glguy> > floor (1/0::Double) == 2^2^10
22:49:34 <lambdabot>  True
22:49:58 <Pseudonym> The thing is, of course, these optimisations are advanced material.
22:50:14 <Pseudonym> You have to understand map and fold first.
22:50:22 <dons> yeah.
22:50:29 <Cale> That's true.
22:50:33 <dons> so he's coming from a zero-FP background
22:50:34 <hpaste>  nrb23 annotated "ForeignPtr vs Ptr?" with "lazy bytestring?" at http://hpaste.org/474#a3
22:50:53 <Pseudonym> More to the point, a POV of not understanding data structures as algebra.
22:51:02 <Cale> Well, map and fold should be among the first things you learn in functional programming, but still. :)
22:51:06 <Pseudonym> You don't need to know FP for that, though it kinda falls out naturally.
22:51:14 <nrb23> I'm a bit confused about why it wants a lazy bytestring for runGet
22:51:15 <glguy> but he picked up HTML and CSS in one day.. so
22:51:26 <Pseudonym> HTML and CSS are not Turing-hard.
22:51:40 <glguy> You could stop at "hard"
22:51:44 <glguy> but OK :)
22:51:47 <Pseudonym> Not true.
22:51:54 <Cale> He did?
22:51:56 <Pseudonym> Getting CSS to work cross-browser is beyond hard.
22:52:06 <glguy> he didn't claim that feat
22:52:10 <Cale> He just said that he used them all in one day.
22:52:14 <nrb23> or rather, thinks it's being given one
22:52:21 <Cale> Which is not nearly as impressive :)
22:52:25 <dons> nrb23: the entire Get monad operates on lazy bytestrings (so you can parse buffers lazily). you can turn a strict bytestring into a lazy one by using fromChunks
22:52:34 <Pseudonym> Of course, it's not just Haskell.  You should learn a new language a year.
22:52:36 <dons> so you've got a strict bytestring from C land,
22:52:38 <nrb23> dons, thanks
22:52:42 <glguy> "I think using C#, Java, and Ruby (and SQL and JavaScript and HTML and CSS and XML) in one day is enough"
22:52:44 <dons> you just wrap it up as a (fake) lazy bytestring
22:52:47 <Pseudonym> And Haskell just happens to be one of the more useful ones to learn.
22:52:51 <glguy> he's just impressed that he was able to use them all in the same day
22:52:57 <Pseudonym> Well sheesh.
22:52:57 <roconnor> > cos Pi
22:52:58 <lambdabot>   Not in scope: data constructor `Pi'
22:53:02 <roconnor> > cos pi
22:53:03 <lambdabot>  -1.0
22:53:18 <roconnor> > (cos pi)^13
22:53:19 <lambdabot>  -1.0
22:53:20 <Pseudonym> I've used Haskell, C, Python, AWK, Korn shell, Bourne shell, Haskell and Prolog in one day.
22:53:27 <Pseudonym> Not Python, Perl.
22:53:35 <glguy> Pseudonym: say it isn't so!
22:53:41 <Pseudonym> Python == Perl to a first approximation.
22:53:44 * Pseudonym ducks
22:54:01 <nrb23> dons, where is getChunks?
22:54:12 <Pseudonym> glguy: Actually, you're right.  If you know Perl, you don't need shell scripting or AWK.
22:54:13 <roconnor> > (cos pi)^14
22:54:13 * nrb23 whishes hoogle had Data.Binary 
22:54:14 <lambdabot>  1.0
22:54:18 <glguy> lazy bytestring
22:54:23 <Pseudonym> Same is probably true of Python.
22:55:33 <roconnor> > 1660710909902848/2251799813685248
22:55:35 <lambdabot>  0.7375037957681343
22:56:04 <dons> fromChuns, in Data.ByteString.Lazy
22:56:14 <Cale> dons: It's cool how you go and search people's blogs for references to Haskell. With this power, we can make the Haskell community seem awesome even to outsiders. :)
22:56:26 <Pseudonym> Anyway, must away.
22:56:31 <Pseudonym> Nytol!
22:56:48 <roconnor> :@type iterate
22:56:51 <roconnor> @type iterate
22:56:52 <lambdabot> forall a. (a -> a) -> a -> [a]
22:57:04 <roconnor> > iterate cos pi
22:57:05 <lambdabot>  [3.141592653589793,-1.0,0.5403023058681398,0.8575532158463934,0.654289790497...
22:57:08 * dufflebunk doesn't get how a type can have a function in it
22:57:18 <roconnor> > (iterate cos pi)!!13
22:57:20 <lambdabot>  0.7414250866101092
22:57:27 <roconnor> > (iterate cos pi)!!19
22:57:28 <lambdabot>  0.7393038923969059
22:57:34 <dons> dufflebunk: its a higher order function
22:57:39 <roconnor> > (iterate cos pi)!!100
22:57:41 <lambdabot>  0.7390851332151607
22:57:41 <xpika> Cale: http://blogsearch.google.com/blogsearch?hl=en&q=haskell&btnG=Search+Blogs
22:57:43 <lambdabot> Title: Google Blog Search: haskell, http://tinyurl.com/226kes
22:57:45 <dons> :t map
22:57:46 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:57:49 <dufflebunk> dons: the forall part
22:57:51 <dons> being the canonical higher order function
22:57:55 <nrb23> it builds! ship it!
22:58:07 <dons> oh, that's just binding the type variable (i.e. so you see its scope)
22:58:18 <dons> think of that like 'let' for type variables
22:58:36 <dons> Cale: well, google searches the blogs, and gives me an rss feed
22:59:04 <dons> i then go and magically materialise wherever the honour of haskell is threatened! :-)
22:59:27 <dons> it does make us seem very very organised, I must admit
22:59:47 <dons> since I don't think you'd get the top perl or java guys popping up on random blogs
23:00:00 <nrb23> aside from the fact that the data looks to be completely wrong... but I'm sure that's my fault :->
23:00:00 <dufflebunk> dons: does the forall actually make a difference then?
23:00:27 <dons> dufflebunk: nope, its just docs, since there's an implicit forall there anyway, if you leave it off
23:00:48 <dons> nrb23: hehe. good. but test test test. playing with C/binary is very untyped, and actually needs testing ;)
23:00:53 <Cheery> if person is on pass-by trip on haskell, where one would go if he'd want something better language than haskell?
23:00:58 <dufflebunk> dons: is there another kind of type binding as well then?
23:01:10 <nrb23> dons: great...
23:01:26 <dons> dufflebunk: yeah, you can play some funny games with local bindings
23:01:39 <dons> Cheery: better in what sense?
23:01:40 <dons> harder?
23:02:06 <Cheery> even more stronger foundation, even more carefully thought out.
23:02:17 <Cheery> even better code generation properties.
23:02:19 * dufflebunk stays away from funny games until he figures out the normal syntax
23:02:29 <dons> hmm, better code generation properties?
23:02:40 <dufflebunk> Cheery: I would suggest bash
23:02:44 <Cheery> dons: even more abstract.
23:02:44 <dons> i mean, much stronger and you have a theorem prover, so say, epigram or Twelf
23:02:48 <dons> or isabelle
23:03:08 <dons> more abstract, hmm, the arrow/applicative /comonad  subset of haskell?
23:03:24 <dons> you can keep abstracting in haskell , so i'm not sure we've found the upper limit yet.
23:03:35 <vincenz> dons: what is the name of your advisor?
23:03:42 <dons> seems to be new higher abstractions every year (like applicative functors)
23:03:42 <Cheery> ok, so haskell is a bit dead end then.
23:03:57 <dons> Cheery: well, we don't know where the end is
23:04:00 <Cheery> (from language selection point of view)
23:04:06 <dons> that's the point. much further and you have a theorem prover
23:04:08 <vincenz> dons: the one with the templates for making presentations with I thought it was latex
23:04:21 <dons> Cheery: its the top of the power scale
23:04:34 <dons> the fuzzy cloud of experimental languages is the only thing beyond it
23:05:10 <chessguy> dons, make sure that quote gets in your thesis :)
23:05:40 <dons> vincenz: http://www.cse.unsw.edu.au/~chak
23:05:40 <lambdabot> Title: Manuel M T Chakravarty
23:05:56 <dons> vincenz: you're looking for the chaksem.cls file
23:06:05 <dons> chessguy: which one? :}
23:06:10 <vincenz> dons: thx :)
23:06:28 <chessguy> ?remember dons the fuzzy cloud of experimental languages is the only thing beyond haskell
23:06:28 <lambdabot> Done.
23:06:30 <chessguy> that one :)
23:07:13 <dons> well, that's true enough :)
23:07:30 <chessguy> oh, i agree whole-heartedly
23:07:35 <chessguy> not that i know anythign
23:07:43 <nrb23> interesting, bytes 13 and 14 are correct
23:07:53 <dons> nrb23: well, that's a start :)
23:08:00 <nrb23> but the first 12 aren't
23:08:02 <chessguy> i can't even spell 'anything'
23:08:21 <chessguy> nrb23, time to release and request patches
23:08:27 <nrb23> heh
23:11:28 <dmead> i uhh
23:11:31 <dmead> have a theorem prover...
23:11:53 <Cheery> It's just weird, because I've not had an urge to change language after haskell. :(
23:12:13 <dons> me neither , yet. there's so much to learn.
23:12:22 <Cheery> And my socks start to smell because I change programming language as often as my socks.
23:12:36 <dons> i haven't used 3/4 ofD[D[D[D[D the abstractions out there yet.
23:12:46 <dons> heh
23:13:06 <siti> haskell is just so good there is no reason to change ;)
23:13:37 <dons> well, at least there's plenty of room to improve it , without forking
23:13:56 <dons> there's still a lot of potential, which keeps people around, I think
23:14:22 <siti> yeah it looks like a good community process to improve the language
23:14:52 <Cheery> no kidding? You have been made the foundation of this language on lambda calculus.
23:14:57 <careo> Cheery: heh. I'm hoping learning Haskell brings me to that same end. The end of my language slut days
23:16:17 <careo> does anyone know anything about Qt4 bindings in Haskell?
23:16:26 <Cheery> dons: that means haskell is a whole new portal to completely different reality. It's like asking whether there's raining in London if you asking whether there's something new in haskell.
23:17:04 <dons> that's true enough. there's a lot of new unexplored territory
23:17:59 <careo> seems kind of crazy that there IS so much unexpored territory in something manmade.
23:18:44 <Cheery> careo: well, I see lambda calculus as rules of automaton, it's not that it all is possibly man-made.
23:19:31 <careo> pardon my ignorance, but is haskell based on lambda calculus? I've only heard the term in the contxt of Lisp
23:20:13 <Cheery> careo: it has, and deeper compared to most lisps I've seen.
23:20:26 <dmead> it's based on that and the M-H whatnots from the 70s
23:20:35 <careo> Cheery: cool, cool
23:20:40 <Cheery> consider this: map (2+) [1..99]
23:21:22 <Cheery> currying is going there, (\x -> \y -> x + y)
23:21:34 <dmead> hey
23:21:37 <dmead> if you have
23:21:43 <dmead> sum x y = x + y
23:21:57 <dmead> the lambda version is (\x y = x + y)
23:21:58 <dmead> yea?
23:22:07 <Cheery> yes.
23:22:13 <chessguy> in haskell, you would say \x y -> x + y
23:22:16 <dmead> cool.
23:22:29 <chessguy> plus parens, if you like
23:22:36 <dmead> oh right
23:22:37 <dmead> ->
23:23:56 <Cheery> careo: also there's another things which seem to success in haskell, compared to common lisp languages like CLISP and scheme.
23:24:14 <Cheery> like this form from y-combinator:
23:24:46 <Cheery> > \f -> (\x -> x x) (\x -> x x)
23:24:47 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
23:24:47 <lambdabot>       Expe...
23:25:14 <Cheery> ugh, not right.
23:25:35 <Cheery> \f -> (\x -> f (x x)) (\x -> f (x x))
23:25:39 <Cheery> now it's right.
23:25:52 <mauke_> > \f -> let x = f x in x
23:25:53 <lambdabot>  Add a type signature
23:25:57 <chessguy> x x ?
23:26:03 <chessguy> that looks wrong
23:26:11 <int-e> no, that's right :)
23:26:24 <int-e> it's not typable in the typed lambda-calculus but that was to be expected.
23:26:28 <chessguy> well, i don't really know what he's doing. it just looked weird
23:26:30 <int-e> (simply typed)
23:27:38 <nrb23> dons, does getByteString not do what I think it does?
23:28:27 <Cheery> chessguy: It's one kind of Y-combinator, you can make recursions without explicit naming when you use it.
23:29:05 <Cheery> like this: \f x -> f (x+2)
23:30:07 <mauke_> > (\f -> let x = f x in x) ('f' :)
23:30:08 <lambdabot>  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff...
23:30:18 <chessguy> ok, it's just exceptional to see something like "x x"
23:30:19 <Cheery> :)
23:32:00 <chessguy> > (\x -> x + 2) 3
23:32:01 <lambdabot>  5
23:32:21 <chessguy> that's more my speed :)
23:32:46 <Cheery> > putStrLn "Hello lamers!"
23:32:47 <lambdabot>  <IO ()>
23:32:58 <Cheery> :/
23:33:28 <nrb23> I should go to bed
23:33:30 <nrb23> 'night
23:33:41 <nrb23> thanks for the help yet again
23:34:23 <nrb23> wait!
23:34:25 <nrb23> I'm an idiot!
23:34:31 <nrb23> I was comparing my output to the wrong data
23:34:33 <nrb23> it works!
23:34:35 <nrb23> wazoo!!!
23:35:47 <chessguy> @paste
23:35:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:36:07 <dmead> :>
23:40:23 <dons> nrb23: that's the parsing function for getByteString, it extracts a ByteString from the parse state
23:40:50 <nrb23> dons: I had two bugs... one in my code, and one in the fact that the actual output from ethereal I was looking at was for the wrong file :-<
23:41:06 <nrb23> this is what I get for trying to learn this stuff after a long day at work
23:42:28 <nrb23> dons, thank you very much for your help.. I now have the bytestring stuff working exactly as I wanted
23:43:07 <nrb23> good night all
23:44:13 <dons> nrb23: wow. great.
23:44:24 <dons> feel free to demo the TCP parser on haskell-cafe@
23:44:32 <dons> and if anything needs documentation tweaked, let me know.
23:46:20 <Cheery> " If one spends much time around those who are intellectually weak it will be noticed that they love to argue - indeed this is one of their favorite pastimes. This tells you that arguing is not an intelligent activity."
23:46:22 <Cheery> LOL
23:46:34 <dmead> aye
23:46:40 <dmead> i've got a tuple
23:46:43 <dmead> (x,[])
23:46:49 <dmead> x [] is an invalid pattern
23:46:56 <dmead> (i'm changing to curried forum)
23:47:01 <dmead> soo
23:47:07 <dmead> how do you curry x []?
23:47:10 <Cheery> > (1, [])
23:47:11 <lambdabot>  Add a type signature
23:47:25 <dmead> o0
23:47:26 <dmead> i have
23:47:33 <dmead> foo(x,[])
23:47:37 <dmead> but i want to write
23:47:40 <dmead> foo x []
23:47:45 <dmead> which seems to be rejected
23:48:01 <hyrax42> :t curry
23:48:03 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
23:48:13 <hyrax42> ?
23:48:21 <dmead> hmmm
23:48:32 <hyrax42> not sure what you mean
23:48:40 <hyrax42> and
23:48:41 <kzm> dmead what's the type of foo?
23:48:45 <Cheery> what about: uncurry foo (x,[]) :)
23:48:46 <hyrax42> ?localtime hyrax42
23:48:47 <lambdabot> Local time for hyrax42 is 2007-02-13 02:47:31 -0500
23:48:51 <hyrax42> ?localtime
23:48:52 <lambdabot> Local time for hyrax42 is 2007-02-13 02:47:36 -0500
23:48:57 <hyrax42> ah good
23:49:00 <hyrax42> anyway, I'm going to bed
23:49:00 <chessguy> ?time
23:49:01 <lambdabot> Local time for chessguy is Tue Feb 13 02:46:35
23:49:09 <Cheery> ?time
23:49:12 <hyrax42> oh even better
23:49:14 <dmead> (x. [x]) -> [x]
23:49:34 <hyrax42> ?djinn (a, [a]) -> [a]
23:49:35 <lambdabot> f (_, a) = a
23:49:48 <dmead> ?src curry
23:49:49 <lambdabot> curry f x y = f (x, y)
23:49:55 <dmead> ?src uncurry
23:49:55 <lambdabot> uncurry f p = f (fst p) (snd p)
23:50:04 <Cheery> hmm
23:50:11 <Cheery> yeh, curry foo (x, [])
23:50:16 <hyrax42> why isn't that a pattern match
23:50:19 <Cheery> lets see. :)
23:50:20 <vincenz> Cheery: where did you egt that quote?
23:50:31 <hyrax42> f (x,y) = f x y
23:50:34 <vincenz> dons: have you used the latex presentation cls before?  Any sample code I could rip?
23:50:34 <dmead> seems like you should be able to write [] in a curried pattern
23:50:41 <Cheery> vincenz: http://www.hal-pc.org/~rcanup/energy.html
23:50:42 <lambdabot> Title: The Interference Anomaly
23:50:42 <dons> vincenz: yeah, let me find it..
23:50:45 <hyrax42> or maybe a lazy pattern?  I don't know aobut those
23:50:56 <hyrax42> dmead: of course you can
23:51:00 <hyrax42> ?src map
23:51:01 <lambdabot> map _ []     = []
23:51:01 <lambdabot> map f (x:xs) = f x : map f xs
23:51:07 <Cheery> > curry (\x y -> x) (1,2)
23:51:08 <lambdabot>  Add a type signature
23:51:15 <Cheery> :/
23:51:22 <dmead> ;/
23:51:34 <dons> vincenz: http://www.cse.unsw.edu.au/~dons/code/talks/fps-intro/
23:51:34 <lambdabot> Title: Index of /~dons/code/talks/fps-intro
23:51:42 <Cheery> > uncurry (\x y -> x) (1,2)
23:51:43 <lambdabot>  1
23:51:55 <Cheery> > uncurry (\x y -> y) (1,2)
23:51:56 <lambdabot>  2
23:52:04 <Cheery> dmead: did you want this?
23:52:08 <hyrax42> hm I dunno what you're doing so I'm going to bed
23:52:21 <dmead> hmm
23:52:25 --- mode: ChanServ set +o dons
23:52:40 --- mode: dons set +b *!*n=gavin@*.lsanca.dsl-w.verizon.net
23:52:40 --- kick: ion-weapon was kicked by dons (same old gschuett troll.)
23:52:41 <vincenz> dons: muchas gracias ;)
23:52:42 --- mode: ChanServ set -o dons
23:52:53 <dons> that's the infamous @protontorpedo, fwiw guys :)
23:52:58 <dmead> ?paste
23:52:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:53:09 <dons> (check the logs from a couple of days ago, he dragged some of you into his bizarro world talk)
23:53:12 <dons> @proton
23:53:12 <lambdabot> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp?
23:53:16 <dons> @proton
23:53:16 <lambdabot> so haskell is different from lisp?
23:53:31 <chessguy> lol
23:53:32 <vincenz> dons: see http://lambda-the-ultimate.org/node/2062 ?
23:53:32 <Cheery> @dons
23:53:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:53:32 <lambdabot> Title: Lightweight Fusion by Fixed Point Promotion | Lambda the Ultimate
23:53:37 <dons> that's from 2 years ago, then a few days ago,
23:53:38 <dons> 07.01.31:07:02:10 <magic_user> whats a monad?
23:53:38 <dons> 07.01.31:07:02:17 <magic_user> is it like a gonad?
23:53:38 <dons> 07.01.31:07:02:59 <magic_user> anyone here comparing commonlisp to haskell
23:53:40 <sieni> > ((*
23:53:41 <lambdabot>  Parse error
23:53:46 <sieni> > ((*) 7 4)
23:53:46 <dons> vincenz: yeah, i saw the talk live at POPL
23:53:48 <lambdabot>  28
23:53:50 <vincenz> dons: apparently it's the same guy as calvino
23:53:57 <dons> oh? huh.
23:53:57 <vincenz> dons: on CLS
23:54:10 <vincenz> (c.l.scheme)
23:54:17 <hpaste>  dmead pasted "curry?" at http://hpaste.org/475
23:54:17 <kzm> Was there any way to assign from IO actions in ghci 6.6 without having the result printed?
23:54:20 <vincenz> at least riastradh told me so
23:54:27 <dons> @seen calvino
23:54:27 <lambdabot> I haven't seen calvino.
23:54:30 <hyrax42> is that the same as gavino?
23:54:37 <vincenz> hyrax42: erm, right
23:54:40 <dons> kzm: foo >> return ()
23:54:40 <vincenz> gavino, not calvino
23:54:49 <hyrax42> he's the best troll ever
23:54:58 <hyrax42> his style is 10/10
23:54:59 <vincenz> hyrax42: nah, kt is :)
23:55:03 <dons> @proton
23:55:03 <lambdabot> why haskell over smalltalk? I thought smalltalked rocked
23:55:05 <dmead> parse error in pattern ;/
23:55:08 <hyrax42> kt?
23:55:13 <hyrax42> well I'm going for style here
23:55:23 <vincenz> hyrax42: tilton?
23:55:27 <hyrax42> oh
23:55:28 <hyrax42> right
23:55:32 <kzm> dons: can I bind the value to a variable?
23:55:37 <hyrax42> but
23:55:44 <kzm> @hoogle unsafePerformIO
23:55:44 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
23:55:58 <kzm> Hah, that's it!
23:56:01 <hyrax42> I've been thinking of writing something like this to c.l.l
23:56:05 <dons> x <- foo
23:56:13 <hyrax42> subject: i want to troll like gavino
23:56:15 <dons> ah, but thta prints it, does it?
23:56:20 <dmead> > foo x [] = 1
23:56:20 <lambdabot>  Parse error
23:56:25 <dmead> yea
23:56:32 <dmead> > let foo x [] = 1
23:56:33 <lambdabot>  Parse error
23:56:36 <hyrax42> body: i want to troll like gavino how?
23:56:38 <hyrax42> how?
23:56:40 <dmead> > let foo x [] = 1 in foo x y
23:56:40 <lambdabot>   Not in scope: `y'
23:56:41 <hyrax42> how??
23:56:52 <dmead> > let foo x [] = 1 in foo x [1..3]
23:56:53 <lambdabot>   Not in scope: `x'
23:56:56 <dmead> pker;lea
23:57:14 <Cheery> @Cheery
23:57:15 <lambdabot> Unknown command, try @list
23:57:18 <Cheery> hmm
23:57:18 <dmead> > let foo x [] = 1 in foo x []
23:57:19 <lambdabot>   Not in scope: `x'
23:57:25 <allbery_b> @keal
23:57:25 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
23:57:41 <dmead> o0
23:57:44 <kzm> dons: yep.  But 'let x = unsafePerformIO foo' is okay.
23:58:49 <dmead> ?src fold1
23:58:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:59:04 <dmead> yes hal, give up the source ya bastard
23:59:12 <dmead> ?src foldr
23:59:12 <lambdabot> foldr k z xs = go xs
23:59:12 <lambdabot>     where go []     = z
23:59:12 <lambdabot>           go (y:ys) = y `k` go ys
23:59:42 <JKnecht> ?src foldl
23:59:43 <lambdabot> foldl f z xs = lgo z xs
23:59:43 <lambdabot>     where lgo z []     =  z
23:59:43 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
