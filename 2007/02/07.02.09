00:15:48 <vincenz> heh, /me likes the new topic in #haskell.dut
00:15:58 <vincenz> #haskell.dut :: (Dutch newbie, Haskell help) => newbie -> help newbie
00:16:26 <earthy> (makes mistakes such as those made by jeeves_bond at around 05:16 localtime in .nl and .be somewhat less probable ;))
00:17:26 <tessier__> #haskell.piglatin
00:17:51 <tessier__> iay ikelay unctionalfay rogrammingpay
00:18:59 <vincenz> kealy?
00:19:00 <vincenz> @kealy
00:19:01 <lambdabot> 99% of my book has been erased by faulty hdd's
00:19:27 <vincenz> and you mean 'ogrammingpray
00:22:59 <Cale> @keal
00:22:59 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
00:23:11 <Cale> @keal
00:23:12 <lambdabot> my very first computer was an 80-0840
00:26:22 <pjd> "rogramming" has a certain... je ne sais quoi
00:34:49 <vincenz> naming...the biggest problem o research and coding
00:36:51 <hpaste>  Cheery pasted "What is going on here?" at http://hpaste.org/408
00:37:13 <dons> hehe
00:37:34 <Cheery> It's like those type definitions would have their own life. :(
00:38:19 <Cheery> I thought I handle them, but then MonadState comes and kicks ass.
00:38:38 <Cheery> class (Monad m) => MonadState s m | m -> s where
00:38:48 <Cheery> What should I give to it?
00:39:00 <pjd> vincenz: some say naming is everything
00:39:06 <vincenz> pjd: I would nearly agree
00:39:14 <vincenz> pjd: once something is named it is defined and therefore understood
00:39:42 <pjd> heh, i'm not quite so sure about the latter bit
00:41:01 <pjd> but yeah, finding names for things is at least half of programming
00:41:27 <vincenz> moreso for research
00:41:55 <pjd> so what are you naming, then?
00:42:28 <hpaste>  dons annotated "What is going on here?" with "seems to work..." at http://hpaste.org/408#a1
00:42:38 <vincenz> pjd: a particular transformation
00:43:41 <Cheery> hmm.
00:44:51 <Cheery> after running my ghci with -fglasgow-exts , it seems to work.
00:45:34 * allbery_b suspected it might be related to MPTC
00:45:43 <vincenz> Cheery: haskell98 doesn't handle MPTC lik allbery_b said
00:45:51 * allbery_b not real smart about such things though
00:46:30 <allbery_b> (multi-parameter typeclasses)
00:47:07 <Cheery> I see. and MonadState is multi-parameter typeclass.
00:48:28 <Cheery> I do not understand the  '|' -mark in that class definition, and there didn't read anything in wikibook about that.
00:48:37 <Cheery> What is it?
00:49:05 <allbery_b> "fundep" (functonal dependency, another Haskell extension)
00:49:29 <allbery_b> basically asserts that m determines s uniquely
00:50:03 <allbery_b> (I think --- again, not really knowledgeable about such things)
00:50:52 <Cheery> do you know where I could find out myself about haskell extensions?
00:51:35 <vincenz> #haskell
00:51:53 <allbery_b> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html more or less :)
00:51:55 <lambdabot> Title: Chapter 7. GHC Language Features, http://tinyurl.com/kf2g3
00:53:18 <Cheery> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
00:53:21 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
00:53:27 <Cheery> ok, thanks. :)
00:55:21 <dons> ?yow!
00:55:22 <lambdabot> There's a little picture of ED MCMAHON doing BAD THINGS to JOAN RIVERS
00:55:22 <lambdabot> in a $200,000 MALIBU BEACH HOUSE!!
00:56:08 <vincenz> @shootut
00:56:09 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
00:56:52 <vincenz> hmm
00:57:04 <vincenz> the technique of bootstrapping the loop one iteration earlier for fractal isn't done
00:58:25 <hpaste>  vincenz pasted "bootstrapping fractal" at http://hpaste.org/409
01:06:04 <Syzygy-> Hang on a second! Currying is just the isomorphism Hom(A, Hom(B,C)) <=> Hom(AxB, C) - isn't it?
01:07:51 <norp> if Hom means function
01:09:46 <Syzygy-> Hom is the set (group, vector space, whatever) of functions with the signature A -> B
01:10:41 <dons> vincenz: yes, all versions that used this trick  failed with the rounding error at n=3k
01:11:16 <norp> i thought a homomorphism had to be structure preserving
01:11:26 <norp> but who cares :)
01:15:42 <Cheery> So... In MonadState, the s -parameter is uniquely defined by m -parameter.
01:16:34 <Cheery> MonadState s (State s) defines that s is the inner -thing of State ?
01:17:38 <Cheery> so, s would be equivalent to: s -> (a,s) here.
01:17:44 <Cheery> must try!!! :)
01:20:15 <Cheery> like this:
01:20:19 <Cheery> instance MonadState (s -> (a,s)) (ST (s -> (a,s)))
01:21:04 <norpan> Cheery: no, surely s i the state
01:22:19 <quicksil1er> Cheery: the 's' in ST is not "really" a state
01:22:32 <quicksil1er> Cheery: well it's a very very abstract version of one
01:25:23 <Cheery> hmm.
01:26:12 <Cheery> get :: m s,   so get must return (ST s)
01:26:48 <quicksil1er> that's a different 's'
01:26:56 <quicksil1er> an unfortunate collision of names
01:28:14 <quicksil1er> I think I'm not explaining this very well
01:28:29 <quicksil1er> hopefully someone more awake will wander in soon, but let me try again
01:28:42 <Cheery> I think so too, I'm a bit confused now. :)
01:29:43 <quicksil1er> Cheery: if (ST s) was a 'normal' state monad
01:29:55 <quicksil1er> Cheery: then you might expect  'get' to return the 's'
01:30:09 <quicksil1er> Cheery: but ST s is special, and 's' is a secret type, and you're not allowed it
01:30:22 <allbery_b> youy know he's talking abotu a reimp[lementation of State he was playing with, and not Control.Monad.ST?
01:30:22 <quicksil1er> Cheery: you can never do anything directly with the 's'
01:31:16 <quicksil1er> ah
01:31:31 <quicksil1er> then it sounds like I have confused him un-necessarily
01:31:46 <pjd> Syzygy-: so it is, according to the Wikipedia article
01:31:48 <allbery_b> see http://hpaste.org/408
01:31:55 <quicksil1er> Cheery: when you mentioned (ST s) I thought you were talking about the 'standard' ST
01:32:03 <allbery_b> (which we've already corrected)
01:32:14 <quicksil1er> Cheery: my apologies for not reading enough scrollback before jumping in
01:32:35 <Cheery> I see. No problem. :)
01:32:41 <Syzygy-> pjd: Neat. Then currying is even easier than I thought. :P
01:32:48 <allbery_b> one of the tutorials I've seen called its example simple State monad ST, which IMO is confusing :/
01:33:03 <allbery_b> or at least the constructor thereof, I forget
01:33:27 <pjd> Syzygy-: for a very specialized definition of "easy", i bet :)
01:33:29 <quicksil1er> Cheery: in your example, the type of 'get' is ST s s
01:33:33 <allbery_b> Control.Monad.ST (state thread monad) is kinda deep black magic :)
01:33:46 <Syzygy-> pjd: Well, I -know- how the isomorphism I quoted works. :P
01:33:49 <quicksil1er> Cheery: 'get' is a computation in the (ST s) monad which happens to calculate a value of type 's'
01:33:58 <allbery_b> using existential types to protect the guts of the monad
01:33:58 <quicksil1er> Cheery: hence, (ST s) s or simply ST s s
01:34:14 <Syzygy-> pjd: I have a lot of category theory and homological algebra internalized even before I started looking at Haskell...
01:34:46 <Syzygy-> And I find it pretty that my intuition from homological algebra actually translates to something explicit here.
01:36:38 <Cheery> quicksil1er: you are still talking about ST monad in the haskell standard?
01:37:14 <quicksil1er> Cheery: no
01:37:26 <quicksil1er> Cheery: now, I'm talking about yours, having understood your question finally :)
01:37:50 <allbery_b> just for clarity: ST isn't part of the haskell standard, it relies on many extensions to even exist :)
01:38:12 <quicksil1er> Cheery: your monad is (ST s), so in "get : m s", the 'm' is actually (ST s), giving get :: (ST s) s
01:38:19 <pjd> Syzygy-: lucky you :)
01:38:24 <Cheery> ah. so get :: m s   would be same as: get :: (ST s) s in instance MonadState s (ST s)
01:39:15 <quicksil1er> Cheery: exactly
01:39:56 <quicksil1er> Cheery: "MonadState s (ST s)" can be read like this, in English "I define the monad (ST s) to be a State Monad, and its state is of type 's'"
01:39:56 <pjd> i've been trying to teach myself some category theory
01:40:15 <pjd> mostly, i've just succeeded in feeling very thick
01:41:01 <quicksil1er> different people have different approaches to category theory. Personally I could only ever get a handle on it via examples.
01:41:18 <quicksil1er> And the examples tend to be drawn from other fields of pure mathematics and aren't very useful if you don't already know those.
01:41:25 <vincenz> dons: oh, I see :/
01:41:35 <vincenz> dons: funny cause it's just adding 0s
01:42:12 <Cheery> I had to understand lambda calculus and tiny part of category theory before I could understand haskell.
01:42:20 * pjd sees a market for "category theory for dummies"
01:42:29 <quicksil1er> lambda calculus I can see
01:42:44 <quicksil1er> to be honest, I learnt haskell without thinking about categories once, though
01:42:48 <Cheery> pjd: in wikipedia there's something about it, probably all I know about it now.
01:43:02 <quicksil1er> even though I knew what a categorical Monad was, I never took the trouble to relate that to a haskell monad.
01:43:27 <quicksil1er> I just decided a haskell monad was a way of wrapping a type in some computational container
01:43:47 <ivanm> dons: I tried using Arrays for matrices, but it slowed my program down even more
01:44:24 <tessier__> I kinda get lambda calculus but I need to think more about y combinator, fixed points, etc.
01:44:34 <tessier__> Still don't quite get that. Something about recursion.
01:44:52 <tessier__> I need to read the last chapter or two of "The Little Schemer" again. I seem to recall it explained the y combinator.
01:45:18 <quicksil1er> It's certainly not necessary to understand the fixed point combinator to understand recursion in practice.
01:45:24 <quicksil1er> (heck even C programs can recurse)
01:45:39 <quicksil1er> there's a mild "Oh, I see" moment when you do grok the relationship though.
01:45:49 <tessier__> I like those moments. :)
01:45:59 <vincenz> the aha-erlebenis
01:46:02 <Cheery> quicksil1er: I wouldn't otherwise be interested about haskell if it wouldn't implement a very consistent package for describing programs.
01:46:03 <vincenz> or zen-whack
01:46:27 <quicksil1er> Cheery: absolutely
01:48:27 <Cheery> and if I wouldn't have found that out myself it does so. :)
01:49:04 <tessier__> Categorical logic is now a well-defined field based on type theory for intuitionistic logics, with application to the theory of functional programming and domain theory, all in a setting of a cartesian closed category as non-syntactic description of a lambda calculus.
01:49:09 * vincenz curses at the IT departement
01:49:10 <tessier__> My head hurts.
01:49:35 <tessier__> Sometimes wikipedia is less useful than other times.
01:50:01 <vincenz> "Hello, I am having problems sending mail via the SMTP server" "Oh...hmm...well... I don't know...I don't know... I don't know... it works fine for me"  "Yes, you are using the exchange server, I am having trouble with the smtp server" "No...I don't know...I don't know...I don't know...you could call...hmm...well...maybe this person"
01:50:13 <vincenz> o.O
01:50:14 <ivanm> well, I'm doing a research project at uni at the moment (which involves learning haskell), and another guy is doing one on category theory, and it involves just _learning_ category theory...
01:50:27 <pejo> I can happily say I knew nothing about category theory, lambda calculus or logic when they threw Haskell at us in the functional programming course.
01:50:59 <tessier__> pejo: Good. Perhaps I have hope.
01:51:10 <tessier__> pejo: Assuming you still enjoy haskell and are doing productive things with it.
01:51:43 * allbery_b still knows close to nothing about category theory
01:52:01 * Vq^ neither
01:52:01 <pejo> tessier__, naw, never done anything productive with it. Still don't know category theory. I'm a lazy slob. But others are doing great stuff.
01:52:15 <Cheery> I wonder how much different imperative programming languages would seem like if they'd have not copied concepts from functional language and would have instead studied the abstractions available in the machine code.
01:52:25 <tessier__> pejo: Not what I wanted to hear. :)
01:52:33 <allbery_b> I get he impression you only need to cre about it for muching around with implementing higher level things
01:52:45 <pjd> Cheery: what do you mean?
01:52:47 <quicksil1er> I don't think you *need* to care about it, ever
01:52:59 <quicksil1er> but there is a link and some people might find that enlightening
01:53:08 <allbery_b> that is, you might need to know it to *invent* the ST monad, or the IO monad, but not to *use* either
01:53:55 <pjd> allbery_b: maybe not even to invent them
01:54:17 <Cheery> pjd: think what it would be if machine code would be as well formalized like how lambda calculus is.
01:54:19 <pjd> it's not too uncommon to see monads reinvented by accident in various contexts
01:54:24 <dons> to formalise the concept of a monad, you might want some CT
01:54:31 <dons> that's about it.
01:54:34 <pjd> my favorite example is still Twisted's Deferreds
01:55:02 <kaspyanand> hi all
01:55:36 <kaspyanand> i have just started reading YAHT tutorial,i have some questions
01:55:46 <pjd> Cheery: hmm, i think machine code is pretty "formalized"
01:55:56 <pjd> in the sense of being rigorously specified
01:56:08 <allbery_b> pjd: sure, I've read sigfpe's thing.  but I also get the impression that making nicely composable and reusable monads is simplified if you can think about them in terms of category theory
01:56:32 <pjd> allbery_b: yes, of course
01:56:47 <kaspyanand> in the tutorial author mentions we can define a length function as:
01:56:48 <kaspyanand> my_length [] = 0
01:56:48 <kaspyanand> my_length (x:xs) = 1 + my_length xs
01:57:01 <kaspyanand> what does this means (x:xs)..a list of any length??
01:57:02 <Cheery> hmm, maybe it's then just that IT companies and other such guys who are doing programs aren't very sophisticated.
01:57:08 <allbery_b> it's a pattern
01:57:13 <quicksil1er> kaspyanand: a list of length at least one, in fact
01:57:18 <quicksil1er> kaspyanand: such that 'x' is the first element
01:57:23 <quicksil1er> kaspyanand: and 'xs' are the remainder
01:58:15 <kaspyanand> ok ths
01:58:17 <pejo> tessier__, hey, I'm lazy. Atleast I don't try to hide it. :-)
01:58:24 <kaspyanand> is it related to pattern matching
01:58:31 <araujo> > let (x:xs) = [1 .. 9] in (show x) ++ " is the first element; and " ++ (show xs) ++ " the rest of the list."
01:58:32 <ivanm> kaspyanand: that's because lists can be constructed as: 1:2:3:4:[] = [1,2,3,4] = 1:[2,3,4], etc.
01:58:34 <lambdabot>  "1 is the first element; and [2,3,4,5,6,7,8,9] the rest of the list."
01:58:37 <pjd> kaspyanand: it is pattern matching :)
01:59:02 <nornagon> hm, what's the syntax for modifying records?
01:59:03 <Cheery> kaspyanand, (x:xs), you could see it as such that (x:xs) -breaks the first element in your list.
01:59:13 <allbery_b> r {fld = newva}
01:59:20 <allbery_b> +l
01:59:21 <nornagon> thx
01:59:34 <nornagon> can I do fld = fld + 1 or some such?
01:59:50 <allbery_b> there's no way to make a nice shorthand
02:00:02 <allbery_b> r {f = (f r) + 1}
02:00:22 <kaspyanand> ok so xs can itself be a list so x:xs
02:00:24 <allbery_b> records aren't first class, so you can't wrap that... but you could write a modify function for each field
02:00:38 <nornagon> (also, this is on a CalendarTime -- will it work out everything else if I set just one field?
02:00:42 <nornagon> )
02:00:49 <ivanm> kaspyanand: exactly (including the empty list, [])
02:00:55 <allbery_b> yes, it copies over the rest
02:01:40 <Cheery> kaspyanand, would definition of list help you?
02:01:57 <nornagon> hm, maybe it'd be better to alter the ClockTime before converting it to CalendarTime
02:02:08 <kaspyanand> Cheery:sure
02:02:25 <Cheery> data List a = [] | a : List
02:02:38 <kaspyanand> ok
02:02:46 <Cheery> [1,2,3] is a syntax suggar for 1:2:3:[]
02:03:05 <kaspyanand> rite
02:04:04 <Cheery> so when you say in some pattern that: (x:xs), the left hand value is item in list and right hand value is the rest of the list.
02:04:14 <nornagon> whee, it works
02:04:17 <Syzygy-> Cheery: Ayup.
02:04:20 <kaspyanand> Cheery:thks got it
02:04:26 <quicksil1er> (and : is right associative so that really means 1 : (2 : (3 : []))
02:04:27 <nornagon> i have now liberated my timetable program from ruby :)
02:04:28 <Cheery> head (x:_) = x
02:04:32 <Syzygy-> Hrm. Ooops. Misinterpreted the direction of explanations. Sorry.
02:04:33 <Cheery> tail (_:xs) = xs
02:05:01 <hpaste>  nornagon pasted "A fortnightly timetable -- haskellish enough?" at http://hpaste.org/410
02:05:06 <kaspyanand> good explanation
02:05:12 <kaspyanand> another q
02:05:56 <kaspyanand> say a function is defined like square :: Num a => a -> a,what => means
02:06:11 <Cheery> It's inheritance.
02:06:12 <allbery_b> class context
02:06:29 <Cheery> it simply says that a must be of class Num
02:06:34 <allbery_b> several types can share an interface by being members of a typeclass
02:06:47 <allbery_b> typeclasses an't be named directly as types, so you use class contexts to name them
02:06:52 <quicksil1er> I don't think 'inheritance' is a good word for it to be honest
02:07:07 <ivanm> nornagon: so how does programming your timetable differ from just writing it out?
02:07:08 <quicksil1er> It's an extra requirement, which I would read as an "if"
02:07:17 <Cheery> hmm.
02:07:25 <allbery_b> so that declaration says that given a type a which is a member of typeclass Num, square is a functon from an a to an a
02:07:26 <quicksil1er> square : "If 'a' is a Number, then a -> a "
02:07:43 <quicksil1er> or, if you prefer "For all 'a' which are Numbers, then a -> a "
02:08:02 <Cheery> quicksil1er: so does it mean that you can have an alternate type definition which says how does it go for something else?
02:08:20 <Cheery> like, if a is not Number, then the type definition does not apply?
02:08:37 <kaspyanand> Cheery:yes it wont apply
02:08:50 <nornagon> ivanm: it means I can do $ tt on the command line and not have to worry about which day or week it is :)
02:08:53 <nornagon> it's very handy
02:09:00 <allbery_b> you can't delcare another square with a different signature, no
02:09:01 <Cheery> http://en.wikibooks.org/wiki/Haskell/Class_declarations#Class_Inheritance
02:09:04 <lambdabot> http://tinyurl.com/2yqzm3
02:09:21 <allbery_b> but you *could* declare a new type which is a member of class Num, and square will work with it unchanged
02:09:54 <allbery_b> as long as your new type implements all the required instance functions for Num
02:09:56 <ivanm> nornagon: each to their own, I suppose... I've always just printed it out on a piece of paper, so I don't have to turn my computer on in the morning to find out what classes I've got!!!
02:10:06 <quicksil1er> Cheery: class inheritance in that sense is when you have two classes
02:10:11 <ivanm> nornagon: (besides, I normally memorize it after a few weeks)
02:10:15 <quicksil1er> Cheery: 'Ord' has everything 'Eq' has, plus more!
02:10:32 <quicksil1er> Cheery: but in kaspyanand's square example there is only one class involved, not two
02:10:41 <ivanm> nornagon: nice concept, though
02:11:07 <nornagon> ivanm: I leave my laptop on overnight usually
02:11:14 <quicksil1er> ivanm: you turn your computer off? *shudder*
02:11:24 <quicksil1er> I don't know where the off button is on my computer, I'm not sure it has one.
02:11:48 <allbery_b> the last time I turned off this machine it was to upgrade its RAM
02:11:50 <ivanm> quickil1er: if I don't turn it off, 1) my parents are annoyed at power wastage, 2) the power pack is too hot for me to pack my laptop up in the morning ;)
02:11:53 <nornagon> quicksil1er: :D
02:12:23 <nornagon> I usually take the battery out when it's not actually running off it or charging it
02:12:24 <ivanm> nornagon: so whats the significance of the codes after software and chemistry?
02:12:37 <nornagon> ivanm: rooms; those classes move around
02:12:39 <ivanm> and I suppose you memorise rooms, etc?
02:12:59 <nornagon> well I know where the rooms are; I'm just not always sure which class is where
02:13:18 <ivanm> OK... (i've got a different room every day for most classes)
02:13:19 <nornagon> and I can't really be bothered memorising it
02:13:25 <nornagon> that sounds too much like hard work
02:13:48 <ivanm> i don't do it consciously... just start remembering where i'm meant to go next
02:14:12 <nornagon> ah, heh
02:14:22 <nornagon> usually I just use this to work out what i have first
02:14:33 <nornagon> so i don't have to go hunting for my timetabel
02:14:35 <nornagon> ble
02:16:58 <kaspyanand> when we write \x->x*x it is same as square x=x* x rite?
02:17:15 <allbery_b> yes
02:17:33 <allbery_b> that's a lambda abstraction (anonymous function)
02:17:35 <ivanm> but square is named
02:17:47 <ski> square = \x -> x*x
02:18:00 <kaspyanand> yes lambda abstraction,why we use it?
02:18:16 <kaspyanand> since i can just say square x=x*x
02:18:27 <Saizan> because it's often handy to write small functions inline
02:18:34 <allbery_b> consider a list of numbers, where you want to square every number in the list
02:18:35 <ski> > map (\x -> 10*x - 3) [5,4,20]
02:18:37 <lambdabot>  [47,37,197]
02:19:03 <allbery_b> or that for a slightly more complex example
02:20:06 <vincenz> > map ((substract 3) . (*10)) [5,4,20]
02:20:07 <lambdabot>   Not in scope: `substract'
02:20:11 <vincenz> > map ((subtract 3) . (*10)) [5,4,20]
02:20:12 <lambdabot>  [47,37,197]
02:20:33 <nornagon> anonymous inline functions are very handy.
02:20:51 <ivanm> vincenz: is subtract the same as (-)?
02:20:51 <allbery_b> in a functional programming language, functions are values.  you can create them on the fly, or even modify them (think of map as taking a function a -> b and producing a new function [a] -> [b])
02:20:55 <nornagon> the lambda notation is almost unnecessary, though, when you use pointfree style.
02:21:08 <nornagon> (pointfree stuff can't do pattern matching, as far as I'm aware.)
02:21:10 <ivanm> except when the pointfree style is too ugly
02:21:18 <ski> @src subtract
02:21:19 <lambdabot> subtract x y = y - x
02:21:24 <nornagon> @pl (\(x:xs) -> xs)
02:21:25 <lambdabot> tail
02:21:27 <ivanm> ahhh.....
02:21:28 <nornagon> :O
02:21:32 <nornagon> @pl (\(x:xs) -> xs:x)
02:21:33 <lambdabot> ap (flip (:) . head) tail
02:21:35 <allbery_b> ivanm: subtract is a workaround for the odd parsing of (-)
02:21:45 <nornagon> so @pl does list pattern matching, then
02:21:48 <ivanm> allbery_b: in what way is it odd?
02:21:53 <allbery_b> since (-1) is read as negative one, not as a section
02:21:53 <ivanm> as in not associative?
02:22:03 <ivanm> OK, right, didn't think of that
02:22:06 <allbery_b> so you use (subtract 1) instead
02:22:08 <nornagon> @pl (\(a:+b) -> show a ++ "+i" ++ show b)
02:22:09 <lambdabot> (line 1, column 6):
02:22:09 <lambdabot> unexpected "+"
02:22:09 <lambdabot> expecting natural, identifier, "_" or "("
02:22:24 <ivanm> lol
02:26:16 <loka> I once heard someone say they could make a scheme interperter with less than a thousand lines of code. I was wondering where I could look at the source.
02:26:30 <loka> or rather saw someone type
02:27:02 <kaspyanand> are there any open source projetcs where haskell is being used?
02:27:18 <loka> multitudes
02:27:24 <ivanm> darcs, pugs, LB, hpaste...
02:27:41 <quicksil1er> nornagon: point-free pattern translations require the existence of appropriate catamorpism, basically
02:27:42 <allbery_b> @go scheme interpreter in 48 hours
02:27:44 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
02:27:44 <lambdabot> Title: Write Yourself a Scheme in 48 hours
02:27:48 <allbery_b> that, I think
02:27:50 <Cheery> wow, state transformers are a quite whores!
02:28:06 <quicksil1er> nornagon: @pl knows some of the simple ones
02:28:10 <loka> allbery_b: ki'e(thanks)
02:28:18 <quicksil1er> nornagon: like (,) and (:)
02:28:59 <kaspyanand> i am at a learning stage,can I join these projects
02:29:25 <quicksil1er> kaspyanand: well clearly you can download the code and examine it and play with it
02:29:30 <quicksil1er> kaspyanand: thta is the nature of open source
02:29:44 <allbery_b> #perl6 always looking for contributors :)
02:29:47 <kaspyanand> quicksil1er:yes
02:29:47 <rahikkala> ~/scheme_in_48/code $ cat *|sort|uniq|wc -l
02:29:48 <rahikkala> 492
02:29:48 <allbery_b> (pugs)
02:29:51 <quicksil1er> kaspyanand: as to whether you can contribute, most projects make that decision once you show them something *to* contribute. I.e. a patch
02:30:00 <kaspyanand> ok
02:30:06 <quicksil1er> allbery_b: I don't think pugs is a good newbie project :P
02:30:34 <ivanm> quicksil1er: so what _would_ you consider to be a good newbie project?
02:30:42 <allbery_b> there is that :) although even newbies can contribute tests once they wrap their heads around the synopses and start playing
02:31:02 <ivanm> but wouldn't you have to know perl to be able to contribute to pugs?
02:31:17 <allbery_b> perl5 knowledge is not so useful with perl6
02:31:35 <quicksil1er> I think without knowing perl you wouldn't have much *motivation* to contribute to pugs :P
02:31:42 <quicksil1er> what's the point, if you don't use the language?
02:32:14 <ivanm> true
02:33:34 <kaspyanand> what language would u suggest for a person just starting in programming field,doing CS-java,c++,Scheme or Haskell,python?
02:34:18 <quicksil1er> kaspyanand: doing CS as a carerr? or CS for fun? or CS for education?
02:34:30 <pejo> kaspyanand, considering the channel you're in, people are going to say Haskell.
02:34:34 <ivanm> the problem with python, IMHO, is that if you use it as an introductory language, it will get you into bad habits
02:34:48 <Cheery> kaspyanand: I'd suggest such person to learn lambda calculus.
02:34:49 <ivanm> java is a pretty good language, for OO
02:35:03 <Cheery> python, java and c++ in that list are ridiculous choices.
02:35:09 <quicksil1er> kaspyanand: for a career I'd probably be forced to suggest Java. For fun or learning I'd suggest haskell.
02:35:39 <quicksil1er> Cheery: that's your opinion. I'd choose java over scheme any day of the week.
02:35:45 <quicksil1er> I'd rather have types...
02:36:07 <ivanm> Where do I find the profiling libraries for the mtl package? I'm importing Control.Monad.List, but whenever I want to profile my code I have to import Control.Monad and Data.Map instead...
02:36:46 <Cheery> quicksil1er: well, now when I've learned haskell, those all languages seem like odd choices.
02:37:10 <Cheery> it has really shuffled my opinions about languages. :)
02:37:51 <Cheery> mostly static typing with inference.
02:38:49 <Cheery> currently I keep explicit static typing worse than dynamic typing, but implicit static typing better than dynamic.
02:39:48 <quicksil1er> Cheery: msot of the denizens of this channel recommend explicitly typing your haskell
02:39:57 <quicksil1er> Cheery: although personally I'm not sold on the idea
02:40:22 <pejo> Part of the reason for that seems to be the bad reporting of type errors otherwise.
02:41:08 <allbery_b> the problem with type inference is that a function's type may be modified froma distance by a use of that function
02:42:09 <Cheery> allbery_b: but it's great thing to leave away types when they are very obvious.
02:42:09 <allbery_b> this makes diagnosing type errors somewhat difficult; it's easier if you explicitly type things because the mismatch between the expected and inferred types will be caught where it happens, instead of where the com[piler discovers that something doesn't match
02:42:56 <quicksil1er> it makes diagnosing type errors an acquired art
02:43:00 <quicksil1er> but you get the hang of it
02:43:09 <quicksil1er> personally I copy-paste sub-expressions into ghci
02:43:16 <quicksil1er> if I'm really stuck
02:43:19 <quicksil1er> and piece it together
02:43:58 <Cheery> I guess type inference makes it easier to define types afterwards anyway, you can just input the code into ghci and test what is it's type now.
02:44:08 <Cheery> Then copy&paste the type signature and constraint it.
02:44:19 <allbery_b> I also find that explicitly typing things helps as (a) documentation and (b) making me think through what exactly I'm doing
02:46:57 <quicksil1er> Cheery: true enough
02:47:00 <quicksil1er> allbery_b: valid point
02:47:01 <allbery_b> there are also performance reasons for explicit typing:  Haskell will happily infer a polymorphic type which may end up being slower than a simple type
02:47:07 <quicksil1er> allbery_b: especially for external inferences
02:47:15 <quicksil1er> erm
02:47:19 <allbery_b> ...but that probably matters only whn you get to the optimization stage, in a program that really needs it
02:47:24 <quicksil1er> external exports, I mean I think
02:47:39 <quicksil1er> I was reading your next sentence whilst typing my last and the words got muddled
02:47:53 <pejo> allbery_b, that's a compiler deficiency though. If it knows that the only instance is for a certain type it should create that function instead.
02:48:02 <pejo> Well, unless modules and all those other issues, of course.
02:48:58 <allbery_b> modules are the sticky point I see.  sure, it could be done if you compile everything as a single unit, but that means you can't really have library modules
02:49:11 <allbery_b> (precompiled that is)
02:49:12 <quicksil1er> that's a well-known problem with the language though
02:49:21 <quicksil1er> it really 'needs' whole program compilation
02:49:33 <quicksil1er> to be able to sensibly optimise the abstractions it provided
02:49:35 <quicksil1er> provides
02:49:39 <pejo> allbery, if you're that worried about performance, I don't think you mind taking the hit from compiling it all at once.
02:50:06 <quicksil1er> there was a message on the list thismorning about a program which rebuilds your program as one module and recompiles it
02:50:12 <quicksil1er> so that ghc can 'see everything' at once
02:50:33 <allbery_b> yeh
02:51:00 <ivanm> there was? what is it?
02:51:28 <allbery_b> @go haskell all-in-one
02:51:32 <lambdabot> http://hal3.name/HAllInOne/index.html
02:51:33 <lambdabot> Title: Haskell All-In-One
02:51:51 <allbery_b> hm, that's not the link from the message :/
02:52:03 <quicksil1er> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022294.html
02:52:06 <lambdabot> Title: [Haskell-cafe] Monolithic module tool, http://tinyurl.com/2znmzl
02:52:16 <ivanm> would this improve performance?
02:52:40 <allbery_b> however it's correct :)
02:52:47 <quicksil1er> ivanm: only if your performance was constrained by ghc's inability to do cross-module optimisatoin
02:53:15 <ivanm> quicksil1er: in what way? (i.e. what do you mean by cross-module optimisation?)
02:54:10 <quicksil1er> ivanm: for your matrix program the answer is almost certainly 'no'
02:54:15 <quicksil1er> ivanm: although there's no harm trying it
02:54:39 <ivanm> quicksil1er: I didn't think so, as the only reason I modularised it was so that I knew how to make modules ;)
02:54:44 <allbery_b> ivanm: the case of ghc not recognizing that it needs only e.g. a Double version instead of a pol;ymorphic version of a funcntion
02:54:51 <pejo> ivan, suppose your module contains the ordinary map function. If your program only calls it with the first parameter "square" the compiler could instead create a map_{square} that only takes a list as parameter.
02:54:55 <ivanm> ahhhh, ok
02:54:56 <allbery_b> ...because the uses are in a differentr module
02:55:06 <ivanm> that makes sense
02:55:27 <allbery_b> of course, with ghc you can also hack around it with SPECIALIZE pragmas
02:55:36 <ivanm> so putting it all into one, large super-module lets it optimise further by knowing exactly when each function is called and by what?
02:56:09 <allbery_b> yes, so it doesn't need to unnecessarily make something polymorphic because it knows how it's being used
02:56:36 <ivanm> and would it make seperate map_{square} and map-{return}, say functions?
02:56:46 <ivanm> or leave it as polymorphic if used multiple times?
02:57:07 <allbery_b> I don't know if ghc does that kind of optimization
02:57:09 <quicksil1er> I'm not sure any of us know exactly how the GHC optimiser works
02:57:13 <quicksil1er> I know I don't :)
02:57:16 <ivanm> lol
02:57:19 <quicksil1er> I'm not even sure if it's documented...
02:57:28 <pejo> ivanm, that depends on the compiler. It's not always a win to have large linear code.
02:57:39 <allbery_b> there is a ghc hackers trac which might have some clues
02:57:52 <ivanm> slightly off topic then, apart from running ghc twice, is there a difference between using --make and compiling each module seperately?
02:57:58 <quicksil1er> ivanm: no
02:58:04 <quicksil1er> ivanm: btw are you useing -O2 ?
02:58:07 <ivanm> k, didn't think so
02:58:29 <ivanm> quicksil1er: yes, I'm also using -Wall -fvia-C -funbox-strict-fields
02:58:33 <pejo> quicksil1er, there's a paper on the inliner that is from this millenium. The ncg is rather simple, but the cross-module things we're talking about now is earlier than that. Gill's thesis covers short cut deforestation.
02:58:49 <ivanm> (I've managed to get the run-time for 4*4 squares down to 13 seconds!!! yay!!!)
02:59:21 <ivanm> I noticed, though, when I tried to use the INLINE pragma that it actually slowed the program... is this what you were talking about pejo?
02:59:55 <pejo> ivanm, yeah. Inlining isn't really well understood.
03:00:07 <allbery_b> IIRC from when they were optimziingmandelbrot that incautious use of NLINE can introduce extra thunks
03:00:41 <ivanm> well, the user guide said it might produce extra performance, so I tried it... didn't expect _too_ much from it, though
03:00:42 <pejo> Nods, excessive inlining in a lazy language removes sharing - and duplicates work.
03:01:24 <pejo> ivanm, well. Inlining just one thing might open up for other transformations that will help with the performance. But this is also rather hard to predict.
03:01:31 <quicksil1er> pejo: Yes, I'm waare of the thesis, I was more interested in docs on what GHC *actually* does
03:01:38 <ivanm> what exactly is inlining? is that like turning functions into lambda expressions and inserting them directly where they're used? like C macros?
03:02:01 <allbery_b> something like that, yes
03:02:16 <quicksil1er> ivanm: it's replacing a name with its definition
03:02:19 <quicksil1er> (typically a function
03:02:24 <pejo> quicksil1er, supposedly it does that. There are a couple of rewrite rules in GHC.List or similar places. (I asked the other day).
03:02:43 <ivanm> k, thought so, just wanted to check and see if my intuition was correct
03:04:26 <ivanm> would there be a performance hit if unused functions were present in the code? I would think that it would just bulk it up...
03:04:35 <quicksil1er> shouldn't be, no
03:04:43 <quicksil1er> in fact, the linker might well leave them out entirely
03:05:04 <ivanm> k, just curious
03:05:42 <quicksil1er> with the C backend it definitely will
03:06:14 <quicksil1er> since gcc has a smart link
03:11:08 <mr_tenor> is there a nice way to express numbers  in the type system? eg. a type "Foo a" where a is a number
03:11:34 <ivanm> a :: Foo?
03:11:48 <Botje> (Num a) => Foo a
03:11:51 <Botje> or something like it
03:12:08 <Botje> IANATSE
03:13:23 <mr_tenor> doesn't that mean that a is a type which implements Num?
03:13:27 <quicksil1er> yes
03:13:31 <mr_tenor> as opposed to an actual number, like "4"
03:13:35 <ivanm> 4 :: Int
03:13:50 <quicksil1er> @type 4
03:13:51 <lambdabot> forall t. (Num t) => t
03:14:12 <quicksil1er> mr_tenor: "4" is value of a type which implements Num :)
03:14:16 <quicksil1er> mr_tenor: but it doesn't know which type (yet)
03:14:23 <allbery_b> I'm not sire it makes sense to declare something to be of a type e.g. Foo 4
03:14:39 <quicksil1er> well it odes
03:14:46 <quicksil1er> lists_of_length 4
03:14:50 <ivanm> odes badly?
03:14:50 <quicksil1er> makes perfect sense :)
03:15:17 <quicksil1er> if that's really what mr_tenor is after, then the haskell type system isn't brilliant at it
03:15:20 <mr_tenor> yes, and for example I might want to write a function that only works on 2 lists of the same length
03:15:22 <allbery_b> not in haskell's type system :)
03:15:29 <quicksil1er> mr_tenor: that is very hard in haskell
03:15:35 <allbery_b> unless maybe if you're Oleg :)
03:15:37 <mr_tenor> in C++ i'm doing it with awful template hacks
03:15:41 <quicksil1er> of course you can get some type-level naturals
03:15:49 <Saizan> type level naturals?
03:15:50 <quicksil1er> Unit | Succ a
03:15:53 <ivanm> if ((length lst1) == (length lst2) then <foo> else error "not same length"
03:15:56 <quicksil1er> sort of stuff
03:16:04 <quicksil1er> ivanm: he wants it checked by the typecheckr
03:16:16 <mr_tenor> I could do dumb stuff like use "Foo a" and use dummy types for tags :P
03:16:22 <quicksil1er> mr_tenor: there are limited ways you can embed dependent typing via the class system but they're not very satisfying
03:16:24 <ivanm> quicksil1er: yeah, I realise that, but that's the only way I can think of doing it
03:16:35 <mr_tenor> runtime is deeply unsatisfying ;)
03:16:40 <allbery_b> there's also data MyList4 a = L4 a a a a
03:16:40 <quicksil1er> mr_tenor: you want epigram
03:16:49 <bakert> ?pl onCredit b = elem b ["a", "b", "c"]
03:16:49 <lambdabot> onCredit = flip elem ["a", "b", "c"]
03:16:51 <allbery_b> but you get to roll your own ops
03:17:09 <quicksil1er> mr_tenor: but people have written long articles about how far you can get in haskell
03:17:56 <quicksil1er> mr_tenor: our own ops
03:17:56 <quicksil1er> 11:15 < quicksil1er> mr_tenor: but peopl
03:17:59 <quicksil1er> bah
03:18:00 <quicksil1er> sorry
03:18:03 <quicksil1er> mr_tenor: http://okmij.org/ftp/Computation/lightweight-dependent-typing.html
03:18:05 <lambdabot> Title: Lightweight Dependent-type Programming, http://tinyurl.com/ylrm54
03:18:10 <quicksil1er> mr_tenor: is a reasonable summary
03:18:57 <pejo> mr_tenor, out of curiosity - why do you need this, and why not use a dependently typed language? Seems like a rather uncommon requirement.
03:19:56 <quicksil1er> pejo: it's a very common requirement
03:20:10 <quicksil1er> pejo: I've hardly written a program with more than 25 lines without wishing I had dependent types
03:20:24 <mr_tenor> pejo: writing stuff at work where we plug different components together, each having numeric input/output constraints. composability should be compiletime checkable, i figure.
03:20:30 <quicksil1er> pejo: but, it's a hard problem, and the existing dependent languages have their flaws
03:20:31 <pejo> quicksil1er, most folks don't have a phd.
03:20:51 <matthew-_> quicksil1er: I've hardly written a 25line depenedently typed program without wishing I had about 15 additional brains
03:21:01 <quicksil1er> epigram is extremely cool but not for practical use
03:21:06 <quicksil1er> (yet, anyway)
03:21:08 <pejo> mr_tenor, ah. Nods, that's desirable.
03:21:20 <quicksil1er> mr_tenor: the problem is that type inference becomes intractable, basically
03:21:32 <quicksil1er> mr_tenor: although there are ways to make various fractions tractable
03:21:35 <matthew-_> quicksil1er: that's an understatement. No ability to interact with the real world and compilation can take hours!
03:21:45 <mr_tenor> along the lines of that list example above... say a certain component outputs a list of length 3 and need 2 lists of length 4 as input. and so on. have i plugged them together correctly?
03:21:46 <JohnMeacham> hallow.
03:21:55 <JohnMeacham> anyone have any neural network code in haskell?
03:22:11 <quicksil1er> mr_tenor: but your type inferrer has to be able to solve general equations (which is obviously intractable, in general)
03:22:45 <JohnMeacham> I am more interesting in ideas on how to represent things, than a concrete implementation. (though, a concrete implemention would obviously be interesting.)
03:23:17 <ivanm> JohnMeacham: using google: http://ci.uofl.edu/tom/software/Haskell/
03:23:19 <lambdabot> Title: Haskell
03:24:19 <mr_tenor> if i used dummy types to represent numbers, I could do it just using standard algebraic types, so all I need is a countably infinite set of these dummy types indexed nicely ;)
03:24:27 <quicksil1er> mr_tenor: read that link
03:24:58 <quicksil1er> mr_tenor: but basically data Zero = Zero ; data Succ a = Succ a
03:25:08 <mr_tenor> quicksil1er: will do so :)
03:25:13 <JohnMeacham> yeah. those links are dead.
03:26:59 <ivanm> JohnMeacham: well, just googling "neural network haskell" (no quotes) gives a whole list of what seems to be papers discussing implementation techniques...
03:27:50 <mr_tenor> quicksil1er: like "data Nat = Zero | Succ Nat" ?
03:28:55 <mr_tenor> no, that wouldn't help :/ hmm...
03:30:47 <matthew-_> mr_tenor: the problem is that you want Zero and Succ to be constructors at the type level rather than value level. In Omega you can do this nicely, in Haskell you can't, which is why you have to have separate data declarations
03:32:48 <mr_tenor> yeah, i see now. one could typecheck by counting the "Succ"s in quicksil1er's definition
03:34:46 <ivanm> how could you do that for an arbitrary number of Succ's? (i.e. two values with the same, arbitrary number?)
03:34:51 <matthew-_> of course, the distinction is somewhat arbitrary. The thinking seems to be that stuff at the type level and above is "run" by the compiler, whereas stuff at the value level is for runtime. Epigram doesn't make this distinction which makes it more powerful, but also makes compilation a whole lot harder.
03:35:08 <mr_tenor> if i don't want to do arithmetic in the type system, it might be lett fugly to use tags like One, Two, Three etc. Of course, after I need to reconstruct arithmetic, I'll give up ;)
03:35:14 <mr_tenor> "less"
03:35:57 <matthew-_> ivanm: you tend to just care about whether it's zero or not.
03:36:09 <matthew-_> ivanm: eg rewriting head so that it can't work on an empty list
03:36:15 <matthew-_> that kind of thing
03:36:19 * allbery_b wonders if TH could be cajoled into doing this
03:36:21 <mr_tenor> matthew-_: yeah. you end up with a tiny sublanguage that you desperately try to express things in
03:36:29 <allbery_b> of course, then you get to deal with TH :)
03:36:33 <matthew-_> it's all about which additional properties you wish to model
03:36:56 <ivanm> matther-:_: k
03:37:02 <matthew-_> and carrying enough information around with the types so that the compiler can verify those properties
03:37:15 <mr_tenor> ivanm: i you have two inputs of type "Foo a" and one of the a's is "Succ Succ Succ Zero" then the other has to be as well, yeah?
03:38:01 <ivanm> mr_tenor: I wouldn't have a clue, but I don't think so... unless Foo a = Succ Succ Succ Zero
03:38:11 <ivanm> (but then the "a" becomes redundant)
03:38:12 <matthew-_> ivanm: I've not seen it with GADTs, but in Omega and Epigram there are also examples of, eg append (++) which returns a list which knows that its length is the sum of the lengths of the two input lists
03:38:17 <mr_tenor> "a" is just an arbitrary type there
03:38:35 <mr_tenor> logically, one of the "number"s i've been asking about
03:39:01 <ivanm> mr_tenor: whoops, misread it to mean a "type Foo a = ..."
03:39:04 <matthew-_> ivanm: and at that point you have to implement plus at the type level and you have to have some way of expressing all the properties (eg symmetric) of plus. This is where it gets slightly tricky
03:39:37 <mr_tenor> in C++ I've been using numeric template parameters and doing some awful code that will fail to compile if certain numbers aren't equal. But I can do arithmetic there too.
03:41:29 <mr_tenor> matthew-_: heh :)
03:41:30 <ivanm> matthew-_: what is Omega and Epigram? I've tried to look at their sites but there's not a lot of information there...
03:41:50 <quicksil1er> there are examples of how to do it on oleg's site
03:41:58 <quicksil1er> but type-level (+) is hard in haskell
03:42:06 <quicksil1er> and type-level (-) is a bloody nightmare, even in epigram
03:42:16 <matthew-_> Omega is index types which is a restricted form of dependent types. It's built on top of haskell but without the type classes
03:42:42 <ivanm> k
03:42:48 <quicksil1er> ivanm: epigram is a proof-of-concept program for a rather sophisticated subset of dependent types which can guess what program you're trying to write
03:43:03 <quicksil1er> ivanm: it is extremely clever, but not intended for real programs yet
03:43:24 <matthew-_> Epigram is dependent type language which in many ways feels in use more like a proof checker. The interface is somewhat quirky, to say the least, but it is very powerful, and I find it quite natural to work with, once you've rewired your brain ;)
03:43:37 <pjd> predictive typing, you could say (badum, tsh)
03:43:48 <ivanm> matthew-_: rewired = bludgeoned with a hammer? ;)
03:43:55 <matthew-_> ivanm: no, it's not that bad
03:43:55 * allbery_b gets a headache just from the description
03:44:10 <matthew-_> the code completion in epigram is staggaring though
03:44:43 <matthew-_> it's like @djinn but with enough information in the types that it really understands *how you should* write the rest of the current function
03:44:44 <quicksil1er> pjd: more like predictive coding, actually
03:45:09 <matthew-_> quicksil1er: do you work on Epigram?
03:45:09 <pjd> quicksil1er: i know, i was trying to be punny
03:45:25 <quicksil1er> matthew-_: no, but I have had long-ish chats about it with the team
03:45:54 <matthew-_> ahh. cool. I saw Conor give a workshop at RHUL over the summer. Quite jaw-dropping.
03:46:40 <quicksil1er> Conor typically is
03:46:44 <quicksil1er> Always the performer :)
03:47:03 <matthew-_> I guess it's how you make progress in the political world of academia
03:47:04 <matthew-_> ;-)
03:47:43 <quicksil1er> actually I'm not sure it is
03:47:50 <quicksil1er> at least, it's only one path
03:48:05 <mr_tenor> well, thanks heaps guys :)
03:48:08 <quicksil1er> many of the really good academics I have met are not really performers at all
04:02:21 <quicksilver> what? 15 minutes without conversation? unheard of!
04:02:56 <rahikkala> Well, certainly if there's no discussion then nobody should be hearing any discussion
04:06:40 <pjd> here's a question:  why aren't the comparison methods of Ord defined circularly?
04:07:48 <pjd> as opposed to <= being special (via compare)
04:08:18 <syntaxfree> @src (<=)
04:08:19 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
04:09:10 <syntaxfree> anyway. new rant!
04:09:53 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/09/for-whom-the-bell-tolls/
04:09:56 <lambdabot> Title: for Whom The Bell Tolls Â« Data.Syntaxfree, http://tinyurl.com/yodbk3
04:11:12 <therp> that's definately a rant :)
04:12:16 <syntaxfree> therp: you're definitely a speed-reader ; )
04:12:22 <ivanm> syntaxfree: what's this about closure in java? never heard of it (not even sure what it's refering too...)
04:12:41 <syntaxfree> ivanm: the article about closures in Java is linked.
04:12:45 <syntaxfree> "Elliot Harold".
04:13:05 <ivanm> OK, missed seeing that as a link
04:13:06 <syntaxfree> a haskeller's response is also linked.
04:13:25 * Cale fights for STM a bit more against people who don't appear to understand it very well.
04:13:41 <psnl> Cale: hint: the web is full of morons...
04:13:44 <rahikkala> syntaxfree: This is the web, you're supposed to form an opinion about an article by quickly scanning over it, looking at the lists and the bolded parts. That's why you use them when you write your blog :).
04:14:13 <psnl> Cale: you kill one moron, and a thousand more will raise in his place...
04:14:41 <therp> rahikkala: I feel a bit caught. that's exactly what I did :)
04:15:05 <Cale> psnl: indeed. There are even some otherwise pretty smart morons, it seems.
04:15:35 <ivanm> just so I can understand, what's an example of closure in haskell?
04:15:36 <quicksilver> it's the really sad side effect of being famous
04:15:43 <quicksilver> i *know* guido is a clever chap
04:15:57 <quicksilver> and I know if someone explained it to him in person, nicely, he'd feel stupid for saying that
04:16:05 <quicksilver> but now, because he's famous, his quote is up in lights
04:16:11 <quicksilver> and of course, now he will be defensive
04:16:14 <syntaxfree> it *is* an annoying quote.
04:16:19 <quicksilver> because it's hard to back down and say "I'm sorry, I was wrong"
04:16:23 <syntaxfree> c'mon, "our brains are wired for.."?
04:16:25 <quicksilver> syntaxfree: It's a really really stupid ignore quote
04:16:31 <quicksilver> syntaxfree: ignorant, I meant
04:16:36 <syntaxfree> that's a classic bigot quote.
04:16:39 <quicksilver> syntaxfree: but, guido himself is neither stupid nor ignorant
04:16:44 <quicksilver> so it's a terrible shame he said it :(
04:16:48 <Cale> When you become famous, it becomes *more* important to acknowledge when you were wrong, not less.
04:16:56 <syntaxfree> "Our brains are wired for heterosexual intercourse / monotheistic religion / monogamy / etc. etc."
04:17:00 <quicksilver> Cale: absoultely. but that doesn't make it easy
04:17:06 <quicksilver> Cale: at least, not for most people
04:17:24 <ivanm> I definitely think that the haskell version of list expressions is nicer than python's.... easier to learn the former, IMHO
04:17:25 <quicksilver> ivanm: a 'closure' is an expression containing variables, some of which are 'bound'
04:17:30 <syntaxfree> geek psychology is fragile, yet.
04:17:34 <syntaxfree> s/yet/yes
04:17:37 <xic> Cale: did you see this? http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf
04:17:39 <quicksilver> ivanm: haskell doesn't really "need" closures in the same way java does
04:17:44 <quicksilver> ivanm: because it's pure
04:17:58 <syntaxfree> ivanm: comprehensions are just syntax.
04:18:01 <quicksilver> ivanm: but notionally, in the partially applied function (\a b -> a + b) 5
04:18:14 <quicksilver> ivanm: you might say that function is passed around with a "closure which binds a to 5)
04:18:18 <syntaxfree> ivanm: Guido wants you to believe FP itself is all about syntax, which it isn't.
04:18:22 <Cale> I *really* hate how people are talking about closures as a language feature.
04:18:28 <ivanm> quicksilver: well, http://www-128.ibm.com/developerworks/java/library/j-cb01097.html says that "closure has long been a staple of languages such as List, Smalltalk and Hasekll."
04:18:30 <lambdabot> Title: Crossing borders: Closures
04:18:39 <Cale> Closures are not a language feature. They're an implementation of a language feature.
04:18:43 <quicksilver> ivanm: yes, that's sloppily worded
04:18:49 <quicksilver> ivanm: what Cale just said is the nub of the issue
04:18:49 <ivanm> OK
04:19:06 <ivanm> so what is closure, if not a language feature?
04:19:08 <quicksilver> ivanm: closures are a way of passing around a chunk of code "with some variables bound"
04:19:14 <quicksilver> it's more like a compiler feature
04:19:18 <quicksilver> or a compiler design choice
04:19:22 <syntaxfree> ivanm: anyway, I fixed that link to make it clearer. Thanks for the input.
04:19:24 <Cale> It's a way of implementing first-class functions.
04:19:24 <ivanm> a bit like "map ((+) 1)"?
04:19:48 <ivanm> OK
04:20:18 <TB> Hey :)
04:20:29 <Cale> Technically, you're storing code along with environments of variable assignments for that code to run in, and such a pair is a "closure", roughly speaking.
04:20:44 <ivanm> OK
04:21:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/411
04:21:06 <Cale> But the programmer doesn't touch the closures, they're something for the compiler writer to worry about.
04:21:31 <ivanm> btw, I know that side-effects are bad, but is there anyway to tell a program to print something inside a function, so that I can see how far along a program is going?
04:21:42 <TB> I'm reading the YAHT tutorial atm, but I'm having a little trouble with a function to show the factorial of all the numbers in a list. What I came up with is this: http://hpaste.org/411, but I somehow feel that the return 0 is obselete :/ is there any way to do this prettier ?
04:21:42 <allbery_b> Data.Trace.trace
04:21:50 <Cale> ivanm: Debug.Trace.trace
04:21:55 <allbery_b> sprry, Debug
04:22:06 <ivanm> OK, I'll have a look at that
04:22:09 * allbery_b shpould consider bed :/ odd sleep schedule after yesterday
04:22:13 <Cale> Though you don't want that for real output.
04:22:23 <Cale> It's 7am and I haven't slept :)
04:22:32 <quicksilver> TB: you're mixing calculation and showing, FWIW
04:22:38 <Cale> ivanm: basically, the "Debug" is there for a reason :)
04:22:55 * allbery_b enjoying lots of infections doing strange things to him
04:22:57 <xic> Cale: i have a question about monad transformers :|
04:22:57 <ivanm> Cale: yep, didn't even think of that
04:23:01 <Cale> If you stick values into a list, you can print the list, and the values will be computed as needed.
04:23:02 <quicksilver> TB: but you could get rid of the first return 0 entirely
04:23:33 <benja_> xic: so ask? :)
04:23:44 <Cale> showFactorials [] = return ()
04:23:52 <Cale> showFactorials (x:xs) = ...
04:24:10 <Cale> Would be one recursive option.
04:24:20 <ivanm> TB: would something like mapAccumR do what you want?
04:24:25 <Cale> another would be something like
04:24:39 <allbery_b> not sure antibiotics are actually doing the full job :(
04:24:59 <syntaxfree> antibiotics: your body has defenses to fight out infections; antibiotics are just helpers.
04:25:22 <TB> ivanm: I'm at page 36, I have no idea what mapAccumR does :P
04:25:23 <syntaxfree> I'd suggest you pay attention to your nutrition while you fight it out at least.
04:25:55 <Cale> showFactorials = sequence [ putStrLn $ concat ["Factorial of ", show n, ": " show (fac n)] | n <- l]
04:25:58 <quicksilver> ivanm: actually mapM is enough
04:26:05 <ivanm> TB: Well, I never went through YAHT...
04:26:06 <rahikkala> showFactorials = mapM_ (\item -> putStrLn $ "Factorial of "++(show item)++": "++(show (fac item)))
04:26:12 <Cale> Or a solution in terms of mapM, sure.
04:26:25 <quicksilver> @pl (\item -> putStrLn $ "Factorial of
04:26:26 <lambdabot> (line 1, column 22):
04:26:26 <lambdabot> unexpected "\""
04:26:26 <lambdabot> expecting space or simple term
04:26:27 <quicksilver>                    "++(show item)++": "++(show (fac item))
04:26:29 <quicksilver> bah
04:26:44 <ivanm> lol
04:26:44 <quicksilver> @pl (\item -> putStrLn $ "Factorial of"++(show item)++": "++(show (fac item))
04:26:45 <lambdabot> (line 1, column 74):
04:26:45 <lambdabot> unexpected end of input
04:26:45 <lambdabot> expecting variable, "(", operator, ":", "++", "$", "$!", "`seq`" or ")"
04:27:23 <quicksilver> @pl \item -> putStrLn $ "f"++(show item)++":"++(show (fac item))
04:27:23 <lambdabot> putStrLn . ('f' :) . liftM2 (++) show ((':' :) . show . fac)
04:27:25 <allbery_b> @pl (\item -> putStrLn $ "Factorial of"++(show item)++": "++(show (fac item)))
04:27:26 <lambdabot> putStrLn . ("Factorial of" ++) . liftM2 (++) show ((": " ++) . show . fac)
04:27:32 <Cale> hehe
04:27:39 <Cale> I knew it'd butcher that :)
04:27:48 <quicksilver> I would suggest that's not a good time to use pointfree :) But it sure is cute, in a twisted way.
04:28:09 <ivanm> very twisted...
04:28:42 <ivanm> @unlambda putStrLn . ("Factorial of" ++) . liftM2 (++) show ((": " ++) . show . fac)
04:28:42 <lambdabot>  unlambda: Unknown operator 'p'
04:28:48 <TB> blegh... /me longs back to imperial languages :(
04:28:59 <allbery_b> thta's not what unlambda does
04:29:07 <Cale> unlambda is presumably an interpreter for unlambda which is a programming language
04:29:23 <Cale> http://www.madore.org/~david/programs/unlambda/
04:29:24 <ivanm> isn't it? I thought that wa the point of it (un-pl-ing code)...
04:29:25 <lambdabot> Title: The Unlambda Programming Language
04:29:28 <rahikkala> @unpl putStrLn . ("Factorial of" ++) . liftM2 (++) show ((": " ++) . show . fac)
04:29:29 <lambdabot> (\ j -> putStrLn ("Factorial of" ++ ((show >>= \ c -> (\ p -> ": " ++ (show (fac p))) >>= \ b -> return (c ++ b)) j)))
04:29:35 <Cale> oh, that would be unpl
04:29:37 <ivanm> oh, that's what I was thinking of
04:29:52 <ivanm> OK, even the pl versioin is nicer than that ;)
04:30:09 <ivanm> just interested in how could unpl was at reversing pl
04:30:18 <hpaste>  xic pasted "need help with MonadReader!" at http://hpaste.org/412
04:30:20 <benja_> showFactorials = mapM_ (\item -> printf "Factorial of %d: %s" item (fac item))
04:30:31 <benja_> s/%s/%d/
04:30:34 <xic> Cale: do you think you could please give a quick look at that?
04:30:42 <Cale> sure
04:30:43 <araujo> TB, An equivalent version, http://hpaste.org/411#a1
04:30:46 <xic> Cale: i can't figure out how to write the "local" function of MonadReader
04:30:49 <araujo> TB, probably more readable
04:30:57 <benja_> ?type local
04:30:59 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
04:31:36 <Cale> It usually will involve the 'run' function of your new monad.
04:32:01 <quicksilver> benja_: local 'temporarily' mutates the environment for one computation
04:32:17 <quicksilver> benja_: it is in some sense analogous to perl or lisp locals
04:32:46 <Cale> xic: Why are you not using Either?
04:32:56 <benja_> quicksilver: yes, I understand the type :)
04:33:08 <xic> Cale: i couldn't get that to work
04:33:22 <Cale> huh, okay
04:34:06 <hpaste>  araujo annotated "(no title)" with "Or better ....." at http://hpaste.org/411#a2
04:34:15 <benja_> xic: looks like you'd need to use runResponseActionResultT
04:34:49 <benja_> the problem seems to be that 'a' is a ResponseActionResultT instance, not a ReaderT instance
04:36:03 <benja_> ResponseActionResultT (local f (runResponseActionResultT a)) ?
04:36:17 <Cale> xic: You don't have MonadReader implemented for ResponseActionResultT
04:36:31 <Cale> so  local f a  won't work.
04:36:51 <xic> Cale: ResponseActionResultT isn't necessarily a MonadReader
04:37:40 <benja_> local f (RA (ResponseActionResultT a)) = RA (lift (local f a))?
04:37:47 <Cale> The idea behind local is that it's going to apply a function to the environment parameter and run the computation given with the new environment.
04:39:08 <benja_> but xic, if m is a MonadReader, so is ResponseActionResultT m, since it ResponseActionResultT m a = m (...)
04:39:30 <xic> benja_: right
04:46:23 <pjd> <syntaxfree> "Our brains are wired for heterosexual intercourse / monotheistic religion / monogamy / etc. etc."
04:46:29 <pjd> heh
04:46:32 <Cale> hmm, this would all be less irritating if the ReaderT was out one level.
04:46:40 <pjd> syntaxfree: you are trying to say that functional programmers are deviants? :)
04:47:05 <syntaxfree> haha. I'm trying to say Guido is a bigot.
04:48:53 <pjd> syntaxfree: i think what he says in that post should not be considered too far out of its context (that is, Python)
04:49:20 <syntaxfree> he says, "OUR BRAINS ARE WIRED". That's hard to take "out of context".
04:49:25 <syntaxfree> Unless his context is "nonhuman".
04:49:42 <araujo> what are you talking about?
04:49:48 <syntaxfree> he says "human brains are wired". It can't be taken out of context.
04:49:52 <pjd> araujo: scrollback :)
04:49:55 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/09/for-whom-the-bell-tolls/
04:49:58 <lambdabot> Title: for Whom The Bell Tolls Â« Data.Syntaxfree, http://tinyurl.com/yodbk3
04:50:00 <araujo> thanks syntaxfree
04:50:03 <syntaxfree> araujo: second blockquoted quotation.
04:50:08 <syntaxfree> the rest is irrelevant.
04:50:12 <pjd> syntaxfree: it can.  i understand "our" as referring to "prospective Python users".
04:50:28 <syntaxfree> he said "human brains".
04:51:13 <pjd> hmm, ok then
04:51:46 <pjd> i still maintain the post as a whole shouldn't be taken outside of the context of Python too much :)
04:51:48 <hpaste>  Cale annotated "need help with MonadReader!" with "(no title)" at http://hpaste.org/412#a1
04:51:53 <quicksilver> syntaxfree: FWIW, I think 3. Vested interests in making simple software complex is probably conspiracy paranoia
04:52:03 <quicksilver> syntaxfree: I agree wholehearted with 1. and 2. though
04:52:10 <xic> Cale: thanks!
04:52:10 <Cale> xic: there you go
04:52:40 * pjd suspects he'll never get an answer to the Ord question :(
04:52:41 <Cale> xic: Writing an instance of MonadReader with ReaderT underneath another layer can be annoying, so I swapped the two layers.
04:52:59 <Cale> pjd: Ord question?
04:53:09 <quicksilver> Cale: were you here last night for the discussion of what things haskell is bad at abstracting?
04:53:26 <Cale> not much of it, if any
04:53:39 <pjd> <pjd> why aren't the comparison methods of Ord defined circularly?
04:53:40 <xic> Cale: hm... interesting
04:53:50 <araujo> I didn't expect such an opinion from GvR
04:54:09 <Cale> pjd: Well, there are sensible defaults which would otherwise be circular.
04:54:24 <quicksilver> Cale: it strikes me that layers of monad transformers are a good example of a pattern that haskell can't abstract
04:54:28 <araujo> I personally think recursion is a more natural process to our brains than loops
04:54:30 <pjd> would otherwise be circular?
04:54:42 <quicksilver> araujo: I don't think he'd want to stand by that opinion if pressed on it, politely
04:54:56 <Cale> pjd: but any specific instance will provide a basis from which the rest can be derived through the defaults
04:54:57 <quicksilver> araujo: I think he simply said something stupid which he probably regrets now if he's honest about it
04:55:02 <quicksilver> araujo: (at least, I hope that)
04:55:16 <Cale> quicksilver: that's very true.
04:55:31 <Cale> quicksilver: I have a long something to say about that, and you can read it on my wiki.
04:55:40 <quicksilver> Cale: frustrating amount of boilerplate involved
04:55:45 <araujo> loops are more natural for machines ; and since programmers have grown up (most of them) from a machine perspective ; it's evident that looping will look more familiar for most of the programmers
04:55:50 <quicksilver> Cale: and, unfortunately, rather mindbending until you get used to it
04:56:02 <Cale> It's not really frustrating if you do things the right way, but there is boilerplate there.
04:56:06 <quicksilver> araujo: recursion is pplenty natural to machines, especially tail recursion
04:56:06 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
04:56:08 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
04:56:11 <pjd> Cale: right, but the Prelude's definition makes <= special, instead of being circular (so that you can define any operation and have the rest work)
04:56:18 <quicksilver> araujo: machines have JMP instruction, that's all it needs
04:56:23 <araujo> But our brain tend to be more of a recursive model.
04:56:41 <araujo> quicksilver, No more than looping.
04:56:57 <araujo> quicksilver, Our current machines are imperative by design.
04:57:01 <Cale> pjd: ah, that's interesting.
04:57:09 <pjd> Cale: it seems more arbitrary than i was expecting
04:57:12 <araujo> Blame Neuman for that :-)
04:57:13 <Cale> pjd: right, that's because it can't provide more than one default.
04:57:29 <Cale> pjd: and compare is tricky.
04:57:38 <quicksilver> Cale: very interesting, thank you
04:57:43 <pjd> more than one default?
04:57:47 <quicksilver> araujo: imperative and recursive are not orthogonal
04:57:57 <quicksilver> araujo: No *less* than looping either
04:57:57 <Cale> pjd: i.e. compare in terms of < or >
04:58:01 <araujo> quicksilver, i didn't say that.
04:58:13 <quicksilver> araujo: "< araujo> loops are more natural for machines"
04:58:15 <pjd> Cale: i'm not sure i understand
04:58:20 <araujo> quicksilver, But an imperative approach usually satisfy more a looping model.
04:58:26 <araujo> And not a recursive one.
04:58:32 <Cale> The implementation of compare there is written using <=
04:58:32 <quicksilver> araujo: I dont' agree
04:58:34 <araujo> Mainly for the way our machines are designed.
04:58:39 <quicksilver> araujo: not at all
04:58:39 <Cale> which is the only thing that makes <= special
04:58:41 <araujo> You don't have to
04:58:50 <quicksilver> araujo: recursion and iteration both require the 'JMP' construct, which all machines have
04:59:00 <Cale> but you can't provide another implementation of compare for it to use in case <= isn't there, but > is.
04:59:03 <quicksilver> araujo: there is no reason why machine architecture makes one preferable
04:59:19 <araujo> quicksilver, It's more  amatter of paradigm than implementation.
04:59:25 <Cale> and the other operations all already have defaults as well, in terms of compare
04:59:32 <quicksilver> further more, even when I program in imperative languages I use recursion very frequently
04:59:33 <pjd> Cale: but you wouldn't need to, when they're all defined circularly
04:59:43 <araujo> quicksilver, I never said you can't do it.
04:59:56 <quicksilver> araujo: so what are you saying, in fact?
04:59:57 <Cale> pjd: but to do that, you'd need to be able to have more than one default per function, but you can't.
05:00:08 <araujo> quicksilver, But it is more a matter of design; not of implementation.
05:00:08 <pjd> Cale: you don't need more than one default
05:00:14 <pejo> ara/quick, discussing what is "natural" doesn't really lead anywhere. Being taught either construction first will probably bias the result.
05:00:15 <Cale> oh?
05:00:31 <pjd> Cale: you can define all the operations as one circular chain
05:00:38 <araujo> quicksilver, That our current model of hardware design satisfy more an imperative approach; than a declarative one.
05:00:40 <pjd> with each depending on the next
05:00:45 <Cale> ah, yes, that's silly of me
05:00:51 <pjd> then, whichever one you make concrete make all the rest concrete
05:00:55 <araujo> quicksilver, That has big influence over what and how the programmers think.
05:01:14 <araujo> quicksilver, That's way looping might look more familiar to most of the programmers.
05:01:19 <Eelis> i'm having trouble with parsec. when i try:   parse (string "ax" `manyTill` string "ay") "" "axay"   the parse fails with the following error: (line 1, column 1) unexpected "x", expecting "ay".  it seems like parsec commits to the "ay" possibility the moment it succesfully parses "a". if that's the case, how do i get backtracking behavior?
05:01:20 <Cale> The problem with that approach is that it loses the efficiency that compare is supposed to buy you.
05:01:27 <araujo> s/way/why/
05:01:35 <quicksilver> araujo: ah!
05:01:39 <araujo> :-)
05:01:41 <quicksilver> araujo: well now I agree
05:01:42 <rahikkala> Eelis: try
05:01:43 <pjd> Cale: wouldn't the compiler be able to deal with the indirection?
05:01:50 <Cale> perhaps
05:01:52 <quicksilver> araujo: but first time you said 'recursive' and not 'declarative'
05:01:58 <quicksilver> araujo: that is very different indeed
05:02:02 <araujo> But i personally think that recursion is more natural for human brains
05:02:04 <Eelis> rahikkala: try what?
05:02:04 <Cale> But maybe not in 1998.
05:02:08 <araujo> Than looping.
05:02:26 <pjd> Cale: even so, it seems odd to base a decision like that on efficiency
05:02:31 <quicksilver> I strongly suspect that what is natural for a particular human being is determined entirely by their education and preference
05:02:36 <Cale> pjd: There are worse things than that.
05:02:47 <ToRA> Eelis: try is a parser/method in parsec, look it up in the docs, it should do what you want
05:02:51 <rahikkala> Eelis: Use try. "The parser (try p) behaves like parser p, except that it pretends that it hasn't consumed any input when an error occurs."
05:02:51 <quicksilver> the reason we churn out imperative programmers is because we teach them pascal, basic, VB and java
05:02:58 <pjd> i mean, for types where efficiency really matter, you'd probably provide direct implementations for them all anyway
05:03:05 <quicksilver> Eelis: it's called "try"
05:03:06 <araujo> quicksilver, and why we teach them that?
05:03:10 <Eelis> rahikkala/ToRA: ah, i see :) sorry, and thanks
05:03:16 <araujo> quicksilver, it will get you to my main point.
05:03:18 <quicksilver> araujo: because the people who run the universities are stupid, maybe?
05:03:23 <quicksilver> araujo: (I don't really think that)
05:03:34 <quicksilver> because we're stuck in a vicious circle
05:03:36 <araujo> quicksilver, i prefer to believe at my theory than yours :-)
05:03:39 <Cale> Eelis: no need to be sorry for asking questions around here :)
05:03:47 <quicksilver> we teach what people use (because that's what helps them get a job)
05:03:58 <quicksilver> then they use what we teach them (because that's what they know how to do)
05:04:13 <araujo> quicksilver, backus wrote a nice paper about this
05:04:20 <araujo> quicksilver, you might probably search for it
05:04:22 <quicksilver> some universities have experimented with FP as a first language course and it has been broadly succesful
05:04:32 <quicksilver> I *think* Graham Hutton did at Nottingham for a bit
05:04:41 <quicksilver> Imperial used miranda for many years
05:04:48 <ToRA> Imperial now uses Haskell
05:05:02 <pejo> Luleå/Chalmers used Haskell too. Unsure what Chalmers does, but Luleå ditched it.
05:05:08 <araujo> quicksilver, FP has been around for quite a long time.
05:05:26 <Eelis> rahikkala/ToRA: works like a charm. thanks again.
05:05:43 <araujo> quicksilver, Nevertheless ; it seems like it still is too shocking for many people.
05:05:50 <benja_> http://www.cs.chalmers.se/Cs/Research/Functional/
05:05:53 <lambdabot> Title: The Multi Group
05:05:58 <benja_> "The functional programming research is mainly centered around the programming language Haskell."
05:06:18 <SamB> benja_: what else?
05:06:26 <pejo> benja, Josef Svenningsson had an interesting thing about being the last functional programmer at chalmers.
05:06:31 <pejo> In his blog.
05:06:32 <emk> syntaxfree: That's an entertaining rant you have on resistance to learning new things.
05:06:40 <benja_> hm, right, you were talking about teaching not research =)
05:06:43 <benja_> sorry, misread
05:06:56 * araujo never found his way through python btw :-)
05:07:13 <quicksilver> araujo: *programming* is shocking for many people
05:07:26 <quicksilver> I've taught people who found java extremely mind bending
05:07:36 <quicksilver> personally I don't think they'd have found haskell any *worse*
05:07:40 <quicksilver> (obviously I can't tell)
05:07:54 <quicksilver> haskell has obviously trivial advantages too, like a REPL
05:08:04 <SamB> My physics teacher wishes they would talk about Gauss's law WRT gravitation as well as WRT electricity in physics books
05:08:04 <Laney> Graham Hutton is lecturing me now! :O
05:08:05 <quicksilver> learning with a REPL is so much nicer than a edit-compile-sob loop
05:08:10 <pejo> Fp seems mainly to be mind stretching to those who already know some imperative language.
05:08:18 <SamB> I'm inclined to agree
05:08:19 <quicksilver> Laney: say hello from me then, although he won't remember me
05:08:23 <SamB> that law is damn handy
05:08:32 <Laney> quicksilver, you went to Notts?
05:08:43 <benja_> I hated the one intro to programming through haskell course I've seen
05:08:44 <quicksilver> Laney: no, but we crossed paths a few times
05:08:53 <quicksilver> Laney: he organised a conference I attended
05:08:58 <benja_> but it was the professor, really, not the language
05:09:15 <SamB> and could be used to prove that large spherical masses can be treated as points with relative ease, to boot
05:09:24 <Laney> quicksilver, ah. I do his Advanced Functional Programming module currently. http://www.cs.nott.ac.uk/~gmh/afp.html
05:09:27 <lambdabot> Title: Advanced Functional Programming
05:09:29 <benja_> the intention was to use haskell to put people who had previous programming experience on the same footing as people who hadn't
05:09:53 <SamB> benja_: wouldn't that give the non-programmers better footing?
05:09:56 <SamB> no?
05:09:58 <benja_> but the professor kept referring to imperative languages
05:10:04 <SamB> eek!
05:10:20 <SamB> well. he should have reffered to algebra more.
05:10:57 <quicksilver> that's counter-productive too
05:11:00 <benja_> and then stuff like: "What do we want from a programming language? Hierarchical namespaces" (<-- no explanation of what those would be IIRC)
05:11:10 <quicksilver> all the people I taught programming to hated algebra
05:11:15 <quicksilver> and believed they hated maths
05:11:22 <quicksilver> (ok, not quite 'all'. But 85%+)
05:11:29 <araujo> :-)
05:11:42 <SamB> hmm. http://syntaxfree.wordpress.com/ is not high enough on google. I'll mention it here, hoping that google follows URLs in text files.
05:11:44 <lambdabot> Title: Data.Syntaxfree
05:12:29 <SamB> I cannot understand people who actually hate learning
05:12:42 <SamB> I can easily understand people who hate school though ;-)
05:12:58 <quicksilver> SamB: many of them may not understand the difference
05:13:01 <pejo> The really odd combination is people who go to school and hate learning though.
05:13:04 <benja_> hehe, now I can see it. Welcome to our Intro to Programming course! Let us have some definitions first. A *category* is a collection of *objects* and *arrows*, where each arrow connects two objects. A *cartesian closed category* is...
05:13:20 <quicksilver> pejo: I don't think it's that odd. They go to school to get a job to get rich
05:13:26 <quicksilver> pejo: they don't expect to enjoy it
05:13:32 <SamB> quicksilver: okay, I can understand people who believe that they hate learning because they believe it to be what they have been doing in school
05:13:37 <mauke> benja_: that would be awesome
05:13:40 <quicksilver> SamB: exactly
05:13:45 <pejo> quicksilver, and somehow skip out learning the math, since CS is just programming anyways?
05:13:53 <earthy> awesomely insane
05:14:00 <quicksilver> pejo: they don't realise that maths in involved until much too late
05:14:04 <quicksilver> pejo: or they never realise
05:14:06 <benja_> I think it would believably put people who know imperative languages and people who don't on the same footing -]
05:14:16 <quicksilver> pejo: certainly they don't realise at the point that they apply
05:14:48 <mauke> sigh. I hate you, notFollowedBy!
05:14:49 <SamB> I was warned
05:15:12 <benja_> I think I've succesfully managed to weasle through all math courses in my curriculum
05:15:33 <benja_> which is good, because math courses don't agree with me -)
05:15:37 <SamB> it doesn't hurt that I aquired TAOCP before college
05:15:48 <SamB> or that I started on Haskell before college
05:16:05 <benja_> learning the math necessary for some specific task I'm doing comes much more easily
05:16:26 <Cale> xic: that's an interesting paper on concurrency. I agree insofar as I think that we ought to try to avoid nondeterminism where possible, but I'm unconvinced that it should be discarded altogether for ordinary applications.
05:16:40 * earthy suddenly understood projective geometry after thinking about gps. :)
05:17:14 <earthy> samb: taocp is... tough reading. :)
05:17:16 * Thunder is unable to edit http://www.haskell.org/hawiki/HaskellUserLocations ... IOError: [Errno 13] Permission denied: 'data/pages/HaskellUserLocations/last-edited'
05:17:18 <lambdabot> Title: HaskellUserLocations - The Haskell Wiki
05:17:24 <Cale> Thunder: log in.
05:17:30 <Laney> I was rather naive about the mathsiness, but actually quite enjoy it luckily :)
05:17:41 <earthy> thunder: you shouldn't edit hawiki anyway
05:17:45 <SamB> earthy: yeah
05:17:49 <earthy> the page should be used to haskellwiki
05:17:58 <Cale> moved*
05:18:05 <earthy> thanks cale :)
05:18:20 <DannoHung> They don't really tell you what math classes you really oughta take but aren't required to at my school... I am rather upset with some of the administrators in our CS department because of this.
05:18:24 <SamB> I know someone who is in CS and not engineering because he doesn't know maths too well... perhaps I should warn him...
05:18:29 <earthy> samb: I did find a small infelicity in one of the taocp's once. got the check to prove it. :)
05:18:41 <malcolm> dino-: about getting plain text from HTML out of HaXml, have you tried the Xtract tool?  Xtract "//-"
05:18:41 <SamB> infelicity?
05:18:50 <SamB> earthy: did you check the errata?
05:18:51 <quicksilver> since random numbers are always a hot topic here : http://xkcd.com/c221.html
05:18:52 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:18:53 <Cale> I like how at Waterloo, CS is a school of the Mathematics Faculty.
05:19:17 <Cale> That's the way it ought to be, in my opinion :)
05:19:17 <earthy> SamB: I've got a letter from Knuth and a check, acknowledging that this was indeed somewhat in error. :)
05:19:26 <benja_> SamB: apparently, since knuth wouldn't've written a check for something not in the errata :)
05:19:34 <benja_> s/not/
05:19:35 <SamB> earthy: ah
05:19:41 <benja_> s/not //;
05:19:44 <DannoHung> On the other hand, considering that there's no Software Engineering major at my school (not that I think they'd run that competently either), they also don't tell you which design classes you probably oughta take either.
05:19:53 <hpaste>  Jim pasted "seating plan puzzle" at http://hpaste.org/413
05:20:06 <ivanm> Cale: I wish it was at my uni... they apparently offer a dual Maths/CS honours, but no-one seems to know anything about it :(
05:20:07 <Cale> The best thing to do if you want to be in CS, but you're weak in mathematics is to do a pure mathematics undergrad :)
05:20:10 <earthy> Simon Stevin couldn't have been of Belgium, as Belgium didn't exist when Simon Stevin lived.
05:20:10 <SamB> earthy: I was gonna suggest going for one of those if it wasn't in the errata ;-)
05:20:14 <cjeris> Cale: my school (Chicago) didn't offer a CS degree until a year after me; there was only "bachelor's in math with specialization in computer science".  Of course this was partly because the CS department, at that time, was bad.
05:20:24 <SamB> benja_: if it was in the errata, that would mean someone had found it!
05:20:30 <SamB> which means no check
05:20:44 <cjeris> This was before they got half of PLT and a bunch of other people.
05:21:15 <benja_> SamB: that's what I was *trying* to say ;)
05:21:17 <SamB> hmm, I wonder if anyone has written him about the lack of peripheral devices for his MMIX computers...
05:21:22 <Thunder> Cale: I'm logged in.
05:21:27 <SamB> benja_: oh ;-)
05:21:28 <earthy> samb: that is a design choice
05:21:37 <Cale> oh, that's odd then
05:21:54 <Cale> Thunder: we should really get someone to move that to the new wiki :)
05:21:59 <SamB> earthy: I don't think so... I think must have forgotten, since he said something about implementing NNIX...
05:22:20 <Thunder> cale: Remove Python should be enough.
05:22:44 <earthy> no, I'm pretty sure about that. MMIX is an instruction set architecture rather than a computer system architecture
05:22:58 <SamB> I don't like the way the GNU MMIX ABI does relocations, either...
05:23:04 <SamB> earthy: hmm.
05:23:11 <SamB> what are you supposed to do?
05:23:40 <SamB> get some kind of generic PCI motherboard and put it on that?
05:23:57 <SamB> I think the MMU sucks, too...
05:25:07 <quicksilver> Cale: is there a commonly accepted name for the problem where f has some algebriac type, and I know from the defn of f that in fact it could only contain some constructors and not others?
05:25:13 <quicksilver> Cale: (but the type system doesn't know this)
05:25:17 <Thunder> The content is changed, the reason for this error message was a "simple" race condition. There is really a need for a new wiki.
05:25:22 <SamB> hmm, how does syntaxfree's blog have these thumbnails of link targets?
05:25:37 <SamB> oh, something called snap...
05:25:41 <SamB> I've seen that before...
05:25:59 <xic> SamB: i find them quite annoying
05:26:06 <SamB> xic: you can turn them off
05:26:11 <SamB> click on options
05:26:30 <benja_> I thought it was a smart idea when I first saw them recently
05:26:38 <xic> SamB: would rather not see them in the first place
05:26:41 <benja_> although somewhat annoying =)
05:26:44 <Cale> Thunder: It's already implemented, and most of the content has been moved over. haskell.org puts you there.
05:26:56 <SamB> xic: well tell syntaxfree
05:27:15 * xic instructs syntaxfree to remove that "snap" shit from his blog :P
05:29:45 <earthy> http://www.haskell.org/haskellwiki/HaskellUserLocations
05:29:46 <lambdabot> Title: HaskellUserLocations - HaskellWiki
05:29:46 * earthy whistles
05:32:44 <emk> Huh. I can't get GHC rewrite rules to apply, not even the standard ones, as far as I can tell.
05:33:06 <emk> I'm using -O and -ddump-rules, and it claims to be using an empty list of rules.
05:33:38 <dcoutts> emk, and -fglasgow-exts ?
05:34:37 <emk> dcoutts: Ah, that does it.
05:34:53 <emk> So even the standard built-in rules fail to fire without -fglasgow-exts?
05:34:56 <dcoutts> you need that for it to parse the RULES sections
05:36:01 <emk> dcoutts: Even if I have no RULES section in my own code, leaving out -fglasgow-exts will keep the built-in rules from firing.
05:36:11 <dcoutts> hmm
05:36:19 <dcoutts> that's not what I'd expect
05:36:42 <emk> dcoutts: Well, that's what the -ddump-rules output suggests, at least.
05:37:10 <emk> There's really no way to confirm it, since the built in rules don't change the program's meaning.
05:37:11 <dcoutts> emk, look at -ddump-simpl-stats and look for how many rules fired
05:37:58 <emk> Huh, that claims they're running, but -ddump rules claims they aren't.
05:38:00 <emk> So it
05:38:08 <emk> it's an output issue...
05:38:15 <dcoutts> maybe
05:39:16 <pjd> Cale: re. earlier, surely closures are language features?
05:39:47 <Cale> pjd: no, they're an implementation of a language feature, specifically, first-class functions.
05:39:48 <quicksilver> pjd: no, they're a technique for implementing a feature
05:40:32 <quicksilver> e.g. the following javascript:  a = 5; return function() {return a}
05:40:35 <vincenz> Cale: no, closures are first-class functions that are lexically bound
05:40:50 <quicksilver> that builds a closure (containing the value of a at the time)
05:40:56 <pjd> you can have first-class functions without them being closures, though
05:41:00 <quicksilver> but the closure doesn't appear in the language
05:41:03 <emk> Cale: Well, you can have (far less useful) first-class functions without closures, you just can't create any at runtime...
05:41:14 <pjd> and you can implement closures without the function+environment technique
05:41:17 <vincenz> emk: yes you can, that's called dynamic scoping
05:41:21 <pjd> via lambda lifting
05:41:29 <Cale> They're not exactly first-class values if you can't create them at runtime :)
05:41:47 <emk> vincenz: Dynamic scoping is just wrong and unnatural and I'm going to ignore it. ;-)
05:41:53 <nmessenger> no, The word "closure" technically means any expression without free variables :P
05:41:54 <vincenz> emk: ...
05:41:58 <nmessenger> s/no, //
05:42:04 <pjd> nmessenger: exactly
05:42:12 <vincenz> emk: nonetheless dynamic scoping has its uses and there are papers about that (recent ones)
05:42:27 <quicksilver> nmessenger: that's not a definition I've heard
05:42:32 <quicksilver> nmessenger: that's a "closed form"
05:42:46 <pjd> the way i understand the terminology "closure" is the language feature, and function+scope or lambda lifting are among the ways of implementing it
05:42:54 <mauke> what's dynamic scoping other than global variables?
05:43:06 <emk> vincenz: Oh, certainly, especially if you're talking about thread-local variables that store configuration data.
05:43:20 <pjd> mauke: dynamic scoping has nesting and so on
05:43:21 <quicksilver> mauke: it's where in the pseudocode { a = 5; f() }, the value of a is available to f
05:43:22 <nmessenger> mauke: shadowable global variables!
05:43:23 <Cale> I'd probably define a closure as a piece of code together with an environment binding the free variables of that code.
05:43:29 <quicksilver> mauke: and all the functions it calls
05:43:41 <mauke> quicksilver: so, a is global
05:43:50 <emk> vincenz: But it's a nasty way to get first-class functions working in the absence of lexical closures.
05:43:52 <quicksilver> mauke: no, because it's not accesible outside that scope
05:43:53 <earthy> now to get dons to generate the pictures from the new wiki page and we're all set. ;)
05:43:59 <quicksilver> mauke: e.g. if f() is called from elsewhere
05:44:07 <quicksilver> mauke: so it isn't global
05:44:11 * emk has just gotten a custom rewrite rule to work!
05:44:18 <vincenz> emk: it is not 'nasty' it is just different
05:44:32 <mauke> quicksilver: I'd say it is a global variable that's temporarily given a value
05:44:35 <quicksilver> it's antithetical to alpha-conversion
05:44:46 <quicksilver> so it feels nasty to peopl who live in an alpha-conversion world
05:44:50 <quicksilver> but 'nasty' is subjective
05:44:52 <nmessenger> { a = 1; f x = { a = 2; return (g(x)) }; g x = { return (a+x) } } -- f's a shadows global a
05:45:02 <vincenz> quicksilver: correct
05:45:05 <quicksilver> mauke: no, because it doesn't exist at all outside that scope
05:45:09 <emk> vincenz: I've written a lot of code in primitive Lisp systems that work that way, and there's all sorts of different ways to lose. Lexical scoping is a Good Thing.
05:45:11 <vincenz> but we were talking about closures vs first class functions
05:45:20 <vincenz> the point is: you -can- have first class functions without closures
05:45:23 <quicksilver> mauke: if there was a global 'a' it would indeed be shadowed in most implementations of dynamic scoping
05:45:27 <vincenz> most languages do not do that, but that does not mean t is impossible
05:45:30 <mauke> quicksilver: how can you tell the difference?
05:45:31 <quicksilver> mauke: but if there is no global 'a' then it simply doesn't exist
05:45:43 <quicksilver> mauke: accessing 'a' outside would be a runtime fault
05:45:50 <vincenz> emk: that is graet, we are not talkng aboutt what codes more easily, we are talking about possibility
05:46:25 <mauke> quicksilver: runtime fault? even better, then it's definitely just global variables with temporary values
05:46:40 <quicksilver> mauke: you're arguing about semantics and trying to map something into your world view
05:46:49 <quicksilver> mauke: 'a' does not exist (in the normal sense of variable existence)
05:46:52 <quicksilver> outside that scope
05:46:55 <quicksilver> so it isn't global
05:46:57 <mauke> in this case, my world view = perl :-)
05:46:58 <emk> vincenz: In a dynamically-scoped language, you can't allow a lambda to escape the creating function, or else it will no longer have access to the local scope. That eliminates a huge fraction of interesting first-class and higher-order functions.
05:47:02 <quicksilver> you could *implement* the technique with globals
05:47:07 <quicksilver> mauke: perl has dynamic scopes
05:47:09 <quicksilver> mauke: it calls them local
05:47:28 <mauke> quicksilver: uh, "local" temporarily replaces the value of an existing variable
05:47:38 <quicksilver> mauke: and, if there was no existing variable, it creates it
05:47:40 <quicksilver> mauke: dynamic scoping
05:47:41 <vincenz> emk: obviously this conversation i snot working and we have different goals.  My goal was to dissambiguate first class functions from closures, not discuss the merits of lexical scoping
05:47:44 <mauke> quicksilver: wrong
05:47:57 <SamB> mauke: that is exactly the same as dynamic scope!
05:48:01 <mauke> quicksilver: perl doesn't have such a thing as non-existing variables
05:48:07 <quicksilver> mauke: of course it does
05:48:16 <mauke> I'd like to see that
05:48:17 <quicksilver> mauke: it may not throw an error by default, but it does
05:48:33 <mauke> variables are created in the parser
05:48:33 <SamB> whether or not they have nonexisting variables is besides the point
05:48:42 <quicksilver> mauke: not necessarily
05:48:49 <mauke> it's simply not possible to refer to a non-existing variable
05:48:49 <quicksilver> mauke: perl can create variables and runtime too
05:48:57 <emk> vincenz: Yeah, sorry to rant. I've worked in too many old-style Lisps, and been burned so many times it isn't funny.
05:49:07 <quicksilver> mauke: and perl doesn't distinguish between runtime and parse-time
05:49:09 <emk> So I'm a little touchy on the subject...
05:49:15 <emk> My apologies.
05:49:18 <mauke> quicksilver: yes, there's "my", but local is broken in that it doesn't work with lexical scalars
05:49:24 <nmessenger> SamB: whether the "replacing" happens at runtime vs. compile-time was the difference b/n dynamic scope and static scope, if I understood correctly
05:49:28 <quicksilver> mauke: local is dynamic scoping
05:49:32 <quicksilver> mauke: that's why it 'feels broken'
05:49:45 <quicksilver> because dynamic scoping is a strange feature to people not used to it
05:49:50 <mauke> no, the broken part is that 'local my $foo' doesn't compile
05:49:54 <quicksilver> that's broken, yes
05:49:55 <mauke> I know what local does
05:50:03 <vincenz> Anyways, I would like to point out a few CRITICAL things which make closures not as simple in languages like java.  Lisp and scheme are simple languages, you have few syntactic constructs, therefore making closures is much easier.  However there are a few constructs which should not always be lexically scoped.  And that is why recently dynamic scoping has taken some interest again.  Look for instance at the recent interest in how exceptions mesh w
05:50:11 <nmessenger> I've not seen perl's local, what does it do?
05:50:17 <quicksilver> nmessenger: dynamic scoping
05:50:24 <vincenz> emk: no need to apologize.
05:50:27 <mauke> nmessenger: "local" temporarily replaces the value of an existing variable
05:50:37 <mauke> the old value is restored when the current scope is left
05:50:39 <SamB> "... exceptions mesh w"
05:51:16 <vincenz> For instance, imagine a loop that creates closures, and these closures have 'break' inside... should break be lexically scoped or dynamically scoped?  Personally I think the prior makes no sense at all (though the second could also not make sense)
05:51:20 <nmessenger> mauke: what's the difference with "my"?
05:51:32 <mauke> nmessenger: "my" creates a new variable
05:51:39 <quicksilver> nmessenger: my is lexical, i.e. functions you call don't see the variable
05:51:51 <nmessenger> OH!
05:51:52 <vincenz> emk: hereby an invitation to #oasis
05:51:55 <quicksilver> nmessenger: {my $f = 5; g()} vs {local $f = 5; g()}
05:51:58 <pjd> nmessenger: the reason for having "local" as well as "my" is due to hysterical raisins
05:52:02 <pjd> mostly
05:52:09 <vincenz> pjd: historical reasons?
05:52:09 <mauke> pjd: no, they're totally different
05:52:10 <quicksilver> nmessenger: in the former, g can't see $f, in the latter it can
05:52:15 <nmessenger> so "local" is like new globals, i.e. dynamic scope, I think I understand
05:52:29 <earthy> there. HaskellUserLocations migrated to the new wiki
05:52:30 <dylan> delimited globals. :)
05:52:36 <mauke> $::foo = 5; { local $::foo = "zomg"; ... } # $::foo reset to 5 here
05:52:54 <vincenz> mauke: that isisue is orthogonal to lexical binding
05:52:59 <vincenz> erm
05:53:01 <vincenz> lexical scoping
05:53:10 <mauke> yeah, exactly
05:53:12 <quicksilver> mauke: here is an example of a new variable created at runtime in perl, not by the parser
05:53:18 <vincenz> you define a new variable
05:53:22 <quicksilver> mauke: perl -e 'my $foo = $ARGV[1];  $main::{$foo} = "bar"' bumble
05:53:23 <mauke> "local" doesn't let functions magically see foreign lexicals
05:53:54 <mauke> hmm, typeglob aliasing
05:54:05 <mauke> does that create variables?
05:54:07 <quicksilver> yes
05:54:11 <quicksilver> perl can create variables at runtime
05:54:24 <quicksilver> (a variable in perl is just an entry in a hash anyway)
05:54:32 <quicksilver> (everything in perl is runtime, there is no true parse)
05:54:32 <mauke> quicksilver: lexicals aren't
05:54:41 <mauke> there is a parse
05:54:47 <quicksilver> there is no 'true' parse
05:54:55 <quicksilver> you can't separate the parse phase from the runtime phase
05:54:59 <mauke> that's like saying there is no true parse in lisp
05:55:00 <quicksilver> they can be arbitrary interleaved
05:55:05 <quicksilver> no, it's totally different
05:55:10 <mauke> how so?
05:55:11 <nmessenger> from my understanding, any language that stores variables in a map like that is technically "dynamic scope", but may behave as if statically scoped
05:55:17 <quicksilver> lisp without-string-eval can be parsed once and for all
05:55:21 <quicksilver> and then executed at will
05:55:27 <mauke> nmessenger: perl has both mappy and non-mappy vars
05:55:34 <quicksilver> perl has 'string eval' built in and all sorts of subtle levels
05:55:44 <quicksilver> meaning that the parser and the executor are hideously overlapped
05:55:48 <pjd> nmessenger: nah, the "dynamic scope" would describe how the map is used
05:55:50 <vincenz> Let's move this to #haskell-blah?
05:55:53 <quicksilver> also, perl can execute code at 'parse-time'
05:55:54 <vincenz> or #oasis?
05:55:57 <vincenz> or #ltu?
05:56:11 <pjd> Python stores everything in run-time dicts, but it is strictly lexically scoped
05:56:22 <mauke> quicksilver: #haskell-blah?
05:56:32 <quicksilver> mauke: to be honest, I have real work to do :)
05:56:47 <mauke> hah
05:56:49 <xic> what do you guys think about MissingH?
05:56:56 * pjd wonders how the discussion turned Perl so quickly
05:58:45 <quicksilver> pjd: trying to explain dynamic scoping to mauke, he said his world view was perl, so I tried to couch the explanation in perl terms. It didn't go well :P
05:58:56 <mauke> that's quicksilver doesn't understand how perl works :-)
05:58:59 <mauke> *becase
05:59:10 <mauke> :(
05:59:34 <quicksilver> bah, that's flame bait of the worse kind
05:59:41 <paolino> if I have nested StateT ,should I newtype the inside one to let get/put/gets resolve the ambiguity ?
06:00:04 <quicksilver> I understand perl in considerable detail I can assure you :) I have been a perl programmer for more years than I care to admit.
06:00:05 <earthy> xic: MissingH is nice.
06:00:47 <pjd> vincenz, mauke: re. hysterical raisins, i mean Perl first only had globals, then local was introduced as the easiest-to-implement substitute for lexical variables
06:01:17 <mauke> yeah
06:01:28 <pjd> then, some time later, proper lexical variables (my) were implemented, eliminating most of local's use
06:01:47 <mauke> quicksilver: huhu, do you know http://perlmonks.org/index.pl?node=How's+your+Perl?
06:02:02 <lambdabot> Title: How's your Perl?
06:02:16 <pjd> and while it's still useful for dynamic(-ish) scoping, it's mostly regarded as an odd corner of the language
06:02:29 * malcolm sighs, wondering why yhc has to be so difficult to install (been trying for three days now)
06:02:56 <emk> A very basic tutorial on purely functional queues, adapted from Okasaki's first example:
06:03:00 <mauke> pjd: if you think local is a weird substitute for real scoping, have you seen reset? :-)
06:03:04 <emk> http://www.randomhacks.net/articles/2007/02/08/haskell-queues-without-pointers
06:03:08 <lambdabot> Title: Haskell: Queues without pointers, http://tinyurl.com/ypdolk
06:03:17 <pjd> mauke: reset?
06:03:27 <mauke> perldoc -f reset
06:03:34 <pjd> mauke: and that's not what i think, that's what Perlers think (as far as i know :)
06:03:39 <mauke> http://perldoc.perl.org/functions/reset.html
06:03:40 <lambdabot> Title: reset - perldoc.perl.org
06:04:01 <paolino> anyone used nested StateT's  ?
06:04:43 <pjd> mauke: that's pretty zany
06:05:20 <mauke> bingo
06:08:44 <mauke> emk: if that queue is persistent, it doesn't run in O(1)
06:09:00 <emk> mauke: Yup.
06:10:25 <xic> earthy: it seems to have a lot of stuff that should be in the standard modules
06:13:28 <quicksilver> mauke: why not O(1) time if persistent?
06:13:54 <emk> quicksilver: Because if you clone the queue right before it does the reverse, you pay for it over and over again.
06:14:24 <quicksilver> emk: but on average you won't do that very often?
06:14:55 <emk> mauke: How should I credit you for that correction/elaboration?
06:15:21 <vincenz> Wow, it's impressive how little has changed: http://video.google.com/videoplay?docid=-7466310348707586940&q=smalltalk
06:15:23 <lambdabot> Title: ACM SIGGRAPH 1983 Issue 8 - Smalltalk - Google Video, http://tinyurl.com/2ytgh7
06:15:41 <emk> quicksilver: Probably not. But if that were a concern, there's a very clever workaround that only adds another few lines of code.
06:16:40 <mauke> emk: okasaki, section 5.6 :-)
06:17:22 <quicksilver> emk: I have a suspicion that you can't quantify it without knowing the use case
06:17:32 <quicksilver> emk: but I believe for certain use cases it would still amortize to O(1)
06:18:20 <tom___> hi all
06:19:05 <emk> quicksilver: I wouldn't be the least bit surprised. But like I said, the fix is pretty clever and quite straightforward.
06:19:13 <tom___> Does anyone here know anything about System.Posix.Terminal and why it doesn't have support a baud rate of 57600?
06:22:29 <emk> mauke: I added a note...
06:22:56 <emk> tom__: Sorry, I haven't tried the Terminal stuff yet.
06:23:43 <tom___> oh well, thanks anyway
06:26:04 <ski> @palomer
06:26:05 <lambdabot> I have news for you, it's pointless
06:26:32 <ookk> how much overhead does an STArray have?
06:26:42 <ookk> compared to IOArray?
06:27:03 <ookk> or STUArray vs IOUArray
06:29:16 <dons> IOUArray is compiled down to an STUArray
06:29:30 <dons> in fact, everything's an ST(U)Array in the end :-)
06:29:50 <dons> except Foreign.Marshal.Array, which is a Ptr
06:30:37 <dons> I usually use IOUArray's though, and then sometimes drop into Foreign.Marshal.Array when I really care (i.e. on the shootout)
06:31:04 <ookk> how much of a difference is there between STUArray and Foreign.Marshal.Array?
06:31:09 <ookk> no bounds checking?
06:31:18 <dons> right
06:31:30 <xic> dons: what about TUArray?
06:31:32 <dons> and if you use unsafeRead/unsafeWrite with STUArray/IOUArray, they behave almost the same
06:31:43 <dons> xic, not used it. (where's that live?)
06:31:51 <ookk> so you can turn of bounds checking if you want with STUArray?
06:31:52 <xic> dons: it's part of STM
06:32:06 <dons> you get readFooArray# primops instead of readFooPtrOff# primops
06:32:09 <dylan> @hoogle TUArray
06:32:10 <lambdabot> Data.Array.ST.castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
06:32:11 <lambdabot> Data.Array.ST.STUArray :: data STUArray s i a
06:32:11 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
06:32:19 <dons> that's the difference  in the end between IOU/STUArray and Ptr
06:32:26 <ookk> then it should be just like a c-array? raw data access?
06:32:31 <dons> ookk: yeah, but you have to use unsafeRead/unsafeWrite for indexing
06:32:37 <xic> dons: oops sorry, there is no TUArray, only TArray
06:32:52 <dons> ookk: right. IOUArray with unsafeReadunsafeWrite is just raw data in memory
06:32:56 <xic> TUArray would be really useful though
06:33:34 <ookk> dons, and that is also true for STUArrays?
06:33:43 <dons> yes
06:33:53 <dons> IO is implemented using ST. they're the same thing on the array level
06:33:59 <ookk> nice
06:34:03 <quicksilver> hmm there should be a primitive for 'run this pure computation on the current value of this impure array'
06:34:04 <dons> and that abstraction is compiled away anyway
06:34:13 <quicksilver> ah but that doesn't make sense!
06:34:16 <dons> quicksilver: you mean, a pure read?
06:34:19 <quicksilver> laziness bites me in the arse again
06:34:26 <quicksilver> dons: I meant, like freeze but without the copy
06:34:27 <dons> yeah, laziness can mess things up
06:34:33 <quicksilver> dons: then I realised I was talking rubbish :)
06:34:48 <quicksilver> dons: like unsafeFreeze but not unsafe, if you will
06:34:58 <quicksilver> but you'd need to totally force the pure computation
06:35:07 <dons> yeah
06:35:28 <dons> xic, there's some examples of very fast array/Ptr access on the shootout
06:35:31 <quicksilver> well people worry too much about this stuff anyway
06:35:31 <dons> ?wiki Shootout
06:35:32 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
06:35:32 <CosmicRay> argh, gtk2hs is broken in sid.
06:35:34 <CosmicRay> grmbl
06:35:38 <dons> the spectral-norm example, is one.
06:35:43 <quicksilver> they should only worry once they've proved they have a performance problem :)
06:35:51 <dons> yeah
06:35:52 <quicksilver> (of course, for those people who *have* proved it, it's important and fiddly)
06:36:06 <dons> ?shootout
06:36:06 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
06:36:17 <earthy> ah, the donsman
06:36:20 <dons> i wonder if we've climbed any further today.
06:36:28 <dons> (mandelbrot got fixed)
06:36:54 * earthy points dons at http://www.haskell.org/haskellwiki/HaskellUserLocations and barks
06:36:55 <lambdabot> Title: HaskellUserLocations - HaskellWiki
06:37:00 <dons> i've also submitted an updated spectral-norm that runs 2.2x slower than C.
06:37:11 <dons> so we might over take Clean for raw speed tomorrow :-)
06:38:04 <nornagon> ooh.
06:38:12 <ookk> i wrote the meteor-contest program and i have been trying to optimize it, it runs much faster when i implement the same algorithm in c++
06:38:34 <ookk> but the winning program in that benchmark is using a more advanced algorithm i think
06:39:52 <ookk> but at least the Haskell code looks much nicer :P
06:40:03 <ookk> even though that is not part of the competition
06:41:17 * earthy nods
06:41:31 <earthy> otoh: it *does* put ghc over clean. :)
06:41:31 <Saizan> what a split
06:41:49 <pjd> wow, #haskell makes for epic splits
06:42:15 <dons> now, if we comment out the couple of entries that are waiting in the queue to be run (recursive, spectral-norm), then haskell rises to 5th
06:42:23 <nmessenger> Saizan: /agree
06:42:33 <dons> so that's the penalty the current poor nbody and spec-norm entries have.
06:42:50 <earthy> not bad. not bad *at*all*
06:42:54 <nmessenger> my scrollback dissappeared  D:
06:43:31 <dons> now, i've fixed spec-norm and recursive. just the nbody problem is proving stubborn
06:43:45 <dons> but the shootout maintainers are away for a few days, so no updates till monday
06:44:03 <vincenz> what is the major problem with nbody?
06:44:48 <dons> it uses a mutable array of Double. the best I can get is around 3x C
06:44:50 * quicksilver recommends clients which combine split messages
06:44:56 <quicksilver> (+158 more, use /NETSPLIT to show all of them)
06:44:58 <dons> but on the shootout box its about 7x (so that's fixable)
06:45:31 <Syzygy-> ?hoogle unfold
06:45:31 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
06:45:32 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:45:32 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
06:45:36 * dons `liftM` sleep
06:45:41 <nornagon> :D
06:45:42 <vincenz> dons: can the algoritme be formulated in another way?
06:45:52 <vincenz> dons: that should be
06:45:53 <ookk> what is the problem with Double arrays with ghc?
06:45:58 <vincenz> dons `flip liftM` sleep
06:46:08 <mauke> lexical error
06:46:32 <nmessenger> dons `Mtfil` sleep where Mtfil = flip liftM
06:46:44 <nornagon> heh.
06:46:47 <xic> dons: what do you think of MissingH?
06:46:56 <quicksilver> can someone summarise for me the key difference between 'let' and 'where'? I always forget...
06:47:08 <mauke> where = backwards let
06:47:09 <nornagon> quicksilver: opposite sides of the expression
06:47:24 <nornagon> expr where n  ===  let n where expr
06:47:24 <quicksilver> hmm I'm sure there was a fiddly difference too
06:47:28 <nmessenger> quicksilver: where is function syntax level, it can't be used inside an expression
06:47:40 <Lemmih> nornagon: Not quite right.
06:47:42 <quicksilver> nmessenger: ah, that's probably what I'm thinking of
06:47:44 <nornagon> er, let n in
06:47:47 <nornagon> sry.
06:47:54 <Lemmih> nornagon: Still not quite right.
06:47:55 <nmessenger> quicksilver: but that allows it to scope over several guards
06:47:59 <dylan> let is expression-wise
06:48:08 <dylan> where scopes differently.
06:48:08 <nornagon> quicksilver: perhaps let n = a where m?
06:48:14 <nornagon> gah
06:48:17 <nornagon> it's 2am
06:48:24 <nornagon> quicksilver: perhaps let n in expr where m?
06:48:41 <quicksilver> nornagon: it's the subtle scoping/grammatical point I'm getting at
06:48:46 <nornagon> oh.
06:48:47 <nornagon> okay.
06:48:55 <nmessenger> dylan: I was confused at first since the Hugs repl allows you to use 'where' as if it were an expression.
06:49:15 <quicksilver> nmessenger: but where can be used inside the declaration part of a let, and thus 'inside something inside an expression' ?
06:49:27 <nmessenger> heh
06:49:34 <dcoutts_> CosmicRay, are you waiting for the new Gtk2Hs release? the ghc-6.6 compatible one?
06:49:43 <quicksilver> > let a = b where b = 5 in a
06:49:44 <nmessenger> (let x = x where x = ... in ... x ...)
06:49:47 <lambdabot>  5
06:49:55 <nmessenger> nope, x = x is bottom
06:50:07 <quicksilver> nmessenger: my one worked though
06:50:11 <nmessenger> yep
06:50:30 <quicksilver> nmessenger: is there a sensible stylistic guideline? personally I always use 'let'
06:50:39 <quicksilver> (probably because before I used haskell, I used ocaml)
06:51:03 <nmessenger> I prefer where and use let only when I need to scope inside a larger expression
06:51:20 <nmessenger> personal preference, though, when either is okay
06:51:23 <ski> if one's just initializing a loop, then i prefer 'where'
06:52:05 <Syzygy-> ?hoogle [a] -> [a]
06:52:06 <lambdabot> Prelude.cycle :: [a] -> [a]
06:52:06 <lambdabot> Prelude.init :: [a] -> [a]
06:52:06 <lambdabot> Prelude.reverse :: [a] -> [a]
06:52:19 <quicksilver> @src init
06:52:20 <lambdabot> init [x]    = []
06:52:20 <lambdabot> init (x:xs) = x : init xs
06:52:20 <lambdabot> init []     = undefined
06:52:21 <nmessenger> you *have* to use where to scope over several guards, you *have* to use let to refer to bindings within an expression.
06:52:42 <Syzygy-> Is reverse . tail . reverse a good idea on a finite list?
06:52:45 <Syzygy-> To get all but the last?
06:52:55 <nmessenger> > init [1..10]
06:52:56 <lambdabot>  [1,2,3,4,5,6,7,8,9]
06:53:07 <nornagon> :t init
06:53:10 <lambdabot> forall a. [a] -> [a]
06:53:12 <nornagon> oh
06:53:12 <nmessenger> @src init
06:53:13 <lambdabot> init [x]    = []
06:53:13 <lambdabot> init (x:xs) = x : init xs
06:53:13 <lambdabot> init []     = undefined
06:53:13 <dylan> > last [1..10]
06:53:15 <lambdabot>  10
06:53:16 <nornagon> nmessenger: beat me to it
06:53:27 <quicksilver> nmessenger: I just @srced init 5 lines above :P
06:53:36 <nmessenger> oh
06:53:45 <ski> > map (\x -> case () of () -> y where y = x*x) [0..9]  -- using 'where' to refer to binding within expression
06:53:46 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
06:54:05 <nmessenger> ski: bleargh!
06:54:24 <ski> ugly, yes ;P
06:54:24 <hpaste>  fourbissime pasted "osc ?" at http://hpaste.org/414
06:55:02 <nmessenger> "osc?"?
06:55:27 <ski> "osc ?"!
06:55:42 <nornagon> "\"osc?\"?"?
06:56:09 <earthy> oscillator
06:56:32 <nmessenger> fix show "osc?"
06:57:05 <CosmicRay> dcoutts_: yes, the ghc6.6 gtk2hs
06:57:21 <hpaste>  Earthy annotated "osc ?" with "better osc. :P" at http://hpaste.org/414#a1
06:57:22 <CosmicRay> it appears to be sitting in Debian's NEW, but I don't know where it came from really
06:57:43 <hpaste>  ski annotated "osc ?" with "(no title)" at http://hpaste.org/414#a2
06:57:49 <dcoutts_> CosmicRay, well I'm nearly there with the final release. I was giving it a few days to let the bug reports roll in.
06:57:52 <dcoutts_> CosmicRay, do you or liyang have the debian packages for the new version working yet?
06:58:05 <quicksilver> earthy: but your version can't split the state
06:58:06 <CosmicRay> dcoutts: liyang appears to have made an upload of the old version with some patch
06:58:07 <Syzygy-> ?where fold
06:58:07 <lambdabot> I know nothing about fold.
06:58:07 <Syzygy-> ?doc foldr
06:58:07 <lambdabot> foldr not available
06:58:07 <Syzygy-> ?doc Prelude
06:58:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
06:58:09 <quicksilver> earthy: and capture moments in time
06:58:12 <CosmicRay> dcoutts: but I can't see it yet
06:58:13 <dcoutts_> CosmicRay, if not, now is the time to try while there's still the chance to get your patches in.
06:58:13 <earthy> quicksilver: true.
06:58:17 <quicksilver> earthy: that's the "point" of the state monad, I guess
06:58:28 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/415
06:58:39 <earthy> contextless though I'd say this is better.
06:58:40 <CosmicRay> dcoutts: url?
06:58:53 <dcoutts_> CosmicRay, haskell.org/gtk2hs
06:58:58 <CosmicRay> oh, right there on the home page, ok
06:58:58 * earthy doesn't like dependence on state and such when it's uncalled for
06:59:10 <dcoutts_> CosmicRay, really? patching the last version to work with ghc-6.6 isn't easy. it'd be a big patch.
06:59:33 <CosmicRay> well, he called it 0.9.10.5
06:59:40 <dcoutts_> ah ok
06:59:42 <CosmicRay> maybe that had something to do with the prerelease, I dunno.
06:59:45 <dcoutts_> that's the release candidate
06:59:48 <CosmicRay> ah
07:00:12 <dcoutts_> that was RC1, the one on the website now is RC2
07:00:37 <dcoutts_> so if there's anything from the debian patchset that you want pushing upstream...
07:00:58 <CosmicRay> I can't see it yet since it's still stuck in NEW
07:01:04 <dcoutts_> oh ok
07:01:09 * dcoutts_ prods liyang 
07:01:21 <CosmicRay> me too
07:01:27 <CosmicRay> oh, liyang is here.
07:04:02 <TwigEther> 16
07:04:10 * TwigEther FAILS at changing windows today!
07:07:27 <velco> http://www.randomhacks.net/articles/2007/02/08/haskell-queues-without-pointers
07:07:33 <lambdabot> Title: Haskell: Queues without pointers, http://tinyurl.com/ypdolk
07:07:41 <velco> How using queues persistently breaks amortized O(1) ?
07:08:02 <velco> and what does it exactly mean to use them "persistently" ?
07:08:26 <quicksilver> velco: take references to intermediate values of the queue
07:08:30 <velco> (Ihave some vague informal understanding of "ephimeral" and "persistent" data)
07:08:36 <quicksilver> velco: so that you have 'old states in time' lying around
07:08:55 <nmessenger> > let f = ((++"?") . show) in foldr (.) id (repeat f) "osc ?"
07:08:56 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:10:30 <nmessenger> @losers
07:10:30 <lambdabot> Maximum users seen in #haskell: 322, currently: 304 (94.4%), active: 33 (10.9%)
07:12:31 <paolino> is the book from okasaki  readable online ?
07:15:10 <paolino> worth buying ?
07:15:41 <Syzygy-> I bought it. Seems neat.
07:16:55 <velco> not available online. The thesis it, thouigh.
07:17:08 <velco> (allegedly, they aren't equivalent)
07:25:48 <Ogedei> I am reading the 'tackling the awkward squad' paper -- I'm not sure if the the terminology used in there is standard or not -- and I wondered whether there is any idiom to recover from situations where a thread does something that causes others to block (taking the value from a shared MVar, for example), and then gets hit by an asynchronous exception. -- in other languages things like unwind-protect or try/finally allow you to
07:25:48 <Ogedei> release things like that. (phew, long line)
07:27:27 <nmessenger> there are things like the bracket and catch functions
07:28:51 <Ogedei> ah, I see, you could wrap the operation that should release the resource in a catch and release it anyway when gets interrupted
07:29:42 <nmessenger> @hoogle bracket
07:29:42 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:29:43 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
07:29:43 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
07:30:57 <Ogedei> great, thanks for the hint
07:31:57 <nmessenger> @docs Control.Exception
07:31:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
07:32:02 <nmessenger> ^^ for more info
07:32:19 <pejo> paolino, well worth its money. Wasn't that expensive either iirc.
07:35:47 <roconnor> heh, I read an article last week on how message-passing sucks, and an article today on why STM sucks.
07:36:00 <roconnor> At least we can all agree that locks really suck.
07:36:05 <vincenz> roconnor: let us return to single-core, single-thread, no-shared-state systems
07:36:36 <roconnor> back in my day, we put in a floppy disk and ran one appication at at time!
07:37:15 <wolverian> is there a way to apply a function to both elems in a tuple?
07:37:39 <roconnor> @djinn (a -> b) -> (a,a) -> (b,b)
07:37:40 <lambdabot> f a (b, _) = (a b, a b)
07:37:50 <roconnor> oh dear
07:38:00 <roconnor> that's no good
07:38:03 <nmessenger> > join (***) (+3) (5, 9) -- if you want to be sneaky
07:38:05 <lambdabot>  (8,12)
07:38:16 <Lemmih> > uncurry (+) (1,2)
07:38:18 <lambdabot>  3
07:38:32 <roconnor> @type join (***)
07:38:33 <quicksilver> wolverian: (***) is what you mean, I imagine, you need to import Control.Arrow for that
07:38:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:38:36 <nmessenger> > (\f -> f *** f) (+3) (5, 9) -- less sneaky
07:38:38 <lambdabot>  (8,12)
07:38:54 <wolverian> oh, join. I'd forgotten that.
07:39:07 <wolverian> thanks, all :)
07:39:12 <mauke> @type uncurry . join
07:39:13 <bakert> wolverian, mapFst is good too
07:39:14 <lambdabot> forall a b c. (a -> a -> b -> c) -> (a, b) -> c
07:39:15 <quicksilver> @pl \f (a,b) -> (f a, f b)
07:39:16 <vincenz> nmessenger: personally I find join more legible
07:39:16 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
07:39:17 <nmessenger> join (f :: a -> a -> b) = (f' :: a -> b)
07:40:25 <wolverian> (><) is quite near too :)
07:40:35 <nmessenger> eh?
07:40:40 <nmessenger> @hoogle (><)
07:40:41 <lambdabot> Did you mean: (><)
07:40:41 <lambdabot> Prelude.undefined :: a
07:40:41 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:40:42 <mauke> @index (><)
07:40:43 <lambdabot> Data.Graph.Inductive.Query.Monad, Data.Graph.Inductive.Query, Data.Graph.Inductive
07:41:04 <nmessenger> @src (Data.Graph.Inductive.><)
07:41:05 <lambdabot> Source not found. Where did you learn to type?
07:41:26 <nmessenger> @type (Data.Graph.Inductive.><)
07:41:27 <lambdabot> forall d b c a. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:41:48 <roconnor> (><) === (***) ?
07:41:52 <nmessenger> isn't that just (->) (***)
07:41:55 <quicksilver> @pl \f x -> (f (fst x),f (snd x))
07:41:56 <lambdabot> ap (ap . ((,) .) . (. fst)) (. snd)
07:42:11 <quicksilver> I like lambdabot's version :)
07:42:29 <nmessenger> do not confound pl with LB!
07:42:37 <mauke> @. unpl pl \f x -> (f (fst x),f (snd x))
07:42:38 <lambdabot> ((\ l t -> (\ x -> ((,)) (l (fst x))) >>= \ q -> t >>= \ p -> return (q p)) >>= \ e -> (\ c ad -> c (snd ad)) >>= \ d -> return (e d))
07:42:45 * nmessenger vomits
07:42:48 <roconnor> much better
07:42:49 <quicksilver> nmessenger: don't you mean 'conflate'?
07:42:52 <roconnor> use that
07:42:57 <nmessenger> quicksilver: aye
07:43:11 <quicksilver> nmessenger: you confounded me by misusing conflate!
07:43:18 * nmessenger likes to pretend to have a bigger vocabulary than he does
07:43:25 <mauke> . unpl pl is pretty awesome for generating obfuscated code
07:43:27 <roconnor> unpl really needs to do some beta reduction
07:43:50 <roconnor> or something
07:43:53 <roconnor> hmm
07:44:06 <roconnor> @unpl (\x -> x) y
07:44:07 <lambdabot> y
07:44:10 <nmessenger> quicksilver: shouldn't that be "misappropriating conflate"?  :P
07:44:17 <roconnor> okay, so why is that so complicated?
07:44:35 <roconnor> is it because bind isn't being evaluated?
07:44:48 <roconnor> @type  ap (ap . ((,) .) . (. fst)) (. snd)
07:44:49 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
07:45:02 <nmessenger> @src ap
07:45:02 <lambdabot> ap = liftM2 id
07:45:12 <quicksilver> > ap (ap . ((,) .) . (. fst)) (. snd) $ (+5) (1,3)
07:45:13 <lambdabot>  Couldn't match `b -> c' against `(a, b1)'
07:45:19 <quicksilver> hmm
07:45:24 <roconnor> @src liftM2
07:45:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:45:29 <quicksilver> > (ap (ap . ((,) .) . (. fst)) (. snd)) (+5) (1,3)
07:45:31 <lambdabot>  (6,8)
07:45:34 <quicksilver> ah, it is correct
07:45:40 <nmessenger> @. undo src liftM2
07:45:40 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
07:46:24 <quicksilver> nmessenger: m1 >>= \x1 -> m2 >>= \x2 -> return f x1 x2
07:46:26 <quicksilver> nmessenger:  :P
07:46:26 <nmessenger> quicksilver: I'd be surprised if @pl generated incorrect code!
07:49:38 <nmessenger> m1 >>= \x1 -> m2 >>= return f x1 -- eta-reduction ftw!
07:50:50 <nmessenger> @pl m1 >>= \x1 -> m2 >>= return f x1
07:50:51 <lambdabot> return (f =<< m2) =<< m1
07:50:59 <nmessenger> cooool
07:51:42 <Saizan> @pl m1 >>= \x1 -> m2 >>= (return . f) x1
07:51:42 <lambdabot> (m2 >>=) . return . f =<< m1
07:52:11 <Saizan> ?type \f m1 m2 -> m1 >>= \x1 -> m2 >>= return f x1
07:52:13 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a1 -> m b) -> m a -> m a1 -> m b
07:52:17 <nmessenger> @pl m1 >>= \x1 -> m2 >>= \x2 -> return f x1 x2 -- was it not correct?
07:52:17 <lambdabot> return (f =<< m2) =<< m1
07:52:30 <Saizan> ?type liftM2
07:52:32 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:53:04 <Saizan> ?type \f m1 m2 -> m1 >>= \x1 -> m2 >>= \x2 -> return $ f x1 x2 --this is correct
07:53:06 <lambdabot> forall a a1 (m :: * -> *) a2. (Monad m) => (a -> a1 -> a2) -> m a -> m a1 -> m a2
07:53:15 <nmessenger> oh, of course
07:53:37 <nmessenger> @pl m1 >>= \x1 -> m2 >>= return . f x1
07:53:38 <lambdabot> (`fmap` m2) . f =<< m1
07:54:01 <nmessenger> @type \f m1 m2 -> (`fmap` m2) . f =<< m1
07:54:03 <lambdabot> forall (f :: * -> *) a b a1. (Monad f, Functor f) => (a1 -> a -> b) -> f a1 -> f a -> f b
07:55:02 <nmessenger> but that would require Monad to subclass Functor (which it should), right?
07:55:23 <Saizan> most of them do
07:55:56 <nmessenger> *all* of them *should*, the heirarchy should be fixed.
07:56:16 <Saizan> there's liftM anyway
07:56:18 <quicksilver> nmessenger: there is much discussion as to why it doesn't
07:56:27 <quicksilver> nmessenger: but I dan't remember the basic reason
07:56:40 <quicksilver> haskell doesn't support a 'generic instance', does it?
07:56:50 <quicksilver> As in (for any Monad m, here is the functor instance)
07:56:54 <nmessenger> @wiki Class_system_extension_proposal
07:56:55 <lambdabot> http://www.haskell.org/haskellwiki/Class_system_extension_proposal
07:56:57 * quicksilver nods
07:57:01 <quicksilver> right, that's what I thought :)
07:57:08 <quicksilver> I remember the proposal just not the details
07:57:38 <nmessenger> which leads to:
07:57:48 <nmessenger> @wiki The_Other_Prelude
07:57:48 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
07:57:49 <Saizan> instance Monad m => Functor m where fmap = liftM ? it is probably an undecideable instance
07:58:21 <quicksilver> incidentally, why is the new wiki not googleable?
07:58:23 <nmessenger> Saizan: yes, but if class Monad m where fmap f ma = ma >>= (\a -> return (f a)) were allowed...
07:58:27 <quicksilver> have they robots.txt'ed it?
07:58:37 <nmessenger> +(Functor m) =>
07:59:24 <nmessenger> @google site:haskell.org The Other Prelude
07:59:27 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/Prelude
07:59:27 <lambdabot> Title: Prelude - Haskell Prime - Trac
07:59:30 <nmessenger> hmm
08:06:19 <dino-> bah, the HaXml documentation speak of a (|||) function that apparently no longer exists.
08:06:24 <dino-> speaks^
08:06:30 <nmessenger> @index (|||)
08:06:30 <lambdabot> Control.Arrow
08:06:45 <nmessenger> is it (Control.Arrow.|||)?
08:07:22 <malcolm> dino-: where?  I'll go and fix it
08:07:30 <nmessenger> are the types that the examples operate on instances of Arrow?
08:07:53 <dino-> nmessenger: Nah, Text.XML.HaXml.Combinators
08:08:08 <dino-> malcolm: You're a/the HaXml developer?
08:08:51 <malcolm> dino-: yeah.  what docs are you reading?
08:09:29 <dino-> I'm reading the icfp99.html that installed with it.
08:09:37 <dino-> Let me find a url for it..
08:10:17 <dino-> http://www.cs.york.ac.uk/fp/HaXml/icfp99.html
08:10:20 <lambdabot> Title: Haskell and XML: Generic Combinators or Type-Based Translation?
08:10:23 <dino-> Old documentation, to be sure.
08:10:26 <malcolm> dino-: s'ok, I've found it
08:10:26 <dino-> 1999
08:10:49 <malcolm> Yup, I'd entirely forgotten about (|||)
08:11:41 <dino-> To tell you the truth, I'm not sure I even need that function. I've been flailing around with it, unsure of how to get the results I need.
08:11:42 <nmessenger> looks like liftM2 (++)
08:11:48 <malcolm> dino-: it's called "union" now
08:11:57 <dino-> malcolm: Ok, thank you.
08:12:29 <malcolm> dino-: you were looking the other day to de-tag an HTML doc, yes?
08:12:52 <dino-> Yes, I've been working on ripping things out of an HTML document and making a plain text (not tagged at all) document.
08:12:57 <malcolm> dino-: have you tried using the Xtract tool - Xtract "//-"
08:13:03 <dino-> I have not.
08:13:28 <dino-> I've been slogging it out with things like: position 0 (keep /> tag "foo" /> tag "bar") /> txt
08:13:31 <dino-> and similar
08:13:36 <malcolm> dino-: it might only work completley correctly with the latest darcs version though
08:14:26 <dino-> I did have to write my own custom processHtmlWith that is happy with a [Content] full of CText only.
08:14:38 <malcolm> dino-: using the combinators directly, it should translate to something like "multi txt"
08:15:44 <dino-> malcolm: To get Xtract behavior, you mean?
08:16:30 <malcolm> dino-: yeah, Xtract "//-" is roughly equivalent to (multi txt) in combinators
08:17:14 <malcolm> (older versions of Xtract translate it to (deep txt) which is subtley different and not quite as useful)
08:17:45 <dino-> ok, thank you
08:18:36 <dino-> Let me ask this. I have a <ul> with (of course) <li><a..>text1</a>text2</li> ...
08:18:45 <dino-> Now, there's a pile of these <li> constructions.
08:18:57 <dino-> I want "text1 text2" lines out of them
08:19:19 <dino-> But all I can get is "text1\ntext1\ntext1\ntext2\ntext2\ntext2\n"
08:19:39 <dino-> Like they're not interleaved.
08:19:49 <dino-> I'm sure this is totally unclear.
08:19:51 <dino-> :/
08:20:37 <malcolm> hmm, it's returning the deeper results before the shallower ones, rather than in original occurrence order?
08:21:07 <dino-> This is probably going to suck to discuss without an example.
08:21:41 <paolino> :t map
08:21:42 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
08:21:42 <dino-> It's getting all the <li><a>'s as a group and then all of the <li>'s after that.
08:22:22 <dino-> When what I want is, for each <li><a>foo</a>bar</li> an output of "foo bar" before moving on to the next <li>
08:22:28 <paolino> @hoogle [(a ->b)] -> a -> [b]
08:22:29 <lambdabot> No matches, try a more general search
08:22:54 <dino-> Part of this, I sadly suspect, is that I don't understand what these functions like /> are doing.
08:23:09 <nmessenger> @type \fs x -> map ($ x) fs
08:23:11 <lambdabot> forall a b. [a -> b] -> a -> [b]
08:23:51 <malcolm> dino-: so what is your combinator query that produces this odd ordering?
08:23:55 <paolino> ah, the $ . I always miss them :P
08:23:57 <paolino> thanks
08:24:17 <nmessenger> "apply x to each f"
08:24:42 <paolino> each f to x
08:25:44 <nmessenger> ($ x) = apply x, map ($ x) fs = map (apply x) over the fs
08:26:11 <paolino> $ reads apply ?
08:26:14 <quicksilver> yes
08:26:18 <paolino> ok
08:26:25 <quicksilver> "f $ x" is "f x"
08:26:35 <quicksilver> (but the precedence rules are different)
08:26:42 <dino-> (keep /> tag "li" /> tag "a" /> txt) `union` (keep /> tag "li" /> txt)  will do it
08:26:46 <quicksilver> however you can't take a 'section' of application
08:26:52 <quicksilver> (because there is no syntax for it)
08:26:56 <quicksilver> but you can take a section of $
08:26:56 * nmessenger thinks that sequence or ap or something could do the same
08:26:59 <quicksilver> because it's an operator
08:27:08 <dino-> Given that this filter is used like foo `o` [node where the ul tag is]
08:27:14 <paolino> only if f is not runSomething !
08:27:26 <nmessenger> @type \fs x -> sequence fs x
08:27:28 <lambdabot> forall t a. (Monad ((->) t)) => [t -> a] -> t -> [a]
08:27:32 <quicksilver> @pl \x -> map ($x)
08:27:32 <nmessenger> heh
08:27:33 <lambdabot> map . flip id
08:28:01 <paolino> or the higher kinded types come on me
08:28:08 <nmessenger> id f x = f x = f $ x
08:28:26 <quicksilver> @src id
08:28:27 <lambdabot> id x = x
08:28:40 <nmessenger> thus (id f) x = f x
08:28:48 <quicksilver> ah yes, so (flip id) is reverse composition
08:28:53 <nmessenger> yep
08:29:00 <paolino> :)
08:29:00 <nmessenger> flip id = flip ($)
08:29:09 <quicksilver> @pl \fs x -> map ($x) fs
08:29:10 <lambdabot> flip (map . flip id)
08:29:14 <nmessenger> ($) is a special-case id :)
08:29:17 <quicksilver> @pl \x fs -> map ($x) fs
08:29:18 <lambdabot> map . flip id
08:29:21 <malcolm> dino-: ah, well that query expresses exactly what you see.  First get all the texts inside the <li><a> tags, then those inside the <li> tags
08:29:24 <nmessenger> @type (id, ($))
08:29:34 <lambdabot> forall a a1 b. (a -> a, (a1 -> b) -> a1 -> b)
08:29:49 <quicksilver> $ is id restricted to functions
08:29:49 <nmessenger> for a = (a1 -> b)
08:29:56 <quicksilver> weird
08:30:05 <quicksilver> f `id` 3
08:30:17 <nmessenger> > negate `id` 3
08:30:21 <lambdabot>  -3
08:30:26 <nmessenger> :3
08:31:08 <paolino> :t sequence
08:31:10 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:31:16 <malcolm> dino-: I think what you want is more like (keep /> tag "li" /> ((tag "a" /> txt) `union` txt))
08:31:19 <nmessenger> for m = ((->) r)
08:32:04 <nmessenger> @src sequence
08:32:05 <lambdabot> sequence ms = foldr k (return []) ms
08:32:05 <lambdabot>     where
08:32:05 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:32:15 <quicksilver> sequence [(+1),(+2)] 3
08:32:19 <quicksilver> >sequence [(+1),(+2)] 3
08:32:23 <quicksilver> > sequence [(+1),(+2)] 3
08:32:25 <lambdabot>  [4,5]
08:32:30 <quicksilver> yup, nmessenger is right again :)
08:32:31 <paolino> why not (-> r)
08:32:31 <nmessenger> coolz
08:32:44 <quicksilver> paolino: it's actually (r ->)
08:32:52 <nmessenger> paolino: ((->) r) would be (r ->) if type sections were supported
08:32:52 <quicksilver> paolino: but we don't have a syntax for type-level-sections
08:32:53 <paolino> ah
08:32:54 <dino-> malcolm: Wow, that did it.
08:32:58 <malcolm> dino-: or more probably (keep /> tag "li"  /> deep txt)
08:33:13 <bos> @pl \cs ps -> (sum . map abs) (zipWith subtract cs ps)
08:33:14 <lambdabot> ((sum . map abs) .) . zipWith subtract
08:33:27 <dino-> I see, if you can rely on there being only txt's that you want in there and none to filter out.
08:33:32 <quicksilver> for some reason .-sections still hurt my brain
08:33:33 * nmessenger wants type sections!
08:33:37 <dino-> deep --> get them all
08:34:17 <paolino> we don't have type sections and ((->) r) what is actually ?
08:34:35 <quicksilver> paolino: well it's much like a section
08:34:39 <nmessenger> ((->) Int) Char = Int -> Char
08:34:42 <quicksilver> paolino: but it's just written as a partial application
08:34:45 <dino-> malcolm: Let me ask another question, there's a lot of arbitrary newlines and whatnot in these txt components. Is there a filter or something to get rid of all that?
08:34:53 <malcolm> dino-: strictly, no, deep only gets the top-most matching element.  But since txt cannot contain any further sttrcuture, it amounts tot he same thing
08:34:54 <quicksilver> paolino: like (+) 3 4 is 3+4
08:35:02 <quicksilver> paolino: so (+) 3  is (3+)
08:35:16 <dino-> You know, meaningless whitespace that occurred in the HTML but of course browsers don't care about it outside of <pre> or similar.
08:35:19 <paolino> :t ((->) r)
08:35:21 <lambdabot> parse error on input `->'
08:35:37 <nmessenger> @kind ((->) r) -- types have kinds :)
08:35:39 <lambdabot> Not in scope: type variable `r'
08:35:40 <quicksilver> paolino: it's a type not a value
08:35:45 <nmessenger> @kind ((->) Int)
08:35:47 <lambdabot> ? -> *
08:35:50 <quicksilver> paolino: just like you can't say :t Int
08:35:54 <quicksilver> :t Int
08:35:56 <lambdabot> Not in scope: data constructor `Int'
08:35:59 <nmessenger> :k Int
08:35:59 <malcolm> dino-: I don't have one, but it should be easy to write a filter for that
08:36:00 <lambdabot> *
08:36:18 <quicksilver> @unpl (f.) . g
08:36:19 <lambdabot> (\ d i -> f (g d i))
08:36:38 <quicksilver> nmessenger: can you attempt to explain (f.) to me?
08:36:51 <dino-> malcolm: Ok, I can write a subst filter that applies a regex to the content of a CText.
08:37:11 <quicksilver> nmessenger: well especially (f.) . <blah>
08:37:27 <nmessenger> quicksilver: \x y -> f ((g x) y) = \x y -> (f . g x) y = \x -> f . g x = \x -> (f .) (g x) = (f .) . g
08:37:29 <mauke_> (f .) . g is two-arg (.)
08:37:41 <nmessenger> follow the derivation slowly
08:37:52 <dino-> I see from earlier, multi for everything below.
08:37:59 <quicksilver> nmessenger, mauke_: thanks both helpful answers
08:38:24 <glguy_> !paste
08:38:24 <hpaste> Haskell paste bin: http://hpaste.org/
08:38:27 <dino-> malcolm: Thank you for your help. I was stuck on this for a while. I really appreciate it.
08:38:30 <mauke_> > ((sqrt .) . (+)) 1 1
08:38:31 <lambdabot>  1.4142135623730951
08:38:57 <nmessenger> in English: ((f .) . g), g takes an arg and produces a function, this function is passed to (f .) which sticks f in front of it.
08:39:24 * quicksilver nods
08:39:31 <nmessenger> that's it
08:39:49 <quicksilver> thanks, that's a bit clearer
08:40:00 <nmessenger> f (g x y) = (f .) . g
08:40:13 <nmessenger> (\ x y -> of course)
08:40:19 * quicksilver nods
08:40:47 <paolino> @unpl (f.).g $ x y
08:40:48 <lambdabot> (\ k -> f (g (x y) k))
08:40:59 <nmessenger> @unpl ((f.).g) x y
08:41:00 <lambdabot> (f (g x y))
08:41:06 <nmessenger> ($) is evil :D
08:41:43 <paolino> :t not $
08:41:44 <lambdabot> parse error (possibly incorrect indentation)
08:42:00 <nmessenger> @ty (not .) . ($)
08:42:02 <lambdabot> forall a. (a -> Bool) -> a -> Bool
08:42:08 <nmessenger> heh
08:42:30 <nmessenger> @type let (.:) = (.) . (.) in not .: ($)
08:42:32 <lambdabot> forall a. (a -> Bool) -> a -> Bool
08:43:05 <mauke_> @type \f -> (f .) . id
08:43:07 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:43:52 <nmessenger> (.:), the left function has one point, the right has two points :D
08:44:03 <paolino> @pl \f -> (f.).id
08:44:03 <lambdabot> (.)
08:44:11 <nmessenger> heh
08:44:44 <Syzygy-> @type (.)>>=(.)
08:44:45 <lambdabot> forall a a1. (a1 -> a -> a1) -> a1 -> a -> a -> a1
08:44:47 <nmessenger> > (\f -> (f.).id) negate (+3) 5
08:44:48 <lambdabot>  -8
08:46:00 <paolino> mmhh in python  we write 3+5 , but 'I guess this is more complete :P
08:46:11 <nmessenger> @type (join . ((.).)) (.) (.)
08:46:12 <lambdabot> forall b c. (b -> c) -> (b -> b) -> (b -> b) -> b -> c
08:46:41 <nmessenger> @pl (join . ((.).))
08:46:42 <lambdabot> ((.) =<<)
08:46:59 <nmessenger> @type (join . fmap (.)) (.) (.)
08:47:00 <lambdabot> forall b c. (b -> c) -> (b -> b) -> (b -> b) -> b -> c
08:47:31 <nmessenger> @type fix (.)
08:47:33 <lambdabot>     Occurs check: cannot construct the infinite type: t = a -> t
08:47:33 <lambdabot>       Expected type: ((a -> t) -> c) -> (a -> t) -> c
08:47:36 <nmessenger> darn
08:48:04 <nmessenger> @type fix (.id)
08:48:05 <lambdabot> forall a c. a -> c
08:48:14 <nmessenger> neat!
08:48:20 <Saizan> ?tyoe fix seq
08:48:22 <lambdabot> forall t. t -> t
08:48:34 <nmessenger> > fix (.id) 3 :: Float
08:48:36 <lambdabot>  Exception: <<loop>>
08:49:00 * nmessenger thought he had unsafeCoerce#
08:49:21 <nmessenger> but it's just bottom :)
08:49:37 <nmessenger> @type error
08:49:39 <lambdabot> forall a. [Char] -> a
08:49:55 <nmessenger> fix (.id) is more general!
08:50:25 <nmessenger> also more useless :D
08:52:12 <nmessenger> error should have type Dynamic -> a
08:52:19 <paolino> bang-patterns is a 6.6 feature ?
08:52:24 <vincenz> paolino:yes
08:53:02 <paolino> :t Dynamic
08:53:03 <lambdabot> Not in scope: data constructor `Dynamic'
08:53:14 <glguy> :k Dynamic
08:53:15 <lambdabot> *
08:53:16 <nmessenger> (it's a type)
08:53:24 <glguy> :t toDyn
08:53:26 <lambdabot> forall a. (Typeable a) => a -> Dynamic
08:53:35 <quicksilver> paolino: it's a way of allowing 'safe' typecasts
08:53:35 <nmessenger> > toDyn 5
08:53:37 <lambdabot>  Add a type signature
08:53:46 <nmessenger> > toDyn (5::Int)
08:53:48 <lambdabot>  <<Int>>
08:53:49 <quicksilver> paolino: which give runtime errors if you do something bad
08:54:26 <quicksilver> paolino: it's best used only in special cases, as you're losing compile-time checking
08:54:27 <nmessenger> > fromDynamic (toDyn (5::Int)) :: Maybe String
08:54:29 <lambdabot>  Nothing
08:54:37 <quicksilver> > toDyn "error"
08:54:38 <lambdabot>  <<[Char]>>
08:55:08 <nmessenger> > fromDynamic (toDyn (5::Int)) :: Maybe Int
08:55:09 <lambdabot>  Just 5
08:55:13 <quicksilver> it's oh-so-tempting to use it for stuff like heterogenous lists but there are generally more idiomatic and better ways of doing it
08:55:38 <nmessenger> usually just make a union type
08:55:56 <nmessenger> for the simple stuff
08:56:47 <paolino> is there an typeclass to implement to use it for datatypes ?
08:56:58 <quicksilver> paolino: yes, Typeable
08:57:01 <quicksilver> :t toDyn
08:57:02 <lambdabot> forall a. (Typeable a) => a -> Dynamic
08:57:04 <nmessenger> deriving (Typeable)
08:57:26 <quicksilver> paolino: you can derive it, basically, for most stuff that isn't polymorphic
08:57:26 <nmessenger> import Data.Typeable maybe
08:57:47 <quicksilver> paolino: the haddock for the packages explains it fairly well, I believe
08:57:57 * quicksilver can't remember if you can typeable functions
08:58:06 <quicksilver> > toDyn ((+1) :: Int -> Int)
08:58:08 <lambdabot>  <<Int -> Int>>
08:58:09 <paolino> more than strange if it's the case
08:58:15 <quicksilver> ah, you can. I wonder how that works.
08:58:35 <quicksilver> clever stuff, I suspect, is the technical term for how it works
08:58:44 <nmessenger> (:
08:58:49 <paolino> :)
08:59:00 <nmessenger> 'u'
08:59:24 <nmessenger> .^.
08:59:35 <paolino> 'A'
09:00:29 <paolino> Ã
09:01:13 <nmessenger> my client is unicode-stupid, I see A-tilde hyphen.
09:02:03 <paolino> I am unicode stupid with a Finnish keyboard
09:02:55 <opqdonut> :)
09:03:03 <Vq^> ?
09:03:25 <nmessenger> ?!
09:03:25 <lambdabot> Maybe you meant: . v
09:03:36 <nmessenger> heh, LB wants to play too
09:03:44 <paolino> eheh
09:03:50 <Vq^> hehe :)
09:03:52 <nmessenger> ?! should be a synonym for ?yow
09:03:53 <lambdabot> Maybe you meant: . v
09:04:06 <nmessenger> blah, I added a space
09:04:28 <nmessenger> @yow!
09:04:28 <lambdabot> My face is new, my license is expired, and I'm under a doctor's
09:04:28 <lambdabot> care!!!!
09:05:22 <nmessenger> you just can't say @yow, you must add an exclamation point!
09:06:02 <nmessenger> *I* must, anyway
09:07:25 <paolino> @pl map fromJust. filter isJust
09:07:26 <lambdabot> map fromJust . filter isJust
09:07:53 <nmessenger> > catMaybes [Nothing, Just 1, Just 2]
09:07:54 <lambdabot>  [1,2]
09:08:09 <nmessenger> @index catMaybes
09:08:10 <lambdabot> Data.Maybe
09:08:27 <fasta> This works:
09:08:27 <fasta> foo::SpecificDataType () b
09:08:27 <fasta> foo = f g      (where f and g are class methods)
09:08:27 <fasta>  
09:08:27 <fasta> zork = l foo
09:08:27 <fasta>  
09:08:29 <fasta> While:
09:08:31 <fasta>  
09:08:33 <fasta> foo :: <insert type zork has above>
09:08:35 <fasta> foo = l (f g)
09:08:37 <fasta>  
09:08:39 <fasta> doesn't. Why not? How can I reduce the number of explicit references to specific data types? Any flags, etc?
09:08:53 <glguy> !paste
09:08:54 <hpaste> Haskell paste bin: http://hpaste.org/
09:09:45 <paolino> -fno-monomorphism-restriction?
09:10:01 <nmessenger> foo = l (f g :: (above foo type))
09:10:06 <fasta> Well, I think I understand the issue.
09:10:26 <fasta> The problem is that I need to tell GHC at some point what instances it needs to select.
09:10:34 <nmessenger> the first foo restricts to one instance, (f g) in the second is ambiguous
09:11:22 <fasta> The type errors I am getting are horrific, though.
09:11:57 <nmessenger> It doesn't say something's "ambiguous"?
09:12:20 <fasta> It said no instance for ....
09:12:40 <fasta> The instance is there.
09:12:49 <Cheery> "The dishes, things which thays forever."
09:12:55 <Cheery> *stays
09:13:23 <nmessenger> eh?
09:13:38 <quicksilver> instance? we are talking type classes not polymorphism then
09:14:07 <nmessenger> typeclasses *are* Haskell's parametric polymorphism
09:16:17 <quicksilver> nmessenger: but the monomorphism restriction refers to true polymorphism doesn't it?
09:16:31 <quicksilver> nmessenger: as in, you can't pass 'id' to a function and then use it at two different types
09:17:09 <nmessenger> that sounds like existential, but I'm fuzzy on the details.
09:19:18 <hpaste>  fasta pasted "The real problem " at http://hpaste.org/417
09:19:20 <nmessenger> f :: (forall a. a -> a) -> (b, c) -> (b, c); f g (x, y) = (g x, g y) -- would this work?  I've no idea about the intricacies
09:19:45 <fasta> nmessenger: Can you look at the real problem?
09:20:06 <quicksilver> nmessenger: no, it doesn't work
09:20:15 <quicksilver> nmessenger: and that is what is known as the 'monomorphism restriction'
09:20:23 <quicksilver> nmessenger: or that's my memory of the issue
09:20:42 <fasta> quicksilver: you are wrong
09:20:47 <quicksilver> nmessenger: (it may well be that with the correct GHC extensions you can do that but it would, for example, be illegal in ML)
09:20:57 <quicksilver> fasta: which part is wrong? I'm mixing up the names?
09:21:28 <fasta> quicksilver: That you can't do a f = (f 1, f "") in Haskell 98 isn't because of the monomorphism restriction.
09:22:25 <quicksilver> fasta: what is the name of that, then?
09:22:33 <fasta> quicksilver: When you start "explaining" things to others, it might be better if you have a firm understanding yourself first.
09:22:52 <nmessenger> If I understand correctly (which I likely don't), the forall should quantify over just g, so it can pick the correct specialization of g.  I think this has something to do with existential types.
09:22:56 <fasta> quicksilver: I have no interest in that discussion, although I know the answer.
09:23:40 <quicksilver> fasta: I'm only human, I make mistakes
09:23:54 <quicksilver> fasta: I recalled the fast that you can't pass polymorphic functions as first class values
09:24:06 <quicksilver> fasta: and my memory told me that was called the 'monomorphism restriction'
09:24:11 <chessguy> fasta, so pretty much what you're saying is "nyah nyah you're wrong, i'm smarter than you"
09:24:19 <quicksilver> fasta: if I was wrong, and you're correcting me, I'd very much appreciate to know what it is called
09:24:34 <fasta> chessguy: If you think that's the case, you may believe so.
09:25:11 <chessguy> fasta, you certainly haven't been very constructive about it
09:25:14 <Igloo> fasta: It seems rather off to tell someone they're wrong and not tell them what is right
09:25:31 <nmessenger> the MMR has to do with when the inferencer cannot infer when it logically should be able to.
09:25:56 <fasta> chessguy: I don't feel very constructive at the moment for rather irrational reasons.
09:26:39 * Igloo can't think what the right term is, unless it's predicativity
09:27:02 <fasta> quicksilver: rank-2 polymorphism
09:27:29 <fasta> Now, I would be mighty happy, if someone could help me.
09:27:34 <Igloo> I think of that as more being a type inference implementor's term than a user's term, though
09:28:36 <fasta> Igloo: Can you tell me how to get "zork" executing? http://hpaste.org/417
09:29:10 <quicksilver> that's interesting, I'm not alone in making this mistake. I find another post on the internet using the exact same incorrect term, and being corrected
09:29:52 <quicksilver> fasta: it looks to me like you need to tell it "which zork you mean"
09:30:10 <quicksilver> fasta: zork typechecked fine, but it doesn't have enough information to know which instances to use
09:30:19 <paolino> from yesterday chats I recall this is a mistake design pattern
09:30:21 <quicksilver> zork :: (long fugly type goes here)
09:30:58 <fasta> quicksilver: It operates on a value of a certain type. The compiler could know the type.
09:31:13 <Igloo> fasta: Is from foo onwards a complete module that demonstrates the problem?
09:31:29 <fasta> Igloo: no, those are the instances defined.
09:31:40 <fasta> Igloo: among some for which GHC claims there's no instance.
09:31:48 <Philippa> Igloo: you're right about predicativity
09:31:49 <fasta> Igloo: well, GHC refers to a more general "g".
09:32:22 <Philippa> at least, partly so. That, and the restriction to rank-1 polymorphism
09:32:29 <chessguy> ?hoogle Ix
09:32:30 <lambdabot> Data.Ix :: module
09:32:30 <lambdabot> Ix :: module
09:32:30 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
09:32:42 <chessguy> ?src Data.Ix
09:32:42 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:32:47 <Philippa> (you need rank-n impredicativity before polymorphic values're truly the equal of monomorphic ones)
09:33:48 <quicksilver> Philippa: any idea where I picekd up the meme that this is called the monomorphism restriction?
09:34:18 <Igloo> Philippa: OK, ta. That explains why I couldn't think of the other word then  :-)
09:34:55 <Igloo> fasta: If you've got a small example then I could try to take a look
09:35:38 <nmessenger> quicksilver: monomorphism means "one type", which has to do with both the actual MMR, and the case you're thinking of.
09:36:02 <fasta> Igloo: Ok, I will see whether I create one.
09:36:05 <quicksilver> fasta: but zork has type b1
09:36:10 <quicksilver> fasta: which is quantified out
09:36:17 <quicksilver> fasta: so don't you have to tell it 'which b1' you mean?
09:36:34 <quicksilver> or, alternatively, is that an illegal escape of a quantified type?
09:37:16 <quicksilver> fasta: but zork :: Int (supposing Int was a valid possibility for b1|) would provide that information to the inferrer
09:37:28 <Philippa> quicksilver: probably because type variables're restricted s.t. you can only instantiate them with monomorphic types
09:37:51 <nmessenger> @vera st
09:37:53 <lambdabot> *** "st" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
09:37:54 <lambdabot> ST
09:37:54 <lambdabot>      Seagate Technology (HDD)
09:37:54 <lambdabot>  
09:37:54 <lambdabot> *** "st" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
09:37:55 <lambdabot> [7 @more lines]
09:38:01 <fasta> quicksilver: zork should return a Graph () b
09:38:16 <nmessenger> "so that"?
09:38:29 <hpaste>  quicksilver pasted "Not that web forums are a reliable source, but..." at http://hpaste.org/418
09:38:31 <chessguy> such that
09:38:53 <quicksilver> fasta: what does zork :: Graph () b say, then?
09:39:10 <quicksilver> fasta: because that type says it returns a b1, and doesn't mention that b1 should be Graph () b
09:39:42 <quicksilver> actually you'd need to instantiate 'b' at a type, too
09:39:47 <quicksilver> as in zork :: Graph () Int
09:39:48 <quicksilver> or so
09:42:40 <quicksilver> Philippa: ah it's called the 'value restriction' apparently
09:44:31 <fasta> I found the mistake.
09:45:02 <quicksilver> fasta: good :)
09:45:04 <fasta> zork::Graph () b was completely correct
09:45:36 <fasta> It appears an instance was missing, as GHC said.
09:56:09 <Philippa> quicksilver: it's not called the value restriction in haskell. ML has additional issues
09:57:57 <quicksilver> Philippa: *nod*
09:59:01 <syntaxfree> oh boy. Michi's blog linked to mine. This is such a honor.
09:59:06 <syntaxfree> (About some code, too, not the usual rants)
10:11:32 <benja_> @seen lemmih
10:11:33 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 2h 33m 20s ago.
10:15:20 <Cheery> @seen Slarba
10:15:21 <lambdabot> I haven't seen Slarba.
10:15:53 <benja_> anyone here know something about the Data.LRU module?
10:16:19 <sjanssen> benja_: I've seen it before . . . in conjure perhaps?
10:16:40 <benja_> sjanssen: that's where I saw a reference, except that it doesn't seem to be there now
10:16:54 <benja_> here's another reference google finds: 11:43:39 <sjanssen> SamB: would a rewrite of the Data.LRU module with faster data structures be useful?
10:16:58 <benja_> -- http://tunes.org/~nef/logs/haskell/06.01.04
10:16:59 <benja_> ;-)
10:17:09 <Lemmih> benja_: Hiya?
10:17:15 <sjanssen> I never did write a new version
10:17:20 <Cheery> I've gotten a bit weird idea in using parsers.
10:17:37 <benja_> hi, I found this reference to Data.LRU in conjure (by googling for Haskell LRU), but I can't find such a beast
10:17:45 <benja_> there's no src/Data
10:17:53 <benja_> is it so that there used to be one but isn't any longer?
10:18:01 <benja_> the Makefile still references it =)
10:18:53 <Lemmih> benja_: There's no Makefile in the conjure repository I maintain.
10:19:02 <Lemmih> @where conjure
10:19:03 <lambdabot> http://darcs.haskell.org/~lemmih/conjure/
10:19:12 <benja_> Lemmih: http://darcs.haskell.org/~lemmih/conjure/Makefile
10:19:54 <Cheery> You know the parsers which can be in 'multiple state' at same time, wouldn't one be capable of writing very clever and general interface for interpretting user input?
10:20:30 <Cheery> just take the states coming to the system and parse them, possibly with state indicators.
10:20:48 <Lemmih> benja_: And now it's gone (:
10:20:54 <benja_> :)
10:21:05 <Lemmih> benja_: I had 9 unpushed patches.
10:21:31 <benja_> right =)
10:21:46 <sjanssen> benja_: get a full copy of the conjure repo and start unpulling patches until LRU.hs exists
10:22:21 <Cheery> has anybody else thought about using parsers for this purpose?
10:22:35 <Lemmih> benja_: Perhaps you can find jlouis' repo. He's the original author.
10:26:22 <paolino> what is @djinn ?
10:27:09 <paolino> @djinn (++).return
10:27:10 <lambdabot> Cannot parse command
10:27:20 <allbery_b> @help djinn
10:27:21 <lambdabot> djinn <type>.
10:27:22 <lambdabot> Generates Haskell code from a type.
10:27:22 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
10:27:31 <benja_> did darcs changes Data/LRU.hs and then darcs unpull --from-patch. thanks! :)
10:27:34 <benja_> "The implementation provided here is very
10:27:35 <benja_> -- slow and uses lists for everything in the wrong way"
10:27:45 <benja_> I suppose I can do better than that though =)
10:30:01 <paolino> @ty (:[])
10:30:02 <lambdabot> forall a. a -> [a]
10:30:30 <sjanssen> benja_: I think you could write a very nice LRU implementation with Data.FingerTree
10:31:14 <benja_> sjanssen: where's that? (I only know Data.Sequence which doesn't provide the necessary interface even though it does use finger trees...)
10:31:24 <paolino> @pl (++).return
10:31:24 <lambdabot> (++) . return
10:31:26 <sjanssen> @where FingerTree
10:31:27 <lambdabot> I know nothing about fingertree.
10:31:32 <sjanssen> @where Data.FingerTree
10:31:33 <lambdabot> I know nothing about data.fingertree.
10:31:44 <sjanssen> @google hinze paterson fingertree
10:31:48 <lambdabot> http://www.soi.city.ac.uk/~ross/software/html/Data-FingerTree.html
10:31:54 <benja_> aha
10:32:13 <sjanssen> @where+ Data.FingerTree http://www.soi.city.ac.uk/~ross/software/html/Data-FingerTree.html
10:32:13 <lambdabot> Done.
10:32:21 <sjanssen> @where+ FingerTree http://www.soi.city.ac.uk/~ross/software/html/Data-FingerTree.html
10:32:22 <lambdabot> Done.
10:33:33 <mattam> @google haskell fingertree
10:33:35 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
10:33:36 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
10:33:58 <mattam> i've just done them in Coq :)
10:35:18 <Cheery> Finger trees?
10:35:21 <Cheery> never heard of. :)
10:35:21 <mattam> yep
10:36:16 <paolino> :t Data.Map.insertWith
10:36:17 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
10:36:50 <Cheery> what makes them general purpose?
10:37:01 <mattam> They're a bit strange, but seem very effective for a wide range of operations
10:37:28 <mattam> small amortized complexity for almost every op
10:37:36 <sjanssen> Cheery: Hinze and Paterson's formulation provides a general querying and information caching mechanism
10:37:38 <chessguy> hmm, there's no source code there
10:37:44 <emu> Data.Sequence uses finger trees i think
10:37:51 <emu> ah someone said it
10:38:02 <mattam> chessguy: look at my link
10:38:03 <sjanssen> yes, Data.Sequence is a specialized Data.FingerTree
10:38:31 <benja_> by the way, if someone wants to learn about a data structure related to finger trees and doesn't mind reading a text coming at it from a completely different perspective: http://xanadu.com/tech/
10:38:33 <lambdabot> Title: XANADU TECHNOLOGIES-- an introduction
10:39:16 <benja_> it talks about "WIDative" and "DSPative" properties, where "WIDative" would be like those in Finger Trees
10:39:31 <benja_> and DSPative a related notion
10:39:36 <Cheery> mattam: even they are strange, would they be useful enough to have their own syntax or ways to handle them?
10:40:12 <mattam> no, their shape is strange, not the external interface you can have on top of them
10:41:19 <mattam> ie, you can have cons, snoc, append, split, traverse easily
10:41:35 <Cheery> oh well, I think I then take a look at them.
10:41:58 <paolino> mhh is [1]++ [2..10] efficient ?
10:42:04 <Cheery> This channel seems being very useful for learning something new.
10:42:14 <glguy> oh?
10:42:28 <allbery_b> paolino: 1 : [2..10] would be more efficient
10:42:38 <sjanssen> [1..10] -- is the best
10:42:45 <glguy> paolino: that appending of a constant number of elements has constant comlexity :)
10:43:09 <paolino> I mean more efficient than [1..9] ++ [10]
10:43:32 <glguy> the first example doesn't copy the second list
10:43:40 <chessguy> benja_, i suspect the idea of that page is really interesting, but obfuscated idea
10:43:44 <glguy> ++ has to copy its first list
10:43:45 <chessguy> shame
10:43:53 <glguy> so the second example is less efficient
10:43:58 <mattam> FingerTree A = Empty | Single A | Deep (digit A) (FingerTree (node A)) (digit A) where digit A = One A | Two A A... Four ... and node A = Node2 A A | Node3 A A A, the FingerTree (node A) is key here
10:43:59 <sjanssen> paolino: xs ++ ys is O(length xs)
10:44:30 <benja_> chessguy: =)
10:44:40 <paolino> ok, I suspect lists are not the best choice in my case anyway
10:45:50 <sjanssen> paolino: if you have ghc 6.6 use Data.Sequence
10:46:04 <paolino> I was in doubt for insertWith (++) or insertWith (flip (++)) , this is the reason of my question
10:46:49 <bakert_> "show ClockTime" gives a fairly decent result but it's just a bit too verbose. Is there anyway to format a ClockTime without going into IO (other than manipulating the show String which I really don't want to do)?
10:47:16 <bakert_> CalendarTime has formatCalendarTime but to get a ClockTime to be a CalendarTime I need IO.  I think.
10:47:49 <chessguy> ?src Data.Sequence
10:47:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:48:18 <bakert> Sorry, logged in twice.  Anyone know how to format a ClockTime?
10:48:18 <allbery_b> bakert: yes, it needs to refer to your timezone so it's in IO
10:48:28 <paolino> probably insertWith (Set.add) is best
10:48:59 <bakert> allbery_b, right.  But  show ClockTime manages to create a representation without that.  So can I not do something like whatever show ClockTime does?
10:49:11 <allbery_b> toUTCTime on the other hand doesn't, and is pure
10:49:16 <quicksilver> Some monads have the property that >> is 'left-absorbing' i.e. that a >> b == b (ignoring seq and program termination)
10:49:16 <bakert> aha!
10:49:19 <quicksilver> one example is the reaqder monad
10:49:22 <bakert> allbery_b, that sounds like my boy
10:49:50 <quicksilver> is there a name for this property? intuitively, these monads are 'stateless'
10:49:51 <bakert> thanks
10:50:40 <glguy> ?type mapAccumL
10:50:42 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:53:23 <paolino> mmh, isn't a fold ?
11:01:07 <paolino> I want to inject a @pl somewhere in the empty space inside my skull
11:04:26 <paolino> @pl \ gss rs  -> map (\(gs,r) -> zip gs (repeat r)) (zip gss rs)
11:04:26 <lambdabot> zipWith ((. repeat) . zip)
11:04:30 <chessguy> hmmm, the link about finger trees said they could be used to create priority queues and such. does that mean that Data.Seq can be use to do that too?
11:04:33 <glguy> paolino: the *practice* tool works great for that
11:04:46 <chessguy> glguy, practice tool?
11:05:08 <glguy> yeah, practicing @pl on paper and figuring it out before you ask lambdabot helps a lot
11:05:16 <glguy> (lot more than just watching lambdabot do it :) )
11:05:17 <chessguy> ohh, THAT tool
11:05:18 <paolino> ehi see what it did
11:05:30 <chessguy> is there an algorithm for performing @pl?
11:05:39 <therp> sometimes it really takes a lot of programming fu to debug stuff like Prelude.head: empty list.
11:05:44 <glguy> obviously, since lambdabot can do it
11:05:47 <earthy> obviously there is, chessguy. :)
11:05:55 <chessguy> yes, that was a pretty stupid question, wasn't it.
11:06:06 * earthy nods
11:06:17 <chessguy> is there a human-comprehensible algorithm for it?
11:06:23 <glguy> (canned response) There are no stupid questions, only stupid people ;)
11:06:44 <chessguy> glguy, well i certainly qualify for that
11:06:50 <paolino> :t (. repeat)
11:06:52 <lambdabot> forall a c. ([a] -> c) -> a -> c
11:06:56 <glguy> chessguy: push the rightmost parameter of the argument list to the right most side of the expression
11:07:00 <earthy> glguy: inquisitive idiots. ;)
11:07:01 <glguy> drop both
11:07:15 <glguy> repeat while parameters exist
11:07:32 <chessguy> hmmm
11:07:46 <glguy> when a parameter is used more than once
11:07:47 <earthy> ofcourse, the trick is in 'push to the right most side of the expression'
11:07:57 <glguy> you have to generally use (->) r   to duplicate it
11:08:03 <chessguy> @pl \x -> x*x
11:08:03 <lambdabot> join (*)
11:08:17 <chessguy> can you give an example of how you would work this out?
11:08:31 <glguy> \x -> x * x     \x -> join (*) x       join (*)
11:08:32 <earthy> yes. this is using the (->) r monad
11:08:45 <earthy> @type join
11:08:47 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:08:50 <glguy> or to be more verbose:
11:08:55 <glguy> \x -> (*) x x
11:09:02 <glguy> \x -> join (*) x
11:09:04 <glguy> join (*)
11:09:11 <paolino> :t (.repeat) sum
11:09:13 <lambdabot> forall a. (Num a) => a -> a
11:09:42 <chessguy> how do you get  \x -> join (*) x from \x -> (*) x x
11:09:43 <glguy> (.b) a      flip (.) b a       (.) a b       a . b
11:09:44 <paolino> :t (.repeat) sum 4
11:09:45 <lambdabot> forall a. (Num a) => a
11:09:56 <glguy> chessguy: you have to know what join does
11:09:56 <earthy> chessguy: using the (-> r) monad
11:10:10 <paolino> > (.repeat) sum 4
11:10:14 <lambdabot> Terminated
11:10:41 * paolino machecazz
11:11:28 <xerox> ?slap paolino
11:11:28 * lambdabot beats up paolino
11:12:04 <paolino> :t (.repeat). zip
11:12:06 <lambdabot> forall a a1. [a1] -> a -> [(a1, a)]
11:12:06 <xerox> paolino: sum (repeat 4)
11:12:16 <earthy> hmdamn. :)
11:12:20 <xerox> \x -> zip (repeat x)
11:12:35 * earthy is writing that section wrong
11:12:37 * chessguy decides to just go look at LB's source code
11:12:47 <chessguy> i hope you don't mind, lambdabot
11:12:50 <xerox> What's the matter?
11:12:50 * glguy waves farewell to chessguy 
11:12:59 <Stinger> does anyone know how to break ghci from a nonterminating prog in windows?
11:12:59 <paolino> ah
11:13:02 <earthy> @type join :: (r -> (r -> a)) -> (r -> a)
11:13:04 <lambdabot> (r -> (r -> a)) -> (r -> a) :: forall r a. (r -> r -> a) -> r -> a
11:13:13 <allbery_b> @version
11:13:14 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
11:13:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:13:15 <chessguy> glguy, i didn't mean i'm leaving right now
11:13:16 <glguy> chessguy: I don't think that @pl's source code is considered "accessible" :-)
11:13:23 <chessguy> oh
11:13:24 <allbery_b> LB's an exhibitionist :)
11:13:24 <glguy> chessguy: I just mean you'll be gone a while
11:13:25 <xerox> earthy: join f x = f x x
11:13:35 <chessguy> figures
11:13:35 <earthy> xerox: for that instance, yes.
11:13:41 <glguy> ?src (->) join
11:13:41 <lambdabot> Source not found. My pet ferret can type better than you!
11:13:47 <earthy> ?src join
11:13:47 <lambdabot> join x =  x >>= id
11:13:58 <glguy> ?src ((->)r) join
11:13:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:14:02 <xerox> What are you investigating today? I was trying to understand why paolino was angry at that.
11:14:03 <arjanoosting> away
11:14:15 <earthy> ?src ((->) r) >>=
11:14:16 <lambdabot> Source not found. You speak an infinite deal of nothing
11:14:29 <earthy> ?src >>= :: ((->) r)
11:14:29 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:14:32 * glguy doesn't fully understand ?src's logic
11:14:32 <xerox> join is defined as |join x = x >>= id| for all the monads, not in the instance.
11:14:39 <paolino> > zipWith ((.repat).zip) "pao" [[1,2,3],[2,3,4],[3,4,5]]
11:14:39 <lambdabot>   Not in scope: `repat'
11:14:49 <earthy> ?src ((->) r) (>>=)
11:14:49 <lambdabot> Source not found. stty: unknown mode: doofus
11:14:55 <paolino> > zipWith ((.repeat).zip) "pao" [[1,2,3],[2,3,4],[3,4,5]]
11:14:56 <lambdabot>  Couldn't match `[a]' against `Char'
11:15:12 <glguy> xerox: lambdabot will provide source for what ap does in (->) r somehow
11:15:19 <paolino> > zipWith ((.repeat).zip)  [[1,2,3],[2,3,4],[3,4,5]] "pao"
11:15:21 <lambdabot>  [[(1,'p'),(2,'p'),(3,'p')],[(2,'a'),(3,'a'),(4,'a')],[(3,'o'),(4,'o'),(5,'o')]]
11:15:34 <xerox> glguy: yeah, via djinn.
11:15:40 <glguy> xerox: I just never seem to guess correctly at the syntax
11:15:46 <glguy> ah
11:16:08 <earthy> instance Monad ((->) r) where
11:16:08 <earthy>         return = const
11:16:08 <earthy>         f >>= k = \ r -> k (f r) r
11:16:51 <chessguy> if i do newtype Foo a = Bar a, will Foo automatically derive everything that Bar derives?
11:16:56 <earthy> anyway.   (\r -> k (f r) r) id    is \r -> f r r
11:16:57 <xerox> ?djinn (e -> a -> b) -> (e -> a) -> (e -> b)
11:16:58 <lambdabot> f a b c = a c (b c)
11:17:05 <newsham> ?uptime
11:17:05 <lambdabot> uptime: 1d 7h 37m, longest uptime: 2d 3h 42m 19s
11:17:09 <newsham> ?farber
11:17:09 <earthy> !sigh
11:17:09 <lambdabot> Unknown command, try @list
11:17:13 * earthy is tired.
11:17:18 <earthy> time for food
11:17:21 <chessguy> @quote tired
11:17:22 <lambdabot> No quotes match. Are you on drugs?
11:17:24 <xerox> Have a good meal (:
11:17:25 <allbery_b> chessguy: no, you need to use the newtype deriving stuff (ghc extension I think)
11:17:39 <chessguy> hmm. i don't get what precisely newtype does then
11:17:42 <rahikkala> @protontorpedo
11:17:42 <lambdabot> is there going to be a better dns server in haskell?
11:17:45 <earthy> xerox: it'll take 20 minutes for the oven to finish cooking it. ;)
11:17:50 <chessguy> @keal
11:17:50 <lambdabot> what are epsilons?
11:17:53 <xerox> earthy: oh, and what's that.
11:18:26 <earthy> puff pastry filled with chicken and broccoli in a liaison of cream and eggs.
11:18:47 <xerox> ?arr!
11:18:48 <lambdabot> I'll keel haul ya fer that!
11:18:58 <xerox> Errr.
11:19:03 <earthy> aka poormans quiche.
11:19:11 <earthy> which makes me not a real programmer. :)
11:19:26 <xerox> Real programmers don't cook?
11:19:35 <earthy> don't eat quiche. :)
11:19:46 <CosmicRay> they don't liaison with cream
11:20:58 <chessguy> maybe i just need to find more examples of uses of newtype
11:21:34 <chessguy> ?hoogle newtype
11:21:34 <lambdabot> Prelude.newtype :: keyword
11:21:35 <lambdabot> Language.Haskell.TH.newtypeD :: CxtQ -> Name -> [Name] -> ConQ -> [Name] -> DecQ
11:21:35 <lambdabot> Language.Haskell.TH.NewtypeD :: Cxt -> Name -> [Name] -> Con -> [Name] -> Dec
11:21:58 <CosmicRay> newtype is a keyword.  what is your question about it?
11:22:15 <chessguy> <chessguy> hmm. i don't get what precisely newtype does then
11:22:52 <CosmicRay> to the programmer, it does the same thing as type
11:22:57 <CosmicRay> I think there is some optimization in the backend
11:23:17 <earthy> there is a fundamental difference though
11:23:57 <chessguy> difference from data you mean?
11:24:06 <earthy> between type and newtype
11:24:17 <bd_> CosmicRay: newtype is more like data
11:24:18 <bd_> except
11:24:25 <bd_> a) there's only one, one-argument constructor
11:24:26 <chessguy> earthy, what's that?
11:24:32 <bd_> and that constructor is strict in its argument
11:24:40 <bd_> there's also another subtle difference; if you have:
11:24:47 <bd_> foo (Constructor x) = ()
11:24:58 <bd_> if you have:
11:25:04 <earthy> newtype introduces a constructor. type does not.
11:25:06 * lispy needs help with Fortran, any takers? ;)
11:25:07 <bd_> newtype T = (Constructor Int)
11:25:16 <bd_> then foo undefined = ()
11:25:16 <bd_> if you have:
11:25:22 <bd_> data T = Constructor !Int
11:25:24 <bd_> then foo undefined = undefined
11:25:45 <earthy> therefore, newtype allows you to distinguish between values of the new type and of the original type
11:25:50 <earthy> whereas type does not
11:25:51 <bd_> newtype will also nearly always be more efficient than a data construction
11:26:17 <chessguy> so it's desirable to use newtype where possible?
11:26:38 <bd_> yes; if you need to you can replace it with data later
11:26:44 <xerox> (newtype QuicheEater = QE Programmer you can easily distinguish.)
11:26:46 <earthy> well, I almost never see a need for usintg 'type'
11:27:02 <bd_> earthy: type lets you use shorthand in type signatures :)
11:27:13 <earthy> bd: that's the *only* use
11:27:15 <quicksilver> String, for example, is a type and not a newtype
11:27:25 <quicksilver> the reas is, we want the list functions to work on it unaltered
11:27:29 <earthy> that I see. ;)
11:27:33 <quicksilver> (at least, I assume that's the reason)
11:27:43 * earthy nods
11:27:59 <bd_> earthy: type ComplexM a = StateT Foo (ReaderT Bar (WriterT (Seq String) (ContT () IO a)))
11:28:03 <bd_> or something :)
11:28:26 <bd_> you can use generalized newtype deriving I suppose
11:28:27 * earthy doesn't normally build complex shit like that. ;)
11:28:27 <xerox> bd_: I think you're better off writing a newtype for that.
11:29:09 <bd_> only if you want to encapsulate the details >.>
11:29:21 <bd_> which I suppose is usually the case
11:29:23 <glguy> and want sane error messages
11:29:27 <chessguy> hmm, this looks like an interesting example
11:29:28 <chessguy> http://www.haskell.org/haskellwiki/Non-trivial_type_synonyms\
11:29:31 <chessguy> http://www.haskell.org/haskellwiki/Non-trivial_type_synonyms
11:29:33 <lambdabot> Title: Non-trivial type synonyms - HaskellWiki
11:29:54 <xerox> ?hoogle Control.Monad.RWS.RWST.
11:29:55 <lambdabot> No matches, try a more general search
11:29:57 <chessguy> so the idea is that you only want to use Miles where miles should be, and not other integers
11:30:01 <chessguy> right?
11:30:06 <xerox> That without ContT IO (which is too scary), has got a nice name in factThat without ContT IO (which is too scary), has got a nice name in fact Control.Monad.RWS.RSWT
11:30:15 * xerox sighs...
11:30:50 * chessguy raises an eyebrow at xerox 
11:30:56 <xerox> I'm using Circe version from CVS (2006-08-15 19:38:32) with GNU Emacs 22.0.50.1 (of 2006-08-19)
11:31:01 <xerox> I pressed some weird key combination.
11:31:21 <dylan> bd_ can find a complex solution to almost any problem.
11:31:23 <chessguy> that happens to me in vi all the time
11:31:47 <glguy> ContT == too scary??
11:31:59 <bd_> xerox: RWST?
11:32:19 <xerox> ?docs Control.Monad.RWS
11:32:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html
11:32:21 <glguy> Reader-WRiter-State-T
11:32:38 <glguy> :k RWST
11:32:39 <lambdabot> Not in scope: type constructor or class `RWST'
11:32:47 <bd_> ah
11:32:49 <glguy> :k Control.Monad.RWS.RWST
11:32:51 <bd_> They probably should mention that acronym in the docs somewhere
11:32:51 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
11:33:34 <glguy> reader type writer type state type monad type result :) type
11:33:38 <earthy> Dazzle has 68 'type' declarations
11:33:51 <earthy> most of which are for documentation
11:34:09 <earthy> eg: NetworkModel.hs:type NodeNr = Int
11:34:09 <earthy> NetworkModel.hs:type EdgeNr = Int
11:34:09 <earthy> NetworkModel.hs:type ViaNr  = Int
11:34:09 <earthy> NetworkModel.hs:type ValueNr = Int
11:36:34 <justonp6> Hey all
11:36:44 <earthy> hya juston
11:37:13 <earthy> how's code
11:37:16 <earthy> ?
11:37:24 <justonp6> Just about to start learning haskell and I thought i'd start to idle too :p
11:38:07 <earthy> you know about the wiki? :)
11:38:37 <justonp6> yup
11:38:46 <justonp6> on the haskell.org domain right?
11:39:02 <justonp6> ./haskellwiki
11:39:05 <earthy> yup
11:39:37 <earthy> and, http://www.cs.uu.nl/wiki/FP/ has all materials for a course in fp with haskell
11:39:42 <lambdabot> Title: FP / Web Home
11:39:49 <earthy> a course that is running Right Now
11:40:00 <justonp6> oh neat!
11:40:14 <justonp6> wow, this chan really is very helpful just like it said!
11:41:41 <lispy> yes, in fact, i've asked for help in 4 language channels in the last 10 minutes and the #haskell is the only where i didn't get chastized :)
11:42:24 <velco> lispy: and #c
11:42:40 <justonp6> :p
11:42:42 <lispy> yeah, i guess in #C they just didn't care
11:42:49 <lispy> told me to go to ##java
11:42:56 <velco> yeah :D
11:42:57 <justonp6> our of curiousity, do any of you guys use haskell for "challenge sites"
11:43:06 <lispy> justonp6: some people here do yeah
11:43:10 <glguy> justonp6: I used it for projecteuler.net
11:43:11 <lispy> justonp6: glguy i think is one
11:43:22 <dylan> I bought a book of recreational mathematics and I plan on using haskell for that.
11:43:24 * glguy *used* to be at 100% completion :(
11:43:35 <justonp6> :p
11:43:39 <justonp6> I like this chan
11:43:52 <glguy> We've kicked all the unfriendly people ;)
11:43:56 <glguy> ?yarr!
11:43:57 <lambdabot> Aye
11:44:06 <chessguy> @quote friendly
11:44:06 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
11:44:10 <chessguy> pff
11:44:17 <glguy> ?quote chessguy
11:44:18 <lambdabot> chessguy says: [<newsham> (if complicatedly is indeed a word)] <chessguy> newsham, if it's not a word, just define it and add it to the language. that's what FP is is all about, right?
11:44:43 <chessguy> ?quote glguy
11:44:43 <lambdabot> glguy says: Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
11:44:55 <glguy> that even came up again!
11:45:01 <glguy> and I recognized it
11:45:07 <chessguy> 2^1024? that's a big number
11:45:12 <glguy> when someone did: floor (1/0 :: Double)
11:45:17 <glguy> > float (1 / 0 :: Double)
11:45:18 <lambdabot>   Not in scope: `float'
11:45:21 <glguy> > floor (1 / 0 :: Double)
11:45:23 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
11:45:29 <glguy> > 2^1024
11:45:30 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
11:45:34 <glguy> I spotted it :)
11:45:41 <chessguy> > log 10 (2^1024)
11:45:42 <lambdabot>   add an instance declaration for (Floating (a -> a1))
11:45:43 <lambdabot>     In the definition ...
11:45:47 <justonp6> does anyone know if there is a fastest way to do fibbonacci numbers, insane ones?
11:45:51 <glguy> logBase*
11:45:53 <lispy> > length $ show $ 2 ^ 1024
11:45:54 <lambdabot>  309
11:46:02 <therp> is there something inefficient about compilation in GHC when strings are not represented as "foobar" but as ['f','o','o','b','a','r'] ?
11:46:05 <chessguy> lispy, aww, that's cheating
11:46:06 <chessguy> lol
11:46:24 <lispy> justonp6: you want to talk to Pseudonym
11:46:30 <bd_> justonp6: The naive way is O(n lg n), but I /think/ there's a O(lg n) method. Not sure though.
11:46:39 <glguy> > logBase 10 (2 ^ 1024)
11:46:41 <lambdabot>  Infinity
11:46:51 <Jaak> yeah, there is log n method
11:46:55 <glguy> > logBase  (2 ^ 1024) 10
11:46:56 <lambdabot>  0.0
11:47:11 <bd_> > logBase 10 2 * 1024
11:47:13 <lambdabot>  308.2547155599167
11:47:13 <glguy> what did lambdabot actually say there?
11:47:14 <justonp6> hmm
11:47:24 <glguy> I see a 8-O
11:47:26 <glguy> or something
11:47:28 <glguy> emoticoned
11:47:39 <chessguy> <glguy> > logBase  (2 ^ 1024) 10
11:47:39 <chessguy> <lambdabot>  0.0
11:47:43 <chessguy> you mean there?
11:47:49 <glguy> chessguy: yeah... break that up
11:47:51 <glguy> the second line
11:47:56 <chessguy> oh, sorry
11:48:00 <chessguy> 0 . 0
11:48:04 <glguy> oh, lol
11:48:29 <chessguy> what client are you using?
11:48:45 <glguy> Colloquy
11:49:00 <glguy> I use that an irssi exclusively
11:49:11 <chessguy> ewww, mac
11:49:12 <glguy> unless my server is down or something
11:49:25 <glguy> chessguy: what's better than a mac (don't say linux)
11:49:31 <chessguy> anything?
11:49:32 <justonp6> lol
11:49:33 <kowey> glguy: why not configure it to display emoticons as text (i have mine set to colour them, but leave them text)
11:49:34 <kowey> ?
11:49:44 <lispy> kowey: hi
11:49:45 <glguy> kowey: because in general I like them (-:
11:49:50 <kowey> :-)
11:49:55 <chessguy> lol
11:49:56 <kowey> heya lispy, long time no see
11:50:06 <chessguy> > 0.0 -- smile for glguy
11:50:08 <lambdabot>  0.0
11:50:14 <glguy> ?yow!
11:50:14 <lambdabot> Yes, but will I see the EASTER BUNNY in skintight leather at an IRON
11:50:15 <lambdabot> MAIDEN concert?
11:50:37 * chessguy sighs
11:50:43 <chessguy> ok, i really should get back to work
11:51:14 <chessguy> or at least pretending to work
11:53:34 <dylan> URIs are functions!! damn MVC and catalyst!
11:53:41 <dylan> </explosion>
11:53:47 <glguy> I washed my car today
11:53:50 <glguy> it's below freezing
11:53:58 <glguy> I've got a layer of ice on my car
11:54:15 * resiak looks at dylan
11:54:20 <glguy> but there was just so much salt... was disgusting
11:55:19 <chessguy> yeah, my car's the same way
11:55:24 <dylan> resiak: haskell has made me hate the app I'm writing at work.
11:56:01 <dblhelix> regarding the first article in the latest issue of TMR, i.e., the one on dropWhile: why not just make the first solution (dwBackwards) less strict? (I'm sure this is discussed here before... haven't been around too much the last couple of days)
11:56:03 <dylan> and in particular hate the idea of using model-view-controller "design platter" for web application...
11:56:19 <SamB> dylan: I just plain don't understand MVC
11:56:47 <dylan> SamB: as my father would say, it's a distinction without a difference. :P
11:57:38 <SamB> what? between hating and not understanding? or between models and views, models and controllers, or views and controllers?
11:57:42 <SamB> or between all three?
11:57:46 <resiak> dylan: I'm using Catalyst for an app I'm writing, because I can produce something that works faster in it than in Haskell :)
11:57:59 <dylan> I stupidly migrated this perl web app which was using a perfectly lovely webpages-are-functions framework to a MVC one named Catalyst.
11:58:08 <SamB> what I can understand is models and pretty-printers
11:58:33 <dylan> resiak: oh, haskell might not work for web apps right now, but Catalyst seems to be slowing me down these last few months.
11:59:12 <dylan> I wish I had never gone away from CGI::Application. At the time is seemed okay, because I wasn't 100% disuaded from "design platters". :-/
11:59:16 <Philippa> dylan: surely MVC-for-webapps is just three tier?
11:59:30 <SamB> Philippa: hah
11:59:35 <SamB> "just three tier"
11:59:38 <SamB> what does that mean?
11:59:43 <dylan> Philippa: I do not comprehend that sentence.
11:59:52 <Philippa> sorry, "just a three tier architecture"
12:00:07 <dylan> For one thing, I started loving my database.
12:00:17 <dylan> so an object-relational mapper now feels like an impairment.
12:00:19 <SamB> morphic makes more sense to me than MVC
12:00:31 <SamB> dylan: duh
12:00:40 <dylan> I looove postgres
12:01:13 <SamB> it works best if you pick objects *or* relational data models
12:02:02 <dylan> I don't really want objects, anyway.
12:02:17 <dylan> Not in the way most "frameworks" use them.
12:03:24 <dylan> complex class hierarchies and subclassing just seems like monkeys. (e.g. interface stuff that twisted.python uses, ugh...).
12:05:21 <dylan> I wish I could send a messaeg to myself six months ago that just says "webpages are functions, stupid!"
12:06:56 <Philippa> um. They're not, they're values?
12:07:27 <dylan> well, URIs are functions.
12:08:26 <SamB> dylan: you mean calls?
12:08:43 <SamB> or maybe GETs and POSTs are calls
12:08:48 <dylan> requesting an HTTP resource is akin to invoking a function.
12:09:20 <SamB> except that there is some state on the server.
12:09:32 <dylan> IO values, then. :)
12:09:43 <SamB> something like ;-)
12:09:46 <dylan> catalyst makes it so each request could cause any number of methods to fire.
12:10:04 <dylan> I just want a 1:1 mapping of request to function, to ensure nothing else is called.
12:10:06 <Philippa> that's not totally stupid for eg logging purposes
12:10:09 <Philippa> but yeah, 1:1 is simpler
12:10:19 <dylan> And to use composition for authentication and such
12:10:31 <therp> hm, is there a way to build GHC packages with stage2 GHC?
12:10:40 <therp> not in general, just for a selected package
12:11:21 <dylan> Philippa: 1:1 with the posibility of composition seems to be quite powerful.
12:11:23 <neonse> I like that you can just google "oleg" and the second hit is his site
12:11:29 <Igloo> therp: I'm not sure I understand the question - if you want to build a package then Cabal is normally the way to go
12:11:31 <Philippa> it is, yes
12:11:47 <Philippa> I built something that smells suspiciously AOP-like on top of that and an encoding of first-class modules
12:12:27 <dylan> anyway,  just have to secretly rewrite this horrible web application using the older, less complicated "framework".
12:12:31 <dylan> What's AOP?
12:12:34 <dylan> Abstract... ?
12:12:43 <reilly> Aspect Oriented Programming
12:12:55 <dylan> Oh, that buzzphrase.
12:13:12 <dblhelix> mmm... the type-arithmetic example on top of the wiki page on this topic is broken for ghc 6.6
12:13:23 <reilly> Not a buzz-phrase ... just much more narrowly useful than the creators imagine
12:14:10 <Philippa> certainly in its usual incarnations
12:14:10 <shapr> SHAZAM!
12:14:19 <Philippa> 'lo shapr
12:14:22 <shapr> hiya!
12:14:29 <dylan> I need to buy my boss a math book or something, too.
12:14:29 <therp> Igloo: hm, it's more complicated than that. I actually want to export compiler internal stuff. it should actually be part of the ghc package, but the GHC package is built with a stage1 compiler. I need to extend the GHC package with source built by a stage2 compiler
12:14:45 <therp> stage2 because it needs meta-programming
12:14:52 <dylan> he needs to learn why it is not desireable to loop over every possible permutation of some set of things for any given problem.
12:15:14 <therp> igloo: so I thought, ok let's make an extra package that is built with the stage2 package instead of fiddling with the GHC package
12:15:50 <Igloo> therp: Do you mean you want to export something generated by TH?
12:16:09 <chessguy_work> @get-shapr
12:16:09 <lambdabot> shapr!!
12:16:11 <therp> igloo: almost correct. my own meta-programming stuff.. Liskell and so on
12:16:30 <Igloo> therp: Why can't stage1 run your meta-programming stuff?
12:17:09 <dcoutts> dylan, that doesn't need maths, you can just point out that it's faster not to have to examine every possible combo. Or you mean he needs convincing that it's safe to skip examining some combos?
12:17:20 <dylan> dcoutts: tried that
12:17:25 <therp> igloo: because stage1 doesn't include GHCi
12:17:25 <therp> igloo: or is that assumption wrong? ..
12:17:35 <dylan> dcoutts: he doesn't think the number of possible combos would be that large.
12:17:35 <paolino> @pl \(x,r) s  -> insertWith (++) x [r] s
12:17:36 <lambdabot> uncurry ((. return) . insertWith (++))
12:18:20 <dylan> dcoutts: e.g. he wanted an option of the order form that would produce orders for every possible combination of things on the order form.
12:18:41 <Igloo> therp: No, that is right
12:19:06 <Igloo> therp: I'm still not following exactly, but the easy way would be to do a 3-stage build and have the extra stuff in teh stage 3 GHC package only
12:19:07 <dcoutts> dylan, so you can't easily calculate the number of combinations or would calculating the number of combos be not that much easier than doing the whole implementation?
12:19:29 <dylan> dcoutts: there are about 10 pulldowns, each with between 3 and 15 choices...
12:19:59 <therp> igloo: wouldn't it be better just to build a seperate package in the libraries hierarchy that has to be built with a stage2 compiler?
12:20:00 <dylan> and each order fires a script that prints a seperate drawing using a plotter.
12:20:15 <dylan> I don't think we could afford the paper.... :)
12:20:20 <Igloo> therp: If it's separate then you can use cabal
12:20:42 <apfelmus> dylan: maybe your boss knows the famous chessboard fable
12:20:56 <dylan> dcoutts: combinations would be things like "windspec = 130, window manufactuer = Bryan Bobson", etc.
12:21:04 <therp> igloo: it has a dependency on the ghc package. does that count as seperate?
12:21:12 <dylan> apfelmus: that's the one! I should teach him that.
12:21:22 <dcoutts> > product [5..14]
12:21:24 <lambdabot>  3632428800
12:21:32 <dcoutts> dylan, hmm that's quite a few combinations
12:21:37 <neonse> dylan: nono, you'r on the wrong track, use this as an excuse to buy a FAST machine!
12:21:40 <Igloo> therp: That's as separate as something has a dependency on the base package (i.e. essentially everything)
12:22:14 <dcoutts> dylan, or have I done the wrong calculation?
12:23:18 <dylan> dcoutts: it was at least an equally huge number.
12:23:42 <apfelmus> dylan: you can even propose him to pay you 0.01$ the first month and than to double it every month
12:23:50 <apfelmus> *then
12:24:07 <dcoutts> dylan, you should tell him the story about the Chinese emperor and the rice and the chess board
12:24:20 <therp> igloo: +that? .. I take that as a yes :)
12:24:30 <dcoutts> or yeah follow apfelmus's suggestion :-)
12:24:48 <hpaste>  Jaak pasted ""fast" Fibonacci numbers" at http://hpaste.org/419
12:24:57 <Igloo> therp: Yup
12:31:27 <emu> is there a class which unites "Set-style" operations much like Foldable covers "fold-like" operations on data types?
12:33:42 <jlouis> emu, what would a Set-style set of operators be? Foldable is possible because reduce has some nice categoric properties one can exploit
12:33:52 <sjanssen> emu: check out Edison
12:34:03 <emu> well i find myself using union, intersection, insert, delete a lot
12:34:20 <emu> but i have to qualify it with either Set. or Map. which is rather annoying and interferes with readability
12:34:35 <jlouis> you could build a type like that yourself
12:34:41 <Stinger> my gtk2hs win installer cant seem to find ghc 6.6 :(
12:35:09 <emu> i was thinking of a class which I could implement for Map and Set. was wondering why it didn't exist.  i will take another look at Edison.
12:35:14 <sjanssen> @where edison -- please use this
12:35:14 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
12:35:29 <jlouis> benja_, you don't want to be using my crap LRU based on lists IIRC
12:35:30 <emu> i have it downloaded somewhere
12:36:18 <sjanssen> hmm, maybe Edison doesn't have a class that is both set-like and map-like
12:37:05 <sjanssen> emu: you could leverage the fact that a Set a is approximately equivalent to Map a ()
12:37:48 <emu> couldn't a type-class with instances for Set and Map cover this ?
12:38:14 * earthy smacks dblhelix
12:38:30 * dblhelix turns the other cheek
12:38:52 <dblhelix> earthy: what's up?
12:38:53 <earthy> do some more advertising for the channels. ;)
12:39:23 <dblhelix> doaitse just guided them to the wiki... they found the channels on their own from there
12:39:24 <sjanssen> it's a bit tricky, because Set's and Map's are different kinds
12:39:40 <xerox> hehe
12:39:44 <emu> sjanssen: basically, i want to take some of my code and "refactor" it towards reading like the mathematical description
12:39:45 <earthy> ah. they'll start using them more then. :)
12:40:13 <xerox> sjanssen: pretty cool.
12:40:49 <dblhelix> earthy: beware of homework questions though ;)
12:41:05 <sjanssen> xerox: what is pretty cool?
12:41:29 <earthy> hey, everybody here has access to your list of 145, right? :)
12:42:14 <dblhelix> :)
12:42:17 <sjanssen> emu: you could make Data.Map an instance of Data.Edison.Coll.SetX
12:42:35 <dblhelix> earthy: they have, but it's all in dutch
12:42:45 * earthy notices
12:43:15 <earthy> that'll work on #haskell.dut though. ;)
12:44:28 <emu> that also requires CollX
12:44:57 <sjanssen> right
12:45:26 * dblhelix is doing some type-level programming
12:45:28 * dblhelix boings
12:45:41 <ookk> is IORef a pointer?
12:45:46 <xerox> sjanssen: Edison!
12:46:21 <emu> i should be able to write an instance for this where "a" is a pair?
12:46:30 <sjanssen> xerox: :)  Edison is the most under appreciated Haskell library
12:46:37 <sjanssen> emu: yeah
12:46:49 <emu> ok, multiparam typeclasses with fundeps GO!
12:47:02 <astrolabe> ookk: A lot of things are pointers behind the scenes, but I don't think you should think of it as a pointer.
12:48:08 <ookk> astrolabe, what i am after is this, can i make as many copies of the IORef as i want and when i do stuff with the different copies it will still manipulate the same value?
12:50:48 <Stinger> anyone managed to install gtk2hs 0.9.11rc on windows?
12:50:49 <dblhelix> never saw this before :): Top level:
12:50:49 <dblhelix>     Context reduction stack overflow; size = 20
12:50:49 <dblhelix>     Use -fcontext-stack=N to increase stack size to N
12:51:12 <earthy> you're trying to program division? :)
12:51:26 <ookk> astrolabe, im asking because i use them like that in a program right now, and the values in my IORefs doesnt change like they are supposed to
12:51:37 <astrolabe> ookk: I don't understand what you mean by 'copies', but if you can change one IORef in many different places.
12:52:57 <ookk> astrolabe, for instance, i have a global list of IORefs that i pass to different functions
12:53:11 <dblhelix> earthy: not yet, just computed 4^4 :)
12:53:24 <astrolabe> ookk: Make sure you really need an IORef.  Pure functions are more in the spirit of haskell.
12:53:31 <dblhelix> having a good time, though
12:53:55 <ookk> astrolabe, well this is for the programming language shootout
12:54:03 <ookk> so i have to use them for speed
12:54:15 <astrolabe> ookk: In that case you probably know a lot more about this than I do :)
12:55:23 <ookk> astrolabe, i dont think i know enough because i cant explain why the values in my IORef dont change
12:55:38 <ookk> when i look at the values locally in the function that changes them, they change
12:55:52 <ookk> but when i look at them in the function that calls that function they dont change
12:56:12 <sjanssen> ookk: can you paste your program?
12:56:34 <ookk> sure
12:56:38 <ookk> !paste
12:56:38 <hpaste> Haskell paste bin: http://hpaste.org/
12:56:55 <astrolabe> ookk: So it sounds as though you are accidentally making copies rather than using the same IORef?
12:57:09 <ookk> astrolabe, yes i am making copies of the IORef
12:57:16 <ookk> because i think it shouldnt matter?
12:57:24 <ookk> they should just be a address to a value
12:57:38 <ookk> if i copy that adress 1000 times it still points to the same data
12:58:01 <sjanssen> there isn't really a concept of "copy" in Haskell
12:58:08 <hpaste>  ookk pasted "n-body" at http://hpaste.org/420
12:59:56 <ookk> sjanssen, the position changes but not the velocity
13:00:37 <ookk> data Planet = Planet Vector3Ref Vector3Ref Double {- Planet position velocity mass -}
13:00:56 <sjanssen> ookk: every time you use the "planets" IO function, you're going to create a bunch of distinct planets?
13:01:07 <sjanssen> erm, that wasn't supposed to be a question
13:01:13 <ookk> sjanssen, yes, that is why i only use it once
13:01:30 <ookk> sjanssen, and pass the resulting list as a parameter to the other functions
13:01:42 <sjanssen> ookk: you use it in planetPairs and main
13:01:52 <ookk> hah yeah there you have it!
13:02:05 <ookk> thx
13:02:06 <encryptio> is there some sort of range optimization that could be done on some values? is it done? (the optimization i'm talking about would make (length (repeat 1)) > 10 not go into an infinite loop)
13:02:10 <ookk> that i didnt see that
13:02:12 <paolino> :t ap
13:02:13 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
13:02:49 <sjanssen> encryptio: the solution is to use genericLength and a different definition of 10
13:03:03 <sjanssen> @src genericLength
13:03:03 <encryptio> sjanssen: no, it's not - that's not my problem
13:03:04 <lambdabot> genericLength []    = 0
13:03:04 <lambdabot> genericLength (_:l) = 1 + genericLength l
13:03:05 <encryptio> but
13:03:43 <paolino> @hoogle zip
13:03:43 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
13:03:44 <lambdabot> List.zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
13:03:44 <lambdabot> List.zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
13:03:49 <sjanssen> if you use peano numbers, then "genericLength (repeat 1) > 10" terminates
13:03:52 <encryptio> i'm just thinking that it could make some things much easier.. stable inifintely recursive functions on floating point values could actually be executed
13:03:55 <emu> i'm going to try using Edison unqualified and hide Prelude names =)
13:04:46 <encryptio> and it would be a completely static optimization - no runtime costs if it doesn't help
13:07:02 <encryptio> maybe i'll write a paper.
13:08:20 <chessguy_work> what is this Edison module i hear people talk about?
13:08:55 <sjanssen> chessguy_work: Edison is a package with classes that abstract common operations on data structures
13:09:06 <chessguy_work> ?where Edison
13:09:06 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
13:09:09 <chessguy_work> ah
13:12:11 <olliej> ?src List.zip5
13:12:11 <lambdabot> Source not found. stty: unknown mode: doofus
13:12:34 <therp> igloo: can you give me a hint, how I would use cabal to build stuff in libraries/ with stage2?
13:12:47 <olliej> ?src zipWith
13:12:47 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:12:48 <lambdabot> zipWith _ _      _      = []
13:13:25 <Igloo> therp: Ah, you want to build it as part of the GHC compilation process?
13:13:31 <therp> igloo: yes
13:13:48 <Igloo> There's no support for it yet then, AFAIK
13:17:24 <therp> igloo: oh hmm. I'm tempted to add a post-stage2 target to the libraries/Makefile
13:18:07 <Igloo> therp: Is this a local thing or something you want to go into GHC itself?
13:18:44 <therp> igloo: later it should be part of GHC. It's a something like Prelude, but only for Liskell (which is part of GHC at least in my local fork)
13:19:22 <paolino> :t liftM2 zip
13:19:24 <lambdabot> forall a b (m :: * -> *). (Monad m) => m [a] -> m [b] -> m [(a, b)]
13:19:33 <therp> also Liskell automatically adds this Prelude to the import list, so it's tied to the compiler pretty closely
13:20:17 <paolino> :t liftM2 zip. liftM2 zip
13:20:19 <lambdabot> forall b a b1. [[a]] -> ([[b1]] -> [b]) -> [[b1]] -> [([(a, b1)], b)]
13:20:22 <Igloo> therp: It sounds like this should be something that can be distributed as a standalone cabal package that depends on the ghc package
13:21:24 <ookk> does mapM_ have memory problems?
13:21:27 <ookk> it seems so
13:21:31 <therp> igloo: yes, but as the "base" package it should be compiled along GHC compilation
13:21:59 <bd_> ookk: memory problems?
13:22:43 <ookk> bd_, if i call a function lots of times with: mapM_ (\_ -> return ()) [1..5]
13:22:49 <ookk> my program starts to eat ram
13:23:13 <Igloo> therp: We're generally trying to cutdown what gets built with GHC, hence phasing out the non-core libraries
13:23:18 <ookk> but if i call the same function with return () instead of mapM_ (\_ -> return ()) [1..5] it does not consume any memory
13:24:23 <therp> igloo: I don't consider this non-core, or do you define Prelude as non-core?
13:24:51 <ookk> bd_, it seems you cannot use mapM_ as a loop replacement
13:25:02 <bd_> hmm
13:25:08 <bd_> for [1..5]?
13:25:20 <Igloo> therp: Prelude is needed to build GHC and Cabal, so it is core
13:25:24 <bd_> I shouldn't think that would cause a space leak. What side effects are you doing in there?
13:25:33 <bd_> You may have a space leak in the loop body
13:25:55 <ookk> i dont do anything right no, i removed everything except mapM_ (\_ -> return ()) [1..5]
13:26:01 <ookk> to test if it was indeed the space leak
13:26:21 <bd_> hm
13:26:52 * bd_ tests
13:27:07 <bd_>       1,240 bytes maximum residency (1 sample(s))
13:27:21 <bd_> that's main = mapM_ (\_ -> return ()) [1..10000000]
13:27:25 <bd_> what monad are you in?
13:27:29 <int-e> ookk: how do you run the program, how did you compile it?
13:27:30 <ookk> IO
13:27:59 <paolino> @pl  liftM2 zip (liftM2 zip a b) c
13:27:59 <lambdabot> liftM2 zip (liftM2 zip a b) c
13:28:20 <ookk> int-e,  {-# OPTIONS_GHC -fbang-patterns -O2 -optc-O -fglasgow-exts -fexcess-precision -optc-ffast-math #-}
13:28:40 <olliej> @pl (\x -> not $ x `elem`  "<>:!")
13:28:41 <lambdabot> not . (`elem` "<>:!")
13:28:49 <paolino> @pl \a b c ->  liftM2 zip (liftM2 zip a b) c
13:28:50 <lambdabot> (liftM2 zip .) . liftM2 zip
13:28:53 <bd_> ookk: I get       5,192 bytes maximum residency (1 sample(s))
13:28:57 <sjanssen> ookk: are you actually calling mapM_ on [1..5], or is it some other list?
13:28:58 <bd_> with that
13:29:50 <ookk> sjanssen, some other list
13:29:54 <ookk> that is constant
13:30:01 <ookk> and passed as an argument to the function
13:30:16 <int-e> btw, note that      mapM_ (\_ -> return ()) [1..]    *does* leak.
13:30:33 <ookk> well my program terminates
13:30:36 <fasta> int-e: why?
13:30:48 <int-e> fasta: because it builds a thunk for 1+1+1+1+1+1...
13:30:58 <int-e> which never gets forced.
13:31:06 <fasta> int-e: I don't see a + operation.
13:31:24 <ookk> sjanssen, but for testing i putt [1..5] there instead
13:31:35 <ookk> because the list i use normally has 5 elements
13:31:37 <int-e> fasta: it's in enumFrom
13:31:48 <int-e> fasta: [1..] == enumFrom 1
13:31:49 <bd_> ookk: Can you paste a complete code example which leaks, in hpaste?
13:31:51 <bd_> ?paste
13:31:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:32:04 <ookk> so basically i just call the function: f a_list = do mapM_ (\_ -> return ()) [1..5]
13:32:30 <fasta> int-e: how can one remove that space-leak?
13:32:30 <ookk> and i use that function with replicateM_ n (f a_list)
13:32:37 <ookk> !paste
13:32:37 <hpaste> Haskell paste bin: http://hpaste.org/
13:32:50 <fasta> int-e: seq?
13:33:11 <bd_> fasta: unfortunately enumFrom in Integer does not use seq in that way
13:33:13 <fasta> int-e: I am not sure where to place it in this case, though.
13:33:32 <paolino> :t (liftM2 zip .) . liftM2 zip
13:33:33 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m [a] -> m [b1] -> m [b] -> m [((a, b1), b)]
13:33:46 <sjanssen> ookk: a_list will be shared between each call to replicateM_, is a_list very large?
13:33:52 <hpaste>  ookk pasted "hmmm" at http://hpaste.org/421
13:33:55 <int-e> fasta: hmm, not sure. but if you don't need the numbers, repeat ()  is a better infinite list.
13:33:59 <therp> igloo: my preference for the moment is that it builds somehow (no matter how). I always go for the dirty version first and refine later. adding stuff to the libraries Makefile seems to work for me
13:34:25 <ookk> sjanssen, actually its two list, one with 5 elements and one with 10 elements
13:34:26 <fasta> int-e: sure
13:34:43 <fasta> int-e: I don't write loops with mapM_ .... <some list>
13:34:47 <bd_> ookk: That code sample doesn't leak for me
13:34:53 <int-e> fasta:  foldr (\x y -> x `seq` x:y) [] [1..]  should do the trick
13:35:13 <fasta> int-e: I either use fix or foldr or explicit recursion
13:35:30 <bd_> ookk: in fact, it hardly does any allocation at all
13:35:48 <ookk> total alloc =   4,801,808 bytes  (excludes profiling overheads)
13:36:01 <bd_>      22,168 bytes allocated in the heap
13:36:03 <bd_>      17,016 bytes maximum residency (1 sample(s))
13:36:11 <bd_> ookk: what version of GHC?
13:36:25 <bd_> also total alloc is probably the wrong stat, you're looking for residency on major GC runs
13:36:25 <ookk> and if i increase the value of repetiotions by 10
13:36:30 <ookk> total alloc =  48,001,808 bytes  (excludes profiling overheads)
13:36:33 <ookk> ghc 6.6
13:36:55 <ookk> bd_, well if i set it even higher my system starts to swap heavily
13:36:56 <bd_> what are you using to get that statistic?
13:37:12 <ookk> ghc test.hs -o test -prof -auto-all
13:37:18 <ookk> ./test +RTS -p
13:37:21 <ookk> cat test.prof
13:37:35 <bd_>         total alloc =       9,656 bytes  (excludes profiling overheads)
13:37:37 <sjanssen> ookk: compile with -O
13:37:52 <ookk> i compiled it with -O3
13:38:05 <bd_> hmm
13:38:09 <sjanssen> ookk: try compiling without profiling
13:38:19 <bd_> -p -O0 has a large alloc. -p -O2 however is quite low
13:38:37 <pf_moore> Quick question - is there an elegant way of writing \(a,b,c) -> a+b+c? For a 2-tuple (a,b) uncurry (+) works, but can I generalise that?
13:38:38 <bd_> -p -O3 low as well
13:38:50 <ookk> sjanssen, i already did, thats how i found out about the space leak
13:38:54 <bd_> pf_moore: unfortunately, no :/
13:38:54 <ookk> sjanssen, it starts to swap
13:39:04 <sjanssen> ookk: you aren't compiling with -O
13:39:07 <ookk> sjanssen, and without profiling i cant know how much memory it consumes
13:39:12 <sjanssen> or this example isn't exhibiting your problem
13:39:27 <pf_moore> bd_: OK, thanks.
13:39:36 <ookk> sjanssen, i have tried with -O
13:39:38 <ookk> and its the same
13:39:43 <sjanssen> because this program runs in constant memory with -O with or without profiling
13:39:44 <ookk> total alloc =  48,001,808 bytes  (excludes profiling overheads)
13:40:03 <sjanssen> ookk: try compiling with -no-recomp
13:40:06 <wilx> You could write yourself a Template Haskell function that would generate such function.
13:40:21 <ookk> sjanssen, i have compiled it with -fforce-recomp everytime
13:40:32 <ookk> !paste
13:40:33 <hpaste> Haskell paste bin: http://hpaste.org/
13:40:44 <sjanssen> ookk: and you're testing the program you pasted?
13:41:08 <fasta> If a certain module never uses some part of a data structure, is it optimized away?
13:41:26 <hpaste>  ookk pasted "this is what i do" at http://hpaste.org/422
13:41:35 <ookk> sjanssen, yes
13:41:40 <ookk> this program i pasted now
13:41:46 <fasta> I am thinking of the use case where one creates a generic data structure and simpler versions get exported.
13:41:59 <bd_> ookk: disable -auto-all
13:42:01 <ookk> and the profiler says: total alloc =  48,001,808 bytes  (excludes profiling overheads)
13:42:47 <ookk> bd_, well then it doesnt record all stats?
13:43:44 <bd_> ookk: well, with -prof-all, I see
13:43:47 <bd_> 240,956,808 bytes allocated in the heap
13:43:49 <bd_>       5,448 bytes maximum residency (1 sample(s))
13:43:53 <bd_> so high heap churn
13:43:54 <bd_> but
13:43:56 <bd_> not much space usage
13:44:24 <tibbe> what was moggi's original paper on monads?
13:44:26 <sjanssen> bd_: the allocation figures are misleading in this example
13:44:31 <ookk> well it is still bad
13:44:35 <tibbe> end of the 80s
13:44:36 <sjanssen> s/bd_/ookk
13:44:38 <ookk> that it has to allocate so much memory
13:44:48 <bd_> sjanssen: Does -auto-all prevent inlining and unboxing?
13:44:48 <sjanssen> ookk: these allocations aren't simultaneous
13:45:10 <sjanssen> bd_: I think -O is forcing inlining of the [1..5] constant here
13:45:31 <sjanssen> but that isn't a real problem, because it's practically free to compute
13:45:40 <bd_> sjanssen: I mean, the allocation counter it much larger if -auto-all is on, even though it claims to not include profiler overheads
13:45:43 <bd_> is*
13:46:58 <sjanssen> ookk: the program is in fact allocating (1000000 * 5) cons cells -- but these cells are gc'ed right away so there is virtually no overhead
13:48:01 <ookk> sjanssen, okay then the space leak in my program must be somewhere else
13:48:12 <sjanssen> ookk: replace 1000000 with maxBound and watch the program with top.  You'll see what I mean
13:48:18 <ookk> sjanssen, i just started searching and saw that profiling number and thought i hade found the leak
13:48:37 <ookk> sjanssen, yeah i did that now, it stays constant at 900kb memory usage
13:49:48 <int-e> sjanssen: hmm, even with -O0 the program doesn't do that for me (21,764 bytes allocated in the heap using replicateM_ 10000000 (f [1..5]))
13:50:55 <sjanssen> int-e: that's considerably smaller than the "48,001,808 bytes" result I got with -O
13:50:59 <int-e> sjanssen: nm.
13:51:08 <int-e> sjanssen: I tested the wrong executable, sorry.
13:51:24 <fasta> Isn't there some overview of all the tricks GHC implements?
13:51:45 <fasta> E.g. constant-folding, copy-propagation, etc.
13:52:29 <int-e> sjanssen: 84 MB with -O0, 21kb with -O. I'm happy.
13:52:55 <Cale> fasta: you had a question for me earlier
13:52:57 <Cale> ?
13:53:04 <int-e> sjanssen: without profiling mind you. I'm using  +RTS -sstderr
13:53:41 <fasta> Cale: I had a case where data types like in Haskell are inherently more inefficient than in e.g. C.
13:53:56 <Cale> oh?
13:54:02 <sjanssen> fasta: please share
13:54:11 <fasta> It are just constants.
13:54:20 <Cale> Does it have something to do with boxing?
13:54:27 <fasta> No
13:55:05 <fasta> I also found out that if I changed the data type definition all was well, again.
13:55:15 <Cale> which datatype?
13:55:29 <fasta> But still in one case I shouldn't need to be forced to program in this way.
13:55:37 <fasta> (via an extra indirection)
13:55:39 <fasta> One moment.
13:55:47 <fasta> I will write up a little data type.
13:57:55 <bd_> ooh. http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=54
13:57:59 <lambdabot> Title: FP Lunch Â» Blog Archive Â» GHC sometimes loops
13:59:13 <sjanssen> bd_: well known problem.  It's even in ghc's manual
13:59:18 <bd_> heh
13:59:21 <ookk> hmm it seems like writeIORef is the problem
13:59:41 <bd_> ookk: More likely, it's what you're writing into it
13:59:54 <sjanssen> ookk: maybe you should force your values before you put them in the IORef?
13:59:56 <hpaste>  fasta pasted "example" at http://hpaste.org/423
14:00:04 <defcon8> is YAHT really the best? I preferred GITC. Would it be recommended for newcomers to haskell?
14:00:11 <ookk> bd_, yes but as faras im concerned, i only have 5 unique IORefs
14:00:12 <defcon8> GITH*
14:00:42 <ookk> sjanssen, i have tried to run the program without the writeIORefs and just the calculations of the values - no memory leaks
14:00:43 <sjanssen> defcon8: many complain that the Gentle Intro isn't very gentle
14:00:49 <Cale> fasta: Err... you want mutability?
14:00:52 <ookk> sjanssen, but as soon as i start to write what i calcultate
14:00:53 <ookk> it leeks
14:01:00 <defcon8> well I looked at yaht and it didn't really seem to get down to any programming
14:01:13 <defcon8> or teaching much about haskell, but I don't know
14:01:17 <int-e> sjanssen: oh. forM_ [1..1000000 :: Int] (\_ -> f [1..5]) allocates much less than  forM_ [1..1000000] (\_ -> f [1..5]) (defaulting to Integer).
14:01:21 <fasta> Cale: well, why not?
14:01:33 <fasta> Cale: it certainly is a lot more natural
14:01:44 <defcon8> are there any carbon-based books that are better than both?
14:02:02 <sjanssen> ookk: ghc's optimizer is tricky, by removing the IORef's perhaps the strictness analyzer is doing a better job?
14:02:03 <ookk> sjanssen, maybe you can use IORefs as pointers to values?
14:02:06 <Cale> What does your function do?
14:02:18 <Cale> and what's the NodeWithContext type?
14:02:29 <sjanssen> ookk: you should try adding a seq before you write to your IORefs -- see what happens
14:02:33 <ookk> sjanssen, yeah but i shouldnt matter if its lazy or strict?
14:02:44 <fasta> Cale: The node with context basically holds a list of indirected and outdirected edges.
14:02:53 <sjanssen> int-e: I think the :: Int version fuses.  I don't know about the Integer version
14:02:55 <Cale> okay
14:03:11 <defcon8> anyone?
14:03:20 <astrolabe> defcon8: 'better' is subjective, but I liked 'the haskell school of expression'
14:03:24 <sjanssen> ookk: I think you're collecting a bunch of really large thunks inside your IORefs
14:03:30 <Cale> So, supposing that you have a function that gives you in O(E) time, a list of all the edges in the graph, you're saying you can't iterate over that in O(E) time?
14:03:40 <defcon8> astrolabe, does it teach the whole language and have lots of exercises?
14:03:48 <fasta> Cale: I am saying that you can't write a function that changes the type of the node label.
14:03:53 <fasta> Cale: edge label, I mean
14:03:57 <ookk> sjanssen, with seq on the calculations but without the IORefs there is no memory leaks
14:04:14 <Cale> ah, okay
14:04:14 <sjanssen> ookk: have you tested seq + IORefs?
14:04:26 <astrolabe> defcon: I guess it has the whole of haskell98 in it, though I couldn't swear to that.
14:04:44 <Cale> That would be simpler if you separated the edge labels so that the nodes could be shared.
14:04:56 <fasta> Cale: I already solved the problem.
14:04:59 <Cale> Okay.
14:05:02 <fasta> Cale: You don't need to solve it for me.
14:05:17 <fasta> Cale: I solved it 2 hours ago
14:05:22 <Cale> okay :)
14:05:22 <ookk> sjanssen, yeah then i have no memory leaks!
14:05:44 <ookk> sjanssen, but i how come ghc allocates an insane amount of thunks?
14:06:24 <sjanssen> ookk: because ghc won't compute the values until you ask it to (by using seq or pattern matching)
14:06:45 <fasta> Cale: Anyway, I thought it was pretty annoying.
14:06:50 <int-e> sjanssen: you're right, the int version fuses, the integer version doesn't. interesting.
14:06:50 <astrolabe> defcon8: and quite a lot of exercises.  Maybe 6 per chapter and 24 chapters.
14:06:57 <defcon8> okay
14:07:06 <astrolabe> defcon8: but I liked yaht!
14:07:07 <ookk> sjanssen, and that is very much sub-optimal in this case
14:07:18 <defcon8> I guess I'll re-read yaht
14:07:37 <astrolabe> defcon8: and do the exercises!
14:07:58 <defcon8> yeah
14:08:16 <Cale> This isn't so much a type system thing though as it's a lack of mutability thing. The edge labels are part of the nodes, and the nodes are immutable, so if you want to change the edge labels, you end up rebuilding the nodes as well.
14:08:35 <sjanssen> int-e: the cases where enumerations fuse is somewhat inconsistent.  For example [1 :: Int .. 10] will fuse, but [1, 2 .. 10 :: Int] won't
14:09:53 <TuringTest> int-e: Does the Integer version fuse if you put in an explicit ::Integer type ?
14:10:34 <int-e> TuringTest: no. (it defaults to Integer so that's not surprise)
14:10:38 <sjanssen> TuringTest: shouldn't make a difference.  The overloading is resolved at type checking time
14:11:24 <TuringTest> ..And why does the fusion care what num type it is?
14:12:49 <sjanssen> TuringTest: the Enum instance for Int is written in a special way
14:12:54 <kpreid> Does GHC 6.6 come with a pathname manipulation library?
14:12:59 <sjanssen> ie. in terms of build
14:13:15 <TuringTest> sjanssen: Okay...that is an excellent reason.
14:13:29 <TuringTest> kpreid: No, but there is one you can install
14:18:28 <int-e> sjanssen: the instance for Integer has rules for that, too. But Integer can't be easily unboxed which probably prevents some other optimizations.
14:19:08 <sjanssen> ah, that makes sense
14:19:09 <int-e> sjanssen: while the rules for the Int instance explicitely unbox the counter.
14:19:23 <Syzygy-> @pl \(a,b) (c,d) -> (a+c,b+d)
14:19:24 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
14:19:31 <Syzygy-> Yowsa!
14:20:01 <TuringTest> kpreid: System.FilePath is at http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
14:20:03 <lambdabot> Title: Neil Mitchell - Haskell Libraries
14:20:04 <sjanssen> I bet there's an arrow combinator for that
14:20:29 <kpreid> TuringTest: Does there happen to be a Debian package?
14:20:40 <sjanssen> @type (+) *** (+)
14:20:42 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
14:20:57 <TuringTest> kpreid: I don't know --- but it would surprise me
14:20:58 <Jaak> > (uncurry (***) $ join (***) (+)) (1,2) (3,4)
14:20:59 <lambdabot>      Expecting a function type, but found `t_a1RH'
14:20:59 <lambdabot>       Expected type: (b, c...
14:21:07 <kpreid> (I have a very small problem, and the solution is running on Debian, so I'll use a path library if it's easy)
14:21:10 <kpreid> TuringTest: Okay, I'll just be careful with my concatenations :)
14:21:12 <Jaak> > (uncurry (***) . join (***) (+)) (1,2) (3,4)
14:21:13 <lambdabot>  (4,6)
14:22:50 <TuringTest> uncurry (***) . ((+) *** (+))
14:25:20 <shapr> chessguy_work: You called?
14:25:29 <chessguy_work> shapr, i did?
14:25:39 <chessguy_work> i don't think i even have your phone number
14:27:10 <dblhelix> @seen jeroeng
14:27:11 <lambdabot> I saw jeroeng leaving #haskell 22h 46m 23s ago, and .
14:39:39 <shapr> chessguy_work: :-P
14:41:54 <chessguy_work> shapr, are things calming down for you somewhat?
14:42:41 <syntaxfree> things weren't calm?
14:56:37 <beelsebob> HASKELL!
14:56:53 <tessier_> beelsebob: Yes?
14:57:03 <beelsebob> sorry, drunk
14:57:21 * tessier_ wonders if haskell could eventually replace python for quick scriptability
14:58:17 <allbery_b> with the appropriate libraries, certainly
14:58:45 <Vq^> beelsebob: what? what?
14:58:54 <syntaxfree> hell , i hate ajax pseudo-popups.
14:59:03 <syntaxfree> like the reddit login form. wtf is that?
14:59:08 <beelsebob> Vq^: do you know what alcohol is?
14:59:19 <Vq^> beelsebob: rings a bell
14:59:44 <beelsebob> Vq^: lots of that + beelsebob == random expletives and Haskell
15:00:11 <Vq^> beelsebob: got anything that typechecks yet? :)
15:00:46 <beelsebob> instance Num String where
15:00:46 <beelsebob>   "lots of that" + "beelsebob" = "random expletives and Haskell"
15:00:53 <beelsebob> happy?
15:01:40 <Vq^> heh
15:04:36 <sorear> tell fodder
15:04:55 <sjanssen> sorear: normal people say hello :)
15:06:12 <chessguy_work> meesa goin' home!
15:06:38 <sjanssen> chessguy_work: Boss Nass is okay with that?
15:07:08 <syntaxfree> beelsebob: you inspired me. I'm opening a bottla wine.
15:07:43 <beelsebob> syntaxfree: excellent, why not rum?
15:08:07 <syntaxfree> haha. no hard liquor here, I'm afraid.
15:08:16 <syntaxfree> I live with my parents.
15:08:32 <syntaxfree> The last two weekends I went to bars with friends. I'm all alone again, though.
15:08:42 <tibbe> is there a way to integrate haddock lookup into emacs?
15:08:55 <syntaxfree> I should get more friends. I can't keep on overtaxing my small ammount of "real" friends with all my weekend neediness.
15:09:35 <tibbe> also, i get some problems with hoogle for emacs, something to do with hasell-mode-map
15:09:49 <mbishop> syntaxfree: stop being so emo :P
15:09:54 <tibbe> haskell-mode-map even
15:09:58 <syntaxfree> haha. It's the wine, it's the wine ; )
15:14:00 <Syzygy-> syntaxfree: Did you see my response to your random gibberish post?
15:14:24 <syntaxfree> oh. you = Mikael Johanson's?
15:14:26 <Syzygy-> Oh you did.
15:14:28 <Syzygy-> :P
15:14:42 <Syzygy-> Now I see your post. And I -really- have to read your about page now"
15:14:46 <Syzygy-> *!
15:15:07 <Syzygy-> Ayup!
15:15:33 <Syzygy-> You know... Now that you've done this, I really need to build a partial tree model of english, tag an entire chapter or two of Moby Dick, and do a text generator on that.
15:16:08 <Syzygy-> Preferably a Moby Dick in Esperanto.
15:18:06 <Syzygy-> Wow! I'm juxtaposed with sigfpe. I'm VERY flattered!
15:18:14 <syntaxfree> I like quickie hacks. This didn't turn out good though.
15:18:30 <syntaxfree> I have a program that figures out what's the correct shift number for Caesar ciphers.
15:18:36 <Syzygy-> syntaxfree: This starts bordering quite a lot on modern research computational linguistics. :P
15:18:50 <Syzygy-> Ooooh. Caesar crackers are cool. Is yours doing it by freqeuuency analysis?
15:18:53 <syntaxfree> it picks the version that better matched letter frequency in Nietzsche's complete work.
15:18:57 <syntaxfree> yes, yes. It's a quickie too.
15:19:00 <Syzygy-> BWAHAHAHA!
15:19:16 <syntaxfree> it's on my old blog, which is deactivated. I'll hunt it and hpaste it. Just a min.
15:19:19 <Syzygy-> You should pick that french novel that completely avoids the letter 'e'.
15:20:27 <Syzygy-> syntaxfree: Note that on the Planet, realnames and nicks are displayed together.
15:20:54 <hpaste>  syntaxfree pasted "magic caesar cracker" at http://hpaste.org/424
15:21:34 <Syzygy-> Hmmmm... Wonder if this'll perform well for a VigenÃ¨re too...
15:22:04 <hpaste>  (anonymous) annotated "magic caesar cracker" with "(no title)" at http://hpaste.org/424#a1
15:22:15 <syntaxfree> those are some examples.
15:23:17 <syntaxfree> heh. it's amazing what a glass of wine will do for my mood.
15:23:22 <Syzygy-> :)
15:23:41 <syntaxfree> I should buy some booze one day and keep it hidden in my bedroom.
15:23:53 <nornagon> mm
15:23:56 <nornagon> likewise
15:24:00 <syntaxfree> gah, I need to get out. I'm 24 and I'm stuck at these things like a teenager.
15:24:08 <syntaxfree> Damn graduate school.
15:26:20 <Syzygy-> BWAHAHAHA!
15:26:30 <Syzygy-> *Caesar> putStrLn $ autodeRot "THIS IS A STRING"
15:26:40 <Syzygy-> (0.7492784552845528,"THIS IS A STRING")
15:26:48 <Syzygy-> (0.7492784552845528,"THIS IS A STRING")
15:26:48 <Syzygy-> (0.7500745257452573,"ESTD TD L DECTYR")
15:26:48 <Syzygy-> (0.9685196476964771,"FTUE UE M EFDUZS")
15:27:01 <Syzygy-> Wrong, sucker! :)
15:27:03 <xerox> Syzygy- is having some fun.
15:28:07 <Syzygy-> *Caesar> putStrLn $ autodeRot $ strRot 11 "ALL AARDVAARKS ARE AFTER AARON'S ALE"
15:28:13 <Syzygy-> (1.6792581300813005,"ALL AARDVAARKS ARE AFTER AARON'S ALE")
15:28:13 <Syzygy-> (1.7476964769647698,"UFF UULXPUULEM ULY UZNYL UULIH'M UFY")
15:28:13 <Syzygy-> (1.8585298102981032,"PAA PPGSKPPGZH PGT PUITG PPGDC'H PAT")
15:28:13 <Syzygy-> (2.1607757452574528,"EPP EEVHZEEVOW EVI EJXIV EEVSR'W EPI")
15:28:18 <Syzygy-> Hah!
15:28:48 * Syzygy- mixed booze of his own with a bunch of friends a couple of weeks ago. It's maturing in my room now. :P
15:29:05 <syntaxfree> Syzygy-: too short.
15:29:19 <syntaxfree> out of 20, how many wrong?
15:29:36 <Syzygy-> 2 1/2 litres of good old Swedish Punsch (http://en.wikipedia.org/wiki/Punsch)
15:29:46 <syntaxfree> xerox: he's having some fun slamming *my* Caesar cracker!
15:29:53 <Syzygy-> Oh yes!
15:30:11 <Syzygy-> But I should be fair, I'm feeding it short texts that are seriously off in their distributions.
15:30:54 <syntaxfree> it's a simple approach. not probabilistic, but probably can be framed that way.
15:31:04 <syntaxfree> fared way better than the tetragram text generator.
15:31:24 <syntaxfree> still, the tetragram text generator got a few new words.
15:31:51 <syntaxfree> coase, fort, tao, tad.
15:32:27 <augustss> hmmmm, coase?
15:32:40 <syntaxfree> yes. as in Ronald Coase, economist extraordinaire ; )
15:32:52 <Syzygy-> (17.233418021680215,"IF YOUTH, THROUGHOUT ALL HISTORY, HAD A CHAMPION TO STAND UP FOR IT; TO SHOW A DOUBTING WORLD THAT A CHILD CAN THINK; AND, POSSIBLY, DO IT PRACTICALLY; YOU WOULDN'T CONSTANTLY RUN ACROSS FOLKS TODAY WHO CLAIM THAT A CHILD DON'T KNOW ANYTHING. A CHILD'S BRAIN STARTS FUNCTIONING AT BIRTH; AND HAS, AMONGST ITS MANY INFANT CONVOLUTIONS, THOUSANDS OF DORMANT ATOMS, INTO WHICH GOD HAS PUT A MYSTIC POSSIBILITY FOR NOTICING AN ADULT'S ACT,
15:32:56 <augustss> ah
15:33:02 <syntaxfree> "ttpaeoeryemican" could be construed as someone who lives in ttpaeoeryemica.
15:33:04 <Syzygy-> (18.215928184281843,"UR KAGFT, FTDAGSTAGF MXX TUEFADK
15:33:06 <Syzygy-> (18.351812330623304,"JG ZPVUI, UISPVHIPVU BMM IJTUPSZ,
15:33:10 <Syzygy-> HAH!
15:33:21 <Syzygy-> And now you cannot whack me for giving it short samples any longer!
15:33:25 <syntaxfree> ; )
15:33:47 <Syzygy-> you could, though, probably whack me for using "Gadsby" as a source. :P
15:34:08 <sorear> Syzygy-: you realize lambdabot keeps tabs on who uses all caps? :p
15:34:09 <syntaxfree> it's really stupid. If I had written it today, I'd allow variable calibration sources.
15:34:18 <Syzygy-> sorear: Oooops.
15:34:18 <augustss> Syzygy-: Here's a thing a played with many years ago.  You take two texts and XOR them character by character.  And the your mission is to write a program that recovers both of them.
15:34:26 <syntaxfree> brb
15:34:30 <Syzygy-> augustss: Riiiiiiiight.
15:34:48 <sorear> Syzygy-: the entropy of text is very low ...
15:34:50 <augustss> Syzygy-: You can get it like 90% right with little effort
15:35:01 <Syzygy-> Hmmm... Hang on . Rght, yeah, I can see why it isn't hopeless.
15:35:12 <Syzygy-> But it's bloody icky. :P
15:35:23 <augustss> I thought it was fun. :)
15:35:25 <sorear> augustss: heh. but if your texts happen to be the SAME ...
15:35:39 <Syzygy-> BWAHAHA! :)
15:35:42 <SamB> well that is kind of hopeless ;-)
15:35:45 <augustss> sorear: well, then you're out of luck :)
15:36:22 <sorear> @users
15:36:23 <lambdabot> Maximum users seen in #haskell: 322, currently: 288 (89.4%), active: 50 (17.4%)
15:37:32 <Syzygy-> Yeah, for an excerpt from the english translation of La Disparation, the correct solution is fourth. And that's quite a large text chunk. :P
15:37:40 <Syzygy-> Won't keep on spamming the channel though.
15:38:48 <syntaxfree> back.
15:39:04 <Syzygy-> syntaxfree: I have yet to see your cracker work reliably a single time!
15:39:18 <syntaxfree> it works for every sentence I randomly think of!
15:39:29 <syntaxfree> "Nevertheless it is clear that such persons as the writer of these notes not only may, but positively must, exist in our society, when we consider the circumstances in the midst of which our society is formed. "
15:39:37 <syntaxfree> try that. I just picked it from the ebook I'm reading.
15:39:42 <syntaxfree> I didn't even test it.
15:40:01 <bos31337> @hoogle ([[a]], [[b]]) -> [([a], [b])]
15:40:02 <lambdabot> No matches, try a more general search
15:40:21 <syntaxfree> I sometimes wish Haskell would support Squiggol syntax.
15:41:45 <sorear> bos: state the nature of your problem ...
15:42:10 <sorear> (const []) world work, BUT ...
15:42:27 <sorear> somehow I doubt you could use that
15:42:29 <Jaak> @type uncurry zip
15:42:31 <_Stinger_> @hoogle (a -> b -> c) -> (a,b) -> c
15:42:31 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
15:42:31 <Syzygy-> syntaxfree: It didn't work for any of my previous examples, nor for "Noon rings out. A wasp, making an ominous sound, a sound akin to a klaxon or a tocsin, flits about. Augustus, who has had a bad night, sits up blinking and purblind. Oh what was that word (is his thought) that ran through my brain all night, that idiotic word that, hard as I'd try to pun it down, was always just an inch or two out of my grasp - fowl or foul or Vow or Voyal?..."
15:42:33 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
15:42:50 * sorear read Augustss
15:43:15 <_Stinger_> @type uncurry . zip
15:43:15 <Syzygy-> > uncurry zip ([[1,2],[3],[4,5,6]],[[2,3],[1],[],[4,5,6,7,8],[]])
15:43:16 <xerox> ?type unzip
15:43:17 <lambdabot>     Couldn't match `b -> c' against `[(a, b1)]'
15:43:17 <lambdabot>       Expected type: [a] -> [b1] -> b -> c
15:43:18 <lambdabot>  [([1,2],[2,3]),([3],[1]),([4,5,6],[])]
15:43:18 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
15:43:35 <Syzygy-> > (uncurry zip) ([[1,2],[3],[4,5,6]],[[2,3],[1],[],[4,5,6,7,8],[]])
15:43:36 <lambdabot>  [([1,2],[2,3]),([3],[1]),([4,5,6],[])]
15:43:38 <_Stinger_> er
15:43:54 <augustss> sorear: huh?
15:44:29 <xerox> > transpose [[[1,2],[3],[4,5,6]],[[2,3],[1],[],[4,5,6,7,8],[]]]
15:44:30 <lambdabot>  [[[1,2],[2,3]],[[3],[1]],[[4,5,6],[]],[[4,5,6,7,8]],[[]]]
15:45:03 <nornagon> ?src transpose
15:45:04 <lambdabot> transpose []             = []
15:45:04 <lambdabot> transpose ([]   : xss)   = transpose xss
15:45:04 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:45:27 <nornagon> transpose [[1],[]]
15:45:29 <sorear> augustss: ouch . case insensitive pinger?  anyway, someone mentioned August*u*s
15:45:34 <nornagon> > transpose [[1],[]]
15:45:36 <lambdabot>  [[1]]
15:45:42 <nornagon> > transpose [[1],[1,2]]
15:45:44 <lambdabot>  [[1,1],[2]]
15:45:48 <augustss> oh :)
15:46:19 <augustss> > transpose [[]]
15:46:19 <lambdabot>  Add a type signature
15:46:38 <augustss> > transpose [[]] :: [[()]]
15:46:39 <lambdabot>  []
15:47:51 <astrolabe> #join ubuntu
15:47:59 <nornagon> :O
15:48:09 <astrolabe> oops :)
15:48:46 <sorear> the command is @join, btw
15:48:54 <sorear> @join #ubuntu
15:49:00 <sorear> @part #ubuntu
15:49:57 <sorear> well, I suppose it helps if lambdabot is in <10 channels :)
15:50:17 <augustss> > join ubuntu
15:50:18 <lambdabot>   Not in scope: `ubuntu'
15:50:56 <astrolabe> @type join
15:50:57 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:51:04 <mr_tenor> heh
15:51:14 <astrolabe> So ubuntu :: m (m a) ?
15:51:15 <augustss> > join (*) 5
15:51:16 <lambdabot>  25
15:51:33 <sorear> > join (***) negate (4,5)
15:51:35 <lambdabot>  (-4,-5)
15:52:41 <Axioplase> ?type  join (*)
15:52:42 <lambdabot> forall a. (Num a) => a -> a
15:53:58 <augustss> @djinn (e->-e->a) -> (e->a)
15:53:59 <lambdabot> Cannot parse command
15:54:10 <Axioplase> I don't get this.. (*) is not of type m (m a) !
15:54:18 <syntaxfree> Syzygy: bah, it worked with everything I had tried so far.
15:54:21 <augustss> @djinn (e->e->a) -> (e->a)
15:54:22 <lambdabot> f a b = a b b
15:54:25 <sorear> Axioplase: yes it is!
15:54:29 <olliej> ?type join (\a b -> join + a b)
15:54:31 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> m (m a) -> m a
15:54:31 <lambdabot>       Expected type: t
15:54:36 <augustss> Axioplase: if m is e-> it is
15:54:44 <Axioplase> haaa...
15:54:51 <olliej> ?type join (\a b -> join (+) a b)
15:54:53 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> a
15:54:53 <lambdabot>       Expected type: t
15:55:05 <olliej> bah
15:55:17 <Axioplase> I got it :)
15:59:16 <augustss> the reader monad strikes again
16:00:20 <Axioplase> quite funny : "(\axioplase->night) inHisBed" evaluates to night where Axioplase is inHisBed
16:09:10 <emu> you know whats getting kinda annoying? not being able to use capital letters as variable names
16:09:30 <emu> can you use unicode perhaps? greek letters?
16:09:34 <sorear> heh
16:09:37 <steven_ashley> :P
16:09:37 <sorear> I believe so
16:09:56 <sorear> how about doubled letters? "cc, yy, dd" ?
16:09:57 <sorear> :)
16:10:08 <sorear> or just ... meaningful names!
16:10:10 <emu> i mean, if one is familiar with the literate, talking about an alphabet \Sigma and individual letter \sigma is natural
16:10:11 <sorear> :p
16:10:18 <emu> literature*
16:10:39 <emu> now I could use S and s, but i can't use S, so um
16:10:49 <mr_tenor> variable names in laTeX?
16:10:50 <nornagon> > let Î± = "alpha" in Î± ++ "foo"
16:10:51 <lambdabot>  Illegal character ''\177''
16:10:54 <emu> unicode
16:10:56 <syntaxfree> emu: you can always use hungarian notation.
16:11:04 <sorear> nornagon: LB doesn't do unicode (still)
16:11:08 <nornagon> :(
16:11:08 <mr_tenor> pattern matching and indentation are the enemies of meaningful variable names :(
16:11:09 <emu> my code is rapidly expanding from using descriptive names
16:11:24 <sorear> \177 is a UTF8 prefix byte, interpreted rawwise.
16:11:24 <nornagon> Prelude> let Î± = "alpha" in Î± ++ "foo"
16:11:24 <nornagon> <interactive>:1:7: parse error on input `='
16:11:34 <Philippa> I'm a lot terser with pattern variables than other identifiers
16:11:34 <emu> and the greek letters are more than sufficiently descriptive, again, to anyone who's read the literature
16:11:39 <syntaxfree> what encoding should i set my irc channel to to see thea lphas?
16:11:45 <sorear> UTF8?
16:11:45 <nornagon> syntaxfree: utf8
16:11:48 <emu> so ghc can handle utf8?
16:11:55 <sorear> emu: >6.6 -> yes
16:11:58 <sorear> >= maybe
16:12:01 <emu> hmm
16:12:03 <syntaxfree> oh great.
16:12:09 <syntaxfree> somehow, it was iso-latin1.
16:12:15 <syntaxfree> â«Ã
16:12:22 <syntaxfree> that came out right?
16:12:23 <sorear> syntaxfree: beats cp232 anyday. :)
16:12:33 <nornagon> I saw box-beta
16:12:34 <sorear> <syntaxfree> â«
16:12:45 <Jaak> seems fine
16:12:48 <syntaxfree> hey. where's the german-beta?
16:12:48 <Jaak> ?ß
16:12:49 <lambdabot> Maybe you meant: . v
16:12:57 <Jaak> tho' mine is not :\
16:13:00 <syntaxfree> > elite Ã
16:13:01 <lambdabot>  Illegal character ''\159''
16:13:09 <sorear> syntaxfree: you mean sharp s?
16:13:15 <syntaxfree> that, too : )
16:13:22 <sorear> syntaxfree: I just hit 's' twice :)
16:13:31 <syntaxfree> Ã
16:13:41 <nornagon> Ã
16:13:52 <syntaxfree> I like postixing certain words with â¢
16:13:53 <nornagon> Compose-s-s
16:15:44 <chessguy> hi haskellers
16:15:59 <JernejL> quick haskell question: for which platforms are haskell compilers availible?
16:16:16 <chessguy> JernejL, pretty much any
16:16:17 <allbery_b> sad, my font doesn't distinguish between beta and es-zet
16:16:21 <syntaxfree> http://www.haskell.org
16:16:23 <lambdabot> Title: Haskell - HaskellWiki
16:16:40 <syntaxfree> click on "Implementations"
16:17:00 <JernejL> thanks
16:17:18 <syntaxfree> â
16:17:20 <sorear> how bizzare is the platform you are thinking of?
16:17:25 <emu> oh no, it treats capital greek letters like type names too :(
16:17:40 <sorear> :)
16:17:44 <syntaxfree> emu: hahahaha
16:17:53 <JernejL> <sorear> how bizzare is the platform you are thinking of? <- anything that runs opengl.
16:18:05 <syntaxfree> ?
16:18:23 <sorear> JernejL: no, haskell doesn't support running on graphics cards yet. :(
16:18:35 <steven_ashley> emu: why not just use lowercase :P?
16:18:38 <emu> and they call this language "mathematically inspired!"
16:18:41 <sorear> (although there is a thesis-project to make it work - see DpH)
16:18:43 <JernejL> oh i meant any platform for which i can use it with opengl
16:18:55 <emu> steven_ashley: because \Sigma and \sigma have different meanings (namely, \sigma \in \Sigma)
16:19:22 <syntaxfree> emu: if you're going as far as that, guards are wrong too.
16:19:31 <syntaxfree> should be f x = |  ... cases here
16:19:33 <emu> yes yes, i know how miranda does it
16:19:38 <syntaxfree> not f x | = cases here..
16:19:59 <emu> blah, i always thought camelCase was a mistake :(
16:20:22 <emk> Are there any papers with good performance numbers for map fusion?
16:20:55 <emk> Something based on GHC's rewrite rules would be most useful.
16:21:12 <sjanssen> emu: what if Greek programmers want to write Haskell in their native language?
16:21:56 <sjanssen> emk: "Rewriting Haskell Strings" has some performance numbers for a different fusion system
16:21:57 <emu> well i think you should be able to name variables with upper or lower case regardless of language :P
16:22:00 <Philippa> JernejL: windows, multiple flavours of *nix...
16:22:17 <sjanssen> emu: and how do we denote type variables?
16:22:19 <emu> i don't have a good solution for the lexing problem
16:22:27 <Philippa> I'd rather the case convention than marking things out with a prefix or postfix
16:22:33 <steven_ashley> me also
16:22:34 <emk> sjanssen: Thanks!
16:22:35 <emu> though SML does 'a
16:22:39 <syntaxfree> the case convention makes for pretty-looking code.
16:23:01 <Philippa> and it's neatly parallel to the way capitals're used in english
16:23:02 <syntaxfree> it is painfully clear when constructors are being hidden in an abstract data type though.
16:23:09 <syntaxfree> Philippa: is it?
16:23:10 <emu> well i'm arguing it's ruining the pretty-ness of my code by making me use longer unconventional names
16:23:12 <emk> I'm working on a map fusion tutorial, and I'm too lazy to run accurate benchmarks myself. ;-)
16:23:19 <steven_ashley> emu: whats wrong with something like ... \letter \in \alphabet ?
16:23:48 <Philippa> syntaxfree: it's the specific name of something concrete, rather than one of a class of things
16:23:52 <sjanssen> emk: only map fusion?  Or are you going to cover more general cases like foldr/build?
16:24:02 <emu> steven_ashley: it gets unreadable when it's part of a larger expression
16:24:03 <syntaxfree> that Makes Sense.
16:24:24 <emk> sjanssen: A treeMap and a treeFoldr function. I'm skipping build for the moment...
16:24:26 <Philippa> syntaxfree: Good Thing, no? :-)
16:24:35 <syntaxfree> hahaha.
16:24:40 <syntaxfree> I might have had a cup of wine too many.
16:24:42 <emk> It's just a short tutorial to whet people's appetite.
16:27:33 <hpaste>  JoshTriplett pasted "Compilation error when using Control.Monad.RWS" at http://hpaste.org/425
16:27:50 <JoshTriplett> When I attempt to use Control.Monad.RWS, I get the error I just pasted.
16:27:58 <sorear> JoshTriplett: --make
16:28:00 <sjanssen> JoshTriplett: add -package mtl when compiling
16:28:12 <sorear> JoshTriplett: add --make or -package mtl
16:28:36 <sjanssen> I always use --make, it's just more convenient
16:28:40 <JoshTriplett> Thanks.
16:28:48 <sorear> JoshTriplett: those are undefined symbol errors, you need to add the appropriate libs or tell ghc to do it automatically
16:29:24 <JoshTriplett> sorear: I figured I needed some haskell library-equivalent, I just didn't know what. :)
16:29:35 <sorear> hehe.
16:29:56 <dobblego> how do you exit from main with an error code?
16:30:05 <sjanssen> @hoogle exit
16:30:06 <lambdabot> System.Exit :: module
16:30:07 <lambdabot> System.exitFailure :: IO a
16:30:07 <lambdabot> System.exitWith :: ExitCode -> IO a
16:30:10 <dobblego> ta
16:30:24 <sjanssen> @type System.IO.exitWith
16:30:26 <lambdabot> Not in scope: `System.IO.exitWith'
16:30:59 <sorear> @ty System.Exit.exitWith
16:31:01 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
16:31:05 <sorear> @ty System.Exit.ExitCode
16:31:07 <lambdabot> Not in scope: data constructor `System.Exit.ExitCode'
16:31:10 <sorear> @ty System.Exit.ExitNum
16:31:12 <lambdabot> Not in scope: data constructor `System.Exit.ExitNum'
16:31:17 <sorear> @src System.Exit.ExitCode
16:31:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:31:22 <sorear> @hoogle Int -> System.Exit.ExitCode
16:31:24 <lambdabot> No matches, try a more general search
16:31:31 <sorear> @src ExitCode
16:31:31 <lambdabot> data ExitCode = ExitSuccess | ExitFailure Int
16:32:18 <emu> maybe i should just do things like _S
16:33:40 <sorear> beware!  that is subject to change in haskell'
16:34:02 <sorear> (haskell' might make _ caseless, so _S is a type while _s is a data)
16:34:28 <steven_ashley> emu: Perhaps something like \sSigma \in \aSigma where s is for symbol and a is for alphabet?
16:35:02 <emu> erp
16:35:32 <steven_ashley> sorear: is it considered okay to use _ to remove the not used warnings?
16:36:02 <sorear> steven_ashley: that's what it's there for
16:36:08 <sorear> iirc
16:36:14 <steven_ashley> :) ok
16:37:32 <xic> how do i collapse all adjacent spaces into a single space in a string? "1  2    34 5" -> "1 2 34 5"
16:38:27 <steven_ashley> xic: map head $ group $ "1  2    34 5"
16:38:32 <sorear> I use it!
16:38:32 <sorear> @bot
16:38:32 * sorear grumbles at his internet connection
16:38:33 <sorear> unwords . words
16:38:33 <lambdabot> :)
16:39:03 <sorear> > map head $ group "11  2"
16:39:05 <lambdabot>  "1 2"
16:39:12 <steven_ashley> ahh yeah
16:39:12 <sorear> > unwords $ words "11  2"
16:39:13 <steven_ashley> you win ;)
16:39:14 <lambdabot>  "11 2"
16:41:01 <xic> actually i need to collapse '_' chars, so unwords . words won't work :(
16:41:50 <LoganCapaldo> let  = _ in unwords . words "1    2 3" of course! ;)
16:41:58 <LoganCapaldo> err
16:42:08 <LoganCapaldo> let  = _ in unwords . words "1__2_3" of course! ;)
16:42:17 <LoganCapaldo> Its not funny when I mess it up
16:42:35 <LoganCapaldo> (probably isn't funny even if I don't mess it up)
16:43:18 <bd_> xic: collapse?
16:43:20 <glguy> > concat $ map (\x -> if head x == '_' then "_" else x) $ group $ "this____is_a___test"
16:43:21 <lambdabot>  "this_is_a_test"
16:44:18 <sorear> dons: I can't pull from any of your repos
16:44:36 <sorear> (CSE seems down)
16:45:08 <allbery_b> > concat $ map (\x -> if head x == '_' then "_" else x) $ group $ "this____is_a___testttt"
16:45:10 <lambdabot>  "this_is_a_testttt"
16:45:30 <allbery_b> hm, right :)
16:45:47 <steven_ashley> > let myFunc c = c == '_' || isSpace c in map head $ groupBy (\a b -> myFunc a && myFunc b) $ "1  2 _  __ 34 _5"
16:45:49 <lambdabot>  "1 2 34 5"
16:45:54 <steven_ashley> **shrug**
16:46:02 <allbery_b> > foldl (\a c -> if null a || last a /= '_' || c /= '_' then a ++ [c] else a) "" "11 2     34 5 55 5 555 89  "
16:46:04 <lambdabot>  "11 2     34 5 55 5 555 89  "
16:46:07 <allbery_b> oops
16:46:20 <sorear> steven_ashley: groupBy maybe?
16:46:29 <allbery_b> > foldl (\a c -> if null a || last a /= '_' || c /= '_' then a ++ [c] else a) "" "11_2__ _ 34_5 55_5 555_89__"
16:46:31 <lambdabot>  "11_2_ _ 34_5 55_5 555_89_"
16:46:48 <steven_ashley> sorear: i used groupBy ;)
16:47:53 <LoganCapaldo> @hoogle Regex
16:47:54 <lambdabot> Text.Regex :: module
16:47:54 <lambdabot> Text.Regex.Regex :: data Regex
16:47:54 <lambdabot> Text.Regex.Posix.regExtended :: Int
16:53:40 <steven_ashley> >map head $ groupBy (\a b -> a == '_' && b == '_') $ map head $ groupBy (\a b -> isSpace a && isSpace b) "11_2_ _ 34_5 55_5 555_89_"
16:53:58 <allbery_b> need a space after the ">"
16:54:02 <steven_ashley> > map head $ groupBy (\a b -> a == '_' && b == '_') $ map head $ groupBy (\a b -> isSpace a && isSpace b) "11_2_ _ 34_5 55_5 555_89_"
16:54:04 <lambdabot>  "11_2_ _ 34_5 55_5 555_89_"
16:54:09 <steven_ashley> got it in the end ;)
16:55:50 <allbery_b> > let squash p s = map head $ groupBy (\a b -> p a && p b) s in squash (== '_') $ squash isSpace "11_2_ _ 34_5 55_5    555_89_"
16:55:52 <lambdabot>  "11_2_ _ 34_5 55_5 555_89_"
16:57:08 <steven_ashley> nicely done :) I was getting there ;)
17:07:17 <emu> unknown or unimplemented opcode 23020
17:07:39 <cpfr> howdy, I have a minor question that can be interpreted as flamebait
17:08:00 <emu> i have code that can't be interpreted
17:08:17 <cpfr> would you implement a loop that does an action n times
17:08:20 <sorear> emu: !paste it
17:08:27 <Cale> cpfr: with replicateM
17:08:33 <Cale> @type replicateM
17:08:34 <dobblego> cpfr, would I or how would I?
17:08:34 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
17:08:37 <sorear> cpfr: (foldr (.) id action) value
17:08:52 <Cale> I'm assuming you're talking about a monadic action?
17:08:53 <sorear> cpfr: (foldr (.) id (replicate n action)) value rather :)
17:09:23 <Cale> er, if it's a pure function you want to apply to a value n times, then  iterate f x !! n
17:09:45 <Cale> > iterate (*2) 1
17:09:47 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
17:09:49 <allbery_b> like perl, there's more than one way to do it.  unlike perl, most of them don't suck.  :)
17:10:12 <Cale> > iterate (*2) 1 !! 10
17:10:13 <cpfr> ok
17:10:14 <lambdabot>  1024
17:10:18 <emu> it's quite long
17:10:41 <cpfr> excellent
17:10:52 <Cale> But for monadic actions, replicateM is the usual way, or if you need to know which iteration you're on, mapM.
17:11:04 <cpfr> excellent
17:11:28 <Cale> There's also forM, which is just mapM with parameters flipped, so the list is first.
17:12:09 <Cale> and sequence, which takes a list of actions and gives an action which executes each in turn.
17:12:21 <Cale> (collecting a list of results)
17:12:29 <chessguy> ?type sequence
17:12:31 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
17:12:40 <cpfr> mmm
17:13:24 <steven_ashley> > mapM_ (putStr . show) [1..9]
17:13:25 <lambdabot>  <IO ()>
17:13:30 <steven_ashley> awwh :(
17:13:55 <chessguy> > gets 3
17:13:55 <lambdabot>   add an instance declaration for (Show (m a))
17:13:59 * LoganCapaldo imagines sequence :: (Monad m, MonadPlus n) => n (m a) -> m (n a)
17:14:34 <ddarius> @src sequence
17:14:35 <lambdabot> sequence ms = foldr k (return []) ms
17:14:35 <lambdabot>     where
17:14:35 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
17:14:43 <LoganCapaldo> Hmm
17:14:49 <sorear> LoganCapaldo: it's called traverse
17:15:01 <Cale> sequence = foldr (liftM2 (:)) (return [])
17:15:02 <LoganCapaldo> I'm suspecting that my understanding of MonadPlus might be flawed
17:15:15 <cpfr> i was doing some coding in C recently where I muttered, this would be a lot easier if i could see the type signature of this function
17:15:19 <LoganCapaldo> @type traverse
17:15:21 <lambdabot> Not in scope: `traverse'
17:15:38 <sorear> LoganCapaldo: er, no, it's called sequence but in a diff module
17:15:40 <Cale> @type Data.Traversable.traverse
17:15:42 <lambdabot> Couldn't find qualified module.
17:15:47 <allbery_b> I think Data.Traversable is 6.6
17:15:48 <Cale> oh, bah
17:15:51 <Cale> yes it is
17:15:52 <sorear> Prelude> :t Data.Traversable.sequence
17:15:52 <sorear> Data.Traversable.sequence :: (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
17:15:58 <Cale> and the bot isn't using that yet
17:16:40 <Cale> Haskell has more interesting classifications of functor than I'm used to seeing :)
17:17:22 <ddarius> Cale: Used to from where?
17:17:36 <Cale> It seems that the functional programming perspective brings out distinctions that you don't normally worry about in pure mathematics. Usually because you're more interested in specific functors.
17:17:43 <LoganCapaldo> ddarius: I think from math
17:17:57 <sorear> Prelude Data.Traversable> :t sequenceA
17:17:57 <sorear> sequenceA :: (Traversable t, Control.Applicative.Applicative f) => t (f a) -> f (t a)
17:18:02 <sorear> ^^^ much better!
17:18:02 <LoganCapaldo> I suspect Cale is one of those "mathematician" type people
17:18:11 <Cale> Oh, that's very much the case :)
17:18:43 <ddarius> There is a ridiculous variety of classifications for functors in math, including the ones Haskell has.
17:18:51 <LoganCapaldo> He just hangs out in here to complain about things like Monad having fail and what not ;)
17:18:58 <Cale> LoganCapaldo: hehe
17:19:09 <ddarius> I do that all the time.  I did that just yesterday.
17:19:47 <chessguy> ?remember LoganCapaldo I suspect Cale is one of those "mathematician" type people
17:19:48 <lambdabot> Done.
17:19:53 <Cale> ddarius: Yeah, but I'm not used to worrying about them. Have you put them to use in, say, analysis, or even algebraic topology?
17:20:08 <orbitz> Cale: interesting post on STM btw
17:20:12 * LoganCapaldo thinks about doing some more DE problems
17:20:15 <Cale> orbitz: which one? :)
17:20:30 <LoganCapaldo> There now I've established my math level! You can all point and laugh ;)
17:20:49 <Cale> LoganCapaldo: you're farther ahead in DE's than I am, I suspect.
17:21:19 <Cale> I've only solved one nontrivial DE, on my own, and never taken a single course on them.
17:21:24 <cpfr> LoganCapaldo, you should have said Algebra
17:21:29 <LoganCapaldo> Cale: You might be correct in that case ;)
17:21:30 <cpfr> thats ambigious
17:21:30 <orbitz> Cale: on ltu, long one
17:21:33 <ddarius> LoganCapaldo: The interconnections of mathematics form a true DCG.  There is very interesting work in with differential equations.
17:21:36 <Cale> orbitz: ah :)
17:22:25 <Cale> Specifically, I was interested in finding all solutions to d^n f/dx^n = f, which was not all that hard, but it's a nice class of functions.
17:22:34 <LoganCapaldo> Despite the fact that I'm a CS major, the point of the DE class is to prepare us to build bridges and machines so :)
17:22:43 <emu> what is with all the bad blood towards STM
17:22:47 <LoganCapaldo> I have no idea what ddarius is talking about :)
17:23:03 <LoganCapaldo> I can do something with bacteria in a petri dish though!
17:23:11 <cod3po37> would someone happen to know of a definitive solution to the OS X/X11 PPC "can't load .so/.DLL" problem? I searched the internets and I found one long discussion but no particular resolution.
17:23:47 <ddarius> Cale: Yes it is. Albeit very simple once you get (at least) the n=2 case, even at the n=1 case the rest follows with just a little thinking out of the box (for someone new to math).
17:24:01 <orbitz> Cale: one question i have abotu STM though if you ahv ea minute.  The ERlang style saves you from having to do anythign special to be sure your data won't mishmash, but in seems in STM you hav eot eb careful to wrap the transaction in some sort of atomic block.  is this the case?
17:24:42 <JoshTriplett> What do I want to use if I want to simulate a list of instructions with jumps between them?  How do I execute a "jump"?  Should I just use a random-access data structure and a program counter?
17:24:42 <sorear> Cale: oh, that one was fun
17:25:05 <sorear> JoshTriplett: generate a cyclic data structure
17:25:16 <LoganCapaldo> JoshTriplett: You should check out the latest issue of the monad reader is what you should do
17:25:22 <emu> orbitz: the type system enforces that
17:25:23 <JoshTriplett> LoganCapaldo: I just read that, actually. :)
17:25:28 <orbitz> emu: how so?
17:25:32 <emu> the STM monad
17:25:37 <JoshTriplett> LoganCapaldo: So now I know how to assemble such a list of instructions quite easily. :)
17:25:42 <Cale> orbitz: the atomic blocks are essentially the transactions themselves
17:25:46 <JoshTriplett> LoganCapaldo: But I want to know how to execute such a list.
17:25:47 <sorear> JoshTriplett: data Insn = IncA Insn {- next -} | DecA {- next -} Insn {- if zero -} Insn
17:25:47 <orbitz> emu: so you are speaking specifically to haskell or to STM in genera?
17:25:50 <allbery_b> orbitz: I think you don't have to "vbe careful", the type system forces you to do it.  atomically is in effect runSTM
17:25:52 <emu> oh, haskell
17:25:57 <Cale> orbitz: you have to wrap things into atomic blocks if you want them to be transactions at all.
17:26:00 <sorear> JoshTriplett: that work for you?
17:26:12 <emu> perhaps i find STM so nice because I haven't used it in other languages where it is not so rosy
17:26:38 <Cale> Other languages will require careful thinking about their design in order to support STM properly.
17:26:43 <JoshTriplett> sorear: It might, as soon as I understand the semantic it implies.
17:26:48 <orbitz> are any of the argumens int eh LtU discussion valid?
17:26:49 <Cale> They will need separation of effects at the type level.
17:26:57 <JoshTriplett> sorear: How does that help me implement a jump?
17:26:59 <orbitz> i ha veonly really used erlang for wha ti consider acceptable concurrency
17:27:15 <xic> Cale: do you think STM could ever work in a "dynamic" language, like python?
17:27:31 <emu> values in the STM monad represent actions taken within the transaction. it gets pretty cool when you can compose and retry them as first-class values.
17:27:34 <LoganCapaldo> STM has had a terrible effect on my brain. I'm finding I want transactions everywhere now.
17:27:36 <sorear> JoshTriplett: explicit jumps are like explicit pointers.  use Haskell's branching tree support instead, if you can.
17:27:39 <Cale> xic: yes, but you would still need a certain amount of typechecking
17:27:50 <Cale> xic: at least when transactions are formed
17:27:58 <dgoldsmith> cod3po37: does this happen with code compiled with ghc, or only with ghci?
17:28:22 <JoshTriplett> sorear: So, in other words, I don't want [Instruction], I want a graph of instructions?
17:28:26 <cod3po37> @dgoldsmith: I haven't tried ghc yet. let me try.
17:28:26 <lambdabot> Unknown command, try @list
17:28:32 <sorear> JoshTriplett: exactly.
17:28:33 <Cale> orbitz: Which arguments? I had trouble finding really coherent arguments against STM there -- just claims that STM was evil :)
17:28:39 <chessguy> > groupBy (\x -> True) "some text"
17:28:40 <lambdabot>      Expecting a function type, but found `Bool'
17:28:41 <lambdabot>       Expected type: a -> Bo...
17:28:43 <JoshTriplett> sorear: And Jump just has a reference to the instruction(s) it targets?
17:28:47 <chessguy> ?type groupBy
17:28:47 <cod3po37> dgoldsmith: I haven't tried...let me do so.
17:28:49 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:28:52 <emu> do msg <- atomically (readTChan ch1 `orElse` readTChan ch2); -- wait for message from either ch1 or ch2
17:28:54 <sorear> `par` forever!
17:28:56 <sorear> bbl
17:29:03 <chessguy> > groupBy (\x y -> True) "some text"
17:29:05 <lambdabot>  ["some text"]
17:29:53 <Cale> orbitz: People were claiming that it's too far away from the machine
17:30:40 <newsham> ?let withWords f = unwords.f.words
17:30:41 <lambdabot> Defined.
17:30:48 <Cale> orbitz: While that's potentially an argument, that's also the argument people used to complain about garbage collection, object oriented programming, and pretty much every other abstraction people use on a regular basis these days.
17:30:52 <newsham> ?let eachWord f = withWords (map f)
17:30:53 <lambdabot> Defined.
17:31:00 <newsham> > eachWord reverse "testing this out"
17:31:02 <lambdabot>  "gnitset siht tuo"
17:31:27 <Cale> In fact, I take the distance from implementation as a good thing. It leaves room for transparent improvement of the implementation.
17:31:37 <LoganCapaldo> > reverse `eachWord` "testing this out"
17:31:38 <lambdabot>  "gnitset siht tuo"
17:31:51 <newsham> ooh, nice readability
17:32:13 <xic> Cale: the big problem i see with STM is it's lack of IO support
17:32:15 <LoganCapaldo> You did it not me ;)
17:32:19 <newsham> > let cap (x:xs) = toUpper x : xs in (cap.reverse) `eachWord` "testing this out"
17:32:21 <lambdabot>  "Gnitset Siht Tuo"
17:32:34 <Cale> xic: well, it's not like you can't have threads which do IO
17:32:44 <Cale> xic: It's just that you can't have transactions which do IO.
17:33:02 <chessguy> ?type L.withWords
17:33:03 <lambdabot> Couldn't find qualified module.
17:33:04 <Cale> It doesn't make a whole lot of sense for transactions to do IO, 99% of the time.
17:33:08 <chessguy> ?type withWords
17:33:09 <lambdabot> Not in scope: `withWords'
17:33:31 <xic> Cale: i'd like to be able to have TVars do internal caching, via unsafePeformIO
17:33:39 <Cale> There's only a tiny fraction of IO which it's actually safe to do inside a transaction. Specifically, only IO which reads from context but has no visible side effects.
17:33:43 <newsham> > reverse `withWords` "testing this out"
17:33:44 <lambdabot>  "out this testing"
17:33:54 <Cale> There's unsafeIOtoSTM, I think.
17:34:14 <Cale> And that's well and good if you're extending STM, but not good if you don't know what you're doing :)
17:34:23 <Cale> (and not good on a regular basis)
17:34:29 <xic> Cale: hm.... unsafeIOtoSTM....
17:34:33 <xic> @hoogle unsafeIOtoSTM
17:34:33 <cod3po37> dgoldsmith: yes, it only happens in ghci. I was able to compile the simple HGL program using ghc --make and have it run.
17:34:34 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
17:34:53 <xic> Cale: cool thanks that might work!
17:34:55 <LoganCapaldo> > let inWords = withWords in reverse `inWords` "testing this out"
17:34:56 <lambdabot>  "out this testing"
17:35:02 <LoganCapaldo> mmm
17:35:27 <newsham> ?check \s -> withWords reverse (eachWord s) == reverse s
17:35:29 <lambdabot>      Expecting a function type, but found `[Char]'       Expected type: Strin...
17:35:31 <dgoldsmith> cod3po37: yes, it's a known problem, though I wasn't able to find it in Trac. Do you want to report it?
17:35:45 <xic> Cale: but where are the docs that explain when it's safe to use unsafeIOtoSTM?
17:35:46 <Cale> xic: you could use it to implement transactions which time out after a given amount of clock time, and throw an exception rather than retrying.
17:35:49 <newsham> ?check \s -> withWords reverse (eachWord reverse s) == reverse s
17:35:49 <dgoldsmith> cod3po37: it happens on Mac OS X Intel, too.
17:35:51 <lambdabot>  OK, passed 500 tests.
17:36:14 <Cale> xic: It ought to be safe if you don't mind the IO happening every single time that the transaction retries.
17:36:17 <LoganCapaldo> well it must be true!
17:36:18 <LoganCapaldo> :)
17:36:26 <cod3po37> dgoldsmith: I can report it. I'm not sure how or where...this is my first time which makes it all the more exciting ;)
17:36:29 <Cale> Obviously, it can't roll-back the effects of the IO.
17:36:32 <chessguy> @pl withWords reverse (eachWord reverse s)
17:36:33 <lambdabot> withWords reverse (eachWord reverse s)
17:36:49 <Cale> also, if the transaction throws an exception after the IO's occured, the IO will still happen.
17:36:49 <chessguy> @pl f s = withWords reverse (eachWord reverse s)
17:36:50 <lambdabot> f = withWords reverse . eachWord reverse
17:36:51 <LoganCapaldo> Well rolling back IO effects needs OS support
17:36:56 <newsham> ?pl  \s -> withWords reverse (eachWord reverse s)
17:36:56 <lambdabot> withWords reverse . eachWord reverse
17:36:58 <xic> Cale: will the IO action always be run to completion at least, or may it be aborted in the middle?>
17:36:58 <LoganCapaldo> and possibly a time machine :)
17:37:02 <Cale> LoganCapaldo: maybe more than that :)
17:37:05 <Cale> yes
17:37:24 <dons> dcoutts: re. -ddump-simpl, a quick hack:  ghc -ddump-simpl | HsColour -tty | less -r
17:37:29 <Cale> xic: I don't think it could be.
17:37:31 <dons> :) (pretty core on my brain)
17:37:38 <LoganCapaldo> Still I think a file system that support transactions would be fun if nothing else
17:37:46 <LoganCapaldo> s/support/supported/
17:38:01 <xic> Cale: what if the IO action throws an exception?
17:38:02 <Cale> xic: Then again, it makes a good point about the unsafety. :)
17:38:17 <Cale> xic: I don't know if that works, but it probably does.
17:38:29 <xic> Cale: am i allowed to run atomically inside of the IO action?
17:38:47 <newsham> ?type atomically
17:38:47 <Cale> xic: I don't think so. I seem to recall people saying that was broken.
17:38:49 <lambdabot> Not in scope: `atomically'
17:39:02 <Cale> @type Control.Concurrent.STM.atomically
17:39:04 <lambdabot> forall a. GHC.Conc.STM a -> IO a
17:39:14 <sjanssen> dons: did you catch my note about writing a WM in Haskell?
17:39:20 <dons> nope?
17:39:24 <Cale> newsham: atomically runs a transaction as-if-atomically.
17:39:34 <sjanssen> yeah, I've started cloning dwm
17:39:40 <dons> great!
17:39:41 <dons> url?
17:39:43 <Cale> xic: Basically, I'd try to be as conservative as possible with what IO I did in an STM transaction.
17:39:47 <dons> devbot6 eh?
17:39:50 <Cale> What are you planning to do?
17:40:04 <Cale> "internal caching"?
17:40:10 <xic> Cale: if my IO action is the last action in the transaction, does it mean that if the action runs then the transaction has succesfully completed?
17:40:20 <Cale> xic: no
17:40:22 <sjanssen> dons: not up yet -- maybe in 24 hours
17:40:27 <dons> cool.
17:40:29 <dons> good work!
17:40:42 <dons> Just needs someone to lead and coordinate the project
17:40:47 <dons> so if you can do that, we might get somewhere
17:40:53 <Cale> xic: because it could be that another transaction has committed in the meantime, writing the readset of your transaction.
17:41:04 <sjanssen> so far it can: launch xterms, tell windows to display full screen, and cycle through windows
17:41:10 <Cale> xic: which makes your transaction that's been running optimistically fail, and retry.
17:41:10 <newsham> cale: *nod* atomic transaction with rollback/retry
17:41:39 <Cale> xic: so basically, you really need to be sure that you don't care how many times the IO gets run.
17:41:46 <LoganCapaldo> which means your IO action could run n times
17:42:20 <Cale> If the IO computes a pure function, or only reads from the environment with no side effects, it should be okay.
17:42:24 <syntaxfree> ah, yes. behold the concurrency wars.
17:42:33 <Cale> Otherwise, you're getting into potential unsafety.
17:42:39 <syntaxfree> I took a look at Erlang, but somehow I'm not impressed.
17:42:44 <Cale> I suppose that idempotent output *might* be okay.
17:42:57 <xic> data Circle = Circle { radius :: Double, areaCache :: IORef (Maybe Double) }
17:42:59 <Cale> So long as no other thread had access to it.
17:43:09 <Cale> (the same resource that the output was affecting)
17:43:19 <ddarius> syntaxfree: Because it's easy enough to do message passing in most languages ?
17:43:28 <LoganCapaldo> this is why whenever I need a concurrent program I go into the kernel of whatever os I happen to be using and rewrite the scheduler so my program's behavior is deterministic ;)
17:43:42 <syntaxfree> probably because I don't know the first thing about message passing so I ignored the concurrency features.
17:43:47 <xic> Cale: now i have a setRadius :: Circle -> Double -> Circle function, that sets the IORef to Nothing
17:44:02 <ddarius> syntaxfree: Um... that'd do it.
17:44:09 <Philippa> yeah
17:44:11 <Philippa> just a little
17:44:19 <syntaxfree> except for the concurrency, what does Erlang have?
17:44:21 <xic> Cale: and a getArea :: Circle -> Double function that somehow updates the IORef if it is nothing
17:44:40 <Philippa> that's like asking "except for the OO, what does Smalltalk have?"
17:44:46 <dons> sjanssen: wow!
17:44:47 <ddarius> syntaxfree: A fairly nice pattern matching syntax.
17:44:49 <Cale> Message passing seems to just move the problems with compositionality in concurrency around without really solving them. It does help over shared memory, locks and condition variables, only in that it decreases the amount of shared state and gives the user control over it..
17:45:03 <dons> sjanssen: so you're going to take a dwm-ish approach to removing code and keeping it simple?
17:45:08 <LoganCapaldo> A prolog inspired syntax?
17:45:10 <dons> simple and very fast?
17:45:16 <ddarius> Philippa: Very high amount of reflectivity.  That's the interesting about Smalltalk, otherwise it's fairly passe.
17:45:17 <JoshTriplett> LoganCapaldo: Not a feature. :)
17:45:18 <LoganCapaldo> FP merged with dynamic typing?
17:45:23 <Cale> xic: odd :)
17:45:33 <xic> Cale: hm... will this even work?
17:45:38 <syntaxfree> maybe the docs were bad.
17:45:43 <syntaxfree> i was underwhelmed.
17:45:43 <Cale> xic: what are you trying to do?
17:45:43 <mbishop> How can you attribute speed to a window manager? is there a window manager with a "SLOW THE HELL DOWN" setting or something?
17:45:44 <Philippa> ddarius: yeah, but it's older than I am, what do you expect?
17:45:50 <LoganCapaldo> Oh I know! Bit pattern matching!
17:45:55 <sjanssen> dons: I'm not quite so militant on the minimum lines of code.  But yes, I'd like it to be simple
17:45:59 <syntaxfree> next language to look at is Scala.
17:46:06 <syntaxfree> Bit pattern matching? Hey, cool!
17:46:22 <Philippa> syntaxfree: the concurrency is a big thing with Erlang partly because it encourages you to create new processes like other languages create objects
17:46:32 * ddarius was referring mostly to that earlier.
17:46:59 <mr_tenor> bit pattern matching rocks hard
17:47:05 <xic> Cale: i'm not sure exactly
17:47:06 <Philippa> yeah, I was perhaps doing it in a slightly different manner :-)
17:47:10 <allbery_b> mbishop: kde's window manager handlles a coupel hundred windows far better than, say, fvwm
17:47:15 <newsham> logan: why bother with an OS?
17:47:19 <ddarius> syntaxfree: The message passing concurrency model encourages a different style of programming.  If you've played with the pi calculus some, you probably have a fairly good idea of that.
17:47:21 <allbery_b> 5 seconds to close a window is *not* acceptable
17:47:24 <sjanssen> dons: what do you think of dwm's dynamic layout?
17:48:00 <dons> sjanssen: i just use dwm for full screen xterms on my laptop, and floating windows for gimp
17:48:02 <Cale> xic: If you're trying to memoise things, then you really want to consider getting it via sharing values with a constant, like an array.
17:48:07 <dons> that's about it :)
17:48:08 <mbishop> allbery_b: I think if you have a couple hundred windows open, you've got a bigger problem than what window manager you choose :)
17:48:17 <Cale> If that really isn't going to work out, then you will want to read a paper.
17:48:17 <allbery_b> mbishop: zwgc :)
17:48:24 <dons> i do like popping windows across to different screens with a single keystroke
17:48:31 <mbishop> allbery_b: eh?
17:48:45 <Cale> http://citeseer.ist.psu.edu/peytonjones99stretching.html
17:48:46 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
17:48:54 <allbery_b> welcome to carnegie mellon.  zwgc is a client for the zephyr instant messaging service
17:48:56 <xic> Cale: no, a constant won't work
17:49:04 <sjanssen> dons: the dynamic layout always got on my nerves, I'm thinking ion style tiles of tabs instead
17:49:12 * ddarius needs to get ubuntu on the net so he can use ion comprehensively.
17:49:50 <sjanssen> dons: also, how do you feel about tags vs. workspaces?
17:49:51 * Cale has been happily using boring metacity. :)
17:49:51 <xic> Cale: i read that paper! :)
17:50:15 <dons> sjanssen: yeah, tabs would be ok. i used to miss them, but don't know actually
17:50:17 <dons> don't now.
17:50:18 <ddarius> Cale: ion is probably far more boring (in many respects) than metacity.
17:50:26 <Cale> I can't live without overlapping windows.
17:50:27 <dons> i don't think i use tags very much
17:50:32 <dons> basicaly just for 5 workspaces
17:50:50 <dons> (i have very simple layout requirements, it seems)
17:50:55 * ddarius always has everything in Windows at full screen, all his vim buffers at full screen.
17:50:57 <Cale> Well, I could, if the real problems with user interfaces could be fixed.
17:51:02 <dons> yeah, like ddarius
17:51:24 <Cale> There's too much cruft that's impossible to remove when you don't need it in most program UI's.
17:51:37 <ddarius> Cale: Exactly.
17:51:47 <sjanssen> I like to have a split screen between code and docs/terminal
17:51:49 <Cale> I like the fact that overlapping windows let you cover that stuff up and get a little more screen real estate.
17:51:54 <xic> "Many readers, ourselves included, will have a queasy feeling by this stage. What is left of the beauty of functional programming by the time all these primitives have been added? How can the unspecified "proof obligations" of unsafePerformIO be characterised and proved? Has the baby been thrown out with the bath water? These are justifiable criticisms. The baby is indeed in danger."
17:51:56 * LoganCapaldo goes and lives in his smalltalk
17:52:00 <dons> yeah, that was critical for larger screens, i think, sjanssen
17:52:04 <LoganCapaldo> There! no nothing is impossible to remove
17:52:10 <LoganCapaldo> s/no/now
17:52:17 <ddarius> I also tend to remove, hide, or minimize toolbars, address bars, menu bars and such.
17:52:27 <Cale> xic: yeah, unsafePerformIO is not to be taken lightly.
17:52:30 <LoganCapaldo> Does anyone have a good Haskell implementation in smalltalk?
17:52:51 <Cale> xic: It ought to be called simonPerformIO, and only used if your first name is Simon.
17:52:59 <dons> LoganCapaldo: heh are you crazy? :)
17:53:10 <dons> do we have a good smalltalk implementation in haskell, don't oyu mean?
17:53:11 <LoganCapaldo> I sure hope so :)
17:53:17 <Philippa> are you implying that simon and unsafe are synonymous?
17:53:29 <sorear> @quote Cale It ought to be called simonPerformIO, and only used if your first name is Simon.
17:53:30 <lambdabot> No quotes match. You type like i drive.
17:53:38 <LoganCapaldo> Hmm I guess that would work
17:53:43 <dons> i don't think the smalltalk folks ever spoke to the lambda folks
17:53:47 <sorear> @remember Cale It ought to be called simonPerformIO, and only used if your first name is Simon.
17:53:48 <lambdabot> Done.
17:53:49 <Cale> Squeak is fun, sort of like rollercoasters are fun. You fear for your life in a sort of artificial way.
17:54:02 <SimonCapaldo> Bwahahahah
17:54:03 <Philippa> dons: depends who you call lambda folks, no?
17:54:07 <SimonCapaldo> Now I have the power!
17:54:13 <sjanssen> Cale: what do you mean? (I've never used Squeak)
17:54:20 <ddarius> dons: They did speak with the Scheme folks
17:54:25 * SimonCapaldo gives up the power
17:54:28 <Cale> sjanssen: It's a smalltalk. Absolutely Everything Is Mutable.
17:54:36 <mr_tenor> SimonCapaldo: ?
17:54:53 <sorear> Cale: even literal constants?
17:55:00 <LoganCapaldo> I could have used simonPerformIO then
17:55:00 <xic> Cale: would the implementation in that paper work with unsafeIOtoSTM? can 2 unsafeIOtoSTM actions happen concurrently? what happens when the memo table or whatever is accessed concurrently?
17:55:00 <ddarius> sorear: Yes.
17:55:02 <Cale> Things interact with each other in arbitrary ways via message passing in a continuous fashion, even as you're writing the code for them.
17:55:04 <sorear> FORTRAN's amazing 4 = 2
17:55:11 <LoganCapaldo> @ mr_tenor
17:55:55 <ddarius> Cale: I think what you want is that the meaning of the program can change throughout the course of the program.
17:55:59 <Cale> xic: You're already in STM, which has mutable cells, why not just memoise things directly?
17:56:18 <Cale> ddarius: yes, that can happen
17:57:12 <xic> Cale: good point.... but how do i know when to free stale memoisations?
17:57:19 <dons> ok. this is weird. one of my shootout entries only runs at full speed when flags are set in the file OPTIONS pragma...
17:57:28 <dons> now to work out which flag that is
17:57:39 <LoganCapaldo> Memoizations can get stale?
17:57:41 <Cale> xic: That's always an application-specific concern, and the reason why we don't have a generic 'memo' function in Haskell.
17:58:36 <Cale> LoganCapaldo: yes, you can be aware that you're never going to apply that function to that parameter ever again.
17:58:47 <xic> Cale: my real need is that i have a big database in a file, and i want to cache data sets of it in transactional memory
17:59:22 <Cale> Okay.
17:59:29 * LoganCapaldo tries to think of an example of that
18:00:19 <dons> got it!
18:00:25 <Cale> So you create a new thread, and it's going to read from the database as needed, and update a TVar or something whenever results are demanded and it has to hit the DB, and checks the contents of that TVar for the result before going to the DB?
18:00:32 <dons> looks ike -fexcess-precision is *ignored* unless its in the OPTIONS pragma!
18:01:00 <LoganCapaldo> dons: excess of something makes it go faster?
18:01:21 <dons> it turns off excess-precision (yeah, I know, don't say it!)
18:01:42 * LoganCapaldo doesn't say it. But thinks it, very loudly
18:01:50 <dons> but, that means a couple of shootout entries are running 2-3 times slower
18:01:59 <Cale> http://www.thisisbroken.com/
18:01:59 <JoshTriplett> dons: It makes perfect sense: "F excess precision, I want to go faster". :)
18:02:00 <lambdabot> Title: This Is Broken
18:02:00 <ddarius> Hey it reads like that "F excess precision!"
18:02:04 <dons> since the flag is being ignored on the command line
18:02:15 <sjanssen> no, -fexcess-precision does turn on excess precision
18:02:15 <xic> Cale: hm.... i'll need somethink like getValue :: TVar DB -> Key -> STM Value
18:02:32 <dons> sjanssen: oh, what's the reason it speeds everything up then?
18:02:33 <xic> Cale: how does the db thread detect this request and hit the actual db?
18:02:46 <allbery_b> because excess precison is what the FPU produces
18:02:50 <Cale> xic: perhaps set up a TChan?
18:03:00 <allbery_b> IEEE precision is obtained by masking after every FPU op
18:03:06 <allbery_b> yes, this is dumb
18:03:10 <dons> allbery_b: ah rihght, we ignore the excess the fpu produces
18:03:15 <sorear> dons: also, discovered yesterday:
18:03:16 <dons> screw IEEE
18:03:19 <sorear> @src Word8
18:03:19 <lambdabot> Source not found. My mind is going. I can feel it.
18:03:27 <sorear> data Word8 = Word8# Word#
18:03:28 <dons> hmm?
18:03:31 <sjanssen> dons: what allbery_b says
18:03:31 <xic> Cale: hm... i haven't read about TChan yet
18:03:36 <sorear> ^^^ is this hurting us?
18:03:39 <dons> right .good.
18:03:58 <dons> sorear: it still has narrowWord8# primops inserted in the backend
18:04:01 <Cale> xic: It's just the STM-equivalent of a channel. You write to one end, stuff comes out the other.
18:04:13 <dons> sorear: so they're not really words
18:04:32 <sjanssen> they're words wrt to storage, right?
18:04:38 <sorear> dons: they are words, speedwise ... with extra masking!
18:05:28 <Cale> Reading when it's empty will block until it's not.
18:05:29 <dons> check the C backend.
18:05:32 <xic> Cale: so you're saying that it will be possible to write such a getValue function, that will behind the scenes(in another thread) do some IO work?
18:05:53 <Cale> xic: sorry, what's getValue's type?
18:06:05 <xic> getValue :: TVar DB -> Key -> STM Value
18:06:22 <Cale> Is it necessary that it be in STM?
18:06:34 <xic> yes
18:06:51 <xic> i may want to atomically increment the value for example
18:07:20 <Cale> er, IO which would increment something would be very bad to stick into an STM transaction, unless you don't care how much it gets incremented.
18:07:36 <sjanssen> dons: is narrowWord8# some sort of magic operation?
18:07:43 <ddarius> Bah! I should be broke.  Why is my money not gone?!
18:07:50 <sjanssen> ie. something other than a lowest 8 bits mask
18:08:05 * sorear is reminded of the K6 highmem bug
18:08:11 <dons> its a cast, in the C backend, iirc
18:08:25 <Cale> If you want to increment something, much safer to make it a TVar, so that the changes can be rolled back if the thing doesn't commit.
18:08:38 <Cale> (or rather, they just won't be committed)
18:09:13 * ddarius wonders if recursive helping can be used in other contexts.
18:09:47 <allbery_b> (actually, the precision behavior has good, if annoying, reasons)
18:10:16 <dons> sjanssen: so that's the weird slowdown (and why the shootout wasn't reproducing our results) -fexcess-precision is ignored on the command line
18:10:21 <xic> Cale: hm.... this is complicated stuff. what do you think about the idea of a layer on top of STM adding pre and post IO hooks to transactions?
18:10:37 <dons> sjanssen: so e.g. body, spectral, recursive are all running 2x slower or more
18:11:03 <Cale> xic: That's totally doable, and in fact has already been done.
18:11:14 <sjanssen> dons: well, it's nice to have that resolved :)
18:11:23 <dons> yeah. that was a bit of a mystery!
18:11:30 <dons> and now a bug report to file, I think.
18:11:44 <xic> Cale: then i could have getValue be MySTM Value, where running a MySTM guarantees that a post-hook IO action is run on completion
18:11:47 <dons> (this has been hurting us for a year or more now, all this talk of numerics being bad!)
18:11:56 <Cale> xic: It's also easy enough just to enqueue IO actions in a list to be part of the return value of the STM action.
18:12:09 <Cale> Depending on what you're doing.
18:12:39 <Cale> Look on the mailing lists, that extension to STM has been fully worked out.
18:12:46 <xic> :O
18:14:12 * ddarius should be doing -something- constructive right now.
18:14:43 <bd_> Cale: Is it possible to do it in an atomic manner? That is, ensure that if an action is enqueued, it will complete before any other thread observes the changes in the txn in question?
18:15:32 <Cale> bd_: not so easily.
18:15:57 <Cale> bd_: It would generally be really bad for performance anyway.
18:16:33 <LoganCapaldo> @src scanl
18:16:33 <lambdabot> scanl f q ls = q : case ls of
18:16:33 <lambdabot>     []   -> []
18:16:33 <lambdabot>     x:xs -> scanl f (f q x) xs
18:16:35 <bd_> I was thinking it'd be useful to compose STM with actual disk database transactions, durably
18:16:39 <LoganCapaldo> bah
18:16:50 * LoganCapaldo was hopping for a definition in terms of foldl
18:16:53 <Cale> The thing that makes STM work well in most cases is that transactions are able to run optimistically.
18:18:57 <ddarius> @src foldl
18:18:57 <lambdabot> foldl f z xs = lgo z xs
18:18:57 <lambdabot>     where lgo z []     =  z
18:18:57 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
18:27:09 <twanvl> What kind of error handling should be prefered for an encoding library?
18:27:13 <twanvl> Should I have decodeUTF16 :: ByteString -> CompactString, which can throw exceptions,
18:27:18 <twanvl> or should I use decodeUTF16 :: Monad m => ByteString -> m CompactString?
18:27:39 <xic> twanvl: have you looked at UTF8.lhs to see how they do it?
18:28:09 <twanvl> xic: it uses exceptions (error)
18:28:29 <xic> i thought it returns (String, [Error])
18:28:57 <twanvl> Oh, I was looking at encode, sorry
18:29:01 <bd_> twanvl: ByteString -> Either DecodeError CompactString ?
18:29:14 <bd_> Or for that matter, you could use MonadError
18:29:43 <bd_> though Monad would be simpler
18:29:59 <bd_> most people probably won't need a detailed error resuly...
18:30:00 <twanvl> I am leaning more towards using exceptions, since they used by for instance chr. And I think wrongly encoded strings really are exceptional.
18:30:17 <bd_> twanvl: exceptions can't be caught from pure code
18:30:49 <twanvl> But the thing you are decoding was accuired using IO anyway
18:31:03 <bd_> twanvl: That doesn't mean you want to process it in IO
18:31:16 <sorear> how about both?
18:31:19 <twanvl> No, but you want to handle exceptions there
18:31:56 <sorear> decode :: ByteString -> Either CodeError CompactString
18:32:04 <sorear> decode_ :: ByteString -> CompactString
18:32:13 <sorear> decode_ = fromRight . decode
18:32:21 <sorear> where fromRight (Left s) = error s
18:32:30 <sorear>       fromRight (Right v) = v
18:32:34 <sorear> ?
18:32:53 <chessguy> can someone translate this to english for me? code :: StateT [Char] IO ()
18:33:09 <sorear> twanvl: also, /me takes opportunity to espouse the virtues of phantom types
18:33:12 <bd_> sorear: decode can be generalized to MonadError CodeError m => ByteString -> m CompactString, can't it?
18:33:24 <heatsink> chessguy: code is an IO action that returns nothing, and carries a string state with it
18:33:37 <allbery_b> a StateT carrying String state, stacked on top of IO, returning a type () (presumably an IO action's result)
18:33:48 <twanvl> sorear: how would I use those here?
18:33:50 <allbery_b> @unmtl StateT [Char] IO ()
18:33:51 <lambdabot> [Char] -> IO ((), [Char])
18:33:57 <sorear> bd_: that's a false generalization (eitherToMonadError is writable), and probably not worth it; decode_ would be usable purely
18:34:16 <bd_> sorear: I thought Either is an instance of MonadError?
18:34:23 <heatsink> chessguy: StateT wraps a monad in a state-like monad, so you get a state monad with another monad inside.
18:34:49 <sorear> bd_: I don't think so (since you need an instance Error CodeError)
18:35:04 <DannoHung> Why would anyone use foldr instead of foldl?
18:35:22 <allbery_b> foldl builds up lots of thunks and then evaluates them in reverse
18:35:22 <bd_> hmm, I suppose
18:35:38 <sjanssen> DannoHung: foldr is useful in several situations
18:35:51 <twanvl> Such an instance is not too hard, just have data CodeError = ... | OtherError String
18:35:55 <sjanssen> > foldr (||) True (repeat True)
18:35:56 <lambdabot>  True
18:36:11 <sjanssen> > foldl (||) True (repeat True)
18:36:15 <lambdabot> Terminated
18:36:18 <sjanssen> @src any
18:36:19 <lambdabot> any p =  or . map p
18:36:25 <sjanssen> @src or
18:36:26 <lambdabot> or    =  foldr (||) False
18:36:29 <bd_> twanvl: that seems to be overloading CodeError a bit...
18:36:31 <allbery_b> basically, you end up with chunks of incomplete calculation waiting for foldl to reach the end of the list and then resolve them all.  foldr goes to the end of the list first
18:37:09 <gotaku> Can someone explain to me how newtype is used in the definition of the State type?
18:37:09 <DannoHung> Oh... huh, I must be reading this wrong, still very Haskell newb
18:37:23 <gotaku> newtype State s a = State { runState :: (s -> (a,s)) }
18:37:36 <sorear> twanvl: you lose a lot of type safety - it becomes easy to accidentally have a $random_other_subsystem error become wrapped in a CodeError
18:37:41 <sjanssen> DannoHung: reading what wrong?
18:37:56 <twanvl> sorear: That's true
18:38:01 <sorear> gotaku: think of it as data, only more efficient and with slightly nicer semantics wrt _|_
18:38:08 <DannoHung> http://haskell.org/haskellwiki/Stack_overflow
18:38:09 <lambdabot> Title: Stack overflow - HaskellWiki
18:38:25 <TuringTest> dons: Excellent paranoia must have been needed to find that -fexcess-precision bug.  But now it is 2:37AM, so good night everyone!
18:38:41 <gotaku> sorear: I've heard that but I want to know how... it's use doesn't fit with the definition that I have seen.
18:38:46 <sorear> time zones suck
18:38:54 <dons> TuringTest: hehe :-)
18:39:10 <sjanssen> DannoHung: yes, foldr can stack overflow when the function is strict in the second element
18:39:14 <sorear> @activity-full 45
18:39:15 <lambdabot> 1*total 1*TuringTest
18:39:34 <TuringTest> dons is -fexcess-paranoia ?
18:39:51 <gotaku> According to the Gentle Indtroduction to Haskell it's defined as: "...the newtype declaration creates a new type from an existing one."
18:40:03 <ddarius> @oldwiki StackOverflow
18:40:03 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
18:40:15 <gotaku> What is the existing type that State is being defined from?
18:40:22 <DannoHung> I'm probably not really even ready to be diving this deep
18:40:23 <sorear> TuringTest: sorry.  abuse of power recognized. :(
18:40:25 <dons> TuringTest: there had to be something happening. A mandel entry running 1.8x C here would run 11x C there...
18:40:47 <TuringTest> gotaku: A tuple
18:40:57 <dons> *hopefully* this fixes the numerics entries enough to be respectable
18:40:58 <sorear> TuringTest: a function!
18:41:13 <TuringTest> gotaku: I am wrong:  A function.
18:41:27 <twanvl> I still don't see why anyone would be interested in knowing how exactly a string is encoded incorrectly. If it is not correct, either you made it yourself (which you shouldn't, since you have an encoding library), or you got it from someone else, in which case all you can do is tell him the string you got is incorrect. More information is never needed.
18:41:43 * TuringTest reminds himself not to give advice after 2 am
18:42:16 <sorear> twanvl: I agree.
18:42:17 <gotaku> Can you always use newtype in such cases?
18:42:51 <TuringTest> gotaku: newtypes do not automatically inherit any instances of type classes.  This can be useful.
18:43:03 <sorear> gotaku: yes.  newtypes are extremely powerful.  I believe they are equivalent to type lambdas, but with slightly different inference properties.
18:43:10 <kfish> who made foldl.com and foldr.com ?
18:43:40 <gotaku> That's funny.
18:43:46 <sorear> kfish: Oliver Steele
18:43:53 <sorear> steele@osteele.com
18:44:04 <kfish> sorear, cheers :-) they rule
18:44:13 <sorear>    23 Forestedge Rd.   Amherst, MA 01002 US   +1.6177397366
18:44:20 <sorear> kfish: who is "they"
18:44:41 <kfish> sorear, "they" is the sites / domains
18:44:42 <TuringTest> dons: When the new entries are all up you should put a note in the weekly news.
18:44:44 <sorear> the Registry?
18:45:26 <sorear> kfish: Rule #1 of web anonymity: don't register the domain yourself.
18:45:28 <sorear> whois++
18:45:39 <kfish> heh
18:46:48 <ddarius> foldr.com would be a good name for a Haskell library repository.
18:47:07 <dons> yeah, I'm thinking I should write up the issues uncovered during the past week
18:47:37 <kfish> hi dons
18:47:38 * sorear goes back to writing the whole-program optimizer for yhc
18:47:42 <dons> hey kfish
18:48:34 <mr_tenor> ddarius: you need something so that prepending "something." lets you compose the functions cleverly :)
18:52:41 * ddarius wonders if the other code in this collection will look as clean.  Probably not.
18:57:07 <gotaku> Is there an easy way how I can see how the State monad is defined?
18:57:22 <ddarius> @oldwiki MonadState
18:57:22 <lambdabot> http://www.haskell.org/hawiki/MonadState
18:57:31 <mbishop> @source MonadState
18:57:31 <lambdabot> MonadState not available
18:57:38 <mbishop> ?where MonadState
18:57:38 <lambdabot> I know nothing about monadstate.
18:57:54 <sorear> @src State
18:57:55 <lambdabot> Source not found. My mind is going. I can feel it.
18:58:07 <sorear> @src State >>=
18:58:08 <lambdabot> Source not found. It can only be attributed to human error.
18:58:16 <sorear> @source Control.Monad.State
18:58:17 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
18:58:25 * mbishop claps for sorear 
18:58:27 <sorear> gotaku: ^^^ the source
18:58:33 <emu> does lhs2TeX have problems dealing with the ($) operator at all?
18:58:39 * sorear bows
18:58:41 <gotaku> Thanks.
18:59:07 <allbery_b> @src State (>>=)
18:59:08 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:59:16 <allbery_b> correct syntax, at least
18:59:23 <allbery_b> @src Maybe (>>=)
18:59:24 <lambdabot> (Just x) >>= k      = k x
18:59:24 <lambdabot> Nothing  >>= _      = Nothing
18:59:35 <sorear> dons: poke, what's going on with www.cse.unsw.edu.au
18:59:47 <mbishop> university asplode?
19:00:28 <sjanssen> @djinn-add type State s a = s -> (a, s)
19:01:03 <sjanssen> @djinn State s a -> (a -> State s b) -> State s b
19:01:03 <lambdabot> f a b c =
19:01:04 <lambdabot>     case a c of
19:01:04 <lambdabot>     (d, e) -> b d e
19:01:17 <dons> sorear: there's some repairs happening today (saturday). i hope it's back up soon
19:01:40 <sorear> gah.  this is holding up my daily pull. :)
19:01:56 * sorear replicate 17 "^C"
19:02:00 <gotaku> Ok, this is weird... the All About Monads article defines the MonadState instance for State as: instance MonadState (State s) s where
19:02:16 <gotaku> While the source says: instance MonadState s (State s) where
19:02:27 <sorear> gotaku: the source is right
19:02:44 <ddarius> gotaku: Do they have the same class declarations?
19:03:06 <gotaku> No, they are reversed too.
19:06:02 * ddarius should just go to sleep.
19:07:29 <sorear> @where yhc
19:07:30 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
19:08:34 <mbishop> @where monads
19:08:35 <lambdabot> http://www.nomaware.com/monads/html/index.html
19:08:58 <mbishop> Is that site still down for anyone else?
19:09:10 <chessguy> it is for me
19:09:16 * mbishop nods
19:09:37 <mbishop> I have the pdf that I found with google up on my server :/
19:09:59 <chessguy> is it linkable?
19:10:07 <ddarius> Papers!  I forgot about my papers!
19:10:33 <emu> aha, OPTIONS_GHC pragma is causing lhs2TeX to barf
19:10:46 <emu> (or rather, latex to barf on the output)
19:10:56 <mbishop> chessguy: http://mbishop.esoteriq.org/stuff/allaboutmonds.pdf
19:11:03 <mbishop> er
19:11:12 <mbishop> http://mbishop.esoteriq.org/stuff/allaboutmonads.pdf
19:11:13 <chessguy> is that relatively permanent?
19:11:16 * mbishop nods
19:11:31 <mbishop> just switched to dreamhost in fact, so it's nice and fast too :o
19:11:34 <chessguy> ?where+ monads http://mbishop.esoteriq.org/stuff/allaboutmonads.pdf
19:11:34 <lambdabot> Done.
19:12:54 <gotaku> Why does the haskell source use tabs?
19:13:15 <sorear> because they were there
19:13:17 <sorear> no more
19:13:39 <sorear> if tabs didn't exist, haskell wouldn't use them
19:13:44 <araujo> hello
19:13:58 * sorear supposes that last statement was rather tautological
19:14:07 <sorear> hello back
19:14:09 <nornagon> i saw a really good article once about elastic tabs
19:14:17 <nornagon> which is How ^I Should Be.
19:15:35 * ddarius wants to write code, but not strongly enough...
19:21:05 <Cale> I think that the tab character just shouldn't exist in source files. Editors should be better at aligning text, but when files are saved, save them using only spaces, which have an unambiguous interpretation.
19:21:53 <dons> mm. syntax coloured Core code is so much nicer on the eyes!
19:22:19 <sorear> <*dons>  <-- ouch, what happened?
19:22:30 <dons> hmm
19:22:31 <nornagon> Cale: I use :set et myself.
19:22:50 <dons> what's that mean?
19:22:59 <hpaste>  gotaku pasted "MyState error" at http://hpaste.org/426
19:23:01 <sorear> not-nickserv-id'd
19:23:16 <gotaku> Can someone tell me why that fails with the listed error?
19:23:48 <dons> yeah, silly irc client
19:23:54 <bd_> gotaku: try -fglasgow-exts
19:23:54 <sorear> gotaku: you need fancier instances
19:24:15 <gotaku> Ah, right...
19:24:18 <allbery_b> that's -fglasgow-exts for multiparameter type classes
19:24:28 <gotaku> Forgot about that.
19:24:48 <gotaku> Why were they never added to Haskell 98?
19:25:42 <Cale> Because typeclasses were pretty new, and they wanted to be conservative with respect to what they were standardising on.
19:27:45 <LoganCapaldo> Is there a Haskell 200X in the works?
19:27:54 <heatsink> There's a Haskell Prime
19:27:58 <bd_> LoganCapaldo: Yep, Haskell' is being worked on atm
19:28:21 <bd_> which basically amounts to standardizing what GHC and Hugs have done for years now :)
19:28:49 * LoganCapaldo was just about to ask if the body of the document contained only See source code of GHC <g>
19:29:54 <allbery_b> ghc includes stuff that isn't likely to make H'.  think of it as the testbed for possible H' extensions
19:31:04 <ddarius> Yay extremely densely typeset math and text!
19:31:40 * LoganCapaldo wonders if anyone is really working on Haskell' at_m_
19:31:57 <gotaku> I need a new vim color scheme.
19:32:45 <nornagon> i like zenburn.
19:32:50 <defcon8> gotaku, you need to bloody use emacs
19:32:52 <sjanssen> I use evening
19:33:12 <DannoHung> vi is for win
19:33:24 <gotaku> You use evening? Really?
19:33:24 <LoganCapaldo> does emacs have good color schemes?
19:33:40 <sjanssen> gotaku: yeah
19:33:57 <gotaku> sjanssen: With what font?
19:33:58 <chessguy> ?hoogle smal
19:33:59 <lambdabot> Text.Html.small :: Html -> Html
19:34:02 <chessguy> ?hoogle small'
19:34:02 <lambdabot> No matches found
19:34:07 <chessguy> ?hoogle small
19:34:08 <lambdabot> Text.Html.small :: Html -> Html
19:34:14 <defcon8> wtf is evening
19:34:35 * ddarius is currently using torte
19:34:36 <defcon8> evening commander for emacs?
19:34:46 * allbery_b thought it was a vim color scheme
19:34:58 * allbery_b not a vim user...
19:34:59 <sjanssen> gotaku: monaco on my mac -- because it's the one monospace font that OS X doesn't mangle
19:35:11 <sjanssen> gotaku: bitstream vera sans mono in linux
19:35:49 * glguy uses Monoco... but OS X at least manages to leave artifacts using Vim
19:35:54 <LoganCapaldo> No Haskell examples unfortunately http://www.cs.cmu.edu/~maverick/VimColorSchemeTest/
19:35:55 <lambdabot> Title: Vim Color Scheme Test
19:36:00 <sjanssen> glguy: yeah, happens to me too
19:36:04 <DannoHung> I use desert
19:36:13 <chessguy> > let smallest x y z | x <= y = if y <= z then x else y; | y <= z = y; otherwise z in smallest 1 2 3
19:36:14 <lambdabot>  Parse error
19:36:32 <sjanssen> glguy: I have "set nomacatsui" in my .gvimrc, it helps a little
19:36:42 <glguy> let smallest x y z = min x $ min y z -- ?
19:36:49 <glguy> sjanssen: ditto
19:36:50 <allbery_b> missing | before otherwise
19:37:01 <chessguy> @type min
19:37:03 <lambdabot> forall a. (Ord a) => a -> a -> a
19:37:14 <allbery_b> @type minimum
19:37:16 <lambdabot> forall a. (Ord a) => [a] -> a
19:37:18 <glguy> let smallest x y z = minimum [x,y,z]
19:37:35 <newsham> ?where shim
19:37:36 <lambdabot> http://shim.haskellco.de/trac/shim
19:38:24 <gotaku> I don't seem to have bitstream vera for some reason...
19:38:51 <sjanssen> glguy: I think I'm going to switch to Linux because gvim sucks in OS X
19:39:06 <glguy> sjanssen: it would take a lot more to drive me to Linux ;)
19:39:15 <master_baiter> sjanssen switch to freebsd instead.
19:39:47 <sjanssen> master_baiter: I'm sure freebsd would take even more work to get all my laptop's features working
19:39:48 <LoganCapaldo> sjanssen: COnsidered running gVim under X under OS X
19:39:59 <master_baiter> sjanssen it worked great on my laptop
19:40:02 <master_baiter> without much effort.
19:40:18 <gotaku> Oh that's why. I have the DejaVu fonts instead.
19:40:24 <sjanssen> LoganCapaldo: X11 is pretty annoying on the mac
19:40:27 <newsham> and as a bonus, the source code is readable and maintained by a small group of people who understand it! ;-)
19:40:40 <sjanssen> I'm tired of macports too
19:40:49 <glguy> if you don't need 3d hardware support, openbsd is pretty nice for laptops
19:40:56 <gravity> Since http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output#Mind_your_expression_types_too isn't finished yet, what's the proper solution for such a problem? I had thought it was to use return, but the TODO notes that this is "kinda silly"
19:40:58 <LoganCapaldo> sjanssen: WHich variant of gVim are you using?
19:40:58 <lambdabot> http://tinyurl.com/2cgp6b
19:41:01 <glguy> good wireless and speedstep and whatnot
19:41:03 * LoganCapaldo uses Vim.app
19:41:10 <LoganCapaldo> No artifacts for I
19:41:18 <sjanssen> LoganCapaldo: Vim.app for me too
19:41:24 <glguy> LoganCapaldo: you are using anti-aliased fonts?
19:41:39 <LoganCapaldo> set nomacatsui anti enc=utf-8 gfn=Monaco:h13
19:41:52 <LoganCapaldo> So make of that what you will :)
19:42:01 <LoganCapaldo> that was mostly set via trial and error
19:42:05 * heatsink is shocked
19:42:22 <heatsink> I get different results when I move let clauses around in an mdo due to strictness
19:42:28 <heatsink> Is that supposed to happen?
19:46:58 <gotaku> What's nomacatsui?
19:46:59 <newsham> why would you run openbsd on an ia32?
19:49:26 <LoganCapaldo> gotaku: magically mac specific option? *shrug*
19:55:26 <ohmega> @get-shapr
19:55:26 <lambdabot> shapr!!
20:00:12 <kfish> anyone got any advice on the differences between the books TTFP and TaPL/ATTaPL ?
20:02:07 * kfish is currently reading Stenlund's "Combinators, Î»-terms and Proof Theory" (1972) but looking for something a bit more practical next ;-)
20:12:27 <dons> ghc fact of the day part 2: double constants at the top level aren't inlined
20:14:56 <sorear> !
20:15:28 <dons> I got something like 10% speed up just by inlining dt = 0.01 (!)
20:15:40 <dons> (though we're at the level where the interaction with gcc really matters)
20:15:49 <dino-> @paste
20:15:49 * dons looks at asm all day long now
20:15:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:15:51 <newsham> any turtle graphics in the hask.heir.libs?
20:15:59 <sorear> hehe
20:16:16 <newsham> > let dragon x = x ++ [True] ++ map not x in (dragon.dragon.dragon) [True]
20:16:18 <lambdabot>  [True,True,False,True,False,False,True,True,False,False,True,False,True,True...
20:16:21 <sorear> yhc doesn't like parsec, it seems
20:16:21 <newsham> dragon curves
20:16:36 <hpaste>  dino- pasted "HaXml conundrum" at http://hpaste.org/427
20:17:07 <dino-> If anybody is around with some HaXml experience..
20:17:37 <dino-> I should add that I'm trying to process some XML data into plain old texty text. No markup.
20:18:47 <sorear> @seen ndm
20:18:48 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 16d 10h 35m 38s ago, and .
20:19:00 <newsham> hrm, looks like lots of people give out "write a turtle graphics system" excercises in haskell
20:19:04 <newsham> but i dont see any libs for it
20:19:12 <sorear> @seen shackell
20:19:13 <lambdabot> I haven't seen shackell.
20:19:18 <sorear> @seen tomshackell
20:19:18 <lambdabot> I haven't seen tomshackell.
20:20:16 <sorear> @seen beelsebob
20:20:16 <newsham> is HGL part of ghc?
20:20:16 <lambdabot> beelsebob is in #haskell. I don't know when beelsebob last spoke.
20:20:32 <beelsebob> fart
20:20:36 <sorear> yhc: user error (Error: /home/stefan/lib/yhc/packages/parsec/2.0/Text/ParserCombinators/Parsec.hi(381:26-381:27) Found 17 but expected one of interface }' ; {-end-of-definition-} ( <varid> _instance_ _class_ _data_ _newtype_ _type_)
20:20:43 <sorear> ^^^ any yhc hackers?
20:20:54 <beelsebob> not my job to fix
20:21:03 <sorear> Yes, I compiled it myself.
20:21:07 <beelsebob> :P
20:21:09 <sorear> (parsec that is)
20:21:25 <sorear> yhc didn't complain at the time
20:21:39 <sorear> (I was actually rather suprised when parsec compiled)
20:24:36 <sorear> can anyone shed light on the error?
20:27:30 <chessguy> > let data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show in Branch 3
20:27:30 <lambdabot>  Parse error
20:27:53 <chessguy> > data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show; Branch 3
20:27:54 <lambdabot>  Parse error
20:28:13 <emk> I'm seeing weird interactions between rewrite rules and inlining (I think).
20:29:22 <emk> When I define something like "treeSum t = treeFoldr (\l x r -> l+x+r) 0 t", I would expect the treeSum to eventually be inlined, making the treeFoldr visible to the surrounding code (and therefore eligible for fusion).
20:29:34 <emk> But it only works if I inline treeSum by hand.
20:29:40 <dons> inlining and rewrite rules interact strongly
20:29:55 <dons> you have to some times delay inlining for key expressions in order for them to be matched first
20:29:56 <heatsink> emk: Have you tried a pragma?
20:30:02 <heatsink> oh
20:30:05 <dons> e.g. {-# INLINE [1] foo #-}
20:30:11 <dons> delays inlining of foo till after phase 1
20:30:21 <dons> so it might be a candidate for rule matching in phase 0
20:30:28 <emk> On the treeFoldr, I presume?
20:30:29 <dons> now, if its inlined too early, then the rules won't spot it
20:30:39 <dons> so anything you want to match in a rule , has to be inlined-delayed
20:30:49 <dons> and anything you want to expose to matching, needs to be inlined as soon as possible
20:31:11 <dons> so you have a custom fusion rule for treefoldr ?
20:31:31 <dons> then I would think:   {-# INLINE treeSum #-} -- immediately
20:31:37 <dons> but {-# INLINE [1] treeFoldr #-}
20:31:47 <dons> delay till treeFoldr rule has a chnance to match
20:32:00 <dons> use -ddump-simpl-iters to watch the inining and fusion happening
20:32:25 <dons> (even better if you install HsColour and : ghc -O Foo.hs -ddump-simpl | HsColour -tty | less -r
20:32:33 <dons> (since then you might actually be able to read the Core :)
20:32:39 * emk tries INLINE [1]
20:33:10 <dons> so yeah, anything you want to match on the lhs of a rule has to have inlining delayed on it
20:33:34 * dons lives by the rules
20:33:48 <SamB> the RULES! yes, the RULES!
20:34:37 <dons> ok. I think I've almost caught C with the nbody benchmark now.
20:34:41 <dons> so that's all of them!
20:34:57 <heatsink> awesome.
20:35:05 <dons> hopefully we should be no more than 3x slower than the best entry, for any benchmark after this
20:35:27 <dons> yeah, just under 3x C for nbody
20:35:36 <dons> currently we're 15x under C
20:35:41 <dons> yay!
20:35:50 * sorear applauds
20:35:53 <chessguy> ?hoogle minimum
20:35:54 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
20:35:54 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
20:35:54 <lambdabot> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
20:36:05 <sorear> gah. isn't Directory h98?
20:36:06 <dons> i've spent the last 4 hours tuning asm output though... :)
20:36:22 <sorear> it is *gulp*
20:36:33 * dons sez: numerics in ghc aren't so bad after all
20:36:38 * sorear is futily trying to convince yhc to bootstrap
20:36:45 <emk> dons: Ah, also: Get rid of -prof.
20:37:03 <dons> heh
20:37:09 <dons> yeah, -prof will mess up things nicely
20:37:16 <sorear> yhc doesn't even have Directory
20:38:01 <sorear> it does have System.Directory!
20:38:31 <allbery_b> yhc doesn't believe in the utmoded H98 stuff? :)
20:38:32 <emk> dons: Two rewrite rules drop a simple test program from 15.0 to 4.6 seconds by eliminating two intermediate trees.
20:39:11 <sorear> allbery_b: funny, since yhc *uses* directory
20:39:13 <dons> we have the technology!
20:39:31 <sorear> they weren't kidding when they said yhc requires GHC to build
20:39:37 <dons> emk, its cool that people are starting to use rewrite rules for custom algebraic transforms in user code
20:39:59 <emk> dons: I'm just messing around at the moment.
20:40:02 * sorear wonders how much of the Simplifier can be moved out into the Prelude
20:40:15 <sorear> then jhc can have it too!
20:40:18 <emk> If it works, I might write a short tutorial...
20:40:47 <dons> yeah, that'd be nice.
20:40:54 <dons> note there's also a wiki page on using rules
20:41:03 <chessguy> > 2 /= 3
20:41:04 <lambdabot>  True
20:41:48 <emk> dons: Cool!
20:42:00 <sorear> gah
20:42:06 <sorear> now Yhc wants MTL
20:42:15 <sorear> somehow I doubt that's written in H98
20:42:27 <emk> dons: I'm impressed by the optimization potential of the rewrite rules.
20:42:29 <SamB> sorear: no, it uses fundeps at the moment
20:43:06 <emk> It's a really compelling demonstration of why equational reasoning is worth the price...
20:43:08 <allbery_b> and MPTC and a few undecidable instances
20:43:27 <SamB> allbery_b: well fundeps imply MPTC
20:43:30 * allbery_b has been poking at MTL source of late
20:43:52 <SamB> you can't have functional dependencies between typeclass arguments if you don't have multiple typeclass arguments!
20:44:01 <dons> emk, yeah. that's right. if you don't have purity, you can forget these tricks
20:44:05 <dons> and they can do so so much
20:44:12 <allbery_b> heh
20:44:18 * allbery_b still weak on fundeps
20:44:36 <dons> emk, you'll still want to use QuickCheck to verify the rewrite rules are correct though
20:44:40 <newsham> is there a syntax to bind from a subset of record items?
20:44:47 <dons> its easy for nasty bugs to slip in if your rule is wrong in a corner case
20:44:58 <dons> so the rule can be directly expressed as a QC property
20:45:00 <sorear> like foldr/build and seq?
20:45:02 * sorear hides
20:45:21 <dons> rule "foo" a b . x a b = y b c   becomes a QC property:   prop_foo a b = x a b == y b c
20:45:34 <dons> when compiled with -fno-rules of course, to prevent the rhs being rewritten to the lhs
20:45:47 <dons> foldr/build and seq is a rare, hard issue to produce
20:46:03 <dons> since you have to fuse a lazy consumer (like head) iwht a strict producer
20:46:11 <dons> and there's no strict producers in the base library
20:46:21 <dons> and QC won't generate them either , without special help
20:46:43 <dons> so i know of only one case where the foldr/build issue failed in real life, and that was wit bytestring unpack fusing with lazy head
20:46:47 <emk> dons: Now that I have a toy example running, I'll feel comfortable using rewrite rules in production code.
20:47:02 <dons> yeah, that's reasonable
20:47:41 <emk> With the really far out features, I need to get them working on toy examples before using them in anger.
20:48:14 <dons> yeah
20:48:37 * sorear is meticulously demtling yhc
20:48:52 * emk used QuickCheck to generate benchmarking data, walked the tree once to make everything exist, and then benchmarked once either way
20:49:12 <brad__> hi
20:49:13 <LoganCapaldo> newsham: like case point of Point { x = a } -> _do something with a_ ?
20:49:16 <brad__> a question
20:49:34 <brad__> how do i transform ["a","b","c"] to [("a",0),(
20:49:49 <brad__> how do i transform ["a","b","c"] to [("a",0),("b",1),("c",2)]
20:49:56 <LoganCapaldo> (assuming data Point Point { x :: Int, y :: Int }
20:50:15 <heatsink> brad__: Do you have a function to make the number from the character?
20:50:16 <newsham> logan: yah.  like if Point had 20 members, but you only want to select 2 of them
20:50:17 <dons> > zip ["a","b","c"] [0..]
20:50:19 <lambdabot>  [("a",0),("b",1),("c",2)]
20:50:31 <brad__> ah, thanks dons!!!
20:50:34 <emk> dons: Many thanks, as always!
20:50:37 <LoganCapaldo> > zipWith (,) ["a", "b", "c"] [0..]
20:50:38 <newsham> func (Point x _) = ....
20:50:38 <lambdabot>  [("a",0),("b",1),("c",2)]
20:50:42 <dons> no worries!
20:50:48 <newsham> but by name instead of by position
20:50:54 * LoganCapaldo is too slow
20:51:04 <LoganCapaldo> newsham: yeah
20:51:06 <brad__> thanks to you also Logan!
20:51:06 <LoganCapaldo> that woks
20:51:08 <LoganCapaldo> *works
20:51:16 <newsham> func (Point {x=x}) = ....
20:51:19 <newsham> something like that
20:51:41 <LoganCapaldo> Yeah
20:51:46 <hyrax42> newsham: that works as is
20:51:46 <sorear> yhc: Error: File not found, Control.Exception
20:51:51 <sorear> I give up :)
20:51:52 <LoganCapaldo> Its not something like that it is that
20:52:07 <brad__> by the way, is there something in haskell that can be done with Data.Map to make it support multiple levels of keys? i am sort of stuck on the $hash{'a'}{'b'} = ... functionality of perl
20:52:33 <sorear> why use multiple levels of keys when you can key on tuples?
20:52:33 <hyrax42> brad__: tuple keys is not what you want?
20:52:34 <allbery_b> use a tuple?
20:52:42 <hyrax42> haha
20:52:45 <LoganCapaldo> brad__: You make a Data.Map whose values are themselves Data.Map
20:52:48 <newsham> ok, cool.
20:52:49 <LoganCapaldo> or yeah use a tuple
20:52:50 <LoganCapaldo> silly me
20:52:58 <sorear> tupling is Generally Better
20:52:58 <emu> use tupleware
20:53:01 <brad__> three people have suggested tuples, perhaps a small trivial example?
20:53:16 <emu> Data.Map (Int,Int) Char
20:53:27 <brad__> ah
20:53:29 <brad__> i see
20:53:35 <LoganCapaldo> instead of $hash{'a'}{'b'} do $hash{'a', 'b'}
20:53:45 <brad__> i can make the key to Data.Map a tuple?
20:53:53 <dons> yeah
20:53:54 <emu> anything that is Ord can be a key
20:53:56 <hyrax42> > M.lookup (1,'a') $ M.fromList [((1,'a'), "test")]
20:53:57 <lambdabot>   add an instance declaration for (Show (m [Char]))
20:54:00 <brad__> VERY INTERESTING!
20:54:01 <bd_> brad__: Sure. You can use a list too, if it's more convenient.
20:54:03 <allbery_b> the key can be anything, unlike perl where it has to stringify ssanely
20:54:16 <hyrax42> > M.lookup (1,'a') $ M.fromList [((1,'a'), "test")] :: Maybe String
20:54:18 <lambdabot>  Just "test"
20:54:20 <brad__> you learn something new everytime you visit this forum
20:54:21 <allbery_b> (so e.g. you can't use perl objects as keys)
20:54:26 <dons> > M.fromList $ zip (zip "haskell" [0..]) [1..]
20:54:28 <lambdabot>  {('a',1):=2,('e',4):=5,('h',0):=1,('k',3):=4,('l',5):=6,('l',6):=7,('s',2):=3}
20:54:30 <emu> i think i have a map here which is keying on equivalence classes
20:54:33 <bd_> brad__: in fact, string keys are a special case of list keys :)
20:54:54 <newsham> hmm.. I thought ghc was supposed to come with HGL on win32....
20:54:58 <brad__> by the way, has anyone read hutton's "programming haskell"? i got mine in the mail today
20:55:05 <hyrax42> emu: so you have to get the representitive before doing stuff?
20:55:09 <LoganCapaldo> s/a special case/an instance of/ no?
20:55:10 <dons> i've browsed a copy
20:55:13 <dons> seems like a good intro book
20:55:15 <hyrax42> brad__: I've read the first 5 chapters in the preview
20:55:25 <hyrax42> starts off very well
20:55:29 <LoganCapaldo> it doesn't actually do anything special for strings rght?
20:55:30 <dons> you won't find much on stream fusion or GADTs in there though ;)
20:55:30 <emu> hyrax42: the equivalence class is a set of all the congruent elements
20:55:37 <emu> Map (Set ...) ...
20:55:39 <brad__> yes it seems pretty basic
20:55:47 <hyrax42> emu: isn't that really really slow ?
20:55:47 <brad__> was expecting a bit more...oh well, work paid for it
20:56:15 <emu> idc ;) the whole damn thing is transplanted almost literally from a formal textbook description
20:56:40 <hyrax42> brad__: I amthinking of buying it just to see how well it does things later one
20:56:57 <newsham> ?where hgl
20:56:58 <lambdabot> http://haskell.org/graphics/index.html
20:57:18 <chessguy> @pl heapify (place x left)
20:57:19 <lambdabot> heapify (place x left)
20:57:20 <emu> a nested Map might be better if you want to take slices out
20:57:27 <chessguy> @pl \x -> heapify (place x left)
20:57:28 <lambdabot> heapify . flip place left
20:57:41 <chessguy> @pl \x -> heapify (place left x)
20:57:42 <lambdabot> heapify . place left
20:57:43 <LoganCapaldo> @type x
20:57:45 <lambdabot> Not in scope: `x'
20:57:54 <LoganCapaldo> lol
20:57:59 <LoganCapaldo> silly me
20:58:13 * LoganCapaldo thought someone had defined an x operator)
20:58:33 * allbery_b doesn't think operators can be letters
20:58:42 <allbery_b> punctuaion, yes
20:58:45 * SamB `x` allbery_b
20:58:45 * LoganCapaldo thinks allbery_b is correct
20:58:52 <LoganCapaldo> hence its even worse :)
20:59:04 <allbery_b> right, `x`, but that's because of the ``
20:59:46 <emu> try >< for \times ;)
21:00:06 <LoganCapaldo> @type flip . flip
21:00:07 * SamB â allbery_b
21:00:07 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
21:01:27 <LoganCapaldo> let ff = flip . flip ; g x y = x - y in id g == ff g
21:01:39 <LoganCapaldo> > let ff = flip . flip ; g x y = x - y in id g == ff g
21:01:40 <lambdabot>   add an instance declaration for (Eq (c -> c -> c))
21:01:40 <lambdabot>     In the definition of...
21:01:44 <dons> ?bug
21:01:44 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:01:51 <newsham> anyone here familiar with HGL?
21:02:04 <SamB> how do you do a "del" symbol in LaTeX?
21:03:08 <allbery_b> \nabla IIRC
21:03:56 <SamB> âallbery_b
21:04:03 <SamB> yeah, that works
21:04:13 <brad__> thanks for the help! bye bye
21:05:55 <newsham> I installed HGL (soe) 2.0.5, and its not working...  I dont see Graphics.HGL or Graphics.SOE libs
21:06:09 <newsham> ghc-pkg -list shows soegtk
21:06:47 <SamB> newsham: well, why don't you "locate SOE"
21:06:52 <newsham> whats that?
21:07:17 <newsham> do you mean the unix command "locate"?
21:07:25 <SamB> yeah
21:07:40 <newsham> because this is win32, and also i'm not sure how that would help me..  i know where it installed (/Program Files/)
21:07:52 <newsham> but when I :module +Graphics.HGL I get nothing
21:08:08 <SamB> browse until you find an .hi file with SOE in the name?
21:09:22 <newsham> is there a way to query in ghci what is in a package?
21:09:51 <newsham> (btw, the deoms and tests that come with SOE arent cooperating with "runhaskell" either)
21:09:52 <SamB> package? maybe with :!
21:09:57 <chessguy> !paste
21:09:57 <hpaste> Haskell paste bin: http://hpaste.org/
21:09:59 <SamB> module? sure.
21:10:40 <hpaste>  chessguy pasted "Surely there's a better way to do this..." at http://hpaste.org/428
21:10:46 <allbery_b> :browse
21:11:45 <bd_> chessguy, how will that represent a heap of zero elements?
21:11:56 <newsham> ahh!  gtk-pkg describe soegtk
21:12:01 <newsham> says expoed-modules.
21:12:23 <chessguy> as it is now, it won't, but it wouldn't be hard to change that
21:14:46 <chessguy> can heapify be simplified?
21:18:04 <bd_> chessguy: Do you really need to order the two branches of the heap?
21:18:37 <chessguy> bd_, i'm not sure what you mean
21:19:13 <bd_> ... never mind, I was reading the code wrong. Excuse me while I go off in the corner and be embarassed for a bit
21:19:39 <chessguy> well, it's hideous code, which is why it needs to be simplified :)
21:28:25 <newsham> ?type lift
21:28:27 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:29:20 <newsham> if I have a lifting type function that turns a (Turtle a) into an (IO a)  what is its type?
21:29:38 <newsham> I'm getting:  Couldn't match expected type `()' against inferred type `a' (a rigid variable)
21:29:50 <newsham> when I do   foo :: Turtle a -> IO a
21:30:49 <allbery_b> @paste
21:30:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:30:55 <LoganCapaldo> ?type liftM
21:30:56 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:32:46 <LoganCapaldo> @hoogle (Monad m1, Monad m2) => m1 a -> m2 a
21:32:47 <lambdabot> Did you mean: (Monad m1, Monad m2) => M1 a -> M2 a
21:32:47 <lambdabot> Prelude.id :: a -> a
21:32:47 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:33:25 <allbery_b> @ty liftIO
21:33:27 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
21:34:03 <newsham> crap, this thing didnt even come with the gtk/gdk dlls!
21:34:09 <LoganCapaldo> @ty flip liftIO
21:34:11 <lambdabot> forall a b. (MonadIO ((->) b)) => b -> IO a -> a
21:34:15 <newsham> whats the forall bit do?
21:34:40 <LoganCapaldo> It's a universal qualifier.
21:35:07 <newsham> yah, but....
21:35:11 <chessguy> ?type length
21:35:12 <lambdabot> forall a. [a] -> Int
21:35:25 <chessguy> newsham, means it's true for any type a
21:35:27 <newsham> I can do   length :: [a] -> Int    no?
21:35:32 <newsham> *sigh*
21:35:49 <allbery_b> foralls are usually implicit
21:35:52 <LoganCapaldo> yes
21:35:54 <chessguy> the forall just makes it explicit
21:35:55 <newsham> I am not trying to be obtuse, but if you think this is answering my question, its not. :\
21:36:02 <LoganCapaldo> but lambdabot is verbose :)
21:36:27 <newsham> I still have not a clue why   foo :: Turtle a -> IO a   is giving me an error
21:36:33 <LoganCapaldo> which one, the forall or the Turtle to IO?
21:36:38 <allbery_b> you could paste your code
21:36:50 <LoganCapaldo> well whats the definition of Turtle?
21:36:53 <newsham> ?paste
21:36:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:36:58 <allbery_b> is Turtle a monad or a value constructor?
21:37:08 <LoganCapaldo> I don;t think theres a generic function to do m a -> IO a
21:37:24 <allbery_b> er, simple type constructor
21:37:31 <allbery_b> no, you can't do that in the general case
21:37:34 <allbery_b> consider ST
21:38:01 <allbery_b> (where you can do it, via unsafeSTtoIO)
21:38:05 <hpaste>  newsham pasted "lifting, type error." at http://hpaste.org/429
21:39:25 <newsham> .. not that i think it matters at this point..  this install of SOE is worthless :(
21:40:18 <sorear> back
21:40:27 <chessguy> can i have a where block inside of a guard
21:40:40 <sorear> no
21:40:42 <allbery_b> your problem is that act is tmain which returns Turtle () regardless of the input
21:40:42 <chessguy> like foo x | x == 3 = t where t = ...
21:40:46 <sorear> where blocks are global
21:41:00 <sorear> foo x | x == 3 = t | otherwize = bar where t = ...
21:41:03 <sorear> will work
21:41:06 <newsham> chess: you have "let" still
21:41:13 <sorear> provided you define "otherwize" :)
21:41:43 <chessguy> so i can do foo x | x == 3 = let t = ... in t
21:41:56 <sorear> yes
21:42:07 <sorear> or just move the "where" after all the guards
21:42:24 <chessguy> i don't think i want to do that
21:42:26 <chessguy> in this case
21:42:37 <newsham> logan: any ideas on the types in the paste?
21:42:50 <allbery_b> hm, maybe not
21:43:27 <newsham> allberry: whats wrong with it returning Turtle () ?
21:43:44 <allbery_b> aha
21:43:55 <allbery_b> noo, the problem is that runGraphics is defined to return IO ()
21:44:08 <newsham> oh.
21:44:11 <newsham> I see.
21:44:24 <newsham> makes sense.
21:44:34 <allbery_b> so Turtle a -> IO ()
21:44:36 <newsham> thanks, allbery.
21:45:13 <newsham> now I can start over again because this !@%!@$# HGL/SOE package doesnt work.
21:45:36 <newsham> why are SOE and HGL docs in the gtk haskell heir lib docs if they dont ship with ghc and dont work?
21:47:06 <hpaste>  chessguy annotated "Surely there's a better way to do this..." with "possible improvement?" at http://hpaste.org/428#a1
21:47:18 <newsham> oh, hrmm.. soegtk came from gtk2hs not from HGL/SOE (which providednothign I guess).
21:47:23 <newsham> ok, well the fix is easier then..
21:49:48 <chessguy> is that better? worse?
21:50:09 <newsham> better, its more recent at least.
21:50:14 <newsham> and people onthis channel know about it.
21:50:26 <chessguy> newsham, i meant my annotation :)
21:54:32 <newsham> sorry
21:55:23 <chessguy> ?type minimum
21:55:25 <lambdabot> forall a. (Ord a) => [a] -> a
21:56:15 <LoganCapaldo> > minimum []
21:56:16 <lambdabot>  Add a type signature
21:56:31 <LoganCapaldo> > minimum [] :: [Int]
21:56:32 <lambdabot>  Exception: Prelude.minimum: empty list
21:57:00 <chessguy> ?hoogle MonadState
21:57:01 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
21:57:09 <chessguy> ?src MonadState
21:57:10 <lambdabot> Source not found. My pet ferret can type better than you!
21:57:30 <allbery_b> @source Control.Monad.State
21:57:31 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
21:57:44 <newsham> ahh!  it works fine when I compile, but if i run in runhaskell it doesnt
21:58:10 * allbery_b seems to recall some magic is needed to run gui stuff from ghci, including runhaskell
21:58:19 <allbery_b> on windows
21:58:25 <LoganCapaldo> > let min [] = error "empty list"; min (x:xs) = foldr (\x y -> if x < y then x else y) x xs in min [3,2,7]
21:58:27 <chessguy> ?src Ord
21:58:27 <lambdabot>  2
21:58:27 <lambdabot> class  (Eq a) => Ord a  where
21:58:27 <lambdabot>     compare      :: a -> a -> Ordering
21:58:27 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
21:58:27 <lambdabot>     max, min         :: a -> a -> a
21:58:37 <sorear> emacs gurus: How do I tell C-x C-f to ignore *.hi ?
21:59:30 <allbery_b> add it to completion-ignored-extensions
21:59:35 <sorear> ty
21:59:54 <newsham> anyone familiar with gtk2hs awake?
22:00:03 <sorear> very vaguely
22:00:24 <chessguy> i want to impose an ordering on Foo a, given that a is a member of Ord. is this right? instance (Ord a) => Ord (Foo a) where ...
22:00:24 <newsham> if I use the SOE stff in Gtk2Hs do I still have to call the gtk mainloop?
22:00:43 <sorear> not enough guruage, sorry
22:00:51 <sorear> chessguy: yes.
22:01:16 <chessguy> and then i have to define all the functions given above?
22:01:31 <sorear> chessguy: no, just compare
22:01:39 <sorear> the others have default impls
22:01:41 <LoganCapaldo> chessguy: just compare will suffice
22:01:59 <chessguy> how can you tell the others have default implementations?
22:02:12 <sorear> @src (<)
22:02:13 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
22:02:18 <sorear> @src max
22:02:19 <lambdabot> max x y = if x <= y then y else x
22:02:23 <LoganCapaldo> If it compiles w/o them? <g>
22:02:28 <sorear> aparently @src knows :)
22:02:31 <sorear> @src compare
22:02:32 <lambdabot> compare x y | x == y    = EQ
22:02:32 <lambdabot>             | x <= y    = LT
22:02:32 <lambdabot>             | otherwise = GT
22:02:44 <sorear> so if you def <= and ==, you don't need compare
22:02:48 <LoganCapaldo> I love that
22:02:49 <allbery_b> you can provide either compare or (<=)
22:03:01 <LoganCapaldo> the recursive defaults blow my mind
22:03:04 <allbery_b> (and (==) since Eq a is a prerequisite for Ord a
22:03:06 <allbery_b> )
22:03:21 <chessguy> i don't like compare because then you don't get the notion of <= or >= any more
22:03:30 <sorear> you don't?
22:03:45 <allbery_b> if you have compare then (<=) and (>=) will be defined in terms of it
22:04:18 <chessguy> oh ok
22:04:26 <allbery_b> if you have (<=) then compare is defined in terms of it, then the others from compare
22:05:24 <SamB> unfortunately (==) cannot be :-(
22:05:43 <sorear> whine whine whine.
22:05:44 <sorear> :)
22:05:55 <sorear> @users
22:05:56 <lambdabot> Maximum users seen in #haskell: 322, currently: 277 (86.0%), active: 26 (9.4%)
22:06:07 * allbery_b hands out cheeze to go with the whine :)
22:06:19 <chessguy> ?src minimum
22:06:19 <lambdabot> minimum [] = undefined
22:06:20 <lambdabot> minimum xs = foldl1 min xs
22:06:26 <LoganCapaldo> let a == b = a > b || a < b ;)
22:06:27 <chessguy> ?src min
22:06:28 <lambdabot> min x y = if x <= y then x else y
22:06:56 <LoganCapaldo> err
22:07:02 <allbery_b> logancapaldo: problem is, class (Eq a) => Ord a where ...
22:07:04 <LoganCapaldo> throw in a not
22:07:27 <LoganCapaldo> class (Ord a) => Eq a where ...
22:07:31 <LoganCapaldo> bwahahahahah
22:07:43 <SamB> bwahahaha indeed ;-)
22:07:47 <LoganCapaldo> -fallow-insanely-overlapping-instances
22:07:59 * allbery_b watches the world collapse
22:07:59 <SamB> except that means you can't have instances of Eq but not of Ord
22:08:36 <Cale> -fallow-quite-simply-ridiculous-instances
22:08:38 <LoganCapaldo> No you jsut have two defs of Eq,
22:08:45 <chessguy> ?type compare
22:08:46 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
22:09:02 <LoganCapaldo> class Eq q where and class (Ord a) => Eq a
22:09:38 <LoganCapaldo> So then you can define == and <= or > and <
22:09:45 <LoganCapaldo> and get Ord AND Eq
22:09:50 <LoganCapaldo> or jsut define == and get Eq
22:10:01 <LoganCapaldo> its brilliant!
22:10:32 <chessguy> @pl \x y -> compare (f x) (f y)
22:10:33 <lambdabot> (. f) . compare . f
22:10:35 <LoganCapaldo> ;)
22:11:06 <LoganCapaldo> @type compareBy
22:11:07 <lambdabot> Not in scope: `compareBy'
22:11:12 <LoganCapaldo> @type comparing
22:11:13 <allbery_b> in 6.6 that's comparing
22:11:14 <lambdabot> Not in scope: `comparing'
22:11:18 <bd_> lambdabot is on 6.5 :)
22:11:25 <bd_> until dons fixes hs-plugins :)
22:11:38 <allbery_b> I thought it was fixed
22:11:38 <chessguy> so why won't this work?
22:11:38 <chessguy> instance (Ord a) => (Foo a) where
22:11:38 <chessguy>     compare x y = compare (value x) (value y)
22:11:56 <chessguy> value :: Foo a -> a
22:12:29 <sm-afk> evening all
22:12:43 * sorear waves
22:12:44 <allbery_b> what error do you get?
22:13:05 <allbery_b> ...also, why not just deriving(Eq, Ord)?
22:13:25 <chessguy> 'compare' is not a (visible) method of class `Foo`
22:13:34 <sm> how do I split a list on each occurence of an element ?
22:13:47 <chessguy> mm, i doubt it can derive it
22:13:55 <allbery_b> oh.  instance Ord a => Ord (Foo a) where ?
22:14:22 <sorear> you don't :(
22:14:25 <chessguy> oh, sheesh
22:14:47 <newsham> ?type foldM
22:14:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:15:02 <newsham> ?type foldM_
22:15:04 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
22:15:06 <sorear> sm: find SMarlow and coerce him by any means necessary to find and flip the nearest coin
22:15:22 <sorear> that way, you'll get *a* standard split
22:15:28 <sm> oh dear :)
22:15:42 <sorear> now we have 0 standards and aleph-three proposals
22:16:17 <sorear> maybe I'm exaggerating the cardinality of the set of proposals *slightly*...
22:16:27 <dons> sorear: so how does yi perform with the new vty?
22:16:29 <dons> usable yet?
22:16:34 <sorear> dons: badly?
22:16:45 <dons> you've not tested it/
22:16:47 <dons> ?
22:17:06 <sorear> dons: vty is rather slow, and GHC's inliner has made it impossible to find the (now anonymous) inner loop :(
22:17:18 <dons> {-# NOINLINE inner_loop #-} ?
22:17:19 <chessguy> you guys like answering questions with questions? :)
22:17:19 <sorear> even the TEST PROGRAM is cpu bound!
22:17:32 <chessguy> @quote test
22:17:33 <lambdabot> Lemmih says: dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
22:17:39 <sm> oh dear, dear
22:17:51 <sm> I can't even see how to implement this easily
22:17:52 <sorear> anyway dons: 2GHZ P4, yi's scrolling is limited more by CPU than autorepeat
22:17:53 <dons> if you want me to take a peek, can you post a url for the repo, and a test program that needs to run faster?
22:18:15 <kaspyanan1> i am going through YAHT tutorial
22:18:28 <kaspyanan1> following is defined-
22:18:30 <kaspyanan1> findElement :: (a -> Bool) -> [a] -> Maybe a
22:18:30 <kaspyanan1> findElement p [] = Nothing
22:18:30 <kaspyanan1> findElement p (x:xs) =
22:18:30 <kaspyanan1> if p x then Just x
22:18:31 <kaspyanan1> else findElement p xs
22:18:38 <kaspyanan1> how to call findElement
22:18:43 <sorear> also, jyp's rendering code is rapidly becoming a bottleneck, now that vty is marginally faster
22:18:44 <dons> yeah  that's the 'find' functoin
22:18:45 <newsham> ?type iter
22:18:47 <lambdabot> Not in scope: `iter'
22:18:49 <newsham> ?type iterate
22:18:51 <lambdabot> forall a. (a -> a) -> a -> [a]
22:19:02 <dons> kaspyanan1: something like :  findElement (=='e') ['a','b','c','d','e']
22:19:13 <dons> kaspyanan1: in ghci, or hugs, after loading that definition from a file
22:19:14 <kaspyanan1> ok dons thks
22:19:45 <hpaste>  chessguy annotated "Surely there's a better way to do this..." with "Better yet...(am I cheating?)" at http://hpaste.org/428#a2
22:20:34 <kaspyanan1> ok i got the result..but I get Just 6(as per Maybe datatype declaration),but i want only 6..how?
22:20:50 <sorear> wtf?
22:21:00 <chessguy> @type fromJust
22:21:02 <lambdabot> forall a. Maybe a -> a
22:21:15 <sorear>  6498 stefan    15   0  3512 1680  780 S  0.0  0.4   0:00.18 Test
22:21:16 <allbery_b> @ty fromMaybe
22:21:18 <lambdabot> forall a. a -> Maybe a -> a
22:21:31 <sorear> it was pulling 40+ seconds yesterday
22:21:34 <allbery_b> fromMaybe defaultValue (findElement ...)
22:21:43 <sorear> my code has gotten much faster for no good reason
22:22:06 <sorear> *much* faster
22:22:10 <sorear> like >100x
22:22:34 <nornagon> cool.
22:22:46 * sorear tries to reproduce sloth
22:23:24 <chessguy> the fair goddess Haskella has smiled upon you today
22:23:27 <allbery_b> or:  case findElement ... of (Just x) -> doSomethingWith x; Nothing -> throwAnErrorOrSomething
22:23:32 <kaspyanan1> where should I write from Maybe in the function
22:23:56 <sorear> gah
22:24:01 <kaspyanan1> ok
22:24:06 <sorear> how do I tell GHC where my headers are
22:24:07 <sorear> ?
22:24:22 <sorear> the C backend has forced me to use -optc-I/tmp/vty
22:24:36 <dons> -i/tmp/vty
22:24:39 <dons> iirc
22:24:53 <sorear> double bah
22:25:04 <sorear> it can't find the C symbols for Data.Map ...
22:25:13 <sorear> yes I'm using --make
22:25:23 <dons> sorear: re. the speedup, maybe you triggered a full recompilation
22:25:31 <dons> i.e. more cross module inlining
22:25:33 <sorear> find . -name '*.hi' -delete fixed it ...
22:25:45 <sorear> dons: fresh build yes ...
22:25:55 <sorear> that could make a difference? *gulp*
22:26:06 <sorear> I thought partial builds were always correct!
22:27:01 <sorear> so GHC does whole program optimization if you delete the objects first?
22:27:17 <sorear> same uber-fast behaviour with GHC-6.6
22:28:11 <sorear> well, if you'd like to comment on my profiling-fingered loop anyway
22:28:29 <sorear> http://members.cox.net/stefanor/vty/Graphics/Vty.hs, last function
22:36:29 * chessguy sighs
22:36:38 <chessguy> i should know by not not to underestimate haskell
22:36:49 <sorear> ?
22:36:52 <kaspyanan1> in prelude i load a file.hs,ghci takes me to Main prompt,i make some changes to hs file how to reload?
22:37:02 <sorear> OK, who wrote hscolor?
22:37:03 <dons> sorear: the 'diffs' function?
22:37:06 <dons> malcolm
22:37:14 <sorear> ... and his nick?
22:37:15 <dons> sorear: any reason not to use bang-patterns on diffs?
22:37:21 <dons> its malcolm or malcolmw
22:37:27 <allbery_b> kaspyanan1: :reload, or juust :r (or even just :)
22:37:28 <sorear> @seen malcolm
22:37:29 <lambdabot> I saw malcolm leaving #haskell, #haskell-blah and #ghc 12h 33m 10s ago, and .
22:37:31 <sorear> @seen malcolmw
22:37:32 <lambdabot> I haven't seen malcolmw.
22:37:43 <sorear> malcolm++ nice
22:37:47 <dons> no reason not to use guards or if-then-else for Bool tests (if they're clearer)
22:37:52 <dons> e.g. case (ola /= nwa || olc /= nwc)
22:38:00 <dons> what's that Core come out as?
22:38:15 <sorear> case is more compatible with emacs autoindentification :)
22:38:21 <dons> heh
22:38:42 <sorear> emacs keeps me consistent.  is there a set of rules for manual haskell indent anywhere?
22:38:50 <hpaste>  chessguy annotated "Surely there's a better way to do this..." with "still shrinking..." at http://hpaste.org/428#a3
22:39:02 <allbery_b> @where report
22:39:03 <lambdabot> http://www.haskell.org/onlinereport/
22:39:03 <allbery_b> :)
22:39:55 <kaspyanan1> pls provide me link for emacs for windows
22:39:56 * allbery_b half tempted to propose a splitBy for ghc6.7
22:39:58 <sorear> dons: anyway, I don't think I'm using *any* extensions beyond FFI and hierarichal modules now
22:40:45 <sorear> allbery_b: be bold!  augustss disregarded discussion and just sent a patch, and as a result we have the bikeshad "IsString"
22:40:47 <allbery_b> splitBy :: (a -> Bool) -> [a] -> [[a]]
22:41:09 <chessguy> ?type splitBy
22:41:11 <lambdabot> Not in scope: `splitBy'
22:41:13 <dons> hehe
22:41:16 <chessguy> ?hoogle split
22:41:16 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
22:41:17 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
22:41:17 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
22:41:17 <allbery_b> doesn''t currently exist
22:41:28 <dons> yeah, there's a lot to be said for just diong something.
22:41:30 <chessguy> ?type groupBy
22:41:31 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
22:41:40 <chessguy> hmm, not quite
22:41:41 <dons> if you write the code, then you already have 2/3 the discussion won
22:42:00 <allbery_b> afaik there is no standard one, someone popped in looking for one *again* earlier thiso evening
22:42:13 <hpaste>  sm pasted "splitAtElement based on words" at http://hpaste.org/430
22:42:34 <sorear> allbery_b: write it! we will be eternally greatful!
22:42:48 <flux-> hm, I believe the java-haskells aren't quite good yet (I haven't tried, just listened ;)), but maybe this can fill the need: http://labs.businessobjects.com/cal/
22:42:50 <lambdabot> Title: The Open Quark Framework for Java and the CAL Language
22:42:55 <nornagon> splitBy (== 0) [1,2,3,0,4,5,6] == [[1,2,3],[4,5,6]]+
22:42:57 <nornagon> ?
22:42:58 <flux-> I guess it's old news here?
22:42:58 * sorear pledges 10 ++
22:44:55 <hpaste>  allbery_b pasted "probably not optimal, but a good start" at http://hpaste.org/431
22:45:41 <allbery_b> it's not hard, I think I've consed that thing up 6-7 times already
22:45:57 <allbery_b> ...wich in itself is proof it should probably exist :)
22:46:19 <sorear> bah, accumulating parameter
22:46:27 <sorear> allbery_b: your splitBy isn't lazy
22:46:40 <jz87> hey I have a question regarding circular definitions in type
22:46:44 <allbery_b> yeh
22:47:05 * allbery_b probably ought be in bed, shouldbookmark and come back when brain works
22:47:23 <jz87> I'm reading through the paper on modular interpreters and monadic transformers
22:47:30 <jz87> and I'm trying to code along in Haskell
22:47:55 <sm> sorear: is mine ?
22:48:37 <jz87> but I'm stuck at this point where ther are 2 circular definitions
22:48:48 <jz87> type Value = Either Int (Either Fun ())
22:48:58 <jz87> type Fun = interpM Value -> interpM Value
22:49:53 <jz87> GHC won't compile this complaining that this is a circular type definition
22:49:54 <hpaste>  sorear annotated "probably not optimal, but a good start" with "my first take" at http://hpaste.org/431#a1
22:50:35 <jz87> can anyone help me out?
22:50:35 <sorear> jz87: types must be non-circular, they're macros
22:50:45 <sorear> jz87: you want newtype here
22:50:56 <sorear> jz87: I imagine you hail from ML-land?
22:51:07 <jz87> lisp
22:51:09 <mauke> newtype Fun = Fun { call :: interpM Value -> interpM Value }
22:51:17 <mauke> AFAIK you need the same trick in OCaml
22:51:18 <sorear> jz87: data (with built in con/dis/junction) is more idiomatic here
22:51:24 <jz87> the static typing is boggling my mind
22:51:38 <sorear> data Value = IV Int | FV Fun | ZV
22:51:53 <sorear> data Fun = Fun (InterpM Value -> InterpM Value)
22:52:08 <jz87> but the thing is should I use data if there is only 1 type of value
22:52:13 <sorear> also, if InterpM is a monad, you *probably* want:
22:52:17 <sorear> data Fun = Fun (Value -> InterpM Value)
22:52:23 <jz87> I thought data is more used when there are several possible constructors
22:52:31 <mauke> jz87: or when there's recursion
22:52:31 <sorear> jz87: yes, if you think of the types as distinct.
22:52:39 <jz87> ah
22:52:49 <mauke> "type" is just an abbreviation
22:52:50 <sorear> data is very cheap
22:53:25 <sorear> type is a macro - recursive types if not caught by GHC (don't worry they always are) would give infinite programs
22:53:31 <mauke> you could use data for everything, but the constant (un)wrapping might be annoying
22:53:33 <jz87> let me try using data then
22:53:42 <jz87> yeah, that's the main reason I didn't use data
22:53:49 <jz87> the unwrapping creates a lot more typing
22:53:52 <jz87> and clutters it up
22:54:09 <jz87> what exactly is the difference between type and newtype
22:54:09 <mauke> data Wrap a = Wrap { unwrap :: a }
22:54:14 <jz87> I could never figure that out
22:54:24 <mauke> newtype is like data except it only supports a single constructor
22:54:46 <jz87> ah
22:54:49 <mauke> (unwrap (Wrap x) == x)
22:54:50 <jz87> that seems to be what I need
22:55:10 <jz87> single constructor recursive type
22:55:48 <jz87> is the following definition legal?
22:55:54 <chessguy> i found this example helpful w.r.t. type versus newtype:
22:55:54 <chessguy> http://www.haskell.org/haskellwiki/Non-trivial_type_synonyms
22:55:56 <lambdabot> Title: Non-trivial type synonyms - HaskellWiki
22:56:01 <jz87> newtype Fun = (InterpM Value -> InterpM Value)
22:56:04 <sorear> newtype has slightly different behaivor wrt _|_ too
22:56:07 <sorear> jz87: no
22:56:11 <mauke> jz87: no, missing constructor name
22:56:22 <sorear> newtype Fun = Fun { unFun :: (InterpM Value -> InterpM Value) }
22:56:36 <jz87> newtype needs a constructor name?
22:56:43 <mauke> yes
22:56:50 <mauke> it's pretty much like data
22:56:55 <jz87> ok
22:57:00 <mauke> s/unFun/call/ :-)
23:05:05 <jz87> how do I create a new monad class?
23:05:14 <sorear> blah blah blah
23:05:22 <sorear> instance Monad MyType where
23:05:36 <sorear>     a >>= f = something appropriate
23:05:41 <jz87> I'm trying to create a MonadTransformer called EnvT
23:05:42 <sorear>     return x = something appropriate
23:05:53 <jz87> that adds a variable binding list
23:06:06 <sorear> jz87: like ReaderT (Map String Value) ?
23:06:08 <mauke> sounds like a Reader
23:06:12 <jz87> hmm
23:06:19 <jz87> let me read up on that
23:06:21 <sorear> @unmtl ReaderT (Map String Value) IO a
23:06:22 <lambdabot> Map String Value -> IO a
23:06:35 <sorear> look like what you want?
23:06:48 <jz87> yeah
23:07:06 <jz87> the State monad didn't look right
23:07:10 <jz87> but yeah, this is what I need
23:07:23 <sorear> I think the MTL has done newbies a great disservice.  there's virtually no excuse for writing your own monad anymore.
23:07:26 <jz87> where is the source code for this stuff?
23:07:34 <sorear> @source Control.Monad.Reader
23:07:35 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
23:08:31 <jz87> well much of the mtl library was inspired by the monad transformer paper I'm reading right now
23:08:53 <jz87> so I've been trying to replicate their code (they wrote it in Gopher and the paper doesn't come with full source code)
23:09:27 <sorear> yeah, back then Gofer had a lot of extensions over Haskell
23:09:38 <sorear> GHC has mostly caught up since then
23:10:07 <sorear> you see the {-# OPTIONS_GHC -fenable-arcane-extensions #-} pragma at the top of Reader :)
23:10:52 <DannoHung> People should stop calling things "arcane" and just call them "wizard"
23:11:00 <jz87> I need to learn more about this stuff
23:11:10 <DannoHung> -fenable-wizard-extensions  or "sorcerors" or "voodoo-shaman-arts"
23:11:13 <jz87> I'm thinking of writing a tutorial for other people like myself
23:11:16 <jz87> cause this stuff is pretty hard
23:11:25 <jz87> or at least not terribly accessible to newbies
23:11:25 <Gwern> is "fold-map fusion" the same thing as "map fusion"?
23:11:32 <sorear> Gwern: no
23:11:43 <sorear> Gwern: map fusion: map f . map g ==> map (f . g)
23:11:52 <Gwern> ah. that's it?
23:12:02 <sorear> Gwern: fold/map fusion: foldr f z . map g ==> foldr (f . g) z
23:12:29 <Gwern> sorear: ok, thanks. a blog mentioned map fusion and I was having a terrible time figuring out what it is, since google is swamped with useless results
23:12:54 <sorear> Gwern: syntaxfree's massed brain explosions?
23:12:58 <Gwern> sorear: ayuh
23:13:21 * Gwern is going to add that to Wikipedia now, so at least one can easily find out what it means *somewhere*
23:13:34 <sorear> he's a regular here, if you wan't he'll be happy to rant at you about the glory of Haskell
23:13:52 <Gwern> sorear: I think I'm probably convinced already :)
23:14:12 <jz87> question: I'm seeing a lot of
23:14:29 <jz87> newtype T a = T { function :: type }
23:14:31 <jz87> patterns
23:14:46 <sorear> yes
23:14:47 <jz87> this seems to be some sort of ideom
23:14:50 <sorear> yes
23:14:54 <jz87> what exactly does it do?
23:14:57 <sorear> it's a type level lambda
23:15:04 <jz87> lambda?
23:15:07 <sorear> it creates a function T from types to types
23:15:12 <jz87> a is a lambda type?
23:15:13 <dons> it defines a new type, and a deconstructor, that has the same runtime representation as an existing data type
23:15:28 <dons> but its treated as a new type in the compiler. Monads are usually written as newtypes
23:16:02 <sorear> wrt the :: part, that's just an easy way of getting a deconstructor
23:16:08 <jz87> normally I write things like Constructor Type1 Type2
23:16:13 <sorear> it's an abuse of record syntax
23:16:17 <jz87> what does the {  } do to make it different?
23:16:26 <sorear> record syntax
23:16:27 <dons> ah right, yes. that's record syntax
23:16:32 <jz87> ah, so it means the constructor takes 1 record
23:16:32 <dons> the fields can be accessed with the label names
23:16:37 <jz87> type as the parameter?
23:16:41 <sorear> jz87: no
23:16:44 <dons> e.g. data T = T { val :: Int }
23:16:49 <sorear> jz87: records are not first class yet :(
23:16:53 <dons> then val x wil extract the 'val' field of value x
23:17:14 <sorear> jz87: it means the constructor takes named rather than positional arguments (optionally)
23:17:15 <jz87> ah ok
23:17:24 <jz87> this makes much more sense now
23:17:32 <sorear> good
23:17:37 <sorear> we like hearing that
23:17:39 <sorear> :)
23:19:39 <Gwern> another question: maps are examples of catamorphisms, right?
23:19:51 <sorear> yes
23:20:05 <sorear> maps are both cata and ana
23:20:18 <sorear> map f = foldr ((:) . f) []
23:20:30 <Gwern> good, then I didn't misunderstand. I like when that doesn't happen
23:21:03 <sorear> map f = unfoldr (\ls -> case ls of (x:xs) -> Just (f x, xs) ; [] -> Nothing)
23:25:10 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/turtle/
23:25:12 <lambdabot> Title: Directory /~newsham/x/machine/turtle/
23:25:14 <newsham> yay, it works
23:25:49 <lispy> http://en.literateprograms.org/Quicksort_(Haskell)
23:25:51 <lambdabot> Title: Quicksort (Haskell - LiteratePrograms
23:26:00 <lispy> have you guys seen this literateprograms.org before?
23:27:20 <sorear> dons: question.  should I release vty 3.0 now that the interface is abstract and (I hope) stable, or should I wait to tune it to death first?
23:27:36 <lispy> sorear: early and often
23:28:20 <sorear> lispy: here in Haskell-Land it seems "release" means "bother everyone on haskell@haskell.org".  If I am mistaken, I'd like to know. :(
23:28:24 <lispy> http://en.literateprograms.org/Markov_algorithm_simulator_%28Haskell%29 <-- very nice, i've been looking for something like this so we can write a megamonad in pure haskell
23:28:28 <lambdabot> Title: Markov algorithm simulator (Haskell) - LiteratePrograms, http://tinyurl.com/2dhk9b
23:29:00 <lispy> sorear: for me, it could mean one of several things, including pushing the latest to a darcs repo and talking about it here with the people that care
23:29:17 <lispy> sorear: otoh, there are many reasons to do an official, versioned release
23:29:35 <lispy> sorear: i'm not sure what you should do :)
23:29:44 <kaspyanan1> hi i am going through yaht tutorial and exercise 4.6 and 4.7..i understood 4.6,but not 4.7 in which fromTuple (One a ) = Left (Left a ) and fromTuple (Two a b ) = Left (Right (a,b) ) function r written..why use Either type..cant i just say fromTuple (Two a b )=(a,b)
23:30:07 <dons> sorear: tune it!
23:30:13 <dons> make sure it runs yi fast enough
23:30:30 <sorear> dons: now it doesn't run yi at all
23:30:31 <lispy> oh, maybe the markov algorithm is different than hidden markov models :(
23:31:09 <sorear> major version bump means I broke all the programs that assumed [[(Char, Attr-as-a-record-of-bools)]] :)
23:32:47 <sorear> stefan@stefans:~/vty$ ./Setup.lhs record -a -w "bump version ; update compile options"
23:33:12 <lispy> setup.lhs has a record feature?
23:33:16 <lispy> what does it do?
23:33:29 <sorear> lispy: this: Setup.lhs: Unrecognised command: record (try --help)
23:33:42 <lispy> heh
23:33:57 <lispy> i assume you meant darcs record?
23:34:04 <lispy> typo?
23:34:13 <sorear> yeh :)
23:35:28 <lispy> ah well, just as long as you're not doing thinkos
23:35:33 <lispy> those can get you
23:36:43 <sorear> like rm -r vty in the wrong directory :)
23:37:05 <sorear> fortunately that was itself a thinko, of the short term memory read error variety
23:45:30 <gotaku> Anyone know of some good screen video capture software for linux?
23:45:40 <magnus_> Hello... I'm wondering if there is a way to enable recursive do notation in ghc
23:46:21 <magnus_> so that you can write things like do { x <- f y; y <- g x; return x }
23:46:39 <sorear> magnus_: mdo?
23:46:47 <magnus_> yes, mdo
23:46:52 <sorear> mdo { x <-  f y ; y <- g z ; return x }
23:47:05 <sorear> -fglasgow-exts maybe?
23:47:16 <magnus_> aha, I guess I'm missing -fglasgow-exts.. duh
23:47:44 <magnus_> yes, it works now
23:47:52 <magnus_> :)
23:51:47 <dons> sorear: my point was not to release till you've tested yi against it
23:52:11 <sorear> okay
23:52:37 <dons> since its very important to test aginst its use in practice
