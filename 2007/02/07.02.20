00:08:50 <abz> Cheery: hey
00:09:25 <Cheery> Hi abz
00:09:57 <abz> Cheery: last night your were laughing a "Software done right" and we used javascript....well I re-did the site using a real language, i.e. Haskell (WASH)
00:10:50 <Cheery> WASH?
00:11:05 <abz> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
00:11:07 <lambdabot> Title: Web Authoring System Haskell (WASH)
00:12:38 <Cheery> abz: so, now WASH generates your javascript and html?
00:13:11 <abz> thats correct, but I didn't have to write any javascript or html, WASH does the lot
00:13:19 <Cheery> that's nice.
00:14:00 <abz> I've got a site coming out at the end of this month that is about 4k lines of haskelldb, wash and a little ajax...
00:14:09 <Cheery> maybe I should remember the WASH, next time when I'm thinking about doing web software for nowadays browsers.
00:15:19 <abz> I'm going to bed. night.
00:15:28 <Cheery> good night.
00:41:51 * lispy should be in bed
00:43:48 <fuzan> you could solve all your problems by bringing a laptop to bed.
00:44:56 <osfameron> how true
00:45:30 <lispy> fuzan: i'm trying to break taht habbit actually...
00:46:19 <fuzan> lispy: you could always start sleeping at your desk then.
00:46:32 <fuzan> get a nice lounge chair :)
00:46:37 <fuzan> works all the time for me in my classes.
00:47:24 <fuzan> scope in tcl is retarded.
00:48:03 <pjd> but never boring
00:50:39 <Cheery> I should buy a laptop, then I could bring my hobby anywhere with me.
00:50:54 <fuzan> Cheery: it's worth it :)
00:51:02 <osfameron> they are addictive
00:53:38 <matthew-_> they are also incredibly bad for your posture and, if you suffer from it, rsi
00:54:24 <fuzan> and typing for 8+ hours a day isn't good for your fingers, either.
00:54:29 <Cheery> matthew-_: especially in bed, I suppose. ;)
00:54:29 <matthew-_> yup
00:55:38 <Cheery> There's also an another choice which could be at some point better than laptop.
00:56:06 <matthew-_> mindreading?
00:56:19 <Cheery> you have seen that guy who did plans for hand-held keyboard?
00:56:26 <Cheery> and you know the gumstix -thing?
00:56:28 <matthew-_> oh - the chordic stuff?
00:56:31 <matthew-_> yeah
00:56:32 <Cheery> ye.
00:56:49 <matthew-_> I think that takes *loads* of training though to get up to anything like sane speeds
00:56:52 <fuzan> i want ipv6 ;@
00:57:08 <matthew-_> not sure if there's a linux driver for it either
00:57:17 <Cheery> yet one would require oled heads-up display and here you'd have a computer which is always with you.
00:57:55 <fuzan> that's flagrant nerdism and more than likely is also no good for your health.
00:58:14 <fuzan> at one point in or another in our life we must at least attempt to attract members of the opposite sex.
00:58:41 <kzm> ..and what can be more attractive than a shiny, new laptop? :-)
00:58:48 <matthew-_> rotfl
00:59:14 * araujo still waits to meet the first haskeller girl
00:59:14 <kzm> Hey baby, wanna peek under the lid?
00:59:20 <araujo> on person, that's it
00:59:29 <matthew-_> have you seen my monadic combinator?
00:59:43 <kzm> no unwanted side effects, I bet?
00:59:49 <matthew-_> *nudge* *nudge*; *wink* *wink*
00:59:50 <lokasam> that's so dirty lol
00:59:53 <fuzan> of course not, i'm type safe!
00:59:58 <lokasam> lmao
01:00:05 <Cheery> araujo: maybe in next life
01:00:22 <lokasam> maybe in parrallel life?
01:00:31 <araujo> Cheery, why everybody says that always?
01:00:39 <osfameron> there are some Perl girls
01:00:45 <araujo> i mean, it isn't like an impossible thing
01:00:48 <osfameron> we have one that comes to the florence perlmongers meetings
01:00:48 <matthew-_> they're not safe though
01:00:54 <fuzan> how materialistic of them :\
01:01:05 <fuzan> have you told them about ruby yet?
01:01:14 <Cheery> araujo: there's two schools about that thing.
01:01:15 <osfameron> actually, she doesn't program perl as such, but she comes to the meetings and wants to get a "Chicks dig Perl" t-shirt
01:01:32 <araujo> haha
01:01:47 <araujo> I only will marry with a haskeller girl
01:02:04 <matthew-_> araujo: you'll be lonely for some time I suspect ;)
01:02:14 <araujo> hah
01:02:14 <fuzan> I'm still working on converting my wife :)
01:02:33 <matthew-_> that's more the direction to go - I'm trying the same
01:02:50 <lokasam> araujo: no worries. Everything is possible :)
01:03:12 <lokasam> and is as probable as you believe it to be.
01:03:50 * araujo wants something like "<me> Hi, how you doing? ; <girl> Trying to write some comonads .. and you? ... <me> wow, marry me"
01:04:04 <fuzan> araujo: perhaps you should read some nicholas sparks.
01:04:22 <matthew-_> @remember araujo/#haskell wants something like "<me> Hi, how you doing? ; <girl> Trying to write some comonads .. and you? ... <me> wow, marry me"
01:04:22 <lambdabot> Done.
01:04:27 <araujo> haha
01:04:28 <araujo> ouch
01:04:32 <araujo> :-)
01:04:56 <lokasam> :)
01:05:00 * araujo always forgets this channel is kind of dangerous
01:05:16 <Cheery> Maybe we should take over the world and make Haskell a basic school subject, lets replace geometry or some else math subject with it.
01:05:18 <lokasam> ?
01:05:25 <Cheery> then we'd probably end up having some haskeller girls.
01:05:46 <araujo> hah
01:05:59 <matthew-_> replace chemistry please
01:06:07 <fuzan> we could always influence governments to throw out some "it's cool for girls to program" propoganda
01:06:28 <osfameron> we could pay for adverts as a community effort
01:06:46 <matthew-_> mmm. a manifesto pledge "If elected, we will seek to significantly increase the number of competant female Haskellers"
01:06:50 <matthew-_> that'd go down well
01:07:15 <osfameron> matthew-_: better would be "competent, HOT, female Haskellers"
01:07:30 <matthew-_> ...through a eugenics programme?
01:07:31 <fuzan> how shallow of you!
01:07:44 <osfameron> ;-)
01:08:08 <fuzan> what a horrible reason to perform eugenics, haha.
01:08:19 <fuzan> breed hot female haskellers.
01:08:32 <Cheery> we'd need robots or something, that'd be probably the easiest way to get hot female haskellers.
01:09:00 * matthew-_ is surprised at the general level of desperation in #haskell for hot female haskellers
01:09:08 <fuzan> i can't convice a single fellow student of mine to even play with haskell :'(
01:09:28 <kzm> Yeah.  Although I bet a lot of them would like to play with females.  Sigh.
01:09:29 <matthew-_> get them drunk first
01:09:40 <fuzan> i'm honestly in no desire of one; however,  it is an interesting topic :)
01:10:06 <fuzan> the sad fact is that most haskellers probably spend more time thinking about programming than the ladies :)
01:10:18 <fuzan> let me see if i can find a relevant xkcd comic.
01:10:43 <fuzan> http://xkcd.com/c69.html
01:10:44 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:10:53 <sieni> fuzan: I don't!
01:11:18 <matthew-_> is spj married?
01:11:47 <sendark> the best xkcd comic is the one about the ninja turtles vs renaissance artist
01:11:54 <sieni> what do you mean? spj is married to all hot women on this planet!
01:12:03 <sieni> we clearly need an spj facts site
01:12:11 <araujo> hahahaha
01:12:30 <fuzan> heh, it is pretty good :)
01:12:41 <matthew-_> "I now pronounce you man >>= wife"
01:13:02 <fuzan> oh, woot.
01:13:07 <fuzan> http://xkcd.com/c196.html
01:13:07 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:13:17 <fuzan> another relevant example :)
01:13:43 <osfameron> heh
01:13:56 <sendark> "Make me a sandwich", "what? make it yourself!", "sudo make me a sandwich", "oh, ok then..."
01:14:20 <matthew-_> there's just a whole class of humor windoze users are missing out on...
01:14:25 <pjd> mathrick: that's rather biased! :)
01:14:38 <quicksilver> spj facts? Stuff like "There is no theory of evolution, just a list of animals SPJ allows to live" ?
01:14:43 <matthew-_> ;-)
01:15:06 <pjd> s/mathrick/matthew-_/
01:15:12 <osfameron> spj strikes me as being rather more benevolent than Norris
01:15:21 <matthew-_> pjd: but I don't think do {man >>= woman; woman >>= man} would typecheck
01:15:22 <pjd> quicksilver: ISAGN
01:15:38 <matthew-_> wouldn't it be the same problem as (\x.xx)(\x.xx) ?
01:15:52 <pjd> mattam: obviously, the relationship is dyadic, not monadic
01:15:58 <matthew-_> ahh
01:16:07 <araujo> haha
01:16:09 <matthew-_> and what is wrong with your tab completion of nicks?!
01:16:18 <pjd> blame xchat
01:16:20 <araujo> fuzan, those are nice comics
01:16:27 <araujo> Probably sad for some of us though :-)
01:16:30 <pjd> i don't know how to fix it
01:16:34 <fuzan> araujo: i advise you to read all of them, great comics :)
01:16:43 <sendark> kinda obscure comics tho
01:16:46 <osfameron> you just wait till he starts mentioning haskell. You will see it posted to every haskell RSS feed and sent to every mailing list
01:16:49 <sendark> most mortals wont get them
01:16:59 <osfameron> every time there is one mentioning Perl, the community goes into spasms
01:17:10 <matthew-_> sendark: whereas all immortals will get them?
01:17:28 <matthew-_> surely the perl community regularly spasms
01:17:34 <sendark> :D
01:18:32 <sendark> hey do u guys know how to go away on irssi?
01:18:44 <kc5tja>  /away
01:18:52 <kc5tja> As in:
01:18:59 <sendark> yep
01:19:03 <kc5tja>  /away off to bed.
01:19:10 <sendark> and how o you get back?
01:19:19 <kc5tja>  Just use: /away  <-- no parameter
01:19:25 <sendark> cool
01:19:42 * kc5tja personally doesn't use it though.
01:19:51 <kc5tja> But, with that in mind, I'm off to bed.  :)
01:20:04 * kc5tja just finished getting SCons to auto-configure for the project I'm working on.
01:20:10 <fuzan> http://xkcd.com/c205.html
01:20:10 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:20:23 * sendark is gotta go to lectures
01:20:29 <fuzan> lol... i've missed a bunch of the newer ones. this one made me laugh :)
01:21:11 <sendark> later, inmortals!
01:31:30 <araujo> @hoogle Char -> Bool
01:31:31 <lambdabot> Char.isAlpha :: Char -> Bool
01:31:31 <lambdabot> Char.isAlphaNum :: Char -> Bool
01:31:31 <lambdabot> Char.isAscii :: Char -> Bool
01:45:31 * quicksilver fumes quietly
01:45:37 <quicksilver> "I wanted to learn Haskell a while ago, but I found that the syntax is unreadable and kind of gave up."
01:45:55 <quicksilver> Then you're extremely stupid. Please pursue a fulfilling career in the rapid catering service industry
01:46:47 <sieni> quicksilver: fortunately there's liskell as well <3
01:47:20 <matthew-_> tell them the syntax for x86 assembler is much simpler so they should write exclusively in that
01:47:44 <quicksilver> sieni: by syntax they almost certainly mean 'lack of syntax'
01:47:50 <quicksilver> sieni: so I imagine they'd find liskell to be worse :)
01:50:47 <matthew-_> the rapid catering service industry could probably make use of programmers
01:52:46 <osfameron> quicksilver: it's not a particularly enlightening comment. But there is definitely a cognitive impedence mismatch between haskell and what many jobbing programmers are used to
01:52:47 <sieni> rapid catering service industry :-D
01:53:14 <osfameron> quicksilver: I'm finding haskell very hard to read.  Unlike anonyposter, I'm pushing on with it (slowly) but I think the sentiment is valid
01:53:18 <quicksilver> osfameron: yes, well I'm not being terribly reasoned, just ranting :)
01:53:34 <osfameron> heh
01:53:37 <quicksilver> the point, IMO, is that it's not hard, because it's hard. It's hard, because it's different.
01:53:43 <hpaste>  Cheery pasted "state machine. help?" at http://hpaste.org/565
01:53:49 <quicksilver> reading C programs the first time is very hard too.
01:53:55 <osfameron> quicksilver: yeah
01:54:07 <Cheery> quicksilver: reading C programs are always hard.
01:54:11 <osfameron> I find Ruby hard to read despite a) fanboys saying how easy it is, and b) knowing Perl well
01:54:29 <osfameron> but I'm sure Ruby isn't *Actually* hard, it's just syntax I ahven't got head around yet
01:54:29 <sieni> osfameron: what part of  (\ l -> (\ ag -> ((\ x d e h -> (x >= e) && (d h)) >>= \ q -> l >>= \ p -> return (q p)) (fst ag)) >>= \ al -> snd >>= \ ak -> return (al ak)) don't you understand?!?!?!
01:54:35 <osfameron> sieni: :-)
01:54:43 <matthew-_> but a hard C program is hard to read because it assumes so much about hardware, whereas a hard haskell program is hard due to the typesystem constraints. imho
01:54:59 <osfameron> of course that's badly obfuscated haskell in that it doesn't have sensible function and variable names or indentation
01:55:48 <matthew-_> plus you used >>= where you meant >> ;-)
01:56:13 <Cheery> haskell type system is interesting.
01:56:38 <osfameron> the haskell type system rocks, you can tell that even from the first few chapters of a tutorial
01:56:47 <osfameron> I can't make it do anything useful yet, but it definitely rocks
01:56:55 <quicksilver> hmm well it's pointless to argue about ugly programs
01:57:03 <quicksilver> clearly I can write an ugly program in any language
01:57:06 <quicksilver> (ACME::Bleach ?)
01:57:16 <quicksilver> the point is to argue about well written, idiomatic programs
01:57:16 <Cheery> it is helpful because it allows you to context things, therefore reducing the possibility for error.
01:57:23 <quicksilver> how hard is it to read a *good* haskell program vs a *good* C program
01:57:53 <Cheery> quicksilver: been there, done that.
01:58:05 <fuzan> the root of the problem is that most programmers have learned coding via imperative languages
01:58:07 <pjd> quicksilver: i can second osfameron;  i also find Haskell's syntax hard to acquire
01:58:19 <Cheery> I think plan9 gives a good idea about a good C program.
01:58:28 <pjd> there's lots of implicity
01:58:30 <fuzan> even though a problem is so much naturally defined (most of hte time) in a functional language, most people opt for what they know
01:58:36 <quicksilver> pjd: hmm, explain that
01:58:48 <quicksilver> I would have said haskell's syntax was more explicit than Perl, for example
01:58:50 <pjd> quicksilver: compared to something like Scheme or Python
01:59:10 <araujo> pjd, Haskell syntax is easy. We barely have a syntax.
01:59:16 <quicksilver> I think haskell's syntax is very similar to Scheme. Just a different arrangement of brackets.
01:59:16 <pjd> *anything* is more explicit than Perl :)
01:59:47 <pjd> arasinen: there's a lot more syntax than in Scheme
01:59:50 <quicksilver> there was one thing I found hard to get used to about haskell's syntax, which was 'juxtaposition' having the highest precedence
01:59:57 <quicksilver> apart from that, I didn't have trouble
01:59:58 <pjd> i'm not saying this is bad;  it's wonderful
02:00:02 <quicksilver> but I came from an ocaml background
02:00:09 <Cheery> I wonder whether haskell even should be typed, just pure lambda calculus and context wrappings. :)
02:00:09 <pjd> i just takes time to absorb, like most good things
02:00:18 <araujo> pjd, The syntax is very easy to follow. That's important.
02:00:21 <Cheery> like:
02:00:30 <pjd> araujo: once you know it, it's easy to follow
02:00:48 <araujo> pjd, and you cn know it very fast!
02:00:56 <Cheery> you'd have Num -context, but instead Num would be a structured type, it'd be a pattern&rules&functions for combinators.
02:00:58 <araujo> More than other langs.
02:01:16 <Cheery> *instead that
02:01:23 <pjd> araujo: not more than Scheme/Python, by some measure
02:01:36 <araujo> pjd, i bet i can show two definitions doing the same (something simple) on scheme and haskell to some non-programmer ; and the haskell example will be understood faster.
02:02:03 <araujo> function definitions*
02:02:19 <pjd> araujo: toy expressions don't count; they don't involve most of the language's syntax :)
02:02:20 <araujo> sum n = n + n
02:02:22 <araujo> :-)
02:02:42 <araujo> pjd, Well, a complex one. scheme functions can get very messy
02:02:45 <osfameron> good libraries will convince people
02:02:53 <araujo> In which case, i don't understand your point then
02:02:56 <quicksilver> pjd: at the risk of patronising you (which I don't want to) I don't think you mean 'syntax'
02:02:59 <osfameron> what about a function to animate a bouncing ball, that sort of thing ?
02:03:04 <araujo> You can write a very complex funcion using schme or python
02:03:06 <Cheery> ie. Num would be an algebraic definition of calculus, ie. language instead of type.
02:03:07 <osfameron> still simple, but more of a "real" example
02:03:07 <pjd> quicksilver: i very much mean exactly syntax
02:03:07 <araujo> Very obfuscated
02:03:35 <araujo> The idea is to show _HOW_ simple , a definition can be on each lang. In which case, i think Haskell will beat most of the langs.
02:03:38 <quicksilver> pjd: haskell has fewer syntactical rules than almost any other language; something like scheme would be the only thing to have fewer
02:03:45 <araujo> Including scheme and python.
02:04:12 <Botje> you forgot brainfuck>
02:04:27 <araujo> That too :-)
02:04:32 <encryptio> unlambda > brainfuck
02:04:34 <osfameron> araujo: syntax doesn't mean fuck without good libraries
02:04:41 <Cheery> quicksilver: what's one benefit in haskell is that there's little of syntactical rules which are unique, ie. can't be properly expressed in terms of other rules in language.
02:04:46 <araujo> osfameron, ?
02:05:06 <osfameron> araujo: if you want to show a scheme aexample and a haskell example, show one that showcases the libraries involved
02:05:08 <Cheery> those are in minimal.
02:05:10 <osfameron> graphics/IO/web etc.
02:05:35 <araujo> osfameron, no need. And i still think .. Haskell will win btw.
02:05:36 <osfameron> all the syntax in the world isn't more useful than the ability to get real stuff done
02:05:50 <araujo> A language syntax got nothing to do with libraries available.
02:05:53 <Cheery> osfameron: true! :)
02:06:02 <araujo> Libraries are built upon this syntax.
02:06:17 <osfameron> (and I'm not saying that haskell is weak in this, I don't know.  Just that to some extent the syntax doesn't actually matter as much as we think)
02:06:30 <araujo> Not the opposite. (it looks so in some cases.)
02:06:52 <osfameron> araujo: sure!  so the hypothesis would be that haskell enables great libraries.  fantastic!  That's what a Scheme vs Haskell library comparison could usefully showcase
02:06:54 <quicksilver> osfameron: whilst you have a good point, it may be tangential to our discussion
02:07:01 <quicksilver> osfameron: we *were* talking about syntax, after all :)
02:07:02 <araujo> And i still don't get what you mean. I think Haskell will beat scheme or some lisp language family too. Since these languages syntax are very variable.
02:07:09 <osfameron> quicksilver: ok :-)  fair enough.  I'll pipe down
02:07:22 <araujo> Instead the Haskell syntax keeps being very simple and concise through the different libs available.
02:07:37 <Cheery> oh well, did anyone seen this? (11:51:48) hpaste:  Cheery pasted "state machine. help?" at http://hpaste.org/565
02:07:42 <araujo> osfameron, oh :-)
02:07:54 * araujo got a bit confused
02:08:18 <pjd> araujo: it depends;  a lot of the things that are macros in Scheme are higher-order functions/combinators in Haskell
02:08:28 <Cheery> I'd at least need to know how I can make sure that there's no duplicates in result of step.
02:08:30 <pjd> the definition of "syntax" can get a bit gray
02:08:53 <araujo> pjd, i know ... that's why i am just proposing 'simple' examples.
02:08:55 <quicksilver> "First thing is that I'd want no duplicates of Transitions into one step -result." <-- I can't parse this sentence
02:09:26 <osfameron> yeah.  I understood from hudak's book that Lists for example aren't actually defined in haskell - they're part of the library, and they just fall out of the type system.  (I might have misundertood this point though)
02:09:29 <Cheery> quicksilver, like [s1,s1,s3,s4,s2]
02:09:37 <pjd> araujo: are you talking about simple example or libraries, now? :)
02:09:45 <pjd> "library showcases", even
02:09:45 <Cheery> would be instead: [s1,s3,s4,s2]
02:09:55 <encryptio> Cheery: nub
02:09:58 <encryptio> i think
02:09:58 <araujo> pjd, ive always talked about simple syntax examples ....
02:10:00 <quicksilver> Cheery: your states don't have identities, though
02:10:09 <quicksilver> Cheery: they are just variable names :)
02:10:11 <araujo> pjd, sum n =  + n
02:10:14 <araujo> :-)
02:10:17 <quicksilver> Cheery: doesn't the state need a name, too?
02:10:27 <araujo> now compare that with, (define (sum n) (+ n n))
02:10:45 <pjd> araujo: you were just talking about Haskell syntax being  simple and concise through different libraries
02:10:50 <Cheery> quicksilver: hmm, maybe.
02:10:58 <araujo> pjd, Because of osfameron comments
02:11:11 <araujo> But i am talking to _you_ , about simple syntax
02:11:17 <osfameron> (yeah, sorry for muddying the waters)
02:11:30 <pjd> right, and my point is that if you consider how Scheme macros correspond to HOFs, then the syntax is actually about the same
02:11:31 <araujo> osfameron, it's fine, you bring an interesting point too
02:11:37 <araujo> erh, brought
02:11:43 <pjd> (syntax complexity across libraries, etc.)
02:11:51 <pjd> aaanyway
02:12:07 <araujo> forget macros. I just want to show a line of code to a non programmer
02:12:17 <araujo> For her/him to deduce what it does
02:12:29 <Cheery> quicksilver: how could I assign unique identities for each state?
02:12:33 <fuzan> good luck teaching a non programmer type inference :)
02:12:36 <quicksilver> Cheery: give them a name?
02:12:54 <encryptio> fuzan: in a lot of cases, good luck teaching a programmer about type inference >.>
02:12:55 <quicksilver> fuzan: good luck teaching a non programmer static types (as in C, Java, etc)?
02:13:12 <quicksilver> fuzan: at least haskell doesn't force you to type what the compiler can trivially infer :)
02:13:24 <fuzan> it's for the sake of the majority.
02:13:45 <fuzan> and that's why functional programming will probably never be as popular as its little sister.
02:13:59 <pjd> fuzan: it's just a matter of time
02:14:04 <fuzan> but at least our cool features get integrated :)
02:14:10 <pjd> the lambda revolution is inevitable
02:14:21 <fuzan> c# 3.0, python, even ruby now!
02:14:29 <encryptio> some of them
02:14:29 <osfameron> and Perl6 and javascript :-)
02:14:34 <Cheery> quicksilver: can I do it somehow so that I could get unique identifiers for each Transition without typing them in explicitly?
02:14:36 <osfameron> and VB
02:14:57 <xerox> ?docs Data.Unique
02:14:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Unique.html
02:15:09 <quicksilver> Cheery: you could, yes. You could define each transition by a function call which assigns it a number
02:15:23 <quicksilver> Cheery: you could then encapsulate that notion inside a unique supply monad
02:15:23 <psnl> is there a good gtk2hs widget for showing haskell source?
02:15:32 <quicksilver> Cheery: I don't have time to talk you through it though, I'm afraid :)
02:15:41 <encryptio> i'm trying to teach a perl programmer i tutor about haskell... unfortunately it's about as easy as making a useful function of type a -> b
02:15:44 * araujo thinks functional programming will be the next boom (after OO)
02:15:46 <xerox> psnl: yes.
02:15:55 <dcoutts> psnl, the SourceView widget does Haskell syntax highlighting
02:16:01 <xerox> That :)
02:16:10 <Cheery> quicksilver: no problem, I like to go on my own when I know where to go. ;)
02:16:19 <osfameron> encryptio: have you tried Shlomi Fish's http://www.shlomifish.org/lecture/Perl/Haskell/ ?
02:16:21 <lambdabot> Title: Haskell for Perl Programmers
02:16:29 <osfameron> actutally... I should probably look at that again myself...
02:16:43 <psnl> dcoutts: yey, I don't have to roll my own
02:16:43 <Cheery> what you have done now is actually everything I could have hoped for.
02:16:44 <encryptio> dude! i so needed that when i started
02:16:52 <araujo> dcoutts!
02:16:53 <psnl> dcoutts: I'm guessing I'll see you tomorrow?
02:16:58 <pjd> encryptio: unlambda < lazy k :)
02:17:00 <dcoutts> psnl, yep
02:17:15 <osfameron> encryptio: actually it looks like it's just a set of examples... but presumably tailored to perl programmers.  It's not much good for self study, but it might be useful to you as a tutor
02:22:28 <Syzygy-> ?hoogle when
02:22:29 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
02:22:29 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
02:28:19 <psnl> dcoutts: second silly question: can you use sourceview and glade at the same time?
02:28:55 <dcoutts> psnl, yes.
02:29:29 <dcoutts> psnl, though you can't construct sourceview widgets via glade, but just leave a place holder and add it in manually.
02:29:31 * dcoutts -> office
02:30:15 <pejo> araujo, lets not split them - fp with OO!
02:30:50 <siti> umm OO sucks :p
02:31:32 * osfameron actually like OO :-)  I'm sure there are nice hybrid OO/FP approaches
02:31:45 <siti> I think ocaml has fused the two
02:32:05 <siti> but I think someone said almost no one uses the object functionality
02:32:25 <pejo> siti, O'caml fused impurity too while at it.
02:32:29 <pjd> generic function-based OO!
02:33:07 <siti> why do you like OO and think it's better than good functional code :p?
02:33:16 <osfameron> I like to write functional OO Perl... I'm working on a set of transformations between data-sheet objects for example
02:33:31 <siti> you can do everything OO can do with extensiel types
02:33:33 <pejo> siti, who said I thought it was better? Why should I not have subtyping in my functional language?
02:33:53 <pejo> siti, you can do anything you can do in fp in asm.
02:34:03 <siti> lol
02:34:12 <osfameron> siti: didn't say it was better.  But for example, with the datasheet thing, I can have objects calling ->head() and ->body() instead of having to remember where in the data structure they're storing everything.  That might be nicer in haskell of course, dunno.
02:34:24 * araujo considers that OO came out from FP
02:34:46 <araujo> has anyone here used Eiffel?
02:35:33 <DmC_> slm
02:35:38 <siti> well you have a nice class system (note this is not OO) which can make what you are descrbing
02:35:51 <araujo> Ive been reading a bit about it lately; and i am quite of impressed of the similarities with some Haskell ideas.
02:37:21 <siti> well I have been doing OO for a few years now, and from my about 6 months with haskell I have to say it's so much nicer :)
02:37:23 <pjd> siti: well, people mean ten thousand things when they say "OO"
02:37:33 <siti> yeah true
02:37:54 <pjd> actor-based OO is a completely different ballgame than FP, for example
02:38:04 <osfameron> I have a vague idea that haskell might be a good language to write a web-based collaborative spreadsheet in
02:38:11 <Patty01> what is actor-based OO?
02:38:19 <quicksilver> well in the real world, there are problems, and there are solutions
02:38:27 <araujo> siti, by far ... i think that FP being the next boom ; will be partially of that OO evolution.
02:38:27 <quicksilver> you can do 'actor type stuff' in haskell
02:38:35 <quicksilver> and you do it slightly differently from the way you'd do it in C++
02:38:43 <pjd> Patty01: http://en.wikipedia.org/wiki/Actor_model
02:38:45 <araujo> Which i think it is kind of ironic ; since OO came out from FP.
02:38:46 <quicksilver> but the approximate shape of the solution would be rather similar
02:38:50 <Patty01> thanks
02:38:57 <pjd> think message-passing
02:39:20 <osfameron> sounds very erlangy
02:39:50 <siti> yep
02:39:50 <pjd> also, there is prototype-style OO
02:39:57 <pjd> which is different again
02:40:00 <pejo> Would anyone care to summarize the difference between the "actor model" and what's possible to express in a simple process calculus?
02:40:11 <quicksilver> pejo: summary: nothing
02:40:24 <quicksilver> pejo: the details differ :)
02:40:30 <pjd> pejo: one is an instance of the other?
02:40:36 <quicksilver> simple process calculi don't tend to name stuff
02:40:47 <quicksilver> real programming models tend to have names and identity all over the place
02:41:11 <pjd> pejo: ah, there's a convenient article: http://en.wikipedia.org/wiki/Actor_model_and_process_calculi
02:41:12 <quicksilver> (but, yes, I'm aware that there are process calculi which let you name various bits and bobs)
02:41:13 <lambdabot> Title: Actor model and process calculi - Wikipedia, the free encyclopedia
02:41:29 <siti> my summary of OO is that it is not much of an improvement over procedural.  It's just that the new languages that are OO also include garbage collection, big standard libraries etc...
02:41:39 <siti> it's been a big bit a hype
02:42:14 <pjd> siti: if you're talking about Java style common-denominator OO :)
02:42:38 <pejo> siti, so you've never even once thought "Darn, I'd like to extend this record/data type with a subtype" in Haskell?
02:42:46 <quicksilver> siti: I think that's harsh
02:43:00 <careo> I think the improvement in OO in most "new" OO langauges isn't as great as it could be. but the imrovment in, say, Smalltalk is
02:43:01 <quicksilver> siti: abstractions like dynamic dispatch are genuinely useful
02:43:06 <siti> pejo: oh I see what you mean now...
02:43:25 <pjd> careo: and CLOS, Dylan, Self...
02:43:31 <quicksilver> siti: at a higher level patterns (dare I even use the word in this channel) like observer are useful
02:43:44 <quicksilver> and whilst OO isn't the only way to implment observers, by any means, it's *a* way
02:43:50 <siti> lol patterns ;)
02:43:53 <quicksilver> and implementing observers by hand in C would be a pain
02:44:02 <siti> glib does it well :p
02:44:08 <quicksilver> indeed it does
02:44:10 <siti> but that's kind of OO in c ;)
02:44:11 <quicksilver> and it was a pain :)
02:44:17 <pjd> quicksilver: s/observers by hand//
02:44:17 <quicksilver> after all, C++ can be compiled to C
02:44:25 <quicksilver> which is more or less what glib does
02:44:41 <siti> but it's much nicer than the traditional model
02:44:49 <quicksilver> yes, in some ways it is
02:45:11 <pejo> quicksilver, considering that GHC can output C as well it's not a very enlightening thing that something can be compiled to C.
02:45:11 <quicksilver> I don't think OO can be discounted, though. Java and C++ use OO to bring abstractions to the table which were previously out of reach, in C
02:45:23 <quicksilver> pejo: well there's a difference of degree there
02:45:31 <quicksilver> pejo: C++ can essentially be 'preprocessed' into C
02:45:39 <quicksilver> pejo: while haskell is genuinely compiled
02:45:40 <jer> C++ is not OO; don't confuse classes and objects =]
02:46:09 <pjd> jer: Obstruct-Oriented Programming
02:46:15 <pejo> Java and C++ use objects instead of having a proper module system more or less too.
02:46:18 <quicksilver> true
02:46:29 <jer> pjd, i see, that's a new one on me
02:46:32 <quicksilver> and there are other ways to attain those abstractions, and there are more powerful abstractions which can't be attained
02:46:42 <jer> pejo, c++ has no notion of objects in the language, period.
02:46:45 <quicksilver> but I don't think the whole thing can be written off
02:46:58 <quicksilver> jer: that's a very strange perspective
02:47:18 <steven_ashley> quicksilver: OO sucks?
02:47:22 <quicksilver> jer: motivated by a definition of object which is some distance from the consensus, I guess
02:47:23 <pejo> jer, classes then. They're doubling as a module system in the evenings atleast.
02:47:37 <jer> quicksilver, well perhaps it's my bias speaking (smalltalk programmer myself); but when i look at C++, i don't see objects. i see a class-based language, which is entirely different than an object-based language
02:47:54 <siti> don't be to pedantic ;)
02:47:57 <jer> pejo, right
02:47:59 <pjd> jer: ten thousand definitions of OO, etc.
02:48:03 <quicksilver> Sure, it's a class-based language. But the fact that its objects are restricted doesn't mean they're not objects.
02:48:05 <siti> I am sure they're similar ;)
02:48:18 <osfameron> prototype based OO is lovely
02:48:24 <jer> osfameron, indeed
02:48:30 <Cheery> quicksilver: drawing things on paper seems helping a lot.
02:48:32 <osfameron> I cried when I heard people wanted to get rid of it from javascript and make it more Classy
02:48:51 <siti> yeah javascript is interesting
02:49:06 <pjd> jer: Smalltalk's OO is also considered "class-based", by the way
02:49:09 <siti> someone was saying the other day that yhc can compile haskell to JS.. :)
02:49:10 <jer> osfameron, big thing is, with a prototype language you can craft classes in (usually) a few lines of code; but you can't go back if you include classes in the language... you essentially have to create a new language
02:49:10 <quicksilver> Cheery: I find that
02:49:22 <Cheery> I drew some transition graphs from my state machine.
02:49:33 <jer> pjd, i misspoke, i meant to say class-oriented
02:49:37 <jer> (in reference to C++)
02:49:59 <pjd> how would that differ from Smalltalk?
02:50:14 <osfameron> jer: there's hacks around it in Perl... but they amount to dynamically generating a new class per object... cute though
02:50:15 <Cheery> now I see that duplicate states appearing into that list, are always unique if there's appearing additional data on them.
02:50:49 <quicksilver> osfameron: s/new class/new method table/
02:50:55 <quicksilver> osfameron: and if you think about it, what else could you do?
02:51:09 <quicksilver> osfameron: in Perl, all a class is, is a method table
02:51:14 <quicksilver> Cheery: good :)
02:51:31 <quicksilver> Cheery: incidentally, the 'best' way to ensure uniqueness might be to use Set instead of List as your underlying type
02:51:32 <osfameron> quicksilver: yeah
02:51:44 <quicksilver> Cheery: but it does depend what you're doing
02:51:54 <quicksilver> the right underlying data structure is often a good start, though
02:52:13 <osfameron> quicksilver: I'd probably use Class::MOP which abstracts the symbol table hacking.  I once prototyped (hah) a prototype Object based thing doing it by hand for an adventure game library, but it was painful
02:52:16 <jer> pjd, tell me, in this statement, what's an object: int ::foo(int x) { return x; } <--
02:52:39 <pjd> jer: ?
02:52:52 <Patty01> Query: is there a standard library function whcih replaces the ith element of a list with a provided element; so e.g.  repl [a,b,c] 2 d = [a,d,c] ?
02:52:56 <quicksilver> jer: just because 'not everything is an object' doesn't mean 'nothing is an object'
02:53:01 <Cheery> ?Set
02:53:02 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:53:03 <quicksilver> jer: that's a terrible false syllogism
02:53:25 <quicksilver> Cheery: Data.Set in the standard libs
02:53:32 <jer> quicksilver, if that's the defintiion you want to use then i have a counter... when i instantiate a C++ object, you are aware of what's happening 'under the hood' correct?
02:53:46 <Cheery> ?Data.Set
02:53:47 <lambdabot> Unknown command, try @list
02:53:52 <Cheery> ok.
02:54:02 <TSC> Patty01: I don't think so, but it's not hard to build using splitAt
02:54:02 <quicksilver> jer: yes, of course
02:54:20 <Patty01> thanks!
02:54:50 <pjd> Patty01: or more directly, take/drop
02:55:11 <pejo> Why do we take horrible examples like C++ and perl when discussing OOP here?
02:55:40 <siti> pejo: what's your fav OO lang?
02:55:59 <osfameron> (perl might be my fault :-)  otoh, Perl's OO is er... very flexible, so it can be as good as you want it to be, if you're using newer abstractions)
02:56:03 <xerox> Cheery: what are you searching for?
02:57:53 <quicksilver> pejo: because, I think, we were discussing the state of the industry rather than the state of the art
02:58:50 <osfameron> btw, for "state of the art" in Perl5, I believe people rate Moose quite highly: http://search.cpan.org/~stevan/Moose-0.17/
02:58:51 <lambdabot> Title: Stevan Little / Moose-0.17 - search.cpan.org
02:59:10 <osfameron> Perl6 has a lot of interesting discussion going on in the OO front too, but that's still vapourware so I'll shut up again...
02:59:12 <pjd> Patty01: repl xs i x = take i xs ++ x : tail (drop i xs)
02:59:15 <Cheery> xerox: probably now I'd like some basic introduction to using sets.
02:59:39 <quicksilver> > Set.fromList [1,2,3]
02:59:40 <lambdabot>   Not in scope: `Set.fromList'
02:59:42 <pjd> that's using a 0-based i, not 1-based as in your example, though
02:59:45 <quicksilver> > Data.Set.fromList [1,2,3]
02:59:47 <lambdabot>  fromList [1,2,3]
02:59:53 <pjd> assuming the former is what you want
03:00:00 <quicksilver> odd, that's a different 'show' instance than the standard one?
03:00:04 <quicksilver> > Data.Set.fromList [1,2,3,3,4,3]
03:00:06 <lambdabot>  fromList [1,2,3,4]
03:00:26 <quicksilver> > (Data.Set.fromList [1,2,3,3,4,3]) Data.Set.Union (Data.Set.fromList [3,4,5])
03:00:27 <lambdabot>   Not in scope: data constructor `Data.Set.Union'
03:00:38 <quicksilver> > (Data.Set.fromList [1,2,3,3,4,3]) Data.Set.union (Data.Set.fromList [3,4,5])
03:00:40 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
03:00:51 <quicksilver> > (Data.Set.fromList [1,2,3,3,4,3]) `Data.Set.union` (Data.Set.fromList [3,4,5])
03:00:52 <lambdabot>  fromList [1,2,3,4,5]
03:00:56 <quicksilver> 45th time lucky
03:01:12 <quicksilver> Cheery: the Data.Set documentation page at least gives you an idea.
03:01:25 <quicksilver> Cheery: basically it's like list, but it guarantees uniqueness
03:01:34 <quicksilver> Cheery: and you dont' have a concrete constructor like (:)
03:01:51 <quicksilver> Cheery: instead you build up sets using fromList and things like union, insert, difference, etc
03:02:41 <pjd> quicksilver: what kind of tree is it using?
03:02:48 <elmex> hello
03:03:00 <quicksilver> pjd: some balanced thing, the docs have the details
03:03:14 <pjd> quicksilver: the haddock docs don't mention it
03:03:19 <quicksilver> oh *ponder*
03:03:34 <pjd> oh, wait, it references a paper
03:03:41 <pjd> they don't explicitly mention it, then :)
03:03:51 <quicksilver> trees of bounded balance, apparently :)
03:04:07 <pjd> yeah, just read that
03:04:11 <quicksilver> I believe they are "like red-black, but just slighly neater around the edge cases"
03:04:19 <pjd> sounds like a magical item
03:04:25 * quicksilver nods
03:04:25 <quicksilver> it is
03:04:33 <quicksilver> SPJ has a +5 Tree of Bounded Balance
03:04:34 <pjd> :)
03:04:36 <quicksilver> but he never lends it out
03:04:52 * pjd chuckles
03:04:57 <quicksilver> Allegedly Oleg has an ancient artifact tree
03:04:59 <Cheery> quicksilver: aah.
03:05:00 * quicksilver stops. Now.
03:05:06 <Cheery> ok.
03:05:43 <quicksilver> Cheery: it's more efficient probably than any algorithm for uniqueness you'd come up with on your own
03:06:35 <Cheery> I think there's one thing I can rely on as well.
03:07:51 <Cheery> my 'transitions' resembles a lot like morphisms.
03:07:52 <pjd> quicksilver: hmm, doesn't seem much like red-black trees, thankfully
03:10:17 <quicksilver> hurrah for algorithms with depth 2 pattern matches!
03:10:17 <Cheery> it may not be a good idea thought, because I allow my states to destruct.
03:10:32 <quicksilver> T' (p as (_,T(_,_,T(_,ln,_,_),T(_,rn,_,_)),E)) = ...
03:11:00 <quicksilver> still I have to hand it to him, that is a rather short program.
03:11:56 <pjd> quicksilver: destructuring binds are absolutely the best way to implement rotation :)
03:23:29 <dons> pretty html benchmarks, http://www.cse.unsw.edu.au/~dons/nobench/results.html
03:23:30 <lambdabot> Title: nobench: Haskell implementation shootout
03:24:21 <pjd> pretty?
03:24:49 <dons> compared to http://www.cse.unsw.edu.au/~dons/nobench/bench.log
03:25:09 <dons> i.e. the script actually generates html now :-) yay for xhtml combinators
03:25:10 <Lemmih> What's with all the Errors?
03:25:28 <dons> either compile failures or runtime errors (heap/stack oflow)
03:25:35 <dons> yhc is missing getArgs in System
03:25:38 <dons> so that breaks it for most things
03:25:57 <dons> i'll tweak the script tomorrow to link to the failure reason
03:26:08 <dons> note hbc does pretty well!
03:26:39 <matthew_-> can you do averages?
03:26:40 <dcoutts_> dons, you're using darcs yhc, so don't fix the benchmark, make them fix yhc
03:26:54 <dons> right. i'm asking for that.
03:27:00 <matthew_-> like "on average ghc-old is 1.3 times faster than ghc"
03:27:06 <dons> matthew_-: could be done. and multipliers for ecah test
03:27:09 <dcoutts_> dons, oh and nice html results :-)
03:27:14 <dons> ah, ghc-old is actually slower
03:27:17 <dons> that's caching
03:27:29 <dons> i need to run each test once before the measuring begins
03:27:49 <matthew_-> um. or you need to destroy the caches
03:27:53 <dons> yep
03:28:10 <dons> polutting the cache before each run is probably a better idea. either is ok
03:28:29 <dons> so ghc currently pays a small price for being first off
03:28:59 <matthew_-> yeah, I think just running a malloc until you get an error/start hitting swap and blanking out the memory is better than trying to make all the implementations benefit from caches
03:29:22 <dons> in our fps benchmarks we do that. on the shootout they do a warmup run
03:29:33 <dcoutts_> matthew-_, there are easier ways to flush cache than that :-)
03:29:54 <dcoutts_> we only need to dirty the L1/L2 caches, not the OS page cache
03:29:59 <matthew_-> ok, it's not something I've ever thought about much
03:30:12 <matthew_-> why don't you need to destroy the OS cache?
03:30:24 <dcoutts_> we're measuring CPU time, not real time
03:30:42 <matthew_-> ok
03:30:46 <matthew_-> that makes sense
03:30:54 <dcoutts_> so it doesn't include IO time
03:32:28 <dons> the atom benchmark is interesting. hugs has beaten ghc on that for the last 10 years
03:32:55 <dcoutts_> wow, yes by 6x
03:35:12 <dcoutts_> dons, shouldn't that be a case for the static argument transform?
03:35:18 * ddarius merely reads the first Haskell-Cafe email, "return?", and is dumbfounded.
03:36:12 <dcoutts_> dons, runExperiment in arom.hs I mean
03:36:16 <dcoutts_> erm atom.hs
03:36:40 <dcoutts_> hmm, perhaps not
03:36:46 <dcoutts_> it's a cse thing
03:41:05 * ddarius is glad he started writing this article; it's pointed out something obvious to him.
03:51:26 <hpaste>  Svrog pasted "GADT abuse" at http://hpaste.org/566
03:52:36 <Svrog> would anyone be able to tell me what's going on there?
03:52:52 <ddarius> What error does GHCi give you?
03:53:00 <Svrog> hang on
03:53:37 <Svrog> test.hs:21:14:
03:53:37 <Svrog>     Overlapping instances for LiftToExp a a1
03:53:38 <Svrog>       arising from use of `liftToExp' at test.hs:21:14-24
03:53:38 <Svrog>     Matching instances:
03:53:38 <Svrog>       instance (Floating a) => LiftToExp a b -- Defined at test.hs:17:0
03:53:39 <Svrog>       instance LiftToExp (Exp a) a -- Defined at test.hs:14:0
03:53:39 <Svrog>     (The choice depends on the instantiation of `a, a1'
03:53:41 <Svrog>      Use -fallow-incoherent-instances to use the first choice above)
03:53:43 <Svrog>     In the first argument of `App', namely `(liftToExp x)'
03:53:45 <Svrog>     In the expression: App (liftToExp x)
03:53:47 <Svrog>     In the definition of `test': test x = App (liftToExp x)
03:53:55 <Botje> Svrog: urgh. put that on a pastebin.
03:54:01 <Svrog> heh.. sorry
03:54:29 <Svrog> there is no error if i dont uncomment that line - and if i do :t test from ghci it gives me the same type signature im using
03:55:43 <pjd> ddarius: first Haskell-Cafe email?
03:55:58 <pjd> article?
03:56:02 <pjd> links? :)
03:57:32 <ddarius> Svrog: Hmm, drop the forall's in the explicit type signature and see if it works (it shouldn't).  But if it really is the case that the code fails when given a type signature that it can infer then that is most likely a bug.
03:57:53 <Svrog> fair enough
03:58:57 <Svrog> nope, dropping forall didn't help - still get the same error
03:59:29 <Svrog> so maybe it is a bug
03:59:36 <ddarius> Svrog: Check to see if it isn't already reported and perhaps ask on the ghc bugs list but otherwise report it.
03:59:47 <Svrog> yeah ill do that
03:59:50 <Svrog> thanks
04:00:21 <ddarius> pjd: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022685.html was the first post in the batch my mail program just got.
04:00:23 <lambdabot> Title: [Haskell-cafe] return?, http://tinyurl.com/22ch52
04:01:40 <ddarius> pjd: As far as the article, I'm writing, for the heck of it, an article on the Riemann Hypothesis and for some reason I hadn't explicitly realized (or maybe I did and forgot) that the Dirichlet transform is just a discrete version of the Mellin transform.
04:03:03 <pjd> oh, awesome
04:04:25 <pjd> is it an introductory article, or what?
04:06:06 <ddarius> The goal is to illustrate how you'd arrive at the Riemann hypothesis without glossing over the relevant parts of the math.  I'm hoping to present it in a way that would show you how you would even be lead to the questions.
04:06:58 <pjd> i'd love to read that
04:07:01 <ddarius> It's kind of like the "popular math" book "Prime Obsession" minus the history, denser, and more technical but hopefully more fulfilling.
04:08:15 <SamB> Mellin sounds a lot tastier than Dirichlet
04:08:56 <ddarius> And tastier than Laplace, Fourier, or Z.
04:09:24 * ddarius wonders how the Z-transform got out of being named after some math guy.
04:10:04 <careo> maybe it was named after Dr Z
04:10:13 <SamB> is it like honey dew, or water melon?
04:10:22 <SamB> or canteloupe?
04:10:29 * careo shoots himself for the incredibly lame reference to the Daimler-Benz ads
04:10:57 <ddarius> I wouldn't say watermelon at all.  Between honey dew and canteloupe I'd lean toward honey dew, but it's close.
04:12:00 * SamB wonders why xmms is insisting on playing his SPCs in *order*, despite the Shuffle button being clearly depressed
04:12:18 <ddarius> Because it agrees that Shuffle is evil.
04:12:29 <matthew_-> use xmms2, not xmms
04:12:32 <matthew_-> for the win!
04:12:34 <pjd> SamB: maybe you should cheer it up, provide some motivation
04:13:41 <SamB> how is Shuffle evil?
04:13:50 <SamB> it could do like 10 riffles at least
04:13:59 * beelsebob pokes people who are interested in benchmarks in the spleens
04:14:11 <SamB> beelsebob: ouch
04:14:16 <matthew_-> you're not benchmarking my spleen!
04:14:22 <beelsebob> lol
04:14:35 <SamB> hahhah
04:14:46 <SamB> strange way to parse it ;-)
04:14:48 <SamB> anyway...
04:14:56 <beelsebob> anyone who is interested in seeing how fast Haskell runs, how interested are you in a framework that lets you run lots of programs on different people's computers or different OSes?
04:15:03 * matthew_- has years of practise of deliberately misparsing...
04:15:07 <beelsebob> (and gives back pretty graphs)
04:15:12 <beelsebob> (mmm... graphs)
04:15:14 <SamB> benchmarks are good to give you an idea how systems compare in terms of performance
04:15:54 <SamB> oooh, buildbot for benchmarks?
04:15:56 <matthew_-> beelsebob: are you proposing using a zombie bot network for haskell benchmarking?
04:16:08 <SamB> zombie indeed!
04:16:16 <SamB> we would use *volunteers*
04:16:21 <matthew_-> ahh!
04:16:25 <matthew_-> ;-)
04:16:37 <beelsebob> matthew-_: no - I'm proposing that I know a guy who writes geekbench and am trying to convince him to give it a plugin architecture
04:16:37 <SamB> zombies are too inefficient and unreliable
04:16:42 <pjd> benchbot!
04:16:54 <beelsebob> he wants contact from people who want to use such a thing
04:17:05 <SamB> you don't think buildbot is a better place to start?
04:17:17 * SamB doesn't know much about it
04:17:35 <beelsebob> it could well be
04:17:41 <beelsebob> but buildbot builds stuff rather than running it
04:17:50 <beelsebob> @google geekbench
04:17:51 <beelsebob> go there
04:18:05 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
04:18:14 <SamB> does buildbot not run supplied commands?
04:18:27 <SamB> lambdabot: pull yourself together
04:18:35 <SamB> @google google
04:18:36 <lambdabot> http://www.google.com/
04:18:37 <lambdabot> Title: Google
04:18:42 <SamB> okay, lambdabot works
04:18:46 <SamB> ;-)
04:18:52 <SamB> @google geekbench
04:18:59 <lambdabot> http://www.geekpatrol.ca/geekbench/
04:18:59 <lambdabot> Title: Geek Patrol | Geekbench
04:20:41 <SamB> hmm.
04:20:47 * malcolmw wonders if dons has got nhc98 to build from darcs yet
04:20:48 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
04:21:21 <pjd> beelsebob: surely you could state your benchmark in the form of a build
04:21:27 <pjd> (for buildbot)
04:44:44 <dons> malcolmw: looks like you're right about the symlink issue. i'll retry the build in the morning. otherwise the build looked fine.
04:57:54 <therp> wah is there a way to beat the stupid URL package of latex that intense that it stops breaking urls as http:<break>//foobar.com/
05:35:09 <earthy> okay. let's see if this nasty hack works.
05:35:43 <earthy> drat. it doesn't.
05:35:52 <earthy>     Bad interface file: /usr/local/wxhaskell/lib/imports/Graphics/UI/WX.p_hi
05:35:52 <earthy>         mismatched interface file ways: expected p, found
05:37:41 <Lemmih> Isn't there a flag to ignore those pesky messages?
05:40:57 <Lemmih> Hm, guess not.
05:45:39 * earthy was trying to avoid recompiling wxhaskell for the umpteenth time, just to allow profiling
05:47:37 <emk> I need to write some proofs that involve random sampling, but I'm not even remote sure where to start.
05:48:35 <emk> Does anybody know, off the top of their head, a good introductory book on random sampling with a nice selection of proofs?
05:49:06 <matthew_-> I've just read every comic on xkcd.com. I still don't know what my PhD is about.
05:49:24 <apfelmus> emk: unfortunately no. but what's your task?
05:49:58 <edwinb> matthew_-: have you read all of phdcomics.com too?
05:50:49 <pejo> edwinb, heh, I was thinking exactly the same.
05:51:12 <emk> apfelmus: I'm trying to generalize the ideas in "A Probabilistic Language based upon Sampling Functions" by Park, et al., and I'm having trouble trying to prove the monad laws in the presence of random sampling. There must be some obvious trick, right?
05:51:17 <dropdrive> matthew-_, how many years have you been in grad school?
05:52:10 <dropdrive> er, wrong matthew.
05:55:35 <matthew_-> edwinb: um, most of those too
05:55:44 <matthew_-> dropdrive: they're both me (home and office)
05:56:01 <matthew_-> dropdrive: 1st year PhD, 5th month
05:59:19 <apfelmus> emk: i skimmed through the paper but did not grok much. i guess it can basically be formulated as a monad in pure Haskell?
05:59:35 <edwinb> matthew_-: curses, you'll need a new way to procrastinate then
05:59:53 <emk> apfelmus: It's a close cousin of the existing "PFP" library for Haskell, but based on sampling functions.
06:00:10 <emk> It's a nice monad, but I'm trying to generalize it without breaking the monad laws.
06:01:22 <matthew_-> oh, I procrastinate currently by just reading papers. Each day I read < 2 papers and print out > 4 papers. I'm sorted.
06:01:51 <emk> I think the trick may to work in terms of random variables, e.g., use X to represent an arbitrary element sampled from the underlying distribution. But I don't have any good examples of random proofs that do just what I want.
06:01:52 <apfelmus> emk: can you explain what the sampling function monad from the paper does? i did not read carefully, is it like a Reader (0,1]?
06:02:18 <quicksilver> emk: my gut feeling is that the monad laws will fail
06:02:29 <quicksilver> emk: but not in ways which will matter
06:02:36 <quicksilver> this is the sad truth of many haskell monads :)
06:02:47 <quicksilver> the laws fail up to some kind of 'observable equivalence'
06:03:02 <chessguy> 'morning, haskellers
06:03:08 <emk> apfelmus: Take a look at "Probabilistic Functional Programming" in Haskell, which uses exact probability distributions. The sampling paper just chooses a random path through the computation instead of doing it exhaustively.
06:03:29 <emk> quicksilver: In this case, I have reason to believe the monad laws should actually hold.
06:03:57 <emk> Probability distributions are, in general, monads, and a sampling function is a specialized model of a probability distribution.
06:04:24 <emk> But if I'm trying to generalize the underlying concepts slightly, I'm going to need to do the proofs, not just handwave.
06:04:25 <apfelmus> emk: aha. in a sense PFP a = FiniteMap (0,1] a whereas PaperProb a = (0,1] -> a    ?
06:04:59 <emk> apfelmus: Yeah, I think that's a reasonable way to look at it.
06:05:25 <chessguy> woohoo! HSOE is almost here!
06:08:06 <quicksilver> HSOE?
06:10:24 <apfelmus> emk: ah, that was incorrect. in reality, we have PFP a = FiniteMap a (0,1] with an interesting join function.
06:11:05 <emk> apfelmus: You can also look at it as a weighted set comprehension.
06:11:59 <emk> I don't remember the type signature of FiniteMap, so you'll need to take my comments in that direction with a grain of salt.
06:12:50 <emk> PFP is basically "newtype Dist a = Dist [(a, Prob)]", where the Prob values sum to 1.
06:14:44 <emk> apfelmus: The sampling paper is something like "newtype Sample a = Sample (Float -> a)", where Float lies between zero and one.
06:15:00 <emk> apfelmus: Proving properties of the later is giving me a headache.
06:15:03 <apfelmus> yes. the list is kinda finite map. the basic operation is to "convex-combinate" two sets
06:15:43 <emk> apfelmus: Yeah, it's roughly a cartesian product which multiplies the associated weights.
06:16:03 <apfelmus> emk: concerning Sample a, the most interesting point is how the join-operation looks like.
06:16:19 <emk> Take a look at Planet Haskell for a whole bunch of nice articles on PFP.
06:16:54 <emk> apfelmus: Basically, you can combine two distributions by taking a sample from each.
06:17:37 <apfelmus> join f x = (f x) x ?
06:17:59 <emk> You want a 'join' which gives you 'liftM2 (,) a b' returning one value each from a and b.
06:18:14 <_frederik_> PFP?
06:18:51 <_frederik_> http://talks.cam.ac.uk/talk/index/6732
06:18:52 <lambdabot> Title: talks.cam : : Universal Artificial Intelligence, and Probability Monads
06:19:03 <emk> _frederik_: Its randomly-sampled cousin: "A Probabilistic Language based upon Sampling Functions" by Park, et al.
06:19:07 <chessguy> ?where PFP
06:19:08 <lambdabot> I know nothing about pfp.
06:19:11 <chessguy> bah
06:19:30 <_frederik_> emk: what does PFP stand for? i just came in
06:19:51 <chessguy> ?where+ http://web.engr.oregonstate.edu/~erwig/pfp/
06:19:52 <lambdabot> Done.
06:19:56 <chessguy> _frederik_, ^^
06:20:05 <emk> _frederik_: Probabilistic Functional Programming, the monad over discrete finite probability distributions represented as weighted sets.
06:20:16 <dcoutts_> @where pfp
06:20:16 <lambdabot> I know nothing about pfp.
06:20:17 <_frederik_> emk: i am giving a reading group talk on probability monads but chose not to use that paper
06:20:25 <dcoutts_> chessguy, you need to give the keyword
06:20:29 <emk> Thanks for the talk pointer!
06:20:29 <chessguy> whoops
06:20:34 <chessguy> ?where+ pfp http://web.engr.oregonstate.edu/~erwig/pfp/
06:20:35 <lambdabot> Done.
06:20:46 <dcoutts_> @where http://web.engr.oregonstate.edu/~erwig/pfp/
06:20:59 <chessguy> heh
06:21:03 * dcoutts_ wonders what lambdabot did when it said 'Done' last time
06:21:05 <chessguy> shame there's not a where-
06:21:08 <matthew_-> @all-dicts PFP
06:21:09 <lambdabot> *** "pfp" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
06:21:10 <lambdabot> PFP
06:21:10 <lambdabot>  
06:21:10 <lambdabot>         {Plastic Flat Package}
06:21:11 <lambdabot>  
06:21:16 <chessguy> lol
06:21:50 <emk> _frederik_: I have a draft paper in the pipeline, but I'm still chewing over proofs.
06:21:56 <dons> ?where pfp
06:21:57 <lambdabot> http://web.engr.oregonstate.edu/~erwig/pfp/
06:22:07 * emk was a CS major, not a math major, and some days he feels it.
06:22:18 <matthew_-> running dict locally, 2 seconds; working out how to run dict in lambdabot, 5 minutes; amusing the #haskell channel, priceless
06:22:26 <chessguy> emk, i feel your pain
06:22:31 <earthy> hm. does --enable-executable-profiling do anything other than setting withProfExe to True?
06:22:33 <_frederik_> emk: nice
06:22:49 <obsethryl> hello
06:22:53 <chessguy> @remember matthew_ running dict locally, 2 seconds; working out how to run dict in lambdabot, 5 minutes; amusing the #haskell channel, priceless
06:22:53 <dons> earthy: well, it should link the executable with profiling libs and runtime
06:22:54 <lambdabot> Done.
06:23:01 <emk> _frederik_: I'm looking forward to reading the papers on that site you linked; there's a lot of interesting stuff there.
06:23:05 <obsethryl> how easy is it to interface Haskell with Qt libraries? is there anyone doing work on that?
06:23:07 <earthy> yeah, it seems to do that
06:23:10 <matthew_-> chessguy: ;)
06:23:13 * chessguy wonders if LB actually Done something that time
06:23:18 <earthy> however, how would I do -auto-all, e.g.?
06:23:30 <earthy> (it doesn't seem to do that at all)
06:24:17 <emk> _frederik_: You might also be interested in http://www.csse.monash.edu.au/~lloyd/tildeFP/2003ACSC/ , which takes a very different approach to AI in Haskell.
06:24:18 <lambdabot> Title: Types and Classes of Machine Learning and Data Mining
06:24:45 <chessguy> emk, if he's not, I am :)
06:24:50 <emk> Basically, how Occam's razor prevents overfitting (a.k.a, MDL in Haskell).
06:24:52 <matthew_-> does dons go through all the new quotes each week for HWN ?
06:25:07 <dcoutts_> @yarr!
06:25:08 <lambdabot> This is the END for you, you gutter-crawling cur!
06:25:08 * dcoutts_ finally has his review copy of Graham Hutton's "Programming in Haskell"
06:25:13 <earthy> ghcProfOptions exeBi
06:25:17 <earthy> hm. promising. ;)
06:26:22 <_frederik_> cool
06:27:12 <quicksilver> emk: oh, suddently remembered something
06:27:29 <_frederik_> i am presenting to a bunch of machine learning people, hopefully i will be able to make them understand monads etc. in one hour
06:27:37 <quicksilver> emk: I saw a talk from someone (I think his name was 'Sun') who had implemented a probabilistic ML to robot control
06:27:43 <quicksilver> emk: was a phd project
06:28:02 <emk> quicksilver: Yeah, the Park paper was a robotic-control paper.
06:28:08 <quicksilver> that's the chap
06:28:10 <chessguy> dcoutts_, have you reviewed HSOE yet?
06:28:15 <quicksilver> Sun Woo Park?
06:28:17 <quicksilver> something like that
06:28:38 <dcoutts_> chessguy, I'm reviewing Programming in Haskell not HSOE
06:28:48 <emk> quicksilver: Yeah, that's the one we were discussing. It's a nice paper, with a good argument for representing distributions as sampling functions.
06:28:52 <quicksilver> I wasn't particularly interested in the robotics (no offence) but I thought the probabilistic data types for ML was cute
06:29:32 <chessguy> dcoutts_, ah. i thought they might've asked you to review HSOE too
06:29:33 <_frederik_> i wrote a monad for exact inference in tree-shaped causal models. not particularly useful but you can do a 2-line HMM which uses the forward-backward algorithm to get posteriors automatically via the monad
06:29:41 <nomeata> @djinn [a -> b] -> a -> [b]
06:29:44 <lambdabot> -- f cannot be realized.
06:29:48 <dcoutts_> Cheery, HSOE has been out for years, this is new
06:29:57 * emk likes robotics because it forcibly smacks AI over the head with the real world.
06:29:58 <dcoutts_> erm sorry, chessguy , not Cheery
06:30:02 <nomeata> @djinn Maybe (a -> b -> a -> Maybe b
06:30:03 <lambdabot> Cannot parse command
06:30:06 <nomeata> @djinn Maybe (a -> b) -> a -> Maybe b
06:30:06 <lambdabot> f a b =
06:30:06 <lambdabot>     case a of
06:30:06 <lambdabot>     Nothing -> Nothing
06:30:06 <lambdabot>     Just c -> Just (c b)
06:30:08 <emk> _frederik_: Cool!
06:30:09 <chessguy> dcoutts_, ah, i didn't realize
06:30:30 <apfelmus> mh, why does he bury the interesting things in the operational semantics?
06:30:48 <emk> apfelmus: Are you talking about the Park paper?
06:30:55 <nomeata> @pl \mapf v fs = map ($v) fs
06:30:56 <lambdabot> (line 1, column 12):
06:30:56 <lambdabot> unexpected "="
06:30:56 <lambdabot> expecting pattern or "->"
06:31:00 <_frederik_> emk: i think it has a different flavour from Park et al, and also Ramsey and Pfeffer. i will probably go over it in the talk
06:31:11 <erider> good morning all
06:31:23 <emk> _frederik_: Well, I wish I could attend, but I'm on the wrong continent. :-(
06:31:28 <_frederik_> hehe
06:31:29 <apfelmus> emk: yes. i basically try to get a Haskell program out of the operational semantics
06:31:33 <nomeata> @pl let mapf v fs = map ($v) fs in mapf
06:31:33 <lambdabot> map . flip id
06:31:51 <_frederik_> http://ofb.net/~frederik/futility/src/HMM.hs
06:31:56 <nomeata> @pl let mapf fs v = map ($v) fs in mapf
06:31:56 <lambdabot> flip (map . flip id)
06:32:01 <_frederik_> http://ofb.net/~frederik/futility/src/NB.hs
06:32:02 <emk> apfelmus: Yeah, it's a nice result, but needlessly opaque. You can implement it as a 10-line Haskell monad.
06:33:47 <emk> _frederik_: Thanks! I'll take a look.
06:33:58 <earthy> *sigh*
06:34:20 <quicksilver> emk: to be fair, though, these things aren't always obvious during development :) It could well be a huge simplification on their previous attempt at semantics
06:34:22 <apfelmus> emk: mh, mh. it looks like we just have type Sample a = State (Stream (0,1]) a
06:34:38 * quicksilver speaks with feeling, having been party to semantic attempts before
06:34:57 <apfelmus> with the side condition that the stream only gets eaten up.
06:35:03 <emk> apfelmus: Yeah, I just use a "Rand" monad which gives me a sample between 0 and 1.
06:35:59 <apfelmus> emk: aha, that's what i wanted to know. so what does the paper introduce besides this trivial monad?
06:36:52 <emk> apfelmus: A bunch of discussions of why the sampling monad is more useful than other probability distribution monads, given sufficiently messy data, and some nice results in robotics.
06:38:27 <emk> apfelmus: I have some more to say on this subject, but that will have to wait until I sort out my proofs.
06:38:46 <emk> It will show up on Planet Haskell. :-)
06:39:09 <emk> Gotta run!
06:39:25 <apfelmus> emk: ok. bbl
06:45:35 <LoganCapaldo_> Am I just extra dumb or is ReadP more frustrating than Parsec?
06:46:09 <hpaste>  mauke pasted "hell.hs" at http://hpaste.org/567
06:46:11 <_frederik_> ReadP is harder to debug
06:46:19 <_frederik_> i find
06:46:33 <mauke> "I wish. It's machine code."
06:46:39 <matthew_-> are there some typical great and simple examples of programs which clearly are typesafe but which haskell's type system doesn't accept.
06:47:17 <quicksilver> matthew_-: what kind of thing are you looking for?
06:47:36 <quicksilver> matthew_-: there's the inability to pass around truly polymorphic functions, for example
06:47:45 <matthew_-> quicksilver: something simpler than that
06:47:56 <pejo> matthew, all papers with type system extensions present something that is hard or impossible to encode with the previous type system.
06:48:03 <matthew_-> indeed
06:48:47 <matthew_-> I'm looking at various papers and for example this type system won't allow x!|y!|if b then x?.y?.0 else y?.x?.0 (pi-calc)
06:48:48 <edwinb> matthew_-: how about a variadic adder?
06:48:56 <edwinb> (I'm not sure why you'd want to write such a thing, but still...)
06:49:18 <quicksilver> edwinb: is that a typesystem issue or a syntax issue?
06:49:25 <matthew_-> so I'm thinking "mmm, there must be programs that intuitively or even by deterministic reduction are safe, but haskell won't accept"
06:49:37 <quicksilver> edwinb: haskells 'everything is an application' syntax makes variadics painful
06:49:44 <edwinb> yes
06:49:46 <quicksilver> (although not impossible, look at printf)
06:49:52 <edwinb> euw
06:50:07 <quicksilver> conor mcb has a bunch of other variadic examples, too
06:50:16 <quicksilver> implementing bra-kets and so on
06:50:26 <edwinb> matthew_- wanted something simple though ;)
06:51:02 <quicksilver> I'm not sure I understand what he didn't want
06:51:14 <matthew_-> mmm. maybe this is just an indication that typing sequential programs is so much simpler than concurrent programs
06:52:05 <matthew_-> quicksilver: probably I was after something that a C programmer would be happy writing and would be safe, but for which the haskell translation wouldn't typecheck, requiring a completely different attack on the problem
06:52:35 <Syzygy-> ?hoogle allocaBytes
06:52:36 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
06:52:56 <quicksilver> matthew_-: maybe stuff like reusing memory cells at different types?
06:53:14 <quicksilver> matthew_-: much of the C stuff doesn't really get expressed naturally
06:53:15 <pejo> matthew, to return to the previous flamethrowing today - subtyping. http://www.cs.chalmers.se/~nordland/ohaskell/examples.html - the TK interface there is one example.
06:53:18 <lambdabot> Title: Some O'Haskell programming examples
06:53:24 <quicksilver> matthew_-: garbage collectors are quite hard to type check :)
06:53:39 <quicksilver> matthew_-: consider writing a haskell garbage collector in haskell...
06:54:12 <matthew_-> cool, all great, thanks. the cells stuff is particularly good seeing as it's kinda related to Erlang-style mailbox concurrency and trying to type the mailbox!
06:55:09 <pejo> (Why does concurrency mess up typing? Isn't there quite a lot done on typed process calculi?)
06:55:17 <matthew_-> pejo: yep
06:55:22 <matthew_-> I'm reading it all now
06:55:46 <quicksilver> matthew_-: Bornat, O'Hearn, Calcagno et al have some interesting work on program proof for memory-mutating programs
06:55:51 <matthew_-> it's kinda limiting - things that you can prove reduce without divergence you often can't type
06:56:07 <quicksilver> matthew_-: last I checked they don't really have a type system as such, for what they do
06:56:13 <matthew_-> quicksilver: I guess this is getting towards the separation logic stuff?
06:56:16 <edwinb> Bornat is giving a talk here in 5 minutes
06:56:19 <quicksilver> matthew_-: yes, it is
06:56:25 <quicksilver> edwinb: give him my best regards
06:56:36 <matthew_-> yeah, I heard Byron Cook talk on this stuff a month or so ago
06:56:49 <edwinb> ok ;)
06:56:51 <quicksilver> edwinb: by real name, not IRC nick. 'Jules Bean'
07:01:10 <LoganCapaldo_> step 1 to getting readP to work: Stop trying to do _all_ your dev in ghci. Files are your friend ;)
07:08:50 <LoganCapaldo_> So is there a way to hint to readP that a particular variation is more desireable? Or should I just write the grammar more carefully?
07:09:41 <quicksilver> I've never used it, but isn't it left-biased?
07:09:56 <quicksilver> most parser combinators I write by hand come out left-biased, that's the natural way to do it
07:10:03 <LoganCapaldo_> It claims its not although it can be if you want it to :)
07:10:10 <LoganCapaldo_> (+++ vs.<++)
07:10:14 <quicksilver> ah
07:10:21 <quicksilver> then isn't <++ the hint you're looking for?
07:10:29 <quicksilver> or did you want a weaker hint?
07:10:30 <LoganCapaldo_> but what I've written now doesn't really have any choice in it <g>
07:11:02 <LoganCapaldo_> I'm playing with "porting" some regexpy type stuff to it
07:11:15 <LoganCapaldo_> (I know theres a regexp lib)
07:22:25 <Syzygy-> ?hoogle assert
07:22:26 <lambdabot> Control.Exception.assert :: Bool -> a -> a
07:22:26 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
07:22:26 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
07:27:21 <fasta> Will a - (b - a) be optimized to -b + a automatically?
07:27:47 <fasta> Uhm, never mind
07:28:01 <bd_> Maybe for builtin types. I don't think it'll do that with custom instances, as that might not be correct.
07:28:36 <bd_> In the case of builtins a will only be evaluated once, so the extra subtraction won't matter that much anyway...
07:28:54 <fasta> My optimization was "incorrect", btw.
07:29:03 <fasta> Let me see what I meant...
07:29:09 * LoganCapaldo_ was trying to figure out that algebra
07:29:14 <LoganCapaldo_> my head hurt :)
07:29:38 <fasta> a - (a - b) => b
07:30:39 <fasta> I can also manually do the transformation.
07:34:33 <glguy> ?seen SyntaxNinja
07:34:33 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 3d 14h 15m 23s ago, and .
07:35:17 <ndm> hi, anyone familiar with the GHC Darcs tree?
07:35:18 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
07:35:29 <fasta> Heh, I found an error in CLRS
07:35:31 <Igloo> ndm: What's up?
07:35:37 <LoganCapaldo_> Hmm, I wonder if you could do the a - (a - b) with GHCs rewrite rules
07:35:39 <ndm> in particular, where would I find ./tests/ghc-regress/esc/
07:35:41 <ndm> @messages
07:35:42 <lambdabot> dons said 11h 49m 26s ago: yhc now fails on build with an error about System.Environment
07:35:58 <ndm> Igloo: i spotted the ESC Haskell messages flying past, i was wondering where the test directory was?
07:36:00 <Igloo> ndm: http://darcs.haskell.org/testsuite/tests/ghc-regress/esc/
07:36:01 <lambdabot> Title: Index of /testsuite/tests/ghc-regress/esc
07:36:08 <ndm> ah, i was looking under ghc
07:37:04 <ndm> thanks Igloo
07:37:11 <Igloo> np
07:37:12 <ndm> i don't suppose the esc haskell code is up anywhere?
07:37:30 <Igloo> No idea
07:37:37 <ndm> i guess i can ask Dana tomorrow
07:37:38 <bd_> fasta: It doesn't look like it implements any kind of transformation like that to me... but it shouldn't matter much.
07:37:46 <bd_> [based on -ddump-simpl output]
07:38:05 <bd_> In order to maintain correctness it must evaluate a anyway...
07:38:11 <bd_> [since _|_ - _ = _|_]
07:38:57 <Igloo> Not for all types
07:39:32 <fasta> Igloo: for non-lazy machine instructions it has to.
07:41:48 <ndm> @type (-)
07:41:50 <lambdabot> forall a. (Num a) => a -> a -> a
07:42:07 <ndm> fasta: - is not a machine instruction, you are thinking of -# (in GHC speak) or SUB_W (Yhc speak)
07:42:54 <fasta> ndm: AFAIK, everything that's lazy in on an x86 (short-circuit operations) is lazy in H98
07:43:05 <fasta> ndm: addition is not in x86
07:43:14 <fasta> ndm: => also not in Haskell
07:43:42 <ndm> fasta: (-) is a Num type, I can create my data Nat = Zero | Succ Nat, and have that be lazy in subtraction/addition etc
07:43:48 <fasta> ndm: - could be implemented lazily in Haskell, but AFAIK, it isn't.
07:44:07 <ndm> fasta: (-) is an operation in a class, it is lazy, -# is the strict machine code equivalent
07:44:28 <LoganCapaldo_> > 4 -# 3
07:44:29 <lambdabot>   Not in scope: `-#'
07:44:34 <LoganCapaldo_> drat
07:44:40 <fasta> ndm: you are implying that Int is not in Num
07:45:07 <ndm> fasta: for some instnatiations of -, it is strict, but in general its not
07:45:08 <bd_> Num does not require that (-) be strict on its arguments
07:45:15 <bd_> however Int is strict on (-)'s arguments
07:45:47 * fasta thinks bd_ is expressing it much better
07:46:00 <LoganCapaldo_> > 4 :: Int - 2 -- strict
07:46:01 <lambdabot>  Parse error
07:46:03 <bd_> Num neither requires nor forbids strictness, i should say.
07:46:10 <fasta> Right
07:46:11 <LoganCapaldo_> > (4 :: Int) - 2 -- strict
07:46:13 <lambdabot>  2
07:46:23 <LoganCapaldo_> > (4 :: Integer) - 2 -- lazy?
07:46:25 <lambdabot>  2
07:46:25 <bd_> > (4 :: Int) - undefined `seq` () -- strict :)
07:46:27 <lambdabot>  Undefined
07:46:28 <bd_> > (4 :: Integer) - undefined `seq` () -- strict :)
07:46:30 <lambdabot>  Undefined
07:46:38 <bd_> I think all the builtins are strict
07:46:44 <bd_> but you could implement a lazy one
07:46:58 <bd_> anyway, I must go now
07:47:05 <fasta> But what are the costs of that? => ultra-slowness?
07:47:42 <fasta> With a sufficiently smart compiler.... (yes, I know)
07:50:35 <earthy> finally.. a Dazzle with -prof -auto-all
07:50:49 <earthy> now to see if it doesn't just give me CAF shite
07:52:13 <earthy> um. you guys are ignoring boxed and unboxed code
07:52:35 <earthy> s/code/data/
08:04:29 <bd_> fasta: it's only one or two extra CPU cycles... :)
08:04:55 <bd_> earthy: how is unboxed data relevant to the optimization in question?
08:05:35 <fasta> bd_: When you say that for X items, it's one or two X extra CPU cycles
08:05:37 <pejo> bd, what is one or two cycles extra?
08:06:33 <bd_> fasta: I think the cost of evaluating a, which is required for correctness, will overwhelm any minor difference in the actual subtractions
08:06:53 <bd_> pejo: failure to optimize a - (a - b) => b
08:08:51 <mwc> bd_, optimize it for what type?
08:09:16 <mwc> ints? you have to deal with over/underflow, so strictly speaking, a - (a - b) /= b for all a,b
08:09:25 <mwc> floating point? Rounding.
08:09:40 <mwc> for Integer, you'd have a case :)
08:10:09 <mwc> generally when a programmer says something like a - (a - b) he's driving at something specific, or he would have written b.
08:11:40 <mwc> ie: using creative subtractions that algebraically do nothing to get more precision: http://en.wikipedia.org/wiki/Kahan_summation_algorithm
08:14:02 <bd_> @check a - (a - b) == (b :: Int32)
08:14:03 <lambdabot>   Not in scope: `b'
08:14:08 <bd_> @check \a b -> a - (a - b) == (b :: Int32)
08:14:09 <lambdabot>   add an instance declaration for (Arbitrary Int32)     In the expression: le...
08:14:12 <bd_> @check \a b -> a - (a - b) == (b :: Int)
08:14:13 <lambdabot>  OK, passed 500 tests.
08:14:30 <Cale> Int is an additive group at least. :)
08:14:33 <bd_> > minBound - (minBound - maxBound) == (maxBound :: Int)
08:14:35 <lambdabot>  True
08:14:49 <Cale> You shouldn't have trouble with that on Ints
08:14:54 <Cale> but you will with Floats.
08:15:12 <mwc> right, I forgot that Z mod N is a group
08:15:27 * mwc sentences self to spend an hour with last year's group theory textbook.
08:15:41 <pejo> mwc, simple arithmetic shows up quite often from bounds calculationsf or arrays and such though. Which is why a + 0 = a is a useful optimisation sometimes.
08:16:34 <mwc> Right, but a) array bounds are ints, and b) even if it were FP, I'm fairly certain that FPU's handle 0 specially.
08:16:41 <MarcWebe5> Do you know wether I can tell DrIft to ignore not imports which it cannot find ?
08:16:51 <mwc> @check \a b -> a - (a - b) == (b:: Double)
08:16:53 <lambdabot>  Falsifiable, after 0 tests: -2.0, 2.3333333333333335
08:17:02 <mwc> on the other hand...
08:17:11 <Cale> I'd really like to see the Cayley graph generated by floating point addition.
08:17:13 <mwc> @check \a -> a + 0 == (a :: Double)
08:17:14 <lambdabot>  OK, passed 500 tests.
08:17:35 <mauke> > (\a -> a + 0 == a) (0 / 0)
08:17:37 <lambdabot>  False
08:17:41 <mauke> lame
08:17:47 <Cale> lame?
08:17:58 <mauke> yeah, @check didn't try NaN
08:18:06 <Cale> It tests random values
08:18:24 <Cale> The likelihood of it checking NaN is pretty low.
08:18:43 <bd_> @check \a b -> (a/b) + 0 == ((a/b) :: Double)
08:18:43 <dcoutts_> which is in itself a problem sometimes
08:18:44 <Cale> I wonder if smallcheck does.
08:18:44 <lambdabot>  Falsifiable, after 1 tests: 0.0, 0.0
08:18:59 <bd_> @scheck \a -> a + 0 = (a :: Double)
08:18:59 <lambdabot>  Parse error
08:19:03 <mwc> > (0/0)
08:19:04 <lambdabot>  NaN
08:19:05 <pjd> Cale: how does it get random float values?
08:19:09 <bd_> @scheck a + 0 = (a :: Double)
08:19:14 <lambdabot>  Parse error
08:19:16 <dcoutts_> mind you, you don't want to check maxBound all the time, or you could be creating some very large example problems
08:19:17 <mwc> > let nan = (0/0)
08:19:17 <Cale> pjd: good question
08:19:18 <lambdabot>  Parse error
08:19:18 <mwc> > nan == nan
08:19:18 <bd_> hm
08:19:20 <lambdabot>   Not in scope: `nan'
08:19:29 <pjd> re-interpreting ints as floats?
08:19:37 <bd_> > NaN
08:19:38 <lambdabot>   Not in scope: data constructor `NaN'
08:19:45 <mwc> My point was that nan's compare as not equal to nans
08:19:48 <bd_> > read "NaN" :: Double
08:19:50 <lambdabot>  NaN
08:19:57 <mauke> @let nan = 0/0
08:20:00 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
08:20:02 <mwc> so you can check for a nan like this: if x /= x then handleNan else ...
08:20:10 <Cale> Could be via encodeFloat
08:20:17 <bd_> :t encodeFloat
08:20:20 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
08:20:32 <mauke> isNan = join (/=)
08:20:44 <Cale> :t isNaN
08:20:47 <lambdabot> forall a. (RealFloat a) => a -> Bool
08:21:00 <Cale> :t isInfinite
08:21:00 <mauke> @src isNaN
08:21:01 <lambdabot> Source not found. It can only be attributed to human error.
08:21:03 <lambdabot> forall a. (RealFloat a) => a -> Bool
08:21:11 <mwc> :t join
08:21:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:21:16 <Cale> @src isNaN Float
08:21:17 <lambdabot> Source not found. Wrong!  You cheating scum!
08:21:26 <Cale> :t isDenormalized
08:21:27 <pjd> do infinities compare equal?
08:21:29 <lambdabot> forall a. (RealFloat a) => a -> Bool
08:21:36 <Cale> > (1/0) == (1/0)
08:21:37 <mwc> pjd, I believe yes
08:21:38 <lambdabot>  True
08:21:38 <pjd> (with themselves?)
08:21:41 <Cale> yes
08:21:43 <Cale> > (1/0) == (-1/0)
08:21:44 <lambdabot>  False
08:21:47 <bd_> @check \a b -> join (/=) (a/b) == isNaN (a/b(
08:21:47 <lambdabot>  Parse error
08:21:48 <bd_> @check \a b -> join (/=) (a/b) == isNaN (a/b)
08:21:49 <lambdabot>  Add a type signature
08:21:53 <bd_> @check \a b -> join (/=) (a/b) == isNaN (a/b :: Double)
08:21:55 <lambdabot>  OK, passed 500 tests.
08:22:14 <Cale> > 0 == (-0)
08:22:16 <lambdabot>  True
08:22:20 <mwc> is that join the monad join?1
08:22:26 <Cale> > let f x = 1/x in f 0 == f (-0)
08:22:28 <lambdabot>  False
08:22:30 <mauke> mwc: yes
08:22:32 <bd_> mwc: join in Reader, yes
08:22:32 <Cale> mwc: yeah
08:22:37 <quicksilver> > (1/0)
08:22:38 <lambdabot>  Infinity
08:22:39 <Cale> @quote stereo
08:22:40 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
08:23:12 <LoganCapaldo_> that seems to be common in a lot of channels
08:23:13 <mwc> @pl \x -> (x,x)
08:23:14 <lambdabot> join (,)
08:23:18 <LoganCapaldo_> that or silence
08:23:28 <Cale> > let f x = 1/x in 0 == (-0) && f 0 /= f (-0)
08:23:30 <lambdabot>  True
08:23:33 <earthy> okay... 60% of the time in Dazzle is spent on Map handling...
08:23:40 <mwc> So it seems join has the side effect of feeding an argument to a function twice? I wouldn't have thought of using it for that
08:23:50 <Cale> mwc: yeah...
08:24:05 <earthy> in this particular use case
08:24:06 <Cale> join x = do v <- x; w <- v; return w
08:24:09 <quicksilver> mwc: that's join in the monad of functions
08:24:19 <mauke> join = (>>= id)
08:24:23 <quicksilver> :t join
08:24:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:24:40 <bd_> :t join :: (a -> a -> b) -> a -> b
08:24:41 <Cale> My form will be easier for seeing why it's applying parameters twice
08:24:43 <lambdabot> (a -> a -> b) -> a -> b :: forall a b. (a -> a -> b) -> a -> b
08:24:53 <bd_> @src (->) join
08:24:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:24:55 <Cale> In the (->) e monad, things are run by applying them to the environment parameters
08:24:58 <Cale> -s
08:25:05 <Cale> For example...
08:25:16 <mauke> bd_: join is not a method
08:25:28 <bd_> It should be :(
08:25:28 <Cale> > (do x <- (+10); y <- (+20); return (x,y)) 5
08:25:30 <lambdabot>  (15,25)
08:25:55 <Cale> (+10) and (+20) are "run" by applying them to 5
08:26:02 <Cale> join x = do v <- x; w <- v; return w
08:26:12 <Cale> Now look at that again :)
08:27:08 <Cale> x will be run by applying it to the environment parameter once, then its result will be run by applying it to that parameter.
08:27:36 <Cale> > (do v <- (*); w <- v; return w) 5
08:27:38 <lambdabot>  25
08:27:47 <Cale> > (do v <- (,); w <- v; return w) 5
08:27:49 <lambdabot>  (5,5)
08:27:53 <Saizan> return is const?
08:28:09 <Cale> yeah.
08:29:08 <Cale> another interesting find in this monad is ap
08:29:16 <Cale> ap f g x = f x (g x)
08:29:29 <Cale> (in the (->) e monad)
08:29:39 <Cale> > ap (,) (+10) 5
08:29:41 <lambdabot>  (5,15)
08:29:52 <Thunder> @pl let y f = f (y f) in y
08:29:53 <lambdabot> fix (ap id)
08:30:03 <Thunder> Just another use of ap.
08:31:23 <Cale> :t ap id
08:31:25 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
08:31:44 <Cale> :t fix (ap id)
08:31:47 <lambdabot> forall b. (b -> b) -> b
08:31:50 <Cale> nice
08:32:01 <Thunder> Cale: ap is used to generate the same structure as the Y combinator.
08:33:57 <Cale> Thunder: right
08:34:09 <Cale> ap id y f = y (f y)
08:34:17 <Cale> er
08:34:52 <Cale> ap id f y = y (f y)
08:34:54 <Cale> rather
08:35:16 <quicksilver> flip (ap id)
08:35:21 <quicksilver> is what you meant :)
08:36:33 <mauke> liftM2 c f g = \x -> f x `c` g x
08:36:48 <paolino> hi, how do I make this work ?
08:36:49 <paolino> *Net.Parse> read.show $ "paolino"
08:37:24 <mauke> > read . show $ "paolino" :: String
08:37:26 <lambdabot>  "paolino"
08:37:48 <paolino> :t "paolino"
08:37:50 <lambdabot> [Char]
08:38:02 <mauke> :t read ""
08:38:05 <lambdabot> forall a. (Read a) => a
08:38:39 <paolino> > read.show $ 4
08:38:40 <lambdabot>  4
08:38:56 <Cale> paolino: defaulting is being used there to make it an Integer
08:39:11 <mauke> that doesn't work here
08:39:33 <Cale> > show . read $ "5"
08:39:34 <lambdabot>  "5"
08:39:41 <Cale> hehe, nice :)
08:39:46 <quicksilver> I still think there is something mysterious about the fact that ($) is just a specialisation of id
08:40:02 <bd_> @src ($)
08:40:02 <lambdabot> f $ x = f x
08:40:06 <Cale> Well, it doesn't do anything
08:40:07 <bd_> should be ($) = id :)
08:40:14 <quicksilver> I know :)
08:40:24 <bd_> @. pl src ($)
08:40:24 <lambdabot> (line 1, column 1):
08:40:25 <lambdabot> unexpected end of input
08:40:25 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
08:40:29 <quicksilver> but it still twists the corners of my mind in a slightly painful fashion
08:40:30 <osfameron> @src id
08:40:31 <lambdabot> id x = x
08:40:55 <Cale> You know how f x y z = ((f x) y) z, right? :)
08:41:00 <quicksilver> yes :)
08:41:17 <pjd> quicksilver: agreed
08:41:24 <Cale> It's really unfortunate that $ has the opposite associativity of application.
08:41:27 <mauke> f `id` x `id` y `id` z
08:41:42 <pjd> ($) :: (a -> b) -> (a -> b) mostly works for me
08:41:49 <quicksilver> Cale: yes
08:42:45 <paolino> newtype Lev = Lev String deriving (Eq,Read,Show)
08:42:46 <paolino> I cannot succeed in reading values for it , how they should be written ?
08:43:04 <mauke> "Lev \"...\"" probably
08:43:21 <quicksilver> paolino: the same way show shows them
08:43:37 <quicksilver> paolino: show one, look at it, that's what you should write if you want to read it :)
08:43:40 <mauke> deriving Read is not that useful
08:54:15 <paolino> *Net.Parse> parseDatas "DataLev (Lev \"%\")" "paolino\nmauke" (\ns -> (ns!!0) -| (ns!!1))
08:54:16 <paolino> 6.0
08:54:43 <paolino> but
08:54:44 <paolino> *Net.Parse> parseDatas "DataLev (Lev \"%\")" "paolino\nCale" (\ns -> (ns!!0) -| (ns!!1))
08:54:44 <paolino> 5.0
08:54:50 <paolino> :)
08:55:55 <paolino> and, also
08:55:56 <paolino> *Net.Parse> parseDatas "DataInt %" "2\n5" (\ns -> (ns!!0) -| (ns!!1))
08:55:56 <paolino> 3.0
08:57:33 <paolino> rank-2 CPS grapes
08:59:50 <paolino> is rank2 polymorphism anyway related conceptually with the reader monad ?
09:01:31 <quicksilver> paolino: not in any way that's clear to me off-hand
09:01:42 <quicksilver> paolino: what are you thinking it down
09:02:07 <paolino> looks like it encapsulate  a type in place of a value
09:03:42 <quicksilver> paolino: and lambda-abstraction abstracts a name, in place of a value or a type :)
09:03:59 <quicksilver> paolino: I'm not convinced the similarity is deeper than the similarity between any two types of abstraction
09:04:04 <quicksilver> but I'm happy to be proven wrong :)
09:04:12 <ndm> @tell dons i've added a fix to Yhc, should work for you now
09:04:12 <lambdabot> Consider it noted.
09:04:25 <paolino> and I suppose that type can hold a specific value of that type (don't know how)
09:05:27 <paolino> unData :: [Data'] -> (forall a.Metrics a => [a] -> ret) -> ret
09:05:28 <paolino> looks like a monad runner
09:06:46 <paolino> the function passed as second arg can access a , but only "inside"  unData
09:07:03 <sjanssen> @quote
09:07:04 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
09:07:33 <paolino> bah, I'm like a baby with LEGO probably
09:07:50 <quicksilver> paolino: building houses and knocking them down?
09:08:00 <quicksilver> paolino: that's a pretty healthy way to proceed, I think
09:08:07 <mbishop> choking to death?
09:09:37 <paolino> I don't even know when to use callCC, I'm out of topic
09:09:56 <ndm> anyone know how to get a darcs repo at a particular tag?
09:10:03 <ndm> darcs get --tag="Stable 1" http://darcs.haskell.org/yhc doesn't seem to do it
09:10:04 <quicksilver> paolino: never :)
09:10:04 <lambdabot> Title: Index of /yhc
09:10:12 <ndm> but that gets the latest version...
09:10:18 <quicksilver> callCC is a painfully powerful general flow control construct
09:10:38 <quicksilver> in specific applications there is normally a less powerful and less painful but more elegant combinator you can use
09:11:33 * paolino wonders when it's right to call a function combinator
09:12:04 <quicksilver> I tend to use combinator in the sense 'higher order function'
09:12:07 <dcoutts_> paolino, when you want people to think it's cool ;-)
09:12:12 <quicksilver> function some of whose parameters are functions
09:12:15 <quicksilver> normally at least two of them
09:12:23 <quicksilver> so it's *combin*ing code
09:12:46 <dcoutts_> obviously it's somit wot combines things init?
09:12:55 <quicksilver> however some combinators act on 'function-like' things which are not strictly functions
09:13:54 <quicksilver> Historically, I believe, combinators are associated with a desire to go point-free
09:14:03 * paolino suggests to add to  the first topic  "or at least what is a combinator"
09:14:07 <quicksilver> combinatory logic is point-free lambda calculus
09:14:54 <hyrax42> ?pl \x -> zipWith (++) (tails x) (inits x)
09:14:54 <lambdabot> ap (zipWith (++) . tails) inits
09:15:09 <hyrax42> :t ap
09:15:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:15:22 <chessguy> \lis
09:15:25 <chessguy> whoops
09:15:42 <quicksilver> hyrax42: that's ap in the arrow monad
09:15:51 <quicksilver> one of Cale's favourite tricks :)
09:15:53 <hyrax42> yeah
09:15:59 <hyrax42> I knew it'd had ap in there somewhere
09:16:28 <hyrax42> ap is one that I have never used because I'm not too sure what it does
09:16:30 <quicksilver> @pl \x -> notzipWith (tails x) (++) (inits x)
09:16:30 <lambdabot> ap (flip notzipWith (++) . tails) inits
09:16:38 <chessguy> @pl \lis -> ((head lis) ++ "or at least what is a combinator"):(tail lis)
09:16:39 <Cale> ap f g x = f x (g x)
09:16:39 <lambdabot> ap ((:) . (++ "or at least what is a combinator") . head) tail
09:16:43 <quicksilver> @pl \x -> notzipWith (tails x) (inits x) (++)
09:16:44 <lambdabot> flip (liftM2 notzipWith tails inits) (++)
09:16:45 <Cale> ap is the classical S
09:17:12 <hyrax42> hm
09:17:28 <hyrax42> easy way to remember it, now just need to get to using it
09:17:29 <Cale> > ap (,) (+10) 5
09:17:31 <lambdabot>  (5,15)
09:17:33 <quicksilver> sometimes I wish ++ was mappend
09:17:43 <quicksilver> that is, I wish ++ was a Monoid method
09:17:51 <Cale> > ap (++) (map toLower) "ECHO"
09:17:53 <lambdabot>  "ECHOecho"
09:18:11 <Cale> quicksilver: It used to be a MonadPlus method.
09:18:31 <quicksilver> Cale: hmm
09:18:35 <quicksilver> Cale: no, I don't want that :)
09:18:47 <quicksilver> Cale: Monoid is more basic than MonadPlus
09:18:56 <quicksilver> stupid overlapping instances and stuff
09:19:30 * osfameron wonders whether when he's finished SoE he'll be able to understand 10% of what is said in this channel :D
09:19:33 <Cale> MonadPlus is probably slightly more useful most of the time.
09:19:46 <kolmodin> ?seen dons
09:19:46 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 2h 56m 52s ago.
09:19:49 <quicksilver> Cale: you're probably right
09:19:55 <Cale> osfameron: Don't worry, you'll pick it up by osmosis, and it's on a long loop anyway.
09:19:57 <quicksilver> Cale: but still ++ and monoids are nice notions
09:20:12 <Cale> quicksilver: yeah
09:20:31 <quicksilver> One of my pet hates is the 'optimisation' from ++ to :
09:20:38 <quicksilver> @pl "a" ++ "bcd"
09:20:38 <lambdabot> "abcd"
09:20:42 <Cale> oh?
09:20:45 <quicksilver> @pl "a" ++ x
09:20:45 <lambdabot> 'a' : x
09:20:49 <quicksilver> that one
09:20:52 <Cale> yeah
09:20:55 <quicksilver> it's exposing structure
09:21:01 <Cale> yes it is :)
09:21:02 <quicksilver> ++ is the 'real operation' there
09:21:08 <Cale> Or is it? :)
09:21:10 <quicksilver> I don't want to care that lists are 'head-biased'
09:21:24 <quicksilver> I want to write code with ++ that would work with other Sequence structures
09:21:43 <Cale> Sometimes code really is written for lists though.
09:22:17 <Cale> Lists are actually pretty special when you stop and think about it. lists : data structures :: loops : general recursion
09:22:49 <quicksilver> of course
09:22:55 <quicksilver> but often, code is written for monoids
09:23:14 <quicksilver> (Writer being a good example, perhaps)
09:23:17 <Cale> yeah.
09:23:27 <quicksilver> and un-parsers in general, I think
09:23:57 <Cale> WriterT (Product Rational) [] is an interesting monad.
09:23:59 <quicksilver> ther 'right kind' of structure for a general unparser might be something more tree-shaped in implmentation
09:24:08 * quicksilver grins
09:24:19 <quicksilver> calculating probabilities, perhaps?
09:24:22 <Cale> yeah
09:24:41 <Cale> automatically :)
09:24:42 <quicksilver> the STL has 'ropes' I think they're some kind of efficiently implemented string monoid
09:24:46 <quicksilver> never looked at how they worked
09:25:19 <quicksilver> (C++ STL, that is)
09:25:31 <Cale> I think it's just a concatenation tree used to implement strings.
09:25:55 <Syzygy-> Reading the pointfree source, it seems as if ++ gets translated into : in order to actually write all the monoid simplifications explicitly for lists instead.
09:26:16 <Cale> data Rope = RBranch Rope Rope | RLeaf String
09:26:56 <hyrax42> will h' have overlapping instances?
09:27:54 <Cale> I'm not 100% comfortable with overlapping instances, since I'm not completely sure how they're selected from.
09:28:02 <quicksilver> that's the key question
09:28:17 <quicksilver> it would be lovely to be able to find an elegant (not too much syntactical overhead) way of doing it
09:28:34 <quicksilver> so that I could choose from the many possible ways that [Int] is a Monoid
09:28:47 <Cale> It would be nice if things like that, and operator precedence could be done by specifying partial orders.
09:29:12 <quicksilver> I *might* be happy with a scoped 'choice' construct
09:29:18 <Cale> hehe, it'd really piss off the text editor people :)
09:29:42 <quicksilver> with instance Monoid [Int] from MonadPlus [a] ( .... )
09:30:11 <quicksilver> i.e. a simple set of rules to determine the 'default' instance plus an explicit but not-to-noisy way to get other ones in a particular code block.
09:30:29 <Cale> quicksilver: yeah, that's been proposed before. The effect has some odd consequences. Maybe not entirely bad, but it's a change.
09:30:43 <Cale> It's like implicit parameters.
09:30:55 <quicksilver> Cale: you said that before, and I didn't understand how.
09:30:59 <Cale> oh
09:31:06 <quicksilver> Cale: implicit parameters are ugly because they're like dynamic scoping
09:31:10 <quicksilver> this is like lexical scoping
09:31:15 <quicksilver> so it's more transparent, I thought?
09:31:21 <Cale> Well, you're specifying the dictionary to be passed down into a segment of code.
09:31:28 <quicksilver> true
09:31:36 <quicksilver> but only if that code is asking for a Monoid context
09:31:51 <quicksilver> if that code is asking for a Monoid context it has no right to make any assumption about what the type is
09:32:01 <Cale> ah, so you would *require* (....) there to have a monoid context directly in its type
09:32:11 <Cale> and not just using the monoid operations incidentally
09:32:23 <quicksilver> I think we're slightly at cross purposes
09:32:33 <quicksilver> if it uses monoid operations incidentally, then it wouldn't need a monoid context
09:32:37 <Saizan> mmh what happens if i then compose two functions that are using different instances?
09:32:45 <quicksilver> I thought you were talking about passing the dictionary onto other functions
09:32:51 <quicksilver> Saizan: it doesn't matter, because they're different
09:33:01 <quicksilver> Saizan: they're effecively different types, from the point of view of the type system
09:33:09 <quicksilver> you can't get them confused
09:33:10 <Cale> You'd have to use two withs.
09:33:24 <Cale> er
09:33:29 <quicksilver> Cale: the with is still lexical though
09:33:35 <quicksilver> I'm pretty happy with lexical constructs
09:33:41 <Cale> hmm
09:33:44 <quicksilver> I can see the source file, look over it, see what's happening
09:34:59 <Cale> let instance Ord Integer where ... in sort [5 :: Integer,2,6,1,3]
09:35:13 <Cale> Would that use the provided instance?
09:35:16 <quicksilver> yes
09:35:18 <quicksilver> :t sort
09:35:21 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:35:26 <quicksilver> sort's type has an Ord context
09:35:28 <Cale> :t sort [5 :: Integer,2,6,1,3]
09:35:30 <lambdabot> Integer,2,6,1,3] :: [Integer]
09:35:33 <Cale> heh
09:35:34 <quicksilver> so you give it an ord dictionary
09:35:43 <Cale> [Integer] is the type of the expression though
09:35:46 <quicksilver> that seems fine to me
09:35:48 <twanvl> This would mess with context reduction, the compiler can no longer remove "Monoid Int => .."  from a type if there is an instance in scope.
09:35:49 <quicksilver> yes, agreed
09:35:54 <Cale> (let instance Ord Integer where ... in sort) [5 :: Integer,2,6,1,3]
09:36:04 <Cale> that would certainly use the provided dictionary
09:36:22 <quicksilver> ah well, that's a funny one
09:36:26 <Cale> but the other way, it's just like implicit parameters
09:36:30 <quicksilver> I was thinking not
09:36:41 <quicksilver> since I was looking at scope for the value of type a
09:36:43 <quicksilver> not the function
09:37:34 <quicksilver> Cale: sort is still sort
09:37:43 <quicksilver> putting it in a block like that doesn't change it
09:38:02 <quicksilver> however I would allow sort (let instance Ord ... in [5 :: Integer,2,6,1,3])
09:38:08 <Cale> The question I'm getting at is whether the dictionary gets passed down through values which don't have Ord contexts in their types.
09:38:55 <quicksilver> well, the way I'm seeing it, the compiler is saying 'I'm applying this function 'sort', to this argument '5,2,6,1,3'. Do their types match?
09:38:57 <Cale> That last one would be brutally hard to support.
09:39:08 <quicksilver> it checks the type for 'sort', it finds that it requires an ord context
09:39:20 <quicksilver> it checks the type for [5,2,6,1,3], and then looks for an ord context
09:39:30 <Cale> Because it would require every piece of data to carry around any additional dictionaries which it'd been flagged with.
09:39:55 <quicksilver> semantically, it would, yes
09:40:04 <quicksilver> but these things can be resolved at compile-time in general
09:40:11 <Cale> Without something like full-program optimisation, no.
09:40:20 <quicksilver> that is the non-mathematical 'in general'
09:40:20 <Cale> What happens across module boundaries?
09:40:24 <quicksilver> which means the exact opposite
09:40:25 <quicksilver> :)
09:40:33 <quicksilver> but these things can be resolved at compile-time mostly
09:40:43 <Cale> Oh?
09:41:05 <quicksilver> ah well that's why it's lexical
09:41:07 <quicksilver> (in my head)
09:41:12 <Cale> *cough* stupid separate compilation *cough*
09:41:12 <quicksilver> it's not dynamic
09:41:20 <quicksilver> so if foo :: [Int] is in a module
09:41:28 <quicksilver> that module *cannot* attach a different dictionary to it
09:41:36 <quicksilver> because that's lexically separate
09:41:56 <quicksilver> so if I 'sort My.Module.foo', the Ord instance is that in lexical scope at call site
09:41:59 <Cale> That said, it would be kind of neat.
09:42:09 <quicksilver> what might be in lexical scope at the definition of foo is irrelevant
09:42:19 <Cale> I think it would be saner to attach the dictionary to the sort though.
09:42:38 <quicksilver> if, instead of foo :: [Int], the module defined foo :: (exists a. Ord a => [a])
09:42:41 <quicksilver> that would be different
09:42:52 <quicksilver> but in that case, it seems entirely reasonable for the module to return a dictionary
09:43:03 <Cale> It would make things pretty strange if we tried to attach different dictionaries to the elements of the list, and then pass that to sort :)
09:43:14 <quicksilver> yeah, that's true
09:43:22 <quicksilver> this is why I'm trying to make it lexical
09:43:34 <quicksilver> the only argument is which 'point' is the lexical magic happening
09:44:06 <Cale> I think the best you could likely do without massive overhaul of the runtime system is to attach something to sort itself.
09:44:17 <quicksilver> I think I can do better
09:44:25 <quicksilver> but I think, in all probability, that's because I misunderstand
09:44:28 <quicksilver> still, that's what I think :)
09:44:41 <Cale> Oh, you could also have an implicit-parameter-like behaviour.
09:44:43 <quicksilver> can you point me to a debate on this topic anywhere? mailing list archives?
09:44:52 <Cale> Where the whole expression is evaluated with that instance.
09:45:05 <Cale> I can at least point you at a paper...
09:45:46 <Cale> http://www.cas.mcmaster.ca/~kahl/Publications/Conf/Kahl-Scheffczyk-2001.ps.gz
09:45:49 <lambdabot> http://tinyurl.com/ynnsxt
09:46:23 <twanvl> A problem with this idea is that the behaviour can depend on the type signature, for example, (foo :: [Int]) behaves differently depending on whether or not foo has a polymorphic type.
09:47:10 <quicksilver> twanvl: I don't understand that comment
09:47:13 <Cale> That's something you get with typeclasses already to som extent though.
09:47:17 <Cale> some*
09:47:20 <quicksilver> twanvl: surely foo :: [Int] is quite clearly monomoprhic?
09:47:34 <Cale> quicksilver: he's saying under replacement of [Int]
09:47:54 <Cale> If you made it (Num a) => [a], it might behave entirely differently.
09:48:09 <twanvl> If I understand you correctly, if some module X exports foo :: Ord a => [a] will get changed instances, but if it exported foo :: [Int] it would not.
09:48:09 <quicksilver> like id :: a -> a behaves differently from id :: (a -> b) -> a -> b ?
09:48:21 <Cale> quicksilver: more differently than that :)
09:48:32 <quicksilver> twanvl: actually I meant, if it exports foo :: Ord a => [a] it can CHOOSE the instance
09:48:37 <quicksilver> twanvl: nothing changes
09:48:43 <quicksilver> I mean, nothing 'changes without the module knowing'
09:48:53 <Cale> quicksilver: It can choose the instance, or the rest of the program can?
09:48:55 <quicksilver> it's just the with the Ord type it's promising to provide a dictionary
09:49:16 <twanvl> quicksilver: (id example) that is not a behavioural difference, if the program compiles it always does the same thing.
09:49:27 <quicksilver> if you export foo :: (exists a . Ord a => [a]) then you are making a promise to return a dictionary
09:49:29 <Cale> Actually, I think some confusion here is that's not what the "Ord a =>" means.
09:49:49 <quicksilver> if you merely export foo :: Ord a => [a] then that is actually rather different
09:49:50 <Cale> It means that the *caller* promises to provide a dictionary.
09:50:02 <quicksilver> then you are promising 'for any Ord instance, I can return a list of them'
09:50:13 <quicksilver> (I strongly suspec that's an empty type)
09:50:22 <quicksilver> well, trivial ones only
09:50:28 <Cale> You can export something of type (C a => a) even when there are no instances of C visible in your module.
09:50:32 * quicksilver nods
09:50:36 <quicksilver> right
09:50:44 <quicksilver> (C a => a) <--- caller provides dictionary
09:50:53 <quicksilver> (exists a . C a => a) <--- module provides dictionary
09:50:57 <quicksilver> quite different
09:51:02 <Cale> right
09:51:16 <quicksilver> but this, presumably, is all true at the moment?
09:51:24 <quicksilver> I mean, that's how higher rank works?
09:51:36 <Cale> There is no 'exists' keyword actually.
09:51:56 <twanvl> There should be
09:51:57 <Cale> (In the implementation at least :)
09:52:20 <Cale> First class existentials make type inference hard.
09:52:27 <quicksilver> ah
09:52:38 <quicksilver> but you can fake it with a contravariant forall, right?
09:52:44 <quicksilver> so it's 'morally there'
09:52:48 <quicksilver> just a bit obfuscated
09:52:55 <Cale> Yeah, I suppose you can.
09:53:06 <twanvl> Not much harder if type signatures are required, as with all higher rank stuff.
09:53:07 <quicksilver> I'm pretty sure I've been to an SPJ talk where he admits that
09:53:12 <Cale> I think that's what paolino's been doing lately.
09:53:14 <quicksilver> and uses exists notation for haskell types :)
09:53:39 <Cale> Lucky, I wish I could go to talks by him :)
09:53:53 <ddarius> With impredicativity you can make an "Exists" type constructor.  I tried it a long time ago but it didn't work due to predicativity.
09:54:00 <Cale> Seriously, people, when are you going to start bringing video cameras to his talks? :)
09:54:31 <Cale> ddarius: right, the boxy types stuff might have changed that :)
09:54:42 <ddarius> Oh, I tried it again and it works.
09:54:51 <chessguy> that reminds me
09:55:59 <chessguy> @tell paolino you can darcs get http://catenova.org/~chessguy/GPLib once in a while to check out my code
09:55:59 <lambdabot> Consider it noted.
09:56:00 <Cale> GHC 6.7 has some delicious type system extensions.
09:56:24 <ddarius> If we had type lambdas, the constructs I made would be little worse to use than built-in existentials.  They aren't if you get lucky.
09:56:36 <Cale> I *really* like how he's made class contexts on data constructors mean what they ought to have meant all along.
09:56:40 * ddarius is curious about the debugger.
09:56:41 <quicksilver> blah stupid macs and their poor postcript support
09:56:42 <chessguy> @tell paolino that should be darcs get http://catenova.org/~awagner/GPLib sorry
09:56:42 <lambdabot> Consider it noted.
09:56:54 <quicksilver> That Kahl/Scheffcyzk paper comes out horribly with ps2pdf
09:57:02 <Cale> quicksilver: yeah, it's awful, I remember that
09:57:11 <quicksilver> I'll have to print it to read it
09:57:13 <quicksilver> :)
09:57:16 <Cale> Can you get hold of gv?
09:57:22 <quicksilver> Yes, clearly I can
09:57:29 <quicksilver> I'm slightly surprised I don't have it, I thought I did :)
09:57:36 <quicksilver> I definitely used to
09:58:08 <Cale> gv still does better at rendering postscript than anything else I've come across
09:58:19 <Cale> Evince comes close, but it still sucks on certain documents.
09:58:21 <quicksilver> Cale: my laserprinter does a pretty good job
09:58:25 <quicksilver> Cale: otherwise, I agree :)
09:58:27 <Cale> Well, yeah :)
09:58:41 <Cale> I'm talking about for screen display, of course :)
09:58:58 <EvilTerran> ghostscript's kinda the de facto benchmark for postscript viewers, i guess
09:59:18 <quicksilver> well time to go catch a train. I will think on this. I really think something lexical should work, and not be evil like implicit types.
09:59:22 <Cale> It's quite funny, because gv has this really antiquated UI.
09:59:56 <Cale> You'd think we'd at least be able to replicate its ability to render postscript.
10:01:18 <ddarius> What are you talking about anyways quicksilver?
10:02:00 <Cale> ddarius: A syntax for locally specifying instances to be applied.
10:02:45 <ddarius> To what end? or I don't get it.
10:03:00 <ddarius> Local instance declarations?
10:04:20 <Cale> yeah -- because for some things, (Ord and Monoid are popular in this regard), there are many possible instances one might want to use
10:05:13 <Cale> I took the Devil's Advocate stance here, although I've actually proposed similar things in the past.
10:05:34 <Cale> The potential for abuse really is something to be considered in the design though.
10:06:02 <ddarius> Cale: What kind of abuses did you forsee, that you thought were relatively likely?
10:06:26 <Cale> Well, done the obvious way, it basically lets you simulate implicit parameters.
10:07:49 <Cale> In some circumstances, it can have unintended effects on code, not just the ones which are immediately obvious from the expression that you wrote.
10:08:31 <ddarius> Cale: Such as?  And also, did you point him at the prior work on named instances (or had he already read it?)
10:09:05 <Cale> For example, you might locally specify a different Ord instance on Integers to sort some list specially, but the code which gets that list you're sorting, unbeknownst to you, also uses the Ord instance for Int, which you've just locally changed.
10:09:10 <ddarius> (Incidentally, at least the basics of named instances are easily simulable in Haskell, albeit not backward compatibly.)
10:09:16 <Cale> And perhaps that code relies on the usual behaviour.
10:09:40 <EvilTerran> Cale, surely the instance of choice would be lexically scoped?
10:10:01 <Cale> But sort isn't a method of Ord
10:10:10 <EvilTerran> actually, that sounds like it would be very awkward to implement, then
10:10:29 <Cale> You really do need to reach in and mess with the functions things are calling, but then you open yourself up to doing it inadvertently.
10:10:45 <Cale> There is one sane way I can see of doing it.
10:11:05 <ddarius> There is a design decision there about when to resolve the Ord instances, i.e. early or late.
10:11:19 <Cale> Require that the thing you're applying the named instance/local instance to explicitly has a class constraint for that class in its type
10:11:50 <Cale> and you're only going to influence the application in that one constraint
10:12:19 <Cale> So you'd have to apply the thing directly to sort itself, and not sort applied to the list.
10:12:30 <Cale> (i.e. while it's still polymorphic)
10:12:55 <EvilTerran> i have visions of associating each value with the instance lexically appropriate to where it is defined, and then only permitting use of Ord's methods between two Ints of the same instance (say. pick your own class and type.)
10:13:30 <ddarius> Cale: Would a named instances approach alleviate the problems this intends to solve in a cleaner way?
10:13:41 <EvilTerran> but i think it would be difficult to determine where (lexically speaking) a value is "defined"
10:14:02 <Cale> ddarius: The problems are still there, but it might be more convenient to use.
10:16:08 <ddarius> Anyways, back to work.
10:22:38 <davidmccabe> I am stuck without a haskell interpreted installed; is there one on the web?
10:22:43 <davidmccabe> or on IRC for that matter?
10:22:49 <EvilTerran> > fix show
10:22:50 <glguy> both
10:22:51 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
10:23:10 <davidmccabe> thanks.
10:23:16 * kc5tja has to admit . . .
10:23:33 <davidmccabe> I need something where I can define functions.
10:23:39 <EvilTerran> you can have /msg conversations with lambdabot, too
10:23:43 <davidmccabe> well, I could actually rewrite this as anons. nm.
10:23:50 <kc5tja> Despite the wonky sounding names of various concepts (monads -- they just sound RUDE and IMPOLITE to say in public!), it's a pretty nice language.  I'm quite happy with it.
10:23:56 <EvilTerran> it'll reply in greater length
10:24:18 <EvilTerran> @list
10:24:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:25:48 <davidmccabe> I need to test a recursive function using lambdabot or similar. any pointers?
10:26:39 <chessguy> umm, many functions are recursive
10:26:39 <EvilTerran> > let fact 0 = 1; fact n = n * fact(n-1) in fact 10
10:26:41 <lambdabot>  3628800
10:26:54 <davidmccabe> ah, I was missing the 'let'.
10:27:06 <davidmccabe> <--- new, harried.
10:27:45 <davidmccabe> nope, still getting parse errors.
10:27:51 <bd_> > let fact = (let f@(1:t) = 1:zipWith (+) f t in (f !!)) in fact 10
10:27:53 <lambdabot>  Exception: <<loop>>
10:27:56 <bd_> hm
10:28:03 <bd_> > let fact = (let f@(1:t) = 1:1:zipWith (+) f t in (f !!)) in fact 10
10:28:05 <lambdabot>  89
10:28:09 <davidmccabe>   <davidmccabe> > let foo x = x * 2
10:28:10 <davidmccabe> [10:25]  <lambdabot>  Parse error
10:28:12 <davidmccabe> doh.
10:28:18 <davidmccabe> nm, I see. my apologies.
10:28:19 <EvilTerran> you need an 'in'
10:28:22 <davidmccabe> right.
10:28:29 <bd_> > let fact = (let f = 1:1:zipWith (+) f (tail f) in (f !!)) in fact 10
10:28:31 <lambdabot>  89
10:28:35 <bd_> huh.
10:28:40 <EvilTerran> let definition; definition; definition in expression
10:28:43 <bd_> oh, fibonacci vs factorial
10:30:38 <EvilTerran> davidmccabe, the bot basically does anything that's a valid haskell expression (ie something that can be reduced to a value)
10:30:52 <davidmccabe> but it won't let me screw with its global namespace, huh? :P
10:31:02 <Syzygy-> Not really.
10:31:05 <EvilTerran> i seem to recall @let is currently broken, so i'm afraid so
10:31:15 <EvilTerran> @let xyzzy = "Nothing happens."
10:31:15 <Syzygy-> @let foo x = 2*x
10:31:16 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
10:31:16 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
10:31:20 <Syzygy-> Right.
10:32:36 <davidmccabe> um, by the way, has hoogle always looked so... you know...
10:33:01 <chessguy> ?hoogle map
10:33:02 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
10:33:02 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
10:33:02 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
10:33:10 <chessguy> looks fine with me
10:33:18 <chessguy> s/with/to/
10:41:46 <quicksilver> Cale: still around?
10:42:04 <Cale> quicksilver: yeah, though I should get going soon :)
10:44:19 <Cale> What's up?
10:45:58 <quicksilver> cale read that paper, anyhow (on the train now, could be a bit laggy)
10:46:15 <Cale> cool
10:46:25 <quicksilver> they are certainly trying to do something a bit different
10:46:26 <quicksilver> they're trying to make it (optionally) explicit
10:46:40 <quicksilver> whereas I'm suggesting that it could be made imploicit with a little explicit choice
10:47:05 <Cale> Oh, I think they're also keeping the implicit system around.
10:47:10 <Cale> No?
10:47:55 <UUStudent> how would one get really good at programming in haskell?
10:48:05 <glguy> by programming in Haskell
10:48:17 <UUStudent> I meant how do I even start?
10:48:22 <Cale> UUStudent: hang around here ;)
10:48:23 <Cale> ah
10:48:27 <UUStudent> :)
10:48:30 <Cale> You can try one of the tutorials :)
10:48:42 <UUStudent> can you gimme the link
10:48:51 <glguy> haskell.org
10:48:54 <Cale> Unless you have a background in ML, I recommend starting out with the wikibook and/or YAHT
10:48:57 <Cale> @where wikibook
10:48:58 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:49:01 <UUStudent> I'm pretty bad at coding, so I need to learn to think logically
10:49:02 <Cale> @where YAHT
10:49:02 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
10:49:08 <UUStudent> thanks :)
10:49:49 <Cale> YAHT is really pretty good for the early chapters, when it starts getting awkward, try switching to something else. I don't recommend learning monads from it, there are better monad tutorials.
10:50:12 <UUStudent> oh
10:50:15 <quicksilver> and that I think I can lexically scope that choice
10:50:16 <Cale> The wikibook is looking pretty good these days, but I think it still has some gaps.
10:50:17 <UUStudent> thanks guys
10:50:20 <petekaz> I'm still baffled by monads, and have yet to have the lightbulb click.
10:50:26 <mbishop> Oh, so I found that MissingH has a time library that does what I want heh
10:50:28 <Cale> Most importantly, hang around and ask lots of questions!
10:50:35 <UUStudent> hmmm
10:50:36 <UUStudent> sure
10:50:50 <kc5tja> Cale: Any suggestions for monad tutorials?  I've read YAHT and loved every bit of it.  Cover to cover in one day, plus as many exercises as I could.
10:51:16 <kc5tja> Although, I still take issue with the "point-free notation" being easier to read "as a rule."  I found a number of his so-called "easier" solutions were patently harder to read.
10:51:23 <Cale> mine :)
10:51:25 <kc5tja> Otherwise, it was a great tutorial.
10:51:37 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
10:51:39 <lambdabot> Title: Monads as containers - HaskellWiki
10:51:43 <Cale> also,
10:51:59 <Cale> http://www.nomaware.com/monads/ (but it's down at the moment)
10:52:03 <Cale> and...
10:52:05 <mbishop> ?where monads
10:52:06 <lambdabot> http://mbishop.esoteriq.org/stuff/allaboutmonads.pdf
10:52:08 <mbishop> ^
10:52:12 <Cale> ah, cool
10:52:22 <Cale> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html -- this is also good
10:52:23 <EvilTerran> shameless self-promotion, mbishop? ;]
10:52:25 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
10:52:31 <Cale> EvilTerran: he's mirroring it
10:52:39 <mbishop> EvilTerran: heh nah, it's the pdf from nomaware, because it's always down :|
10:52:40 <EvilTerran> o, right. hehe. nevermind.
10:52:58 <Cale> I recommend starting with Monads as Containers
10:53:07 <Cale> because I find that approach seems to sit the best with beginners
10:53:27 <Cale> but definitely read the others, because my approach isn't *really* the approach you'll use everyday
10:53:31 <glguy> ?protontorpedo
10:53:32 <lambdabot> so with 100s of users adn different daabases haskell does fine?
10:53:33 <Cale> (but it's a good first step)
10:54:25 <glguy> ?keal
10:54:25 <lambdabot> i still dont understand how gci is supposed to do anything other than mathematics
10:54:46 <Cale> If everyone already knew about writing combinator libraries, then monads would be much easier to explain :)
10:55:36 <petekaz> The thing about monads that confuse me is that some people use the IO monad as a starting point of discussion and start with the terms "actions" and such, but this seems like a special case of a monad and doesn't apply elseweher.  And then those that don't talk about IO, speak so broadly that one wonders how the IO monad fits in.  This is of course my opinion, and I'm still lost in terms of really understading monads.  I can use them,
10:55:37 <petekaz> but haven't figured out the transformer bit though.
10:55:44 <Cale> The real description of what monads are about in programming is that they're a particular method for structuring combinator libraries so that they can share code for control structures and similar things.
10:55:55 <Cale> But that's meaningless when you start out :)
10:56:11 <Cale> petekaz: yes, IO is the *worst* example of a monad.
10:56:21 <mbishop> I found the idea of monads to be simple, but their actual USE is pretty hard to understand heh
10:56:35 <Cale> yeah
10:56:49 <Cale> There's almost nothing to them, when you get right down to it.
10:56:58 <quicksilver> Cale: yes, they keep the implicit system around. But what they really propose is a direct (although incomplete) interface to the underlying dictionary-passing semantics.
10:57:05 <Cale> But there are lots of important examples to learn.
10:57:07 * glguy tries to think of a common moand that doesn't work well in terms of "actions"
10:57:09 <quicksilver> Cale: 'dictionary application', explicitly
10:57:10 <petekaz> Not only using them, but using them with other monads.
10:57:32 <quicksilver> glyCont
10:57:41 <quicksilver> glguy: cont, that is :)
10:57:50 <EvilTerran> I came across an unusual analogy for stateful monads; someone described them to me as "foo >>= bar runs foo in one interpreter, with one state, then runs bar in a fresh interpreter with a new state"
10:57:53 <Cale> I like to think of transformers as a way to *construct* monads, not as something to be used lightly in the middle of other code.
10:58:07 <Cale> They're used to start writing whole libraries.
10:58:35 <glguy> quicksilver: in Cont, the action that can occur is that the follow can jump
10:58:56 <Cale> There should be a small finite number of lifts confined to one module where you're defining some operations, and where the monad is actually used, you shouldn't have any.
10:59:04 <Cale> (except possibly liftIO)
10:59:17 <glguy> s/follow/flow
10:59:30 <Cale> Hello doserj
10:59:37 <Cale> Are you new here?
10:59:54 <doserj> yes
10:59:56 <quicksilver> Cale: Anyhow, I decided which lexical site I want. Not the function, not the parameter. but he *application* itself. The instance used is the instance in-scope at point-of-application.
11:00:06 <Eighty> @hoogle unsafeperformio
11:00:06 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
11:00:17 <quicksilver> glguy: I don't think that accounts very well for the fact that the other 'actions' may happen more than once or not at all, in complicatied patterns.
11:00:48 <glguy> quicksilver: specifically in Cont?
11:00:58 <Cale> Eighty: watch out! :)
11:01:06 <glguy> doserj: we are having an open house today
11:01:20 <Cale> doserj: learning Haskell?
11:01:27 <chessguy> ?users
11:01:28 <lambdabot> Maximum users seen in #haskell: 317, currently: 289 (91.2%), active: 32 (11.1%)
11:01:44 <davidmccabe> is there a big difference between list comprehensions and filter&map other than syntax?
11:01:59 <doserj> playing with it, when I have time...
11:02:06 <glguy> > [ (x,y) | x <- [1..3], y <- [4..5] ] -- sort of
11:02:07 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:02:10 <Cale> davidmccabe: no, list comprehensions are converted into concatMap, and filter
11:02:20 <glguy> davidmccabe: concatMap rather than map
11:03:04 <Cale> [ (x,y) | x <- [1..3], y <- [4..5] ]
11:03:06 <Cale>  = concatMap (\x -> [(x,y) | y <- [4..5]]) [1..3]
11:03:26 <Cale>  = concatMap (\x -> concatMap (\y -> (x,y)) [4..5]) [1..3]
11:03:39 <petekaz> I just started reading School of Expression.  I'm hoping this will be a useful text.  My problem with Haskell thus far is that there are so few books on the practical use of it.  The same problem existed for Common Lisp until recently when someone wrote "Practical Common Lisp" which was an EXCELLENT book.  Somenone should mirror that book in Haskell and it would be an instant hit.  Here is its table of contents:
11:03:40 <petekaz> http://www.gigamonkeys.com/book/
11:03:41 <lambdabot> Title: Practical Common Lisp
11:03:41 <Cale> er
11:03:43 <glguy> Cale: -> [
11:03:46 <Cale>  = concatMap (\x -> concatMap (\y -> [(x,y)]) [4..5]) [1..3]
11:03:46 <glguy> missing list
11:03:47 <Cale> rather
11:03:50 <Cale> yes
11:04:01 <Cale> > concatMap (\x -> concatMap (\y -> [(x,y)]) [4..5]) [1..3]
11:04:02 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:04:05 <Cale> yes :)
11:04:06 <glguy> I knew that if I didn't hit return soon, you'd have corrected it :-p
11:04:18 <davidmccabe> From the description in the prelude, I don't really understand the difference between map and concatMap.
11:04:32 <Cale> concatMap f xs = concat (map f xs)
11:04:33 <petekaz> Re: PCL, maybe not mirror it exactly, but you get the point.  Lots of practical examplse.
11:04:38 <EvilTerran> > map (\x -> [x]) [1..10]
11:04:40 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
11:04:43 <EvilTerran> > concatMap (\x -> [x]) [1..10]
11:04:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:04:52 <Cale> But concatMap can be implemented more efficiently than concat (map f xs)
11:05:14 <Cale> > concatMap (\x -> [x,x*10]) [1..9]
11:05:15 <lambdabot>  [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90]
11:05:21 <glguy> > (x -> [x]) =<< [1..10]
11:05:22 <lambdabot>  Parse error
11:05:23 <EvilTerran> > concat [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]] -- for good measure
11:05:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:05:26 <glguy> > (\x -> [x]) =<< [1..10]
11:05:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:05:31 <davidmccabe> ok, gotcha.
11:05:43 <Cale> (=<<) = concatMap, for the list monad
11:05:44 <EvilTerran> glguy, that's just being obscure ;]
11:06:01 <glguy> EvilTerran: not after you've been playing with haskell for at least 1 month
11:06:22 <EvilTerran> well, i don't know how long davidmccabe's being playing with haskell... *shrug*
11:06:22 <Cale> I actually rather like using >>= in that way.
11:06:39 <EvilTerran> it's terser than concatMap
11:06:39 <Cale> so...
11:06:42 <glguy> EvilTerran: well, it's still important that he be exposed to new things :)
11:06:54 <Cale> > do x <- [1..3]; y <- [4..5]; return (x,y)
11:06:55 <EvilTerran> altho i suspect you might get accusations of "you're not writing in perl, dammit!"
11:06:56 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:07:11 <Cale> The list monad is roughly equivalent to list comprehensions.
11:07:12 <glguy> EvilTerran: but we usually kick the trolls like that out of the channel
11:07:23 <Cale> You can use the guard function to implement conditions.
11:07:25 <EvilTerran> i joke, i joke
11:07:39 <Cale> > do x <- [1..3]; y <- [1..3]; guard (x < y); return (x,y)
11:07:41 <lambdabot>  [(1,2),(1,3),(2,3)]
11:07:53 <Cale> > [(x,y) | x <- [1..3], y <- [1..3]; x < y]
11:07:54 <lambdabot>  Parse error
11:07:58 <Cale> > [(x,y) | x <- [1..3], y <- [1..3], x < y]
11:08:00 <lambdabot>  [(1,2),(1,3),(2,3)]
11:08:30 <Cale> hehe
11:08:34 <Cale> okay :)
11:08:41 <Cale> I'm off.
11:08:52 <glguy> > [(x,y) | x <- [1..3], y <- [x+1 .. 3]]
11:08:54 <lambdabot>  [(1,2),(1,3),(2,3)]
11:09:01 <glguy> cya
11:09:22 <chessguy> ?hoogle guard
11:09:23 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
11:09:23 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
11:09:23 <lambdabot> Language.Haskell.TH.Guard :: data Guard
11:10:01 <chessguy> ?src Monad.guard
11:10:01 <Saizan> ?src IO guard
11:10:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:10:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:10:12 <Saizan> ?src guard
11:10:12 <lambdabot> guard True  =  return ()
11:10:13 <lambdabot> guard False =  mzero
11:10:22 <Saizan> ?src IO mzero
11:10:22 <lambdabot> mzero       = ioError (userError "mzero")
11:10:41 <glguy> Saizan: :use the *source*
11:10:46 <glguy> ;-D
11:10:51 <Saizan> :D
11:11:35 <Saizan> mmh i've reinvented it as when (not p) (fail "foo")
11:12:05 <Saizan> though mine works for any monad :)
11:12:39 <hyrax42> ?djinn (a -> (b,c)) -> a -> (b,c)
11:12:39 <lambdabot> f a = a
11:12:46 <glguy> :t unless
11:12:49 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:12:54 <glguy> Saizan: ^
11:13:00 <hyrax42> ?djinn (a -> b, a -> c) -> a -> (b,c)
11:13:01 <lambdabot> f (a, b) c = (a c, b c)
11:13:48 <EvilTerran> @pl f (a, b) c = (a c, b c)
11:13:49 <lambdabot> f = uncurry (liftM2 (,))
11:15:04 <Saizan> mmh a little different, byt maybe cleaner
11:15:48 <glguy> ?src unless
11:15:48 <lambdabot> unless p s = if p then return () else s
11:16:10 <glguy> ?src when
11:16:11 <lambdabot> when p s = if p then s else return ()
11:16:15 <Saizan> glguy: note the fail
11:16:30 <glguy> Saizan: no, the point is that you never need: when (not p)
11:16:36 <glguy> Saizan: that is; unless p
11:17:07 <Saizan> aah ok, missed that
11:17:11 <tcr> Is anyone here involved in the development of Hugs?
11:19:43 <Saizan> ?paste
11:19:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:20:54 <hpaste>  Saizan pasted "style question" at http://hpaste.org/569
11:22:12 <glguy> Saizan: sequence_ (intersperse blank [code,w,h,max,pgmRastex])
11:23:03 <glguy> Saizan: and I would either only use the let, or only use the where
11:24:40 <Saizan> glguy: heh, that's a bit of a habit i've from imperative coding, i use lets as i would use variables, and where for helper functions
11:24:57 <glguy> code was a helper function?
11:25:00 <Saizan> would intersperse be optimized away?
11:25:13 <Saizan> a contant one ^^
11:25:39 <glguy> Saizan: if it wasn't, would that actually matter in this case?
11:25:40 <EvilTerran> hyrax42, Saizan, surely "f (a, b) c = (a c, b c)" is (&&&)?
11:26:01 <glguy> > (succ &&& pred) 4
11:26:02 <lambdabot>  (5,3)
11:26:07 <glguy> EvilTerran: so no..
11:26:10 <EvilTerran> well, uncurry (&&&)
11:26:47 <EvilTerran> let f = uncurry (&&&) in f ((+1), (*2)) 3
11:26:51 <EvilTerran> > let f = uncurry (&&&) in f ((+1), (*2)) 3
11:26:52 <lambdabot>  (4,6)
11:27:04 <hpaste>  glguy annotated "style question" with "maybe taken a little too far?" at http://hpaste.org/569#a1
11:27:49 <Saizan> glguy: no, would it matter if it was? like, would it be recreated each call of put if it was in a let?
11:28:42 <glguy> Saizan: it isn't going to be inlined  Idon't think, but I can't see why that matters
11:28:52 <glguy> !say alive?
11:28:53 <hpaste> alive?
11:29:20 <glguy> can anyone else get to hpaste.org?
11:29:25 <chessguy> works for me
11:29:33 <Saizan> me too
11:29:44 <EvilTerran> slow here, but working
11:30:01 <EvilTerran> looks like a sluggish DNS or something, it's fast after the first time it loads
11:30:22 <glguy> I think my work network is just screwing up...
11:33:15 <glguy> Saizan: you are writing a Binary instance?
11:35:46 <Saizan> Saizan: the third, or fourth
11:36:30 <hyrax42> EvilTerran: yeah
11:36:44 <hyrax42> I was doing nothing particularly interesting
11:37:19 <hyrax42> the other one was ($)
11:38:02 <EvilTerran> i note @djinn doesn't @hoogle for a type match. i guess that'd be cheating.
11:38:06 <Saizan> [[Bool]] --> .pbm, Seq (Seq Bool) --> .pbm, UArray (Int,Int) Bool -> .pbm, and now Integral a => UArray (Int,Int) a --> .pgm
11:38:16 <hyrax42> with a more specific type I suppose
11:38:35 <EvilTerran> @hoogle (a -> b, a -> c) -> a -> (b,c)
11:38:36 <lambdabot> No matches, try a more general search
11:38:48 <hyrax42> hoogle will be sorted out soon, we are told :p
11:38:49 <EvilTerran> @hoogle (a -> b) -> (a -> c) -> a -> (b,c)
11:38:50 <lambdabot> No matches, try a more general search
11:39:27 <EvilTerran> actually, now i think about it, (&&&)'s in terms of arrows, not (->)s.
11:39:56 <hyrax42> ?hoogle Arrow r => r a b -> r a c -> a -> (b,c)
11:39:57 <lambdabot> No matches, try a more general search
11:40:16 <hyrax42> well I'd hope that hoogle would do taht kind of thing
11:40:24 <hyrax42> :t (&&&)
11:40:26 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:40:46 <hyrax42> ?hoogle (a -> b) -> Maybe a -> Maybe b
11:40:46 <lambdabot> No matches, try a more general search
11:41:01 <hyrax42> that should return fmap and liftM imo
11:41:18 <hyrax42> ohh my type was wrong of course
11:41:33 <hyrax42> ?hoogle Arro r => r a b - > r a c -> r a (b, c)
11:41:34 <lambdabot> Hoogle Error: Parse Error: Unexpected character '- > r a c '
11:41:40 <hyrax42> ?hoogle Arrow r => r a b - > r a c -> r a (b, c)
11:41:40 <lambdabot> Hoogle Error: Parse Error: Unexpected character '- > r a c '
11:41:47 <hyrax42> ?hoogle Arrow r => r a b -> r a c -> r a (b, c)
11:41:48 <lambdabot> Prelude.asTypeOf :: a -> a -> a
11:41:48 <lambdabot> Prelude.const :: a -> b -> a
11:41:48 <lambdabot> Prelude.seq :: a -> b -> b
11:42:08 <EvilTerran> "that kind of thing"; automatically try searching for more generalised types of the given type?
11:42:34 <hyrax42> well search using known contexts
11:43:16 <hyrax42> we have instance Functor Maybe and instance Monad Maybe that would give functions with the desired type
11:43:17 <EvilTerran> so, "given a -> Maybe a", it'd also try "Monad m => a -> m a", "Functor f => a -> f a", and so forth
11:43:24 <hyrax42> yeah
11:43:28 <EvilTerran> s/"given /given "/
11:43:39 <hyrax42> I *think* it's all coming in hoogle 4
11:43:45 <hyrax42> but I forget who even does hoogle
11:43:47 <mbishop> Hmm, how can I get the difference between two epochtime's?
11:43:47 <hyrax42> ?where hoogle
11:43:48 <lambdabot> http://www.haskell.org/hoogle
11:44:08 <hyrax42> what module does it live in?
11:44:18 <EvilTerran> and, given "(b -> c) -> ...", it'd also try "Arrow a => a b c"....
11:44:25 <hyrax42> ok I thought it was neil mitchell
11:44:34 <hyrax42> EvilTerran: aye that would be ideal
11:45:42 <EvilTerran> and then teach djinn to use it to find some really arcane combinations >:]
11:46:10 <hyrax42> eep
11:49:02 <sendark> hey there, if i have a type CSP = ([Var], Domains, ConstrTab, Assign) and i need to write a fuction that given a CSP looks for the Assign and returns it, how do i do it?
11:49:14 <kc5tja> Cale: Your tutorial (via the containers) is -- different.  :)  I, however, definitely don't find fmap and join to be easy.
11:49:25 <kc5tja> But I'll trudge on.
11:49:53 <mbishop> http://programming.reddit.com/info/15ne0/comments
11:49:54 <mbishop> awww
11:49:55 <lambdabot> Title: Python vs. Ruby at the c2.com wiki (reddit.com)
11:50:04 <mbishop> silly reddit users
11:51:24 <kc5tja> What is reddit?
11:51:31 <kc5tja> I've seen that phrase several times, but never knew what it was.
11:52:52 <Saizan> kc5tja: a kind of a social bookmarking site, the relevant bit is the programming section, programming.reddit.com
11:53:03 <ctkrohn> the main reddit has really gone downhill lately ;_l
11:53:28 <ctkrohn> programming.reddit is still pretty good
11:53:39 <hyrax42> ?djinn (a,b,c,d) -> d
11:53:40 <lambdabot> f (_, _, _, a) = a
11:53:44 <hyrax42> sendark: ^^^
11:54:05 <sendark> yea
11:54:11 <sendark> cheers mate
11:54:16 <hyrax42> np
11:55:56 <kc5tja> Saizan: All I see.
11:59:11 <hyrax42> programming reddit is pretty crappy too now I think
11:59:15 <hyrax42> lots of garbage posted
11:59:17 <hyrax42> dupes
11:59:18 <hyrax42> etc.
11:59:29 <hyrax42> it's good to read about things you know nothing about
12:00:14 <hyrax42> but once you have a modicum of understanding, most of the stuff posted is handwavy bullshit
12:00:25 <hyrax42> I find especially wrt haskell
12:00:28 <hyrax42> anyway I'm out
12:17:47 <Cale> kc5tja: well, they're not necessarily easy, but they're simpler than bind
12:18:40 <Cale> kc5tja: Reddit is a place where people post links to things, vote on them and discuss them.
12:18:59 <Cale> ah, someone answered that :)
12:19:27 <sendark> @hoogle sortBy
12:19:28 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:19:35 <Cale> Yeah, programming reddit's been pretty poor, I've been thinking of adapting hpaste into something reddit-like.
12:19:43 <sendark> @hoogle Ordering
12:19:43 <lambdabot> Prelude.Ordering :: data Ordering
12:19:44 <mbishop> do it!
12:19:58 <glguy> ?seen sorear
12:19:58 <lambdabot> I saw sorear leaving #darcs, #ghc, #haskell and #happs 14h 9m 16s ago, and .
12:20:23 <Cale> I wonder if I'd go for such a democratic model. They always seem to fall apart eventually.
12:20:31 <glguy> Speaking of hpaste, I'd like to see sorear's idea come to fruition to have a Protocols.IRC in HAppS for hpaste to use
12:20:37 <kc5tja> Cale: i found it much easier to think of the monad as a box containing something (not a plurality), and bind is a function that works on the contents of that box.  In other words, just leave fmap and join out of it, because I see it as royally confusing.  :)
12:21:00 <glguy> Cale: I think there should be an invite model
12:21:04 <Cale> kc5tja: note, the monad isn't the computations/containers
12:21:20 <Cale> Maybe is a monad, Just 5 isn't.
12:21:20 <kc5tja> Correct.
12:21:27 <kc5tja> I know that.
12:21:39 <Cale> kc5tja: ah, okay
12:21:39 <glguy> State Int is a monad, State is not ! :)
12:21:44 <mbishop> Cale: screw democracy, make it a dystopian wasteland!
12:21:46 <Cale> glguy: indeed :)
12:21:47 <sendark> how does an ordering function work? i want to sort a list of tuples by the number of legal values they hold in an array. I know how to look for the number of legal values, i just dont know how to write an Ordering function
12:21:52 <Cale> mbishop: haha
12:22:14 <glguy> I think that the invite system should allow you to figure out who invited a user
12:22:26 <glguy> so that people would be less likely to invite the idiots from reddit into it
12:22:30 <Cale> @src Ordering
12:22:31 <lambdabot> data Ordering = LT | EQ | GT
12:22:35 <glguy> for sake of mass ridicule
12:22:45 <sendark> where LT EQ and GT stand for?
12:22:55 <kc5tja> Less Than, EQual, Greater Than
12:22:56 <glguy> less then equal to and greaterthen
12:22:58 <glguy> than*
12:22:59 <Cale> Less Than, Equal, Greater Than
12:23:05 <sendark> ah that makes sense :D
12:23:12 <alexj> glguy: and perhaps any inviter has the power to disinvite the tree resulting from the invite
12:23:38 <Cale> hmm :)
12:24:27 <mbishop> glguy: that doesn't sound like a bad idea actually, after you submit a certain number of possitve links, you get a few invites to invite people
12:25:01 <Cale> Yeah, that'd make you less likely to invite idiots.
12:28:59 <ndm> @seen dons
12:28:59 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 6h 6m 4s ago.
12:36:51 <kitto>    CHK the new version of C99 SHELL with SAFE MODE bypass WORK test there +++>>>   !!!PRIVATE!!!   http://www.dachkomplett.at/images/start/c99.c?   !!!PRIVATE!!! <<<+++          MOROCCO RULEZ
12:37:13 --- mode: ChanServ set +o glguy
12:37:15 <SamB> what the hell?
12:37:15 --- mode: glguy set +b *!*n=kiTToR@*.fbx.proxad.net
12:37:15 --- kick: kitto was kicked by glguy (glguy)
12:37:45 <mbishop> haha
12:37:47 <Cale> wow, that's nuts
12:37:49 <mbishop> C99 shell huh
12:37:56 <SamB> hah
12:38:04 <SamB> <?php $_F=__FILE__;$_X='Pz48P3BocCANCi8vU3QxcnQ0bmcgYzFsbHMgDQo0bjRfczV0KCJtMXhf
12:38:04 <SamB> NXg1YzN0NDJuX3Q0bTUiLDApOyANCjRmICghZjNuY3Q0Mm5fNXg0c3RzKCJnNXRtNGNyMnQ0bTUiKSkg
12:38:09 <glguy> I saw that message in the hpaste debugging output and switched windows over here to get my /kn in
12:38:10 <SamB> that is how it starts...
12:38:21 <Cale> wtf?
12:38:42 <SamB> apparantly it was supposed to be a php script?
12:38:50 <SamB> but isn't interpreted for some reason
12:40:43 <bringert> what? happs can't run php exploits?
12:41:09 <SamB> bringert: dude, that wasn't pasted to hpaste
12:41:34 <glguy> I should add that as a feature
12:41:43 <glguy> [ ] check here if this should be run as php code
12:42:16 --- mode: glguy set -b *!*n=kiTToR@*.fbx.proxad.net
12:42:31 <glguy> (/kn has a default 4 minute timeout)
12:42:35 <glguy> 5 minute
12:42:35 <sendark> is there a function that counts the number of elements in alist?
12:42:43 --- mode: glguy set -o glguy
12:42:47 <sendark> something like the python lenghtOf
12:42:49 <bringert> SamB: what's it from?
12:42:57 <bringert> maybe I missed some context here
12:43:11 <SamB> <kitto>    CHK the new version of C99 SHELL with SAFE MODE bypass WORK test there +++>>>   !!!PRIVATE!!!   http://www.dachkomplett.at/images/start/c99.c?   !!!PRIVATE!!! <<<+++          MOROCCO RULEZ
12:43:12 <glguy> sendark: length
12:43:12 <sendark> yes sendark, length
12:43:17 --- mode: ChanServ set +o glguy
12:43:19 --- mode: glguy set +b *!*i=naesten@*.c3-0.upd-ubr7.trpr-upd.pa.cable.rcn.com
12:43:19 --- kick: SamB was kicked by glguy (glguy)
12:43:26 <sendark> sorry should look a bit for it before i go around askin
12:43:27 <ndm> @hoogle [a] -> Int
12:43:28 <lambdabot> Prelude.length :: [a] -> Int
12:43:32 --- mode: glguy set -b *!*i=naesten@*.c3-0.upd-ubr7.trpr-upd.pa.cable.rcn.com
12:43:41 <ndm> sendark: you can use Hoogle to ask for you :)
12:43:52 <SamB> whoops
12:43:57 --- mode: glguy set -o glguy
12:43:58 <glguy> :-p
12:44:10 <SamB> glguy: you try it now ;-P
12:44:11 <bringert> SamB: ah, I see
12:44:20 <JohnMeacham> everyone knows zsh is way better than csh anyway.
12:44:21 * SamB wants to see if glguy can autoban himself
12:44:25 <bringert> hmm, what's that for?
12:44:28 <glguy> SamB: that wasn't an autoban
12:44:34 <glguy> that was me shooting from the hip!
12:44:40 <SamB> oh
12:45:07 --- mode: ChanServ set +b *!*@4.38.41.141
12:45:19 <glguy> oh dang burn!
12:46:25 <paolino> :t zipWithM
12:46:26 <lambdabot> paolino: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:46:28 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
12:48:47 <sendark> hey, a little doubt about the scope of haskell. If i call a function in a function, i need to define the function i'm calling higher up in the code than the one that is calling the function right?
12:49:05 <ndm> sendark: no, anywhere is fine
12:49:09 <SamB> heh
12:49:14 <sendark> neato
12:49:17 <SamB> never seen a "where"?
12:49:29 <paolino> :t zipWithM ($)
12:49:32 <lambdabot> forall a (m :: * -> *) c. (Monad m) => [a -> m c] -> [a] -> m [c]
12:49:38 <ndm> sendark: in general Haskell is written for humans, not for compilers
12:49:39 <glguy> > let x = y; y = 1 in x -- for sendark
12:49:39 <Cale> sendark: you can even make functions mutually recursive
12:49:41 <lambdabot>  1
12:49:48 <sendark> yea, i know about recursion
12:49:50 <sjanssen> sendark has obviously been damaged by writing C code :)
12:49:53 <sendark> nah
12:49:54 <sendark> python
12:49:59 <sendark> and java.
12:50:02 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
12:50:03 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
12:50:04 <ndm> doesn't python let you declare anywhere?
12:50:09 <sendark> yep
12:50:10 <ndm> Java certainly does
12:50:12 <Cale> check that out :)
12:50:27 <SamB> ndm: as long as you don't call stuff before defining it
12:50:30 <nornagon> Cale: woah
12:50:40 <ndm> > [0,2..]
12:50:42 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
12:50:45 <nornagon> Cale: that's pretty cool
12:50:52 <SamB> you can write your calls before you define the called things, just as long as you don't let them be invoked first...
12:51:02 <psnl> ndm: python has interesting scoping rules.
12:51:04 <glguy> ndm: your's is boring!
12:51:14 <Cale> ndm: hehe, yes, but that wouldn'e illustrate values defined through mutual recursion :)
12:51:20 * ndm thinks circular programming should be taught to experience people, its way too easy to foot shoot!
12:51:21 <Cale> t
12:51:34 <sendark> i love giving gurus conversation
12:51:36 <ndm> psnl: Python is next on my list of things to learn
12:51:39 <psnl> ndm: a bit like english then? ;-)
12:51:41 <ndm> psnl: you coming to FITA?
12:51:47 <psnl> ndm: aye
12:51:48 <sendark> ndm: python is a piece of cake
12:51:51 <ndm> psnl: technically english is first on my list
12:52:07 <ndm> psnl: cool, hopefully this time i'll get a better chance to meet you, and not have to rush off so soon after
12:52:16 <SamB> ndm: why in the world would you want to learn a silly thin like that?
12:52:25 <psnl> ndm: we might have to rush off too
12:52:34 <ndm> SamB: its the least broken imperative programming language, as far as i am aware
12:52:43 <Cale> The long and short of it though is that it doesn't matter where you declare things. The only place where ordering of declarations matters is when you have a bunch of pattern matches in a function declaration -- the first one to succeed wins.
12:52:47 <SamB> english is imperative now?
12:52:47 * psnl wanders off to the next pancake praty
12:52:53 <psnl> party, even
12:52:56 <glguy> I need about 192 request to http://hpaste.org to get over the 75k mark plz
12:52:58 <glguy> kthnxby
12:53:02 * ndm has enough sugar in his system for the next few days
12:53:30 <ndm> SamB: english is entirely broken, but first on my list of things to learn
12:53:39 <ndm> although i'm trying to write as much of my paper in Haskell as I can
12:53:50 <SamB> ndm: yes, but, why would you want to learn it?
12:53:53 * sendark wonders why anglo-saxons replaced the catholic crazy party of carnival by silly pancake parties.
12:54:44 <paolino> :t fmap read
12:54:45 <ndm> SamB: some times you  need to play the imperative game, and my best imperative languages at the mo are Javascript/C#/VB
12:54:47 <lambdabot> forall a (f :: * -> *). (Read a, Functor f) => f String -> f a
12:54:59 <SamB> no, why english?
12:55:21 <ndm> SamB: because i have to write it
12:55:28 <glguy> can you win the imperative game?
12:55:40 <ndm> SamB: apparently annotated source listings do not count as academic papers :(
12:55:43 <sjanssen> glguy: there are no winners in the imperative game
12:56:01 <glguy> Oh, but you can get payed to play, right?
12:56:03 <ndm> (although a million typing rules does, i don't write the rules...)
12:56:58 <sjanssen> what happens if your typing rules are executable?
12:57:44 <ndm> i don't understand typing rules, i just see talks that consist of lots of them
12:57:47 <SamB> ndm: have we told you about "literate programming"?
12:57:49 <ndm> and get some "nap time"
12:58:17 <sjanssen> ndm: I skip those too :)
12:58:19 <ndm> SamB: my paper is a literate program, but you have to put bits between \end{code} and \begin{code}
12:58:26 <glguy> ?hoogle intersperseM_
12:58:27 <lambdabot> No matches found
12:58:28 <glguy> :(
12:58:41 <SamB> yeah, I suppose Haskell really doesn't need literate programming tools ;-)
12:58:50 <SamB> lhs is good enough...
12:59:01 <ndm> lhs is the literate programming tool...
12:59:26 <ndm> i have now written an english checker in haskell, to run over my paper
12:59:32 <ndm> DrEnglish
13:00:04 <SamB> you have to be kidding!
13:00:22 <ndm> @where+ DrEnglish http://www.cs.york.ac.uk/fp/darcs/drenglish
13:00:23 <lambdabot> Done.
13:00:28 <glguy> that's called *procrastination*
13:00:35 <ndm> originally called Auto-Colin
13:00:49 <ndm> after my supervisor, who corrects my grammar all the time
13:01:01 <ndm> i wrote this ages ago
13:01:06 <ndm> its a time saver in the end!
13:02:30 <ndm> the scary thing is now i'm not the only one in my department who auto-colin's their work
13:02:50 <matthew-_> does colin?
13:03:58 <ndm> nah, this is strictly for those people who aren't colin
13:09:20 <glguy> ahh, a spoonful of honey helps the sugar go down...
13:09:54 <mbishop> Careful, 1 spoonful to calm you down, 2 to help you sleep, but 3 spoonfuls and you'll sleep so long, you never wake up!
13:10:07 <SamB> glguy: s/sugar/medicine/ s/honey/sugar/
13:10:21 <glguy> SamB: OH, is that what I've been doing wrong??
13:10:34 <SamB> yes
13:10:44 <SamB> misquoting mary poppins is very bad for you
13:11:30 <glguy> well, I'm going to keep eating honey and misquoting poppins until hpaste hits 75k ;)
13:12:05 <mbishop> I think I probably misquoted futurama there
13:12:06 * mbishop shrugs
13:12:23 <glguy> it's been a long time since  Iwatched too much futurama
13:29:09 <glguy> in http://kakapo.scannedinavian.com/~eric/hpaste/DiffHtml.hs
13:29:33 <glguy> is the x'ge'lenx and y'ge'leny manual CSE stuff actually buying anything?
13:42:21 <alexj> @seen igloo
13:42:21 <lambdabot> igloo is in #haskell, #darcs and #ghc. I last heard igloo speak 6h 3m 22s ago.
13:58:26 <sendark> @hoogle filter
13:58:27 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
13:58:27 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
13:58:27 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
14:01:59 <sendark> is there a function that given two lists removes every ocurrence of the elements of the first list from the second list?
14:02:18 <ndm> > "neil" \\ "ei"
14:02:19 <lambdabot>  "nl"
14:02:37 <ndm> @hoogle Eq a => [a] -> [a] -> [a]
14:02:37 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
14:02:38 <lambdabot> List.intersect :: Eq a => [a] -> [a] -> [a]
14:02:38 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
14:02:45 <mauke> > "aaa" \\ "ab"
14:02:47 <lambdabot>  "aa"
14:03:04 <ndm> sendark: ^^
14:03:14 <alexj> @seen musasabi
14:03:14 <lambdabot> musasabi is in #happs, #ghc, #haskell-blah and #haskell. I don't know when musasabi last spoke.
14:03:26 <sjanssen> glguy: I doubt the manual CSE is helping you there
14:03:46 <sendark> so if
14:03:53 <sjanssen> glguy: >= on Ints is so cheap it probably doesn't matter
14:04:00 <sendark> > [1..9] // [2,3,4]
14:04:01 <lambdabot>  Couldn't match expected type `Array i e'
14:04:15 <sendark> > [1..9] \\ [2,3,4]
14:04:17 <lambdabot>  [1,5,6,7,8,9]
14:04:20 <sendark> awesome
14:04:48 <mauke> > [1,1,2,2,3,3] \\ [1,2,3]
14:04:50 <lambdabot>  [1,2,3]
14:05:35 * sendark buys lambdabot the finest can of robot oil.
14:06:03 <der_igel> > [1,1,2,2,3,3] \\ [1,2,3,1]
14:06:04 <lambdabot>  [2,3]
14:06:57 <bos31337> @hoogle ap
14:06:58 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
14:06:58 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
14:06:58 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
14:07:09 <sjanssen> @src \\
14:07:10 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:07:38 <glguy> sjanssen: alright, I don't actually know which patch added that, I was just surprised to see it :)
14:08:12 <mauke> @src (\\)
14:08:13 <lambdabot> (\\) = foldl (flip delete)
14:09:12 <ndm> @tell dons @src \\ should work, not insult the user!
14:09:13 <lambdabot> Consider it noted.
14:16:12 <tibbe> if I have a function that can be implemented in different ways but with the same behaviour should I use a type class to allow one to switch between the versions?
14:16:25 <tibbe> or should I just use the same name and have the user change the import?
14:16:40 <mahogny> when would one want to change?
14:17:57 <shapr> Hey, who's the maintainer for Network.HTTP now?
14:18:05 <shapr> For some reason I'm thinking it kolmodin.
14:18:48 <sjanssen> shapr: bringert I think
14:19:27 <monochrom> How do you get typeclasses to work that way?
14:19:52 <xerox> Maybe using an index type.
14:20:51 <xerox> (I mean, a phantom type to do indexing.)
14:20:55 <monochrom> bjorn bringert does Network.HTTP
14:21:04 <xerox> (But it's really crude.)
14:21:52 <monochrom> It's probably very weird to use the typeclass way.
14:22:17 <shapr> sjanssen: Ok, thanks.
14:23:27 <monochrom> The module way will look like this in use.  import qualified ImplA; import qualified ImplB; main = print (ImplA.func 0 + ImplB.func 0).
14:29:30 <glguy> > map ( flip showHex "" ) [249, 243]
14:29:32 <lambdabot>  ["f9","f3"]
14:30:13 <Terabyte> hey
14:30:13 <davidmccabe> > let qs c [] = []; qs c (x:xs) = qs c (filter (c x) xs) ++ [x] ++  qs c (filter (c x) xs); l = [5,4,-9,-2] in qs (<) l
14:30:15 <lambdabot>  [5]
14:30:20 <davidmccabe> any ideas why that doesn't work?
14:30:49 <araujo> hello
14:31:04 <xerox> > let qs [] = []; qs (x:xs) = qs (filter (<x) xs) ++ [x] ++ qs (filter (>= x) xs) in qs [5,4,-9,-2]
14:31:05 <lambdabot>  [-9,-2,4,5]
14:31:11 <Terabyte> (off the topic) Just out of interest.. what would people say the difference between (if any) a presentation and a lecture is?.. what does a presentation have that a lecture doesn't (visa versa) and don't say powerpoint!
14:31:18 <davidmccabe> oh, duh, I need two comparators.
14:31:26 <mauke> davidmccabe: missing (not .)?
14:31:33 * davidmccabe shakes head.
14:31:34 <SamB> slides!
14:31:39 <davidmccabe> Terabyte: a lecture is part of a course or series?
14:31:51 <mauke> :t partition
14:31:51 <SamB> except some lectures have those too ;-P
14:31:54 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:32:02 <Terabyte> samB: lol :P, david: hmm
14:32:03 <SamB> lectures are meatier?
14:32:46 <Terabyte> i mean if i was to stand somewhere and talk for 15 minutes, with a screen on behind me (with content relevant to what i was talking about) could that be a lecture, and could it be a presentation?
14:33:07 <davidmccabe> whoa, my computer just went to sleep without my asking it to :(
14:33:13 <Terabyte> I just don't see what the difference.. everyone says "powerpoint" but to be honest.. powerpoint is in most lectures...
14:33:26 <thalassocrac> it's both a lecture and a presentation
14:33:37 <Terabyte> thalas: cool
14:33:43 <SamB> I don't think 15 minutes counts as a lecture
14:33:48 <Terabyte> :P
14:33:53 <davidmccabe> oh, battery is reading at 0%, having suddenly dropped from about 10%.
14:33:54 <SamB> too lightweight
14:33:57 <Terabyte> well that's my thought entirely...
14:33:58 <davidmccabe> time to go to the shop again :(
14:34:38 <thorat> Terabyte: lectures are honest
14:34:55 <SamB> thorat: since when?
14:34:56 <Terabyte> lol! :D yeah... they don't include too many statistics
14:35:30 <Terabyte> Lecture: the process where the notes of the lecturer become the notes of the student without passing through the minds of either.
14:35:41 <Terabyte> hopefully that is the real crunch^
14:36:00 <SamB> couldn't they just email you their notes?
14:36:08 <thorat> Terabyte: yes, unfortunately in practice
14:36:09 <Terabyte> well they do in effect...
14:36:25 <SamB> it would save time!
14:36:59 <Daveman> xerox :D
14:37:17 <Terabyte> it's just i'm preparing a presentation.. and I don't see the difference between a lecture and a presentation .. and i'm just checking there's little chance sombody said "havn't you turned this into a lecture" if I don't bring in something which flashes green and red in the background...
14:37:18 <thorat> you present your work, lecture about other people's work
14:37:52 <thorat> how's that? ;)
14:38:03 <Terabyte> I only talk for 5 minutes split with 3 people to make 15 .. so i guess that's the difference
14:38:09 <Terabyte> yeah quite nice :P
14:38:20 <Terabyte> ok cool thanks everyone.
14:42:12 <Cale> Yeah, you can't do much of a lecture in 5 minutes :)
14:42:44 <Cale> I don't think you have anything to worry about in that regard, so long as you make sure it fits the timeslot :)
14:42:52 <Cale> oh, gone :)
14:43:57 <davidmccabe> is there a way I can say what I mean when I say ((<) . abs) without saying (\x,y -> abs x < abs y)?
14:44:39 <davidmccabe> (want to compare two numbers by their absolute values)
14:45:07 <mauke> @pl \x y -> abs x < abs y
14:45:08 <lambdabot> (. abs) . (<) . abs
14:45:11 <astrolabe> A compareBy function would be useful
14:45:37 <matthew-_> using a numeric type that doesn't have negatives may also be what you want
14:45:39 <Cale> I like defining  comparing p x y = compare (p x) (p y)
14:45:46 <Cale> @index comparing
14:45:46 <lambdabot> bzzt
14:45:59 <davidmccabe> polite bot you got there.
14:46:01 <Cale> oh, it's in Data.Ord
14:46:18 <Cale> But that's not exactly what you're looking for
14:46:26 <Cale> Some people like defining `on`
14:46:32 <davidmccabe> I'm also looking for something succinct; this is for a demo.
14:46:47 <Cale> c `on` p = \x y -> c (p x) (p y)
14:46:48 <davidmccabe> (yes, I am demoing haskell and I can barely write in it! oh wel!)
14:47:27 <Cale> So then it'd be  ((<) `on` abs)
14:48:18 <davidmccabe> that's pretty nice.
14:48:34 <mauke> @pl \abs x y -> abs x < abs y
14:48:35 <lambdabot> flip =<< (((.) . (<)) .)
14:49:00 <Cale> haha
14:49:07 <davidmccabe> very clear.
14:49:23 <mauke> @. unpl pl \abs x y -> abs x < abs y
14:49:24 <lambdabot> ((\ g p e f -> (g p) < (e f)) >>= \ a b c -> a c b)
14:49:32 <Cale> That's got to be the greatest @pl ever
14:50:21 <xerox> ?type let (.:) = (.) . (.) in (uncurry (<)) .: curry (join (***) abs)
14:50:24 <lambdabot> forall b. (Ord b, Num b) => b -> b -> Bool
14:50:51 <Cale> beautiful ;)
14:51:09 <xerox> :-D
14:51:12 <Cale> I think a lambda is probably the clearest way, or else define that `on` combinator.
14:51:46 <Lacrimosa> :-)
14:51:54 <Lacrimosa> hi guys
14:52:09 <xerox> Hi.
14:52:15 <Cale> hello!
14:52:27 <Cale> New Haskell user?
14:52:51 <Lacrimosa> Cale: yea, commin from the Erlang landis
14:52:58 <Cale> ah, cool :)
14:53:37 <Cale> The Gentle Intro might actually make sense to you then :) You could try it if the wikibook or YAHT seem too slow.
14:54:19 <Cale> (It's sort of funny how the "Gentle Introduction" is only gentle if you have a functional programming background :)
14:54:24 <Lacrimosa> ...so i was wondering if it is possible to make something like a persistent haskell code at runtime
14:54:38 <Cale> persistent in which sense?
14:54:53 <Lacrimosa> like in clean
14:55:31 <Lacrimosa> even an automated bytecode dumping is okay
14:55:55 <Cale> ah, like, storing the entire state of a computation to disk?
14:56:30 <Lacrimosa> yep, something like a Lisp image
14:56:51 <Cale> My guess is that something like that would require some hacking on GHC. The Yhc people might already be able to do it, if not, then it's something I think they're looking at.
14:57:11 <xerox> HAppS is also looking forward implementing such a system, I think.
14:58:36 <Lacrimosa> nothings like the Prolog's SQL mapping thing though :-)
14:58:51 <EvilTerran> that sounds potentially rather interesting.
14:58:56 <Cale> One of the things which I'd personally be interested in seeing is a function  retain :: IO () -> ByteString, which would basically take a snapshot of the current program state, and produce an executable with the provided main action.
14:59:46 * EvilTerran has visions of a mod_haskell where you can do{...; formRes <- getUserToFillOutForm; ...}
14:59:49 <mauke> wait, current state? shouldn't that be IO ByteString?
14:59:55 <Cale> er, yes
14:59:58 <Cale> sorry :)
15:00:07 <Cale> IO () -> IO ByteString
15:00:30 <EvilTerran> (sort of "mechanical turk"-esque setup, done transparently)
15:00:31 <Cale> IO () -> ByteString would also be interesting
15:00:41 <Cale> But slightly less so.
15:00:48 <xerox> return . mail Simon :: IO () -> IO ByteString
15:01:24 <Cale> (since you couldn't capture the current state)
15:01:29 <Lacrimosa> well, i guess the only chance for me would be to use the parser at runtime n doing the other stuff by hand, :(
15:01:41 <ndm> Given that I don't have newtype deriving, because I'm not using GHC
15:01:47 <ndm> how do i newtype derive over a state monad?
15:01:52 <ndm> newtype FreeVar a = FreeVar (State [String] a)
15:01:56 <Cale> Lacrimosa: We do have database bindings.
15:02:04 <ndm> instance Monad FreeVar where; return a = FreeVar (return a)
15:02:13 <ndm> I can't figure out >>=...
15:02:15 <mauke> "I've heard that there is a shell (bourne or csh) to perl filter, does anyone know of this or where I can get it?"  "Yeah, you filter it through Tom Christiansen.  :-)"
15:02:17 <Cale> deriving (MonadState [String])
15:02:24 <Lacrimosa> Cale: i know, but thats only the program data
15:02:29 <ndm> Cale: without deriving
15:02:39 <Cale> ah
15:02:52 <ndm> i know monad type sigs are tricky...
15:03:04 <Cale> instance Monad FreeVar where
15:03:13 <Lacrimosa> life sux...
15:03:23 * glguy &
15:03:25 <Cale>    (FreeVar x) >>= f = FreeVar (x >>= f)
15:03:26 <Cale> ?
15:03:51 <Cale>    return x = FreeVar (return x)
15:04:08 <ndm> ERROR file:.\FreeVar2.hs:32 - Type error in application
15:04:10 <ndm> *** Expression     : x >>= f
15:04:10 <Excedrin> does anyone have a (handy) priority queue that works with the Eratosthenes Seive paper by Melissa O'Neill?
15:04:12 <ndm> *** Term           : x
15:04:13 <ndm> *** Type           : State [String] a
15:04:15 <ndm> *** Does not match : FreeVar a
15:04:16 <ndm> that was my first guess...
15:04:34 <Cale> oh, right
15:04:39 <EvilTerran> [1]+  Stopped                 glguy
15:04:45 <Lacrimosa> thank you guys, have a nice day :-)
15:04:48 <EvilTerran> ;]
15:05:18 <Cale> err
15:05:43 <mauke> FreeVar s >>= f = s >>= (f . FreeVar) ?
15:05:43 <mauke> no, that doesn't make sense
15:07:36 <ndm>     (FreeVar x) >>= f = FreeVar (x >>= fromFreeVar . f)
15:07:49 <ndm> that works in the end, with fromFreeVar being the unwrapping of the newtype
15:09:00 <ddarius> Excedrin: Read sample chapter here http://www.palgrave.com/products/catalogue.aspx?is=0333992857
15:09:01 <lambdabot> Title: Palgrave Macmillan : Catalogue Page
15:09:32 <Cale> ndm: ah, yes
15:09:46 <ddarius> Result, like a three line heap implementation with fairly good properties
15:10:05 <Excedrin> ddarius: thanks
15:10:06 <Cale> ndm: at some level, you should just be able to ignore the type system altogether, and just have it work, since the newtype tags don't really mean anything at runtime.
15:10:23 <ndm> Cale: yeah, but its finding that level :)
15:10:27 <Cale> You could stick in unsafeCoerce's.
15:10:37 <ndm> thats too evil for me :)
15:11:10 <Cale> Are you implementing newtype deriving, or just doing the transformation by hand?
15:11:17 <ddarius> Excedrin: Of course, I'm sure there's one in the libs, but that's no fun.
15:11:22 <ndm> Cale: transform by hand
15:11:26 <Cale> ah, okay
15:11:36 <ndm> although i definately want to implement newtype deriving some day
15:11:40 <Cale> If you were implementing it, I'd say unsafeCoerce is probably fair :)
15:11:50 <ddarius> Cale: Blech!
15:12:06 <Cale> I mean, the whole point of newtype deriving is that the type system can be ignored.
15:12:24 <ddarius> Blech!
15:12:30 <ndm> Cale: thats the theory, the practice is often slightly different
15:12:37 <Cale> (Because the instances are already available on the base type.)
15:12:38 <ndm> i have a program where adding newtypes slows it down...
15:12:44 <Cale> really?
15:12:50 <sjanssen> ndm: in Hugs or GHC?
15:12:56 <ndm> sjanssen: GHC#
15:13:08 <ddarius> I can believe that.
15:13:14 <Nafai> GHC#?
15:13:25 <ddarius> That'd be awesowe!
15:13:27 <ndm> GHC
15:13:37 <sjanssen> ndm: do you know why?
15:13:37 <ndm> plus big fingers and little keyboard :)
15:13:46 <Nafai> ndm: Heh
15:13:53 <ndm> sjanssen: nope, was an hour before a talk and i needed performance numbers quickly
15:14:11 <bvd> Hello, is there a standard function for timing IO actions? i.e.: time :: IO a -> IO (a, TimeDiff)
15:14:19 <sjanssen> I wonder if newtype evaporation happens before or after RULES matching
15:15:06 <ndm> @hoogle CPU
15:15:07 <lambdabot> CPUTime :: module
15:15:07 <lambdabot> CPUTime.cpuTimePrecision :: Integer
15:15:07 <lambdabot> CPUTime.getCPUTime :: IO Integer
15:15:19 <ndm> bvd: if its performance measuring, that can be used ^^
15:16:12 <Cale> time x = do t <- getClockTime; v <- x; t' <- getClockTime; return (v, diffClockTimes t t')
15:17:34 <bvd> Cale: yes that mine implementation. But is there a standard function that does that?
15:17:52 <Cale> No, I don't think so
15:17:57 <bvd> ok thanks
15:18:59 <EvilTerran> o.
15:20:54 <ddarius> Bah, I thought I was going to be "productive" this afternoon, but it looks instead as though I will have to figure out how to map Noether's theorem to programming.
15:23:31 <dcoutts> sjanssen, after
15:24:45 <sjanssen> dcoutts: I suppose that could get in the way of certain RULES optimizations?
15:25:16 <dcoutts> sjanssen, the contrary is also true
15:25:55 <sjanssen> true, true
15:29:10 <sorear> ..
15:29:25 <xerox> ddarius: yuck.
15:30:15 <ndm> hmm, now i've got a wrapped state monad
15:30:20 <ndm> how do i implement get?
15:30:27 <ndm> in my new monad
15:30:40 <sorear> newtype deriving
15:30:47 <sorear> that's what LB uses
15:31:24 <ndm> but it must implement it in some way underneath
15:31:27 <ddarius> The persons reply to me is on the track that I'm thinking.  I'm going via category theory using natural transformations (parametric functions) to isolate the conserved quantities or perhaps they should be the symmetries.
15:31:45 <ndm> dcoutts, you off to fun in the afternoon?
15:32:23 <dcoutts> ndm, yep, gotta get up at 8am to get an 8:30 train! ugg
15:32:36 <ndm> dcoutts, Colin is driving, so an 11:15 start
15:32:41 <ddarius> ndm: The quickest thing (besides deriving) is to write a function toRep :: FreeVar a -> ([String] -> ([String],a))
15:32:42 <dcoutts> I'll bring my unicycle to save time
15:32:59 <ddarius> and fromRep going the other way.
15:33:15 <ndm> ddarius: doesn't that basically involve me implementing my own state monad?
15:34:07 <sorear> ndm: newtype deriving works by fudging the underlying type system ... I'ven't read about it post-FC, but I'll bet it uses the newtype coercion to retype the old dictionary as applying to the new type
15:34:17 <ddarius> Oh, yeah.  I'm didn't look at your type very clear headedly.
15:34:28 <ddarius> ndm: You should just be able to unwrap and rewrap.
15:34:32 <sorear> ndm: in an untyped setting, it can simply re-use the dictionary for the base type.
15:34:52 <sorear> wrapping is the approach at the haskell source level
15:34:56 <ndm> ddarius: i know, i just can't figure out where the wrap/unwrap goes
15:35:14 <ndm> sorear: i would still have thought they used wrapping, to be honest, coercions aren't a first choice mechanism usually
15:35:37 <ddarius> myget = FreeVar get
15:36:28 <ndm> ddarius: no worky :(
15:37:01 <ndm> ddarius: oh, it does work, i thought i tried that first...
15:40:40 <bos31337> http://www.serpentine.com/blog/2007/02/20/haskell-cabal-now-with-extra-crunchy-rpm-goodness/
15:40:42 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  Haskell Cabal, now with extra crunch ..., http://tinyurl.com/ytro4j
15:41:04 <bos31337> cabal can now build rpms.
15:44:05 <chessguy> 'evening haskellers
15:44:25 <ndm> evening chessguy
15:44:36 <chessguy> @pl \c -> c {x=3; y=2}
15:44:36 <lambdabot> (line 1, column 9):
15:44:37 <lambdabot> unexpected "{"
15:44:37 <lambdabot> expecting variable, "(", operator or end of input
15:45:15 <xerox> No way.
15:45:21 <chessguy> @pl \c -> c {x=3, y=2}
15:45:22 <lambdabot> (line 1, column 9):
15:45:22 <lambdabot> unexpected "{"
15:45:22 <lambdabot> expecting variable, "(", operator or end of input
15:45:44 <bos31337> chessguy: what are you trying to do?
15:45:46 <EvilTerran> is that even possible?
15:46:07 <bos31337> sure, but you need a type declared with the record syntax.
15:46:28 <bos31337> and lambdabot probably doesn't know about that piece of syntax, anyway.
15:46:30 <sorear> chessguy: there is no such thing as pointfree record update
15:46:33 <EvilTerran> i mean, haskell's current record syntax is incompatible with pointsfreeing it, right?
15:46:39 <bos31337> oh. yes.
15:46:58 <xerox> You can write such combinator using the constructors, though.
15:47:08 <EvilTerran> it'd make more sense to me if {x=3,y=2} was a function, but meh.
15:47:17 <chessguy> xerox, what do you mean?
15:47:24 <xerox> chessguy: how's 'c' defined?
15:47:39 <sorear> bos++ bos31337++
15:47:40 <chessguy> it's a record with a bunch of fields
15:48:17 <chessguy> well, that function that i gave would be applied to an instance of a record with a bunch of fields
15:48:34 <bos31337> why do you care if it'
15:48:39 <chessguy> c itself is just the parameter of the lambda expression
15:48:40 <bos31337> er, if it's point-free?
15:48:56 <dibblego> what's a canonical problem that is solved best with the state monad?
15:49:06 <xerox> chessguy: e.g. |data Point = Point { x, y, z :: Int }| then |(Point 3 2) . z| has the type you wanted.
15:50:12 <chessguy> hmmm
15:50:25 <chessguy> so it would have the form Int -> Point, right?
15:50:32 <chessguy> s/form/type/
15:50:35 <xerox> Point -> Point
15:50:54 <chessguy> err
15:51:28 <chessguy> oh, ok
15:51:38 <chessguy> and it would modify just the x and y fields
15:52:01 <xerox> ?type let third (_,_,z) = z in (,,) 2 3 . third
15:52:04 <lambdabot> forall t t1 b t2 t3. (Num t, Num t1) => (t2, t3, b) -> (t, t1, b)
15:52:13 <xerox> Imagine prettier type.
15:52:28 <chessguy> hmm.
15:53:00 <xerox> More combinatorial fun in presence of more arguments. Let's not waste the night, though.
15:53:07 <chessguy> the record type i'm using has a whole bunch of fields which indicate default values. i want it easy to specify a function which will override any number of the defaults
15:53:47 <sorear> hlist forever! :)
15:53:48 <chessguy> hmm, that didn't make much sense
15:54:31 <ddarius> dibblego: It's the typical solution for unique identifiers or random number generators.
15:55:07 <chessguy> the record type has a bunch of parameters. there will be an instance of the record which has a default for each parameter. i want it to be easy to specify a function which can override any number of the defaults to create a new record which will contain all the parameters needed
15:55:16 <chessguy> sorear, was that for me? i don't know what an hlist is
15:55:54 <sorear> yes , Oleg's record type
15:56:03 <sorear> emphasis on the Oleg bit
15:56:44 * ddarius thinks he'll pass out and be completely un"productive" instead.
15:57:13 <xerox> ?spell heterogeneous
15:57:13 <xerox> ...lists.
15:57:14 <lambdabot> heterogeneous
15:57:19 <bos31337> chessguy: there is no easy way to do what you want to do, without getting all Oleginous.
15:57:29 <dons> moin
15:57:30 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
15:57:35 <xerox> Hi dons.
15:57:40 <EvilTerran> chessguy, data Foo = Foo { x :: Int, y :: Int, ... }; defaultFoo = Foo { x = defX, y = defY, ... }
15:57:43 <sorear> hello!
15:57:47 <bos31337> dons: is there a programmatic way to talk to hackagedb?
15:57:55 <EvilTerran> then you can go myFoo = defaultFoo { x = myX }
15:58:06 <dons> i've not used hackagedb: so I don't know.
15:58:09 <bos31337> oh.
15:58:17 <dons> ah sorry.
15:58:17 <bos31337> i thought for some reason that you were involved.
15:58:20 <dons> misunderstood
15:58:23 * dons needs coffeee!
15:58:27 <dons> you want to upload or download?
15:58:33 <Cale> It's amazing how little you really need heterogeneous lists.
15:58:36 <bos31337> i want to download everything.
15:58:36 <dons> there's no library, but there are some tools now
15:58:37 <EvilTerran> the instance of the record with the defaults is the closest you'll get to the function you're looking for /sans/ mess.
15:58:44 <dons> ah right. you want cabal-install
15:58:53 <bos31337> oh, the stuff in the hackage-scripts repo?
15:58:54 <dons> semi-working, in the latest darcs version of caabl
15:58:58 <ndm> dons: Yhc should now work
15:59:07 <ndm> dons: and you should have a hacle + clean patch
15:59:07 <dons> ndm, running the tests now with your patch
15:59:11 <chessguy> hmm, but i can also go \foo -> foo { x = myX} defaultFoo -- right?
15:59:11 <dons> i do.
15:59:16 <Cale> I suppose it has something to do with the fact that if you have a collection of things, you usually want to know that you can at least do some of the same things to them.
15:59:16 <dons> just need hacle and clean now
15:59:19 * sorear pulls
15:59:33 <chessguy> well, probably (\foo -> foo { x = myX}) defaultFoo
15:59:34 <iron33> Hi all I have question about Haskell Record/Tuple syntax if I declare data Record = MakeRecord { name :: String, age :: Int } is that part of the Haskell 98 standard ?
15:59:39 <sorear> yes
15:59:44 <Cale> iron33: yep
16:00:06 <iron33> Ok thanks
16:00:57 <EvilTerran> chessguy, why not just use defaultFoo { x = myX... }?
16:01:23 <EvilTerran> (or, as i generally do it, data Foo = Foo {...}; foo = Foo {...}; with the defaults in foo)
16:01:40 <sorear> dons: have you gotten anything from the hacle+clean guy yet?
16:02:03 <dons> > Prelude.sequence [(*2),(+1)] 7
16:02:05 <lambdabot>  [14,8]
16:02:13 <dons> should've remembered that
16:02:20 <chessguy> EvilTerran, library/client separation
16:02:32 <EvilTerran> ah.
16:02:33 <sorear> > import Prelude hiding (sequence, map, mapM, mapM_)
16:02:34 <lambdabot>  Parse error
16:02:39 <xerox> Cale - On the other hand one has got polymorphism on the container type, which enables interesting things.
16:02:42 <ptolomy> Heh. I love that I find myself, when dealing with non-Haskell languages, often thinking, "Golly, this would easier if this language had documentation / community help like haskell.."
16:03:22 <EvilTerran> i think you'll end up doing "setX f x' = f{x = x'}" for all your fields, in that case.
16:03:43 * sorear adds a self performance tester to vty ... yay!
16:03:59 <sorear> no more worrying about whether adding polymorphism will hurt
16:04:00 <EvilTerran> yielding "myFoo = defaultFoo `setX` myX `setY` myY", which isn't too bad...
16:05:34 <chessguy> i was thinking i could just require that to modify the parameters they send a function of type ParameterList -> ParameterList, which i then apply to the defaultParameterList before doing what needs to be done
16:05:47 <chessguy> and if they don't do that, then the default function is id :)
16:06:51 <EvilTerran> ooohhh, i see... you were hoping to recieve the hypothetical @pl function as a parameter?
16:07:11 <iron33> Sorry another noob question data Record = MakeRecord { name :: String, age :: Int } how would I pattern match that f MakeRecord { name = n, age = a } ?
16:07:11 <chessguy> right
16:07:15 <xerox> chessguy: you might borrow the `set' function from Gtk2Hs (IIRC the name.)  It lets you do things like |set object [ X := 1, Y := 2 ]| and even more powerful (monadic) things.
16:07:18 <ndm> sorear: yes he has, the guy sent him a patch today
16:07:26 <sorear> hurray!!
16:07:49 <sorear> fun MakeRecord{name = n, age = a} = use n and a
16:07:49 <chessguy> xerox, i'l check it out
16:07:54 <sorear> iron33: ^^
16:08:11 <iron33> thanks
16:08:28 <EvilTerran> don't you need to parenthesise MR{...}?
16:08:34 <sorear> nope
16:08:37 <EvilTerran> okay
16:08:47 <chessguy> sorear, can't you also do something like fun MakeRecord n a = use n and a
16:09:00 <chessguy> assuming they're the only fields
16:09:04 <sorear> chessguy: no, you can't lambda bind a datacon :)
16:09:20 <chessguy> ermm
16:09:38 <sorear> fun (MakeRecord n a) = use n and a  would work :)
16:09:41 <chessguy> i know you can do stuff like foo Tree x left right = ...use x, left, and right
16:09:56 <chessguy> yeah, that's what i meant
16:09:58 <chessguy> with parens
16:15:10 <mabs29> I have a very naive, over-simplified question: how does Haskell 'compare' to Ruby? In particular, expressiveness and ability to accomplish diverse things, from scripting to web servers. I appreciate it if someone could point me to articles, too.
16:16:52 <orbitz> mabs29: ugh that's a terribel question.
16:17:20 <orbitz> mabs29: it's really good at a lot of things dependin gon your level of zealotness
16:17:50 <dons> mabs29 ok. let me try. but take this with a grain of salt.  haskell is faster, a lot faster. it is also more expressive. however ruby has better library support.
16:18:06 <dons> lines of code for naive programs should be roughly similar
16:18:06 <orbitz> I prefer a functional language over OO almost any day so somethign like ruby isn't all that good IMO
16:18:25 <iron33> Does Ruby have a standard byte compiler yet
16:18:27 <orbitz> ruby has a lot of scoping issues that haskell doesn't and is just increidbly annoying
16:18:31 <sorear> Haskell is much easier to read ...
16:18:35 <sorear> for haskellers.
16:18:54 <dibblego> Chinese is much easier to read
16:18:58 <iron33> I haven't followed Rubies development in a while
16:18:58 <dibblego> for Chinese people :)
16:19:07 <dons> ?users
16:19:08 <lambdabot> Maximum users seen in #haskell: 317, currently: 295 (93.1%), active: 44 (14.9%)
16:19:10 <thorat> mabs29: perl makes easy things easy, hard things possible; haskell makes impossible things possible
16:19:42 <sorear> does ruby have any sort of static typing?  user defined types?
16:19:43 <bd_> and hard things into one-liners? ;)
16:19:47 <thorat> mabs29: perl ~= ruby
16:19:50 <kc5tja> Perl makes easy things hard to read, hard things impossible to maintain.  :)
16:20:16 <LoganCapaldo_> ruby is untyped ;)
16:20:23 <Excedrin> sorear: are classes types?
16:20:39 <LoganCapaldo_> You can create classes but those are just syntactic sugar for creating objects
16:20:41 <iron33> Well I find Perl doesn't do well for programming in the large but thats just my opinion fun to program in but I wouldn't want to have to maintain anything written in perl
16:20:48 <dons> mabs29: so um, anything useful in all that? :-)
16:20:56 <LoganCapaldo_> Excedrin, classes are definitely not types
16:21:04 <sorear> IMD an untyped language is one with only one type, and all operations are type-total.
16:21:04 <LoganCapaldo_> except maybe in Eiffel
16:21:06 <xerox> Excedrin - Typeclasses are sets of types.
16:21:24 <orbitz> sorear: it's "strongly" typed, but nothign static
16:21:29 <LoganCapaldo_> sorear, everything is an object, and theres only one operation, send :)
16:21:29 <sorear> are you telling me ruby will consent to use an integer as an array? (most likely resulting in a crash)
16:21:31 <Excedrin> xerox: I meant Ruby classes, not Haskell typeclasses
16:21:33 <iron33> I don't like Ruby much since it is bascally SmallTalk with uglier syntax
16:21:39 <dons> lazy typing!
16:21:46 <xerox> Excedrin - Ah, I have no idea about Ruby.
16:21:51 <orbitz> sorear: no, an integer wont' have the same operators to perform on it
16:21:55 <sorear> LoganCapaldo_: what happens when you
16:21:56 <orbitz> heo fnord123
16:22:02 <bd_> dons: heh, let's just make the entire program be an unevaluated (GHC.eval "...") chunk :
16:22:03 <kc5tja> Ruby is strongly, dynamically typed as far as I know -- it shares the same basic object model as Smalltalk, which is a strongly-typed, dynamic language.
16:22:05 <bd_> )
16:22:06 <ptolomy> I find ruby to be more convenient for quick-n-dirty development.. on-the-fly coding, etc. Most things work as you'd expect without much thought on the small scale, and don't require much boilerplate. However, once you try to do something complicated, you have to have a huge test harness and a crapload of awkward classes to keep things clean.
16:22:08 <kc5tja> Objects have the type, not the variables.
16:22:12 <sorear> ... send the wrong message to an object?
16:22:21 <LoganCapaldo_> it raises an exception
16:22:33 <LoganCapaldo_> although "wrong" message is open to negotation
16:22:35 <dons> ptolomy: interesting. i do all my quick and dirty hacks in haskell these days
16:22:38 <LoganCapaldo_> (just as in Smalltalk)
16:22:43 <orbitz> ptolomy: i usually think the same but s/ruby/python. however i started writin gmy scripts at work in haskell rather than python and i found it to be just as easy if not easier
16:23:01 * sorear writes haskell oneliners using ghc -e ... perl is rare in my usage now
16:23:22 <orbitz> i found i banged the keyboard less but produced mor econcise results in abotu the same amount of itme
16:23:24 <thorat> sorear: would that be ghci?
16:23:41 <sorear> thorat: it's like vi/ex
16:23:45 <dons> so MarcWebe3 was just trolling?
16:23:50 <davidmccabe> am I the only one who finds the idea of a template engine written in PHP funny plus evil?
16:23:51 <dons> soryr. mabs29
16:23:57 <thorat> sorear: or does gch -e imply ghci?
16:23:57 <ptolomy> What keeps me using ruby > haskell is the ability to play fast-and-loose with data structures and the convenient regex/library stuff.
16:24:03 <LoganCapaldo_> does ghc -ne stick the code in "interact" ?
16:24:10 <Excedrin> davidmccabe: I find it sad, only sad
16:24:11 <sorear> thorat: ghci is a symlink to ghc, and implies the --interactive flag
16:24:22 <LoganCapaldo_> cause it should ;)
16:24:28 <dons> ptolomy: fast-and-loose with data structures?
16:24:28 <sorear> -e is a different mode flag, an overrides --interactive.
16:24:36 <LoganCapaldo_> it also needs an -i flag
16:24:56 <sorear> IMESF, everything Perl can do better than Haskell, Grep or Sed can do better than both.
16:25:56 <bos31337> @hoogle ssl
16:25:57 <lambdabot> No matches found
16:26:03 <fnord123> awk is worth a mention
16:26:03 <lambdabot> fnord123: You have 1 new message. '/msg lambdabot @messages' to read it.
16:26:12 <ptolomy> dons: I still fear haskell arrays and hashtables. Ruby has special syntax so I don't have to remember argument order, has easy defaults, etc. Nothing haskell can't do also, but I think haskell coding requires more thought.
16:26:18 <dons> hashtables?
16:26:27 <xerox> ?where hopenssl
16:26:27 <lambdabot> I know nothing about hopenssl.
16:26:28 <bos31337> wah! no ssl support in haskell libraries?
16:26:32 * dons hands ptolomy Data.Map
16:26:34 <xerox> ?where+ hopenssl http://cryp.to/hopenssl/
16:26:35 <lambdabot> Done.
16:27:01 <LoganCapaldo_> dons, stop giving people things they fear! ;)
16:27:25 <sorear> trees are neither arrays nor hashtables
16:27:37 <thorat> I think it's hard to quickly convince Perl/Ruby programmers to try haskell,
16:27:37 <bos31337> hmm, hopenssl isn't much use.
16:27:51 <xerox> :-(
16:28:03 <thorat> back in 2000 I was unconvinced,
16:28:12 <thorat> as a perl fanatic
16:28:13 <dons> bos31337: check with musasabi
16:28:18 <Excedrin> sorear: ok, I wrote a 80 line perl program that acts as a tcp server listening on some port, when I connect, I get a prompt and can eval any arbitrary perl. I use it to interact with machines that are in the middle of a Jumpstart install, so I can check progress, poke around to find out why something's failing etc. How would I do that with sed and grep?
16:28:19 <dons> there's probably some code in happs
16:28:22 <LoganCapaldo_> thorat, yes its because we try it of our own volition, you can't convince someone of something if they've already done it ;)
16:28:28 <xerox> There you go, bos31337: http://www.cs.helsinki.fi/u/ekarttun/hsgnutls/
16:28:29 <lambdabot> Title: hsgnutls
16:28:34 <fnord123> lambdabot: seen dcoutts
16:28:40 <dibblego> has anyone ever done a 'preferred programming language' and 'religious conviction' survey?
16:28:54 <bos31337> xerox: nice, thanks.
16:29:01 <LoganCapaldo_> Excedrin, its only better in sed and grep if Haskell isn't better at it :)
16:29:04 <xerox> You're welcome.  Google knows it all.
16:29:08 <Cale> Excedrin: perhaps a fifo together with netcat?
16:29:17 <iron32> dibbleog: No I haven't I would ove to do one though
16:29:25 <kc5tja> /dev/tcp
16:29:25 <EvilTerran> ?seen dcoutts
16:29:25 <lambdabot> dcoutts is in #haskell, #ghc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 53m 21s ago.
16:29:27 <ptolomy> hehe. I like Data.Map and all, but I still find it more awkward than the built-in hash tables in ruby. Ruby lets me write sloppy code faster. Obviously anyone who is a guru haskell coder would find haskell easier, but for small tasks haskell holds little benefit for me.
16:29:28 <LoganCapaldo_> I think there are versions of awk for which the netcat part is superflous
16:29:29 <thorat> I changed my mind when I saw that a lot of smart people thought otherwize
16:29:43 <thorat> so it was a leap of faith
16:29:47 <dibblego> iron32, me too, but of course, interpreting the results would be controversial and I don't care too much for that
16:29:50 <Cale> Excedrin: probably saner just to run a telnet/ssh server though.
16:30:22 <Excedrin> Cale: there's no netcat available at that point, and if there was it would have to be a huge blob of shell script
16:31:03 <ptolomy> I bet i'd be much more haskell-ready on quick scripts if I were more comfortable with bytestring regexen.
16:31:16 <thorat> s/otherwize/otherwise/
16:31:42 <thorat> how did you decide to study haskell?
16:32:06 <thorat> the gentle is not that catchy when you already know an expressive scripting language
16:32:11 <fons> hi all
16:32:26 <sorear> hi
16:32:30 <Excedrin> LoganCapaldo_: yea, I suppose I could write a shell-like interpreter in Haskell... maybe that's a useful project for me someday
16:33:31 <iron32> thorat : Mostly the belief that there has to be a better way to code so you keep exploring languges and learning new ideas
16:33:35 <thorat> sometimes good things are hard to sell
16:33:46 <thorat> yes
16:33:55 <fabiand> hmm hello - may i ask a quick question :) in a function composition, is it mandatory that all functions have the same number and type of parameters?
16:33:59 <fons> anyone used to work with Template Haskell?
16:34:06 <sorear> fabiand: no...
16:34:23 <sorear> fabiand: but composition only works 'right' on one-arg functions
16:34:36 <sorear> fons: I've looked at it and tried to use it
16:34:53 <fabiand> sorear, hmm okay - thanks, i suppose that i'll have to look at them again then ... thought so ..
16:35:05 <fons> I don't know how to include type variables withing the [t| |] quasiquotes, GHC complains if I do things such us [t| Maybe b |]
16:35:05 <iron32> thorat : Whats good is in the eye of the beholder :)
16:35:22 <fabiand> sorear, what does this mean? is it general only common to use composition with one-arg functions?
16:35:23 <sorear> fons:
16:35:29 <Cale> :t (.)
16:35:31 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:35:41 <Cale> thankfully, all functions in Haskell take exactly one parameter :)
16:35:47 <thorat> iron32: the persistence of the people on LTU got me convinced to take a second look
16:35:48 <sorear> fons: http://haskell.org/ghc/dist/current/docs/users_guide/template-haskell.html#id3183972
16:35:50 <lambdabot> Title: 7.6. Template Haskell, http://tinyurl.com/29wwbz
16:35:52 <mabs29> dons: what do you mean by Haskell being 'more expressive'? I can see in both languages abilities to express different things with mind-boggling density. For example, in ruby, the Camping project (4k web app framework)
16:35:53 <Cale> (and potentially return another function)
16:36:06 <sorear> fons: ^^^ read the part where it says [t| ... |] isn't implemented yet
16:36:20 <Cale> fabiand: you can see in the type of (.) what is meant by that
16:36:24 <thorat> mabs29: my reaction exactly first when I looked at haskell
16:36:29 <fons> sorear, well, it is ... as it works with [t| Bool |]
16:36:34 <thorat> mabs29: from Perl
16:36:38 <Cale> fabiand: function composition is itself just an ordinary function
16:36:46 <fons> sorear, maybe it isn't complete though
16:36:49 <Cale> (f . g) x = f (g x)
16:36:52 <thorat> mabs29: so it's not just about expressiveness IMO
16:36:53 <Cale> is the definition
16:36:57 <sorear> fons: Cool, you found your first GHC bug! Report it!
16:36:59 <sorear> @bug
16:37:00 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:37:26 <fabiand> Cale, so how would a composition look when f has one arg and g two?
16:37:33 <thorat> mabs29: it's also the benefits of the type system
16:37:38 <fabiand> f . (g a x) ?
16:37:42 <LoganCapaldo_> fabiand, no
16:37:46 <fons> sorear, are you using HEAD?
16:37:48 <LoganCapaldo_> it would look the same
16:37:51 <LoganCapaldo_> hahahahahah
16:38:11 <fabiand> erm
16:38:15 <fabiand> :)
16:38:16 <sorear> fons: yes
16:38:20 <mabs29> thorat: I still have a lot to do in terms of understanding Haskell's type system, which seems very complex but useful
16:38:22 <fnord123> who was working on yi?
16:38:27 <fons> sorear, you could maybe try if it works before I add noise in the bug tracker
16:38:34 <ptolomy> I think Haskell is more profound than the flexy flexy scripting languages. You don't just get some functionality with a concise block of code, you get a specification with potentially wide-ranging implications.
16:38:46 <hyrax42> fnord123: I think sorear picked it up recently
16:38:47 <Cale> fabiand: if you wrote f . g, then f would have to take a function as its first parameter
16:38:48 <thorat> mabs29: I recommend trying to understand anything Oleg Kiselyov does
16:38:53 <LoganCapaldo_> :type id . (+) -- + takes two args
16:38:57 <thorat> mabs29: it will fry you brain
16:38:57 <dons> mabs29: I wsa thinking in terms of theoretical expressiveness. Fundamental CS features like monads, arrows, applicative functors, type classes, GADTS, let your write programs simply not expressible in Ruby.
16:39:01 <LoganCapaldo_> @type id . (+) -- + takes two args
16:39:04 <lambdabot> forall a. (Num a) => a -> a -> a
16:39:06 <Cale> fabiand: because (f . g) x = f (g x), and then g x would be a function
16:39:24 <LoganCapaldo_> @type id . (+) 2
16:39:27 <lambdabot> forall b. (Num b) => b -> b
16:39:38 <LoganCapaldo_> hmm maybe id was a bad example <g>
16:39:38 <sorear> fnord123: not quite ... I've done a lttle to yi, but virtually all the code is coming from jyp
16:39:38 <hyrax42> fnord123: I may be quite wrong thogh
16:39:40 <xerox> id . (+) = \x -> id (x+) = \x -> (x+) = (+)
16:39:42 <sorear> @seen jyp
16:39:43 <lambdabot> I saw jyp leaving #oasis and #haskell 2d 12h 12m 17s ago, and .
16:39:45 <Cale> @unpl f . (. g)
16:39:46 <lambdabot> (\ d -> f (\ i -> d (g i)))
16:39:58 <EvilTerran> @unpl flip flip flip
16:39:59 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
16:40:01 <Cale> @unpl (f .) . g
16:40:01 <lambdabot> (\ d i -> f (g d i))
16:40:04 <Cale> aha
16:40:12 <Cale> that's what you're probably looking for
16:40:15 <xerox> ?type (.) . (.)
16:40:18 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:40:19 <xerox> ?type (.) . (.) . (.)
16:40:22 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
16:40:23 <xerox> Spot the pattern.
16:40:23 <iron32> mabs29 : Well IMHO I would call Haskell concise like math and not expressive like english. But when you do express something in Haskell as long as you understand the syntax it is more clear and less ambigous. Unlike perl which was to many ways to express the same ideas
16:40:33 <thorat> mabs29: the source code for the standard prelude is also very catchy
16:40:34 <dons> so on the scale of Felleisen's expressiveness index, Haskell would be strictly more expressive. However, you'd have to be proficient in both languages to get a sense of what's posisble in everyday work. They probably come out the same for most scripts.
16:40:47 <Rule> Is there a general (fast) way to convert a Floating type to a Float?
16:40:55 <bos31337> god, i hate trac.
16:40:55 <fabiand> does this channel get logged somewhere -  might make more sense to look at this in the morning again :)
16:40:59 <dons> > 7.0 :: Float
16:41:00 <lambdabot>  7.0
16:41:02 <dons> ?logs
16:41:02 <xerox> ?where logs
16:41:03 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:41:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:41:03 <Cale> Rule: realToFrac?
16:41:08 <bos31337> how do i get an account in the hackage trac instance?
16:41:09 <fabiand> but - yes - there seems to be some pattern :)
16:41:10 <Cale> @type realToFrac
16:41:11 <Rule> I'm looking for something like Floating a => Float -> a
16:41:13 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
16:41:17 <xerox> dons: hehe that's ?docs.
16:41:21 <fons> sorear, I'm using GHC 6.6 and in the documentation (as you correctly stated) it clearly says there's no support for [t| |], even if it seems to work if no type parameters are supplied, so mayne that is the expected behaviour till type quasiquotes are "officially" supported
16:41:22 <dons> bos31337: i.e. to upload?
16:41:31 <fabiand> ah okay - thanks
16:41:33 <dons> to hackage.haskell.org ?
16:41:41 <Cale> Rule: yeah, use realToFrac
16:41:42 <bos31337> dons: just to submit a bug.
16:41:46 <Rule> Cale: I'll try realToFrac
16:41:57 <dons> ah. you just make an account. guest/guest Chsoudl workd
16:42:00 <Rule> Cale: Sounds really logical :-)
16:42:02 <Cale> Rule: the two numeric conversions you need to know about are realToFrac and fromIntegral.
16:42:03 <fabiand> thanks and bye ,,,
16:42:10 <bos31337> but i can't see the "create an account" button
16:42:58 <mabs29> iron32: so the expressiveness and 'meta programming' in Ruby is effectively telescoping and compressing English, where Haskell is compressing the tasks themselves by diverse means -- is that fair to say?
16:44:31 <fnord123> if reddit goes downhill, where will people here usually be found (apart from irc and their meatspace)
16:44:51 * sorear doesn't care about reddit
16:44:55 <sorear> the ML, mostly
16:44:59 <sorear> @where haskell-cafe
16:45:00 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
16:45:09 <LoganCapaldo_> sorear, I suspect its mutual :)
16:45:25 <LoganCapaldo_> reddit is a cold-hearted uncaring webpage
16:45:54 <iron32> mabs29 : I wouldn't say that only that Haskell has firm groundings in math like lambda calculus and category theory where as other imperative llanguages often don't
16:52:20 <dons> i had much fun yesterday rolling a quick haskell script to pick up logs files and render them as a nice html page
16:52:23 <dons> using xhtml and read/show
16:52:43 <dons> the code was really quick to write, and works nicely. had a couple of formatting bugs.
16:52:58 <sorear> @where nobench-results
16:52:58 <lambdabot> I know nothing about nobench-results.
16:52:59 <dons> but I couldn't imagine doing it faster in a "scripting" language -- which I would have done in the old days
16:53:27 <dons> ?where+ nobench-results http://www.cse.unsw.edu.au/~dons/nobench/results.html
16:53:27 <lambdabot> Done.
16:53:57 <dons> yeah, here's the script, http://www.cse.unsw.edu.au/~dons/code/nobench/bin/gen-report.hs
16:54:06 <dons> so its just a data type for the disk files
16:54:14 <dons> and then an xhtml pass to render the page
16:54:26 <dons> easy. i guess people write code like this everyday in the real world :-)
16:54:30 <dons> quick scripts to get something done.
16:54:43 * sorear stands amazed at the five tests where hbc dramatically outperforms ghc
16:54:50 <LoganCapaldo_> dons: I have this suspicion that past a certain level of language features its largely knowing how to think about the problem. There's certainly people out there who would do it with the same facility in lisp, and others who would do it with the same speed in even Java perhaps
16:55:00 <dons> sorear: hey, lennart is a pretty good compiler writer...
16:55:11 <dons> LoganCapaldo_: agreed.
16:55:29 * ndm gets to see Lennart talk tomorrow
16:55:47 <dons> people for some reason seem surprised by scripting tasks like this (i.e. short quick text/IO/html munging) done in .hs
16:55:48 <ndm> dons: before applying my Yhc patch?
16:55:57 <dons> ndm, your patch is running now.
16:56:01 <dons> it'll update in an hour or so
16:56:06 <dons> seems to work
16:56:15 <ndm> dons: and we managed to replicate your slowdown on our machines, Tom is currently debugging the slowdown
16:56:23 <thorat> "Smart people tend to clump together, and if you can find such a clump, it's probably worthwhile to join it." --Paul Graham
16:56:31 <ndm> dons: if we could use darcs --tag then it would be much easier...
16:56:34 <dons> ndm, partial results now http://www.cse.unsw.edu.au/~dons/nobench/results.html
16:56:35 <lambdabot> Title: nobench: Haskell implementation shootout
16:56:39 <thorat> that's the only reason I gave haskell a tyr
16:56:41 <thorat> try
16:56:51 <kc5tja> What I think makes Haskell potentially good for lots of scripting applications is the lack of a distinct need to express types explicitly, plus its heavy use of implicit iteration.
16:57:21 <dons> kc5tja: yeah.
16:57:31 <dons> mapM_ + inferred (strong) types == quick scripts
16:58:16 <sorear> polymorphism helps a LOT
16:58:34 <dons> kc5tja: i think one of the other good things is the combinator libraries.
16:58:36 <sorear> dynamic typing can handle some cases (eg foreach), but not all
16:58:38 <dons> e.g. xhtml. yay.
16:58:41 <dons>  parsec == yay
16:58:55 <fnord123> does ghci not allow function definitions?
16:59:08 <sorear> fnord123: it does
16:59:13 <LoganCapaldo_> fnord123, let f x = ...
16:59:17 <sorear> fnord123: but not with the standard synax
16:59:23 <fnord123> let is key. thanks
16:59:25 <nmessenger> the toplevel acts like you're in the IO monad, use do syntax
16:59:35 <sorear> Prelude> let f x = x + 1
16:59:35 <sorear> Prelude> f 1
16:59:35 <sorear> 2
16:59:35 <sorear> Prelude>
17:00:03 <fnord123> lambdabot: let io f = interact (unlines . f . lines)
17:00:29 <monochrom> class Yay a where yay :: a -> Bool
17:00:41 <xerox> Yay Me!
17:00:46 <monochrom> instance Yay Parsec where yay _ = True
17:00:52 <dons> ndm, darcs --tag?
17:01:01 <dons> on what, nobench?
17:01:02 <monochrom> instance Yay Java where yay _ = False  -- :)
17:01:28 <ndm> dons: no, on Yhc - we need an old version (which we tagged), so we can f igure out where our regression is
17:01:34 <dons> ah right
17:01:45 <dons> just roll back till you hit the slowdown.
17:01:45 <ndm> dons: and alas darcs --tag is equivalent to darcs --ignore-tag
17:01:54 <sorear> ndm: also do you think the (unversioned) is worth fixing?
17:01:56 <dons> ok. so do those numbers now look right for current yhc? http://www.cse.unsw.edu.au/~dons/nobench/results.html
17:01:57 <lambdabot> Title: nobench: Haskell implementation shootout
17:01:58 <ndm> we know where our last benchmark set was from
17:02:00 <LoganCapaldo_> instance Yay JavaParserInParsec where yay _ = undefined
17:02:08 <sorear> ndm: it can be completely automated, a la @version
17:02:11 <sorear> @version
17:02:12 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
17:02:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:02:24 <dons> yeah, i encourage yhc -v and yhc --version to emit something useful :-)
17:02:28 <monochrom> Haha
17:02:29 <ndm> sorear: no, we deliberately turn off version for those builds which are't our official versions - the buildbot ones do have a version
17:02:36 <sorear> the 509 is (1st approx)  ls _darcs/patches | wc -l
17:02:50 <ndm> dons: til recently it always said "Yhc XP"
17:02:54 <monochrom> Dynamic typing is a sledgehammer.
17:03:01 <dons> $ cd tmp/yhc
17:03:01 <dons> $ darcs changes --xml-output 2> /dev/null | sed -n '/TAG/q;/^<\/patch/p' | wc -l | sed 's/ *//g'
17:03:04 <dons> 397
17:03:07 <dons> yhc Np397
17:03:20 <sendark> todays xkcd is hilarious.
17:03:22 <ndm> dons: those things look right, as they stand, but wrong as they should be
17:03:29 <dons> ok. good.
17:03:36 <dons> at least I have a correctly built yhc then
17:03:47 <dons> now you just need to get fps distributed with yhc
17:03:52 <dons> (hey .. nhc98 comes with fps now ...)
17:04:00 <iron32> fps ?
17:04:03 <monochrom> Eh! lambdabot has upgraded to 6.6!
17:04:12 <dons> ?where fps
17:04:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
17:04:16 <dons> Data.ByteString, iron32
17:04:18 <ndm> we need to fix our performance bugs first
17:04:20 <dons> monochrom: indeed
17:04:25 <dons> ndm. well, that too :-)
17:04:31 <dons> yhi isn't the python interpreter, is it?
17:04:37 <sorear> dons: (compare `on` performance) (yhc with fps-0.8 superfusion) (ghc with fps-base nofusion)
17:04:44 <sorear> no, that's pyhi
17:04:46 <bos31337> dons: do you know anything about the HaskellNet stuff from last year's SoC?
17:04:55 <dons> bos31337: yeah. used it a bit. seems quite nice
17:05:00 <dons> needs a maintainer
17:05:03 <dons> ?where HaskellNet
17:05:04 <lambdabot> http://darcs.haskell.org/SoC/haskellnet/
17:05:06 <bos31337> hmmm.
17:05:09 <sorear> iron32: FastPackedString incase you care
17:05:14 <ndm> dons: thats pyhi :)
17:05:21 <bos31337> because i want to use JSONy stuff from it.
17:05:23 <sorear> yhi is written in C
17:05:24 <dons> sorear: right. nothing is running with stream fusion yet.
17:05:29 <dons> ah ok.
17:05:40 <ndm> we now have clock cycle profiling on the bytecode instructions, to help track down the performance
17:05:42 <dons> bos31337: you should be able to just grab it and have a poke around
17:05:47 <dons> it has good haddocks and some nice examples
17:05:49 <sorear> how big is yhi now ...
17:05:50 <bos31337> dons: am doing so.
17:05:56 <dons> ndm, ah that sounds useful
17:06:00 <bos31337> it seems to have diverged from the http module.
17:06:06 <dons> yep
17:06:21 <bos31337> that's a bummer.
17:06:24 <ndm> dons: only useful once you can compare it to before we broke it...
17:06:59 <dons> sorear: whaddya reckon. should we try for jhc support now?
17:08:20 <sorear> sure
17:08:33 <sorear> how much ram does the nobenchd have?
17:09:00 <dons> 1G
17:09:11 <dons> i can get more if we need it ;)
17:09:14 <sorear> also, jhc has many versions, and JohnMeacham advises unrecording as a tool for fixing problems :)
17:09:25 <dons> heh
17:09:34 <sorear> dons: ah good. with no rts flags jhc wants 600M
17:09:39 <dons> easy
17:09:45 <sorear> was a problem for my (384 core)
17:09:47 <dons> and that's just to build jhc?
17:09:51 <dons> or to bulid the test progs?
17:09:57 <sorear> latter
17:10:06 <sorear> (or is that 'snd' here?)
17:10:14 * monochrom goes around begging for 600M :)
17:10:25 <monochrom> Haha snd
17:10:35 <monochrom> (!! 1)  :)
17:12:18 <sorear> dons: john also advises only using tagged versions (latest is 'ejthecnar')
17:12:58 <dons> ok
17:13:13 <xerox> Goodnight.
17:13:14 <sjanssen> @google ejthecnar
17:13:16 <lambdabot> http://repetae.net/dw/darcsweb.cgi?r=jhc;a=rss
17:13:20 <dons> heh
17:13:23 <dons> google++
17:15:52 <iron32> sorear : Thanks sorry for late response was coding
17:16:11 <sorear> which one?
17:16:17 <chessguy> hmm, why doesn't it work to just import Graphics.SOE
17:16:27 <iron32> sorear: Yo told me what fps was
17:16:48 <iron32> sorear : I was thinking first person shooter myself
17:17:01 <sjanssen> chessguy: because it isn't in the base package?
17:17:05 <dons> mm. happily built nhc98 from darcs.
17:17:07 <dons> that was easy.
17:17:12 <sjanssen> chessguy: compile your programs with --make
17:17:31 <chessguy> it's in http://haskell.org/ghc/docs/latest/html/libraries/
17:17:48 <iron32> Actually I tired to get Hugs, Nhc98, Yhc to compile on cygwin with no luck anyone manage to do that
17:17:50 <chessguy> sjanssen, you mean just ghc Foo.hs --make
17:17:51 <chessguy> ?
17:18:10 <sjanssen> chessguy: ghc --make Foo.hs
17:18:42 <sjanssen> also, it's an extralib in GHC 6.6 (meaning that you might not have installed it already
17:18:46 <sorear> iron32: BITD ghc came with a module called PackedString (this was before Data. even); it was fairly space efficient but very slow.  Hence the "Fast"
17:19:11 <chessguy> sjanssen, is there an easy way to tell
17:19:15 <iron32> sorear : Thanks
17:19:44 <sjanssen> chessguy: see if hgl is in the output of ghc-pkg list
17:20:39 <sorear> dons: can I just wrap jhc in timeout or do I need to copy the exitcode hack?
17:21:12 <chessguy> it's not
17:21:50 <chessguy> so what do i need to be able to do to use Graphics.SOE
17:22:19 <fnord123> yaht doesn't really go in depth with 'readFile'. anyone know a good resource to bring someone up to speed on how to use it to read in a file and cut it up per line, and then for each line do some stuff with it?
17:22:27 <sorear> jbc: compile-jbc run-jbc   -- yay for search/replace!
17:22:39 <sorear> JohnMeacham's B Compiler ...
17:23:39 <sjanssen> chessguy: you need to install extralibs or hgl
17:23:46 <sjanssen> see ghc's downloads page
17:24:12 <chessguy> fnord123, check out http://www.haskell.org/haskellwiki/Simple_unix_tools
17:24:14 <lambdabot> Title: Simple unix tools - HaskellWiki
17:24:17 <monochrom> Is that you asking about SOE on haskell-cafe, chessguy? :)
17:24:38 <chessguy> sjanssen, weird, i have extralibs here. maybe i didn't install after upgrading to 6.6
17:24:50 <chessguy> monochrom, wow, you are way too smart for mee
17:26:06 <fnord123> that has no mention of readFile
17:26:15 * sorear tests nobench+jhc ... be back in:
17:26:26 <sorear> > (24 * 400) / 3600
17:26:28 <lambdabot>  2.6666666666666665
17:26:29 <nmessenger> @type readFile
17:26:32 <lambdabot> FilePath -> IO String
17:26:33 <sorear> 2.6 hours
17:27:08 <nmessenger> It gives you an IO String, so you can work with that string in, for example, an IO do block and beat up on it like you would any ordinary string.
17:28:00 * fnord123 wishes it was read in as an IO [String]
17:28:02 <chessguy> even weirder
17:28:04 <nmessenger> it's like getContents, it lazily reads the entire file
17:28:14 <nmessenger> @type fmap lines readFile "blah"
17:28:17 <lambdabot>     Couldn't match expected type `String'
17:28:17 <monochrom> Does, or doesn't, yaht go in depth with IO?
17:28:17 <lambdabot>            against inferred type `IO String'
17:28:20 <nmessenger> @type fmap lines (readFile "blah")
17:28:21 <chessguy> HGL just looked like it installed, but it still doesn't show up in ghc-pkg
17:28:23 <lambdabot> IO [String]
17:28:47 <sorear> dons: now testing nobench jhc.  I expect a lot of compiler timeouts :)
17:29:31 <monochrom> chessguy: how did you install hgl?
17:29:46 <chessguy> with the INSTALL script in the directory
17:31:32 <chessguy> oh, there are some unrecoverable errors near the beginning, but it keeps on going
17:31:39 <chessguy> @paste
17:31:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:32:02 <hpaste>  chessguy pasted "INSTALL output" at http://hpaste.org/570
17:32:19 <monochrom> Sounds like you build from source.  Will probably need lots of "blahblah-dev" packages from your linux distro.
17:32:31 * chessguy sighs
17:32:36 <chessguy> why does it have to be so difficult
17:33:01 <monochrom> building from source is seldom easy.
17:33:33 <chessguy> i suppose i could learn gtk2hs and port all the code to there
17:33:41 <monochrom> I'm wondering what's going on with the first few, i.e., "tar: HSHGL-3.00.tar.gz: Cannot open: No such file or directory".
17:34:16 <sjanssen> chessguy: I believe recent gtk2hs has an implementation of SOE
17:34:24 <sjanssen> it's supposed to have nicer rendering quality too
17:35:10 <chessguy> ?where gtk2hs
17:35:10 <lambdabot> http://haskell.org/gtk2hs/
17:36:12 <chessguy> dcoutts, dcoutts_ ping
17:37:29 <sorear> dons: jhc actually didn't time out on digits-of-e1
17:37:39 <sorear> dons: it hit the assertion failure :)
17:37:50 <darrint> Is there an easy way to get happs working in a little sandbox, where I can install libraries without affecting the rest of the machine?
17:38:02 <hpaste>  chessguy annotated "INSTALL output" with "for monochrom" at http://hpaste.org/570#a1
17:38:12 <dons> sorear: so any tests run successfully yet?
17:38:18 <sorear> no
17:38:34 <chessguy> ?where hshgl
17:38:34 <lambdabot> I know nothing about hshgl.
17:38:46 <sorear> two failures since ejthecnar can't build its own haskell98 package (no Ratio, etc)
17:39:08 <sorear> one due to Grin.FromE.toType: ELit (Jhc.Order.Bool#::ESort #)
17:39:32 <chessguy> fnord123, did you figure out how to do what you want to do?
17:39:40 <monochrom> I'm booting up my build box and going to simulate building hgl to see what is needed
17:40:14 <fnord123> chessguy, some of it
17:40:24 <chessguy> fnord123, what are you trying to do?
17:41:15 <monomorph> This is why I am called monomorph. :)
17:42:05 <sorear> 4/24
17:42:40 <chessguy> heh. guess it was top-secret
17:43:08 <darrint> I'm getting this message from Cabal: ghc-pkg.bin: /home/darrint/.ghc/i386-linux-6.4.2/package.conf: getPermissions: does not exist (No such file or directory)
17:45:17 <darrint> c'mon people, this is #haskell. You're supposed to be assailing me with answers. ;-)
17:45:44 <jcreigh> darrint: perhaps the file doesn't exist. :)
17:46:24 <LoganCapaldo_> touch /home/darrint/.ghc/i386-linux-6.4.2/package.conf
17:46:28 <LoganCapaldo_> there you go :)
17:47:14 <darrint> Ok. Wondered if there was some Setup.hs init-user-db or something.
17:47:53 <jcreigh> darrint: it's possible that LoganCapaldo_ was being sarcastic as well. I've never used Cabal, so I don't know if simple making any empty file is going to get you anywhere.
17:48:09 * darrint is trying it.
17:48:42 <jcreigh> LoganCapaldo_: ...and my apologies if your answer was serious. <g>
17:49:27 <fnord123> sorry chessguy. im having some compiz-killing-x problems..
17:49:36 <sorear> > let lagfib = take 607 [0..] ++ zipWith (+) (drop 607 lagfib) (drop 273 lagfib) in drop 100000 lagfib
17:49:38 <lambdabot>  Exception: stack overflow
17:49:42 <chessguy> mmm, ok
17:50:01 <kc5tja> dons: Sorry -- was afk doing office stuffs.  Not sure what you mean by combinator libraries.  "Combinator" is another one of those big words that doesn't mean much to me.  :)
17:51:44 <fnord123> gninght
17:52:17 * chessguy loads up on the sugar so he can spend all night hacking at haskell
17:52:41 <sorear> > let lagfib = [0..607] ++ zipWith (+) (drop 607 lagfib) (drop 273 lagfib) in drop 10000 lagfib -- yes, short RNGs can be written in Haskell
17:52:43 <lambdabot>  [473814684198596856660384254140116774218133150149156205958,48000786236712847...
17:53:00 <sorear> > let lagfib = [0..607] ++ zipWith (+) (drop 607 lagfib) (drop 273 lagfib) in drop 10000 lagfib :: [Int] -- need that modulo 1
17:53:02 <lambdabot>  [-450431610,-1809982425,-1108902440,-496270186,914861224,-1869002283,3038834...
17:53:07 <jcreigh> kc5tja: Parsec would be an example of a combinator library.
17:54:12 <chessguy> let lagfib = [0..607] ++ zipWith (+) (drop 607 lagfib) (drop 273 lagfib) in length $ show $ drop 10000 lagfib
17:54:17 <chessguy> > let lagfib = [0..607] ++ zipWith (+) (drop 607 lagfib) (drop 273 lagfib) in length $ show $ drop 10000 lagfib
17:54:21 <lambdabot> Terminated
17:54:55 <dons> kc5tja: little languages embedded in libraries
17:55:04 <sorear> it produces an infinite stream of randoms!
17:55:19 <dons> e.g. to build a html table,    table (map th ["1", "2", "3"] +++ map tr rows)
17:55:33 <chessguy> > let lagfib = [0..607] ++ zipWith (+) (drop 607 lagfib) (drop 273 lagfib) in length $ show $ head $ drop 10000 lagfib
17:55:34 <lambdabot>  57
17:55:39 <dons> uses functions to combine elements building up a structure that generates an html page
17:55:45 <chessguy> ohh, there is a comma in there
17:55:53 <dons> this is a combinator library. the functions like table/tr/th are "combinators"
17:55:55 <chessguy> i was confused for a minute there
17:56:11 <sorear> > let lagfib = fix (([(0::Int)..607] ++) . liftM2 (zipWith (+)) (drop 607) (drop 273) in drop 100000 lagfib
17:56:11 <lambdabot>  Parse error
17:56:21 <sorear> > let lagfib = fix (([(0::Int)..607] ++) . liftM2 (zipWith (+)) (drop 607) (drop 273)) in drop 100000 lagfib
17:56:22 <lambdabot>  [-382068572,-331158337,415910185,-728454907,-331465631,-905919186,-194951223...
17:56:46 <sorear> ^^^ behold, world's shortest (?) haskell RNG
17:56:59 <nmessenger> > 4 -- even shorter :)
17:57:01 <lambdabot>  4
17:57:13 <chessguy> xkcd++
17:57:17 <kc5tja> Ahh
17:57:48 <iron32> sometimes strict typing sucks
17:58:15 <nmessenger> you could alway circumvent it via Data.Dynamic
17:58:20 <dons> only if you want to run code with bugs in it ;)
17:58:36 <sorear> nmessenger: Dynamic is for wimps
17:58:48 <sorear> nmessenger: Real men use unsafeCoerce#
17:58:54 <iron32> Can I lift an Int to and IO Int ?
17:59:01 <sorear> yes, use 'return'
17:59:29 <sorear> down to primes and NOT ONE successful jhc run!
17:59:33 <dons> ah well.
17:59:42 <sorear> we need to add 'hello world' to even the odds :)
17:59:44 <dons> so um, Bulat's recommendation to use JHC was um? premature?
17:59:57 * dons likes numbers better than advocacy
18:00:32 <sorear> dons, Grin.FromE.toType: ELit (Jhc.Order.Bool#::ESort #) isn't a number
18:00:48 <iron32> I am trying to mix Int with IO Int basically I have a list of integers to which i need to add randoms numbers to and put them in Records which I guess must be type IO record
18:01:17 <sorear> no, an IO number is an action
18:01:20 <dons> iron32: no, use a pure stream of randoms
18:01:25 <bo> guys, anyone knows why there is a big jump in terms of haskell's ranking in computer lanaguage shootout? http://shootout.alioth.debian.org/sandbox/benchmark.php?test=all&lang=all
18:01:28 <lambdabot> Title: Create your own Overall Scores | Debian : AMD&#8482; Sempron&#8482; The Sandbox, http://tinyurl.com/ycoslq
18:01:31 <nmessenger> you could also use an explicit RNG instead of the global one in IO
18:01:31 <sorear> every time you look at it it produces a different answer
18:01:32 <dons> :t randomRs
18:01:35 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
18:01:41 <sorear> bo: what do you mean "jump"?
18:01:46 <thorat> I'm trying to build lambdabot and get "Setup.hs: cannot satisfy dependency plugins>=1.0",
18:01:49 <dons> bo, we ported the old entries to use ghc 6.6 (i.e. fixed broken entries)
18:01:55 <thorat> and can't find the package in debian
18:01:57 <dons> so it climbed back up to where it wsa this time ast year
18:01:59 <chessguy> thorat, you can remove that dependency
18:02:10 <bo> I remember that haskell was not as high as now
18:02:26 <bo> I remember clean is better than haskell before
18:02:26 <sorear> bo: ghc is much faster (though still much slower than the unmaintained-since-<95 hbc on some nobench tests)
18:02:28 <dons> yeah, for the last couple of months its been falling, since the entries weren't maintained, and some broke with ghc 6.6
18:02:43 <dons> we just fixed those entries (remembe rthis time last year ghc 6.4.2 was ranked first overall...)
18:03:13 <dons> sorear's advocating hbc now ;)
18:03:14 <bo> ah I see. interesting
18:04:00 <thorat> chessguy: sorry, how? <- newbie
18:04:16 <iron32> d10 :: IO Int
18:04:16 <iron32> d10 = getStdRandom ( randomR(1, 10)) how do I do a stream of random ints
18:04:25 <chessguy> thorat, edit the .cabal file and remove the part about plugins
18:05:05 <bo> is there any apt source for ghc6.6 on ubuntu?
18:05:17 <thorat> chessguy: oh, and fps as well?
18:05:43 <thorat> chessguy: apt-cache search haskell fps, returned nothing
18:06:00 <chessguy> if you have GHC 6.6 you can remove that, yes
18:06:16 <iron32> sorear does Hbc conform to Haskell 98 It seems to say Haskell 1.4
18:06:21 <thorat> chessguy: thanks, I did
18:06:24 <nmessenger> > randomRs (1,10) (mkStdGen 42) -- iron32, use some flavor of 'randoms'
18:06:25 <lambdabot>  [2,2,8,5,7,2,9,2,9,6,6,10,7,9,5,6,8,2,4,7,7,5,3,5,7,5,1,9,4,5,5,6,3,3,7,4,5,...
18:06:25 <thorat> chessguy: and I have
18:08:17 <sorear> > let lagfib = drop 100000 $ fix (([(0::Int)..607] ++) . liftM2 (zipWith (+)) (drop 607) (drop 273)) in map ((+5) . (`div` 214748364)) lagfib  -- muahahaha
18:08:18 <lambdabot>  [3,3,6,1,3,0,-5,1,-3,7,-5,-2,-4,3,2,1,-1,12,8,14,1,-1,6,6,8,-1,3,12,1,-4,-3,...
18:08:26 <thorat> $ ./build; spits out "scripts/BotPP.hs:41:25: Not in scope: `B.breakChar'"
18:08:33 <sorear> > let lagfib = drop 100000 $ fix (([(0::Int)..607] ++) . liftM2 (zipWith (+)) (drop 607) (drop 273)) in map ((+10) . (`div` 214748364)) lagfib  -- muahahaha
18:08:35 <lambdabot>  [8,8,11,6,8,5,0,6,2,12,0,3,1,8,7,6,4,17,13,19,6,4,11,11,13,4,8,17,6,1,2,16,1...
18:09:15 <thorat> ... when building lambdabot on debian etch ghc 6.6
18:09:22 <iron32> how do you send code to lambdabot ?
18:09:30 <sorear> darcs send
18:09:55 <sorear> or did you mean > foo ?
18:09:58 <sorear> > 2 + 2
18:10:00 <lambdabot>  4
18:10:06 <iron32> > 2 + 2
18:10:08 <lambdabot>  4
18:10:16 <iron32> thats what I meant
18:10:18 <nmessenger> the '>' command is short for @run
18:10:20 <nmessenger> @list
18:10:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:10:39 <iron32> > randomRs(1,10)
18:10:40 <lambdabot>  Add a type signature
18:10:41 <sorear> IRC limitations encourage obfuscated one liners
18:11:01 <darrint> Ok, I'm about to pull hairs out. Docs say: "The ghc-pkg tool knows where this file should be located, and will create it if it doesn't exist" But really, it just complains about it not existing and fails.
18:11:03 <sorear> that code I sent was a full lagged fibbonacci PRNG
18:11:05 <nmessenger> @type fmap (randomRs (1,10)) newStdGen
18:11:08 <lambdabot> forall t. (Num t, Random t) => IO [t]
18:11:18 <sorear> darrint: mkdir -p?
18:11:22 <nmessenger> ^^ that'll give you an IO stream of random Ints or whatever
18:11:25 <darrint> Been there, did that.
18:11:43 <darrint> It wants the file to exist and be of proper syntax.
18:12:02 <siti> is there a way to make timers in haskell without using glib/gtk2hs bindings?
18:12:03 <darrint> I did both just mkdir -p and touched the file.
18:12:28 <sorear> siti: threadDelay
18:12:28 <iron32> > randomRs(1,10)( mkStdGen 8 )
18:12:30 <lambdabot>  [6,6,1,10,10,10,10,10,9,4,3,3,4,1,7,2,3,7,10,9,2,8,3,10,8,5,7,5,4,7,2,5,3,3,...
18:12:48 <nmessenger> helpful commands: @help @run @type @src @docs @source @pl @undo, also LB listens to /msgs if you want to play
18:12:59 <iron32> > take 8 ( randomRs(1,10)( mkStdGen 8 ) )
18:13:00 <lambdabot>  [6,6,1,10,10,10,10,10]
18:13:01 <siti> sorear: a nice way :p e.g. timerCall 500 (somefunction)
18:13:46 <sorear> @pl \n f -> forkIO (threadDelay n >> f) --siti
18:13:47 <lambdabot> (forkIO .) . (>>) . threadDelay
18:14:33 <darrint> sorear: I got it. I put "[]" in package.conf and ghc-pkg was happy.
18:14:35 <iron32> so if I take 1 from a stream of random numbers then it is a Int and not within a Monad ?
18:14:46 <siti> hmm forkIO wont interact well with gtk2hs, and os level threads are to expensive I suppose I will just use gtk2hs functions then :p
18:14:49 * darrint mutters
18:15:04 <nmessenger> if you use mkStdGen, you get a pure RNG, so it won't be in the monad
18:15:23 <nmessenger> but if you just want one, you should just use randomR
18:16:02 <nmessenger> > randomR (1,10) (mkStdGen 42)
18:16:03 <lambdabot>  (2,1720602 40692)
18:16:20 <nmessenger> > randomR (1,10) (read "1720602 40692")
18:16:21 <lambdabot>  Add a type signature
18:16:58 <iron32> nmessenger I think you are missing a s it is "randomRs"
18:17:35 <nmessenger> the -s versions give you an infinite list, the non-s versions give you one value and an updated RNG.
18:17:36 <iron32> Hmm I have a lot to learn
18:17:52 <iron32> oh I see so I can get just one
18:18:02 <nmessenger> > fst $ randomR (1,10) (mkStdGen 42)
18:18:03 <lambdabot>  2
18:18:35 <nmessenger> > randomR (1,10) (snd $ randomR (1,10) (read mkStdGen 42)) -- using the updated RNG
18:18:36 <lambdabot>  Couldn't match expected type `String'
18:18:41 <nmessenger> bleh
18:19:09 <nmessenger> > randomR (1,10) (snd $ randomR (1,10) (mkStdGen 42)) -- had 'read' for some reason :/
18:19:11 <lambdabot>  (2,128694412 1655838864)
18:20:10 <nmessenger> basically, when you call a function it returns a (value, updatedRng) pair.  You can use the value and pass the updated RNG into the next call.
18:20:21 <iron32> well this should make my life so much easier thanks all
18:24:50 <iron32> actually your random numbers did not seem to work they retun the same number everytime I guess thats why I need a monad since that is strcitly a side effect
18:25:22 <nmessenger> it looked like it worked, it just returned 2 twice
18:25:47 <sendark> @hoogle Parse error in pattern
18:25:48 <lambdabot> Did you mean: Parse Error In Pattern
18:25:53 <sendark> yes
18:25:53 <iron32> I returns 2 every single time for me
18:26:06 <sendark> @hoogle Parse Error In Pattern
18:26:07 <lambdabot> No matches, try a more general search
18:26:12 <sendark> hmm
18:26:27 <nmessenger> iron32: you didn't pass in the same RNG did you?
18:27:24 <iron32> well can I pass a random number to RNG then ?
18:28:25 <nmessenger> The RNG is the thing you pull the random numbers out of.  You call the various 'random*' functions to extract a value and get a new version of the RNG that will give you a different number.
18:28:38 <iron32> but to be honest conceptual I can't see creating a function that returns a random number without wrapping it in a Monad
18:29:33 <nmessenger> think of a StdGen as an infinite list of already-made numbers.  You can construct one several ways, by using a specific seed value, for instance.
18:29:42 <nmessenger> > mkStdGen 8
18:29:44 <lambdabot>  9 1
18:30:05 <LoganCapaldo> > mkStdGen 42
18:30:06 <lambdabot>  43 1
18:30:08 <nmessenger> (mkStdGen someSeed) will always generate the same numbers given the same seed.
18:30:28 <LoganCapaldo> @src mkStdGen
18:30:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:30:32 <bo> iron32: can I think it in this way? the pseudo rand gen has a long list of rand numbers stored internally and you pass in an index it returns the corresponding number back?
18:30:34 <LoganCapaldo> @src StdGen
18:30:34 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:30:59 <nmessenger> you can use the newStdGen action to make a new generator in IO initialized using the clock or something suitable
18:31:02 <nmessenger> @type newStdGen
18:31:05 <lambdabot> IO StdGen
18:31:31 <LoganCapaldo> @src show :: StdGen -> String
18:31:31 <lambdabot> Source not found. My pet ferret can type better than you!
18:31:41 <LoganCapaldo> I'm having a lousy time of this :)
18:32:04 <nmessenger> LoganCapaldo: use @src Type method for class methods, though StdGen probably won't work.
18:32:11 <iron32> bo : Well I fail to see how that simulates a die roll when I have to give it a seed each time ?
18:32:22 <LoganCapaldo> @src StdGen show
18:32:23 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:32:26 * LoganCapaldo had to try it
18:32:45 <LoganCapaldo> 43 1 and 9 1 just seem like really odd impls of show :)
18:32:55 <bo> iron32: you r right.
18:33:11 <nmessenger> > do g1 <- newStdGen; let {(x, g2) = randomR (1,6) g1; (y, g3) = randomR (1,6) g2}; return (x,y,g3)
18:33:12 <lambdabot>   add an instance declaration for (Typeable StdGen)
18:33:31 <allbery_b> normally you stuff the StdGen in a State (or StateT IO, etc.) monad, and pass it around thgat way
18:33:54 <nmessenger> ^^ something like that (modulo errors :)) is how you would use an IO action to generate two random numbers.
18:33:58 <allbery_b> the wiki has a MonadRandom that keeps the state for you, I think, as am alternative
18:34:21 <iron32> Which leaves me with the problem of how to add Int to an IO Int
18:34:44 <iron32> If I lift the Int to an IO Int can I add them ?
18:34:56 <LoganCapaldo> iron32, you got it backwards :)
18:34:59 <nmessenger> @type \i mi -> fmap (i+) mi
18:35:02 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => a -> f a -> f a
18:35:02 <allbery_b> do it inside IO.  do n <- something_that_produces_IO_Int; return (n + 3)
18:35:13 <allbery_b> or liftM (+3) something_that_returns_IO_Int
18:35:38 <LoganCapaldo> you must temporarily pull the IO Int out add em and put the sum back in
18:36:01 <allbery_b> @wiki New_monads/MonadRandom
18:36:01 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
18:36:04 <nmessenger> iron32: you can either lift the addition into the IO Int, or use do syntax to pull the Int down and return the result back up.
18:36:08 * LoganCapaldo nominates self for most imperative description of monads ever
18:36:33 <iron32> nmessenger : I though once you enter the Monad you can never get out ?
18:36:51 <nmessenger> iron32: right, that's why you need to return at the end of the do.
18:36:52 <LoganCapaldo> iron32, that actually depends on the monad
18:37:01 <allbery_b> you can temporarily escape.  the usual way is to do something in IO then invoke pure code on it
18:37:03 <LoganCapaldo> but for IO yes, there is no escape :)
18:37:26 <allbery_b> that code will execute "within" the IO monad but you don't need to worry about it
18:37:28 * nmessenger quietly mumbles something about a certain "unsafe" function...
18:37:40 <LoganCapaldo> nmessenger, that doesn't exist, shh!
18:37:53 <LoganCapaldo> implementation detail, implementation detail!
18:37:55 <iron32> nmessenger PerformUnsfeIO is evil
18:37:58 <nmessenger> :)
18:38:01 * LoganCapaldo plugs fingers in ears
18:38:43 <nmessenger> do pureInt <- someIoInt; return (someFunctionOn pureInt)
18:38:45 <allbery_b> do { x <- something_producing_IO_Int; return (myPureFunc x) } where myPureFunc n = {- pure code here -}
18:38:54 <nmessenger> heh
18:39:37 <nmessenger> @undo do x <- action; return (f x)
18:39:38 <lambdabot> action >>= \ x -> return (f x)
18:39:51 <nmessenger> @pl action >>= \ x -> return (f x)
18:39:51 <lambdabot> f `fmap` action
18:40:00 <nmessenger> ^^ another way to write the same thing.
18:40:19 <allbery_b> something_producing_IO_Int >>= return . myPureFunc {- yet another way to write it -}
18:40:54 * beelsebob_ pokes about for darcs authors
18:41:01 <beelsebob_> (or darcs knowledgable people)
18:41:11 <LoganCapaldo> @type liftM2 (+)
18:41:13 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
18:41:43 <LoganCapaldo> liftM2 (+) ioInt (return pureInt)
18:41:53 <LoganCapaldo> for yet another way
18:42:05 <nmessenger> but that's ugly!  To much IO!
18:42:20 <nmessenger> too* even
18:42:38 <allbery_b> (+3) `liftM` ioInt -- :)
18:42:43 <LoganCapaldo> I'll let lambdabot tells me when it's too ugly :)
18:42:56 <allbery_b> lambdabot doesn't care about ugly :)
18:42:59 <nmessenger> You use (>>=) to connect actions together, the reason you can't escape the monad is because (>>=) requires its second argument to eventually end up in the same monad.
18:43:04 <allbery_b> @quote flip-stream
18:43:04 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
18:43:07 <LoganCapaldo> (+pureInt) `liftM` ioInt -- you mean
18:43:29 <nmessenger> but in the meantime, it uses the pure value from the first action when making the second action
18:43:30 <allbery_b> sure, but I was using (+3) earlier as my example
18:43:33 <nmessenger> @type (>>=)
18:43:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:43:37 <LoganCapaldo> Bah!
18:43:38 <svref> how do I check if there's a file at /home/foo/blah.txt?
18:43:42 <LoganCapaldo> Open it
18:44:07 <LoganCapaldo> just kidding
18:44:10 <svref> no probeFile then...
18:44:11 <allbery_b> there's also getFileStatus on POSIXish systems
18:44:34 <allbery_b> Win32 has its own functions for that kind of thing as well, but I can't help there
18:44:52 <svref> Opening it sounds like the portable way.
18:45:13 <LoganCapaldo> svref, sometimes people get mad when I suggest things like that
18:45:21 <LoganCapaldo> So I throw on the just kidding just in case
18:45:24 <LoganCapaldo> ;)
18:45:36 <svref> AHA!  I KNEW YOU WERE SERIOUS!  PREPARE TO DIE!
18:45:48 <svref> hehe
18:46:34 * nmessenger makes a note not to kid around with svref
18:46:40 <allbery_b> well, open for read can be unfortunate when it's a unix device file or fifo (and won't work for AF_UNIX sockets)
18:46:51 <sjanssen> svref: I think the best way to do it is with System.Directory
18:47:36 <sjanssen> @type \f -> liftM2 (||) (System.Directory.doesFileExist f) (System.Directory.doesDirectoryExist f)
18:47:39 <lambdabot> FilePath -> IO Bool
18:48:00 <svref> doesFileExist?  Wonder why that didn't show when I hoogled "exist"?
18:48:23 <svref> ah, I hoogled "exists".  Newbie error.
18:48:24 <sjanssen> @hoogle exist
18:48:25 <lambdabot> Distribution.Extension.ExistentialQuantification :: Extension
18:48:25 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
18:48:25 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
18:49:56 <dons> xhtml makes scripting fun!   http://www.cse.unsw.edu.au/~dons/nobench/results.html
18:49:56 <lambdabot> Title: nobench: Haskell implementation shootout
18:49:59 <dons> :-)
18:52:12 <svref> I didn't even know about some of those implemenattions.
18:52:24 <araujo> yay!
18:52:56 <mbishop> is that a response to the ruby shootout?
18:53:14 <dons> no, it wasn't. but then the day after I wrote this, i saw the ruby shootout
18:53:24 <araujo> dons, no jhc?
18:53:28 <dons> nice coincidence
18:53:36 <dons> araujo: we've not been able to get jhc to pass *any* tests yet
18:54:28 <mbishop> http://programming.reddit.com/info/15pzz/comments
18:54:30 <lambdabot> Title: Haskell implementation shootout (reddit.com)
18:54:31 <mbishop> :P
18:54:33 <svref> so the moral of the story is "ghc".
18:55:16 <dons> yikes. the shootout is only part way through its run
18:55:57 <sjanssen> ghc-old wins fairly often
18:56:09 <mbishop> yeah, that's kind if weird heh
18:56:20 <araujo> dons, oh, ok
18:56:25 <dons> sjanssen: I think thats cachine.
18:56:29 <dons> cacheing.
18:56:42 <dons> e need to do best-of-3 runs I think
18:56:56 <christine_c> hi people
18:57:06 <sjanssen> yeah
18:57:27 <sjanssen> dons: or make the compilers you want to win run last :)
18:57:52 <mbishop> heh
18:58:04 <dons> hehe
18:58:15 <christine_c> im doing elementary nlp, im looking for sql select grammar, do you know some sites on this? please
18:58:55 <nmessenger> @vera nlp
18:58:57 <lambdabot> *** "nlp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:58:58 <lambdabot> NLP
18:58:58 <lambdabot>      Natural Language Processing
18:58:58 <lambdabot>  
18:58:58 <lambdabot> *** "nlp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:58:59 <lambdabot> [7 @more lines]
18:59:03 <ddarius> @help remember
18:59:03 <lambdabot> quote <nick>
18:59:04 <lambdabot> remember <nick> <quote>
18:59:05 <lambdabot> Quote somebody, a random person, or save a memorable quote
18:59:36 <ddarius> @remember ptolomy Heh. I love that I find myself, when dealing with non-Haskell languages, often thinking, "Golly, this would easier if this language had documentation / community help like haskell.."
18:59:36 <lambdabot> Done.
19:01:40 <mbishop> @remember corentin C is the language of the gods? Fine, I'm an atheist.
19:01:41 <lambdabot> Done.
19:02:52 <christine_c> hi
19:03:13 <Excedrin> @quote c
19:03:13 <lambdabot> dons says: "academic" is such an amusing insult.
19:03:15 <allbery_b> I don't think this is the right place to look for SQL information
19:03:41 <allbery_b> you might try someplace like #mysql
19:03:49 <christine_c> ok thanks
19:04:06 <iron32> Thanks a lot for all you help I got it working
19:04:14 <nmessenger> \o/
19:04:25 <iron32> and Improved my Knowledge of monads too
19:04:34 <iron32> :)
19:05:38 <nmessenger> meh.  A monad is just something that can be (f)mapped over, joined together, and returned into.  It's really not so much scarier than that.
19:07:06 <iron32> well not everyone is a Haskell master ;)
19:07:18 <siti> :D
19:07:27 * nmessenger is definately not one of those. D:
19:07:50 <mbishop> only dons
19:07:51 <mbishop> and cale
19:07:52 <mbishop> ;P
19:08:21 <nmessenger> I've just found that when I go to *use* a thing with a scary name, I find there's usually not really much there to be afraid of.
19:08:40 <iron32> Modelling IO with monads might be the most logical thing but it sure isn't the easiest
19:08:59 <sorear> ... back
19:09:07 <allbery_b> enh.  it's not really that bad
19:09:22 <allbery_b> most of the time you can lift stuff out and work purely
19:10:15 <nmessenger> the following page *really* helped my understanding of the IO monad in particular, I recommend it:
19:10:18 <nmessenger> @wiki IO_inside
19:10:19 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
19:11:29 <iron32> thanks I will look at it
19:11:51 * ddarius is depressed by the lack of logo on that page.
19:13:13 <allbery_b> heh
19:13:27 <nmessenger> a function takes some parameters and results in a value, so if it depends on or changes the outside world, logically, the outside world should be one of its parameters.
19:14:36 <nmessenger> the only sensible thing you can do with the real world is destructively update it, which you can do purely functionally, so long as you never re-use an old world.
19:15:03 <Excedrin> it's interesting that nhc98 is always faster than yhc, and that hugs is faster than either in one case; I guess jhc fails to compile most of the tests?
19:15:25 <nmessenger> the IO monad as explained on that page is just a world-parameterized state transistion function.
19:17:14 <nmessenger> (though, as some have mentioned, its not the necessarily the *best* way to implement the IO type, but it can give a semblance of understanding)
19:18:36 <Excedrin> I guess "20% faster than nhc" on the yhc page is based on some other set of benchmarks
19:18:43 <allbery_b> really, you could do it by having every IO function take a final argument which is some non-instantiable (without hackery) value
19:18:59 <dons> it was at one point, but they've introduced some slow downs.
19:19:02 <sorear> Excedrin: much older benchmarks.  you should read the ML, ndm was as suprised as you are
19:19:12 <dons> Excedrin: yeah, jhc fails to compile or run any of the tests :-)
19:19:21 <SamB> dons: typical
19:19:28 <sorear> dons: where does it say jhc failed?
19:19:40 <Excedrin> dons: based on the darcs jhc?
19:19:43 <sorear> dons: results.html doesn't list jhc
19:19:54 <Excedrin> sorear: it was mentioned earlier on irc
19:20:57 <thorat> dons: $ ./build; spits out "scripts/BotPP.hs:41:25: Not in scope: `B.breakChar'"
19:21:03 <thorat> ... when building lambdabot on debian etch ghc 6.6
19:21:16 <dons> thorat: grab darcs version of lambdabot
19:21:25 <thorat> k
19:22:57 * ddarius should fire up his darcs and start pulling stuff.
19:23:57 <iron32> Anyone here use HARE ?
19:24:13 <thorat> I will
19:24:33 <thorat> vim and haskell, a match made in heaven
19:24:46 <iron32> thorat : It only supports Vim ?
19:24:53 <thorat> uh, dunno
19:25:02 <thorat> but I will know ;)
19:25:53 <sorear> dons: looking at your latest patch 'more stuff', it appears it will fromJust: Nothing if passed "jhc".  I take it this means jhc isn't being included?
19:25:55 <iron32> So far I am using Eclipse as my Haskell IDE but I would like to have the ability to refacotr code
19:26:08 <dons> sorear, well, that's a quick hack.
19:26:10 <dons> :-)
19:26:17 <dons> if we can get jhc to pass, say, 1/4 of the tests
19:26:19 <dons> then i'll include it
19:26:47 <thorat> iron32: according to web page it supports emacs as well
19:26:50 <sorear> dons: if we include it now JohnMeacham might just fix the assertion failure
19:27:13 <dons> true. i'd need to build it first. 'll try to do that tonight
19:27:32 <sorear> ah.
19:27:39 <LoganCapaldo> refactor haskell code?
19:27:48 <sorear> in that case there is yet hope, I gave up halfway throug.
19:27:56 <iron32> Well I have had trouble with the Haskell mode for Xemacs under both windows and cygwin
19:28:04 <SamB> LoganCapaldo: is it such a strange concept?
19:28:19 <LoganCapaldo> My brain can barely handle a non-messy haskell function
19:28:26 * ddarius seriously considers making a native Win32 ion.
19:28:33 <LoganCapaldo> much less one so messy that it needed to be refactored
19:28:48 <nmessenger> I usually just change stuff and let the compiler point out all the dependencies
19:28:50 <dons> some of these runtime numbers look quite small sorear
19:28:53 <iron32> Well refactoring can be simple as renaming things
19:29:01 <dons> we're just measuring only cpu time for what now?
19:29:13 <iron32> or more complex
19:29:21 <sorear> CPU time
19:29:32 <sorear> cumulative cpu time
19:29:44 <SamB> LoganCapaldo: heh
19:32:16 <nmessenger> a common "refactoring" you learn is giving names to confusing sub-expressions in a where clause
19:32:34 <iron32> :t ++
19:32:36 <allbery_b> iron32: haskell-mode is nt well tested under xemacs, and under some versions xemacs deals *very* poorly.  I updated my xemacs and got something that mostly works
19:32:37 <lambdabot> parse error on input `++'
19:32:39 <tautologico> has anyone here head "the algebra of programming" by bird and de moor?
19:32:41 <allbery_b> :t (++)
19:32:44 <lambdabot> forall a. [a] -> [a] -> [a]
19:34:23 <iron32> allery_b : well I hacked on it a while got something mostly working but decdided that the eclipse FP plugin gave me more out of the box for less hassle
19:35:14 <monochrom> I have read "the algebra of programming" by bird and de moor.
19:36:00 <iron32> monochrom any good
19:36:16 <tautologico> monochrom: is it good? I can't find it anywhere, only copies priced over a hundred bucks
19:37:28 <allbery_b> eclipse is painfully slow on my g4 macmini :)
19:38:02 <dufflebunk> s/on my g4 macmini :)/:(/
19:38:06 <dufflebunk> fixed that for you
19:38:39 * dufflebunk has to use eclipse for some work on occasion
19:38:42 <emu> someone needs to write shim-vim
19:39:10 <sorear> dons: how much do I need to edit to add a new benchmark?  just imaginary/Makefile?
19:39:20 <iron32> allery_b : Well runs great on my Pentium 3 GHZ
19:39:40 <monochrom> It is deep.  It is about deriving implementation from specification.  To get an idea whether you will want it or not, try reading some papers of Bird first.  Look for those on "greedy algorithms" and "dynamic programming", the book is an organized version of those topics.
19:40:26 <tautologico> monochrom: I know, squiggol, bird-meertens formalism, isn't it? I wanted to know exactly if the book offers something for someone who has read some of the papers
19:41:36 <dons> sorear: right.
19:41:49 <dons> sorear: what kind of benchmark? hello world?
19:41:57 <sorear> dons: ok, than my patch should be valid
19:42:02 <sorear> yeah, pretty much
19:42:18 <sorear> it highlights the 0.65s for ghci ... slowest impl by a longshot
19:42:31 <sorear> guess which of my compilers is fastest for nop :)
19:42:47 <sorear> jhc                  0.000    seconds            (NaN x)
19:43:02 <sorear> followed by a three-way 0.020 tie yhc/ghc/ghc-old
19:43:17 <dons> ah, i see why nhc98 is winning integer. no output, nhc98 does nothing
19:43:21 <dons> the others are all stricter ;)
19:43:35 <sorear> dons: you need to diff the output :p
19:43:46 <dons> no. they all produce no output
19:43:57 <dons> and nhc is the only one that decides that means 'dont do anything at all' :-)
19:44:00 <dons> but yes, diffs required
19:44:11 <dons> it relies on
19:44:12 <dons> seqlist [] = return ()
19:44:12 <dons> seqlist (x:xs) = x `seq` seqlist xs
19:44:19 <dons> but nhc just ignores that, it seems
19:45:09 <sorear> reminds me of a certain shootout problem ;)
19:45:29 * dons adds a print statement
19:45:39 <jcreigh> am I the only one who has to look up the recommended Data.Map import stanza everytime I use it?
19:45:58 <monochrom> I believe if you know the stuff in Bird's papers, you do not need the book.
19:46:02 <sorear> jcreigh: I think you are the only person who actually uses it.
19:46:02 <dons> import qualified Data.Map as M
19:46:05 <glguy> jcreigh: how do you mean?
19:46:12 <jcreigh> import Data.Map (Map)
19:46:14 <thorat> iron32: maybe you'd like to check out "Calculating Functional Programs" by gibbons
19:46:15 <sorear> the rest of us just use what dons said
19:46:17 <jcreigh> import qualified Data.Map as Map
19:46:29 <tautologico> monochrom: thanks
19:46:38 <lispy> import qualified Data.Map as Pete <-- this is even better
19:46:41 <jcreigh> dons: with that, do you refer to the type as M.Map?
19:46:48 <sorear> yeah!
19:46:51 <ddarius> Hmm, if they can do that with about 20 C++ files, surely I can do what I want with like 3 Haskell files.
19:46:57 <nmessenger> Pete.empty :(
19:46:59 <sorear> import qualified Data.Map as Set
19:47:11 <nmessenger> !! D:
19:47:36 <sorear> hmm.  remind me to enter the #3 iohcc :)
19:47:53 <sjanssen> import qualified Data.Map as Prelude
19:47:55 <LoganCapaldo> import qualifed Data.Map as PeteAndRepeat
19:47:56 <lispy> sorear: iohcc?
19:48:09 <sorear> @google ioccc
19:48:12 <lambdabot> http://www.ioccc.org/
19:48:12 <lambdabot> Title: The International Obfuscated C Code Contest
19:48:15 <nmessenger> blah obfuscated haskell blah blah
19:48:27 <lispy> ah, i see
19:48:29 <sjanssen> does the report say how "import ... as Prelude" should work?
19:48:48 <sorear> import qualified Prelude as Data.Map
19:49:09 <nornagon> heh
19:49:28 <nmessenger> can one qualify-rename to a name with dots like that?  It never occured to me to try.
19:49:34 <jcreigh> okay, I think I'm going to go with dons's answer. :P
19:49:44 <lispy> fellout Pete = do {person <- ask; whoisleft person; } whoisleft Pete = undefined; whoisleft Repeat = fellout Pete
19:49:47 <sorear> dots are ordinary characters in module names
19:51:06 <sorear> jhc output is consistently faster than yhc output
19:51:26 <thorat> when building lambdabot (darcs) on debian etch (ghc 6.6), "Setup.hs: cannot satisfy dependency arrows-any"
19:51:45 <lispy> hrm
19:51:47 <thorat> apt-cache search haskell arrows, returns nothing
19:52:05 <lispy> how about ghc-pkg list | grep arrows
19:52:24 <dons> ah we do need to diff. nhc98 now produces incorrect output for that test too
19:52:37 <thorat> nope
19:53:04 <thorat> arrows are standard, aren't they?
19:53:54 <sorear> standard, yeah - it's in the standard extralibs bundle
19:54:25 <sorear> whoever compiled your ghc messed up and put arrrows into its own package
19:54:59 <monochrom> I wouldn't say it's messed up.
19:55:11 <sorear> I would.
19:55:55 <iron32> Well good night all thanks again for the help
19:56:11 <monochrom> There are now two rivaling philosophies on distributing ghc.  Some say include those libs.  Some others say separately.  The debianians are inclined to the latter.
19:56:28 <thorat> but they failed to package it seperately as well
19:56:44 <LoganCapaldo> the debianians are always inclined to seperate things
19:56:46 <thorat> that's what I mean by the apt-cache search comment
19:56:57 <kc5tja> I prefer Debianese over Debianians.  :)
19:56:57 <LoganCapaldo> they're seperatists I say
19:57:03 <monochrom> I'm going to name you the arrows package.
19:57:14 <kc5tja> Although I'm a Slackwarian myself.  :)
19:57:34 <sorear> libghc6-arrows-dev, if it exists
19:57:43 <monochrom> libghc6-arrows-dev, available in both "unstable" and "testing"
19:57:47 <LoganCapaldo> they've also chopped ruby into teeny tiny little pieces
19:57:51 <monochrom> http://packages.debian.org/cgi-bin/search_packages.pl?keywords=arrow&searchon=names&subword=1&version=all&release=all
19:57:54 <lambdabot> Title: Debian -- Debian Package Search Results, http://tinyurl.com/2e8f7q
19:58:01 <thorat> aaaaah,
19:58:11 <sorear> libghc6-$package-dev
19:58:13 <monochrom> I don't use Debian and I still know how to find.
19:58:15 <thorat> you're right, why did the apt-cache search not find it
19:58:24 <monochrom> apt-get update ? :)
19:58:25 <thorat> sorry
19:58:41 <monochrom> Or you're on "stable"? :)
19:59:02 <thorat> no, it's because I used arrows, not arrow
19:59:08 <monochrom> oops :)
19:59:10 <thorat> and arrows only occurs in the title
19:59:15 <thorat> not the desctription
19:59:21 <thorat> hrmf
19:59:38 <LoganCapaldo> @arr
19:59:38 <lambdabot> Aye Aye Cap'n
19:59:44 <monochrom> computers are still dumb :)
20:00:12 <LoganCapaldo> @type arr
20:00:15 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
20:00:26 <lispy> monochrom: yeah, but at least they're not idiots
20:00:31 <LoganCapaldo> @type arr id
20:00:33 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
20:00:44 <LoganCapaldo> That's funny
20:00:48 * ddarius could go for more people being dumb.
20:00:56 <LoganCapaldo> I was kind of expecting (->) b b
20:01:03 <monochrom> Initially I thought of using "debians" to refer to debian people. :)
20:01:03 <kc5tja> Dude, wtf?  Did the author of lambdabot think of every conceivable mistyped @-code?  That was the funniest response from a bot I've ever seen!
20:01:15 <allbery_b> @help arr
20:01:16 <lambdabot> arr. Talk to a pirate
20:01:24 <LoganCapaldo> @vixen you've seen naugh yet
20:01:25 <lambdabot> <undefined>
20:01:29 <TSC> Duh, I installed HaXml from source this morning without even checking the debian packages |:
20:01:29 <LoganCapaldo> hmm
20:01:30 <kc5tja> @noodly appendage
20:01:30 <lambdabot> Unknown command, try @list
20:01:31 <allbery_b> vixen still b0rked
20:01:42 <allbery_b> @list quote
20:01:42 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
20:01:46 <lispy> ah, vixen is broken?
20:01:50 <SamB> @girl19
20:01:51 <lambdabot> I'm in Moscow, Russia
20:01:54 <monochrom> The author of lambdabot did think of every conceivable and inconceivable mistyped @-code.
20:01:55 <SamB> lispy: has been since some regex change
20:01:57 <lispy> ?v
20:01:58 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:01:58 <allbery_b> new Data.Binary broke it
20:02:04 <lispy> ?yhjulwwiefzojcbxybbruweejw
20:02:04 <lambdabot> "\""
20:02:11 <lispy> ?keal
20:02:12 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
20:02:15 <monochrom> In fact he went so far as to think of mistyped ?-code too.
20:02:20 <_TalonAWD> hey im looking for a coder to pull something off a eerpom on a ECU willing to $$
20:02:23 <allbery_b> @b52s
20:02:23 <lambdabot> Girl from Ipanema, she goes to Greenland
20:02:27 <ddarius> @<solution-to-the-halting-problem>
20:02:28 <lambdabot> Unknown command, try @list
20:02:33 <SamB> actually, it is just a spellchecker ;-P
20:02:38 <lispy> _TalonAWD: sorry mate no idea :(
20:02:42 <_TalonAWD> :(
20:02:47 <SamB> @k
20:02:48 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . v
20:02:51 <LoganCapaldo> @. leet arr
20:02:52 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "leet"
20:02:55 <SamB> @z
20:02:57 <lambdabot> Maybe you meant: . v
20:03:00 <SamB> @y
20:03:01 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . v
20:03:01 <lispy> ?. eleet keal
20:03:02 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "eleet"
20:03:04 <SamB> @yow
20:03:05 <lambdabot> ... I want to perform cranial activities with Tuesday Weld!!
20:03:06 <jcreigh> @. elite arr
20:03:06 <lambdabot> y0 HO HO, 4nD a Bo+7|E oF RuM!
20:03:11 <lispy> ?. elite keal
20:03:11 <lambdabot> i suGge5T joo T3Ar 4pAR7 A 20q 4ND PLUg IT wi+H T|-|e al9
20:03:14 <allbery_b> compose doesn't do the edi distance stuff
20:03:16 <sorear> @where+ prod VERSION
20:03:17 <lambdabot> Done.
20:03:20 <allbery_b> edit distance
20:03:29 <bd_> @where prod
20:03:32 <bd_> heh
20:03:41 <bd_> maybe lb should just prefix all of its lines with a space :)
20:03:47 <kc5tja> Darn, no @zippy command.  :)
20:03:54 <kc5tja> Perhaps it's for the better.
20:03:55 <sorear> kc5tja: it's there
20:03:57 <sorear> @yow
20:03:57 <allbery_b> @yow
20:03:57 <lambdabot> Hold the MAYO & pass the COSMIC AWARENESS ...
20:03:58 <lambdabot> Oh my GOD -- the SUN just fell into YANKEE STADIUM!!
20:03:59 <SamB> kc5tja: @yow
20:04:01 <kc5tja> Ah ha!
20:04:17 <bd_> or for extra bonus points use that template haskell hack in PH a few days back to safely interpolate untrusted strings with static checking for the proper escapes
20:04:18 <sorear> lambdabot: @yow
20:04:19 <lambdabot> NEWARK has been REZONED!!  DES MOINES has been REZONED!!
20:04:26 <goban> [CTCP] Received Version request from lambdabot to channel #haskell.
20:04:33 <lispy> @. girl19 yow
20:04:34 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
20:04:36 <goban> why did that :?) sukoshi?
20:04:46 <sorear> goban: because bd_ told it to
20:04:53 <lispy> ?localtime goban
20:04:54 <lambdabot> Local time for goban is Tue Feb 20 23:03:08 2007
20:04:55 <sorear> <bd_> @where prod
20:04:58 <allbery_b> sorear did something evil, bd_ set it off :)
20:05:00 <bd_> sorear: I blame sorear :)
20:05:08 <SamB> what is that funky 
20:05:14 <sorear> \001
20:05:16 <bd_> SamB: \001, it's the CTCP encoding
20:05:19 <bd_> ... thing
20:05:20 <lispy> SamB: hi!
20:05:22 <monochrom> We should all /ctcp version SamB
20:05:27 <LoganCapaldo> @localtime LoganCapaldo
20:05:30 <lambdabot> Local time for LoganCapaldo is Tue Feb 20 23:04:51 2007
20:05:32 <SamB> oh
20:05:34 <SamB> nasty!
20:05:38 <glguy> @localtime #haskell
20:05:45 <SamB> I thought CTCP was encoded sanely
20:05:45 <tautologico> blimey
20:05:56 <monochrom> You flood us, we flood you. :)
20:05:57 <allbery_b> that oughta hurt a bit :)
20:05:58 <tautologico> @localtime lambdabot
20:05:59 <lambdabot> I live on the internet, do you expect me to have a local time?
20:06:07 <bd_> SamB: it's not :/
20:06:09 <kc5tja> I hardly consider two lines of CTCPs a flood though.  :)
20:06:09 <monochrom> hahahaha
20:06:11 <tautologico> @localtime glguy
20:06:12 <lambdabot> Local time for glguy is Tue Feb 20 22:04:12 2007
20:06:19 <bd_> SamB: I mean, this is IRC, you expect anything related to IRC to be sane? :)
20:06:22 <SamB> I'm really the one who got flooded
20:06:58 <lispy> *** Undefined CTCP query received. Silently ignored
20:07:10 <bd_> @localtime freenode:#haskell
20:07:11 <glguy> LOL, not silent for you though ;)
20:07:16 <bd_> ooh.
20:07:41 <LoganCapaldo> lambdabot, I don't know what time it is!
20:07:42 <monochrom> Heh, you flood yourself, we flood you. :)
20:07:44 <sorear> @msg #haskell UTC 100
20:07:59 <bd_> sorear: that's cheating >.>
20:08:16 <bd_> lambdabot probably ought to strip \001 from its input :)
20:08:19 <glguy> !say yawn
20:08:20 <hpaste> yawn
20:08:30 <allbery_b> control chars in general, I'd say
20:08:43 <lispy> hpaste: hi, i don't think we've met yet
20:08:44 <sorear> !msg nickserv identify :)
20:09:13 <nmessenger> @where+ prod /msg #haskell Yarr!
20:09:14 <lambdabot> Done.
20:09:17 <nmessenger> @where prod
20:09:18 <lambdabot> /msg #haskell Yarr!
20:09:22 <nmessenger> :(
20:09:36 <nornagon> @where+ prod Yarr!
20:09:36 <sorear> @admin + hpaste
20:09:36 <lambdabot> Done.
20:09:39 <nornagon> @where prod
20:09:40 <lambdabot> Yarr!
20:09:44 <nornagon> :-O
20:10:02 <nmessenger> @where+ prod /msg nornagon Yarr?
20:10:03 <lambdabot> Done.
20:10:06 <bo> !say @arr
20:10:14 <glguy> !say @admin + glguy
20:10:14 <hpaste> @admin + glguy
20:10:19 <glguy> :(
20:10:30 <kc5tja> !say and you never will.  :)
20:10:49 <kc5tja> !say "and you never will.  :)"
20:10:51 <nornagon> heh
20:10:52 <glguy> !say more like you never will
20:10:53 <hpaste> more like you never will
20:10:59 <kc5tja> Ahh, ACLed.
20:11:15 <nmessenger> @id <-- adds a space
20:11:16 <lambdabot>  <-- adds a space
20:11:39 <goban> What's the advantage of using a State monad instead of simply passing around a Data type ?
20:11:44 --- mode: ChanServ set +o hpaste
20:11:45 <kc5tja> Anyway, I need to get back to coding on my personal project now that I'm home.
20:11:50 <monochrom> shorter code
20:11:51 <sorear> @read "\013\010 <-- adds a space, and strips newlines"
20:11:51 <lambdabot>   <-- adds a space, and strips newlines
20:11:59 <hpaste> bring it on!
20:12:14 <ddarius> goban: Clearer code, access to generic monad functions, the ability to generalize later.
20:12:16 <kc5tja> Great, a Haskell bot war.
20:12:21 <nornagon> @read /me also responds to /me
20:12:22 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
20:12:27 <nornagon> ic
20:12:38 <goban> thanks
20:12:39 <glguy> ugh, unfortunately I don't have a way to tell hpaste to deop
20:12:42 --- mode: ChanServ set +o glguy
20:12:43 <tautologico> if you have to thread state explicitly, it gets boring soon
20:12:46 --- mode: glguy set -oo hpaste glguy
20:13:32 <kc5tja> And God said >> let there be monads. ;)  (I still think that name just sounds rude. ;D)
20:13:47 <monochrom> You can call it "triple".
20:13:58 <nmessenger> you could just call them endofunctors on the category of haskell types
20:14:09 <kc5tja> Endofunctors is worse!
20:14:14 <kc5tja> I like it!
20:14:17 <glguy> nmessenger: you are thinking of Functor?
20:14:18 <SamB> hahahaha
20:14:24 <TSC> warm fuzzy thing
20:14:24 <sorear> nmessenger: /\a -> (a,a) is an endofunctor, but not a triple.
20:14:25 <kc5tja> I meant rude as in the bad party joke sort of way.
20:14:29 <ddarius> Pointed endofunctors.
20:14:59 * nmessenger knows no category theory, just heard that definition somewheres
20:15:05 <kc5tja> Oh wow.  I know the name of the next data type to encode in Forth.  ;D
20:15:09 <nmessenger> I think syntaxfree's blog.
20:15:09 <kc5tja> ENDOFUNCTOR FOO
20:15:21 <kc5tja> Why?  Just 'cuz.
20:15:29 <ddarius> Monads are endofunctors (or part of them is) but endofunctors aren't necessarily monads.
20:15:29 <tautologico> the imperativator
20:15:34 <ddarius> Neither are pointed endofunctors.
20:15:55 <nmessenger> an endofunction + return + join?
20:15:59 <nmessenger> s/ion/or/
20:16:26 * kc5tja wonders where the ectofunctors are.  :)
20:16:50 <kc5tja> I'll have you know -- I had a VERY bad day at work today.  Just couldn't concentrate on anything.
20:17:02 <kc5tja> But seeing this discussion just made me laugh it all out.
20:17:22 <kc5tja> Endofunctors.  Wow.  I'm so writing that one into my journal for later recall . . .
20:17:24 <monochrom> Yeah, we tend to solve all the world's problems. :)
20:17:42 <nmessenger> modest, too :)
20:18:03 <ddarius> "Haskell: Using Monads to Change the World"
20:18:06 <kc5tja> uh oh -- I think I just say some lightning.  :/
20:18:46 <kc5tja> Nope -- must have been me hallucinating.
20:19:12 <kc5tja> -1s/say/saw/
20:20:07 <lispy> heh, here is a new way to say "for real"
20:20:10 <lispy> :t 4.0
20:20:12 <lambdabot> forall t. (Fractional t) => t
20:20:39 <lispy> (some interpretation required)
20:21:36 <nmessenger> (not available in all states, ask your doctor before using, not responsible for broken limbs or crushed arteries)
20:22:33 <kc5tja> (batteries not included.  Some assembly required.  Use with plenty of ventilation.  We don't exactly know what this is.  Do not taunt Happy FunBall.)
20:23:02 <nmessenger> apply directly to forehead!
20:23:42 <kc5tja> If, for any reason at all, I were to make my own programming language, it would have to be called Funball.
20:23:53 * nmessenger takes uncrazifying pill
20:23:59 <allbery_b> "do not use internally" (seen on my glasses wipes...)
20:24:06 <kc5tja> Haha!
20:24:14 <kc5tja> Hmm...that's going to be kind of hard to do.
20:24:26 <SamB> allbery_b: bobandgeorge.com says something similar
20:24:56 <SamB> "This comic is for entertainment purposes only and not to be taken internally."
20:27:40 <lesner2> allbery_b/SamB: http://www.lyricsdownload.com/george-carlin-advertising-lullaby-lyrics.html
20:27:42 <lambdabot> Title: George Carlin - Advertising Lullaby LYRICS, http://tinyurl.com/2eppv7
20:29:11 <glguy> Is a "town car" a "taxi"
20:29:17 <glguy> in west-coast language
20:29:38 <glguy> if someone is having a "town car" pick them up
20:30:27 <nmessenger> maybe they're just gonna steal some random car they find?
20:31:03 <jcreigh> nmessenger: you're thinking of the GTA-universe, not the west coast. :)
20:31:16 <nmessenger> of course, silly me :o)
20:32:14 <xpika> whats the difference between 'data Foo = Foo Int' and 'data Foo = Foo !Int'?  I'm thinking that the !Int might mean eager evaluate?
20:32:16 <SamB> And if you act now, we'll include an extra added free complimentary
20:32:16 <SamB> bonus gift at no cost to you: a classic deluxe custom designer
20:32:16 <SamB> luxury prestige high-quality premium select gourmet combination
20:32:16 <SamB> key ring, magnifying glass, and garden hose, in a genuine
20:32:16 <SamB> imitation leather-style carrying case with authentic vinyl trim.
20:32:17 <SamB> Yours for the asking, no purchase necessary.It's our way of
20:32:20 <SamB> saying thank you.
20:32:36 <glguy> george carlin?
20:32:53 <glguy> (my first instinct was to kick you again for spaming your free product ;) )
20:33:14 <SamB> lesner2 linked to some song lyrics
20:33:22 <glguy> lesner2?
20:33:23 <SamB> that part made the least sense ;-)
20:33:35 <glguy> I think that's from a George Carlin comedy skit
20:33:37 <allbery_b> xpika: yes, the ! is a strictness annotation
20:33:53 <SamB> glguy: well, it does bear his name
20:33:57 <kc5tja> What's funny is, as a kid, I *distinctly* remember hearing an infomercial clearly state: "And if you call within the next 60 seconds, we'll send you, absolutely free, this extra set of knives, for only $9.99!"
20:34:04 <xpika> was does strictness actually mean?
20:34:28 <monochrom> You can pretend it means eager.
20:34:29 <SamB> kc5tja: that means they don't charge shipping and handling, I guess?
20:34:37 <monochrom> Hey!
20:34:38 <xpika> the opposite of lazy?
20:34:42 <monochrom> Yes.
20:34:52 <kc5tja> SamB: No, it means they get idiots, hook line and sinker, to pay the $9.99 absolutely free.  :)
20:35:11 <allbery_b> practically, it means eager/not lazy.  actually, it means "unlifted", i.e. cannot hold a thunk (suspended calculation) or _|_
20:36:05 <allbery_b> (that being why it's eager evaluation; lazy eval basically makes all calculations thunks until something forces them)
20:36:06 <xpika> i new strict people didn't like the sight of bottoms
20:36:11 <SamB> oooh
20:36:12 <kc5tja> I think I thunked I funked and finked it ... oh noes!  I've goon cross-eyed!
20:36:15 <SamB> Our detection engine shows that you currently have Flash version 0 installed.
20:36:23 <xpika> s/new/knew
20:36:37 <allbery_b> @remember xpika I knew strict people didn't like the sight of bottoms.
20:36:38 <lambdabot> Done.
20:36:43 <xpika> noooo.
20:36:47 <monochrom> You beat me to it. :)
20:36:55 <xpika> @unremember
20:36:55 <lambdabot> Incorrect arguments to quote
20:37:06 <SamB> (_|_) -- you can say that again
20:37:37 <SamB> @quote
20:37:38 <lambdabot> Baughn says: I think I'm beginning to understand this language. I just defined 1+1=3.
20:38:01 <glguy> SamB: http://www.pcentraide.com/index.php?showtopic=45143
20:38:03 <lambdabot> Title: Internet Explorer Et Flash Player - PC Entraide
20:38:11 <sorear> @index taisl
20:38:12 <lambdabot> bzzt
20:38:14 <sorear> @index tails
20:38:14 <lambdabot> Data.List
20:38:42 <nmessenger> > tails"pin"
20:38:44 <lambdabot>  ["pin","in","n",""]
20:38:45 <kc5tja> : +   2dup 1 = swap 1 = and 1 and + + ;  \ oh yeah...  >:)
20:38:57 <lispy> nmessenger: ha
20:39:08 <LoganCapaldo> > head"less"
20:39:09 <lambdabot>  'l'
20:39:13 <SamB> glguy: I not speak french
20:39:30 <glguy> SamB: I had to use google translator to see what they were going on about
20:39:33 <glguy> youtube it seems :)
20:39:52 <SamB> it just seems awfully silly to me that it doesn't notice that I actually don't have flash -- just calls it version 0!
20:41:04 <SamB> actually that was livevideo.com...
20:41:34 <glguy> SamB: maybe google translator determined that the french to english translation of livevideo.com was youtube.com?
20:41:37 <glguy> ;)
20:41:55 <SamB> well, I pasted it from livevideo.com
20:44:20 <glguy_> !paste
20:44:20 <hpaste> Haskell paste bin: http://hpaste.org/
20:44:22 <sorear> yay!  GHC output segfaults!
20:44:32 <sorear> now let's see where my ffi abuse failed
20:44:37 <SamB> hootay!
20:44:42 <SamB> er.
20:44:47 <SamB> s/t/r/
20:44:47 <nmessenger> heh
20:45:43 * nmessenger resolves to use "hootay!" at some point.
20:46:04 <SamB> lol
20:46:52 <chessguy> little late for new years' resolutions
20:47:06 <chessguy> or a lot early
20:48:25 <nmessenger> one needn't wait for new years to resolve in something
20:48:55 <nmessenger> You just need to be resolute!
20:49:14 <nmessenger> hootay!
20:49:35 <SamB> in fact, most new years resolutions are not made with enough resolve
20:49:58 <nmessenger> aye, 'tis indeed true
20:51:11 <glguy_> http://www.cnn.com/2007/US/02/19/homeless.attacks/index.html?eref=rss_latest -- all the 15 year old wanted to do was get drunk and smoke some pot, and then a primal urge came over him to beat a homeless guy... reminded his friend of playing a violent video game... poor kid, a victim of a childhood of violent video games
20:51:14 <lambdabot> Title: Teen 'sport killings' of homeless on the rise - CNN.com, http://tinyurl.com/24lz2p
20:51:20 <glguy_> someone should pay for what they made that kid do
20:54:42 <sorear> HAH! my pathetic attempts at benchmarking uncovered a bug in vty
21:00:12 <chessguy> ddarius, ping
21:01:28 <kc5tja> I read through some of the quotes that lambdabot has -- many of them are a hoot!
21:01:36 <ddarius> I'm here, but busy.
21:02:06 <sorear> kc5tja: how are you getting the quotes - @quote? if so there's a better way
21:02:21 <kc5tja> sorear: Yeah, just repeatedly typing @quote
21:02:54 <sorear> kc5tja: http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
21:03:08 <sorear> read that file.  you may need to apply zcat.
21:03:57 <sorear> once, lb stored quotes as plain text.  but dons is a bit infatuated with the bytestring-based gzip bindings atm.
21:05:09 <sorear> dons: I've gotten the vty internal benchmark working!
21:05:23 <sorear> well, almost.
21:05:29 <sorear> no way to quit!
21:05:33 <sorear> time for kill
21:05:35 <chessguy> ddarius, ok: if you want to keep up with my project at all, feel free to darcs get http://catenova.org/~awagner/GPLib
21:05:37 <lambdabot> Title: Index of /~awagner/GPLib/
21:05:40 <lispy> sorear: oh, does vty work in compressed streams! zty! ;)
21:05:59 <sorear> lispy: no, not yet :)
21:10:39 <sorear> dons: your 'disable jhc support for now' patch doesn't do what it says it does
21:10:49 <sorear> dons: it permutes the GHC versions!
21:11:07 <sorear> 1m47s first run of benchmark
21:11:26 <slowriot> has anyone here used yampa?
21:12:56 <dons> sorear: didn't i a) permute and b)disable jhc?
21:13:15 <dons> i wasn't looking, so its possible i did the wrong thing there :-) (wasn't expecting a conflict..)
21:13:21 <sorear> jhc is disabled, but that last patch didn't do it :)
21:14:44 <sorear> vty has a builtin benchmark now, no more fuddling with yi
21:14:44 <dons> um,, looks ok to me: COMPILERS   = ghc-old ghc ghci hugs nhc98 yhc hbc
21:15:06 <dons> i.e. jhc got droped , ghc-old and ghc swapped (previously)
21:15:09 <sorear> State-of-the-world is fine, I was complaining about the patch description
21:15:30 <sorear> since inconsistant patches imply confused authors :)
21:15:38 <dons> yeah, i applied a patch, then saw yours. so unexpected merge. doesn't matter now.
21:17:01 <chessguy> @pl \g -> (a g) == 0
21:17:01 <lambdabot> (0 ==) . a
21:17:27 <sorear> now reruning vty bench with -O2 -funbox-strict-fields (no opt: was  1m47)
21:17:32 <sorear> yow!
21:17:48 <sorear> -O2 -funbox-strict-fields --> 0m15
21:18:07 <sorear> -O2 makes vty 7x faster
21:18:16 <dons> good
21:18:30 <sorear> might have to tweak N :)
21:18:45 <edwinb> ETOOEARLY
21:18:51 * edwinb beings slow progress towards FitA
21:20:33 <sorear> now let's see how much slower it is with -prof -auto-all :)
21:21:26 <sm> evening all!
21:22:41 <sm> Lemmih, Igloo: I got the 6.6-release built as you suggested, profiling works great now
21:23:21 * sm has been learning how to read the text and uDraw reports
21:24:51 <sorear> dons: 29s with -O2 -funbox-strict-fields -prof -auto-all
21:24:51 <sorear> total alloc: 5 GB
21:24:58 <sorear> you mean from +RTS -p ?
21:27:11 <sm> here's my current haskell issue: I keep running into problems with module organization
21:27:29 <Patty01> Another question:  I have to run a program I have with +RTS -H750M -RTS  --- is there any way to get the compiler to default to this heap size?
21:27:30 <sorear> pretty much everyone's
21:27:42 <sm> maybe it's forcing me to design more clearly.. though sometimes it just seems like jumping through hoops
21:28:04 <sorear> Patty01: why?  -H750M doesn't change anything but performance.
21:28:10 <allbery_b> Patty01: GHCRTS environment variable?
21:28:13 <sm> perhaps I'm too used to the smalltalk model where all classes are global, but..
21:28:23 <Patty01> I'm on windows
21:28:25 <sorear> Patty01: -H sets the *initial* heap size, it expands as needed
21:28:58 <Patty01> sorear - If I allow the heap to grow normally,. the program spends a lot of time in gc
21:29:02 <sorear> Patty01: so you could set -H1M and your program would start slower, but be just as fast afterward
21:29:17 <sorear> ah.
21:29:36 <sorear> as long as you understand what you are doing, I'll tell you how :)
21:29:42 <Patty01> :)
21:30:05 <chessguy> you gotta love how haskell pretty much forces good program design. i just completely changed the representation of a major data structure in my program, and only had to change a few places to do so
21:30:05 <sorear> Patty01: this section of the manual: http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html#rts-hooks
21:30:07 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/2hoaa9
21:30:39 <sm> ok - I have a CookedLedger which must be at the top so it can cache any of the others. Code below it can not use its fast functions, and code above it should use only its functions for good performance. Upper-level code loses the benefit of many lower-level functions and has to reimplement them as fast versions.. any advice for this situation ?
21:30:55 <Patty01> Ah - so there's nothing like a {-# OPTIONS -H750M #-} directive?
21:31:20 <sorear> Patty01: nah, that would be too easy :)
21:31:24 <hpaste>  sm pasted "sm's module organization" at http://hpaste.org/571
21:31:29 <allbery_b> section 4.14.6 of the GHC manual
21:31:48 <sorear> allbery_b: .... which I just provided a link to :)
21:31:59 <allbery_b> but, um, looks like there are issues on Windows.  figures
21:32:33 <Patty01> haskell on windows == massive pain in bum a lot of the time :(
21:32:44 <allbery_b> windws has environment variables, by the way.  you can set them in CMD.EXE with SET, or globally via one of the system control panel panes IIRC
21:32:53 <Patty01> ok - thanks
21:33:20 <sorear> the (classic) mac os is the only remotely popular system without envvars
21:36:17 <TSC> I have a massive source file, and GHC gobbles all the memory when trying to compile it.  What should I do?
21:36:30 <sorear> split it up? ;)
21:36:39 <TSC> Yeah, that looks likely
21:36:48 <sorear> seriously, try using +RTS -c -F1.1 -RTS
21:36:56 <sorear> compiler option
21:37:14 <sorear> that says use-much-less-memory
21:37:22 <sorear> conversely it will use more CPU
21:37:27 <TSC> Ah, I was looking at the docs to find an option like that
21:37:52 <allbery_b> is that -I1.1?
21:37:59 <sorear> mark-compact collector (-c) uses much less memory than the default twospace copying collector
21:38:01 <sorear> allbery_b: no
21:38:09 * allbery_b is looking at +RTS and sees no -F
21:38:17 <allbery_b> (ghc's own that is.  on ppc)
21:38:30 <sorear> -F1.1 (default -F2) says be much more conservative about expanding the heap
21:38:42 <TSC> Ah, ok
21:38:53 <sorear> this makes heap growth slower, but will prevent GHC from overshooting the amount of RAM on your system
21:38:57 <TSC> It does seem to be making a difference
21:39:20 <sorear> allbery_b: -Ffactor, http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html#rts-options-gc
21:39:22 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/2hoaa9
21:40:53 * allbery_b wonders what else is missing from the +RTS help message
21:43:06 <TSC> 5 minuttes into compilation, I can hear the poor OS moving swap around to make room...
21:43:38 <TSC> I think I'm about to lose it... (900MB allocated so far)
21:43:58 <chessguy> ?hoogle sequenceM
21:43:58 <lambdabot> No matches found
21:43:59 <sorear> +RTS -c -F1.1 -RTS makes Jhc, king of swaphounds, barely run on my computer (390MB/384MB)
21:43:59 <sm> what could I read to get better at organizing modules ? not finding much on this topic
21:44:11 <chessguy> ?hoogle sequence
21:44:12 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
21:44:12 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
21:44:12 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
21:44:20 <sorear> ?google+
21:44:21 <lambdabot> Maybe you meant: google hoogle+
21:44:24 <sorear> ?hoogle+
21:44:39 <chessguy> ?hoogle+
21:44:58 <sorear> TSC: how big is your module?
21:45:22 <chessguy> ?hoogle mapM_
21:45:22 <sorear> is it just hand-written code?
21:45:22 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
21:45:23 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
21:45:43 <chessguy> ?hoogle forM_
21:45:43 <sorear> chessguy: huugle is 6.4.2
21:45:43 <lambdabot> No matches found
21:45:56 <sorear> @ping TSC
21:45:59 <lambdabot> Not in scope: type constructor or class `TSC'
21:46:01 <sm> relatedly, whats a good way to get an overview of current modules & functions ? how to run haddock ?
21:46:05 <chessguy> sorear, was there something it missed?
21:46:07 <chessguy> ?hoogle forM
21:46:07 <lambdabot> Text.Html.form :: Html -> Html
21:46:08 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
21:46:08 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
21:47:19 <allbery_b> forM is from 6.6, lambdabot's hoogle database is from 6.4.2.
21:47:32 <allbery_b> pick on dons :)
21:47:36 <chessguy> ah, gotcha
21:48:35 <TSC> sorear: sorry, I'm still here; the machine just ground to a halt under the weight of memoryless-ness
21:48:50 <TSC> $ wc SvgDtd.hs
21:48:52 <TSC>   29639  152045 1752753 SvgDtd.hs
21:49:21 <TSC> I used HaXml's dtd-to-haskell converter to convert the SVG 1.0 DTD into a Haskell module
21:50:00 <sorear> hahaha.
21:50:13 <sorear> try ghc -v5, what phase blows up?
21:50:45 <sorear> +RTS -M300M -RTS # abort when heap usage exceeds 300Mbytes
21:51:24 <TSC> I'll make it 500
21:51:38 <TSC> Parsing...
21:51:48 <sorear> @how-much-ram TSC  -- this doesn't work, alas
21:51:49 <lambdabot> Unknown command, try @list
21:51:55 <TSC> About 900
21:52:18 <TSC> Ok, up to rnamer/typechecker
21:52:26 <sorear> <- 384, needs about 14 for foreground tasks
21:52:50 <TSC> I used to have 384, but nothing would compile so I bought more (:
21:53:14 <allbery_b> hw.usermem: 956125184
21:53:25 <sjanssen> > 1752753 / 2^20
21:53:26 <lambdabot>  1.671555519104004
21:53:38 <sorear> hehe.  only thing that has *ever* given me ram troubles is jhc
21:53:57 <sorear> and +RTS -c -F1.1 -RTS makes even that work.
21:53:57 <allbery_b> of course that's OSX, so assume half of that is used by just the base system :)
21:54:36 <sorear> Linux drivers/char/vt.c is one of the lightest-weight window systems in existance :)
21:55:29 <sorear> glibc, emacs, bash, linux.  amazing how little ram it uses...
21:55:58 <sjanssen> TSC: I'd like to point out that your source file is nearly 30% of the total size of the Haskell portions of ghc's source
21:56:13 <TSC> Ah
21:56:27 <TSC> It's mainly data definitions and derived instances
21:56:31 <sjanssen> a megabyte really is a lot of source
21:56:33 <sorear> TSC : is it to the desugarer yet?
21:56:38 <sjanssen> s/source/haskell source
21:56:39 <sorear> simplifier?
21:56:54 <TSC> I don't think so
21:57:55 <TSC> Ah, desugar now
21:58:18 <TSC> Doesn't seem to be affecting memory use
21:58:24 <sorear> good, you made it through the entire frontend
21:58:45 <TSC> Hooray!
21:59:30 <TSC> It seems to slow down a lot in some deeply-nested parts
22:00:28 <sorear> Haskell -parse-> AST -rename-> AST with no scoping -typecheck-> AST with no missing typesigs -desugar-> Core (System Fc) -simplify-> Optimized Core -Stgprep-> STG-machine abstract code -codegen-> Cmm -prettyprinter-> C -gcc-> Object code
22:00:28 <araujo> flip ftw!
22:00:41 <sorear> Cmm -NCG-> Object code
22:00:49 <chessguy> > (0.9*0.9)::Double
22:00:50 <lambdabot>  0.81
22:01:13 <sorear> TSC: what isntances are being derived?
22:01:14 <chessguy> araujo!
22:02:38 <araujo> hola chessguy !
22:02:42 <TSC> sorear: I mean instances have already been derived by HaXml
22:02:45 <araujo> como estas? :-)
22:03:00 <TSC> Although it's also "deriving" Show and Eq
22:03:03 <sorear> TSC: ah.  what types?
22:03:21 <sorear> what ver. of HaxML?
22:03:28 <TSC> Darcs version
22:04:12 <TSC> The instances seems to be mainly of XmlAttrType
22:04:30 <TSC> And XmlContent
22:05:09 <sorear> how big is the dtd?
22:06:29 <TSC> $ wc svg10.dtd
22:06:30 <TSC>  1704  4576 55654 svg10.dtd
22:07:38 * sorear wonders how easy it would be to get dtd2haskell to directly emit IfaceSyn
22:08:01 <sorear> y'know, skip the whole compilation phase :)
22:08:31 <TSC> That might help (:
22:08:38 * ddarius will have to learn how to make a Virtual Desktop Manager through reverse engineering because he has no idea where he would start.
22:08:44 <TSC> It seems like it would be pretty simple to split the file up
22:09:01 <sorear> especially with Data.Graph
22:09:01 <TSC> I don't think there are (m)any dependencies
22:09:41 <sorear> dependency analysis is as easy as "sccs (concatMap extractDep graph)"
22:12:13 <araujo> Haskell ftw!
22:12:16 <araujo> http://dev.gentoo.org/~araujo/lasthimerge.png
22:12:51 <sjanssen> TSC: I've managed to make it to the linking stage
22:13:39 <TSC> How big is the object file?
22:14:00 <sjanssen> 22MB
22:14:18 <TSC> Hmm
22:14:50 <sjanssen> ghc's memory use capped around 900MB, and ld used 100MB or so
22:15:54 <sjanssen> and the ambient temperature in this room increased a bit :)
22:16:17 <TSC> Ha (:
22:16:57 <JohnMeacham> dons sorear: I'll take a look, jhc is in an unstable state at the moment due to using the opprotunity of switch to Data.Binary to revamp the whole ho and library file infrastructure.
22:16:59 <metaperl> can someone get nomaware.com up and running? I want to read the monad tutorial there
22:18:55 <dons> JohnMeacham: yep. understood. ping me when you've got it in a state to run over the benchmarks
22:20:23 <JohnMeacham> I will likely switch to using them for internal testing anyway, I knew if I waited long enough someone would do the work of writing such a suite. :)
22:20:40 <sorear> JohnMeacham: we're not using darcs current
22:20:50 <sorear> JohnMeacham: the failures are with ejthecnar
22:21:46 <sorear> @remember JohnMeacham [on nobench failing jhc] I will likely switch to using them for internal testing anyway, I knew if I waited long enough someone would do the work of writing such a [test] suite. :)
22:21:47 <lambdabot> Done.
22:22:53 <sorear> JohnMeacham: the good news is on my test of the nop benchmark jhc was infinitely faster than any other compiler, and I mean that quite literally
22:22:56 <dons> looks like its caught some issues with ghc 6.6 too (there's a stack oflow that doesn't happen in 6.4.2)
22:23:13 <dons> the numbers are updating here as I speak, http://www.cse.unsw.edu.au/~dons/nobench/results.html
22:23:14 <lambdabot> Title: nobench: Haskell implementation shootout
22:23:19 <sorear> within time resolution, jhc 0.00, yhc/ghc/ghc-6.4.2 0.20, ghci 0.65
22:23:24 <JohnMeacham> it does 'nop' well. it has been my standard benchmark so far. :)
22:23:45 <dons> hehe
22:23:53 <sorear> nop doesn a good job of shaming its slowest compiler IMO
22:23:55 <sorear> ghci
22:24:08 <sorear> I've complained for months about ghci startup time
22:24:18 <sorear> now, by patching nobench, I can..
22:24:59 <slowriot> the latest version of yampa is not compatible with ghc 6.6. This is because certain modules define functions with the same name as functions which are imported from other modules. Any calls made to those functions are ambiguous. Any ideas about how I would go about fixing this?
22:25:24 <sorear> import OtherModule hiding (badName)
22:25:28 <sorear> -or-
22:25:31 <slowriot> sweet. thanks
22:25:35 <slowriot> or...
22:25:38 <sorear> ... ThisModule.badName ...
22:25:47 <slowriot> I tried ThisModule.badName
22:25:56 <sorear> oh wel.
22:25:59 <slowriot> I still got ambiguous errors
22:27:34 <sorear> dons: lookie here:   spectral  calendar      0.78          0.89          0.77          Compile error 0.45          0.02          19.25
22:27:39 <sorear> note nhc98 time
22:28:05 <dons> calendar is bogus
22:28:16 <dons> nhc98 is miscompiling itto a program that does somethin gelse
22:28:19 <JohnMeacham> did none of the 'real' benchmarks make it in? those seem to be the most important in a lot of ways.
22:28:34 <sorear> JohnMeacham: two did
22:28:37 <dons> those are on their way. 2 are in so far, they update last
22:28:40 <sorear> JohnMeacham: rsa and meteor
22:28:40 <dons> the rest i'll add soon
22:28:47 <dons> (have to manually convert the makefiles)
22:28:56 <slowriot> hiding worked
22:29:00 <sorear> yay
22:29:11 <JohnMeacham> ah. yeah, some also needed some tweaks to make them H98 if I remember.
22:29:17 <dons> yeah
22:29:31 <chessguy> > 1000000 :: Double
22:29:32 <lambdabot>  1000000.0
22:29:37 <chessguy> > 10000000000000000000000 :: Double
22:29:38 <lambdabot>  1.0e22
22:29:40 <sorear> well ejthecnar doesn't to h98, only h' :P
22:29:44 <sorear> s/to/do
22:29:45 <chessguy> ?instances Bounded
22:29:47 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
22:29:52 <chessguy> ah
22:30:00 <sorear> haskell98 fails to compile because System.IO.Error doesn't exist
22:30:10 <chessguy> is Double arithmetic as slow as Integer arithmetic then?
22:30:20 <sorear> why?
22:30:28 <bd_> Double arithmetic is a machine type
22:30:29 <sorear> it uses double precision floating point
22:30:43 <chessguy> oh, so it's not arbitrary precision
22:30:46 <dons> chessguy: you need {-# OPTIONS -fexcess-precision #-} if you care about Double speed.
22:30:47 <sorear> nah!
22:30:47 <JohnMeacham> sorear h' + SuperSecretUndocumentedJhcExtensions actually.
22:30:49 <bd_> particularly with -fexcess-precision (note: due to a ghc bug, must be in an OPTIONS_GHC pragma) it should be faster
22:30:55 <xpika> does anyone know a language with dynamic datatypes?
22:31:01 <sorear> Haskell!
22:31:05 <sorear> Data.Dynamic
22:31:23 <dons> xpika: that phrase is ambiguous. coudl you clarify?
22:31:30 <JohnMeacham> I keep meaning to write a perl script to pull documentation out of the source files and arrange it into a manual nicely. sort of like what darcs does. but without doing lhs.
22:31:37 * xpika hoogles
22:31:43 <sorear> > ((1.0e-20 + 1) - 1) :: Double  --chessguy, look here
22:31:44 <lambdabot>  0.0
22:31:48 <JohnMeacham> a manual would certainly help jhc's adoption I would think.
22:31:52 <sorear> > (1.0e-20 + (1 - 1)) :: Double  --chessguy, look here
22:31:54 <lambdabot>  1.0e-20
22:32:08 <lispy> JohnMeacham: just start a wikibook on it
22:32:15 <lispy> JohnMeacham: and let the users document it! ;)
22:32:18 <sm> do you all use unit tests, or do you consider them unnecessary with haskell ?
22:32:18 <chessguy> sorear, your point?
22:32:27 <lispy> sm: necessary
22:32:35 <sorear> JohnMeacham: so would it not failing every nontrivial compile with Grin.FromE.toType: ELit (Jhc.Order.Bool#::ESort #)
22:32:43 <lispy> sm: small check, quick check and hunit are all goood places to start
22:32:46 <chessguy> ?hoogle QuickCheck
22:32:46 <lambdabot> Test.QuickCheck :: module
22:32:47 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
22:32:51 <chessguy> sm, ^^
22:33:01 <lispy> ?check 1 == 1
22:33:02 <lambdabot>  OK, passed 500 tests.
22:33:05 <sorear> I do hope that's an error message... no 'error' prefix
22:33:07 <lispy> ?scheck 1 == 1
22:33:09 <lambdabot>   Completed 1 test(s) without failure.
22:33:19 <witten> how does haskell's monad relate to clean's uniqueness typing, if at all?
22:33:22 <bos> @djinn ([a] -> b) -> (a, [b])
22:33:22 <lambdabot> -- f cannot be realized.
22:33:30 <witten> it seems they're solving the same problem
22:33:36 <sm> thanks, do you mix all 3 of those depending on the situation ?
22:33:38 <lispy> ?scheck \s -> (reverse . reverse) s == (s :: String)
22:33:39 <ddarius> @check \x -> reverse (reverse x) == x
22:33:40 <lambdabot>   Completed 1957 test(s) without failure.
22:33:40 <lambdabot>  Add a type signature
22:33:46 <JohnMeacham> sorear: hmmm.. I remember that bug.
22:34:01 <sorear> JohnMeacham: is it fixed post-ejthecnar?
22:34:10 <lispy> sm: yeah, hang on
22:34:10 * sm has a couple of hunit and qc tests so far
22:34:25 <chessguy> witten, i don't really know much about uniqueness types, but i seem to remember reading that the IO monad takes care of the same problem as uniqueness types does
22:34:30 <ddarius> witter: They are used to solve the same problem, but they work at slightly different levels of abstraction.
22:34:30 <lispy> sm: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
22:34:33 <lambdabot> Title: dagit.o  Blog Archive  Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
22:34:35 <sorear> dons: cryptarithm2 is bogus, direly needs an N boost
22:34:38 <witten> chessguy: ok, thanks
22:34:41 <chessguy> witten, but monads in haskell are much more general than just the IO monad
22:34:43 <lispy> sm: that was my exploration of using quickcheck as the unit testing
22:34:46 <witten> ddarius: okay
22:34:51 <dons> witten: they're both used to deal with sequential IO.   however monads are also used for many interesting other things, like implementing continutatoins and threads
22:34:52 <sm> great, thank you
22:34:53 <chessguy> witten, the IO monad is just one instance
22:34:59 <JohnMeacham> sorear: I believe so, but some other stuff is broken. there is some tension between the -fvia-ghc and grin backends that is yet to be fully resolved, so fixing something in one sometimes breaks something in the other. you might try -fvia-ghc and see if that helps.
22:35:06 <witten> dons: oh, right
22:35:14 <chessguy> ?all-dict continutatoins
22:35:15 <lambdabot> No match for "continutatoins".
22:35:31 <dons> sorear: i'm thinking of ditching it, since the IO is compiled in
22:35:40 <witten> chessguy: so uniqueness types only solve the same problem that the IO monad does?
22:35:46 <witten> and not other monads?
22:35:50 <chessguy> witten, that's my understanding, yes
22:35:56 <witten> interesting
22:35:56 <dons> chessguy: are you always so narky?
22:36:02 <sorear> witten: uniqueness types also andle ST
22:36:03 <ddarius> witter: More it solves the problem ST/State does and that can be used to solve the IO problem.
22:36:11 <chessguy> dons, i was just curious whether it could find the right word
22:36:26 <chessguy> dons, no offense intended
22:36:29 <dons> ?spell continutatoins
22:36:30 <lambdabot> continuations continuation's continuities contentions continuant's
22:36:37 <witten> hmm
22:36:39 <chessguy> ?all-dict narky
22:36:40 <sorear> witten: uniqueness types make a better ST than monads do, but they can't for-instance easily express backtracking
22:36:40 <lambdabot> No match for "narky".
22:36:45 <dons> ?. all-dict spell continutatoins
22:36:46 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "all-dict"
22:36:47 <ddarius> ?. all-dicts spell continuatoin
22:36:51 <sorear> dons +s?
22:36:53 <lambdabot> *** "Continuation" gcide "The Collaborative International Dictionary of English v.0.48"
22:36:53 <lambdabot> Continuation \Con*tin`u*a"tion\, n. [L. continuatio: cf. F.
22:36:53 <lambdabot>    connuation.]
22:36:53 <lambdabot>    1. That act or state of continuing; the state of being
22:36:53 <lambdabot>       continued; uninterrupted extension or succession;
22:36:55 <lambdabot> [159 @more lines]
22:36:56 <witten> sorear: okay I didn't realize that either
22:37:12 <chessguy> wow, that's a big dictionary entry
22:37:15 <witten> sorear: what's ST stand for?
22:37:29 <sorear> witten: eg. haskell's gmp binding sucks because it never uses the inplace operations, only the make-a-new-number ones.
22:37:33 <sorear> witten: STate
22:37:41 <witten> ok, that's what I thought
22:37:43 <sorear> witten: or State Thread
22:37:55 <witten> ahh
22:38:18 <sorear> witten: it's IO (mutable arrays and all that), but with a nasty typesystem trick that makes unsafePerformIO perfectly safe (called runST)
22:38:28 <glguy> sorear: is that generally necessary because of immutable variables?
22:38:35 <chessguy> ?hoogle runState
22:38:35 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
22:38:36 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
22:38:42 <chessguy> ?hoogle evalState
22:38:43 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
22:38:43 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
22:39:02 <witten> thanks all, for the answers
22:39:05 <witten> I'll look into this some more
22:39:06 <chessguy> i swear, i will never rember which of runState, evalState, and execState are which
22:39:09 <sorear> glguy: yes. if we had last use analysis ala clean's uts, we could use the (asymptotically faster in some cases) inplace operations.
22:39:15 <sjanssen> TSC: things seem to go much more quickly without the deriving(Eq,Show) for each data type
22:39:23 <sorear> anyway, I should be going to bed real soon.
22:40:07 <sjanssen> chessguy: join the club
22:40:26 <chessguy> ?hoogle **
22:40:27 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
22:40:27 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:40:34 <chessguy> ?instances Floating
22:40:35 <lambdabot> Double, Float
22:40:39 <sm> haddock is failing to resolve a bunch of imports and doing nothing useful
22:41:08 <sm> how can I tempt it to give me docs ?
22:42:48 <sm> a: it needs -h or similar
22:44:10 <chessguy> :r
22:44:22 <chessguy> bah
22:45:18 <chessguy> ?hoogle sum
22:45:19 <lambdabot> Prelude.sum :: Num a => [a] -> a
22:45:19 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
22:45:19 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
22:47:24 <chessguy> @pl t p f = s $ m (fi p) f
22:47:25 <lambdabot> t = (s .) . m . fi
22:53:28 <nrb23> hmm, I'm experimenting with GetOpt
22:53:49 <nrb23> and I'm having trouble determing a good way to tell if two conflicting options are passe
22:53:52 <nrb23> *passed
22:54:48 <nrb23> is there a good way to pattern match against a consructor without writing a large case statement?
22:57:40 <Azmo> nrb23: why is the case statement large if yuo only need to match against one constructor?
22:57:49 <nrb23> it's not large
22:57:55 <nrb23> but it's also not just one or two words
22:58:27 <nrb23> I have data Flag = InputFile String | InputDevice String | Version
22:58:44 <nrb23> so, I've made isInputFile, and isInputDevice
22:58:46 <dons> use records to get free field extraction functions?
22:59:16 <dons> isInputFile (InputFile _) = True ; isInputFile _ = False -- ?
22:59:27 <nrb23> dons: yes
22:59:35 <nrb23> I was just hoping to get those for free
23:00:08 <dons> nope. its one line. just move on and write some code!   ;)
23:02:51 <abz> ?poll-list
23:02:51 <lambdabot> ["OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","editor","jabberName"]
23:03:03 <abz> ?poll-results OperatingSystem
23:03:04 <lambdabot> Poll results for OperatingSystem (Open): House=1, GNU/Hurd=0, SuSE=1, Emacs=1, MacOS=4, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=2, OpenBSD=2, Gentoo=13, Debian=12, Ubuntu=4,
23:03:04 <lambdabot> FreeBSD=3
23:03:42 <dons> ?vote OperatingSystem OpenBSD
23:03:43 <lambdabot> voted on "OpenBSD"
23:03:50 <nrb23> ?vote OperatingSystem MacOS
23:03:51 <lambdabot> voted on "MacOS"
23:03:58 <abz> the question is: does lambdadot get a vote?
23:04:02 <nrb23> can I vote on Gentoo too, since that's what I use for work?
23:05:14 <abz> nrb23: I say you can, and I'm not biased....
23:05:22 <Boney> ?vote Ubuntu
23:05:23 <lambdabot> usage: @vote <poll> <choice>
23:05:29 <Boney> ?vote MacOS
23:05:30 <lambdabot> usage: @vote <poll> <choice>
23:05:31 <nrb23> ?vote OperatingSystem Gentoo
23:05:32 <lambdabot> voted on "Gentoo"
23:05:40 <nrb23> ?poll-results OperatingSystem
23:05:41 <lambdabot> Poll results for OperatingSystem (Open): House=1, GNU/Hurd=0, SuSE=1, Emacs=1, MacOS=5, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=2, OpenBSD=3, Gentoo=14, Debian=12, Ubuntu=4,
23:05:41 <lambdabot> FreeBSD=3
23:05:43 <Boney> ?vote Operating Ubuntu
23:05:44 <lambdabot> No such poll:"Operating"
23:05:52 <Boney> ?vote OperatingSystem Ubuntu
23:05:53 <lambdabot> voted on "Ubuntu"
23:05:58 <Boney> Urgh.  I'm dyslexic today.
23:06:09 <Boney> ?vote OperatingSystem MacOS
23:06:09 <lambdabot> voted on "MacOS"
23:06:14 <Patty01> ?vote OperatingSystem Windows
23:06:15 <lambdabot> voted on "Windows"
23:06:17 <bos> ?vote OperatingSystem Fedora
23:06:17 <lambdabot> "Fedora" is not currently a candidate in this poll
23:06:18 <Boney> (I use both equally)
23:06:24 <Azmo> ?vote OperatingSystem Windows
23:06:24 <lambdabot> voted on "Windows"
23:06:43 * tmoertel is also running Fedora on his workstations
23:06:57 <nrb23> ?poll-results cheeky-off
23:06:57 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=1, AddFlag=2, No=4, Yes=14
23:07:05 <dons> ?vote OperatingSystem NetBSD
23:07:06 <lambdabot> voted on "NetBSD"
23:07:08 <dons> on my mac
23:07:42 * tmoertel laments not having whenM in the standard libs
23:09:14 <dons> tmoertel: agreed
23:09:18 <dons> ?type guard
23:09:20 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
23:10:56 <ddarius> whenM = (>>= when)  (?)
23:11:25 <dons> whenM a b = a >>= flip when b
23:11:28 <dons> I think
23:11:37 <dons> :t \a b -> flip when b
23:11:40 <lambdabot> forall t (m :: * -> *). (Monad m) => t -> m () -> Bool -> m ()
23:12:00 <dons> :t \a b -> a >>= flip when b
23:12:02 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
23:12:14 <dons> ?pl \a b -> a >>= flip when b
23:12:14 <lambdabot> (. flip when) . (>>=)
23:13:15 <ddarius> @type (>>= when)
23:13:18 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
23:15:24 <glguy> !paste
23:15:25 <hpaste> Haskell paste bin: http://hpaste.org/
23:21:45 <bos> has anyone written ByteString code for Sockets?
23:21:55 <bos> because i'd hate to be duplicating work.
23:23:51 <dons> well, they just write to handles. what's to do?
23:24:09 <dons> lazy bytestrings would be good (check with bringert or musasabi)
23:24:16 <dons> they've done a lot of network programming with bytestrings
23:24:22 <bos> if you turn a socket into a handle, it loses all of its sockety goodness.,
23:24:38 <dons> remind me of the socket interface again?
23:25:25 <bos> the ability to do stuff like half-close a connection with shutdown, get peer info, etc
23:26:53 <dons> ah. you've looked at the HaskellNet interface to that stuff?
23:27:06 <bos> euh, looks like shutdown doesn't care whether it's been handle-ified.
23:27:52 <bos> yeah, it's not much use.
23:50:54 <sm> night all
23:59:29 <bos> @hoogle IOError
23:59:29 <lambdabot> Prelude.IOError :: type IOError
23:59:29 <lambdabot> Prelude.ioError :: IOError -> IO a
23:59:29 <lambdabot> System.IO.Error.IOErrorType :: data IOErrorType
23:59:35 <clanehin> in "MonadError e m | m -> e", what does the | m -> e mean?  (I would google for it, but I don't even know what to google for)
