00:05:30 <sorear> dons: how portable are bang patterns? should I be concerned about portability?
00:07:13 <dons> does vty run in hugs?
00:07:24 * sorear tries this
00:07:45 <sorear> ERROR "Test.hs" - Can't find imported module "Data.ByteString.Char8"
00:07:59 <dons> no fps installed?
00:08:02 <dons> in hugs?
00:08:15 <sorear> no, only 6.4.2
00:08:20 <dons> using CPP is another option,
00:08:20 <dons>     STRICT3(map_)
00:08:21 <dons>     map_ n p1 p2
00:08:21 <dons>        | n >= len = return ()
00:08:21 <dons>        | otherwise = do
00:08:34 <dons> #define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
00:08:48 <dons> but bang patterns are nicer, if you don't expect any hugs users
00:09:02 <dons> for libraries though, keeping it portable is a big concern
00:09:48 <sorear> what's cpphs?
00:09:54 <sorear> Setup.hs: Data/ByteString.hs: no cpphs (or GHC) preprocessor available
00:10:04 <sorear> I have GNU cpp ... at least 3 versions
00:10:25 <sorear> no only 1, but I do have a 'cpphs-hugs'
00:10:40 <dons> ?where cpphs
00:10:40 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
00:11:01 * sorear fudges the --with-cpphs=/usr/bin/cpphs-hugs
00:11:03 <dons> you using runhaskell Setup.hs configure --hugs ?
00:11:14 <dons> maybe it does need cpphs, not sure.
00:11:14 <dons> --with-cpphs==cpp might be ok.
00:12:04 <sorear> I built and registered and still the error...
00:12:48 <sorear> need I more than 'hugs Test.hs' ?
00:13:47 <dons> hugs -98 Test.hs ?
00:13:56 <dons> there's a cpp flag as well for hugs. -g ? something like that
00:13:59 <dons> or -F ?
00:14:04 <sorear> ERROR "Test.hs" - Can't find imported module "Data.ByteString.Char8"
00:14:33 <sorear> and yes I did stefan@stefans:/usr/local/src/fps-hugs$ su -c 'runhaskell Setup.hs register --user'
00:14:49 <dons> -package fps ?
00:14:51 <dons> or whatever hugs needs
00:14:54 <sorear> that was mildly dumb
00:15:13 <dons> i'm not sure hugs supports --user
00:15:21 <sorear> register w/o --inplace w/o copy
00:15:45 <sorear> ERROR "./Graphics/Vty/Cursor.hs" - Error while importing DLL "/home/stefan/vty/Graphics/Vty/Cursor.so":
00:15:52 <sorear> /home/stefan/vty/Graphics/Vty/Cursor.so: cannot open shared object file: No such file or directory
00:16:19 <sorear> FFI I'm guessing ...
01:18:35 <Cheery> Monoids seem somehow trivial, I've read yaht.pdf, have I encountered monoids already?
01:19:15 <bd_> Lists are monoids :)
01:19:29 <bd_> Monoids are basically things you can stick together to make... bigger things.
01:20:01 <bd_> so for example, Lists, Sets, functions of type (a -> a) - sticking together is composition, etc...
01:20:15 <bd_> also all Monoids have an identity element - eg, [], Set.empty, id
01:20:24 <sorear> monoids are so simple they aren't even taught in lowish level math ...
01:20:42 <sorear> abstract algebra *starts* with groups, which are strictly more complicated.
01:20:46 <bd_> And of course Data.Sequence is another useful monoid
01:21:07 <Cheery> bd_: that's good to hear, they sound frightening.
01:21:16 <bd_> MonadPlus is a Monoid which is also a Monad, I believe, but haskell's type system doesn't let that be expressed directly...
01:21:17 <sorear> a Monoid is a set of things and an associative binary operator with an identity.
01:21:23 <bd_> Cheery: nah, that's just the terminology
01:21:25 <Cheery> monad -- monoid -- ;p
01:21:48 <bd_> :t mempty
01:21:49 <lambdabot> forall a. (Monoid a) => a
01:21:50 <bd_> :t mappend
01:21:52 <lambdabot> forall a. (Monoid a) => a -> a -> a
01:22:08 <sorear> a group, if you're familiar with those, is a monoid with subtraction
01:22:39 <bd_> hmm
01:22:42 <Cheery> so then I basically know monoids, just I weren't able to connect them. :)
01:22:44 <bd_> > 2 `mappend` 2
01:22:45 <lambdabot>  Add a type signature
01:22:49 <bd_> > 2 `mappend` 2 :: Int
01:22:49 <lambdabot>   add an instance declaration for (Monoid Int)
01:22:50 <lambdabot>     In the expression: 2 `mapp...
01:22:53 <bd_> :(
01:23:07 <quicksilver> bd_: technically isn't MonadPlus a Monad whose *elements* are monoids?
01:23:11 <sorear> Cheery: all of math, rounding at most one percent, is terminology.
01:23:33 <quicksilver> bd_: or something like that
01:23:35 <sorear> quicksilver: I'd say a  MonadPlus is a Monad whose applications are monoids
01:23:45 <quicksilver> sorear: yes, better
01:23:51 <Cheery> sorear: could you explain that a better?
01:24:01 <sorear> it's easier to think about IMO in terms of system F style type application
01:24:06 <bd_> I suppose I should read that category theory for programmers paper sometime...
01:24:17 <sorear> a monad :  |~| x -> something_with_x
01:24:22 <quicksilver> Cheery: 'being a monad' is a property of the "functor"
01:24:23 <sjanssen> forall m a. MonadPlus m => Monoid (m a) -- how about this?
01:24:37 <quicksilver> Cheery: e.g. \x -> [x] is the monad
01:24:40 <sorear> a application of a monad : (monad something) : something_with_somethign
01:24:50 <quicksilver> Cheery: being a monoid is a property of the actual things
01:24:54 <quicksilver> Cheery: (i.e. lists)
01:24:54 <bd_> > (Just 4) `mappend` mempty
01:24:55 <lambdabot>   add an instance declaration for (Monoid (Maybe a))
01:25:00 <bd_> bah!
01:25:13 <sjanssen> we can even encode this in Haskell with overlapping instances: instance MonadPlus m => Monoid (m a)
01:25:32 <quicksilver> Cheery: alternatively "List" is a Monad, but all lists are monoids
01:26:02 <bd_> ah, I see. It's a difference in kind.
01:26:05 * quicksilver nods
01:26:07 <quicksilver> yes
01:30:35 <Cheery> these fingertrees seem fun to implement. :)
01:31:51 <Cheery> and probably they are because haskell already has these.
01:32:17 <sorear> Data.Sequence
01:32:19 <sorear> ?
01:32:47 <Cheery> not sure, just heard it has these already.
01:33:34 <bd_> Data.Sequence uses fingertrees internally, but doesn't expose them
01:33:37 <bd_> ?where fingertrees
01:33:37 <lambdabot> I know nothing about fingertrees.
01:33:38 <bd_> ?where fingertree
01:33:39 <lambdabot> http://www.soi.city.ac.uk/~ross/software/html/Data-FingerTree.html
01:38:47 <dons> sjanssen: http://hackage.haskell.org/trac/ghc/ticket/1138
01:38:49 <lambdabot> Title: #1138 (The -fexcess-precision flag is ignored if supplied on the command line.)  ...
01:38:54 <dons> that's cost us for the passed year or more...
01:41:14 <sjanssen> funny that GHC_OPTIONS pragmas work but command line args don't
01:45:01 <sorear> @index update
01:45:01 <lambdabot> Data.HashTable, Data.IntMap, Data.Map
01:50:28 <kolmodin> morning!
01:50:42 * sorear waves
01:51:03 <quicksilver> can I use Data.Binary 'random access' on a large file?
01:51:15 <sorear> not yet
01:51:31 <sorear> ndm is working on DeferredBinary, which will allow that
01:51:38 * quicksilver nods
01:52:19 <quicksilver> but I could just use Data.Binary on records which I pull random access
01:52:31 <quicksilver> (assuming I have the record length information to find the right offset)
01:52:39 <sorear> yes you could
01:53:08 <quicksilver> thanks
01:56:53 <therp> grr, I miss a backtrace facility in Haskell. This Prelude.tail: empty list error takes me too much time to locate. don't ask how much tail call I have in my source
01:57:44 <sorear> therp: is (compiling) -prof -auto-all (runtime) +RTS -xc  helpful?
01:58:10 <sorear> that's a dirty hack to extract a backtrace from the profiling system
01:58:45 <therp> sorear: I suspected that there are such options. haskellwiki didn't list them. but the error presumably occurs in bytecode so, no profile here I guess
01:58:47 <sorear> "never wrong.  usually worthless, but never wrong." -- attribution forgotten.
01:59:02 <sorear> huh?  bytecode wha?
01:59:10 <xic> what's up with show "a" returning "\"a\"" ?
01:59:21 <sorear> it doesn't
01:59:25 <therp> sorear: interactive compilation, just as in GHCi
01:59:45 <sorear> Prelude> putStr $ show "a"
01:59:45 <sorear> "a"Prelude>
02:00:04 <xic> sorear: yeah, that sucks
02:00:11 <sorear> OTOH:
02:00:14 <Saizan> > read ( show "a") :: String
02:00:16 <lambdabot>  "a"
02:00:41 <Saizan> if you just want to print a, call putStr "a"
02:00:56 <sorear> therp: I don't understand your comment.  Just because code is interpretable doesn't mean it can't be profiled.
02:01:18 <xic> Saizan: i want a function to work with any showable value, String being the most common
02:01:19 <sorear> (indeed, *almost all* code can be interpreted *and* profiled)
02:02:02 <therp> sorear: ah, so the profiler is also active for bytecode? ok. I assumed something different
02:02:12 <sorear> xic: the standard functions print/putStrLn are split based on String/non-string (anti-respectively) ...
02:02:59 <sorear> therp: I don't know.  however I mis-interpreted your previous statement, badly :)
02:03:05 <sorear> sorry
02:03:21 <nmessenger> @src print
02:03:21 <lambdabot> print x = putStrLn (show x)
02:04:56 <kolmodin> dons: nice instances for Double and Float
02:10:12 <dons> kolmodin: yeah, we should have thought of it earlier!
02:10:29 <dons> i don't know the haskell numerics system well enough
02:11:01 <norpan> what instances?
02:11:09 <sorear> @ty encodeFloat
02:11:11 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
02:11:56 <sjanssen> wow, that's it?
02:12:56 <dons> uh hu.
02:13:01 <dons> :t decodeFloat
02:13:02 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
02:13:11 <sjanssen> > decodeFloat 10.2
02:13:12 <lambdabot>  (5742089524897382,-49)
02:14:13 <norpan> huh?
02:14:17 <sjanssen> > 5742089524897382 * 2 ^^ (-49) -- is this how it works?
02:14:19 <lambdabot>  10.2
02:15:27 <sjanssen> > floatRadix (undefined :: Double) -- let's hope this is always 2 :)
02:15:29 <lambdabot>  2
02:15:52 <MechaBlue> Any recommendations for books on advanced Haskell topics?
02:18:50 <dons> MechaBlue: there's currently no advanced haskell book. all the advanced stuff is in research papers, journal articles and blog articles
02:19:22 <dons> see, for eample, this week's Monad.Reader magazine online, and the 'Research papers' link on haskell.org
02:19:30 <dons> ?where TMR
02:19:31 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
02:20:12 <MechaBlue> Thanks.
02:20:35 <dons> also, hang out on haskell-cafe@ -- lots of advanced tricks get mentioned there
02:20:38 <MechaBlue> I feel like that's a bit of an obstacle when it comes to learning how to apply Haskell :/
02:20:50 <dons> yeah, there's a couple of advanced books underway
02:20:56 <dons> hopefully we'll see them in the next year or so
02:21:04 <dons> but start on haskell.org
02:21:18 <dons> it's full of applicatoin hints and tricks. articles about using haskell for hard problems and so on
02:21:34 <dons> what kind of problem were you wondering about?
02:22:03 <sorear> here's also not a bad lurking spot
02:22:34 <sorear> e.g. anyone here three days ago got a very heavy dose of optimizing hints
02:22:36 <dons> trying to answer every question on haskell-cafe@ , here and hpaste.org is a good way to learn funny parts of the language
02:22:53 <dons> sorear: oh, the mandelbrot saga?
02:23:02 <sorear> yes
02:23:20 <dons> yeah, that was good. and a bit scary
02:23:23 <ivanm> is most of the ultra-optimization done using monads?
02:23:28 <dons> since it required dropping into asm to see what was going wrong
02:23:51 <dons> ivanm: not really. sometimes it is, sometimes its using compiler rewrite rules, sometimes using special low level data structures
02:23:54 <dons> and unboxed types
02:24:02 <MechaBlue> I use Haskell a lot of generate test plans
02:24:09 <sorear> and a lot of focused trial and error
02:24:18 <dons> oh, that sounds interesting, MechaBlue
02:24:30 <dons> sorear: yeah, you're trying to guide code through the compiler in some ways
02:24:37 <ivanm> but for all the shootout codes for example, how many of them are in the clear, top-level style shown in the tutorials, books, etc?
02:24:45 <dons> we need vim/emacs support for showing the Core and asm a given block of haskell compiles too
02:24:55 <dons> and then dynamic diffs as you change things
02:25:05 <sorear> ivanm: they're suprisingly close ...
02:25:13 <sorear> not as close as we'd like however
02:25:20 <dons> ivanm: they are somewhat, but they tend to do low level things, so they're a bit different, not too far
02:25:23 <dons> ?shootout
02:25:23 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
02:25:30 <dons> ?wiki Shootout
02:25:30 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
02:25:39 <dons> has more exapmles ^^
02:25:48 <dons> esp. since ghc 6.6 its been easier by far to write in a high level style
02:26:02 <sorear> eg Mandelbrot uses higher order functions (unfoldr), recursion, lots of pure code, just with a lot of annotations
02:26:23 <dons> with strictness annotations, yeah. too many in fact(
02:26:25 <ivanm> I suppose it would be the same with most languages though... the really high end optimisations aren't in the same, clear style shown in the tutorials, and you sacrifice some clarity for speed/efficiency
02:26:38 <dons> see the 'recursive' benchmark. ghc gets all the strictness right
02:27:02 <MechaBlue> dons: For the most part, it's relatively simple functionality that is seen in different places.  Often, it is heavily refactored, with minor changes, and higher-order functions save a lot of effort.
02:27:17 <dons> yeah. that's a good use MechaBlue
02:27:18 <sorear> ivanm: rewrite rules help a lot ... foldr/build and the bytestring equivaluent FORCES you to use higher order functions for peak performance
02:27:34 <ivanm> sorear: OK
02:27:36 <sorear> since hand-coded loops don't fuse
02:27:44 <dons> yeah, hand rolled ones will run worse
02:28:27 <dons> unless you manually fuse
02:28:40 <ivanm> hmmm.... I'm looking through the mandelbrot code, and most of it seems pretty easy to understand... !Int in a constructor means evaluate that Int before creating the new value?
02:28:49 <sorear> yes
02:29:19 <dons> that's *very* low level code too
02:29:44 <ivanm> @hoogle shiftL
02:29:45 <dons> note the raw ptr manipulation
02:29:45 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
02:29:46 <lambdabot> GHC.Exts.shiftL# :: Word# -> Int# -> Word#
02:29:46 <lambdabot> GHC.Exts.iShiftL# :: Int# -> Int# -> Int#
02:30:57 <ivanm> Presumably the writers of ghc are working on making much of this low-level stuff required explicitly (i.e. doing optimisation work with "simple" haskell)?
02:31:18 <sorear> somehow I'd thought mandelbrot used bytestrings.
02:31:41 <ivanm> How does a bytestring differ from a normal string?
02:31:51 <sorear> bytes
02:32:01 <dons> sorear: it did. i decided to reuse a mutable buffer though
02:32:25 <sorear> normal string --> very lazy, up to 20 bytes per char, up to 2 cache misses per char, full unicode
02:32:54 <sorear> byte string -> not very lazy, 1 byte per char, 1 cache miss per 16/32 chars, ISO 8859-1 only
02:33:24 <dons> here's a nice one, http://shootout.alioth.debian.org/gp4/benchmark.php?test=recursive&lang=ghc&id=4
02:33:26 <ivanm> so its more efficient for string manipulation, but at the cost of restricting its use?
02:33:26 <lambdabot> Title: recursive Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Com ..., http://tinyurl.com/2ba9sc
02:33:32 <dons> that's *almost* naive
02:33:49 <dons> ivanm: a little. you get C-speed strings, with array fusion, but can't use unicode directly
02:33:52 <sorear> ivanm: **************much**************  more efficient.  I hope that's balanced.
02:33:56 <dons> and no pattern matching either.
02:34:13 <dons> example of the efficiency: http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=2
02:34:16 <lambdabot> Title: sum-file Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2pxuqt
02:34:17 <dons> note the first and last entries
02:34:31 <nmessenger> heh.  "Translated from the Clean by Don Stewart"  I like that it's "The Clean" instead of Clean.
02:34:58 <ivanm> I see that ghc is pretty far down in that benchmark though...
02:35:09 <ivanm> there's 2 versions of clean faster than ghc!
02:35:26 <ivanm> nmessenger: presumably "The Clean" == "The Clean implementation"
02:35:29 <dons> hmm?
02:35:34 <dons> ah yes, the mandelbrot one, yes.
02:35:43 <nmessenger> ivanm: presumably, but that would be less funny :P
02:35:46 <dons> its 1.8x C, that's ok for me
02:35:56 <dons> look at the multipl ier
02:36:40 <ivanm> For the recursive benchmark? Isn't the multiplier 3.4?
02:36:53 <ivanm> Or am I looking at the wrong column?
02:36:56 <dons> yeah, that's the bug in --fexcess-precision i reported today
02:37:04 <dons> it should be fixed tonight or tomorrow on the shootout
02:37:05 <ivanm> Oh, OK
02:37:07 <dons> (ghc ignored a flag)
02:37:11 <ivanm> lol
02:37:42 <dons> seriously though, if you think of what high level languages you'd consider for a new problem, e.g. python, ruby or haskell... http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=python
02:37:44 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2deng4
02:38:48 <ivanm> Yeah, I wouldn't use python for anything much (then again, I had the option of Python or Matlab for a matrix-based PDE problem, and my Python code was _much_ faster than those people that used Matlab!)
02:39:05 <dons> that's interesting. matrices are hard, and need good library support
02:39:27 <ivanm> BTW, when using the FFI, is there any special rules/conventions that must be adhered to when writing C, etc.functions?
02:39:39 <dons> not really. purity is a good idea.
02:39:54 <sorear> don't overwrite random addresses
02:39:57 <ivanm> dons: yeah, I was using the numarray library for python... pretty fast (compared to standard python, anyway)
02:40:57 <ivanm> Looking at the other languages there on the shootout, how does eiffel compare to haskell?
02:42:02 <sorear> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=se
02:42:04 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/yrjldn
02:42:24 <ivanm> I meant as a language, not speed
02:42:56 <ivanm> (though eiffel seems to outperform ghc a lot... less pure?)
02:43:44 <nmessenger> I would presume not many here have eiffel experience
02:44:00 <ivanm> well, when I asked about clean some people knew it ;)
02:44:50 <Saizan> isn't eiffel an OO strict language? with additional notation to specify class invariants?
02:45:41 <ivanm> oh, whoops, I thought it said pure functional OO language on the web page, sorry...
02:46:09 <nmessenger> my google turned up the wikipedia, with many important-sounding words at the top.
02:46:12 <nmessenger> http://en.wikipedia.org/wiki/Eiffel_programming_language
02:46:29 <sorear> goodnight.
02:46:38 <ivanm> yeah, well, it doesn't seem to be functional, so shmeh
02:46:43 <ivanm> sorear: g'night!
02:47:02 <nmessenger> @localtime sorear
02:47:03 <lambdabot> Local time for sorear is Sat Feb 10 02:45:59 2007
02:47:10 <nmessenger> g'night!
02:50:38 <nmessenger> "...notable functional programming languages used in industry and commercial applications include Erlang, R, ...and domain-specific programming languages like XSLT." !!?
02:51:05 <nmessenger> http://en.wikipedia.org/wiki/Functional_programming_language
02:52:06 <ivanm> nmessenger: look at the references for XSLT: http://www.topxml.com/xsl/articles/fp/
02:52:08 <lambdabot> Title: TopXML : The Functional Programming Language XSLT - A proof through examples
02:52:53 <nmessenger> yeah but calling XSLT a programming language seems like a stretch to me :)
02:53:28 <rahikkala> XSLT wouldn't be completely horrible if it took a page out of RELAX NG's book and developed an encoding that can actually be edited by normal humans, unlike the XML encoding
02:54:18 <ivanm> then again, I'm trying to read through the references and the site keeps dying on me
02:55:45 <ivanm> though I know what you mean... I always thought that XML was just a data description language...
02:57:15 <Saizan> what's the right way to fold over an Array?
02:57:56 <rahikkala> Saizan: I just fold over its elems, but I'm a simple-minded person :(
02:58:20 <ksandstr> besides folding over a list produced by the function that produces its elements in order by ascending index?
02:58:54 <nmessenger> where "the function that produces its elements in order by ascending index" = elems
02:59:51 <nmessenger> :P
03:00:04 <ksandstr> yeah, i can never remember those. it's so rare for me to use arrays in haskell anymore...
03:00:40 <rahikkala> In case you don't want to use elems, you can import Data.Foldable, it has a Foldable instance for Ix i => Foldable (Array i)
03:00:52 <nmessenger> @src Foldable
03:00:52 <Saizan> :O
03:00:53 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:01:02 <ksandstr> also, an upper and a _lower_ bound? yecch.
03:01:08 <xerox> Saizan: just use fold
03:01:16 * rahikkala slaps the bot for being abusive
03:01:24 <xerox> Ah, rahikkala just said that, np.
03:01:25 <Saizan> ?docs Data.Foldable
03:01:26 <lambdabot> Data.Foldable not available
03:01:35 * nmessenger suggests @vote cheeky-off to rahikkala
03:01:36 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
03:01:39 <lambdabot> http://tinyurl.com/23pc9l
03:01:47 <rahikkala> @vote cheeky-off
03:01:48 <lambdabot> usage: @vote <poll> <choice>
03:01:57 <Saizan> it's just that i search for instances in the page of the data structure and not of the class :)
03:01:58 <rahikkala> @vote cheeky-off yes
03:01:59 <lambdabot> "yes" is not currently a candidate in this poll
03:02:12 <nmessenger> @poll-show cheeky-off
03:02:13 <lambdabot> ["MakeItAbuseCowboyNeal","AddFlag","No","Yes"]
03:02:27 <nmessenger> uppercase 'Y'
03:02:35 <rahikkala> pffffffffft
03:02:42 <rahikkala> @vote cheeky-off Yes
03:02:43 <lambdabot> voted on "Yes"
03:02:46 <ivanm> hang on, what are you voting for?
03:03:16 <nmessenger> @src someNonexistantFunction
03:03:17 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:03:25 <nmessenger> ^^ cheekiness
03:03:42 <ivanm> ahhh.... I was wondering if you were trying to kick someone called cheeky off #haskell ;)
03:03:48 <Saizan> mmh, now the problem is that i want to fold only on a specific range..  maybe i should fold on map (arr!) (range i j)
03:03:49 <ivanm> @vote cheeky-off No
03:03:50 <lambdabot> voted on "No"
03:04:01 <nmessenger> @poll-results cheeky-off
03:04:02 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=3, Yes=13
03:04:42 <ivanm> who is CowboyNeal?
03:04:49 <nmessenger> slashdot founder
03:04:50 <opqdonut> ?vote cheeky-off No
03:04:50 <lambdabot> voted on "No"
03:04:59 <Syzygy-> ?vote cheeky-off MakeItAbuseCowboyNeal
03:04:59 <lambdabot> voted on "MakeItAbuseCowboyNeal"
03:05:00 <opqdonut> ivanm: and also a recurring joke in slashdot polls
03:05:03 <xerox> Saizan - maybe you can put the test for the range inside the folding function.
03:05:05 <Syzygy-> Someone has to stand up for the minority here!
03:05:18 <opqdonut> Syzygy-: what about addflag? :(
03:05:27 <ivanm> ahhh, OK... but presumably not in any way related to haskell?
03:05:29 <Syzygy-> opqdonut: Huh?
03:05:48 <opqdonut> Syzygy-: nobody has voted addflag yet
03:05:58 <Syzygy-> @poll-result cheeky-off
03:05:59 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=1, AddFlag=0, No=4, Yes=13
03:06:07 <Syzygy-> Oh, there was an AddFlag too...
03:06:10 <opqdonut> @polls
03:06:10 <lambdabot> Unknown command, try @list
03:06:11 <Syzygy-> Hmmm. Wonder if I can
03:06:16 <nmessenger> @list poll
03:06:16 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
03:06:21 <opqdonut> @poll-list
03:06:22 <lambdabot> ["Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
03:06:23 <Syzygy-> ?vote cheeky-off AddFlag
03:06:24 <lambdabot> voted on "AddFlag"
03:06:29 <Syzygy-> @poll-result cheeky-off
03:06:29 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=1, AddFlag=1, No=4, Yes=13
03:06:32 <Syzygy-> There we go.
03:06:39 <opqdonut> @poll-results jabberName
03:06:39 <lambdabot> Poll results for jabberName (Open): Network.Protocol.Xmpp=0, Network.Xmpp=0
03:06:43 <opqdonut> :D
03:06:48 <Syzygy-> Actually, AddFlag, if done right, is something I definitely back up.
03:06:49 <ivanm> and what is AddFlag meant to be fore?
03:06:51 <Syzygy-> ?vote cheeky-off AddFlag
03:06:52 <lambdabot> voted on "AddFlag"
03:06:57 <Syzygy-> There we go. Now I'm done.
03:07:00 <ivanm> *for
03:07:10 <Syzygy-> ivanm: I suppose it means you can tweak whom lambdabot'll insult.
03:07:11 <nmessenger> @src someNonexistantFunction /cheeky
03:07:11 <lambdabot> Source not found. You type like i drive.
03:07:20 <opqdonut> @poll-results Written_a_compiler_or_interpreter
03:07:20 <lambdabot> No such poll: "Written_a_compiler_or_interpreter"
03:07:24 <opqdonut> @poll-results Written_a_compiler_or_interpreter?
03:07:25 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=4, Yes=16
03:07:39 <opqdonut> @vote Written_a_compiler_or_interpreter? Yes
03:07:40 <lambdabot> voted on "Yes"
03:07:42 <opqdonut> yepyep
03:07:46 * rahikkala suddenly feels very inadequate
03:08:05 <ivanm> well, I wrote a dodgy haskell to scheme interpreter for an assignment once, ... does that count? ;)
03:08:44 * nmessenger wrote a false interpreter http://wouter.fov120.com/false/
03:08:46 <lambdabot> Title: Wouter's False page
03:09:06 <nmessenger> ^^ false language, my interpreter hasn't been released
03:09:19 <therp> @vote Written_a_compiler_or_interpreter? Yes
03:09:19 <lambdabot> voted on "Yes"
03:09:48 <therp> I hope a lambda calculus interpreter counts too
03:09:51 <ivanm> nmessenger: does that language even work, or does the name describe its claims? ;)
03:10:05 <nmessenger> heh
03:10:05 <ivanm> @vote Written_a_compiler_or_interpreter? Yes
03:10:06 <lambdabot> voted on "Yes"
03:10:36 <ivanm> isn't there one called whitespace or something, where the code is the whitespace (so programs can be literate!)?
03:10:52 <nmessenger> ivanm: it's basically a Forth-like, with syntax that looks like swearwords! :D
03:10:52 <oklopol> @vote Written_a_compiler_or_interpreter? Yes
03:10:53 <lambdabot> voted on "Yes"
03:11:32 <oklopol> ivanm yes there is
03:11:48 <ivanm> yep, just re-found the page on wikipedia
03:12:03 <oklopol> http://compsoc.dur.ac.uk/whitespace/
03:12:05 <oklopol> okay
03:12:06 <lambdabot> Title: Whitespace
03:12:17 <oklopol> lambdabot is great :P
03:12:24 <ibid> ahh! gtk2hs is becoming usable in sid again :)
03:12:42 <nmessenger> "Nobody will know that your blank piece of paper is actually vital computer code!"  <-- my favorite quote :)
03:12:54 <ivanm> lol
03:13:04 <oklopol> yeah, just scan it!
03:13:07 <Syzygy-> Haha
03:14:04 <ivanm> hmmm... I wonder... has anyone writtern a program such that its in both whitespace and another language? (would probably be a pain to do for something too long...)
03:14:33 <nmessenger> @google polyglot programs
03:14:34 <lambdabot> http://en.wikipedia.org/wiki/Polyglot_(computing)
03:14:37 <oklopol> that is very trivial
03:14:44 <ivanm> Then again, even their factorial code is ~1 page long... I'm sure a simple product [1..n] can fit in there somewhere ;)
03:15:01 <ivanm> odlopol: yeah, I saw that... I meant a serious program
03:15:19 <oklopol> whitespace is not code in many languages, which would make an easy conversion if the program can be programmed in whitespace
03:15:21 <ivanm> (and the 8-language polyglot link doesn't seem to work)
03:15:39 <oklopol> since a program you can make in whitespace is probably trivial to do in for example c
03:16:01 <ivanm> but would it work for something like python or haskell, which uses indentation to define blocks?
03:16:07 <oklopol> i didn't mean the link was trivial, but a program that is both whitespace and another language
03:16:13 <ivanm> I suppose you could... but why would you bother
03:16:26 <nmessenger> ivanm: you can use { ; ; } instead of layout, so it should work
03:16:50 <oklopol> haskell has a way to circumvent whitespace?
03:16:51 <ivanm> I suppose... but you'd have to take into account any spaces between your code as well
03:16:56 <oklopol> i thought it has
03:17:17 <ivanm> whitespace is just syntactic sugar for braces, isn't it?
03:17:21 <oklopol> nmessenger said it already it seems
03:17:23 <ivanm> (or is it the other way round?)
03:17:45 <nmessenger> ivanm: nope, braces are in the language definition, iirc
03:18:16 <bakert> ?src ***
03:18:17 <lambdabot> Source not found. Where did you learn to type?
03:18:22 <bakert> ?src (***)
03:18:22 <lambdabot> f *** g = first f >>> second g
03:18:23 <ivanm> nmessenger: so the compilers recognise both implicitly, without transforming one to another?
03:18:29 <bakert> ?src (>>>)
03:18:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:18:35 <bakert> ?hoogle >>>
03:18:36 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
03:18:56 <nmessenger> http://www.haskell.org/onlinereport/lexemes.html#sect2.7
03:18:57 <lambdabot> Title: Haskell 98 Lexical Structure
03:19:32 <nmessenger> bakert: (>>>) is a class method, so you might look for the specific instance you want
03:19:36 <nmessenger> @src (->) (>>>)
03:19:37 <lambdabot> f >>> g = g . f
03:19:56 <nmessenger> (->) is the function Arrow
03:20:26 <nmessenger> @src (->) (***)
03:20:26 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
03:20:40 <bakert> nmessenger, ah.  i didn't know that.  i really need to get down with arrows now that monads aren't quite so scary any more.
03:21:17 <nmessenger> Arrows are like general functions, Arrow a => a b c means an arrow of type 'a' from a 'b' input to a 'c' output
03:21:29 <nmessenger> s/general/a generalization of/
03:21:37 <bakert> ok.
03:22:02 <bakert> the only time i've ever used one is in http://bluebones.net/2007/02/formatting-decimals-in-haskell/
03:22:07 <lambdabot> Title: Formatting Decimals in Haskell - bluebones.net
03:22:09 <nmessenger> thus for the type (Int -> Char), a = (->), b = Int, and c = Char
03:22:38 <bakert> golly.
03:22:48 <bakert> so i can kind of "get at" (->) in my code?  that's cool.
03:22:50 <nmessenger> if you use them just for the function Arrow, they are like useful tuple hacking functions :)
03:23:00 <bakert> yeah that's how i was using it!
03:23:06 <nmessenger> ((->) r) is a Monad
03:23:21 <bakert> oh lord.  how deep does this hole go?!
03:23:48 <nmessenger> Int -> Char -> Bool is just infix form for (->) Int ((->) Char Bool)
03:24:03 <bakert> i see
03:24:15 <nmessenger> which, you'll notice, looks like any other normal union type
03:24:23 <bakert> part of the whole "all functions really have one argument" thing.
03:24:50 <nmessenger> you can even define an alias "type Fn = (->)" and write it as Fn Int (Fn Char Bool)
03:25:06 <nmessenger> though doing so is strictly insane. :)
03:25:09 <bakert> !
03:25:30 <bakert> so (->) is a type??  not a function?
03:25:37 <nmessenger> @kind (->)
03:25:39 <lambdabot> ?? -> ? -> *
03:25:47 <nmessenger> a higher-kinded type, i.e. a type constructor
03:25:54 <bakert> it's a type for making functions with
03:26:03 <bakert> so like i create my data objects, it creates functions?
03:26:38 <nmessenger> it creates function *types*, you'll need to use Haskell syntax to define function *values*
03:26:49 <bakert> ah yes right of course
03:26:57 <bakert> what fun
03:26:59 <nmessenger> @type (\1 -> True)
03:27:01 <lambdabot> forall a. (Num a) => a -> Bool
03:28:18 <nmessenger> (->) is analogous to (,) in this respect.  (,) Int Char is an Int/Char pair, (->) Int Char is a function from Ints to Chars
03:28:27 <kirkeby> ;window 2
03:28:49 <nmessenger> that they can be written (Int,Char) and (Int -> Char) is just syntax sugar :)
03:29:19 <bakert> nmessenger, that is really interesting that it works like that and that (->) and (,) aren't just magically predefined.  i'm not sure what the implication is but it's definitely interesting!
03:29:53 <nmessenger> I know!
03:32:23 <nmessenger> Indeed, any finite algebraic data type can be rewritten using (,), Either, (), and Void, but that's for another day :-}
03:34:34 <bakert> ... !
03:35:27 <Jaak> exit
03:35:41 <dcoutts> ibid, is that the new release in sid?
03:36:01 <nmessenger> data Season = Winter | Spring | Summer | Autumn <=> type Season = Either () (Either () (Either () ()))
03:36:04 <kolmodin> morning dcoutts
03:36:12 <dcoutts> g'morning
03:36:29 * kolmodin is looking into the Get monad again
03:36:46 <kolmodin> I just like to commit what I've got so far, just checking that it really works
03:36:48 <dcoutts> good good
03:36:52 <nmessenger> thus Winter, Spring, Summer, Autumn <=> Left (), Right (Left ()), Right (Right (Left ())), Right (Right (Right (Right ())))
03:36:55 <kolmodin> it's at least a 4-6 x speedup
03:37:06 <kolmodin> or something like that
03:37:41 <dcoutts> newsham, was your SOE question answered?
03:40:30 <dons> on breaking off the strict head of the input bytestring, kolmodin ?
03:40:34 <dons> is that what you're working on?
03:40:39 <kolmodin> dons: exactly
03:40:51 <dons> yeah, i think its critical
03:40:58 <kolmodin> I started a while ago, time to wrap it up
03:41:11 <dons> yeah, if we can get that done, we could tag and release
03:41:16 <dcoutts> @arr
03:41:17 <lambdabot> Yeh scurvy dog...
03:41:37 <kolmodin> It's still far from as fast it could be, but it's at least something
03:42:02 <kolmodin> we lack a lot of test cases for stuff other than the instances of Binary
03:42:06 <dons> once that's in place, i'm happy to read core to get it better
03:42:20 <kolmodin> like skip, remaining, lookaheads and that kind of thing
03:42:46 <kolmodin> dons: nice. I'd like to lear that too, it's kind of black magic :)
03:43:13 <kolmodin> it takes time and a big jar of coffee/tea
04:02:15 <beelsebob> why is all the rum gone?
04:03:39 <nmessenger> oh.  that's why.
04:04:23 * nmessenger `heart` Pirates
04:43:36 <Stinger> dcoutts on?
04:43:53 <Stinger> @seen dcoutts
04:43:53 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I last heard dcoutts speak 1h 2m 36s ago.
04:44:53 <nomeata> Hmm. Is there a nice way (no uncurry, maybe no list comprehension) to write this function:
04:44:54 <nomeata> matrix_multiply a b = map (map (uncurry inner_product)) [[(x,y) | y <- b] | x <- a]
04:48:29 <nmessenger> I'm not terribly good at list comps, but couldn't you inline the map map into the comprehension result? i.e. [[inner_product x y | y <- b] | x <- a]
04:48:34 <xerox> yeah.
04:49:10 <jumps54321> a question, is either a or b transposed?
04:49:38 <jumps54321> if not, it looks like you are taking the inner prod. of rows of a and rows of b
04:50:10 <ibid> dcoutts: yes, though installing it is a *major* pain (bug reported)
04:50:17 <nomeata> nmessenger: I think you are right, I just noticed it as well
04:50:40 <nomeata> This might be a useful addition to this haskell-code-suggestion-program (forgot the name)
04:50:48 <nmessenger> Dr. Haskell?
04:51:10 <nomeata> jumps54321: not sure, isn’t my code, I’m just trying to give suggesstions
04:51:13 <nmessenger> @where drhaskell
04:51:14 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
04:51:14 <nomeata> nmessenger: that’s the one
04:53:42 * ibid aborts the gtk2hs install attempt
05:01:15 <Twey> Ahm, trying to grasp monads here... a tutorial I'm reading says that monads force execution in order, no?
05:01:48 <Twey> Yet, http://rafb.net/p/OtmFhA36.html reads in a and b first, then prints out all the output all at once.
05:01:49 <lambdabot> Title: Nopaste - No description
05:02:10 <Cheery> Twey: depends.
05:02:22 <nmessenger> The IO monad does, but I don't think it's required in general
05:02:35 <Twey> Ah
05:02:46 <Twey> But that still doesn't explain that code, which is in main
05:03:14 <defcon8> is there a haskell to c compiler?
05:03:17 <defcon8> or one being made
05:03:23 <nmessenger> Twey: how much Haskell do you know?  Can you read types?  Can you mentally desugar 'do' blocks?
05:03:38 <Twey> Nope, I'm an imperative programmer floundering a little.  :-)
05:04:47 <xic> defcon8: ghc generates c code from haskell code
05:04:52 <nmessenger> @wiki IO_inside
05:04:53 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
05:04:55 <nmessenger> ^^ An explanation of the IO monad that helped me a lot, but it requires some base Haskell knowledge.
05:05:00 <Twey> Thanks
05:05:12 <defcon8> xic, why isn't it fast, then?
05:05:21 <xic> defcon8: it is fast
05:05:28 <defcon8> fast as C?
05:05:32 <xic> defcon8: yes
05:05:35 <defcon8> I looked at the great language shootout on gentoo
05:05:38 <defcon8> well, that's good then
05:05:43 <xic> @shootout
05:05:44 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
05:06:23 <pejo> defcon, laziness is a part of the reason for the performance difference, usually.
05:06:24 <defcon8> not that slower at all
05:06:40 <defcon8> pejo, you mean it's good or bad?
05:07:24 <pejo> defcon, when the laziness makes the program do less work it's good, otherwise it might give a performance penalty.
05:08:01 <defcon8> ahh okay
05:08:12 <defcon8> why doesn't the following work? :
05:08:18 <defcon8> let list = 1:list
05:08:20 <defcon8> fst list
05:08:21 <Vq^> funny thing is that they had to change some programs where laziness really paid off because Haskell got to good scores :)
05:08:28 <defcon8> :D
05:08:31 <Syzygy-> defcon8: Because of what fst is.
05:08:33 <Syzygy-> ?type fst
05:08:35 <lambdabot> forall a b. (a, b) -> a
05:08:37 <nmessenger> @type head
05:08:39 <lambdabot> forall a. [a] -> a
05:08:46 <xic> > let list = 1:list in head list
05:08:48 <lambdabot>  1
05:08:59 <defcon8> oh yeah
05:09:03 <defcon8> fst is for tuples
05:09:05 <Syzygy-> > let list = 1:list in list !! 2
05:09:07 <lambdabot>  1
05:09:18 <pejo> Vq, performing no work should be about equally expensive in all languages, so crappy benchmark then.
05:09:53 <Maddas> defcon8: 'fast as C' is meaningless (talking about compiler output anyway), you can always write slow C.
05:10:06 <defcon8> yes but in equivalent algorithms
05:10:11 <Maddas> Yes.
05:10:55 <defcon8> how are databases done in Haskell if destructive update is not allowed?
05:10:58 <defcon8> monads?
05:11:05 <Vq^> pejo: well... it depends on what they want the benchmark to show
05:11:52 <Maddas> pejo: Why should performing no work be about equally expensive in all languages? You need to consider starting up virtual machines and such for some language...
05:12:04 <Maddas> some languages, even.
05:12:06 <jumps54321> the reality is that Haskell is slower, but it's worth it to write in a more expressive language -- that is why people write in C instead of assembler
05:12:32 <jumps54321> but most programs don't need tremendous speed
05:12:51 <jumps54321> and most that do need speed has very small bottleneck regions
05:12:52 * Maddas disagrees with jumps54321
05:12:57 <pejo> Maddas, that's just a constant, and it's fairly small for starters. But why would I run the "empty program", ever?
05:13:08 <defcon8> why do lists have to be homogenous/
05:13:12 <defcon8> how do you do hash tables?
05:13:38 <Maddas> pejo: I don't know, but if you don't, why do you care about how expensive it is? (I'm confused)
05:13:40 <pejo> defcon, you have a strange design if every 8th element in a list should be a number, but the rest characters.
05:14:21 <Syzygy-> data HashBucket a = [a]; data HashKey a = a; data HashItem a b = (HashKey a,HashBucket b); data HashList a b = [HashItem a b]
05:14:27 <Syzygy-> Something like that would work.
05:14:43 <Maddas> pejo: I agree that small benchmarks as the shootout has them do not characterize real-world performance in any meaningful way, if that's what you're saying.
05:14:44 <defcon8> okay
05:14:48 <Syzygy-> Hrm. Modulo all the constructors I forgot...
05:14:56 <defcon8> ahh, of course, you could use datatypes
05:14:58 <xic> well, c was originally used not because it's more productive then assembly, but because it is portable
05:15:10 <jumps54321> true, excuse me
05:15:41 <jumps54321> but I think the point is still valid -- there is some trade of speed for expressiveness in haskell, especially with lazy programming
05:15:51 <pejo> Maddas, I'm more saying that performing no work and measuring the cost of that is an odd benchmark - since all real programs will eventually compute something, otherwise they're useless.
05:16:01 <Maddas> pejo: Indeed.
05:16:08 <pejo> Maddas, but I agree that the shootout measures something completely different than real world performance.
05:18:43 <pejo> jumps54321, let's separate expressiveness and evaluation strategy. Most people would consider SML or O'caml 'equally expressive', except for the infinite structures.
05:19:48 <defcon8> how would it be possible to define the signum function piecewise?
05:20:21 <defcon8> without case
05:20:40 <defcon8> oh yeah, there's the guard thing
05:21:13 <joelr1> good day
05:21:14 <lambdabot> joelr1: You have 1 new message. '/msg lambdabot @messages' to read it.
05:21:44 <joelr1> wow, a message box of my own!
05:22:03 <Syzygy-> joelr1: Everyone has one. :)
05:22:42 <joelr1> lambdabot is not saying anything, though
05:22:46 <joelr1> weird
05:22:51 <nmessenger> @tell joelr1 use @tell to leave someone a message
05:22:51 <lambdabot> Consider it noted.
05:23:23 <joelr1> i mean i asked lambdabot for messages and it's quiet
05:23:23 <lambdabot> joelr1: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:23:32 <nmessenger> heh
05:23:58 <joelr1> ah, now it works
05:24:00 <joelr1> thanks
05:24:00 <jumps54321> i would consider evaluation strategy a big part of the 'expressiveness' of haskell (by this I mean how well one's mental/mathematical notions map to code) -- it free the programmer from worrying about stop conditions in advance
05:24:36 <kfish> in the type system, what's the word for a thing with kind * (ie. with no free type arguments, as opposed to say * -> *)? a type? a concrete type? an instantiable type?
05:24:39 <joelr1> has anyone tried embedding ghc into their app?
05:24:46 <kolmodin> dons, dcoutts: binary patch applied
05:24:51 <pejo> jumps54321. and you consider SML mapping it considerably worse?
05:25:32 <jumps54321> i am not familiar with SML, though I have a little ocaml exp.
05:26:03 <joelr1> kolmodin: thanks (syb)
05:26:27 <joelr1> has anyone tried using haskell as a scripting language in their app?
05:26:42 <kolmodin> joelr1: glad you like it
05:26:43 <nmessenger> kfish: I usually call it a "type of the first kind"
05:26:45 <pejo> jumps54321, and it was considerably worse than Haskell?
05:27:20 <nmessenger> "*-kinded type" is succinct
05:28:19 <jumps54321> pejo, no
05:29:03 <kfish> nmessenger, cheers -- tho I'm trying to describe it while introducing the concept of kinds, so perhaps I'll just use a few extra words :-)
05:29:25 <jumps54321> i need to go, pejo, bye
05:30:19 <nmessenger> concrete type seems clearish, then
05:30:47 <kfish> nmessenger, :-) cool
05:35:05 <defcon8> how do I make ghc output c code?
05:36:20 <nmessenger> defcon8: check the docs: http://haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
05:36:22 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/yod3gf
05:36:33 <defcon8> okay thanks
05:38:41 <Twey> Hmm... GHC complains about the type of a when doing a simple "main = readLn >>= (\a print a)"
05:40:10 <nmessenger> it doesn't know which type you want to read.  try (readLn :: IO Int)
05:40:43 <psi> it's \a -> print a
05:40:55 <Twey> Ah, thanks
05:41:24 <Twey> Oh, aye, sorry, typed it out wrongly
05:42:04 <defcon8> bishopsbriggs?
05:42:14 <defcon8> just trying to guess from your host
05:42:27 <defcon8> I seem to be connected to cowcaddens NTL
05:42:49 <Twey> And how about strings?  (readLn :: IO String) gives a no-parse error
05:43:19 <nmessenger> did you type the quotes at the prompt?
05:43:51 <Twey> No :-)
05:43:56 <nmessenger> it has to be a reasonably well-formed Haskell expression for readLn
05:44:05 <nmessenger> if you just want what was typed, use getLine
05:44:18 <Twey> Aha
05:44:20 <Twey> Thanks.
05:44:25 * Twey goes back to the docs.
05:44:37 * joelr1 just opened a can of worms on haskell-cafe
05:44:45 <joelr1> purposefully so
05:44:56 <GsD_CeleborN> [dcoutts]: hi
05:45:26 <GsD_CeleborN> [dcoutts_]: hi
05:52:29 <syntaxfree> my IRC client has one of these sound alarms when someone mentions my nickname.
05:52:33 <syntaxfree> It's a clear typewriter "ding".
05:52:39 <syntaxfree> My mother once said it sounds like a buddhist temple.
05:53:03 <syntaxfree> Said that, I love the sound of lambdabot going "ding" when I come around and spam about a new post ; )
05:53:10 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/10/guido-is-wrong-for-loops-declarativeness-and-charlie-mingus/
05:53:13 <lambdabot> Title: Guido is wrong! for loops, declarativeness and Charlie Mingus « Data.Syntaxfree, http://tinyurl.com/yq79ef
05:53:25 <syntaxfree> it's like if it was celebrating it.
05:53:37 <Cheery> heh.
05:53:41 <cjay> lol
05:54:04 <Cheery> how many else likes the concepts of zigzag and xanadu?
05:54:58 <Cheery> I didn't know they even exist, now feel I love them.
05:55:13 <Cheery> They are almost a pure foundation for an operating system. :)
05:58:03 <defcon8> how do I display an integer?
05:58:12 <syntaxfree> > show 2
05:58:12 * chris2 played with zigzag a bit
05:58:13 <dons> > show (42 :: Integer)
05:58:13 <lambdabot>  "2"
05:58:14 <lambdabot>  "42"
05:58:14 <defcon8> thanks
06:00:07 <nmessenger> @src print
06:00:07 <lambdabot> print x = putStrLn (show x)
06:00:11 <GsD_CeleborN> Somebody knows as using keyboard events on Gtk Opengl
06:00:11 <Cheery> I guess this year will go on studying code generation.
06:00:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/432
06:00:23 <defcon8> can someone tell me what's wrong with printy? http://hpaste.org/432
06:01:26 <Cheery> defcon8: lets see...
06:01:33 <mauke> defcon8: what's wrong with operations?
06:01:54 <defcon8> sdays printy is applied to too many args
06:01:58 <defcon8> says
06:02:54 <Cheery> hmm, this is interesting, I will load it up to my desktop and try it. :)
06:03:24 <mauke> defcon8: fix operations, then it should work
06:03:36 <defcon8> oh yeah
06:03:38 <defcon8> need to display iut
06:04:56 <defcon8>   putStrLn show (foldr (+) list)
06:04:58 <defcon8> that doesn't work
06:05:12 <nmessenger> putStrLn (show (foldr (+) list))
06:05:23 <defcon8> oh yeah
06:05:30 <nmessenger> also, foldr needs a base case
06:05:34 <defcon8> damn, insert won't seem to turn off
06:05:39 <defcon8> how do you mean?
06:05:44 <nmessenger> foldr (+) 0 list
06:05:59 <defcon8> ahh okay
06:06:18 <mauke> a.k.a. sum list
06:06:27 <nmessenger> @src sum
06:06:28 <lambdabot> sum = foldl (+) 0
06:06:36 <defcon8> now I've got probs in main
06:06:57 <sieni> or you can use foldr1 or foldl1, but then it won't work on an empty list
06:07:01 <defcon8> ahh, need results from entering first
06:07:09 <sieni> > foldr1 (+) [1..4]
06:07:10 <lambdabot>  10
06:07:14 <sieni> > foldl1 (+) [1..4]
06:07:15 <lambdabot>  10
06:07:19 <nmessenger> entering is an IO [Int], so you'll need to draw out the [Int] via the (<-) syntax
06:07:19 <defcon8> yes, works
06:07:29 <defcon8> I still don't get the <- thing. can anyone explain it to me please?
06:07:32 <Vq^> syntaxfree: who is dr. k ?
06:07:37 <defcon8> is it because it's not a pure function?
06:07:53 <nmessenger> @undo do {x <- readLn :: IO Int; print x}
06:07:53 <lambdabot> readLn :: IO Int >>= \ x -> print x
06:07:55 <sieni> it's just a shorthand notation
06:08:19 <nmessenger> er, that should have parens
06:08:38 <nmessenger> defcon8: have you read YAHT?
06:08:44 <dons> huh, is sigfpe the new oleg? http://homepage.mac.com/sigfpe/
06:08:45 <lambdabot> Title: index
06:08:48 <defcon8> nmessenger, it's actually an example from there
06:08:57 <defcon8> I just never got fully what <- is for
06:09:37 <mauke> defcon8: it's syntactic sugar for >>=
06:10:00 <nmessenger> @type (>>=)
06:10:01 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
06:10:13 <defcon8> ahh I guess I'll get it when I get to monads
06:10:19 <mauke> what lambdabot is trying to tell you is IO a -> (a -> IO b) -> IO b
06:10:27 <mauke> you can understand it without monads
06:10:38 <nmessenger> it takes an action (m a), a function that makes a new action (a -> m b), and puts them together to make a combined action (m b)
06:11:07 <nmessenger> @redo readLn >>= \ x -> print x
06:11:08 <lambdabot> do { x <- readLn; print x}
06:11:56 <nmessenger> readLn is an action that results in some type in the Read class.  The (\ x -> print x) function takes the resulting value and passes it to 'print', which makes a new action
06:12:00 <nmessenger> @type print
06:12:01 <lambdabot> forall a. (Show a) => a -> IO ()
06:12:14 <ookk> !paste
06:12:15 <hpaste> Haskell paste bin: http://hpaste.org/
06:14:27 <nmessenger> you can think of an IO action as a program snippet.  You can pass them around and make new ones, but the only one that ever gets run is the 'main' action (and the subsequent actions in its binding chain)
06:15:28 <hpaste>  ookk pasted "what am i doing wrong?" at http://hpaste.org/433
06:15:40 <mauke> you can think of an IO value as a data structure that describes how to perform an action
06:15:44 <ookk> how can i speed up the haskell code?
06:15:47 <mauke> the haskell runtime interprets this data structure
06:20:21 <dons> ookk: profile, and then tune.
06:20:29 <dons> follow the tips on the Performance wiki
06:20:34 <dons> ?wiki Performance
06:20:34 <lambdabot> http://www.haskell.org/haskellwiki/Performance
06:20:54 <dons> it should be possible to write *very* fast (i.e. C like) code, if you understand what your code is doing
06:20:59 <dons> see the shootout, for examples.
06:21:05 <dons> ?shootout
06:21:05 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
06:21:40 <ookk> dons, yes im trying to understand what makes it fast / slow
06:21:46 <ookk> dons, and i have stricitfied it
06:21:55 <ookk> as i have read the performance guidlines
06:23:09 <dons> ah, ok. you're using IORefs!
06:23:17 <dons> don't use IORefs for accumulators :)
06:23:26 <ookk> why?
06:23:29 <dons> look at the 'recursive' benchmark, you should pass your accumulators on the stack
06:23:32 <dons> as haskell variables
06:23:36 <dons> IORefs are slow
06:23:51 <dons> so don't translate mutable C vars to IORefs, translate them to stack variables
06:24:05 <dons> also, the -fexcess-precision flag should be used with any Double-based code
06:24:18 <dons> i.e. add the {-# OPTIONS -fexcess-precision #-} pragma
06:24:20 <dons> to the top of your code
06:24:28 <ookk> yeah i know about that, but i wanted it to be "fair" to the cpp-code
06:24:40 <ookk> so i didnt turn that flag on
06:24:41 <dons> the main thing is not to use IORefs
06:24:49 <dons> use stack variables
06:24:57 * dons writes a translation
06:24:58 <ookk> dons, which module are they in?
06:25:40 <ookk> i thought IORefs where the mutable to use in haskell
06:26:29 <bakert> dons, is excess-precision for performance, or is that just a general guideline?
06:26:52 <dons> ookk: also, -optc-O3 often slows things down
06:26:56 <ookk> excess-precision can screw up floatingpoint calculations
06:27:12 <ookk> dons, in this case it doesnt to anything, i tried with it on and off
06:27:17 <ookk> = the same time
06:29:02 <paolino> :t Data.Map.lookup
06:29:08 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
06:29:26 <dons> bakert, for performance of floating point code. it can mean a 2-3x speedup
06:29:38 <nmessenger> @let m = M.fromList [(1,'a'),(2,'b'),(3,'c')]
06:29:40 <lambdabot> Defined.
06:29:51 <nmessenger> > lookup 2 m :: Maybe Char
06:29:51 <lambdabot>  Couldn't match `[(a, Char)]' against `Data.Map.Map Integer Char'
06:30:05 <nmessenger> > M.lookup 2 m :: Maybe Char
06:30:07 <lambdabot>  Just 'b'
06:30:12 <hpaste>  dons annotated "what am i doing wrong?" with "This beat's C...!" at http://hpaste.org/433#a1
06:30:22 <nmessenger> > M.lookup 5 m :: Either String Char
06:30:24 <lambdabot>  Left "Data.Map.lookup: Key not found"
06:30:25 <ookk> dons, yeah well with that flag the cpp and hasell programs is not comparable
06:30:29 <dons> ookk: see the annotation
06:30:43 <dons> anyway, that's the best way to translate a C loop to Haskell
06:30:51 <dons> see how the accumulator is passed on the stack?
06:30:54 <Syzygy-> > M.lookup 3 m
06:30:55 <lambdabot>   add an instance declaration for (Show (m Char))
06:31:04 <nmessenger> > runIdentity $ M.lookup 5 m :: Identity Char
06:31:04 <lambdabot>  Couldn't match `Identity Char' against `Char'
06:31:40 <paolino> M.lookup 3 :: String
06:31:42 <ookk> dons, that is not writing something to a mutable variable though
06:31:55 <ookk> which is what i need
06:31:58 <nmessenger> > typeOf m
06:32:00 <lambdabot>  Map Integer Char
06:32:02 <paolino> > M.lookup 3 :: String
06:32:03 <lambdabot>      Expecting a function type, but found `[Char]'
06:32:04 <lambdabot>       Expected type: Strin...
06:32:21 <nmessenger> you need a Map, I @let'ed 'm' above
06:32:28 <dons> ookk: I'm saying, don't use a mutable vriable, use the stack slow as a mutable variable
06:32:35 <paolino> > M.lookup 3 m :: String
06:32:36 <lambdabot>  "c"
06:32:36 <dons> or expect awkward code, the IO monad, and slow code.
06:32:43 <nmessenger> heh
06:32:56 <paolino> > M.lookup 12 m :: String
06:32:57 <lambdabot>  ""
06:33:04 <nmessenger> String = [Char], so [] satisfies Monad m => m
06:33:12 <dons> stack slot. sorry, its a bit later here :)
06:33:24 <dons> and my wifi is dropping out
06:33:35 <dons> ookk: is there a reason you *must* use a mutable variable?
06:33:40 <ookk> dons, well i am trying to write an entry to the nbody shootout, and i was thinking about what might be a good mutable variable for the vector3's
06:33:40 <dons> (and if so, use a Ptr Double)
06:33:50 <dons> ah, did you see my new entry?
06:33:55 <dons> its about 2.2x slower than C
06:34:05 <dons> and uses a Ptr Double array
06:34:09 <ookk> dons, no i havent seen that?
06:34:09 <paolino> :t mapM (flip M.lookup m)
06:34:11 <lambdabot> Couldn't find qualified module.
06:34:18 <dons> yeah, you can't pass all those planet data on the stack
06:34:22 <dons> even though that would be the fastest.
06:34:25 <dons> ?wiki Shootout
06:34:25 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
06:34:30 <ookk> dons, i wrote the vectors3s as IOUArray Int Double now but that was to slow
06:34:31 <dons> all the entires are recorded here ^^
06:34:48 <mauke> how does haskell's alloca work?
06:34:49 <paolino> :t M.lookup
06:34:50 <dons> yeah, its a *hard* problem. basically it all comes down to how good your inner loop in the 'advance' function is
06:34:51 <lambdabot> Couldn't find qualified module.
06:35:08 <dons> ookk: check the etry on the wiki for Nbody, that's the best I could do today
06:35:11 <ookk> dons, which one is yours?
06:35:28 <ookk> the one that is 2.2x c
06:36:04 <paolino> > mapM (flip M.lookup m) [1,2]
06:36:05 <lambdabot>   add an instance declaration for (Show (m [Char]))
06:36:05 <dons> this one, http://www.haskell.org/haskellwiki/Shootout/Nbody#Proposed_entry
06:36:07 <lambdabot> Title: Shootout/Nbody - HaskellWiki
06:36:07 <ookk> 2 Proposed entry?
06:36:30 <dons> we really need nice mutable array syntax to make this fun to program in Haskellthough
06:36:42 <dons> its just unpleasant
06:37:06 <ookk> dons, we need fast mutable variables
06:37:08 <paolino> > concat $ mapM (flip M.lookup m) [1,2] :: String
06:37:09 <lambdabot>  "ab"
06:37:11 <dons> so basically, I use stack variable where possible, (i.e. advanceJ)
06:37:15 <dons> and elsewhere the fast Ptr Double
06:37:16 <ookk> because that is what IORef is supposed to be?
06:37:22 <ookk> but now they are painfully slow
06:37:24 <dons> which is plenty fast, its just a raw machine array after all
06:37:37 <paolino> > concat $ mapM (flip M.lookup m) [1..100] :: String
06:37:38 <lambdabot>  ""
06:37:40 <dons> Ptr Foo is better for speed. IORef has synchronisation issues
06:37:58 <paolino> uh
06:38:11 <paolino> > m
06:38:12 <lambdabot>  {1:='a',2:='b',3:='c'}
06:38:36 <ookk> dons: Parse error on #
06:38:48 <dons> O -fglasgow-exts -fbang-patterns -optc-O3 -optc-march=pentium4
06:39:04 <paolino> nmessenger: what's happened?
06:39:25 <Syzygy-> ?doc Ptr
06:39:25 <lambdabot> Ptr not available
06:39:39 <paolino> > concat $ mapM (flip M.lookup m) [1..3]
06:39:40 <lambdabot>  "abc"
06:39:48 <mauke> ?doc Foreign.Ptr
06:39:48 <paolino> > concat $ mapM (flip M.lookup m) [1..4]
06:39:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
06:39:50 <lambdabot>  ""
06:39:51 <dons> ookk: watch out for line wrapping when copying from the wiki
06:39:51 <ookk> dons, yeah you use Ptr Double, that must be as much of a raw double as you can get in haskell
06:40:05 <ookk> i got it to compile now
06:40:18 <dons> it is a raw machine double, yes.
06:40:24 <dons> literally. exactly the same as in C
06:40:28 <nmessenger> @src mapM
06:40:28 <lambdabot> mapM f as = sequence (map f as)
06:40:44 <ookk> runs in 27.89s on my machine
06:40:46 <nmessenger> @src sequence
06:40:46 <lambdabot> sequence ms = foldr k (return []) ms
06:40:47 <lambdabot>     where
06:40:47 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
06:40:53 <chessguy> 'morning haskellers
06:40:57 <dons> ok, for n=5500?
06:41:05 <paolino> > concat $ mapM (flip M.lookup m) [0..3]
06:41:06 <lambdabot>  ""
06:41:09 <ookk> 0.01s
06:41:11 <nmessenger> hmm
06:41:24 <dons> sorry, whatever the number was on the shootout
06:41:27 <dons> was it 20M?
06:41:31 <chessguy> ?src minimum
06:41:32 <lambdabot> minimum [] = undefined
06:41:32 <lambdabot> minimum xs = foldl1 min xs
06:41:38 <dons> ookk, how does C do on your machine?
06:41:39 <ookk> dons, 20M is 27.89s
06:41:46 <ookk> let me see...
06:41:47 <dons> ok. that sounds reasonable I think
06:41:50 <chessguy> ?src foldl1
06:41:51 <lambdabot> foldl1 f (x:xs) = foldl f x xs
06:41:51 <lambdabot> foldl1 _ []     = undefined
06:41:57 <dons> I'd say C would do about 15s then
06:42:13 <dons> maybe worse though. 27s is pretty good, iirc
06:42:32 <chessguy> ?src foldl
06:42:33 <lambdabot> foldl f z xs = lgo z xs
06:42:33 <lambdabot>     where lgo z []     =  z
06:42:33 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
06:42:39 <dons> I did spend 4 hours this morning looking at the asm output though, ookk... ;)
06:43:03 <ookk> dons, hehe
06:43:05 <paolino> @let  l=flip M.lookup m
06:43:06 <lambdabot> <local>:5:7:     Ambiguous type variable `m' in the constraint:       `Monad ...
06:43:17 <hpaste>  Eighty pasted "polymorphism fun" at http://hpaste.org/434
06:43:32 <nmessenger> > mapM (flip M.lookup m) [1..3] :: [String]
06:43:34 <lambdabot>  ["abc"]
06:43:36 <Eighty> what's wrong? i can define f _ _ = (), but if i add a constructor, it complains
06:43:38 <nmessenger> > mapM (flip M.lookup m) [0..3] :: [String]
06:43:39 <lambdabot>  []
06:44:05 <paolino> nmessenger: were you blaming concat ?
06:44:29 <chessguy> is there something like a fold that gives as a result both the list and the value?
06:44:29 <ookk> dons, hmm the c++ version doesnt compile for me
06:44:30 <ookk> Bodies::solar_mass
06:44:30 <ookk> collect2: ld returned 1 exit status
06:44:44 <ookk> has he provided a .h file or something
06:44:57 <dons> not sure. I usually don't bother with the C++, since it rarely compiles
06:44:58 <nmessenger> paolino: I'm only half paying attention, I have to go.
06:45:05 <paolino> np
06:45:08 <dons> i just check against C, and check the Clean entries for hints
06:45:20 <paolino> thanks for that half
06:45:40 <dons> ookk, see the stack passing variable trick in offset_momentum. not mutable vars, since using the stack is so much faster
06:45:57 <chessguy> @type foldl
06:45:57 <ookk> hmm i changed it manually
06:45:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:46:29 <ookk>  ./test 20000000  15.19s user 0.03s system 99% cpu 15.305 total
06:46:35 <ookk> thats the cpp version
06:46:43 <chessguy> ?hoogle (a -> b -> a) -> [b] -> (a, [a])
06:46:44 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
06:46:44 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
06:46:44 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:46:51 <dons> haha . 01:40  dons> I'd say C would do about 15s then
06:47:37 <dons> ookk, that's ok then. this problem is about as least suited to the existing Haskell libraries as you can get. so < 2x C++ works for me.
06:48:18 <ookk> dons, yeah but it is good as it reveals flaws in the libraries
06:48:25 <dons> it sure does.
06:48:27 <kfish> Eighty, Boo is a type, not a variable
06:48:29 <ookk> these things needs to be worked on
06:48:40 <dons> yeah, so a nice interface to mutable arrays would be useful
06:48:45 <Eighty> kfish: it's the name of the constructor also
06:48:46 <dons> basically just sugar for what I do manually in that entry
06:48:53 <ookk> you shouldnt have to read asm to make such a thing go fast :P
06:48:53 <dons> x := v
06:48:57 <dons> would make a good function
06:49:01 <Eighty> kfish: defining f _ _ = (), i can evaluate f Boo Foo
06:49:13 <ookk> dons, yeah thats what i tried to do in my nbody.hs
06:49:23 <dons> ookk, for shootout code I think everyone reads the asm....
06:49:27 <ookk> i wrote a Vector3 using IOUArray INt Double
06:49:36 <dons> since you're competing against C gcc guys who *do* read the asm
06:49:38 <ookk> and defined += -= =<
06:49:38 <Saizan> Eighty: you can't use pattern match on a polymorphic type like that
06:49:40 <ookk> etc
06:49:43 <ookk> but it was to slow
06:49:43 <dons> yeah, that's good.
06:49:51 <dons> with inlining and strictness that should have reasonable performance
06:49:59 <dons> since IOUArrays compiled down to Ptr Double in the end
06:50:11 <dons> if you had a smaller example I might look at it
06:50:23 <dons> but I never want to touch nbody again after today ;)
06:50:40 <Eighty> Saizan: why not?
06:50:45 <Saizan> Eighty: you only know that "a" and "b" are members of class Moo, you can't inspect the concrete types
06:50:50 <ookk> dons, hehe
06:50:59 <Eighty> Saizan: okay
06:51:02 <dons> i think i have RSI from writing shootout code
06:51:04 <Saizan> Eighty: you can only use the methods of the class
06:51:56 <chessguy> let f [] = []; f [a] = [a]; f (x:y:zs) = if x < y then y:(f $ x:z) else x:(f $ y:z) in f [3,3,10,2,9,4,11,1]
06:52:05 <ookk> dons, i have deleted that code as it was to slow
06:52:06 <Saizan> Eighty: the library Typeable can provide something like what you are trying to do, but is uncommonly needed
06:52:11 <chessguy> > let f [] = []; f [a] = [a]; f (x:y:zs) = if x < y then y:(f $ x:z) else x:(f $ y:z) in f [3,3,10,2,9,4,11,1]
06:52:12 <lambdabot>   Not in scope: `z'
06:52:23 <chessguy> > let f [] = []; f [a] = [a]; f (x:y:zs) = if x < y then y:(f $ x:z) else x:(f $ y:zs) in f [3,3,10,2,9,4,11,1]
06:52:23 <lambdabot>   Not in scope: `z'
06:52:28 <dons> ookk, one thing I didn't try was a Ptr Planet
06:52:44 <dons> data Planet = Planet { x :: !Double, ... }
06:52:52 <chessguy> > let f [] = []; f [a] = [a]; f (x:y:zs) = if x < y then y:(f $ x:zs) else x:(f $ y:zs) in f [3,3,10,2,9,4,11,1]
06:52:54 <lambdabot>  [3,10,3,9,4,11,2,1]
06:52:58 <dons> which with unpacking should have the same representation, but better syntax
06:53:10 <chessguy> > let f [] = []; f [a] = [a]; f (x:y:zs) = if x < y then y:(f $ x:zs) else x:(f $ y:zs) in f [1,3,3,10,2,9,4,11]
06:53:11 <lambdabot>  [3,3,10,2,9,4,11,1]
06:53:18 <Eighty> Saizan: i'll check it out
06:53:21 <ookk> dons, dont you have to write an instance for Ptr Planet then?
06:53:50 <dons> yeah, an instance of Storable
06:53:56 <dons> so you can control the packing
06:54:00 <dons> and then use peek/poke on the fields
06:54:26 <dons> rather than the manual array flattening transformation I do here
06:54:32 <oklopol> tutorial, please :)
06:54:33 <ookk> yeah but then that instance declaration would look ugly instead :P
06:54:51 <dons> not so bad, and you only need to do it once.
06:55:35 <ookk> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=ocaml&id=0
06:55:39 <lambdabot> Title: n-body OCaml program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langua ..., http://tinyurl.com/yv3zjw
06:55:46 <ookk> that is what haskell should be able to do
06:55:55 <ookk> with some kind of mutable variable
06:56:00 <dons> yeah, I agree.
06:56:09 <dons> its just a library wrapper over Ptr we need to write!
06:56:26 <ookk> yeah
06:56:37 <ookk> a class called Mutable
06:56:38 <dons> though Storabe isn't too far off
06:56:42 <ookk> if that name isnt already taken?
06:56:47 <chessguy> hmm, the channel has gotten a lot less newbie friendly with all the bit-twiddling going on for the shootout
06:56:57 <dons> chessguy: hey/
06:57:29 <chessguy> hey what?
06:57:31 <syntaxfree> the channel  has gotten a little less newbie friendly as the level of arrogance has risen an epsilon in the past two weeks. But it's hardly noticeable yes.
06:57:38 <paolino> does M.lookup run fail ?
06:57:52 <chessguy> arrogance by who?
06:57:59 <dons> chessguy, afraid of a little Ptr ? ;)
06:58:25 <Eighty> Saizan: i can't see how it does what i want...
06:58:31 <chessguy> dons, i'm just making a general observation
06:58:44 <dons> oh, how do you mean? I hope things haven't changed that much
06:58:53 <dons> ookk is a newbie, no? :-) and getting lots of help!
06:59:15 <Eighty> Saizan: i have two different data type representations for a thingy, and i want a function to take two as an argument, and have different behavior depending on the types
06:59:23 <Eighty> like c++-style overloading
06:59:33 <ookk> dons, i get good help here
06:59:37 <Philippa> I don't think arrogance is the word. Perhaps not having time to spend helping newbies as much
06:59:51 <ookk> dons, because the stuff i ask is not covered in any tutorials (i know of...)
06:59:58 <dons> yeah, i've not been around much in the last weekyeah.
07:00:10 <Philippa> dons: so much for arrogance ;-)
07:00:22 <chessguy> it just seems like most of the conversation is at a much higher level than most newbies can follow, and most newbie-level conversations get swallowed up in those
07:00:25 <Philippa> certainly I do a lot less teaching than I did a couple of years back too
07:00:46 <Philippa> the former isn't necessarily a problem. The latter might be - time for more use of -overflow?
07:00:46 <dons> chessguy: yeah, sometimes that happens
07:01:06 <dons> sometimes they go over to -overflow, sometimes its good to follow the hard stuff :-)
07:01:17 <Saizan> Eighty: the clean way is to have them member of a typeclass so that you can specify the different behavior but using the same interface, not to check the type in a polymorphic function
07:01:25 <dons> ookk, maybe we should write a nice data Planet = Planet { x :: Double , ...} version
07:01:26 <Philippa> but the high-level conversation's always been an important part of the chan, otherwise everyone just hits the same 'intermediate' level and never gets to pick up new stuff
07:01:28 <dons> then work out what the hard stuff is
07:01:30 <dons> and fix it
07:01:31 <chessguy> but then, maybe it's just frustration speaking in that i've been teetering on the edge of a deeper understanding of haskell for months
07:01:48 <dons> chessguy, you need a project to hack on!
07:01:52 <Philippa> often the... yeah, that
07:01:58 <Philippa> preferably something reasonably tough
07:01:59 <chessguy> dons, working on one now
07:02:01 <pejo> As long as the subject is somewhat relevant to the channel I think the high level conversations should stay in here.
07:02:10 <ookk> dons, yeah
07:02:21 <chessguy> pejo, nobody has said they shouldn't
07:02:27 <roconnor> Hmm, Haskell actually does have a rule that treats variables beginning with _ as different
07:02:31 <Philippa> pejo: I think using -overflow when it's noticably choking helping newbies isn't necessarily a bad thing so long as people announce it
07:02:37 <roconnor> ``Compilers that offer warnings for unused identifiers are encouraged to suppress such warnings for identifiers beginning with underscore.''
07:02:43 <roconnor> I guess it isn't really a rule
07:02:56 <ookk> dons, but isnt the best think to only write a MutableDouble, then define Vector3 with that and then define Planet with that
07:03:01 <kolmodin> dcoutts: I heard waern talked to you about his haddock.ghc
07:03:15 <ookk> dons, because you dont have to read the whole Vector3 or the whole planet to change a value in it
07:03:24 <dons> ookk, yeah, that's an interesting idea.
07:03:30 <ookk> dons, as you only update position, velocity etc
07:03:33 <Eighty> Saizan: yeah, but then the point of having different underlying data structures would be lost, wouldn't it? i need it so i can implement things efficiently.
07:03:44 <ookk> you dont want to write back everything when you update something
07:03:44 <pejo> Philippa, shrug, that's fine by me too.
07:03:46 <Philippa> interesting, but in practice you do have unboxing-related problems
07:03:53 <dons> i'm not sure the best way. ocaml is impure, so they don't need to treat mutable stuff specially
07:04:23 <Philippa> chessguy: problems I've thought hard about include really serious web app infrastructure and an awful lot of compiler/interpreter/language processor stuff including how to make the code nice. Both're good ways to stretch yourself
07:04:26 <Eighty> Saizan: is there a way so that when the arguments are type A and B, in any order, I can convert them both to A, and use that implementation?
07:04:37 <ookk> dons, when i did it i defined Vector3 and Vector3Ref, on Vector3 i defined + - * and on Vector3Ref i defined += -= :=, Vector3 was purely functional
07:04:38 <Philippa> the web app stuff was interesting because it involved trying to make a lot of dynamic stuff work nicely
07:04:51 <ookk> dons, then i defined readVector3Ref, writeVector3Ref
07:05:01 <chessguy> Philippa, sure, but newbies need to do simple stuff before they can do stuff like that
07:05:04 <dons> ah ok. nice.
07:05:07 <ookk> dons, and a Planet was Planet Vector3Ref Vector3Ref Double
07:05:22 <ookk> dons, and i kept a global list of the planets and all pairs of planets
07:05:27 <dons> ookk, so maybe try again with Ptr Double ?
07:05:36 <Philippa> chessguy: I think we're talking at cross purposes here - those were suggestions for you. And you can take a good crack at them starting from a comparatively small start
07:05:41 <ookk> dons, yeah
07:06:00 <Philippa> I started looking at the language stuff at a stage where I didn't grok monads at all and was missing a lot of H98 features let alone extensions
07:06:02 <dons> this 'mutable' stuff sounds a bit like what Clean does with the unique types
07:06:08 <dons> the way records are tagged as unique
07:06:17 <dons> which we simulate with Ptr
07:06:17 <chessguy> Philippa, ah. well, i have several projects i'm working on which i think are sufficiently stretching me
07:06:26 <ookk> i am not familiar with clean
07:06:39 <Philippa> are they causing you to consider possible language extensions you might want, stuff like that? :-)
07:06:53 <Saizan> class toA b where convert :: b -> A, instance toA A where convert=id, instance toA B where convert (B ..) = ...,   foo a b = let a' = toA a; b' = toA b; in ..?
07:06:55 <Philippa> though I guess the past few years have made it tougher to think up ones you really do want
07:07:01 <Saizan> err
07:07:01 <dons> its haskellish, but with 'uniqueness types' to tag values that may be safely destructively updated.
07:07:11 <chessguy> Philippa, no, because there's still a lot more to the language than i know
07:07:17 <Saizan> s/toA/convert/ in the last two cases
07:08:00 <ookk> dons, i see Clean does very well on the nbody problem
07:08:01 <Philippa> chessguy: I did find that often having thought up the "dream extension" I could find a way to encode it :-) Often a useful exercise, even if you're not Oleg
07:08:21 <dons> ookk, yeah, so understanding their approach would be worthwhile
07:08:22 <chessguy> anyway
07:08:22 <Saizan> Eighty: however with typeOf you can check the type of a value at runtime and make your choices
07:08:29 <dons> perhaps replacing the 'mutable' keyword with Ptr
07:08:56 <dons> and then if that doesn't work, working directly on mutable cells (yes, that's possible...)
07:09:00 <Eighty> Saizan: um, can i still have a different implementation when the arguments are both of type B?
07:09:14 <Eighty> i'd rather avoid runtime checking
07:09:16 <ookk> dons, yeah just write something with Ptr Double
07:09:43 <Philippa> dons: for personal reference, how do you do that?
07:09:45 <pejo> Eighty, are you sure the basic design is that great?
07:10:08 <Eighty> pejo: no
07:10:24 <ookk> !paste
07:10:24 <hpaste> Haskell paste bin: http://hpaste.org/
07:10:27 <chessguy> what i'm working on now is i want some kind of fold-type function that finds the minimum of a list and moves it to the front
07:10:32 <Eighty> i'd just like to know what you'd do if you had, say, a datatype for sparse matrices and for normal matrices and you wanted to multiply them together
07:10:36 <dons> Philippa: define a wrapper over a primop to just write to memory and destrictively update
07:10:39 <hpaste>  ookk pasted "this is what i did" at http://hpaste.org/435
07:10:46 <dons> then be very careful to treat that value as unique
07:10:51 <ookk> dons, thats what i did in a early version, but with slow IORefs
07:11:07 <ookk> dons, but im thinking it might be possible to rewrite with Ptr Double instead
07:11:21 <dons> yeah, sounds good
07:11:34 <dons> then be careful with the inlining, and pay attention to strictness
07:11:59 <Saizan> Eighty: do you find useful to keep them two distinct datatypes? instead of a single datatype with two constructors?
07:12:18 <ookk> dons, the code has the advantage of being readable but it runs in 90s on my machine with n = 20M
07:12:25 <dons> ah ok.
07:12:29 <dons> I think we can do better than that
07:12:32 <ookk> dons, maybe Ptr Double will speed it up dramatically
07:12:39 <dons> yeah, I think so
07:12:51 <dons> and you can take some general hints on writing loops from my version
07:12:53 <ookk> dons, that is why i made the test_cpp and test_hs
07:13:15 <Eighty> Saizan: haha, wow, i'm silly. :) using a single datatype would probably be better
07:13:17 <dons> yeah, the first thing I always do is run the C version, then you know what your upper limit is going to be roughly
07:13:27 <ookk> now i use mapM_ but that is probably suboptimal?
07:13:32 <dons> that's fine
07:13:33 <Eighty> but when you use a recursive datatype with a basis case, what then? i guess you could make a wrapper datatype
07:13:38 <dons> forM_ is usually nicer
07:13:38 <ookk> as i have two global lists
07:13:44 <Eighty> oh well, consider my problem solved :)
07:13:45 <ookk> planets and planetPairs
07:14:04 <ookk> planetPairs for the for i ... for j = i+1
07:14:07 <dons> sounds slow.. :)
07:14:15 <dons> do any other entries do that/
07:14:34 <dons> you need to be careful about cache behaviour, so keeping all your data packed together makes sense
07:14:58 <ookk> the alternative is to figure out the planetPairs everytime
07:15:06 <ookk> or not use mapM_ and write a loop
07:15:12 <dons> yeah, write a loop
07:15:43 <ookk> how much of a performance loss is it to have a function: let f (Planet a b c) instead of let f a b c ... ?
07:15:46 <dons> try to use the same kinds of data structures as C
07:15:52 <hpaste>  chessguy pasted "Can this be generalized to Data.Tree structures?" at http://hpaste.org/436
07:15:57 <dons> probably none, if you have strict fields
07:16:01 <dons> Planet !a !b !c
07:16:11 <dons> will be compiled to a function taking a b c unboxed
07:16:22 <ookk> dons, the first thing to do is Ptr Double i think
07:16:34 <dons> you can check the Core output from ghc (did you see my post on this earlier today to the -cafe?)
07:16:35 <ookk> those lists i will look into if Ptr Double makes any difference
07:17:16 <ookk> dons, -dump-core-simpl?
07:17:31 <dons> -ddump-simpl, yeah
07:17:36 <dons> with coouring
07:17:47 <dons> colour,. grumble wifi 2am
07:18:21 <dons> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022315.html
07:18:23 <lambdabot> Title: [Haskell-cafe] Tricks for making low level haskell hacking easier, http://tinyurl.com/2f2dsc
07:18:46 <dons> ookk, looking at the fannkuch benchmark is another option
07:19:02 <dons> I originally just manually compiled that down to primops ... but with ghc 6.6 we should be able to write that as idiomatic haskell
07:19:30 <ookk> hmm yeah i have to look into that
07:20:50 <ookk> im gonna go about doing the Ptr Double now
07:20:52 <bryanl> http://slashdot.org
07:20:53 <lambdabot> Title: Slashdot: News for nerds, stuff that matters
07:20:55 <ookk> bbl :P
07:25:19 <nornagon> :t all
07:25:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:26:18 <nornagon> > let belong_to a b = True in all (belong_to us) bases
07:26:19 <lambdabot>   Not in scope: `bases'
07:26:41 <nornagon> > let belong_to a b = True in all (belong_to us) bases where bases = ["no chance","to survive"]
07:26:42 <lambdabot>  Parse error
07:27:04 <nornagon> > let belong_to a b = True ; bases = ["no chance", "to survive"] in all (belong_to us) bases
07:27:06 <lambdabot>   Not in scope: `us'
07:27:15 <nornagon> > let belong_to a b = True ; bases = ["no chance", "to survive"] ; us = 1in all (belong_to us) bases
07:27:17 <lambdabot>  True
07:27:18 <nornagon> eek
07:27:24 <nornagon> > let belong_to a b = True ; bases = ["no chance", "to survive"] ; us = 1 in all (belong_to us) bases
07:27:26 <lambdabot>  True
07:27:29 <nornagon> oh, crazy
07:27:33 <nornagon> anyway, done.
07:28:10 <paolino> > mapM (flip M.lookup $ fromList [(0,'a')]) [0,1]
07:28:11 <lambdabot>   Not in scope: `fromList'
07:28:17 <chessguy> ?src foldr
07:28:18 <lambdabot> foldr k z xs = go xs
07:28:18 <lambdabot>     where go []     = z
07:28:18 <lambdabot>           go (y:ys) = y `k` go ys
07:28:33 <paolino> > mapM (flip M.lookup $ M.fromList [(0,'a')]) [0,1]
07:28:34 <lambdabot>   add an instance declaration for (Show (m [Char]))
07:29:51 <paolino> > mapM (flip M.lookup $ M.fromList [(0,'a')]) [0,1] :: Maybe [Char]
07:29:52 <lambdabot>  Nothing
07:30:19 <paolino> > mapM (flip M.lookup $ M.fromList [(0,'a')]) [0] :: Maybe [Char]
07:30:21 <lambdabot>  Just "a"
07:31:22 <Saizan> :t Data.Map.lookup
07:31:24 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
07:32:14 <paolino> > flip M.lookup $ M.fromList [(0,'a')] :: [Char]
07:32:15 <lambdabot>  Couldn't match `[Char]' against `k -> m Char'
07:33:17 <paolino> > M.lookup 0 $ M.fromList [(0,'a')] :: [Char]
07:33:18 <chessguy> man
07:33:18 <lambdabot>  "a"
07:33:29 <chessguy> i wouldn't have thought that implementing a heap in haskell would be all that hard
07:34:30 <mdmkolbe> Is there anyway to make equality of infinate datastructures terminate?  For example "let ones = 1:ones in ones == ones"
07:34:57 <paolino> chessguy: how is it different from a list ?
07:35:18 <chessguy> paolino, uh. it's not a list
07:35:28 <paolino> a heap != stack
07:35:35 <chessguy> no
07:36:00 <chessguy> a heap gives you access to the min/max element in constant time
07:36:16 <chessguy> deleteMin in log n time
07:36:46 <chessguy> and add in log n time, i think
07:36:55 <paolino> a tree ?
07:37:29 <paolino> tracking first and last leaf ?
07:37:58 <chessguy> it's a tree in which any node is always less than its children
07:38:02 <chessguy> (for example)
07:38:09 <Saizan> why there's no IArray (IOToDiffArray IOUArray) Bool instance?
07:38:11 <chessguy> that would be a min heap
07:38:37 <paolino> Saizan it's just missing :/
07:40:10 <Saizan> i'll add it in my source..
07:40:53 <ookk> ?paste
07:40:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:41:05 <paolino> that's hacking! And send patches to the core developers
07:41:12 <hpaste>  ookk pasted "nbody" at http://hpaste.org/437
07:42:12 <ookk> dons, its faster with Ptr Double but not that much
07:42:22 <ookk> dons, i guess i have to write loops to
07:42:50 <xic> dons: have you ever thought about a haskell binding to GNU lightning, or another JIT library? or a JIT system implemented in haskell?
07:43:30 <lucio_> helllo people.. why doesnt this work? "data Bar1=B1{z::Int};data Bar2=B2{z::Int}"? how do you usually work around it?
07:43:46 <lucio_> error:  Multiple declarations of `Main.z'
07:44:01 <allbery_b> field names are field accessor functions
07:44:05 <chessguy> uhh, use something other than z the second time?
07:44:09 <xic> lucio_: instead of z, use b1Z and b2Z
07:44:35 <Saizan> there's no way to use a function that's not exported by a module, right? (from another module)
07:44:58 <xerox> Saizan: right.
07:45:06 * paolino hopes not
07:45:11 <pjd> xic: lightning is more like a multi-platform run-time assembler/machine-code generator, not a JIT
07:45:39 <chessguy> xerox!
07:45:50 <pjd> it could be used as the back-end of a JIT
07:45:52 <xerox> chessguy!
07:46:14 <velco> alice ml use it for their jit
07:46:23 <lucio_> use something else than z? thats the best that can be done?
07:46:26 <pjd> s/JIT/JIT compiler/ (damn nouning)
07:46:32 <TomMD> Saizan: Perhaps if you get a function pointer and muck with it...
07:46:41 <lucio_> dogs have legs and chairs have legs :)
07:46:48 <allbery_b> lucio_: you can also do things with typeclasses if you must
07:46:55 <lucio_> i dont want to go around calling them dog_legs
07:46:58 <darrint> Since I saw liskell on reddit, I've seen very little written about it. Is there any news or new docs written?
07:47:01 <paolino> ook, seeing signatures like energy :: IO Double is a bit awful
07:47:07 <roconnor> moveTo, lineTo :: Point -> C.Render ()
07:47:10 <chessguy> lucio_, but if you talk about legs, you have to somehow say which kind you're taling about
07:47:18 <Stinger> @seen dcoutts
07:47:19 <roconnor> I didn't realize you can do type declarations like that!
07:47:19 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I last heard dcoutts speak 4h 6m 1s ago.
07:47:24 <allbery_b> record syntax is one of those areas where everyone knows there are deficiencies but nobody has a proposal that satisfies everyone
07:47:51 <chessguy> allbery_b, OOP!
07:47:55 <pjd> roconnor: it's just like IO ()
07:48:08 <Philippa> chessguy: that's guaranteed to satisfy nobody
07:48:12 <GsD_CeleborN> dconutts_: hi
07:48:15 <GsD_CeleborN> dconutts: hi
07:48:31 <GsD_CeleborN> [dcoutts_]: hi
07:48:50 <xerox> donuts!
07:49:10 <chessguy> hey xerox, you're my Tree expert. you gotta help me with this
07:49:20 <chessguy> http://hpaste.org/436
07:49:30 <roconnor> @hoogle color
07:49:31 <lambdabot> Text.Html.color :: String -> HtmlAttr
07:49:31 <lambdabot> System.Win32.Info.cOLOR_ACTIVEBORDER :: SystemColor
07:49:31 <lambdabot> System.Win32.Info.cOLOR_ACTIVECAPTION :: SystemColor
07:49:36 <roconnor> @hoogle colour
07:49:37 <lambdabot> No matches found
07:49:42 <paolino> ook, is IO much faster than using ST ?
07:50:02 <roconnor> is there a library of colour names -> RGB values?
07:50:34 <lucio_> thanks for the input
07:50:36 <lucio_> gotta run
07:50:43 <lucio_> ill be back later with more questions
07:50:44 <dons> paolino: no, ST and IO should be identical
07:51:28 <dons> @tell ookk actually, should't my hort C loop be comparable and fair with gcc, since gcc sets -fno-float-store (i.e. -fexcess-precision) by default? so they're the same test
07:51:28 <lambdabot> Consider it noted.
07:51:41 <paolino> so the problem is using Ptr can't be done under ST ?
07:52:11 <pejo> chessguy, record Colorpoint < Point = col :: Color!
07:52:22 <GsD_CeleborN> anybody use gtk with opengl here? beyond dcoutts ?
07:52:30 <chessguy> pejo, huh?
07:52:49 <pejo> chessguy, oop!
07:52:54 <xic> GsD_CeleborN: i've done it in other languages
07:53:07 <chessguy> dude, that was like 10 minutes ago
07:53:34 <GsD_CeleborN> I need help with haskell gtk
07:53:59 <xerox> chessguy: yeah, I think so. Data.Tree has a list of child (not just two children like a binary tree) that you ought to sort.
07:54:15 <xic> GsD_CeleborN: i've also used gtk2hs quite a bit :)
07:54:16 <GsD_CeleborN> Glut has KeyboarCallback
07:54:24 <chessguy> xerox, ugh
07:54:29 <mdmkolbe> Is there anyway to test the equality of infinate datastructures?  For example "let ones = 1:ones in ones == ones" will never terminate but if Haskell had a ptr equality test it would require only one compare.
07:54:29 <chessguy> i don't really want to sort
07:54:30 <GsD_CeleborN> [xic]: ok
07:54:33 <dons> paolino: the ST stuff compiles down to Ptr, but Ptr is a bit more flexible (and more dangerous)
07:54:35 <GsD_CeleborN> [xic]: in GLut
07:54:36 <dons> since its just the raw machine
07:54:55 <chessguy> xerox, i'm trying to get heapify in log n time
07:55:12 <GsD_CeleborN> [xic]: has KeyboardMouse function
07:55:37 <xerox> chessguy: you traverse the tree, swapping branches so that the left ones contain values less than the right ones?
07:55:40 <GsD_CeleborN> [xic]: in gtk have somthing similar ?
07:56:19 <chessguy> xerox, it's a priority queue: the only constraint is that any node have a smaller value than its immediate children
07:57:00 <xerox> chessguy: alright.
07:57:09 <xerox> I'm not sure what heapify mean.
07:57:30 <chessguy> heapify assumes it's true except for the root node, and sort of percolates the root value down through the tree to its proper place
07:57:39 <xic> GsD_CeleborN: yeah, but i don't remember how
07:57:49 <xerox> I see.
07:57:54 <hpaste>  dons pasted "Why is this Haskell code faster than this C code?" at http://hpaste.org/438
07:57:58 <xerox> That's doable.
07:58:08 <dons> hmm, can anyone explain why this Haskell program beats C/gcc? ^^
07:58:27 <dons> Am I cheating somewhere?
07:58:42 <GsD_CeleborN> [xic]: do you have any example, the gtk with opengl ?
07:58:59 <GsD_CeleborN> [xic]: for me see
07:59:10 <Syzygy-> GsD_CeleborN: Drop the color stuff.
07:59:12 <xic> GsD_CeleborN: gtk2hs comes with a gtk and opengl example
07:59:14 <Syzygy-> Please
07:59:53 <Philippa> dons: you probably want to ask a Simon, or look at the asm
08:00:08 <emk> dons: I've posted a draft of the rewrite rule tutorial:
08:00:11 <emk> http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance
08:00:14 <dons> cool
08:00:20 <Philippa> how much faster is it?
08:00:20 <dons> i'll have to have a look in the morning
08:00:26 <dons> Philippa: aout 5-10%
08:00:30 <emk> dons: Thanks for all the help!
08:00:47 <Philippa> hmm. Dumb question: how do they compare if you skip the printf?
08:01:35 <Philippa> not that it should matter...
08:01:47 <dons> huh
08:01:49 <dons> $ time ./a.out
08:01:50 <dons> ./a.out  0.34s user 0.01s system 101% cpu 0.340 total
08:02:13 <dons> the C program runs 3x faster.
08:02:15 * dons boggles
08:02:40 <mdmkolbe> In the C code you may want to "return (int)x+y" so gcc knows that x and y are used values
08:02:49 <velco> here gcc eveluated all at compile time :(
08:02:53 <xerox> chessguy: may you provide a sample tree?
08:03:02 <chessguy> xerox sure
08:03:12 <Philippa> mdmkolbe: passing them into printf should be good enough for that, no?
08:03:22 <velco> yes, it's good enough
08:03:26 <dons> mdmkolbe: ah yes, good idea
08:03:30 <mdmkolbe> Philippa: you are correct, but once the printf is removed ...
08:03:35 <Philippa> point
08:03:58 <dons> yeah,, ghc still beats gcc once I do that
08:04:49 <chessguy> heapify Branch 13 (Branch 4 (Leaf 10) (Leaf 8)) (Branch 5 (Leaf 17) (Leaf 99)) == Branch 4 (Branch 8 (Leaf 10) (Leaf 13)) (Branch 5 (Leaf 17) (Leaf 99))
08:04:49 <velco> compile with gcc -O3 -fomit-frame-pointer -mss2 -mfpmath=sse :)
08:05:11 <dons> I was! oh, not the frame pointer
08:05:13 <chessguy> s/heapify/heapify $
08:05:35 <dons> ghc still wins
08:05:52 <dons> gcc -O3 -ffast-math -mfpmath=sse -msse2 t.c -o a.out -std=c99 -fno-float-store -fomit-frame-pointer
08:06:02 <mdmkolbe> dons: if you go out to largeer numbers of iterations, does this hold up?  What if you take the iteration count from a command line argument to pevent the compiler from precomputing anything?
08:06:50 <velco> ah, indeed
08:07:30 <mdmkolbe> dons: there is a small difference in the code.  C: "i <= 100000000" will do one more iteration than Haksell: "i == 100000000 = printf ..."
08:07:46 <mdmkolbe> dons: not that it will make a difference
08:07:58 <dons> for 10x larger, C just wins, ./a.out  10.04s user 0.00s system 98% cpu 10.190 total
08:08:07 <dons> versus./A  10.67s user 0.01s system 99% cpu 10.691 total
08:09:03 <dons> the main loop in the ghc program is only 11 assemby instructions
08:09:44 <mdmkolbe> dons: paste?
08:10:27 <hpaste>  dons annotated "Why is this Haskell code faster than this C code?" with "asm" at http://hpaste.org/438#a1
08:11:03 <velco> gcc still folds everything here
08:11:07 <dons> note the terribly indirect jump!
08:12:59 <dons> ghc++
08:13:11 <dons> so does anyone else get the same result?
08:13:15 <dons> does ghc beat gcc here?
08:14:28 <dons> I declare that numerics aren't so shabby in ghc
08:15:18 <mdmkolbe> dons: C: 0.851s, Haskell: 1.165s
08:15:21 <chessguy> dons, want me to try on a 64-bit arch?
08:15:36 <dons> mdmkolbe: ah interesting!
08:15:38 <dons> which gcc?
08:15:54 <mdmkolbe> ghc 6.6, gcc 3.4.6 20060404 (Red Hat 3.4.6-3)
08:15:58 <dons> i've a fairly old gcc 3.3.5
08:16:06 <dons> on a pentium M
08:16:18 <dons> still, 1.165s, not too bad.
08:16:19 <velco> gcc 4.1.2 evaluates it at compile time
08:16:30 <dons> tricky
08:16:36 <dons> does it take 1s to evaluate it/
08:16:44 <xerox> chessguy: instance Eq a => Eq (Tree a) where x == y = value x == value y -- is this really wanted?
08:16:51 * mdmkolbe goes to try it w/ icc
08:16:57 <dons> good idea
08:17:23 <Syzygy-> velco: Really? Coool.
08:17:26 * mdmkolbe has to find it first though
08:17:34 <chessguy> xerox, yes, i want to compare trees by their root value
08:18:39 <Maddas> hrm, fink must have installed ghc wrong
08:18:44 <velco> what bugs me that *I* can't evaluate it at compile time :(
08:19:58 <hpaste>  chessguy annotated "Why is this Haskell code faster than this C code?" with "gcc crushes ghc" at http://hpaste.org/438#a2
08:20:36 <chessguy> xerox, unless you have a better suggestion
08:20:46 <velco> oh, indeed, the loop body becomes z = 1/3.; y = 3.
08:21:26 <dons> chessguy: the compile time eval.
08:21:31 <dons> so that's like using TH to do the same thing.
08:22:12 <chessguy> oh, you mean the 3.33333?
08:22:14 <dons> so that doesn't count ;)
08:22:25 <emk> Are there any good Haskell versus C benchmarks that show off what rewrite rules can do?
08:22:49 <dons> emk, hmm. yes, in my stream fusion paper
08:23:29 <emk> Cool! Is that the same as the ByteString paper?
08:23:56 * emk googles
08:24:09 <dons> emk, yeah.
08:24:20 <dons> well, not sure if they're 'good' benchmarks :-)
08:24:25 <dons> they're brief
08:24:33 <emk> Well, I'm linking to those already, so that's good.
08:24:38 <SamB> so?
08:24:47 <SamB> C does worse the longer your program gets, does it not?
08:24:58 <emk> Is there anything in the shootout which is currently worth pointing to?
08:25:10 <mdmkolbe> dons: ICC is pre computing, I'm going to try reading the counter from argv
08:25:19 <SamB> oooooh
08:25:22 <SamB> neato
08:25:28 <SamB> ICC is precomputing but GHC is not?
08:25:43 <mdmkolbe> SamB: yes
08:26:23 <dons> yeah, you have to code that in TH if you wanted it done statically
08:26:59 <xerox> chessguy: it's not a traverse, hmm.
08:27:10 <chessguy> xerox, correct
08:27:13 <velco> would it change the benchmark if you change the constants to 3.1 and 9.1, for example ?
08:28:50 <xerox> chessguy: you might try writing a fold, after having instantiated Tree as a Monoid.
08:29:14 <chessguy> xerox, you mean Data.Tree
08:29:17 <dons> velco: nope
08:29:19 <dons> same result
08:29:20 <chessguy> right?
08:29:35 <mdmkolbe> dons: icc: 0.001s
08:30:13 <xerox> chessguy: I think that writing that for your binary tree is a good step, then apply what learned to write the Forest one
08:30:42 <dons> mdmkolbe: hehe
08:31:00 <chessguy> sigh. i don't even know what a monoid is
08:31:09 <dons> so it worked out some clever transform?
08:31:22 <velco> ghc beats gcc here
08:31:28 <dons> mdmkolbe: i wonder what setting -pgmc=icc would do
08:31:41 <dons> so it used icc to try to compile the haskell code
08:31:46 <dons> i don't know if anyone's done this before...
08:31:59 <dons> velco: yeah, seems so!
08:33:07 <velco> 1.3 vs. 1.8
08:33:16 <chessguy> ?src Monoid
08:33:17 <lambdabot> class Monoid a where
08:33:17 <velco> I'm so glad :D
08:33:17 <lambdabot>     mempty  :: a
08:33:17 <lambdabot>     mappend :: a -> a -> a
08:33:17 <lambdabot>     mconcat :: [a] -> a
08:34:30 <emk> chessguy: It's basically an algebra with a 0 and a +.
08:35:41 <chessguy> hmm, i'm not sure Tree should be a monoid
08:35:52 <chessguy> it's not entirely clear what the addition of two trees should look like
08:36:14 <xerox> It's also a monad, but you have many ways to write such instnace.
08:36:16 <xerox> *instance
08:36:20 <Philippa> it's probably more accurate to say that there're many monoids on trees
08:37:08 <Z03> general question, what are the main development areas that make use of haskell ?
08:37:16 <velco> well, I was missing -ffast-math
08:37:47 <dons> Z03,can you be more specific?
08:37:59 <dons> are you asking what domains haskell is primarily used in at the moment?
08:38:00 <xerox> It's arbitrary as your equality (or ordering) instance.
08:38:00 <velco> gcc 0.64, ghc 1.34
08:38:13 <dons> oh, huh. i wonder what my machine is doing then.
08:38:18 <Anon4888> haskell was developed as a language for lambdabot
08:38:29 <Z03> dons: where is haskell usually used ? could you give me examples of applications
08:38:30 <dons> velco: using what flgas?
08:39:01 <velco>  -O3 -ffast-math -fomit-frame-pointer -msse2 -mfpmath=sse
08:39:25 <dons> Z03, its a general purpose language, used primarily for building standalon programs
08:39:37 <dons> often commpilers, but a wide range of other apps these days. check haskell.org's libraries and applications page
08:39:42 <ndm> Z03, haskell is more used by users, than for applications - i've written web apps, gui's, compilers, analysis tools
08:39:43 <velco> the difference with no fast-math was that there was a division in the loop
08:40:07 <ndm> Z03, but generally Haskell people do stuff in Haskell, and no one else uses it - even where they should
08:40:21 <dons> velco: interesting, so ghc still wins on my machine with those flags
08:40:33 <dons> ndm, that's the spirit!
08:40:39 <chessguy> well, i only ordered them that way so that i could do something like minimum [x,y,z] for three threes
08:40:48 <chessguy> without comparing the whole structure
08:40:49 <dons> though pugs and darcs, the main haskell apps in terms of visibility, are written not by haskell peole
08:41:17 <Philippa> or at least far from exclusively
08:41:25 <xic> man parsec is hard
08:41:25 <Z03> ndm: I'm just find functional programming difficult to learn .. that answers my question, thx :)
08:41:27 <chessguy> how does instantiating Tree as a monoid help with writing a fold?
08:41:32 <Z03> I just*
08:41:38 <chessguy> (for the heapify)
08:41:48 <ndm> Z03, once you've learnt Haskell, you will resent having to use C :)
08:41:49 <pejo> Z03, imperative programming is hard too.
08:42:03 <xerox> chessguy: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html#t%3AFoldable
08:42:05 <lambdabot> http://tinyurl.com/23pc9l
08:42:09 <dons> if you learnt haskell first, you'd find C bizarre and broken, I think.
08:42:13 <Z03> ndm: 2nd time I hear that :)
08:42:13 <Philippa> xic: hard? Parsec's got to be the easiest way I've written parsers so far... what're you doing?
08:42:46 <dons> Z03, you got a good tutorial?
08:42:51 <dons> ?where yaht
08:42:52 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
08:42:55 <dons> ^^ is a good one
08:42:57 <xerox> chessguy: Data.Tree has got Functor, Foldable, Traversable, Typeable. The last two are excluded, Functor is also not what you want, Foldable would be the only way to write a generic function, if you don't count writing your own classes.
08:43:04 <dons> ?users
08:43:04 <lambdabot> Maximum users seen in #haskell: 322, currently: 306 (95.0%), active: 49 (16.0%)
08:43:05 <hpaste>  velco annotated "Why is this Haskell code faster than this C code?" with "how gcc 4.1 compiles it" at http://hpaste.org/438#a3
08:43:08 <Z03> dons: not really.. anything u can recommend ?
08:43:17 <dons> yeah, YAHT, http://darcs.haskell.org/yaht/yaht.pdf
08:43:22 <dons> and the haskell wikibook
08:43:24 <chessguy> xerox, i don't see how all this helps with heapify though
08:43:26 <dons> found on haskell.org's front page
08:43:30 <xic> Philippa: well i've never written a parser before :) i'm trying to parse a string of the form: "regular text but double braces {{ has.special }} meaning"
08:43:54 <xerox> chessguy: you can also port heapify on Data.Tree non generically, you asked for generalization
08:43:55 <Z03> thx dons :)
08:44:14 <xic> Philippa: i want to end up with [Either String [String]]
08:44:18 <Philippa> xic: look at manyTill and relatives?
08:44:26 <chessguy> non generically?
08:44:29 <xic> Philippa: thanks, i'll check out manyTill!
08:44:41 <xerox> chessguy: that is, write import Data.Tree and then the definition of heapify
08:44:43 <Philippa> that'll let you eat many chars 'til you find a {{
08:45:17 <chessguy> i want to write heapify that does the same thing except its type is (Ord a) => Data.Tree a -> Data.Tree a
08:45:18 <dons> yeah, gcc 4 really does a better job there
08:45:26 <dons> that loop is much much nier
08:45:29 <dons> grr
08:45:32 * dons kills wifi
08:46:04 * pejo gives dons a cable
08:46:32 <xerox> chessguy: ah, you just have problems writing that function?
08:46:39 <chessguy> tes
08:46:40 <chessguy> yes
08:46:41 * SamB wonders how electricsheep works
08:47:42 <pitecus> Can I ask a very naive question? I compile a hello world program in one linux machine and try to run it on another (same architecture afact) and it output a "floating point exception"
08:48:07 <SamB> pitecus: that doesn't sound very naive to me
08:48:19 <SamB> that sounds like "WTF!"
08:48:46 <SamB> what does "uname -a" say on each?
08:48:57 <atsampson> when you say same architecture, is it the same type of CPU? (for example, is it trying to use SSE/3DNow instructions that the second machine doesn't support, or something?)
08:49:16 <gotaku> I hate the choice of variable names in the State instance of MonadState... it uses 's' for everything.
08:49:27 <pitecus> Linux pg-219 2.6.18-1.2849.fc6 #1 SMP Fri Nov 10 12:45:28 EST 2006 i686 i686 i386 GNU/Linux
08:49:34 <pitecus> Linux zag.computing.dcu.ie 2.6.12-1.1381_FC3 #1 Fri Oct 21 03:46:55 EDT 2005 i686 i686 i386 GNU/Linux
08:50:07 <SamB> two "i686"s?
08:50:12 <SamB> wierd.
08:50:34 <chessguy> gotaku, welcome to Haskell. the language you *know* is academic because everything's got such terrible names
08:50:44 <SamB> which one is it crashing on?
08:50:52 <pitecus> the second one
08:50:57 <SamB> okay...
08:51:11 <SamB> I don't suppose you can build the program on the second one?
08:51:40 <pitecus> i can actually but i was wondering why that happens
08:52:48 <SamB> maybe that kernel is buggy? who knows...
08:53:06 <pitecus> hmm
08:53:30 <chessguy> pitecus, out of sheer morbid curiosity, have you tried building on the second and running on the first?
08:53:53 <pitecus> chessguy, no, i'll do it now
08:55:44 <pitecus> ok so it works the other way round...
08:56:42 <bakert> chessguy, no no not terrible names - head and tail not car and cdr.  that alone exempts haskell from scorn!
08:58:12 <bakert> also dig the fact that head, tail, init and last all have four letters.  glorious!
08:58:27 * pjd throws in up and dn
08:58:41 <chessguy> ?hoogle up
08:58:42 <lambdabot> Data.HashTable.update :: HashTable key val -> key -> val -> IO Bool
08:58:42 <lambdabot> Data.IntMap.update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
08:58:42 <lambdabot> Data.IntMap.updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
08:58:49 <bakert> up and dn???
08:58:59 <pjd> instead of car and cdr, for working with pairs
08:59:07 <pjd> not quite for lists
09:00:42 <pjd> i'd consider head (maybe fore) and rest, over head and tail :)
09:00:59 <chessguy> xerox, so is writing heapify :: Data.Tree a -> Data.Tree a any easier?
09:01:27 <Daveman> :)
09:01:35 <pjd> (..for lists, i'd consider...)
09:05:23 <hyrax42_> where does one get docs on stm from?
09:05:35 <hyrax42_> ?docs Control.Concurrent.STM
09:05:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
09:05:40 <hyrax42_> seems rather poor
09:06:07 <dons> they're actually in gHC.Conc
09:07:07 <dons> due to a haddock bug
09:07:14 <hyrax42_> ?docs GHC.Conc
09:07:14 <dons> the next version generated should contain the full docs
09:07:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html
09:07:48 <dons> probably the best references arethe wiki (search for 'Concurrency'), and the stm papers available from the 'Research' link on haskell.org
09:08:05 <emk> hyrax42_: Also, search for
09:08:15 <xic> there's also that STM video starring spj
09:08:17 <emk> "Composable Memory Transactions". It's a killer paper.
09:08:31 <hyrax42_> xic: I've seen the video, it's hardly a tutorial
09:08:34 <hyrax42_> though very cool
09:08:52 <hyrax42_> emk: have it, wasn't sure if it was a good place to start or not
09:08:54 <dons> the reason the docs don't appear, btw, is that haddock doesn't like exporting docs across package boundaries
09:09:05 <hyrax42_> thanks all though
09:09:09 <dons> so getting from base/GHC.Conc to stm/* is beyond the old haddock
09:09:12 <emk> hyrax42_: Well, it worked for me. :-)
09:09:13 <sjanssen> hyrax42_: I second emk's suggestion
09:09:24 <SamB> dons: kinda sad :-(
09:09:27 <hyrax42_> emk, sjanssen: I'll printit off then
09:09:57 <emk> @seen syntaxfree
09:09:58 <lambdabot> syntaxfree is in #haskell-blah, #haskell-overflow and #haskell. I last heard syntaxfree speak 2h 12m 26s ago.
09:10:12 <xic> Philippa: how do i not absorb the "{{" in manyTill?
09:10:36 <syntaxfree> me?
09:10:47 <emk> syntaxfree: I'm working on a map fusion tutorial.
09:11:04 <syntaxfree> yay!
09:11:15 <hyrax42_> emk: sounds cool
09:11:16 <emk> syntaxfree: http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance
09:11:49 <emk> It was pretty fun to get rewrite rules working.
09:12:13 <emk> It's this kind of thing which makes Haskell seem so worthwhile...
09:12:16 <augustss> howdy
09:13:14 <dons> emk, you going to drop that by reddit/
09:13:55 <emk> dons: Feel free. I generally don't self post to aggregator sites.
09:14:17 <dons> but i thought reddit was a community ;)
09:15:05 <emk> Anything I should fix before it gets more publicity?
09:15:29 <dons> just reading through
09:15:39 <augustss> emk: you might want to reference Ralf Lämmel's MapReduce paper
09:16:18 <pejo> emk, Wadler's deforestation paper maybe, for the interested reader?
09:16:40 <dons> i'd probably make those tree nodes strict in the elements
09:17:05 <chessguy> ?hoogle reduce
09:17:06 <lambdabot> No matches found
09:17:09 <dons> though its not critical for this article
09:17:16 <dons> ?hoogle fold
09:17:17 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
09:17:17 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
09:17:17 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
09:17:24 <dons> ?hoogle+
09:17:24 <lambdabot> Data.Set.fold :: (a -> b -> b) -> b -> Set a -> b
09:17:24 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
09:17:24 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
09:17:26 <emk> augustss, pejo, dons: Working on it. :-)
09:17:46 <augustss> dons: is the map fusion valid when the elements are strict?
09:18:06 <dons> oh, good question
09:18:31 <dons> here, I think so
09:18:33 <augustss> it might be ok, but i'd have to convince myself
09:18:44 <dons> since we're not dropping in undefineds to short circuit loops
09:18:52 <dons> like the head build/foldr rules does
09:18:56 <dons> which does break on a strict list
09:19:17 <dons> emk, some binary tree examples, http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
09:19:19 <emk> dons: I think I'll leave it lazy in this article, if only to avoid explaining the tradeoffs. :-)
09:19:20 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/zx84m
09:19:25 <dons> much the same, but strict nodes.
09:19:28 <pjd> is it possible for ghc to infer that particular map fusion automatically?
09:19:32 <dons> yeah, for your 1M node tree in practice
09:20:08 <pejo> augustss/dons, is it obvious why build/foldr is invalid for a strict list?
09:20:16 <pjd> by something like declaring the tree as a Functor instance?
09:20:17 <pejo> Uh, buid/foldr rule, even.
09:20:42 <dons> "head/build"    forall (g::forall b.(a->b->b)->b->b) .
09:20:43 <dons>         head (build g) = g (\x _ -> x) badHead
09:20:53 <augustss> pejo: it's not obvious, until you know :)
09:21:05 <dons> yeah, its not obvious. if you hit it though, it is
09:21:11 <dons> since your happy program suddenly termintes
09:21:39 <roconnor> > log 40
09:21:40 <lambdabot>  3.6888794541139363
09:22:00 <augustss> > exp (log 40)
09:22:02 <lambdabot>  40.0
09:23:12 * emk adds in suggested papers, benchmarks
09:23:25 <augustss> pjd: many things are possible, but it's not been done a real compiler, afaik
09:23:25 <dons> http://programming.reddit.com/info/13uwu/details
09:23:52 <gotaku> dons: Anyone doing something about the n-body bench?
09:23:56 <roconnor> I'm editing the haskell charting program; is there a better way of testing my changes without doing Setup.hs install?
09:24:03 <pjd> augustss: so ghc's list fusion is essentially all special?
09:24:10 <pjd> list map fusion, even
09:24:11 <dons> gotaku: yeah, I wrote one today, its 1.8x slower than C. and in the queue
09:24:13 <augustss> pjd: it sure is
09:24:18 <dons> gotaku: check the Shootout page on the wiki
09:24:22 <dons> ?wiki Shootout
09:24:22 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
09:24:26 <dons> gotaku: you want to fix fannkuch?
09:24:29 <gotaku> dons: Great.
09:24:29 <dons> that's the last one to do now
09:24:42 <pjd> is it possible to write a rewrite rule generically in terms of Functor? :)
09:25:09 <pejo> dons, was that head/build snippet an explaination?
09:25:13 <dons> fmap f . fmap g = fmap (f .g ) ?
09:25:20 <chessguy> ?instance functor
09:25:21 <lambdabot> Maybe you meant: instances instances-importing
09:25:23 <sjanssen> pjd: you could write the rule "fmap f (fmap g xs) =  fmap (f . g) xs"
09:25:25 <SamB> is it wise?
09:25:25 <chessguy> ?instance Functor
09:25:25 <lambdabot> Maybe you meant: instances instances-importing
09:25:26 <gotaku> dons: No, that's alright.
09:25:33 <chessguy> ?instances Functor
09:25:35 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:25:46 <pjd> sjanssen: how would it know to match on Functor?
09:25:53 <dons> pejo: sorry, that's the rule that fails if your list is strict , but its too late here for me to unfold the code and explain it.
09:25:56 <dons> ?time
09:25:58 <SamB> pjd: types!
09:26:00 <lambdabot> Local time for dons is Sun Feb 11 04:24:55 2007
09:26:05 <sjanssen> pjd: the rule matcher is smart
09:26:18 <sjanssen> actually, it's a little dumb
09:26:19 <dons> yeah, the types have to match. (you're matching AST code)
09:26:37 <pejo> dons, ah, I'll figure it out, cheers.
09:26:42 <pjd> but how does it know you're talking about Functor's fmap?
09:26:53 <SamB> because that is the one in scope
09:27:03 <gotaku> dons: They need to change the default pairing of GHC and JDK... it's really unfair.
09:27:12 <dons> heh. poor JDK
09:27:15 <SamB> pairing?
09:27:22 <augustss> pjd: declaring something to be a function doesn't help the compiler really.  Because it's can;t check that your definition makes sens and it really is a functor.
09:27:23 <dons> http://shootout.alioth.debian.org/gp4/haskell.php
09:27:24 <pjd> ah, so rewrite rules are only in terms of their current scope
09:27:24 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ...
09:27:33 <augustss> s/function/Functor/
09:28:01 <augustss> What's happened to my spelling and typing? :)
09:28:05 <sjanssen> the full pragma would be: {-# RULES "fmap/fmap fusion" forall f g xs. fmap f (fmap g xs) = fmap (f . g) xs #-}
09:28:28 <pjd> augustss: i realize that, but i would probably count that in the same bin as breaking purity via unsafe*
09:28:49 <pjd> the fix would be to remove the Functor declaration, not the optimization
09:29:02 <sjanssen> pjd: RULES can in fact change the meaning of your programs
09:29:05 <augustss> pjd: yes, you could have a pramga MAKE_UNSAFE_ASSUMPTIONS_ABOUT_INSTANCES
09:29:19 <dons> you can do arbitrary evil things with rules
09:29:27 <dons> as long as the type is preserved
09:29:37 <pjd> right
09:29:59 <dons>  RULE reverse . reverse $ xs == xs -- nice rule, bad for infinite lists
09:30:05 <sjanssen> pjd: because proving that the transformation is correct is intractable (undecidable?)
09:30:09 <augustss> I wonder how many programs would break if GHC assumed things declared as monads were actually monads ;)
09:30:17 <dons> heh
09:30:20 <dons> we should test that!
09:30:22 <SamB> well, QuickCheck might
09:30:39 <augustss> RULE map f x = []
09:30:47 <dons> that's a good rule
09:30:49 <augustss> good for speed!
09:30:52 <dons> life would be a lot easier
09:31:18 <jcreigh> wow, I had no idea the RULES pragma existed. That's awesome.
09:31:19 <pjd> sjanssen: yes, but it shouldn't be unreasonable to expect the user to ensure Functor instances are correct
09:31:21 <augustss> and just like the reverse rule it's true for some x
09:31:25 <SamB> hmm... but can you fuse [] with anything?
09:31:31 <Pastorn> yo
09:31:32 <dons> RULE unsafePerformIO x = unsafePerformIO (do print "Don't do this!"; exitImmediately)
09:31:43 <augustss> I like!
09:31:47 <pjd> in the same way that implementing Monad correctly isn't compiler-checked
09:32:29 <pjd> or the purity of foreign functions, probably
09:32:33 * LoganCapaldo wonders if exitImmediately uses unsafePerformIO
09:32:39 <pjd> (i don't know Haskell's FFI)
09:32:54 <augustss> LoganCapaldo: it doesn't have to.  it's in the IO monad
09:33:00 <LoganCapaldo> duh
09:33:03 <sjanssen> pjd: ffi safeness is all programmer's honor
09:33:15 * LoganCapaldo bangs head against a monadic wall repeatedly
09:33:37 <Pastorn> could someone please make me an example of a function using "case of" at paste.lisp.org? I want to compare two lists and count the amount of elements that are the same and at the same place in the list
09:33:42 <augustss> perhaps we should have safePerformIO
09:33:55 <augustss> safePerformIO x = x
09:34:00 <pjd> sjanssen: so are Monad/Functor correctness, no?
09:34:06 <dons> heh
09:34:06 <Philippa> I was about to define it as id :-)
09:34:11 <sjanssen> pjd: that is correct
09:34:15 <pjd> or are there valid uses of non-conforming instances?
09:34:27 <Philippa> depends on the definition of "conformance"
09:34:31 <LoganCapaldo> @hoogle (Num a) => (b -> Bool) -> [b] -> a
09:34:31 <Philippa> arguably, IO isn't a monad
09:34:32 <lambdabot> No matches, try a more general search
09:34:41 <xic> earlier, Cale suggested that unsafePerformIO be renamed to simonPerformIO and you are only allowed to use it if your name is simon
09:34:42 <sjanssen> there's a mailing list thread that claims IO isn't a monad
09:34:42 <LoganCapaldo> @hoogle count
09:34:43 <lambdabot> Text.ParserCombinators.ReadP.count :: Int -> ReadP a -> ReadP [a]
09:34:43 <lambdabot> Text.ParserCombinators.Parsec.Combinator.count :: Int -> GenParser tok st a -> GenParser tok st [a]
09:34:43 <lambdabot> Test.HUnit.Base.counts :: State -> Counts
09:34:45 <augustss> pjd: IO isn't a monad...
09:34:52 <vincenz> dons: doesn't that recurse endlessly?
09:35:12 <Philippa> xic: that's actually a long-running joke
09:35:28 <pejo> xic, isn't Lennart alpha-convertible to Simon?
09:35:44 <xic> Philippa: hm.... sad. do you know how i can have manyTill not consume the "{{" input?
09:36:27 <LoganCapaldo> > length $ filter (uncurry (==)) $ zip [1,2,3] [1,3,3]
09:36:28 <lambdabot>  2
09:36:50 <LoganCapaldo> > length $ filter (uncurry (==)) $ zip [1,2,3] [3,2,1]
09:36:52 <lambdabot>  1
09:37:01 <LoganCapaldo> > length $ filter (uncurry (==)) $ zip [1,2,3] [3,4,5]
09:37:03 <lambdabot>  0
09:37:05 <Philippa> xic: you can pass it a modified parser that doesn't consume the "{{", just matches and then backtracks
09:37:21 <xic> Philippa: how do i make such a parser?
09:37:22 <Philippa> alternatively, you can just start parsing the innards up until the }}
09:37:33 <pjd> <augustss> pjd: IO isn't a monad...
09:37:36 <pjd> in what sense?
09:37:48 <augustss> it doesn't obey the monad laws
09:37:50 <Pastorn> LoganCapaldo: thet was just crazy
09:38:04 <pjd> oh, i thought it did
09:38:12 <augustss> it would if we didn't have seq
09:38:13 <pjd> how does it break?
09:38:14 <Philippa> xic: lookahead?
09:38:20 <Pastorn> but filter and zip was nice =)
09:38:38 <xic> @hoogle lookahead
09:38:39 <lambdabot> Text.ParserCombinators.Parsec.Combinator.lookAhead :: GenParser tok st a -> GenParser tok st a
09:38:39 <lambdabot> IO.hLookAhead :: Handle -> IO Char
09:39:09 <augustss> pjd: there's a long thread in one of the haskell mailing lists.  not that is wasn't know before that
09:39:20 <pjd> augustss: pointer?
09:39:24 <xic> hm... there don't seem to be any docs for lookAhead
09:39:44 <Pastorn> http://paste.lisp.org/display/36671
09:39:46 <chessguy> ?src maybe
09:39:46 <pjd> is it really the IO monad disobaying the laws, or due to more general strictness issues?
09:39:47 <lambdabot> maybe n _ Nothing  = n
09:39:47 <lambdabot> maybe _ f (Just x) = f x
09:40:19 <LoganCapaldo> > [1,2,3] == [1,2,3]
09:40:20 <lambdabot>  True
09:40:28 <LoganCapaldo> > [1,2] == [6,7,8]
09:40:30 <lambdabot>  False
09:40:42 <chessguy> ?hoogle try
09:40:42 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
09:40:43 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
09:40:43 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
09:40:44 <LoganCapaldo> @instances Eq
09:40:45 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
09:40:49 <Pastorn> equals :: [a] -> [a] -> Int <-- notice "Int"
09:41:04 <LoganCapaldo> oh silly me :)
09:41:13 <Pastorn> and all i want to know is how to write cases
09:41:18 <emk> dons, augustss, pejo: OK, all the links and papers you suggested have been added.
09:41:33 <Saizan> Pastorn: replace "dunno" with case x == y of True -> 1; False -> 0
09:41:42 <Pastorn> or maybe i have to do this with guards...
09:41:43 <tibbe> could someone please recommend me some good books?
09:41:44 <augustss> @paste
09:41:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:41:47 <LoganCapaldo> Pastorn: case is just like using pattern matching in the function
09:41:53 <Pastorn> Saizan: thanks =)
09:42:13 <LoganCapaldo> f (x:xs) is the same as f ls = case ls of (x:xs) ->
09:42:23 <dons> emk, btw, we're catching up on the shootout, only one entry runs outside 10x C now, and I fixed that today.
09:42:29 <Saizan> you'll have layour issues probably
09:42:32 <Saizan> *layout
09:42:33 <LoganCapaldo> So you already know how to use case :)
09:42:43 <emk> dons: Great to hear it!
09:42:50 <pejo> tibbe, about?
09:42:55 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/440
09:43:06 <pjd> augustss: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/18569 ?
09:43:09 <lambdabot> Title: Gmane Loom
09:43:19 <augustss> pjd: yes, and I pasted the example
09:43:37 <chessguy> let pick u xs = xs !! (floor.(u*).fromIntegral.length) xs in pick (2%3) "abc"
09:43:41 <chessguy> > let pick u xs = xs !! (floor.(u*).fromIntegral.length) xs in pick (2%3) "abc"
09:43:43 <lambdabot>  'c'
09:43:57 <chessguy> > let pick u xs = xs !! (floor.(u*).fromIntegral.length) xs in pick (1%3) "abc"
09:43:58 <lambdabot>  'b'
09:44:10 <augustss> pjd: You can ignore the .! part
09:44:32 <emk> OK, I'm wandering off. I'll be back in a half hour or so...
09:45:06 <LoganCapaldo> that troll is so far over my head its underneath my feet
09:45:19 <newsham> anyone awake familiar with gtk2hs?
09:45:46 <pjd> augustss: dcoutts's response makes sense to me, though
09:46:33 <LoganCapaldo> > length $ filter id $ zipWith (==) [1,2,3] [1,2,3]
09:46:34 <lambdabot>  3
09:48:41 <LoganCapaldo> ?check map (uncurry (==)) (zip a b) == zipWith (==) a b
09:48:43 <lambdabot>   Not in scope: `b'
09:48:43 <augustss> pjd: but (>>= f) . return === f is one of the monad laws
09:49:51 <augustss> pjd: actually, it might be that the monad law holds in another formulation.
09:50:40 <augustss> pjd: since seq breaks eta reduction you have to be very careful how you formulate things
09:50:53 <pjd> augustss: but that example doesn't seem to violate that monad law, unless i'm missing something
09:51:22 <pjd> in other words, i see a surprising seq/strictness interaction, not a monad law violation
09:51:32 <augustss> pjd: do we agree that one of the law is '(>>= f) . return === f'
09:51:32 <Philippa> it might be fun to try to define (for an appropriate language) a seq that only works on either relevant values or provably-terminating ones
09:51:47 <tibbe> pejo, well I left that kinda open, comp sci or FP perhaps
09:51:50 <tibbe> pejo, or math
09:51:59 <tibbe> pejo, cause I want to get better at it
09:52:30 <augustss> pjd: if you agree to that, then you should be freely able to interchange LHS with RHS in code without changing the program.  And you can't for some f
09:53:19 <augustss> pjd: but I don't blame IO, I blame seq
09:53:20 <Philippa> except for the rather common definition of === which is "modulo _|_", but also not the value of === normally meant in the laws
09:53:41 <pjd> augustss: i think the concept of "changing the program" becomes smoky around bottom
09:54:02 <Philippa> I think it's pretty clear that making a previously-terminating program yield _|_ is a change
09:54:03 <augustss> pjd: no, it shouldn't.  Then your theory is broken
09:54:34 <augustss> Philippa: by === I mean a congruence relation
09:54:58 <pjd> Philippa: right, and isn't that strangeness due to seq, not the monad?
09:55:07 <augustss> the usual mathematical = of denotational semantics
09:55:28 <Philippa> pjd: in that removing seq'll leave you with a monad and that removing the monad won't, sure :-)
09:56:21 <augustss> You can weaken the monad laws.  By nasty side conditions.
09:56:28 <augustss> And then they would still hold.
09:56:29 <Anon4888> Philippa'll append 'll to anything
09:56:58 <pjd> Philippa: but if that example implies IO is broken, doesn't it imply all monads are broken?
09:57:19 <Philippa> Anon4888: where otherwise I would append " will", yes
09:57:39 <sorear> tell codder
09:57:42 <Philippa> pjd: no, only all useful ones
09:58:56 <Philippa> there're a few useless ones that do things like turn everything to () or undefined :-)
09:59:38 <augustss> Ban seq on functions!  Give us eta back!
10:00:01 <augustss> No more cruel experiments on functions!
10:00:03 <pjd> Philippa: what i mean is, the only think i can gather from that thread so far is that IO does obey they monad laws, and seq is subtler than it seems
10:00:18 <pjd> "the monad laws", even
10:00:58 <augustss> But IO does not obey the monad laws, and neither does e.g. [].
10:01:59 <augustss> And seq is subtle.  But it was thrown in, in the current form, for pragmatic reasons.
10:02:02 <pjd> augustss: it seems that depends whether you consider preserving value, or preserving strictness as well
10:02:13 <pjd> (i'm probably not using ideal wording)
10:03:47 <augustss> pjd: when I see = in a programming language setting I think denotational equality, mathematical equality, a congruence relation.  If I stray from that I no longer know what meta-theory I can trust.  It might be a perfectly fine place to stray to, but I no longer know it's safe.
10:04:38 <pjd> augustss: the way i see it, strictness is a separate issue, which there are other ways of dealing with
10:04:55 <astrolabe> augustss: I find myself having to use seq all the time.  Are there ways around it?
10:05:14 <pjd> like codata and corecursion
10:05:21 <dons> use bang patterns :-)
10:06:03 <astrolabe> dons: and banged datatypes instead of tuples?
10:06:23 <dons> yeah, but I was half-joking, since they're sugar for seq
10:06:56 <dons> its good to give the strictness analyser something to chew on though
10:07:01 <astrolabe> dons: but they are a special case.  Do they lead to the same problems?
10:07:21 <dons> yes
10:07:39 <pjd> ah, more specifically, "total" functional programming, as in David Turner's paper
10:08:08 <pjd> which eliminates one class of bottom, if i understand it right
10:09:57 <Philippa> yeah, the alternative's to use substructural types to show relevance - at which point you know you're going to evaluate it sooner or later
10:11:15 <Philippa> both options'd have their uses
10:12:12 <astrolabe> 'I don't like Haskell. It's a bondage and discipline language - either you think the way it thinks, or it will make your live a living hell.'
10:12:25 <syntaxfree> I saw that.
10:12:47 <astrolabe> We must all be kinky
10:12:59 <syntaxfree> I think everyone's entitled to be a snob, except if they work at Google, Amazon or are the authors of another language.
10:13:01 <Philippa> hey, don't look at me...
10:13:06 <Gwern> that's deviant thinking. miniluv will be applied to such double unplusgood thoughts.
10:13:18 * nmessenger cracks his whip
10:13:23 <syntaxfree> astrolabe: I actually  wrote a lengthy essay on bondage-and-discipline languages.
10:13:23 * astrolabe looks at Philippa
10:13:28 <Philippa> thing is, Haskell isn't a B&D language in that sense any more than C is - considerably less so, in fact
10:13:47 <astrolabe> I remember philippa's tmr article
10:13:59 <Philippa> and no doubt at least one conversation in -blah, too
10:14:33 <astrolabe> yeah, for pretty weak values of 'at least one'
10:15:03 <zem> 'ello
10:15:09 <nmessenger> h'
10:15:11 <pjd> astrolabe: yeah, that's a silly position
10:15:15 <pjd> form can be freedom
10:15:53 <Philippa> pjd: that's a common line from BDSMers, too :-)
10:15:54 <pjd> Haskell's B&D is like that of mathematics, not Java
10:16:09 <augustss> pjd: if you consider strictness a separate issue you can replace any program by bottom and theu would be equal according to your definition
10:16:37 <pjd> augustss: i'm not sure how you get to that
10:17:05 <nmessenger> the polymorphic types in Haskell remind me of (what I understand of) C++ templates, but have a *tremendously* saner syntax.
10:17:05 <astrolabe> I think what he says there is sort of true.  In the same way that if you try to make Pascal do gotos, it's going to be ugly.
10:17:26 <pjd> what i'm saying (and what the responses in that thread say) is that seq is inherently a special function
10:17:43 <Philippa> nmessenger: they're significantly different, C++ templates're more closely related to ML modules
10:17:48 <augustss> pjd: you just claimed that 42=undefined (according to the monad IO example), because it's just  change in strictness
10:17:54 <pjd> its outside of the pure functional world, just like unsafe*
10:18:06 <pjd> augustss: definitely not
10:18:15 <Philippa> unsafe* aren't part of H98 though
10:18:23 <Philippa> unsafeSeq would be a good name, sure...
10:18:25 <syntaxfree> what good is undefined in a strict context?
10:18:33 <augustss> Philippa: yes :)
10:18:48 <nmessenger> syntaxfree: it's good for blowing up your program :)
10:18:57 <pejo> syntaxfree, maybe that is the wrong question.
10:19:51 <augustss> pjd: well, ok, then we agree, 42/=undefined.  so the monad laws don't hold.  and it is because of stricness, but it's still broken.  (but it's better than if the laws had shown that 42=43 :) )
10:20:00 <pjd> augustss: they do hold
10:20:24 <pjd> the difference in behavior you see is due to seq
10:20:27 <pjd> not the IO monad
10:20:40 <Philippa> but the IO monad is not behaving according to the laws *because of seq*
10:21:04 <Philippa> claiming that my HD's not failing to store data because there's a huge magnet next to it doesn't do me much good either
10:21:06 <augustss> I don't really care what it's due to, the monad laws don't hold for IO in Haskell
10:21:27 <pjd> augustss: : seq is defined *outside* of pure functional evaluation
10:21:31 <Philippa> no, it's not
10:21:33 <augustss> Actually, I do care what it's due to.  But that doesn't make it less broken.
10:21:47 <Philippa> it's part of our mechanism for evaluating pure functions
10:21:54 <Philippa> if seq were an IO action that'd be different
10:22:04 <augustss> pjd: It's defined outside in the sense that you can't define it inside the lambda calculus.
10:22:15 <pjd> Philippa: it's part of the mechanism
10:22:25 <augustss> pjd: but is has a simple denotational definition
10:22:36 <Philippa> right, so it's part of pure functional evaluation in haskell
10:22:41 <pjd> augustss: right, which are not part of the monad law
10:22:44 <pjd> laws, even
10:23:00 <Philippa> the monad laws don't mean /anything/ without a semantics for the language
10:23:01 <pjd> Philippa: it's not a pure function, though
10:23:11 <pjd> it's closer to a compiler pragma
10:23:11 <augustss> pjd: well, yes, adding seq made the laws break
10:23:27 <Philippa> it is a pure function. It's just not a very nice one
10:23:40 <augustss> pjd: a pragma should not change the meaning of a program.  seq is NOT a pragma
10:24:18 <pjd> augustss: pragma, strictness annotation, whatever you call it :)
10:24:40 <pjd> you can change the behavior of lots of things with similar strictness annotations
10:24:51 <Philippa> which we don't have in haskell except through seq
10:24:58 <augustss> seq is a pure function, with a simple definition.  it's just bad news for various laws that used to hold for haskell
10:25:35 <astrolabe> augustss: what's the definition?
10:25:36 <augustss> if seq were in a type class (which it originally was) then things would not break
10:25:59 <pjd> augustss: err, how would you define seq?
10:26:03 <augustss> seq _|_ y = _|_; seq x y = y (where x /= _|_)
10:26:19 <astrolabe> Ah
10:26:25 <augustss> this is a definition in denotational semantics, not Haskell
10:26:30 <pjd> except that's not a pure definition
10:26:32 <pjd> exactly
10:26:41 <Philippa> pjd: that is a pure definition of a pure function
10:26:44 <augustss> it's pure
10:26:47 <Philippa> pure doesn't mean "ordinary haskell"
10:26:54 <augustss> it's just not definable in haskell
10:27:13 <Philippa> there's an awful lot of functions not definable in haskell, or in any programming language
10:27:20 <augustss> but there are other functions that are useful that you can't define in Haskell.  Like por
10:27:25 <astrolabe> augustss: is it a theorem that it's not?
10:27:45 <Philippa> astrolabe: _|_ isn't a constructor, how do you match against it?
10:27:47 <augustss> astrolabe: yes, you can prove that seq is not definable in haskell
10:28:02 <astrolabe> Thanks both
10:28:12 <pjd> matching against _|_ isn't inside the realm of computation, is it?
10:28:24 <Philippa> pjd: there are many pure functions that aren't
10:28:25 <trurl> how does such a proof look like?
10:28:27 <augustss> that's right
10:28:46 <pjd> so that's not how seq works
10:28:51 <astrolabe> It isn't obvious to me that you need to match against bottom
10:28:55 <pjd> Haskell's seq, i mean
10:29:03 <Philippa> pjd: it is. Just bear in mind what _|_ *means*
10:29:03 <augustss> trurl: I'm not sure what an easy proof is.  maybe a relational one
10:29:33 <Philippa> it's okay for the match against _|_ to fail to terminate if you hand it _|_
10:29:46 <Philippa> because that would yield _|_
10:29:50 <astrolabe> right
10:30:00 <augustss> pjd: just because it looks like you match against _|_ doesn't mean you can't implement it
10:30:19 <pjd> Philippa, augustss:  look, i understand what you're saying
10:30:24 <astrolabe> Philippa: the difficulty is matching against the complement of bottom :)
10:30:40 <augustss> pjd: so why are we arguing? :)
10:30:54 <Philippa> astrolabe: nah, that's easy so long as you're allowed to fail to terminate if you don't get it :-)
10:31:20 <pjd> what i'm saying is that there's nothing special about the IO monad (or any monad) being altered by seq
10:31:29 <augustss> pjd: agreed
10:31:39 <Philippa> sure. That's precisely why it prevents the monad laws holding
10:31:41 <pjd> because that isn't part of the monad laws
10:31:41 <astrolabe> Philippa:  :p.  You aren't!
10:31:51 <Philippa> except it is
10:31:57 <Philippa> because that's what the = means
10:32:07 <pjd> Philippa: it isn't.  the monad laws come from category theory, not denotational semantics
10:32:21 <Philippa> sure. Now go build the relevant category, yeah?
10:32:25 <pjd> several of the posts in that discussion go into more detail
10:32:26 * allbery_b also doesn't see what the ruckus is; seq is, effectively, unsafeBottom or something like that.
10:32:35 <pjd> allbery_b: yeah
10:33:05 <augustss> allbery_b: seq is not unsafe in the same way as unsafePerformIO
10:33:28 <allbery_b> no, not in the same way, but nevertheless unsafe
10:33:32 <augustss> maybe unpleasentSeq
10:33:45 <allbery_b> you're delivberately breaking the rules
10:33:50 <Philippa> yeah, there isn't an implementation of seq that involves pulling entire universes from nothing
10:33:51 <chessguy> nassssty little seqsss
10:34:31 <astrolabe> @type flip seq ()
10:34:33 <lambdabot> forall a. a -> ()
10:34:39 <augustss> seq is also fine, except for the -> type (and things built on it)
10:34:56 <Cheery> lets see, I guess it's parsertime!
10:35:17 <chessguy> ?seen xerox
10:35:18 <lambdabot> xerox is in #ghc and #haskell. I last heard xerox speak 1h 48m 46s ago.
10:35:36 <bakert> ?t (>>=)
10:35:37 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:35:40 <Cheery> time to formalise the parser design and maybe implement it.
10:35:44 <bakert> ?type (>>=)
10:35:46 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
10:36:09 <bakert> ?hoogle bind
10:36:10 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
10:36:10 <lambdabot> Language.Haskell.TH.bindS :: PatQ -> ExpQ -> StmtQ
10:36:10 <lambdabot> System.Console.Readline.bindKey :: Char -> Callback -> IO ()
10:43:17 <bakert> ha ha.  i just re-read http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
10:43:19 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
10:43:26 <bakert> and this time it made sense AND i could do the exercises.
10:43:27 <astrolabe> I'd like to know if it is always possible to avoid seqs, or if they are inevitable if you want to handle large structures.
10:43:29 <bakert> go me.
10:43:51 * nmessenger cheers on bakert
10:43:52 <astrolabe> go bakert!
10:44:05 <oklopol> what's the most trivial tutorial there is on haskell? my friend has no programming experience and the one i found in haskell.org requires that
10:44:17 <oklopol> like, learning to program using haskell
10:44:22 <hpaste>  zem pasted "handling a fromJust error within IO" at http://hpaste.org/441
10:44:40 * zem needs help filling in the blanks
10:45:17 <allbery_b> why are you using fromJust?
10:45:23 <Philippa> oklopol: bash out some arithmetic, use let, define the booleans and the usual operations from scratch, work from there?
10:45:57 <zem> well, i need to convert Just value to value
10:46:08 <allbery_b> case Map.lookup ... of
10:46:15 <oklopol> i mean, i'm not gonna teach him, just asked for a tutorial :D
10:47:00 <astrolabe> It would be nice if there was a 'the little lisper' for haskell
10:47:00 <allbery_b> alternately, fromMaybe so you can provide an action to perform if it's Nothing
10:47:35 <nmessenger> the maybe function does the case analysis succinctly
10:47:38 <nmessenger> @src maybe
10:47:39 <lambdabot> maybe n _ Nothing  = n
10:47:39 <lambdabot> maybe _ f (Just x) = f x
10:48:21 <zem> how does that play with imperative code?
10:49:01 <allbery_b> r <- maybe (return ()) (do ...) (Map.lookup ...)
10:49:11 <nmessenger> it's just a pure function, you can use it like any other.  *shrug*
10:49:14 <zem> ah - sweet
10:49:17 <allbery_b> actually, for that I thik a version of maybe with parameters flipped would work better
10:49:45 <allbery_b> (but flip maybe isn't right either)
10:50:00 <nmessenger> yeah, it's Left Void
10:50:02 <nmessenger> :P
10:50:16 <nmessenger> @src Maybe
10:50:17 <lambdabot> data Maybe a = Nothing | Just a
10:50:27 <nmessenger> the maybe function matches the declared order
10:50:38 <allbery_b> sure
10:50:58 <allbery_b> I'm just thinking ifMaybe (catchNothing) (expr) $ do ...
10:51:06 <allbery_b> or similar
10:51:08 <nmessenger> oh
10:51:23 <allbery_b> for this kind of usage.  probably not common enough to be a standard function
10:51:30 <zem> and how do i get the result of the map.lookup inside the do block?
10:52:18 <nmessenger> maybe (return ()) f (...); let f theResult = ...
10:52:36 <thedward> oklopol: have you looked at http://en.wikibooks.org/wiki/Haskell ?
10:53:50 <allbery_b> case Map.lookup ... of Nothing -> return (); (Just r) -> do ...
10:54:10 <nmessenger> ^^ that's the same thing, but explicit
10:54:48 <oklopol> thedward no, but i will
10:54:59 <astrolabe> Interesting fusion for haskell article on reddit
10:56:14 <zem> beautiful :) thanks
10:56:30 <zem> just finished my first working haskell app
10:59:31 <chessguy> (corner cases)--
10:59:37 <oklopol> thedward, it seems just the thing, thx :D
11:02:13 <chessguy> @quote corner
11:02:13 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
11:02:44 <edwinb> eek
11:02:56 <edwinb> he did, though ;)
11:03:07 <zem> :)
11:03:31 <nmessenger> @quote [oO]leg
11:03:32 <lambdabot> emu says: olegarithmic
11:05:04 <chessguy> ugh, if you have an empty heap and want to know the minimum value in that heap, what should it be?
11:05:38 <chessguy> > minimum []
11:05:39 <lambdabot>  Add a type signature
11:05:43 <nmessenger> undefined?
11:05:46 <chessguy> ?src minimum
11:05:46 <lambdabot> minimum [] = undefined
11:05:47 <lambdabot> minimum xs = foldl1 min xs
11:05:49 <allbery_b> _|_
11:06:01 <chessguy> which is it? undefined or bottom?
11:06:05 <nmessenger> yes
11:06:21 <nmessenger> undefined is bottom
11:06:24 <chessguy> oh ok
11:06:37 <glguy> it should be error "minimum: emptyHeap"
11:06:47 <nmessenger> ^^ which is also bottom :)
11:06:49 <chessguy> oh?
11:06:54 <chessguy> ...
11:07:00 <glguy> so when you encounter it at runtime
11:07:04 <nmessenger> > let bottom = bottom in bottom
11:07:04 <glguy> you know why your program stopped
11:07:05 <lambdabot>  Add a type signature
11:07:14 <chessguy> @quote bottom
11:07:15 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
11:09:11 <chessguy> @type error
11:09:13 <lambdabot> forall a. [Char] -> a
11:09:36 <glguy> chessguy: or it could return Maybe a
11:11:01 <slowriot> I've been trying to install afrp
11:11:14 <chessguy> bah
11:11:19 <slowriot> the current version, 0.4, isn't really compatible with ghc 6.6, is it?
11:11:20 <chessguy> i don't even like having an empty heap
11:11:41 <xerox> chessguy: hey, done? I had some friend visiting.
11:11:53 <slowriot> has anyone here used yampa?
11:11:58 <chessguy> xerox, meh, i've just avoided the problem
11:12:21 <chessguy> i fleshed out the rest of my binary tree definition, and i'm just using that
11:12:22 <xerox> ?seen joelr
11:12:22 <lambdabot> I haven't seen joelr.
11:12:33 <chessguy> except i'm calling it a heap instead of a tree :)
11:14:04 <chessguy> i think i'm just going to make an empty heap impossible
11:14:43 <xerox> chessguy: the haddock doc suggest a definition for a possible empty binary tree, and its instances of Traversable/Foldable
11:14:53 <oklopol> my ghc crashed on 10^10^10 `mod` 5
11:15:04 <xerox> > 10^10^10 `mod` 5
11:15:08 <lambdabot> Terminated
11:15:26 <xerox> 0
11:15:40 <oklopol> it might be because i've been terminating it a lot by force
11:15:41 <oklopol> maybe
11:15:46 <chessguy> the hadock doc for what?
11:15:51 <oklopol> yeah, i outwitted haskell too :PP
11:16:06 <xerox> chessguy: Data.Foldable Data.Traversable
11:17:11 <chessguy> oh, isn't that a subclass of monoid?
11:17:44 <xerox> Monoids needn't to be foldable or traversable.
11:18:07 <chessguy> yea, but to be foldable, it must be a monoid, right?
11:18:08 <xerox> E.g. endofunctors (a -> a) aren't either.
11:18:12 <nmessenger> do foldable and traversable things have to have a 0 and a +?
11:20:06 <nmessenger> the doc doesn't mention a Monoid in the definition of Foldable  http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
11:20:09 <lambdabot> http://tinyurl.com/23pc9l
11:20:25 <gotaku> What does 'where' mean in a module definition?
11:20:25 <sorear> tell fodder
11:20:28 <sorear> it did for me, see the sig of fole
11:20:31 <sorear> it did for me, see the sig of fold
11:20:44 <nmessenger> gotaku: the where introduces all the names you define in the module
11:20:48 <sorear> gotaku: where introduces the block with the module's names
11:21:21 <nmessenger> sorear: er, yeah.  I meant it's not specifically a superclass.
11:23:04 <nmessenger> the foldr and foldl methods take the (+) and 0 as parameters
11:23:14 <oklopol> let superpow n = n^n^n^n^n^n `mod` n
11:23:39 <oklopol> wouldn't it have been easy to introduce some modulo arithmetics to ghc?
11:24:20 <oklopol> not that that kind of thing would actually be used, but it's very basic math to optimize that
11:24:28 <oklopol> into let superpow n = 0
11:24:30 <Lajexander_> http://paste.lisp.org/display/36679
11:24:39 <glguy> ?where wrong
11:24:39 <lambdabot> http://adrinael.net/wrong.jpg
11:24:42 <Lajexander_> I need to write a tuple, that isn't a tuple
11:25:00 <sorear> Lajexander_: we have our own pastebin now, BTW
11:25:00 <glguy> !paste
11:25:00 <hpaste> Haskell paste bin: http://hpaste.org/
11:25:27 <Lajexander_> so it's just two Ints...
11:25:35 <Lajexander_> how do you do that?
11:25:52 <orbitz> hr, has anyone gotten hopengl to work under macosx?
11:26:48 <sorear> Lajexander_: data Reply = Reply Int Int, btw
11:27:18 <Lajexander_> you can't do that!!
11:27:28 <allbery_b> ?
11:27:37 <nmessenger> Lajexander_: you mean *you* can't for this assignment?
11:27:51 <Lajexander_> that's against all intuitive rules ever concieved!!
11:27:57 * nmessenger sighs
11:28:04 <Lajexander_> hehe
11:28:06 <Lajexander_> thanks
11:28:45 <sorear>  Lajexander_: huh?
11:28:52 <sorear> Lajexander_: you CAN to "that"
11:29:04 <sorear> Lajexander_: assuming I understand what "that" is
11:29:15 <sorear> data Reply = ReplyD Int Int
11:29:30 <Lajexander_> just writing "Int Int", no commas, no parentheses of any kind...
11:29:50 <nmessenger> @kind (,) Int Int
11:29:50 <malcolm> orbitz: yeah, hopengl on mac worked for me, but it was a while back - ghc-6.2.2 I think
11:29:51 <sorear> Lajexander_: yes, this binds tightly
11:29:52 <lambdabot> *
11:30:02 <Lajexander_> I was thinking of this: {
11:30:10 <sorear> Lajexander_: if you have a more complicated type you need parens
11:30:14 <Lajexander_> but I don't really know how it works...
11:30:22 <sorear> data Reply = Reply Map Int Int Int -- illegal
11:30:29 <sorear> data Reply = Reply (Map Int Int) Int -- legal
11:30:49 <orbitz> malcolm: hrm i'm tryign to install greencard which it says it needs and that is giving me lip
11:31:05 <Lajexander_> oh... so it's okay as long as it is no more than two types after the constructor?
11:31:34 <sorear> Lajexander_: no
11:31:35 <malcolm> orbitz: doesn't your ghc come with hopengl already-compiled?
11:31:41 <orbitz> hrmm
11:31:45 <allbery_b> you can have many types.  you just need to keep them straight if one of the types is itself composite
11:31:46 <orbitz> malcolm: how can I test?
11:31:49 <sorear> Lajexander_: it's okay as long as your types have no spaces in them
11:31:53 <Lajexander_> sorear: thanks for not confusing me ;)
11:32:02 <malcolm> orbitz: ghc-pkg list
11:32:02 <Lajexander_> hehe, ok
11:32:37 <orbitz> malcolm: i see GLUT and OpenGL so is hodul eb abel to do ghc -package OpenGL ?
11:32:53 <allbery_b> data R = R Int String (Map Int Foo) IO (State Bar) -- legal if perhaps inadvisable (records are nicer when it's this complex)
11:32:55 <sorear> orbitz: yes
11:33:01 <orbitz> sorear: oh wonderful
11:33:14 <bakert> This is a ludicrously general question.  But what proportion of your functons are in IO, "normally"?  Writing a real world kind of a program that actually does something.
11:33:15 <orbitz> malcolm, sorear : thanks. all the stuf fi was reading msut be old it seemed to say it was plannign ong etting opengl in base install
11:33:21 <sorear> orbitz: don't use -package unless you know what you are doing
11:33:29 <orbitz> sorear: oh? what should I do then?
11:33:29 <sorear> orbitz: use --make, always
11:33:36 <glguy> bakert: almost none of hpaste is in IO
11:33:39 <orbitz> sorear: what if i want to play in ghci?
11:33:44 <sorear> make means no dependency hell
11:34:01 <sorear> orbitz: ghci requires no package options, if properly configured
11:34:07 <Philippa> bakert: hardly any of mine unless it's a very 'scripty' program
11:34:07 <sorear> (it's effectively always --make)
11:34:09 <bakert> glguy, roughly what percentage?
11:34:12 <orbitz> oh ok
11:34:18 <orbitz> what is wrong with package?
11:34:28 <sorear> orbitz: dependency hell
11:34:34 <bakert> my three little programs are 76 out, 28 in.
11:34:52 <sorear> orbitz: it'll take a rediculous amount of time to get all the right options
11:34:55 <glguy> bakert: you are welcome to count it up in hpaste, the sources are public
11:35:00 <orbitz> hrm i'm trying to compile one fo teh HOpenGl xamples and i get Could not find module 'GLU'
11:35:07 <bakert> they do do a lot of db and web grabbing stuff.  and they produce html reports.  but perhaps that is a bit too high a proportion.
11:35:21 <sorear> orbitz: that's an OLD example then
11:35:25 <orbitz> oh ok
11:35:39 * sorear is amazed HOpenGL predates hierarchical modules
11:35:39 <orbitz> is ther ea mroe uptodate examples listing?
11:36:21 <sorear> I don't recall
11:36:28 <bakert> glguy, hpaste is 7 in IO, 88 out.
11:36:38 * bakert whistles in admiration
11:36:46 <sorear> bakert: define IO
11:37:08 <sorear> bakert: most of HPaste (iirc) is in HPaste's IO/STM newtypes
11:37:08 <orbitz> sorear: thanks
11:37:15 <bakert> sorear,  grep "::" | grep IO
11:37:20 <bakert> !
11:37:38 <sorear> bakert: so newtype'd IO is somehow less stigmatic?
11:37:51 <bakert> sorear, who would do something crazy like that?!
11:38:06 <bakert> not me or glguy, tha'ts for sure!!!!
11:38:08 <bakert> ;)
11:38:20 <sorear> bakert: musasabi / alexj
11:38:39 <sorear> bakert: .... whose code is imported into hpaste
11:39:10 <bakert> sorear, cheating!
11:39:20 <glguy> none of the hpaste web-interface code is in IO except the part that tells the bot something happened
11:39:41 <glguy> it isn't even in STM, it is just used by STM
11:40:00 <glguy> HAppS functions represent transformations on state
11:40:04 <bakert> so we can include the 8 functions in Net as well?  Making it 15/80
11:40:29 <glguy> bakert: I really don't know what the relevence of that statistic is , though
11:40:51 <bakert> Well, I was just wondering if I'd done "enough" to get stuff out of IO in my code.
11:40:54 <bakert> That's all really.
11:41:16 <bakert> I know it's too general a question but I was thinking about it so I thought I'd start an idle discussion.
11:41:17 <bakert> !
11:41:43 <glguy> I just don't think there is any general guideline to follow
11:41:48 <glguy> put things that are IO based in IO
11:41:55 <glguy> don't put things that aren't in it
11:42:00 <glguy> totally dependent on the speicific application
11:42:01 <bakert> true but sometimes there's a grey area.
11:42:09 <sorear> bakert: lambdabot is another good example ... (note LB = IO + bot state)
11:42:48 <bakert> like if you don't decompose enough you can end up with one great mass in IO.  i know because i have to fight it happening to me!
11:43:04 <bakert> i start to feel like IO has got all over everything and it's going to take ages to clean up!
11:43:05 <nmessenger> ask yourself which parts of an algorithm *truly* depend on the outside world, and pull everything else you can out of IO.
11:44:07 <astrolabe> Yeah, I make an effort to minimise what is in IO, but it is easy to get slack about it.
11:44:40 <bakert> that's the thing.  i mean, obviously getting the result out of the db is in IO.  but then that bit of IO can kind of infect other stuff that it shouldn't if you let it.
11:44:57 <bakert> i think i am doing ok though.
11:45:24 <xic> orbitz: you are a c++ expert, right?
11:46:11 <nmessenger> liftM (putResult . bashDataPurely) getDataFromDB
11:46:12 <jz87> what does :^: mean in haskell?
11:46:17 <jz87> I know : is the cons operator
11:46:26 <ookk> dons,
11:46:27 <ookk> ~/Desktop > time ./test 20000000
11:46:27 <lambdabot> ookk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:46:27 <ookk> -0.169075164
11:46:27 <ookk> -0.169031665
11:46:27 <ookk> ./test 20000000  20.50s user 0.05s system 99% cpu 20.563 total
11:46:30 <sorear> jz87: anything
11:46:36 <jz87> anything?
11:46:37 <newsham> ?src (:^:)
11:46:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:46:40 <sorear> jz87: it's a user defined operator
11:46:40 <nmessenger> : starts an infix data constructor, so it'd depend on the type.
11:46:43 <newsham> ?type (:^:)
11:46:45 <lambdabot> Not in scope: data constructor `:^:'
11:46:50 <nmessenger> @index (:^:)
11:46:50 <sorear> jz87: IIRC it  is from HList
11:46:51 <lambdabot> bzzt
11:46:59 <newsham> jz87: someone could have defined it to anything they wanted to
11:47:01 <sorear> jz87: what code are you int
11:47:25 <jz87> for a binary tree
11:47:31 <sorear> oh
11:47:40 <sorear> so somewhere up you have
11:47:41 <newsham> do you see any definitions for (:^:) ?
11:47:45 <orbitz> xic: to a degree
11:47:51 <jz87> yeah
11:47:53 <jz87> hmm
11:47:54 <sorear> data Tree a = Leaf a | Tree a :^: Tree a
11:47:57 <jz87> I somehow missed that
11:47:58 <jz87> yes
11:48:06 <jz87> I thought ^ meant something
11:48:11 <jz87> where : is the normal cons operator
11:48:14 <jz87> and I got confused
11:48:16 <newsham> ?type (^)
11:48:18 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:48:19 <newsham> it does :)
11:48:28 <sorear> ?ty (.^.)
11:48:30 <lambdabot> Not in scope: `.^.'
11:48:31 <nmessenger> could also be written: (:^:) (Tree a) (Tree a) or Node (Tree a) (Tree a)
11:48:33 <sorear> ?ty (.&.)
11:48:35 <lambdabot> forall a. (Bits a) => a -> a -> a
11:48:40 <ddarius> jz87: Anything that starts with : is a constructor.
11:48:44 <glguy> did everyone else already know that you can supply your nickserv password as your server password to be automatically identified when you connect?
11:48:47 <jz87> oh
11:48:47 <nmessenger> (:^:) is just a constructor name
11:48:54 <jz87> infix constructors?
11:48:55 <sorear> glguy: no
11:49:02 <sorear> jz87: yes
11:49:04 <bakert> glguy, i finally got xchat to do it after it had annoyed me for about a week
11:49:08 <jz87> ok, that's new to me
11:49:09 <sorear> jz87: isn't it wonderful?
11:49:11 <xic> orbitz: so why the interest in haskell?
11:49:16 <jz87> yes and no
11:49:21 <jz87> it's confusing to new people
11:49:26 <jz87> but I can see how it's convenient
11:49:27 <glguy> bakert: you don't have to confiure xchat specially if you just provide a server password
11:49:27 <bakert> glguy, but tell it not to join #ubuntu and to join #haskell instead was trickier!
11:49:34 <Eighty> jz87: (:) is an infix constructor that you already know about
11:49:34 <ddarius> xic: Why not?
11:49:44 <sorear> jz87: EVERYTHING haskell is confusing to new people
11:49:46 <bakert> glguy, oh
11:49:46 <newsham> jz87: yah, lots of things ar econfusing to new people :)
11:49:57 <nmessenger> jz87: (->) is an infix *type* constructor!
11:50:05 <jz87> yeah, but : doesn't seem so confusing because :: is used for the same thing in theML world
11:50:14 <bakert> nmessenger, no voodoo on saturdays!  i told you before!
11:50:18 <sorear> nmessenger: .... but (,) isn't!
11:50:35 <ddarius> jz87: Yep, Haskell switched : and :: from ML.
11:50:47 <nmessenger> ML uses :: for cons?
11:50:51 <sorear> yes
11:50:52 <jz87> yeah
11:50:56 <jz87> and : for type
11:50:56 <sorear> and : for sigs!
11:51:05 <jz87> var 1 : int
11:51:30 * nmessenger `voodoo` bakert
11:51:33 <jz87> well not just ML, lots of languages use that notation
11:51:41 <jz87> anyway, thanks again sorear
11:52:24 <newsham> hey, at least coming from ML all you have to get confused about is some syntax
11:52:30 <newsham> try coming from C :)
11:53:10 <orbitz> xic: why not? C++ isn't a very good language
11:53:13 <ddarius> newsham: Scheme was the closest language to Haskell that I had programmed in before Haskell.
11:53:56 * ddarius essentially came from C++, but he still likes C++ too...
11:54:27 <mauke> template<typename e, template<typename> s, template<typename> m, typename a> m< Either< Pair< ParseError<e, s, t>, s<t> >, List< Pair< a, s<t> > > > runParserT(ParserT<e, s, t, m, a>, s<t>);
11:55:06 * sorear vomits
11:55:23 <newsham> i dont much care for C++.  I do like C though.
11:55:41 <newsham> my favorite list would probably be {haskell,C,python} in no particular order
11:56:26 * nmessenger points at the channel name and looks sternly at newsham
11:56:30 <ddarius> C# might steal C++'s place though. That said, I rarely use C++, it's just the next language I grab after Haskell.
11:56:32 <nmessenger> :P
11:58:06 <newsham> C# seems decent.  i havent yet had much occasion to use it.
11:58:45 <Saizan> reading last sigfpe's post i wondered who was so insane to create c++'s syntax
11:58:45 <sorear> isn't C# 3 supposed to be more a ML than a C?
11:59:10 <newsham> i've used C, C++ and python extensively (and java, haskell and various assembly languages a decent amount)
11:59:11 <sorear> er, an ML
11:59:17 <newsham> and perl...
11:59:39 <sorear> C, perl, haskell, i386 asm
12:00:03 <newsham> worked on commercial products in C, C++ and python (different projects)
12:00:31 <sorear> minor: mc68k hex (you know your development tools suck when), C++, FORTH,
12:00:51 <newsham> at least m68k is the most programmer friendly assembly
12:01:12 <sorear> newsham: at least I had a copy of the user's manual, with opcode charts.
12:01:49 <newsham> probably shouldnt be doing assembly w/o arch ref manual :)
12:01:56 <dbremner> Saizan-Bjarne started with yacc and then switched to recursive descent
12:01:56 <lambdabot> dbremner: You have 1 new message. '/msg lambdabot @messages' to read it.
12:01:58 <sorear> only one program though...
12:02:12 <sorear> newsham: not assembly.  I was using a hex editor.
12:02:22 <sorear> hence need for opcode charts
12:02:22 <newsham> *nod* I understood.
12:02:37 <sorear> only program --> world's buggiest mac hello world
12:02:38 <newsham> again..  at least it was m68k,   coulda been worse :)
12:03:06 <sorear> hehe.
12:03:11 <newsham> i had to write dissassemblers/modelers for various instruction sets (was a fun job!)..  ia32 so much pain.
12:03:38 <newsham> m68k will always be the king of assemblies, thanks to the risc movement.
12:04:33 <nmessenger> learning enough assembly to write at least *some* kind of toy is good for demistifying the magic of programming in general
12:04:47 <newsham> or maybe vax was the king, i'm too young to know enough about it
12:04:50 <orbitz> cani convert form .lhs to a .hs automagicaly?
12:04:51 * SamB is trying to help fix ZSNES
12:04:54 <sorear> I like designing processor architectures
12:05:00 <sorear> orbitz: unlit
12:05:14 <Philippa> nmessenger: agreed
12:05:15 <sorear> /usr/lib/ghc-6.6/unlit -- on debian
12:05:28 * orbitz humphs.  none of these OpenGL exampels seem to do anythign for me!
12:05:37 <newsham> but m68k is supposed to be heavily borrowed (subset) from vax
12:05:38 <sorear> orbitz: but why?  .lhs is better!
12:05:45 <orbitz> sorear: curiosity
12:05:49 <sorear> ah ok.
12:05:58 * nmessenger didn't parse the second 'h' in 'humphs' the first time :}
12:06:01 <orbitz> is tehr eany palce devoted specificlaly to OpenGL in haskell?
12:06:14 <sorear> haskell.org/hopengl?
12:06:30 <mauke> orbitz: perl -pe 's/^>//||!/\S/||s/^/-- /' :-)
12:06:44 <orbitz> sorear: 404
12:07:10 <dbremner> newsham- vax has a polynomial eval instruction
12:07:17 <newsham> *nod*
12:07:38 <nmessenger> @where hopengl
12:07:39 <lambdabot> http://haskell.org/HOpenGL/
12:07:50 <orbitz> oh yes sit DID work!
12:07:53 <orbitz> yaaay
12:07:58 <newsham> those vaxes are crazy.  the first vax had a pdp11 as its front end.
12:08:11 <chessguy> ?src Traversable
12:08:11 <lambdabot> class (Functor t, Foldable t) => Traversable t where
12:08:12 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
12:08:12 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
12:08:12 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
12:08:12 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
12:08:22 * nmessenger mutters at case-sensitivity in general
12:08:24 <chessguy> Applicative?
12:08:35 <mauke> ?src Foldable
12:08:36 <lambdabot> Source not found. Do you think like you type?
12:08:37 <chessguy> ?source Applicative
12:08:38 <lambdabot> Applicative not available
12:09:04 <nmessenger> chessguy: Applicative is a Functor subclass
12:09:12 <sorear> ?src Applicative
12:09:13 <lambdabot> class Functor f => Applicative f where
12:09:13 <lambdabot>     pure  :: a -> f a
12:09:13 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:09:35 <sorear> ?source Data.Foldable
12:09:36 <lambdabot> Data.Foldable not available
12:09:38 <sorear> vah.
12:09:51 <nmessenger> if Monad were a subclass of it, then pure = return, (<*>) = ap
12:12:32 <chessguy> so, in general, what does it mean if something is an instance of Applicative?
12:12:59 <nmessenger> you can 'return' it and 'ap' it, beyond that I'm not sure :D
12:13:29 <chessguy> ?instances Applicative
12:13:30 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:13:39 <nmessenger> @docs Data.Applicative
12:13:39 <lambdabot> Data.Applicative not available
12:13:54 <nmessenger> @docs Control.Applicative
12:13:55 <lambdabot> Control.Applicative not available
12:14:11 <nmessenger> bleh
12:14:22 <nmessenger> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
12:14:24 <lambdabot> http://tinyurl.com/yrwujr
12:14:54 <nmessenger> "a strong lax monoidal functor"... whatever the hell that means :)
12:15:00 <chessguy> yeah, anyway
12:17:14 <chessguy> LB really needs it's src/docs/source/etc. stuff updated or something
12:19:02 * ddarius is still in the top 10 repliers for programmersheaven.com
12:19:10 * ddarius hasn't logged into it for four years.
12:19:33 <Twey> Haha
12:20:07 <chessguy> heh. "Programmers Heaven. It's all here! (except haskell, lisp, or any other really interesting language)"
12:21:19 <ddarius> In one of my last posts (http://www.programmersheaven.com/c/MsgBoard/read.asp?Board=3&MsgID=159284), I was told to "Write Haskell until your fingers hurt."
12:21:21 <lambdabot> Title: MESSAGEBOARD ERROR!, http://tinyurl.com/32fgu6
12:21:49 <ddarius> wtf?
12:21:58 <nmessenger> heh, and four years later?
12:22:16 <chessguy> fingers hurting yet?
12:22:23 <ddarius> No, not yet.
12:22:57 <chessguy> then GET BACK TO HACKING!
12:23:37 <nmessenger> @yow!
12:23:38 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
12:23:38 <lambdabot> legislation..
12:23:44 * ddarius needs a C++ compiler or to rewrite a C++ program in Haskell.
12:24:25 <ddarius> (or O'Caml, Scheme or Oz)
12:24:41 <ddarius> Or I guess C#
12:25:08 * ddarius has a dearth of mainstream language implementations.
12:25:32 <TomMD> C# is not allowed to be mentioned in this channel - it has harmed to many bystandards.
12:25:54 <zem> 'bystandards' is a beautiful word :)
12:26:25 <ddarius> Thank God, I'm not a bystandard.
12:26:56 <nmessenger> Won't someone please think of the ISOs!
12:28:08 <SamB> won't the ISO please think of the programmers?
12:28:35 <SamB> and, you know, offer free PDFs?
12:29:20 <zem> standard-bearers don't come cheap
12:29:45 <dbremner> SamB- some standards are free, normally those sponsored by wealthy organizations.
12:30:45 <SamB> so who sponsored SGML?
12:30:54 <bos> IBM.
12:31:05 <SamB> and when was IBM not wealthy?
12:35:23 <dbremner> SamB- the only free ISO or ANSI language standards that come to mind were DoD sponsored.
12:41:40 <RyanT5000> i'm running ghc 6.6, and it doesn't have Control.Monad.State
12:41:43 <RyanT5000> what's up with that?
12:41:56 <SamB> ah. you need to install extralibs
12:42:01 <allbery_b> you neglected to install the mtl package for your platform?
12:42:21 <RyanT5000> mtl?
12:42:26 <RyanT5000> i'm on ubuntu
12:42:32 <allbery_b> e.g. on debian libghc6-mtl-dev IIRC
12:43:05 <allbery_b> "monad transformer library" in 6.6 various things have been split from the base distribution
12:43:12 <RyanT5000> ah ok
12:43:15 <RyanT5000> thanks
12:43:38 <sorear> libghc6-mtl-dev
12:44:47 <sorear> (debian name)
12:45:13 <sorear> no wonder CTCP was't working!?
12:45:17 <sorear> Lag
12:45:56 <sorear> ... as sorear is suddenly flooded with replies to apparently nonworking version requests
12:47:10 <sorear> int-e: ^AVERSION^A recieved.
12:47:27 <int-e> it replied though
12:52:14 <ddarius> Events in my life in the last few months have made me find Underpower ten times more entertaining.
12:55:52 <mbishop> Happy birthday Nafai :D
12:56:52 <chessguy> > foldr (:) [] [1..5]
12:56:53 <lambdabot>  [1,2,3,4,5]
12:57:36 <chessguy> ?check foldr (:) [] x == id x
12:57:36 <lambdabot>   Not in scope: `x'
12:57:46 <chessguy> ?check foldr (:) [] == id
12:57:47 <lambdabot>   add an instance declaration for (Eq ([a] -> [a]))     In the definition of ...
12:57:47 <sorear> chessguy: Ok, passed oo tests
12:58:19 <chessguy> ?check foldr (:) [] = id
12:58:20 <lambdabot>  Parse error
12:58:21 <sorear> ?check (\x -> foldr (:) [] x == id x) :: [Int] -> Bool
12:58:23 <lambdabot>  OK, passed 500 tests.
12:58:51 <chessguy> why do you have to supply a type?
12:58:56 <sorear> and, it's true to boot
12:59:11 <chessguy> obviously it's true
12:59:15 <sorear> chessguy: quickcheck is an ordinary overloaded function
12:59:33 <sorear> so if you don't supply a type, it's as ambiguous as show . read
12:59:54 <sorear> ?check (\x -> foldr (:) [] x == id x)
12:59:55 <lambdabot>  Add a type signature
13:00:16 <sorear> you also need to eta-convert functional equality
13:01:12 <ddarius> ?check (foldr (:) [] == id) :: [Int] -> Bool
13:01:13 <lambdabot>      Expecting a function type, but found `Bool'       Expected type: [Int] -...
13:01:15 * mbishop holds lambdabot upside down and shakes his birthday presents out of her
13:01:24 <augustss> sorear: but eta conversion is not valid in haskell ;)
13:01:36 <dobblego> can you execute a system command from within a directory?
13:04:14 <sorear> stefan@stefans:~$ cd vty
13:04:14 <sorear> You have new mail in /var/mail/stefan
13:04:14 <sorear> stefan@stefans:~/vty$ ls
13:04:14 <sorear> Graphics  README     TODO  Test.hi  Test.o   UTF8.lhs  _darcs    comp.cmm    comp.stg  gwinsz.c  gwinsz.o    vty.cabal
13:04:18 <sorear> looks like :)
13:04:49 <xic> that UTF8 module really should be in the ghc standard modules
13:06:06 <trurl> how does your code look like that runs a set of quickcheck tests and exits with a non-zero status if one of them fails?
13:16:51 <zem> is there any difference between "a = <build data structure> \n f = <function querying a>" and "f = <function querying a> where a = <build data structure>" ?
13:17:27 <zem> (assuming i don't need a visible outside of f)
13:18:44 <ddarius> no
13:18:49 <ddarius> well...
13:19:07 <zem> what i'm trying to ask i guess is will the compiler do the calculation of a only once
13:19:17 <zem> even if i inline it as a where in f
13:20:18 <ddarius> Probably not, it should be lambda-lifted.  You could find out by throwing a trace statement in a.
13:20:24 <Lajexander_> you know how N x N is the set of all couples of integers...? How do I do that in a list comprehension?
13:21:13 <zem>  [(x, y) | x <- [1..], y <- [1..]]
13:21:27 <ddarius> zem: That's not all integers
13:21:38 <zem> oops - yeah, my bad
13:21:47 <astrolabe> no Lajexander_'s bad
13:22:03 <astrolabe> Z x Z is the pairs of integers
13:22:11 <sorear> no
13:22:23 <ddarius> Also, you'd need a diagonalizing list comprehension if you actually wanted to see more than (1,x)
13:22:30 <Lajexander_> okay, say instead that I need to make a list (of length n) instead of a tuple all with elements from xs
13:22:37 <Saizan> however [(x, y) | x <- [1..], y <- [1..]] is more like zip (repeat 1) [1..] in finite time
13:22:40 <zem> yeah, was just trying to cobble one togeher
13:22:49 <sorear> > join (liftM2 (,)) "abc"
13:22:51 <lambdabot>  [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c',...
13:22:54 <Lajexander_> Saizan: yeah, I know that...
13:23:15 <sorear> Lajexander_: join (liftM2 (,)) usefule?
13:23:22 <kaol> > take 22 [(y, z) | x <- [1..], y <- [1..x], z <- [1..x], x==y+z]
13:23:24 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
13:23:33 <orbitz> is $= a commonly defiend haskell funciton?
13:23:36 <Lajexander_> sorear: niggah plz!! what was that?
13:23:43 <sorear> no, just HOpenGL
13:23:52 <zem> maybe [(x*z, y*z) | [x <- 1..], y <- [1..x], z <- [-1, 1]]
13:23:55 <zem> something along those lines
13:24:06 <sorear> join (liftM2 (,)) = \a -> liftM2 (,) a a
13:24:22 <Lajexander_> i said I wanted this as a list comprehension...
13:24:26 <sorear> oh
13:24:36 <Lajexander_> and I have NO idea what liftM2 does...
13:24:38 <zem> you'd need to debug it so that x and y could be negative independently ;)
13:24:45 <sorear> join (liftM2 (,)) = \l -> [ (a,b) | a <- l , b <- l ]
13:25:01 <sorear> Lajexander_: list comprehensions are isomorphic to monads. liftM2 is a monad function.
13:25:09 <sorear> (on the [] monad)
13:25:15 <zem> [(x*z, y*w) | x <- [1..], y <- [1..x], z <- [-1, 1], w <- [-1, 1]] seems to do it but i'm not guaranteeing anything
13:25:22 <sorear> it's just one of #haskell's cute code compacting tricks
13:25:24 <Lajexander_> ok, so given an Int n and a list xs, gimme a list of lists with all the combinations of xs with length n
13:25:41 <Saizan> > [(x*z, y*w) | x <- [1..], y <- [1..x], z <- [-1, 1], w <- [-1, 1]] --just try it
13:25:43 <lambdabot>  [(-1,-1),(-1,1),(1,-1),(1,1),(-2,-1),(-2,1),(2,-1),(2,1),(-2,-2),(-2,2),(2,-...
13:26:02 <zem> wow - i keep forgetting what the bot can do
13:27:23 <Lajexander_> > 2 + 2
13:27:24 <lambdabot>  4
13:29:09 <augustss> Lajexander_: (sequence .) . replicate
13:29:27 <augustss> > let f = (sequence .) . replicate in f 2 "abc"
13:29:29 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
13:30:07 <Lajexander_> sequence is IO-related, isn't it?
13:30:26 <Saizan> monad related, and [] is a monad too
13:30:36 <zem> is there a shortcut for zip xs (map f ys)?
13:30:36 <Lajexander_> yeah
13:30:37 <paolino> :t sequence
13:30:39 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:33:33 <heatsink> @instances Monoid
13:33:35 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
13:33:50 <sorear> @src Ordering mempty
13:33:51 <lambdabot> Source not found. I feel much better now.
13:34:01 <sorear> @src Ordering mappend
13:34:02 <lambdabot> Source not found. My mind is going. I can feel it.
13:34:17 <heatsink> Hmm.  The online docs say there's an instance Monoid b => Monoid (a->b) but that seems to overlap with Monoid (a->a)...
13:34:53 <Syzygy-> I suppose Monoid (a->a) is just composition of endomorphisms, right?
13:35:07 <heatsink> I think so... mappend should be (.)
13:35:13 <heatsink> or flip (.) ?
13:35:15 <Syzygy-> Whereas Monoid b => Monoid (a->b) is by pointwise application of the Monoid structure?
13:35:35 <heatsink> I don't actually know what that means :/
13:36:02 <sorear> Syzygy-: yes and yes
13:36:09 <Syzygy-> sorear: Ok.
13:36:21 <sorear> endomorphisms are 6.4, reader monoid is 6.6
13:36:40 <Syzygy-> heatsink: The way I think about monoids is as having an identity (probably mempty?) and a composition (mappend, it'd seem).
13:36:54 <Syzygy-> And the identity on (a->b) would be const mempty
13:37:05 <heatsink> ah.
13:37:14 <sorear> monoids are just algebraic structures, nothing more
13:37:29 <Syzygy-> And the composition is f + g = \x -> (f x) + (g x)
13:37:40 <sorear> yea
13:38:02 <Syzygy-> sorear: And what you call the reader and I call pointwise application (or much better: pullbacks! :) is something that holds very generally...
13:38:03 <sorear> http://en.wikipedia.org/wiki/Monoid
13:38:12 <heatsink> Yea, I was wondering about the overlapping instances thing.  If the definitions aren't both present in the same version of ghc, then that answers the question.
13:38:26 <sorear> as usual, the articles on math topics are very useful
13:38:31 <SamB> they took out the Monoid (a -> a)
13:38:48 <SamB> but they oughtn't to have put in Monoid (a -> b) yet :-(
13:38:50 <Syzygy-> sorear: Before I actually think it through: is the endomorphism monoid expressible in terms of pullbacks (reader) ?
13:38:57 <Syzygy-> SamB: Oh?
13:38:59 <heatsink> hmm.
13:39:00 <sorear> Syzygy-: Ross Paterson called it the Reader monoid transformer ...
13:39:09 <LoganCapaldo> So is the integers and addition a Monoid ?
13:39:12 <sorear> Syzygy-: I think not
13:39:16 <heatsink> LoganCapaldo: yea
13:39:17 <SamB> because sometimes things typecheck with both of those...
13:39:21 <sorear> LoganCapaldo: yes, see instance Monad Sum
13:39:31 <Syzygy-> LoganCapaldo: Of course they are. :)
13:39:43 <LoganCapaldo> Just making sure I got the concept :)
13:39:53 <Syzygy-> SamB: Yeah. I built in a few bugs in the NumericPrelude with that trap. :P
13:39:56 <SamB> they should have had no Monoid instance for (->) for a while
13:40:04 * heatsink is at the disadvantage of not having learned any theoretical CS, except what I picked up by programming haskell.
13:40:04 <Syzygy-> They got thrown out again quickly, but still...
13:40:15 <SamB> heatsink: so?
13:40:18 <ddarius> heatsink: That's abstract algebra.
13:40:28 <heatsink> yea
13:40:31 <SamB> and yeah, that ain't theoretical CS ;-)
13:40:33 <Syzygy-> heatsink: I come from the completely other direction. I'm doing research in algebra, and theoretical CS and Haskell for the fun of it. :)
13:41:25 <heatsink> Okay, abstract algebra.
13:41:43 <chessguy> @paste
13:41:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:41:47 <heatsink> Syzygy-: that seems to be more common among haskell programmers.
13:41:58 * sorear <3 abstract mathematical structures
13:42:03 <SamB> heatsink: oh really?
13:42:12 <heatsink> Far as I've seen anyway.
13:42:14 <sorear> too bad we can't have fun with uncountable sets in Haskell ;(
13:42:26 <hpaste>  chessguy pasted "What's wrong with this?" at http://hpaste.org/442
13:42:27 * augustss is squarly in the CS camp.  If there are camps.
13:42:28 <sorear> I want Topology classes!
13:42:29 <hpaste>  chessguy pasted "What's wrong with this?" at http://hpaste.org/443
13:42:33 <qwr>         doc <- fmap (xmlParse fn) (hGetContents h)
13:42:33 <qwr>         seq doc (hClose h)
13:42:37 <chessguy> whoops
13:42:41 <chessguy> sorry for the re-paste
13:42:57 <Syzygy-> Which account s a lot for what topics I actually end up talking about, as well as the language I end up iusing.
13:42:58 <SamB> I think I started learning partly because I did not initially believe that you could do anything with purely functional programming. probably because I misinterpreted the term "purely functional" ;-)
13:42:59 <sorear> chessguy: exactly what it says
13:43:06 <sorear> chessguy: you need -fglasgow-exts
13:43:12 <LoganCapaldo> Woo
13:43:13 <SamB> I think I thought it meant that "the only thing there is is functions"
13:43:15 <LoganCapaldo> String a Monoid
13:43:16 <qwr> is this a "right way" to solve the problem, that lazy xmlParse after hClose will get nothing to parse...
13:43:21 <LoganCapaldo> I like it
13:43:34 <SamB> (though isn't that actually true of Lazy K?)
13:43:35 <chessguy> what, there's not a way to put a stdGen in the state?
13:43:35 <augustss> chessguy: also, never use Float, use Double
13:43:40 <sorear> qwr: delete the second line
13:43:45 <Philippa> it's true of the lambda calculus itself
13:43:54 <Syzygy-> sorear: YES you do want topology classes.
13:43:58 <sorear> qwr: the file will be automatcally closed
13:43:58 <SamB> Philippa: well yes, but Lazy K has IO
13:44:03 <SamB> and lambda calculus does not
13:44:12 <sorear> chessguy: you CAN put a StdGen in the state
13:44:23 <Syzygy-> One extremely funky thing I've heard people talk about very vaguely and want to know more about is topological methods (primarily homotopy) on logic and on lambda calculus.
13:44:32 <chessguy> why specifically do i need extensions?
13:44:45 <Syzygy-> So you end up with different proofs of the same theorem being homotopical if you can change one into the other by small small steps...
13:44:45 <augustss> chessguy: MPTC
13:44:47 <Philippa> SamB: nothing stops you church-encoding an AST for monadic computations and going from there, for example
13:44:50 <sorear> chessguy: MonadState ProgramState s
13:44:56 <Syzygy-> LoganCapaldo: String is a monoid because [a] is.
13:44:57 <sorear> chessguy: ^^^ not h98
13:45:11 <SamB> Philippa: I suppose
13:45:21 <LoganCapaldo> Syzygy-: I wasn't speaking speciically of Haskell
13:45:23 <astrolabe> Syzygy: Sounds weird
13:45:35 * LoganCapaldo was still reading the wiki page
13:45:36 <ddarius> sorear: See Synthetic Topology.
13:45:48 <Syzygy-> LoganCapaldo: Ok. The tensor product is a monoid. :)
13:46:00 <Syzygy-> astrolabe: The homotopy of proofs stuff? Yeah, but very appealing. :)
13:46:04 <qwr> sorear: hmm, System.IO doc says about automatic close "However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable."
13:46:11 <chessguy> so i just need {-fglasgowexts} somewhere in there?
13:46:13 <SamB> I guess I just didn't think it counted if you had to somehow apply the functions to datatypes (or functions) that aren't supported by the language...
13:46:28 <SamB> (in order to get the IO to work)
13:46:33 <SamB> I dunno.
13:46:34 <chessguy> s/\}/-\}/
13:46:38 <sorear> chessguy: {-# OPTIONS_GHC -fglasgow-exts #-}
13:46:40 * SamB wonders how that does work...
13:46:48 <LoganCapaldo> Ahh and now I see why a->a is a monoid
13:46:57 <LoganCapaldo> very clever those mathematicians
13:47:15 <Syzygy-> LoganCapaldo: It's easy. You have the identity endomorphism. And you can compose morphisms.
13:47:15 <SamB> mainly I used (a -> a) for DLists
13:47:29 <Syzygy-> LoganCapaldo: If a has an abelian group structure, (a->a) is a ring.
13:47:31 <chessguy> does that then require that i compile, instead of using ghci?
13:47:37 <sorear> chessguy: no
13:47:38 <SamB> dons's DList module might actually provide a Monoid instance by now
13:47:40 <Cale> Syzygy-: that is interesting -- do they pick an arbitrary set of transformations as being "small"?
13:47:42 <Syzygy-> Pointwise addition and composition.
13:47:50 <SamB> I certainly sent him the code long enough ago!
13:47:52 <Cale> Or are there specific things?
13:47:56 <Syzygy-> Cale: I really only ever saw handwaving.
13:47:59 <Cale> hmm
13:48:07 <Syzygy-> I think John Baez once wrote up an example.
13:48:09 <Syzygy-> Maybe.
13:48:15 <LoganCapaldo> See I'm starting to suspect that all this group / category / stuff is jsut daunting because of the vocabulary, not because its particularly hard
13:48:21 <chessguy> does it matter where  {-# OPTIONS_GHC -fglasgow-exts #-} goes?
13:48:32 <SamB> LoganCapaldo: most likely
13:48:39 <Syzygy-> LoganCapaldo: Parts of it is daunting because it's a LOT of new language. Parts of it really are tricky to wrap your head around.
13:48:40 <Cale> LoganCapaldo: There's lots of genuinely hard group theory.
13:48:48 * Syzygy- has had quite a few epiphanies during my undergraduacy.
13:48:49 <sorear> qwr: that comment was refering to Handle IO.  Lazy list IO is a very different (and much more confusing) beast, the file will be closed when you reach the end.
13:48:49 <allbery_b> firs tline of the file, no?
13:48:55 <sorear> chessguy: first line
13:48:56 <Cale> Then again, there's lots of pretty easy group theory too.
13:49:13 <Cale> (But not as much as you'd expect)
13:49:14 <SamB> Cale: I don't think he meant that there weren't hard things in it
13:49:15 <pejo> LoganCapaldo, there's plenty of vocabulary in fp too, you're just very used to it.
13:49:22 <Syzygy-> Cale: And then again, you can always go and find that little patch of frontier that noone else actually is looking at, and do your own thing. :P
13:49:40 <LoganCapaldo> Cale; If I may rephrase is daunting to me because of the vocabulary, I've not come across anything genuinely hard yet to daunt me on that front ;)
13:49:58 <qwr> sorear: thx. good to know :)
13:50:37 <Cale> Yeah. Category theory and graph theory have lots and lots of vocabulary you need to learn before you can really get into things.
13:50:57 <sorear> qwr: also, don't use list IO if performance matters, it's just too lazy.  Data.ByteString.Char8.Lazy.readFile is much better.
13:53:26 <Syzygy-> Cale: The n-category cafe got REALLY interested in the Haskell crowd after I dumped an example from the Haskell Wikibook into a discussion their.
13:53:29 <Syzygy-> *there
13:53:39 <Cale> Oh?
13:53:45 <Cale> Which example?
13:53:55 <Cale> Can I see the thread? :)
13:54:09 <Syzygy-> The categoricists, philosophers and mathematical physicists wanted to figure out whether all graphs can be made into categories.
13:54:38 <Syzygy-> http://golem.ph.utexas.edu/category/2007/02/this_weeks_finds_in_mathematic_5.html#c007550
13:54:41 <lambdabot> Title: This Week's Finds in Mathematical Physics (Week 244) | The n-Category Caf&#xE9;, http://tinyurl.com/yo4gha
13:55:09 <Cale> Isn't there an easy small contradiction to that?
13:55:37 <Syzygy-> Exactly.
13:55:54 <Syzygy-> And it's an exercise in the Haskellbook, and so I dumped a link into the discussion.
13:55:56 <Cale> Yeah, the Haskell wikibook page has the standard example
13:57:16 * LoganCapaldo asks stupid question
13:57:19 <Cale> Hmm, Firefox's support for MathML is better than I'd thought.
13:57:28 <Syzygy-> Cale: Ayup.
13:57:33 <Syzygy-> LoganCapaldo: Which question is that?
13:57:34 <LoganCapaldo> Why wouldn't you just have a set of pairs of vertices?
13:57:42 <LoganCapaldo> Is that not a category?
13:57:59 <Cale> It's getting some of the sizes of things and alignments slightly wrong, but it's readable. :)
13:58:28 <Syzygy-> LoganCapaldo: You can definitely have a category that looks kinda like this: | | | |
13:58:41 <Syzygy-> with pairs of vertices, a single morphism between the pairs, and nothing inbetween.
13:58:41 <Cheery> "Abraham Lincoln reportedly said that, given eight hours to chop down a tree, he'd spend six sharpening his axe."
13:59:01 <Syzygy-> In fact, since there is a partial order looking like that, there is a category too.
13:59:02 <Cale> LoganCapaldo: There can be more than one arrow between any pair of objects, and usually there are a large number.
13:59:07 <Syzygy-> Since partial orders are categories.
13:59:26 <SamB> Cale: I expect xmltex does better?
13:59:32 <Cale> But you can remove the discussion of objects from the description of categories altogether if you want
13:59:45 <LoganCapaldo> Cale: well (vertex, vertex, count) perhaps then
13:59:52 <Cale> SamB: Well, TeX does better, so probably.
14:00:09 <Syzygy-> LoganCapaldo: Just the number of arrows is not enough to determine the category.
14:00:11 <SamB> I didn't know TeX could read mathml by itself!
14:00:15 <Cale> LoganCapaldo: no, the arrows have more information in them than that.
14:00:45 <Cale> Consider this category: Objects are natural numbers, the arrows from n -> m are n by m matrices.
14:00:50 <Cale> (say, over the reals)
14:00:59 <Syzygy-> Composition is by multiplying the matrices.
14:01:02 <LoganCapaldo> all I know about graphs is wha I learned in Discrete :)
14:01:02 <Cale> right
14:01:03 <Syzygy-> (right?)
14:01:06 <Cale> exactly
14:01:27 <Cale> So in that case, there are usually uncountably many arrows between two objects.
14:01:37 <Syzygy-> Not only usually.
14:01:46 <Cale> well, not from 0 -> 0
14:01:48 <SamB> Cale: you must have a different firefox from me
14:01:53 <Syzygy-> Oh, right.
14:01:59 <Syzygy-> Is 0 natural in this world?
14:02:00 <Cale> I suppose you can use positive integers :)
14:02:06 <Cale> In my world yes :)
14:02:08 * LoganCapaldo obviously doesn't lknow what a category is. goes and reads some more
14:02:24 <SamB> mine is getting the alignments off by a LARGE vertical amount
14:02:28 <Syzygy-> In my world too, but the example seems to end up being slightly less natural with a natural 0.
14:02:45 <LoganCapaldo> Oh crud
14:02:52 <Cale> I don't mind matrices with empty rows or columns.
14:02:57 <LoganCapaldo> set of objects + the morphisms
14:03:03 <LoganCapaldo> not just the set of objects
14:03:04 <sorear> alignments huh?
14:03:05 <Syzygy-> LoganCapaldo: The one sentence description is: A category is a bunch of thingies, and for each ordered pair of thingies a bunch of _morphisms_.
14:03:12 <Syzygy-> And the morphisms can be all sorts of stuff.
14:03:17 <sorear> I am almost immune to bad web page formatting
14:03:28 <Syzygy-> Functions on sets are very common for examples, but far from the only ones.
14:03:36 <sorear> ... it's all the same 9x16 font
14:03:45 <Syzygy-> And a very good example to think about for intuition is actually the Haskell category.
14:03:53 <Syzygy-> Where objects are types and arrows are functions.
14:04:01 <SamB> sorear: that must make it difficult for you to see properly-rendered mathml!
14:04:06 <LoganCapaldo> woah
14:04:10 <Syzygy-> (oh, and 'arrow' and 'morphism' often are used synonymously)
14:04:23 <sorear> hmm.
14:04:33 <sorear> functions have types too
14:04:35 <Cale> Or just the category of sets and (mathematical) functions.
14:04:36 <Syzygy-> We require each object to have an identity (id::a -> a)
14:04:46 <sorear> is that what makes Hask (cartesian | closed)
14:04:57 <LoganCapaldo> if I get this diagram, there isn't 1 morphism id, there are N id morphisms, id 0, id 1, id 2, ... , id N
14:05:08 <Syzygy-> And we require composition of morphisms to work and to be associative.
14:05:13 <Syzygy-> LoganCapaldo: What diagram?
14:05:24 <LoganCapaldo> the one on the wikibook page
14:05:30 <LoganCapaldo> with A B and C
14:05:39 <Syzygy-> LoganCapaldo: In category theory, overloading isn't. There is a new id for each object.
14:06:06 <Syzygy-> Overloading/polymorphism is, in categorical terms, syntactic sugar for defining a whole bunch of morphisms at once.
14:06:20 <LoganCapaldo> So a function is family of morphisms?
14:06:23 <Syzygy-> Cale: I fully expect you to whack me once I bullshit too much.
14:06:49 <Syzygy-> LoganCapaldo: A function is mostly a morphism, and occasionally a family of morphisms, parametrized by the possible type signatures.
14:06:54 <Philippa> Syzygy-: it's arguably so in Haskell, too - an explicitly-typed calculus with parametric polymorphism usually has type lambdas
14:07:58 <Syzygy-> Hask ends up being slightly weird though: since morphism signatures also give rise to objects, so a morphism is both an element in the set of morphisms corresponding to its signature, and also a member of the object consisting of morphisms of that particular type.
14:08:19 <Cale> Syzygy-: I've been walking in and out of the room though :)
14:08:35 <Syzygy-> So some f::a -> b -> c is simultaneously an element of the morphisms from a to (b->c), and an element of the Haskell type a -> b -> c
14:08:45 <Syzygy-> Cale: Ok. Then I'll just continue with my disinformation. :)
14:08:58 <Syzygy-> Though Philippa probably also is capable of whackage if need.
14:09:00 <Syzygy-> *needed
14:10:02 <augustss> Well, we know Philippa is a BDSM girl.  And all of us Haskellers are.  I saw it on Reddit.
14:10:06 <augustss> ;)
14:10:17 <Syzygy-> augustss: Say what?
14:10:24 <SamB> augustss: I resent that!
14:10:28 <SamB> I'm no girl!
14:10:50 <Syzygy-> Yeah! SamB only plays one if you pay him enough! He has a completely different ground state!
14:10:52 <augustss> Hmmm, we're not all girls.  Just BDSMers :)
14:11:07 <SamB> Syzygy-: what?
14:11:28 <Syzygy-> One of the things I find myself frustrated with in mathematical programming (GAP to be specific) ends up being just the lack of typing and type information.
14:11:52 <Syzygy-> It's almost to the poitn where I want to write an algebra system of my own, in Haskell, in order to get enough bondage.
14:12:18 <Cale> Syzygy-: Yes, GAP is so good but they got the foundational language so wrong.
14:12:45 <Cale> I really really wish that GAP had been founded on something more like Haskell.
14:12:51 <Syzygy-> Ayup.
14:12:56 <Syzygy-> That would have been a joy working in.
14:13:20 <Syzygy-> OTOH, Magma has a strong type system. And can also do many of the things I need. Only, in Magma, it ends up being incomprehensible instead.
14:13:20 <Cale> I spend lots and lots of time in GAP fighting against aliasing of mutable objects.
14:13:27 <Syzygy-> Cale: Ayup.
14:13:31 <george--> any intrinsic functions that will turn a string (which is an int) to an int
14:13:31 <Cale> It's really hard to do anything immutably.
14:13:39 <Cale> george--: read
14:13:41 <LoganCapaldo> mmmm, map f is a functor mapping the morphism f : a -> b to the morphism f' : [a] -> [b] ?
14:13:46 <Cale> > read "53" :: Int
14:13:48 <lambdabot>  53
14:13:50 <Cale> > read "53" :: Integer
14:13:52 <lambdabot>  53
14:13:54 <Cale> > read "53" :: Double
14:13:56 <lambdabot>  53.0
14:14:08 <Cale> It's polymorphic in its result type.
14:14:10 <Syzygy-> Cale: Hopefully, my PhD is going to end with writing a GAP package. :)
14:14:19 <george--> ty
14:14:25 <Syzygy-> Or it'll end up with a Haskell system for working in group cohomology. Also a possible outcome.
14:14:36 <Cale> LoganCapaldo: ([],map) are the two halves of the list functor.
14:14:39 <Syzygy-> LoganCapaldo: Well ... map can be viewed as a functor.
14:14:54 <Syzygy-> > (+3) >>= [2,3,4]
14:14:54 <lambdabot>  Couldn't match `a -> a -> b' against `[a1]'
14:14:57 <Syzygy-> Doh.
14:14:59 <LoganCapaldo> Cale, yeah I couldn't figure out how to say [] was invovled too :)
14:15:06 <dbremner> Syzygy-is a binding possible?
14:15:19 <Syzygy-> > (+3) `fmap` [2,3,4]
14:15:20 <lambdabot>  [5,6,7]
14:15:22 <Syzygy-> That's it.
14:15:27 <Cale> A functor has two parts: a function on objects, and a function on morphisms. The type constructor for lists is the object part, and map is the morphism part.
14:15:43 <Syzygy-> > ([]) 3
14:15:43 <lambdabot>      The function `([])' is applied to one arguments,
14:15:44 <lambdabot>     but its type `[a]' ...
14:15:51 <Syzygy-> ?type ([])
14:15:53 <Cale> more like [] Integer
14:15:53 <lambdabot> forall a. [a]
14:15:59 <Cale> @kind []
14:16:01 <lambdabot> * -> *
14:16:04 <Syzygy-> Right.
14:16:06 <ddarius> > (:[]) 3
14:16:07 <lambdabot>  [3]
14:16:09 <ookk> dons, there?
14:16:16 <Syzygy-> Cale: Oh yeah. Doh.
14:16:18 <Cale> Yeah, we don't mean [] the empty list.
14:16:30 <Syzygy-> @kind [9 Integer
14:16:32 <lambdabot> parse error (possibly incorrect indentation)
14:16:35 <Syzygy-> @kind [] Integer
14:16:36 <Cale> It's [] the thing which wraps brackets around types. :)
14:16:37 <lambdabot> *
14:16:48 <Cale> @type [1,2,3] :: [] Integer
14:16:50 <lambdabot> [] Integer :: [Integer]
14:16:50 <thedward> > [2,3,4] >>= return . (+3)
14:16:52 <lambdabot>  [5,6,7]
14:17:16 <Cale> Man, that's still not fixed. If nobody does anything about that much longer, I might be goaded into writing a patch.
14:17:32 <Syzygy-> Cale: What's not fixed?
14:17:45 <allbery_b> <lambdabot> [] Integer :: [Integer]
14:17:47 <Cale> The @type command cuts at the first :: rather than the last.
14:17:55 <LoganCapaldo> And so maybe's fucntion for objects is Just and its functon for morphisms is fmap
14:18:10 <Cale> LoganCapaldo: no, it's Maybe
14:18:15 <Cale> Maybe and fmap
14:18:37 <Syzygy-> LoganCapaldo: Just is something that happens to elements. But the _objects_ in Hask are the _types_.
14:18:42 <Cale> Remember the object part of the functor has to take objects to objects. Objects in the case of Haskell are types.
14:18:50 <Syzygy-> So you need to figure what Maybe does on _types_.
14:18:54 <LoganCapaldo> Ooooooooooooooooooooooooooooooo
14:19:20 <LoganCapaldo> OOOO!
14:19:25 <sorear> O!
14:19:26 <Cale> hehe
14:19:44 <Syzygy-> I think LoganCapaldo just got an epiphany.
14:19:54 <Syzygy-> LoganCapaldo: Cherish the feeling. It's my driving force in life. :)
14:21:07 <joelr1> evening
14:21:38 <LoganCapaldo> Itkovian: Is your nick a reference to something?
14:21:52 <Itkovian> LoganCapaldo: Why?
14:22:04 <Itkovian> Does it remind you of something?
14:22:15 <LoganCapaldo> its the name of a character in a book I'm reading
14:22:19 <astrolabe> Hi joelr1
14:22:27 <Itkovian> And it's an excellent book, isn't it :-)
14:22:46 <LoganCapaldo> Just started house of chains actually :)
14:23:06 <Itkovian> Then you have some serious catching up to do, as Reaper's Gale will be out in March
14:23:38 <LoganCapaldo> I'm two books beind or just the one?
14:23:48 * LoganCapaldo is in the US if that makes a difference
14:24:27 <LoganCapaldo> Category theory _and_ Steve Erikson, a glorius combo ;)
14:24:41 <Syzygy-> Steve Erikson??
14:24:41 <george--> ok, i have a [(Int, String)]. What i want the program to do is for each one of these pairs I want it to ask the value, take this as input and then multiply it by the Int and add this value to a running total
14:24:51 <Itkovian> Steven, actually
14:25:00 <george--> think of it like a shopping list. the int is the number i want and the string is what i want
14:25:07 <george--> I want it to ask the user the cost of each
14:25:13 <george--> and then give a total shopping cost
14:25:14 <Itkovian> Erm, after HoC, there's Midnight Tides and then there's the Bonehunters
14:25:28 <george--> i just dont know how to do this with IO
14:25:38 <Saizan> foldM?
14:25:39 <Syzygy-> george--: Since you want to do something at each point and accumulate a result, you'll want to do some sort of fold. Getting the user interaction is trickier - I'm out of my league there.
14:25:46 <Syzygy-> ?type foldM
14:25:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:26:03 <Itkovian> LoganCapaldo: You can still order from the uk amazon site.
14:26:13 <LoganCapaldo> Itkovian: I may have to do that
14:26:20 <george--> im really not so fussed about doing this in an optimal way. just i dont know how to take a load of user inputs like this
14:26:26 <Itkovian> LoganCapaldo: I also recommend reading Knight of Knives, after you finished MT, and before you read the bonehunters
14:26:29 <LoganCapaldo> considering the date of printing on HoC is 2005
14:26:41 <Syzygy-> So, we'll have a int, b the (Int, String) and the (a -> b -> m a) the function that takes an int, a string, asks the string and reads the answer, returning it all into the IO monad...
14:27:04 <Cale> george--: well, when does the list end?
14:27:10 <Cale> george--: or should it loop forever?
14:27:11 * LoganCapaldo checks again
14:27:11 <Itkovian> I may be confusing the order of MT and HoC
14:27:17 <george--> cale: its from an input file
14:27:19 <LoganCapaldo> I hope not
14:27:20 <Cale> ah, okay
14:27:24 <george--> cale: about 50 items
14:27:27 <LoganCapaldo> cause I haven't read MT :)
14:27:41 <Cale> so you'll want to read the whole input file, and then break that into lines, and deal with it in a pure way from there.
14:27:44 <george--> so far my code reads in the file and makes this list of pairs
14:28:02 <Cale> do xs <- readFile "myFile"
14:28:12 <Syzygy-> george--: And after reading the list, you'll want to throw out a lot of user interaction, right?
14:28:12 <Cale>    let ls = lines xs
14:28:21 <george--> Syzygy-, yes
14:28:25 <Cale> Now ls :: [String]
14:28:44 <Cale> and in the rest of the do-block, you can worry about what you're going to print out.
14:28:55 <george--> Cale: my code reads in the file successfully, my problem is with getting the value of each item
14:28:57 <LoganCapaldo> Itkovian: Damn I live on the wrong side of the ocean. First edition over here is August 2006
14:29:03 <LoganCapaldo> (of HoC)
14:29:05 <Cale> okay, have you seen lookup?
14:29:10 <Cale> @type lookup
14:29:11 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
14:29:17 <astrolabe> george: maybe write a function (Int,String) -> IO Int, returning the product of the value times the quantitity.
14:29:25 <heatsink> Cale: I think the value of each item is not part of the input file, but entered interactively later.
14:29:26 <Cale> A list of pairs is a very inefficient way to handle a map like that though.
14:29:48 <george--> astrolabe, that is the function im asking for help to write now
14:30:21 <george--> Cale, im not aiming for efficiency so much, just a quick solution to a real practical problem i have :)
14:30:26 <Cale> okay
14:30:34 <Cale> But consider learning about Data.Map
14:30:42 <Syzygy-> Hey look at that.
14:30:43 <Itkovian> Cale: how about putting that list into a Map first?
14:30:45 <Cale> Because it's much nicer than working with lists of pairs.
14:30:54 * Syzygy- managed to figure something out that typechecks and seems right.
14:30:59 * Itkovian is too late once more
14:31:01 <Syzygy-> \(a,b) -> putStrLn b >> getContents >>= read >>= (*a)
14:31:11 <Saizan> foldM (\acc (i,name) -> putStr name >> getLine >>= \l -> let l' = read l in return acc+i*l) list, something like this?
14:31:19 <Cale> george--: Okay, so you read in this file, and then what?
14:31:23 <astrolabe> george  get_val (number,name) = do{putStr ("what is the val of " ++ name);valStr <- getStr;return read getStr * number}
14:31:29 <Cale> You're going to interact with the user somehow...
14:31:36 <george--> Cale, I am relatively familiar with map, i just finished a project (beginners haskell level) using it. unfortunately, 4 weeks without using haskell my mind is fried. So im using it to solve a real problem and also a little revision for exams n summer
14:31:36 <jcreigh> ask_for_whatever (i, prompt) = putStr prompt >> getLine >>= return . (*i) . read
14:31:37 <Cale> Or just print stuff?
14:31:39 <Syzygy-> No wait.
14:31:46 <Syzygy-> That doesn't work. It has IO IO b occuring.
14:31:57 <Cale> george--: not map as in the list function, Data.Map, the data structure.
14:32:12 <george--> Cale, that is what im refering to also :)
14:32:15 <Cale> ah, okay :)
14:32:19 <Cale> just checking :)
14:32:23 <jcreigh> with ask_for_whatever :: (Int, String) -> IO Int
14:32:28 <Cale> one sec :)
14:32:33 <astrolabe> Cale: why is Data.Map nicer in this instance?
14:33:09 <george--> lookups i believe are less cost
14:33:21 <george--> atleast, that is why i was told to use it in my last project ;)
14:33:59 <Syzygy-> \(a,b) -> putStrLn b >> getContents >>= read >>= (\x -> return (x*a))
14:34:03 <Syzygy-> That seems to typecheck.
14:34:04 <jcreigh> george--: ^^ Does ask_for_whatever do what you had in mind?
14:34:27 <george--> jcreigh, im just trying this, and the solution by saizan ou now ;)
14:34:40 <Cale> astrolabe: It's almost always nicer than [(a,b)] for a lookup table.
14:34:54 <Syzygy-> No....
14:34:59 <Cale> It's faster, and supports a wide range of operations.
14:35:00 <Syzygy-> My solution still isn't.
14:35:01 <jcreigh> Syzygy-: I don't think "read" is in the IO monad.
14:35:07 <Syzygy-> jcreigh: No, it isn't.
14:35:07 <astrolabe> Cale: this isn't a lookup table is it?
14:35:11 <Saizan> mine lacks a 0 for the initial state of the accumulator
14:35:18 <Syzygy-> And if I enter a fmap, it wants to read chars.
14:35:24 <Cale> Well, I don't know, I suspect that it is, based on what george-- said.
14:35:41 <Cale> I still don't completely understand the application.
14:36:02 <astrolabe> george--: ok, i have a [(Int, String)]. What i want the program to do is for each one of these pairs I want it to ask the value, take this as input and then multiply it by the Int and add this value to a running total
14:36:16 <Cale> ah, okay
14:36:18 <astrolabe> He has a list of (quantity, name) pairs
14:36:38 <Cale> and the user is going to interact with each of them in turn?
14:36:46 <astrolabe> Cale: I think so yes
14:36:48 <Cale> okay
14:36:53 <Cale> then it's a mapM/forM
14:37:13 <jcreigh> george--: armed with a function of type (Int, String) -> IO Int, you can now use mapM: mapM ask_for_whatever [(2, "hi there"), (7, "goober")]
14:37:21 <Cale> mapM interactionWithPair listOfPairs
14:37:26 <Syzygy-> Cale: And he's supposed to accumulate stuff. Will you do that with a mapM? Or do you need a foldM?
14:37:30 <astrolabe> I think george might be suffering from data overload at the moment.
14:37:36 * Syzygy- still believes in the foldM.
14:37:40 <Cale> Syzygy-: I'd do it afterward with a pure function.
14:37:52 <Cale> Or is it supposed to print the running total?
14:37:58 <jcreigh> the mapM will get you IO [Int], and you can bind it to something and sum the list.
14:38:00 <Syzygy-> Cale: Good point.
14:38:20 <george--> 'bind it to something and sum the list'
14:38:24 <george--> that is a little hazy for me :)
14:38:25 <Syzygy-> Cale: So fmap sum $ mapM questions pairlist -- or something like this
14:38:34 <Cale> Syzygy-: exactly
14:38:59 <Cale> george--: The result of mapM will be an action which runs to produce a list of results
14:39:00 <LoganCapaldo> george--: x <- mapM interactWithPair listOfPairs; sum x is what it would look like
14:39:05 <jcreigh> george--: like listOfInts <- mapM ask_for_whatever pairlist
14:39:30 <jcreigh> or >>= instead of do-notation, of course.
14:39:34 <Cale> george--: specifically, the results of each interaction -- probably in your case, the product of the value from the file with what the user entered
14:40:34 <Cale> mapM is just like a "foreach" loop, but in addition to looping, it captures the result of each loop iteration into a list.
14:41:16 <Cale> LoganCapaldo: careful, sum x will not be an action
14:41:26 <Cale> you'll probably want to do something like print the sum
14:41:38 <LoganCapaldo> Cale: This is what I get for being only slightly less vague :)
14:41:47 <LoganCapaldo> Instead of all the way less vague
14:41:47 <Syzygy-> return (sum x) -- may do the trick. :)
14:41:52 <Cale> right
14:42:14 <Cale> george--: is that making sense? Should I write you a small sample application?
14:42:17 <LoganCapaldo> Besides the compiler would have yelled at him any way if he copied and pasted :)
14:42:27 <george--> Cale, so far im good i think :)
14:42:33 <Cale> okay, great :)
14:42:36 <george--> ill try and run this on a sample data and see where i get stuck
14:42:36 <LoganCapaldo> #haskell is the only channel I feel safe in giving bad code
14:43:09 <george--> its a shame, i study physics with 1 comp sci module, and the only place i get good help is this module... all #physics channels are poor for help :)
14:43:16 <LoganCapaldo> I'm forever checking to make sure my advice is right in #ruby-lang :)
14:44:46 <ibid> what's the best way to get access in a program to its version number, which is specified in the cabal file?
14:44:48 <sorear> @quote tropic
14:44:49 <lambdabot> dons says: not sure that the irc culture outside happy lambda land is always so warm and tropical
14:44:57 <astrolabe> george: You'd probably get better physics help here if you don't get told off for being off topic
14:45:27 <Cale> george--: yeah, #math is more likely to get you help on physics problems, but you have to strip out the physics first usually :)
14:45:51 * Cale sips rooibos tea.
14:46:39 <george--> math is good, except in physics that isnt normally the problem, it is the underlying physics and then the math is generally easy
14:46:55 <george--> atleast, you should have a good indication if values are within magnitude of what you expect
14:47:10 <george--> it is rare that the pure math stumps me :)
14:50:39 <ibid> ah, there is a VersionTool
14:58:20 * LoganCapaldo reads about curry howard
14:58:26 <LoganCapaldo> fascinating
15:01:39 <Syzygy-> @pl curry . uncurry
15:01:43 <lambdabot> id
15:02:17 <Saizan> so, given this: http://planetmath.org/encyclopedia/Monad.html , if T is the type constructor and fmap, what are eta and mu? i was thinking of return and join, but they doesn't fit so well
15:02:20 <JohnnyL> man i remember when #haskell only had 75 people in it.. and that wasen't too long ago!
15:02:23 <lambdabot> Title: PlanetMath: monad
15:03:04 <Philippa> Saizan: you've got it, though
15:03:23 <LoganCapaldo> mu must be join
15:04:03 <Syzygy-> Yup
15:04:14 <Syzygy-> And eta is return
15:04:34 <Saizan> so, how do you write mu . T . eta in haskell?
15:04:47 <Syzygy-> Note, also, that mu and eta form a monoid in another category
15:04:48 <Cale> mu is join, eta is return
15:05:18 <Cale> T is fmap/liftM
15:05:32 <Saizan> ?ty join.fmap.return
15:05:34 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
15:05:35 <lambdabot>       Expected type: a2 -> f a -> f a -> a1
15:05:36 <Cale> (and the corresponding function on types)
15:06:07 <Cale> @type join . (fmap return)
15:06:09 <lambdabot> forall a (m :: * -> *). (Functor m, Monad m) => m a -> m a
15:06:24 <Saizan> ooh
15:07:28 <Cale> Those are a little confusing to translate directly.
15:08:23 <Saizan> @type join . (return fmap) --?
15:08:25 <lambdabot> forall a b. a -> (b -> b) -> b -> b
15:11:09 <Saizan> well they are probably at a different level, haskell functions are on elements, not on objects, right?
15:11:09 <xic> will ghc compiler ever optimize by "unrolling loops" on a fold/map that works with a compile-time-fixed-size list?
15:12:14 <TuringTest> xic :  You could use template haskell ...
15:12:57 <Cale> Saizan: functions on objects are represented by type constructors
15:13:24 <sorear> xic: I believe so ... but you'd be much better off using an array, if it truly is fixed size
15:14:24 <xic> sorear: i'm wondering if there's a difference betwen writing code like "a + b + c + d" vs "foldr (+) 0 [a, b, c, d]"
15:14:24 <sorear> xic: one very nice thing about FP is that it simplifies optimizing compilers.  GHC has no loop unrolling support, and doesn't need it, because in a FP language like Haskell loop unrolling is just a special case of inlining.
15:14:48 <sorear> xic: foldr (+) 0 [a] / a --> no difference
15:15:11 <sorear> xic: in the source for GHC.Base, which for unrelated reasons I was reading a few minutes ago,
15:15:18 <Cale> Er, I don't think it actually does that transformation in GHC at the moment though, does it?
15:15:28 <Cale> It would have to know that a + 0 = a
15:15:34 <Cale> which it probably can't know.
15:15:46 <sorear> it says that the full foldr/cons rule is disabled because with VERY long lists it causes bloat.
15:15:56 <sorear> Cale: it would optimize sum [x] to a + 0
15:16:09 <sorear> surely gcc knows the integers form a monoid :)
15:16:20 <Cale> sorear: But it can't know that + is implemented correctly.
15:16:39 <LoganCapaldo> unsafePerformAddition eh?
15:16:47 <Cale> @type (+)
15:16:49 <lambdabot> forall a. (Num a) => a -> a -> a
15:17:07 <Cale> If I write my own instance of Num, I can break that rule.
15:17:16 <sorear> Cale: yes it can.  we're talking g*c*c here, and gcc has access to the intel programmer's manual wrt *integers*
15:17:44 <LoganCapaldo> Does gcc have sum [x]?
15:17:47 <sorear> (besides, even in the general case, doesn't Num have proof obligations?)
15:18:17 <sorear> ghc turns sum [x] into x + 0, and since you specified -O2 -fvia-C, gcc turns x + 0 into x
15:18:19 <Cale> Not such strong proof obligations that the compiler could rely on them.
15:18:49 <Cale> x + 0 is really x + fromInteger 0
15:19:24 <sorear> ... and fromInteger must be a group homomorphism.
15:19:27 <Cale> and then after class translation there will be a dictionary parameter.
15:19:35 <LoganCapaldo> why doesn't Haskell just decide that sum [x] = x ? Can't you do that with one of those fancy rewrite rules?
15:19:36 <Cale> No it doesn't have to be.
15:19:39 <Cale> It should be
15:19:43 <Cale> But it might not be.
15:20:10 <sorear> Cale: we have Ix laws that miscompile if you break them, why not Num laws?
15:20:30 <Cale> Well, sure, I'm talking about what GHC is actually going to do though.
15:20:56 <Cale> Num laws are much more vague due to the desire to have things like Float and Double in Num.
15:21:03 <Igloo> You could rewrite it to 0 + x which should get constant folded if the type is known to be Int/Integer
15:21:29 <Cale> fromInteger isn't a group homomorphism on Float because Floats don't even form an additive group.
15:21:59 <sorear> they do form a commutative magma with an identity - is that good enough?
15:22:50 <Anon4888> Has anybody looked at making a Real type that is treated like an honest-to-goodness Real until the very end, at which point it is approximated with Float?
15:23:33 <xic> Cale: is a polymorphic function compiled to only a single c function? it's not like c++ where it's compiled to a seperate function for each possible type?
15:24:11 <sorear> xic: only one function
15:24:36 <sorear> xic: if you want multiple functions, use {-# SPECIALIZE foo :: Int -> Int #-} pragmas
15:24:45 <ookk> only one function for each type you use it on i would say?
15:25:07 <ookk> _one_ c function take different types of arguments
15:25:12 <ookk> cannt*
15:25:14 <ookk> cannot*
15:25:32 <xic> sorear: why doesn't ghc detect during compile time which specializations are used, and automatically add such SPECIALIZE pragmas?
15:25:43 <TuringTest> SUPER SPECIALIZE?
15:25:48 <augustss> xic: it does
15:25:54 <LoganCapaldo> Specialization infeference>
15:25:56 <LoganCapaldo> ?
15:25:58 <LoganCapaldo> heh
15:26:03 <augustss> xic: if you compile with optimization
15:26:17 <augustss> xic: but only within a single module
15:26:51 <sorear> TuringTest: JHC has a SUPERSPECIALIZE pragma
15:26:53 <augustss> xic: it doesn't go back and recompile modules that were not compiled with the right specialization
15:27:04 <TuringTest> sorear: So I have read...
15:27:15 <sorear> TuringTest: and MULTISPECIALIZE, which would do what we're talking about here
15:27:19 <augustss> If you do whole program optimization that's easy
15:27:58 <augustss> (except that you'll have to stop specializing at some point since there can be an unbounded number of instances in a program)
15:29:19 <xic> it seems to me that there is still a lot more room for automatic optimizations in ghc
15:29:45 <sorear> this suprises you? :)
15:30:00 <augustss> xic: sure.  there always.  it's "theorem of perpetual compiler write employment"
15:30:00 <sorear> haskell is very fertile optimization territory
15:30:41 <heatsink> because the baseline is so slow. ;)
15:30:44 <xic> does ghc do any whole program optimization at all?
15:30:59 <sorear> @quote augustss sure.  there always.  it's "theorem of perpetual compiler write employment"
15:30:59 <heatsink> xic: it does inlining across modules
15:31:00 <lambdabot> No quotes match. My pet ferret can type better than you!
15:31:06 <sorear> @remember augustss sure.  there always.  it's "theorem of perpetual compiler write employment"
15:31:07 <lambdabot> Done.
15:31:27 <augustss> you cound have fixed the spelling ;)
15:31:44 <sorear> cound, eh? :)
15:31:45 <Anon4888> @remember augustss you cound have fixed the spelling ;)
15:31:46 <lambdabot> Done.
15:31:48 <Anon4888> :P
15:31:50 <augustss> lol
15:31:51 <xerox> haha
15:32:06 <Syzygy-> Haha
15:32:21 <augustss> I wish I were drunk.  I should be to have this many typos.
15:32:21 <Syzygy-> augustss: If you spel well, you'll have to live with the consequitur.
15:33:36 <dmead> boink
15:33:42 <sorear> bing!
15:33:46 <dmead> hey
15:33:49 <dmead> whats a good book
15:33:52 <dmead> on predicate calculus
15:33:56 <dmead> or predicate logic
15:34:07 <dmead> if anyone like
15:34:11 <dmead> knows about that stuff =)
15:36:24 <sorear> emacs 22 says I need to restart after an upgrade ... what nerve
15:38:39 <sorear> :(
15:39:26 <heatsink> restart emacs, or restart your computer?
15:39:39 <dmead> emacs is his computer, man
15:40:28 <heatsink> Is it an operating system or a virtual machine? Make up your mind!
15:41:18 <sorear> according to the definition of OS I came up with years before I knew what free software was, emacs is an OS.
15:41:20 <heatsink> cool.  My monad-transformer-like combinators appear to work.  But they require -fallow-incoherent-instances.
15:41:29 <sorear> unsuprising
15:41:43 <sorear> -fallow-useful-code
15:41:51 <heatsink> heh
15:41:58 <Eighty> how can i make instances of my class automatically get a show method (that can be overridden)?
15:42:02 <Eighty> i've tried these:
15:42:11 <hpaste>  Eighty pasted "automatic show" at http://hpaste.org/444
15:42:15 <sorear> Eighty: go to haskell-prime@haskell.org, and beg.
15:42:41 <bd_> Eighty: Try the latter with -fallow-incoherent-instances?
15:42:49 <heatsink> Eighty: you can define it in the class body just like you would in the instance body.
15:42:51 <sorear> Eighty: you want subclasses to be able to provide default methods of superclasses
15:43:03 <sorear> Eighty: but you Can't Do That.
15:43:11 <Eighty> alrighty then
15:43:12 <augustss> yet
15:43:23 <sorear> @wiki Class_hierarchy_proposal
15:43:24 <lambdabot> http://www.haskell.org/haskellwiki/Class_hierarchy_proposal
15:43:26 <sorear> ^^^ iirc
15:43:47 <Eighty> hehe, "there is currently no text on this page"
15:44:10 <augustss> I had a reasonable proposal, but since it only works well for single parameter classes I never posted it.
15:44:17 <jcreigh> "error: there was no error" -- Dreamweaver
15:44:39 <sorear> @wiki Class_system_extension_proposal
15:44:39 <lambdabot> http://www.haskell.org/haskellwiki/Class_system_extension_proposal
15:44:42 <sorear> ^^^ correct
15:44:42 <heatsink> jcreigh: visit thedailywtf?
15:44:55 <sorear> augustss: how does it compare to the wiki's csep?
15:45:40 <jcreigh> heatsink: yeah, I've seen it there. Some guys at $WORK have seen that actual message as well.
15:47:11 <augustss> sorear: very, very similar
15:47:46 <augustss> but I remember that there are some murky bits in this when you try to work out all the details.
15:51:55 <nrb23> is it possible to use runhaskell to run a haskell program that needs a -lpcap to link?
15:52:35 <sorear> runhaskell -optl-lpcap ... ?
15:52:46 <sorear> (might be -optL)
15:52:59 <nrb23> does runhaskell actually compile the thing first?
15:53:03 <sorear> yes
15:53:07 <sorear> and second
15:53:10 <sorear> and third
15:53:12 <nrb23> hm
15:53:14 <sorear> and fourth
15:53:15 <sorear> ...
15:54:12 <sorear> actually I think it uses ghci by default -- faster than C/asm generation, but it still has to parse and typecheck your entire program every time
15:54:14 <nrb23> ahh, it's optl
15:54:27 <nrb23> and it needs to go before the .hs file
15:54:52 <sorear> anything after the filename is an argument to your program
15:55:03 <sorear> runhaskell is designed for unix shebangs
15:55:18 <nrb23> ah
15:55:26 <nrb23> makes sense
15:56:10 <nrb23> so, it doesn't have to do a full compile... it still runs it through some bytecode runtime thing
15:56:19 <nrb23> (I come from the O'Caml world)
15:56:44 <nrb23> (actually, I come from the C world... I work on embedded systems0
15:57:30 <nornagon> does haskell compile to arm yet? :)
15:57:46 <nornagon> i guess it could if it went through gcc
15:57:47 <nrb23> seems it could
15:57:52 <nornagon> but it might not be very optimised
15:58:07 <sorear> nornagon: JHC :: Haskell -> ANSI_C ; GCC :: ANSI_C -> Arm ; GCC . JHC :: Haskell -> Arm
15:58:27 <sorear> GHC does *not* generate remotely portable code
15:58:48 <nrb23> GHC generates GCC-portable code though, right?
15:59:01 <sorear> (I do believe GHC targets Arm, but if it didn't, you'd be mostly out of luck)
15:59:04 <Philippa> nrb23: no
15:59:09 <Philippa> it's platform-specific
15:59:24 <Philippa> yes, there's GHC on arm
15:59:31 <sorear> Philippa: how platform-specific is -unreg GHC output?
15:59:37 <nrb23> ARM is nice
15:59:42 <Philippa> sorear: still at least somewhat
16:00:04 <sorear> nrb23: also Yhi is ansi C
16:00:08 <Philippa> my ARM machine is nice, certainly. Well, all three of them, but I'm not keen on coding on the GBA or the DS
16:00:20 <sorear> hehe.
16:00:26 <sorear> what's the third?
16:00:32 <nrb23> I have a whole pile of ARM processors at work
16:00:32 <mbishop> what about a jornada?
16:00:36 <Philippa> a Sharp Zaurus SL-C3200
16:00:37 * mbishop pets his jornada
16:00:54 <nornagon> JHC?
16:00:59 <gotaku> @source State
16:00:59 <lambdabot> State not available
16:01:00 <sorear> JohnMeacham
16:01:02 <nornagon> Philippa: i do DS coding :)
16:01:06 <sorear> JohnMeacham's haskell compiler
16:01:20 <sorear> @where jhc
16:01:21 <lambdabot> http://repetae.net/john/computer/jhc/
16:01:26 <Philippa> I'm largely happy to stay away from gamedev these days
16:01:26 <ihope> > let foo = head $ filter perfect [1,3..] where perfect x = sum (divisors x) == x; divisors x = [ y | y <- [1..x-1], x `mod` y == 0 ] in foo
16:01:28 <gotaku> How do I get the source for the State monad again?
16:01:31 <lambdabot> Terminated
16:01:49 <sorear> ^^^ if you have less than a half gig of memory, don't even TRY to use this
16:02:01 <sorear> @src State (>>=)
16:02:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:02:06 <ihope> > let foo = head $ filter perfect [7..] where perfect x = sum (divisors x) == x; divisors x = [ y | y <- [1..x-1], x `mod` y == 0 ] in foo
16:02:08 <lambdabot>  28
16:02:12 <sorear> @. source index State
16:02:13 <lambdabot>  not available
16:02:23 <sorear> @source Control.Monad.State
16:02:24 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
16:03:08 <augustss> the question if there are any odd perfect numbers is still open, right?
16:03:16 <sorear> iirc
16:04:13 <nrb23> man, sometimes I wonder if my math skills are good enough for haskell
16:05:18 <sorear> it's just elementary number theory!  how can you not know that!  :p :p
16:07:14 <fasta> I wondered whether the complexity of a question implies a lower-bound of a possible counter-example.
16:07:16 * nrb23 was never very good at math
16:07:20 <astrolabe> http://en.wikipedia.org/wiki/Perfect_number#Odd_perfect_numbers
16:10:40 * nrb23 still isn't good at math
16:10:40 <fasta> (Intuitively, it would be odd if the first counter-example for, IIRC, the Riemann hypothesis would contain 100 billion(or some other "large number") numbers. I have no formal basis to support this, of course, but I wouldn't be surprised if there was...)
16:11:39 <augustss> fasta: but some very large numbers have been used in mathematical proofs
16:11:54 <fasta> augustss: true
16:12:12 <fasta> augustss: I never said it was a good idea ;)
16:12:18 <nrb23> big numbers likek
16:12:28 <nrb23> > floor(2/0)
16:12:29 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
16:12:40 <nrb23> > floor(2/0) == 2**128
16:12:41 <lambdabot>  Add a type signature
16:12:41 <augustss> fasta: but I agree with you :)
16:12:42 <dons> ookk: around?
16:13:16 <augustss> nrb23: lol, looks like somebody forgot to test for infinity (could be me)
16:13:32 <ookk> dons, yeah
16:13:45 <nrb23> augustss: yeah, it's funky
16:13:46 <ookk> dons, i got the nbody to run 1.5x the fastest c++ entry on my machine
16:13:53 <dons> ookk, so I saw some fast code eh?
16:13:56 <dons> yeah!
16:14:00 <dons> is the code on the wiki?
16:14:03 <ddarius> fasta: The first counter-example to two approximations of the distributions of primes being lower and upper bounds is an obscenely large number.
16:14:23 <ookk> dons, no, maybe i should ad it?
16:14:36 <dons> well, do you intend to submit it?
16:14:46 <dons> yeah, you should add it. or at least hpaste.org it
16:14:48 <ddarius> Then, of course, there is the monster group.
16:14:52 <ookk> i already have submited it to the shootout
16:14:59 <ookk> ?paste
16:15:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:15:05 <dons> heh cool.
16:15:08 <dons> i'll get it from there.
16:15:20 <hpaste>  ookk pasted "nbody" at http://hpaste.org/445
16:15:36 <ookk> hmm i cant hpaste it
16:15:38 <ookk> it cuts off
16:15:51 <augustss> nrb23: large numbers like http://en.wikipedia.org/wiki/Skewes%27_number
16:16:07 <dons> oh, you should remove the optc-ffast-math -optc-mfpmath=sse -optc-msse2 flags from the pragma
16:16:12 <dons> and ask them to be put in the Makefile
16:16:23 <nrb23> augustss: yes, that's big
16:16:30 <ookk> dons, i have asked them to do that, but does it matter if they are in the pragma?
16:16:40 <dons> I think it will break on amd64
16:16:44 <dons> the other shootout box
16:16:55 <ookk> oh i didnt think about that
16:17:25 <dons> you could upload a replacement that has only -fexcess-precision in the pragma
16:17:35 <dons> and everything else in the Makefile, 'cept the already globale flags
16:17:45 <ookk> i need -fbang-patterns
16:17:47 <dons> which are fglasgow-exts -O3 -optc-O2
16:18:00 <dons> also, -optc-ffast-math isn't consideered legal
16:18:04 <dons> so they'll probably remove that
16:18:22 <nrb23> can someone explain the usage of shows vs show?
16:18:39 <ookk> dons, ok
16:18:39 <augustss> :t show
16:18:41 <lambdabot> forall a. (Show a) => a -> String
16:18:46 <augustss> :t shows
16:18:48 <lambdabot> forall a. (Show a) => a -> ShowS
16:19:08 <dons> ookk, code looks very nice!
16:19:20 <nrb23> that's not quite what I get in ghci
16:19:22 <dons> note that you don't have to write let multiple times to define a bunch of values
16:19:25 <dons> let x = ...
16:19:27 <dons>     y = ...
16:19:29 <dons> is ok
16:19:32 <dons> and compresses better
16:19:44 <augustss> > shows (42::Int) "foo"
16:19:45 <lambdabot>  "42foo"
16:20:01 <ookk> let x = f y
16:20:07 <ookk>    y = z
16:20:12 <ookk> is that possible?
16:20:48 <allbery_b> why not?
16:20:50 <dons> yeah, if x and y align
16:21:03 <ookk> dons, i cannot edit the wiki
16:21:10 <ookk> dons, and hpaste wont let me paste the whole thing
16:21:14 <dons> do you have an account?
16:21:19 <dons> you have to just register your name.
16:21:42 <nrb23> is shows x $ show y better than show x ++ show y
16:21:52 <ookk> nah i dont have an account, you dont need any privileges to sign up?
16:21:57 <augustss> ookk: is mallocBytes etc really faster than an unboxed array?
16:21:58 <dons> nope
16:22:04 <Eighty> ookk: what does the ! in "new !d =" do?
16:22:22 <Eighty> do you need a compiler option for that?
16:22:29 <ookk> Eighty, -fbang-patterns
16:22:35 <ookk> makes it strict
16:22:49 <ookk> i dont think that makes any difference in speed there
16:22:56 <ookk> i just added it for good measure :P
16:23:03 <augustss> ookk: but it's so ugly
16:23:15 <dons> i've seen times where the Ptr-based arrays are faster
16:23:24 <dons> probably because they have less levels for the compiler to unravel
16:23:32 <augustss> sad
16:23:33 <Eighty> is it equivalentto new d = d `deepSeq` ...?
16:23:38 <dons> a ghc bug, almsot.
16:23:42 <augustss> all this belongs in ST
16:23:47 <ookk> augustss, well this is not for beauty, its for speed
16:23:58 <ookk> but i hide all the ugly stuff behind nicer functions
16:24:01 <augustss> ookk: but people will look at the code
16:24:24 <Philippa> and then throw up, and then forget it but have nightmares inspired by it...
16:24:33 <ookk> audreyt, an IOUArray with unsafeRead / unsafeWrite doesnt look to nice either
16:24:35 <augustss> ookk: yes, overall I think your code looks nice, but just the fact that it has a mallocBytes makes it tarnished :)
16:24:45 <Philippa> I may be being a little harsh :-)
16:25:11 <dons> its not that ugly. :-) compared to the old nbody entry....
16:25:17 <Philippa> unsafeRead/Write are at least honest about what you're doing that's 'dirty'
16:25:21 <augustss> ookk: I'd rather have it in ST with unsafeRead and unsafeWrite.
16:25:22 <nrb23> anyone have a sugestion on using shows vs show ++ ?
16:25:49 <augustss> nrb23: shows is more efficient if you are showing big things
16:25:56 <ookk> augustss, i might try that later, but i think it will decrease performance
16:26:06 <nrb23> augustss: how big is "big" ?
16:26:14 <augustss> ookk: if it does, it's a good thing to fix in GHC
16:26:45 <augustss> nrb23: shows is always more efficient, but I would worry unless you have thousands of characters
16:26:56 <augustss> s/would/wouldn't/
16:27:06 <nrb23> well, I have 1000's in total
16:27:12 <nrb23> so, I'll go for it
16:27:15 <augustss> nrb23: do
16:27:26 <nrb23> basically, the idea is shows x $ shows y $ show z, right?
16:28:05 <augustss> yeah.  and if you are defining a Show instance, then you should define the showsPrec function, not the show function
16:28:18 <nrb23> ah
16:28:20 <dons> ookk++ beats gcc on my box
16:28:29 <augustss> ookk++
16:28:41 <dons> gcc, ./a.out 2000000  3.73s user 0.00s system 99% cpu 3.741 total. ghc, ./E 2000000  3.39s user 0.00s system 99% cpu 3.406 total
16:28:57 <augustss> nice!
16:29:53 <ookk> augustss, what cpu do you have?
16:30:27 <Axioplase> dons: you should run it at least a dozen times and then calculate the mean time...
16:30:36 <ookk> or dons i mean
16:30:40 <augustss> well, i've not run it, but I have a 2GHz Intel Core Duo
16:30:44 <ookk> http://haskell.org/haskellwiki/Shootout/Nbody#Proposed_entry
16:30:46 <lambdabot> Title: Shootout/Nbody - HaskellWiki
16:30:53 <dons> ookk, Pentium M, 1.6ghz
16:30:56 <ookk> i have added it to the wikie
16:31:01 <dons> thanks
16:31:03 <ookk> augustss, macbook pro?
16:31:06 <dons> i might have a play with this today
16:31:26 <dons> check the Core, there's some things I'd normally consider 'worrying' for performance :-)
16:31:40 <ookk> dons, i think it has an advantage of looking more readable then previous entries aslo :)
16:31:40 <augustss> ookk: non-pro
16:31:54 <dons> ookk, definitely!
16:32:58 <ookk> dons, it will be interesting to se how it does on the shootout machine
16:33:17 <ookk> dons, on my machine the c++ entry runs at 14s and my entry runs at 20.3s
16:33:34 <nrb23> so, why is shows faster?
16:33:51 <ookk> dons, i also noticed that if i add a "module Main where" it runs slower
16:35:10 <allbery_b> (++) does an extra copy,I think
16:35:30 <ookk> dobs ill post a FIXED on the shootout about those flags
16:35:33 <ookk> dons*
16:36:42 <augustss> ookk: you need to add module Main(main)
16:37:02 <augustss> ookk: otherwise all the functions are exported and can't be optimized as much
16:37:29 <dons> also, the {- -} style comments aren't removed by the shootout lexer. so best to use -- style.
16:37:41 <dons> yeah, that's why. so also best not to include module Main at all
16:38:17 <ookk> dons, what do you mean by not removed?
16:38:24 <dons> ookk, there's points for compressibility, so removing the parens, in e.g. vel1 -= (m2 *. mass_magn) is worth points
16:38:25 <ddarius> Google doesn't index the Haskell mailinglists anymore?
16:38:37 <dons> to count the code size
16:38:37 <dons> they strip the comments, and compress with gzip
16:38:47 <ookk> dons, aha
16:39:08 <ookk> dons, well then i should remove unnecessary type declatations to
16:39:35 <ookk> but i have found that removing these declarations slow the program down for some reason
16:39:57 <ookk> maybe it is because they become unnecessary polymorphic?
16:42:11 <nornagon> hm, can one define functions like a `f` b = ...?
16:42:25 <augustss> yes
16:42:37 <hpaste>  dons pasted "tighter advance function" at http://hpaste.org/446
16:42:49 <ddarius> nrb23: See http://www.mail-archive.com/haskell-cafe@haskell.org/msg02820.html
16:42:52 <lambdabot> Title: Re: powerset, http://tinyurl.com/ytsqvl
16:42:58 <augustss> > let a `f` b = a+b in f 1 2
16:42:59 <lambdabot>  3
16:44:02 <ookk> dons, also they dont really clearly define what is legal or not in the benchmark
16:44:34 <ookk> for instance, this is illegal: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=csharp&id=2
16:44:36 <lambdabot> Title: n-body C# Mono #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer L ..., http://tinyurl.com/27uhvh
16:44:39 <ookk> but this is not
16:44:40 <ookk> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=ocaml&id=0
16:44:42 <lambdabot> Title: n-body OCaml program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langua ..., http://tinyurl.com/yv3zjw
16:44:59 <ookk> maybe they just dont know ocaml enough to know what it does?
16:46:01 * ddarius had forgotten "Woh-pah!"
16:46:58 <ookk> dons, is there a speed difference with the modifed advance?
16:47:50 <dons> seems a tiny bit faster, but i couldn't be sure. its shorter though.
16:47:56 <ookk> dons, i just submitted a FIXED without seeing your modification :P
16:48:23 <ookk> well i guess well have to gather modifcations and submit them all at once
16:48:27 <ookk> instead of 100 fixes
16:48:47 <ookk> i just want to get the entry tested on their machine as soon as possible
16:48:59 <ookk> because then we really know how fast it goes
16:49:00 <nrb23> ddarius: thanks
16:49:36 <ookk> dons, also the energy and offset_momentum functions could be written in a more functional way, since they have zero effect on performance
16:50:03 <ookk> dons, but since i already had written an imperative interface to that Ptr Double i though i might aswell use it there to
16:52:00 <dons> ookk, yeah, i'd just submit what you have, and then in a day or two, we can submit the best version
16:52:18 <dons> oh, when submitting updates to an entry, its best to annotate an original submission
16:52:25 <dons> (in future)
16:53:04 <ookk> ah ok i though that was what FIXED was for
16:53:14 <dons> hmm. maybe. i'm sure its ok anyway
16:53:26 <dons> i'll have a play around today with the code anyway.
16:54:15 <ookk> hope you can speed it up, im not so proficient at reading core-dumps so i probably wont :)
16:54:50 <augustss> where are unsafe{Read,Write}Array?
16:55:00 <ookk> Foreign
16:55:04 <dons> Data.Array.Base
16:55:17 <dons> ?hoogle unsafeRead
16:55:17 <lambdabot> No matches found
16:55:18 <ookk> yeah Data.Array.Base sorry my bad
16:55:27 <ookk> and its unsafeRead not unsafeReadArray
16:55:38 <augustss> oh, ok
16:56:08 <augustss> i never use unsafe stuff ;)
16:56:08 <dons> augustss: make sure to put -fexcess-precision in a pragma. ghc silently ignores that on the command line atm.
16:56:22 <ookk> augustss,  heh
16:56:30 <ookk> well i dont see why unsafe* isnt the default
16:56:41 <ookk> you do the bounds check in your functions / loops whatever anyway
16:56:42 <dons> heh
16:56:56 <dons> cause random segfaults are scary, compared to checked exceptions
16:57:01 <augustss> ookk: i hope you are joking
16:57:17 <ookk> no im not :)
16:57:36 <dons> it really feels very unsafe when you use them
16:57:37 <augustss> the only way the unsafeRead and writes should happen is inside a trusted kernel, a la Oleg
16:57:37 <ddarius> Simply use Oleg's Bounded index thingies.
16:57:57 <dons> simple and oleg in the same sentence?
16:58:28 <augustss> ookk: the default for a language should NEVER be to be able to segfault.  if you want that possibility, you should turn it on
16:58:54 <ookk> augustss, yeah you are right
16:59:18 <ookk> augustss, those who want no bounds check know what they are doing, and should use non-default stuff
16:59:29 <augustss> But Oleg has shown us how to do it nicely
16:59:45 <ddarius> dons: I don't know.  Oleg and I independently posted the same example of simulating dependent types at the same time.
17:00:10 <ookk> augustss, what do you meen by nicely?
17:01:11 <augustss> ookk: you can put the unsafe stuff in a small piece of code than you can hope to understand, and then you use that
17:02:36 <ddarius> That's nice.  Someone inserted spam into the middle of my code.
17:03:10 <ookk> augustss, how does that help?
17:03:29 <ookk> augustss, you can not guarantee that someone doesnt call the array with an invalid index
17:03:36 <ookk> unless you check that it isnt invalid
17:03:48 <ddarius> http://okmij.org/ftp/Haskell/types.html#branding
17:03:49 <lambdabot> Title: Haskell Programming: Types
17:03:49 <ookk> and then you might aswell use the normal read/write?
17:03:59 <augustss> ookk: because you can prove (formally or informally) that this piece of code is correct, and then the type checker will ensure you use it in a valid way
17:04:26 <ddarius> ookk: You can prove that your code maintains the invariant after performing fewer run-time checks.
17:04:33 <ookk> augustss, but all programs cant be written that way?
17:05:05 <augustss> ookk: I don't know.  But many.
17:05:46 <ookk> every program where the array indexing does not depend on any IO data should be able to be proven completely safe
17:06:07 <ookk> and every program where the indexin is dependent on IO data you need to make checks
17:06:19 <ookk> that is how i understand it?
17:06:36 <ddarius> ookk: But you only need to make the checks when you receive the data.
17:06:57 <augustss> exactly
17:07:15 <ookk> yes you can prove that for every valid data that enters your program that the indexes will be defined
17:08:32 <augustss> ookk: you should check out the paper.  it's neat
17:08:52 <ddarius> ookk: Let's say you have a program that updates a chunk of array given user-inputted lower and upper bounds.  Once you check that those bounds are in bounds for the array, you don't need to check any of the array access code.
17:10:36 <ookk> ddarius, yes that is what most c/c++ programs does
17:10:47 <ookk> do*
17:11:14 <augustss> So using IOUArray give a 10% slowdown
17:11:40 <ookk> compared to?
17:12:00 <ddarius> ookk: Do they make the guarantee (in general) explicit and compiler checked or is it implicit?
17:12:47 <augustss> ookk: compared to your code
17:13:01 <ookk> ddarius, well in c those things does not involve the compiler
17:13:03 <augustss> I rewrote it with IOUArray
17:13:24 <ookk> ddarius, the programmer very informally proves in his head that there will be no false indexing :P
17:13:40 <ookk> and that is why c/c++ program tend to have those kinds of errors
17:13:50 <ookk> augustss, ah so i thought
17:13:59 <ookk> augustss, may i see the code?
17:14:21 <augustss> sure, one sec
17:14:22 <ddarius> ookk: Oleg's branding library allows you to formally prove this to the compiler (kind of) and -it- will then use the unsafe versions.
17:14:55 <dons> augustss: some -fliberate-case-threshold=1000 help?
17:15:17 <dons> or stirctness on the arrays (check with -ddump-simpl that they're being unboxed to MutableArray# ptrs)
17:15:40 <ookk> ddarius, how can it prove it?
17:15:49 <ookk> (the compiler)
17:15:58 <augustss> dons: i wanna get rid of the unsafeperformio first
17:16:40 <vagif> In prelude: and = foldr (&&) True
17:16:43 <vagif> questoin
17:16:54 <vagif> qhy foldr and not foldl ?
17:17:25 <vagif> why foldr and not foldl ?
17:17:40 <ookk> vagif, because in other languages if (cond1 && cond2) looks at cond1 first then cond2
17:17:49 <ookk> not the other way arround
17:17:58 <ookk> which would be the case with foldr
17:18:14 <ookk> foldl
17:19:00 <vagif> so with foldl it would first check second argument and then first ?
17:19:04 <ddarius> ookk: Oleg's code uses a small trusted set of operations that "brand" indices as inbounds and uses Haskell's type system to guarantee that you can't forge branded indices.
17:20:18 <ookk> ddarius, what are those trusted operations?
17:20:27 <ookk> vagif, yes
17:20:41 <vagif> i see thx
17:20:41 <ookk> > foldl (/) [1,2]
17:20:43 <lambdabot>   add an instance declaration for (Fractional [a])
17:20:57 <ookk> > foldr (/) [1,2] :: Double
17:20:58 <lambdabot>      Expecting a function type, but found `Double'
17:20:58 <lambdabot>       Expected type: Doubl...
17:21:07 <ookk> > foldr (/) 1 [1,2] :: Double
17:21:09 <lambdabot>  0.5
17:21:16 <ookk> > foldl (/) 1 [1,2] :: Double
17:21:18 <lambdabot>  0.5
17:21:21 <ookk> hmm
17:21:28 <ookk> i guess that didnt have apoint :P
17:21:31 <augustss> ookk: darcs.augustsson.net/Darcs/Planets
17:21:35 <ookk> > foldr (/) 1 [2] :: Double
17:21:37 <lambdabot>  2.0
17:21:42 <ookk> > foldl (/) 1 [2] :: Double
17:21:45 <lambdabot>  0.5
17:22:27 <ookk> augustss, swedish?
17:22:35 <vagif> foldr (/) 1 [1,2] returns the same 0.5
17:22:36 <augustss> yep
17:23:47 <ddarius> ookk: For the example he illustrates, bmiddle, which returns a branded index between two indices, bsucc/bpred which increment/decrement a branded index only checking (at run-time) whether it is too high/low.
17:23:48 <ookk> vagif, that was bad of me, look at: foldr (/) 1 [1,2], foldl (/) 1 [1,2]
17:24:28 <ookk> ddarius, well then he does a bounds check right there, bsucc/pred?
17:24:35 <vagif> ookk: and ?
17:24:52 <ookk> vagif, you see that one give 1/2 and one 2/1
17:24:54 <vagif> i fail to see the difference result in both cases in the same
17:25:07 <ookk> > foldr (/) 1 [2]
17:25:09 <lambdabot>  2.0
17:25:10 <ookk> > foldl (/) 1 [2]
17:25:11 <lambdabot>  0.5
17:25:19 <ookk> oh sorry i see i wrote [1,2] instead of [2]
17:25:22 <ookk> my bad
17:25:36 <vagif> i see now :) thx
17:25:54 <ookk> ddarius, but i guess it depends on what and how much he uses bsucc bpred?
17:26:12 <vagif> but what it has to do with "all" ? conjunction does not depend on argument place
17:26:43 <vagif> so in case of using foldr for "all" i do not see the reason
17:26:48 <ookk> i though you were talking about "and" ?
17:26:58 <vagif> i'm sorry
17:27:01 <vagif> and
17:27:04 <vagif> same question
17:27:19 <vagif> x and y == y and x
17:27:29 <ookk> because in the real world, conditions take a different amount of time to evaluate
17:27:40 <ddarius> ookk: Yes, but only half of one.  Also for bmiddle he does none.  The example he was using was a binary search on an array.
17:27:41 <ookk> and fail / succed a different amount of %
17:27:57 <ookk> vagif, if (cheap_cond && expensive_cond)
17:28:10 <ookk> if cheap_cond fails why evaluate expensive_cond?
17:28:17 <vagif> i see
17:28:32 <vagif> but foldr itself is not cheap, foldl is much cheaper
17:28:46 <ookk> ddarius, yeah i can se that the point about bmiddle
17:29:03 <tessier> Why would foldl be cheaper than foldr?
17:29:12 <tessier> What difference does it make which end of the list you start from?
17:29:12 <vagif> space ?
17:29:31 <ookk> tessier, you start from the same end in the list in both cases
17:29:44 <ookk> @src foldl
17:29:45 <lambdabot> foldl f z xs = lgo z xs
17:29:45 <lambdabot>     where lgo z []     =  z
17:29:45 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:29:48 <ookk> @src foldr
17:29:49 <lambdabot> foldr k z xs = go xs
17:29:49 <lambdabot>     where go []     = z
17:29:49 <lambdabot>           go (y:ys) = y `k` go ys
17:29:56 <tessier> I'm a newbie. I must misunderstand what foldl and foldr do.
17:30:01 <sorear> tell fodder
17:30:01 <tessier> I thought they were like for loops.
17:30:16 <sorear> they are a bit
17:30:17 <ookk> tessier, a haskell list is not double linked
17:30:18 <tessier> But one increments and the other decrements which is like processing a list from the left or frrom the right
17:30:19 <lispy> > foldl (+) 0 [1..10]
17:30:20 <lambdabot>  55
17:30:31 <sorear> tessier: they abstract out recursion
17:30:40 <tessier> ookk: I considered that the lists would be more like arrays.
17:30:46 <sorear> tessier: also, they are lazy
17:30:49 <lispy> > 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
17:30:50 <lambdabot>  55
17:31:00 <ookk> tessier, lists are nothing like arrays
17:31:02 <sorear> > foldr (&&) True (False : repeat True)
17:31:04 <lambdabot>  False
17:31:09 <ddarius> ookk: You could also add a brange lo hi action that would allow you to safely do my original example.
17:31:09 <sorear> > foldl (&&) true (False : repeat True)
17:31:10 <ookk> foldl would be faster
17:31:10 <lambdabot>   Not in scope: `true'
17:31:16 <tessier> ookk: I know how lists are implemented in lisp. I guess haskell's are similar?
17:31:18 <tessier> ie. not arrays
17:31:18 <sorear> > foldl (&&) True (False : repeat True)
17:31:23 <lambdabot> Terminated
17:31:24 <sorear> tessier: yes
17:31:27 <ookk> vagif, but usually you wont do and on big lists
17:31:37 <sorear> tessier: haskell lists are *exactly* like lisp lists
17:31:45 <tessier> sorear: I see.
17:32:01 <tessier> So foldr has to traverse once and reverse the list and then do its magic?
17:32:06 <vagif> ookk: agree, but this is general function, you cannot argue with "usualy"
17:32:07 <sorear> tessier: no
17:32:16 <ookk> tessier, look at the soruce
17:32:17 <sorear> tessier: foldr is a very lazy thing
17:32:25 <ookk> @src foldr
17:32:25 <lambdabot> foldr k z xs = go xs
17:32:26 <lambdabot>     where go []     = z
17:32:26 <lambdabot>           go (y:ys) = y `k` go ys
17:32:58 <ookk> especially go (y:ys) = y `k` go ys
17:33:00 <tessier> I still don't quite understand what it means to be a "lazy" thing
17:33:04 <sorear> tessier: foldr f z lst = if (null lst) then  f (head lst) (foldr f z (tail lst))  else  z
17:33:15 <ookk> it put lazy computations on the stack
17:33:18 <tessier> I'll read more than the first chapter of my haskell book and come back to understanding why foldr is slower. :)
17:33:20 <sorear> tessier: where head is car and tail is cdr
17:33:31 <ookk> f x_1 (f x_2 (f x_3 ...)))
17:33:41 <ddarius> tessier: foldr isn't slower.
17:33:48 <ookk> tessier, it cant be made tail recursive
17:33:51 <ddarius> tessier: It's different.
17:33:55 <sorear> tessier: foldr is often MUCH faster
17:34:00 <Cale> tessier: In the case of a data structure, it means that components of the structure can be evaluated without evaluating the whole structure.
17:34:06 <sorear> tessier: like asymptotically faster
17:34:17 <sorear> tessier: this foldr is quick
17:34:21 <sorear> > foldr (&&) True (False : repeat True)
17:34:23 <lambdabot>  False
17:34:29 <Cale> foldr in some sense is O(1)
17:34:35 <tessier> It was said that foldl is cheaper. Since it isn't faster you mean cheaper in space? Because of the stack issue and lack of tail recursion on foldr?
17:34:36 <sorear> tessier: this equivalent foldl takes forever
17:34:40 <sorear> > foldl (&&) True (False : repeat True)
17:34:40 <Cale> It doesn't automatically recurse.
17:34:44 <lambdabot> Terminated
17:34:53 <vagif> yes i meant space
17:34:59 <tessier> ah, ok. I see now.
17:35:02 <sorear> tessier: ^^^^ foldr is millions of times faster there
17:35:11 <ddarius> @oldwiki StackOverflow
17:35:11 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
17:35:25 <ddarius> Incidentally, foldl shouldn't be used, rather foldl' should.
17:35:28 <tessier> Programming in haskell is so different than programming anything else.
17:35:42 <tessier> You never consider these things in imperative progamming.
17:35:49 <ddarius> tessier: No, I imagine it's rather like programming in Clean ;)
17:35:49 <vagif> so are you saying that foldr is faster than foldl, but foldl is more space efficient ?
17:35:51 <tessier> But I'm learning that perhaps we should.
17:36:02 <tessier> vagif: The classic time vs space tradeoff?
17:36:05 <ddarius> vagif: foldr and foldl do different things
17:36:34 <ookk> vagif, foldr is not faster if it has to actually do computations on the whole list
17:36:43 <ookk> because it cant be made tail recursive
17:37:03 <ddarius> If the operations passed to them is associative then you can choose and strictness characteristics determine your choice.
17:37:05 <ookk> try foldl (+) 0 [1..10000] and foldr (+) 0 [1..10000]
17:37:09 <augustss> ookk: interesting.  I got rid of planets as a global variable and that made the code much slower.  that shouldn't happen
17:37:12 <ookk> my guess is there will be a difference
17:37:24 <int-e> try foldl' (+) 0 [1..10000], too.
17:37:44 <sorear> or billions, or trillions, if you wait longer :)
17:37:49 <ookk> augustss, you got rid of unsafePerformIO and did a p <- planets and then passed that to advance?
17:38:00 <augustss> ookk: yes
17:38:33 <ookk> augustss, maybe beacuse advance gets called 20M times, with an argument
17:39:01 <ookk> augustss, it might be better to do an advance planets n, where the loop of 20M takes place in advance
17:39:07 <ookk> then i think it should be the same
17:39:07 <augustss> ookk: that argument never moves, it should sit in a fixed place in a register or on the stack
17:39:19 <ddarius> "The one-line summary for folds: if the binary operation is strict use foldl' otherwise use foldr."
17:40:03 <augustss> ookk: I need to stare at the core, because this is just poor
17:40:06 <ookk> audreyt, how much of a slowdown did it amount to then?
17:40:27 <ookk> augustss, *
17:41:01 <augustss> ookk: 2.14 to 3.57
17:41:20 <ookk> ouch
17:41:40 <ookk> it *shouldnt* slow it down :P
17:41:47 <augustss> advance' is tail recursive, it should just be a loop.  any argument that remains fixed should cost nothing
17:42:01 <int-e> ddarius: haha
17:42:19 <ddarius> int-e: ?
17:42:31 <ookk> augustss, yes but ghc might not infer that you only call advance with one list
17:42:36 <int-e> ddarius: just had to laugh at your one-line summary.
17:42:48 <ddarius> int-e: ?
17:42:55 <ookk> augustss, or ptr or array or whatever you call it with
17:43:27 <augustss> ookk: well, ghc is obviously missing something
17:43:27 <dons> ookk, a cute trick,  momentum' !p = liftM2 (*.) (mass p) (getVec (vel p))
17:43:34 <sorear> tessier: also: GHC's foldr/build loop fusion only works with foldrs, not foldls, so if you've got multiple nearby folds foldr will probably be faster.
17:43:42 <ookk> augustss, that is why, if you only use a function with the same argument, dont have it as an argument
17:44:10 <ookk> dons, yeah that is nice
17:44:40 <ddarius> sorear: It doesn't really matter.  If you should use foldl', you should use foldl' despite the fusion rules.
17:44:41 <ookk> augustss, that is why i did the unsafePerformIO
17:45:09 <ddarius> Or should you ...
17:45:12 <augustss> ookk: but I hate global variables. :)
17:45:28 <Igloo> augustss: Can you structure the code like    do planets <- mkPlanets; let { mass = ... planets; loop = ... mass ... loop }; loop   ?
17:45:46 <ookk> augustss, is there a tragic event in your childhood with global variables that has induces this hate? ;)
17:45:51 <augustss> i'll try some rewrites, but not tonight.
17:45:51 <int-e> does anyone use FFI to create global variables 'safely'?
17:45:56 <ddarius> ookk: Probably.
17:46:21 <augustss> and btw, now the code can move to the ST monad where it belongs.  since it doesn't do io
17:46:47 <TomMD> int-e: Not I, I 1) avoid globals via function overloading + STM, or 2) Using unsafePerformIO (iow, the obvious)
17:47:08 <ookk> augustss, yeah it would be really nice if that could be achieved without a performance loss
17:47:11 <TomMD> s/function overloading/partion application/
17:47:35 <TomMD> grrrr - I can not type!  I ment to say "Partial application"
17:47:36 <Igloo> ST should be just as fast, as it should be the exact same code
17:47:45 <augustss> ookk: yes.  i'll look at it some more tomorrow
17:48:01 <nrb23> what's the best way of printing in hex equiv to printf "%02x" ?
17:48:04 <Igloo> You might find using a Ptr Double is faster than an IOUArray Int Double, though, in which case you can't go the ST route
17:48:15 <nrb23> showHex 0 "" gives me "0".. but I want "00"
17:48:39 <sorear> nrb23: printf?
17:48:49 <sorear> > printf "%02x" 10
17:48:50 <lambdabot>  Add a type signature
17:48:52 <augustss> Ptr Double was 10% faster than IOUArray Int Double
17:48:54 <nrb23> isn't printf some crazy magic?
17:48:59 <sorear> > printf "%02x" (10 :: Int) :: String
17:49:00 <lambdabot>  "0a"
17:49:01 <sorear> nrb23: nah.
17:49:03 <Igloo> Hmm, I can't remember if I did actually find that, or if I just wanted fast conversion to ByteStrings now I think about it
17:49:03 <augustss> nrb23: yes it is ;)
17:49:06 <Igloo> Ah, OK
17:49:10 <sorear> nrb23: just typeclasclass hackery
17:49:14 <nrb23> but it's a good idea to use?
17:49:15 <ookk> tail $ showHex (256+0) ""
17:49:26 <sorear> Igloo: is it true that adding fixed parameters to a tail recursive function costs nothing?
17:49:27 <ookk> tail $ showHex (16^3+0) ""
17:49:27 <augustss> nrb23: why not?
17:49:55 <ookk> > tail $ showHex (16^3+0)
17:49:56 <lambdabot>      Expecting a function type, but found `a'
17:49:57 <lambdabot>       Expected type: [a]
17:49:57 <lambdabot>       ...
17:50:06 <nrb23> ookk: that gives me "000"
17:50:07 <ookk> > tail $ showHex (16^3+0) ""
17:50:08 <lambdabot>  "000"
17:50:14 <ookk> > tail $ showHex (16^2+0) ""
17:50:14 <sorear> Igloo: a while back I made a mandelbrot function much faster by rewriting it using a where-clause and a subfunction with fewer params, so I worry GHC isn't able to do loops well enough.
17:50:16 <lambdabot>  "00"
17:50:17 <augustss> sorear: I said that it shouldn't. ;)  we got that one right over 20 years ago :)
17:50:25 <ookk> sorry it should be ^2
17:50:55 <ookk> > tail $ showHex (16^3+16) ""
17:50:57 <lambdabot>  "010"
17:51:02 <ookk> > tail $ showHex (16^2+16) ""
17:51:03 <lambdabot>  "10"
17:51:06 <ookk> > tail $ showHex (16^2+3) ""
17:51:08 <lambdabot>  "03"
17:51:11 <nrb23> huh
17:51:22 <nrb23> I thought tail just got the last element?
17:51:24 <augustss> ookk: i think i prefer printf :)
17:51:36 <augustss> nrb23: all but the first element
17:51:52 <nrb23> ah, right
17:53:15 <sorear> augustss: GHC was around back then !?
17:53:15 * sorear thought he predated GHC
17:54:11 <augustss> sorear: no, this was before Haskell.  But same technology
17:54:22 <ookk> how old is haskell then?
17:54:50 <dons> ookk, oh, you're missing -funbox-strict-fields, that should make a tiny difference to use of the Vector3 type
17:55:18 <ookk> dons, i removed that as i noticed no performance difference
17:56:05 <sorear> GHC can produce 426 lines of asm from a 4 line function. wow.
17:56:35 <sorear> ah, 144 with -O2
17:56:55 <ookk> sorear, well, with haskell, a four line function can be _alot_ :P
17:58:19 <hpaste>  sorear pasted "the four line function I'm studying, also a representative loop from vty" at http://hpaste.org/447
17:58:35 <sorear> also grr:
17:58:36 <sorear> -bash: HsColor: command not found
17:59:01 <dons> sorear: -optc-O3 ?
17:59:01 <allbery_b> symlinks are good things :)
17:59:33 <ookk> sorear, with than function i understand why you are surprised of 426 lines of asm :)
17:59:33 <ookk>  
18:00:13 <ookk> i dont have HsColor either
18:00:16 <ookk> im on os x
18:00:47 <dons> HsColour
18:00:48 <sorear> void fillSeg(int a, int b, int* p1, int* p2) { while (p1 != p2) { *p1++ = a; *p1++ = b; } } /* it's even a oneliner in C of all languages */
18:01:07 <dons> sorear, if that's callable from haskell , just ffi to it
18:01:31 <sorear> dons: looking at core it seems most of the generated code is wrapper ... to study the worker, I'll unbox manually next.
18:01:35 <dons> you might want to write a QC test for that though
18:01:40 <sorear> dons: how big is FFI overhead?
18:02:33 <dons> small,m if the loop time dominates (think of yi's cbits)
18:02:38 <sorear> anyway, this is not the biggest consumer, and the from-vty-ness is not a big deal for vty.  I'm just trying to get a better feel for the code generator.
18:10:04 <magnus_> Hi, can anyone recommend a haskell CGI library?
18:10:24 <magnus_> there seem to be a lot of them out there so I can't choose
18:10:47 <sorear> Network.CGI is in the baselibs, so "it must be preferred"
18:10:58 <magnus_> aah :)
18:11:02 <sorear> I have, of course, never actually used it.
18:11:05 <magnus_> that simplifies it
18:11:19 <sorear> @docs
18:11:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:12:28 <syntaxfree> http://lambda-the-ultimate.org/node/2045
18:12:29 <lambdabot> Title: Open Quark (CAL language) available under BSD-style license | Lambda the Ultimat ...
18:12:41 <syntaxfree> I haven't understood what that is yet but it looks interesting.
18:13:21 <magnus_> my GHC6.6 doesn't seem to have Network.CGI
18:13:22 <sorear> *gag* at the quality of GHC generated code
18:13:44 <allbery_b> libghc6-net-dev package?
18:13:51 <sorear> (looking at -ddump-asm)
18:13:54 <nrb23> I get the impression that GHC could be much faster with a better backend
18:14:38 <magnus_> allbery_b: aha... I don't have permission to install packages though :(
18:17:02 <hpaste>  sorear annotated "the four line function I'm studying, also a representative loop from vty" with "unbox (eliminates wrapper, no effect on worker)" at http://hpaste.org/447#a1
18:17:02 <allbery_b> you could insall the binary tarbal (which includes all standard and extralibs packages) somewhere under your homedir, I guess
18:18:16 <magnus_> hmm yes
18:20:14 <hpaste>  sorear annotated "the four line function I'm studying, also a representative loop from vty" with "output of 'ghc-6.7 -c X.hs -ddump-asm -O2', look at X_fillSeg_info and GAG!" at http://hpaste.org/447#a2
18:20:28 <jz87> I have a question regarding instance definitions
18:20:30 <sorear> dons: ^^^ ghc's ncg appears to suck
18:20:44 <jz87> sorear, you seem to live in this channel
18:21:20 <jz87> I see you everytime I log on
18:21:20 <sorear> jz87: http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html
18:21:21 <lambdabot> Title: #haskell @ freenode.org stats by dons
18:21:36 <sorear> jz87: look at the list of nicks by activity
18:21:58 <jz87> haha
18:22:03 <jz87> wow
18:22:37 <sorear> wow, I've reached #25 on the all time list
18:22:46 <jz87> I have a question about instance definitions
18:22:47 <sorear> this channel is 6 years old
18:22:55 <sorear> I've been here since November
18:23:00 <chessguy> 'evening haskellers
18:23:07 <jz87> I defined this class SubType sub sup where
18:23:11 <jz87> injection :: sub -> sup
18:23:18 <sorear> cool
18:23:23 <jz87> basically the subtype relation on types
18:23:38 <jz87> injection basically takes a subtype and upcast it to the supertype
18:23:51 <sorear> that's how I'd do it ...
18:23:54 <jz87> now I'm trying to write the following
18:24:10 <jz87> instance (SubType a b, SubType b c) => SubType a c where
18:24:18 <jz87> injection = injection . injection
18:24:27 <sorear> good luck
18:24:30 <jz87> and it won't compile
18:25:10 <chessguy> ?hoogle sine
18:25:10 <lambdabot> No matches found
18:25:14 <chessguy> ?hoogle sin
18:25:15 <lambdabot> Prelude.sin :: Floating a => a -> a
18:25:15 <lambdabot> Prelude.sinh :: Floating a => a -> a
18:25:15 <lambdabot> Data.IntMap.singleton :: Key -> a -> IntMap a
18:25:27 <sorear> jz87: that can be made to work with -fallow-undecidable-instances (I think), but you'll be rewarded with an infinite loop
18:25:31 <sorear> at compile time
18:25:36 <jz87> uh
18:26:06 <jz87> hmm
18:26:13 <jz87> how come GHC can't just compile that though?
18:26:51 <sorear> blah blah blah principal types blah blah undecidability blah blah blah blah
18:27:14 <sorear> answering that question requires more type theoretic arcana than even I know.
18:27:20 <jz87> ok, I'm implementing the subtype relation as SubType a (Either a b)
18:27:21 <Gwern> sorear: the clearest explanation I've seen all day
18:27:31 <sorear> augustss: I seem to recall you talking about this before?
18:27:49 <jz87> so how do I implement it so that I don't have to write a separate instance definition for each level of nesting?
18:28:14 <jz87> so if I have type Value = Either Int (Either Bool (Either Float ()))
18:28:43 <jz87> how can I define an instance of SubType so I can just type injection (int, or bool, or float) and have it casted
18:29:03 <oerjan> Hi, I wondered if there is a reasonable way to create an infinite cyclic datastructure containing IORefs?
18:29:43 <sorear> oerjan: fixIO
18:29:46 <sorear> @ty fixIO
18:29:48 <lambdabot> Not in scope: `fixIO'
18:30:00 <sorear> oerjan: or after-the-fact mutation
18:30:07 <sorear> @ty mfix
18:30:09 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
18:30:35 <oerjan> fixIO sounds promising, I hadn't found that
18:30:47 <sorear> @index fixIO
18:30:48 <lambdabot> System.IO
18:30:58 <sorear> @ty System.IO.fixIO
18:31:00 <lambdabot> forall a. (a -> IO a) -> IO a
18:31:11 <sorear> mfix == fixIO
18:31:17 <sorear> @src IO mfix
18:31:17 <lambdabot> mfix = fixIO
18:31:40 <emu_> > cycle [1,2,3]
18:31:41 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
18:32:29 <sorear> hmm, in GHC who is MDP?
18:32:34 <sorear> er WDP
18:32:44 <emu_> what is a WDP?
18:33:19 <sorear> emu: someone's initials.  someone very important it seems.  not too far from the 'SLPJ'
18:33:29 <oerjan> heh, i never thought to check whether IO was a MonadFix instance! Thanks :)
18:33:44 <allbery_b> @instances MonadFix
18:33:46 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:36:29 <sorear> will partain it seems
18:41:17 <jz87> I'm having trouble figuring this one out
18:41:37 <jz87> I write SubType a b => SubType a (Either c b) where
18:41:45 <jz87> injection = Right . injection
18:41:54 <jz87> this shouldn't be undecidable
18:42:03 <jz87> but it's still having trouble
18:42:15 <jz87> can anyone explain this to me please?
18:42:50 <hpaste>  sorear annotated "the four line function I'm studying, also a representative loop from vty" with "the final assembly, with -fvia-C -optc-O3. read it and weep." at http://hpaste.org/447#a3
18:42:57 <sorear> dons: ^^^
18:44:11 <sorear> 6.6 and 6.4.2 don't do any better.
18:46:03 <Cale> @djinn (Either (a -> r) (b -> r) -> r) -> (a -> r, b -> r)
18:46:04 <lambdabot> -- f cannot be realized.
18:46:23 <Cale> @djinn (a -> r, b -> r) -> (Either (a -> r) (b -> r) -> r)
18:46:24 <lambdabot> -- f cannot be realized.
18:46:39 <sorear> augustss: testing shows no recent version of GHC can keep loop constants in registers.
18:46:39 <Cale> er, oh
18:46:47 <Cale> @djinn ((a -> r) -> r, (b -> r) -> r) -> (Either (a -> r) (b -> r) -> r)
18:46:48 <lambdabot> f (a, b) c =
18:46:48 <lambdabot>     case c of
18:46:48 <lambdabot>     Left d -> b (\ _ -> a d)
18:46:48 <lambdabot>     Right e -> b e
18:46:57 <Cale> @djinn (Either (a -> r) (b -> r) -> r) -> ((a -> r) -> r, (b -> r) -> r)
18:46:58 <lambdabot> f a = (\ b -> a (Right (\ _ -> a (Left b))), \ c -> a (Right c))
18:47:01 <Cale> right.
18:48:56 <Cale> strangely asymmetric code though...
18:49:48 <Cale> @type (\ b -> a (Right b), \ c -> a (Right c))
18:49:50 <lambdabot> Not in scope: `a'
18:49:50 <lambdabot>  
18:49:50 <lambdabot> <interactive>:1:28: Not in scope: `a'
18:49:55 <Cale> @type \a -> (\ b -> a (Right b), \ c -> a (Right c))
18:49:57 <lambdabot> forall t a b. (Either a b -> t) -> (b -> t, b -> t)
18:50:19 <Cale> er
18:50:23 <Cale> @type \a -> (\ b -> a (Left b), \ c -> a (Right c))
18:50:25 <lambdabot> forall t a b. (Either a b -> t) -> (a -> t, b -> t)
18:50:26 <dons> sorear the inner loop doesn't look too bad.
18:50:31 <Cale> yes
18:51:01 <Cale> @type \(a,b) c -> case c of Left d -> a d; Right e -> b e
18:51:03 <lambdabot> forall a b t. (a -> t, b -> t) -> Either a b -> t
18:51:04 <sorear> dons: !?
18:51:25 <Cale> okay, so djinn is just not finding the nicest solution.
18:51:28 <sorear> dons: I count 4x the needed number of memory refs per iteration
18:51:38 <sorear> dons: are you talking Core/haskell?
18:51:50 <sorear> dons: the Core, even the STG, looks perfect to me
18:52:04 <sorear> dons: the cmm and assembly are ... gag
18:52:21 <sorear> look after X_fillSeg_info
18:53:29 <chessguy> @paste
18:53:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:53:53 <hpaste>  chessguy pasted "Why doesn't this work?" at http://hpaste.org/448
18:56:30 <chessguy> so this is the foundation for a very simple genetic programming framework
18:56:45 <emk> dons: 621 hits on the map fusion essay today, excluding various useless sorts of traffic (spiders, my own IP block, etc.).
18:56:58 <emk> There's apparently some interest in Haskell.
18:57:04 <chessguy> essentially, a program is a tree, with functions in the non-leaf nodes and terminals in the leaf nodes
18:57:30 <sorear> chessguy: the type of eval is wrong
18:57:47 <chessguy> hm, ok
18:57:53 <emk> Not nearly as much traffic as a good Ruby essay gets, but not to shabby.
18:57:55 <sorear> eval is perfectly valid, at type Program -> State ProgramState Program
18:58:14 <chessguy> hmm. the type signature is what i want
18:58:27 <sorear> emk: join p.h.o!
18:58:46 <sorear> http://planet.haskell.org/policy.html
18:58:48 <lambdabot> Title: Membership policy - Planet Haskell
18:58:48 <chessguy> i want it to evaluate the Program in light of the current ProgramState
18:59:56 <chessguy> the evaluation of the program should return a DataType
19:00:22 <Cale> @djinn (((a -> r) -> r) -> r) -> (a -> r)
19:00:22 <lambdabot> f a b = a (\ c -> c b)
19:00:52 <Cale> @. pl djinn (((a -> r) -> r) -> r) -> (a -> r)
19:00:53 <lambdabot> f = (. flip id)
19:04:40 <SimonRC> thing that made me LOL:
19:05:04 <ihope_> Hey, I was going to say it!
19:05:04 <sorear> @botsnack
19:05:04 <sorear> ah, lag explains everything.
19:05:04 <sorear> *grump* *grump*
19:05:05 <lambdabot> :)
19:05:21 <sorear> ?
19:05:28 <sorear> @botsnack
19:05:29 <lambdabot> :)
19:05:30 <ihope_> Scheme guy: (> scheme haskell)
19:05:35 <ihope_> Haskell guy: (> scheme) haskell
19:05:48 <SimonRC> "<schemer> (> Scheme Haskell)
19:05:48 <SimonRC> <haskeller> (> Scheme) Haskell"
19:05:55 <ihope_> Yeah, that. :-P
19:06:01 <SimonRC> oops
19:06:06 * SimonRC goes to bed
19:09:57 <sorear> dons: how do you get a perfect loop from GHC?
19:10:45 <chessguy> :r
19:11:01 <sorear> chessguy: winno?
19:11:24 <chessguy> wrong window, sorry
19:11:37 * sorear reloads
19:14:11 <chessguy> that reminds me of an xkcd, but i'm too lazy to look it up
19:14:12 <mattam> how do you write ++ in latex so that it doesn't look too big ?
19:14:25 <sorear> {\small ++} :p
19:15:56 <mattam> i thought that might work obviously :)
19:20:00 <Jessehk> By any chance is there a built-in function to get the word form of integers?
19:20:49 <sorear> ?
19:20:54 <sorear> "word form"?
19:20:55 <chessguy> ?hoogle Int -> [Char]
19:20:56 <lambdabot> No matches, try a more general search
19:21:01 <chessguy> ?hoogle Int -> String
19:21:02 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
19:21:08 <nrb23> :t fromIntegral
19:21:10 <lambdabot> forall b a. (Num b, Integral a) => a -> b
19:21:11 <sorear> like "nineteen seventy-two"?
19:22:01 <Jessehk> wordFrom 3 = "three"
19:22:21 <Jessehk> or something?
19:22:28 <sorear> nope
19:22:35 <sorear> no such standard fun
19:22:37 <sorear> afaik
19:22:50 * glguy redirects the question to ##lisp
19:22:55 <sorear> sorry
19:23:00 <Jessehk> thanks anyways :)
19:23:39 <chessguy> Jessehk, i think i saw something like that. hang on
19:23:52 <Gwern> show wouldn't work?
19:24:38 <Gwern> > length (show 8)
19:24:39 <lambdabot>  1
19:24:43 <sorear> Gwern: show 8 = "8"
19:25:32 <chessguy> ah, not built in, but maybe something like this would work for you:
19:25:35 <chessguy> Jessehk, http://www.haskell.org/haskellwiki/99_questions/95_to_99
19:25:36 <lambdabot> Title: 99 questions/95 to 99 - HaskellWiki
19:26:37 <Jessehk> I'll look into expanding it. Thanks chessguy.
19:27:55 * glguy doesn't much care for converting things to strings and using digitToInt on each :-/
19:28:38 <glguy> ... [digits!!digitToInt d | d <- show n]
19:29:13 <nornagon> that sure is horrible
19:29:31 <chessguy> ?type execState
19:29:32 <lambdabot> forall s a. State s a -> s -> s
19:29:49 <chessguy> ?type evalState
19:29:50 <lambdabot> forall a s. State s a -> s -> a
19:30:09 <chessguy> what's the one that returns both s and a
19:30:18 <sorear> runState
19:30:20 <chessguy> ?hoogle State s a -> s -> (s, a)
19:30:21 <lambdabot> No matches, try a more general search
19:30:29 <chessguy> ?hoogle runState
19:30:29 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
19:30:30 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
19:35:23 <chessguy> why is it s -> (a, s)
19:35:26 <chessguy> i just want a, s
19:37:03 <sorear> you need to give it an initial state!
19:37:19 <sorear> you can't get from State s a to (a,s) without an initial state
19:39:34 <hpaste>  chessguy annotated "Why doesn't this work?" with "almost working..." at http://hpaste.org/448#a1
19:40:11 <chessguy> somehow at the end there i have to say "evaluate p1 and p2 in the current state and add the results together
19:40:12 <chessguy> "
19:44:41 <chessguy> although i guess it should technically be "evaluate p1 in the current state, evaluate p2 in the resulting state, and add the two results together"
19:49:31 <gotaku> How do I perform IO in a State monad?
19:49:51 <chessguy> use StateT TheState IO ReturnType
19:50:32 <gotaku> ... transformers.
19:51:02 <sorear> rule!
19:51:19 <chessguy> gotaku, http://www.haskell.org/haskellwiki/Simple_StateT_use is a pretty good example
19:51:21 <lambdabot> Title: Simple StateT use - HaskellWiki
19:51:24 <Cale> http://reddit.com/info/13v0w/comments/c13xkb?context=5 -- hehe
19:51:26 <lambdabot> Title: Double-helix shaped nebula discovered at the center of our galaxy (reddit.com)
19:51:50 <chessguy> the type of code is StateT [Int] IO ()
19:51:54 <sorear> does anyone here know how to write an efficient loop in GHC?
19:51:55 <chessguy> (i believe)
19:57:22 <Cale> sorear: foldl' ?
19:58:29 <sorear> Cale: I've got a recursive IO procedure which produces *terrible* assembly
19:58:41 <Cale> sorear: and this matters?
19:58:57 <sorear> dons looked at it, failed to see the problem, and vanished
19:59:02 <Cale> What does it look like in the profile?
19:59:19 <Cale> You could simply write the assembly yourself, and link it in via the FFI.
19:59:24 <chessguy> Cale, you better hope you don't fail too :)
20:00:13 <Cale> If dons couldn't find it, I'm pretty unlikely to be able to. Don had more experience reading core than I do.
20:00:24 <Cale> But I tend not to care at all about how crappy the assembly looks.
20:00:25 <sorear> oh, the core was perfect
20:00:43 <Cale> s/had/has/
20:01:00 <Cale> What does the profile look like?
20:01:13 <sorear> 11 memory accesses in a memset type loop (should have 2)
20:01:21 <Cale> er, no, the profile :)
20:01:52 <Cale> What percent of the time your program is running is spent in the loop, for instance?
20:01:59 <sorear> Cale: doubly funny.  two days ago, VERY bad performance with a (slightly more complicated) comparison loop at 66%
20:02:21 <sorear> I don't remember changing anything but the code is 100x faster now
20:03:04 <sorear> (also, I'm trying to understand the code generator, for the future's sake)
20:05:55 <fnord123> Hi all. Has anyone tried this for fun? : http://www.facebook.com/jobs_puzzles/?puzzle_id=2
20:05:57 <lambdabot> Title: Facebook | Incompatible Browser
20:06:24 <sorear> Incompatible browser, wow
20:06:31 <sorear> that's one dumb webdev
20:06:46 <fnord123> what browser?
20:06:53 <sorear> elinks
20:06:59 <sorear> idiots
20:07:26 <sorear> now that I know facebook doesn't support web standards, I'll never use them
20:07:42 <mbishop> heh
20:07:53 <mbishop> It's frightening to think you used facebook to begin with :)
20:08:01 <fnord123> does linkedin.com work for you?
20:08:02 <sorear> mbishop: I never have.
20:08:16 <fnord123> facebook is like linked in, but for people who dont matter
20:08:21 <bd_> I note that they say it's under a CC attribution licence with only a link as attribution
20:08:23 <sorear> mbishop: but I could have someday started.  now I definitely won't
20:08:45 <Nafai> mbishop: Happy Birthday!
20:08:47 <chessguy> > fact 16
20:08:48 <lambdabot>   Not in scope: `fact'
20:08:52 <chessguy> > fac 16
20:08:53 <lambdabot>   Not in scope: `fac'
20:08:53 <mbishop> Nafai: You too! :D
20:09:00 <sorear> > product . enumFrom 1 16
20:09:01 <lambdabot>      The function `enumFrom' is applied to two arguments,
20:09:01 <lambdabot>     but its type `a...
20:09:04 <sorear> > product . enumFromTo 1 16
20:09:05 <lambdabot>      Expecting a function type, but found `[a]'
20:09:06 <lambdabot>       Expected type: a1 -> [a...
20:09:07 <Nafai> mbishop: Thanks!
20:09:09 <sorear> > product $ enumFromTo 1 16
20:09:11 <lambdabot>  20922789888000
20:09:41 <fnord123> there must be pruning opportunities, though
20:09:51 <chessguy> ok, so even dividing by 2 it's a big number
20:10:12 <fnord123> reverse seating orders are prunable.
20:10:41 <gotaku> Why don't people make their types explicit in these examples...
20:11:16 <nornagon> > product [1..16]
20:11:17 <fnord123> and you can ignore any seating arrangement that starts off poorly (i.e. kill the compare if it is halfway through and below some threshhold)
20:11:18 <lambdabot>  20922789888000
20:11:20 <chessguy> hmm. i wonder if alpha beta would be a worthwhile approach
20:13:46 <justonp6> how come I keep getting <interactive>:1:6: Not in scope no matter what I type?
20:14:38 <sorear> what do you type?
20:14:42 <Gwern> because you aren't using 'let' for definitions?
20:14:46 <sorear> 2 -- give error?
20:14:48 <Gwern> that's what caused it for me, anyway
20:15:05 <chessguy> fnord123, another method i would consider would be a genetic algorithm
20:15:30 <fnord123> chessguy, that's not guaranteed to find the maximum, afaik
20:15:43 <fnord123> what's alpha-beta?
20:15:52 <emk> The "Haskell Road to Logic, Maths and Programming" is a really nice textbook...
20:16:06 <chessguy> "pproximate or probabalistic solutions that are particularly clever are also appreciated. "
20:16:12 <chessguy> s/pp/app/
20:16:54 <chessguy> alpha-beta is a method for searching a tree-like space
20:17:17 <chessguy> usually used for things like artificially intelligent game-playing programs
20:18:59 <chessguy> i don't think it would work here
20:23:27 <gotaku> How do you know what monad you are in if the type isn't explicit?
20:25:19 <chessguy> you would have to tell by where the function is being called from
20:25:21 <chessguy> i think
20:25:28 <chessguy> example?
20:26:58 <gotaku> That StateT example.
20:27:29 <chessguy> ok, so you're looking at the code function?
20:28:00 <gotaku> Both.
20:28:15 <chessguy> oh yeah, there's no type signatures at all
20:28:25 <chessguy> well, main of course is always IO ()
20:29:03 <chessguy> now it calls runStateT code
20:29:08 <chessguy> ?type runStateT
20:29:09 <lambdabot> forall s a (m :: * -> *). StateT s m a -> s -> m (a, s)
20:30:15 <chessguy> now let's work backwards
20:30:23 <chessguy> ?type (>>)
20:30:25 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
20:30:36 <gotaku> What's the forall stuff?
20:31:13 <chessguy> existential qualifiers.
20:31:23 <chessguy> you can ignore that part for now
20:31:29 <Ytinasni> explicit qualifiers where they usually occur implicitly
20:32:10 <chessguy> so from bind, we know the resulting type is IO ()
20:32:25 <chessguy> s the b in that type signature will get instantiated with (), and the m with ()
20:33:27 <chessguy> thus, we know there's IO involved in code
20:34:07 <Cale> m with IO, you mean
20:34:17 <chessguy> yes, sorry
20:34:47 <gotaku> For something called "Simple StateT use", it's not very simple...
20:34:57 <chessguy> and from the type signature for runStateT, we know that code is a State stacked on top of some monad
20:35:18 <chessguy> so we can gather that it's StateT [Int] IO ()
20:35:36 <chessguy> (assuming the default type of 1 is Int)
20:35:57 <chessguy> yeah, type signatures would probably help
20:37:12 <chessguy> ah, Integer appears to be the default
20:38:21 <chessguy> i'm going to edit that page with signatures
20:39:24 <gotaku> Looks like you can blame dons.
20:40:31 <sorear> @seen JohnMeacham
20:40:32 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I last heard JohnMeacham speak 15h 2m 45s ago.
20:40:47 <chessguy> hmm. i'm not sure why pop is StateT [Integer] IO Integer and not State [Integer] Integer
20:43:20 <chessguy> anyone?
20:43:37 <sjanssen> chessguy: in what context?
20:43:59 <chessguy> sjanssen, check out the type signature for pop in http://www.haskell.org/haskellwiki/Simple_StateT_use
20:44:00 <lambdabot> Title: Simple StateT use - HaskellWiki
20:44:18 <chessguy> why isn't it State [Integer] Integer
20:44:51 <Cale> dons: you just duplicated your post.
20:45:00 <Cale> (to reddit)
20:45:01 <sjanssen> chessguy: if pop was a State rather than StateT, you wouldn't be able to call it from code
20:45:21 <sjanssen> (the code StateT action in the example, to be specific)
20:45:30 <chessguy> hmm
20:45:32 <augustss> sorear: I don't ask for arguments that remain constant during tail recursion to be kept in a registers necessarily, a stack location will do.
20:45:40 <sjanssen> chessguy: State and StateT aren't compatible types
20:45:45 <Cale> @free map :: (a -> b) -> [a] -> [b]
20:45:46 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
20:46:10 <sorear> augustss: oh. ok.
20:46:26 <sorear> i'd still like GHC to produce a better loop :)
20:46:31 <augustss> sorear: x86 doesn't have many registers
20:46:32 <chessguy> ah, ok. i think i get it
20:46:44 <chessguy> code is sort of providing the state, via a StateT
20:46:56 <augustss> sorear: going via C makes it hard to generate good loops (the way ghc does it)
20:47:35 <sjanssen> chessguy: the problem is that in "(>>=) :: m a -> (a -> m b)" -- those two m's need to be the same type
20:48:07 <sjanssen> State [Int] a and StateT [Int] IO a are different types
20:48:32 <sorear> augustss: actually, the same code (virtually) is generated with or without -fvia-C
20:48:46 <sorear> augustss: (and this is 6.7 so -O2 no longer implies -fvia-C)
20:49:25 <chessguy> so here, m is StateT, a is [Integer], and b is Integer, right?
20:49:32 <sorear> augustss: looking at the Cmm, it has very bad aliasing problems that would make it difficult for *any* backend to generate good coode
20:49:54 <augustss> sorear: that's bad then
20:50:19 <sjanssen> chessguy: m is "StateT [Integer] IO"
20:50:24 <sorear> "I know!  We need a FORTRAN backend!"
20:50:36 <sorear> also, -optc-fstrict-aliasing didn't help.
20:51:08 <chessguy> so what are a and b then?
20:51:29 <sjanssen> chessguy: depends on which section of the program we're talking about
20:51:29 <augustss> sorear: holy crap!  this simple loop generates code that is beyond bad!
20:51:43 <sorear> augustss: are you looking at the assembly now, or what?
20:51:47 <augustss> yes
20:51:56 <sorear> so you believe my "read this and weep"?
20:51:56 <sjanssen> chessguy: let's consider "do x <- pop; io $ print x"
20:51:57 <sorear> :)
20:52:02 <augustss> sorear: yes
20:52:06 <chessguy> ok
20:52:20 <sjanssen> that desugars into "pop >>= \x -> io $ print x"
20:52:31 <chessguy> yes
20:52:34 <sjanssen> in that example, a is Integer, and b is ()
20:53:52 <augustss> sorear: oh, a little strictness annotation helped
20:53:53 <sorear> augustss: even scarier - that loop generates similar code in all of [6.4.2, 6.6, HEAD-10-days-ago], so it's been hurting us a *while* (pun intended)
20:54:09 <sorear> augustss: ?
20:54:25 <gotaku> The language shootout site has updated and Haskell just past Ada in the overall listing.
20:54:31 <Nafai> Nice
20:54:34 <sjanssen> sorear: where is the Haskell that generates this ugly code?
20:54:39 <sorear> augustss: I think my code is completely strict already
20:54:44 <chessguy> so bind is instantiated as being of type StateT [Integer] IO Integer -> (Integer -> StateT [Integer] IO ())
20:55:01 <sorear> sjanssen: http://hpaste.org/447#a3
20:55:06 <sjanssen> chessguy: precisely
20:55:10 <fnord123> whoa. awesome lightening in london.
20:55:14 <augustss> sorear: I thought so of my code too
20:55:23 <augustss> time to leave for london
20:55:38 <sorear> sjanssen: look at X_fillSeg_info, and tell me what you think of the loop.
20:56:11 <chessguy> sjanssen, thanks
20:59:26 <chessguy> gotaku, did any of this make sense?
20:59:36 <gotaku> No.
21:00:08 <chessguy> gotaku, do you understand the State monad by itself?
21:00:31 <gotaku> I think so.
21:00:51 <sjanssen> sorear: has dons commented on the code?
21:01:01 <sorear> sjanssen: yes
21:01:23 <sorear> <dons> sorear the inner loop doesn't look too bad.
21:01:50 <sjanssen> I've never scrutinized ghc's assembly output, I don't know whether this is typical
21:01:50 <sorear> 2 h 10 m ago
21:02:16 <chessguy> gotaku, well, the StateTransformer monad is for connecting a State monad to another monad. in this case, IO
21:04:33 <sjanssen> sorear: so you want the parameters to stay in registers instead of being retrieved from the stack repeatedly?
21:05:00 <sorear> sjanssen: yes.
21:05:21 <sjanssen> otherwise it looks okay
21:05:24 <sorear> sjanssen: is that too much to ask? I believe C compilers have done it for decades
21:05:40 <sjanssen> sorear: I believe the answer is "patches welcome" :)
21:07:16 <sorear> ghc is scarily big
21:07:37 <chessguy> gasp!
21:07:45 <chessguy> @bot
21:07:55 <sorear> @uptime
21:07:58 <sorear> @version
21:07:59 <lambdabot> :)
21:08:05 <lambdabot> uptime: 29s, longest uptime: 2d 17h 27m 21s
21:08:11 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
21:08:16 <sorear> @farber
21:08:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:08:23 <sjanssen> sorear: have you tried benchmarking the generated code against a tweaked version
21:08:26 <lambdabot> Unknown command, try @list
21:08:35 <sorear> sjanssen: tweaked how so?
21:08:56 <sorear> the Core and STG look perfect
21:09:03 <sjanssen> sorear: remove the redundant stores and use registers
21:09:14 <sorear> I don't have that level of control
21:09:18 <sorear> this is haskell
21:09:32 <sorear> (or are you suggesting I edit the assembly)
21:09:42 <sjanssen> sorear: yeah, edit the assembly
21:10:19 <sorear> the answer is no
21:10:44 <sjanssen> just for academic purposes -- to see exactly how much the added indirection costs
21:11:00 <sorear> hmm.
21:11:05 <sorear> will try it.
21:11:14 <sorear> I'll also look at larger examples
21:11:30 <sorear> the 30% profile band in vty is a loop quite similar to this one
21:11:45 <sorear> (the 60% band is a much bigger, allocating, loop)
21:12:02 <sjanssen> another good question is why gcc isn't doing the register lifting
21:12:09 <sjanssen> it should be good at that
21:12:11 <chessguy> ?src liftIO
21:12:12 <lambdabot> Source not found. That's something I cannot allow to happen.
21:12:13 <sorear> sjanssen: aliasing
21:12:41 <sorear> sjanssen: if you look at the CMM, ghc is tweaking the stack in such a way no compiler can prove lifting is safe
21:12:45 <chessguy> ?hoogle liftIO
21:12:46 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
21:13:03 <sorear> sjanssen: I suspect that is why both via-C and asm are afflicted
21:13:11 <sjanssen> makes sense
21:16:42 <chessguy> what's CMM?
21:16:56 <sorear> C--
21:17:03 <sorear> just different
21:17:11 <sorear> -ddump-opt-cmm
21:17:23 <sorear> "cee minus minus"
21:17:24 <chessguy> oh, intermediate code?
21:17:32 <sorear> hiya dons!
21:17:40 <sorear> welcome back!
21:17:43 <sorear> :)
21:18:06 <dons> happy happy, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=clean
21:18:07 <sorear> well, I go off to try those things you mention
21:18:38 <sorear> dons: so, if that loop I showed you is good, what does bad look like?
21:18:44 <chessguy> what, we're using hApps on the shootout problems? :)
21:18:46 <dons> hehe. yeah, ok. its bad
21:18:46 <ivanm> dons: well, that's definitely better than yesterday's results!
21:18:51 <dons> yeah!
21:18:58 <dons> and there's some entries that haven't been updated yet
21:19:03 <dons> so we should climb a bit more still
21:19:45 <sorear> dons: do you have any hints for extracting a better loop from ghc?
21:20:09 <sorear> this is a purely academic exercise, the loop in question isn't visible on any profile
21:21:16 <dons> hmm.
21:23:25 <gotaku> One more spot and Haskell will be top 5 overall.
21:26:16 <ivanm> Is there any difference between the gentoo and debian scores?
21:31:00 <siti> lol
21:31:08 <ivanm> looks like there is... are the differences due to platform, or insane compiler flags on gentoo?
21:31:23 <ivanm> OK, what just happened there? a freenode server crashed?
21:31:37 <siti> yes it looks that way
21:31:53 <ivanm> Apparently, I'm meant to be connected to the pratchett server as well...
21:31:59 <jcreigh> netsplit, for whatever reason...
21:32:03 <ivanm> unless they've all been on for too long ;)
21:32:06 <siti> lol
21:33:29 <sorear> ivanm: you saw my link :)
21:33:29 <sorear> @bot
21:33:52 <sorear> gah
21:33:59 <sorear> I was SO sure I fixed that
21:34:14 <sorear> (and I can version dons so it's not a network issue)
21:34:16 <newsham> anyone know how to use gtk2hs from ghci or runhaskell?
21:34:28 <sorear> newsham: upgrade to the latest gtk2hs
21:34:40 <sorear> newsham: the threaded-rts issues have been fixed
21:34:53 <newsham> i installed about 1-2 weeks ago
21:34:56 <ivanm> sorear: which link? [can't find it after all the disconnect/connect messages ;) ]
21:35:02 <newsham> it wasnt the release but it was pretty close to the new release
21:35:04 <sorear> ivanm: http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=ghc&lang2=clean
21:35:04 <siti> and gtk2hs rocks now :)
21:35:08 <sorear> VERY impressive
21:35:12 <sorear> haskell wipes the floor with clean under Debian
21:35:19 <siti> lol
21:35:44 <ivanm> The only link like that I can find is dons...
21:35:51 <newsham> will upgrading fix my issue?
21:35:52 <sorear> ivanm: ?
21:35:58 <sorear> newsham: probably.
21:36:23 <newsham> i'm skeptical...  here we go.
21:36:24 <ivanm> sorear: I just searched through the message list, and the only one I found to the shootout was by dons, not by you (and it was to the gentoo box, not debian)
21:36:35 <ivanm> but yeah, that _is_ impressive ;)
21:37:12 <sorear> in a sad kinda way
21:37:59 <ivanm> true
21:38:08 <dons> so there's still an updated nbody to appear on the shootout
21:38:12 <dons> and then we're done pretty much
21:38:17 <dons> maybe fannkuch could be improved
21:38:29 <dons> anything else will come down to improving ghc's code generator though
21:38:40 <sorear> maybe if my bug is fixed? :)
21:38:45 <dons> and things like using tags in the rts
21:38:58 <dons> stream fusible bytestrings too
21:39:08 <dons> they're a fair bit faster again for the bechmarks that use bytestrings.
21:40:51 <newsham> newsham@lenoxp$ runhaskell square.hs
21:40:52 <newsham> Failed to load interface for `Graphics.UI.Gtk.Entry.Entry': no package matching gtk-0.9.10.5 was found
21:41:03 <newsham> nofix.
21:41:08 <newsham> (diff error though!)
21:41:24 <sorear> was the old one threaded-rts?
21:41:37 <newsham> it works in ghci though.. but not runhaskell.
21:41:40 <siti> @google runhaskell
21:41:42 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/1076
21:41:42 <lambdabot> Title: #1076 (runhaskell crash with .hi/.o files in the directory) - GHC - Trac
21:41:46 <newsham> old what?
21:41:51 <sorear> error
21:42:00 <newsham> nope, about not being able to load a shared lib
21:42:22 <newsham> hmm.. not quite working in ghci... doesnt process events properly it seems.
21:42:29 <newsham> but at least popped up a window and showed something
21:42:41 <newsham> the compiled code runs fine
21:43:12 <newsham> (this is win32, btw)
21:48:15 <newsham> is anyone working on putting shim into yi?
21:49:41 <sorear> not yet
21:49:49 <sorear> yi doesn't even have modes
21:51:02 <newsham> who needs modes?  shouldnt it only support haskell?  ;-)
21:51:56 <sjanssen> sorear: yi supports plenty of modes
21:52:02 <sjanssen> insert mode, for one
21:52:11 <newsham> ah, a modal editor!
21:52:35 <sjanssen> @quote color.*haskell
21:52:36 <lambdabot> glguy says: [on hpaste] you can have your code syntax colored however you like, as long as that color is "haskell"
21:52:52 <dons> all editors are modal, some just have only an Identity mode ;)
21:53:08 <sjanssen> yi is a model modal editor
21:53:26 <sorear> newsham: unfortunately, no.
21:53:37 <dons> a very modern modal
21:53:49 <sorear> newsham: yi needs modes:
21:54:13 <sorear> Haskell, Core, STG, C--, i386-asm, cabal, LitHaskell, Alex, Happy, ...
21:54:31 <newsham> mostly modest modern model modal editor
21:54:43 <sorear> and most of all yi needs an IRC client
21:54:50 <ivanm> don't forget, you need both literate and non-literate haskell modes
21:54:52 <sjanssen> modal: because anything else is outmoded
21:55:13 <newsham> all programs grow until they eventual can support an email reader.
21:55:25 <Gwern> newsham: you trying to bad mouth Gnus?
21:55:31 <sorear> yi will be uber-modular
21:55:41 <newsham> gwern: unnecessary
21:55:41 <sorear> u:ber-modular, even
21:55:58 <newsham> what is FilePath?
21:55:59 <Gwern> (personally, I'd like some distro packages for yi. why can't I just apt-get install yi?)
21:56:15 <dons> its not moved out of beta yet.
21:56:19 <sorear> Gwern: it's not ready for sucess.
21:56:21 <dons> bleeding edge devs only for now
21:56:23 <sjanssen> Gwern: the haskell overlay for gentoo has a yi package
21:56:37 <sorear> Gwern: if more people knew about yi, we wouldn't be able to hack it
21:56:37 <dons> ah, maybe yi 0.1 is iin gentoo
21:56:46 <sorear> we'd be too busy with bugreports
21:56:50 <sjanssen> dons: I think it's yi-darcs
21:56:59 <Gwern> sorear: aren't bug-reports a good thing?
21:57:45 <Gwern> (if it's bleeding-edge, than noone besides those equipped to handle it will really be interested. )
21:58:57 <tessier> Can yi show me the mayan calendar? Wouldn't want to miss my important religious festivals.
21:59:12 <tessier> Is it time to plant the maize yet?
21:59:22 <Gwern> tessier: pooh. one only needs the discordian calendar
21:59:44 <tessier> Gwern: No wonder discordians are always so skinny!
22:00:30 <Gwern> tessier: I blame the lack of hotdog buns, myself
22:01:15 <dfranke> Gwern, what do you mean the lack?  You still eat one per week, don't you?
22:01:53 <Gwern> dfranke: I... er... gave myself some plenary indulgences to not eat them
22:02:50 <dfranke> ah.  Wise choice.
22:06:03 <dfranke> I submitted this to thedailywtf yesterday: http://paste.lisp.org/display/36700
22:06:13 <dfranke> That was TA-provided code for a PhD-level course.
22:07:09 <sorear> proof obligations ftw
22:16:23 <newsham> ?type inet_addr
22:16:24 <lambdabot> Not in scope: `inet_addr'
22:16:31 <newsham> weird that inet_addr is IO.
22:17:02 <sorear> @index inet_addr
22:17:02 <lambdabot> Network.Socket
22:17:14 <sorear> @type Network.Socket.inet_addr
22:17:16 <lambdabot> String -> IO Network.Socket.HostAddress
22:18:35 <newsham> inet_addr should be referntially transparent
22:18:44 <newsham> (its a string parser)
22:18:46 <jcreigh> dfranke: wow...it's amazing how messed up one LOC can be.
22:18:51 <sorear> well, it's obsolete anyway
22:19:00 <sorear> @type Network.Socket.inet_aton
22:19:01 <lambdabot> Not in scope: `Network.Socket.inet_aton'
22:19:49 <sorear> gah ... Network.Socket doesn't wrap the replacement for inet_addr!
22:24:48 <newsham> we'll live (except when you want 255.255.255.255)
22:25:04 <newsham> hmm.. I wonder if the IO is to throw an error when -1 is returned
22:26:11 <sorear> it does
22:26:26 <sorear> (throw an error)
22:26:39 <sorear> why can't it just use throw?
22:33:43 <newsham> anyone use shim?
22:37:28 <sorear> yes
22:37:46 <newsham> the README doesnt say to doanything with the shim.el.  does that have to be copied somewhere?
22:43:28 <sorear> no
22:44:16 <sorear> (add-hook 'haskell-mode-hook
22:44:16 <sorear> 	  (lambda ()
22:44:16 <sorear> 	    (add-to-list 'load-path "/usr/local/src/shim")
22:44:16 <sorear> 	    (require 'shim))) ; this is however required
22:48:30 <lucca> probably better to say ; this is necessary
22:48:41 <lucca> lest people say "no kidding"
22:53:10 <newsham> yah, thats in the readme.
22:53:20 <newsham> so where does the shim.el go?
22:53:47 <sorear> dont move it
22:53:58 <sorear> see that sexp I pasted?
22:54:08 <hyrax42_> what is shim
22:54:15 <newsham> so I can only run shim when i'm in the shim src directory where shim.el is?
22:54:17 <sorear> replace /usr/local/src/shim with where shim is on your computer
22:54:37 <newsham> ok, so thats kind of important.. that woulda been nice for it to say :)
22:55:07 <sorear> also, you may need to (customize-group "shim")
22:55:38 <hyrax42_> oh that sounds nifty
22:56:37 <hyrax42_> how superior is it?
22:57:34 <dons> ?users
22:57:34 <lambdabot> Maximum users seen in #haskell: 322, currently: 276 (85.7%), active: 11 (4.0%)
22:57:39 <sorear> vastly :)
22:58:09 * hyrax42_ wonders if identifier completion could be done including scope and type considerations
22:58:26 <sorear> hyrax42: it already shows you the type
22:58:58 <hyrax42> sorear_: must balance the number of _s?
22:59:27 <hyrax42> sorear_: well I have no idea what it does, I guess
22:59:28 <newsham> how do I get a clean copy of a file I edited in darcs?
22:59:42 <sorear_> darcs revert foo/bar
23:00:13 <abz> ?poll-list
23:00:14 <lambdabot> ["Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
23:00:29 <sorear> btw, I just registered sorear_
23:00:41 <sorear> that's the Explanation
23:00:48 <hyrax42> ah
23:00:54 <hyrax42> hmm I forget all the commands
23:01:02 <sorear> @list
23:01:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:01:05 <hyrax42> I think I have hyrax42_ and kalmar, kalmar_
23:01:16 <sorear> @whois kalmar
23:01:16 <lambdabot> Unknown command, try @list
23:01:20 <hyrax42> which at some point I will switch to
23:02:05 <sorear> hyrax42: change your nick to kalmar while inchannel so lambdabot knows you've changed it
23:02:15 <RandomNewNick> @seen sorear
23:02:15 <lambdabot> sorear has changed nick to randomnewnick.
23:02:16 <lambdabot> You are in #darcs, #ghc and #haskell. I last heard you speak just now.
23:02:27 <hpaste>  jtl pasted "iota command line function" at http://hpaste.org/449
23:05:11 <kalmar_> bah have to wait 600 seconds before I can register the last one
23:06:06 <sorear> jtl: schemer?
23:08:57 <oklopol> @seen me
23:08:57 <lambdabot> I haven't seen me.
23:09:05 <oklopol> @seen oklopol
23:09:05 <lambdabot> You are in #unicycling and #haskell. I last heard you speak just now.
23:09:07 <hpaste>  sorear annotated "iota command line function" with "use cases and centralize arg handling" at http://hpaste.org/449#a1
23:09:19 <sorear> @seen jtl
23:09:19 <lambdabot> I haven't seen jtl.
23:09:45 <sorear> hmm, I wonder where he is...
23:13:14 <hpaste>  sorear annotated "iota command line function" with "more refactoring" at http://hpaste.org/449#a2
23:13:23 <sorear> can't ... stop ... improving
23:14:09 * int-e waits patiently for the final one line program.
23:15:25 <glguy> printf expected
23:16:04 <glguy> showeachW n x = printf "%*d" (n+1) x
23:16:23 <glguy> (missing \n)
23:16:31 <newsham> blah, when I run emacs, i get no M-x shim
23:16:54 <newsham> (also ctrl-x ctrl-c doesnt work right.. cygwin issue?)
23:16:56 <glguy> err, looks like not (n+1)
23:16:59 <sorear> newsham: enter haskell mode first
23:17:07 <newsham> with what command?
23:17:26 <sorear> M-x haskell-mode, or just visit a .hs file
23:17:38 <newsham> I'm in a .hs file, and there's no M-x haskell-mode
23:17:56 <newsham> M-x haskell- [No match]  (when tab completion)
23:18:30 <newsham> (I should point out i only vaguely know emacs)
23:18:39 <hpaste>  sorear annotated "iota command line function" with "use prim enumFromThenTo" at http://hpaste.org/449#a3
23:18:52 <glguy> sorear: what is (a,b,c) for in your paste?
23:19:00 <sorear> newsham: you need to find and install haskell-mode, I think it's a prerequisite
23:19:06 <sorear> :(
23:19:40 <newsham> blah, docs shold mention :(
23:19:59 <hpaste>  glguy annotated "iota command line function" with "updated showeachW" at http://hpaste.org/449#a4
23:21:08 <glguy> > printf "%*d\n" 4 (42 :: Int) :: String
23:21:09 <lambdabot>  Add a type signature
23:21:16 <glguy> > printf "%*d\n" (4 ::Int) (42 :: Int) :: String
23:21:18 <lambdabot>  "  42\n"
23:21:55 <hpaste>  sorear annotated "iota command line function" with "more amazing refactoring!" at http://hpaste.org/449#a5
23:23:10 <newsham> cool, shim ran
23:23:21 <glguy> ?hoogle hprintf
23:23:22 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
23:23:28 <glguy> putStr $ concatMap ( printf "%*d\n" w )  (enumFromThenTo a (a+c') b)
23:23:55 <glguy> mapM_ (hprintf "%*d\n" stdout w) (enumFromThenTo a (a+c') b)
23:24:09 <hpaste>  sorear annotated "iota command line function" with "minor refactor" at http://hpaste.org/449#a6
23:24:10 <newsham> blah, cant tell if it worked though (stupid cygwin emacs and ^C)
23:24:21 <glguy> oh yeah
23:24:24 <glguy> IO typed printf
23:24:27 <glguy> duh
23:25:11 <glguy> if (a > b) then c else (-c) -- same as -- if a > b then c else -c --?
23:25:26 <hpaste>  hyrax42 annotated "iota command line function" with "showeachW "idiomatically"" at http://hpaste.org/449#a7
23:25:49 <glguy> for loose values of idiomatically?
23:26:03 <hyrax42> glguy: suitably loose, yes
23:26:05 <hpaste>  sorear annotated "iota command line function" with "prune imports" at http://hpaste.org/449#a8
23:27:10 <sorear> I wonder if jtl is still watching
23:27:26 <hyrax42> sorear: haha
23:28:01 <hyrax42> hmm I should have called n "len" or something else
23:28:14 <hyrax42> l perhaps is most "conventional"
23:28:25 <hyrax42> if haskellers could use 0-length identifiers, I think they would
23:28:39 <int-e> and then ' '' ''' and so on :)
23:29:02 <hyrax42> int-e: of course
23:29:18 <glguy> sorear: that if statement is "close" to signum (a-b) * c
23:29:35 <glguy> actually, that'd work, no?
23:29:39 <glguy> since when a == b
23:29:47 <glguy> [a, a..a] -> [a]
23:29:48 <hyrax42> ?pl \n -> (++ "\n") . reverse . take n . (++ repeat ' ') . reverse . show
23:29:49 <lambdabot> (((++ "\n") . reverse) .) . (. ((++ repeat ' ') . reverse . show)) . take
23:29:57 <ddarius> hyrax42: we do.
23:30:26 <hyrax42> ddarius: too true
23:30:33 <ddarius> > [1,1..1]
23:30:35 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:30:43 <glguy> hmm
23:30:51 <newsham> realdarcs.exe: takeFile win32Hacks.p-0 in C:/cygwin/tmp/shim: openFd: invalid
23:30:51 <newsham> argument (Invalid argument)
23:30:53 <ddarius> glguy: You're stepping with 0
23:30:55 <newsham> awesome.
23:31:01 <int-e> > [1,1..1.0]
23:31:02 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0...
23:31:20 <glguy> that seems like a bug...
23:31:27 <ddarius> glguy: What?
23:32:35 <ddarius> Anyways, that bastard got a tablet.  I want a tablet.
23:32:48 <davidmccabe> What's a good monospace font for print?
23:32:54 <davidmccabe> or should I even set code in monospace in print?
23:33:18 <hyrax42> davidmccabe: for what purpose
23:33:43 <davidmccabe> handout for a talk.
23:33:49 <dfranke> I like DejaVu Sans Mono.
23:33:51 <davidmccabe> short code snippets of haskell.
23:33:58 <hyrax42> I would set that mono
23:34:25 <dfranke> yes, variable-width fonts for code are a crime against humanity.
23:34:28 <davidmccabe> Consolas seems like it might be nice. will have to wait til Monday to try it on a laser though.
23:34:34 <glguy> anyone here use VMWare Server?
23:34:44 <glguy> and know why I'd want to pay for VMWare Workstation?
23:34:53 <davidmccabe> dfranke: well, you have languages like applescript and lingo that're designed for it. otherwise I'm with you though.
23:35:16 <hpaste>  sorear annotated "iota command line function" with "more refactoring" at http://hpaste.org/449#a9
23:35:22 <dfranke> davidmccabe, and Mathematica, I suppose.
23:35:23 <hyrax42> for print I think courier 10pt would be nice
23:35:40 <davidmccabe> I dunno. courier? with those massive serifs?
23:35:51 <hyrax42> hmm true
23:35:55 <hyrax42> it looks nice in hpaste though
23:36:01 <hyrax42> but that's not in print...
23:36:06 <glguy> sorear: flip forM_?
23:36:11 <glguy> are you avoiding an import?
23:36:13 <dfranke> davidmccabe, and although I like Mathematica, I really hate the interface.
23:36:41 <davidmccabe> yeah, me too, though I don't know it well.
23:36:52 <int-e> > [2..1] -- sorear, that's not what you want I think
23:36:53 <lambdabot>  []
23:37:14 <davidmccabe> anyways, I'm planning on using Myriad for the headings and Minion for the english.
23:37:18 <hyrax42> davidmccabe: I can't help too much... I just use Monaco here
23:37:25 <davidmccabe> which is a pixel font.
23:37:35 <hyrax42> not here it isn't
23:37:36 <Korollary> most fonts look much better when printed due to the higher dpi
23:37:37 <davidmccabe> I'll try a few when I get access to a laser.
23:37:41 <hpaste>  sorear annotated "iota command line function" with "int-e, you asked?" at http://hpaste.org/449#a10
23:37:42 <davidmccabe> hyrax42: oh, I thought it was.
23:37:53 * davidmccabe wanders off.
23:37:57 <davidmccabe> thanks.
23:38:00 <hyrax42> davidmccabe: at least on os x it is outline
23:38:01 <sorear> glguy: no, I'm being buggy.
23:38:12 <int-e> sorear: also, flip forM_ = mapM_
23:38:23 <davidmccabe> hyrax42: it kinda irks me they can change a font from pixel to outline without changing the name. it's a completely different font.
23:38:33 <davidmccabe> monaco was one of the original macintosh fonts.
23:38:35 <hyrax42> iirc myriad is apple's current logotype?
23:38:43 <hpaste>  sorear annotated "iota command line function" with "fix dumb bug" at http://hpaste.org/449#a11
23:38:44 <davidmccabe> yes. beautiful font.
23:38:57 <hyrax42> a shame they don't actually let users use it
23:39:05 <hyrax42> by default anyway
23:39:20 <hyrax42> what subject matter?
23:39:22 <davidmccabe> taking it in vane.
23:39:32 <hyrax42> is minion suitable?
23:39:34 <davidmccabe> hyrax42: the handout? haskell itself.
23:40:11 <davidmccabe> hyrax42: minion is a nice, business-like serif font. I like it.
23:40:12 <int-e> @type ap forM_
23:40:14 <lambdabot> Not in scope: `forM_'
23:40:22 <int-e> @type ap Control.Monad.forM_
23:40:23 <lambdabot> Not in scope: `Control.Monad.forM_'
23:40:46 <hyrax42> it's a very popular body face for novels and such
23:40:58 <sorear> @type ap (flip mapM_)
23:40:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ([a] -> a -> m b) -> [a] -> m ()
23:41:20 <sorear> the type I expected, good
23:41:34 <hyrax42> myself, when I'm not using CMR, I've been using Garamond recently
23:41:43 <sorear> @ty \ iota printf -> ap (flip forM_) (printf "%*d\n" . maximum . map (length . show)) . iota =<< getArgs
23:41:45 <lambdabot> Not in scope: `forM_'
23:41:45 <lambdabot>  
23:41:45 <lambdabot> <interactive>:1:93: Not in scope: `getArgs'
23:42:02 <davidmccabe> hyrax42: another of my favorites. minion though is taller and boxier.
23:42:14 <sorear> @ty \ iota printf getArgs -> ap (flip mapM_) (printf "%*d\n" . maximum . map (length . show)) . iota =<< getArgs
23:42:15 <lambdabot> forall a (m :: * -> *) b a1. (Monad m, Show a) => (a1 -> [a]) -> ([Char] -> Int -> a -> m b) -> m a1 -> m ()
23:42:21 <davidmccabe> hyrax42: http://www.adobe.com/type/browser/P/P_1719.html
23:42:39 <hyrax42> I'm there :)
23:42:51 <davidmccabe> beautiful, ain't it?
23:43:01 <hyrax42> I really need to get off my bum and work out how to get latex to use other fonts
23:43:19 <davidmccabe> heh. latex. good luck.
23:43:31 <hyrax42> a shame they're all so expensive
23:43:44 <glguy> you paid 200$?
23:43:53 <davidmccabe> no, nobody pays retail for fonts :P
23:43:56 <davidmccabe> their organization buys them for them.
23:44:17 <hyrax42> davidmccabe: well if you're in cs/maths/physics, you'll have to use latex pretty much
23:44:25 <hyrax42> I don't know any better way to set the maths
23:44:35 <davidmccabe> yeah. but for anything other than that it's a pain.
23:44:45 <hyrax42> you are using... indesign?
23:44:49 <davidmccabe> I'm using apple Pages for this handout; useless for anything academic, but nice when layout is key.
23:45:11 <davidmccabe> nope, cheap and cheerful Pages :)
23:45:24 <hyrax42> ah, I haven't tried it out
23:45:48 <hpaste>  int-e annotated "iota command line function" with "make it compile" at http://hpaste.org/449#a12
23:45:50 <hyrax42> xetex supposedly makes it easier to use other fonts
23:46:07 <sorear> @bot
23:46:07 <sorear> gah, connection's gone out again
23:46:07 <lambdabot> :)
23:46:11 <glguy> !paste
23:46:12 <hpaste> Haskell paste bin: http://hpaste.org/
23:46:37 <hyrax42> all right, I'll get my stupid self to bed
23:46:39 <glguy> can anyone confirm that cygwin's x11 server is quite slow compared to commercial alternatives for windows?
23:46:52 <int-e> sorear: you were missing a  map read
23:46:52 <davidmccabe> hyrax42: nice chatting with ye.
23:46:58 <sorear> int-e: I saw.
23:47:01 <hyrax42> indeedy
23:47:28 <sorear> btw, what we've just reduced to 2 lines is a stripped down unix seq(1)
