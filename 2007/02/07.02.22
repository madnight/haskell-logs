00:37:42 <Syzygy-> Hmmmmmmm.
00:38:32 <Syzygy-> How do I, as lazily as possible, write a function that takes a list of Thingies, multiplies each pair of Thingies in turn, reduces them according to some algorithm depending on the list as it looks as the moment, and tacks the result onto the end of the list
00:44:09 <Syzygy-> ?sublist
00:44:09 <lambdabot> Unknown command, try @list
00:44:17 <Syzygy-> ?doc Data.List
00:44:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:44:43 <Syzygy-> > isInfixOf [1,2,3] [1,2]
00:44:45 <lambdabot>  False
00:45:01 <Syzygy-> > isInfixOf [1,2,3] [1,2,3,4]
00:45:03 <lambdabot>  True
00:47:04 * ttmrichte1 tests.
00:47:08 <ttmrichte1> OK.
00:47:15 <ttmrichte1> Got some weird stuff from Nickserv.  Sorry.
00:51:37 <Slarba> uhh
00:51:38 <Slarba> <interactive>: internal error: interpretBCO: unknown or unimplemented opcode 11101
00:51:39 <Slarba>     (GHC version 6.6 for x86_64_unknown_linux)
00:51:39 <Slarba>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
00:51:39 <Slarba> Process haskell aborted (core dumped)
00:51:41 <lambdabot> Title: 1.2. Reporting bugs in GHC
00:56:35 <Syzygy-> Slarba: Yeah. Go report that bug.
00:57:14 <Slarba> yep
00:57:51 <Syzygy-> ?type maybe
00:57:53 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:58:13 <Syzygy-> > maybe 0 id Nothing
00:58:15 <lambdabot>  0
00:58:18 <Syzygy-> > maybe 0 id Just 3
00:58:19 <lambdabot>  Couldn't match expected type `Maybe a'
00:58:27 <Syzygy-> > maybe 0 id (Just 3)
00:58:28 <lambdabot>  3
01:02:44 <Syzygy-> ?src isInfixOf
01:02:44 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
01:02:57 <Syzygy-> ?src isPrefixOf
01:02:57 <lambdabot> isPrefixOf [] _          = True
01:02:57 <lambdabot> isPrefixOf _  []         = False
01:02:57 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
01:03:48 <Thunder> Oops. Boyer-Moore would be much more approbriate for isInfixOf.
01:04:19 <Syzygy-> Boyer-Moore?
01:05:30 <int-e> Thunder: but Boyer-Moore requires indexed access. isInfixOf as above works on linked lists.
01:05:51 <Thunder> Check "backwards": Compare the last item of needle first. If matched go backwards. If no match: Search the first partial string inside the needle of the currently explored part of haystack and adjust the postion of needle.
01:06:21 <Thunder> Example: isInfixOf "test" "just a test".
01:09:31 <Slarba> that unimplemented opcode bug seems to be reported already
01:11:44 <Thunder> First the '___t' and '___t' are matched, then '__st' and '__st' is matched. Then the match '_e' failes  with '_u' so the known part ist 'ust': Therefor the first match could be the initial 't'
01:12:11 <Thunder> Now we move the needle by three positions an try again
01:13:09 <Thunder> First the '___t' and 't__ ' are matched. This fails an the known part ' ' does not match at all. So move by four positions.
01:13:46 <Thunder> The strings matches but we evaluated only the following part of the haystack: '_ust__ test'
01:15:00 <Syzygy-> Right.
01:15:11 * Syzygy- is going to end up writing an infix-finder myself anyway.
01:15:32 <Syzygy-> I would most of all want an infix-finder typed [a] -> Maybe ([a],[a],[a])
01:15:52 <Syzygy-> (or -- I could dispense with [a] -> Maybe([a],[a]) actually...)
01:16:05 <Syzygy-> I need to figure out the prefix and suffix should the infix actually exist.
01:16:31 <Thunder> Avarage runtime is O(length needle * length haystack) for the default algorithm and O(length haystack / length needle) for Boyer Moore.
01:16:54 <Syzygy-> Thunder: Boyer-Moore copes with infinite lists ok too?
01:17:23 <Thunder> Syz: I dont' recommend this approach, because you construct two new lists without reason.
01:17:33 <Thunder> Of course.
01:17:47 <Thunder> (Not with an infinite needle)
01:18:41 <Syzygy-> Thunder: Finding the infix isn't what I really need. What I really do need are the two new lists.
01:18:56 <Thunder> Look the algorithm up in a Textbook (i.e. Sedgwick or Knuth), because you can speed up the process by choosing the right data representation.
01:19:22 <Syzygy-> Thunder: Will those tell me how to recover the prefix and suffix in the process?
01:19:36 <Thunder> I' recomment   search :: [a] -> Maybe Integer
01:19:57 <Thunder> Ã„hm: search :: [a] -> [a] -> Maybe Integer
01:20:13 <int-e> Thunder: again, [a] is a linked list.
01:21:14 <int-e> Thunder: you can implement boyer-moore for bytestrings. it actually sounds like a good idea.
01:21:16 <Thunder> You only need the start of the match. The match itself is already known (== needle) so the prefix is "take result haystack)
01:21:38 <int-e> Thunder: yes, and the start of the match is best represented by a pointer to the proper list element, that is, [a].
01:22:37 <Thunder> Nope. If you return three lists, they must be constructed, which results in increased memory.
01:22:46 <int-e> Thunder: that's where you're wrong.
01:23:09 <int-e> Thunder: the list already exists - it's part of the haystack
01:23:10 <Syzygy-> I need two lists: prefix and suffix. And these must get constructed anyway - so I don't care if I do that here or later.
01:23:27 <Thunder> Please show me how to return a prefix of a list without constructing it (copy the structure).
01:23:54 <Thunder> Syz: For a general approach you should avoid the cost.
01:24:06 <int-e> ok, you need to construct the prefix (although different prefixes can contain shared parts).
01:24:40 <Thunder> The only list which is shared is the suffix.
01:24:55 <int-e> Thunder: sorry if you meant to change the representation, I'm all for that - but all I saw you use is lists
01:26:07 <Thunder> I do not want to change the represetation, but look at the source:
01:26:15 <Thunder> @src take
01:26:16 <lambdabot> take n _      | n <= 0 =  []
01:26:16 <lambdabot> take _ []              =  []
01:26:16 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
01:26:24 <Thunder> @src drop
01:26:25 <lambdabot> drop n xs     | n <= 0 =  xs
01:26:25 <lambdabot> drop _ []              =  []
01:26:25 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
01:26:41 <Thunder> Drop does not contain a constructor, take does!
01:29:48 <quicksilver> Thunder: take constructs a new list
01:29:51 <quicksilver> Thunder: drop does not
01:30:00 <quicksilver> Thunder: drop returns the *same* tail as the original list
01:30:07 <quicksilver> they share the same in-memory representation
01:31:59 <Thunder> They share the elements.
01:32:15 <quicksilver> in both cases, the element is shared
01:32:22 <quicksilver> in the drop case the actual list structure is also shared
01:33:54 <Thunder> My point is to not construct two lists without reason.
01:35:18 <quicksilver> right, I thought you were saying that [a] wasn't a linked list
01:35:21 <quicksilver> :)
01:36:11 <Thunder> Oh no, this are boldy implemented arrays ;-)
01:40:28 <Heffalump> thunder: they have to work that way because they are immutable linked lists..
01:44:20 <vincenz> Thunder: there is no reason to worry about sharing gor no sharing lists. Fusion will remove all the intermediate lists away ;)
01:45:02 <Heffalump> drop can't be a good producer, surely.
01:45:16 <vincenz> o.O
01:45:23 <vincenz> sure it is
01:45:44 <Heffalump> how?
01:46:10 <Heffalump> it would have to reconstruct the input list tail
01:46:33 <vincenz> hmm, well it's just transparent :)
01:46:58 <Heffalump> I didn't know there was a short cut fusion rule involving drop
01:47:04 <Heffalump> I could certainly imagine writing one
01:47:34 <vincenz> Well I don't know, but conceptually it's not that hard really.  It's just fusing the function that generated the list passed to drop
01:47:39 <vincenz> I mean
01:47:46 <Heffalump> agreed
01:47:47 <vincenz> map f . drop 10 . unfoldr osmething
01:47:53 <vincenz> that should fuse right through
01:48:09 <Heffalump> you'd end up with a fused function that took 10 as a parameter
01:48:29 <Heffalump> and then called itself recursively until 10 became 0, at which point it would call the original fusion result
01:48:36 <Heffalump> But I doubt ghc has a rule for it.
01:49:08 <vincenz> well in terms of fused for-loops
01:49:10 <vincenz> it's rather easy :)
01:50:41 * vincenz should know, he wrote a paper on it
01:50:51 <vincenz> I did a fusion for STL-sequences :)
01:51:23 <vincenz> forward-iteratable only, but still, that's superset of list-fusion
01:51:47 <vincenz> (insert is rather annoying :))
01:58:17 <vincenz> It's a bit crufty and pragmatic, but the core idea works, just have to formalize it more now (which requires quite a bit of baggage :/)
02:01:39 * vincenz stops talking to the wall :)
02:02:09 <Thunder> *grin*
02:04:36 <dmead> ?src foldr
02:04:36 <lambdabot> foldr k z xs = go xs
02:04:36 <lambdabot>     where go []     = z
02:04:36 <lambdabot>           go (y:ys) = y `k` go ys
02:05:53 <Thunder> @pl let go k (y:ys) = y `k` go ys in go
02:05:54 <lambdabot> fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip (flip . ((.) .)))
02:06:06 <Thunder> Oh, not easier.
02:06:59 <quicksilver> pretty, though
02:07:14 <quicksilver> looks like an instruction on how to simulate the function with coin-tosses
02:07:20 <quicksilver> flip flip head, flip flip tail...
02:11:11 <Heffalump> vincenz: I was in the shower :-)
02:11:23 <vincenz> Heffalump: ah alright :)
02:11:57 <Heffalump> spent rather too long in it too, ran out of hot water with shampoo in my hair :-(
02:12:13 <Heffalump> so how do you persuade a C++ compiler to do fusion?
02:12:34 <vincenz> Heffalump: well it's a precompiler step
02:12:41 <pjd> futilely?
02:13:07 <vincenz> Heffalump: right now the transformations are manual and the concept is explained in my first paper.  But I plan to formalize it so it can be partially automated (with perhaps some hints from the deeveloper as to which he'd like to actually fuse)
02:13:19 <Thunder> Heffalump: Did you order lazy support of hot water?
02:14:13 <Heffalump> no, it's very eager. Just finite :-(
02:14:17 <vincenz> But the formalization is requiring quite a bit of baggage, but should be quite powerful once I have it :)
02:14:42 <vincenz> Heffalump: well you hav eto choose...eager and finite or lazy and infinite, bu tdon't complain if it takes longer for the hot-water to come out then at the start
02:18:27 <ejt> hi
02:22:24 <dmead> hi
02:22:26 <dmead> ;o
02:39:06 <kolmodin> ?seen dons
02:39:06 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 3h 58m 17s ago.
02:39:33 <vincenz> Heffalump: do you work on fusion?
02:39:34 <ejt> what is #haskell-overflow ?
02:39:45 <vincenz> An IRC channel
02:39:54 <dons> hey
02:40:14 <dons> for technical conversations that might involve a lot of text
02:40:23 <dons> kolmodin: ?
02:40:26 <kolmodin> dons: hey. last time (a week ago) I tried to build and run lamdbabot
02:40:32 <kolmodin> it segfaulted
02:40:34 <vincenz> dons: oh did you know that my fusion paper got accepted?
02:40:37 <dons> oh, nice.
02:40:44 <norpan> cold fusion?
02:40:48 <dons> vincenz: where at?
02:40:51 <dons> kolmodin: oh, fun fun
02:41:00 <vincenz> dons: SCOPES
02:41:01 <kolmodin> dons: yeah, I was quite pleased
02:41:08 <dons> kolmodin: on the binary parsing?
02:41:20 <kolmodin> dons: I don't think that part can segfault?
02:41:27 <dons> i hope not
02:41:29 <kolmodin> :)
02:41:35 <kolmodin> I have no idea where
02:41:46 <dons> well, can you reproduce it?
02:41:49 <kolmodin> it said 'loading plugins........ Seg fault'
02:42:14 <dons> if you remove State/seen does it still do it?
02:42:16 <kolmodin> sure, but not at the moment as 1) I'm at work and shouldn't be doing this 2) the box is offline
02:42:20 <dons> ok.
02:42:25 <nornagon> seg fault, eh?
02:42:27 <dons> i'll keep it in mind
02:42:29 <nornagon> not segfault?
02:42:32 <nornagon> :P
02:42:47 <kolmodin> no, it's seg's fault
02:42:49 <kolmodin> :)
02:42:53 <dons> sigsegv
02:43:09 * nornagon catches dons
02:43:14 <sigsegv> i always though sigfpe had a good nick
02:44:04 <sigstop> bah, sigusr1 is taken!
02:44:10 <sigchld> heh
02:44:25 <sigchld> 21:41:42 [freenode] -NickServ(NickServ@services.)- This nickname is owned by someone else
02:44:33 <sigchld> :-[
02:44:40 <int-e> sigill?
02:44:52 <kolmodin> dons: I think the box is a 64bit machine, if that matters to your plugin thingie
02:45:02 <vincenz> Anyone know how to box a word in latex?
02:45:08 <kolmodin> I'm not sure though, just got an account :)
02:45:09 <nornagon> \box{...}?
02:45:25 <nornagon> (just a guess)
02:47:08 <int-e> "The \fbox command is exactly the same as the \mbox command, except that it puts a frame around the outside of the box that it creates."
02:48:11 <vincenz> not floating tho, inline in a paragraph
02:49:16 <vincenz> \fbox it is :)
02:49:18 <vincenz> thx
02:52:30 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/22/bycicling-for-collatz/
02:52:33 <lambdabot> Title: Bycicling for Collatz « Data.Syntaxfree
02:52:34 <syntaxfree> new post!
02:52:35 <syntaxfree> ;)
02:54:29 <Thunder> syntaxfree: Syntax error in line 54: "unterminated string constant"
02:55:24 <syntaxfree> 54?
02:55:36 <Thunder> Your website.
02:55:54 <syntaxfree> bah, wordpress mangled the code again. I'll try and look at it.
02:56:02 <syntaxfree> What line is it?
02:57:18 <goban> is there a way to tell when a user was last logged on?
02:57:24 <dons> ?seen goban
02:57:25 <lambdabot> goban is in #haskell. I last heard goban speak 7s ago.
02:57:26 <Thunder> The line where you try to add the remote ip, but you forgot the extra lines generated by proxies.
02:57:40 <goban> ?seen toxygen
02:57:40 <lambdabot> I haven't seen toxygen.
02:57:43 <dons> bicycling?
02:57:46 <goban> dons: thanks
02:57:56 <quicksilver> syntaxfree: you should write a bot to announce your blog posts :P
02:58:10 <quicksilver> actually maybe lambdabot should link into the planet haskell rss
02:58:15 <syntaxfree> Thunder: Uhh. Wordpress.com must be fudged. I can't do nothing about it.
02:58:18 <dons> yeah, i've thought about that.
02:58:21 <dons> it would be useful
02:58:57 <dons> syntaxfree: By-cicling? or bi-cycling?
02:59:38 <syntaxfree> bicycling. I'm sleepy, damn :)
02:59:43 <dons> pretty graphs :-)
02:59:58 <dons> ?time syntaxfree
03:00:01 <lambdabot> Local time for syntaxfree is Thu Feb 22 08:57:37 2007
03:00:06 <quicksilver> fun article
03:00:09 <dons> all nighter?
03:00:16 <quicksilver> nonetheless I don't know if I agree with this: That makes for a smashing bedroom poster.
03:00:18 <dmead> oh shit
03:00:18 <syntaxfree> nah.
03:00:20 <quicksilver> :)
03:00:21 <dmead> i'm 24
03:00:24 <dmead> fuck
03:00:25 <dmead> i'm old
03:00:40 <dons> nah
03:00:50 <dmead> my mid 20s are slippy by dons
03:00:54 <dmead> i'm over the hill
03:00:57 <syntaxfree> The whole thing was written/compiled/graphed in the last fourty minutes.
03:00:58 <dmead> *slipping
03:01:13 <syntaxfree> I kinda wake up with my head screaming "GO MAKE COLLATZ GRAPHS".
03:01:18 <syntaxfree> It's scary.
03:01:20 <syntaxfree> s/wake/woke
03:03:32 <ketil> I have some problems installing the ghc 6.6 binary snapshot...
03:03:59 <JaffaCake> ketil: what's the problem?
03:04:14 <ketil> It installs all the links in $prefix/bin, but not the executables they link to.
03:04:24 <JaffaCake> hmm
03:04:42 <JaffaCake> which arch?
03:04:45 <ketil> Can I just copy the driver scripts manually (renaming them to remove .sh, it seems)?
03:04:49 <ketil> x86
03:05:03 <ketil> On AMD64, but I only run a 32 bit OS.
03:05:06 <JaffaCake> IIRC they need to have some lines prepended by the Makefile
03:05:13 <JaffaCake> ok
03:05:30 <JaffaCake> I'll try it out here
03:05:36 <syntaxfree> quicksilver: c'mon. It does!
03:05:51 <quicksilver> syntaxfree: :)
03:06:26 <ketil> I'll redo, and look for any suspicious make output.
03:07:28 <ketil> JaffaCake, I have some permission denied stuff, perhaps I should check that out first...
03:07:47 <JaffaCake> yeah, probably
03:07:52 <dons> JaffaCake: starting to get some jhc and hbc numbers http://www.cse.unsw.edu.au/~dons/nobench/results.html (there's still some bugs in there, after tonight the ones that generate wrong output should be flagged too)
03:07:53 <lambdabot> Title: nobench: Haskell implementation shootout
03:08:07 <JaffaCake> dons: yeah I saw, excellent!
03:08:24 <dons> jhc doesn't compile many things, but some of the ones it does, it does well.
03:08:34 <dons> digits-of-e1 anyway
03:08:39 <JaffaCake> it'd be nice to get normalised numbers (e.g. +10%)
03:08:46 <ejt> how do I use Gen to make a variable length list ?
03:09:00 <dons> yeah. i've got mulitpliers in now. takes about 3 hrs to run the suite though
03:09:04 <dons> so that'll update later tonight
03:09:22 <dons> so it will be: binarytrees  1.45 (1.2)   1.26 (1.0)   92.37 (73.3)
03:09:39 <JaffaCake> ok, cool
03:09:54 <quicksilver> ejt: 'Gen' ?
03:10:07 <dons> most of the 'real' class of programs take specific infput files, but that input is now too small to be of much use
03:10:11 <JaffaCake> dons: geometric means would be nice too ;-)
03:10:16 <ketil> JaffaCake,  I think I found it.  I'm on NFS, doing configure as $USER, and sudo make install.  I guess there's root_squash on, and root isn't allowed to do some parts of the installation.  Still, make reports a successful install.  chmod -R a+rw * solved it.
03:10:18 * dons puts that on his list
03:10:22 <ejt> quicksilver: I've just read http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
03:10:24 <lambdabot> http://tinyurl.com/2fpup7
03:10:41 <ejt> which talks about using the Monad Gen for creating randomness
03:10:57 <ejt> but I don't see how to generate a random list of a given size
03:11:07 <JaffaCake> dons: yes, I recently went through the spectral class and made many of them take variable sized input, so with nofib you can say 'make mode=slow' and most programs take 2s or so
03:11:18 <dons> yeah, saw that. much better
03:11:22 <dons> i'll see if i can do that for real
03:11:31 <JaffaCake> that'd be great
03:11:44 <dons> i'd like to add some more to real, and ditch some of them
03:11:48 <dons> i added djinn
03:11:51 <ejt> eg, generate listLength (mkStdGen 1) intListGen
03:11:57 <dons> and there's a c2hs-generated C parser dcoutts has i'd like to include as well
03:12:06 <dons> instead of the 1990's style 'parser'
03:12:08 <dcoutts> @arr!
03:12:09 <lambdabot> Swab the deck!
03:12:32 <Laney> Is there a function which tests whether something is an element of a list?
03:12:33 <quicksilver> :t choose
03:12:36 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
03:12:40 <quicksilver> lambdabot: `elem`
03:12:55 <JaffaCake> dons: definitely, it's long overdue for a tidyup
03:12:59 <Laney> Thanks quicksilver
03:13:02 <quicksilver> > choose [0,0] [9,9]
03:13:03 <lambdabot>   Not in scope: `choose'
03:13:12 <JaffaCake> we could put Happy in too
03:13:19 <dons> yeah.
03:13:23 <JaffaCake> with GHC's Parser.y as input
03:13:32 <JaffaCake> that takes a few seconds
03:13:41 <dons> yeah, that's a good one.
03:13:43 <quicksilver> > choose ([0,0],[9,9])
03:13:44 <lambdabot>   Not in scope: `choose'
03:13:49 <ketil> It'd be nice to have different benchmarks excercising associative storage (Data.Map, Data.Hashtable, mutable arrays, etc).
03:13:58 <JaffaCake> and Alex while we're at it
03:14:00 <ejt> > choose ([], [9,9,9])
03:14:01 <lambdabot>   Not in scope: `choose'
03:14:03 <dons> the shootout programs are quite nice for this. they seem to pick specific tight 'imaginary' problems
03:14:17 <dons> and either the compiler gets it right, or it fails miserably (ghc gets them right now ;)
03:14:19 <quicksilver> > Test.QuickCheck.choose ([0,0],[9,9])
03:14:19 <JaffaCake> we should be careful about compiler-specific code, though
03:14:20 <lambdabot>   Not in scope: `Test.QuickCheck.choose'
03:14:25 <quicksilver> dons: help :P
03:14:27 <ketil> The shootout will tend to just use whatever is fastest, and often that is roll your own (e.g. a trie for k-nucleotide)
03:14:27 <dcoutts> JaffaCake, yep GHC's parser is longer than my C parser by 500 lines :-)
03:14:43 <dons> quicksilver: QuickCheck isn't in scope
03:15:23 <quicksilver> dons: but it can see the types with :t ?
03:15:26 <quicksilver> :t choose
03:15:28 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
03:15:33 <dons> it can.
03:15:45 <dons> we could add QuickCheck I guess, its pretty harmless (iirc...)
03:15:56 <quicksilver> well you already have @check :)
03:16:13 <dons> dcoutts: so the new 16 core machine has a broken ether adapter
03:16:21 <dcoutts> dons, :-(
03:16:23 <dons> does some bogus dma, and makes the kernel oops
03:16:43 <dons> the 'rapid response team' will have to have a look at it tomorrow
03:17:13 <dons> i suppose we could plug in a a $10 card till then ...
03:17:15 <ejt> dons: who's the manufacturer ?
03:17:22 <dons> tyan.
03:17:33 <dons> the box is a 'tyan thunder' and it sounds like a jet engine taking off (8 fans)
03:17:47 <nornagon> heh
03:18:01 <ejt> I can imagine
03:18:18 <ejt> I once thought it would be a good idea to put 2 Sun E450s in my office
03:19:11 <ulfdoz> ejt: You need a powerful radio then. ;)
03:19:56 <ejt> :t vector
03:19:59 <lambdabot> forall a. (Arbitrary a) => Int -> Gen [a]
03:20:04 <ejt> bingo !
03:20:22 <quicksilver> :)
03:22:13 <pjd> syntaxfree: eck, snap
03:24:08 <dons> oh, yhc bug. it generates wrong output for digits-of-e
03:24:14 <dons> @seen ndm
03:24:15 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 10h 7m 22s ago, and .
03:24:17 <syntaxfree> pjd: it's the free webhost. Icky, I know.
03:24:19 <dons> @seen beelsebob
03:24:20 <lambdabot> I saw beelsebob leaving #haskell 17h 40m 28s ago, and .
03:24:55 <JaffaCake> dons: what are all the compile errors for ghc-old?
03:25:00 <pjd> syntaxfree: oh, ok :/
03:25:06 <dons> oh, that's -fexcess-precision in a pragma
03:25:15 <dons> i.e. {-# OPTIONS_GHC -fexcess-precision #-}
03:25:18 <JaffaCake> ah
03:25:34 <dons> except for circsim.
03:25:37 <dons> that's something else i think
03:25:48 <JaffaCake> why does clausify fail for 6.6?
03:25:52 <pjd> syntaxfree: what's the "Collatz" about?
03:25:52 <dons> you can see the errors here, http://www.cse.unsw.edu.au/~dons/nobench/bench.results
03:26:05 <dons> ghc                  RuntimeError "\"Heap exhausted;use `+RTS -M<size>' to increase it.\""
03:26:32 <JaffaCake> what heap size do you set?
03:26:55 <pjd> given the title and the graphing, i was expecting a graphing of the Collatz sequence :)
03:27:09 <dons> big. see the build logs here, http://www.cse.unsw.edu.au/~dons/nobench/bench.log
03:27:26 <dons>    /clausify 50 +RTS -H128M -M350M -RTS
03:27:29 <syntaxfree> pjd:
03:27:34 <syntaxfree> @google collatz conjecture
03:27:35 <lambdabot> http://en.wikipedia.org/wiki/Collatz_conjecture
03:27:40 <JaffaCake> wow
03:28:00 <JaffaCake> I must go and check that, we shouldn't be using 350M heap for clausify
03:28:21 <pjd> syntaxfree: oh, sorry i mis-skimmed
03:28:30 * pjd shuts up
03:30:36 <jacobian> I have a list of [A|B]  and a function that verifies the property of being an A in A|B, i.e.  A|B -> bool and I want to use this to get [A], is this possible directly, or do I have to write a seperate function [A|B]->[A]
03:31:38 <jacobian> It seems that a filter will simply give me [A|B] such that A|B -> Bool is satisfied when inl
03:31:47 <jacobian> but I want the more specific type
03:33:37 <quicksilver> catMaybes . map, probably
03:33:53 <JaffaCake> dons:  I can't repeat that heap overflow here
03:34:10 <ejt> jacobian: or you can pattern match in a list comprehension:
03:34:19 <quicksilver> :t catMaybes
03:34:20 <dons> JaffaCake: ok. i'll look into it some more.
03:34:22 <lambdabot> forall a. [Maybe a] -> [a]
03:34:35 <quicksilver> > catMaybes [Just 3, Just 4, Nothing, Just 2, Nothing]
03:34:36 <lambdabot>  [3,4,2]
03:34:37 <ejt> [x | x <- a_or_bs, isA x]
03:34:42 <jacobian> right
03:35:33 <jacobian> thanks quicksilver
03:35:41 <quicksilver> ejt's approach is neater actually
03:35:57 <quicksilver> it saves you from explicity writing the function (A|B) -> Maybe A
03:36:01 <ejt> I came across it yesterday reading the source to hscolour
03:36:08 <quicksilver> you get it implicitly in some sense, from the pattern match
03:36:22 <ejt> he did something like:
03:36:38 <ejt> [x | File x <- lst]
03:37:38 <malcolmw> dons: I like the improved look of the nobench results tables
03:37:43 <quicksilver> > let testlist = [Left 5, Right "foo", Left 4::Int, Left 1::Int, Right "bar"]
03:37:43 <lambdabot>  Parse error
03:37:49 <dons> malcolmw: yeah, its getting there.
03:37:58 <quicksilver> > let testlist = [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"]
03:37:58 <lambdabot>  Parse error
03:38:10 <quicksilver> > @let testlist = [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"]
03:38:10 <lambdabot>  Parse error
03:38:16 <dons> malcolmw: though nhc is generating the wrong output on a couple of tests. i'll send in some mails in the morning (the ones that run in 0.01 time)
03:38:16 <quicksilver> @let testlist = [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"]
03:38:19 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
03:38:21 * malcolmw considers writing a simple optimiser for nhc98 to improve our standing
03:38:33 <quicksilver> :t [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"]
03:38:35 <lambdabot> [Either Int [Char]]
03:38:51 <malcolmw> dons: I had a look at the integer benchmark, and neither ghc nor nhc98 were producing any output
03:38:55 <dcoutts> malcolmw, heh, the pressure of benchmarks :-)
03:38:55 <quicksilver> let testlist =  [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"] in [ x | Left n <- testlist]
03:39:03 <quicksilver> > let testlist =  [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"] in [ x | Left n <- testlist]
03:39:04 <lambdabot>   Not in scope: `x'
03:39:09 <ejt> > [x | Left x <- [Left 4, Right "foo"]]
03:39:10 <dons> yeah, i added diffing today. so the current run should spot output issues
03:39:11 <lambdabot>  [4]
03:39:34 <malcolmw> wow, 143 patches to nobench in the last two days
03:40:03 <dons> some of those are mechanically generated though
03:40:16 <Thunder> @pl \y -> [x | Left x <- y]
03:40:17 <lambdabot> return . ((x | Left x) <-)
03:40:34 <Thunder> :t [x|Left x <-]
03:40:36 <lambdabot> parse error on input `]'
03:40:42 <nornagon> O.o
03:40:46 <Heffalump> @t ((x | Left x) <-)
03:40:47 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:40:54 <Heffalump> @type ((x | Left x) <-)
03:40:56 <lambdabot> parse error on input `|'
03:40:58 <dons> JaffaCake: ok, i seem to be able to reproduce it,
03:41:05 <dons> these flags: $ ghc-6.6 -no-recomp -O2 -optc-O2 -fvia-C -optc-march=pentium4  --make -o clausify clausify.hs
03:41:07 <Heffalump> didn't think that was legal :-)
03:41:19 <quicksilver> > let testlist =  [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"] in [ n | Left n <- testlist]
03:41:20 <dons> this program: http://www.cse.unsw.edu.au/~dons/code/nobench/spectral/clausify/
03:41:21 <lambdabot>  [5,4,1]
03:41:21 <lambdabot> Title: Index of /~dons/code/nobench/spectral/clausify
03:41:21 <ejt> y, my brain was saying 'parse error' too
03:41:27 <quicksilver> > let testlist =  [Left 5, Right "foo", Left (4::Int), Left 1, Right "bar"] in [ n | Right n <- testlist]
03:41:28 <lambdabot>  ["foo","bar"]
03:41:33 <dons> JaffaCake: and with expclit rts flags, $ ./clausify 50 +RTS -H64M -M350M
03:41:33 <quicksilver> there you go :)
03:41:40 <dons> JaffaCake: Heap exhausted;
03:41:40 <dons> Current maximum heap size is 349999104 bytes (333 Mb);
03:41:40 <dons> use `+RTS -M<size>' to increase it.
03:41:45 <JaffaCake> wow, ok
03:41:53 <dons> without +RTS ... it just keeps running for a long time (I got bored)
03:41:57 <Thunder> @tell dons @pl \y -> [x | Left x <- y] generates illegal code.
03:41:58 <lambdabot> Consider it noted.
03:42:28 <malcolmw> dons: hmm, I see you added expected results for most programs - how will it cope with minor differences in floating point between architectures?
03:42:51 <dons> possibly badly. we can add expected.$ARCH
03:42:52 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
03:42:54 <JaffaCake> dons: -O2 is the culprit
03:43:00 <malcolmw> I know there are a couple of nofib progs that give different results on sparc/powerpc/intel
03:43:04 <JaffaCake> interesting...
03:43:05 <dons> also, theres some differences in show output between compilers that breaks the diffs too
03:43:10 <ejt> > do {Left x <- [Left 4, Right "foo"]; return x}
03:43:11 <lambdabot>  [4]
03:43:14 <dons> hbc doesn't put negative numbers in parens
03:43:45 <JaffaCake> dons: darn, clausify has killed my box
03:43:53 <dons> wow
03:44:01 <malcolmw> JaffaCake: CR strikes again...
03:44:05 <dons> yay, 1 ghc bug, 1 nhc build system issue, 2 yhc bugs in 2 days!
03:44:10 <dons> yay for nasty programs
03:44:12 <JaffaCake> malcolmw: hehe
03:44:42 <malcolmw> JaffaCake: CR likes to say that, ten years after publishing the clausify benchmark, ghc still can't compile it...
03:44:51 <dons> heh
03:45:17 <dons> i see he wrote a few of the nastier programs in there
03:45:23 <dons> wheelsieve2 isn't so much fun either
03:45:52 <quicksilver> ejt: when the pattern match fails, it calls 'fail' in the monad
03:46:03 <quicksilver> ejt: the list interpretation of 'fail' is []
03:46:07 <ejt> exactly
03:46:10 <quicksilver> ejt: which gives the result you're sseeing
03:46:12 * quicksilver nods
03:46:27 <malcolmw> all the nofib progs that ndm's analyser can't handle were written by CR
03:46:31 <ejt> I do wonder if list comprehensions would have been added if do notation had come first
03:46:41 <JaffaCake> malcolmw: what does he mean by that?
03:46:47 <quicksilver> list comprehensions used be permitted for all monads
03:47:13 <dons> hmm. is there a way to grow the hugs *stack*? hugs fails a bunch of things with stack overflows
03:47:14 <ejt> but no longer ?
03:47:23 <dons> I can't find a -Afoo flag
03:48:01 <malcolmw> JaffaCake: well, clausify revealed lots of space bugs in ghc.  I believe it was the example that persuaded SPJ to handle CAFs correctly.
03:48:18 <quicksilver> ejt: no, it was taken out
03:48:31 <quicksilver> ejt: the translation to do notation is simple enought though, as you observe
03:48:39 <ejt> y
03:48:42 <JaffaCake> I mean, in what sense can GHC not compile it?
03:49:29 <dons> well, it does happily compile clausify.
03:50:18 <JaffaCake> dons: the current HEAD doesn't have the -O2 bug, or at least it doesn't show up with HEAD
03:50:24 <dons> ok. good.
03:50:36 <malcolmw> sorry, not compile/run/whatever it adequately
03:50:50 <dons> is head in a state reasonable enough for me to install and try running on this stuff?
03:50:57 <malcolmw> basically, clausify is good at revealing bugs in compilers is what he means
03:51:06 <JaffaCake> ah ok
03:51:29 <JaffaCake> so are there still knwn inadequacies in how GHC treats clausify?
03:52:21 <malcolmw> JaffaCake: I don't know, but the fact that it gives a runtime error on the nobench results page is suggestive
03:52:23 <JaffaCake> dons: as of yesterday, I think HEAD is working ok
03:52:39 <malcolmw> JaffaCake: or have you identified and fixed that fault now?
03:52:44 <dons> ok. i'll install that tomorrow then.
03:52:50 <JaffaCake> malcolmw: yes we found a bug with -O2
03:53:05 <JaffaCake> it's fixed in the HEAD, but we don't know which patch fixed it yet
03:54:16 <JaffaCake> malcolmw: I was just trying to get at why CR is saying that GHC can't compile clausify, and whether we need to create a bug report
03:55:22 <JaffaCake> dons: HEAD build status is here http://darcs.haskell.org/buildbot/head/
03:55:24 <lambdabot> Title: BuildBot: GHC
03:55:27 <malcolmw> JaffaCake: it was just a humorous comment from him, when we told him yesterday about the nobench failure, that was all.
03:55:45 <JaffaCake> ah I see, thanks
03:56:38 * malcolmw thinks JaffaCake is worried about how tasty his keyboard will be
03:57:36 * JaffaCake looks hungrily at his keyboard
04:00:12 <JaffaCake> malcolmw: I'm less convinced that GHC should go to all the trouble it does to GC CAFs now
04:01:02 <JaffaCake> nhc98 doesn't do that, does it?
04:01:35 <malcolmw> JaffaCake: yep, nhc98 certainly does.
04:01:59 <JaffaCake> oh it does?  is it possible to describe quickly how it works?
04:02:09 <malcolmw> JaffaCake: I'm sure CR would not have let Niklas get away without it
04:02:46 <JaffaCake> well there are various levels of accuracy to GC'ing CAFs
04:03:00 <malcolmw> JaffaCake: I didn't write the garbage collector, so I don't really know.  Tom might, since he rewrote it for Yhc.
04:03:14 <JaffaCake> hmm, ok thanks
04:03:39 <JaffaCake> I'm thinking that GHC is currently trying too hard
04:04:14 <malcolmw> I can have a quick look at the source and see if I can reconstruct the gist of what it is doing, if you like
04:04:39 <JaffaCake> I'd be interested to know, but don't go to a lot of trouble
04:06:19 <ejt> wow, case is really a _lot_ faster than 'let', presumably because it's strict
04:08:16 <EvilTerran> "case (foo) of (bar) -> baz" vs "let bar = foo in baz", you mean?
04:08:22 <ejt> y
04:09:02 <ejt> @paste
04:09:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:09:15 <malcolmw> JaffaCake: looks like nhc98 uses a mark-sweep collector, with pointer-reversal during the sweep phase (for compaction)
04:09:36 <hpaste>  ejt pasted "(no title)" at http://hpaste.org/587
04:09:38 <JaffaCake> right
04:09:59 <ejt> blows the stack if I use let
04:10:05 <JaffaCake> malcolmw: any idea how it traces the references from code to CAFs?
04:10:52 <malcolmw> JaffaCake: I'm just pondering that.  I wonder if it stores CAF references in the info table for the function.  Seems likely
04:10:56 <JohnMeacham_> the new tagged jhc should be much better, and works with the pre-built libraries on the page.
04:11:29 <dons> JohnMeacham_: any changes from this morning?
04:11:43 <dons> i.e. will haskell98 build?
04:12:08 <JohnMeacham_> yes. quite a few changes. but you can just use the pre-built libraries I have put online.
04:12:13 <dons> JohnMeacham_: i have some preliminary numbers for jhc here, http://www.cse.unsw.edu.au/~dons/nobench/results.html
04:12:14 <lambdabot> Title: nobench: Haskell implementation shootout
04:12:24 <dons> but note that the wrong output is produced in some programs, and not detected
04:12:29 <dons> that's fixed now.
04:12:51 <dons> ok. i'll update jhc tomorrow and grab the libs
04:13:25 <malcolmw> dons: it looks like increasing the heapsize to 128M has significantly decreased the performance gap between nhc98 and ghc
04:13:36 <JaffaCake> dons: when can we expect a new set of results?
04:13:52 <dons> temporary results here, http://www.cse.unsw.edu.au/~dons/tmp/x.html
04:13:53 <lambdabot> Title: nobench: Haskell implementation shootout
04:13:59 <dons> but the full set won't be done for a couple of hours
04:14:05 <JohnMeacham_> cool. yeah, the ghc back end does not always do the right thing, there are some primitive impedance mismatch problems that are hard to work around in a general way... I am looking into providing a straightforward STG-style backend for jhc.
04:14:11 <dons> the ghci output error was a warning (fixed)
04:14:17 <JaffaCake> great, ta
04:14:21 <dons> JohnMeacham_: ah of course.
04:14:39 <dons> malcolmw: so it improved nhc98's results?
04:15:00 <JaffaCake> dons: ghc goes quite a bit faster with the default heapsize for some benchmarks
04:15:06 <JaffaCake> due to cache effects
04:15:09 <JohnMeacham_> which should be comparable to ghc more or less directly. I can't really use ghc's runtime though without the same issues. it just has a different world view in certain ways. but I can use its evaluation model.
04:15:13 <malcolmw> JaffaCake: yeah, the CAFs are stored in the info table, so any reference to a function using a CAF will mark the CAF as well, whether or not it is actually live
04:15:15 <dons> ah ok. so maybe there should be some fine tuning of that setting
04:15:23 <quicksilver> a CAF is a definition with a type not of kind * -> * ?
04:15:40 <JaffaCake> malcolmw: is there any attempt to share the tables between functions?
04:15:49 <JohnMeacham_> what is the most recent paper on the STG machine? in particular, one that takes into account the fact that now you do eval-apply rather than push-enter.
04:16:07 <malcolmw> JaffaCake: how do you mean?  what would that achieve?
04:16:17 <JaffaCake> just save some code size
04:16:42 <JaffaCake> oh, nhc98 does lambda lifting, doesn't it?
04:16:50 <malcolmw> JaffaCake: it is only 4 bytes per CAF, and I don't expect there are too many of them in any one program
04:17:12 <malcolmw> JaffaCake:  yes. lambda-lifting
04:17:12 <JaffaCake> but you need to store references to other functions that indirectly reference CAFs, not just CAFs themselves
04:17:40 <dons> JohnMeacham_: the 'push enter or eval apply' paper?
04:17:45 <JohnMeacham_> this new back end will allow partial separate compilation too. libraries (packages) will be compiled to object code directly. that should drastically speed up a lot of things.
04:18:04 <dons> JohnMeacham_: hopefully eh? i notice quite slow compile times ;)
04:18:11 <JohnMeacham_> yeah, that is a good paper.
04:18:16 <malcolmw> JaffaCake: hmm, yes transitive closure of references, I hadn't thought of that.  must look closer at the code
04:18:25 <JaffaCake> JohnMeacham_: there's been no refresh of the STG paper since eval/apply
04:18:47 <JaffaCake> so yes, the eval/apply paper is the latest
04:20:23 <JaffaCake> in case anyone's interested, we recently discovered that vectored returns are no longer an optimisation :)
04:20:27 <JohnMeacham_> ah. okay.
04:20:44 <JohnMeacham_> hmm.. what do you mean by vectorized returns?
04:21:15 <Philippa> you can count me as generally interested, FWIW - looking at back ends seems to be where I get my low-level thinking these days
04:21:33 <JaffaCake> for a case continuation, the alternatives are stored in a return vector, and the constructor returns directly to the appropriate alternative
04:22:17 <JohnMeacham_> ah. I remember reading about that. so now you scrutinize and branch explicitly?
04:22:28 <JaffaCake> we will do, yes
04:23:13 <JohnMeacham_> neat.
04:24:28 <JohnMeacham_> dons: among other things, the new jhc release uses Data.Binary and ZLib for all its serialization.
04:24:45 <dons> ah ok. cool
04:28:00 <JohnMeacham_> cuts down the prebuilt libraries from 25M to 1.2M or so :). though, I do lose some speed due to not having 'lazy' reading of the files. (which would probably be incompatable with zlib anyway). I guess it would be nice if I could have several 'named sections' in a single file. so I can jump directly to the type-checking info or the code-generation info depending on why I am reading the file.
04:28:51 <SamB> um, why couldn't you have lazy reading?
04:28:56 <JohnMeacham_> so. perhaps the best way to do that would be at the LazyByteString level.
04:29:08 <JohnMeacham_> because Data.Binary can't skip over data without reading it.
04:29:41 <SamB> oh
04:29:46 <malcolmw> JaffaCake: I'm not entirely sure, but I think the GC mark phase chases down all functions in the info table, and recursively in their info tables.  Obviously once marked, an info table doesn't need to be looked at again.
04:30:22 <JohnMeacham_> my old one would seek forward in the file as needed. though, I wouldn't mind using explicit named sections in a file. each independently zlibed.
04:31:09 <JaffaCake> malcolmw: right, that's similar to what GHC does
04:32:05 <JaffaCake> malcolmw: any idea how references from the stack are handled?
04:32:06 <SamB> except GHC doesn't keep the whole module in the interface file ;-)
04:32:39 <JohnMeacham_> dons: could Data.Binary export a number like 'version' that is bumped every time the internal format changes? I have a header I spit out into files i generate, and it would be nice to include that.
04:32:39 <malcolmw> JaffaCake: well the stack is the root set for GC essentially
04:33:00 <JaffaCake> yes - but stack frames must have references to CAFs too
04:34:03 <malcolmw> JaffaCake: not sure I follow.  nhc98's stack is the spineless G-machine stack
04:34:25 <dcoutts_> JohnMeacham_, just define a newtype Header a = ... that when serialised adds the binary format number
04:34:26 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
04:34:39 <JohnMeacham_> my big stumbling block at implementing new back ends is root finding for the GC. there is no nice answer as far as I can tell.
04:34:58 <JaffaCake> malcolmw: so a case expression works by pushing a continuation frame on the stack, and evaluating the scrutinee expression, right?
04:35:08 <JohnMeacham_> dcoutts_: indeed. that is what I do, but I don't have that binary format number to add :)
04:35:22 <JaffaCake> the continuation frame may refer to some CAFs and top-level functions, and the GC needs to follow those references
04:36:24 <SamB> "binary format number"?
04:36:26 <dcoutts_> JohnMeacham_, hmm, I suppose we could try and track all changes to the format with a increasing version number.
04:36:40 <JohnMeacham_> though, I thought a neat feature would be a 'hash :: a -> Word64' method to Binary, that create a hash of the 'form' of the type.
04:36:52 <malcolmw> JaffaCake: no, I don't think so.  case is implemented as a table-switch - eval the top of stack, scrutinise the constructor, then jump forward in the bytecode according to the lookup
04:37:45 <JohnMeacham_> dcoutts_: yeah, I mean, I imagine it won't be updated very often at all. but it would be nice to have, as reading bad data often fails poorly otherwise.
04:37:47 <JaffaCake> ok, but while evaluating the top-of-stack, the continuation is the current byte-code sequence, and there may be a stack of such continuations
04:37:53 <dcoutts_> JohnMeacham_, btw, I have been thinking of a rope-like extension to lazy byte string that'd allow skipping to places later in the file without reading all the intervening data
04:39:11 <malcolmw> JaffaCake: so the context of the current evaluation is an application, yes, which is stored lower down the stack, and so is a root for GC
04:40:02 <JohnMeacham_> dcoutts_: yeah. something like skip-lists perhaps? though. at the moment, I think I will go ahead and implement a file format with explicit segments, each of which can independently be read by a LazyByteStream... though.. hmm.. seeking a file that is being lazily read probably won't work to well... hrm..
04:40:30 <dcoutts_> JohnMeacham_, indeed it would not work since the file handle will be semi-closed
04:40:39 <JaffaCake> malcolmw: when the eval in a case expression returns, what does it return to?
04:42:56 <Cheery> When I'm trying to install the debian package from ghc6.6, it says:
04:43:06 <JohnMeacham_> is 'hGet' lazy? I could open the same file several times I guess.
04:43:21 <Cheery> "Error: Dependency is not satisfiable: libc6"
04:43:35 <SamB> Cheery: fantastic!
04:43:59 <SamB> um, do you have an apt sources?
04:44:04 <SamB> s/an/any/
04:44:50 <malcolmw> JaffaCake: not sure what you mean.  The bytecode for a case is something like: PUSH_ARG_I3, EVAL, TABLESWITCH 2 4 15, alt0, alt1
04:44:59 <Cheery> well, when I'm looking into synaptic package manager, it says thought that I have libc6
04:45:13 <SamB> Cheery: another point
04:45:16 <SamB> most people do
04:45:48 <SamB> how did you try to install ghc 6.6?
04:46:05 <SamB> and you are sure there was no version number involved in this error message?
04:46:08 <Cheery> from .deb -package I got from debian.org
04:46:22 <Cheery> SamB: I can try it again.
04:47:03 <malcolmw> JaffaCake: so after the eval, the bytecode resumes at the tableswitch.  So eval pushes a stack frame containing the current evaluation context, instruction pointer, and so on.
04:47:07 <SamB> that error would make sense if it said "libc6 (>=foo.bar)"
04:47:20 <SamB> where by foo.bar I mean a version number
04:47:21 <JaffaCake> malcolmw: right, that's exactly what I'm getting at
04:47:52 <Cheery> SamB: sudo gdebi ghc6_6.6-3_i386.deb
04:47:59 <SamB> oh
04:48:00 <JaffaCake> malcolmw: the evaluation context may refer to CAFs - e.g. in one of the branches of the case, you might return a CAF
04:48:04 <SamB> I heard gdebi sucks
04:48:05 <Cheery> Dependency is not satisfiable: libc6
04:48:19 <SamB> what distro are you using?
04:48:21 <JaffaCake> so the GC must do something with evaluation contexts, mustn't it?
04:48:22 <Cheery> ubuntu
04:48:56 <SamB> thought so. do you pull from the "universe" repository?
04:49:50 <Cheery> yes.
04:50:25 <SamB> you could search for "ghc6.6" in synaptic or aptitude
04:50:29 <malcolmw> JaffaCake: yes.  the stack holds a black-holed pointer to every piece of graph that is under evaluation.  such graph fragments contain references to functions, and these have their info tables traced for possible CAFs
04:50:33 <SamB> or just run apt-get install ghc6.6
04:50:44 <SamB> I think that ought to work
04:50:56 <SamB> (unless it be in multiverse?)
04:51:15 <JaffaCake> malcolmw: ok, so I conjecture that I can construct an example for which nhc98 has a space leak due to CAFs but GHC doesn't
04:51:16 <Cheery> it can't find such package.
04:51:29 <JaffaCake> I also conjecture that nobody cares :)
04:51:38 <malcolmw> JaffaCake: OK, I look forward to seeing it :-)
04:51:55 <malcolmw> JaffaCake: I'm pretty sure CR would care, if we told him
04:52:23 <SamB> JaffaCake: space leak due to CAFs?
04:52:33 <SamB> what sort of space leak?
04:52:44 <JaffaCake> I don't think you distinguish between CAFs that are referred to *before* the case expression from those that are referred to *after*, in a particular code sequence
04:52:51 <SamB> Cheery: huh.
04:53:04 <SamB> well, you could try dpkg -i ghc6_6.6-3_i386.deb
04:53:08 <malcolmw> JaffaCake: are you saying that, because of the conditional branch, there might be a CAF in the non-live branch, but nhc98 will retain it anyway and ghc will not?
04:54:08 <Cheery> huh, SamB, I think it works!
04:54:11 <SamB> Cheery: or you could add the "multiverse" to your sources.list somehow, but I'm not going to suggest that because it will probably cause apt to "upgrade" some of your other packages to half-baked versions or something ;-)
04:54:16 <erider> good morning
04:54:20 <JaffaCake> malcolmw: suppose one of the evaluation contexts on the stack is a case expression in the middle of a function.  You'll retain all CAFs reachable from that function, but GHC only retains CAFs reachable from the branches of the case
04:54:27 <Cheery> or wait
04:54:33 <Cheery> it doesn't. :(
04:54:38 <Cheery> but I got a better error message. :)
04:54:58 <Cheery>  ghc6 depends on libc6 (>= 2.3.6-6); however:
04:54:58 <Cheery>   Version of libc6 on system is 2.3.6-0ubuntu20.
04:55:58 <malcolmw> JaffaCake: yeah sure, we don't split functions to have separate info tables at different points in their execution
04:56:12 <JaffaCake> right, that's the difference
04:56:28 <JaffaCake> so do you believe I could construct a bad example?
04:56:38 <malcolmw> JaffaCake: sure I believe you can
04:56:48 <JaffaCake> do you think CR would care?
04:57:25 <malcolmw> JaffaCake: but nhc98 does split functions at other places
04:57:49 <malcolmw> JaffaCake: through lambda-lifting I guess
04:57:53 <JaffaCake> yes
04:58:26 <malcolmw> JaffaCake: if you can demonstrate a bad enough space leak, i think you'll get his attention :-)
04:58:55 <JaffaCake> well I can construct an arbitrarily bad space leak...
04:59:08 <JaffaCake> how many Gb would get his attention? :)
04:59:57 <JaffaCake> perhaps if I transformed clausify such that it had a new CAF space leak... <evil grin>
04:59:58 <malcolmw> JaffaCake: in a real program, or just by an artificial but pathological construction?
05:00:23 <quicksilver> Most IRC users are artificial and pathological constructions
05:01:27 <Cheery> So. It seems I can't install the debian package, unless if I find some way to upgrade that libc6
05:04:53 <JaffaCake> malcolmw: so actually this conversation is going in the wrong direction... I don't *want* GHC to be this clever, because it's hard and I don't think anyone really cares, I'd like to find a better compromise between complexity and usefulness
05:05:29 <JaffaCake> it's really helpful to know what nhc98 does, thanks for that
05:06:00 <JaffaCake> what's more, I can construct examples that GHC still doesn't catch
05:06:12 <malcolmw> JaffaCake: is it difficult to maintain?  I'd have thought that once you've gone to the effort of implementing it, you might as well keep it
05:06:49 <JaffaCake> tracing CAFs at GC time isn't cheap, I have the feeling we're doing it on too fine a granularity
05:07:35 <malcolmw> JaffaCake: it would be nice to have some numbers to firm up your feeling
05:08:13 <JaffaCake> I once measured that there was a static 0.1s penalty in every major GC in GHC just for tracing the static reference graph
05:09:52 <Cheery> aah, got further.
05:10:07 <Cheery>  /usr/local/lib/ghc-6.6/ghc-6.6: error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory
05:10:53 <beelsebob> not quite sure how they would be pattern matched though
05:10:55 <beelsebob> bah
05:10:56 <beelsebob> fail
05:11:05 * beelsebob tries to stir some discussion by suggesting that Haskell' should have disjunctive tuples as (5 | 6 | 7)
05:11:16 <beelsebob> was what I meant to say
05:11:41 <beelsebob> (yes, I know this is just Either, but then Tuples are easily represented as ADTs too)
05:12:11 <SamB> um
05:12:15 <SamB> you can't do that with Either
05:12:25 <SamB> you have to pick one ;-)
05:12:30 <beelsebob> exactly
05:12:38 <beelsebob> okay yes... bad example :P
05:12:41 <quicksilver> beelsebob: tuples are just syntactic sugar for an ADT
05:12:48 <Cheery> aaah. the hell is over.
05:12:49 <quicksilver> beelsebob: what syntactic sugar are you suggesting?
05:12:53 <Cheery> now I have ghc6.6
05:13:00 <quicksilver> beelsebob: how shall we denote 'which alternative'?
05:13:11 <beelsebob> quicksilver: in a type definition we might have (Int | Error)
05:13:22 <quicksilver> beelsebob: and when you use the value?
05:13:25 <beelsebob> in the function we might have ( | "Bugger, it blew up")
05:13:30 <quicksilver> ah
05:13:35 <beelsebob> similarly in the patern match
05:13:42 <quicksilver> so constructors like (||| . ||)
05:13:45 <quicksilver> and so on?
05:13:52 <beelsebob> yeh, it's not as nice as it could be is it
05:14:02 <Cheery> Is there some useful utilities I should know with ghc?
05:14:05 <beelsebob> *wonders if there should be something to indicate "nothing here" *
05:14:07 <quicksilver> I can see that could be useful for some tricks, yes
05:14:20 <quicksilver> but to be honest with more than 2 or 3 alternatives I'd want to name them, I think
05:14:25 <beelsebob> indeed
05:14:39 <quicksilver> (just like when tuples get bigger than 2 or 3 people tend to use the 'record syntax')
05:14:41 <beelsebob> but I think for small cases it's particularly nice
05:14:43 <Philippa> a more general extensible variant system's probably the way to go
05:14:50 <Cheery> for example, I've seen .cabal -named scripts in modules, what those are?
05:14:50 <quicksilver> Philippa: like which what?
05:15:29 <Philippa> quicksilver: something with row polymorphism or something along those lines, I guess
05:15:40 <Philippa> though personally I'd like pre-declared labels
05:16:03 <beelsebob> thought for the day... we have (broken) records
05:16:08 <beelsebob> why don't we have unions as well?
05:16:15 <beelsebob> the disjunctive case seems to be ignored a lot
05:16:31 <quicksilver> you can argue that Either is union, can't you?
05:16:34 <quicksilver> well, disjoint union
05:16:36 <beelsebob> you can
05:16:42 <quicksilver> (and types are disjoin by definition, most people woudl say)
05:16:57 <quicksilver> type inference has a tough time if types aren't disjoin
05:16:58 <beelsebob> I'd argue that you want named feilds *more* for unions than you do for records though
05:17:19 <beelsebob> indeed
05:17:51 <Philippa> but we already have named fields though, they're called constructors
05:18:25 <beelsebob> this is true
05:18:35 <beelsebob> not named consistantly with record syntax though :/
05:18:54 <Philippa> it's all those other languages that screw up - hence why I don't want to write compilers in Java
05:18:59 <beelsebob> (named consistantly with the same way you can do conjunction with ADTs)
05:19:15 <beelsebob> I can see why union syntax isn't there
05:19:15 <Cheery> hmm, it was frighteningly simple to install ghc6.6 after all. :/
05:19:18 <Cheery> there must be trick in it.
05:19:26 <beelsebob> but I still like the (Int | Error) syntactic sugar
05:19:26 <Philippa> sure, that's because algebraic datatypes offer us slightly more structure than records do
05:19:41 <earthy> otoh
05:19:52 <earthy> there are some things that you might want to do
05:20:05 <earthy> that would necessitate records again
05:20:16 <beelsebob> hmm?
05:20:18 <quicksilver> beelsebob: syntactic sugar at the *type* level isn't very interesting though
05:20:26 <quicksilver> beelsebob: since we don't write types very often
05:20:29 <apfelmus> Cheery: run  ghci to test whether it works
05:20:32 <beelsebob> quicksilver: no, it's not insteresting -- it's useful though
05:20:39 <quicksilver> beelsebob: syntactic sugar at the value level is what you want
05:20:48 <Cheery> apfelmus: tested already.
05:20:49 <Philippa> earthy: sure. Really you want extensible records pretty fast at that point though
05:20:52 <earthy> but that's mostly syntactic sugar at the value level
05:20:57 <beelsebob> I'd really like to be able to write ( | "bugger") rather than Right "bugger"
05:21:01 <quicksilver> (3|) and (|"foo") don't even lex, though
05:21:09 <earthy> phillipa: exactly. I'd *kill* for good extensible records
05:21:12 <Philippa> quicksilver: you've not tried writing type annotations for some of the stuff that gets produced in typical code using arrows, have you?
05:21:23 <quicksilver> Philippa: I think I overstated my case
05:21:39 <quicksilver> Philippa: but certainly the verbosity of 'Eitehr Int String' doesn't bother me
05:21:49 <quicksilver> Philippa: but the verbosity of Left 5 does, occasionally
05:21:51 <quicksilver> although not much
05:21:57 <pejo> earthy/Philippa, how are records extended, if not through subtyping?
05:22:19 <quicksilver> ocaml has extensible, subtyping records
05:22:22 <apfelmus> Cheery: ah, ok :) The .cabal files are for installing the modules.
05:22:22 <quicksilver> and it's a bloody mess
05:22:23 <quicksilver> (IMO)
05:22:26 <earthy> pejo: by having the record carry along a dictionary containing all the fields in them
05:22:30 <beelsebob> quicksilver: the verbosity in practise does actually bother my, but what bothers me more is the arbitrary names
05:22:33 <earthy> s/them/int
05:22:36 <earthy> (it
05:22:36 <earthy> )
05:22:43 <quicksilver> mostly because of the contravariance problem
05:22:47 <beelsebob> sometimes I don't want to name the parts of the union
05:22:55 <Cheery> apfelmus: are they easiest way to install them?
05:23:00 <beelsebob> sometimes I specifically don't want to call them Left and Right
05:23:06 <Cheery> or is there something which would be even easier?
05:23:25 <quicksilver> beelsebob: then call them something else :) defining a new ADT is cheap
05:23:34 <earthy> beelsebob: for those cases, define your own functions sugaring Left and Right away
05:23:39 <beelsebob> quicksilver: not as cheep as ( | doom )
05:23:44 <quicksilver> data blah = A Int | B String | C Fish | D Dog
05:23:51 <apfelmus> Cheery: yes. in fact, you just type "runhaskell Setup.lhs configure", "runhaskell Setup.lhs build", "runhaskell Setup.lhs install" and you're done.
05:23:53 <earthy> > let wrong = Left ; right = Right in Wrong 5
05:23:53 <apfelmus> @where cabal
05:23:54 <lambdabot>   Not in scope: data constructor `Wrong'
05:23:54 <lambdabot> http://www.haskell.org/cabal
05:23:57 <earthy> > let wrong = Left ; right = Right in wrong 5
05:23:58 <lambdabot>  Left 5
05:24:12 <quicksilver> beelsebob: true, though
05:24:24 <quicksilver> beelsebob: I could see (|) as syntacti sugar 'like tuples'
05:24:27 <earthy> patternmatching isn't quite as nice then anymore though
05:24:50 <quicksilver> (|"blah") :: forall a . ( a | String )
05:24:54 <quicksilver> right?
05:24:57 <beelsebob> yeh
05:25:08 <quicksilver> and (|"blah"|) similarly
05:25:23 <quicksilver> would be a fairly conservative extension
05:25:33 <beelsebob> indeed
05:25:39 <quicksilver> but it would remove all sequences of |s out of the valid operator lexeme
05:25:40 <apfelmus> Cheery: i mean the standard libraries are already installed, but most additional libraries can be easily installed with cabal.
05:25:46 <beelsebob> in fact... as many bars as your sanity can deal with
05:25:59 <quicksilver> well, just like commmas in tuples
05:26:02 <JaffaCake> malcolmw: do you know if YHC has the same behaviour w.r.t. CAFs as nhc98?
05:26:04 <beelsebob> quicksilver: no, all sequences of |s only surrounded by brackets
05:26:14 <beelsebob> so ||| wouldn't be an operator
05:26:17 <beelsebob> but |||- would be
05:26:20 <Cheery> apfelmus: neat.
05:26:36 <quicksilver> beelsebob: you could do that, yes. remove only sequences of 'pure |s'
05:26:38 <quicksilver> :t (|)
05:26:40 <lambdabot> parse error on input `|'
05:26:51 <quicksilver> ah, that's reserved for guards anyway
05:26:52 <quicksilver> hmm
05:26:54 <beelsebob> course
05:27:03 <beelsebob> so yeh... it wouldn't even have a negative impact
05:27:08 <Cheery> now when you talk about pattern matching, how can you turn the pattern matching to lambda calculus?
05:27:10 <apfelmus> Cheery: indeed. The libraries themselves are preferably found on hackage
05:27:11 <beelsebob> all previous programs would still compile
05:27:11 <apfelmus> @where hackage
05:27:11 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
05:27:21 <quicksilver> beelsebob: suggest it on the mailing list
05:27:25 <beelsebob> I will do
05:27:35 <Cheery> for example, what happens for: \(x:_) -> x   ?
05:27:37 <beelsebob> where is the mailing list again?
05:27:48 <Philippa> Cheery: church encodings
05:28:14 <Philippa> though that one's particularly easy because you don't have to handle the case where it's not a cons
05:28:37 <quicksilver> or you can view that as \y -> case y of (x:_) -> x | error "pattern match"
05:29:31 <quicksilver> although I forget if the strictness implications are precisely the same? I think they are?
05:30:11 <Philippa> Cheery: there's a standard encoding for sums (equivalent to Either), you can build it up from there
05:32:48 <Cheery> Philippa: how church encodings correspond to this?
05:33:10 <mightybyte> I'm new to Haskell and am looking for a good project to work on to aid my learning.  Any suggestions?
05:33:33 <malcolmw> JaffaCake: I don't know about yhc's GC, tom rewrote it extensively
05:33:41 <Cheery> \(x:_) -> x would be equivalent to something like: (\(List x _) -> x)
05:33:43 <JaffaCake> I see
05:33:58 <beelsebob> emails away!
05:34:35 <Cheery> which would be equivalent to that x gets the head cell of List, and everything else is ignored.
05:34:48 <ketil> Just checking, but it is sufficient to bang-pattern a parameter only in one pattern match ..er.. clause? for the function?
05:35:43 <beelsebob> ketil: presumably that forces its evaluation in all patters subsequent to that one
05:35:47 <malcolmw> JaffaCake: I just found the following comment in the yhc mark phase:
05:35:51 <Cheery> huh, freaky, I think I understand it.
05:35:58 <Philippa> Cheery: that's not desugaring to lambda calculus, you just renamed a constructor
05:36:01 <malcolmw>      The other thing that the code does is thread in new CAFs as it marks. Then
05:36:01 <malcolmw> as the last stage
05:36:01 <malcolmw>      of the mark algorithm it scans all the CAFs, marking any nodes that are in
05:36:01 <malcolmw> the constant table
05:36:01 <malcolmw>      and adding any new CAFs to the *end* of the CAF list (if it added them to t
05:36:02 <malcolmw> he beginning it would miss them).
05:36:06 <ketil> beelsebob, presumably, yes.  Testing now :-)
05:36:14 <Philippa> raw lambda calculus doesn't know what a list is
05:36:36 <JaffaCake> malcolmw: could you try the primes program from nofib with nhc98 and see if it space leaks?  It leaks with YHC for me
05:36:48 <JaffaCake> http://darcs.haskell.org/nofib/imaginary/primes/Main.hs
05:37:01 <Cheery> Philippa: I see..
05:37:37 <Philippa> so presumably you didn't quite mean what you were asking?
05:38:04 <Cheery> no, When I think of it, your right.
05:40:27 <beelsebob> @type |||
05:40:30 <lambdabot> parse error on input `|||'
05:40:32 <beelsebob> @type (|||)
05:40:35 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
05:42:17 <malcolmw> JaffaCake: hrumph, hp2graph is seg faulting for me on primes
05:43:30 <quicksilver> but dont' we encode ADTs in raw lambda by adding an 'elimination rule' for each data type?
05:43:36 <quicksilver> and that elimination rule is case?
05:44:35 <Philippa> quicksilver: you need to do that in a CBV calculus
05:44:45 <Philippa> you don't need to in general
05:45:19 <quicksilver> Philippa: if you have a moment, what do you do in general?
05:45:29 <quicksilver> I think I might have learn this once but if so, it has slipped away
05:46:27 <Philippa> you have left and right tags which take a single parm (the data), and then take two parms and apply the first or second one respectively to the data
05:46:34 <Philippa> that gets you Either, and you build from there
05:47:13 <quicksilver> :t either
05:47:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:47:28 <quicksilver> Philippa: that's that, isn't it? with params described in a different order?
05:48:30 <Philippa> nearly
05:48:49 <Philippa> what you get from left foo or right foo is equivalent to either with the Either already applied
05:49:28 <quicksilver> ah, sorry
05:49:55 <quicksilver> is that different from an elimination rule, though?
05:50:01 <quicksilver> sounds similar to my fuzzy head
05:50:05 <Philippa> yes, because it's not an addition to the calculus
05:50:18 <malebria> Is there a way to specify records selector as functions?
05:50:31 <quicksilver> malebria: record selectors are automatically functions
05:50:46 <malebria> Something like f record selector = record {selector = 1}
05:51:02 <malebria> quicksilver: this kind of code is saying that selector is not a selector
05:51:10 <quicksilver> ah
05:51:21 <Philippa> you can't do that currently with nice syntax
05:51:22 <quicksilver> well selectors tend to have different types...
05:51:27 <Philippa> the best you can do is put it in a guard
05:51:38 <Philippa> or... well, for update I think you're a bit stuck
05:52:11 <malebria> How can a guard help me?
05:52:13 <quicksilver> Philippa: Ah, I think I'm catching on
05:52:38 <Philippa> malebria: it can't because you're doing an update. Sorry, my bad. Would be nice if those were generated for us as well as the getters
05:52:54 <quicksilver> Philippa: so instead of Left a, you have 'left a'
05:53:00 <malebria> Philippa: hum, ok. Thanks.
05:53:08 <malebria> It'd be very nice if that was possible.
05:53:27 <quicksilver> Philippa: left :: a -> (a->c) -> (b->c) -> c
05:53:34 <Philippa> quicksilver: right
05:53:43 <quicksilver> Philippa: right :: b -> (a->c) -> (b->c) -> c
05:53:47 <malebria> Do you guys know an alternative for this situation?
05:53:52 <quicksilver> then 'left a' and 'right b' both have the same type
05:54:06 <Philippa> bingo
05:54:09 <quicksilver> so essentially you model 'Either a b' as the type (a->c) -> (b->c) -> c
05:54:10 <malebria> It really need to specify what field I want to change with a parameter.
05:54:29 <Philippa> and then you can encode n-way sums by nesting
05:54:37 <quicksilver> malebria: you make another small ADT with the same number of elements as you have selectors
05:54:48 <quicksilver> malebria: and you use that to 'choose' which you want
05:55:00 <Philippa> or you just write update funcs for each field
05:55:22 <malebria> I'll think which is better here/
05:55:28 <Cheery> Philippa: I guess desugaring the pattern matching -stuff is easy, am I right?
05:55:31 <chessguy> 'morning haskellers
05:56:58 <Philippa> Cheery: desugaring a 'simple' case statement to that's easy, yeah. Real compilers don't use a plain lambda calculus as an intermediate rep anyway though
05:57:59 <Cheery> Philippa: I'm interested about pure lambda calculus in this case. :)
05:58:22 <Philippa> okay. Do you know what I mean by a 'simple' case statement?
05:58:57 <Philippa> also, when was your homework assignment set? :-)
05:59:04 <Cheery> not sure, do you mean something such as: case x of 1 -> ... 2 -> etc.
05:59:09 <Cheery> ?
05:59:31 <Philippa> doesn't have to be numbers, does have to avoid nested patterns
05:59:38 <vincenz> This is odd, does Oleg avoid the camera?
05:59:48 <vincenz> There's this page gonline about Friedman's 60th bday
05:59:54 <vincenz> and then some people have individualp picutres
05:59:58 <vincenz> of everyone...except oleg
06:01:53 <hpaste>  (anonymous) pasted "selector choice" at http://hpaste.org/588
06:02:03 <quicksilver> malebria: there's one way of doing it
06:02:49 <quicksilver> the problem is that in the expression foo{selector=1} the selector is not a first-class object
06:02:53 <quicksilver> that's a special syntax
06:04:00 <malebria> quicksilver: yes, but it'd be good if this special syntax supports this
06:04:16 <quicksilver> malebria: you want to 'pass a selector' to a function
06:04:24 <chessguy> suppose i have a [Int]. i want a function f :: [Int] -> [Int] such that, if the sum is at least k, and the nth number is the one that gets the sum over k, i want to return the whole list with just the nth number doubled. if the sum is not at least k, i want to just return the whole list. is there a better way to do this than just raw recursion?
06:04:27 <quicksilver> you can only 'pass' things which are first-class objects
06:04:59 <malebria> quicksilver: that solution is ok, I'm using a class, so I'll just define a function that makes the selection.
06:05:03 * quicksilver nods
06:05:24 <quicksilver> my version 'concretises' selector choice into a first class object
06:05:28 <quicksilver> at the cost of boilerplate
06:05:32 <quicksilver> (defining that new object)
06:05:33 <malebria> quicksilver: I already had a function that defines the selector, but now I'll have to do another one that changes that field.
06:05:34 <jacobian> are there any lazy programming languages where there is a syntactic distinction between data and codata?
06:05:37 <quicksilver> erm, new data type
06:05:57 <malebria> quicksilver: the function related to the selector is first-class.
06:06:00 <quicksilver> jacobian: isn't that what 'Charity' does
06:06:02 <quicksilver> malebria: this is true
06:06:10 <quicksilver> malebria: but it doesn't contain information about which field it represents
06:06:13 <malebria> quicksilver: So I think that what should change is just the support of the syntax.
06:06:18 <quicksilver> malebria: it is 'only' the projection function
06:06:24 <quicksilver> malebria: it doesn't have the 'ability' to update
06:06:25 <malebria> hum...
06:07:00 <quicksilver> Anyone around with good categorical intuition?
06:08:54 <Cheery> Philippa: to pattern match with some lambda like lcCons... one would need to reverse it, I guess.
06:10:47 <Cheery> resulting with a function which has similar holes.
06:13:06 <hpaste>  chessguy pasted "Here's the raw recursive version of what i want to do" at http://hpaste.org/589
06:13:14 <chessguy> i think that should be right
06:14:59 <quicksilver> chessguy: I think f is itself f' 0
06:15:06 <quicksilver> chessguy: which saves you a bit of repetition
06:15:34 <chessguy> mmm, yes, but i don't particularly want to call f with that extra parameter
06:15:36 <chessguy> i suppose i could
06:15:39 <quicksilver> no no
06:15:48 <quicksilver> just write f = f' 0 where f' ....
06:15:54 <quicksilver> save yourself the 'top-level case'
06:15:56 <chessguy> oh right, ok
06:16:06 <Saizan> say i have data Letter = A | B | C | D | ... | Z, is faster a isVocal written by pattern matching or one that uses a Data.Set and the member function?
06:16:29 <quicksilver> Saizan: pattern match, I would imagine
06:16:43 <Syzygy-> Wouldn't pattern match be compiled away in a lot more cases than member?
06:17:01 <hpaste>  chessguy annotated "Here's the raw recursive version of what i want to do" with "like this" at http://hpaste.org/589#a1
06:17:03 <quicksilver> pattern match is also naturall compiled (like switch in C) to a JMP
06:17:24 <quicksilver> chessguy: yes, like that :)
06:17:46 <chessguy> it seems like this should be related to some kind of fold
06:18:14 <quicksilver> chessguy: it certainly could be produced by a fold, but I suspect a rather ugly one
06:18:41 <Saizan> member claims to be O(log n) while pattern match is linear, but if it's a JMP...
06:18:53 <chessguy> it's sort of a fold which cuts out early
06:19:03 <quicksilver> pattern match can be O(1)
06:19:11 <chessguy> i wonder if the ugliness can be abstracted out
06:19:13 <quicksilver> chessguy: I think it's more like a map which carries some state along
06:19:25 <earthy> !sigh wxhaskell
06:19:27 <chessguy> uh
06:19:34 <quicksilver> chessguy: maybe it's a mapM in a simple state monad
06:19:43 <chessguy> hmm
06:19:57 <quicksilver> (the state is your y parameter)
06:20:22 <chessguy> yes
06:22:57 <michaelw> quicksilver: [re patmatch faster than Data.Set.member] only if patmatch uses a jump table, or a match tree or something equally smart, otherwise it's linear in the alphabet size
06:23:00 <Philippa> quicksilver: it's hard to make pattern match O(1) if you have extensible variants or something else stopping you from counting your tags from 0 with each type though
06:23:20 <Philippa> a match tree's not constant
06:24:32 <ndm> @seen dons
06:24:32 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 1h 47m 11s ago.
06:24:41 <michaelw> Philippa: a (log n) member impl. is not constant time either
06:24:52 <quicksilver> I just assumed since constructor matching in haskell is always a finite list (with a couple of primitice exceptions) it should be compiled to finite time
06:24:54 <ndm> @tell dons you seem to be getting diff errors for hacle, any change matt can find out what hte diff looks like?
06:24:54 <lambdabot> Consider it noted.
06:25:03 <quicksilver> I've no idea how it's implemented by the compiler, though
06:25:28 <michaelw> "finite time"?
06:26:16 <Philippa> michaelw: yeah, fair enough :-)
06:26:16 <norpan> pattern matching is definitely "finite time"
06:26:30 <ketil> Any way to get ghci to print stack (or any other useful information about a stack overflow)?
06:26:35 <michaelw> brute-forcing TSP is also "finite time" :)
06:26:56 <michaelw> ketil: compile with profiling, start with +RTS -xc
06:26:59 * quicksilver grins
06:27:02 <quicksilver> "constant time" sorry
06:27:03 <Saizan> chessguy: this seems quite similar to the dropWhile article on TMR, and in the end the better way was raw recursion :)
06:27:07 <ulfdoz> Doesn't NP-complete usually mean to bruteforce?
06:27:33 <quicksilver> NP-complete means 'to any algorithm'
06:27:46 <ketil> michaelw,  still with ghci?  (I don't really have a 'main'  module at this point, could mock one up, though)
06:28:00 <michaelw> ulfdoz: there are very good heuristics for TSP, even with error boundaries
06:28:09 <quicksilver> and asserts that you have proved that any fast algorithm would be transformable to a fast solution to all NP problems
06:28:13 <chessguy> heh
06:28:15 <norpan> quicksilver: linear in the number of constructors, which is a constant, so constant time :)
06:28:29 <michaelw> ketil: oh, sorry, i missed the 'i' in "ghci"
06:28:58 <norpan> or do you mean something else?
06:28:58 <ulfdoz> michaelw: I do not consider a heuristic to be a solution. Except in some rare cases it is an approximation.
06:29:55 <michaelw> ulfdoz: well, I live in the Real World, I'll welcome you when you make it here. ;-P
06:30:04 <ski_> (beelsebob : recently i was thinking about a notation for matching on such "nonlabelled variants" ..)
06:30:24 <Saizan> well member is constant as well for a Set with constant elements..
06:30:25 <ski_> @src RealWorld
06:30:26 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:30:40 <Saizan> but that's not very helpful
06:30:53 <ski_> @hoogle RealWorld
06:30:54 <lambdabot> Control.Monad.ST.RealWorld :: data RealWorld
06:31:17 <ulfdoz> michaelw: I haven't said, that heuristics are bad in any way and I use them too, because they are worth it in practice.
06:31:46 <ulfdoz> michaelw: But it is a difference to solve a problem or to approximate a solution.
06:31:56 <chessguy> Saizan, i'm wondering though if the raw recursion can be easily abstracted out
06:32:28 <norpan> unless the number of constructors change at run-time of course, but usually they don't
06:32:42 <chessguy> it'll still be ugly, but it'll leave me with a (hopefully) useful operator in its place
06:32:47 <chessguy> ?src foldr
06:32:47 <lambdabot> foldr k z xs = go xs
06:32:48 <lambdabot>     where go []     = z
06:32:48 <lambdabot>           go (y:ys) = y `k` go ys
06:32:55 <chessguy> i mean, by itself that's pretty ugly
06:33:15 <Saizan> chessguy: runUntilConditionAndDo cond action list?
06:33:53 <Saizan> maybe with a better name :)
06:34:27 <chessguy> lol
06:35:17 <chessguy> i'm trying to work out what the t ype would be
06:35:58 <norpan> isn't that unfoldr sort-of?
06:36:05 <Saizan> mmh it's a bit more complex than that
06:36:15 <chessguy> ?hoogle unfoldr
06:36:16 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
06:36:16 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:36:45 <Thunder> Funny why this difference in two identical definitions?
06:36:55 <chessguy> mmmm, no, my function takes a list
06:37:05 <norpan> chessguy: a can be a list
06:37:16 <chessguy> hmm
06:37:21 <Saizan> a should be a tuple of the list and the accumulator
06:37:36 <norpan> a can be ANYTHING :)
06:37:59 <jacobian> or any one thing
06:38:07 <Thunder> norpan: No, it is restricted be have a kind of *
06:38:14 <jacobian> ah yeah :)
06:38:24 <jacobian> don't want our universes collapsing
06:38:41 <jacobian> * :: * doesn't work out well
06:38:49 <chessguy> so what would b be then?
06:38:57 <norpan> Thunder: well, yes, i mean ANY TYPE :)
06:39:29 <jacobian> b is any type
06:39:30 <norpan> of course it cannot be for instance a hydrogen atom and so on
06:39:54 <chessguy> data Atom a = ...
06:41:55 <chessguy> :k Monad
06:41:59 <lambdabot> Class `Monad' used as a type
06:42:06 <chessguy> :k Monad a
06:42:09 <lambdabot> Not in scope: type variable `a'
06:42:19 <Cheery> does ghc6.6 contain optimizations not in ghc6.4?
06:42:22 <chessguy> :k State
06:42:25 <lambdabot> * -> * -> *
06:42:46 <Cheery> this feels swift. :)
06:43:14 <Syzygy-> Cheery: I would assume so.
06:43:20 <Syzygy-> :k IO
06:43:23 <lambdabot> * -> *
06:43:35 <chessguy> hmmm. so State requires a type which carries the state, and a return type? is that the idea?
06:43:43 <Saizan> yes
06:43:49 <chessguy> and then returns a monad?
06:43:59 <Saizan> well, the monad is State Type
06:44:07 <Saizan> not State Type ReturnType
06:44:11 <chessguy> returns isn't a very good word
06:44:15 <Syzygy-> chessguy: Not all things of kind * -> * are Monads.
06:44:37 <chessguy> so what's the last * then
06:44:43 <quicksilver> chessguy: I have the monad version for you
06:44:52 <chessguy> oh? annotate?
06:45:01 <Saizan> the last * is when you have an  m a
06:45:11 <hpaste>  (anonymous) annotated "Here's the raw recursive version of what i want to do" with "State version" at http://hpaste.org/589#a2
06:45:32 <quicksilver> chessguy: I don't know if that's particularly better
06:45:36 <quicksilver> it might be easier to read
06:45:38 <Saizan> like (State Int) Bool, (State Int) is m and Bool is a
06:46:15 <quicksilver> or, in my example, f_state' :: [Integer] -> State Integer [Integer]
06:46:42 <chessguy> hmmm
06:47:43 <quicksilver> I sort-of like it
06:47:49 <quicksilver> it's clearer that you don't modify most elements
06:48:00 <quicksilver> (you can see it normally just returns x)
06:48:02 <chessguy> of course if we were going to make it useful, we'd have to parameterize the x+y and the 2*y
06:48:08 <chessguy> err, 2*x
06:48:23 <quicksilver> that's not very hard :)
06:48:33 <chessguy> no
06:48:54 <Saizan> quicksilver, i don't think you solution is correct
06:49:26 <quicksilver> Saizan: but I proved it! It gave the same answer on one case, what more is there?
06:49:29 <quicksilver> :P
06:49:42 <chessguy> lol
06:50:01 <quicksilver> I tested it on a second case! Now it's definitely right.
06:50:22 <Saizan> won't it double every x for which the condition is true? instead of only the first?
06:50:30 <chessguy> is @let working?
06:50:49 <quicksilver> Saizan: no, that's the y<k
06:50:54 <quicksilver> although there is a small bug
06:51:07 <quicksilver> one of those > or < should be >=
06:51:10 <quicksilver> or <=
06:51:23 <quicksilver> to make it exactly like chessguy's, the > should be >=
06:51:24 <chessguy> s/>/>=/
06:51:44 <quicksilver> right
06:51:46 <Saizan> ah right, i didn't connect that k == 20
06:52:07 <quicksilver> chessguy's code left y as a parameter
06:52:11 <quicksilver> erm k, I mean
06:52:16 <quicksilver> I set an anctual value for testing purposes
06:52:31 <chessguy> yeah, it should be >= k instead of > 20
06:52:37 <quicksilver> doh
06:52:39 <quicksilver> that's stupid :)
06:53:16 <chessguy> but that should be parameterized too
06:53:24 <chessguy> :)
06:53:53 <quicksilver> well I don't know what the exact generalisation is
06:53:59 <quicksilver> I was able to check 'first time it happened'
06:54:01 <quicksilver> easily enough
06:54:09 <quicksilver> in a more complex case you migth need a Bool in the state
06:54:13 <Saizan> yes but's not hard, not (cond y) && cond (y')
06:54:14 <quicksilver> to flag if it's happened yet
06:54:20 * quicksilver nods
06:54:31 <quicksilver> yes, as long as you have old and new y it's easy
06:54:33 <quicksilver> good point
06:54:51 <Saizan> unless you have a condition that can oscillate
06:55:00 <chessguy> right, sabakas1
06:55:04 <chessguy> err, Saizan
06:55:34 <chessguy> i think the code could be adjusted to always look at the old and new y
06:56:39 <Saizan> well so this HOF would need an initial state, a condition, a statetranformerfunction, and something to do the element matched?
06:56:58 <quicksilver> sounds fairly obscure to me :)
06:57:01 <chessguy> yeah
06:57:05 <chessguy> probably :)
06:58:21 <chessguy> but an interesting exercise in abstraction
07:04:36 <pjd> hmm
07:05:22 <hpaste>  Saizan annotated "Here's the raw recursive version of what i want to do" with "quite a type" at http://hpaste.org/589#a3
07:05:24 <pjd> does anyone know anything about the idea of representing rational numbers as single lists of possibly-negative integer prime exponents?
07:06:46 <pjd> such that 2 / 3 is [1, -1, 0...]
07:08:13 <pjd> that is, 2^1 * 3^-1 * 5^0 * ...
07:08:52 <pjd> 5/6 would be [-1, -1, 1, 0...]
07:09:06 <Saizan> which is like storing the factorization of the numerator and denominator?
07:09:20 <pjd> right, but merged
07:09:25 <ski_> Saizan : doesn't that traverse the whole list ?
07:10:00 <pjd> because you can assume they don't have common factors
07:10:15 <pjd> this way, they're intrinsically normalized
07:10:19 <Saizan> ski_: right, that was one of my objections to the mapM
07:10:40 <quicksilver> ski_: yes
07:10:50 <quicksilver> mapM can't shortcircuit, as far as I know
07:10:59 <quicksilver> and yet, mapM seemed intuitively the right construct :)
07:11:28 <ski_> (hm .. maybe if combined with exceptions ..)
07:11:48 <Saizan> pjd: has that a practical use?
07:11:54 <ski_> State s Maybe a
07:12:05 <pjd> Saizan: that's what i'm interested in :)
07:12:14 <ski_> um, no .. the other way around
07:12:25 <quicksilver> StateT s Cont a ?
07:12:29 <ski_> MaybeT (State s) a
07:12:53 <_roconnor> pjd: usually rational numbers are represented as the coeffecients of their continued fraction expansion
07:13:03 <_roconnor> (if you are going to use lists of integers)
07:13:29 <pjd> _roconnor: this representation could make some things easier, though
07:13:55 <_roconnor> pjd: it depends on what operations you are intrested in doing.
07:13:59 <pjd> right
07:14:13 <quicksilver> converges rather slowly, doesn't it?
07:14:28 <quicksilver> continued fractions are unpredictable but typically converge rather fast
07:14:38 <pjd> very very fast
07:16:08 <pjd> roconnor: i tangentially have some things in mind that involve lots of work with prime factors
07:16:23 <pjd> music theory toying :)
07:16:41 <roconnor> ah
07:16:50 <roconnor> hmm
07:17:04 <roconnor> continued fractions have to go with gcd caculations
07:17:11 <roconnor> and gcds have to do with prime numbers
07:17:30 <roconnor> I wonder if you can get prime number information from the continued fraction representation
07:17:37 <roconnor> but I'm not sure.
07:17:39 <pjd> interesting question
07:20:05 <quicksilver> continued fractions are calculated by repeated subtraction and inversion
07:20:18 <quicksilver> but the substraction probably screws up the prime factors
07:21:41 <sendo> @hoogle filter
07:21:42 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
07:21:42 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
07:21:42 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
07:22:11 <roconnor> the continued fraction is the trace of the gcd algorithm
07:22:53 <pjd> quicksilver: i have a feeling they're orthogonal
07:23:04 <pjd> the information they contain, that is
07:25:21 <sendo> if i have a list of tuples like  [(True,1), (False,2), (False,3)] and i wanna filter out the tuples with false on them, regardless of the integer, what should i feed the filter function with? because filter (True,_) list does not work!
07:25:33 <quicksilver> pjd: well it can't be totally orthogonal since an initial component of either can approximate the number to any given epsilon
07:25:42 <quicksilver> pjd: but I know what you mean
07:25:44 <Saizan> sendo: filter fst
07:25:45 <Syzygy-> sendo: Try filter fst
07:25:51 <sendo> oki!
07:25:58 <Saizan> > filter fst [(True,1), (False,2), (False,3)]
07:26:01 <lambdabot>  [(True,1)]
07:26:04 <quicksilver> sendo: (True,_) is a pattern, not a function
07:26:18 <Saizan> ?src fst
07:26:19 <lambdabot> fst (x,_) =  x
07:26:43 <quicksilver> sendo: you could write filter (\x -> case x of {(True,_) -> True; otherwise -> False}) list
07:26:55 <quicksilver> sendo: but as it happens, the function 'fst' works for this specific case :)
07:27:15 <pjd> quicksilver: hmm, i don't think any initial or trailing component of a prime-exponent list approximates the number
07:27:19 <sendo> what if i need to keep the ones with false?
07:27:27 <sendo> do i use quicksilver's approach?
07:27:34 <pjd> the amount they "contribute" to the number is a function of the size of the exponent, not its position
07:27:41 <quicksilver> sendo: filter (not.fst)
07:27:53 <quicksilver> pjd: it's bounded by position though
07:28:03 <quicksilver> pjd: but then again, primes don't get big particularly fast
07:28:05 <sendo> pff, it's so freakin simple but i just try and make it difficult!
07:28:13 <pjd> quicksilver: in continued fractions, but not in prime exponents
07:28:15 <Cale_> It's good to get in the habit of putting spaces next to . when used as composition.
07:28:19 <quicksilver> sendo: also consider the following amusing variant
07:28:21 <pjd> the exponent to 2 can be anything :)
07:28:45 <quicksilver> pjd: oh, for some reason I was neglecting positive indices :)
07:29:02 <quicksilver> pjd: positive exponents
07:29:07 <quicksilver> sendo: like this:
07:29:19 <Saizan> the prime exponents list can be quite sparse though
07:29:22 <sendo> i'm watching
07:29:25 <pjd> Saizan: yeah
07:29:33 <quicksilver> > [ n | (True,_) <- [(True,1),(False,2),(True,3)] ]
07:29:34 <lambdabot>   Not in scope: `n'
07:29:41 <quicksilver> > [ n | (True,n) <- [(True,1),(False,2),(True,3)] ]
07:29:42 <lambdabot>  [1,3]
07:29:47 <sendo> true, a list comprehension also makes ense
07:29:48 <sendo> oh
07:29:50 <quicksilver> > [ n | (False,n) <- [(True,1),(False,2),(True,3)] ]
07:29:51 <lambdabot>  [2]
07:29:56 <sendo> thats exactly what i needed
07:30:00 <quicksilver> strips out the tuple/bool at the same time :)
07:30:10 <sendo> cos i zipped to filter them out and then unzip them
07:30:13 <sendo> but that's much better!
07:30:19 <pjd> quicksilver: hmm, in fact, i don't think you can get any kind of approximation out of a prime-exponent list
07:30:29 <quicksilver> pjd: *nod* I was making no sense
07:30:37 <quicksilver> pjd: I was thinking only about numbers less than one
07:30:39 <int-e> > map snd . filter fst $ [(True,1),(False,2),(True,3)]
07:30:40 <lambdabot>  [1,3]
07:30:50 <int-e> > map snd . filter (not . fst) $ [(True,1),(False,2),(True,3)]
07:30:51 <lambdabot>  [2]
07:30:54 <quicksilver> pjd: where you do have a converging sequence, although one that converges deathly slow
07:31:05 <pjd> converging?
07:31:14 <quicksilver> numbers in (0,1), yes
07:31:21 <quicksilver> all exponents negative
07:31:24 <pjd> with the prime-exponent list or the CFs?
07:31:29 <quicksilver> prime-exponents
07:31:34 <Saizan> sendo: how do you generate the flags? if your condition depends only on the number you can pack it in the comprehension
07:31:36 <pjd> converging in what sense?
07:31:56 <quicksilver> pjd: increasing sequence bounded above :)
07:32:08 <pjd> you can have numbers in the (0,1) range with positive exponents too
07:32:11 <quicksilver> pjd: in compact interval
07:32:27 <sendo> nah, it depends on wether the value violates some rules for whom i made a function
07:32:27 <pjd> the negative exponents just have to "weigh more"
07:32:32 <quicksilver> oh blah
07:32:37 <quicksilver> I'm just not thinking at all
07:32:38 <sendo> the solution quicksilver pointed out its exactly what i need.
07:32:40 <quicksilver> yes, you're right :)
07:32:43 <sendo> cheers everyone
07:32:47 <quicksilver> sendo: np
07:32:49 <pjd> quicksilver: it's a funny representation to think about :)
07:32:51 <sendo> i'm gonna get a sandwich
07:34:08 <pjd> hmm, is there a canonical method to compare CFs (by the number they represent)?
07:36:22 <pjd> hmm, you can probably compare them by component, right, alternating the direction the comparison counts in?
07:36:47 <quicksilver> that sounds plausible, but there are surely hundreds of papers on this
07:36:53 <quicksilver> they have been studied to death I believe
07:37:30 <pjd> what i'd love to know is any literature on the prime
07:37:39 <pjd> ...-exponent representation
07:40:01 <oren> Can anyone help me with a quick Parsec issue?
07:40:46 <jacobian> usually it's best to just ask about your specific problem, then people can answer at their leisure
07:41:12 <ruben> what's the fastest prime number generating algorithm in Haskell anyone can come up with?
07:41:42 <Igloo> ruben: 2
07:41:46 <oren> Ok... I'm looking for implementing something like the Prolog "cut" operator in Parsec
07:42:21 <oren> Currently I think Parsec is an all-or-nothing backtracker. Either you "try" or you don't
07:42:30 <ruben> i meant it has to generate the first n primes where n is an integer
07:42:45 <oren> What I want is something like "try", but if I "cut" somewhere in the 1st alternative, I don't want Parsec to backtrack from it
07:43:27 <oren> I just wondered if anyone else did this sort of thing, or whether I should hack it in myself
07:46:25 <LoganCapaldo> oren: I wonder if you could get that effect by instread of try parser <|> other where parser = subparser1 subparser2 cut ubparser3 if you do parser <|> other with parser = try subparser1 try subparser2 subparser3
07:46:48 <allbery_b> (try (symbol "foo")) >> ...) <|> ...
07:47:40 <ndm> @google runciman lazy prime spiral
07:47:45 <lambdabot> http://journals.cambridge.org/article_S0956796897002670
07:47:50 <ndm> ruben: it was that one ^^
07:47:56 <oren> LoganCapaldo: Interesting idea. Let me check...
07:50:47 <glguy> Don't make it just free as in beer, make it free as in cool refreshing budweiser(TM)
07:50:50 <oren> LoganCapaldo: No, doesn't really work. But what could work might be something like: (peek lookaheadParser) try actualParser <|> alternativeParser
07:51:04 <Cheery> oooh!!!! :O :O :O :O
07:51:10 <oren> I would parse the "peeked lookahead" twice if it succeeds though
07:51:13 <LoganCapaldo> oren: I think the right way would be  to construct it as allbery_b suggested, (try (do { subparser1; subparser2 }) >> subparser3) <|>
07:51:16 <Cheery> I now really understood this toy with pattern matching!
07:51:20 <LoganCapaldo> mmm
07:51:23 <LoganCapaldo> k
07:51:34 <LoganCapaldo> was worth shot :)
07:51:46 <oren> Problem is I don't always have it broken up nicely to subparser1 subparser2 etc.
07:51:53 <LoganCapaldo> yeah
07:52:23 <Cale_> Cheery: hm?
07:53:22 <oren> I think I'll try to see whether I can implement "peek"
07:53:43 <oren> Efficiency isn't my pressing concern here - it is better error reporting etc.
07:53:59 <Cheery> Cale: well, it's so simple that there's relationship with function which works as a pattern and the structure buildt.
07:55:22 <Cheery> I'm still finding out how would I formalize such method of breaking a lambda into pattern matching component.
07:55:58 <Cheery> thought
07:58:30 <ski_> Cheery : hm ?
08:01:50 <malcolmw> oren: I don't know about parsec, but the polyparse package does what you want.
08:02:20 <malcolmw> oren: there are two kinds of failure: please-backtrack and try something else, or no-really-stop-this-is-wrong
08:02:24 <ruben> I came up with a function which performs quite fast. I haven't been able to improve on it at all.
08:02:30 <ruben> primes = primesFilter 1 [2..]
08:02:30 <ruben>    where primesFilter primorial (n:ns)
08:02:30 <ruben>             | (gcd primorial n == 1) = n : (primesFilter (primorial*n) ns)
08:02:30 <ruben>             | otherwise              = primesFilter primorial ns
08:03:06 <quicksilver> ruben: there was a *long* discussion on the mailing list just recently on this
08:03:08 <quicksilver> ruben: did you read it?
08:03:12 <ruben> no
08:03:23 <oren> malcolmw: Thanks! I will give it a look
08:04:03 <quicksilver> ruben: then, you should :)
08:05:03 <quicksilver> ruben: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022765.html
08:05:06 <lambdabot> Title: [Haskell-cafe] Code and Perf. Data for Prime Finders (was: Genuine Eratosthenes  ..., http://tinyurl.com/2hltv4
08:06:51 <huschi> hi. is there a base64 implementation in haskell?
08:07:44 <chessguy> mmmm, 64
08:07:58 <chessguy> yummy
08:07:59 <glguy> huschi: HAppS uses one
08:08:13 <huschi> and is there one as a single package?
08:08:24 <quicksilver> a quick google search suggests that haskell http uses another
08:08:33 <quicksilver> and darcs has another
08:09:01 <quicksilver> huschi: http://hackage.haskell.org/packages/archive/pkg-list.html
08:09:11 <|Lupin|> Hello, everybody.
08:09:18 <earthy> hiya lupin
08:09:50 <huschi_> quicksilver: thx.
08:10:32 <|Lupin|> Sorry to bother you with a darcs question, but #darcs is notvery active and I feel lost...
08:10:53 <|Lupin|> I'm trying to store a recorded patch into a file.
08:10:59 <|Lupin|> Tried darcs send -i -o file
08:11:01 <|Lupin|> doesn't work
08:11:09 <|Lupin|> What am I doing wrong, please ?
08:11:14 <ndm> |Lupin|: what does -i do? it always works for me without -i, using -o file
08:11:29 <|Lupin|> -i is for interactive.
08:11:44 <ndm> |Lupin|: try without -i and see if it works, it's pretty interactive when i do it
08:11:44 <|Lupin|> ndm: How do you specify whichpatch to send ?
08:11:57 <ndm> |Lupin|: it asks me, interactively - no idea what -i means
08:11:59 <|Lupin|> ok
08:12:30 <|Lupin|> ndm: It does mot work. It stays there sleeping.
08:12:49 <ndm> |Lupin|: sounds like it's looping... darcs enjoys doing that
08:13:20 <quicksilver> non-terminating-vcs for the win!
08:13:31 <quicksilver> or, 'covcs' as I like to call it
08:13:34 <|Lupin|> actually it triesto open an ssh connection, but themachine it tries to connectto is off.
08:13:47 <|Lupin|> I don't understand why it's trying to open this connection.
08:13:59 <ndm> |Lupin|: to send it has to have something against which to send - it only sends the patches you have that hte remote repo doesn't
08:14:28 <|Lupin|> oh I see.
08:14:51 <|Lupin|> hmm...
08:15:41 <|Lupin|> Is it possible to "undo" a patch, i.e. to remove it fromThe sources while keeping it in th patchesseries, for later re-recording ?
08:15:52 <|Lupin|> s/re-recording/re-applying/
08:27:25 <ndm> no, to do that you'd just do a send ;)
08:43:45 <|Lupin|> see you later guys, perhaps at fosdem if someone goes ?
08:45:37 <edwinb> I was wondering if any #haskellers would be at fosdem too
08:45:58 <roconnor> @what fosdem
08:45:58 <lambdabot> I know nothing about fosdem.
08:46:15 <|Lupin|> kowey goes
08:46:17 <|Lupin|> (with me)
08:46:49 <|Lupin|> So if you see a blind guy with a asian guy... tbat's me and kowey.
08:49:02 <|Lupin|> bye
08:50:42 <chessguy> i was thinking
08:50:47 <glguy> oh dear
08:50:56 <chessguy> :)
08:50:58 <glguy> ;)
08:51:10 <chessguy> within any do block, there's basically just two kinds of statements, right?
08:51:17 <chessguy> x <- foo
08:51:22 <chessguy> let y = bar
08:51:31 <mux> you two nicknames inevitably makes me think of glchess
08:51:40 <glguy> chessguy: there is also just: bar
08:51:45 <mux> s/you/&r/ s/makes/make/
08:51:46 <glguy> or _ <- bar
08:51:58 <chessguy> ok, three
08:52:09 <quicksilver> let y = isn't a statement in the same sense
08:52:20 <quicksilver> it's mostly a convenience way of putting a let binding in there
08:52:36 <kc5tja> Stiff necks suck ass!
08:52:47 <quicksilver> or, It's harder to suck ass with a stiff neck?
08:53:03 <chessguy> ok, but  bar has to have a particular type depending on the monad you're in, right?
08:53:15 <kc5tja> quicksilver: I saw the link to existential types you posted; interesting read.  This is 100% analogous to COM objects where you can "query interface" any object to see if it conforms to some interface or not.  Except, it's all done automatically for you.
08:53:34 <quicksilver> yes
08:53:35 <quicksilver> :)
08:53:44 <quicksilver> and verified at compile time, too
08:53:48 * kc5tja nods
08:53:57 <quicksilver> chessguy: right
08:54:01 <quicksilver> chessguy: so does foo :)
08:54:12 <quicksilver> chessguy: erm, hang on
08:54:15 <quicksilver> chessguy: NO
08:54:18 <quicksilver> chessguy: your bar can be any type
08:54:29 <quicksilver> chessguy: glguy's bar has to be the monadic type
08:54:36 <ski_> (quicksilver : posted where ?)
08:54:37 <quicksilver> chessguy: your bar is a general let binding it can be anything
08:54:48 <quicksilver> ski_: here, in this channel, around 22 hours ago
08:54:52 <glguy> ?losers
08:54:53 <lambdabot> Maximum users seen in #haskell: 317, currently: 309 (97.5%), active: 46 (14.9%)
08:54:56 <quicksilver> ski_: kc5tja is a slow reader
08:55:03 <chessguy> hmm
08:55:09 <chessguy> glguy, looks like a new record
08:55:18 <kc5tja> quicksilver: No, I've gone to bed prior to you posting the link.  I scrolled back to find it.
08:55:26 <quicksilver> kc5tja: I was joking :)
08:55:43 <chessguy> quicksilver, oh, there's also the return statement
08:55:46 <chessguy> sometimes
08:55:50 <quicksilver> chessguy: that's not a statement
08:55:53 <kc5tja> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
08:55:54 <quicksilver> :t return
08:55:56 <lambdabot> http://tinyurl.com/f9umb
08:55:57 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:56:01 <chessguy> i don't mean statement in a technical sense
08:56:11 <quicksilver> return is just a special case of 'bar'
08:56:14 <chessguy> i'm just trying to feel out the anatomy of a monadic do black
08:56:14 <kc5tja> ski_: ^^  That's the link that was posted.
08:56:32 <chessguy> without doing all the manual de-sugaring
08:56:46 <quicksilver> chessguy: the anatomy is: everything is either of type m a or b -> m a
08:57:07 <chessguy> hmmm, not the let bindings
08:57:15 <quicksilver> chessguy: the last statement *must* be  'm a' not 'b -> m a'
08:57:50 <chessguy> right?
08:57:53 <quicksilver> chessguy: the let bindings are not statements
08:57:56 <quicksilver> they are let bindings
08:58:02 <quicksilver> just like in normal haskell
08:58:07 <quicksilver> except without the 'in'
08:58:32 <malebria> Is there a type like Maybe2, something as data Maybe2 a = Zero | One a | Two a a ?
08:58:41 <chessguy> quicksilver, an important distinction
08:58:47 <quicksilver> > do { x <- [1,2]; let y = 3+4; return x }
08:58:48 <lambdabot>  Parse error
08:59:03 <mauke> Maybe (Maybe a, a)
08:59:11 <chessguy> (at least to newbies like me
08:59:30 <Cale> malebria: not in the libraries
08:59:45 <mightybyte> take 3 [1..]
08:59:54 <vincenz> re
08:59:58 <mightybyte> @take 3 [1..]
08:59:58 <lambdabot> Maybe you meant: time type
09:00:00 <malebria> Cale: thanks.
09:00:08 <Cale> malebria: usually if you can have 0,1, or 2 of something, you can have any number, and hence a list is appropriate. If you really want to enforce that, you can make your own data declaration of course.
09:00:15 <malebria> mauke: this is an option, but I think that the data type is more clear.
09:01:10 <kc5tja> >take 3 [1..]
09:01:29 <chessguy> > take 3 [1..]
09:01:30 <mightybyte> > take 3 [1,1..]
09:01:30 <lambdabot>  [1,2,3]
09:01:31 <lambdabot>  [1,1,1]
09:01:36 <mightybyte> Ok, thanks
09:01:55 <kc5tja> What?!  Lambdabot doesn't take >take3[1..] ?  ;)
09:02:01 <quicksilver> Cale: what's wrong with my let binding syntax
09:02:12 <quicksilver> kc5tja: lambdabot requires a space after the >
09:02:17 <mightybyte> Would that be the easiest way to get a list of n elements initialized to zero?
09:02:17 <glguy> quicksilver: you need { }
09:02:22 <Cale> > do { x <- [1,2]; let {y = 3+4}; return x }
09:02:24 <lambdabot>  [1,2]
09:02:26 <quicksilver> ah
09:02:28 <quicksilver> thanks :)
09:02:39 <Cale> It thinks the return x is part of the let.
09:02:41 <quicksilver> chessguy: point of that example is, there is nothing monadic about y or its type
09:02:56 <quicksilver> chessguy: the let binding can be an expression of any type
09:02:57 <kc5tja> mightybyte: Seems like it to me.  take N [0,0...]
09:03:13 <Saizan> or replicate n 0
09:03:28 <mightybyte> Saizan: Ahh, that's the function I was looking for
09:03:41 <allbery_b> quicksilver: you're tripping over one of the weird parts of haskell syntax.
09:03:45 <Saizan> but "initialized" is kind of a wrong way to say this, a list is not mutable
09:03:50 <quicksilver> allbery_b: yes, it makes sense to me now
09:04:04 <quicksilver> allbery_b: I always forget that let decl lists are also display formatting
09:04:21 <quicksilver> allbery_b: I also always forget that case is display formatted, and try to put in a | like in ML :)
09:04:42 <mightybyte> Saizan: Ok.  I'm trying to write a little tic-tac-toe program to get started with Haskell.  Would I use an array instead of a list to represent the board?
09:04:51 <quicksilver> I wouldn't
09:04:55 <quicksilver> lists are natural and easy
09:05:01 <quicksilver> arrays are for efficiency
09:05:13 <quicksilver> which isn't a particular concern with 9 elements
09:05:25 <mightybyte> Ok
09:05:31 <Cale> quicksilver: depends on how many copies you'll need, but I'll agree on this one :)
09:06:49 <Saizan> i'd say that it most depends on the way you want to access the elements
09:07:15 <mightybyte> Well, since I'm still learning haskell, I'm not sure how I want to access them.
09:09:06 * glguy wonders if an array wouldn't be more suitable for something that it going to have unordered access and updates
09:09:17 <Cale> arrays are good ar random access, lists are good at linear access, but also have lots of additional functions for operating on them
09:09:21 <glguy> not so much from the point of view of efficiency
09:09:35 <glguy> just from the pov of him playing around
09:10:15 <quicksilver> oh this remiinds me
09:10:28 <quicksilver> is there a datatype in the hierarchical libs for '1 to 1 Map'
09:10:33 <quicksilver> also know as isomorphism?
09:10:36 <quicksilver> or invertible?
09:12:55 <Saizan> with fast inverse lookup too?
09:14:49 <Cale> I don't think you can easily guarantee that a function is invertible.
09:15:04 <quicksilver> Cale: you could guarantee that a Data.Map was
09:15:10 <Cale> You could do it for functions with a finite domain and codomain, yeah
09:15:16 <quicksilver> that's what I meant
09:15:20 <quicksilver> finite 1-1 map
09:15:24 <Cale> I'd probably start with a Set of pairs.
09:15:40 <quicksilver> i.e. Data.Map?
09:15:41 <quicksilver> grin
09:15:57 <Cale> Roughly, yes
09:16:05 <quicksilver> you'd need to override insert to either throw an error or alternatively overwrite
09:16:08 <Cale> Except that when you do a lookup, things are different
09:16:09 <quicksilver> depending which you wanted
09:16:13 <Cale> and when you're adding a new value
09:16:15 <quicksilver> and also union, and also....
09:16:24 <Cale> Really, it should be a set of 2-sets.
09:16:42 <quicksilver> which is why I wondered if there was an existing module for it
09:16:49 <quicksilver> it's nontrivial but useful
09:16:54 <quicksilver> consider reversible translations
09:17:03 <quicksilver> e.g. different file formats and stuff
09:17:05 <vincenz> Cale: a set of pairs won't work
09:17:30 <Cale> vincenz: not on its own
09:17:35 <vincenz> it's a set of elements
09:17:39 <vincenz> T a b
09:17:40 <vincenz> where
09:17:45 <quicksilver> vincenz: a Data.Map is a set-of-pairs guaranteed to be functional
09:17:51 <vincenz> T a b == T x y iff a == x \/ b == y
09:17:57 <quicksilver> vincenz: I just want a Data.Map which is further gauranteed to be injective
09:18:13 <vincenz> yes I know
09:25:28 <ski_> kc5tja : ty
09:25:56 <kc5tja> ski_: n/p
09:26:35 <chessguy> quicksilver, what were you referring to with your b -> m a ?
09:26:54 <quicksilver> chessguy: that's the typical type of a statement in a do block
09:27:41 <quicksilver> well that's a slightly misleading way to phrase it
09:27:43 <chessguy> like?
09:27:57 <quicksilver> the thing you right is actually of type 'm a'
09:28:09 <quicksilver> but behind the scenes it is promoted to b -> m a
09:28:10 <Saizan> "it's the typical type of a function that you would use in a do block"
09:28:12 <quicksilver> s/right/write/
09:28:25 <quicksilver> so that bind can be used
09:28:31 <quicksilver> :t (>>=)
09:28:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:28:58 <quicksilver> e.g. in do { x <- [1,2] ; y <- [3,4] ; return (x,y) }
09:29:05 <quicksilver> [3,4] is of type 'm a'
09:29:13 <malebria> @hoogle (a -> b) -> (a, a) -> (b, b)
09:29:14 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:29:19 <quicksilver> but behind the scenes it is converted into \x -> [3,4]
09:29:30 <quicksilver> @undo do { x <- [1,2] ; y <- [3,4] ; return (x,y) }
09:29:31 <lambdabot> [1, 2] >>= \ x -> [3, 4] >>= \ y -> return (x, y)
09:29:32 <ski_> :t join (***)
09:29:35 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
09:29:35 <quicksilver> like that
09:29:51 <mauke> > do { [1, 2]; [3, 4] }
09:29:53 <lambdabot>  [3,4,3,4]
09:30:02 <michaelw> @src foldl1'
09:30:03 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:30:03 <ski_> :t \x y -> join (***) x y
09:30:06 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
09:30:06 <malebria> ski_: thanks.
09:30:16 <quicksilver> in mauke's case, the 'results' of [1,2] are ignored
09:30:24 <michaelw> hmm: my ghc seems to know a foldl1', wonder what's the difference...
09:30:34 <quicksilver> although because of the way the list monad works, the number of results is still significant
09:30:40 <quicksilver> michaelw: strictness
09:30:48 <michaelw> ah
09:31:00 <quicksilver> the ' versions of the left folds are strict in the accumulator
09:31:09 <quicksilver> with luck this prevents you from building a huge thunk
09:31:35 <quicksilver> although I think actually with -O2 there is no difference anyway in GHC ?
09:31:38 <malebria> @type join
09:31:40 <chessguy> @undo do { [1, 2]; [3, 4] }
09:31:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:31:41 <lambdabot> [1, 2] >> [3, 4]
09:32:13 <quicksilver> chessguy: or, equivalently [1,2] >>= \_ -> [3,4]
09:32:31 <chessguy> yeah, but how do you get [3,4,3,4] out of that?
09:32:48 <quicksilver> that's the magic of >>= in the list monad
09:32:58 <malebria> ski_: What's join doing, I don't get very much..
09:33:07 <chessguy> concatmap, isn't it?
09:33:13 <quicksilver> for lists, yes
09:33:14 <mauke> > concatMap (\_ -> [3,4]) [1,2]
09:33:14 <ski_> join (***) f = f *** f
09:33:16 <lambdabot>  [3,4,3,4]
09:33:27 <chessguy> > do { [1, 2, 3]; [3, 4] }
09:33:28 <lambdabot>  [3,4,3,4,3,4]
09:33:40 <malebria> ski_: it's because of Monad (->) ?
09:33:46 <ski_> > (tail *** head) [0,1,2]
09:33:47 <lambdabot>  Couldn't match expected type `([a], [a1])'
09:33:52 <ski_> malebria : yes
09:33:52 <quicksilver> malebria: yes
09:34:00 <malebria> Ok, thanks, guys!
09:34:07 <quicksilver> > join (*) 4
09:34:08 <lambdabot>  16
09:34:10 <ski_> > (tail *** head) ([0,1,2],[3,4])
09:34:12 <lambdabot>  ([1,2],3)
09:34:33 <quicksilver> join in the reader monad means 'use the environment for two parameters'
09:34:45 <ski_> > (tail &&& head) [0,1,2]
09:34:47 <lambdabot>  ([1,2],0)
09:34:54 <Saizan> but it's not the reader monad
09:35:03 <Saizan> it's just monad
09:35:13 <quicksilver> Saizan: I'm having two conversations here
09:35:22 <quicksilver> Saizan: malebria and ski are in the reader monad
09:35:27 <quicksilver> Saizan: chessguy is in the list monad :)
09:35:39 <Saizan> ?ty join -- no MonadReader here
09:35:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:35:48 <quicksilver> Saizan: join is in every monad
09:35:57 <quicksilver> Saizan: but it happens that in the reader monad, it means what I said
09:36:26 <Saizan> ah it's "reader monad" in a semantic sense?
09:36:46 <quicksilver> I don't know what you mean by semantic, there
09:36:52 <quicksilver> the reader monad is a particular monad
09:36:58 <quicksilver> (->) r
09:36:58 <pejo> Is there anything like undefined, that is defined? :-)
09:37:06 <quicksilver> pejo: what do you want?
09:37:13 <mauke> Maybe a
09:38:03 <pejo> quicksilver, somethign temporary that can be shown basically. The expected type is a constructor with a bunch of parameters.
09:38:37 <quicksilver> how is that undefined?
09:38:52 <quicksilver> I don't understand how your question related to that clarification!
09:39:57 <pejo> quicksilver, I need to construct a pair: (Name, Scheme) - but only have Name available. Sticking undefined in there works, until I "use" the value.
09:40:11 <dmhouse> pejo: it'll still work until you do some IO
09:40:15 <mauke> well, then don't use the value
09:40:24 <roconnor> (Name, Maybe Scheme)?
09:40:24 <pejo> The usage in question is using show on it.
09:41:33 <pejo> roconnor, changing type of the pair isn't possible - will break all other layers.
09:41:54 <quicksilver> changine the type has to be an option
09:42:07 <quicksilver> you can always write the function (Name,Scheme) -> (Name, Maybe Scheme)
09:42:11 <quicksilver> and vice versa
09:42:15 <quicksilver> across interface boundaries
09:43:42 <roconnor> If a function isn't using the Scheme part of (Name,Scheme) then they ought to change their type to be more polymorphic and work on a (Name,a) instead.
09:44:06 <malebria> hum..
09:44:11 <malebria> That's now what I want..
09:44:21 <malebria> I said it wrongly.
09:44:29 <sendo> can a lambda abstraction be applied to several functions in a tuple, i.e.: map (\v -> (vars, somefunction v, someotherfunction v)) vs
09:44:37 <malebria> @hoogle (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
09:44:37 <pejo> roconnor, I'm just not sure how to figure out what the Scheme should be, it ought to be there in some philosophical sense.
09:44:38 <lambdabot> No matches, try a more general search
09:44:45 <quicksilver> sendo: yes
09:44:47 <malebria> Something like this.
09:45:02 <quicksilver> > map (\v -> (v+1,v-1)) [1,2,3,4]
09:45:04 <lambdabot>  [(2,0),(3,1),(4,2),(5,3)]
09:45:06 <quicksilver> sendo: like that?
09:45:11 <roconnor> pejo: maybe you want it in some functions, but not others?
09:45:13 <Botje> @pl \v -> (vars, somefunction v, someotherfunction v)
09:45:13 <lambdabot> ap ((,,) vars . somefunction) someotherfunction
09:45:32 <Botje> that's not *TOO* shabby
09:45:40 <mauke> @unpl ap ((,,) vars . somefunction) someotherfunction
09:45:40 <lambdabot> ((\ i -> (,,) vars (somefunction i)) >>= \ b -> someotherfunction >>= \ a -> return (b a))
09:46:04 <pejo> roconnor, the passes before and after me wants the information. Personally I need to figure out a way to just preserve it.
09:46:17 <quicksilver> pejo: if the pass before you has the information
09:46:24 <quicksilver> pejo: then how did you lose it?
09:46:29 <roconnor> pejo: ah, the great thing about haskell is that if you figure out the value of Scheme later, then you can pass it in by sending it back in time. ;)
09:47:10 <roconnor> seriously, it works
09:47:46 <pejo> quicksilver, is that a trick question? :-)
09:47:52 <quicksilver> pejo: no
09:47:56 <sendo> yea quicksilver  cheers!
09:47:58 <sendo> i do that
09:48:03 <quicksilver> pejo: the pass before you had the information, surely it passed it to you :)
09:48:10 <quicksilver> pejo: that's what 'pass' means in my book...
09:48:13 <sendo> and i get a type mismatch error
09:48:20 <quicksilver> sendo: show us the code
09:48:25 <sendo> so i thought i could be that, but it must be something else
09:48:29 <quicksilver> or, a simplified version if it's complicated
09:49:39 <sendo> map (\v -> (vars, update_doms doms [(var,v)], cons, update_var ass var v)) vals
09:49:49 <sendo> where vals = list of things
09:50:11 <quicksilver> presumably it's a type error somewhere
09:50:20 <sendo> but once i know its not a problem of the lambda abstraction, i can goo on and sniff for errors in my list generator
09:50:23 <sendo> yep
09:50:23 <sendo> cheers tho
09:50:27 <quicksilver> either v isn'ts the right type for doms, or for update_var :)
09:50:57 <pejo> quicksilver, basically I traversed down through the tree. But of course you're right, the information was there before me.
09:52:04 <quicksilver> pejo: nod, well you probably need to bring it with you in your traverse
09:52:12 <quicksilver> :)
09:52:20 <sendo> its not the right type for update_var
09:52:46 <sendo> it says Couldn't match 'Val' against '[Val]'
09:52:47 <pejo> quicksilver, that's the long term solution. I'd be happy to rip out the program with "error ("Oups : " ++ show prog)" for now.
09:52:57 <sendo> so i think my list generator is generating lists inside the list
09:53:14 <quicksilver> sendo: remember you can test parts of code independently
09:53:17 <quicksilver> e.g. in ghc
09:53:33 <sendo> yeah but
09:53:42 <sendo> yea yea
09:53:44 <sendo> i'm on it
09:53:51 <sendo> i'll tell you if it works!
09:54:42 <quicksilver> pejo: well, you can put that in there if you like
09:54:58 <quicksilver> pejo: but the error will be generated if that value is ever 'asked for'
09:55:57 <pejo> quicksilver, which is why I'd like to avoid undefined. :-)
09:56:15 <quicksilver> pejo: I'd like to fly to work every day
09:56:19 <sendo> well i checked
09:56:24 <quicksilver> pejo: what you're asking for is impossible :)
09:56:33 <sendo> and my list generator actually generates just a list
09:56:41 <chessguy> flying's not bad, but i don't think i'd want to do it every day
09:56:45 <sendo> with Vals inside
09:56:46 <pejo> quicksilver, impossible is nothing!
09:56:52 <sendo> so i dont think why it shouldnt work!!
09:56:56 <chessguy> at least not in a plane
09:57:10 <quicksilver> pejo: right, that's what roconnor told you in the first place
09:57:20 <quicksilver> pejo: impossible is Nothing
09:57:26 <quicksilver> pejo: so use (Name, Maybe Scheme)
09:57:27 <quicksilver> :P
09:57:46 <pejo> quicksilver, and change the other passes. Mmm, looking forward to that. ;)
09:59:02 <sendo> there was a missing ]
10:00:38 <sendo> @hoogle \\
10:00:38 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
10:00:41 <roconnor> @djinn ((Name, Scheme) -> (Name, Scheme)) -> ((Name, Maybe Scheme) -> (Name, Maybe Scheme))
10:00:42 <lambdabot> f a (b, c) =
10:00:42 <lambdabot>     case c of
10:00:42 <lambdabot>     Nothing -> (b, Nothing)
10:00:42 <lambdabot>     Just d -> case a (b, d) of
10:00:42 <lambdabot>               (e, f) -> (e, Just f)
10:00:43 <sendo> @hoogle (\\)
10:00:44 <lambdabot> Did you mean: (\\)
10:00:46 <lambdabot> Prelude.undefined :: a
10:00:48 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:00:57 <roconnor> pejo: it's easy, just lift your existing functions (see above)
10:01:00 <sendo> yes, i actually meant (\\)
10:01:10 <ddarius> pejo: Why not just use a dummy Scheme object?
10:01:17 <roconnor> @. pl djinn ((Name, Scheme) -> (Name, Scheme)) -> ((Name, Maybe Scheme) -> (Name, Maybe Scheme))
10:01:17 <lambdabot> (line 3, column 13):
10:01:17 <lambdabot> unexpected ">" or "-"
10:01:17 <lambdabot> expecting variable, "(", operator or end of input
10:01:36 <sendo> @hoogle (\\)
10:01:37 <lambdabot> Did you mean: (\\)
10:01:38 <lambdabot> Prelude.undefined :: a
10:01:38 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:01:54 <sendo> how do i tell lambdabot that i want to know what (\\) does?
10:02:02 <sendo> @hoogle ((\\))
10:02:02 <chessguy> ?src \\
10:02:03 <lambdabot> Did you mean: ((\\)
10:02:03 <lambdabot> Prelude.undefined :: a
10:02:03 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:02:03 <lambdabot> Source not found. Wrong!  You cheating scum!
10:02:12 <chessguy> ?src (\\)
10:02:13 <lambdabot> (\\) = foldl (flip delete)
10:02:17 <pejo> ddarius, hm. Yeah, could do that I guess. Probably the simplest way.
10:02:27 <chessguy> heh
10:02:43 <sendo> so it deletes the occurrences of the right hand side list from the left hand side list?
10:03:38 <int-e> > [1] \\ [1..]
10:03:38 <chessguy> > [1..10] \\ [4,5]
10:03:40 <roconnor> @type maybe
10:03:42 <lambdabot>  [1,2,3,6,7,8,9,10]
10:03:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:03:45 <lambdabot> Terminated
10:03:56 <pejo> ddarius, thanks.
10:04:01 <chessguy> > [4,5] \\ [1..10]
10:04:03 <lambdabot>  []
10:04:18 <chessguy> oh, the first one was right
10:04:57 <roconnor> @type \f (a,b) -> maybe (\b' -> let (c,d) = f (a,b') in (c, Just d)) (a,Nothing) b
10:05:00 <lambdabot>     Couldn't match expected type `a -> t2 -> (t, Maybe t1)'
10:05:00 <lambdabot>            against inferred type `(a1, b)'
10:05:19 <roconnor> @type \f (a,b) -> maybe (a,Nothing) (\b' -> let (c,d) = f (a,b') in (c, Just d)) b
10:05:22 <lambdabot> forall t a a1. ((t, a1) -> (t, a)) -> (t, Maybe a1) -> (t, Maybe a)
10:05:30 <roconnor> @pl \f (a,b) -> maybe (a,Nothing) (\b' -> let (c,d) = f (a,b') in (c, Just d)) b
10:05:31 <lambdabot> (line 1, column 43):
10:05:31 <lambdabot> unexpected "("
10:05:31 <lambdabot> expecting natural, identifier or "in"
10:05:33 <pejo> quicksilver, what makes you want to live that far away from work btw?
10:06:09 <roconnor> @type \f (a,b) -> maybe (a,Nothing) (\b' -> (\(c,d) -> (c,Just d)) (f (a,b'))) b
10:06:11 <lambdabot> forall t a a1. ((t, a1) -> (t, a)) -> (t, Maybe a1) -> (t, Maybe a)
10:06:16 <roconnor> @pl \f (a,b) -> maybe (a,Nothing) (\b' -> (\(c,d) -> (c,Just d)) (f (a,b'))) b
10:06:17 <lambdabot> (`ap` snd) . (. fst) . ap (maybe . flip (,) Nothing) . ((second Just .) .) . (. (,)) . (.)
10:06:22 <roconnor> perfect
10:06:27 <roconnor> you can use that function
10:08:03 <malsyned> Hey, anybody know what this error means? "ghc-pkg.bin: HOME: getEnv: does not exist (no environment variable)"
10:08:19 <Botje> there's no environment variable called HOME ?
10:08:20 <pejo> malsyned, is your $HOME set?
10:08:44 <malsyned> arg.  Right.  That makes sense.  No, I doubt $HOME is set, this is on Ubuntu and I'm trying to backport packages for ghc6.6.
10:08:56 <malsyned> prevu probably doesn't set $HOME in the chrooted environment.
10:09:08 <malsyned> but why would $HOME need to be set in order to install a package as root?
10:09:47 <allbery_b> ghc-pkg likes to check for user packages as well.  conceivably it should skip it as root...
10:11:10 <malsyned> Who should I submit a bug report to, once I figure out exactly what's happening?
10:11:59 <allbery_b> @bug
10:12:00 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:12:02 <chessguy> > 2 ** 64
10:12:04 <lambdabot>  1.8446744073709552e19
10:12:15 <chessguy> > 2 ^ 64
10:12:17 <lambdabot>  18446744073709551616
10:12:20 <mauke> > 1 `shiftL` 64
10:12:21 <lambdabot>  Add a type signature
10:12:27 <mauke> > 1 `shiftL` 64 :: Integer
10:12:29 <lambdabot>  18446744073709551616
10:12:48 <chessguy> > 18446744073709551616 :: Int
10:12:50 <lambdabot>  0
10:14:07 <mauke> http://www.plover.com/%7Emjd/misc/python.html
10:14:40 <chessguy> > 18446744073709551615 :: Int
10:14:42 <lambdabot>  -1
10:14:48 <chessguy> > 18446744073709551614 :: Int
10:14:50 <lambdabot>  -2
10:14:54 <chessguy> heh
10:15:03 <chessguy> > maxBound :: Int
10:15:04 <lambdabot>  2147483647
10:15:38 <Botje> yay, overflow.
10:15:43 <mauke> > maxBound `div` (-1) :: Int
10:15:45 <lambdabot>  -2147483647
10:15:51 <mauke> > minBound `div` (-1) :: Int
10:15:53 <lambdabot> Terminated
10:16:12 <chessguy> oh that's determined by the machine though, right?
10:17:58 <earthy> nope
10:18:12 <earthy> by the installation of your haskell system
10:18:26 <earthy> usually this derives it from the machine word size
10:18:33 <earthy> but it need not be
10:19:08 <chessguy> so for GHC on a 64-bit computer, an Int would be 64 bits?
10:19:24 <earthy> might be
10:19:28 <earthy> not sure
10:20:06 <chessguy> i'll have to check when i get home :)
10:24:18 <chessguy> > minBound :: Int
10:24:20 <lambdabot>  -2147483648
10:25:26 <chessguy> @get-shapr
10:25:26 <lambdabot> shapr!!
10:26:27 <chessguy> > 1 `shiftL` 60
10:26:28 <lambdabot>  Add a type signature
10:26:35 <chessguy> > 1 `shiftL` 60 :: Integer
10:26:36 <lambdabot>  1152921504606846976
10:27:41 <shapr> chessguy: hiya!
10:27:50 <chessguy> :)
10:29:07 * chessguy sighs
10:29:14 <chessguy> this job is such a colossal waste of time
10:29:32 <shapr> Someone must think it's worthwhile if they're giving you money.
10:30:15 <chessguy> they're not too bright
10:35:30 <michaelw> chessguy: maxBound :: Int ==> 9223372036854775807
10:35:48 <roconnor> > let p x = 9 / 8 * x * x * x * x - 45 / 4 * x * x * x + 315 / 8 * x * x - 217 / 4 * x + 27 in map p [0..10]
10:35:49 <lambdabot>  [27.0,2.0,4.0,6.0,8.0,37.0,147.0,419.0,961.0,1908.0,3422.0]
10:35:53 <chessguy> michaelr,  on what?
10:35:57 <chessguy> err, michaelw
10:36:05 <roconnor> mauke: works for me ;)
10:36:05 <michaelw> x86_64
10:36:16 <chessguy> ghc?
10:36:26 <michaelw> ghci
10:36:44 <chessguy> same thing
10:36:46 <chessguy> thanks
10:37:00 <roconnor> apparently python sucks at math ;)
10:37:10 <xs> > minBound :: Double
10:37:11 <lambdabot>   add an instance declaration for (Bounded Double)
10:37:12 <lambdabot>     In the expression: min...
10:37:15 <xs> sigh.
10:37:21 <chessguy> ?instances Bounded
10:37:23 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
10:37:24 <michaelw> xs!
10:37:25 <chessguy> xs, ^^
10:37:30 <xs> michaelw!
10:37:34 <shapr> lambdabot!
10:37:35 <xs> chessguy!
10:37:39 <xs> shapr!
10:37:41 <chessguy> chessguy!
10:37:42 <roconnor> > minBound :: ()
10:37:43 <chessguy> oops
10:37:43 <lambdabot>  ()
10:37:51 <mauke> > let p x = 9 % 8 * x * x * x * x - 45 % 4 * x * x * x + 315 % 8 * x * x - 217 % 4 * x + 27 in map p [0..10]
10:37:53 <lambdabot>  [27%1,2%1,4%1,6%1,8%1,37%1,147%1,419%1,961%1,1908%1,3422%1]
10:39:01 <nomeata> :i Any
10:39:16 <chessguy> ?hoogle Any
10:39:17 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
10:39:17 <lambdabot> Network.Socket.aNY_PORT :: PortNumber
10:39:17 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: CharParser st Char
10:39:35 <nomeata> I think I saw it somewhere as a newtype Bool, but not sure.
10:39:55 <nomeata> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Monoid.html
10:40:26 <chessguy> > maxBound::Any
10:40:28 <lambdabot>  Any {getAny = True}
10:40:38 <chessguy> > minBound::Any
10:40:39 <lambdabot>  Any {getAny = False}
10:40:52 <UUStudent> @pl \ h -> IO.hGetContents h >>= putStr
10:40:52 <quicksilver> ANy and ALl are nwtypes to give monoid structures to Bool
10:40:53 <lambdabot> (putStr =<<) . (IO .) . hGetContents
10:41:01 <quicksilver> I think
10:41:09 <sjanssen> that is correct
10:41:22 <nomeata> > Any True `mappend` Any false
10:41:23 <lambdabot>   Not in scope: `false'
10:41:26 <nomeata> > Any True `mappend` Any False
10:41:28 <lambdabot>  Any {getAny = True}
10:41:34 <quicksilver> I suspect they're teh same things that conor mcb calls  mighty and musty
10:41:40 <roconnor> > let p x = 9 % 8 * x * x * x * x - 45 % 4 * x * x * x + 315 % 8 * x * x - 217 % 4 * x + 27 in map (\x -> let (a :% 1) = p x in a) [0..10]
10:41:41 <lambdabot>   Not in scope: data constructor `:%'
10:41:45 <sjanssen> they exist because Bool is a monoid under both (&&, True) and (||, False)
10:41:45 <nomeata> > All True `mappend` All False
10:41:47 <lambdabot>  All {getAll = False}
10:42:01 <nomeata> > mzero :: All
10:42:03 <lambdabot>  Couldn't match expected type `All' against inferred type `m a'
10:42:05 <roconnor> @hoogle Ratio a -> (a,a)
10:42:06 <lambdabot> No matches, try a more general search
10:42:18 <roconnor> @hoogle (a,a)
10:42:19 <lambdabot> Data.Map.findMax :: Map k a -> (k, a)
10:42:19 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
10:42:19 <lambdabot> Data.Map.elemAt :: Int -> Map k a -> (k, a)
10:42:20 <nomeata> > mempty :: All
10:42:21 <lambdabot>  All {getAll = True}
10:42:38 <roconnor> @type numerator
10:42:40 <lambdabot> forall a. (Integral a) => Ratio a -> a
10:43:25 <sjanssen> > getAll . foldMap All $ [False, True]
10:43:26 <lambdabot>   Not in scope: `foldMap'
10:48:59 <glguy> ?seen vegai
10:49:00 <lambdabot> vegai is in #happs. I don't know when vegai last spoke.
10:55:20 * earthy loves 100 fold speedups
10:55:54 <siti> 100!!??
10:56:11 * earthy nods
10:56:17 <earthy> well, almost
10:56:19 <siti> how did you do that?
10:56:24 <earthy> 1190s down to 13.5s
10:56:47 <earthy> -O2 -funbox-strict-fields gave me 5 times speedup
10:57:02 <earthy> a less stupid algorithm gave me the rest
10:57:06 <siti> nice :D
10:57:59 * earthy can go eat now. :)
10:58:07 <siti> yeah :p
10:59:08 <roerd> @pl withFile name mode = bracket (openFile name mode) hClose
10:59:08 <lambdabot> withFile = flip flip hClose . (bracket .) . openFile
11:00:14 <earthy> oh, memorybandwidth pressure went down 81 times... so I guess I was memory bound. :)
11:00:22 <siti> ok
11:00:37 <siti> what type of program was it?
11:01:09 <earthy> a check running a dataset against a bayesian network
11:01:25 <siti> sounds fun :D
11:01:35 <earthy> in a sense, it is.
11:02:17 <earthy> it's a small part of http://www.cs.uu.nl/dazzle/
11:02:21 <lambdabot> Title: Dazzle
11:19:03 <malsyned> Is there an automatic cabal->dpkg bridge, like the cabal->rpm bridge that bos is working on?
11:19:20 <bos> john goerzen wrote something.
11:32:37 <ndm> @seen dons
11:32:37 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 6h 55m 16s ago.
11:34:39 * ndm is working on Yhc -O :)
11:38:24 * kc5tja is working on Java code (at work), and it is seriously sucking hard.
11:40:02 <Slarba> kc5tja: depends how you write it ;)
11:40:44 <quicksilver> kc5tja: I find eclipse eases the pain
11:41:17 <Slarba> and beanshell
11:41:37 <cjeris> perhaps the best way to write java is to write scala, compile it, then decompile the resulting bytecode? :p
11:43:02 <quicksilver> assuming scala compiles into decompilable bytecode
11:43:05 <quicksilver> which it may well not
11:43:12 <quicksilver> most decompilers are designed for the output of javac
11:43:16 <quicksilver> not general bytecode
11:45:47 <kc5tja> Slarba: That's the problem -- I didn't write it.
11:46:00 <kc5tja> And it was working perfectly, but NOW it's throwing NullPointerException errors all over the place.  >:(
11:46:34 <kc5tja> quicksilver: Eclipse won't help find the cause of this.  We use IntelliJ IDEA here, which is similar to Eclipse.  It's not helping.
11:47:02 <kc5tja> Anyway, I'll be back.  Meeting, then a lunch.
11:47:07 <kc5tja> Then perhaps another meeting.
11:47:20 <Slarba> stack trace is of no help?
11:47:47 <ehird> language to learn, 2007: haskell
11:48:17 <mauke> what languages do you know?
11:48:23 <ehird> you people will have to deal with me for at least a year
11:48:27 <ehird> mauke: quite a few
11:48:30 <ehird> no functional ones, though
11:48:46 <bos> @users
11:48:46 <lambdabot> Maximum users seen in #haskell: 324, currently: 323 (99.7%), active: 48 (14.9%)
11:48:49 <mauke> C, C++, Perl, Python, Lisp?
11:49:00 <astrolabe> ehird: Good luck.  It's fun!
11:49:03 <ehird> (ruby and python are the ones i currently use most)
11:49:32 <astrolabe> ehird: Do you want some pointers?
11:49:37 <ehird> (other ones, like php, will not be mentioned to aid the committee trying to remove knowledge of such languages from my brain)
11:49:45 <ehird> astrolabe: if you know any, that'd be appreciated, thanks :)
11:50:11 <astrolabe> My favorite web tutorial is yaht
11:50:15 <astrolabe> @where yaht
11:50:16 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:50:21 <astrolabe> @learn
11:50:21 <lambdabot> http://www.haskell.org/learning.html
11:50:40 <ehird> whoa, lambdabot's image url transformed into the image inline
11:50:45 <ehird> i didn't know my irc client did that
11:51:27 <astrolabe> If you want a book, I can recommend 'The haskell school of expression"
11:51:40 * kc5tja knows (non-exhaustive): ARexx, BASICs of various flavors, Bash, C(++), Forth, (learning Haskell; probably know enough to be dangerous), J, K, Lisp, Modula-2, Oberon, Objective-C, Perl, Python, Rexx, Rebol, Scheme,  --  I can't remember if I know any more....
11:52:08 <ehird> J, K - the languages you must know to inform the internet you are joking in a hip way
11:52:09 <astrolabe> ehird: and this is an excellent place to hang around / ask questions
11:52:09 <kc5tja> Heh -- OK, meeting about to start.
11:52:44 <kc5tja> ehird: It was through J and K that the idea of "implicit iteration" first really hit home with me.
11:52:52 <astrolabe> ehird: Have you got a compiler yet?
11:53:03 <ehird> astrolabe: yes, I did 'hello world' a while ago but didn't really progress further
11:53:16 * mauke has written programs in BASIC, Pascal, bash, C, C++, Perl, Python, OCaml, Lisp, Haskell, Java, Brainfuck, Sorted!, INTERCAL, ploki, false, PHP
11:53:16 <ehird> ghc, i think it's called
11:53:19 <glguy> How would someone that uses emacs approach taking an xml file with no line endings and turning it into a pretty indented xml file?
11:53:28 <astrolabe> ehird: Ah ok.  "hello world" doesn't flatter haskell I think.
11:53:44 <ehird> the one thing i noticed about it was that putStrLn was an oddly named print function :P
11:53:48 <mauke> main = putStr "Hello, world!\n"
11:54:07 <astrolabe> You could use "print
11:54:08 <ehird> well, i did the factorial function on the haskell in 5 steps page too
11:54:24 <astrolabe> um: you could use "print"
11:54:32 <astrolabe> @type print
11:54:35 <lambdabot> forall a. (Show a) => a -> IO ()
11:54:38 <psi> glguy: does indent region work?
11:54:45 <psi> indent-region
11:54:49 <glguy> psi: no, and I think that that is because it has no newlines
11:54:55 <psi> ok
11:54:58 <glguy> indent-region is C-M-\ apparently
11:54:59 <mauke> ehird: http://www.willamette.edu/~fruehr/haskell/evolution.html ? :-)
11:55:01 <lambdabot> Title: The Evolution of a Haskell Programmer
11:55:10 <bos> glguy: sgml-fill-element
11:56:01 <glguy> bos: I don't have that function
11:56:21 <bos> glguy: take a alook at psgml, which provides it
11:56:32 <ehird> fac n = snd (until ((>n) . fst) (\(i,m) -> (i+1, i*m)) (1,1)) <-- I think my head exploded
11:56:34 <glguy> C-M-< C-M-> ought to set the region to be the whole buffer, no?
11:57:20 <malsyned> any Ubuntu haskell gurus in the house?
11:57:27 <cjeris> glguy: yes.
11:57:37 <malsyned> glguy: just C-< and C->
11:57:37 <cjeris> wait.  C-M-<?  M-<.
11:58:28 <psi> C-x h
11:58:28 <glguy> OH, M-< is what I meant
11:58:29 <malsyned> er, right.  M-<
11:58:41 <psi> C-x h is mark-whole-buffer
11:58:45 <glguy> I was holding the shift key and cross wires in my brain
11:59:22 * ehird sees the darcs yaht repository and converts it to html (pdf, bah)
12:00:36 <glguy> hmm, what would the replace-regex for <.*> to $0\n actually be (I know that \n is C-q C-j)
12:01:53 <quicksilver> <.*>
12:02:00 <quicksilver> \1C-qC-j
12:02:11 <quicksilver> $0 is a perl-ism, it's \1 in regexpspeak
12:02:31 <quicksilver> erm <\(.*\)>
12:02:32 <quicksilver> rather
12:02:56 <Slarba> wth... is the ghc-6.6 compiler just seriously broken?!
12:03:03 <Slarba> I get very strange results
12:03:07 <glguy> [~<] means anything but <?
12:03:10 <glguy> or is that [!<]
12:03:15 <glguy> or something totally different
12:03:26 <ibid> [^<] usually
12:03:35 <ibid> Slarba: yes?
12:05:12 <ehird> ok, that ate all my ram maybe not a good idea
12:05:40 <ehird> is there an already-converted html yaht on hte web?
12:06:11 <bd_> http://en.wikibooks.org/wiki/Haskell/YAHT
12:06:20 <glguy> This worked... replace-string ">" ">\n", and then C-x h C-M-\
12:06:32 <glguy> basically :)
12:06:57 <ehird> bd_: i've always found wikibooks awkward to read... not sure why, think it's the huge sidebar and sans-serif font
12:07:27 <mauke> http://209.85.135.104/search?q=cache:VWvjbL_Y1EQJ:darcs.haskell.org/yaht.ps&hl=en&ct=clnk&cd=6&gl=de
12:07:30 <lambdabot> Title: Yet Another Haskell Tutorial, http://tinyurl.com/2cmrkl
12:07:42 <kowey> ehird: you can also use a custom css to read them
12:07:46 <bd_> ehird: Well, it's a HTML import anyway
12:07:54 <kowey> ehird: for example, by setting your wikibooks user preferences
12:08:23 <kowey> (that being said, i do agree that the sans serif fonts make for hard reading)
12:08:42 <glguy> I find serif fonts hard to read on the web
12:09:10 <ehird> latex2html is  working fine, anyway, even if it is dying on lots of images..
12:15:42 <metaperl> ehird - I use PlasTeX - python-based
12:16:03 <xic> woohoo, netsplit!
12:16:23 <astrolabe> That took a long time to fix
12:16:39 <ehird> metaperl: looks like the ugly python docs... (the example)
12:16:59 <astrolabe> In case you haven't found it, yaht on the web, even if not html http://en.wikibooks.org/wiki/Haskell/YAHT
12:17:36 <ehird> ho hum, sourceforge is slow
12:17:37 <JohnnyL> what sort of things can you not do in the interpreter than you can do in the compiler?
12:18:36 <norpan> call functions not yet defined?
12:19:04 <JohnnyL> ok
12:19:18 <JohnnyL> i thoguht it was alot more than that.
12:19:31 <astrolabe> JohnnyL: which interpreter?
12:19:45 <JohnnyL> haskell: ghci
12:20:29 <astrolabe> I don't think you could say 'fac 0 = 1' for instance
12:21:15 <astrolabe> You have to use expressions rather than statements iirc
12:23:20 <ehird> `let' works in ghci here?
12:23:25 <ehird> i.e. let fac 0 = 1
12:24:12 <thedward> > let fac 0 = 1 in fac 0
12:24:14 <lambdabot>  1
12:24:51 <JohnnyL> astrolabe, ok
12:25:41 <astrolabe> ehird: right
12:28:01 <ehird> plastex enjoys complaining
12:30:39 <ehird> Well, it produced an index.
12:30:42 <ehird> Containing this: "*red Censoredf jdsalf jkasf jklasf ajsdklf jasdf jaskdfj alksdf jaklsd fjklasdjfkla sdjklf jasdlkfajsdf jlaksdf jaklsdjf aksdfj ksadjfklasdjflkasdj a"
12:30:47 <ehird> No joke.
12:35:20 <michaelw> astrolabe: let fac 0 = 1 is a-okay in ghci
12:35:38 <michaelw> gah, living in the paste
12:35:41 <michaelw> past, even
12:37:43 <malsyned> anyone know why I would have ghc6.6 installed but a Setup.hs would fail on dependency mtl-any ?
12:38:35 <kosmikus> malsyned: do you have mtl installed as well? mtl is shipped as a separate library now ...
12:38:39 <michaelw> malsyned: maybe you need to install mtl
12:38:41 <malsyned> ah.  that explains it.
12:38:56 <malsyned> It didn't used to be shipped as a separate library.  I just upgraded to ghc 6.6 from 6.4.
12:39:11 <michaelw> Debian?
12:39:19 <malsyned> michael: Ubuntu
12:39:31 <michaelw> close enough.  i fell into the same trap
12:39:39 <malsyned> I used prevu to backport ghc6.6 to Edgy.
12:41:10 <astrolabe> michaelw: right, but you need the 'let'
12:41:23 <malsyned> and all these libraries that used to be included are now separate.  Hey, speaking of which, any idea how I might satisfy a dependency for libghc6-hslogger-dev ?  The source doesn't appear to be in the feisty source repos.
12:41:52 <ehird> metaperl: plastex doesn't seem to work...
12:42:13 <metaperl> ehird - ok, well I was very happy with it. sorry it didnt work for you
12:42:16 <ehird> it freezes after a few warnings and starts eating cpu
12:43:13 <fuzan> Hey, what do you gentoo'rs use to get the ghc extralibs? (Network, etc.)
12:44:51 <jyasskin> astrolabe: ghci is basically running inside an IO 'do' block, so anything you can do there, you can do in the interpreter.
12:45:07 <jyasskin> The only think I wind up missing is datatype definitions.
12:45:13 <jyasskin> s/think/thing/
12:46:18 <bla123> how do i tell a cabal "setup.hs" where to look for C headers and libs?
12:48:05 <ulfdoz> Gab's nicht nur P4 mobile?
12:48:09 <ulfdoz> ECHAN, sorry
12:49:47 <fuzan> Jeez, what distributions are you all using?
12:50:00 <dons> ?users
12:50:00 <lambdabot> Maximum users seen in #haskell: 326, currently: 321 (98.5%), active: 54 (16.8%)
12:50:49 <chessguy> a new record!
12:51:04 <ehird> bleh, start working, plastex
12:51:07 * ehird considers the wikibook
12:51:43 <shapr> Yay 326!
12:52:38 <astrolabe> @stats
12:52:39 <lambdabot> Unknown command, try @list
12:52:43 <astrolabe> @where stats
12:52:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
12:53:17 <jyasskin> Lambdabot got a lot more capable in the year.5 since I've been in here.
12:53:35 <malsyned> ay!  I finally got yi to compile!
12:53:40 <siti> ool nice
12:54:07 <dons> jyasskin: hey. yeah. about 1500 patches
12:54:07 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
12:54:31 * jyasskin is impressed
12:54:52 <dons> ?seen lambdabot
12:54:59 <lambdabot> Yes, I'm here. I'm in #haskell.it, #haskell, #haskell.es, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell-
12:55:02 <lambdabot> overflow and #haskell-blah
12:55:03 <dons> she lives in about 25 different channels now
12:55:27 <SamB> ?seen freenode2:lambdabot2
12:55:28 <lambdabot> freenode2:lambdabot2 is in freenode2:#haskell.jp. I don't know when freenode2:lambdabot2 last spoke.
12:55:36 <sjanssen> @hackage binary
12:55:37 <lambdabot> Unknown command, try @list
12:55:43 <dons> sorry. not updated yet.
12:55:48 <SamB> sorear says lambdabot is using a lousy version of happs
12:55:50 <sjanssen> dons: which day do you update?
12:56:07 <dons> happs eh?
12:56:16 <dons> sjanssen: hmm. i should pick a day
12:56:29 <glguy> ?zow!
12:56:30 <lambdabot> I have a TINY BOWL in my HEAD
12:56:39 <SamB> he clarified that it was to happs what DOS is to UNIX ;-)
12:58:01 <dons> interesting.
12:58:55 <SamB> he said that this is why lambdabot does not persist things like IRC connections and channels joined...
12:59:35 <dons> ah i see.
12:59:53 <ndm> dons: i'm working on a Yhc backend, we'll have -O, -OGHC and -OClean, to use the Yhc front end with various back ends
13:00:15 <ndm> dons: is that too many for nobench? since the original Yhc without -O will virtually be a different compiler, so needs to stay in
13:00:18 <norpan> -Other
13:00:44 <jyasskin> I haven't heard of the 'ther' backend.
13:00:48 <ndm> we'll also have -O11, but not for a while yet :)
13:01:01 <SamB> how about -OJHC, with alias -OOM
13:01:08 <dons> ndm, well, depends on how hard it is to get running
13:01:29 <ndm> dons: if you have GHC and Clean installed, just adding an extra flag will be enough
13:01:29 <dons> if it all just works out of the box, i don't mind
13:01:29 <dcoutts> dons, ah, g'morning
13:01:36 <dons> hey dcoutts
13:01:51 <ndm> dons: neat, i'll try and get -O in the next few days, then the -OGHC and -OClean will follow a few days later
13:01:53 <dcoutts> dons, sent you a few fps patches, I've been working on Experimental.Data.Stream and Experimental.Data.List
13:02:10 <dons> ah great. to apply to the unstabe repo?
13:02:12 <dcoutts> for the fps-unstable repo
13:02:14 <dcoutts> yep
13:02:25 <glguy> dons: could lambdabot be told to join #happs? (how hard would it be to compile a custom lambdabot that exported HAppS)?
13:02:27 * SamB wonders why nobody is reacting to his joke
13:02:33 * fuzan wonders why he does not have Control.Monad.State
13:02:45 <SamB> fuzan: you need more packages
13:02:53 <glguy> fuzan: you run linux with insane package maintainers
13:02:56 <dons> @join #happs
13:03:04 <SamB> glguy: actually, it isn't like that...
13:03:06 <dons> glguy: i'll add it to the list
13:03:20 <SamB> see, the ghc6.6 package never requires the extralibs for some reason!
13:03:32 <fuzan> yah. i'm a little annoyed with teh gentoo overlay.
13:03:38 <fuzan> i'm merging random stuff from extralibs now
13:03:42 <fuzan> well, manually
13:03:49 <SamB> ???
13:03:56 <fuzan> but I can't find anything relating to Control.Monad.State
13:04:04 <fuzan> http://haskell.org/ghc/dist/6.6/ghc-6.6-src-extralibs.tar.bz2
13:04:25 <SamB> doesn't the gentoo overlay have a ghc6.6-extralibs package or something like that?
13:04:30 <glguy> dons: lambdabot was already ther as of 30 minutes ago apparently
13:04:31 <fuzan> ls **/*State*    -> nothing that looks like Control.Monad.State
13:04:34 <fuzan> SamB: not that I can find.
13:05:11 <sjanssen> fuzan: did you see my reply in #gentoo-haskell?
13:06:15 <bla123> how do i make a "runghc Setup.hs configure" pass command line arguments directly to ghc?
13:06:45 <dons> add ghc-options: foo to the .cabal file
13:07:19 <bla123> thank you, i was just looking for command line options all the time
13:07:25 <ehird> Is the skin used in the haskellwiki freely avaliable? I'll probably use that with the YAHT wikibook
13:07:39 <ehird> (if it isn't named/free downloadable from somewhere, then i'll have to rip the css out! :D)
13:11:52 <ndm> @hpaste
13:11:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:12:12 <hpaste>  ndm pasted "Fun type error message" at http://hpaste.org/591
13:12:40 <ndm> PS, I'm not asking for help debugging that, i realise there is little anyone could do...
13:12:43 <ndm> its just scary
13:13:12 <mauke> is that hugs?
13:13:58 <ndm> yep
13:14:39 <twanvl> What did you do to deserve that?
13:15:17 <ndm> writing a Haskell back end for Yhc Core
13:15:36 <ndm> it means you've got to take concepts out of Yhc Core (which is untyped) and put them back in Haskell
13:16:10 <ndm> esp hard to replace Yhc primitives which don't existing in Haskell back with pure haskell
13:18:14 <Philippa> er, yeah. Ow.
13:18:30 <Philippa> I would've thought the appropriate thing to do was to work in a YHCCore monad (probably on top of IO), but hey
13:20:27 <ndm> if i was writing an interpretter, yeah
13:20:44 <ndm> but i want to recompile this code as Haskell once more, in Yhc, without any optimisation, so i have to do it direct
13:21:00 <Philippa> ah. Dare I ask why you want to do that?
13:21:11 <ndm> so i can write an optimiser for Yhc
13:21:16 <ndm> using Yhc Core, which Yhc can't compile
13:21:31 <ndm> its not a "good" design, but it is a design none the less
13:21:55 <sendo> does anyone know how to implement an AC-3 arc consistency algorithm in haskell?
13:22:12 <Philippa> fair enough. I guess I was assuming the existance of an optimiser (largely for inlining) when suggesting a monad
13:22:32 <sendo> @hoogle sortBy
13:22:33 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
13:22:46 <ndm> Philippa: we have one of those, but it hits before the output, not after :(
13:23:33 <quicksilver> ndm: I don't think I understand that piece of indirection at all
13:23:53 <ndm> quicksilver: its complex, and a BAD WAY of doing things, but its the way we do things
13:24:05 <quicksilver> ndm: how does a mapping from yhc core to haskell help you write an optimiser?
13:24:11 <ndm> quicksilver: Haskell -> Compiler -> Core -> Optimised -> Haskell -> Compiler -> ByteCode
13:24:32 <ndm> quicksilver: i can write an optimiser easily enough, just not a compiler for the optimised code
13:24:48 <quicksilver> ah!
13:24:54 <quicksilver> hmm
13:25:20 <david_> hello
13:26:01 <ndm> quicksilver: one addition advantage is that the second compiler no longer has to be the same as the first, it doesn't even have to be the same language (we support Clean)
13:26:07 <ndm> quicksilver: but its still not a good idea
13:26:43 <david_> I don't want to disturb, but would this be a good place to ask for an explanation about a ( probably simple ) haskell problem ? I'm trying to learn.
13:26:53 <nocturnal> i've found the page with books on haskell.org but i prefer to ask you guys which book you would recommend for a unix user who knows some languages like perl and c but has never used haskell at all and wants to start learning it as a hobby, nothing serious that is
13:27:06 <dons> ?where yaht
13:27:07 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
13:27:08 <dons> perhaps?
13:27:11 <Cale> nocturnal: YAHT and the Wikibook
13:27:16 <dons> that's usually hat we recommend. and the wikibook
13:27:20 <nocturnal> i want a book, i don't like reading from the screen
13:27:22 <ehird> somebody stop that yaht linking, it takes up 3 pages in my irc client for the pdf preview =P
13:27:31 <ehird> hehe
13:27:37 <dons> your irc client does pdf previews??
13:27:51 <ehird> i didn't know either
13:27:55 <quicksilver> david_: yes, it's exactly that kind of place
13:27:56 <mauke> ehird: get a better irc client :-)
13:27:58 <ndm> david_: ask away :)
13:27:58 <ehird> but it displays the first page inline after grabbing it from the web it seems
13:27:59 <wilx> Heh.
13:28:05 <dons> scary
13:28:07 <ehird> i think a dev had too much time on their hands.
13:28:07 <wilx> Evil.
13:28:15 <wilx> Does it execute binaries too?
13:28:17 <nocturnal> is the WikiBook available in print?
13:28:22 <ehird> wilx: not entirely sure.
13:28:39 <ehird> :D
13:29:04 <ehird> ok, the YAHT wikibook should REALLY have next/back butotns at the bottom
13:29:07 <david_> thanks ndm. I have this error on a function and I'm totally clueless as to how to correct it.   the error is :
13:29:07 <david_>   Ambiguous type variable `a' in the constraint:
13:29:07 <david_>       `Read a' arising from use of `split2' at tst.hs:15:21-26
13:29:07 <david_>     Probable fix: add a type signature that fixes these type
13:29:07 <david_> variable(s)
13:29:20 <Cale> Maybe Graham Hutton's new book?
13:29:21 <ndm> @paste
13:29:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:29:32 <Cale> http://www.cs.nott.ac.uk/~gmh/book.html
13:29:33 <ndm> david_: ^ paste the code and the error message in that pastebin
13:29:34 <lambdabot> Title: Programming in Haskell
13:29:48 <nocturnal> Cale: Programming in Haskell?
13:29:50 <nocturnal> oh
13:29:54 <david_> ok
13:30:12 <Cale> nocturnal: I haven't read it yet though.
13:30:19 <Cale> nocturnal: But I've heard that it's good.
13:31:16 <nocturnal> well that's the best i've heard so far, thank you
13:32:03 <hpaste>  David Virebayre pasted "Bug in test 1" at http://hpaste.org/592
13:32:38 <david_> posted it
13:33:05 * ehird just grasps what ``lazy'' means
13:33:17 <ehird> that's something i never thought a computer could do
13:33:20 <david_> the problem arises in function 'test1'. ( there's 2 versions of it )
13:33:25 * ehird eye's explode appropriately
13:34:16 <mwc> ehird, lazyness is incredibly convenient
13:34:23 <ehird> it sure sounds so
13:34:28 <bd_> once you understand it anyway :)
13:34:34 <mwc> do you know the canonical fibonnachi example?
13:34:40 <ehird> yep
13:34:43 <sjanssen> david_: the problem is that Haskell doesn't know which implementation of "read" you want
13:34:48 <ehird> saw the haskell ver :)
13:35:00 <ehird> fac 0 = 1, fac n = n * fac (n-1)
13:35:05 <mwc> no no
13:35:17 <david_> sjanssen : there are many ?
13:35:18 <mwc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
13:35:19 <lambdabot>  Parse error
13:35:24 <nmessenger> @instances Read
13:35:26 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
13:35:28 <bd_> > let fact = 1:zipWith (*) fact [2..] in fact
13:35:30 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
13:35:32 <nmessenger> yep :)
13:35:39 <mauke> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
13:35:41 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:36:10 <mwc> mauke, hmm, I thought that lambdabot was supposed to be like GHCi, effectively a "do" env.
13:36:24 <david_> sjanssen : then why this one works :
13:36:25 <david_> > test2 :: ( Read a, Read b ) => [( a, b )]
13:36:25 <david_> > test2 = map split mylist
13:36:26 <lambdabot>   Not in scope: `test2'
13:36:26 <lambdabot>  Parse error
13:36:29 <nmessenger> david_: you add a type annotation to "l <- func >>= return . split2", i.e. "l <- func >>= return . split2 :: Net [(Int, Double)]" or whatever
13:36:31 <hpaste>  sjanssen annotated "Bug in test 1" with "one way to fix the ambiguity" at http://hpaste.org/592#a1
13:36:44 <ehird> "A call like x = x + 1 is called destructive update because we are destroying whatever was in x before and replacing it with a new value. Destructive update does not exist in Haskell." <-- is that a way of saying 'you can't assign to variables after defining them'?
13:37:08 <mauke> ehird: pretty much
13:37:09 <mwc> ehird, it would be better to say that names in haskell are "bindings," not variables
13:37:13 <mwc> they're "bound" to a value.
13:37:14 <sjanssen> david_: in that version, the caller decides which versions of "Read" to use
13:37:22 <mauke> ehird: it's not just about variables, though
13:37:34 <ehird> that sounds simultaniously a great way to keep out bugs and a pain in the butt
13:37:39 <nmessenger> that *are* variables in the mathematical sense, not the mutable box sense.
13:37:54 <norpan> we have mutable boxes too
13:38:07 <siti> IORef ;)
13:38:52 <norpan> we just won't use them if we don't have to
13:38:54 <nmessenger> f x = x + 1 -- x "varies" depending on which value is passed to f
13:38:55 <astrolabe> ehird: I was amazed that you could program at all with such constraints
13:38:59 <david_> so if I had used say split :: ( Int a, Int b ) => String -> (a,b)     ( and modified the others accordingly ) it'd work ? I'll try.
13:39:10 <mauke> except Int is not a class
13:39:17 <ehird> astrolabe: "the only programming language where variables are not... variable"
13:39:26 <siti> lol
13:39:26 <sjanssen> david_: split :: String -> (Int, Int) -- is correct
13:39:44 <nmessenger> david_: also split2 :: String -> [(Int,Int)]
13:39:44 <mauke> constants aren't, variables don't
13:39:51 <siti> call them functions, everything is a function :p
13:40:19 <bd_> siti: Except bindings!
13:40:28 <astrolabe> ehird: My advice is to see what you can do without using mutable variables.  They aren't really the right spirit for haskell, though they are useful sometimes I suppose.
13:40:32 <siti> close enough ;)
13:40:33 <bd_> Except when bindings /are/ functions.
13:40:37 <Altair^> hi, I am a complete noob with haskell, and would like to know how to print a table returned by a function in the main function
13:40:45 <bd_> let plusone = fmap succ ...
13:40:51 <mauke> Altair^: what's a table?
13:40:55 <norpan> they are called variables because the value is potentially unknown and can vary between invocations
13:41:11 <encryptio> Altair^: print table -- but for prettyprinting you'll have to actually tell us what a "table" is
13:41:13 <ehird> siti: yeah, everything is a function is something i thought all programming languages should know is logical
13:41:27 <nmessenger> david_: split2 is fine with its type, its just that the type inferencer can't tell which types split2 should return in the call in test1.  Read is a class that has many types, so you have to tell it which types to use.
13:41:31 <ehird> though i hope compilers optimize away that "function that just returns 5"
13:41:32 <Altair^> well I mean a list, like []
13:41:36 <Altair^> well eh
13:41:42 <encryptio> ehird: they do - inlining
13:41:44 <mauke> > print [1,2,3]
13:41:46 <lambdabot>  <IO ()>
13:42:10 <siti> well ghc is an amazing compiler and manages to be faster than java, c# :) even though it's much higher level
13:42:22 <nmessenger> Altair^: the "show" function turns things into strings.  The print function is a shorthand for "show" then "putStrLn"
13:42:24 <ehird> snd (fst ((1,'a'),"foo")) <-- I am reminded of lisp, but not in a bad way
13:42:26 <nmessenger> @type show
13:42:29 <lambdabot> forall a. (Show a) => a -> String
13:42:33 <encryptio> @src show
13:42:33 <lambdabot> show x = shows x ""
13:42:42 <Altair^> ah, thanks nmessenger
13:42:54 <norpan> computers are fast, programmers are slow; that's why a language primarily should make programs fast to write
13:43:14 <siti> yes but haskell accomplishes both
13:43:20 <david_> ok, I think I just got it.
13:43:20 <norpan> that's an added bonus
13:43:21 <encryptio> ehird: in most cases you'd use pattern matching to get that
13:44:00 <mauke> > let ((_, x), _) = ((1, 'a'), "foo") in x
13:44:02 <lambdabot>  'a'
13:44:03 <encryptio> ehird: as in: extractTheA ((_,var),_) = var    -- _ means "throw this away"
13:44:12 <ehird> let x = [1,2,3], let x = 0:x <-- infinite-ness. heh. wasn't expecting that.
13:44:18 <ehird> encryptio: clever
13:44:26 <mauke> > let x = 0 : x in x
13:44:27 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:44:28 <hpaste>  nmessenger annotated "Bug in test 1" with "er, split2 should return a list" at http://hpaste.org/592#a2
13:44:40 <mauke> > repeat 0
13:44:42 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:44:53 <nmessenger> david_: do you understand?
13:45:17 <mbishop> > putStr "Hello" ++ (repeat "o")
13:45:18 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
13:45:21 <mbishop> :[
13:45:24 <david_> Yes I've got it. I've tried for half a day and you guys explained it in a few minutes
13:45:29 <david_> thanks a lot
13:45:36 <nmessenger> mbishop: parens :)
13:45:36 <encryptio> > putStr "Hello" ++ (repeat 'o')
13:45:38 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
13:45:54 <nmessenger> > putStr ("Hello" ++ repeat 'o')
13:45:56 <lambdabot>  <IO ()>
13:46:02 <encryptio> > "Hello" ++ (repeat 'o')
13:46:04 <lambdabot>  "Hellooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
13:46:14 <mbishop> ah, nice work heh
13:46:14 <nmessenger> > cycle "lo"
13:46:15 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
13:46:18 <ehird> There are two basic list functions: head and tail. The head function returns the first element of a (non-empty) list, and the tail function returns all but the first element of a (non-empty) list. <-- car, cdr, anyone?
13:46:21 <siti> well that's pretty silly :p
13:46:56 <david_> I didn't know you could write something like : l <- func >>= return . split2 :: Net [(Int, Int)]
13:47:10 <abz> ?users
13:47:11 <lambdabot> Maximum users seen in #haskell: 328, currently: 327 (99.7%), active: 64 (19.6%)
13:47:17 <Cale> ehird: exactly
13:47:18 <nmessenger> david_: the annotation scopes over everything past the '<-"
13:47:24 <siti> we need to get 4 more people to come in :D
13:47:40 <david_> nmessenger : thanks for the precision.
13:47:52 <ehird> In Haskell, a String is simply a list of Chars <-- HaCkell
13:47:52 <Cale> ehird: Lists in Haskell are cons lists, just like in scheme or common lisp.
13:48:27 <sjanssen> "There are two basic list functions: head and tail." -- pssh, we all know that foldr is the One True List Function :)
13:48:39 <Altair^> hmm, what does it usually mean when I try to print and it says that No instance for (Show (IO [String]))
13:48:42 <nmessenger> True /= basic
13:48:59 <sjanssen> Altair^: it means you're trying to print some sort of IO action, which you can't do
13:49:01 <Cale> Altair^: are you trying to print an action?
13:49:02 <mauke> Altair^: it means you're trying to print an IO action
13:49:07 <mauke> haha
13:49:12 <mauke> @stereo
13:49:13 <lambdabot> Unknown command, try @list
13:49:16 <Cale> @quote stereo
13:49:16 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:49:28 <nmessenger> Altair^: you must first draw the string out of the action before you can print it.
13:49:36 <Altair^> ah, okay
13:49:39 <sjanssen> if your code is "do print action", then it should be "do x <- action; print x"
13:49:43 <ehird>  head (length (tail [1,2,3] ++ [3,2,1]):length([1,2,3]):[]) <-- Get out of the way, I'm a useless programmer
13:49:50 <nmessenger> Altair^: you do this either with the (>>=) function or with do notation
13:49:54 <mauke> eep
13:50:08 <siti> ehird: don't be hard on yourself you are learning :p
13:50:10 <nmessenger> > print getLine -- doesn't type
13:50:11 <lambdabot>  <IO ()>
13:50:18 <nmessenger> er, shouldn't type :)
13:50:21 <Altair^> yeah, having done java and c haskell is not so easy at first
13:50:28 <siti> yep
13:50:35 <nmessenger> > do line <- getLine; print line
13:50:37 <lambdabot>  <IO ()>
13:50:38 <david_> So true Altair^
13:50:44 <siti> I am similar, and haskell was very hard at first
13:50:49 <encryptio> ehird: at least you're doing it... most people don't keep going after a few minutes with haskell
13:51:01 <sjanssen> nmessenger: it types because of the dummy Show instance for IO in lambdabot
13:51:09 <mauke> ehird: head [length (tail [1,2,3] ++ [3,2,1]), length [1,2,3]] ?
13:51:11 <nmessenger> yeah, I figured that :)
13:51:28 <ehird> encryptio: i like the syntax
13:51:31 <Altair^> woot, it worked
13:51:40 <sjanssen> > putStrLn
13:51:42 <ehird> ascii art generating ascii art: [()]:[[()]] ----> [[()],[()]]
13:51:42 <lambdabot>  <[Char] -> IO ()>
13:51:48 <encryptio> heh
13:51:50 <ehird> not much of an ascii masterpeice, mind
13:52:23 <mauke> @v
13:52:24 <lambdabot> Exception: <<loop>>
13:52:29 <nmessenger> the (:[]) function looks like a monster
13:52:48 <chessguy> @quote monster
13:52:48 <lambdabot> dcoutts says: (:[]) looks like a monster
13:52:58 <chessguy> plagiarist!
13:53:01 <siti> well I see a big smile face there :p
13:53:07 <sendo_> @quote @quote
13:53:08 <lambdabot> lambdabot says: @quote lambdabot
13:53:11 <encryptio> i see a monster
13:53:12 * nmessenger has been shamed :(
13:53:23 <mauke> :t (.) (.)
13:53:24 <ehird> I can even refactor code! [()]:[()]:[] -- more confusing, at half the price! tastes exactly the same!
13:53:24 <chessguy> @type (:{})
13:53:27 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
13:53:28 <lambdabot> parse error on input `{'
13:53:35 <chessguy> @type (:[])
13:53:38 <lambdabot> forall a. a -> [a]
13:53:40 <encryptio> :t (.) . (.)
13:53:43 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:53:51 <nmessenger> ehird: try: ((():[]):(():[]):[])
13:54:05 <ehird> nmessenger: what is this? brainfuck
13:54:07 <ehird> ?
13:54:09 <ehird> :D
13:54:26 <nmessenger> nah, the [x,y,z] syntax is just ugly sugar.
13:54:40 <nmessenger> (x:y:z:[]) is preffered by discriminating hackers.
13:54:43 <Cale> heheh
13:54:51 <encryptio> @bf ++++++++[>+++++++++<-]>.<++++[>+++++++<-]>+.<++[>+++<-]>+..+++.++++[>++++++++<-]>.<+++++[>++++++++++<-]>+++++.<<.+++.------.<+++[>---<-]>+.
13:54:52 <lambdabot> Plugin `bf' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:54:57 <encryptio> =(
13:55:07 <bd_> > join ($[])([()]:)
13:55:09 <lambdabot>      Occurs check: cannot construct the infinite type:
13:55:09 <lambdabot>       b = ([a1] -> b) ...
13:55:32 <nmessenger> > ($[])([()]:)
13:55:33 <lambdabot>  [[()]]
13:55:40 <bd_> yeah, it's the next step that kills it
13:56:22 <nmessenger> @type ($[])
13:56:25 <lambdabot> forall b a. ([a] -> b) -> b
13:56:36 <mauke> @bf >++++++++[<+++++++++>-]<+.>>++++[<++++++++++>-]<-.[-]>++++++++++[<+++++++++++>-]<-.>>++++[<++++++++>-]<.>>++++++++++[<++++++++++>-]<---.<.>+.->>++++++++++[<+++++++++++>-]<++++.<.>>>++++++++++[<++++++++++>-]<+++++.<<<<+.->>>>---.<+++.---<++.-->>>>>++++++++++[<+++++++++++>-]<---.<<<<<.<+++.>>>.<<<-.- ->>>>+.<.<.<<.>++++++++++++++.
13:56:37 <lambdabot> Plugin `bf' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:56:43 <nmessenger> @bot?
13:56:44 <sjanssen> > join (($[])([()]:))
13:56:44 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
13:56:45 <lambdabot>  [()]
13:56:47 <mauke> @bf []
13:56:48 <lambdabot> Plugin `bf' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:56:54 <mauke> who broke @bf?
13:56:58 <nmessenger> well ($[]) is only unary, to join it'd have to be binary
13:57:46 <xerox> > join [[()]]
13:57:48 <lambdabot>  [()]
13:58:03 <nmessenger> @quote Help!
13:58:04 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
13:58:14 <encryptio> lol
13:58:56 <ehird> CANNOT CONSTUCT.... THE INFINITE TYPE <dundudnudn>
13:59:15 <nmessenger> > fix fix
13:59:17 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
13:59:17 <lambdabot>     Probabl...
13:59:24 <mauke> > fix show
13:59:25 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:59:38 <nmessenger> > fix ("aaahh! "++)
13:59:39 <lambdabot>  "aaahh! aaahh! aaahh! aaahh! aaahh! aaahh! aaahh! aaahh! aaahh! aaahh! aaahh...
14:00:14 <nmessenger> > "aah!" >>= replicate 8
14:00:16 <lambdabot>  "aaaaaaaaaaaaaaaahhhhhhhh!!!!!!!!"
14:00:25 <ehird> map head (map show [1,2,3]) <-- hm.
14:00:43 <nmessenger> map chr?
14:01:00 <sjanssen> ehird: same as map (head . show) [1, 2, 3]
14:01:10 <ehird> ooooo shiny
14:01:14 <nmessenger> map (chr . (+ ord '0')) rather
14:01:36 <ehird> doesn't seem to like "putStrLn" or print though
14:01:38 <ehird> not sure why
14:01:38 <xerox> > map intToDigit [1..10]
14:01:39 <lambdabot>  "123456789a"
14:01:55 <nmessenger> coolz
14:01:58 <sjanssen> > map intToDigit [10..]
14:02:00 <lambdabot>  Exception: Char.intToDigit: not a digit 16
14:02:19 <mauke> ehird: what line?
14:02:24 <nmessenger> intToDigit must not have heard of heptadecimal
14:02:33 <ehird> map putStrLn ["hello, ", "world"]
14:02:46 <ehird> or as i was trying to do, map (putStrLn . show) [1,2,3]
14:02:51 <mauke> that works
14:02:56 <nmessenger> putStrLn produces an action, so you'd get a list of actions
14:02:58 <mauke> but it won't print anything
14:03:02 <ehird>     No instance for (Show (IO ()))      arising from use of `print' at <interactive>:1:0-32    Possible fix: add an instance declaration for (Show (IO ()))
14:03:12 <nmessenger> @type sequence
14:03:14 <lambdabot>     Ambiguous occurrence `sequence'
14:03:15 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
14:03:16 <mauke> it doesn't know how to print a list of actions
14:03:21 <ehird> ah.
14:03:25 <nmessenger> @type Control.Monad.sequence
14:03:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:03:38 <nmessenger> also mapM which is sequence + map
14:03:49 <mauke> mapM print [1,2,3]
14:03:55 <ehird> map show [[]:[(1,(([]:[])))]:[]] <-- Introspection-y
14:04:06 <nmessenger> geh
14:04:08 <mauke> > map show [[]:[(1,(([]:[])))]:[]]
14:04:12 <lambdabot>  ["[[],[(1,[[]])]]"]
14:04:21 <encryptio> ehird: having fun with lists i see
14:04:26 <jfoutz> what's the difference between mapM and fmap? i'm a little hazy there... if you don't mind my asking
14:04:40 <nmessenger> fmap is map, mapM is map + sequence
14:04:40 <mauke> jfoutz: everything. fmap == liftM
14:05:06 <jfoutz> ok, no sequencing with fmap. i see
14:05:08 <nmessenger> fmap also "maps" over things that aren't just lists, like Trees for instance.
14:05:20 <ehird> > show (show (show ("'\"show'\"")))
14:05:21 <lambdabot>  "\"\\\"\\\\\\\"'\\\\\\\\\\\\\\\"show'\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
14:05:37 <jfoutz> thanks
14:05:40 <mauke> > iterate show 42
14:05:41 <lambdabot>   add an instance declaration for (Num String)
14:05:45 <mauke> :(
14:05:50 <nmessenger> > fmap (+5) (Node 1 [Node 2 [], Node 3 []])
14:05:51 <lambdabot>  Node {rootLabel = 6, subForest = [Node {rootLabel = 7, subForest = []},Node ...
14:06:01 <mauke> > iterate show ""
14:06:03 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
14:06:08 <bos> @pl \sock nbytes = liftM fst $ recvFrom sock nbytes
14:06:09 <lambdabot> (line 1, column 14):
14:06:09 <lambdabot> unexpected "="
14:06:09 <lambdabot> expecting pattern or "->"
14:06:16 <bos> @pl \sock nbytes -> liftM fst $ recvFrom sock nbytes
14:06:17 <lambdabot> (fmap fst .) . recvFrom
14:06:40 <bos> bleah.
14:06:54 <nmessenger> (f .) . g is standard for \x y -> f (g x y)
14:07:17 <mauke> @unpl (liftM fst .) . recvFrom
14:07:18 <lambdabot> (\ d g -> liftM fst (recvFrom d g))
14:07:28 <mightybyte> Is there any way to avoid typing Array.xyz inside ghci?
14:07:42 <mauke> :m +Data.Array
14:08:19 <ehird> > foldr (+) 2 [(foldr (*) 10 [4])]
14:08:21 <lambdabot>  42
14:08:41 <nmessenger> funny way to say 4 * 10 + 2 :P
14:08:58 <ehird> yep
14:09:07 <mightybyte> mauke: Thanks.  Is the Data. required?
14:09:24 <mauke> mightybyte: oh, I thought you meant the Data.Array module
14:09:44 <Cale> mightybyte: no, but leaving it out is somewhat deprecated
14:10:06 <mightybyte> mauke: I was referring to the regular array
14:10:37 <ehird> > mapM putStrLn [head [show (head [foldr (+) 2 [(foldr (*) 10 [4])]])]]
14:10:38 <nmessenger> the new compilers nowadays are standardising on the Heirarchical modules
14:10:46 <ehird> behold
14:10:54 <ehird> i am teh 1337 haxor
14:11:15 * ehird considers writing 'just another perl hacker,' in haskell
14:11:21 <mbishop> lambdabot: botsnack
14:11:27 <mbishop> @bot
14:11:27 <lambdabot> :)
14:11:29 <ehird> or would that cause the universe to fold itself
14:11:35 <ehird> into nice sharp shapes
14:11:38 <ehird> then implode
14:11:57 <nmessenger> so long as there's no side effects, I could live with that :)
14:12:25 <mauke> ehird: http://mauke.ath.cx/stuff/haskell/hax.pl
14:12:38 <ehird> oh my
14:12:47 <nmessenger> hah!
14:12:54 <nmessenger> 'tis awesome!
14:14:17 <ehird> part 1: foldr (++) ['u'] [['j']]
14:14:39 <siti> ehird: you are a fold addict ;)
14:14:48 <ehird> well, the tutorial just mentioned it, what do you think
14:14:53 <mauke> > foldr (++) "u" ["j"]
14:14:54 <lambdabot>  "ju"
14:14:59 <siti> well almost everything can be written as a fold :D
14:15:26 <nmessenger> ehird: you've not used it before?  You're pretty good!
14:15:45 <mauke> > join (intersperse "; " (map show [1 .. 9]))
14:15:47 <lambdabot>  "1; 2; 3; 4; 5; 6; 7; 8; 9"
14:15:54 <ehird> never typed a line of haskell code before 5-10 minutes ago, nmessenger :P
14:16:07 <ehird> well. i wrote hello world and factorial in the 5 step thing, but that was ages ago
14:18:06 <ehird> > mapM putStr (head (head (map tail [reverse(reverse["t","s"]:[foldr(++)['u'][['j']]:[]])])))
14:18:20 <thalassocrac> is there a haskell tutorial that really emphasizes syntax?
14:18:46 <dons> hmm. good question!
14:18:55 <dons> we need a syntax guide.
14:18:59 <nmessenger> not really a tutorial, but there is the syntax overview
14:19:03 * nmessenger looks
14:19:33 <nmessenger> @google overview of the haskell syntax
14:19:35 <lambdabot> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
14:19:35 <lambdabot> Title: Tour of the Haskell Syntax
14:21:06 <nmessenger> you just have to get used to which parts are expressions, declarations, types, and patterns, and the various type decl syntaxes
14:21:18 <thalassocrac> thanks
14:21:46 <nmessenger> I find the expression syntax, with the unification of operators and ordinary functions really great.
14:22:27 <quicksilver> thalassocrac: the most important thing to remember is that function application is the highest priority
14:22:32 <quicksilver> thalassocrac: and it runs from left to right
14:22:45 <quicksilver> that's what catches most people out
14:22:48 <nmessenger> f 1 + 2 is parsed: (f 1) + 2
14:22:58 <quicksilver> as in: print sum [1,2,3,4]
14:23:06 <ehird> ok, haskell is infinitely cool, and i can't even do it for useful things yet
14:23:14 <quicksilver> that means print has two parameters, sum and [1,2,3,4] probably not what you expect
14:23:14 <encryptio> mauke: only if f takes one argument
14:23:26 <encryptio> *nmessenger
14:23:29 <quicksilver> encryptio: wrong
14:23:33 <nmessenger> nope.
14:23:39 <quicksilver> encryptio: nothing in the parser ever checks how many arguments things take
14:23:53 <quicksilver> only the type-checker checks that (which is later)
14:23:54 <encryptio> bah.
14:24:20 <ehird> > length (filter Char.isLower "aBCde")
14:24:21 <lambdabot>  3
14:24:23 <nmessenger> f 1 (+) 2 -- here, f takes three arguments
14:24:25 <ehird> Are you happy now, tutorial?
14:25:16 <ehird> ``Write a function'' <-- The tutorial is apparently unaware that it hasn't told me how to make functions yet... good job i already know
14:25:31 <nmessenger> yeah, someone else mentioned that
14:26:10 <nmessenger> perhaps it should be written "write an expression of (sample input) that finds (expected output)"
14:26:24 <ehird> let firstSecond l = fst (head (tail l))
14:26:29 <ehird> yay.
14:26:46 <ehird> i have this strange feeling that it's running a lisp interpreter in he background.
14:26:49 <ehird> *the
14:27:08 <nmessenger> so that'd be a ([(a,b)] -> a)
14:27:23 <nmessenger> head . tail is also (!! 1)
14:27:52 <Cale> > let ones = 1 : ones in head ones
14:27:53 <lambdabot>  1
14:27:58 <ehird> We already saw in the sections Ghc and Nhc how to write a Hello World program and how to compile it. <-- No you didn't
14:28:01 <ehird> nmessenger: bleh
14:28:18 <nmessenger> > (head . tail) [1,2,3]
14:28:20 <lambdabot>  2
14:28:23 <nmessenger> > [1,2,3] !! 1
14:28:25 <lambdabot>  2
14:28:26 <ehird> module Test
14:28:26 <ehird>     where <-- What does where do?
14:28:37 <psi> ehird: function composition is cool: fst . head . tail
14:28:39 <nmessenger> introduces all the names defined in the module
14:28:46 <ehird> psi: okay, you win
14:28:52 <ehird> i bow down
14:29:04 <ehird> wouldn't that be fst . !! 1 though?
14:29:12 <nmessenger> fst . (!! 1) actually
14:29:13 <Cale> fst . (!! 1)
14:29:30 <ehird> Yep, that works
14:29:32 <ehird> Nice syntax.
14:29:56 <nmessenger> "get the 1th (i.e. second) element, then get its fst"
14:30:28 <ehird> !! 0 (. !! 1) <-- ?
14:30:34 <nmessenger> I'm never sure what ordinal numbers to use in a 0-based context
14:31:14 <nmessenger> ehird: doesn't parse my mental parser
14:31:28 <ehird> it looks cool though.
14:31:29 <ehird> :P
14:31:59 <Saizan> TH can transform only Quasi-Quoted code, right?
14:32:00 <nmessenger> you can paren-wrap an operator to make it an ordinary prefix function: 1 + 2 = (+) 1 2
14:32:21 <ehird> textmate doesn't have a very good haskell mode?
14:32:28 <ehird> s/?/://
14:32:38 <ehird> barely any highlighting and no auto-indent
14:33:03 <oklopol> If none of the guards succeeds a program is raised an evaluation stops.
14:33:10 <oklopol> what does this mean? :D
14:33:16 <ehird> As you might have expected, functions are central to Haskell, as it is a functional language. <-- No, really?
14:33:17 <bd_> should that be exception?
14:33:19 <bd_> shouldn't*
14:33:30 <oklopol> and 'and' i'd say
14:33:38 <oklopol> instead of an
14:33:56 <nmessenger> ehird: :P
14:34:08 <ehird> hm, does pattern matching support conditionals?
14:34:13 <ehird> like myfunc (< 1)
14:34:18 <ehird> for myfunc <anything below 1>
14:34:19 <nmessenger> > let f 1 = "one"; f 2 = "two" in f 5
14:34:21 <lambdabot>   Non-exhaustive patterns in function f
14:34:33 <nmessenger> ^^ that's what its talking about
14:34:41 <sjanssen> ehird: you use guards to do that
14:34:45 <encryptio> [0,5..100] confuses me
14:34:52 <ehird> sjanssen: blank newbie stare
14:34:57 <sjanssen> myfunc x | x < 1 = dostuffwithxhere
14:35:12 <nmessenger> myfunc of x such that x is less than one equals ...
14:35:13 <sjanssen> you can read the | character as "such that"
14:35:48 <nmessenger> encryptio: that gets translated to enumFromThenTo, you could check the docs
14:35:57 <nmessenger> > enumFromThenTo 0 5 100
14:35:59 <lambdabot>  [0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
14:36:01 <ehird> @paste
14:36:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:36:22 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/593
14:36:29 <ehird> i su re hope that does what i expect :P
14:36:37 <ehird> nope
14:36:39 <ehird> doesn't.
14:36:41 <glguy> ugh, people that don't put titles annoy me
14:36:45 <nmessenger> it does, but you don't need the lets
14:36:51 <ehird> in ghci, i do :)
14:37:16 <nmessenger> in ghci, to define a multiple-case function, seperate the cases with ';'
14:37:24 <sjanssen> ehird: when you use let, you're introducing a new binding that shadows the old one
14:38:03 <sjanssen> ehird: you may find it more useful to write your definitions in a file, and load them from ghci
14:38:31 <hpaste>  nmessenger annotated "multiple cases in ghci" with "multiple cases in ghci" at http://hpaste.org/593#a0
14:38:34 <encryptio> and then use :reload (or equivalently :r or : ) to update after editing it
14:38:43 <sjanssen> glguy: then don't allow pastes without titles -- YOU HAVE THE POWAH!
14:38:49 <nmessenger> eh?
14:39:04 <psi> ehird: i think most people use emacs for haskell coding.
14:39:09 <encryptio> i use vim!
14:39:22 <glguy> sjanssen: I don't want people to write garbage in those fields either
14:39:23 <nmessenger> I use <random Windows freeware text editor>!
14:39:49 <glguy> sjanssen: which is what *I* do on forms that require information I don't want ot provide
14:40:16 <glguy> so rather than have a bunch of garbage, they show up really easily to be deleted
14:40:28 <ehird> psi: let's not start that flamewar (which i am on an opposite side on, i think you should know - no, er, that's not a flamethrower i'm holding, really)
14:40:39 <nmessenger> glguy: I like that when you delete the paste before I finish annotating it, it gives the above message.
14:40:48 <hpaste>  fasta pasted "more ambiguous types?" at http://hpaste.org/594
14:41:10 <glguy> nmessenger: That's a known behavior, and I like being able to paste to deleted things
14:41:19 <glguy> so I didn't change it :)
14:41:21 <ehird> Suppose we wanted to define a function that had a value of 1 if its argument were 0; a value of 5 if its argument were 1; a value of 2 if its argument were 2; and a value of - 1 in all other instances <-- You're lagging behind, tutorial
14:41:46 <fasta> I really don't get why sometimes the type gets inferenced, and sometimes it doesn't. In this case, clearly the compiler knows at some point the type.
14:42:25 <sjanssen> fasta: the difference isn't the "let"
14:42:36 <sjanssen> fasta: in your first sample, you don't use show at all
14:42:48 <fasta> sjanssen: true
14:42:52 <nmessenger> fasta: perhaps the ghci toplevel is adding more defaulting?
14:42:57 <fasta> sjanssen: but when I evaluate it ghci is
14:43:08 <ehird> ok, textmate REALLY sucks for haskell
14:43:13 <ehird> barely 3 characters are highlighted
14:43:27 <fasta> sjanssen: to me it appears that ghci is acting deliberately stupid when in non-interactive mode
14:43:58 <fasta> nmessenger: perhaps, but it appears to me like it's always doing the right thing
14:44:05 <sjanssen> fasta: ghci has extended defaulting, so that is what is happening when you use the first version from a ghci prompt
14:44:18 <david_> psi : I use kate ( kde's editor )
14:44:19 <fasta> sjanssen: Can I get extended defaulting also in some other way>
14:44:21 <fasta> ?
14:44:38 <sjanssen> fasta: I think there might be a flag -- but it's a bad idea in the long run
14:44:52 <sjanssen> fasta: just give an extra type signature
14:44:53 <ehird> david_: kate is nice, but uhhh, not on OS X
14:45:08 <fasta> sjanssen: ok, so I should just see what ghci inferences and annotate it? Yep, that's what I figured
14:45:40 <mbishop> ehird: use the Xcode plugin?
14:45:40 <fasta> sjanssen: Do you have insights on why it wouldn't work in general?
14:45:53 <sjanssen> fasta: do you see why your second example really is ambiguous?
14:45:54 <ehird> mbishop: xcode is generally inferior to textmate...
14:46:13 <psi> ehird: improve the textmate bundle!
14:46:17 <fasta> no, imho, it isn't.
14:46:32 <ehird> psi: i would, if i knew haskell yet
14:46:38 <fasta> sjanssen: maybe I do
14:46:56 <fasta> sjanssen: no, it isn't ambiguous
14:47:07 <sjanssen> fasta: it's the fact that you call "show x", where x isn't monomorphic
14:47:11 <sjanssen> fasta: yes, it is
14:47:17 <fasta> sjanssen: the makeStructureOfSomeType makes a value of a specific type
14:47:25 <mbishop> Well isn't there also uh, aquamacs?
14:47:28 <fasta> sjanssen: (you are probably right, but I am just saying what I think)
14:47:43 <fasta> sjanssen: this specific type has an instance for show
14:47:43 <sjanssen> fasta: what is the type of foobar?
14:47:56 <psi> i prefer carbon emacs on os x.
14:48:00 <fasta> sjanssen: the type of foobar is f a b -> f a' b
14:48:17 <fasta> sjanssen: the a' is "unknown".
14:48:20 <ehird> mbishop: i think i already specified my emacs opinion ;) (that is, can't get past page 3 of tutorial)... i'll probably use vim or something for now
14:48:21 <sjanssen> fasta: that's where it becomes ambiguous
14:48:31 <fasta> sjanssen: but it's the same g
14:48:44 <glguy> I used to use Vim and I still use it remotely
14:48:52 <glguy> but recently i've been using emacs for local devleopment
14:48:55 <glguy> development*
14:48:59 <fasta> sjanssen: Can I tell the compiler that whenever something with g needs to be shown, that it should just select that instance?
14:49:09 <fasta> sjanssen: without annotating all the time?
14:49:21 <sjanssen> fasta: I have no idea what 'g' is -- this is the first time you've mentioned it
14:49:29 <fasta> sjanssen: right, "f"
14:50:37 <ehird> > head (head [tail ([]:[head [head [head [head [head ['a']]]]]]:[])])
14:50:39 <lambdabot>  "a"
14:50:57 <fasta> More formally forall types f <whatever> <whatever> show should call the instance defined for type f
14:51:06 <Saizan> well in your istance for f you probably use some instance for a', and if it's not specified..
14:51:17 <sjanssen> fasta: you could introduce "myshow :: f () b -> String; myshow x = show x", or something
14:52:31 <sjanssen> what is the significance of the first type parameter, anyway?
14:52:49 <sjanssen> if you've got functions that freely change it
14:53:14 <fasta> sjanssen: any idea how to get rid of it then?
14:53:21 <fasta> sjanssen: I need to return it in some class methods
14:53:49 <fasta> sjanssen: I need to return a value of both of these types in some class methods.
14:53:59 <sjanssen> oh, so is f like Either?
14:54:13 <fasta> sjanssen: in that way, it's similar
14:54:19 <sjanssen> or something like (Maybe a, Maybe b)
14:54:32 <mbishop> ehird: there's an emacs tutorial? all you need to know is C-x C-f to open/create a file, and C-x C-s to save
14:54:49 <sjanssen> is there a good reason for foobar :: F a b -> F a' b instead of F a b -> F a b?
14:54:54 <ehird> that'd make me even less efficient than i am now, mbishop
14:55:07 <fasta> sjanssen: yes, the point of that function is that the type can change.
14:55:25 <mbishop> ehird: really? thought you couldn't find a good editor to use? :P
14:55:30 <fasta> sjanssen: it's needed to implement some operations that otherwise are impossible to implement efficiently
14:55:42 <bos> @pl \f sock -> recvContents sock >>= send sock . f
14:55:43 <lambdabot> liftM2 (>>=) recvContents . flip ((.) . send)
14:55:53 <bos> ew.
14:56:28 <ehird> Does vim have haskell-layout-knowledge?
14:56:41 <fasta> ehird: there's some block "mode"
14:56:47 <fasta> ehird: but not in vanilla vim
14:56:58 * fasta uses Emacs
14:57:08 <ehird> if anyone has a link it'd be appreciated :P
14:57:57 <encryptio> ehird: i use vim with auto-indenting - it's not smart to any specific language, but it's still useful
14:58:33 <sjanssen> ehird: basically the most useful thing that vim can do is carry indentation depth to the next line
14:58:42 <ehird> yeah, shame
14:58:55 <mbishop> emacs \o/
14:59:07 <fasta> sjanssen: I think the problem is that the a' in the type is unknown results in the problem that ghc cannot prove that the resulting type is also showable.
14:59:18 <fasta> sjanssen: You probably meant this.
14:59:24 * ehird continues learning tomorrow
14:59:32 <ehird> and hopes people will stop reccomending emacs
14:59:46 <encryptio> heh
15:00:02 <fasta> Emacs, VIM what's the difference?
15:00:03 <sieni> (sucks-p 'emacs) -> t
15:00:29 <sieni> viper-mode is pretty usable, but buggy like the rest of emacs
15:00:43 <fasta> Debugger entered--Lisp error: (void-function sucks-p)
15:00:43 <fasta>   (sucks-p (quote emacs))
15:00:43 <fasta>   eval((sucks-p (quote emacs)))
15:00:43 <fasta>   eval-last-sexp-1(nil)
15:00:43 <fasta>   eval-last-sexp(nil)
15:00:43 <fasta>   call-interactively(eval-last-sexp)
15:00:51 <beschmi> would be nice to have some haskell code that handles indentation (that could be used with emacs and vim)
15:00:56 <fasta> You made a mistake :P
15:01:35 <fasta> sjanssen: Does that sound right?
15:01:38 <malsyned> is anybody in here using Ubuntu Feisty betas?
15:02:34 <fasta> sieni: What is buggy in the rest of Emacs?
15:03:43 <sieni> bad understanding of context for example
15:04:15 <lacrimosa> :-)
15:04:24 <fasta> sieni: where is that defined as a feature?
15:04:32 <sieni> the minibuffer isn't window/frame-specific, so you can't do something else in another window/frame in the middle of an incremental search
15:05:00 <sieni> it's bad and crappy and extremely annoying behaviour
15:05:52 <fasta> sieni: First time I hear it.
15:05:58 <sieni> I want to have lots of buffers open and do stuff in another window and frame and expect that the state of things stays the same in the other buffer/frame
15:06:03 <fasta> sieni: doesn't seem like something that cannot be "fixed"
15:06:39 <fasta> I often have >15 buffers open, seems to work well.
15:07:16 <fasta> No software is perfect, but I don't think it's a bug.
15:07:28 <fasta> You could report it and see what they think.
15:07:42 <fasta> I can imagine that even if you wrote a patch, they wouldn't accept.
15:08:02 <sieni> it has been like that as long as I've been using emacs, which must be something like 13 years
15:08:15 <sieni> well, anyway, open two frames
15:08:18 <jfoutz> i was a fairly hardcore vim user, i switched to emacs, because i think it's better to customze your editor in elisp than in c. they are both broken, but they are both less broken than any alternative i've played with
15:08:22 <xic> is shim good?
15:08:23 <sieni> with the same file open
15:08:35 <sieni> then move to another position in one frame
15:08:42 <sieni> it seems to understand that
15:08:51 <hpaste>  bluestorm pasted "(no title)" at http://hpaste.org/595
15:09:07 <sieni> then if you switch to another buffer in one of the frames and back then it grabs the cursor position of the other frame
15:09:24 <sieni> -> extreme suckiness
15:09:27 <lacrimosa> just how scalable Haskell can be on SMP systems ?
15:09:46 <sieni> lacrimosa: quite well as I understand it
15:10:04 <lacrimosa> i know im pretty cheap but..do you have any experience with that kind if apps written in Haskell ?
15:10:15 <sieni> lacrimosa: at least ghci
15:10:23 <beschmi> xic: shouldn't be that hard to install if you already use emacs. just try it ;)
15:10:33 <xic> actually i use vim
15:10:45 <xic> beschmi: are you the shim developer?
15:11:01 <beschmi> yep
15:11:02 <lacrimosa> sieni:  but thats an interpreter
15:11:12 <sieni> lacrimosa: sorry ghc
15:11:13 <emu> sieni: you can have multiple minibuffers: (setq enable-recursive-minibuffers t) in your ~/.emacs
15:11:27 <emu> sieni: it's just disabled by default because its considered confusing
15:11:34 <fasta> sieni: I see what you mean.
15:11:36 <xic> beschmi: cool.... you use ghc-api?
15:11:42 <fasta> sieni: (the frames thing)
15:11:56 <fasta> sieni: I only never use frames. What do you use them for?
15:11:59 <beschmi> xic: yes, i reuse some code from visual-haskell
15:12:08 <sieni> fasta: Well the same applies to windows
15:12:16 <xic> beschmi: interesting... have you heard of hIDE?
15:12:28 <sieni> I have Alt-Tab and Alt-Shift-Tab to rotate through buffers in current window
15:12:53 <beschmi> xic: yeah, seems pretty dead unfortunately
15:13:08 <xic> beschmi: have you thought about reviving it yourself?
15:13:29 <fasta> sieni: I can't open the same file twice in Emacs, it just points to the buffer where you already was.
15:13:31 <sieni> fasta: Well, I tend to have 2 or 3 80 column full height emacs windows side-by-side
15:13:45 <jfoutz> how did yi end up? wasnt that one of the first modular haskell tests?
15:13:55 <jfoutz> sort of a vi knockoff?
15:14:10 <emu> jfoutz: an example of hs-plugins in action
15:14:11 <fasta> sieni: I am not sure how to produce the behaviour you mean.
15:14:16 <psi> what's shim?
15:14:32 <fasta> shim is vaporware, IIRC
15:14:37 <sieni> fasta: yes, but you can have emacs to have the cursor to point to different points in the same file as long as the buffers stay visible
15:14:38 <emu> @where shim
15:14:39 <lambdabot> http://shim.haskellco.de/trac/shim
15:14:42 <emu> not quite
15:14:46 <fasta> It's "under development"
15:15:01 <beschmi> xic: i would extend yi rather than reviving hide
15:15:01 <emu> but since beschmi is here, now i can bug him about my install not working ;)
15:15:17 <jfoutz> @where yi
15:15:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
15:15:27 <xic> beschmi: hm... if i want to learn ghc-api, should i look at visual-haskell code or shim code?
15:15:58 <emu> hmm.. this time its working
15:16:02 <beschmi> fasta: i use it everyday, but i agree that there is no release yet and there might be problems if you use another OS/another emacs version etc
15:16:24 <emu> ah wait nvm
15:16:28 <fasta> beschmi: ok, well, if you are using it, it probably has some value. Interesting.
15:16:44 <beschmi> fasta: but i would  be happy to look at all bug reports
15:17:04 <emu> it's weird, because i know i loaded the slim.el file, but: Symbol's function definition is void: shim-buffer-filename-maybe-translated
15:17:29 <beschmi> i just pushed a patch for that 4 hours ago
15:17:30 <emu> oh, its addressed in the patch
15:17:32 <emu> i see
15:17:43 <kc5tja> Yi definitely looks interesting.
15:18:11 <fasta> beschmi: your server seems to be crawling
15:18:39 <beschmi> xic: you can also look at InteractiveUI.hs in ghc since ghci uses ghc-api
15:18:58 * ddarius is glad he wrote StackOverflow.
15:19:13 <fasta> I think I also understand how the type defaulting might work.
15:19:15 <xic> beschmi: hm... interesting.... do you think that you could do syntax highlighting using ghc-api?
15:19:51 <beschmi> fasta: yeah, i should move it. it's a virtual-server and my stuff gets swapped out all the time
15:20:06 <emu> beschmi: i had to change another typo
15:20:16 <fasta> beschmi: darcs.haskell.org would be a sensible location.
15:20:21 <emu> line 877
15:20:50 <fasta> "The server at shim.haskellco.de is taking too long to respond."
15:21:06 <lacrimosa> some people say Haskell is far beyond Erlang in terms of scalability and performance...is that true ? what do you think?
15:21:24 <beschmi> emu: i shouldn't have pushed that translate-file-name stuff without a lot more testing. it was pretty late ;)
15:21:28 <fasta> lacrimosa: ask those people
15:21:40 <emu> but now it works stellar
15:21:54 <lacrimosa> fasta: well i ask you
15:22:18 <kc5tja> I was just at shim.haskellco.de, and it was responding quite fast for me.
15:22:30 <beschmi> xic: there is a stripped down lexer in vshaskell for syntax highlighting and sorear uses a haskell lexer for syntax highlighting in yi
15:22:49 <beschmi> fasta: the website or darcs get?
15:22:59 <fasta> lacrimosa: I mean the website
15:23:04 <fasta> beschmi: that was for you
15:23:19 <xic> beschmi: but doesn't ghc-api include the ghc parser? couldn't you use that if you wanted to?
15:23:28 <emu> beschmi: you might want to use C-u C-c C-t for shim-insert-type; that's what stephen advised me when i wrote a similar function for inferior-haskell-mode
15:25:10 <emu> there is no shim-repl-mode yet, right?
15:25:44 <beschmi> xic: normally, you just use a lexer for synhl. so you could also use the standard lexer
15:26:00 <xic> beschmi: what is the standard lexer?
15:26:09 <sorear> hello
15:26:12 <sorear> what's this about synhl?
15:26:28 <beschmi> xic: better ask sorear about it. i'm not sure if he uses the default ghc lexer in yi
15:26:55 <beschmi> emu: no you have to use the one in haskell-mode for now
15:27:18 <sorear> I'm a tad interested in synhl tech.  someone wants to know about it?
15:27:54 <beschmi> <xic> beschmi: hm... interesting.... do you think that you could do syntax highlighting using ghc-api?
15:28:04 <sorear> we COULD
15:28:12 <sorear> but it would be very slow
15:28:18 <sorear> no slower than it is now
15:28:28 <sorear> but it would preclude further speedups
15:28:42 <sorear> currently yi uses non-incremental syntax highlighting
15:28:57 <sorear> the entire file is reparsed every time the screen is painted
15:29:12 <sorear> if you have a <3000GHz processor you should have noticed already
15:29:19 <sorear> we plan to fix this someday
15:29:36 <emu> one thing i investigated pulling out of GHC-API was how to obtain the type of arbitrary sub-expressions?
15:29:42 <sorear> but writing an incremental highlighter requires a lexer whose state is an instance of Eq
15:29:55 <sorear> most lexer combinator libraries use functional state
15:29:56 <emu> i couldn't figure it out though, it seemed that it only attached types to certain points
15:29:57 <dcoutts> sorear, no problem it's usually an Int
15:30:03 <xic> emu: that would seem like one of the really useful tools to have in your editor/IDE
15:30:04 <dcoutts> sorear, use Alex
15:30:17 <sorear> yi now uses a very very ugly hack, directly referencing alex internal symbols
15:30:29 <dcoutts> sorear, hIDE used a modified version of GHC's Alex lexer and that uses an Int state
15:30:29 <sorear> basically I rewrote the scanner loop
15:30:49 <emu> xic: i couldn't get any better information than what :type gives at the toplevel, however, so i ended up just doing that
15:31:14 <xic> emu: what exactly is your project?
15:31:20 <sorear> dcoutts: does hIDE handle string gaps properly?
15:31:28 <dcoutts> sorear, not sure.
15:31:30 <sorear> dcoutts: multiline comments?
15:31:41 <emu> xic: making haskell-mode better.  but shim is the way forward, imo, so i'm glad someone is working on it
15:31:45 <Lemmih> sorear: Yes, iirc.
15:31:52 <dcoutts> sorear, I assume so, it used the GHC lexer so I think it was basically perfect
15:32:09 <sorear> dcoutts: a line-at-a-time lexer like the vshaskell one is very hard to make work, and sucks when you fatfinger C-u 1000000 a
15:32:29 <beschmi> emu: vshaskell can search in the typechecked parsetree for source locations and look up the type
15:32:46 <sorear> I have made that slip on several occasions, and will not use an editor that consumes infinite time when I do.
15:32:53 <dcoutts> sorear, it did incremental lexing by remembering the lexer state at the beginning of each line. After a change it'd re-lex the current line and then if the lexer state for the following line had not changed then it could stop. Otherwise it'd carry on 'til it hits a line where the lexer state matches up or all the way to the end of the buffer.
15:33:13 <dcoutts> sorear, you could optimise that scheme and stop re-lexing at the end of the currently visible window
15:33:20 <sorear> dcoutts: That's exactly how old yi worked.
15:33:21 <beschmi> emu: of course it would be even nicer if you search for source span. eg. mark 'map (++ "aaa")' and look up this type
15:33:24 <emu> beschmi: yes, i was trying to figure out how to do that by examining GHC internals.  but i could not figure it out.
15:33:41 <dcoutts> sorear, so what's wrong with that?
15:33:45 <emu> it seemed that ghc was not attaching type information at every point
15:33:49 <dcoutts> sorear, why not do it that way?
15:34:10 <sorear> dcoutts: C-u 10000000 a
15:34:22 <dcoutts> sorear, what does that mean? I don't emacs.
15:34:31 <sorear> dcoutts: I don't like editors (I think I'm looking at vim) that crash that easily
15:34:40 <sorear> dcoutts: insert ten million 'a's
15:34:54 <sorear> 10000000aa<ESC>
15:35:09 <dcoutts> sorear, you mean re-lexing after inserting each 'a' is bad. Well sure. Don't do that then :-)
15:35:21 <dcoutts> sorear, re-lex after the end of a compound editor command.
15:35:48 <sorear> hmm. I hate to admit it, but that almost sounds good enough.
15:36:06 <sorear> dons: awake?
15:36:07 <beschmi> emu: have you taken a look at: http://darcsweb.haskellco.de/cgi-bin/darcsweb.cgi?r=shim;a=headblob;f=/Shim/ExprSearch.hs
15:36:09 <bringert> alexj: you around?
15:36:09 <lambdabot> Title: darcs - shim, http://tinyurl.com/2b6wf6
15:36:12 <SamB> what if I fatfinger on the mouse and paste in 10000000 as?
15:36:24 <SamB> ... on the terminal
15:36:26 <dcoutts> SamB, it'll go really slowly ;-)
15:36:49 <emu> ooh. interesting.
15:36:53 <sorear> you can abort tat :
15:37:00 <alexj> bringert: here
15:37:00 <sorear> +h +)
15:37:09 <alexj> bringert: sup?
15:37:11 <SamB> sorear: you can't abort pasting to terminals...
15:37:46 <emk> @tell syntaxfree More crazed abuse of probability monads: http://www.randomhacks.net/articles/2007/02/22/bayes-rule-and-drug-tests
15:37:47 <lambdabot> Consider it noted.
15:38:00 <dcoutts> SamB, what we did for hIDE was when we fork off the GHC front end to compile stuff, if the buffer got modified soon after then we'd kill that thread. Also we'd wait for a certain amount of inactivity before starting to compile, so you'd not get terrible performance when typing etc.
15:38:13 <sorear> SamB: Switch VTs and kill gpm?
15:38:17 <emu> i see that's what C-c C-t uses
15:38:26 <emu> very nice
15:38:29 <sorear> SamB: or are you saying the kernel has an infinite paste buffer?
15:38:30 <SamB> sorear: I don't think that would work too well in X
15:38:44 <sorear> <SamB> ... on the terminal
15:38:51 <SamB> yeah, it is an xterm
15:39:04 <sorear> doh, keep forgetting those exist
15:39:09 <SamB> heh
15:39:14 <SamB> that is my favorite kind
15:39:14 <dcoutts> SamB, you could do something similar for the lexing, basically you want the view to update no more often than say 30fps, so if you're pasting at an amazing rate then it's still not that bad.
15:39:16 <emu> i wish i had more time to play with this stuff
15:39:43 <dcoutts> SamB, having the view update asynchronously with respect to the model is the way to go there.
15:39:51 <SamB> dcoutts: that sounds about right...
15:39:53 <dcoutts> SamB, that's how all GUI toolkits work.
15:40:12 <dcoutts> SamB, widgetQueueRedraw
15:40:27 <dcoutts> and you can have many of those in sequence, it's not expensive
15:40:35 <dcoutts> the actual redraw comes round later
15:40:55 <dcoutts> and can be more expensive in calculating stuff since it can be rate limited
15:41:20 <kc5tja> sorear: What editor crashed after injecting 10000000 'a's?
15:41:30 <kc5tja> sorear: I've done worse with vim, and it has never crashed for me.
15:41:34 <SamB> kc5tja: crashed?
15:41:36 <SamB> not crashed
15:41:44 <SamB> just took forever to get to the end
15:41:45 <kc5tja> 15:33 < sorear> dcoutts: I don't like editors (I think I'm looking at vim) that crash that easily
15:41:49 <fasta> Anyone got a link to the Linux kernel overview image that was posted on reddit?
15:41:59 <SamB> ?????
15:42:00 <kc5tja> Well, yeah, that's to be expected.
15:42:24 <allbery_b> I recall him doing that to vin and then trying to jump from beginning to end of line and back and it was really slow and eventually blew up
15:42:28 <kc5tja> Any editor processing a 10MB file is going to take some time to get to the end fo the file.  :)
15:42:33 <allbery_b> nvi was happy the whole time :)
15:42:40 <SamB> kc5tja: O(n^2) sucks, though
15:42:59 <kc5tja> Was something like syntax highlighting turned on?
15:43:06 * kc5tja never uses syntax highlighting with vim.
15:43:12 <kc5tja> That's the #1 thing to get turned off.
15:43:13 <fasta> Nm
15:43:46 <kc5tja> The last time I pushed vim to its limits like that, it literally took about the same amount of time as it takes Emacs to start up on my box.
15:44:01 <kc5tja> So Emacs ain't no grand master editor either.  :)
15:44:18 <mauke> :syn enable!
15:44:48 <kc5tja> BTW, for those who are wondering, the #2 thing to be turned off is support for tabs.  :set expandtab!
15:45:22 <mauke> doesn't that toggle 'et?
15:45:45 <mightybyte> How would I define a datatype to be a fixed length array of integers?
15:45:48 * ddarius agrees with kc5tja on the latter and partially on the former.
15:46:25 <ddarius> mightybyte: data T = T Integer Integer Integer Integer ...
15:46:38 <ddarius> Or more likely just wrap an array as an abstract data type.
15:46:40 <emu> @where yi
15:46:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
15:46:59 <fasta> ddarius: I am sure GHC would love a data type definition with millions of elements.
15:47:08 <mightybyte> ddarius: Yeah, I wanted to use array, but I couldn't figure out the syntax
15:47:39 <fasta> mightybyte: there's no synta
15:47:42 <fasta> mightybyte: x
15:47:51 <mightybyte> data MyArr = listArray (0,8) (replicate 9 Int)
15:48:12 <fasta> mightybyte: this is not Java
15:48:28 <fasta> mightybyte: data defines an algebraic type.
15:48:35 <Lemmih> mightybyte: data MyArr = Array Int Int?
15:48:43 <sorear> listArray works on Values .  data need Types
15:48:52 <fasta> mightybyte: you are trying to assign a value to something that should declare something.
15:48:58 <Cale> data MyArr = MA (Array Int Int)
15:49:03 <sorear> dons: ping?
15:49:13 <mightybyte> Ok, I see that, but then how do I create a data structure to hold values?
15:49:19 <fasta> mightybyte: or type MA = Array Int Int
15:49:26 <fasta> mightybyte: you just use functions
15:49:32 <fasta> mightybyte: array in this case, for example
15:49:56 <Cale> myArray = listArray (0,8) (replicate 9 42)
15:50:18 <mightybyte> I want this type to be an array of a fixed size, "type MA = Array Int Int" doesn't do that.
15:50:21 <fasta> mightybyte: array (1,5) [(1,"Hi"),(2,"Something"),(3,"else")] (with an appropriate type)
15:50:30 <Lemmih> mightybyte: That's not possible.
15:50:34 <fasta> mightybyte: you can do that with type level arithmetic
15:50:37 <SamB> Lemmih: it is!
15:50:44 <SamB> it is just not very convenient!
15:50:46 <Cale> It's not practical :)
15:50:47 <Lemmih> SamB: My bad. That's not feasible.
15:50:56 <mightybyte> Ok, well how should I do it?
15:50:57 <fasta> mightybyte: something you are not ready for probably
15:51:13 <sorear> @localtime dons
15:51:16 <lambdabot> Local time for dons is Fri Feb 23 10:49:04 2007
15:51:18 <SamB> somebody did some binary arithmatic code at the type level...
15:51:22 <Cale> mightybyte: Just write functions to define the array which ensure that the bounds are correct.
15:51:36 <ddarius> mightybyte: Use newtype and a module to wrap a normal array and only expose a function that builds arrays of the length you want.
15:51:39 <fasta> mightybyte: in what language can you already do what you want?
15:51:47 <SamB> fasta: Pascal?
15:51:51 <mightybyte> fasta: Many
15:51:52 <fasta> SamB: right
15:52:00 <sorear> SamB: I did dependent arithmatic on the haskell type level.  <gloat gloat>  + is associative and commutative!
15:52:02 <Cale> mightybyte: If you want to use the typesystem to get some safety, you can do something like newtype Board = B (Array Integer Integer)
15:52:05 <mightybyte> fasta: Java, C, C++, etc
15:52:09 <fasta> mightybyte: it's not _that_ common.
15:52:25 <fasta> mightybyte: In Java? With generics?
15:52:27 <fasta> mightybyte: how?
15:52:27 <mauke> mightybyte: oh? I thought java arrays don't contain length information
15:52:29 <SamB> mightybyte: dude, C barely supports arrays *or* types
15:52:30 <Cale> and then create a module around that where the only exported mechanisms for creating Board values do the right thing
15:52:33 <mightybyte> So instead of types, I should use functions?
15:52:34 <SamB> nevermind array types
15:52:36 <fasta> mightybyte: In C you can't
15:52:51 <mauke> C does have array types
15:52:58 <Cale> mightybyte: Types are compile-time information
15:52:59 <fasta> mightybyte: In C++ you can, but with advanced hackery.
15:53:09 <mightybyte> fasta: What I want to do is make a Tic-Tac-Toe program.  I can easily do that in those languages.
15:53:17 <sorear> oh!
15:53:21 <fasta> mightybyte: We can do that easily in Haskell too.
15:53:21 <mauke> ahaha
15:53:25 <mightybyte> And I'm trying to figure out how I should do it in Haskell
15:53:31 <sorear> @google site:haskell.org tic tac toe chessguy
15:53:33 <lambdabot> No Result Found.
15:53:33 <xic> how can java arrays not contain length information? doesn't java detect array out of bounds accesses?
15:53:38 <sorear> @google site:haskell.org tictactoe chessguy
15:53:39 <lambdabot> No Result Found.
15:53:43 <sorear> @google site:haskell.org  chessguy
15:53:44 <Cale> xic: not at compile time
15:53:45 <lambdabot> No Result Found.
15:53:50 <mightybyte> I don't want one already written.  I want to write it so I can learn.
15:54:18 <Cale> arrays in Haskell contain bounds information at runtime, which is what Java does, I think.
15:54:37 <mightybyte> I thought the first logical step was to create a data type that I would use for a board.
15:54:42 <xic> ok i haven't been following the discussion i just saw that one remark pop out at me
15:54:44 <fasta> mightybyte: it is
15:55:01 <mightybyte> And that's where I'm stuck.
15:55:23 <mightybyte> Once I get the basics set up, I should be able to take it from there.
15:55:34 <dons> sorear: pong
15:56:13 <Cale> It sort of depends. For an application that small, it might be more convenient just to use something like Array (Int, Int) Piece directly.
15:56:20 <Cale> (perhaps with a type synonym)
15:56:29 <sorear> dons: john has pushed some patches that (judging from the names alone) may make haskell98 buildable, so a LOT more tests will run if you recompile now.  hopefully.
15:56:35 <Cale> and   data Piece = Empty | X | O
15:56:39 <bos> @hoogle isEOFError
15:56:39 <lambdabot> IO.isEOFError :: IOError -> Bool
15:56:39 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
15:56:40 <mightybyte> Cale: Ok
15:56:44 <xerox> <Interrupted by Cale>
15:56:51 <Cale> type Board = Array (Int, Int) Piece
15:57:02 <dons> sorear: yep. i spoke to him earlier
15:57:12 <xerox> Cale, let's code something together again sometime :-)
15:57:18 <Cale> xerox: yeah :)
15:57:36 <Cale> mightybyte: Note that the array is indexed by pairs of Int values.
15:57:47 <mightybyte> Cale: Ok, I see it now
15:57:50 <Cale> So you can refer to position (1,2), say
15:57:57 <mightybyte> Let me go see what I can do from here
15:58:08 <bos> jeepers, exception handling in haskell is complicated!
15:59:17 <xic> Cale: ok i've read up on the discussion
15:59:18 <bos> i want to catch only EOF errors, and my head is exploding.
15:59:32 <xic> C arrays have length information at compile time
15:59:33 <mightybyte> Cale: Ok, why do you use "data Piece", but "type Board"?
15:59:42 <mauke> bos: just learn Perl first :-)
15:59:54 <bos> i already knew perl exceptions :-)
16:00:02 <mauke> oh, then it should be easy
16:00:08 <xic> mightybyte: data is like struct. type is like typedef
16:00:27 <mightybyte> xic: Oh, got it.
16:00:36 <xerox> mightybyte: data defines a full-fledged new datatype, type defines a synonym for another type.
16:02:15 <bos> @pl \_ -> return []
16:02:16 <lambdabot> const (return [])
16:02:38 <sorear> dons: hm, read the logs from 12h ago.  looks like I missed my chance to relate my Big Idea :)
16:02:40 <emu> > filterM (const [True,False]) [1,2,3,4,5]
16:02:41 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,...
16:06:46 * sorear is now playing with jhci
16:07:35 <sorear> Now, at what value of 'N' will runjhc be faster than runghc? :P
16:08:20 <SamB> probably depends on what "N" is
16:08:42 <JohnnyL> hey there emu, which do you think is bettter lisp or haskell?
16:08:52 * sorear leaves quickly
16:09:04 <SamB> ... which lisp?
16:09:08 <SamB> for what?
16:09:15 <dons> JohnnyL: heh. that's like asking: what's better, haskell of 1979 (aka lisp), or haskell of 2007 ;)
16:09:29 <sorear> Haskell is probably better than ANSI Common Lisp.
16:09:55 <sorear> Not that I've used CL, but the fact that ANSI hasn't touched Haskell is a *very good sign*
16:10:00 <ddarius> dons: Well, Scheme circa '70s, CL circa '80s which is better...
16:10:20 <dons> ML circa 80s :-)
16:10:21 <JohnnyL> sorear, they probably can't figure out the extents of it just yet. lol
16:10:40 <sorear> Algol 68 was a great improvement on most of its successors, remember.
16:11:06 <sorear> I can't figure out how to get an answer for 2+2 from jhci :)
16:11:22 <mbishop> do languages that can be proved correct even really need an ANSI standard?
16:11:26 <ddarius> Well first you start with well-founded Set Theory...
16:11:28 <SamB> sorear: I'm sure ANSI would be happy to standardize Haskell if ISO did it first ;-P
16:11:45 <dcoutts> mbishop, sadly Haskell isn't in that class
16:11:47 <SamB> sorear: try "print (2+2)"
16:12:06 <sorear> SamB: already done it.
16:12:07 <SamB> yeah, Haskell needs some semantics, man
16:12:11 <SamB> sorear: and?
16:12:14 <ddarius> dcoutts: Nor any language as that sentence hardly makes sense.
16:12:18 <hpaste>  bos pasted "lazy bytestring read from a socket" at http://hpaste.org/596
16:12:19 <sorear> >print (2+2)
16:12:19 <sorear> Prelude.IO.print (2 Prelude.+ 2)
16:12:19 <sorear> Warning: defaulting:  t9 => Jhc.Basics.Integer
16:12:19 <sorear> :: Jhc.Prim.IO Jhc.Basics.()
16:12:22 <sorear> As@.10 :: Jhc.Basics.Integer
16:12:25 <sorear> As@.13 :: Jhc.Basics.Integer
16:12:28 <sorear> >
16:12:40 <bos> can someone tell me if the above looks sane?
16:12:44 <bos> seems to work OK.
16:12:57 <sorear> unsafeCoerce# can be sane ...
16:12:59 <bos> but the "is this an EOF error" check is yucky.
16:13:01 <dcoutts> ddarius, ok, but he probably means one where program transformations can be proved correct with respect to some formal semantics.
16:13:46 <sorear> bos: why do you need to limit the chunk size?
16:13:54 <dcoutts> bos, why can't you use a Handle and hGetContents ? that already does the chunking and the non-blocking.
16:13:56 <ddarius> dcoutts: Hopefully not as that is every language.
16:14:15 <dcoutts> ddarius, huh?
16:14:21 <sorear> bos: it won't decrease laziness - all real OS's early exit read when recieving a partial chunk.
16:14:30 <dibblego> :t forall
16:14:33 <lambdabot> Not in scope: `forall'
16:14:36 <dibblego> ?type forall
16:14:38 <sorear> bos: or better yet, Data.ByteString.Lazy.readFile
16:14:39 <lambdabot> Not in scope: `forall'
16:14:42 <dcoutts> ddarius, few languages have a formal semantics
16:14:46 <sorear> dibblego: it's not a type
16:14:52 <sorear> dibblego: it is special syntax
16:15:00 <dibblego> isn't it a function?
16:15:03 <bos> sorear: you have to give the read system call a number of bytes to receive.
16:15:13 <ddarius> dcoutts: Perhaps what you want him to have said is that there is a formal semantics to use to prove the correctness.
16:15:25 <sorear> bos: but why should it be a parameter?
16:15:26 <dibblego> I was expecting something like (a -> Bool) -> [a] -> Bool
16:15:33 <bos> dcoutts: afaict, going through a Handle involves an extra copy. and anyway, this has proven a good way to learn the FFI.
16:15:34 <sorear> dibblego: all
16:15:38 <dibblego> ah thanks
16:15:43 <SamB> bos: the read system call does not always read that many
16:16:01 <sorear> bos: just use a fixed 16384, that's what lazy bytestrings do
16:16:07 <bos> SamB: indeed, the documentation in the paste says as much.
16:16:09 <dcoutts> bos, I don't think there's any extra copy. For large reads when the Handle buffer is empty it doesn't go via the Handle buffer.
16:16:27 <bos> sorear: that's what the recvContents (with no N) does.
16:16:54 <dibblego> ?src all
16:16:55 <lambdabot> all p =  and . map p
16:17:27 <bos> dcoutts: fair enough. i just like going direct through the socket interface.
16:17:49 <sorear> bos: why do you need a parameter then?
16:17:51 <bos> i also have an action that uses writev(2) to send a lazy bytestring with a single system call.
16:17:51 <dcoutts> bos, well ok but you then have to re-implement the whole ByteString IO layer.
16:17:59 <bos> dcoutts: already done.
16:18:26 <edwardk> none of the random haskell database libraries have looked at MDX/OLAP stuff have they?
16:18:29 <LordBrain> i'm trying to mentally trace filterM (const [True,False]) [1,2,3,4,5] ...  it looks at 1 first i assume... applies that constfunction and based on the result,...
16:18:45 <sorear> gah!
16:18:55 <mauke> @src filterM
16:18:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:18:57 <SamB> bos: that sounds kind of... strict!
16:19:03 * sorear generally wouldn't bother trying to trace something like that.
16:19:03 <bos> sorear: why not have a parameter? there's a parameterless function in any case. the parameter is nice to have if you need it.
16:19:18 <sorear> bos: you'll never need it
16:19:19 <LordBrain> emu posted it
16:19:21 <bos> SamB: yes, it is strict. i have a lazy version, too.
16:19:28 <bos> sorear: shrug.
16:19:46 <sorear> bos: the parameterised version can be written in terms of the un-parameterised version
16:19:59 <LordBrain> intuitively i'm thinking its a powerset function...
16:20:13 <bos> sorear: indeed.
16:20:46 <LordBrain> hmm its in control.monad
16:21:18 <LordBrain> heres the source, http://darcs.haskell.org/ghc-6.6/packages/base/Control/Monad.hs
16:21:54 <LordBrain> very simple
16:22:53 <LordBrain> filter p (x:xs) = do { flg <- p x; ys <- filterM p xs; return (if flg then x:ys else ys); }
16:24:16 <LordBrain> hmm let me rewrite without do notation...
16:24:32 <SamB> @undo filter p (x:xs) = do { flg <- p x; ys <- filterM p xs; return (if flg then x:ys else ys); }
16:24:32 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 17}) "Parse error"
16:24:41 <SamB> @undo let filter p (x:xs) = do { flg <- p x; ys <- filterM p xs; return (if flg then x:ys else ys); } in filter
16:24:42 <lambdabot> let { filter p (x : xs) = p x >>= \ flg -> filterM p xs >>= \ ys -> return (if flg then x : ys else ys)} in filter
16:25:29 <LordBrain> what is @undo?
16:25:42 <sorear> @help undo
16:25:43 <lambdabot> undo <expr>
16:25:43 <lambdabot> Translate do notation to Monad operators.
16:25:47 <LordBrain> oh
16:26:18 <LordBrain> @undo filterM p (x:xs) =  do { flg <- p x; ys <- filterM p xs; return (if flg then x:ys else ys); }
16:26:19 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 18}) "Parse error"
16:26:55 <JohnnyL> @p [1,2,3,4,5,6,7]
16:26:56 <lambdabot> Maybe you meant: palomer part paste pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . v
16:27:04 <JohnnyL> no
16:27:05 <JohnnyL> ?
16:27:15 <JohnnyL> wow, bot is getting more ai as the months progress.
16:27:27 <Botje> @yow
16:27:28 <lambdabot> TONY RANDALL!  Is YOUR life a PATIO of FUN??
16:27:35 <JohnnyL> @yow
16:27:36 <lambdabot> Yow!  I threw up on my window!
16:27:55 <kc5tja> @help pl
16:27:55 <lambdabot> pointless <expr>. Play with pointfree code.
16:28:17 <zbrown> @poo?
16:28:18 <lambdabot> Unknown command, try @list
16:28:20 <zbrown> darn
16:28:21 <zbrown> @list
16:28:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:28:27 <resiak> @y
16:28:28 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . v
16:28:33 <Botje> O_O
16:28:39 <zbrown> @p
16:28:40 <lambdabot> Maybe you meant: palomer part paste pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . v
16:28:45 <LordBrain> @undo filterM p (x:xs) =  do { flg <- p x; ys <- filterM p xs; return (if flg then x:ys else ys); } in filterM
16:28:46 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 18}) "Parse error"
16:28:51 <zbrown> @yarr
16:28:51 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
16:28:57 <mauke> @yhjulwwiefzojcbxybbruweejw
16:28:58 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:29:00 <kc5tja> @help arr
16:29:00 <lambdabot> arr. Talk to a pirate
16:29:11 <sorear> @tell JohnMeacham_ jhc needs vastly more RAM now to load base ... 14s GC 6s MUT (with 350M compacting heap)
16:29:12 <lambdabot> Consider it noted.
16:29:15 <sorear> @v
16:29:16 <lambdabot> "\""
16:29:19 <kc5tja> @help yarr
16:29:19 <lambdabot> yarr. Talk to a pirate
16:29:27 <kc5tja> @help yhjulwwiefzojcbxybbruweejw
16:29:28 <lambdabot> V RETURNS!
16:29:35 <kc5tja> @help yow
16:29:36 <lambdabot> yow. The zippy man.
16:29:46 <kc5tja> Hah.  That's just too funny.  :)
16:30:28 <JohnnyL> @tell humasect hey bub, <bonks head with snicker> that's my brain!
16:30:29 <lambdabot> Consider it noted.
16:31:16 <sorear> @seen humasect
16:31:16 <lambdabot> I saw humasect leaving #haskell 2d 15h 32m 50s ago, and .
16:33:26 <LordBrain> > filterM (const [True,False]) [1,2,3,4,5]
16:33:27 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,...
16:33:31 <LordBrain> hmmm
16:33:36 <LordBrain> > filterM (const [True,False]) [1]
16:33:38 <lambdabot>  [[1],[]]
16:33:44 <LordBrain> > filterM (const [True,False]) [1,2]
16:33:46 <lambdabot>  [[1,2],[1],[2],[]]
16:34:12 <LordBrain> > filterM (const [True,False]) [1,2,3]
16:34:14 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:34:41 <LordBrain> when i try to trace it i find myself expecting the lists to show up in a different order
16:35:20 <LordBrain> i'm not stepping into the the recursion properly
16:36:07 <LordBrain> oh i see it now
16:36:45 <LordBrain> [2,3], [2],[3],[]   is the result of filterM applied to the tail of the list
16:37:13 <LordBrain> > filterM (const [True,False]) [2,3]
16:37:14 <lambdabot>  [[2,3],[2],[3],[]]
16:37:24 <bos> @pl \e -> if f e then Just e else Nothing
16:37:24 <lambdabot> flip (liftM2 if' f Just) Nothing
16:38:59 <LordBrain> now, for 1, you have first true, giving 1 appended to the front of that value, but thats multiple values via the listmonad, so its appended to each
16:39:25 <mightybyte> Can you put newline characters in Haskell strings, or do you have to get them via something like putStrLn?
16:39:26 <LordBrain> then false, you have the same result without 1 appended
16:39:38 <LordBrain> mightybyte, \n works
16:39:50 <mightybyte> Hmmm, didn't work for me
16:39:53 <LordBrain> not sure if that is standard actually might want to double check me
16:40:01 <ddarius> It is.
16:40:17 <ddarius> "foo\nbar"
16:40:22 <ddarius> > "foo\nbar"
16:40:23 <lambdabot>  "foo\nbar"
16:40:27 <LordBrain> mightybyte, whats your source?
16:40:28 <ddarius> Bah show.
16:40:34 <mightybyte> "hello" ++ "\n"
16:40:48 <LordBrain> i see no problem with that, but remember the precedence
16:41:02 <LordBrain> you might need ("hello" ++ "\n")
16:41:03 <mightybyte> > "hello" ++ "\n"
16:41:04 <lambdabot>  "hello\n"
16:41:08 <dibblego> > show $ "hello" ++ "\n" ++ "foo"
16:41:09 <lambdabot>  "\"hello\\nfoo\""
16:41:13 <LordBrain> depending on the context
16:41:15 <dibblego> oops
16:41:20 <mightybyte> > ("hello" ++ "\n")
16:41:21 <lambdabot>  "hello\n"
16:41:31 <LordBrain> or the $ like dibblego did
16:41:48 <mightybyte> > show $ ("hello" ++ "\n")
16:41:50 <lambdabot>  "\"hello\\n\""
16:42:34 <mightybyte> Or is ghci mangling it for me?
16:42:39 <LordBrain> its escaped because thats how strings are displayed in source
16:42:53 <LordBrain> and show is the inverse of read
16:43:53 <LordBrain> > filterM (const [True,False]) "abcde"
16:43:55 <lambdabot>  ["abcde","abcd","abce","abc","abde","abd","abe","ab","acde","acd","ace","ac"...
16:44:06 <LordBrain> > filterM (const [True,False]) "abcd"
16:44:08 <lambdabot>  ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","d...
16:44:29 <edwardk> > map reverse $ reverse $ filterM (const [True,False]) $ reverse [1..3]
16:44:31 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
16:44:35 <edwardk> =)
16:44:40 <LordBrain> :)
16:45:23 <LordBrain> maybe someone should put that one on that blow your mind page on the wiki
16:45:38 <edwardk> heh
16:45:47 <chessguy> ?remember Hudak It was actually Schonfinkel who first called attention to this idea [of currying], but the word "schonfinkelling" is rather a mouthful!
16:45:48 <lambdabot> Done.
16:46:06 <LordBrain> lol
16:46:22 <Cale> The only thing to fear is the fear of the fear of the fear of the fear of the fear of ...
16:46:40 <dibblego> Shoenfinkel
16:46:56 <sorear> Sho:nfinkel !
16:47:08 <chessguy> he has Schonfinkel with an umlaut, which i didn't feel like looking up
16:47:12 <LordBrain> The only thing to X is X itself, kind of reads like a tautology when you look at it that way :)
16:47:14 <sorear> er, Scho:nfinkel
16:47:22 <dibblego> chessguy, if you omit the umlaut, append an e
16:47:23 <mightybyte> Ok, ghci mangles the \n characters.
16:47:28 <mauke> Schoenfinkel
16:47:41 <chessguy> yes sir! sorry sir!
16:47:45 <chessguy> yeesh
16:47:47 <mightybyte> Running it from the command line works fine.
16:47:54 <dibblego> chessguy, only passing on what a German once told me :)
16:48:04 <ddarius> LordBrain: Not really.
16:48:06 * dibblego /nick messenger
16:48:19 <sorear> > map fromEnum "Ã‚Â¤"
16:48:20 <lambdabot>  [194,164]
16:48:43 * chessguy goes back to reading
16:49:16 <LordBrain> ddarius, you cant say Not really, because kind of is defined however i please, and i define it so that yes really.
16:49:22 <LordBrain> :)
16:49:39 <Boney> dibblego: is right.  about the umlouts and es
16:49:52 <sorear> what did I put between the quotes?
16:49:53 <sorear> I see a box :)
16:50:20 <chessguy> Boney, i never said he wasn't. thanks for condescending to impart your wisdom upon us though
16:50:38 <LordBrain> i see capital A with a carot on top, next to a little circle with 4 sticks protruding at the corners
16:50:43 <ddarius> LordBrain: Then surely I can say "Not really" as I can define "really", "Not" and "Not really" however I please.
16:50:51 <Boney> hey. just trying to help.  I'm not trying to undermine anyone.
16:51:01 <LordBrain> no, only "kind of" works that way.
16:51:02 <kc5tja> It looks like CTRL-A here then \u00a4
16:51:05 <LordBrain> sorry
16:51:52 <kc5tja> > map fromEnum "bork bork bork"
16:51:52 <LordBrain> because "kind of" means "in some sort of way as yet to be defined"
16:51:53 <lambdabot>  [98,111,114,107,32,98,111,114,107,32,98,111,114,107]
16:52:05 <|Lupin|> somebody here told he/she will join FOSDEM, IIRC: Who was it ?
16:52:07 <LordBrain> or unspecified
16:52:17 <ddarius> Not last I checked.
16:52:27 <LordBrain> when was that?
16:52:42 <ddarius> Last time I was a native English speaker.
16:52:44 <chessguy> whoah.
16:52:49 <chessguy> interesting statement:
16:53:03 <LordBrain> i'm a native american speaker
16:53:07 <chessguy> "Type classes often imply a set of laws that govern the use of the operators in the class."
16:53:26 <beschmi> |Lupin|: i think eric kowey and some other darcs people will be at fosdem
16:53:27 <|Lupin|> In the evening.
16:53:38 <chessguy> oh, never mind, he's talking about things like monad laws
16:53:43 <ddarius> LordBrain: As am I.
16:53:50 <|Lupin|> beschmi: Indeed. I go with kowey.
16:54:06 <sorear> eric kowey, eh? ;)
16:54:15 <siti> what Language is american :S
16:54:21 <SamB> en_US
16:54:29 <siti> yeah that's english :p
16:54:33 <sorear> major dialect of Engligh
16:54:34 <|Lupin|> eric kow, aka kowey
16:54:38 <SamB> no, its very clearly american
16:54:55 <beschmi> sorear: ah, i mixed it up ;)
16:55:12 <sorear> ... the British dialect of American ...
16:55:14 <kc5tja> siti: The English have bonnets and boots in their cars.  We have hoods and trunks.  :)
16:55:38 <kc5tja> Otherwise, not much difference between the dialects.  Just use of different words to mean the same things.
16:55:53 <ddarius> And the same words to mean different things.
16:55:57 <dibblego> or the same word...
16:55:58 <dibblego> you win
16:56:00 <kc5tja> ddarius: By definition.
16:56:25 <siti> yes, but us english is still english :p
16:56:49 <dibblego> does US English have the contractive form of "you are" to be "your" yet?
16:56:56 <sorear> @where nobench-results
16:56:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/results.html
16:57:04 <kc5tja> We use "you're" for that.
16:57:04 <sorear> dibblego: you're
16:57:11 <beschmi> sorear: what do you think is the better approach for providing ghc-api features to vim users? write a yi plugin and make them use yi or write a vim plugin?
16:57:12 <ddarius> dibblego: We're working on "ur"
16:57:13 <kc5tja> (it's pronounced "your" though)
16:57:16 <dibblego> yes, I'm talking about *US* English
16:57:50 <sorear> dibblego: I live in San Diego and have never left the country.
16:57:52 * kc5tja lives in California, so I qualify as a fluent US English speaker.  :)
16:57:52 <Boney> I'm a vim user.  what's ghc-api and why do I want it?
16:57:57 <siti> oh no, more people wrecking english if is wasn't already screwed enough :(
16:58:11 <MarcWebe2> beschmi: I don't know how long it will take to teach yi what vim actially is able to do... ;)
16:58:18 <kc5tja> There can be no wrecking a language designed by illiterates.
16:58:21 <dibblego> I figured it may have made it to a dictionary - perhaps not yet
16:58:22 <sorear> beschmi: I'm not a vim user ...
16:58:25 <SamB> kc5tja: hah
16:58:26 <LordBrain> maybe its easier to just port vim
16:58:34 <kc5tja> (literally; English evolved from the lower classes who couldn't read or write; Latin was the language of the literates)
16:58:34 <LordBrain> :)
16:58:40 <MarcWebe2> LordBrain: Port vim to haskell?
16:58:42 <LordBrain> if you want total completeness including scripts
16:58:43 <LordBrain> yeah
16:58:47 <siti> kc5tja: yes I know it's munted beginnings :(
16:58:50 <kc5tja> As a result, English is a very flexible language.
16:58:52 <MarcWebe2> LordBrain: Have you ever seen :h ?
16:58:55 <ddarius> kc5tja: And look at latin now
16:59:01 <beschmi> sorear: but a yi hacker
16:59:28 <beschmi> Boney: basically the things provided by visual-haskell
16:59:33 <sorear> beschmi: huh?
16:59:33 <LordBrain> MarcWebe2, the help system in vim? of course
16:59:33 <SamB> I think he maybe means that english will *bend* rather than breaking, if you try to break it
16:59:58 <kc5tja> beschmi: I was pondering the possibility of contributing to Yi too -- I'm not an Emacs user.  :)
16:59:59 <beschmi> Boney: http://www.haskell.org/~simonmar/papers/vshaskell.pdf
17:00:03 <dibblego> if google can make it to a dictionary, so can 'your' as the contraction for 'you are'
17:00:16 <LordBrain> if you are suggesting building the code from the help, that might actually be a better idea... at least its compliant with the docs then
17:00:27 <gvdm_other> true, ungrammatical sentences usually understood by everpeople
17:00:28 <ddarius> dibblego: As I said, we've been side-tracked by "ur"
17:00:29 <MarcWebe2> LordBrain: Then you know how much effort it would be to port vim to haskell ;) I would appreciate it, really... But I even can't dream of knowing all vim commands..
17:00:36 <gvdm_other> everypeople*
17:00:43 <glguy> ?get-shapr
17:00:43 <LordBrain> hmmmmmm
17:00:43 <lambdabot> shapr!!
17:00:53 <sorear> MarcWebe2: exactly.
17:01:06 <sorear> MarcWebe2: that's why we want a simple orthogonal editor.
17:01:21 <LordBrain> MarcWebe2, well, we could just port it peicemeal... converting more and more of the existing source modules to haskell
17:01:25 <kc5tja> dibblego: Indeed; as ddarius indicates, "your" has never been, nor will ever be, a contraction for "you are."  "Ur" is the preferred contraction now, due to the rise of popularity of SMS and AOL Instant Messenger.
17:01:44 <kc5tja> (actually, it's been in use long before that -- morse code telegraphers used it quite a bit too)
17:01:50 <sorear> MarcWebe2: yi is not a vi anymore, it is becoming an extensible editor
17:02:04 <sorear> MarcWebe2: ie a viper (also not --as=emacs)
17:02:13 <MarcWebe2> Yeah I know. I have to check it out again.
17:02:28 <beschmi> sorear: i was just bored of all the emacs/vi flamewars. so i wanted to start a yi/vim one ;)
17:02:28 <LordBrain> i added visual mode, but i never got around to visual line mode
17:02:48 <ddarius> sorear: Um... that's good.  It was never supposed to be a vi, it was supposed to be an extensible editor.
17:03:18 * kc5tja forks yi to create . . . Yip!
17:03:34 <kc5tja> j/k
17:04:00 * ddarius forks Yip to produce Yippie.
17:04:34 <MarcWebe2> We no longer need vi. perhaps we need something vim like ;) No more set nocompatible ;))
17:04:36 <allbery_b> so yip is the smp version? :)
17:04:59 <LordBrain> well.. i need vim like.... my fingers dont want to do anything else
17:05:46 <sorear> LordBrain: I made the switch months ago and don't regret it :)
17:05:52 <LordBrain> to what? emacs?
17:05:57 <LordBrain> or yi?
17:06:05 <sorear> emacs :(
17:06:07 <LordBrain> oh
17:06:22 <kc5tja> LordBrain: AGREED!  I tried so many times to learn Emacs -- I know it's a good editing environment, but ... my brain just refuses adamently.
17:06:35 <kc5tja> VI is just so ... *easy*.
17:07:00 <LordBrain> i am not sure why i would want to go to emacs
17:07:11 <kc5tja> I just like learning new things.
17:07:20 <kc5tja> I mean, I'm a *Forth* coder -- why would I ever want to learn Haskell?
17:07:21 <kc5tja> :)
17:07:21 <MarcWebe2> LordBrain: Because of the integrated debugger *lol*
17:07:29 <LordBrain> oh
17:07:32 <kc5tja> (Actually, doing so has, I believe, helped me code better Forth)
17:07:35 <mbishop> emacs is nice
17:07:46 <mbishop> I used to use it for practically everything
17:07:47 <kc5tja> And likewise, learning Forth will help others code things better in their preferred languages.
17:07:49 <sorear> MarcWebe2: GUD or the Lisp debugger?
17:07:53 <LordBrain> yeah, well i guess i'd prefer a vim-like ide for that
17:08:10 <chessguy> ?hoogle lift0
17:08:11 <lambdabot> No matches found
17:08:11 <LordBrain> i like moded editing
17:08:14 <mauke> emacs isn't beginner friendly
17:08:18 <dibblego> does 0.9 recurring equal 1?
17:08:22 <mauke> its suckage barrier is too high
17:08:23 <MarcWebe2> sorear gdb .. I would have to start emacs again.. Much time has passed..
17:08:24 <kc5tja> OK, I just identified one good reason to have an IRC client in an editor --- BACK SEARCH.  ;)
17:08:36 * sorear knows forgth.
17:08:38 <kc5tja> Someone asked about what "yip" would be different, but I can't find out who.
17:08:44 <LordBrain> vim is beginner friendly due to its docs and coming with a tutor and all, but vi in general isnt...
17:08:46 <kc5tja> s/what/how/
17:08:55 <mbishop> emacs was my irc client, my music player, my editor, my terminal, and my instant messenger...I still used firefox for web though heh
17:09:01 <ddarius> dibblego: It depends on how you define reals, but often yes.
17:09:04 <mbishop> dibblego: yes (but don't ask me to prove it)
17:09:32 <kc5tja> LordBrain: I personally disagree.  On the Amiga platform, I had used Micro-Emacs quite regularly.  Moving to Linux, I immediately found vim to be overwhelmingly easy, once you get used to insert vs command modes.
17:09:45 <sorear> emacs is my editor, my terminal, and my irc client... I still use elinks, mutt, ghci and Linux :(
17:09:56 <kc5tja> Mutt kicks butt.  :)
17:10:00 <kc5tja> //Fast//
17:10:11 <LordBrain> kc5tja, i said vim IS beginner friendly
17:10:16 <dons> its config language isn't so fun though
17:10:20 <dons> i'd like a haskell mutt ...
17:10:21 <mbishop> heh, don't they have elinks integration for emacs? thought they did...most people just use w3c I guess
17:10:22 <kc5tja> LordBrain: I never used the tutor though.
17:10:26 <LordBrain> oh
17:10:30 <kc5tja> LordBrain: Vim didn't have a tutor back then.  :)
17:10:31 <chessguy> dibblego, http://en.wikipedia.org/wiki/.999_%3D_1
17:10:39 <LordBrain> well when you open vim, it tells you imediately where to get help etc
17:10:51 <mbishop> er, w3m, whatever they called that browser
17:10:52 <MarcWebe2> LordBrain: It depends. When you have to learn about different quation types "\<bs>" stuff etc.. it can get quite complicated..
17:10:53 <siti> eclipse is my editor :D
17:10:56 <kc5tja> What makes vim (well, vi in particular) easy for me is the fact that I don't need to do Vulcan nerve pinch commands.
17:11:25 <LordBrain> when i first opened a vi, i couldnt put text in it, because i didnt know about insert mode, and i couldnt quit, because i didnt know :q or anything... i had to send a kill signal to the process
17:11:33 <kc5tja> But, after reading Jef Raskin's Humane Interface, I see the value of using CTRL-key combinations for everything.
17:11:35 <sorear> kc5tja: you realize you can load alternate keymaps for emacs? M-x viper-mode et al
17:11:38 <siti> modes = bad interface
17:11:42 <dons> sorear: so what should we hack on today?
17:11:48 <kc5tja> sorear: These things didn't exist back then.
17:11:57 <Pseudonym> LordBrain: Also true of me, only it was emacs.
17:12:00 <kapheine_> LordBrain: I had the same experience with Emacs the first time I loaded it :P
17:12:02 <kapheine_> hah
17:12:05 <Pseudonym> :-)
17:12:17 <Pseudonym> ^Zkill %1 is the quit sequence.
17:12:23 <kc5tja> What I'd like to do, strangely enough, is to introduce the foot-pedal to computing.
17:12:24 <sorear> I think I had that experience with yi.
17:12:24 <kapheine_> And probably vim too, to be fair.  But I don't remember my first time using vim.
17:12:29 <kc5tja> I say, have four foot-pedals.
17:12:33 <mbishop> kc5tja: already been done heh
17:12:39 <sorear> I am a vi user.
17:12:42 <kc5tja> One for SHIFT (so no need for CAPS-LOCK while still typing all caps)
17:12:43 <sorear> ((not regularly, but still)
17:12:43 <MarcWebe2> Anyway.. Do you think it would be possible to implement some kind of interface so that ghc-api can be used with yi, emacs or vim?
17:12:45 <kapheine_> kc5tja: thinkgeek has a USB footpedal.
17:12:46 <kc5tja> brb
17:12:48 <dibblego> ?undo do ct <- getClockTime; t <- toCalendarTime ct; print t
17:12:48 <lambdabot> getClockTime >>= \ ct -> toCalendarTime ct >>= \ t -> print t
17:12:50 <mbishop> some serious emacs users have foot pedals for Control
17:12:56 <LordBrain> i use vim seriously... every day
17:13:02 <bos31337> dons: what's a sensible way to decode two Binary values from a handle?
17:13:08 <LordBrain> and at work i have visual studio with a plugin to act like vim
17:13:18 <sorear> bos31337: liftM2 (,) get get
17:13:40 <beschmi> MarcWebe2: i think that should be possible if you have vim with +python
17:14:00 <MarcWebe2> LordBrain: If you reduce vim to its 3 modes.. But if you have written some plugins and mappings you'll miss vim then, too.
17:14:09 <mbishop> someone needs to write hamacs
17:14:18 <kscaldef_> all emacs users should own a Kinesis
17:14:19 <mbishop> there's already pymacs, and ermacs
17:14:22 <bos31337> sorear: so i need to actually run the Get monad and pull the residual ByteString out of it?
17:14:24 <sorear> mmbishyi --as=emacs
17:14:36 <bos31337> i.e. calling decode is the wrong thing to do.
17:14:39 <kscaldef_> and because of that, all vi users should stop complaining about vulcan nerve pinces
17:14:41 <mbishop> sorear: english?
17:14:54 <mbishop> and climacs
17:14:57 <sorear> mbishop: yi --as=emacs
17:15:07 <mbishop> sorear: oh heh
17:15:22 <sorear> mbishop: the error was your name failed to autocomplete and the error message ate ':' ' '
17:15:40 <beschmi> MarcWebe2: i'll try to hack up a proof-of-concept for lookup type or find-definition
17:15:42 <sorear> you have to type a line ahead when jhc is swpapping
17:16:05 <mbishop> Someone needs to make schemacs, and ocamacs, and uh...Ozmacs
17:16:06 <MarcWebe2> beschmi or perl or ruby or php or .. ;) php even can call .net stuff
17:16:07 <LordBrain> dons posted a script for vim to insert the generated types for you
17:16:10 <LordBrain> from ghci
17:16:24 <MarcWebe2> LordBrain: Where? I've heard of it but never seen
17:16:33 <LordBrain> i think its on his blog somewhere
17:16:53 <LordBrain> it uses a shell script
17:16:57 <LordBrain> to do it
17:17:05 <MarcWebe2> on glasgow-haskell-users someone told he has used a hugs command to show the type in status bar. But he considered it beeing annying so he switched it of again..
17:17:43 <dons> bos31337: encode them as a pair, and decode the pair back?
17:18:05 <bos31337> dons: that won't work; i'm trying to do this over a network connection.
17:18:06 <dons> bos31337: just the usual way, i.e. get = liftM2 (,) get get  -- ;)
17:18:16 <dons> ok. you chain together 'get' calls then.
17:18:20 <bos31337> ok.
17:18:52 <bos31337> thanks!
17:19:01 <dons> let me know if that works.
17:19:11 <dons> ?users
17:19:11 <lambdabot> Maximum users seen in #haskell: 328, currently: 303 (92.4%), active: 56 (18.5%)
17:19:22 <dons> hey .we equalled the all time high score today. nice.
17:19:29 <bos31337> will do. i'll have to put my Get monad inside an MVar. will take a few minutes to hack up.
17:20:41 <dons> inside an MVar eh?
17:20:52 <sorear> wow, john has slowed jhc down so much spectral/ansi (which worked yesterday with the 400s timeout) now fails with the 600s timeout
17:21:05 <sorear> @where nobench-results
17:21:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/results.html
17:21:14 <sorear> (on my computer)
17:22:12 <dons> ah. should i have a go now at getting the darcs head of jhc then?
17:22:58 <sorear> probably, it supports h98 now ...
17:23:43 <sorear> but it won't have an effect without the two-line makefile patch I just sent
17:23:58 <sorear> (which BTW will break every single test with ejthecnar)
17:24:13 <dons> ok.
17:24:40 <dons> btw, SimonM said that setting -h128M for ghc is probably going to slow things down. i notice pidigits runs 3-4x faster with the default heap size
17:24:46 <MarcWebe2> beschmi This find definition.. Should this be based on tags? will it find source of used packages?
17:25:37 <kc5tja> back
17:25:39 <kc5tja> Sorry
17:25:59 <sorear> dons: another idea ... how about making an option for "GHC-HEAD nightly build"?
17:25:59 <kc5tja> No, I wanted four footpedals.  One for SHIFT, one for CTRL, one for ALT, and one for general purpose program use.
17:26:06 <beschmi> MarcWebe2: only definitions in the current package
17:26:12 <dons> sorear: yeah, i ant to do that.
17:26:40 <kc5tja> That way, it's possible to have the "single-key" input facility that VI-users enjoy, while still having the "normal editor interface" that Emacs users expect.
17:26:48 <kc5tja> But, I'm beating a dead horse.  Sorry.
17:26:50 <kc5tja> :)
17:27:02 * sorear zaps a wand of undead turning
17:27:13 <beschmi> MarcWebe2: it has the disadvantage already listed in ml discussion for ghci :tag that your code has to compile and it's probably a bit slower than hasktags
17:27:37 <kapheine_> Eventually you'd look like one of those one-man-bands when you were coding.
17:27:46 <beschmi> MarcWebe2: but on the other hand, you don't have to recreate the tags file all the time
17:28:13 <sorear> IMO partial compilation, once achieved, will be far better than either :tags(currently) or hasktags
17:28:24 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1000
17:28:25 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
17:29:10 <kc5tja> kapheine_: A piano player can make excellent use of his foot-pedals.  Why not a coder?
17:29:14 <dons> try doing that ^^ in #ruby ;-)
17:29:36 <kscaldef_> kc5tja: http://www.kinesis-ergo.com/fs-savant-elite.htm
17:29:37 <lambdabot> Title: Kinesis Foot Switches
17:30:20 <LordBrain> is nhc still actively developed or is that action over with yhc now?
17:30:36 <kc5tja> kscaldef_: YIKES!  That's expensive!  But exactly what I'd be looking for.
17:31:16 <sorear> LordBrain:
17:31:20 <sorear> @where nofib-results
17:31:21 <lambdabot> I know nothing about nofib-results.
17:31:25 <sorear> @where nobench-results
17:31:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/results.html
17:31:39 <kscaldef_> kc5tja: you spend how much time typing?  How much does your chair cost?  Your monitor?
17:31:41 <sorear> LordBrain: ^^^ look, nhc98 is 20% faster at everything
17:31:58 <dons> LordBrain: nhc is still very active, yeah
17:32:16 <LordBrain> ok
17:32:25 <shapr> glguy: You called?
17:32:31 <kc5tja> kscaldef_: A lot of time, but I don't think I've spent more than $20 on a char.
17:32:32 <kc5tja> char
17:32:36 <kc5tja> chaIr.
17:32:59 <sorear> 'a' <- a char, absolutely free
17:33:09 <kscaldef_> well, okay... it's pretty normal for software shops to spend $500+ on a chair
17:33:17 <dons> hbc is the non-active project.
17:33:21 <ddarius> sorear: False.
17:33:30 <MarcWebe2> beschmi I'm using :inoremap <m-r><m-t> to recreate tags.. And I've tagged all libraries I'm using. So I won't benefit. ;(
17:33:39 <kscaldef_> but, for some reason a $300 keyboard seems extravagant
17:33:54 <dons> ?version
17:33:55 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
17:33:56 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:33:56 <sorear> ddarius: implicit coercions are for the language pedants :)
17:34:02 <dons> ah. i should update to get sjanssen's patches
17:34:12 <ddarius> dons: Completely now or is there still a reclusive bunch of hbc hackers.
17:34:30 <dons> completely, afaik.
17:34:31 <chessguy> ?seen dcoutts
17:34:31 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 1h 16m 39s ago.
17:34:37 <dons> though i'd be happy to maintain it if i can get the src
17:34:38 * ddarius was referring to, at the very least, the increased entropy of the universe.
17:34:40 <beschmi> MarcWebe2: cool, so you can jump eg to the definition of foldr?
17:34:52 <dons> i'll talk to lennart next time he appears
17:35:01 <xic> hey guys! anyone wanna test out my haskell chat webapp? it's running live now!
17:35:11 <dons> xic, url?!!
17:35:11 <ddarius> That was weird when I heard a new hbc had come out.
17:35:13 <sorear> how is it better than IRC? :)
17:35:22 <dons> ddarius: last time in 2004 , afaik
17:35:23 <xic> http://feld.sh.nu:2000
17:35:25 <dons> that's the src i have
17:35:27 <xic> sorear: it's powered by haskell!
17:35:41 <dons> xic, want to tell us about the implementation?
17:35:49 <dons> The following error was encountered:
17:35:49 <dons>     * Read Error
17:35:50 <dons> ?
17:36:01 <xic> dons: huh?
17:36:03 <dons>  (104) Connection reset by peer
17:36:11 <dons> url not working for me?
17:36:26 <xic> dons: go to that url in your web browser!
17:36:41 <dons> to http://feld.sh.nu:2000/ ?
17:36:56 <dons> that's what i'm doing, and i'm getting "  (104) Connection reset by peer"
17:37:15 <xic> dons: maybe you have a reverse firewall that is blocking port 2000?
17:37:17 <beschmi> xic: do you use a persistent http connection or just pull every x seconds?
17:37:20 <dons> ah hmm.
17:37:24 <xic> beschmi: persistent
17:37:25 <MarcWebe2> beschmi: Sure.
17:37:32 <kc5tja> kscaldef_: Oh, I'm sure.  The monitors and stuff that we have here are all pretty top-notch.  :)
17:37:48 <chessguy> @tell dcoutts you asked me to let you know how i did with using Graphics.SOE.Gtk for SOE stuff....it's not working. please ping me for details
17:37:48 <lambdabot> Consider it noted.
17:37:49 <kc5tja> ksandstr: But I'm talking about something that I can use at home.  :)\
17:37:57 <MarcWebe2> beschmi: Retagging a new lib is as easy as cd to lib $gvim  :TagCurrentDirectoryHaskell ;)
17:37:59 <dons> xic, i think its the proxy getting in the way
17:38:18 <dons> there we go. disabling the proxy worked.
17:38:27 <beschmi> MarcWebe2: and does it handle qualified names import Foo as Bar etc?
17:38:52 <dons> xic, could do with some pretty Text.XHtml layout :-)
17:39:17 <xic> dons: perhaps :)
17:39:20 <chessguy> could do with a lot of things :)
17:39:21 <MarcWebe2> beschmi No. It just searches all known libs and files.. But it works well when using tjump. I usually get a list of 7 item to choose from
17:39:36 <mbishop> that's pretty nice, I like how fast it updates, rather than the usual slow CGI:IRC stuff heh
17:40:17 <MarcWebe2> beschmi: I've tried implementing function completion based on imports and vimscript. But it is much to slow even with file caching.
17:42:01 <MarcWebe2> beschmi: I'd like to share if you're interested
17:42:21 <beschmi> MarcWebe2: yeah, i'd like to take a look
17:45:28 <chessguy> anybody seen this message when using gtk2hs before? Xlib: unexpected async reply (sequence 0x4f)!
17:46:17 <MarcWebe2> beschmi: Get http://www.mawercer.de/marcweber/vim/vimlib/repository/ and put it into ~/.vimlib
17:46:19 <lambdabot> Title: Index of /marcweber/vim/vimlib/repository
17:48:30 <beschmi> MarcWebe2: thanks, i'll try it out later
17:50:41 <MarcWebe2> beschmi: There are still some things to do (add this path to runtimepath, you need two extra files to get backgroundcompilation/ configuration on F2 F3 with cabal ...  features like tab-completion (eg i<tab> Data.List q<tab> are defined in my 'private' haskell vim file) .. So you need that too to benefit. Just write back.
17:57:54 <chessguy> ugh, how do i just make an executable from a .hs file? is it just ghc --make Foo.hs
17:58:06 <dons> ghc --make -O Foo.hs -o foo
17:58:17 <dons> how long have you been in #haskell ?? ;)
17:59:24 <chessguy> mm, maybe 6 or 8 months
18:01:02 <allbery_b> dons: you can do a heck of a lot with cabal and ghci :)
18:01:14 <allbery_b> and runghc :)
18:01:35 <chessguy> i still haven't quite figured out why i need to compile this stuff
18:01:44 <chessguy> but whatever
18:03:52 <dons> hehe. executables are good for you.
18:04:05 <chessguy> but i *like* REPL
18:04:19 <dons> sure. but the final product you want to sell, you compile, yeah?
18:04:28 <araujo> http://www.timestretch.com/FractalBenchmark.html
18:04:29 <lambdabot> Title: Ruby, Io, PHP, Python, Lua, Java, Haskell, and Plain C Fractal Benchmark
18:04:35 <chessguy> i don't think i'm going to be selling the examples i do out of SOE :)
18:04:37 <araujo> Haskell for scripting!
18:04:39 <araujo> hi all
18:04:57 <chessguy> araujo, :)
18:05:14 <araujo> :-)
18:05:25 <dons> araujo: that's a pretty naive mandelbrot too
18:05:47 <chessguy> dons, besides, didn't you read the xkcd the other day? commercialism only leads to violent bloodshed
18:06:01 <araujo> he explicitly states it isn't anything scientific
18:06:07 <chessguy> i don't want to sleep with a set of numchucks under my bed
18:07:10 <araujo> dons, i think that's the idea
18:07:24 * araujo *thinks*
18:08:40 <xic> chessguy: are you the one who was saying that you only got chat messages when you said something?
18:08:51 <chessguy> xic, yes
18:09:01 <chessguy> c'est moi
18:09:05 <dons> araujo: i just made it run 3x by changing one flag ;)
18:09:08 <xic> chessguy: are you using internet explorer by any chance?
18:09:10 <chessguy> no
18:09:14 <kscaldef_> Is there a better introduction to QuickCheck than http://haskell.org/haskellwiki/Introduction_to_QuickCheck
18:09:15 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki
18:09:23 <xic> chessguy: safari?
18:09:30 <chessguy> guess again
18:09:32 <araujo> dons, haha , interpreted?
18:09:49 <chessguy> firefox on fedora here
18:10:22 <xic> chessguy: hm......
18:10:41 <kscaldef_> like if I were an idiot and didn't know what coarbitrary was supposed to do, where could I learn that?
18:11:21 <dons> araujo: nope. compiled. 0.5s now
18:11:37 <dons> now down to 0.2s
18:11:45 <araujo> haha
18:11:54 <araujo> dons, -O ?
18:12:53 <dons> that and some other tricks
18:13:21 <araujo> hah
18:13:28 <lispy> kscaldef_: if you're an idiot, i'm a moron because i still don't get it even after trying to learn about it
18:13:30 <araujo> so it is doing better than plain C :)
18:13:35 <jicrayne_> why is the haskell implementation shootout called nobench?
18:14:51 <chessguy> :k Int
18:14:54 <lambdabot> *
18:14:57 <chessguy> :k Tree
18:15:00 <lambdabot> * -> *
18:16:10 <dons> jicrayne_: there's an old benchmark suite called 'nofib'
18:16:12 <allbery_b> jicrayne_: because it's based on nofib, the ghc testsuite
18:16:19 <allbery_b> oh, benchmark suite
18:16:20 <allbery_b> durr
18:18:19 <ddarius> Wouldn't "venerable" be a better word than "old"?
18:18:36 <araujo> hah
18:27:28 <dons> araujo: i sent off a 10x faster mandelbrot entry to the author of that page :-)
18:27:54 <kc5tja> Hey, I wonder if my 99 bottles of beer entry was accepted to the 99 bottles page.
18:27:59 <dons> should run around 0.3sec, by my numbers.
18:28:00 <araujo> dons, haha
18:28:04 * kc5tja wrote a nice, highly functional version of the program.
18:28:09 <araujo> dons, cool!
18:28:24 <kc5tja> And I verified it worked by running it on GHCi.  I was pleased with myself.  :D
18:28:29 <araujo> that beats the c version even
18:28:39 <dons> should be a little slower, i think.
18:28:54 <dons> the best way is to take the code from the shootout. that's pretty good.
18:29:05 <dons> but this is a nice balance between simplicity and speed
18:29:11 <araujo> yeah
18:29:39 <araujo> i like the way it is compared to the scripting languages
18:30:04 <dons> yeah, haskell's a nice scripting language.
18:30:31 <chessguy> yeah, haskell's a nice _ scripting language
18:30:36 <chessguy> err
18:30:38 <chessguy> _ language
18:30:43 <chessguy> bah, i screwed that up
18:31:41 <araujo> dons, haven't you done more work related to a possible haskell shell?
18:31:59 <dons> i worked on h4sh (which i use daily, btw)
18:32:24 <monochrom> Good evening haskellers
18:32:34 <monochrom> Good evening lambdabot
18:32:41 <iron32> Good evening Mono
18:32:43 <chessguy> @hi
18:32:52 <chessguy> hi monochrom
18:33:21 <xic> monochrom: hey, wanna see something cool?
18:35:22 <monochrom> chessguy: this is a late reply. I have found that the source tarball of hgl, i.e., http://haskell.org/graphics/downloading.html , is very old, incompatible with many things now. It cannot be built.
18:35:39 <monochrom> xic: what is cool?
18:36:05 <chessguy> monochrom, ok, thanks for checking it out
18:36:12 <xic> monochrom: a haskell chat webapp demo i've made... you can join us at
18:36:22 <xic> http://feld.sh.nu:2000/
18:36:24 <chessguy> monochrom, it turns out that gtk2hs has support for SOE built into it
18:37:07 <monochrom> The hgl source inside ghc-6.6's extralibs is very up-to-date. Though the "version" still says "3.00", very different content.
18:38:20 <monochrom> I can't read off any sign of SOE from the haddock on gth2hs's home page.
18:38:31 <araujo> dons, i ended up hacking a bit ghci adding some shell operators
18:40:28 <monochrom> Why is it called a haskell chat webapp? Code written in haskell?
18:40:41 <dons> http://programming.reddit.com/info/164fn/details
18:40:42 <lambdabot> Title: Practical Haskell: a filesystem tree printer (reddit.com)
18:40:44 <dons> monochrom: yep
18:40:47 <xic> monochrom: yes!
18:40:55 <dons> no. just for fun. its really in ruby
18:41:06 <monochrom> OK, at least the implementation is a kudo.
18:41:25 <xic> no, i'm writing a complete haskell webapp framework
18:41:36 <monochrom> I am usually not a big fan of "let's move all software to webapps".
18:41:37 <xic> monochrom: this is a chat example i got working
18:41:59 <xic> monochrom: please just check it out :)
18:42:12 <monochrom> I am "monomorph" there.
18:44:44 <monochrom> filesystem tree printer = visit directory tree recursively?
18:45:39 <dons> tree traversal and pretty printer
18:46:07 <dons> http://programming.reddit.com/info/164gm/details
18:46:08 <lambdabot> Title: Using Bayesian filtering instead of "if" in Haskell (reddit.com)
18:46:11 <dons> another nice article ^^
18:48:35 <rahikkala> "Monads are Functors, no matter what Haskell thinks." ;)
18:49:39 <bd_> {-# OPTIONS -fallow-undecidable-instances #-} instance Monad m => Functor m where fmap = liftM :)
19:01:39 <emk> MarcWebe2
19:04:54 <iron32> I have a question is there a simple way to grab a web and put it in an IO String ?
19:05:03 <dons> grab a web?
19:05:05 <dons> page?
19:05:06 <mauke> :|
19:05:11 <iron32> I have a question is there a simple way to grab a web pageand put it in an IO String ?
19:05:31 <emk> dons: I'm really delighted with the way the probability monads are fitting together...
19:05:31 <iron32> yes a web page sorry for the typo
19:05:35 <dons> its not trivial, unfortunately. you need the http package
19:05:42 <dons> ?where http
19:05:43 <lambdabot> http://www.haskell.org/http/
19:05:48 <mauke> just shell out to perl
19:05:49 <dons> has a few methods for getting at pages.
19:06:30 <iron32> dons thanks I will look into it
19:07:08 <dons> here you go:
19:07:09 <dons> *Main> wget "http://www.google.com"
19:07:10 <lambdabot> Title: Google
19:07:17 <dons> and the code:
19:07:19 <dons> import System.Process
19:07:19 <dons> import System.IO
19:07:19 <dons> wget url = do
19:07:19 <dons>     (ih,oh,eh,pid) <- runInteractiveCommand ("wget " ++ url)
19:07:21 <dons>     hClose ih
19:07:24 <dons>     so <- hGetContents oh
19:07:27 <dons>     se <- hGetContents eh
19:07:29 <dons>     map length [so,se] `seq` return ()
19:07:32 <dons>     return (so ++ se)
19:07:37 <dons> otherwise, use the http package
19:07:39 <mauke> (ih,oh,eh,pid) sounds painful
19:07:40 <monochrom> @slap dons
19:07:41 * lambdabot smacks dons about with a large trout
19:07:57 <dons> it is. i'm writing a wrapper for System.Process in fact
19:08:01 <dons> ?where newpopen
19:08:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
19:08:04 <dons> that guy.
19:08:11 <dons> @slap monochrom back
19:08:12 * lambdabot smacks monochrom back about with a large trout
19:08:53 * kc5tja rather *likes* that runInteractiveCommand procedure.
19:09:00 <dons> yeah, its a bit low level though
19:09:02 <dons> i'd like:
19:09:05 <siti> @slap lambdabot back
19:09:06 <lambdabot> why on earth would I slap lambdabot back
19:09:08 <kc5tja> That's like 80% of the "expect" library wrapped up into a single call.
19:09:10 <dons>  s <- readProcess "wget http://www.google.com"
19:09:11 <lambdabot> Title: Google
19:09:16 <dons> that's the interface i'm working on, anyway
19:09:28 <dons> hey tom
19:09:39 <dons> nice little blog article on dir tree walking
19:09:43 <tmoertel> thanks
19:09:47 <mauke> kc5tja: doesn't expect create a pseudo-tty?
19:09:54 <monochrom> well the "expect" library is interesting for the other 20% :)
19:10:22 <kc5tja> mauke: Of all the things I've used expect for, I've never had a need for a pseudo-TTY.
19:10:42 <kc5tja> I just needed to be able to automatically interact with a command that emulated a person tapping at a keyboard.
19:11:24 <xic> dons: what do you think about writing a web spider in haskell?
19:12:11 <mauke> dons: can I get readPipe "/usr/bin/wget" ["wget", "http://www.google.com"]?
19:12:12 <oren> Does anyone have an idea whi (in Parsec) "do { subparser1 ; common } <|> do { subparser2 ; common }" works, but "do { subparser1 <|> subparser2 ; common }" fails?
19:12:46 <dons> xic, trivial task. would be nice with forkIO concurrency
19:12:52 <dons> ?seen urlcheck
19:12:53 <lambdabot> I haven't seen urlcheck.
19:12:58 <dons> xic, you could start with the urlcheck src
19:13:07 <dons> ?where+ http://www.cse.unsw.edu.au/~dons/code/urlcheck
19:13:08 <lambdabot> Done.
19:13:12 <dons> that's a linkchecker-style proggy
19:13:24 <xic> dons: yeah, using some kind of global maximum bandwidth usage though
19:13:31 <siti> yeah in a few months I might try and write a spider in haskell :)
19:13:31 <dons> should be possible
19:13:37 <nmessenger> @type (<|>)
19:13:39 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
19:13:50 <nmessenger> osfameron: do subparsers 1 and 2 have different types?
19:14:00 <monochrom> Ah!
19:14:06 <nmessenger> oren, rather
19:14:12 <oren> Nope, they have exactly the same type
19:14:15 <bd_> oren: you're not using try around the do blocks in the former?
19:14:33 <oren> Adding try doesn't help (it is also unnecessary in this case)
19:15:01 <monochrom> I have not seen a case when the two parsers behave different.
19:15:52 <nmessenger> so ((p1 >> p3) <|> (p2 >> p3)) /= ((p1 <|> p2) >> p3)
19:16:21 <oren> What was the URl for pasting sample code?
19:16:21 <nmessenger> I'm not sure why that'd be.
19:16:26 <nmessenger> @paste
19:16:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:16:40 <mgsloan> hey, will something like "The other prelude" make it into haskell'?
19:17:22 <nmessenger> mgsloan: As awesome as that might be, H' is more for standardizing what current compilers already do.
19:17:30 <mgsloan> :(
19:17:58 * nmessenger <3 TheOtherPrelude
19:18:22 * mgsloan too
19:18:47 <mgsloan> in a few short lines it totally re-elegent-erizes haskell
19:19:13 <nmessenger> re-elegant-erization!  Awesome word!
19:19:14 <bd_> ?where theotherprelude
19:19:15 <lambdabot> I know nothing about theotherprelude.
19:19:24 <nmessenger> @wiki The_Other_Prelude
19:19:24 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
19:19:25 <mgsloan> the longer inclusion is delayed, the bigger the problem
19:19:40 <mgsloan> bigger the adjustment
19:19:45 <mgsloan> as more monadic haskell is written
19:20:26 <hpaste>  oren pasted "<|> and factoring out common tail" at http://hpaste.org/597
19:21:37 <iron32> Dons ypu know of any samples or tutorials on how to use the HTTP lib not exactly straight forward
19:21:55 <nmessenger> oren: er, small syntax error, the second root leaves out a 'do'
19:22:02 <mauke> does try (char '(') have any effect?
19:22:26 <nmessenger> doesn't work as in doesn't compile or doesn't parse correctly?
19:22:46 <dons> iron32: i don't. i agree, it isn't straight forward. we're going to write a completely new one this year some time.
19:22:49 <oren> nmessenger: Right, sorry
19:22:52 <emk> dons: What's the best mailing list to propose a rough draft of a Haskell library on?
19:22:54 <emk> dons: I
19:22:57 <dons> iron32: i'd just roll my own wrapper
19:23:04 <dons> emk, on libraries@
19:23:06 <oren> It compiles, but it chokes on the input "()\n"
19:23:07 <emk> I'd eventually like to package up all the probability stuff.
19:23:12 <dons> good idea!
19:23:17 <dons> you could just ask on haskell-cafe@
19:23:26 <dons> and you've seen the libraries tutorial?
19:23:44 <mgsloan> I suppose if the other prelude was integrated in, Prelude.Retro could hold old funcs now deprecated like concat, fmap, etc
19:24:07 <emk> dons: I think so. The nice document with the Cabal, etc., instructions?
19:24:35 <dons> yep
19:24:48 <emk> There's a bunch of other people thinking about probability monads, too, so it would be good to go for a lot of peer review.
19:25:38 <dons> yeah
19:25:43 <dons> haskell-cafe@ i think
19:26:37 * kc5tja writes some code to manipulate strings at a byte-by-byte level, which undoubtedly will be the cause of some subtle bug somewhere.
19:26:48 <dons> kc5tja: you using bytestrings?
19:26:51 <kc5tja> Hack, hack, hacking away at Firefox!
19:26:55 <dons> ah
19:27:00 <kc5tja> Nope -- fixing a bug in Firefox.
19:27:05 <dons> yep
19:27:05 <kc5tja> That's been outstanding since 2002.
19:27:10 <dons> have fun :-)
19:27:19 <hpaste>  oren annotated "<|> and factoring out common tail" with "(no title)" at http://hpaste.org/597#a1
19:27:20 <kc5tja> I have the attention of those who need to do the code review.
19:27:28 <kc5tja> (it was easier to find them than I thought)
19:27:30 <emk> dons: Thanks! And I suppose I should propose MaybeT while I'm at it...
19:27:44 <dons> not a bad idea.
19:27:54 <dons> its been brought up before. i'd like to see it in the mtl
19:27:58 <emk> I'm surprised it's not in the standard library.
19:28:00 <dons> wouldn't be controversial
19:28:08 <dons> i think its on the 'NewMonads' page on the wiki
19:30:20 <kc5tja> dons: Once I'm done whipping Firefox into shape, my next "bug to fix" milestone will be the "darcs replace doesn't take quotation marks" bug.  :)
19:30:34 <kc5tja> (which will be my first real application of Haskell coding, albeit not of original design)
19:30:53 <mauke> oren: hmm, my parser lib does the same thing so it's probably not a bug in parsec :-)
19:31:52 <christine_c> people.....good day to all of you
19:32:11 <mauke> oren: found the problem
19:32:16 <monochrom> oren: It has something to do with: <|> asymmetric; curls and parens each contains "<|> return ()"
19:32:42 <mauke> curls accepts ""
19:32:45 <mauke> the following end fails
19:32:46 <oren> Ok... which means...?
19:33:00 <oren> I see
19:33:18 <monochrom> Yeah the "<|> return()" causes curls (parens too if it ran first) to accept ""
19:33:28 <oren> I need to ensure curls/parens inisist on an input
19:33:49 <kc5tja> w00t!  The code worked.  I'm impressed.  Now for a bit of stress testing.
19:34:04 <oren> Obvious in retrospect... many thanks guys!
19:34:12 <oren> You are lifesavers
19:34:15 <hpaste>  mauke annotated "<|> and factoring out common tail" with "this also works :-)" at http://hpaste.org/597#a2
19:34:24 <MarcWebe2> ?where data
19:34:24 <lambdabot> I know nothing about data.
19:34:29 <glguy> shapr: still about
19:37:03 <oren> mauke: What is 'ParserT'  and '<|||>'?
19:37:22 <MarcWebe2> Where can I find package data containing Data.Graph.Basics ?
19:37:30 <monochrom> mauke: what is <|||> ?
19:37:41 <nmessenger> @hoogle (<|||>)
19:37:41 <lambdabot> Did you mean: (<|||>)
19:37:42 <lambdabot> Prelude.undefined :: a
19:37:42 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:37:53 <nmessenger> @index (<|||>)
19:37:54 <lambdabot> bzzt
19:38:00 <MarcWebe2> oren Never heard. StateT and ReaderT means they both have an inner monad.
19:38:40 <oren> @hoogle (<|||>)
19:38:41 <lambdabot> Did you mean: (<|||>)
19:38:41 <lambdabot> Prelude.undefined :: a
19:38:41 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:38:49 <mauke> oren: it's something I'm working on to learn monad transformers
19:38:53 <mauke> code is at http://rafb.net/p/CYt85690.html
19:38:55 <lambdabot> Title: Nopaste - No description
19:39:01 <kc5tja> hmm..Haskell has a "volume slider control" operator.  :)
19:39:17 <nmessenger> heh
19:39:41 <nmessenger> operators are just library functions.  Saying "Haskell has a foo operator" doesn't really apply.
19:39:58 <kc5tja> I was referring specifically to the otherwise ASCII-art <|||>  ;)
19:40:08 <mgsloan> you could very well have such an operator in a sound lib
19:40:24 <kc5tja> You guys took me entirely too literally.
19:40:25 <kc5tja> :)
19:40:31 <oren> mauke: I see
19:40:47 <nmessenger> $!^%$*?! <-- the acursed operator
19:40:52 <mauke> my <|||> is like parsec's <|>
19:40:58 <monochrom> "Haskell has ___ function" can mean "Someone has written ___ function for Haskell"
19:41:00 <mauke> my <|> always runs both parsers
19:41:15 <monochrom> Yeah asymmetry plays a role here.
19:42:00 <nmessenger> then of course dons wrote a whole program using nothing but multiples of (?????) for names.
19:42:16 <nmessenger> truly evil
19:42:29 <monochrom> hahahahhahaha that's cool, where can I see it?
19:42:36 <MarcWebe2> nmessenger: I'd use refactoring to rename each identifier to ???? ;)
19:42:42 <monochrom> and has dons posted about it on reddit? XD
19:42:43 <SamB> yay!
19:42:55 <SamB> IOHCC ftw!
19:43:05 <nmessenger> @go haskell obfuscated
19:43:07 <lambdabot> http://lambda-the-ultimate.org/node/308
19:43:08 <lambdabot> Title: Succ Zeroth International Obfuscated Haskell Code Contest Results | Lambda the U ...
19:43:47 * kc5tja does the happy dance -- Firefox bug fixed!
19:43:56 <SamB> whoah
19:43:58 <SamB> what bug?
19:44:39 <nmessenger> title-truncation I hope?!!
19:44:45 <kc5tja> Launching helper applications that depend on *what filename* they're invoked with (e.g., vim versus view versus gvim versus gview, for example) causes Firefox to hang indefinitely while it spawns a zombie process.
19:44:45 <bd_> the link to the actual code is broken :/
19:44:47 <monochrom> oren: can you craft up two versions of curls, one version is like the present curls accepting "", another version curls1 hating "".  Use the second version for do { curls1 <|> parens; end }
19:45:01 <jcreigh> kc5tja: good on you.
19:45:09 <jcreigh> @karma+ kc5tja
19:45:09 <lambdabot> kc5tja's karma raised to 1.
19:46:11 <kc5tja> Thanks.  :)
19:46:34 <monochrom> I'm thinking our expectation of "(x<|>y) >> z == (x>>z) <|> (y>>z)" is ok when x,y accepts disjoint languages.  Once they have overlaps (e.g., both accept "" now) things break.
19:47:04 <kc5tja> nmessenger: What title truncation bug are you referring to?  Is there an official bug filed against Firefox in Bugzilla?
19:47:08 <allbery_b> hrm.  ask shapr about that?
19:47:41 <allbery_b> (the IOCCC results link that is)
19:47:42 <mauke> nmessenger: there's an extension called Long Titles to fix that
19:47:50 <nmessenger> mauke: using it now
19:48:53 <mauke> kc5tja: go to http://www.xkcd.com/c224.html , hover mouse over image
19:48:55 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
19:49:11 <jcreigh> mauke: oh, title *attribute* truncation.
19:49:18 <monochrom> What title truncation?  What spawning zombie process?
19:49:21 <jcreigh> I was thinking <title>
19:49:25 <SamB> mauke: how is that a bug?
19:49:54 <SamB> you mean the fact that it does it so soon?
19:49:59 <mauke> yes
19:50:05 <malsyned> is it bad form to say something like "Just redditURI = parseURI "http://reddit.com" ?
19:50:06 <jcreigh> you have to right-click > properties to see the whole thing...
19:50:09 <lambdabot> Title: reddit.com: what&#39;s new online
19:50:12 <monochrom> How soon is too soon?
19:50:34 <mauke> depends on the size of my firefox window
19:50:39 <SamB> monochrom: well, it is less than the width of the image, and less than two sentances...
19:51:02 <monochrom> I completely like it this way.
19:51:03 <oren> monochrom: It is easier to simply use "optional" and stick with one version
19:51:10 <SamB> "We lost the documentation on quantum mechanics.  You'll have to decode the r..."
19:51:17 <SamB> out of:
19:51:22 <SamB> "We lost the documentation on quantum mechanics.  You'll have to decode the regexes yourself."
19:51:31 <SamB> it would easily have fit
19:51:34 <monochrom> oren: yes that too.
19:51:53 <nmessenger> monochrom: finally found it: http://haskell.org/haskellwiki/Obfuscation
19:51:55 <lambdabot> Title: Obfuscation - HaskellWiki
19:52:14 <ddarius> malysned: Not really.
19:53:05 <monochrom> nice
19:53:13 <kc5tja> monochrom: Bug 176486
19:53:51 <monochrom> I'm thinking I should file a bug: "it's too long, make it shorter, truncate more"... :)
19:53:58 <nmessenger> malsyned: if it is bad form, I do it too. :)  I find it better than fromJust myself
19:54:24 <monochrom> We can conspire to make the mozilla folks scream :)
19:55:13 <kyevan> Hmm, this summer, should I relearn haskell. or should I attempt C?
19:55:26 <monochrom> Do both.  Add FFI.
19:55:35 <malsyned> nmessenger: strength in numbers ;)
19:58:47 <monochrom> "x:_ = [1,2,3]" is perfectly correct.  So is "Just x = parseURI <clearly correct uri>".
19:59:09 <jcreigh> kyevan: Haskell is much more interesting than C. But C is useful if you want to write a kernel or hack on, oh, just about every Unix program ever written. (ie, the language itself is not that interesting, but there's tons of stuff written in it, so you should learn C at some point. But if you had to pick one, go with Haskell.)
19:59:20 <malsyned> monochrom: and the latter has the benefit of actually being useful in a real source file.
19:59:44 <malsyned> OK, it's settled.  i'm totally doing that and not even feeling guilty.
20:00:39 <SamB> anyway, it gives better error messages than fromJust
20:01:02 <monochrom> A large part of programming is about exploiting facts.
20:03:08 <monochrom> When I was a kid, I contemplated on "how paranoid should I be in my code?"
20:04:17 <dons> doh, just missed emk
20:04:27 <dons> i like the quote on his latest blog entry, "Dont worry if you dont understand the details" :-)
20:04:30 <dons> should be our motto here.
20:04:59 --- mode: ChanServ set +o dons
20:05:03 <monochrom> For example, I had a chain of functions f, g, h, ...  f passed its number parameter to g, g then passed the same number to h, ...  They were all intended to just work for positive integers.  Must I repeat the safeguard against non-positive integers at all stages?
20:05:05 --- topic: set to '["The Haskell programming language: don't worry if you don't understand the details","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
20:05:10 --- mode: ChanServ set -o dons
20:05:14 <beschmi> http://shim.haskellco.de/trac/shim/attachment/wiki/ScreenShots/vim-shim.png
20:05:16 <lambdabot> Title: ScreenShots: vim-shim.png - shim - Trac, http://tinyurl.com/29r7ah
20:05:20 <dons> ooh!
20:05:23 <dons> vim shim!!
20:05:33 <dons> beschmi++
20:05:40 <beschmi> dons: it's just a quick hack for now ;)
20:05:59 <dons> that's pretty sweet.
20:06:03 <dons> should i dive in then?
20:06:08 <dons> being a vim user
20:06:10 <kscaldef> does Double distinguish 0 and -0?
20:06:25 <dibblego> > 0::Double == -0::Double
20:06:26 <lambdabot>  Parse error
20:06:29 * jcreigh ponders why the semantics of the x86 DIV instruction must be so convoluted...
20:06:30 <dons> > 0 == ((-0) :: Double)
20:06:32 <lambdabot>  True
20:06:34 <kscaldef> > 0.0 == -00
20:06:35 <lambdabot>  True
20:06:55 <dons> ?check \x -> let _=x :: Double in x == - (-x)
20:06:57 <lambdabot>  OK, passed 500 tests.
20:07:03 <dons> i'm surprised that worked
20:07:07 <kscaldef> hmm... okay, that's not my bug
20:07:30 <kscaldef> > 0.0 == -0.0
20:07:32 <lambdabot>  True
20:07:34 --- mode: ChanServ set +o dons
20:07:44 <nmessenger> dons: that's an interesting way to annotation params without lhs annotations.
20:07:47 --- topic: set to '["The Haskell programming language: don't worry about the details","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
20:07:51 --- mode: ChanServ set -o dons
20:07:53 <nmessenger> annotate*
20:07:53 <jcreigh> Do doubles just have a sign bit?
20:07:56 <monochrom> After joining the school-of-thought of proof-your-programs-correct, I feel no guilt in omitting all checks (except at the outermost interface facing malicious parties).  I have written down in the specification that f,g,h expect positive integers, I have proved that all calls observe it, nothing to worry.
20:07:57 <dons> nmessenger: yeah :-) old QuickCheck trick
20:08:02 <Pseudonym> jcreigh: Because it was complicated 30 years ago.
20:08:05 <dbremner> monochrom - then you might like this http://ftp.stratus.com/vos/doc/papers/RobustProgramming.ps
20:08:14 <Pseudonym> That's the reason for everything in the x86.
20:08:35 <jcreigh> if doubles just have a sign bit, then -(-x) should always == x. But as with all things floating point, I wouldn't count onti.
20:08:42 <jcreigh> s/onti/on it/
20:09:01 <dons> they're hardware doubles
20:09:03 <nmessenger> then there's NaN which fudges things up :/
20:09:10 <dons> so the representation depends on the arch
20:09:21 <dons> (and the results too ...)
20:09:22 <beschmi> dons: i can publish a repo of the things i got so far. but there is only completion for now and error handling is nearly nonexistant
20:09:37 <beschmi> but it's a start
20:09:39 <dons> yeah
20:10:14 <beschmi> *existent
20:10:30 <nmessenger> @spell nonexistant
20:10:31 <lambdabot> nonexistent nonresistant inexistent nonexistence
20:10:45 <nmessenger> hmm, I could've sworn the first was correct
20:10:53 <jcreigh> beschmi: wait... "nearly nonexistent" or "nearly existent"?
20:11:12 <dons> ?spell extant
20:11:13 <lambdabot> extant
20:11:20 <JohnnyL> @serve drinks
20:11:21 <lambdabot> Not enough privileges
20:11:24 <JohnnyL> haha
20:11:27 <beschmi> nonexistent unfortunately
20:11:28 <chessguy> ?all-dict extant
20:11:33 <lambdabot> *** "Extant" gcide "The Collaborative International Dictionary of English v.0.48"
20:11:33 <lambdabot> Extant \Ex"tant\, a. [L. extans, -antis, or exstans, -antis, p.
20:11:33 <lambdabot>    pr. of extare, exstare, to stand out or forth; ex out + stare
20:11:33 <lambdabot>    to stand: cf. F. extant. See {Stand}.]
20:11:33 <lambdabot>    1. Standing out or above any surface; protruded.
20:11:35 <lambdabot> [38 @more lines]
20:11:42 <chessguy> @more
20:11:42 <lambdabot>       [1913 Webster]
20:11:43 <lambdabot>  
20:11:43 <lambdabot>             That part of the teeth which is extant above the
20:11:43 <lambdabot>             gums.                                 --Ray.
20:11:45 <lambdabot>       [1913 Webster]
20:11:47 <lambdabot> [33 @more lines]
20:11:48 <kscaldef> ahh... my bug is that I'm an idiot
20:11:49 <lambdabot> JohnnyL, you like your martini's shaken or stirred?
20:11:52 * kscaldef sighs
20:12:03 <chessguy> kscaldef, that's a hard one to fix. i run into it all the time
20:12:07 <ddarius> kscaldef: Yeah... that's usually the bug.
20:12:17 <nmessenger> kscaldef: typical bug.  A real pain in the ass.
20:12:27 <jcreigh> kscaldef: all my bugs are like that too. I mean, they're that *I'm* an idiot, not that you're an idiot. :)
20:12:55 <kscaldef> well, at least I have tests to tell me I'm an idiot ;-)
20:13:13 <kc5tja> jcreigh: Not sure if anyone answered your question or not; doubles (at least at x86 register level) have two sign bits: one for mantissa, and one for exponent.
20:13:45 * nmessenger thinks @help should also spellcheck, so @help serve tells you which command it's turned into
20:13:54 <chessguy> so fmap is just a way to apply a function to every element in a container?
20:14:02 <dons> nmessenger: nice idea
20:14:14 <nmessenger> chessguy: yep
20:14:25 <ddarius> chessguy: Except that in general instances of functors aren't necessarily "containers", yes.
20:14:26 * kc5tja celebrates my victory with a Talking Heads session.
20:14:31 <nmessenger> chessguy: though I think it is more general
20:14:49 <chessguy> guess it depends how you define containers
20:15:05 <chessguy> ?instances functor
20:15:06 <lambdabot> Couldn't find class `functor'. Try @instances-importing
20:15:11 <chessguy> ?instances Functor
20:15:13 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:15:24 <nmessenger> A monad is something that can be fmapped over, returned into, and joined together.  That's it.
20:15:41 <chessguy> i'm not talking about monads
20:16:12 <nmessenger> I know, just sharing a realization I had to the collective conciousness
20:16:19 <nmessenger> @spell conciousness
20:16:19 <lambdabot> consciousness conciseness consciousness's consciousnesses noxiousness
20:16:25 <chessguy> hmm
20:16:28 <monochrom> A container is just something you brag about in your container libraries.
20:16:32 <chessguy> ?src Mona
20:16:32 <lambdabot> Source not found. stty: unknown mode: doofus
20:16:32 <kc5tja> noxiousness  Hahaha :)
20:16:33 <chessguy> ?src Monad
20:16:34 <lambdabot> class  Monad m  where
20:16:34 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
20:16:34 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
20:16:34 <lambdabot>     return      :: a -> m a
20:16:34 <lambdabot>     fail        :: String -> m a
20:16:42 <chessguy> a monad doesn't have to be a functor
20:16:56 <monochrom> WOAH?!
20:17:06 <nmessenger> chessguy: that's a bug :P
20:17:09 <nmessenger> x >>= f = join (fmap f x)
20:17:18 <dibblego> chessguy, check out the CAL programming language
20:17:19 <jcreigh> kc5tja: okay, thanks for the info. So -(-x) == x *might* be true in some cases. (but not really worth counting on, IMO)
20:17:27 <chessguy> ?source Control.Monad
20:17:27 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
20:17:54 <kc5tja> jcreigh: I'm not sure I follow; -(-x) does equal x.
20:18:15 <jcreigh> kc5tja: but if x is a float/double, is -(-x) *always* going to equal x?
20:18:25 <monochrom> When is -(-x)/=x other than NaN ?
20:18:29 * jcreigh distrusts floating point numbers.
20:18:40 <bd_> @check \x -> negate (negate x) == (x :: Double)
20:18:41 <lambdabot>  OK, passed 500 tests.
20:18:46 <bd_> @check \x -> negate (negate x) == (x :: Float)
20:18:48 <lambdabot>  OK, passed 500 tests.
20:18:48 <kc5tja> I've never heard of the x86 FPU instruction set violating the negation rule.
20:18:58 <kc5tja> Division?  Yes.  But not necessarily negation.
20:19:00 <nmessenger> @scheck \x -> negate (negate x) == (x :: Double)
20:19:01 <lambdabot>   Completed 79 test(s) without failure.
20:19:05 * monochrom thinks there are too many misunderstandings on floating point numbers specifically ieee 754
20:19:07 <ddarius> > let nan = 1/0 :: Double in - (- nan) == nan
20:19:08 <lambdabot>  True
20:19:19 <nmessenger> eh?
20:19:20 <ddarius> > let nan = 1/0 :: Double in (- (- nan) == nan,nan)
20:19:22 <lambdabot>  (True,Infinity)
20:19:28 <monochrom> 1/0 is not NaN.
20:19:31 <ddarius> > let nan = 0/0 :: Double in (- (- nan) == nan,nan)
20:19:32 <lambdabot>  (False,NaN)
20:19:32 <dibblego> chessguy, CAL fixes your statement, the Monad class is a specific type of Functor
20:19:33 <nmessenger> > (-(-(1/0)) :: Double
20:19:34 <lambdabot>  Parse error
20:19:34 <chessguy> hmm, i can't find the original source
20:19:36 <monochrom> You'll need sqrt(-1) for that.
20:19:43 <chessguy> CAL?
20:19:45 <kscaldef> @check \x y z -> (x::Double + y) + z == x + (y + z)
20:19:45 <lambdabot>  Parse error
20:19:55 <nmessenger> > (negate (negate (1/0)) :: Double
20:19:55 <lambdabot>  Parse error
20:20:02 <kc5tja> > sqrt(-1)
20:20:04 <lambdabot>  NaN
20:20:11 <nmessenger> > 0 :+ 1
20:20:12 <lambdabot>  0.0 :+ 1.0
20:20:14 <dibblego> chessguy, http://labs.businessobjects.com/cal/
20:20:16 <lambdabot> Title: The Open Quark Framework for Java and the CAL Language
20:20:35 <chessguy> which statement are you even talking about?
20:20:42 <monochrom> > sqrt( -1 :+ 1)
20:20:44 <lambdabot>      precedence parsing error
20:20:44 <lambdabot>         cannot mix prefix `-' [infixl 6] and `(...
20:20:44 <jcreigh> chessguy: "not all monads are functors"
20:20:53 <dibblego> <chessguy> a monad doesn't have to be a functor
20:20:59 <monochrom> > sqrt( (-1) :+ 1)
20:21:01 <lambdabot>  0.45508986056222733 :+ 1.09868411346781
20:21:07 <chessguy> oh
20:21:10 <dibblego> to which the response is, "yes it does; Haskell got it wrong"
20:21:25 * chessguy sighs
20:21:27 <dibblego> (CAL got it right - of course with the benefit of hindsight)
20:21:31 <chessguy> this is #haskell
20:21:34 <chessguy> news flash
20:21:59 <monochrom> Well I guess if you wrote "a Monad is not a Functor" there would be less misunderstanding.
20:22:00 <chessguy> please don't confuse newbies by making statements like that wihtout being clear that you're not talking about haskell any more
20:22:02 <dibblego> that doesn't legitimise your statement
20:22:24 <dibblego> no, please don't confuse newbies without being clear that you're telling lies and instead you're talking about Haskell
20:22:25 <chessguy> in haskell, a monad does not necessarily have to be a functor. it's not a subclass
20:22:41 <monochrom> Well we can't talk about haskell and nothing else.  Sometimes we have to touch on category theory.  Sometimes we have to touch on ieee 754.
20:23:00 * dibblego slaps chessguy around the noggin with a copy of B. J. Pierce
20:23:17 <monochrom> And where are the newbies?
20:23:18 <chessguy> i'm the newbie i'm talking about. everything i say should be taken with a grain of salt
20:23:29 <monochrom> ok
20:23:30 <jcreigh> @quote newbie
20:23:30 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
20:23:33 <dibblego> monochrom, ##java
20:23:49 <nrb23> I'm a newbie
20:23:51 <dons> dibblego: you mean, Functor m => Monad m
20:23:52 <chessguy> but when you say "a monad is a functor", and the source says something else, i get confused
20:24:00 <dons> like pre-98 haskell?
20:24:12 <monochrom> Well English is a damn ambiguous language.
20:24:27 <dibblego> dons, I'll try to find a reference (CAL docs suck hard)
20:24:41 <nmessenger> monochrom: and the syntax is all shot to hell with special cases. :/
20:24:52 <monochrom> You go to #china and you see half of them wonder why they talk about some country and the other half of them wonder why they talk about some ceramic.
20:24:52 <chessguy> dons, i think he means instance (Functor f) => Monad f where ...
20:25:03 <chessguy> or whatever the syntax is
20:25:31 <dons> haskell used to have: class Functor f => Monad f
20:25:37 <dons> but it makes error messages a lot more confusing
20:25:41 <nmessenger> chessguy: that'd be an undecidable instance, far better if the Monad class were changed to imply Functor.
20:25:42 <dons> since they are rather generic
20:25:47 <monochrom> Hell, even Haskell is ambiguous.  When I say "0", which 0?
20:25:50 <dons> usual h98 reason for removing genericity
20:25:54 <dibblego> CAL doesn't have do notation anyway
20:25:57 <chessguy> err, yes, that's what i meant dons
20:26:35 <chessguy> dons, yes, error messages now are crystal clear *rolls eyes*
20:26:58 * nrb23 is lost
20:27:09 <kscaldef> I'm a newbie, although I used to understand a bit of category theory, long before I ever heard of haskell
20:27:19 <ddarius> dibblego: So?
20:27:24 <kscaldef> @check \x y z -> (x::Double + y) + z == x + (y + z)
20:27:24 <lambdabot>  Parse error
20:27:27 <nmessenger> I wish I would've had Monad and Functor explained to me in terms of fmap, return, and join; not with all the baggage of how Monads are used to model computation.
20:27:33 <kscaldef> why is that a parse error?
20:27:40 <dons> parens
20:27:46 <nmessenger> kscaldef: + y isn't a type
20:27:47 <kc5tja> >:(
20:27:52 <dons> ?check \x y z -> ((x :: Double) + y) + z == x + (y + z)
20:27:54 <lambdabot>  Falsifiable, after 3 tests: -1.0, 2.6666666666666665, -0.6666666666666666
20:27:54 <dibblego> ddarius, so you can write your own SuperMonad type and it would have nothing additional to the standard Monad type
20:27:59 <kc5tja> Anyone know of a way to search the darcs-devel mailing list archives?
20:28:07 <kscaldef> ahh... thxs
20:28:07 <nrb23> mmmm. floats
20:28:08 <dons> ?check \x y z -> let _=x::Double in        (x + y) + z == x + (y + z)
20:28:10 <lambdabot>  Falsifiable, after 13 tests: 4.0, 4.285714285714286, -4.666666666666667
20:28:12 <ddarius> dibblego: Except library support.
20:28:13 <kc5tja> Short of the obvious action of downloading all the gzipped contents?
20:28:18 <dibblego> ddarius, right
20:28:18 <ddarius> and community support.
20:28:26 <dons> kc5tja: use gmne
20:28:26 * kscaldef hates floating point arith
20:28:28 <dons> gmane
20:28:33 <dons> gmane's search facility
20:28:37 <kc5tja> Never heard of it.
20:28:40 <dons> i've even got a command line wrapper to that , if you want
20:28:49 <dons> what's the keyword/subject/author you're looking for?
20:28:50 <nrb23> kscaldef: then don't use it
20:28:51 * monochrom loves floating point arith.
20:29:08 * nmessenger is indifferent towards floating point arith
20:29:11 <monochrom> Too many people just don't get it.
20:29:14 <nrb23> floats are evil
20:29:21 * LoganCapaldo loves buoyant point arithmetic
20:29:24 <monochrom> They say "grapes are evil".
20:29:33 <dons> kc5tja: http://search.gmane.org/
20:29:34 <lambdabot> Title: Gmane -- Mail To News And Back Again
20:29:35 <kscaldef> blame the prof... I'm just trying to write tests for what was assigned
20:29:37 <kc5tja> dons: Any author; the subject is "darcs replace"
20:29:54 <kscaldef> except that I'm not really taking the class, so I guess I'll change the rules to make it easier to test
20:30:16 <monochrom> Well yeah, if "too many people don't get it", a consequence is "the prof doesn't get it either", so how could he/she teach it properly.
20:30:23 <dons> kc5tja: http://search.gmane.org/?query=darcs+replace&author=&group=gmane.comp.version-control.darcs.devel&sort=relevance&DEFAULTOP=and&xP=darcs%09replace&xFILTERS=--A
20:30:31 <dons> ;)
20:30:40 <slowriot> How do I bind more than one local variable with where"?
20:30:48 <kc5tja> I did a search for darcs on it, and it did not list that newsgroup.
20:30:58 <dibblego> slowriot, just list them under each other
20:31:01 <nmessenger> slowriot: start the variables on the same column
20:31:03 <nrb23> slowriot: just like the let syntax
20:31:04 <slowriot> okay
20:31:06 <dons> f x = y
20:31:06 <dons>     where z = x + 1
20:31:06 <dons>           y = z * 2
20:31:09 <slowriot> thanks
20:31:17 <kc5tja> Sounds like we need a new mailing list archiver function of some kind.
20:31:42 <dons> kc5tja: http://dir.gmane.org/search.php?match=darcs
20:31:44 <lambdabot> Title: Gmane -- Mail To News And Back Again
20:31:54 <jcreigh> so far, I've been pretty confused by some of the seemingly-arbitrary decisions made in H98. (fmap vs. map, monad comprenesions, monads aren't functors) But I haven't had the opportunity to be confused by these hypothetical error messages, so I don't know which is worse.
20:32:18 <dons> jcreigh: they're not arbitrary. though controversial, they were in general aimed at simplying error messages
20:32:19 <jcreigh> *comprehensions
20:32:40 <jcreigh> "seemingly-arbitrary"
20:32:40 <dons> so blame those who saw haskell as a replacement for scheme as a teaching language
20:32:56 <dons> and not as the industrial, large language it turned into
20:33:03 <edward1> heh
20:33:08 <dons> or at least is trying to turn into
20:33:19 <edward1> somehow i get the impression we'll be 90, and still be bitching about fmap ;)
20:33:33 <nmessenger> :D
20:33:41 <jcreigh> yeah, it seems like H98 thought it was just going to be an academic language.
20:33:41 <monochrom> I suppose if they had "class Functor m => Monad m", people would be tired of fixing up a Functor instance every time they wrote a Monad instance.  (In those days it was fashionable to always roll your own state monad rather than using State or StateT)
20:33:51 <dons> monochrom: that too.
20:33:59 <emu> industrial haskell?
20:34:16 <nmessenger> monochrom: have you seen TheOtherPrelude or the class extension proposal?
20:34:20 <ddarius> Writing instance Functor MyMonad where fmap = liftM is that hard?
20:34:36 <monochrom> (And in those days it was fashionable too to tell newbies to roll their own state monads.  Now the error message about "you lack Functor" comes in...)
20:34:37 <edward1> yeah, the Functor m => Monad m infelicity in the standard simply seems to stretch from the fact that you can't define an automatic fmap = liftM default in haskell as it stands.
20:34:52 <monochrom> nmessenger: no, I haven't.
20:34:55 * nrb23 wishes he could use haskell at work
20:34:55 <edward1> ddarius: its repetitive, not my argument. i seem to think it should just be done on general principle ;)
20:35:37 <ddarius> edward1: That would be an argument, but people write it anyways.
20:35:39 <nmessenger> monochrom: the class sys ext basically proposes: "class Functor m => Monad m where ... fmap f x = x >>= return (f x)"
20:35:57 <edward1> ddarius: preaching to the converted ;)
20:35:58 <nmessenger> monochrom: i.e., subclasses can provide implementations for supermethods.
20:36:01 <kc5tja> dons: Thanks.  I'm reading some stuff now, but none of it seems relavent to what I'm trying to research.
20:36:11 <nmessenger> @wiki The_Other_Prelude
20:36:12 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
20:37:47 <nmessenger> @wiki Class_system_extension_proposal
20:37:48 <lambdabot> http://www.haskell.org/haskellwiki/Class_system_extension_proposal
20:37:51 <nmessenger> ^^ lists implications
20:38:23 * nrb23 never thought about the (.) <=> map implications
20:38:44 <nmessenger> nrb23: as in they're both fmap?
20:38:45 <edwardk> i have an old article mentioning it on comonad.com
20:39:20 <nrb23> nmessenger: yeah, that too
20:39:45 <monochrom> "f . [1,2,3]" is gonna be quite evil.  then again grapes are evil too.
20:40:16 <nmessenger> it's only evil because (.) is hard-wired into our brains as function composition.
20:40:21 <edwardk> the (.) = map requires the (->)e reader monad to be in the standard library though. so the OtherPrelude doesn't work. does it?
20:40:22 <nrb23> monochrom: so write map instead
20:40:37 <edwardk> i like f . [1,2,3] =)
20:40:39 <chessguy> ?hoogle composeM
20:40:39 <lambdabot> No matches found
20:40:43 <monochrom> Well grapes are evil too, and I like grapes and I like evil.
20:40:46 * ddarius waits for his sink drain to work the other way.
20:40:53 <nmessenger> edwardk: yeah, that'd require Functor ((->) e)
20:41:11 <kapheine_> Especially grapes of wrath.
20:41:20 <monochrom> sink drain has something to do with plumbing has something to do with monads
20:41:23 <edwardk> well i mean it works, but . breaks as that functor isn't in TheOtherPrelude unless i missed something
20:41:39 <nmessenger> edwardk: it's still a work in progress :)
20:41:45 <nrb23> what does Functor((->) e) mean ?
20:41:45 <edwardk> heh
20:42:00 <ddarius> nrb32: Functor (e->)
20:42:00 <edwardk> look at Control.Monad.Reader
20:42:15 <nrb23> @hoogle Control.Monad.Reader
20:42:16 <lambdabot> No matches, try a more general search
20:42:27 <edwardk> it makes a functor of e -> a for all a
20:42:33 <nmessenger> @docs Control.Monad.Reader
20:42:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
20:43:25 <edwardk> you just can't write it infix coz of the parsing rules not allowing a partial infix application there, so its a little unnatural looking at first
20:43:41 <nmessenger> given type IntReader = (->) Int, fmap (f :: Char -> Bool) (g :: IntReader Char), the 'f' is mapped over the 'contained' Char, resulting in IntReader Bool.
20:43:58 <nmessenger> thus, fmap in ((->) e) is function composition.
20:44:13 <nrb23> my head asplode
20:44:43 <nmessenger> you can think of ((->) e) as a computation that requires an 'e' input to produce an output.
20:44:54 <nrb23> (my wife has her book club people over, and they're watching some crazy movie, and I have no clue what's going on)
20:45:15 <nmessenger> or as a State monad that you can only 'get', since it is only input once.
20:45:36 <edwardk> ok if a Functor f = (->)e    then f a = e -> a, so fmap :: (a -> b) -> f a -> f b becomes fmap :: (a -> b) -> (e -> a) -> (e -> b)
20:45:44 <nmessenger> > (do x <- (+1); y <- (*3); return (x + y)) 5
20:45:46 <lambdabot>  21
20:45:49 <edwardk> which is the same thing modulo alpha conversion as
20:45:52 <edwardk> @type (.)
20:45:54 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:46:12 <nmessenger> nrb23: stare at that ^^ for awhile
20:46:51 <edwardk> the (->)e thing is a little unnatural, its as bad as the (,)e comonad =)
20:47:01 <nmessenger> hah
20:47:46 <nmessenger> (+1) is an action that produces a number (given a number)
20:48:13 <nrb23> nmessenger: what monad is that statement in?
20:48:27 <nmessenger> Num e => ((->) e)
20:48:34 <nrb23> lovely
20:48:58 <nrb23> (I just moved to a different room, so maybe my head will clear up.. of course, now I have a rabbit wanting my attention)
20:49:45 <nrb23> > (do x <- (+2); return x) 6
20:49:47 <lambdabot>  8
20:49:52 <edwardk> > let (.) = fmap in (+1) . [1,2,3]
20:49:53 <lambdabot>  [2,3,4]
20:50:21 <LoganCapaldo> I'm never gonna get that
20:50:25 <LoganCapaldo> I mean I get it
20:50:29 <nrb23> allright, that last part made sense
20:50:29 <LoganCapaldo> but I just don't _get_ it
20:50:38 <edwardk> or fill in the blank with a right hand side monadic expression of your choice
20:50:39 <slowriot> has anyone here used fgl?
20:50:39 <edwardk> heh
20:50:42 <nrb23> sorta
20:50:44 <dons> a little
20:50:54 <dons> needs some docs.... :-)
20:51:14 <slowriot> I'm working on a problem, and it would be really nice if I could somehow use it to search an implicit graph.
20:51:16 <nrb23> nmessenger: I don't get the x+y part
20:51:26 <edwardk> oh, question, do any of the haskell db type codebases out there do anything with olap or mdx or is all random sql stuff?
20:51:49 <ddarius> > (do e <- ask; return (e + 2)) 6
20:51:51 <lambdabot>  8
20:51:51 <edwardk> i'm thinking i might just put something together to get my head around mdx
20:52:09 <nrb23> :t ask
20:52:11 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
20:52:19 <nmessenger> @src (->) ask
20:52:19 <lambdabot> ask = id
20:52:38 <nrb23> @src [] ask
20:52:38 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:52:43 <nmessenger> . @src doesn't understand ((->) e), but (->) is enough to get it by
20:52:51 <nmessenger> @instances Control.Monad.Reader
20:52:52 <lambdabot> Couldn't find class `Control.Monad.Reader'. Try @instances-importing
20:52:55 <nmessenger> @instances Control.Monad.Reader.Reader
20:52:57 <lambdabot> Couldn't find class `Control.Monad.Reader.Reader'. Try @instances-importing
20:52:57 <slowriot> there's a graph constructor that takes a list of nodes and a list of edges. I could create implicit node and edge lists using Haskell's implicit list syntax.
20:53:11 <allbery_b> @instances-importing Control.Monad.Reader MonadReader
20:53:13 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
20:53:13 <nrb23> @src (->) +
20:53:13 <ddarius> @instances MonadReader
20:53:13 <lambdabot> Source not found. My mind is going. I can feel it.
20:53:15 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
20:53:42 <slowriot> but when you match a node in fgl, it seems like it needs to access every context
20:53:56 <nmessenger> @src (->) (>>=)
20:53:57 <lambdabot> f >>= k = \ r -> k (f r) r
20:54:06 <nmessenger> hackery!
20:54:12 <nmessenger> @src (->) return
20:54:12 <lambdabot> return = const
20:54:24 <nmessenger> > (do return 5) 2
20:54:25 <lambdabot>  5
20:54:35 <ddarius> instance Monad ((->) r) where return = k; (>>=) = s
20:54:47 <nmessenger> hah!
20:55:18 * nmessenger head asplode with MASSIVE epiphany!
20:55:22 <nrb23> ?
20:55:32 <nmessenger> k and s in the SKI calculus
20:55:34 <nrb23> k, s as in ski?
20:55:35 <reilly> I'm getting an error when I try to compile with -caf-all ... is there some trick to this?
20:55:47 <nrb23> :t k
20:55:50 <lambdabot> Not in scope: `k'
20:56:03 <nmessenger> nrb23: ddarius's wasn't actual code
20:56:12 <nrb23> nmessenger: just checking ;->
20:56:37 <nmessenger> though, ap is also s in the ((->) e) monad
20:56:45 <monochrom> k is called const in haskell. i is called id.  I forgot s.
20:56:47 <dons> reilly: are you sure -caf-all works?
20:56:49 <dons> i've never used it
20:56:56 <dons> reilly: also, what error ?   :-)
20:57:10 <reilly> dons:   FATAL:Symbol _Mainmain_CAF_cc_ccs already defined.
20:57:19 <dons> is that hugs?
20:57:20 <ddarius> Actually (>>=) = flip s
20:57:23 <reilly> ghc
20:57:28 <dons> huh.
20:57:32 <dons> haven't seen that. looks fun.
20:57:39 <dons> not sure -caf-all works  though
20:57:42 <ddarius> @src ap
20:57:42 <lambdabot> ap = liftM2 id
20:57:45 <dons> better check on glasgow-haskell-users@
20:57:47 <nrb23> > (do x <- (+2); return x + 3) 6
20:57:48 <lambdabot>   add an instance declaration for (Num (a -> a))
20:57:48 <lambdabot>     In the expression: (retu...
20:57:51 <nmessenger> > ap (*) (+1) 5
20:57:52 <lambdabot>  30
20:58:00 <nmessenger> :D
20:58:21 <nrb23> yeah, I don't quite understand that yet either
20:58:27 <nmessenger> nrb23: add parens around the returned value
20:58:37 <reilly> dons: yeah, i will ... I'm working out a performance problem and all my time is spend in Main CAF.
20:58:40 <nrb23> > (do x <- (+2); return (x + 3)) 6
20:58:41 <lambdabot>  11
20:59:04 <reilly> dons:  wanted to track it down a little more ...
20:59:08 <nrb23> > (do x <- (+2); return (x * 3)) 6
20:59:10 <lambdabot>  24
20:59:18 <ddarius> do y <- f is do x <- ask; return (f y)
20:59:19 <nmessenger> s f g x = f (g x) x
20:59:29 <nmessenger> @src (->) (>>=)
20:59:30 <lambdabot> f >>= k = \ r -> k (f r) r
20:59:33 <dons> reilly: you using -prof -auto-all ?
20:59:41 <reilly> yeah
20:59:42 <ddarius> As I said, it's actually flip s
20:59:49 <dons> have you added some manual SCC pragmas?
20:59:56 <dons> to each sub expression/
21:00:00 <ddarius> @src (=<<)
21:00:00 <lambdabot> f =<< x = x >>= f
21:00:06 <beschmi> dons: i pushed the patches to the main shim repo and added some minimal installation instructions to http://shim.haskellco.de/trac/shim/wiki/ShimVim
21:00:06 <dons> {-# SCC "line 1" #-} for example
21:00:07 <lambdabot> Title: ShimVim - shim - Trac
21:00:15 <nmessenger> oh yeah
21:00:42 <dons> beschmi: nice
21:01:33 <nmessenger> thus we have proved that (=<<) is more natural after all!
21:02:19 <nrb23> > (do x <- (+2); return (x * x)) 6
21:02:21 <lambdabot>  64
21:02:39 <nrb23> :t (do x <- (+2); return (x * x))
21:02:42 <lambdabot> forall a. (Num a) => a -> a
21:02:45 <reilly> dons: no, not yet ... i'll try that
21:03:05 <nmessenger> the first action (+2) gets the six, x is drawn from it, the second action gets the six, which is discarded since return = const
21:03:44 <nrb23> both get them... right... my head less asplode
21:03:49 <LoganCapaldo> @hoogle Char -> Char
21:03:50 <lambdabot> Char.toLower :: Char -> Char
21:03:50 <lambdabot> Char.toUpper :: Char -> Char
21:04:23 <LoganCapaldo> > (do x <- toUpper; return x) 'a'
21:04:24 <lambdabot>  'A'
21:04:26 <nmessenger> again, it's like a State that gets carried around to each action, but can't be updated.
21:04:27 <nrb23> > (do x <- toUpper; y <- toLower; return (x:y:[]) 'f'
21:04:28 <lambdabot>  Parse error
21:04:31 <LoganCapaldo> weird
21:04:35 <nrb23> > (do x <- toUpper; y <- toLower; return (x:y:[])) 'f'
21:04:36 <lambdabot>  "Ff"
21:04:40 <nmessenger> :D
21:05:01 <nrb23> neat
21:05:10 <nrb23> so, why is it called a "reader"
21:05:13 <ddarius> nrb23: If you use ask and think of it as accessing an environment available to all "actions" then it's pretty clear.
21:05:16 <LoganCapaldo> @hoogle StdGen
21:05:16 <lambdabot> System.Random.StdGen :: data StdGen
21:05:16 <lambdabot> Random.getStdGen :: IO StdGen
21:05:16 <lambdabot> Random.mkStdGen :: Int -> StdGen
21:05:22 <nmessenger> A state - write, thus read
21:05:23 <nrb23> and how can I use its powers for awesome?
21:05:32 <LoganCapaldo> @hoogle random
21:05:33 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
21:05:33 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
21:05:33 <lambdabot> Random :: module
21:05:47 <dons> nrb23: its really nice for implementing lexical scoping in an interpreter
21:05:52 <dons> i've got a little example somwhere...
21:05:55 <ddarius> nrb23: It is also known as the Environment monad
21:06:00 <nrb23> dons: that makes sense
21:06:06 <nrb23> ddarius: ahh, I like that name better
21:06:30 <nmessenger> State s a = s -> (a, s), Reader s a = s -> a
21:06:33 <LoganCapaldo> > (do x <- random; return $ fst x) (mkStdGen 42)
21:06:35 <lambdabot>  -1673289139
21:06:38 <monochrom> -_- these days everyone is excited about being Environment-friendly
21:06:56 <LoganCapaldo> > (do x <- random; return $ fst x) (mkStdGen 2)
21:06:57 <lambdabot>  -1154341369
21:07:01 * nrb23 smacks monochrom with a medium-sized herring
21:07:05 <LoganCapaldo> Hmmm
21:07:07 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/11#interpreters-with-reader-monads
21:07:07 <chessguy> ?hoogle mapM_
21:07:08 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
21:07:09 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
21:07:09 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y7wvnq
21:07:22 <chessguy> ?hoogle getArgs
21:07:22 <lambdabot> System.getArgs :: IO [String]
21:07:31 * monochrom renames State to Pollutor, StateT to Pollutant, and dances around.
21:07:49 <dons> ddarius: hmm. your eval/lambda plugin might make a good addition to the nobench suite
21:07:58 <dons> i seem to recall it being quite stressful to compile and run
21:08:18 <LoganCapaldo> > (do x <- (+); return (x 2)) 3
21:08:19 <lambdabot>  5
21:08:24 <ddarius> hehe.  Perhaps I should extend it with first class state.  The background is there.
21:08:43 * nmessenger high-fives LoganCapaldo
21:08:48 <ddarius> dons: It should have been easy enough to compile though.
21:08:48 <LoganCapaldo> (->) e is like default first argument monad
21:08:55 <LoganCapaldo> apparently ;)
21:09:18 <ddarius> (do x <- (-); return (x 2)) 3
21:09:35 <LoganCapaldo> Although I'm not quit sure what return means
21:09:43 <nmessenger> LoganCapaldo: it is when you use functions directly, but if you use 'ask' then you can stack the Reader somewhere inside a bunch of transformers
21:09:50 <nrb23> > (do x <- (-); return (x 2)) 3
21:09:51 <lambdabot>  1
21:10:13 <nrb23> > (do x <- (-)) 3
21:10:13 <lambdabot>  Parse error
21:10:17 <nmessenger> > (do x <- asks (-); return (x 2)) 3
21:10:18 <lambdabot>  1
21:10:32 <nrb23> > (do x <- (-); x ) 3
21:10:33 <lambdabot>  0
21:10:42 <LoganCapaldo> erm
21:10:44 <nrb23> > (do x <- (-); x 1 ) 3
21:10:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> t
21:10:45 <lambdabot>     Probabl...
21:11:05 <LoganCapaldo> oh
21:11:08 <LoganCapaldo> der
21:11:09 <ddarius> LoganCapaldo: In general with a monad, don't think of (>>=) or return as doing anything.
21:11:14 <nrb23> > (do x <- (-); x + 1 ) 3
21:11:15 <lambdabot>   add an instance declaration for (Num (a -> a))
21:11:15 <lambdabot>     In the expression: x + 1...
21:11:23 <ddarius> They just let you embed pure computation into the monadic computation.
21:11:28 <nmessenger> (do x <- action; x) = action >>= \x -> x = action >>= id = join action
21:11:41 <nmessenger> > join (-) 3
21:11:43 <lambdabot>  0
21:11:52 <nrb23> @src join
21:11:52 <lambdabot> join x =  x >>= id
21:11:57 <dons> ddarius: oh, but it used a lot of Dynamic, no?
21:12:20 <ddarius> dons: It used Dynamic, yes.
21:12:24 <LoganCapaldo> Ooooooo
21:12:32 <LoganCapaldo> (->) e is totally gnarly
21:12:35 <nmessenger> > join (,) 1
21:12:36 <lambdabot>  (1,1)
21:12:48 <nmessenger> LoganCapaldo: indeed!
21:12:50 <nrb23> :t (,)
21:12:52 <lambdabot> forall a b. a -> b -> (a, b)
21:12:54 <dons> ddarius: so the whole new haskell-based @eval plugin is new since you were last here?
21:12:56 <LoganCapaldo> one day I'll use all thi crazy knowledge and write some actually haskell code ;)
21:12:59 <nrb23> nice
21:13:08 <dons> > mapM_ putChar "this one"
21:13:10 <lambdabot>  <IO ()>
21:13:41 <dons> LoganCapaldo: what kind of code do you write day-to-day?
21:13:53 <LoganCapaldo> Lately?
21:13:53 <ddarius> dons: No.  It was there when I left.
21:13:59 <LoganCapaldo> nothing really except assignments
21:14:06 <nmessenger> (join (f :: a -> a -> b) :: a -> b), thus join copies the argument.
21:14:12 <dons> do you write test suites for your assignments?
21:14:22 <dons> i always encourage my students to use quickcheck
21:14:37 <dons> wish i'd known about it when i was an undergrad -- almost feels like cheating ;)
21:14:41 * kc5tja codes in Java, Python, and Bash script professionally.
21:14:47 <LoganCapaldo> I don't think I could hand in Haskell source ;)
21:14:51 <kc5tja> (and Java was giving me fits earlier today.  Blech!)
21:15:00 <dons> right, but i'm suggesting you use QuickCheck for testing your src
21:15:07 <dons> be it in shell or C or something else.
21:15:11 * nrb23 codes in C, C++, Python, and random others professionally
21:15:14 <chessguy> LoganCapaldo, one thing i've learned in the last couple of weeks: if you aren't coding (a lot!), you're not learning!
21:15:24 * dons codes in Haskell, C and sh professionally
21:15:37 * kc5tja would *love* to code Forth professionally.
21:15:47 * chessguy is trying hard to get a haskell job
21:15:49 * nrb23 works with embedded hardware, hence, C 
21:15:53 * kc5tja isn't good enough with Haskell to code professionally with it yet.  :)
21:16:00 <ddarius> Hmm.  It would be easy to make Arbitrary instances of FFI types and use Haskell to QuickCheck your foreign language code...
21:16:04 * nmessenger hasn't worked in a while :(
21:16:04 <dons> indeed
21:16:06 <LoganCapaldo> well this weekend will be spent in the bowels of a C++ project
21:16:12 <dons> ddarius:  use that to test C bindings regularly
21:16:16 <dons> s/i use/
21:16:21 <nrb23> C++ has lots of bowles
21:16:23 <dons> i don't trust C on its own
21:16:28 <dons> even after it type checks.
21:16:43 <nrb23> ug.. C type checking
21:16:43 <kc5tja> nmessenger: I was thinking about what would happen if I lost my job.  I wonder if there's a market for people who are professional bug-fixers-for-open-source-projects.  :)
21:16:46 <LoganCapaldo> dons: So how would I apply quickcheck to some C or C++ code?
21:16:47 * nrb23 likes DoubleCheck
21:16:56 <LoganCapaldo> (I was planning on using CppUnit or something)
21:16:58 * nrb23 just realized that DoubleCheck isn't released yet
21:17:05 <dons> LoganCapaldo: ok, so C is easiest. you write a Haskell driver module that foreign imports the C function you want to test
21:17:07 <nrb23> or rather, isn't shipping
21:17:10 <ddarius> dons: No one does.  That's why people whose experience with "static typing" is C are so infatuated with dynamically typed languages.
21:17:14 <dons> and then you write a quickcheck propery for it.
21:17:25 <dons> hmm. anyone else interested in testing C code with QuickCheck?
21:17:29 <dons> maybe i should write a tutorial
21:17:36 <dons> ddarius: yeah :(
21:17:42 <dons> static typing circa 1968
21:17:53 <nrb23> dons, that might be cool, but would it work with IO? (all my C code is in IO)
21:18:01 <dons> it all does IO?
21:18:02 <jcreigh> C is *everything* circa 1968.
21:18:02 <kc5tja> dons: I'd be interested.
21:18:13 <dons> nrb23: all the code is stateful?
21:18:29 * kc5tja wrote the CUT unit testing package, and use it often for my own C projects.
21:18:30 <dons> its certainly harder to test. but possible.
21:18:31 <nrb23> dons: lately it's mostly network code
21:18:32 <dons> pure code is easier
21:18:49 <dons> network code. yeah. that's a bit harder, but people do  test that kind of thing in quickcheck now
21:19:00 * LoganCapaldo is not gonna have a whole lot of pure code either
21:19:12 <dons> john hughes' new company basically works by quickchecking network-y erlang code
21:19:35 <dons> state is bad, guys ... :-)
21:19:50 <dons> though of course, you can still test it. you just pass the state in from haskell too
21:19:59 * LoganCapaldo notes that the C code is for "Unix System Programming"
21:20:01 <dons> instance Arbitrary CProgState where
21:20:11 <dons> so?
21:20:37 <bos> dons: finally had a chance to look at chaining get in Binary.Get.
21:20:39 <dons> another option is to use quickcheck to generate unit tests
21:20:40 <LoganCapaldo> Low on the algorithms, high on the "read this datastructure from disk and twiddle its bits" ;)
21:20:43 <bos> there seems to be a problem.
21:20:44 <kc5tja> dons: And God invented Mock Objects, and saw that it was good.  COMPLICATED, a major PAIN, but good all the same.  :)
21:20:46 <nrb23> dons: yeah, but my network code interacts with hardware devices... there's real state there :->
21:20:53 <dons> that's a bit harder :-)
21:21:13 <bos> namely that there's no equivalent of runGet that keeps the residual state left after it's parsed a value.
21:21:23 <dons> kc5tja: well, at least a state monad is not anywhere near as nasty as a mock object
21:21:28 <nmessenger> heh.  "that's a bit harder" /= "that's not possible" :D
21:21:35 <bos> and i can't write my own runGet, because S and initState are private to the module.
21:21:35 <dons> bos, some have asked for that.
21:21:53 <dons> now, i thought there was a patch for that already in the repo
21:21:58 <dons> in the darcs version of binary
21:22:13 <bos> not in my copy of it.
21:22:16 <kc5tja> You know, since I am an advocate of glass-box as well as black-box testing, I almost never use mock objects.
21:22:19 <kc5tja> Never had a need.
21:22:35 <nmessenger> glass box testing?
21:22:43 <kc5tja> Just make sure your tests are partially ordered, so that lower-level tests run (and pass) before higher-level tests, and everything works out.
21:22:54 <dons> bos, yeah, looks like i didn't apply the patch
21:22:57 <kc5tja> glass box is when your tests verify state before and after an operation.
21:23:01 <dons> i solicited some feedback, and didn't get any.
21:23:09 <dons> bos, you want the patch, to see if it helps?
21:23:18 <LoganCapaldo> nmessenger, it's like black box testing except the box isn;t black and its made of glas
21:23:18 <LoganCapaldo> ;)
21:23:28 * nmessenger likes slapping people and randomly picks LoganCapaldo to slap.
21:23:32 <bos> dons: yes please :-)
21:24:00 <dons> > getNLen :: BG.Get a -> BG.Get (a,Int64)
21:24:01 <lambdabot>   Not in scope: type constructor or class `BG.Get'
21:24:02 <dons> ?
21:24:10 * nmessenger slaps HydraIRC's /slap command upside da head with a hairy goldfish
21:24:17 <dons> > runGetState :: Get a -> L.ByteString -> (a,Int64,L.ByteString)
21:24:18 <lambdabot>   Not in scope: type constructor or class `Get'
21:24:19 <dons> bos ^^
21:24:21 <kc5tja> aka white-box testing.
21:24:21 <kc5tja> brb -- I need to grab something to eat.
21:24:21 <kc5tja>  . . . -- marker -- . . .  (I wish all IRC clients had a reasonable "marker" or "hrule" type command... :( )
21:24:24 <dons> like that?
21:24:48 <dons> bos, email addr please.
21:24:50 <bos> dons: yes, exactly.
21:24:54 <bos> bos@serpentine.com
21:24:57 <nrb23> @src foldr
21:24:58 <lambdabot> foldr k z xs = go xs
21:24:58 <lambdabot>     where go []     = z
21:24:58 <lambdabot>           go (y:ys) = y `k` go ys
21:25:03 <dons> if the patch helps, we can apply it
21:25:06 <dibblego> kc5tja, why wouldn't you advocate functional programming instead (you realise it is mutually exclusive?)?
21:25:14 <bos> zoopah.
21:25:20 <dons> sent
21:27:22 <bos> dons: applied, thanks.
21:27:41 <dibblego> does a _darcs directory grow proportionally to the repository size?
21:28:11 <dons> bos, its totally untested on my part
21:28:25 <dons> but , you know what they say: if the types check, use it
21:28:27 <bos> dons: it doesn't typecheck; needs a bit of fixing.
21:28:45 <bos> S grew the strict head-of-list since that patch.
21:29:02 <bos> change should be easy enough to manage.
21:34:44 <kc5tja> back
21:34:55 <kc5tja> dibblego: I'm sorry?  I don't understand your question.
21:35:27 <dibblego> your definition of glass-box testing and functional programming are mutually exclusive; why advocate the poor one?
21:36:32 <kc5tja> dibblego: The existance of various monads in Haskell demonstrates that functional programming and state are not mutually exclusive.
21:36:53 <dibblego> I've yet to find one
21:36:53 <kc5tja> dibblego: Glass-box testing is one more tool that can be employed to help ensure correct programs.
21:37:05 <kc5tja> dibblego: Yet to find one what?
21:37:15 <dibblego> a monad that satisfies your statement
21:37:19 <kc5tja> umm
21:37:22 <kc5tja> State?
21:37:33 <dibblego> no, that doesn't satisfy your statement
21:37:45 <kc5tja> Anything that deals with low-level code?
21:37:52 <dibblego> what does "low-level" mean?
21:38:02 <kc5tja> Bits and bytes?
21:38:07 <dibblego> do you realise that a functional program has no order of evaluation specified?
21:38:18 <kc5tja> dibblego: Irrelavent and non sequitor.
21:38:35 <dibblego> it's entirely relevant
21:38:35 <kc5tja> At some point, *something* has to interface with the computer as such.
21:38:39 <kc5tja> That computer has state
21:38:42 <dibblego> let's look at this statement:
21:38:44 <dibblego> "verify state before and after an operation."
21:38:51 <dibblego> that implies order of evaluation, doesn't it?
21:39:05 <bd_> well, state can mean state within a state monad
21:39:06 <dibblego> yes, the computer; the thing in the physical world
21:39:06 <kc5tja> Sure it does.
21:39:13 <dibblego> I'm talking about computer programming and software
21:39:18 <nmessenger> doesn't Haskell explicitly specify lazy evaluation order?
21:39:18 <bd_> or in a program using IO, various IORef/TVar/etc
21:39:26 <kc5tja> Look, I'm not going to fight.
21:39:30 <kc5tja> I do this for a profession.
21:39:33 <kc5tja> I know what I'm talking about.
21:39:36 <kc5tja> I'll just leave it at that.
21:39:46 <bd_> nmessenger: no, it's technically 'nonstrict', the compiler can evaluate early if it can prove termination and exception semantics are the same
21:39:47 <LoganCapaldo> I don't think "lazy" is an order
21:39:50 <glguy> What are "orphan instances"
21:39:52 <dibblego> I don't want to fight; just point out your mistake *shrug*
21:40:12 <kc5tja> Suffice it to say that glass box testing is used to verify state transitions.  Anything that depends on that, which can be higher level code that safely abstracts it away, may or may not need glass-box testing.  But the low-level stuff does.
21:40:19 <kc5tja> There is no mistake.
21:40:23 <dibblego> there is no low-level stuff
21:40:48 <kc5tja> dibblego: If you believe that, then you've never touched hardware, never interfaced to the host OS, and never had to write optimized routines because the host language is too slow.
21:40:49 <dibblego> "All software exists in the abstract universe. Even your C program that does clever pointer arithmetic and your assembly program that moves the hard disk head." http://blog.tmorris.net/statefulness-and-the-abstract-universe/
21:40:50 <lambdabot> Title: Î» Tony&#8217;s blog Î» » Blog Archive » Statefulness and the Abstract Universe
21:41:07 <dibblego> kc5tja, that's another mistake, but I'm not interested in exploring it, are you?
21:41:34 <kc5tja> dibblego: If it's such a mistake, then why has software quality improved by leaps and bounds only *after* glass-box testing is employed?
21:41:37 <kc5tja> That's up to you.
21:41:45 <kc5tja> Explore is one thing.  Fight everything I say is another.
21:41:48 <dibblego> actually, it has improved by *not* doing that
21:41:49 <nmessenger> LoganCapaldo: perhaps I confused it with normal order
21:41:51 <dibblego> Haskell is an example
21:42:33 <kc5tja> dibblego: Haskell is one example.  But the remainder of the computer industry and its wildfire acceptance of test-driven design is an overwhelming body of evidence to the contrary.
21:42:37 <dibblego> I'm only pointing out one of your mistakes; no need to get all in a knot about it
21:42:51 <kc5tja> dibblego: I'm not getting into a knot.
21:42:55 <dibblego> kc5tja, actually, it's evidence that it's completely flawed
21:43:02 <kc5tja> If you say so.
21:43:28 <dibblego> you can't just appeal to euphemistic nonsense and expect me to just say OK, surely?
21:43:33 <kc5tja> I'm not saying that functional programming and procedural/OO+testing are isomorphic.
21:43:38 <kc5tja> But please don't call it a "mistake."
21:43:43 <kc5tja> Because it's very patently not.
21:43:49 <dibblego> it wasn't a mistake, until you made the mistake
21:44:00 <dibblego> I only asked why you went for the poor solution
21:44:00 <kc5tja> Why are you fighting?
21:44:11 <dibblego> because I embrace the truth
21:44:16 <dibblego> if that means you made a mistake, so be it
21:44:28 <kc5tja> By calling it a poor solution, you prejudged the situation -- that's precluding a fight.
21:44:39 <dibblego> it's the context we are in
21:44:41 <kc5tja> Your religious embrace of this stuff is not helping the situation.
21:44:46 <dibblego> if we were in ##java, IU'd say it differently
21:44:58 <dibblego> in fact, I wouldn't even bother investing the effort
21:44:59 <kc5tja> Look at the context of the thread of discussion at the time.
21:45:20 <kc5tja> While we are in #haskell, the discussion at the time was not Haskell related.
21:45:36 <dibblego> no, but I asked why you don't advocate a superior solution instead?
21:45:42 <dibblego> but then you made a mistake
21:45:56 <dibblego> and so we digressed
21:45:56 <kc5tja> What mistake?
21:46:03 <bos> dons: runGetState needs a slightly different signature
21:46:04 <kc5tja> I have yet to see ONE instance of an actual MISTAKE.
21:46:11 <dibblego> <kc5tja> dibblego: The existance of various monads in Haskell demonstrates that functional programming and state are not mutually exclusive.
21:46:13 <dibblego> that one
21:46:24 <kc5tja> And I stand by that statement.
21:46:25 <bos> runGetState :: Get a => ByteString -> Int64 -> (a, ByteString, Int64)
21:46:26 <dibblego> not the spelling mistake I mean (existence)
21:46:35 <kc5tja> That is not a mistake.
21:46:38 <kc5tja> That is an observation.
21:46:52 <kc5tja> If it truely were a mistake, Haskell would have NO need AT ALL for monads.
21:46:55 <nmessenger> guys, agree to disagree?
21:46:56 <dibblego> are you open to the possibility that it is an incorrect observation?
21:47:04 <kc5tja> No.
21:47:09 <dibblego> then so be it
21:47:32 <kc5tja> Yup.
21:47:52 <nmessenger> @slap both of them
21:47:53 * lambdabot smacks both of them about with a large trout
21:48:46 <nrb23> @slap nrb23
21:48:47 * lambdabot smacks nrb23 about with a large trout
21:50:52 <siti> woah haskell rocks after making huge changes + refactoring, I after solving all the type and syntax errors had my program work perfectly :D
21:51:18 <bos> where's the fun in that? no debugging to do? no Debug.Trace to add? :-)
21:51:46 <siti> yep :)
21:52:05 <nmessenger> @slap herself
21:52:05 <lambdabot> why on earth would I slap herself
21:52:09 <nmessenger> darn
21:52:20 <kc5tja> @slap himself
21:52:21 * lambdabot smacks himself about with a large trout
21:52:28 <siti> lol
21:52:36 <bos> @hoogle Int64
21:52:36 <lambdabot> Data.Int.Int64 :: data Int64
21:52:39 <nmessenger> lambdabot = female
21:52:46 <siti> that's what I was about to say
21:52:49 <siti> interesting
21:52:59 <siti> someone cares about fine details :p
21:53:09 <LoganCapaldo> instance Female lambdabot where ...
21:53:18 <Adamant> @slap yourself, with my hand, numbnuts!
21:53:19 * lambdabot slaps yourself, with my hand, numbnuts!
21:53:27 <bd_> instance Gender Lambdabot where gender _ = Female
21:53:42 <LoganCapaldo> bd_ win
21:53:45 <LoganCapaldo> *wins
21:54:00 <bd_> I mean, otherwise what's to stop adding an instance Male? :P
21:54:02 <nmessenger> LB is a type?
21:54:50 <LoganCapaldo> She is in Pseudo-Haskell
21:54:58 <bd_> data Lambdabot -- tag type
21:55:00 <LoganCapaldo> (Conversational Haskell?)
21:55:07 <bd_> lambdabot does all her computation at the type level ;)
21:56:20 <dons> yay. we're about 10 mins away from building ghc on the 16 core amd64
21:56:32 <dons> my entire phd has been building up to this moment ;)
21:56:49 <nmessenger> 16 cores?  beefy.
21:57:35 <dibblego> we're looking at buying a multi-core machine to run a large computation on it
21:58:38 <pstickne> dons, how many cores/chip?
22:03:22 <bos> do people generally use MVars instead of IORefs for mutable state in the IO monad?
22:03:31 <dons> 8 cpus, 2 cores/cpu
22:03:38 <dons> bos, yeah
22:03:41 <dons> since you get thread safety
22:03:49 <dons> with the same interface.
22:03:55 <bd_> TVars are nice too
22:03:56 <dons> but if it really has to be fast-and-mutable, use Ptr a
22:06:06 <siti> what's the diff between a Ptr and a IORef, is it that Ptr is literally a pointer?
22:06:41 <bd_> Ptr is a raw pointer into memory, not GC'd or otherwise managed by haskell. You can use it with Storable types.
22:06:43 <bd_> :t peek
22:06:45 <siti> ok
22:06:46 <lambdabot> Not in scope: `peek'
22:06:48 <bd_> hm.
22:06:51 <bd_> :t Data.Storable.peek
22:06:54 <lambdabot> Couldn't find qualified module.
22:07:05 <siti> it doesn't like you :p
22:07:45 <LoganCapaldo> dons: theres this cool article about drug testing and Haskell on reddit. You should check it out ;)
22:08:11 <dons> i should!
22:08:45 * LoganCapaldo likes the FDist monad
22:08:54 <LoganCapaldo> thats neat
22:09:01 <bos> dons: just sent you the new runGetState.
22:09:01 <LoganCapaldo> Monads are cool
22:09:42 <dons> there's something just wrong about:  make -j20
22:09:45 * LoganCapaldo does a line of Monads
22:09:48 <dons> where -j20 might be conservative
22:10:10 * LoganCapaldo was going ask if the "wrong" thing was how small 20 was
22:10:52 <bos> a good -j option is 1.5x #CPUs
22:11:47 <nrb23> hmm.. I have a list
22:11:54 <nrb23> and I want to fold over that list, collecting a new list as I go
22:11:59 <bos> dons: what's your thesis topic again?
22:12:08 <dibblego> nrb23, map?
22:12:13 <LoganCapaldo> @type whenM
22:12:13 <nrb23> but the new list depends on some state, what's the way to do this
22:12:15 <lambdabot> Not in scope: `whenM'
22:12:29 <nrb23> dibblego: no, map isn't right
22:12:34 <LoganCapaldo> @type mapAccumL
22:12:36 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:12:51 <LoganCapaldo> @type mapAccumR
22:12:53 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:13:19 <LoganCapaldo> Plus theres always fold(r/l)
22:13:30 <nrb23> well, I'd like to do it on an infinite list
22:13:35 <LoganCapaldo> @type scanl
22:13:37 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:13:42 <LoganCapaldo> @type scanr
22:13:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
22:13:51 <nrb23> what's the difference between them?
22:13:57 <nrb23> err, scanr and foldr
22:14:00 <nrb23> @src scanr
22:14:00 <lambdabot> scanr _ q0 []     =  [q0]
22:14:01 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
22:14:01 <lambdabot>     where qs@(q:_) = scanr f q0 xs
22:14:10 <nmessenger> > foldr (+) 0 [1,2,3]
22:14:11 <lambdabot>  6
22:14:13 <nmessenger> > scanr (+) 0 [1,2,3]
22:14:13 <LoganCapaldo> > scanr (+) 0 [1,2,3]
22:14:15 <lambdabot>  [6,5,3,0]
22:14:15 <lambdabot>  [6,5,3,0]
22:14:42 <nrb23> huh
22:14:53 <nmessenger> hmm
22:14:58 <nrb23> > scanr (:) [] [1,2,3]
22:14:59 <lambdabot>  [[1,2,3],[2,3],[3],[]]
22:15:04 <LoganCapaldo> > scanr (+) 0 [1,2]
22:15:06 <lambdabot>  [3,2,0]
22:15:09 <nmessenger> > map (foldr (+) 0) (tails [1,2,3])
22:15:11 <lambdabot>  [6,5,3,0]
22:15:15 <nmessenger> :D
22:15:25 <LoganCapaldo> Amaaazing
22:15:40 <nrb23> :t tails
22:15:43 <lambdabot> forall a. [a] -> [[a]]
22:15:47 <nmessenger> > tails "pin"
22:15:48 <nrb23> > tails [1,2,3]
22:15:49 <lambdabot>  ["pin","in","n",""]
22:15:49 <lambdabot>  [[1,2,3],[2,3],[3],[]]
22:16:22 <mauke> > snd (mapAccumL (\a x -> (a + 1, a + x)) 0 [0 ..])
22:16:24 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
22:16:25 <LoganCapaldo> > scanr tail [] [1,2,3]
22:16:26 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `[a]'
22:16:28 <kc5tja> That was one incredibly heavy train that just passed by, OR, that was an earthquake tremor I just felt while a train was passing by.
22:17:35 <LoganCapaldo> scanr (:) [] [1,2,3]
22:17:40 <LoganCapaldo> > scanr (:) [] [1,2,3]
22:17:41 <lambdabot>  [[1,2,3],[2,3],[3],[]]
22:17:56 <nmessenger> so scanr (:) [] = tails!
22:18:01 <LoganCapaldo> Hmmm
22:18:02 <dibblego> > mapM (\x -> Just x) [1..10]
22:18:04 <LoganCapaldo> funky
22:18:10 <nmessenger> symmetric!
22:18:20 <nmessenger> @src tails
22:18:21 <lambdabot> tails []         = [[]]
22:18:21 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
22:18:31 <nmessenger> bleh, needs more reuse :)
22:18:37 <dibblego> > mapM (\x -> Just x) [1..10]
22:18:42 <mauke> > mapM
22:19:13 <dibblego> <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
22:19:23 <nmessenger> D:
22:19:43 <mauke> @help eval
22:19:43 <lambdabot> eval. Do nothing (perversely)
22:19:53 <nmessenger> @help run
22:19:53 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
22:19:57 <LoganCapaldo> > scanr ((+1) . const) 0 [1,2,3]
22:19:57 <lambdabot>   add an instance declaration for (Num (a -> a))
22:20:38 <LoganCapaldo> > scanr ((+1) . flip const) 0 [1,2,3]
22:20:39 <lambdabot>   add an instance declaration for (Num (a -> a))
22:20:46 <LoganCapaldo> bah
22:20:55 <nrb23> :t mapAccumL
22:20:57 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:21:04 <LoganCapaldo> > scanr (\x y -> x + 1) [1,2,3]
22:21:05 <lambdabot>   add an instance declaration for (Num [t])
22:21:05 <lambdabot>     In the expression: x + 1
22:21:05 <lambdabot>     ...
22:21:12 <mauke> > mapM Just
22:21:31 <nmessenger> @type mapM Just
22:21:34 <lambdabot>     Ambiguous occurrence `mapM'
22:21:34 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
22:21:41 <bd_> :t mapM
22:21:44 <lambdabot>     Ambiguous occurrence `mapM'
22:21:44 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
22:21:47 <nmessenger> >:/
22:22:01 <LoganCapaldo> > scanr (\x y -> x + 1) 0 [1,2,3]
22:22:02 <lambdabot>  [2,3,4,0]
22:22:09 <nrb23> @hoogle mapAccumL
22:22:09 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
22:22:09 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:22:19 <mauke> > Control.Monad.mapM Just [1..9]
22:22:21 <lambdabot>  Just [1,2,3,4,5,6,7,8,9]
22:22:27 <mauke> lambdabot: you suck.
22:22:28 <LoganCapaldo> > scanr1 (\x y -> x + 1)  [1,2,3]
22:22:30 <lambdabot>  [2,3,3]
22:22:55 <LoganCapaldo> grr
22:23:18 <mauke> > sequence ["ab","cd"]
22:23:25 <nmessenger> > mapAccumR (\a x -> (shows x a, x + 1)) "" [1,2,3]
22:23:27 <lambdabot>  ("123",[2,3,4])
22:23:27 <LoganCapaldo> > scanr1 ((+1) . const) [1,2,3]
22:23:27 <lambdabot>   add an instance declaration for (Num (b -> b))
22:23:48 <LoganCapaldo> > scanr1 ((+1) $ const) [1,2,3]
22:23:49 <lambdabot>   add an instance declaration for (Num (b -> b -> b))
22:24:03 <LoganCapaldo> > scanr ((+1) . const) 0 [1,2,3]
22:24:04 <lambdabot>   add an instance declaration for (Num (a -> a))
22:24:18 <LoganCapaldo> @type (+1) . const
22:24:21 <lambdabot> forall a b. (Num (b -> a)) => a -> b -> a
22:24:25 <nmessenger> ((+1) .) . const
22:24:52 <LoganCapaldo> > scanr (((+1) .) . const) 0 [1,2,3]
22:24:53 <lambdabot>  [2,3,4,0]
22:25:03 <LoganCapaldo> ooooooooook
22:25:19 <LoganCapaldo> @type ((+1) .) . const
22:25:22 <lambdabot> forall a a1. (Num a1) => a1 -> a -> a1
22:25:28 <kc5tja> > take 3 [1,2,3,4,5]
22:25:29 <lambdabot>  [1,2,3]
22:25:41 <nmessenger> @pl \x y -> (+1) (const x y)
22:25:41 <lambdabot> ((1 +) .) . const
22:25:57 <kc5tja> > let xs = [1,2,3,4,5] in take ((length xs)-1) xs
22:25:58 <lambdabot>  [1,2,3,4]
22:26:01 <mauke> > (head >>= take) [3..9]
22:26:02 <lambdabot>  [3,4,5]
22:26:10 <nmessenger> evil!
22:26:42 <LoganCapaldo> > (take =<< head) [3..9]
22:26:43 <lambdabot>  [3,4,5]
22:27:01 <nmessenger> :)
22:27:11 <LoganCapaldo> > let off = [3..9] in (take =<< head) off
22:27:13 <lambdabot>  [3,4,5]
22:27:46 <nmessenger> that's ((->) e) again
22:27:53 <LoganCapaldo> Yeah
22:28:21 <nrb23> my head asplode again
22:28:24 <kc5tja> I still find that function inputs are distributive.
22:28:35 <nmessenger> the head of the list, is being taken from the list.  Niceola.
22:28:35 <kc5tja> s/still find that/still find it incredulous that/
22:28:43 <kc5tja> Yeah, I see how it works.
22:29:25 <kc5tja> But, you just have to rely on the distributive property of that function to see how it works.
22:30:07 <nmessenger> (f =<< g) x = f x (g x), i.e. SKI's S, so (take =<< head) = \xs -> take (head xs) xs
22:30:09 <LoganCapaldo> (->) e so weird
22:30:38 <nmessenger> or did I mix something up?
22:30:52 <LoganCapaldo> The number of meanings x <- f can take and still make sense never ceases to amaze me
22:30:59 <mauke> yes, that's f (g x) x
22:31:02 <mauke> S is ap
22:31:12 <kc5tja> SKI's??
22:31:27 <kc5tja> Is that an acronym for something?
22:31:32 <nmessenger> the SKI calulus?
22:31:36 <mauke> yes, it stands for S, K and I
22:31:40 <kc5tja> Never heard of it.
22:31:49 <mauke> S = ap, K = const, I = id
22:31:55 <kc5tja> ap?
22:31:58 <LoganCapaldo> well K is const, I is id
22:32:00 <mauke> :t ap
22:32:01 <LoganCapaldo> um, what mauke said
22:32:02 <kc5tja> I'm assuming const = constant
22:32:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:32:05 <nmessenger> K x y = x, I x = x, S x y z = x z (y z), (not sure about S)
22:32:20 <mauke> @src const
22:32:21 <lambdabot> const x _ = x
22:32:38 <nmessenger> @google Lazy K programming language
22:32:43 <nmessenger> ^^ for real perversion
22:32:43 <lambdabot> http://www.cwi.nl/~tromp/cl/lazy-k.html
22:32:44 <lambdabot> Title: The Lazy K Programming Language
22:33:01 <ski_> http://en.wikipedia.org/wiki/SKI_combinator_calculus
22:33:29 <edwardk> of course ski would have a link ;)
22:33:54 <Stinger> ever wonder if the term lazy programming is holding back functional languages from mainstream commercial adoption? ;)
22:34:07 <dibblego> Stinger, yep, often
22:34:22 <LoganCapaldo> > (do { x <- head; y <- take; y }) [3..9]
22:34:23 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
22:34:25 <kc5tja> I don't think so -- I think they just need to find their "killer app."
22:34:27 <edwardk> call it demand-driven and you wouldn't be able to beat away the business guys with a stick, thats the funny part ;)
22:34:37 <LoganCapaldo> > (do { x <- head; y <- take; return y }) [3..9]
22:34:37 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
22:35:05 <nmessenger> > (do x <- head; y <- take x; return y) [3..]
22:35:07 <lambdabot>  [3,4,5]
22:35:09 <LoganCapaldo> @redo (head >>= take)
22:35:09 <lambdabot> (do { a <- head; take a})
22:35:20 <LoganCapaldo> oh der
22:35:29 <LoganCapaldo> I make some dumb mistakes sometimes
22:35:41 <nmessenger> though (... y <- take x; return y) = (... take x)
22:35:43 * LoganCapaldo goes to bed
22:36:19 <nmessenger> @localtime LoganCapaldo
22:36:27 <lambdabot> Local time for LoganCapaldo is Fri Feb 23 01:34:11 2007
22:37:00 * nmessenger needs to do the same -_- zzz
22:40:13 <zbrown> @localtime zbrown
22:40:16 <lambdabot> Local time for zbrown is Fri Feb 23 01:38:02 2007
22:42:29 <emu> lazy is a selling point in my book
22:45:55 <allbery_b> if you want to sell it to mundanes, "just-in-time" might work better :)
22:49:27 <ski_> > return 'a' 'b'
22:49:28 <lambdabot>  'a'
22:51:06 <mauke> return = const
22:53:22 <nrb23> @src foldr
22:53:22 <lambdabot> foldr k z xs = go xs
22:53:23 <lambdabot>     where go []     = z
22:53:23 <lambdabot>           go (y:ys) = y `k` go ys
22:54:41 <svref> I've been using `flip (.)` and `flip ($)` in place of . and $, and finding them much more readable.
22:55:40 <svref> (obviously I rename them something else)
22:56:09 <nmessenger> @src (->) (>>>)
22:56:09 <lambdabot> f >>> g = g . f
22:56:22 <kc5tja> bedtime for me.
22:56:49 <svref> @help @src
22:56:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:56:56 <svref> @help src
22:56:57 <lambdabot> src <id>. Display the implementation of a standard function
22:57:08 <nmessenger> or src <type> <method> for class methods
22:57:30 <svref> (->) is the name of a class?
22:57:43 <nmessenger> (->) is a type in the Arrow class
22:58:28 <nrb23> 'night all
22:58:34 <nmessenger> good night
22:58:50 <allbery_b> the syntax of @src can't cope with ((->) r) so dons used (->) instead
22:59:15 <nmessenger> ((->) r) is a Monad, but (->) is an Arrow
22:59:46 <bd_> @src ((->) r) >>=
22:59:46 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:59:48 <bd_> @src ((->) r) (>>=)
22:59:49 <lambdabot> Source not found. My pet ferret can type better than you!
22:59:50 <bd_> @src ((->) e) (>>=)
22:59:51 <lambdabot> Source not found. stty: unknown mode: doofus
22:59:52 <bd_> :/
23:00:00 <nmessenger> @src (->) (>>=)
23:00:00 <lambdabot> f >>= k = \ r -> k (f r) r
23:00:19 <nmessenger> like allbery_b said, (->) points in the direction of ((->) r)
23:00:48 <nmessenger> the actual Monad is ((->) r), not (->), which doesn't have the right kind.
23:01:05 <bd_> oh, right, I read that backwards somehow XD
23:12:35 <bhauth> So how does Haskell compare with Mozart/Oz?
23:36:58 <Luitzen> anyone know if it is possible to create a function like match here: http://hpaste.org/598 ?
23:37:08 <Luitzen> in a generic way, that is
23:37:50 <Luitzen> the idea is to give match a data constructor, then a series of "patterns" for its arguments, and have that return a function you can apply to a value of a type and have it return true of the values for the data constructor of that type matches those you've given
23:47:42 <_Stinger_> hmm how tightly does ":: type" bind
23:48:31 <_Stinger_> a b c :: Blah, c is type Blah or a b c results in Blah?
23:52:16 <mauke> a b c, I think
23:52:28 <reilly> using mapM when you meant to use mapM_ can make a big difference in performance
23:52:39 <mauke> > read "42" :: Double
23:52:41 <lambdabot>  42.0
23:54:37 <pjd> bhauth: it might help making the question a bit more specific :)
23:54:38 <_Stinger_> hmm ok thanks
23:55:05 <bhauth> Haha, just a bit bored pjd.
23:55:49 <mauke> > "Haskell" `compare` "Mozart/Oz"
23:55:51 <lambdabot>  LT
23:55:56 <pjd> oh no!
23:56:37 <pjd> it probably counts in Haskell's favor that it has one consistent name, at least
