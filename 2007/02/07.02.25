00:41:27 <dons> ?users
00:41:28 <lambdabot> Maximum users seen in #haskell: 329, currently: 284 (86.3%), active: 27 (9.5%)
00:45:54 <sorear> I'm 28% through the yhc bytecodes ... yay
00:46:54 <dons> you writing your own interpreter?
00:47:14 <sorear> yeah
00:47:27 <sorear> it's impressive how good the docs are :)
00:47:31 <dons> how does it differ from yhi?
00:48:20 <sorear> smaller, more dynamicy, much more forthish
00:48:33 <sorear> it's like forth with laziness and GC
00:48:39 <dons> so in haskell?
00:48:47 <dons> faster than yhi? ;)
00:49:02 <sorear> nah, nasm tempted me back
00:49:03 <dons> ?time sorear
00:49:05 <lambdabot> Local time for sorear is Sun Feb 25 00:46:38 2007
00:49:41 <sorear> but I think I have a couple good ideas for any yhi
00:49:56 <sorear> as opposed to ayhi which is byte-count-at-any-cost
00:49:56 <dons> cool
00:50:35 <dons> translate it to haskell and compile that via ghc? :-)
00:50:38 <ddarius> sorear: Make an image based dynamically compiled Haskell implementation so I don't have to.
00:50:50 <ddarius> Reflective too.
00:51:07 <sorear> ddarius: you just described ayhi better than at this hour I can
00:51:23 <ddarius> @localtime ddarius
00:51:24 <lambdabot> Local time for ddarius is Sun Feb 25 02:48:56
00:52:55 <sorear> I plan on adding as many -Ds as I can get away with.  notably -DUSE_LINKER and -DUSE_LIBC, for the OpenBSD/OSXIntel/Windows crowd.  also -DOPTIMIZE_FOR_SPEED if I have time.
00:54:00 * ddarius would be working on it, but the code generator for the x86 is not very enticing...
00:56:04 <sorear> oh, that kind of dynamically compiled.
00:57:18 <ddarius> sorear: Smalltalk-esque only totally not.  That, though, doesn't really need me to write a code generator at this time...
00:57:37 * sorear hasn't used Smalltalk :(
00:58:07 <sorear> but I'm familiar with the stereotypical Forth, and have written 3(?)
01:00:44 <ddarius> sorear: Ever read the Self papers?
01:01:07 <sorear> nope :(
01:01:23 <ddarius> sorear: Do so.  They are very good reads.
01:01:46 <sorear> added to todo list
01:05:17 * ddarius should actually start checking things off his todo list.
01:05:49 <dons> sorear: did you get far with the FFT translation?
01:05:55 <sorear> no
01:06:17 <dons> ok
01:06:23 <xs> native haskell FFT?
01:06:23 <sorear> I figured out it is a radix-2 DIF FFT with component planes (all real, all imag)
01:06:36 <sorear> and it has a really wacky memory access pattern
01:06:54 <sorear> looks like someone was trying to write a screenhack when they made it
01:07:17 <dons> xs, yeah. a translation
01:07:22 <dons> sorear: hard to fix?
01:07:27 <ddarius> The math behind signal processing is very nice and quite a bit more widely applicable than it first comes off as.
01:07:47 <ddarius> It's not FFTW generated... is it?
01:08:00 <dons> nah
01:08:08 <dons> FFTW generates asm, iirc
01:08:09 <xs> GSLHaskell is really nice.
01:08:16 <sorear> for me, rewriting it from the specs I've seen would probably be easier
01:08:24 <dons> sorear: nice idea
01:08:32 <sorear> all those refs really confuse the data flow :)
01:08:41 <dons> yeah
01:08:52 * sorear bashes impure langs
01:09:24 <mbishop> FFTW uses ocaml to generate C
01:10:01 <dons> there's at least one version that generates asm blocks too
01:12:19 <mbishop> still, dunno the point of making an FFT library when FFTW is about as fast as you'll ever get heh
01:12:32 <sorear> code sharing? :)
01:13:44 <mbishop> hmm?
01:14:08 <sorear> night...
01:40:36 <paolino> @pl zipWith (\w f -> (\(x,y) -> f x y * w)
01:40:37 <lambdabot> (line 1, column 39):
01:40:37 <lambdabot> unexpected end of input
01:40:37 <lambdabot> expecting variable, "(", operator or ")"
01:41:05 <paolino> @pl zipWith (\w f -> (\(x,y) -> f x y * w))
01:41:06 <lambdabot> zipWith (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . ((flip . ((*) .)) .)))
01:41:21 <paolino> I should have guessed
02:11:09 <Chad> how would one do something alike:
02:11:29 <Chad> > let z = B.hGet 60 >>= (\x -> x `B.append` t)
02:11:30 <lambdabot>  Parse error
02:12:31 <Chad> from my own type inference, it seems to be correct
02:13:24 <Chad> so i'm inclined to think I cannot do something like ,  let b = m a >>= (a -> b)
02:14:40 <Chad> but as I just figured out one can do:
02:14:46 <dons> b <-  m a >>= (a -> b)
02:15:39 <Chad> the type of b was not monadic though,
02:15:47 <Chad> i got it working by throwing it in the IO monad though.
02:15:49 <augustss> dons: do you have your hbc darcs repo available?
02:15:52 <xs> Chad, do you mean z <- liftM (`B.append` t) (B.hGet h 60)?
02:16:04 <dons> Chad: ah yes, sorry. m a >>= return . (a -> b)
02:16:12 <Chad> xs: that's probably a more correct way of expressing it.
02:16:14 <dons> Chad: ah yes, sorry. (a -> b) `fmap` m a
02:16:20 <dons> augustss: i do
02:16:29 <dons> http://www.cse.unsw.edu.au/~dons/code/hbc
02:16:29 <lambdabot> Title: Index of /~dons/code/hbc
02:16:34 <augustss> thanks
02:16:35 <dons> though i've not tested that everything is there.
02:17:13 <augustss> dons: I just want to see if you have any newer stuff than I.  My code looks a bit old.  Version date was 1999. :)
02:17:26 * Chad needs to start using liftM more.
02:27:52 <augustss> dons: The default heap size for hbc is 10M, could you add say, -H100M to the runtime flags for hbc next time you run nobench?
02:29:22 <dons> yep.
02:29:47 <dons> actually, i've got HBC_RUN_OPTS = -A20M -H128M
02:29:51 <dons> that ok?
02:30:53 <augustss> Oh, ok.
02:31:24 <augustss> let me check something again then
02:32:28 <augustss> Change that to "-A20M -H128M -"
02:32:53 <augustss> The - stops the rest of the args from being interpreted by the rts
02:33:03 <dons> ah ha!
02:33:07 <dons> yes, i was wondering about that
02:33:22 <augustss> so integer should pass now
02:33:36 <dons> ok. good
02:34:19 <dons> ok. tonight's run will use that
02:34:48 <bos> dons: thx for taking the run
02:34:49 <augustss> Hmmm, I see that I should add 5-tuples to show.  hbc only goes up to 4
02:35:01 <bos> er, runGetState fix
02:38:40 <augustss> dons: And perhaps a -H128M to hbc as well.  It seems to run out of heap when compiling some programs.
02:40:51 <dons> ok
02:42:16 <augustss> dons: are you using hbcmake to compile?
02:42:20 <dons> yeah
02:42:42 <augustss> it seems to get confused by lhs files :(  doesn't get the dependencies right
02:43:07 <dons> right. i saw that on a couple.
02:43:15 <dons> some things in the real category
02:44:16 <augustss> yeah
02:46:32 <JohnMeacham> back. and well taco-ed. LA does make good late night tacos.
02:47:04 <JohnMeacham> got my new backend working! yay. went out to celebrate. will work on optimizing it tomorrow. but very promising so far.
02:47:56 <dons> great!
02:50:27 <araujo> morning
02:50:43 <malcolm> dons: what happened to all the imaginary progs in nobench? there are only 7 left!
02:51:38 <dons> sorry, yeah, that's some partial results
02:51:51 <dons> i accidentally 'make clean' then 'make publish'
02:51:55 <dons> in imaginary
02:52:06 <JohnMeacham> indeed. it should help the compilation passing a lot. as it doesn't need the global analysis pass, which was just infeasable for programs over a certain size. so now I can just run it for some set amount of time (perhaps settable by a command line argument) and still be able to compile stuff.
02:52:51 <malcolm> dons: OK, no problem.  So we should see them come back tomorrow.
02:52:57 <dons> tonight's run has just started, so the should be up in hmm, 4 hours?
02:53:01 <dons> i'm not sure how long it takes now
02:53:25 <malcolm> dons: mind you, excluding the imaginaries has improved nhc98's geometric mean substantially :-)
02:54:13 <dons> note that nhc is a bit poorly treated at the moment. timeouts count for 1.5x the timeout limit
02:54:32 <dons> so even though nhc runs some progs in imaginary, whihc timeout, yhc refuses to even run those, and its mean looks better (though it fails more)
02:54:49 <augustss> dons: I don't believe the results of hidden.  ghc is right and every other implementation is wrong?  I think it's the other way around :)
02:55:03 <malcolm> dons: sorry, I don't understand - the timeout is set to 400s yes? but it actually means 600s?
02:55:20 <dons> augustss: you looking at the current results?
02:56:05 <dons> malcolm: so the current timeout is 600 (it will be 1200 tonight). when computing the mean, timeout doesn't count as failure, it counts as a successful time of 900
02:56:08 <augustss> dons: I'm looking at http://www.cse.unsw.edu.au/~dons/nobench/bench.results
02:56:40 <malcolm> dons: oh, I see.  That could be a dubious interpretation.
02:56:44 <dons> augustss: oh, that looks out of date. i was hacking on things today. see http://www.cse.unsw.edu.au/~dons/nobench/results.html
02:56:45 <lambdabot> Title: nobench: Haskell implementation shootout
02:57:16 <dons> everything passes hidden now, cept jhc
02:57:46 <malcolm> augustss: have you found some sources for hbc now? :-)
02:58:17 <augustss> malcolm: I've even managed to recompile hbc after a little hacking
02:59:06 <malcolm> augustss: Sven Panne did some hacking on hbc back in 2004, for H'98 compatibility, I think
02:59:15 <dons> malcolm: right. so hmm. what should i do about timeouts?
02:59:24 <dons> anyway, i've increase the limit to 1200, so we'll see.
02:59:32 <malcolm> dons: just increasing the limit seems reasonable
02:59:32 <dons> hopefully a few more things scrape in under that.
02:59:59 <dons> so of course, compilers that refuse to compile anything but stuff they can run quickly will have a good mean
03:00:09 <augustss> malcolm: oh, I had done some too in an unreleased version.  back in 99 or so
03:00:18 <malcolm> if an implementation is more than 2000x slower than the others, you could probably count it as a failure
03:00:36 <dons> ah yes. that's a good idea.
03:01:23 <augustss> dons: which kind of FP arithmetic is ghc using?
03:01:41 <malcolm> dons: have you pointed augustss at your darcs repo for hbc?
03:01:47 <dons> malcolm: yep.
03:02:06 <augustss> dons: it seems your and my repo were pretty similar
03:02:30 <dons> augustss: some of the Double-heavy  programs are asking for sse FP with gcc.
03:03:04 <augustss> dons: I have my doubts about fem, which only differs in some decimals.  I'm not sure ghc is right here. :)
03:03:07 <malcolm> dons: I'm having trouble with darcs pull: 404 not found /~dons/code/nobench/.git/darcs-format
03:03:10 <malcolm> dons
03:03:17 <dons> .git ?
03:03:23 <malcolm> is that a darcs bug, or a repo bug?
03:03:45 <dons> hmm. there's no such file .gti
03:03:57 <malcolm> that's what the 404 says :-)
03:04:06 <dons> very odd. let me try..
03:05:13 <dons> augustss: if you reckon ghc is wrong, send a patch changing fem.expected :-)
03:05:26 <dons> then you and simon can work out who's right
03:05:47 <augustss> dons: it could be hbc taking liberties too.  I'd have to investigate
03:06:17 <dons> i've noticed quite a bit of floating point variation across the programs
03:06:29 <dons> hugs too, since it does non-gmp stuff. and yhc has hit a couple of bugs.
03:07:04 <malcolm> augustss: any chance of adding a m_powerpc backend to hbc? :-)
03:07:53 <dons> malcolm: hmm. i can 'get' the repo fine.
03:08:18 <dons> i've no idea why it would be looking for a .git dir
03:08:30 <malcolm> dons: yeah, I was able to darcs get it too (well, there was a darcs error at the end, when applying)
03:08:59 <malcolm> dons: I've seen that kind of error intermittently from unsw before
03:09:18 <dons> oh, that's interesting.
03:09:26 <augustss> malcolm: powerpc?  That's m_rs6000
03:09:31 <dons> $ darcs get http://www.cse.unsw.edu.au/~dons/code/nobench
03:09:31 <dons> Copying patch 273 of 273... done!
03:09:31 <dons> Applying patch 273 of 273... done.
03:09:31 <dons> Finished getting.
03:09:31 <dons> $ darcs --version
03:09:31 <lambdabot> Title: Index of /~dons/code/nobench
03:09:33 <dons> 1.0.7 (release)
03:09:55 <malcolm> I wonder if the web server is not giving a proper 404 http response code, but a 200 page served, containing only the text which claims it is a 404
03:10:30 <malcolm> augustss: oh, cool, I'd forgotten about the IBM machines that used the same chip
03:11:01 <malcolm> dons: or it could just be a darcs bug, I'm on 1.0.4, which is quite old now.
03:11:07 <augustss> malcolm: I admit rs6000 isn't the best name.  but when i wrote the code generator I don't think the name powerpc was widely used yet
03:11:09 <dons> ah quite possibly
03:12:07 * malcolm starts building hbc on his G4 iBook
03:14:01 <dons> augustss: so do you have a new repo up somewhere for hbc?
03:15:05 <augustss> dons: not yet.  i want to make sure i have a few things from your repo merged first.  I don't want too many of them floating around :)
03:15:16 <malcolm> augustss: hmm, configure is telling me Target machine: m_rs6000, target OS: aix, C compiler: 'gcc'
03:15:37 <malcolm> I'm not sure how to change aix to darwin - or maybe it doesn't matter
03:15:55 <augustss> malcolm: well, making to work with darwin will probably need some hackery
03:16:11 <dons> augustss: ok, i'll just take down mine once you put up the official version
03:16:19 <malcolm> augustss: I'll just start it building and see how far it gets
03:16:23 <augustss> I'm gonna see if I can get it going on my macbook
03:17:51 <malcolm> augustss: that's a core-duo though?
03:18:11 <augustss> malcolm: yes.  but same OS
03:18:34 <augustss> I'm sure my OS dependent #if's need some updating
03:19:00 <malcolm> augustss: the build failed already, with lmlc: not found - hmm, I thought it bootstrapped lmlc somehow
03:19:29 <augustss> malcolm: no, porting hbc is a pain
03:19:57 <augustss> The file CROSSCOMPILE explains how
03:20:02 <malcolm> augustss: perhaps I'll leave it to the expert then
03:23:07 <dons> i'm wondering how i originally got hbc going. was there an lml binary snapshot?
03:23:20 <augustss> dons: yes
03:23:43 <augustss> dons: each distribution used to have binaries for all the archs
03:23:49 <malcolm> there are still linux snapshots available from the chalmers ftp
03:24:14 <dons> ah right. that's what I used I think.
03:27:52 <malcolm> I have a source tarfile http://www.cs.york.ac.uk/fp/hbc-2004-06-27.src.tar.gz and wonder if there might be any unmerged patches in there.  (download permissions fixed btw)
03:29:53 <dons> that's interesting. that's 2 days earlier than my snapshot.
03:29:58 <dons> i'll run a quick diff
03:33:59 <pejo> augustss, isn't the CPU's in rs6000 "Power<n>", and somewhat different from the version apple is using? (Somewhat late reply, and only the end of the conversation on the top of my screen).
03:34:37 <dons> malcolm: --- /home/dons/dons/src/hbc/lmlchbc/version.c   Wed Jun 30 00:41:37 2004
03:34:40 <dons> +++ ./lmlchbc/version.c Wed Jun 26 23:15:46 2002
03:34:43 <dons> @@ -1,4 +1,4 @@
03:34:45 <dons>  char *
03:34:48 <dons> -version = "Haskell98 version 0.9999.5c";
03:34:50 <dons> +version = "Haskell98 version 0.9999.5b";
03:35:05 <dons> that  seems to be the only difference, and:
03:35:06 <dons>  char *versiondate =
03:35:06 <dons> -"2004 Jun 29" ;
03:35:06 <dons> +"1999 Apr 02" ;
03:35:09 <dons> :-)
03:35:18 <malcolm> dons: fair enough
03:35:52 <malcolm> pejo: yes, POWER3, POWER4 etc are different from the powerpc arch in minor ways, but there is a common instruction subset
03:36:36 <Phyx-> quick question, is there still no official build for lambdabot on windows?
03:36:50 <dons> right.
03:36:59 <dons> there is no official build of lambdabot for any arch :-)
03:37:17 <Phyx-> :P
03:37:17 <dons> lambdabot should build on windows though.
03:37:33 <Phyx-> i tried on an earlier version, didn't go so well, i'll try again now
03:37:46 <Phyx-> busy copying from darcs
03:37:52 <augustss> pejo: yes, they are somewhat different, but hbc uses just a few instructions that I believe are the same
03:38:21 <Saizan> trying to configure latest LB: Setup.hs: cannot satisfy dependency unix-any :)
03:38:58 <dons> there were some recent patches to make lambdabot build on windows. check with newsham.
03:39:58 <beschmi> newsham++, he ported shim to windows too
03:39:58 <lambdabot> beschmi: You have 1 new message. '/msg lambdabot @messages' to read it.
03:40:00 <Saizan> ?where arrows
03:40:00 <lambdabot> http://www.haskell.org/arrows/
03:40:18 <dons> Saizan: probably best to get them from hackage
03:40:24 <dons> ?hackage arrows
03:40:25 <lambdabot> Unknown command, try @list
03:40:32 <dons> ?where hackage
03:40:33 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
03:40:36 <Saizan> thanks
03:40:54 <pejo> Wow. HBC contains backends for nearly any arch.
03:42:36 <beschmi> dons: thanks, i'm taking a look at sml-mode. got anything special in mind?
03:43:55 <malcolm> if anyone is interested, I have tarfiles for hbcc + grin backend.  (hbcc was lennart's successor to hbc)
03:44:03 <Phyx-> dons: ok, will do
03:44:30 <malcolm> hbcc was used as the front end for the pH compiler, and Eager Haskell
03:45:00 <Phyx-> newsham: you around? :P
03:47:31 <Phyx-> "If you're *not* using ghc 6.6, build the Data.ByteString library at" <-- i thought ghc was at pre 6.5
03:49:07 <dons> malcolm: hmm. we really should have this kind of thing on darcs.haskell.org
03:49:23 <dons> Phyx-: 6.6 came out last october
03:49:28 <dons> ?version
03:49:29 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
03:49:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:50:18 <Phyx-> hmm, ok, cool. updating then :)
03:50:42 <Saizan> uhm, LB builded just by removing the unix dependence from the .cabal
03:50:53 <malcolm> dons: It's all very well making a darcs repo available, but really these things need an active maintainer
03:51:31 <Phyx-> oh nice.. Cabal looks nice :D
03:51:35 <cpfr> hey is there a good tutorial on ffi i can look at
03:51:40 <cpfr> i am quite intrigued
03:51:43 * Phyx- likes
03:51:43 <malcolm> I suppose having a repo accessible does mean that the software can sit and wait for someone to become interested enough to maintain it
03:52:02 <dons> yeah. i was thinking more of avoiding the situation where the src is lots for good
03:52:07 <dons> lost.
03:52:33 <dons> cpfr: hmm. there are a few. probably best to poke around haskell.org's wiki for examples
03:52:39 <cpfr> ok
03:52:47 <cpfr> dons got any favorites?
03:53:02 <dons> its pretty easy to use, btw, say you wanted to use strlen:
03:53:03 <dons> foreign import ccall unsafe "string.h strlen" c_strlen
03:53:03 <dons>     :: CString -> IO CSize
03:53:22 <malcolm> Hmm, nhc98 seems to fail on a lot of nofib/nobench programs with Context for Prelude.Num needed in left hand pattern
03:53:36 <dons> yes. i noticed that malcolm. any ideas?
03:53:45 <malcolm> I really must fix that in the compiler, rather than always tweaking the sources
03:53:59 <dons> cpfr: hmm. i think there's at least one on the wiki. but check the FFI spec too
03:54:11 <cpfr> ok will do
03:54:21 <malcolm> there is an easy src->src transformation that always permits nhc98's typechecker to succeed there
03:54:46 <dons> ah right. you sent me some manual transforms of that sort?
03:54:56 <JohnMeacham> dons: are the logs of the compilers output available online somewhere?
03:55:24 <dons> JohnMeacham: yes, click on 'Logs', http://www.cse.unsw.edu.au/~dons/nobench.html
03:55:25 <lambdabot> Title: nobench : benchmarking Haskell implementations
03:56:08 <JohnMeacham> ah. cool. thanks.
03:57:48 <JohnMeacham> I don't know if this one should count against me: http://www.cse.unsw.edu.au/~dons/nobench/logs/integer.jhc-ghc.compile  :)
03:57:49 <lambdabot> http://tinyurl.com/yvx66s
03:58:18 <JohnMeacham> it looks like a lot of the failing ones were from timeouts. which is good. because I know about that problem :)
03:59:02 <dons> JohnMeacham: hehe.
03:59:24 <dons> i like the final warning:   user error (Hs code did not compile.)
04:00:29 <JohnMeacham> hmm.. a lot of them are just missing library routines or minor parsing issues. I can probably hammer a bunch of those out tomorrow..
04:00:46 <dons> right. a lot of them seem trivial.
04:01:53 <JohnMeacham> of course. patches always welcome. :)
04:01:56 <malcolm> dons: whilst I'm waiting for a fresh darcs to compile, can you tell me what primes2007 does, and how it differs from the previous primes?
04:02:15 <dons> right. primes2007 is a collection of the primes programs that were posted to the mailing list last week
04:02:24 <araujo> yay!
04:02:28 <dons> one of which is the wheel sieve. but there are a number of other prime sieves there
04:02:31 <malcolm> dons: oh, OK
04:02:31 * araujo found the bug!
04:02:38 * araujo throws sugar lambdas at everyone
04:02:46 <dons> i'd imagine we could merge wheelsieve2 in there, and have a single primes benchmark
04:02:56 <dons> spj asked me to add it :-)
04:03:08 <malcolm> it's odd that wheel sieve should break nhc98, since CR developed it using nhc
04:04:51 <malcolm> pidigits reveals a nasty heap-allocation/GC bug in nhc98 to do with GMP.  If you increase the heap to be ludicrously large, the runtime seg fault goes away.
04:04:57 <JohnMeacham> hmm.. I think I am goning to make Char's 24 bits and Int's 30 bits. I wonder how many programs that will mess up.
04:04:59 <dons> oh, is that the one that segfaulted? primes2007?
04:05:23 <Phyx-> dons: i try with cabal and get setup.exe: cannot satisfy dependency unix-any
04:05:41 <dons> Phyx-: for lambdabot?
04:05:45 <Phyx-> yup
04:05:53 <dons> Phyx-: you need to edit the .cabal file for windows, since you don't have unix*
04:05:54 <malcolm> no, pidigits segfaulted - I haven't had the chance to explore primes2007 yet
04:06:16 <dons> i think primes2007 did too. let me check..
04:06:27 <Phyx-> dons: ok, cool, thanx
04:08:33 <Phyx-> dons: should i just remove the reference?
04:08:59 <dons> i think so.
04:09:04 <Phyx-> ok
04:09:04 <dons> then talk to newsham if you get stuck
04:09:12 <Phyx-> ok, thanx
04:09:24 <Phyx-> i'll need to find a few other depencies first
04:09:27 <Phyx-> like arrows
04:09:30 <Phyx-> *scrolls up*
04:09:34 <dons> get them all from hackage
04:09:36 <dons> ?where hackage
04:09:48 <dons> ?where lambdabot
04:09:48 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
04:09:49 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:10:31 <Phyx-> cool, should make things easier
04:10:48 <dons> malcolm: btw, if you have any nice benchmarky programs lying around, ping me with the url, and i'll add them.
04:11:12 <dons> malcolm: right. so after 20 seconds or so, primes2007 segfaults too
04:11:31 <malcolm> dons: OK, sounds like the same GMP binding bug
04:11:42 <dons> $ ./primes2007 2000 +RTS -H512M -RTS
04:11:42 <dons> Not enough memory for heap and stack.
04:11:45 <dons> is that true?
04:11:55 <dons> I thought i had 1G on this box.
04:12:22 <malcolm> dons: what it means is that the OS has refused to serve the memory somehow
04:12:29 <dons> ok.
04:13:04 <malcolm> Using sbrk() asks for the memory to be contiguous to the code segment I think
04:13:47 <malcolm> If you use malloc() instead, you are more likly to get the memory, but it could be in the upper portion of the address space, which triggers the high mem bug in nhc98
04:14:23 <dons> ah right. i see.
04:15:06 <malcolm> drat, my build of darcs has failed
04:15:22 <Phyx-> ?where readline
04:15:23 <lambdabot> I know nothing about readline.
04:15:43 <Phyx-> ok,i'm guessing it means the function then
04:15:47 <dons> readline is on darcs.haskell.org (hmm, it should be on hackage too)
04:16:15 <Phyx-> dons: all i find is Shellac-readline
04:16:16 <dons> malcolm: right, if I increase the heap size, it makes further progress, +RTS -H256M -RTS
04:16:25 <Phyx-> i'll loook on darcs
04:16:36 <dons> Phyx-: yes. i'm saying it really should be on hackage, but it isn't :-)
04:16:44 <malcolm> dons: yup, definitely sounds like the problem as pidigits
04:17:11 <Phyx-> dons: :P ok
04:17:24 <Phyx-> found it :)
04:20:06 <lispy> hackage has been realized?
04:20:18 <dons> yes.
04:20:25 <dons> most of it
04:20:26 <lispy> awesome
04:20:35 <lispy> ?where hackage
04:20:35 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
04:20:55 <lispy> i need to get my stuff into the hackage system
04:20:58 <dons> malcolm: there's no mtl lib with nhc98?
04:21:16 <malcolm> it uses MPTC and maybe fundeps
04:21:22 <dons> yes to both.
04:21:26 <Phyx-> lol, think installing readline hung
04:21:48 <Phyx-> visual studio is not responding ^_^
04:25:30 <lispy> Phyx-: you're using visual haskell?
04:25:53 <Phyx-> lispy: tried to, went back to installing them via commandline
04:25:59 <Phyx-> lol, less of a hassle
04:27:58 <lispy> dons: would it be hard to make it so that you can browse the package source directly from the package page?
04:28:51 <dons> i don't think so. seems easy enough. talk to Ross/grab the src and hack it
04:29:17 <lispy> i just emailed him requesting a user account
04:29:25 * dons `ap` sleep
04:29:30 <lispy> i have a couple projects i'd like to see on the list :)
04:29:35 <lispy> good night
04:29:48 * lispy should sleep too
04:30:04 <goban> http://web.archive.org/web/20010531202326/www.numeric-quest.com/haskell/QuantumComputer.html
04:30:07 <lambdabot> Title: Haskell Simulator of Quantum Computer, http://tinyurl.com/24z9hm
04:30:26 <ttmrichter> Lambdabot generates tinyurls?  Cool!
04:31:28 <Phyx-> lol
04:31:47 <astrolabe> I don't know how useful that feature is.
04:31:49 <lispy> ttmrichter: yeah, i implemented it!
04:32:09 <astrolabe> lispy: No offence
04:32:16 <Phyx-> that's weird... setup.exe: can't find source for Control.Arrow.Operations in ["."]
04:32:28 <lispy> astrolabe: non taken.  I certainly find it useful.  YMMV :)
04:32:36 <ttmrichter> It's really useful.  I like ambushing some of my hide-bound C++-steeped colleagues with Haskell-related links.
04:32:55 <Phyx-> am i missing something?
04:33:07 <astrolabe> ttmrichter: That does sound like a valid use.
04:34:03 <ttmrichter> Useless would be lambdabot generating a screenshot of a web page, hosting it on imageshack and tinyurling that.
04:34:21 * ttmrichter has a head full of useless ideas.  :D
04:34:31 <Cale> hehe
04:34:44 <Phyx-> ttmrichter: though i could see usages for that one aswell
04:34:50 <lispy> ttmrichter: oh, you should get the lambdabot source and add that :)
04:35:01 <Phyx-> it's a goatse exploit waiting to happen :P
04:35:43 * ttmrichter makes a mental note to abuse lambdabot with goatse support.
04:36:18 <Phyx-> ohh, i am missing something, stupid program didn't extract the files correctly
04:36:19 <lispy> lambdabot is very hackable and dons accepts many patches for it
04:36:30 <Phyx-> .tar.tar support should really be fixed in izarc
04:36:31 <lispy> so,  if you do think of a feature or an improvement, hack away!
04:38:14 <ttmrichter> Sure.
04:38:23 <ttmrichter> Once I get to the stage where I can *UNDERSTAND* lambdabot's code....
04:38:38 <ttmrichter> Learning Haskell is a part-time fun-time thing for me right now.
04:38:53 <Phyx-> :) same
04:39:23 <ttmrichter> For any suitably expansive definition of "fun"....  ;)
04:39:28 <Phyx-> haven't used it in 6 - 8 months, forgot quite alot
04:39:40 <Phyx-> it's coming back piece by piece though :)
04:40:26 <lispy> once you understand monads you'd be able to hack on lambdabot
04:40:45 <Phyx-> i understand it, just forgot it :|
04:41:23 <Phyx-> haven't touched a functional language in months
04:41:24 <Phyx-> lol
04:42:50 <lispy> ah yeah
04:42:57 <lispy> been a while since i hacked some haskell too
04:43:13 <lispy> next term i get to hack it more
04:43:20 <lispy> i'll be working on my research which is all in haskell
04:44:09 <Phyx-> i won't be needing it for the remainder of my bachelor, maybe masters
04:58:49 <Phyx-> hey, how do i install base? it has no setup.hs or lhs
05:01:02 <Phyx-> nvm..
05:01:02 <Phyx-> lol
05:03:15 <astrolabe> is there a standard library that does peano arithmatic?  Something like 'data Nat = Zero | Succ Nat'?
05:03:53 <Pastorn_> astrolabe: write it yourself?
05:04:20 <astrolabe> Pastorn_: Yeah, not difficult I think, but I'd prefer that there be a standard one.
05:04:52 <astrolabe> or do you mean I should produce a standard one?
05:05:38 <Pastorn_> is PA something that should have a library?
05:06:10 <Pastorn_> i mean: what are the uses?
05:06:23 <pjd> astrolabe: maybe just collect various Oleg snippets together
05:06:29 <pjd> http://article.gmane.org/gmane.comp.lang.haskell.general/13223
05:06:32 <lambdabot> Title: Gmane -- Mail To News And Back Again
05:07:34 <astrolabe> Pasorn: I thought it would be nice if  'length [0..5] < length [0..]' returned true.
05:07:50 <pjd> "The implementation of RSA on type level is left for future work."
05:07:51 <xerox> astrolabe: http://www.eecs.tufts.edu/~rdocki01/typenats.html
05:07:52 <astrolabe> I'd have to define a new length too of course
05:07:53 <lambdabot> Title: Typenats
05:08:06 <nornagon> > length [0..5] < length [0..]
05:08:12 <lambdabot> Terminated
05:08:13 <Pastorn_> and list...
05:08:33 <Pastorn_> or?
05:08:39 <Pastorn_> nevermind...
05:08:52 <nornagon> > [0..5] < [0..]
05:08:59 <lambdabot>  True
05:09:48 <astrolabe> Pastorn: there are ways of finding the shorter list at the moment of course, but I would like to be able to write what I did.
05:10:02 <dmhouse> > let lthLT (a:as) (b:bs) = lthLT as bs; lthLT [] (_:_) = True; lthLT (_:_) [] = False; lthLT [] [] = False in lthLT [0..5] [0..]
05:10:04 <lambdabot>  True
05:10:11 <astrolabe> xerox: That's something different I think.  I didn't mean a type for each Nat.
05:10:21 <a-oXiDe> is there a function in IO or prelude to print out a list of lists of Strings?
05:10:46 <nornagon> a-oXiDe: show.
05:10:51 <xerox> astrolabe: this way you can type-annotate lists with their length, and have length [0..5] [0..] returning True in O(1) time?  Mumble.
05:10:52 <astrolabe> dmhouse: exactly, but it's a bit nasty.
05:10:53 <nornagon> > show [["a"]]
05:10:54 <lambdabot>  "[[\"a\"]]"
05:11:08 <dmhouse> astrolabe: surely if you want to encode the length of the list into its type, you need type-level nats?
05:11:09 <Cale> a-oXiDe: print
05:11:41 <dmhouse> a-oXiDe: print x is just putStrLn (show x). show converts anything that's "showable" into a String.
05:12:31 <Pastorn_> on related note: length and Ord operators should be optimized for laziness
05:12:32 <astrolabe> dmhouse: for example if I want to know if (2*length a) + 1 > length b, I have to write a comparison that knows about lists at the same time.
05:13:11 <a-oXiDe> ah rite i want it to putStr rather than show
05:13:16 <astrolabe> dmhouse, I don't want to encode the length into its type.
05:13:22 <astrolabe> 13:00] astrolabe: is there a standard library that does peano arithmatic?  Something like 'data Nat = Zero | Succ Nat'?
05:13:42 <astrolabe> So, A single type holding all the natural numbers
05:14:09 <dmhouse> If you're not talking type-level nats I don't get the link to lists.
05:14:44 <astrolabe> dmhouse: I could then define peanoLength :: [a]->Nat
05:15:01 <dmhouse> How would that work on infinite lists?
05:15:11 <astrolabe> dmhouse: lazily
05:15:25 <dmhouse> Ah, okay, I see where this is going.
05:15:38 <dmhouse> Then you define (<) by unwrapping constructors and see which one runs out first.
05:15:53 <astrolabe> dmhouse: yes! :)
05:16:20 <dmhouse> So what you propose is essentially isomorphic to what I wrote, but you first convert a list of n elements to a repeated application of Succ, n times, to Zero.
05:16:31 <dmhouse> Then unwraps Succs instead of unwrapping (:)s.
05:16:31 <Pastorn_> astrolabe: how would it handle  len [0..] == len [0..]
05:17:02 <astrolabe> Pastorn: the value of that would be bottom, as now.
05:17:16 <dmhouse> Pastorn_: you can't really return any sensible result there.
05:17:42 <Pastorn_> well, they ARE of equal size
05:17:45 <dmhouse> Unless your algorithm attempts to construct a bijection and prove its bijectivity ;)
05:17:52 <Pastorn_> both are kappa big
05:18:02 <Pastorn_> or kappa-0
05:18:09 <dmhouse> Isn't it Aleph?
05:18:16 <Pastorn_> sorry
05:18:26 <Pastorn_> was so long ago...
05:18:27 <dmhouse> But okay; how do you know this? Because you can construct a bijection between the two lists.
05:18:37 <Pastorn_> yes
05:18:43 <dmhouse> If you can write an algorithm that constructs bijections, I'm impressed. :)
05:18:45 <astrolabe> dmhouse: isomorphic as far as what the computer has to work out, but I think Nat would be more flexible from a programming point of view.
05:19:13 <Pastorn_> dmhouse: induction perhaps?
05:19:40 <Pastorn_> how do you do WLG in haskell?
05:20:06 <astrolabe> Pastorn_: I suspect testing that two arbitrary lists have the same length is equivalent to the halting problem.
05:20:28 <Pastorn_> yeah... might be so...
05:20:47 <dmhouse> Sounds plausible.
05:20:53 * Pastorn_ goes to school now
05:20:55 <Pastorn_> bbiab
05:21:35 <dmhouse> > let lenEq = equating length in [1..10] `lenEq` [20..30]
05:21:37 <lambdabot>   Not in scope: `equating'
05:21:40 <dmhouse> Boo.
05:21:45 <dmhouse> > let lenEq = (==) `on` length in [1..10] `lenEq` [20..30]
05:21:47 <lambdabot>   Not in scope: `on'
05:21:58 <dmhouse> > let lenEq x y = length x == length y in [1..10] `lenEq` [20..30]
05:22:00 <lambdabot>  False
05:22:04 <dmhouse> > let lenEq x y = length x == length y in [1..10] `lenEq` [21..30]
05:22:06 <lambdabot>  True
05:22:12 <dmhouse> Halting problem solved :)
05:22:31 <nornagon> :)
05:28:43 <Saizan> you can't have uncountable lists in haskell
05:29:39 <Saizan> but with only the list you can't determine if it's finite or not :\
05:29:55 <Cale> You can't really have uncountable lists at all.
05:30:13 <Saizan> no?
05:30:40 <xs> lists have a countable number of elements
05:30:41 <Saizan> why?
05:31:42 <Saizan> so i can't say "the list of real numbers"
05:31:51 <pjd> finite lists have
05:33:34 <syntaxfree> Saizan: there's a ranges library somewhere.
05:33:38 <Cale> I suppose you could generalise "list" to uncountable ordinals, but that would be odd. Usually "list" implies that there's a function from natural numbers to the elements of some set.
05:33:40 <syntaxfree> @hoogle haskell ranges
05:33:42 <lambdabot> Did you mean: Haskell Ranges
05:33:42 <lambdabot> Prelude.undefined :: a
05:33:42 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
05:33:46 <syntaxfree> er.
05:33:51 <syntaxfree> @google haskell ranges
05:33:52 <lambdabot> http://mail.python.org/pipermail/python-dev/2000-August/008864.html
05:33:53 <lambdabot> Title: [Python-Dev] Lukewarm about range literals
05:33:58 <syntaxfree> @google hs-ranges
05:34:01 <lambdabot> http://www.springerlink.com/index/N37128446336311K.pdf
05:34:14 <Cale> (with finite lists, some initial segment of the naturals)
05:35:38 <astrolabe> I agree with Cale.  The elements of a list can be naturally put in 1-1 correspondance with an initial segment of the natural numbers.
05:38:10 <Saizan> ah, so it's just how they are defined, mmh uncountable lists would be quite odd to use probably
05:45:47 <pejo> Is there a reason nobench entry in lambdabot points to the code, instead of the project description page?
05:48:24 <xerox> pejo: it was added when the page didn't exist yet.
05:52:44 <pejo> And is nobench basically an extended nofib?
05:57:31 <ttmrichter> Quick, probably silly, question: is there any ASN.1 compiler/runtime pairing for Haskell?
05:59:57 <xerox> Yes.
06:01:04 <syntaxfree> any Pandoc users here?
06:01:50 <xerox> ttmrichter: http://www.haskell.org/crypto/
06:01:52 <lambdabot> Title: The Haskell Cryptographic Library
06:02:14 <ttmrichter> That doesn't seem to have an ASN.1 parser.
06:02:19 <ttmrichter> Only the BER/DER codecs.
06:02:40 <xerox> Hmmm, maybe shapr knows more.
06:03:26 <ttmrichter> I somehow suspect there is no such beast.  Most people "hand-compile" ASN.1 specs into the runtime codec stuff.  But this tends to be error-prone and fragile as standards evolve.  :(
06:09:12 <ttmrichter> Well, perhaps that gives me a project for Parsec.  ;)
06:09:18 <ttmrichter> Time to crack open the docs thereof.
06:09:39 <ADEpt> ttmrichter: I once wrote ASN.1 parser for fairly complete subset of '98 spec
06:09:45 <ttmrichter> Just one quick question before I go: is Parsec recursive-descent in overall architecture?
06:09:54 <ADEpt> ttmrichter: it is still lying in the haskell-libs somewhere
06:10:05 <ttmrichter> ADEpt, how difficult/easy was the task and which tools did you use?
06:10:36 <ttmrichter> Now that sounds interesting as a jumping-off point.
06:10:59 <ADEpt> ttmrichter: Parsec + JavaCC ASN.1 parser + sed/perl + large saw to saw off unused bits + 2-month supplement of curses and swears + ghc 6.4.2 .
06:11:20 <ttmrichter> JavaCC?
06:11:31 <ttmrichter> Or you started from the JavaCC grammar and moved it to Haskell?
06:11:45 <ADEpt> ttmrichter: exactly
06:11:47 <ttmrichter> And I understand fully the cursing and swearing.
06:12:05 <ttmrichter> I had to do a trial balloon for ASN.1 compilation using ANTLR.
06:12:14 <ttmrichter> ASN.1 is an ugly, ugly, ugly syntax.  :S
06:13:22 * ADEpt is try to google up the code
06:14:16 <ADEpt> ttmrichter: http://haskell-libs.cvs.sourceforge.net/haskell-libs/libs/asn1/
06:14:17 <lambdabot> Title: SourceForge.net Repository - [haskell-libs] Index of /libs/asn1
06:14:33 <ADEpt> ttmrichter: drop me a line if you manage to do something useful out of it, ok?
06:15:00 <ttmrichter> Not a problem, ADEpt.  If this goes the way I want it, I'll have a package in Hackage.  :)
06:17:17 <ADEpt> ttmrichter: I browsed the code. It IS ugly and I suspect that with ghc 6.6 one can get rid of DrIFT dependecy and streamline it quite a lot
06:18:16 <ttmrichter> I'm looking it over right now.  Sadly my Haskell skills aren't up to the point where I can casually read it.
06:18:47 <ADEpt> ttmrichter: Blame my style and decision to start from JavaCC grammar. Nowaday I can't read it casually either
06:19:25 <ttmrichter> Nah.  That's not the issue.
06:19:30 <ADEpt> ttmrichter: But I suspect that by adding a couple of automated tests to check for regressions it is refactorable
06:19:42 <ttmrichter> The issue is that Haskell still verges on executable line noise to my eyes at times.
06:20:13 <ttmrichter> I'm going to be trying to update it to ASN.1 2002.
06:20:17 <ttmrichter> Fun, fun, fun.
06:21:01 <ttmrichter> This is also somewhat of a test for me: can Haskell be more productive in this work than ANTLR was when I first tried it.
06:21:02 <Cale> dc is executable line noise :)
06:21:09 <ttmrichter> Dc?
06:21:25 <Cale> unix desk calculator
06:21:31 <ttmrichter> Oh, that thing.
06:21:33 <Cale> It's a simple stack language
06:21:35 <ttmrichter> I don't bother with it.
06:21:48 <Cale> It lets you use newline as a variable name
06:22:02 <ttmrichter> K and J are pretty much executable line noise as well.
06:22:54 <ADEpt> ttmrichter: if you'll make some headway, I suspect that I know a guy or even two who would be interested to join in and contribute, if you feel like it
06:23:17 <ttmrichter> That'd be nice.
06:23:39 <pejo> Without having read much - is CFA insanely hard in a higher-order language, and didn't Shivers's dissertation "fix" that in the early 90's?
06:23:44 <ttmrichter> Mostly I'd need people to hit me on the head with "WTF DO YOU THINK YOU'RE DOING, NEWB!?!"-style feedback.
06:24:09 <ADEpt> i dont frequent this channel recenty (it is a pure miracle that I spotted you request), but I believe my contract are in the README in that repo
06:24:29 <ttmrichter> I have a lot of respect for Haskell of a sudden.
06:24:48 <ttmrichter> My ANTLR recogniser alone was more lines of code than the Haskell I see here which seems to cover about as much of the spec as I did.
06:24:56 <ttmrichter> That's the ANTLR grammar file.
06:25:06 <ttmrichter> Not the generated Java or C++ code.
06:25:40 <ttmrichter> How did you deal with some of the ugly ambiguities in the spec?
06:26:02 <ttmrichter> I had to make liberal use of ANTLR's various predicates to get past some of the circularity issues.
06:26:11 <ADEpt> ttmrichter: i cheated :)
06:26:24 <ttmrichter> Well that's what ANTLR predicates do.  ;)
06:26:26 <ttmrichter> How did you cheat?
06:26:30 <ADEpt> ttmrichter: basically, i didn't (re)read the spec for starters
06:26:39 <ttmrichter> That helps.  :D
06:26:56 <ADEpt> ttmrichter: then i took the JavaCC source and used sed/perl to make semi-Haskell out of it
06:27:38 <ADEpt> ttmrichter: then I made it a proper haskell my hand and "derived" definitions for datatypes out of type signatures of separate parser functions (still with me?)
06:28:47 <ADEpt> ttmrichter: then I took a couple of large ASN.1 files I have (working for telecom, i have way too many of them for my liking) and tried to parse them.
06:29:42 <ADEpt> ttmrichter: Bughunt began. When i chased out all the bugs and found that I am able to parse all my files and data seem to be populated properly, I downloaded a couple of asn1-specs off the Internet and tried them too
06:30:31 <ADEpt> they were parsed, and I called it a day. Toyed with code since then, but never managed to cross-breed it with BER en/de-coded, which was my original goal
06:31:21 <ttmrichter> Pretty much my line of attack way back when.
06:31:24 <ttmrichter> Only different tool used.
06:31:29 <ADEpt> ttmrichter: all in all, majority of work took me two evenings to do
06:31:32 <ttmrichter> Same source of ASN.1 specs.
06:31:52 <ttmrichter> Took me a lot more than two evenings, though.  To be fair, however, I didn't start from a functioning grammar.  (I couldn't FIND one!)
06:32:11 <ttmrichter> I went from the spec.  Whose grammar is horribly ambiguous.
06:32:47 <ADEpt> yep
06:33:05 <ttmrichter> I remember my first draft I cranked the lookahead up to 5 symbols and *STILL* had circularity problems.
06:33:20 <ttmrichter> It was fun watching a 50-line spec occupy half a gig of RAM....
06:33:48 <ttmrichter> Predicates allowed me to take it down to 1 token lookahead except for certain trouble spots.
06:33:54 <ttmrichter> But still...  Really ugly.
06:34:24 <ttmrichter> And that was without all the weird additions they put in place to replace the old-style MACRO invocations.
06:34:47 <ttmrichter> Never got those working because the project got canned and a commercial C-based solution (OSS) was used instead.
06:37:05 <ADEpt> ttmrichter: I just tried and ghc-6.6 seems to build the things with "-fglasgow-exts --make" without requiring the preprocessing step with DrIFT. Which is good :)
06:37:18 <ttmrichter> What is DriFT?
06:42:25 <ADEpt> ttmrichter: among other things, a tool for generating instances of typeclasses automatically
06:42:48 <ADEpt> ttmrichter: nowadays i'd go with Template Haskell or try to stick with built-ins, though
06:42:57 <ttmrichter> And what in 6.6 removes the need for DriFT?
06:43:24 * ttmrichter thinks he'll just bull his way through without adding tools on top.
06:43:39 <ttmrichter> I get kind of ... antsy ... when I start relying on non-standard preprocessors.
06:45:22 <apfelmus> Cale: ping
06:45:28 <Cale> pong
06:45:58 <apfelmus> hi there! i'm reading moggi's paper.
06:46:09 <apfelmus> but i'm a bit lost.
06:46:49 <Cale> Have a question?
06:46:54 <Cale> Which paper, btw?
06:47:22 <apfelmus> Cale: the famous one. "Notions of computations and monads"
06:47:48 <apfelmus> my problem is how to treat functions types
06:48:22 <Cale> hrm, citeseer is down
06:49:07 <Cale> ah, here we go, the Singapore mirror is up
06:49:25 <Cale> what about them?
06:49:28 <apfelmus> i got it from reddit. http://www.disi.unige.it/person/MoggiE/ftp/ic91.ps.gz
06:49:38 <apfelmus> i mean i stumbled on it on reddit
06:50:14 <apfelmus> concerning the function types: given the kleisli-category with arrows (a -> T b), i want to internalise the arrows
06:50:17 <malcolm> hmm, DrIFT is a pretty standard preprocessor, it is Template Haskell that is non-standard (and non-portable)
06:51:20 <apfelmus> Cale: i.e. in the kleisli-category, we have objects a ~> b which correspond to side-effectfull functions
06:51:29 <Cale> arrows
06:52:05 <apfelmus> i mean the interpretation of the object (a ~> b) is the arrow (a -> T b) of our kleisli-category
06:52:51 <Cale> The Kleisli category, as far as I've seen it defined, has the same objects as the original category, but an arrow f: a -> b in the Kleisli category is an arrow a -> Tb in the original.
06:53:08 <apfelmus> yes.
06:54:07 <apfelmus> ah.
06:55:22 <apfelmus> mh. i somehow want to kick out function types (a -> b) from the normal catgeory and to introduce (a ~> b) instead
06:57:44 <ADEpt> ttmrichter: I use Data.Typeable and "derive Typeable", and they were not part of ghc prior to (I think) 6.4.x
06:58:53 <Cale> apfelmus: ah, function types do correspond to objects in the original category as well -- they're exponential objects: the type A -> B is denoted B^A
06:59:28 <Cale> (which should help interpret that paper perhaps)
07:00:32 <Cale> The notation B^A in the Kleisli category is unfortunately somewhat ambiguous, since it could refer either to the B^A in the original category, or the exponential object in the Kleisli category, which aren't the same thing.
07:00:46 <apfelmus> yes, that's exactly the point
07:01:23 <Cale> Does this come up as an issue in his paper?
07:01:41 <apfelmus> i don't know. but that's the reason why i'm reading it :)
07:02:18 <Cale> If it was up to me, I'd probably just decide that B^A meant the original B^A, and the exponential object in the Kleisli category would be denoted TB^A
07:03:02 <apfelmus> that's what i'd like to avoid. i mean, i want to kick out any distinction between pure and impure functions
07:03:56 <Cale> ah, okay
07:04:49 <Cale> Then you can only work in the Kleisli category, and specify that B^A means TB^A in the old category.
07:05:21 <Cale> pure functions can be considered as a subset of impure functions by composition with eta.
07:05:36 <apfelmus> yes. i should state my original intention, i want do something strange.
07:05:46 <apfelmus> i'd like to represent objects of the kleisli category by a GADT
07:06:08 <apfelmus> K a   <- object a of the kleisli category
07:06:24 <apfelmus> for instance, we have K Int and K (Int,Int) and so on
07:06:52 <apfelmus> now, we can interpret K a in our original category
07:07:01 <apfelmus> [K Int] = Int
07:07:09 <apfelmus> [K (Int,Int)] = (Int,Int)
07:07:26 <Cale> Er, not m Int ?
07:08:02 <apfelmus> ah, yes, i think that's the question.
07:08:18 <Cale> oh, right
07:08:25 <Cale> Yeah, that's a bit of a problem :)
07:08:31 <apfelmus> you said "no" because the objects of the kleisli category are the same as the old ones
07:08:32 <Pastorn_> ?src Prelude.sequence
07:08:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:08:36 <Cale> I suppose it's fine
07:08:43 <Pastorn_> ?src Control.Monad.sequence
07:08:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:08:51 <Pastorn_> help plz?
07:08:57 <Cale> K Int would correspond to Int, but you need special application
07:09:11 <apfelmus> yeah, i'm after the application
07:09:21 <Cale> sequence = foldr (liftM2 (:)) (return [])
07:09:30 <Cale> or:
07:09:40 <Cale> sequence [] = return []
07:10:04 <Cale> sequence (x:xs) = do {v <- x; vs <- sequence xs; return (v:vs)}
07:10:21 <apfelmus> the hole point of the story is of course [K (a -> b)] = [K a] -> T [K b]
07:11:18 <apfelmus> now, what does the application look like. is it internal, i.e. K ((a, a -> b) -> b)?
07:11:39 <apfelmus> or is it external? app :: K (a, a -> b) -> K b
07:13:11 <apfelmus> yeah, and that's already wrong.
07:13:12 <apfelmus> we can have app :: [K (a, a -> b)] -> T [K b]
07:13:49 <apfelmus> but i somehow don't want the interpretation layer
07:16:19 <Daveman> heh
07:19:28 <emk> I just spent the last day and a half trying to figure out why I couldn't get the math in a Bayesian monad to line up with Paul Graham's "A Plan for Spam".
07:20:31 <emk> Turns out that Graham's formula at http://www.paulgraham.com/naivebayes.html only works if we assume a prior probability distribution of <0.5,0.5>.
07:20:33 <lambdabot> Title: Probability
07:20:46 <zbrown> So newbie question: If I have a function 'askForNum' and it returns a list, how do i create a variable that is equal to the list that askForNum returns?
07:21:07 <pjd> foo = askForNum?
07:21:13 <zbrown> hmm
07:21:21 <pjd> or what do you mean?
07:21:57 <zbrown> well im doing the Yet Another Haskell Tutorial right now, trying to learn haskell, and to be honest its rather difficult for me to wrap my brain around the concept of functional programming... so many differences compared to working C lol.
07:22:04 <xerox> zbrown: is that a function that terminates in a IO [Int] type?
07:22:11 <malcolm> do n <- askForNum
07:22:16 <zbrown> xerox: im not sure what you mean?
07:22:53 <zbrown> malcolm: i get this error: ProdSumFact.hs:9:8: The last statement in a 'do' construct must be an expression
07:22:59 <boXiDe> what does an error saying No instance for (Show(IO ())) mean?
07:23:31 <malcolm> zbrown: so you need to actually do something with the list you have just bound
07:23:39 <kpreid> boXiDe: it means the code tried to 'show' an IO action
07:23:45 <pjd> boXiDe: it probably means you're trying to show an IO value directly
07:23:49 <malcolm> do { n <- askForNum; print n; }
07:23:56 <zbrown> malcolm: ooooh ok
07:24:05 <kpreid> boXiDe: which usually means you want to run it instead
07:24:38 <boXiDe> ok so how would i go about doing that?
07:25:45 <zbrown> malcolm: thats exactly what i needed, thank you.
07:26:11 <zbrown> The Yet Another Haskell Tutorial is a pretty good paper, but it leaves some of us detail oriented folk in the dark at times ;).
07:26:33 <Saizan> boXiDe: where do you get that error?
07:26:50 <boXiDe> when i try to run a function in ghci
07:27:18 <boXiDe> i can make it print out one line with IO(), then i try to make it print out multiple with [IO()] and it comes up with that error
07:27:36 <Saizan> ahh, so, you need sequence
07:27:52 <boXiDe> whats sequence?
07:28:07 <Saizan> because [IO ()] is just a list of actions and can't be executed in thet way
07:28:12 <Saizan> ?type sequence
07:28:17 <lambdabot>     Ambiguous occurrence `sequence'
07:28:18 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
07:28:23 <Saizan> ?type Prelude.sequence
07:28:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:28:43 <malcolm> >Prelude.sequence [print 2, print 3, print 4]
07:29:01 <Saizan> it's a function that can trasform your [IO ()] in a IO [()] so that your actions can be exacuted
07:29:22 <Saizan> you may want sequence_ in this case probably, that just discardes the ()s
07:29:30 <Saizan> ?type Prelude.sequence_
07:29:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:30:00 <Saizan> ?type Prelude.sequence_ [putStrLn "foo"]
07:30:03 <lambdabot> IO ()
07:30:09 <zbrown> If I need to perform a function on each item of a list, whats the best way to do this? I know in C or Java I'd iterate teh list and call the function but my experience tells me there's a more elegant way to do this in Haskell?
07:30:24 <Saizan> zbrown: use map
07:30:27 <Saizan> ?type map
07:30:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:30:34 <zbrown> ah right! i remember now
07:31:01 <zbrown> Saizan: I think I'll stay here. You guys are nicer than ##C lol
07:31:19 <Saizan> @quote tropical -- :)
07:31:20 <lambdabot> No quotes for this person. Where did you learn to type?
07:31:24 <Saizan> @quote tropical
07:31:25 <lambdabot> dons says: not sure that the irc culture outside happy lambda land is always so warm and tropical
07:31:29 <boXiDe> ahk cheers for that
07:31:36 <zbrown> haha its true
07:31:44 <Saizan> :D
07:32:07 <apfelmus> Cale: i think that's exactly the problem. we can see (x :: K a) as an expression representing an element of the object a in the kleisli category. now, i'd like to have
07:32:07 <apfelmus>   x :: K a, f :: K (a -> b)   |-   App f x :: K b
07:32:07 <apfelmus> But with [K (a -> b)] = [K a] -> T [K b], i cannot interpret these expressions anymore in a suitable form, namely by
07:32:08 <apfelmus>   eval :: K a -> [K a]
07:32:40 <boXiDe> out of interest for my IO problem it says a possible fix: add an instance declaration for (Show (IO())). what does this mean exactly?
07:33:00 <zbrown> Saizan: ok, another question about lists. If i want to just print one item of a list, what do I do?
07:33:37 <zbrown> or rather, i'll have to print them all
07:33:45 <zbrown> but I need to print them one at a time, and not as a group
07:34:00 <Saizan> boxide: when you ran a command in ghci, if it's not an IO action, it tries to use show on it to get a String representation of the value and print it
07:34:05 <Saizan> ?type show
07:34:08 <lambdabot> forall a. (Show a) => a -> String
07:34:39 <Saizan> zbrown: mmh one at a time but still all of them in the same way?
07:34:46 <zbrown> yes
07:35:02 <zbrown> Saizan: example "The factorial of <foo> is <foo!>"
07:35:07 <apfelmus> ?type mapM -- zbrown
07:35:08 <zbrown> thats what I'm looking to print
07:35:08 <Saizan> well, you can use mapM_
07:35:09 <lambdabot>     Ambiguous occurrence `mapM'
07:35:10 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
07:35:19 <apfelmus> ?type mapM_
07:35:21 <Saizan> ?type Prelude.mapM_
07:35:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:35:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:35:41 <mdmkolbe2> What is the easiest way to convert from Int32 to Double? (fromInteger didn't work)
07:36:20 <apfelmus> Cale: still there?
07:36:51 <zbrown> hmmm
07:37:13 <Saizan> so something like mapM_ (\num  -> putStrLn "The factorial of" ++ show num ++ " is " ++ show (fac num)) [1..5]
07:37:32 <emk> ?djinn [m a] -> m [a]
07:37:34 <lambdabot> -- f cannot be realized.
07:37:39 <Saizan> where fac is your factorial function of choice
07:37:52 <mdmkolbe2> @pointless fromInteger . toInteger
07:37:53 <lambdabot> fromInteger . toInteger
07:38:02 <emk> ?djinn Int -> Int -> Int
07:38:03 <lambdabot> f _ a = a
07:38:20 <zbrown> Saizan: what does [1..5] mean?
07:38:26 <Saizan> > [1..5]
07:38:29 <lambdabot>  [1,2,3,4,5]
07:38:30 <mdmkolbe2> ?djinn GHC.Int.Int32 -> Double
07:38:31 <lambdabot> -- f cannot be realized.
07:38:32 <Cale> apfelmus: yeah, sorry about that :)
07:38:42 <zbrown> Saizan: ah ok
07:39:02 <zbrown> Saizan: how could i tell it to do that say with the lenght of the list?
07:39:04 <apfelmus> Cale: any idea?
07:39:12 <zbrown> just use [1..length(foo)] ?
07:39:14 <emk> ?djinn String -> IO ()
07:39:15 <lambdabot> -- f cannot be realized.
07:39:16 <Cale> boXiDe: Your error means that you tried to 'show' an IO computation -- that is, turn it into a string.
07:39:57 <Saizan> zbrow: that [1..5] was just an example list, it's not like an iterator
07:40:13 <Saizan> zborw: you can just replace it with you list
07:40:16 <Cale> apfelmus: not really -- I usually just think of the Kleisli category as an abstraction which you'd use to think about the computations rather than something you'd program in directly.
07:40:25 <boXiDe> Cale: if it can print out a single one i dont understand the difference in printing out multiple lines?
07:40:35 <Cale> boXiDe: can I see your code?
07:40:42 <boXiDe> yeah
07:40:58 <Cale> apfelmus: You might want to look at the Kleisli constructor in Control.Arrow
07:41:17 <Cale> It allows you to work with the arrows in the Kleisli category reasonably well.
07:41:28 <Cale> Or else you can define Kleisli composition directly
07:41:55 <zbrown> Saizan: ah ok, thank you
07:42:09 <Cale> boXiDe: you can paste it here:
07:42:11 <Cale> ~paste
07:42:13 <Cale> !paste
07:42:14 <hpaste> Haskell paste bin: http://hpaste.org/
07:43:10 <apfelmus> Cale: well, the point is that i want to find syntactic sugar for arrows :)
07:43:24 <boXiDe> ahk 1 sec
07:43:38 <zbrown> Saizan: ProdSumFact.hs:9:8: The last statement in a 'do' construct must be an expression
07:43:52 <apfelmus> Cale: some way to split a and b from (a ~> b) such that they become standalone
07:43:56 <zbrown> Saizan: i got that error with this line of code:
07:44:07 <zbrown> mapM_ (num -> putStrLn("The factorial of " ++ show num ++ "is " ++ show(factorial num)) [foo])
07:44:40 <Saizan> mmh
07:44:53 <njd> @users
07:44:54 <lambdabot> Maximum users seen in #haskell: 329, currently: 318 (96.7%), active: 32 (10.1%)
07:45:10 <Saizan> first of all you have a misplaced prenteses
07:45:31 <Saizan> then, what's the type of foo?
07:45:47 <Cale> mapM_ (\num -> putStrLn ("The factorial of " ++ show num ++ " is " ++ show (factorial num))) [foo]
07:45:48 <zbrown> foo is a list of integers
07:45:59 <Cale> oh, then you don't want the brackets
07:46:02 <Cale> mapM_ (\num -> putStrLn ("The factorial of " ++ show num ++ " is " ++ show (factorial num))) foo
07:46:33 <zbrown> ah ok
07:46:39 <Saizan> mapM_ takes a function and a list, the function is your lambda, the list is foo
07:46:43 <zbrown> why is there a "\
07:46:46 <zbrown> before 'num'
07:47:09 <allbery_b> lambda abstraction
07:47:23 <zbrown> oic
07:47:25 <allbery_b> (an anonymous function taking a single argument, "num")
07:47:32 <Saizan> ah, that's a lambda, an anonymous function, e.g. double x = 2*x === double = \x -> 2*x
07:47:36 <zbrown> hmmm gotta go, thanks for the help Cale allbery_b Saizan
07:48:09 <allbery_b> "\" is the lame ASCII equivalent of a 
07:49:44 <Saizan> strange that yaht gives you IO before lambdas
07:50:35 <Cale> There was a while there when it was all the rage to put IO as early as possible in tutorials.
07:51:26 <dmhouse> It's a good idea to have it early.
07:52:31 <Saizan> but at least the syntax should come before :)
07:53:25 <dmhouse> You don't really teach syntax in a section on its own
07:53:46 <dmhouse> Apart from, perhaps, saying something as brief as 'Function application is written without parentheses, Haskell is case sensitive' etc.
07:54:42 <Saizan> mmh i remember a chapter on sections
07:55:13 <dmhouse> Well, yeah, sections and stuff need a section (haha) of their own, because there's so many permutations.
07:55:28 <Cale> I prefer the idea of putting IO quite a ways in.
07:55:38 <dmhouse> E.g. (!), (x !), (! x), (x `foo`) (`foo` x), ...
07:56:20 <Cale> I'd want to have most of the type system explained before IO.
07:56:31 <Saizan> you could introduce lambdas as an alternative form to a section
07:57:12 <Cale> I'd introduce lambdas at the same time as introducing functions.
07:58:53 <DynWind> yeah, lambdas aren't hard to understand --- they're just function literals
08:00:36 <Saizan> and they contribute to the first-class-function concept
08:02:09 <dmhouse> Cale: the idea is that people will dismiss Haskell as impractical if they can't do some simple IO early on.
08:02:27 <Cale> dmhouse: Show them interact :)
08:02:44 <DynWind> its more likely they'll get scared if you show them IO early on ;)
08:03:26 <dmhouse> Cale: yeah, that's what I've been doing.
08:03:30 <DynWind> when I wanted to show a friend how cool Haskell is, I showed him the fibonacci defined as a recursive list :)
08:04:31 <dmhouse> Cale: but how, for example, would one write a program using interact that asks for a name then prints "Hello, [name]"?
08:05:01 <apfelmus> \name -> "Hello, " ++ name ?
08:05:09 <Saizan> ?type interact
08:05:12 <lambdabot> (String -> String) -> IO ()
08:05:35 <Botje> it'd be interesting to see a tutorial start with io
08:05:44 <Botje> and introduce functions as needed
08:06:02 <int-e> dmhouse: \name -> "What's your name?\n" ++ (head name `seq` ("Hello, " ++ name)) ? ... it could work.
08:06:11 * emk is currently packaging up his probability monad examples
08:06:12 <int-e> dmhouse: probably doesn't :)
08:06:18 <cjay> ?users
08:06:18 <lambdabot> Maximum users seen in #haskell: 329, currently: 319 (97.0%), active: 37 (11.6%)
08:06:36 <Pastorn_> okay... i have something i DESPERATELY need help with...
08:06:38 <Pastorn_> @paste
08:06:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:06:49 <dmhouse> apfelmus: you need to print a prompter first.
08:07:17 <Cale> int-e: I think you need a takeWhile (/= '\n') or some such. It's awkward, but that's not the point anyway.
08:07:17 <apfelmus> the prompter should be supplied by interact
08:07:49 <int-e> Cale: yes, maybe. I wouldn't do it :)
08:07:51 <hpaste>  Pastorn pasted "Mastermind" at http://hpaste.org/662
08:08:02 <dmhouse> apfelmus: what do you mean?
08:08:14 <apfelmus> ?src interact
08:08:14 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:08:34 <Pastorn_> as is is now, reply gx sx gives Reply 1 2 where it SHOULD give Reply 1 1
08:08:34 <dmhouse> apfelmus: here's the spec. 1) Print "What's your name?". 2) Allow the user to type a name. 3) Print "Hello, [name]".
08:08:40 <Cale> dmhouse: The main answer is that you wouldn't :)
08:08:54 <Cale> dmhouse: At least, not until IO is covered.
08:09:01 <dmhouse> Cale: exactly, but something like this is the canonical simple IO program.
08:09:05 <Cale> There's plenty of interesting stuff you can do with just a REPL.
08:09:19 <apfelmus> dmhouse: ah, sorry. i thought "prompter" would mean the tiny "> " at the beginning of the line
08:09:37 <apfelmus> what's a REPL?
08:09:39 <dmhouse> Sure, but users are going to be asking "Why can't I write a program that greets me?"
08:09:44 <Cale> Read-Eval-Print-Loop
08:09:50 <apfelmus> thanks
08:09:51 <dmhouse> apfelmus: Read-Eval-Print Loop, a Lisp term.
08:09:55 <Cale> dmhouse: Why would they ask that?
08:10:11 <dmhouse> Cale: because most language tutorials start with a program like that; it's what people are used to writing.
08:10:24 <Pastorn_> how it should work: http://en.wikipedia.org/wiki/Image:Mastermind.jpg
08:10:28 <apfelmus> dmhouse: i think it might be worth considering writing our own "simplified IO module" for the wikibook
08:10:52 <dmhouse> If there was some important conceptual reason why basic do-blocks couldn't be introduced early I'd agree with you, but as it stands I think it's better to introduce do early.
08:11:17 <Cale> Pastorn_: what's the trouble?
08:11:17 <apfelmus> dmhouse: well, not before functions and types
08:11:44 <pejo> Nothing says that all of the type system has to be introduced early on, there could be just parts of it covered.
08:11:45 <Pastorn_> the second Int in Reply is colour matches but at the wrong place
08:11:51 <Cale> dmhouse: In order not to be horribly confused by IO, one needs to properly understand the difference between IO actions and other values.
08:12:03 <apfelmus> yeah the problem is about explaining what (IO a) should be
08:12:22 <apfelmus> unless you know what (a) is, there is no chance to get what (IO a) is
08:12:23 <xerox> "An action returning a value of type a" works for me.
08:12:24 <Pastorn_> Cale: trouble comes when you have a guess with two of the same colour but only one in the soloution
08:12:28 <Cale> It's much easier for people to understand how IO works once they understand how types work.
08:12:39 <dmhouse> I think IO should come before types.
08:12:52 <apfelmus> that would be detrimental
08:12:59 <dmhouse> Then introduce types, then typeclasses and so on, then monads, then link back to IO.
08:13:14 <pejo> Cale, I don't understand IO, but I would say I understand types fairly well.
08:13:32 <Cale> pejo: You're probably ready to learn about IO then :)
08:13:35 <Botje> Pastorn_: what's up with filter (True==) ? in equals?
08:13:36 <dmhouse> The idea is we give the user some practical experience before dragging them through chapters of hardcore theory.
08:13:37 <pejo> Cale, so all this enlightenment hasn't struck me.
08:13:57 <dmhouse> pejo: do you understand type classes?
08:13:57 <Cale> IO is harder than types by far.
08:14:28 <pejo> dmhouse, not sure. I haven't tried that hard either.
08:14:32 <dmhouse> Cale: I'm not pretending we introduce much at all. Just putStrLn, getLine, and do-block syntax.
08:14:39 <mdmkolbe2> @source Graphics.Rendering.OpenGL.GL.Bitmaps
08:14:39 <lambdabot> http://darcs.haskell.org/packages/OpenGL/Graphics/Rendering/OpenGL/GL/Bitmaps.hs
08:14:55 <Pastorn_> Botje, used for counting the exact matches
08:14:57 <apfelmus> dmhouse: well, i think that IO and IO are different things. with a custom IO-library, we can give the reader a plethora of IO-performing programs without him seeing the type (IO a)
08:15:06 <Pastorn_> in order to be able to filter...
08:15:32 <Botje> Pastorn_: but you've already reduced the list to a list of booleans
08:15:53 <Botje> ohwell
08:15:55 * Botje looks further
08:16:05 <Cale> Pastorn_: so you want to partition the pairings of the guess with the solution into ones which match and ones which don't, and then continue with the ones which don't to see if there are any that are the same colour, but in the wrong position.
08:16:32 <Cale> (but it's important to have removed the matching ones before that)
08:16:42 <pejo> dmhouse, how on earth do you decide that you've understood something? :-)
08:16:51 <Pastorn_> Cale: yes
08:17:18 <Pastorn_> Cale: no, "- eq" fixes that
08:17:28 <Botje> Pastorn_: a fix would be to do g <- nub gs
08:17:31 <lupo__> dmhouse: do i understand correctly that you are the maintainer or a major contributor to the wikibook?
08:17:40 <Pastorn_> Botje, no, lemme show you
08:17:43 <Cale> Pastorn_: well, yeah, I suppose you can handle it that way too :)
08:18:01 <Pastorn_> gy = [Blue, Blue, x , y]
08:18:18 <Pastorn_> sx = [ a , b , Blue, Blue ]
08:18:27 <Pastorn_> should give Reply 0 2
08:18:31 <Cale> length (filter (\x -> any (== x) solution) guess)
08:18:44 <Cale> not quite :)
08:19:11 <Cale> Because you have to remove things from the solution once they've matched in the guess.
08:19:34 <Cale> I suppose your count does the trick
08:19:45 <Pastorn_> can't... i have guidelines for these functions, so I can't change the types
08:20:04 <dmhouse> lupo__: yeah, I'm a contributor.
08:20:14 <Cale> Let's see...
08:20:28 <Cale> > intersect [1,1,2,3] [2,1,1,1]
08:20:30 <lambdabot>  [1,1,2]
08:20:36 <Cale> looks alright.
08:20:45 <Cale> > length $ intersect [1,1,2,3] [2,1,1,1]
08:20:47 <lambdabot>  3
08:21:20 <lupo__> dmhouse: okay, i'm a noob and i was working through the wikibook. you're surely right when IO comes after type basics. i understood it directly and it was good not to be bothered with too much theory in advance.
08:21:25 <Cale> > intersect [1,2,2,3] [1,3,3,4]
08:21:27 <lambdabot>  [1,3]
08:21:36 <Pastorn_> > (length $ intersect [1,1,2,3] [2,1,1,1]) - (length . filter (True==) $ zipWith (==) [1,1,2,3] [2,1,1,1])
08:21:38 <lambdabot>  2
08:26:34 <apfelmus> lupo__: interesting. can you elaborate on what you think would have been (or is) too much theory, so that i get an impression how you conceive the wikibook currently?
08:27:56 <apfelmus> i mean there can be too much theory because there are no interesting examples
08:28:03 <apfelmus> or because it's too abstract
08:28:27 <lupo__> apfelmus: right now i can only give my opinion on the "haskell basics" part
08:28:44 <Pastorn_> Cale: any idea how I do to make reply gx sx = Reply 1 1
08:28:46 <apfelmus> yeah, that's fine, i'm eager to hear it :)
08:29:25 <Cale> Pastorn_: didn't we just figure that out?
08:30:02 <Pastorn_> no
08:30:20 <Cale> reply gs ss = Reply eq (near - eq) where eq = length . filter id $ zipWith (==) gs ss; near = length $ intersect gs ss
08:30:55 <emk> Where in the Haskell library hierarchy would a probability type fall?
08:30:56 <lupo__> apfelmus: i liked it very much, it's straightforward and balances theory and practice quite well
08:31:06 <Pastorn_> Cale: that's just the problem... I HAVE to make use of count...
08:31:13 <emk> I can see something like Data.Probability, but is there a better place to put it?
08:31:14 <xerox> emk: you can use @hoogle type
08:31:15 <Cale> why?
08:31:26 <emk> xerox: It doesn't exist yet. I'm writing a proposal.
08:31:29 <xerox> emk: ah, I thought you were searching for a pre-existing one.
08:31:33 <apfelmus> lupo__: can you give examples of what you conceived as theory and as practice?
08:31:37 <Pastorn_> cause I have  a crazy teacher
08:31:49 <Cale> Using count makes things awkward, but I suppose you can do it.
08:32:13 <Cale> You need to, for each colour, determine the minimum of the two counts for the gs and ss.
08:32:14 <Pastorn_> that's just it... once i make a match I want to eliminate that match from ss
08:32:57 <Pastorn_> maybe some kind of recursion?
08:33:07 <Cale> near = sum [min cg cs | c <- [Red .. White], let cg = count c gs; cs = count c ss]
08:34:24 <Cale> That's a silly way to do it, but it should work.
08:35:57 <Pastorn_> ?src min
08:35:57 <lambdabot> min x y = if x <= y then x else y
08:36:01 <Pastorn_> oh, right
08:36:23 <lupo__> apfelmus: for the sake of discussion, i will call theory "anything that is a concept not explicitly written down when writing a program". i'd say types are theory. i liked it, they have been introduced in a gentle manner.
08:36:38 <Botje> unmatched = [ s | s <- ss | g <- gs, g /= s ]
08:37:50 <lupo__> apfelmus: i also got the IO stuff immediately
08:38:40 <pejo> I tried checking out nobench, and it's 273 patches - taking quite some time. Even with --partial. Is there a way around that?
08:40:00 <lupo__> i found it clever to introduce type basics and then io without delving into types too deep. from what i understand is that haskell is a type heaven (or hell?) and that can be gradually learned
08:40:34 <apfelmus> lupo__: ok. would you say that the chapter about IO was theory because IO is a concept? or do you think it's more like practice, because you can write programs that do something? is the IO chapter the first one about programs doing something
08:40:51 <pejo> lupo, but the beginner will make lots of type errors. So it's not sufificient to just ignore it.
08:41:41 <apfelmus> concerning types, well, indeed you need just Int, -> and [a] to begin writing useful programs
08:41:43 <augustss> pejo: the repo has no checkpoints so there's nothing to do.  --partial doesn't help
08:42:53 <pejo> augustss, are you the author of the queens.hs in there btw?
08:43:02 <boXiDe> is there a function to replace an item in a list?
08:44:12 <lupo__> apfelmus: the IO chapter is the first chapter that, viciously speaking, makes haskell appear more real-world-related than prolog. :) seriously, i understood why IO is too be handled differently than usual functions. what i still don't understand is using pure functions on the input i get or vice versa parsing real world values to pure functions. i still don't get that and as long as i don't get that, i don't know how to connect my pure ivory
08:44:28 <wkh>  > 2+2
08:44:34 <wkh> > 2+2
08:44:35 <lambdabot>  4
08:44:46 <augustss> pejo: it's possible.  i've not looked at all the programs
08:44:58 <wkh> > fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
08:44:59 <lambdabot>  Parse error
08:45:06 <wkh> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
08:45:06 <lambdabot>  Parse error
08:45:09 <lupo__> wkh: your math course was long ago? :-P
08:45:14 <augustss> pejo: i've probably written several of them
08:45:23 <Cale> lupo__: your message ended: "i don't know how to connect my pure ivor"
08:45:36 <Cale> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:45:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:45:42 <pejo> augustss, well, thank you anyways! (Says grabbed from LML dist). People seem obsessed with having infinite lists in them.
08:45:55 <lupo__> Cale: oops. it is: i don't know how  to connect my pure ivory tower functions to values from the outside.
08:45:56 <apfelmus> lupo__: you mean that it's not clear why you need pure functions if IO is all you want, so to speak?
08:46:11 <Cale> lupo__: ah, you can do that from inside an IO action
08:46:39 <Cale> lupo__: consider something like  do { x <- getLine; putStrLn (reverse x) }
08:46:47 <Cale> reverse is a pure function acting on strings.
08:47:08 <Cale> Or, to make the separation a little more explicit,
08:47:10 <lupo__> IO String, isn't it?
08:47:20 <apfelmus> ?type reverse
08:47:21 <Cale> do { x <- getLine; let y = reverse x; putStrLn y }
08:47:23 <lambdabot> forall a. [a] -> [a]
08:47:27 <Cale> x :: String here
08:47:34 <Cale> getLine :: IO String
08:47:43 <apfelmus> ?type putStrLn
08:47:46 <lambdabot> String -> IO ()
08:48:04 <Cale> (this is why I say understanding types is crucial :)
08:48:31 <emk> ?src Control.Monad.Error.MonadError
08:48:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:48:43 <lupo__> sorry, why is when i have "x <- getLine"  x of type String and getLine of IO String ? shouldn't x assume the type of that what comes out from the expression after "<-" ?
08:49:21 <apfelmus> lupo__: no, that's the point. x = would do that, but x <- in a do block is different
08:49:37 <fons> I?'m translating a grammar to an AST in Haskell. In Haskell we have lists to express {}* (where * indicates xero or more), Maybe to express {}? ( where ? indicates optional), but how about {}+ (where + indicates one or more)?
08:49:46 <Cale> lupo__: x <- y will run the action y to produce the value x
08:50:14 <Cale> If we'd written  let x = getLine, then x would just be the same action as getLine, and wouldn't be a string
08:50:18 <emk> Hmm. Does anybody know where the online copy of the Haskell standard library source code lives?
08:50:20 <apfelmus> fons: roll your own. data List1 a = One a | Cons a (List1 a)
08:50:21 <lupo__> Cale: and then i can apply pure functions to x, right?
08:50:27 <Cale> lupo__: yeah
08:50:27 <apfelmus> @where libs
08:50:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:50:31 <emk> Thanks!
08:50:57 <lupo__> Cale: fine then. and i need the do block to impose an order on what's done?
08:51:12 <fons> apfelmus, yep that's what I'm doing now, but just wanted to check if there was sothing in the stanbdard libraries, reusing is always a good idea
08:51:21 <emk> apfelmus: Oh, wait. That's the docs. I'm looking for the Darcs repository, because some of the details aren't in Haddock.
08:51:26 <Cale> lupo__: Yeah, you need it to glue the IO actions together into a larger one.
08:51:26 <twb> Has anyone debianized shim?
08:51:32 <apfelmus> fons: nothing i'm aware of
08:52:04 <wkh> how do i generate an infinite stream consisting of the fibonacci sequence in lambdabot?
08:52:09 <apfelmus> emk: oh, sorry. mh, you can look in the ghc sources
08:52:11 <lupo__> Cale: ah i see. i need to write a small test program right now. :)
08:52:11 <apfelmus> @where ghc
08:52:12 <lambdabot> http://haskell.org/ghc
08:52:15 <apfelmus> @where sources
08:52:16 <lambdabot> I know nothing about sources.
08:52:21 <apfelmus> @where darcs
08:52:21 <lambdabot> http://darcs.net/
08:52:32 <emk> apfelmus: OK, I'll track that down. Thanks!
08:52:38 <Cale> :)
08:52:51 <xerox> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:52:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:53:39 <apfelmus> emk: my knowledge < lambdabot's knowledge. strict inequality because i don't know how much lambdabot knows
08:53:40 <wkh> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:53:43 <wkh> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:53:44 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:53:54 <wkh> selecta!
08:53:56 <Cale> http://hpaste.org/620
08:54:31 <Cale> (If you want the really sophisticated way to generate specific fibs quickly :)
08:55:02 <jix> > Data.List.nubBy (\a b -> b `mod` a == 0) [2..]
08:55:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
08:55:57 <Cale> @pl (\a b -> b `mod` a == 0)
08:55:57 <lambdabot> flip flip 0 . ((==) .) . flip mod
08:56:00 <Cale> heh
08:56:20 <xerox> ((0 ==) .) . `flip mod` -- :-)
08:56:37 <jix> what does @pl do?
08:56:54 <Cale> Converts code into points-free form
08:57:36 <Cale> @pl (\x -> f (g x))
08:57:37 <lambdabot> f . g
08:57:48 <wkh> :O
08:57:52 * wkh has much to learn
08:58:18 <xerox> ?type flip $ ((0==) .) . mod
08:58:21 <lambdabot> forall a. (Integral a) => a -> a -> Bool
08:58:36 <xerox> flip flip 0 is really weird.
08:58:55 <wkh> ?type flip flip 0
08:58:57 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
08:59:15 <apfelmus> ?type flip . flip
08:59:18 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
08:59:38 <xerox> ?pl flip . flip
08:59:39 <lambdabot> id
09:00:10 <apfelmus> ?type flip flip
09:00:12 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
09:00:15 <jix> @pl (\a b -> 0 == b `mod` a)
09:00:16 <lambdabot> ((0 ==) .) . flip mod
09:00:28 <xerox> Good.
09:02:15 <augustss> ?type flip flip flip
09:02:17 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
09:02:28 <augustss> ?type flip flip flip flip
09:02:31 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
09:02:41 <lupo__> oh. any hint (URL, keyword, ...) on type conversion, [Char] to Num?
09:02:52 <wkh> so do you guys just use haskell to write brilliant one-liners? :)
09:03:05 <augustss> @djinn (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
09:03:05 <lambdabot> f a b = a b (\ c d e -> c e d)
09:03:17 <augustss> @djinn (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
09:03:17 <lambdabot> f a b = a b (\ c d e -> c e d)
09:03:36 <Cale> lupo__: read?
09:03:36 <augustss> strangely, flip flip flip == flip flip flip flip :)
09:03:41 <lupo__> Cale: ouch. thx.
09:04:04 <Cale> wkh: hehe, seems that way :)
09:04:36 <augustss> wkh: one line should be enough for anyone ;)
09:05:24 <Cale> One line is a luxury! Back in the day, we only had one character!
09:06:21 <augustss> And it was poisonous!
09:06:36 <Oejet> Lemmih: PING
09:06:38 <Saizan> and it was only whitespace!
09:08:31 <emk> Huh. The standard mtl library needs -fallow-undecidable-instances in quite a few places.
09:08:46 <wkh> it seems there are many higher-order functions in the standard library that subsume many, many common idioms that a newbie like me would have to spend many LOC writing
09:09:05 <wkh> and that i would unknowingly write out assuming they didn't exist
09:09:18 <emk> wkh: If you know the type of function, just type it into Hoogle.
09:09:22 <emk> E.g.:
09:09:34 <emk> ?hoogle [m a] -> m [a]
09:09:35 <lambdabot> Prelude.head :: [a] -> a
09:09:35 <lambdabot> Prelude.last :: [a] -> a
09:09:35 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
09:10:07 <emk> Err, that's not a very complete hoogle.  Try here: http://www.haskell.org/hoogle/
09:10:08 <lambdabot> Title: Hoogle
09:10:21 <Cale> wkh: indeed -- the most important of these to learn right away are map, filter and foldr
09:10:29 <Cale> zip/zipWith is also rather handy
09:11:13 <Cale> Once you start really getting into the list and monad libraries, there's some rather crazy stuff you can do very elegantly :)
09:11:27 <Cale> > filterM (const [False, True]) [1,2,3,4,5]
09:11:29 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
09:11:37 <Cale> > filterM (const [True, False]) [1,2,3,4,5]
09:11:38 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,...
09:11:44 <augustss> wkh: a good way is to re-read the library code now and then to see if there's something you recognize as useful
09:12:05 <Cale> > sequence [[1,2,3], [4,5], [6,7,8]]
09:12:12 <Cale> > Control.Monad.sequence [[1,2,3], [4,5], [6,7,8]]
09:12:14 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
09:12:23 <Cale> (got to get that fixed :)
09:13:11 <Cale> > [replicate k ['a'..'z'] | k <- [1..]] >>= Control.Monad.sequence
09:13:12 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
09:13:18 <Cale> > [replicate k ['a'..'c'] | k <- [1..]] >>= Control.Monad.sequence
09:13:20 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
09:14:08 <Cale> > concat [replicateM k ['a'..'c'] | k <- [1..]]
09:14:09 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
09:15:12 <wkh> Cale: what is the biggest/most impressive/most useful/most substantial Haskell program you have written?
09:15:37 <Cale> wkh: I'd say that's probably still the pipeline scheduler for PPC/Altivec which I wrote.
09:15:57 <wkh> is that in GHC?
09:16:21 <Cale> No, it was part of a project to create a signal-processing language called Coconut.
09:17:35 <Lemmih> Oejet: pong.
09:18:55 <Oejet> Lemmih: I have been looking for some good SDL documentation (libsdl.org is quite confusing to me), and thought you might know some?
09:19:37 <wkh> does Haskell support the creation of embedded domain-specific languages?
09:20:25 <Lemmih> Oejet: The doc-wiki is the best there is.
09:20:39 <wkh> i wanted to make a little language for generating boilerplate code for data-driven web applications and i thought it would be a good way to learn Haskell, which I've been meaning to do for a couple years
09:20:55 <Cale> wkh: It supports that excellently
09:21:03 <Oejet> Lemmih: OK, thanks.
09:21:48 <Cale> These terms you hear thrown around like monads and arrows, applicative functors, etc. are all just slightly fancy way to structure DSLs so that they can share control structures.
09:21:50 <zeeeee> i wrote coin denomination in haskell, but it gets a stack overflow when i try n=999999. is this due to a recursive implementation of map? i also wrote it in python, where it works fine. http://rafb.net/p/K8coui94.html
09:21:52 <lambdabot> Title: Nopaste - coin denomination problem
09:22:25 <pjd> higher-order higher-order functions
09:23:20 <Cale> zeeeee: try replacing that minimum with foldl1' min, and see if it makes a difference.
09:23:25 <zeeeee> questions: i tried -O2; that removed the overflow, but it never terminates (it's been running for >5 minutes now). is there any way to get around these problems in haskell?
09:23:30 <Cale> and import Data.List
09:23:45 <Cale> oh, let me try it
09:24:14 <Cale> oh, that minimum is of at most 4 elements, nevermind
09:24:17 <zeeeee> Cale: no, that made no difference
09:24:28 <zeeeee> right
09:24:57 <mightybyte> Why are ghc binaries so hugeL
09:25:01 <mightybyte> ?
09:25:21 <zeeeee> if the compiler were smart, the stack could be bounded as a constant
09:25:21 <Cale> mightybyte: they're statically linked against the RTS
09:25:42 <mightybyte> Cale: Ahh, what's RTS?
09:25:51 <Cale> runtime system
09:25:59 <mightybyte> Ok
09:26:38 <mightybyte> Why not do dynamic linking?
09:27:33 <mightybyte> We've got lazy evaluation.  It doesn't seem like lazy linking would be too hard.
09:28:07 <Pastorn_> ?src all
09:28:07 <lambdabot> all p =  and . map p
09:28:45 <emk> Does anybody understand MonadFix?
09:29:39 <xerox> emk: yes.
09:30:00 <emk> xerox: Should I just go read the original paper, or is there a better tutorial?
09:30:02 <wkh> > not $ all even [2, 4, 6, 8]
09:30:04 <lambdabot>  False
09:30:10 <wkh> > not $ all even [2, 4, 6, 8, 9]
09:30:11 <lambdabot>  True
09:30:19 <wkh> holy resemblance to plain English, batman
09:30:26 <Cale> mightybyte: nobody's done it on most platforms is all
09:32:09 <mightybyte> Ok
09:32:42 <xerox> emk: I don't know of better tutorials.
09:33:17 <emk> xerox: Thanks! I'm trying to define a reasonably complete MaybeT, and some of the weirder transformers are giving me a headache. :-/
09:34:12 <xerox> :-)
09:34:17 <Cheery> Is there a way to implement static typing with inference without it being too hard to implement?
09:35:02 <pejo> Cheery, basic Hindley-Milner isn't that complicated. The book on Simon Peyton Jones homepage contains Miranda code for it too.
09:36:43 <Cheery> thanks.
09:38:48 <alxb> hi
09:38:52 <alxb> how do I generate a random Float?
09:39:28 <Cale> @type randomRIO
09:39:31 <hyrax42> ?index System.Random
09:39:31 <lambdabot> forall a. (Random a) => (a, a) -> IO a
09:39:32 <lambdabot> bzzt
09:39:39 <hyrax42> I mean
09:40:02 <hyrax42> ?docs System.Random
09:40:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
09:40:15 <Cale> :q
09:40:18 <Cale> oops :)
09:40:36 <alxb> any idea if this is this included in MinHugs?
09:40:45 <hyrax42> hmmm where can I read what the semantics of Control.Concurrent.Chan are
09:40:50 <wkh> ?source List.replicate
09:40:50 <lambdabot> List.replicate not available
09:41:01 <hyrax42> does writeChan block?
09:41:06 <augustss> zeeeee: Haskell arrays can be quite space consuming.  You get a small improvement (i.e., it runs it about 25s) if you declare 'coinDenom :: Int->Int'
09:41:14 <Cale> zeeeee: profiling shows that f is entered 43348 times. It seems probable that calls to f are piling up on the stack with nothing being returned.
09:43:49 <wkh> ?source Data.List.replicate
09:43:49 <lambdabot> Data.List.replicate not available
09:43:54 <hyrax42> nobody on Chan?
09:44:10 <Cale> hyrax42: I don't think so
09:44:10 <hyrax42> ?src replicate
09:44:10 <lambdabot> replicate n x = take n (repeat x)
09:44:16 <Cale> hyrax42: readChan would though
09:44:37 <hyrax42> so what happens if multiple threads try to write to the Chan?
09:44:43 <hyrax42> I should be thinking of TChans?
09:45:22 <fasta> Another heisenbug: internal error: interpretBCO: unknown or unimplemented opcode 7976
09:45:23 <fasta>     (GHC version 6.6 for i386_unknown_linux)
09:45:23 <fasta>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
09:45:25 <lambdabot> Title: 1.2. Reporting bugs in GHC
09:45:27 <augustss> Cale: I tried a version of zeeeee's code that forced all array elements before returning a!n.  It runs much, much faster.  I find that a little surprising.
09:45:33 <Cale> zeeeee: There's an easy way to ensure that the calls don't build up -- simply force that the elements of the array
09:45:37 <Cale> -that
09:45:46 <Cale> augustss: it's not surprising :)
09:45:54 <fasta> Seems like a hardware failure...
09:46:14 <Cale> augustss: think about what happens when you index the array at n -- you're going to start building a gigantic recursive expression involving f
09:46:16 <augustss> Cale: actually, I think i 30 time speedup is
09:46:50 <Cale> Well, surprising in the sense that you didn't expect it?
09:46:54 <fasta> Hmm, I can reproduce it.
09:47:03 <fasta> But now: interpretBCO: unknown or unimplemented opcode 24360
09:47:12 <Cale> !paste
09:47:12 <hpaste> Haskell paste bin: http://hpaste.org/
09:47:29 <hpaste>  Cale pasted "for zeeee" at http://hpaste.org/663
09:47:50 <sorear> hello
09:47:54 <augustss> Cale: I expected the stack consumption to go away, but not the drastic decrease in run time
09:48:01 <Cale> This will cause the expressions to get reduced in a bottom-up fashion
09:48:06 <Cale> ah
09:48:07 <Cale> okay
09:49:10 <Cale> The reason that the python code works so well is that the expressions are reduced immediately as the array is being constructed.
09:49:21 <Cale> and so they never get very large
09:52:25 <fasta> Bug reported.
09:52:30 <Cale> augustss: perhaps the lower memory consumption?
09:52:52 <augustss> Cale: perhaps
09:55:32 <Cale> coinDenom 9999999 takes about 3 minutes to complete on my machine now.
09:58:15 <Cale> This seems like a rather inefficient solution to the problem as a whole though.
09:58:37 <Cale> Especially when the greedy algorithm always works.
09:59:17 <Cale> (as is the case with ordinary coin denominations)
10:01:36 <augustss> Cale: outside Russia, you mean :)
10:01:42 <Cale> augustss: yeah
10:03:35 <pejo> More people awake now - I'll try reasking the same question again. Without having read much, I bumped by the slides for MLton. They imply that CFA for a higher order language is difficult. Isn't this what Shivers's dissertation did in the early 90's?
10:03:36 <Cale> The greedy algorithm takes 4 milliseconds on my machine
10:03:38 <glguy> ?seen Lemmih
10:03:38 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 43m 13s ago.
10:04:00 <Cale> (for 9999999)
10:04:41 <Lemmih> glguy: Yes?
10:05:16 <augustss> Cale: I don't trust the ghc arrays.  The original code for 999999 takes 85s with ghc and 6.7s with hbc
10:05:51 <Pastorn_> @google hbc haskell
10:05:53 <lambdabot> http://www.cs.chalmers.se/~augustss/hbc/hbc.html
10:05:53 <lambdabot> Title: The HBC compiler
10:06:06 <Pastorn_> don
10:06:29 <augustss> pejo: yes, that's what Olin did, but it's very inefficient
10:06:31 <Pastorn_> nevermind...
10:07:01 <emu> this is probably a dumb question. is there a XOR operator?
10:07:04 <emu> logical
10:07:04 <pejo> augustss, so the problem is solved, but the analysis takes too much time?
10:07:57 <Pastorn_> augustss: does this page exist? ftp://ftp.cs.chalmers.se/pub/haskell/chalmers/KnownBugs
10:07:57 <glguy> @seen shapr
10:07:58 <lambdabot> I saw shapr leaving #scannedinavian, #haskell and #happs 10h 35m 15s ago, and .
10:07:58 <augustss> pejo: yes, solved in some sense
10:08:25 <pejo> Pastorn, http://www.cs.chalmers.se/pub/haskell/chalmers/KnownBugs
10:08:35 <augustss> Pastorn_: Chalmers has shut down the ftp server, so you need http
10:08:45 <Pastorn_> ok
10:09:21 <augustss> Cale: with forcing the array the time went from 6.7s to 3.6s with hbc.  This is what I expected.
10:10:08 <pejo> augustss, ah, thanks.
10:10:59 <augustss> Cale: whereas forcing with ghc foes from 85s to 5.8s
10:11:18 <sorear> @users
10:11:19 <lambdabot> Maximum users seen in #haskell: 329, currently: 325 (98.8%), active: 43 (13.2%)
10:11:23 <augustss> Cale: I think 'array' in ghc must be very poorly implemented
10:11:32 <Cale> augustss: hmm
10:13:49 <augustss> Cale: because I know they are not as efficient as they could be in hbc
10:17:44 <astrolabe> emu: I think you are supposed to use (/=)
10:21:43 * emu smacks self
10:22:17 <zeeeee> augustss, Cale: sorry, stepped away - i did actually enter Int->Int in my actual program, i didn't include that in the paste
10:22:19 <Pastorn_> How's that OS voting going?
10:22:43 <zeeeee> Cale: it's actually six 9s, not five 9s, that's problematic. also, i don't know what difference it makes that you hardcode the constant into your program.
10:23:16 <augustss> zeeeee: hardcoding shouldn't make any difference.  ghc isn't that smart
10:23:49 <zeeeee> augustss: ghc doesn't do constant folding?
10:24:20 <zeeeee> (i'm still trying to understand the seq solution)
10:24:33 <augustss> zeeeee: sure, but you'd have to do some fairly sphisticated things for that to make much difference
10:25:26 <augustss> zeeeee: the only thing seq does is to force the array elements in order so you don't pile up so much stack
10:26:00 <augustss> zeeeee: but IMO using seq shouldn't make that much of a difference
10:27:55 <zeeeee> ah, i think i see now - in the original, f is recursively called because we start at a!n, which recurses into lower elements of a, etc. but with foldr seq, we're building the array low to high.
10:28:14 <zeeeee> and lastly we look up a!n
10:28:55 <augustss> zeeeee: right
10:29:46 <zeeeee> awesome, thanks a lot
10:31:21 <Saizan> boxed/lazy arrays are quite tricky
10:31:43 <monochrom> they're quite natural
10:33:11 <zeeeee> Cale: how did you determine that f was being recursively called many times? (how did you profile?)
10:34:16 <zeeeee> did you just use ghc -prof -auto-all, then +RTS -p?
10:37:18 <_|_> I just learned that it's a legal nick :)
10:37:44 <astrolabe> Who is the mysterious bottom?
10:37:52 <glguy> 12:34 (*) monochrom is now known as _|_
10:37:56 <xerox> astrolabe: it's a decolored one
10:38:03 <zeeeee> Cale: the reason i ask is because i always seem to see the same # entries into all the functions, regardless of whether i use my orig or your seq solution
10:38:08 <astrolabe> Ah
10:38:29 <zeeeee> so i wouldn't have been able to tell where the stack explosion was originating
10:39:01 <Botje> zeeeee: laziness.
10:39:16 <zeeeee> Botje: what?
10:39:16 <Botje> if you don't evaluate something, haskell stores a piece of code to calculate the value
10:39:17 * _|_ loves laziness.  laziness loves _|_
10:39:18 <pjd> " :Erroneous Nickname"
10:39:22 <pjd> phooey
10:39:29 <zeeeee> Botje: yes...but i was getting a stack overflow?
10:39:33 <Botje> zeeeee: yes.
10:39:38 <Botje> because that code takes up stack space too.
10:39:41 <Botje> observe:
10:39:49 <Botje> > foldl (+) 0 [1..1000000]
10:39:52 <lambdabot>  500000500000
10:39:59 <Botje> silly code, overflow.
10:40:03 <Botje> > foldl (+) 0 [1..10000000000]
10:40:07 <lambdabot> Terminated
10:40:17 <Botje> bleh;
10:40:21 <Botje> anyway:
10:40:25 <zeeeee> Botje: right, isn't the profiling supposed to show how many times we enter the functions? Cale said f was entering 40000+ times
10:40:37 <Botje> yes..
10:40:49 <zeeeee> oh..wait...i think the reason is that i need to make f into a global
10:40:58 <zeeeee> it's not even showing up in the profile, silly me
10:41:02 <Botje> so if you've got a big pile of 40000 functions all on top of each other
10:42:31 <zeeeee> hm...how can i make ghc profile non-global functions?
10:42:56 <_|_> use those "SCC" annotations.  the ghc manual says how.
10:43:15 <zeeeee> _|_: got it, thanks
10:43:21 <_|_> As _|_ I'm too lazy to look it up :)
10:43:33 <wkh> > foldl1 (+) [1..10]
10:43:34 <lambdabot>  55
10:44:00 <wkh> > let n = 10 in n*(n+1)/2
10:44:01 <lambdabot>  55.0
10:44:44 <_|_> consider `div` instead of /
10:46:19 <zeeeee> is there any way to apply SCC to a function definition instead of an expression? it's annoying if the function is broken up into several cases
10:46:23 <zeeeee> or guards
10:46:51 <sorear> -auto-all
10:47:54 <zeeeee> sorear: oh, you didn't see the context. i was actually referring to non-top-level functions.
10:48:20 <sorear> lambda lift :)
10:48:39 <zeeeee> wwwhat?
10:48:43 <zeeeee> *what
10:48:55 <_|_> he means make the function top-level :)
10:49:17 <nrb23> has anyone read "Haskell: The Craft of Functional Programming"... is it worth getting?
10:49:47 <_|_> Probably the only two choices are manually annotate each branch or move function to top-level then auto-all
10:51:32 <reilly> is anyone on the channel an expert on GHC's garbage collector?
10:54:27 <sorear> I've read all the documentation and spent a few hours trying to figure out how the system pins Integers(without success)
10:55:34 <reilly> I'm interested in being able to predict worst case gc pause durations
11:01:18 <dufflebunk> Is there a simpler way of writing:
11:01:27 <dufflebunk> Map.update (\ s -> Just (Set.insert id s)) key m
11:02:15 <nmessenger> @hoogle insert
11:02:16 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
11:02:16 <lambdabot> Data.HashTable.insert :: HashTable key val -> key -> val -> IO ()
11:02:16 <lambdabot> Data.IntMap.insert :: Key -> a -> IntMap a -> IntMap a
11:02:31 <Lemmih> Map.update (Just . Set.insert id) key m
11:02:42 <nmessenger> I think there's something like updateWith
11:03:15 <dufflebunk> Lemmih: Just . <something> ? I thought . was used for function composition, and Just isn't a function...
11:03:34 <nmessenger> @type Just
11:03:37 <lambdabot> forall a. a -> Maybe a
11:04:03 <nmessenger> is so!
11:04:34 <dufflebunk> cool
11:04:36 <LoganCapaldo> Just is a function
11:04:44 <LoganCapaldo> constructors == functions
11:04:46 <LoganCapaldo> bwahahahha
11:05:01 <LoganCapaldo> I was amazed when I realized that
11:05:15 <nmessenger> :D
11:05:25 <LoganCapaldo> (well not all constructors == functions)
11:05:34 <LoganCapaldo> True isn't a function much to my dismay :)
11:05:37 <nmessenger> simple functions, though.  They take arguments and make data.
11:05:58 <nmessenger> LoganCapaldo: you could call it a "nullary function" i.e. a function without arguments
11:06:51 <LoganCapaldo> nmessenger, err, that always kinda struck me as icky :)
11:07:15 <nmessenger> let x = 1 -->  int x() { return 1; }
11:07:46 <LoganCapaldo> that's not a function, its a thunk <g>
11:08:27 <nmessenger> ...which is just a function that gets optimized at runtime :P
11:10:59 * dufflebunk wonders how things get optimized at runtime in an interpreter
11:11:15 <allbery_b> they don't, at least in ghci
11:11:32 <allbery_b> (actually I'm told ghci has an optimizer but it's broken and disabled currently)
11:11:54 <pjd> hmm, when can't constructors and functions be treated interchangeably?
11:12:11 <nmessenger> pjd: when you didn't know they could do that yet :)
11:12:14 <pjd> (aside from being matched on, obviously)
11:12:55 <LoganCapaldo> I mean it makes sense since why should you have to type (\x -> Cons x)
11:13:47 <nmessenger> LoganCapaldo: it would make sense to type that if one thought constructors were some "magic" part of the syntax.
11:14:28 <LoganCapaldo> I know, but the first time you typed that you'd go "Why the heck are constructors some magic part of the syntax?? This is stupid" :)
11:14:37 <nmessenger> heh
11:14:58 <nmessenger> the only magic is use in patterns
11:16:16 <nmessenger> which you can't do with ordinary functions, thus constructors are somehow thought of as seperate from, even completely not, functions
11:16:38 <nmessenger> (at least that was my experience)
11:16:47 <LoganCapaldo> Yeah patterns are great, but a little
11:16:49 <t4> ?where zlib
11:16:49 <lambdabot> darcs get http://haskell.org/~duncan/zlib
11:17:10 <LoganCapaldo> not weird, I'm not sure the word I'm looking for :)
11:17:24 <nmessenger> orthogonal? :3
11:17:28 <LoganCapaldo> "Not related to functions"?
11:17:36 <LoganCapaldo> "...in an obvious way"
11:17:38 <LoganCapaldo> lol
11:17:40 <LoganCapaldo> I dunno :)
11:17:46 <ddarius> They are perfectly functions.
11:17:48 <nmessenger> @wn orthogonal
11:17:51 <lambdabot> *** "orthogonal" wn "WordNet (r) 2.0"
11:17:51 <lambdabot> orthogonal
11:17:51 <lambdabot>      adj 1: not pertinent to the matter under consideration; "an issue
11:17:51 <lambdabot>             extraneous to the debate"; "the price was immaterial";
11:17:51 <lambdabot>             "mentioned several impertinent facts before finally
11:17:53 <lambdabot> [7 @more lines]
11:18:15 <LoganCapaldo> ddarius, You'd say patterns are functions?
11:18:18 <nmessenger> er, I meant in the sense of "they fit like a glove"
11:18:18 <allbery_b> I think I'd argue that a constructor defines both a function and a pattern
11:18:30 <ddarius> Patterns aren't constructors are.
11:18:35 <allbery_b> and that they're separate concepts
11:18:35 <LoganCapaldo> yes ok
11:18:40 <LoganCapaldo> glad we agree
11:18:41 <nmessenger> allbery_b: not much to argue over, 'cause that's what they do!
11:19:14 <LoganCapaldo> Now if only the patterns were first class and you could pass em around <g>
11:19:22 <ddarius> Actually, to an extent patterns are just a notation for the inverse of constructors, having a well-defined inverse is what is different about constructors and functions.
11:19:22 <pjd> allbery_b: it might be neater to consider costructors "invertable-only" functions
11:19:36 <nmessenger> ddarius: ah!  very true.
11:19:39 <pjd> with patter matching being the inverse of their application
11:19:42 <pjd> pattern, even
11:19:46 <LoganCapaldo> Apparently ddarius and pjd are inside each others head
11:20:00 <alxb> (( getStdRandom (randomR (-2.048, 2.048)) ):: IO Float) >>= print
11:20:03 <pjd> heh
11:20:07 <alxb> can I transform that to a Float?
11:20:28 <ddarius> @google First-class patterns Haskell=
11:20:31 <lambdabot> http://www.cs.yale.edu/homes/tullsen/patterns.ps
11:20:42 <pjd> realizing that was a huge "aha" moment for me about haskell
11:20:48 <nmessenger> doesn't getStandardRandom . randomR = randomRIO
11:20:57 <allbery_b> no; you lift a pure function into the monad with >>=, and work with the Float from the pure function
11:20:58 <LoganCapaldo> every idea I have someone else thinks of first :)
11:21:19 * LoganCapaldo doesn't feel like clicking on .ps atm
11:21:35 <pjd> previously, i thought pattern matching was just some ad hoc process
11:21:49 <nrb23> @go quickcheck
11:21:52 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
11:21:52 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
11:22:37 <nmessenger> alxb: by "transform to a Float" do you mean as opposed to an "IO Float"?
11:22:45 <alxb> yes
11:22:51 <nmessenger> not without evil
11:23:10 <nmessenger> it's easier just to bind to functions that accept a float via the (>>=) operator
11:23:16 <ddarius> LoganCapaldo: The upshot, and what you can do today, is simply combine Blah -> Maybe Foo functions to make first class patterns, especially with support for pattern guards and such.
11:23:23 <allbery_b> (( getStdRandom (randomR (-2.048, 2.048)) ):: IO Float) >>= return . myFunc -- then work with the bare Float in myFunc
11:23:38 <nmessenger> alxb: or equivalently, do notation
11:23:40 <allbery_b> (which will receive the Float as its argument)
11:23:53 <LoganCapaldo> ddarius, cool
11:24:34 <nmessenger> ddarius: is that the "views" proposal?
11:25:05 <ddarius> nmessenger: No.
11:25:30 <alxb> >>= return . test
11:25:34 <alxb> test :: Float -> Float
11:25:34 * ddarius isn't a fan of views.
11:25:34 <alxb> test x = x
11:25:39 <nmessenger> @type (>>= return . text)
11:25:41 <alxb> like that?
11:25:42 <lambdabot> forall (m :: * -> *). (Monad m) => m String -> m Doc
11:25:52 <nmessenger> @type (>>= return . (undefined :: Float -> Float))
11:25:55 <lambdabot> forall (m :: * -> *). (Monad m) => m Float -> m Float
11:26:18 <pjd> alxb: you can think of IO as being the context that the Float is defined in:  you can't really separate the two
11:27:00 <pjd> but you can do anything you like to the Float within that context
11:27:11 <nmessenger> alxb: you can use do notation to pull out the Float, perform functions on it, and eventually 'return' it back into IO
11:27:29 <nmessenger> @type (>>=)
11:27:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:27:42 <nmessenger> thats what bind does, replace 'm' above with 'IO'
11:27:57 <LoganCapaldo> @type IO (>>=) -- this work?
11:27:59 <lambdabot> Not in scope: data constructor `IO'
11:28:07 <nmessenger> LoganCapaldo: @src?
11:28:09 <Cheery> Does haskell already have module for playing with quantum computers?
11:28:23 <LoganCapaldo> nmessenger, sorta :)
11:28:26 <ddarius> There are simulations of them out there.
11:28:33 <LoganCapaldo> I wanted it to do the s/m/IO/g :)
11:28:33 <augustss> Cheery: there are a few
11:28:36 <nmessenger> LoganCapaldo: oh, no.  I don't think there's a "specialize to one type" thingy
11:28:41 <ddarius> Or libraries for working with them.
11:28:43 <augustss> Cheery: but you'll have to google
11:29:07 <ddarius> @google Quantum Computing Haskell
11:29:10 <lambdabot> http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=871900
11:29:10 <lambdabot> Title: Modeling quantum computing in Haskell
11:29:43 <LoganCapaldo> @type (>>=) :: IO a -> (a -> IO b) -> IO b
11:29:46 <lambdabot> IO a -> (a -> IO b) -> IO b :: forall a b. IO a -> (a -> IO b) -> IO b
11:30:00 <LoganCapaldo> that sort of defeats the purpose
11:30:35 <nmessenger> I've written a whole minilanguage interpreter in functions from s -> IO s, and now I'm changing it to StateT s IO ().  It's being a little less scary than I thought, but the transformations aren't immediately obvious to me.
11:31:36 <nmessenger> LoganCapaldo: I think you'll have to do the unification yourself if you want to specialize.
11:32:09 <nmessenger> LoganCapaldo: i.e. tell say: "(>>=) has type IO Float -> (Float -> IO Something) -> IO Something"
11:32:14 <nmessenger> s/tell//
11:32:29 <ddarius> nmessenger: You should just have to sprinkle lift around as the first cut.
11:33:18 <nmessenger> ddarius: luckily, a lot of my functions are (return . someFunctionOnState), so I can change to (modify someFunctionOnState)
11:34:20 <nmessenger> this is my first time actually *using* transformers, as opposed to learning through osmosis and relaying said learned stuff.
11:37:39 <nmessenger> I've also learned that (\(x:xs) -> blah (f x) xs) becomes (do (x:xs) <- get; blah (f x); put xs)
11:38:51 <LoganCapaldo> nmessenger, I just had an evil idea. I wonder if you could make a generic functor to transform your entire code base <g>
11:39:40 <nmessenger> LoganCapaldo: nah, all my functions are dependant directly on (a -> b) and IO, so the returns and (.)s don't really fit.
11:41:00 <nmessenger> I was at least a *little* forward-thinking.  All my numeric ops look like: op '+' = opNum2 (+), so I just have to change opNum1 and opNum2
11:41:25 <nmessenger> @google false programming language
11:41:28 <lambdabot> http://wouter.fov120.com/false/
11:41:28 <lambdabot> Title: Wouter's False page
11:41:33 <nmessenger> ^^ that's what it is
11:41:55 <nmessenger> it's a cute (and devilish) forthlike
11:42:29 <nmessenger> the code "looks like swear words" :)
11:44:42 <nmessenger> I'd like to eventually put it in LB, but building her scares me 'cause I'm a wimp.
11:45:50 <Cheery> are quantum computers turing-compatible anyway?
11:46:05 <LoganCapaldo> turing compatible? <g>
11:46:26 <nmessenger> -complete?  I don't know enough about them.
11:50:56 <ddarius> Lambdabot's not too bad, or at least it wasn't when I was building it before and I'm on Windows.
11:53:44 <LoganCapaldo> So lambdabot does do windows
11:53:50 <LoganCapaldo> how about carpets?
11:54:15 <ddarius> Not so well.  No one has written a module for those.
11:54:35 <nmessenger> @remember LoganCapaldo So lambdabot does do windows, how about carpets?
11:54:36 <lambdabot> Done.
11:54:45 <nmessenger> :P
11:56:29 <pjd> "Proprietor! This here computer isn't Turing compatible!"
11:58:06 <nmessenger> @quote mathematician..type
11:58:07 <lambdabot> LoganCapaldo says: I suspect Cale is one of those "mathematician" type people
11:58:10 <nmessenger> :3
11:58:23 <jcreigh> does @quote take a regex?
11:58:27 <nmessenger> yep
11:58:33 <boXiDe> is there a way in haskell to divide an int and round it to the nearest number?
11:58:40 <nmessenger> @type div
11:58:43 <lambdabot> forall a. (Integral a) => a -> a -> a
11:58:55 <nmessenger> @type (round .) . (/)
11:58:57 <lambdabot> forall b a. (Integral b, RealFrac a) => a -> a -> b
11:59:09 <araujo> hello
11:59:22 <nmessenger> @type (\x y -> round (x/y)) -- less crazy-looking
11:59:25 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> a -> b
11:59:54 <boXiDe> ah rite, will it round up or down?
12:00:05 <sorear> down
12:00:10 <nmessenger> @docs Prelude
12:00:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
12:00:12 <sorear> use `quot` for round-to-zero
12:00:26 <sorear> > 3 `div` 2
12:00:28 <lambdabot>  1
12:00:39 <sorear> > (-3) `div` 2
12:00:41 <lambdabot>  -2
12:00:45 <sorear> > (-3) `quot` 2
12:00:46 <lambdabot>  -1
12:01:14 <pjd> round will round to nearest
12:01:31 <sorear> I think that there is the first time Prelude.quot was invoked this month in any instance of Haskell.  Nobody uses it.
12:01:49 <nmessenger> @src RealFrac
12:01:50 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
12:01:51 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
12:01:51 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
12:01:54 <Pastorn_> when using getChar, how do I get an instant response? (I don't want the program to wait for me to press Enter)
12:01:58 <nmessenger> ^^ for more roundings
12:02:10 <sorear> Pastorn_: setBuffering stdin NoBuffering
12:02:34 <ddarius> quot is faster than div
12:03:00 <nmessenger> s/set/hSet/ I believe
12:04:23 <Pastorn_> bug: hugs doesn't support this
12:04:33 <nmessenger> import System.IO
12:04:35 <nmessenger> ?
12:04:39 <Pastorn_> could someone please report this (as i have no clue how to)
12:05:01 <Pastorn_> but it works in ghci :D
12:05:25 <nrb23> anyone available to give me a hand getting started with quickcheck?
12:05:37 <nrb23> I can't seem to run any tests
12:05:45 <nrb23> and I can't find the quickCheck script on my system
12:05:51 <mdmkolbe> @pointless \xs yx -> [(x, y) | x <- xs, y <- ys]
12:05:52 <lambdabot> const . (: [y <- ys]) . (((x, y) | x) <-)
12:06:13 <mdmkolbe> @type (<-)
12:06:15 <lambdabot> parse error on input `<-'
12:06:20 <LoganCapaldo> theres no way [y <- ys] is valid is there?
12:06:33 <allbery_b> @pl doesn't understand list comprehensions
12:06:33 <LoganCapaldo> > let ys = [1,2,3] in [y <- ys]
12:06:34 <lambdabot>  Parse error
12:06:34 <lambdabot> doesn't understand list comprehensions
12:06:48 <LoganCapaldo> Oh good :)
12:06:48 <nmessenger> hah
12:07:06 <fasta> @hoogle [a] -> [(a,a)]
12:07:07 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
12:07:19 <boXiDe> does div need to be in ' marks?
12:07:22 <LoganCapaldo> fasta, I think he wants cross product not zip
12:07:33 <allbery_b> they're ` marks, but yes
12:07:43 <fasta> LoganCapaldo: What makes you think that I am trying to help someone?
12:07:44 <allbery_b> unless you use it as a prefix
12:07:47 <mdmkolbe2> bad wireless connection
12:07:48 <allbery_b> > div 6 3
12:07:48 <LoganCapaldo> lol
12:07:49 <boXiDe> ah no wonder its not working
12:07:49 <lambdabot>  2
12:07:51 <LoganCapaldo> sorry
12:07:51 <sorear> > liftM2 (,) [1,2,3] [4,5,6]
12:07:53 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
12:07:53 <LoganCapaldo> :)
12:07:55 <allbery_b> > 6 `div` 3
12:07:56 <lambdabot>  2
12:08:04 <sorear> LoganCapaldo: cross product is liftM2 (,)
12:08:12 <mdmkolbe2> sorear: cool thx
12:08:25 <fasta> The function I am looking for does have the type I searched for, it's just not zip.
12:08:47 <ddarius> fasta: Obviously, because zip doesn't have that  type.
12:08:55 * LoganCapaldo will never assume anyone is trying to help anyone again
12:08:56 <ddarius> @type join zip
12:08:56 <nmessenger> fasta: grouping successive pairs?
12:08:58 <lambdabot> forall a. [a] -> [(a, a)]
12:09:04 <fasta> nmessenger: yeah
12:09:25 <ddarius> fasta: I don't think there is a standard function to do that, but implementing it yourself is trivial.
12:09:27 <fasta> nmessenger: I wrote it before, but I can't find it in my personal library
12:09:38 <sorear> fasta:
12:09:44 <sorear> > ap zip tail [1,2,3,4,5]
12:09:44 <nmessenger> @type map (\[x,y]->(x,y)) . takeWhile (not . null) . unfoldr (Just . splitAt 2)
12:09:47 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
12:09:47 <lambdabot> forall a. [a] -> [(a, a)]
12:10:00 <fasta> nmessenger: yep, it did look like that.
12:10:09 <ddarius> > let group2 [] = []; group2 (x:y:xs) = (x,y):group2 xs in group2 [1..16]
12:10:10 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16)]
12:10:18 <fasta> sorear: heh, that's nice.
12:10:20 <nmessenger> mine results in [(1,2),(3,4),ERROR!
12:10:30 <fasta> @type ap
12:10:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:10:51 <sorear> > map head . iterate (drop 2) . ap zip tail $ [1,2,3,4,5]
12:10:52 <lambdabot>  Exception: Prelude.head: empty list
12:10:59 * ddarius misunderstood "successive pairs"
12:10:59 <sorear> > map head . iterate (drop 2) . ap zip tail $ [1,2,3,4,5,6]
12:11:01 <fasta> sorear: what instance is ap using?
12:11:01 <lambdabot>  Exception: Prelude.head: empty list
12:11:03 <nmessenger> zip is e -> a -> b, so ap's m is ((->) e)
12:11:27 <ddarius> @src (->) ap
12:11:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:11:32 <sorear> @src ap
12:11:32 <nmessenger> @src ap
12:11:33 <lambdabot> ap = liftM2 id
12:11:33 <lambdabot> ap = liftM2 id
12:11:41 <sorear> @src (->) >>=
12:11:41 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:11:45 <sorear> @src (->) (>>=)
12:11:45 <lambdabot> f >>= k = \ r -> k (f r) r
12:11:48 <nrb23> hmm... how do I get cabal to run my tests?
12:11:49 <AvengerX> I just -can't- get the idea of haskell :/
12:11:49 <sorear> @src (->) return
12:11:50 <lambdabot> return = const
12:12:04 <fasta> sorear: how does it look like without ap?
12:12:06 <nmessenger> AvengerX: it's a little more indirection than I know *I* can mentally unify
12:12:27 <sorear> fasta: (on ->) ap f g = \x -> f x (g x)
12:12:28 <ddarius> AvengerX: You are over complicating things.  In a pretty strong sense Haskell is "simpler" than most languages.
12:12:41 <sorear> fasta: thus ap zip tail = \x -> zip x (tail x)
12:12:48 <nmessenger> ah!
12:12:51 <sorear> @pl \x -> zip z (tail x)
12:12:52 <lambdabot> zip z . tail
12:12:56 <fasta> sorear: oh, I thought of that method before you mentioned it :)
12:12:56 <sorear> @pl \x -> zip x (tail x)
12:12:57 <lambdabot> ap zip tail
12:13:02 <nmessenger> > ap zip (tail . tail) [1,2,3,4,5,6]
12:13:04 <lambdabot>  [(1,3),(2,4),(3,5),(4,6)]
12:13:08 <nmessenger> :/
12:13:20 <fasta> sorear: My previous version was much longer. (looking like that of nmessenger)
12:13:22 <AvengerX> but should it be complicated to match one guy inside a list? :P
12:13:32 <sorear> \ [x] -> ...
12:14:09 <sorear> @users
12:14:10 <lambdabot> Maximum users seen in #haskell: 331, currently: 331 (100.0%), active: 48 (14.5%)
12:15:27 <nmessenger> > let dropEvens = map snd . filter (\(i,x)->odd i) . zip [1..] in dropEvens (ap zip tail [1..6])
12:15:28 <lambdabot>  [(1,2),(3,4),(5,6)]
12:15:34 <nmessenger> :D
12:16:14 <sorear> > map snd . filter (even . fst) . zip [0..] . ap zip tail $ [1..6]
12:16:16 <lambdabot>  [(1,2),(3,4),(5,6)]
12:16:30 <nmessenger> I decided to give it a name since it was scary-looking
12:17:09 <sorear> > catMaybes . zipWith ap (cycle[fail,return]) . ap zip tail $ [1..6]
12:17:10 <lambdabot>  Couldn't match expected type `String -> a'
12:17:21 <sorear> > catMaybes . zipWith ap (cycle[\_->Nothing,Just]) . ap zip tail $ [1..6]
12:17:22 <lambdabot>  Couldn't match expected type `a -> b'
12:17:28 <sorear> > catMaybes . zipWith id (cycle[\_->Nothing,Just]) . ap zip tail $ [1..6]
12:17:30 <lambdabot>  [(2,3),(4,5)]
12:18:10 <nmessenger> fasta: do you want f [1..4] = [(1,2),(2,3),(3,4)] or [(1,2),(3,4)]?
12:18:19 <sorear> > catMaybes . ap (zipWith3 id (cycle[\_ _->Nothing,curry Just]) tail $ [1..6]
12:18:19 <lambdabot>  Parse error
12:18:21 <fasta> nmessenger: the former
12:18:23 <sorear> > catMaybes . ap (zipWith3 id (cycle[\_ _->Nothing,curry Just])) tail $ [1..6]
12:18:25 <lambdabot>  [(2,3),(4,5)]
12:18:50 <sorear> > catMaybes . ap (zipWith3 id (cycle[curry Just,\_ _->Nothing])) tail $ [1..6]
12:18:52 <lambdabot>  [(1,2),(3,4),(5,6)]
12:18:54 <nmessenger> then f = ap zip tail
12:19:21 <fasta> nmessenger: I used the version without monadic references
12:19:34 <fasta> nmessenger: I think using ap is obfuscation.
12:19:47 <nmessenger> ap zip tail = \xs -> zip xs (tail xs)
12:19:53 <nmessenger> so use that
12:19:58 <fasta> nmessenger: I was already
12:20:03 <nmessenger> ah, I see
12:21:18 <LoganCapaldo> re: what we were talking about before about constructors being invertible functions, is it provable that the inverse of (f . g) where f and g are invertible is gInverse . fInverse ?
12:21:22 <sorear> > ($[]) . ap (zipWith3 id (cycle[curry(:),\_ _->id])) tail $ [1..6]
12:21:23 <lambdabot>  Couldn't match expected type `[a] -> b'
12:21:36 <sorear> > foldr($)[] . ap (zipWith3 id (cycle[curry(:),\_ _->id])) tail $ [1..6]
12:21:37 <lambdabot>  [(1,2),(3,4),(5,6)]
12:22:45 <sorear> > (let f(x:y:xs)=(x,y):f xs ; f[]=[] in f) $ [1..6]
12:22:47 <lambdabot>  [(1,2),(3,4),(5,6)]
12:22:50 <sorear> points++
12:23:26 <nmessenger> heh
12:24:23 <nmessenger> never thought about using (let f x = ... in f) y, I usually use (\x -> case x of ...) y
12:24:54 <LoganCapaldo> It must be right because you can do Left (Just 1) for instance
12:25:10 <LoganCapaldo> ?
12:25:49 <nmessenger> fromLeft (Left x) = x, fromJust (Just x) = x, so (Left . Just) = (fromJust . fromLeft)
12:26:10 <nmessenger> @quote unjust
12:26:11 <lambdabot> SamB says: [on the subject of fromJust] SamB_XP thinks that unJust would be a more fun name for that
12:27:05 <nmessenger> er, they aren't equivalent, the're inverses
12:27:40 <LoganCapaldo> right so
12:27:56 <nmessenger> @slap nmessenger
12:27:57 * lambdabot beats up nmessenger
12:28:07 <AvengerX> lol
12:28:16 <nmessenger> thanks, LB
12:28:27 <mdmkolbe> @pointless let f a (x:xs) = a+x:(f (a+x) xs) in f 0
12:28:29 <lambdabot> fix (flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (((.) . (:)) .) . (+)) . (. (+)) . (.)) 0
12:28:37 <LoganCapaldo> if I have a function g such that g = f1 . f2 ., ... , fn where fi are all in invertible functions,
12:28:38 <AvengerX> this bot is an all-in-wonder tool
12:29:04 <LoganCapaldo> You could conceivable have a compiler that allowed case value of g x -> ...
12:29:06 <LoganCapaldo> No?
12:29:43 <nmessenger> LoganCapaldo: the trouble is proving to the compiler that g is invertible, and what it's inverse is.
12:29:54 <sorear> @users
12:29:54 <lambdabot> Maximum users seen in #haskell: 331, currently: 330 (99.7%), active: 47 (14.2%)
12:30:12 <LoganCapaldo> well yeah thats why I suggested just constructors and (.) for isntance
12:30:44 <nmessenger> what is the inverse of (.)?  uncompose f = (g,h)?
12:31:04 <LoganCapaldo> well it would be a pattern match
12:31:11 <LoganCapaldo> err
12:31:13 <LoganCapaldo> no wait
12:31:18 <LoganCapaldo> I mean what I said earlier
12:31:31 <LoganCapaldo> gInverse . fInverse would be the inverse of f . g
12:32:06 <nmessenger> suppose you have f = g . h . k,  for the pattern (x . y), would (x,y) be (g . h, k) or (g, h . k)?
12:32:44 <LoganCapaldo> I dunno :)
12:32:52 <LoganCapaldo> thats why I'm asking all these questions :)
12:32:58 <nmessenger> neither does the compiler. :)
12:33:46 <nmessenger> Constructors are good because they can't be simplified, so deconstruction has only one possible outcome.
12:34:00 <LoganCapaldo> Yeah
12:35:15 <LoganCapaldo> I guess type Compose a b c = a (b c) might work though?
12:35:45 <LoganCapaldo> case v of Compose Left Just 1 -> ....
12:35:51 <nmessenger> though a function (a -> Maybe b) could be used as a "deconstructor" for type a.  If it matches, then (Just someB), if it fails, then (Nothing)
12:36:15 <LoganCapaldo> yeah thats what ddarius mentioned before
12:36:29 <Pastorn_> I can't use backspace when using getLine, can this be solved with Line Buffering?
12:36:30 <nmessenger> I remember reading about a "views" proposal of this sort on the Haskell' Trac wiki
12:37:29 <nmessenger> http://haskell.galois.com/trac/haskell-prime/wiki/ViewPatterns
12:37:31 <lambdabot> Title: ViewPatterns - Haskell Prime - Trac
12:38:35 <nmessenger> this is like an extra syntactic support for matching with guard patterns
12:38:51 <ddarius> Yes, (f . g)^-1 = g^-1 . f^-1
12:39:16 <LoganCapaldo> ddarius, well I'm glad I got that part right :)
12:41:29 <AvengerX> i'm not sure, but some things with -1 in haskell -must- be parenthesized... and I think ^ precedes * which precedes -
12:41:54 <AvengerX> do I make any sense, ddarius? :)
12:42:19 <nmessenger> AvengerX: that was maths notation, not Haskell
12:42:22 <xerox> AvengerX: that is not standard Haskell.
12:42:31 <AvengerX> ahh :P
12:42:55 * AvengerX puts his read in the nearest hole
12:42:59 <AvengerX> ops
12:43:00 <AvengerX> *head!
12:43:17 <xerox> AvengerX: f^-1 denotes the inverse function of f.
12:44:17 * AvengerX pulls off head [ah yes!..] and hides again
12:44:17 <AvengerX> :)
12:44:19 <LoganCapaldo> I hate that because it also could be 1/f :(.
12:44:30 <LoganCapaldo> math notation is so overloaded
12:44:48 <AvengerX> lol
12:44:56 <nmessenger> f^x usually means "f superscript x", with whatever superscripting implies in the current context.
12:45:06 <nmessenger> usually exponentiation
12:45:17 <AvengerX> it could become -ln(f.g) also
12:45:26 <LoganCapaldo> |A| -- cardinality, absolute value, or the determinate? (Who knows, maybe more :) )
12:46:32 <LoganCapaldo> Mathematics notation: The Original Context Sensitive Grammar
12:46:49 <LoganCapaldo> :)
12:46:50 <nmessenger> heh
12:46:58 <ddarius> LoganCapaldo: The ambiguity with 1/f is on purpose.
12:47:17 <AvengerX> > head []
12:47:19 <lambdabot>  Exception: Prelude.head: empty list
12:48:08 <ddarius> LoganCapaldo: |A| are all notions of "size" and anyways none of those can be ambiguous they apply to totally different things.
12:48:36 <LoganCapaldo> ddarius, I know :)
12:48:39 <ddarius> And coincide on, e.g. scalars, 1D vectors, 1x1 matrices.
12:48:42 <AvengerX> eech... if I do a head [ blah | blah <- bleh, blah == bloblo ], and there's no bloblo == blah in the bleh list, the 'head []' will return an error!
12:48:46 <LoganCapaldo> I'm just busting math's chops
12:48:51 * AvengerX laughts out loud of his own example
12:49:14 <ddarius> LoganCapaldo: There are things that are worse, those aren't them though.
12:49:29 <ddarius> It's mostly very consistent at the semantic level.
12:49:41 <nmessenger> @src find
12:49:42 <lambdabot> find p          = listToMaybe . filter p
12:49:47 <nmessenger> @src listToMaybe
12:49:48 <lambdabot> listToMaybe []        =  Nothing
12:49:48 <lambdabot> listToMaybe (a:_)     =  Just a
12:50:06 <nmessenger> find (bloblo==)
12:50:39 <AvengerX> find already in prelude?
12:50:47 <nmessenger> @index listToMaybe
12:50:47 <lambdabot> Data.Maybe
12:50:52 <AvengerX> hmm
12:50:53 <nmessenger> listToMaybe is like a "safe" head
12:50:59 <allbery_b> @index find
12:51:00 <lambdabot> Data.List
12:51:05 <nmessenger> @src head
12:51:05 <lambdabot> head (x:_) = x
12:51:06 <lambdabot> head []    = undefined
12:51:09 <AvengerX> I'm implementing a 'find' but it is for a list of triples
12:51:29 <LoganCapaldo> find works on lists o' anything
12:51:37 <nmessenger> triples have an Eq instance
12:51:53 <LoganCapaldo> @type find
12:51:55 <AvengerX> listToMaybe (a:_) does not matches if a list greater than 1 elements is resulted
12:51:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:52:06 <allbery_b> sure it does
12:52:10 <LoganCapaldo> erm yes it does
12:52:10 <AvengerX> this Maybe Type is weird
12:52:12 <allbery_b> the _ matches any list tail
12:52:14 <encryptio> what's an efficient way to take the square root or next higher Integral of an Integral a => a?
12:52:37 <therp> I need to buy a new faster computer. not for gaming, nor some fancy digital video stuff, but for compiling GHC faster.
12:52:38 <allbery_b> > let f (x:_) = x in f [1..5]
12:52:40 <lambdabot>  1
12:52:54 <nmessenger> so (ceiling . sqrt . fromIntegral) but more efficient?
12:53:21 <encryptio> yep
12:53:26 <AvengerX> it is the same as head [ list ] (this (x:_) ... hmm makes all sense!
12:53:28 <allbery_b> > listToMaybe [1//5]
12:53:29 <lambdabot>   add an instance declaration for (Num [(i, e)])
12:53:33 <allbery_b> whoops
12:53:36 <allbery_b> > listToMaybe [1..5]
12:53:38 <lambdabot>  Just 1
12:53:52 <AvengerX> why 'Just'?
12:53:58 <AvengerX> > listToMaybe []
12:53:59 <lambdabot>  Nothing
12:54:05 <nmessenger> encryptio: I suppose you could implement integral sqrt.  I'm not sure it's anywhere.
12:54:06 <ddarius> We need to figure out how to farm some of the GHC compilation process onto the GPU.
12:54:08 <AvengerX> > listToMaybe [2,5,4,2,1]
12:54:09 <lambdabot>  Just 2
12:54:20 <allbery_b> Just x and Nothing are the constructors for Maybe
12:54:21 <encryptio> AvengerX: because (Just a) creates a Maybe
12:54:38 <AvengerX> omg
12:54:42 <AvengerX> @Maybe
12:54:42 <lambdabot> Unknown command, try @list
12:54:43 <pjd> ddarius: what part of compilation could be streamed, though?
12:54:47 <allbery_b> (a Maybe is either Nothing or Just something)
12:54:51 <AvengerX> @type Maybe
12:54:54 <lambdabot> Not in scope: data constructor `Maybe'
12:55:01 <allbery_b> @src Maybe
12:55:01 <lambdabot> data Maybe a = Nothing | Just a
12:55:02 <nmessenger> @src Maybe
12:55:03 <lambdabot> data Maybe a = Nothing | Just a
12:55:37 <allbery_b> so it's a convenient way to represent optional values
12:55:40 <AvengerX> Nothing and Just are constants?
12:55:48 <ddarius> pjd: That's what needs to figured out.  I'm sure something could be arranged.
12:55:49 <encryptio> they're type constructors
12:56:02 <pjd> arranged indeed :)
12:56:03 <ddarius> encryptio: Data constructors.
12:56:09 <encryptio> yeah, that.
12:56:11 <nmessenger> s/type/data/
12:56:14 <allbery_b> (and it has a monad instance which makes it even more convenient for some things:  it threads values through a computation and short-circuits away Nothing)
12:56:15 <AvengerX> hmmm
12:56:21 <AvengerX> @src Just
12:56:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:56:28 <nmessenger> encryptio: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
12:56:38 <pjd> AvengerX: the Maybe data type is distinct from the Maybe monad instance
12:56:56 <pjd> just like the [] type is distinct from the [] monad
12:57:00 <AvengerX> hmm
12:57:26 <AvengerX> I think I don't know what is a monad yet
12:57:33 <pjd> don't worry :)
12:57:43 <encryptio> nmessenger: i completely forgot about that page, thanks
12:57:56 <AvengerX> I'd better try with head x instead of listToMaybe :)
12:58:12 <allbery_b> you don't have to care about the monad instance
12:58:27 <nmessenger> AvengerX: you could do fromJust, but that'd also error on an empty list.
12:58:28 <AvengerX> I would like to search the list of triples and get just the first match (or an empty list if no matches)
12:58:30 <allbery_b> someday you might, and you can learn about it then
12:58:50 <allbery_b> head . filter (yourmatchpredicate)
12:59:05 <allbery_b> well, no, not quite :)
12:59:07 <nmessenger> AvengerX: you want either a triple or an empty list?  But the empty list isn't in the triple type
12:59:10 <AvengerX> as long as the filter does not return []
12:59:37 <nmessenger> you could do: maybe [] (:[]) . find
13:00:08 <nmessenger> or: maybe (Left []) Right . find, but that'd be really no different from just using Maybe
13:00:38 <AvengerX> I want to return the first triple's match and a (<sought>,"Not fount",0) if not found
13:00:43 <AvengerX> *found
13:01:05 <AvengerX> Maybe [] (monster) . find
13:01:16 <AvengerX> I'd love to use it lol
13:01:28 <nmessenger> You could use the Either YourTriple (SoughtsType,String,Int) type
13:01:42 <AvengerX> > maybe [] (:[]) . (0,"Not found",0)
13:01:43 <lambdabot>  Couldn't match expected type `a -> Maybe a1'
13:02:11 <AvengerX> I think I can't compose functions like that :)
13:02:18 <nmessenger> or (Maybe Result, String, Int)
13:02:32 <allbery_b> actually you want \val -> maybe [(v,"Not found",0)] (find ...)
13:02:36 <nominolo> hm, what's the idiom for C's #ifdef DEBUG ...?  just simple if Config.debug then ... ?
13:02:47 <AvengerX> hmm
13:02:58 <pjd> @type maybe
13:03:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:03:39 <nmessenger> if it *might* not be there, you'll either need to blow up, use the Maybe type, or some other "If it's not there" type.
13:03:56 <mdmkolbe> @pointless (\f g x -> f (g x))
13:03:56 <lambdabot> (.)
13:04:16 <AvengerX> well, I am thinkering something here like this, nmessenger
13:04:17 <ehird> heh
13:04:19 <nmessenger> Maybes are really useful!
13:04:20 <allbery_b> > \xs k -> maybe [(k,"Not found",0)] (find (\(v,_,_) -> k == v) xs)
13:04:20 <AvengerX> lemme see if it works
13:04:21 <lambdabot>  Couldn't match expected type `a -> [(t, [Char], t1)]'
13:04:23 <pjd> AvengerX: maybe default (doSomethingWithX) (Maybe x)
13:05:09 <pjd> that will either return the default, or the result of doSomethingWithX, depending on whether the last argument is a Nothing or a Just x
13:05:40 <nmessenger> Nothing embodies the concept of "Not found", so you shouldn't need to return that as a String
13:06:07 <nmessenger> if you want indeces, you could zip [0..] onto it
13:06:21 <nmessenger> > zip [0..] ['a'..'f']
13:06:23 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
13:06:24 <pjd> right, it looks like you actually just want to use Maybe directly :)
13:06:36 <AvengerX> pjd: kinda maybe (cod,"not found",0) (find ((id,_,_) -> cod == id)
13:06:37 <AvengerX> ?
13:07:01 <nmessenger> AvengerX: paste what you have and we'll bash on it.
13:07:03 <nmessenger> @paste
13:07:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:07:09 <AvengerX> well.. actually I got to return just the second and third fields of the triple
13:07:48 <nmessenger> fmap (\(_,y,z) -> (y,z)) :: Maybe (a,b,c) -> Maybe (b,c)
13:08:06 <AvengerX> let me just test it a lil more now that you enlightened me, I paste then (maybe I'm doing ambiguity and pleonasms)
13:08:10 <pjd> AvengerX: nah, maybe is for when you have an actual Maybe value, and you want to either operate on its contents (if it's a Just x) or return a default (if it's a Nothing)
13:08:31 <pjd> if you have an operation that can fail, then it returns a Maybe directly
13:09:09 <encryptio> @pl (\x f -> f x !! 10)
13:09:09 <lambdabot> flip flip 10 . ((!!) .) . flip id
13:09:36 <nmessenger> ((!! 10) .) . flip ($)?
13:09:53 <nmessenger> @type ((!! 10) .) . flip ($)
13:09:56 <lambdabot> forall a a1. a1 -> (a1 -> [a]) -> a
13:10:06 <pjd> s
13:10:10 <pjd> oops
13:10:34 <nornagon> @unpl ((!! 10) .) . flip ($)
13:10:35 <lambdabot> (\ j m -> (m j) !! 10)
13:10:37 <encryptio> what is it with the "a1" stuff in general types?
13:10:39 <rahikkala> @pl (\n x f -> f x !! n)
13:10:39 <lambdabot> flip (flip . ((!!) .) . flip id)
13:10:46 <AvengerX> it worked!
13:10:50 <AvengerX> @paste
13:10:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:10:59 <AvengerX> lambdabot: :*
13:12:00 <mdmkolbe> @pointless snd . mapAccumL (\x y -> (x+y, x)) 0
13:12:00 <lambdabot> snd . mapAccumL (flip =<< ((,) .) . (+)) 0
13:12:24 <encryptio> :t (,)
13:12:27 <lambdabot> forall a b. a -> b -> (a, b)
13:12:35 <nmessenger> > (,) 'a' 1
13:12:37 <lambdabot>  ('a',1)
13:12:57 <encryptio> > (,) ((,) 1 2) 3
13:12:58 <lambdabot>  ((1,2),3)
13:13:21 <encryptio> @pl (\x y z -> (x,y,z))
13:13:21 <nmessenger> (blah, barf) is just syntax sugar
13:13:21 <lambdabot> (,,)
13:13:26 <hpaste>  Avenger pasted "Code to find id in triplet and return tuple with 2nd and 3rd parts of it or 'generic' tuple if not f" at http://hpaste.org/665
13:13:50 <AvengerX> I didn't use maybe
13:13:58 <AvengerX> used guards and overload instead
13:14:17 <AvengerX> would it work better if I choosed something on maybe?
13:15:06 <nmessenger> maybe ("Item " ++ show cod ++ " unknown", 0) id (find (cod==) listatotal)
13:15:45 <nmessenger> the maybe function gives what the Nothing should turn into, and what to do to Just a value
13:16:02 <AvengerX> wow, this single line resumes all that? :)
13:16:03 <pjd> AvengerX: are you sure you don't want busca to return Maybe (Nome,Preco) ?
13:16:34 <pjd> if there's a result, it returns Just (head result), otherwise Nothing
13:16:58 <AvengerX> pdj: Sure, don't want types 'Nothing' nor 'Just <something>'. my function must return a touple (String,Int)
13:17:36 <pjd> AvengerX: are you really sure?
13:17:44 <AvengerX> It must return a touple regardless of the search results (either with the item or with 'item not found' touple)
13:18:12 <pjd> this way the caller must specially check for the "Item unknown" value
13:18:21 <pjd> it's a lot easier to check for Nothing instead
13:18:32 <bolrod> | result == [] = busca [] cod     isn't obvious...   | result == [] = Nothing is more clear
13:18:36 <bolrod> imo.
13:18:40 <dons> ?users
13:18:41 <lambdabot> Maximum users seen in #haskell: 332, currently: 325 (97.9%), active: 52 (16.0%)
13:18:41 <nmessenger> oops, the (cod==) should be (\(id,_,_) -> id == cod)
13:18:53 <AvengerX> pjd: well... I'm quite sure...
13:19:02 <pjd> AvengerX: think about it :)
13:19:17 <pjd> at the moment, the special "not found" value is just another kind of Nothing
13:19:26 <bolrod> you could write a function around this one to return the "Nothing found"  if this returns Nothing
13:19:32 <pjd> except it's harder to work with, and less flexible
13:19:59 <nmessenger> Your ("Item blah unknown", 0) *looks* like a real value, you have to check the string to know, Nothing is explicitly *not found*
13:20:35 <AvengerX> pjd: look, this 'busca' (find) will return an entity which will later be formatted for a 'bill'. Later in the program I'll provide a list of ints, and each int will be processed by the 'busca', and formatted to a list of lines like 'Item......price\nItem....price\n\nTotal...totprice'
13:20:56 <AvengerX> unless I do a formatTouple for 'Nothing' type as well...
13:21:10 <AvengerX> But I could just format the 'Unkown',0 touple
13:21:11 <allbery_b> that would probably be wise
13:21:20 <allbery_b> do you want an Unknwn t slip through unnoticed?
13:21:28 <AvengerX> hmmm
13:21:31 <nmessenger> AvengerX: well, the find function already does the searching, and the (maybe ("blah", 0) id) changes a not found into your tuple
13:21:38 <pjd> AvengerX: you can turn the Nothing into an item unknown separately
13:21:44 <allbery_b> IME the billing folks don't like that kind of thing much :)
13:21:47 <pjd> or you can filter the Nothings out
13:21:52 <pjd> or you can do any other thing
13:21:59 <AvengerX> hmmm
13:22:03 <nmessenger> > catMaybes [Just 1, Nothing, Just 2, Just 3, Nothing]
13:22:05 <lambdabot>  [1,2,3]
13:22:14 <AvengerX> Nothing's into the Prelude or I have to load anything else before I can use it?
13:22:22 <pjd> it's built in, yes
13:22:24 <AvengerX> And to see if it is nothing I do a
13:22:52 <pjd> you can pattern match on it, like anything else
13:22:54 <AvengerX> f x | x == Nothing = <nothings formatation> ; | otherwise = <format normally>
13:22:59 <nmessenger> fear not, The Libraries, young one, for vast riches, they contain
13:23:01 <allbery_b> @index Maybe
13:23:02 <lambdabot> Data.Maybe, Prelude
13:23:07 <pjd> or you can use maybe, or several other things
13:23:23 <nmessenger> </yoda>
13:23:33 <encryptio> f Nothing = ...formatting...  ;  f (Just item) = ....formatting for item...
13:23:45 <AvengerX> hmm
13:23:58 <AvengerX> I like this maybe thing :)
13:24:22 <pjd> or f x = maybe "not found" <format x> x
13:24:37 <encryptio> :t maybe
13:24:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:24:44 <encryptio> ooo.
13:24:50 <nmessenger> @src maybe
13:24:51 <lambdabot> maybe n _ Nothing  = n
13:24:51 <lambdabot> maybe _ f (Just x) = f x
13:25:21 <AvengerX> But I can't do a list with [(0,"Str",32),...,Nothing,(15,"Str",123)...], can I?
13:25:29 <nmessenger> the n is your "Not found" string, the f formats your Just contained item
13:25:33 <jcreigh> @src fromMaybe
13:25:34 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
13:25:41 <pjd> AvengerX: put a "Just" in front of the non-Nothings
13:25:47 <ddarius> @type listToMaybe
13:25:49 <lambdabot> forall a. [a] -> Maybe a
13:25:58 <encryptio> AvengerX: no, you'd have to wrap those others in a Just, so you have [Maybe TupleType]
13:26:01 <nmessenger> AvengerX: they have to be the same type to be in a list, you have to use Just as pjd says
13:26:02 <jcreigh> oh, "maybe" applies a function too.
13:26:03 <AvengerX> pjd: LOL cool
13:26:11 <AvengerX> so
13:26:30 <AvengerX> I can do a list with [Just (0,"Str",32),...,Nothing,Just (15,"Str",123)...]?
13:26:48 <pjd> AvengerX: in general, any operation that can "fail", like a lookup, should return a Maybe
13:27:01 <AvengerX> hmm
13:27:03 <pjd> AvengerX: yep
13:27:13 <AvengerX> Let me work on htat
13:27:13 <AvengerX> that
13:27:27 <Boney> >  [Just (0,"Str",32), Nothing, Just
13:27:27 <lambdabot>  Parse error
13:27:28 <pjd> then you can use catMaybes to get rid of the Nothings
13:27:33 <Boney>                   (15,"Str",123)]
13:27:45 <Boney> >  [Just (0,"Str",32), Nothing, Just (15,"Str",123)]
13:27:46 <lambdabot>  [Just (0,"Str",32),Nothing,Just (15,"Str",123)]
13:27:55 <hpaste>  nmessenger annotated "Code to find id in triplet and return tuple with 2nd and 3rd parts of it or 'generic' tuple if not f" with "using find and fromMaybe" at http://hpaste.org/665#a1
13:28:06 <AvengerX> Type for this list would be:: type listofMaybes [Maybe (Int,String,Int)] ?
13:28:47 <allbery_b> :: [Maybe (Int,String,Int)]
13:28:47 <Boney> AvengerX: probably,  also probably Integer rather than Int
13:28:49 <AvengerX> I will like to have the Nothings in the list, so the nothings becomes the 'Not found...0,00' items
13:28:55 <nmessenger> AvengerX: no listOfMaybes, that's a function.  The type is [Maybe (Int,String,Int)]
13:29:06 <pjd> or you can say something like:
13:29:10 <Boney> @type [Just (0,"Str",32), Nothing, Just (15,"Str",123)]
13:29:10 <pjd> > map (maybe "not found" show) [Just 1, Just 2, Nothing, Just 4]
13:29:12 <lambdabot>  ["1","2","not found","4"]
13:29:13 <lambdabot> forall t t1. (Num t, Num t1) => [Maybe (t, [Char], t1)]
13:29:34 <AvengerX> I used 'listtoMaybes' to differ from the function listOfMaybes but ok
13:30:15 <nmessenger> listToMaybes is like 'head', it turns the first element into Just x, and an empty list into Nothing
13:30:34 <nmessenger> listToMaybe*,  no 's'
13:30:53 <nmessenger> AvengerX: did you see my paste?
13:31:18 <AvengerX> nmessenger: this kills two bunnies in a single punch
13:31:26 <AvengerX> ops no
13:31:28 <nmessenger> D:
13:31:31 * AvengerX looks for it
13:31:36 <nmessenger> birds/stone
13:32:07 <AvengerX> There's not a paste announce for yours, nmessenger
13:32:21 <nmessenger> http://hpaste.org/665#a1
13:32:30 <allbery_b> <hpaste>  nmessenger annotated "Code to find id in triplet and return tuple with 2nd and 3rd parts of it or 'generic' tuple if not f" with "using find and fromMaybe" at http://hpaste.org/665#a1
13:32:43 <nmessenger> oops, error, one sec
13:32:51 <AvengerX> ah, so I have to import data.Maybe
13:33:13 <pjd> you shouldn't have to
13:33:22 <pjd> the Prelude imports it
13:33:41 <hpaste>  nmessenger annotated "Code to find id in triplet and return tuple with 2nd and 3rd parts of it or 'generic' tuple if not f" with "had a type mismatch :)" at http://hpaste.org/665#a2
13:34:02 <AvengerX> ah, it announces 'annotated', was looking for 'pasted' :P
13:34:04 <AvengerX> sorry
13:34:44 <nmessenger> does that work?
13:35:56 <nmessenger> "find those records with the correct id, turn the result into a (Nome,Preco) pair, if there's no result, give the default"
13:36:02 <AvengerX> well, I was thinking, that I could use 'busca' to return the Maybe type, and only when I format the output, I do the 'Nothing' -> 'Not found.....0.00', from a list of maybes generated throught (among others) the 'busca'
13:36:51 <nmessenger> that code does what yours did, you could change it if you like by moving the defaulting/error handling into a higher function.
13:37:00 <AvengerX> I have a 'formatBusca'-like function that gets the touples (String,Int) and format them. I could end the Maybe -there-
13:37:18 <AvengerX> so I just don't use 'fromMaybe' there, right?
13:37:45 <AvengerX> ah you no longer used FromMaybe in the second annotation
13:37:55 <hpaste>  nmessenger annotated "Code to find id in triplet and return tuple with 2nd and 3rd parts of it or 'generic' tuple if not f" with "to keep the Maybe" at http://hpaste.org/665#a3
13:38:32 <AvengerX> busca :: BancoDeDados -> CodigoDeBarras -> (Nome,Preco)
13:38:33 <AvengerX> becomes
13:38:36 <AvengerX> busca :: BancoDeDados -> CodigoDeBarras -> Maybe
13:38:43 <AvengerX> ops
13:38:48 <AvengerX> busca :: BancoDeDados -> CodigoDeBarras -> Maybe (Nome,Preco)
13:38:51 <AvengerX> right?
13:39:02 <AvengerX> (sorry again)
13:39:03 <nmessenger> 'maybe' and 'fromMaybe' pulls values down, with defaults for Nothing, 'fmap' applies a function to the Just value if present.
13:39:12 <nmessenger> AvengerX: yep, see the last annotation
13:41:15 <nmessenger> maybe and fromMaybe yank values out of Maybes, fmap pushes functions into Maybes
13:41:32 <AvengerX> hmm
13:41:48 <nmessenger> @src Maybe fmap
13:41:49 <lambdabot> fmap _ Nothing       = Nothing
13:41:49 <lambdabot> fmap f (Just a)      = Just (f a)
13:42:05 <AvengerX> fmap is needed to turn the triplet into a touple?
13:42:10 <nmessenger> yep
13:42:18 <AvengerX> hmmm
13:43:03 <AvengerX> can't I do that maybe thing with lists by comprehension? (this is somewhat 'expected' to be used on the code)
13:43:21 <AvengerX> that would get me rid of the fmap wouldnt it?
13:43:37 <nmessenger> [ ... | Just x <- ... ]
13:43:47 <nmessenger> would drop the Nothings
13:43:56 <AvengerX> ah...
13:44:11 <AvengerX> no, it is not interesting
13:44:26 <nmessenger> you could alway use the code you started with :D
13:44:36 <encryptio> :t length
13:44:38 <lambdabot> forall a. [a] -> Int
13:44:57 <AvengerX> yeah, but this maybe will help me get skilled with haskell
13:45:02 <pjd> Int?
13:45:08 <pjd> what if you have a really big list?
13:45:16 <nmessenger> @type genericLength
13:45:18 <lambdabot> forall b i. (Num i) => [b] -> i
13:45:25 <pjd> hah, ok
13:45:35 <nmessenger> :)
13:45:47 <AvengerX> I would have a bigger list with touples and some nothings
13:46:06 <dibblego> how do you memoise factorial function, since suppose I call it with 10 and then 5 - I have already computed the value for 5?
13:46:10 <glguy> ?src foldM
13:46:10 <lambdabot> foldM _ a []     = return a
13:46:11 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:46:30 <AvengerX> anyway, this is 'intended' to be a supermarket list, the program would be enough to store the supermarket's stock in one list without filling 100Mb of RAM
13:46:31 <AvengerX> :P
13:47:58 <bolrod> 100MB is alot of articles... ;o
13:48:07 <encryptio> > foldl1 []
13:48:07 <lambdabot>  Couldn't match expected type `a -> a -> a'
13:48:26 <encryptio> > foldl1 (\x _ -> x) []
13:48:28 <lambdabot>  Exception: Prelude.foldl1: empty list
13:49:33 <nmessenger> Perhaps a Data.Map.Map CodigoDeBarras (Nome,Preco) would suit your needs better?
13:50:32 <glguy> ?pl \x y -> y x -- flip id, but does ?pl do better?
13:50:33 <lambdabot> flip id
13:50:36 <AvengerX> nmessenger: well, I'm thinking in doing something to 'busca' return either Just (touple) or Nothing
13:50:55 <glguy> ?type foldM (flip id) undefined
13:50:57 <lambdabot> forall a (m :: * -> *). (Monad m) => [a -> m a] -> m a
13:51:04 <AvengerX> Then i'll fill a (like) map [list_of_ints] busca x
13:51:14 <AvengerX> so I get a list of [busca x]
13:51:35 <AvengerX> then, a list of [Just (touple),Nothing,Just....]
13:51:52 <AvengerX> and only then, i'll format each of the Justs of that list
13:52:01 <nmessenger> > M.lookup 2 (M.fromList [(1,("apples",2.00)),(2,("cereal",1.50)),(3,("beef",5.00))]) :: Maybe (String,Double)
13:52:03 <lambdabot>  Just ("cereal",1.5)
13:52:08 <AvengerX> If its just something, format something, else show the default line
13:52:21 <nmessenger> > M.lookup 5 (M.fromList [(1,("apples",2.00)),(2,("cereal",1.50)),(3,("beef",5.00))]) :: Maybe (String,Double)
13:52:23 <lambdabot>  Nothing
13:52:50 <AvengerX> (its stated I must not use lookup)
13:52:57 <nmessenger> :)
13:53:16 <AvengerX> actually, my next step will be override lookup with this 'busca'
13:54:15 <AvengerX> lookup will be implied the 'bd' specification (it will be like busca bd <what_we_asked>), but we'll use lookup <our_question>
13:54:23 <dons> so how are we going to change the world today, guys?
13:54:26 <nmessenger> If your assignment is to actually *implement* lookup/find, using them in your definition probably won't work. :)
13:54:46 <glguy> are you thinking what I'm thinking, Pinky?
13:54:55 <AvengerX> yeah... that's nothing about find, but I think I must use lists by comprehension
13:55:08 <AvengerX> one used a list by comprehension to return a Just or Nothing today here
13:55:22 <nmessenger> well I think so Brayin, but where will we find the 50-gallon tub of lard and all the chickens?
13:55:31 <pjd> dons: unsafe*ly
13:55:41 * glguy high fives nmessenger 
13:55:50 * nmessenger goes down low
13:56:33 <dons> pjd, hehe
13:58:03 <AvengerX> > let bd = [(0,"zero",100),(1,"one",110),(2,"two",200)]; seek bdx x = [ (name,price) | (id, name, price) <- bd, id == x ] in seek bd 2
13:58:05 <lambdabot>  [("two",200)]
13:58:23 <AvengerX> > let bd = [(0,"zero",100),(1,"one",110),(2,"two",200)]; seek bdx x = maybe [ (name,price) | (id, name, price) <- bd, id == x ] in seek bd 2
13:58:25 <lambdabot>  Add a type signature
13:58:44 <pejo> dons, just looked at nobench. Going to publish anything about it, or write some technical report or simliar?
13:58:45 <AvengerX> let me flood -overflow :P
13:59:07 <sorear> morning dons!
14:00:19 <nrb23> I have a patch for http://www.haskell.org/networktools/src/pcap/ that adds cabal support... what's the best way to give this to the world?
14:00:20 <lambdabot> Title: Index of /networktools/src/pcap
14:00:55 <sorear> darcs send
14:01:18 <JohnnyL> #type qsort
14:01:21 <JohnnyL> @type qsort
14:01:22 <dons> pejo, hmm. you're the second person who's suggested this
14:01:24 <lambdabot> Not in scope: `qsort'
14:01:25 <dons> a TR makes sense
14:01:29 <sorear> in today's haskellverse, a repo that is not darcs sendable is a BUG
14:01:33 <dons> pejo: any suggestions?
14:01:34 <sorear> TR?
14:01:36 <dons> sorear: hehe
14:01:40 <dons> TR== technical report
14:01:44 <sorear> @type sort
14:01:47 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:02:05 <dons> a way of publishing a technical article, not quite of the standard to submit to a conference or workshop, or containting a lot of technical data
14:02:07 <sorear> JohnnyL: sort is quick
14:02:20 <dons> nrb23: one way is to contact the author
14:02:30 <dons> nrb23: if the author doesn't respond, fork :-)
14:02:36 <nrb23> dons: heh, okay :->
14:02:42 <sorear> dons: oh right.  somehow I thought you were respinding to nrb23.
14:02:46 <sjanssen> Data.List.sort isn't quicksort, but does sort quickly
14:02:46 <dons> if the source is open, use it ! :-)
14:02:57 <pejo> dons, nah, I know nothing about publishing. But a TR feels more solid than a web page, for citing purposes.
14:03:28 <dons> hmm.and people might start citing it eh.
14:03:31 * dons ponders
14:03:32 <pejo> dons, (and won't the page disappear if you graduate and leave?)
14:03:44 <dons> *if* i graduate?? !
14:03:54 <pejo> dons, no, if you *graduate and leave*.
14:03:54 <dons> but yes, i'll be moving a lot of my stuff to haskell.org
14:04:05 <xerox> hehe
14:04:07 <dons> you mean, "when you graduate and leave"
14:04:22 <AvengerX> thats it
14:04:24 <sorear> is it still graduating when you are promoted to faculty? :)
14:04:24 <xerox> :type if
14:04:24 <pejo> dons, theoretically you could graduate and stay. :-)
14:04:24 <AvengerX> > let bd = [(0,"zero",100),(1,"one",110),(2,"two",200)]; seek :: [(Int,String,Int)] -> Int -> Maybe (String,Int); seek bdx x = listToMaybe [ (name,price) | (id, name, price) <- bdx, id == x ] in seek bd 2
14:04:26 <lambdabot>  Just ("two",200)
14:04:31 <xerox> :t when
14:04:32 <AvengerX> > let bd = [(0,"zero",100),(1,"one",110),(2,"two",200)]; seek :: [(Int,String,Int)] -> Int -> Maybe (String,Int); seek bdx x = listToMaybe [ (name,price) | (id, name, price) <- bdx, id == x ] in seek bd 4378
14:04:34 <lambdabot>  Nothing
14:04:35 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:04:37 <xerox> Yeah he means that.
14:04:37 <AvengerX> :)
14:06:19 <AvengerX> hmmm
14:06:23 <AvengerX> if I
14:06:43 <AvengerX> f a b = [ (y,z) | (x,y,z) <- a]
14:06:49 <AvengerX> ok. but now if:
14:06:53 <AvengerX> f _ b = [ (y,z) | (x,y,z) <- ??]
14:07:13 <AvengerX> nonsense?
14:07:48 <wilx> _ says
14:07:49 <xerox> What do you mean?
14:07:58 <wilx> _ says "I don't care what the input is."
14:08:04 <wilx> If you care, you cannot say _.
14:08:22 <AvengerX> if I use 'a' in the parameter, I call it with 'a'. If I use '_', how I call it?..
14:08:23 <glguy> _ I'm never going to use this again so I'm not going to bother with a meaningful name
14:08:31 <AvengerX> ah ok
14:08:34 <jcreigh> it's kind of sad to listen to Alan Kay's 1997 keynote and hear him say "in the next ten years" and compare it to what actually happened.
14:08:40 <LoganCapaldo> LOL
14:08:43 <AvengerX> so I can't do it if I try f _ b
14:08:50 <Korollary> jcreigh: Alan Kay's keynote itself is sad imho.
14:09:27 <shawn> what's the url for his keynote?
14:09:36 <dibblego> sad.com
14:09:37 <Vq^> how can i make code that is dependent on a functor instance that is present in ghc6.6 but not in ghc6.4 portable?
14:09:45 <dons> cpp
14:10:07 <jcreigh> shawn: http://lambda-the-ultimate.org/node/2086 (has a link to Google video)
14:10:08 <lambdabot> Title: The Computer Revolution Hasn&#039;t Happened Yet | Lambda the Ultimate
14:10:28 <Vq^> dons: cpp?
14:10:52 <ddarius> C PreProcessor
14:10:52 <nmessenger> the c++ textual preprocessor
14:11:16 <ddarius> nmessenger: Wow, you are the only person that would call it C++'s.
14:11:27 <dons> #if __GLASGOW_HASKELL___ < 660
14:11:27 <shawn> I thought you guys were talking about some new keynote
14:11:37 <AvengerX> So if I want match a list of anything and a empty list I have to do a f [] b = Nothing ; f a b = [ (y,z) | (x,y,z) <- a, x == b ] ?
14:11:42 <Korollary> jcreigh said
14:11:44 <nmessenger> er, yeah I suppose it isn't C++'s, I just naturally react "C++" when I see "cpp"
14:11:46 <Korollary> "1997"
14:11:56 <AvengerX> No way to imbue the empty list in the two definitions?
14:12:01 <Vq^> dons: thanks
14:12:05 <Vq^> @karma+ dons
14:12:05 <lambdabot> dons's karma raised to 122.
14:12:06 <AvengerX> (in the second definition)
14:12:17 <sorear> @karma-all
14:12:17 <lambdabot>  "audreyt"             143
14:12:18 <lambdabot>  "dons"                122
14:12:18 <lambdabot>  "fglock"               58
14:12:18 <lambdabot>  "putter"               53
14:12:18 <lambdabot>  "lwall"                50
14:12:19 <lambdabot> [771 @more lines]
14:12:19 <ddarius> Wow dons
14:12:22 <JohnnyL> > sort [4,5,1,56,6,2,12,1]
14:12:24 <lambdabot>  [1,1,2,4,5,6,12,56]
14:12:26 <sorear> @more
14:12:43 <ddarius> Karma ddarius -> 0 Yay!
14:12:48 <JohnnyL> @type sort
14:12:50 <ddarius> @karma ddarius
14:12:51 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:12:51 <lambdabot> You have a karma of 1
14:12:56 <dons> audrey's has gone up a lot
14:12:56 <ddarius> What the?
14:13:03 <sorear> uh, why do they call him lwall now?
14:13:05 <dons> they must have tweaked the commit bot output
14:13:07 <Korollary> perl6 karma
14:13:24 <JohnnyL> @karma johnnyl
14:13:25 <lambdabot> johnnyl has a karma of 0
14:13:29 <ddarius> @seen lambdabot
14:13:30 <lambdabot> Yes, I'm here. I'm in #haskell.it, #haskell, #haskell.es, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell-
14:13:30 <lambdabot> overflow and #haskell-blah
14:13:31 <Korollary> There's got to be a karma exchange rate between channels.
14:13:34 <sorear> @topic-tell #perl6
14:13:35 <lambdabot> svn switch --relocate http://svn.openfoundry.org/pugs http://svn.pugscode.org/pugs/ | run.pugscode.org | spec.pugscode.org | paste: http://sial.org/pbot/perl6 | pugs.blogs.com | http://dev.pugscode.
14:13:35 <lambdabot> org/
14:13:36 <AvengerX> @karma Avengerx
14:13:37 <lambdabot> Avengerx has a karma of 0
14:13:53 <sorear> @karma-all
14:13:53 <sorear> @more
14:13:54 <jcreigh> @karma DONS
14:13:54 <lambdabot>  "audreyt"             143
14:13:54 <lambdabot>  "dons"                122
14:13:54 <lambdabot>  "fglock"               58
14:13:54 <lambdabot>  "putter"               53
14:13:54 <lambdabot>  "lwall"                50
14:13:56 <lambdabot> [771 @more lines]
14:13:58 <lambdabot>  "glguy"                48
14:13:58 <nmessenger> Korollary: heh, so 1 #haskell karma = 5 #perl6 karma?
14:14:00 <lambdabot>  "Cale"                 42
14:14:02 <lambdabot>  "dcoutts"              42
14:14:04 <lambdabot>  "lambdabot"            42
14:14:06 <lambdabot>  "sjanssen"             41
14:14:08 <sorear> @more
14:14:08 <lambdabot> [766 @more lines]
14:14:10 <lambdabot> Plugin `karma' failed with: IRCRaised thread killed
14:14:14 <AvengerX> @karma nmessenger
14:14:14 <lambdabot> nmessenger has a karma of 3
14:14:17 <sorear> @karma
14:14:17 <lambdabot> You have a karma of 24
14:14:24 <dons> sorear: the nobench takes a while to run now... :)
14:14:25 <nrb23> @karma
14:14:25 <lambdabot> You have a karma of 0
14:14:27 <LoganCapaldo> @karma
14:14:28 <Korollary> nmessenger: determined by free market of course
14:14:28 <lambdabot> You have a karma of 1
14:14:28 <AvengerX> @karma+ nmessenger
14:14:29 <lambdabot> nmessenger's karma raised to 4.
14:14:30 <dons> been going for 8 hours or so
14:14:36 <lispy> ?karma
14:14:36 <lambdabot> You have a karma of 21
14:14:36 <nmessenger> Korollary: :)
14:14:36 <AvengerX> @karma+ ddarius
14:14:36 <sorear> I thought mine was upto 40 now?
14:14:37 <lambdabot> ddarius's karma raised to 2.
14:14:40 <dons> i think i'll have to look at a proper parallel build system
14:14:49 <nrb23> @karma+ nrb23
14:14:49 <lambdabot> You can't change your own karma, silly.
14:14:51 <dons> sorear: yes, i think it made 40 too. hmm.
14:14:51 <AvengerX> :P
14:14:51 <nrb23> :->
14:14:55 <sorear> dons: 16 core nobench!
14:15:04 <dons> right
14:15:15 <dons> on 64 bits. would be useful (e.g. nhc will fail)
14:15:17 * sorear submits a patch to "correct" his karma (jk)
14:15:31 <dons> i'm not sure you can submit patches to karma ;)
14:15:38 <sorear> dons: slight problem there
14:15:38 <dons> maybe if we live in the matrix
14:15:49 <sorear> dons: personalities will defeat you
14:15:50 <nmessenger> is State/ not in the repository?
14:15:59 <sorear> dons: (or whatever *BSD calls them)
14:16:09 <Korollary> If we lived in the matrix, we'd be firing assault rifles instead of programming like a real hacker.
14:16:15 <dons> personalities??
14:16:21 <dons> sounds windows-ish
14:16:29 <sorear> linux actually
14:16:34 <lispy> Korollary: what do you mean, "If" ?
14:16:35 <sorear> run time abi switch
14:16:59 <Korollary> lispy: I'm not firing rifles, so I assume I am not in the matrix.
14:17:01 <sorear> among other things, allows 32 bit programs to run unchanged w/o addressing problems
14:17:17 <sorear> or does fbsd force everything to run 64bit?
14:18:35 <sorear> dons: so, eventually we'll have jhc-grin competing with jhc-ghc
14:18:39 <dons> sorear: oh, i see what you mean. the 16 core machine is running Fedora
14:18:50 <dons> and yeah, has dual 32 bit 64 bit stuff. but we're running in 64 bit iirc
14:19:01 <sorear> dons: now imagine what two jhcs in parallel will do to ram/disk
14:19:02 <dons> and i don't use fbsd anyway :)
14:19:27 <dons> sorear: well, there's 16 gig of ram. so i'm hoping that say, -j4 probably won't be noticeable
14:19:53 <sorear> oh, I thought you only had 2 :) nm then
14:20:24 <dons> clearly we need more system info on the results page
14:21:16 <LoganCapaldo> does lambdabot run on this ridiculous machine?
14:21:16 <sorear> dons: can you fudge the deps so that you don't need to rerun jhc when you upgrade yhc?
14:21:18 <LoganCapaldo> @uname
14:21:18 <lambdabot> Unknown command, try @list
14:21:26 <sorear> @versio
14:21:26 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
14:21:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:21:35 <LoganCapaldo> guess not
14:21:36 <sorear> > bitSize (0 :: Int)
14:21:37 <lambdabot>  32
14:21:46 <jcreigh> wow, 16 gigs. That seems like a lot of RAM.
14:22:02 <LoganCapaldo> but its only half as much ram as 32G
14:22:09 <ddarius> Indeed.  Why would anyone need more than 1 MB?
14:22:12 <sorear> jcreigh: don't forget everything is twice as big when you have a 64bit machine :)
14:22:29 <sorear> 64k, man
14:22:39 <sorear> ayhi forever!
14:22:53 <xerox> I've recently ordered 2Gb of RAM. The site was selling a 8Gb chip for eur11000.
14:23:00 <dons> sorear: ah i see.
14:23:01 <dons> hmm.
14:23:10 <dons> yes, we should have .touch files like the shootout
14:23:17 <dons> and just rely on make to fix things
14:23:47 <jcreigh> are 64-bit machines (by which I mean: x86-64) optimized for 64-bit memory alignment? If you wanted to have 32-bit ints, is that slower?
14:23:52 <dons> jcreigh: server with 16 cores. 16 gig seems small when you think about it ;)
14:24:02 <dons> jcreigh: yeah. slower.
14:24:27 <norpan> are they really slower?
14:24:31 <SamB> hmm.
14:24:48 <dons> 32 bit writes, instead of 64 bit writes?
14:24:48 <SamB> I doubt they are *slower*
14:24:53 <sorear> jcreigh: also x86-64 has built-in modeselection - forget user programs, you can run an unmodified 32bit *kernel*
14:25:11 <dons> we saw some speed ups from word32 to word64 writes on at least one amd64 box, with a small benchmark
14:25:12 <jql> as long as the int doesn't cross a 64-bit boundary, alignment shouldn't affect speed on the lastes processors
14:25:27 <SamB> dons: hmm.
14:25:38 <sorear> dons: I believe x86 wants 256-bit writes.  the L1 cache erases the granularity.
14:25:47 <SamB> well, remember that if you use 32-bit that could make it fit better in cache
14:30:22 <AvengerX> > fromMaybe Just ("Do"," ","It")
14:30:23 <lambdabot>  Couldn't match expected type `Maybe (a -> Maybe a)'
14:30:36 <AvengerX> > toMaybe Just ("Do"," ","It")
14:30:37 <lambdabot>   Not in scope: `toMaybe'
14:30:39 <AvengerX> ops
14:30:45 <AvengerX> > fromMaybe (Just ("Do"," ","It"))
14:30:47 <lambdabot>  <Maybe (Maybe ([Char],[Char],[Char])) -> Maybe ([Char],[Char],[Char])>
14:30:50 <dibblego> > fromMaybe $ Just ("Do"," ","It")
14:30:52 <lambdabot>  <Maybe (Maybe ([Char],[Char],[Char])) -> Maybe ([Char],[Char],[Char])>
14:31:04 <nrb23> > fromMaybe $ Just ("Do", " ", "it")
14:31:05 <lambdabot>  <Maybe (Maybe ([Char],[Char],[Char])) -> Maybe ([Char],[Char],[Char])>
14:31:20 <nmessenger> > fromMaybe ("","","") (Just ("Do"," ","It"))
14:31:21 <lambdabot>  ("Do"," ","It")
14:31:27 <AvengerX> wanted ("Do"," ","It")
14:31:46 <AvengerX> ...and nmessenger saves the day
14:31:50 <nmessenger> > fromMaybe ("","","") (Nothing)
14:31:52 <lambdabot>  ("","","")
14:31:53 <xerox> Prelude> "do it"
14:31:53 <xerox> "do it"
14:31:53 <xerox> Prelude> Just (do it)
14:31:53 <xerox> Just "do it"
14:31:59 <mightybyte> How should I go about debugging complicated recursion?
14:32:13 <nmessenger> > return "do it" :: Maybe String
14:32:15 <lambdabot>  Just "do it"
14:32:34 <xerox> GHCi defines it (-:
14:32:43 <nmessenger> hahah
14:33:24 <mightybyte> In an imperative language, I would make liberal use of print statements to watch program flow, but that's harder to do in Haskell.
14:33:39 <allbery_b> Debug.Trace.trace
14:33:40 <xerox> ?docs Debug.Trace
14:33:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
14:33:48 <nmessenger> in IO, use those same print statement, in pure code, ^^ Debug.Trace
14:33:49 <AvengerX> mightybyte: try Hoare's calculus
14:33:59 <allbery_b> be aware that will strictify
14:34:10 <allbery_b> (i.e. don't try to do it on an infinite list)
14:34:12 <dons> use 'trace' :-)
14:34:46 <zeeeee> what's a CAF? 0-arity function? i tried googling but found no primers.
14:34:50 <mightybyte> Ok, thanks
14:35:01 <nmessenger> zeeeee: yep, "constant applicative form"
14:35:05 <newsham> ?check \s -> (unwords.map reverse.reverse.words) s == reverse s
14:35:07 <lambdabot>  OK, passed 500 tests.
14:36:08 <newsham> ?check \s f g -> (unwords.f.words).(unwords.g.words) s == (unwords.f.g.words) s
14:36:09 <lambdabot>  Couldn't match expected type `a -> String'
14:37:15 <nmessenger> zeeeee: http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html#prof-rules
14:37:18 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/2z559y
14:37:56 <zeeeee> nmessenger: hmm...ok, so it sounds like CAFs are constants or primitive partial applications on constants. i don't see what this has to do with this dynamic programming, as suggested by this comment: http://developers.slashdot.org/comments.pl?sid=142494&cid=11940393
14:37:59 <lambdabot> Title: OCaml vs. C++ for Dynamic Programming, http://tinyurl.com/yp2dal
14:38:10 <zeeeee> would anyone happen to know?
14:38:47 <nmessenger> a CAF is an implementation detail of GHC, I'm not sure how it'd apply
14:39:19 <zeeeee> he said "you fill a CAF" as if it were some data structure
14:39:24 <newsham> ?check \xs -> sum xs == sum $ reverse xs
14:39:25 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
14:39:36 <newsham> ?check \xs -> sum xs == sum (reverse xs)
14:39:37 <lambdabot>  Add a type signature
14:39:46 <dons> dcoutts: i notice lennart used the following type in his prime sieve, data StreamInt = !Int :> StreamInt
14:39:47 <newsham> ?check \xs -> sum (xs :: [Int]) == sum (reverse xs)
14:39:49 <lambdabot>  OK, passed 500 tests.
14:39:56 <dons> dcoutts: some hints there for the lazy bytestring type, eh?
14:42:03 <astrolabe> @hoogle (:>)
14:42:04 <lambdabot> Did you mean: (:>)
14:42:04 <lambdabot> Prelude.undefined :: a
14:42:04 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:42:23 <ddarius> zeeeee: You it's a way to memoize certain things easily and utilize lazy evaluation.
14:42:23 <allbery_b> he defined an infix constructor
14:43:36 <nmessenger> zeeeee: perhaps s/CAF/thunk/ would make more sense in that comment?
14:43:49 <zeeeee> nmessenger: yeah, i think so
14:43:53 <AvengerX> > fromMaybe ("oh my") (Just ("Do"," ","It"))
14:43:54 <lambdabot>  Couldn't match expected type `[Char]'
14:44:07 <AvengerX> > fromMaybe ("oh my") Just ("Do"," ","It")
14:44:08 <lambdabot>  Couldn't match expected type `Maybe [Char]'
14:44:18 <AvengerX> >>
14:44:31 <nmessenger> AvengerX: ("oh my") isn't the same type as ("Do"," ","It")
14:44:51 <AvengerX> fromMaybe ("oh my","","") Just ("Do"," ","It")
14:44:54 <AvengerX> didn't work also
14:45:10 <nmessenger> > fromMaybe ("oh my","","") (Just ("Do"," ","It"))
14:45:13 <lambdabot>  ("Do"," ","It")
14:45:20 <nmessenger> forgot the parens
14:45:25 <AvengerX> ahh ok
14:45:44 <AvengerX> (tried it in first -- wrong -- match and forgot to place it back :P
14:45:46 <AvengerX> )
14:48:07 <AvengerX> hmm
14:48:42 <AvengerX> if I have f::Int->Int and g::Int->Int->Int I can't f.g, can I?
14:48:52 <dibblego> why doesn't GHC 6.6 include QuickCheck(-any)?
14:48:57 <LoganCapaldo> sure you can
14:49:00 <AvengerX> iow:
14:49:01 <AvengerX> > snd ( fromMaybe ("",0) (Just ("Oak",2)) )
14:49:03 <lambdabot>  2
14:49:06 <nmessenger> @type (undefined::Int->Int) . (undefined::Int->Int->Int)
14:49:09 <lambdabot>     Couldn't match expected type `Int'
14:49:09 <lambdabot>            against inferred type `Int -> Int'
14:49:12 <SamB> dibblego: you have extralibs and no quickcheck/
14:49:17 <SamB> s|/|?|
14:49:18 <nmessenger> @type ((undefined::Int->Int) .) . (undefined::Int->Int->Int)
14:49:20 <lambdabot> Int -> Int -> Int
14:49:39 <nmessenger> (f.).g
14:49:43 <AvengerX> hmmm
14:49:43 <LoganCapaldo> err
14:49:44 <AvengerX> !
14:49:45 <LoganCapaldo> yeah
14:49:55 <dibblego> I just installed ghc 6.6 from source and now CABAL complains when I do a configure
14:49:57 <LoganCapaldo> you can with more dots :)
14:50:02 <AvengerX> > ((snd.) . fromMaybe) ("",0) (Just ("Oak",2)) )
14:50:03 <lambdabot>  Parse error
14:50:03 <sjanssen> dibblego: GHC HQ wants to have a smaller distribution, so they cut out several libraries
14:50:04 <nmessenger> (f.).g = \x -> f . g x
14:50:28 <dibblego> sjanssen, ok, so I install QC separately somehow?
14:50:33 <AvengerX> what becomes of the 'y' needed to g?
14:50:47 <nmessenger> \x -> f . g x = \x y -> f (g x y)
14:51:01 <SamB> dibblego: ./darcs-all --help or something
14:51:01 <sjanssen> dibblego: the simplest thing to do is probably install extralibs with ghc (the tarball is on the ghc downloads page)
14:51:17 <SamB> oh, right, tarball
14:51:19 <dibblego> ok cheers
14:51:24 <SamB> ;-)
14:51:49 <AvengerX> well, its clearer without composition anyway
14:51:49 <dibblego> oh is *that* what that is? :)
14:51:50 <AvengerX> :)
14:52:26 <nmessenger> @type let (.:)=(.).(.) in (undefined::Int->Int) .: (undefined::Int->Int->Int)
14:52:29 <lambdabot> Int -> Int -> Int
14:52:48 <CyberScript32> hi
14:52:53 <nmessenger> greets!
14:53:04 <AvengerX> CyberScript32: hello brazooka mate :)
14:53:11 <dons> hi
14:53:45 <AvengerX> It seems I'm not the only brazillian which likes haskell around here anymore :P
14:53:57 <GsD_Celeborn> I am trying to use haddock
14:54:22 <AvengerX> ...or maybe I am
14:54:58 <dons> AvengerX: there's a fair few. syntaxfree is a pretty well known blogger on haskell stuff, for example
14:55:14 <GsD_Celeborn> but it is not recognizing --|
14:55:23 <dons> -- |
14:55:24 <nmessenger> -- *space* |
14:55:26 <dons> missing space
14:55:33 <GsD_Celeborn> -- |
14:55:36 <GsD_Celeborn> this ?
14:55:37 <AvengerX> ehn!
14:55:50 <AvengerX> what is haddock? Syntax parser?
14:55:59 <dons> a documentation generator
14:56:00 <GsD_Celeborn> is
14:56:02 <dons> ?docs Data.List
14:56:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
14:56:04 <GsD_Celeborn> yes
14:56:05 <dons> for this ^^
14:56:13 <AvengerX> for wikipedia its just a fish :P
14:56:16 <nmessenger> @source Data.List
14:56:17 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
14:56:23 <nmessenger> ^^ notice the annotations
14:56:30 <mbishop> Haskell cookbook made it to reddit, seems people like it :)
14:56:36 <dons> mbishop: yeah!
14:56:41 <GsD_Celeborn> -- |The 'square' function squares an integer.
14:56:42 <dons> mbishop++ great work :-)
14:56:49 <GsD_Celeborn> this done ?
14:57:02 <dons> looks ok to me. and the square function is exported from the module?
14:57:34 <chessguy> hi haskellers
14:57:36 <GsD_Celeborn> no
14:57:44 <AvengerX> hello there chessguy
14:57:45 <AvengerX> o/
14:57:59 <dons> you also need a type signature on the function
14:58:02 <dons>  hddock ignores functions without type signatures
14:58:27 <GsD_Celeborn> square :: Int -> Int
14:58:31 <GsD_Celeborn> this ?
14:58:55 <nmessenger> yes
14:59:31 <GsD_Celeborn> i use windows
15:00:55 <GsD_Celeborn> I'm using this example http://haskell.org/haddock/haddock-html-0.8/markup.html#id288849
15:00:56 <lambdabot> Title: Chapter 3. Documentation and Markup
15:01:08 <GsD_Celeborn> but , not done
15:01:46 <dibblego> can you write extractors for pattern matching a data type?
15:03:08 <nmessenger> unA (A x) = x ?
15:03:27 <dibblego> what's that?
15:04:03 <nmessenger> a function unA that removes the 'A' constructor from some data value.
15:04:24 <dibblego> oh yeah
15:04:26 <AvengerX> > let moh=[Just ("Me",15),Nothing,Just ("You",26)]; sumall xs = sum [ item | item <- fromMaybe ("",0) xs, xs /= Nothing ] in sumall moh
15:04:27 <lambdabot>  Couldn't match expected type `[t]'
15:04:30 <dibblego> jumping between languages sucks
15:04:31 <AvengerX> want summing just 15 and 26
15:04:32 <AvengerX> :)
15:05:06 <nmessenger> (sum (map snd (catMaybes ...)))
15:05:36 <AvengerX> ahh catMaybes! :)
15:05:45 <Botje> sum [ x | Just (_,x) <- xs ]
15:05:47 <nmessenger> @src catMaybes
15:05:48 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:06:09 <AvengerX> like botje's
15:06:16 <nmessenger> > catMaybes [Just 1, Nothing, Just 3]
15:06:18 <lambdabot>  [1,3]
15:06:28 <AvengerX> :P
15:06:52 <LoganCapaldo> > take 5 $ catMaybes (fix (Nothing:))
15:06:56 <lambdabot> Terminated
15:07:03 * nmessenger 's never really used list comprehensions
15:07:11 <Botje> list comprehensions rock.
15:07:39 <nmessenger> sum (do Just (_,x) <- xs; return x) -- :P
15:07:53 <dibblego> are tuples strict?
15:08:01 <nmessenger> dibblego: no, strict tuples are
15:08:14 <dibblego> how do they look?
15:08:23 <nmessenger> > (# 1, "alpha" #)
15:08:23 <lambdabot>  Parse error
15:08:35 <nmessenger> GHC only, LB doesn't have glasgow-exts
15:08:41 <LoganCapaldo> I thougth (# x, y #) was unboxed, not strict?
15:08:43 <dibblego> mk
15:09:00 <nmessenger> LoganCapaldo: there's a difference?
15:09:03 <LoganCapaldo> (well unboxed -> strict I guess)
15:09:15 <AvengerX> lambdabot should strip IRC codes :P
15:09:32 <AvengerX> so we can make syntax hilighted samples with >
15:09:32 <AvengerX> :P
15:09:41 <nmessenger> @id /msg AvengerX she puts a space before stuff just in case
15:09:42 <LoganCapaldo> well strict tuples implies they could hold boxed values
15:09:42 <lambdabot>  /msg AvengerX she puts a space before stuff just in case
15:10:12 <AvengerX> ?
15:10:17 <LoganCapaldo> ie: ([1,2,3], 4) would work for a strict tuple, but not an unboxed one
15:10:22 <allbery_b> unrelated
15:10:24 <LoganCapaldo> unless I'm totally nuts :)
15:10:37 <allbery_b> <AvengerX> > let moh=[Just ("Me",15),Nothing,Just ("You",26)]; sumall xs = sum [ item | Just (_,item) <- xs] in sumall moh
15:10:37 <allbery_b> <lambdabot>  Illegal character ''\STX''
15:10:46 <nmessenger> oh
15:10:50 <allbery_b> (the Just (_,item) was bolded
15:10:52 <AvengerX> lol
15:10:53 <allbery_b> )
15:11:04 <therp> yow. I have a liskell repl
15:11:11 <nmessenger> @yow!
15:11:12 <lambdabot> Now I'm being INVOLUNTARILY shuffled closer to the CLAM DIP with the
15:11:13 <lambdabot> BROKEN PLASTIC FORKS in it!!
15:11:53 <nmessenger> @where liskell
15:11:53 <lambdabot> I know nothing about liskell.
15:11:59 <nmessenger> D:
15:12:09 <SamB> @google liskell
15:12:11 <lambdabot> http://clemens.endorphin.org/liskell
15:12:12 <lambdabot> Title: Liskell - clemens.endorphin.org
15:12:36 <nmessenger> @where+ liskell http://clemens.endorphin.org/liskell
15:12:37 <lambdabot> Done.
15:12:42 <therp> thanks
15:13:05 <therp> wow, I claimed the term Liskell quite quickly. I remember the google query for that name I did 2 months ago was return 500 results..
15:13:13 <nmessenger> therp++
15:13:14 <therp> now it's returning 17600?
15:13:16 <chessguy> @paste
15:13:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:14:23 <chessguy> ?seen Cale
15:14:23 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 38m 51s ago.
15:14:35 <sorear> therp: I'm working on a replacement for yhi with much greater dynamicity.  you'll be able to upgrade *the interpreter* without even a re-exec.  Code fragments can be garbage collected, etc.  Nowhere near ready for publicity yet (all it does is fail to assemble, all the last version did was "Hello World")
15:14:55 <therp> sorear: that sounds nice!
15:15:17 <therp> sorear: the next big roadblock for me was how to move the GHC model of compilation/linking/loading to a more dynamic style
15:16:58 <sorear> therp: I have experience with writing Forths - this is turning into a Forth with GC. *muahahaha*  I've already figured out how I'll dynamically link into yhc, then you'll have a full repl.  *muahahaha*
15:17:07 <Saizan> what's the type of liskell lists?
15:17:18 <therp> saizan: ([] a)
15:17:26 <sorear> ddarius++ Exists is *brilliant*
15:17:31 <Saizan> (#\a "mixed" list) <-- even this?
15:17:32 <therp> generic type constructor syntax from ghc
15:17:52 <hpaste>  chessguy pasted "getting the same "random" program every time..." at http://hpaste.org/666
15:18:12 <Botje> heh. appropriate paste no.
15:18:28 <therp> saizan: that's just a parse tree example that is not valid expression
15:18:33 <therp> +a
15:18:38 <chessguy> when i do randomPrograms 5, for example, i get the same 'random' tree for all 5
15:18:55 <chessguy> well, i should clarify
15:19:14 <chessguy> i actually do evalState (randomPrograms 5) (GlobalState { randomGen = mkStdGen 42 })
15:19:23 <ddarius> sorear: Unfortunately, you rarely have a type constructor that perfectly matches.  First order type functions would be handy for that.
15:19:38 <nmessenger> therp: would you say that it's just a bunch of untyped lisp cons-lists that later get translated into TH-like ASTs?
15:20:13 <sorear> ddarius: we have full type functions, already. (with bad syntax)
15:20:29 <therp> sorear: well, GHC can load native code and link in memory.. for some reason it can only do that for existing .o files I think.. in memory compilation to native code isn't possible.. maybe because of the cmm stuff
15:20:35 <sorear> newtype K a b = K b
15:20:35 <sorear> newtype S a b c = S ((a c) (b c))
15:20:37 <ddarius> sorear: But I need them to be convenient and to fit well with the language.
15:20:51 <sorear> repeat ad nauseum until GHC adds kind polymorphism.
15:21:01 <nmessenger> :}
15:21:16 <ddarius> It may still work, I don't know.
15:21:30 <therp> nmessenger: the particular example can't be translated, or are you talking about something else?
15:21:31 <chessguy> ugh. not only that, i'm getting the same function every time i'm not at maximum depth, and the same terminal every time i am
15:21:46 <AvengerX> how do I override the 'lookup' function with one from me?
15:21:48 <AvengerX> :P
15:22:01 <sorear> therp: don't use the GHC-API it is very low level.  hs-plugins (which uses GHC-API, and is potentially portable) *already* has System.Eval.Haskell.eval "\x -> x + x"  which compiles.
15:22:05 <AvengerX> ported my program entirely to Maybe' paradigm :P
15:22:05 <nmessenger> therp: not that example, just the syntax in general can lispy things, then later it becomes Haskell ASTs.
15:22:11 <ddarius> I'd use a different name, or you can hide it locally, or you can import the Prelude explicitly and hide it.
15:22:21 <AvengerX> hmm
15:22:26 <AvengerX> hide lookup?
15:22:39 <AvengerX> after 'module <name> where' ?
15:22:48 <nmessenger> import Prelude hiding (lookup)
15:22:51 <therp> nmessenger: yes, the become haskell asts. http://clemens.endorphin.org/ILC07-Liskell-draft.pdf page 3 show the Liskell compilation "model"
15:23:00 <AvengerX> k
15:23:02 <AvengerX> ty
15:23:10 <Botje> chessguy: why not get a randomly seeded StdGen from getStdGen ?
15:23:27 <AvengerX> b-b-ut, isnt prelude already imported?
15:23:32 <therp> sorear: eval is the next thing I have to add. I will certainly have a look at hs-plugins
15:23:38 <ddarius> Not if you explicitly import it.
15:23:45 <AvengerX> hmm
15:23:48 <dibblego> how do you ask lambdabot for the source of an instance declaration?
15:23:54 <chessguy> why is my random number generation so totally broken?
15:24:02 <therp> nmessenger: s/the/the liskell parse tree/ sorry for the missing word typos -- I'm a bit tired
15:24:04 <dibblego> chessguy, it's not! it's *meant* to be random
15:24:08 <Botje> chessguy: because you're giving it the same seed over and over again.
15:24:09 <AvengerX> @src instance, I think
15:24:09 <lambdabot> Source not found. You speak an infinite deal of nothing
15:24:19 <chessguy> Botje, how do you figure?
15:24:21 <AvengerX> @src splitAt
15:24:22 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
15:24:25 <ddarius> sorear: The term-level syntax for those existentials though is very close to builtin syntax.
15:24:25 <chessguy> dibblego, but it's NOT random
15:24:25 <Botje> 00:16 < chessguy> i actually do evalState (randomPrograms 5) (GlobalState { randomGen = mkStdGen 42 })
15:24:36 <Botje> that 42 is the "seed" value of the RNG
15:24:39 <dibblego> chessguy, it's randomly not random :)
15:24:44 <therp> hmm.. if tired then Just ("go", 2, "sleep") else Nothing
15:24:49 <chessguy> Botje, yes, but i'm using the rng multiple times in the program
15:24:54 <chessguy> if you look at the code
15:24:58 <AvengerX> I can't: import Prelude -- COmment ?
15:25:25 <AvengerX> (vim's syntax does not hilights it accordingly)
15:25:36 <chessguy> let me show you sample output too
15:25:55 <AvengerX> it does not return an error tough
15:26:17 <Botje> ?src ForM
15:26:18 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:26:36 <fnord123> ?filter odd [1..10]
15:26:37 <lambdabot> Unknown command, try @list
15:26:48 <chessguy> ?src forM
15:26:48 <lambdabot> forM = flip mapM
15:27:19 <AvengerX> curse this laggy DSL. 500ms ping from my machine to my nexthop... :/
15:27:20 <hpaste>  chessguy annotated "getting the same "random" program every time..." with "sample input/output" at http://hpaste.org/666#a1
15:28:16 <chessguy> Botje, see what i mean?
15:29:06 <Botje> hrrm.
15:30:01 <fnord123> > filter odd [1..10]
15:30:03 <lambdabot>  [1,3,5,7,9]
15:30:09 <nmessenger> therp: just wanted to make it clear for Saizan.
15:30:14 <AvengerX> Lemme reconnect this shitty dsl to see if I get better speeds.
15:30:18 <AvengerX> brb
15:31:05 <fnord123> > let button = buttonNewWithLabel "Hello"
15:31:06 <Botje> chessguy: perhaps it's unfoldtreeM being naughty?
15:31:06 <lambdabot>  Parse error
15:31:11 <LoganCapaldo> ((+) 2 3) -- Bah, who needs liskell
15:31:16 <LoganCapaldo> > ((+) 2 3) -- Bah, who needs liskell
15:31:17 <lambdabot>  5
15:31:22 <fnord123> >:module + Graphics.UI.Gtk
15:31:40 <chessguy> being naughty how?
15:31:47 <dons> sorear: ok. so we have a proper parallel build system for nobench now
15:31:50 <dons> yay for gnu make
15:32:01 <dons> mm. wow. actually, this really speeds things up
15:32:06 <JohnnyL> @source (+)
15:32:06 <lambdabot> (+) not available
15:32:13 <JohnnyL> @source sort
15:32:14 <lambdabot> sort not available
15:32:15 <LoganCapaldo> @src (+)
15:32:15 <lambdabot> Source not found. Are you on drugs?
15:32:25 <LoganCapaldo> @src sort
15:32:25 <dons> ?src sort
15:32:25 <chessguy> ?src sort
15:32:25 <lambdabot> sort = sortBy compare
15:32:26 <lambdabot> sort = sortBy compare
15:32:26 <lambdabot> sort = sortBy compare
15:32:31 <dons> jinx!
15:32:43 <JohnnyL> @src sortBy
15:32:43 <nmessenger> therp: though I wonder why you copied Haskell's special-case 'if' instead of making it an ordinary function. :P
15:32:43 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:32:48 <chessguy> @quote answer
15:32:49 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:33:47 <LoganCapaldo> I wonder if theres a correalation between experience with Haskell and the use of @ vs. ? as command prefixes to lambdabot
15:34:09 <dons> ok  wow. this is ridiculously faster, -j10 nobench
15:34:09 <chessguy> hmm, i doubt it. i use both, rather randomly
15:34:44 <nmessenger> LoganCapaldo: I used both randomly when first toying around with LB, now I mostly use @, and I notice dons uses ? a lot.
15:35:48 <therp> nmessenger: I think I started with the most simple things when implementing. then later -- despite finding it redundant -- so non-Haskell people find at least one thing they are familiar with :)
15:35:59 <ddarius> Lambdabot only had @ when I was last here.
15:36:26 <nmessenger> oops, gotta go, later folks
15:36:30 * nmessenger waves
15:36:34 <therp> bye
15:36:37 <LoganCapaldo> So long, nmessenger
15:36:42 <therp> and I will go to bed. /me waves too
15:37:22 * fons thinks that ? must be the affectionate way of using lambda bot, as dons is lambdabots pappa ;)
15:37:32 <LoganCapaldo> heh
15:37:46 <ddarius> God father would be better.
15:38:04 <LoganCapaldo> This obviously needs to become a new stat <g>
15:38:23 <LoganCapaldo> "dons uses ? 99.5% of the time"
15:38:30 <LoganCapaldo> @stats
15:38:30 <lambdabot> Unknown command, try @list
15:38:35 <LoganCapaldo> @list
15:38:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:38:47 <Botje> chessguy: have you tried a different seed?
15:38:59 <fons> it would be nice to get the command list as a private message
15:39:04 <Botje> there's always the small possibility it's just one hilarious coincidence
15:39:36 <LoganCapaldo> @where stats
15:39:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
15:39:50 <vincenz> @join #squeak
15:40:03 <chessguy> yeah, 41 gieves the exact same result
15:40:37 <chessguy> *gives
15:42:16 <chessguy> Cale, ping
15:42:25 <ddarius> How is it that Haskell pokes so many tendrils into other communities and partially grabs so many people from other communities but not the other way around?
15:42:53 <LoganCapaldo> ddarius, I'm not sure what the other way around would be?
15:42:55 <ddarius> I think I partially understand actually.
15:42:58 <dons> ddarius: good question
15:43:36 <ddarius> LoganCapaldo: Haskellers hanging about other languages IRC channels, be beswarmed by other language bots to use this area as an example.
15:43:44 <dons> e.g. haskell rubbing on perl6, but perl6 doesn't rub on haskell much
15:43:53 <lupo__> ddarius: because it's a cool community. I can tell you because I'm a complete noob when it comes to haskell. people are so friendly here, absolutely incredible.
15:43:54 <ddarius> Exactly.
15:44:09 <dons> lupo__: great to know!
15:44:15 <ddarius> lupo__: That is where my partial understanding comes from.
15:44:21 <chessguy> not to mention the cool language :)
15:44:32 <ddarius> I have long said the most valuable thing about Haskell is it's community.
15:44:39 <lupo__> chessguy: what? this channel is about programming? I gotta leave. :-D
15:44:58 <dons> ddarius: that's right. otherwise we're just clean or ocaml.
15:45:30 <hpaste>  fnord123 pasted "Can't add buttons to button boxes in gtk2hs?" at http://hpaste.org/667
15:45:31 <chessguy> dons, well, i don't know about that. the language itself still has benefits over clean or ocaml, even without the community
15:45:31 <dons> its the community that writes the libraries...
15:45:37 <Philippa> the combined purity and pragmatism's a big deal too. Having the combination's partly due to cool people, of course
15:45:51 <ddarius> Of course, the natural next question is "Why is the Haskell community this way?" it doesn't need to be, as the Lisp community aptly illustrates.
15:45:51 <dons> that's true. but partly that's due to having a community keeping the development happening
15:45:56 <Philippa> chessguy: it wouldn't have if you took away what the community's done in the last decade
15:46:18 <chessguy> hm, true
15:46:18 <Philippa> Haskell's not old enough to be 90% cranky curmudgeons yet? :-)
15:46:21 <dons> ddarius: the theory of open source says its the founders who establish the culture
15:46:37 <dons> ddarius: so if you read the 1990 haskell mailing list thread, there's 20 people, and the conversations are much the same
15:46:52 <mbishop> Philippa: I thought only C made people cranky :P
15:47:00 <dons> and we've all inherited that friendly, open, lets-make-the-world-better attitude
15:47:06 <fnord123> if i wanted to help out, how would i go about getting funding?
15:47:34 <Philippa> fnord123: find something one of the haskell-using companies wants doing
15:47:39 <ddarius> dons: But surely there are many other programming communities with similar or at least just as welcoming atmospheres of their founders.
15:47:39 <chessguy> so, anyway, why is my RNG totally broken? http://hpaste.org/666#a1
15:47:42 <Philippa> or do something academic enough that's helpful
15:47:51 <Philippa> but most of the stuff that gets done gets done for free
15:47:59 <Philippa> oh yeah, Summer of Code if you're eligible
15:48:15 <dons> ddarius: probably also the effect of having a lot of teachers in the community. so we keep training people
15:48:30 <Philippa> yep, I'm an example there
15:48:38 <fnord123> im not eligabile for soc. i graduated a while back
15:48:46 <ddarius> dons: How formal are you taking the word "teacher"?
15:48:48 <Philippa> OK, I'm largely self-taught, but only largely
15:48:55 <Philippa> ddarius: including lecturers
15:49:23 <fnord123> in any event, is anyone like dcoutts around/
15:49:35 <Philippa> it's nearly midnight here, so he might not be
15:49:38 <ddarius> A lot of the "teaching" that goes on doesn't seem to come from teachers in my experience.
15:49:50 <Philippa> sure. But a lot of initial exposure has done historically
15:49:55 <fnord123> s/like dcouts/involved in gtk2hs/
15:50:14 <Philippa> that's less true now, but still a significant proportion of beginners
15:50:17 <chessguy> ddarius, i guess that depends on who you consider the teachers
15:50:32 <ddarius> chessguy: That's what I was asking dons.
15:50:35 <Philippa> dons: hope I'm not misrepresenting your argument?
15:51:13 <reilly> So, I have a stupid question.  Why does liftM have the type (a->b) -> M a -> M b  ?  I would have though it would have the type (a -> b) ->  a -> M b instead
15:51:39 <chessguy> i consider myself a teacher in that i like to communicate what little i know to other newbies in a way they can understand
15:51:58 <LoganCapaldo> (a -> b) -> a -> m b is just (return .)
15:52:17 <Philippa> chessguy: *nod* - I used to do a lot more teaching in here than I do now
15:52:41 <ddarius> I just poke in interesting things upon occasion.
15:53:03 <ddarius> My online "persona" has always been like that.
15:53:24 <reilly> LoganCapaldo: I understand that.  But isn't the canonical monadic component a -> M b ?
15:53:40 <Philippa> whereas mine's always been inclined to pun in response to lines like that :-)
15:54:04 <allbery_b> reilly: the point of liftM is to run the (a->b) on an a in a monad, producing a b in a monad
15:54:04 <Philippa> reilly: only insofar as that's "something you put into bind"
15:54:44 <allbery_b> if you have just an a, there are other ways to pull it into the monad
15:54:45 <reilly> philippa: and what a do looks like
15:54:46 <LoganCapaldo> liftM f a -- b instead of a >>= liftM f -- b
15:55:04 <LoganCapaldo> (the second one being if liftM had the type you suggested
15:55:25 <Philippa> reilly: a do statement gives you an m a, not an a -> m b
15:56:00 <hyrax42> hm
15:56:06 <hyrax42> people can see this?
15:56:28 <fnord123> i wonder where hyra42 is. he hasn't said anything in ages
15:56:39 <allbery_b> :)
15:56:50 <hyrax42> hrmmm
15:56:52 <hyrax42> this is really strange
15:56:54 <mdmkolbe> @pointless \f g x -> f (g x)
15:56:55 <lambdabot> (.)
15:57:06 <hyrax42> everything but IRC stopepd working
15:57:11 <hyrax42> IM, email, web all of it
15:57:22 <AvengerX> bah. they won't fix it until tomorrow
15:57:24 <AvengerX> i'm suffering that hi latencies since the beginning of the month.
15:57:26 <AvengerX> hyrax42: it's not my case :P
15:57:29 <AvengerX> hyrax42 maybe something with nat has stopped
15:57:37 <hyrax42> seems DNS died
15:57:50 <AvengerX> connections already being tracked are kept but new connections are not made
15:57:58 <AvengerX> are you behind NAT?
15:58:22 <reilly> Philippa: ack ... yeah ... thinking of functions i built with do
15:58:40 <AvengerX> heh
15:58:47 <AvengerX> i wonder how does 'do' work in haskell :P
15:58:55 <hyrax42> I can ping IPs, but not names
15:58:57 <hyrax42> I think it's DNS
15:59:02 <LoganCapaldo> @undo do { x <- y; return $ x + 1 }
15:59:03 <lambdabot> y >>= \ x -> return $ x + 1
15:59:08 <AvengerX> well, try using one of the root-servers.. heh
15:59:31 <AvengerX> maybe you can use 200.216.240.114, my client asked me to open its relay
15:59:41 <LoganCapaldo> AvengerX, that's how, it just transforms the expression
15:59:54 <AvengerX> it'll be working for some time
15:59:58 <AvengerX> LoganCapaldo: transforms how?
16:00:08 <AvengerX> @src do
16:00:09 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:00:10 <dibblego> with the compiler
16:00:11 <LoganCapaldo> no
16:00:13 <ddarius> http://www.haskell.org/tutorial/monads.html
16:00:14 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
16:00:24 <AvengerX> oh
16:00:27 <AvengerX> monads
16:00:29 <dibblego> do is a keyword
16:00:30 <LoganCapaldo> its syntactic sugar
16:00:32 <AvengerX> the famous monads :P
16:00:40 <AvengerX> hmm
16:00:50 <AvengerX> syntactic sugar of what exactly?
16:00:54 <LoganCapaldo> @undo do { x <- y; return $ x + 1 }
16:00:55 <lambdabot> y >>= \ x -> return $ x + 1
16:00:55 <ddarius> Contains the simple desguraing of do notation
16:00:56 <allbery_b> if you really want to know, the haskell98 report defines how do blocks are translated
16:01:14 <AvengerX> ahh! the >>!
16:02:11 <AvengerX> well, I am content of having a idea of it right now, but I'll sure drown into this later
16:02:51 <LoganCapaldo> @redo x >>= \y -> print y
16:02:51 <lambdabot> do { y <- x; print y}
16:03:37 <LoganCapaldo> @redo a >>= \_ -> b
16:03:37 <lambdabot> do { _ <- a; b}
16:03:37 <Gwern> Hey everyone. I'm trying to find a function which will take a list of strings, and another list of strings, and then use the entries in the first list and filter out entries in the second list if they don't contain any entries in the first list as substrings
16:03:50 <LoganCapaldo> @redo a >> b
16:03:50 <lambdabot> do { a; b}
16:03:58 <Gwern> any ideas on whether it already exists, or how I could write it?
16:04:18 <chessguy> @type filter (not.elem)
16:04:20 <lambdabot>     Couldn't match expected type `Bool'
16:04:20 <lambdabot>            against inferred type `[a] -> Bool'
16:04:54 <dibblego> given a tuple with all elements of the same type, can you match without being specific to the order in the tuple?
16:05:20 <allbery_b> no, tuples are inherently ordered
16:05:32 <dibblego> what structure is best suited? a Set?
16:05:51 <chessguy> @type not.elem
16:05:54 <lambdabot>     Couldn't match expected type `Bool'
16:05:54 <lambdabot>            against inferred type `[a] -> Bool'
16:06:09 <LoganCapaldo> @type (not .) . elem
16:06:12 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:06:13 <sorear> > let f a b = filter (\s -> not $ any (`isInfixOf` s) a) b in f ["fo","ie","ba"] ["abba", "car", "food", "kiev"]
16:06:14 <lambdabot>  ["car"]
16:06:18 <ephemient> @type flip $ not . flip elem
16:06:19 <sorear> Gwern: ^^^
16:06:20 <lambdabot>     Couldn't match expected type `Bool'
16:06:20 <lambdabot>            against inferred type `a -> Bool'
16:06:23 <ephemient> bah.
16:06:24 <Gwern> (use case: I want to be able to go 'n (permute "foo bar") ["oo","ar"]', and get ["Foo bar", "Foo Bar", "foo bar", "foo Bar"])
16:06:32 <Gwern> where n is my mystery function
16:06:55 <sorear> Gwern: f above
16:06:55 <Gwern> sorear: man, I have no idea what that means
16:07:06 <chessguy> @type \xs ys -> filter (not.(elem xs)) ys
16:07:09 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [[a]]
16:07:31 <sorear> Gwern: f a b = filter ... b  -- take elements x from b matching ... x
16:07:50 <sorear> so our ... is \s -> not $ any (`isInfixOf` s) a
16:08:00 <Gwern> sorear: hmm. so between filter that isInfixOf, it does the trick?
16:08:08 <sorear> any is also important
16:08:26 <fnord123> http://hpaste.org/667 <-- I need to convert from IO HButtonBox to HButtonBox and from IO Button to Button; I'm unsure how.
16:08:36 <sorear> fnord123: why?
16:08:48 <Gwern> isInfixOf is in data.list, right?
16:08:52 <sorear> yeah
16:09:33 <hpaste>  sorear annotated "Can't add buttons to button boxes in gtk2hs?" with "use <- for IO a at the prompt" at http://hpaste.org/667#a1
16:10:17 <hpaste>  LoganCapaldo annotated "Can't add buttons to button boxes in gtk2hs?" with "monads!" at http://hpaste.org/667#a2
16:11:36 <LoganCapaldo> I am just too slow
16:11:41 <LoganCapaldo> also my answer was lamer :)
16:11:51 <fnord123> aha, thanks sorear
16:12:50 <dpiponi> Simple question:Does the almost trivial function\x f -> f x already have a name in a library somewhere?
16:13:03 <resiak> @pl \x f -> f x
16:13:03 <lambdabot> flip id
16:13:11 <fnord123> i dont mind LoganCapaldo's solution. may be good to collect all the monads and then set everything up in two groups
16:14:20 <dpiponi> 'flip id' isn't quite a name! I just want to make sure that if I define an operator to do this it won't conflict with some standard usage.
16:15:26 <sorear> $ has been redefined for this
16:15:39 <sorear> actually yes, there is a well-known operator flip id
16:15:44 <sorear> (.) -- in PLEAC
16:16:18 <sorear> I can get away with mentioning this because dpiponi is too un-new to be corrupted by this :)
16:16:35 <sorear> so they have "foobar".sort.reverse
16:17:01 <sjanssen> and every time I see it, I gag
16:17:16 <encryptio> > splitAt 2 [0..5]
16:17:16 <chessguy> that's dumb
16:17:17 <lambdabot>  ([0,1],[2,3,4,5])
16:18:57 <dibblego> how long does GHC 6.6 + extralibs take to compile?
16:19:05 <ddarius> dpiponi: ($ x)
16:19:18 * ddarius missed the first arg
16:19:29 <chessguy> dibblego, took me maybe an hour or two on my AMD Turion
16:19:37 <sjanssen> dibblego: took about an hour on my Core Duo
16:19:38 <dibblego> crikey
16:20:01 <AvengerX> > let printDat :: String -> IO (); printDat x = putStr x; dat="Just do It (c)" in printDat dat
16:20:03 <lambdabot>  <IO ()>
16:20:08 <AvengerX> eeck
16:20:10 <JohnnyL> where can I get small to mid size projects in haskell? Documentation optional.
16:20:31 <ddarius> JohnnyL: They're all over the place.
16:20:35 <sjanssen> JohnnyL: you want to find projects to contribute to?
16:20:36 <AvengerX> > putStr "JOluser"
16:20:37 <lambdabot>  <IO ()>
16:20:44 * dpiponi Looks at PLEAC
16:20:48 <AvengerX> ahh... it does not do io here
16:20:56 <JohnnyL> sjanssen first i have to figure out the remaining 2/3's of the language. :)
16:21:00 * dpiponi Oh dear
16:21:22 <ddarius> The PLEAC code is horrible (or was several years ago, and sounds like it still is)
16:22:08 <chessguy> (.) o f = f o -- object notation for object fan
16:22:08 <chessguy> () f g x = f (g x)
16:22:22 <AvengerX> JohnnyL: if you'd know Portuguese I would gladly give you the haskell homework I'm doing here. :)
16:22:52 <dpiponi> But those PLEAC pages don't seem to even define (.) to do what they use it for
16:22:56 <AvengerX> maybe you can process it into babelfish and resolve it
16:22:56 <JohnnyL> AvengerX are the function names written in english?
16:22:57 <dons> we have a cookbook now. maybe we should getsomeoen to take down pleac...
16:23:10 <AvengerX> JohnnyL: not really... :P
16:23:15 <JohnnyL> haha
16:23:21 <JohnnyL> boa tarde.
16:23:24 <JohnnyL> :)
16:23:30 <AvengerX> But I think a translation should translate them
16:23:37 <ddarius> JohnnyL: It's definen retardedly in some support file.
16:23:44 <AvengerX> 'tis night here right now :)
16:23:52 <JohnnyL> boa noite.
16:23:52 <JohnnyL> haha
16:23:57 <GsD_Celeborn> how put autor in Haddock
16:24:05 <AvengerX> now its more like it
16:24:08 <LoganCapaldo> PLEAC == programming languages alike cookbook?
16:24:09 <GsD_Celeborn> boa noite
16:24:17 <zbrown> Is there a significant reason for me to get the "Haskell: The Craft of Functional PRogramming" published in 1999 as opposed to the one published in 1996?
16:24:31 <ddarius> H98
16:24:33 <GsD_Celeborn> [JohnnyL]: oi
16:24:34 <dons> ok. i think i love this new machine, sorear :-)
16:24:39 <chessguy> @tell cale i know you know this RNG stuff well. when you get a chance, could you take a look at http://hpaste.org/666#a1 and see why my random stuff is not being random at all?
16:24:40 <lambdabot> Consider it noted.
16:25:03 <AvengerX> GsD_Celeborn: ele  sabe portugus no, ele t s zoando com os 'oi' em portugus.. :P
16:25:16 <AvengerX> digo 'boa tarde, boa noite'
16:25:45 <JohnnyL> avengerX, thanks for the offer, but I'll pass for now.
16:25:51 <AvengerX> GsD_Celeborn: pq eu ofereci ele o trabalho aqui que tou fazendo (s que o trabalho t em portugues at nas variveis)
16:25:51 <zbrown> dons: so you feel the difference is significant enough to warrant doing so then?
16:25:57 <AvengerX> np John^
16:26:00 <AvengerX> JohnnyL
16:26:00 <GsD_Celeborn> AvengerX awe
16:26:01 <AvengerX> :)
16:26:15 <zbrown> er crap
16:26:28 <zbrown> ddarius: so you feel the difference is significant enough to warrant doing so then?
16:26:29 <LoganCapaldo> > "This works?"!![2,4]
16:26:30 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
16:26:31 <GsD_Celeborn> [AvengerX]: qual tu nacionalidade ?
16:26:34 <zbrown> dons: sry
16:26:37 <dons> i'd get the post 1998 version, zbrown
16:26:38 <LoganCapaldo> oh good
16:26:53 <zbrown> dons: ok thanks you
16:26:53 <dons> (actually, i have it. i learnt haskell from that text. but note that its a beginners text)
16:26:55 <allbery_b> the haskell98 standard is significant, yes
16:26:58 <ddarius> zbrown: It'd probably be easier to use and less confusing.
16:27:00 <sjanssen> LoganCapaldo: !! is another operator that PLEAC redefines
16:27:01 <AvengerX> GsD_Celeborn: um pas escondido a chamado 'Brasil'.. j ouviu falar? :)
16:27:10 <GsD_Celeborn> [AvengerX]: ja , moro nele
16:27:17 <zbrown> dons: ah i see. well im a beginner with functional programming so i guess that'd be appropriate
16:27:17 <GsD_Celeborn> [AvengerX]: heehehe
16:27:20 <LoganCapaldo> this website is freaking me out
16:27:28 <GsD_Celeborn> [AvengerX]: awe , sabe usar o haddock ?
16:27:31 <AvengerX> GsD_Celeborn: suspeitei desde seu 1.o join... vc que no viu eu falar hehehehe
16:27:44 <GsD_Celeborn> [AvengerX]: eu vi
16:27:46 <chessguy> hey guys, take it to #haskell.pt, please
16:27:48 <AvengerX> GsD_Celeborn: no, nunca usei ele no... mas o pessoal aki tira ele de letra
16:27:50 <GsD_Celeborn> [AvengerX]: mas tu falo em ingles
16:27:51 <ddarius> zbrown: Yeah, you probably don't want to have to translate the code from Haskell 1.4 to Haskell 98 without knowing Haskell.
16:27:59 <zbrown> ddarius: ah ok
16:28:04 <AvengerX> GsD_Celeborn: thats cause the channel is english only heh
16:28:25 <GsD_Celeborn> [AvengerX]: what do you do in haskell
16:29:06 <GsD_Celeborn> \j haskell.pt
16:29:17 <hyrax42> is there a priority queue in standard libs?
16:29:19 <AvengerX> does it yet exist?
16:29:20 <GsD_Celeborn> ops
16:29:29 <chessguy> ?users #haskell.pt
16:29:30 <lambdabot> Maximum users seen in #haskell.pt: 1, currently: 0 (0.0%), active: 0 (NaN%)
16:29:33 <ddarius> hyrax42: Probably
16:29:35 <LoganCapaldo> PLEAC is really really scary
16:29:38 <AvengerX> lol
16:29:48 <AvengerX> ?users #haskell.br
16:29:49 <lambdabot> Maximum users seen in #haskell.br: 1, currently: 0 (0.0%), active: 0 (NaN%)
16:29:56 <ddarius> LoganCapaldo: That was my reaction to it.  Then I never ever looked at it again.
16:29:59 <AvengerX> ?users #haskell-br
16:29:59 <lambdabot> Maximum users seen in #haskell-br: 1, currently: 0 (0.0%), active: 0 (NaN%)
16:30:11 * LoganCapaldo feels like he's watching a train wreck
16:30:12 <AvengerX> well
16:30:16 <LoganCapaldo> I just can't stop
16:30:34 <AvengerX> GsD_Celeborn: do you read pm's? (escrevi uns pvts proc)
16:30:55 <hyrax42> ddarius: it looks like ansewr is now
16:30:56 <GsD_Celeborn> [AvengerX]: yes
16:30:59 <hyrax42> *answer is no
16:31:24 <ddarius> hyrax42: There should be data structures that you can use as a priority queue.
16:31:27 <AvengerX> GsD_Celeborn: hope you received my pms... there at least no one could complain of our fuzzy language :P
16:31:35 <AvengerX> ...other than us of course ;P
16:31:57 <GsD_Celeborn> how do I put author in haddock?
16:32:18 <AvengerX> You mean: comment the code with the author name?
16:32:27 <GsD_Celeborn> yes
16:32:28 <AvengerX> GsD_Celeborn: what you use haddock for?
16:33:14 <LoganCapaldo> Someone escape from Ruby and get a hold of Haskell or something???? [0..2].each(\e -> putStr (e^" "))
16:33:16 <LoganCapaldo> geez
16:33:30 <GsD_Celeborn> documentation
16:33:42 <hyrax42> ddarius: not easily if you want the adjust priority operation to be decently quick
16:34:32 <encryptio> @src zip
16:34:32 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:34:33 <lambdabot> zip _      _      = []
16:36:50 <ddarius> hyrax42: I could point you to the Chris Okasaki's Fun of Programming chapter.  Or any of his several other papers on purely functional data structures.
16:37:25 <AvengerX> GsD_Celeborn: do you want just to put your name on the code, not to be printed in the end result?
16:37:42 <sorear> yes! GETCHAR/PUTCHAR opcodes working in ayhi. now for the Yhc bytecodes ...
16:37:47 <AvengerX> if nmessenger were here he would know how to you do that :P
16:38:27 <heatsink> ayhi?
16:38:55 <GsD_Celeborn> [AvengerX]: like this
16:38:57 <dibblego> is the source for the function that computes the list for [2,4..10] available?
16:38:58 <GsD_Celeborn> [AvengerX]: http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html
16:39:01 <lambdabot> http://tinyurl.com/tkkq9
16:39:04 <sorear> @src enumFromThenTo
16:39:05 <lambdabot> Source not found. It can only be attributed to human error.
16:39:08 <sorear> @src Int enumFromThenTo
16:39:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:39:19 <sorear> apparently not.
16:39:21 <ddarius> JohnnyL: http://www.haskell.org/haskellwiki/Example_code
16:39:22 <lambdabot> Title: Example code - HaskellWiki
16:39:26 <GsD_Celeborn> [AvengerX]: look at top and right
16:39:46 <sorear> ayhi = my project to rewrite yhi in 1 page
16:40:00 <GsD_Celeborn> [AvengerX]: have "Portability" ....
16:40:25 <GsD_Celeborn> [AvengerX]: I wanna know , How do put this
16:40:27 <ddarius> Have you been watching that "Implementing Categorical Semantics" video
16:41:40 <AvengerX> Why don't you just {-- |My name here --} ?
16:42:44 <AvengerX> > let prtt String -> IO (); prtt = putStr in prtt "Hello World!"
16:42:45 <lambdabot>  Parse error
16:43:33 <AvengerX> > let prtt String -> IO (); prtt = (putStr . cycle) '.' in prtt "Hello World!"
16:43:34 <lambdabot>  Parse error
16:43:48 <AvengerX> > let prtt String -> IO (); prtt = (putStr . cycle) in prtt "Hello World!"
16:43:49 <lambdabot>  Parse error
16:43:58 * AvengerX gone to the other window
16:44:30 <AvengerX> > let prtt :: String -> IO (); prtt = (putStr . cycle) in prtt "Hello World!"
16:44:32 <lambdabot>  <IO ()>
16:44:36 <GsD_Celeborn> [AvengerX]: because , I'm trying as that link
16:44:40 <AvengerX> how the hell haskell knows I send him a parameter!?
16:45:13 <AvengerX> GsD_Celeborn: i looked over your link... in a first sight, -- | is for commenting out lines
16:46:49 <bd_> -- | is for haddock
16:46:52 <bd_> --  is a comment
16:47:02 <GsD_Celeborn> I know
16:47:14 <AvengerX> so, what if
16:47:15 <GsD_Celeborn> but, not is this
16:47:29 <AvengerX> -- |Author: Mike Zier (mike@zier.org)
16:47:44 <AvengerX> in the end of the program or something like it
16:48:08 <AvengerX> Documentation annotations may span several lines; the annotation continues until the first non-comment line in the source file. For example:
16:48:32 <JohnnyL> @type fmap
16:48:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:48:38 <AvengerX> according to it, just the first comment has to have -- |. If it is followed by a --, it will be a haddock also
16:48:45 <JohnnyL> ddarius, thanks.
16:48:54 <AvengerX> bd_: look here: http://haskell.org/haddock/haddock-html-0.8/markup.html
16:48:56 <lambdabot> Title: Chapter 3. Documentation and Markup
16:49:10 <AvengerX> lambdabot: thanks
16:49:15 <AvengerX> http://www.buynet.com.br/
16:49:18 <lambdabot> Title: BuyNet Internet - Vi&ccedil;osa, MG
16:49:21 <AvengerX> lol!
16:49:25 <AvengerX> smart boy
16:49:56 * AvengerX taps lambdabot's head
16:50:40 <AvengerX> b-but I still don't understand how does haskell guess the parameters, and when I'd best use this
16:50:46 <AvengerX> > let prtt :: String -> IO (); prtt = (putStr . cycle) in prtt "Hello World!"
16:50:48 <lambdabot>  <IO ()>
16:50:52 <mauke> what do you mean by "guess"?
16:51:08 <AvengerX> look: prtt definition has no reference to the parameter!..
16:51:14 <mauke> so?
16:51:18 <encryptio> it doesn't need to
16:51:24 <allbery_b> yes, but haskell knows what putStr . cycle needs
16:51:33 <allbery_b> and it has your type signature
16:51:34 <encryptio> putStr . cycle has the correct type, and it's a function
16:51:44 <allbery_b> :t putStr . cycle
16:51:47 <lambdabot> [Char] -> IO ()
16:52:19 <AvengerX> > let prtt :: String -> IO (); prtt = (putStr . cycle) in prtt 132
16:52:20 <lambdabot>   add an instance declaration for (Num String)
16:52:34 <AvengerX> > let prtt :: String -> IO (); prtt = (putStr . (cycle . show)) in prtt 132
16:52:36 <lambdabot>   add an instance declaration for (Num String)
16:52:42 <ddarius> AvengerX: functions are first class, you can bind them to a variable.
16:52:50 <allbery_b> any time you have f x = (something) x
16:52:56 <allbery_b> you can reduce that to f = something
16:53:04 <mauke> > (putStr . cycle . show) 132
16:53:06 <lambdabot>  <IO ()>
16:53:12 <AvengerX> hmm
16:53:15 <Botje> allbery_b: yeah. too bad it gets Tricky(tm) with more than one variable
16:53:19 <AvengerX> > let prtt :: String -> IO (); prtt = (putStr . cycle . show) in prtt 132
16:53:20 <lambdabot>   add an instance declaration for (Num String)
16:53:24 <ddarius> > (cycle . show) 132
16:53:24 <allbery_b> (although you probably need a type signature, since there's this artificial restriction --- the monomorphism restriction
16:53:25 <lambdabot>  "132132132132132132132132132132132132132132132132132132132132132132132132132...
16:53:35 <mauke> > let prt = putStr . cycle . show in prt 132
16:53:37 <lambdabot>  <IO ()>
16:54:21 <allbery_b> note also that since putStr consumes its argument strictly and cycle produces an infinite list, you've got an infinite loop there :)
16:54:23 <AvengerX> > let prtt :: String -> IO (); prtt = (putStr . (cycle . show)) in prtt 132
16:54:24 <lambdabot>   add an instance declaration for (Num String)
16:54:30 <mauke> AvengerX: dude, 132 is not a string
16:54:32 <AvengerX> ah... the signature
16:54:42 <AvengerX> > let prtt :: Int -> IO (); prtt = (putStr . (cycle . show)) in prtt 132
16:54:43 <lambdabot>  <IO ()>
16:55:02 <AvengerX> > let prtt :: Int -> IO (); prtt = putStr . cycle . show in prtt 132
16:55:03 <lambdabot>  <IO ()>
16:55:13 <AvengerX> hmmmmmmmmmmmmmmmmmmmmmmmm
16:55:30 <mauke> > 'h' : repeat 'm'
16:55:32 <lambdabot>  "hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm...
16:55:33 <AvengerX> so if it is a 'f(x,y)=something', I can't use of this
16:55:48 <AvengerX> mauke: lol
16:55:50 <allbery_b> you can, but it's more difficult
16:55:53 <allbery_b> also, it would be f x y
16:55:54 <encryptio> @pl (\x -> (sum x) / (length x))
16:55:55 <lambdabot> liftM2 (/) sum length
16:55:59 <mauke> what? (x, y) is a single parameter
16:56:13 <AvengerX> allbery_b: yeah, used math notation for the sample
16:56:16 <mauke> encryptio: doesn't typecheck
16:56:28 <encryptio> mauke: what?
16:56:56 <allbery_b> @pl \f x = sum (map f x)
16:56:57 <lambdabot> (line 1, column 6):
16:56:57 <lambdabot> unexpected "="
16:56:57 <lambdabot> expecting pattern or "->"
16:56:59 <mauke> length returns Int, / needs Fractional
16:57:00 <allbery_b> oops
16:57:05 <allbery_b> @pl \f x -> sum (map f x)
16:57:06 <lambdabot> (sum .) . map
16:57:22 <AvengerX> In a case like let prtt :: Int -> Int -> IO (); prtt = putStr . cycle . show in prtt 132 122
16:57:26 <encryptio> ah
16:57:34 <encryptio> why doesn't @pl check types?
16:57:48 <AvengerX> > let prtt :: Int -> Int -> IO (); prtt = putStr . cycle . show . ++ in prtt 132 122
16:57:49 <lambdabot>  Parse error
16:58:08 <AvengerX> > ++ (show 32) (show 23)
16:58:08 <sjanssen> encryptio: @pl just isn't that smart
16:58:08 <lambdabot>  Parse error
16:58:11 <monochrom> (++)
16:58:15 <AvengerX> :P
16:58:17 <AvengerX> > (++) (show 32) (show 23)
16:58:19 <lambdabot>  "3223"
16:58:28 <AvengerX> > let prtt :: Int -> Int -> IO (); prtt = putStr . cycle . show . (++) in prtt 132 122
16:58:30 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
16:58:36 <allbery_b> @pl \x y -> putStr (cycle (show x ++ show y))
16:58:37 <lambdabot> ((putStr . cycle) .) . (. show) . (++) . show
16:58:40 * encryptio recommends AvengerX load a copy of ghci
16:58:47 <allbery_b> it gets rather tricky with multiple arguments
16:58:53 <AvengerX> encryptio: agreed
16:59:34 <AvengerX> allbery_b: how would u do in the case of this prtt 132 122?
16:59:59 <AvengerX> is that what lamb shown?
17:00:30 <encryptio> AvengerX: you're trying to ++ the numbers and then show the result.. you need to do the reverse, show the numbers then ++ the result
17:00:41 <AvengerX> > let prtt :: Int -> Int -> IO (); prtt = ((putStr . cycle) .) . (. show) . (++) show in prtt 132 122
17:00:42 <lambdabot>  Couldn't match expected type `[a]'
17:01:11 <AvengerX> > let prtt :: Int -> Int -> IO (); prtt = ((putStr . cycle) .) . (. show) . (++) . show in prtt 132 122
17:01:12 <lambdabot>  <IO ()>
17:01:18 <AvengerX> OMFG
17:01:20 <AvengerX> it works!
17:01:33 <AvengerX> haskHELL
17:01:34 <JohnnyL> @type interact
17:01:37 <lambdabot> (String -> String) -> IO ()
17:02:00 <AvengerX> at least to make it guess multi params is nothing like 'readable'
17:02:09 <mauke> it doesn't guess
17:02:19 <allbery_b> <allbery_b> @pl \x y -> putStr (cycle (show x ++ show y))
17:02:20 <allbery_b> <lambdabot> ((putStr . cycle) .) . (. show) . (++) . show
17:02:31 <AvengerX> yes it does! for me it does
17:03:03 <AvengerX> how does he know he has to put that X there and the Y over there?
17:03:04 <AvengerX> heh
17:03:09 <allbery_b> you're arund the point where trying to be point-free is kinda pointless --- the original is easier to understand
17:03:24 <allbery_b> @unpl ((putStr . cycle) .) . (. show) . (++) . show
17:03:24 <lambdabot> (\ e q -> putStr (cycle ((show e) ++ (show q))))
17:03:41 <AvengerX> yeah
17:03:45 <AvengerX> what does '@pl' mean?
17:03:48 <allbery_b> and the way it knows is that it knows the types of the functions
17:03:53 <allbery_b> @help pl
17:03:53 <LoganCapaldo> @help pl
17:03:53 <lambdabot> pointless <expr>. Play with pointfree code.
17:03:54 <lambdabot> pointless <expr>. Play with pointfree code.
17:04:00 <AvengerX> ahh
17:04:02 <LoganCapaldo> @quote stereo
17:04:02 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:04:06 <jcreigh> In general, as soon as the output of @pl looks like UUencoded text, you're better off without it. :)
17:04:26 <allbery_b> @remember jcreigh In general, as soon as the output of @pl looks like UUencoded text, you're better off without it. :)
17:04:27 <lambdabot> Done.
17:04:42 <ddarius> It doesn't need to know.  You use it as a function.
17:04:50 <AvengerX> @pl putStr (show a)
17:04:51 <lambdabot> putStr (show a)
17:05:06 <AvengerX> @unpl putStr (show a)
17:05:07 <lambdabot> putStr (show a)
17:05:18 <AvengerX> what the..
17:05:22 <hpaste>  Gwern pasted "A CLI tool to generate possible capitalizations of a name" at http://hpaste.org/668
17:05:37 <Gwern> sorear: it took some doing, but I finally got it working
17:05:50 <mauke> @pl \show -> putStr (show a)
17:05:51 <lambdabot> putStr . ($ a)
17:09:47 <LoganCapaldo> @type \show -> putStr (show a)
17:09:49 <lambdabot> Not in scope: `a'
17:10:37 <LoganCapaldo> sometimes I wish it would just make something up :)
17:11:54 <EvilTerran> "(a :: b) => b -> IO ()" ?
17:12:25 <EvilTerran> (that's not right, but whatever)
17:12:33 <sorear> @type \show -> putStr (show ?a)
17:12:35 <lambdabot> forall t. (?a::t) => (t -> String) -> IO ()
17:12:39 <LoganCapaldo> OMG
17:12:41 <mauke> aieee
17:12:46 <LoganCapaldo> @karma+ sorear
17:12:46 <lambdabot> sorear's karma raised to 25.
17:12:47 <sorear> muahahaha!
17:12:49 <EvilTerran> it does it!
17:13:02 <EvilTerran> it even nearly uses the syntax i used! wow!
17:13:47 <EvilTerran> sorear, what exactly does that "?" mean?
17:13:53 <sorear> implicit parameter
17:14:05 <sorear> ghc extension, slated for removal Real Soon Now
17:14:29 <EvilTerran> huh. ok.
17:14:43 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/other-type-extensions.html#implicit-parameters
17:14:45 <lambdabot> Title: 7.5. Other type system extensions, http://tinyurl.com/ywd9d4
17:16:44 <mbishop> Wow, I hate reddit so much
17:16:48 <mbishop> why do I even bother? heh
17:17:07 <Gwern> mbishop: it's a lot better than /. or Digg, that's for sure
17:17:25 <Gwern> (and lambda the ultimate is too specific, so that's not enough)
17:17:34 <AvengerX> @unpl \x -> putStr (show a)
17:17:35 <lambdabot> \ x -> putStr (show a)
17:17:41 <AvengerX> @pl \x -> putStr (show a)
17:17:42 <lambdabot> const (putStr (show a))
17:17:44 <AvengerX> oops
17:17:47 <AvengerX> @pl \a -> putStr (show a)
17:17:47 <lambdabot> putStr . show
17:17:48 <mbishop> Someone needs to make a better one :/
17:17:48 <ddarius> Not a very well-liked extension by the way.
17:18:00 <AvengerX> aaaah! nooow its more like it
17:18:03 * ddarius avoided reddit from the get go.
17:20:30 <mbishop> one of my links was up to 4 points, now it's somehow down to 1 again, and another link I just posted went to 0 right after I put it up heh
17:21:45 <EvilTerran> I suppose, if you wanted find the type of an expession with an arbitrary a in it, you could just ":type \a -> (...)".
17:21:49 * nmessenger reads the logs
17:22:19 <nmessenger> dpiponi: Microsoft's F# language has an operator (|>) like that.  I kinda like it.
17:22:24 <AvengerX> @pl \x y -> putStr (x ++ y)
17:22:25 <lambdabot> (putStr .) . (++)
17:22:40 <AvengerX> well simpler!
17:23:14 <AvengerX> @pl \x y -> putStr ((show x) ++ (show y))
17:23:15 <lambdabot> (putStr .) . (. show) . (++) . show
17:23:17 <dpiponi> nmessenger: |> is a good name
17:23:22 <AvengerX> ok
17:23:50 <mauke> wait, I invented |>!
17:23:59 <EvilTerran> <_< >_>
17:24:05 <EvilTerran> so did i. i even called it |>.
17:24:21 <nmessenger> what purposes did you two use it for?
17:24:31 <bd_> :t (|>)
17:24:33 <lambdabot> Not in scope: `|>'
17:24:35 <bd_> tsk
17:24:38 <bd_> :t Data.Sequence.(|>)
17:24:41 <lambdabot> Couldn't find qualified module.
17:24:56 <nmessenger> @type (Data.Sequence.|>)
17:24:59 <lambdabot> forall a. Data.Sequence.Seq a -> a -> Data.Sequence.Seq a
17:24:59 <EvilTerran> a left-to-right version of ($), basically
17:25:11 <EvilTerran> I used it in ML to cut down on brackets
17:25:31 <nmessenger> bd_: is that like a flip (:)?
17:25:50 <bd_> sequence |> newelement
17:25:53 <bd_> O(1) :)
17:26:03 <bd_> it puts it on the right end of the sequence
17:26:04 <EvilTerran> snoc?
17:26:10 <nmessenger> oh, snoc
17:26:10 <bd_> whereas newelement <| sequence puts it on the left end
17:26:55 <chessguy> any ideas why my RNG is not cooperating in being random? http://hpaste.org/666#a1
17:33:34 <nmessenger> chessguy: does GlobalState have any other fields?
17:33:44 <chessguy> no
17:33:51 <nmessenger> if you do 'newStdGen >>= \g -> evalState (randomPrograms 5) (GlobalState {randomGen = g})' at the toplevel does it ever change?
17:34:38 <nmessenger> or are you asking why the unfolding doesn't seem to update the RNG?
17:35:07 <eyeris> I am just learning Haskell. I am trying to pass the result of `mod` to the drop function but I am getting an error from ghc that the expected Int doesn't match the inferred Integer. So how do I convert an Integer to an Int?
17:35:11 <chessguy> nothing seems to update the RNG
17:35:39 <nmessenger> eyeris: sprinkle some parens around
17:36:02 <ephemient> @type fromInteger
17:36:05 <lambdabot> forall a. (Num a) => Integer -> a
17:36:12 <EvilTerran> @type fromIntegral
17:36:14 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:36:19 <allbery_b> alternately:
17:36:22 <allbery_b> :t genericDrop
17:36:25 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
17:36:31 <nmessenger> oh, yeah Integer
17:36:44 <EvilTerran> @src genericDrop
17:36:44 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:36:49 <chessguy> nmessenger,  and running that code gives the same result every time
17:37:05 <eyeris> Thanks, fromInteger worked
17:37:05 <sorear> chessguy: dump question:  are genes or terminals non-singleton?
17:37:08 <allbery_b> @index genericDrop
17:37:09 <lambdabot> Data.List
17:37:12 <bd_> > drop (-1) "abcd"
17:37:14 <lambdabot>  "abcd"
17:37:17 <EvilTerran> genericDrop i xs = drop (fromIntegral i) xs
17:37:23 <bd_> that should be _|_ ;)
17:37:32 <chessguy> sorear, i'm not sure what you mean
17:37:37 <allbery_b> ewww, partial functions
17:37:44 <bd_> :(
17:38:06 <bd_> well, drop (-1) [] should be [_|_] at the least
17:38:13 <bd_> :)
17:38:14 <LoganCapaldo> > drop (-1) "abcd" --> "abc" :)
17:38:15 <lambdabot>  Parse error
17:38:59 <chessguy> sorear, the lists should not contain duplicates, if that's what you mean
17:39:36 <nmessenger> singleton mean (length xs == 1)
17:39:45 <chessguy> oh, duh
17:40:05 <LoganCapaldo> > let superDrop n xs = if n < 0 then reverse $ drop (negate n) reverse xs else drop n xs in superDrop (-1) "abcd"
17:40:06 <lambdabot>  Couldn't match expected type `[a]'
17:40:13 <sorear> @ty runState
17:40:16 <lambdabot> forall s a. State s a -> s -> (a, s)
17:40:19 <EvilTerran> "drop n xs | n < 0 = (replicate (negate n) undefined) ++ xs" :P
17:40:21 <LoganCapaldo> > let superDrop n xs = if n < 0 then reverse $ drop (negate n) $ reverse xs else drop n xs in superDrop (-1) "abcd"
17:40:23 <lambdabot>  "abc"
17:40:34 <chessguy> terminals is singleton, genes is not
17:40:35 <allbery_b> this is not perl :>
17:40:50 <EvilTerran> i think mine makes more sense :P
17:40:57 <LoganCapaldo> I think you mean "this is not PLEAC" :)
17:42:00 <sorear> @ty randomR
17:42:03 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
17:45:16 <hpaste>  sorear annotated "getting the same "random" program every time..." with "obligatory refactor (probably no fix)" at http://hpaste.org/666#a2
17:45:56 * EvilTerran notes this is a devil of a problem :P
17:46:37 <nmessenger> @src forM
17:46:38 <lambdabot> forM = flip mapM
17:46:42 <nmessenger> @src mapM
17:46:42 <lambdabot> mapM f as = sequence (map f as)
17:46:54 <ephemient> so, a MonadRandom would be nice
17:47:05 <chessguy> ephemient, already exists
17:47:19 <ephemient> I see Test.QuickCheck.Gen; anything in the standard libraries?
17:47:26 <sorear> chessguy: I assume you have a good reason for dragging the whole GlobalState down into the unfold?
17:47:35 <allbery_b> whee, homwork help on cafe@
17:47:42 <allbery_b> *homework
17:47:52 * sorear killall -USR1 fetchmail
17:48:33 <chessguy> sorear, ermmm, because it needs access to the RNG
17:48:45 <allbery_b> @wiki New_monads/MonadRandom
17:48:45 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
17:49:15 <chessguy> ?src replicateM
17:49:15 <lambdabot> replicateM n x = sequence (replicate n x)
17:49:21 <sorear> chessguy: I mean, why not *just* bring the rng down?
17:49:47 <sorear> do you have other state you need to access/mutate?
17:49:55 <chessguy> oh, potentially, yes
17:50:07 <chessguy> not currently, but further down the line i will
17:51:26 <nmessenger> what's unfoldTreeM look like?
17:51:46 <chessguy> ?src unfoldTreeM
17:51:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:52:01 <nmessenger> is it in Data.Tree?
17:52:07 <sorear> @source Data.Tree
17:52:08 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
17:52:10 <chessguy> yes
17:52:32 <chessguy> unfoldTreeM f b = do
17:52:33 <chessguy> 	(a, bs) <- f b
17:52:33 <chessguy> 	ts <- unfoldForestM f bs
17:52:33 <chessguy> 	return (Node a ts
17:53:00 <LoganCapaldo> No, fold the forest back up!
17:54:48 <nmessenger> I really *haven't a clue* what's wrong :(
17:55:09 <LoganCapaldo> its magic
17:56:18 <nmessenger> It *looks* like everything's sequenced fine.
17:57:14 <chessguy> nmessenger, and it typechecks, to boot!
17:57:57 <dons> sorear: so i can get through the nobench suite in about 20 mins or so on 'serenity' , the new box :)
17:58:29 <ddarius> dons: And do you also no longer need centralized heating?
17:58:38 <dons> that's right.
17:58:45 <dons> we needed better cooling , in fact
18:00:05 <nmessenger> arity = ?
18:01:42 <zarvok> nmessenger: are you looking for a definition? the arity of a function is the number of arguments the function takes.
18:01:47 <chessguy> ermm, an Int in Gene
18:02:10 <chessguy> it says how many children a particular gene should have
18:03:10 <nmessenger> zarvok: thanks, but no.  I was asking chessguy.
18:03:56 <zarvok> ah
18:03:59 <chessguy> well, my definition is pretty much the same as his :)
18:04:00 <lupo__> .oO (noobnote: which ingenious sicko first introduced the concept of list comprehension?)
18:04:24 <dons> well, its set notation
18:04:36 <EvilTerran> careful what you call people, lupo__, he may very well be in the channel
18:04:42 <zarvok> lupo__: It's actually possible to consider comprehensions for any monad! Very cool stuff.
18:04:44 <dons> I think it was Turner who introduced the Z-F notation into an early predecessor of haskell
18:04:53 <dons> and then wadler popularised it further
18:05:01 <EvilTerran> ok, nm
18:05:38 <AvengerX> francisco_: hallow brazooka! :)
18:06:00 <francisco_> hello AvengerX
18:06:26 <AvengerX> latin american you, right?
18:06:50 <zarvok> Anyone have some examples of large or interesting projects that have used parsec?  I imagine asking here is easier than hunting around the web
18:06:51 <dons> > [ i * 2 | i < [1..10] ] -- and its quite intuitive, I think
18:06:52 <lambdabot>   Not in scope: `i'
18:07:00 <AvengerX> (not brazillian tough, I'd guess)
18:07:02 <dons> > [ i * 2 | i <- [1..10] ] -- and its quite intuitive, I think
18:07:04 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
18:07:19 <lupo__> EvilTerran: actually i consider my statement an appreciating mention.
18:07:37 <lupo__> dons: thx
18:07:49 <EvilTerran> oh, ok. i guess i took "sicko" the wrong way.
18:07:51 * nmessenger would take "ingenious sicko" as flattery
18:08:05 <francisco_> AvengerX: I am mexican
18:08:15 <jcreigh> ha ha!
18:08:27 * jcreigh just got his dirt-simple x86 compiler working end-to-end
18:08:44 <nmessenger> jcreigh: \o/  Assembly?
18:08:46 <jcreigh> well, it compiled factorial anyway, which is how I measure these things.
18:08:49 <zarvok> jcreigh: from what language?
18:09:07 <lupo__> btw, who's the nice guy who wrote "Haskell for C Programmers"? good work.
18:09:28 <jcreigh> zarvok: simple (ie, signed bits is all you get) language I made up.
18:09:35 <jcreigh> *signed ints
18:09:38 <dons> jcreigh: it compiles what to x86?
18:09:40 * zarvok looks forward to the day someone has to write "C for haskell programmers"
18:09:41 <EvilTerran> hehe, signed bits
18:09:41 <nmessenger> "Written by Eric Etheridge"
18:09:53 <EvilTerran> i guess that'd be 0 and -1
18:09:56 <dons> btw, here's the nobench run from the 16 core box, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
18:09:57 <lambdabot> Title: nobench: Haskell implementation shootout
18:10:03 <EvilTerran> (in two's complement, anyway)
18:10:09 <jcreigh> balanced ternary FTW! :)
18:11:14 <jcreigh> Now all I need to do is get rid of all the ugly hacks I did "just to get it working"
18:11:31 <ddarius> dons: Several differences between GHC and GHCi correctness-wise.
18:11:44 <ddarius> Or is it memory/stack something?
18:11:59 <dons> stack mostly
18:12:18 <dons> the failing programs error on floating point in the 20th digit or so, compared to the expected output
18:12:22 <dons> that needs to be tweaked
18:12:43 <dons> ddarius: see http://www.cse.unsw.edu.au/~dons/nobench/x86_64/bench.results
18:12:55 <dons> chess fails properly on ghci with a bug
18:13:26 <dons> everything else is stack, bar 1 fp issue, and 1 broken test
18:14:17 <sorear> jcreigh: have you read "Let's Build a Compiler"?  That one demystified it for me.
18:14:34 <lupo__> zarvok: hehe.
18:14:53 <lupo__> nmessenger: yes i read that, i just wondered how to send him a cake.
18:15:04 <sorear> jcreigh: I've also written a trivial x86 compiler.  Actually I wrote an entire OS around it... only used it once (and a story to that)
18:15:45 <jcreigh> sorear: I have read that, but it was a while ago. Might be worth checking out again.
18:16:29 <sorear> how while ago?  it was >12 years old when I read it ...
18:16:41 <sorear> actually the document is older than I
18:16:54 <jcreigh> year or two ago, maybe?
18:19:06 <jcreigh> I'm always amazed how many things seem really hard at first, but once you actually give it a shot, isn't that hard. Sure, it's really hard to write a production-ready compiler. But it's pretty easy to hack together one for a toy language.
18:19:25 <sorear> what language did you write yours in?
18:19:57 <sorear> mine was C ... now that I know Haskell, I wonder how hard a parsec-based x86 compiler would be
18:20:09 <sorear> I assume yours has no optimizer to speak of?
18:20:34 <jcreigh> well, the compiler is Haskell, of course. The toy language is a "everything is a signed word" language. (But with a Lisp-like syntax, since I was getting lazy by the time I needed to write the parser)
18:20:47 <chessguy> sorear, any luck figuring out my RNG problem?
18:20:48 <jcreigh> sorear: no, no optimizer.
18:20:52 <sorear> I've written 1(2?) compilers, 3 x86 FORTHs, 3ish OS's  ... was once a passion of mine.
18:20:59 <sorear> hah, lisp syntax
18:21:16 <sorear> pythonish (in retrospect) block structures languages here :)
18:21:20 <ddarius> jcreigh: Code generators start from easy and quickly get really pain-in-the-ass long before you hit "production-ready"
18:21:35 <jcreigh> so it looks like Lisp, but in reality is worse than C. I imagine it would give a Lisp hacker quite a shock. :)
18:22:03 <sorear> Is it worse to program in than RTL?
18:22:06 <sorear> :)
18:22:09 <jcreigh> RTL?
18:22:13 <nmessenger> @vera rtl
18:22:15 <lambdabot> *** "rtl" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:22:16 <lambdabot> RTL
18:22:16 <lambdabot>      Real Time Language
18:22:16 <lambdabot>  
18:22:16 <lambdabot> *** "rtl" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:22:17 <lambdabot> [11 @more lines]
18:22:18 <ddarius> Register Transfer Language
18:22:56 <EvilTerran> "Reduced to Three Letters" :P
18:22:59 <nmessenger> @google Register Transfer Language
18:23:01 <lambdabot> http://en.wikipedia.org/wiki/Register_Transfer_Language
18:23:02 <wkh> > Monad.mapM_ putStrLn ["i", "dont", "understand", "monads"]
18:23:02 <lambdabot> Title: Register Transfer Language - Wikipedia, the free encyclopedia
18:23:02 <lambdabot>   Not in scope: `Monad.mapM_'
18:23:45 <nmessenger> > {- wkh: -} putStrLn (unwords ["then","don't","use","them","so","much :)"])
18:23:46 <lambdabot>  <IO ()>
18:24:04 <hpaste>  jcreigh pasted "example generated code, for the curious" at http://hpaste.org/669
18:24:28 <nmessenger> sweet!
18:24:37 <wkh> well, i'm interested in learning any language constructs that allow for declarative, compositional computation
18:25:58 <petekaz> quick question: how do I ensure that quickcheck is available when I load ghci?
18:26:20 <sorear> :m + Test.QuickCheck
18:26:26 <petekaz> thanks.
18:26:57 <allbery_b> you can also put that in ~/.ghci if you always want it
18:28:30 <petekaz> thanks.
18:29:28 <ddarius> jcreigh: No register allocation.
18:29:49 <jcreigh> ddarius: right. This is the x86, do you think I'm crazy? :)
18:30:42 <jcreigh> I take an AST, compile that to an infinite register intermediate language, assign virtual registers to stack variables, then translate to x86
18:30:56 <ddarius> jcreigh: Yeah. I understand completely.
18:31:27 <jcreigh> The DIV instruction alone was enough to convince me that I didn't want to try to walk down that road.
18:31:34 <jcreigh> not yet, anyway
18:33:33 <sorear> eventually there will be an ayhi ncg ... I wonder how much of a speedup wrt bytecode I can achieve with how little effort
18:34:40 <sorear> hmm, yours generates gas input.  Mine spit out an ELF executable directly.
18:35:24 <jcreigh> yeah, I'm too lazy to deal with generating x86 opcodes.
18:35:48 <sorear> I didn't even bother with using the linker :)
18:35:58 <ddarius> jcreigh: If Piumarta's VPU was available I'd be so happy.
18:36:37 <ddarius> Going from assembly to machine code is tedious but easy.
18:37:39 <jcreigh> #HASKELL? no, sorry, this is #UPPERCASELAND
18:39:38 <jcreigh> I wonder if you can use ESI and EDI as general purpose registers...
18:40:01 <allbery_b> no
18:40:13 <LoganCapaldo> But you can tryu
18:40:18 <allbery_b> they don't support most of the GP ops IIRC
18:40:19 <ddarius> allbery_b: For the most part you can.
18:40:38 <ddarius> Almost all the registers do.
18:40:40 <Turks> sup
18:40:43 <sorear> actually you can use all 8 for gp ops
18:40:48 <allbery_b> hm, ESI and EDI.  most but not all things, yeh, and you have to avoid using some of the fancier block ops
18:40:52 <sorear> div needs edx, eax
18:41:03 <Turks> hrm, does ghc translate haskell code into c?
18:41:07 <jcreigh> anonfunc: "block ops"?
18:41:16 <sorear> allbery_b: you should avoid using them anyway unless (like me) you're optimizing for size
18:41:17 <ddarius> The issue is that certain ops clobber esi and edi among many other ops clobbering other thing.
18:41:34 <ddarius> movsb presumably.
18:41:37 <ddarius> (and co.)
18:41:43 <allbery_b> ESI and EDI are used by CPU block moves and other block opcodes
18:41:49 <sorear> allbery_b: folklore says the block ops are slower than handhacked moves on pentium class processors
18:42:22 <allbery_b> not surprised, I recall that falling out int he 486 days, didn't know if they'd been fixed yet
18:42:51 <sorear> Turks: yes. actually C--.  if (-fvia-C) { translate_cmm_to_c } else { translate_cmm_to_asm }
18:42:56 <anonfunc> jcreigh: block ops?
18:42:59 <allbery_b> Turks: it can, or it can generate machine code almost directly
18:43:08 <allbery_b> completion error, he meant me
18:43:25 <jcreigh> anonfunc: oh, sorry, tab-completion lead me astray. Meant that for allbery_b
18:43:28 <sorear> anonfunc: (rep)? {mov,sto,lod,sca}s[bwd]
18:43:38 <jcreigh> *led, and allbery_b beat me anyway.
18:43:49 <anonfunc> I just wanted to reply :)
18:43:52 <Turks> ah, is it possible for it to just translate to C and not compile?
18:43:59 <sorear> not sure
18:44:14 <sorear> but you can certainly try -progc '/bin/true'
18:44:22 <allbery_b> yes, that's the first step of ding an unregisterised build for a port
18:44:24 <sorear> also look at -keep-hc-file
18:44:26 * Turks adds to batch
18:44:27 <allbery_b> *doing
18:44:59 <allbery_b> but you probably don't want to do that for a standard build, you really need ghc to keep the compile foo straight
18:54:29 <Turks_> grr
18:54:32 <Turks_> stupid dial up
18:54:55 <Turks_> anyway, so there isnt a way to translate haskell code using ghc into standard C?
18:55:33 <ddarius> Turks_: Not into standard C, into GCC C yes.
18:57:52 <Turks_> gcc has its own c o.0?
18:57:52 <MP0> ghc -C
18:57:52 <Korollary> and it's pretty messy C
18:57:52 <ddarius> Turks_: GCC has a bunch of extensions to standard C.
19:00:58 <sorear> Turks_: get jhc.  jhc -v myprog.  wait a few hours.  stop.  upgrade your RAM.  jhc -v myprog.  wait a few hours.  look at hs.out.c (which IS ansi)
19:01:19 <Turks_> wait, what?
19:01:35 <sorear> Turks_: wrt ddarius' comment, mostly global register variables.
19:01:54 <Turks_> dial up prolly wont like jhc
19:02:08 <sorear> jhc : JohnMeacham's Haskell Compiler.  Whole program optimization.  Unbelievable memory and time use.  Generates ANSI C
19:02:23 <sorear> jhc isn't an internet program, why would dialup care?
19:02:49 <sorear> also generated code is about twice as fast as GHC on nobench
19:02:59 <sorear> @where nobench-results
19:03:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench/results.html
19:03:49 <dons> ?where+ nobench-results http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
19:03:50 <lambdabot> Done.
19:04:14 <dons> sorear: the generated code is 0.70x
19:04:23 <dons> though only manages to generate code
19:04:24 <dons> > 9/67
19:04:26 <lambdabot>  0.13432835820895522
19:04:39 <dons> so 1/10th of your haskell programs will run 30% faster :-)
19:05:07 <sorear> dons: ah. randomness strikes, it was 0.50x last time I looked :)
19:05:23 <dons> i think i managed to get it to pass one more
19:06:18 <sjanssen> perhaps nobench needs to measure compilation time as well?
19:06:41 <sorear> well it already has a 20minute compile timeout
19:06:43 <Turks_> sorear, because i have to download it :P
19:07:12 <Turks_> any links?
19:07:22 <sorear> 1.8M total patches for jhc
19:07:41 <sorear> > 1874883 `div` 57600
19:07:42 <lambdabot>  32
19:07:47 <jcreigh> @google jhc haskell compiler
19:07:49 <lambdabot> http://repetae.net/john/computer/jhc/
19:07:49 <lambdabot> Title: jhc
19:07:50 <dons> sorear: i'm not sure i'd respond to Andrzej, its pretty much just trolling
19:07:55 <dons> modulo language issues
19:08:07 <dons> Turks_: what are you trying to do?
19:08:08 <sorear> *gulp* I didn't notice
19:08:18 <dons> (before you go and get lost for a week playing with jhc)
19:10:19 <mdmkolbe> @src first
19:10:20 <lambdabot> Source not found. My mind is going. I can feel it.
19:10:26 <mdmkolbe> @src Arrow.first
19:10:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:10:35 <sorear> @src Arrow
19:10:35 <mdmkolbe> @src Control.Arrow.first
19:10:36 <lambdabot> class Arrow a where
19:10:36 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:10:36 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:10:36 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:10:36 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:10:38 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:10:40 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:10:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:10:50 <sorear> mdmkolbe: it's a class method, it has no source
19:10:50 <mdmkolbe> @source Control.Arrow
19:10:51 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
19:10:56 <nmessenger> @src (->) first
19:10:57 <lambdabot> first f = f *** id
19:11:06 <sorear> @src (->) (***)
19:11:07 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
19:11:34 <nmessenger> so \f (x,y) -> (f x, y)
19:11:38 <mdmkolbe> thx, that is just what I was looking for
19:12:03 <nmessenger> @pl \f (x,y) -> (f x, y)
19:12:04 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
19:12:07 <nmessenger> geh!
19:12:38 * sorear still intends to rewrite @pl
19:13:00 <mdmkolbe> is there a reason GHC comes with an arrow instance for functions but not for streams?  (I had to find one online)
19:13:55 <Turks_> grr
19:14:07 <sorear> @seen dfranke
19:14:08 <lambdabot> dfranke is in #haskell-blah and #haskell. I don't know when dfranke last spoke.
19:14:17 <dfranke> yes?
19:14:20 <Turks_> i hate these types of sites...anyone got a direct link to a executable?
19:14:45 <sorear> dfranke: just trying to find nick
19:15:14 <sorear> Turks_: what kind of sites?
19:15:34 <Turks_> where you either have to build it or ponder the other links in search for an executable tarball
19:15:58 <sorear> it takes <10m
19:16:09 * Turks_ hates compiling compilers
19:16:13 <nmessenger> need darcs?
19:16:29 <sorear> Turks_: jhc source code is 1.8 mbytes, full histor
19:16:35 <sorear> Turks_: jhc binary is 15 mbytes
19:16:45 <Turks_> heh
19:16:50 <sorear> Turks_: which would you rather download?
19:17:33 <Turks_> which is easier, the bin or the src
19:17:35 <Turks_> :P
19:18:02 <lupo__> is there something like a unique function for lists (ie. passing [1,1,2,2,3] yields [1,2,3]) ?
19:18:08 <sorear> nub
19:18:16 <sorear> > nub [1,1,2,2,3,4,3]
19:18:18 <lambdabot>  [1,2,3,4]
19:18:21 <lupo__> thx
19:18:33 <lupo__> what a strange name :)
19:18:39 <Turks_> sorear executable link plz
19:20:24 <dons> ?web1913 nub
19:20:26 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
19:20:26 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
19:20:26 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
19:20:26 <lambdabot>  
19:20:26 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
19:20:28 <lambdabot> [3 @more lines]
19:20:30 <dons> @more
19:20:31 <lambdabot> Nub \Nub\, n.
19:20:32 <lambdabot>    A jag, or snag; a knob; a protuberance; also, the point or
19:20:34 <lambdabot>    gist, as of a story. [Colloq.]
19:20:42 <dons> "the point or gist of a story"
19:20:52 <Turks_> sup dons
19:20:55 <dons> gist might have been a good name
19:21:11 <dons> hey
19:22:06 <sorear> Turks_: w/o history: -rw-r--r-- 1 stefan stefan 389K Feb 25 19:18 jhc.7z
19:22:25 <lupo__> :)
19:23:14 * Turks_ is stupid
19:23:17 <wkh> oh, so it's pronounced "nub", rhymes with bub, club, and dub, not like n00b
19:23:32 <mlh> so was unique  (or uniq) taken?
19:23:46 <mdmkolbe> :t unique
19:23:48 <lambdabot> Not in scope: `unique'
19:23:56 <dons> 'nub' is a nice word
19:23:57 <mdmkolbe> @hoogle unique
19:23:58 <Turks_> sorear, ?
19:23:58 <lambdabot> Data.Unique :: module
19:23:58 <lambdabot> Data.Unique.Unique :: data Unique
19:23:58 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
19:24:05 <nmessenger> @hoogle+
19:24:06 <lambdabot> Data.Unique.newUnique :: IO Unique
19:24:24 <dons> @web1913 unique
19:24:26 <lambdabot> *** "Unique" web1913 "Webster's Revised Unabridged Dictionary (1913)"
19:24:27 <lambdabot> Unique \U*nique"\, a. [F. unique; cf. It. unico; from L. unicus,
19:24:27 <lambdabot>    from unus one. See {One}.]
19:24:27 <lambdabot>    Being without a like or equal; unmatched; unequaled;
19:24:27 <lambdabot>    unparalleled; single in kind or excellence; sole. --
19:24:28 <lambdabot> [8 @more lines]
19:24:33 <dons> @more
19:24:34 <lambdabot>    {U*nique"ly}, adv. -- {U*nique"ness}, n.
19:24:34 <lambdabot>  
19:24:35 <lambdabot> *** "Unique" web1913 "Webster's Revised Unabridged Dictionary (1913)"
19:24:36 <lambdabot> Unique \U*nique"\, n.
19:24:38 <lambdabot>    A thing without a like; something unequaled or unparalleled.
19:24:39 <wkh> if they had called it 'uniq' then it wouldn't seem surprising and new, a requirement for everything in haskell
19:24:41 <lambdabot> [3 @more lines]
19:24:48 <mlh> yeah
19:24:51 <dons> unique is not quite the right name for a set
19:24:55 <mlh> what wkh said
19:25:03 <dons> 'nub' makes more sense. 'kernel' might have been good
19:25:09 <ddarius> nub has history before Haskell.
19:25:13 <mlh> dedupe?
19:25:36 * Turks_ sighs
19:25:52 <mlh> a set?  b..but it's a list
19:26:17 <sorear> Turks_: Sorry.  my binary is 50% larger than my hosting quota.  besides, are you running i386 ELF Linux with glibc 2.3.6?
19:26:24 <dons> ?check \s -> let _=s::[Int] where   nub s = S.toList (S.fromList s)
19:26:24 <lambdabot>  Parse error
19:26:27 <Turks_> no
19:26:38 <dons> ?check \s -> let _=s::[Int]  in   nub s = S.toList (S.fromList s)
19:26:39 <lambdabot>  Parse error
19:26:51 <Turks_> there isnt a precompiled binary on the web somewhere?
19:26:54 <nmessenger> (==)?
19:26:57 <Turks_> win32 :(
19:27:02 <dons> ?check \s -> let _=s::[Int]  in   nub s == {- not a good day -} S.toList (S.fromList s)
19:27:03 <lambdabot>  Falsifiable, after 8 tests: [-6,2,-2]
19:27:22 <dons> ?check \s -> let _=s::[Int]  in   nub s == sort ({- not a good day -} S.toList (S.fromList s))
19:27:23 <mlh> the arg i mean
19:27:24 <lambdabot>  Falsifiable, after 1 tests: [2,0]
19:27:33 <nmessenger> S.toList (S.fromList [-6,2,-2])
19:27:36 <nmessenger> > S.toList (S.fromList [-6,2,-2])
19:27:38 <lambdabot>   Not in scope: `S.fromList'
19:27:44 <dons> ?check \s -> let _=s::[Int]  in sort (  nub s) == sort ({- not a good day -} S.toList (S.fromList s))
19:27:46 <lambdabot>  OK, passed 500 tests.
19:27:55 <dons> ?check \s -> let _=s::[Int]  in sort (  nub s) ==  ({- not a good day -} S.toList (S.fromList s))
19:27:57 <lambdabot>  OK, passed 500 tests.
19:28:08 <sorear> dons: does ?check support pattern type signatures?
19:28:18 <nmessenger> S.toList . S.fromList sorts?
19:28:20 <dons> ?check \s -> sort (nub s) == S.toList (S.fromList (s :: [Int]))
19:28:22 <lambdabot>  OK, passed 500 tests.
19:28:34 <dons> hence, nub gives you a set :-)
19:28:46 <dons> sorear: parser issues in h98
19:28:48 <sorear> ?check \(s::[Int]) -> sort (nub s) == S.toList (S.fromList s))
19:28:48 <lambdabot>  Parse error in pattern
19:28:50 <wkh> there's stuff about monoids in Haskell?
19:28:50 <sjanssen> @check \(s :: Bool) -> s -- I think this requires a GHC extension
19:28:51 <lambdabot>  Parse error in pattern
19:28:59 <wkh> i can't believe that abstract algebra class i took might actually come in handy for something!
19:29:04 <dons> ?source Data.Monoid
19:29:04 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
19:29:10 <sorear> oh, speaking of ghc extentions...
19:29:32 <Turks_> and sorear, ive got ghc 6.4.2, so finding a win32 binary would be a better option than compiling jhc
19:29:50 <dibblego> ?users
19:29:51 <lambdabot> Maximum users seen in #haskell: 332, currently: 306 (92.2%), active: 48 (15.7%)
19:29:51 <dons> got hugs running on the amd64.
19:29:55 <dons> i guess i could try yhc
19:29:58 <dons> but it needs scons. boo
19:30:05 <sorear> @type \show -> putStr (show ?a) -- I used slightly over 2:15 ago in response to LoganCapaldo's challenge
19:30:06 <dons> why can't yhc be just another haskell compiler?
19:30:08 <lambdabot> forall t. (?a::t) => (t -> String) -> IO ()
19:30:26 <dons> and i guess hbc isn't going to like amd64
19:30:30 <sorear> dons: scons is written in python, it should be fairly portable
19:30:44 <sorear> useful on the other hand ...
19:30:49 <dons> yeah. but i don't want it :-)
19:30:51 * sorear hates scons
19:30:55 <dons> i've never needed it for anything but yhc
19:30:56 <nmessenger> Monoid (a -> b) looks interesting :D
19:31:38 <mlh> wkh: yeah, Hardy would be disappointed in the current state of things
19:32:00 <sorear> I used it a while back for some large C program whose name I have blissfully forgotten (scons)
19:32:25 <sorear> @users
19:32:26 <lambdabot> Maximum users seen in #haskell: 332, currently: 305 (91.9%), active: 47 (15.4%)
19:32:37 <mlh> "I have never done anything 'useful'. ....   http://en.wikipedia.org/wiki/G._H._Hardy
19:33:52 <nrb23> ?where stateT step by step
19:33:52 <lambdabot> I know nothing about statet.
19:35:07 <sorear> @go Monad transformers step by step
19:35:12 <sorear> nrb23: ^^^ ?
19:35:15 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
19:35:16 <lambdabot> Title: Monad Transformers Step by Step
19:35:22 <nrb23> sorear: yes, that's what I was looking for
19:35:31 <dons> i love having a load average of 15
19:35:39 <dons> and not even noticing it
19:35:44 <dibblego> laughs: seen in ##java <meeper> whats_in_a_name: err no they don't. in fact, if I find a programmer writing an algorithm I'd likely fire him
19:35:55 <dons> hah
19:35:59 <dons> yeah, those algorithms!
19:36:03 <dons> always trouble
19:36:11 <dibblego> it a funny as hell conversation
19:36:17 <dibblego> damn I procrastinate on that channel
19:36:26 <dons> and the java guys wonder why everyone makes fun of them
19:36:31 <dibblego> this guy doesn't
19:36:38 <dibblego> we are all short-sighted according to him
19:36:39 <mbishop> that guy was in #scheme
19:36:55 <mbishop> he was saying how he saw "no value in scheme over java or c#" -_-
19:37:21 <dons> its great that people have opinions
19:37:33 <jcreigh> dons: how so? :)
19:37:35 <dons> its sad that opinions aren't statically typechecked
19:37:39 <dibblego> lol
19:37:40 <mbishop> HASKELL SUCKS
19:37:42 * mbishop runs
19:37:45 <wkh> i thought scheme was useless compared to C
19:37:47 <wkh> when i was 16.
19:37:53 <dons> mbishop: type error in comment
19:38:01 <nmessenger> @remember dons its great that people have opinions; its sad that opinions aren't statically typechecked
19:38:02 <dons> can't apply 'SUCKS' to 'HASKELL'
19:38:02 <lambdabot> Done.
19:38:24 <dons> expected type (Cool Haskell), inferred type '(Sucks Haskell)'. Try again.
19:38:27 <bd_> sucks is a partial function, whose domain does not contain haskell.
19:38:51 <nmessenger> partial?!  Oh noes runtime error!
19:39:21 <nmessenger> you really ought to refine its type.
19:39:24 * sorear downloads the gcc source for the sole purpose of finding the list of caller-saved registers on i386, grr
19:39:41 <nrb23> sorear: oy
19:40:01 <nmessenger> @quote type.?check
19:40:02 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
19:40:04 <sorear> 1 day estimated
19:40:10 <nmessenger> @quote type.?check
19:40:11 <lambdabot> dons says: its great that people have opinions; its sad that opinions aren't statically typechecked
19:40:14 <sorear> 16% [2 gcc-4.1 7313848/37.0MB 19%]                                                                                420kB/s 1m27s  much better
19:40:36 <sorear> dons: nobench already supports jhc/grin
19:40:46 <sorear> dons: just add 'jhc-grin' to the COMPILERS list
19:40:58 <sorear> dons: it's just that JohnMeacham needs to fix it first
19:40:58 <dons> yeah
19:41:09 <dons> do i need to update jhc?
19:42:35 <sorear> dons: my darcs changes shows after blaphohisu: 1. Remove a excessively large show instance to speed up the compiler 2. add a debugging option 3. support RULES_JHC .  I suspect none could fix grin
19:43:07 <sorear> but with your uberfast computer it might not hurt to try it (it might have been fixed between ejthecnar and blaphohisu)
19:43:12 <nrb23> sorear: aren't _all_ of the registers on x86 callee saved
19:44:16 <nrb23> or, maybe not
19:44:19 <sorear> nrb23: my notoriously poor memory gives esi, edi, ebx
19:44:45 * nrb23 mostly deals with ARM and PPC... x86 is scary
19:44:59 <sorear> well it's what I've got
19:45:44 <nrb23> well, I've found the x86-64 convention "The callee is responsible for perserving the value of registers %rbp %rbx, and %r12-r15, as these registers are owned by the caller.  The remaining registers are owned by the callee.  "
19:46:15 <dons> sorear: any idea if jhc is going to work on amd64?
19:46:57 <allbery_b> google tells me %eax, %ecx, %edx are caller-save
19:47:06 <dons> one way to find out ..
19:47:24 <nrb23> my recollection is that there are about 100 different calling conventions on x86
19:48:02 <sorear> dons: it is portable (no target macros) Haskell and generates portable ANSI C
19:50:57 <jcreigh> what's so special about %ebx?
19:51:26 <jcreigh> as compared to other "general purpose" registers. (It turns out that, in reality, the x86 doesn't have any general purpose registers...)
19:52:08 <sorear> jcreigh: all 8 are general purpose.  but some can be used for non-general purposes ...
19:52:27 <MP0> I tried "[1..] !! 10000000" in ghci and it doesn't seem to be lazily computed. Is there something about how !! works that I'm missing? ie, I expected it to force the evaluation of the 10000000 item without needing any other items.
19:52:40 <sorear> correct
19:52:49 <jcreigh> so all x86 registers are general purpose, but some are more general purpose than others?
19:52:56 <bd_> MP0: ooh, it blew the stack, right? :)
19:53:04 <sorear> but because enumFrom is broken in GHC, you're evaluating (1 + (1 + (1 + ...)))
19:53:08 <dons> > [1..] !! 10000000
19:53:11 <bd_> MP0: [1..] :: [Integer] will generate this huge (1+1+1+1+1+1+....)
19:53:11 <sorear> stack overflow!
19:53:14 <lambdabot> Terminated
19:53:16 <MP0> bd_: no clue, I canceled before I tried.
19:53:23 <bd_> MP0: heh
19:53:28 <bd_> > [!..] !! 1000000
19:53:28 <dons> > last ( take 10000000 [1..])
19:53:29 <lambdabot>  Parse error
19:53:33 <bd_> > [1..] !! 1000000
19:53:38 <lambdabot>  Exception: stack overflow
19:53:38 <MP0> I canceled before it blew the stack I mean.
19:53:39 <lambdabot> Terminated
19:53:48 <bd_> > [1..] !! 1000000 :: Int
19:53:50 <dons> > last [1..1000000]
19:53:50 <lambdabot>  1000001
19:53:51 <lambdabot>  1000000
19:54:01 <sorear> > last [1..] :: Int
19:54:05 <lambdabot> Terminated
19:54:07 <dons> get some ints in there. yeah
19:54:10 <sorear> > last [1..] :: Int16
19:54:11 <lambdabot>  32767
19:54:30 <chessguy> so who else wants to get stumped by my random number generation problem?
19:54:31 * sorear muahahahas
19:54:56 <mauke> > [1 ..] !! 520164
19:54:59 <lambdabot>  520165
19:55:06 <mauke> that gives me a stack overflow here
19:55:23 <wkh> me too
19:55:43 <MP0> I'm just kinda curious how I get the benefits of lazy evaluation if it isn't.
19:55:55 <chessguy> http://hpaste.org/666#a1
19:56:14 <dons> > zip "haskell" [1..]
19:56:16 <lambdabot>  [('h',1),('a',2),('s',3),('k',4),('e',5),('l',6),('l',7)]
19:56:17 <dons> like that
19:56:34 <wkh> random programs, eh?
19:56:35 <dons> or better, look at the memory use of haskell in the regex-dna and binarytrees benchmarks on the shootout
19:56:39 * wkh is reminded of genetic programming
19:57:15 <MP0> so in other words I need to assume that the calculation of item n requires the calculation of all previous items?
19:58:09 <chessguy> wkh, indeed
19:58:19 <chessguy> wkh, for genetic programming
19:59:05 <wkh> if you want to get fancy about things and especially if you want to control what kind of programs you generate, i very strongly suggest you look into, e.g., grammatical evolution, or maybe instead strongly-typed GP
19:59:14 <newsham> ?brain -- are you thinking what i'm thinking?
19:59:14 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
19:59:25 <mauke> > let foo (!n) = n : foo (succ n) in foo
19:59:26 <lambdabot>  Parse error in pattern
19:59:37 <nmessenger> @list quote
19:59:38 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
19:59:55 <chessguy> hmm, i've heard of grammatical evolution, but not strongly-typed
20:00:27 <mauke> > let foo n = n `seq` n : foo (succ n) in foo 1 !! 10000000
20:00:29 <wkh> strongly typed GP is just where functions only take arguments of certain types so you restrict what calls what. ECJ (implemented in Java) has an implementation of it
20:00:31 <lambdabot> Terminated
20:00:42 <mauke> > let foo n = n `seq` n : foo (succ n) in foo 1 !! 100000
20:00:44 <lambdabot>  100001
20:00:46 <wkh> GE is more general
20:00:53 <mauke> > let foo n = n `seq` n : foo (succ n) in foo 1 !! 1000000
20:00:55 <lambdabot>  1000001
20:01:36 <chessguy> wkh, i think that with a framework like what i'm doing, support for either could probably be added
20:02:06 <chessguy> but anyway, i think GP is more important for generating algorithms than for generating actual runnable programs
20:04:20 <wkh> its utility in actual software engineering is fairly limited, yeah
20:04:47 <Daveman> :)
20:05:24 <chessguy> and that's really outside the spirit of the initial concept, as drafted by Koza, too
20:05:39 <nrb23> huzzay! http://etherbunny.anytini.com
20:05:40 <lambdabot> Title: Etherbunny
20:06:10 <Darius> nrb23: Impressive
20:06:24 <nrb23> Darius: not really... it actually sucks
20:09:33 <dons> big multicore boxes are really a dream for running testsuites
20:09:47 <dons> you can get linear speedups in runtime of the suite
20:09:58 * dons watches machine load climb to 16
20:10:16 <sorear> dons: so, (given dep analysis), cron anyone?
20:10:34 <dons> cron anyone eh?
20:11:07 <dons> i have a jhc buld going on in the background, not affecting anything
20:11:09 <dons> :-)
20:11:11 <sorear> dons: ooh.  maybe you could have a script check for statistically major changes and notify a mailing list?
20:11:40 <dons> mm
20:11:46 * sorear wishes he had 2 gigs and 2 cores, 16 of each is a bit excessive atm
20:12:22 <dons> you'd need a cleanroom garage for the 16 core box anyway
20:12:27 <dons> too noisy by far to have in the house
20:13:36 <meeper> heh
20:13:38 <sorear> I'd like a 16-core 16-gig box with CPU+RAM hotplug and triacs inserted everywhere.  One core until loadavg reaches 2.0, etc etc.  Power conservation FTW!
20:14:50 <sorear> and don't forget the dynamic fan control
20:14:59 <dons>  15:11:41 up 2 days, 22:32,  5 users,  load average: 11.48, 8.01, 4.45
20:15:18 <dons> under utilised!
20:15:32 <sorear> you have a running joule total? :)
20:16:16 <dons> i'm just playing my part in bringing about the cylon takeover
20:16:19 <dons> we all do what we can
20:16:58 <slowriot> dons: so you use Haskell at work?
20:17:40 <dons> yeah. 95% haskell, 4% sh, 1% C.
20:17:43 <meeper> dons: you want the cylons to take over?
20:18:01 <slowriot> Cool. What are you working on?
20:18:12 <dons> meeper: sssh! that's a secret
20:18:19 <dons> slowriot: phd :-)
20:18:30 <meeper> dons: who are the other cylon sympathizers?
20:18:32 <slowriot> awesome
20:18:36 <jcreigh> he's one of them!
20:18:56 <slowriot> mind if I ask what the topic is?
20:18:57 <lambdabot> there will be no more talk of cylons!
20:19:10 <dons> slowriot: dynamic linking in statically typed languages
20:19:13 <dons> and general haskell dev
20:19:16 <chessguy> slowriot, it's really a shame. dons spends all his time working on writing his dissertation instead of coding
20:19:25 <mauke> if the robots win, we'll have to listen to techno
20:19:54 <slowriot> chessguy, I don't know. Writing a dissertation sounds more interesting than coding.
20:20:06 <chessguy> </sarcasm>
20:20:12 <slowriot> ah
20:20:41 <meeper> slowriot: c' n'est pas vrai
20:20:46 <lambdabot> actually, we cylons quite like your human music. Particularly Bach. calms the electrons after a hard days human slaying
20:20:50 <MP0> If writing 1 dissertation is good, writing 15,382,000 must be better. http://pdos.csail.mit.edu/scigen/
20:20:51 <lambdabot> Title: SCIgen - An Automatic CS Paper Generator
20:21:55 <slowriot> meeper: what does that mean?
20:23:25 <meeper> slowriot: nothing. but I wanted to say it's not true. coding can be more interesting than a dissertation :)
20:26:55 <hyrax42> ?hoogle (a,b) -> (b,a)
20:26:56 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:26:57 <slowriot> Do you guys believe that Haskell should be used as a general purpose language?
20:27:11 <allbery_b> why not?
20:27:15 <slowriot> It seems to have quite a diverse collection of libraries. So to me, that suggests that it is.
20:27:26 <hyrax42> what the devil
20:27:31 <slowriot> (a general purpose language)
20:27:38 <meeper> hyrax42: the devil is here alright
20:27:49 <allbery_b> heck, I use perl and ruby as GP languages, and neither's going to win any awards for speed
20:27:59 <hyrax42> ?djinn (a,b) -> (b,a)
20:27:59 <lambdabot> f (a, b) = (b, a)
20:28:09 <slowriot> heh... Haskell is quite fast compared to those languages.
20:28:15 <bd_> ?djinn (a,b) -> (a,a)
20:28:16 <lambdabot> f (a, _) = (a, a)
20:28:19 <bd_> ?djinn (a,b) -> (a,c)
20:28:20 <lambdabot> -- f cannot be realized.
20:28:22 <dons> its a general purpose language and people use it as such.
20:28:24 <allbery_b> rocks are fast compared to ruby, but... :)
20:28:26 <jcreigh> especially Ruby
20:28:34 <dons> from writing os kernels to high math
20:28:42 <jcreigh> dons: os kernels?
20:28:47 <allbery_b> House
20:28:58 <dons> there's 3 kernels in haskell that i can think of , and 2 filesystems
20:28:58 * hyrax42 would have assumed that would be in the libs
20:29:50 <dons> in fact, haskell is probably suited to a wider range of tasks than say, python. you wouldn't write a kernel in python
20:29:50 <sorear> @ty curry (flip id)
20:29:51 <LoganCapaldo> are the filesystems lazy?
20:29:53 <lambdabot> forall a b c. a -> b -> ((a, b) -> c) -> c
20:30:02 <slowriot> I'd imagine some of the core code would be written in C, am I right?
20:30:03 <sorear> @ty uncurry (flip id)
20:30:06 <lambdabot> forall a c. (a, a -> c) -> c
20:30:06 <LoganCapaldo> They only write to a file when something else tries to read from it?
20:30:14 <sorear> @ty uncurry (flip (,))
20:30:16 <lambdabot> forall b a. (a, b) -> (b, a)
20:30:35 <dons> the bottom bit of the OS is a C runtime, like the C runtime, but providing a haskell runtime
20:30:55 <hyrax42> sorear: aye
20:31:16 <allbery_b> slowriot: actually, I'd expect certain core code to be written in assembler, and the rest could be in any reasonable language.  (and runtime, but if you wanted to be really weird that could be bootstrapped much like ghc is)
20:31:18 <LoganCapaldo> Is the haskell GC (storage manager?) written in Haskell?
20:31:23 * sorear plans eventually to add hardware drivers to ayhi ... 500 bytes of asm, the rest is Haskell
20:31:24 <jcreigh> dons: there's a project (I don't recall the name ATM) to write an OS in Python. Of course, it's not going anywhere, but people are trying.
20:31:28 <dons> LoganCapaldo: nope.
20:31:29 <nmessenger> @. pl djinn (a,b)->(b,a)
20:31:30 <lambdabot> f = uncurry (flip (,))
20:31:59 <slowriot> jcreigh: As much as I love Python, that sounds like a horrible idea from my naive perspective.
20:32:02 <sorear> LoganCapaldo: in the final ayhi-ncg, ONLY the garbage collector will be !haskell ...
20:32:16 <LoganCapaldo> dons, it could be though right? Or at least some subset of Haskell with memory primitives
20:32:18 <dons> jcreigh: there's no obvious benefit though. at least for kernels you want high assurance, so there's some incentivie to use strong static typing
20:32:23 <allbery_b> there is at least one pythn compiler, so not compl;etely insane
20:32:24 <dibblego> ugh! a strictness annotation on haskell itself!
20:32:28 <LoganCapaldo> sorear, ayhi-ncg?
20:32:30 <dons> LoganCapaldo: yeah. region based GC could be done in haskell
20:32:36 <LoganCapaldo> @where ayhi-ncg
20:32:36 <lambdabot> I know nothing about ayhi-ncg.
20:32:59 * LoganCapaldo is obsessed with self-hosting for some reason
20:33:09 <sorear> not released or mostly written yet ... my project to redesign and rewrite yhi
20:33:21 <LoganCapaldo> @where yhi
20:33:22 <lambdabot> I know nothing about yhi.
20:33:24 <LoganCapaldo> heh
20:33:28 <LoganCapaldo> I'm batting a thousand
20:33:31 <LoganCapaldo> @go yhi
20:33:32 <lambdabot> http://www.yhi.com.au/
20:33:33 <lambdabot> Title: YHI | HOME
20:33:38 <sorear> I've got 500 lines of assembler atm
20:33:50 <LoganCapaldo> nope thats not it :)
20:34:01 <LoganCapaldo> @go yhi haskell
20:34:03 <sorear> http://darcs.haskell.org/yhc/src/runtime/BCKernel/
20:34:03 <lambdabot> http://www.mail-archive.com/yhc@haskell.org/msg00623.html
20:34:04 <lambdabot> Title: [Yhc] yhi talks about a "haskell class file"
20:34:04 <lambdabot> Title: Index of /yhc/src/runtime/BCKernel
20:34:13 <dons> sorear: hmm. jhc on amd doesn't look too promising,
20:34:14 <dons> [dons@serenity digits-of-e1]$ ./digits-of-e1 1400
20:34:14 <dons> Segmentation fault
20:34:25 <dons> i guess we'll see what we shall see.
20:34:40 <sorear> @localtime JohnMeacham
20:34:41 <lambdabot> Local time for JohnMeacham is Sun Feb 25 20:32:13
20:34:59 <LoganCapaldo> @where yhc
20:34:59 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
20:35:42 <dons> sorear: i'll do a full build now, see if anything runs
20:35:43 <dons> it built ok
20:35:59 <sorear> dons: how about sorting the columns in the nobench output by mean speed?
20:38:29 <slowriot> I am interested in video game development. Do you think functional programming would be effective for game development?
20:38:41 <sorear> @where Frag
20:38:42 <lambdabot> http://www.haskell.org/haskellwiki/Frag
20:38:53 <slowriot> yeah, I've heard of Frag. I haven't tried it yet.
20:39:02 <siti> it crashes for me :(
20:39:39 <glguy> You need OpenGL support for 1
20:39:48 <siti> I have open gl 2.1
20:39:53 <glguy> and you have to specify a level
20:39:56 <siti> that's not the issue
20:39:57 <glguy> (worked for me on windows)
20:39:57 <slowriot> I started to skim through some of the yampa-related papers, but I want to get it installed before I investigate it in-depth.
20:40:07 <dons> sorear: so by which column? ghc's speed?
20:40:14 <dons> or the mean over all compilers?
20:40:26 <siti> it's that the creator uses unsafe malloc calls, and doesn't realise that int is not always 32bit
20:40:46 <glguy> you can't run in some 32bit emul mode?
20:41:01 <siti> well I don't have a 32bit ghc :(
20:42:11 <jcreigh> haha! ghc --make FTW!
20:42:21 <sorear> dons: sorry, I mean sort the compilers by the mean benchmark speed
20:42:35 <dons> sort them horizontally across the page?
20:42:43 <dons> so jhc ghc hbc ... yhc ?
20:42:52 <dons> hugs is lsat, actually
20:43:02 <sorear> yeah
20:43:20 <dons> yeah, i suppose that would be interesting.
20:44:25 <slowriot> glguy: what does gl stand for? Graphics Library?
20:44:37 <hyrax42> :t M.lookup
20:44:40 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
20:44:47 <glguy> good looking, gross lunch, gamma lambda
20:44:57 <glguy> depends on the day :)
20:44:58 <hyrax42> :t fromJust . M.lookup
20:45:01 <lambdabot>     Couldn't match expected type `Maybe a'
20:45:01 <lambdabot>            against inferred type `M.Map a2 a1 -> m a1'
20:45:16 <slowriot> It never stands for graphics library, though, huh?
20:46:59 <nmessenger> @type (fromJust .) . M.lookup
20:47:02 <lambdabot> forall a a1. (Ord a) => a -> M.Map a a1 -> a1
20:47:14 <sorear> @type (M.!)
20:47:17 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
20:47:25 <sorear> @type flip (M.!)
20:47:29 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> a
20:48:14 <sorear> @type M.findWithDefault undefined
20:48:17 <lambdabot> forall a k. (Ord k) => k -> M.Map k a -> a
20:48:20 <nmessenger> :)
20:52:41 <slowriot> does anyone know what gl stands for?
20:52:56 <hyrax42> good luck
20:53:04 <hyrax42> among other things
20:53:15 <Pseudonym> Yes, it's Graphics Library.
20:53:21 <allbery_b> opengl is a 3d graphics standard
20:53:27 <slowriot> yeah, I know.
20:53:30 <allbery_b> based on SGI's SGL
20:53:30 <Pseudonym> It's the old library that Silicon Graphics (as it was then) defined for their workstations.
20:53:31 <sorear> > 71 / 136
20:53:33 <lambdabot>  0.5220588235294118
20:53:36 <sorear> Irix GL
20:53:48 <Pseudonym> allbery_b: Technically, they weren't SGI at the time.
20:54:14 <sorear> yay, more than halfway through the bytecodes .. (testing will be fun when I become able to load nobench)
20:55:09 <slowriot> I'm trying to learn about graphics. It isn't going as smoothly as learning classic algorithms from CLRS went.
20:57:05 <slowriot> Computer Graphics is a pretty deep subject, but there are a lot of texts, even the most popular ones, that give you the psuedo code for certain algorithms without explaining their mathematical contexts.
20:57:35 <slowriot> this is probably too off-topic
20:58:14 <jcreigh> doesn't Haskell School of Expression take a graphical approach? (I haven't read it)
20:58:23 <wkh> yeah and the graphics look like shit
20:58:37 <slowriot> 2D or 3D?
20:58:40 <wkh> 2d
20:58:53 <jcreigh> aww, no raytracing?
20:58:53 <wkh> but he develops cool DSLs for making them so it kind of redeems itself
20:58:57 <wkh> nope.
20:59:14 <slowriot> Messing around with 2D graphics can be a decent way to learn about programming.
20:59:15 <wkh> the theme of the book is embedded DSLs
20:59:30 <jcreigh> I've always thought raytracing is kinda cool. I should write a raytracer sometime.
20:59:49 <hyrax42> ?docs Data.Map
20:59:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
20:59:55 <SamB> I've actually written part of an ICFP raytracer...
20:59:58 <SamB> it actually seems to work
21:00:07 <slowriot> Does anyone here know much about graphics? I'd imagine glguy does.
21:00:17 <SamB> I think I mostly just need to feed the shader what it wants and spawn subrays...
21:00:21 <SamB> and then it will work
21:00:36 <SamB> (maybe I also have some more types of objects and lights to do?)
21:02:18 <lupo__> ...
21:02:46 <lupo__> i feel like back in seventh grade when i started with pascal
21:03:15 <SamB> lupo__: is it because of how people always hear Haskell as Pascal?
21:03:26 <mauke> haha
21:03:35 <SamB> that might be the #1 most annoying thing about Haskell
21:03:39 <lupo__> lol
21:03:52 <lupo__> yeah, it's all about the name
21:03:57 <slowriot> yeah, only the first consonant is different
21:04:20 <mauke> english sucks
21:04:26 <mbishop> people suck
21:04:53 <slowriot> are there any graphics channels on freenode? The closest one I've found is blendercoders
21:04:55 <lupo__> torvalds always noted that.
21:05:02 <SamB> ps are apparantly hard to tell from hs
21:05:22 <SamB> lupo__: noted what?
21:06:18 <lupo__> SamB: it's all about the name. quote: "OS/2? Hah. I've got Linux. What a cool name"
21:06:39 <ephemient> one of my friends was complaining that they they got confused when I spoke of Has'kell, so I started saying 'Has.koll
21:06:50 <SamB> they could have called it CAT
21:07:09 <lupo__> don't do that, some splinter group will fork the language and call it DOG
21:08:01 <SamB> I meant, IBM should have called OS/2 that
21:08:08 <SamB> (after MS-DOG)
21:08:16 <lupo__> <-- noob of the day ... writing a program that finds the smallest distance between two nodes in a directed graph ... and failed (so far)
21:08:31 <lupo__> ah i see
21:08:39 <falconair_> i'd like to know if problems of the following kind have a specific name (and associated literature): given an array of numbers, x0, x1, x2, ...xn, figure out the maximum difference between those numbers as long as the greater number comes after the smaller number...for example:
21:08:42 <lupo__> you know not everybody likes CATs?
21:08:46 <mbishop> lies
21:09:03 <SamB> why does apple name their OSes after them, then?
21:09:08 <slowriot> lupo__: you mean the distance of the shortest path between two nodes?
21:09:16 <lupo__> slowriot: riiight.
21:09:28 <slowriot> lupo__: are you using fgl?
21:09:41 <mbishop> that's easy, just create a wormhole and the distance is 0
21:09:47 <slowriot> lol
21:09:49 <lupo__> slowriot: use what?
21:09:50 <falconair_> [1,2,3,4,5] => [1,5] => 4, [2,1,3,5]=> [1,5], [5,1,2,3] => [1,3], etc.
21:10:12 <lupo__> and where's the wormhole module?
21:10:26 <SamB> lupo__: I think he meant an arc
21:10:31 <slowriot> lupo__: functional graph library... or are you trying to write the algorihtm yourself? And in what language? Also... do you want help?
21:10:34 <falconair_> i'd like to do this in terms of a fold (basically i'm trying to figure out how to do time series analysis using catamorphisms)
21:10:35 <SamB> and I think it would count as one
21:10:49 <lupo__> slowriot: there is a graph library? why didn't anyone tell me? *g*
21:10:54 <nmessenger> falconair_: so maximum . map maximum . groupIntoSortedSublists?
21:11:18 <nmessenger> wait, no
21:11:35 <slowriot> lupo__: writing graph algorithms using fgl is extremely elegant. It has it's issues, though.
21:11:35 <lupo__> slowriot: thx for the hint, i think i'll be better of with it
21:11:48 <slowriot> lupo__: you should read this paper...
21:12:21 <slowriot> http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
21:12:23 <lambdabot> http://tinyurl.com/gf73z
21:12:43 <nmessenger> maximum . map (\xs -> last xs - head xs) . groupIntoSortedSublists?
21:13:24 <slowriot> dang... I need to study image processing some more. Later guys.
21:13:54 <newsham> mmm multi-dimensional discrete time signal processing
21:13:56 <falconair_> messenger: so groupIntoSortedSublists does exactly what?  split a list into sublists as long as the values are increasing?
21:14:03 <nmessenger> yep.
21:14:10 <slowriot> newsham: indeed
21:14:27 <nmessenger> left as an exercise for the reader :>
21:14:43 <nmessenger> just asking if I understand the question
21:15:17 <falconair_> nmessenger: ok, before it scrolls off, i need to copy it and figure it out correctly :)  thanks
21:15:28 <falconair_> nmessenger: oh, not sure, i need to understand your solution first
21:16:00 <falconair_> nmessenger: basically i am trying to translate a paper from the sql world into haskell type list comprehensions
21:16:17 <lupo__> oh man ... i'm a biologist, not a mathematician ...
21:17:01 <newsham> let fir impulse ys = map (\xs -> sum $ zipWith (*) impulse xs) (tails ys)
21:18:20 <glguy> fir impulse = (sum . zipWith (*) impulse) . tails
21:18:32 <glguy> feel free to ignore me :)
21:18:40 <newsham> no, s'good
21:18:46 <nmessenger> pointlessness ftw!
21:18:53 <newsham> i see a point
21:19:01 <glguy> i'm working there
21:19:08 <newsham> ?pl \fir impulse ys = map (\xs -> sum $ zipWith (*) impulse xs) (tails ys)
21:19:09 <lambdabot> (line 1, column 17):
21:19:09 <lambdabot> unexpected "="
21:19:09 <lambdabot> expecting pattern or "->"
21:19:16 <newsham> ?pl \fir impulse ys -> map (\xs -> sum $ zipWith (*) impulse xs) (tails ys)
21:19:17 <lambdabot> const ((. tails) . map . (sum .) . zipWith (*))
21:19:36 <glguy> fir impulse = flip (.) tails . ((.) sum . zipWith (*))
21:19:39 <glguy> err
21:19:40 <nmessenger> within reason of course ;)
21:19:45 <glguy> fir = flip (.) tails . ((.) sum . zipWith (*))
21:20:03 <newsham> elegance is readability
21:20:28 <glguy> fir = (. tails) . ((sum .) . zipWith (*))
21:20:30 <nmessenger> fir = (. tails) . ((sum .) . zipWith (*))
21:20:40 <glguy> :-p
21:20:44 <nmessenger> infix also ftw!
21:20:52 <glguy> I was showing my work!
21:20:53 <glguy> shesh :)
21:21:25 <newsham> elegance is readability
21:21:55 <nmessenger> wait a sec, I think you dropped the map D:
21:22:01 <glguy> ops
21:22:04 <glguy> oo*
21:22:14 <nmessenger> fir = (. tails) . map . (sum .) . zipWith (*)
21:22:25 <glguy> ?type  (. tails) . map . (sum .) . zipWith (*)
21:22:28 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
21:22:36 <newsham> let sumMult xs ys = sum (zipWith (*) xs ys) in map sumMult impulse (tails ys)
21:22:47 <nmessenger> @pointy (. tails) . map . (sum .) . zipWith (*)
21:22:47 <lambdabot> (\ e n -> map (\ q -> sum (zipWith (*) e q)) (tails n))
21:22:58 <glguy> sumMult = (sum . ) . zipWith (*)
21:23:02 <nmessenger> looks good :D
21:23:48 <glguy> ?unpl (sum . ) . zipWith (*)
21:23:48 <lambdabot> (\ d g -> sum (zipWith (*) d g))
21:24:30 <nmessenger> (.:) and on should really be in the prelude, more ammo for @pl
21:25:11 <glguy> ?unpl (.)(.)(.) sum (zipWith (*))
21:25:12 <lambdabot> (\ f i -> sum (zipWith (*) f i))
21:26:03 <glguy> why not (...) :)
21:26:18 <nmessenger> 'cause that should be undefined!
21:26:58 <dons> grr. yhc breaks
21:31:04 <nmessenger> ...tho I do like (was it jhc's?) using the magic underscore in an expression for 'undefined' + source location annotation.
21:32:38 <nmessenger> _ in pattern is "ignored name", _ in expression is "no value", perhaps _ in type is "infer this part" :D
21:33:40 <glguy> I wast thinking today that _ in a type sig would be the same as in a pattern
21:33:51 <glguy> thing I never touch
21:34:05 <glguy> ?type Right
21:34:07 <lambdabot> forall b a. b -> Either a b
21:34:15 <nmessenger> ah, cool
21:34:20 <glguy> forall a. a -> Either _ a
21:34:43 <glguy> a -> Either _ a
21:34:46 <glguy> would be a better example
21:35:12 <nmessenger> _ for "infer this part" could do that, right?
21:35:18 <glguy> yeah
21:35:23 <lupo__> is there something like an IN-operator (1 in [1,2] evaluates to true, 3 in [1,2] to false)
21:35:33 <wkh> :t elem
21:35:35 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:35:45 <wkh> > elem 1 [1, 2]
21:35:46 <lambdabot>  True
21:35:47 <lupo__> thx
21:35:53 * nmessenger wanted to do it, but was waiting for the "majestic stereo"
21:36:25 <nmessenger> it's usually used in sections: (1 `elem`) = "one is an element of..."
21:36:51 <lupo__> i would have tested on length(filter())
21:37:03 <bd_> hmm, rather than using _ for inference, how about an exists operator?
21:37:14 <bd_> exists b. forall a. a -> Either b a
21:37:17 <nmessenger> *smack*, you could've at least test (not . null)
21:37:26 <bd_> then again, if you change the order of those, would it be decidably?
21:37:28 <bd_> decidable*(
21:37:49 <lupo__> thx
21:53:38 <nmessenger> > (foldr (.) id . map (:)) "abc" "xyz"
21:53:40 <lambdabot>  "abcxyz"
21:53:47 <nmessenger> :)
21:58:49 <lupo__> > "abc" ++ "xyz"
21:58:50 <lambdabot>  "abcxyz"
22:02:43 <MP0> > zip "haskell" [1..]
22:02:44 <lambdabot>  [('h',1),('a',2),('s',3),('k',4),('e',5),('l',6),('l',7)]
22:06:21 <JohnMeacham> sorear: local time has very little coorelation to when i am awake.
22:07:57 <sorear> hmm
22:08:23 <sorear> I've done thinking about a lbplugin for statistical analysis of lines/hour utc
22:10:37 <jcreigh> hey, do any other Haskellers use del.icio.us?
22:11:26 <ddarius> sigfpe
22:11:39 <jcreigh> I was just thinking it might be cool if anything tagged "haskell" by certain people was automagically announced in-channel.
22:11:52 <bhauth> That's what delicious is for?
22:13:02 <jcreigh> naw, I was just thinking it would be kinda cool.
22:15:56 <haskray> what's ICFP?
22:17:02 <ddarius> International Conference/Content on Functional Programming
22:17:10 <ddarius> s/Content/Contest/
22:17:15 <bhauth> http://www.google.com/search?hl=en&q=ICFP&btnI=I%27%27m+Feeling+Lucky
22:17:16 <MP0> A chance to make a VM that runs Umix
22:17:18 <lambdabot> Title: Welcome to International College of Financial Planning ::, http://tinyurl.com/yr69m7
22:17:27 <haskray> and how do you win?
22:17:35 <MP0> make a VM that runs Umix faster
22:17:44 <MP0> ;-p
22:17:58 <MP0> it changes every year.
22:18:11 <haskray> MPO: ok, so Umix was a language?
22:18:12 <MP0> but generally solve problems faster than other people do.
22:18:12 <ddarius> haskray: There's a conference and an associated contest.  How you win the contest is different each time.  It usually involves writing a program in a few days to accomplish some task.
22:18:31 <MP0> Umix was an operating system running on a VM you had to write for the last contest.
22:18:32 <haskray> ddarius: can anyone partecipate?
22:18:37 <MP0> yes
22:18:38 <ddarius> haskray: Yes
22:18:41 <haskray> MPO: I see
22:18:57 <ddarius> @google International Contest on Functional Programming
22:18:59 <lambdabot> http://www.icfpconference.org/
22:18:59 <lambdabot> Title: The ACM SIGPLAN International Conference on Functional Programming (ICFP)
22:19:14 <jcreigh> http://www.boundvariable.org/
22:19:15 <lambdabot> Title: ICFP Programming Contest, 2006
22:19:18 <haskray> ddarius: so even if I'm not a researcher I could get a little bit of notoriety by winning the context (huge assumption that I would be able to)
22:19:37 <jcreigh> the '06 contest involved implementing a simple VM.
22:19:51 <ddarius> A little bit of notoriety.  Not much.
22:19:53 <sorear> night all...
22:20:28 <haskray> ddarius: I see
22:20:30 <ddarius> Maybe if you win using Intercal or something you'd get a bit more notoriety.
22:20:35 <MP0> what I'd love to C is C as the choice programming language for discriminating hackers.
22:20:48 <ddarius> I think C++ actually got it one year.
22:21:13 <haskray> I've investigated Haskell for a few days, and as a Ruby programmer I've come to the following conclusions
22:21:23 <dons> the C entries always bomb out under stress testing though
22:21:40 <haskray> 1) Haskell makes Ruby look like a toy :-(
22:21:42 <dons> there's usually 20% or more of the entries in C, they just segfault.
22:22:14 <dons> when there's only 3 days to get something done, and any bug that appears during testing leads to disqualification, you can't afford to have bugs appear late
22:22:15 <MP0> how did they run for the programmer?
22:22:16 <haskray> 2) I'm an incompetent programmer :-(
22:22:42 <haskray> 3) I absolutely love it! :-)
22:22:45 <ddarius> http://www.dtek.chalmers.se/groups/icfpcontest/results.html
22:22:47 <lambdabot> Title: ICFP Programming Contest -- Results
22:22:52 <dons> haskray: good to hear!
22:23:38 <haskray> dons: I've always found a huge gap between mathematical functions, calculus, etc... and the actual programming languages
22:24:03 <haskray> dons: when i came to Haskell I said... holy crap, this is like 1 to 1 mapping
22:24:08 <lupo__> gotta go the the university. have a nice <insert your daytime here> and thanks for all the help. now i can count the minimum number of edges between two given nodes in a directed graph. feel much better :)
22:27:20 <haskray> I've a question for you in regards to fibonacci. Keep in mind that I'm a beginner and that I'm learning Haskell on my own (e.g. not at a university). When I calculate the fib the typical recursive way It is very slow... what's the optimal and haskell-way of calculating fibonacci? I mentally know that it's a matter of caching the previous values inline, but I wouldn't know how to do that in a language that is not
22:27:20 <haskray>  imperative?
22:28:11 <ddarius> The optimal way takes more than memoization.
22:28:59 <haskray> ddarius: ok. A faster than let fib 0 = 1; fib 1 =1; fib n = fib(n-1) + fib(n-2) way?
22:29:23 <haskray> ddarius: e.g. mine is so naive... :)
22:29:26 <dons> ?go site:haskell.org the fibonacci sequence
22:29:28 <lambdabot> http://haskell.org/haskellwiki/The_Fibonacci_sequence
22:29:29 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
22:29:33 <dons> haskray: ^^
22:29:43 <haskray> dons: ahahah... great.
22:29:51 <dons> zipWith is the nice memoising solution.
22:30:01 <jcreigh> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- the traditional "haskell is so cool" fib
22:30:03 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:30:11 <dons> since you're recalculating results a lot with your fib (n-1) + fib (n-2) version
22:31:06 <dons> > fix ( (1:) . scanl (+) 1 ) -- is efficient but obscure
22:31:08 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:31:08 <haskray> zipWith applies the operator to each pair in the two lists?
22:31:10 <jcreigh> hmm, does fibonacci start 0, 1 or 1, 1? I always thought it was 0, 1?
22:31:15 <dons> haskray: yeah
22:31:26 <dons> > zipWith (*) [1,2,3,4] [2,4,6,8]
22:31:27 <haskray> jcreigh: 0 yeah
22:31:28 <lambdabot>  [2,8,18,32]
22:31:38 <dons> > zipWith (,) [1,2,3,4] [2,4,6,8]
22:31:40 <lambdabot>  [(1,2),(2,4),(3,6),(4,8)]
22:31:52 <dons> zipWith is a bit perlish :-)
22:32:05 <haskray> dons: zipWith is now my best friend... takes the place of Map
22:32:08 <dons> heh
22:32:44 <haskray> what about speed in general? coming from Ruby, Haskell seems to me unbelievably fast!
22:32:46 <ddarius> haskray: You may also want to look at SICP where it has the "optimal" version of fib as an exercise.
22:32:58 <ddarius> @google Structure and Interpretation of Computer Programs
22:33:01 <lambdabot> http://mitpress.mit.edu/sicp/full-text/book/book.html
22:33:01 <lambdabot> Title: Structure and Interpretation of Computer Programs
22:33:09 <haskray> ddarius: is it easy to translate scheme code to Haskell?
22:33:18 <dons> ?shootout -- as you can see, its competitive with other higher level langauges for ra speed
22:33:19 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
22:33:21 <jcreigh> haskray: yeah, but Ruby is so slow, anything seems fast. :) (But really, Haskell is pretty fast.)
22:33:33 <ddarius> haskray: Most of it should be more or less easy.
22:34:03 <haskray> what about OCaml? A friend of mine told me that I shouldn't spend time on Haskell but rather use Ocaml... I don't like Ocaml syntax and Haskell seems nicer to me.
22:34:09 <dons> maybe ruby is a toy? :-)   --> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ruby
22:34:11 <ddarius> Most of SICP should be almost trivial to translate.
22:34:12 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/veo3w
22:34:22 <dons> haskray, ocaml is nice. but its a bit old fashioned compared to haskell
22:34:28 <haskray> ddarius: thanks
22:34:28 <dons> its more like haskell circa 1989
22:34:44 <haskray> dons: Miranda basically
22:34:56 <ddarius> dons: wtf?
22:35:25 <dons> hmm. not really. its its own complete language. it just lacks nice overloading, syntax
22:35:40 <ddarius> I agree with the overloading and syntax.
22:36:02 <dons> i.e. haskell - laziness, monads, syntax, typeclasses
22:36:10 <jcreigh> haskray: well, there's a lot more activity in the Haskell community right now vs. ocmal. (eg, I used to lurk in #ocmal, and it almost always dead, compared to here, with 300+ people)
22:36:24 <dons> which leaves you with a cutting edge language circa 1989 technology
22:36:27 <dons> i.e. ML :-)
22:36:29 <jcreigh> s/almost/was almost/
22:36:31 <ddarius> jcreigh: I don't think the O'Camlers hang out on freenode.
22:36:38 <jcreigh> ddarius: oh, really? Where then?
22:36:51 <haskray> Great. Thanks for the info about OCaml.
22:36:54 <haskray> in the Ruby community there is a huge marketing effort. Everyone tries to push Ruby to the other developers (e.g. Python, PHP, Perl, etc...). What's the real spirit of the Haskell community? And if marketing is appreciated, how could I get involved in the Haskell community?
22:36:57 <jcreigh> surely not this "real life" which I have heard about. :)
22:37:11 <ddarius> jcreigh: Heck if I know, I've never been a part of the O'Caml community.  It's just that the O'Camlers here didn't seem to care too much for #ocaml.
22:37:19 <dons> haskray, dive in! one good way is to blog about your haskell experiences
22:37:20 <jcreigh> ddarius: oh, okay
22:37:24 <dons> haskray, and to contribute libraries
22:37:38 <ddarius> jcreigh: Possibly they stick to the mailing lists (?)
22:37:39 <dons> we like to influence programmers based on technical merit and having better solutions
22:37:57 <dons> though there's some marketing as well (i have a theory we can win over lisp refugees)
22:38:03 <emu> and jedi mind tricks
22:38:06 <dons> that too
22:38:26 <jcreigh> I don't remember being influence by jedi mind tricks...wait a minute...
22:38:41 <dons> as you can see, ocaml is pretty quick, haskell (ghc 6.6) is pretty close, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ocaml
22:38:42 <jcreigh> *influenced
22:38:43 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/glm93
22:38:45 <dons> but it wins on concurrency
22:39:07 <haskray> dons: I prefer to remain anonymous here, but in the ruby community I'm quite well known, so if I blog about Haskell it may be noticed by a few thousands people. But I've to think about this one. :)
22:39:17 <ddarius> haskray: The Haskell community isn't very pushy, it's open, open-minded, and welcoming.
22:39:25 <dons> haskray, hehe ok. good! use the power wisely :-)
22:39:32 <haskray> ddarius: academic right?
22:39:55 <dons> haskray, and if you do want to write, ping us -- there's lots of people here who'd love to help proof read :-)
22:39:59 <ddarius> haskray: A good chunk, but definitely not all of it.  I, for example, am not an academician.
22:40:16 <emu> please don't write a monad tutorial
22:40:26 <haskray> dons: I will. I first need to really get into the Haskell community and learn the language properly. Then I'll promote it in my blog...
22:40:34 <dons> hehe good plan
22:40:38 <haskray> dons: it's a good idea about the proof reading as well
22:40:44 <dons> and you've got ghc?
22:41:07 <dons> if you really get into it, it would be interesting to see a Ruby v Haskell comparision (maybe for the Monad Reader magazine).
22:41:17 <haskray> dons: yeah, I've not slept because of GHC :-P
22:41:21 <dons> particularly from  someone well versed in ruby
22:41:34 <dons> ?users
22:41:35 <lambdabot> Maximum users seen in #haskell: 332, currently: 288 (86.7%), active: 38 (13.2%)
22:41:42 <dons> oh, i note we reached a new user high score today!
22:41:47 <dons> yaya. growth :-)
22:42:05 <haskray> dons: sounds great! I'm sure I will.
22:42:50 <LoganCapaldo> Ruby v. Haskell. Ruby has anonymous functions. Haskell has anonymous functions. Comparision ends. Everything else is completely different <g>
22:43:35 <ddarius> LoganCapaldo: Actually... that might not be too inaccurate.
22:43:39 <haskray> dons: I either get into languages at the right time or I bring luck... I joined Python before it was widely adopted, and Ruby before Rails was even around... :-P
22:43:45 <LoganCapaldo> ddarius, I know :)
22:43:51 <LoganCapaldo> I was only half joking
22:44:19 <haskray> LoganCapaldo: I'll try to extend your line into an article. I'll quote you if you don't mind.
22:44:29 <dons> haskray, hmm! :-) oh, btw, have you seen the Ruby Quiz solutions in Haskell?
22:44:34 <ddarius> haskray: A simpler explanation is that you join when many other people are joining.
22:44:36 <dons> they might be useful if you're looking for puzzles to hack on
22:44:51 <ddarius> haskray: I.e. it's statistically likely that you would join during those times.
22:44:53 <haskray> ddarius: yes I agree, but it's usually well in advance
22:45:02 <dons> http://www.haskell.org/haskellwiki/Haskell_Quiz
22:45:03 <lambdabot> Title: Haskell Quiz - HaskellWiki
22:45:20 <haskray> dons: thanks. That will be a lot useful.
22:46:00 <LoganCapaldo> well if haskray's pattern holds, Haskell is about to replace Java <g>
22:46:22 <sieni> let's hope so
22:46:24 <haskray> LoganCapaldo: let's hope for the best :-P
22:46:31 <dons> :)
22:46:42 <dons> growth is good. more code, more libraries, more jobs.
22:46:43 <haskray> software would improve for sure
22:46:44 <jcreigh> LoganCapaldo: except that Haskell does have weird scoping rules that screw you over whenever you try to treat blocks like lambdas.
22:46:47 <jcreigh> *doesn't
22:47:05 <LoganCapaldo> Like I said, everything else is completely different :)
22:47:09 <LoganCapaldo> including scoping :)
22:47:10 <jcreigh> heh
22:47:16 <dons> > runState (do x <- get ; put (x+1) ; return "done") 7 -- yay for anonymous code
22:47:17 <lambdabot>  ("done",8)
22:48:01 <dons> hmm. it *is* kind of cool to be able to toss around anonymous chunks of imperative code as arguments to functions
22:48:12 <dons> i've decided monads are kewl.
22:48:22 <haskray> I need to get back to work. I'll talk to you all soon.
22:48:30 <LoganCapaldo> dons: what just now?
22:48:36 <sjanssen> @remember dons i've decided monads are kewl.
22:48:36 <lambdabot> Done.
22:48:39 <dons> yeah, just now ;)
22:48:49 <sjanssen> dons: yes, Haskell is the finest imperative language
22:48:50 <jcreigh> haskray: see you around. Happy hacking.
22:48:54 * LoganCapaldo woulda expected dons' to decide that long ago
22:48:57 <haskray> jcreigh: thanks
22:49:50 <ddarius> dons: It is convenient not to have to "thunk" such things.
22:50:12 <ddarius> Makes making imperative controls structures much cleaner.
22:50:17 <sjanssen> if C is an imperative language, then why aren't actions first class values? ;)
22:50:59 * ddarius doesn't consider HOFs a requisite for a language to be "functional".
22:57:02 <ddarius> I guess another reason for the generally inward flux of the Haskell community is that most people don't arrive here without first going through several other languages.
23:02:11 <jql> from my experience, that's true
23:02:30 <jql> never seen someone use Haskell as their first *or* second language. :)
23:02:39 <MP0> is there a way to declare a data type in a let statement? I've tried "let data AAA = A | B | C deriving (Eq, Ord) in (A<B)"
23:03:10 <emu> no
23:04:13 <dons> jql, it was my first language :-)
23:04:23 <ddarius> jql: Occasionally if they get it in a university.
23:04:35 <dons> and thousands of others at unsw, actually. or chalmers, or oxford, or ...
23:04:39 <MP0> is there a reason why that's not possible?
23:04:55 <ddarius> dons: In my experience, they tend not to be the ones that stay.
23:04:57 <jql> is there an inverse first-language-BASIC rule in effect? does learning haskell first cripple you with regard to learning more primitive languages? :)
23:05:05 <dons> MP0, types (which is what you're declaring), are at the top level of a module
23:05:13 <dons> ddarius: that's true.
23:05:18 <sjanssen> MP0: it's a little tricky, what is the type of "let data A = A in A"?
23:05:59 <MP0> hmm, I was hoping if it derived Ord, it would be 0 or 1
23:06:08 <dons> if you derive Enum
23:06:11 <dons> > fromEnum True
23:06:13 <lambdabot>  1
23:06:14 <MP0> sorry, Enum
23:06:14 <jql> Every Haskell program I've written feels more like writing a maths proof than an imperative progrem
23:06:17 <dons> > fromEnum LT
23:06:18 <lambdabot>  0
23:06:27 <dons> jql, maybe you write the wrong kind of haskell program?
23:06:35 <jql> I can't picture going from that to... say, VB
23:06:41 <siti> write a gui app :D
23:06:44 <ddarius> jql: You are writing a logical proof.
23:06:45 <jql> no, I meant that in the good way. :)
23:07:03 <dons> here's some imperative haskell :-) http://www.cse.unsw.edu.au/~dons/code/nobench/bin/bench.hs
23:07:03 <ddarius> That said, writing Haskell feels like neither to me.
23:07:15 <dons> (that's a testsuite driver)
23:07:20 <dons> quick hack
23:07:25 <jql> I don't want to write another kind of Haskell program. I'm trying to escape the finger-diarrea of other languages
23:07:26 <araujo>  hello
23:08:12 <siti> enough indentation?
23:08:19 <dons> just a little
23:08:42 <dons> just to say, you can hack perlish scripts in haskell too ;) but they'll have data types in them
23:08:47 <sjanssen> MP0: I think the answer to your question is a cost vs. benefit issue.  Let scoped data decls are rarely (never?) needed, and they'd be quite complicated to describe in the standard
23:09:19 <MP0> ah. My only issue is that it makes it impossible to play with in ghci
23:09:26 <MP0> so I've changed over to writing into a text file
23:09:50 <sjanssen> MP0: that is the recommended workflow with ghci or hugs
23:10:19 <sjanssen> type the definitions in a file, then :load the file and explore
23:10:47 * ddarius doesn't say something about Church encoding data types into functions...
23:11:13 * LoganCapaldo doesn't say something about throwing the baby out with the bathwater
23:11:51 <MP0> (Inc (Inc (Inc (Inc Zero))))
23:30:35 <slava> @protontorpedo
23:30:35 <lambdabot> or does it become a mishmash of code?
23:30:41 <slava> @protontorpedo
23:30:41 <lambdabot> I am banned from like 6 rooms
23:30:44 <slava> @protontorpedo
23:30:45 <lambdabot> I had one guy tell me he was 16x as fast to develop something in smalltalk
23:30:55 <slava> sorry for the spam, i had to see this in action :)
23:31:30 <slava> gavino drops by #forth once in a while
23:38:17 <dons> slava: yeah that's him
23:42:55 <kc5tja> Hey, I just got back from an evening of celebrating, and look what I find in here.  ;D
23:42:59 * kc5tja waves to Slava
23:43:19 <kc5tja> Anyway, I'm heading to bed.  I need to sleep off the Tequilla.  :)
23:43:29 <slava> heh. sweet dreams
