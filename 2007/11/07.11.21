00:00:13 <int-e> Pascal uses semicolons as statement separators, so with a semicolon you have at least two statements in the row. on the other hand, pascal only allows one statement between then and else.
00:00:14 <lambdabot> int-e: You have 1 new message. '/msg lambdabot @messages' to read it.
00:00:22 <lament> i think it's been proven without a doubt that newlines work best as statement separators, anyhow :)
00:00:35 <int-e> I wonder if that's accessible to beginners
00:00:38 * osfameron boils lament in carrot juice
00:01:31 <lament> int-e: i think it should be, as long as you clarify what a "statement" is.
00:01:40 <firefly> "How many ways to skin a cat?  Let me count the ways." (apologies to Elizabeth BB)
00:01:48 <firefly> lament: I can tell you that it is not.
00:02:27 <dons> lament: definitely proven. beyond a doubt :)
00:02:31 <firefly> It is one of the most inaccessible parts of Pascal, that and the rest of the dangling else problem.  Wirth fixed it in Modula.
00:03:02 <lament> firefly: i dunno, i think i could explain that to anybody.
00:03:08 <firefly> ever tried?
00:03:13 <lament> (who has any hope of being a programmer)
00:03:18 <lament> no
00:03:24 <firefly> I have.
00:03:32 <firefly> To many.
00:04:16 <lament> you taught pascal to a class?
00:04:44 <lament> that's different, i'm not sure i could explain it to a class.
00:05:28 * wli just wants the scars of H98 erased but doesn't have the time or mental composure or probably even intelligence to deal with it.
00:06:52 <firefly> not to classes but to smaller groups -- and I've watched it being taught to many, both as groups and as individuals.  The semicolons get them.  C got that one right.
00:07:28 * osfameron is too used to semicolons being optional at the end of a block, so gets bitten by C...
00:08:38 <lament> i'm just glad there's python, in case i ever need to teach somebody programming :)
00:09:14 <firefly> I might end up teaching Bright Nephew Forth -- I hope :)
00:09:30 <lament> no previous programming experience?
00:11:27 <firefly> none.  He's just turned twelve.
00:11:52 <lament> mm. forth. :)
00:11:57 <goalieca> lament, python is the new basic
00:11:57 <firefly> he likes math and weird things.  His favourite band is Deep Purple :)
00:12:09 <goalieca> deep purple? wow. he's awesome
00:12:15 <firefly> yup!
00:12:43 <lament> teach him dancing and talking to girls, or he'll end up like me :)
00:13:23 <firefly> I dunno about dancing but I think he'll do quite well with the girls.  He's been playing electric guitar for a while ;)
00:14:09 <goalieca> social skills are very important. math can come later :-)
00:14:23 <firefly> he's got those, don't worry.
00:19:06 <glguy> ?seen dons
00:19:06 <lambdabot> dons is in #haskell, #ghc and #xmonad. I last heard dons speak 15m 3s ago.
00:42:20 <coderdave> I'm having trouble understanding a part of this haskell tutorial. It says add x y = x + y, and that it it has the for add e1 e2, and is equivalent to (add e1) e2, I don't understand this
00:42:34 <coderdave> *it has the form
00:43:01 <sjanssen> which part do you find confusing?
00:43:26 <Spark> add e1 e2 is two things, just like x + y + z is two things
00:43:27 <coderdave> how (add e1) can be evaluated
00:43:34 <Spark> consider add x = \y. x + y
00:43:37 <osfameron> > let { add x y = x + y; add5 = add 5 } in add5 10
00:43:42 <dons> > let add x y = x + y in     let f =  add 3   in [ f 1 , f 2 , f 3 ]
00:43:44 <lambdabot>  15
00:43:44 <lambdabot>  [4,5,6]
00:44:08 <dons> so you can partially apply add, yielding a function with one argument already filled in
00:44:52 <sjanssen> coderdave: in Haskell, all functions take exactly one argument
00:44:56 <coderdave> dons, so it doesn't really evaluate the expression it just puts a value in one of the arguements
00:45:08 <Spark> basically yeah
00:45:37 <coderdave> thats wierd, i think im missing something fundamental still
00:46:09 <Spark> probably an understanding of functions as values? :)
00:46:35 <sjanssen> coderdave: internally, for "add e1", the compiler will allocate a lambda function, something like "\x -> add e1 x"
00:46:39 <dons> and that functions can be applied to less than all of their arguments
00:47:17 <dons> add x y = x + y ---> add = \x -> \y -> x + y   , basically. its just syntax for nested lambdas
00:47:27 <dons> so then if you start applying this \x -> \y -> x + y thing
00:47:33 <coderdave> i get it
00:47:35 <dons> to arguments, you yield new functions
00:47:42 <coderdave> the first function restricts the domain of the second
00:47:54 <dons> ( \x -> \y -> x + y ) 3 -->  (\y -> 3 + y)
00:48:43 <coderdave> im not quite sure what the \x syntax is but i understand the nested lambdas part
00:48:44 <dons> so we'd say, the first application of the function creates a closure, which tracks that x=3 in the local environment
00:49:11 <dons> oh, that's a lambda, an anonymous function
00:49:17 <dons> > (\x -> x + 2)   7
00:49:19 <lambdabot>  9
00:49:29 <firefly> coderdave: maybe it helps if you view functions as sets?
00:49:52 <firefly> A function can be viewed as a set of pairs, where the first element in the pair is the "input" and the other element is the "output".
00:49:57 <Spark> why would you want to do that?
00:50:02 <firefly> Some sets are infinite, of course.
00:50:33 <coderdave> spark, because when you create that first lambda function its a constraint of the input to the next function, so you are creating a set?
00:50:40 <firefly> So the operator + can be viewed as a function of two parameters, two inputs.
00:50:50 <coderdave> so i think that makes sense
00:50:58 <firefly> The elements in the corresponding set look like ((x,y), sum).
00:51:25 <firefly> The partial application/currying turns that set into another set where the elements look like (y, sum).
00:51:51 <coderdave> man, haskell is fun :)
00:51:51 <firefly> Functions are just sets, in abstract math.
00:52:12 <dons> coderdave: so yes, as you say, the arguments are just slots. applying a function to one argument just fills in that slot, yielding a new function with the argument bound in the old environment
00:52:14 <Spark> i still don't see why there was any reason to bring maths into a discussion about programming languages
00:52:43 <sjanssen> Spark: math and programming languages have everything to do with each other
00:52:43 <Spark> programmers are perfectly happy with the idea of a function without having to have it defined in terms of sets
00:52:46 <coderdave> spark, because functions that map input to output are based on math..
00:53:00 <Spark> sjanssen: only by analogy
00:53:04 <firefly> a function *is* math, after all.
00:53:07 <sjanssen> Spark: no, by fact
00:53:09 <dons> maybe i'm weird, but i find it helpful to think in terms of scope and bindings
00:53:17 <Spark> sjanssen: how long did it take to figure out semantics of programming languages? :)
00:53:31 * araujo agrees about dons be weird
00:53:32 <sjanssen> Spark: and shame on the world for making you think otherwise :)
00:53:44 <sjanssen> dons: I often think about things in terms of scope too
00:53:49 <firefly> Spark: we had a lot of it in the seventies (Floyd-Hoare)
00:53:49 <Spark> the binding of maths and programmign languages is entirely artificial
00:53:52 <andyjgill> Does anyone know what this function is called? funny xs ix a = [ if ix' == ix then a else a' | (a',ix') <- zip xs [0..]]
00:54:26 <sjanssen> @type Data.List.lookup
00:54:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:54:35 <Spark> and anyway, there are important differences
00:54:36 <dons> its a split and find?
00:54:38 <sjanssen> @type Data.List.findIndex
00:54:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
00:54:44 <andyjgill> funny :: (Num t, Enum t) => [a] -> t -> a -> [a]
00:54:47 <Spark> a haskell function can do things like not terminate
00:54:47 <sjanssen> bah
00:54:51 <dons> > elemIndex 'x' "haskell x x fun"
00:54:52 <lambdabot>  Just 8
00:54:53 <sjanssen> @type Data.List.elemIndex
00:54:53 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
00:55:08 <firefly> so can functions in math.
00:55:13 <andyjgill> I would expect this to be in the Prelude, its the opposite of !!
00:55:14 <sjanssen> andyjgill: elemIndex, modulo Maybe/[]
00:55:24 <firefly> series don't have to converge, etc.
00:55:28 <dons> andyjgill: splitting up lists is too expensive to be in the prelude :)
00:55:32 <Spark> a series isn't a function
00:55:43 <sjanssen> oh, not quite
00:55:45 <firefly> ¡¡ ?
00:55:49 <Spark> at best you can say a partial function
00:56:30 <andyjgill> dons: only for an inferior deforestation scheme
00:56:36 <dons> oh, not elemIndex, just conditionally replace
00:56:39 <sjanssen> Spark: there are mathematical models for divergance too
00:56:48 <sjanssen> Spark: have you heard of lambda calculus?
00:56:53 <dons> > splitAt 4 "haskell"
00:57:00 <Spark> the lambda calculus is not a set of pairs
00:57:02 <lambdabot>  ("hask","ell")
00:57:10 <firefly> It's pretty fundamental for math (or can be) :)
00:57:11 <Spark> the lambda calculus was what we were talking about in the first place, before someone mentioned sets of pairs
00:57:42 <Spark> i'm perfectly happy with the lambda calculus to be used as a model for functions as defined in a programming language
00:57:49 <firefly> Same thing holds for sets -- and my description *is* how functions are constructed from sets.
00:57:58 <Spark> at least for explanation purposes
00:58:27 <andyjgill> > (\ xs n a -> take (n-1) xs ++ [a] ++ drop n xs) "Haskell" 4 '*'
00:58:29 <lambdabot>  "Has*ell"
00:58:36 <Spark> ok, how do you represent (λx.xx)(λx.xx) as a set
00:58:56 <coderdave> spark, what is that notation (just curious)
00:59:03 <Spark> the lambda calculus
00:59:05 <firefly> lambda calculus
00:59:16 <coderdave> what does that expression evaluate to?
00:59:20 <Spark> tiself
00:59:21 <firefly> (two K combinators, if I'm not mistaken)
00:59:21 <Spark> itself
00:59:40 <Spark> > (\x => x x) (\x => x x)
00:59:41 <lambdabot>  Parse error at "=>" (column 5)
00:59:42 <sjanssen> andyjgill: are you terribly concerned about efficiency?
00:59:46 <Spark> forgotten the syntax
00:59:53 <Spark> > (\x -> x x) (\x -> x x)
00:59:55 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
00:59:55 <lambdabot>     Probab...
00:59:58 <Cale> type error :)
01:00:01 <andyjgill> sjanssen: not really. clarity is the important thing
01:00:02 <Spark> self application
01:00:02 <Spark> pwned
01:00:10 <Spark> can you give it an annotation?
01:00:17 <dons> > (\xs n c -> let (a,x:b) = splitAt (n-1) xs in a ++ c : b) "Haskell" 4 '*'
01:00:19 <lambdabot>  "Has*ell"
01:00:20 <quicksilver> you have to explicitly name the type
01:00:32 <quicksilver> haskell only permits infinite types as named types
01:00:34 <Spark> > let I = (\x -> x x) in I I
01:00:34 <lambdabot>   Not in scope: data constructor `I'
01:00:38 <Cale> No, but you can construct a type which basically allows that to be typed.
01:01:16 <Spark> oops i'm thinking of let I = (\x -> x) in I I
01:01:35 <quicksilver> Spark: in haskell, uppercase identitfiers are types, constructors, or classes
01:01:38 <Spark> ah yes
01:01:43 <quicksilver> Spark: values have to have a lowercase first letter
01:02:08 <dons> ?users
01:02:08 <lambdabot> Maximum users seen in #haskell: 418, currently: 367 (87.8%), active: 12 (3.3%)
01:02:45 <coderdave> heh look at that the next section im reading is on lambda abstractions, should of waited before asking :)
01:03:11 <dons> :)
01:03:55 <Cale> (\x -> y) is simply the Haskell-function which takes x as a parameter and results in y.
01:04:27 <Cale> Well, or lambda calculus term, if you're talking about some lambda calculus :)
01:04:49 <Cale> So (\x -> x x) a = a a, for any term a
01:05:13 <Cale> (but it only makes sense without a type system)
01:05:16 <coderdave> what does a a even mean?
01:05:25 <Cale> It means the application of the term a to itself.
01:07:20 <Spark> it makes sense with a type system
01:07:26 <Spark> just only a powerful type system :)
01:07:42 <Cale> You'd have to admit infinite types.
01:07:50 <Spark> nah you can use intersection types
01:07:56 <Cale> In the pure lambda calculus, all you have are lambda terms, which can to a certain extent be thought of as functions from lambda terms to more lambda terms.
01:08:32 <quicksilver> Spark: "powerful" in the sense of "weak", yes
01:08:37 <Spark> the type of \x -> x x is  (1→1)∧(1) → 1
01:08:40 * kfish hands around some free variables
01:08:49 <quicksilver> Spark: a type system which gives types types to all syntactically valid terms is weak, not strong
01:09:05 <quicksilver> because it turns out not to be good at discriminating
01:09:19 <Spark> quicksilver: if you're talking about intersection types, then you misunderstand
01:09:33 <quicksilver> I can't see your unicode :)
01:09:45 <Spark> (1->1)&(1) -> 1
01:09:46 <Spark> i think
01:09:51 <Spark> it's been a few years
01:09:53 <quicksilver> but to type (\x -> x x) (\x -> x x) you need the type a@(a->a)
01:10:02 <Spark> you can't type that
01:10:06 <Spark> but you can type self application
01:10:11 <quicksilver> a@(a->a) is essentially 'all lambda calculus terms'
01:10:13 <quicksilver> which is fine
01:10:21 <quicksilver> but if you can type that, you can type anything
01:10:28 <Spark> infinite rank intersection types type only terminating terms, as the type inference is a model of execution
01:10:28 <quicksilver> so your typechecker stops showing you any errors :)
01:11:11 <Spark> but finite rank intersection types are decidable and still principal
01:11:37 <Spark> making them better than HM-based quantified types :)
01:12:12 <Spark> a->a is not all lambda calculus terms, e.g. K does not have that type
01:12:13 <andyjgill> Is there anyone from Nottingham here?
01:12:26 <Spark> therefore a & a->a is also not all lambda calculus terms
01:12:50 <Spark> andyjgill: i believe liyang is, perhaps you should stalk him
01:12:58 <Spark> i think he'd like that
01:13:27 <Spark> time for work
01:22:23 <timbod> Hi All
01:23:00 <quicksilver> Spark: K is a @ (a -> a) though
01:25:25 <timbod> @seen lemmih
01:25:25 <lambdabot> lemmih is in #haskell. I don't know when lemmih last spoke.
01:25:39 <dmwit> Hi timbod!
01:25:52 <timbod> Hi
01:26:49 <andyjgill> night guys
01:28:01 <timbod> Anyone about who's used haskell+sdl+opengl? I'm searching for some example code.
01:36:37 <Spark> quicksilver: no it's not, as it's not in a -> a
01:36:43 <Spark> intersection means it has to be both
01:36:58 <Spark> why do you keep using @
01:37:02 <Spark> is that supposed to be a union?
01:40:01 <quicksilver> Spark: I don't know what it's called. Maybe it is a union.
01:40:43 <quicksilver> it's a model of the (untyped) lambda calculus
01:40:47 <Spark> well i was talking about intersection :)
01:40:48 <quicksilver> everything can be applied.
01:40:58 <quicksilver> I know. I wasn't disagreeing, I was saying something different.
01:41:16 <quicksilver> a @ (a -> a) is the kind of type you get inferred if you use ocaml's rectypes extension, say
01:42:27 <EvilTerran> what does it mean, though?
01:44:10 <quicksilver> I believe it means data Foo = MkFoo ( Foo -> Foo )
01:44:41 <Spark> hmm
01:47:54 <quicksilver> intuitively it menas "everythign is a, and everythign is also a -> a, so you can apply everything to everything.
01:48:27 <quicksilver> or "the smallest type such that A == A -> A "
01:58:05 <ivanm> I _really_ hate java... I'm working on an assignment generator written in java, and atm I'm writing questions used for a combined 1st year math/programming course using python...
01:58:55 <ivanm> so I'm trying to go and represent basic python constructs, and I keep wishing I could use Haskell-like type sigs, or at the very least have classes (so that I can say the output of a function is of type (Num a) => a) :s
01:59:05 <faxathisia> ivanm: There are various languages which compile to java or are written as interpreters in java
01:59:13 <ivanm> I _have_ to use java
01:59:19 <ivanm> since they want to reduce dependencies
01:59:21 <faxathisia> yes.. that's why I suggested those
01:59:51 <ivanm> and don't want to require users wanting to extend this later on, etc. have to have anything except java + LaTeX
02:00:17 <ivanm> because this project is meant to be released under the gpl..
02:00:30 <ivanm> doesn't help when the lead programmer who wrote the engine isn't much of a programmer :s
02:00:52 <ivanm> he chose Java not because he knows it, but because its nicer than C (which the original prototype was written in)
02:01:03 <ivanm> well, anyway, that's my rant of the day done :p
02:07:13 <faxathisia> I can't believe it's -still- fashionable to hate java
02:07:22 <wli> Why wouldn't it be?
02:11:25 <faxathisia> there is enough tools in the language to metaprogram yourself away from anything you don't like
02:11:41 <Cale> It's still hideously verbose and unsafe though.
02:13:35 <timbod> Can someone point me to a cabal file that works under ghc-6.6.1 and ghc-6.8.1, and handles the dependences on the split base?
02:16:27 <liyang> Spark: face.
02:20:46 <firefly> I'm trying to build the darcs version of ghc -- it complains about a missing lockFile.h during install.
02:20:56 <firefly> Does anybody know where it's supposed to come from?
02:31:43 <timbod> firefly, I've build from the tar.gz source a fair bit, but not from darcs.... and haven't seen that problem.
02:32:17 <firefly> a simon just helped me in #ghc, says it's his fault :)
02:35:27 <timbod> there's only two isn't there?
02:38:29 <ketil_> @seen dons
02:38:33 <lambdabot> dons is in #haskell, #ghc and #xmonad. I last heard dons speak 1h 35m 21s ago.
02:47:06 <firefly> I don't know how many there actually are but you can at most observe two of them at a time, I think.
02:48:52 <doserj> there is also simon thompson, author of "the craft of functional programming"
02:52:10 <firefly> but is he /a/ simon or just a Simon?
02:53:28 <Sizur> Hajax. who's the project leader? i need to contribute.
03:05:05 <cedricshock> Why do I get Not in scope: type variable `a':?
03:05:07 <cedricshock> listmap_lookup :: (Ord k) => k -> ListMap k a -> [a]
03:05:07 <cedricshock> listmap_lookup k lm =
03:05:07 <cedricshock>    let m::(Maybe [a]) = Map.lookup k lm in
03:05:07 <cedricshock>       case m of
03:05:07 <cedricshock>          Nothing -> []
03:05:08 <cedricshock>          Just a  -> a
03:06:38 <cedricshock> Nevermind, ghc can figure out the type from the Nothing and Just.
03:08:05 <doserj> cedricshock: if you still care, you need to use an explicit forall a in the type signature of listmap_lookup to bring a into scope
03:09:04 <cedricshock> doserj: So that's what forall does. I was wondering what it did in the monad bind type definitions. Thanks.
03:09:30 <TSC> Is that enough?  I thought you had to give the "scoped type declaration" flag too.
03:10:05 <doserj> TSC: of course you also need LANGUAGE ScopedTypeVariables, or similar, but without that, you get another error msg :)
03:10:54 <TSC> cedricshock: You might also be interested in Data.Map.findWithDefault
03:11:38 <cedricshock> TSC: Thanks. I looked for something like that, but there are a LOT of Data.Map functions...
03:11:45 <quicksilver> :t fromMaybe
03:11:46 <lambdabot> forall a. a -> Maybe a -> a
03:11:54 <quicksilver> cedricshock: or the generic fromMaybe combinator, perhaps
03:12:04 <quicksilver> fromMaybe [] (Map.lookup k lm)
03:12:23 <TSC> Yeah, findWithDefault is just lookup + fromMaybe
03:12:57 <cedricshock> Thanks quicksilver, TSC.
03:13:27 <quicksilver> I don't think fromMaybe is a very good name, thoughg :(
03:13:37 <quicksilver> it doesn't aid code readability IMO
03:13:45 <quicksilver> so for that reason I prefer findWithDefault
03:13:57 <doserj> Data,Map.lookup returns m a, for any monad m. There should be no need for converting from Maybe, just use [] directly
03:14:03 <quicksilver> (I think fromMaybe should be called maybeWithDefault or maybeOrDefault)
03:14:21 <quicksilver> doserj: that will get him [a] instead of a
03:14:24 <quicksilver> doserj: if it's found
03:14:39 <quicksilver> well the value [a] instead of a, the type [[a]] instead of [a]
03:14:43 <doserj> ok
03:14:46 <quicksilver> with apologies for overloading of a ;)
03:15:40 <faxathisia> Do you ever use a monad for an interpreter?
03:15:50 <faxathisia> so you can do things in an imperative way
03:15:59 <doserj> now i understand what "ListMap k a" should mean :)
03:16:04 <timbod> Any hackage users about?
03:16:09 <faxathisia> like do ctx <- evalute ctx exp1 ; ctx <- evaluate ctx exp2
03:16:17 <timbod> (ie package creators, not downloaders)
03:16:23 <faxathisia> as opposed to evaluate (evaluate ctx exp1) exp2
03:16:38 <faxathisia> or like some other method?
03:16:48 <pejo> faxathisia, there's a tutorial about writing interpreters with monad transformers.
03:16:52 <cedricshock> Woohoo! I have a (highly impractical) type-safe accounting system. Every Ledger always balances!
03:17:03 <faxathisia> pejo: About logic programming?
03:17:05 <faxathisia> or something else
03:17:29 <pejo> @google writing interpreter monad transformer site:.de
03:17:30 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
03:17:36 <pejo> Probably that one, I think.
03:17:41 <faxathisia> ah nice
03:17:45 <faxathisia> thanks a lot, haven't seen this
03:31:55 * SamB_XP is tempted to pun badly
03:32:01 <faxathisia> that was fantastic
03:41:33 <faxathisia> gmf Operational semantics as type charts confuse me
03:41:59 <faxathisia> looks like the diagram and the text say different things
03:50:19 <hpaste>  firefly pasted "ghc darcs, w/-fregs-graph" at http://hpaste.org/4019
04:07:51 <cedricshock> I have an pattern in the design of programs that I'd like to extract out that's important to optimizations. It's sort of state advancement of parallel states, or something of the sort.
04:08:52 <cedricshock> I have two types, a and b, and functions f(a) and g(b) and a map from a to b, b = m(a).
04:09:28 <hrehf_> morning
04:09:51 <cedricshock> The relevant property here is that m(f(a)) is somehow equivalent to g(m(a)).
04:12:03 <pejo> cedricshock, do you want to rewrite one to another?
04:12:08 <cedricshock> I'm sure this is one of the many "morphisms", and I'm guessing that it can best be represented in haskell as either a class or maybe more specifically a monad.
04:13:39 <faxathisia> so m.f == g.m
04:13:43 <cedricshock> pejo: In practical terms the assumption is that m is expensive, and f and g are cheap. I'm going to use g to calculate m(f(a)) as g(m(a)) whenever f is applied to a,
04:13:55 <cedricshock> faxathisia: exactly.
04:17:09 <cedricshock> Now f and g can be seen as equivalent state transitions, applied to the equivalent states a and b. What I'd like is a framework for distributing the various state transitions (these could be functions on a class) among the various types that are emulating each other.
04:17:57 <cedricshock> I can even provide a default implementation (if there is some authoritative type) in terms of m().
04:21:11 <cedricshock> Or if a possible history of applications of functions such as f is function of a back to some null value (not as unbelievable as it sounds) I can provide m as a function of f and g.
04:24:42 <cedricshock> What I described is a homomorphism from a to b.
04:26:47 <matthew_-> so, what's the record length of time for getting ghci to type check something ?
04:27:34 <matthew_-> because I'm at 19.3 hours now...
04:28:02 <SamB_XP> matthew-_: without segfaulting? wow!
04:28:10 <matthew_-> yep
04:28:12 <SamB_XP> or stack blowing or anything
04:28:18 <matthew_-> memory use seems stable
04:28:43 <matthew_-> Just doing: > :t  testAdd (D1 (D5 (D4 (D8 E)))) (D9 (D3 (D2 E)))
04:28:54 <matthew_-> (base10 maths in the type system)
04:29:18 <faxathisia> :D
04:29:24 <faxathisia> why is it taking so long
04:29:36 <matthew_-> type systems aren't very good at maths?
04:29:41 <integral> much more sensible than checking primality of base-1 numbers in the type system
04:29:47 <opqdonut> :D
04:29:47 <SamB_XP> maybe you should stick with powers-of-two based systems?
04:30:23 <SamB_XP> base 1... is that like "1111" -> 4?
04:30:28 <matthew_-> integral: you sound like you speak from experience!
04:30:41 <integral> I never really got it working because it used too much RAM :-(
04:30:54 <opqdonut> :/
04:30:56 * wli thinks it looks vaguely decimal.
04:31:52 <matthew_-> you don't mean base 1 do you? You mean unary / peano numbers right?
04:31:56 <SamB_XP> someone already wrote power-of-2 based type arithmatic that works, iirc
04:32:01 <desp> matthew_-: wow.
04:32:12 <desp> That's a whole new definition of insanity.
04:32:13 <SamB_XP> matthew-_: well, it seems like that's the same thing
04:32:17 <integral> matthew_-: hrm, you say they're different?  I mean the latter
04:32:36 <SamB_XP> matthew-_: unless you know otherwise?
04:32:45 <matthew_-> well, we're currently arguing about this in the office
04:32:53 * matthew_- turns on the office mic to irc proxy
04:32:55 <wli> Oleg wrote decimal type arithmetic.
04:32:57 <Spark> WANK
04:33:10 <matthew_-> yep, he's in our office
04:33:10 <faxathisia> what
04:33:10 <SamB_XP> matthew-_: well, I think they are the same
04:33:15 <SamB_XP> but I have to go to school now
04:33:33 <matthew_-> well, in base 2, you have 2^0, 2^1, 2^2, 2^3 as your columns right?
04:33:41 <faxathisia> in base 1 you can only express a single number
04:33:50 <matthew_-> yes, that's what I'm getting at
04:33:58 <SamB_XP> oh... true...
04:34:06 <SamB_XP> I forgot about that part :-(
04:34:09 <faxathisia> well we can define base 1 as '1111' = 4 as a special case
04:34:15 <matthew_-> cheats!
04:34:16 <Spark> it would use 0, not 1
04:34:19 <SamB_XP> heh
04:34:21 <faxathisia> since that's a more interesting number system
04:34:23 <matthew_-> you're just off by one Spark
04:34:23 <SamB_XP> byes
04:34:23 <Spark> 0 to n-1 where n is 1
04:34:30 <Spark> no, you are :)
04:34:38 <faxathisia> Spark: as a special case
04:34:38 <matthew_-> I'm one more than you :p
04:34:41 <Spark> so you can only represent 0
04:34:46 <matthew_-> yes
04:34:53 <faxathisia> Spark: Yes but you can define base 1 as '1111' = 4 as a special case
04:34:56 * matthew_- turns off the office mic to irc relay
04:34:56 <cedricshock> With 0 it's more obvious that base 1 can only describe a single number, since we are familiar with 00 == 0 == 0000, etc.
04:35:10 * integral sees now
04:35:35 * Spark blinds integral
04:35:52 <Spark> it's for your own good
04:36:23 <hpaste>  matthew-_ pasted "the code that started it all..." at http://hpaste.org/4020
04:36:55 <matthew_-> anyway, that's the code. You need -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances. And it's clean-room - it may well be the same as Oleg's but it may also be different.
04:37:10 <matthew_-> it's faster for smaller sums. It's just not really linear
04:37:38 <faxathisia> What is clean-roon?
04:38:03 <wli> Oleg's was much fancier.
04:38:20 <hrehf> hmm, how do i use the ShowS function i get from most of the specialised show functions (e.g. http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Numeric.html#v%3AshowFFloat) ? giving it an empty String to concatenate to didn't work :( (my call is something like '((showFFloat) f [])' )
04:38:21 <lambdabot> http://tinyurl.com/2e2psz
04:38:27 <cedricshock> What I described is also, I believe, a Functor.
04:38:43 <sieni> faxathisia: http://en.wikipedia.org/wiki/Clean_room_design
04:38:44 <lambdabot> Title: Clean room design - Wikipedia, the free encyclopedia
04:39:38 <quicksilver> :t showFFloat
04:39:40 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
04:39:51 <quicksilver> showFFloat 4 4.5 []
04:39:55 <quicksilver> > showFFloat 4 4.5 []
04:39:56 <lambdabot>   add an instance declaration for (Num (Maybe Int))
04:40:06 <quicksilver> > showFFloat (Just 4) 4.5 []
04:40:10 <lambdabot>  "4.5000"
04:40:14 <quicksilver> hrehf: like that
04:40:51 <hrehf> oh, i incorrectly remembered what Maybe did :(
04:41:01 <hrehf> thank you :)
04:41:10 <faxathisia> > showFFloat Nothing 4.5 []
04:41:11 <lambdabot>  "4.5"
04:41:15 <faxathisia> oh ok
04:41:29 <hrehf> yay, that worked ;)
04:44:12 <cedricshock> The properties of a Functor described in the prelude are what this homomorphism is if I can deduce m.
04:45:39 * SamB_XP wonders why he has a stomache ache now...
04:46:37 <Sizur> what's the point of type-level arithmetic anyway? just because we can?
04:46:53 <SamB_XP> Sizur: there's more to it than that ;-)
04:48:20 <cedricshock> No, It's a Functor if I can use /any/ m. That would be a nice property to have. But Haskell's Functor is from a type f back to a type f.
04:49:10 <quicksilver> cedricshock: haskell's Functor is from a type "a" to a type "f a"
04:49:48 <twanvl> haskell's functor is from the category Hask/(->) to the category Hask/(->)
04:50:00 * SamB_XP decides, since he has already missed his first class (which is about to start), that he might as well have another cup of peppermint tea
04:51:02 <cedricshock> quicksilver: Almost, and I'm being stupid (since I know list is a functor). It's a Functor from "f a" to "f b".
04:55:50 <quicksilver> cedricshock: ? Haskell Functors are from "a" to "f a".
04:56:31 <cedricshock> class Functor f where
04:56:42 <SamB_XP> got any actual code?
04:56:43 <cedricshock>    fmap :: (a -> b) -> f a -> f b
04:57:05 <cedricshock> (but I'm not real clean on category theory).
04:57:05 <quicksilver> cedricshock: yes, so "f" itself is a functor, and it takes "a" to "f a"
04:57:29 <quicksilver> categorically "f" is a functor from Hask to Hask, but I was describing its effect pointwise
04:57:38 <quicksilver> which is a reasonably common abuse of notation :)
05:09:35 <hpaste>  cedricshock pasted "Example of where homomorphisms could be beneficial" at http://hpaste.org/4021
05:13:18 <quicksilver> cedricshock: that's quite a lot like a Monoid
05:13:43 <quicksilver> cedricshock: it's a Monoid together with some implicit injection like "singleton" or "pure"
05:14:24 <cedricshock> quicksilver: I almost typed, ignoring the fact that this is a Monoid... I'm wondering if all homomorphisms are monoids in some sense...
05:14:57 <quicksilver> all things with a binary operation can be factored through monoids
05:15:06 <quicksilver> monoids are 'universal' for binary operations
05:16:50 <MyCatVerbs> @pl (\a b-> 1 == (gcd a b))
05:16:50 <lambdabot> ((1 ==) .) . gcd
05:17:07 <cedricshock> quicksilver: All? What about semigroups, quasigroups, magmas, and loops?
05:18:47 <quicksilver> cedricshock: you can factor them through monoids, yes
05:19:03 <quicksilver> cedricshock: well I should have said 'associative'
05:19:28 <quicksilver> cedricshock: so not magmas, no :)
05:23:33 <cedricshock> It's almost like the only hard part of this is the "event dispatching", which may well be a Monad. How can I make a type that's say a tuple or list of types all of the same class, and guarantee that the same class functions are called on all the elements of the tuple (i.e. hide access to setting the values in the tuple).
05:27:09 <quicksilver> cedricshock: I'd newtype a list
05:27:25 <quicksilver> cedricshock: newtype ManyFoo a = [a]
05:27:33 <quicksilver> cedricshock: then instance that whole newtype in a class
05:27:47 <quicksilver> instance Foo a => Foo (ManyFoo a)
05:27:55 <quicksilver> cedricshock: with 'pointwise' application of methods
05:28:16 <quicksilver> ..where bar = map bar
05:28:25 <quicksilver> give or take newtype destruction and construction
05:28:36 <quicksilver> and the fact that I forgot to name the constructor, as always
05:29:11 <LoganCapaldo> eh the compiler will just throw that ctor away anyway
05:29:39 <LoganCapaldo> its name is unimportant :)
05:30:23 <quicksilver> :)
05:31:20 <cedricshock> quicksilver: Dispatching the events it I quess another easy part. I had already thought of making another instance of the class. The hard part is guaranteeing nothing but the events happens. I guess this can probably be done with a monad and using a data type for the events. I'll just need to think about it more...
05:32:43 <LoganCapaldo> cedricshock: depending on what you mean by guranteeing nothing but the events happen, you might be able to do that just by making your data type abstract (ie no exporting constructor etc.)
05:34:43 <LoganCapaldo> then consumers can't pattern match on your values or construct their own modified versions of your values w/o going through your interface
05:34:55 <cedricshock> LoganCapaldo: Thanks. I'll think about that as a possibility.
05:37:13 <cedricshock> I don't care if they pattern match on it, or extract things individually. I only care that they don't update part of the data structure without updating the other. (I want to guarantee it stays synced). Too bad taking away the constructor takes away both.
05:38:25 <quicksilver> cedricshock: you can't update data structures. This is haskell.
05:38:32 <quicksilver> cedricshock: all you can do is build new ones :)
05:39:43 <cedricshock> quicksilver: I know. I know all I have to do is keep control over construction. I never want someone to write the function:
05:40:04 <cedricshock> f (Synced a b) = Synced (g a) b
05:40:12 <cedricshock> I have no problem if they write:
05:40:26 <cedricshock> f (Synced a b) = (g a)
05:40:54 <quicksilver> yes, this is a slight wart which has been remarked before
05:41:08 <quicksilver> that pattern-matching and construction are linked.
05:41:30 <osfameron> isn't that a good thing?
05:42:19 <quicksilver> it's annoying that you can't export one without the other, osfameron
05:42:32 <quicksilver> to permit pattern matching but forbid construction, or vice versa
05:47:41 <osfameron> quicksilver: ah, ok.  Isn't that what the unidirectional monads (IO etc.) achieve ?
05:48:48 <quicksilver> osfameron: in a sense, yes, but this isn't only a monad issue
05:49:00 <quicksilver> osfameron: and you will notice they hide their constructor entirely.
05:49:16 <quicksilver> osfameron: there are cases where you want to prevent construction but not pattern matching.
05:49:23 <LoganCapaldo> synced :: Synced a b -> (a -> b -> c) -> c
05:49:49 <LoganCapaldo> actually flip that type
05:49:50 <osfameron> quicksilver: ok, that sounds reasonable
05:49:55 <LoganCapaldo> and aname it syncapply
05:50:15 <LoganCapaldo> f `syncapply` (Synced a b)
05:50:22 <LoganCapaldo> wordy yes
05:50:24 <Feuerbach> Can ghc optimize several calls to the same function w/ same args?
05:51:07 <LoganCapaldo> sort of an upside dowbn monad
05:51:22 <LoganCapaldo> you can get values out but not put them in <g>
05:51:26 <hrehf> hrm, i need to average a [Float] : (foldl1 (+) fs) / length fs complains about Float/Int division, what do i do? can i cast to Float ?
05:52:17 <LoganCapaldo> // fromIntegeral (length fs)
05:52:20 <LoganCapaldo> err
05:52:23 <LoganCapaldo> oonly one /
05:52:24 <cedricshock> Feuerbach: do you mean something like this: "f a = (g a) + (g a)" or memoizing in general, or what?
05:52:31 <doserj> this should really be stated on http://www.haskell.org/haskellwiki/FAQ :)
05:52:32 <lambdabot> Title: FAQ - HaskellWiki
05:52:39 <LoganCapaldo> @ hrehf
05:52:55 <LoganCapaldo> @quote fromIntegral
05:52:55 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
05:53:06 <LoganCapaldo> (or Float)
05:53:06 <hrehf> LoganCapaldo ah, i wouldn't have thought of searching for a function of that name ;)
05:53:08 <hrehf> thanks
05:53:19 <LoganCapaldo> welcome
05:53:56 <quicksilver> hrehf: there are 3 general purpose numeric 'cast' functions you need to know about
05:54:05 <quicksilver> hrehf: fromIntegral, realToFrac and round
05:54:13 <quicksilver> most of the time they cover everything you need.
05:54:29 * hrehf tries to remember
05:56:54 <LoganCapaldo> oh wait
05:57:29 <LoganCapaldo> I totally cam up with a "solution" to the pattern match problem a while ago when I was having a similar conversation
05:57:43 <quicksilver> you can solve it with views
05:57:58 <quicksilver> having a proxy data type which you do export the constructor of
05:58:07 <LoganCapaldo> naw it was more mundance than that :)
05:58:13 <LoganCapaldo> yeah the second one :)
05:58:16 <LoganCapaldo> basically
05:58:59 <cedricshock> LoganCapaldo: I guess I can do it in one if I do data UnSynced = UnSynced a b, define unsync (Synced a b) = UnSynced a b, and only export UnSynced. Anyone getting in needs to make and destroy a tuple though... maybe your function is better.
06:00:46 <quicksilver> cedricshock: that's precisely what I meant by a proxy view data type
06:01:45 <LoganCapaldo> cedricshock: mine looked something like data Synced a b = Synced a b ; newtype DontExportMe a b = S (Synced a b) ; You wouldn't export S and you'd have a function to get things out of S so you could pattern match them
06:03:07 * LoganCapaldo is lazy and wouldn't want to duplicate all the constructors <g>
06:03:16 <cedricshock> LoganCapaldo: Yeah. I can "don't repeat myself" if I do it backwards like that. Synced is then just a special marker on UnSynced
06:03:21 <Feuerbach> cedricshock: yes, I mean automatic memoizing
06:04:48 <cedricshock> Feuerbach: What do you wan't to memoize? It's frequently as easy as writing the program lazily. Automatic memoizing could be done in a functional style with maps, has anyone done this?
06:05:17 <quicksilver> Feuerbach: it looked to me like you just meant CSE
06:05:22 <quicksilver> ghc doesn't do very much CSE
06:05:37 <quicksilver> but you can do it yourself with let foo = ... in h ... foo ... foo
06:08:16 <ddarius> cedricshock: Of course people have done such things, albeit not automatically.  "Automatic memoization" is obviously a very bad idea.
06:08:29 <Feuerbach> quicksilver: what I'm going to do is to use functions (: Int -> a) instead of small arrays. Even if program would recompute values every time I refer to them I won't probably notice, but it'd be nice if it wouldn't :)
06:09:08 <ddarius> Feuerbach: You can easily set it up not to, but no general-purpose programming language automatically memoizes all function calls.
06:09:41 <Feuerbach> ddarius: how can I set it up?
06:09:54 <quicksilver> Feuerbach: if you just use arrays, things won't get recomputed...
06:11:17 <ddarius> Feuerbach: It is easy to write a function memo :: (Int -> a) -> Int -> a.  Then you can apply it where needed either early or late.
06:11:41 <cedricshock> ddarius: I meant like template haskell. Lot's of what people want to memoize is loop unrolling, and little things that should really be taken care of as algebraic proofs. Some of the assumptions made in computer science (such as if it can't be solved in general it's not worth trying to solve for specific instances, yes I'm looking at you, Mr. Halting Problem) are one of the huge differences between human and computer (especially compil
06:11:41 <cedricshock> er) program generation.
06:12:15 <Feuerbach> ddarius: I understand, thank you
06:12:52 <ddarius> cedricshock: There has been some polytypic stuff, but nothing that would make all functions automatically memoized.
06:13:12 <ddarius> (Not because it would be at all hard to do so, but that would be a very very bad idea.)
06:14:07 <LoganCapaldo> but but
06:14:19 <LoganCapaldo> I thought it was incredible difficult and an awesome idea
06:14:27 <LoganCapaldo> you've turned my world upside down
06:14:33 <LoganCapaldo> I can't go on
06:15:27 <hpaste>  mlesniak pasted "Split-Files in Haskell: memory-consumption" at http://hpaste.org/4022
06:15:40 <osfameron> is there an "average" (or mean) function defined in prelude or standard libs ?
06:15:42 <mlesniak> It would be nice if someone could help by looking at the pasted code ;()
06:16:14 <cedricshock> ddarius: I'm not suggesting memoizing all functions, I'm suggesting making it easy to memoise anything you want to. I wouldn't be surprised if Data.Dynamic could make memoize :: (a -> b) -> a -> b for most types, though it would probably be quite useless...
06:16:23 <LoganCapaldo> osfameron: what would it's type be?
06:16:55 <osfameron> LoganCapaldo: I would have thought  Num a => a -> a   or perhaps Float a => a -> a
06:17:04 <integral> [a]->a surely.
06:17:08 <osfameron> er, yes
06:17:17 * osfameron checks his brain
06:17:26 <quicksilver> mlesniak: if you set 'size' to be rather large, then you are holding quite a big chunk of the file in memory at once
06:18:13 <ddarius> cedricshock: As I said, a polytypic version of that is easy to do.  It is also easy for the runtime to support such a memoize function and in fact Haskell implementations do have such things.
06:18:43 <mlesniak> quicksilver: I have 2GB of RAM, the file is 700 MB, this should be enough, since nearly no other programs are loaded; also swapspace is sufficient
06:18:48 <LoganCapaldo> @type let avg xs = sum xs / genericLength xs in avg
06:18:51 <lambdabot> forall a. (Fractional a) => [a] -> a
06:19:03 <quicksilver> mlesniak: 100M of [Char] takes about 2.4G in ram, I believe
06:19:04 <mlesniak> quicksilver: btw, would there be a more efficient solution; i found no way to read the file partially
06:19:11 <quicksilver> mlesniak: it's about 24 bytes per character
06:19:15 <mlesniak> quicksilver: :-O
06:19:42 <cedricshock> data Account = Income | Expense | Savings | Slush deriving (Ord, Group)
06:19:42 <quicksilver> mlesniak: the problem is the way you use take and drop
06:19:57 * mlesniak is quite new to haskell
06:19:58 <cedricshock> avg [Slush, Savings, Slush, Income]
06:20:11 <mlesniak> quicksilver: this seemd to be the easiest solution due to the lazy evaluation ;)
06:20:20 <quicksilver> mlesniak: because you are going to use 'file' later in the call to 'drop'
06:20:24 <quicksilver> it cannot be GCed
06:20:34 <quicksilver> and then, the effect of 'take' is to force the first 'size' elements
06:20:43 <quicksilver> so after the putstr/hclose
06:20:57 <quicksilver> you have 'size' elements of file held in memory
06:21:04 <quicksilver> which, as I say, is about 24 bytes per Char
06:21:05 <mlesniak> oh
06:21:47 * mlesniak thinks about other ways to handle this ...
06:21:56 <quicksilver> don't read character by character
06:22:04 <quicksilver> use bytestrings or hGetBuf/hPutBuf
06:22:05 <hjs> Hi, I have a question. I want to create an infinite list of the same element x, which is [x,x,...], how to write that expression?
06:22:14 <quicksilver> hjs: repeat x
06:22:19 <hjs> quicksilver: ah, thanks
06:22:23 <LoganCapaldo> fix (x:)
06:22:28 <DRMacIver> Hm. Using Data.Binary, is there any way of getting the current index into the bytestring?
06:22:44 <LoganCapaldo> cycle [x]
06:23:07 <dcoutts_> DRMacIver: I don't think so, no.
06:23:07 <LoganCapaldo> so many ways!
06:23:16 <DRMacIver> Sigh.
06:23:18 <DRMacIver> dcoutts_: Thanks
06:23:30 <mlesniak> quicksilver: looked at hGetBuf, but didn't understood the Ptr-Type ;) It seems to be only usable with FFIs
06:23:41 <Feuerbach> Can I write pattern (f n = 0), but n being not a binding variable but some value? Just like (f 0 = 0) but more generally. I know this could be done with guards, but can it be done without?
06:23:52 <dcoutts_> DRMacIver: what do you want it for? We did ponder whether to track it. It might not be too costly.
06:23:59 <LoganCapaldo> Feuerbach: nay
06:24:05 <Lemmih> DRMacIver: bytesRead?
06:24:16 <LoganCapaldo> how would you decide which behavior you wanted?
06:24:47 <DRMacIver> dcoutts_: I'm abusing Data.Binary to try to write a library for manipulating Java class files. Certain instructions need to get padded to be four-byte aligned with the start of the class file.
06:25:09 <DRMacIver> Well. s/abusing/using/ :)
06:25:13 <quicksilver> mlesniak: it's not only usable with ffi but it is certainly fiddly.
06:25:35 * mlesniak thought, such a problem would be easier to handle
06:25:36 <dcoutts_> DRMacIver: I see.
06:25:48 <quicksilver> Feuerbach: no, but you can write f x | x == n = 0
06:25:49 <mlesniak> quicksilver: I see, now I know where to search for examples, Thanks :)
06:26:01 <quicksilver> mlesniak: the haskell standard file IO library is painful.
06:26:04 <quicksilver> mlesniak: which is a shame.
06:26:14 <quicksilver> mlesniak: I would use bytestrings for what you are trying to do.
06:26:49 <osfameron> LoganCapaldo: yeah, that's what I would have written (though why genericLength instead of just length?) but was curious as to how it was defined (if it was defined) "officially"
06:27:23 <LoganCapaldo> @type length
06:27:27 <lambdabot> forall a. [a] -> Int
06:27:39 <mlesniak> quicksilver: Where's the difference to normal IO? It seems to support the same functions?
06:27:45 <LoganCapaldo> @type (/) (3 :: Int)
06:27:46 <lambdabot>     No instance for (Fractional Int)
06:27:46 <lambdabot>       arising from use of `/' at <interactive>:1:0-13
06:27:46 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
06:28:17 <osfameron> @type genericLength
06:28:17 <lambdabot> forall b i. (Num i) => [b] -> i
06:28:28 <quicksilver> mlesniak: it doesn't waste 24 bytes per character for starters :)
06:28:52 <mlesniak> quicksilver: *G*! Big advantage. Can I just use the take/drop-approach?
06:29:23 <quicksilver> mlesniak: yes
06:29:37 <mlesniak> quicksilver: perfect, thanks for your answers!
06:29:44 <quicksilver> mlesniak: I very much doubt you'll want to use 100M chunks in practice
06:30:00 <quicksilver> mlesniak: normal chunk sizes for efficient copying are more in the 64k-1M range
06:30:29 <quicksilver> DRMacIver: sounds to me like you need an augmented Put monad
06:30:30 <mlesniak> quicksilver: Actually I'd like to use, e.g. 900MB, chunks: General idea: split DVD's so I can copy them part-by-part using an usb-stick. The join-functions works perfectly ;)
06:31:10 <mlesniak> <- having no dvd-burner in this laptop and like to download iso's using this fast connection
06:31:11 <quicksilver> mlesniak: ah. Right. Well your current naive approach will try to read 900M into memory each time then
06:31:27 <quicksilver> mlesniak: you will want to write out to the file in smaller pieces, IMO.
06:31:29 <mlesniak> quicksilver: which is no problem for me as long as it works ;)
06:31:31 <quicksilver> and probably use hSeek
06:31:33 <DRMacIver> quicksilver: Put and Get really.
06:31:40 <quicksilver> DRMacIver: indeed.
06:31:44 <DRMacIver> indeed, Get is more important at this stage.
06:31:51 <DRMacIver> Right now I'm just trying to read class files.
06:31:52 <quicksilver> DRMacIver: you can build an 'alignment' monad on top of Put, I'll wager
06:31:59 <quicksilver> (and Get)
06:32:20 <DRMacIver> Probably. But I have no idea how. :)
06:32:24 * DRMacIver will figure it out though
06:33:31 <quicksilver> you could build it on StateT Int Get
06:33:38 <quicksilver> where the Int stores the current position
06:33:47 <quicksilver> you'll need to wrap all the underlying get primitives, though
06:34:01 <quicksilver> to update the position rightly
06:34:10 <quicksilver> and then provide new 'aligned' primitives
06:34:18 <quicksilver> which skip to the next aligned position before running
06:34:56 <DRMacIver> I don't really understand monad transformers. But I'll give it a go. :)
06:34:57 <DRMacIver> Thanks
06:36:21 <DRMacIver> Hm
06:36:23 <quicksilver> you don't have to use monad transformers
06:36:29 <quicksilver> that's just a possible implementation technique
06:36:32 <quicksilver> you could do it by hand
06:36:49 <quicksilver> @unmtl StateT Int m
06:36:49 <lambdabot> err: Unknown MTL(1)
06:36:55 <EvilTerran> hehe. whups.
06:37:00 <quicksilver> bah
06:37:30 <DRMacIver> Yeah, I'm just thinking about that. Particularly as I've realised that the byte alignment is from the start of a particular chunk rather than the start of the whole file, and it's a particularly easy chunk to parse.
06:37:31 <hpaste>  cedricshock annotated "Example of where homomorphisms could be beneficial" with "Synced message dispatch" at http://hpaste.org/4021#a2
06:37:33 <EvilTerran> @unmtl StateT Int m a
06:37:33 <lambdabot> Int -> m (a, Int)
06:37:49 <EvilTerran> gotta give something of kind * to @unmtl
06:38:15 <Feuerbach> how to invoke ghc literate preprocessor on Unix?
06:38:33 <Valou> hey guys, anyone got 20s ?
06:39:07 <EvilTerran> yes; I'm timing you, though, so best be quick!
06:39:13 <EvilTerran> ;)
06:39:30 <Valou> i'd like to know the differences between all the time displayed after the execution of such a cmd : PROG_mp arg1 arg2 +RTS -qP -qp8 -sstderr
06:39:34 <Valou> hehe
06:40:12 <Valou> cuz I have a 1st time which is 5times lesser than the elapsed time =/
06:40:26 <Valou>  INIT  time    0.00s  (  0.21s elapsed)  MUT   time   20.47s  (178.12s elapsed)  GC    time    1.06s  (  7.81s elapsed)  EXIT  time    0.00s  (  0.00s elapsed)  Total time   21.53s  (186.14s elapsed)
06:40:41 <LoganCapaldo> cedricshock: Collection looks like Monoid
06:41:15 * LoganCapaldo random observation
06:41:15 <quicksilver> LoganCapaldo: plus some kind of injection like 'pure' or 'singleton'
06:41:21 <quicksilver> LoganCapaldo: yes, I made the same one :)
06:41:42 <cedricshock> LoganCapaldo: I almost wrote when I first wrote that, "Besides looking like a Monoid..."
06:43:00 <EvilTerran> FunctorPlus?
06:43:05 <cedricshock> quicksilver: And my "messaged" looks suspiciously like a Monoid too. What it really is is just state transformations, where m somehow becomes a function from a to a.
06:43:18 <quicksilver> that is a monoid :)
06:43:25 <quicksilver> Endo a =~= a -> a
06:44:15 <Valou> so no one can tell me the difference between these times ?
06:44:16 <cedricshock> EvilTerran: Yes, this is a Functor, except sort of statically instead of at run time.
06:44:17 <Taejo> talking of Endo, anybody know who's hosting the ICFP contest next year?
06:44:55 <quicksilver> Valou: suggests that your system is doing other stuff, I believe
06:45:02 <quicksilver> Valou: elapsed time is 'wallclock' time
06:45:13 <quicksilver> Valou: the measured times are the times when your process actualy had control of the CPU
06:45:51 <Valou> thx =)
06:48:05 <Valou> so in this case the software is ran in 20sec, but I get the result after 180sec because of the CPUs @ other processes ?
06:48:57 <cedricshock> Valou: Or because of IO blocking, memory thrashing, or any other time your process spends working but not actually running.
06:49:39 <Valou> thx very much ;)
07:11:10 <yaxu> yay, i'm an MSc
07:11:19 <yaxu> thanks for your help with that, #haskell :)
07:13:02 <dmead> MSCE?
07:13:10 <dmead> uhh, thanks
07:13:11 <dmead> :P
07:13:16 <dmead> !
07:15:03 <quicksilver> yaxu: grats :)
07:15:47 <explicitjelly> dmead, master of science, i guess ;)
07:16:31 <yaxu> heh, yes not msce
07:16:33 <explicitjelly> quick indentation poll
07:16:44 <explicitjelly> when writing monadic functions with do notation
07:16:48 <explicitjelly> do you prefer
07:16:57 <explicitjelly> myfun = do <linebreak>
07:16:58 <dmead> good work !
07:17:04 <explicitjelly> or myfun = <linebreak> do
07:17:11 <Zao> former.
07:17:11 <explicitjelly> <linebreak>
07:17:27 <explicitjelly> (btw, I use myfun = do <linebreak>)
07:17:29 <Zao> With the next line four spaces from the previous line.
07:17:45 <ari> That kind of depends
07:17:49 * EvilTerran as Zao
07:17:53 <explicitjelly> I let emacs handle this, with 2 spaces indentation
07:18:24 * EvilTerran tends to also write "foo = bar baz eek where<linebreak><4 spaces>bar = ...
07:18:59 <ski> 2 spaces good, 4 spaces bad !
07:19:16 <ari> For me, usually it's either myfun a = do <stuff>, or myfun oneArg anotherArg aLotOfLongArgs = <linebreak> do...
07:19:20 <explicitjelly> hmm. I typically put a linebreak before the "where" clause
07:19:22 <explicitjelly> and none after
07:19:42 <EvilTerran> explicitjelly, most people do, i think, but i prefer this fore the sake of keeping the levels of indentation down
07:20:17 <EvilTerran> foo = ...<newline><indent>where bar = ...<newline><indent><6 spaces>baz = ...
07:20:28 <mlesniak> Is there any way to set a module as "default" in case of clashing function names? E.g. in System.IO and Data.Bytestring.Char8 I have to Prefix each command (even when abbreviated it's really uncomfortable)
07:20:42 <mlesniak> /s/in/using
07:20:43 <EvilTerran> vs foo = ... where<newline><indent>bar = ... ....; those extra six spaces make a big difference ;)
07:20:48 <quicksilver> mlesniak: not as easy as you'd like
07:20:52 <explicitjelly> "The maybe function takes a default value, a function, and a Maybe  value. If the Maybe value is Nothing, the function returns the default value. Otherwise, it applies the function to the value inside the Just and returns the result."
07:20:54 <quicksilver> mlesniak: hide the ones you don't want.
07:20:59 <explicitjelly> so, if I just want the value, I use "id" as function?
07:21:02 <explicitjelly> or is there a cleaner way?
07:21:08 <mlesniak> quicksilver: Oh... that's comfortable ;)
07:21:10 <dcoutts_> mlesniak: import one of them qualified and the other unqualified
07:21:10 <quicksilver> mlesniak: import System.IO hiding (hPutStr,hGetStr)
07:21:20 <dcoutts_> mlesniak: you may also need to hide bits from the prelude
07:21:25 <EvilTerran> @hoogle fromMaybe
07:21:26 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
07:21:28 <quicksilver> you may need to hide some from the prelude too
07:21:30 <EvilTerran> @src fromMaybe
07:21:30 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
07:21:47 <dcoutts_> mlesniak: eg: import Prelude hiding (readFile, writefile, ... etc)
07:21:47 <mlesniak> dcoutts_, quicksilver: Ok, thanks
07:22:43 * mlesniak thinks Haskell's module system needs some work ...
07:23:27 <dmead> i said that once too
07:23:33 <dmead> and was promptly smacked down
07:24:15 <mlesniak> *g*
07:24:16 <explicitjelly> EvilTerran, thanks a lot
07:24:22 <dmead> explicitjelly, i like do <lb>
07:24:30 <dmead> cause then the code block is just kinda hangin out there
07:25:05 <explicitjelly> by the way
07:25:07 <explicitjelly> $ versus parantheses...
07:25:16 <explicitjelly> I find myself typing $ whenever it's possible
07:25:39 <dmead> i don't like $
07:25:44 <dmead> it seems ugly and perlish to me
07:25:52 <explicitjelly> but I'm not entirely sure yet, if "source <- fromMaybe $ getInput "source"" really is better than "source <- fromMaybe (getInput "source")"
07:26:18 <dmead> depends on what other languages you like i guess
07:26:23 <dmead> do you like perl or lisp better?
07:26:40 <explicitjelly> I don't really like perl, no
07:26:52 <dmead> if i'm not mistaken those will compile the same anyway
07:27:00 <dmead> i use parens myself
07:27:04 <explicitjelly> yes, I know. it's just a style preference
07:27:29 <dmead> does anyone know what the difference is really?
07:27:35 <quicksilver> almost nothing
07:27:37 <dmead> i'm not an ghc expert by any means
07:27:44 <dmead> cool cool
07:27:49 <quicksilver> there is a subtle difference with type inference and higher rank types
07:27:57 <dmead> ah
07:29:29 <phlpp> hi!
07:30:42 <explicitjelly> although I think that "liftIO $ ..." is cleaner than "liftIO (...)"
07:50:00 <EvilTerran> "<someone> what's wrong with Maybe? <me> Nothing ;)"
07:52:48 * sebell groans
07:53:14 * dmead sighs
07:53:22 <dmead> also farts
07:53:24 <dmead> watch out
07:53:40 <MyCatVerbs> EvilTerran: What's wrong with nested Maybes? Just... Nothing.
07:53:54 <EvilTerran> owie
07:54:34 <EvilTerran> you win
07:56:44 <Baughn> If you ask for a 95% confidence interval, you expect to see the results from 2.5% to 97.5%, right? Not 5% to 95%?
07:57:03 <waern_> Baugh: yes
07:57:05 <Saul_> HtmlForm/Field.hs:7:7:
07:57:05 <Saul_>     Could not find module `Control.Monad.Error':
07:57:05 <Saul_>       locations searched:
07:57:05 <Saul_>         Control/Monad/Error.hs
07:57:05 <Saul_>         Control/Monad/Error.lhs
07:57:05 <Saul_> Failed, modules loaded: Page, Main.
07:57:27 <Saul_> Does anyone know why ghc can't find Control.Monad.Error?
07:57:28 <Baughn> waern: Nice. That means my teacher is mistaken. Now to convince him of this. :'(
07:58:51 <waern> Baughn: heh :)
07:59:18 <Saul_> Baugh, it might just be different conventions
07:59:33 <Saul_> Baughn*
08:00:16 <Baughn> Saul_: Don't worry. I'm being very subtle and embedding the implied criticism in an explanation of the haskell code.
08:00:39 <Saul_> Baughn: :)
08:01:06 <waern> Saul_: Maybe you don't have the mtl package
08:01:08 <quicksilver> Baughn: people talk of 'one-tailed' and 'two-tailed' confidence intervals.
08:01:38 <Saul_> waern: I'll try getting that one, it's a pretty fresh install
08:01:55 <waern> Saul_: ok
08:02:18 <quicksilver> Saul_: on debian-like systems its libghc6-mtl-dev
08:02:37 <Saul_> quicksilver: Yeah already aptituding it
08:03:08 <Baughn> quicksilver: That makes sense. I have to say, the wikipedia explanation is /lousy/.
08:03:15 <quicksilver> Baughn: but of course, 1-tailed 95% would be 0%->95%
08:03:20 <quicksilver> Baughn: (not 5% -> 95%)
08:03:31 <Saul_> yeah or 5% - 100%
08:03:39 <Baughn> quicksilver: Of course. As he didn't specify, I assumed two-tailed.
08:04:13 * Baughn is statistically measuring the time complexity of haskell functions. Some odd effects have been spotted.
08:04:16 <quicksilver> one-tailed is when your hypothesis is directional
08:04:26 <quicksilver> "hypothesis: ghc 6.8.1 is faster than ghc 6.6"
08:04:43 <quicksilver> is the kind of thing you'd use a one-tailed confidence interval fore
08:04:54 <quicksilver> if your hypothesis was just "6.8.1 is different from..."
08:04:58 <quicksilver> then you'd want the two-tailed.
08:05:20 <quicksilver> Or, I think that's the right terminology. I don't use stats often enough to remember the jargon with perfect confidence.
08:05:25 <Baughn> Mine is "computing stuff takes time", I'm afraid
08:05:55 <Saul_> waern: That did the trick, thanks
08:06:11 <quicksilver> Baughn: I confirm that at the 100% confidence level :)
08:06:23 <Taejo> quicksilver, that sounds right (I just finished stats 1)
08:06:23 <Baughn> quicksilver: Oh? I *don't*. :P
08:08:07 <waern> Saul_: glad to be of help :)
08:45:25 <hpaste>  (anonymous) pasted "Show & Ix" at http://hpaste.org/4023
08:45:45 <hrehf> duh, didn't really want to announce that ;)
08:46:35 <hrehf> i want to do something like http://hpaste.org/4023 - i have to tell the compiler types a and b are showable, right? how do i do that?
08:46:49 <hrehf> for both a and b, obviously
08:46:49 <_ry> @src snd
08:46:49 <lambdabot> snd (_,y) =  y
08:47:05 <_ry> @src thd
08:47:06 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:47:24 <_ry> :(
08:47:31 <_ry> it's so mean
08:47:38 <hrehf> :) but funny
08:47:40 <Olathe> @botsmack
08:47:40 <lambdabot> :)
08:48:23 <dmwit> hrehf: (Show a, Show b) => ...
08:48:25 <phlpp> :t (/\)
08:48:27 <lambdabot> Not in scope: `/\'
08:49:13 <asmanur> hrehf: (Show a, Show b) => ?
08:49:18 <hrehf> dmwit ah, another syntax i wasn't able to find by trial & error :(
08:49:32 <asmanur> arf
08:49:34 <dmwit> hrehf: You should try a tutorial, it's much quicker. ;-)
08:49:45 <dmead> http://www.imontheinternet.com/
08:49:50 <lambdabot> Title: ImOnTheInternet.com
08:49:55 <phlpp> @hoogle /\
08:49:55 <lambdabot> Hoogle Error: Parse Error: Unexpected character '/\'
08:50:00 <phlpp> @hoogle (/\)
08:50:01 <lambdabot> Did you mean: (/\)
08:50:01 <lambdabot> Prelude.undefined :: a
08:50:01 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:50:22 <dmwit> dmead: A good one to keep in mind for pinging. =)
08:50:29 <dmead> :P
08:50:35 <hrehf> hmm, yeah, im using hoogle & wikibooks allthe time, but i didn't reeally know where to search / what to search for :(
08:50:37 <vincenz> @type (/\)
08:50:38 <lambdabot> Not in scope: `/\'
08:50:50 <dmead> > ?src ping
08:50:50 <lambdabot>   parse error on input `?'
08:50:55 <dmead> ?src ping
08:50:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:50:59 <dmead> aw
08:51:47 <dmwit> hrehf: No type-signature at all would also work, probably.
08:51:55 <dmwit> (Unless you were running into the monomorphism restriction.)
08:52:17 <firefly> what kind of release cycle is ghc on at the moment?
08:52:18 <hrehf> well, but that's a bit dirty, isn't it?
08:52:31 <LoganCapaldo> polymorphism destriction
08:52:42 <dmwit> Not at all, that's one of the reasons I use Haskell!
08:53:42 <LoganCapaldo> hrehf: not putting type signatures is how you do tria and error
08:54:00 <LoganCapaldo> load it in ghci and do :t your_function
08:54:07 <hrehf> hmm, but then i wouldn't learn about the type system, wouldn't i ? :)
08:54:09 <hrehf> aaah
08:54:34 <LoganCapaldo> trial and error with syntax is silly
08:54:41 <dmwit> right
08:54:54 <hrehf> cool feature :o
08:55:32 <dmwit> So cool, it got put into \bot! =)
08:55:36 <dmwit> Also, this keyboard sucks.
08:55:48 <dmwit> The \ key is all the way to the right, *under* the enter key.
08:57:15 <firefly> nope, all the way to the left, right next to the left shift key.  You need to hold down Alt Gr, though.
08:57:34 * firefly uses a Danish keyboard
08:57:42 <dmwit> ewwww
08:58:04 <dmwit> Mine is gross enough without being made out of pastry.
08:58:37 <zeeeee> is there a haskell library for expressing and processing make-like rules with dependencies?
08:58:47 <firefly> we probably have the best X keyboard layout in the world.  Does your keyboard have ħ? ;)
08:59:52 <MyCatVerbs> hthththt: oh hey, when'd you get in here, anyway?
09:00:23 <dmwit> zeeeee: Not that I know of.
09:00:28 <dmwit> There's a Data.Graph, though.
09:13:12 <dcoutts_> zeeeee: we're working on one for Cabal.
09:14:36 <dons> top 25 python libs, stats, http://www.algorithm.co.il/blogs/index.php/programming/python/python-module-usage-statistics-cont/
09:14:38 <lambdabot> Title: Algorithm Blogs  Python module usage statistics - Cont., http://tinyurl.com/393z8s
09:14:43 <dons> we need similar :)
09:14:49 <dons> types,298 . hehe
09:15:20 <vincenz> dons: what do you use for note-taking?
09:15:22 <dons> "Note that these results might be slanted, as some stdlib modules are implemented in C"
09:15:38 <dons> vincenz: paper and pen
09:15:55 <vincenz> never heard of htat application
09:15:58 <vincenz> is it for linux?
09:16:15 <dons> i think its quite portable
09:16:31 <vincenz> my issue with pen and paper is that there's no refactoring :|
09:16:32 <dons> for small notes i use 'devtodo'
09:16:42 * dmwit uses gvim
09:16:48 <dons> i know SyntaxNinja uses trac for lots of stuff
09:17:01 * doserj mentions emacs org-mode
09:17:21 * vincenz wants something like visual mind but for linux
09:18:12 * doserj guesses, vincenz knows freemind already
09:18:34 <vincenz> yah
09:18:41 <vincenz> it's not as good, besides it's old
09:18:57 <vincenz> the issue with such applications is that 95% of the selling power is the fluff
09:19:07 <vincenz> And if you're not about a certain fluff-threshold, you might as well use vim
09:19:53 <matveev> hi, is there something like takeWhileTailSatisfiesCond :: ([a] -> Bool) -> [a]  that takes a boolean function to examine the *tail* of a list in stdlibs?
09:20:28 <dons> no, nothing standard
09:20:57 <dmwit> takeWhile . tail ?
09:21:07 <dmwit> Or maybe takeWhile . reverse, if that's what you're into?
09:21:34 <dmwit> Oh, I see what you're getting at.
09:21:38 <dmwit> :t tails
09:21:39 <lambdabot> forall a. [a] -> [[a]]
09:21:44 <dmwit> > tails "haskell"
09:21:45 <lambdabot>  ["haskell","askell","skell","kell","ell","ll","l",""]
09:21:49 <dmwit> Does that help?
09:22:03 <dmwit> There's also inits if that's the wrong direction.
09:22:22 <matveev> learning new functions helps, yes
09:23:34 <jedbrown> How possible would it be to marshal an arbitrary value, to the extent that the same program (on a different machine) can read it?
09:23:50 <dmwit> deriving (Show, Read)
09:24:13 <zeeeee> to 'break' a forM_, would you use exceptions, or write your own forM_ that takes IO Bool rather than IO ()?
09:24:41 <dmwit> :t filterM
09:24:43 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:25:04 <zeeeee> dmwit, that doesn't break, though, does it?
09:25:15 <jedbrown> dmwit: by arbitrary, I mean values of type IO ()
09:25:15 <dmwit> No, I guess not.
09:25:20 <zeeeee> :)
09:25:30 * shapr applies a hysteromorphism on himself.
09:25:32 <dmwit> jedbrown: Aha, that may be trickier.
09:25:35 <resiak> :t forM_
09:25:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
09:26:05 <dmwit> zeeeee: Can you use some kind of takeWhile trick, or is it really going to be an IO Bool?
09:26:50 <vincenz> matveev: what aobut
09:26:56 <zeeeee> dmwit, whether or not to continue is an IO result
09:27:16 <jedbrown> (I want to build a distributed control model loosely analogous to Concurrent.)
09:27:19 <dmwit> zeeeee: Okay.  You may be able to use foldM and when to get what you want.
09:27:56 <zeeeee> yeah, that would work too
09:27:59 <dmwit> Sorry, I mean foldl' and when.
09:28:03 <vincenz> > let takeWhileLists f l = head . dropWhile f . map (flip splitAt) [1..] $ l in takeWhileLists (\(h,t) -> length t > 5) [1..10]
09:28:04 <lambdabot>  Couldn't match expected type `a -> [a1]'
09:28:40 <vincenz> > let takeWhileLists f l = head . dropWhile f . map (`splitAt` l) $ [1..] in takeWhileLists (\(h,t) -> length t > 5) [1..10]
09:28:43 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
09:29:10 <vincenz> that'll do :)
09:29:16 <vincenz> so for your case
09:29:17 <vincenz> it's
09:29:21 <vincenz> (yourF . snd)
09:29:43 <matveev> vincenz: I'll need some time to read that. I asked yesterday about dropping trainling zeroes from the list --- and there was only the ?a bit too strict? reverse . (dropWhile condition) . reverse solution
09:30:00 <vincenz> matveev: basically I generate an infinite list of all possible split pairs
09:30:03 <vincenz> and since you want a 'while' thing
09:30:08 <vincenz> and they're ordered in the right direction
09:30:17 <vincenz> I just keep going until my 'f' returns true, in which case I take that split
09:30:21 <vincenz> erm, returns false
09:31:04 <vincenz> if you want exactly your type
09:31:12 <vincenz> replace 'dropWhile f' by 'dropWhile (f . snd)'
09:31:26 <vincenz> and then add a 'fst .' before the 'head'
09:31:27 <doserj> takeWhileLists p = unfoldr (\(x:xs) -> if p xs then Just (x,xs) else Nothing)
09:31:34 <oboudry> Hi all, is there a way to import different modules depending on ghc version? 6.6.1 vs 6.8.1
09:31:50 <oboudry> need to import Data.ByteString.Unsafe in 6.8.1 and Base in 6.6.1
09:32:23 <oboudry> is this feasible with an #ifdef ???
09:32:28 <dcoutts_> yes
09:32:56 <oboudry> how do I detect between the old base and new split-base?
09:33:10 <dcoutts_> boudry: you can set CPP symbols in the .cabal file based on the version of the base package. Or you can use a less pleasant hack and use #if's based on the ghc version.
09:33:30 <matveev> vincenz, doserj: my type was wrong, sorry. I though of an analog of takeWhile filter that "looks ahead".
09:33:47 <oboudry> dcoutts_: thanks, the CPP symbol trick looks good.
09:33:51 <dcoutts_> oboudry: see http://www.haskell.org/pipermail/haskell/2007-November/019955.html
09:33:53 <lambdabot> Title: [Haskell] package maintainers: updating your packages to work with GHC 6.8.1, http://tinyurl.com/2owuyc
09:35:12 <oboudry> dcoutts_: thanks for the link. I already read this post but didn't thought of defining CPP symbols to be used in the source files.
09:35:14 <zeeeee> dmwit, hrmmm..why not foldM?
09:35:27 <oboudry> dcoutts_: I just used it for the build-depends.
09:35:48 <dmwit> zeeeee: Well... I think that will make it hard to "cut off", right?
09:35:58 <dcoutts_> oboudry: right, but yes you can use it for anything, like cpp-options
09:36:01 <dmwit> Dunno, I didn't actually have a crack at implementing what you want, so...
09:36:17 <oboudry> dcoutts_: understood, thanks for the info.
09:36:31 <zeeeee> that's where 'when' would come in, i think
09:36:47 <vincenz> hey zeeeee
09:37:20 <zeeeee> vincenz, lo!
09:38:06 <zeeeee> vincenz, no more #oasis? :)
09:38:09 <jedbrown> dmwit: No problem.  It may be a very hard problem, but such an abstraction would be really useful.
09:38:43 <dons> dcoutts_: i think i can find time to finish the fusion merge for bytestrings, btw.
09:38:53 <dcoutts_> dons: oh great
09:38:53 <vincenz> zeeeee: sure, but you're not there?
09:39:01 <dons> need fast strings at work, amongst a bunch of other libs we'll be releasing
09:39:07 <dcoutts_> dons: right
09:39:31 <dons> there's a db and a json lib that should get released
09:39:51 <dons> cause we need more db bindings
09:39:54 <dons> ;)
09:40:02 <dcoutts_> dons: I think the bs testsuite needs redoing based on the one we did for list, that was a much better design and it was clearer when we were missing things.
09:40:10 <dons> yeah.
09:40:19 <dons> i use the latter thesedays
09:41:31 <dcoutts_> dons: I could probably find time between writing to help hack on integrating the new fusion stuff with bytestring
09:42:07 <dons> ok. cool.
09:42:13 <dcoutts_> dons: it'd be a pleasant distraction, and I need new perf results for my thesis anyway
09:42:29 <dons> right.
09:44:06 * bos ponders a zipper on a 2D array for convolving it
09:45:35 <vincenz> bos: you mean list?
09:46:32 <bos> vincenz: no, though i can't see an easy way to avoid using a list.
09:47:24 <bos> the one-hole context of an array isn't easy to cook up.
09:47:45 <xs> bos: GSLHaskell/HSSL has fft on vectors. for convolving A and B, can just use A (*) B == F^{-1} (F(A) F(B)^*) where ^* is the complex conjugate?
09:48:40 <vincenz> bos: one-hole of a context of an array is a bit odd
09:48:47 <vincenz> bos: since there's no data definition of an array
09:48:50 <bos> vincenz: precisely
09:48:59 <vincenz> beside,s you have O(1) access..
09:50:16 <vincenz> bos: one-hole context only makes sense for recursively-defined types
09:50:19 <bos> xs: yes, that's doable
09:51:07 <bos> vincenz: i had been coming to that conclusion, i hadn't used zippers on anything other than lists, so i had to think about it
09:52:18 <vincenz> bos: a zipper is basically (though there's some fine subtleties that roconnor pointedm e out) a deriviate of a type in terms of the element type
09:52:59 <vincenz> if it's a flat-type, you jsut get a constant
09:55:16 <vincenz> in a sense, an array is a flattype
09:55:25 <vincenz> so you get a constant for the zipper, I guess the index?
09:55:36 <dmwit> No, the size.
09:56:03 <dmwit> Or, wait.
09:56:08 <vincenz> actually neverm ind
09:56:14 * dmwit goes back to lurking
09:56:22 <vincenz> if we look an array as a tuple
09:56:24 <vincenz> then you have
09:56:28 <vincenz> a^n for an array of size n
09:56:35 <vincenz> so ... the derivative of that is
09:56:38 <vincenz> n * a^n-1
09:56:47 <vincenz> namely the remainder of the array and a constant telling you where you're at
09:56:55 <bos> yes
09:56:58 <vincenz> not very useful
09:57:15 <vincenz> besides, tehre are no array unstructuring and restructuring things :|
09:57:31 <vincenz> so it's not like you could easily unzip
09:57:46 <bos> yes, the array APIs are very thin. pretty much the only useful way to work with them is inside the ST monad.
09:58:55 <bos> you can't even fold over an immutable array without writing your own fold. shocking, i tell you.
10:00:29 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/array-0.1.0.0/Data-Array.html is a bit short on documentation
10:00:29 <lambdabot> http://tinyurl.com/2amflv
10:00:46 <bos> dmwit: the array APIs are documented in Data.Array.IArray
10:01:07 <bos> but even there, they're thin.  try to figure out how to use ixmap from reading its one-line description!
10:01:52 <vincenz> arrays are a tad limited
10:01:58 <dmwit> bos: The type says it all. ;-)
10:02:22 <dmwit> bos: Also, I see what you mean about a fold, but it isn't all that hard to write, since there's "elems", right?
10:02:38 <dcoutts_> fold only makes sense for Int indexed arrays anyway, doesn't it?
10:02:49 <dmwit> no?
10:03:13 <vincenz> dcoutts_: you mean single dimensional ones
10:03:25 <dons> at some point we should start looking at http://darcs.haskell.org/packages/ndp/ndp.cabal instead..
10:03:29 <bos> dmwit: you can operate over arrays by using the list conversion functions, yes, but that's not going to be efficient i suspect
10:03:37 <dcoutts_> bos: fusion :-)
10:03:39 <vincenz> dcoutts_: I dunno, I could see my folding over a higher dimensional matrix to get dimension-1
10:03:55 <dons> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/Unlifted.hs
10:03:56 <dcoutts_> vincenz: hmm, projections yes.
10:03:56 <lambdabot> http://tinyurl.com/272fud
10:03:58 <bos> dcoutts_: will the current foldr/build fusion kick in for foldl'?
10:04:07 <dmwit> dons: =)
10:04:09 <dcoutts_> bos: no, you need stream fusion for that.
10:04:18 <bos> dcoutts_: exactly what i thought :)
10:04:25 <dcoutts_> bos: that's the main limitation that stream fusion addresses.
10:05:12 <renevannt> haskel!!
10:05:13 <renevannt> ok
10:05:22 <renevannt> wher eit tutorial for haskell for REALLY dumb guy
10:05:27 <dons> dcoutts_: do you remember any reason why we wouldn't just start using ndp arrays (the flat, unlifted, unparallel ones) ?
10:05:47 <dons> as UArrays that fuse, and support map and fold
10:07:57 <dons> its fun whatching rl and apfelmus talk on the mailing list
10:08:22 <dcoutts_> dons: so which bit of the ndp arrays are implemented? just the single dimensional?
10:08:40 <dcoutts_> or also the mapping of multi-dimensional to single?
10:08:54 <dons> i think the library is done, but the vectorisation of types , and flattening , needed for nested, parallel ones is ongoing
10:09:10 <dons> so at least single dimensional ones are done though (pretty sure)
10:09:30 <dcoutts_> ok, so that covers most uses of UArray
10:09:36 <dons> yeah
10:09:43 <dons> but with a sane interface :)
10:09:52 <dons> ?type ixmap
10:09:54 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
10:10:03 <dons> oh, that's ok
10:10:46 <dcoutts_> I'm guessing most uses are 1d (so not bixmaps or matrices)
10:11:12 <dons> i expect so.
10:32:35 <dmwit> phlpp: (/\) was probably meant to be the "and" operator for some constraint system.
10:41:59 <Vulpyne> I just upgraded to ghc 6.8.1 and am attempting to compile the HSQL package from htoolkit. It compiled okay on the previous version, but it fails with a pretty weird error now.
10:42:16 <Vulpyne> http://hpaste.org/4025 - Contains the offending area of code (the line with forall) and the error.
10:42:25 <Vulpyne> Anyone have an idea of what the problem could be?
10:42:47 <shapr> hiya Vulpyne!
10:42:47 <mauke> enable -fglasgow-exts
10:43:02 <Vulpyne> Hey, shapr!
10:43:06 <Vulpyne> mauke: Thanks! I'll try it.
10:43:07 <shapr> How's code?
10:43:15 <mauke> achy breaky
10:44:00 <Vulpyne> mauke: Worked. Thanks again.
10:44:12 <Vulpyne> shapr: Going pretty good, I've been doing most of my programming in Haskell lately.
10:44:16 <Vulpyne> Which I enjoy.
10:48:58 <Vulpyne> Ugh. I can see getting stuff to work on 6.8.1 is not going to be a trivial matter.
10:51:18 <magnus_> Hi, I have a design question. Let's say I am building some sort of file processor and I want to write both to an output file and show errors/warnings to the user
10:52:57 <magnus_> if I just return two lazy streams then whichever I evaluate first (using say writeFile), will cause a lot of thunks in memory to be created for the other output
10:52:57 <mrd> @hoogle Writer
10:52:58 <lambdabot> Control.Monad.Writer :: module
10:52:58 <lambdabot> Control.Monad.Writer.Writer :: (a, w -> Writer w a)
10:52:58 <lambdabot> Control.Monad.Writer.Writer :: newtype Writer w a
10:53:21 <magnus_> mrd: that's not a solution really
10:53:55 <magnus_> it seems to me that the two output streams should be read in a balanced way to avoid keeping unnecessary things in memory
10:54:36 <mauke> is this debiforestation?
10:54:39 <mrd> i think you may be prematurely optimizing
10:54:57 <phlpp> dmwit: ok, thanks
10:55:02 <mauke> http://okmij.org/ftp/Haskell/#de-biforestation
10:55:03 <lambdabot> Title: Haskell Programming: Miscellanea
10:55:13 <Taejo> it's optimization, certainly. is it premature?
10:55:55 <magnus_> deforestation only seems to handle the one imput one output case
10:56:01 <magnus_> I have one input two outputs
10:56:08 <oerjan> you could return one lazy stream of Eithers?
10:56:10 <mrd> no, de-biforestation
10:56:24 <magnus_> oerjan: that's an interesting idea
10:56:28 <oerjan> or an explicit datatype
10:56:42 <mrd> "We will consider the problem of one producer and two consumers in the
10:56:43 <mrd> general setting."
10:56:44 <monochrom> Use two threads. Each thread transfers an output to the destination.
10:57:03 <magnus_> aah yes that paper seems relevant
10:57:09 <dcoutts_> magnus_: yes, it does seem tricky to deforest something that has two outputs
10:57:26 <dcoutts_> you need to somehow know that the two consumers are working in lock step
10:57:49 <mrd> oleg's paper assumes they don't
11:00:53 <renevannt> software
11:01:13 <Taejo> renevannt, hardware?
11:02:30 <renevannt> hardware needs software!
11:03:30 <MyCatVerbs> Only if you want to actually *sell* any of it.
11:03:40 <renevannt> selling is important for eating in usa
11:03:54 <MyCatVerbs> ...as opposed to what?
11:04:02 <MyCatVerbs> Is there anywhere in the world where it isn't?
11:04:05 <dcoutts_> mrd: mmm, interesting.
11:04:06 <renevannt> hm
11:04:16 <renevannt> haskell seems interesting
11:04:47 <dcoutts_> renevannt: hardware may need software, but software doesn't need hardware
11:04:48 <MyCatVerbs> renevannt: preaching to the choir, most of us wouldn't be here if we didn't agree. ;)
11:05:47 <MyCatVerbs> dcoutts_: you try running a windowing system by simulating it in your head. :P
11:05:55 <dcoutts_> nah, software just needs pencil and paper :-)
11:06:04 <MyCatVerbs> dcoutts_: plus, all real-time software, by definition, does.
11:06:40 <Taejo> Nah, MyCatVerbs, I can play tic-tac-toe with pencil and paper in real time
11:06:53 <MyCatVerbs> dcoutts_: assuming you use the definition: "delivering answers on time is neccessary for them to be correct" as "real-time". >>
11:07:01 <mauke> hey, protontorpedo is back!
11:07:05 <Taejo> Turing tried with chess, but I believe he was very slow
11:07:08 <dcoutts_> @protontorpedo
11:07:09 <lambdabot> that dude is selling u  a book
11:07:15 <ddarius> dcoutts_: Hardware doesn't need software
11:07:15 <MyCatVerbs> Taejo: that's fine, but tic-tac-toe isn't a real time problem. It's turn-based. :P
11:07:54 <MyCatVerbs> Taejo: try running DOOM3 on paper and see how well you manage to keep up the suspension of disbelief. :P
11:08:06 <MyCatVerbs> Taejo: (obvious retort, Dungeons and Dragons works, doesn't it?)
11:08:08 <Taejo> I can solve differential equations fast enough to catch a ball without any hardware
11:08:23 <Taejo> DND > Doom
11:08:28 <magnus_> olegs paper is too dense for me. This is too complicated for such a simple thing
11:08:30 <MyCatVerbs> Taejo: what do you call that chunk of greyish meat between your ears, if not hardware? Chopped liver?
11:08:38 <oerjan> Taejo: your brain isn't hardware?
11:08:47 <Zao> It's wetware :)
11:08:57 <Taejo> thank you, Zao
11:09:27 <Taejo> of course I agree with you, MyCatVerbs... just being silly
11:10:09 <mauke> @proton
11:10:09 <lambdabot> so haskell is free?
11:10:11 <ddarius> magnus_: Which?
11:10:15 <MyCatVerbs> Taejo: this is not an argument, it's a discussion. And you've quite happily blown straight through my points, so now I know I need to think harder about it. Thank you. :)
11:10:52 <Taejo> It's my pleasure
11:10:54 <magnus_> ddarius: http://okmij.org/ftp/Haskell/#de-biforestation
11:10:54 <lambdabot> Title: Haskell Programming: Miscellanea
11:12:08 <magnus_> I like oerjan's idea better
11:13:39 <renevannt> I am learning haskell
11:13:43 <renevannt> watch out!!!
11:13:50 <renevannt> the web is no longer safe
11:14:15 <dcoutts_> @yarr!
11:14:15 <lambdabot> Well Ahoy! thar.
11:14:21 <mauke> @proton
11:14:21 <lambdabot> smalltalk is oo
11:14:32 <dcoutts_> @yow!
11:14:33 <lambdabot> Do you think the "Monkees" should get gas on odd or even days?
11:16:06 <ddarius> renevannt: The web would be safer if you were learning C?
11:16:22 <renevannt> mmm
11:16:24 <renevannt> maybe
11:17:45 <renevannt> the essence of programs is making interfaces and functionlaity
11:18:42 <renevannt> value oriented programming
11:18:46 <renevannt> hmmm
11:19:01 <mauke> @proton
11:19:02 <lambdabot> is haskell nicer than clisp?
11:19:24 <dcoutts_> renevannt: "value oriented programming" is that from a tutorial? I quite like it as a description.
11:19:58 <ddarius> That will win us the right wing programmers.
11:20:05 <dcoutts_> hah hah
11:20:23 <dcoutts_> quick, we need a left wing buzzword
11:20:30 <ddarius> Though they may prefer the faith-based approach of C.
11:20:47 <dcoutts_> that's a lovely description :-)
11:21:27 <renevannt> Im libertarian.
11:21:28 <renevannt> :)
11:21:52 <mauke> you're a troll
11:21:56 <renevannt> nope
11:22:05 <renevannt> on goole tech talks
11:22:16 <renevannt> http://www.youtube.com/watch?v=faJ8N0giqzw&feature=user
11:22:17 <lambdabot> Title: YouTube - Tangible Functional Programming
11:22:25 <dcoutts_> ah, conal's talk
11:22:26 <renevannt> kiler
11:22:34 <dcoutts_> @seen conal
11:22:36 <lambdabot> I saw conal leaving #haskell and #ghc 12h 43m 45s ago, and .
11:22:56 <dcoutts_> renevannt: when he turns you you can tell him you liked it, I'm sure he'll be glad to know.
11:23:01 <mauke> try again with an identity that doesn't match *!n=gav*@147.21.16.3
11:23:48 <renevannt> turns?
11:23:57 <renevannt> as in a cleric?
11:24:55 <dcoutts_> erm, I meant when he turns up
11:24:59 <dcoutts_> missed a word :-)
11:25:00 <dmead> ?losers
11:25:00 <lambdabot> Maximum users seen in #haskell: 418, currently: 399 (95.5%), active: 13 (3.3%)
11:29:30 <hpaste>  bos pasted "Sobel operator" at http://hpaste.org/4027
11:29:33 --- mode: ChanServ set +o vincenz
11:30:56 <renevannt> any nifty visual tutorials for haskell?
11:31:01 <renevannt> anyone/
11:31:38 <vincenz> @where yaht
11:31:38 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:32:01 <monochrom> pdf's are very visual.
11:32:25 <monochrom> like, you have to use your eyes to read words.
11:32:46 <vincenz> monochrom: no feeding
11:32:47 <monochrom> I bet most speech synthesizers work poorly with pdfs.
11:32:56 <renevannt> ok ill elave
11:32:59 <renevannt> bye
11:33:11 --- mode: vincenz set -o vincenz
11:33:41 <monochrom> Sorry, didn't read the scrollback.
11:37:52 <bos> welcome to #haskell, where you are invited to lay down your own rail on which to run yourself out of town.
11:38:22 <desrt> hello, haskell
11:38:32 <vincenz> bos: :D
11:38:46 <vincenz> bos: I have a high suspcion renevannt is gavino (of CLL troll-fame)
11:38:49 <vincenz> suspicion
11:40:43 <mauke> where high = 99.9%
11:41:14 <vincenz> well no
11:41:18 <vincenz> a prior 80%
11:41:26 <vincenz> but given your statement, I now use bayes to make it 99.9%
11:41:27 <bos> same illiterate off-topic ramblings, anyway.
11:41:43 <mauke> yeah, the first thing he said make me whois him
11:41:58 <mauke> n=gav, 147.21.16.3, "purple"
11:42:05 <mauke> three strikes, etc.
11:42:07 <vincenz> purple... pidgin?
11:42:35 <mauke> that's his realname setting. he's used it before
11:42:47 <vincenz> ah, didn't know that bit
11:43:47 <mauke> s/make me/made me/
11:58:20 <gwern> I have a question. so Monadius stores its demos as these godawful repetitive lists of thousands of integers. is there any better/easier/shorter method of generating these lists than enumerating them (like Monadius currently does) or going "take n $ cycle 'm'" to compress the repetitive parts like I'm currently making it do?
11:58:43 <Orphi> @list
11:58:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:58:52 <gwern> (the definitions look like 'shieldAttack = ((1,0),"[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,33......')
11:59:12 <Orphi> @vixen hello
11:59:20 <lambdabot> hiya
11:59:27 <Orphi> ...?
11:59:27 <SamB> what sort of data is it?
11:59:28 <dmead> > repeat 0 5
11:59:32 <dmead> err
11:59:33 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[t2]'
11:59:35 <dmead> > replicate 0 6
11:59:36 <lambdabot>  []
11:59:40 <dmead> > replicate 6 0
11:59:41 <lambdabot>  [0,0,0,0,0,0]
11:59:42 <oerjan> gwern: for a start there's replicate
11:59:43 <dmead> right
12:00:03 <gwern> so replicate is akin to take $ cycle?
12:00:05 <SamB> @type uncurry replicate
12:00:10 <lambdabot> forall a. (Int, a) -> [a]
12:00:20 <dmead> ?src replicate
12:00:21 <lambdabot> replicate n x = take n (repeat x)
12:00:26 <vincenz> @join #oasis
12:00:36 <dmead> > repeat 5
12:00:37 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
12:00:44 <dmead> > cycle 6
12:00:45 <lambdabot>   add an instance declaration for (Num [a])
12:00:48 <dmead> ?src cycle
12:00:49 <lambdabot> cycle [] = undefined
12:00:49 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:00:52 <dmead> ah
12:00:54 <oerjan> > map (uncurry replicate) [(1,3),(2,5),(10,2)]
12:00:57 <lambdabot>  [[3],[5,5],[2,2,2,2,2,2,2,2,2,2]]
12:00:57 <mux> > cycle [6]
12:00:58 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6...
12:01:07 <oerjan> > concatMap (uncurry replicate) [(1,3),(2,5),(10,2)]
12:01:07 <lambdabot>  [3,5,5,2,2,2,2,2,2,2,2,2,2]
12:01:09 <Orphi> ?src System.Directory.getDirectoryContents
12:01:10 <lambdabot> Source not found. My pet ferret can type better than you!
12:01:23 <gwern> how about that. heh. it's mildly annoying when you reinvent something in the stdlibs
12:01:36 <Orphi> @seen dcoutts
12:01:36 <lambdabot> I saw dcoutts leaving #haskell-overflow, #ghc, #haskell and #gentoo-haskell 6h 9m 42s ago, and .
12:01:39 <dmead> gwern, what did you write?
12:02:08 <gwern> dmead: my definitions currently look like '++ (take 5 $ cycle "67") ++ (take 1 $ cycle "3") ++'
12:02:14 <dmead> ah
12:02:18 <dcoutts_> hia Orphi
12:02:31 <dmead> yea
12:02:31 <Orphi> oh, there ya are.
12:02:31 <Orphi> lo
12:02:37 <gwern> as you can see, it's not particularly efficeint because I wrote these using a combo of 'uniq' and emacs macros
12:02:49 <dmead> you wanna poke around in the libs before writting list operations
12:02:53 <dmead> always saves time
12:02:57 <ihope> > [(1,3),(2,5),(10,2)] >>= concatMap
12:03:02 <ihope> Er, not that.
12:03:04 <lambdabot>  Couldn't match expected type `(t, t1)'
12:03:10 <ihope> > [(1,3),(2,5),(10,2)] >>= uncurry replicate
12:03:11 <lambdabot>  [3,5,5,2,2,2,2,2,2,2,2,2,2]
12:03:29 <ihope> Is it possible to get a list of modules or packages visible to GHC?
12:03:42 <oerjan> > concatMap (take `ap` cycle) [(5,"67"),(1,"3")]
12:03:43 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
12:03:45 <mauke> ghc-pkg list
12:03:48 <Orphi> dcoutts_: as you might have seen, I've hit a couple of packages that require "sh" to build. is there a known way round this?
12:04:08 <gwern> Orphi: submit patches to make'm all better?
12:04:20 <oerjan> > concatMap (take *** cycle) [(5,"67"),(1,"3")]
12:04:22 <lambdabot>  Couldn't match expected type `[b]'
12:04:28 <Orphi> gwern: yeah, but IS there a better way?
12:04:35 <oerjan> gah
12:04:49 <gwern> there must be. everything a shell can do a haskell program is supposed to be able to do
12:05:02 <oerjan> > concatMap (take.fst `ap` cycle.snd) [(5,"67"),(1,"3")]
12:05:10 <lambdabot>      precedence parsing error
12:05:10 <lambdabot>         cannot mix `ap' [infixl 9] and `(.)' [i...
12:05:26 <oerjan> > concatMap (take.fst <*> cycle.snd) [(5,"67"),(1,"3")]
12:05:27 <lambdabot>  "676763"
12:05:32 <Orphi> ok, so if I were sufficiently superhuman to be able to comprehend what these bash scripts do... I could replace them with Haskell?
12:06:02 <dcoutts_> Orphi: which packages btw? So those will build on windows if you've got mingw + msys.
12:06:21 <Orphi> dcoutts_: so far, I've tripped over SDL and GLUT.
12:06:43 <dcoutts_> Orphi: ok, the thing to look at is the configure.ac file, not the configure sh script
12:06:46 <gwern> sdl... I've been trying to rewrite Monadius to use SDL, but sdl won't install on my gentoo. bleh.
12:06:56 <dons> dcoutts_: it would be nice if 'cabal update' could check automatically ona cabal install call
12:07:01 <dcoutts_> gwern: really? it should do.
12:07:06 <dcoutts_> gwern: it's in the overlay
12:07:21 <gwern> dcoutts_: yes, but there's a problem between the configure and compilation
12:07:37 <dcoutts_> dons: yes it would, I think there's a bug open on that. If there isn't would you mind adding one and proposing a design.
12:07:42 <gwern> dcoutts_: I think there's something messed up with my system, another bug left over from when I accidentally nuked /var
12:07:50 <dcoutts_> gwern: heh, oops
12:08:18 <gwern> (I say that because ebuilds of old versions and also hand-downloaded versions all fail the same way)
12:08:19 <Orphi> dcoutts_: ok, so what does configure.ac tell me?
12:08:33 <dons> hmm. isn't regex-base updated for 6.8?
12:08:51 <dcoutts_> Orphi: it says what silly configuration the package needs to do, usually filling in paths etc and writing a .buildinfo file
12:08:52 <dons> ?seen TuringTest
12:08:52 <lambdabot> I saw TuringTest leaving #haskell 20h 55m 52s ago, and .
12:09:07 <dcoutts_> dons: for example, supposing I want to install something that I already fetched, then it's not ok to go online to grab the package index
12:09:20 <dons> hmm. it seems regex-base needs containers, bytestring et al.
12:09:40 <dons> dcoutts_: right. we just want to check if anything changed on hackage
12:09:58 <dons> rsync the package index :)
12:09:58 <dcoutts_> dons: yes, the 0.7x.0.x versions work with 6.8, the 0.9x versions may be different
12:10:04 <dons> mm
12:10:16 <dcoutts_> dons: but we need to be able to work offline sometimes
12:10:18 <dons> but those are buggy versions
12:10:31 <dcoutts_> dons: like fetch stuff, go offline, install/reinstall
12:11:00 <dons> urgh, and there's type errors
12:11:05 <dons> regex-base is too complex!
12:11:05 <dcoutts_> so we cannot just go and try and fetch things unless we're in a situation where it's essential to download anyway, like installing a package that has not been fetched
12:11:18 <dcoutts_> dons: why not just use the ones that work with 6.8?
12:11:25 <gwern> monadius is such *messy* code :( I still haven't figured out what the hell he was doing with that C stub and the manual calls to wavplayer and winamp
12:11:27 * dons uses the old buggy ones that build
12:12:08 <dons> cabal-install++
12:12:19 <dcoutts_> dons: the regex-* situation is a bit odd really, extralibs has these old ones that work and on hackage there are also all the 0.9x versions
12:12:53 <dons> right. fundamentally though, they're too complex in their type hackery, leading to unportability
12:13:11 <bos> where's the unportability?
12:13:34 <dons> bos, broken type class stuff, so current regex-base doesn't type check in 6.8
12:13:44 <dcoutts_> dons: so by the time we've decided we need a package, and thus it's ok to go online, we've already decided what we want to do. So should we abandon our original solution, grab the index and check again?
12:13:49 <dons> i'd be happy with one efficient regex backend. no type class hackery
12:13:59 * dcoutts_ too
12:14:11 <dcoutts_> I avoid all the regex-* stuff as it scares me :-)
12:14:14 <dons> i don't care about all the different .c libs -- just pick the best one.
12:14:16 <dcoutts_> and the standard ones are slow
12:14:44 <dcoutts_> ie the Text.Regex one, that uses the posix backend.
12:21:57 * shapr boings
12:22:25 <dons> ?yow
12:22:26 <lambdabot> TAILFINS!! ... click ...
12:24:46 <gwern> ah, I've got it! 'show $ concat $ map (\(a,b) -> replicate a b)', and make the list a list of pairs
12:24:54 <gwern> @src concat
12:24:54 <lambdabot> concat = foldr (++) []
12:25:13 * gwern was about to redefine concat as well as replicate, it'd seem :)
12:25:16 <sorear> show $ concatMap (uncurry replicate) itym?
12:25:51 <gwern> :( just when I was feeling proud of myself
12:26:03 <idnar> @pl show $ concat $ map (\(a,b) -> replicate a b)
12:26:05 <lambdabot> show (join (map (uncurry replicate)))
12:26:21 <oerjan> gwern: we did sort of mention it several times up there
12:26:41 <oerjan> also, i made a cycle version
12:26:44 * gwern was working on that, better to figure it out for yourself than copy other's, etc. etc.
12:27:09 <shapr> @yow !
12:27:11 <lambdabot> Th' MIND is the Pizza Palace of th' SOUL
12:27:11 <gwern> also, the cycle one was ugly. I don't even know what <*> is
12:27:18 <shapr> I have to find a new amusing thing to say.
12:27:20 * shapr thinks
12:27:23 <shapr> @quote
12:27:23 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
12:27:25 <shapr> argh
12:27:26 <shapr> @quote
12:27:26 <lambdabot> b7j0c says: the haskell community should take out life insurance on dons
12:27:30 <oerjan> it's Applicatve application
12:27:32 <shapr> hah, that's true!
12:27:33 <oerjan> *tive
12:27:49 <oerjan> just sort of @pl trick
12:27:54 <gwern> oerjan: dunno what that is either
12:28:02 <oerjan> you can do it with a lambda instead
12:28:11 <gwern> (the applicative thign, that is, not @pl)
12:28:15 <oerjan> @pl \(a,b) -> replicate a b
12:28:15 <lambdabot> uncurry replicate
12:28:21 <oerjan> oh
12:28:55 <oerjan> it's a generalization of monads, with only the lift operations and not bind
12:29:15 <byorgey> gwern: applicative functors.
12:29:15 <gwern> odd. what do you use it for?
12:29:19 <byorgey> @type (<*>)
12:29:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:29:32 <oerjan> i used it there because the monad ap had the wrong precedence
12:30:05 <byorgey> gwern: it's nice for expressing what would otherwise be something like e.g. zipWith6
12:30:44 <shapr> Ya know, it'd be fun to find statistically improbable phrases from #haskell.
12:31:27 <ihope> I think "show concat map a b replicate a b" isn't very common outside of #haskell.
12:31:45 <byorgey> gwern: http://www.soi.city.ac.uk/~ross/papers/Applicative.html
12:31:48 <lambdabot> Title: Applicative Programming with Effects
12:32:44 <ddarius> shapr: What do you mean?
12:33:20 <hpaste>  tphyahoo-haskel pasted "yhc install problems" at http://hpaste.org/4028
12:35:27 <gwern> byorgey: thnz
12:35:45 <shapr> ddarius: Amazon.com shows statistically improbable phrases when showing books, so I wonder what each irc channel would have for SIPs
12:36:10 <shapr> Hiya gmh!
12:36:16 * byorgey guesses "monad" would be up there...
12:36:19 <grahamhutton> hi shapr!
12:36:47 <ddarius> shapr: I'll have to look at Amazon then.
12:36:54 <shapr> byorgey: I wonder how they do it... you think they build a hidden markov model for each book and then figure out which word chains in a particular text have the least likelihood of showing up?
12:37:25 <grahamhutton> quick advert for those in the UK: "fun in the afternoon" takes place in York, tomorrow
12:37:28 <shapr> yay!
12:37:43 <grahamhutton> http://sneezy.cs.nott.ac.uk/fun/
12:37:51 <lambdabot> Title: Fun in the Afternoon
12:37:58 <shapr> Is there already an HMM lib for Haskell?
12:38:06 <Orphi> ooo...
12:38:11 <Orphi> oh wait, it's in York.
12:38:24 <byorgey> shapr: no, it's probably just some variant of tf-idf
12:38:31 <shapr> tf-idf?
12:38:48 <grahamhutton> Five talks on FP, with our own Conor McBride as the headliner!
12:39:07 <byorgey> shapr: http://en.wikipedia.org/wiki/Tf-idf
12:39:09 <lambdabot> Title: tf–idf - Wikipedia, the free encyclopedia
12:39:13 <Orphi> sounds... interesting. I "talk" isn't something I've experienced before...
12:39:23 <Vulpyne> Anyone manage to get the network-alt package working with ghc 6.8.1?
12:39:52 <shapr> byorgey: Would that work for phrases as well?
12:40:05 <byorgey> shapr: I don't see why not.
12:41:52 <shapr> byorgey: Do you know of a tf-idf lib for Haskell?
12:42:02 <shapr> Hiya Katie
12:42:05 <shapr> @users
12:42:05 <lambdabot> Maximum users seen in #haskell: 418, currently: 406 (97.1%), active: 20 (4.9%)
12:42:28 <byorgey> shapr: no
12:42:28 <KatieHuber> hi
12:42:32 <shapr> KatieHuber: How's code?
12:42:42 <shapr> byorgey: I wonder if fgl could do it...
12:42:43 <byorgey> shapr: that is to say, I don't know of one, not that there isn't one.
12:42:58 <KatieHuber> shapr: it happens, irregularly
12:43:06 <shapr> KatieHuber: Yeah, I know that feeling.
12:43:12 <ddarius> KatieHuber: Eat more fiber.
12:43:18 <shapr> lambda fiber!
12:45:50 * olsner sticks to lambdas and syntactic sugar
12:45:59 <shapr> I'd like to do an NMU for various hackage packages.
12:46:33 * ddarius bets @vera doesn't know this usage of NMU.
12:47:14 <SamB> @vera NMU
12:47:15 <lambdabot> *** "nmu" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
12:47:15 <lambdabot> NMU
12:47:15 <lambdabot>      Non-Maintainer Upload (Linux, Debian)
12:47:15 <lambdabot>  
12:47:25 <SamB> ddarius: I think you just lost?
12:47:25 <ddarius> Holy mackerel.
12:47:31 <ddarius> SamB: Apparently.
12:47:51 <SamB> what OTHER meanings are there?
12:48:01 * ddarius should've sticken to the safe bet that -he- didn't know wtf "NMU" was.
12:48:12 <SamB> ddarius: you don't?
12:48:19 <ddarius> SamB: I do now.
12:48:31 <SamB> well that would explain why you didn't think VERA would know it ;-)
12:48:39 <byorgey> @vera FTW !
12:48:39 <lambdabot> No match for "FTW".
12:48:39 <lambdabot> No match for "!".
12:48:44 <byorgey> aww
12:48:51 <SamB> @vera FTL
12:48:51 <lambdabot> No match for "FTL".
12:49:13 <gwern> how does vera know NMU but not ftw? I only recognize it in a debian context because I caused a few nmus to happen...
12:49:38 <gwern> SamB: there are apparently 4 other meanings for nmu: https://secure.wikimedia.org/wikipedia/en/wiki/NMU
12:50:39 <SamB> hmm, what is VERA's demographic?
12:50:57 * ddarius just now realizes he wrote "sticken"
12:51:22 <shapr> @go sticken
12:51:22 <EvilTerran> @help vera
12:51:22 <lambdabot> http://www.bigoven.com/160505_StickenChicken_recipe.html
12:51:22 <lambdabot> Title: Recipe Software and Food Social Network
12:51:22 <lambdabot> I perform dictionary lookups via the following 13 commands:
12:51:22 <lambdabot> all-dicts ... Query all databases on dict.org
12:51:24 <lambdabot> devils ...... The Devil's Dictionary
12:51:26 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
12:51:28 <lambdabot> elements .... Elements database
12:51:30 <lambdabot> [9 @more lines]
12:51:42 <EvilTerran> @devil cold
12:51:42 <lambdabot> No match for "cold".
12:51:44 <ddarius> @dict-help vera
12:51:44 <lambdabot> vera ........ V.E.R.A.: Virtual Entity of Relevant Acronyms
12:51:51 <SamB> gwern: it MIGHT be related to one of the expansions of FTW, and the fact that the other one doesn't make any sense
12:52:23 <SamB> @vera vera
12:52:23 <lambdabot> *** "vera" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
12:52:24 <lambdabot> VERA
12:52:26 <lambdabot>      Just playing around, huh?
12:52:28 <lambdabot>  
12:52:48 <SamB> JPAH /= VERA
12:53:02 <EvilTerran> @devils cabbage
12:53:03 <lambdabot> *** "CABBAGE" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
12:53:03 <lambdabot> CABBAGE, n.  A familiar kitchen-garden vegetable about as large and
12:53:03 <lambdabot> wise as a man's head.
12:53:03 <lambdabot>     The cabbage is so called from Cabagius, a prince who on ascending
12:53:04 <lambdabot> the throne issued a decree appointing a High Council of Empire
12:53:06 <lambdabot> [6 @more lines]
12:53:09 <EvilTerran> @more
12:53:10 <lambdabot> consisting of the members of his predecessor's Ministry and the
12:53:10 <lambdabot> cabbages in the royal garden.  When any of his Majesty's measures of
12:53:12 <lambdabot> state policy miscarried conspicuously it was gravely announced that
12:53:14 <lambdabot> several members of the High Council had been beheaded, and his
12:53:16 <lambdabot> murmuring subjects were appeased.
12:53:18 <lambdabot>  
12:53:20 <EvilTerran> hehe
12:54:10 <ddarius> Nothing like beheadings to appease the folk.
12:54:14 <shapr> I still wish it stripped blank lines.
12:54:25 <ddarius> I was thinking that too.
12:54:29 <EvilTerran> it would make sense
12:55:10 <ddarius> (Is there any problem beheading can't solve?)
12:55:38 <Vulpyne> How might I convert an Int to a CInt?
12:55:47 <ddarius> fromIntegral
12:55:58 <Vulpyne> Hmm, thanks.
12:55:58 <resiak> stained carpets?
12:56:25 <ddarius> resiak: I can fix that with enough beheadings.  Especially, if you like the color red.
12:56:40 <shapr> hah
12:59:45 <oerjan> @remember ddarius (Is there any problem beheading can't solve?) <resiak> stained carpets? <ddarius> I can fix that with enough beheadings.  Especially, if you like the color red.
12:59:45 <lambdabot> I will remember.
13:04:25 <nominolo> gah why do people have to put huuge photos of themselves right onto every article of their blog.
13:04:38 <nominolo> it's incredibly distracting
13:04:38 <wilx> Exhibicionists?
13:04:56 <nominolo> who knows
13:04:59 <SamB> wilx: what, you mean like NAKED people?
13:05:01 <SamB> where?
13:05:13 <nominolo> http://tomschrijvers.blogspot.com/2007/11/extension-proposal-for-uniplate.html
13:05:14 <lambdabot> Title: Tom's Declarative Languages Blog: An extension proposal for Uniplate, http://tinyurl.com/2ctbye
13:06:44 <dpiponi> Is there a web page with a summary of everything you can do with Haskell records, including ghc extensions?
13:07:00 <SamB> @google ghc docs
13:07:01 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/
13:07:07 <SamB> @google ghc user manual
13:07:08 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
13:07:08 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.8.1
13:07:21 <SamB> dpiponi: you can probably find it from there
13:07:43 <dpiponi> That's where I started but wasn't having much success.
13:08:05 <SamB> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
13:08:06 <lambdabot> Title: Chapter 8. GHC Language Features, http://tinyurl.com/kf2g3
13:08:26 <dpiponi> I guess it does have what I want but it's just scattered around.
13:08:46 <SamB> dpiponi: scattered around?
13:09:04 <SamB> dpiponi: ... that whole chapter is what you want, isn't it?
13:09:28 <byorgey> nominolo: that's why I read things in a feed reader =)
13:09:38 <byorgey> nominolo: (well, ok, that's not really why... just a side benefit)
13:09:39 <dpiponi> There are separate sections on a couple of different record extensions. And presumably somewhere, though I haven't found it, there must be a section on h98 records.
13:09:51 <Heffalump> has anyone played with type synonym families?
13:09:54 <SamB> dpiponi: why would there be?
13:09:58 <SamB> @google haskell report
13:09:58 <lambdabot> http://www.haskell.org/onlinereport/
13:09:58 <lambdabot> Title: The Haskell 98 Language Report
13:09:58 <nominolo> byorgey: yeah
13:10:10 <SamB> dpiponi: those are, after all, described in the report...
13:11:26 <stepcut> is there a .deb for cabal 1.2 or greater ?
13:11:28 <dpiponi> Well, there are nice summaries of other topics at haskell.org so I was hoping to see everything in one place somewhere.
13:11:55 <stepcut> (for use with ghc 6.60
13:12:07 <SamB> dpiponi: oh, I misread your question
13:12:20 <stepcut> 6.6.1
13:12:48 * dpiponi wonders what he was misread as saying
13:14:26 <sizur> i have a lexical parsing error at a preprocessing line at compilation (ghc). what's wrong?
13:14:28 <SamB> dpiponi: I thought you wanted to know about GHC extensions, including record extensions...?
13:14:46 <SamB> at least, I think that's what I thought
13:15:10 <sizur> at the #if to be precise
13:15:22 <SamB> sizur: how did you invoke the compilation?
13:15:33 <sizur> --make
13:15:41 <SamB> try -fcpp
13:16:26 <SamB> dpiponi: anyway... there isn't much extension done to the record stuff...
13:17:32 <sizur> ghc-6.8.1: unrecognised flags: -fcpp
13:17:56 <sizur> same if i put it in OPTIONS in Main.hs
13:18:10 <SamB> sizur: oh
13:18:26 <SamB> I guess -cpp
13:18:39 * SamB can't imagine why it doesn't have an -fcpp form
13:19:13 <sizur> SamB: Thanks! it works :)
13:20:06 <SamB> preprocessor instructions work much better when the preprocessor is actually run over the code ;-)
13:20:40 <sizur> it's in HaXml src, so i have no choice there
13:21:25 * shapr boings cheerfully
13:22:22 <grahamhutton> hi conal!
13:22:33 <sizur> SamB: actually i dont think i quite understood that line... you mean i should invoke cpp and pipe to ghc?
13:23:15 <SamB_XP> sizur: no, I just mean it works better if you ask GHC to run the code by cpp before attempting to compile it -- which is what -cpp is for
13:24:46 <andyjgill_> Graham, this is becoming a habit!
13:24:56 <sizur> SamB: right, i'm just new to the haskell process
13:25:16 <grahamhutton> seems like it :-)
13:26:44 <ihope> Why do most flags seem to start with f?
13:27:13 <allbery_b> I think that's lifted from gcc
13:27:29 <ihope> Does the f mean anything at all?
13:27:30 <allbery_b> -f<option> is compilation flags
13:27:33 <gwern> oh, I just remembered something. I rand across some old code for ghc 6.4, which wants to use Data.FiniteMap, but my ghc 6.8 doesn't have that. where did finitemap go?
13:27:38 * ihope nods
13:27:40 <wilx> Except that -f option in GCC are codegen related.
13:27:50 <wilx> In GHC it covers nearly everything.
13:27:55 <allbery_b> yeh
13:28:21 <allbery_b> but then, ghc doesn't exactly have any consistency in options anyway :)
13:29:26 <allbery_b> (I mean, given the way the other options work, why isn't it -make?)
13:30:41 <harlekin`> I am trying to install to build some packages from hackage.haskell.org. E.g. zlib depends on various base packages(?). How can I check which is installed?
13:30:54 <harlekin`> Or how can I check which packages are installed in general? Is tehre a way?
13:31:10 <shachaf> harlekin`: ghc-pkg list?
13:31:29 <harlekin`> shachaf: Yeah, this seems to be pretty much all I need. Thank you. (:
13:31:38 <shachaf> gwern: Data.FiniteMap was replaced with Data.Map.
13:32:38 <gwern> shachaf: thanks
13:39:27 <phlpp> @go 70 USD in EUR
13:39:28 <lambdabot> 70 U.S. dollars = 47.4737199 Euros
13:40:58 <Taejo> @go 100 USD in ZAR
13:40:58 <lambdabot> 100 U.S. dollars = 672.979212 South African rands
13:41:16 <hpaste>  sizur pasted "what's that and how to fix?" at http://hpaste.org/4029
13:42:33 <sizur> is this a common compilation error? i'm sure i saw that some other place
13:42:58 <oerjan> sizur: you may want something like XParser (ExtParsedEnt <sometype>)
13:43:09 <ddarius> It says what the problem is.
13:44:15 <sizur> but that's directly from hackage src...
13:44:45 <sizur> if i use cabal to install, it's fine, why's that?
13:46:21 <TSC> Which version do you have?
13:46:54 <TSC> The latest version on hackage has "extparsedent :: XParser (ExtParsedEnt Posn)"
13:47:15 <TSC> (That's 1.19.1)
13:50:09 <kalmar> @fptools Text.Printf
13:50:10 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
13:50:52 <hpaste>  sizur annotated "what's that and how to fix?" with "HaXml-1.19.1" at http://hpaste.org/4029#a1
13:51:14 <sizur> TSC: here's same error for latest version
13:51:26 <sizur> at different loc
13:53:37 <kalmar> hmmm is the IsChar class needed because String is a type synonym?
13:54:05 <ddarius> kalmar: No.
13:54:13 <ddarius> Depending on how you mean that.
13:55:28 <kalmar> ddarius: I am wondering why instance Printftype String is not h98
13:55:30 <SamB_XP> well, it's because String = [Char], isn't it?
13:56:10 <ddarius> kalmar: That isn't H98 but you can just expand the type synonym
13:56:32 <kalmar> but instance Printftype [Char] wont' do either
13:57:05 <kalmar> instances have to be for data or newtype types, no?
13:57:18 <kalmar> (I have no idea why I suddenly decided to investigate printf's implementation)
13:58:04 <sizur> nm me, that's not HaXml's problem, it's HAppS's one
13:58:54 <vincenz> what is "value-oriented programming"?
13:59:02 <vincenz> conal: ?
13:59:34 <Cale> vincenz: Functional programming, essentially
13:59:41 <vincenz> hmm
13:59:43 <lament> programming that's oriented in accordance with corporate values
13:59:46 <Cale> heh
14:00:00 <thetallguy>  vicenz: another great term from conal:  genuinely functional programming
14:00:07 <Cale> Programming where the main thing that you do is to describe values
14:00:33 <lament> isn't that more like logic programming?
14:00:35 <thetallguy> vincenz: Conal is talking about maintaining the functional paradigm, even in the face of IO
14:01:11 * vincenz nods
14:01:12 <thetallguy> vincenz: not relaxing to an imperative style, and above all, maintaining composability even with effects.
14:01:47 <thetallguy> a good example is Fran
14:02:12 <thetallguy> an animation is effectful, but descriped as f t, where t is time
14:02:24 <vincenz> right
14:02:25 <vincenz> a stream
14:02:30 <vincenz> a comonad
14:02:56 <thetallguy> Those are examples, there could be other reps.
14:03:11 <vincenz> I think a comonad is the generalisation, not a rep
14:04:14 <thetallguy> okay, there are other possible generalizations as well.
14:04:22 <vincenz> oh
14:04:25 <vincenz> thetallguy: examples?
14:04:37 <thetallguy> Conal has been moving from Monads, to App Functors to Arrows
14:04:47 <thoughtpolice> @pl \s -> error ("problem: "++s)
14:04:47 <lambdabot> error . ("problem: " ++)
14:04:54 <vincenz> nod
14:04:54 <thetallguy> Still thinking about it.
14:05:04 <thetallguy> Any more, you should get from the horse's mouth.
14:05:21 <vincenz> Right :)
14:05:38 <vincenz> But Fran is not his, is it?
14:05:38 <ddarius> He's moving toward arrows?
14:06:22 <vincenz> I wonder how he represents parametric polymorphism in eros
14:06:33 <olsner> vincenz: comonads are streams?
14:06:38 <vincenz> streams are comonads
14:06:40 <ddarius> olsner: Other way.
14:06:52 <vincenz> olsner: it's easy to flatten to a value
14:06:53 <vincenz> w a -> a
14:06:56 <vincenz> but hard to go the other way
14:06:58 <vincenz> it's the opposite of a mona
14:07:03 <thetallguy> Yes, Fran is Conal's work
14:07:06 <olsner> ah, so that's head of the stream then?
14:07:10 <thetallguy> along with Paul Hudak
14:07:12 <ddarius> vincenz: On one of his slides he had "Tangible polymorphism", I'm not sure if that issue was what he was talking about.  He skipped over elaborating that line.
14:07:14 <vincenz> olsner: or the 'current' value
14:07:22 <vincenz> ddarius: Thanks
14:07:27 * vincenz is watching presentation @ google
14:08:08 <thetallguy> ddarius: eros lets you compose polymorphic computations
14:08:11 <ddarius> olsner: class Comonad w where extr :: w a -> a; dupl :: w a -> w (w a); instance Comonad Stream where extr = head; dupl = tails
14:08:51 <vincenz> ddarius: you mean []
14:09:01 <vincenz> Stream has future
14:09:06 <vincenz> Stream a = Stream [a] a [a]
14:09:18 <lament> are extr and dupl the official names?
14:09:19 <vincenz> extr (Stream past now future) = now
14:09:21 <vincenz> no
14:10:04 <ddarius> By Stream I meant data Stream a = Stream a (Stream a) with head and tails being the obvious translation of the list functions to this.
14:10:47 <vincenz> streams typically extend in 2 direections
14:10:49 <vincenz> past and future
14:10:51 <vincenz> but ok
14:11:44 <paczesiowa> can someone help me with alex? I have this macro: @name = (@white_space)? @name_token, how do I write correct rule for @name? "@name {Name}" keeps comments
14:11:44 <nominolo> are diff-arrays extendable?
14:13:32 <conal> vincenz: hi.
14:13:46 <vincenz> Hi
14:13:57 * vincenz is looking at your google techtalk
14:14:02 <vincenz> Always so relaxed :)
14:14:13 <conal> :)
14:14:23 <vincenz> you've obviously found peace
14:14:33 <vincenz> through the cnvc stuff?
14:15:32 <conal> vincenz: pretty much.  nvc stuff is a part of it, mainly in clearly articulating & affirming what i learned from my parents.
14:16:03 <vincenz> conal: So how do you represent polymorphic parametric functions? Or is that open research?
14:16:05 * ddarius has no idea what you two are talking about now.
14:16:28 <conal> vincenz: and i took a few years off for "inner work", including jungian analysis, meditation, journaling, and shamanic training.
14:16:31 * vincenz nods
14:16:35 <nominolo> ddarius: icfp offside talk
14:17:00 <conal> vincenz: the puzzle for me about polymorphism is how to give a concrete visualization.
14:17:07 <olsner> "inner work" is cool. I should do that some time
14:17:16 <vincenz> conal: Yes, same here, hence why I asked :)
14:17:36 <conal> (btw, the nvc stuff vincenz mentioned is described at http://awakeningcompassion.com)
14:17:36 <lambdabot> Title: Awakening Compassion Home
14:17:44 <nominolo> some amorphous blob obviously!
14:18:28 <ddarius> nominolo: Something like that was what I was thinking about seriously.
14:18:34 <conal> re: "<thetallguy> an animation is effectful, but descriped as f t, where t is time", i'd say animations are not effectful.  they just are.
14:18:42 <Inspico> Hello
14:18:43 <ddarius> conal: Ah yes, I forgot about that site.
14:19:11 <lament> conal: are you a shaman?
14:19:14 <Inspico> augustss may I ask you a thing in private message ?
14:19:55 <conal> lament: i went through 16 months of intensive training.  i'm still wondering where it will go.
14:19:58 <waern> conal: can you make animations that are not functions of time in eros?
14:20:07 <conal> waern: e.g.,?
14:20:12 <waern> conal: say you want to evolve some kind of behaviour
14:20:26 <conal> waern: so far sounds like a function of time
14:20:37 <waern> rule based, e.g "game of life"
14:20:51 <vincenz> conal: How do you deal with conditionals?
14:20:55 <conal> waern: are you reading "function of time" as "\ t -> ..."?
14:21:03 <waern> conal: yeah
14:21:04 <conal> vincenz: in eros?
14:21:17 * vincenz nods
14:21:25 <vincenz> And once you have that, how do you deal with recursion
14:21:28 <conal> waern: okay.  i mean semantically, not syntactically.
14:21:42 <vincenz> as for the parametric polymorphism, the reason I asked about it was for simple things like 'uncurry'
14:21:48 <vincenz> or 'curry'
14:21:58 <ddarius> conal: I like how in the talk you never mention that one of the links lit for fusion when clicking on an input is the output of the very same function.
14:22:27 <conal> vincenz: i could do recursion via a fixpoint operator.  but i'm looking for something more artist-friendly.
14:22:32 * vincenz nods
14:22:44 <vincenz> conal: well for instance if you wanted to generate an infinite amount of images scaled down
14:22:49 <conal> vincenz: there are a few built-in polymorphic operators: curry, uncurry, flip, ...
14:22:58 <vincenz> but those are parematrically polymorphic!
14:23:06 <vincenz> erm, with correct spelling
14:23:14 <waern> conal: hmm, you lost me now... I should read the paper instead :)
14:23:28 <vincenz> So you must have some way to visualize them, or are they operations found in menus only?
14:23:32 <conal> vincenz: yes. and they're not presented in the same way.  i'd like something general, uniform, and artist-friendly.
14:23:50 * vincenz nods
14:23:59 <vincenz> blob as mentioned prior would be ok
14:24:01 <vincenz> some cloud thingy
14:24:07 <conal> ddarius: people usually ask about it.
14:24:10 <vincenz> of different colors
14:24:16 <vincenz> like 'a -> blue cloud, 'b -> red cloud
14:25:31 <vincenz> conal: how do you duplicate stuff? fusion deletes your inputs.  So you could never do something like 'let foo = .... in .... foo ... fooo ....'
14:25:48 <ddarius> conal: I was impressed by your (seemingly) quickly thought up and unorthodox way of handling seeing the "program", i.e. the "video" idea.
14:25:57 <conal> vincenz: via a "dup" operator.
14:26:00 * vincenz nods
14:26:05 <vincenz> conal: but you have twice the amount of inputs then?
14:26:30 <conal> ddarius: oops -- i'd thought of that idea before.
14:26:38 <ddarius> conal: I suspected as much.
14:27:01 <ddarius> The unorthodox aspect was the more impressive.  It's certainly not what one thinks of immediately.
14:27:11 <conal> vincenz: dup duplicates an output.  if you want to use an output twice, dup it and then use each copy
14:27:19 <conal> ddarius: thanks. :)
14:27:21 <vincenz> conal: Anyways, I must admit I really like the generic idea behind it all.  That wasn't obvious to me priorly, I had seen Fran and applicative functors.  But didn't know the generic philosophy behind it. I like it :)
14:28:16 <conal> vincenz: :).  the idea has been coming together for me for many years, and only a couple of years back came clear.
14:28:56 <conal> one clue is that many authoring tools and graphics APIs have internal graph representations that grow into more & more complex badly designed programming languages.
14:29:40 <conal> http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule
14:30:04 <vincenz> yep
14:30:09 <ddarius> conal: When I look at this stuff, I see combinator languages, e.g. stack languages.
14:31:40 <hpaste>  zeeeee pasted "How do I fix this type error?" at http://hpaste.org/4031
14:32:20 <vincenz> @type throwDyn
14:32:25 <lambdabot> Not in scope: `throwDyn'
14:32:26 <vincenz> @hoogle throwDyn
14:32:27 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
14:32:27 <lambdabot> Control.Exception.throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
14:32:57 <conal> ddarius: stack?
14:33:09 <vincenz> @hoogle catchDyn
14:33:09 <lambdabot> Control.Exception.catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
14:34:09 <vincenz> zeeeee: why not simply use catchError?
14:35:19 <zeeeee> vincenz, (i'm looking that up)
14:35:28 <vincenz> @hoogle catchError
14:35:29 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
14:35:41 <vincenz> instance MonadError String IO I believe
14:36:07 <oerjan> @instances-importing Control.Monad.Error MonadError
14:36:10 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
14:36:22 <zeeeee> vincenz, the problem is that intr will raise a Dynamic exception
14:36:27 <vincenz> zeeeee: ah
14:37:00 <_fang> hello there! does anyone know where i can find a haskell implementation for the TSP problem, if possible, the assymetric one. i just got the C/C++ and or java, after googling a reasonable time
14:37:06 <olsner> what a weird quit-message... it's not even grammatical
14:38:15 <vincenz> _fang: this for homework?
14:38:59 <_fang> vincenz: sure =] in fact, i wanna take one example so that i can write the code by myself, but i had no graph classes yet, so i'm a bit lost on how to do it
14:39:09 <oerjan> zeeeee: you may wish to use catchJust dynExceptions instead
14:39:53 <oerjan> catchDyn can only handle _one_ dynamic type
14:40:26 <oerjan> or, if you don't _really_ need to check that it's dynamic, just use catch and throw
14:40:55 <oerjan> er, throwError i guess
14:41:04 <zeeeee> man, what a mess
14:41:31 <vincenz> zeeeee: the issue is that exception is not contrainted
14:41:34 <vincenz> zeeeee: it's like
14:41:40 <vincenz> show . read
14:41:42 <augustss> who is having fun tomorrow afternoon?
14:42:54 <conal> augustss: i am!  (or is it a present tense/past tense trick question?)
14:43:14 <augustss> it's a trick question
14:43:21 <Lemmih> conal: They have an exclusive Haskell club, I think.
14:43:42 <augustss> http://sneezy.cs.nott.ac.uk/fun/
14:43:45 <conal> first thanksgiving at my home in the woods.
14:43:45 <lambdabot> Title: Fun in the Afternoon
14:43:50 * vincenz has to go to an internal presentation, sadly
14:43:53 <conal> oh!
14:44:00 <vincenz> conal: you remind me of the guy in 'backslash'
14:44:06 <vincenz> hacker with cabin in the wood ;)
14:44:09 <conal> vincenz: ??
14:44:25 <augustss> conal: you'll just be sleepy after too much tryptophan :)
14:44:30 <ddarius> conal: Not that it should have a stack, but those type of primitives and means of combination.
14:44:35 <vincenz> conal: Nothing serious :)
14:44:39 <conal> augustss: except i'm not into turkey.
14:44:48 <Olathe> Turkey is overrated.
14:44:51 <augustss> oh well
14:44:56 <vincenz> Olathe: not istanbul
14:44:58 * ddarius finds that most people don't really like turkey.
14:45:03 <Olathe> Cranberry sauce and stuffing are nice.
14:45:08 <conal> ddarius: yep.  semantic combinators.
14:45:11 <augustss> I eat turkey once a year; around thanksgiving
14:45:14 <vincenz> "symmetric monoidal categories"
14:45:15 <vincenz> hhe
14:45:20 <wli> Istanbul just hasn't been the same since 1453.
14:45:22 <vincenz> oh, the bird!
14:45:25 <conal> vincenz: i have yet to look that up
14:45:28 <Olathe> vincenz: Yes, but Turkey makes people Hungary.
14:45:37 <augustss> lol
14:45:47 <ddarius> conal: Understand cartesian closed categories?
14:46:14 <conal> ddarius: a bit
14:46:14 <ddarius> (Specifically, actually, symmetric monoidally closed categories would be used for higher order languages.)
14:46:14 <_fang> vincenz: any tips?
14:46:22 <augustss> category theory is overrated
14:47:13 <ddarius> conal: It's basically a cartesian closed category only using non-canonical "products".
14:49:00 <vincenz> _fang: there is a graph library
14:49:53 <_fang> vincenz: can i get its documentation at haskell.org?
14:50:03 <vincenz> @doc Data.Graph
14:50:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
14:50:58 <dibblego> ?src Maybe Arbitrary
14:50:59 <lambdabot> Source not found. It can only be attributed to human error.
14:52:09 <zeeeee> i don't need the exception handler to be able to handle any type of exception, but it should be polymorphic; if necessary, i'm happy to parameterize somehow the exact exception types to be thrown, but i don't know how to do this / what to do
14:52:39 <_fang> rgr! thank you very much! =D
14:52:54 <vincenz> what?
14:53:19 <zeeeee> e.g. read :: String -> Int is possible, but i don't know how to do something similar here (runIntoIO :: ??)
14:53:26 <zeeeee> er, run Int
14:53:39 <EvilTerran> what
14:53:40 <oerjan> zeeeee: it is easiest to catch all (or all dynamic ones)
14:54:22 <oerjan> zeeeee: if you catch all, you can also use bracketOnError
14:54:27 <dibblego> is there any particular reason that instance Arbitrary Maybe a is not in the QC source?
14:55:52 <oerjan> zeeeee: btw you said intr is what raises the exception.  In that case i think you have the wrong precedence - catchdyn will not include the part before the $
14:56:39 <faxathisia> Does anyone know here to get an implementation of pH?
14:56:45 <faxathisia> I think this is a 404 http://csg.csail.mit.edu/projects/languages/ph.shtml
14:56:45 <lambdabot> Title: Computation Structures Group- MIT- LCS
14:56:48 <zeeeee> oerjan, oh, thanks
14:57:17 <oerjan> by default, operators have the _highest_ precedence unless specified, including those in ``
14:57:33 <oerjan> and $ has the very lowest
14:57:52 <zeeeee> faxathisia, i think most of pH has been merged in
14:58:05 <faxathisia> merged in what?
14:58:08 * EvilTerran thought they got 4 or 5 by default
14:58:19 <EvilTerran> (I may be completely mistaken)
14:58:28 <oerjan> infixl 9 is the default iirc
14:58:33 <zeeeee> concurrent haskell
14:58:54 <zeeeee> iirc m-structures == mvars
14:58:59 <oerjan> > (0 `catchDyn` 0 $)
14:59:00 <lambdabot>   Not in scope: `catchDyn'
14:59:01 * ddarius suggests looking at the report.
14:59:10 <oerjan> > (0 `Control.Exception.catchDyn` 0 $)
14:59:11 <lambdabot>   Not in scope: `Control.Exception.catchDyn'
14:59:25 <oerjan> sheesh
14:59:29 <zeeeee> heh
14:59:32 <oerjan> :t (0 `Control.Exception.catchDyn` 0 $)
14:59:33 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `IO a1'
14:59:33 <lambdabot>     In the first argument of `($)', namely
14:59:33 <lambdabot>         `0 `Control.Exception.catchDyn` 0'
14:59:38 <faxathisia> woah
14:59:50 <oerjan> darn, remembered the trick wrong
15:00:03 <faxathisia> merged into GHC?
15:00:03 <faxathisia> So I'm really writing concurrent programs without knowing?
15:00:14 <oerjan> :t (0$0 `Control.Exception.catchDyn`)
15:00:15 <lambdabot>     The operator `Control.Exception.catchDyn' [infixl 9] of a section
15:00:15 <lambdabot>         must have lower precedence than the operand `($)' [infixr 0]
15:00:15 <lambdabot>         in the section: `((0 $ 0) `Control.Exception.catchDyn`)'
15:00:24 <dons> faxathisia: the Control.Parallel stuff is from pH
15:00:32 <dons> when you use `par` and such
15:00:55 <faxathisia> @docs Control.Parallel
15:00:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel.html
15:01:01 <faxathisia> :/
15:02:02 <faxathisia> so is GHC -threaded going to automatically parallelize everything?
15:02:12 <noteventime> Does anyone know if there's been a try at creating an OpenGL scene-graph in Haskell?
15:02:18 <ddarius> faxathisia: No
15:02:33 <faxathisia> mmm
15:03:08 <faxathisia> Glasgow Parallel Haskell (GPH) is implemented as a special setup of the Glasgow Haskell Compiler
15:03:28 <thetallguy> conal: re: "re: ... i'd say animations are not effectful.  they just are.", as with the convo about responding to external stimuli, I appreciate the sentiment, but find the description just a bit too far towards the pure
15:03:57 <ddarius> thetallguy: Not a fan of relativity?
15:03:58 <thetallguy> conal: rendering an animation to paper for a flipbook requires modifying the state of the world.
15:04:13 <conal> thetallguy: that's rendering, not animation.
15:04:24 <thetallguy> conal: rendering it on the screen modifies the state of the user's mind.
15:04:25 <conal> is Bool effectful just because it can be rendered?
15:04:34 <olsner> thetallguy: that's just because you live in a world that does not already have all the flipbooks you want.. sheesh ;-)
15:04:36 <thetallguy> conal: one without the other just gets your machine hot
15:04:36 <conal> thetallguy: sure.  rendering does.
15:04:37 <faxathisia> since they write, nf2 `par` (nf1 `seq` (nf1+nf2+1))
15:04:45 <faxathisia> It seems that GpH is different from pH
15:05:00 <thetallguy> conal: to consider one without the other goes nowhere.
15:05:27 <ddarius> faxathisia: Who is they?
15:05:42 <faxathisia> I found it here http://www.macs.hw.ac.uk/~dsg/gph/docs/Gentle-GPH/sec-gph.html
15:05:43 <conal> thetallguy: and yet the semantics can be specified independently, as with Bool.  yes, i want to render my bools and animations, but i'd like to formulate semantics separately from rendering.
15:06:01 <thetallguy> conal: as before, I do not wish to toss away the information that something is actually effectful.
15:06:04 <conal> the value of separating is that i can reason and compose more powerfully & simply
15:06:21 <thetallguy> conal: I'm not in disagreement with that.
15:06:26 <conal> thetallguy: me neither.  just to clarify that it's presentation that's effectful, not bools or animations.
15:07:05 <thetallguy> conal: Good.
15:07:19 <thetallguy> conal: working on a blog, first step towards modeling the user
15:07:51 <conal> thetallguy: nifty
15:08:03 <thetallguy> conal: we can revisit this with that as a ref.  As always, I think we agree, just need to get our language in sync.
15:08:04 <ddarius> thetallguy: In this regard, Eros is like xmonad.  The StackSet is a model that is rendered by X.  The model is pure, it is the rendering that is not.
15:08:30 <thetallguy> conal: but now I have to go buy wine and cheese.
15:08:44 <thetallguy> ddarius: I would argue that is ultimately not enough.
15:08:52 <faxathisia> I guess no one is using pH then?
15:08:54 <conal> thetallguy: enjoy!
15:09:31 <thetallguy> ddarius: But I need some examples that I've worked through to be able to communicate why.
15:09:41 <ddarius> thetallguy: Enough for what?
15:09:59 <thetallguy> ddarius: to make a complete model of user interaction
15:10:36 <faxathisia> seems like it's not ready I guess
15:11:10 <thetallguy> ddarius: that is  as purely functional as possible.
15:11:15 <thetallguy> afk
15:11:37 <olsner> symmetric monoidal categories?
15:11:57 <conal> i guess my main point about presentation vs model is that the latter is much more composable.  mixing the two together, as is commonly done in Haskell IO programming throws out composability.  keeping them combined and separable as in TV/Eros gives the best of both worlds (usable & composable).
15:16:29 <vincenz> conal: I think a 'let' concept would be neat in your language.  Right now you only build up trees of TVs.  Which means that if you want to use one slider bar to control both your scaling as well as your rotation, you're in a bit of a pickle (iiuc)
15:16:46 <vincenz> You need a concept of DAGs
15:17:13 <vincenz> (or possibly DGs)
15:19:39 <conal> vincenz: dup
15:19:46 <vincenz> conal: but does this not dup your set of sliders?
15:20:08 <vincenz> or does each TV have a unique id, meaning that duplication binds the two sliders
15:20:35 <conal> dup applies to any "output", which could be a function (including sliders) or to its result.
15:20:39 <shapr> Heffalump: Even so, the wires are already there, so opto-isolation would be worth the cost.
15:20:42 <conal> but maybe i'm not getting the question.
15:21:13 <vincenz> conal: let's say you have a scale function UI and a rotate function UI, now I would like to compose these, and use one slider for both inputs
15:21:26 <gwern> D'OH! all that stuff about replicate and concatMap had already been written by dons! http://cgi.cse.unsw.edu.au/~dons/blog/2007/07
15:21:27 <lambdabot> Title: Haskell hacking
15:22:21 <gwern> so, let's see. I have in the last few days re-invented: and's foldr definition; replicate; the idea of run-length encoding and the next best thing to dons's haskell implemenetation, concat...
15:22:27 <conal> vincenz: i see.  i'd use an identity function and dup its output.  then fuse one copy of the output with rotate's input and one copy with scale's input.
15:22:43 * gwern really needs to spend some quality time reading through the base libraries
15:22:50 <vincenz> conal: I see.  I am trying to imagine what that would look like visually
15:23:32 <conal> vincenz: pull the identity function out of the Parts bin.  right-click "dup" on the output.  then two fusion steps.
15:23:38 * vincenz nods
15:23:55 <conal> each output has a context menu filtered down to the type-compatible ops.
15:24:14 <conal> or pick an op from the Tweak menu, and all compatible outputs highlight.
15:24:59 <jorik808> is haskell fast enough to do eg ... render 3D objects realtime ? like in a fps
15:25:11 <gwern> jorik808: sure it is. we even have a fps
15:25:18 <conal> jorik808: you can use opengl through haskell
15:25:21 <gwern> frag, I believe it is called, which is appropriate
15:25:31 <jorik808> really?
15:25:32 <jorik808> wow
15:25:37 <mwc> jorik808: will be even faster if you just use the OpenGL bindings ;)
15:25:56 <mwc> maybe even hardware accelerated, depending on the underlying OGL libs
15:26:17 <jorik808> wow those screenshots look amazing
15:26:40 <conal> btw, i finally have a linux machine.  when i get haskell etc installed, i'll see if eros will build & run on it.  now i'm working on getting ubuntu to find my wireless network.
15:26:54 <gwern> eros - not the eros operating system I take it?
15:27:04 <conal> gwern: right.
15:27:06 <conal> @wiki eros
15:27:07 <lambdabot> http://www.haskell.org/haskellwiki/eros
15:27:30 * vincenz excuses himself
15:30:16 <ramza3> I am compiling ghc 6.8 and it seems to be stuck on this Lexer.hi .  Should I wait it has been like 20 minutes
15:30:36 <ramza3> -o stage1/parser/Lexer.o
15:30:47 <dons> ramza3: that does take a while, on a slow machine
15:30:58 <dons> check if your machine is swapping
15:31:41 <ramza3> dons: I guess I can check that with top
15:35:27 <faxathisia> so there is actually no implementation of pH?
15:35:44 <dibblego> ?hoogle (a -> Bool) -> [a] -> Bool
15:35:44 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
15:35:45 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
15:36:13 <jeffz> faxathisia: by pH do you mean data parallel haskell?
15:36:17 <faxathisia> yes
15:36:27 <jeffz> faxathisia: hmm, have you read the wiki entry?
15:36:54 <shapr> I uninstalled the flash plugin, and I've gotten a lot more work done since.. but now I want to watch conal's talk!
15:37:21 <mauke> what should I do to upload a library to hackage?
15:37:37 <mauke> the website just says "send mail to ross@soi.city.ac.uk"
15:37:38 <shapr> Get a haskellwiki account, then mail Ross Paterson, I think.
15:37:51 <mauke> ah, so that's Ross Paterson
15:38:10 <mauke> what information should be included in the mail?
15:38:27 <shapr> I did it long ago, and he copied my haskellwiki login info directly.
15:38:36 <shapr> So you should include your haskellwiki login
15:38:42 <shapr> I didn't have to do anything else.
15:38:58 <faxathisia> jeffz: where?
15:39:07 <jeffz> faxathisia: http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
15:39:08 <conal> the google talk worked out well.  i like their editing, and they gave me a t-shirt that says "i gave a techtalk at google" on the back.
15:39:18 <shapr> faxathisia: Yes, Jan Willem-Maessan(sp?) wrote the pH implementation.
15:39:24 <shapr> conal: Awesome! pix?
15:39:31 <shapr> conal: I have two SoC google shirts, I want more googlewear!
15:39:46 <shapr> Now I have to come up with some evil plan to give a tech talk...
15:39:49 <faxathisia> jeffz: no that's not what I meant
15:39:56 <jeffz> faxathisia: ah ok
15:40:33 <mauke> I have an old haskellwiki account whose password I have forgotten
15:41:00 <mauke> how can I get that account deleted?
15:41:03 <monochrom> You could ask it to email the password to the address you registered.
15:41:17 <mauke> I have no idea which email address I used, if any
15:41:17 <sjanssen> mauke: you don't need a wiki account
15:41:34 <EvilTerran> @help free
15:41:34 <lambdabot> free <ident>. Generate theorems for free
15:41:40 <monochrom> You know how to check all your email addresses for new mail? :)
15:41:57 <EvilTerran> @djinn Maybe (Maybe a) -> (Maybe a,Maybe a)
15:41:58 <lambdabot> f a =
15:41:58 <lambdabot>     case a of
15:41:58 <lambdabot>     Nothing -> (Nothing, Nothing)
15:41:58 <lambdabot>     Just b -> case b of
15:41:58 <lambdabot>               Nothing -> (Nothing, Nothing)
15:42:00 <lambdabot>               Just c -> (Nothing, Just c)
15:42:06 <sjanssen> mauke: just email Ross Paterson with your first and last name (and perhaps mention what you'd like to upload), he'll give you a random password
15:42:11 <EvilTerran> thrilling.
15:42:13 <mauke> monochrom: it's none of my currently active addresses :-)
15:42:20 <monochrom> I mean, I would give it a try, wait a few minutes, before giving up.
15:42:22 <mauke> sjanssen: ok
15:43:59 * monochrom does not understand the promiscuity in obtaining a million email addresses just to forget them.
15:44:56 * Beelsebob makes TwigEther naked
15:47:06 <hpaste>  noecksit pasted "lcs_length" at http://hpaste.org/4033
15:47:28 * monochrom does not understand 50% of the things young people of today do, e.g., 80% of blogging.
15:47:29 <noecksit> hello, i am trying to assign polymorphic types to a function, which is two parameters which are list of anything
15:48:04 <monochrom> and the return value is of what type?
15:48:18 <monochrom> Is the return value even related to the parameters?
15:48:20 <noecksit> however i get some weird "No instance for (Eq b)" error
15:48:27 <noecksit> the return value is Int
15:48:32 <sjanssen> noecksit: lcs_length :: [a] -> [b] -> Int
15:48:37 <faxathisia> noecksit: remove lcs_length :: [a] -> [b] -> Int
15:48:45 <sjanssen> except you use fH == sH
15:48:47 <faxathisia> noecksit: then you can load your code into ghci, and do :t lcs_length
15:48:58 <faxathisia> :t elem
15:48:59 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
15:49:00 <sjanssen> this means two things: fH and sH must be the same type
15:49:01 <faxathisia> ^ for example
15:49:07 <monochrom> If you use == or /= , you are using Eq.
15:49:09 <sjanssen> and: that type must support Eq
15:49:27 <sjanssen> lcs_length :: Eq a => [a] -> [a] -> Int
15:49:55 <noecksit> i have "lcs_length :: [a] -> [b] -> Int" in my code
15:50:12 <sjanssen> yes.  That is wrong
15:50:25 <noecksit> oh, so it thinks that fH and sH are different types
15:50:30 <monochrom> For example if I give you two lists of functions, your program will not work, since you apply == but there is none for functions.
15:50:44 <sjanssen> noecksit: you told GHC that they're different types by using different type variables
15:51:08 <noecksit> but if i have "lcs_length :: [a] -> [a] -> Int", it will not work either
15:51:18 <sjanssen> yes
15:51:42 <sjanssen> because you use the (==) operation, you need to constrain that type with Eq
15:51:49 <noecksit> even though the two parameters are supposed to be the same types
15:52:02 <dmwit> You bet.
15:52:04 <EvilTerran> read what people are saying, noecksit
15:52:38 <faxathisia> noecksit: did you try what I said?
15:53:15 <noteventime> Is there a linear algebra module for Haskell available or included in Prelude?
15:53:24 <noecksit> yeah, thanx, i just would like to know why Eq a is necessary
15:53:40 <sjanssen> noecksit: because not all types support Eq
15:53:57 <sjanssen> > id == id -- functions don't support Eq, for example
15:53:58 <lambdabot>   add an instance declaration for (Eq (a -> a))
15:53:58 <lambdabot>     In the expression: id == ...
15:54:14 <faxathisia> noecksit: So what did :t lcs_length give you?
15:54:41 <ramza3> dons; Hmm, still compiling 512MB, 800mhz intel p3.  Well, I guess I can wait
15:54:45 <noecksit> uhh, not in scope..
15:55:03 <faxathisia> noecksit: try :load yourfile.hs , then :t
15:55:10 <noecksit> i used :l yes
15:55:24 <mauke> remove the .o file
15:55:24 <noecksit> i mean i used :l myfile.hs
15:55:32 <mauke> or touch myfile.hs
15:56:00 <noecksit> oh, thats it, thanx
15:56:13 <ramza3> ok, now it moved on
15:56:50 <noecksit> "lcs_length :: (Eq a) => [a] -> [a] -> Int"
15:57:10 <noecksit> thank you
15:57:11 <faxathisia> noecksit: haskell inferred that most general type description from inspecting your code
15:57:35 <faxathisia> noecksit: So you can only make the type of the function the same or more specific than that by adding type declarations
15:57:43 <newsham> ?check let ext f g x = f x == g x in ext id (id :: Int -> Int)
15:57:45 <lambdabot>  OK, passed 500 tests.
15:58:04 <faxathisia> noecksit: What this basically means is since you used == that the two lists have to be instances of Eq, since == is only defined for members of Eq
15:58:16 <EvilTerran> ?check (==) <$> id <*> id :: Int -> Bool
15:58:16 <lambdabot>   Not in scope: `<*>'
15:58:20 <faxathisia> oops, the elements of the lists.. not the lists themselves
15:58:28 <EvilTerran> ?check liftM2 (==) id id :: Int -> Bool -- poo
15:58:29 <lambdabot>  OK, passed 500 tests.
15:59:26 <newsham> let (==^) = liftM2 (==)
16:00:04 <mauke> too bad you can't autolift ==
16:00:04 <newsham> prop_extensionality = (==^)
16:00:04 <noecksit> is lambdabot like a haskell interpeter?
16:00:18 <mauke> > ['y', 'e', 's']
16:00:19 <lambdabot>  "yes"
16:00:22 <newsham> I want hats for autolifting all binops
16:00:37 <newsham> hopefully TH will make it happen
16:01:00 <mauke> I am against the tyranny of hats! FREE THE OPERATORS
16:01:11 <newsham> we all wear different hats
16:01:19 <Laney> :t liftM2
16:01:20 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:01:27 <newsham> ?src liftM2
16:01:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:01:31 <monochrom> Does lcs_length really need == ?
16:01:48 <mauke> judging from the name I'd say yes
16:02:12 <noecksit> monochrom: yeah, it finds the largest common subsequence in a list
16:02:25 <noecksit> monochrom: unless theres smthing else
16:02:25 <faxathisia> really?
16:02:26 <newsham> hats are much more terse than liftM2, while still being explicit and also can still be used infix.
16:03:01 <faxathisia> h I see
16:03:11 <newsham> i will use lhs2tex + hats in all my code from this day forward
16:03:29 <mauke> well, you don't need hats for Num methods e.g.
16:03:31 <newsham> (overbar for liftM, overleftarrow and overrightarrow for half-lifting liftM2, and widehat for liftM2)
16:03:42 <mauke> but it's a nice visual hint
16:03:53 <newsham> implicit can be nice, but can also be confusing
16:04:55 <monochrom> The story goes that Church's original notation for (lambda x. E) was x. E with widehat over it, width of widehat indicating scope.
16:06:26 <EvilTerran> monochrom, that widehat could get very wide...
16:06:41 <newsham> I like the:   \lambda x /.\ p . expr   notation
16:06:43 <monochrom> The printer was not very pleased. :)
16:06:52 <newsham> where p is a predicate guard
16:07:08 <newsham> ie:  \lambda x /.\ x \elem N . x+2
16:07:36 <dmwit> Is /.\ meant to be an "and" with a dot under it, or was it done just like that?
16:07:45 <newsham> yah exactly
16:07:52 <newsham> and with dot.  i dont know its name
16:10:32 <davidL> does someone know why Network.HTTP does not export parseHeader?
16:11:41 <DarkieX> any recommendations for a first haskell book?
16:11:44 <Zao> davidL: Sounds like something reasonably internal, since it exposes processed sets of headers through the rest of the API.
16:11:52 <newsham> dark: hutton's book
16:12:09 <newsham> http://www.cs.nott.ac.uk/~gmh/book.html
16:12:10 <lambdabot> Title: Programming in Haskell
16:12:13 <DarkieX> cheers
16:12:25 <jeffz> DarkieX: you can read a review of the book in issue 7 of the monad reader http://www.haskell.org/haskellwiki/The_Monad.Reader
16:12:26 <lambdabot> Title: The Monad.Reader - HaskellWiki
16:12:46 <newsham> there's lots of good onlin emaerial too
16:13:06 <davidL> Zao: is there any way I can access it without exporting it myself and recompiling Network.HTTP?
16:14:05 <Zao> Copy/paste? :)
16:14:49 <davidL> heh, alright, I guess I'll just do that
16:40:17 <chessguy> @quote
16:40:21 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
16:40:41 <chessguy> @seen sarahbot
16:40:41 <lambdabot> I haven't seen sarahbot.
16:41:22 <faxathisia> heh
16:41:34 <faxathisia> that would get sarahbot and lambdabot to loop
16:42:31 <chessguy> would it?
16:43:23 <dmwit> The "sarahbot says: " in front wouldn't ruin the loop?
16:43:36 <chessguy> dmwit, my thought exactly'
16:45:12 <chessguy> http://en.wikipedia.org/wiki/Lambda-CDM_model -- lambdas are everywhere!
16:45:14 <lambdabot> Title: Lambda-CDM model - Wikipedia, the free encyclopedia
16:45:26 <EvilTerran> -- @where+ @where @where
16:45:51 <EvilTerran> actually, that'd need to be "@where+ @where @where @where", wouldn't it
16:46:13 <allbery_b> it gets output with a leading space, though, doesn't it?
16:46:22 <EvilTerran> @where report
16:46:22 <lambdabot> http://www.haskell.org/onlinereport/
16:46:24 <EvilTerran> no
16:47:20 <dmwit> ?where where
16:47:20 <lambdabot>  @where where
16:47:33 <dmwit> ?where @where
16:47:33 <lambdabot> I know nothing about @where.
16:47:38 <faxathisia> ?where ?where
16:47:38 <lambdabot> ?where ?where
16:47:48 <dmwit> \bot ignores herself
16:47:56 <faxathisia> mbot doesn't ignore lambdabot
16:48:05 <dmwit> Right, I saw that the other day. =P
16:48:11 <faxathisia> :D
16:48:12 <allbery_b> right, @where is smart enough to insert a space before dangerous output
16:48:18 <allbery_b> ISTR dons playing with that some time back
16:48:45 <allbery_b> after he fixed some ACTION-related stuff that was also leaking through
16:49:16 <chessguy> @quote leak
16:49:17 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
16:49:30 <dmwit> One of my favorite drinks, that.
16:49:54 <chessguy> one of my favorite metaphors
16:51:09 <dmwit> two of my favorite psnl's
16:51:22 <chessguy> @vera psnl
16:51:22 <lambdabot> No match for "psnl".
17:34:04 <dylan> of course, lambdabot doesn't see what she says, irc doesn't echo your own messages
17:35:02 <lambdabot> It's pretty bad waking up and discovering what you said the night before in the logs.
17:35:24 <lambdabot> Is this what you humans call "hangover"?
17:36:05 <dcoutts> @vixen but you are a human arn't you?
17:36:06 <lambdabot> no, i'm really a girl
17:36:11 <newsham> dont know the vixen bot you woke up next to?
17:36:12 <dylan> LOL.
17:36:19 <mauke> hah! girls /= human
17:36:47 <newsham> ?vixen what did lambdabot do to you?
17:36:49 <lambdabot> i dunno...
17:36:58 <gwern> right. woman would be 'wifman' in Old English irrc
17:37:54 <dcoutts> gwern: "irrc" is that what they used for irc in Old English?
17:38:38 <dcoutts> Old English irrc leet speek perhaps
17:40:18 <lament> what does wifman mean?
17:40:20 <lament> wif=woman
17:40:24 <lament> man=person?
17:40:28 <shapr> @yow !
17:40:29 <lambdabot> Do I have a lifestyle yet?
17:40:46 <mauke> wif=weave?
17:41:25 <oerjan> wif = wife
17:43:25 <gwern> dcoutts: yes, but no one liked Old English irc. it was too difficult to get the alliteration right
17:43:44 * dcoutts grins
17:44:12 <gwern> you try cracking a quick joke but making sure the two halves are separated by the right caesura and a legal set of alliterating syllables! and you had to throw in some kennings if you really wanted to deliver it right
17:44:30 <Pseudonym> No wonder English humour is odd.
17:45:20 <gwern> people think the scandivians have no humor. the truth is, they have plenty of it, but it's so hard to express in a satisfactory fashion they just remain glumly quiet.
17:46:18 <cedricshock> Anyone an expert on the trace monoid?
17:47:42 <Moosefish> I have a (possibly stupid) question about Parsec and monads -- what's a good place to ask?
17:47:47 <sorear> #haskell
17:47:59 <astrolabe> Asking technical questions directly is often more productive than trying to get people to claim to be experts before they know what the question is.
17:48:11 <sorear> also, there are no stupid questions - only stupid people
17:48:15 <faxathisia> lol
17:48:17 <Moosefish> deal.
17:48:18 <sorear> and what astrolabe said
17:48:57 <mauke> sorear: do you know a yiddish christmas carol?
17:49:03 <cedricshock> sorear: That's harsh.
17:49:09 <sorear> mauke: no
17:49:28 <sorear> cedricshock: I'm not saying he is one (yet, but most likely ever)
17:49:34 <Moosefish> I've got a list of parsers, I'm trying to convert it to a single parser that returns a list of their parsed values. I'm somewhat at lost about how to proceed
17:49:43 <mauke> :t sequence
17:49:44 <dcoutts> @sequence
17:49:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:49:44 <lambdabot> Unknown command, try @list
17:49:49 <dcoutts> oops :-)
17:50:00 <gwern> I have a module question. so I have this setup: ~/monadius/src/Main.hs, ~/monadius/src/Monadius/, and in Monadius/ I have Game.hs, Main.hs, Music.hs, etc. Main.hs is the 'Main' Module, and in Monadius/, eerything is like
17:50:07 <Moosefish> I knew it was a stupid question ;)
17:50:09 <lament> Gefilte! Gefilte! Gefilte Meshuggah! Merry Christmas and happy Hanukkah!
17:50:11 <gwern> 'Monadius.Game', and that's how they all call each other
17:50:25 <gwern> why does this lead to problems when I try to load each one in ghci?
17:50:41 <dcoutts> Moosefish: it's not at all a stupid question, but isn't it cool that it has such a concise answer? :-)
17:50:46 <sorear> gwern: because you need to be at a . where Monadius/Foo.hs is valid
17:50:54 <sorear> gwern: run ghci in ~/monadius/src
17:51:16 <astrolabe> Won't the earlier elements that are sequenced gobble up some of the string?
17:52:41 <astrolabe> dcoutts: Won't the earlier elements that are sequenced gobble up some of the string?
17:53:29 <gwern> sorear: I see. yes, that works, but not in haskell-mode in emacs though
17:53:47 <dcoutts> Moosefish, ascender: ah yes, it depends on whether you want to parse the same string with several parsers, starting from the same point, or if you want to do them one after another.
17:53:59 <dcoutts> oops, not ascender, I meant astrolabe
17:54:04 * dcoutts is clearly tired
17:54:11 <astrolabe> :)
17:54:27 <faxathisia> would you use mapM ?
17:54:35 <faxathisia> to try a set of parsers on a single string?
17:54:37 <faxathisia> as opposed to sequencin
17:54:46 <gwern> ah, I've got it! use the :cd builtin in ghci to go one directory up, where Monadius/ is visible
17:54:49 <Moosefish> dcoutts: Actually, in this case, I'm trying to parse a CSV file, first line is a set of headers, then I'm using the headers to create a list of parsers, which I was planning to use to parse each line
17:55:15 <dcoutts> Moosefish: ah ok, so you are combining them sequentially
17:55:27 <Moosefish> dcoutts: Yes
17:55:49 <dcoutts> ok, then sequence is just what you want
17:55:50 <cedricshock> I'm looking for an example of pactical use of the use of the trace monoid  (possibly darcs, though it isn't exceedingly formal). I'm also trying to get my head around why equivalence among traces survives removing the first or last occurrence of a symbol.
17:55:58 <faxathisia> :t mapM
17:56:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:56:19 <faxathisia> :t return
17:56:19 <dcoutts> Moosefish: possibly with intersperse to parse the field separators or something
17:56:19 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:56:29 <Moosefish> dcoutts: Yup, that's the plan so far.
17:56:35 <faxathisia> mapM return [bunch,of,parsers]
17:57:22 <dcoutts> faxathisia: mapM f = sequence . map f
17:57:48 <cedricshock> I'm aslo wondering how the dependence relation is hooked up to the monoid in such a way that there's dependancy, but no failure. I think that's all magic from the algebraic structure and dependency only making a statement about commutativity.
18:04:00 <faxathisia> Is there any Monad m where (m is not :: * -> *)
18:04:36 <Botje> I hope not ..
18:04:52 <astrolabe> I thought that was part of the definition of a Monad.
18:05:07 <faxathisia> @src Monad
18:05:07 <lambdabot> class  Monad m  where
18:05:07 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:05:07 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:05:07 <lambdabot>     return      :: a -> m a
18:05:07 <lambdabot>     fail        :: String -> m a
18:05:25 <sjanssen> faxathisia: no, there can't be
18:05:25 <faxathisia> where does * -> * come from?
18:05:44 <astrolabe> faxathisia: mentions of 'm a' and 'm b' in the defn?
18:05:48 <sjanssen> faxathisia: * means a type, * -> * means it takes a type to yield a type
18:06:03 <sjanssen> @kind Int
18:06:09 <lambdabot> *
18:06:11 <sjanssen> @kind Maybe
18:06:11 <lambdabot> * -> *
18:06:14 <sjanssen> @kind Maybe Int
18:06:14 <lambdabot> *
18:06:33 <sjanssen> @kind ReaderT
18:06:34 <lambdabot> * -> (* -> *) -> * -> *
18:06:44 <faxathisia> @src ReaderT
18:06:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:07:13 <sjanssen> newtype ReaderT r m a = ReaderT (r -> m a)
18:08:07 <faxathisia> what is r?
18:08:31 <sjanssen> the "environment" that you can access with the ask operation
18:09:11 <sjanssen> but that's neither here nor there, I was just looking for a complicated kind to demonstrate
18:10:16 <faxathisia> @kind ReaderT . Maybe
18:10:17 <lambdabot> parse error on input `.'
18:11:41 <Cale> @kind RWST
18:11:42 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
18:11:58 <faxathisia> @src RWST
18:11:58 <lambdabot> Source not found. That's something I cannot allow to happen.
18:13:43 <QtPlatypus> @foogle
18:13:43 <lambdabot> Maybe you meant: google hoogle
18:13:58 <Botje> @gizoogle
18:13:59 <lambdabot> Empty search.
18:14:17 <faxathisia> I wish the haskell docs were not moved :
18:14:26 <cedricshock> I found the awesome power that a library needs to be able to manipulate concurrent results. It was my suspicion that checking to see if things commute naively was insufficient to compute independence of actions on a state for a programmer. The answer is simple and beautiful; On a monoid with an alphabet of state transitions, two series of state transitions a and b are independent if ab = ba and no transition in the alphabet is used in
18:14:26 <cedricshock> both a and b.
18:14:58 <nburlett> hey all
18:15:15 <QtPlatypus> @hoogle (a -> Bool) -> [a] -> [[a],[a]]
18:15:16 <lambdabot> No matches, try a more general search
18:15:22 <nburlett> is there some way to catch the error thrown by head []
18:15:37 <QtPlatypus> @hoogle (a -> Bool) -> [a] -> ([a],[a])
18:15:37 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
18:15:37 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
18:15:37 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
18:15:41 <allbery_b> Prelude.catch, or use pattern matchng instead (better)
18:16:08 <allbery_b> case l of [] -> do something sane; (e:_) -> ...
18:17:56 <nburlett> prelude.catch hates me
18:18:06 <nburlett> basically, I have some code that uses tagsoup to get some data
18:18:16 <allbery_b> actually, I thinkk Control.Exception.catch is generally better
18:18:17 <nburlett> but, in the case where the webpage is malformed, I don't want to bomb out
18:18:23 <nburlett> that one hates me too
18:18:24 <Korollary> nburlett: Try Control.Exception for ghc
18:18:26 <allbery_b> use pattern matching
18:18:32 <allbery_b> instead of head
18:18:42 <nburlett> that will uglify my code :-<
18:19:11 <allbery_b> safeHead [] dft = dft; safeHead (x:_) _ = x
18:19:29 <allbery_b> then use safeHead list default instead of head list
18:19:56 <nburlett> that doesn't help that much
18:20:04 <nburlett> I have lots of dothis . head . dosomethingelse
18:20:17 <allbery_b> flip safeHead dft
18:20:31 <allbery_b> or define safeHead the other way around and just safeHead dft
18:20:46 <nburlett> right, but that assumes I have a reaosnable default to pass to dothis
18:20:57 <Korollary> Then you need to handle error conditions
18:21:14 <nburlett> yeah
18:21:17 <Korollary> a la Error monad, and throwError
18:21:17 <gwern> ,,, this is odd. so I have 'gaugeOfMissile = 1', ghci -Wall complains about no typesig, and infers it as 't'. fair enough. I change it to 'gaugeOfMissile = 1 :: Int' - and it compiles, complains about it not having a type sig, and says it infers the type sig to be :: Int!
18:21:23 <nburlett> I guess I should just through this into maybe
18:21:56 <Botje> gwern: i'm guessing it's either a bug or a typo.
18:21:58 <allbery_b> gwern: that's correct actually
18:22:33 <gwern> allbery_b: it's correct about the type, yeah, but why is it complainign I didn't give it a sig? I certainly thought I did
18:22:41 <allbery_b> gaugeOfMissile = 1 :: Int -- doesn't actually type gaugeOfMissilecorrectly
18:22:43 <Korollary> gwern: that's not a type sig
18:22:51 <allbery_b> gaugeOfMissile :: Int; gaugeOfMissile = 1
18:23:05 <allbery_b> that's a proper type-sig
18:23:25 <gwern> ...what? then what's the postfix :: doing then?
18:23:37 <allbery_b> it types the 1, not the name gaugeOfMissle
18:23:55 <nburlett> ahh, -Wall
18:24:05 <allbery_b> so haskell then infers that type for gaugeOfMissile
18:24:08 <Korollary> gwern: that's like False. g = False doesn't have a type signature for g either
18:24:36 <gwern> oy. I guess I'd better do some more typing then
18:31:10 <ramza3> 4 hour ghc 6.8 compile....yes
18:31:26 <dibblego> you love it
18:31:49 <ramza3> I should have read the compilation speedups
18:32:03 <Korollary> make -j2 helps really
18:32:25 <sjanssen> ramza3: what sort of hardware?
18:32:44 <ramza3> sjanssen, 800mhz 512MB ram intel p3 thinkpad
18:32:46 <sjanssen> ouch
18:33:00 <ramza3> hehe, I am on vacation
18:33:41 <ramza3> does that go for ancient hardware these days
18:35:38 <thoughtpolice> ramza3: i was compiling 6.8 on a 900mHz p3 with 256 last week I believe
18:35:39 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
18:36:12 <ramza3> thoughtpolice,  how long did it take
18:36:29 * nburlett thought his 1.5GHz G4 was slow
18:36:59 <allbery_b> I could try building it on my old 600MHz P3 laptop... :)
18:37:17 * allbery_b is hoping to retire that machine within the next few months
18:37:21 * nburlett waits for ghc 6.8.2 so he can use it on his Mac :-<
18:37:22 <thoughtpolice> ramza3: didn't get through with the build. it had some weird err to where it kept thinking .cabal files were modified, when they weren't.
18:37:32 <thoughtpolice> i think it failed in the middle of base
18:37:37 <newsham> ramza: what a power house
18:37:40 <thoughtpolice> in any case, I'd wager up till then maybe 2 hours?
18:37:40 <allbery_b> that sounds like a time skew problem
18:37:42 <allbery_b> nfs?
18:37:54 <thoughtpolice> it's offline and configured with nothing like that.
18:38:03 <ramza3> newsham, you guys dont appreciate older hardware.  youngsters
18:38:13 <newsham> hah.
18:38:15 <thoughtpolice> i feel my 900mHz is still useful
18:38:21 <thoughtpolice> which is why I put freebsd and xmonad on it
18:38:33 <newsham> i've got a p3/500 laptop nearby.  whippersnapper.
18:38:49 <newsham> with 128MB
18:39:03 * nburlett does a lot of work on a 300MHz system with 32MB of ram
18:39:05 <thoughtpolice> on an unrelated note, I just got my basic numeric expression compiler to work
18:39:13 <thoughtpolice> generated asm is pretty awful though
18:39:36 * nburlett also has done plenty of work on 66MHz systems with 128KB of RAM
18:39:59 <newsham> I wrote my first commercial software on a 33mhz 68030 running netbsd
18:40:05 <ramza3> I have a macplus, ( at home anyway), ha
18:40:24 <allbery_b> I've scrapped everything older than the 600MHz box
18:40:40 <newsham> all: yah, after about that point you might as well just emulate or vmware.
18:40:48 <newsham> I can still boot my old amiga drive images :)
18:40:50 <nburlett> although, I write embedded software, so....
18:40:54 <newsham> using winuae
18:40:59 <cedricshock> Is there any other free monoid possible in haskell other than []? Or any reason to consider another?
18:41:08 <allbery_b> (well, boxen; I need to finish ripping anything useful (if any) out of the backup 600Mhz Athlon and toss it)
18:41:20 <newsham> wish i had somehow transfered all my c64 stuff from floppy :(
18:41:28 <calvins_> good evening haskellers, anybody know how to get haddock not to choke on bang patterns?
18:44:12 <calvins_> or alternately, has anybody else noticed that bang patterns cause a "parse error" with haddock? maybe something is borked with my install.
18:44:16 <oerjan> cedricshock: free algebras _are_ canonical
18:45:13 <oerjan> although i guess there may still be implementation choices
18:45:29 <cedricshock> oerjan: So I should feel extremely comfortable sticking to []? Will do.
18:45:51 <gwern> @pl (\x -> x*x + x + 41)
18:45:52 <lambdabot> (41 +) . ((+) =<< join (*))
18:46:06 <gwern> @pl (\x -> x + 41)
18:46:06 <lambdabot> (41 +)
18:46:19 <faxathisia> @pl (\x -> a*x^2 + b*x + c)
18:46:20 <lambdabot> (c +) . ap ((+) . (a *) . (^ 2)) (b *)
18:46:29 <cedricshock> I can't remember the Haskell class system. How do I say that everything that's an instance of A and an instance of B is uniformly an instance of C?
18:46:32 <faxathisia> f = (c +) . ap ((+) . (a *) . (^ 2)) (b *) ... find f^-1 ?
18:46:36 <nburlett> woah, what monad is that first one in? (->) ?
18:46:45 <oerjan> cedricshock: i guess Data.Sequence might be an alternative, dependent on how you use it
18:47:33 <byorgey> nburlett: ((->) r)
18:47:35 <gwern> @pl (\x -> (square x) + x + 41)
18:47:35 <lambdabot> (41 +) . ((+) =<< square)
18:47:48 <nburlett> byorgey: ok, that's what I figgured
18:47:49 <oerjan> instance (A t, B t) => C t where ...
18:48:25 <gwern> hm. does 2*(square x) = (square x)+x...
18:48:35 <gwern> no
18:48:42 <cedricshock> oerjan: Thanks. I had a library of abstract algebra structures all defined that way, I don't know where ti went when I switched computers...
18:48:47 <oerjan> cedricshock: although that will give you overlapping problems if you try to define _other_ C instances
18:48:49 <byorgey> take 41 $ map ((41+) . ((+) =<< join (*))) [0..]
18:48:55 <byorgey> > take 41 $ map ((41+) . ((+) =<< join (*))) [0..]
18:49:10 <lambdabot>  thread killed
18:49:23 <byorgey> huh?
18:49:34 <byorgey> > [1..5]
18:49:39 <lambdabot>  [1,2,3,4,5]
18:50:09 <cedricshock> oerjan: Whenever I've had slight overlap problems, GHC has magically sorted them out.
18:50:12 <byorgey> > take 41 $ map ((41+) . ((+) =<< join (*))) [0..]
18:50:13 <lambdabot>  [41,43,47,53,61,71,83,97,113,131,151,173,197,223,251,281,313,347,383,421,461...
18:50:26 <faxathisia> Is there a general method to invert point free function definitions?
18:50:37 <faxathisia> or at least.. some interesting subset of them
18:50:55 <oerjan> faxathisia: you mean @unpl ?
18:51:06 <oerjan> or actual function inversion?
18:51:06 <faxathisia> I mean to actually find the inverse
18:51:27 <byorgey> faxathisia: sure.  (a . b)^-1 == b^-1 . a^-1
18:51:30 <oerjan> well, reverse the ordering of a . chain and each element
18:51:41 <faxathisia> byorgey: nice
18:51:49 <faxathisia> ok hm
18:51:51 <lament> why did lambdabot die?
18:52:01 <byorgey> I don't know, that was strange
18:52:10 <faxathisia> (+x)^-1 == (-x)
18:52:23 <byorgey> faxathisia: yup
18:52:30 <faxathisia> what about ap?
18:52:32 <faxathisia> :t ap
18:52:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:52:38 <byorgey> well, (subtract x) in Haskell =)
18:52:43 <faxathisia> oops :|
18:53:02 <faxathisia> thanks I keep making that mistake
18:53:07 <oerjan> lament: perhaps the machine had a high load temporarily...
18:53:38 <hpaste>  thoughtpolice pasted "basic expression compiler example" at http://hpaste.org/4034
18:53:52 <byorgey> faxathisia: hm, interesting question.  I'd have to think about that one for a while...  it probably depends on the monad
18:55:34 <faxathisia> @src ap
18:55:35 <lambdabot> ap = liftM2 id
18:55:35 <cedricshock> Is there any shortcut in GHC for something like this (which is wrong): type Trace a = (Independent a) => [a]
18:55:42 <faxathisia> m ok yeah
18:55:53 <calvins_> nobody knows if haddock choking on any bang patterns at all is a known issue?
18:55:55 <faxathisia> I think it's a lot harder :p
18:56:15 <faxathisia> flip^-1 = flip ?
18:56:21 <faxathisia> :t flip
18:56:36 <lambdabot> thread killed
18:58:51 <ihope_> I was going to begin a message with "dons: dylan has instructed me to", but I don't know what I'd say next.
18:59:11 <ihope_> Something to do with the difficulty of building lambdabot.
19:02:21 <gwern> who is dylan?
19:03:19 <ihope_> A person here.
19:03:38 <Cale> :t flip . flip
19:03:39 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
19:03:41 <gwern> oh. I was wondering whether it was mebbe the famous people named that or the dylan language or something else
19:04:10 <faxathisia> Cale: it's not id .. so it can't be it's own inverse I think
19:04:11 <faxathisia> ?
19:04:29 <Cale> No, it is.
19:04:50 <Cale> There are functions which are not id, but are their own inverse. They're called involutions.
19:05:00 <Cale> (actually, id is an involution as well)
19:05:16 <Cale> Another common example is rot13
19:05:20 <oerjan> negate for example
19:05:21 <faxathisia> oh right
19:05:26 <Cale> Or negate, yes :)
19:05:30 <faxathisia> I see, I was confused
19:05:33 <dylan> or reverse
19:05:36 <faxathisia> (a -> b -> c) -> a -> b -> c -- really is id
19:05:39 <faxathisia> :t a
19:05:40 <lambdabot> Not in scope: `a'
19:05:56 <faxathisia> since it's type x -> x
19:06:25 <Pseudonym> Complex conjugation.
19:06:25 <oerjan> faxathisia: actually it's a bit more subtle
19:06:35 <faxathisia> why?
19:06:36 <Pseudonym> Technically, reverse isn't an involution, because it's not a total function.
19:06:40 <oerjan> e.g. (a -> a) -> (a -> a) has more solutions
19:07:12 <Pseudonym> But if you restrict it to finite lists, it's cool.
19:07:16 <cedricshock> How do I express this to the type system:? A list [a] is a member of the class "C a" if a is a member of the class D?
19:07:34 <oerjan> D a => C [a]
19:07:39 <Cale> instance (D a) => C [a] where ...
19:08:09 <oerjan> @free (a -> b -> c) -> a -> b -> c
19:08:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:08:10 <Cale> You'll probably need some extensions.
19:08:10 <cedricshock> Ahh, I got close, with instance (Independent a) => Trace a [a]. Thanks.
19:08:22 <oerjan> bah
19:08:27 <oerjan> @free f :: (a -> b -> c) -> a -> b -> c
19:08:28 <lambdabot> (forall x. k . p x = q (g x) . h) => k . f p y = f q (g y) . h
19:09:00 <faxathisia> ..what
19:09:08 <faxathisia> I don't know what is going on there
19:09:12 <oerjan> might be able to deduce that it's id from that
19:09:21 <Pseudonym> This is one of those situations where the points-freeing makes things more confusing.
19:09:39 <Pseudonym> (forall x y.  k (p x y) = q (g x) (h y))
19:09:45 <Pseudonym> =>
19:10:08 <Pseudonym> k (f p m n) = f q (g m) (h n)
19:11:43 <oerjan> @free f :: a -> a -- try something simpler
19:11:43 <lambdabot> g . f = f . g
19:12:06 <ihope_> Just what does free do?
19:12:11 <oerjan> in the last one if you put g = const a, you see that f a = a
19:12:19 <Pseudonym> It gives you a theorem that's true about the function.
19:12:21 <oerjan> so f = id
19:12:22 <Pseudonym> Based only on its type.
19:12:35 <ihope_> Is the theorem always of a certain form?
19:12:42 <Pseudonym> Yes.
19:12:50 <Pseudonym> But it's hard to explain what the form is.
19:13:00 <Pseudonym> @free f :: Int -> Bool
19:13:00 <lambdabot> f = f
19:13:04 <ihope_> Can't be impossible to explain.
19:13:05 <Pseudonym> And sometimes it's degenerate.
19:13:14 <ihope_> Does it know what Int and Bool are?
19:13:26 <Pseudonym> It knows that they can be equality-compared.
19:13:26 <faxathisia> is const an involution?
19:13:38 <oerjan>  @free only gives "interesting" results with type variables
19:13:40 <faxathisia> since the central parameter is just ignored
19:13:57 <faxathisia> (it does not contribute to the calcuation)
19:14:03 <ihope_> Sounds to me that x is an involution if x . x = id.
19:14:07 <Pseudonym> Right.
19:14:07 <oerjan> faxathisia: no
19:14:12 <ihope_> @free (a -> a -> a) -> a -> a -> a
19:14:12 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:14:22 <ihope_> @free f :: (a -> a -> a) -> a -> a -> a
19:14:22 <lambdabot> (forall x. g . h x = k (g x) . g) => g . f h y = f k (g y) . g
19:14:22 <Pseudonym> @free f :: (a -> a -> a) -> a -> a -> a
19:14:22 <lambdabot> (forall x. g . h x = k (g x) . g) => g . f h y = f k (g y) . g
19:14:27 <ihope_> Jinx!
19:14:30 <oerjan> involution: f . f = id
19:14:32 <Pseudonym> Again:
19:14:48 <Pseudonym> (forall x y. g (h x y) = k (g x) (g y))
19:14:53 <Pseudonym> =>
19:15:06 <Pseudonym> g (f h m n) = f k (g m) (g n)
19:15:45 <Pseudonym> The theorems make a little more sense if you think about overloading, say with typeclasses.
19:15:48 <Pseudonym> Example:
19:16:03 <Pseudonym> @free fold :: (a -> a -> a) -> [a] -> a
19:16:03 <lambdabot> (forall x. f . g x = h (f x) . f) => f . fold g = fold h . $map f
19:16:13 <faxathisia> :t const(flip .)const
19:16:14 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> a1 -> b -> a -> c
19:16:16 <faxathisia> "almost" :p
19:16:16 <Pseudonym> Suppose instead you had a typeclass:
19:16:31 <Pseudonym> class Semigroup a where { (<*>) :: a -> a -> a }
19:16:36 <Pseudonym> And you wanted:
19:16:41 <Pseudonym> fold :: (Semigroup a) => [a] -> a
19:16:50 <Pseudonym> You wanted to know the free theorem.
19:16:59 <ihope_> Hmm...
19:17:09 <Pseudonym> The part to the left-hand-side of the => in the theorem essentially sais "f is a Semigroup homomorphism".
19:17:16 <Brian`> hey does anyone use haskell as your shell?
19:17:28 <Pseudonym> In other words, if f is a Semigroup homomorphism, then:
19:17:56 <Pseudonym> f . fold g = fold g . map f
19:17:59 <gwern> Brian`: I don't think so. there are a few very primitive very brief essays in making a haskell based shell but not much else
19:18:03 <Pseudonym> Sorry.
19:18:04 <faxathisia> > ((const).(const)) 3 undefined undefined
19:18:06 <lambdabot>  3
19:18:07 <Pseudonym> f . fold = fold . map f
19:18:13 <gwern> except maybe  lambdashell
19:18:23 <Pseudonym> If f is a semigroup homomorphism, fold commutes with f.
19:18:35 <Pseudonym> In general, that's what free theorems "say".
19:18:39 * ihope_ nods
19:19:10 <Pseudonym> if f has some type, then mappings that respect the relevant structure commute with f.
19:19:31 <Cale> Brian`: there's a nice library called HSH which is useful for shell scripting tasks
19:19:33 <Brian`> gwern, why wouldn't people do it? is it just not worth spending time on it? or is there some issue for using haskell as shell?
19:19:38 <ihope_> @free f :: (a -> a) -> a -> a
19:19:38 <lambdabot> g . h = k . g => g . f h = f k . g
19:19:46 <Brian`> Cale, oh thanks :) I'll take a look at that
19:19:49 <Pseudonym> Here's my favourite free theorem, though:
19:19:55 <Cale> http://software.complete.org/hsh
19:19:57 <Pseudonym> ?free naturalTransformation :: F a -> G a
19:19:57 <lambdabot> Title: HSH
19:19:57 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
19:20:05 <gwern> Brian`: may not have gotten around to it
19:20:10 <Pseudonym> That sums it up.
19:20:20 <gwern> Cale: that's for scripting I thought not interactive use
19:20:22 <ihope_> Are F and G meaningful?
19:20:31 <Pseudonym> It assumes that F and G are functors.
19:20:40 <Cale> gwern: well, you usually wouldn't, but you could, I suppose.
19:20:44 * ihope_ nods
19:21:00 <ihope_> Well, this is a nice free theorem:
19:21:02 <ihope_> @free f :: a -> b
19:21:02 <lambdabot> h . f = f . g
19:21:02 <Pseudonym> ihope_: My version, which isn't in lambdabot, also assumes that A a b is an arrow.
19:21:16 <Pseudonym> If idA :: A a a, then:
19:21:22 <Pseudonym> arr f >>> idA = idA >>> arr f
19:21:30 <Pseudonym> Compare with:
19:21:31 <Pseudonym> ?free id
19:21:33 <lambdabot> f . id = id . f
19:21:48 <gwern> Cale: maybe if you layered a heap ful of stuff and parsers on top, I suppose...
19:22:20 <Cale> Typing runIO over and over might get tedious.
19:22:23 <ihope_> Are these theorems true for Haskell expressions in general, or are things expected to be total or something?
19:24:56 <oerjan> ?free fg :: (b->c) -> (a->b) -> (F a -> F c)
19:24:56 <lambdabot> g . k = p . f => f . q = f1 . h => $map_F g . fg k q = fg p f1 . $map_F h
19:25:20 <faxathisia> ?free f :: a -> b ; g :: b -> c
19:25:20 <lambdabot> Extra stuff at end of line
19:25:24 <faxathisia> stuff :p
19:26:10 <ihope_> @free (f,g) :: (a -> b, b -> c)
19:26:10 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:26:16 <ihope_> @free f :: (a -> b, b -> c)
19:26:17 <lambdabot> (forall q f1. h . q = f1 . g              =>               p q = f1) => (forall f3 f4. k . f3 = f4 . h               =>                f2 f3 = f4) => $map_Pair p f2 f = f
19:26:26 <ihope_> My, how many spaces.
19:26:43 <faxathisia> @free f :: (a -> (b -> c) -> d, (d -> b) -> c -> a, a -> a -> b)
19:26:43 <lambdabot> (forall f1 f2. (forall x f3 f4. k . f3 = f4 . h                                =>                                 p (f1 x f3) = f2 (g x) f4)               =>                q f1 = f2) => (forall f6
19:26:43 <lambdabot> f7. (forall f8 f9. h . f8 = f9 . p                              =>                               g . f6 f8 = f7 f9 . k)               =>                f5 f6 = f7) => (forall f11 f12. (forall y. h .
19:26:43 <lambdabot> f11 y = f12 (g y) . g)                 =>                  f10 f11 = f12) => $map_Triple q f5 f10 f = f
19:26:52 <ihope_> @free f :: (a,b) -> a
19:26:52 <lambdabot> g . f = f . $map_Pair g h
19:27:59 <faxathisia> :t (,)
19:28:01 <lambdabot> forall a b. a -> b -> (a, b)
19:28:05 <faxathisia> ?djinn (a, b) -> b -> a
19:28:08 <lambdabot> f (a, _) _ = a
19:28:20 <ihope_> $map_Pair :: (a -> b) -> (c -> d) -> (a,c) -> (b,d)?
19:28:20 <faxathisia> @pl let f (a, _) _ = a in f
19:28:21 <lambdabot> const . fst
19:28:24 <kilimanjaro> you guys are sick
19:29:00 <byorgey> kilimanjaro: =D
19:29:25 <ihope_> @free join id
19:29:25 <lambdabot> Extra stuff at end of line
19:29:29 * ihope_ hits
19:30:18 <faxathisia> @free Extra stuff at end of line
19:30:19 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:30:22 <faxathisia> aw
19:30:31 <kilimanjaro> byorgey, sorry I just spent 10 minutes or so reading C code generated by a scheme compiler so I was already in a severely weakened state when I saw what lambdabot was saying
19:30:55 <byorgey> kilimanjaro: hehe, no apologies necessary =)
19:31:25 <byorgey> @free extra stuff at end of line
19:31:25 <lambdabot> Extra stuff at end of line
19:31:33 <ihope_> @free Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:31:33 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:31:36 <ihope_> Yay!
19:31:40 <byorgey> =D
19:31:45 <faxathisia> hahah
19:31:52 <byorgey> ihope_: you found a fixpoint of @free!
19:31:59 <ihope_> Indeed.
19:32:11 <ihope_> The fixed-point theorem thingy says it has one.
19:32:27 <byorgey> hm, which fixed-point theorem thingy is that?
19:32:41 <faxathisia> the inverse of (,) :: a -> (b -> (a, b)) should have type (b -> (a, b)) -> a
19:32:47 <faxathisia> in (b -> (a, b)) a comes from 'nowhere' so there is no inverse of (,)?
19:33:08 <ihope_> For every f there is an x such that f x = x.
19:33:27 <ihope_> fix f = f (fix f) proves that quite easily.
19:33:30 <faxathisia> let f x = x+1
19:33:38 <faxathisia> > (undefined
19:33:38 <lambdabot> Unbalanced parentheses
19:33:39 <ihope_> > fix (+1)
19:33:40 <lambdabot>  Exception: <<loop>>
19:33:46 <faxathisia> > undefined + 1
19:33:47 <lambdabot>  Undefined
19:34:19 <ihope_> You know, it'd be nice if lambdabot allowed data declarations somehow.
19:34:26 <faxathisia> > fix (\x -> case x of undefined -> Nothing ; _ -> Just "disproved")
19:34:26 <byorgey> ihope_: seriously.
19:34:26 <lambdabot>      Warning: Pattern match(es) are overlapped
19:34:26 <lambdabot>              In a case alterna...
19:35:01 <ihope_> Am I being annoying?
19:35:24 <byorgey> ihope_: ?  not at all.  I was agreeing with you.
19:35:42 <ihope_> Okay, that's good :-)
19:36:05 <ihope_> I wasn't sure just what you meant by "seriously".
19:36:56 <byorgey> sorry, I guess that's a local idiom.  (where by "local" I'm not sure exactly what I mean... my age group? the US? my region of the US?  who knows? =)
19:37:27 <faxathisia> :t curry.uncurry
19:37:28 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
19:37:56 <marceau> ?free mu :: M (M a) -> M a
19:37:56 <lambdabot> $map_M f . mu = mu . $map_M ($map_M f)
19:38:37 <marceau> ?free return :: a -> M a
19:38:37 <lambdabot> $map_M f . return = return . f
19:39:22 <byorgey> @type (\f -> fst $ f undefined) . (,)
19:39:25 <lambdabot> forall a. a -> a
19:39:31 <faxathisia> :t (flip . uncurry) . (curry . flip)
19:39:31 <lambdabot> forall a b a1 c. (a1 -> (a, b) -> c) -> a1 -> (a, b) -> c
19:39:40 <byorgey> faxathisia: see, (,) has an inverse
19:39:55 <byorgey> @type (,) . (\f -> fst $ f undefined)
19:39:56 <lambdabot> forall b a b1 a1. (a1 -> (a, b1)) -> b -> (a, b)
19:39:59 <faxathisia> byorgey: :o
19:40:06 <byorgey> oh, erm...
19:40:07 <faxathisia> is it really
19:40:20 <ihope_> @djinn (b -> (a,b)) -> a
19:40:20 <lambdabot> -- f cannot be realized.
19:40:47 <ihope_> I don't suppose...
19:40:50 <ihope_> @djinn (forall b. b -> (a,b)) -> a
19:40:51 <lambdabot> -- f cannot be realized.
19:40:52 <byorgey> > (\f -> fst $ f undefined) . (,) $ 3
19:40:55 <lambdabot>  3
19:41:05 <byorgey> it kind of depends on laziness of course =)
19:41:12 <faxathisia> ohhh
19:41:13 <faxathisia> I see
19:41:40 <byorgey> because you get this function of type (b -> (a,b)), but you don't have a value of b to apply it to...
19:41:56 <byorgey> so you can use undefined, and just extract the value of type a from the result
19:41:56 <faxathisia> yeah, that's cool :D
19:43:43 <ihope_> I want a value called "defined" that can only be passed to functions which accept values of all types.
19:44:00 <ihope_> exists a. a, I guess.
19:44:10 <ihope_> @kind exists a. a
19:44:11 <lambdabot> parse error on input `.'
19:44:16 <faxathisia> id, ($), flip, reverse -- are all involutions
19:44:49 <faxathisia> @pl (\f -> fst $ f undefined)
19:44:49 <lambdabot> fst . ($ undefined)
19:45:08 <ihope_> Of course, I could use, say, 3 as my "defined".
19:45:26 <oerjan> faxathisia: and not (whose church encoding is flip btw)
19:45:42 <oerjan> er, flip id
19:45:42 <faxathisia> ah :D
19:46:02 <oerjan> or wait
19:46:11 <oerjan> :t flip
19:46:11 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:46:26 <oerjan> no, just flip
19:46:45 <sw17ch> @src flip
19:46:45 <lambdabot> flip f x y = f y x
19:47:57 <faxathisia> (map f)^-1 = map (f^-1)
19:48:44 <oerjan> ah yes.  should work for any Functor.
19:48:59 <faxathisia> @src Functor
19:48:59 <lambdabot> class  Functor f  where
19:48:59 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:49:36 <oerjan> fmap (f . g) = fmap f . fmap g and fmap id = id are the functor laws
19:49:53 <faxathisia> so (fmap f)^-1 = fmap (f^-1) ?
19:50:07 <oerjan> yeah
19:51:10 <Pseudonym> ?free undefined :: forall a. a
19:51:10 <lambdabot> f undefined = undefined
19:51:24 <faxathisia> great :D
19:51:35 <byorgey> since fmap (f^-1) . fmap f = fmap (f^-1 . f) = fmap id = id
19:51:53 <Pseudonym> Assuming that f is monotonic, it's clear what undefined means there.
19:51:59 <newsham> hah! http://www.cs.nott.ac.uk/~wss/repos/IOSpec/www/unsafe.jpg
19:52:16 <faxathisia> @pl (\f -> fmap f)
19:52:17 <lambdabot> fmap
19:52:24 <faxathisia> @pl (\f -> fmap (g f))
19:52:24 <lambdabot> fmap . g
19:52:35 <faxathisia> @pl (\g -> fmap (g f))
19:52:36 <lambdabot> fmap . ($ f)
19:53:32 <Brian`> hey, when you type "[(*2)] `ap` [0,1,2]", how does it know it has to apply *2 to all the elements 0,1,2? what property of the list makes it to do so?
19:53:49 <faxathisia> I think that is the list monad
19:54:04 <oerjan> @src ap
19:54:05 <lambdabot> ap = liftM2 id
19:54:40 <oerjan> it is essentially the same as [id f x | f <- [(*2)], x <- [0,1,2]]
19:55:18 <Brian`> liftM (*2) [1,2,3,4]
19:55:49 <faxathisia> What is the inverse of ($ f)?
19:56:08 <oerjan> faxathisia: doubtful
19:56:54 <faxathisia> it probably doesn't exist?
19:57:00 <oerjan> to invert it, you need to determine a function solely from its value on f
19:58:10 <cedricshock> On the free monoid, what on does = usually mean, as in "uv = vu" ?
19:59:20 <oerjan> cedricshock: that each side contains the same sequence of elements
19:59:27 <oerjan> in order
19:59:39 <Pseudonym> On a non-free monoid, there are additional axioms involving =, of course.
19:59:51 <marceau> cedric: think of the variables u and v as corresponding to operations. then the equation says that the variables commute, i.e. the operations can be done in either order
20:00:03 <marceau> and still give the same result.
20:03:30 <cedricshock> Ok, here's my problem. Given a symmetric independence relationship (S, S), the paper I'm reading says:
20:04:48 <xpika> @pl (\(x,y)->(f x,f y))
20:04:48 <lambdabot> f *** f
20:05:19 <cedricshock> If the set of elements in a free monoid u and the set of elements in a free monoid v are an element of the independence relation then uv = vu and the intersection of those two sets is null.
20:06:33 <cedricshock> I guess it's only useful for showing from the independence relation that uv =vu, and not really useful for deducing the independence relation.
20:06:59 <marceau> i think that uv = { xy | x \in u and y \in v}
20:07:13 <ramza3> is parsec installed with ghc 6.8
20:07:26 <faxathisia> ramza3: Yes I think so
20:07:36 <xpika> @pl (\[x,y] -> f x y)
20:07:37 <lambdabot> (line 1, column 3):
20:07:37 <lambdabot> unexpected "["
20:07:37 <lambdabot> expecting pattern
20:07:37 <faxathisia> it is in earlier versions
20:07:54 <TSC> ramza3: It's in the libraries with GHC
20:07:59 <ramza3> faxathisia: I guess I could install it; hmm ghc-6.8.1: unknown package: parsec
20:08:14 <marceau> @pl (\(x,y) -> f x y)
20:08:14 <lambdabot> uncurry f
20:08:20 <oerjan> ramza3: i vaguely recall something about extra-libs
20:08:27 <faxathisia> @pl (\x:y:[] -> f x y)
20:08:28 <lambdabot> (line 1, column 7):
20:08:28 <lambdabot> unexpected "["
20:08:28 <lambdabot> expecting natural, identifier, "_" or "("
20:08:33 <oerjan> lots of things got split out
20:08:33 <TSC> Yeah, it's in extra-libs
20:08:56 <cedricshock> marceau: That might make sense... If u and v are literally words it makes no sense to talk about uv = vu and expecting them to have no letters in common.
20:08:57 <faxathisia> @pl (xy -> f (xy!!0) (xy!!1))
20:08:58 <lambdabot> (line 1, column 5):
20:08:58 <lambdabot> unexpected ">"
20:08:58 <lambdabot> expecting variable, "(", operator or ")"
20:09:10 <ramza3> oerjan, looks like they are in boot libraries or something now
20:10:02 <marceau> cedricshock: yeah, and it reminds me of a similar definition for the product of other algebraic objects, such as ideals in rings
20:10:39 <cedricshock> Agh, I thout that = had to be under an equivallence relation to make any sense. The author of the paper hid the introduction of an equivalence class and the typing of u and v to be of that class in the middle of a previous paragraph.
20:13:39 <sclv> wheeooh! I finally got my haskell translation of the clean meteors benchmark to work
20:13:40 <cedricshock> I can feel the permutations coming already. Why must every problem in combinatorics always end up actually being a problem in combinatorics?
20:15:01 <sclv> old benchmark: 4.6s of usertime on my machine
20:15:10 <sclv> new benchnarkL 3.8
20:15:33 <sclv> > (4.6-3.8)/4.6
20:15:36 <lambdabot>  0.17391304347826084
20:15:37 <marceau> ?free k :: a -> M b
20:15:37 <lambdabot> $map_M g . k = k . f
20:16:01 <sclv> now with some arrays replacing lists and unboxing...
20:16:12 <sclv> we are, as they say, cooking with gas.
20:16:32 <marceau> ? free (>>=) :: (a -> M b) -> (M a -> M b)
20:17:00 <faxathisia>      (!!0)^-1 = (:[])
20:17:30 <oerjan> faxathisia: only a one-sided inverse, that
20:17:43 <faxathisia> what do you mean?
20:18:06 <oerjan> normally (f^-1)^-1 = f
20:18:18 <cedricshock> The real problem in trying to merge two traces is attempting to manipulate the traces (actually their representations) to get two independent traces. That'll mean trying to move identical letters to either end of the trace... But the only things that it'll be easy to show anything about are identical letters, so they're probably the only part of the problem worth looking at.
20:18:37 <shapr> mm, code!
20:18:37 <faxathisia> I think that holds
20:18:39 <oerjan> a full inverse would give you back the original list in all cases
20:19:07 <faxathisia> the range is a list of length 1
20:19:13 <Pseudonym> ?free bind :: (a -> M b) -> (M a -> M b)
20:19:13 <lambdabot> $map_M g . h = k . f => $map_M g . bind h = bind k . $map_M f
20:19:18 <oerjan> hm, perhaps
20:19:41 <oerjan> what you are missing is f^-1 . f = id
20:20:15 <faxathisia> > (!!0) . (:[]) $ 58
20:20:22 <faxathisia> > (:[]) . (!!0) $ [58]
20:20:28 <Pseudonym> ?free bind :: M a -> (a -> M b) -> M b
20:20:28 <lambdabot>  58
20:20:28 <lambdabot>  [58]
20:20:28 <lambdabot> $map_M g . h = k . f => $map_M g (bind x h) = bind ($map_M f x) k
20:20:39 <faxathisia> the cases work but the type is stricter than haskell lets me say
20:21:03 <oerjan> ok, restricted to length 1
20:21:18 <faxathisia> > ((\x->[1..x]) . length) [1,2,3,4,5]
20:21:18 <lambdabot>  [1,2,3,4,5]
20:22:18 <oerjan> f . g = id requires f surjective (onto) and g injective (one-to-one)
20:22:36 * shapr boings
20:23:34 <hpaste>  faxathisia pasted "some inversions" at http://hpaste.org/4035
20:24:58 <faxathisia> I cannot figure out ($ f) :p
20:25:18 <oerjan> faxathisia: const
20:26:50 <oerjan> @check \x f -> (($ (f::Bool)) . const) x == x :: Bool
20:26:51 <lambdabot>  Add a type signature
20:27:25 <oerjan> @check \x f -> (($ (f::Bool)) . const) x == (x :: Bool)
20:27:27 <lambdabot>  OK, passed 500 tests.
20:28:41 <faxathisia> wow
20:30:06 <oerjan> there are other possibilities with more restricted ranges
20:33:51 <oerjan> @check \x y f -> ((subtract f) . ($ (f::Int))) (+x) y == ((+x) y :: Int)
20:33:53 <lambdabot>  Couldn't match expected type `t -> a' against inferred type `Int'
20:35:23 <oerjan> @check \x y f -> (((+).subtract f) . ($ (f::Int))) (+x) y == ((+x) y :: Int)
20:35:24 <lambdabot>  OK, passed 500 tests.
20:52:32 * thoughtpolice is thinking about blogging on his recent adventures with making a crappy compiler...
20:52:40 <thoughtpolice> my host is having lots of downtime apparently, though :(
20:52:45 <davidL> is there a function that returns the position of a list in another list? something like elemIndex that works on lists (InfixIndex?)
20:53:01 <allbery_b> not in the standard libs (yet)
20:53:17 <davidL> thanks
20:53:26 <allbery_b> hm, scratch (yet), I'm thinkg of isInfixOf
20:53:34 <allbery_b> which doesn't produce an index
20:59:36 <oerjan> > findIndex (isPrefixOf "test") . tails $ "this is a test ho"
20:59:45 <lambdabot>  Just 10
21:01:06 <Korollary> goalieca: Naslund hat trick?
21:01:11 <oerjan> davidL: ^^
21:01:34 <goalieca> Korollary, ya. apparently. it was ppv so i didn't get to see any of it
21:02:02 <davidL> thanks oerjan, I was thinking there might have been a better way without tails but that works
21:02:13 <allbery_b> dang
21:20:25 <dufflebunk> If Data.ByteString.readFile is used, does it close the file automatically?
21:20:41 <marceau> ?free fmap :: (a -> b) -> (M a -> M b)
21:20:41 <lambdabot> g . h = k . f => $map_M g . fmap h = fmap k . $map_M f
21:23:47 <hpaste>  ramza3 pasted "(no title)" at http://hpaste.org/4037
21:24:04 <Pseudonym> marceau: In particular, if fmap id = id, then:
21:24:14 <Pseudonym> fmap f = $map_M f
21:24:21 <Pseudonym> Where $map_M is, of course, the "standard" fmap.
21:24:51 <Pseudonym> But it's kind of interesting that that's a precondition.
21:25:00 <Pseudonym> And that it's sufficient.
21:40:29 <dufflebunk> Anyone have any suggestions (modules, examples, etc) for reading a binary file that requires seeking back and forth in the file?
21:41:28 <sjanssen> dufflebunk: how big is the file?
21:41:49 <dufflebunk> 2MB to 8GB
21:42:02 <sjanssen> hmm, perhaps to large for mmap, then
21:42:17 <dufflebunk> definitely
21:42:35 <dufflebunk> Wait, haskell has mmap?
21:42:48 <sjanssen> there are bindings in System.Posix
21:42:51 <shapr> build a finger tree?
21:43:11 <sjanssen> there used to be an mmapFile :: FilePath -> IO ByteString
21:43:17 <sjanssen> but that's gone now
21:43:34 <shapr> I wonder if there's an incremental load-from-disk finger tree ... I doubt it.
21:43:48 <sjanssen> sounds tricky
21:44:00 <sjanssen> you'd need to be able to unload parts to avoid running out of memory
21:44:17 <shapr> Is there anything like that right now?
21:44:18 <wli> sjanssen: Manual overlays?
21:44:28 <wli> sjanssen: Sounds like a job for remap_file_pages() in Linux.
21:45:01 <sjanssen> wli: I'm talking about the interaction with the garbage collector
21:45:06 <shapr> Is there anything that can unload parts of its data structure that are on disk already?
21:45:44 <wli> sjanssen: That might also be able to be done with remap_file_pages(), at least in terms of compacting the virtualspace footprint.
21:45:45 <shapr> I mean, anything in Haskell?
21:46:08 <dufflebunk> seeking around and parsing a binary file can't be that hard, can it? I was hoping to use Binary, but it needs ByteStrings which don't seem to allow seeking...
21:46:33 <sclv> anyone have a good link to point to for mixing IArrays and UArrays?
21:46:59 <wli> sjanssen: The idea being that you want to shrink the virtual segment while keeping it contiguous, but also have an idea of which pieces of the mmap()'d region are referencd vs. stale.
21:47:09 <puusorsa> xxyyzz can't be that hard, can it? ..famous last words
21:47:24 <shapr> Weak pointers?
21:47:27 <sjanssen> dufflebunk: Binary is more-or-less strictly linear
21:48:21 <wli> remap_file_pages() basically gets you virtual contiguity with scatter/gather in the offsets of the underlying file.
21:49:51 <wli> There are some other happy things involving scatter/gather on file offsets in recent kernels.
21:51:04 <phlpp> hi
21:52:03 <dufflebunk> sjanssen: Yeah, that's my problem. But I haven't found other than using hGetBuf... more low level that I'd like. At least in C I'd be able to read a whole structure into memory but I can't even do that in Haskell. At least not that I can see...
21:52:56 <sclv> ok, so I have the following as part of a list comprehension: m  <- masks ! c
21:53:14 <sjanssen> dufflebunk: well, you know about hSeek, right?
21:53:32 <sclv> oh, wait, I answered my own question as I was writing it out. never mind.
21:54:44 <dufflebunk> sjanssen: Yeah, I /can/ seek, then read 6 Word16 one by one, then seek read some other stuff... but that's even more low level than I can get in C, where I can read 12 bytes into a struct.
21:55:15 <sjanssen> dufflebunk: I'd use hSeek to navigate, ByteString's IO to read small chunks, and Binary to serialize them
21:56:55 <dufflebunk> I guess that's on par with C then. Too bad there's no way to avoid having to define the data structure and also keep track of the structure's size so the buffer holds enough.
21:59:12 <sjanssen> this is something that C does particularly well
22:01:54 <dufflebunk> Yes, it is. And I have a version in C. I also have a version a masochist wrote in Perl.
22:02:37 <dufflebunk> But I figured I'd never learn haskell if I don't use it to write stuff normal stuff.
22:02:56 <dons> that's a right, imo.
22:03:08 <dons> use it every day, and you'll sure learn it.
22:03:29 <sjanssen> dufflebunk: well, at least the Haskell should beat Perl :)
22:03:55 <sjanssen> dufflebunk: hey, maybe Storable is better here than Binary?
22:04:10 <sjanssen> at least Storable has sizeOf
22:04:40 <dufflebunk> OMG, Perl was _not_ written for reading binary formats.
22:04:53 * dufflebunk looks up Storable
22:05:13 <dufflebunk> http://haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.0/Storable.html is empty
22:05:14 <lambdabot> http://tinyurl.com/2e68kj
22:05:17 <hpaste>  thoughtpolice annotated "basic lexer/parser for shunting yard" with "fixed because copying in X is stupid" at http://hpaste.org/4038#a1
22:05:34 <sjanssen> dufflebunk: try Foreign.Storable
22:06:29 <dons> yeah, or something like hSeek around the file, and read in chunks around that point
22:09:39 <dufflebunk> Ok, thanks sjanssen and dons. I'll try those out and see what works.
22:10:54 <conal> should "-funfolding-use-threshold=16" work as a ghc option?  i get "unknown flags in  {-# OPTIONS #-} pragma".
22:11:05 <dons> its all very doable. i'd certainly use haskell for this task -- bytestrings + binary + hseek i think would be enough
22:11:23 <dons> conal: hmm, i don't think you can set it in a options pragma
22:11:37 <Korollary> conal: Nice talk at google btw.
22:11:44 <conal> Korollary: :) thanks.
22:11:53 <conal> dons: oh -- just an explicit flag
22:12:06 <Korollary> conal: Does TV have a fixpoint widget?
22:12:39 <conal> Korollary: no.  it be easy to add, but don't know what would be artist-friendly
22:21:39 <bos> @seen dons
22:21:39 <lambdabot> dons is in #haskell, #ghc and #xmonad. I last heard dons speak 10m 16s ago.
22:24:00 <nburlett> haskell needs a monadic Prelude
22:24:11 <dons> an applicative Prelude!
22:24:13 <nburlett> so that things like head [] fail
22:24:30 <dons> maybe it should have a total prelude, with no partial functions
22:24:38 <wli> dons: It's the old "error handling is too scattershot" issue you've mentioned I think.
22:24:51 <nburlett> dons: well, I was thinking head :: Monad m => [a] -> m a
22:25:00 <wli> dons: (with which I vehemently agree)
22:25:33 <nburlett> I'm writing a tagsoup program and I don't trust the pages I'm fetching, so I need to make sure my parser doesn't halt the program
22:26:40 <nburlett> it's really annoying
22:28:15 <wli> dons: The stumbling block to my doing any Prelude futzing around is not knowing enough ghc internals to change compiler intrinsics. I don't foresee getting around to learning it within the next 6 months.
22:28:29 <dons> well, you can do a lot with -fno-implicit-prelude
22:28:31 <dons> and loading your own
22:28:50 <dons> we played around with a Functor => Applicative => Monad prelude at work today
22:28:53 <dons> and things seemed to work
22:29:01 <dons> do notation desugared to pure and *>
22:29:21 <P_D> I find myself in need of global variables for some state in a DLL.  I can see doing it with file IO, but anyone have better tricks?
22:29:23 <nburlett> dons: what about (.) ?
22:29:26 <wli> dons: I want to see it. do notation desugaring is a huge obstacle to various things.
22:29:46 <wli> nburlett: (.) == fmap involves zero compiler intrinsics.
22:30:07 <wli> nburlett: do notation desugaring is heavy intrinsics
22:30:08 * nburlett keeps forgetting that (.) is defined in the Prelude and not magics
22:30:43 <dons> nburlett: (.) :: Category cat :: cat b c -> cat a b -> cat a c
22:30:44 <dons> :)
22:31:01 <bos> P_D: IORef?  MVar?
22:31:03 * nburlett isn't familiar with Category
22:31:09 <dons> i was tossing back and forth between (.) and <$> today in some code, due to just the overloading
22:31:20 <dons> there's an amusing table of synomyms and instances that can be drawn up
22:31:24 <wli> dons: I want to see how you pulled off the do notation desugaring.
22:31:25 <bos> ah, Control.Applicative, how we lately love thee
22:31:41 <dons> i'm using them a lot at work for parsers and printers
22:31:48 <dons> which makes sense, of course
22:31:49 <sjanssen> the real problem with an updated Prelude is backwards compatibility and using libraries that don't use your fancy Prelude
22:32:12 <P_D> bos:  Isn't IORef local to the instance?
22:32:16 <dons> instance JSON JSONString where showJSON = showJSON <$> JSString readJSON = unJSString <$> readJSON
22:32:52 <bos> P_D: local to the instance of what?
22:32:54 <dons> a good knowledge of Applicative will be required, within 6 months, i reckon
22:33:08 <wli> sjanssen: I'm not too worried about that. I think the elder preludes were sufficiently sexy that they'd motivate a lot of migration if implementations were extant today.
22:33:10 <nburlett> dons: required for whom
22:33:36 <P_D> bos:  I'm injecting into a C program. my hooks call into the haskell DLL.  I need state across separate calls.  Isn't IORef safe in that you start out from scratch at each call?
22:33:41 <dons> nburlett: for haskellers. they'll be popping up in all sorts of libraries
22:33:51 <dons> and all the core types will have instance Applicative sooner or later
22:33:53 <nburlett> dons: ah, yeah, that's probably true
22:34:06 * nburlett needs to learn Applicative :-<
22:34:07 <dons> i'll be releasing code with them all over soon. xmonad uses them already
22:34:20 <bos> the book uses <$> already, too
22:34:22 <dons> they're really easy. lift >> out of Monad
22:34:24 <sjanssen> P_D: no, the IORef will live as long as the Haskell runtime lives
22:34:41 <P_D> sjanssen:  Ok, great, thanks.
22:35:04 <sjanssen> P_D: assuming your using the unsafePerformIO/newIORef/NOINLINE hack
22:35:09 <bos> P_D: IORef is safe in that you can't do anything with it outside of the IO monad
22:35:09 <sjanssen> s/your/you're
22:36:57 <shapr> @index DefaultD
22:36:57 <lambdabot> bzzt
22:36:58 <monochrom> @src map
22:36:59 <lambdabot> map _ []     = []
22:36:59 <lambdabot> map f (x:xs) = f x : map f xs
22:37:00 * shapr wonders
22:38:31 <shapr> How do I read "instance Data DefaultD a => Default a" ?
22:38:44 <bos> nburlett: "Applicative Programming with Effects" is an easy read
22:39:18 <bos> shapr: are you reading more alexj code? :)
22:39:23 <shapr> bos: How did you guess?
22:39:36 <nburlett> dons: I'm pretty sure I've read that, but that doesn't mean I remember it :->
22:39:37 <shapr> There's some awe-inspiring magic inside HAppS.
22:40:04 <nburlett> shapr: is the happs demo working now?
22:40:40 <shapr> nburlett: It was working for a few hours, then lemmih whipped up some very cool magic that's demonstrated in HAppS-Server/Examples/AllIn.hs, and now the demo is broken again.
22:40:51 <nburlett> *sigh*
22:41:05 <shapr> Lemmih's new magic is very cool though, HAppS now has state-compositional components.
22:41:12 * nburlett gives up on HAppS
22:41:18 <shapr> :-(
22:41:34 <nburlett> seriously, I've never found the example code in a working state
22:41:52 <nburlett> I'd love to learn it, but it never works
22:41:55 <shapr> I think things will work out one way or the other soon.
22:42:10 <nburlett> and now it requires ghc 6.8.1, and I can't run that on my machine
22:42:12 <bos> @pl \f s y -> f y (s y)
22:42:13 <lambdabot> ap
22:42:23 <shapr> Now I'm trying to decipher Lemmih's new magic.
22:42:40 <dons> too much magic is a bit scary for users. you have to be careful.
22:42:45 <shapr> Truly
22:42:45 <dons> scary types are scary
22:42:49 <dons> (now i sound like ndm!)
22:43:05 <shapr> Big magic gives big type errors.
22:43:10 <dons> we fight this a lot in xmonad too, simplifying apis, cleaing up interfaces, keeping types simple simple
22:43:31 <shapr> tutbot: @hello
22:43:40 <shapr> tutbot: !help
22:43:41 <P_D> When you use the unsafePerformIO / newIORef trick, is the state evaluated at initialization or at first readIORef?
22:43:44 * shapr shrugs
22:43:55 <P_D> state computed*
22:44:15 <tutbot> @help
22:44:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:44:23 <tutbot> !help
22:44:41 <bos> P_D: it's computed when its value is demanded, as usual, so first time the result of readIORef is used
22:44:42 <shapr> dons: Igloo's scrap your boilerplate with class is deep magic.
22:44:54 <P_D> bos: thanks
22:44:58 <dons> i'm glad to see cool libs like that getting onto hackage too
22:45:02 <dons> and the safe binary lib
22:46:44 <quicksilver> P_D: well, the IORef is created the first time you call readIORef
22:46:54 <quicksilver> P_D: but the *contents* are created the first time you use the result
22:47:01 <P_D> quicksilver: nod
22:47:10 <quicksilver> but don't do it, it's horrible :P
22:47:45 <P_D> quicksilver:  hacking voodoo, no choice.
22:47:55 * shapr does cargo cult coding.
22:48:08 <sjanssen> ha
22:49:22 <tutbot> a quick question on using Cabal on windows machine: how to set prefix directory? "runhaskell Setup.hs configure --prefix=c:\users\desktop\development" given an error: "unexpected argument: \user\desktop\development"
22:49:43 <P_D> try putting quotes around the path
22:50:06 <sjanssen> one day, shapr found some shiny lambdas on the beach.  And so the cult of #haskell began
22:50:12 * shapr laughs
22:50:26 <shapr> @remember sjanssen one day, shapr found some shiny lambdas on the beach.  And so the cult of #haskell began
22:50:26 <lambdabot> Nice!
22:50:40 <dons> i like twanl's new random lambdabot responses
22:50:54 <dons> or its AI, whichever
22:51:44 <nburlett> @quote beach
22:51:44 <lambdabot> sjanssen says: one day, shapr found some shiny lambdas on the beach.  And so the cult of #haskell began
22:51:50 <nburlett> ah, lambdabot
22:51:58 <shapr> Beach beach beach, that's all I ever hear!
22:52:30 * shapr screwed up that Data.Default instance bigtime..
22:52:32 <P_D> Are there any conditions where it's safe to omit the {-# NOINLINE #-}?  e.g. function never called from haskell
22:53:01 <tutbot> P_D: using quote will not terminate the command. If running with --prefix="c:\users\desktop\development", it prompts >> and is expecting more from command line.
22:53:13 <P_D> use / instead of \?
22:56:01 <nburlett> or use \\
22:56:13 <nburlett> > "c:\users\desktop\development"
22:56:13 <lambdabot>  Illegal escape sequence at ""c:\u..." (column 1)
22:56:16 <Lemmih> dons: It's way less magical than the previous code.
22:56:20 <dons> cool :)
22:56:28 <dons> less magic == more magicians
22:56:54 <Brian`> :t guard
22:56:56 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:56:59 <dons> and we're all about training up more magicians :)
22:57:03 <nburlett> @remember dons less magic == more magicians
22:57:04 <lambdabot> It is forever etched in my memory.
22:57:05 <thoughtpolice> dons: will the book cover applicative functors given they're going to be around so much more in the future, apparently?
22:57:15 <dons> thoughtpolice: yep
22:57:58 <thoughtpolice> well i'm waiting. lots of stuff that i have yet to grok or even start with that it looks like it will address. :)
22:58:32 <tutbot> using \\ or " or \" are not working. Seems the issue being parsing "C:". using --prefix=c:\\users\\desktop gives error: "unexpected argument: \\user\\desktop"
22:58:39 <conal> thoughtpolice: Applicative is simpler than Monad.  If you know monadic return & ap, you know Applicative.
23:00:11 <wli> I don't understand ap. It's too complicated.
23:00:11 <dons> yeah, there's nothing much to learn, but its great to have this simpler, cleaner structure distinguished from Monad
23:00:16 <thoughtpolice> conal: i've looked at the wiki and the pearl but i'm still at a loss. i don't think its a case of not knowing, but not understanding how to apply.
23:00:16 <dons> so you can be more precise
23:00:18 <wli> I understand fmap, return, and join.
23:00:40 <dons> :t toUpper <$> getChar
23:00:49 <lambdabot> IO Char
23:00:51 <conal> thoughtpolice: yeah.  i don't know of a simple tutorial.
23:00:57 <quicksilver> thoughtpolice: have you ever used liftM2?
23:01:03 <dons> there isn't one, but we can proobably produce a few on short order
23:01:16 <Stinger_> :t <$>
23:01:17 <lambdabot> parse error on input `<$>'
23:01:23 <quicksilver> (or indeed, liftM3)
23:01:27 <Stinger_> :t (<$>)
23:01:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:01:35 <conal> dons: e.g., parsing.  i don't think i've ever seen a monadic parser that wasn't really applicative.
23:01:36 <thoughtpolice> quicksilver: no, sadly?
23:01:54 <quicksilver> thoughtpolice: ah, well, when you do, that will help you see what applicative is for.
23:02:14 <quicksilver> thoughtpolice: have you ever written code like this: do { x <- a; y <- b; return (f x y) }  ?
23:02:30 <quicksilver> thoughtpolice: and been 'annoyed' by the fact that felt over-linear, somehow?
23:02:46 <thoughtpolice> i've never used it but I know what it does, it lifts functions into your effectful world (same with liftM3, etc.. only for more parameters)
23:03:00 <thoughtpolice> quicksilver: yeah somewhat
23:03:34 <quicksilver> thoughtpolice: well, Applicative style stops you needing to give silly names to x and y
23:03:37 <quicksilver> you just write
23:03:45 <quicksilver> f <$> a <*> b
23:04:07 <dons> shorter code, in lots of cases
23:04:12 <quicksilver> thoughtpolice: which some people suggest is simpler and more readable
23:04:13 <nburlett> 'night all
23:04:19 <thoughtpolice> quicksilver: yeah that's what the paper pointed out about being able to break from wiring these things to names for something so simple; after that it lost me though
23:04:27 <olsner> isn't that liftM2 f a b?
23:04:33 <quicksilver> then the interesting question is "If we always write in this form, and don't use do notation at all, what do we have?"
23:04:36 <quicksilver> olsner: yes, exactly
23:04:43 <conal> olsner: yes.  aka liftA2 f a b
23:04:57 <dons> yeah, it makes do notation less compelling, in some way
23:04:57 <quicksilver> and the answer is "if we never use do notation, we have a weaker language, so a larger class of things"
23:05:02 <quicksilver> that class is Applicative
23:05:08 <quicksilver> all Monads + also some more stuff
23:05:22 <quicksilver> basically it can handle side effects but it can't "wire the results around"
23:05:28 <dons> also, why have special syntax for the Monad class, when we've all these other slightly related classes of computations floating around
23:05:39 <quicksilver> "do" notaton is arbitrary wiring diagrams
23:05:55 <quicksilver> Applicative is a very particular simple case of wiring diagrams
23:06:05 <quicksilver> where intermediate results from one bit can't be used in a neighbouring bit
23:06:29 <dons> it would be nice to ahve x; y ;z desguar to Applicative-constrained only code
23:06:40 <thoughtpolice> quicksilver: so basically it's a form of composition that handles side effects; you just compose rather than giving things names for such stuff?
23:06:58 <quicksilver> yes
23:07:57 <thoughtpolice> i.e. you can still do like dons said with the whole toUpper <$> getChar thing, but you can't arbitraily store that getChar for use with a toUpper that might occur 5 lines ahead. instead of naming you compose and just use more glue
23:08:25 <wli> dons: How did you change the do notation desugaring?
23:08:25 <thoughtpolice> well, i guess you might consider it less glue, but I think you know what I mean...
23:09:58 <dons> wli, so the notatoin is rebindable, and iavor said that >> just binds to whatever is in scope, be that >> defined in Applicative or elsewhere
23:11:07 <wli> dons: Did this involve hacking on ghc?
23:11:38 <thoughtpolice> quicksilver: thanks. i'll just have to think of applicative as less wiring and more compositionality.
23:12:20 <conal> thoughtpolice: to ease into Applicative, start using liftM, liftM2, liftM3, etc in your monadic code.
23:12:39 <dons> wli, nope
23:13:11 <thoughtpolice> conal: i'll give it a shot.
23:13:53 <wli> friendly12345: No. That's all that made it.
23:19:19 <osfameron> @unpl (\s -> (+s) *** succ)
23:19:20 <lambdabot> (\ s -> (\ a -> a + s) *** succ)
23:19:28 <osfameron> @pl (\s -> (+s) *** succ)
23:19:28 <lambdabot> (*** succ) . (+)
23:19:33 <osfameron> eeeek!
23:20:47 <goalieca> haskell. the new perl :-0
23:21:25 <osfameron> dons had a comment about that - that Perl obfuscation is rather orthogonal to the meta refactorings you can do in Haskell
23:21:45 <osfameron> (though that's not entirely fair, as not all of Perl refactoring is just golfing...)
23:22:39 * osfameron stands on his head and contemplates the pointless version
23:22:57 <osfameron> interesting.  From this angle, I can understand it better (though now I feel a little dizzy)
23:33:12 <zeeeee> can template haskell extend string literals syntax and perform string interpolation using variable names? e.g. world="world"; mystring = """hello, {world}{replicate 3 '!'} i'm "haskell." \o/  """
23:39:09 <olsner> template haskell is likely able to do whatever it pleases with strings, e.g. map a string to a series of show and appends
23:39:32 <olsner> but iiuc, you have to add template brackets and a call to a template function to expand the string
23:40:12 <olsner> so printf could be a simpler way to do the same thing
23:40:51 <scook0> yeah, you'd have to have $( interpolate "Hello, {world}" ) or something like that
23:41:26 <scook0> it'd work fine, but syntactically it seems a little heavy
23:44:48 <zeeeee> well, i'm also wondering about the syntax, e.g.
23:45:08 <zeeeee> ", \, etc. literals in strings
23:45:54 <olsner> \ basically works as in the C-family languages
23:46:04 <dons> ?userrs
23:46:04 <lambdabot> Maximum users seen in #haskell: 418, currently: 361 (86.4%), active: 7 (1.9%)
23:46:05 <zeeeee> olsner, so basically, no
23:46:09 <zeeeee> ?
23:46:12 <olsner> \n for newline, \" for quotation mark, etc
23:46:38 <zeeeee> i mean, that's just the same as haskell's strings
23:46:42 <olsner> > "\"hello, I'm \"haskell.\" \\o/ \""
23:46:44 <lambdabot>  "\"hello, I'm \"haskell.\" \\o/ \""
23:46:48 <osfameron> hehe, "A ‘newbie’, in Haskell, is someone who hasn’t yet implemented a compiler. They’ve only written a monad tutorial."
23:47:28 <zeeeee> olsner, my question was about whether i can change this in TH
23:47:58 <olsner> oh, I see, then I guess no, since that's probably hard-coded into the lexer
23:48:11 <zeeeee> hrmph
23:54:38 * wli vaguely focuses.
23:56:32 <olsner> wli: you're still in #haskell though - if work is to be done, leaving is often a necessary first step
23:56:57 * wli doesn't get to focus when working. It's all nonstop interrupts.
23:57:30 <olsner> hmm... your IRQ assignments may need revising
