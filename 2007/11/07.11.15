00:04:40 <ivanm> roconnor: maybe something like this? http://citeseer.ist.psu.edu/308745.html
00:04:44 <lambdabot> Title: Numerical Integration with Exact Real Arithmetic (ResearchIndex)
00:04:47 <ivanm> haven't actually looked at the paper yet though
00:04:52 <ivanm> so it might be too over the top
00:11:24 <whoopsbob> One of my functions returns a Maybe. How do I check what I got? I'm trying to do a guard class for it, so something like ` | f n == Just a = a ', except somethin that's valid syntax :) Something to do with monads?
00:11:29 * osfameron showed gf some haskell this morning
00:11:51 <osfameron> she really liked [1..10] sequences, but was disappointed that you couldn't just do [1*1,2*2.. 10*10] ;-)
00:12:57 <slava> map sq [1..10] ?
00:13:45 <osfameron> yeah, she liked that
00:14:09 <osfameron> but I think the whole "programming by example" thing is really appealing for a non-programmer (actually for a programmer too)
00:14:36 <Korollary> whoopsbob: try f (Just a) = whateveryouwanttodowitha
00:16:24 <whoopsbob> Korollary: That's not quite what I want. I call (f n). This returns a maybe. If it's a `Just a', I want to do somethin with a. Otherwise, I want to do something else. I'm not trying to define f here.
00:17:39 <KatieHuber> case f n of (Just a) -> something; Nothing -> somethingelse ?
00:19:37 <shachaf> @ty maybe
00:19:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:20:27 <shachaf> whoopsbob: Maybe you can give a little more context?
00:23:12 <shachaf> whoopsbob: case f n of Just a -> ...?
00:23:17 <shachaf> whoopsbob: isJust?
00:23:51 <whoopsbob> shachaf: Ok, so I have a smallestFactor function. If `n' has a factor `m' (1 and n don't count), smallestFactor returns Just m. Otherwise (aka n is prime), it returns nothing. In the calling function, if it has a factor, I do something with it, otherwise I do something else. So I need to pull out the value of the maybe
00:24:59 <shachaf> whoopsbob: What's wrong with case f n of/maybe ... (f n)?
00:25:06 <shachaf> (Those are equivalent.)
00:25:59 <shachaf> > maybe 5 (+1) Nothing
00:26:00 <lambdabot>  5
00:26:02 <shachaf> > maybe 5 (+1) (Just 3)
00:26:02 <lambdabot>  4
00:26:31 <shachaf> > case Nothing of Just n -> n + 1; Nothing -> 5
00:26:32 <lambdabot>  5
00:26:39 <shachaf> > case Just 3 of Just n -> n + 1; Nothing -> 5
00:26:51 <lambdabot>  4
00:26:52 <whoopsbob> I'm a bit by the confused by the syntax, so I'm trying to get it to work :)
00:27:09 <shachaf> @paste if it helps.
00:27:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:28:07 <whoopsbob> I get the case of part, but now I'm trying to assign the value of that to something. So `g n = case ... of ...' which doesn't seem to work
00:28:41 <visof> > map Char.toUpper "hello visof"
00:28:48 <shachaf> It should.
00:28:56 <lambdabot>  thread killed
00:30:47 <whoopsbob> schemelab: Whoops, I just has a typo in the line before. Thanks!
00:30:57 <whoopsbob> shachaf, even
01:06:09 <dblhelix> question: do the binary distributions of ghc 6.8.1 include the extra libs?
01:13:34 <tibbe> what's the password for the GHC track?
01:13:48 <quicksilver> guest guest
01:29:49 * osfameron tries to work out why "join" is called "join"
01:30:20 <ddarius> Probably go back to Wadler's "Comprehending Monads"
01:30:23 * osfameron worked through the "trivial monad" exercises, and that's the most confusing bit
01:30:41 <osfameron> ah, yes.  I found I didn't have that on my laptop after all - will download it.
01:32:04 <Phillemann> Is that a good paper for the monad beginner? :)
01:32:10 <osfameron> the other thing that confused me was the join implies taht all monads can wrap themselves
01:32:18 <osfameron> e.g. Just (Just 2), [[3]] etc.
01:32:28 <osfameron> but I don't understand what that means for IO at all
01:32:29 <ddarius> Phillemann: I was responding solely to the "join" comment
01:32:36 <Phillemann> ddarius: Ah, okay...
01:32:38 <osfameron> what's a good one for the beginner?
01:33:04 <Heffalump> osfameron: it doesn't really mean very much beyond that any monad can wrap any value
01:33:21 <osfameron> occasionally people do say that Wadler is clear and more grokkable than the "easy" explanations
01:33:22 <quicksilver> osfameron: IO (IO a) means
01:33:28 <Heffalump> IO is far easier to understand in terms of >>= than join.
01:33:37 <quicksilver> osfameron: an IO computation which produces an IO computation which produces a value of type a
01:33:49 <quicksilver> osfameron: so, I do "some" IO and generate a bunch of instructions.
01:33:58 <quicksilver> osfameron: those instructions specify how to do "some more" IO and generate an a
01:34:05 <osfameron> Heffalump: oh, I don't understand how "join" proves anything apart from that a monad can wrap itself... :-(
01:34:13 <quicksilver> osfameron: does that help?
01:34:20 <ddarius> osfameron: The essence of functional programming is really enjoyable
01:35:05 <osfameron> quicksilver: ah, I guess so, yes that seems to make sense
01:35:13 <quicksilver> osfameron: so, what "join" says is:
01:35:24 <quicksilver> osfameron: we can do "some more" IO immediately after "some" IO if we want
01:35:27 <quicksilver> instead of waiting
01:35:28 <osfameron> ddarius: hmm?  Oh, is tEoFP a book? ;-)
01:35:45 <quicksilver> so "join" is saying: if you have a plan involving {some IO, some more IO, then produce a}
01:35:57 <quicksilver> you can convert that into {a big bunch of IO, then produce a}
01:36:03 <osfameron> ddarius: ok, yes.  ta
01:36:04 <quicksilver> that is, join :: IO (IO a) -> IO a
01:36:07 <Heffalump> osfameron: join doesn't say that monads can wrap themselves, that follows anyway; what join does is say that we can undo the unwrapping.
01:36:46 <Heffalump> for IO, I think it's easiest understood by deriving >>= from join and fmap - m >>= f = join (fmap f m)
01:37:01 <quicksilver> whereas, I totally disagree :)
01:37:11 <quicksilver> I find join much easier to understand than >>= ;)
01:37:35 <osfameron> quicksilver: ok, but though the word "join" implies joining togehter a bunch of IO, the function doesn't do that.  It just unwraps one layer.
01:37:36 <Heffalump> oh wow, 6.8.1 is significantly slower than it can be due to a SPJ typo
01:37:44 <Heffalump> 6.8.2 should *really* rock...
01:37:50 <quicksilver> osfameron: it does join it together, in a sense
01:38:00 <quicksilver> osfameron: it runs the two bits of IO, one after another
01:38:06 <quicksilver> osfameron: that is a kind of joining
01:38:48 <doserj> join (some IO, (some more IO, result)) = (some IO; some more IO , result)
01:38:57 <quicksilver> yeah
01:39:12 <osfameron> but there's only one "a" in join :: IO (IO a)  ?
01:39:17 <quicksilver> so you've "joined" some IO and some more IO into one combined lump if IO
01:39:28 <quicksilver> osfameron: yup. You only produce one result at the end.
01:39:35 <quicksilver> osfameron: the choice is about doing all the IO in one go
01:39:40 <quicksilver> or doing part of it now, and part of it later.
01:40:25 <sjanssen> Heffalump: oh?
01:41:43 <osfameron> quicksilver: I still don't see what the 2 IO inputs are.  I'll look over the wadler papers and do some more exercises in my CFT I think...
01:42:10 <quicksilver> osfameron: it's not really right to think of them as inputs
01:42:20 <quicksilver> osfameron: think of them as sets of instructions
01:42:41 <Heffalump> sjanssen: see the ghc-users list
01:42:41 <quicksilver> osfameron: think of them as chunks of C code even, if that gives a good mental model
01:43:30 <sjanssen> Heffalump: ah, found it
01:43:34 <sjanssen> neat :)
01:43:47 <quicksilver> One concrete model of IO a looks a little like this: [IOPrim,IOPrim,IOPrim,IOPrim],<somehow return a result a>
01:43:50 <Heffalump> and people were already raving about 6.8.1
01:43:53 <osfameron> quicksilver: eeeek, C!  I can think of them as a coderef or whatever if that's useful.
01:44:01 <quicksilver> a model of IO (IO a) looks like this
01:44:35 <quicksilver> [IOPrim,IOPrim,IOPrim,IOPrim],<somehow return [IOPrim,IOPrim,IOPrim,..] <somehow return a> >
01:44:46 <quicksilver> so your first IO action runs some primitives
01:44:54 <quicksilver> but what it returns, is another bunch of primitives
01:45:00 <quicksilver> (which you will presumably run later)
01:45:08 <quicksilver> (and only then will you eventually get your result of type a)
01:45:20 <quicksilver> join "flattens" that structure
01:45:26 <quicksilver> giving a longer list of prims :)
01:45:55 <osfameron> so the a in IO (IO a) is already a list of [IOPrim] ?
01:45:58 <doserj> x::IO (IO a) is a computation that does some IO and produces (a computation that does some more IO and produces a result of type a)
01:46:39 <doserj> join x :: IO a is then (a computation that does some IO and some more IO) and produces a result of type a
01:47:32 <doserj> the a in IO (IO a) has nothing to do with IO!
01:47:47 <quicksilver> osfameron: no, the 'a' isn't
01:47:52 <quicksilver> osfameron: the (IO a) is
01:48:03 <quicksilver> osfameron: the "result" of IO (IO a) is not "a". It's "IO a".
01:48:37 <quicksilver> osfameron: maybe a concrete example will help
01:48:52 <quicksilver> osfameron: suppose you are doing some clever runtime optimisation
01:48:58 <quicksilver> a bit like fftw does
01:49:03 <osfameron> fftw?
01:49:16 <quicksilver> given a set of parameters, you can return the 'ideal' algorithm to do something
01:49:19 <quicksilver> like a perfect hash, maybe
01:49:28 <quicksilver> then you have a computation, which returns a computation
01:49:36 <osfameron> ok
01:49:40 <quicksilver> fftw is a fast fourier library but that doesn't matter :)
01:49:49 <quicksilver> that's what IO (IO a) means
01:49:57 <quicksilver> it's a computation which returns a computation
01:50:15 <quicksilver> maybe it goes and checks stuff about your current system (disk space? CPU? network connectivity?)
01:50:25 <quicksilver> and then it returns a special computation which is optimised for your system.
01:50:48 <osfameron> ok.  But when I write: do this; that; return whatever  I'm *not* doing special computations that return other computations
01:50:59 <quicksilver> no, indeed not
01:51:10 <quicksilver> normally you don't use things like IO (IO a) directly
01:51:14 <quicksilver> but that's what they are
01:51:17 <doserj> if whatever = putStrLn "Hello World", then you do
01:51:45 <quicksilver> so 'join' is the obsevation that you could choose to run that special computation immediately, instead of later
01:51:52 <quicksilver> IO (IO a) is two-stage.
01:51:55 <quicksilver> you can run part now and part later
01:52:03 <quicksilver> join takes the decision to run it all at once, instead
01:52:58 <abell> I have been working on a web app for some time, but I have some problems with html generation. In some cases I need to attach information to an html fragment so that it gets recovered at an outer level (where pieces are put together into the complete page) or I might need to get information, like a unique form id, depending on the final structure. I am thinking of something behaving both like html and a state monad, but I don't know how to put
01:52:58 <abell> the two concepts together.
01:53:18 <abell> I would like to do   thediv << ( getUniqueId >>= makeFormWithId ) +++ needsCss ( "foo.css" ) +++ ( paragraph ! [ theclass "foo" ] << "Hey, there" )
01:53:55 <abell> I guess +++ would be analogous to >>
01:53:59 <abell> Any hint?
01:54:35 <kfish> abell, a StateT wrapping (CGI Html) ?
01:54:47 <osfameron> quicksilver, all: I don't think I'm understanding, but thanks for you time!  (I'll come back to this later once I've read those papers)
01:55:42 <klugez> Integration of a general function over a finite interval. quad_qag implements a simple globally adaptive integrator using the strategy of Aind (Piessens, 1973). The caller may choose among 6 pairs of Gauss-Kronrod quadrature formulae for the rule evaluation component. The high-degree rules are suitable for strongly oscillating integrands.
01:55:53 <klugez> Oops, sorry.
01:56:12 <kfish> abell, and then try to avoid mixing up cgi, html and state in the same function, or it will get ugly and you'll go nuts :-)
01:56:42 <quicksilver> sjanssen: "I omitted a prime (writing env instead of env') in a late fix,"
01:56:46 <abell> kfish, I would just like to make Html more powerful, but keeping the same syntax
01:56:52 <quicksilver> sjanssen: isn't that what you were warning me about the other day? :)
01:57:08 <sjanssen> quicksilver: ha, it is indeed
01:57:31 <abell> State would be very limited, just letting me enforce page-global coherence while generating "local" html fragments
01:58:22 <abell> So that I wouldn't have to explicitly pass back and forth global counters
01:58:55 <kfish> abell, i find that doing html manipulation in purely Html functions is kinda nice -- you can pull values out of state and pass them to the html rendering functions to do the formatting
01:59:55 <abell> kfish, how do you pull values out of state? Do you mean passing them to the function generating the html?
02:00:46 <kfish> abell, yep
02:01:58 <quicksilver> sjanssen: observation: if you never have more than one variable of the same type in scope, the type checker will catch all such mistakes.
02:02:09 <abell> kfish, but it would get quite cumbersome when you have a deep call tree. It reminds me of the problems solved by the state monad, keeping global parameters transparent in most cases
02:02:11 <quicksilver> sjanssen: so it's very handy if you manage to preserve that as much as possible.
02:02:22 <quicksilver> abell: that's the reader monad :)
02:02:31 <quicksilver> abell: state monad is only if you need to change those global parameters too.
02:03:15 <sjanssen> quicksilver: yeah, I've read that some people use: \env -> foo env >>= \env -> bar env
02:03:38 <sjanssen> the variable shadowing ensures that you can't access a stale env
02:03:47 <abell> quicksilver, I also need to change them, like telling the outermost level that I am going to use classes contained in a certain css file
02:03:57 <Heffalump> sjanssen: yeah, I do that
02:04:05 <abell> or increasing a global counter
02:04:22 <Heffalump> only I got caught out when I changed something like env <- return (foo env) into let env = foo env :-)
02:05:06 <ddarius> Those are really annoying bugs to catch
02:05:51 <abell> I was thinking of creating a new Html type parametrized by a monad which could be a state or reader or statet io or whatever, but it is quite a lot of work and I'm not sure I would eventually succeed :-(
02:06:23 <sjanssen> abell: perhaps you could use something similar to the Writer monad?
02:07:13 <abell> sjanssen, as I see it, the difficulty is putting html and the monad together while keeping an efficient syntax for html generation
02:07:41 <sjanssen> writer seems pretty good for this
02:08:24 * Heffalump has combined Html and monads
02:08:33 <sjanssen> simply: tell $ valid html fragment here
02:08:52 <Heffalump> you just have to import all the html combinators qualified and rewrite them using tell
02:08:55 <Heffalump> so you can just write them directly
02:09:36 * Heffalump has to go
02:11:01 <abell> Thanks, guy. I will look into the possibilities of write and see if it's what I need
02:11:12 <abell> s/guy/guys/
02:11:45 * sjanssen notes that this sounds like a great job for idiom brackets
02:12:23 <alexj> @seen ndm
02:12:24 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 2d 9h 48m 2s ago, and .
02:12:25 <quicksilver> sjanssen: *nod*
02:12:49 <quicksilver> sjanssen: although of course there are cases when you do want a stale env, or at least part of it. I suppose you should grab that in a "let" in the correct scope though.
02:12:53 <sjanssen> alternatively, that insane monadic subexpressions proposal
02:13:43 <quicksilver> sjanssen: someone observed that it's often sufficient to use <*> and lots of 'return'
02:13:51 <quicksilver> (return on the pure bits, obviously)
02:14:06 <quicksilver> I wonder if it might be interesting sugar to overload outfix [] as return
02:14:09 <quicksilver> then you could write
02:14:14 <vincenz> quicksilver: you mean ap?
02:14:21 <sjanssen> @remember RichNeswold Wow! I knew the Haskell community has been growing... but there's a brazillian of us?
02:14:22 <lambdabot> I will never forget.
02:14:27 <quicksilver> f <*> a <*> [b] <*> c <*> [d] <*> e
02:14:36 <vincenz> oh right, applicative
02:14:38 <quicksilver> where b and d are pure values and need 'return'ing
02:14:39 <vincenz> pure f :)
02:14:48 <quicksilver> well, make it <$> at the beginning
02:14:53 <sjanssen> quicksilver: some sort of bracket would be nicer, especially for operator heavy code
02:15:07 <alexj> abell: another alternative is to produce a normal haskell datatype focus on converting that datatype to xml.
02:15:09 <alexj> or html
02:16:30 <quicksilver> sjanssen: it still looks ugly when you have deeply nested stuff though
02:16:34 <quicksilver> sjanssen: consider this one:
02:16:40 <doserj> quicksilver: doesn't that make your code ambiguous?
02:17:04 <abell> alexj, I also thought of something like that: a tree where nodes are either html fragments or annotations, if that's what you mean
02:17:06 <quicksilver> f (g (a,b,<I want monadic bit here,d,e)) h j
02:17:21 <quicksilver> you have to write something horrible like:
02:17:27 <alexj> abell: what is the data you are trying to produce?
02:17:41 <sjanssen> the problem there is the tuple syntax
02:17:47 <quicksilver> f . g . (\x -> (a,b,x,d,e)) <*> monadic bit <*> pure h <*> pure j
02:18:01 <quicksilver> something along those lines, anyway
02:18:01 <doserj> quicksilver: ah, it just makes it more general, ok.
02:18:08 <quicksilver> doserj: yeah, it makes [foo] more general
02:18:19 <quicksilver> doserj: [foo] = pure foo for any applicative
02:18:36 <quicksilver> doserj: you could go mad and make [a,b,c] = pure a `mappend` pure b `mappend` pure c :)
02:18:37 <vincenz> quicksilver: you want pure around the first bit
02:18:51 <quicksilver> vincenz: yup, I do. Or the first <*> into a <$>
02:18:55 <vincenz> right
02:18:57 <quicksilver> vincenz: but I think the point is clear :)
02:18:57 <vincenz> :)
02:19:35 <sjanssen> quicksilver: replacing tuples with T, it becomes: f . g <$> [T a b] <*> monadic bit <*> [d] <*> [e] <*> [h] <*> [j]
02:19:38 <sjanssen> still not perfect
02:20:16 * quicksilver nods
02:20:52 <abell> alexj, I am producing html pages, but I want the outer framer (which puts menu and structure and main contents together) to know if some fragment is using a certain css class or javascript function, and the single fragments to be able to get an id which is unique within the final html page
02:21:46 <abell> So the html fragments should be able to see and update some page-global state
02:24:26 <alexj> abell: usually I just send all the style and script in a separate page.
02:24:55 <alexj> do you have bandwidth issues that make it worth this futzing?
02:26:51 <abell> alexj, For instance, I could decide to include a js file in the header only if some fragment in the final page uses some function from it
02:27:07 <abell> s/final page/page/
02:27:23 <alexj> abell: ok.  not obviously worth it.
02:30:22 <abell> alexj, or in any other case when something in a fragment requires something else in a specific place of the page. Think of enabling some menu subsection, or adding keywords to the header, or enabling/disabling some style class.
02:33:40 <quicksilver> abell: I might consider use a Writer for that
02:34:48 <quicksilver> simple to 'tell' a list of "requirements"
02:35:00 <quicksilver> which would be a custom data type
02:36:08 <quicksilver> data Req = ProductMenu | HelpMenu | AdminMenu | SpecialCSS
02:36:09 <quicksilver> etc
02:38:06 <veerz> Is there a way to disable the ghc's garbage collector completely?
02:39:10 <quicksilver> well, you can set the thresholds on whichh in runs to extreme values
02:39:19 <quicksilver> why would you want to disable it?
02:40:00 <veerz> quicksilver: because I've got a small programm that only runs for a few seconds
02:40:23 <veerz> And it spends half of its time with collecting garbage
02:40:31 <abell> quicksilver, so what would my working type be? And to keep the syntax Text.Html-like, would I need to redefine everything for this new type?
02:40:37 <veerz> even with +RTS -A128M
02:41:17 <quicksilver> veerz: have you looked at the total allocation stats?
02:41:23 <quicksilver> is it feasible to have that much heap?
02:42:55 <abell> quicksilver, "everything" meaning h1 title ! << +++ anchor etc.
02:43:37 <quicksilver> abell: well you'd use html for the most part
02:43:45 <veerz> quicksilver: yes and yes
02:43:46 <quicksilver> it might look like this:
02:44:07 <quicksilver> do tell [ProductMenu]
02:44:24 <quicksilver>    return <html stuff as normal>
02:44:46 <veerz> altough they are depressing, my haskell program needs about 400m whereas my c program doing the same thing in place needs only about 100k
02:44:59 <vincenz> veerz: @pate
02:45:00 <vincenz> +s
02:45:12 <quicksilver> vincenz: duck liver or smoked salmon?
02:45:22 <vincenz> :D
02:47:54 <vincenz> quicksilver: farmer's
02:48:32 <hpaste>  veerz pasted "for vincenz ;)" at http://hpaste.org/3891
02:50:00 <vincenz> I think you want a strict int list
02:50:40 <veerz> vincenz: what is a strict int list?
02:50:47 <vincenz> a list of strict ints
02:50:55 <KatieHuber> you write ! and your code magically goes faster
02:51:08 <veerz> That sounds good!
02:51:11 <vincenz> KatieHuber: doubt that works for lists
02:51:18 <KatieHuber> no, probably not :/
02:51:42 <vincenz> veerz: is your s long?
02:52:44 <hpaste>  sjanssen annotated "for vincenz ;)" with "minor improvement" at http://hpaste.org/3891#a1
02:52:53 <vincenz> i guess not
02:52:57 <veerz> vincenz: I use 100'000 entries
02:53:04 <sjanssen> veerz: how large is 'poles' usually?
02:53:16 <vincenz> I think the main problem is
02:53:21 <vincenz> input is kept alive until the end
02:53:25 <vincenz> since the int list isn't forced until then
02:53:35 <vincenz> so you have the int list as well as the input that are both alive
02:53:53 <vincenz> sjanssen: that really help much?
02:53:58 <veerz> sjanssen: about 200 000
02:54:26 <sjanssen> vincenz: it will reduce O(n) cons cell constructions
02:54:55 <vincenz> nod
02:55:44 <sjanssen> should be noticeable with 100,000 elements
02:56:02 <vincenz> yeah
02:56:21 <vincenz> btw
02:56:25 <vincenz> why are you sorting at the beginning?
02:56:32 <veerz> vincenz: it is, it makes the whole program about 10% faster
02:56:34 <vincenz> you just want max and min
02:56:44 <veerz> vincenz: because the input is not ordered
02:56:52 <vincenz> @type foldr
02:56:54 <vincenz> and?
02:56:57 <vincenz> oh
02:56:59 <vincenz> nm
02:57:05 <veerz> vincenz: no, I do need them ordered to calculate the differences
02:57:05 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:57:07 * vincenz coughs
02:57:11 <vincenz> veerz: right, missed that :)
02:57:57 <sjanssen> the next problem is the evaluation order
02:58:12 <sjanssen> I think
02:58:49 <veerz> Hm, I think reading in the integers still uses most of the time and memory
02:59:07 <vincenz> wait
02:59:11 <vincenz> one more option :)
03:00:26 <hpaste>  vincenz annotated "for vincenz ;)" with "little cleaning" at http://hpaste.org/3891#a2
03:00:34 <vincenz> might have some small bugs
03:00:40 <vincenz> in sumnum
03:01:45 <veerz> vincenz: I'll try it out
03:01:47 <vincenz> though not sure if that'll gain you
03:01:53 <vincenz> so yes, interested in that
03:02:01 <vincenz> you'll need -fbang-patterns
03:02:06 <vincenz> iirc
03:02:14 <sjanssen> vincenz: I don't think sumNum will gain anything
03:02:21 <vincenz> nod
03:02:21 <reqamst> > map (/1) [1,5..11]
03:02:23 <lambdabot>  [1.0,5.0,9.0,13.0]
03:02:23 <sjanssen> vincenz: the sort will evaluate all elements anyway
03:02:30 <reqamst> > map (fromRational . (/1) . toRational) [1,5..11]
03:02:31 <lambdabot>  [1.0,5.0,9.0]
03:02:35 <sjanssen> vincenz: sum . take should be reasonably efficient
03:02:38 <vincenz> right
03:02:50 <vincenz> except sum afaik is lazy
03:02:52 <vincenz> @src sum
03:02:52 <lambdabot> sum = foldl (+) 0
03:02:54 <reqamst> Is it good approach to that's problem?
03:03:44 <sjanssen> vincenz: not with ghc -O on [Int]
03:03:50 <vincenz> oh
03:03:54 <sjanssen> veerz: you are compiling with -O, right?
03:03:59 <vincenz> interesting to know
03:04:24 <sjanssen> vincenz: there's an explicit RULE pragma even if the strictness analyzer doesn't catch it
03:04:53 <veerz> sjanssen: yes
03:04:58 <vincenz> is there any advantage to sum being lazy?
03:05:00 <vincenz> veerz: any changes?
03:05:18 <vincenz> hmm
03:05:21 <vincenz> duh me
03:05:37 <vincenz> (nfriends:poles:_) <- liftM (map read . words) getLine
03:05:47 <veerz> vincenz: yes, its does now take 3 instead of 2 seconds ;)
03:05:50 <vincenz> LOL
03:05:51 <vincenz> :)
03:06:06 <hpaste>  sjanssen annotated "for vincenz ;)" with "is this any better?" at http://hpaste.org/3891#a3
03:06:44 <sjanssen> vincenz: no, it's probably an oversight by the committee
03:06:49 <dikini> hi, I've been mucking around with erlang style actors, can you comment on style, etc... It's my first more complicated thing
03:06:51 <dikini> http://hpaste.org/3892
03:07:10 <sjanssen> vincenz: OOC, why liftM rather than fmap?
03:07:59 <vincenz> habit
03:08:10 <vincenz> :type fmap
03:08:17 <vincenz> @type fmap
03:08:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:08:27 * sjanssen has an irrational hate of liftM
03:08:36 <vincenz> @src ap
03:08:36 <lambdabot> ap = liftM2 id
03:08:59 <hpaste>  vincenz annotated "for vincenz ;)" with "little cleaning" at http://hpaste.org/3891#a4
03:09:20 <vincenz> sjanssen: thx for tip
03:09:28 * sjanssen also hates infix fmap
03:09:30 <noteventime> Any good links to where I could learn the theory behind monads?
03:09:42 <sjanssen> but not for any real reason :)
03:10:16 <vincenz> les gouts et les couleurs ce ne discuttent pas
03:10:53 <vincenz> anywho
03:10:56 <vincenz> fmap and liftM
03:10:58 <vincenz> same difference :)
03:10:59 <kfish> noteventime, http://en.wikibooks.org/wiki/Haskell/Category_theory
03:11:16 <vincenz> afk
03:11:42 <kfish> noteventime, http://math.ucr.edu/home/baez/week73.html ;-)
03:11:42 <lambdabot> Title: week73
03:11:49 <noteventime> kfish: Is the wikibook any good? :-)
03:12:02 <veerz> sjanssen: hm It does only make it slower again
03:12:17 <sjanssen> veerz: slower by how much?
03:12:42 <veerz> sjanssen: its about as fast as vincenz version
03:12:55 <kfish> noteventime, it'll give you the flavour, in familiar (haskell) terms
03:12:59 <sjanssen> okay, this is evidence that GHC is evaluating in the order we'd like anyway
03:13:05 <veerz> anyway I have to go to lunch no, I'll be back in an hour
03:13:10 <kfish> noteventime, and answer your specific question (about haskell monads)
03:13:26 <veerz> Thank you very much for your support so far!
03:13:47 <noteventime> I realised I had an ebook about category theory lying around
03:13:54 <hpaste>  sjanssen annotated "for vincenz ;)" with "diff may be too lazy" at http://hpaste.org/3891#a5
03:14:03 <noteventime> Thanks kfish
03:14:06 <noteventime> I'll check them out :-D
03:14:51 <quicksilver> noteventime: 'categories for the working mathematician' is well presented but dry
03:14:53 <sjanssen> veerz: I think that last version is as far as we can go without major changes
03:15:03 <noteventime> quicksilver: That's the one I have :-P
03:15:04 <quicksilver> noteventime: it makes a good encyclopedic way to learn the maths-side
03:15:20 <noteventime> quicksilver: I don't mind dry :)
03:16:23 <hpaste>  sjanssen annotated "for vincenz ;)" with "oops, subtract 1, not add 1" at http://hpaste.org/3891#a6
03:16:44 <quicksilver> somewhere I thought someone had written up PTJ's lecture course in category theory
03:16:48 <quicksilver> but I can't find it immediately
03:17:36 <hpaste>  sjanssen annotated "for vincenz ;)" with "stupid unary negation :(" at http://hpaste.org/3891#a7
03:18:16 <quicksilver> noteventime: http://cheng.staff.shef.ac.uk/autumn07/
03:18:19 <lambdabot> Title: Category Theory
03:18:30 <quicksilver> noteventime: 3/4 of the way down are PDF versions of her cambridge course
03:18:46 <quicksilver> I *think* she based her cambridge course on PTJ's. Even if she didn't, the notes are ood.
03:19:03 <noteventime> quicksilver: Nice, thanks :-)
03:19:23 <quicksilver> there's also youtubes of her lecturing
03:19:26 <quicksilver> which I've never watched
03:19:29 <quicksilver> might be good for a laugh :)
03:20:19 <noteventime> I think I have enough material to learn category theory now ;-)
03:20:53 <osfameron> "I know category theory!</Neo>"
03:21:16 <quicksilver> the problem with category theory is that if you just learn it, you have no idea what it's for.
03:21:16 <noteventime> I need to get a better grasp of, well all the mathematics school doesn't teach me. Which is more or less everything
03:21:24 <quicksilver> That was my problem when I learnt it.
03:21:31 <quicksilver> It was just (ahem) abstract nonsense.
03:21:38 <quicksilver> I have got into a lot of trouble using that phrase.
03:21:39 <noteventime> quicksilver: I like abstract nonsense
03:21:52 <quicksilver> well category theory is the study of abstract nonsense.
03:22:03 <noteventime> Suits me very well then :-D
03:22:03 <quicksilver> It isolates the commonalities between all the nonsenses.
03:22:06 <quicksilver> And gives them names.
03:22:16 <noteventime> quicksilver: Do I need a good understanding of set theory first?
03:22:19 <quicksilver> nope
03:22:24 <noteventime> Good :-)
03:22:40 <osfameron> so you should read Alice in Wonderland first
03:22:42 <quicksilver> A good understanding of set theory might even hold you back.
03:22:48 <quicksilver> it might make you worry about paradoxes.
03:22:51 <noteventime> osfameron: Already done
03:22:55 <quicksilver> that's what set theoreticians do :)
03:23:40 <noteventime> Wow, my list of things to learn just keeps growing :-P
03:24:22 <osfameron> they have a bad habit of doing that...
03:24:43 <noteventime> Good thing I have a lot of free time this year then ^^
03:25:03 <osfameron> eeek!  Boss for $next_job has just suggested he could pay for London Perl Workshop.  In which case I'd have to actually write my haskell talk...
03:25:16 <noteventime> Lol, transcoding a 750mb mov while compiling kde takes time >_>
03:26:19 <quicksilver> osfameron: actually Alice in Wonderland is a good metaphor for category theory. Or is it The Matrix? ;) "Just how deep does this rabbit hole go?"
03:26:51 <osfameron> quicksilver: "48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman."
03:27:23 <Caelum> rabbits don't dig holes, do they?
03:29:05 <quicksilver> Caelum: sure they do
03:29:18 <noteventime> Code using list comprehension confuses me ^_"
03:29:42 <noteventime> I get the idea, but I have trouble following code using it
03:30:01 <quicksilver> people (ab)use the list comprehension for the very neat pattern-matching trick
03:30:15 <quicksilver> like most cool bits of syntax, it's great but only once you get used to it
03:32:00 <noteventime> Yea, I can see the code is usually quite ingenious
03:32:13 <noteventime> It's just that I'm still too stupid :-P
03:38:13 <araujo> morning
03:40:33 <noteventime> Hullo araujo
03:42:42 <araujo> Hi noteventime
03:42:44 <araujo> :-
03:42:45 <araujo> :-)
03:48:33 <mornfall> quicksilver: Which pattern-matching trick?
03:49:44 <sjanssen> mornfall: there are lots of them
03:49:58 <sjanssen> for example, if b then [x] else []
03:50:03 <sjanssen> becomes [x | b]
03:50:14 <byorgey> > [ x | x@(Just _) <- Just 3 ]
03:50:15 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Maybe t1'
03:50:23 <byorgey> > [ x | x@(Just _) <- [Just 3] ]
03:50:24 <lambdabot>  [Just 3]
03:50:29 <byorgey> > [ x | x@(Just _) <- [Nothing] ]
03:50:29 <lambdabot>  []
03:51:13 <kfish> http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
03:51:16 <lambdabot> Title: blog.kfish.org: Survey: Haskell Unicode support
03:51:26 <alexj> @seen igloo
03:51:26 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 12h 34m 24s ago.
03:53:14 <quicksilver> mornfall: I was mostly talking about the constructor one
03:53:26 <quicksilver> mornfall: if you have data Foo = Foo (Maybe Int) String
03:53:34 <kfish> ?tell dons bastard, made me blog about unicode instead of working
03:53:35 <lambdabot> Consider it noted.
03:53:36 <quicksilver> you can match Foo (Just i) s <- list
03:57:36 <mornfall> Interesting.
03:57:53 <mornfall> I also didn't know the @ syntax.
03:58:39 <mornfall> One always learns.
03:59:59 <byorgey> mornfall: and the @ syntax isn't just for list comprehension, it's for any pattern matching.
04:00:24 <byorgey> > let f xxs@(x:xs) = xxs ++ xs ++ [x]  in f [1,2,3]
04:00:25 <lambdabot>  [1,2,3,2,3,1]
04:01:13 <mornfall> byorgey: I have figured that much ; - ).
04:01:22 <byorgey> =)
04:05:23 <_ry> hey. i have a function String -> IO ()    and in my main function I have a [String] array. How can i operate my function on each element of the array and return IO () ?
04:05:41 <EvilTerran> ?type mapM_
04:05:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:06:21 <EvilTerran> > mapM_ putStrLn ["foo", "bar", "baz"]
04:06:22 <lambdabot>  <IO ()>
04:06:38 <_ry> thanks
04:06:41 <EvilTerran> :)
04:06:52 <_ry> mapM_ is a hard function name to remember
04:07:06 <quicksilver> _ry: I don't find it so
04:07:08 <TSC> _ry: The key is the function "sequence", that takes a list of monadic values and turns into a single value
04:07:13 <sieni> _ry: _ry is a hard nickname to remember :-)
04:07:13 <TSC> @type sequence
04:07:14 <hpaste>  rhz pasted "realAbs" at http://hpaste.org/3893
04:07:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:07:24 <_ry> what does the underscore signify
04:07:26 <rhz> what is wrong with the above code?
04:07:27 <quicksilver> _ry: not if you are happy with map
04:07:28 <EvilTerran> the monadic versions of common functions have an "M" tacked on to the end, eg mapM, filterM
04:07:37 <quicksilver> _ry: underscore means, throw away the list of results
04:07:39 <TSC> The underscore means it returns monadic ()
04:07:40 <quicksilver> and just return ()
04:07:42 <EvilTerran> and, if they throw away their final value and just return (), you add a _
04:07:45 <EvilTerran> ?hoogle M_
04:07:46 <lambdabot> Monad.zipWithM_ :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a ()
04:07:46 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
04:07:46 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
04:07:53 <EvilTerran> ?hoogle+
04:07:53 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
04:07:53 <lambdabot> Control.Monad.zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
04:07:53 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
04:08:12 <TSC> Regular "mapM" returns a list of results; "mapM_" throws them away
04:08:18 <EvilTerran> ?type mapM -- preserves its results
04:08:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:08:22 <quicksilver> rhz: your code promises that it can 'realAbs' into any other real b
04:08:42 <quicksilver> rhz: whereas your implementation returns a particular one
04:09:13 <EvilTerran> in general, fooM_ x0 .. xN = fooM_ x0 .. xN >> return ()
04:09:21 <EvilTerran> er, = fooM ..., rather
04:10:02 <EvilTerran> it's not exactly fooM_ = (>>return ()) . fooM, owing to the varying number of parameters fooM will have, but it's similar
04:21:13 <veerz> sjanssen: that did work, down on 1.7 seconds :)
04:22:50 <veerz> the (unoptimized) c version needs just about 0.1 seconds tough
04:23:20 <vincenz> woot
04:23:27 <vincenz> still at it I see
04:25:24 * SamB_XP is wondering how exactly the habit of growing that lists of things to learn have is a bad habit
04:29:32 <byorgey> SamB_XP: huh?
04:30:49 <SamB_XP> <noteventime> Wow, my list of things to learn just keeps growing :-P
04:30:49 <SamB_XP> <osfameron> they have a bad habit of doing that...
04:33:24 * mdmkolbe|ubuntu just realized the problem he's tackling is really just a co-monad 8-)
04:33:31 <mdmkolbe|ubuntu> Are there any good co-monad libraries out there?
04:35:35 <noteventime> SamB_XP: The bad habit is just when you have trouble keeping up :-)
04:36:21 <SamB_XP> noteventime: there's no need to try and keep
04:36:23 <SamB_XP> up
04:36:44 <SamB_XP> but I find that having a growing list of things to learn is infinitely preferable to a shrinking list
04:36:59 <noteventime> SamB_XP: Very true
04:37:56 <noteventime> It's just that you've barely started learning something when you discover 10 new things that you are more interested in :-)
04:38:15 <noteventime> It's like trying to read an article on wikipedia
04:38:17 <quicksilver> mdmkolbe|ubuntu: no. Because nobody really knows what interesting comonads are?
04:38:27 <quicksilver> mdmkolbe|ubuntu: the environment one is the only one I've seen
04:38:34 <SamB_XP> noteventime: hmm, that does sound a bit much ;-)
04:38:57 <byorgey> noteventime: heh, I know the feeling. =)  you just have to be disciplined about putting new ideas in the priority queue instead of running off after them in the middle of whatever else you're learning.
04:39:00 <mdmkolbe|ubuntu> quicksilver: environment = celular atomaton?
04:39:06 <byorgey> ...which is harder than it sounds of course =)
04:39:31 <noteventime> On the other hand, jumping between subjects all the time gives you a good overview :-)
04:39:42 <byorgey> well, yes.
04:40:08 <noteventime> Just like reading 100 articles on wikipedia makes you feel very educated for an hour or so :-D
04:40:16 <mdmkolbe|ubuntu> noteventime: Learning to speed read papers also helps.  A lot of papers (not the seminal ones) only have 5-10 min of content in them if you know what parts to skip.
04:40:39 <noteventime> mdmkolbe|ubuntu: I've noticed :-) Still a skill I have to learn though
04:41:07 <noteventime> Next year university starts, O_o
04:41:24 <noteventime> Somehow I feel like I should be more ready
04:41:28 <stulli> How does foldr work? I (think) i understand foldl, but foldr looks mysterious to me. foldr (/) 12 [4,3,2] has 0.22.. as result, but i expected 0.5?
04:41:47 <stulli> like 12/2/3/4
04:42:32 <magnus___> > foldr (flip (/)) 12 [4,3,2]
04:42:33 <lambdabot>  0.5
04:42:42 <EvilTerran> foldr (/) 12 [4,3,2] = 4/(3/(2/12))
04:42:50 <mdmkolbe|ubuntu> stulli: with foldl the parens pack to the left (((12/2)/3)/4), but with foldr the parens pack o the right (2/(3/(4/12)))
04:42:50 <EvilTerran> > 4/(3/(2/12))
04:42:51 <lambdabot>  0.2222222222222222
04:42:58 <doserj> > 12/(2/(3/4))
04:42:59 <lambdabot>  4.5
04:42:59 <noteventime> Dropping C++ at least seems to make most CS more accessible
04:43:20 <doserj> > 12/(4/(3/2))
04:43:20 <lambdabot>  4.5
04:43:52 <stulli> EvilTerran: that seems to work, thanks
04:44:15 * doserj needs coffee
04:45:20 <mdmkolbe|ubuntu> hmm, maybe haskell needs an abstract arithmetic type, to help explain these problems.  (i.e. 12/4 produces (12 `Div` 4) not 3) that way it's easier for people to understand what foldl and foldr do
04:45:49 <SamB_XP> mdmkolbe|ubuntu: you can make one ;-)
04:46:11 <SamB_XP> but what are you going to do for (==)
04:46:17 <stulli> mdmkolbe|ubuntu: The way you explained it with the parens made it clear for me :)
04:47:13 <mdmkolbe|ubuntu> stulli: such a type would do the parens automatically
04:47:44 <SamB_XP> yes, it would... unless you accidentally used infix constructors and specified their fixity ;-)
04:48:39 <mdmkolbe|ubuntu> SamB: observer operations (e.g. ==) would have to use an abstract boolean or something, only once you got up to "if ... then ... else" would it then *have* to be coerced and interpreted (not perfect, but maybe doable)
04:48:48 <stulli> I searched the web for quite some time, but didnt find a easy explanation for it. Good there is #haskell
04:49:28 <SamB_XP> for some reason I am reminded of the sad lack of support for higher-order type constructors in Derive and DrIFT
04:49:44 <SamB_XP> mdmkolbe|ubuntu: you can't do that!
04:49:52 <SamB_XP> (==) is required to actually return Bool
04:50:27 <SamB_XP> but I suppose it would still be a decent tool to explain folds
04:50:43 <quicksilver> SamB_XP: you could just make == undefined and punt it :)
04:50:50 <quicksilver> or always return false.
04:51:02 <quicksilver> or you could base == on an interpretation in Rational, I guess.
04:51:05 <SamB_XP> or do the interpretation a bit earlier than mdmkolbe|ubuntu would like
04:51:11 <SamB_XP> er, yeah
04:51:14 <SamB_XP> what you said
04:51:16 <mdmkolbe|ubuntu> SamB_XP: yeah, the "(==) is tied to bool" class of problems is starting to show up in a number of DSEL situations
04:51:25 <SamB_XP> mdmkolbe|ubuntu: I don't doubt it
04:51:52 <SamB_XP> it would surprise me if it weren't so
04:52:13 <SamB_XP> sometimes I get jealous of languages like Python
04:52:32 * SamB_XP forgot what the finger next to his pinky is called
04:52:48 <TomMD> "ring finger"
04:53:10 <SamB_XP> oh. well I don't think I want to put a ring on mine, it hurts enough as it is
04:53:47 <SamB_XP> well, my left, anyway...
04:54:11 <mdmkolbe|ubuntu> "third finger" is another (less used) term
04:54:29 <SamB_XP> mdmkolbe|ubuntu: probably because it's too easy to confuse with the middle one?
04:54:38 <mdmkolbe|ubuntu> yeah
04:55:22 <vincenz> that's why error handling in compilers is so hard
04:55:25 <vincenz> whoops
04:55:52 <mdmkolbe|ubuntu> though I've never heard any one refer to the "second" or "forth" finger, only index (sort of numberish) and third
04:56:30 <SamB_XP> forth finger
04:56:32 <SamB_XP> hmm
04:57:06 <mdmkolbe|ubuntu> 4th = pinky/little finger
04:57:13 * SamB_XP can't think of any special finger you use especially often in forth
04:57:32 <mdmkolbe|ubuntu> shift?
04:57:36 <vincenz> SamB_XP: the instruction finger
04:57:39 <SamB_XP> heh
04:57:41 <SamB_XP> shift
04:57:52 <SamB_XP> wouldn't you just turn on capslock?
04:58:09 <SamB_XP> or... write code in lowercase, even?
04:58:10 <mdmkolbe|ubuntu> well it's more of an Emacs finger for me, but oh wel
04:58:36 * mdmkolbe|ubuntu doesn't remember forth so doesn't know how often shift is used in it
04:58:40 <SamB_XP> is that how I got this finger hurting?
04:58:43 <SamB_XP> emacs?
04:59:08 <SamB_XP> Hmm, what combos involving C-M- are there?
04:59:34 <SamB_XP> ... do I even use my pinky for those?
05:00:05 <noteventime> Load Viper ^^
05:00:22 <mdmkolbe|ubuntu> Use "C-h k" to find out
05:00:28 * noteventime dodges the bullets shoot at him
05:00:57 <SamB> noteventime: you are playing a videogame in emacs using viper?
05:01:18 * mdmkolbe|ubuntu uses pinky for shift and ctrl
05:01:39 <noteventime> SamB: No, suggesting a Vim-emulation module to an emacs user can be hazardous to your health
05:01:49 <noteventime> mode*
05:01:57 <quicksilver> SamB_XP: C-M-f for forward-sexp is a useful one
05:02:16 <quicksilver> SamB_XP: C-M-t for transpose-sexps also
05:02:44 <quicksilver> SamB_XP: C-M-% for query-replace-regexp
05:02:44 <quicksilver> etc
05:06:47 <osfameron> SamB: indeed, I guess it's actually a good habit, but it can often be frustrating :-)
05:07:36 <ivanm> are all folds catamorphism? or just those the reduce the list down to a single value?
05:09:48 <mdmkolbe|ubuntu> IIRC, fold is always a catamorphism (b/c of it's type), but it might sometimes give a larger result than the input.  unfold would be the anamorphism.  The the "Programming with Banana's, Lenses and Barbed Wire" paper for more info.
05:10:16 <ivanm> wasn't a fold that produced another list called a homorphism or something?
05:10:51 <quicksilver> ivanm: "fold" itself is the catamorphism
05:10:56 <quicksilver> ivanm: it doesn't matter what you do with it
05:11:00 <quicksilver> :t foldr
05:11:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:11:13 <quicksilver> ^^ that's your catamorphism
05:11:15 <mdmkolbe|ubuntu> catamorphism composed with anamorphism makes homomorpohsm (again IIRC, long time ago)
05:11:24 <mdmkolbe|ubuntu> :t unfoldr
05:11:25 <ivanm> quicksilver: *nod*
05:11:25 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:11:27 <SamB> oh sweet, wikipedia is using Cale's fold diagrams
05:11:35 <quicksilver> SamB_XP: Cale put them there :P
05:11:36 <ivanm> heh
05:11:38 <mdmkolbe|ubuntu> link?
05:11:41 <SamB> quicksilver: I figured
05:11:48 <quicksilver> SamB_XP: in fact, they were there first. He copied them from there to the haskell wiki afterwards.
05:11:53 <SamB> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
05:11:53 <lambdabot> Title: Fold (higher-order function) - Wikipedia, the free encyclopedia
05:12:04 <SamB> quicksilver: I thought they were on Cale's website first?
05:13:24 <quicksilver> SamB: maybe :)
05:15:54 <SamB> it looks like the squiggol paper might be the place to go to find out what kind of morphism foldl is?
05:16:27 <quicksilver> I don't think foldl belongs to any particular class of morphism
05:16:32 <quicksilver> it's quite special and list-specific
05:16:37 <quicksilver> I could be wrong :)
05:17:55 <_ry> how do i open stdin?
05:18:09 <quicksilver> it's already open
05:18:14 <quicksilver> by definition
05:18:18 <_ry> how do i read from it?
05:18:23 <quicksilver> getLine
05:18:27 <quicksilver> e.g.
05:18:47 <quicksilver> most of the 'hGet*' functions have a version without the 'h' which operates implicitly on stdin
05:19:18 <quicksilver> or, you could use the name stdin explicitly
05:19:21 <quicksilver> hGetLine stdin
05:19:22 <quicksilver> ==
05:19:23 <quicksilver> getLine
05:20:05 <vincenz> or
05:20:07 <vincenz> @get-shapr
05:20:07 <lambdabot> shapr!!
05:21:58 <puusorsa> @get-bärzä
05:21:59 <lambdabot> Unknown command, try @list
05:22:20 <puusorsa> >reverse "bärzä"
05:27:15 <mdmkolbe|ubuntu> @get-mdmkolbe
05:27:15 <lambdabot> Unknown command, try @list
05:28:11 <reqamst> lambdabot probably doesn't supports unicode :(
05:28:42 <osfameron> meh, who needs unicode anyway
05:28:54 <osfameron> if ascii was good enough for shakespeare it's good enough for anyone
05:29:04 <reqamst> Me. Unicode rocks.
05:29:48 <mdmkolbe|ubuntu> What category gets constructed once you add "join" to the Co-Monad operators? (yes, I mean join not co-join, and I mean co-monad not monad)
05:31:53 <reqamst> For example sometimes I want to name function in my native language
05:33:04 <reqamst> > putStrLn "Å›Ä‡Å‚Ä…Å„Ä™"
05:33:06 <lambdabot>  <IO ()>
05:33:10 <doserj> isn't join just a special case of extract?
05:34:48 <mdmkolbe|ubuntu> the difference would be that I don't want the outer data just thrown away (what extract does) I want it combined into the inner data (what join does)
05:35:19 <doserj> ah, ok
05:37:41 <quicksilver> mdmkolbe|ubuntu: depends what commutation you specify between join and cojoin, I expect
05:38:00 <quicksilver> for example, join.cojoin = cojoin.join = id ?
05:38:10 * SamB emails himself a powerpoint file just so he can read it
05:38:43 <mdmkolbe|ubuntu> probably join.cojoin = id.  I'm not so picky that cojoin.join = id.
05:41:47 <doserj> cojoin is duplicate?
05:42:05 <vincenz> quicksilver: can cojoin work in haskell?
05:42:20 <vincenz> join . cojoin looks off, since you're introducing an extra parameter
05:42:23 <mdmkolbe|ubuntu> yes, cojoin = duplicate
05:42:29 <vincenz> right, but erm
05:42:36 <doserj> extract . duplicate == id is a comonad law
05:42:37 <vincenz> join . cojoin : passes one parameter between the two
05:42:39 <vincenz> not two
05:42:46 * vincenz was asking about haskell :)
05:43:16 <vincenz> perhaps it should be
05:43:18 <vincenz> cojoin (join) ?
05:43:46 * vincenz wonders
05:43:54 <vincenz> @type join
05:44:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:44:09 <reqamst> http://tnij.org/ag21 Why is it empty?
05:44:18 <vincenz> sorry, was thinking too much in terms of reader monad
05:44:40 <vincenz> @src join
05:44:40 <lambdabot> join x =  x >>= id
05:45:11 <vincenz> cojoin == return?
05:45:36 <vincenz> then (join . cojoin x) = return x >>= id = x
05:46:08 <doserj> no
05:46:16 <mdmkolbe|ubuntu> ok, doserj's comment about extra . duplicate = id convinces me that duplicate may be a side track.  The problem I am solving, involves some information wrapped around a data structure.  As the program runs it inspects the structure and has to push the wrapping down one layer at a time.  Sometimes when it pushes the wrapping down it must combine with a wrapping that is already there thus the need for join.
05:46:55 <vincenz> doserj: no?
05:47:10 <mdmkolbe|ubuntu> The program takes m a as input and finishes with just b, so I'm very much suspecting it's a co-monad, except for th part about needing to combine with lower parts that it collapses onto
05:47:39 <roconnor> c\_/
05:47:39 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
05:48:03 <quicksilver> vincenz: join :: m (m a) -> m a
05:48:06 <vincenz> right
05:48:07 <opqdonut> |_P
05:48:12 <quicksilver> vincenz: cojoin :: m a -> m (m a)
05:48:15 <vincenz> so cojoin should be :: m a -> m (m a)
05:48:17 <vincenz> aka return :)
05:48:20 <quicksilver> so join.cojoin :: m a -> ma
05:48:29 <roconnor> @seen ivanm
05:48:29 <lambdabot> ivanm is in #xmonad, #haskell and #gentoo-haskell. I last heard ivanm speak 36m 53s ago.
05:48:31 <quicksilver> and cojoin.join :: m (m a) -> m (m a)
05:48:32 <opqdonut> no no
05:48:39 <vincenz> it works for the right inverse
05:48:43 <opqdonut> yeah, cojoin can't be return
05:48:49 <vincenz> just not the left one
05:48:54 <opqdonut> that would lose stuff, right?
05:48:58 <quicksilver> if cojoin is liftM return, then you don't have a very interesting comonad
05:48:59 <quicksilver> :)
05:49:13 <vincenz> the right one works because of monad rules
05:49:15 <vincenz> :)
05:49:26 <vincenz> but isn't co stuff usually in a comonad?
05:49:34 <vincenz> and hence why should you be able to . them?
05:49:40 <vincenz> it'd be
05:49:42 <quicksilver> . is just function composition
05:49:44 <vincenz> w a -> w (w a)
05:49:46 <quicksilver> you can do that to anything
05:49:50 <quicksilver> ah no,
05:49:54 <vincenz> quicksilver: only for monads that are also comonads
05:50:01 <quicksilver> well
05:50:05 <quicksilver> that was the question :)
05:50:21 <quicksilver> the question being asked was "if I ahve a comonad which also admits join, what is it?"
05:50:28 <vincenz> oh :)
05:50:37 <quicksilver> and I said "that depends what laws your 'join' obeys"
05:50:42 <vincenz> one that doesn't "lose information"
05:50:47 <vincenz> as brought up by opqdonut
05:50:50 <quicksilver> for examples, does it obey join.cojoin = id?
05:50:51 * quicksilver nods
05:51:10 <opqdonut> yes, if join.cojoin=id we have a very uninteresting comonad right?
05:51:11 <vincenz> e.g not the reader monad
05:51:18 <vincenz> opqdonut: no that's easy
05:51:21 <vincenz> opqdonut: the other one istougher
05:51:29 <vincenz> cojoin = return works for all monads
05:51:32 <vincenz> for right inverse
05:51:34 <opqdonut> ah cojoin.join?
05:51:38 <vincenz> cojoin . join = id is the tough cookie
05:51:41 <opqdonut> yep
05:51:52 <vincenz> Maybe seems to work?
05:52:13 <vincenz> if Maybe were strict...
05:52:24 <vincenz> and Just Nothing == Nothing..
05:52:24 <vincenz> nm
05:52:53 <vincenz> anywho, reader monad is definitely out :)
05:52:57 <mdmkolbe|ubuntu> doesn't cojoin=return only help if I have a Monad and want to add a cojoin.  I'm looking for a comonad plus join.
05:53:12 <vincenz> mdmkolbe|ubuntu: I was looking at it in the opposite sense :)
05:53:18 <vincenz> mdmkolbe|ubuntu: and that wasa easy to solve
05:53:23 <vincenz> so indeed the only issue is the left inverse
05:53:38 <vincenz> cojoin . join = id
05:53:47 <vincenz> this basically means the extra level of 'm' carries no information
05:53:54 <vincenz> so only the identity monad?
05:54:29 <mdmkolbe|ubuntu> a monad that stored it's data in a binary tree with a node at each join might work
05:54:48 <mdmkolbe|ubuntu> (but that might run afoul of assoc laws)
05:55:01 <vincenz> are trees monadic?
05:55:40 <mdmkolbe|ubuntu> I'm thinking "data TreeMonad a = TreeMonad (Tree Int) a"
05:55:59 <vincenz> hmm
05:56:21 <quicksilver> vincenz: I don't think it does. All it shows is that 'cojoin' doesn't inject useful information.
05:56:25 <quicksilver> vincenz: which is to be expected.
05:56:36 <vincenz> quicksilver: well, and that join removes no useful information
05:56:42 <quicksilver> vincenz: it doesn't show that "other" ways of getting two levesls don't add information
05:56:56 <vincenz> quicksilver: the other way is trivial
05:57:05 <vincenz> it's like projecting from low dimension to high and then bck
05:57:10 <vincenz> that'll always work
05:57:34 <vincenz> but the monad can contain no useful information
05:57:35 <vincenz> since join strips it
05:57:39 <vincenz> @type join
05:57:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:58:03 <quicksilver> I don't agree with that interpretation
05:58:04 <mdmkolbe|ubuntu> no, join doesn't strip it, it just combines the info from two into one
05:58:07 <quicksilver> join doesn't strip information
05:58:11 <quicksilver> it combines it
05:58:12 <vincenz> quicksilver: yes it does
05:58:15 <vincenz> oh
05:58:15 <vincenz> hmm
05:58:25 <vincenz> but in a sense it strips info
05:58:30 <vincenz> by stripping how it was split
05:58:41 <quicksilver> that much I agree with, yes
05:58:43 <vincenz> it strips the second level structure
05:59:08 <mdmkolbe|ubuntu> could you keep track of that info without violating the other laws (e.g. tree)
05:59:22 <vincenz> mdmkolbe|ubuntu: possibly, but only for very rare monads
05:59:34 <vincenz> mdmkolbe|ubuntu: and I'm not convinced by your TreeMonad
05:59:44 <vincenz> that seems a very specific case of
05:59:58 <vincenz> data DataMonad b a = DataMonad b a
06:00:16 <vincenz> but I could be mistaken
06:01:05 <mdmkolbe|ubuntu> yes, with the restriction that the joining op :: (b, b) -> b is invertable
06:01:37 <vincenz> nod
06:01:41 <vincenz> great
06:01:45 <vincenz> we're making some progress
06:01:51 <vincenz> we have a class with a property :)
06:02:21 <vincenz> there's prolly other classes as well
06:02:26 <doserj> vincenz, quicksilver: the writer monad is also a comonad (I think). join combines the two states (using mappend), cojoin duplicates the state, so join.cojoin =/= id
06:02:52 <vincenz> doserj: oh wow, and that was even the easy case
06:05:14 <mdmkolbe|ubuntu> reader and state are comonads according to http://www.cs.helsinki.fi/u/ekarttun/comonad/
06:05:39 <doserj> yep. writer monad <=> reader comonad, as should be expected...
06:06:02 <swiert> a -> is only a comonad if a is a monoid.
06:06:24 <mdmkolbe|ubuntu> what are the constraints on the -> monad?
06:06:26 <swiert> Just as Writer a is only a monad if a is a monoid.
06:07:05 <swiert> http://cs.ioc.ee/~tarmo/monads-more/monads-more-4.pdf
06:07:26 <swiert> See the "Exponent comonad" example.
06:08:14 <vincenz> swiert: interesting
06:13:31 <mdmkolbe|ubuntu> afk 10 min
06:13:48 * vincenz gets an eggtimer
06:14:01 * Botje gets a stick of TNT
06:14:11 * vincenz gets some ACME glue and attaches the two
06:14:15 <vincenz> so
06:14:22 <vincenz> (b,b ) -> b must be revertable
06:14:24 <vincenz> hmm
06:15:26 <Botje> b >- )b,b(
06:15:29 * Botje runs
06:15:33 <osfameron> ooo!  Is there an Acme namespace in haskell too?
06:15:47 * mdmkolbe|ubuntu realizes he's off by 10 min
06:16:07 * Botje hands mdmkolbe|ubuntu a bill for one(1) stick of TNt
06:16:30 <vincenz> osfameron: yes, it contains such things as "Dynamic"
06:16:42 <Saizan_> :D
06:16:48 <osfameron> vincenz: what's Dynamic?
06:17:05 <vincenz> meh, there goes my poor joke
06:17:10 <vincenz> @hoogle Dynamic
06:17:11 <lambdabot> Data.Dynamic :: module
06:17:11 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
06:17:11 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
06:17:13 <mdmkolbe|ubuntu> yes, but Dynamic (dynamite) is safer than USPIO (nitrogliceride) ;-)
06:17:18 <vincenz> > [Dynmic 1, Dynamic "String"]
06:17:20 <lambdabot>   Not in scope: data constructor `Dynamic'
06:17:29 <vincenz> > [Data,Dynamic 1, Data.Dynamic "String"]
06:17:34 <lambdabot>   Not in scope: data constructor `Data.Dynamic'
06:17:36 <Saizan_> toDyn
06:17:41 <vincenz> Saizan_: thx
06:17:51 <vincenz> > [toDyn 1, toDyn "String"]
06:17:52 <lambdabot>  [<<Integer>>,<<[Char]>>]
06:21:51 <titusg> Hi, I just installed cabal-install and it doesn't seem to pick up my proxy server...http_proxy is defined but do I need to put something in .cabal/config?
06:24:52 <titusg> the README doesn't describe what can go in the config file...
06:25:30 <Pastorn> @type map
06:25:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:30:37 <titusg> hmm, the HTTP lib doesn't pick up my proxy either -- I can't run the little `get' example
06:36:57 <magnus___> Is ghci optimizing?
06:37:39 <Philippa_> no, but if you compile modules with GHC it'll use the compiled versions
06:37:59 <magnus___> I see
06:44:19 <Philippa_> you don't really want ghci to be optimising, it'd slow things down a lot
06:44:21 <vincenz> does GHC optimize cross-module?
06:44:28 <vincenz> ala mlton
06:44:38 <Philippa_> it does some optimisations across module boundaries, yeah
06:44:50 <SamB_XP> probably not ala mlton
06:45:04 <Philippa_> it doesn't do all the specialisation at link-time though, for example - it's not a whole-program compiler
06:45:09 <vincenz> nod
06:46:06 <quicksilver> vincenz: what it does, is what it crams into the .hi files
06:46:24 <quicksilver> vincenz: for example, it puts "small" functions into the .hi files in source form (Effectively) to permit cross-module inlining
06:46:55 <quicksilver> similarly if there are {SPECIALIZE} pragmas, it puts code into the .hi to support that.
06:47:31 <vincenz> nod
06:47:37 <vincenz> because the .o is assembly hel
06:48:08 <yaxu> data Event a = Sound a -- how do I constrain this so that 'a' must be an instance of the Show class?
06:48:08 <lambdabot> yaxu: You have 1 new message. '/msg lambdabot @messages' to read it.
06:49:20 <vincenz> data (Show a) => Event a = Sound a
06:49:26 <vincenz> but why constrain it in the type decl?
06:49:30 <vincenz> why not onstrain it in use?
06:50:00 <quicksilver> data Event a = (Show a) => Sound a
06:50:16 <vincenz> thx
06:50:18 <yaxu> thanks vincenz, i thought i had to constrain it there to be able to use show at all
06:50:23 <vincenz> I always get the location wrong :)
06:50:28 <vincenz> as you can tell, I don't often use it :)
06:50:34 <doserj> data Event a where Sound:: (Show a) => a -> Sound a
06:50:37 <yaxu> i know it will be an Int or a String
06:50:40 <vincenz> yaxu: no need for that :)
06:50:44 <vincenz> you can do
06:50:49 <vincenz> data Event a = Sound a deriving(Show)
06:50:56 <quicksilver> you can do both positions actually
06:50:57 <vincenz> then wherever you try to show a soun, it'll require a to be showable
06:51:16 <quicksilver> it only matters if there is more than one constructor, AFAIK.
06:51:34 <yaxu> there is more than one constructor, i simplified the question...
06:51:43 <quicksilver> in either case you are only really constraining the constructor
06:51:47 <vincenz> yeah
06:51:49 <quicksilver> if you put it on the left of the =
06:51:53 <vincenz> it's better to just constrain the code that requires the show
06:51:53 <quicksilver> it's constraining all the constructors
06:51:55 <quicksilver> I think
06:51:56 <vincenz> then let it propoagate
06:52:12 <yaxu> i see
06:52:18 <vincenz> quicksilver: but erm
06:52:27 <vincenz> quicksilver: take
06:52:38 <vincenz> data Foo a = (X a) => A a | (Y a) => B a
06:52:42 <vincenz> isn't that equivalent to
06:52:55 <vincenz> data (X a, Y a) => Foo a = A a | B a
06:52:57 <vincenz> ?
06:53:21 <vincenz> I see little sense to have a per-consttructor limitation, really
06:53:29 <vincenz> since type analysis is not data-flow based
06:53:36 <vincenz> (at least not dynamic data flow based)
06:54:07 <quicksilver> vincenz: no, it's not equivalent
06:54:24 <yaxu> actually i'm providing my own show in a 'manual' instance declaration
06:54:30 <quicksilver> vincenz: your second one will not permit you to use "A a" unless you have X and Y
06:54:42 <quicksilver> vincenz: your first will permit you to use "A a" with only X.
06:54:45 <vincenz> quicksilver: I guess there are some corner cases where not both will be required
06:55:03 * vincenz ponders
06:55:05 <quicksilver> it's not very useful because pattern-match doesn't give the contexts back to you :)
06:55:17 <yaxu> and that is in turn calling show on the 'a' type
06:55:17 <quicksilver> you are only constraining the constructor-as-a-function
06:55:31 <quicksilver> you aren't doing anything magic to constructor-as-used-in-case
06:55:41 <quicksilver> so you don't get "contexts for free" when you pattern match
06:55:45 <quicksilver> which is what you'd need for it to be usefl
06:55:46 <yaxu> so that's why i am trying to constrain a there
06:56:04 <quicksilver> yaxu: don't.
06:56:07 <vincenz> quicksilver: better to use two tyvars then
06:56:20 <quicksilver> vincenz: right, AFAIK it's useless
06:56:24 <quicksilver> vincenz: but it is different :)
06:56:40 <quicksilver> yaxu: instead, just put the (Show a) context into the Show instance you're writing
06:56:50 <quicksilver> yaxu: no need to have it in the data definition
06:56:56 <yaxu> ok, i'll rework and will paste the fuller context if i get stuck, thanks
06:56:56 <vincenz> bleh
06:57:01 <vincenz> spilled coffee over my desk
06:57:09 <yaxu> quicksilver: ah, nice
06:57:18 <yaxu> vincenz: not in keyboard i hope
06:57:25 <quicksilver> yaxu: so, data Event a = Sound a ; -- no context ; instance (Show a) => Show (Event a)
06:57:33 * yaxu mourns wasted coffee
06:57:49 <yaxu> quicksilver: i see
06:59:03 <Saizan_> quicksilver: with data Foo a = (X a) => A a | (Y a) => B a, pattern matching gives you the contexts
06:59:13 <quicksilver> Saizan_: really?
06:59:23 <quicksilver> Saizan_: interesting. I could have sworn it didn't.
07:00:00 <Saizan_> foo :: Foo t -> String
07:00:03 <Saizan_> foo (A a) = show a
07:00:07 <Saizan_> this typechecks
07:00:23 <Saizan_> if i add a case for B it needs a Show t context
07:00:47 <quicksilver> Saizan_: not for me it doesn't
07:01:11 <quicksilver> Saizan_: are you sure?
07:01:41 <Saizan_> yes, i'm loading it in ghci right now
07:01:59 <Saizan_> well, replace X with Show and Y with something else
07:03:51 <quicksilver> Saizan_: let me paste my code
07:05:02 <hpaste>  quicksilver pasted "pattern matches do not give you contexts" at http://hpaste.org/3894
07:05:07 <quicksilver> Saizan_: there you are.
07:06:12 <vincenz> yaxu: no
07:06:15 <vincenz> yaxu: still, all sticky
07:06:36 <Saizan_> quicksilver: 6.6.1?
07:08:12 <quicksilver> Saizan_: yes.
07:09:25 <quicksilver> Saizan_: according to the documentation, the behaviour you describe is only the case for GADTs
07:09:33 * yaxu is having another haskell epiphany
07:09:33 <quicksilver> Saizan_: which is, therefore, a ghc extension :)
07:09:43 <Saizan_> well then we've a bug in 6.8.1
07:09:54 <Saizan_> because your code compiles :)
07:10:22 <quicksilver> interesting
07:10:28 <quicksilver> -fglasgow-exts?
07:10:31 <Saizan_> no
07:10:32 <quicksilver> in your .ghci, perhaps?
07:10:40 <Saizan_> i don't have one
07:10:44 * quicksilver nods
07:10:53 <quicksilver> I will report it
07:10:57 <quicksilver> unless you want to :)
07:11:24 <Saizan_> no, go ahead :)
07:12:01 <quicksilver> I note from the docs that the authors always foudn this odd:
07:12:26 <quicksilver> "...But instead of making available an (Eq a) constraint, pattern-matching on MkSet' requires an (Eq a) constraint! GHC faithfully implements this behaviour, odd though it is. But for GADT-style declarations, GHC's behaviour is much more useful, as well as much more intuitive...."
07:13:42 <Saizan_> well i like the way 6.8.1 works, too
07:13:55 <quicksilver> I agree it makes sense
07:13:59 <quicksilver> but it isn't haskll98 :)
07:18:00 <stulli> A strict version of foldl1 : foldl1'  What does that mean? I see no difference in the definition.
07:18:24 <quicksilver> it forces evaluation as it goes
07:18:31 <quicksilver> (which is what strict refers to)
07:18:45 <quicksilver> rather than building up a big thunk, which is normal lazy behaviour
07:18:45 <fasta> How can I round a fractional to N numbers?
07:18:46 <stulli> so no lazy anymore?
07:18:57 <quicksilver> fasta: N decimal places?
07:19:03 <fasta> quicksilver: right
07:19:20 <quicksilver> fasta: (/(10^n).round.(*(10^n)) ?
07:19:29 <quicksilver> with an extra)
07:20:20 <phlpp> @pl sum $ map Char.digitToInt $ show $ product [1..100]
07:20:21 <lambdabot> sum (map Char (digitToInt (show (product [1..100]))))
07:20:25 <phlpp> hehe :D
07:20:30 <ivanm> just checking: it's not possible to instantiate a class (e.g. Eq) using a type alias, is it
07:20:43 <fasta> ivanm: in GHC you can.
07:21:01 <ivanm> with an extension I presume?
07:21:03 <fasta> ivanm: in H98, no.
07:21:31 <fasta> ivanm: you can check these things easily by using Hugs.
07:22:03 <ivanm> fasta: I use ghci :p
07:22:14 <fasta> ivanm: I do so too.
07:22:29 <ivanm> and I didn't think so, but I wasn't sure if there was a ghc exention available or something, which was the point of my question
07:22:32 <yaxu> ok that works nicely
07:22:37 <ivanm> I probably should have worded that better ;-)
07:22:39 <fasta> ivanm: but ghci sometimes accepts non-H98 code in H98 mode, IIRC.
07:22:44 <ivanm> hmmmm
07:23:03 <ivanm> so is there a ghc extension that allows you to use instantiate type aliases?
07:23:43 <fasta> ivanm: by type alias you just mean type A x =  Maybe a, right?
07:23:50 <ivanm> yeah
07:23:57 <fasta> ivanm: well, you can just use it.
07:24:11 <fasta> ivanm: instance Eq (A x) where ...
07:24:22 <ivanm> in this case though, its type CReal = Int -> Integer
07:24:46 <ivanm> and I'm wanting to instantiate it
07:24:53 <fasta> ivanm: I don't know the name of the extension, but it's probably in the manual or use the sledge hammer -fglasgow-exts.
07:25:01 <ivanm> *nod*
07:25:10 <fasta> ivanm: so, you can.
07:25:12 <ivanm> I don't care what the extension is, just that there is one
07:25:21 <ivanm> (since this is for a theoretical exercise)
07:25:29 <fasta> ivanm: and I told you a zillion times that there is.
07:26:02 <fasta> How can a theoretical exercise be related to a practical option of a compiler?
07:26:45 <ivanm> you never actually said there was an extension...
07:27:13 <ivanm> well, theoretical = for an FP paper, where I'm saying "btw, this isn't legal haskell code, but you can do this with a ghc extension"
07:27:45 <fasta> ivanm: but, if you include code in a paper, you should have tested it first.
07:27:55 <ivanm> the code won't run
07:28:07 <ivanm> since on the main it isn't legal code in any way (won't typecheck)
07:29:53 <Saizan_> ivanm: why?
07:30:11 <ivanm> *sigh* I just went over this last night...
07:31:28 <Syzygy-> ivanm: New audience. :)
07:31:43 <ivanm> Saizan_: I'm using functions to represent data... so sometimes these functions don't typecheck (at least not using the Hindley-Milner typing system
07:32:22 <ivanm> if you go through the logs from about 24 hours ago, you'll see the mess ski and I made with lambdabot trying to type function-based church numerals
07:32:28 <ivanm> e.g.
07:33:19 <Saizan_> mmh
07:33:36 <Saizan_> have you read what oleg wrote about this?
07:33:58 <phlpp> oh, at least i forgot
07:34:02 <phlpp> to say "hi all" :)
07:34:46 <Saizan_> ivanm: http://okmij.org/ftp/Haskell/types.html#some-impredicativity -- not sure if this is relevant
07:34:47 <lambdabot> Title: Haskell Programming: Types
07:35:05 <ivanm> @type let zero s z = z; succ n s z = s (n s z); add m n = m succ n; mult m n = m (add n) zero; exp m n = n (mul m) (succ zero) in exp
07:35:12 <lambdabot> Not in scope: `mul'
07:35:16 <ivanm> grrr
07:35:20 <ivanm> @type let zero s z = z; succ n s z = s (n s z); add m n = m succ n; mult m n = m (add n) zero; exp m n = n (mult m) (succ zero) in exp
07:35:21 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10. ((t -> t1) -> (t2 -> t3 -> t3) -> t4) -> ((((((t5 -> t6) -> t7 -> t5) -> (t5 -> t6) -> t7 -> t6) -> t -> t1) -> t4) -> ((t8 -> t9) -> t8 -> t9) -> t10) ->
07:35:21 <lambdabot> t10
07:35:26 <vincenz> ewwie
07:35:33 <ivanm> Saizan_: I've seen it... not quite relevant
07:35:35 <ivanm> vincenz: exactly
07:39:48 <ivanm> Saizan_: it gets better though... now lets try applying exp...
07:39:53 <ivanm> @type let zero s z = z; succ n s z = s (n s z); add m n = m succ n; mult m n = m (add n) zero; exp m n = n (mult m) (succ zero); one = succ zero; two = succ one in exp two two
07:39:54 <lambdabot>     Occurs check: cannot construct the infinite type:
07:39:54 <lambdabot>       t = (((t1 -> t2) -> t3 -> t1) -> (t1 -> t2) -> t3 -> t2) -> t -> t
07:39:54 <lambdabot>     Probable cause: `two' is applied to too few arguments
07:39:59 <ivanm> and type checking fails
07:41:17 <roconnor> ivanm: monomorphism restriction?
07:41:40 <Saizan_> ivanm: so no newtypes allowed?
07:42:44 <ivanm> roconnor: is it? *shrug*
07:42:52 <ivanm> I'm just copying my professors stuff here :p
07:42:58 <ivanm> he said all that happened
07:43:28 <quicksilver> the monomorphism restriction certainly applies to 'one' and 'two' there
07:43:31 <ivanm> Saizan_: the whole point is, you're using functions instead of data structures
07:43:36 <ivanm> quicksilver: hmmm...
07:43:52 <ivanm> *shrug* I never really understood the monomorphism restriction
07:44:33 <quicksilver> but, that's not what it is here
07:44:34 <fasta> quicksilver: I don't see how that code will ever work, unless it was an illustration. I did get it to work however(this really should be in a library(it's in my extended Prelude now), since I use this in about every project).
07:44:43 <quicksilver> just checked with ghci -fglasgow-exts
07:44:48 <quicksilver> fasta: which code?
07:44:51 <doserj> roconnor: the problem is equirecursive types vs. isorecursive types, i think
07:45:02 <fasta> quicksilver: the rounding code.
07:45:06 <roconnor> doserj: oh
07:45:17 <roconnor> @wn equirecursive
07:45:18 <lambdabot> No match for "equirecursive".
07:45:25 <roconnor> @wn isorecursive
07:45:25 <lambdabot> No match for "isorecursive".
07:45:32 <doserj> http://en.wikipedia.org/wiki/Recursive_type
07:45:32 <lambdabot> Title: Recursive type - Wikipedia, the free encyclopedia
07:46:18 <roconnor> doserj: ah right
07:46:26 <doserj> basically, type T = A T would be equirecursive, which is not legal in Haskell.
07:46:58 <roconnor> doserj: you can solve ``Occurs check: cannot construct the infinite type:'' by sticking in a recrusive type to solve the equation.
07:47:17 <doserj> that gives you an isorecursive type
07:47:51 <fasta> quicksilver: (you forgot fromInteger)
07:48:09 <quicksilver> :t (^)
07:48:10 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:48:14 <quicksilver> fasta: ?
07:48:17 <quicksilver> I didn't...
07:48:24 <quicksilver> ah
07:48:25 <quicksilver> yes I did
07:48:26 <quicksilver> :)
07:48:28 <quicksilver> right
08:40:59 <opqdonut> hmm, am i right in thinkin that a threaded state is expressed more elegantly as a comonad?
08:47:32 <opqdonut> ah, that is exactly one of the examples karttunen uses
08:47:33 <opqdonut> nvm :)
08:49:50 <roconnor> there has to be some name/theory for a ``commutative, copyable, discardable, strong, lax, monoidal functor''.
08:52:26 <shapr> @yow !
08:52:27 <lambdabot> World War III?  No thanks!
08:52:36 * byorgey nominates the name "roconnad".
08:52:40 <roconnor> @go commutative, copyable, discardable, strong, lax, monoidal functor
08:52:41 <lambdabot> No Result Found.
08:52:43 <shapr> opqdonut: Einar Karttunen?
08:52:45 <yrlnry> If I define   y g = g (y g), haskell infers type (a -> a) -> a for y.  But Curry-Howard says I oughtn't to be able to define anything with that type.
08:52:49 <yrlnry> So what's up there?
08:52:59 * roconnor sigh
08:53:10 <roconnor> I really am going to end up having this named after me.
08:53:13 <byorgey> yrlnry: what's down there, actually.  it's bottom. =)
08:53:21 <Olathe> @pl \f -> (\a -> Just (f a))
08:53:21 <lambdabot> (Just .)
08:53:23 <shapr> roconnor: Sometimes you feel a monad, sometimes you don't?
08:53:36 <yrlnry> byorgey: please elaborate.
08:53:44 <byorgey> yrlnry: in Haskell, bottom inhabits every type, so the Curry-Howard isomorphism sort of breaks.
08:53:55 <yrlnry>  Ohhh.
08:53:56 <shapr> At least when you hit bottom there's only direction left.
08:53:57 <Olathe> > [Nothing >>= (Just .) (+2), Just 3 >>= (Just .) (+2)]
08:53:59 <lambdabot>  [Nothing,Just 5]
08:54:14 <Olathe> Neat.
08:54:28 <yrlnry> If you have anything more to say about that, I'd like to hear it.
08:54:29 <byorgey> yrlnry: since C-H says that inhabited types correspond to true theorems of intuitionistic logic.
08:54:31 <wli> shapr: Try the bottom of a cube.
08:54:34 <yrlnry> Right.
08:54:40 <Igloo> Is there a way to get the maximum value that a Double can be?
08:54:44 <yrlnry> But in Haskell every type is inhabited.
08:54:49 <Igloo> (other than +Inf)
08:55:02 <ibid> therefore, haskell is inconsistent :)
08:55:07 <opqdonut> shapr: yeah
08:55:08 <ibid> *duck* *run*
08:55:16 <byorgey> yrlnry: exactly, so in Haskell you can have types that don't actually correspond to theorems, such as (a -> a) -> a.
08:55:36 <wli> Igloo: Like epsilon, double until fpclassify says it's infinite, remember the last non-infinite value.
08:55:44 <wli> Igloo: Or bit twiddle.
08:56:18 <roconnor> >pred Infinity
08:56:20 <roconnor> > pred Infinity
08:56:20 <lambdabot>   Not in scope: data constructor `Infinity'
08:56:23 <opqdonut> also, haskell has recursion which shouldn't be possible in strictly typed lambda calculus
08:56:25 <byorgey> yrlnry: note the implementation of your function 'f' depends on possibly non-terminating recursion -- i.e. bottom.
08:56:29 <roconnor> > pred (1.0/0.0)
08:56:30 <lambdabot>  Infinity
08:56:30 <opqdonut> yeah
08:56:30 <yrlnry> Sure.
08:56:50 <integral> C-H isn't stated in terms of haskell terms anyway
08:57:11 * ibid wonders why everyone's talking about Ctrl-H
08:57:20 <phlpp> hehe :D
08:57:27 <phlpp> :t pred
08:57:28 <lambdabot> forall a. (Enum a) => a -> a
08:57:29 <ibid> (sorry, i'm having a bad moment so i have to make bad jokes)
08:57:30 <phlpp> @src pred
08:57:30 <lambdabot> Source not found.
08:57:40 <monochrom> I offer to talk about Meta-L.
08:57:49 <yrlnry> Hmm, I never noticed that this works in SML either.  I thought if I tried to define Y in an H-M type system I would get a circulaity failure.
08:57:53 <phlpp> pred (5+3}
08:57:56 <phlpp> > pred (5+3)
08:57:57 <lambdabot>  7
08:58:01 <phlpp> > pred (5+3/0)
08:58:02 <lambdabot>  Infinity
08:58:11 <phlpp> > 5+3/0
08:58:11 <lambdabot>  Infinity
08:58:26 <doserj> > floatDigits (undefined::Double)
08:58:27 <lambdabot>  53
08:58:31 <byorgey> yrlnry: only in a H-M type system that is restricted to total functions, i.e. functions that are guaranteed to terminate for every input.
08:58:36 <integral> but haskell isn't just milner's type system.
08:58:45 <monochrom> SML gives call-by-value lambda calculus, so you get another complication.
08:58:45 <roconnor> why does kghostview grab my audio system?
08:58:48 <wli> > let zs = iterate (2*) (1.0 :: Double) in fst . head . dropWhile (not . isInfinite . snd) $ zip zs (tail zs)
08:58:49 <lambdabot>  8.98846567431158e307
08:58:52 <byorgey> right, haskell is H-M plus the kitchen sink =)
08:59:24 <yrlnry> SML is less kitchen-sinky, and for some reason I thought I remembered not being able to define Y, for type-circularity reasons.
08:59:37 <yrlnry> But I just tried it and it worked fine.  I wonder what i was thinking of?
08:59:41 <monochrom> Oh yeah, the infinite type thing.
08:59:51 <integral> PCF is much more restricted, if you're looking for that
08:59:55 <vincenz> byorgey: like the emacs of typing systems?
08:59:56 <monochrom> How does it look?
09:00:05 <byorgey> vincenz: something like that =)
09:00:11 <yrlnry> @pl \y g -> g ( y g)
09:00:11 <lambdabot> ap id
09:00:12 <ibid> istr something like the classical untyped y is not typable
09:00:28 <ibid> yrlnry: you aren't defining y, you're defining fix, btw
09:00:41 <monochrom> :t \y g -> g (y g)
09:00:42 <lambdabot> forall t t1. ((t -> t1) -> t) -> (t -> t1) -> t1
09:00:49 <ibid> (they have the same functional semantics but they are built differently)
09:00:57 <yrlnry> Yeah.
09:01:03 <integral> hmm, http://www.cs.st-andrews.ac.uk/~eb/partial.php
09:01:06 <lambdabot> Title: SK Combinator Calculus Interpreter
09:01:06 <yrlnry> Sure.
09:01:13 <monochrom> thoroughly interesting
09:01:35 <monochrom> how do you use it?
09:01:42 <ibid> the point of Y is that you don't have recursion in classical lambda calculus
09:02:09 <yrlnry> Ah, there it is.  I just defined the real Y and got a circularity error.
09:02:13 <yrlnry> Y = (S I I (S I I))
09:02:22 <shapr> @users
09:02:22 <lambdabot> Maximum users seen in #haskell: 412, currently: 401 (97.3%), active: 14 (3.5%)
09:02:56 <yrlnry> @src fix
09:02:56 <lambdabot> fix f = let x = f x in x
09:03:03 <yrlnry> okay.
09:03:21 <monochrom> And (\y g -> g (y g)) is still a step away from fix.
09:03:37 <yrlnry> I on'y did it that way because I didn't know how to ask the bot for what I really wanted.
09:03:51 <yrlnry> I actually have    y f = f (y f), as I said.
09:04:27 <ibid> yrlnry: notice, btw, how the @src uses let. you know why?
09:04:40 <yrlnry> No.  Why?
09:04:44 <yrlnry> Memory usage reasons?
09:04:46 <anX> lambdabot: I'm active now
09:05:58 <ibid> yrlnry: in lazy (as opposed to normal-order) evaluation, this way you make the thing that is returned truly self-referential
09:06:07 <ibid> in the term graph
09:06:48 <ibid> yrlnry: ie, f literally gets its own return value as its argument
09:07:01 <yrlnry> aha.
09:07:03 <ibid> it's called tying the knot
09:07:46 <yrlnry> whereas with y f = f (y f)  it's not clever enough to notice the common expression on both sides of the definition.
09:08:42 <ibid> yrlnry: it's not about cleverness, at this level
09:09:07 <ibid> yrlnry: a compiler optimizer might rewrite the non-let version as the let version
09:09:24 <ibid> yrlnry: what i'm talking about is thet semantics of lazy evaluation (ie. graph reduction)
09:09:46 <scvr> roconner: are you sure that you're not just talking about a symmetric strong monoidal functor?
09:10:40 <roconnor> scvr: right, symmetric is a good word
09:10:50 <roconnor> but I also have some other operations
09:10:59 <roconnor> I have F a -> F (a,a)
09:11:14 <roconnor> and F a -> F ()
09:11:17 <roconnor> ... I think
09:12:20 <bos> here, have a nice backdoored PRNG.
09:12:20 <roconnor> I'm sort of translating from applicative functor language using my intuation.
09:14:11 <scvr> I'm only starting to grok category theory but I think that symmetric is the appropriate term
09:14:20 * ibid actually thinks the haskell report is wrong in defining haskell as merely non-strict and not lazy
09:14:33 <shapr> How so?
09:14:42 <ibid> since there's a body of haskell idioms that make no sense if you don't have laziness
09:14:57 <ibid> tying the knot being an example
09:15:15 <monochrom> Standards like to leave things open. All standards do.
09:15:39 <doserj> > let d = undefined::Double in (2-2**(-(fromIntegral (floatDigits  d) - 1))) * 2^((fromIntegral . snd . floatRange $ d) -1)
09:15:40 <lambdabot>  1.7976931348623157e308
09:15:50 <ibid> monochrom: yes they do, but if that were the only criterion, all standards would leave *everything* open
09:15:59 <roconnor> ibid: does tying the knot only make sense with laziness?
09:16:02 <doserj> > let d = undefined::Float in (2-2**(-(fromIntegral (floatDigits  d) - 1))) * 2^((fromIntegral . snd . floatRange $ d) -1)
09:16:03 <lambdabot>  3.4028234663852886e38
09:17:06 <ibid> roconnor: up to the point where it's about trying to create circular data structures in the evaluator, yes
09:17:40 <roconnor> ibid: but you don't have to make circular structures do you?
09:17:42 <ibid> roconnor: of course, the idioms do produce correct results even without laziness, but then it'd usually be better to use a more straightforward way of doing things
09:17:58 <roconnor> ibid: you could just recompute the circle over again.
09:18:25 <roconnor> ibid: isn't tying the knot fairly straightforward?
09:18:37 <yrlnry> ibid: maybe I don't understand what you mean then.  I know about the graph reduction.  I'm pointing out that a sufficiently clever compiler could notice that the Y f = f (Y f)  graph could be knotted in the same way.
09:19:08 <ibid> yrlnry: yeah, which is about the same thing that i said :)
09:19:14 <SL> how do i output a list the follow way: between every list item a blank, after every third list item two blanks, at the end no blanks
09:19:29 <ibid> yrlnry: that a compiler can rewrite the non-knot version to trhe knot version
09:19:35 <shapr> SL: printf?
09:19:40 <ibid> yrlnry: but that's a matter of program translation
09:20:14 <roconnor> ibid: Haskell doesn't define operational semantics so all idioms that reflect complexity must be compiler specific.
09:20:28 <roconnor> by complexity I mean computational complexity.
09:20:34 <ibid> roconnor: fairly, yeah. but if you're not trying to create circularity, there usually is a *more* straightforward way of getting the same value out
09:20:43 <ibid> roconnor: exactly my point
09:21:01 <roconnor> ibid: I doubt there is a more straitforward way than tying the know.
09:21:07 <roconnor> straightforward.
09:21:11 <roconnor> knot
09:21:16 <roconnor> blah, keyboard.
09:22:27 <fxr> @seen uwe
09:22:27 <lambdabot> I haven't seen uwe.
09:23:55 <ibid> mh. yeah, i misread the fix stuff above
09:24:11 <ibid> so i don't have a ready-made example :)
09:26:29 <SL> shapr, dont know how long the list is
09:28:15 <shapr> SL: Do you know how to get every third list item out of a list?
09:28:37 <scvr> why is fix buried in Control.Monad instead of in the prelude?
09:28:41 <yaxu> http://doc.gold.ac.uk/~ma503am/alex/vocable-source-released/
09:28:43 <lambdabot> Title: Alex McLean » Blog Archive » Vocable source released
09:32:21 <fasta> scvr: it's in Data.Function, AFAIK.
09:32:41 <fasta> scvr: it used to be in Control.Monad.
09:33:14 <shapr> yaxu: w00! Is there a darcs repo?
09:33:40 <hpaste>  endgame pasted "nth element from a list" at http://hpaste.org/3895
09:34:05 <hashendgame> ack, I can't type. That should be "every nth element from a list"
09:34:14 <SL> hm, shapr, tell me
09:34:48 <shapr> SL: Can you get three items out of a list?
09:35:17 <shapr> yaxu: Also, how do I install supercollider on debian/unstable?
09:35:55 <shapr> yaxu: Do you have a blog entry with a tutorial?
09:36:53 <yaxu> shapr: i haven't got to darcs yet sorry
09:37:56 <yaxu> shapr: i guess you've seen this one http://slavepianos.org/rd/r/darcsweb.cgi?r=hsc3;a=plainblob;f=/Help/Tutorial/Tutorial.lhs
09:37:57 <lambdabot> http://tinyurl.com/2nghp6
09:38:07 <yaxu> one sec for more specific ones
09:38:13 <hashendgame> does anyone know of a good site for data structure design? I'm looking for things beyond neat recursive examples like data Tree a = Leaf a | Branch a [Tree a]
09:38:14 <atom> @src Ord
09:38:14 <lambdabot> class  (Eq a) => Ord a  where
09:38:15 <lambdabot>     compare      :: a -> a -> Ordering
09:38:15 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:38:15 <lambdabot>     max, min         :: a -> a -> a
09:38:24 <hpaste>  SL pasted "(no title)" at http://hpaste.org/3896
09:38:37 <yaxu> well that one is specific on the haskell side
09:38:42 <SL> shapr, http://hpaste.org/3896
09:39:05 <atom> @src Ordering
09:39:06 <lambdabot> data Ordering = LT | EQ | GT
09:39:46 <shapr> SL: So, could you apply that function repeatedly to a list?
09:40:48 <SL> shapr, dont think so
09:42:59 <yaxu> shapr: well either download the source and follow instructions in linux/README and linux/scel/README
09:43:19 <yaxu> shapr: or try your luck with apt-get install supercollider
09:44:40 <opqdonut> hashendgame: well "purely functional data structures" is pretty good http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
09:44:54 <yrlnry> merus: a few months ago you gave me really useful help on something.  I don't remember what it was,  But thanks again.
09:44:56 <opqdonut> it concentrates on analysis, tho
09:45:21 <hashendgame> opqdonut: this looks great. Thanks
09:46:11 <shapr> @type repeate
09:46:13 <lambdabot> Not in scope: `repeate'
09:46:13 <shapr> @type repeat
09:46:14 <lambdabot> forall a. a -> [a]
09:46:24 <shapr> @type iterate
09:46:24 <lambdabot> forall a. (a -> a) -> a -> [a]
09:46:29 <shapr> SL: Have you seen the iterate function?
09:46:41 <yrlnry> Snacks are already in progress.
09:46:43 <yrlnry> ww.
09:47:09 <shapr> yaxu: I don't have a supercollider package.
09:48:55 <shapr> SL: Look at the iterate function, it can apply a function multiple times.
09:49:35 <yaxu> shapr: hm, that's strange, i'm pretty sure debian unstable has it
09:49:56 <dons> dcoutts: jdh reckons the ocaml compiler is installed as often as ghc on debian, that seems unlikely imo, due to darcs, xmonad and pugs. details here: http://flyingfrogblog.blogspot.com/2007/11/most-popular-functional-languages-on.html  is there some way of reproducing these numbers?
09:49:57 <lambdabot> Title: The Flying Frog Blog: Most popular functional languages on Linux, http://tinyurl.com/25zaac
09:50:01 <dons> Igloo: ^^
09:50:54 <dons> (its yet another advert for his book, unfortunately)
09:50:58 <yaxu> gotta dash, back later
09:51:40 <dcoutts> dons: we don't measure package popularity in gentoo at all
09:51:54 <dons> ok.
09:52:05 <dcoutts> dons: so we only have highly indirect measures like number/frequency of bug reports when we break things
09:52:17 <dikini> is anyone interested in reviewing some code I wrote - it's mostly an exercise for me, but would love to improve it, so any suggestions are welcome
09:52:39 <dikini> oh, and soory it is in a blog post
09:52:47 <geocalc> debian is not the only linux fortunately ;)
09:52:52 <dikini> http://dikini.net/15.11.2007/learning_to_speak_erlang_style_concurrency_in_haskell
09:52:53 <lambdabot> Title: Learning to speak - erlang style concurrency in haskell | dikini.net, http://tinyurl.com/yoxmwa
09:53:08 <dons> looks interesting, dikini
09:53:44 <Igloo> dons: http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6%2Cocaml&show_installed=on&show_vote=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
09:53:45 <lambdabot> Title: popcon graph, http://tinyurl.com/2xa274
09:54:07 <Igloo> says ocaml is slightly ahead on installations, ghc6 is ahead on people using it recently
09:54:15 <dikini> well it's my first non-example program in haskell -  as I mention there, I probaly will end up using it for bugs and other social insects :)
09:54:20 <Igloo> And the ghc graphs seems to be heading upwards faster
09:54:24 <dons> why are people installing the ocaml compiler? :)
09:54:45 <dons> can we add hugs too?
09:55:19 <Igloo> ocaml is a far smaller package than ghc6, so it might get purged by people who don't use it less frequently
09:55:26 <dons> ah
09:55:41 <dons> interesting graph though
09:56:06 <Igloo> You can add hugs to the list, but you can't get numbers for "has ghc6 and/or hugs installed"
09:56:06 <dons> and xmonad is in debian now, i note
09:56:23 <Igloo> Interestingly ghc6 overtook hugs 8months or so ago
09:56:40 <Igloo> Probably partly due to larger hard disks and faster machines
09:56:43 <dons> that's amazing.
09:56:52 <dons> that hugs held out for so long -- lots of courses teaching
09:57:27 <dons> right, so john's graphs don't show hugs and ghc
09:57:41 <SL> shapr, dont know how to use in this case?
09:57:41 <dons> meaning there's roughly twice the number of installs,
09:57:44 <kaol> I have hugs installed on my box just so that I can grep through /usr/lib/hugs/packages/base
09:58:20 <kaol> I'm guessing some other popcon users do the same ;-)
09:58:51 <dons> there's a good one, http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6%2Cerlang&show_installed=on&show_vote=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
09:58:52 <lambdabot> Title: popcon graph, http://tinyurl.com/ynkn6g
09:59:11 <dons> something went badly wrong in the erlang binary?
10:02:04 <Igloo> dons: http://people.debian.org/~igloo/popcon-graphs/index.php?packages=erlang%2Cerlang-nox&show_installed=on&show_vote=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
10:02:06 <lambdabot> Title: popcon graph, http://tinyurl.com/3ao758
10:02:21 <dons> ah, much more sensible
10:03:03 <Igloo> That's basically the time the Debian etch release happened
10:03:09 <dons> ic
10:03:10 <Igloo> And probably other people are using other erlang-* variants
10:03:15 * Igloo AFKs
10:04:56 <dons> dikini: have  you looked at Chans ?
10:05:03 <dikini> Chans?
10:05:10 <dons> concurrent channels
10:05:15 <dons> ?docs Control.Concurrent.Chan
10:05:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
10:05:20 <pheaver> so I am looking at runProcess and runInteractiveProcess in System.Process.  How would I use one of these to invoke a command and have its stdout or stderr directed to both the screen and a file?  Note that I want to contents written as they are being produced, not afterwards, and it seems that opening a file handle and then using hPutStr would only write the contents after the process finished, rather than lazily?
10:05:22 <dikini> yes
10:06:15 <dikini> dons: why? I'm using them as a basis for the implementation, just skipped pasting the imports, et al
10:06:37 <dikini> dons: the code is attached at the bottom
10:06:49 <dons> ah, i missed that
10:08:06 <dons> Igloo: is the specconstr fix in the stable branch now?
10:08:07 <Saizan_> dikini: in the definition of runProcess there are many symbols not in scope
10:08:13 <dikini> I'm really impressed by haskell
10:08:34 <dikini> Saizan_: in the ErlActors.hs?
10:08:37 <dons> dikini: cool. its a lot of fun
10:08:45 <pheaver> :)
10:08:50 <dons> Igloo: so why are people still installing the ocaml compiler?
10:09:09 <dons> Igloo: also, i bet a runtime dependency on ghc, by xmonad 0.5 helps the install stats :)
10:09:21 <Saizan_> dikini: in the second snippet in your blog post
10:10:13 <dikini> Saizan_: yep, it is just a snippet, all of the code is attached to the post, I might need to clarify that :(
10:10:17 <Saizan_> dikini: however, i can't fine the link to the code
10:10:22 <Saizan_> *find
10:11:13 <dikini> hmm, gimme a sec
10:12:03 <dikini> I forgot my own paranoia, it is up now
10:13:07 <ToRA> @hoogle (Eq a) => a -> [a] -> [[a]]
10:13:12 <lambdabot> No matches, try a more general search
10:13:26 <ToRA> anyone know if there's a general split combinator anywhere?
10:14:05 <dmwit> :t splitRegex
10:14:06 <lambdabot> Not in scope: `splitRegex'
10:14:22 <ToRA> i need it more general than just on strings tho
10:14:27 <dmwit> ok
10:14:46 <ToRA> i have a nasty 1 liner, but i'm wondering if there's something in the libraries i've not seen
10:14:54 <ToRA> :t  let f delim =  unfoldr (liftM2 (>>) (guard . not . null) (Just . second (drop 1) .  break (== delim)))
10:14:54 <lambdabot> <command line>:
10:14:54 <lambdabot>     Could not find module `L':
10:14:54 <lambdabot>       Use -v to see a list of the files searched for.
10:14:59 <ToRA> heh
10:15:04 <ToRA> :t  let f delim =  unfoldr (liftM2 (>>) (guard . not . null) (Just . second (drop 1) .  break (== delim))) in f
10:15:04 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
10:15:34 <shapr> SL: Try it out in ghci
10:15:40 <shapr> pas de pb!
10:16:16 <Saizan_> dikini: however your blog software is mangling the code i think, it ate everything from the <- of fini' and the next ->
10:17:12 <dikini> I'll have a look
10:17:47 <dcoutts> dons: heh, you beat me to it
10:17:59 <dcoutts> re haskellforge that is
10:18:06 <dons> :)
10:18:16 <dons> dcoutts: see the egregious spec constr typo?
10:18:26 <dcoutts> dons: yeah, funny :-)
10:18:38 <dcoutts> glad to know SPJ does it too :-)
10:18:44 <dons> i think that's the 2nd this year i've seen
10:18:51 <dons> x / x' considered harmful!
10:18:57 <dcoutts> like he says, they need performance tests
10:19:06 <dcoutts> to catch regressions like this
10:19:11 <dons> yep. andy gill and i were discussing this yesterday
10:19:20 <dons> before this issue came up
10:19:28 <dons> i bet the mandelbrot slow down is due to this stuff breaking
10:19:41 <dcoutts> dons: right, one can only really optimise what one can measure
10:19:50 <dikini> Saizan_: thanks, missed that :(
10:19:58 <dcoutts> hia andyjgill
10:20:09 <andyjgill> hi dcoutts
10:20:16 <dcoutts> (as in speak of the devil)
10:20:31 <andyjgill> :-)
10:20:35 <Olathe> The devil is evil.
10:20:38 <dcoutts> andyjgill: dons was just mentioning you were talking about measuring performance to catch perf regression bugs
10:20:41 <andyjgill> What were you talking about
10:21:01 <andyjgill> Ahh. yes. We do need to, and see SPJs email today.
10:21:01 <dons> andyjgill: so spj had a typo that broke spec constr in 6.8.1, did you see that?
10:21:14 <dcoutts> andyjgill: it was an env vs env' bug :-)
10:21:44 <dons> how does one prevent that statically?
10:21:50 <andyjgill> What I want is a detailed report generator, and some web tools for investigating things
10:22:09 <dcoutts> dons: declare a parameter to be linear and use a linear type extension?
10:22:20 <andyjgill> Basically, every night a buildbot-ish thing says I ran these tests, and here are all the times.
10:22:27 <dons> dcoutts: right, that's what i was thinking. a bit heavy, but oh well
10:22:33 <dcoutts> dons: that is, if it is being used linearly, but it might be branching
10:22:40 <Saizan_> dikini: also, you call forward to restore the discarded messages in the mbox, but you're not maintaining the ordering, because if another thread in the meantime sent a message to that mbox the forwarded messages will come later instead of before, or not?
10:22:40 <dons> andyjgill: so how do we tag failure?
10:22:45 <dons> record runs fomr the night before?
10:22:49 <dcoutts> dons: it's pretty hard in general I expect
10:22:56 <andyjgill> Its simple, I've got an xml format for it, and good tools for displaying it alreadt
10:23:17 <andyjgill> (simple => concept, not simple => trivial)
10:23:29 <dcoutts> dons, andyjgill: SPJ was suggesting measuring allocations as it's more reliable than time, but how about hpc ticks?
10:23:36 <dons> mm
10:23:41 <andyjgill> Then we have a SQL DB for all the history.
10:23:52 <dikini> Saizan_: yes, I should have used ungetChan
10:23:55 <andyjgill> Ticks are the same as entries in Gofer.
10:24:02 <andyjgill> But lots of optimizations fail to kick in.
10:24:05 <dikini> no idea why I changed it
10:24:42 <dcoutts> andyjgill: hmm, so it needs to be something that does not interfere with optimisations
10:24:55 <dcoutts> andyjgill: isn't that what ticky ticky profiling was for?
10:25:03 <Saizan_> dikini: also, you are assuming that only the owner reads from the mbox, right?
10:25:10 <dikini> yes
10:25:23 <andyjgill> Allocations are a good approximation, though
10:25:31 <dikini> that is the reason for all of the wrapping and the type of Message
10:25:37 <andyjgill> Or count CPU cycles
10:25:39 <dons> what about -fasm instruction counts?
10:25:44 <dcoutts> andyjgill: for simplifier perf bugs, yes. It's less good for lower level stuff.
10:26:12 <dcoutts> dons: static count or dynamic?
10:26:18 <dikini> Saizan_:  I'm considering hiding the Process constructor, so that there is no way to leak it
10:26:25 <dons> dcoutts: just a static count
10:26:36 <dikini> that is legal ways
10:26:45 <dcoutts> dons: then it's not clear which is better, inlining increases the static count usually.
10:27:06 <dons> yes, that's a good point
10:27:39 <Saizan_> dikini: even in that case the owner can forkIO passing the Process around
10:27:56 <andyjgill> On some CPUs, there is a register to help mesurements
10:28:22 <dcoutts> andyjgill: yes, all modern ones. The RTS has some code to count it. The "PAPI".
10:28:42 <dcoutts> andyjgill: that's what JaffaCake used to get the perf counts for the pointer tagging work.
10:29:14 <dcoutts> andyjgill: that was stuff like stalls due to cache misse and branch mis-prediction
10:29:15 <dikini> yes, but the owner doen't have access to the value, just to a send function
10:30:05 <Saizan_> dikini: and how does he receive?
10:30:08 <dikini> Saizan_ is the reason for the feedback gymnastics in runProcess
10:30:24 * dikini learns to type
10:31:25 * MyCatVerbs thinks he ought to learn to type... say, in Chinese.
10:31:41 <dikini> Saizan_: runProcess uses feedback to pass the termination flag, send callback tuple (fini', ...)
10:31:58 <dikini> feedback is a similar style callback
10:32:29 <Saizan_> dikini: yes i see, but that doesn't give feedback a way to receive from the mbox
10:32:36 <dikini> Saizan_:  I choreographed it this way exactly to minimise potential for leakage
10:32:50 <dikini> that is the poit
10:32:53 <dikini> point
10:33:35 <dikini> the only place where Process is kept accessible is the third argument of runProcess
10:33:40 <Saizan_> ok
10:33:44 <dikini> it is passed to it by the bracket
10:33:53 <cjay> is there a library for network-synchronized data structures? a kind of virtual distributed memory.. maybe something like stm, but not only for local processors..
10:34:16 <Saizan_> that argument represent what that process does, right?
10:34:37 <dikini> yes, that is the 'behaviour' of the thread
10:35:17 <dikini> the producer/consumer functions
10:35:24 <dikini> in the example
10:35:32 <Saizan_> ok, i'm just saying that the "behaviour" can send Process around as he wish breaking the assumption that only one thread reads form a mbox
10:35:45 <Saizan_> *from
10:36:02 <dikini> Saizan_: possible
10:36:20 <dikini> it can call anyone, it is not firewalled
10:37:37 <dikini> I would be curious how to stop that
10:37:53 <dikini> no clue at all
10:39:03 <dikini> but then again, is it that bad?
10:39:24 <Saizan_> it's bad because if two of them receive everything can happen
10:39:27 <pheaver> How can I setup a Handle such that writing to the handle will cause output to both stdout and some file?
10:40:28 <dikini> yep
10:40:38 <dons> pheaver: write to a Chan, and have two threads write out to handles?
10:40:49 <pheaver> hmm.m..
10:41:02 <dons> you want to write to two Handles simultaneously
10:41:04 <pheaver> seems more complicated than it should be
10:41:14 <dikini> So... isolating mbox even from the behaviour process...
10:41:14 <pheaver> yeah, essentially I want what the shell command 'tee' does
10:41:35 <Heffalump> except that does it by having a separate process reading from the handle you write to
10:41:43 <Heffalump> you might be able to do it all within the same Haskell process
10:41:45 <dikini>  that would be interesting
10:42:28 <Saizan_> dikini: maybe you can look at the ST monad, and how it prevents you to use STRefs in different blocks
10:42:28 <pheaver> well, here's what I am messing with now...
10:42:57 <pheaver> out <- hGetContents handle; putStr out; hPutStr fileHandle out
10:43:06 <dikini> Saizan_:  I'll have a look, thanks for the pointer
10:43:36 <pheaver> at first I thought that wouldn't be "lazy" enough for me, that the contents would not be written until they were entirely produced
10:43:40 <pheaver> but it seems to be doing what I want... huh
10:46:52 <nominolo> @pl \n x -> f n
10:46:53 <lambdabot> const . f
10:47:30 <defcons> @hoogle [[a]] -> [[a]] -> [a]
10:47:30 <lambdabot> No matches, try a more general search
10:47:48 <defcons> @hoogle [a] -> [a] -> [a]
10:47:48 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
10:47:48 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:47:48 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:48:11 <defcons> @hoogle [[a]] -> [a]
10:48:11 <lambdabot> Prelude.concat :: [[a]] -> [a]
10:48:15 <defcons> that's the one
10:51:17 <desegnis> pheaver: That's the usual Prelude.(g|hG)etContents pitfall
10:51:55 <desegnis> People complain that those functions work lazier than they look every week ;)
10:52:11 <pheaver> oh
10:52:19 <pheaver> well, i am definitely not complaining, I am satisfied heh
10:52:36 <pheaver> pleasantly surprised
10:52:49 <desegnis> Well, there are cases where this laziness can cause subtle bugs. I don't have an example by hand, though
10:53:03 <pheaver> yeah i can imagine
10:53:34 <desegnis> (the tricky thing is that this is not lazy evaluation, as is present everywhere in Haskell, but lazy I/O)
10:53:46 <pheaver> yes
10:54:24 <dcoutts> lazy I/O is very cool, but it's a leaky abstraction
10:54:26 <defcons> @hoogle [a] -> [a] -> [a]
10:54:30 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
10:54:30 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:54:30 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:54:51 <defcons> isn't (:) of the same type?
10:55:05 <Olathe> :t (:)
10:55:09 <lambdabot> forall a. a -> [a] -> [a]
10:56:04 <defcons> right
10:59:04 <dikini> Saizan_: I've changed forward to use unGetChan, now at least you can
11:09:59 <Saizan_> dikini: i think you're putting them back in reversed order
11:12:00 <dikini> hmm, I'm afraid you are right, I'll correct that
11:12:06 <defcons> @hoogle a -> [[a]]
11:12:06 <lambdabot> No matches, try a more general search
11:12:21 <defcons> @hoogle a -> Int -> [[a]]
11:12:22 <lambdabot> No matches, try a more general search
11:12:30 <Olathe> @hoogle [a] -> [[a]]
11:12:30 <lambdabot> List.inits :: [a] -> [[a]]
11:12:30 <lambdabot> List.tails :: [a] -> [[a]]
11:12:30 <lambdabot> List.group :: Eq a => [a] -> [[a]]
11:16:29 <pitecus> what's the approach to memoization in haskell? is it impossible in the general case to memoize a function without changing the type, right?
11:17:07 <dmwit> No, you should be able to keep the type.
11:17:11 <dmwit> (I think.)
11:17:40 <pitecus> dmwit, how?
11:17:45 <dmwit> Let me try to find the mail I'm thinking of, hold on.
11:17:46 <scvr> pitecus -- you can think of it as "wrapping" the function in an appropriate datastructure
11:17:55 <nominolo> > do x <- Just 42; guard (x < 23); return x
11:17:57 <lambdabot>  Nothing
11:18:06 <nominolo> > do x <- Just 42; guard (x > 23); return x
11:18:07 <lambdabot>  Just 42
11:18:31 <monochrom> http://www.haskell.org/haskellwiki/Memoization shows how to memoize.
11:18:31 <lambdabot> Title: Memoization - HaskellWiki
11:20:24 <scvr> The examples there all work on a single integral argument -- you can extend the notion to any other sort of datastructure though
11:20:30 <pitecus> that looks pretty esoteric
11:21:06 <dmwit> Dang, I can't find what I'm looking for.
11:21:14 <scvr> pitecus: the memoized_fib function is probably the easiest to understand
11:21:32 <monochrom> dmwit: Okassaki's memo combinator?
11:21:37 <dmwit> The idea is to write a function that takes an array (or whatever) of the answers.
11:21:53 <dmwit> Then you wrap that function in another that just indexes the array.
11:22:35 <monochrom> The haskellwiki page's memoized_fib uses a list. But it uses the list as an array. You could use an array, or a Data.Map.
11:22:51 <dmwit> right
11:23:10 <dmwit> I think I have an example of it around here, let's see if I still have my Project Euler code...
11:23:21 <scvr> its easiest just to play with lists at first though
11:24:06 <dmwit> Never mind, my example is too specialized to be useful. =P
11:25:15 <pitecus> Thanks guys I'm gonna try it out
11:27:20 <pitecus> OK so the memoized fib thing seems to depend on the fact that you can enumerate all possible arguments
11:27:37 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo is probably what dmwit tried to find on the mailing list.
11:27:40 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
11:28:04 <dmwit> Yes, that one!
11:28:26 <dmwit> Now I know why I couldn't find it, I thought it was by Oleg.
11:28:26 <scvr> pitecus: what are you trying to memoize?
11:28:47 <monochrom> It has been an exercise of "Finding Memo".
11:29:02 <pitecus> scvr, a function which takes complex arguments, not just integers
11:29:23 <byorgey> monochrom: haha
11:29:53 <scvr> right, so you need to operate on a datastructure fancier than a list -- its still enumerable though (assuming you want integral complex arguments and not fractional ones, right?)
11:29:53 <monochrom> You can make your arguments an instance of Ord (for Data.Map keys) or Ix (for array indexes) or hashable.
11:31:37 <pitecus> scvr, sorry i didnt mean complex numbers, just values of some complex type
11:31:59 <scvr> Can you enumerate the values of the type with a list comprehension?
11:32:11 <pitecus> monochrom, I still dont see how to implement the equivalent of this: (map fib [0 ..] !!)
11:32:40 <pitecus> scvr, for the sake of argument lets say the values are lists of strings
11:32:57 <pitecus> I cant enumerate all possible values of that
11:34:21 <scvr> (\x -> fmap myFunc (Map.fromList [a list comprehension to generate all strings]) ! x)
11:35:00 <defcons> is it common to do all typedefs  of functions at the top of a source file, or as they are written?
11:36:00 <monochrom> At the end of the haskellwiki page, there is a list of more reading material. The answer to your question hides somewhere there.
11:36:12 <dmwit> pitecus: If you have some idea of what values will and will not be used, it can still be doable, otherwise you may want to change the type signature a bit.
11:36:14 <scvr> the irritating way to make this efficient would be to write a lazy trie sort of like point 3 in the wiki page
11:36:32 <dmwit> pitecus: Like, a State (Map String Answer) kind of thing.
11:36:38 <monochrom> Moreover the reading material is mailing list messages. You can further read whole threads, not just the particular messages cited.
11:37:06 <monochrom> I am too lazy to write actual code for you.
11:37:07 <scvr> alternately you could stop messing with a purely knot-tying lazy implementation and switch to one where you explicitly pass the map
11:37:25 <pitecus> i think changing the signature might be the more reasonable thing to do
11:37:45 <pitecus> ok thanks again
11:38:30 <byorgey> defcons: usually, the type of a function is written just above the function definition.  it would be strange to put all the types at the top and then have all the definitions.
11:38:42 <byorgey> (although it would be perfectly valid Haskell)
11:38:46 <defcons> okay
11:38:53 <defcons> thank you
11:39:06 <monochrom> You can also put them at the end.
11:39:22 <scvr> Data.StringMap being so rusted irritates me -- I want to use string tries all the time -- dunno why work on this faded away
11:39:25 <defcons> :)
11:42:14 <monochrom> Perhaps someone should add to the haskellwiki page something other than Int.
11:44:04 <dmwit> All sensible functions operate only on Ints.
11:48:06 <monochrom> Why?
11:50:43 <Olathe> Because data structures are evil.
11:51:11 <monochrom> I think data non-structures are evil.
11:51:11 <defcons> even sets?
11:51:31 <defcons> I guess every set could be given an integer
11:51:39 <nburlett> hey all, can I get a hand with some file IO issues?
11:51:50 <dmwit> You would think you want to operate on Strings, but you really want to operate on their hashes.
11:51:52 <dmwit> ;-)
11:52:14 <dmwit> nburlett: What's the problem?
11:52:17 <nburlett> I'm running parseFromFile on a large list of input files
11:52:17 <monochrom> ("data non-structures" means trying to encode rich structure meaningful things into flat meaningless things, such as GÃ¶del numbering.)
11:52:27 <nburlett> and eventually I get: openFile: permission denied (Operation not permitted)
11:52:52 <nburlett> I expect this is due to having too many files open
11:52:59 <nburlett> because the file it talks about, I can open directly just fine
11:53:03 <whoopsbob> Is there a function in the prelude which returns the first element of a list which matches a predicate?
11:53:15 <monochrom> I am going to blind guess. You readFile "xxx", then you open or readFile "xxx" again.
11:53:33 <wli> Data.List.find
11:53:44 <nburlett> monochrom: I don't think so
11:54:07 <dmwit> You may be running out of file handles.
11:54:10 <monochrom> Second blind guess. You readFile many many files.
11:54:11 <dmwit> Do you close them?
11:54:13 <nburlett> dmwit: I think that's the problme
11:54:23 <nburlett> I tried closing them directly
11:54:26 <nburlett> but then it wouldn't work
11:54:38 <dmwit> I bet you use the file equivalent of getContents.
11:54:38 <nburlett> so now I'm using parsec's parseFromFile
11:54:48 <nburlett> dmwit: I was using that, yes
11:54:49 <whoopsbob> wli: thanks
11:55:09 <dmwit> Okay.  I think I've heard rumblings before that getContents is "too lazy" if you want to look at lots of files.
11:55:16 <dmwit> I don't remember the solution.
11:55:19 <nburlett> it does seem that way
11:55:22 <dmwit> =/
11:55:33 <monochrom> hGetContents?
11:55:54 <nburlett> I tried that too
11:56:02 <monochrom> hGetContents and readFile are closely related. I consider them the same for this problem.
11:56:31 <nburlett> what can I use to read in a file strictly?
11:56:32 <dmwit> Maybe what you can do is:
11:56:33 <monochrom> The handle won't close unless and until everything is read.
11:56:46 <dmwit> open, force the read (with seq), then close
11:56:52 <nburlett> yeah, the parser bombs out on some of these files
11:56:56 <monochrom> calculating the length is one way.
11:57:07 <monochrom> seq only forces the next character.
11:57:12 <nburlett> hGetContents `seq` runParser p () fname ?
11:57:13 <dmwit> mmm
11:57:55 <hashendgame> couldn't you stick a $! in somewhere?
11:58:06 <monochrom> same difference with seq.
11:58:24 <monochrom> > seq ('a':undefined) "hello"
11:58:26 <lambdabot>  "hello"
11:58:42 <monochrom> > seq (length ('a':undefined)) "hello"
11:58:43 <lambdabot>  Undefined
11:58:52 <Olathe> > undefined
11:58:52 <lambdabot>  Undefined
11:59:04 <monochrom> That should show you how to force things.
11:59:08 <nburlett> ok
11:59:12 <nburlett> thanks
12:00:22 <monochrom> If the parser absolutely slurps things until EOF, you should not need it.
12:00:52 <nburlett> monochrom: I don't think it does
12:01:04 <monochrom> Alright, then you need it.
12:02:33 <nburlett> huh, that didn't help
12:03:01 <hpaste>  nburlett pasted "strange file error" at http://hpaste.org/3897
12:03:59 <monochrom> Alright, return is lazy. (length input) `seq` return parsed.
12:04:31 <nburlett> hell yeah!
12:04:34 <nburlett> thanks, monochrom
12:05:01 <monochrom> I'm now wondering why even if you close explicitly it is not closed.
12:05:31 <dmwit> Can close signal a failure?
12:06:26 <nburlett> monochrom: when I was closing explicitly, I got different errors.. namely, that the file didn't read anything
12:06:47 <monochrom> I see. Then that's normal.
12:07:16 <monochrom> "let parsed = runParser assessments () fname input" is lazy. The parsing and reading doesn't happen yet.
12:07:34 <monochrom> You have to force "parsed" before you close.
12:07:40 <nburlett> yeah
12:07:45 <nburlett> I was using bracket
12:08:20 <nburlett> bracket (openFile fname ReadMode) (hclose) (\h -> hGetContents >>= runParser assessments () fname)
12:08:21 <monochrom> parsed `seq` return parsed  should work.
12:08:40 <dmwit> laziness--
12:08:45 <monochrom> laziness++
12:08:50 <hashendgame> wouldn't 'return $! parsed' look nicer?
12:08:53 <monochrom> Yes.
12:09:39 <monochrom> hGetContents >>= runParser assessments () fname  should be a type error.
12:10:00 <dmwit> After the previous discussion, why would laziness get a karma point?
12:10:05 <nburlett> uh, maybe it is, I tried it from memroy
12:10:30 <swiert> @seen lispy
12:10:30 <lambdabot> I haven't seen lispy.
12:10:37 <swiert> @seen mboes
12:10:37 <lambdabot> I haven't seen mboes.
12:10:53 <nburlett> huh, the parsed `seq` return parsed gives different results
12:11:00 <monochrom> dmwit: It is unsafeInterleaveIO rather than general laziness causing the present problem.
12:11:42 <dmwit> ok...
12:11:48 <monochrom> Do you like the new result? :)
12:12:03 <nburlett> not really
12:12:10 <nburlett> well, they both bomb out with Prelude.read: no parse
12:12:13 <nburlett> but that's my fault
12:12:39 <nburlett> however, it's odd that the length-based one dumps the errors from file parsing first
12:12:43 <nburlett> actually, wait, no it isn't
12:12:54 <nburlett> that actually makes perfect sense
12:23:39 <hashendgame> anyone around who familiar with the Network module? I want to store a port number in a file but if I store it as an Int I can't convert it into a PortNumber
12:26:27 <Lemmih> hashendgame: You can convert it with 'fromIntegral'.
12:30:55 <hashendgame> Lemmih: works, thanks
12:39:13 <nburlett> speaking of the network module, how do I convert hostnames to IP addresses?
12:39:37 <hpaste>  monochrom annotated "strange file error" with "two solutions" at http://hpaste.org/3897#a1
12:40:49 <nburlett> monochrom: thanks for that
12:41:03 <monochrom> Network.BSD.getHostByName
12:41:50 <nburlett> monochrom: excellent, I'll have to try that on my project when I get home tonight
12:43:24 <nburlett> be back later (probably
12:44:20 <desegnis> Btw, for a strict variant of hGetContents, you're fine with using Data.Bytestring.hGetContents. The only caveat being that reading a bytestring and converting to a String (for Parsec, say) feels just odd.
12:44:52 <monochrom> Yes, I'm now thinking about Data.ByteString.Char.unpack.
12:44:58 <desegnis> Huh... too late, it seems.
12:45:19 <desegnis> ah, monochrom is still there
12:46:48 <Heffalump> iterate :: (a -> a) -> a -> [a]
12:46:56 <Heffalump> oops, sorry
12:48:32 <phobes> Is there a standard way to define a free product operation on a pair of Monads?
12:51:31 <swiert> phobes: what do you mean by "free product operation"?
12:52:35 <phobes> It seems like it should (maybe) be possible to form a new Monad from two given ones
12:53:02 <phobes> by taking formal combinations of elements in a manner similar to a free product
12:53:29 <phobes> I'm wondering if 1) this is true or I'm missing something and 2) if it's true, do people do this and what for?
12:54:16 <mauke> data P m n a = P (m a) (n a);  instance (Monad m, Monad n) => Monad (P m n) where return x = P (return x) (return x); P a b >>= f = P (a >>= f) (b >>= f)
12:54:20 <swiert> @go combining monads using coproducts
12:54:21 <lambdabot> http://lambda-the-ultimate.org/classic/message12291.html
12:54:21 <lambdabot> Title: LtU Classic Archives
12:55:06 <swiert> IIUC, by free product you mean categorical coproduct.
12:55:28 <phobes> very likely - my category theory is very weak :)
12:55:52 <swiert> There's a slight problem with that paper though - it only works for "ideal monads".
12:56:04 <desegnis> Lol. Next tutorial: You could have invented categorical coproducts!
12:56:15 <desegnis> Sounds stunning, anyway.
12:56:16 <phobes> mauke - I don't think that is what I want ... that looks more like a regular product than a free product
12:56:39 <swiert> That is monads where you have a function unreturn : m a -> Maybe a that is a partial inverse to return.
12:56:58 <swiert> A lot of interesting monads in Haskell (think IO, State, ST, etc) aren't ideal.
12:57:19 <phobes> Oh, then this probably isn't going to be what I am envisioning actually
12:57:37 <phobes> but i'm looking at it now...
12:57:47 <swiert> phobes: they mention what the coproduct of monads are in general, though.
13:00:19 <Heffalump> swiert: what's wrong with unreturn = const Nothing ?
13:00:35 <Heffalump> or does unreturn (return a) have to be Just a ?
13:00:48 <swiert> Yes - exactly.
13:01:22 * Heffalump is not sure what "partial inverse" really means
13:01:26 <mauke> @djinn m a -> Maybe a
13:01:26 <lambdabot> f _ = Nothing
13:01:32 <swiert> The problem is that you m1 + m2 basically boils down to different "layers" of computation.
13:01:50 <swiert> Do some a computation in m1, then do one in m2, then one in m1 etc.
13:02:22 <swiert> But you want to make sure that you flatten out any subsequent m1 layers (same for m2)
13:02:42 <swiert> And use the monad laws to remove "trivial" monadic layers (trivial being just returns)
13:02:56 <swiert> I'm probably not explaining this very well...
13:03:48 <ADEpt> swiert: no, no. continue, please
13:03:51 <mauke> yeah, what are we even paying you for
13:05:04 <swiert> Anyhow - that's why you actually need the unreturn function (called etaInv) in the paper (handwave-handwave).
13:05:49 <swiert> Neil and Tarmo have a later paper which is pretty hard core category theory...
13:05:58 <swiert> But I haven't actually read that too closely.
13:06:35 <swiert> I talked about this paper with Neil the other day, and he's not too happy with it. A lot of the time you don't want the coproduct apparently.
13:06:38 <phobes> Ok, thanks, this is closely related to what I was thinking, but not quite the same
13:07:08 <phobes> Basically it looks like the use of 'unreturn' is to allow '
13:07:10 <phobes> oops
13:07:23 <phobes> 'return' to be identified for both monads
13:07:25 <swiert> There's usually some interaction between the monads you're combining. A lot of the monad transformers in mtl aren't just coproducts.
13:10:00 <swiert> phobes: I'm not sure. As I understand it, the coproduct is a quotient. To decide equivalence of the relation you're quotienting over you, you need etaInv.
13:10:54 <phobes> I'm not positive yet, but I don't think the structure I was envisioning was the coproduct, but something a little bigger that is free
13:10:59 <phobes> (not a quotienT)
13:12:17 <swiert> phobes: but if you want the resulting thing to be a monad again, you need to identify certain things.
13:12:38 <swiert> for example, what should the return of m1 + m2 be? The return of m1 or the return of m2?
13:12:52 <swiert> the choice shouldn't matter - that's where you quotient.
13:13:08 <swiert> If you don't, there's no guarantee that the structure you end up with is a monad again.
13:14:21 <phobes> I was thinking the return of the product would be a formal entity
13:14:43 <phobes> You're right though, that I am envisioning some kind of quotient here :)
13:15:28 <swiert> phobes: fair enough. Combining monads is just tricky business, anyway you slice it.
13:15:33 <swiert> *any way
13:17:45 <RayNbow> heh... http://www.haskell.org/haskellwiki/Literate_programming#Listings_package is a bit incomplete...
13:17:46 <lambdabot> Title: Literate programming - HaskellWiki, http://tinyurl.com/y5klfa
13:18:01 <RayNbow> it replaces (//) with two lambdas :p
13:18:37 <phobes> swiert:  Anyway, thanks for the reference.  I really should spend some time at some point getting more comfortable with category theory...
13:18:38 <dmead> ?src foldr
13:18:38 <lambdabot> foldr k z xs = go xs
13:18:38 <lambdabot>     where go []     = z
13:18:38 <lambdabot>           go (y:ys) = y `k` go ys
13:18:46 <mrd> //?
13:18:54 <swiert> phobes: ok. good luck :)
13:19:07 <mrd> should be doing \
13:19:35 <dmead> ?src or
13:19:35 <lambdabot> or    =  foldr (||) False
13:19:47 <dmead> ?and
13:19:47 <lambdabot> Maybe you meant: arr ask id kind undo wn
13:19:50 <dmead> ?src and
13:19:51 <lambdabot> and   =  foldr (&&) True
13:20:05 <Ingon> ?src mapM
13:20:05 <lambdabot> mapM f as = sequence (map f as)
13:22:21 <Ingon> hi, i have a question conserning classes and instances
13:23:06 <hircus> Ingon: just ask :)
13:23:15 <Ingon> :)
13:23:37 <scvr> @where wolf
13:23:37 <lambdabot> Aroooooo!
13:23:38 <Ingon> i'm trying to develop kind of image library
13:23:49 <Ingon> so i've started with types
13:23:55 <Ingon> class Image a where
13:24:10 <Ingon> class Image a where drawImage :: a -> IO ()
13:24:28 <Ingon> data ResterImage = ResterImage
13:24:37 <Ingon> instance Image ResterImage where { drawImage ResterImage = return (); }
13:24:45 <Ingon> and
13:24:45 <Ingon> data VectorImage = VectorImage
13:24:57 <Ingon> instance Image VectorImage where { drawImage VectorImage = return (); }
13:25:21 <scvr> Ingon: for large blocks of code it may be easier to use hpaste.org
13:25:26 <hircus> ok. a bit weird that Rester (you mean Raster?) and VectorImage don't take any arguments
13:25:52 <Ingon> yes, this is for now
13:26:11 <Ingon> the plan is that VectorImage will have a [Vector] items
13:26:36 <Ingon> And rester image maybe kind of [[Point]] or whatever
13:26:46 <whoopsbob> Hi, I'm taking sqrt of a number, then I want to turn that back into an Int. I try to use truncate, but my program gives me funky type errors if I try that. Is there a better way to go from float to int?
13:27:07 <ibid> @type truncate
13:27:08 <scvr> :t ceil
13:27:08 <lambdabot> Not in scope: `ceil'
13:27:08 <Ingon> and of cource i mean Raster :)
13:27:08 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:27:13 <scvr> :t ciel
13:27:13 <lambdabot> Not in scope: `ciel'
13:27:20 <scvr> oy vey
13:27:22 <ibid> :t floor
13:27:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:27:59 <ibid> whoopsbob: without having seen your program, i suspect your type errors are not because of truncate but come from somewhere else (even if the error message points to truncate)
13:28:10 <hircus> Ingon: so far so good.. then?
13:28:12 <Ingon> and then on top of these images are Layers which actually can generate images, which on other handl could manifest themself in files (or whatever)
13:28:12 <ibid> @type sqrt
13:28:13 <lambdabot> forall a. (Floating a) => a -> a
13:28:34 <ibid> > truncate (4.5::Float)
13:28:35 <lambdabot>  4
13:28:37 <Ingon> class Layer a where { draw :: Image t => a -> t }
13:28:40 <ibid> > truncate (4.5::Float) :: Int
13:28:40 <lambdabot>  4
13:29:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3898
13:29:48 <Ingon> yes that is the whole thing
13:30:11 <Ingon> the problem is how to say that the Layer is going to produce images
13:31:06 <hircus> um
13:31:29 <Ingon> initially there was only one Image, and then it was like : draw :: a -> Image
13:31:36 <hpaste>  bobwhoops pasted "type errors" at http://hpaste.org/3899
13:31:36 <whoopsbob> Hm, could someone check what my type error is? (I realize the code is bad, but I'll fix that later :)
13:32:21 <mauke> whoopsbob: write a type signature for f
13:33:00 <ibid> whoopsbob: suggest writing a type signature for f. it makes type errors more comprehensible
13:33:05 <hpaste>  (anonymous) annotated "type errors" with "(no title)" at http://hpaste.org/3899#a1
13:33:17 <whoopsbob> ok, that was my edir ^
13:33:20 <whoopsbob> *edit
13:33:41 <mauke> now it should complain about sqrt (a*a + b*b)
13:33:53 <mauke> no instance for Floating Int or something like that
13:34:29 <whoopsbob> yeah, it says it can't match the expected type a -> b to inferred type Int
13:34:30 <ibid> but the key problem is that you are asking it to have c be both a floating-point number (because you compare it to a and b) and an integer (because it's the return value of truncate)
13:34:36 <ibid> whoopsbob: ^
13:34:38 <Ingon> and thats it: Layers generating Images generating Bytes (or whatever)...
13:34:48 <ibid> whoopsbob: which is c supposed to be?
13:35:11 <whoopsbob> ibid: the sqrt rounded to an integer
13:35:16 <doserj> and you are missing a $
13:35:37 <ibid> whoopsbob: you need to convert the integer back to float to be able to add it with floats :)
13:35:50 <ibid> whoopsbob: there are no implicit conversions in haskell
13:35:54 <whoopsbob> ibid: but a and b aren't supposed to be floats
13:36:10 <mauke> then you can't pass them to sqrt
13:36:23 <whoopsbob> whoops
13:36:25 <ibid> whoopsbob: they are because you give them, unconverted, to sqrt
13:36:35 <mauke> actually, he doesn't
13:36:48 <mauke> well, he does, but the . messes things up
13:36:51 <ibid> well, type converted
13:36:59 <ibid> ah, yeah
13:37:49 <ibid> :type isqrt
13:37:59 <ibid> don't we have something like that somewhere?
13:40:53 <hircus> Ingon: not sure I can help. looks ok to me -- Layer's draw will generate something that is an image
13:41:04 <Ingon> yes
13:41:42 <Ingon> some images... no matter Raster or Vector
13:41:44 <whoopsbob> Ok, I got my program to work. I converted a*a + b*b to a float and replaced the . with a $. Thanks all
13:44:25 <byorgey> ibid: http://haskell.org/haskellwiki/Lambda_lifting
13:44:40 <Tobsan> u/win 22
13:44:42 <Tobsan> oops
13:46:27 <ibid> byorgey: i know what lambda lifting is. what are you trying to say?
13:46:41 <ibid> ah, isqrt
13:46:48 <ibid> i was hoping there was a library function :)
13:48:06 <byorgey> yeah, I don't think it's in a library =(
13:48:23 <Lewisham> newbie question: just looked at the http://haskell.org/haskellwiki/Lifting_pattern , is there a good reason to not use lifting aside from readability?
13:48:58 <Lewisham> it seems like A Good Thing to do Always
13:49:42 <ibid> Lewisham: it's a matter of style
13:49:49 <arke> Hi.
13:50:28 <Lewisham> ibid: Fair enough. Is using bindings more Haskelly?
13:50:31 <ibid> Lewisham: i tend to keep names as local as possible (and i lift them out sometimes temporarily for testing purposes)
13:50:50 <ibid> Lewisham: i refuse to pass judgment on what is and what is not haskelly :)
13:51:30 <ibid> Lewisham: certainly, as long as your modules aren't too large and have well-controlled export lists, lifting doesn't hurt very much
13:51:52 <ibid> Lewisham: but then again, if you don't export the function, you lose the testability argument since ghci won't see it
13:52:31 <ibid> Lewisham: but i certainly think that auxiliary stuff should not be exported except when necessity exists
13:53:03 <TSC> It see it if you load it directly, which is probably what you'd do if you were working on that particular module, which is when you're most likely to want to test it
13:53:31 <ibid> TSC: has this been changed recently? it didn't see them when i last tried to do it,
13:53:34 <ibid> some years ago
13:56:35 <TSC> I'm not sure if it's recent, but that's how it is now
13:56:47 <TSC> (unless the module has already been compiled)
13:59:47 --- mode: irc.freenode.net set +o ChanServ
14:00:08 <ibid> Lewisham: thinking about it some more, i think i'd lift out most stuff that isn't specific to the function, especially if it doesn't involve turning variables into functions
14:00:24 <ibid> argh
14:01:03 <ibid> Lewisham: thinking about it some more, i think i'd lift out most stuff that isn't specific to the function, especially if it doesn't involve turning variables into functions
14:04:04 <Lewisham> yeah
14:04:14 <Lewisham> well that's what I would do naturally
14:04:26 <Lewisham> I was just wondering whether it wasn't common
14:04:36 <Lewisham> seeing as it necessitated a whole wiki page!
14:16:18 <tuomov> You know, I really wish you could use Haskell code from other language without the runtime baggage..
14:16:55 <dons> runtimes are funny like that
14:17:30 <sjanssen> tuomov: how could you avoid at least needing the garbage collector?
14:17:38 <dons> there's nothing too unusual though, same problem if you want to call python or lua or .. :)
14:17:48 <dons> C is just lucky its runtime is provided in the std libs
14:17:51 <sebell> C
14:17:55 <tuomov> well, lua's runtime is lightweight and pure ansi-c
14:18:14 <tuomov> it won't go messing with timers and whatnot that many other runtimes might do
14:18:22 <tuomov> (dunno where haskell does its scheduling)
14:18:49 <pejo> sjanssen, region inference!
14:18:50 <dons> normally you just link libHSrts.a
14:20:10 <tuomov> how does the Haskell concurrency stuff work?
14:20:14 <tuomov> (wrt. this)
14:20:26 <ibid> C actually needs very little runtime support
14:20:32 <tuomov> I've been thinking it might be nice for some things, but I'd also like to write a rather generic library..
14:20:40 <ibid> (unless you mean the standard library, but that's different)
14:21:09 <sjanssen> ibid: Unix is C's runtime system
14:21:22 <ibid> sjanssen: incorrect
14:21:22 <tuomov> I wish it was haskell's as well, more
14:21:29 <sjanssen> or win32, etc.
14:21:34 <tuomov> i.e. proper posix support instead of forcing its own concurrency stuff instead of select etc.
14:21:34 <dikini> Saizan_: thanks for your feedback earlier
14:21:46 <sjanssen> tuomov: do you actually have some issue with GHC's RTS?
14:22:01 <tuomov> sjanssen: wrt. what?
14:22:03 <sjanssen> ibid: why not?
14:22:25 <ibid> sjanssen: because it isn't
14:22:30 <Saizan_> dikini: i'm glad if it has been useful :)
14:22:30 <tuomov> sjanssen: I'd like to know if there's any hope in writing a library in haskell that wouldn't mess with the calling application that wouldn't even know that the library is written in haskell
14:22:34 <sjanssen> tuomov: nevermind, you followed up with the "select" issues
14:23:01 <sjanssen> you can call select in Haskell
14:23:04 <tuomov> and secondly it would be nicer if haskell libs didn't so much proper the haskell way of doing things over posix
14:23:13 <tuomov> s/proper/prefer/
14:23:15 <ibid> sjanssen: obviously, you need to interface with the operating system (or the bare metal) to do anything useful, but beyond that (which is common to all languages) the c language requires very little runtime support
14:23:18 <dikini> Saizan_: :) now it's reading, head scratching, oops time
14:23:19 <sjanssen> nobody does it because select isn't composable
14:23:47 <tuomov> composable?
14:24:03 <ibid> sjanssen: evidence that C is used to write operating systems and other bare metal software (in the "freestanding" mode of the standard)
14:24:05 <tuomov> presently select() is embedded deep in the runtime, instead of letting you select() yourself, or let some library do it
14:24:34 <sjanssen> tuomov: you need to know about all the IO sources in your application to use select()
14:24:49 <tuomov> no, I just need to know those I care about
14:24:50 <dons> user-land schedulers are an open research topic though
14:24:51 <sjanssen> tuomov: it is not trivial to compose two correct programs that call select()
14:24:55 <Pseudonym> Sorry, late in this discussion, but yes, Unix _is_ C's runtime system.
14:25:15 <tuomov> sjanssen: I wish languages and libraries would leave that main loop up to me, instead of forcing one
14:25:25 <ibid> Pseudonym: as evidence by the fact that C runs only on Unix?
14:25:26 <tuomov> of course providing a variant, but not forcing it
14:25:28 <ibid> +d
14:25:43 <Pseudonym> ibid: Other OSes emulate that part of Unix.
14:25:46 <Pseudonym> Let me put it this way:
14:25:56 <b_jonas> we have a c standard and a posix standard and a unix standard
14:25:57 <Pseudonym> How much of <signal.h> is in the C standard library?
14:25:59 <b_jonas> they're stacked
14:26:08 <b_jonas> you can have any without having the next ones
14:26:11 <ibid> Pseudonym: you're talking about OS interfaces, not about language runtime support
14:26:25 <b_jonas> of course, as most c programs are written with unix in mind, most c envs try to emulate some unix functions
14:26:26 <Pseudonym> Unix implements some of the C standard library in the kernel.
14:26:45 <b_jonas> to the point of stupidity like the wierd unixy functions in borland c
14:26:51 <ibid> that speaks about Unix's relationship to C, not C's relationship to Unix
14:27:06 <Pseudonym> OK, let me rephrase:
14:27:07 <monochrom> signal.h is considered to be posix rather than C.
14:27:14 <Pseudonym> Well it's in the C standard.
14:27:19 <ibid> look at standard freestanding C and tell me that's Unix emulation
14:27:20 <b_jonas> isn't sigaction posix and signal c?
14:27:21 <monochrom> Oh, oops.
14:27:30 <b_jonas> also kill is posix but raise is c iirc
14:27:30 <tuomov> it sucks that languages (and some C libraries) try to provide whole Frameworks of everything, instead of just the language
14:27:43 <tuomov> leaving the rest of up to small libraries of the user's choosing
14:27:47 <Pseudonym> But I rephrase: Unix is a C virtual machine.
14:27:53 <Pseudonym> Other OSes have to emulate it somewhat.
14:27:54 <ibid> Pseudonym: that i can agree with
14:27:55 <tuomov> of course there's always GC, but..
14:28:01 <sieni> tuomov: well c sucks anyway
14:28:07 <pejo> b_jonas, C is "huge" in the embedded system market. To the best of my understanding they don't have anything resembling a traditional OS underneath their applications.
14:28:17 <sieni> tuomov: and nice to see you again :-)
14:28:23 <Pseudonym> sieni: If it wasn't for signal delivery, it wouldn't be so bad.  It'd be a very nice portable assembler, in fact.
14:28:29 <tuomov> C sucks, but C provides the best way to write a library accessible from various languages
14:28:34 <ibid> Pseudonym: what i was arguing against is the implicit claim that C's lack of need for runtime support is illusory
14:28:42 <Pseudonym> Right.
14:28:43 <tuomov> and I think many libraries should be so accessible
14:29:01 <therp> true, but most libraries aren't written in C because of the pain
14:29:06 <tuomov> I wish I could write such libraries in Haskell too, without the runtime baggage
14:29:16 <ibid> obviously, the shared history of C and Unix makes them highly ... compatible :)
14:29:18 <tuomov> therp: exactly why it would be nice to use Haskell
14:29:23 <Pseudonym> I hate to admit this, but COM isn't so bad as a language-independent library API.
14:29:24 <tuomov> but not write a Haskell-only library
14:29:38 <Pseudonym> The crap that is built on top of COM is... well, crap.
14:29:38 <therp> tuomov: foreign export "..."
14:29:46 <Pseudonym> e.g. ActiveX
14:29:49 <tuomov> therp: and then you have a runtime with its demands
14:29:53 <dikini> Sorry to jump in the middle most interesting languages implement an OS of their own, since they try to speak to the world their own way, Unix just happens to be most C's way, or vice-versa
14:29:57 <Pseudonym> But COM itself is kind of okay.
14:30:27 <tuomov> Pseudonym: probably some with .NET... the library hierarchies are even more awful than GHC's (being OO crap), but I think the basic architecture is rather sound
14:30:31 <tuomov> s/some/same/
14:30:42 <tuomov> from what little I've looked into it
14:30:58 <therp> tuomov: I don't see why the runtime is a problem.
14:31:02 <sieni> Pseudonym: we have noticed that sigwait() is the only portable way of receiving signals in a multi-c-threaded programs
14:31:06 <tuomov> dikini: and that is unfortunate. Languages should let me choose to OS.
14:31:13 <tuomov> s/to/the/
14:31:19 <ibid> even though i like many languages, the one I always come back to is ... C *grin*
14:31:36 <ibid> (and she wasn't my first, either:)
14:31:37 <tuomov> yep. C sucks, but it's C.
14:32:01 <ibid> C sucks in very specific ways. in other ways, it's comfortable
14:32:16 <sieni> ibid: I hate computers and I would rather flip pizzas, but the only industry that is willing to pay me enough is... *drumroll* software industry
14:32:41 <dikini> tuomov: they have different priorities, hence language RTS
14:32:42 <tuomov> I hate computers too, dunno if I'd rather flip pizzas though
14:33:00 <tuomov> dikini: but you could try to make that as lightweight and unimposing as possible
14:33:08 <tuomov> I'm sure you don't need select() loops and stuff there
14:33:24 <_ry> sieni: are you sure you'd rather flip pizzas? it's not much fun after the first 3 weeks
14:33:31 <sjanssen_> tuomov: the compiler needs to do select() for you if you want composable programs
14:33:40 <_ry> i'd rather be a mountain ranger
14:33:49 <sieni> _ry: well, at least i'd get to cook
14:33:51 <tuomov> what's a composable program?
14:34:02 <yrlnry_> Is there a way to tell whether a given Haskell type is inhabited by a non-bottom value?
14:34:08 <sjanssen_> tuomov: Concurrent Haskell does things differently because there are serious issues with the usual way of doing it
14:34:09 <tuomov> Why can't the language just provide an API for me to get all the fd's and callbacks?
14:34:18 <ibid> tuomov: take two composable programs and you can put them together to make a third program without making changes to either
14:34:28 <dikini> tuomov: you could try, problem is that you end up making compromises, since you adapt to an imposed model from outside
14:34:31 <sjanssen_> tuomov: composability is the property that you can plug two valid programs together to form another valid program
14:34:50 <tuomov> dikini: and here you have something imposed from inside..
14:35:00 <dikini> :)
14:35:16 <tuomov> I'm just asking, let me choose the interface between outside and inside
14:35:30 <tuomov> Let me choose the runtime.
14:35:39 <sieni> _ry: I would rather teach mathematics
14:35:39 <tuomov> so to say
14:36:05 <geocalc> tuomov=<< write your OS with your language !
14:36:20 <_ry> sieni: i was also a mathematics teacher, coincidentally. (i might go back)
14:36:22 <dikini> tuomov: or more likely let me build my own runtime?
14:36:23 <tuomov> geocalc: that's what all the language authors do these days :)
14:36:31 <dikini> from componets I fancy?
14:36:42 <tuomov> it doesn't suffice for them to provide just a language, they want to provide the OS and all the libraries too
14:36:44 * dikini learn to spell
14:36:59 <tuomov> ... Lua being the nice exception
14:37:31 <sieni> _ry: I'm not a qualified math teacher for high school, but I have a Ph.D. an could teach math at a college
14:37:43 <sjanssen_> tuomov: there are crossplatform issues too
14:37:54 <tuomov> and I should care about cross-platform?
14:37:55 <sjanssen_> I like that my Haskell code will usually run everywhere
14:38:02 <sieni> _ry: now I'm mostly concerned with posix thread suckage on multiple platforms
14:38:04 <tuomov> I think that should be left to the final application author
14:38:05 <_ry> sieni: me too (almost - i dropped out of my phd after a few years)
14:38:18 <dikini> lua is a sweet little language, but it is served by the C or whatever else it is tied to
14:38:32 <dikini> and their runtimes
14:38:45 <tuomov> not really even that, since it's ANSI-C
14:38:50 <_ry> sieni: algebraic topology?
14:38:55 <tuomov> so it doesn't depend on the "unix runtime" even
14:39:16 <sieni> _ry: no, analysis
14:39:28 <sieni> _ry: mathematical physics
14:39:32 <sieni> and studd
14:39:35 <sieni> stugg
14:39:36 <sieni> stuff
14:39:50 <tuomov> I might go for farming when I can no longer do research :)
14:39:54 <sieni> *bad keyboard* *bad* *bad* *bad*
14:40:05 <_ry> i want to be an artist-programmer.. ahem
14:40:13 <tuomov> that ringed a few bells: http://www.phdcomics.com/comics/archive.php?comicid=937 :)
14:40:13 <dmwit> sieni: Your fingers are too fat. ;-)
14:40:13 <lambdabot> Title: Piled Higher and Deeper
14:40:20 <_ry> like "why the lucky stiff"
14:40:36 <tuomov> couldn't work in IT shit
14:41:15 <sieni> dmwit: you haven't felt my fingers where you should have felt them
14:42:17 <dikini> tuomov: I was saying that for years, yet I still do, and can't see myself doing farming, and not enough looks and skills for a kept man :(
14:47:03 <tuomov> anyway, so I guess I must take it that there's no hope of writing general-purpose libraries in Haskell
14:47:06 <tuomov> shame
14:47:44 <dmwit> Wait, what's wrong with the FFI?
14:47:58 * dmwit apologizes if this was already covered
14:48:07 <sebell> tuomov: Languages have inherent runtime requirements, if you want to change the Haskell runtime requirements, you'd have to change the language.
14:48:13 <Excedrin> I once wrote a general-purpose library... it was awesome...
14:48:14 <tuomov> there's this thing called the runtime, which might fuck with things
14:48:19 * sebell wishes he could drink and eat and not get fat
14:48:35 <dmwit> tuomov: Oh, I see.  You want all the nice things of Haskell, without any of the price.
14:48:40 <sjanssen> tuomov: if you don't want to use the runtime features, don't.  There is a full featured posix binding
14:48:52 <ibid> dmwit: don't we all?
14:49:03 <dmwit> =)
14:49:04 <tuomov> I'd actually like the concurrency stuff ...
14:49:17 <sjanssen> tuomov: well, then dmwit's comment applies here
14:49:50 <tuomov> the runtime could be more friendly to integration in other mainloops/runtimes
14:51:59 <tuomov> a minimal haskell runtime really just needs to be provided a libevent-style api..
14:52:54 <hpaste>  _ry pasted "i'm trying to recreate the cat program. any suggestions?" at http://hpaste.org/3901
14:53:01 <tuomov> each time its thread goes to wait on a file, it sets a callback for the file descriptor and returns
14:53:44 <dmwit> _ry: unify catStdin and catFilename with catH.
14:53:53 <dmwit> catH :: FileHandle -> IO ()
14:53:57 <sjanssen> there is some work on userspace schedulers, this may apply
14:54:11 <_ry> dmwit: how do i get the stdin filehandle?
14:54:18 <dmwit> ?hoogle stdin
14:54:22 <lambdabot> IO.stdin :: Handle
14:54:27 <dmwit> ;-)
14:54:30 <_ry> ah, easy
14:55:00 <Ingon> ?src Ratio
14:55:00 <lambdabot> data (Integral a) => Ratio a = !a :% !a
14:55:03 <hpaste>  Hykasrsaa pasted "president rolex used" at http://hpaste.org/3902
14:55:23 <tuomov> I wouldn't even necessarily need scheduling; the concurrency stuff could be cooperative coroutines
14:55:24 <Ingon> >
14:55:25 <Ingon> ?
14:55:45 <dmwit> Hi Ingon!  What's up?
14:57:38 <tuomov> does the haskell runtime use timers for scheduling, or is based on breakpoints?
14:57:55 <tuomov> depends on implementation?
14:57:58 <tuomov> ghc?
14:58:21 <sjanssen> yes, it is implementation dependent
14:58:41 <sjanssen> the commentary on ghc's wiki may have details
14:58:47 <ddarius> Considering there is nothing in standard Haskell that supplies concurrency...
14:58:59 <sieni> tuomov: there is only one ghc, the shalt not be other implementations
14:59:14 <hpaste>  _ry annotated "i'm trying to recreate the cat program. any suggestions?" with "(no title)" at http://hpaste.org/3901#a1
14:59:30 <ddarius> @where yhc
14:59:30 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
14:59:34 <ddarius> @where nhc
14:59:34 <lambdabot> http://haskell.org/nhc98
14:59:37 <ddarius> @where jhc
14:59:37 <lambdabot> http://repetae.net/john/computer/jhc/
14:59:41 <ddarius> @where ehc
14:59:41 <lambdabot> I know nothing about ehc.
14:59:43 <ddarius> @where uhc
14:59:44 <lambdabot> I know nothing about uhc.
14:59:58 <ddarius> @where hbc
14:59:58 <lambdabot> I know nothing about hbc.
15:00:13 <ddarius> The where database is lacking
15:00:21 <dmwit> So fix it.
15:00:31 <dmwit> ?google haskell ehc
15:00:32 <Saizan_> @where tbc
15:00:33 <lambdabot> http://www.cs.uu.nl/wiki/Ehc/WebHome
15:00:33 <lambdabot> Title: Ehc / Web Home
15:00:33 <lambdabot> I know nothing about tbc.
15:00:44 <ddarius> dmwit: That would require effort and I'm eating currently.
15:00:50 <dmwit> heh
15:01:14 <dmwit> ?help run
15:01:14 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:01:21 <tuomov> nah, too much work to go through them
15:01:22 <_ry> is there a better way to do this "mapM_ (catH . (\x -> openFile x ReadMode)) args"
15:01:23 <dmwit> ?help .
15:01:23 <lambdabot> . <cmd1> <cmd2> [args].
15:01:23 <lambdabot> . [or compose] is the composition of two plugins
15:01:23 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
15:01:35 <ddarius> It says "no IO" like that's a good thing
15:01:38 <ddarius> @help @
15:01:38 <lambdabot>  @ [args].
15:01:38 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
15:01:38 <lambdabot>  The commands are right associative.
15:01:38 <lambdabot>  For example:    @ @pl @undo code
15:01:38 <lambdabot>  is the same as: @ (@pl (@undo code))
15:01:57 <dmwit> There we go.
15:02:15 <dmwit> @@ @where+ ehc @google haskell ehc
15:02:16 <lambdabot>  Okay.
15:02:22 <dmwit> Rinse, lather, repeat.
15:02:46 <dmwit> All we need to make it really easy is an @join. ;-)
15:03:18 <ddarius> Who's first to make lambdabot's command manipulation language Turing complete?
15:03:56 <dmwit> _ry: Also, have you seen
15:04:00 <dmwit> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/18
15:04:00 <dmwit> ?
15:04:01 <lambdabot> Title: Haskell hacking
15:05:37 <_ry> dmwit: no, thanks
15:07:50 <tuomov> bah
15:08:05 <tuomov> ghc seems to use a timer
15:08:25 <dons> tuomov: i think this is quite interesting. probably simon marlow would like to hear how you're using the rts
15:08:29 <tuomov> yhc doesn't, but it seems to be an interpreter
15:08:30 <monochrom> time slices very tasty!
15:08:39 <tuomov> dons: I'm not using at all ATM
15:08:52 <sjanssen> tuomov: yhc is probably not ready for heavy use
15:08:52 <tuomov> but I'd like to create a library usable from other languages too
15:08:57 <dons> but you suspect the internal timer/signal handling is going to disrupt another library?
15:09:07 <tuomov> of course
15:09:09 <dons> yeah, i wouldn't use yhc. ghc is the only option here, i think
15:09:11 <tuomov> there's only one unix timer signal
15:09:25 <tuomov> I suppose the other don't even create very efficient code?
15:09:31 <dons> right. so this is something to raise on glasgow-haskell-users@ since i don't think anyone has mentioned it before
15:09:53 <sjanssen> tuomov: GHC is the only compiler that's ready for serious use
15:09:57 <tuomov> and then there's the select issue too
15:09:58 <dons> right. and just in terms of being fairly ubiquitous, awith good ffi support
15:10:02 <sjanssen> Hugs is okay, but it's an interpreter
15:10:18 <tuomov> the way to go about this would be passing some libevent-style functions for the haskell runtime to register its stuff through
15:10:26 <tuomov> and let the application author choose the mainloop
15:10:40 <dons> right.
15:10:41 <tuomov> dunno how scheduling would be implemented, but for replacing internal select() that works
15:10:49 <dons> so that's the new user-land scheduler/event stuff
15:11:59 <newsham> language mandates the eventloop?  :(
15:12:01 <tuomov> of course, if the application author doesn't provide those functions, haskell code should still work, but fail with an exception in (the IO monad) code that would require those features
15:14:07 <ddvlad> hi, is it me or are docs at http://haskell.org/ghc/docs/latest/html/libraries/index.html all empty?
15:14:26 <hashendgame> it's just you
15:14:35 <hashendgame> or the www. prefix is making a difference
15:14:46 <ddvlad> Array, Bits, Char, Complex and the like
15:14:52 <sjanssen> ddvlad: not all of them are empty
15:14:59 <ddvlad> Control.Monad for example is ok
15:16:09 <hashendgame> does anyone know how to make a socket waiting on an accept timeout? If I understand the sockets api, I'd select(2) on the socket and only try to accept if I can read. I can't seem to find an equivalent in Network{,.Socket,.BSD}
15:16:43 <dons> hashendgame: so you should be using threads for this :)
15:16:52 <dons> and you can wait with timeout then
15:16:53 <tuomov> lolz
15:16:57 <dons> which will wake up the thread
15:17:13 <tuomov> but yeah, the concurrency stuff is quite nice, but not always the way to go
15:17:21 <dons> though there may be something deep down for this
15:17:29 <ddvlad> hmm... except for the first few links, all docs are in place. thanks for the kick in the rear -- i should have checked more than the first two links
15:17:45 <dons> but almost all uses of unix select() should be done in terms of haskell threads (which live on top of select)
15:18:10 <TomMD> What is the best way to UnitTest / QuickCheck largish STM functions?
15:18:17 <tuomov> and which messes with non-haskell code, both libs, and main app
15:18:27 <tuomov> this problem is in the curses lib too..
15:18:33 <TomMD> I'm currently reduced to writing custom test routines (using Arbitrary still)
15:18:54 <hashendgame> dons: so the way to write it would be to forkIO a thread that does all the accepting and just killThread it when it's shutdown o'clock?
15:18:56 <tuomov> or at least there was at some point some difficulties
15:19:21 <dikini> how to see the unseeable? that is how to do the runST trick of preventing state sharing without resorting to unsafeIO?
15:19:32 <sjanssen> hashendgame: killThread might not work if accept makes a blocking foreign call
15:20:09 <hashendgame> sjanssen: so how would I shutdown the thread that's waiting on the accept?
15:21:09 <tuomov> I guess I should post something one one of the lists one day..
15:21:38 <dons> its worthwhile if you're pushing on unusual parts of the toolchain, tuomov
15:21:49 <sieni> hashendgame: do you mean haskell or c? on c, you just make the file descriptor non-blocking and use select(), poll() (preferably poll()) or on advanced platforms epoll() or similar
15:22:24 <hashendgame> sieni: in haskell
15:22:48 <newsham> if you really wanted sockets and an event loop, you could use FFI
15:23:02 <sieni> hashendgame: then you probably fork a thread and wait :-)
15:23:31 <sieni> newsham: nobody wants an event loop, ever!
15:23:46 <hashendgame> I'm really looking to use Network or Network.Socket. Being able to shutdown the thread that's waiting in accept is what's bothering me
15:23:54 <newsham> sieni: sounds like tuomov does and maybe hashendgame
15:23:54 <tuomov> sieni: and yet every interactive program has one :)
15:24:06 <tuomov> including haskell programs
15:24:17 <tuomov> but now haskell runtimes don't want you to integrate it with other event loops
15:24:36 <newsham> hashed: is it not possible to kill a thread that's blocked on an accept?
15:24:42 <sieni> tuomov: the difference between me and you is that i get paid for this shit
15:24:49 <newsham> because that seems like it should be reported as a bug if its the case.
15:25:03 <sieni> I would rather teach mathematics
15:25:35 <newsham> tuomov: not every interactive program has an event loop.  some systems have the event loop in the kernel.
15:25:51 <tuomov> I'd also rather leave the coding grunt-work to others, just telling them what to do...
15:25:53 <dons> most interactive apps i use in haskell use a thead for the event loop
15:26:06 <dons> sending values over a Chan to the main thread for processing
15:26:22 <tuomov> dons: and the runtime has an event loop
15:26:41 <sieni> tuomov: I just have this thing called life for which I need to have some income
15:27:13 <newsham> tuomov: impl dependant.
15:27:20 <newsham> there's no reason it has to have an event loop
15:27:25 <newsham> thats up to the runtime
15:27:30 <SamB_XP> newsham: how is it going to do all that stuff without one?
15:27:43 <newsham> real threads
15:28:02 <tuomov> and you still have a select() in each thread when it goes into waiting..
15:28:04 <tuomov> i.e. an event loop
15:28:11 <newsham> tuomov: no you dont.
15:28:11 <SamB_XP> yes, but that's just pushing the work into the kernel's scheduling loop...
15:28:13 <_ry> how could i get the lines from a file into an array? (god i suck at haskell)
15:28:15 <tuomov> or a mutex or whatnot
15:28:23 <newsham> real threads can call the accept system call directly and block in-kernel
15:28:43 <newsham> a user-land event loop is just an implementation of threads.
15:28:57 <hashendgame> it appears that you can killThread a thread that's waiting on an accept if my test code is right
15:29:02 <ddarius> _ry: Why do you want lines from a file in an array?
15:29:06 <newsham> (err.. not a general statement, i mean in reguards to haskell threads)
15:29:09 <SamB_XP> it's more efficient than having to switch to context switch all the time...
15:29:14 <_ry> ddarius: i want to sort them
15:29:20 <hpaste>  endgame pasted "kill a thread in accept" at http://hpaste.org/3904
15:29:31 <tuomov> SamB_XP: do thread switches switch context?
15:29:35 <newsham> samxp: *nod*  a mix of kernel and userland thread switching is usually the way to go.
15:29:50 <SamB_XP> tuomov: don't they have to enter the kernel?
15:29:58 <ddarius> _ry: Why do you want lines from a file in an array?
15:29:59 <tuomov> does that switch context?
15:30:10 <tuomov> I thought context switch was about changing the page tables
15:30:15 <SamB_XP> doesn't it?
15:30:34 <SamB_XP> let me pull out my Architecture Optimization Reference Manual...
15:30:37 <tuomov> page tables don't change when you go into kernel or switch thread within same memory space
15:30:44 <_ry> ddarius: i want to sort them
15:31:00 <tuomov> (which is why you could have efficient microkernels in 64bit address space!)
15:31:15 <tuomov> (you can have the services in every program's address space)
15:31:21 <tuomov> (protected by segments)
15:31:34 <LoganCapaldo> changing threads requires you to save & restore the registers and the PC and the stack pointer, even if you don't have to change page tables. I was under the impression that was a context switch
15:31:44 <ddarius> _ry: Apparently I'll have to be more explicit.  Why do you think they need to be in an array to be sorted.
15:31:53 <SamB_XP> LoganCapaldo: there's more to it than that
15:32:07 <LoganCapaldo> More to a context switch?
15:32:11 <tuomov> LoganCapaldo: and that's less efficient than doing the same in a higher-level way in application-side threads?
15:32:13 <SamB_XP> tuomov: um, segments?
15:32:14 <dmwit> _ry: Really an array, or will a list do?
15:32:18 <SamB_XP> tuomov: how would that be fast?
15:32:24 <_ry> oh sorry, a list.
15:32:32 <LoganCapaldo> I'm sorry I jumped in here late
15:32:35 <newsham> tuomov: page table switch is part of a process switch.  within a process you can have several threads which also context switch between each other.
15:32:46 <newsham> that can be implemented in-kernel or in userland, or (more commonly) both.
15:32:46 <SamB_XP> tuomov: 64-bit mode, afaik, doesn't even support segmentation very well
15:32:50 <dmwit> _ry: How about liftM words . hGetContents?
15:32:57 <SamB_XP> nevermind that segments are slow
15:33:03 <tuomov> I think the inefficiency of context switch typically refers to the page-table switching case
15:33:11 <LoganCapaldo> I'm not exactly sure if you guys are even talking about kernel or user space threads
15:33:25 <newsham> if thread contexts are implemented by the kernel then you can have multiple threads each blocking on their own system calls.
15:33:33 <dmwit> _ry: Sorry, I meant liftM lines . hGetContents, but I guess you knew what i meant.
15:33:43 <newsham> if its all userland, then you have to mediate access to the system kernel in a way that doesnt cause other threads to block (ie. select)
15:34:10 <newsham> tumovo: switching thread contexts in userland is much cheaper than in kernel..  the kernel-user boundary is expensive to cross.
15:34:18 <pejo> LoganCapaldo, people are talking about both I think, hence the confusion.
15:34:20 <tuomov> SamB_XP: you know, the kernel is protected from userspace with segments (Linux/x86: application segment=0-3G, kernel segment=3-4G)
15:34:25 <newsham> in userland you're just swapping out some register with another saved copy
15:34:41 <SamB_XP> tuomov: oh
15:35:05 <SamB_XP> well, as long as your segments all have their base at 0 and their limit at ... well, the other end of the address space...
15:35:08 <newsham> tumov: thats an implementation-specific detail.
15:35:17 <newsham> most cpus dont even support memory segmentation.
15:35:25 <_ry> dmwit: thanks that's good. i didn't know about this lines function
15:35:37 <SamB_XP> newsham: we are talking about personal computers
15:35:53 <SamB_XP> newsham: not cellphones, PDAs, or servers
15:36:01 <newsham> i've owned several personal computers that didnt have memory segmentation :)
15:36:04 <SamB_XP> yes
15:36:14 <SamB_XP> but they are becoming less and less common, I think?
15:36:16 <tuomov> (it might've actually been that on Linux/x86 the kernel segment overlapped and was 0-4G, with kernel data actually located above 3G)
15:36:40 <newsham> samb: its true.  but there are many relevant machines that are not ia32 are em64t still
15:36:49 <SamB_XP> tuomov: if you have segments that don't include the whole 4G, that slows down the CPU
15:37:03 <SamB_XP> newsham: hmm?
15:37:06 <tuomov> how?
15:37:24 <SamB_XP> tuomov: because modern OSes don't generally DO that
15:37:27 <tuomov> the linux/x86 userspace segment certainly only includes 0-3G (typically)
15:37:28 <SamB_XP> it's a vicious circle
15:37:45 <tuomov> segments are the only way to protect stuff within the same page tables
15:37:55 <SamB_XP> tuomov: perhaps you are confused with rings
15:37:58 <tuomov> and you want the kernel in there with the application
15:38:10 <SamB_XP> well, the segments may have rings associated...
15:38:32 <tuomov> segments have privilege-level bits
15:38:33 <newsham> dont ia32 page tables have a supervisor bit in them?
15:38:39 <tuomov> so-called rings
15:38:41 <tuomov> newsham: iirc, no
15:38:53 <tuomov> there are 0-3 privilege levels of segments, however
15:38:55 <SamB_XP> tuomov: yes, that's the mechanism that Linux uses afaik
15:38:55 <ddarius> Yes they do.
15:39:03 <SamB_XP> newsham: two supervisor bits!
15:40:07 <tuomov> http://en.wikipedia.org/wiki/Global_Descriptor_Table
15:40:24 <newsham> #define PT_U    0x004           /* user accessible */
15:40:25 <LoganCapaldo> mm
15:40:40 <LoganCapaldo> that's like 4 exciting different levels of visorness
15:40:48 <lambdabot> Title: Global Descriptor Table - Wikipedia, the free encyclopedia
15:40:52 <SamB_XP> LoganCapaldo: yes!
15:40:53 <newsham> tuo: i'm talking about page tables not the GDT
15:41:16 * SamB_XP gives up on the optimization manual, it doesn't seem to talk about Volume 3 stuff
15:41:36 <tuomov> it's been literally ages since I studied that stuff (mid-90s) but IIRC then there wasn't any privilege stuff in pagetables
15:41:54 <_ry> ?index FileHandle
15:41:54 <lambdabot> bzzt
15:46:00 <newsham> this is really more #osdev stuff than #haskell stuff
15:46:00 <SamB_XP> newsham: ... so?
15:46:00 <LoganCapaldo> _ry: System.IO I think
15:46:00 <tuomov> I can't find a PT_U in my linux headers..
15:46:00 <SamB_XP> what's the difference between implementing Haskell and implementing an OS?
15:46:00 <newsham> tuomov: I didnt get it from the linux headers.
15:46:00 <LoganCapaldo> scope?
15:46:00 <newsham> there are other systems out there :)
15:46:00 <SamB_XP> tuomov: don't you have manuals or something?
15:46:00 <newsham> sam: are you implementing haskell on bare metal?
15:46:00 <LoganCapaldo> Mmm lazy processor
15:46:00 <tuomov> SamB_XP: probably buried under some deep pile of other shit
15:46:00 <SamB_XP> newsham: no... I'm not even implementing Haskell. we were discussing implementations of threading in haskell systems...
15:46:00 <newsham> i think we left that discussion about 3 pages ago :)
15:46:00 <SamB_XP> possibly
15:46:00 <newsham> not sure what IA32 page tables and segmentation has to do with threading in haskell
15:46:00 <SamB_XP> something to do with what happens when you try to go without having an event loop?
15:46:00 <_ry>  this is so weird. it was working a second ago: hcat.hs:6:8: Not in scope: type constructor or class `FileHandle'
15:46:00 <_ry> what did i do wrong? :)
15:46:15 <newsham> i think tuomov's original discussion was that he didnt want to directly use haskell threads and he wanted to be able to plug into ghc's event loop that it used to implement threading
15:46:34 <LoganCapaldo> _ry: You're not trying to use FileHandle witha parameter are you?
15:46:42 <LoganCapaldo> FilaHandle a or something
15:47:00 <LoganCapaldo> Did you forget an -> ?
15:47:02 <tuomov> newsham: nah
15:47:07 <tuomov> something a bit different
15:47:21 <_ry> LoganCapaldo: no i'm doing this http://hpaste.org/annotate/3901
15:48:28 <_ry> (oops here is the correct link: http://hpaste.org/3901#a1)
15:48:54 <LoganCapaldo> @hoogle FileHandle
15:48:55 <lambdabot> No matches found
15:49:02 <LoganCapaldo> lol
15:49:05 <LoganCapaldo> darn you hoogle
15:49:13 <LoganCapaldo> I still think it's in System.IO
15:49:39 <monochrom> Handle is in System.IO
15:49:54 <monochrom> I have not heard of FileHandle.
15:49:57 <LoganCapaldo> doh
15:50:00 <LoganCapaldo> lol
15:50:05 <LoganCapaldo> @index Handle
15:50:05 <lambdabot> System.IO
15:50:47 <LoganCapaldo> @type hGetContents
15:50:49 <lambdabot> Not in scope: `hGetContents'
15:50:53 <LoganCapaldo> @type openFile
15:50:54 <lambdabot> Not in scope: `openFile'
15:50:59 <LoganCapaldo> @hoogle openFIle
15:51:00 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
15:51:07 <LoganCapaldo> thee ya go
15:51:08 <_ry> FileHandle is a constructor for Handle
15:51:30 <LoganCapaldo> Well if it's a constructor it's not a type
15:51:46 <LoganCapaldo> just like you don't do foo :: Just -> Int
15:52:42 <_ry> okay. (but i swear it was working just as it is a moment ago!)
15:52:57 * _ry is going crazy
15:53:11 <LoganCapaldo> Are you sure ou had the type annotations before?
15:53:57 <_ry> pretty sure. (but something must have changed...)
15:54:06 <sorear> phase of the moon?
15:54:35 <tuomov> well, it appears that yes there is a "user" bit in pages and code running in PL3 segment can only access that
15:54:44 <tuomov> so maybe that's how the protection is done these days
15:54:55 <tuomov> I seem to recall that there used to be a 3G segment though (in the mid-90s)
15:55:06 <SamB_XP> tuomov: possible
15:55:20 <SamB_XP> tuomov: it probably worked fine on 386s
15:55:35 <SamB_XP> where by fine I mean fast
15:55:51 <SamB_XP> ... for a 386
15:55:58 <sorear> tuomov: there used to be a 3G segment on Linux, yes
15:56:06 <newsham> tuo: linux does split at 3G
15:56:11 <sorear> tuomov: the user bit is ignored in supervisor mode
15:56:13 <newsham> at least on ia32
15:56:24 <SamB_XP> newsham: it doesn't use segmentation per se, though
15:56:27 <sorear> tuomov: old linux had a cheap hack for implementing the EFAULT return from read() et al
15:56:29 <tuomov> sorear: rather, all other code segment privilege levels than 3
15:56:44 <tuomov> kernel being at level 0, and 1 and 2 unused
15:57:00 <sorear> tuomov: it had a special data segment stretching from 0 - 3G, marked as FS
15:57:14 <sorear> tuomov: then read() et al used the FS: instruction prefix
15:57:39 <sorear> tuomov: so any attempt to trick read() into writing on kernel address space would cause a segfault
15:58:00 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3905
15:58:02 <SamB_XP> sorear: where do you learn all of this trivia?
15:58:03 <newsham> you mean copyin/copyout stuff?
15:58:03 <sorear> tuomov: I think they got rid of this when they started trying to make the kernel portable
15:58:17 <wli> set_fs() et al are still around from that. memcpy_from_fs_to_gs() has thankfully been renamed.
15:58:38 <tuomov> anyway, I think in 64-bit architectures you could make 4G segments efficient..
15:58:59 <tuomov> which would leave a lot of room for microkernel services in all programs' address spaces
15:58:59 <newsham> you dont need to use segmentation.
15:59:12 <Corun> Hiya. I'm writing pong to practice my monads and IO. So, I've got: http://hpaste.org/3905 But I'm not really sure how to continue. I was planning on having loop change the state and display would just draw it but I don't see how I can store the state.
15:59:14 <SamB_XP> tuomov: I was under the impression that segmentation was reduced in 64-bit mode...
15:59:23 <tuomov> I don't actually know about that
15:59:55 <tuomov> I've just thought that 64-bit architectures properly done could be used to improve microkernel performance that way
15:59:56 <wli> Most 64-bit architectures don't have segments in any manner similar to x86. MIPS' segments, for instance, are essentially nothing more than dedicated regions of the address space.
16:00:33 <tuomov> not having to flush the page tables all the time
16:00:54 <sorear> tuomov: yes, they could, I've thought about this quite a bit; such promise, but AMD disables the segment translation in 64-bit mode :(
16:00:58 <wli> IBM POWER's segments are just 256MB-sized, 256MB-aligned regions of the address space used to divvy up the TLB via the SLB.
16:01:33 <SamB_XP> sorear: besides the aforementioned performance degradation...
16:01:56 <sorear> tuomov: you might be interested in MIPS etc's tagged TLBs.  basically these systems indexed the TLB using a pair of the virtual address and the page table, so switching page tables didn't force a flush
16:02:12 <LoganCapaldo> Corun: the simplest way would be to use an IORef.
16:02:15 <SamB_XP> yes, that works very nicely
16:03:03 <Corun> Ooh. What's one of those? :-)
16:03:04 * Corun googles
16:03:39 <newsham> IORef is a pointer to mutable storage you can use in IO
16:03:48 <sorear> @docs Data.IORef
16:03:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
16:03:52 <sorear> Corun: ^^^
16:03:54 <newsham> you can use it to write imperative code
16:03:57 <Corun> Ah, cunning, _and_ obvious. Ta :-)
16:04:04 <Corun> I figured there must be something I didn't know about
16:04:23 <tuomov> sorear: yeah, and basically you could do 4G segments in 64-bit address space by forcing 32-bit code and loading the high bits in a register
16:04:34 <wli> MIPS' TLB's aren't very standardized. IBM POWER is really hairy. Alpha's low-level specs are unobtainable (the firmware interface is basically all you can find out about). Probably easiest is UltraSPARC or IA64.
16:04:50 <tuomov> or simply always setting the high bits to a loaded value
16:04:51 <hpaste>  LoganCapaldo annotated "(no title)" with "+ state" at http://hpaste.org/3905#a1
16:05:18 <dibblego> is there a intersperseM :: a -> m a -> m a ?
16:05:27 <newsham> awesome, lets force all userland programs to run in32-bit mode
16:05:44 <tuomov> not all programs, but microkernel services. 4GB should suffice.
16:05:49 <sorear> dibblego: what would it do?
16:05:58 <SamB_XP> tuomov: how would that work?
16:06:15 <dibblego> sorear, dunno haven't thought that far ahead :)
16:06:21 <tuomov> SamB_XP: eh?
16:07:00 <LoganCapaldo> dibblego: (MonadPlus m) => ... right?
16:07:05 <SamB_XP> where would you be sticking these high bits?
16:07:14 <tuomov> you could run the main application in the first 63-bit addressable half (always resetting the high bit for that code), and then services in the second half in 4G segments
16:07:34 <tuomov> always setting the high 32-bits to a given value for that code
16:08:26 <tuomov> it could probably be done quite efficiently
16:08:38 <newsham> not sure what you're trying to achieve, but it sounds like you're trying to solve a simple problem in a complex way.
16:08:43 <dibblego> LoganCapaldo, that's my first guess, without thinking, yep
16:08:54 <newsham> just dont allow user programs access to your kernels pages
16:08:59 <tuomov> newsham: not having to flush page tables in switch to microkernel services
16:09:06 <newsham> you dont have to
16:09:07 <LoganCapaldo> Hmm
16:09:11 <newsham> thats what the user bit is for
16:09:24 <LoganCapaldo> I still can't figure out a useful defn...
16:09:26 <wli> Not just the user bit.
16:09:29 <tuomov> ah, but then the services aren't unprivileged programs like verything else
16:09:29 <wli> The global bit also.
16:09:38 <tuomov> the services are supposed to be _unaware of this_
16:09:48 <wli> ASN's are pretty much all you want/need.
16:10:13 <LoganCapaldo> > do { x <- [1,2,3] ; return [x, 0] }
16:10:19 <lambdabot>  [[1,0],[2,0],[3,0]]
16:10:24 <_ry> @source hGetContents
16:10:25 <lambdabot> hGetContents not available
16:10:33 <LoganCapaldo> eeee
16:10:50 <tuomov> you could run the same code as a normal application that requires a page table switch to execute
16:10:52 <LoganCapaldo> > msum (do { x <- [1,2,3] ; return [x, 0] })
16:10:53 <lambdabot>  [1,0,2,0,3,0]
16:11:09 <tuomov> but you can also load it that way for faster access
16:11:46 <tuomov> but anyway, I'm off to sleep
16:12:05 <LoganCapaldo> @type (\i v -> msum (do { x <- v ; return (x `mplus` i) }))
16:12:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> [m a] -> m a
16:12:24 <LoganCapaldo> um
16:12:44 <LoganCapaldo> how'd [] get in there? :(
16:13:03 <LoganCapaldo> @type (\i v -> msum (do { x <- v ; (return x `mplus` i) }))
16:13:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> [m a] -> m a
16:13:17 <LoganCapaldo> @type (\i v -> msum (do { x <- v ; return (return x `mplus` i) }))
16:13:18 <lambdabot> forall t (m :: * -> *). (MonadPlus m) => m t -> [t] -> m t
16:13:26 <LoganCapaldo> now I'm just making up nonsense
16:13:29 <SamB_XP> @type msum
16:13:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
16:13:36 <LoganCapaldo> doh
16:13:49 <LoganCapaldo> of course
16:14:00 <LoganCapaldo> hmm
16:14:30 <LoganCapaldo> @type \x -> msum . (intersperse x)
16:14:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> [m a] -> m a
16:14:55 <LoganCapaldo> Is that worthy of the name "intersperseM"?
16:15:41 <LoganCapaldo> it does kind of work
16:16:50 <LoganCapaldo> > let intersperseM i = msum . (intersperse i) in instersperseM "," ["a", "b"]
16:16:51 <lambdabot>   Not in scope: `instersperseM'
16:16:57 <LoganCapaldo> > let intersperseM i = msum . (intersperse i) in intersperseM "," ["a", "b"]
16:16:57 <lambdabot>  "a,b"
16:17:29 <LoganCapaldo> > let intersperseM i = msum . (intersperse i) in intersperseM Nothing [Nothing, Just 1, Nothing]
16:17:33 <lambdabot>  Just 1
16:17:39 <LoganCapaldo> > let intersperseM i = msum . (intersperse i) in intersperseM Nothing [Nothing, Just 1, Nothing, Just 2]
16:17:40 <lambdabot>  Just 1
16:19:59 <LoganCapaldo> It doesn't strike me as been very useful
16:20:47 <LoganCapaldo> and that's not really intersperse M
16:20:58 <LoganCapaldo> it's intercalateM I suppose
16:21:36 <EvilTerran> well, more mintercalate ;)
16:25:54 <wli> intersperse is likely to be more recognized.
16:38:05 <SamB_XP> what type has that?
16:38:49 <IW32> is there a way to generate pseudo random numbers in haskell with a output type of Int in haskell?
16:39:11 <EvilTerran> you can get a list of pseudorandoms :: [Int]
16:39:16 <mauke> [3, 3, 3, 3, 3, 3, 3, 3, 3]
16:39:18 <EvilTerran> and consume 'em at your lesiure
16:39:19 <IW32> i have created one, but it as a output type of IO Int
16:40:00 <IW32> i don't want a list, i want one sigle integer number
16:40:08 <mauke> 3
16:41:06 <TSC> IW32: You can use the IO Int value as a plain Int, if you stay within the IO monad
16:41:43 <EvilTerran> IW32, an expression in haskell must always have the same value
16:41:45 <SamB_XP> bind will keep you in the IO monad ;-P
16:41:47 <EvilTerran> so, in short, no
16:41:58 <EvilTerran> but there's plenty of ways to achieve the same effect
16:42:54 <IW32> how can I change a IO Int to a Int?
16:43:33 <EvilTerran> > randomR (0,100) (mkStdGen 3)
16:43:33 <lambdabot>  (30,160056 40692)
16:43:45 <EvilTerran> you don't
16:44:50 <EvilTerran> if you're working in IO, you can achieve something with the same effect with "do x <- randomIO; <IO expression involving x>"
16:44:55 <_ry> i need a function like openFile except returns Handle instead of IO Handle. is that possible?
16:45:08 <mauke> _ry: no, you don't
16:45:11 <EvilTerran> ah, the "I want out of the IO monad"s are out in force tonight
16:45:15 <SamB_XP> _ry: you certainly don't need that
16:45:19 <mauke> what are you going to do with a Handle that doesn't involve IO?
16:45:25 <TSC> Submit to IO!
16:45:27 <Olathe> How do I get into an IO monad ?
16:45:32 <SamB_XP> _ry: you wouldn't be able to use said handle for anything anyway, like mauke says...
16:45:32 <ski> ".. and in the IO monad bind them, .."
16:45:39 <TSC> Olathe: return?  (:
16:45:41 <mauke> Olathe: return
16:45:46 <EvilTerran> http://www.haskell.org/all_about_monads/html/laws.html#nowayout
16:45:47 <lambdabot> Title: The monad laws
16:45:48 <Olathe> > return Olathe
16:45:49 <SamB_XP> ski: oh sweet
16:45:49 <lambdabot>   Not in scope: data constructor `Olathe'
16:45:50 <_ry> i want to pass it to hGetContents
16:45:50 <Olathe> :(
16:45:58 <SamB_XP> I was wondering how to bring LotR into this
16:46:07 <LoganCapaldo> @type (>>= hGetContents)
16:46:08 <lambdabot> Not in scope: `hGetContents'
16:46:10 <mauke> _ry: do { h <- openFile ...; hGetContents h }
16:46:22 <LoganCapaldo> @type (>>= System.IO.hGetContents)
16:46:25 <lambdabot> IO GHC.IOBase.Handle -> IO String
16:46:32 <mauke> "<-" magically gets out of the IO monad
16:46:33 <mauke> locally
16:46:40 <Olathe> Apparently I, as an apparent data constructor, am not in scope.
16:46:43 <mauke> however, the whole do {} block is still in IO
16:46:50 <EvilTerran> "you can't escape from the IO monad, it is impossible to write a function that does a computation in the IO monad but whose result type does not include the IO type constructor. This means that any function whose result type does not contain the IO type constructor is guaranteed not to use the IO monad." <-- important
16:47:07 <EvilTerran> "The wonderful feature of a one-way monad is that it can support side-effects in its monadic operations but prevent them from destroying the functional properties of the non-monadic portions of the program." also
16:47:20 <LoganCapaldo> @type (>>= System.IO.hGetContents) ?h
16:47:20 <lambdabot> (?h::IO GHC.IOBase.Handle) => IO String
16:47:30 <_ry> so i'll tell you the truth. I have a function that takes a handle and prints it's contents. I want to be able to either pass a file handle to it or stdin.
16:47:38 <Olathe> Won't (const 2) get rid of the IO ?
16:47:42 <LoganCapaldo> @type stdin
16:47:43 <lambdabot> Not in scope: `stdin'
16:47:43 <SamB_XP> of course, EvilTerran is quoting a pack of lies
16:47:47 <Olathe> > (const 2) []
16:47:50 <lambdabot>  2
16:47:51 <ski> @index stdin
16:47:52 <lambdabot> System.IO
16:47:55 <_ry> @type Prelude.stdin
16:47:55 <lambdabot> Not in scope: `Prelude.stdin'
16:48:00 <ski> @type System.IO.stdin
16:48:00 <Olathe> > (const 2) (putStrLn "Hello")
16:48:01 <lambdabot> GHC.IOBase.Handle
16:48:01 <lambdabot>  2
16:48:01 <mauke> _ry: stdin is a handle
16:48:12 <EvilTerran> Olathe, yes, but that wouldn't perform the IO computation
16:48:22 <_ry> the problem is openFile returns IO Handle
16:48:24 <Olathe> It wouldn't :(
16:48:26 <Olathe> ?
16:48:28 <IW32> i want the random number to have a range from 0 to 1295 then the number recieved is used to select a value from a file e.g. file !! (random number)
16:48:31 <_ry> so how can i handle files and stdin the same way?
16:48:42 <ski> Olathe : nope
16:48:45 <EvilTerran> SamB_XP, are you referring to the unsafe operations, or oversimplification?
16:48:55 <Olathe> So, main has to return IO something in order to output something ?
16:48:59 <SamB_XP> EvilTerran: unsafePerformIO, of course
16:49:01 <EvilTerran> > const 2 (error "this never gets evaluated, let alone run")
16:49:01 <lambdabot>  2
16:49:28 <EvilTerran> SamB_XP, ah, good. i thought you meant i'd inadvertantly been oversimplifying to the point of falsehood
16:49:31 <SamB_XP> you can write a computation that uses IO but doesn't run in IO, but you ... shouldn't
16:49:32 <ski> Olathe : `main' specified to return an `IO' action, yes
16:49:42 <Saizan_> _ry: if ... then func stdin else do h <- openFile ..; func h
16:49:56 <TSC> _ry: You can extract the Handle from the IO Handle, inside the IO monad
16:49:56 <dibblego> @let inadvertantly = "inadvertently" -- :)
16:49:58 <lambdabot> Defined.
16:50:00 <SamB_XP> EvilTerran: insofar as neglecting to mention unsafePerformIO constitutes oversimplification...
16:50:07 <EvilTerran> is it even H98?
16:50:09 <Olathe> So, I could build 25 different IOs and return the one to actually do ?
16:50:09 <mauke> _ry: do { h <- if useStdin then return stdin else openFile ...; hGetContents h }
16:50:13 <SamB_XP> EvilTerran: no
16:50:22 <SamB_XP> But that's because H98 is ancient
16:50:24 <mauke> Olathe: sure
16:50:24 <ski> Olathe : sure
16:50:27 <Olathe> Ahh :)
16:50:29 <ski> (:
16:50:34 <IW32> i want the random number to have a range from 0 to 1295 then the number recieved is used to select a value from a file e.g. file !! (randomN)
16:50:38 <SamB_XP> and it is a standard extension
16:50:38 <EvilTerran> Olathe, think of the very value of (putStrLn "hello") as an instruction to the runtime to print the string
16:50:39 <LoganCapaldo> or h <- (if ... then return stdin else opendFile ...) ; func h
16:50:50 <IW32> it is for a mastermind game i am working on
16:50:51 <SamB_XP> one of two officially recognized addendums
16:50:59 <EvilTerran> oh, okay then.
16:51:11 <EvilTerran> still, best avoided when introducing the IO monad to newbies
16:51:18 <mauke> GET OUT OF MY HEAD
16:51:18 <mauke> oh, am I lagged to hell?
16:51:21 <SamB_XP> http://haskell.org/haskellwiki/Language_and_library_specification
16:51:29 <SamB_XP> EvilTerran: yes
16:51:29 <newsham> i have a question about something in "haskell road to logic/math/prog".  they talk about powerseries and show that the power series of 1/(1-z) = 1+z+z^2+z^3+...
16:51:31 <EvilTerran> Olathe, similarly, the value (readLine) is an instruction to the runtime to read a string from stdin
16:51:37 <IW32> i saved all the possible combination to a file, at play it retrieve a random index from the file
16:51:51 <EvilTerran> rather than actually being the string itself
16:51:52 <IW32> but i don't know how to do it
16:51:57 <newsham> but obviously 1/(1-4) /= 1+4+4^2+4^3+....
16:52:06 <newsham> what are the conditions that cause it to not work for z=4?
16:52:12 <Saizan_> IW32: have you read anything about the IO monad?
16:52:20 <IW32> no
16:52:21 * wli mutters something about p-adic numbers.
16:52:32 <Olathe> > putStrLn readLine
16:52:33 <lambdabot>   Not in scope: `readLine'
16:52:36 <ski> Olathe : there's a difference between just evaluating a value (e.g. an action), and executing/running a monadic action
16:52:45 <TSC> IW32: if you have a function that returns IO Int (your random index), you'd use something like "do { n <- getRandomNumber ; doSomething (combos !! n) }"
16:52:56 <ski> Olathe : also, lambdabot doesn't allow `IO'
16:52:57 <mauke> newsham: I'm pretty sure z must be < 1
16:52:58 <EvilTerran> Olathe, and, in order to actually get that string, you have to pass the instruction to the runtime
16:52:59 <SamB_XP> newsham: prove that statement
16:53:04 <Olathe> ski: I know :)
16:53:11 <newsham> samb: which one?
16:53:13 <IW32> ok thanks
16:53:25 <SamB_XP> 1/(1-4) /= 1+4+4^2+4^3+...
16:53:30 <EvilTerran> which you do by making it part of the grand IO computation that is main
16:53:47 <hpaste>  _ry pasted "is there a way to make this a one-liner?" at http://hpaste.org/3906
16:54:28 <newsham> Sn = sum (map (4^) [0..n]) is a monotonically increasing sequence with no upper bound
16:54:29 <mauke> _ry: catFilename x = readFile x >>= putStr
16:54:32 <EvilTerran> newsham, i suspect that series only works for -1 < z < 1
16:54:35 <newsham> 1/(1-4) = 1/(-3) = -1/3
16:54:41 <IW32> is it possible to convert a file saved as string to Int integers
16:54:43 <IW32> ??
16:54:48 * wli points to p-adic numbers again.
16:54:53 <IW32> or Int
16:54:56 <SamB_XP> newsham: so how do you know you are using real numbers?
16:54:59 <TSC> IW32: The "read" function will do it
16:55:01 <EvilTerran> > read "12" :: Int
16:55:03 <lambdabot>  12
16:55:11 <IW32> ok
16:55:11 <newsham> wli: I assume you're talking about my problem.. unfort you're not getting through to me.
16:55:12 <wli> Try |z| < 1
16:55:25 <_ry> mauke: i mean with the catH function .. just for sake of learning
16:55:30 <newsham> samb: I picked z=4
16:55:33 <EvilTerran> wli... which is what i said ;)
16:56:07 <Saizan_> IW32: you may find this helpful to start working with IO http://www.haskell.org/haskellwiki/Introduction_to_IO
16:56:08 <lambdabot> Title: Introduction to IO - HaskellWiki
16:56:17 <SamB_XP> newsham: how do you know that that 4 is a real number
16:56:18 <mauke> @undo do { handle <- openFile x ReadMode; catH handle; }
16:56:18 <lambdabot> openFile x ReadMode >>= \ handle -> catH handle
16:56:21 <mauke> _ry: ^
16:56:25 <EvilTerran> given that it clearly diverges for anything outside [-1..1], and (i think) cycles between 0 and 1 at +-1
16:56:36 <newsham> the question is -- what part of  the derivation fo 1/(1-z) --> SUM z^n   assumes |z|<1 ?
16:57:01 <_ry> mauke: okay. thanks
16:57:06 <newsham> sam: i dont understand your question.  are you being serious?
16:57:14 <EvilTerran> newsham, do you have a link to the derivation?
16:57:15 <SamB_XP> I'm not sure
16:57:17 <mauke> _ry: \x -> f x can be replaced by f, of course
16:57:26 <SamB_XP> I think I may have stopped being serious at some point
16:57:39 <LoganCapaldo> I like =<< sometimes
16:57:49 <SamB_XP> :t sometimes
16:57:50 <lambdabot> Not in scope: `sometimes'
16:57:53 <Olathe> =<< is completely backwards.
16:57:55 <newsham> evil: its in the haskell road book.
16:57:57 <LoganCapaldo> catH =<< (openFIle x ReadMode)
16:58:07 <EvilTerran> SamB_XP, because 4 = 1+1+1+1, 1 is the multiplicative identity, so is by definition a member of the reals, and the reals are closed on addition
16:58:10 <SamB_XP> @type =<<
16:58:11 <lambdabot> parse error on input `=<<'
16:58:15 <SamB_XP> @type (=<<)
16:58:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:58:22 <Olathe> @src (=<<)
16:58:22 <lambdabot> f =<< x = x >>= f
16:58:22 <SamB_XP> @type (>>=)
16:58:23 <mauke> @type (<$>)
16:58:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:58:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:58:28 <EvilTerran> does that work?
16:58:36 <SamB_XP> what does =<< do?
16:58:36 <Olathe> @src List.(>>=)
16:58:36 <lambdabot> Source not found. My mind is going. I can feel it.
16:58:41 <SamB_XP> does it involve time travel?
16:58:45 <LoganCapaldo> the same thing as >>=
16:58:48 <EvilTerran> <lambdabot> f =<< x = x >>= f
16:58:48 <Olathe> SamB: Yes.
16:58:49 <mauke> @src [] >>=
16:58:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:58:52 <LoganCapaldo> the order of the arguments is just flipped
16:58:53 <EvilTerran> SamB_XP, only in a MonadFix
16:59:06 <SamB_XP> @src=<<
16:59:06 <lambdabot> Unknown command, try @list
16:59:09 <SamB_XP> @src =<<
16:59:09 <lambdabot> f =<< x = x >>= f
16:59:15 <Olathe> @src ++
16:59:15 <lambdabot> (++) []     ys = ys
16:59:15 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
16:59:17 <hpaste>  newsham pasted "mini derivation" at http://hpaste.org/3907
16:59:20 <Olathe> Neat, no () needed.
16:59:22 <SamB_XP> ... that's exactly what I THOUGHT it did
16:59:29 <SamB_XP> what I wanted it to do
16:59:34 <SamB_XP> @src <<
16:59:34 <lambdabot> Source not found. Wrong!  You cheating scum!
16:59:37 <Olathe> @src List.>>=
16:59:37 <lambdabot> Source not found. Wrong!  You cheating scum!
16:59:55 <Olathe> > "test" >> const 2
16:59:55 <lambdabot>  Couldn't match expected type `[]' against inferred type `(->) b'
16:59:59 <Olathe> > "test" >> (const 2)
16:59:59 <lambdabot>  Couldn't match expected type `[]' against inferred type `(->) b'
17:00:06 <allbery_b> @src [] (>>=)
17:00:06 <lambdabot> m >>= k     = foldr ((++) . k) [] m
17:00:11 <mauke> f =<< x = mdo { y <- f x'; x' <- x; return y }
17:00:13 <_ry> thanks. boy. i need to internalize all these >>, return, and >>= operators soon
17:00:19 <SamB_XP> ah, some crazy wants << to do something totally crazy...
17:00:21 <Olathe> > "test" >> const [2]
17:00:21 <lambdabot>  Couldn't match expected type `[]' against inferred type `(->) b'
17:00:35 <mauke> SamB_XP: me?
17:00:37 <SamB_XP> I still don't get why some people want =<< to be something else
17:00:53 <SamB_XP> mauke: looks like...
17:01:10 <Olathe> > "test" >> [2]
17:01:10 <lambdabot>  [2,2,2,2]
17:01:12 <mauke> :t \f x -> mdo { y <- f x'; x' <- x; return y }
17:01:12 <lambdabot> forall t (t1 :: * -> *) t2. (MonadFix t1) => (t -> t1 t2) -> t1 t -> t1 t2
17:01:17 <Olathe> > [2] << "test"
17:01:18 <lambdabot>   Not in scope: `<<'
17:01:33 <newsham> evilt: http://hpaste.org/3907
17:01:33 <mauke> @let a << b = do { x <- a; b; return x }
17:01:34 <lambdabot> Defined.
17:01:42 <mauke> > [2] << "test"
17:01:43 <lambdabot>  [2,2,2,2]
17:01:45 <SamB_XP> mauke: what did you want << to do, the same as >>
17:01:46 <SamB_XP> ?
17:01:55 <SamB_XP> oh.
17:02:01 <SamB_XP> you want it to return the first thing?
17:02:04 <mauke> yes
17:02:15 <SamB_XP> that's a funky notation...
17:02:26 <shachaf> > [2] <* "test"
17:02:27 <lambdabot>  [2,2,2,2]
17:02:30 <SamB_XP> see, I like to use =<< in <- lines sometimes...
17:02:30 <IW32> i want the game to loop 8 times can i use the do notation, and how do i make it do it 8 times and then end game, i guess i need a counter
17:02:36 <Olathe> @src <*
17:02:36 <lambdabot> (<*) = liftA2 const
17:02:37 <mauke> SamB_XP: atom = token '(' >> expr << token ')'
17:02:42 <Olathe> @src liftA2
17:02:42 <lambdabot> liftA2 f a b = f <$> a <*> b
17:03:04 <SamB_XP> I have grown used to symmetry having meaning
17:03:21 <SamB_XP> as you know, <= and >= are mirror images of eachother, etc.
17:03:31 <mauke> > "test" *> [2]
17:03:32 <lambdabot>  [2,2,2,2]
17:03:38 <shachaf> SamB_XP: They are?
17:03:42 <mauke> hah
17:03:45 <EvilTerran> newsham, and so from that 1/(1-z) = fix (\x -> 1 + z * x), as it were?
17:03:46 <Olathe> > [1..8] >> putStrLn "Hello"
17:03:47 <lambdabot>  Couldn't match expected type `[]' against inferred type `IO'
17:03:49 <mauke> my definition of << makes sense!
17:04:03 * SamB_XP pretends not to have noticed that they aren't mirror images in ASCII
17:04:07 <shachaf> mauke: Except that you should just use <*. :-)
17:04:12 <Olathe> > [1..8] >>= const (putStrLn "Hello")
17:04:12 <lambdabot>  Couldn't match expected type `[]' against inferred type `IO'
17:04:23 <newsham> evilt: basically yah
17:04:25 <Olathe> Hmm...
17:04:33 <TSC> > [1..8] >>= const "Hello"
17:04:33 <lambdabot>  "HelloHelloHelloHelloHelloHelloHelloHello"
17:04:47 <SamB_XP> mauke: wait a minute
17:04:49 <mauke> shachaf: I invented << before I knew liftM, much less Applicative
17:04:54 <SamB_XP> your << doesn't do that time travel thing
17:04:55 <newsham> the book represents power series as an infinite list.  in this case it treats 1/(1-z) as the list [1,1,1,...]
17:05:09 <newsham> for 1*z^0 + 1*z^1 + 1*z^2 + ...
17:05:25 <SamB_XP> so you can't implement it in terms of =<<
17:05:28 <SamB_XP> that seems ugly
17:06:09 <newsham> isnt there a parser combinator like your "<<" that runs two parsers and returns the result of the first?
17:06:12 <SamB_XP> I think you should call your =<< =>>
17:06:21 <EvilTerran> there's <* in Control.Applicative
17:06:22 <mauke> my =<< was a joke :-)
17:06:34 <SamB_XP> mauke: ... oh
17:06:37 <SamB_XP> it's ... hard to tell
17:07:04 <SamB_XP> so who ACTUALLY THINKS =<< IS BACKWARDS IN SOME BAD WAY?
17:07:30 <Pseudonym> I think >>> is backwards.
17:07:31 <Tene> SamB_XP: =<< is backwards, right?
17:07:44 <shachaf> Well, I always have to think about it when I use it.
17:07:49 <SamB_XP> Pseudonym: you want it to do what <<< does and vice versa?
17:07:50 <shachaf> But then, I don't use it much...
17:08:02 <SamB_XP> shachaf: but it's just like >>=, only backwards
17:08:03 <Pseudonym> SamB_XP: I don't want.  Like =<<, I avoid arrows.
17:08:12 <int-e> @src (=<<)
17:08:12 <lambdabot> f =<< x = x >>= f
17:08:20 <int-e> pretty :)
17:08:20 <SamB_XP> which is what it is SUPPOSED to be
17:08:25 <SamB_XP> and what it LOOKS like
17:08:32 <gwern> I have a bit of a problem about this: http://hpaste.org/3886#a2 . I'm running a series of tests using it, with +RTS -N1 -RTS, and +RTS -N4 -RTS (I have a 4-core system), and the -N1 version runs in like 55seconds while the -N4 is running in like 1m20s, which is the exact opposite of what i'd expect. anyone know whether I'm doing something wrong?
17:08:35 <Olathe> > let (<<>>) 1 f = f; (<<>>) n f = f >> ((<<>>) (n - 1) f); in 8 <<>> putStrLn "Hello"
17:08:35 <lambdabot>  <IO ()>
17:08:36 <shachaf> SamB_XP: You just said you like <=/>=.
17:09:01 <SamB_XP> shachaf: well, I like them better when displayed in their proper one-character forms
17:09:05 <SamB_XP> ;-)
17:09:13 <Olathe> > let (*>>) 1 f = f; (*>>) n f = f >> ((*>>) (n - 1) f); in 8 *>> putStrLn "Hello"
17:09:14 <lambdabot>  <IO ()>
17:09:18 <int-e> gwern: did you look at the gc summary (-sstderr)? maybe it's spending most of its time doing GC?
17:09:22 <EvilTerran> i know of at least one language that writes less-than-or-eq as =<
17:09:26 <mauke> Olathe: your base case is wrong
17:09:44 <gwern> int-e: no, I didn't.
17:10:00 <mauke> Olathe: (*>>) 0 f = return ()
17:10:06 <mauke> and then it's replicateM_
17:10:20 <Olathe> @src replicateM_
17:10:20 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
17:10:27 <EvilTerran> newsham, well, i'm stumped. it's easy to determine rigorously over what range it converges, but i can't say why
17:10:43 <newsham> cale on #math says its only valid when it converges
17:10:45 <newsham> which I guess makes sense
17:10:51 <SamB_XP> EvilTerran: you would perhaps benefit from some kind of calculus book?
17:11:12 <EvilTerran> surely this is more in the realms of analysis?
17:11:23 <Olathe> > let (*>>) = replicateM_ in 8 *>> putStrLn "Hello"
17:11:24 <lambdabot>  <IO ()>
17:11:42 <SamB_XP> EvilTerran: I was under the impression that analysis was just calculus with rigor
17:11:45 <EvilTerran> regardless, I've never studied analysis, and i never did particularly well at calculus, so maybe i'm the wrong person to be trying to help ;)
17:12:50 <int-e> gwern: Depending on how much time the tests take the Chan could also be a bottleneck. It's hard to say.
17:12:57 <EvilTerran> i got the impression that it's effectively the ground-work necessary to use the real numbers for *anything* rigorous
17:13:13 <SamB_XP> EvilTerran: could be!
17:13:17 <EvilTerran> which, naturally, tends to include an ungodly amount of calculus
17:13:25 <SamB_XP> naturally
17:13:33 <EvilTerran> ... or should that be "real-ly"?
17:13:42 <SamB_XP> I was wondering that myself ;-)
17:13:57 <gwern> int-e: each test individuallyu is pretty quick, it's just 100 or more that causes it to chug along a while
17:13:58 * sorear is under the impression analysis is just topology specialized to E_{1}
17:14:05 <EvilTerran> 'scuse me, i have to go turn over my laundry so it'll crisp up on the other side ;)
17:14:19 <SamB_XP> .... WHAT?
17:14:24 <sorear> how accurate is that?
17:14:26 <SamB_XP> I like my laundry not crispy
17:14:40 <SamB_XP> @seen Cale
17:14:40 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I don't know when Cale last spoke.
17:14:40 <EvilTerran> hehe. I mean it's due to be moved from the washer to the drier
17:14:48 <EvilTerran> but the cooking analogy struck me as more amusing
17:14:50 <Cale> newsham: If you want a better explanation, I can give it in a little while.
17:14:55 <SamB_XP> EvilTerran: heh
17:15:09 <newsham> cale: i wouldnt mind as long as I can understand it :)
17:15:14 <SamB_XP> Cale: so what is analysis?
17:15:15 <EvilTerran> "baste with fabric softener"
17:15:25 <SamB_XP> EvilTerran: ewww
17:15:47 <Cale> http://www.math.niu.edu/~rusin/known-math/index/tour_ana.html
17:15:47 <lambdabot> Title: Analytic areas of mathematics
17:16:56 <hpaste>  gwern annotated "any suggestions about elegance?" with "-sstderr " at http://hpaste.org/3886#a3
17:19:10 <SamB_XP> EvilTerran: apparantly the calculus is a part of analysis?
17:19:30 <SamB_XP> and sequences and series seem to be part of that ;-P
17:20:01 <newsham> this known-math map is pretty impressive
17:20:20 <SamB_XP> I want the unknown-math map
17:20:34 <newsham> can you wait, sam?
17:20:39 <davidL> @index popen
17:20:39 <lambdabot> bzzt
17:20:49 <SamB_XP> newsham: how long?
17:21:19 <allbery_b> @where newpopen
17:21:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
17:21:35 <davidL> thanks allbery_b
17:21:37 <newsham> i'll let you know
17:22:26 <SamB_XP> newsham: I have my doubts
17:22:46 <SamB_XP> isn't it established that some parts of math may never be discovered, ever?
17:23:36 <hpaste>  gwern annotated "any suggestions about elegance?" with "forgot the -N1 timings" at http://hpaste.org/3886#a4
17:26:47 <gwern> weird. hpaste seems to keep mangling it
17:28:21 <int-e> hmm, your terminal is 142 characters wide?
17:29:04 <gwern> it's pretty wide, yeah.
17:29:05 <SamB_XP> I love the signature on this:
17:29:10 <SamB_XP> http://www.math.niu.edu/~rusin/known-math/95/delicate.conv
17:29:34 <gwern> who manually types their sig?
17:30:03 <SamB_XP> ... I think it was a joke
17:30:21 <int-e> gwern: you're pasting 142 characters per line (most of them spaces), I don't think that's hpaste's fault. Oh and hpaste duly truncated the paste after 5000 characters
17:30:49 <kfish> gwern, my friend dave: http://www.inodes.org/~johnf/slarken/dave.shtml
17:30:50 <lambdabot> Title: Slarken Dave
17:31:47 <gwern> kfish: your friend dave has a problem that he writes those and lovingly posts them online
17:32:33 <kfish> gwern, well, someone else['s script] posts them online :-)
17:33:28 <int-e> gwern: hmm, why does the -N1 output have 8 (or more) worker tasks though? that's suspicious.
17:33:35 <SamB_XP> I wonder if anyone has done that for timbot...
17:33:49 <int-e> gwern: did you try -N2?
17:34:09 <gwern> no. I figured all or none
17:39:56 <hpaste>  gwern annotated "any suggestions about elegance?" with "-N2" at http://hpaste.org/3886#a5
17:41:42 <int-e> gwern: Anyway, I don't see anything wrong with your program, assuming that quickCheck' fully evaluates its result before returning. It should parallelize stuff nicely, and the GC time in the -N4 case is big but not big enough to explain a slowdown.
17:41:51 <gwern> given the '%GC time      17.1%  (10.5% elapsed)' line for -N2 and a similar line for -N4, I don't think GC is the reason for the extra 30 seconds
17:42:41 <gwern> int-e: well, quickCheck' is just the IO Bool form of quickCheck (IO IO), so it evaluates as much as regular quickchecks do
17:42:46 <gwern> *(IO ())
17:46:00 <int-e> Wait, you didn't compile the program?
17:46:59 <gwern> I'm going through ghci, but if you really want, I'll define main as the tests and run the compiled binary
17:51:19 <zeeeee> are there any haskell libraries for posix process management/control? (something higher level than system.posix.process)
17:52:44 <zeeeee> (a bash replacement, but n times better)
17:52:59 <dcoutts> zeeeee: there are several shell libraries
17:53:13 <zeeeee> dcoutts, yeah, i saw a few
17:53:16 <zeeeee> e.g. hsh
17:53:19 <dcoutts> zeeeee: I don't know them well personally, see hackage and the libraries and applications on haskell.org
17:53:42 <zeeeee> dcoutts, usually they're only about piping among child processes
17:53:46 <int-e> gwern: I don't know what ghci does to the RTS options, I just know that it uses a threaded RTS by default somehow. So eliminating that unknown variable could help.
17:53:53 <dcoutts> zeeeee: or see if anyone else here has some recommendation
18:03:08 * dmwit finds himself implementing the Prelude in C++.
18:03:33 <dmwit> templates are way less nice than Haskell's polymorphism.
18:03:52 <hpaste>  gwern annotated "any suggestions about elegance?" with "time's output, -N1-N7" at http://hpaste.org/3886#a6
18:04:31 <gwern> int-e: I ran time on the compiled binary. it seems that the largest difference is between -N1 and -N2
18:05:18 <gwern> (I should probably note that all the QuickCheck tests in nuke.hs are satisfied and the function definitions correct)
18:09:44 <Pastorn> @pl (\xs -> (iterate . sort $ xs) !! (length xs -1))
18:09:44 <lambdabot> ap ((!!) . iterate . sort) (subtract 1 . length)
18:10:16 <Pastorn> can i make lambdabot do that without ap?
18:10:24 <Pastorn> @type ap
18:10:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:12:17 <sorear> Pastorn: no
18:12:22 <sorear> Pastorn: ap is *crucial*
18:12:28 <Pastorn> heh
18:12:45 <sorear> Pastorn: you are familiar with the SKI-calculus, yes?  ap is S
18:12:53 <Pastorn> ???
18:12:54 <Pastorn> no
18:13:04 <Pastorn> SKI being short for...?
18:13:14 <sjanssen> S K I
18:13:17 <sjanssen> :)
18:13:33 <Pastorn> whut??
18:13:41 <sjanssen> each letter is a combinator
18:13:47 <sjanssen> I = \x -> x
18:13:55 <Brian`> how do i check if a module "HaXml" is installed on my comp?
18:13:55 <sjanssen> K = \x y -> x
18:14:17 <paczesiowa> ghc-pkg list
18:14:47 <paczesiowa> Brian`: ghc-pkg list
18:15:01 <Brian`> paczesiowa: k :) thanks
18:17:35 <Pastorn> @type scanl
18:17:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
18:17:41 <Pastorn> @type scanl1
18:17:42 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
18:21:08 <int-e> gwern: Sorry, I don't understand those numbers, in particular why you only get 115% CPU for N>=2.
18:21:55 <gwern> yeah. maybe I should send haskell-cafe an email. perhaps there's soemthing about channels' performance that nobody's mentioned yet
18:24:01 <lekro> if I have some identifier bound to a value by a where or let clause, is it correct to call that thing a "variable"? I'm a bit uncertain because "variable" could imply some change
18:24:26 <lekro> or: how would you call it?
18:24:29 <liyang2> variables don't. :)
18:24:35 <gwern> in a mathematical sense, it's fine. x = y + 1, both x and y are variables, but they don't change
18:25:01 <liyang> Call them identifiers, if you will.
18:25:20 <lekro> identifier seems to refer to the name itself, not to the value behind it
18:25:42 <liyang> (But that'd make you a salmon. Swimming upstream.)
18:26:19 <lekro> hm :)
18:26:52 <liyang> lekro: so if you write let x = y + z in ... x ..., is x a value or expression?
18:27:22 <liyang> or, let's just not care and call it an identifier for the expression y + z instead.
18:27:26 <lekro> I'd say it's a value
18:27:41 <lekro> ok, functions are values, of course.
18:27:47 <scook0> well, the nice thing about referential transparency is that "value" and "expression" aren't much different :)
18:27:59 <liyang> Well, the spineless tagless G-machine would say it's both, at different times. (Kind of.)
18:28:38 <lekro> just yesterday I started reading the paper about the STG machine.
18:29:59 <lekro> quite interesting topic, I didn't expect that compiling Haskell is *so* much different from compiling Lisp
18:30:11 <Brian`> how do i convert IO String to String?
18:30:16 <dmwit> Wait, spineless?
18:30:21 <dmwit> I'll have to add that to my reading list.
18:30:55 <dmwit> Brian`: You don't.
18:31:14 <dmwit> Brian`: Though you can pass the String to functions outside of the IO monad.
18:31:15 <gwern> Brian`: unsafePerformIO
18:31:23 <lekro> Brian`: you use the do notation or (>>=) or something similar
18:31:31 <dmwit> gwern: shhh!
18:31:35 <dmwit> ;-)
18:31:38 <Brian`> lol
18:31:45 <Brian`> then how should I get around this...
18:31:51 * gwern winks at dmwit. hee hee. I am a moderately naughty person
18:31:56 <dmwit> Brian`: What are you trying to do?
18:31:56 <Brian`> I'm trying to read RSS
18:32:05 <Brian`> and getRSSData returns IO String
18:32:21 <Brian`> and I want to parse it with Text.XML.HaXml.Parse
18:32:29 <Brian`> so I can use pretty print
18:32:35 <dmwit> right
18:33:01 <Brian`> In order to parse it with HaXml.Parse, I need type String... but I have IO String
18:33:03 <Brian`> any idea?
18:33:07 <dmwit> So, something like "do { s <- getRSSData; return (parse s) }".
18:33:32 <dmwit> If parse has the type String -> ParsedVersion, then this will have the type IO ParsedVersion.
18:33:50 <dmwit> Notice that the IO is "contagious" -- once you're in IO, you're always in IO.
18:34:09 <dmwit> There are tons of monad tutorials out there if you want more information about what exactly is going on.
18:34:18 <Brian`> hm.. okay
18:34:42 <Brian`> so right now
18:34:45 <shachaf> @wiki Monads as computation
18:34:46 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
18:34:49 <Brian`> I can't make it work ..?
18:34:52 <dmwit> My two favorites are "You Could Have Invented Monads (and Maybe You Already Did)" and "All About Monads".
18:35:02 <dmwit> Brian`: You *can* make it work... I've just showed how.
18:35:09 <shachaf> dmwit: s/Did/Have/
18:35:19 <shachaf> Monads_as_computation is nice.
18:35:23 <dmwit> shachaf: Oh, thanks.
18:35:31 <Brian`> do { s <- getRSSData; return (parse s) } this would work..?
18:35:33 <Brian`> let me try
18:35:34 <Brian`> brb
18:35:46 <shachaf> Wait, hmm.
18:35:58 <shachaf> No, that's right.
18:36:08 <shachaf> Brian`: Yes.
18:36:22 <shachaf> Brian`: Also (fmap parse getRSSData), or (parse <$> getRSSData).
18:36:36 <dmwit> Brian`: In your code, you'll probably want to translate the {;} notation into indentation instead, it's easier to read and more idiomatic.
18:36:55 <shachaf> Brian`: fmap/liftM/(<$>) applies a regular function "inside" a Monad (or Functor).
18:38:03 <shachaf> @ty fmap
18:38:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:44:43 <LoganCapaldo> no it doesn't
18:45:00 <LoganCapaldo> fmap turns a regular function a new functio on  a Functor :)
18:45:31 * LoganCapaldo is kidding
18:46:18 <newsham> won't you take me to functor town
18:47:15 <dmwit> Oooo, that reminds me, I should put on some music!
18:47:30 <newsham> MIT OCW videos more entertaining than music
18:47:50 <Brian`> hey dmwit, how come do { s <- getRSSData; return (parse s) } works and not do { s <- getRSSData; xmlp <- (parse s); return xmlp} ?
18:48:02 <dmwit> newsham: Yes, but less work-conducive.
18:48:25 <dmwit> Brian`: "return" is not what you're thinking of from other languages.
18:48:27 <newsham> brian: whats the type of (parse s) ?
18:48:34 <dmwit> return puts a value into a monad.
18:48:46 <Brian`> Text.XML.HaXml.Types.Document Text.XML.HaXml.Posn.Posn
18:48:49 <dmwit> So, return takes a value and returns that value, but "wrapped" in a monad.
18:48:52 <Brian`> newsham, Text.XML.HaXml.Types.Document Text.XML.HaXml.Posn.Posn
18:48:57 <dmwit> That is the meaning of this:
18:48:59 <dmwit> :t return
18:49:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:49:02 <newsham> how about: do { s <- getRSSData; let xmlp = parse s; return xmlp} ?
18:49:26 <Brian`> dmwit, so inside do notation, it has to return a monad?
18:49:33 <dmwit> Moreover, the (<-) notation requires the right-hand side to be "wrapped" in a monad.
18:49:34 <newsham> "let var = ..." and "var <- .." are similar but not exactly the same
18:49:38 <pjd> return is roughly the one-parameter version of fmap
18:49:38 <dmwit> Brian`: Exactly!
18:49:42 <dons> oh, heh, http://prog.eskosoft.com/node/29
18:49:44 <lambdabot> Title: Pure functional? | Programming tips, tricks and thoughts
18:49:57 <dons> simple assumtpions that ghc should memoise and multithread naive code leads to disappointment..
18:50:02 <dmwit> Brian`: So, in your example, the second (<-) doesn't get a monad on the right, it gets a plain value.
18:50:07 <Brian`> newsham, yeah that one worked ; haha I'm still confused a bit though
18:50:13 <dmwit> It doesn't know how to "unwrap" that, so it complains.
18:50:55 <Brian`> s
18:51:01 <newsham> brian:   x <- action     works to get a value out of a monad action
18:51:02 <dmwit> Brian`: Notice that on the first computation, the right-hand side of the (<-) has type IO String... it is a String wrapped in the IO monad.
18:51:12 <newsham> let x = purefunc   works to get a value out of a pure function
18:51:15 <Brian`> dmwit, so not only the final return, but every line in do notation has to give monad , is it correct?
18:51:24 <dmwit> Hmmm.
18:51:33 <newsham> return pureval   works to change a pure value into an action with that result
18:51:56 <dmwit> Brian`: Not really.  All the (<-) lines have a monad on the RHS and a plain value on the LHS.
18:52:08 <dmwit> All the "let" lines have a plain value on the LHS *and* the RHS side.
18:52:19 <dmwit> And the last line has just a monadic value.
18:52:27 <newsham> dmwit: variable binding on lhs,  plain value on rhs
18:52:45 <dmwit> newsham: Ah, yes, that's clearer.
18:52:59 <dmwit> Brian`: All the left-hand sides of (<-) and (=) are variable bindings.
18:53:44 <dmwit> (Note that all these comments are specifically for lines within a do-block.)
18:53:52 <Brian`> hm.. okay
18:53:52 <pjd> Brian`: it's probably worth looking at how do notation translates to binds
18:54:01 <dmwit> yeah
18:54:02 <Brian`> sure
18:54:06 <pjd> that should take the mystery out of it
18:54:17 <Brian`> alright I guess I'll do that then
18:54:24 <Brian`> is "All About Monads" a good resource?
18:54:30 <pjd> (assuming you're familiar with bind :)
18:54:34 <dmwit> yep
18:54:49 <newsham> dons: amusing blog.  I think part of the blame goes to haskell hype.  isnt it great being popular?
18:55:43 <dons> ah :)
18:56:46 <pjd> Haskell seems to be inheriting unrelated hype about pure functional programming in general
18:57:24 <newsham> there has been a lot of hype that there is the potential to do amazing things with pure code.  and even some real results that research is making some of them come true
18:57:38 <goalieca> pjd, because of things like STM being so bloody simple in haskell.
18:57:40 <pjd> because everyone starts explaining the benefits of referential transparency as "well, it means the compiler can memoize and parallelize your code..."
18:57:51 <newsham> and a large population of broken inference engines receiving all of this information
18:58:28 <pjd> newsham++ for " broken inference engines"
18:58:46 <dmwit> heh
19:00:45 <LoganCapaldo> I think we shuld with explaining the benfits of referential transparency as "You know those other programmers? The ones you don't trust? They can't mess with you. Even if they are you."
19:01:20 <newsham> its awesome not being able to mess w/ myself.
19:01:40 <dmwit> I've taken advantage of that fact lots of times.
19:02:24 <int-e> @quote cjs
19:02:24 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
19:02:24 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
19:02:48 <dmwit> cjs++
19:03:36 <newsham> that sounds pointless
19:05:03 <allbery_b> it's nice not to have to play "show the nice debugger where on the doll the bad pointer touched you"
19:05:32 <dmwit> Wow.
19:05:41 <dmwit> I think that's the first time I've seen segfaults compared to rape.
19:06:23 <LoganCapaldo> Hopefully it won't be the last
19:06:32 <dmwit> Agreed.  Rape is the new murder. ;-)
19:06:46 <newsham> allb: to be honest, debugging can be quite enjoyable at times (if not productive)
19:07:05 <LoganCapaldo> I _hate_ debugging
19:07:10 <newsham> perhaps helsinki syndrome
19:07:32 <zeeeee> anybody here understand concurrent haskell/async exceptions? i'm wondering how to safely interrupt. e.g., can only particular kinds of interrupts be blocked? can you prevent the interruption of interruptible operations (io)?
19:08:12 <newsham> logan: its a puzzle and you get to be a detective.  also sometimes you debug other peopls programs to make it do things that the program isnt supposed to do which is an even more interesting puzzle
19:08:29 <newsham> like call the execve systemcall to run /bin/sh -i
19:09:28 <pjd> @remember allbery_b it's nice not to have to play "show the nice debugger where on the doll the bad pointer touched you"
19:09:28 <lambdabot> Done.
19:10:18 <Lewisham> that one needs to go on my office wall
19:10:47 <kfish> yow
19:10:56 <LoganCapaldo> newsham: I find it frustrating. It means either a) I did something wrong or b) someone else did something wrong or c) I don't understand the code as well as I should which a is actually just a special case of
19:11:20 <dmwit> I've resigned myself to making lots of mistakes.
19:11:23 <newsham> *nod*  and its definitely not productive
19:11:42 <newsham> but sometimes captives learn to admire and sympathize with their captors.
19:11:53 <LoganCapaldo> Sure I know I'll make lots of mistakes. I just don't have to enjoy fixing them do I? :)
19:11:54 <newsham> and I've had many memorable moments in gdb and other debuggers
19:12:43 <dmwit> I often enjoy the "Aha!" moment, especially if it's in a section of code far removed from what I'm currently single-stepping through.
19:13:19 <dmwit> I get to think, "See?  I didn't need the stupid debugger" even though it probably gave me the crucial pieces of information when I wasn't looking.
19:13:19 <newsham> its some of the same puzzle, how do I make it work, what is it doing, discovery feeling that drew me into computing in the first place
19:13:34 <LoganCapaldo> I find the aha moment has a really bitter aftertaste
19:13:42 <newsham> heh
19:14:00 <LoganCapaldo> sorry I'm being so contrary :)
19:14:19 <newsham> not at all..  if thats how you feel thats how you feel.
19:16:51 <Saizan_> the worst is when your code looks in a way and is parsed in another, like int x = 0; if (true) if (false) x=1; else x=2; what is x now in java?
19:17:37 <newsham> the worst is when you spend 3 full days debugging a problem and find out that the deficiency is in a compatibility layer written by an external vendor on which your code relies.
19:17:40 <LoganCapaldo>  /me guesses 0
19:18:06 <EvilTerran> Saizan_, the else attaches to the nearest if, iirc, so 2.
19:18:19 <Saizan_> LoganCapaldo: i thought so, but EvilTerran wins :)
19:18:20 <newsham> but hey, at least you were able to reproduce the bug in the first place
19:18:41 <EvilTerran> :D
19:19:33 * EvilTerran learnt the "else attaches to the nearest if" rule fairly early on when learning C. it so happened that one of the guides i was working from chose to mention it as a pitfall of the single-line-control-structure syntax.
19:20:14 <newsham> also commonly taught in compilers classes (dangling-else problem)
19:20:42 <dmwit> It's almost impossible to have it attach the other way.
19:21:00 <newsham> how so?
19:21:05 <EvilTerran> but, with the right indentation, it can look like it does to the casual observer
19:21:11 <dmwit> Well... for LALR(1) grammars.
19:21:11 <LoganCapaldo> I was trying too hard. I imeediately thought dangling else, so it can't be the dangling else :)
19:21:18 <newsham> if you choose reduce over shift in typical LALR(1) it will come out the other way
19:21:42 <dmwit> newsham: I don't think that's true.
19:21:50 <dmwit> It will become an error.
19:21:56 <newsham> dmwit: no, it wont.
19:22:14 <Saizan_> EvilTerran: yeah, that tricked me.. silly languages where indentation is not significant :)
19:22:17 <dmwit> newsham: I'm often wrong, so I'll trust you, but how would it know on which if to shift?
19:22:33 <newsham> dmwit: you could come out with other cases where it would come out wrong
19:22:45 <dmwit> I would think it would reduce all the "if" clauses at once.
19:22:47 <newsham> ie. you wouldnt know you made the wrong choice until too late
19:22:58 <newsham> but for the example given above it works fine
19:23:30 <newsham> ie:   if E then S else if E then S else S
19:23:50 <newsham> now you ahve two elses and if you reduce early your last "else S" will not have anythign to match with
19:24:17 <newsham> (unless braces were used)
19:24:35 <dmwit> Sorry, the example I see is "if E then if E then S else S".
19:24:43 <dmwit> Suppose you're here in the parse:
19:24:51 <dmwit> if E then if E then S . else S
19:24:56 <dmwit> You choose reduce, right?
19:25:17 <dmwit> So now you're here: if E then IFCLAUSE . else S
19:25:18 <newsham> oh, you're saying its going to reduce both if's
19:25:21 <dmwit> yeah
19:25:27 <newsham> hrm.. you're right.
19:25:29 <newsham> sorry
19:25:29 <dmwit> So the "else" is an error, suddenly.
19:27:18 <dmwit> I have an unfair advantage, I'm in compilers class right now. ;-)
19:27:35 <newsham> yah, but I should know this stuff..  *sigh*
19:29:45 <jtxx000> which style is preferred: (`f` x) or f `flip` x ?
19:30:15 <lekro> what about flip f x?
19:30:16 <dmwit> Programmer's choice.
19:30:30 <dmwit> But yes, usually flip f x over f `flip` x.
19:30:55 <goalieca> if it reads like english or math then use infix
19:30:57 <dmwit> Different things are appropriate at different times, I think.
19:31:02 <dmwit> (`mod` 5)
19:31:10 <dmwit> but
19:31:17 <dmwit> flip findScope identifier
19:32:54 <newsham> def(:)
19:33:24 <dmwit> hmm?
19:33:32 <newsham> def-cons
19:33:41 * allbery_b rolls his eyes
19:33:48 <dmwit> ouch
19:47:34 <dmwit> C++ needs deriving.
19:48:53 <Pseudonym> Oh, man.
19:49:03 <Pseudonym> As if C++'s type system isn't arbitrary enough.
19:49:27 <dmwit> good point
19:49:38 <dmwit> Still, you'd think they could make operator== automatically.
19:49:47 <Pseudonym> I'm trying to wrap my brain around deriving plus implicit casts.
19:50:14 <Pseudonym> Implicit arity-1 constructors are bad enough.
19:50:50 <dmwit> Ew, C++'s constructors are sad sad news.
19:50:55 <Pseudonym> Yeah.
19:51:10 <Pseudonym> According to the guy who proposed "explicit", the committee only accepted it reluctantly.
19:51:33 <Pseudonym> It's a no-brainer today.  Rather than "explicit", it would be better to have an "implicit" keyword.
19:51:47 <kfish> template<class Elite> deriving Crack
19:53:01 <Pseudonym> Nathan Myers.  That's the guy.
19:57:28 <newsham> instance webserver deriving everything
19:58:35 <dmwit> heh
19:59:06 <dmwit> class Everything a where {}
19:59:18 <dmwit> instance (Eq a, Ord a, ...) => Everything a where {}
20:01:24 <newsham> when will you be able to give a computer a homework programming problem and have it spit back a program?
20:01:39 <dmwit> Never.
20:01:46 <dmwit> Programming problems will change to ensure that. ;-)
20:01:47 <newsham> oh pshaw.
20:02:10 <newsham> surely someone can write a program as smart as an undergrad
20:02:38 <brad_> has anyone else tried to build ghc 6.8.1 on freebsd?
20:02:55 <newsham> brad: yes.  i built it on amd64
20:03:02 <EvilTerran> newsham, that's true, but, much like an undergrad, its answers would almost invariably be wrong ;)
20:03:22 <brad_> newsham - did you have a previous ghc on your box?
20:03:30 <brad_> i can't get past ./configure
20:03:51 <dmwit> You need GHC to build GHC.
20:03:55 <dmwit> Quite a quandary, eh?
20:03:58 <brad_> "utils/pwd/pwd: no such file or directory"....?
20:04:09 <newsham> brad: what cpu?
20:04:15 <newsham> I did have previous version.
20:04:19 <brad_> i386
20:04:22 <brad_> freebsd 7
20:04:31 <newsham> oh, freebsd7 has compiler that ghc doesnt like
20:04:33 <newsham> known issue :(
20:04:38 <brad_> gcc 4.1?
20:04:50 <newsham> could be?  I dont have freebsd7 yet.
20:05:07 <brad_> i had to go to 7 on this macbook to get wireless...
20:05:16 <brad_> but i had to give up haskell apparently
20:05:26 <brad_> ghc should be able to build itself from source
20:05:35 <brad_> perl folks used to have miniperl to build the full perl
20:05:37 <newsham> maybe you can get older gcc to build with?  canyou make-do with hugs?
20:06:12 <newsham> ghc is in /usr/ports in freebsd and typically can build itself from src just fine
20:06:19 <newsham> (i think it downloads a bootstrap level)
20:06:26 <brad_> i'll probably just wait for the freebsd guys to do the port, but it won't be anytime soon, i think they are actually going to wait for 6.3 and 7 to go in release before they change the port
20:06:50 <brad_> ghc port right now is marked BROKEN for freebsd 7
20:07:04 <newsham> yah because of gcc.
20:07:05 <brad_> i have been in touch with the porter
20:07:39 <davidL> brad_: do you know if they will make extralibs a seperate port?
20:07:51 <brad_> davidL - in the past they have not
20:08:11 <davidL> they should :-\
20:08:37 <brad_> i might be wrong on that davidL, best to check the freebsd site
20:08:50 <newsham> david: why?  you can build your own if you dont want extras :)
20:09:26 <davidL> it's easier to write ports if the extralibs is seperate
20:10:24 <brad_> has it ever been brought up in the past that ghc cannot bootstrap itself?
20:10:37 <sorear> kfish: eek.  show has *nothing* to do with utf-8
20:13:30 <dons> brad_: ?
20:13:44 <brad_> maybe my question was not accurate
20:13:56 <lekro> is there an idiom for: map (\x -> (head x, length x)) . group ?
20:14:21 <sorear> lekro: asides from the obvious (use &&&), no
20:14:28 <dons> using &&& is the idiom
20:14:44 <dons> :t map (head &&& length) . group
20:14:46 <lambdabot> forall a. (Eq a) => [a] -> [(a, Int)]
20:14:58 <brad_> i made the tweaks suggested by the twiki for doing a "unregisterised" build in the build.mk file, still can't get past ./configure....
20:15:01 <dons> we've seen this a lot lately -- everyone writing run length encoding tools?
20:15:11 <dons> brad_: how so?
20:15:23 <brad_> "utils/pwd/pwd: no such file or directory"
20:15:24 <sjanssen> brad_: unregisterised builds still require ghc
20:15:30 <dons> this is right, if you're porting ghc to a new platform
20:15:37 <dons> you generate unregisterised .hc files on one machine
20:15:42 <dons> copy them to the new one
20:15:45 <dons> and compile with gcc there
20:15:46 <brad_> people say it is a compiler issue on freebsd 7, but this is in the configure stage
20:15:56 <lekro> dons: in my case it's for computing the length of lines of pieces for a board game
20:15:56 <dons> looks like a shell script problem
20:16:08 <dons> lekro: cool
20:16:09 <newsham> brad: what is the error you got?
20:16:11 <sjanssen> brad_: utils/pwd/pwd is a small Haskell script, it is failing because you don't have GHC
20:16:12 <araujo> Does darcs compile with latest ghc?
20:16:34 <dons> brad_: are you following the directions properly? generating the .hc bundle on your working machine
20:16:35 <brad_> sjanssen - you are right, i am trying to get ghc!
20:16:44 <dons> before porting to your unsupported arch?
20:16:50 <dons> you will need one machine with ghc on it
20:17:18 <brad_> well i have a freebsd 6 box, but it has an older compiler on it
20:17:23 <newsham> dons: its freebsd, he can build from ports, except it doesnt work now because freebsd7 has newer gcc which breaks ghc
20:17:28 <newsham> so he's out of luck.
20:17:49 <brad_> but even then newsham, i am getting breakage in ./configure
20:18:05 <newsham> because as sjanssen said you need ghc to build ghc
20:18:07 <newsham> and you dont have it
20:18:12 <brad_> i *should* be able to build *something* on a naked box!
20:18:17 <dons> right. to port, you must have a working ghc on some box already
20:18:22 <newsham> brad: you can if you use the ports
20:18:25 <dons> brad_: you're not following the process :)
20:18:35 <newsham> because the ports installs a bootstrap core
20:18:35 <brad_> newsham - the port is broken
20:18:41 <sjanssen> brad_: you have to use an existing GHC binary, just like the GCC build procedure
20:18:46 <newsham> right, because its not possible to build on freebsd7
20:18:59 <dons> newsham: even when bootstrapping from .hc ?
20:19:20 <newsham> dons: I imagine he could use the port manually to get the boostrap bits
20:19:20 * dons points out that openbsd is working fine :)
20:19:39 <newsham> but first he'll have to tell the port that its not broken
20:19:44 <newsham> and then it wil break during the build :)
20:19:54 <davidL> openbsd doesn't have 6.8 in ports does it?
20:19:58 <brad_> normally i would just have gone with freebsd 6.3, but i need freebsd 7 for wireless on the new laptop
20:20:02 <brad_> :(
20:20:07 <dons> davidL: no, but 6.8 works from 6.6.1, in the ports
20:20:11 <brad_> so i either have a network or my fave programming language
20:20:27 <newsham> brad: is it possible to get latest driver merged into 6.2 sources?
20:20:43 <newsham> (is it in 6.2-STABLE?)
20:20:44 <dons> why not port ghc first? sounds easier
20:20:57 <dons> it can't be too badly broken, can it?
20:21:14 <brad_> maybe, i am using sam leffler's ath branch, but i figure it can't be too long for ghc to get fixed
20:21:21 <newsham> dons: http://www.nabble.com/freebsd-7.0BETA1-and-ghc-t4684983.html
20:21:21 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - freebsd-7.0BETA1 and ghc
20:21:29 <dons> brad_: for atheros support?
20:21:34 <brad_> yes dons
20:21:39 * dons points out openbsd supports atheros nicely :)
20:21:53 <brad_> i think dons, that openbsd will not actually support my chip
20:21:56 <brad_> accoding to sam
20:22:10 <brad_> ryek's openbsd free driver does not support it
20:22:11 <dons> oh, some new AR52xx ?
20:24:17 <brad_> yes
20:24:17 <newsham> brad_: how about build ghc in freebsd6.2 and copy over to freebsd7?
20:24:17 <dons> yeah, there's the 5213 (?) i think, which reyk was playing with
20:24:18 <brad_> newsham - i could do this, since i do have gcc4.1 built on freebsd 6.3
20:24:18 <brad_> and gcc 3.x
20:24:18 <newsham> it wont work with gcc4.1 (if i understand correctly)
20:24:18 <brad_> will i have breakage if i take a gcc 3.x build and move it ?
20:24:18 <newsham> brad: try building binary package from ports and copying over?
20:24:18 <newsham> I think at least ghci should work.  your compiles might not work properly if they use gcc
20:24:18 <brad_> ghc is such a beast i don't know what all to copy
20:24:18 <brad_> i guess i could look at the install manifest
20:24:18 <dons> newsham: so -fasm is an option?
20:24:18 <newsham> dons: *shrug* maybe?
20:24:29 <newsham> brad: ports lets you build binary packages right?
20:24:44 <brad_> you may be right newsham, io would have to look that up
20:25:05 <dons> we need a ghc maintainer for freebsd
20:25:08 <newsham> "make package"
20:25:20 <brad_> cool newsham, you learn something new each day
20:25:23 <newsham> MAINTAINER=     haskell@FreeBSD.org
20:25:33 <newsham> brad: ports(7) is very helpful :)
20:25:43 <davidL> I think there are only two people on haskell@
20:25:53 <brad_> i have been in touch with volker (the maintainer), he is cool but he is in a bind that they cannot make changes until 6.3 and 7 go out
20:26:01 <dons> volker stolz?
20:26:06 <brad_> yeah volker and oliver
20:26:12 <newsham> what about gregory wright?
20:26:17 <brad_> doesn't ring a bell
20:26:19 <allbery_b> yeh, 6.8.1 came out during the ports freeze
20:26:29 <dons> how active is volker with haskell stuff these days?
20:26:32 <brad_> it JUST missed the freeze
20:26:47 <brad_> not sure, he answers emails within 72 hours.
20:26:52 <brad_> good enough considering what i am paying
20:26:55 <dons> cool. haven't seen him on the haskell lists for a while
20:27:30 <brad_> so it seems since i have 6.6.1 on freebsd 6.3, i could use that to build 6.8.1, and then try moving that as a built package on to my new box
20:27:51 <newsham> greg is th eone who has answered my emails.  he says he's working on the 64-bit issues
20:28:06 <newsham> but I suspect he's bogged down with other things
20:28:17 <brad_> cool, i know they are on it, i have been nagging them, so at this point i don't want to bother them anymore
20:28:29 <brad_> or even my freebsd donation karam willwear out
20:28:49 <newsham> brad: can you deal with hugs until they get the port settled?
20:29:00 <brad_> probably, if hugs can build xmonad
20:29:02 <brad_> can it?
20:29:14 <newsham> hugs is an interpreter.. doubt it does xmonad
20:29:19 <goalieca> lol
20:29:22 <brad_> oh well, back to dwm!
20:29:28 <newsham> why not build xmonad on 6.2? :)
20:29:35 <brad_> i think i will do that too
20:29:48 <dons> brad_: :(
20:29:49 <soduko> @seen ddarius
20:29:49 <lambdabot> I saw ddarius leaving #haskell, #haskell-overflow and #haskell-blah 4h 31m 20s ago, and .
20:29:52 <brad_> in the worst case i just put all this in a non-standard path and blow it all away later
20:30:23 <davidL> why don't you just copy ghc binary from 6.3?
20:30:29 <brad_> oh dons i am committed to getting ghc on freebsd7 - all my "helper" programs are in haskell so the box is more or less dead to me until i do!
20:30:41 <brad_> yeah david i will try that
20:30:47 <brad_> seems like my only course now
20:31:01 <brad_> this issue will get settled at some point
20:31:05 <davidL> make package (if it's the same as openbsd)
20:31:14 <newsham> david: *nod* same target
20:31:41 <brad_> i think i will likely not go with a package, i will just get the install manifest and put it in my home dir as to not complicate the package db
20:32:19 <brad_> i don't want my own amateur-hour stuff in the package db
20:32:40 <brad_> well in any case i know more about this problem than i did before i came in
20:32:42 <newsham> the package system lets you remove packages
20:32:49 <brad_> helpful as always gents
20:33:28 <brad_> yes newsham but my OCD will likely not permit me from sullying it with my own package
20:34:10 <brad_> i will try out what was recommended to me and pop in some time, maybe on -cafe and report if it was a success
20:35:10 <brad_> take care and thanks again!
20:42:52 <kfish> sorear: ack
20:46:05 <kfish> is it correct to say that there's currently no specified serialiization for String?
20:46:47 <dmwit> String is a list of Unicode characters.
20:48:50 <sorear> kfish: serialization?
20:48:53 <sjanssen> kfish: yes, putChar and friends does not specifiy exactly what happens
20:48:57 <sorear> kfish: strings are unicode
20:49:18 <sorear> kfish: show just maps unicode into unicode - it DOES NOT involve encoding in any way
20:53:31 <kfish> my understanding (from the Haskell' notes) is that implementations handle it differently
20:54:00 <kfish> ghc, jhc and hugs implement show differently for strings
20:54:18 <kfish> afaiu all that matters is that show and read are compatible within an implementation
21:01:38 <kfish> sorear, anyway, the point you're making is that charset conversion should only happen at IO
21:02:06 <sorear> kfish: generally, it should only happen at String <-> [Word8]
21:02:17 <jeffz> hmm, anyone remember a blog or article on reddit about the number of users attracted to language being proportionate to the amount of bad software written in said language?  I'm trying to find it, I think it was posted in the last few days.
21:02:34 <sorear> kfish: huh?  show and read don't touch encodings, where'd you get an idea like that?
21:03:40 <kfish> sorear, i hadn't thought it through clearly, but in the past few minutes you've encouraged me to
21:03:48 <newsham> no char encoding in ghc.  http://hpaste.org/3908
21:04:07 <Pseudonym> That sounds like Sturgeon's Law, jeffz.
21:04:10 <newsham> basically truncates to 8bits and emits
21:04:13 <Pseudonym> Sturgeon's Revelation, rather.
21:04:34 <jeffz> Pseudonym: ah yes, thanks!
21:05:28 <dons> the more users, the more bad software?
21:05:34 <dons> or more bad software ==> more users?
21:05:49 <kfish> newsham, ah, thanks for analysing, i was wondering in what way it just dumps chars :-)
21:06:19 <allbery_b> the former is "well, *duh*"
21:06:58 <lekro> when I write code like this: http://hpaste.org/3909 , can I count on ghc to only compute "won s" once?
21:07:27 <dons> nope
21:07:30 <dons> use a 'where' clause
21:07:35 <lekro> oh :(
21:07:38 <dons> or a case
21:08:08 <Cale> GHC can almost be counted on not to do common subexpression elimination
21:08:18 <lekro> that's what I tried to avoid, because "won s" is only 5 characters. a where clause would be longer and more cumbersome to read (IMHO)
21:08:24 <Cale> There are cases where it does it, but they're rare.
21:08:39 <dons> but looks like you should use LT/GT/EQ rather than minBoudnd/maxBound/0
21:08:39 <lekro> ok, good to know that.
21:08:41 <dons> utility player s@(State p _) | won s     = if p == player then minBound else maxBound | otherwise = 0
21:09:16 <newsham> lekro:  "where won_s = won s" and "| won_s && p == .."  not that much harder to read :)
21:09:16 <dons> ?pretyy utility player s@(State p _) | won s     = if p == player then LT else GT | otherwise = EQ
21:09:17 <lambdabot>  utility player s@(State p _)
21:09:17 <lambdabot>      | won s = if p == player then LT else GT
21:09:17 <lambdabot>      | otherwise = EQ
21:09:17 <lekro> dons: I also have a heuristic function that returns smaller Int-values in a range like (-1000, 1000)
21:09:43 <newsham> premature optimization?
21:10:05 <lekro> dons: I want to use the utility value and the heuristic value in the same places
21:10:14 <Cale> How much work is in won?
21:10:16 <lekro> newsham: probably, I was just curious :)
21:10:18 <scook0> using maxBound::Int is still a little questionable, I think, but whatever
21:10:24 <dons> minBound/maxBound/0 is a strange idiom. seems fragile to use the type inhabitants like that
21:10:29 <lekro> Cale: quite a lot, compared to the other operations
21:10:30 <Cale> If it's something like a field extractor, then maybe it does get compiled away?
21:10:31 <Cale> oh
21:10:32 <Cale> okay
21:11:28 <lekro> it generates some transposed and rotated boards and then looks for consecutive lines of pieces of the same player. It might not be optimal yet
21:11:52 <lekro> scook0: what would you use instead of maxBound::Int?
21:12:30 <scook0> lekro: some kind of symbolic constant -- which might in fact be set to maxBound
21:12:48 <lekro> as I said, I also have a function heuristic :: Player -> State -> Int
21:13:39 <lekro> and the utility values must always exceed the heuristic values
21:13:55 <lekro> (except for 0, of course)
21:15:20 <lekro> oh, you're right. there might be a problem with maxBound/minBound
21:15:40 <scook0> also, you'll want to be extremely careful never to add anything to those values
21:15:42 <Cale> Don't do any arithmetic on them :)
21:15:51 <scook0> yeah
21:15:57 <lekro> I only compare them, that's all
21:16:07 <lekro> but I use alpha-beta-search and initialize alpha to minBound and beta to maxBound
21:16:59 <scook0> data Utility = Minimal | Numeric Int | Maximal deriving (Ord) perhaps?
21:17:20 <Cale> Then you can even use Integer instead of Int :)
21:17:48 <Cale> (which is a pessimisation performance wise, but easier to manage as far as correctness is concerned)
21:18:10 * wli sees if he can write a CPO-STV webapp in 41 minutes.
21:18:44 <Cale> voting system?
21:18:49 <wli> Yes.
21:19:01 <lekro> well, the heuristic never returns values significantly greater than 100 in absolute value. and the search algorithm only has (Ord a, Bounded a) in its signature, not (Num a)
21:19:41 <scook0> lekro: that's a pretty good start, capability-wise :)
21:20:00 <wli> Okay, the real trouble I'm in appears to be Meek's method.
21:20:45 <Cale> lekro: ah, all right :)
21:25:02 <wli> Okay, who understands Meek's method? (34 minutes)
21:36:43 * locomalo is away: Ausente
21:36:55 <wli> stepMeek :: Map Candidate (CandidateStatus, [(Rational, [Candidate])]) -> Map Candidate (CandidateStatus, [(Rational, [Candidate])]) looks plausible.
21:37:37 <wli> 22 minutes left. Doesn't look good.
21:40:28 <Pseudonym> Why Meek's method?
21:40:35 <Pseudonym> Why not something that's easier to understand.
21:40:46 <Pseudonym> Not that I want to distract you from coding.
21:40:50 <wli> Pseudonym: Because I can't find any documentation on Warren's method and the others are useless.
21:41:46 * Pseudonym is curious about what's wrong with Clarke's method.
21:43:00 <wli> The attempt at avoiding fractional votes spoils the method.
21:43:27 <Pseudonym> You know, it looks to me like binary tree balancing schemes.
21:43:39 <Pseudonym> AFAIK, any method is as good as any other in practice.
21:43:48 <wli> Meek is merely an extension of Senatorial rules (which in turn extends Clarke to a proper method).
21:48:55 <wli> Okay, there's no hope of getting there in 11 minutes.
21:49:39 <wli> There was a second half of the quote "As simple as possible..." that's oftn ignored.
21:49:57 <wli> "... but no simpler." When it's complicated, it's complicated.
21:50:20 <wli> Doing broken bullcrap because it's "simpler" is just broken bullcrap.
21:51:32 <Pseudonym> In voting systems, there's a huge advantage if you can explain to voters how their candidates were elected.
21:52:10 <Pseudonym> I suspect that's one of the reasons why nobody uses Condorcet.
21:52:42 <Pseudonym> IRV is technically inferior in lots of ways, but it's easy to explain.
21:53:21 <conal> anyone here have Warren Burton's "Functional Programming with Quadtrees" in digital form?
21:53:49 <wli> For single-winner IRV is worse than straight plurality in a number of respects.
21:54:12 <wli> It's a dangerous non-reform.
21:54:42 <conal> or his "Lazy Evaluation of Geometric Objects"?
21:56:48 <goalieca> @src zipwith
21:56:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:56:51 <goalieca> @src zipWith
21:56:51 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:56:51 <lambdabot> zipWith _ _      _      = []
21:57:03 <wli> There are other reasons why Condorcet isn't used. For instance, the useful properties are undesirable from the POV of someone manipulating the electoral system.
21:58:53 <wli> CSSD in particular is summable, which makes it too easily accountable relative to e.g. IRV.
22:23:36 <whoopsbob> Is there a nice recursive way of generating the permutations of a list in a lexicograiphic way? aka "abc" -> ["abc", "acb", "bac", "bca", "cab", "cba"]
22:23:54 <dons> list monad time
22:24:22 <glguy> We missed you at the FPUG
22:24:27 <dons> glguy: how'd it go?
22:24:31 <dons> i missed me too
22:24:39 <glguy> Well enough... 12 people there for opening night
22:24:42 <dons> cool
22:24:45 <glguy> I think you were signed up to talk some
22:24:45 <goalieca> heh.. i'm reading someone's dissertation on "stream processing".. making his own c-language for GPU's
22:25:01 <glguy> Are you available 2nd Monday of the month starting in December?
22:25:02 <goalieca> its basically map + fold + generating indexes
22:25:06 <goalieca> hehehe
22:25:17 <dons> > sequence ["abc","abc","abc"]
22:25:19 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
22:25:24 <dons> glguy: mondays are good
22:26:37 <dons> > filter (\x -> nub x == x) $ sequence ["abc","abc","abc"] -- cheap ;)
22:26:38 <lambdabot>  ["abc","acb","bac","bca","cab","cba"]
22:26:45 <goalieca> heh. "Variable output" is filter
22:26:57 <dons> glguy: what do we talk about?
22:27:06 <dons> can you talk about xmonad with iavor?
22:27:15 <dons> whoopsbob: how's that? ^^--
22:27:29 <dons> ?pl \x -> nub x == x
22:27:29 <lambdabot> (==) =<< nub
22:27:31 <glguy> dons: You mean can he and I discuss it at the next meeting?
22:27:33 <dons> heh
22:27:44 <dons> glguy: what's the plan for  the meetings?
22:27:57 <dons> soccer got cancelled in the end :(
22:28:06 <glguy> I think that the agenda is to be decided on the mailing list
22:28:32 <glguy> but the goal is to talk about "functional pearls" or presenting interesting solutions to problems or whatever
22:28:45 <glguy> not particularly sure, I've never been to a "user group"
22:28:52 <whoopsbob> dons: what's nub?
22:28:55 <glguy> today was general functional conversation
22:28:58 <glguy> essence of
22:30:22 <dons> ok, sounds good
22:30:28 <dons> ?docs Data.List
22:30:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:30:32 <dons> like unix 'uniq'
22:30:41 <dons> > nub "112211223344444478"
22:30:43 <lambdabot>  "123478"
22:33:46 <glguy> uniq only deals with identical lines that are adjacent though
22:39:17 <conal> hey -- i just made a "functional programming" group on citeulike: http://www.citeulike.org/groupfunc/3445 .  please join so we can more easily peruse each other's papers.
22:39:18 <lambdabot> Title: CiteULike: Group functional programming
22:51:21 <hpaste>  conal pasted "Infinite binary tree as nested type, with Functor & Applicative instances" at http://hpaste.org/3910
22:53:26 <kscaldef> glguy, dons: user group in Portland?
22:54:02 <glguy> JA
22:54:07 <glguy> s/A/a
22:54:27 <kscaldef> is there a web page or mailing list?
22:54:27 <ivanm> conal: whats the difference between Pair a a, and (a,a) ? and shouldn't you link to the actual article rather than your citation of the article?
22:55:10 <wli> glguy: ooh, when/where?
22:55:30 <glguy> next up is Dec. 10 at "cubespace"
22:55:56 <wli> time?
22:55:57 <glguy> There is a mailing list. I don't know the address yet, but elliottt does
22:56:01 <glguy> wli: evening
22:56:20 <glguy> The first meeting was tonight where it was established we should meet 2nd monday of the month
22:56:38 <glguy> at a place called cube space, because they provide free rooms and projectors and whatnot
22:56:40 <kscaldef> gotcha
22:56:47 <kscaldef> cubespace is cool
22:56:59 <kscaldef> very good people
22:57:21 <glguy> I'll make sure to advertise in channel once I ask Trevor for the address
22:57:33 <glguy> The agenda isn't set nor is the time yet
22:57:37 <kscaldef> 622 SE Grand Ave., Portland OR 97214
22:58:22 <conal> ivanm: defining Pair let me factor the instances more nicely.  it also suggests a way to make each level strict.
22:58:29 <kscaldef> or, you mean mailing list address probably... hahaa
22:58:50 <glguy> yeah. I wasn't on it, but Trevor told Iavor told me to come
22:58:57 <ivanm> conal: *nod*
22:58:58 <glguy> so now I need to sign up
22:58:58 <conal> ivanm: as for the citation, the indirection allows for group tagging etc
22:59:24 * wli will just show up
22:59:42 <glguy> OK, I'll make sure to get you the time when I know it
22:59:51 <kscaldef> I think there's a user group "social" at cubespace one of the days that week, btw.  The last email I got about it didn't sound like the date was set yet.
23:00:42 <glguy> damn, puppy is putting my leg to sleep, but sleeping so soundly ... can't very well move him
23:01:04 <ivanm> sure you can
23:01:18 <ivanm> resultant pain is a different story though ;-)
23:01:18 <glguy> he misses me, I was away on business
23:01:25 <glguy> he doesn't usually sleep like this on me
23:03:31 <glguy> told my wife that she must not love me as much as the dog does... when I got home he was jumping up and down and licking me
23:03:40 <olsner> heh, puppies are cute
23:05:08 <glguy> apparently the functional programming group was a spin-off of the ruby users group
23:05:52 <glguy> but there was a strong Haskell showing tonight
23:05:58 <kscaldef> glguy: http://groups.google.com/group/pdxfunc
23:05:58 <lambdabot> Title: pdxfunc | Google Groups
23:06:02 <wli> There was one tonight?
23:06:11 <glguy> it was the first one
23:06:24 <glguy> mostly about deciding when to have them
23:06:25 <wli> I couldn't have gone anyway. I had an electro appointment.
23:06:36 <kscaldef> yeah, me neither... working :-(
23:06:37 <glguy> the kind that makes hair disappear?
23:06:45 <wli> Yeah.
23:19:34 <vegai> Hey. Is gtk2hs gonna be Cabalized any time soon?
23:50:24 <faxathisia> hi
23:52:16 <glguy> hi
23:52:33 <faxathisia> I'm wondering.. is there any efficientish haskell minesweeper solver?
23:54:00 <faxathisia> (I thought I could maybe use it to enumerate what predecessors for a game of life configuration?)
23:55:20 <markb> hi, could someone help me with a bit of ghc setup on my mac?...darwin ports isnt playing nice for some reason and I don't know how to resolve it
23:56:10 <faxathisia> markb: you can get ghc for mac here http://www.haskell.org/ghc/download.html
23:56:36 <faxathisia> there are binaries
23:57:09 <markb> yeah i know...but i'd prefer to install it through darwin ports so i can install other stuff through there...unless you know of a way to get darwin ports to see outside the /opt/local dir
23:57:36 <faxathisia> What other stuff?
23:57:46 <markb> happy and darcs
23:57:49 <glguy> markb: what OS/arch?
23:57:59 <markb> macbook x86 leopard
23:58:30 <faxathisia> I'm not sure about happy but I know that you can get darcs without darwinports
23:58:59 <faxathisia> at any rate.. darcs won't depend on ghc.. just GMP framework
23:59:35 <markb> darcs on darwin ports installs from source so it does depend on ghc
23:59:50 <faxathisia> You can get darcs without darwinports
