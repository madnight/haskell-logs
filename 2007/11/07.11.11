00:00:15 <Cale> hello
00:00:19 <QtPlatypus> hi
00:00:55 * sjanssen wishes this code would work.  It's so *pretty*
00:02:46 <Cale> sjanssen: what kind of machine are you running?
00:02:53 <Cale> (CPU-wise)
00:03:09 <sjanssen> Cale: Intel Core Duo 1.83 GHz
00:04:29 <Cale> It's up to 10 minutes on my P4 2.4 GHz, but with far less memory usage now.
00:05:54 <Cale> Maybe I should just try running it the same way you did :)
00:07:13 <Cale> wait, how did you avoid passing -fallow-undecidable-instances?
00:08:36 <Cale> Or an -fcontext-stack parameter...
00:08:55 <sjanssen> Cale: hmm, somehow zsh cut off a few arguments
00:09:07 <sjanssen> time (echo ':t solutions (u::Cubes)' | ghci instantinsanity.lhs -fglasgow-exts -fcontext-stack=1000 -fallow-undecidable-instances)
00:09:17 <sjanssen> that's the actual command I ran
00:10:01 * thoughtpolice --sleep
00:50:08 <ari> @where lambdabot
00:50:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:56:06 <Cale> sjanssen: I'm just trying the exact code you were using (from your darcs repo), the non-tf version, and on my P4, it's spent over 18 minutes already. So there's a definite difference between a 2.4 GHz P4 and a 1.8 GHz Core 2 Duo. :)
01:56:45 <wli> Cale: What did it take on the Core2?
01:56:57 <Cale> aha, just finished after 19 mins.
01:57:12 <Cale> It took 6:28 on the Core 2
01:57:24 <sjanssen> not Core 2, Core
01:57:47 <wli> That's a large CPI improvement.
01:58:18 <sjanssen> wli: CPI?
01:58:23 <wli> Cycles Per Instruction
01:58:29 <sjanssen> ah, right
01:58:46 <sjanssen> Cale: how much RAM do you have?
01:58:54 <Cale> 1 GiB.
01:59:16 <Cale> It didn't quite fill that. Only got up around 680MiB.
01:59:27 <sjanssen> yeah, enough to avoid swap
01:59:33 <Cale> right
01:59:53 <sjanssen> I'm going to post my program on haskell-cafe, maybe somebody with more RAM can run my program :)
02:00:14 * wli has 4GB.
02:00:31 * wli runs 32-bit luserspace, though.
02:01:26 <sjanssen> wli: it may need more than that, even
02:01:36 <Cale> At some point I should really get a multicore machine. I'm too excited about concurrency for someone who doesn't own an SMP machine. :)
02:01:57 <balodja> with 4GB not only swap is unnecessary, hard drive too :)
02:02:32 * wli has 4 logical cpus (this is one of those old SMT things with 2 actual cpus and 2 threads per core).
02:02:37 <ulfdoz> Cale: For desktop, I can really recommend SMP.
02:02:59 <wli> A threaded X server would help, of course.
02:03:31 <Cale> If those people come through with their newly invented nanotech high-capacity fast flash memory, I'd be tempted to run my whole system off a USB key :)
02:03:35 <Oejet> Hi, Where can Graphics.UI.GLUT be downloaded? It does not seem to come with GHC-6.8.1.
02:03:41 <sjanssen> wli: yikes, sounds scary.  They've barely got the vanilla server stable
02:04:14 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
02:04:21 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/GLUT-2.1.1.1
02:04:23 <lambdabot> http://tinyurl.com/2aelzo
02:05:07 <wli> sjanssen: It's more to point out how far they've got to go than to suggest an immediate work-needing area.
02:06:17 <Oejet> Cale: Ah, thanks. I guess is should be installed through the package management system somehow. How come it is not included in GHC, when the main OpenGL package is?
02:06:40 <Cale> Oejet: I don't know. They've been trying to pare down the list of packages which come bundled with GHC.
02:07:42 <Cale> Oejet: If you get Cabal 1.2.1 (or HEAD), and cabal-install, you can easily install packages from the commandline, and have it take care of dependency chasing.
02:08:05 <Cale> 1.2.2.0 is broken w.r.t. cabal-install though, unfortunately.
02:08:44 <Cale> Fortunately, cabal-install will work properly if built with 1.2.1 and then 1.2.2.0 is installed after.
02:10:29 <quicksilver> Cale: hmm. I wrote som enotes about foldabe and traversable on the wiki
02:10:46 <quicksilver> Cale: I started with grand ideas but then rather lost coherency :)
02:10:59 <quicksilver> Cale: I'd be grateful if you'd take alook :)
02:11:21 <Cale> okay
02:11:34 <quicksilver> http://www.haskell.org/haskellwiki/FoldableAndTraversable
02:11:35 <lambdabot> Title: FoldableAndTraversable - HaskellWiki
02:11:54 <phlpp> hi
02:13:15 <Oejet> OpenGL-2.2.1.1>runghc Setup.hs configure
02:13:15 <Oejet> Configureing OpenGL-2.2.1.1...
02:13:15 <Oejet> Setup.hs ld is required but it could not be found.
02:13:53 <Oejet> This is on win32. :-(
02:13:58 <Cale> ...Traversable allows you to do that whilst preserving the shape...
02:14:01 <Cale> hmm
02:15:17 <Cale> oh, yes, I see.
02:16:49 <Cale> We should have laws like  head . mapM return = id
02:17:03 <quicksilver> yes
02:17:12 <quicksilver> foldMap . return = id
02:17:21 <quicksilver> if you want a return which is "compatible" with the foldable
02:18:45 <quicksilver> on the other hand, I didn't want to write an article full of algebraic laws
02:19:08 <Cale> Right, I was just trying to better understand what you meant by that comment :)
02:19:39 <doserj> quicksilver: call them quickcheck properties, not algebraic laws, and everybody is happy :)
02:20:06 <Cale> Since it sort of struck me as a strange claim at first, because you're replacing bits of that data structure with computational structure, and it's not at first clear that you can get back.
02:20:18 * quicksilver nods
02:22:25 <Cale> There's an analogue of sorts for concatMap for any Monad, of course ;) Though, perhaps not in as strong a sense as you mean it.
02:22:44 <sjanssen> Functor is transformation, Foldable is summarization, Traversable is transformation and summarization simultaneously
02:22:59 <ac> so, I'm going to ask the obvious question: where does the IO monad go?
02:23:07 <Cale> ac: Where does it go?
02:23:15 <Cale> It goes in the Prelude?
02:23:20 <Cale> um...
02:23:26 <sjanssen> to the market?
02:23:28 <sjanssen> all the way home?
02:23:32 <Cale> I don't know what you mean by the question :)
02:23:36 <ac> should not "(head . mapM return $ [1,2,3]" return "IO 1"?
02:23:49 <Cale> :t head . mapM return $ [1,2,3]
02:23:51 <lambdabot> forall a. (Num a) => [a]
02:24:10 <Cale> that's got to be using the list monad :)
02:24:15 <Cale> :t mapM return $ [1,2,3]
02:24:17 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => m [a]
02:24:21 <sjanssen> ac: change that to "fmap head $ mapM return $ [1, 2, 3]"
02:24:34 <Cale> Since you take the head of it, m is coerced to being []
02:24:44 <ac> :t return
02:24:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:24:59 <ac> that's my misunderstanding. I thought return was specific to the IO monad for some reason
02:25:03 <ac> because that's the only place I've used it so far
02:25:08 <Cale> sjanssen: surely you mean "fmap head . mapM return $ [1, 2, 3]"
02:25:10 <Cale> ;)
02:25:17 <Cale> ac: ah, okay
02:25:36 <Cale> ac: yeah, return is one of the two bits of the definition of a monad.
02:25:36 <ac> so I guess it wasn't an obvious question at all
02:25:48 <Cale> The other one is >>=
02:26:10 <Cale> (or join together with fmap)
02:26:19 <ac> I haven't bothered to read any monad tutorials, but I figure it'll just come to me if I write Haskell enough
02:26:29 <Cale> That's actually probably true :)
02:26:44 <Cale> If you understand the IO monad well enough, anyway.
02:26:44 <ac> (and ask annoying questions on #haskell ;)
02:26:56 <Cale> Yeah, I'd be happy to give you a tutorial at some point.
02:27:23 <Cale> (or just link you to one or three, if you'd prefer)
02:27:39 <ac> not at the moment
02:28:02 <ac> for the time being I'll entertain myself with other features
02:30:13 <user317> is there anyway to get a stacktrace from an exception?
02:35:29 <Heffalump> user317: no :-(
02:35:41 <Heffalump> with ghci 6.8.1, you can get some history
02:35:49 <Heffalump> which is often useful enough
02:36:05 <user317> how do i get some history with 6.8.1?
02:36:52 <user317> does loch handle array bound errors?
02:37:31 <Heffalump> loch?
02:37:46 <Heffalump> run ghci with -fbreak-on-exception
02:38:04 <Heffalump> then :trace <expression that ends up throwing>
02:38:13 <Heffalump> then :history when it does throw (or something like that)
02:41:49 <user317> cool, thanks
02:48:31 <pjd> user317: stacktraces, being a list of things to do next, are a bit dependent on strict evaluation
02:52:51 <Cale> There is a way to get a cost-centre trace
02:53:05 <Cale> Which is sometimes useful, sometimes completely useless.
02:53:14 <Cale> But it's usually worth a shot if you have no idea.
02:53:29 <Cale> Compile with -prof -auto-all, and run the program with +RTS -xc
02:53:54 <Cale> When the exception occurs, you'll get a list of the cost centres which led up to the exception.
03:35:12 <takamura> hey
03:35:19 <ikegami--> hello
03:40:54 <DRMacIver> You'd think I'd have learned by now not to argue about programming languages on the internet. :)
03:40:57 <DRMacIver> Sigh
03:42:56 <ac> DRMacIver: who were you stiring up an argument with?
03:43:11 <DRMacIver> ac: Jon Harrop on the JVM-languages group.
03:43:22 <DRMacIver> Discussing multiple dispatch vs. pattern matching.
03:44:04 <ac> huh.
03:44:07 * ac does not like multiple dispatch
03:44:12 <DRMacIver> Why not?
03:44:22 * ac does not have any reason ;)
03:44:31 <DRMacIver> Oh good. That way I don't have to argue with it. ;)
03:44:44 <ac> frankly it's probably because I've never used it
03:44:51 <wli> DRMacIver: Ever seen what's possible to do with variants and structural subtyping?
03:45:05 <DRMacIver> wli: Mostly in this argument, yes. :)
03:45:35 <DRMacIver> (Although isn't what you do with variants the dual of structural subtyping?)
03:45:46 <ac> DRMacIver: and the languages that have multiple dispatch haven't been attractive enough for me to learn them
03:46:01 <ac> er, I mean the languages where it's used typically
03:46:02 <wli> DRMacIver: case ... of Con1 ... -> ... ; Con2 ... -> ... ; ... yields a constraint that the type have at least the constructors Con1, Con2, ..., ConN
03:46:17 <DRMacIver> ac: Don't like lisp? :)
03:46:22 <ac> DRMacIver: I learned Scheme instead
03:46:37 <DRMacIver> ac: A bunch of schemes have multiple dispatch object systems.
03:46:46 <DRMacIver> Although I admit I've not used any of them. :)
03:46:46 <ac> DRMacIver: I never bothered to use the object systems
03:46:50 <ac> heh
03:46:58 * DRMacIver doesn't do much scheme.
03:47:13 <wli> DRMacIver: Sorry, that the type have *at most* the constructors Con1, Con2, ..., ConN. So you basically get the stuff about making sure pattern matches always succeed in the type system.
03:47:31 <DRMacIver> Anyway, my argument isn't "pattern matching sucks!" or "multiple dispatch rules!".
03:47:35 <DRMacIver> wli: That's quite nice.
03:48:00 <DRMacIver> My argument is more "multiple dispatch has some nice features you're overlooking".
03:48:13 <ac> DRMacIver: whenever I read about languages with fancy dispatch, it just makes me wince, because I don't really like OO all that much to begin with
03:48:28 <wli> DRMacIver: Anyway, there's stuff it does with records, too, but I say screw what it does with records. Structural subtyping on variants rules.
03:48:35 <DRMacIver> Unfortunately Jon Harrop seems much more interested in arguing that OCaml is the bestest language ever. One might suspect he had some vested interest in the subject. :)
03:48:37 <ac> perhaps I'm wrong in thinking that MD is connected with OO
03:48:54 <DRMacIver> It's objects, ac, but not as we know it.
03:49:20 <ac> I'm definitely not familiar with the state of the art in OO programming
03:49:25 <DRMacIver> e.g. the language I'm using (Nice) is much closer to an ML variant with bad syntax than anything very OO.
03:49:38 <DRMacIver> (And it really does have bad syntax. :-/ )
03:50:11 <ac> Isn't bad syntax a good indicator of a sloppy implementation?
03:50:20 <DRMacIver> No. It's a good indicator of stupid politics.
03:50:27 <DRMacIver> The syntax is bad because it's designed to look like Java.
03:50:49 <DRMacIver> The fact that the compiler is awful is a good indication of sloppy implementation though. :)
03:51:15 <ac> I didn't really mean "implementation" that was stupid
03:51:32 <ac> I meant, if the syntax is bad, it means whoever designed the language didn't put enough thought in to all the details
03:51:45 <ac> which doesn't say anything about the implementation
03:51:56 <wli> DRMacIver: Also, structural subtyping on variants gives you a totally natural thing where one type has more cases/constructors than another and things that work on a larger number of cases/constructors work "just fine" on types with fewer of them, which is fantastic.
03:52:27 <DRMacIver> ac: Right. But what I mean is that the "detail" that thought was put into was "How can we con people into thinking this language is Java-like"
03:53:04 <ac> DRMacIver: yeah, I wasn't thinking about that phenomenon when I said that. That is a very unfortunate practice
03:53:24 <DRMacIver> wli: Sure. I'm convinced that it's nice. :)
03:53:43 <DRMacIver> ac: I looked into adding an alternative syntax to Nice a while ago, but couldn't make sense of the compiler.
03:54:17 * ac looks forward to the day when syntax is an implementation detail. (is that silly?)
03:54:36 <wli> http://holomorphy.com/~wli/polylambda.pdf <-- slightly more about subtyping with higher-order polymorphism
03:54:58 <wli> From back when the SEL-HPC archive was still around.
03:54:58 <DRMacIver> ac: Well, wasn't that the original idea behind lispy syntax?
03:55:35 <DRMacIver> Anyway, I've got to go. There's exciting shopping to be done. :-/
03:55:53 <ac> DRMacIver: Yeah, in my mind, it would be nice if any language could have lisp syntax slapped on it. That's not because I like S-expressions so much... I wouldn't actually do that. I'm just saying it would be nice to have the easy capability of doing that
03:56:08 * wli wishes more people were excited about structural subtyping.
03:56:29 <wli> (It's a very different phenomenon from OO subtyping.)
03:56:44 <ac> wli: perhaps I'd be excited about it if I understood what it was
03:56:47 <hpaste>  Reqamst pasted "(no title)" at http://hpaste.org/3805
03:56:59 <wli> ac: There are two basic rules for it.
03:57:41 <reqamst> I have a little problem. I wanted to write simple implementation of Euclidean algorithm, so I've written two functions - gcd2 (works fine) and lct (doesn't work and I don't know why) Can you help me? Here is source: http://hpaste.org/3805
03:57:44 <wli> ac: One for variants, one for records.
03:59:35 <scook0> reqamst: I'm pretty sure that return is unnecessary
03:59:48 <wli> ac: One type t is a subtype of another t' if t can be used anywhere t' is used.
04:00:19 <ac> I can see how that applies to records of course
04:00:22 <wli> ac: For variants this is when there are fewer constructors, and records this is where t has a superset of the fields of t'.
04:00:29 <scook0> reqamst: what's the actual problem? does it fail to compile, or produce the wrong behaviour?
04:00:53 <ac> I'm not immediately understanding the rule for variants though
04:01:22 <wli> ac: data T1 t1 t2 = JustLeft t1 | JustRight t2 ; data T2 extends T1 with Nothing2
04:01:26 <reqamst> scook0: lct2 doesn't compile
04:01:42 <wli> ac: T1 is a subtype of T2
04:01:48 <scook0> reqamst: is that / supposed to be integer-division, or proper division?
04:02:04 <ac> ok. that's also simple enouh
04:02:16 <ac> nothing to be excited about, right? ;)
04:02:34 <wli> ac: And *extremely* useful. You can express restriction to a subset of constructors here where normally you can't.
04:03:10 <ac> yeah I have no doubt it's useful
04:03:35 <reqamst> scook0: i don't know what is exactly 'proper division'?
04:03:52 <scook0> > 3 / 4
04:03:57 <ac> it provides a natural mechanism for java-class-style inheritance I would think
04:03:58 <lambdabot>  0.75
04:04:04 <scook0> > 3 `div` 4
04:04:05 <lambdabot>  0
04:05:32 <scook0> reqamst: I think it's supposed to be integer division
04:05:34 <reqamst> scook0: that's supposed to be integer-division
04:05:44 <scook0> in which case (/) is not what you're after
04:06:00 <scook0> you want div or quot
04:06:02 <wli> ac: T2 is Nothing2 | JustLeft t1 | JustRight t2 so you get 3 cases. You can do a sort of "catMaybes2" with, say, catMaybes2 (Nothing2 : xs) = catMaybes2 xs ; catMaybes2 (JustLeft x : xs) = JustLeft x : catMaybes2 xs ; catMaybes2 (JustRight x : xs) = JustRight x : catMaybes2 xs ; catMaybes2 [] = []  and the type system actually understands that the elimination of the Nothing2 case there has "narrowed" the result from T2 to T1.
04:07:28 <wli> ac: There are a lot of times where enforcing invariants involves eliminating the use of one of several constructors and there's no way to express it in the current type system. With this subtyping you can actually get the compiler to see it and enforce it.
04:07:44 <reqamst> scook0: i currently understand, thanks a lot
04:08:16 <hpaste>  scook0 annotated "(no title)" with "two fixes: lose the return, and use integer division" at http://hpaste.org/3805#a1
04:09:28 <scook0> reqamst: return in Haskell doesn't mean the same thing as return in other languages
04:09:40 <scook0> you shouldn't need to use it unless you're working with monads
04:09:41 <Cale> You can say that again ;)
04:10:06 <ac> what's "catMaybes2"?
04:10:10 <Cale> Loosely, return constructs a computation which does nothing but return the value that it's given.
04:10:28 <scook0> ac: context?
04:10:28 <Cale> That means different things in different monads.
04:10:33 <wli> ac: An example of where you narrow the type.
04:10:45 <scook0> oh, never mind
04:11:00 <reqamst> scook0: your code return wrong result
04:11:04 <wli> ac: Basically you're eliminating the use of the Nothing2 constructor and narrowing the type from [T2] to [T1]
04:11:17 <wli> ac: catMaybes2 :: [T2] -> [T1]
04:11:26 * ac probably needs a personal example (anotherwords want to write something that would benifit from this) in order to understand the benifits of that completely
04:11:29 <Cale> How about 'head', can it deal with that?
04:11:55 <Cale> Or is it only the other sort of variance?
04:12:05 <ac> s/anotherwords/in other words/ :P
04:12:18 <ac> why do I make so many phonetic typos?
04:12:33 <hpaste>  Reqamst annotated "(no title)" with "That source returns correct result" at http://hpaste.org/3805#a2
04:12:33 <wli> ac: You can express a constraint that a list be infinite by virtue of only ever using the (:) constructor.
04:13:06 <ac> wli: while also having it be a subtype of a list?
04:13:15 <wli> ac: Precisely.
04:13:15 <scook0> reqamst: that'll teach me to try to be clever with div/quot :(
04:13:29 <Cale> Oh, I suppose you can't quite express the precondition for head using that :)
04:13:30 <ac> wli: that is interesting
04:13:41 <wli> Cale: Sadly, no.'
04:13:55 * ac is not quite excited yet, but is getting there
04:14:15 <Cale> How's the type inference?
04:14:34 <Cale> Is there at least reasonable partial type inference, or does it completely break?
04:14:39 <scook0> reqamst: what wrong answers does quot give?
04:14:49 <Cale> quot is usually not what you want
04:14:56 <Cale> div/mod are the sane ones.
04:15:16 <wli> Cale: Decidable for H-M without typeclasses. No clue about how it mixes with typeclasses. I think Philippa and others more knowledgeable wrt. type systems have far better knowledge here.
04:15:38 <Cale> Oh, that really is interesting then.
04:15:41 <wli> Cale: Dilip Siquiera's thesis (which I've got floating around) shows how to add it to stock ML.
04:15:57 <wli> Cale: The types look crazy though.
04:16:01 <Cale> ah
04:16:05 <reqamst> scook0: my wrong, quot works fine too
04:16:17 <scook0> heh
04:16:43 <Cale> Is it decidable in a reasonable way too? (Like it doesn't randomly cause reasonably ordinary looking programs to take ages to compile)
04:16:44 <reqamst> > quot (48*32) (gcd 48 32)
04:16:46 <lambdabot>  96
04:16:58 <reqamst> > div (48*32) (gcd 48 32)
04:17:00 <lambdabot>  96
04:17:17 <Cale> If you're only working with positive numbers then quot and div are the same
04:17:32 <Cale> It's the negative cases that they handle differently.
04:17:57 <reqamst> For example?
04:18:19 <scook0> > (quot (-4) 3, div (-4) 3)
04:18:21 <lambdabot>  (-1,-2)
04:18:35 <scook0> quot truncates towards 0; div truncates towards -Inf
04:18:37 <Cale> > ((-2) `div` 5, (-2) `quot` 5)
04:18:38 <lambdabot>  (-1,0)
04:18:57 <Cale> yep
04:19:40 <Cale> Which means that div is always truncating in the same direction, which makes mod behave more regularly relative to rem.
04:19:58 <Cale> quot/rem are easier to implement in hardware apparently though.
04:20:09 <pjd> what are quot/rem actually useful for?
04:20:24 <scook0> creating bugs!
04:20:28 <Cale> They're useful because if your machine has integer division, it probably does that.
04:20:35 <RayNbow> @src product
04:20:35 <lambdabot> product = foldl (*) 1
04:21:11 <Cale> So they were included in the standard so that something would be there to hook the machine semantics up to.
04:21:21 <Cale> (at least, as far as I understand it)
04:21:32 <scook0> so I suppose if you were doing tight inner loops on positive arguments, quot is potentially a hair faster
04:22:00 <scook0> though if you care that much, your inner loop's probably in C
04:22:29 <Cale> Yes, though GHC is emitting better and better code these days.
04:23:50 <scook0> I still have a tendency to subconsciously think of Haskell as slow
04:26:43 <stulli> How do i get user input as integer? I know about a <- getLine, is there something similar for integers? Apparently im new to Haskell ;)
04:26:54 <Heffalump> stulli: call read on the result of getLine
04:27:13 <wli> Why? Just call readLn
04:27:21 <Heffalump> oh, duh :-)
04:27:31 <stulli> readLn doesnt work for me
04:27:44 <stulli> i get a error then
04:27:59 <Heffalump> about an ambiguous type?
04:28:20 <wli> > :t do { x <- readLn ; print (x + 1 :: Integer) }
04:28:20 <lambdabot>  Parse error at "do" (column 4)
04:29:00 <Cale> :t do { x <- readLn ; print (x + 1) }
04:29:01 <stulli> ill try again, thanks. the error was sthg about parsing, dont remember anymore
04:29:09 <lambdabot> IO ()
04:29:15 <ac> stulli: read or readLn can produce practically any type, so you have to be specific about what kind of read you want
04:29:35 <ac> unless it's obvious from the context
04:29:39 <reqamst> wli: why did you use ":: Integer"? It works without it.
04:29:50 <Cale> Often it will get defaulted to Integer, if you use numeric stuff on the result.
04:30:05 <Cale> But it is good to be careful in situations like that.
04:30:30 <ac> actually, would it default to integer regardless of the situation?
04:30:56 <scook0> > read "3"
04:30:58 <lambdabot>  3
04:31:10 <scook0> actually, that doesn't prove anything
04:31:15 <wli> let action = do { putStr "Enter an integer: " ; s <- getLine ; case reads s of { [(x, _)] -> print (x + 1 :: Integer) ; _ -> do { putStrLn "Parse error." ; action } } } in action
04:31:25 <pjd> ac: depends on -fno-monomorphism-restriction ?
04:31:27 <scook0> because \b probably has aggressive defaulting
04:31:34 <Cale> scook0: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=gcc&lang2=ghc -- compared to C, we're averaging maybe 4-5x slower, and are occasionally faster (GHC's concurrency support is really good). That's 6.6.1 too, 6.8.1 is ~15% faster on average.
04:31:36 <lambdabot> Title: C gcc benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language B ..., http://tinyurl.com/2eybmm
04:32:03 <stulli> readLn works for me now, i must have made another mistake before. Thanks again!
04:32:31 <pjd> Cale: do the Haskell shootouts still come with provisos?
04:32:38 <Cale> (well, I don't think those benchmarks have been run on them yet)
04:32:50 <Cale> (er, on 6.8.1 yet, I should say)
04:33:01 <Cale> pjd: sure :)
04:33:16 <scook0> Cale: yeah, it's pretty good
04:33:16 <Cale> pjd: In fact, I don't really like a lot of the things about the shootout's methodology.
04:33:26 <Cale> There are often arbitrary seeming restrictions.
04:33:40 <Cale> For example, we're not allowed to use UArray of Bool
04:33:45 <pjd> yeah
04:33:50 <Cale> Simply because its internal implementation is too good.
04:34:00 <pjd> what on earth is the point of that?
04:34:16 <Cale> Being "fair" to the other lanugages, or something.
04:34:32 <scook0> which benchmark has that restriction?
04:34:41 <Cale> Also, there's a lot of cases where the problem is stupid but carefully worded such that laziness can't be used.
04:35:10 <Cale> and in the cases where laziness would take effect, we'd kill everything else.
04:35:35 <Cale> I forget which one it was.
04:35:41 <scook0> to some extent I respect the need to eliminate laziness in synthetic benchmarks
04:36:12 <olsner> since it's a language shootout, it should only limit what's written in the code and never what the compiler makes of it
04:36:15 <scook0> because the idea is to find out how efficiently your implementation could do an equivalent amount of real work
04:36:55 <Cale> Yes, but they should just set the task initially so that it's a nonstupid piece of real work.
04:37:22 <kfish> or perhaps it should measure compile time too :-)
04:37:37 <Cale> and not require the generation of seemingly unimportant intermediate results which don't affect the output
04:38:22 <scook0> well, I'm only defending the principle of synthetic benchmarks -- I have no idea whether the shootout tasks are actually fair
04:41:01 * DRMacIver returns
04:42:05 <DRMacIver> ac: What I meant was that I was under the impression that lisp syntax was originally with the intention of "We'll come up with something to compile to this later" before people realised they actually liked S-expressions. :)
04:42:48 <scook0> that is my understanding
04:42:53 <Cale> As cool as S-expressions are, I kind of wish they found something to compile to it.
04:42:56 <DRMacIver> ac: In principle I agree though. It would be nice if more languages had a relatively clean abstract syntax tree representation and a pluggable compiler.
04:43:01 <DRMacIver> Cale: Well, Dylan did.
04:43:05 <DRMacIver> More or less
04:43:05 <olsner> iirc, they had M-expressions that looked more algol:y
04:43:08 <DRMacIver> And it kinda failed. :)
04:43:11 <Cale> Yeah, I suppose.
04:43:48 <Cale> Also, Lisp 2 seems to suck way more than Lisp 1. I wonder why that is.
04:43:57 <scook0> though the advantage of programming directly in sexps is that you don't really need to look up the AST docs when metaprogramming
04:44:02 <scook0> c.f. Template Haskell
04:44:09 <Orphi> can anybody explain to me what a "dependent type" actually is?
04:44:59 <ac> DRMacIver: yeah exactly
04:44:59 <Cale> Orphi: The idea is that the type of something is dependent on its value.
04:45:02 <ac> DRMacIver: that's what I was wishing for
04:45:07 <Cale> or the value of something else
04:45:22 <Cale> er, right, the latter, sorry
04:45:39 <Cale> For example, the type of lists of length exactly n
04:45:43 <Cale> depends on the value n
04:45:53 <olsner> C++ has had dependent types since '98 ;-)
04:45:57 <Orphi> Cale: ... so each length of list would have a different type?
04:46:17 <Cale> Orphi: well, if you wanted.
04:46:35 <Orphi> Cale: OK, so each length of list *could* have a different type? ;-)
04:46:36 <Cale> Orphi: of course dependently typed languages still allow for lists of arbitrary length to form a type
04:46:42 <DRMacIver> olsner: Types which are dependent on being insane? ;)
04:46:47 <Cale> and you can write things like
04:46:58 <Cale> concat :: List n a -> List m a -> List (n+m) a
04:47:16 <Orphi> Cale: mmm, has anybody ever actually implemented that yet?
04:47:30 <Orphi> I mean, without using strange encodings.
04:47:35 <Cale> er, that probably should be called (++) and not concat, but what the hell.
04:47:38 * wli points to Cayenne.
04:47:39 <Cale> Yes
04:47:50 <Cale> Cayenne, Epigram, and several others
04:47:57 <matthew-_> agda
04:48:06 * wli needs to work on learning Cayenne.
04:48:10 <Cale> Coq, probably, though I don't really know much about those systems.
04:48:13 <DRMacIver> I still don't know why Cayenne fails to compile on any computer I've so much as looked at. :)
04:48:14 <byorgey> Omega
04:48:20 <schemelab> would you say that in lambda calculus, the function corresponds to an English verb?
04:48:39 <Cale> schemelab: It's also the English noun, in the pure lambda calculus
04:48:53 <Cale> schemelab: Since lambda terms are all that you have.
04:49:00 <byorgey> and preposition, and interjection, and...
04:49:08 <scook0> I'm not sure it's a very useful metaphor
04:49:13 <DRMacIver> So basically the lambda calculus is a demonstration that verbing weirds language? :)
04:49:17 <Orphi> OK, so now what's an associated type?
04:49:23 <Orphi> I thought I knew, but apparently I was wrong...
04:49:25 <byorgey> hehe
04:49:29 <schemelab> oh, so lambda calculus is not really about doing
04:49:30 <Cale> Orphi: A type which is associated with a type class.
04:49:42 <byorgey> @remember DRMacIver So basically the lambda calculus is a demonstration that verbing weirds language? :)
04:49:42 <lambdabot> It is stored.
04:49:43 <Cale> schemelab: and lambda terms aren't *really* functions
04:49:56 <Cale> schemelab: at least not in the proper mathematical sense
04:49:59 <Orphi> Cale: right... so, like, "this container can only contain THIS type"?
04:50:06 <Cale> Orphi: yeah
04:50:25 <Orphi> Cale: have ATs been implemented in Haskell yet?
04:50:27 <Cale> Orphi: which can be specified on a per-instance basis
04:50:40 <Cale> Orphi: yeah, in new GHC's I'm fairly sure.
04:50:50 <Orphi> Cale: I'll check the release notes.
04:50:53 <Cale> Actually, I haven't had a chance to try them yet.
04:50:54 <olsner> Cale: how are lambda terms different from mathematical functions?
04:50:57 <scook0> I think 6.8.1's ATs are still considered somewhat experimental
04:51:08 <scook0> olsner: partiality, perhaps?
04:51:10 <Cale> olsner: A mathematical function is a set of pairs, essentially.
04:51:17 <Orphi> Cale: so I can say "hey, this class represents a container, and THIS container can hold anything, but THAT container only holds X"...?
04:51:30 <Cale> olsner: It's not a rule for saying how to calculate one thing given another
04:51:38 <schemelab> I think there were 15 Haskell entries in the last ICFP --- that's pretty good for a coding language that never made it :)  I dont really like that word coding - http://programming.reddit.com/info/60a7s/comments/
04:51:40 <lambdabot> Title: programming: 12 Coding Languages That Never Took Off
04:52:23 <scook0> "coding language" sounds like something that stuff gets encoded into
04:52:32 <olsner> Cale: but aren't the rules for calculating things equivalent to such a set of pairs?
04:52:43 <Cale> If X and Y are sets, then a function f: X -> Y is a set of pairs (x,y) with x in X and y in Y, such that for each x in X, there is exactly one y in Y for which (x,y) is in f
04:52:53 <Cale> olsner: Not once infinities become involved.
04:53:21 <grimps> hello everyone!!! How are you all doing?
04:53:28 <Cale> olsner: There are more functions from the naturals to the naturals than there are descriptions of functions from the naturals to the naturals.
04:53:36 <Orphi> gimps: insane :-)
04:53:42 <Cale> olsner: Or, say
04:53:47 <Cale> from the Naturals to {0,1}
04:53:57 <Cale> (infinite binary strings)
04:54:00 <grimps> same here even I am insane
04:54:04 <pjd> schemelab: look at the other articles on that site
04:54:11 <grimps> this haskell language has sucked all my blood
04:54:20 <Orphi> it says "Haskell" on the door - we're all mad! :-D
04:54:29 <schemelab> pjd - what is your point?
04:54:34 <olsner> Cale: but couldn't a description of a function consist of an enumeration of all the pairs?
04:54:38 <Cale> Because every description of a function from N -> {0,1} is written down with a finite (or countable) alphabet, and with finitely many symbols
04:54:41 <grimps> URGENT MATTER: Can anyone help me with haskell language... I am stuck with a problem since many hours... I cant understand it inspite of trying to learn the language from tutorials
04:54:52 <Cale> But there are *uncountably* many functions N -> {0,1}
04:54:57 <Botje> grimps: sure, what's up?
04:55:02 <Cale> (same as the real numbers)
04:55:04 <schemelab> paste?
04:55:13 <schemelab> paste.lisp.org/new/haskell
04:55:17 <scook0> @paste
04:55:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:55:24 <Cale> hpaste is nicer :)
04:55:27 <grimps> What does this function mean?
04:55:34 <grimps>   solarSpeed :: Power -> Speed
04:55:45 <grimps>   solarSpeed s
04:55:52 <grimps>     = root 0 (\v -> powerUse v - s) (0,40)
04:56:02 <Cale> grimps: That's the type declaration for a function called solarSpeed which takes a value of type Power and gives a value of type Speed.
04:56:09 <Cale> oh, followed by a definition :)
04:56:20 <grimps> I understood the first two statements
04:56:35 <Orphi> Cale: GHC 6.8.1 contained "experimental" "unsupported" ATs
04:56:36 <Cale> It says that the solarSpeed given a value s :: Power is
04:56:39 <grimps> but I cannot understand the last one which is.............   = root 0 (\v -> powerUse v - s) (0,40)
04:56:43 <scook0> hard to say what it does without knowing what root and powerUse do
04:57:02 <grimps> I have figured out what powerUse does....
04:57:02 <scook0> unless you're looking for an explanation of the syntax
04:57:09 <Cale> root of 0 and (the function which takes a parameter v, and returns powerUse v - s), and the pair (0,40)
04:57:13 <grimps> But do not know what root 0 does?
04:57:31 <Cale> I don't know what root does, but maybe it's something like Newton's method?
04:57:42 <olsner> Cale: "... and with finitely many symbols"? what's wrong with infinite descriptions of functions?
04:57:51 <grimps> Cale, can you make that explanation a bit simpler... I wasn ot able to follow you...
04:58:13 <grimps> what does \v mean?
04:58:13 <Cale> olsner: Well, you run out of paper.
04:58:22 <Cale> \x -> x+1
04:58:28 <Cale> is the function which adds 1 to its argument
04:58:32 <Cale> > (\x -> x+1) 5
04:58:33 <lambdabot>  6
04:58:39 <reqamst> What is faster: map (+1) [1..10] or map (\x -> x+1) [1..10]? CPU makes that same work in both cases?
04:58:47 <Cale> reqamst: they're the same
04:59:04 <scook0> grimps: it allows you to define functions without giving them a name
04:59:20 <Cale> > (\x -> x^2 + x + 1) 10
04:59:21 <lambdabot>  111
04:59:32 <olsner> but math's full of other stuff that won't fit on a finite amount of paper but still exists ;-)
04:59:33 <Cale> > let f x = x^2 + x + 1 in f 10
04:59:35 <lambdabot>  111
04:59:59 <Cale> olsner: right, but the proof showing that it exists in the system consists of finitely many symols
05:00:03 <Cale> symbols*
05:00:16 <Cale> In mathematics we typically require proofs to be finitely long.
05:00:16 <grimps> are you guys there?
05:00:29 <Cale> grimps: yes, I was talking to you there, and then to olsner
05:00:52 <Jiten> grimps: (\v -> v+1) would be a function that takes one paramter (v) and returns v+1
05:01:42 <Cale> grimps: Make sure to stick around if you're learning Haskell. :)
05:02:25 <Cale> grimps: are *you* still there?
05:02:43 <Cale> hmm, no ping reply
05:02:44 <LoganCapaldo> gimps has always been there
05:02:48 <gramplex> Hi Guys! I am back, I think I got disconnected
05:02:52 <Cale> ah, okay
05:02:56 <LoganCapaldo> lurking in the shadows
05:02:57 <Cale> <grimps> are you guys there?
05:03:05 <Cale> we responded, but you didn't :)
05:03:21 <Jiten> solarSpeed s = root 0 abcdef (0,40) where abcdef v = powerUse v - s
05:03:32 <Cale> grimps: (\x -> x + 1) is the function which takes a parameter x, and gives x + 1 as its result
05:03:36 <fasta> If I have the monad transformer stack StateT (ContT(StateT and I want to access the outer StateT, I can just use get, for the inner StateT, I need to do (lift.lift) get, right?
05:03:45 <gramplex> gramplex = grimps
05:03:47 <Cale> fasta: yes
05:03:49 <yitz> grimps: The \ looks (a little bit) like the greek letter lambda, which is a traditional symbol for "define function".
05:03:51 <Jiten> I think this function I just specified does the same as the original
05:04:01 <Cale> gramplex: right :)
05:04:23 <LoganCapaldo> fasta: that looks scary
05:04:33 <Jiten> ... or then I forgot a couple of parentheses
05:04:56 <gramplex> oh okay... so \ means that you are defining a function but without any name
05:05:07 <Cale> right
05:05:09 <Jiten> yes
05:05:18 <gramplex> ok I understood the x + 1 part
05:05:25 <gramplex> now coming back to the problem     = root 0 (\v -> powerUse v - s) (0,40)
05:05:35 <Cale> Functions are just values in Haskell, so you should be able to write them without giving them names :)
05:05:40 <gramplex> Hi Jiten!... thanks for your explanation, but I still could not understand it
05:05:45 <olsner> three nested monad transformers? looks like a case of hypermonadism!
05:05:48 <gramplex> okay!
05:05:54 <Cale> (\v -> powerUse v - s)
05:06:00 <LoganCapaldo> @unmtl StateT s1 (ContT (StateT s2 Identity))
05:06:00 <lambdabot> err: Unknown MTL(1)
05:06:06 <Cale> this is the function which takes v and gives powerUse v - s
05:06:06 <Jiten> gramplex: do you have root and powerUse definitions somewhere?
05:06:13 <Cale> @paste
05:06:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:06:19 <LoganCapaldo> @help unmtl
05:06:20 <lambdabot> unroll mtl monads
05:06:23 <Cale> It would help to paste all the code on that pastebin :)
05:06:26 <gramplex> so we are taking a value v and giving out the output of powerUse v subtract s?
05:06:30 <Cale> right
05:06:31 <yitz> olsner: oh, I'd say three is quite conservative.
05:06:31 <LoganCapaldo> @unmtl ContT State
05:06:31 <lambdabot> ContT State
05:06:48 <Cale> gramplex: that function is being passed as the second parameter to root
05:06:50 <LoganCapaldo> @unmtl State
05:06:50 <lambdabot> err: No applications
05:06:53 <gramplex> I have powerUse function details but not root, I think root is an inbuilt function of Haskell
05:06:54 <LoganCapaldo> @unmtl State Int
05:06:55 <lambdabot> State Int
05:06:58 <Cale> gramplex: It's not.
05:06:59 <LoganCapaldo> @unmtl State Int a
05:06:59 <lambdabot> Int -> (a, Int)
05:07:09 <olsner> yitz: three's plenty for me :P
05:07:10 <Cale> gramplex: However, it might be part of some library which you're using.
05:07:24 <Cale> gramplex: Do you know what it does?
05:07:24 <LoganCapaldo> @unmtl StateT Double (ContT (StateT Int Identity)) a
05:07:24 <lambdabot> err: Unknown MTL(1)
05:07:44 <Cale> I can sort of guess at it, but I may be completely wrong
05:07:46 <reqamst> Can I use unicode symbols in haskell like here: http://tnij.org/agna ? It would be cool using λ instead of \.
05:07:54 <lambdabot> Title: Fun with Unicode - O&#039;Reilly Ruby
05:07:58 <LoganCapaldo> @unmtl StateT Double (ContT State Int) a
05:07:59 <lambdabot> Double -> (a -> Double -> Int State) -> Int State
05:08:02 <hpaste>  gramplex pasted "solar power thing" at http://hpaste.org/3806
05:08:11 <Cale> reqamst: there's limited support for it, but I don't think you can use λ for \
05:08:21 <LoganCapaldo> @unmtl StateT Double (ContT (State Int)) a
05:08:21 <lambdabot> err: Unknown MTL(1)
05:08:26 <Cale> gramplex: okay
05:08:28 <LoganCapaldo> I suck! :)
05:08:44 <byorgey> reqamst: I think you can have identifier names that involve unicode, but you can't arbitrarily replace parts of the built-in syntax such as \.
05:08:49 <Cale> gramplex: I kind of think that root is probably an implementation of a root-finding algorithm
05:08:56 <byorgey> reqamst: but that would be pretty cool =)
05:09:22 <scook0> I swear there's an implementation that lets you use unicode lambdas, arrows etc.
05:09:27 <scook0> but I can't remember which one it is
05:09:41 <byorgey> reqamst: lhs2tex can format literate Haskell like that, though
05:09:43 <Cale> gramplex: however, that function is kind of a silly function to be passing to a root finding algorithm, to be honest
05:10:06 <Cale> hmmm...
05:10:08 <gramplex> Cale: But I can't find anything like a root function in the script. The lhs file is too long and do you want me to paste it on that hpaste site?
05:10:33 <gramplex> Cale: I have got some clarity now in understand it
05:10:34 <Cale> gramplex: you could try that, it might get truncated, but you can make multiple pastes
05:10:35 <Jiten> gramplex: it's likely in some library you're using. look for imports.
05:10:44 <LoganCapaldo> plt scheme lets you use λ in place of lambda (at least inside DrScheme)
05:10:51 <gramplex> Cale: So it is root 0 (function output) and (0,40)
05:10:58 <gramplex> oh okay, wait let me check
05:11:21 <gramplex> Jiten and Cale: Yes, there is this import Root
05:11:23 <byorgey> hm, yes, isn't there also some sort of Emacs mode that will display \ as λ and things like that?
05:11:28 <Cale> gramplex: hmmm :)
05:11:29 <scook0> gramplex: it isn't passing the function output -- it's passing the function itself
05:11:38 <Cale> gramplex: Do you have a Root.lhs file sitting around?
05:11:53 <Cale> (or maybe Root.hs)
05:12:03 * wli does.
05:12:18 <yitz> olsner: Solve puzzles using backtracking, while keeping track of results. Catch any errors, and update a progress bar: StateT puz (ListT (StateT rslts (ErrorT err (WriterT IO progr)))) solution
05:12:31 <gramplex> No, I do not have the root.lhs file with me! :(
05:12:34 <reqamst> byorgey: do you know name of this mode?
05:12:40 <gramplex> Do you think it might be available online?
05:12:41 <Cale> yitz: hehehe :)
05:12:50 <Cale> gramplex: what is this for?
05:13:00 <Jiten> gramplex: if you don't have it somewhere, I can't see how the script would run.
05:13:05 <Cale> gramplex: Is it a homework assignment?
05:13:08 <LoganCapaldo> i read somewhere that the only reason they used λ wasbeause th other symbol didn't work typography wise. I find it ironic that we use \ now for a similar reason. Ironic I say! Like rain on your wedding day.
05:13:08 <ricky_clarkson> Is yaht recommended?
05:13:09 <gramplex> scook0: not function output, but the function itself means? the root function will need a value to process right?
05:13:15 * olsner yields to the power of monads
05:13:19 <Cale> ricky_clarkson: yes, mostly
05:13:20 <byorgey> reqamst: no, I don't.  I just have vague memories along the lines of "such a thing exists" and "it's very annoying to use"
05:13:28 <byorgey> reqamst: but I could be completely wrong =)
05:13:31 <Jiten> gramplex: in haskell, functions themselves are values too.
05:13:37 <Orphi> anybody know if Gtk2hs works with GHC 6.8.1 yet?
05:13:44 <Cale> ricky_clarkson: When you get to the part on monads, I recommend finding another tutorial. Also, cross reference with the wikibook, and ask lots of questions here :)
05:13:56 <scook0> > (\f x -> f x) (\x -> x + 1) 2
05:13:57 <lambdabot>  3
05:14:15 <Cale> There are specific tutorials on monads which are much better than what's in YAHT and the Wikibook.
05:14:26 <gramplex> I am working on a project.. my client has written this script in Haskell. I figured out two functions, but this is the last one I cannot figure out... I have developed a online multiplayer game that simulates solar car racing... I need this function to calculate the amount of solar energy being spent
05:14:37 <yitz> Orphi: their website seems to say: yes.
05:14:57 <Cale> gramplex: You should ask your client for the Root.lhs module.
05:15:06 <gramplex> Jiten: Oh okay
05:15:17 <gramplex> Cale/Jiten: Oh!!! So I need the Root.lhs file... hmmmmm
05:15:32 <gramplex> Cale/Jiten: For now, any guesses what the function might be doing? import Root
05:15:46 <gramplex> root 0 (\v -> powerUse v - s) (0,40)
05:15:48 <LoganCapaldo> > let tellf = tell . Endo in (snd $ runWriter $ do { tellf ("this program" ++) ; tellf ("constructs an" ++) ; tellf ("a string" ++) }) "in reverse I think"
05:15:49 <lambdabot>  Couldn't match expected type `Endo [Char]'
05:15:50 <Cale> My initial guess would be that it's finding a zero of the provided function
05:16:06 <Cale> That is, a value v such that powerUse v - s = 0
05:16:09 <LoganCapaldo> > let tellf = tell . Endo in appEndo (snd $ runWriter $ do { tellf ("this program" ++) ; tellf ("constructs an" ++) ; tellf ("a string" ++) }) "in reverse I think"
05:16:11 <lambdabot>  "this programconstructs ana stringin reverse I think"
05:16:13 <Cale> (or close enough to it)
05:16:25 <Cale> and in the range (0,40) with an initial guess of 0
05:16:39 <Cale> actually that seems fairly reasonable
05:16:49 <LoganCapaldo> but not in reverse because I used sections! :)
05:16:58 <Cale> yes, absolutely, that's what it *must* be doing
05:17:23 <Cale> It's probably an implementation of Newton-Raphson.
05:17:36 <ricky_clarkson> Cale: It seems to be misleading about side effects in the first chapters.  As I understand it Haskell can do side effects perfectly, but yaht seems to suggest that, say, x++ has no corollary in Haskell.
05:17:50 <ricky_clarkson> ..but you can achieve an equivalent with monads, afaik.
05:18:09 <Cale> ricky_clarkson: yes, but when you're doing that, the way in which you accomplish it is different
05:18:21 <ricky_clarkson> Yes.
05:18:24 <Cale> ricky_clarkson: So the referential transparency of the rest of the language is preserved.
05:18:26 <Japsu> @index Endo
05:18:26 <lambdabot> bzzt
05:18:48 <LoganCapaldo> > snd $ runWriter $ do { tell "this program " ; tell "does the same thing "; tell "without using Endo" }
05:18:50 <lambdabot>  "this program does the same thing without using Endo"
05:19:15 <Cale> ricky_clarkson: Values in the I/O monad are really better thought of as values describing side effects which could be performed.
05:19:21 <gramplex> Cale: Thanks. so is it trying to find a value 'v' such that (powerUse(v) - s) = 0... and also that v should be between 0 and 40?
05:19:29 <Cale> gramplex: yeah
05:19:37 <Cale> that is, such that powerUse v = s
05:19:53 <ricky_clarkson> Cale: Ok.  So can you build up a list of side effects and then perform them later, or inspect them to see what they would do?
05:19:55 <Cale> gramplex: so it's looking for a functional inverse of powerUse
05:19:55 <gramplex> Cale: oh ok, yes
05:20:18 <gramplex> Cale: Oh cool!! Thanks a lot zillion!!!!!!!!!!!!!!!!!!!!!
05:20:20 <Cale> ricky_clarkson: well, apart from the inspect them bit, though that really would be nice
05:20:30 <dcoutts> Orphi: yes, see haskell.org/gtk2hs/
05:20:36 <ricky_clarkson> I suppose you could do that by implementing your own IO monad.
05:20:42 <Cale> gramplex: and by all means, hang around and learn Haskell! :)
05:20:46 <Orphi> dcoutts: ah, cool. :-)
05:20:49 <gramplex> Cale: I'll try to search some stuff on the net regarding Newton-Raphson and see if I can figure it out
05:21:01 <dcoutts> Orphi: the 0.9.12.1 point release was for 6.8 compatibility
05:21:04 <LoganCapaldo> Theres that pure IO thing arg what's it called
05:21:06 <gramplex> Jiten/Cale: Thank you all!!!!!!!!!!!!!!
05:21:08 <Cale> http://en.wikipedia.org/wiki/Newton's_method
05:21:09 <lambdabot> Title: Newton's method - Wikipedia, the free encyclopedia
05:21:10 <gramplex> Cale: Sure, Cale
05:21:21 <LoganCapaldo> IOSpec?
05:21:24 <Cale> gramplex: It requires just a little calculus.
05:21:25 <Orphi> dcoutts: I take it that's the only thing that changed then?
05:21:31 <gramplex> Cale: Oh Wow! Thanks, cale. I'll have a read there.
05:21:34 <LoganCapaldo> @go haskell iospec
05:21:37 <lambdabot> http://sequence.complete.org/hwn/20070427
05:21:37 <lambdabot> Title: Haskell Weekly News: April 27, 2007 | The Haskell Sequence
05:21:43 <gramplex> Cale: Damn it! I hate calculus... but ill try
05:21:45 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3807
05:21:59 <dcoutts> Orphi: pretty much, a couple other bug fixes and a couple minor api extensions, no changes. It should be fully compatible.
05:22:26 <Orphi> dcoutts: Well, that was basically the only thing stopping me trying out GHC 6.8.1. I'll go take it for a spin... ;-)
05:22:28 <Cale> ricky_clarkson: I'll find my paste where I show how I think of IO
05:22:51 <Cale> http://hpaste.org/3673
05:22:55 <Cale> there it is :)
05:23:21 <Cale> That's not how GHC implements it, but it would be possible with newer features (GADT's)
05:23:40 <ricky_clarkson> So you're not a "monads are elephants" kinda guy.
05:23:49 <ricky_clarkson> Monads are.. here's the source.
05:24:01 <Cale> ricky_clarkson: essentially what Haskell programs do is define a bunch of instructions for the runtime system to carry out
05:24:06 <gramplex> Cale: I have a doubt. In this function, root 0 (\v -> powerUse v - s) (0,40)...
05:24:14 <gramplex> Cale: I am actually calling solarSpeed s
05:24:15 <ricky_clarkson> Gotcha.
05:24:15 <Cale> and they do this in a perfectly referentially transparent way
05:24:15 * wli does.
05:24:27 <gramplex> Cale: I am just providing one argument, that is 's'
05:24:37 <Cale> gramplex: right
05:24:43 <gramplex> Cale: then how does this function get the value of 'v'... to give it to powerUse?
05:24:58 <Cale> (\v -> powerUse v - s)
05:25:00 <Cale> is a function
05:25:06 <Cale> which takes a parameter v
05:25:07 <gramplex> Cale: I should be providing it in the beginning itself, right? like solarSpeed s, v
05:25:14 <Cale> root provides v
05:25:17 <ricky_clarkson> Cale: How do you test that your instructions are correct?  E.g., can you verify the chain of effects against some known correct pattern, without actually running them?
05:25:42 <Jiten> gramplex: also, please limit your usage of exclamation marks. Reading lines with lots of those feels like having a kid in the room who's bouncing off the walls at lightspeed out of sheer excitement.
05:25:48 <Cale> ricky_clarkson: unfortunately not, though it would be nice, and it's theoretically possible that with a little work we could do it
05:25:50 <gramplex> Cale: so 'v' is between 0 and 40 which is being tried in the powerUse function until it equals to 's'??
05:26:09 <gramplex> Jiten: sorry
05:26:13 <Cale> ricky_clarkson: If IO was implemented internally the way I envision it, then it would be totally doable just by writing a simulator.
05:26:32 <ricky_clarkson> Cale: What's the difference that stops that?
05:26:34 <Cale> gramplex: essentially, yeah
05:26:50 <Cale> ricky_clarkson: Well, currently IO is internally implemented with hackery.
05:26:59 <Cale> not with a nice data structure which is inspectable
05:27:02 <gramplex> Cale: Thanks
05:27:07 <Orphi> dcoutts: while you're here...
05:27:11 <Cale> Because when the IO monad was invented, GADT's didn't exist.
05:27:27 <Orphi> dcoutts: under Windows, the installers for GHC and Gtk2hs only seem to add things to the search path of the user doing the install
05:27:32 <Cale> It's also possible that the way GHC does it is easier to compile.
05:27:38 <dcoutts> Orphi: yes.
05:27:48 <dcoutts> Orphi: to allow it to install when the user is not admin.
05:27:56 <ricky_clarkson> Is there any way/plan of/to chang[ing|e] that?
05:28:05 <ricky_clarkson> Delete as appropriate.
05:28:06 <Orphi> dcoutts: mmm, I didn't know you could do that... :-)
05:28:09 <dcoutts> Orphi: and because messing with the global path scares me :-). You're welcome to do it manually.
05:28:14 <gramplex> Cale: Sorry to disturb you again. If the function does not get a zero after trying values from 0 to 40, then what is the default value it takes?
05:28:19 <Cale> Well, one thing which you can do is to simulate subsets of IO.
05:28:28 <LoganCapaldo> http://www.cs.nott.ac.uk/~wss/repos/IOSpec/
05:28:30 <Orphi> dcoutts: would it be possible to add an option or something to select which path to alter at install time?
05:28:30 <lambdabot> Title: IOSpec
05:28:36 <Cale> yes, like that :)
05:28:46 <dcoutts> Orphi: I'm not admin on the Windows machine I build Gtk2Hs on, so it's pretty essential for be to be able to test it :-)
05:29:06 <ricky_clarkson> LoganCapaldo: Hah, I like the graphic.
05:29:07 <Cale> gramplex: It probably uses some iterative method to improve the initial guess of 0
05:29:18 <Cale> gramplex: So it really depends.
05:29:21 <byorgey> cabal-install is teh sexy!!
05:29:28 <Cale> byorgey: It really is :)
05:29:32 <Orphi> dcoutts: fair enough. well, can this behaviour be documented a little more prominently? ;-)
05:29:36 <gramplex> Cale: Okay
05:29:37 <dcoutts> Orphi: it's not impossible but I cannot test that so someone else would have to do it.
05:29:48 <Cale> gramplex: That's exactly the sort of detail which I can't provide without seeing how root is implemented.
05:30:03 <dcoutts> Orphi: what form of documentation would you suggest?
05:30:20 <Orphi> dcoutts: well, there's some installation notes on the download page isn't there?
05:30:33 <Cale> gramplex: You can probably safely assume that it would return the value with minimal absolute value in the interval, but it probably doesn't actually go that far.
05:30:40 <dcoutts> Orphi: yep, though people typically do not read instructions / documentation ;-)
05:30:57 <Orphi> dcoutts: you can take a horse to water, you can't make it drink. ;-)
05:30:58 <byorgey> Lemmih++
05:31:06 <byorgey> xerox++
05:31:22 <byorgey> anyone else that should get a ++ for cabal-install?
05:31:23 <Cale> gramplex: It might even just return something random when there's no root, and it might not actually find a perfect root, but just an approximation to one.
05:31:30 <dcoutts> byorgey: and we did quite a bit of hacking on it at the recent hackathon.
05:31:36 <byorgey> dcoutts++
05:31:39 <byorgey> awesome =)
05:31:40 <Cale> gramplex: This all depends on how it's implemented.
05:31:50 <dcoutts> byorgey: and you're most welcome to help us out, there's a lot left to do.
05:32:14 <Orphi> dcoutts: I might also mention that Gtk2hs doesn't seem to work on Windows NT 4 - but then, neither does GTK+ :-(
05:32:28 <dcoutts> byorgey: the easiest thing is to document the bugs and your feature requests at http://hackage.haskell.org/trac/hackage/
05:32:30 <lambdabot> Title: Hackage - Trac
05:32:32 <byorgey> dcoutts: perhaps I will.  there's a not insignificant list of projects I'm interested in contributing to... right after I finish grad school applications =)
05:32:50 <dcoutts> byorgey: cool
05:32:57 <byorgey> dcoutts: ok, if I come across any bugs/feature requests I'll be sure to submit them.
05:33:04 <dcoutts> Orphi: if Gtk doesn't work there, there's not a lot we can do.
05:33:19 <Orphi> dcoutts: indeed. ;-)
05:33:22 <dcoutts> Orphi: I expect the same goes for win 9x
05:33:34 <Orphi> dcoutts: I'm unable to verify that - mercifully!
05:34:02 <Orphi> dcoutts: Interestingly, GHC 6.6.1 claims to work on NT but doesn't.
05:34:11 <LoganCapaldo> @type let tellf = tell . Endo in snd . runWriter $ do { tellf (* 2); tellf (+ 1) }
05:34:13 <lambdabot> forall a. (Num a, MonadWriter (Endo a) (Writer (Endo a))) => Endo a
05:34:13 <Orphi> dcoutts: 6.6 did, but not 6.6.1
05:34:22 <Cale> ricky_clarkson: The hardest part about simulating the IO monad is probably that you can call any C function from it.
05:34:24 <dcoutts> Orphi: I bet nobody tests it, that's the trouble
05:34:31 <LoganCapaldo> @type let tellf = tell . Endo in appEndo . snd . runWriter $ do { tellf (* 2); tellf (+ 1) }
05:34:32 <lambdabot> forall a. (Num a, MonadWriter (Endo a) (Writer (Endo a))) => a -> a
05:34:36 <dcoutts> Orphi: since nobody uses NT 4
05:34:37 <Orphi> dcoutts: well, I did ;-)
05:34:50 <Cale> ricky_clarkson: But it would be totally reasonable to implement subsets of the IO monad to test things.
05:34:54 <dcoutts> Orphi: but did you file bug reports?
05:35:02 <LoganCapaldo> interesting how it keeps all those contexts...
05:35:03 <ricky_clarkson> Cale: Fair enough, thanks for your brain cycles.
05:35:06 <Orphi> dcoutts: how do I do that?
05:35:34 <LoganCapaldo> @type let tellf = tell . Endo in appEndo . snd . runWriter $ do { tellf (* 2); tellf (+ 1) }  :: (Num a) => a -> a
05:35:36 <lambdabot>     Inferred type is less polymorphic than expected
05:35:36 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
05:35:36 <lambdabot>         tellf :: (a1 -> a1) -> Writer (Endo a) ()
05:35:37 <dcoutts> Orphi: follow the links from http://haskell.org/ghc/
05:35:38 <lambdabot> Title: The Glasgow Haskell Compiler
05:35:52 <Orphi> dcoutts: OK, I'll go do that now...
05:35:53 <LoganCapaldo> erm
05:36:01 <LoganCapaldo> Less polymorphic?
05:36:15 <dcoutts> Orphi: and to keep it building reliably we'd need to find a build-bot for Win NT otherwise nobody finds out when it breaks
05:36:16 * LoganCapaldo fails to understand the typechecker once again
05:36:30 <dcoutts> Orphi: anyone can contribute their machine as a build-bot
05:37:32 <Orphi> dcoutts: We have stacks of NT machines at work - but I couldn't possibly authorise the use of one of our machines for that...
05:37:46 <Orphi> dcoutts: possibly one of the ancient decommissioned ones
05:38:17 <Orphi> dcoutts: what is needed? just a machine that's Internet-accessible and always turned on?
05:38:18 <Cale> ricky_clarkson: Oh, another thing I should point out is that as far as possible, Haskell programmers keep everything out of being written in the IO monad.
05:38:29 <Cale> ricky_clarkson: Ideally, you should really only be doing IO there.
05:38:29 <dcoutts> Orphi: it needs to be net connected most of the time
05:38:40 <dcoutts> Orphi: or at certain times
05:39:03 <dcoutts> Orphi: buildbot is a distributed client/server system in python
05:39:06 <ricky_clarkson> Cale: Yes.  To date I've only used Haskell as a posh calculator, I've not done anything much with IO.
05:39:12 <Cale> ricky_clarkson: The instructions you give to the runtime system can involve arbitrary pure computations as well, so your "model" in the MVC sense is all pure, and usually large parts of the view and controller as well.
05:39:37 <Orphi> dcoutts: lol! Python rather than Haskell? ;-)
05:40:06 <dcoutts> Orphi: it's an off-the-shelf system http://darcs.haskell.org/buildbot/
05:40:07 <lambdabot> Title: GHC BuildBot
05:40:08 <Cale> Orphi: GHC comes with a perl script
05:40:24 <Orphi> Cale: yeah, the Evil Mangler.
05:40:28 <Orphi> (God I love that name... lol)
05:40:49 <yitz> Isn't the EM deprecated now?
05:40:50 <LoganCapaldo> they should really rewrite that in Malbolge
05:40:50 <Cale> It is such a perfect description of what it does too.
05:40:54 <Cale> yitz: yes
05:41:07 <Cale> yitz: because the native code generator is good enough
05:41:14 <Orphi> as far as I know, the EM still runs though...
05:41:18 <Cale> yitz: it's still needed if you want to compile via C
05:41:26 <Cale> Only if you're compiling via C
05:41:31 <Cale> which is no longer the default
05:41:33 <yitz> They should have written it as a Turing machine, just for spite.
05:41:36 <Botje> perhaps it's time to replace the EM with nice haskell code
05:41:38 <Orphi> Cale: last word I heard is that via-C is still faster. that still the case?
05:42:27 <dcoutts> Botje: that would not be any better
05:42:41 <dcoutts> the problem with the EM is that it exists, not the language it's written in
05:42:47 <LoganCapaldo> I'm gonna find a really poor C compiler to use with -fvia-C and then I'm going to write an inflammatory blog post about how the native code generator is 10X faster than -fvia-C
05:42:58 <dcoutts> the task simply needs to be eliminated
05:43:11 <Orphi> improved native code generation FTW!
05:43:42 <yitz> LoganCapaldo: you can write your C compiler in Perl.
05:43:47 <LoganCapaldo> Yes!
05:43:51 <LoganCapaldo> victory!
05:45:51 <Cale> Use a C interpreter
05:45:55 <paczesiowa> I have parsec's parser p which succeeds for empty string, how do I make it fail for empty strings? I tried "(eof >> fail "") <|> p" but obviously it still succeeds
05:46:39 <Cale> guard
05:46:51 <Cale> hmm...
05:46:58 <wolverian> yitz, and how does that guarantee it'll be poor? :)
05:47:12 <yitz> try eof
05:47:14 <LoganCapaldo> wolverian: I'm a terrible perl programmer, that's how :)
05:47:24 <wolverian> ah!
05:47:31 <wolverian> you can just pretend it's C, though.
05:47:36 <yitz> wolverian: compile the C to perl. But not Perl 6 - it'll end up in Haskell.
05:48:05 <Cale> paczesiowa: does it succeed with a distinctive value on the empty string?
05:48:30 <LoganCapaldo> can we see p?
05:49:04 <yitz> yes, best to factor p itself so that it fails on empty strings.
05:49:10 <LoganCapaldo> it might be easier to write it in such a way as to not match the empty string at all instead of trying to "protect" it from empty strings
05:49:30 <Cale> though actually I bet it can be done :)
05:49:55 <Cale> hmm
05:50:04 <Cale> change fail there to unexpected
05:50:07 <Cale> and see what happens
05:50:07 <yitz> try (not anyChar)
05:50:08 <Orphi> Bug #1867 filed.
05:51:01 <Orphi> while I'm here... should I file the various exception-related bugs in the same place?
05:51:11 <yitz> (you can see how long it's been since I used Parsec)
05:51:17 <Cale> Orphi: I don't think so, or at least they're similar enough that switching to native by default was considered acceptable
05:52:10 <Orphi> Cale: which statement was that a reply to? :-.
05:52:21 <ytshen> hi, i use ghci, and import Test.QuickCheck, and it said no such module, how to add this module
05:52:26 <Cale> Orphi: the thing about via-C being faster or not
05:52:32 <Orphi> Cale: ah, OK.
05:52:59 <LoganCapaldo> @where quickcheck
05:53:00 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
05:53:05 <ricky_clarkson> ytshen: Download QuickCheck.hs and :load QuickCheck.hs (I think)
05:53:13 <Cale> no, get it from Hackage
05:53:34 <LoganCapaldo> @hackage quickcheck
05:53:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/quickcheck
05:53:47 <LoganCapaldo> omg
05:53:52 <Cale> @hackage QuickCheck
05:53:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
05:54:02 <LoganCapaldo> there really is a @hackage?
05:54:19 <Orphi> @hackage banana
05:54:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/banana
05:54:27 <LoganCapaldo> I was getting ready to complain when it didn't work <g>
05:54:44 <Cale> @hackage egakcap/stpircs-egakcah/nib-igc/gro.lleksah.egakcah//:ptth
05:54:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/egakcap/stpircs-egakcah/nib-igc/gro.lleksah.egakcah//:ptth
05:54:45 <Orphi> omg - there's a "banana" package...
05:54:56 <LoganCapaldo> Although it doesn't look like a very smart @hackage, so maybe I can still complain :)
05:55:01 <Cale> Orphi: that's a lie ;)
05:55:08 <yitz> @hackage latest-lambdabot-hackage-plugin
05:55:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/latest-lambdabot-hackage-plugin
05:55:14 <Orphi> @hackage Cake
05:55:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cake
05:55:19 <Orphi> ...the cake is a lie!
05:55:22 <ytshen> thanks a lot
05:55:24 <LoganCapaldo> @hackage shapr
05:55:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/shapr
05:55:31 <paczesiowa> p is composed from little parsers (which should succeed on empty strings) but I want top level to fail on empty string
05:55:33 <idnar> @hack hackage
05:55:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hackage
05:55:37 <ricky_clarkson> I knew he was a Haskell program.
05:55:44 <Orphi> oh, wait - probably not many Portal players here...
05:55:45 <idnar> @hacka foo
05:55:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/foo
05:55:49 <Cale> ytshen: I'm a little surprised you don't have that package, as it comes with GHC
05:55:51 <idnar> huh, didn't know you could abbreviate like that
05:55:59 <Cale> ytshen: did you get GHC from your distribution?
05:56:10 <ytshen> Cale: yes, i use Ubuntu 7.04
05:56:11 <LoganCapaldo> @hickage foo
05:56:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/foo
05:56:12 <Cale> ytshen: If so, then your distro might have a package for it
05:56:14 <Cale> ah, yes
05:56:17 <LoganCapaldo> and spell wrong too!
05:56:27 <Cale> cale@zaphod:~$ apt-cache search quickcheck
05:56:27 <Cale> libghc6-quickcheck-dev - Haskell automatic testing library for GHC
05:56:42 <Cale> ...
05:56:55 <Cale> (there are some other possibly interesting results there too :)
05:56:56 <LoganCapaldo> hehe
05:56:57 <idnar> what the heck @ hickage
05:57:03 <ytshen> Cale: yes, i have installed it now, thanks a lot :)
05:57:06 <Cale> idnar: spell correction
05:57:07 <LoganCapaldo> Cale's hostname is silly
05:57:09 <gour> hdbc abstracts database back-end, ie. it should be possible to use different back-ends with the same code*
05:57:15 <Cale> hm?
05:57:23 <Cale> LoganCapaldo: which of my hostnames?
05:57:36 <Orphi> lmao @ which
05:57:37 <idnar> sheesh
05:57:40 <Orphi> advanced...
05:57:47 <Cale> CPE004854805910-CM000e5cdd834a.cpe.net.cable.rogers.com ?
05:57:48 <yitz> @hack age
05:57:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/age
05:57:50 <LoganCapaldo> the only one I've ever seen
05:57:57 <Cale> cale.yi.org ?
05:58:08 <LoganCapaldo> in your prompt, unless that was your cwd
05:58:13 <Cale> oh zaphod
05:58:32 <Cale> That's my machine name, yeah.
05:58:43 <LoganCapaldo> yes CPE004854805910-CM000e5cdd834a.cpe.net.cable.rogers.com is very silly
05:59:04 <yitz> @go zaphod
05:59:06 <lambdabot> http://en.wikipedia.org/wiki/Zaphod_Beeblebrox
05:59:35 <LoganCapaldo> Cale's just dis guy ya know?
05:59:36 <yitz> "For the Ottawa nightclub, see Zaphod Beeblebrox (nightclub)."
05:59:50 <LoganCapaldo> Oh so going to Ottawa!
05:59:58 <LoganCapaldo> who's with me?
06:00:12 <Cale> I could probably go to Ottawa
06:00:35 <yitz> But we thought you are are already there. virtually.
06:00:51 <Cale> via a web of free association :)
06:01:00 <opqdonut> :t filterM
06:01:00 <vincenz> those cause cancer
06:01:02 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:01:44 <yitz> Hey, it says the Stones shot a video there.
06:02:03 <vincenz> anyone with ACM access?
06:02:07 <wli> I've been to that club.
06:04:22 <LoganCapaldo> > let pred = \_ -> do { x <- get ; put (x + 1); return (x > 3) } in flip evalState 0 $ filterM pred [1,2,3,4,5,6,7]
06:04:23 <lambdabot>  [5,6,7]
06:05:23 <wli> modify (+1)
06:06:06 <LoganCapaldo> > map length ["modify (+1)", "put (x + 1)"]
06:06:08 <lambdabot>  [11,11]
06:06:24 <LoganCapaldo> and I already had x out, might as well use it
06:07:18 <yitz> > let pred = \_ -> do { modify (+10); gets (> 3) } in flip evalState 0 $ filterM pred [1,2,3,4,5,6,7]
06:07:20 <lambdabot>  [1,2,3,4,5,6,7]
06:08:04 <LoganCapaldo> yitz: order matters for imperative programs <g>
06:08:06 <Orphi> so guys, what should I do with my interesting exceptions problem?
06:09:03 <LoganCapaldo> although I'm very confused about the +10
06:10:30 <LoganCapaldo> > let pred = \_ -> do { modify (+1) ; gets (> 3) } in flip evalState (-1) $ filterM pred [1..7]
06:10:32 <lambdabot>  [5,6,7]
06:11:03 <Jiten> http://blog.fishsoup.net/2007/11/10/reinteract-better-interactive-python/ something like this would nice for haskell too.
06:11:05 <lambdabot> Title: Reinteract - Better interactive Python  fishsoup, http://tinyurl.com/22vo5p
06:11:23 <LoganCapaldo> > let pred = const $ modify (+1) >> gets (> 3)  in flip evalState (-1) $ filterM pred [1..7]
06:11:24 <lambdabot>  [5,6,7]
06:11:25 <wli> > let pred _ = modify (+1) >> gets (> 4) in evalState (filterM pred [1..7]) 0
06:11:26 <lambdabot>  [5,6,7]
06:12:40 <Cale> Jiten: yes, I've been thinking the same thing for a long time
06:12:53 <yitz> > let pred = \_ -> ((=<<modify (+10)) . return) =<< gets (> 3) in flip evalState 0 $ filterM pred [1,2,3,4,5,6,7]
06:12:54 <lambdabot>  Couldn't match expected type `m b' against inferred type `Bool'
06:13:00 <yitz> or something
06:13:05 <Cale> Jiten: That's based on the Mathematica notebook interface, which would actually work better for Haskell than it does for Mathematica.
06:15:02 <Jiten> Yes, Haskell is quite good fit for that style.
06:15:58 <geezusfreeek> i thought that when i tried mathematica for the first time
06:16:05 <geezusfreeek> that i wished it was like haskell
06:16:29 <Cale> Imperative computation doesn't actually mix all that well with the notebook interface, because cells can get evaluated in some strange order and you can end up confusing yourself.
06:16:51 <Cale> But pure computation would work extremely well.
06:16:57 <reqamst> What mean that upside-down "A" in Haskell logo? http://www.haskell.org/sitewiki/images/8/86/Haskellwiki_logo_big.png
06:16:59 <lambdabot> http://tinyurl.com/2cwjf8
06:17:01 <LoganCapaldo> Seems like everyone agrees this would be hot to have for haskell. lets do it! do it!
06:17:10 <Cale> Especially if you could get cells to update automatically when declarations they depend on change.
06:17:21 <LoganCapaldo> reqamst: "forall"
06:17:48 <Cale> (well, maybe that should be handled with something like Mathematica's "Dynamic" actually :)
06:18:13 <Cale> But at least you could visually mark the out of date cells.
06:18:45 <integral> Doesn't Excel do that? :-P
06:18:50 <Orphi> Cale: yeah, but who's going to build all this? ;-)
06:18:51 <reqamst> LoganCapaldo: oh, sure - quantifier.
06:18:58 <Cale> Orphi: That's a good question.
06:19:21 <Orphi> Cale: I'd love to have a go at it... but since there doesn't appear to be a lightweight Haskell interpreter anywhere...
06:19:32 <LoganCapaldo> reqamst: I was going to give you this link http://en.wikipedia.org/wiki/Universal_quantification but it seems you just eneded a reminder :)
06:19:33 <lambdabot> Title: Universal quantification - Wikipedia, the free encyclopedia
06:19:39 <Cale> Hm? Of course you'd use GHCi as a backend.
06:19:50 <Cale> Or GHC, rather. :)
06:20:01 <Cale> Probably GHC-as-a-library.
06:20:31 <wli> To be lightweight, one would probably want to stick to a restrictive subset of the language.
06:20:40 <wli> e.g. H98
06:20:49 <LoganCapaldo> bah.
06:21:00 <LoganCapaldo> lightweight is overrated :)
06:21:06 <Cale> I want all the cool stuff in GHC :)
06:21:39 <Cale> But that's not really what I consider the hard part.
06:21:52 <Cale> The hard part is the annoying GUI work that you'd have to do to get it right.
06:22:06 <Cale> This isn't a stock editbox we're talking about :)
06:22:08 <wli> What are you trying to pull off?
06:22:08 <Orphi> Cale: last time I asked the GHC API, the compiled program was larger than GHC itself... o_O
06:22:24 <reqamst> LoganCapaldo: Unfortunately i still haven't logic in school.
06:22:28 <Cale> Orphi: what?
06:22:44 <Orphi> grrr... last time I *used* the GHC API...
06:22:51 <Cale> Well, sure
06:22:56 <Cale> the GHC API *is* GHC.
06:23:09 <LoganCapaldo> of course it's GHC + your program :)
06:23:18 <Orphi> yeah, but... my program was about 12 lines long, and the compiled version was about 4x larger than GHC.
06:23:20 <Cale> You're linking a complete copy of GHC into your application.
06:23:21 <fasta> Cale: it seems that for every level in the stack for every variable I am interested in, I need to write a function to access it.
06:23:28 <Cale> 4x larger is strange, yeah
06:23:43 <Cale> fasta: wha?
06:24:02 <Orphi> Cale: perhaps because you get the compiler *and* bytecode interpreter, where as GHC and GHCi each have only one or the other?
06:24:21 <Cale> Orphi: I'm not sure
06:24:26 <LoganCapaldo> I thought ghci was just a alnative way of spelling ghc --interactive
06:24:30 <Cale> yes
06:24:32 <Cale> it is
06:24:39 <LoganCapaldo> so i don't see how that could be the case
06:24:56 <Orphi> well, GHCI.EXE is quite large...
06:25:11 <Orphi> so presumably doing GHC.EXE --interactive just makes it call the other binary?
06:25:19 <Cale> no
06:25:20 <Orphi> (I'm guessing here...)
06:25:22 <Cale> the other way around
06:25:30 <Cale> er
06:25:32 <Cale> hum
06:25:37 <Cale> Maybe it's different on windows
06:25:51 <Cale> On linux ghci is just a link to ghc, iirc.
06:26:14 <Orphi> Cale: yeah, that's the usual Unix style of things...
06:26:23 <LoganCapaldo> On my box ghci is a shell script
06:26:32 <fasta> Cale: suppose I have a stack of N high, am interested in accessing M parts of State (e.g. readFoo = gets foo), in all of them, it seems I need for one level: gets foo, for another lift(gets foo) for yet another lift(lift(gets foo)) and so on. If I name all those functions, I get N*M functions.
06:26:32 <wli> Generally the way it goes is examining argv[0]
06:26:44 <Orphi>  10,237,440 ghc.exe
06:26:48 <LoganCapaldo> a 3 line shell script
06:26:53 <Orphi>     10,240 ghci.exe
06:26:57 <LoganCapaldo> (not counting the shebng)
06:27:02 <Cale> yes, here too :)
06:27:21 <Orphi> 10 KB is quite a big shell script ;-)
06:27:34 <Cale> fasta: Do you actually use each of the levels separately?
06:27:39 <LoganCapaldo> I understand .bat files are very verbose <g>
06:27:42 <Cale> (I just figured out what you mean by stack)
06:27:45 <Orphi> OTOH, it's a very small bytecode compiler and interpreter, so...
06:28:05 <Cale> fasta: You should always newtype the constructed monad.
06:28:10 <LoganCapaldo> I'm really curious what the deal is with that
06:28:18 <Cale> fasta: and just wrap up all the operations on it.
06:28:32 <LoganCapaldo> maybe it's just a C program that has to go thru an elaborate song and dance to invoke ghc --interactive
06:28:50 <LoganCapaldo> and it's full of debugging symbols or something?
06:28:54 <LoganCapaldo> that's truly bizzare
06:28:59 <yitz> nah, probably a copy.
06:29:09 <Cale> are they (almost) the same size?
06:29:23 <LoganCapaldo> not according to orph
06:29:44 <LoganCapaldo> ghci.exe is 10Kish
06:29:45 <fasta> Cale: What would newtyping help?
06:29:58 <LoganCapaldo> ghc.exe is 10M ish
06:30:12 <Cale> fasta: It would help to forget that there's a stack of monad transformers there :)
06:30:41 <Cale> LoganCapaldo: oh, then that's definitely what's going on.
06:31:47 <Cale> fasta: you kind of want to think of a monad as a small embedded programming language which you've designed
06:32:19 <fasta> Cale: So, I can use monad transformers in the definition of the newtype and then forget about it when I use it?
06:32:50 <fasta> Cale: That doesn't work magically, right?
06:32:54 <Cale> fasta: right, just add deriving (Functor, Monad), and any other classes you want to derive.
06:33:17 <Cale> and implement any primitives that you'd like
06:33:37 <wli> Shouldn't there be MonadState, MonadReader, MonadWriter, etc. classes that automatically get instances and lift?
06:33:45 <Cale> and then leave that module, don't export the newtype's data constructor, and forget that it's actually a stack of monad transformers
06:34:03 <Cale> there are
06:34:07 <wli> The sole wart being IO which does not lift.
06:34:11 <Cale> But only sometimes
06:34:22 <Cale> Not everything lifts through everything else
06:34:41 <fasta> Cale: I did that once, but GHC derived the type as being MonadState (something), instead of MyMonad (with something hidden)
06:34:44 <Cale> and you still need special cases for specific primitives you've added
06:34:51 <wli> Well, most of the time I can mix their combinators freely and just have to define the ordering when I unwrap.
06:35:01 <integral> perhaps some of your transformers can be merged, such as adjacent readers
06:35:08 <Cale> fasta: hmm... did you forget the data constructor in your primitive operations?
06:35:41 <fasta> Cale: how do you mean "forget"? I just newtyped StateT.
06:35:41 <Cale> I have a document about how to do this...
06:35:51 <fasta> Cale: yes, the traffic lights
06:36:00 <Cale> yes
06:36:35 <LoganCapaldo> traffic lights?
06:36:41 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
06:36:43 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
06:37:05 <LoganCapaldo> Is this yet another dazzling metaphor? :)
06:37:12 <Cale> no
06:37:16 <Cale> It's just an example
06:37:27 <Cale> Not even a really great example, but it's something :)
06:39:46 <fasta> Cale: oh, I see
06:40:02 <fasta> Cale: I think I did forget to wrap it in a constructor, indeed.
06:40:05 <Skyp> Hm, I tried to write a simple, intuitive function to test if an Integer is prime. I am aware, that there are better methods, but why doesn't this work properly: isprime nr = (length [x | x <- [2..(floor (sqrt nr))], (rem nr x) == 0]) == 0
06:40:22 <Skyp> if I call the function, it tells me sth. about "unresolved overloading" ;)
06:40:38 <Skyp> *** Type       : (Floating a, Integral a, RealFrac a) => Bool
06:40:42 <Cale> Skyp: probably you'll need a fromIntegral as well
06:40:45 <LoganCapaldo> @type rem
06:40:47 <lambdabot> forall a. (Integral a) => a -> a -> a
06:40:52 <Cale> @type sqrt
06:40:54 <LoganCapaldo> @type floor
06:40:54 <lambdabot> forall a. (Floating a) => a -> a
06:40:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:41:00 <fasta> Cale: i.e. get =  State.get foo should be ConstructorT (State.get foo)
06:41:05 <Cale> Nothing is both Integral and Floating
06:41:07 * Orphi stops filling GHC bugs now...
06:41:17 <Cale> Orphi: what have you been filing?
06:41:20 <fasta> Cale: that's what you meant, right?
06:41:22 <Skyp> Hm, I am not sure if I understand that ;)
06:41:25 <Cale> fasta: yes
06:41:40 <LoganCapaldo> Integral is a set of types, Floating is a set of types
06:41:41 <Cale> fasta: You only do that for your primitives defined inside that module where you construct the monad.
06:41:46 <Orphi> Cale: just a few minor things (e.g., GHC is broken on WinNT.)
06:41:50 <LoganCapaldo> hre is no typ that is in both sets
06:42:05 <LoganCapaldo> so you need some way to get there from here
06:42:16 <LoganCapaldo> usually that way is fromIntegral
06:42:33 <Skyp> ok, so I do a fromIntegral (sqrt nr) ?
06:42:37 <Cale> Skyp: Numeric conversions in Haskell all have to be done explicitly, though there are some very general operations for doing it
06:42:48 <Cale> fromIntegral needs to be applied to nr before sqrt
06:43:09 <Skyp> oh, ok
06:43:11 <Cale> and then floor afterward, so it's probably a good idea to factor that out into a function
06:43:41 <Cale> It's because nr is an integral type of thing, and sqrt wants a floating point sort of thing.
06:43:50 <Skyp> ok, fine, thx ;)
06:45:42 <LoganCapaldo> Cale: that article was interesting. I think it might have given me a clue as to the direction to go in creating "non-toy" programs
06:46:46 <Cale> :)
06:47:17 * Cale .oO(Hmm, I wonder if I've written any non-toy programs.)
06:47:34 <Cale> I suppose I've written at least one. :)
06:47:53 <LoganCapaldo> Like ever, or in haskell? :)
06:48:03 <Cale> Well, both to some extent.
06:48:20 <Cale> I spend lots of time thinking about how to architect programs though.
06:48:38 <Cale> I just have very little patience for actually doing it.
06:48:45 <LoganCapaldo> I've discovered that I'm not the best for that
06:48:55 <wli> Skyp: primes :: [Integer] ; primes = 2 : 3 : 5 : [p | p <- [7,9..], isPrime p] ; isPrime :: Integer -> Bool ; isPrime p = all [q | q <- takeWhile (\t -> t * t < p) primes, p `rem` q /= 0] ?
06:49:07 <LoganCapaldo> I bang my head against teh wall a lot when it comes to designs esp. big ones
06:49:33 <LoganCapaldo> usually it takes another person to point out how stupid I was being :)
06:49:59 <LoganCapaldo> I think I don't trust myself so I try to overdesign everything and I get caught up in the spiralling complexity
06:51:39 <Cale> Haskell's a particularly good language to just sit and think about.
06:51:53 <wli> Skyp: primes :: [Integer] ; primes = 2 : 3 : 5 : [p | p <- [7,9..], isPrime p] ; isPrime :: Integer -> Bool ; isPrime p = all (\q -> p `rem` q /= 0) (takeWhile (\q -> q * q <= p) primes)
06:51:54 <Cale> It's still kind of scary, but it seems to pay off.
06:52:21 <LoganCapaldo> Haskell even more than ruby has infected my day to day C++ programming
06:52:37 <LoganCapaldo> even if it's just how I think about the code i'm writing
06:52:57 <Cale> You see traps everywhere? :)
06:53:18 <Cale> Oh damn, that's going to be a bug someday.
06:53:22 <Cale> hehe
06:53:34 <LoganCapaldo> Yeah something like that
06:53:55 <Cale> It's really hard to write code in C++ without mutating things.
06:54:15 <LoganCapaldo> Also the number of times I've wanted newtype ... = ... deriving (Num) and the number of bugs it would have prevented has  been staggering
06:55:13 <Cale> I think NASA also would like newtype deriving. ;)
06:56:22 <Cale> "Oops, that was in feet, not metres."
06:56:28 <LoganCapaldo> Although one thing that ruby taught me that Haskell has only reinforced was the data-structures as control structures thing
06:56:45 <Cale> yes
06:57:36 <LoganCapaldo> So Haskell can't take all the credit for that one as far as I'm concerned. and that I use at work also (somewhat less than I would if it were ruby or haskell but it's not something I likely woulda done before encountering the idea)
06:58:37 <LoganCapaldo> Now if only I had lazy lists... :)
06:58:41 <Cale> right :)
06:58:57 <Cale> Ruby can't use data structures for infinite loops :)
06:59:10 <DRMacIver> Sure it can.
06:59:11 <Cale> though, perhaps it has generators?
06:59:36 <DRMacIver> Even languages which don't have generators have generators. :)
06:59:58 <Cale> Oh, I suppose yes, you could do that.
07:00:02 <geezusfreeek> not another "you can write fortran in any language" argument...
07:00:12 <Cale> But that's unwieldy at best.
07:00:15 <LoganCapaldo> You can pretty easily get ruby to scheme-level support for laziness
07:00:31 <LoganCapaldo> But I miss t more in C++ :)
07:00:41 <DRMacIver> geezusfreeek: Not really, no. In languages with first class functions and mutability, generators are very easy.
07:01:09 <DRMacIver> Even iterators aren't too bad. </blatant lie>
07:01:16 <geezusfreeek> haha
07:02:19 <pjd> DRMacIver: define "generators"
07:02:44 <DRMacIver> "Thingies"
07:02:55 <LoganCapaldo> let generators = .. ;)
07:03:04 <DRMacIver> (Or in other words, I really don't want to multitask *two* language debates. ;) )
07:03:15 <fasta> yield was already implemented by someone in Haskell
07:03:32 <LoganCapaldo> ruby yield or python yield?
07:03:53 <LoganCapaldo> cause ruby yield = ($) basically :)
07:03:56 <pjd> writing CPS is hardly the same as having a native yield-type construct
07:04:02 <fasta> Python
07:04:39 <fasta> It seems that in Haskell anything "big" will use a monad-transformer stack.
07:04:47 <LoganCapaldo> pjd: what if you have call/cc ?
07:04:54 <fasta> Or rather a special language like Cale said.
07:05:24 <Cale> fasta: Not necessarily. Monad transformer stacks are a decent way to quickly construct combinator libraries, but I've written large programs without them.
07:05:52 <Cale> I don't think I used monad transformers at all in the largest Haskell program I wrote.
07:06:00 <pjd> LoganCapaldo: CLU/Python/JavaScript/C# yield, yeah
07:06:06 <Cale> Just lots of the list monad.
07:06:23 <Cale> I suppose it could have been a little nicer with a StateT over list.
07:06:27 <Cale> In hindsight.
07:06:33 <LoganCapaldo> pjd: was that an answer to my first question or my second?
07:06:36 <pjd> LoganCapaldo: you can implement it using continuations, yeah
07:06:48 <pejo> Cale/fasta, could you quantify "big"?
07:07:02 <LoganCapaldo> http://www.ruby-doc.org/stdlib/libdoc/generator/rdoc/index.html
07:07:03 <lambdabot> Title: generator: Ruby Standard Library Documentation
07:07:08 <LoganCapaldo> uses call/cc
07:07:20 <geezusfreeek> and post source because we need more examples of big haskell programs
07:07:22 <geezusfreeek> :)
07:07:25 <pjd> Ruby's callcc is based on stack copying, though
07:07:32 <Cale> ~1200 lines of Haskell, which was ~50% documentation, which would have been 15,000 lines of C
07:07:43 <pjd> so don't expect reasonable performance for anything :)
07:07:48 <LoganCapaldo> pjd: ah so it's a sucky a call/cc and doesn't count? :)
07:07:53 <Cale> (by the estimate of a rather good C programmer)
07:08:17 <pjd> LoganCapaldo: it's just very inefficient
07:08:23 <LoganCapaldo> (incidently I lied that lib no longer uses call/cc it uses ruby's green threads because they're faster)
07:09:02 <pjd> LoganCapaldo: for generators, you'll be copying the entire stack about twice for every yield
07:09:20 <LoganCapaldo> yes yes
07:09:23 <LoganCapaldo> it's lousy :)
07:10:01 <LoganCapaldo> that's why Cont is so badass. Mechanically transformation into CPS so i don't have to :)
07:10:11 <Cale> (so that was fairly dense Haskell code, but I thought it was still pretty nice and readable and modular)
07:10:35 <Cale> and Wolfgang Thaller said it was decent :)
07:11:08 <Cale> (He took over the code after me)
07:11:11 <pejo> Cale, ghc/OSX maintainer?
07:11:18 <Cale> pejo: The same guy, yes
07:14:11 <pjd> LoganCapaldo: that link you gave still claims to use continuations
07:14:28 <LoganCapaldo> yeah it's likely old
07:15:08 <LoganCapaldo> we don't beleive in updating in documentation in ruby land <g>
07:17:08 <Altair^> what happens if function min gets two arguments, where another is head of an empty array?
07:18:50 <mrd> you mean head of an empty list
07:18:57 <mrd> > min (1, head [])
07:18:59 <lambdabot>  <(Integer,Integer) -> (Integer,Integer)>
07:19:08 <mrd> > min 1 (head [])
07:19:10 <LoganCapaldo> hehe
07:19:10 <lambdabot>  Exception: Prelude.head: empty list
07:19:12 <mrd> sorry, too much SML
07:20:59 <fasta> Cale: I find that 1200 -> 15,000 hard to believe.
07:21:24 <fasta> Cale: (assuming it's not a library difference)
07:23:22 <geezusfreeek> i don't think around 10x the loc for a C traslation of a haskell program is outside the realm of possibility if we are talking about a very literal translation
07:23:45 <geezusfreeek> but if both the haskell code and the C code are idiomatic, i agree, it sounds like a bit too large of a difference
07:23:57 <wli> Doesn't to me.
07:24:21 <geezusfreeek> hmm... he did also say it was pretty dense
07:24:45 <LoganCapaldo> let's try an experiement!
07:25:01 <LoganCapaldo> Somene rewrite it in C
07:25:04 <LoganCapaldo> not it!
07:25:05 <geezusfreeek> lol
07:25:12 <geezusfreeek> definitely not it
07:25:13 <wli> What was it?
07:26:00 <fasta> The best test would be to rewrite a complete replacement for a GNU program.
07:26:33 <LoganCapaldo> GNU hello world!
07:26:36 <fasta> I guess that doesn't count, because those mostly do I/O ;)
07:26:40 <wli> patch(1) is hard.
07:26:47 <kawfee> wli!
07:27:06 <LoganCapaldo> dowouldn't darcs have to effectively do pathc(1) ?
07:27:10 <LoganCapaldo> or no?
07:27:22 <wli> Find out what it really does and fear.
07:27:50 * LoganCapaldo wonders if it would be safer to remain ignorant
07:27:52 <geezusfreeek> there we go... let's rewrite darcs in C!
07:27:57 <opqdonut> !
07:28:04 <LoganCapaldo> Now I'm really afraid
07:28:05 <kawfee> LoganCapaldo ignorance is bliss
07:28:18 <wli> patch(1) is a huge patchwork of voodoo to try to get patch conflicts.
07:28:22 <Jiten> Cale: you wouldn't happen to have an estimate on what the program would've been in C++?
07:28:24 <wli> s/get/fix/
07:28:32 <Jiten> (that 1200 line haskell, 15k line C)
07:28:47 <olsner> a patch replacement would also have to parse patches from input, which probably includes a fair bit of voodoo to read all the different patch formats you have to support
07:28:53 <LoganCapaldo> Jiten: by my standard calculations, 30K <g>
07:29:30 <opqdonut> the standardized sleeve-stetson method
07:29:31 <pejo> fasta, Erlang people have rewritten some telecom stuff, and it was quite a lot smaller. Too bad I dont' remember the name offhand.
07:29:56 <opqdonut> yeah erlang was kinda designed with that in mind :=
07:29:57 <opqdonut> *:)
07:30:44 <fasta> Is it a bad thing to import one giant module of which you only need a small bit, but there exist other modules that do use other parts of it, forming a partition?
07:30:49 <pejo> opqdonut, it's still a functional language.
07:31:07 <fasta> (It would cut down the amount of imports I need to do)
07:31:44 <Jiten> LoganCapaldo: was that a realistic estimate or a tongue-in-cheek one?
07:31:52 <LoganCapaldo> The latter
07:32:17 <LoganCapaldo> hence the <g>
07:32:34 <fasta> I think the Haskell program will be a small factor <<10 smaller, and an order of magnitude more safe and more easy to maintain.
07:32:55 <fasta> Beyond that, I don't know.
07:32:58 <LoganCapaldo> actually
07:33:09 <LoganCapaldo> just have Cale compile it with -fvia-C.
07:33:23 <LoganCapaldo> then we'll have an exact count and no one will have to touch that icky C language :)
07:34:49 <Jiten> oh, ghc can compile to C?
07:35:06 <pejo> That's hardly idiomatic C, or even resembling anything you would write.
07:35:18 <Skyp> hm, is there a way for a lambda-function to call itself other than let foo = (\x <- foo x) ... ? or is it usually done this way?
07:35:31 <LoganCapaldo> Skyp: fix!
07:35:38 <pejo> fasta, Jan Henry Nystrm was the guy I was thinking of, during his postdoc at Heriot-Watt.
07:35:49 <Jiten> why not simply define it in where?
07:36:02 <Skyp> fix?
07:36:12 <DRMacIver> Hm. The state of the art with statically typed multimethods really makes me sad.
07:36:13 <olsner> @src fix
07:36:14 <lambdabot> fix f = let x = f x in x
07:36:20 <LoganCapaldo> > fix (\f n -> if n == 0 then 1 else n * f (n - 1) ) 5
07:36:22 <lambdabot>  120
07:36:22 <DRMacIver> I should fix it, but I'm so far from competent to do so that it's not even funny. :)
07:36:33 <Skyp> ah, ic ;) thx ;)
07:36:41 <olsner> DRMacIver: statically typed multimethods?
07:36:43 <Skyp> Jiten: that's another possibility, of course
07:37:26 <DRMacIver> olsner: A multimethod is a function which dispatches on the type of all of its arguments.
07:37:48 <DRMacIver> olsner: So I could define foo(Object, Object) and specialise for foo(String, String).
07:38:00 <Jiten> LoganCapaldo: how do you get at the C-file? I suddenly got interested at what kind of code it produces.
07:38:01 <DRMacIver> olsner: They're quite common in lispy circles, and there's a nice extension to HM which supports them.
07:38:08 <LoganCapaldo> Jiten: I have no idea
07:38:17 <DRMacIver> olsner: But as far as I know there are three languages which are designed around them and they're all abandoned.
07:38:17 <Jiten> it didn't produce a .c file by just specifying -fvia-C
07:38:26 <LoganCapaldo> I think it produces .hc files
07:38:40 <pejo> Jiten, you can get ghc to keep temporary files with some switch.
07:39:05 <Jiten> ah, -keep-hc-file
07:39:05 <olsner> ah, yes, I've heard of that
07:39:42 <olsner> but if it's static it's not a multimethod, is it? that'd be more like overloading
07:40:38 <Jiten> heh, it made a 8619 line monster out of my 125 line testcase :)
07:40:52 <DRMacIver> olsner: No, it's still dispatched dynamically. There is run time type information, but there's also a static type system that makes guarantees (and allows for a lot of shortcutting optimisations, at least theoretically)
07:40:53 <pejo> DRMacIver, why do you want the specialisation, performance?
07:41:35 <LoganCapaldo> > 1115 / 50 * 100
07:41:37 <lambdabot>  2230.0
07:41:41 <Jiten> ok, this is quite unreadable.
07:41:41 <LoganCapaldo> err
07:41:47 <LoganCapaldo> > 50 / 1115 * 100
07:41:49 <lambdabot>  4.484304932735426
07:41:51 <DRMacIver> pejo: Many reasons. Sometimes performance, sometimes for behaviour changes, sometimes as an alternative to pattern matching.
07:42:00 <LoganCapaldo> I suck at math
07:42:16 <LoganCapaldo> a 50 line haskell file -> 1115 C file
07:42:26 <LoganCapaldo> > 1115 / 50
07:42:27 <lambdabot>  22.3
07:42:32 <LoganCapaldo> 22X :)
07:42:32 <DRMacIver> pejo: They subsume a lot of things you can do with multi-parameter type classes, pattern matching, etc.
07:42:39 <LoganCapaldo> I'm satisfied
07:42:44 <DRMacIver> (And other things don't do so well :) )
07:44:21 <Japsu> .hc stands for hardcore
07:44:24 <Japsu> ;)
07:44:52 <Saizan_> DRMacIver: with "pattern matching" you mean the effect you get with union types?
07:45:57 <DRMacIver> Saizan_: You can realise a data Foo = Bar | Baz declaration as instead declaring an abstract type Foo and two concrete subtypes Bar and Baz, then you can dispatch on the type of that.
07:46:24 <DRMacIver> (As Jon Harrop pointed out to me recently you really need some form of destructuring + nesting of matches in order to make that as good as Haskell style pattern matching though)
07:46:49 <DRMacIver> Or rather as I pointed out to Jon Harrop once he complained at me sufficiently about how verbose the example I wrote was. :)
07:47:20 <pejo> DRMacIver, so you want subtyping to be able to remove mptc?
07:47:50 <DRMacIver> pejo: I think you're putting text into my keyboard. ;)
07:48:11 <pejo> DRMacIver, I'm just trying to guess where you're going.
07:49:02 <DRMacIver> It's an alternate style of doing things. It captures some things you could do with (pattern matching, multiparameter type classes, higher order modules, normal OO single dispatch, etc.) more elegantly. Some things it doesn't do as well.
07:49:21 <DRMacIver> It also does some things which are quite hard to encode without subtyping.
07:49:47 <DRMacIver> I'm not saying "Haskell should have subtyping", so strictly this is OT. :) It's just sad that there aren't better examples for exploring this approach.
07:50:12 <pejo> DRMacIver, heh. Play around with O'Haskell some if you can get it going. :-)
07:50:25 <DRMacIver> It's not really the same thing as far as I know.
07:50:35 <opqdonut> ?src mplus MonadState
07:50:35 <lambdabot> Source not found. stty: unknown mode: doofus
07:50:39 <DRMacIver> I looked into it a while ago.
07:50:40 <opqdonut> hrmm
07:50:46 <opqdonut> ?src mplus StateT
07:50:46 <lambdabot> Source not found. Are you on drugs?
07:51:07 <pejo> DRMacIver, same thing as what?
07:51:12 <DRMacIver> (Where 'looked into it' really doesn't involve more than that)
07:53:15 <olsner> ?src StateT mplus
07:53:15 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:58:56 <Saizan_> DRMacIver: any suggestion on what to read about this?
08:02:48 <visof> >[1,2,3,4,5]!!3
08:03:08 <olsner> 4
08:04:27 <visof> >[1,2,3,4]++[1,2,3,4,5]
08:05:04 <Saizan_> [1,2,3,4,1,2,3,4,5]
08:05:27 * olsner was the slower bot this time. Never again!
08:05:58 <Beelsebob> gyah, you'd think that a spreadsheet app would be able to get drawing a graph right... http://www.cs.kent.ac.uk/people/rpg/tatd2/broken.png
08:06:03 <reqamst> > [1..5] !! (-1)
08:06:04 <lambdabot>  Exception: Prelude.(!!): negative index
08:06:25 <visof> >head[tail[1,2,3]]
08:06:32 <reqamst> Uhm, it doesn't work, ;(
08:06:36 <visof> > head[tail[1,2,3]]
08:06:37 <lambdabot>  [2,3]
08:06:43 <Beelsebob> it does work... it just doesn't do what you expected
08:06:52 <opqdonut> yep :)
08:07:07 <visof> > tail[1,2,3]
08:07:08 <lambdabot>  [2,3]
08:07:19 <Beelsebob> > head [[2,3]]
08:07:20 <lambdabot>  [2,3]
08:07:22 <roconnor> > [tail [1,2,3]]
08:07:23 <lambdabot>  [[2,3]]
08:07:27 <visof> > head[tail[1,2,3]]
08:07:28 <lambdabot>  [2,3]
08:07:42 <Beelsebob> > head(tail[1,2,3])
08:07:44 <lambdabot>  2
08:07:59 <roconnor> > head (tail (1,2,3))
08:08:00 <lambdabot>  Couldn't match expected type `[a]'
08:08:01 <visof> what is the difference?
08:08:11 <Saizan_> visof: you know that [..] are not just for grouping but construct a list of 1 element?
08:08:22 <Beelsebob> visof: () merely group things (like brackets in maths), [] put things in lists
08:08:25 <visof> ya
08:08:47 <Saizan_> ?src head
08:08:47 <lambdabot> head (x:_) = x
08:08:47 <lambdabot> head []    = undefined
08:08:49 <Beelsebob> so [tail[1,2,3]] is the list containing one element... that element is the tail of [1,2,3] i.e. [2,3]
08:09:51 <visof> hence head[2,3]
08:09:56 <visof> > head[2,3]
08:09:58 <lambdabot>  2
08:09:59 <Beelsebob> no
08:10:05 <Beelsebob> you did head of the list containing [2,3]
08:10:10 <Beelsebob> not head [2,3]
08:10:10 <visof> is this functions composition?
08:10:16 <Saizan_> head [[2,3]] /= head [2,3]
08:10:30 <Beelsebob> visof: look at the difference here:
08:10:35 <Beelsebob> > (tail [1,2,3])
08:10:36 <lambdabot>  [2,3]
08:10:45 <Beelsebob> > [tail [1,2,3]]
08:10:46 <lambdabot>  [[2,3]]
08:10:55 <visof> oh i understood
08:11:10 <LoganCapaldo> the big idea here is that ( and [ are _not_ interchangeable
08:11:12 <visof> in head[[2,3]]
08:11:25 <visof> this is list that contain one element
08:11:29 <Beelsebob> yes
08:11:33 <Beelsebob> and that one element is another list
08:11:33 <visof> that be list also
08:11:37 <Beelsebob> which contains 2 elements
08:11:42 <Saizan_> ?type [[2,3]]
08:11:42 <visof> wow
08:11:43 <lambdabot> forall t. (Num t) => [[t]]
08:12:04 <DRMacIver> Saizan_: Where 'this' equals what? Statically typed multimethods?
08:12:05 <visof> wonderful
08:12:10 <visof> thanks guys
08:12:12 <Saizan_> DRMacIver: yes
08:13:16 <visof> saizan_ i had the 5 chapters from "Introduction to haskell by Hutton
08:13:26 <visof> can i find the whole Ebook?
08:13:42 <phlpp> erm
08:13:57 <phlpp> can a native english speaker tell me the difference between die and dice?
08:14:13 <Igloo> one die, many dice
08:14:25 <Igloo> Except most natives would say one dice too
08:14:25 <phlpp> dice can be singular too, can't it?
08:14:29 <wli> "Dice" is the plural of "die."
08:14:31 <DRMacIver> Saizan_: My reading on it is at most cursory I have to admit. The last time I seriously looked into the subject I was horribly out of my depth (I'm not much better now). The three languages which use it that I know of are Jazz, Pizza and Needle (all in various states of decay).
08:14:32 <Saizan_> visof: i don't really know, is it freely available?
08:14:47 <mrd> @roll 2d20
08:14:47 <lambdabot> Consider it noted.
08:14:49 <visof> i don t know too
08:14:55 <mrd> hmm
08:15:03 <mrd> what did I just do?
08:15:15 <DRMacIver> Saizan_: A good place to look is probably Daniel Bonniot's papers on the subject ( http://cristal.inria.fr/~bonniot/bonniot.html ) and the bibliographies.
08:15:17 <lambdabot> Title: bonniot
08:15:50 <visof> Saizan_ what are your tutorial sources for learning Haskell?
08:16:10 <Saizan_> mmh yaht, the wikibook, and #haskell
08:16:13 <Saizan_> ?where yaht
08:16:14 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
08:16:38 <Saizan_> so wikibook: http://en.wikibooks.org/wiki/Haskell
08:16:40 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
08:17:21 <Saizan_> the haskell wiki also have a lot about specific areas
08:18:15 <Saizan_> DRMacIver: papers ftw, thenks :)
08:18:41 <LoganCapaldo> If I wanted to add a table of bindings to parsec parser, woudl it be better to ReaderT Parser or to use GenParser Char MyTable a ?
08:19:37 <LoganCapaldo> I'm sort of leaning towards the latter, I think I get more parsers for free if I use Parser right?
08:20:05 <LoganCapaldo> erm
08:20:11 <LoganCapaldo> I can't use latter and former
08:20:15 <LoganCapaldo> I fail at english
08:20:24 <LoganCapaldo> I'm sort of leaning towards the _former_
08:21:00 <Saizan_> aren't combinators polymorphic in the user state?
08:21:42 <LoganCapaldo> istr a bunch of them being defined for just Parser, but it might of been that a bunch were just defined for GenParser Char ...
08:21:56 <Saizan_> ?docs
08:21:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:22:59 <Saizan_> http://haskell.org/ghc/docs/latest/html/libraries/parsec-2.1.0.0/Text-ParserCombinators-Parsec-Char.html <-- st is free
08:23:01 <lambdabot> http://tinyurl.com/227lk5
08:23:15 <Saizan_> ?help docs
08:23:15 <lambdabot> docs <lib>. Lookup the url for this library's documentation
08:23:28 <Saizan_> i wonder what "lookup" means here
08:24:30 <DRMacIver> Saizan_: I've not done more than skim them really.
08:25:08 <Saizan_> however is your table doesn't change ReaderT gives you more guarantees, but all the lifting might be ugly
08:26:12 <firefly> How does one use this cabal thing?
08:26:52 <firefly> I would like to install the PCRE regex module (Text.Regex.PCRE).
08:26:57 <Saizan_> firefly: usually: runhaskell Setup configure; runhaskell Setup build; sudo runhaskell Setup install
08:27:14 <firefly> on what?  where?
08:27:32 <Saizan_> are you on windows?
08:27:48 <firefly> nope, Ubuntu Gutsy Gibbon
08:28:08 <Saizan_> however from the command line in the directory where you extracted the package
08:28:36 <firefly> ok.
08:28:56 <Saizan_> or did i misunderstood your question?
08:28:58 <firefly> I have a suspicion that I have to download the dependencies manually as well... correct?
08:29:16 <firefly> no, it just seems like there is much less to this cabal thing than I thought.
08:29:27 <Saizan_> there's cabal-install
08:29:39 <hpaste>  pep pasted "Just for try" at http://hpaste.org/3808
08:29:50 <firefly> does it wrap things better?
08:29:50 <Saizan_> which is like apt-get for hackage
08:30:05 <firefly> that sounds good.
08:30:15 <firefly> That's precisely the kind of interface I want.
08:30:17 <Saizan_> but you've to build it manually, first ^^
08:30:56 <firefly> Yum would theoretically be ok except that I've never seen it work well in practice and the yum maintainer is immune/allergic to critique ;)
08:31:10 <firefly> does cabal-install have any evil dependencies?
08:31:35 <Saizan_> no, just 2 packages that build fine, but you need Cabal 1.2.1
08:31:53 <Saizan_> which comes with 6.8.1 but you can also install it on 6.6.1
08:32:05 <Saizan_> (ghc i mean)
08:32:21 <firefly> aha, it comes with 6.8.1.  I did the binary download thing with 6.8.1 :)
08:32:42 <firefly> Does cabal handle parallel GHC installs ok?
08:32:57 <Saizan_> yes
08:33:13 <firefly> (and why the xxxx isn't this properly googleable .... grrrr....)
08:33:33 <LoganCapaldo> hmm
08:34:01 <Saizan_> cabal defaults to the ghc referenced by `which ghc`
08:34:10 <firefly> ok, so the easiest thing for me for now seems to be to kind of ignore the neatly packaged 6.6.1 and the neatly packaged libraries for it under Ubuntu Gibbon and just use 6.8.1 from now on?
08:34:10 <Saizan_> but you can pass a -w flag to configure
08:34:11 <LoganCapaldo> can unsafeCoerce# be used to successfully convert between newtypes with the same underlying type?
08:34:24 <Saizan_> firefly: yes
08:34:27 <LoganCapaldo> @index unsafeCoerce
08:34:28 <lambdabot> bzzt
08:34:32 <LoganCapaldo> @index unsafeCoerce#
08:34:32 <lambdabot> bzzt
08:35:14 <firefly> what about the hc-pkg thing that is meantioned in the cabal spec?
08:35:27 <Saizan_> firefly: then you can install http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install-0.4.0 with and its dependencies
08:35:30 <lambdabot> http://tinyurl.com/yss6oz
08:35:31 <LoganCapaldo> not that i'd ever want to do such a terrible thing of course
08:35:51 * firefly loves lambdabot :)
08:36:51 <Saizan_> firefly: hc-pkg is meant to be the package manager of the compiler, it just stores information about the installed packages
08:37:18 <firefly> but ghc doesn't seem to provide one?!?
08:37:18 <Saizan_> a bit like dpkg, if you want
08:37:25 <Saizan_> it's called ghc-pkg
08:37:28 <firefly> ah.
08:39:04 <LoganCapaldo> in case anyone else was interested it does apparently work
08:40:16 <firefly> Amongst the varied and useful subcommands of a typical Setup.hs, we also get hscolour and pfe.
08:40:38 <Saizan_> pfe?
08:40:59 <firefly> "Generate Programmatica Project."
08:48:30 <visof> how can i make the average for elements of list?
08:48:48 <visof> let average x = sum x / length x?
08:48:51 <LoganCapaldo> @hoogle [a] -> a
08:48:52 <lambdabot> Prelude.head :: [a] -> a
08:48:52 <lambdabot> Prelude.last :: [a] -> a
08:48:52 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
08:49:06 <Saizan_> visof: almost.
08:49:26 <LoganCapaldo> @hoogle (Num a, Fractional b) => [a] -> b
08:49:26 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
08:49:26 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
08:49:26 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
08:49:28 <Saizan_> length gives an Int but / wants a fractional, so you've to convert it with fromIntegral
08:49:29 <visof> what do you mean?
08:49:57 <Saizan_> ?type let average x = som x / length x in average
08:49:58 <visof> i m absolute beginner with Haskell
08:49:59 <lambdabot> Not in scope: `som'
08:50:02 <Saizan_> ?type let average x = sum x / length x in average
08:50:04 <lambdabot>     No instance for (Fractional Int)
08:50:04 <lambdabot>       arising from use of `/' at <interactive>:1:16-31
08:50:04 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
08:50:09 <visof> what is hoogle?
08:51:05 <Saizan_> ?type let average x = sum x / fromIntegral (length x) in average
08:51:07 <lambdabot> forall a. (Fractional a) => [a] -> a
08:51:22 <profmakx> > average []
08:51:23 <lambdabot>   Not in scope: `average'
08:51:23 <profmakx> bam
08:51:36 <pejo> visof, give hoogle a type signature and it will give you matching functions
08:52:49 <visof> @hoogle  a =>  a => a
08:52:50 <lambdabot> Prelude.undefined :: a
08:52:50 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:52:50 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
08:53:08 <firefly> visof: it's like google, only for searching the Haskell standard library
08:53:30 <LoganCapaldo> > let sumWithLength [] (s, n) = (s, n) ; sumWithLength (x:xs) (s, n) = sumWithLength xs (s + x, n + 1) ; let average xs = sum / len where (sum, len) = sumWithLength xs (0,0) in average [2,3,4]
08:53:30 <lambdabot>  Parse error at "let" (column 104)
08:53:33 <DRMacIver> Argh. I hate the "I know what I'm looking for but don't have the keywords to google it" feeling.
08:53:49 <LoganCapaldo> > let sumWithLength [] (s, n) = (s, n) ; sumWithLength (x:xs) (s, n) = sumWithLength xs (s + x, n + 1) ; average xs = sum / len where (sum, len) = sumWithLength xs (0,0) in average [2,3,4]
08:53:51 <lambdabot>  3.0
08:54:36 <fasta> firefly: that's called a search engine ;)
08:56:03 <LoganCapaldo> > let sumWithLength [] (s, n) = (s, n) ; sumWithLength (x:xs) (s, n) = sumWithLength xs (s + x, n + 1) ; average xs = sum / len where (sum, len) = sumWithLength xs (0,0) in average []
08:56:05 <lambdabot>  NaN
08:56:05 <firefly> err... I know.  I remember when lycos showed up.  It made using the web so much simpler and faster.
08:56:41 * wli would probably just use avg xs = sum xs / genericLength xs
08:56:41 * firefly remembers ugly homepages WITHOUT pictures of cats
08:57:45 * LoganCapaldo has a compulsion not to walk the list twice, nevermind the giant pair of thunks he's building up
08:59:00 * doserj gives wli a list of integers to try out his avg function
08:59:12 <wli> doserj: Try me.
08:59:36 <wli> Oh, sorry.
08:59:39 <LoganCapaldo> @type let sumWithLength [] (s, n) = (s, n) ; sumWithLength (x:xs) (s, n) = sumWithLength xs (s + x, n + 1) ; average xs = sum / len where (sum, len) = sumWithLength xs (0,0) in average
08:59:40 <lambdabot> forall t. (Fractional t) => [t] -> t
08:59:44 <xerox> > uncurry (/) . foldr (\x -> (+x) *** succ) (0,0) $ [1,2,3]
08:59:45 <lambdabot>  2.0
09:01:20 <Saizan_> > uncurry (/) . foldr (\x -> (+x) *** succ) (0,0) $ [1::Integer,2,3]
09:01:21 <lambdabot>   add an instance declaration for (Fractional Integer)
09:01:29 <LoganCapaldo> > uncurry (/) . foldr ((*** succ) . (+)) (0,0) $ [1,2,3]
09:01:30 <lambdabot>  2.0
09:01:39 <araujo> hello
09:02:34 <xerox> > uncurry (/) . join (***) fromIntegral . foldr (\x -> (+x) *** succ) (0,0) $ [1 :: Int, 2, 3]
09:02:35 <lambdabot>  2.0
09:03:13 <LoganCapaldo> xerox: that's gonna break on doubles / floats now though isn't it?
09:03:32 <wli> Seems like the numeric hierarchy needs work.
09:03:34 <xerox> the type is now Integral a => [a] -> Int
09:03:43 <xerox> Or -> a, whatever.
09:03:52 <LoganCapaldo> > fromIntegral 2.3
09:03:53 <lambdabot>  Add a type signature
09:04:03 <LoganCapaldo> > fromIntegral (2.3 :: Double)
09:04:03 <lambdabot>   add an instance declaration for (Integral Double)
09:04:04 <lambdabot>     In the expression: fr...
09:04:29 <Saizan_> ?type uncurry (/) . join (***) fromIntegral . foldr (\x -> (+x) *** succ) (0,0) $ [1 :: Int, 2, 3]
09:04:30 <lambdabot> forall c. (Fractional c) => c
09:04:50 <LoganCapaldo> tee hee
09:05:15 <xerox> Yeah, Integral a, Fractional b => [a] -> b
09:05:29 <firefly> cabal-install turned out to need zlib and HTTP, which are not in the base install of ghc 6.8.1 (but are in 6.6.1).
09:05:47 <firefly> I've installed those and cabal-install now configures, builds, and installs.
09:05:49 <LoganCapaldo> > uncurry (/) . join (***) fromIntegral . foldr (\x -> (+x) *** succ) (0,0) $ [2.3, 2.3]
09:05:50 <lambdabot>  Add a type signature
09:05:52 <firefly> But it does not run!
09:06:03 <LoganCapaldo> > uncurry (/) . join (***) fromIntegral . foldr (\x -> (+x) *** succ) (0,0) $ [2.3 :: Double, 2.3]
09:06:04 <lambdabot>   add an instance declaration for (Integral Double)
09:06:11 <Saizan_> firefly: getting errors?
09:06:13 <LoganCapaldo> stupid cake
09:06:25 <Saizan_> firefly: the command is called "cabal"
09:06:41 <Saizan_> firefly: e.g. cabal install foo
09:06:46 <firefly> strace tells me that it tries to open the file "dist/Conftest.c" in the current directory, right after issuing a bunch of stat64 syscalls looking for ld, the run-time loader/linker.
09:06:52 <LoganCapaldo> @hoogle (Num a, Fractional b) => a -> b
09:06:53 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
09:06:54 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
09:06:54 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
09:06:55 <visof> when we say  x :: Bool -> Bool
09:07:02 <firefly> Yes, I tried to run "cabal fetch".
09:07:17 <firefly> I got a very cryptic error message that actually turned out to be true:
09:07:20 <visof> is this mean the input of  x is Bool and out is also Bool
09:07:20 <visof> ?
09:07:27 <doserj> firefly: either use Cabal-1.2.1, or Cabal from darcs. The Cabal from ghv 6.8.1 is broken wrt caba-install
09:07:34 <Saizan_> firefly: ah, yes, you need to first run it from the source directory, i found that bug yesterday
09:07:34 <firefly> cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
09:07:58 <pidou> Hi!
09:08:03 <LoganCapaldo> instance Num a where toFractional n = fromIntegral n ; instance Fractional a where toFractional n = id
09:08:11 <firefly> Oh.  I'll reconfigure and rebuild it and run it from there first.  Thanks!
09:08:16 <LoganCapaldo> oh wait
09:08:22 <LoganCapaldo> that so can't be in both type classes
09:08:39 <LoganCapaldo> or can it?
09:08:57 <LoganCapaldo> Fractional ness requires Num ness right?
09:09:15 <LoganCapaldo> are you allowed to provide defaults like that?
09:09:16 <Saizan_> firefly: wait, i think you should follow doserj advice and install Cabal-1.2.1
09:09:30 <Saizan_> or 1.2.2, you can find it on hackage
09:09:41 <LoganCapaldo> I got nothing
09:09:57 <firefly> I can do that without anything else in the ghc 6.8.1 installation getting mad at me?
09:10:03 <pidou> I'd like to know which version of happs is needed to compile succesfuly hpaste ...
09:10:28 <Saizan_> firefly: yes, you can
09:11:04 <Saizan_> pidou: which repo?
09:12:12 <pidou> Saizan: the darcs version of hpaste
09:14:03 <Saizan_> hard to say..
09:15:14 <pidou> The hpaste Cabal package specify a version of HAppS>0.8.4
09:16:27 <firefly> Yeah, I'll try installing a newer version of the cabal library.
09:17:03 <firefly> cabal fetch was much better behaved this time around but cabal install died of the same reason as soon as I gave it a package name,
09:17:19 <firefly> What on Earth would it even want to open a C source code file for!?!
09:18:08 <pidou> But when I try to compile hpaste with HAppS 0.9.1, I still get the message 'cannot satisfy dependency HAppS>0.8.4'
09:19:03 <ramza3> excuse me for my ignorance.  But are their similiaries between data types and in object oriented development, objects.  They seem to share many of the same properties.
09:19:09 <Lemmih> pidou: I don't think hpaste works with 0.9.1
09:19:29 <Lemmih> pidou: Actually, I'm quite sure it doesn't.
09:20:38 <pidou> Since it doesn't work with 0.8.4, maybe it will work with 0.8.8 ?
09:21:56 <Saizan_> pidou: http://www.scannedinavian.com/~eric/hpaste-devel/ <-- this should almost work with 0.8.8
09:22:16 <shapr> Good morning #haskell!
09:22:25 <firefly> "morning", Shae!
09:22:38 <firefly> (you ARE still in Sweden, aren't you?)
09:22:48 <shapr> firefly: Nah, I've been back in the USA for more than a year.
09:23:02 <shapr> firefly: Haven't seen you around #haskell in a long time though, what's up?
09:23:19 <firefly> oh.  Didn't know that.  I recently started hacking haskell a bit and I tried to catch up on your blog.
09:23:39 <shapr> ramza3: There are some similarities between data types and objects, yes.
09:23:47 <firefly> Well, I worked a bit on an accelerated NIC + linux driver.
09:23:47 <LoganCapaldo> no there aren't!
09:23:55 <firefly> Quite interesting, actually.
09:23:56 <LoganCapaldo> they are totally different!
09:24:07 <shapr> firefly: And I probably won't ever be back in Sweden.
09:24:23 <firefly> Got to know far more than I wanted to about various ways to implement resets, asynchronous and synchronous, in verilog.
09:24:44 <shapr> Sounds exciting
09:25:05 <firefly> A bit too exciting, actually.  Surprisingly hard to get right.
09:25:07 <pidou> Saizan_: Where can I get HAppS 0.8.8 ?
09:25:23 <shapr> ramza3: But objects hold state as well as data, so in my viewpoint monads match objects a bit more.
09:25:48 <ramza3> shapr: that is interesting, hmm.
09:26:26 <LoganCapaldo> shapr: distinguishing between state and data. I like the way you think !
09:26:43 <fasta> firefly: if you want to complain, do it in the BTS of cabal-install, not here.
09:27:33 <Saizan_> pidou: good question
09:27:48 <Saizan_> shapr, Lemmih: is 0.8.8 still available somewhere?
09:28:34 <conal> there's also a simple relationship between algebraic data types and objects.  the type corresponds to an abstract class and the constructors to constructors for concrete subclasses.  Functions defined over those constructors are like methods on the concrete subclasses.
09:29:56 <DRMacIver> *coughmultimethodscough*
09:30:43 <conal> agreed -- the correspondence is even stronger when you consider multi-methods.
09:30:45 <Philippa_> that, and it doesn't work at all in a statically-typed setting
09:31:01 <Philippa_> gets variances backwards, stuff like that
09:31:38 <conal> sure.  there's a correspondence and significant differences.
09:32:41 <Philippa_> or to put it another way, the relationship's an approximation, modulo a bunch of important stuff. Unlike most of the things we describe as relationships around here
09:32:45 <wli> Cale was asking about type inference with structural subtyping.
09:33:08 <DRMacIver> Philippa_: I don't see why it gets the variance backwards.
09:33:25 <wli> I had no idea what was decidable or not decidable apart from Dilip Siquiera's thesis.
09:34:27 <Philippa_> DRMacIver: actually it's worse than that because of where it's acceptable to add types in the typing hierarchy
09:34:38 <Philippa_> really you can't talk about variance sensibly until you've resolved that
09:34:42 <wli> I did make the point that structural subtyping could do some cool things (totally ignoring OO subtyping).
09:34:59 <shapr> Saizan_: Probably in ~server/backups ?
09:35:14 <DRMacIver> Philippa_: Ok. In which case I agree, they treat the hierarchical nature very differently. I just wasn't sure what you meant.
09:35:38 <DRMacIver> Hm
09:35:47 * DRMacIver wonders why this is only giving warnings but failing to build.
09:40:39 <firefly> Ah, the bug where cabal tries to open dist/Conftest.c got fixed in the darcs repository on Nov 8.
09:40:41 <araujo> ghc-pkg expose <package> , that's the correct way of unhidden a package right?
09:43:07 <doserj> yes
09:45:30 <pidou> Saizan_, shapr: How can I access ~server/backups ?
09:48:11 <araujo> doserj, are you using ghc6.8?
09:54:20 <hpaste>  Byredsaq pasted "swiss army watch strap" at http://hpaste.org/3809
09:55:30 <kpreid> I was hoping for some entertaining Haskell code there...
09:59:24 <thoughtpolice> hm, is there any documentation on reading the core output for optimising your program? or is it just kind of self-explanatory after enough looking?
10:01:07 <hpaste>  pidou pasted "HAppS blog error" at http://hpaste.org/3810
10:02:03 <dons> firefly: yes, that's right
10:03:43 <hpaste>  firefly pasted "cabal install regex-pcre error" at http://hpaste.org/3811
10:04:54 <fasta> thoughtpolice: there's a wiki page, but unless you only have less than a page of code to inspect it's usable.
10:05:01 <firefly> I got past the hurdle of install cabal-install and also past the hurdle where it tries to open a non-existing .c file.
10:05:20 <firefly> Now that I've come so far it actually seems nice enough.
10:05:21 <Brian`> hi guys
10:05:44 <fasta> thoughtpolice: not usable*
10:05:45 <Brian`> I'm using haskell on windows and when I specify a file path like "d:/Programming Source Code/Haskell/blah.xml", it says illegal URI
10:05:50 <firefly> But it still doesn't work for me.  I'm trying to install regex-pcre, which depends on regex-base.
10:05:50 <Brian`> do u know how to get around it?
10:06:08 <firefly> cabal detects the dependency, downloads them both and tries to configure and install regex-base.
10:06:10 <fasta> Brian`: that's because it is not a valid URI.
10:06:26 <Brian`> fasta: then what's valid URI?
10:06:35 <firefly> Then it complains about a missing Data.Sequence which is supposed to be in the containers package only hidden.
10:06:42 <fasta> @go RFC URI
10:06:44 <lambdabot> http://www.faqs.org/rfcs/rfc2396.html
10:06:44 <lambdabot> Title: RFC 2396 (rfc2396) - Uniform Resource Identifiers (URI): Generic Syntax
10:06:53 <firefly> But ghc-pkg says it's very much NOT hidden (and I never did anything to hide it).
10:06:56 <fasta> Brian`: see that RFC>
10:07:02 <firefly> So something else is wrong.
10:07:04 <firefly> Any ideas?
10:07:28 <roconnor> file:///d|/Programming Source Code/Haskell/blah.xml
10:07:43 <fasta> Brian`: probably something like file:///home/bar would work on *nix. I don't know about Windows.
10:07:55 <Brian`> hm.. okay
10:08:11 <Brian`> thanks to both roconnor, fasta
10:08:38 <firefly> roconnor: I think it should be with only two forward slashes in the beginning and then the drive spec.
10:10:08 <fasta> roconnor: is that a standard thing?
10:10:10 <thoughtpolice> fasta: hm well that's fine, it's a start. any links?
10:10:32 <fasta> @go performance haskell wiki core inspect
10:10:34 <lambdabot> http://haskell.org/haskellwiki/Performance/GHC
10:10:34 <lambdabot> Title: Performance/GHC - HaskellWiki
10:11:26 <marceauhuxley> marceau
10:12:56 <araujo> Anybody knows what package contains Controll.Parallel for ghc6.8.1?
10:13:19 <audreyt> base-3.0.0.0
10:13:38 <dons> hey audreyt!
10:13:45 <araujo> mmm...
10:13:51 <dons> araujo: isn't it in the parallel package?
10:13:56 <byorgey> no, it's in parallel-1.0.0.0
10:14:13 <byorgey> so says http://haskell.org/ghc/docs/latest/html/libraries/
10:14:23 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parallel-1.0.0.0
10:14:26 <lambdabot> http://tinyurl.com/3atykq
10:14:43 <araujo> Thanks
10:14:45 <araujo> :-)
10:14:52 <doserj> firefly: many packages are not yet compatible with ghc6.8.1. With a bit of luck, it is sufficient to just add the packages to the build-depends line in the .cabal file
10:15:59 <firefly> aha, thanks doserj.
10:16:31 <araujo> I have seen the packages have been more ... 'modularized' for ghc6.8.1
10:16:47 <dons> yep.
10:18:06 <profmakx> m. lambdabot doesnt build on 6.8.1
10:18:41 <dons> that's right.
10:20:26 <profmakx> the tower of monads refuses to compile ;)
10:20:33 <profmakx> time to tear it down, dons *cough*
10:21:17 <firefly> adding "containers, bytestring, array" gets me past the build of regex-base (with runghc Setup.hs).
10:21:34 <firefly> Alas, it fails under runghc Setup.hs install:
10:22:00 <firefly> Installing: /home/firefly/ghc-6.8.1//lib/regex-base-0.92/ghc-6.8.1
10:22:01 <firefly> Setup.hs: Error: Could not find module: Text.Regex.Base with any suffix: ["hi"]
10:24:23 <araujo> wow
10:24:29 <araujo> it compiles lot faster!
10:26:49 <fasta> firefly: AFAIK, not everything is compatible with 6.8.1 yet
10:27:15 <firefly> :(
10:27:23 <fasta> firefly: so, complain to the authors or patch it yourself and send the changes to them.
10:27:35 <firefly> do you have any idea what the error message might mean?
10:28:05 <fasta> firefly: no, but dcoutts does, surely
10:28:11 <firefly> I've already spent 2.5 hours on IRC chasing this so (and a couple of days before that) so I might as well continue for a bit more.
10:29:10 <fasta> firefly: probably, the Cabal file doesn't contain regex-<something>
10:38:09 <davidL> when I try to build hpaste I get the error: HPasteAdmin.hs:31:41: Not in scope: `html' ...where is html?
10:39:51 <monochrom> module Text.Html, package "html".
10:40:29 <davidL> I thought hpaste used Text.XHtml
10:41:03 <LoganCapaldo> @index html
10:41:03 <lambdabot> bzzt
10:41:10 <LoganCapaldo> stop bzzting me!
10:41:16 <monochrom> Alright, then module Text.XHtml, package "xhtml". Available in "extralibs" or your OS distribution or hackage.
10:41:17 <LoganCapaldo> I liked the insults better
10:41:26 <LoganCapaldo> @hoogle html
10:41:26 <lambdabot> Text.Html :: module
10:41:27 <lambdabot> Text.Html.Html :: [HtmlElement] -> Html
10:41:27 <lambdabot> Text.Html.HTML :: class HTML a
10:41:27 <monochrom> I really like insults.
10:42:27 <LoganCapaldo> @remember monochrom I really like insults.
10:42:27 <lambdabot> It is stored.
10:42:44 * monochrom insults LoganCapaldo
10:43:26 <LoganCapaldo> @typ ?f . ?g
10:43:28 <lambdabot> forall b c a. (?f::b -> c, ?g::a -> b) => a -> c
10:43:52 <LoganCapaldo> @typ ?f ?a
10:43:54 <lambdabot> forall t t1. (?f::t -> t1, ?a::t) => t1
10:43:59 <LoganCapaldo> hehehee
10:44:20 <LoganCapaldo> @typ ?f ?g . ?h
10:44:22 <lambdabot> forall t b c a. (?f::t -> b -> c, ?g::t, ?h::a -> b) => a -> c
10:44:41 <firefly> Ah, the problem is that runghc Setup.hs build doesn't complete.
10:45:03 <LoganCapaldo> @type ?f ?. ?b
10:45:04 <firefly> It wants to (and needs to) compile four files for regex-base.
10:45:05 <lambdabot> Not in scope: `?.'
10:45:19 <LoganCapaldo> no implicit operators eh>
10:45:28 <firefly> It spews a screenful of warnings for the second one but does compile it to completion.
10:45:41 <firefly> it gives a single warning for the third one -- and then it stops.
10:46:01 <hpaste>  wli annotated "cubic Newton-like method" with "fixed up cubic Newton-like" at http://hpaste.org/3344#a1
10:46:10 <firefly> It does NOT produce a .hi file for the third of the .hs files.  The fourth is completely skipped.
10:46:34 <firefly> There are no error messages at all.
10:46:48 <dcoutts> firefly: I'd use regex-* 0.7*.0.1
10:47:28 <hpaste>  firefly pasted "cabal doesn't build all constituent modules" at http://hpaste.org/3812
10:47:34 <dcoutts> that is, regex-base-0.72.0.1 regex-posix-0.72.0.2 and regex-compat-0.71.0.1
10:47:58 <LoganCapaldo> > mconcat ["hello", "world"]
10:48:00 <lambdabot>  "helloworld"
10:48:07 <firefly> It's just I would like to play with "real" regexps :)
10:48:18 <LoganCapaldo> > msum ["hello", "world"]
10:48:19 <lambdabot>  "helloworld"
10:48:31 <LoganCapaldo> > concat ["hello", "world"]
10:48:32 <lambdabot>  "helloworld"
10:48:45 <LoganCapaldo> almost as many ways of spelling that as fmap
10:52:28 <dcoutts> firefly: that looks like a ghc bug to me
10:52:37 <dcoutts> firefly: if it's just a warning it should not fail
10:52:46 <dcoutts> firefly: I get the same behaviour
10:53:43 <firefly> dcoutts, I just tried compiling them individually (ghc -c xxx.hs) and they compile fine.
10:53:51 <firefly> Maybe it's different with optimization flags on?
10:54:32 <dcoutts> firefly: no, it's a ghc bug
10:54:36 <dcoutts> it works with ghc-6.6.1
10:54:54 <dcoutts> or if you delete the export that is says does nothing then it also works with ghc-6.8.1
10:55:16 <firefly> aha.  Why can I compile them individually, then?
10:55:37 <dcoutts> firefly: dunno
10:56:15 <firefly> ghc -c Text/Regex/Base.hs has an exit code of 0 so that can't be why the cabal compile wrapper stops.
10:57:19 <DRMacIver> Hm. I am right in thinking that the basic H98 type system is fully inferrable, right?
10:57:28 <DRMacIver> It's the various additions that can make it go strange.
10:58:09 <DRMacIver> Oh, hm. No, I'm not.
11:00:02 <monochrom> show (read "x") is uninferrable.
11:00:45 <firefly> dcoutts: I'm a bit wiser now and less mystified now.  You were of course completely right, it's a ghc bug.
11:00:46 <monochrom> In general, remove typeclasses and you get inferrable again.
11:01:00 <DRMacIver> Right. That's what I realised.
11:01:07 <firefly> (I discovered runghc Setup.hs build -v which prints out the command lines it runs)
11:01:15 <DRMacIver> (although not that specific example)
11:01:33 <nbb> won't polymorphic recursion examples still require type annotations?
11:02:18 <monochrom> what is polymorphic recursion examples?
11:03:07 <nbb> roughly, you can declare a, say, 5-parameter function and make recursive calls with 6 parameters
11:03:28 <nbb> this is because the actual type is forall a. .... 5 args ... -> a
11:03:40 <twanvl> polymorphic recursion is like recursion, but using the function being defined with another type
11:03:51 <nbb> so if a is actually b -> c the 6th parameter appears
11:04:10 <monochrom> Like "f x = f x x"?
11:04:16 <dcoutts> firefly: I've filed a bug: http://hackage.haskell.org/trac/ghc/ticket/1871
11:04:17 <lambdabot> Title: #1871 (compile warning appears to be treated as error) - GHC - Trac
11:04:26 <mrd> it makes more sense if you write the type-lambdas and type-apps explicitly
11:05:12 <monochrom> Is polymorphic recursion allowed in H98?
11:05:49 <nbb> not sure, but if you provide a type annotation maybe yes?
11:06:04 <SamB_XP> I think so
11:06:16 <nbb> like f :: a -> b for the f above
11:06:26 <SamB_XP> you could try that datastructure from Purely Functional Datastructures...
11:06:27 <twanvl> h98 report says: "Type signatures can also be used to support polymorphic recursion."
11:06:29 <firefly> Thank you, dcoutts! :)
11:06:44 <dcoutts> np
11:06:52 <monochrom> Thanks.
11:08:10 <byorgey> yes, H98 supports polymorphic recursion, but only with explicit type signatures I think.
11:08:28 <byorgey> oh, I didn't see twanvl already said that =)
11:12:41 <nbb> @type let f :: a -> b ; f x = f x x in f
11:12:43 <lambdabot> forall a b. a -> b
11:12:47 <nbb> @type let f x = f x x in f
11:12:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
11:12:49 <lambdabot>     Probable cause: `f' is applied to too many arguments
11:12:49 <lambdabot>     In the expression: f x x
11:14:01 <thoughtpolice> hm, is the purpose of rank polymorphism mainly to have polymorphic functions which accept polymorphic functions? (reading the generics papers right now)
11:16:08 <twanvl> it is not the purpose, it is the definition. A function is rank 2 polymorphic if it has a rank 1 polymorphic parameter
11:19:52 <jder> Can anyone explain to me why the commented type decl in this snippet is needed? http://hpaste.org/3813
11:20:13 <dons> otherwise its ambiguous which monad you're in?
11:20:16 <allbery_m> monomorphism restriction, probably
11:21:03 <thoughtpolice> twanvl: hm alright. kind of a recursive definition but I tried a few examples in ghci so it makes sense. :)
11:21:04 <jder> huh. Ok, thanks. I'll look around.
11:25:39 <_roconnor> @go 1 CAD in USD
11:25:41 <lambdabot> 1 Canadian dollar = 1.071123 U.S. dollars
11:26:33 <firefly> @go 1 Euro in USD
11:26:33 <dons> Igloo: around?
11:26:34 <lambdabot> 1 Euro = 1.4698 U.S. dollars
11:26:44 <gvdm> @go 1 NZD in USD
11:26:45 <lambdabot> 1 New Zealand dollar = 0.7737 U.S. dollars
11:26:49 <dons> @go 1 AUD in USD
11:26:50 <lambdabot> 1 Australian dollar = 0.9225 U.S. dollars
11:26:54 <dons> rockin!
11:27:33 <gvdm> we used to be impressed when we got over .7
11:27:33 <firefly> @go 1 DKR in USD
11:27:37 <lambdabot> http://en.wikipedia.org/wiki/Danish_krone
11:27:37 <lambdabot> Title: Danish krone - Wikipedia, the free encyclopedia
11:27:44 <dons> heh
11:27:48 <dons> gvdm: yeah.
11:27:52 <gvdm> nowadays it seems like everybody is kicking the USD
11:27:52 <firefly> @go how much is 1 DKR in USD
11:27:53 <Igloo> dons: ish
11:27:54 <lambdabot> http://en.wikipedia.org/wiki/Humanitarian_response_to_the_2004_Indian_Ocean_earthquake
11:27:54 <lambdabot> Title: Humanitarian response to the 2004 Indian Ocean earthquake - Wikipedia, the free  ...
11:28:15 <dons> Igloo: version numbering issue. X11-1.3.0 in darcs has an api change, and will get tagged as 1.4.0 when release
11:28:22 <dons> but do we have a scheme for the unstable branches?
11:28:36 <dons> 1.3.9? 1.3.0.20071109 ?
11:29:18 <gvdm> 1.3.9 doesn't work, just now you need 9 or more releases in a given release cycle
11:29:39 <dons> well, not really. its bigger than 1.3.0 and smaller than 1.4.0
11:29:43 <dons> which is all that matters
11:30:03 <Igloo> dons: We don't have a scheme currently
11:30:26 <dons> what do you do with the ghc and base lib branches?
11:31:32 <Igloo> Leave the version number as the last released version until the next release, currently
11:31:46 <Igloo> dons: Oh, BTW, you wanted X11 to leave extralibs, right?
11:32:24 <dons> yeah, i think so.
11:32:30 <dons> i'm happy to distribute it via hackage
11:32:44 <dons> well, we need to bump it since darcs xmonad depends on darcs X11
11:32:56 <dons> so leaving at 1.3.0 doesn't work, it would lead to a type error
11:33:34 <phlpp> @go 1 EUR in USD
11:33:36 <lambdabot> 1 Euro = 1.4698 U.S. dollars
11:36:12 <firefly> @go 1 DKK in USD
11:36:13 <lambdabot> 1 Danish krone = 0.197188 U.S. dollars
11:36:20 * firefly got it wrong before
11:36:27 <firefly> getting there...
11:36:30 <chessguy> @go 1 limpira in USD
11:36:36 <lambdabot> http://www.frommers.com/cgi-bin/WebX?13@52.GTeecMpqaIa%5E0@.eed2d32
11:36:37 <lambdabot> Title: Travel Talk - Info on Roatan
11:36:40 <firefly> @go 1 PTS in USD
11:36:41 <chessguy> boo!
11:36:43 <lambdabot> http://www.onjava.com/pub/a/onjava/2002/09/04/ejbinherit.html
11:36:43 <lambdabot> Title: ONJava.com -- EJB Inheritance, Part 1
11:37:00 <byorgey> what's a limpira?
11:37:24 <firefly> @go 1 YEN in USD
11:37:26 <lambdabot> http://www.x-rates.com/d/JPY/USD/data30.html
11:37:26 <lambdabot> Title: Exchange Rates Data (American Dollar, Japanese Yen)
11:37:35 <firefly> @go 1 JPY  in USD
11:37:36 <lambdabot> 1 Japanese yen = 0.008941 U.S. dollars
11:37:37 <chessguy> limpira is the currency in honduras
11:38:09 <firefly> @go 1 HNL in USD
11:38:10 <lambdabot> 1 Honduran lempir = 0.052957 U.S. dollars
11:38:14 <wilx> @go 1 USD in JPY
11:38:15 <lambdabot> 1 U.S. dollar = 111.844313 Japanese yen
11:38:17 <chessguy> oh, nice
11:38:29 <firefly> @go 1 ISK in USD
11:38:30 <lambdabot> 1 Iceland krona = 0.016734 U.S. dollars
11:38:49 <firefly> @go 1 ESP in USD
11:38:52 <lambdabot> http://fxtop.com/en/cnvhisto.php3?C1=ESP&B=2
11:38:52 <lambdabot> Title: fxtop.com currency converter in the past
11:38:54 <bos31337> we need to give a name to the style of function chaining in which the parameters of a function hang at the end of a line with their arrow, followed by the fnuction body on the next line.
11:39:07 <Adamant> I'm surprised nobody has tried doing ducats to dollars
11:39:13 <chessguy> bos31337, huh?
11:39:17 <Adamant> but I guess that's not a current currency
11:39:40 <firefly> bos31337: Schönfinkelization
11:39:51 <chessguy> bos, can you give an example?
11:39:57 <firefly> or Fregation, perhaps.
11:40:05 <bos> chessguy: as in "\p ->\n  body"
11:40:23 <firefly> there's not much chaining in that.
11:40:23 <chessguy> oh, you're talking about layout
11:40:33 <firefly> Lambda, anyway.
11:40:34 <bos> firefly: i was thinking about the visual style more than the actual practice.
11:40:47 <bos> "hanging lambdas"
11:40:51 <SamB_XP> who does that?
11:41:02 <bos> SamB_XP: almost everyone?
11:41:18 <byorgey> SamB_XP: all the cool kids
11:41:22 <byorgey> =)
11:41:23 <SamB_XP> I do
11:41:26 <sclv> expressive vs. declarative style?
11:41:28 <SamB_XP> \p n -> body
11:41:41 <firefly> Ah, I get it.  The second \ escaped the n to indicate a newline.  Sorry.
11:41:52 <chessguy> @slap SamB_XP
11:41:52 * lambdabot jabs SamB_XP with a C pointer
11:41:54 <SamB_XP> oh
11:42:06 <SamB_XP> that was not a good choice of notation!
11:42:09 <firefly> lambda lifting?
11:42:26 <firefly> broken lambdas?
11:42:27 <byorgey> I like "hanging lambdas" =)
11:42:50 <firefly> but it's not really the lambda that's hanging.  It's the body.
11:42:52 <SamB_XP> I call it "what you do when your lambda is too long to fit on just one line"
11:42:54 <bos> the hanging lambdas of babylon.
11:43:07 <firefly> fractured function?
11:43:13 <nbb> run-on-lambdas
11:43:16 <sclv> it's handy because then you can just say "hang a lambda off that withData call" etc.
11:43:51 <chessguy> i think i've seen it most often in expressions like flip map [1..n] $ \i -> ...
11:43:54 <sclv> it sounds like a skate move.
11:44:02 <SamB_XP> bos didn't say anything about withFoo $
11:44:43 <byorgey> SamB_XP: yes, but that's often the sort of context where it gets used.
11:44:56 <SamB_XP> true
11:45:40 <byorgey> firefly: well, the lambdas are "hanging" in the same sense that someone who is hoping for a high five might be "left hanging"...
11:47:43 <SamB_XP> byorgey: are you implying they won't ever get called?
11:48:25 <byorgey> SamB_XP: no, just being silly
11:48:49 <byorgey> they get called, but from across the room so they can't get a high-five
11:48:55 <wli> I daresay that if you overflow 80 columns with 8-column tabs you need to break up whatever's blowing past 80 columns.
11:50:01 <shapr> @yow !
11:50:01 <lambdabot> Hello, GORRY-O!!  I'm a GENIUS from HARVARD!!
11:50:16 <byorgey> sclv: heh.  "wow, didja see that 540 triple grind hanging lambda!?"
11:50:51 <bos> well, we don't use tabs in haskell-land, anyway.  people who use tabs are condemned to obscurity and forced to go back to hacking on the freebsd kernel.
11:51:23 <thetallguy> I have a cabal file with an extensions field that seems out of date.  Any pointers on what it should be updated to?
11:52:09 <wli> I've never done much with the freebsd kernel. I stick to the Linux kernel.
11:52:13 <bos> thetallguy: more info?
11:52:22 <bos> wli: hence "condemned to obscurity"
11:52:38 <sclv> byorgey: "and then he fanned out a double flip with a lift!"
11:52:43 <bos> though maybe that would be hacking on the plan9 kenel
11:52:43 <thetallguy> runhaskell Setup configure
11:52:43 <thetallguy> Setup: haifa.cabal:22: Parse of field 'extensions' failed:
11:52:50 <byorgey> sclv: sweet!!!
11:52:55 <thetallguy> Ah, I was assuming that mean extensions had been deprecated
11:53:03 <thetallguy> perhaps the contents are just bogus
11:53:10 <wli> The closest thing to a BSD kernel I've ever dealt with is DYNIX/ptx.
11:53:13 <bos> thetallguy: right. are you using ghc 6.8.1?
11:54:01 <thetallguy> no, sitll 6.6
11:54:14 <thetallguy> Extensions:
11:54:14 <thetallguy>         MultiParamTypeClasses,
11:54:14 <thetallguy>         FunctionalDependencies,
11:54:14 <thetallguy> 	AllowUndecidableInstances,
11:54:14 <thetallguy>         TemplateHaskell
11:54:28 <bos> thetallguy: the indentation is off. i believe cabal cares about that.
11:54:47 <wli> I never did do much with DYNIX/ptx. The closest thing to an accomplishment there was FibreChannel boot testing, which didn't really involve any code.
11:54:51 <bos> it certainly cares as of 1.2, don't know about earlier
11:55:20 <thetallguy> there are spaces in all, tab in the AllowUndecidable, but fixing that still gives the same error
11:56:04 <thetallguy> putting it all on one line didn't help either
11:56:31 * wli generally fixes such things by converting all multi-space -based indentation to tabs.
11:57:41 <bos> thetallguy: there's not an "Allow" on the front of "UndecidableInstances"
11:58:06 <thetallguy> Ah, thanks.
11:58:43 <bos> you'll find -fallow- on the front of stuff when you're explicitly passing arguments to ghc on the command line, which is probably where that mistake crept in from
11:58:44 * thetallguy muses if that wouldn't be clearer if the cabal file were compilable Haskell
11:59:06 <wli> (I didn't really accomplish much in AIX, either.)
11:59:08 <bos> just say no to turing-complete package specifications.
12:00:12 * firefly hacked a bit on Autopackage
12:00:33 <thetallguy> bos: I didn't suggest that
12:01:02 <thetallguy> bos: but I would counter with, just say no to yet another poorly constructed parser/type.
12:01:12 <thetallguy> bos: with really lame error messages.
12:01:16 <wli> bos: Good idea for a language: a terminating lazy FPL with no IO.
12:02:07 <wli> bos: Use it for setting up data structures like config files with heavy abbreviation.
12:02:37 <bos> wli: sendmail.cf? :-)
12:02:57 <wli> bos: I was hoping for a subset of Haskell.
12:04:05 <thetallguy> wli: sounds right
12:04:12 <bos> thetallguy: did cabal not say which field it was barfing on?
12:04:26 <thetallguy> it did not
12:04:34 <thetallguy> in fact, it said 'parse error'
12:04:37 <bos> thetallguy: if not, you should file a bug. the cabal folks are obliging types.
12:04:38 <thetallguy> not the latest cabal
12:04:56 <visof> > pairs [1,2,3,4]
12:04:57 <lambdabot>   Not in scope: `pairs'
12:05:19 <thetallguy> My bug would read: cabal spec shoul be a terminating lazy FPL with no IO, subset of Haskell.
12:05:23 <thetallguy> ;-)
12:05:30 <TomMD> > head $ nub $ map (\_ -> 1) [1,2,3,4]
12:05:31 <lambdabot>  1
12:05:39 <thetallguy> bos: I will try it on the latest and then submit a bug if necessary
12:05:41 <sorear> thetallguy: If it's terminating, why lazy?
12:05:49 <atomiku> Huh, whats this?
12:05:53 <atomiku> Programming language?
12:05:58 <thetallguy> sorear: because I was quoting wli
12:06:05 <mrd> atomiku: actually its guys named Haskell
12:06:11 <sorear> atomiku: Yes.  See the topic.
12:06:17 <TomMD> atomiku: haskell.org
12:06:27 <sorear> atomiku: In particular the ","http://haskell.org "," bit.
12:06:29 <lambdabot> Title: Haskell - HaskellWiki
12:06:54 <wli> sorear: So erroring partial functions aren't strictly evaluated etc.
12:07:16 <atomiku> Strange...
12:07:20 <thetallguy> For me, it's really more about reusing the same syntax, parser and error messages
12:07:22 <sorear> atomiku: what?
12:07:27 <byorgey> atomiku: it's one of the coolest programming languages ever.  want to learn it?
12:07:29 <atomiku> just looking at the syntax :D
12:07:33 <atomiku> I might have a go
12:08:02 <TomMD> > reverse "atomiku"
12:08:04 <lambdabot>  "ukimota"
12:08:14 <TomMD> ^ that is necessary so you can think in a functional manner.
12:08:32 <atomiku> Hmm
12:08:35 <atomiku> > "lol"
12:08:37 <lambdabot>  "lol"
12:08:38 <wli> Syntax matters. Sexy syntax can make a language and ugly syntax can break it.
12:08:42 <byorgey> > map pred "atomiku"
12:08:42 <atomiku> Oh right, clever
12:08:43 <lambdabot>  "`snlhjt"
12:09:06 <atomiku> > ['H', 'e', 'l', 'l', 'o']
12:09:07 <lambdabot>  "Hello"
12:09:13 <atomiku> Heh
12:09:19 <thetallguy> > map succ "atomiku"
12:09:20 <lambdabot>  "bupnjlv"
12:09:30 <atomiku> so umm
12:09:43 <audreyt> > let 1 + 1 = "atomiku" in 1 + 1
12:09:44 <lambdabot>  "atomiku"
12:09:52 <TomMD> @let sayToAtomiku s ="automiku: " ++ s
12:09:58 <lambdabot> Defined.
12:10:09 <TomMD> > sayToAutomiku "Lambdabot is fun"
12:10:10 <lambdabot>   Not in scope: `sayToAutomiku'
12:10:11 <atomiku> everyone types my name as automiku :(
12:10:27 <TomMD> Damn bot
12:10:40 <Saizan_> 1> sayToAtomiku "Lambdabot is fun"
12:10:45 <Saizan_> > sayToAtomiku "Lambdabot is fun"
12:10:46 <lambdabot>  "automiku: Lambdabot is fun"
12:10:52 <TomMD> Yes, I saw.
12:11:04 <TomMD> We need to make lambdabot do spelling corrections.
12:11:09 <thoughtpolice> > map pred "mbncebcpu!jt!gvo"
12:11:10 <lambdabot>  "lambdabot is fun"
12:11:21 <atomiku> > map lol "what"
12:11:22 <lambdabot>   Not in scope: `lol'
12:11:40 <Deewiant> > pred
12:11:41 <lambdabot>  Add a type signature
12:11:41 <TomMD> > map (+1) [1,2,3,4,555]
12:11:42 <lambdabot>  [2,3,4,5,556]
12:11:48 <byorgey> > delete 'u' $ sayToAtomiku "Lambdabot is fun"
12:11:49 <lambdabot>  "atomiku: Lambdabot is fun"
12:12:52 <sorear> Is the Internet Archive down?
12:12:52 <Deewiant> @type pred
12:12:54 <lambdabot> forall a. (Enum a) => a -> a
12:13:12 <Deewiant> not to me
12:13:17 <shachaf> sorear: archive.org seems to work for me.
12:13:27 <sorear> shachaf: Try looking something up.
12:13:34 <sclv> > pred False
12:13:35 <lambdabot>  Exception: Prelude.Enum.Bool.pred: bad argument
12:13:37 <sorear> The front page loads fine.
12:13:45 <sclv> > pred True
12:13:46 <lambdabot>  False
12:13:55 <shachaf> sorear: The Wayback Machine also seems to work.
12:13:56 <Deewiant> > pred '\0'
12:13:57 <lambdabot>  Exception: Prelude.Enum.Char.pred: bad argument
12:14:06 <TomMD> > pred False
12:14:08 <lambdabot>  Exception: Prelude.Enum.Bool.pred: bad argument
12:14:09 <Deewiant> > pred ('\0' + 1)
12:14:10 <lambdabot>   add an instance declaration for (Num Char)
12:14:13 <shachaf> sorear: If that's what you mean: http://web.archive.org/web/20060816200301/http://www.google.com/
12:14:15 <sorear> oh, it's just EXTREMELY SLOW
12:14:20 <sclv> > pred '0'
12:14:21 <lambdabot>  '/'
12:14:28 <sclv> > succ '9'
12:14:29 <lambdabot>  ':'
12:14:30 * sorear comes back in a minute and sees a result
12:14:35 <Deewiant> > succ '\0'
12:14:36 <lambdabot>  '\SOH'
12:14:43 <sorear> @go ASCII
12:14:45 <lambdabot> http://www.asciitable.com/
12:14:45 <lambdabot> Title: Ascii Table - ASCII character codes and html, octal, hex and decimal chart conve ...
12:15:13 <Deewiant> > map succ ['a'..'z']
12:15:14 <lambdabot>  "bcdefghijklmnopqrstuvwxyz{"
12:16:54 <firefly> gave up on cabal with 6.8.1.
12:17:02 <firefly> Got it all up and running with 6.6.1.
12:17:12 <TomMD> I just darcs pull everything I need
12:17:30 <firefly> cabal update; cabal install regex-pcre worked!
12:17:45 <TomMD> I bet he didn't see that coming.
12:23:51 <diltsman> I'm having trouble getting this haskell mode for vim plugin working.  Anybody think they might be able to help me with it?
12:32:29 <hpaste>  dikini pasted "any ideas how to improve?" at http://hpaste.org/3814
12:33:25 <dikini> I'm playing with a erlangish send receive, but if I do a guarded message reception things go ugly
12:33:30 <shapr> @hoogle String -> [Element]
12:33:31 <lambdabot> No matches, try a more general search
12:36:38 <shapr> How do I turn a string into [Element] with HaXml?
12:36:45 <shapr> I used to know how to do this...
12:37:15 <Lemmih> shapr: Why do we depend on Crypto?
12:37:39 <shapr> Lemmih: There's some good reason, but I forget exactly why. You can remove it and rebuild to see :-)
12:39:47 <shapr> Lemmih: I'm trying to parse a Google Calendar feed, what's the best way to get [Element] from a String?
12:40:42 <thoughtpolice> hm, i'm getting ghc 6.8.1, xmonad et al. set up on my freebsd box which is offline... anybody have any recommendations of what would be good to install? (already got haskell-mode)
12:41:15 <Lemmih> shapr: Is it RSS or Atom?
12:41:18 <shapr> Atom
12:41:24 <shapr> Though I think I can get RSS
12:41:45 <Lemmih> shapr: Doesn't HAppS have an Atom parser?
12:42:26 <shapr> Yeah, I'm trying to use it, but there's nothing obvious about how to parse a string.
12:43:03 * monochrom finally removes his installation of 6.4.2
12:43:43 <monochrom> Oh, and 6.6 :)
12:44:21 <shapr> Lemmih: Any ideas how to use that Atom parser?
12:44:36 <Lemmih> shapr: Nope.
12:44:40 <shapr> foo
12:44:57 <thetallguy> shapr: have you looked at the sample code in the haxml dist?
12:44:59 <shapr> Any ideas how to parse Xml with HAppS in general?
12:45:16 <thetallguy> I've just been wading through those
12:45:34 <shapr> thetallguy: Not yet, I'm not sure if that's what I need. I can't quite figure out how HAppS does XML parsing.
12:46:11 <dons> someone want to port   this to haskell, http://blog.fishsoup.net/2007/11/10/reinteract-better-interactive-python/ ?
12:46:14 <lambdabot> Title: Reinteract - Better interactive Python  fishsoup, http://tinyurl.com/22vo5p
12:47:37 <shapr> dons: Does Pivotal already do something like that?
12:48:08 <thetallguy> dons: no, but implement something like it, yes.
12:48:28 <dons> something like it, yes.
12:48:41 <thetallguy> dons: I've been discussing concepts like that with Conal
12:49:11 <dons> dcoutts: i updated cabal, cabal-setup, cabal-install but it tried to pull base 3.0 and failed when doing a : cabal install haskell-src (so cabal-install/ ghc 6.6 failed?)
12:49:22 <newsham> dons: that python thing looks interesting, but lisp machines had an interface like that long time ago that was probably more advanced.
12:49:30 <newsham> if anything people should look their for inspiration
12:49:51 <dons> the lisp guys don't use the internet though
12:49:57 <ADEpt> or Mathematica notebooks ...
12:50:18 <thetallguy> Bah, Lisp people did everything before the dinosaurs died out
12:50:23 <newsham> you can find copies of the lispm system (genera) online, as well as videos demonstrating how the system works and what it can do
12:50:46 <newsham> there's a small #lispm (or was) on freenode
12:51:21 <dons> dcoutts: so 6.6/darcs cabal/darcs cabal install,
12:51:22 <dons> dons@haskell:~/lambdabot$ cabal install QuickCheck
12:51:22 <dons> 'base-3.0.0.0' is cached.
12:51:22 <dons> Data/List.hs:18:1: lexical error at character 'i'
12:51:40 <waern> cpp
12:52:03 <sorear> @users
12:52:03 <lambdabot> Maximum users seen in #haskell: 424, currently: 400 (94.3%), active: 15 (3.8%)
12:52:10 <dons> right, but its 6.6, so shouldn't be looking for base 3 anyway
12:52:23 <waern> ah
12:55:22 <dons> so getting a blank box into a state such that it can build lambdabot is pretty painless, i have to say, considering it requires:
12:55:26 <dons>     Cabal-1.3, HTTP-3001.0.0, QuickCheck-1.1.0.0, Stream-0.2.2,
12:55:28 <dons>     arrows-0.3, binary-0.4.1, filepath-1.1.0.0, haskell-src-1.0.1.1,
12:55:31 <dons>     zlib-0.4.0.1
12:55:33 <dons> so cabal-install working with 6.6 would help here, but everything worked.
12:55:39 <dons> despite manual dependency resolution
12:55:52 <dons> good job by Igloo, dcoutts, nominolo and all the cabal hackers
12:56:43 <nominolo> bringert did most of the work on cabal-install iirc
12:56:46 <newsham> any reason 6.6?
12:56:50 <dons> and bringert, yes.
12:56:56 <dons> newsham: oh, that's what's on code.haskell.org :)
12:57:16 <dons> though cabal-install is the bit that broke :)
12:57:55 <bos> beautiful quote on refereeing papers: "It would be unfair to compare the author's methodological advice to enjoining us to remember to breathe; it is more like reminding us not to hold forks by their pointy ends, which rather go into the food."
12:58:30 <bos> haskell: teaching programmers not to hold the fork by the pointy end
12:59:13 <newsham> except programming has a dozen sides, and points on almost all of them
12:59:29 <newsham> much easier to fork yourself
13:01:05 <hpaste>  dikini annotated "any ideas how to improve?" with "slightly better, I think, but could it be improved?" at http://hpaste.org/3814#a1
13:03:50 <newsham> dkini: what is the type of "guard"?
13:04:10 <Beelsebob> @type guard
13:04:11 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:04:22 <newsham> guarded_receive ainfo guard =
13:04:27 <dikini> AInfo a b -> Bool
13:04:35 <dikini> oops
13:04:42 <dikini> should be the type of message
13:05:06 <dikini> and I forgot to unwind the back channel
13:05:14 <newsham> (Message a b -> Bool) ?
13:05:19 <dikini> yep
13:08:05 <newsham> why define "back_channel = newChan" ?  you're writing these things to a new channel but does anyone ever read them?
13:08:28 <dikini> I forgot in this revision :(
13:09:03 <dikini> is it safe to use bracket to wrap the ungetting of the back_channel?
13:09:15 <newsham> guarded receive is supposed to only receive matching messages and leave the others in queue?
13:09:15 <therp> OT: anyone with full access to LNCS here (via university subscription)?
13:09:22 <dikini> yes
13:09:31 <sorear> newsham: back_bhannel = newChan des nothing useful
13:09:37 <newsham> what happens when the queue only contains messages that do not match the guard?  you're spinning in a tight loop waiting?
13:09:39 <dikini> I try to replicate the erlang receive
13:09:53 <sorear> newsham: it just creates an alias of newChan
13:09:54 <newsham> sorear: yes, hence the question
13:10:22 <dikini> at the moment it will end waiting on the 'main' channel
13:11:05 <dikini> me stupid
13:11:37 <newsham> i think you want to have a channel that says "a new message is ready" and then when that channel gets triggered, try to pull data off of the data channel, if one matches, return it, if none match, requeue them all and wait again on the "new message available" channel
13:12:52 <newsham> hmm.. i have an idea of how to do this but its more of a traditional queue with lock type approach..
13:13:21 <dikini> newsham: I want to try to avoid locks
13:13:27 <dons> "If you grep for `girlfriend' or `wife' or the
13:13:27 <dons> like in the #haskell logs, you will get more lines - nay, more conversations -
13:13:27 <dons> returned than from the #ruby-lang logs. More, even, than in the #girlfriends
13:13:27 <dons> logs"
13:13:43 <dons> "It gets worse when you grep #haskell-blah."...
13:13:50 <mrd> what -blah logs?
13:14:02 <newsham> read entire queue, if something matches, return it, if not wait on new messages channel and then repeat
13:14:05 <newsham> that kinda thing
13:14:14 <dons> http://freeshells.ch/~revence/myths.txt :)
13:14:39 <sieni> mrd: the ones that lambdabot dumps to dons's hard drive ,-)
13:14:52 <newsham> dons: is that sort of like car salesmen using the word "honest" more often?
13:15:03 <newsham> ;-)
13:15:45 <dikini> I was thinking of checking for isempty, or whatever was the right function on channels, if yes then just return emptyhanded, otherwise loop through the que, if it empties, and there is still nothing, restore everything ang bail out
13:16:14 <newsham> the trying to grab stuff, restoring if cant sounds kinda like stm
13:16:22 <dikini> isEmptyChan
13:16:50 <jakub2007> hi, I'm having trouble compiling Chart (the latest version from hackage) runghc Setup.hs build says ghc-6.6.1: unknown package: mtl (dependency of gtk-0.9.12) however I do have mtl installed - I'm using gentoo - anybody any idea?
13:16:53 <dikini> yes, it does, but I have no clue how or what exactly it does
13:16:56 <newsham> tried google for guarded channel haskell yet?
13:17:26 <dikini> not these exact words
13:17:39 <chessguy> @bot
13:17:44 <newsham> dikini: http://www.haskell.org/haskellwiki/Video_presentations#Concurrency_and_parallelism
13:18:04 <dons> never fear... lambdabot is on her way!
13:18:17 <dikini> missed that one, thanks
13:18:47 <dons> ?uptime
13:18:52 <lambdabot> uptime: 13s, longest uptime: 1m 10d 23h 44m 29s
13:19:02 <dons> ?version
13:19:10 <lambdabot> lambdabot 4p578, GHC 6.6 (Linux i686 2.40GHz)
13:19:16 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:19:18 <dons> > map (^2) [1..]
13:19:25 <LoganCapaldo> ah man
13:19:26 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
13:19:36 <dons> just moved her to the usa.
13:19:42 <LoganCapaldo> when you did the ?version I was half expecting 6.8
13:19:55 <dons> no, sorry. 6.6 still (depends on plugins, which depends on cabal 1.1.6)
13:19:55 <shachaf> dons: Where is she now?
13:19:59 <shachaf> dons: At Galois?
13:19:59 <dons> code.haskell.org
13:20:04 <dons> nope
13:20:06 <shachaf> OK.
13:20:10 <dons> the galois firewall was a pain
13:20:30 <Igloo> Hmm, I wonder if we can get reverse DNS set up
13:20:44 <dons> ?go haskell
13:20:46 <lambdabot> http://www.haskell.org/
13:20:47 <lambdabot> Title: Haskell - HaskellWiki
13:20:54 <dons> ?quote lambda
13:20:54 <lambdabot> Binkley says: It's more fun than kicking puppies, even, since puppies don't tend to say nonsensical things about lambda calculus.
13:21:10 <dons> ?users
13:21:11 <lambdabot> Maximum users seen in #haskell: 401, currently: 401 (100.0%), active: 4 (1.0%)
13:21:15 <dons> boo
13:21:21 <dons> must not have copied all the state
13:21:46 <ddarius> Nah, we just count differently in America.
13:21:51 <dons> heh
13:21:53 <LoganCapaldo> lambdabot and state seem to have a rock relationship
13:21:59 <LoganCapaldo> s/rock/rocky
13:22:09 <ddarius> She would.
13:22:44 <nominolo> hm, how can i parsec convince to parse a grammar like:  T ::= "int" | T "*"  ?
13:22:55 <nominolo> i get a stack overflow
13:22:58 <sorear> nominolo: chainl1
13:23:07 <sorear> er, chainl
13:23:08 <Saizan_> left recursion evilness!
13:23:31 <sorear> nominolo: rewrite it as T ::= "int" modifier;  modifier = "*" *;
13:23:56 <LoganCapaldo> The existance of chainl impresses me but I prefer the second option
13:24:02 <newsham> or use a parser generator that doesnt require you to massage a grammar
13:24:15 <newsham> we have the technology
13:24:17 <sorear> newsham: there is such a thing?
13:24:38 <newsham> there is
13:24:42 <nominolo> newsham: Happy is buggy
13:25:03 <nominolo> newsham: or at least I got a very bad error message
13:25:08 <nominolo> sorear: thanks, i'll try that
13:25:56 <sorear> newsham: I'd like an example; every one I've tried has arbitrary restrictions (Frown can only handle LR(k), etc)
13:26:18 <newsham> sorear: GLR parsers allow you to parse arbitrary grammars without restriction
13:26:24 <LoganCapaldo> GLR would not require any grammar massagery no?
13:26:26 <sorear> no
13:26:33 <sorear> arbitrary *context free* grammars
13:26:50 <newsham> yes, I am implicitely talking of CFGs
13:26:57 <sorear> I challenge you to parse { a^k b^k c^k | k <- [0..] } with GLR
13:27:11 <ddarius> I can with Parsec
13:27:31 <newsham> [11:25] < newsham> yes, I am implicitely talking of CFGs
13:27:41 <ddarius> Of course, it would be easier with just Haskell
13:27:48 <sorear> newsham: or better yes
13:27:50 <sorear> *yet
13:28:03 <sorear> newsham: { a^k b^k | k <- [0..] } with GLR
13:28:20 <sorear> newsham: that's context free - but you'll need to *gasp* massage it
13:28:34 <newsham> nah, I can parse a^k b^k just fine
13:28:38 <Saizan_> are we assuming linear complexity? if not we have ReadP
13:28:52 <newsham> thats simple parenthesis parsing
13:29:03 <sorear> 13:23 < newsham> or use a parser generator that doesnt require you to massage a grammar
13:29:06 <newsham> S = a S b | epsilon
13:29:12 <sorear> that's massaging
13:29:15 <newsham> works just fine in my GLR
13:29:21 <newsham> thats a grammar.
13:29:25 <newsham> your set notation is not a grammar
13:29:26 <sorear> my original grammar was non-recursive
13:30:19 <LoganCapaldo> presumable you coudl have GLR parser generator that understood sorear's notation
13:30:21 <newsham> give me terminals, non terminals, productions, starting symbol
13:30:35 <newsham> i'll let you use EBNF extensions if you wish
13:30:42 <nominolo> hm.  maybe i should still try using happy ... whitespace handling will become a nightmare with parsec
13:31:02 <newsham> logan: sure, but that falls outside of the normal definition of a grammar.
13:31:07 <ddarius> nominolo: Why do you say that?
13:31:12 <waern> nominolo: what are you parsing?
13:31:12 <Saizan_> nominolo: you should handle that in the lexer maybe?
13:31:16 <nominolo> ddarius: because i tried it
13:31:23 <nominolo> waern: LLVM assembly files
13:31:29 <fasta> Why isn't "A" told to the WriterT in http://paste.debian.net/42132?
13:31:35 <waern> nominolo: ok
13:31:46 <nominolo> Saizan_: yep, maybe i should use lexer + parsec
13:32:29 <nominolo> ddarius: do you know a nice ideom for: "skip empty lines or lines that only contain comments" ?
13:32:45 <nominolo> ddarius: and chop all trailing whitespace/comments
13:33:09 <ddarius> Using the token parsers should do that automatically.
13:33:15 <nominolo> ddarius: using a pre-pass can mess up line numbers, so you have to be careful
13:33:26 <newsham> ?type lexeme
13:33:27 <nominolo> ddarius: yes, a token parser could be useful
13:33:29 <lambdabot> Not in scope: `lexeme'
13:35:35 <fasta> Never mind, I answered the question myself.
13:35:41 <newsham> isnt there a combinator for throwing away whitespace?
13:35:57 <ddarius> All the token parsers do that.
13:36:22 <newsham> i mean for when you're not using the token parser
13:36:43 <ddarius> newsham: Yes, use the stuff the token parsers are implemented with.
13:36:52 <fasta> Don't you need to write two parsers for a real compiler anyway? One containing perfect error messages and slow and one blazingly fast?
13:36:58 <newsham> arbitrarily breaking the problem up into lexer and parser breaks modularity.  you cant just embed one grammar within another.
13:37:16 <newsham> when both are specified directly as parsers they compose.
13:37:38 <nominolo> fasta: for LLVM you use the binary format if you want speed
13:37:46 <nominolo> fasta: so i don't care (yet)
13:38:00 <newsham> (unless the two parsers have compatible lexers, then they're composable still)
14:32:52 <shapr> Well, I've found two Atom.hs output libraries, but zero Atom parsing libraries :-(
14:33:44 <ramza3> general comment; I love this tutorial; http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
14:33:45 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
14:34:11 <ddarius> shapr: That means you can be the first!
14:39:08 <lekro> how can I get one Handle for stdin and stdout?
14:39:34 <lekro> that I can use for things like (hReadLine handle) and (hPutStrLn handle)
14:40:33 <thoughtpolice> import System.IO
14:40:35 <newsham> ?type stdin
14:40:36 <lambdabot> Not in scope: `stdin'
14:40:39 <newsham> ?hoogle stdin
14:40:40 <lambdabot> IO.stdin :: Handle
14:40:49 <allbery_m> why do you want a single shared handle for that?
14:40:52 <lekro> I can use stdin for hPutStrLn?
14:41:00 <lekro> allbery_m: socket handles work the same
14:41:22 <newsham> Prelude> :module +System.IO
14:41:22 <newsham> Prelude System.IO> hPutStrLn stdout "test"
14:41:22 <newsham> test
14:41:29 <lekro> the ones I get with socketToHandle sock ReadWriteMode
14:42:54 <allbery_m> you could use System.Posix.IO to dup either fd0 or fd1 and create a read/write handle to them; assuming nobody has done any redirection both are actually open read/write.
14:43:10 <allbery_m> that said, this is *very* unreliable as any redirection will break your program.
14:43:12 <newsham> allbery: h <- if fn == '-' then return stdin else openFile fn ReadMode   ?
14:43:29 <allbery_m> you're answering the wrong question
14:43:51 <newsham> oh he wants stdin and stdout merged
14:44:01 <newsham> reading comprehension low
14:45:02 <lekro> hm, another question: can I redirect the standard handles so that putStrLn does not send to IO.stdout but to some other handle?
14:45:09 <newsham> lekro: are you trying to hook up a socket to stdio?
14:45:44 * allbery_m thinks that last question is evidence that you're doing the wrong thing somewhere
14:46:47 <lekro> newsham: yes
14:48:05 <lekro> I have some functions that do some (very litttle) putstr/readln for human interaction. Now I want this program to work over network, that is, through a plain telnet connection.
14:48:08 <newsham> System.Posix.IO's dup might work.
14:48:13 <newsham> in a non-portable way
14:48:38 <newsham> dupTo in particular
14:49:09 <allbery_m> I'm tempted to say the correct way to do that is continue to use stdin/stdout and let inetd do the socket swizzling for you
14:49:12 <newsham> you could take your old code and alter it to take a handle as a parameter
14:49:25 <newsham> inetd is a good solution
14:49:36 <lekro> allbery_m: well, I want some output to go to the real stdout
14:49:36 <LoganCapaldo> i'm with allbery_m
14:50:06 <newsham> lekro: you could dup the original stdout to a new handle and then dupTo your socket to stdio
14:52:08 <lekro> newsham: yes, this doesn't seem to be very portable. I think I'll go for the extra parameter
14:52:31 <lekro> or maybe a ReaderT
14:52:52 <dibblego> ?type \f b -> case f b of Just(a, b') -> mplus (return a) (unfoldr f b'); Nothing -> mzero -- why is the return type [t] and not (MonadPlus m) => m t?
14:52:52 <lambdabot> forall t b. (b -> Maybe (t, b)) -> b -> [t]
14:53:57 <shapr> ddarius: hah!
14:54:21 <shachaf> dibblego: unfoldr?
14:54:24 <dibblego> oh duh
14:54:29 <dibblego> just saw it myself
14:54:36 <dibblego> I need fix
14:54:44 * araujo still impressed by the speed improvement on ghc6.8 
14:55:40 <dibblego> ?type let unfold f b = case f b of Just(a, b') -> mplus (return a) (unfold f b'); Nothing -> mzero in unfold
14:55:40 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m) => (t -> Maybe (t1, t)) -> t -> m t1
14:56:02 <dibblego> does this function exist somewhere already?
14:57:34 <Botje> :t concatMaybe
14:57:35 <lambdabot> Not in scope: `concatMaybe'
14:57:38 <Botje> argh
14:57:39 <Botje> :t concatMaybes
14:57:40 <lambdabot> Not in scope: `concatMaybes'
14:57:47 <Botje> @hoogle catMaybe
14:57:47 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
14:57:52 <Botje> well, that one.
14:58:06 <Botje> but it's for the list monad only. don't know if that's good enough for you?
14:58:16 <dibblego> for me?
14:58:21 <Botje> oh wait
14:58:24 <Botje> *blink*
14:58:27 <Botje> nevermind :)
14:58:34 <dibblego> I am just surprised that unfold can be written for MonadPlus only
14:59:05 <newsham> > let swap (a,b) = (b,a); guarded f p x = guard (p x) >> return (f x) in unfoldr (guarded (/=0) (swap.(`divMod` 10))) "1234"
14:59:05 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `Bool'
14:59:36 <newsham> > let swap (a,b) = (b,a); guarded p f x = guard (p x) >> return (f x) in unfoldr (guarded (/=0) (swap.(`divMod` 10))) "1234"
14:59:36 <lambdabot>   add an instance declaration for (Integral [Char])
15:00:12 <newsham> > let swap (a,b) = (b,a); guarded p f x = guard (p x) >> return (f x) in unfoldr (guarded (/=0) (swap.(`divMod` 10))) 1234
15:00:13 <lambdabot>  [4,3,2,1]
15:08:29 <sorear> > (reverse . map digitToInt . show) 1234
15:08:30 <lambdabot>  [4,3,2,1]
15:10:44 <dcoutts> dons: yes, I noticed this today, that cabal-install doesn't realise that base cannot be upgraded
15:14:45 <dons> dcoutts: right, that's  what it looks like.
15:15:20 <dcoutts> dons: we need a new dep resolution algorithm for cabal-install, kosmikus was looking at it a bit
15:16:53 <LoganCapaldo> base can't be upgraded?
15:17:34 <dons> you could try :)
15:20:22 <thetallguy> dcoutts: is there a write up about that some place?
15:20:33 <newsham> sorear: mine is shorter.
15:20:48 <thetallguy> dcoutts: if not, I would like to see one show up on planet haskell or some such
15:20:59 <dcoutts> thetallguy: a write up about a new dep resolution algorithm?
15:21:04 <thetallguy> yes
15:21:07 <dcoutts> there's nothing so concrete yet
15:21:14 <thetallguy> the need for it would be fine
15:21:17 <dcoutts> just some ideas and the notion that it needs replacing
15:21:25 <thetallguy> that's what I want to see
15:21:27 <newsham> > let swap (a,b) = (b,a); guarded p f x = guard (p x) >> return (f x) in unfoldr (guarded (/=0) (swap.(`divMod` 9))) 1234
15:21:29 <lambdabot>  [1,2,6,1]
15:21:34 <dcoutts> thetallguy: neither I not kosmikus have a blog
15:21:53 <dcoutts> thetallguy: I tend to send my cabal ideas to the cabal-devel mailing list
15:21:58 <thetallguy> dcoutts: a simple brain dump to the cafe would serve
15:22:06 <thetallguy> Ah, I think I'm ont on that.
15:22:09 <thetallguy> I will remedy
15:22:11 <dcoutts> there's a whole series there on the new cabal make prototype
15:22:29 <dcoutts> which we're pretty excited about
15:22:37 <thetallguy> fab.  having struggled at Linspire with Debian packaging for years...
15:22:47 <thetallguy> ...I'd like to take a look for pitfalls.
15:23:22 <dcoutts> we're taking dons advice and modelling this stuff that does lots of IO in a pure way
15:23:26 <dcoutts> so we can QC it
15:23:47 <dons> yay
15:24:08 <dcoutts> the core algorithm is parametrised over any monad, so we can put it over IO for the real thing or in some pure simulation monad for QuickChecking
15:24:21 <dcoutts> we just got the first QC tests passing today
15:24:23 <newsham> like swierstra's "functional semantics for the awkward squad"?
15:24:33 <dcoutts> newsham: something like that
15:24:37 <newsham> neat
15:24:48 <dcoutts> we have a model of a filesystem with advancing time
15:24:57 <dons> excellent !
15:25:18 <dcoutts> so you can write (do readFile "foo"; writeFile "bar")
15:25:34 <dcoutts> and then runMake gives you a trace of events with the state of the system at each step
15:25:42 <dcoutts> so you can write QC properties over that
15:26:00 <newsham> nifty model checking
15:26:06 <dcoutts> things like that after make, all the files are up to date with respect to their dependencies
15:26:06 <thetallguy> dcoutts: nice.  It's still a model of state on machine, add packages a little bit at a time, right?
15:26:32 <dcoutts> thetallguy: oh, this bit is the make code, kosmikus has something else for package dep resolution
15:26:48 <thetallguy> dcoutts: not the Nix model where you specify all the packages at once?
15:27:37 <dcoutts> thetallguy: it was basically a function to consult a collection of available packages and some root deps to satisfy and to find a solution
15:27:44 <dcoutts> it uses backtracking
15:28:10 <shapr> hiya delYsid
15:28:11 <thetallguy> dcoutts: okay.
15:28:14 <shapr> long time no see
15:28:32 <diltsman> Question, is Yi any good?
15:28:38 <dcoutts> thetallguy: the idea is that it can be parametrised by policy when there are choices to make, things like preferences for installed packages or latest packages
15:28:56 <newsham> ?type any good
15:28:58 <lambdabot> Not in scope: `good'
15:29:31 <diltsman> I'm confused, was that to me?
15:29:38 <dcoutts> thetallguy: the tricky thing with cabal is doing this dep resolution in the presence of conditional package deps
15:29:54 <newsham> ?let good = isUpper in any good "Yi"
15:29:54 <lambdabot>  Parse error
15:30:00 <thetallguy> dcoutts: all very good ideas.  I would like to see that as a front end that produces a spec, and then, once the spec is okayed, have cabal-install work on that.
15:30:04 <newsham> >let good = isUpper in any good "Yi"
15:30:22 <opqdonut> newsham: just not your day eh?
15:30:24 <thetallguy> dcoutts: yes, we know aobut the conditionals.  stepcut and dsfox did a bunch of work on that
15:30:27 <dcoutts> thetallguy: it does, the output is a list of packages and the configuration flags of those packages
15:30:29 <LoganCapaldo> > let good = isUpper in any good "Yi"
15:30:31 <lambdabot>  True
15:30:35 <newsham> opq: pretty avg day actually
15:30:44 <thetallguy> dcoutts: okay, that's good
15:30:49 <newsham> thats why I need the practice
15:30:59 <thetallguy> dcoutts: very important to separate those two phases.
15:31:09 <dcoutts> thetallguy: yes.
15:31:20 <thetallguy> and to make the first interactive
15:31:35 <dcoutts> right, the policy functions could be in IO
15:31:56 <thetallguy> if you can have two or more distinct installs, so that you can roll back, then I'm in heaven.
15:32:00 <dibblego> ?type let unfold f b = case f b of Just(a, b') -> mplus (return a) (unfold f b'); Nothing -> mzero in unfold
15:32:01 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m) => (t -> Maybe (t1, t)) -> t -> m t1
15:32:06 <dibblego> ?hoogle (MonadPlus m) => (t -> Maybe (t1, t)) -> t -> m t1
15:32:07 <lambdabot> Did you mean: MonadPlus m => (t -> Maybe (T1, t)) -> t -> m T1
15:32:11 <dcoutts> thetallguy: kosmikus wrote an emerge replacement in Haskell that does a lot of this already. I asked him to have a think about the cabal-install case.
15:32:36 <dibblego> ?hoogle (MonadPlus m) => (t -> Maybe (T1, t)) -> t -> m T1
15:32:37 <lambdabot> No matches, try a more general search
15:32:47 <thetallguy> dcoutts: sounds very hopeful.  I'll watch the list.
15:32:50 <thetallguy> gotta run.
15:33:11 <dcoutts> thetallguy: ah right yes, so we can build a package and install into a image dir, but then building a dependent package without installing the first will be a bit more tricky.
15:33:20 <dcoutts> we'll need an inplace package db
15:35:41 <dons> bos: around?
15:36:03 <bos> yeah
15:36:59 <thoughtpolice> dons: i'm having issues with xmonad. it never starts (tested on my linux box and on my freebsd box)
15:37:03 <thoughtpolice> 0.4.1
15:37:19 <dons> hmm? never starts?
15:37:24 <thoughtpolice> yeah
15:37:31 <dons> in what sense?
15:37:32 <thoughtpolice> X just sits there as if you ran 'Xorg -conf' to test your configuration
15:37:40 <LoganCapaldo> did you try runningit? <g>
15:38:23 <thoughtpolice> kde works on my freebsd box, and I've had openbox working on my linux box for a while. I did have it working at one point, but that was at like, xmonad 0.1/0.2
15:38:23 <dons> sounds like you're not starting it with .xinitrc or something?
15:38:32 <dons> how are you invoking xmonad?
15:38:41 <thoughtpolice> exec $HOME/bin/xmonad is my entire .xinitrc
15:38:51 <dons> how do you know its not running?
15:39:15 <dons> sounds like a path issue, or some other X config problem though, not xmonad :)
15:39:21 <LoganCapaldo> cause theres no pretty desktop background or toolbar?
15:39:22 <dons> what X display manager are you using?
15:39:29 <dons> LoganCapaldo: right
15:39:32 <dons> by default, anyway
15:39:36 <bos> does Data.Sequence allow efficient deque-like use? it seems like not.
15:39:41 <LoganCapaldo> so it's clearly not running
15:39:47 * LoganCapaldo was joking
15:39:57 <bos> my okasaki book is at home, and i need a deque. blumph.
15:40:07 * bos pokes at edison a bit.
15:40:10 <dons> mm
15:40:15 <dons> yes, i'd start with edison
15:40:17 <thoughtpolice> dons: i've tried absolute paths, everything. and if kde/openbox is working then I'm not sure where to go from there
15:40:20 <LoganCapaldo> a zipper with 2 holes, one eper end?
15:40:43 <dons> thoughtpolice: can you run it by starting X directly, (i.e. "X") and then typing xmonad?
15:40:54 <shachaf> thoughtpolice: (This should probably be in #xmonad.)
15:41:04 <thoughtpolice> shachaf: my bad. :(
15:41:06 <mlh> thoughtpolice: my usual way to test X stuff is to just start an xterm from xinit and attempt to start the wm from the xterm
15:41:11 <thoughtpolice> dons: lemme see
15:41:25 <dons> it might depend on your display manager
15:41:32 <dons> and join #xmonad :)
15:41:47 <dons> http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#How_can_I_use_xmonad_with_a_display_manager.3F_.28xdm.2C_kdm.2C_gdm.29
15:41:48 <lambdabot> http://tinyurl.com/3a2duf
15:41:52 <bos> LoganCapaldo: yes, a zipper would make sense
15:41:55 <dons> covers the use of particular display managers
15:42:48 <shachaf> thoughtpolice: By the way, if you need to specify the path explicitly in .xinitrc, restarts probably won't work.
15:42:58 <shachaf> thoughtpolice: Since xmonad needs to be in its own PATH.
15:44:02 <bos> ah, hm, it looks like i can use views on Data.Sequence
15:45:25 <dons> ?uptime
15:45:25 <lambdabot> uptime: 2h 26m 51s, longest uptime: 1m 10d 23h 44m 29s
15:46:31 <bos> > viewr ((fromList "abc") |> 'd')
15:46:32 <lambdabot>   Not in scope: `|>'
15:46:42 <opqdonut> :i viewr
15:46:56 <opqdonut> :t viewr
15:46:57 <lambdabot> Not in scope: `viewr'
15:47:22 <bos> lambdabot dinnae ken Data.Sequence
15:48:52 <dons> oh.
15:48:58 <dons> that's odd
15:49:49 <vincenz> dons: wt is up with joel.reddit?
15:50:22 <dons> don't know, don't care?
15:50:29 <vincenz> ok
15:50:32 <dons> > Data.Sequence.viewr
15:50:32 <lambdabot>  Add a type signature
15:50:34 <vincenz> maybe you knew, I found that surprising
15:51:02 <vincenz> > Data.Sequence.viewr :: ViewR Int
15:51:03 <lambdabot>   Not in scope: type constructor or class `ViewR'
15:51:07 <vincenz> @type Data.Sequence.viewr
15:51:08 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.ViewR a
15:51:15 <vincenz> > Data.Sequence.viewr :: Data.Sequence.ViewR Int
15:51:16 <lambdabot>  Couldn't match expected type `Data.Sequence.ViewR Int'
15:51:22 <vincenz> meh
15:51:23 <vincenz> duh
15:51:36 <vincenz> > Data.Sequence.viewr (Data.Sequence.empty):: Data.Sequence.ViewR Int
15:51:37 <lambdabot>  EmptyR
15:54:31 <yitz> msg lambdabot @seen Cale
15:57:09 <bos> @seen dons
15:57:10 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 1m 59s ago.
15:59:41 <Cale> hello
16:01:40 <yitz> Cale: how is your definition of IO as a GADT fundamentally different than the traditional one as a state transition?
16:03:35 <Cale> Well, the state transition thing doesn't really work so well, because really those values of type RealWorld would have to include the things which the user types, all the things going on over the network and so on, and doesn't do very well at all at accounting for nondeterminism from things like concurrency
16:04:03 <Cale> (like, how do you model forkIO using that RealWorld -> (RealWorld, a) model?)
16:04:33 <yitz> mmm - there is one more thread in the world at the moment?
16:05:54 <Cale> Well, if that's really going to be a function
16:06:10 <Cale> Then the same input world has to lead to the same output world
16:06:36 <Cale> But once you introduce things like concurrency, lots of random things could influence the scheduling of threads.
16:06:56 <Cale> and so that "RealWorld" type gets a lot bigger
16:07:15 <Cale> It really has to be the whole real world.
16:07:53 <yitz> The same input RealWorld can give the same output - but it can change on its own without me doing anything. That is true even without considering threads.
16:08:00 <Cale> But there's something funny about what  forkIO :: (RealWorld -> (RealWorld,a)) -> RealWorld -> (RealWorld,a) does
16:08:38 <Cale> yitz: right, and that's not how values are really supposed to behave
16:09:15 <Cale> It's sort of an okay approximation to what IO is doing, but it seems to fail as a real useful model of the monad.
16:09:23 <yitz> So instead, you are just saying abstractly that it is a monad, without specifying anything more?
16:09:33 <Cale> My GADT is actually something implementable.
16:10:17 <Cale> You have a GADT which encodes specifications of IO actions, and the RTS is responsible for carrying out those instructions.
16:11:09 <Cale> and you don't worry quite as much about the exact transformation on the real world which is effected by each action.
16:11:31 <Cale> Of course, that's important, but it's part of the RTS's job, not part of the monad's job.
16:12:02 <yitz> I always thought about IO that way before, too. An IO action changes the world in a specific way at the moment. But there are no promises the RealWorld will be well-behaved beyond that.
16:12:53 <yitz> So I guess you are just trying to reduce the apparent promise that Haskell is making about the real world. Is that it?
16:13:15 <LoganCapaldo> Haskell doesn't make any promises about RealWorld does it?
16:13:33 <Cale> RealWorld doesn't really exist as far as Haskell is concerned.
16:13:46 <LoganCapaldo> yes
16:13:48 <yitz> LoganCapaldo: that would be a bit impertinent, wouldn't it?
16:13:54 <matthew-_> nor does RealWorld behave properly...
16:13:57 <Cale> There's an implementation detail of GHC by the same name, but that's not what people are talking about when they use that metaphor.
16:14:27 <Cale> The implementation detail used in GHC is just a token, and the functions of type RealWorld -> (RealWorld, a) which are used are impure functions.
16:14:53 <matthew-_> Cale: ok, I use RealWorld to mean state monad with state as RealWorld - it's a token.
16:15:26 <Cale> So that actually can't really be implemented without cheating.
16:16:03 <matthew-_> you reckon? even with a total rewrite of the universe all in Haskell?
16:16:10 <matthew-_> I've not thought about it hard enough...
16:16:28 <Cale> With the GADT, the IO monad itself can be implemented completely without cheating, and then the interpretation of those actions has to be carried out by a separate program which is allowed to really carry out the IO, but it's separated.
16:16:45 <yitz> I don't think it is the functions that are impure - it is RealWorld. The whole idea of that trick is to push the infelicity out of the functions and into an opaque data type, where it hardly hurts.
16:16:54 <wli> Such a rewrite is impossible. At least some has to be written in machine language, assembly, C, or a combination of the three.
16:17:22 <Cale> wli: hm?
16:17:43 <Cale> Well, sure, the runtime system or something will be written at least partly in C
16:18:01 <wli> udivdi3 et al need to be written in asm or machine language, for instance (C is incapable of it).
16:18:05 <allbery_m> the real problem there is replacing humans with equivalent haskell programs :)
16:18:08 <matthew-_> ahh, ok, I've not read scroll back. You wish to use a GADT to enumerate every action within RealWorld?
16:18:09 <Cale> It will walk over the IO data structure it gets and carry out the IO actions, passing work to the Haskell evaluator as necessary.
16:18:17 <Cale> matthew-_: no
16:18:22 <Cale> matthew-_: Within IO
16:18:37 <matthew-_> gotcha
16:18:38 <Cale> http://hpaste.org/3673
16:18:46 <Cale> That'd be the essential idea of it.
16:19:14 <yitz> allbery_m: I've always been a bit worried about representing those supermassive black holes inside my cpu, also.
16:19:30 <Cale> Of course, this might not be *entirely* practical from a performance standpoint, I don't know.
16:19:33 <wli> (The machine division intrinsics typically need to refer to hard registers, which can be done in C only via inline asm, which means it's really being done in asm.)
16:19:37 <matthew-_> sod performance.
16:19:42 * allbery_m wonders if he can model that with the song by Muse...
16:19:58 <Cale> But it totally would be implementable for real.
16:20:08 <matthew-_> right. ok. I've been spending some time thinking about making an entire operating system referentially transparent
16:20:09 <allbery_m> yitz: but thaty's easy, at least on some CPUs:  F0 0F C7 C8 :)
16:20:14 <Cale> You could have a completely pure IO monad on the haskell side which is just a data structure
16:20:28 <matthew-_> yes. I think this would give a way through
16:20:31 <Cale> and then a runtime system written in assembly or C or something which actually carries out the instructions
16:21:01 <Cale> an additional cool feature of that would be that IO values would be inspectable
16:21:14 <Cale> (if desired)
16:21:18 <matthew-_> if the runtime system understood those actions and could recognise when they are "the same", it could eliminate duplicate calls completely
16:21:32 <Cale> Well, at least to some extent...
16:21:36 <user317> is there any way to get the RTS to be more aggressive at waking up threads
16:21:54 <LoganCapaldo> yeah call it names
16:21:58 <LoganCapaldo> it usually gets ma
16:22:01 <LoganCapaldo> *mad
16:22:02 <matthew-_> Cale: sure - it's got to properly understand what actions do what etc
16:22:05 <user317> i have two different threads waiting on sockets, and if i send data to one, sometimes it doesn't wake up right away
16:22:12 <Cale> user317: um, you can cause a thread to yield
16:22:17 <wli> Cale: Some assembly will be required, and really, I think if there's any part which can be done in C, you can pretty much break it down into a piece needing to be done in asm and a piece that can be done in e.g. Haskell, or eliminating the foreign portion altogether (e.g. peek/poke in IO monads in Haskell can basically do C pointer crap for raw memory manipulation).
16:22:47 <user317> Cale, well both o them have yeilded, they are blocked by hGetContents
16:23:21 <Cale> wli: The idea here is that the values of type (IO a) don't have strange side effects encoded directly into them, they just abstractly describe those effects using a data structure.
16:23:40 <matthew-_> Cale: but imagine it - a request comes in for a webpage. The OS looks at the data and sees that it sent the same data to the http server recently and has the results cached. It checks that the IO actions the http server issued have not been "invalidated" and so just reissues the result, without ever waking up the http server.
16:23:43 <Cale> wli: It's up to some other part of the system to interpret those instructions and carry out the effects.
16:24:26 <matthew-_> Cale: your system would give an easy way to achieve low-level distributed operation
16:24:33 <sorear> yitz: RealWorld and Haskell have nothing to do with each other, it isn't even a valid implementation of IO and you ABSOLUTELY should not think about it.
16:24:35 <wli> Cale: Might as well have that set of instructions be machine instructions and their interpreter the CPU.
16:25:11 <Cale> wli: Well, yes, you could do that.
16:25:12 <matthew-_> CPUs suck.
16:25:19 <Cale> wli: but you also need Bind and Return
16:25:30 <wli> Cale: With, of course, various provisos for system call traps, of course.
16:25:36 <sorear> yitz: it's like talking about memory addresses in C, they just don't exist.  if you are a compilers hacker, you can be concerned with compiler implementation details; but memory addresses DO NOT show up at the C level
16:25:55 <yitz> wli: the power of Haskell is more in how it will look on future architechtures, not necessarily in how exactly it is implemented on today's hardware. Though that's also important :)
16:25:59 * sorear thinks we need to do a better job of enforcing 'users don't know about realworld'
16:26:04 <Cale> wli: It does seem somewhat unnatural of a representation for me though.
16:26:09 <wli> Cale: Bind is just sequencing of instructions, return I'm not sure of.
16:26:27 <wli> yitz: Why is this any different from how it looks in the future?
16:26:29 <Cale> wli: You see, to be a monad, things need to be typed.
16:26:34 <Saizan_> sorear: patch yaht
16:26:39 <yitz> sorear: (int) &x
16:26:50 <sorear> yitz: nasal demons
16:27:06 <Cale> wli: Whereas at the assembly level, types don't really exist so clearly.
16:27:26 <matthew-_> some interrupts can be considered runtime type checking
16:27:27 <wli> Cale: There's been work on typed assembly language (the project is even called that and the acronym "TAL" is used to refer to the language).
16:27:28 <matthew-_> eg / 0
16:28:40 <wli> Cale: Typechecking is just not done at runtime for you. Static checking schemes need to be devised prior to codegen.
16:29:14 <Cale> wli: um, perhaps you don't know what the discussion is referring to?
16:29:22 <Cale> This seems kind of strange :)
16:29:27 <dons> ?tiny-url http://sigfpe.blogspot.com/2007/11/small-combinatorial-library.html
16:29:28 <lambdabot> http://tinyurl.com/2lf26b
16:29:29 <wli> Cale: Maybe not, then.
16:29:30 <Cale> Did you see my paste?
16:29:59 <wli> Cale: Probably not. My backlog only goes back so far and I only wandered in a minute or two ago.
16:30:04 <Cale> http://hpaste.org/3673
16:30:14 <matthew-_> Cale: I think we'd need extensible GADT declarations ;)
16:30:19 <LoganCapaldo> question regarding GADTs, what happens when you try to pattern match on something like your GetChar Cale?
16:30:28 <Cale> matthew-_: No, just a constructor for foreign imports.
16:30:38 <Cale> matthew-_: er, hmm :)
16:30:46 <wli> Cale: Looks like you're shooting for system call trap semantics.
16:30:48 <Cale> Yeah, you might be right about that.
16:30:53 <yitz> wli: Think of WASH. Haskell that compiles to run on a machine abstraction that has no persistent memory at all, even between function calls. Or Haskell that compiles to run on a massively distributed cluster. The low-level CPU/memory/asm metaphor is already not exactly true, and hardware will drift away from that in the future.
16:30:55 <matthew-_> Cale: ugh. Why fix the problem properly when we can leave it broken for years? :p
16:31:15 <Cale> LoganCapaldo: it either succeeds or fails?
16:31:17 <matthew-_> and PLEASE can we have closed type classes... just while we're at it, you know...
16:31:37 <Cale> LoganCapaldo: GetChar is just a value, like Nothing in the Maybe type.
16:31:41 <wli> yitz: I have good reasons to believe that will not be the case.
16:32:00 <Cale> LoganCapaldo: there's no actual semantics attached to it at the Haskell level
16:32:44 <LoganCapaldo> Cale: duh. My head wasn't on straight
16:32:44 <Cale> Well, there is, I suppose, but it's just the usual semantics of Haskell values :)
16:32:50 <wli> yitz: I'm aware of CPU vendor roadmaps extending 6-8 years out and nothing even tweaking von Neumann in the slightest is under any consideration whatsoever.
16:32:52 <yitz> wli: I know people who work on low-level firmware for hardware devices. Even they work at some higher level abstraction nowadays.
16:33:19 <yitz> yeah, 6-8 years is about how long they plan.
16:33:40 <Cale> What I mean is that GetChar here doesn't actually encode *how* to get a character, that's the job of the runtime system.
16:34:06 <Cale> matthew-_: It would be nice to have declarations like   open data IO a where ...
16:34:19 <matthew-_> indeed.
16:35:11 <yitz> The actual silicon won't change very quickly, for obvious reasons of technilogical baggage. But we already find it necessary to wrap it in many layers to isolate ourselves from it. And that will allow it to change - slowly - according to need, over time.
16:35:34 <Cale> Of course, even as inspectable as this is, it still suffers the same problem all monads suffer w.r.t. inspectability, in that the right hand parameter to bind is a function, which is opaque.
16:35:35 <sorear> tuukkah:
16:35:39 <sorear> meh
16:35:40 <wli> yitz: The "longer term" smoke being blown is all about more parallelism, improved IO, memory, and virtualization architectures, and essentially no thought whatsoever regarding the fundamentals of CPU architectures. The extinction of CPU architectures is expected to continue with various sorts of lesser legacy / embedded architectures dying off.
16:35:45 <Cale> But you could at least write an IO simulator directly.
16:35:58 <sorear> anyone know how to disable C-j in irssi, given that it has the same keycode as enter?
16:36:14 * sorear mumbles something about this discussion being pointless
16:37:01 <wli> yitz: For instance, the last embedded 32-bit SPARC production is expected to die off completely. So instead of diversifying in any way whatsoever, the opposite is expected.
16:37:18 <shachaf> sorear: You'd probably do that on another level.
16:37:19 <Moosefish> wli: who's still doing embedded sparc?
16:37:25 <shachaf> sorear: Why do you want that?
16:38:01 <wli> Mooseish: I think EMC was using it for a microcontroller component in some of their disk arrays and a few other very unusual uses.
16:38:34 <Moosefish> too bad. ERC32 and LEON are fun things to play with.
16:38:35 <matthew-_> there are some sparc cores that you can get as part of fpgas iirc
16:38:36 <yitz> wli: at the research level, a lot of stuff is being worked on that is far different, inherently. eventually, the industry will drift in various directions, and diversity will return in a different way.
16:38:40 <wli> Moosefish: (Nothing so obvious as the controller for the disk array itself or the interface.)
16:38:48 <sorear> shachaf: t<TAB><C-a><C-j> ->
16:38:50 <sorear> ARGHH
16:38:52 <LoganCapaldo> here you could have a a constructor liek LiftM :: (a -> b) -> IO a -> IO b. couldn't you? GADTs are weird.
16:39:00 <sorear> shachaf: t<TAB><C-a><C-j> -> "tukkah: ", I wanted C-k
16:39:23 <matthew-_> GADTs are not weird. normal data decls are weird as they hide types
16:39:29 <LoganCapaldo> Although I think I start to get an inkling of the "typed interpreter" thing
16:39:36 <shachaf> Oh, hmm.
16:39:41 <wli> yitz: I'm not aware of any CPU architecture research being taken seriously by major CPU vendors. I'd love to be (very) wrong about this, though.
16:39:43 <matthew-_> it's just like record fields hide types
16:39:53 * shachaf would've used C-w, but that's no solution. :-)
16:39:58 <glguy> bos: You about?
16:40:16 <bos> yawp
16:40:35 <glguy> bos: Are you the GHC maintainer for Fedora?
16:40:46 <yitz> wli: definitely not within the next 6-8 years, anyway.
16:40:50 <bos> glguy: yep
16:41:15 <wli> yitz: What I'm seeing from vendor roadmaps doesn't reflect CPU architecture research. What are you seeing?
16:41:30 <glguy> bos: so Haskell support is pretty decent on Fedora then?
16:41:38 <Moosefish> wli: Any research in particular you're referring to?
16:41:53 <bos> glguy: not up to the level of debian, but pretty good, yeah
16:42:02 <glguy> bos: alright, cool
16:42:19 <glguy> I was googling for "fedora ghc 6.8.1" and your blog post came up first :)
16:42:46 <bos> yitz: academic computer architecture research is completely irrelevant
16:44:15 <wli> Moosefish: No. Essentially industry roadmaps are completely oblivious to computer architecture research AFAICT.
16:44:16 <yitz> bos: I don't think you're right. They won't be building desktop computers out of that for a long time, but if real benefits are shown, it will get out into the real world somehow.
16:44:43 <bos> yitz: no, i am right. i've worked with cpu designers for years.
16:44:52 <wli> Moosefish: So I have no idea.
16:45:03 <wli> bos: What's your take on what's going on with all this?
16:45:29 <shachaf> Hmm. nano handles ^J separately. :-)
16:45:36 <bos> yitz: the problem is that a small team of grad students and postdocs cannot, in 4 to 6 years and with negligible funding, do anything of any interest to CPU designers.
16:45:48 <Pseudonym> Actually, I disagree that it's completely irrelevant.
16:45:52 <yitz> bos: the cpu designers will not pay any attention to it, that is true.
16:45:57 <Moosefish> wli: My gut feeling is that most of the CPU architecture development (and by that I mean microcoding single-threaded single-core stuff) is fast reaching diminishing returns. The new ideas produced would take too much software changes to be economically viable.
16:46:00 <Pseudonym> Someone needs to teach computer architecture to the next generation of designers.
16:46:06 <yitz> that doesn't mean it's irrelevent.
16:46:06 <Pseudonym> And that'd better be an expert.
16:46:11 <Moosefish> But I'm handwaving with little first hand knowledge, so take it with a grain of salt.
16:46:33 <Pseudonym> And industry does hire academics.
16:46:50 <wli> My take on CPU architecture development is that it's hitting a wall much as fabrication processes and clock speeds are. ;)
16:46:51 <bos> Pseudonym: sure. but that doesn't mean that the research they do can influence what happens.
16:47:08 * Pseudonym points out that Ivan Sutherland works for Sun
16:47:26 <yitz> Pseudonym: that's not necessarily good enough. If there are multibillions invested in a certain kind of process, your ideas are nice, but...
16:47:30 <bos> ivan sutherland hasn't had anything influential to say in quarter of a century.
16:47:38 <Saizan_> Cale:
16:48:16 <Pseudonym> Very few people get to say anything that's truly influential.  I think that's a difficult standard to achieve.
16:48:27 <Pseudonym> And it's a far cry from "completely irrelevant".
16:48:41 <waern> can anyone point me to a great paper to read while compiling ghc? :)
16:48:50 <chessguy> @quote paper
16:48:51 <lambdabot> emu says: design patterns are what you choose for wallpaper and carpets
16:49:04 <wli> waern: http://holomorphy.com/~wli/polylambda.pdf
16:49:04 <yitz> waern: war and peace
16:49:12 <Pseudonym> bos: I'm not saying that I'm disagreeing with the thrust of it.
16:49:25 <Pseudonym> I do think that "completely irrelevant" is a slight exaggeration.
16:50:08 <waern> yitz: it's doesn't take *that* long :)
16:50:45 * Pseudonym wonders what the last big academic idea to hit commercial CPUs was
16:50:53 <wli> I say that computer architecture is dead. The course of it is mapped out for the remainder of its history. Processes end at 22nm or maybe one process smaller, and everything else is just obvious tacking on of caches, buses, cores, etc. until that's tapped out, too.
16:50:53 <Pseudonym> Probably the Harvard architecture.
16:51:01 <bos> Pseudonym: only barely, if at all.  the people who have influence over CPU design directions have been in industry a long time already.
16:51:26 <allbery_m> one could the last one t hit was vliw :)
16:51:37 <Pseudonym> VLIW has been around forever, though.
16:51:42 <Pseudonym> Hell, a lot of microcode is VLIW.
16:51:44 <bos> Pseudonym: so what happens is PhD students get loaned to design teams for a while, or join companies after they graduate, and that's where they learn their tradecraft.
16:51:46 <allbery_m> exaxctly
16:52:10 <wli> Any comments/etc. on my "computer architecture is dead" bit?
16:52:23 <Pseudonym> wli: Disagree.
16:52:24 <nominolo> not at all
16:52:35 <nominolo> most of the stuff is happening in the embedded area
16:52:36 <waern> wli: thanks.
16:52:42 <Moosefish> wli: hardly. I'm expecting FPGAs to turn out to be a fascinating field for the forseeable future. We'll see computer architecture revived out of the FPGA community -- in particular, removing the artificial proxy layer imposed by instruction sets.
16:52:45 <Pseudonym> Yes, I agree there.
16:52:48 <nominolo> @go No instruction set computer
16:52:50 <lambdabot> http://www.cecs.uci.edu/~nisc/
16:52:50 <wli> Okay, virtualization features maybe get tacked on, too.
16:52:50 <lambdabot> Title: NISC Technology
16:52:56 <jberg> @src groupBy
16:52:56 <lambdabot> groupBy _  []       =  []
16:52:57 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
16:52:57 <lambdabot>     where (ys,zs) = span (eq x) xs
16:53:01 <chessguy> i don't get this quote from that polylambda paper: "...types play a role in
16:53:01 <chessguy> efficiency. If it is known that a subterm of a program has a certain type, then this subterm may be
16:53:01 <chessguy> executed more efficiently by making use of this type information."
16:53:07 <Pseudonym> The embedded area is one of the few places where genuine innovation matters.
16:53:24 <chessguy> anyone for an example?
16:53:30 <wli> Embedded will get wiped out by low-power x86.
16:53:34 <Moosefish> chessguy: There's a ton of interesting optimizations to be done if you know that a variable is an int or a string
16:53:34 * nominolo is just writing a compiler to a fpga-based architecture
16:53:37 <allbery_m> look up why the monomorphism restriction exists?
16:53:38 <wli> That's my prediction for embedded.
16:53:47 <jberg> @src span
16:53:47 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:53:52 <Thomas2> low-power x86? not arm?
16:53:53 <yitz> wli: product other than traditional "computers" will use other ideas. Once they get some capitalization, the "computer" as we know it will probably cease to exist, and there will be many other things that use what we think of as computing.
16:53:56 <Pseudonym> wli: And how much embedded development do you do?
16:53:58 <chessguy> Moosefish, you pretty much just repeated the quote in different words :)
16:54:00 <Moosefish> chessguy: the former will fit in a register, for example, reducing memory pressure -- which the compiler or JIT engine can take advantage of
16:54:22 <chessguy> oh, i can see it making a difference in efficiency of *space*, sure
16:54:32 <Moosefish> chessguy: Not just space, but it's the most obvious one.
16:54:33 <mauke> er, and runtime
16:54:38 <wli> Pseudonym: I talk to enough embedded Linux hackers to have a vague idea.
16:54:44 <Pseudonym> In the embedded space, there's a sense in which it really doesn't matter which ISA you use.
16:54:51 <Pseudonym> Anything reasonable will do.
16:55:03 <Pseudonym> So it falls down to things like interrupt latency, die space and so on.
16:55:27 <wli> Pseudonym: ARM fabbers can't keep up with Intel and are committing financial suicide in various other ways.
16:55:29 <Pseudonym> Low-power x86 has one huge limitation: Code and data have the same address space.
16:55:58 <Pseudonym> In really low-power applications, you want to be able to run your code straight out of flash.
16:55:58 <nominolo> and it still needs a lot of decoding overhead
16:56:01 <Pseudonym> Or similar.
16:56:03 <Pseudonym> Yeah.
16:56:08 <Saizan_> chessguy: well list fusion can work only if you know you're using lists.
16:56:09 <wli> Pseudonym: I can't keep up with all their commentary on it but they're rather serious about the low-power x86 stuff.
16:56:24 <Pseudonym> x86 will always require more die space than ARM, MIPS etc.
16:56:25 <chessguy> hm, ok
16:56:25 <Moosefish> chessguy: Strong typing information allows you to remove layers of indirection. Think of it from the python/perl perspective. When you call one of the builtin functions/operators/whatever the first thing it does is query the variable to figure out its type, then do its thing. Haskell and friends already know what type it is, so they just do their thing (bypassing the querying)
16:56:36 <nominolo> wli: the advantage is that you don't have to re-compile
16:56:39 <chessguy> kind of an obscure example, but a good one
16:56:46 <Pseudonym> But even 8 bit will still be around for a long time.
16:56:50 <wli> Pseudonym: Not if they're 1-2 generations ahead in fabrication process.
16:57:24 <vincenz> Pseudonym: no there's not
16:57:30 <vincenz> Pseudonym: the embedded space is oen where ISA's are most explored
16:57:43 <vincenz> Pseudonym: in fact most lowlevel optimisations are studied in the embedded space
16:57:52 <vincenz> just got to DATE, DAC, ISSCC, ISCAS or any other
16:57:59 <Pseudonym> vincenz: I agree with you, which makes me wonder what you're disagreeing with me about.
16:58:12 <vincenz> 01:55 < Pseudonym> In the embedded space, there's a sense in which it really doesn't matter which ISA you use.
16:58:17 <Pseudonym> Oh, was it the ISA comment?
16:58:18 <chessguy> Moosefish, so are we always talking about a constant effect? as in, typing will never change asymptotic runtime?
16:58:40 * vincenz nods
16:58:53 <Pseudonym> If so, what I meant by that was that unlike desktop machines, there's no problem with legacy code targeted to an existing ISA.
16:59:00 <Moosefish> chessguy: Practically speaking? Probably. In theory, you could imagine a compiler optimization that only applies when the compiler can figure out enough typing information to apply it
16:59:17 <vincenz> Pseudonym: oh right
16:59:21 <chessguy> hmm, fair enough
16:59:23 <araujo> mmm
16:59:25 <vincenz> Pseudonym: people often have to handcompile stuff anyways
16:59:31 <araujo> darcs don't compile with ghc6.8 yet?
16:59:32 <Pseudonym> Sometimes, yes.
16:59:35 <vincenz> spending mnths just to get the stuf into the ram
16:59:37 <Moosefish> for (int i = 0; i < X; i++) { /* do nothing /* }
16:59:37 * Pseudonym had to about a year ago
16:59:44 <vincenz> not perse the compilation, but the mapping
16:59:55 <Moosefish> chessguy: mathematically speaking, if you know it's an int, you can do i = X; right away.
16:59:58 <vincenz> (task definition, processor assignment, memory assignment, prefetch, etc.)
17:00:02 <Moosefish> chessguy: But that's stretching it a fair bit.
17:00:34 <Pseudonym> See, I have an embedded board sitting on my desk next to me that I have to write software for.  I can't see x86 replacing the AVR chip any time soon.
17:00:59 <Pseudonym> If the AVR core gets smaller in the next generation, the space is going to get replaced by more I/O stuff.
17:01:04 <wli> Pseudonym: Returns to scale with component costs.
17:01:10 <Pseudonym> Like, bigger onboard FPGA.
17:01:14 <chessguy> Moosefish, but that's a case where O(1) = O(n) anyway
17:01:26 <chessguy> err, no
17:01:48 <Moosefish> not really :)
17:01:56 <Saizan_> well X is constant
17:02:09 <Saizan_> it depends what you are counting, as usual
17:02:13 <vincenz> x86 is just really bad at the energy game :)
17:02:14 <Moosefish> Saizan_: Doesn't have to be for the optimization to work
17:02:17 <wli> Pseudonym: Power consumption makes the use physically feasible and the component cost makes it financially feasible or superior.
17:02:35 <vincenz> wli: why power?
17:02:39 <vincenz> wli: oh, desktops?
17:02:52 <Moosefish> Saizan_: But knowing it's an int (vs a perl string) is critical.
17:02:52 <wli> vincenz: If the low-power x86 becomes competitive power consumption -wise blah blah blah.
17:03:00 <vincenz> wli: for portabale?
17:03:04 <hpaste>  LoganCapaldo pasted "GADTs are still weird but in a good way. this is the easiet time I ever had implementing state." at http://hpaste.org/3816
17:03:05 <vincenz> then it's not about power, but about energy
17:03:19 <vincenz> there's a huge misconception about those two being the same
17:03:34 <vincenz> low power is easy, just clock at 1/1000 the frequency
17:03:34 <wli> vincenz: Putatively for laptops but the real thrust is into the embedded space.
17:03:51 <vincenz> wli: their energy saving schemes are really brute
17:03:57 <vincenz> they clock gate only at the core level, nothing finer grain
17:04:03 <vincenz> so if one core starts to run away, heat wise, you're one cor down
17:04:28 <vincenz> intel has a lot to catch up in the embedded market
17:04:33 <wli> vincenz: There's obviously more to the further schemes than that.
17:04:40 <Saizan_> btw, can you have record-like GADTs?
17:04:44 <wli> vincenz: Yes, and that's planned.
17:05:54 <vincenz> Saizan_: no
17:06:02 <vincenz> Saizan_: record and GADTS don't mix iirc
17:06:07 <hpaste>  tehgeekmeister pasted "Exercise 3.3.3 from "Write Yourself a Scheme in 48 Hours"." at http://hpaste.org/3817
17:06:09 <vincenz> you get a compiler bug
17:06:12 <vincenz> maybe its' fixed tho
17:06:40 <tehgeekmeister> how do i fix the do blocks inside of lets inside of do blocks in that example?
17:07:13 <Saizan_> i wonder if there's an intrinsic reason
17:07:23 <nominolo> tehgeekmeister: use vanillastring <- many ...
17:07:29 <nominolo> ie, no let
17:08:09 <nominolo> tehgeekmeister: oh
17:08:23 <LoganCapaldo> or maybe you meant to say let vanillastring = many (noneOf '\\') ?
17:08:28 <nominolo> tehgeekmeister: i misread.  remove the "x <-" in the first expr
17:08:38 <Saizan_> and the second too
17:08:49 <nominolo> yeah
17:09:05 <Pseudonym> It's kind of amazing how Intel dropped the ball in the embedded space.
17:09:13 <Pseudonym> In the early 80s, they had a bunch of good chips.
17:09:37 <tehgeekmeister> so a let defined in a do block counts as being in the appropriate monad?
17:09:56 <LoganCapaldo> you're problem is that you had x <- for no reason
17:10:00 <LoganCapaldo> gah
17:10:04 <nominolo> tehgeekmeister: no
17:10:11 <LoganCapaldo> I keep doing the reverse of misusing you're
17:10:25 <nominolo> tehgeekmeister: it's just another way of writing let .... in do
17:10:38 <LoganCapaldo> it's in the appropiate monad because of the types of many and noneOf and <|> etc.
17:12:44 <hpaste>  tehgeekmeister annotated "Exercise 3.3.3 from "Write Yourself a Scheme in 48 Hours"." with "Is this correct now?" at http://hpaste.org/3817#a1
17:13:37 <chessguy> tehgeekmeister, you don't need the "do" either
17:13:39 <nominolo> tehgeekmeister: your problem is the use of x <- in the last expression of a do-statement
17:13:49 <nominolo> let's translate this to >>=
17:14:32 <nominolo> char '\\'; x <- anyChar    ==>  char '\\' >>= \_ -> anyChar >>= \x -> ????
17:15:20 <nominolo> see?  the result of anyChar should actually be the result of your whole do-block
17:16:03 <tehgeekmeister> oh!
17:16:19 <chessguy>  anyChar >>= return
17:16:49 <mauke> '>>= return' == 'liftM id'
17:16:49 <nominolo> and noneOf expects a list
17:16:59 <chessguy> err, right
17:17:38 <nominolo> mauke: s/he might not be ready for that, yet
17:17:39 <chessguy> @hoogle noneOf
17:17:40 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st Char
17:17:44 <newsham> > liftM id 5 :: [Int]
17:17:45 <lambdabot>   add an instance declaration for (Num [Int])
17:18:00 <newsham> > liftM id (return 5) :: [Int]
17:18:01 <lambdabot>  [5]
17:18:08 <chessguy> nominolo, i think mauke's point is that the >>= is unneccesary
17:18:16 <chessguy> you can just leave it off completely
17:18:21 <nominolo> yes
17:18:26 <nominolo> sure
17:18:32 <newsham> ?type liftM id
17:18:33 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
17:18:36 <nominolo> due to the monad laws
17:18:37 <newsham> > id [5]
17:18:38 <lambdabot>  [5]
17:18:40 <newsham> > liftM id [5]
17:18:41 <lambdabot>  [5]
17:18:56 <nominolo> m >>= \x -> return x == m
17:20:36 <chessguy> tehgeekmeister, is any of this making any sense?
17:21:59 <chessguy> i think we blew up another newbie's head
17:22:00 <tehgeekmeister> chessguy: i'm still lost as how to make my code work, but i do get why not to use a <- at the end of a do
17:22:29 <hpaste>  chessguy annotated "Exercise 3.3.3 from "Write Yourself a Scheme in 48 Hours"." with "something like this" at http://hpaste.org/3817#a2
17:22:42 <nominolo> tehgeekmeister: maybe using a where-clause instead of those "let"s would be more readable
17:23:31 <hpaste>  nominolo annotated "Exercise 3.3.3 from "Write Yourself a Scheme in 48 Hours"." with "(no title)" at http://hpaste.org/3817#a3
17:23:35 <shachaf> tehgeekmeister: Also look at between?
17:24:23 <chessguy> shachaf, aww, you're ruining all the fun :)
17:24:44 <tehgeekmeister> shachaf: would that work for parsing "\""?  and the main reason i didn't use it, the tutorial hasn't mentioned it yet, even tho i saw it.
17:24:49 <tehgeekmeister> i'm willing to work harder to learn more.
17:24:50 <chessguy> @hoogle between
17:24:51 <lambdabot> Text.ParserCombinators.ReadP.between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
17:24:51 <lambdabot> Text.ParserCombinators.Parsec.Combinator.between :: GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a
17:25:04 <nominolo> i'd use String <$> between (char '"') ....
17:25:38 <shachaf> That would be my suggestion (Control.Applicative!).
17:25:49 <shachaf> String . concat <$>, probably.
17:26:04 <nominolo> shachaf: though, you'd have to write the instance yourself
17:26:15 <nominolo> shachaf: no, many does that for you
17:26:15 <shachaf> nominolo: Three lines.
17:26:25 <shachaf> nominolo: It does?
17:26:28 <chessguy> maybe not such a good idea for someone who doesn't quite grasp do-notation yet
17:26:32 <nominolo> :t many
17:26:32 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
17:26:37 <nominolo> er
17:26:39 <shachaf> @hoogle many
17:26:40 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
17:26:40 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
17:26:40 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
17:26:45 <shachaf> Parsec uses that one.
17:27:12 <shachaf> However, you can hide Parsec's (<|>), many, etc., I think, and use Applicative/Alternative's.
17:27:13 <nominolo> i think the concat is wrong
17:27:46 <nominolo> shachaf: oh, didn't know that
17:27:48 <shachaf> nominolo: Possibly.
17:28:59 * shachaf didn't go so far as to look at the code itself... :-)
17:29:05 <nominolo> but using C.A makes things much more readable.  esp. once you use <* and *>
17:30:03 <shachaf> Those are (>>) and flip (>>), right?
17:30:40 <nominolo> x <* y = const <$> x <*> y
17:30:55 <nominolo> so, no.  the order is preserved
17:31:01 <chessguy> tehgeekmeister, did either of our suggestions work for your code?
17:31:03 <nominolo> but only the pointed-to result is returned
17:32:08 <Saizan_> ?type (*>)
17:32:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
17:32:23 <shachaf> @ty (>>)
17:32:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
17:32:32 <tehgeekmeister> the code works now, but i've got a type error, escapedLiteral is returning a string and vanillaString a list of strings
17:32:43 <tehgeekmeister> well, it's closer to working, i should say.
17:32:54 <nominolo> tehgeekmeister: try removing the concat?
17:32:55 <shachaf> nominolo: I meant with order preserved, right. :-)
17:33:11 <nominolo> shachaf: then, yes ;)
17:33:29 <tehgeekmeister> nominolo: i was thinking about putting the concat in vanillaString, bring them both to strings, that's what i want anyway?
17:34:05 <nominolo> tehgeekmeister: no, i don't think so
17:34:18 <nominolo> oh, wait
17:34:29 <nominolo> that can work?
17:34:54 <chessguy> that can has success?
17:34:54 <tehgeekmeister> i think i confused myself about the types.
17:35:01 <nominolo> i would remove the many in vanillaString
17:35:21 <nominolo> both sides of <|> must return the same result
17:35:36 <tehgeekmeister> oh!
17:35:38 <tehgeekmeister> that works.
17:35:45 <tehgeekmeister> i knew they must, i just couldn't see the obvious.
17:35:46 <nominolo> *result type
17:35:50 <shachaf> nominolo: The same type. :-)
17:36:25 <nominolo> shachaf: same result in abstract interpretation in the domain of types
17:36:35 <nominolo> or sth... :)
17:46:57 <sprinky> Hey #haskell, I've been having a problem using the Haskell overlay for Gentoo.
17:47:11 <sorear> #gentoo-haskell?
17:47:21 <sprinky> If it exists: Lovely :)
17:47:24 <sprinky> Thanks sorear
17:53:05 <araujo> darcs don't compile with ghc6.8 yet?
17:59:38 <n00b> in SOEgraphics how do i change the background color from black?
18:03:17 <n00b> any help?
18:03:29 <tehgeekmeister> is it just me, or is this solution wrong: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Answers#Exercise_2
18:03:30 <lambdabot> http://tinyurl.com/3y8dgg
18:03:39 <tehgeekmeister> it looks to me like it wouldn't parse the empty string.
18:04:00 <sorear> @seen glguy
18:04:01 <lambdabot> I saw glguy leaving #xmonad and #haskell 45m 12s ago, and .
18:04:09 <n00b> any help??
18:14:44 <shachaf> tehgeekmeister: Is that wrong?
18:15:49 <tehgeekmeister> well, does scheme allow empty strings?
18:16:24 <tehgeekmeister> yes, it's wrong.
18:16:34 <tehgeekmeister> scheme allows empty strings.
18:17:28 <dons> http://sequence.complete.org/hwn/20071111 HWN out !
18:17:29 <lambdabot> Title: Haskell Weekly News: November 11, 2007 | The Haskell Sequence
18:18:41 <shachaf> tehgeekmeister: Which Exercise 2 are you thinking of?
18:19:38 <waern> dons: nice!
18:19:44 <TSC> dons: Andrew Coppin might be upset that you misspelt his name (:
18:19:55 <tehgeekmeister> shachaf: 3.3.2
18:20:11 <dons> oh
18:20:12 <dons> oops
18:20:27 <LoganCapaldo> seems like these are picking up in regularity
18:21:09 <shachaf> dons: You can still change it, right?
18:21:19 <shachaf> Oh.
18:22:01 <dons> http://programming.reddit.com/info/60d87/comments/
18:22:33 <dons> too many new  libraries though. could people write a bit less haskell code?!
18:22:45 <Pseudonym> dons: You mean refactor more, right?
18:23:17 <shachaf> dons: Well, you're counting process, containers, etc.
18:23:31 <shachaf> With the 6.8 release.
18:23:39 <tehgeekmeister> dons: is that the secret to how so many of those haskell articles get voted up so well?  linking them in here?
18:24:34 <dons> shachaf: yeah, there were 60 in the last hwn, though.
18:24:47 <dons> tehgeekmeister: hmm, typically its worth 1 or 2 upmods
18:24:48 <dons> not that much
18:25:00 <shachaf> Well, OK.
18:30:46 <hpaste>  tehgeekmeister annotated "Exercise 3.3.3 from "Write Yourself a Scheme in 48 Hours"." with "yet another version." at http://hpaste.org/3817#a4
18:31:16 <tehgeekmeister> can anyone explain why this version won't work on strings along the lines of "abc\\de"
18:31:37 <tehgeekmeister> well, it's not matching anything with any escaped anything yet
18:34:36 <allbery_m> because many matches and returned a vanillaString when it hits the \\, so the subsequent char '"' fails
18:35:02 <allbery_m> I think
18:35:16 * allbery_m is fuzzy, somewhat dizzy, and can barely see.  yeugh
18:35:32 <schemelab> Is there a library in haskell that can calculate the coefficients of a polynomial, given it's roots?
18:36:10 <allbery_m> oh, I see it
18:36:38 <allbery_m> if it hits a \\ then vanillaString will match and return empty, so escapedLiteral never gets a chance to run
18:36:42 <allbery_m> try reversing them
18:36:56 <tehgeekmeister> okay
18:39:07 <tehgeekmeister> no luck.
18:39:07 <allbery_m> in general, if you have something that will match anything (many (noneOf "\\") will succeed and return empty when faced with "\\") you want it after all other alternatives
18:39:34 <tehgeekmeister> maybe it's something in how i'm testing it?
18:40:09 <tehgeekmeister> i'm not at all familiar with parsec, as this is part of the write yourself a scheme tutorial
18:43:33 <tehgeekmeister> oh, i think it was.
18:43:35 <tehgeekmeister> =]
18:43:53 <allbery_m> your code will fail to parse if \ is followed by anyuthing ther than \ or ", btw
18:44:07 <tehgeekmeister> yes, it's meant to.
18:44:21 <tehgeekmeister> being pedantic about r5rs
18:44:58 <tehgeekmeister> the standard explicitly calls \ followed by anything but \ or " undefined, so i'm making it undefined in my parser.
18:45:30 <tehgeekmeister> and the problem was me not escaping the string in ghci right.
18:45:47 <allbery_m> yeh
18:46:11 <tehgeekmeister> it's messy trying to write escape an escaped string.
18:46:18 <tehgeekmeister> -write
18:52:29 <Altair^> is there a nice way to free memory that a vector is using?
18:52:36 <EvilRanter> stop looking at it
18:53:22 <EvilRanter> System.Mem.performGC as well, maybe
18:53:32 <Altair^> if I don't want to free the whole vector
18:53:37 <EvilRanter> but mostly stop looking at it
18:53:56 <EvilRanter> if you're worried about memory usage other than asymptotically, haskell is not the langauge for you ;)
18:54:56 <skew> "vector"?
18:55:23 <Altair^> oops, thought I was talking at c++
18:55:27 <Olathe> If you cover your eyes, the world vanishes.
18:55:29 <Altair^> oh sorry mates :D
18:55:47 * wli points to nhc98
18:55:58 <skew> you can't do that either, except maybe to trim some reserved space at the end
18:56:06 * EvilRanter pokes himself in the eye with a dangling pointer
18:56:24 <shachaf> @remember sorear C: the implementation language of choice when constant factors matter.
18:56:25 <lambdabot> Good to know.
18:57:04 <scook0> @quote
18:57:05 <lambdabot> shapr says: I dare you to call a substructural type system obvious anywhere outside of #haskell.
18:57:22 <Olathe> That's namecalling.
18:58:24 <chessguy> substructural typing? as in class Foo a => Bar a?
18:58:39 <skew> as in substructural logic
18:58:44 <skew> linear, affine, whatever
18:58:59 <chessguy> i knew i shouldn't have asked
18:59:16 <skew> uniqueness typing?
19:00:22 <wli> C has its own gross inefficiencies, esp. those related to formatted IO.
19:00:51 <ddarius> uniqueness typing is related to linear logic, yes.
19:01:40 <wli> String processing, too.
19:01:56 <Leimy> namecalling?
19:02:19 <scook0> chessguy: the basic idea of substructural typing is not that complicated
19:03:04 <chessguy> i've never heard of it
19:03:13 <wli> Substructural typing? Is this structural subtyping?
19:03:25 <skew> not at all
19:03:53 <ddarius> Basically, instead of using sets for contexts, use bags or lists.
19:04:26 <chessguy> to allow duplicates?
19:04:28 <skew>  logic has these structural rules, like A,B,C => D if A,B,B,C => D
19:04:36 <skew> or A,B => C iff B,C => C
19:05:16 <scook0> in most logics, you can add, drop, and duplicate your premises as much as you want
19:05:26 <skew> substructural logics drop some of those rules, so you only get to use hypotheses once (uniqueness, states of a mutable object), or in the order you introduced them (stack items, some region alloction stuff)
19:05:36 <scook0> if you take away one or more of these "obvious" structural rules, you get a substructural logic
19:05:53 <chessguy> wait, "most logics"?
19:06:14 <scook0> it can be useful for things like, say, proving that a filehandle is never used after it is closed, using the type system
19:06:27 <EvilTerran> chessguy, linear logic has limitations on that sort of thing
19:06:46 <ddarius> chessguy: Obviously substructural logics don't have (all of) these rules.
19:06:57 <scook0> chessguy: there are many different systems of logic, with their own different sets of rules
19:07:10 <EvilTerran> in that you "consume" a proposition when you use it in a deductive step
19:07:45 <chessguy> like, there are systems of logic in which A => B does not imply ~A => ~B?
19:07:55 <chessguy> err
19:08:15 <chessguy> ~B => ~A
19:08:19 <ddarius> chessguy: You can have the symbols mean anything, but what is being changed here is something a bit different (though it could be cast in that form)
19:08:39 <scook0> normally, if you have premises A and A => B
19:08:53 <scook0> you can apply modus ponens, and end up with A, A => B, B
19:09:16 <scook0> but if your logic doesn't allow duplication, you might only end up with B
19:09:28 <scook0> i.e. you can't use A or A => B to prove anything else
19:09:46 <chessguy> what would you call the most basic logical system that most people learn
19:09:47 <SideFFect> whats up all!
19:09:58 <ddarius> chessguy: classical logic
19:09:59 <EvilTerran> or, given A, A => B, A => C, maybe you can deduce B, or C, but not both
19:10:01 <wli> chessguy: A lot of logics used for programming language theory don't even have "not" or ~
19:10:24 <EvilTerran> because the A is "consumed" by an application of modus ponens
19:10:33 <ddarius> chessguy: classical propositional logic if I wanted something more "basic"
19:10:37 <dons> ?tiny-url http://okmij.org/ftp/Haskell/types.html#state-algebra
19:10:38 <lambdabot> http://tinyurl.com/2fzesc
19:10:43 <Pseudonym> chessguy: One-valued logic.
19:10:45 <Pseudonym> True = False
19:10:58 <Pseudonym> Except most people don't learn it.  It comes naturally.
19:11:12 <ddarius> I was about to steal your punchline, but I decided not to.
19:11:23 <Pseudonym> You're too kind.
19:11:29 <Pseudonym> (For your own good.)
19:11:41 <ddarius> Probably.
19:12:04 <chessguy> is there a simple way to completely define a logical system?
19:12:33 <ddarius> chessguy: You specify the axioms and the rules of inference.
19:12:44 <EvilTerran> you'll need a grammar, too
19:13:10 <chessguy> so...it's basically a language
19:13:12 <Pseudonym> Sequents?
19:13:14 <Pseudonym> Just a suggestion.
19:13:19 <EvilTerran> it gets a bit circular, tho, 'cos your logics'll be defined in terms of sets and rewrites and things, and those'll all be defined in a logic...
19:14:49 <scook0> chessguy: do you know anything about the Curry-Howard correspondence?
19:15:12 <chessguy> types as implications
19:15:20 <chessguy> a bit
19:15:23 <ray> they wrote each other lots of letters?
19:15:29 <chessguy> @slap ray
19:15:30 * lambdabot activates her slap-o-matic...
19:15:52 <scook0> so remember when I mentioned using A and A => B to conclude B
19:16:04 <scook0> well, if A is the type of open file handles
19:16:13 <scook0> and A => B is the type of the close operation
19:16:26 <scook0> then once I've closed the handle, I can't accidentally close it again
19:16:34 <scook0> because the type system won't let me
19:16:48 <chessguy> interesting
19:17:17 <shachaf> scook0: But can you use the close operation again?
19:17:30 <skew> shachaf: it consumed the file handle
19:17:43 <chessguy> can you do that with pattern matching too?
19:17:56 <EvilTerran> it consumes the type, so another close operation would be a type error
19:17:57 <chessguy> data FileHandle = Open String | Closed
19:18:10 <scook0> I don't really know the subtle details
19:18:14 <shachaf> Oh, right.
19:18:23 <scook0> I imagine that either duplication of "close" is ok
19:18:32 <scook0> or else opening a file would give you a new "close" operation
19:18:33 <EvilTerran> as it were
19:18:34 <ddarius> You can easily have intuitionistic assumptions of linear implications.
19:19:08 <skew> if you have cake, and if you have cake you can eat cake, then you can't conclude you can have cake and eat it
19:19:20 <scook0> so A is a linear proposition, but A => B is not a linear proposition?
19:19:22 <EvilTerran> but i also have three PS3s!
19:19:25 <scook0> (in this case)
19:20:02 <ddarius> scook0: Yes(ish).
19:20:26 <ddarius> Usually, A -o B is used for linear implication.
19:20:30 * EvilTerran notes he is rambling, so heads off to sleep
19:20:45 * scook0 realises he has ATTaPL sitting on his desk...
19:21:12 <scook0> "Chapter 1: Substructural Type Systems"
19:21:17 * ddarius wonders why IRC is still working but POP and HTTP aren't...
19:22:03 <sorear> ddarius: Something has decided to start dropping SYN packets maybe?  IRC uses one connection per session, POP/HTTP need to create connections often
19:22:23 <ray> that happens to me way too often
19:22:37 <chessguy> scook0, is that the sequel to TAPL?
19:22:48 <scook0> chessguy: more or less
19:23:07 <chessguy> well, yes, using the term "sequel" loosely
19:23:47 <scook0> e.g. most of the chapters are not by Pierce
19:24:01 <chessguy> oh
19:24:07 <scook0> (he's the editor)
19:24:18 <scook0> and it has a more diverse range of topics
19:29:14 <Pseudonym> It does, however, accurately describe how things work.
19:29:27 <Pseudonym> TaPL stops around the point that all modern type theory has in common.
19:29:43 <Pseudonym> And ATTaPL is where they branch.
19:33:11 <user317> hm, how come i cant load modules into ghci anymore, :m + Utilrnmodule main:Util is not loaded
19:34:00 <scook0> :load ?
19:34:07 <user317> what about adding mroe modules
19:34:41 <wli> I just want to know how module systems and HM(X) work.
19:42:42 <newsham> ddarius: is your dns out perhaps?
19:42:57 <newsham> pop and http wont work so well if they cant resolve the address they wish to connect to
19:56:58 * monochrom builds ghc, using -H512M.  This is aka "RAM test". :)
20:46:46 <dataangel> How do you check things in a constructor in Haskell? Like what if you wanted a runtime check to make sure an integer given to a constructor is only in a certain range?
20:46:48 * dataangel is curious
20:47:13 <dibblego> make the type abstract and check on the function
20:48:38 <scook0> (which unfortunately means you can't use pattern-matching outside the abstraction boundary)
20:49:11 <dons> ?google smart constructor site:haskell.org
20:49:13 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
20:49:13 <lambdabot> Title: Smart constructors - HaskellWiki
20:49:19 <dons> dataangel: ^^
20:49:32 <dons> you can lift some into the type if you're careful
20:51:40 <nburlett> hey all
20:51:52 <sorear> hello?
20:51:59 <nburlett> hello sorear
20:52:16 <nburlett> I'm trying to find a function String -> [Word8]
20:53:35 <nburlett> other than, say, error
20:53:47 <dons> map (fromIntegral.chr )
20:54:01 <sorear> const []
20:54:07 <allbery_m> heh
20:54:10 <nburlett> > map (fromIntegral.chr) "hello"
20:54:12 <dons> :t Data.ByteString.unpack . Data.ByteString.Char8.pack
20:54:12 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
20:54:13 <lambdabot> String -> [Word8]
20:54:15 <dons> :t chr
20:54:16 <sorear> @djinn String -> [Word8]
20:54:16 <lambdabot> -- f cannot be realized.
20:54:16 <lambdabot> Int -> Char
20:54:17 <dons> :t ord
20:54:18 <lambdabot> Char -> Int
20:54:25 <dons> :t map (fromIntegral. ord)
20:54:26 <lambdabot> forall b. (Num b) => [Char] -> [b]
20:54:27 <allbery_m> :t map fromEnum
20:54:28 <lambdabot> forall a. (Enum a) => [a] -> [Int]
20:54:35 <allbery_m> ehoops
20:54:46 <sorear> nburlett: look at the encoding or utf8-string package on hackage
20:54:55 <nburlett> sorear: ok
20:55:05 <dons> map (fromIntegral. ord) is perfectly suitable though
20:55:14 <nburlett> > map (fromIntegral.ord) "hello"
20:55:16 <lambdabot>  [104,101,108,108,111]
20:55:19 <nburlett> spiffy
20:55:30 <dons> > "\1233321"
20:55:31 <lambdabot>  Character constant out of range at ""\123..." (column 1)
20:55:33 <dons> > "\12331"
20:55:34 <lambdabot>  "\12331"
20:55:40 <dons> > map (fromIntegral.ord) "\12331"
20:55:41 <lambdabot>  [12331]
20:55:47 <dons> > map (fromIntegral.ord) "\12331" :: [Word8]
20:55:48 <lambdabot>  [43]
20:55:50 <dons> :)
20:57:31 <newsham> are the Char8 IO functions?
20:57:37 <newsham> or BS IO functions?
20:57:54 <nburlett> also, why are women from the future always hot? :->
20:58:31 <Korollary> they evolved more
20:58:32 <newsham> nburlett: politically incorrect unnatural selection]
20:58:50 * nburlett watches ST TNG
20:59:42 <Korollary> those are actors I believe
21:00:06 <newsham> ahh.. thats caused by another phenomenon: cute girls acting geeky increases ratings on scifi programs
21:01:27 <dons> ah yes. the Kaylee syndrome
21:01:36 <thoughtpolice> understandable
21:02:29 <newsham> its cheaper than spending more on writers
21:03:32 <nburlett> heh
21:08:52 <olsner> heh, The Kaylee Syndrome
21:08:52 <Korollary> the objective of human experience is to cram as many good looking people as possible into a tv show
21:10:28 <olsner> (Trek series usually only have one cute girl per series though)
21:10:53 <goalieca> and hot guests actresses
21:11:01 <olsner> not counting the random appearances of hot alien chicks for Kirk (or spock!) to seduce
21:11:57 <newsham> you can always watch 'the big bang theory'
21:12:36 <olsner> (... one would think the future should have some protocol for intimacy with new species!)
21:13:13 * nburlett doesn't have cable
21:13:27 <allbery_m> niven already covered that one, I think...
21:13:27 * nburlett is watching TNG on DVD
21:25:10 <newsham> its not on the cable
21:45:36 <nburlett> hmm.. if I have a lazy ByteString, and want to pass it to a function that takes a strict byte string, what's the best method?
21:47:21 <nburlett> actually, hm.. nano-md5 returns a string, not an array of bytes
21:53:16 <Elifant> Hello all. I have generalized HughesPJ pretty-printer so it can work on any type of elements, e.g. widgets, not just text. I have done this in order to be able to pretty-print text with ANSI-colored components. Is anyone interested?
21:53:46 <phlpp> hi
21:59:33 <dfranke> (#darcs seems to be dead but maybe someone here can answer...)
21:59:35 <dfranke> How robust is darcs against being killed while merging a patch?
21:59:38 <dfranke> I want to run a darcs repo off of Dreamhost, but they have a daemon that kills processes that are eating CPU time.  Is there any danger that that will corrupt the repository?
22:03:59 <glguy> darcs is pretty good at repository corruption
22:04:14 <glguy> I'd be wary
22:07:34 <wli> Not so sure of that.
22:08:35 <glguy> darcs does have a good record of corruption. I don't know that it is due to being killed for cpu time during a merge
22:09:34 <dataangel> Is there any difference between peano numbers and church numerals?
22:10:20 <dfranke> well, yes and no.  They're isomorphic concepts in two different axiomatic systems.
22:12:19 <dataangel> that's what I thought, just sanity checking
22:12:32 <dataangel> it didn't occur to me why you'd have two different names but I think that makes sense
22:14:41 <dataangel> Why do type arithmetic with peano numbers instead of a binary representation? Seems like the latter would be a lot more efficient.
22:16:18 * dataangel points out that for once something non-dangerous but useful is easier in C++ -- templates can be parameterized on integers fresh out of the box
22:17:04 <dfranke> The Peano numbers aren't intended for machine implementation.  They're just an attempt at describing the natural numbers using axioms that are simple as possible.
22:17:28 <dataangel> ah, the wiki uses peano numbers to help with smart constructors
22:18:11 <dfranke> yeah, that's for the most part just wanking :-)
22:18:42 <dons> dcoutts: streams (the data type) in the mlton prelude! http://mlton.org/cgi-bin/viewsvn.cgi/mltonlib/trunk/com/ssh/extended-basis/unstable/public/sequence/stream.sig?view=auto
22:18:48 <lambdabot> Title: Repository - markup - svn: mltonlib/trunk/com/ssh/extended-basis/unstable/public ..., http://tinyurl.com/2qb6dv
22:19:30 <newsham> unary arithmetic might not be efficient to implement but its efficient to describe the semantics of
22:19:32 <dons> dcoutts: from this thread, http://www.nabble.com/Stream-Fusion-t3665484.html
22:19:33 <lambdabot> Title: Nabble - MLton - User - Stream Fusion
22:24:24 <scodil> does anyone know the rules by which ghc decides to honor {-# UNPACK #-} directives?
22:24:57 <dons> its strict, and not a function, has one constructor
22:25:30 <scodil> see that's what I thought, but its not unpacking
22:25:40 <dons> you need -O to turn it on
22:26:07 <dons> and you should see a constructor generated with unboxed components, in the -ddump-simpl output
22:26:17 <luqui> I want to peek at the code haskell generates, but I can't understand .hc files.  Is there an earlier or prettier intermediate stage I can look at?
22:26:41 <dons> ghc -O2 Foo.hs -ddump-simpl | less
22:26:43 <dons> is what I use
22:26:50 <dons> sometimes with HsColor -tty to colorise
22:27:02 <dons> its much the same as .hcr, but with better names
22:27:15 <dons> Lemmih: has a prettyCore function that cleans up the result
22:27:17 <scodil> if i write the simple, non-polymorphic version, it unboxes, but the nicer polymorphic data type doesnt get unboxed
22:27:34 <dons> oh, polymorphic fields won't get unboxed
22:27:46 <dons> you'll have to apply and specialise
22:27:56 <luqui> cool, thanks! :-)
22:27:56 <scodil> and what does that involve
22:28:31 <dons> well, pick a monomorphic type for the field :)
22:28:45 <scodil> that sucks
22:28:57 <dons> scodil: there may be some other options i've not thought of
22:29:04 <dons> try asking on the ghc list
22:29:11 <dons> night all!
22:29:14 <dons> ?uptime
22:29:14 <lambdabot> uptime: 9h 10m 40s, longest uptime: 1m 10d 23h 44m 29s
22:32:18 <scodil> dons you still there?
22:37:21 <meester> i'm quite sure this is a standard function:
22:37:37 <meester> (\f g x -> (f x ,g x))
22:37:59 <meester> but i can't remember the name, anyone got a clue?
22:40:24 <araujo> @hoogle (a -> b) -> (a -> b) -> a -> (b, b)
22:40:28 <lambdabot> No matches, try a more general search
22:40:55 <nburlett> has anyone else noticed that hoogle doesn't give the right documentation links any more?
22:41:01 <olsner> @pl (\f g x -> (f x ,g x))
22:41:02 <lambdabot> liftM2 (,)
22:41:32 <meester> thanks
22:41:42 <shachaf> @ty (&&&)
22:41:43 <olsner> if what pl gives you for an expression is simpler, that's probably as close as you get to a standard function for it ;-)
22:41:57 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:42:11 <olsner> @unpl f &&& g
22:42:11 <lambdabot> (f &&& g)
22:42:13 <meester> i'm a bit hesitant to import control.arrow everytime i want to use (&&&) on standard functions
22:42:16 <shachaf> > (+1) &&& (*2) $ 5
22:42:19 <lambdabot>  (6,10)
22:42:48 <sclv> @unpl \f g -> f &&& g
22:42:49 <lambdabot> \ f g -> f &&& g
22:42:58 <sclv> oops
22:45:00 <goalieca> lol
23:00:55 <quicksilver> meester: don't be hesitant to import Control.Arrow
23:01:07 <quicksilver> meester: import only (&&&) and (***) if that's all you want
23:01:16 <quicksilver> Or even, override them to specific types if you like
23:20:26 <newsham> why so hesistant?
23:26:09 <meester> well, suppose someone looks at my code and wonders what &&& does
23:26:36 <quicksilver> suppose you'd written your own custom version
23:26:46 <quicksilver> wouldn't they then wonder what that did?
23:27:00 <quicksilver> and given the choice between the two, isn't it better to use the library version
23:27:09 <quicksilver> they may have seen it before and understand it instantly
23:27:22 <meester> given the choice, it's better to use (&&&)
23:27:42 <roconnor> @dice 1d2
23:27:42 <quicksilver> you could always add a comment for readers
23:27:42 <lambdabot> 1d2 => 2
23:28:12 <quicksilver> dons++ # more HWN goodness
23:30:38 <newsham> ?dice 6d48
23:30:38 <lambdabot> 6d48 => 103
23:44:10 <meester> it's like the difference between map and fmap
23:44:30 <meester> map is usefull, because it shows you'r working on lists
23:44:52 <meester> noone has to wonder what functor you'r working on, or wtf a functor is
23:45:29 <shachaf> meester: Unless you're specifically working in an Arrowy context, it's assumed you mean (->).
23:45:44 * shachaf thinks fmap should probably be called map.
23:55:12 * Cale too
23:56:09 <Cale> hehe, though I also think it would be rather fun to let (.) mean fmap too :)
23:56:42 <shachaf> Cale: I'm undecided about that.
23:57:00 <shachaf> (Well, I agree with the "rather fun" bit. :-) )
