00:05:44 <omnId> I wonder if it's possible to evaluate a (Data d => d) and turn it into a template haskell Exp that represents that datum.
00:06:45 <omnId> call it (toExp :: Data d => d -> Exp), then you could have compileTimePerformIO a = liftM toExp (runIO a)
00:07:41 <Cale> I don't understand that last bit
00:07:54 <Cale> But can't you already have a compileTimePerformIO?
00:08:08 <omnId> aLiteralString = $(compileTimePerformIO (readFile "blah.txt"))
00:09:14 <omnId> runIO (readFile "blah.txt") gets you a String of the file's contents.  If you could then turn that String into an Exp, the Exp could be spliced into the compiled code.
00:09:26 <P_D> > sort "ExecuteFunc"
00:09:28 <lambdabot>  "EFcceentuux"
00:09:40 <P_D> > sort $ nub "ExecuteFunc"
00:09:42 <lambdabot>  "EFcentux"
00:09:52 <omnId> Cale: do you understand that?
00:09:55 <Cale> ah, I see what you mean
00:09:58 <P_D> > map ord $ sort $ nub "ExecuteFunc"
00:09:59 <lambdabot>  [69,70,99,101,110,116,117,120]
00:10:17 <omnId> I've not used Data.Generics, any tuts anyone recommends?
00:10:42 <P_D> Trying to abstract traversals?
00:11:11 <omnId> is there any other way I could turn a String or whatever into a TH Exp?
00:12:25 <omnId> The String case isn't difficult, I was wondering the general case.
00:17:56 <roconnor> @go 1 CAD in USD
00:17:57 <lambdabot> 1 Canadian dollar = 1.04734 U.S. dollars
00:18:08 <roconnor> @go 1 AUD in USD
00:18:09 <lambdabot> 1 Australian dollar = 0.9188 U.S. dollars
00:19:36 <geocalc> @go 1 EURO in USD
00:19:37 <lambdabot> 1 Euro = 1.4406 U.S. dollars
00:19:50 <ddvlad> @go 1 RON in USD
00:19:51 <lambdabot> 1 Romanian lei = 0.431053 U.S. dollars
00:19:54 <omnId> toExp x = maybe undefined (LitE . StringL) (cast x) --  :)
00:20:02 <jedbrown> @go 1 CHF in USD
00:20:03 <lambdabot> 1 Swiss franc = 0.859107 U.S. dollars
00:20:06 <ddvlad> wow... i wasn't expencting that to work =)
00:20:33 <roconnor> oh the US dropped intrest rates again?
00:20:48 <roconnor> they're crazy!
00:21:01 <wli> How would one predict exchange rates from interest rates and all that?
00:21:26 <P_D> power series for bank lending?
00:21:44 <roconnor> dropping intrest rates decreases the demand for the currency
00:22:10 <wli> Well, it's more a question of which model to use on what empirical data.
00:22:14 <roconnor> less demand for an objects generally means a the objects value decreases.
00:22:30 <wli> s/value/price/
00:22:42 <roconnor> value = price in other currencies
00:22:54 <roconnor> on the flip side
00:23:07 <roconnor> lower intrest rates means that more people are inclided to borrow money
00:23:14 <roconnor> this increases the supply of USD
00:23:21 <roconnor> which also decreases the value of the USD.
00:23:30 <jewel> maybe that's what they want
00:23:44 <roconnor> jewel: actually that is a good point.
00:23:45 <wli> Is this a "beggar thy neighbor" I see before me?
00:24:52 <roconnor> jewel: I keep forgetting that a low USD is probably good for the US.  I sort of guess that they want to lower the US dollar while at the same time saying that they support a strong dollar.
00:27:42 <jewel> It makes imports more expensive and decreases the value of all that money in USD that foreign governments are holding
00:28:52 <wli> It also increases the national debt.
00:29:10 <jewel> I guess if they were scared that the currency would collapse, this is a way to push it down gently and let the market find an equilibrium
00:29:59 <geocalc> lol                 ^^
00:30:36 <jewel> ?
00:30:49 <wli> They must be true believers in markets despite imperfect information, imperfect competition, etc.
00:31:12 <geocalc> equilibrium will never be
00:31:14 <jewel> i didn't say anything about a perfect market
00:32:50 <geocalc> a perfect market is all for free
00:33:10 <wli> Well, they're not necessarily _your_ assumptions. But anyhow they do seriously call into question the existence and uniqueness of an equilibrium (or, for that matter, whether there is a tendency to approach equilibrium points or enter into limit cycles when they do exist).
00:33:58 <jewel> equlibrium was probably the wrong word to use, maybe I should I have said 'stable state'
00:34:51 <P_D> you can never be in equilbrium as long as the sun shines and the sky.. doesn't shine.
00:35:17 <geocalc> you forgot the richest that break a stable state to make more profits
00:36:25 <oklokok> trying to noob up a bf interp, what's wrong with data Node t = Add t | Move t | Out | In | [Node]?
00:36:37 <wli> I see no reason why it couldn't be a positive feedback loop (or why it must be). If you don't have the assumptions to satisfy the preconditions of the theory you don't get answers out of it.
00:36:47 <P_D> You need to name [Node] and parameterize it to Node t
00:37:01 <oklokok> ah.
00:37:03 <oklokok> thanks
00:37:14 <jewel> geocalc I'm talking about the global currency market, not the idea that markets are 'fair'
00:38:10 <geocalc> global == world (me too)
00:39:51 <ttfh> the cheap dollar makes importing all kinds of stuff from the US interesting
00:41:29 <geocalc> iff there's delivery services
00:41:54 <wli> I didn't know the US manufactured anything anymore.
00:42:28 <ttfh> I mean privately importing stuff
00:42:54 <ttfh> my boss just bought a 3000$ bicycle frame
00:43:56 <ac> imagine a game where you roll a die, and if it's NOT a six, you role again. Say your friend plays one "game" and gets a six, what's the probability he rolled twice?
00:44:46 <geocalc> 0
00:44:59 <ac> geocalc: huh?
00:45:01 <scook0_> well, P(1 roll) = 1/6
00:45:11 <P_D> The pig game
00:45:15 <ac> Reasoning with a probability tree (or with Bayes law), I get 4/11, but intuitively I would say it's a higher probalitiy that they rolled twice
00:45:37 <vegai> exactly two times?
00:45:57 <vegai> I mean... is two times the maximum amount of rolls in that game?
00:46:05 <ac> vegai: yeah
00:46:26 <scook0_> so P(2) = 5/6 * 1/6, perhaps?
00:46:40 <scook0_> (though I'm terrible at seat-of-the-pants probability)
00:46:50 <axm> thats the chance to roll twice
00:47:42 <scook0_> oh, I misunderstood the problem (didn't see ac's correction)
00:47:55 <scook0_> (I assumed a potentially-unbounded number of rolls)
00:48:15 <axm> ..but for the exactly twice version that should be the same
00:48:33 <axm> then see geoc.
00:48:39 <geocalc> as he get a six the probability to reroll are 0 anyway
00:49:18 <ac> geocalc: what? There are two ways to get a six: roll it on the first roll, or roll it on the second roll after rolling something other than a six
00:49:40 <axm> i think we were just talking about infinite rolls
00:50:10 <axm> but when i think about it, that series should converge
00:50:22 <scook0_> I don't see how geocalc's 0 makes sense in either game
00:50:49 <ac> scook0_: me neither
00:51:13 <scook0_> unless you interpret "rolled a six" as "rolled a six on the first roll"
00:51:15 <geocalc> ac=<< i don't understand well english :(
00:51:25 <ac> heh
00:51:27 <scook0_> ah
00:51:48 <axm> ac, for a max 2 rolls, 1/6 + 5/6*1/6 is correct
00:52:07 <axm> but the infinite rolls version is much more interesting ;)
00:53:04 <axm> so, as i understood, when you got a 6 and do not know the path to it, you have to add posibilities up. so chances for a 6 are 1 not 0
00:53:45 <roconnor> axm: since you always roll again with a 6, isn't impossible to ``get a 6'' in the game
00:53:53 <roconnor> hence 0, as geocalc said.
00:53:59 <axm> not 6 roll again
00:54:12 <omnId> 6 on second roll
00:54:43 <roconnor> err opps
00:54:45 <omnId> got a 6 somehow, either first 6, or first 1..5 + second 6.
00:54:53 <roconnor> when you don't get a six you roll agian
00:54:59 <roconnor> right
00:55:20 <geocalc> > sum [1..sum[1..8]]
00:55:22 <lambdabot>  666
00:55:31 <roconnor> ]:)
00:57:10 <omnId> since you know the end result was 6, isn't the space reduced to those six cases, of which 5 are two-roll cases, thus P = 5/6?  What do I misunderstand?
00:58:21 <ac> omnId: but there's this decreasingly small possibility that you rolled it many more times
00:58:49 <scook0_> ac: I think he's talking about the 2-rolls-max version
00:59:53 <scook0_> omnId: even with 6 cases, you haven't guaranteed that they're equally likely
01:00:11 <scook0_> (not that I've done the numbers myself)
01:00:14 <ac> omnId: two-rolls-max version is only interesting to me because the result is unintuitive.
01:00:33 <axm> rolling the 6 in the first place is six times more probable than the other cases
01:00:39 <omnId> Probability makes my head hurt.
01:01:18 * ac is attempting to pound Bayes law in to his head via the hammer method
01:01:20 <axm> drawing a tree and adding up probabilities for each desired branch helps
01:02:59 <quicksilver> ac: did you get my message?
01:03:40 <ac> quicksilver: what message?
01:03:51 <quicksilver> ac: I managed to get your mandelbrot cod 10x faster
01:04:07 <ac> quicksilver: sweet. where's the code?
01:04:10 <quicksilver> ac: the test for divergence turned out to be the key part
01:04:40 <quicksilver> one moment and I'll post it
01:04:53 <quicksilver> on my machine it dropped from 36 seconds to 3.6 seconds
01:06:15 <axm> @hoogle s -> IOLA a b -> IOSLA s a b
01:06:19 <lambdabot> No matches, try a more general search
01:06:50 <axm> is there a predefined way to convert io arrows to io state ones by giving a state?
01:07:18 <hpaste>  quicksilver pasted "faster mandelbrot" at http://hpaste.org/3569
01:07:44 <omnId> axm: I would imagine it's some incantation of arr, State, return, or some such.  Are IOLA and IOSLA abstract (do they export constructors)?
01:08:19 <axm> IOLA does, IOSLA does not (afaict), thats my problem
01:09:47 <omnId> a quick google for iosla turns up some code that uses a raw IOSLA constructor.
01:09:53 <quicksilver> you woudln't convert an IOLA to an IOSLA by supplying a state, surely
01:10:16 <axm> i can arr (arrowfn), but i am a bit stuck on how to convert the IOLA function that i can access to an approb
01:10:17 <omnId> module Control.Arrow.IOStateListArrow
01:10:17 <omnId>     ( IOSLA(..)
01:10:22 <axm> *appropriate one
01:10:30 <omnId> looks like it exports IOSLA's constructor
01:10:41 <quicksilver> IOSLAs don't "have" state. Rather they operate on it.
01:10:44 <axm> i use an api demanding an IOSLA and want to lift my IO stuff to it
01:10:48 <quicksilver> so what you'd convert an IOLA to is an IOSLA wic 'ignores' its state
01:11:26 <axm> yes
01:11:32 <quicksilver> "The first one and the last one are those used most frequently in the toolbox, and of course there are lifting functions for converting the special arrows into the more general ones."
01:11:46 <quicksilver> so apparently the function you want exists
01:12:15 <axm> there are for io arrows, but have not found some for my problem
01:12:33 <omnId> try something like: (\x -> IOSLA (\s a -> liftM ((,) s) (runIOLA x)))
01:12:36 <axm> therefore the question if i overlooked something
01:13:25 <omnId> IOSLA (\s a -> liftM ((,) s) (runIOLA x a))) -- where x :: IOLA a b
01:13:40 <omnId> does that work?
01:13:55 <axm> give me a minute
01:16:30 <jedbrown> > (map sum . tail . inits . map ((*(1%6)) . product) . inits . repeat) (5%6)
01:16:35 <lambdabot>  [1%6,11%36,91%216,671%1296,4651%7776,31031%46656,201811%279936,1288991%16796...
01:16:59 <ac> quicksilver: huh. my original code runs in about 50 seconds, and yours takes about 25 on my machine
01:17:09 <omnId> > realToFrac . (!! 10) $ (map sum . tail . inits . map ((*(1%6)) . product) . inits . repeat) (5%6) :: Double
01:17:10 <lambdabot>  0.8654120142584619
01:17:19 <omnId> > realToFrac . (!! 100) $ (map sum . tail . inits . map ((*(1%6)) . product) . inits . repeat) (5%6) :: Double
01:17:20 <lambdabot>  0.9999999899377721
01:18:39 <axm> omnId, (\x -> IOSLA (\s a -> liftM ((,) s) ((runIOLA x) a))) seems to be good, thanks
01:18:55 <omnId> understand it?  :)
01:19:28 <axm> yes. but needs to sink in more to get active knowledge..
01:19:35 <axm> *become
01:20:08 <omnId> need an IOSLA, so we construct one: IOSLA (\s a -> ...)
01:20:23 <omnId> we have an IOLA, so we run it: runIOLA x
01:20:35 <omnId> that's (a -> IO [b])
01:21:00 <quicksilver> axm: I think your problem is your types wren't polymorphic
01:21:13 <omnId> give it the 'a' from the IOSLA action and we get a result (IO [b])
01:21:15 <axm> yip, i mean, i will need time to get that fast developing it
01:21:15 <ac> quicksilver: you can get even more speed (albeit with a few artefacts) with (\(r :+ i) -> r + i < 2)
01:21:22 <quicksilver> axm: you're not supposed to write code with tye OIOLA
01:21:31 <omnId> liftM ((,) s) to pair in the state.
01:21:49 <quicksilver> axm: you're supposed to write coe with type ArrowIO m, ArrowList m
01:22:03 <quicksilver> axm: then it would be polymoprhic and would run hapilly as an IOLA or an IOSLA as required
01:22:48 <omnId> axm: active nothing, I looked at the source for the underlying types and hooked together puzzle pieces :)
01:22:53 <axm> thats a good point, let me check
01:23:46 <quicksilver> ac: that's odd. Wonder why the difference was so much greater for me. What OS/hardware are you on?
01:24:10 <ac> Intel 1.6ghz, laptop
01:24:27 <ac> er, make that 1ghz
01:24:49 <quicksilver> This is a 2.2Ghz core duo
01:24:54 <olsner> that'd make it a celeron or p3?
01:25:01 <quicksilver> but it doesn't really explain why I see a 10x speedup and you only 2x
01:25:30 <quicksilver> ac: you see how to use withArry now? much nicer than messing around with malloc
01:25:33 <ac> quicksilver: what version of ghc?
01:25:44 <P_D> there's a neat algorithm for very deep zooms where you outline a box, walk the corners of the box through the map, then when it starts to deform, you split the box into little boxes, and recurse.
01:26:23 <quicksilver> ac: 6.6.1
01:26:30 <ac> I'm using 6.8
01:26:55 <ac> quicksilver: ah I see, withArray takes a list. I thought it took an array for some reason
01:27:04 <ac> yes, that is quite simple
01:27:16 <olsner> hmm, so perhaps the base case is 5x better in 6.8 than in 6.6.1 then?
01:27:23 <ac> olsner: that's what I was thinking
01:27:58 <quicksilver>  could be
01:28:07 <ac> quicksilver's machine is fast enough that my faster base case runs slower than his slower base case in absolute terms
01:28:07 <quicksilver> could be 6.8 has a last slow implementation of Data.Complex
01:28:12 <quicksilver> that was the problem, here
01:28:32 <quicksilver> last = less
01:28:32 <quicksilver> :)
01:28:53 <ac> I should experiment with using tupples
01:28:55 <quicksilver> I sped it up by avoiding calls to the very slow 'abs' implementation
01:28:59 <quicksilver> no point
01:29:04 <quicksilver> Data.Complex *is* a tuple
01:29:19 * olsner jumps on the bike and heads off to work
01:29:24 <quicksilver> I did try hand-writing the multiplication in z*z
01:29:25 <quicksilver> but it wasn't any better
01:35:06 <ac> I was hoping it would be comparible to c ;P
01:35:56 <jedbrown> How optimized is Ratio Int?  I want to define a new ordering on the dyadic numbers on the interval and I'm wondering how much work it will be to roll my own type as opposed to subverting Ratio.
01:38:15 <omnId> @src Ratio
01:38:15 <lambdabot> data (Integral a) => Ratio a = !a :% !a
01:45:05 <ac> According to benchmarks I've seen, ghc should be within half to a fifth of gcc. Is that about right?
01:46:29 <dcoutts> ac: for the same algorithm, yes.
01:46:33 <Cale> http://www.secrettechnology.com/zombie/lovesickzombie6.html -- this game is awesome
01:46:36 <lambdabot> Title: lovesickzombie6: alarmingly these are not lovesick zombies a game/artwork by Jas ...
01:46:56 <dcoutts> bah, "get flash" it tells me
01:46:56 <ac> that's why I'm curious, because a similar c program I wrote is a good 30 times faster
01:47:19 <dcoutts> ac: does you Haskell version use lists and your C version use something else?
01:47:35 <dcoutts> does your C version use int and your Haskell one Integer?
01:47:55 <ac> dcoutts: floats for all
01:48:17 <dcoutts> ac: ok, arrays of floats?
01:48:32 <ac> dcoutts: actually, C version uses doubles, ghc version is using floats
01:50:17 <P_D> rare is the compiler that actually has an x86 machine do float arithmetic
01:50:25 <P_D> you have to pass a flag to gcc to force it
01:50:37 <P_D> it helps with cache performance, but that's not an issue for your basic mandelbrot.
01:50:55 <P_D> it = using floats w/ double arithmetic
01:52:17 <dcoutts> ac: so are you working with arrays in the C version? or is it just some tight loop with no data structures at all?
01:52:26 <salierix> What's "boxing" and "unboxing"?
01:52:58 <P_D> you've got values, and pointers to values.  boxing adds a layer of indirection, unboxing removes it
01:53:19 <ac> dcoutts: it's just a loop. The ghc version is writing to a Ptr Word8, and the C version is making a library call in the tight loop
01:54:16 <quicksilver> dcoutts: http://hpaste.org/3569
01:54:27 <quicksilver> dcoutts: the core of the code is just the function 'mandlebrot'
01:54:47 <quicksilver> dcoutts: I had a very cursory look at the core and stuff looked like it was unboxing and prim-opping ok
01:54:54 <dcoutts> ah, list fusion
01:55:06 <dcoutts> mandelbrot should fuse but it does not under build/foldr
01:55:14 <dcoutts> because length is a foldl and cannot be fused
01:55:23 <dcoutts> (it'd work with stream fusion)
01:56:01 <quicksilver> ac: I established that the overhead isn't in the Ptr/array/texture handling
01:56:18 <quicksilver> ac: if I replace mandelbrot with 'const 0' I get a black 512x512 box in about 0.05 seconds
01:56:28 <quicksilver> ac: so the bottleneck really is the mandelbrot code
01:56:37 <dcoutts> mandelbrot really is allocating list cells, a lot
01:56:59 <quicksilver> is there a way of rewriting it which is cleverer?
01:57:06 <dcoutts> rewrite it to not use lists
01:57:14 * quicksilver sobs
01:57:20 <quicksilver> I can't just replace length with something fusible?
01:57:50 <dcoutts> quicksilver: well you could use a foldr version of length
01:57:58 <dcoutts> then it'd fuse, but that might still be slow
01:58:17 <ac> dcoutts: the lists are so pretty ;)
01:58:40 <dcoutts> ac: yes, that's why we implemented stream fusion, so you could write things just like that
01:59:08 <dcoutts> but stream fusion is not the standard fusion system in ghc yet, it's in a separate list lib
01:59:09 <ac> composing functions that operate on lazy lists is one of my favorite things about Haskell
01:59:23 <dcoutts> yes, we like it too, which is why we wanted it to be fast
01:59:35 <dcoutts> @google stream fusion lists nothing
01:59:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
01:59:37 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
01:59:59 <omnId> not much overhead to nothing
02:00:26 <dcoutts> but in the absence of that, you'd have to manually fuse that mandelbrot function
02:00:34 <atom> @src Mult
02:00:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:00:47 <dcoutts> ac, quicksilver: or go try it with our stream fusion list library
02:01:01 <ac> dcoutts: that sounds a lot more interesting. How do I do that?
02:01:27 <ac> dcoutts: (the results would be more interesting, not the process I mean)
02:01:40 <dcoutts> ac: see the link above
02:01:59 <quicksilver> dcoutts: I can't, cos I'm on 6.6 :) But I'll be interested if ac tries.
02:02:13 <dcoutts> quicksilver: we did the development with 6.6
02:02:21 <quicksilver> how do I get gc statistics? I thought it was -RTS -sstderr
02:02:22 <ac> dcoutts: Should I read the paper while I'm at it?
02:02:41 <dcoutts> ac: yes, and you can watch the video of the presentation if you like :-)
02:03:45 <ac> is the author the dons of this channel?
02:04:20 <dcoutts> ac: yes, me and dons (and rl who is not in this channel)
02:04:54 <quicksilver> FWIW, a foldr version of length increases time by about 10% for me
02:05:27 <dcoutts> quicksilver: compile with -dump-simpl-stats and check how many occurences of build/foldr there were
02:06:27 <quicksilver> dcoutts: it does increase from 3 to 4
02:06:27 <ac> dcoutts: should I get all three of those darcs links, and recompile ghc?
02:06:37 <ttfh> is there a standard 2d vector somewhere?
02:06:59 <dcoutts> ac: you probably only need the list lib, and don't need to recompile ghc
02:08:13 <dcoutts> quicksilver: right, so a length as a foldr fuses, but it's just a silly way to write length
02:08:25 <dcoutts> which is why you want a fusion system that fuses foldls
02:08:47 <quicksilver> ttfh: (Double,Double) perhaps?
02:09:37 <ttfh> quicksilver: yes, but if i want vector addition, multiplication, scaling and so on
02:09:59 <quicksilver> ttfh: not a 'standard' one as such
02:10:01 <geocalc> dons is the hard workeer here
02:10:06 <quicksilver> there are some linear alg libs though
02:10:14 <quicksilver> wli was using one yesterday
02:11:18 <ac> dcoutts: I assume I need to "import Data.List.Stream" to use this library, but that's it?
02:11:38 <ttfh> they also have it as an example on wikibooks, making a Vector type and making it an instance of Num
02:11:41 <P_D> There's GSLHaskell
02:12:18 <dcoutts> ac: and import qualified Prelude to hide the equivalent standard functions
02:12:20 <quicksilver> you can argue about whether it's sensible to make vectors instances of num
02:12:28 <doserj> numericprelude contains a vectorspace class, with 2-tuples, and 3-tuples, e.g., as instances
02:12:35 <ac> dcoutts: right. I just got a bunc of ambiguous errors ;)
02:12:51 <quicksilver> dcoutts: I wonder if any of dons' funky compiler flags help with this
02:12:58 <quicksilver> dcoutts: he did have some flags for faster FP math
02:13:08 <ac> dcoutts: how do I save things from Prelude like ($), and hide all the list stuff?
02:13:21 <dcoutts> ac: import Prelude (($), foo, bar)
02:13:34 <quicksilver> or, import Prelude hiding (foldr,foldl,length)
02:13:37 <dcoutts> ac: and use -O2
02:13:40 <quicksilver> depending which list is easier to write :)
02:13:47 <ac> the latter definitely
02:14:12 <dcoutts> quicksilver: yeah, probably, -optc-fast-math ? and things like that
02:14:13 <ac> I can't say "import Data.List.Stream overriding Prelude" or something?
02:14:17 <ttfh> doserj: numericprelude?
02:14:22 <dcoutts> ac: sadly not
02:14:23 <geocalc> SSE's are missing in ghc
02:15:05 <doserj> @where numericprelude
02:15:06 <lambdabot> darcs.haskell.org/numericprelude/
02:15:33 <doserj> it should be known (and used, and tested) more widely...
02:16:41 <ttfh> hmm, yes, NumericPrelude, GSLHaskell seems to have a lot of things i don't need
02:16:52 <ac> dcoutts: well cool. looks like that gave me a good 33% speedup
02:17:22 <dcoutts> ac: try a microbenchmark of just the mandlebrot function
02:17:22 <quicksilver> geocalc: SSE isn't *entirely* missing
02:17:41 <ac> dcoutts: like quicksilver said, the rest of it is about .05 seconds
02:17:48 <dcoutts> ac: and compile using -ddump-simpl-stats to tell you the number of fusion occurrences
02:17:56 <quicksilver> geocalc: but SSE will only happen if you're lucky enough that ghc produces the kind of code that gcc uses sse for
02:18:34 <quicksilver> which I suspect is quite unlikely :)
02:18:57 <quicksilver> ooh funky
02:19:06 <omnId> holy shit, Cale.  That's some SERIOUSLY trippy crap.
02:19:07 <quicksilver> ac: I get a 25% speedup from -fexcess-precision
02:19:08 <geocalc> i was thinking of SSE Num type quicksilver
02:19:14 <omnId> asdfsdasdf
02:19:15 <quicksilver> geocalc: ah sorry. Yeah, that would be nice :)
02:19:24 <Cale> omnId: haha
02:19:26 <roconnor> @yow
02:19:26 <lambdabot> What I want to find out is -- do parrots know much about Astro-Turf?
02:19:27 <quicksilver> omnId: what did cale do?
02:19:38 <Cale> omnId: Linked to a funny "game"
02:19:42 <omnId> 04:51 <!Cale> http://www.secrettechnology.com/zombie/lovesickzombie6.html -- this game is awesome
02:19:43 <lambdabot> Title: lovesickzombie6: alarmingly these are not lovesick zombies a game/artwork by Jas ...
02:19:51 <Cale> By the same author as Game Game Game and Again Game
02:20:12 <Cale> http://www.secrettechnology.com/gamegame/gamegame.swf
02:20:45 <ac> dcoutts: would I grep the compile output for "fusible" to see how many it's doing?
02:20:51 <omnId> Cale: is the "theory of games" button supposed to not do anything?
02:21:23 <Cale> No, it's supposed to load a silly video
02:21:26 <dcoutts> ac: -ddump-simpl-stats should give a very short output, just a list of rule applications and counts of other optimisations
02:23:00 <omnId> Cale: I love that I scored 4.8 thousand quadrillion points on the one level.
02:23:01 <ac> it says a number of things are fusible, one map unfused, and 3 stream/unstream fusion
02:23:16 <scook0_> incidentally, a few months ago I had a pure Haskell program that crashed when compiled with -optc-mfpmath=sse
02:23:52 <quicksilver> interestingly -optc-ffast-math makes it slower
02:23:53 <roconnor> scook0_: do you have sse instructions on your processor?
02:23:56 <quicksilver> about 20% slower
02:24:04 <scook0_> roconnor: heh, yes
02:24:11 <cinimod> I'm using runCommand "cd foo"; runCommand "pwd". cd foo succeeds but pwd says I didn't move directory. Any clues?
02:24:24 <roconnor> scook0_: I'm out of ideas then :)
02:24:33 <P_D> -ffast-math is for things like sqrt taking negative numbers
02:24:50 <quicksilver> cinimod: you are spawning a subshell and changing the dir of that shell
02:24:54 <mcp_> Does this line contain an error (unexpected `;', possibly due to bad layout)?     nodes2graphs :: [Int] -> [Graph]
02:24:55 <quicksilver> cinimod: and then it dies
02:24:58 <quicksilver> cinimod: this is a NOP :)
02:25:22 <dcoutts> ac: is that 3 fusions when compiling just the mandelbrot in a module on it's own?
02:25:33 <roconnor> I find that GHC flags do the opposite of what they say
02:25:37 <scook0_> mcp_: that line itself seems fine
02:25:43 <roconnor> for example -no-comp says compile everything
02:25:47 <cinimod> quicksilver: thanks I understand why it doesn't work. Do you know what I need to do to have the desired effect?
02:25:47 <scook0_> it's probably something just before that confusing the compiler
02:25:58 <ac> dcoutts: I have not isolated it yet. I will do that now
02:26:14 <dcoutts> ac: we'd expect 3 stream/unstream in that function
02:26:38 <mcp_> scook0, you are right, thanks
02:26:43 <ac> how would I force Haskell to actually evalluate the whole mess?
02:26:49 <quicksilver> cinimod: System.Directory.setCurrentDirectory
02:26:52 <ac> (if it's by itself)
02:26:55 <scook0_> like how a missing ; at the end of a C header file can cause bizarre error reports in your .c files :/
02:27:00 <cinimod> quicksilver: ta
02:27:05 <quicksilver> ac: printing the 'sum' of (map mandelbrot points) is one way
02:27:15 <quicksilver> ac: can't calculate the sum without calcutlating it all
02:27:15 <ac> quicksilver: than you're doing extra operations
02:27:18 <quicksilver> true
02:27:18 <dcoutts> ac: if the function is exported, ghc will try hard to compile it
02:27:22 <quicksilver> btu that's life
02:27:33 <quicksilver> you can't use data without inspecting it :)
02:27:41 <quicksilver> and inspection requires operations
02:27:55 <dcoutts> ac: if it's not exported and not used by something that is exported then ghc prunes it
02:28:03 <roconnor> @type floor
02:28:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:28:09 <roconnor> @type ceil
02:28:10 <lambdabot> Not in scope: `ceil'
02:28:13 <roconnor> @type ceiling
02:28:14 <ac> dcoutts: ah ok, I'll turn it in to a module and export it
02:28:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:28:51 <dcoutts> ac: and if you really care, it's can be interesting to look at the optimised code
02:28:55 <dcoutts> ac: -ddump-simpl
02:29:16 <geocalc> with ghc 6.8.0 of today i can compil so few hackage packages !!! don't try it
02:29:23 <omnId> quicksilver: we're summing lists to force them?  You could foldr seq ().
02:29:44 <quicksilver> omnId: only if you're sure the list contains a strict data type, though :)
02:29:46 <quicksilver> omnId: but, yes.
02:29:53 <sjanssen> rnf!
02:29:56 <quicksilver> I believe Data.Complex is strict
02:30:34 <quicksilver> ac: I have experimented with compiler flags. The only one which gives a reasonable speedup, to me, is -fexcess-precision
02:30:49 <quicksilver> ac: that gives a 20-25% speedup. It runs in 2.9 seconds now for me.
02:31:40 <salierix> Doesn't haskell have an automatic package management system yet?
02:32:14 <Cale> salierix: It has hackage/cabal
02:32:16 <P_D> cabal-install, but it doesn't run on windows yet
02:32:20 <quicksilver> that rather depends what you mean by automatic package management
02:32:47 <dcoutts> P_D: the darcs version does, we should make another release
02:32:52 <salierix> Something like ruby gems.
02:33:03 <P_D> I shall try the darcs version then
02:33:08 <geocalc> maybe it's time to good haskell programmers to help ghc dev
02:33:21 <Cale> omnId: I think game, game, game and again game was actually better :)
02:34:03 <omnId> Cale: will it take me another 15 minutes to download over 56k?  :)
02:34:16 <Cale> I don't know
02:34:23 <quicksilver> 56k? ouch :(
02:34:35 <omnId> Meh.  It works.
02:34:39 <Cale> Do you live out in the country?
02:34:42 <geocalc> 56k is death
02:34:52 <omnId> I'm a cheapass.
02:34:59 * Cale has a 900mbit/s connection
02:35:12 <Cale> er
02:35:19 <Cale> 9mbit/s, duh
02:35:31 <geocalc> hehe
02:35:43 <Cale> That'll teach me to listen to distracting videos of nonsense while trying to talk
02:36:20 <Cale> So about 1MB/s
02:36:40 <salierix> Harpy sounds very impressive. Does it actually work?
02:36:56 <mcp_> I want to return the value of anyfunc, if it fulfills some criteria. But i dont want to execute anyfunc twice. My approach (does not work):    | num > 0 = num where num = anyfunc
02:36:56 <dcoutts> salierix: apparently, yes.
02:37:31 <Cale> whoa, I'm a bit dizzy after all that
02:37:35 <quicksilver> mcp_: that looks fine.
02:37:41 <quicksilver> mcp_: probably just a syntax problem
02:37:42 <dcoutts> P_D: as I recall, there's an issue we could do with some help from some windows developer on, when it finishes installing a package it deletes the temp dir where the package was being built. Sometimes deleting files in the temp dir fails and we're not sure why yet.
02:37:50 <scook0_> mcp_: how do you know it's executing twice?
02:37:56 <Cale> I hope I don't have mild epilepsy or something :)
02:37:58 <P_D> dcoutts:  the build fails on zlib.h
02:38:00 <dcoutts> P_D: and we need some help investigating why
02:38:21 <dcoutts> P_D: are you using the latest zlib package from hackage?
02:38:22 <scook0_> (unless it fails to compile, in which case ignore me :/)
02:38:40 <mcp_> scook0, it works when i write it twice. So i assume its executed twice then.
02:38:40 <P_D> dcoutts:  I believe so, I installed it for this last night.  zlib 0.4.0.1
02:38:57 <quicksilver> mcp_: what you wrote is fine. It must just be syntax.
02:38:58 <dcoutts> P_D: oh, hmm. That's odd then.
02:38:59 <scook0_> mcp_: care to hpaste the whole function?
02:39:11 <quicksilver> mcp_: you probably need where to be on a line on its own
02:39:12 <dcoutts> P_D: could you hpaste the build log
02:39:23 <P_D> dcoutts:  it's missing zconf.h
02:39:23 <geocalc> mmh i don't understand why dev for win32 anymore
02:39:24 <quicksilver> mcp_: or you need {} around your guards
02:39:52 <dcoutts> P_D: hmm, I was pretty sure I included that in 0.4.0.1 let me check again
02:40:31 <hpaste>  mcp_ pasted " Syntax error in input (unexpected `=')" at http://hpaste.org/3570
02:40:51 <dcoutts> P_D: are you sure it's the 0.4.0.1 tarball you're using? if you look in the tarball cbits/zconf.h is definitely there
02:41:10 <hpaste>  quicksilver annotated " Syntax error in input (unexpected `=')" with "like this?" at http://hpaste.org/3570#a1
02:41:30 <axm> quicksilver, you were absolutely right about my type problem, knowing how these arrows scale makes it so much easier
02:41:58 <P_D> dcoutts:  it might be darcs,  building from tarball now
02:42:26 <quicksilver> axm: cool :)
02:42:50 <quicksilver> axm: if explicit 'lifting' functions between types are missing it's often because you're expected to write polymorphically
02:43:07 <dcoutts> P_D: it looks to be in the darcs repo too
02:43:12 <Cale> what's this about?
02:43:23 <Cale> (the polymorphism)
02:43:29 <P_D> dcoutts:  yes, it apparently just doesn't install it
02:43:55 <dcoutts> P_D: ohhh, so you get this error not when building zlib, but when building cabal-install ?
02:43:58 <axm> this was about lifting a ArrowIO to ArrowStateIO
02:44:08 <axm> it just was not necessary
02:44:19 <ac> dcoutts: were you interested in seeing the compile stats for the lone mandelbrot function?
02:44:21 <mcp_> I just found out, that i have to put the where to the bottom after all options.
02:44:25 <P_D> dcoutts:  error is on building cabal.  copying zconf.h to zlib...\ghc...\include lets cabal compile
02:44:25 <dcoutts> ac: sure
02:44:33 <quicksilver> Cale: he wanted to convert IOLA to IOSLA
02:44:44 <quicksilver> Cale: it is possible to write the function to do that
02:44:52 <P_D> *cabal-install
02:45:01 <quicksilver> Cale: but it's better just to use (ArrowList l,ArrowIO l) => l in the first place
02:45:01 <dcoutts> P_D: right, ok. That makes a lot more sense.
02:45:10 <quicksilver> Cale: and then you can use it at either type
02:45:17 <axm> i was confused that arrowIO "constructs" IOSLAs as well
02:45:38 <Cale> ah, yeah
02:45:45 <dcoutts> P_D: ok, if your hack works I'll fix up the zlib package to install the zconf.h along with zlib.h
02:45:47 <quicksilver> mcp_: right. Where scopes over all guards.
02:45:52 <hpaste>  ac pasted "-ddump-simpl-stats of just the mandelbrot function (everything else commented)" at http://hpaste.org/3571
02:48:27 <quicksilver> ac: Complex Float ought to be slower that Complex Double, by the way
02:48:33 <quicksilver> ac: not sure when you switched to floats
02:48:47 <P_D> dcoutts:  cabal seems to be running.  do you have any more details on that bug?
02:49:18 <dcoutts> P_D: so try using the cabal.exe program to install some packages from hackage, see how it goes
02:49:40 <P_D> yep...
02:49:54 <dcoutts> P_D: I found occasionally that it'd build install and register a package, and then fail deleting the temp dir that the package got built int
02:50:01 <dcoutts> with a permission denied error
02:50:21 <dcoutts> as if the file was still in use, though we waited for the program that was using it to terminate
02:54:36 <P_D> Hard finding things to install.  Lots of stuff already installed, some things expect posix, some can't resolve dependencies
02:55:10 <mcp_> is there an easy way to specify a list of items to be removed from another list. Like remove [2,3] [1,2,3,4] should yield [1,4]
02:55:48 <Syzygy-> > [1,2,3,4] \\ [2,3]
02:55:49 <lambdabot>  [1,4]
02:55:53 <Syzygy-> Like that?
02:55:59 <P_D> > filter (not $ elem [2,3]) [1,2,3,4]
02:56:00 <lambdabot>  Couldn't match expected type `Bool'
02:56:05 <mcp_> Syzygy-, interesting
02:56:07 <P_D> > filter (not . elem [2,3]) [1,2,3,4]
02:56:08 <lambdabot>   add an instance declaration for (Num [[t]])
02:56:08 <lambdabot>     In the expression: 4
02:56:15 <dcoutts> P_D: try haxml perhaps
02:56:19 <Syzygy-> > [1,2,3,4,2,4,3] \\ [2,3]
02:56:20 <lambdabot>  [1,4,2,4,3]
02:56:34 <Syzygy-> Thus, do note, that \\ only removes the first occurrence of each member in the list.
02:56:38 <Syzygy-> > [1,2,3,4,2,4,3] \\ [2,3,2]
02:56:39 <lambdabot>  [1,4,4,3]
02:56:48 <mcp_> Syzygy-, no problem, i use nub first anyways
02:56:51 <Syzygy-> @src (\\)
02:56:51 <lambdabot> (\\) = foldl (flip delete)
02:57:18 <P_D> I would suggest case insensitivity, or a suggestion if there's a case insensitive alternative
02:58:24 <EvilTerran> foldl (flip $ deleteBy $ compare `on` toUpper) --?
02:58:45 <P_D> dcoutts:  HaXml doesn't type check =)
02:58:51 <geocalc> > map (\\ [2,3]) [1,2,3,4,2,4,3]
02:58:52 <lambdabot>   add an instance declaration for (Num [a])
02:58:52 <lambdabot>     In the expression: 3
02:59:01 <malcolmw> P_D: dcoutts: but note that the current release of HaXml fails to build, because there is one module that didn't get tested before I built the package
02:59:17 <malcolmw> I'm meaning to get back to it real soon now
02:59:27 <ac> quicksilver: I just tested Float vs Double with a pure benchmark (summing the results) and Float is 1.6 times faster
02:59:55 <quicksilver> that's very odd
02:59:56 <dcoutts> P_D: try the older haxml version, 1.13.2 iirc. Use cabal list haxml to find it
03:00:08 <ac> I did use -fexcess-precision
03:00:12 <EvilTerran> quicksilver, ac; maybe it's a cache locality etc thing?
03:00:25 <EvilTerran> given that doubles take up more space...
03:00:27 <P_D> > filter ((flip . elem) [2,3]) [1,2,3,4]
03:00:28 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Bool'
03:00:36 <P_D> > filter ((flip elem) [2,3]) [1,2,3,4]
03:00:37 <lambdabot>  [2,3]
03:00:50 <dcoutts> P_D: were you referring to cabal-install when you were mentioning case insensitivity?
03:00:52 <P_D> > filter ((not . (flip elem)) [2,3]) [1,2,3,4]
03:00:53 <lambdabot>  Couldn't match expected type `Bool'
03:00:55 <P_D> dcoutts:  yes
03:01:00 <EvilTerran> @src intersectBy
03:01:01 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
03:01:08 <quicksilver> EvilTerran: they shouldn't really be being stored..
03:01:11 <P_D> dcoutts: haxml vs HaXml
03:01:14 <quicksilver> ac: it's 4x slower for me
03:01:24 <quicksilver> ac: 2.9 seconds -> 12.3 seconds
03:01:24 <P_D> evilterran: thank you =)
03:01:27 <ac> quicksilver: hah. goes to show how silly benchmarks are
03:01:32 <EvilTerran> @src intersect
03:01:32 <lambdabot> intersect = intersectBy (==)
03:01:44 <quicksilver> ac: did you try -fexcess-precision yet?
03:01:47 <dcoutts> P_D: oh when you say install. Right. It's case insensitive for searching but not install at the moment I guess. Want to file a bug report?
03:01:59 <ac> quicksilver: yeah, all of these tests so far are with it
03:02:00 <dcoutts> http://hackage.haskell.org/trac/hackage/
03:02:02 <lambdabot> Title: Hackage - Trac
03:02:11 <EvilTerran> that's a bit of an odd definition, actually. (\xs ys -> filter (`elem` ys) xs) would work fine, i think
03:04:17 <malcolmw> P_D: btw, it is a one-line fix to get HaXml-1.19 to build
03:04:42 <P_D> malcolmw:  that's ok, I'm just using it to test cabal
03:04:55 <malcolmw> understood
03:11:44 <mcp_> I get a paramter, that i never want to use as its passed, but always in a modified form (its a list, and i want some things appended). Can I overwrite a passed in parameter in a where clause? Would look like    where param = param++["something"].
03:12:32 <opqdonut> nah you need where param' = param++foo
03:12:41 <opqdonut> that would create a recursive one
03:12:43 <EvilTerran> > let f x = x where x = "something"++x
03:12:43 <lambdabot>  Parse error at end of input
03:12:48 <EvilTerran> > let f x = x where x = "something"++x in f "test"
03:12:53 <lambdabot>  "somethingsomethingsomethingsomethingsomethingsomethingsomethingsomethingsom...
03:12:56 <opqdonut> :)
03:13:01 <opqdonut> exactly
03:14:07 <mcp_> ok, so i give it a new name.
03:14:53 <mcp_> What does different arities mean? Is that the number of function parameters?
03:15:19 <mcp_> sometimes things are really confusing in haskell
03:15:36 <quicksilver> yes
03:15:41 <quicksilver> arity = number of parameters
03:17:34 <opqdonut> earlier i asked about that O(1)-set-membership-bookkeeping thing, i tried just nubbing the list of states at each step and got a thousandfold decrease in running time
03:17:40 <opqdonut> for some pathological inputs
03:18:01 <opqdonut> yay \o/
03:18:02 <EvilTerran> mcp_, yes on both counts, although sometimes things are really confusing anywhere :)
03:18:30 <Cale> opqdonut: hm?
03:19:00 <EvilTerran> opqdonut, Data.Set's O(log n) not good enough for ya?
03:19:09 <Cale> > nub [1..]
03:19:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:19:18 <opqdonut> yeah i know, nub is O(n^2)
03:19:26 <P_D> there's no such thing as O(1) when you've got to random access O(n) elements
03:19:33 <Cale> Shouldn't that have taken infinitely long then? ;)
03:19:40 <P_D> not the way we build computers today.
03:19:51 <opqdonut> Cale: :)
03:20:13 <opqdonut> yeah what i meant was i worried too much about the asymptotical performance :)
03:20:24 <opqdonut> but i guess i'll implement a Set just for looks
03:21:54 <Cale> You can combine the technique which nub uses with a Data.Set in order to get an O(n log n) nub which can still operate lazily.
03:21:56 <opqdonut> tho i'm still a few orders of magnitude away from the reference c implementation
03:22:13 <opqdonut> Cale: hmm, interesting
03:23:38 <salierix> Does anyone here actually use xmonad?
03:23:48 <Cale> salierix: lots of people
03:24:03 <salierix> Maybe I should give it a try.
03:24:04 <Cale> salierix: In fact, it has quite a few non-Haskell-using users as well
03:26:33 <mcp_> Ar the where clauses only executed when needed?   Can i write something like           | checkIfWhereWouldCrash = False  \n | otherwise = valueCalculatedByWhereClause
03:26:51 <Cale> > let snub xs = snub' (Data.Set.empty) xs; snub' s [] = []; snub' s (x:xs) = if x `Data.Set.member` s then snub' s xs else x : snub' (Data.Set.insert x s) xs in snub [1..]
03:26:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:27:19 <Cale> mcp_: yeah
03:27:38 <Cale> mcp_: Everything is only evaluated when needed
03:27:42 <mcp_> Cale, scary
03:27:57 <scook0> it's the magic of lazy evaluation
03:28:16 <Cale> In fact, at some level, the only thing which causes any evaluation to ever occur are case expressions.
03:29:03 <Cale> It's pattern matching which drives computation forward and forces something to happen.
03:29:56 <Cale> (There may be some exceptions to this in practical terms, but conceptually the idea works.)
03:31:07 <geocalc> > snub [1..] !! 32^24
03:31:08 <lambdabot>   Not in scope: `snub'
03:31:10 <Cale> I suppose that seq can do at least one thing which case expressions can't which is to tell the difference between the function undefined, and the function const undefined
03:33:21 <salierix> Is ghc 6.8.1 relatively stable?
03:33:49 <geocalc> no
03:34:46 <quicksilver> Cale: interesting. case f of g -> 1 doesn't force f
03:35:00 <quicksilver> Cale: it only forces if you case against a constructor
03:35:09 <quicksilver> somehow I didn't expect that
03:37:11 <EvilTerran> much like case [1..] of (x:xs) -> ... doesn't force anything past the outermost :
03:37:30 <quicksilver> yeah, but I somehow expect it always did WHNF
03:37:41 <quicksilver> in retrospect I can see it doesn't need to
03:37:47 <quicksilver> but that is what I was expecting
03:40:22 <Cale> quicksilver: Not for irrefutable pattersn
03:40:24 <Cale> patterns*
03:40:26 <mcp_> I get "Instance of Eq Graph required"  in the line  "  | ((node g from) == Nothing) = InvalidInput".  "Where node returns Maybe Graph. So, why does it need to Eq Graph??
03:41:12 <Cale> Because in order to have an instance of Eq for Maybe, it needs one for Graph
03:41:18 <EvilTerran> the instance of Eq for Maybe is instance Eq a => Eq (Maybe a)
03:41:20 <Cale> You should use isNothing
03:41:22 <EvilTerran> so it can compare Justs
03:41:41 <mcp_> Cale, thx, didnt know that
03:42:09 <Cale> For similar reasons, you should never test for the empty list using (== [])
03:42:13 <Cale> use null instead
03:42:25 <EvilTerran> or, in both cases, pattern-matching
03:43:04 <EvilTerran> if you're willing to use an extension, "| Nothing <- node g from = InvalidInput" would work with the "pattern guards" extension
03:43:16 <EvilTerran> but it's still better to use isNothing
03:44:04 <EvilTerran> pattern guards would be more helpful in the other case; say, "| Just x <- node g from = x" or whathaveyou
03:44:09 <dcoutts> @seen P_D
03:44:09 <lambdabot> I saw P_D leaving #haskell 17m 16s ago, and .
03:44:30 <mcp_> The test for empty list brings up another thing I'd like to know. Sometimes I'd like to check for existence of something in a list. So i currently do    length [y|y<-src,y==mycondition] > 0      . There must be a more elegant solution. Can you suggest one?
03:44:58 <scook0> @hoogle a -> [a] -> Bool
03:44:59 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
03:44:59 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
03:45:03 <scook0> \o/
03:45:15 <sjanssen> mcp_: not . null is better than length > 0
03:45:32 <sjanssen> mcp_: also, filter is nicer there
03:45:54 <scook0> and ultimately elem should do what you want
03:46:16 <sjanssen> putting it together: not . null . filter mycondition $ src
03:46:37 <quicksilver> sjanssen: filter (==mycondition) I think
03:46:43 <sjanssen> ah yes, equality
03:46:56 <mcp_> scook0, elem is exactly what i've been looking for. I really should have found myself.
03:47:00 <quicksilver> isn't that "any (==mycondition) src"
03:47:01 <sjanssen> elem is best.  I'm up too late :)
03:47:05 <scook0> mcp_: this is what hoogle is for
03:47:11 <quicksilver> :t any
03:47:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:47:26 <quicksilver> > any (==3) [1..]
03:47:27 <lambdabot>  True
03:47:29 <sjanssen> @src elem
03:47:30 <lambdabot> elem x    =  any (== x)
03:47:33 <quicksilver> ;)
03:47:41 <scook0> or if hoogle doesn't work, using #haskell is fine ;)
03:52:02 <Cale> :t find
03:52:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
03:52:20 <Cale> :t any
03:52:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:52:43 <Cale> mcp_: ^^ those may also be handy
03:52:49 <Cale> There's also
03:52:52 <Cale> :t all
03:52:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:54:39 <YaKoStar> http://pastebin.com/m597deae6
03:55:22 <YaKoStar> Why do i get error on line 19: tinitten type: int does not match: [String] -> Int ?
03:56:23 <TSC> I think the lines above it are wrong
03:56:30 <TSC> What is "1 + mer" supposed to do?
03:56:52 <TSC> mer has type "[String] -> Int"; you can't add that to 1
03:56:56 <Cale> yeah, that's the problem
03:57:54 <Cale> also, GHCi gives a better error message
03:58:05 <Cale> It says:
03:58:06 <Cale>     Couldn't match expected type `Int'
03:58:06 <Cale>            against inferred type `[String] -> Int'
03:58:06 <Cale>     In the expression: 1 + mer
03:58:35 <jorik808> hello everyone
03:58:42 <Cale> jorik808: hello
03:59:01 <jorik808> hey :) i saw this movie on youtube, where a guy created live music using Haskell
03:59:07 <jorik808> wait lemme dig it up
03:59:20 <Cale> YaKoStar: another problem is in tokenizer, where you're adding word and c, but they're not numbers
03:59:32 <jorik808> http://uk.youtube.com/watch?v=eLS6GHXWMpA
03:59:33 <lambdabot> Title: YouTube - hacking haskell music
04:00:11 <Cale> Yeah, that's Alex McLean
04:00:18 <Cale> http://doc.gold.ac.uk/~ma503am/alex/haskellmusic/
04:00:21 <lambdabot> Title: Alex McLean » Blog Archive » Haskell music
04:00:34 <Cale> er,
04:00:35 <Cale> http://doc.gold.ac.uk/~ma503am/alex/
04:00:37 <lambdabot> Title: Alex McLean
04:01:05 <ac> how do I specify guards for multiple arguments?
04:01:17 <Cale> ac: foo x y z | ...
04:01:28 <jorik808> anyways, i was wondering if anyone here has some experience live programming music
04:01:28 <jorik808> iam currently creating my stuff with Reason, and while i know some programming (mostly lisp) i never knew about livecoding
04:01:34 <Cale> ac: x,y and z will all be in scope in your guards
04:02:27 <jorik808> wooow cool iam gonna contact him
04:02:50 <YaKoStar> argh thanks guys
04:03:04 <YaKoStar> it was suposed to be word ++ [c]
04:03:09 <YaKoStar> not word + c :S stupid me :P
04:03:10 <Cale> YaKoStar: yeah
04:03:35 <Cale> huh, this new ATI graphics driver appears to be buggy
04:03:47 <quicksilver> fancy that! A buggy graphics driver...
04:03:48 <quicksilver> ;)
04:03:57 <Cale> heh
04:04:14 <Cale> and from a company with such a reputation for good linux drivers
04:05:16 <Cale> I'm going back to 8.40.4 and hoping that it's not that my card has just shorted out or something.
04:05:38 <ac> Cale: I see, you don't need to be exhaustive with your guards, and they're evaluated top down, right?
04:05:44 <Cale> ac: right
04:06:10 <Cale> ac: though it's certainly good to be exhaustive in most cases
04:06:44 <ac> Cale: is it possible to pattern match an argument in a guard?
04:06:55 <ac> Cale: nevermind
04:06:58 <ac> I know the answer to that
04:07:08 <quicksilver> yes, it is!
04:07:17 <quicksilver> but its' a ghc extension
04:07:21 <quicksilver> damn useful one, sometimes
04:07:34 <ac> you can just put your pattern match in the arguments, and use those variables in your guards
04:08:00 <Cale> ac: yeah, but sometimes you want to pattern match a function of your argument
04:08:04 <ac> quicksilver: but you're saying there's a syntax extension to match in the guards too?
04:08:09 <Cale> in which case that's not *quite* enough
04:08:13 <Cale> yeah
04:08:25 <Cale> f x y z | Just q <- lookup y z = ...
04:08:38 <scook0> also, you might want to perform a pattern match that only makes sense if an earlier guard fails
04:08:50 <scook0> (though I guess in that case you could add an extra definition line)
04:08:55 <Cale> yeah
04:09:13 <Cale> If none of the guards succeed, it still checks the rest of the pattern matches
04:09:30 <Cale> (which themselves can have more guards to be tried)
04:12:09 <jorik808> just out of curiosity ... sound is "represented" by nothing more than a stream of samples (= number) right?
04:12:21 <Cale> yeah, typically
04:12:43 <ac> couldn't I say "foo x y@(a :+ b) | ...." and use both y, a, and b in guards and body?
04:12:49 <jorik808> im thinking it shouldn't be too much work to write this from scratch
04:12:57 <quicksilver> ac: yes
04:12:58 <Cale> It can also be represented as musical events, like keys on a piano being pressed at certain times and at certain pressures.
04:13:06 <ac> quicksilver: guess my syntax error is something else
04:13:07 <quicksilver> ac: that's easy, because :+ is the only constructor
04:13:19 <quicksilver> ac: pattern guards are useful when there is more than one
04:13:25 <jorik808> yeah but even than, you can convert to samples
04:13:31 <jorik808> you must convert to samples
04:13:54 <Cale> jorik808: unless your soundcard can do it for you, given midi input
04:14:07 <jorik808> ah
04:14:17 <jorik808> true
04:14:22 <Cale> (but yeah, at some point in time, you must convert to samples and eventually to voltages, if you want to hear it :)
04:14:40 <jorik808> http://en.wikipedia.org/wiki/Musicology#Computer.2Finformation_sciences_and_mathematics_of_music
04:14:42 <lambdabot> http://tinyurl.com/2fxdnk
04:15:05 <jorik808> lovely
04:15:12 <Cale> heh
04:15:14 <Cale> brb
04:15:58 <ac> arhg! :set expandtab!!!!111
04:16:51 <vikrant> can anubody help me in installing haskore
04:19:20 <sjanssen> (fmap $ fmap $ fmap $ fmap $ fmap $ SLeft r) (doLayout l) -- potential snippet from xmonad
04:19:34 * Cale switches back to the old fglrx driver, notes that 3D is working properly in mathematica again and hopes not to be seeing that hideous display corruption where little blocks on the screen were in inverted colour any time soon.
04:19:52 <Cale> Use (.) not ($) :)
04:19:58 <scook0> sjanssen: that is hardcore
04:20:10 <mcp_> @hoogle Just a -> a
04:20:11 <lambdabot> No matches, try a more general search
04:20:17 <mcp_> @hoogle Maybe a -> a
04:20:18 <lambdabot> Maybe.fromJust :: Maybe a -> a
04:20:18 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
04:20:18 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
04:20:23 <sjanssen> Cale: I used ($) because I didn't want to accidentally change one into another fmap
04:20:48 <Cale> How could that happen?
04:21:01 <sjanssen> original code: (fmap (second . fmap $ SLeft r) .) . doLayout l
04:21:17 <Cale> (fmap . fmap . fmap . fmap . fmap $ SLeft r)
04:21:25 <Cale> should be exactly the same
04:21:26 <sjanssen> Cale: I was replacing all .'s with fmap for kicks
04:21:38 <Cale> oh, haha
04:22:02 <Cale> That should still work though
04:22:19 <Cale> and then you can repeat the process indefinitely ;)
04:22:57 <scook0> :t fmap `fmap` fmap
04:22:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:23:15 <nornagon> haha
04:23:32 <vikrant> I get follwing error when I try to compile haskore
04:23:33 <Cale> (fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap $ SLeft r)
04:23:37 <vikrant> make: *** No rule to make target `/usr/lib/ghc/4.04/imports/exts/IOExts.hi', needed by `IOExtensions.o'.  Stop.
04:23:45 <nornagon> ye gods! it's full of fmap!
04:24:05 <Cale> vikrant: heh, 4.04?!
04:24:31 <vikrant> I am using ghc 6.6.1!!
04:24:36 <matthew_-> ok, I need some lhs2tex work
04:24:39 <matthew_-> help, rather
04:24:50 <matthew_-> um, I need to put latex commands within a code block
04:24:56 <ivanm> what's a good paper I can use to reference the fact that functional languages like haskell are/should be better for concurrency?
04:24:57 <sjanssen> vikrant: I'd hunt for a more recent distribution if at all possible
04:25:28 <vikrant> but thats the latest one which I got from haskell.org
04:25:31 <ivanm> what's a good paper I can use to reference the fact that functional languages like haskell are/should be better for concurrency?
04:25:50 <ac> quicksilver: still around?
04:25:51 <Cale> vikrant: I think he's talking about Haskore, but I'll try grabbing Haskore and seeing if I can see what's up.
04:25:55 <ivanm> grrr.... thought it didn't get sent, so I sent it again :@
04:26:22 <quicksilver> ac: maybe. Who's asking?
04:26:24 <vikrant> yeah I am talking about haskore.
04:26:47 <ac> quicksilver: me :-P. I improved it by another 20% by writing two uggly loops
04:27:23 <quicksilver> hmm interesting
04:27:47 <vikrant> this file "IOExts.hs" exists in hugs (latest), but not in ghc 6.6.1
04:28:13 <ac> quicksilver: it was by far not worth the masochism
04:28:34 <quicksilver> ;)
04:28:45 <quicksilver> you learn something though..
04:28:56 <ac> actually, it was worth it for me because I learned more Haskell syntax, which was half the reason I did it
04:28:59 <ac> yeah
04:29:19 <quicksilver> you improved another 20% over dcoutts's stream fusion lib?
04:29:24 <ac> quicksilver: yeah
04:29:29 <dcoutts> good good :-)
04:29:42 <quicksilver> hmm
04:29:46 <ac> quicksilver: now it's somewhere around 15x slower than the C version, rather than 60 or so
04:29:50 <quicksilver> dcoutts: doesn't that suggest that something isn't fusing?
04:30:05 <dcoutts> quicksilver: no, just that the result can still be hand-tuned
04:30:10 <quicksilver> and it really shouldn't be 15x slower than C ...
04:30:19 <dcoutts> that's certainly true
04:30:24 <quicksilver> it should be 1x-3x slower I would thin
04:30:28 <Cale> vikrant: openBinaryFile is in System.IO now
04:30:41 <ac> yeah, that's what I'd expect. What the heck am I doing?
04:30:43 <Cale> vikrant: Also, if you see problems with fromInt, replace it with fromIntegral
04:30:47 <dcoutts> is it really using the same algorithm, even at the level of conditionals, control flow etc?
04:31:07 <Cale> vikrant: I'm thinking *someone* must have an updated version of Haskore though
04:31:10 <ac> dcoutts: actually, the c version is using a much much slower test to break out of the loop
04:31:10 <dcoutts> quicksilver, ac: bear in mind that gcc is pretty good with tight loops and ghc is not
04:31:12 <Cale> This is ridiculously old.
04:31:29 <Cale> ah, http://darcs.haskell.org/haskore/
04:31:31 <lambdabot> Title: Index of /haskore
04:31:37 <Cale> this looks far more modern
04:31:42 <vikrant> ok I will try to hunt for new version of haskore
04:31:51 <Cale> I found it
04:31:57 <Cale> darcs get http://darcs.haskell.org/haskore/
04:31:58 <lambdabot> Title: Index of /haskore
04:32:46 <vikrant> thanks , I am trying it out
04:35:59 <swiert> There's also some more recent work about synthesizing music in Haskell...
04:36:10 <swiert> www.cs.nott.ac.uk/~ggg/publications/switched_on_yampa_PADL2008.pdf
04:36:12 <Cale> Oh, it appears to require some dependencies.
04:36:56 <Cale> dependencies which ought to be in Hackage, but aren't.
04:37:05 <quicksilver> dcoutts: yeah, but surely 'pretty good' vs 'not' isn't 15x? I'd hope...
04:37:31 <quicksilver> ac: if you are really intrigued, you should compare the assembly output
04:37:36 <quicksilver> ac: that's the key thing
04:38:24 <ac> quicksilver: I very well might do that another day
04:38:41 <dcoutts> quicksilver: 10x for code gen issues would not be surprising
04:39:05 <ac> quicksilver: the fact is I don't really care about raw performance from ghc, but it would still be interesting
04:39:30 <Cale> but they do appear to be available also from darcs.hackage.org
04:39:32 <dcoutts> quicksilver: a memory filling loop in C can be compiled to 4 x86 instructions, the equivalent via ghc comes out at ~20
04:39:43 <ac> (ok, I admit it, I do care a little ;)
04:39:50 <dcoutts> quicksilver: with two indirect jumps and lots of stack to reg moves
04:40:02 <quicksilver> dcoutts: interesting
04:40:19 <quicksilver> dcoutts: would the better register allocator in pricniple help with that kind of thing?
04:40:34 * quicksilver is a bit vague about details compilation techniques
04:40:39 <Cale> There seem to be a lot of packages which are nicely cabalised sitting on darcs.haskell.org which aren't listed on hackage.
04:40:45 <dcoutts> quicksilver: mainly the CPS transform at the CMM level
04:41:16 <dcoutts> quicksilver: to turn the loop into a real loop rather than a tail recursion that does stuff with the stack
04:41:42 * quicksilver nods
04:41:47 <quicksilver> I thought that part worked, though?
04:41:57 <quicksilver> I thought ghc did produce 'real loops' at least under some circumstances?
04:47:28 <dcoutts> quicksilver: they work in constant space, but they still call via the stack
04:47:43 <ac> when I am at that stage, I think this would be a good little project to learn how to use the FFI
04:48:04 <quicksilver> ac: the FFI is boggling simple
04:48:21 <quicksilver> ac: you just set up a C procedure of type Double -> Double -> IO Int, and call it :)
04:48:29 <quicksilver> or drop the 'IO' if you promise it's pure
04:48:51 <quicksilver> simplest FFI I've ever seen, for simple needs at least
04:49:21 <ac> is there a more complex underlying part?
04:49:41 <scook0> things get trickier if you need to poke around in structs
04:50:00 <quicksilver> it's not so great for structs, no
04:50:07 <quicksilver> but for simple C types, it's fine
04:50:16 <quicksilver> and for structs as opaque pointers, it's fine
04:50:29 <ac> just out of curiosity, is there a Java interface?
04:50:47 <quicksilver> not mainstream, no
04:50:58 <quicksilver> I vaguely remember someone talking about a haskell-jni bridge
04:51:15 <scook0> one thing to be aware of when doing simple FFI, though
04:51:23 <scook0> is to be careful with your C/Haskell types
04:51:59 <quicksilver> ac: it seems that claus reinke worked on some haskell/jni stuff but not for a long time
04:52:48 <scook0> strictly speaking, I believe you're supposed to use (CDouble/double) or (Double/HsDouble), for example
04:53:24 <salierix> xmonad is pretty cool. I'm using it right now.
04:53:52 <quicksilver> ac: and Erik Meijer worked on something call Lambada, but again I don't find anythign recent
04:53:58 <quicksilver> I conclude that java just isn't cool enough any more :P
04:54:30 <swiert> @seen jdagit
04:54:30 <lambdabot> I haven't seen jdagit.
04:54:32 <quicksilver> wow there is also GCJNI
04:54:35 <swiert> @seen dagitj
04:54:35 <lambdabot> I haven't seen dagitj.
04:54:48 <quicksilver> it seems that it's very populr to build java-haskell bridges
04:54:54 <quicksilver> but nobody every actually *uses* them
04:54:57 <quicksilver> so they bitrot
04:55:17 <kowey> swiert: i think you're looking for lispy
04:55:39 <quicksilver> @seen lispy
04:55:39 <lambdabot> lispy is in #xmonad, #haskell-soc, #darcs, ##logic, #ghc, #haskell-blah and #haskell. I don't know when lispy last spoke.
04:56:35 <swiert> kowey: thanks.
04:58:42 <Cale> dcoutts: What do you think of a cabal ticket for adding already cabalised packages from darcs.haskell.org to hackage? (As a "Task"?)
04:59:52 <dcoutts> Cale: that's not really the job of hackage/cabal maintainers, that's the job of maintainers of those packages to get them up to scratch and distribute them properly
05:00:04 <Cale> I suppose that's true.
05:00:08 <dcoutts> Cale: what packages are you thinking of?
05:01:03 <Cale> Well, I've bumped into 'pretty', and a couple others, as well as just noticing that the entire haskore chain of dependencies is cabalised and not in Hackage.
05:01:36 <dcoutts> Cale: ah, pretty etc are new core libs, they'll come with ghc-6.8.1
05:01:56 <hpaste>  (anonymous) annotated "show in binary form" with "not only 2.." at http://hpaste.org/3568#a1
05:01:59 <dcoutts> Cale: it's not obvious they need to be on hackage immediately since you cannot install them with older ghc/base combos
05:02:19 <Cale> ah, right. I remember abandoning that installation process for some reason ;)
05:02:38 <pejo> dcoutts, does that comment mean that more libraries are distributed with ghc, rather than less?
05:03:03 <dcoutts> pejo: no less
05:03:26 <dcoutts> pejo: the base package has been split into several, of which some still have to be distributed with ghc since it requires those to build
05:03:44 <dcoutts> so that's a larger number of packages, but less code
05:04:11 <hpaste>  Cale annotated "show in binary form" with "n-patterns" at http://hpaste.org/3568#a2
05:04:20 <dcoutts> since it's all bits split out of the old base package, and some of those new split packages actually are not core libs and are now distributed separately
05:04:20 <pejo> dcoutts, so more and more of ghc is "upgradable" through cabal?
05:04:25 <dcoutts> right
05:04:54 <dcoutts> pejo: you can upgrade any package except for base itself
05:05:18 <Cale> That's a good thing. I still like the fact that GHC is distributed with lots of useful packages to start with though.
05:05:31 <pejo> Cale, oh, agreed.
05:05:33 <hpaste>  aaim pasted "more pointless ?" at http://hpaste.org/3572
05:05:46 <pejo> dcoutts, that sounds good. :)
05:05:47 <dcoutts> Cale: well, what we need there is just to make it easy to get the other packages you might want
05:06:00 <dcoutts> Cale: which is what cabal-install and hackage are for
05:06:03 <Cale> right :)
05:06:15 <Cale> I've actually really enjoyed cabal-install so far
05:06:25 <dcoutts> Cale: but I agree it'd be useful to have some managed "distro" of stuff that's QA managed
05:06:25 <Cale> It's annoying when things *aren't* on hackage now.
05:06:26 <pejo> dcoutts, didn't you get cabal-install up and running at the hackaton?
05:06:35 <dcoutts> pejo: yep
05:06:45 <dcoutts> it's no hackage now, try it
05:06:49 <dcoutts> no/on
05:07:34 <pejo> Next year, not now - my installation currently works. :-)
05:07:38 <Cale> If it was distributed with GHC, then perhaps there could be a hook to look up a package on hackage and ask if you want it installed when GHC can't find a package :)
05:08:14 <dcoutts> Cale: well if you use cabal-install to build your stuff then it does exactly that
05:08:27 <Cale> Yeah, that's true.
05:08:31 <dcoutts> Cale: cd myproject; cabal install  -- it downloads and installs any missing deps
05:08:53 <sjanssen> dcoutts: is that a new feature?
05:08:54 <quicksilver> although there is the issue about wanting to use OS-provided prackages in preference
05:08:58 <dcoutts> sjanssen: yep
05:09:01 <Cale> Oh, you can cabal install with no parameters right from inside a directory?
05:09:05 <dcoutts> yes
05:09:10 * Lycurgus .oO(I wish they wouldn't cross the streams like that)
05:09:11 <Cale> I've been using cabal-setup for that, but that's much more convenient
05:09:32 <dcoutts> Cale: the plan is to merge cabal-setup and cabal-install
05:09:48 <Cale> Right, there's little point in keeping them separate
05:09:51 <dcoutts> quicksilver: it uses the existing registered global package if it's installed
05:10:00 <quicksilver> dcoutts: *nod*
05:10:05 <dcoutts> Cale: from a UI point, right.
05:10:12 <quicksilver> dcoutts: but if I'm compiling Foo, and that depends on Bar, which I don't have
05:10:17 <dcoutts> Cale: technically it seems to be more tricky.
05:10:20 <quicksilver> dcoutts: I'd rather get Bar as an OS pacakge, if that's possible
05:10:28 <quicksilver> dcoutts: falling back to hackage only if it isn't
05:10:32 <dcoutts> quicksilver: then it does a per-user install of Bar.
05:10:37 <quicksilver> I know
05:10:40 <quicksilver> but I'd rather not :)
05:10:48 <quicksilver> I'd rather do a sys wide install of Bar as OS package if that exists
05:10:57 <quicksilver> but, if it doesn't exist then, as you do now
05:11:03 <dcoutts> quicksilver: sure, but you'd need to be root and we'd need native integration
05:11:08 <Cale> I actually wish cabal-install would try harder to install a package. It seems to ignore a newer version on Hackage when there's an old version on my system. (Unless I specify exactly which version I want)
05:11:19 <dcoutts> quicksilver: both of which I encourage you to send in patches for :-)
05:11:32 <Cale> Of course, if I went to all the trouble of typing the command, I think it should go and get the new version for me. :)
05:11:39 <quicksilver> dcoutts: I don't really know what the right answer is, to be honest
05:11:41 <dcoutts> Cale: that's just a choice.
05:11:44 <quicksilver> (as in the right UI/behaviour)
05:12:00 <Cale> dcoutts: Or at least interactively ask me if I want the new one.
05:12:04 <dcoutts> Cale: I think we have the right default, but I agree we could do with a mode that upgrades deps too.
05:12:14 <dcoutts> Cale: that's what other systems do, eg emerge --deep
05:12:21 <dcoutts> similar for apt
05:12:28 <sjanssen> quicksilver: IMO, it isn't a big problem as long as cabal-install is --user by default
05:12:42 <dcoutts> default to upgrading minim stuff to get the target installed, but with a mode to upgrade maximally
05:12:53 <pejo> dcoutts, I think you have a very sane default. The stuff already installed is well tested.
05:12:59 <Cale> Right, cabal is so much like apt, that I expect it to work the same way.
05:13:11 <dcoutts> Cale: it does as I understand it.
05:13:24 <dcoutts> Cale: apt doesn't upgrade things that do not have to be upgraded.
05:13:44 <Cale> If you apt-get install an installed package, and there's a newer one, it will upgrade it.
05:14:17 <Cale> There's no reason for you to type that command if the version you already had was sufficient.
05:14:38 <Cale> (unless you were confused or something)
05:14:42 <EvilTerran> apt-get moo?
05:14:48 <pejo> Cale, unless the user followed the instructions in the installation manual
05:15:23 <Cale> pejo: without interpreting them? Okay.
05:16:59 <pejo> Cale, well, yeah. It's usually tricky to get back into the previous state, so having tools that hinder you from shooting yourself in the foot unless you really mean it seems like a good idea to me.
05:17:23 <Cale> It's presently okay to have multiple versions of a library installed isn't it?
05:17:49 <sjanssen> Cale: yes, but there can be some trickiness
05:18:01 <Cale> For example, I currently have three versions of Cabal installed on my system and I haven't noticed any problems.
05:18:09 <pejo> Cale, but unless you specify a version eplicitly it takes the most recent one? So installing a package might break compilation of something.
05:18:56 <Cale> pejo: It may also fix the compilation of something else ;)
05:19:28 <Cale> Anyway, just presenting the user with an option to upgrade when running on a tty seems sensible.
05:19:47 <pejo> Cale, oh, agreed. All I'm saying is that the previous broken state is better than a new one, usually. Atleast you knew what you had with the last broken state.
05:20:27 <Cale> I've also noticed that there's not much support for *un*installing packages
05:20:48 <Cale> (unless there is and I don't know where to find it)
05:21:27 <Cale> I can ghc-pkg unregister
05:21:46 <Cale> but I get the impression that's not actually removing the package from my system properly
05:22:14 <Cale> (If it is, then it's doing it rather quickly and silently ;)
05:22:33 <sjanssen> Cale: yes, you're right
05:22:35 <roconnor> http://people.cs.uu.nl/johanj/FPDag2008/
05:22:37 <lambdabot> Title: Functioneel Programmeren dag 2008
05:23:22 <roconnor> oh, it's already listed on Haskell.org
05:32:06 <profmakx> functional programming day. good idea. have to propose that for my uni
05:35:25 <EvilTerran> hm. my programming languages lecturer claimed yesterday that \calc had no O(1) (as it were) way of getting the tail of a list... this seems to be true for the encoding of lists he was using, but it seems to me that there's an (actually simpler) encoding of lists for which there is one
05:36:58 <EvilTerran> his encoding being basically "encode xs as (\f e -> foldr f e xs)"
05:38:27 <EvilTerran> but encoding xs as (\f e -> case xs of [] -> e; hd:tl -> f hd tl) would clearly allow O(1) tail, and indeed anything else at the same complexity as the equivalent haskell, afaict
05:39:00 <EvilTerran> and foldr's still possible, so it's not more restrictive or anything
05:39:39 <EvilTerran> (my encoding would be better stated as "nil encodes as (\f e. e); cons encodes as (\hd tl f e. f hd tl)"
05:39:42 <Syzygy-> Is there an obvious way, given a tree type, to replace each leaf with a subtree from a given list?
05:40:03 <sjanssen> Syzygy-: sounds like >>=
05:40:10 <Syzygy-> sjanssen: How's that?
05:40:10 <quicksilver> Syzygy-: you mean, you have 'N' leaves and an a list of 'N' subtrees?
05:40:20 <Syzygy-> I have one tree with N leaves, and I have a list of N trees.
05:40:20 <quicksilver> >>= puts the same subtree at each leaf
05:40:35 <quicksilver> Syzygy-: that sounds like a Data.Traversable version of zipWith
05:40:41 <quicksilver> Syzygy-: I wonder if one exists...
05:40:57 <EvilTerran> (foldr becomes \cons nil. fix (\f xs. xs (\hd tl. cons hd (f tl)) nil))
05:41:40 <sjanssen> Syzygy-: what is your tree type?
05:41:51 <Syzygy-> sjanssen: data Tree = Leaf | Node [Leaf]
05:42:04 <Syzygy-> Sorry.
05:42:07 <sjanssen> definitely not >>= :)
05:42:12 <Syzygy-> that should be data Tree = Leaf | Node [Tree]
05:42:15 <Syzygy-> of course
05:43:10 <EvilTerran> sounds like you could do something with Data.Generics.Schemes.everywhereM
05:43:12 <sjanssen> sounds like "State [Tree] Tree" now :)
05:43:14 <swiert> Syzygy- so where is the data stored in the tree?
05:43:26 <geocalc> @users
05:43:26 <lambdabot> Maximum users seen in #haskell: 424, currently: 383 (90.3%), active: 20 (5.2%)
05:43:57 <quicksilver> no, it's a traversable zip
05:44:07 <quicksilver> you could implement it using 'traverse'
05:44:17 <sjanssen> quicksilver: Tree isn't the right kind
05:44:18 <quicksilver> over an applicative which stored the second list (being unwound)
05:44:35 <quicksilver> sjanssen: well I assume he means Tree a = Leaf a | Node [Tree a]
05:44:53 <Syzygy-> quicksilver: Actually, no.
05:44:58 <quicksilver> sjanssen: if note, then call it Tree () and it's isomorphic but now the right kind :)
05:44:58 <Syzygy-> I don't want my tree to carry stuff.
05:45:17 <quicksilver> then use Tree () :)
05:45:17 <Syzygy-> Ah.
05:46:15 <quicksilver> the "point" of traversable is to enable you to traverse something linearly
05:46:23 <quicksilver> but keep the structure exactly as it was
05:46:24 <geocalc> why a tree to carry nothing ?
05:46:37 <Syzygy-> geocalc: Because I want to do computation in the operad As_\infty
05:46:55 <Syzygy-> Which consists of planar trees, with composition being grafting of trees onto leaves.
05:47:09 <quicksilver> what 'traverse' does is go through the tree doing 'something' at each node
05:47:17 <quicksilver> hmm you'd need to flatten it after
05:47:24 <quicksilver> so actually you *would* be using the full monad instance
05:48:16 <swiert> Syzygy- sounds a lot like what you really want to do is use the Tree a version and use bind to perform the substitution.
05:48:25 <geocalc> mmh is it not better with a shape Syzygy- ?
05:48:42 <quicksilver> swiert: it's not trivial to use bind in a way which carries along the 'right' subtree to each leaf
05:48:47 <quicksilver> swiert: at least, I don't think it is
05:48:57 <Syzygy-> What I would want to end up with in the end is something like graft (Node [Leaf, Leaf]) [Node [Leaf, Leaf], Leaf] --> Node [Node [Leaf, Leaf], Leaf]
05:49:11 <quicksilver> swiert: I think it's more like <$> in a custom Applicative
05:49:14 <Syzygy-> geocalc: shape?
05:49:22 <EvilTerran> what's the {-#LANGUAGE#-} for SYB?
05:49:27 <quicksilver> swiert: an applicative which is "like" ZipList but with Trees...
05:49:34 <geocalc> object 3d
05:49:43 <quicksilver> EvilTerran: SYB is pure haskell now
05:49:58 <quicksilver> EvilTerran: I'm not sure the old version still runs?
05:50:00 <EvilTerran> and for those of us using 6.6.1?
05:50:09 <quicksilver> SYB is pure haskell since for a long time :)
05:50:18 <swiert> quicksilver: I see your point. But monads were originally designed specifically to model terms and substitution.
05:50:24 <EvilTerran> okay then, why doesn't my "deriving Typeable" work?
05:50:40 <quicksilver> EvilTerran: I don't know. What is the error message?
05:50:50 <EvilTerran> "You need -fglasgow-exts to derive an instance for this class"
05:50:55 <quicksilver> heh
05:50:59 <EvilTerran> -fglasgow-exts is a bit of a sledgehammer
05:51:04 <swiert> quicksilver: I'd always go for the "Tree a" version.
05:51:22 <EvilTerran> so i was hoping for something a little more subtle, namely a (rather more specific) LANGUAGE pragma
05:51:41 <quicksilver> swiert: yes, so would I...
05:51:48 <quicksilver> EvilTerran: I'm not sure there is one
05:51:54 <hpaste>  sjanssen pasted "treeverse" at http://hpaste.org/3573
05:52:02 <quicksilver> EvilTerran: there are quite a few things 6.6 doesn't have a LANGUAGE pragme for
05:53:19 <Syzygy-> sjanssen: That does what I expect it to.
05:53:22 <sjanssen> in fact, most LANGUAGE pragmas activate -fglasgow-exts in 6.6
05:53:26 <Syzygy-> Next exciting project - understanding that code...
05:53:40 <quicksilver> hmm evilterran left
05:53:51 <quicksilver> I think it might be {- # LANGUAGE Generics -}
05:54:40 <EvilTerran> sorry, you were saying?
05:55:34 <quicksilver> EvilTerran: LANGUAGE Generics, perhaps?
05:55:42 <quicksilver> EvilTerran: the LANGUAGE pragmas are undocumented
05:55:45 <quicksilver> but tehre is a list here
05:55:46 <EvilTerran> I tried that. you'd think it'd work, but it doesn't
05:55:51 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
05:55:53 <lambdabot> http://tinyurl.com/2xjyqs
05:56:35 <quicksilver> sjanssen: I was trying to factor it into the applicative/traversable framework
05:56:48 <quicksilver> sjanssen: I'm sure it's a traversable thing somehow
05:56:51 <quicksilver> but I gave up :)
05:57:18 <sjanssen> I think you want both Traversable and Monad
05:57:41 <quicksilver> there is a traversable mapM
05:57:56 <quicksilver> @hoogle Data.Traversable.mapM
05:57:57 <lambdabot> No matches, try a more general search
05:58:02 <quicksilver> @type Data.Traversable.mapM
05:58:04 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:58:15 <sjanssen> quicksilver: you also need join
05:58:20 <quicksilver> yes
05:58:33 <quicksilver> because you would instantiate t = m
05:58:40 <quicksilver> and end up with m (m b)
05:58:41 <quicksilver> right ?
05:58:46 <sjanssen> right
05:59:19 <sjanssen> erm, maybe not
05:59:36 <quicksilver> hmm
05:59:40 <quicksilver> no, you woudln't
05:59:44 <quicksilver> m woudl be the state monad
05:59:46 <quicksilver> just like you showed
05:59:54 <quicksilver> but that wasn't what I really wanted :)
06:00:19 <sjanssen> the first argument to mapM would be (() -> m (Tree ())
06:00:30 <sjanssen> where m = State [Tree], most likely
06:00:33 <quicksilver> I wanted zipTraverse :: (Traversable t, Traversable t2) => (a -> b -> c) -> t a -> t2 b -> t c
06:00:46 <geocalc> haddock doc are cryptic better to look the sources
06:00:50 <quicksilver> which co-traverses two different traversables
06:01:08 <quicksilver> then I'd instantiate with t = Tree but t2 = []
06:01:17 <sjanssen> making the result (m (Tree (Tree ())))
06:01:22 <sjanssen> fmap join
06:01:27 <quicksilver> right
06:01:32 <quicksilver> or join after doing evalState
06:02:05 <quicksilver> I dont' think it's obvious that you can write zipTraverse
06:02:09 <quicksilver> although it seems like a sensible thing to try
06:02:26 <quicksilver> obviously the choice to "end up in" t instead of t2 is pretty arbitrary
06:02:41 <sjanssen> quicksilver: it's easy to write t a -> [a]
06:02:48 <quicksilver> yes, that
06:02:52 <quicksilver> s true
06:03:00 <quicksilver> Data.Traversable.toList, it's called :)
06:03:09 <quicksilver> then I could do a state monad
06:03:14 <quicksilver> and wrap it all up
06:03:16 <quicksilver> just like your code does
06:03:20 <quicksilver> seems surprisingly hard :)
06:04:00 <hpaste>  wouter pasted "treeverse2" at http://hpaste.org/3574
06:04:06 <quicksilver> hmm no, it's Foldable.toList
06:04:12 <quicksilver> not Traversable.toList
06:04:47 <swiert> quicksilver: that's how I'd do it - though I'd rather have dependent types :)
06:05:31 <EvilTerran> ?index cast
06:05:31 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
06:05:45 <quicksilver> interesting
06:06:59 <quicksilver> sjanssen: we're actually using StateT as an applicative, not as a monad, right?
06:07:05 <quicksilver> sjanssen: results don't get threaded
06:07:20 <sjanssen> quicksilver: I think so
06:07:22 <swiert> this program is also guaranteed to be "well-scoped" - the list you pass as an argument has to be long enough.
06:07:29 <sjanssen> treeverse could have an applicative type, anyway
06:07:30 <quicksilver> so that's excatly the use case of traverse
06:07:32 * quicksilver nods
06:08:46 <quicksilver> interestingly, I recognise a lot of these common structures but I never actually *use* them by name
06:08:56 <quicksilver> so I think "that's a reader monad", "that's a traversable"
06:09:06 <quicksilver> but I always end up hand-coding the combinators I need
06:09:18 <quicksilver> somehow the general abstractions don't see worth the extra typing
06:09:20 <quicksilver> I wonder why not
06:14:39 <roconnor> @quote booklet
06:14:39 <lambdabot> No quotes match. Take a stress pill and think things over.
06:14:50 <quicksilver> EvilTerran: < Igloo> DeriveDataTypeable in 6.8
06:14:57 <quicksilver> EvilTerran: (nothing in 6.6, though)
06:22:47 <shapr> Good morning #haskell!
06:22:54 <shapr> @quote
06:22:54 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
06:22:59 <shapr> @quote haskell
06:23:00 <lambdabot> Tac-Tics says: Haskell is 50% style and 60% research... and -10% code bloat
06:23:18 <quicksilver> Good morning @shapr
06:24:27 <shapr> yow!
06:25:23 <quicksilver> you know those old games like scorched earth where you chip away at a 2D landscape
06:25:30 <shapr> yeah?
06:25:31 <MyCatSchemes> Like... scorched earth.
06:25:38 <MyCatSchemes> And clones of Scorched Earth, mainly.
06:25:43 <quicksilver> I was thinking it might be fun to use haskell to simulate a 2D landscape which actuall obeyed gravity
06:25:46 <MyCatSchemes> Artillery games, anyway.
06:25:53 <quicksilver> so outcrops of rock would stay up for a while
06:26:01 <quicksilver> but if they got too thin/too heavy
06:26:03 <Zao> Oh lovely. Happy requires Happy to build.
06:26:07 <quicksilver> they would crack and fall
06:26:20 <MyCatSchemes> quicksilver: jinkies, that sounds painfully difficult or slow, depending on which way you lean it.
06:26:26 <MyCatSchemes> quicksilver: however, awesome.
06:26:28 <quicksilver> well modern machines are nice and fast
06:26:35 <dcoutts> Zao: get the fixed tarball from hackage
06:26:36 <quicksilver> I think ti's much the same as surface tension
06:26:50 <quicksilver> and people certainly model surface tension in particle systems
06:27:02 <quicksilver> (ball-and-spring physics between a few 1000s of independent mud clots)
06:27:05 <ricky_clarkson> I read a lovely piece about how self-hosting software can keep bugs/viruses between builds that aren't in the source code.
06:27:20 <quicksilver> yeah
06:27:49 <quicksilver> all binary copies of gcc contain a trojan which enables RMS to control your PC remotely. And they build this into every executable they produce.
06:27:53 <quicksilver> ;)
06:27:59 <sieni> ricky_clarkson: reflections on trusting trust?
06:28:09 <ricky_clarkson> sieni: I think so, yes.
06:28:20 <sieni> ricky_clarkson: it's a classic
06:29:49 <Zao> dcoutts: Great, thanks.
06:30:18 <ricky_clarkson> So perhaps if you look at the binary for happs you'll find a copy of Rails.
06:30:45 <shapr> I'd be surprised.
06:32:17 <wli> Doesn't gcc restrict the subset of C it's written in so it can be built by other compilers?
06:32:25 <quicksilver> MyCatSchemes: actually there are two types, IIRC. In 'worms' earth never slides down. you can make arbitrraily big hole below a point.
06:32:31 <MyCatSchemes> quicksilver: yeah, but Scorched Earth tracked each pixel of dirt as a seperate particle. Scale that up to a 1280x1024 or a 1600x1200 battlefield and you have a problem.
06:32:49 <quicksilver> MyCatSchemes: in scorched earth, each pixel always falls vertically
06:32:55 <quicksilver> MyCatSchemes: so you can never have any holes
06:32:57 <MyCatSchemes> quicksilver: yeah, but worms isn't anywhere near as cool as SE.
06:32:59 * MyCatSchemes nods.
06:33:23 <quicksilver> you woudln't need one pixel per particle, though
06:33:24 <MyCatSchemes> Perhaps it makes collision detection easier? I can certainly think of really easy ways to do that.
06:33:34 <quicksilver> I think that 50,000 particles might get you quite a long way
06:33:40 <quicksilver> and simulating 50,000 particles isn't too hard
06:34:15 <quicksilver> my not-remotely-optimised 3D particle engine does 120k particles per second on this machine
06:34:21 <MyCatSchemes> > 1600.0 * 1200.0 / 50000.0
06:34:23 <lambdabot>  38.4
06:34:53 <quicksilver> (and this is a simpler job than a full 3D model, in some ways. Less data, at least)
06:35:31 <MyCatSchemes> One particle per fourty pixels doesn't sound atrocious, but you'd still have fairly *big* clumps of earth. Roundabout nine pixels diameter, I think.
06:35:56 <quicksilver> that's your fault for running at 1600x1200 in my opinion :)
06:36:09 <MyCatSchemes> > sqrt (40 / 3.14)
06:36:11 <quicksilver> I'd be quite happy targetting a smaller resolution that that
06:36:11 <lambdabot>  3.569153051241248
06:36:20 <MyCatSchemes> Wait, that's the wrong wawy around, isn't it?
06:36:28 <MyCatSchemes> > (sqrt 40)/3.14
06:36:30 <lambdabot>  2.0141895924639357
06:36:41 <quicksilver> I think you had it right the first time
06:37:01 <MyCatSchemes> > 3.56 * 3.56 * 3.14
06:37:02 <lambdabot>  39.795104
06:37:11 <dcoutts> MyCatSchemes: quicksilver: though presumably you can assume that most particles do not change in most interactions, just the ones in the vicinity of some event/explosion
06:37:31 <MyCatSchemes> Oh, right, yeah, eight pixels diameter. The 3.56 we get there would be the radius.
06:38:16 * MyCatSchemes thought his brain had stopped working. Thankfully, that's impossible, since it hasn't started working anyway.
06:38:40 <quicksilver> dcoutts: yes, something like that
06:38:52 <wli> Event queues blah blah blah.
06:38:58 <quicksilver> MyCatSchemes: I think that you then interpolate between particles
06:39:17 <quicksilver> MyCatSchemes: to get smooth-looking "mud" despite there being, on average, 40 pixels per particle
06:39:38 <quicksilver> MyCatSchemes: you could even use different colours when they are closer together, which would be a indicator of stress :)
06:39:45 <quicksilver> so you could make arches and prove how they work!
06:40:02 <quicksilver> I've seen some very impressive water demos
06:40:08 <quicksilver> where they interpolate between rather large particles
06:40:15 <MyCatSchemes> quicksilver: oooh, now that sounds sexy.
06:40:35 <MyCatSchemes> quicksilver: ever seen Pontifex?
06:40:50 <quicksilver> http://runevision.com/3d/include/particles/
06:40:52 <lambdabot> Title: rune|vision - Rune's Particle System&nbsp;&nbsp;&nbsp;
06:40:56 <quicksilver> (Flow demo scene)
06:41:01 <quicksilver> is the one I was thinking of
06:42:08 <quicksilver> MyCatSchemes: no, although I've heard of it.
06:42:10 <quicksilver> MyCatSchemes: ENOWINDOWS :P
06:42:19 <matthew_-> that's not E
06:42:24 <wli> To me as well.
06:42:30 <MyCatSchemes> Nice, pretty. But no interaction between particles, so that isn't really in the right ballpark for CPU time cost.
06:42:38 <wli> Hair would be very interesting.
06:42:46 <MyCatSchemes> quicksilver: NOWINDOWS isn't an E-code, but ENOWINE is.
06:42:50 <quicksilver> I'm amused that 'Pontifex' the game is the first google hit for 'Pontifex'
06:42:54 <quicksilver> higher than the pope
06:43:01 <MyCatSchemes> quicksilver: Pontifex works fine in wine, for me.
06:43:05 <quicksilver> I wonder if Benedict is similarly amused :)
06:43:10 <MyCatSchemes> Hahahah.
06:43:18 <MyCatSchemes> I know which one I'd rather play with. XD
06:43:35 <quicksilver> I've never had the remotest incentive to install WINE
06:43:36 <wli> I have a tough time thinking of the Pope as net-savvy.
06:43:43 <quicksilver> well, today you have given me a remote incentive, I agree
06:43:51 <quicksilver> but it's unlikely to push me over the edge :)
06:44:05 <MyCatSchemes> quicksilver: never had the urge to play, say, Day of Defeat?
06:44:14 <quicksilver> no, not really
06:44:21 <quicksilver> I have a PS2 to play games on, although I seldom do
06:44:40 <wli> Same here.
06:44:40 <quicksilver> the games I've spent more time playing that anything else run on all operating systems anyway :)
06:44:47 <quicksilver> e.g. angband, ToME
06:45:02 <quicksilver> these days, when I have spare time, I hack rather than playing, as a rule
06:46:34 <MyCatSchemes> quicksilver: hrmn. Does Nethack run on VAXen these days, I wonder?
06:46:37 <matthew_-> quicksilver: yeah, I used to invest hundreds of hours into bzflag. But these days I prefer writing games in Haskell
06:46:54 <atom> @src Mul
06:46:54 <lambdabot> Source not found. That's something I cannot allow to happen.
06:49:19 <araujo> matthew-_, any interesting one? :-)
06:49:34 <quicksilver> Oh, I have a PSP too. Crush is pretty cool.
06:49:43 <quicksilver> But only if I don't get a seat on the train. Haskell is cooler.
06:55:22 <nominolo> hm.  what are "orphaned instances" ?
06:55:49 <sioraiocht> they have no type classes to take care of them
06:55:56 <sioraiocht> (I have no idea)
06:56:04 <ToRA> class instance decls in modules that define neither the data type having the instance made for it, or the class being instantiated
06:56:23 <quicksilver> http://www.nabble.com/Orphan-Instances-with-GHC-6.8-t4640451.html
06:56:24 <quicksilver> ?
06:56:24 <lambdabot> Title: Nabble - Haskell - Glasgow-haskell-users - Orphan Instances with GHC 6.8
06:56:25 <nominolo> ah, i see
06:56:26 <sioraiocht> aha, so I was right
06:56:31 <ToRA> i think it's both
06:56:42 <nominolo> ToRA: yes, that explains it
06:56:52 <sioraiocht> when is ghc 6.8 being released, anyway?
06:57:34 <quicksilver> in the next week or so, hopefully
06:57:40 <quicksilver> I believe there is a 6.8.1 "candidate"
06:57:47 <ToRA> i get them a lot when defining things like read and show or binary for gl vector classes
06:57:47 <ToRA> :(
06:58:26 <nominolo> you could put them all into a module Foo.Bar.Instances
06:58:59 <sioraiocht> quicksilver: will it play nicely with leopard?
06:59:07 <sioraiocht> hrm..would be nice if GNUreadline placed nicely with leopard..
06:59:43 <sioraiocht> *played
07:01:33 <fasta> -O3 by definition applies at least the same optimizations as -O2 in GHC, right?
07:02:08 <sieni> @src nub
07:02:08 <lambdabot> nub = nubBy (==)
07:02:13 <sieni> @src nubBy
07:02:13 <lambdabot> nubBy eq []             =  []
07:02:14 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:02:19 <Saizan> was the bug that made -O3 ~= -Onot fixed?
07:03:48 <fasta> Saizan: bug number?
07:04:12 <Saizan> i don't know..
07:05:45 <atom> @paste
07:05:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:06:40 <hpaste>  atom pasted "problem with operator overloading/defining operations" at http://hpaste.org/3575
07:07:01 <atom> anyone want to take a look and tell me what I'm doing wrong?
07:08:38 <Cale> atom: what's the problem?
07:08:54 <Cale> let me try it
07:09:02 <atom> Cale: well, first I've tried using normal * and + operatos
07:09:22 <atom> Cale: then I always got some collisions with Prelude, so I dropped that and said I'll figure that out later
07:09:43 <atom> Cale: but now I'm getting some type problems again...
07:10:01 <Cale> It seems to work for me
07:10:04 <pharm> atom: ghci gives no errors with -fglasgow-exts, but complains about multi-parameter typeclasses otherwise...
07:10:06 <Cale> *Main> (Die 3 6) +++ (5 :: Int)
07:10:06 <Cale> [3d6]+5
07:10:23 <allbery_b> I'd guess you didn't instance Num
07:10:33 <atom> allbery_b: no, I tried to avoid that...
07:10:42 <allbery_b> then you can't reuse (+) and (*)
07:11:02 <atom> num has a bit restrictive policies on different types being used at the same time
07:11:22 <atom> Cale: I want to be able to do something like this:
07:11:23 <Cale> Right, so you need to invent your own operators for that
07:11:38 <atom> Cale: 1`d`6 +++ 5
07:12:03 <Cale> you can, so long as you specify that 5 is an Int
07:12:19 <Cale> because otherwise, it has no idea that you want to apply that particular instance
07:12:36 <atom> Cale: still says error
07:12:42 <Cale> *Main> 3`d`6 +++ (5 :: Int)
07:12:42 <Cale> [3d6]+5
07:12:47 <Cale> not for me
07:12:52 <pharm> WFM too.
07:13:09 <pharm> *Main>  3`d`6 +++ (5 :: Int)
07:13:09 <pharm> [3d6]+5
07:13:09 <atom> Cale: ok, so I need to put that 5 in parens. forgot that. any way I can avoid that?
07:13:26 <Cale> atom: It won't be necessary in actual code
07:13:35 <pharm> atom: no, function application binds tighter (IIRC)
07:13:48 <atom> so just in the interpreter?
07:13:58 <atom> because it dumps without the parens
07:13:58 <Cale> well, type decls always apply to the largest possible thing which they could
07:14:03 <atom> oh.
07:14:28 <atom> and, let me guess, I can't use ++ either
07:14:31 <Cale> It won't be a problem in actual code, because you'll have some other code which will help it to know that the thing you're passing is an Int
07:14:37 <atom> because it's a string concat operator?
07:14:40 <Cale> right
07:14:49 <Cale> unless you want to import Prelude hiding (++)
07:16:02 <atom> Cale: but... and I don't want a "just because" answer... Why can't you overload the already used operators in other classes as well, as long as your types don't inherit from both?
07:16:23 <Cale> types inherit?
07:16:37 <atom> Cale: sorry, "are instances of"
07:16:54 <Cale> because then what's the type of (+)?
07:17:03 <Cale> Okay, suppose you have:
07:17:06 <atom> Cale: well, it depends on the types of parameters
07:17:08 <Cale> class C a where
07:17:18 <Cale>    f :: a -> Int
07:17:20 <Cale> and
07:17:24 <Cale> class D a where
07:17:29 <Cale>    f :: a -> Bool
07:17:36 <Cale> now what's the type of f?
07:18:02 <atom> well, if you give it a D parameter, then Bool. if a C parameter, then Int
07:18:19 <Cale> and there's no way to say that some type isn't in both
07:18:37 <atom> Cale: then make a ruckus if it is, not just forbid it outright
07:19:08 <atom> in most cases, the types wouldn't clash anyway
07:19:15 <Cale> This also makes type inference next to impossible.
07:19:21 <geocalc> | |
07:19:54 <Cale> Because if you don't know the type of the parameter of f, its result could be Bool or Int
07:20:04 <Cale> but then that can trigger another class decision
07:20:09 <Cale> and so on and so forth
07:20:18 <pharm> Cale: betcha you could come up with a function in this setup which had an infinite number of possible distinct types
07:20:27 <Cale> probably
07:20:33 <titusg> does anyone have any pointers on converting logical sentences into disjunctive normal form, or an example of an algorithm?
07:20:57 <atom> I sometimes miss C++'s strict type system...
07:21:08 <pharm> bye bye decidable types...although ghc ditches that anyway.
07:21:11 <Cale> How is this any worse?
07:21:21 <Cale> In C++, you have to declare all of your types.
07:21:38 <Cale> You're complaining about having to declare the type of just one expression :)
07:21:58 <atom> Cale: at least there, you CAN (and, well, must) declare them on a case-by-case basis. Here, you can't even do that
07:22:00 <mrd> he's also wishing for "C++'s strict type system"
07:22:04 <mrd> hilarious
07:22:23 <atom> mrd: ok, just stop.
07:22:31 <mrd> what do you mean "you can't do that?"
07:22:41 <Cale> You can declare things on a case-by-case basis.
07:22:53 <Cale> Look what you're doing with (+++)
07:23:01 <atom> Cale: yeah, but I can't reuse +
07:23:03 <Cale> the problem is that (+) is just already taken
07:23:17 <atom> Cale: well, in C++ I would have been able to reuse +. THat's my whole point.
07:23:25 <Cale> If you don't want the Prelude's (+), you can shadow it and not import it from the prelude.
07:23:25 <atom> Cale: the long and short of it, actually.
07:23:29 <mrd> haskell isn't like C++
07:23:33 <geocalc> +'
07:23:34 <atom> Cale: I do want it for normal types
07:23:47 <wli> He means ad hoc overloading.
07:24:04 <mrd> (+) is a method of Num.  if you have something you want to be a Num, you implement it for Num
07:24:09 <Cale> atom: There's nothing that says some future module won't come along and declare an instance of Num for Die
07:24:21 <geocalc> so use parsec
07:24:23 <mrd> wli: type classes are ad-hoc technically
07:24:25 <atom> wli: thanks
07:24:31 <Cale> mrd: Not really.
07:24:41 <sjanssen> type classes are principled ad-hoc
07:24:53 <Cale> They solve the same problem as ad-hoc overloading, but they aren't.
07:25:15 <Cale> A better name would be bounded parametric polymorphism.
07:25:44 <Cale> They serve to restrict the types over which type variables range.
07:26:13 <Cale> In ad-hoc overloading systems, you generally can't write polymorphic functions just by using ad-hoc polymorphic functions.
07:26:25 <Cale> Which you can do with typeclasses.
07:26:25 <sjanssen> @google "How to make ad-hoc polymorphism less ad hoc"
07:26:28 <lambdabot> http://citeseer.ist.psu.edu/85097.html
07:26:28 <lambdabot> Title: How to Make Ad-Hoc Polymorphism Less Ad Hoc - Wadler, Blott (ResearchIndex)
07:26:33 <Cale> sort :: (Ord a) => [a] -> [a]
07:26:48 <Cale> and you get it by using (<) which is a member of Ord
07:27:03 <Cale> You don't have to build sort into the Ord class, or define it specially for each type
07:27:09 <mrd> restricting universal quantification is going to increase the number of functions, naturally
07:27:20 <Cale> right
07:28:02 <mrd> i still consider it ad-hoc because you can define the operations any way you want
07:28:07 <atom> Cale: I was just reading about functional dependencies, and from what I've seen, they solve the problem completely. In the paper (and you've probably all seen it), this is used to implement linear algebra library pieces - vectors and matrices
07:28:07 <sjanssen> atom: note that the next version of C++ is adopting a feature based on Haskell's class overloading
07:28:11 <mrd> if there were proof obligations to discharge, then it wouldn't be
07:28:15 <ski> s/bounded/constrained/, no ?
07:28:51 <Cale> The point where I draw the line between ad-hoc overloading and what typeclasses do is that in ad-hoc overloading, the code which is used is determined *exactly* at the call site, from the concrete types of the parameters passed to the given function.
07:28:53 <atom> sjanssen: yeah, but "ad hoc overloading" isn't going away.
07:29:07 <ski> `bounded parametric polymorphism' sounds like sub- or super-typing bound on the type variables .. which we don't really have here, right ?
07:29:37 <wli> Wrong ordering on types.
07:29:43 <ski> mrd : types are partial proof obligations, no ?
07:29:46 <wli> It's the more vs. less instantiated.
07:29:53 <Cale> ski: You're bounding the set of types over which the universal quantifiers range
07:30:01 <atom> Cale: and there they implement the * and + operators on Vector and Matrix types without subclassing Num
07:30:10 <doserj> "instance Num GLFloat where ..." is pretty much ad-hoc, isn't it?
07:30:13 <atom> Cale: now I don't know if they assumed the Prelude wasn't around...
07:30:15 <ski> Cale : hm .. that could work, i suppose
07:30:17 <Cale> ski: To lie within a particular class.
07:30:45 <Cale> atom: they probably just didn't import the Prelude.
07:30:58 <Cale> atom: or used different names
07:31:03 <mrd> ski: partial :)
07:31:13 <Cale> doserj: not quite, no
07:31:20 <atom> Cale: how can you get the + operator for ordinary numbers without importing the prelude?
07:31:41 <Cale> atom: Well, by importing the Prelude qualified
07:31:47 <Cale> So you can write P.+
07:31:52 <ski> mrd : so by proof obligation, you mean no less than a full specification of the functional relation between the inputs and outputs of the function ?
07:31:55 <sjanssen> > 2 Prelude.+ 3
07:31:56 <Cale> To mean the Prelude's +
07:31:58 <lambdabot>  5
07:31:58 <mrd> or import Prelude(+) perhaps
07:32:15 <mrd> ski: as you might do in Coq
07:32:56 <wli> Eiffel had a brilliant idea here.
07:32:57 <ski> mrd : *nod* .. i was only inquiring about the "full" part
07:32:58 <atom> Cale: it would actually be nice to redefine the prelude's num class in terms of different classes: Mult, Add, Neg...
07:33:07 <atom> then you can opt-in on individual operators.
07:33:14 <wli> Write down your proof obligations in a syntactically-checked/etc. way.
07:33:45 <wli> Dynamic checks for them being true get generated when you turn on certain compiler flags.
07:33:55 <atom> instead of having to instance the whole Num monstrosity and cheat on (-) = undefined stuff.
07:34:06 <Cale> With ad-hoc overloading (in my worldview), if you have two definitions for f, which have the types  f :: Int -> String and  f :: Bool -> String, then which code is used for f is determined only by the type of the parameter at the call site, and you can't write polymorphic functions which pass a polymorphic parameter to f
07:34:19 <pjd> atom: cue John Meacham's class alias proposal
07:34:36 <Cale> atom: yeah, but I'd still want them to have the same type of parameters and result
07:34:43 <fasta> pjd: can't you already trivially fake them?
07:35:03 <ski> Cale : s/type of the parameter/type of the parameter and result/ for Ada
07:35:16 <Cale> atom: scalar multiplication is a completely different operation, and it deserves a different name
07:35:23 <Cale> ski: sure
07:35:30 <sjanssen> atom: then you get ridiculous typesignatures like f :: (Addable a, Subtractable a, Negatable) => a -> a
07:35:30 <pjd> fasta: fake them?
07:35:33 <Cale> ski: but the point is that it's local
07:35:39 <ski> *nod*
07:35:50 <ski> (and not deferrable)
07:35:52 <pjd> sjanssen: cue John Meacham's class alias proposal :)
07:35:59 <Cale> Polymorphism of ad-hoc overloaded functions doesn't propagate
07:36:13 <atom> Cale: but it's got the same operator (actually, just written in the same way) in mathematics, and if it can be well-defined for mathematics, it's probably well defined enough for a programming lanugage
07:36:19 <Cale> which is the fundamental aspect of typeclasses, that they propagate their polymorphism to their callers
07:36:20 <pjd> (http://repetae.net/john/recent/out/classalias.html)
07:36:21 <lambdabot> Title: Class Alias Proposal for Haskell
07:36:37 <atom> pjd: thanks
07:36:47 <mrd> mathematicians abuse notation all the time
07:36:51 <Cale> atom: It's really not, because machines are kind of dumb.
07:36:56 <mrd> not necessarily something you want to copy in a PL
07:36:59 <integral> atom: it's not the same operator in mathematics.  It's just that mathematicians have a very, very complicated context-sensitive grammar inside them
07:37:19 <ski> (also <http://repetae.net/john/recent/out/supertyping.html> is relevant here, i think)
07:37:24 <Cale> It's not really an abuse of notation in mathematics, because mathematicians are smart, and there's usually enough context to tell.
07:37:30 <atom> integral: see, I wrote that it's not the same operator, it's just written in the same way
07:37:35 <Cale> (if there isn't people yell at one another and sort it out)
07:37:57 <integral> atom: but it's not, they're in different contexts
07:38:05 * mrd keeps a pocket mathematician around to take out an yell at
07:38:19 <Cale> In a programming language, you talk to the compiler, and if it can't figure it out, you end up telling it the whole story over again, but modified so as to be correct.
07:38:22 <atom> Cale: yup... It's just that in C++ I've never, ever had a problem like this. This is probably only because I'm a total n00b when it comes to haskell, but...
07:38:31 <Cale> atom: Don't sweat it.
07:38:39 <ski> C++ doesn't support type-inference
07:38:39 <Cale> atom: Just use another operator symbol.
07:38:51 <Cale> There are infinitely many to choose from
07:39:08 <integral> atom: C++ and haskell sort of have opposite limitations when it comes to operators: in haskell you can only give an operator a single type, but you can invent new operators.  In C++, you can overload operators, but never, ever define new ones
07:39:14 * atom cries out but it's not so beautiful and sheds some tears
07:39:15 <sjanssen> atom: C++ let's you overload + as much as you'd like, but it can't represent the type signature "Num a => a -> a" in a principled way
07:39:22 <ski> (it would be nice to be able to locally open modules in a subscope in haskell ..)
07:39:37 <sjanssen> atom: it's a trade-off
07:39:46 <Cale> atom: You can even define  plus x y and use  Die 3 6 `plus` 5
07:39:47 <fasta> pjd: instance (Zork b, Baz b) => Foo b where method = Zork.method etc and this can be automated with Template Haskell?
07:39:48 <atom> sjanssen: it's what I'm learning the hard way :)
07:39:53 <integral> you can't reopen classes in C++, which annoys me
07:40:08 <atom> integral: it's the exact thing I hate about ruby :)
07:40:09 <Cale> Polymorphism in C++ doesn't propagate, which annoys me.
07:40:16 <atom> integral: you CAN reopen classes :)
07:40:31 <fasta> ski: PLT Scheme has that, IIRC, but I have never seen a use for it.
07:40:31 <integral> atom: oh.
07:40:36 <sjanssen> fasta: overlapping instances and TH are much larger proposals than the class alias proposal
07:40:49 <integral> atom: can you add new interfaces to them?
07:41:01 <sjanssen> fasta: and there comes a point when faking it isn't good enough
07:41:08 <atom> integral: I mean, the thing I hate about ruby is that you can extend classes on the spot.
07:41:30 <fasta> sjanssen: I'd rather see Template Haskell being implemented such that it becomes a joy to use.
07:41:43 <atom> integral: and the thing I like in C++ is that you define a class in one place and it's final
07:41:50 <pjd> atom: i think it's not so much that ruby allows it (most/all dynamic languages do), but that it encourages it
07:42:01 <atom> pjd: that too
07:42:17 <atom> integral: bye bye type-safety
07:42:20 <ricky_clarkson> I don't get how the ability to do something is a bad thing.
07:42:21 <integral> atom: well, I prefer Java there over C++ as it has it all in one file and compiles it to an interface definition, instead of the programmer having to split things up
07:42:27 <integral> atom: o_O
07:42:43 * integral thought ruby was perfectly type-safe;  just dynamic and whatnot
07:43:06 <atom> integral: I mean, you have no guarantee that a function is defined on a particular object at compile time
07:43:12 <atom> you have to run the program to find out
07:43:18 <Cale> integral: It's type safe if crashing at runtime over a type error is type safe.
07:43:27 <ricky_clarkson> > head []
07:43:28 <lambdabot>  Exception: Prelude.head: empty list
07:43:31 <integral> Cale: but it's a safe crash
07:43:35 <Cale> Which means that it's basically not type safe.
07:43:56 <atom> ricky_clarkson: good point :)
07:44:17 <sieni> ricky_clarkson: so don't do that! :-)
07:44:27 <ski> ricky_clarkson : the ability to do something constrains your ability to make promises
07:44:48 <integral> @type head []
07:44:49 <lambdabot> forall a. a
07:45:05 <Cale> ricky_clarkson: In dynamically typed languages, you have no ability to control the way in which your functions are going to be called.
07:45:05 <mrd> classes are garbage anyhow, especially when conflated with module systems
07:45:28 <Cale> ricky_clarkson: Which is something which you might want to do.
07:45:55 * integral hates typos in method names in perl
07:46:11 * mrd is surprised perl doesn't auto-spell-correct
07:46:13 <atom> mrd: I like class semantics. Data and function that operates on that data should go together. It's just natural.
07:46:24 <integral> mrd: there's a module for that :-)
07:46:39 <ricky_clarkson> ski: You can choose on a case by case basis which ability you want.
07:46:41 <mrd> atom: for some things
07:47:07 <fasta> atom: Computers are not natural.
07:47:13 <atom> mrd: true. Actually, I find it to be true for most things.
07:47:20 <mrd> math is not one of those things
07:47:36 <ski> ricky_clarkson : but can you make guarrantees (modulo compiler bug,hardware failure,..) ?
07:47:38 <ttfh> how does hpaste work?
07:47:46 <Cale> atom: It is rather restrictive
07:47:59 <Cale> atom: It means that functions can't be overloaded on their result type.
07:48:02 <fasta> ttfh: it listens on port 80 and responds?
07:48:05 <atom> mrd: hm... is there an easier way? At least you can implement first-order-functions with objects
07:48:13 <atom> Cale: that's true as well
07:48:18 * mrd prefers higher-order functions
07:48:22 <atom> fasta: lol
07:48:39 <atom> mrd: sorry, that's what I meant.
07:48:41 <integral> using objects where functions are sufficient is rather ugly in languages which do that
07:48:48 <fasta> ttfh: the source is available too
07:48:54 <ttfh> fasta: really?
07:48:56 <atom> higher order functions.
07:48:57 <ttfh> :-)
07:49:00 <pjd> Cale: not *exactly*
07:49:08 <ricky_clarkson> ski: You could only allow opening classes to add methods, not change/delete them.
07:49:13 <fasta> ttfh: http://www.scannedinavian.com/~eric/hpaste/
07:49:15 <Cale> pjd: hm?
07:49:24 <pjd> see e.g. Perl's list versus scalar context
07:49:24 <fasta> ttfh: which you could have see if you scrolled down
07:49:29 * mrd would like to see the function (.) in OOP
07:49:40 <ricky_clarkson> You could even add methods only in a lexically scoped way.
07:49:54 <fasta> Cale: not all languages think that the vector 1 2 3 and 1 are different "things".
07:50:13 <ski> pjd : is that a syntactic category overloading ?
07:50:21 <fasta> Cale: they define 1 to be the vector of length 1 then.
07:50:30 <Cale> fasta: I know that
07:50:52 <ttfh> faste: I meant more along the lines of "how do I use it", but alright
07:51:17 <ski> fasta : how about the 2-vector consisting of those two vectors ?
07:51:19 <Cale> pjd: er, what was that a response to?
07:51:37 <pjd> Cale: overloading based on return type
07:51:47 <ski> Cale : overload on result type in dyn. typed lang.s, i think
07:52:03 <fasta> ttfh: then perhaps you should ask that next time :)
07:52:08 <Cale> oh, but that's not a class mechanism
07:52:15 <hpaste>  ttfh pasted "Illegal instance declaration" at http://hpaste.org/3576
07:52:27 <Cale> (perl's contexts aren't an OO thing)
07:52:32 <spy> join #haskell
07:52:44 <mrd> spy: you've made it
07:53:01 <fasta> ski: they (in R) call that a matrix, AFAIK.
07:53:06 <atom> Cale: ok. so... I guess I'm stuck with my own operators for the forseeable future regarding haskell. Ok. I'll get used to it :)
07:53:13 <sjanssen> ttfh: you need to turn on a couple extensions
07:53:20 <fasta> ski: they also have a few other concepts, but it's quite messy, imho.
07:53:29 <ttfh> sjanssen: which ones?
07:53:49 <ttfh> sjanssen: and why does it work with IO?
07:54:06 <sjanssen> ttfh: either "{-# LANGUAGE FlexibleInstances, TypeSynonymInstances #-}" at the top of your file or just use -fglasgow-exts
07:54:27 <Cale> atom: The good thing about this way of doing things is that when you see an operator, it could only *mean* one thing, even if the code for it might be different depending on the eventual type.
07:54:44 <ttfh> so in vanilla haskell you can't declare a type synonym an instance?
07:54:51 <sjanssen> ttfh: that is correct
07:54:52 <pjd> Cale: with say generic-function based OO, nothing in principle prevents you from overloading based on result type
07:54:54 <atom> Cale: well, at least that's true.
07:55:13 <ttfh> ok, that cleared everything up for me, thank you very much
07:55:48 <sjanssen> ttfh: the second problem is 'ReaderT Point IO'.  Haskell '98 says that instances must be of the form "instance Class (Type a b ..)" where "a b ..." are type *variables*
07:55:54 <pjd> or non-generic-function OO, i guess
07:55:54 <atom> Cale: I've got another question though - in my instance Add Die Int Roll where... The Int should actually stand for any Integral type, but I can't find a way to specify that
07:55:58 <Cale> atom: In Haskell, classes usually come with expectations about the laws that the functions will satisfy.
07:56:29 <Cale> instance (Integral a) => Add Die a Roll
07:56:47 <atom> Cale: where in C++ classes come with "functionality" they satisfy. Is that your point?
07:56:53 <sjanssen> plus undecidable and overlapping instances
07:57:09 <atom> Cale: thanks
07:57:52 <Cale> atom: well, in C++ it's a little mixed together
07:57:57 <ttfh> sjanssen: Hmm, I don't understand that bit...
07:58:15 <sjanssen> ttfh: it's a bit obscure :)
07:58:28 <Cale> atom: The closest thing in C++ to a Haskell class would be an abstract base class, I suppose.
07:58:31 <atom> Cale: I mean, ever since I've started with haskell, I find my math education to be a lot better a lead than my programming education
07:58:36 <Cale> yeah
07:58:41 <Cale> It generally is.
07:58:47 <ttfh> sjanssen: the problem is in the type declaration for DrawIOPostscript i mention these types explicitly?
07:58:52 <atom> Cale: thank gods I have both.
07:58:53 <shapr> I wish classes came with qc props
07:59:03 <sjanssen> ttfh: your instance was for 'ReaderT Point IO', Haskell '98 says that Point and IO must be type variables
07:59:18 <Cale> shapr: They can, at least... :)
07:59:36 <shapr> Cale: I just wish it happened more often.
07:59:38 <atom> Cale: yeah, about the abstract base classes... Well, probably the best match is java interfaces
07:59:54 <atom> abstract base classes can have datamembers
08:00:01 <atom> if I remember correctly
08:00:09 <pjd> atom: so can Java interfaces
08:00:17 <atom> pjd: really? damn me
08:00:26 <ski> atom : can those data-members be function pointers ?
08:00:31 <atom> pjd: ok... UML API descriptions :)
08:00:50 <ttfh> sjanssen: if I would have declared the type with "data" instead, I would have been alright?
08:00:55 <pjd> Java interfaces are just "purely" abstract base classes; i.e., no method implementations
08:00:59 <ski> ttfh : yes
08:01:10 <sjanssen> ttfh: yep, it's even a common idiom
08:01:14 <atom> ski: probably, although anyone that saw that would probably strangle ou on the spot
08:01:22 <ski> ttfh : though `newtype' would have been more fitting, in this case
08:01:43 <ski> atom ;)
08:03:22 <ricky_clarkson> Java interfaces can only have static data members.
08:03:28 <ski> ttfh : `newtype DrawIOPostscript a = MkDIOP {unDIOP :: ReaderT Point IO a} deriving Monad' -- e.g.
08:03:29 <ttfh> hmm, so maybe the best way is to use newtype and do without the extensions
08:03:56 <ski> (though that `deriving Monad' is of course an extension, too :)
08:04:50 <ttfh> hmm, I don't understand how deriving works, I've used it for "deriving Show", very neat, but I don't understand it
08:04:56 <sjanssen> ttfh: those extensions are actually widely supported, so don't worry about them too much
08:05:09 <ski> it's hard-coded for a few standard classes
08:05:46 <ski> however, ` deriving Monad' there is called `newtype-deriving', and works for any class at all, but only over newtypes
08:05:54 <ttfh> ski: those curly braces... what do they do?
08:06:18 <ski> ttfh : just declares a record field name .. or if you like, a convenient extraction function
08:06:21 <ski> it's the same as
08:06:34 <ski>   newtype DrawIOPostscript a = MkDIOP (ReaderT Point IO a) deriving Monad
08:06:44 <ski>   unDIOP :: DrawIOPostscript a -> ReaderT Point IO a
08:06:58 <ski>   unDIOP (MkDIOP diop) = diop
08:07:16 <ttfh> thank you very much
08:07:21 <ttfh> gotta go
08:07:49 <ski> ttfh : the syntax is for simulating records with `data' .. but works for `newtype' as well (but then you can only have one constructor with one field, of course since that is what newtypes do)
08:13:55 <hpaste>  atom annotated "problem with operator overloading/defining operations" with "A further problem with wanting to use a class instead of a type." at http://hpaste.org/3575#a1
08:14:18 <atom> can anyone tell me what the correct way to write this is?
08:15:19 <jedbrown> I have a program that builds a (Map [Ratio Int] Double) with ~10^6 nodes (in a dimension=2 case, so the list is only length 2) and it is taking >600 MiB.  This seems about 10 times more than I would expect.
08:16:44 <MyCatSchemes> atom: use a HB pencil and a nice clean sheet of paper. :)
08:17:02 <shapr> jedbrown: Have you profiled the memory usage?
08:17:08 <atom> MyCatSchemes: that would be appropriate if I had a scanner :)
08:18:15 <jedbrown> shapr: I've profiled speed.  How do I get memory?
08:18:37 <shapr> I don't remember off the top of my head, but I've seen it on the haskellwiki
08:19:16 <MyCatSchemes> atom: put it on a wooden table and take a photograph. ;)
08:19:32 <Saizan> atom: you've to write data Die a = Integral a => Die a a
08:20:21 <atom> Saizan: oh, so THAT was the problem. Do I then have to instantiate Dice as Die Int something something?
08:21:08 <Saizan> atom: you use the contructor in the same way, but the type will be (Die Int) or (Die Integer) etc..
08:21:21 <atom> oh, perfect. just what I wanted.
08:21:34 <Saizan> same for Roll
08:21:39 <atom> MyCatSchemes: I live in a forest of molecules. I don't *have* a table
08:21:49 <ricky_clarkson> (Die Bart Die)
08:22:04 <atom> ricky_clarkson: lol
08:22:09 <atom> is Bart an integral type?
08:22:14 <ski> @die 3d6
08:22:15 <lambdabot> 3d6 => 13
08:22:30 <shapr> @die 99d99
08:22:31 <lambdabot> 99d99 => 5059
08:22:38 <shapr> @die 1d1
08:22:38 <lambdabot> 1d1 => 1
08:22:41 <shapr> @die 1d2
08:22:41 <lambdabot> 1d2 => 2
08:22:42 <atom> @die 3d6
08:22:42 <lambdabot> 3d6 => 12
08:22:49 <atom> yup, actually rolls them
08:22:49 <ski> @die 4d0
08:22:50 <lambdabot> 4d0 => 1
08:22:53 <ski> ?
08:22:56 <shapr> I broke @die the first day by doing @die 9999999999d999999999
08:22:59 <shapr> haha
08:23:03 <shapr> ski: You found a bug!
08:23:09 <atom> ski: multiplies. same way 0! =1
08:23:22 <MyCatSchemes> atom: you can make do with an association list, provided you don't care about performance... :)
08:24:00 <atom> @src die
08:24:00 <lambdabot> Source not found. You type like i drive.
08:24:23 <Cale> jedbrown: make sure that all the elements are forced?
08:24:28 <ski> atom : a six-sided die can give values in {1,2,3,4,5,6}, then a zero-sided die can give values in {}, so it shouldn't be possible to succeed throwing such a die
08:24:34 <shapr> ski: Makes sense to me.
08:24:37 <ski> @help die
08:24:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:24:44 <atom> ski: of course it's a bug, but it's logical.
08:24:44 <ski> @list die
08:24:45 <lambdabot> No module "die" loaded
08:24:47 <shapr> musasabi wrote @die
08:24:49 <Cale> jedbrown: If you're holding onto code for each element in the map, it might be a bit larger than that.
08:25:20 <Cale> jedbrown: But still, yeah, I'd have estimated about 1/10 that memory usage as well
08:25:26 <ski> @die 0d6
08:25:27 <lambdabot> 0d6 => 0
08:25:39 <phlpp> hi!
08:25:44 <ski> lo!
08:25:45 <jedbrown> Turns out my profiling does show memory (%alloc) which closely follows %time.
08:26:07 <Cale> oh, which profiling mode are you using?
08:26:16 <jedbrown> I do a lot of partitioning of the map, but it is always in the context of a fold, so I'm never holding onto it.
08:26:19 <shapr> jedbrown: You could also dump the strictness information and see if something is being more lazy than it could be.
08:26:30 <shapr> Or less lazy than it could be.
08:26:36 <jedbrown> I'm compiling with -prof -auto-all and running with +RTS -p
08:26:39 <shapr> Laziness can lead to pleasant fusion.
08:26:45 <Cale> Ah, then that's just total allocation
08:27:00 <Cale> (as if you'd never GC'd)
08:27:11 <jedbrown> I'm sure I can remove quite a bit of laziness, but I like it now.
08:27:29 <jedbrown> The total usage is what is displayed by top while it is running.
08:27:42 <jedbrown> That is where I'm quoting the 600+ MiB
08:27:56 <Cale> run with -hc instead
08:28:00 <Cale> oh
08:28:02 <Cale> okay
08:28:19 <Cale> well, run with -hc anyway
08:28:28 <jedbrown> trying that now.
08:28:36 <Cale> and run hp2ps on the resulting .hp file
08:28:47 <Cale> and you'll get a nice graph of the memory usage over time
08:28:58 <jedbrown> Oh, cool.
08:29:19 <Cale> that's broken down by producer cost-centre
08:29:39 <Cale> there are other options for figuring out what's holding on to things so they don't get GC'd and so on
08:29:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
08:29:47 <lambdabot> Title: 5.4. Profiling memory usage, http://tinyurl.com/ycro5f
08:30:16 <jedbrown> The context is arbitrary-dimensional adaptive wavelets.  I'm sure I can significantly improve things by using tuples instead of lists, but then I loose a little dimensional flexibility.
08:30:57 <Cale> It might be interesting to see just how much memory that would save, if it's not a huge pain to switch it back and forth.
08:31:45 <jedbrown> I just have to write a little extra code for each case and replace map for a few operations.
08:31:46 <Cale> I suspect it would save about 12 bytes per element.
08:31:57 <Cale> er
08:31:58 <Cale> 20
08:32:36 <Cale> Though I'm kind of guessing on some details of GHC's representation which I'm not terribly clear about
08:32:39 <jedbrown> For 2^16 nodes, the postscript file shows about 12 MiB usage.
08:33:43 <Cale> So that's ~183 bytes per node.
08:34:04 <jedbrown> top is showing 206 MiB for 2^18 nodes now.  I'll see the postscript in a minute.
08:34:35 <Cale> which is way more than linear increase in size
08:35:27 <jedbrown> I'll have to check if the postscript quote corresponds to actual usage, but the small case doesn't take very long to run.
08:35:35 <fasta> jedbrown: profiled code can run several factors slower.
08:35:51 <jedbrown> Yes, I'm noticing that while waiting for this run to finish.
08:36:28 <shapr> jedbrown: how long does a run take?
08:36:43 <shapr> jedbrown: If you're on a dual-core, can you use forkIO and +RTS -N 2 ?
08:37:08 <jedbrown> For 2^16, it takes half a minute or so, but more than 2 for profiled code.
08:37:22 <jedbrown> Although I can cut that in four by not repeating similar things.
08:37:46 <jedbrown> I'm on an old single core.
08:39:06 <fasta> jedbrown: what "nodes" do you speak of?
08:39:08 <jedbrown> So the hp2ps shows about 50 MiB usage, but top showed 200+ throughout the entire run.
08:39:24 <jedbrown> elements in the Map.  They correspond to active wavelets.
08:39:38 <Cale> well ~50 makes more sense
08:39:46 <jedbrown> Each node is ([Ratio Int], Double)
08:39:51 <fasta> jedbrown: do you really need a Map?
08:39:55 <jedbrown> But the list is only length 2 at the moment.
08:40:08 <wli> VSZ vs. RSS
08:40:14 <jedbrown> Yes, because there are typically only a small fraction of the wavelets actually active.
08:40:32 <jedbrown> I was quoting from RES
08:40:47 <fasta> jedbrown: you misunderstand the issue
08:41:15 <shapr> jedbrown: Is your code NDA or otherwise confidential? Is it short enough to hpaste?
08:41:22 <jedbrown> fasta: An array would be more natural for the `dense' case.
08:41:32 <jedbrown> It is 200 lines, will paste.
08:42:05 <fasta> jedbrown: ok, I don't know anything about wavelets, but usually you can do some tricks and still do it with arrays.
08:42:20 <hpaste>  jedbrown pasted "wavelets" at http://hpaste.org/3577
08:43:02 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3578
08:43:36 <hpaste>  jedbrown pasted "wavelets part 3" at http://hpaste.org/3579
08:43:48 <jedbrown> Turns out it had to be split up.
08:45:17 <jedbrown> fasta: the trouble is the multiscale nature of the problem.  They correspond to a physical problem I'm modeling.  I want to represent functions with local behavior on a very fine scale, embedded in a very big space.
08:45:57 <jedbrown> fasta: Since I don't know where I need a fine scale until I solve the problem, the solution method must have a multilevel data structure.
08:47:00 <hpaste>  jedbrown annotated "wavelets part 3" with "Main looks like this." at http://hpaste.org/3579#a1
08:47:02 <Cale> That sounds like a job for quadtrees or some such spatial partitioning.
08:48:02 <jedbrown> Cale: yes, I'm sure there are better trees.  My first thought was a radix tree, but I either have to roll my own or subvert IntMap a bit.
08:48:17 <Cale> Well, actually what you have is sorta-kinda like that yeah :)
08:48:28 <jedbrown> And I have a problem with address space using IntMap on a 32 bit machine.
08:49:40 <jedbrown> One of the things I've been thinking about is implementing a new ordering so that I can use Map.split instead of Map.partition (this actually has other benefits).
08:50:14 <jedbrown> Also, since all my points are purely dyadic on the interval [-1,1], I should be able to do better than Ratio Int, but that was easy to do while prototyping.
08:50:29 <chessguy> #math
08:50:41 <chessguy> oops
08:50:56 <jedbrown> chessguy: were you suggesting we should move?
08:51:35 <chessguy> no, i typed /j #math, but my window changed in the middle :)
08:53:19 <chessguy> i don't even know what you were talking about
08:53:26 <Cale> heh, this is practically #math2
08:53:40 <Cale> with less homework and more computer science
08:54:12 <jedbrown> One of my favorite things about writing haskell is it looks so much like math.
08:56:02 <chessguy> hm, while i like that about haskell, i don't know that it would be all that high up on my list of favorite things about i
08:56:04 <chessguy> t
08:56:26 <ricky_clarkson> It looks so much like the maths I never learned.
08:57:04 <chessguy> and so much like the math i wish i knew :)
08:57:10 <Cale> Heh, the syntax of Haskell was actually one of the things which made it easier for me to learn in the first place.
08:57:58 <jedbrown> I'm really quite new to haskell, but now more than ever, I can't stand writing C/C++.
08:58:03 <shapr> :-)
08:58:03 <jedbrown> Or python for that matter.
08:58:23 <Cale> http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
08:58:24 <lambdabot> Title: C/C++ Request For Enlightenment 0 - Design Philosophy
08:59:11 <jedbrown> Cale: Nice
08:59:19 <chessguy> > 9^9
08:59:21 <lambdabot>  387420489
08:59:29 <raxas> hmm, after 25 years of switching programming languages, haskell is the first difficult challenge to me
09:01:12 <fasta> Is there a way in GHC to tell that I want the cost centres of everything that's required to compute f are attributed to f?
09:01:26 <chessguy> "C/C++ is easy to write. It uses a notation that rejoices in the name of bosops aniawysipaz, which is the word-reversed form of the letter-reversed form of the Polish phrase meaning "notation". This is also sometimes known as RRPN. Using RRPN, it is possible to express complex ideas quickly and simply."
09:01:28 <chessguy> rofl
09:01:48 <roconnor> I've done an svn add, but not a commit.  How do I undo my add?
09:02:30 <jedbrown> roconnor: svn rm --force
09:02:44 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/gooeyhat.png <-- win :)
09:03:10 <Cale> cool :)
09:03:17 <roconnor> jedbrown: um, my file is gone.
09:03:23 <roconnor> good thing I copied it :)
09:03:50 <jedbrown> roconnor: the file is gone, but svn thinks it is still there?
09:04:01 <jedbrown> roconnor: can you touch its name and then svn rm --force it
09:04:02 <jedbrown> ?
09:04:25 <roconnor> jedbrown: no, it's just svn rm also deleted the file, which is more than the opposite of svn add
09:04:49 <roconnor> svn add schedules a file to be added to revision control
09:04:58 <jedbrown> roconnor: Oh.  Yes, it will do that.
09:05:57 <kpreid> jedbrown: your advice needs improvement.
09:06:15 <kpreid> the way to undo an add is "svn revert", just like any other uncommitted name
09:06:17 <roconnor> kpreid: it's okay, I half expected it to get deleted ;)
09:06:25 <kpreid> s/name/change/
09:06:28 <jedbrown> I misunderstood the question.  Sorry.
09:06:53 <fasta> That's a nice logical answer to the question how do delete file foo: rm -rf /
09:07:14 <fasta> It does delete the file (on some OS's not), but it also does other things ;)
09:12:53 <jedbrown> Cale: the hp2ps output shows just heap usage.  I had to increase the stack space (from the 8 MiB default) for the larger cases.  However, doubling it seemed to be enough.  Any idea where the extra 140 MiB is?
09:13:06 <jedbrown> Cale: Is the garbage collector just slow?
09:17:00 <fasta> jedbrown: AFAIK, it's pretty fast.
09:17:01 <jedbrown> Cale: http://59A2.org/files/Main-8.ps
09:18:14 <jedbrown> off-topic, but...  http://59A2.org/files/calving-2007156-864.avi
09:18:25 <fasta> jedbrown: there is a section on this in the user manual
09:21:09 <jedbrown> fasta: Addressing the discrepency?  I'm looking, but I don't see why the huge difference.
09:21:40 <fasta> jedbrown: I am also not sure exactly what you mean, since I didn't follow the complete conversation.
09:21:54 <fasta> jedbrown: what numbers are you comparing?
09:22:52 <jedbrown> fasta: The RSS memory usage (from ps/top) to the heap profile.
09:23:04 <fasta> jedbrown: yes, that's documented
09:30:58 <quicksilver> Beelsebob: that's gorgeous!
09:31:07 <quicksilver> Beelsebob: where did that come from?
09:31:36 <Beelsebob> quicksilver: nocked it together in no time from great big chunks of hat-observe and Cocoa's toolkit :)
09:31:56 <Beelsebob> lots of work to do on it
09:32:06 <Beelsebob> the plan is that that's the starting point for firing off other gui tools
09:32:20 <chessguy> Beelsebob, i don't get it. is that haskell code?
09:32:39 <quicksilver> release early, release often! I'd partly be interested just becauser I haven't seen haskell-cocoa bindings in use
09:32:51 <quicksilver> and partly because I've always wanted to see a nicer hat :)
09:33:01 <Beelsebob> chessguy: it's debugger observations from a run of the "insSort"
09:33:18 <Beelsebob> quicksilver: unfortunately, it's not written in Haskell (or most of it isn't)
09:33:21 <chessguy> oh, ok
09:33:27 <Beelsebob> HOC doesn't work very stably
09:33:36 <Beelsebob> hopefully though that'll change with the new bridging toolkit
09:33:36 <quicksilver> Beelsebob: ah, you make me sad :(
09:33:55 <Beelsebob> (Leopard has a shiny toolkit specifically for bridging other languages to Cocoa)
09:34:11 <Beelsebob> they even provided Python and Ruby bindings :)
09:34:44 <Beelsebob> quicksilver: for the moment, it's a bit too unstable to be released early
09:34:57 <Beelsebob> but as soon as I get the observe like tool into a stablish state I'll release it
09:35:54 <foo-nix> Why can I not do this:  "instance Show [Token] where ...."     (http://pastebin.org/6731) ? Because [Token] is a type but not a algebraic type?
09:36:05 <Beelsebob> the other minor annoyance is that it requires Leopard to run, mostly because I was lazy, and wanted garbage collection in my C code
09:36:20 <fasta> foo-nix: because it requires overlapping instances
09:36:21 <Beelsebob> foo-nix: because there's already an instance for Show []
09:36:32 <Beelsebob> s/[]/[a]/
09:36:41 <fasta> foo-nix: so, you "can", but it's almost always a bad idea.
09:36:56 <foo-nix> Beelsebob: so, what should I do If I want to show [Token] different?
09:37:15 <Beelsebob> foo-nix: as fasta says, you need overlapping instances, but it's almost always a bad idea
09:37:28 <fasta> foo-nix: newtype it or don't use show or overlapping instances
09:37:37 <quicksilver> foo-nix: probably you don't want to use show
09:37:38 <foo-nix> fasta: I want [Token] to be shown different then [a] where a is not Token.
09:37:47 <quicksilver> foo-nix: that's the wrong thing to want :)
09:37:52 <quicksilver> foo-nix: show for [a] should be unifrom
09:37:59 <quicksilver> if you have another kind of pretty-printing in mind
09:38:06 <quicksilver> don't try to overload 'Show' to get it
09:38:13 <quicksilver> call it 'pretty' or 'pp' ;)
09:38:18 <foo-nix> quicksilver: So I should want to make a different class,.
09:38:21 <fasta> foo-nix: I told you: use overlapping instances, but I warned you.
09:38:53 <foo-nix> class pretty ....
09:38:59 <foo-nix> *Pretty
09:39:01 <Beelsebob> so, your options are... invent a new class "Pretty"; use overlapping instances, or newtype TokenStream = TS [Token]
09:39:09 <ivanm> if I have an algebraic datatype, how do I set it in the module's function listing so that all the constructors are visible outside that module?
09:39:36 <foo-nix> thanks all.
09:39:39 <Beelsebob> ivanm: module Jam where (Type(..))
09:40:20 <ivanm> e.g. if I have "data FooBar = F | B" in module FB, how do I write the module listing? "module FB (FooBar) where" doesn't seem to work :s
09:40:20 <oerjan> foo-nix: um, Show is a special case
09:40:29 <ivanm> thanks Beelsebob
09:40:41 <ivanm> what about custom classes? does that work for them as well?
09:41:16 <oerjan> the show for [Token] is derived from showList for Token.  So make an instance for Token, overriding showList.
09:41:23 <Rebooted> so do overlapping instances allow different branches of a GADT to implement a type class differently?
09:42:28 <Beelsebob> Rebooted: no one said anything about GADTs
09:42:35 <Rebooted> i did..
09:42:43 <fasta> Beelsebob: he just asks a related question.
09:43:05 <Beelsebob> they merely allow you to have two instances for types that are not entirely different
09:43:16 <fasta> I.e. whether you can write an instance Show (Foo Int) and Show (Foo String)
09:43:23 <oerjan> (this was hacked in to allow String to work differently)
09:43:29 <fasta> I think you can, but I don't know.
09:43:38 <fasta> Rebooted: that's what you meant, right?
09:43:45 <Rebooted> yeah
09:44:00 <fasta> Rebooted: I am so understanding ;)
09:44:22 <fasta> Rebooted: but it's rather pointless, I think
09:44:25 <Rebooted> i want to write a proper encoding of the XHTML DTD into a type, and if I could do that it would be a lot easier
09:44:42 <fasta> Rebooted: since you can just use pattern matching to handle the different cases.
09:45:48 <Rebooted> well, it would be useful if I could have Foo String implement a class and Foo Int not implement it at all
09:46:23 <Rebooted> i'll try it
09:46:49 <sclv> fasta: I found a few uses of this too, for selective overriding.
09:47:39 <sclv> it lets you define a default case, and then specialize it on an ad-hoc basis.
09:47:58 <ski> > do {x <- foo [0,1,2] where {foo [] = return []; foo (y:ys) = return ys `mplus` ((y:) `liftM` foo ys)}; return (reverse x)}  -- hmm
09:47:58 <lambdabot>  Parse error at "where" (column 22)
09:48:16 <ski> > do {x <- let {foo [] = return []; foo (y:ys) = return ys `mplus` ((y:) `liftM` foo ys)} in foo [0,1,2]; return (reverse x)}  -- pity
09:48:17 <lambdabot>   add an instance declaration for (Show (t1 [t]))
09:48:32 <fasta> sclv: I don't use GADT's, so I don't have experience with them, but it sounds nice, although overlapping instances seem to be a bad idea when you used them a lot.
09:48:33 <ski> > do {x <- let {foo [] = return []; foo (y:ys) = return ys `mplus` ((y:) `liftM` foo ys)} in foo [0,1,2]; return (reverse x)} :: [[Int]]
09:48:35 <lambdabot>  [[2,1],[2,0],[1,0],[2,1,0]]
09:49:39 <ski> i wonder why `where' clauses can't appear on `do'-bindings
09:50:04 <Rebooted> fasta: yup, it works
09:50:22 <sclv> ski: trying to do a cleaner perms func?
09:50:26 <ski> ("Lazy Imperative Programming", John Launchbury, seems to suggest that that was at least breifly considered)
09:50:27 <fasta> Rebooted: if you have an actual application for it, you could document it.
09:50:35 <ski> sclv : no, just an example
09:50:52 <fasta> Rebooted: I think the current situation is that compiler writers think overlapping instances are a bad idea too.
09:51:54 <Rebooted> fasta: i'm not sure if this is actually overlapping instances actually
09:52:29 <Rebooted> fasta: nothing is overlapping.. i only needed -fglasgow-exts, not the overlapping flag
09:52:45 <fasta> Rebooted: -fglasgow-exts implies overlapping
09:53:05 <fasta> Rebooted: but it depends on the actual data declaration, I think
09:53:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/3580
09:53:34 <fasta> Rebooted: If you have one constructor with data Foo a =  Foo a, you could be looking at overlap already.
09:53:47 <Rebooted> that's what i tried out
09:53:48 <fasta> Rebooted: (next to your other more typed constructors)
09:53:54 <shapr> Does Data.Binary work on MacOSX/Darwin ?
09:54:05 <shapr> Specifically, on Intel hardware?
09:54:11 <quicksilver> Rebooted: you can, although you might need glasgow-exts
09:54:21 <fasta> Rebooted: remove fglasgow-exts and try again
09:54:27 <fasta> quicksilver: he already did
09:54:40 <quicksilver> fasta: sorry I was scrolled back 10 minutes without realising I was :)
09:54:48 <Rebooted> yeah, fglasgow-exts is needed since it is a GADT anyway
09:55:03 <fasta> Rebooted: bo
09:55:05 <fasta> Rebooted: no
09:55:13 <fasta> Rebooted: all the features have their own flags
09:55:21 <Rebooted> oh
09:55:30 <sclv> ski: vis a vis the where clause in do bindings, i guess its because where clauses scope over larger blocks?
09:56:26 <bakert> if i have a Data.Map is there a way to get a map which is the subset of just entries with keys that match a certain pattern?
09:56:44 <Rebooted> fasta: do you know what the GADT flag is? i can't find it
09:57:00 <bakert> specificaly if keys are of type data = A String | B Integer, can I get a Map composed of all the entries that are type A _ ?
09:57:55 <bakert> oh hang on .. there's a filter in Data.Map
09:57:56 <bakert> doh
09:58:18 <fasta> Rebooted: -X=GADTs
09:58:23 <fasta> Rebooted: in >=6.8
09:58:44 <fasta> Rebooted: otherwise, find your own manpage.
09:59:42 <pejo> shapr, I'm running 0.3 and it works afaik.
10:00:47 <hpaste>  mux pasted "any idea for a better name?" at http://hpaste.org/3581
10:01:36 <mux> elemOrdered ?
10:03:28 <fasta> sortedUpTo?
10:03:35 <hpaste>  mux annotated "any idea for a better name?" with "more point-free and new name" at http://hpaste.org/3581#a1
10:05:37 <Runaro_BRS> If you have two libraries, from two different vendors, that pretty much do the same thing, and you want to be able to substitute one for the other during deployment of your application, what's a common way of doing that with Haskell?
10:07:08 <spine> IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:10 -spine(i=elik5-59@159.148.18.129)- IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:12 <spine> IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:13 <lambdabot> Title: Lost Worlds - [ GalvenÄ ]
10:07:14 <lambdabot> Title: Lost Worlds - [ GalvenÄ ]
10:07:14 -spine(i=elik5-59@159.148.18.129)- IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:16 <spine> IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:17 <lambdabot> Title: Lost Worlds - [ GalvenÄ ]
10:07:18 -spine(i=elik5-59@159.148.18.129)- IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:20 <spine> IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:22 <lambdabot> Title: Lost Worlds - [ GalvenÄ ]
10:07:22 -spine(i=elik5-59@159.148.18.129)- IRCOP HACK JOIN HERE http://lostworlds.lv/go.php?1139625893
10:07:42 <arcatan> hrmmph.
10:08:06 --- mode: ChanServ set +o Philippa_
10:08:17 --- mode: Philippa_ set +b *!*@159.148.18.129
10:08:22 --- kick: spine was kicked by Philippa_ (spammer)
10:08:33 <Runaro_BRS> wanker
10:09:15 --- mode: Philippa_ set -o Philippa_
10:10:18 <sieni> Runaro_BRS: don't insult people who masturbate!
10:10:37 <bakert> Pattern matching and filter.  Say I have:
10:10:38 <bakert> let x = [("a", 1), ("a", 4), ("b", 4), ("a", 2)]
10:10:47 <bakert> How do I say:
10:10:48 <bakert> filter (\("a", x) -> x > 1) x
10:10:57 <bakert> without it being non-exhaustive doo-dah?
10:11:12 <bakert> (ooops to many x's)
10:11:33 <bakert> a bit clearer with:
10:11:33 <bakert> filter (\("a", v) -> v > 1) x
10:11:37 <bakert> as the second line
10:11:59 <mux> > filter (\(x,y) -> x == "a" && y > 1) [("a", 1), ("a", 4), ("b", 4), ("a", 2)]
10:12:00 <bakert> that is, how can i get a False automatically for any value that does not match the pattern, rather than getting an error?
10:12:01 <lambdabot>  [("a",4),("a",2)]
10:12:22 <mux> I don't know if that's possible the way you are suggesting it
10:12:39 <bakert> mux: hmm yeah i suppose that is pretty obvious really :)  let me see if that works for the more complicated problem in my program.  thanks!
10:12:53 <mux> you're welcome
10:13:08 <sclv> bakert: you can also throw in a case statement.
10:13:10 <mux> otherwise
10:13:18 <ski> sclv : well, they scope over ordinary value and function bindings .. e.g. `fun x = case x of Nothing -> ..; Just y -> z where z = ...' or `fun x = let f y = ... where z = ... in ...'
10:13:40 <mux> > filter (\("a",x) -> x > 1; _ -> False) [("a", 1), ("a", 4), ("b", 4), ("a", 2)]
10:13:40 <lambdabot>  Parse error at ";" (column 26)
10:13:53 <mux> hm yeah, you'd need a case.
10:13:58 <mux> or a separately defined functon
10:14:03 <bakert> ah ok.  i've worked out why i didn't think of that.
10:14:09 <ski> sclv : so i don't think it would be that unreasonable to also allow them on `do'-bindings (and generators in list comprehensions, of course)
10:14:10 <bakert> my real problem is not pairs.
10:14:12 <bakert> it's a data type
10:14:24 <bakert> data V = X String | Y Integer | Z
10:14:42 <bakert> so sometimes it can be broken into two parts with pattern matching but sometimes it can't
10:14:44 <mux> provide a function to unfold your ADT
10:15:02 <bakert> mux: once more but for a thick person?
10:15:06 <bakert> :)
10:15:45 <mux> something like unfold :: V -> (String -> a) -> (Integer -> a) -> a -> a
10:15:55 <mux> or go the case way
10:16:30 <bakert> i see.  thanks.  i will try case first and see where i get to as there are only two real possibilities here
10:16:31 <mux> the unfold function would essentially be a case
10:16:40 <mux> that would allow you to write smaller code for those cases
10:17:01 <mux> I mean, those cases where you need to act upon the valeus of V :)
10:17:55 <mux> it would then be filter (unfold (== "a") (> 1) False)
10:18:16 <mux> (with the parameters put in the right order of course)
10:18:32 <mux> see?
10:19:06 <mux> so, unfoldV :: (String -> a) -> (Integer -> a) -> a -> V -> a
10:19:17 <quicksilver> bakert: use a list comp
10:19:21 <shapr> pejo: Does Data.Binary work for you in ghci also?
10:19:25 <mux> and, filter (unfoldV (== "a") (> 1) False)
10:19:53 <sclv> for the orig example: uncurry (||) . ((==)"a" *** (>1))
10:20:14 <vali> hello. how much do i need to know about monads in order to survive as a hobby haskell programmer? are they lisp lisp macros, something you don't need to know to do basic stuff?
10:20:15 <sclv> is there a nice arrowlike thing to replace uncurry (||) ?
10:20:23 <quicksilver> let l = [("a",1),("b",2),("a",2)] in [ x | x@("a",y) <- l, y>1 ]
10:20:27 <quicksilver> > let l = [("a",1),("b",2),("a",2)] in [ x | x@("a",y) <- l, y>1 ]
10:20:29 <mux> heh, those arrow lovers can't resist the envy to use one of those operators everytime pars are around :)
10:20:29 <lambdabot>  [("a",2)]
10:20:49 <sclv> mux: I'm just starting to get the hang of the basics of arrow functions, so...
10:20:50 <quicksilver> bakert: list comprehensions are the way to get a filter based on a pattern match
10:20:51 <mux> but he doesn't actually need to use pairs
10:21:11 <mux> right, list comprehensions are the best thing since sliced bread
10:21:45 <Rebooted> vali: they're not *that* hard
10:22:18 <quicksilver> vali: you need to know that monads what 'IO side-effects' use
10:22:25 <quicksilver> vali: like putStrLn "hello world"
10:22:45 <quicksilver> vali: you don't really need to know what monads mean, to get by. Although you get the hang of it soon enough in practice.
10:22:48 <vali> quicksilver: ah. i understood that they isolate impure functions... functions that don't always return the same thing when given the same parameters
10:22:54 <quicksilver> yes
10:22:59 <quicksilver> that's also true
10:23:11 <quicksilver> since impure functions have the 'side-effect' of make a non-deterministic choice
10:23:17 <hpaste>  mux annotated "any idea for a better name?" with "with user-supplied comparison test?" at http://hpaste.org/3581#a2
10:23:22 <quicksilver> you have to be quite boradminded on what side effect means
10:23:29 <ski> monads make effects explicit in the return type
10:23:33 <quicksilver> also, I'd note that IO is by no means the only monad
10:23:44 <quicksilver> (but it may be the only one you need to use to "get by as a hobby programmer")
10:23:44 <dons> http://programming.reddit.com/info/5zmal/comments/
10:23:45 <lambdabot> Title: programming: Partial Vectorisation of Haskell Programs: implicit parallelism is  ...
10:23:48 <quicksilver> at least to start with.
10:24:07 <ski> > do x <- [0,1,2]; y <- [100,200]; return (x+y)  -- the list monad
10:24:09 <lambdabot>  [100,200,101,201,102,202]
10:24:48 <mux> quicksilver: do you think that would be useful to have in the base libs? (cf my hpaste)
10:24:54 <vali> quicksilver: okay. i have read some basic tutorials, but i find it hard to really get started. i guess i should just start trying to write something and bang my head against the wall as i go along... not sure what that "something" should be though
10:26:43 <bakert> quicksilver: can i use list comprehensions to break apart a data type though.  Like data X = Y String | Z
10:26:46 <ski> vali : you could try defining `putStrLn',`getLine', "guess the number" game in IO, to get started
10:27:00 <ski> bakert : break apart, how ?
10:27:11 <vali> ski: to make my own putStrLn?
10:27:14 <mux> bakert: no, for that use an unfold function
10:27:22 <bakert> ok.  back to "case" :)
10:27:23 <ski> > [x | Just x <- [Nothing,Just 4,Just 5,Nothing,Just 0]]
10:27:25 <lambdabot>  [4,5,0]
10:27:35 <bakert> ooh
10:27:44 <mux> er, yeah.
10:27:53 <bakert> that might work?
10:27:58 <ski> vali : if you don't see directly how to do it (in terms of `putChar' and `getChar', i mean), it can be useful
10:28:12 <bakert> how do i do a data declaration in ghci?  i want to try it out!
10:28:13 <bakert> :)
10:28:19 <ski> bakert : you don't
10:28:21 <vali> ski: aah. maybe i will give it a try
10:28:26 <bakert> ski: :(
10:29:35 <ski> ghci is only for evaluating expressions, performing IO actions, (and binding previouses to names), as far as for language features
10:29:45 <bakert> that's a shame
10:30:27 <ricky_clarkson> Why is it limited?
10:30:31 <ski> it could be nice to allow defining datatypes,classes,instances in ghci, yes
10:31:25 <ski> ricky_clarkson : one reason is that because of the mutually-recursive nature of definitions in haskell, it's hard to give one part first and another (which the first possibly depends on) later
10:32:02 <ski> ricky_clarkson : however, in ghci you actually can define mutually recursive functions, if you do it at the same time
10:32:05 <ricky_clarkson> That could be solved by somehow delimiting a block of declarations.
10:32:44 <ricky_clarkson> E.g., Scala's interpreter lets you define a whole class at once.
10:33:04 <faxathisia> you can delimit a block of declarations by putting them in a file
10:33:24 <ski> i suppose another way would be to allow using undefined identifiers, and remember which things depend on them and when they're defined
10:37:49 <ski> (e.g. istr when the ocaml interactive toplevel makes a value monomorphic (because of value restriction), it makes the actual monomorphic type to pplug into the type variable undetermined until first use which determines it)
10:40:47 <dons> http://programming.reddit.com/info/5zmal/details :) for those looking for something to get excited by, -fvectorise in ghc
10:40:48 <lambdabot> Title: programming: Partial Vectorisation of Haskell Programs: implicit parallelism is  ...
10:42:43 <bakert> Can I make a type like this:
10:42:51 <bakert> data A = X String | Y String | Z
10:42:56 <bakert> data B = A Integer
10:42:57 <bakert> ???
10:43:02 <dons> sure
10:43:06 <bakert> i thought so.
10:43:12 <bakert> but i seem to be getting errors
10:43:14 <mrd> dons: cool
10:43:17 <bakert> must have done something dumb
10:44:32 <ski> maybe you were thinking the `A' (a data constructor for `B') in the `data B = ...' had anything to do with the previous `A' (a type constructor) ?
10:44:48 <bakert> ah
10:44:49 <bakert> yes
10:44:50 <mrd> dons: ndp is now in head?
10:44:53 <bakert> that is what i am doing
10:45:05 <ski> bakert : so maybe you intended `data B = B A Integer' ?
10:45:09 <bakert> I see!  yes
10:45:10 <bakert> doh
10:45:11 <bakert> thanks
10:45:28 <bakert> is there anyway to skip having the new constructor?
10:45:42 <ski> (bakert : or `data B = MkB A Integer', or any other name you like)
10:46:04 <ski> bakert : well, you can use `type B = (A,Integer)', though then that is not a new type
10:46:17 <ski> bakert : otherwise, no
10:46:26 <bakert> i see.  it does kind of make sense as a pair
10:46:40 <bakert> so maybe i will do that
10:46:43 <bakert> thanks
10:46:49 <ski> yw
10:46:51 <ivanm> @doc Data.Array.IArray
10:46:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
10:47:48 <bakert> Actually, what I am going to do is store A -> Integer in a Data.Map
10:48:04 <bakert> but i need to somehow then fit that into a list comprehension
10:48:07 <bakert> :s
10:48:55 <bakert> i guess i can use toList on the Map
10:49:02 <bakert> inside the comprehension
10:49:53 <mux> what for?
10:50:08 <bakert> to get that magic "ignore things that don't match" power of the list comprehension
10:50:35 <mrd> filter?
10:50:46 <bakert> no it's better than that
10:50:47 <mux> yes, there is filter for maps
10:50:48 <mrd> guard?
10:50:54 <bakert> it's like filter with pattern matching
10:50:55 <mux> and you can have an ADT unfold :)
10:51:00 <bakert> hang on ... example ...
10:51:05 <mux> what are you pattern matching against?
10:51:28 <bakert> > [x | Just x <- [Nothing,Just 4,Just 5,Nothing,Just 0]]
10:51:30 <lambdabot>  [4,5,0]
10:51:50 <mux> yeah I got what you want to do
10:51:57 <bakert> so if just after the pipe i have a moderately complex pattern that is a very neat way to pack it in
10:51:59 <mux> but what are you pattern matching against?
10:52:21 <bakert> it's this data type i've been banging on about ... data A = X String | Y String | Z
10:52:29 <bakert> and they are the keys in a Data.Map
10:52:38 <mux> you really don't want to have an unfoldA ?
10:52:46 <mux> it would be very convenient :-P
10:52:56 <mux> and then you can use filter
10:53:06 <bakert> and i want to know if in this map if there is a value of 7 or higher with a key which is X _ but not X "monkey"
10:53:08 <bakert> :)
10:53:13 <mux> you know, list comprehensions end up being rewritten to filters and concatMaps
10:53:16 <bakert> mux: what is an unfoldA?
10:53:36 <bakert> in my mind (currently) it looks a bit like this:
10:53:37 <mux> bakert: something that abstracts that "case" over your adt
10:53:40 <mux> its type would be :
10:54:04 <mux> unfoldA :: (String -> a) -> (String -> a) -> a -> A -> a
10:54:13 <bakert> but that means more function definitions
10:54:35 <bakert> my vague and untrustworthy intuition is that the list comprehension version is going to be "shorter"
10:54:35 <mux> it's written very easily, it's automatic
10:54:42 <mux> and then you can express nice filters
10:54:44 <bakert> i am completely prepared to be wrong :)
10:54:59 <mux> such as when it's an X with the string being "foo" or when it's a Z like this :
10:55:14 <mux> filter (unfoldA (== "foo") (const False) True)
10:55:56 <bakert> but then i have to go through another round of filtering to find the values over 7 right?
10:56:05 <mux> eh?
10:56:11 <bakert> whereas with the list comprehension i can just tack ", x > 7" on the end?
10:56:12 <oerjan> bakert: you might use mapMaybe or mapMaybeWithKey, and use a do expression over the Maybe monad instead
10:56:21 <bakert> oerjan: :s
10:56:28 <mux> if you have a number in your ADT
10:56:33 <bakert> no
10:56:35 <mux> you can pass a condition to the unfold function
10:56:41 <mux> what is x then?
10:56:45 <bakert> um well yes
10:56:46 <bakert> :)
10:56:51 <bakert> i mean that there is the ADT
10:56:59 <bakert> which is representing the abstract thing
10:57:02 <mux> having unfold functions to case over an ADT is very convenient, and you can still combine that with the list comprehensions
10:57:10 <bakert> and then it will have a value in a particualr case
10:57:20 <bakert> probably/possibly through a Data.Map
10:57:33 <sclv> bakert: there is filterWithKey too
10:57:34 <bakert> these things actually represents skills
10:57:37 <bakert> so
10:57:49 <bakert> Skill = Weapon String | Read String | Horsemanship | FirstAid
10:57:57 <bakert> And I want to say ...
10:58:15 <bakert> "have you got a skill in a weapon that is not "Sword" with a value of 7 or higher"
10:58:21 <bakert> in the neatest way possible.
10:58:38 <bakert> as well as "do you have any skill except Horsemanship and Read "Latin" at level 10 or above"
10:58:46 <mux> that makes no sense
10:58:47 <oerjan> mapMaybeWithKey (\k v -> do guard (v>=7); X m <- return k; guard (m/="monkey"); return v)
10:58:49 <bakert> and "what is your Weapon "Sword"" skill level
10:58:53 <mux> this is a sum, not a product type
10:58:59 <mux> your definition means
10:59:19 <mux> Skill is *either* Weapon with a string or Read with a string etc
10:59:25 <bakert> yes
10:59:28 <bakert> that's right!
10:59:32 <mux> so what value are you talking about?
10:59:36 <bakert> and then in a Map or whatever we store the values
10:59:46 <bakert> so there's maybe another type like:
10:59:47 <mux> you changed x by "value" but you're still not telling where does this comes from
10:59:54 <sclv> bakert: why a map!?
10:59:55 <bakert> SkillInstance = SkillInstance Skill Integer
10:59:58 <bakert> or we have a map
11:00:06 <bakert> sclv: really no reason other than it has a lot of nice functions
11:00:14 <bakert> could be a list of pairs
11:00:15 <mux> ok
11:00:17 <bakert> or anything really
11:00:24 <lament> are we writing a haskell mmorpg?
11:00:28 <sclv> bakert: I think you want a set.
11:00:38 <bakert> lament: if only it were that good !
11:01:01 <mux> bakert: better push that level number into the Skill type itself
11:01:11 <bakert> it's a Pendragon pen and paper character generator.  with possible thoughts of a web-based game in the far future but really just to have a well defined problem to learn more haskell with.
11:01:15 <mux> and then you can haev uber-convenient unfold functions, still :-P
11:01:18 <bakert> mux: yes i could do that
11:01:25 <sclv> I guess you could have a map on Skill as key, if you derive Ord...
11:01:30 <bakert> do i have to write "Integer" after every wkill?
11:01:35 <bakert> s/wkill/skill/g
11:01:39 <bakert> there are a lot :)
11:01:41 <mux> I'm repeating myself, but it seems quite clean that in those cases they are extremely convenient
11:01:49 <mux> clear
11:01:56 <bakert> so
11:02:06 <mux> so you have a list of pairs of skills and levels
11:02:17 <bakert> data Skill = Weapon String Integer | Read String Integer | Horsemanship Integer | FirstAid Integer
11:02:21 <mux> and you want to select a skill that isn't sword
11:02:21 <bakert> seems a bit longwinded
11:02:29 <mux> and has a level > 7, that gives :
11:02:39 <bakert> mux: right - a Weapon skill that isn't sword with value > 7.
11:02:51 <bakert> (or in some cases, any skill)
11:03:09 <mux> filter (\(s,l) -> unfoldSkill (/= "Sword") (const True) True s && l >= 7)
11:03:10 <bakert> (or in some cases, a skil that is not sword or horsemanship or blah or foo)
11:03:14 <sclv> bakert: SkillInstance still makes sense. don't fold the integer into the skill type, because it's harder to polymorphically query that way
11:03:15 <mux> I _mean_ it
11:03:20 <mux> you want an unfold stuff
11:03:31 <bakert> sclv: glad to hear it :)
11:03:41 <mux> sclv: yes
11:03:45 <bakert> mux: ok!  i will try the unfold thing
11:03:46 <mux> bakert: seeN
11:03:47 <mux> ?
11:03:47 <bakert> :)
11:04:02 <mux> it's just a case
11:04:11 <bakert> should i store these as a Map or as a list of pairs, or doesn't it matter?
11:04:15 <mux> that applies the correct function to the value you have
11:04:21 <bakert> seeN?
11:04:24 <bakert> :t seeN
11:04:25 <mux> a list of pairs is fine as a start
11:04:26 <lambdabot> Not in scope: `seeN'
11:04:30 <mux> sorry, that was just a typo :)
11:04:33 <bakert> oh!
11:04:34 <bakert> :)
11:04:35 <oerjan> (do Weapon "Sword" <- Just s; Nothing) `mplus` True
11:04:44 <mux> if it's a problem with performance, you can change to something else later
11:04:45 <bakert> :t mplus
11:04:46 <oerjan> er wait
11:04:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
11:04:59 <bakert> there won't be a performance problem.  this is all very dinky.
11:05:01 <oerjan> doesn't work that way
11:05:43 <mux> type Level = Int, and a list [(Skill,Level)] doesn't strike me as odd :)
11:05:45 <mux> it's rather nice.
11:06:46 <oerjan> :t isNothing
11:06:47 <lambdabot> forall a. Maybe a -> Bool
11:07:13 <sclv> speaking of which, if its a small list, and its mainly being fully traversed, then using a set as opposed to a list doesn't make a big difference and he might as well just go with the straight list comprehension.
11:08:29 <fons> hi
11:08:53 <kaol> @users
11:08:53 <lambdabot> Maximum users seen in #haskell: 424, currently: 378 (89.2%), active: 17 (4.5%)
11:09:42 <Lucas82> hey all
11:10:06 <faxathisia> hello fons, Lucas82
11:10:20 <Lucas82> cool, you all Haskell knowers?
11:10:27 <faxathisia> not really :p
11:10:28 <faxathisia> Trying..
11:10:36 <faxathisia> I think that almost everyone here is an expert though
11:10:38 <Lucas82> hehe cool! I just started lering it
11:10:51 <Lucas82> It is such a cool lang
11:10:59 * faxathisia *agrees*
11:11:06 <dons> great!
11:11:21 <Lucas82> :p well anyway I have a few Qs.. so if anyone has a few mins?
11:11:35 <faxathisia> just ask away
11:11:43 <oerjan> well i just missed my bus anyway :)
11:11:50 <dons> Lucas82: just ask away
11:12:31 <Lucas82> ok hang on!:D
11:14:49 <Lucas82> you know about quickcheck?
11:15:15 <conal> yep
11:15:20 <Lucas82> cool ok then..
11:15:20 <mux> @check \s -> reverse (reverse s) == True :: String -> Bool
11:15:26 <mux> err
11:15:28 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
11:15:34 <mux> @check \s -> reverse (reverse s) == s :: String -> Bool
11:15:34 <lambdabot>  Couldn't match expected type `String -> Bool'
11:15:49 <faxathisia> @check 1 == 2
11:15:50 <lambdabot>  Falsifiable, after 0 tests:
11:15:50 <mux> @check (\s -> reverse (reverse s) == s) :: String -> Bool
11:15:52 <lambdabot>  OK, passed 500 tests.
11:16:13 <Lucas82> hehe 100...
11:16:17 <oerjan> @check 2+2 == 4
11:16:19 <lambdabot>  OK, passed 500 tests.
11:16:20 <conal> @check \s -> reverse (reverse s) == (s :: String)
11:16:21 <lambdabot>  OK, passed 500 tests.
11:16:35 <mux> @check (\x -> x^2 == x * x) :: Int -> Bool
11:16:36 <lambdabot>  OK, passed 500 tests.
11:16:40 <conal> @check \ s :: String -> reverse (reverse s) == s
11:16:40 <lambdabot>  Parse error at "::" (column 5)
11:16:46 <conal> @check \ (s :: String) -> reverse (reverse s) == s
11:16:47 <lambdabot>  Parse error in pattern at "->" (column 17)
11:16:55 <oerjan> conal: not H98
11:17:07 <faxathisia> @check (\n -> sum [1..n] == (n)*(n+1) `div` 2)
11:17:08 <lambdabot>  Add a type signature
11:17:10 <mux> @scheck (\x -> x^2 > 0) :: Int -> Bool
11:17:11 <Lucas82> so if I  have a module that is a pack of playing cards
11:17:12 <lambdabot>   Failed test no. 1. Test values follow.: 0
11:17:14 <conal> oerjan: thx
11:17:17 <faxathisia> @check (\n -> sum [1..n] == (n)*(n+1) `div` 2) :: Int -> Int
11:17:18 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
11:17:23 <faxathisia> @check (\n -> sum [1..n] == (n)*(n+1) `div` 2) :: Int -> Bool
11:17:24 <lambdabot>  Falsifiable, after 2 tests: -4
11:17:28 <vinse> any recommendations for eclipse plugins for haskell? i found a couple projects put they dont seem active
11:17:30 <faxathisia> *grr*
11:17:30 <mux> @scheck (\x -> x > 0 ==>  x^2 > 0) :: Int -> Bool
11:17:31 <lambdabot> Couldn't match expected type `Bool'
11:17:38 <conal> go on, Lucas82
11:17:40 <faxathisia> @check (\n -> x > 0 ==> sum [1..n] == (n)*(n+1) `div` 2) :: Int -> Bool
11:17:41 <lambdabot>   Not in scope: `x'
11:17:45 <Lucas82> can I pm you?
11:17:45 <faxathisia> @check (\n -> n > 0 ==> sum [1..n] == (n)*(n+1) `div` 2) :: Int -> Bool
11:17:46 <lambdabot>  Couldn't match expected type `Bool'
11:17:58 <mux> @scheck (\x -> x > 0 ==>  x^2 > 0) :: Int -> Bool
11:17:59 <lambdabot> Couldn't match expected type `Bool'
11:18:14 <conal> Lucas82: you'd get better results if you asked publicly.
11:18:19 <Lucas82> ok ..
11:18:21 <mux> :t (==>)
11:18:22 <lambdabot> Not in scope: `==>'
11:18:25 <conal> i'm fairly new to quickcheck
11:18:28 <conal> but loving it
11:18:35 <oerjan> :t (Test.QuickCheck.==>)
11:18:37 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
11:18:52 <faxathisia> > sum [1..-5]
11:18:53 <lambdabot>   Not in scope: `..-'
11:18:56 <Lucas82> so what I want to do, is add a Card to a Hand
11:18:59 <mux> @scheck \(x :: Int) -> x > 0 ==> x^2 > 0
11:18:59 <lambdabot>  Parse error in pattern at "->" (column 13)
11:18:59 <faxathisia> > sum [1..(-5)]
11:19:00 <lambdabot>  0
11:19:04 <thetallguy> conal: yes, it's a wonderful feeling to have a test suite, especially with quickcheck
11:19:25 <mux> @scheck \x -> (x :: Int) > 0 ==> x^2 > 0
11:19:26 <lambdabot>   Completed 13 test(s) without failure.  But 7 did not meet ==> condition.
11:19:30 <conal> i'm addicted to QC.  i blame dons for his inspiring endorsements.
11:19:36 <thetallguy> conal: one begins to get a sense that on's code is truly reliable
11:19:38 <mux> @check \x -> (x :: Int) > 0 ==> x^2 > 0
11:19:39 <lambdabot>  OK, passed 500 tests.
11:19:44 <mux> @check \x -> (x :: Complex) > 0 ==> x^2 > 0
11:19:45 <lambdabot>      `Complex' is not applied to enough type arguments     Expected kind `?',...
11:19:52 <mux> @check \x -> (x :: Complex Int) > 0 ==> x^2 > 0
11:19:53 <lambdabot>        add an instance declaration for (Arbitrary (Complex Int))     In the e...
11:19:58 <Lucas82> hmm
11:20:09 <mux> damn, I expected QC to have arbitrary instances for Complex types
11:20:11 <thetallguy> conal: yes, I think dons should take his fair share of the blame
11:20:15 <Lucas82> think this a bit of a hard Q.. I wil think about it for a bit
11:20:39 <thetallguy> I was using qc before xmonad, but not as religiously
11:21:01 <Lucas82> I am making a programme for a card game anyway
11:21:12 <conal> i'd like for all libs to ship with Arbitrary instances, even though it means an extra lib dependency.
11:21:29 <conal> Lucas82: go on.  there's a lot going on here, but i'm tracking, and maybe some others are also.
11:21:56 <Lucas82> ok
11:22:09 <doserj> conal: you might want to have different Arbitrary instances, though, to get different distributions
11:23:41 <conal> doserj: oh.  so you'd like the freedom not to get a standard one?
11:23:52 <thetallguy> I need a better IM client, one that would show me Lucas82 messages in summary
11:23:52 <conal> so you can define your own
11:23:54 <Lucas82> what does this data type def acually mean: data Card = Card { rank :: Rank, suit :: Suit }  that a Card must have a rank and suit?
11:23:56 <oerjan> mux: that's only part of your problem, Complex requires a RealFloat argument, and is not ordered
11:24:08 <conal> Lucas82: yes
11:24:19 <Lucas82> and what is Suit ... and suit?
11:24:25 <Lucas82> upper lower case..
11:24:31 <conal> type and accessor function, respectively.
11:24:35 <thetallguy> Suit must be defined elswhere
11:24:48 <Lucas82> so a Suit is another type?
11:24:50 <thetallguy> yes
11:24:51 <conal> type names are capitalized (except type variables).
11:25:05 <Lucas82> ok.. so why rank :: Rank?
11:25:06 <thetallguy> Look around, you will probably find something like
11:25:25 <thetallguy> data Suit = Spades | Hearts | Diamonds | Clubs
11:25:26 <Lucas82> is rank a function somewhere .. or
11:25:33 <bakert> mux: ok.  unfoldSkill ::  (String -> a) -> (String -> a) -> a -> Skill -> a
11:25:39 <bakert> but how do i write it? :)
11:25:40 <Lucas82> yes I get that.. thanks
11:25:50 <conal> Lucas82: that data def *defines* rank & suit
11:26:01 <conal> as accessor functions for the Card data structure
11:26:09 <abell> Lucas82, rank gets defined on that line, as the accessor to the Rank-typed field of a Card
11:26:27 <abell> It's a shorthand
11:26:31 <bakert> hey roconnor man have i got a good question for you :)
11:26:32 <Lucas82> ok cause underneath I have an instance with rank <- arbitrary
11:26:47 <oerjan> bakert: with a pattern match
11:27:16 <oerjan> unfoldSkill f _ _ (Weapon w) = f w, etc.
11:27:20 <Lucas82> AH hang on I get it now
11:27:34 <conal> Lucas82: yeah -- that'd be a bit confusing.  another variable also named "rank", but of type Rank, rather than Card -> Rank.  it "shadows" the accessor.
11:27:37 <faxathisia> How do I define an integer type which takes values 0-4294967295 (32 bit) and has + - etc ops modulo 4294967295?
11:27:42 <bakert> oerjan: aha!  thanks.  what is the second function for?
11:27:55 <bakert> and in fact the "a" variable too
11:28:23 <oerjan> bakert: the a variable is the result type of the case statement you are converting
11:28:41 <Lucas82> yes ok cool .. so when I get to : data Rank = Numeric Integer | Jack | Queen | King | Ace  ... My problem is defing ACE.. cause ACE has a value either 1 or 11
11:28:47 <oerjan> one function per constructor, taking as many arguments as the constructor
11:29:28 <hpaste>  thetallguy pasted "Lucas82 Card" at http://hpaste.org/3582
11:29:38 <oerjan> bakert: look at maybe and either which do this for the Maybe and Either types
11:29:42 <oerjan> @src maybe
11:29:43 <lambdabot> maybe n _ Nothing  = n
11:29:43 <lambdabot> maybe _ f (Just x) = f x
11:29:48 <Lucas82> cool thnks
11:29:51 <roconnor> bakert: ok
11:30:07 <thetallguy> Lucas82: the ghci session shows the type definitions of rank and suit
11:30:15 <thetallguy> in the hpaste link above
11:31:05 <bakert> roconnor: you know we represented PassionMeasure as higher order function thingy the other day?  is there any way to get a list of them out of that function thing?
11:31:28 <roconnor> faxathisia: newtype Mod4294967295 = Mod4294967295 Integer
11:31:41 <roconnor> faxathisia: then make it an instance of Num
11:32:01 <oerjan> faxathisia: are you sure you don't mean mod 4294967296? in which case Data.Word.Word32 may already do what you want
11:32:01 <roconnor> bakert: a list of what?
11:32:03 <faxathisia> alright, thank you
11:32:09 <faxathisia> oh
11:32:15 <Lucas82> AH .. hmmmmmmmmmm
11:32:21 <roconnor> > 2^32
11:32:23 <lambdabot>  4294967296
11:32:32 <faxathisia> > [1..] :: [Data.Word.Word32]
11:32:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:32:34 <roconnor> > maxBound :: Word 32
11:32:35 <lambdabot>  Parse error at "32" (column 18)
11:32:43 <roconnor> > maxBound :: Word32
11:32:44 <bakert> roconnor: the passions that the character has.  everything with a value > 0.  i guess we would need to query for every possible passion?
11:32:44 <lambdabot>  4294967295
11:32:45 <faxathisia> > last ([1..] :: [Data.Word.Word32])
11:32:49 <lambdabot> Terminated
11:32:51 <Lucas82> ok so how would I define the typ for a function that returns the whole pack of cards..?  Card -> Hand ?
11:32:55 <roconnor> faxathisia: sorry, I'm dumb
11:33:20 <faxathisia> > (4294967295 :: Data.Word.Word32) + (5 :: Data.Word.Word32)
11:33:22 <lambdabot>  4
11:33:24 <faxathisia> :D
11:33:26 <conal> Lucas82: how about [Card]
11:33:28 <faxathisia> great
11:33:31 <roconnor> bakert: we will have to switch to using Data.Map
11:33:38 <Lucas82> AH.. yes
11:33:41 <faxathisia> roconnor: Thank you!
11:33:45 <Lucas82> true..
11:33:49 <faxathisia> oerjan: Thanks
11:33:53 <oerjan> :)
11:33:53 <faxathisia> this is great
11:34:11 <Lucas82> [Card] -> Hand .. ?
11:34:26 <Lucas82> cause I don't wan to write them all down.. I want to make a fuction..
11:34:40 <ski> Lucas82 : taking Functional Programming at Chalmers/GU ?
11:34:46 <Lucas82> hehe:) yup
11:34:59 <Lucas82> and its really confusing
11:35:02 <thetallguy> conal was suggesting  type Hand = [Card]
11:35:15 <Lucas82> hmmmm let me think about that
11:35:21 <jorik808> lolz
11:35:32 <thetallguy> Hand is effectively an alias for [Card]
11:35:37 <thetallguy> but perhaps easier to read
11:36:20 <conal> yes, and writing an algorithmic definition (not listing) for a list of all cards in a deck.  (not sure if you want a hand or a deck.)
11:36:32 <bakert> roconnor: :(  i'm in the middle of some other #haskell-inspired rewriting (as it always goes for me on here - eventually my whole program will be one line of code with at least two "flip"s in it - as per usual).  but i may annoy you later with Data.Map questions.
11:36:43 <roconnor> ok
11:36:49 <bakert> thanks :)
11:36:51 <faxathisia> lol
11:36:53 <thetallguy> Howdy stepcut, you're everywhere today
11:36:54 <Lucas82> ski : you talked to students from here before?
11:37:07 <ski> Lucas82 : i've taken that course :)
11:37:26 <Lucas82> ah cool:)
11:37:42 <Lucas82> you had the blackjack too then huh
11:37:52 <ski> Lucas82 : you want to compute a list of all possible cards ?
11:38:19 <faxathisia> @index Data.Word.Word32
11:38:20 <lambdabot> bzzt
11:38:20 <Lucas82> ski : yes
11:38:24 <faxathisia> >:|
11:38:38 <ski> and you don't want to enumerate them all by hand
11:38:43 <Lucas82> having defined the types needed
11:38:48 <ski> s/by hand/manually/
11:38:59 <Lucas82> hmm
11:39:10 <Lucas82> what do you mean?
11:39:22 <conal> i keep wanting conjunctive quickcheck properties (not just boolean conjunction).  is it possible to define in QC1?  does it work in QC2, and does QC2 work reasonably well?
11:39:41 <Lucas82> return a hand which is a fulldeck of 52 cards
11:39:50 <Lucas82> in a [Card]
11:39:59 <roconnor> @hoogle property
11:40:00 <lambdabot> Test.QuickCheck.property :: Testable a => a -> Property
11:40:00 <lambdabot> Test.QuickCheck.Property :: data Property
11:40:11 <roconnor> @hoogle Property -> Property -> Property
11:40:11 <lambdabot> No matches, try a more general search
11:40:15 <roconnor> :(
11:40:23 <thetallguy> conal: every time I ask/search for QC2 i can't find it
11:40:35 <ski> Lucas82 : well, each card is determined fully by a rank and a suit .. and all combinations are allowed
11:40:48 <thetallguy> conal: can you give an example of what you want?
11:41:06 <ski> Lucas82 : so maybe the problem would be simpler if you already had a list of all possibly ranks, as well as a list of all possible suit ?
11:41:24 <conal> thetallguy: i have a type represented by an interval and a function.  i want to test two such things for equality.
11:41:24 <Lucas82> hmmm
11:41:30 <Lucas82> and map them?
11:41:39 <conal> for function equality, i use forAll, which gives a property.
11:41:58 <ski> `map' would work .. list comprehensions, too .. also direct recursion would work
11:42:25 <Lucas82> (x:xs) (y:ys) ? I suppoese..
11:42:50 <ski> in the last case, yes
11:42:53 <conal> thetallguy: QC2: http://code.haskell.org/QuickCheck
11:42:54 <lambdabot> Title: Index of /QuickCheck
11:43:23 <conal> does anyone use QC2?  dons?
11:43:33 <Lucas82> and the null point.. hmm?
11:43:37 <thetallguy> > [(a,b) | a <- [1..4],b<-[1..13]]
11:43:42 <Lucas82> [] [] = []?
11:43:46 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
11:44:20 <faxathisia> > [(a,b) | a <- [1..b], b<-[1..13]]
11:44:21 <lambdabot>   Not in scope: `b'
11:44:22 <thetallguy> conal: thanks
11:44:23 <faxathisia> >:|
11:44:36 <ski> Lucas82 : are you thinking of a function taking two lists and returning a list of pairs of all possible combinations (usually called "cartesian product") ?
11:45:06 <thetallguy> conal: what's the property that you wish to test?
11:45:10 <Lemmih> @seen Igloo
11:45:11 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 3h 56m 59s ago.
11:45:11 <Lucas82> no
11:45:18 <Lucas82> hmm
11:45:31 <sclv> lucas -- you should derive ord and enum, it'll be handy probably.
11:45:36 <jorik808> what's the best way to interface with c code ? so far i've found greencard and C->Haskell
11:45:43 <shapr> Does anyone know just how close ghc 6.8 is to release?
11:46:00 <ski> Lucas82 : well, i think you would do well to have some kind of plan of solving the problem .. do yuo have one ?
11:46:01 <Lucas82> 1 rank for every card wich is a certain suit , then when thats exceede, next suit..
11:46:06 <thetallguy> f1 == f2 ==> (T r f1) == (T r f2)?
11:46:32 <thetallguy> shapr: tsurely the Usenet Oracle does
11:46:36 <ski> Lucas82 : you're thinking too lowlevel
11:46:49 <Lucas82> mm ok
11:47:06 <conal> thetallguy: e.g., properties on motions in an infinite spatial zipper (or its function model), such as prev.next == id.
11:47:09 <Lucas82> I just can't seem to wrap my head around it
11:47:12 * shapr throws a printout of three days worth of alt.binaries.* at thetallguy 
11:47:37 <ski> Lucas82 : simply "for each suit, for each rank, make a card for suit & rank" works, no ?
11:47:41 <shapr> Not that I could actually lift that much cellulose...
11:47:57 <ski> Lucas82 : have you played with `map' or list comphrehensions, yet ?
11:48:04 <sclv> @faq can haskell 6.8 be ready for release today?
11:48:05 <lambdabot> The answer is: Yes! Haskell can do that.
11:48:05 <Lucas82> function (Add card suit rank)
11:48:13 * thetallguy thanks shapr for all the great binaries
11:48:44 <shapr> thetallguy: hah, you just have to scan them in and uudecode them..
11:49:04 <thetallguy> shapr: and merge all those splits
11:49:32 <thetallguy> shapr: one handed
11:49:34 <shapr> That too
11:49:40 * shapr laughs
11:50:03 <shapr> Was that a 4chan reference?
11:50:13 <shapr> aaanyway
11:50:50 <thetallguy> shapr: there was a program that did all that, which advertised that the key bindings were designed so it could be operated with one hand.
11:50:59 <thetallguy> shapr: not sure about the name
11:51:05 <thetallguy> stepcut may remember
11:51:10 <thetallguy> he was the one who told me
11:51:54 <bakert> mux: i think the problem with unfoldSkill is that there are about 30 skills.  would that imply 32 arguments to the unfoldSkill function?
11:51:55 <thetallguy> conal: I'm still unclear here
11:52:27 <mux> bakert: yes, it ain't so great if there are too much branches :-)
11:52:28 <ski> Lucas82 : have you defined `(<+)' yet, then ?
11:52:33 <thetallguy> conal: it looks like you wish to test functions whose domain is this Range Fucnction type?
11:52:34 <bakert> mux: :(
11:52:54 <bakert> perhaps i can still do my list comprehension thing
11:53:06 <sclv> bakert: instead of having each skill as a constructor, why don't you have Skill as a seperate data enum, then a record with Skill, Level, and an optional String -- you can handle the whole thing with accessors.
11:53:29 <mux> yes
11:53:32 <shapr> thetallguy: That's scary and unsurprising.
11:53:33 <mux> sounds good
11:53:36 <bakert> sclv: that sounds nice.  how do i do an optional string?
11:53:43 <ski> Maybe
11:53:45 <mux> bakert: Maybe String
11:53:54 <bakert> ok let me try that
11:53:56 <bakert> thanks
11:54:15 <pastorn> i need a good tutorial to datatypes for someone who knows their basic java stuff )
11:54:58 <pastorn> --> the person in question can code, not just advanced stuff, which is what we are supposed to learn in this course, hash maps n stuffs
11:55:04 <bakert> pastorn: there's various types stuff in http://www.haskell.org/~pairwise/intro/intro.html
11:55:05 <lambdabot> Title: Haskell for C Programmers
11:55:07 <Lucas82> ski : yes I have
11:55:08 <conal> thetallguy: i don't know how to give enough context.  i'm working with infinite things -- functions, streams, trees.  so my equality tests use random sampling.  when i want two such tests, say because a structure has two infinite things in it, i don't know how to express the property as a single Property.
11:55:10 * thetallguy agrees with shapr
11:55:21 <Lucas82> (<+) :: Hand -> Hand -> Hand
11:55:25 <pastorn> bakert: thanks :)
11:55:31 <bakert> np
11:55:35 <thetallguy> conal: much clearer, thanks
11:55:49 <pastorn> Lucas82: why are you doing your labs in here?
11:55:55 * pastorn is EVERYWHERE!
11:56:17 <Lucas82> I am just asking for guidelines
11:56:27 * thetallguy ponders whether pastorn `elem` anagram "savoir faire"
11:56:54 <conal> thetallguy: oh :) .  part of the problem is that Property is abstract.  i think i could define Property conjunction easily -- if i had access to the representation.
11:57:05 <ski> Lucas82 : can you state, in a short highlevel way, what `fullDeck' should do/compute ?
11:57:48 <thetallguy> conal: it seems to me I saw something like what you wanted
11:58:18 <bakert> sclv: when you say accessors you mean functions that go through the list of Skill-Maybe String-Integer and fish out the value?
11:58:21 <conal> Lucas82: Haskell programming is more like clear/precise description than it is like C programming.  so ski's question will lead you to a Haskell program.
11:58:22 <ski> Lucas82 : actually, if you can't, i see there's a hint in the lab pm :)
11:58:39 <thetallguy> conal: I don't understand property conjunction w/o bool
11:58:54 <conal> thetallguy: if you run across it, please shoot me a note.
11:59:45 <thetallguy> conal:prop_Insert2 x = forAll orderedList $ \xs -> ordered (insert x xs)   where types = x::Int
12:00:09 <sclv> bakert: do you know record notation?
12:00:13 <bakert> yes
12:00:15 <thetallguy> conal: I was puzzling about that construct yesterday
12:00:24 <sclv> that's all I meant -- the autogenerated functions
12:01:02 <bakert> sclv: hmm.  that's problematic because there are a lot of weapons in the world :)
12:01:23 <bakert> so do i enumerate them all in the record definition?
12:01:28 <bakert> not really possible
12:01:40 <sclv> bakert: just let them be a string?
12:01:49 <ski> Lucas82 : that's a type signature .. i was after a description of what should be computed, e.g. in english or swedish
12:01:51 <conal> thetallguy: over the forAll?  the "types = .."?
12:02:09 <bakert> sclv: that would be good.  but how do i then put that into a record definition?
12:02:20 <sclv> filter (\x-> skill x == Weapon && subSkill x = Just "Polearm")
12:02:22 <bakert> data Skills = Skills { ... }
12:02:25 <ski> (Lucas82 : also, it's not the type signature that the lab pm says you should have .. i suggest reading more carefully)
12:02:37 <Lucas82> yups ok
12:02:38 <thetallguy> conal: over the apparent n**2 behavior
12:03:01 <sclv> data SkillItem = {skill:: Skill, subSkill:: Maybe String, Level :: Int}
12:03:22 <bakert> sclv: oh i see .. not for the list of skills but for EACH skill!  doh.
12:03:33 <thetallguy> conal:  I think I misunderstood it.
12:04:13 <thetallguy> conal: I'll think some more.  I still don't think I can formulate your problem correctly.
12:04:29 <bakert> haskell is so weird.  you just monkey around with types until the program writes itself.
12:05:15 <conal> thetallguy: thanks.  for now i'm going to make a new Property type that is just like the current one but let's me get to its rep, so i can define conjunction.
12:05:29 <thetallguy> Send me the results
12:05:34 <conal> sure
12:05:43 <pjd> @remember bakert haskell is so weird.  you just monkey around with types until the program writes itself.
12:05:43 <lambdabot> It is forever etched in my memory.
12:06:13 <ski> @djinn Either a (b,c) -> (Either a b,Either a c)
12:06:14 <lambdabot> f a =
12:06:14 <lambdabot>     case a of
12:06:14 <lambdabot>     Left b -> (Left b, Left b)
12:06:14 <lambdabot>     Right (c, d) -> (Right c, Right d)
12:06:36 <ski> ^ program writes itself, given type !
12:07:33 <ski> Lucas82 : any progress ?
12:07:37 <Lucas82> but if a hand is empty | Add Card Hand how can it be just a Hand.. a list of all the cards..
12:07:38 <thetallguy> conal: you know you can test over binary functions, right?
12:08:09 <conal> thetallguy: hm?
12:08:21 <ski> Lucas82 : a hand is defined to either be empty, or a card added to a(nother) hand
12:08:49 <Lucas82> yes I know that.. but how can it therefore list the whole pack.. it always wants another card
12:08:52 <thetallguy> conal: Let me see if I can reproduce that and then see if that's what you want
12:09:08 <Lucas82> or the hand is empty
12:09:25 <conal> thetallguy: ok
12:09:50 <Excedrin> lets say your "cards" are numbers from 1 to 52, then deck = [1 .. 52]
12:10:01 <Excedrin> does that help?
12:10:01 <sclv> Lucas -- if you want to play with iteration with termination conditions, you might want to look at unfoldr, but that's probably the wrong approach here.
12:10:58 <Lucas82> : Excedrin  : yes.. with you
12:11:19 <Lucas82> so.. I want 1 .. 13 four times
12:11:27 <ski> Lucas82 : you can enumerate a hand by either having another card, and a sub-hand under that, or no more cards left, i.e. empty
12:11:32 <ski> yes
12:11:36 <faxathisia> > take 4 $ repeat $ [1..13]
12:11:38 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13],[1,2,3,4,5,6,7,8,9,10,11,12,13],[1,2,3,4,5,...
12:11:47 <faxathisia> > take 4 $ cycle $ [1..13]
12:11:48 <lambdabot>  [1,2,3,4]
12:11:52 <faxathisia> grr
12:12:44 <Excedrin> well 3 in the first list isn't the same as 3 in the 2nd list; you should probably have something like: data Card = Card Value Suit; data Suit = Heart | Spade | Diamond | Club; data Value = Two | Three ...
12:13:06 <Lucas82> so a hand can be for ex.. 1 , 2  King, Empty
12:14:00 <Lucas82> : Excedrin  : thanks but data Card is already defined
12:14:03 <ski> Lucas82 : e.g. `hand2 = Add (Card {rank = Numeric 2,suit = Hearts}) (Add (Card {rank = Jack,suit = Spades}) Empty)' is a hand consisting of two cards .. you only want all 52 cards, instead
12:14:34 <ski> Lucas82 : but, again, consider reading the hint under `fullDeck :: Hand'
12:14:38 <Lucas82> ok
12:14:39 <Beelsebob> for those that hadn't seen http://www.cs.kent.ac.uk/people/rpg/tatd2/gooeyhat.png <-- win :D
12:15:11 <faxathisia> Beelsebob: O_o
12:15:23 <Excedrin> Beelsebob: I was expecting something halloween related
12:15:27 <Beelsebob> hehe
12:15:32 <chr1s> Beelsebob: what's that?
12:15:45 <ski> Lucas82 : do you understand the hint ?
12:16:38 <Beelsebob> Gui version of Hat-observe (being extended into Gui versions of all the tools in a nice environment)
12:17:31 <chr1s> ah, I'm just reading your paper on Hat, that looks pretty cool!
12:17:32 <astrolabe> Oh. That's nice.  Is hat any more useable than it was about a year ago?
12:17:50 <Beelsebob> o.O
12:17:55 <Beelsebob> which paper?
12:18:18 <chr1s> Hat-delta â One Right Does Make a Wrong
12:18:23 <Beelsebob> ah, okay :)
12:18:36 <Beelsebob> that one really needs some poking
12:19:04 <Beelsebob> needs rather more evaluation really
12:19:25 <Lucas82> hmm not really reading
12:21:07 <bakert> sclv: been through all my use cases and your version of Skill works with them all!  thanks!
12:21:44 <ski> Lucas82 : before you noticed that you more or less want 1 .. 13 four times .. maybe you can make a function for doing "this" once, and then use that four times ?
12:22:20 <ski> Lucas82 : it's somewhat hard trying to help you, since i have to guess what you have problems with
12:22:40 <ski> (that's a hint, btw)
12:22:58 <Lucas82> hehe my labpartner hjust reappeard and said the same thing :) thnks :)
12:23:16 <dylan> now that's an unexpected admission requirement
12:23:43 <dylan> immunity to measles.
12:24:08 <dylan> and... this is the wrong window. ignore that, please. :)
12:24:45 <ski> Lucas82 : anyway, what i suggest you do, is reading through the lab pm *and* discussing with your lab partner how to break down the problems into smaller problems
12:24:46 <faxathisia> How do you often model the Store of an interpreter?
12:24:58 <thetallguy> conal: quickCheck (\x y -> x + y == y + x)
12:25:01 <faxathisia> Like a Map or somthing else?
12:25:21 <ski> Lucas82 : as for me, it's high time i bike home and get some food .. good luck
12:25:36 <Lucas82> ah ok thanks for help though
12:25:37 <kscaldef> is there a pointfree version of named field replacement?
12:25:39 <thetallguy> conal: is that what you're looking for?
12:25:40 <kscaldef> @pl \foo -> foo {bar = ""}
12:25:40 <lambdabot> (line 1, column 13):
12:25:40 <lambdabot> unexpected "{"
12:25:40 <lambdabot> expecting variable, "(", operator or end of input
12:25:41 <Lucas82> good luck woth you food
12:26:12 <ski> (btw, if anyone would like to read what this lab is about, see <http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lab2.html>)
12:26:27 * ski bows to Lucas82
12:28:28 <conal> thetallguy: hm.  i don't think so.  more like a = b && forAll $ \ x -> f x == g x.  composably.
12:30:00 <conal> thetallguy: i think i have a solution.  the QC functions "evaluate" and "forAll" allow constructing and deconstructing Property value.
12:30:03 <thetallguy> s/a = b/a == b/ I assume?
12:30:11 <faxathisia> I want to turn http://img236.imageshack.us/img236/7859/picture5ov5.png into haskell code
12:30:50 <conal> thetallguy: yes, thx
12:30:54 <thetallguy> conal: intersting, I haven't gotten to evaluate yet.  I will read and play more.
12:31:11 <conal> thetallguy: i hadn't either!
12:31:49 <faxathisia> How do you know exactly what code (I could probably guess correctly, but I wonder more specifically) to write for these diagrams?
12:32:03 <thetallguy> conal: that manual is deceptively short
12:33:20 <hpaste>  conal pasted "Property conjunction in QC1" at http://hpaste.org/3583
12:33:35 <conal> compiles -- not yet tested.
12:37:13 <jeremiah> friends what is the perfect book for a novice, and the perfect book for an expert in haskell.
12:38:35 <Runaro_BRS> jeremiah: For the novice, The Haskell School of Expression is great fun. For the expert, a notebook is best.
12:38:55 <jeremiah> what is a notebook?
12:39:05 <thetallguy> Runaro_BRS: good answer
12:39:11 <thetallguy> jeremiah: he means a computer
12:39:23 <thetallguy> with an internet connection
12:39:43 <jeremiah> ah ok, thx, but a book only, what do you recommend for advanced haskell
12:40:17 <faxathisia> jeremiah: specialize
12:40:33 <faxathisia> jeremiah: if you are advanced then find some very specific interesting topic
12:40:58 <jeremiah> i am not advanced of course
12:41:42 <thetallguy> jeremiah: very much depends on your definition of advanced
12:42:02 <thetallguy> jeremiah: THSoE will get you a long way
12:42:06 <jeremiah> well in english i can define very well nothing sorry
12:42:27 <thetallguy> jeremiah: if you want to study more about Haskell internals or FP principals
12:43:02 <thetallguy> jeremiah: then you can look at Ben Pierce's books on Type Theory
12:43:16 <hpaste>  twanvl annotated "Property conjunction in QC1" with "This is simpler" at http://hpaste.org/3583#a1
12:43:18 <jeremiah> i would like to buy two books, one easy and one advanced
12:43:22 <thetallguy> jeremiah: or SPJ's 86 book on building an FP compiler, available on the web
12:43:45 <jeremiah> thx thetallguy, you are veri kind
12:43:48 <thetallguy> jeremiah: if you are looking for advanced features of Haskell usage, there really isn't such a book
12:44:03 <thetallguy> jeremiah: at that point, you switch to papers
12:44:19 <jeremiah> i see , thx
12:44:44 <conal> twanvl: much simpler.  thanks! :)
12:45:02 <thetallguy> jeremiah:  But HSoE and Pierce's Type Theory and Programming Languages are a good start
12:45:27 <jeremiah> thx friend
12:45:28 <thetallguy> jeremiah: actually, that covers quite a lot
12:46:06 <L29Ah> > take 1 (intersect [1..] [2..])
12:46:13 <lambdabot> Terminated
12:46:25 <L29Ah> =(
12:47:22 <faxathisia> > take 1 ((intersect [1..10] [2..]) ++ (intersect [11..] [2..]))
12:47:24 <thetallguy> jeremiah:      Types and Programming Languages      by Benjamin C. Pierce
12:47:26 <lambdabot> Terminated
12:47:29 <faxathisia> :|
12:47:45 <faxathisia> @src intersect
12:47:45 <lambdabot> intersect = intersectBy (==)
12:47:51 <faxathisia> @src intersectBy
12:47:55 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
12:48:05 <jeremiah> thx thetallguy i have taked note of that books.
12:48:11 <pierre-> > take 1 (intersect [2..] [1..])
12:48:14 <lambdabot>  [2]
12:48:43 <omnId> intersect has to check all of ys, so if it's not there...
12:48:47 * faxathisia wants to see intersect written with the Omega monad
12:48:48 <twanvl> > let intersect (x:xs) (y:ys) = case x `compare` y of LT -> intersect xs (y:ys); EQ -> x : intersect xs ys; GT -> intersect (x:xs) ys in take 1 (intersect [1..] [2..]) -- for sorted lists
12:48:50 <lambdabot>  [2]
12:49:47 <omnId> twanvl: do you know anything about Data.Generics?
12:49:57 <twanvl> A bit
12:50:20 <omnId> Do you know any not horribly painful way to go from (Data d => d) to a TH Exp?
12:50:43 <omnId> or even Generics Constr to TH Exp?
12:50:56 <twanvl> what should the Exp do?
12:51:14 <omnId> the Exp should be a representation of the datum.
12:51:55 <twanvl> one horrible hack I can think of is using gshow and then parsing the result
12:52:14 <omnId> so "ab" -> ConE (mkName ":") `AppE` LitE (CharL 'a') `AppE` LitE (CharL 'b') `AppE` ConE (mkName "[]")
12:52:30 <omnId> erm, missed a (:)
12:55:23 <hpaste>  omnId pasted "Compile-time evaluation" at http://hpaste.org/3584
12:56:03 <omnId> the X datatype there was for fussing around with
12:57:15 <twanvl> you can try using extQ
12:57:28 <omnId> @type extQ
12:57:30 <lambdabot> Not in scope: `extQ'
12:57:41 * omnId checks the docs
12:59:30 <twanvl> 'extend query'.  genericFunction `extQ` specificFunction
13:01:10 <omnId> so instead of generating a Tree Constr, generate a Tree Exp with some type-specific cases?
13:03:00 <L29Ah> twanvl: thank you!
13:09:17 <kscaldef> sigh... reddit downvoters attacking... can I get some love? http://programming.reddit.com/info/5zmm8/comments
13:09:18 <lambdabot> Title: programming: Haskell Web Spider, Part 3: More HXT
13:30:41 <Lucas82> ski: you there ski?
13:40:19 <droundy> Can anyone tell me how to make cabal build an executable that isn't installed on make install (e.g. a unit test program)?
13:44:00 <_ry> is there a ecmascript implementation in haskell?
13:47:11 <sclv> _ry: I think there's the opposite -- a yhc backend that compiles down to javascript.
13:47:21 <sclv> why would you want the other?
13:47:36 <koala_man> maybe you could make it self hosting!
13:53:26 <dcnstrct_> How many java devs does it take to round up by a power of 2 ? http://forum.java.sun.com/thread.jspa?threadID=248212&start=0&tstart=0   and how could this be done in Haskell ? thnx
13:53:28 <lambdabot> Title: Java Programming [Archive] - Rounding up an int to a power of two, http://tinyurl.com/38alcj
13:55:52 <TSC> You mean round up to the nearest power of 2?
13:56:02 <sclv> (\x -> head . dropWhile (<x) . iterate (*2) 1) 45
13:56:03 <omnId> > 2 ^ (ceiling (logBase 2 18)) -- just a quick example :)
13:56:04 <lambdabot>  32
13:56:10 <sclv> > (\x -> head . dropWhile (<x) . iterate (*2) 1) 45
13:56:11 <lambdabot>  Couldn't match expected type `a -> [a1]'
13:56:26 <sclv> > (\x -> head $ dropWhile (<x) $ iterate (*2) 1) 45
13:56:27 <lambdabot>  64
13:56:34 <olsner> I think there's a slightly clever bit-manipulation to get the answer very easily
13:57:46 <dcnstrct_> nice!! thanks a bunch people, and yes TSC round up to the nearest power of 2
13:57:55 <omnId> oh gawd: "what does *= do?? I have never seen that construct before."
13:58:03 <TSC> omnId: Yes, that was a bit scary
13:58:23 <olsner> hey, who expected java programmers to know java?
13:58:55 <omnId> olsner: Â¯\(Â°_o)/Â¯
13:59:19 <olsner> omnId: bonus points for the possibly biggest smiley I've ever seen
14:03:40 <idnar> it's spiderman!
14:04:04 <hpaste>  Victor Nazarov pasted "some random stuff" at http://hpaste.org/3585
14:05:52 <dcnstrct_> takuan, did you get your screenname from the Eiji Yoshikawa book ?
14:06:14 <takuan> well, indeed, from the character
14:06:30 <dcnstrct_> yea he was a smart whippernsapper
14:07:10 <dcnstrct_> takuan, did you read his book Taiko ?
14:07:19 <dcnstrct_> be sure to peep that one
14:07:23 <dcnstrct_> I think it's his best work
14:07:24 <takuan> yup
14:07:34 <takuan> but it's an abreviation of the original book
14:07:45 <takuan> the original is far longer than the english translation
14:08:06 <takuan> and I don't think you know all he has written ;)
14:08:14 <takuan> most of it isn't translated
14:08:24 <dcnstrct_> GOOD POINTS! I'm glad to hear there is much more to check out
14:08:37 <takuan> but you'll have to learn japanese
14:08:44 <takuan> and a decent lot
14:09:01 <dcnstrct_> well I've learned Ruby.... thats a first step I guess
14:09:14 <takuan> my family in law tells me that for them (they're japanese) the japanese is already quite difficult
14:09:32 <dcnstrct_> oh wow
14:10:08 <takuan> but when you can get a hold of a html-version of it and you use a japanese popup program you can get quite far
14:10:47 <dcnstrct_> oh please show me!
14:12:23 * omnId uses the rikaichan firefox extension, but doesn't know enough basic grammar to get far.
14:13:05 <omnId> Alt-Insert, popup definitions with readings.
14:13:26 <dcnstrct_> I'd just like to get a feeling for how much is missing from the english manuscript
14:13:50 <takuan> well, it's quite good actually
14:13:56 <takuan> but you miss the literary stuff
14:14:08 <takuan> therefore, the japanese is also quite challenging to read
14:14:44 <lament> "Lost In Translation"
14:15:28 <Lucas82> anyone know about StdGen
14:15:45 <takuan> yup
14:15:49 <takuan> very good movie btw
14:16:14 <augustss> what about StdGen?
14:16:20 <takuan> it really gives a feel for how Japan feels when you arrive for the first time in the country
14:16:34 <omnId> > mkStdGen 1
14:16:35 <lambdabot>  2 1
14:16:39 <omnId> > split (mkStdGen 1)
14:16:40 <lambdabot>  (3 40692,80028 2147483398)
14:16:46 <omnId> > randomR (0,10) (mkStdGen 1)
14:16:48 <lambdabot>  (3,80028 40692)
14:39:54 <Lucas82> OO nice
14:40:03 <Lucas82> what if I just want random ints?
14:40:26 <Lucas82> not doubles
14:40:50 <oerjan> @instances-importing System.Random Random
14:40:52 <lambdabot> Bool, Char, Double, Float, Int, Integer
14:41:55 <omnId> > randoms (mkStdGen 42) :: [Int]
14:41:57 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
14:42:10 <monochrom> 42 is also my favourite seed :)
14:42:28 <dons> mine too :)
14:42:30 <omnId> it's dons' fault.
14:42:35 <dons> it produces better randoms than other seeds
14:42:38 <dons> much better
14:43:05 <monochrom> How is it dons's fault? Hard-coding it into QuickCheck? :)
14:43:07 <oerjan> > randomRs (1,6) (mkStdGen 42) :: [Int]
14:43:09 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
14:43:10 <Lucas82> soory didn't get that
14:43:20 <omnId> monochrom: using it all the time, so I picked it up.
14:43:25 <Lucas82> AH
14:43:25 <dons> ah, yes.
14:43:26 <Lucas82> ok
14:43:39 <monochrom> haha ok. I guess "great minds think alike" applies. :)
14:44:05 <olsner> I think you all stole it from Douglas Adams
14:44:17 <omnId> olsner: that goes without saying
14:44:23 <olsner> ;-)
14:45:24 <Lucas82> hmm but ok.. so I want to use first the first.. then the second..
14:46:06 <oerjan> Lucas82: btw mkStdGen is something we use only because lambdabot censors IO actions.  for real programs you want to use newStdGen in IO instead
14:46:29 <oerjan> :t newStdGen
14:46:30 <lambdabot> IO StdGen
14:46:33 <omnId> Lucas82: get hold of a StdGen somehow, either through mkStdGen or newStdGen in IO, then pass it around to the various random* functions.
14:46:40 <Lucas82> ok thanks.. buts its ok I am only a begginer
14:46:50 <omnId> @src Random
14:46:50 <lambdabot> class Random a where
14:46:51 <lambdabot>   random    :: RandomGen g => g -> (a, g)
14:46:51 <lambdabot>   randoms   :: RandomGen g => g -> [a]
14:46:51 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
14:46:51 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
14:46:52 <lambdabot>   randomRIO :: (a,a) -> IO a
14:46:54 <lambdabot>   randomIO  :: IO a
14:47:05 <Lucas82> mm nice:)
14:47:15 <luqui> does the haskell standard require that "case x of True -> 42; False -> 42"  be strict, or is the strictness allowed to be optimized away?
14:47:19 <omnId> 'a' is a type that can be randomly generated, 'g' is a random number source.
14:47:56 <oerjan> luqui: strictness required
14:48:06 <omnId> x `seq` 42 :)
14:48:45 <monochrom> case x of True ->...  is strict.
14:49:12 <oerjan> it can of course be optimized to what omnId said
14:49:12 <monochrom> case x of ~True -> 42; ...  is non-strict.
14:49:31 <Lucas82> look what I meant was..  If I write   take 1 (randomRs (1,6) (mkStdGen 42) :: [Int]) the list always starts at [39,....
14:49:37 <omnId> monochrom: yeah, and the ... cases will be warned as overlapping :)
14:49:39 <oerjan> in principle
14:49:43 <Lucas82> I want the 39 to change everyime I execute
14:50:04 <oerjan> Lucas82: exactly, which is why you want to use newStdGen
14:50:13 <omnId> Lucas82: don't use mkStdGen 42, use: do g <- newStdGen; blah blah g
14:50:35 <oerjan> in haskell, anything which changes value when you repeat it _must_ be in IO
14:50:37 <omnId> Lucas82: and taking one from an infinite list is pointless, just use randomR.
14:50:47 <monochrom> I actually support code transformations that make programs more non-strict. From running time oo to running time O(1) is a speedup by definition.
14:51:20 <Lucas82> but I want one int
14:51:31 <omnId> Lucas82: so you randomR
14:51:34 <omnId> use*
14:51:35 <oerjan> :t randomRs (1,6) =<< newStdGen
14:51:37 <lambdabot>     Couldn't match expected type `[]' against inferred type `IO'
14:51:37 <lambdabot>       Expected type: [a]
14:51:37 <lambdabot>       Inferred type: IO StdGen
14:51:48 <omnId> liftM
14:51:59 <oerjan> :t randomRs (1,6) <$> newStdGen
14:52:01 <lambdabot> forall t. (Num t, Random t) => IO [t]
14:52:02 <omnId> or (return .), which is the same :)
14:52:23 <oerjan> we have no shortage of synonyms for liftM
14:52:43 <omnId> @quote liftM
14:52:43 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
14:52:51 <omnId> @quote fmap
14:52:51 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life; is much happier now
14:54:12 <pjd> when in doubt, lift 'em
14:54:14 <oerjan> > product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
14:54:16 <lambdabot>  120
14:54:45 <omnId> > product . map read . map (:[]) . take 5 $ "1234567"
14:54:47 <lambdabot>  120
14:54:59 <omnId> > product . map (read . (:[])) . take 5 $ "1234567" -- fusion
14:55:00 <lambdabot>  120
14:55:10 <oerjan> Lucas82: for trying in the interpreter, randomRIO (1,6) may be simplest
14:55:51 <oerjan> um, not sure if it prints the result always
14:56:06 <omnId> @check \c -> digitToInt c == (read . (:[])) c
14:56:08 <lambdabot>  Exception: Char.digitToInt: not a digit '\1102448'
14:56:10 <oerjan> if not, print =<< randomRIO (1,6)
14:56:22 <omnId> hrm
14:57:14 <omnId> @check \c -> ('0' <= c && c <= '9') ==> digitToInt c == (read . (:[])) c -- not the best, but...
14:57:16 <lambdabot>  Arguments exhausted after 0 tests.
14:57:20 <omnId> :(
14:57:42 <omnId> I suppose I could generate in some smaller type then convert to Char
14:57:49 <oerjan> @check \c -> isDigit c ==> digitToInt c == (read . (:[])) c
14:57:50 <lambdabot>  Arguments exhausted after 0 tests.
14:58:09 <oerjan> huh?
14:58:36 <oerjan> oh right
14:58:40 <omnId> it made 500 test data, but 0 got through the (==>)
14:59:01 <oerjan> @check \c -> c `elem`['a'..'z']
14:59:02 <lambdabot>  Falsifiable, after 0 tests: '\720493'
14:59:07 <ddarius> @scheck \c -> isDigit c ==> digitToInt c == (read . (:[])) c
14:59:09 <lambdabot>   Completed 7 test(s) without failure.  But 7 did not meet ==> condition.
14:59:24 <oerjan> @scheck \c -> c `elem`['a'..'z']
14:59:25 <lambdabot>   Completed 7 test(s) without failure.
14:59:37 <oerjan> scheck only generates letters
14:59:43 <oerjan> @scheck \c -> c `elem`['a'..'g']
14:59:44 <lambdabot>   Completed 7 test(s) without failure.
14:59:46 <ddarius> That's pretty crappy.
15:00:17 <ddarius> @scheck \c -> isLower c == c
15:00:18 <lambdabot> Couldn't match expected type `Bool' against inferred type `Char'
15:00:26 <ddarius> @scheck \c -> toLower c == c
15:00:27 <lambdabot>   Completed 7 test(s) without failure.
15:00:41 <oerjan> given that it has a size limit 7, it must choose 7 fixed chars i guess
15:00:53 <oerjan> @help scheck
15:00:54 <lambdabot> scheck <expr>
15:00:54 <lambdabot> You have SmallCheck and 3 seconds. Test something.
15:00:54 <omnId> @check \c -> let test c = digitToInt c == (read . (:[])) c in case c of {Left LT -> test '0'; Left EQ -> test '1'; Left GT -> test '2'; Right LT -> test '3'; Right EQ -> test '4'; Right GT -> test '5'} -- =D
15:00:55 <lambdabot>        add an instance declaration for       (Arbitrary (Either Ordering Orde...
15:00:59 <ddarius> There are better sets of 7
15:01:00 <omnId> :(
15:01:23 <omnId> @instances-importing Test.QuickCheck Arbitrary
15:01:24 <lambdabot> (), (a -> b), (a, b), Bool, Double, Float, Int, Integer, [a]
15:01:55 <conal> @instances-importing Test.QuickCheck Testable
15:01:56 <lambdabot> (), (a -> b), Bool, Property, Result
15:02:42 <oerjan> i guess generating characters is pretty crappy no matter what you do, unless you consider the actual use case
15:02:58 <omnId> @check \c -> let test c = digitToInt c == (read . (:[])) c in case c of {(False,False) -> test '0'; (False,True) -> test '1'; (True, False) -> test '2'; (True, True) -> test '3'} -- =D
15:02:59 <lambdabot>  OK, passed 500 tests.
15:03:05 <omnId> hehe
15:03:13 * omnId projects (Bool,Bool) to Char
15:03:29 <omnId> impromptu Arbitrary instance
15:04:45 <oerjan> in fact Char is not mentioned, seems @instances does not see the same module as @check
15:05:21 <oerjan> maybe it has additional imports, or uses another QuickCheck version
15:06:23 <dmwit> > ord 257
15:06:24 <lambdabot>   add an instance declaration for (Num Char)
15:06:29 <dmwit> > chr 257
15:06:30 <lambdabot>  '\257'
15:06:33 <dmwit> Oh good.
15:06:43 <oerjan> Char is Unicode
15:06:57 <dons> > maxBound :: Char
15:06:58 <lambdabot>  '\1114111'
15:07:14 <omnId> > showHex "1114111" ""
15:07:15 <lambdabot>   add an instance declaration for (Integral [Char])
15:07:15 <lambdabot>     In the expression: sh...
15:07:21 <oerjan> although the IO operations only support the byte part
15:07:29 <omnId> > showHex 1114111 ""
15:07:31 <lambdabot>  "10ffff"
15:07:42 <omnId> (False,False,False) -> '0'; (False,False,True) -> '1'; (False,True,False) -> '2'; (False,True,True) -> '3'
15:07:45 <omnId> oops
15:07:53 <omnId> @check \c -> (\c -> digitToInt c == (read . (:[])) c) $ case c of {(False,False,False) -> '0'; (False,False,True) -> '1'; (False,True,False) -> '2'; (False,True,True) -> '3'; (True,False,False) -> '4'; (True,False,True) -> '5'; (True,True,False) -> '6'; (True,True,True) -> '7'} -- larger test space
15:07:54 <lambdabot>  OK, passed 500 tests.
15:09:21 <oerjan> @check w <= (255 :: Word8)
15:09:22 <lambdabot>   Not in scope: `w'
15:09:23 <omnId> > and $ map (\c -> digitToInt c == (read . (:[]) c) ['0'..'9']
15:09:23 <lambdabot> Unbalanced parentheses
15:09:29 <omnId> > and $ map (\c -> digitToInt c == (read . (:[])) c) ['0'..'9']
15:09:30 <oerjan> @check \w -> w <= (255 :: Word8)
15:09:30 <lambdabot>  True
15:09:31 <lambdabot>  OK, passed 500 tests.
15:09:46 <oerjan> ah, Word8 is available too
15:10:00 <oerjan>  @check definitely has more instances
15:10:25 <quicksilver> was Data.Foldable introduced with a paper or anything?
15:10:32 <quicksilver> is there any motivational material for it?
15:10:39 <dons> http://programming.reddit.com/info/5zmz4/comments
15:10:40 <lambdabot> Title: programming: The PolyState Monad
15:10:54 <dons> quicksilver: hmm, in the applicative pearl?
15:11:23 <nominolo> @hackage MultiSet
15:11:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MultiSet
15:11:41 <nominolo> stupid script
15:11:55 <dons> ?version
15:11:55 <lambdabot> lambdabot 4p571, GHC 6.6 (Linux i686 2.66GHz)
15:11:55 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:12:06 <dons> you could patch the hackage program, if its wrong
15:12:08 <quicksilver> dons: No, that just mentions traversable and even that, only in passing
15:12:13 <dons> hmm
15:12:21 <oerjan> quicksilver: wasn't FunctorM an earlier version?
15:12:30 <nominolo> dons: that was only half-serious.  it should use the new search functionality
15:12:51 <dons> yes.
15:13:08 <oerjan> but i don't see any paper links in that either
15:14:29 <quicksilver> oerjan: hmm I hadn't realised that. But yes.
15:15:16 <quicksilver> been thinking about putting together a haskellwiki page on the Functor/Monoid/Foldable/Traversable hierarchy
15:15:25 <dons> quicksilver: yes, its time.
15:15:36 <fox86> do you usually put the "main" at the beginning of your file?
15:15:41 <quicksilver> there are some non-obvious things about using them
15:16:00 <quicksilver> for example, I'm wondering why Foldable doesn't have a "length" funciton or (more likely) method
15:16:22 <monochrom> I sometimes put main at the end.
15:18:15 <quicksilver> fox86: I put it all over the place depending on mood :)
15:18:25 <fox86> ah, okay
15:18:35 <quicksilver> fox86: but if the program gets sizeable, I normally put main in a rather small 'main' module
15:18:40 <quicksilver> and put the good stuff elsewhere
15:19:13 <fox86> quicksilver: i see. i am making a first attempt at a useful haskell program
15:19:19 <oerjan> fox86: i've put it at the beginning, just after imports and data structure definitions
15:20:03 <oerjan> since it is sort of the "root" from which the rest is reachable
15:20:22 <fox86> okay. i think i'll place mine at the beginning as well
15:21:03 * omnId parses his program into a list of decls, randomizes the list, and reprints the decls out.
15:24:35 <monochrom> Related question for discussion: Do you write "f x = let y=x*x in y+y" or "f x = y+y where y=x*x".
15:24:49 * omnId prefers where when there's a choice
15:24:51 * ddarius always uses where if possible
15:25:03 <monochrom> It is really a psychology test.
15:25:18 * oerjan agrees with the above
15:25:25 <ddarius> Yes, are you a Haskeller or not.
15:26:39 <monochrom> It measures whether you are a top-down person or bottom-up person.
15:26:50 * twanvl is not a Haskeller...
15:27:06 <oerjan> main at top + where or main at bottom + let
15:27:21 <fasta> monochrom: what if you use both?
15:27:31 <omnId> being written, my code's usually a mess of the two, then I change, reformat, extract common bits, and use 'where' where possible
15:27:46 <monochrom> I am a bit of both, indeed.
15:28:17 <quicksilver> monochrom: I use let, if I think a reader should read this definition first, before proceeding
15:28:28 <fasta> And as usual I don't agree with the top-down vs bottom-up.
15:28:29 <quicksilver> monochrom: I use where if I don't thin the details of the definition are important and he can read it later
15:28:40 * ddarius is a top up person.
15:28:42 <quicksilver> monochrom: of course, I don't always stick to that rule, but that's the idea :)
15:29:00 <oerjan> ddarius: standing on your head a lot? :)
15:29:13 <fasta> Haskell could support top-down better.
15:29:32 <fasta> E.g. top = undefined RET vs top <RET>
15:30:02 <fasta> Someone had a proposal for that, IIRC.
15:30:07 <_Jedai_> I use where mostly, but sometimes let for vey small defs that are used immediately on the same line
15:31:30 <fox86> and do you use [Char] or String?
15:31:37 <fox86> not sure if it's the same think
15:31:40 <oerjan> do other expression vs. declaration style things like case vs. patterns in function arguments also fit into this?
15:31:40 <fox86> thing*
15:31:44 <quicksilver> it is the same thing
15:31:46 <quicksilver> I use String
15:32:04 <fox86> okay
15:32:15 <oerjan> @src String
15:32:15 <lambdabot> type String = [Char]
15:34:08 <oerjan> monad comprehensions vs. do expressions seems like another case, perhaps why some people want comprehensions back so strongly?
15:34:49 <Lemmih> @seen dons
15:34:50 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 12m 2s ago.
15:35:00 <omnId> they both seem expressiony rather than declarationy to me.
15:35:16 <oerjan> omnId: i'm thinking of top vs. bottom
15:36:02 <oerjan> there's a linguistic term for this.
15:36:59 <quicksilver> omnId: comprehensions are somewhat declarative
15:37:03 <dolio> Monad comprehensions are probably a better fit for certain monads, since they're more like set comprehensions in math.
15:37:08 <quicksilver> omnId: in that the return comes first
15:37:15 <dolio> Instead of a sequence of imperative steps like a do.
15:37:16 <quicksilver> omnId: "(x,y) such that..."
15:37:21 <omnId> somewhat, yes
15:37:48 <quicksilver> (the return coming first is basically the only difference, apart from magic 'guard')
15:38:26 <quicksilver> dons: A good example. You have started using Data.Sequence, and you're looking for 'concatMap' equivalent.
15:38:50 <quicksilver> dons: it's actually foldMap, but to know that, you have to know that Sequence is both Foldable and Monoid
15:38:58 <quicksilver> dons: and you have to look in Foldable in the first place.
15:39:13 <quicksilver> (and think of instantiating the two types to the same)
15:40:08 <quicksilver> interestingly, this would seem to imply that if you are both Foldable and Monoid, you are in fact Monad.
15:40:11 <quicksilver> Interesting.
15:40:16 <omnId> quicksilver: s/dons/dolio/g?
15:40:42 <LoganCapaldo> Monads are Foldable Monoids?
15:40:46 <LoganCapaldo> gasp
15:40:57 <quicksilver> omnId: no, I was talking to dons about this 10 mins ago :) or 20.
15:41:05 <quicksilver> LoganCapaldo: no. Foldable Monoids are Monads.
15:41:08 <quicksilver> LoganCapaldo: not the converse :)
15:41:59 <quicksilver> But, I'm wrong. foldMap is an excellent candidate for >>= but foldables aren't required to have anything like return.
15:42:20 * oerjan is probably thinking of SOV vs. SVO order
15:42:22 <quicksilver> So I'd need to say "if you're Foldable, Monoid and Applicative, then you are a Monad"
15:42:31 <omnId> instance (Foldable f, forall a. Monoid (f a)) => Monad f where ... -- something like this?
15:42:56 <fox86> i don't understand how "bracket" works? i am opening a file and reading some chars from it.. and it's working, but i don't know why
15:43:02 <omnId> @src bracket
15:43:03 <lambdabot> bracket before after thing = block $ do
15:43:03 <lambdabot>     a <- before
15:43:03 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
15:43:03 <lambdabot>     after a
15:43:03 <lambdabot>     return r
15:43:19 <omnId> a <- openYourThing
15:43:41 <omnId> r < catch (doItWith a) (ohNoesErrorz!)
15:43:45 <quicksilver> omnId: yes
15:43:58 <omnId> closeYourThing a
15:44:00 <omnId> return r
15:44:00 <quicksilver> omnId: of course you end up being MonadPlus, not just Monad
15:44:24 <quicksilver> the block/unblock is just gravy to do with asynchronous stuff. It's not important at first glance.
15:44:34 <bakert> I have a record type where one of the fields is a Maybe String - is there a good trick to avoid having to write Nothing 90% of the time I use one of these records?
15:44:55 <LoganCapaldo> @type maybe
15:44:56 <twanvl> that should maybe also imply some laws for Foldable
15:44:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:45:04 <LoganCapaldo> @type fromMaybe
15:45:05 <lambdabot> forall a. a -> Maybe a -> a
15:45:13 <omnId> bakert: you could use the Maybe Monad and various other useful Maybe-crunching functions.
15:45:14 <LoganCapaldo> and of course my personal favorite, do notation
15:45:29 <quicksilver> bakert: have a default record
15:45:38 <quicksilver> bakert: which has that field set to nothing
15:45:43 <bakert> ok, perhaps now id the time to confront the horrifying truth "Maybe is a Monad"
15:45:49 <quicksilver> bakert: and construct records using update notation
15:45:57 <omnId> bakert: it's not so scary :)
15:45:59 <bakert> quicksilver: i thought of that but then i end up with awkward looking code.
15:46:01 <omnId> @src Maybe (>>=)
15:46:01 <lambdabot> (Just x) >>= k      = k x
15:46:02 <lambdabot> Nothing  >>= _      = Nothing
15:46:30 <omnId> > Just 1 >>= (\n -> Just (n + 1))
15:46:32 <lambdabot>  Just 2
15:46:46 <bakert> quicksilver: i may not have thought of the right way of using the default record
15:46:47 <omnId> > liftM (+1) (Just 1)
15:46:49 <lambdabot>  Just 2
15:46:58 <quicksilver> bakert: I'm not sure exactly what you're trying to do :)
15:47:04 <dolio> Isn't it just 'defaultRecord { whatever }' instead of 'Record {whatever, baz = Nothing }' ?
15:47:12 <faxathisia> :t liftM
15:47:13 <quicksilver> as dolio says
15:47:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:47:23 <quicksilver> normally that saves you writing baz = Nothing
15:47:24 <faxathisia> > (liftM (+1)) (Just 1)
15:47:25 <omnId> (a -> b) -> Maybe a -> Maybe b
15:47:26 <lambdabot>  Just 2
15:47:29 <quicksilver> but otherwise it's not too hard
15:47:41 <omnId> faxathisia: turns the 'a' inside the Maybe into a 'b'.
15:47:46 <dibblego> is there a type-class that has something like mempty or mzero but nothing else (i.e. is not necessarily a Monad for example)?
15:47:50 <bakert> dolio, quicksilver: well i don't like to use the record syntax because i have quite a lot of this stuff
15:47:57 <omnId> dibblego: Monoid?
15:47:57 <LoganCapaldo> omnId: turns the a into a b. nice. :)
15:48:10 <dibblego> omnId, Monoid has mappend I think
15:48:12 <omnId> LoganCapaldo: quotes are useful :P
15:48:21 <bakert> [Statistic Weapon "Sword" 10, default Horsemanship 6, default FirstAid 3, Statistic Read "Latin" 3]
15:48:24 <bakert> just seems horrid :(
15:48:30 <bakert> and
15:48:41 <dibblego> omnId, though, that may be acceptable anyway
15:48:49 <LoganCapaldo> err
15:48:54 <quicksilver> dibblego: you just want an 'empty' element?
15:48:58 <quicksilver> dibblego: no, there isn't.
15:48:59 <LoganCapaldo> Maybe he doesn't actually have records?
15:49:02 <bakert> [Statistic { skill = Weapon, specialty = Just "Sword", level = 10 } ... seems even worse!
15:49:07 <dibblego> quicksilver, ok cheers
15:49:07 <bakert> verbose
15:49:07 <quicksilver> dibblego: not sure what you'd call it. PointedSet ?
15:49:20 <quicksilver> dibblego: just 'Pointed' perhaps
15:49:20 <dibblego> quicksilver, yes, I'm agreeing with that line of reasoning in my head right now
15:49:55 <bakert> omnId: is using Maybe's monadness going to let me write a nice list of initial values for various of my record type?
15:50:12 <quicksilver> bakert: custom constructors sounds like the way
15:50:16 <quicksilver> bakert: for that case
15:50:20 <bakert> yes i thought of:
15:50:25 <bakert> special Weapon "Sword" 10
15:50:25 <bakert> plain Horsemanship 6
15:50:34 <bakert> but i couldn't think of good names
15:50:38 <bakert> :)
15:50:45 <quicksilver> also, consider
15:50:46 <twanvl> 'pointed' sounds horribly non-descriptive to me
15:51:14 <bakert> maybe i should use "" for no specialty and not Nothing
15:51:19 <quicksilver> map special [(Weapon,"Sword",10)...] ++ map default [(Horsemanship,6),(FirstAid,3)] ....
15:51:26 <bakert> ooh
15:51:28 <bakert> that's good
15:51:33 <quicksilver> that save you writing special + default over and over again
15:51:38 <bakert> yes
15:51:53 <quicksilver> lists of tuples are quite good "custom constructors"
15:52:05 <quicksilver> with a few judicious maps to 'inject' them into the real data structure
15:52:07 <bakert> ah yes that is cunning
15:52:29 <Raguel> hihi
15:52:33 <bakert> i still feel sad that lance, sword, dagger, etc. are all wrapped up in weapon
15:52:43 <bakert> they feel like the should be at the top level
15:52:50 <LoganCapaldo> class Weapon ...
15:52:51 <quicksilver> why not make 'Weapon' take a parameter?
15:52:51 <ivan_m> how can I reference "haskell" in my report? (i.e. bibtex entry)
15:52:54 <ddarius> bakert: You don't have to use record notation to build a record.
15:53:12 <bakert> ddarius: yes i know but it looks pretty hideous even without.
15:53:13 <quicksilver> data .... FirstAid | Horsemanship | Weapon String
15:53:22 <sorear> ivan_m: What does it mean to reference a language?
15:53:23 <bakert> quicksilver: yes i like that a lot
15:53:26 <bakert> buuuuuuut
15:53:31 <bakert> it makes the question
15:53:40 <sorear> ivan_m: Do you want to reference the Haskell 98 Language and Libraries Report?
15:53:44 <quicksilver> then (Weapon "Sword") 10 or Horsemanship 63
15:53:47 <bakert> "does this character have a non-sword weapon skill 7 or greater" into a nightmare
15:53:53 <bakert> :)
15:53:58 <ivan_m> sorear: I think mainly just the actual haskell website... but I can't find author, etc. for it
15:54:05 <quicksilver> bakert: I think it makes that easier
15:54:18 <quicksilver> (Weapon c) n | c /= "Sword" && n > 7
15:54:20 <keseldude> hi. I'm new to haskell (started today) and I can't figure out how to write anything to a file. Can someone help me out?
15:54:25 <Raguel> can anyone help me work out why i can't get hugs to work?
15:54:29 <sorear> ivan_m: there is no other, haskell.org is basically just a hosting provider for Haskell-related pages
15:54:30 <bakert> quicksilver: what in the hell is that pipe?? :)
15:54:35 <quicksilver> bakert: a 'guard'
15:54:45 <quicksilver> bakert: a fuller example
15:54:48 <sorear> Raguel: No, because you haven't asked your question yet.
15:54:50 <ivan_m> sorear: OK then
15:55:00 <Raguel> sorear: goooood point
15:55:01 <bakert> quicksilver: ok i know guards.  so that's part of a function?
15:55:02 <sorear> @ty writeFile -- for keseldude
15:55:10 <lambdabot> FilePath -> String -> IO ()
15:55:17 <Raguel> ok when i try to load in a file it says ERROR file:{Hugs}\programs\fibonacci.txt:2 - Syntax error in declaration (unexpected symbol ":=")
15:55:31 <quicksilver> rightskill (Weapon c) n | c /= "Sword" && n > 7 = "He has the skillz" | otherwise = "He has not the skillz"
15:55:37 <keseldude> i made a file called Main.hs and wrote:
15:55:37 <keseldude> module Test where
15:55:37 <keseldude> main = writeFile "C:\numbers.txt" "Hello"
15:55:42 <omnId> Raguel: fix the error then :)
15:55:57 <quicksilver> bakert: normally I'd put a newline before the | otherwise
15:56:03 <Raguel> I'm quite new at haskell
15:56:07 <bakert> i see
15:56:10 <ddarius> rightskill (Weapon "Sword") n | n > 7 =
15:56:10 <Raguel> ie trying to load in my first program
15:56:16 <sorear> Raguel: that's an error in your code.  if you can't figure out how to fix it, put it on hpaste and we'll gladly help.
15:56:16 <omnId> @paste your code to the paste bin, Raguel
15:56:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:56:19 <sorear> @paste
15:56:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:56:34 <ddarius> This will be interesting.
15:56:34 * omnId pokes sorear 
15:56:59 <hpaste>  keseldude pasted "writing to a file" at http://hpaste.org/3586
15:57:03 * sorear looks at omnid
15:57:14 <LoganCapaldo> @hoogle (a -> Bool) -> (a -> Bool) -> (a -> Bool)
15:57:15 <lambdabot> No matches, try a more general search
15:57:18 <twanvl> the main module must be called Main
15:57:21 <bakert> quicksilver: but then i need to write actual functions to determine the answers to specific questions.  rather than having a kind of general function.  i'd need one for Read and one for Play and one for Weapon (which have specialties) and then perhaps just one for the other types. ???
15:57:25 <faxathisia> Raguel: gotta escape the \
15:57:26 <bakert> or can i generalize?
15:57:29 <LoganCapaldo> O!
15:57:33 <sorear> keseldude: C:\\numbers.txt, and what twanvl said
15:57:34 <LoganCapaldo> limftM (&&)
15:57:40 <LoganCapaldo> err
15:57:42 <hpaste>  Raguel pasted ""fibonaccci"" at http://hpaste.org/3587
15:57:43 <LoganCapaldo> I can't spell
15:57:45 <sorear> faxathisia: that's keseldude
15:57:51 <faxathisia> oops
15:57:55 <keseldude> o yeah
15:58:02 <omnId> Raguel: uh, what language is that?
15:58:05 <quicksilver> bakert:  I see what you mean. You end up writing a mini-language for the functions, yes
15:58:11 <quicksilver> bakert: possibly more annoying.
15:58:26 <twanvl> it looks like pascal
15:58:37 <quicksilver> did pascal have "od." ?
15:58:41 <bakert> pascal surely doesn't hav od?
15:58:47 <faxathisia> no it didn't
15:58:51 <quicksilver> I only remember "od." from pseudo-code
15:58:58 <monochrom> ivan_m: http://www.cs.toronto.edu/bibliography/searchbib.cgi/Misc/allison?query={Jones99,&partial=on&case=on&results=preformatted&maxnum=10
15:58:58 <lambdabot> http://www.cs.toronto.edu/bibliography/searchbib.cgi/Misc/allison?query={Jones99,&partial=on&case=on&results=preformatted&maxnum=10
15:58:59 <omnId> Raguel: that is most certainly not Haskell.
15:59:02 <bakert> some weird kind of shell?
15:59:03 <quicksilver> of lecturers with a particular sense of humour :)
15:59:11 <bakert> if / fi
15:59:18 <Raguel> i blame my lecturer
15:59:25 <quicksilver> but apart from that, that looks like psuedo-code
15:59:29 <quicksilver> algol-like
15:59:41 <Raguel> *grumble*
15:59:50 <bakert> Raguel: are you supposed to turn that into haskell?  is that the assignment?
15:59:51 <quicksilver> and despite the name, it doesn't calculate fibonacci :)
15:59:55 <faxathisia> looks like Dijkstra code
16:00:03 <Raguel> thats the joke i think quicksilver
16:00:12 <Raguel> and the assignment is to find the number of possible paths
16:00:16 <faxathisia> Raguel: Missing semi-colon
16:00:30 <omnId> faxathisia: might be seperator not terminator
16:00:47 <Raguel> wrote it literally letter for letter
16:00:48 <monochrom> ivan_m: Oh, here is the newer one: http://www.cs.toronto.edu/bibliography/searchbib.cgi/Misc/allison?query={Jones03a,&partial=on&case=on&results=preformatted&maxnum=10
16:00:48 <faxathisia> hm
16:00:48 <lambdabot> http://www.cs.toronto.edu/bibliography/searchbib.cgi/Misc/allison?query={Jones03a,&partial=on&case=on&results=preformatted&maxnum=10
16:01:02 <omnId> lambdabot: stop that!
16:01:09 <keseldude> it worked as that one line, but not from the file =\
16:01:55 <Raguel> ok first question - when it says "unexpected symbol :="
16:02:04 <Raguel> i thought := is a valid haskell symbol
16:02:23 <ivan_m> thanks monochrom
16:02:23 <omnId> you could define a (:=) data constructor.
16:02:26 <faxathisia> Raguel: That code is absolutely nothing like haskell at all
16:02:47 <Raguel> right... now i need to work out how to translate it into haskell
16:02:49 <ivan_m> so, if I want to reference a particular wiki page (i.e. the STM page), whom do I say the author is? (bibtex wants either an author or a key)
16:03:10 <Raguel> fortunately i can poke my lecturer tomorrow to see why its messed up
16:03:11 <twanvl> ivan_m: look at the history
16:03:29 <Raguel> to get me started (since i've only written in c before) whats WRONG with it?
16:03:33 <bakert> Raguel: i wouldn't say it is messed up exactly.  it's just not haskell.  at all.  in any way.
16:03:50 <ivan_m> twanvl: quite a few people :p
16:03:51 <hpaste>  omnId annotated ""fibonaccci"" with "something more Haskelly" at http://hpaste.org/3587#a1
16:03:59 <faxathisia> Raguel: You should like... learn haskell
16:04:01 <monochrom> hpaste.org is slow.
16:04:04 <faxathisia> Raguel: Then you can translate that into it
16:04:04 <ivan_m> is there some generic "haskell community" I can assign authorship to? :p
16:04:08 <Raguel> faxa: this is me starting
16:04:10 <omnId> monochrom: yes.
16:04:30 <monochrom> I guess you can say the author is "The Haskell Community". :)
16:04:30 <bakert> omnId: i dig your function name.  nice.
16:04:33 <faxathisia> Raguel: I think this it not the best way..
16:04:41 <omnId> @wiki Haskell_in_5_steps   <- this is where to start, Raguel
16:04:41 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps___<-_this_is_where_to_start,_Raguel
16:04:46 <omnId> bah
16:04:48 <omnId> @wiki Haskell_in_5_steps
16:04:48 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
16:04:51 <omnId> ^ there
16:05:52 <Raguel> well the theory was: get lectures from the guy who wrote the book on haskell, try code that he puts in handout, learn from doing
16:05:55 <ivan_m> monochrom: :D
16:06:15 <monochrom> Who is that guy?
16:06:20 <bakert> Raguel: doesn't sound like a terrible plan.
16:06:50 <Raguel> except for this small chunk of fail i seem to have stumbled upon
16:06:54 <bakert> Raguel: but you're starting off with a misunderstanding here.  this code you have is very unhaskelly.
16:07:08 <Raguel> well its not really haskell lectures
16:07:11 <bakert> you must banish from your mind that is has anything to do with haskell
16:07:14 <Raguel> its more operational semantics
16:07:24 <bakert> and perhaps take a look at the haskell wiki 5 steps link above ^^^^
16:07:30 * Raguel gets his haskell book out
16:07:32 <bakert> just to get to the kind of basic "hello world" level
16:07:37 <bakert> or yes an intro book
16:07:39 <Raguel> bakert: reading that too
16:08:39 <ddarius> Raguel: What's the title of your book
16:08:41 <bakert> not that i am any great expert as the great experts here present would surely be quick to point out if they weren't too polite.  but you really want a nice gentle introduction to haskell before you attempt anything else
16:08:50 <monochrom> It seems to be your course has nothing to do with Haskell.
16:08:53 <pjd> dibblego++ for fighting the good fight
16:09:12 <dibblego> heh, thanks :) I'm getting a bit tired though
16:09:13 <Raguel> monochrom: so i got a book
16:09:24 <Raguel> and all the examples in the module are taught with haskell
16:09:30 <Raguel> even if this isn't ACTUAL haskell code
16:09:53 <ddarius> Raguel: What's the title of your book
16:10:01 <Raguel> programming in haskell
16:10:04 <monochrom> I propose my conjecture that Raguel is trolling or bluffing.
16:10:12 <Raguel> graham hutton
16:10:13 <bakert> Raguel: what's the book called?
16:10:38 <Raguel> you could ask graham himself, he said he spotted me here
16:10:50 <Raguel> hmm itkovian's a name i know...
16:10:57 <Raguel> meh - anyway
16:11:17 <Raguel> when i try putting things into hugs its coming back with the same error again
16:11:23 <monochrom> What is your course web page?
16:11:28 <Raguel> uuuum
16:11:30 <Raguel> lemme find it
16:11:46 <bakert> monochrom: i think you may be right
16:12:12 <Raguel> meeks :| i'm sorry if i'm a newb but i came here for help not to wind people up :(
16:12:33 <faxathisia> Raguel: Well you know what to do next right?
16:12:40 <faxathisia> Raguel: Learn haskell :)
16:12:50 <faxathisia> Raguel: not .. try to run random peices of code with no idea what they do
16:13:10 <bakert> :)
16:13:24 <Raguel> i thought hugs worked as write program into document, load document
16:13:41 <omnId> Raguel: it does, but that document isn't written in Haskell.
16:13:45 <faxathisia> Raguel: Do you now think it doesn't?
16:13:51 <faxathisia> Raguel: And if so, what changed your mind?
16:14:11 <Raguel> well i still believe it does
16:14:19 <Raguel> but i'm less sure on the simplicity of the matter
16:14:37 <Raguel> i am right in thinking you load a straight txt file in
16:14:40 <luqui> faxathisia needs a good smartass-prevention shot I think....
16:14:42 <luqui> :-)
16:14:44 <omnId> Raguel: copy/paste my version I added to your paste, load into Hugs, the type 'notfib' at the prompt.
16:14:45 <faxathisia> usually put .hs in haskell
16:14:48 <faxathisia> er haskell in .hs
16:15:14 <faxathisia> luqui: eh?
16:15:34 <Raguel> ok thats working :)
16:15:43 <faxathisia> luqui: forgive me for trying to find out where the confusion lies...
16:15:48 <luqui> that or luqui needs a interpretation-enhancer pill
16:15:50 <oerjan> > head . dropWhile ((/=0).snd) . iterate (\(a,b) -> (a*b,b-1)) $ (1,10)
16:15:52 <lambdabot>  (3628800,0)
16:16:23 <Raguel> but at least now i know that hugs can handle .txt format
16:16:25 <omnId> Raguel: put this into a file: 'fact n = product [1..n]' then, at the prompt, try 'fact 10' or 'fact 12' or whatever.
16:16:28 <bakert> monochrom: to be fair to Raguel his IP is from NTL Nottingham where graham hutton works.  so sorry Raguel if i doubted you!
16:16:42 <Raguel> no worries
16:16:49 <Raguel> and you can ask graham
16:16:54 <Raguel> oooor philipa
16:16:56 <Raguel> or liyang
16:17:07 <Raguel> who shall be poked if he doesn't wear his damn catears :P
16:17:10 <ddarius> It doesn't really matter, the correct advice has already been given.
16:17:18 <liyang> Raguel: ...
16:17:27 <liyang> I'm trying to keep a professional image.
16:17:36 <Raguel> and you can do that with cat ears on!!
16:17:41 <liyang> anyway. They're yours.
16:17:49 <Raguel> anno :P
16:17:53 <Raguel> but they look so much better on ou
16:17:55 <Raguel> *you
16:18:17 <faxathisia> :o
16:18:20 <Raguel> :|:|
16:18:22 <Raguel> aaahhh
16:18:24 <paczesiowa> is ther some uberMonadT which can support this: I need lazy list of values, where computing every value can result in IO (but it should happen when that value is really needed) and I need some state in all this
16:18:26 <Raguel> i see what i did wrong
16:18:55 <Raguel> sorry this is written in a language that was being defined in the lectures
16:19:03 <omnId> @slap Raguel
16:19:03 * lambdabot pushes Raguel from his chair
16:19:08 <oerjan> paczesiowa: you probably need unsafeInterleaveIO to make that
16:19:10 * Raguel flops on the floor
16:19:37 <hpaste>  keseldude pasted "writing a number to a file" at http://hpaste.org/3588
16:19:51 <keseldude> what's wrong with that?
16:19:54 <omnId> keseldude: (show x)
16:19:55 <paczesiowa> oerjan: I can't use any unsafe functions, my teacher hates them
16:20:01 <kpreid> oerjan: could be a "headUberT :: UberT a -> IO a" such that it performs the effects then
16:20:06 <omnId> keseldude: the parens need fixing
16:20:15 <liyang> paczesiowa: some combination of WriterT and StateT with IO as the outermost monad.
16:20:20 <kpreid> er,
16:20:21 <oerjan> paczesiowa: then it's impossible really
16:20:23 <keseldude> thank you!
16:20:40 <kpreid> headUberT :: UberT m a -> m a
16:20:44 <liyang> please don't unsafeInterleaveIO... that makes me a sad panda. :(
16:20:47 <Raguel> are indentations done only with tabs or with spaces too? (thinking of while loops)
16:20:56 <kpreid> tailUberT :: UberT m a -> m (UberT m a)
16:20:59 <omnId> Raguel: what's a while loop?
16:21:02 <liyang> Raguel: a tab is 8 spaces. It's the law.
16:21:17 <monochrom> omnId: a while loop is defined as per the lecture notes.
16:21:27 <kpreid> Raguel: Haskell will accept either, but it considers tabs equivalent to 8 spaces, which matters per the layout rule
16:21:46 <liyang> paczesiowa: oops. Sorry. Didn't read the bit in brackets.
16:22:08 <hpaste>  LoganCapaldo annotated "Having too much fun" with "(no title)" at http://hpaste.org/3589#a1
16:23:24 * liyang always uses tabs at the beginning of the line. So even when he has tabspace=4 when editing the code, the compiler/interpretor is still happy.
16:23:58 <liyang> (Except when you have one of those pesky let things. I don't like using let because it messes up my layout rules.)
16:24:00 * oerjan always has the editor turn tabs into spaces
16:24:01 <paczesiowa> liyang: how do I use FirstT and SecondT both at the same time?
16:24:25 <kpreid> FirstT (SecondT IO) Int
16:24:34 <kpreid> FirstT (SecondT (ThirdT IO)) Int
16:24:50 <liyang> paczesiowa: you have to pick one as the inner and the other as the outer monad. :3
16:24:55 <paczesiowa> but, wouldn't that SecondT IO need some a?
16:25:03 <kpreid> paczesiowa: no
16:25:16 <kpreid> all monad transformers take monads
16:25:27 <oerjan> :k StateT
16:25:35 <lambdabot> * -> (* -> *) -> * -> *
16:25:35 <kpreid> IO is a monad; IO a is not. If I have the terminology right.
16:25:36 <liyang> (And when you start nesting brackets at type level, it's time to use type synonyms...)
16:25:46 <paczesiowa> and SecondT IO is a monad, but SecondT IO Int isn't?
16:25:54 <omnId> @unmtl StateT s (WriterT w IO) a
16:25:54 <lambdabot> s -> IO (a, s, w)
16:26:02 <kpreid> paczesiowa: it's all partial application until the outer level
16:26:10 <kpreid> look at this:
16:26:14 <kpreid> (FirstT (SecondT (ThirdT IO))) Int
16:26:18 <kpreid> (I added more parens)
16:26:22 <keseldude> what do you use for an editor? I use editpad pro
16:26:26 <liyang> If we're being strict with terminology here, then StateT isn't a monad transformer per se. StateT StateType is.
16:26:30 <kpreid> all the Ts are applied to some monad producing a monad
16:26:46 <kpreid> then we apply it to Int to get a type
16:26:47 <omnId> keseldude: many here are linuxers in vim or emacs.
16:26:56 <omnId> omnId: I use Notepad2 for now :)
16:27:02 <liyang> Some are Darwinnars.
16:27:10 <omnId> erm, s/omnId/keseldude/ :S
16:27:10 <shachaf> @poll-list
16:27:10 <lambdabot> ["LuaEmbeddingIntoHaskell","TorrentifyHW2007Videos"]
16:27:17 <paczesiowa> that looks like it should make some sense to someone smarter than me:P
16:27:25 <omnId> omnId: how are you today, omnId?
16:27:34 <omnId> omnId: fine, thanks.
16:27:57 <oerjan> oerjan: why is omnId talking to himself?
16:27:59 <liyang> (a monad transformer being of the kind (* -> *) -> (* -> *) )
16:28:02 <oerjan> oerjan: i don't know.
16:28:07 <liyang> oerjan: insanity.
16:28:09 <paczesiowa> but maybe I'll ask most important question, do I really need StateT, ListT and IO to implement prolog interpreter?
16:28:20 <liyang> oerjan: it's the guaranteed tell-tell sign.
16:28:28 <omnId> tell-*tale*
16:28:31 <shachaf> omnId: Talking to yourself is a bad habit for a dungeoneer.
16:28:34 <faxathisia> ?djinn <('o'<)
16:28:34 <lambdabot> Cannot parse command
16:28:37 <oerjan> oerjan: i think liyang may be right.
16:28:40 <liyang> omnId: :)
16:29:10 <bakert> omnId, keseldude: is it me or is haskell crying out for the most killerest ide wot there ever was?  static typing + ide = good.  right?
16:29:19 * liyang is attempting to hack something together but is being distracted by you bad people.
16:29:23 <oerjan> paczesiowa: in principle you can do all the plumbing yourself other than IO
16:29:42 <shachaf> bakert: Static typing + vim = good.
16:29:51 <Cale> bakert: It ought to be possible to do something fairly nice
16:30:05 <cjay> vim + plugins = almost ide
16:30:05 <bakert> i'm writing my haskell in vim at the moment shachaf but i don't use any haskell specificness
16:30:15 <mrd> get Reinke's plugins
16:30:32 <mrd> @go haskell for vim reinke
16:30:34 <Cale> bakert: It'd also be cool to have something which understands the layout rule, and allows you to adjust the position of blocks dynamically
16:30:35 <lambdabot> http://www.haskell.org/
16:30:35 <lambdabot> Title: Haskell - HaskellWiki
16:30:37 <mrd> blah
16:30:54 <shachaf> @go haskell vim
16:30:55 <lambdabot> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
16:30:55 <paczesiowa> oerjan: but that unification (or whatever that predicate evaluation is called in prolog) can give many values, and every value can result in IO, so I need lazy list of IO effects
16:30:55 <lambdabot> Title: Haskell mode for Vim
16:31:22 <bakert> Cale: development environments of all sorts totally fail to understand what i want them to do with indenting and wrapping.  in the future they won't believe we did it like this.  text editor macros or not.
16:31:25 <omnId> Cale: like the elastic tabstops thingy.
16:31:46 <Cale> omnId: yeah, but perhaps even a little more cleverly automatic
16:32:11 <oerjan> paczesiowa: i am not saying doing the plumbing yourself would be easier...
16:32:37 <Cale> The elastic tabstops thingy could almost do it on its own, if it could be trained to insert an elastic tabstop automatically before the first nonwhitespace character after certain keywords
16:33:00 <oerjan> paczesiowa: there is a LogicT monad somewhere
16:33:03 <omnId> Cale: put a tab there yourself and it'll do the right thing.
16:33:05 <faxathisia> paczesiowa: the unification just gives you a single MGU (There is only one), which is a substitution of varables to terms
16:33:17 <Cale> It still doesn't perfectly fit my mental model of how blocks are laid out though
16:33:33 <Cale> If you indent a block far enough, it should snap up a line.
16:33:59 <Cale> For instance, what happens when you indent the 'then' and 'else' further in:
16:34:00 <Cale> if foo
16:34:03 <Cale>    then bar
16:34:06 <Cale>    else quux
16:34:11 <Cale> You get:
16:34:17 <Cale> if foo then bar
16:34:23 <Cale>        else quux
16:35:02 <Cale> which should be possible to do just by dragging a little grey line to the left of the text :)
16:35:16 <Raguel> what do you guys write programs in?
16:35:24 <LoganCapaldo> haskell
16:35:27 <Raguel> ....
16:35:31 * LoganCapaldo ducks
16:35:32 <Cale> Raguel: you mean editor?
16:35:34 <Raguel> yeah
16:35:37 <Cale> I use vim and emacs mostly
16:35:39 <bakert_> vim
16:35:40 <Raguel> atm i'm using notepad
16:35:49 <faxathisia> Cale: you really use both?
16:35:51 <kpreid> TextMate
16:35:58 <TSC> cat
16:35:58 <Cale> Notepad isn't suitable, because it doesn't have an option to convert tabs to spaces
16:36:02 <paczesiowa> faxathisia: I know that, I meant that thing drawn as tree, with backtracking and stuff
16:36:05 <Cale> (as I recall)
16:36:10 <Cale> faxathisia: yeah
16:36:14 <faxathisia> how? :S
16:36:15 <Raguel> vim sounds like an energy drink ¬_¬
16:36:23 <paczesiowa> faxathisia: I don't know proper name, I even don't know prolog
16:36:28 <Raguel> should tabs be converted to spaces
16:36:29 <lament> Cale uses vim with one hand, and emacs with the other
16:36:29 <bakert_> that's just one of its qualities
16:36:39 <Raguel> and does it matter how many spaces you have?
16:36:42 <Cale> Raguel: yes, unless you like confusing syntax errors
16:36:53 <omnId> or you use { ; ; } all the time.
16:36:54 <Raguel> oooh i'm beginning to love them ;)
16:36:56 <LoganCapaldo> I hope Cale has 10 fingers on his emacs hand, or a third hand
16:37:08 <Cale> Raguel: tabs will otherwise align to the nearest following 8-space boundary
16:37:11 <bakert_> ok did Raguel just start text editor discussion followed by tabs/spaces?
16:37:26 <Cale> bakert: I started the tabs/spaces thing
16:37:27 <omnId> bakert_: I believe that's correct.
16:37:31 <bakert_> are you going to ask us which distro we like best next? :)
16:37:34 <Cale> hehe
16:37:44 <lament> okay, let's talk about abortions and the war in iraq!
16:37:46 <faxathisia> paczesiowa: I'd recommend  you read The Reasoned Schemer :)
16:37:50 <pjd> bakert_: BSD or GPL?
16:37:55 <bakert_> :)
16:37:58 * LoganCapaldo wants to read the unreasoned schemer
16:37:59 <Cale> Seriously, there's only one sensible answer to the tabs/spaces question in Haskell.
16:38:06 <omnId> paper or plastic?
16:38:07 <bakert_> (or anywhere)
16:38:09 <faxathisia> paczesiowa: They describe a really cool logic programming system, and the implementation uses a lot of concepts from haskell
16:38:10 <Apocalisp> Big end!
16:38:10 <Cale> That's to not have tab characters in your input files.
16:38:28 <Cale> I think ascii tab should be considered a lexical error.
16:38:34 <bakert_> :)
16:38:44 <Raguel> ok so if i'm indenting then i just use spaces
16:38:47 <oerjan> Cale: i half-expected the punchline to be "But no one can agree what it is."
16:38:52 <faxathisia> paczesiowa: + you get a good feel for Prolog, unification and such. Also I think this book is spawned from LogicT or there is some relation somewhere
16:39:04 <Cale> Raguel: What you want is an editor which will insert appropriate spaces when you press tab
16:39:07 <bakert_> Raguel: you should use a text editor that maps your tab key to a certain number of spaces (probably 4)
16:39:07 <ddarius> paczesiowa: You can model Prolog's evaluation however you like, you don't -have- to use lazy lists and state passing.
16:39:10 <lament> "<Cale> Seriously, there's only one sensible answer to the tabs/spaces question" -- similarly, there's only one sensible answer to the vim/emacs question :D
16:39:12 <faxathisia> (although the logic system is more advanced than prolog in a few ways)
16:39:15 <bakert_> Raguel: notepad ain't it.
16:39:33 <omnId> Cale: remember the compile-time constant evaluation I was talking about?
16:39:34 <Cale> Raguel: and treat multiple spaces as if they were a tab -- but it shouldn't write tabs into the file
16:39:41 <Raguel> okay beginning to see people are rather split over what to write it in
16:39:43 <Cale> omnId: any luck with that?
16:39:44 <bakert_> Raguel: ultraedit on windows is good.  i have mixed feelings about vim on windows.
16:39:53 <omnId> Cale: it's mostly finished, just some rough edges at the Constr/Exp boundary.
16:40:03 <Raguel> ultraedit?
16:40:07 <ddarius> Raguel: Any decent editor will work.  Use a decent editor.
16:40:08 <Cale> Raguel: well, get something other than notepad. I hear TextPad is popular on windows, but I'm not a windows user.
16:40:24 <Raguel> :S ultraedit, vim or textpad
16:40:28 <Raguel> any more to throw in?
16:40:34 <Cale> Raguel: If it has syntax colouring for Haskell and an option to convert tabs to spaces, it'll do.
16:40:34 <TSC> emacs...
16:40:55 <hpaste>  omnId annotated "Compile-time evaluation" with "ambiguous types from ints and reals, I'd like to not have to enumerate all the types." at http://hpaste.org/3584#a1
16:41:13 <Raguel> emacs, utraedit, vim, textpad ... but not notepad
16:41:22 <bakert_> yo
16:41:31 <Raguel> any advice on which one?
16:41:39 <bakert_> ho ho ho  ...
16:42:26 <Raguel> i get the feeling that people may have mixed feelings about them...
16:42:37 <Raguel> fiiiine, i have a pocket full of dice
16:42:40 <faxathisia> Raguel: I think you can only find out which one is best for you by trying them
16:42:41 <ddarius> Raguel: Just pick one.
16:43:03 <LoganCapaldo> pick an editor, any editor
16:43:18 <lament> if you don't care about comfort and have an excellent memory, emacs is probably the best by far
16:43:21 <bakert_> Raguel: the best plan is to install them all and switch between them typing one line at a time in each until you know which is best for you.  usually it can be decided within a few months.
16:43:40 <Raguel> good plan!
16:43:40 <keseldude> what would happen if i told lambdabot to writeFile ____ ____?
16:43:47 <ddarius> keseldude: Nothing.
16:43:49 <bakert_> blindfolded
16:43:52 <omnId> bakert_: for some values of "best" :)
16:43:52 <sorear> keseldude: it would print <IO ()>
16:43:57 <ddarius> > writeFile "passwd" ""
16:43:59 <lambdabot>  <IO ()>
16:44:09 <Raguel> cos this program i'm writing is throwing me a } error when i haven't got a }
16:44:16 <Raguel> program? line rather
16:44:17 <Apocalisp> Raguel: I'll come right out and recommend vim. Better yet: yi.
16:44:17 <omnId> lambdabot doesn't execute IO actions, that would be dangerous.
16:44:19 <Apocalisp> :-)
16:44:20 <Raguel> Seqn [Assign 'A' (Val 1), Assign 'B' (Val 10), While (Var 'B') (Seqn [Assign 'A'
16:44:20 <Raguel> (Mult (Var 'A') (Var 'B')), Assign 'B' (Add (Var 'B') (Val (-1)))])]
16:44:30 <keseldude> just because that's all it prints, doesn't mean that's all it does...
16:44:30 <Raguel> oh yeah
16:44:39 <lament> i tried to install yi a couple times, never quite succeeded
16:44:45 <omnId> keseldude: that's all it does.
16:44:51 <keseldude> but that probably is all it does
16:44:58 <paczesiowa> so, I'm not the only one writing interpreter this weekend:>
16:45:25 <ddarius> paczesiowa: I assure paczesiowa that there are several people right this minute that are working on interpreters.
16:45:27 <omnId> Cale: any ideas?
16:45:40 <ddarius> + \you,
16:45:43 <Cale> @remember bakert [On text editors] The best plan is to install them all and switch between them typing one line at a time in each until you know which is best for you.  Usually it can be decided within a few months.
16:45:43 <lambdabot> Good to know.
16:45:45 <ddarius> Bah.
16:46:11 * ddarius preferred the old lambdabot.
16:46:19 <monochrom> It's the same question as "what is the best Haskell book or tutorial?"
16:46:29 <Raguel> what's darcs
16:46:29 <keseldude> yaht
16:46:31 <bakert_> ddarius: are you auditioning for resident curmudgeon?
16:46:38 <paczesiowa> ddarius: you too?
16:46:41 <faxathisia> Raguel: RVCS
16:46:41 <oerjan> Raguel: those } errors are very often an artifact of haskell's layout to {;} translation rule, i think
16:46:45 <omnId> Raguel: a versioning system.
16:46:52 <ddarius> @google site:tunes.org ddarius curmudgeonly
16:46:53 <lambdabot> No Result Found.
16:46:57 <ddarius> Bah
16:47:06 <jeffz> monochrom, that one is easy... the Monad Reader suggests Grapham Hutton's book as _the recommended_ introductory book
16:47:06 <Cale> omnId: Not really ;)
16:47:09 <ddarius> @google site:tunes.org ddarius curmudgeon
16:47:10 <lambdabot> No Result Found.
16:47:22 <ddarius> I think that was in #haskell-blah
16:47:23 <omnId> Cale: yeah, but it sounds safe :)
16:47:32 <omnId> and familiar
16:47:38 <bakert_>  ddarius: embrace change!
16:47:50 <Cale> (I mean about ideas regarding that code)
16:47:54 <ddarius> bakert_: change is scary
16:48:01 <Raguel> oerjan: wha?
16:48:03 <omnId> Cale: oh, well, uh, hmm
16:48:14 <Cale> (I've missed a bunch of this discussion due to distraction too :)
16:48:22 <Saizan_> omnId: -fno-monomorphism-restriction?
16:48:34 <ddarius> Cale: You didn't miss much.
16:48:38 <omnId> I've not hit the MR, I don't think.
16:48:39 <monochrom> bakert_: embrace state mutation? :)
16:48:48 <bakert_> :)
16:48:59 <Apocalisp> Embrace the State!
16:49:14 <Cale> Raguel: once you're sure about the no tabs thing, the golden rule of Haskell indentation is to indent things deeper if they're "inside" the things on previous lines, and indent them the same if they're on the same level.
16:49:19 <omnId> Saizan_: in any case, no luck
16:49:19 <oerjan> Raguel: all that indentation stuff in haskell is in principle translated into { ; and } delimiters internally.  unfortunately ghc sometimes applies this translation before giving error messages, which can be confusing.
16:49:50 <oerjan> i.e. you get messages about } even if your code contains none
16:50:01 <Cale> For example, the 'then' and 'else' are parts of an 'if' expression, so if they come on following lines, they should be indented deeper than the if, and they're at the same level as each other, so they should line up
16:50:05 <Raguel> how do i get hugs to stop trying to open a file it doesn't like
16:50:12 <monochrom> Embrace State! do { put 0; }  <--- put it inside braces!
16:50:21 <oerjan> Raguel: :l a different file
16:50:28 <oerjan> or just :l for no file
16:50:28 <Apocalisp> har
16:50:39 <omnId> maybe we should abolish layout and remove this class of error alltogether :P
16:50:56 <Cale> omnId: Heresy!
16:51:11 <ddarius> If we abolish programming in general, all classes of programming errors would cease to exist.
16:51:13 <monochrom> we should abolish tabs and layout and pico.
16:51:27 <omnId> ddarius: perfect!
16:51:31 <nominolo> what's pico?
16:51:33 <monochrom> I actually want to abolish programming by humans.
16:51:37 <nominolo> the editor?
16:51:40 <jeffz> nominolo: pine composer.
16:51:43 <faxathisia> if people don't program
16:51:45 <monochrom> pico is a poor editor.
16:51:46 <faxathisia> Who will write programs?
16:51:52 <monochrom> computers.
16:51:55 <faxathisia> :/
16:52:01 <faxathisia> I don't believe it's possible
16:52:07 <monochrom> You already let calculators do math for you.
16:52:10 <nominolo> Skynet"
16:52:18 <Apocalisp> Computation is not programming.
16:52:19 <faxathisia> computers will get all philosophical about it and never write any useful code
16:52:30 <monochrom> haha
16:52:31 <faxathisia> honestly they should not be trusted
16:52:44 <Raguel> evolution code!
16:52:51 <Raguel> you can already evolve circitry
16:53:00 <nominolo> will they also design the hardware?
16:53:02 <Raguel> (which should have at least one u in it somewhere)
16:53:11 <faxathisia> of course, for computers to write programs.. we need a person to write a program first yeah?
16:53:15 <faxathisia> Or is there a way out of this?
16:53:17 <monochrom> 50 years ago lots of people did not believe computers could do symbolic differentiation.
16:53:29 <bakert_> faxathisia: with time travel there is a way out
16:53:42 <faxathisia> well .. without being inside an 80s film.. is it possible? :p
16:53:43 <bakert_> kinda
16:53:44 <Raguel> designing stuff is an iterative process where you take what doesn't works, make a hundred variations, then take the best of them and make a hundred variations on it
16:54:08 <monochrom> That is called Natural Selection.
16:54:14 <Raguel> yup
16:54:18 <nominolo> evolution
16:54:18 <Raguel> apply it to programming
16:54:20 <faxathisia> I think this means we are forever to be the ones programming
16:54:27 <monochrom> Methinks you atheists take Evolution too far.
16:54:32 <faxathisia> Just we'll automate more and more
16:54:46 <Apocalisp> You'll always need a volitional creature to bootstrap the process. ;-)
16:54:51 <bakert_> faxathisia: great scott!  that's something i wouldn't want to have to find out.
16:55:06 <nominolo> monochrom: how so?
16:55:07 <monochrom> I believe in Intelligent Design for programming, and I actually practice it with great success.
16:55:24 <Raguel> i want to code evolutionary design and have computers make things that work REALLY well
16:55:39 <bakert_> why is this invalid:
16:55:48 <nominolo> monochrom: that actually shows that intelligent design might be quicker, but really buggy
16:55:48 <bakert_> f (x y) = (x y)
16:56:14 <Raguel> is that a trick question of sorts or a genuine one?
16:56:20 <Lemmih> bakert_: Did you mean: f x y = x y?
16:56:22 <Raguel> cos i get asked things like that all the time :(
16:56:22 <faxathisia> bakert_: Well I think it's wrong because (x y) is not a valid name for a parameter
16:56:28 <faxathisia> bakert_: But what did you want to code?
16:56:36 <bakert_> i want (x y) to pattern match a type
16:56:43 <faxathisia> which type?
16:56:47 <bakert_> data Foo = Bar String
16:56:59 <faxathisia> f (Bar x) = ..
16:56:59 <faxathisia> ?
16:57:10 <bakert_> what about
16:57:25 <bakert_> data Foo = Bar String | Baz String | Quux String ?
16:57:33 <bakert_> :)
16:57:38 <idnar> you can't have a "variable" type constructor
16:57:48 <faxathisia> f (Bar x) = ... f (Baz x) = ...
16:57:56 <bakert_> i can!  (please mom, can i?)
16:57:57 <idnar> if I understand correctly, you want "x" to stand in the place of Bar, Baz, or Quux?
16:57:59 <oerjan> > constr (Just "hah!")
16:58:00 <lambdabot>   Not in scope: `constr'
16:58:00 <bakert_> yes
16:58:19 <omnId> > toConstr (Just "heh.")
16:58:20 <lambdabot>   Not in scope: `toConstr'
16:58:30 <omnId> > Data.Generics.toConstr (Just "bah.")
16:58:31 <lambdabot>  Just
16:58:38 <bakert_> ooh la la
16:58:55 <omnId> bakert_: way much more of a sledgehammer than you need.
16:58:59 <nominolo> you could generalize pattern matching, but you'd lose information, like if all patterns were matched
16:59:00 <Raguel> so are there no set rules on how far you should indent (4 spaces vs 5 etc)
16:59:07 <bakert_> lol
16:59:10 <bakert_> indeed
16:59:30 <Raguel> but it matters if i have one line 4 then the next 5 (when they should be the same) ?
16:59:47 <oerjan> Raguel: yep
16:59:53 <LoganCapaldo> data Foo = Bar { unFoo :: String } | Baz { unFoo :: String } | Quux { unFoo :: String }; f x = doStuff (unFoo x)
16:59:58 * Raguel has vim up and running
17:00:07 <omnId> Raguel: the first token on the first line sets the indentation level.  Subsequent lines must match that level.
17:00:21 <Raguel> cool!
17:00:26 <faxathisia> LoganCapaldo: OOOOhhhhh :D
17:00:27 <faxathisia> nice
17:00:37 <omnId> so you could indent 38 spaces, so long as the lines after indent by 38 spaces, too
17:00:42 <LoganCapaldo> only works if if they're all the same type of course
17:00:48 <Raguel> and the whole language is case sensitive throughout
17:00:52 <bakert_> LoganCapaldo: will that work with them all having the same name?
17:01:02 <LoganCapaldo> unFoo?
17:01:04 <bakert_> unFoo i mean
17:01:04 <LoganCapaldo> yes
17:01:06 <Raguel> is it just a convention that functions begin with a capital?
17:01:08 <bakert_> coooool
17:01:12 <faxathisia> Raguel: No
17:01:23 * LoganCapaldo learned that trick in this channel
17:01:24 <faxathisia> Raguel: They start with lowercase
17:01:26 <omnId> LoganCapaldo: I was going to suggest that, but I think field constructors must have different *sets* of field labels (they can share some names, though)
17:01:40 <faxathisia> Raguel: Type constructors start with uppercase
17:01:41 <Raguel> what was it that starts with a capital then?
17:01:44 <Raguel> ah
17:01:51 <monochrom> nominolo: The quality of Intelligent Design depends on the designer, of course. Someone who uses "intuition" will be buggy. Someone like Bird who "calculates" will be much better.
17:01:53 <LoganCapaldo> omnId: I'm pretty sure that works
17:02:01 <LoganCapaldo> It's come up before
17:02:08 <Raguel> like if i wanted to define while it would be While Expr Prog
17:02:15 <Cale> Also, data constructors start with an uppercase letter
17:02:21 <Raguel> erm is Expr a valid thingy?
17:02:31 <faxathisia> you could define a type called Expr
17:02:32 <Raguel> (thingy IS a technical term :P)
17:02:33 <Cale> but not functions
17:02:37 <ddarius> omnId: What are you talking about?
17:02:42 <omnId> LoganCapaldo: I tested, I was wrong.
17:02:52 <omnId> ddarius: I thought I'd heard something like that.
17:02:58 <LoganCapaldo> omnId: Oh good
17:03:01 <Cale> Raguel: what do you intend While, Expr, and Prog to be?
17:03:04 * LoganCapaldo stops starting to test
17:03:07 <bakert_> LoganCapaldo: that doesn't help me get teh Bar/Baz/Quux value though?
17:03:22 <LoganCapaldo> No it won't tell you which of the three
17:03:27 <Raguel> one sec and i'll paste it in to your webthing
17:03:50 <Cale> Raguel: If it's abstract syntax for some program, then that looks like maybe part of a data declaration for Prog
17:03:51 <ddarius> omnId: Haskell has a tendency to not have "corner cases".  Rules often apply generally even beyond what you might expect.
17:03:56 <bakert_> LoganCapaldo: ah.  i want to replace the value of unFoo but leave the outside bit (constructor?) unchanged
17:04:01 <ddarius> E.g. class C a | -> a
17:04:05 <Raguel> cale: it is!
17:04:06 <bakert_> ah but i can do that with pattern matching
17:04:20 <Cale> Raguel: then While would be a data constructor, and Expr, Prog would be types
17:04:22 <oerjan> bakert_: x { unFoo = ... }
17:04:25 <nominolo> monochrom: but it assumes the underlying algebra makes sense
17:04:29 <bakert_> f x = x { unFoo = "blah" }
17:04:32 <bakert_> oerjan: yes!
17:04:34 <bakert_> :)
17:04:48 <bakert_> coooool
17:04:52 <monochrom> Yes, the algebra needs a soundness proof.
17:04:59 <hpaste>  Raguel pasted "Attempt 2" at http://hpaste.org/3590
17:05:34 <bakert_> ooh this good.  thanks LoganCapaldo !
17:05:41 <Raguel> now i get the feeling i'm going to have to have the definition of some more things...
17:05:43 <omnId> Raguel: you need some type with Val and Var constructors.
17:05:52 <Raguel> yeah starting with them
17:05:56 <Raguel> Expr?
17:05:57 <oerjan> Raguel: you are definitely mixing tabs and spaces
17:06:06 <Raguel> there are no tabs there
17:06:13 <Raguel> data Prog = Assign Char Expr
17:06:13 <Raguel>           | Seqn [Prog]
17:06:13 <Raguel> 	  | If Expr Prog Prog
17:06:13 <Raguel>           | While Expr Prog
17:06:13 <Raguel> 	  | Done
17:06:14 <Raguel> 	  deriving Show
17:06:16 <Raguel> Seqn [Assign 'A' (Val 1), Assign 'B' (Val 10), While (Var 'B') (Seqn [Assign 'A' (Mult (Var 'A') (Var 'B')), Assign 'B' (Add (Var 'B') (Val (-1)))])
17:06:19 <Raguel> bleh
17:06:23 <Raguel> that was supposed to be something else
17:06:37 <Cale> Raguel: there are tabs in your paste
17:06:43 <faxathisia> Raguel: That looks a bit more like haskell
17:06:53 <omnId> faxathisia: =D
17:06:57 <Raguel> i'm getting there!
17:06:59 <oerjan> otoh it should not matter in your case, since you have no layout blocks
17:07:14 <faxathisia> ah so you are writing an interpreter for the language you pasted earlier
17:07:21 <faxathisia> Raguel: now it makes sense :p
17:07:30 <omnId> looks like just an AST for now
17:07:45 <Raguel> i'm not
17:07:52 <Raguel> i'm just skipping over to the next slide
17:07:57 <Raguel> which makes slightly more sense...
17:08:47 <oerjan> Raguel: note if you are pasting related things, you can use the annotate button
17:08:54 <omnId> Raguel: haskell files are made of top level declarations, not expressions, so that big AST should either go in a definition: 'exampleAst = Seqn [...]', or you could enter it at the hugs prompt.
17:09:47 <Raguel> AST?
17:09:54 <omnId> abstract syntax tree
17:10:04 <omnId> vals and vars and assigns and whatnot.
17:10:09 <Raguel> ah
17:10:27 <faxathisia> hmm
17:10:43 <faxathisia> Other than by what-I-suppose-is-the-right thing
17:10:56 <faxathisia> How do you turn this kind of diagram into code http://img236.imageshack.us/img236/7859/picture5ov5.png
17:11:27 <Raguel> i have a headache from that
17:11:31 <Raguel> oooor from ephedra
17:11:39 <omnId> lol, AssVar
17:11:50 <Beelsebob> faxathisia: with a lot of thought, but not too much trouble
17:11:52 * omnId runs away
17:12:24 <Raguel> can anyone expain very simply what deriving Show does
17:12:28 <Raguel> and how often it is needed?
17:12:48 <oerjan> Raguel: it makes haskell automatically make functions for printing your type
17:12:49 <faxathisia> Raguel: when you define some data types, deriving Show will automatically create an Show instance for them
17:12:51 <omnId> Raguel: it writes a function 'show' that turns you values into strings.
17:13:29 <omnId> data A = B | C deriving (Show) ---> instance Show A where show B = "B"; show C = "C"
17:13:31 <Raguel> and do i need it at the end of every expression declaration or just the last one?
17:13:51 <omnId> Raguel: just datatype declarations that you want to turn to strings.
17:13:59 <oerjan> just at the end of each data ... = ...
17:14:00 <omnId> *the values of which,
17:14:37 <Raguel> y'know hugs is still bitching about a
17:14:40 <Raguel> }
17:14:54 <faxathisia> you can hpaste.org
17:14:55 <faxathisia> if you like
17:14:58 <omnId> Raguel: put the example AST into a declaration like I told you.
17:15:02 <oerjan> Raguel: don't mind } it just means _some_ syntax error there
17:15:17 <oerjan> the } is a red herring usually
17:15:27 <Raguel> ah so its just "you ballsed SOMETHING up" not specifically }
17:15:42 <oerjan> Raguel: as i tried to explain earlier :)
17:15:49 <omnId> you can't have that AST just sitting there in the toplevel.  It needs to belong to a name.
17:15:52 <Cale> Raguel: well, the Haskell interpreter/compiler adds braces and semicolons to your code according to layout
17:15:53 <hpaste>  Raguel annotated "Attempt 2" with "(no title)" at http://hpaste.org/3590#a1
17:16:11 <Raguel> thats what i'm trying to put into hugs
17:16:16 <faxathisia> ah yeah, exactly what oerjan said
17:16:18 <faxathisia> you want,
17:16:23 <faxathisia> fib = Seqn ...
17:16:26 <bakert_> When you see an apostrophe on the end of a function what do you expect it to do relative to the function with the same name with no apostrophe?
17:16:46 <monochrom> they are related. but I'd read the fine print.
17:16:49 <hpaste>  omnId annotated "Attempt 2" with "files hold declarations." at http://hpaste.org/3590#a2
17:16:54 <oerjan> Raguel: all except the last line looks fine for putting in a file
17:17:04 <hpaste>  notyouravgjoel pasted "troubling novice issue" at http://hpaste.org/3591
17:17:06 <oerjan> the last line you could give to hugs command line
17:17:12 <Cale> Raguel: that last line is just an expression, it's not a declaration. You have to give it a name.
17:17:25 <notyouravgjoel> If you guys don't mind taking a look at that, i'd really appreaciate it. I've been having a ton of problems with the code
17:17:26 <omnId> notyouravgjoel: liftM read
17:17:44 <omnId> notyouravgjoel: or let num = read n
17:17:46 <Raguel> aah i see
17:18:05 <monochrom> notyouravgjoel: Either "let num = read n" or "num <- readIO n"
17:18:08 <faxathisia> notyouravgjoel: "0" is a string, but you probably want a list of numbers?
17:18:10 <Raguel> wootations!
17:18:11 <Raguel> it works :)
17:18:15 <Cale> notyouravgjoel: read n isn't an IO action, so you don't need to run it with <- syntax
17:18:17 <notyouravgjoel> ugh
17:18:18 <faxathisia> notyouravgjoel: So I think you should compare equality with 0 instead
17:18:29 <monochrom> plus what faxathisia says :)
17:18:54 <omnId> @src readLn
17:18:54 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
17:19:01 <omnId> ^^ that does what you want
17:19:18 * Raguel twitches
17:19:24 <notyouravgjoel> thanks
17:19:32 <notyouravgjoel> so, <- is only for IO?
17:19:32 <Cale> Why not readLn, if you're going to do that?
17:19:34 <Raguel> it printed out what fib was
17:19:42 <Cale> notyouravgjoel: For now, yes :)
17:19:42 <Raguel> not the numerical solution
17:20:03 <Cale> notyouravgjoel: The do-syntax is actually more general, but you don't have to care yet, unless you want to :)
17:20:04 <faxathisia> Raguel: haskell doesn't figure out interpreters based no data types :P
17:20:18 <LoganCapaldo> it should though
17:20:21 <omnId> Raguel: right.  You have an abstract syntax tree that represets a program.  You'll need to write an interpreter to execute that program.
17:20:22 <Cale> LoganCapaldo: hehe
17:20:22 <LoganCapaldo> via magic
17:20:26 <notyouravgjoel> i dont =) i'm only trying to go through this tutorial
17:20:55 <Raguel> right
17:20:58 <Cale> notyouravgjoel: When you get to the stuff on monads, ask me, and I'll get you some other tutorials to look at, if you find that one confusing.
17:21:05 <LoganCapaldo> data ... = ... deriving Interpreter
17:21:05 <Raguel> so i'm gonna have to prod it to get it to actually do something
17:21:12 <omnId> LoganCapaldo: ;p
17:21:18 <Cale> notyouravgjoel: Also, you might be interested in a short intro to IO I wrote
17:21:19 <faxathisia> LoganCapaldo: *lol*
17:21:23 <Cale> (very short)
17:21:31 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
17:21:32 <lambdabot> Title: Introduction to IO - HaskellWiki
17:21:40 <oerjan> @remember LoganCapaldo data ... = ... deriving Interpreter
17:21:40 <lambdabot> Nice!
17:21:53 <notyouravgjoel> atm im going through this http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fdarcs.haskell.org%2Fyaht%2Fyaht.pdf&ei=k20qR8-HEpzAxAKurNSOAQ&usg=AFQjCNGHcSjamIu9LJ1bBP-VNRuwoef1mQ&sig2=Fo8Hp6KkZ-JBSx_kHri-3g
17:21:55 <omnId> LB approves, Logan
17:21:55 <lambdabot> http://tinyurl.com/2bh434
17:21:56 <notyouravgjoel> err?
17:22:08 <Cale> notyouravgjoel: yeah, I can tell ;)
17:22:34 <notyouravgjoel> oh well then =)
17:23:06 <Cale> (YAHT is one of the major recommended ones)
17:23:25 <ddarius> "Coherence is the key to efficient rendering."
17:23:39 <Raguel> deriving Interpreter eh?
17:23:40 <Raguel> hmm
17:23:54 <Raguel> replace the deriving Shows with Interpreters?
17:23:58 <Cale> Raguel: it's a joke of course ;)
17:24:06 <notyouravgjoel> ah, well... I'm still having trouble. =) I'm working through it though
17:24:09 <Raguel> mrew :(
17:24:19 <Raguel> oookay so whats and interpreter?
17:24:33 <faxathisia> O_o
17:24:42 <faxathisia> Raguel: I think you just wrote 1/3rd of one
17:24:43 <Cale> Raguel: You've written a data type which seems to want to represent code for some programming language
17:24:49 <omnId> hugs is a haskell interpreter.
17:24:58 <omnId> (compiler, really, but whatever)
17:25:11 <ddarius> omnId: It's barely a compiler.  Interpreter is fine.
17:25:14 <Raguel> well i've taken the code i posted up
17:25:23 <Cale> Raguel: the rest of the interpreter is something to take that code, and act on it. (Perhaps along with something which turns text into that data structure)
17:25:24 <Raguel> and trying to get it to just RUN
17:25:35 <Raguel> hmm
17:25:38 <Cale> Raguel: It's just a data structure, what do you expect it to do?
17:25:47 <Raguel> it to run the function fib
17:25:50 <Raguel> which is at the bottom
17:26:06 <omnId> > [Just 1, Just 2, Nothing, Just 3] -- darnit, why doesn't this do what I want!
17:26:08 <lambdabot>  [Just 1,Just 2,Nothing,Just 3]
17:26:20 <omnId> it's just data.
17:26:22 <Raguel> fib = Seqn [Assign 'A' (Val 1), Assign 'B' (Val 10), While (Var 'B') (Seqn [Assign 'A' (Mult (Var 'A') (Var 'B')), Assign 'B' (Add (Var 'B') (Val (-1)))])]
17:26:26 <Cale> Raguel: but that's not a Haskell function, it's a data structure which represents the fib function in some language you're designing
17:26:31 <Raguel> is that not a function?
17:26:34 <Cale> no
17:26:38 <Cale> It's just a value
17:26:39 <faxathisia> I thought it is a function of zero arguments
17:26:41 <Raguel> oh
17:26:42 <Raguel> doh
17:26:43 <Raguel> hmm
17:26:47 <idnar> faxathisia: semantics!
17:26:49 <omnId> faxathisia: same diff :)
17:26:58 <Raguel> i'm doing semantics
17:27:05 <Raguel> semantics has no same differences :(
17:27:07 <Cale> I only consider something to be a function if it has an (->) at the top level of its type ;)
17:27:13 <chessguy> Raguel, you need something like eval :: Program -> Primitive
17:27:14 <omnId> Raguel: it's data.  If you need help starting out writing an interpreter, ask your prof.
17:27:36 <Cale> Raguel: Yeah, if this is for a course, you might want to read over the assignment problem specification again
17:27:38 <omnId> they're aren't exactly *trivial* things to write.
17:28:09 <Raguel> assignment problem works on the assumption that i can implement that code in haskell...
17:28:12 <chessguy> interpreters are easy to write. it's coming up with a language worth interpreting that's hard to do
17:28:20 <LoganCapaldo> what chessguy said
17:28:22 <Cale> Raguel: It seems like you may have misunderstood the task -- if the goal was just to write fib in Haskell, none of this data declaration stuff would be necessary
17:28:35 <Raguel> this is what happens when you skip modules
17:28:37 <omnId> chessguy: they aren't if you don't know the language well enough to express a functio :/
17:28:39 <Raguel> the task wasn't to write fib
17:28:42 <omnId> +n
17:28:44 <Raguel> thats just the first step...
17:29:10 <Cale> Raguel: the data structure there appears to be an abstract syntax tree for fib in some imperative language
17:29:21 <omnId> Raguel: maybe you should go back to the last module and learn Haskell first :)
17:29:39 <Raguel> the task is to use ptree and write a program to calculate the number of transitions in the tree for that program
17:29:53 <faxathisia> How do you usually represent the store of an interpeter
17:29:54 <omnId> o_O
17:30:03 <faxathisia> like a Data.Map or something of the variables -> values?
17:30:14 <omnId> faxathisia: yeah, Map usually
17:30:20 <Cale> notyouravgjoel: Let me know if that Introduction to IO article helps or if it's nonsense :)
17:30:28 <ddarius> Cale: Names can be deceiving.  It's not the fibonacci function.
17:30:41 <Raguel> yeah - its factorial
17:30:49 <Cale> ddarius: yeah, I didn't actually interpret it myself :)
17:30:58 <Raguel> for some reason it was in the notes as fibonacci and i've kinda stuck with it for NO reason
17:31:00 <Cale> okay, factorial then :)
17:31:07 <omnId> Cale: how dare you for taking a name at face value!
17:31:17 <idnar> fibbonactiorial
17:31:26 <Raguel> lol
17:31:31 <chessguy> factonacci
17:31:36 <omnId> A = 10!
17:31:39 <omnId> http://hpaste.org/3587
17:31:40 <LoganCapaldo> sounds like a pasta
17:31:57 <hpaste>  faxathisia annotated ""fibonaccci"" with "actual fib" at http://hpaste.org/3587#a2
17:32:01 <faxathisia> theye :)
17:32:18 <dino-> haha, I was just thinking that. Fibonaccioli
17:32:24 <Raguel> this is what happens when you cross operational somantics with haskell
17:32:38 <Raguel> assuming that the student knows enough of them both to pick them apart
17:32:59 <ddarius> Perhaps the instructor assumes that the students will attend class.
17:33:04 <Raguel> rofl
17:33:10 <Cale> > let fibbonactorial 0 = 0; fibbonactorial 1 = 1; fibbonactorial n = n * (fibbonactorial (n-1) + fibbonactorial (n-2)) in map fibbonactorial [1..10]
17:33:15 <Raguel> the instructor assumes that the students are comp sci students
17:33:19 <lambdabot>  [1,2,9,44,265,1854,14833,133496,1334961,14684570]
17:33:26 <Raguel> :|
17:33:35 <monochrom> And you are a political science student?
17:33:36 <faxathisia> lol
17:33:41 <omnId> ddarius: how presumptuous.
17:33:42 <Raguel> mono: rofl
17:33:50 <Raguel> mechanical engineer
17:34:07 <Raguel> who wants to learn functional programming on a whim
17:34:12 <chessguy> that may be one of the few degrees more difficult than computer science
17:34:19 <Raguel> it is
17:34:20 <Cale> > Math.OEIS.describeSequence [1,2,9,44,265,1854,14833,133496,1334961]
17:34:21 <lambdabot>   Not in scope: `Math.OEIS.describeSequence'
17:34:27 <omnId> it takes more effort than a "whin" would likely entail.
17:34:33 <omnId> whim*, even
17:34:35 <Cale> Well? Why isn't it in scope yet?
17:34:36 <Cale> hehe
17:34:45 <Raguel> well hence me actually working ;)
17:35:02 <Raguel> and why i'm up at 12:30 trying to figure out haskell instead of in bed with my gf
17:35:11 <faxathisia> :O
17:35:11 <omnId> Cale: does the module have a local copy of the database or does it download or what?
17:35:14 <faxathisia> nice idea
17:35:26 <Raguel> i would be reading journal papers on double collocation methods in radial basic functions
17:35:36 <Raguel> which is something that i know more about than ANY of you
17:35:37 <Raguel> siiiince
17:35:39 <Cale> hey, that fibbonactorial function actually appears to be useful
17:35:48 <Raguel> if you knew anything about it - i'd know who you were :P
17:36:05 * Raguel enjoys being in a restrictive school of science
17:36:08 <Cale> It's the number of derangements!
17:36:08 <Raguel> buuut
17:36:19 <Raguel> how deranged i am?
17:36:25 <Raguel> umm... yes!
17:36:51 <Raguel> wait a min
17:37:02 <Raguel> i've still not worked out what i'm doing with this program!
17:37:05 <Cale> (the one I defined)
17:37:10 <Raguel> yes...
17:37:15 <Raguel> where did you define it again?
17:37:20 <Cale> > let fibbonactorial 0 = 0; fibbonactorial 1 = 1; fibbonactorial n = n * (fibbonactorial (n-1) + fibbonactorial (n-2)) in map fibbonactorial [1..10]
17:37:20 <Raguel> not fibbonactorial :P
17:37:22 <lambdabot>  [1,2,9,44,265,1854,14833,133496,1334961,14684570]
17:37:53 <LoganCapaldo> I like that function
17:38:00 <Raguel> it is cute
17:38:06 <Raguel> but it isn't what i'm trying to do :(
17:38:45 <ddarius> This is the kind of stuff #haskell stumbles upon by accident.
17:38:51 <Raguel> now i have defined a little bit of language of prog and expr...
17:39:03 <oerjan> > let fl = 0:1:zipWith(*)[2..](zipWith(+)fl(tail fl)) in fl
17:39:05 <lambdabot>  [0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,3207...
17:39:20 <omnId> Raguel: so write a function 'interpret :: Prog -> State -> State'
17:39:27 <LoganCapaldo> now, someone define a combinator :: (Num a) => (a -> a) -> (a -> a) -> (a -> a) such that combinator fibonacci factorial is equivalent to fibonactorial :)
17:39:57 <LoganCapaldo> and \f g -> fibonactorial doesn't count :)
17:40:23 <Raguel> like interpret :: fib -> Val (n)
17:40:29 <Raguel> erm sans paren
17:40:55 <chessguy> fib is no a type
17:41:02 <chessguy> s/o/ot/
17:41:10 <omnId> interpret would be a function that takes an AST, a program start state, and interprets the AST to get a program end state.
17:41:22 <Raguel> ah
17:41:29 <LoganCapaldo> Olegcat is in yur type systems computing ur functions
17:41:31 <omnId> you'd have to write that function.
17:41:31 <monochrom> I don't think it's possible. fibonactorial mingles two recursions.
17:41:33 <idnar> LoganCapaldo: I really want to see that combinator now
17:41:34 <Raguel> fib :: int
17:41:39 <Raguel> since it doesn't take any arguments
17:41:48 <omnId> fib :: Int -> Int
17:41:53 <omnId> fib 10 :: Int
17:42:18 <chessguy> monochrom, such a negative attitude :)
17:42:25 <omnId> your fib, er fact, reperesents fact 10 in the variable A
17:42:35 <LoganCapaldo> wait if youchancge the type to (Arrow (->), Num a) => ... as above ...
17:42:41 <omnId> renamed that darned thing.
17:42:48 <omnId> rename*
17:42:52 <Raguel> it says fib is a prog and doesn't match type int...
17:43:05 <omnId> that's becasue fib is a Prog
17:43:10 <LoganCapaldo> *what if, not wait if
17:43:29 <monochrom> arrow doesn't help. the problem is the two inputs are black box functions (or black box arrows, or black box whatever), but the task needs to open up the black boxes and rewire things.
17:43:39 <chessguy> Raguel, what you need is something like interpret :: Prog -> Int
17:43:48 <chessguy> (assuming every program returns an int)
17:43:54 <omnId> Raguel: see?  You used the Seqn constructor to make fib, (RENAME IT TO FACT10!!), and Seqn's build Prog values.
17:43:57 <LoganCapaldo> My thought was you could come up with an instance for arrow that carried around the info abotu how it recursed
17:44:00 <LoganCapaldo> but I guess not
17:44:34 <oerjan> omnId: you mean fact10, don't be insensitive
17:44:39 <omnId> sorry
17:44:41 <omnId> :(
17:44:54 <omnId> (case insensitive :)
17:45:01 <Raguel> ¬_¬
17:45:43 <ddarius> Raguel: Go through a Haskell tutorial first and don't worry about this problem yet.
17:45:46 <Raguel> chessguy: when you say that do you mean fact10 :: Prog -> Int
17:45:52 <Raguel> well its due in at 9am tomorrow
17:45:53 <omnId> fact10 :: Prog
17:46:01 <omnId> Raguel: you're fucked.
17:46:04 <ddarius> Raguel: Heck, there is even one that would be particularly relevant, Scheme in 48 hours.
17:46:09 <chessguy> Raguel, no, i mean what i say
17:46:18 <ddarius> Raguel: What omnId said.  You don't have the background to do this at this point.
17:46:30 <Raguel> so?
17:46:35 <Raguel> i have a place to start
17:46:38 <Raguel> and a goal to aim at
17:46:43 <Raguel> what more does one need in life?
17:46:51 <faxathisia> Raguel: Why don't you just learn haskell and fail the course?
17:46:51 <Raguel> except a particularly interesting drug that negates the need for sleep
17:46:54 <omnId> time to learn.
17:46:58 <chessguy> Raguel, look, you have exampleAst, right? tell me what that is?
17:47:01 <omnId> that's what you need.
17:47:02 <faxathisia> Raguel: You don't need to do a course to learn haskell
17:47:10 <Raguel> damn straight i don't
17:47:15 <Raguel> thats why i'm not DOING that course
17:47:19 <Raguel> that course is functional programming
17:47:20 <ddarius> Raguel: Yes, but the best way to proceed at this point is to go read some introductions/tutorials not to poll this channel.
17:47:26 <Raguel> hmm
17:47:28 <Raguel> well i did
17:47:36 <Botje> Leading experts on haskell recommend at least twenty-four hours between brane asplosions.
17:47:37 <Raguel> i've read the first 6 chapters of this book
17:47:56 <stepcut> any got f# working on gutsy ?
17:48:08 <chessguy> Raguel, i'm willing to try to help you if you want
17:48:27 <LoganCapaldo> I like to keep the brain explosions all together. Smaller pieces of brain that way. This could be why I'm not a leading expert
17:48:49 <Raguel> mkay well i'm needing to interpret this program
17:49:09 <faxathisia> Raguel: you probably wanna use Data.Map
17:49:23 <faxathisia> to store values of variables
17:49:23 <ddarius> Raguel: You need to read a lot more of it and if this is your first programming language then you will need a -lot- more time.
17:49:33 <puusorsa> Raguel, "except a particularly interesting drug" .. you probably wanna use modafinil. or good old crystal meth!
17:49:34 <chessguy> Raguel, that's why you still need what i've told you several times you need. something like interpret :: Prog -> Int
17:49:36 <Raguel> I can write C
17:49:51 <faxathisia> (haskell isn't C)
17:49:55 <keseldude> lol
17:49:58 <Raguel> really?
17:50:01 <Raguel> oh well i'm fucked then
17:50:02 <Raguel> :P
17:50:06 <puusorsa> forgot "that negates the need for sleep"  .. neither is particularly interesting otherwise
17:50:06 <Raguel> anno its not ;)
17:50:13 * chessguy sighs
17:50:22 <monochrom> It is sometimes said that to learn haskell you have to unlearn c.
17:50:31 <puusorsa> or desoxypipradrol
17:50:32 <keseldude> nah
17:50:38 <Raguel> rofl
17:50:43 <keseldude> it's just a different way of thinking
17:50:43 <Raguel> i also need to learn fortran and matlab
17:50:47 <chessguy> @quote unlearn
17:50:47 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
17:50:50 <Raguel> but i don't need to know them till like... next week
17:50:58 <Raguel> maybe saturday
17:50:59 <faxathisia> hmm.....
17:51:09 <keseldude> how do you find all of these?
17:51:10 <omnId> plenty of time, then.  Er, I mean, ARE YOU CRAZY?
17:51:18 <puusorsa> ambition is good but i thiink you might be overdoing it
17:51:24 <monochrom> Plenty of time to go crazy. :)
17:51:30 <Raguel> well i'm attempting to go from 0 to PHD
17:51:37 <puusorsa> in a week?
17:51:37 <Japsu> Neo: "I know Matlab" Morpheus: "Show me!"
17:51:38 <faxathisia> in 60 seconds :D
17:51:40 <oerjan> keseldude: the quotes?
17:51:42 <Raguel> rofl
17:51:44 <dnox> dons: how is it going with hs-plugins?
17:51:51 <ricky_clarkson> 0 to PHD via rofl.
17:52:00 <Raguel> via splosions
17:52:15 <LoganCapaldo> I don't think rofl has the right kind
17:52:29 <chessguy> @quote kind
17:52:29 <lambdabot> JaffaCake says: I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
17:52:30 <oerjan> :k rofl
17:52:32 <lambdabot> Not in scope: type variable `rofl'
17:52:35 <keseldude> nvm.. i'm not really that interested
17:52:38 <omnId> ricky_clarkson: I so want to @remember that, but I don't want to the horribleness of it ascribe it to you.
17:52:51 <faxathisia> keseldude: What was your question
17:52:52 <Raguel> i also need to learn to use CFX, everything that is computational fluid dynamics, design a golf trolly, research sweep and ejection in turbulent boundry layers then write an essay on it and learn haskell up to the level where i'm not a complete noob
17:52:53 <ricky_clarkson> omnId: It's crap anyway.
17:52:56 <Raguel> .... BY NEXT WEEK
17:52:58 <ricky_clarkson> @quote clarkson
17:52:58 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
17:53:08 <Raguel> ps i have to work as a chef friday night and saturday
17:53:09 <ricky_clarkson> @quote ricky_clarkson
17:53:09 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
17:53:13 <ricky_clarkson> Oh, only whole words.
17:53:17 <LoganCapaldo> LOL
17:53:34 <monochrom> I can't configure Debian. I use Ubuntu. There.
17:53:44 <LoganCapaldo> that quote is so awesome I'd @remember it again if it weren't already remembered
17:53:47 <liyang> Raguel: given Graham's doing the Advanced FP course this semester, I kind of get the idea that this is not the particular course you're looking for... :3
17:53:52 <Botje> I _CAN_ configure Debian. I also use Ubuntu.
17:54:04 <Raguel> advanced FP is NEXT semester
17:54:07 <chessguy> @remember LoganCapaldo that quote is so awesome I'd @remember it again if it weren't already remembered
17:54:07 <lambdabot> It is stored.
17:54:10 <puusorsa> i prefer gentoo it's easier..
17:54:11 <liyang> (Raguel: ps -- what time is his lecture today?)
17:54:14 <pjd> i can't configure Ubuntu, so i use FreeBSD
17:54:15 <Japsu> I can't configure Debian so I use Gentoo.
17:54:20 <puusorsa> Japsu, <3
17:54:25 <Japsu> puusorsa: <3
17:54:29 <ricky_clarkson> I can't configure Debian so I use Vista.
17:54:31 <ricky_clarkson> AAGH
17:54:32 <liyang> Raguel: ... now I'm really confused. I thought Neil was taking the introductory FUN course.
17:54:34 <Raguel> today being friday - its 9am - business south
17:54:38 <Raguel> room 8 a?
17:54:45 <liyang> okay, I'm supposed to be in by 10 then.
17:54:57 <lament> indroduction to fun?
17:54:59 <liyang> (Cheers.)
17:55:03 <Raguel> a 7
17:55:19 <liyang> lament: Functional Programming. FUN is the TLA course code. Sorry. ^^
17:55:19 <puusorsa> you can't spell fungi without fun!
17:55:55 <liyang> (and I also thought that FUN was next semester. Hrm.)
17:55:59 <omnId> Toad is such a Fun Guy.
17:56:00 * Raguel seeks advanced fun timetable
17:56:04 <Raguel> fun is next semester
17:56:17 <monochrom> "take me take me to, fungi town!"
17:56:30 <oerjan> why is the fun always some time later?
17:56:37 <LoganCapaldo> The fun is always next semester
17:56:45 <monochrom> lazy evaluation :)
17:57:04 <Raguel> advanced fun is next semester too \0/
17:57:05 <monochrom> lazy list: the thunk is always one cons later. :)
17:57:18 <LoganCapaldo> fun -- the unevaluated continuation
17:57:38 <Raguel> and structural vibrations!
17:58:05 <Raguel> the concept is to get into PoP you don't NEED to know haskell
17:58:17 <Raguel> but you need it to understand wtf he's talking about
17:58:17 <monochrom> PoP = ?
17:58:21 <LoganCapaldo> @vera PoP
17:58:23 <lambdabot> *** "pop" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
17:58:23 <lambdabot> POP
17:58:23 <lambdabot>      Package for Online Programming
17:58:23 <lambdabot>  
17:58:23 <lambdabot> *** "pop" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
17:58:24 <Raguel> principals of programing
17:58:25 <lambdabot> [3 @more lines]
17:58:38 <liyang> Raguel: so how are you doing FUN this semester? o.O
17:58:43 <liyang> OH!.
17:58:56 <Raguel> now next semester i'm doing AFP
17:58:56 <liyang> Right. Yes. I know Graham's doing that this semester.
17:59:00 <Raguel> advanced fun
17:59:11 <lament> introduction to cocaine
17:59:13 <Raguel> for that you need to know haskell
17:59:22 <Raguel> but the trick is:
17:59:46 <Raguel> the amount of haskell needed to complete PoP is the same needed to START AFP
17:59:54 <monochrom> AFP is going to be tough.
17:59:59 <Raguel> but the amout needed to start PoP is 0
18:00:03 <Raguel> oh EVERYTHING is gonna be tough
18:00:15 <Raguel> its like throwing a kid in the deep end and telling him to swim
18:00:24 <chessguy> why in the world is a mechanical engineer taking advanced functional programming?
18:00:26 <Raguel> then when he starts to make progress, releasing the sharks
18:00:26 * ddarius highly recommends that approach for swimming.
18:00:34 <liyang> It's quite funny actually. Half the courses in the school is being taught by us FP Labbers. And we somehow manage to sneak Haskell into just about everything we teach. :D
18:00:39 <Raguel> i'm taking it because i want to :)
18:00:40 <puusorsa> that's how i learned to swim
18:00:48 <Raguel> and because i wanted to learn programming that wasn't lame
18:00:57 <chessguy> heh
18:01:00 <lament> that's how i learned to hunt sharks
18:01:02 <chessguy> well you came to the right place
18:01:04 <Raguel> :)
18:01:15 * liyang looked at the notes from the Operational Semantics course from his previous uni and my god. It was horrid.
18:01:30 <Raguel> ironically enough the plan was to also learn portugese
18:01:35 <Raguel> in a class full of people who speak spanish
18:01:41 <Raguel> with no prior knowledge
18:01:43 <ddarius> liyang: Why?
18:01:58 <Raguel> unfortunately that fell through when my school noticed i wasn't actually doing any mech eng modules ¬_¬
18:02:01 <LoganCapaldo> a priori protugesi
18:02:08 <lament> portuguese is easy when you know spanish
18:02:14 <Raguel> which i don't
18:02:18 <lament> oh
18:02:22 <Raguel> all i have is a portugese kitchen
18:02:25 <LoganCapaldo> Raguel: ae you sure you're in the right major?
18:02:33 <Raguel> nope :)
18:02:38 <Raguel> but i'm in my final year
18:02:39 <liyang> ddarius: opsem of OO-like languages. :3
18:03:06 <Raguel> and in theory - if i work hard enough and manage to pull my ass up to a 2:1 i can do a phd
18:03:12 <Raguel> otherwise its a beng
18:03:22 <Raguel> so it really is phd or broke
18:03:25 <liyang> ddarius: actually they are good notes, it's just the content that horrifies me. It was all incredibly intricate but essentially horrible.
18:03:26 <chessguy> what's 2:1?
18:03:32 <lament> Raguel: i'm in my final year of Math, my favourite course i'm taking right now is spanish art and literature, also the study of fossils is pretty cool :)
18:03:36 <Raguel> just under a 1st degree
18:03:45 <Raguel> rofl
18:03:57 <Raguel> well if i bum out i'll do psychology and philosophy
18:04:13 <lament> never got those
18:04:20 <lament> well, psych is fine
18:04:27 <lament> never got philosophy though
18:05:04 <Raguel> and chessguy - when you said i need interpret :: Prog -> Int did you mean something like fact10 :: Prog -> Int (ie the program's name)
18:05:44 <lament> "interpret is a function that takes a program and returns an integer"
18:05:49 <chessguy> no, you need to write a function, called something like interpret. the function will be of type Prog -> Int -- that is, it will take a Prog as input, and return an Int as a result
18:05:58 <omnId> Raguel: you would write a function interpret with type Prog -> State -> State, then the expression (interpret fact10 startingState) would evaluate your ast.
18:06:15 <liyang> Cale: flogging a long-dead horse, but I never use multi-line if-then-else constructs anymore these days because it totally buggers up the look of the code. case b of { True -> ... ; False -> ... } is so much prettier.
18:06:29 <omnId> and you'd end up with a final interpreter state after interpret does its thing.
18:07:21 <liyang> Cale: if forced to, I'd have to make myself write: (excuse the spam)
18:07:31 <liyang> if b
18:07:35 <liyang>     then
18:07:41 <liyang>         ...
18:07:46 <liyang>     else
18:07:48 <liyang>         ...
18:07:57 <liyang> (shoot me.)
18:07:58 <Cale> liyang: I don't understand how the case is significantly different from if then else when laid out the way I did it
18:08:05 <Cale> Why not
18:08:07 <Cale> if b
18:08:09 <liyang> case b of
18:08:09 <Cale>    then ...
18:08:13 <Cale>    else ...
18:08:33 <Cale> (why put the rest on a separate line?)
18:08:40 <liyang> Cale: that breaks down when you have "then do ..." :3
18:08:44 <Cale> no it doesn't
18:08:48 <Cale> if b
18:08:52 <Cale>    then do ...
18:08:55 <Cale>            ...
18:08:56 <Cale>            ...
18:09:02 <Cale>    else do ...
18:09:06 <Cale> and so on
18:09:20 <liyang> But I always use tabs for initial spaces. :)
18:09:25 <Cale> don't
18:09:35 <monochrom> tabs are evil
18:09:36 <Cale> Get your editor to convert them into spaces
18:09:45 <liyang> I like tabs.
18:09:49 <Raguel> do i need to put ; at the end of every line?
18:09:53 <profmakx> haskell doesnt
18:09:54 <Cale> Raguel: no
18:10:00 <Raguel> \0/
18:10:03 <liyang> And I always write them in a way so they don't break when you change tabspace setting.
18:10:04 * mrd attacks tabs
18:10:07 <LoganCapaldo> you can if you want to
18:10:10 <Cale> liyang: Really, tabs ought to be lexical errors
18:10:21 <liyang> and my vim shows my tabs differently from spaces.
18:10:51 <liyang> So I use tabs.
18:10:54 <liyang> Deal with it. ;)
18:10:57 <Raguel> Missing binding for variable "interpret" in type signature
18:11:04 * Raguel ponders
18:11:12 <Raguel> needs type!
18:11:18 <idnar> vim shows my tabs like ">-----" in blue text on a red background ;)
18:11:18 <Cale> You can use expandtab
18:11:28 <Raguel> nooo... it needs binding
18:11:43 * Raguel ties up with string
18:11:44 <Cale> liyang: I believe that's all you need in order to make it treat multiple spaces as if they were a tab as well
18:11:54 <pjd> idnar: not bold and blinking?
18:11:58 <idnar> pjd: nope
18:12:03 <pjd> for shame
18:12:06 <liyang> Cale: am aware of that. Would rather not. Say I want to change tabspace from my usual 4.
18:12:09 <Cale> liyang: I'm sure there is such an option, because my vim does that :)
18:12:09 <idnar> pjd: that's too annoying if I'm editing a makefile
18:12:12 <oerjan> Raguel: let me guess, you wrote interpret :: Prog -> Int and nothing else?
18:12:23 <Raguel> ¬_¬ maaaaybeeee...
18:12:28 <pjd> idnar: i would think the effect is redundant
18:12:31 <Raguel> i was trying to work out what step to take next
18:12:40 <liyang> Cale: can we just agree to disagree? :)
18:12:42 <oerjan> that is just the type declaration.  you need to write the actual function definition, annoyingly enough.
18:12:48 <idnar> pjd: hahaha
18:12:52 <Cale> liyang: you will end up confusing anyone who you send your code to, especially given that GHC treats your tabs as 8 spaces whether you like it or now
18:12:55 <Cale> not*
18:13:06 <oerjan> Raguel: there is a trick, you can write interpreter = undefined and expand as you go
18:13:17 <Raguel> as in what fact10 is or something else?
18:13:28 <liyang> Cale: I end up confusing anyone who tries to *edit* my code. It views perfectly fine however wide your tabs are.
18:13:28 <monochrom> Not just GHC. The Haskell standard is very specific about what happens to tabs, and GHC just conforms.
18:13:40 <Cale> well, yes
18:14:15 <Cale> ah, it's smarttab
18:14:22 <liyang> Cale: but TBH, most people who will eventually see the code will see it through lhs2TeX anyway. <grin>
18:14:55 <liyang> ( if they do at all. :3 )
18:15:06 <Cale> liyang: Really, what editors should be doing is parsing the code according to the layout rule, and displaying it in a configurable fashion.
18:15:09 <Raguel> is lhs2TeX a real thing or did a cat jump on your keyboard?
18:15:23 <LoganCapaldo> it's real
18:15:34 <LoganCapaldo> Literate haskell to TeX
18:15:37 <Raguel> thought so
18:15:40 <liyang> Cale: yes, but given the status quo, I find myself saner with my current choice. :)
18:15:42 <Cale> Short of that though, I think it's best that everyone sees exactly the same thing when they open the file :)
18:15:50 <lament> lhs means literate haskell, 2 means to, and TeX doesn't mean anything :)
18:15:56 <Cale> liyang: You should try spaces sometime, you might like it :)
18:16:12 <monochrom> http://groups.google.com/group/comp.lang.haskell/browse_frm/thread/e2aa728d9e42f981/d6f71cd66ffdc335#d6f71cd66ffdc335 is a true horror story of tabs.
18:16:12 <liyang> Cale: have done. Didn't. Really. :)
18:16:14 <lambdabot> Title: comp.lang.haskell | Google Groups, http://tinyurl.com/2eq9h5
18:16:24 <Cale> What was so bad about it?
18:16:28 <faxathisia> I like pressing tab and entering spaces with it
18:16:32 <liyang> I know, I've read all the arguments for/against it.
18:16:38 <faxathisia> this way you type several spaces at once
18:16:39 <chessguy> Raguel, you need to pattern match on the different kinds of programs
18:16:48 <Raguel> oh?
18:16:50 <faxathisia> imo that is ideal
18:17:05 <Cale> faxathisia: better yet, you can have backspace after a bunch of spaces act like those were a tab
18:17:19 <Raguel> pattern matching brings back memories of LOTS of regex
18:17:35 <chessguy> Raguel, you need to tell interpret what to do with an Assign, what to do with a Seqn, etc.
18:17:39 <liyang> but frankly, I'm an idealised situation where I'm the only one who has to deal with my code.
18:17:44 <Raguel> ah
18:17:47 <pjd> or use actual indent/dedent commands (CTRL-D / CTRL-T or <</>> in Vim)
18:17:55 <Raguel> like i have with Expr and Prog?
18:17:58 <liyang> So cross-editor compatibility isn't exactly a high priority.
18:18:08 <omnId> interpret (Assign var val) names = insert var (interpret val)
18:18:11 <idnar> pjd: don't those always indent a fixed amount?
18:18:24 <omnId> insert var (interpret val) names, rather
18:18:27 <pjd> idnar: they indent according to your indentation settings
18:18:30 <Cale> monochrom: good example :)
18:18:50 <pjd> but anywhere on the line (why should you have to manually edit the indentation itself?)
18:19:07 <omnId> Raguel: that pattern-matches on the (Assign _ _) constructor for Progs, then does what you would expect for an assignment.
18:19:18 <chessguy> Raguel, you haven't done any pattern matching yet
18:19:22 <liyang> Cale: for some reason, it irritates me when I see people laying out code looking like e.g.:
18:19:39 <liyang> if b then do x y z
18:19:49 <liyang>              a b c
18:20:20 <liyang> i.e. have a non-multiple of 'tabspace' spaces for indentation.
18:20:43 <liyang> Which means repeated bashing of the space bar in an attempt to align the buggers.
18:20:54 <LoganCapaldo> liyang would hate my code :)
18:21:07 <liyang> Sorry. Personal pet peeve.
18:21:23 <Raguel> do i need to define what Assign, Sequ, If, While and Done are?
18:21:34 <idnar> liyang: I guess you need a better editor ;)
18:21:34 <Excedrin> are there cases where tabs vs spaces cause similar looking code to be valid but different? (I've seen that in Python)
18:21:42 <liyang> I mean, I'd conform to other people's coding standards if I'm working with them, but for my own code I stick strictly to my own standards. :)
18:21:50 <omnId> Raguel: you need to define what the interpret function does with them.
18:22:01 <idnar> Excedrin: as long as you're displaying tabs as 8 spaces, it should be fine, because that's how they're treated
18:22:06 <Cale> liyang: If your editor is configured intelligently, it will continue the block with the same indentation
18:22:08 <liyang> idnar: something that understood Haskell syntax?
18:22:12 <idnar> Excedrin: so it's basically the same as python
18:22:17 <omnId> liyang: even my retarded windows editor has insert and delete spaces at beginning of line :)
18:22:29 <pjd> except Haskell is far more likely to catch it with type errors
18:22:29 <liyang> Cale: I usually leave lots of blank lines in long do-blocks.
18:22:30 <idnar> liyang: enough to figure out the necessary indentation, anyway
18:22:49 <Cale> liyang: i.e. pressing enter after the 'c' there should put the cursor in the same column as the the 'a', on the next line
18:23:06 <idnar> hmm, I slightly misread that question
18:23:08 <Cale> liyang: that's okay, so long as those blank lines have spaces in them
18:23:12 <liyang> And blank lines that look like blank lines but actually contain just spaces is another pet peeve.
18:23:16 <Cale> (which they will)
18:23:20 <idnar> Cale: you still have to make 'a' line up with 'x' though
18:23:31 <Cale> idnar: right, but you only do it once
18:23:32 <Raguel> oh god
18:23:40 <Raguel> i got my housemate sitting next to me saying "thats noobish"
18:23:45 <Raguel> about lazy evaluation
18:23:52 <Cale> and that's just pressing tab a few times, and then getting it right with spaces
18:23:53 <liyang> There's a funny story about invisible spaces in source files actually.
18:23:54 <monochrom> Theorem: The question "how much to indent the next line of code in Haskell" is undecidable.
18:23:59 <Cale> Raguel: huh?
18:24:10 <Cale> monochrom: heh
18:24:12 <Raguel> i was telling him what lazy evaluation is
18:24:22 <Raguel> he said that you can do that in c if you define the function properly
18:24:30 <Cale> Raguel: no you can't.
18:24:31 <liyang> But maybe I shouldn't tell it in public as it'd be bad publicity for my previous employers... :3
18:24:37 <Raguel> he says c++
18:24:41 <Raguel> and its a bitch appearantly
18:24:50 <Cale> Raguel: Well, you can simulate it, but it's not the same.
18:24:55 <Raguel> when i told him its hard coded into haskell he just said its noobish
18:25:01 <Raguel> he says he'll use a bubble sort
18:25:02 <Raguel> :P
18:25:09 <LoganCapaldo> you still can't do it in C++. not really/
18:25:11 <Raguel> and then goes on about how he programs in assembler
18:25:19 <Cale> All that lazy evaluation is, is outermost-first evaluation, plus sharing
18:25:25 <monochrom> <shrug> language pissing wars are a waste of time.
18:25:44 <faxathisia> monochrom: Only when you know both languages!
18:25:49 <pjd> who's shrug, and where did he say that?
18:25:52 <Cale> In strict languages like C and C++, parameters to functions are evaluated *before* being substituted into the function body
18:25:54 <Raguel> if i gave you a phone book and told you to find the first guy called bob lazy evalution would cut it simpler :)
18:26:02 <monochrom> OK, I know both languages, I guess that's why. :)
18:26:30 <Cale> In Haskell, the substitution is done first, and only if those subexpressions are reached, will they be evaluated
18:26:52 <Cale> (Is that how you explained lazy evaluation?)
18:26:52 <liyang> (Just a passing note to any students: when you copy and paste your mate's code, make sure you strip out any trailing spaces and/or strange mixes of tabs and spaces for indentation. Because in my editor, it's blatantly obvious when you plagiarise.)
18:26:59 <faxathisia> you can do lazy evaluation in C :P
18:27:02 <faxathisia> && and ||
18:27:06 * faxathisia hides
18:27:16 <idnar> liyang: your students don't use automatic formatting fuzzers?
18:27:17 <monochrom> Yes Cale.
18:27:21 <Cale> faxathisia: yes, now try writing a function 'and' which does that
18:27:31 <liyang> idnar: not my students here.
18:27:38 <idnar> liyang: heh
18:27:43 <Cale> monochrom: yes to what?
18:27:44 <liyang> idnar: sorry, I mean, I'm not talking about my students here.
18:27:57 <idnar> ah
18:27:58 <monochrom> to how to explain lazy evaluation as substitute first
18:28:07 <idnar> anyhow, I know some people who spent more time writing tools to cheat on coding assignments, than on doing the assignments
18:28:17 <Cale> monochrom: Oh, I was asking Raguel whether that's how he explained it.
18:28:26 <monochrom> darn
18:28:28 <oerjan> liyang: just tested in vim, and it doesn't put spaces in blank lines (but keeps indentation level afterward)
18:28:31 <Cale> (Maybe he didn't catch that?)
18:28:31 <faxathisia> idnar: I'm ok with that
18:28:48 <monochrom> I think when Raguel finishes this PoP course he will explain it well.
18:28:52 <liyang> oerjan: why can't you people just let me be! *sob*
18:29:00 <idnar> faxathisia: well, I think it suggests a failing on the part of the lecturer / course / whatever ;)
18:29:10 <Raguel> sorry still listening to my house mate (for some reason)
18:29:15 <Raguel> he's talking about pik processors
18:29:21 <Raguel> or something :S
18:29:24 <liyang> idnar: it just so happens that those who plagiarise tends to be those who don't have a clue (in general, and) about how we detect plagiarism.
18:29:28 <SamB> idnar: isn't that how you are SUPPOSED to do programming?
18:29:29 <Cale> Raguel: If you want, I can properly explain what lazy evaluation is, and why it doesn't happen in C.
18:29:47 <liyang> s/we/I/ er...
18:29:56 <idnar> SamB: heh
18:30:06 <liyang> Raguel: PICs must die.
18:30:26 <idnar> I was usually the guy everyone plagiarised from
18:30:32 <monochrom> hehehe
18:30:53 <monochrom> Induction dictates that someone has to be the source.
18:30:53 <Raguel> cale: go for it, always interested in learning
18:31:01 <Cale> To simulate lazy evaluation in C, you would have to simulate your own thunks using function pointers along with data parameters, which is not very far from just writing your own compiler/runtime system
18:31:06 <Raguel> liyang: he says why?
18:31:24 <liyang> idnar: the plagiarisees were given the same punishment, in the case hinted to above. :p
18:31:38 <Cale> In strictly evaluated languages, expressions are evaluated innermost first.
18:31:39 <idnar> liyang: heh
18:31:45 <liyang> Raguel: it destroyed my interest in electronics.
18:31:48 <Cale> So, for example, if we have the function:
18:31:51 <Cale> double x = x + x
18:32:03 <Cale> and we want to evaluate the expression  double (double 5)
18:32:10 <Cale> in a strict language, it goes like this:
18:32:11 <Raguel> liyang: if you don't like pics try dsps
18:32:13 <Cale> double (double 5)
18:32:17 <Cale> = double (5 + 5)
18:32:20 <Cale> = double 10
18:32:23 <Cale> = 10 + 10
18:32:24 <Cale> = 20
18:32:40 <Raguel> mmm
18:32:42 <faxathisia> I always hear little popping sounds when you do that Cale :D
18:33:00 <Cale> Under normal-order, that is, outermost-first evaluation, which is one step closer to lazy evaluation, it looks like this:
18:33:01 <liyang> Raguel: I want raw gates and transistors and all the other funky components that people seem to have forgotten about since PICs came along.
18:33:04 <Cale> double (double 5)
18:33:10 <Cale> = (double 5) + (double 5)
18:33:19 <Cale> = (5 + 5) + (double 5)
18:33:23 <Cale> = 10 + (double 5)
18:33:26 <Cale> = 10 + (5 + 5)
18:33:29 <Cale> = 10 + 10
18:33:31 <Cale> = 20
18:33:34 <oerjan> Double double, toil and trouble!
18:33:46 <LoganCapaldo> fire burn and cauldron bubble
18:33:50 <Cale> That clearly took more steps, however, since we duplicated the evaluation of double 5
18:34:01 <Cale> So lazy evaluation corrects this flaw
18:34:18 <Cale> If a function parameter is duplicated in the body, its evaluation is shared between the copies
18:34:21 <omnId> LoganCapaldo: Cale-dron bubble
18:34:25 <Cale> But otherwise, it's outermost-first evaluation
18:34:37 <SamB> liyang: transistors?
18:34:40 <Cale> So in lazy evaluation, it looks something like this (using let to denote the sharing)
18:34:41 <SamB> wierd stuff
18:34:44 <Cale> double (double 5)
18:34:46 <LoganCapaldo> The Cale-dron is bubbling.
18:34:52 <LoganCapaldo> Sounds ominous
18:34:53 <Cale> = let x = double 5 in x + x
18:34:59 <Cale> = let x = 5 + 5 in x + x
18:35:03 <Cale> = let x = 10 in x + x
18:35:04 <liyang> SamB: I don't know what I'm talking about anymore.
18:35:05 <Cale> = 20
18:35:08 <liyang> Sleep deprived.
18:35:32 <monochrom> You're talking about tabs and code copying. :)
18:35:43 <Raguel> liyang: sleep is overrated
18:35:46 <pjd> sleep depravation
18:35:57 <LoganCapaldo> sleep is underrated
18:36:11 <Raguel> so many better things to be doing!
18:36:12 <Cale> (In a real implementation, that shared computation is shared because two code pointers are the same, and after the code runs once, it updates itself with code that returns the result immediately)
18:36:13 * liyang concurs with LoganCapaldo here.
18:36:14 <Raguel> like going to bed
18:36:25 <Cale> Raguel: does that help you or your friend? :)
18:36:28 <Olathe> Sleeping hands are the devil's playthings.
18:36:52 <Raguel> he says yes
18:36:57 <Raguel> but the blank look in his eyes says otherwise
18:37:06 <Cale> The nice thing about lazy evaluation is that it lets you decompose programs in ways that you couldn't otherwise.
18:37:07 <Raguel> i think he may be slightly dead
18:37:21 <oerjan> No no, he is just sleeping
18:37:22 <Cale> Er, I should have said "problems"
18:37:54 <liyang> Raguel: you didn't come to see Planet Terror did you?
18:37:55 <Cale> For instance, this algorithm for finding a substring is completely ridiculous in a strict language:
18:38:09 <Raguel> liyang: i wanted to but i had a game on
18:38:10 <Raguel> :P
18:38:12 <Cale> isSubstringOf x y = any (isPrefixOf x) (tails y)
18:38:16 <liyang> FOOL!
18:38:25 <liyang> (Bestest filum evar.)
18:38:30 <Raguel> yeah well :(
18:38:37 <Cale> That looks like it constructs all the tails of the string y, and then checks if each of them has x as a prefix
18:38:43 <Raguel> and i still haven't interpreted this thing
18:38:53 <Cale> But in a lazy language, it's the same as the nested loops with early breakouts in C.
18:38:54 * liyang will stop going OT and hide this IRC window.
18:39:05 <liyang> Good night, and good luck.
18:39:10 <Raguel> night li
18:39:17 <liyang> :3
18:39:24 <Cale> The advantage being that you got to take advantage of existing library functions
18:39:39 <Raguel> i need to learn libry functions
18:39:39 <Cale> (like tails, which is almost completely useless in a strict language)
18:40:07 <Cale> As problems get larger, the benefits also tend to scale up fairly nicely too
18:41:06 <Raguel> ok with these functions bob x y = bobify (bobbed x) (fied y) - how does one go from just that to just that but WORKING
18:41:16 <Raguel> ie i have my fact10 function
18:41:23 <Raguel> how do i get that to a point where it'll run
18:41:37 <Raguel> i've got interpret :: Prog -> Int
18:42:08 <Raguel> but its complaining about a lack of binding...
18:42:15 <Cale> Okay, so you have to decide which Int it will return in each case.
18:42:16 <oerjan> fact10 is fine.  it is interpret which must do the work.
18:42:35 <oerjan> you haven't actually _defined_ interpret yet
18:42:40 <Raguel> ah good point - it doesn't know which to return from A and B
18:42:41 <oerjan> only declared it
18:42:41 <liyang> (in a Zen sense, laziness and FP has helped me to let go of constant factors in time complexity. Give it a few years and SPJ et al. will have figured out how to make it all better.)
18:42:51 <Cale> So go through the various constructors for Prog and decide which Int it's going to return when it gets that program.
18:43:16 <monochrom> And remember: you may use recursion.
18:43:29 <Cale> (and it will probably call itself recursively to do the work, and may need to keep track of state, so you might want a helper which takes a dictionary of bound values as a parameter)
18:43:55 <monochrom> One thing you need to worry about is how you will model variables like A, B.
18:44:03 <liyang> (And I only write Zen because I couldn't trust myself to type Bhuddist properly.)
18:44:35 <Raguel> :|
18:44:38 <pjd> Buddhist
18:44:40 <hpaste>  Toxaris pasted "combinator-based fibbonactorial function" at http://hpaste.org/3592
18:44:41 <Raguel> *melt*
18:44:47 <SamB> liyang: you mean because you sometimes get such nice asymptotic bounds from laziness?
18:44:47 <monochrom> You will also find that you probably need an auxiliary function. Let's say "aux_interpret". "interpret" will just call "aux_interpret", then "aux_interpret" will recurse on itself.
18:44:49 <liyang> pjd: there you go.
18:45:31 <liyang> SamB: I can't deal with an inquisition right now. Sorry I lied about hiding the window. ;_;
18:45:47 <SamB> what window?
18:45:52 <SamB> where can you hide a window?
18:46:04 <liyang> this IRC window that I was going to stop looking at.
18:46:10 <SamB> I suppose you could put it in the basement
18:46:20 <SamB> but then all you'd be able to see would be dirt...
18:46:21 <Raguel> ok so i haven't actually said what i want interpret to do i see now
18:47:00 <Toxaris> I had to "unfix" fib and fact to get my hands on the recursion, and to change fib's base case to fib 0 = 1 to get nice results, but otherwise, it is working fine, and again proves the good sense of telling cs students about fixed points. (At the other hand, I spend a lot of time writing magic combinators instead of doing something usefull)
18:47:41 <monochrom> I know that one day you won't need to write the code for "interpret" yourself. You will just need to write the type signature, and add the word "catamorphism", and then the program will write itself.
18:47:44 <LoganCapaldo> Toxaris: magic combinators you say?
18:47:54 <LoganCapaldo> Can you write the fibonactorial combinator?
18:48:14 <Toxaris> LoganCapaldo: http://hpaste.org/3592
18:48:17 <monochrom> LoganCapaldo hasn't given up! :)
18:49:15 <oerjan> @remember monochrom I know that one day you won't need to write the code for "interpret" yourself. You will just need to write the type signature, and add the word "catamorphism", and then the program will write itself.
18:49:15 <lambdabot> It is stored.
18:49:16 <LoganCapaldo> zomg
18:49:50 <monochrom> Yes, you open up the recursion, then it is not so black-box anymore, and you can do it.
18:49:56 <LoganCapaldo> he (basically) did it
18:50:14 <LoganCapaldo> Toxaris++
18:50:21 <monochrom> As halfly foretold by the Prophet.
18:50:41 <Raguel> ok interpret a = a'
18:50:43 <Raguel> or something
18:50:43 <monochrom> (Could I get half of ++ too? :) )
18:50:53 <Raguel> now i gotta work out what a' is
18:50:57 <Raguel> and how i get it to equal B
18:52:00 <Raguel> learning haskell its like grappling with an octopus, you think you got it pinned down but then it turns out that it has eight legs over and over again
18:52:25 <ddarius> monochrom: It depends on how descriptive your types are.
18:52:36 <monochrom> That's recursive octopus. :)
18:52:54 <Raguel> better than intrusive octopus
18:52:57 <omnId> Raguel: strange that you make that assertion.  You haven't really learned any haskell yet.
18:53:05 <Raguel> no
18:53:15 <ddarius> L = L + L + L + L + L + L + L + L
18:53:19 <Raguel> and i've never beaten an octapus in an wrestling match
18:53:33 <monochrom> ddarius: Yeah, the given information need to be just a bit more than "catamorphism", e.g., some base cases still need to be given.
18:54:15 <ddarius> monochrom: The "catamorphism" follows directly from the structure of the AST which doesn't (the structure that is) contain all that much information.
18:54:27 <Raguel> so before i decide to die in bed - how am i going to define interpret in such a way that it'll print out a value for B
18:54:41 <Raguel> or rather A
18:54:49 <Cale> Raguel: Is this due tomorrow?
18:54:54 <Raguel> weeelll
18:54:59 <omnId> Cale: yes.
18:54:59 <Raguel> its not gonna get done
18:55:09 <Raguel> but i need to know this much by tomorrow
18:55:14 <Raguel> so i can actually understand shit
18:55:29 <Cale> Raguel: How many other Haskell programs have you written?
18:55:29 <omnId> Raguel: interpret _ _ = 3628800
18:55:37 <Raguel> this would be No 1
18:55:40 <Cale> omnId: hehe
18:55:48 <monochrom> Structural recursion over Prog. And something more to handle variables.
18:56:07 <Raguel> randnum _ = 4
18:56:17 <Cale> Raguel: An interpreter for an imperative language as your *very* first program seems a little harsh.
18:56:51 <Cale> Raguel: Have you looked at any of the tutorials on Haskell?
18:57:00 <Raguel> bin reading one
18:57:06 <Raguel> ie book
18:57:12 <Cale> The Wikibook is not bad (until it starts talking about monads), and YAHT is also decent.
18:57:13 <monochrom> Hutton's book
18:57:24 <Cale> ah, you have Hutton's book?
18:57:28 <Raguel> i have come to understand you define a type, then you define the function,
18:57:29 <Raguel> yes
18:57:34 <Raguel> and then you call the function
18:57:50 <ddarius> monochrom: All the complexity is in the arguments to the fold, but all that complexity is -exactly- the (denotational) semantics of the language.
18:57:50 <Cale> Have you read and done the exercises up to this point in the book?
18:57:53 <Raguel> only here i've defined a funtion and then i'm defining another function to execute it...
18:58:06 <Raguel> no :(
18:58:11 <Raguel> or at least i can't remember them
18:58:13 <Cale> Raguel: If you're finding this hard, I'd *strongly* recommend going back and working on the previous stuff.
18:58:26 <Raguel> yeah ... its just i'm starting to run out of mental energy :(
18:58:30 <ricky_clarkson> I noticed that ScalaCheck has this concept of shrinking failure cases before reporting them.  Does QuickCheck have that?
18:58:32 <Cale> You'll get more out of it than trying to jump into the middle of the book, I think.
18:58:45 <Raguel> well i thought i understood it
18:58:57 <Raguel> bugger i wish i could quit my job - then i could spend friday night and sat doing it :(
18:59:01 <Lemmih> ricky_clarkson: Yes.
18:59:02 <Raguel> but as it is i gotta chef me some cash
18:59:19 <ricky_clarkson> Lemmih: Thanks.
18:59:28 <Raguel> right next step - do i hit the hay even though i'm not tired
18:59:46 <Raguel> or do i pick up a paper on fluid flow around bends in pipes and read that
18:59:51 <Cale> Well, find a little time to play around with the language a bit. I think it's a little unrealistic to go from never having written an interpreter before, to writing one in a new language which you're not completely familiar with.
18:59:54 <Raguel> (also needed to be known for tomorrow)
19:00:00 <Lemmih> ricky_clarkson: The most recent version does.
19:00:13 <Raguel> thanks cale and all you guys for helping me out
19:00:18 <Raguel> i'm gonna sign off for now
19:00:24 <Cale> Maybe write some smaller programs first which do simpler things :)
19:00:37 <LoganCapaldo> Start witha  Haskell compiler
19:00:41 <Raguel> and fall asleep to the al-rafai's study of turbulent flows in pipe bends
19:00:42 <Cale> heh
19:00:49 <Raguel> logan is mean :P
19:00:50 <Raguel> night
19:01:03 <LoganCapaldo> I'm a big believer in working your way down :)
19:02:31 <sorear> Turbulent flows in pipe bends?  Sounds very interesting!
19:02:56 <ricky_clarkson> Lemmih: I've been playing with the Java 7 prototype, and think I've hit something close enough to be called a QuickCheck port - in particular see the 'main' in here: http://pastebin.com/d50ca9e85
19:07:40 <oerjan> @remember LoganCapaldo Start with a Haskell compiler // I'm a big believer in working your way down
19:07:41 <lambdabot> Nice!
19:12:01 <omnId> lambdabot: I thought it was rather pedestrian.
19:12:15 <faxathisia> @quote Interpreter
19:12:15 <lambdabot> Philippa says: I'm fed up of writing uglyprinters for values inside an interpreter
19:12:19 <faxathisia> @quote Interpreter
19:12:20 <lambdabot> Philippa says: I'm fed up of writing uglyprinters for values inside an interpreter
19:12:22 <faxathisia> hmpf
19:14:22 <monochrom> LoganCapaldo, Toxaris: You may be interested in more recursion-opening in http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-375/
19:14:24 <lambdabot> Title: That About Wraps it Up
19:15:09 <LoganCapaldo> oooo
19:15:21 <LoganCapaldo> that looks interesting
19:15:54 <Toxaris> yes it does, thanks for the pointer, monochrom
19:18:13 <Olathe> ghc is Glorious ?
19:19:56 <monochrom> It's both Glasgow and Glorius.
19:20:05 <monochrom> err, Glorious
19:20:26 <omnId> what's not glorious about ghc? :)
19:21:08 <Olathe> There are no choirs singing its praises.
19:21:14 <Olathe> We must implement them.
19:23:22 <faxathisia> please implement deriving Interpreter first :)_
19:25:11 <chessguy> i think Interpreter would be a cool class, though maybe automatic derivations is asking a bit much
19:30:42 <LoganCapaldo> monochrom: this paper is neat
19:30:58 <monochrom> Yeah, neato.
19:33:04 <LoganCapaldo> although all his examples thus far have been using sideffects :)
19:34:29 <Toxaris> LoganCapaldo: but at least some of them are possible without sideeffects, too
19:35:00 <Toxaris> like memoization (using tries)
19:42:47 <omnId> @quote
19:42:47 <lambdabot> Jerub says: shapr: we have a new manager. she complained of a bad heart when I told her we didn't have revision control.
20:02:58 <shapr> @yow !
20:02:59 <lambdabot> I'm having an EMOTIONAL OUTBURST!!  But, uh, WHY is there a WAFFLE in
20:02:59 <lambdabot> my PAJAMA POCKET??
20:03:23 <keseldude> haha
20:06:17 <shapr> It's a beautiful day in the neighborhood.
20:07:25 <Brian`> hello
20:07:32 <dmwit> Hiya, Brian`!
20:07:39 <OceanSpray> It ain't in Compton.
20:07:58 <dmwit> You know what Mr. Rogers said when he was hit by a car?
20:08:07 <Brian`> hey guys, is y >>= (\x -> do ...) same as (\x -> do ...) y ?
20:08:11 <dmwit> "It's a beautiful day on the neighbor's hood."
20:08:16 <Brian`> lol
20:08:20 <dmwit> Brian`: Not quite.
20:08:21 <Cale> Brian`: no
20:08:30 <faxathisia> @_@
20:08:38 <faxathisia> I thought Brian`s question was the punchline
20:08:44 <dmwit> heh
20:09:01 <Cale> Brian`: >>= will produce a computation which when executed, will run y and pass its result to the function, producing another computation to run
20:09:05 <Brian`> but isn't the first one saying feed the value of y into (\x -> do ...) statement?
20:09:12 <Cale> Brian`: the latter just passes y directly to the function
20:09:12 <Brian`> oh i c
20:09:15 <Brian`> aha~
20:09:20 <Brian`> that's very clear :)
20:09:23 <Cale> So if y is a computation, it won't be run yet
20:09:34 <Cale> y >>= \x -> do ...
20:09:37 <Cale> Is the same as
20:09:42 <Cale> do x <- y; ...
20:09:45 <Brian`> yeah
20:10:03 <Brian`> man! learning haskell is so much fun haha
20:10:07 <Cale> :)
20:10:35 <Brian`> did you guys read "You know you are into Haskell when ..." article in programming.reddit.com?
20:10:45 <Brian`> lol it was funny hehe
20:10:45 <omnId> gt $ fstr
20:10:48 <Cale> heh
20:10:51 <Brian`> yeah it wasn't article lol
20:10:53 <Brian`> gt $ fstr
20:11:00 <Cale> yeah, I saw that
20:11:07 <Brian`> and what's even funnier is that I saw that ad after work lol on the way home
20:11:12 <Cale> It took me a while to decipher what it actually meant
20:11:15 <faxathisia> hmm
20:11:16 <faxathisia> what is gt $ fstr
20:11:17 <omnId> Brian`: srsly?!
20:11:19 <Brian`> yeah me too lol
20:11:20 <Brian`> yeah
20:11:23 <Brian`> I live in New York now
20:11:30 <Brian`> and it's Chase Bank's ad
20:11:36 <Cale> faxathisia: It was written on a bank window, if it helps
20:11:39 <omnId> faxathisia: get monies faster, in txtspk
20:11:46 <Brian`> yeah lol
20:11:54 <Brian`> :t fstr
20:11:58 <lambdabot> Not in scope: `fstr'
20:12:04 <Brian`> lol
20:12:05 <faxathisia> oh ok
20:12:23 <dmwit> The sad thing is that I made the same mistake a few weeks earlier...
20:12:48 <dmwit> I was like, "Whoa, I want to get hired there!  They advertise Haskell right on their window!"
20:12:52 <dmwit> Then came the let-down...
20:13:27 <faxathisia> haha
20:13:34 <Brian`> lol
20:13:36 <sorear> Why does karle misrepresent her replies as having been written by TuringTest?
20:13:38 <Brian`> do you live in New York too?
20:13:55 <Cale> sorear: who is karle?
20:14:20 <sorear> Cale: some person on the mailing list who needs a remedial course in e-mail quoting
20:14:52 <hpaste>  gwern pasted "archive-bot -readfile problem?" at http://hpaste.org/3593
20:14:55 <gwern> I have a kind of question. I have this one program which is supposed to work on 1000 line chunks of a file at a time; I call readFile, take 1000 and pass it to another function, then I delete 1000 lines and call main again. But it doesn't really seem to work and i suspect the problem is bytestring's (strict) readFile. am I supposed to close the file before I delete lines? if so how?
20:16:08 <Cale> gwern: er, why delete them on disk?
20:16:28 <Cale> (I'm not saying you can't do it, but it seems like a roundabout way to get things done)
20:16:40 <sjanssen> gwern: Data.ByteString.readFile is strict
20:17:01 <gwern> Cale: I repurposed the deleteL function; I don't entirely recall what I was thinking. probably something along the lines of 'ooh if I modify on the disk then I can run multiple ones at the same time!'
20:18:24 <gwern> also, this way I don't need to pass a argument representing the now shorter file/list iirc, since main doesn't take arguments
20:18:34 <Cale> You're using B.words instead of B.lines there, is that right?
20:18:58 <Cale> That is, you're passing the first 1000 words of the file to archiveBot
20:19:09 <gwern> Cale: yes, the file comes with all spaces turned into underscores
20:19:25 <gwern> ie, an example line consists of '"Anzac"_(Restriction_on_Trade_Use_of_Word)_Act_1916
20:20:18 <Cale> btw,  liftM (take 1000 . B.words) $ B.readFile en
20:20:54 <gwern> (I mean, I guess lines would be equivalent in this situation. any performance difference?)
20:21:34 <Cale> Well, it just seems safer to switch to either words or lines in both places
20:21:42 <Cale> but I'm still looking at it
20:22:17 <Cale> (x == a || x == b || x == c) is the same as x `elem` [a,b,c]
20:22:27 <Cale> (just style hints)
20:22:42 <gwern> oh. I didn't realize that. a good idea
20:23:13 <gwern> (that section is a horrible efficiency hack, btw)
20:25:07 <Cale> Hmm, what seems to be going wrong with it?
20:25:49 <sorear> gwern: You've been trying for several months to solve this problem with Haskell.  I think it's time for:  find . -type f | xargs sed -i 1,1000d    or something like that
20:26:23 <Cale> sorear: huh? That doesn't look like this program
20:26:37 <gwern> Cale: the last time I tested it, it ran too fast and emptied the file within like a minute, which obviously can't work - the file has somewhere between 2-20 million lines (I forget what)
20:27:14 <Cale> gwern: Well, that seems reasonable, but you'll have also forked a *lot* of threads
20:27:17 <gwern> even with all the forks and efficiency improvements, it couldn't possibly download all of wikipedia and parse it that quickly
20:27:35 <Cale> You're not doing that work in the loop which consumes the file
20:27:42 <Cale> You're forkIO'ing all the processing
20:27:43 <gwern> sorear: probably, but I find it a good way to learn haskell. I've learned an awful lot from messing with this
20:28:00 <sorear> gwern: Why download wikipedia with a bot, when you can just munge the XML dumps?
20:28:09 <Cale> oh, also, your main loop doesn't terminate until the file is empty at which point the program just crashes?
20:28:23 <gwern> sorear: the xml dumps are often out of date and are increasingly unreliable
20:28:38 <sorear> that sounds like a bad idea!
20:28:38 <faxathisia> so is wikipedia :p
20:28:41 <faxathisia> why not just read it online
20:28:55 <sorear> gwern: that's.... dumb
20:29:06 <gwern> sorear: plus, the format of external links is... weird in the xml dumps. I don't understand it
20:29:28 <Cale> gwern: What does your program do when it reaches the end of the file?
20:29:35 <Cale> gwern: terminate with an error?
20:29:36 <gwern> because the xml is a wrapper around wikimarkup or something, so stuff looks like '
20:29:50 <gwern> 'The overall albedo of the [[Moon]] is around 12%, but it is strongly directional and non-Lambertian, displaying also a strong opposition effect. &lt;ref&gt;http://jeff.medkeff.com/astro/lunar/obs_tech/albedo.htm A discussion of Lunar albedos&lt;/ref&gt; While such reflectance properties are different from those of any terrestrial terrains, they are typical of the [[regolith]] surfaces of airless solar system bodies.'
20:29:52 <lambdabot> Title: Lunar Albedo
20:30:08 <Cale> gwern: Remember that you need to keep the main thread running or else the whole program quits.
20:30:25 <sorear> gwern: Do they provide *any* downloadable sane format?
20:30:28 <gwern> Cale: presumably it cannot read the file, at which point main exits, which unwinds the nested mains
20:30:49 <Cale> (well, main is tail recursive, so there's no unwinding to be done)
20:31:01 <Cale> But that means all your spawned threads die
20:31:10 <gwern> sorear: there's the SQL dumps...
20:31:11 <Cale> which means the work they do never finishes
20:31:59 <P_D> Has anyone used Harpy successfully on windows?
20:32:00 <Cale> What you probably really want to do is only spawn so many worker threads and make sure that they all complete.
20:32:06 <gwern> oh. maybe that's the issue then - it creates threads for all the work, but they've just started working when main chews through the entire file and then errors on the empty file, which kills it and its threads
20:32:12 <Cale> right
20:32:30 <gwern> is main fast enough to eat through a few million lines in a minute or two?
20:32:36 <Cale> probably
20:32:45 <Cale> main isn't doing much
20:33:00 <Cale> how many times does it print "1000 processed"?
20:33:22 <gwern> Cale: dunno, I just added that right before I posted as I was going through looking it over again
20:33:54 <Cale> Of course, that doesn't *really* mean that 1000 items were processed, just that a thread was spawned and 1000 lines deleted from the file
20:35:15 <Cale> What I'd do is to have a QSem which manages the number of running worker threads and keeps tabs on how many are finished.
20:36:11 <Cale> You'd pass (signalQSem qs) to each of the worker threads as a parameter, and they call it to signal that their work is finished.
20:36:12 <sw17ch> Are there any web framework projects in haskell?
20:36:51 <Cale> er, oh, it looks like QSem doesn't have an interface for querying the currently available quantity.
20:37:24 <Cale> I was going to say that you could do that to detect when all your work is finished as well, but it turns out that you probably can't.
20:37:34 <gwern> Cale: that's getting too complex for me. I think what I'll do is simplify it and stop trying to process it 1000 lentriees at a time, and then once I'm satisfied it's correct, then look into parallelizing it
20:37:57 <gwern> odd thing was, it worked fine when I had the 1000-at-a-time part being done by a bash script :)
20:38:46 <Cale> It makes no sense that Control.Concurrent doesn't come with a bounded channel. It's easy to implement and yet very useful.
20:39:27 <Cale> gwern: yeah, your main problem here is that the main thread is quitting.
20:39:34 <ddarius> sw17ch: The answer to all such questions is: Look at haskell.org and hackage.
20:39:46 <Cale> gwern: if you just kept it active until all working threads had stopped, you'd be fine, I think
20:39:58 <Cale> @faq
20:39:59 <lambdabot> The answer is: Yes! Haskell can do that.
20:40:35 <Cale> (Yeah, there are web frameworks)
20:42:12 <oerjan> Cale: what about simply letting all the worker threads do a putMVar at the end, and main does the same number of getMVar before exiting?
20:42:23 <Cale> yes
20:42:28 <oerjan> er, takeMVar
20:42:49 <Cale> you mean maintain an integer counter?
20:43:22 <oerjan> in main yes
20:43:23 <Cale> or... oh, I suppose you could just takeMVar in a loop.
20:43:54 <ddarius> mapM_ takeMVar mvars
20:44:23 <oerjan> one MVar should be enough?
20:45:51 <Cale> mapM_ (\x -> takeMVar mvar) tids
20:45:56 <sw17ch> is there a better way to satisfy my "what does that function do?" questions that blabbering them here every time?
20:46:08 <gwern> hoogle?
20:46:11 <Cale> sw17ch: Well, do you know about the libraries documentation?
20:46:18 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
20:46:23 <sw17ch> many of them don't tell me much :(
20:46:35 <Cale> like which?
20:46:49 <omnId> sw17ch: /msg lambdabot > test expression
20:46:51 <Cale> Some areas of the docs are patchier than others
20:47:00 <sw17ch> first google hit for mapM_ : http://www.zvon.org/other/haskell/Outputprelude/mapM__f.html
20:47:01 <lambdabot> Title: Haskell : mapM_
20:47:05 <omnId>  @type unknown function
20:47:07 <sw17ch> which... tells me... nothing :(
20:47:15 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3AmapM_
20:47:18 <lambdabot> http://tinyurl.com/ykyqfl
20:47:20 <sw17ch> i know how to get type signatures, etc...
20:47:20 <omnId>  > unknownFunction params which match type
20:47:22 <gwern> now... the real question is: the reason I tried for the segmented approach was because my laptop with 512mb ram couldn't handle the entire file at once. can my new desktop with 4 cores and 4gigs RAM handle it?
20:47:35 <Cale> sw17ch: don't use zvon
20:47:57 <Cale> gwern: you could just use lazy bytestrings
20:48:09 <omnId> sw17ch: @index <name> gives a module, @docs <module> gives the docs
20:48:10 <Cale> gwern: that would also mean you don't have to destroy the file
20:48:28 <gwern> Cale: oh, that's right - I don't need to be strict any more
20:48:41 <gwern> and yes, it allows me to not have to worry about the file anymore too, which is nice
20:49:50 <hpaste>  gwern annotated "archive-bot -readfile problem?" with "simplified" at http://hpaste.org/3593#a1
20:56:00 <omnId> uniq = filter (`notElem` exceptions) . concat
20:56:08 <omnId> exceptions = map B.pack [...]
20:58:37 <user317> are there any rpc libraries for haskell?
21:01:31 <gwern> omnId: good advice. always amazing how much nicer things can get in haskell
21:01:48 <omnId> gwern: is the annotation necessary?
21:02:14 <sw17ch> just out of curiosity, how long have all of you been working with haskell?
21:02:30 <Cale> sw17ch: 3 or 4 years now.
21:02:55 <sw17ch> Cale: academic? hobby? work?
21:03:03 <wli> Strictly speaking, I don't work with it.
21:03:08 <Cale> hobby, some work
21:03:18 <omnId> 3 months, 3 months hiatus, then 1 month, all hobby
21:03:29 <wli> Loosely speaking, 9 years.
21:03:57 <sw17ch> omnId: you seem to know this quite well for 4 of 7 months
21:04:30 <omnId> thinking again, I underestimated, I started 'round the beginning of '07.
21:04:41 <omnId> 5 total at least.
21:05:18 <wli> There are people who didn't start college until after I started using it and are now far better Haskell programmers than I (whom I furthermore ask for advice/help/etc.).
21:05:56 <omnId> when I got past incomprehensibility, I loved what I found, and gorged myself on it :)
21:06:13 <sw17ch> omnId: I'm still hoping for the true "ahah!" moment
21:06:53 <sw17ch> omnId: my major stumbling block right now is looking for resources to learn it. I can wrap my head around most things that don't involve monads... with exceptions
21:06:59 <omnId> I didn't have one overarching epiphany, more like many brutally-earned miniepiphany :)
21:07:00 <lament> ahah moments don't happen very often.
21:07:20 <lament> what happens is you look back and realize how far you are from where you started :)
21:07:27 <sw17ch> lament: i had a good one with lisp... and when i finally figured out why the heck list comprehensions were cool
21:07:55 <omnId> I still don't use comps much at all, you'll not take my precious hofs from me!
21:08:11 <brad__> is there a simple way in haskell to convert from an Int/Integer to a hex representation?
21:08:23 <omnId> brad__: to a String?
21:08:29 <oerjan> > showHex 255
21:08:31 <lambdabot>  <[Char] -> [Char]>
21:08:33 <omnId> > showHex 255 ""
21:08:33 <wli> brad__: There are hexadecimal string formatting functions.
21:08:34 <oerjan> > showHex 255 ""
21:08:34 <lambdabot>  "ff"
21:08:35 <lambdabot>  "ff"
21:08:40 <brad__> cool!
21:08:44 <brad__> thanks folks!
21:08:45 <wli> > showHex 8675309
21:08:46 <lambdabot>  <[Char] -> [Char]>
21:08:52 <omnId> > showHex 2937 "stuff after it"
21:08:52 <wli> > showHex 8675309 ""
21:08:53 <lambdabot>  "845fed"
21:08:54 <lambdabot>  "b79stuff after it"
21:09:08 <wkh> > showHex 9823409850985092384094328098409384093284302948203948324098 ""
21:09:10 <lambdabot>  "190a12f2eb75614f6a1e88591c06b79fda21ad0158cbeb502"
21:09:46 <user317> is there any haskell rpc library out there?
21:10:06 <wli> I'm notaware of any.
21:11:16 <brad__> :q
21:11:21 <sw17ch> omnId: didn't you have something that read from arbitrary bases last night? how about printing to arbitrary bases?
21:11:35 <omnId> @type showIntAtBase
21:11:37 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
21:11:58 <wli> This is in the library.
21:12:16 <omnId> > showIntAtBase 26 (['a'..'z']!!) 238947 ""
21:12:18 <lambdabot>  "npmh"
21:12:39 <omnId> @index showIntAtBase
21:12:39 <lambdabot> Numeric
21:12:49 <omnId> the Numeric module is filled with that stuff.
21:13:09 <sw17ch> huh... so... expanding to base 62 wouldn't be all that hard either then
21:13:20 <oerjan> you also need things from Data.Char to combine with
21:14:10 <sw17ch> > showIntAtBase (10 + 26 + 26) ((['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'])!!) 238947 ""
21:14:11 <lambdabot>  "109Z"
21:14:32 <oerjan> > showIntAtBase 256 toEnum 23062096
21:14:33 <lambdabot>  <[Char] -> [Char]>
21:14:34 <sw17ch> > showIntAtBase (10 + 26 + 26) ((['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'])!!) 2^10 ""
21:14:35 <lambdabot>   add an instance declaration for (Num ([Char] -> b))
21:14:37 <oerjan> > showIntAtBase 256 toEnum 23062096 ""
21:14:39 <lambdabot>  "\SOH_\230P"
21:14:44 <omnId> :)
21:14:58 <bos> andyjgill: glad you're blogging!
21:15:02 <omnId> sw17ch: (2^10)
21:15:07 <Pseudonym> > showIntAtBase 0x10ffff toEnum 23062096 ""
21:15:09 <lambdabot>  "\DC4\779876"
21:15:11 <sw17ch> > showIntAtBase (10 + 26 + 26) ((['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'])!!) (2^10) ""
21:15:13 <lambdabot>  "gw"
21:15:19 <sw17ch> hah, fantastic
21:15:21 <Cale> sw17ch: I suppose I could give some pointers on how to think of monads.
21:15:30 <Pseudonym> NO POINTERS!
21:15:41 <Cale> heh
21:15:53 <Cale> Some references then?
21:15:58 <Pseudonym> That would be fine.
21:16:05 <omnId> @slap Pseudonym and Cale
21:16:05 * lambdabot karate-chops Pseudonym and Cale into two equally sized halves
21:16:14 <Pseudonym> Oh, that's better.
21:16:23 * Pseudonym didn't like being joined to Cale much
21:16:28 <Cale> hehe
21:16:45 <Cale> Well, my current favourite explanation for what monads are about is that they're just a way to structure certain kinds of libraries.
21:16:59 <sw17ch> I understood them as ways to maintain state =)
21:17:08 <Cale> For a long time, functional programmers have been writing these things which they like to call combinator libraries.
21:17:15 <Pseudonym> I like the idea of "overloaded semicolon".
21:17:37 <faxathisia> I prefer Monoids.. easy to say what they are :)
21:17:42 <Cale> A combinator library is basically a library which has a rich enough API that using it is like using a miniature programming language custom-tailored to your problem.
21:17:58 <Cale> An embedded domain-specific language, if you like.
21:18:12 <sw17ch> Ah, so the way Parsec feels like its own language
21:18:16 <Cale> yes
21:18:33 <Cale> Typically, such a library will define a bunch of basic computations -- in parsec's case, simple parsers which parse individual characters, for instance
21:18:44 <wkh> i code database and web applications for a living
21:18:46 <Cale> and then a way to combine those comptuations into larger ones
21:19:03 <sw17ch> >>= and so on?
21:19:09 <Pseudonym> wkh: Unluckly you. :-)
21:19:10 <wkh> i've been trying to understand dons's work on generating monte carlo simulator codes because i'd like to use haskell for generative programming in the area of web applications
21:19:13 <Cale> >>= as well as <|> and so on
21:19:22 <sw17ch> aggregate a lot of small (easy) computations into larger more complex ones
21:19:25 <Pseudonym> ?seen dons
21:19:25 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 20m 42s ago.
21:19:26 <sw17ch> alright
21:19:36 <Cale> Monads just abstract one particular means of combination which is common across many libraries.
21:20:02 <Cale> So that code can be written for all of these libraries at once. (Things like general control structures)
21:20:34 <Cale> So what kind of library is a monadic one?
21:20:41 <sw17ch> beat me to it
21:20:44 * Pseudonym raises his hand
21:20:46 <Pseudonym> IO!
21:20:46 <Cale> Well, monadic computations have results.
21:20:57 <sw17ch> Does IO have results?
21:21:04 <Pseudonym> Sure does.
21:21:05 <Cale> :t getLine
21:21:07 <lambdabot> IO String
21:21:14 <Cale> getLine has a String result, for instance
21:21:15 <Pseudonym> You read something from a file, that's a result.
21:21:16 <Pseudonym> Yeah.
21:21:32 <sw17ch> :t putStrLn
21:21:33 <lambdabot> String -> IO ()
21:21:36 <Pseudonym> Sometimes the result is what you would call "void" in C.
21:21:37 <sw17ch> but not always, right?
21:21:39 <Cale> Or when you parse some string using parsec, your parser returns some data structure representing what it was that you parsed.
21:21:40 <Pseudonym> Which is spelled () in Haskell.
21:21:50 <Cale> right, not always ()
21:22:15 <sw17ch> so, slight tangent... perhaps you could apply this to the Maybe monad
21:22:21 <Cale> Next, in any monad, there's a way to take any value whatsoever, and get the computation which "does nothing" and gives that value as its result.
21:22:28 <Cale> Okay
21:22:30 <sw17ch> hold my previous thought
21:22:34 <omnId> @type Text.ParserCombinators.Parsec.satisfy isDigit
21:22:35 <lambdabot> forall st. Text.ParserCombinators.Parsec.Char.CharParser st Char
21:22:36 <sw17ch> continue with yours until you're ready
21:22:56 <Cale> all right, Maybe is a funny example for this world-view, but it can be done :)
21:23:10 <omnId> ^ that's the (CharParser st) monad, which results in a Char.
21:23:24 <sw17ch> I just had a terrible flashback to some liberal arts core :P (worldview is a funny word at my school)
21:23:33 <Cale> You can think of a value of type (Maybe t), as being a computation which will either return a value of type t, or fail.
21:23:51 <Cale> That is, it's either Just x, with x::t, or it's Nothing
21:24:04 <sw17ch> if(true) { return ptrToObject; } else {return 0; }
21:24:21 <sw17ch> i know it's different from the C code
21:24:35 <Cale> Something like that would probably use the Maybe type in Haskell.
21:24:36 <sw17ch> so...
21:24:38 <omnId> struct { int tag; T value }
21:24:49 <sw17ch> if ( true ) { Just ptrToObject } else { Nothing }
21:25:01 <omnId> tag = 0, Nothing, and value is NULL, tag = 1, value is some T value.
21:25:19 <sw17ch> alright
21:25:22 <Cale> anyway, on with the show :)
21:25:41 <sw17ch> so, when ever you have something that works with the Maybe monad, you need to do a case of ... to check if it's Just something or Nothing
21:26:04 <sw17ch> yes, please continue
21:26:07 <omnId> sw17ch: hehe, except that the (>>=) funciton alraedy does that case expression!
21:26:10 <Cale> Given a pair of computations, x and y in the same monad, one can form the computation (x >> y), which when run, intuitively "runs" the computation x, throws away its result, then runs y, returning its result.
21:26:28 <Pseudonym> That's the semicolon operator in Pascal.
21:26:41 <sw17ch> ah, and since we lack side effects...
21:26:42 <Cale> x >> y is the same thing as do x; y
21:26:49 <sw17ch> i was just goingto ask that
21:27:06 <Cale> No, the side effects are encoded into the datatype of computations we're manipulating.
21:27:28 <sw17ch> i dont get that,  but we can come back... it will probably make sense later
21:27:51 <Cale> So for example, you can think of a value of type (IO t) as being a program script which *describes* a bunch of actions to be performed before resulting in a value of type t
21:28:14 <Cale> And those can include descriptions of input and output to be done.
21:28:15 <omnId> you can represent that program script however you like.
21:28:40 <Cale> Right, it could even be that under the covers, GHC is manipulating bits of C code.
21:28:48 <Cale> (though it's not)
21:29:15 <Cale> I mean, C source code, of course.
21:29:22 <sw17ch> :P
21:29:39 <Cale> And the >> operator is sort of a concatenation of program scripts
21:29:54 <omnId> yeah, you could have getLine be a constant bag of C code, and binding to another action puts more C code onto it in a referentially transparent way.
21:30:05 <sw17ch> So, these actions I specify... say: main = putStrLn "Hello World!"
21:30:20 <sw17ch> can we say that main IS a monad?
21:30:22 <Cale> no
21:30:25 <Cale> IO is a monad
23:39:22 --- topic: '["The Haskell programming language: homeground of the lambdacats!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ", "http://arcanux.org/lambdacats.html" ]'
23:39:22 --- topic: set by dons on [Wed Oct 10 16:54:09 2007]
23:43:05 <hpaste>  omnId annotated "Compile-time evaluation" with "looks like I have to do each type that doesn't fit into ConE :(" at http://hpaste.org/3584#a2
23:44:32 <omnId> shoot, I need TupE too
23:44:42 <omnId> D:
23:46:00 * wli needs some sort of de-1337-ification filter to understand this weirdo on another IRC network and wonders if natural language processing people about have such things floating around.
23:51:04 <omnId> *CompileTime> $(compileTimeEval [Left (1::Integer), Right "hello"])
23:51:04 <omnId> [Left 1,Right "hello"]
23:51:20 <omnId> not completely broken, but I see many headaches to getting it complete.
23:53:48 <omnId> *CompileTime> $(compileTimeEval ('a','b'))
23:53:48 <omnId> <interactive>:1:2:
23:53:48 <omnId>     Illegal data constructor name: `,'...
23:54:09 <omnId> Generics haet TH
23:56:51 <omnId> that becomes: ConE (mkName ",") `AppE` LitE (CharL 'a') `AppE` LitE (CharL 'b')
23:56:55 <omnId> TH wants: TupE [LitE (CharL 'a'),  LitE (CharL 'b')]
