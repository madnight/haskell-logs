00:18:51 <sorear> math_guy88: what's the difference between you and math_lover?
00:19:05 <math_guy88> a few letters
00:19:18 <math_guy88> this mirc client is hellish
00:34:31 <roconnor> @type join map
00:34:34 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a]'
00:34:34 <lambdabot>       Expected type: (a -> b) -> (a -> b) -> a1
00:34:34 <lambdabot>       Inferred type: (a -> b) -> [a] -> [b]
00:34:39 <roconnor> @type join . map
00:34:39 <lambdabot>     Couldn't match expected type `(->) [a]' against inferred type `[]'
00:34:39 <lambdabot>     Probable cause: `map' is applied to too many arguments
00:34:39 <lambdabot>     In the second argument of `(.)', namely `map'
00:34:46 <roconnor> @type (join .) . map
00:34:47 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
00:34:54 <goalieca> lol. i love lazyness. i forgot to actually display the results so it didn't compute them :P
00:34:59 <goalieca> saved me a good half-hour :P
00:35:30 <roconnor> @type =<<
00:35:30 <lambdabot> parse error on input `=<<'
00:35:36 <roconnor> @type (=<<)
00:35:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
00:36:19 <sclv> ?hoogle pokeByteOff
00:36:19 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
01:33:05 <wli> I wonder if there's something I'm missing wrt. GADT's.
01:33:51 <wli> The use cases don't seem very obvious to me.
01:37:31 <integral> hmm, does haskell have the "parallel-or" operator?
01:37:43 <wli> No.
01:37:52 <wli> integral: Wanting full abstraction, are you?
01:37:58 <integral> I was just wondering :-)
01:38:36 * integral hasn't quite got a handle yet on how different languages differ yet
01:49:31 <hpaste>  toad3k pasted "used to calculate likelihood of certain coin toss patterns" at http://hpaste.org/4068
02:03:44 * wli wonders if Cayenne questions would be too far off topic.
02:06:11 <quicksilver> wli: I doubt people will mind, but I certainly won't know the answers :)
02:06:39 <wli> quicksilver: Linear algebra with dependent types is too sexy to pass up.
02:07:48 <quicksilver> ;)
02:08:50 <wli> quicksilver: First I need to figure out how to define Galois fields...
02:10:24 <wli> quicksilver: At the very least a proper numeric hierarchy should be easier to implement. ;)
02:13:51 <math_guy88> galois fields, ok I feel dumb, what are they?
02:14:26 <dobblego> it's a farm, owned by Galois, where they grow the lambda crop, in large fields
02:14:46 <wli> math_guy88: Finite fields. The first associated with a prime p is Z/pZ, then they're the splitting fields of x^(p^n)-x over that or some such.
02:15:40 <wli> math_guy88: GF(p^n) is a field with p^n elements for a prime p and a natural number n > 0.
02:17:21 <wli> math_guy88: You need dependent types to ensure the modulus of Z/pZ is prime in the types indexed by natural numbers.
02:17:55 <math_guy88> wow
02:18:06 <wli> math_guy88: Z/pZ being "Z mod p Z" or the integers modulo the prime p.
02:18:16 <mlesniak> Does Haskell support escape sequences? I'd like to clear the screen using putStrLn "\027[2J;", but it does not work under ghci
02:18:26 <wli> mlesniak: Yes.
02:18:30 <quicksilver> that's not haskell's problem, mlesniak
02:18:35 <quicksilver> that's all down to whatever terminal you're using
02:18:51 <mlesniak> quicksilver: thought, the cmd-shell from windows supports them?
02:19:01 <dmead> if it did
02:19:04 <dmead> i'd be suprised
02:19:17 <mlesniak> :-/ Ok, I see, thanks :)
02:19:21 <wli> mlesniak: Trying to do vt100 escape codes?
02:19:22 <quicksilver> no idea :)
02:19:33 <math_guy88> when you say modulo
02:19:44 <math_guy88> do you mean absolute value?
02:20:03 <mlesniak> wli: I'm not sure from which standard it is, but the \escape[2J; thing worked for me till I have to use windows ;-)
02:20:35 <math_guy88> 'clear' on a linux box clears the screen....
02:20:35 <wli> mlesniak: Maybe you mean \033
02:20:53 <allbery_b> vt100-derived / ansi escapes commonly work in unixy terminal emulators, but are not supported in windows console mode
02:21:10 <mlesniak> wli: Hmm, possibly ;)
02:21:18 <mlesniak> allbery_b: that's a pity :-/
02:21:42 * mlesniak is used to unix terminals...
02:21:54 <allbery_b> http://en.wikipedia.org/wiki/ANSI_escape_code
02:21:54 <lambdabot> Title: ANSI escape code - Wikipedia, the free encyclopedia
02:21:55 <wli> mlesniak: Try putStr "\^[[2J;"
02:22:45 <Liskni_si> (i'd leave out the semicolon and add a move to (0,0), but that's not going to make it work in windows, of course)
02:23:00 <mlesniak> Liskni_si: This would be the 2nd step
02:23:27 <wli> mlesniak: Hmm, Windows is another story entirely. Different command set there.
02:24:10 <mlesniak> wli: It *should* work according to wikipedia, but I have to load ANSI.sys, that just f*ck_ng stupid!
02:24:33 * mlesniak is not even sure if he has to reboot to use config.sys ;)
02:24:34 <wli> mlesniak: You're basically writing a low-level terminal driver.
02:24:56 <wli> mlesniak: You're issuing a clear screen command, which is different for different terminal types.
02:25:11 <allbery_b> read again, only 16-bit VDMs will do that
02:25:15 <allbery_b> 32-bit programs won't
02:25:44 <hpaste>  (anonymous) annotated "used to calculate likelihood of certain coin toss patterns" with "(no title)" at http://hpaste.org/4068#a1
02:25:46 <mlesniak> wli: I don't plan to use the "whole" terminal stuff ,just want to clear the screen for convience ;)
02:27:50 <wli> mlesniak: What you're doing will break on the wrong terminal types. You're seeing that happening now with Windows. You need to detect the terminal type and figure out the character sequence to issue for a clear screen command from that.
02:28:28 <wli> mlesniak: There are probably ncurses bindings sufficient for your purposes but I've no idea how they play with Windows.
02:29:02 <mlesniak> wli: I see, but I think that's becoming to much work for just having a small cls-function which is not "really" needed
02:29:12 <mlesniak> anyway, it's not a haskell problem but a windows one
02:29:39 <mlesniak> wli: but thanks for the suggestions :)
02:29:41 <wli> mlesniak: You shouldn't have to write it yourself. Just find the ncurses lib and call it and drag in ncurses on Windows.
02:30:24 <mlesniak> wli: that's also good idea, thanks
02:30:49 <allbery_b> on unix you can just capture the output of "tput clear", or for a one-shot just run it directly
02:31:16 <allbery_b> or even just running "clear" (and on windows try "cls")
02:33:02 <SnailRacer> It's not haskell's fault, but it is still it's problem *sigh*
02:37:47 <wli> I started on a pure Haskell NIH of ncurses.
02:38:07 <wli> I don't have the wherewithal or intestinal fortitude to finish it.
02:40:18 <wli> FFI calls to ncurses don't fly because of the signal handling behavior of FFI calls.
02:43:52 <allbery_b> @where hscurses
02:43:52 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
02:44:42 <firefly> is there a "cmmcolour" just like there is an hscolour?
02:45:12 <firefly> it would be nice to have some sort of syntax colouring/highlighting for C--
02:47:02 <wli> allbery_b: That's an FFI binding IIRC, with all the aforementioned signal handling issues.
02:47:15 <wli> allbery_b: (FFI calls blocking signals)
02:47:27 <allbery_b> yeh
02:47:54 <allbery_b> there's vty, but no windows support afaik (and assumes ANSI)
02:48:12 <allbery_b> ...although these days I would not waste time on something that isn't based on ANSI X3.64
02:48:32 <wli> I've got most or all of terminfo parsing/etc. done.
02:48:53 <wli> I'm down to basically the idiot interpreter for the escape sequences.
02:49:13 <allbery_b> shouldn't be that hard
02:49:52 <allbery_b> I've done it in C more times than I can count (before screen became available on various odd platforms)
02:50:26 <wli> allbery_b: At my level of burnout everything is hard.
02:51:19 <wli> allbery_b: http://holomorphy.com/~wli/hncurses/
02:51:20 <lambdabot> Title: Index of /~wli/hncurses
02:53:05 <wli> allbery_b: You may be a better candidate to hammer the lib out.
02:53:42 <allbery_b> once I'm not constantly tired, maybe.  (get to try to schedule blood tests next week, weeee)
02:54:26 <wli> allbery_b: You're looking at something on the order of years if you're going to wait for me to do it, so you've got plenty of time.
02:56:09 <allbery_b> hm, actually, I'd say you're doing this wrong.  use FFI to terminfo to get the escape sequences, implement the rest in haskell
02:56:36 <allbery_b> that's a one-time thing at the start of the program
02:57:14 <allbery_b> (unless you want to drop to terminfo to translate sgr= or something, but that's a fairly fast call so I'd not worry about signals)
02:58:28 <wli> allbery_b: IIRC the escape sequences are not entirely static.
02:59:00 <allbery_b> right, that was what I was referring to
02:59:32 <allbery_b> thing is, you can drop into FFI to do that and return the string, without to omuch impact on signal handling
02:59:55 <phlpp> hi
03:00:14 <Lycurgus> hello
03:00:24 <allbery_b> although I'd say tputs and tparm are not that difficult in haskell, so you can let the FFI terminfo binding do the rest
03:01:28 <Lycurgus> how long have you been programming allbery_b?
03:01:30 <wli> allbery_b: I've mostly not even started reading about how runtime usage works. I'm very loath to rely on the FFI but maybe that's just a bad decision.
03:02:05 <allbery_b> it's a bad decision for the ncurses input stuff, I;'d think not so bad for output
03:02:25 <allbery_b> but, well, I think most programs that use (n)curses ignore the input stuff anyway
03:02:33 <allbery_b> it's always been wonky and unreliable
03:02:43 <Stinger_> anyone have some good videos of haskell tutes/lectures? or screencasts etc
03:02:50 <dobblego> ?where video
03:02:50 <lambdabot> http://haskell.org/haskellwiki/Video_presentations
03:02:57 <dobblego> Stinger_ ^
03:03:02 <Stinger_> easy :) thanks
03:03:31 <allbery_b> and I *really* would not want to reimplement curses' window handling!
03:03:52 <allbery_b> Lycurgus: sorry I missed your question.  1978 or thenabouts :)
03:04:56 <allbery_b> ncurses took years to get it right, and original curses has bugs in corner cases (some of them relatively common) that have never been fixed
03:05:04 <wli> allbery_b: The plot is mostly centered around constructing a readline equivalent in native Haskell vs. windowing.
03:05:06 <Stinger_> heh damn, theres a series of interesting looking vids linked to on that page that are unfortunately in german
03:05:32 <dobblego> Stinger_, what kind of video are you after specifically?
03:05:53 <Lycurgus> isn't there already an hcurses or sumthin?
03:05:58 <allbery_b> ah.  so do FFI bindings to terminfo for output.  input is unfortunately going to be interesting no matter what
03:06:12 <allbery_b> yes, I pointed out hscurses (and vty) earlier
03:06:38 <wli> allbery_b: There are other nasties about ncurses which are more general than Haskell esp. in the API but anyway.
03:06:42 <Stinger_> well an intro to the monad libraries would be ideal, but the one I was refering to was on generic programming
03:07:14 <dobblego> I don't know about a video on generic programming, but there might be one there
03:07:23 <wli> allbery_b: Input is my primary concern. Windowing I don't care about much if at all.
03:07:38 <Stinger_> yeah I'll keep looking through em
03:09:05 <wli> allbery_b: Actually an editbox windowing widget would be nice but it drags in the rest of the windowing system (which is basically crap).
03:10:04 <allbery_b> honestly?  go look at vty
03:10:05 <wli> allbery_b: The state management is fatally flawed to the point you're stuck spawning tty IO slave processes to work around it.
03:10:16 <math_guy90> doh
03:11:07 <wli> allbery_b: I did and saw it was inadequate in the input department and also not portable across terminal types and so became inspired to do whatever I did.
03:11:29 <quicksilver> harsh words from ndm about nhc...
03:12:23 <allbery_b> sour grapes froma  competitor?  (ndm is behind yhc, isn't he?)
03:12:29 <wli> allbery_b: (Yes, processes, not threads. You need copies of memory because the data structures are global.)
03:12:42 <quicksilver> he uses it, and he's at york
03:12:59 <quicksilver> he's not 'behind' it AFAIK
03:13:05 <allbery_b> what benighted place are you at that still uses non-ANSI terminals?
03:14:15 <wli> allbery_b: There are still plenty of uses for non-ANSI terminals, like line printer consoles, Braille consoles, and so on.
03:21:16 * wli is really liking Cayenne.
03:33:23 <Heffalump> wli: and only on Thursday I was being told Cayenne had failed :-)
03:35:11 <wli> Heffalump: Oh dear. Where do I go for dependent types, then?
03:35:42 * wli will probably end up being the lone user.
03:36:22 <wli> Heffalump: There is something to be said for avoiding success. ;)
03:37:52 * wli thinks about numeric hierarchies and fraction-free Gaussian elimination over Z[5^(1/2)] to distract himself from his utter failure to get X working after a week straight.
03:38:46 <Heffalump> I don't think it's failed, per se, but I doubt it has many users or much/any development.
03:39:25 <wli> Dependent types mean I can get a numeric hierarchy that doesn't suck.
03:41:39 <wli> I just need to get a bit further than hello world.
03:46:42 <Heffalump> anyone familiar with building GHC? In particular is there a way to build a 32-bit i386 version on a 64-bit machine?
03:47:21 <wli> AIUI cross-builds are difficult somehow.
03:48:01 <wli> I've had my own biarch difficulties.
03:50:32 <abell> Heffalump, if you are on Linux, I would chroot into a 32-bit environment and work from there
03:51:39 <wli> I was trying to build a ghc targetting x86-64 on an x86-32 -mostly userspace on an x86-64 box.
03:52:07 <wli> It did not go smoothly.
03:55:07 <hpaste>  (anonymous) annotated "used to calculate likelihood of certain coin toss patterns" with "(no title)" at http://hpaste.org/4068#a2
03:55:31 <Heffalump> abell: ok, I was hoping to avoid doing that :-)
03:56:20 <Heffalump> actually, I'm not sure what my userspace is, now I come to think of it...
03:56:33 <Heffalump> there must be an obvious way to check (Debian)
03:56:58 <wli> file `which file`
03:57:07 <Heffalump> cunning :-)
03:57:18 <Heffalump> ok, so it's a 32-bit userspace, but GHC's configure still seems to decide on 64 bit.
03:57:31 <wli> It goes by the uname of the machine.
03:57:46 <Heffalump> right. Is it just a question of passing it a few flags and everything else will work out?
03:57:51 <hpaste>  (anonymous) annotated "used to calculate likelihood of certain coin toss patterns" with "(no title)" at http://hpaste.org/4068#a3
03:57:58 <wli> There's an environment trick or two and a few fixups beyond that in the code where that gets bypassed.
03:59:34 <Heffalump> ugh
03:59:37 <wli> linux32 is the first trick, the second is to export CC="gcc -m32" or similar because gcc itself is insane and insists on incompatibility by always generating 64-bit code unless specifically directed.
03:59:44 <Heffalump> surely the GHC developers must have to do this a lot?
04:00:11 <wli> Leave off the "in" in let
04:00:40 <Heffalump> what do you mean by 'linux32'?
04:00:47 <wli> /usr/bin/linux32
04:01:14 * Heffalump installs it
04:01:20 <wli> I think it tries to use an LD_PRELOAD to intercept uname syscalls.
04:01:39 <wli> It's in linux32 on Debian.
04:01:52 <Heffalump> indeed, I've got it and am configuring now
04:02:17 <wli> Anyway, whenever the environment gets blown away these things stop working.
04:03:15 <wli> And that happens, so you'll see build failures and 64-bit ELF files floating around. Where that happened I went in and added crap to makefiles or edited source to remove things activated by 64-bit defines.
04:03:41 <hkBst> > let hy x = PutStr "hello" >> x in hy 3
04:03:43 <lambdabot>   Not in scope: data constructor `PutStr'
04:03:59 <wli> Lowercase putStr
04:04:32 <wli> Identifiers starting with capital letters are special things like types and constructors (trust us, this helps).
04:04:54 <phlpp> > let hy x = putStr "foo " >> 3 in hy 3
04:04:56 <lambdabot>   add an instance declaration for (Num (IO b))
04:04:56 <lambdabot>     In the expression: let hy ...
04:05:25 <phlpp> > let hy x = putStr "foo " ++ putStr 3 in hy 3
04:05:26 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
04:05:38 <phlpp> > let hy x = putStr "foo " >> show x in hy 3
04:05:38 <lambdabot>  Couldn't match expected type `IO' against inferred type `[]'
04:05:53 <phlpp> > let hy x = putStr "foo " >> putStr x in hy 3
04:05:53 <lambdabot>   add an instance declaration for (Num String)
04:05:57 <wli> let hy x = putStrLn $ "foo " ++ show x in hy 3
04:06:05 <phlpp> boo!
04:08:34 <Heffalump> I guess I could just reboot onto a 32-bit kernel...
04:08:48 <hkBst> let hy x = putStr "hello" >> x in (hy 3) (liftM +) (hy 2)
04:08:53 <hkBst> > let hy x = putStr "hello" >> x in (hy 3) (liftM +) (hy 2)
04:08:54 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
04:10:05 <wli> :t let hy x = putStr "hello " >> return x in liftM2 (+) (hy 3) (hy 2)
04:10:09 <lambdabot> forall a1. (Num a1) => IO a1
04:10:50 <hkBst> > let hy x = putStr "hello" >> x in (liftM2 (+)) (hy 3) (hy 2)
04:10:54 <lambdabot>   add an instance declaration for (Num (IO b))
04:11:19 <wli> You need return x
04:12:01 <hkBst> wli: isn't there some trick to make return implicit?
04:12:51 <hkBst> > let hy x = do{putStr "hello"; x} in (liftM2 (+)) (hy 3) (hy 2)
04:13:03 <lambdabot>   add an instance declaration for (Num (IO a1))
04:13:18 <sjanssen> hkBst: no
04:13:20 <wli> hkBst: No implicit return, sorry.
04:13:54 <wli> hkBst: We don't want you to forget you're in a monad.
04:15:44 <hkBst> how do I make ghci recognize liftM2 ?
04:15:55 <wli> Do :m + Control.Monad
04:16:55 <wli> let hy x = putStr "hello " >> return x in liftM2 (+) (hy 3) (hy 2) :: IO Int
04:17:03 <wli> That works in ghci with no warnings for me.
04:17:36 <hkBst> wli: it works now :)
04:18:11 <hkBst> > let hy x y = putStr x >> return y in liftM2 (+) (hy "a" 1) (hy "b" 2)
04:18:16 <wli> hkBst: I use -Wall in ghci to warn me when types are defaulted.
04:18:25 <lambdabot>  <IO Integer>
04:18:45 <hkBst> wli: defaulted?
04:19:12 <wli> hkBst: 1 could be an Int or an Integer or a Double or a Rational.
04:19:49 <wli> hkBst: If there's not enough information to decide, the default behavior of the compiler is to silently choose one for you.
04:19:56 <wli> hkBst: I prefer to be warned.
04:21:25 <hkBst> in that expression above, is it garuanteed that b prints after a?
04:21:45 <wli> > (read $ show 5) + 1
04:22:00 <lambdabot>  6
04:22:04 <wli> hkBst: That's a good example of defaulting gone wild.
04:22:11 <wli> :t (read $ show 5) + 1
04:22:12 <lambdabot> forall a. (Read a, Num a) => a
04:22:34 <wli> hkBst: Yes, it's guaranteed that b prints after a.
04:22:41 <Armor_Azrael> Hey, can someone tell me how to make an instance that operates something like:
04:22:41 <Armor_Azrael> instance Eq (a -> b)
04:22:41 <Armor_Azrael>    a == b = False
04:23:05 <Armor_Azrael> Basically, I know function equality is hard, and have a data structure that sometimes has function attributes, and want it to be able to derive eq
04:23:12 <Armor_Azrael> ideas?
04:24:24 <hkBst> wli: I don't understand what's gone wild.
04:25:49 <hkBst> ML seems to like to default types though :)
04:26:01 <Armor_Azrael> err, my bad, I figured it out
04:26:10 <Armor_Azrael> I just needed another nesting of parens, sorry
04:27:47 <hkBst> the order of evaluating function arguments depends on the function definition, right?
04:28:50 <desegnis> hkBst: It even depends on the function definition whether function arguments are evaluated at all. So I guess the answer is yes.
04:29:43 <hkBst> :src liftM2
04:29:46 <desegnis> hkBst: Note, though, that Haskell implementations do not guarantee any specific evaluation order. They only guarantee to deliver the right result.
04:29:56 <bakert> If I have something in a monad and I want to move it into IO monad - am I relying on the creator of the monad to have provided a Monad x -> IO x type function?  Or is there a more general way to achieve that?
04:30:16 <hkBst> @src liftM2
04:30:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:30:22 <bakert> (I actually just want to print something that is in Gen (from QuickCheck))
04:30:56 <desegnis> bakert: The Monad must incorporate IO somehow. There is a MonadIO class that gives you liftIO.
04:31:20 <bakert> thanks
04:32:06 <hkBst> @src liftM6
04:32:06 <lambdabot> Source not found.
04:32:42 <bakert> :t Test.QuickCheck.generate
04:32:48 <lambdabot> forall a. Int -> StdGen -> Gen a -> a
04:33:03 <desegnis> I think the idea of liftIO is that any monad transformer simply passes it through to the underlying monad, so even if using nested monad transformers, it will finally reach IO.
04:35:08 <desegnis> I don't see any IO in Gen, though, so you might have to fall back to using trace
04:38:08 <wli> Sorry, nature called.
04:38:30 <wli> hkBst: How are things going over there?
04:39:23 <hkBst> wli: I need to practice my Monads and read up :)
04:39:28 <wli> http://holomorphy.com/~wli/LiftedIO.hs
04:40:12 <wli> hkBst: I found springschool95.ps (also .pdf) and YAHT to be the two monad things that got me off the ground.
04:41:17 <hkBst> http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf
04:41:40 <hkBst> thanks wli
04:41:45 <wli> hkBst: That's the first of the two. YAHT is hosted on haskell.org now AIUI.
04:42:00 <wli> hkBst: Beware that springschool95.pdf uses antiquated notation.
04:43:17 <wli> hkBst: The big enlightening example was the join operation on AST's (or otherwise variable substitution).
04:45:20 <wli> %format return \eta
04:45:54 * wli found it annoying that standard IO bits weren't lifted in the first place, and so wrote LiftedIO.hs
04:47:19 <hkBst> wli: standard IO bits as in string operations?
04:47:45 <mauke> ?
04:47:58 <wli> hkBst: outputting strings to handles, inputting strings from handles, etc.
04:48:59 <wli> hkBst: This only matters when you've got monad transformer stacks in play.
04:49:40 <hkBst> wli: hehe :) I'll not worry about it then
04:51:13 <Mitar> how can I convert an Int to Char (ASCII)?
04:51:19 <Heffalump> @type chr
04:51:21 <lambdabot> Int -> Char
04:51:23 <wli> hkBst: A lot of times people want to "escape" the IO monad. That's the wrong way. You use monad transformer stacks and it looks "inside out" there and you can freely mix IO with the other monads given lifting like I've done in LiftedIO or lifting various other IO subroutines you may have defined for yourself. Then when you force the monad transformer stack you unravel it all.
04:52:03 <Mitar> not in scope?
04:52:18 <Mitar> Data.Char :-)
04:52:19 <Mitar> thanks
04:52:32 <wli> hkBst: I'd not even try to get around without monad transformers and the MTL (Monad Transformer Library).
05:44:13 <bakert_> Is there any haskell wiki software?  I suppose I mean written in haskell or particularly haskell-friendly?  What does haskell.org use?
05:45:34 <bakert_> it's some earlier or customized version of MediaWiki by the looks of things
05:49:39 <mauke> MediaWiki 1.5.4
05:52:25 <bakert_> hmm ... thinks about writing the 9 millionth implementation of wiki ...
05:57:02 <sannysanoff> @quite ghc API
05:57:02 <lambdabot> Maybe you meant: quit quote
05:57:08 <sannysanoff> @quote ghc API
05:57:08 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
06:10:23 <vwx> hello
06:10:57 <pmatos> Hello all, I know there is a way to do this but I can't remember the syntax to strictly evaluate a function in haskell.
06:11:02 <pmatos> Anyone?
06:11:24 <mauke> what do you mean by that?
06:11:49 <Zao> $! maybe?
06:11:51 <pmatos> mauke: ok, basically I have a function which returns a list and I want to tell ghc to compute the whole list, not just the first element.
06:12:14 <desegnis> pmatos: You can force the order of evalution using  seq  , or you may annotate a field of a data constructor to be strict.
06:12:29 <mauke> (length x `seq` x)
06:12:50 <desegnis> pmatos: The whole list, does that include all its elements, too?
06:13:01 <pmatos> yeah, but guess that the function is called f. I want to compute the difference between calling head $ f and the strict evaluation of f.
06:13:24 <vwx> how can i sort a list of strings case insensitively?
06:13:27 <pmatos> Basically I want to make sure that my function is really doing lazy evaluation on f.
06:13:28 <pmatos> heh
06:13:49 <mauke> sortBy (\x y -> lc x `compare` lc y) strings
06:13:52 <mauke> where lc = map toLower
06:13:54 <pmatos> desegnis: yes, i guess so.
06:14:37 <pmatos> desegnis: f returns a list of numbers so in a sense I want to ask GHC to compile all the list as if for printing it but without printing (I don't want to know about the time it takes to print)
06:15:16 <mauke> show xs `seq` ()
06:15:17 <desegnis> pmatos: Then mauke's solution would not be enough for you. You'd need something like  foldr seq result xs
06:15:21 <pmatos> the problem of calling length of f is that it'll include the time of length which although is probably only linear on the size of the list, might be a lot.
06:15:43 <mauke> uh, getting the length is effectively O(1) there
06:15:49 <desegnis> (Oh, I'm always thinking ina too complicated way.)
06:15:58 <mauke> you already get linearity from forcing the whole thing
06:15:58 <pmatos> mauke: why?
06:16:14 <mauke> keeping a counter on top of that shouldn't cost much
06:16:19 <pmatos> ok...
06:16:45 <bakert_> ?hoogle getArgs
06:16:46 <lambdabot> System.getArgs :: IO [String]
06:16:48 <pmatos> is there any function to time a function execution. Some other languages have something called time. Is there such a thing in haskell?
06:17:21 <allbery_b> @go site:haskell.org timing computations
06:17:26 <faxathisia> there is always, time ./haskellprogram
06:17:27 <desegnis> pmatos: If you _just_ want to make sure that f does not consume the whole list, just do f (xs ++ undefined).
06:17:27 <lambdabot> http://www.haskell.org/haskellwiki/Timing_computations
06:17:27 <lambdabot> Title: Timing computations - HaskellWiki
06:18:08 <allbery_b> you *really* want to read that, there are many pitfalls
06:18:43 <pmatos> desegnis: what if undefined? will that throw exception when evaluated?
06:18:47 <mauke> which language uses "time" for timings?
06:18:48 <pmatos> allbery_b: thx
06:19:03 <pmatos> mauke: scheme at least . you can do (time (function x))
06:19:04 <faxathisia> bash & common lisp
06:19:05 <pmatos> for example
06:19:12 <mauke> ah
06:19:15 <faxathisia> as well
06:19:17 <mauke> lisp weirdos
06:19:21 <desegnis> pmatos: Yes. It's only useful if you really want a weird error condition :)
06:19:23 <pmatos> mauke: lol
06:19:31 <pmatos> desegnis: greaT1
06:20:01 <sannysanoff> hello all, I am using GHC API to parse haskell code (and get parser tree), but "load" produces '.o' files, which I do not need. How to stop it after parsing phase?
06:20:02 <desegnis> pmatos: Of course, you have error "bla", too
06:21:04 <sannysanoff> ... i am reading through the GHC code for last 2 hours, but nothing works... (ghci debugger is not an option ;-)
06:21:06 <pmatos> desegnis: right... I keep forgetting that haskell is lazy and I can do that sort of stuff.
06:21:06 <pmatos> heh
06:24:06 <pmatos> mauke: I'm trying for example: show xs ++ undefined `seq` () but this doesn't throw undefined, so I would guess it doesn't compute the whole list?
06:24:34 <pmatos> well, in fact is show (xs ++ undefined) `seq` ()
06:24:42 <pmatos> but still, I get () and that's it.
06:26:27 <nornagon> > let xs = [] in show (xs ++ undefined) `seq` ()
06:26:28 <lambdabot>  Undefined
06:27:35 <allbery_b> > let xs = [1] in show (xs ++ undefined) `seq` ()
06:27:35 <lambdabot>  ()
06:27:49 <nornagon> oh right.
06:28:23 <pmatos> so I would guess that xs is not evaluated at all, right?
06:28:28 <desegnis> The problem is that show returns a lazy string.
06:28:37 <pmatos> oh...
06:28:40 <pmatos> :-\
06:28:40 <allbery_b> > let xs = [1] in (xs ++ undefined) `seq` ()
06:28:42 <desegnis> (I think)
06:28:43 <nornagon> > let xs = [1] in (show xs ++ undefined) `seq` ()
06:28:44 <lambdabot>  ()
06:28:44 <lambdabot>  ()
06:28:50 <nornagon> huh
06:29:40 <faxathisia> > (reverse $ reverse $ ([1,2,3]++undefined)) `seq` ()
06:29:42 <lambdabot>  Undefined
06:29:51 <faxathisia> > (show $ reverse $ reverse $ ([1,2,3]++undefined)) `seq` ()
06:29:51 <lambdabot>  Undefined
06:30:00 <faxathisia> > (([1,2,3]++undefined)) `seq` ()
06:30:00 <lambdabot>  ()
06:30:05 <faxathisia> > (show $ ([1,2,3]++undefined)) `seq` ()
06:30:05 <lambdabot>  ()
06:30:43 <desegnis> Since lists (and thus, strings) are defined inductively, a list on the left of a `seq` will only have the first (:) of the list evaluated.
06:30:51 <allbery_b> does seq only reify xs, and not the spine of the list contained?
06:30:53 <nornagon> > ([undefined]) `seq` ()
06:30:53 <allbery_b> ah
06:30:53 <lambdabot>  ()
06:31:17 <faxathisia> @pl \f->f this doesnt make any sense
06:31:17 <lambdabot> flip (flip (flip (flip ($ this) doesnt) make) any) sense
06:31:31 <idnar> heh
06:31:31 <allbery_b> that's fine, it only reifies the list, not the first element
06:31:45 <allbery_b> @pl \f->f
06:31:46 <lambdabot> id
06:32:01 <idnar> :t undefined
06:32:03 <lambdabot> forall a. a
06:32:28 <faxathisia> :t let __ = __ in __
06:32:28 <lambdabot> forall t. t
06:32:37 <desegnis> allbery_b: More precisely, it only reifies the first cons cell of the list
06:32:56 <allbery_b> yeh
06:34:07 <desegnis> > let reify xs = foldr seq xs xs in reify ([1,2,3] ++ undefined)
06:34:08 <lambdabot>  Undefined
06:34:58 * wli fails to code his way out of a wet paper bag in Cayenne.
06:35:31 <allbery_b> even that nly does the cons cells and not their contents, right?
06:35:47 <allbery_b> > let reify xs = foldr seq xs xs in reify ([1,2,3,undefined])
06:35:48 <lambdabot>  Undefined
06:35:50 <allbery_b> hm
06:36:07 <allbery_b> oh, right.  n/m
06:36:30 <allbery_b> inserting more pointers than exist :)
06:36:52 <desegnis> Still:
06:37:24 <desegnis> > let reify_ xs = foldr seq () xs in reify [[1,2],[3,undefined]]
06:37:26 <lambdabot>   Not in scope: `reify'
06:37:30 <desegnis> er
06:37:36 <desegnis> > let reify_ xs = foldr seq () xs in reify_ [[1,2],[3,undefined]]
06:37:37 <lambdabot>  ()
06:37:49 <desegnis> obviously...
06:38:08 <allbery_b> yeh
06:44:45 <pmatos> thanks guys... It'll definitely take me some time to understand what's going on but I'll get there. :-) heh.
06:45:17 <pmatos> Anyway, I bought The Haskell Road to Logic Maths and Programming, what would be the next one???
06:48:48 <allbery_b> just to amuse yourself, explain the result of   let reify xs = foldr seq xs xs in reify [[1,2],[3,undefined]]   in ghci
06:50:13 <allbery_b> (lambdabot won't work for this)
06:50:45 <desegnis> pmatos: A ‚ÄúReal World Haskell‚Äù book has been announced for... maybe next year, and it looks promising
06:51:24 <fnord123> !where logs
06:51:42 <fnord123> (its in the topic, hurr)
06:51:44 <nominolo> javascript++
06:51:56 <nominolo> @karma javascript
06:51:56 <lambdabot> javascript has a karma of 1
06:52:06 <nominolo> @karma java
06:52:06 <lambdabot> java has a karma of -22
06:52:11 <mjrosenb> i join #haskell, and the first thing i see is javascript++ :(
06:52:14 <fnord123> @haskell erlang
06:52:15 <lambdabot> Unknown command, try @list
06:52:17 <desegnis> allbery_b: Lambdabot responses with ‚Äúthread killed‚Äù? Amusing.
06:52:23 <faxathisia> javascript++
06:52:24 <fnord123> @karma erlang
06:52:24 <lambdabot> erlang has a karma of 0
06:52:34 * allbery_b wa sjust thinking LB needs the same hack it has for java karma
06:52:36 <nominolo> mjrosenb: we are (I am) open-minded
06:52:43 <allbery_b> hm, it produced Undefined for me
06:52:54 <allbery_b> but ghci does something a little different
06:53:09 <faxathisia> in javascript you can write a program which lets you click on an image to get a list of coordinates in 2 lines of code :)
06:53:09 * mjrosenb wants to test the @karma of lots of fun stuffs now
06:53:14 <faxathisia> this is a *good thing*
06:53:15 <allbery_b> <allbery_b> > let reify = join (foldr seq) in reify [[1,2],[3,undefined]]
06:53:15 <allbery_b> <lambdabot>  Undefined
06:53:17 <chessguy> mjrosenb, what do you have against javascript?
06:53:32 * allbery_b admits to cheating there :)
06:53:58 <allbery_b> hm, suppose the chet might affect the result
06:54:00 <nominolo> faxathisia: javascript is very nice for what it is intended
06:54:01 <mjrosenb> chessguy: it's fine as long as i don't have to touch it
06:54:02 <desegnis> allbery_b: Now it produces Undefined for me, too. Seems the bot hung for a second. Ah, lambdabot handles undefined differently from ghci...
06:54:04 <fnord123> pmatos, I found Haskell School of Expression to be pretty good.
06:54:12 <allbery_b> right
06:54:13 <nominolo> yahooooo: especially with jQuery
06:54:15 <chessguy> js is quite an interesting language
06:54:20 <mjrosenb> chessguy: and as long as it doesn't blow up in my face
06:54:33 <mjrosenb> right, so does anyone know if haskell supports or patterns?
06:54:47 <faxathisia> mjrosenb: What would that be?
06:54:56 <nominolo> er ... i meant faxathisia
06:55:28 <mjrosenb> faxathisia: you know sml?
06:55:40 <faxathisia> mjrosenb: only really basics
06:55:46 <mjrosenb> http://rafb.net/p/q0nBgC10.html
06:55:46 <lambdabot> Title: Nopaste - No description
06:56:15 <mjrosenb> faxathisia: that's an example .. it's something that's planned for the next version of sml
06:56:17 <geocalc> @karma--
06:56:17 <lambdabot> usage @karma(+|-) nick
06:56:25 <allbery_b> mjrosenb: actually there is some excuse for javascript:  yhc can compile a subset of haskell to javascript
06:56:25 <faxathisia> mjrosenb: so does it match either
06:56:48 <mjrosenb> faxathisia: basically. . and it binds x in both cases
06:57:05 <faxathisia> mjrosenb: is it equivalent to this http://rafb.net/p/7PAzXP87.txt
06:57:06 <vwx> allbery_b: do you a lot about yhc javascript target?
06:57:19 <allbery_b> not a whole lot, I just know it's there
06:57:19 <nominolo> mjrosenb: that seems of very limited use
06:57:21 <paczesiowa> hi, could someone confirm this bug: http://hpaste.org/4069 ?
06:57:30 <mjrosenb> faxathisia: yes, but with less code
06:57:32 <nominolo> mjrosenb: x has to be the same type in both
06:57:35 <allbery_b> something was posted to haskell-cafe recently about the current status and some examples
06:57:47 <vwx> allbery_b: yeah, i read that. very cool stuff
06:57:56 <mjrosenb> nominolo: you'd be surpriesed, and yes
06:58:05 <faxathisia> mjrosenb: no I don't there is any way to do this in haskell
06:58:52 <faxathisia> mjrosenb: of course you can do extractOne (y, NONE) = extractOne (NONE, y)
06:58:59 <faxathisia> if you decide on some canonical ordering
06:59:15 <faxathisia> (cause I'm guessing = x would be something a lot longer..)
06:59:32 <faxathisia> mjrosenb: or you can define both cases and use f x ... later on where f x =
07:00:00 <mjrosenb> allbery_b: just because you can compile something useful to a given language doesn't mean the target language is useful
07:00:08 <nominolo> mjrosenb: what are better uses of this?
07:00:18 <mjrosenb> nominolo: RB trees
07:00:27 <mjrosenb> nominolo: general syntatic sugar
07:00:28 <faxathisia> > let f x = x*x in case (Just 5) of Just x -> f x ; Nothing -> f 0
07:00:39 <lambdabot>  25
07:00:40 <faxathisia> > case (Just 5) of Just x -> f x ; Nothing -> f 0 where f x = x*x
07:00:41 <lambdabot>   Not in scope: `f'
07:00:43 <faxathisia> hmf
07:00:47 <faxathisia> well they should be equivalent
07:01:06 <faxathisia> mjrosenb: anyway I'd use where in that casd
07:02:19 * nominolo goes back to javascript coding ..
07:02:35 <mjrosenb> hrmmm
07:02:40 <mjrosenb> @karma prolog
07:02:40 <lambdabot> prolog has a karma of -1
07:02:44 <mjrosenb> :(
07:03:20 <mjrosenb> what's the default value for something?
07:03:28 <nominolo> @karma
07:03:28 <lambdabot> You have a karma of 0
07:03:33 <nominolo> that is
07:03:41 <mjrosenb> oic
07:04:10 <paczesiowa> mjrosenb: do you like prolog? then check whether this prolog parser gives you segfaults http://hpaste.org/4069
07:04:14 <faxathisia> @quote prolog
07:04:14 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
07:04:17 <mjrosenb> @karma i_hope_nobodys_changed_the_karma_of_this
07:04:17 <lambdabot> i_hope_nobodys_changed_the_karma_of_this has a karma of 0
07:04:23 <faxathisia> paczesiowa: writing a prolog?
07:04:26 <mjrosenb> i_hope_nobodys_changed_the_karma_of_this++
07:04:38 <faxathisia> paczesiowa: ahh nice
07:04:41 <firefly> I asked about "sparks" yesterday and they are described in the article "Automatic Spark Strategies and Granularity for a Parallel Functional Language Reducer", Kevin Hammond, Jim S. Mattson Jr, and Simon L. Peyton Jones.
07:04:48 <ZsoL> @karma
07:04:48 <lambdabot> You have a karma of 0
07:05:09 <paczesiowa> faxathisia: yes, but that code was first try. right now I'm finishing prolog lexer (ISO draft compliant:P)
07:05:23 <faxathisia> paczesiowa: I wrote an ISO lexer and parser with Parsec for prolog
07:05:31 <faxathisia> paczesiowa: but I broke my HD and lost everything >:|
07:05:53 <ZsoL> that just happened to me, too
07:06:28 <ZsoL> now I'm on a raid1 array :D
07:06:59 <allbery_b> <3 backups
07:07:08 <paczesiowa> wouldn't happen if you shared that code:> I couldn't google anything non-trivial for prolog in haskell
07:07:31 <mjrosenb> paczesiowa: prolog.hs:40:9: The last statement in a 'do' construct must be an expression
07:09:06 <mjrosenb> paczesiowa: what the deuce is "<|>"?
07:09:16 <allbery_b> parsec alternation
07:09:34 <paczesiowa> I hate hpaste, it alters tabs
07:09:41 <allbery_b> the parser a <|> b attempts to parse a, and if it fails attempts to parse b instead
07:09:48 <mjrosenb> paczesiowa: yeah, sounds about right
07:09:48 <paczesiowa> wait I'll switch tabs to 8 spaces
07:09:49 <allbery_b> tabs are evil
07:10:02 <faxathisia> tabs are fine just not in source code :p
07:10:02 <paczesiowa> I like them
07:10:13 <mjrosenb> okee, so i'm going to move that all onto one line
07:10:20 <allbery_b> (more to the point, tabs are inconsistent.  typically 8 n unix and 4 or 5 on windows)
07:11:17 <sieni> tabs are just fine in source code. just use them properly
07:11:22 <hpaste>  Paczesiowa annotated "ghc-6.8.1 segfaults" with "tab-free version" at http://hpaste.org/4069#a2
07:11:34 <sieni> if your editor fubars your haskell source code, you are using the wrong editor
07:12:13 <paczesiowa> mjrosenb: try it now
07:12:44 <faxathisia> paczesiowa: well main gave me Struct "john" [Numb 1] in GHC 6.6.1
07:12:56 <paczesiowa> faxathisia: I know, problem is with 6.8.1
07:13:10 <mjrosenb> paczesiowa: i think there's something fubared with my ghc install
07:13:13 <faxathisia> ah sorry.. I wasn't able to compile 6.8.1 yet
07:13:22 <mjrosenb> prolog.hs:3:0: Failed to load interface for `Text.ParserCombinators.Parsec'
07:13:56 <paczesiowa> if you have 6.8.1 you must install parsec library (it's not anymore in ghc itself)
07:14:12 <paczesiowa> unless you use windows
07:14:23 <faxathisia> paczesiowa: I think the best thing to do is just make this segfaulting code as minimal as posssible
07:14:24 <mjrosenb> oh, hey, that's a package in the overlay
07:14:36 <faxathisia> so it is easier to determine/fax what exactly is wrong
07:14:49 <faxathisia> fix * :/
07:15:21 <mjrosenb> there are a bunch of things in the regex library that don't compile correctly with 6.8.1
07:15:40 <paczesiowa> you don't need regex
07:15:44 <desegnis> paczesiowa, mjrosenb: Parsec is in the extralibs tarball.
07:15:57 <paczesiowa> we use gentoo apparently:P
07:16:09 <mjrosenb> paczesiowa: yes indeed
07:16:25 <mjrosenb> prolog.o: In function `s10b_info':
07:16:25 <mjrosenb> (.text+0x172): undefined reference to `parseczm2zi1zi0zi0_TextziParserCombinatorsziParsecziChar_oneOf_closure'
07:16:29 <paczesiowa> so "emerge dev-haskell/parsec" is all we need
07:16:35 <mjrosenb> lots and lots of those
07:16:47 <paczesiowa> mjrosenb: compile it with "--make" or "package parsec"
07:16:47 <desegnis> D'oh :)
07:17:15 <paczesiowa> mjrosenb: I wrote those commands in comments at the bottom of src
07:17:21 * mjrosenb needs to learn how to use haskell's package system
07:17:37 <mjrosenb> paczesiowa: mjrosenb@guide2 ~/projects/test $ ./prolog
07:17:37 <mjrosenb> Struct "john" [Numb 1]
07:17:59 <paczesiowa> faxathisia: I tried doing that, I can't simplify it more (previous versions didn't segfault) besides check my comments at hpaste, it segfaults with ghci and ghc -e but not with ghc itself
07:18:10 <bjorkintosh> how similar is haskell to erlang?
07:18:22 <bjorkintosh> ... on a one to ten scale.
07:18:23 <paczesiowa> mjrosenb: did you compile with ghc? try ghci or ghc -e
07:18:34 <mjrosenb> let me try with -e
07:18:39 <vwx> bjorkintosh: not similar
07:18:48 <bjorkintosh> okay thanks.
07:18:54 <paczesiowa> ghc Segfault.hs -e "main" -Wall -Werror
07:19:09 <bjorkintosh> so i shouldn't pay 55 bucks for that one haskell book i saw then.
07:19:39 <mjrosenb> mjrosenb@guide2 ~/projects/test $ ghc prolog.hs --make -e "main"  -Wall -Werror
07:19:39 <mjrosenb> Struct "john" [Numb 1]
07:19:48 <paczesiowa> don't pay for haskell books, there's plenty of free haskell knowledge
07:20:16 <allbery_b> mjrosenb: --make is implied for ghci or ghc -e, fwiw
07:20:25 <bjorkintosh> hmm
07:20:40 <mjrosenb> allbery_b: thanks
07:20:43 <allbery_b> (there's a bug registered to make it the default for regular ghc for consistency)
07:20:43 <paczesiowa> mjrosenb: --make and -e doesn't work (it just compiles, doesn't run it with -e)
07:20:50 <allbery_b> ah
07:20:52 <hpaste>  mlesniak pasted "Beginner question: Good approach for passing config options?" at http://hpaste.org/4070
07:21:17 <daniel_larsson> bjorkintosh: They're both functional languages, but otherwise there are lots of differences. Haskell is statically typed, Erlang dynamically, etc.
07:21:21 * mlesniak wasn't able to figure out a better title ;)
07:21:58 <mjrosenb> dynamically typed functional language??? :(
07:22:11 <mauke> scheme?
07:22:30 <mjrosenb> mauke: never really like scheme
07:22:33 <mjrosenb> same reason
07:23:29 <faxathisia> so strange people hating certain types of programming language so strongly :p
07:24:02 <bjorkintosh> faxathisia, it's a religious matter and cannot be questioned nor commented on.
07:24:06 <mjrosenb> faxathisia: that's because they were created by satan
07:24:32 <mauke> where satan = Alonzo Church?
07:24:40 <mjrosenb> i mean just look at malbolge
07:24:48 <vwx> does erlang have any major advantages over haskell? apart from the automatic distributed feature, which probably wouldn't be too hard to implement in haskell anyway?
07:25:07 <paczesiowa> mjrosenb: is it segfaulting yet?:P
07:25:08 <resiak> some people love the bitfield syntax
07:25:17 <mjrosenb> paczesiowa: nope. . .
07:25:18 <ricky_clarkson> Yes, it's dynamically typed.
07:25:48 <paczesiowa> mjrosenb: how do you run it?
07:26:01 <mjrosenb> paczesiowa: i ran ghc with the command that you gave me, and it ran succussefuly
07:26:25 <mjrosenb> paczesiowa: mjrosenb@guide2 ~/projects/test $ ghc prolog.hs --make -e "main"  -Wall -Werror
07:26:28 <mjrosenb> Struct "john" [Numb 1]
07:28:24 <paczesiowa> mjrosenb: when you compiled it with --make earlier there are still working binaries. delete prolog.o prolog.hi and a.out and run again ghc prolog.hs -e "main"  -Wall -Werror
07:29:11 <allbery_b> segfauted here (6.9.20071025 PPC-G4)
07:29:12 <mjrosenb> paczesiowa: yep. . .segfaults now
07:29:41 <paczesiowa> so, off to file a bug report (my first:D)
07:30:03 <bjorkintosh> aloha.
07:32:06 <mjrosenb> paczesiowa: oh yeah, this is on amd64
07:32:40 <wli> Nice, a Prolog interpreter.
07:32:58 <hpaste>  allbery_b annotated "ghc-6.8.1 segfaults" with "backtrace" at http://hpaste.org/4069#a3
07:33:42 <paczesiowa> allbery_b: how do I get that backtrace?
07:33:58 <hpaste>  tphyahoo-haskel pasted "is there a more way to generate helper functions for a state type based on records?" at http://hpaste.org/4071
07:34:34 <allbery_b> find the real gdb binary ($prefix/lib/ghc-$version/ghc-$version) and run gdb on it and the core file, "bt" command
07:35:07 <mjrosenb> allbery_b: you mean the real ghc binary
07:35:28 <mjrosenb> paczesiowa: that might not work, i think portage strips all binaries on the system
07:35:39 <allbery_b> since I'm on a mac and using an (old) darcs build: gdb /usr/local/lib/ghc-6.9.20071025/ghc-6.9.20071025 /cores/core.6172
07:35:47 <SamB_XP> mjrosenb: ALL?
07:35:58 <allbery_b> (after ulimit -c unlimited)
07:35:59 <mjrosenb> SamB_XP: errr, all binaries that it installs
07:36:02 <tphyahoo-haskell> I read "haskell record types considered grungy"... I think this is the same thing that was complaining about.
07:36:39 <tphyahoo-haskell> http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
07:36:40 <lambdabot> Title: Haskell Records Considered Grungy ´ :: (Bloggable a) => a -> IO (), http://tinyurl.com/3akjdr
07:36:43 <SamB_XP> well, I suppose, with the way Gentoo users are, everything would have been built with -fomit-frame-pointer, so even if they had basic symbols a backtrace would be unobtainable...
07:36:48 <ricky_clarkson> "Static type checking is a compile-time abstraction of the runtime behaviour of your program, and hence it is necessarily only partially sound and complete"
07:37:09 <idnar> heh
07:37:21 <mjrosenb> SamB_XP: i don't have a frame pointer.  . . amd64 sort of destroyed it
07:37:36 <ricky_clarkson> I think this is wrong, and cite 'id' as an example.  I would ask "what's the smallest program for which static type checking is only partially sound?".  Does this seem a good angle of inquiry?
07:37:37 <SamB_XP> oh, did it now?
07:37:56 <mjrosenb> SamB_XP: yeah. . .it confused my TA's
07:38:00 <SamB_XP> even in the i386 ABI it is apparantly optional...
07:38:13 <SamB_XP> I could have sworn it was mandatory!
07:38:27 <mauke> why do you need frame pointers for backtraces?
07:38:29 <tphyahoo-haskell> I have a suspicion this type of issue is what drove HAppS team to use TH for state boilerplate, which seems to have created its own set of issues.
07:38:32 <paczesiowa> what severity should I choose? major?
07:38:36 <mjrosenb> SamB_XP: yeah, it just made some things like alloca easier
07:38:47 <allbery_b> and debugging
07:39:05 <allbery_b> note that alloca is generally considered evil
07:39:08 <SamB_XP> mauke: well, if you don't have frame pointers, you need some other way of finding the next stack frame
07:39:17 <SamB_XP> allbery_b: is it now?
07:39:20 <sieni> allbery_b: why is that?
07:39:28 <mjrosenb> SamB_XP: {E,R}SP?
07:39:30 <allbery_b> so I suspect the folks who standardized it felt little need to force everyone to cater to it
07:39:30 <SamB_XP> I thought it was just considered tricksy
07:39:31 <faxathisia> alloca is dumb
07:39:55 <mjrosenb> faxathisia: why do you say that?
07:40:05 <allbery_b> arbitrary allocation on stack is tricky and canblow up in your face if you do too much of it
07:40:11 <geocalc> mac
07:40:34 <allbery_b> er, who standardized the abi
07:40:35 <mjrosenb> allbery_b: or if you don't know what you're doing
07:40:39 <faxathisia> mjrosenb: It's not a useful procedure
07:40:53 <allbery_b> mjrosenb: but that's true of C in general.  "more than enough rope"
07:40:55 <SamB_XP> the ABI doesn't do anything to make alloca particularly harder
07:40:55 <wli> ABI's are standardized, e.g. ELF/i386
07:40:57 <idnar> @pl flip $
07:40:57 <lambdabot> (line 1, column 7):
07:40:58 <lambdabot> unexpected end of input
07:40:58 <lambdabot> expecting white space or simple term
07:41:01 <idnar> @pl flip ($)
07:41:02 <lambdabot> flip id
07:41:12 <idnar> :t ($)
07:41:14 <lambdabot> forall a b. (a -> b) -> a -> b
07:41:20 <faxathisia> @pl ($)
07:41:20 <lambdabot> id
07:41:26 <faxathisia> @unpl id
07:41:26 <lambdabot> (\ a -> a)
07:41:40 <SamB_XP> ... as long as the compiler helps out
07:41:41 <idnar> :hoogle a -> (a -> b) -> b
07:41:42 <mjrosenb> faxathisia: why is beings able to quickly allocate space in a thead safe manner not useful?
07:41:42 <allbery_b> SamB_XP: it only does in the sense that the frame pointer is optional
07:41:45 <idnar> @hoogle a -> (a -> b) -> b
07:41:46 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
07:41:46 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
07:41:46 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
07:41:53 <idnar> meh
07:42:13 <faxathisia> whataer you looking for idnar ?
07:42:22 <allbery_b> :t flip ($)
07:42:23 <lambdabot> forall a b. a -> (a -> b) -> b
07:42:32 <idnar> faxathisia: a flipped ($)
07:42:42 <faxathisia> idnar: it's id.. flipped doesn't make a difference
07:42:46 <allbery_b> pretty sure there's no such in the standard libs
07:42:51 <idnar> faxathisia: hmm?
07:42:54 <mauke> faxathisia: yes, it does
07:42:59 <faxathisia> @src ($)
07:42:59 <lambdabot> f $ x = f x
07:43:05 <idnar> faxathisia: I mean a $< f instead of f $ a
07:43:06 <mauke> map (flip id) is very different from map id
07:43:22 <SamB_XP> allbery_b: all that means is that the compiler has to know about alloca
07:43:29 <faxathisia> oh sorry you're right
07:43:37 <idnar> :t flip id
07:43:38 <lambdabot> forall b c. b -> (b -> c) -> c
07:44:21 <mattam> :t flip ($)
07:44:22 <lambdabot> forall a b. a -> (a -> b) -> b
07:44:30 <mjrosenb> is there still a bot that has djinn running on it?
07:44:36 <sieni> faxathisia: I have to admit that in C I have allocated variable size data structures on stack by recursively calling a function to get the storage in the function's stack frames and then building the data structure in the end and using it
07:44:46 <idnar> @djinn a -> a
07:44:46 <lambdabot> f a = a
07:44:54 <faxathisia> sieni: that's fine
07:45:01 <mjrosenb> whee
07:45:15 <mjrosenb> @djinn (a->b) -> a -> b
07:45:15 <lambdabot> f a = a
07:45:23 <sieni> faxathisia: well, one can use alloca to achieve basically the same thing
07:45:26 <faxathisia> sieni: I think using alloca for the same purpose is bad though because it's less clera to read
07:45:37 <SamB_XP> faxathisia: how so?
07:45:39 <idnar> @djinn a -> (a -> b) -> b
07:45:39 <lambdabot> f a b = b a
07:45:53 <faxathisia> (the storage is not explicit.. you are just generating it from some calculated value)
07:46:09 <wli> That's all allocators do anyway.
07:46:24 <geocalc> hehe
07:46:56 <mjrosenb> ooohhh
07:46:59 <SamB_XP> faxathisia: so?
07:47:03 <mjrosenb> @djinn ((a->b) -> a) -> b
07:47:03 <lambdabot> -- f cannot be realized.
07:47:06 <wli> Anyow, I never touch alloca(). I always kmalloc(), kmem_cache_alloc(), or alloc_page().
07:47:18 <SamB_XP> wli: you, sir, are a kernel hacker
07:47:25 <resiak> > id (+1) 3
07:47:27 <lambdabot>  4
07:47:31 <idnar> mjrosenb: how would that work?
07:47:41 <mjrosenb> hrmm, we need to add wli no man for kmalloc
07:47:56 <mjrosenb> idnar: you mean my type?
07:48:06 <SamB_XP> wli no man? is that japanese?
07:48:10 <faxathisia> SamB_XP: that's just my opinion
07:48:14 <idnar> mjrosenb: yeah
07:48:24 <wli> I studiously avoid getting involved with mm/slab.c (or the new crap going around to supplant it).
07:48:35 <sieni> well, the recursive allocation will segfault if you run out of stack.
07:48:48 <mjrosenb> idnar: with the help of the functions callcc :: (a cont -> a) -> a
07:49:03 <mjrosenb> and throw :: a cont -> a -> b
07:49:28 <wli> I generally have to assume PAGE_SIZE or less of stack, so alloca() et al are useless.
07:49:42 <idnar> mjrosenb: hoo boy
07:49:57 <Saizan> ?type callCC
07:50:01 <SamB_XP> wli: well, yeah. such is the life of a kernel hacker
07:50:02 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
07:50:25 <mjrosenb> o right. . .callcc plays in interesting ways with monads
07:50:49 <wli> It's not really all that much better in userspace. There are stackspace limits both as rlimits and in terms of threads bumping into each others' stacks to be concerned about.
07:50:54 <faxathisia> ?djinn ((a -> b) -> a) -> a
07:50:54 <lambdabot> -- f cannot be realized.
07:51:08 <wli> At least with malloc() you know up-front if it will fail.
07:51:22 <Saizan> ?src Cont
07:51:22 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
07:51:24 <bos> well, you know up front that it might fail.
07:51:42 <bos> with an overcommitting allocator, it can succeed and blow up in your face later.
07:51:56 <mjrosenb> brb
07:52:07 <Saizan> ?djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
07:52:07 <lambdabot> f a b = a (\ c _ -> b c) b
07:52:16 <wli> bos: Disabling overcommitment resolves that. Disk is cheap for adding swap to back it.
07:52:25 * SamB wonders if you can disable overcommit on a process-by-process basis in a useful way
07:52:31 <wli> SamB: No.
07:52:37 <SamB> why the heck not?
07:52:50 <wli> SamB: It doesn't even make sense.
07:52:59 <SamB> what about that doesn't make sense?
07:53:05 <wli> SamB: Overcommitment is interplay between multiple processes.
07:53:09 <SamB> yes
07:53:16 <wli> SamB: Sharing and unsharing go on.
07:53:35 <wli> SamB: Non-overcommitment means reserving enough space to unshare.
07:54:07 <SamB> so?
07:54:33 <wli> SamB: This is innately not a per-process affair.
07:54:43 <SamB> why can't you reserve enough to unshare some particular processes from the rest?
07:55:05 <idnar> uhm
07:55:11 <wli> SamB: Because it doesn't make a useful guarantee.
07:55:14 <idnar> re: http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
07:55:15 <lambdabot> Title: Haskell Records Considered Grungy ´ :: (Bloggable a) => a -> IO (), http://tinyurl.com/3akjdr
07:55:31 <SamB> wli: how so?
07:55:36 <idnar> oh nevermind, someone already made my point in the comments
07:56:01 <firefly> Linux needs a syscall to say "please unify these pages (which may be in different processes and probably are)".
07:56:21 <wli> firefly: Reverse COW?
07:56:30 <firefly> If the dynamic linker/loader used it, it could make shared libraries that get patched with the same fixups cheaper.
07:56:49 <firefly> the syscall should just be a nop if the contents actually isn't the same.
07:56:52 <wli> firefly: Not enough state bits to pull it off, so it entails massive damage to the VM.
07:56:58 <fasta> If only people that wrote <10KLOC in $LANGUAGE would stop writing blogs..
07:57:13 <firefly> why are state bits needed?
07:57:43 <paczesiowa> thanks everybody for help with confirming that bug
07:57:47 <sw17ch> i like haskell Records :(
07:57:58 <SamB> wli: I was thinking you could guarentee that "none of the processes in this set will die upon touching a page because of overcommit"
07:58:01 <wli> firefly: To know why you were sharing in the first place when unsharing again because you need to do something different from normal COW.
07:58:22 <wli> SamB: Not possible to make that guarantee without doing it for the whole system.
07:58:35 <SamB> wli: how so?
07:59:00 <firefly> I don't actually want more sharing than what two forked processes end up with.  It's fine if the syscall only works with one backing file at a time.
07:59:35 <wli> SamB: Because it doesn't make sense. Overcommitments elsewhere can consume enough memory to make the guarantee impossible.
08:00:10 <SamB> wli: eh?
08:00:22 <firefly> I think SamB wants a flag that says "well, don't lie to /me/ about how much memory there really is  -- when I ask for memory, I want to either get that memory or an immediate error"
08:00:56 <idnar> SamB: your process can get killed because other processes overcommitted
08:00:57 <SamB> you just need to reserve pages for the non-overcommitted processes...
08:01:07 <idnar> the OOM killer doesn't care who allocated which memory when
08:01:19 <wli> SamB: And you can't do that without non-overcommitting the rest of the system.
08:01:35 <SamB> wli: I don't understand why you think this
08:01:51 <firefly> wli: because that's how linux currently does it or because it simply can't be done, period?
08:02:36 <SamB> explain what you think would happen to make this not work
08:02:59 <allbery_b> because you can't stop the OOM killer from touching such processes without risking a system deadlock
08:03:19 <allbery_b> (and likewise cannot simply omit the OOM killer if you have overcommit)
08:03:46 <wli> It's a Linux limitation.
08:03:58 <SamB> allbery_b: okay. so maybe the OOM killer would need some reworking
08:04:18 <wli> The amount of missing infrastructure to pull this off in Linux is far beyond massive.
08:04:45 <wli> And its performance impact would dwarf that of the global non-overcommit.
08:05:03 <seliopou> Anybody know why I would get "Undefined symbols: _readline" when ghc is trying to link my program?
08:05:08 <SamB> wli: I'm not sure why
08:05:11 * allbery_b also notes that allowing processes to avoid overcommit on an individual basis can be a DoS
08:05:16 <firefly> how far could one get with LD_PRELOAD skin that changes brk and mmap to add mlocking?
08:05:29 <SamB> allbery_b: point
08:05:32 <allbery_b> seliopou:  using --make?
08:05:36 <seliopou> Yes.
08:05:51 <allbery_b> what ghc version?  what platform?
08:05:56 <firefly> because you have the wrong version of the readline library on your machine, I think.
08:06:00 <seliopou> 6.6.1, osx
08:06:06 <allbery_b> osx, yep
08:06:09 <firefly> It's mentioned as one of the FAQ things.
08:06:27 <SamB> wli: what exactly do you believe would cause this performance hit?
08:06:33 <seliopou> firefly: I followed the instructions on the download page and got the framework
08:06:48 <seliopou> there was something in a faq about solaris and multiple versions of the library
08:06:56 <firefly> at least it's a FAQ problem for the binary version of 6.8.1 for some Linux distributions.
08:07:32 <allbery_b> OSX has a similar faq enry because of some system weirdies.  (specifically Apple ships a -lreadline that isn't readline)
08:07:50 <allbery_b> you may need to do weirdshit to make sure the correct readline is fund
08:07:57 <allbery_b> the correct -lreadline that is
08:08:11 <allbery_b> if it finds the Apple-supplied one first you will be unhappy
08:08:15 <firefly> I don't know how to fix it or work around it on OS X.  I've been using Linux at home since '99 and I only really touched OS X on a friend's machine a couple of months ago and got severely disappointed by its non-unixy unix :/
08:08:44 <allbery_b> what non-unixy aspects?
08:09:07 <seliopou> I was under the impression that fixing the readline problem was as simple and installing the readline framework
08:09:29 <firefly> the filesystem layout, the configuration files, what flags the various commands took (or rather NOT took).  I do realize that much of what I'm used to is really GNU rather than Unix.
08:09:30 <allbery_b> there are some issues caused by OSX being mach instead of unix, but others are caused by it using a freebsd userspace instead of the linux one that many newcomers to unix think is "real" unix
08:09:56 <seliopou> Can you point me to this FAQ? I'm looking at GHC:FAQ on the wiki and it doesn't mention this problem
08:09:57 <firefly> Linux is definitely more in line with the real unices I've used at uni than OS X is.
08:10:01 <pejo> allbery_b, the stuff apple ships is libedit, just like Netbsd.
08:10:06 <allbery_b> yep
08:10:24 <allbery_b> but naming it -lreadline is Just Wrong
08:11:42 <seliopou> I like how when I search for this problem there is a job description that says, e're particularly looking for someone who is experienced in a variety of operating system platforms and libraries. You should be able to deal with questions like "I try to build GHC on Solaris 2.3.4 and get `undefined symbol _readline'"; or "How do I link to DLLs on Windows?"; or "does the ByteString library in...
08:11:44 <seliopou> ...GHC 6.2.1 do XXX?".
08:11:53 <pejo> seliopou, do you have GHC installed and working, but trying to build some haskell program using readline?
08:12:11 <seliopou> pejo: I screwed up my old install trying to get 6.8.1 to work
08:12:31 <seliopou> So I got rid of everything and I'm trying to install from scratch now with a binary distro of 6.6.1
08:13:08 <pejo> firefly, not sure what you mean by a real unix, but I think my mac works surprisingly much like a sane unix.
08:13:34 <allbery_b> he's already admitted he was using unix == gnu
08:13:40 <allbery_b> freebsd is *not* gnu
08:13:44 <firefly> I've used HP UX, SunOS, Solaris, and a tiny bit Irix.
08:14:08 <firefly> All were much nicer when using the GNU tools rather than the native ones ;)
08:14:27 <faxathisia> unix == gnu ? O_o
08:14:31 <pejo> firefly, except that the gnu tools doesn't handle ACL's under Solaris, and .., and .., and .. - but except that they work like a charm.
08:14:39 <allbery_b> common belief among linuxers...
08:14:42 <faxathisia> this axiom is inconsistent
08:14:47 <firefly> never liked ACLs anyway.
08:14:50 <pejo> firefly, I agree though, the gnu stuff gives a nice cozy feeling when it works.
08:15:16 <firefly> they take too many options, though.
08:16:21 <pejo> seliopou, so you're trying to compile GHC 6.8.1, with a binary snapshot of 6.6.1, on Leopard?
08:17:40 <allbery_b> 6.8.1 has known issues finding the right -lreadline on OSX
08:29:39 <seliopou> pejo
08:29:56 <seliopou> I'm trying get the binary snapsot of 6.6.1 to work with readline
08:30:02 <seliopou> If I can do that, I can get 6.8.1 to work as well
08:30:11 <seliopou> as that's the only problem with my install right now
08:30:18 <seliopou> Undefined symbols: _readline
08:31:32 <seliopou> And that only happens when a program uses System.Readline
08:33:18 <wli> SamB: The accounting is more involved, it needs new data structures, and it needs more computation during the heavily exercised accounting steps.
08:45:03 <sw17ch> does hackage have a "cpan" like interface from the command line?
08:46:21 <Cale> sw17ch: Yes, cabal-install
08:46:41 <firefly> 'cabal', but you have to install the cabal-install package first, which may be a bit of a struggle.
08:46:58 <Cale> sw17ch: Make sure that when you build it, you're not using Cabal-1.2.2.0 though, because that version has a bug which makes cabal-install not work.
08:47:12 <firefly> It required using runghc Setup.hs/Setup.lhs for the various packages + the occasional ghc-pkg command.
08:47:18 <Cale> (This is unfortunately the version which went out with GHC 6.8)
08:47:22 <sw17ch> Cale: gentoo has 1.1.6.2 as stable
08:47:59 <Saizan> that's too old, i think
08:48:02 <allbery_b> won't work with packages upgraded for 6.8 support
08:48:03 <Cale> That may be all right, I'm not sure. I know that 1.2.1 works, and apparently HEAD works.
08:48:12 <firefly> It is probably a good idea to use --user and --prefix so you have control over where the packages get installed.  That should make it easier to play with different versions of ghc.
08:48:32 * Cale hopes that dons will update hs-plugins soon :)
08:48:48 * sw17ch thinks he may just stick with the basics for a while
08:48:55 <firefly> (--user and --prefix as arguments to cabal when you get that far.  And something similar with the arguments to runghc Setup.hs/Setup.lhs)
08:49:44 <firefly> Once you've got it going, things become really easy :)   it is just as easy as apt-get install, modulo the occasional bug.
08:50:27 <firefly> I really recommend spending the grumpy hours it can take to install it because hackage becomes so much easier afterwards.
08:50:41 <sw17ch> firefly: to be honest, i haven't touched hackage yet
08:50:56 <sw17ch> the stuff in Prelude has been enough for me so far... i'm not doing anything out of the ordinary yet
08:50:57 <firefly> (and you WILL be grumpy when trying to install cabal-install)
08:51:09 <firefly> Data.ByteString is nice.
08:52:11 <firefly> Harpy seems interesting, too.
08:52:57 <Heffalump> Harpy is very cool.
08:54:31 * desegnis recognizes that now, after updating to the newest ghc release, the cabal output of `Setup.hs configure` appears massively cleaned up.
08:54:59 <sw17ch> What is Harpy (short of googling it)?
08:55:11 <bjornbm> Anyone used the libcurl bindings (http://varsztat.com/projects/curl/) or know how to get in touch with the maintainer?
08:55:12 <lambdabot> Title: Haskell bindings for libcurl
08:55:38 <desegnis> bjornbm: I think darcs uses libcurl.
08:57:14 <sw17ch> firefly: ah, i remember why i was asking about hackage in the first place... libpcap
08:58:41 * firefly just installed it
08:58:49 <bjornbm> desegnis: I see, but does it provide a friendly lib with haskell bindings? Guess I can dig around in the repo...
08:58:51 <firefly> "cabal install --user pcap"
08:59:03 <sw17ch> man, that is easy...
09:00:55 <Brian`> hm... i don't even remember if i had my nick registered to irc lol
09:01:25 <sw17ch> $ equery files dev-haskell/cabal
09:01:25 <sw17ch> [ Searching for packages matching dev-haskell/cabal... ]
09:01:25 <sw17ch> * Contents of dev-haskell/cabal-1.1.6.2:
09:01:25 <sw17ch> /usr/lib64
09:01:26 <sw17ch> /usr/lib64/ghc-6.6.1
09:01:28 <sw17ch> /usr/lib64/ghc-6.6.1/gentoo
09:01:30 <sw17ch> /usr/lib64/ghc-6.6.1/gentoo/cabal-1.1.6.2.conf
09:01:37 <sw17ch> that's disappointing
09:02:13 <firefly> what does "ghc-pkg list" say?
09:02:26 <sw17ch> $ ghc-pkg list
09:02:26 <sw17ch> /usr/lib64/ghc-6.6.1/package.conf:
09:02:26 <sw17ch>     Cabal-1.1.6.2, base-2.1.1, cairo-0.9.12.1, filepath-1.0,
09:02:26 <sw17ch>     gconf-0.9.12.1, (ghc-6.6.1), glade-0.9.12.1, glib-0.9.12.1,
09:02:26 <sw17ch>     gtk-0.9.12.1, gtkglext-0.9.12.1, haskell98-1.0, mozembed-0.9.12.1,
09:02:27 <sw17ch>     mtl-1.0.1, parsec-2.0, readline-1.0, regex-base-0.72,
09:02:29 <sw17ch>     regex-base-0.91, regex-compat-0.71, regex-compat-0.90,
09:02:31 <sw17ch>     regex-posix-0.71, regex-posix-0.92, rts-1.0, soegtk-0.9.12.1,
09:02:33 <sw17ch>     sourceview-0.9.12.1, stm-2.0, svgcairo-0.9.12.1,
09:02:35 <sw17ch>     template-haskell-2.1, unix-2.1
09:02:48 <firefly> these are the packages you already have :)
09:03:00 <sw17ch> hmmm... yes...
09:03:16 <sw17ch> but i understand that cabal 1.1.6.2 is too old for cabal install?
09:03:45 <firefly> when you try to install cabal-install you may need to install newer versions of some of these (but you will be told so automatically).
09:04:08 <firefly> You may need to temporarily "hide" one of the preinstalled packages -- ghc-pkg can do that for you.
09:04:55 <firefly> I haven't got the faintest idea about what version of cabal (the basic cabal library that does versioning and stuff) to use.  I think I downloaded the newest and manually installed it.
09:06:07 <sw17ch> hehe. alright, thanks firefly
09:06:24 <firefly> Anyway, download cabal-install and try to get that going with runghc Setup.hs (or Setup.lhs) and see what it complains about.
09:06:57 <firefly> once cabal works, it will handle dependencies automatically for you.
09:07:15 <firefly> (works = is properly installed)
09:14:34 <desegnis> bjornbm, sorry, not sure about that
09:23:32 <hpaste>  Big_Ham pasted "(no title)" at http://hpaste.org/4072
09:24:02 <Big_Ham> Does anyone know a way I can get my code to create every possible expression availible from a list of ints??
09:24:36 <Big_Ham> I have no idea how to even start going about it :(
09:25:36 <Lycurgus> well you might start with the definition of the expression
09:25:38 <firefly> ...and a list of operators, I presume?
09:25:53 <Big_Ham> the definition of the expression is at the top of the paste..
09:27:03 <Big_Ham> could I do that with the stuff I currently have?
09:27:06 <conal> Big_Ham: i know you didn't ask, but there's a much more elegant way to work with Maybe values:
09:27:11 <conal> > liftA2 (+) (Just 3) (Just 4)
09:27:12 <lambdabot>  Just 7
09:27:16 <conal> > liftA2 (+) (Just 3) Nothing
09:27:17 <firefly> how deep do you want the expression tree to be?  do you only want to use each int once?
09:27:18 <Lycurgus> you could wait for Don Knuth to finish his cookbook on combinatorics (vol. 4 of the Art of Computer Programming)
09:27:18 <lambdabot>  Nothing
09:27:21 <conal> > liftA2 (+) Nothing (Just 4)
09:27:21 <lambdabot>  Nothing
09:27:29 <pitecus> Is it forbidden to export newtype constructors??
09:27:32 <Big_Ham> each int can only be used once
09:27:36 <Big_Ham> each int must be used at least one
09:27:44 <xerox> > (+) <$> Just 1 <*> Just 2
09:27:44 <lambdabot>  Just 3
09:27:45 <Big_Ham> hence the permute
09:28:00 <Big_Ham> so that would give all the combinations of numbers
09:28:05 <firefly> so you can get by with only Add, provided you have at least two ints?
09:28:22 <Big_Ham> so, because there's a target number
09:28:33 <Big_Ham> have to try and make the target number from the list of ints
09:28:37 <firefly> ah.
09:28:41 <Big_Ham> using +-* and/
09:29:11 <Big_Ham> well, `div` technically
09:31:33 <byorgey> pitecus: shouldn't be.  why?
09:33:17 <Big_Ham> If someone could annotate my code to give me some hints, that would superb, I don't expect a full complete answer as it's homework anyway/
09:33:35 <Big_Ham> I just have no idea how to go about this
09:33:53 <pitecus> byorgey, i was confused, trying to export the constructor like MakeFoo instead of Foo(MakeFoo)
09:33:55 <firefly> define a function that returns a list of possible trees, start with just Add.
09:34:03 <bakert_> is there some base version of lambdabot on which a novice could base a very simple IRC bot?
09:34:07 <firefly> handle the target later.
09:34:08 <byorgey> pitecus: ah, I see =)
09:34:25 <bakert_> ?where lambdabot
09:34:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:34:27 <Big_Ham> a list of possible tree?
09:34:31 <firefly> yes.
09:34:37 <Big_Ham> hmm, ok
09:35:02 <firefly> let it take a list of ints (or possibly an int and a list or two lists or some variation thereof)
09:35:05 <byorgey> bakert_: probably not.  but what about dons' 'roll your own IRC bot' article?
09:35:12 <byorgey> @go roll your own IRC bot
09:35:12 <bakert_> byorgey: sounds good
09:35:12 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
09:35:17 <bakert_> thanks
09:35:47 <Big_Ham> ok, thank you firefly
09:36:06 <firefly> you might want to combine that with a function that splits apart a list into an element and the rest of the list in all possible ways, ie. that returns a list of such splits.
09:36:32 <Big_Ham> that doesn't matter because each int HAS to be used once
09:36:39 <firefly> at least that's how I would start.  Once one explores a bit one tends to get an "aha" moment and understand the problem much better.
09:36:41 <Big_Ham> so just a list of all combinations is sufficient
09:36:48 <Big_Ham> lol
09:37:04 <firefly> the list of splits thing may make it easier for you to generate all the possible trees with Add.
09:37:29 <Big_Ham> so I need to create a tree of Expre's right?
09:37:47 <firefly> Expre *is* a tree.
09:37:56 <Big_Ham> ?
09:38:01 <firefly> !
09:38:04 <Big_Ham> in a way i suppose
09:38:21 <Big_Ham> i never thought to look at it that way
09:38:25 <firefly> not "in a way" or "i suppose"!  It very definitely *IS*.
09:38:31 <Big_Ham> lol
09:38:39 * Big_Ham just got owned
09:39:38 <firefly> Draw a little picture of the tree "Add (Sub (Lit 3) (Lit 2)) (Lit 9)" :)
09:40:12 <Big_Ham> yeah, I see what you mean
09:40:22 <firefly> You might want to rename your constructors to Add, Sub, Mul, Div, Lit so they all line up nicely in case expressions if you are going to need those.
09:40:57 <Big_Ham> ok
09:41:14 <firefly> (and use the trick from conal to turn all the value cases into one-liners)
09:42:07 <byorgey> Big_Ham: note liftA2 requires importing Control.Applicative.
09:42:24 <Big_Ham> ok, thanks by
09:42:32 <conal> Big_Ham: why do you toss negatives?
09:42:55 <Big_Ham> because they aren't allowed as an intermediate value
09:43:02 <Big_Ham> neither are fractions
09:43:06 <conal> why not?
09:43:15 <Big_Ham> that's the question
09:43:23 <Big_Ham> i guess it makes it slightly more simple that way
09:43:43 <Big_Ham> although not a great deal
09:43:58 <Cale> What is the question?
09:44:27 <byorgey> I think it actually makes it more complicated that way =)
09:44:30 <Big_Ham> lol
09:44:56 <conal> also, what does your program give for value (Sub (Lit 3) (Lit 4)) ?
09:44:59 <Big_Ham> Take a list of ints and a target int and return the expression if their is one that equals the target number
09:45:10 <Big_Ham> Nothing
09:45:16 <Big_Ham> *there
09:45:24 <conal> Big_Ham: you sure?
09:45:28 <Big_Ham> should do
09:45:53 <Big_Ham> nah, syntax error :S
09:46:06 <Big_Ham> I would have expected it to return nothing
09:46:20 <conal> Big_Ham: there's no case that fits.
09:46:40 <hpaste>  _fang pasted "type error" at http://hpaste.org/4073
09:46:41 <Big_Ham> pattern match failiure
09:46:49 <conal> yeah
09:47:00 <_fang> i just pasted something, and the error i get is in there... can anyone help me?
09:47:07 <conal> Big_Ham: i don't think excluding negatives is helping you any.
09:47:33 <conal> also, from where comes does the requirement of using only distinct members of the int list?
09:48:00 <conal> it's doable but certainly trickier than without the requirement.
09:48:15 <Big_Ham> That's the question I've afriad
09:48:35 <Big_Ham> *I'm afraid
09:48:42 <conal> ok
09:48:48 <Big_Ham> anyway, thanks for your help guys, I'm off
09:48:57 <conal> good luck, Big_Ham
09:50:38 <byorgey> _fang: because you use x in the expression (y:x), it must be a list... but you pass it to dist which expects an Int.
09:50:49 <byorgey> perhaps you meant y ++ [x] instead of y:x?
09:52:22 <byorgey> _fang: I would suggest giving all_paths_between an explicit type signature.  That will probably help you track down your type errors more easily.
09:52:43 <firefly> how does forkOS work in terms of low-level stuff?
09:53:01 <firefly> somebody told me there was a bad interaction with the heap or garbage collector -- is that true?
09:53:01 <vwx> i imagine it's pretty complicated
09:53:10 <firefly> where should I start digging?
09:53:55 <firefly> almost all the articles I've found about haskell and threads talk about forkIO only.
09:54:35 <_fang> byorgey: yes! guess it'll do. i'll do it as soon as i finish finding out what i want with it! lol! i'm in a deep trouble with this. thx =D
09:55:55 <vwx> firefly: forkOS is the same as forkIO, it just makes sure that all ffi calls go through the same OS thread
09:56:57 <firefly> so each time forkOS is invoked, a new OS thread is created that the new haskell thread gets mapped onto -- so it creates a 1:1 relation between them?
09:57:36 <firefly> if any of them did a forkIO would that share the same native OS thread as the haskell thread that called it?
09:57:45 <vwx> i'm not sure, but i don't think that's how it works
09:57:59 <byorgey> ...I thought it was the other way around?  Not that I know all that much about it.
09:58:52 <firefly> I want to use real native threads to send many file I/O requests off to the operating system and give it a fighting chance to read the file(s) in a sensible order.
09:59:27 <firefly> if the run-time system decides that only one of its native threads can issue I/O at a time then I've got a problem.
09:59:48 <firefly> Also, if using forkOS impairs the garbage collector then I may have a problem.
10:00:14 <Cale> I think that if you just use forkIO, things will generally work sensibly.
10:00:25 <firefly> It looks like there is a "Big RTS Lock" akin to the Big Kernel Lock that Linux has.
10:00:33 <Cale> Is there?
10:00:51 <firefly> Cale: read/write are not the only OS calls that can block.  Opening a file can block, creating a file can block, etc.
10:01:11 <firefly> That's what docs/comm/rts-libs.html seems to say.
10:03:26 <Cale> firefly: Are you using foreign libraries to do I/O?
10:03:33 <firefly> Not yet ;)
10:03:39 <firefly> (I don't think I will, actually)
10:04:06 <firefly> I might want to fire off an fadvise or madvise in a separate OS thread, though.
10:04:33 <firefly> (they tend to block in most (all?) versions of Linux, hence the desire for a separate thread)
10:05:59 <Cale> Basically, AIUI, the RTS manages a pool of OS threads which manage Haskell threads. A given Haskell thread can be run by one OS thread or by many during its lifetime.
10:06:40 <firefly> yep.  That's my understanding, too.  This mental model works fine with forkIO.  It breaks a bit with forkOS, though.
10:07:38 <vwx> forkOS is the same thing as forkIO, it only adds compatibility for C libraries that use thread-local storage
10:07:55 <Cale> Well, the only change with forkOS is that it ensures that the new Haskell thread is bound to a fixed OS thread.
10:08:19 <Cale> All forign calls made by that Haskell thread will be made using that one OS thread.
10:08:25 <Cale> foreign*
10:08:45 <firefly> so it's just a binding thing.  good.  That matches what I wrote initially.  Does that binding continue for a child thread if such a bound thread does a forkIO?
10:08:51 <Cale> Which is important when interacting with certain not-so-threadsafe libraries.
10:08:55 <firefly> yep :)
10:09:24 <vwx> Cale: but two forkOS threads, can still end up running on the same OS thread, right?
10:09:26 <Cale> No, I don't think it does. If you do a forkIO, I'm fairly sure that'll create a new unbound Haskell thread.
10:09:41 <firefly> and certain thread-safe, too.  I don't think it's unreasonable to demand that some calls must be done from within the same OS thread.
10:09:52 <Cale> Apparently forkOS creates a new OS thread when it's used.
10:10:01 <firefly> as long as the library /does/ allow more than one thread to use it.
10:11:01 <Cale> It's not necessary to use forkOS to get non-blocking IO
10:11:24 <Cale> and it's also not necessary if you want threads to run in parallel on a multiprocessor
10:11:54 <vwx> but what if you want threads to run in parallel on a uniprocessor?
10:12:06 <firefly> I thought the run-time knew about read/write calls and switched file handles into non-blocking mode + used select to handle them nicely.
10:12:13 <Cale> vwx: That's kind of impossible :)
10:12:37 <firefly> Which is good and stuff.  But madvise() will just block while reading the file into memory if it isn't there already.  Nonblocking mode or not.  It doesn't matter.
10:12:59 <vwx> Cale: no it's not, an execution thread does I/O in addition to running cpu code
10:13:28 <firefly> I mainly want to ensure that the I/O is properly overlapped and scheduled.
10:13:57 <Cale> vwx: The Haskell scheduler will make sure that threads are switched between in a reasonable manner even on a uniprocessor.
10:14:29 <vwx> Cale: what about heavy use of foreign functions?
10:14:49 <vwx> like a blocking foreign function?
10:16:00 <Cale> If a foreign call blocks, then Haskell code continues to execute in other OS threads.
10:16:55 <vwx> but on a uniprocessor there is only one OS thread, right?
10:17:04 <firefly> there might be more.
10:17:10 <Cale> No, there might be many.
10:17:25 <firefly> ghc has a pool of worker threads which it is supposed to grow (and shrink) automatically.
10:17:30 <vwx> so it's a guessing game? sometimes the program may run fast, and sometimes slow?
10:17:48 <Cale> Sorry?
10:18:21 <vwx> hm...
10:18:45 <Cale> The runtime system manages a pool of worker OS threads each of which normally tries to aquire Haskell threads to run.
10:19:11 <vwx> is the pool of worker OS threads a fixed size, from the -N RTS option?
10:22:07 <firefly> ok, I've given up on the documentation and started reading the code (which I probably should have done right away).
10:22:22 <Cale> I think -N controls the number of OS threads which are allowed to concurrently execute Haskell code. (and the initial number of OS worker threads created by the runtime)
10:22:40 <firefly> I think there is a subtle error in forkOS_createThread() in rts/posix/OSThreads.c.
10:23:09 <firefly> pthread_create() returns 0 if the thread got created and !0 if creation failed.
10:23:47 <firefly> If the creation failed, pthread_detach(tid) gets called (why, if the thread creation failed?)
10:24:03 <sk> what is this discussion about?
10:24:04 <firefly> &tid was passed to pthread_create() and filled in in case of success.
10:24:46 <firefly> But what if pthread_creat() failed?  Does it set tid in that case?  If it doesn't, we end up having pthread_detach() with a garbage thread id, which may be one we didn't want detached.
10:24:56 <firefly> sk: I'm trying to learn how forkOS works.
10:25:06 <Cale> firefly: Sorry, which code are you looking at?
10:25:11 <Cale> firefly: GHC 6.8.1?
10:25:16 <firefly> darcs version.
10:25:19 <Cale> ah
10:25:52 <sk> ic... good luck =)
10:26:10 <firefly> :)
10:27:03 <firefly> same thing in createOSThread().
10:27:11 <Cale> There are probably people around who know this stuff much better than I do.
10:27:47 <Cale> Are you experiencing problems with concurrency?
10:28:20 <firefly> not yet.  I'm trying to get a good mental model all the way down from the refined airs of beautiful haskell down to the metal.
10:28:39 <firefly> I lack an understanding of the stuff between forkIO and forkOS and native pthreads.
10:28:53 <Cale> firefly: Remember that it's all subject to change with each release of GHC :)
10:29:02 <firefly> sure, no problem with that :)
10:29:49 <Cale> There have been some papers that seemingly advocate a new RTS which would allow for user-specified scheduling.
10:30:16 <firefly> You are thinking of "Lightweight concurrency primitives for GHC"  (Peng Li et al) ?
10:30:41 <Cale> Right, yes
10:30:42 <Cale> http://www.haskell.org/~simonmar/papers/conc-substrate.pdf
10:31:02 <firefly> It ignores the issue.
10:34:00 <Cale> Um, that code looks okay to me.
10:34:08 <Cale> er...
10:34:21 <firefly> what is the value of tid when pthread_detach gets called?
10:34:53 <Cale> pthread_create gives 0 when successful
10:34:59 <firefly> yes.
10:35:51 <firefly> I realize it's a corner case but ulimits may cause a program to run into a thread creation limit long before the machine is any way loaded.
10:36:13 <Cale> and it stores the ID of the created thread in the location referenced by the pointer which is its first parameter
10:36:27 <Cale> So tid gets set to the created thread's ID.
10:36:39 <Cale> and then pthread_detach is called with that tid
10:37:00 <firefly> but when pthread_create is successful, we don't call pthread_detach() .. oh, wait.  I got a bit flipped.
10:37:10 <firefly> :(
10:37:56 <Cale> Yeah, using 0 for success is a funny idiom.
10:38:07 <firefly> ok, the next question is "if we want the new threads to be detached, why don't we create them in that state?  the current code let's them run in attached state for a bit which is racy if it really is so important to be detached"
10:38:19 <firefly> pthread_create() can take an attribute for that.
10:38:52 <Cale> pthread_detach just means that the storage for the thread can be reclaimed when the thread terminates.
10:39:24 <Cale> hmm
10:39:51 <Cale> So you're saying that the thread might finish before the call to pthread_detach?
10:39:56 <firefly> yes.
10:40:10 <firefly> it most likely won't, but there is a race there.
10:40:33 <Cale> I wonder if that's really a problem. I suppose it depends on exactly how pthreads work. (I'm not entirely familiar)
10:41:10 <Cale> It sounds like if the thread is still attached then it won't be deallocated.
10:41:12 <firefly> even if it's wrong, it is unlikely that anybody runs into it.  The race is small.
10:41:15 <Cale> (even when it terminates)
10:41:40 <Cale> So it might not actually be an issue, simply because of the nature of attachment. But I'm not sure about that.
10:49:15 <Cale> As far as I can tell, it's okay to call pthread_detach on an already exited thread.
10:49:25 <firefly> good.
10:49:51 <firefly> hey, there's still a race :)
10:50:31 <firefly> if the thread exits and sufficiently many new threads are created, the thread id may be reused before pthread_detach() is called ;)
10:51:03 <firefly> (actually, I think the implementation holds onto the thread id until the thread is used in pthread_join() or has been detached and auto-released)
10:51:27 <firefly> (it may even be in the POSIX threading standard, for all I know)
10:56:22 <Cale> That latter behaviour seems like the only right thing to do.
10:56:44 <Cale> Reusing the thread id before a join or detach would be really evil.
10:56:51 <firefly> yes :)
10:57:05 <firefly> Unfortunately, it's been a few years since I last looked at the spec :/
10:57:08 <vwx> does ghc use pthreads also on windows?
10:57:19 <firefly> as far as I can tell, yes.
10:57:37 <firefly> mingw probably maps it onto win32
10:59:51 <vwx> probably uses http://sourceware.org/pthreads-win32/
10:59:52 <lambdabot> Title: POSIX Threads (pthreads) for Win32
11:30:54 <hpaste>  sizur pasted "link error" at http://hpaste.org/4074
11:32:28 <dmwit> sizur: What's the output of ghc-pkg list?
11:33:30 <sizur> dmwit: my friend insalled a binary distro. and it was not easy
11:33:51 <sizur> in user space
11:34:00 <sizur> so that can be a clue
11:35:34 <hpaste>  sizur annotated "link error" with "ghc-pkg" at http://hpaste.org/4074#a1
11:36:32 <firefly> Cale: the thread/rts code doesn't seem too bad, actually.  I think I can crack it in a couple of days, max.
11:36:40 <dmwit> huh, glut and opengl are exposed
11:37:00 <sizur> it's on gentoo system in user space
11:37:17 <dmwit> Is the real libGlut and libGL on the system?
11:37:25 <sizur> how to check?
11:39:22 <sizur> he has freeglut installed
11:40:08 <dmwit> Okay, so there's some /usr/lib/libGL.so and /usr/lib/libglut.so?
11:41:55 <dmwit> In that case, I'm not sure.
11:43:27 <sizur> ok, he made it to work. apparently package.conf from fedora rpm is not compattible with something. i have no idea what went wrong. he made it to work by replacing the package.conf from bzip distro
11:43:50 <sizur> dmwit: thank you very much for trying to help :)
11:57:59 <dmwit> I just got Youtube spam from my mother. =/
11:58:20 <vwx> shit happens :(
11:58:50 <dmwit> Yes, and now you have complaint spam from me!  It propagates... =)
12:06:55 <seliopou> I asked this question earlier but nobody was around that seemed to know what was going on, so I'm going to ask again.
12:07:10 <seliopou> I'm trying to install ghc 6.8.1, and everything works, except for the System.Readline library.
12:07:31 <seliopou> When I try to compile a program that uses it, ghc fails at linking with the error, "Undefined symbols: _readline"
12:07:41 <shachaf> seliopou: Do you use --make?
12:07:45 <seliopou> Yes.
12:08:00 <shachaf> seliopou: What version of readline do you have installed?
12:08:08 <seliopou> I'm using OS X, The third binary distribution listed under the intel section
12:08:16 <seliopou> GNUreadline.framework
12:08:32 <seliopou> In addition, I have one installed in /opt/local since it's a dependency for some other stuff
12:09:30 <shachaf> seliopou: Which version? I understand GHC likes an older version of readline.
12:10:10 <seliopou> It's version 5.2, the one linked to by the installation instructions
12:10:37 <shachaf> Hmm, I thought GHC used readline4.
12:10:58 <shachaf> Maybe not on OSX.
12:11:17 <seliopou> shachaf: GHC on OS X is a mess
12:12:49 <seliopou> What's particularly irritating is that if I remove the framework, it complains that the library isn't present, so I'm pretty confident it's finding the right copy of readline
12:13:06 <seliopou> and furthermore, the symbol that it claims is undefined is there...
12:14:22 <firefly> no, it is not a sign that it finds the right copy of readline -- it means it finds /a/ copy of readline (which evidently is not the right one).
12:14:41 <firefly> oh, fun, hadn't seen the part about the symbol actually being there.
12:15:03 <seliopou> The instructions state that it uses the GNUreadline.framework
12:15:22 <seliopou> When it is not present, I get an error saying it is not present. When it is present, I get an undefined symbols error.
12:15:33 <seliopou> Ah
12:17:56 <firefly> what's your DYLD_xxxx environment variables say?
12:18:43 <seliopou> I don't have it set
12:20:14 <seliopou> One interesting thing: What's failing is  /usr/libexec/gcc/i686-apple-darwin8/4.0.1/collect2 with a great number of options
12:20:15 <firefly> try setting DYLD_FRAMEWORK_PATH or DYLD_FALLBACK_FRAMEWORK_PATH.
12:20:22 <seliopou> one of which is -framework GMP
12:20:33 <seliopou> but there is no similar option for the readline framework
12:21:28 <seliopou> Nothing
12:21:31 <seliopou> same error
12:21:59 <firefly> the complaint about the library missing, does it occur during link or when you try to run the program?
12:23:04 <seliopou> Link time
12:23:31 <firefly> too bad :(
12:23:39 <seliopou> But just so we're clear, I'm not getting a missing library/framework error right now, just the undefined symbols error
12:23:57 <seliopou> Yeah, it's really unfortunate that installing ghc has to be such a pain on OS X
12:24:59 <firefly> how about passing -optl '-framework readline' to ghc (or something like that) ?
12:25:07 <firefly> -optl means "pass this option to the linker"
12:25:17 <firefly> (just like -Wl,xxxx for gcc)
12:28:07 <seliopou> firefly: on OS X, you can just use -framework name
12:28:10 <seliopou> and now it compiles
12:28:19 <seliopou> This is really bizarre
12:28:27 <bparkis> I was thinking--consider the execution of a program that has read/write access only to a block of memory.  if you prove things (like loop invariants) about the execution of this program, you are actually proving that certain states of the memory cannot occur
12:28:49 <seliopou> firefly: Thanks for your help
12:28:54 <seliopou> I can get my program to link now
12:29:06 <firefly> you are welcome -- but did I even do anything?  Things just work for you now, don't they?
12:29:41 <seliopou> I mean, you suggested explicitly passing -framework GNUreadline to ghc
12:29:45 <bparkis> and if you consider a static type system to be a set of inferences about a dynamic type system with type tags, the type checker is proving that certain states of the memory--those with invalid type tags--do not occur
12:29:50 <seliopou> Which is something it should have been doing on it's own
12:30:03 <firefly> and that's what made it work?
12:30:11 <bparkis> and discarding those invalid states from the beginning by doing away with the type tags
12:31:00 <seliopou> firefly: Yes
12:31:20 <firefly> weird.  Ghc is apparently not quite polished yet.
12:31:22 <seliopou> So as long as I use that every time I use System.Readline, I'm good
12:31:25 <firefly> :)
12:31:28 <bparkis> so I was wondering, can you do something similar--paring down invalid states from the beginning--with any other property of the program?
12:31:31 <seliopou> Yeah
12:31:36 <seliopou> I suppose I should tell somebody about this?
12:31:43 <firefly> probably.
12:31:46 <seliopou> It seems odd that nobody has found this yet.
12:31:47 <EvilTerran> @where bugs
12:31:47 <lambdabot> I know nothing about bugs.
12:31:56 <ddarius> @bug
12:31:56 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
12:31:59 <seliopou> I presume not a lot of people that use OS X use System.Readline
12:32:00 <ddarius> bparkis: Sure.
12:32:12 <seliopou> thanks
12:32:13 <EvilTerran> @where+ bugs http://hackage.haskell.org/trac/ghc/newticket?type=bug
12:32:13 <lambdabot> It is forever etched in my memory.
12:32:25 <firefly> I've reported one bug and I did get a reply a couple of days later (roughly "yep, you are right.  Dunno what a good solution would be.")
12:32:25 <bparkis> well ddarius what I mean is, with _every_ other property of the program
12:32:33 <EvilTerran> I'd almost certainly've forgotten that as a special case the next time i wanted it ;)
12:32:51 <bparkis> in the limit case paring down the program until _every_ state of memory can occur (dependent on the input)
12:32:58 * firefly halts!
12:33:09 <firefly> or not?
12:34:42 <EvilTerran> if you've got finite memory, we can work it out by exhaustive analysis, firefly ;)
12:35:36 <bparkis> for instance if you know that an integer is always in the range 0 to 3, representing it by 2 bits instead of 16
12:36:32 <newsham> I found out they sold me a large finite state machine :(
12:36:56 <firefly> would you rather have very long tapes?
12:37:04 <newsham> as long as it was semiinfinite
12:37:13 <newsham> at least it would be turing complete
12:37:21 <firefly> bparkis: you can do some analysis of that sort, yes, but you can't do as much as you probably want to.
12:37:48 <monochrom> I'm happy I paid finite money for a finite machine! :)
12:38:00 <bparkis> i mean in theory--in theory is there some set of program transformations that can alter a program to use less memory, given some invariant about the program's execution
12:38:02 <firefly> There have been a few experimental compilers for C and hardware description languages that did perform such analyses precisely in order to get by with fewer bits.
12:38:20 <bparkis> until eventually there are no invariants about the program's execution and it uses the minimum memory possible
12:38:21 <EvilTerran> with an appropriately extensible distributed computing system and unlimited buying power, you could create something that tends towards turing-completeness as time passed tends to +inf, which'd be the best you could do in theory anyway ;)
12:38:34 <firefly> The ones that describes digital hardware were used/could be used to synthesize logic so the narrower buses and registers, the better.
12:39:10 <firefly> The C and C-like ones were intended for energy efficiency: the fewer bits you work with, the fewer bits have to toggle (or even be enabled) => the less energy the computer will require.
12:39:20 <firefly> There are papers on this available on citeseer.
12:39:44 <EvilTerran> bparkis, i think in the end you'd end up with an almost literal representation of a FSM
12:40:41 <firefly> other things to look at: supercompilation and partial evaluation.  Plus perhaps the paper about driving in the jungle (by Jens Peter Secher) which I must admit I don't understand.
12:40:43 <EvilTerran> er, DFA. whatever.
12:40:48 <firefly> + stuff on abstract interpretation.
12:40:51 <vwx> are there any html templating engines for haskell? chunks is cool, but are there others?
12:40:55 <bparkis> ah yes, that's true--it would end up just being the state minimization algorithm
12:41:22 <bparkis> sort of
12:41:24 <EvilTerran> and you'd have trouble reducing it to exactly 2^n states
12:41:42 <EvilTerran> although you could always introduce equivalent states to get that
12:41:52 <bparkis> there's a problem with that, namely that a computer can execute when it is not reading input
12:42:09 <bparkis> whereas a FSM can only execute one step per symbol of input
12:42:35 <wli> A computer receives a clock signal.
12:42:38 <EvilTerran> if you're dealing with finite memory, you might as well merge all the steps from one token of input to the next
12:42:48 <wli> Which is essentially an input.
12:43:04 <bparkis> yes and that would probably minimize the memory used
12:43:21 <firefly> wli: it doesn't have to.
12:43:25 <EvilTerran> and you'd be left with a meaningless number as your state
12:44:02 <EvilTerran> and a giant graph with very little semantic meaning as your program
12:45:07 <EvilTerran> another problem, though: if we're working from the same term of "invariant", they can refer to things other than the current state
12:45:31 <wli> Asynchronous computers would just treat the completion of an instruction like a clock signal is treated by synchronous computers now, essentially in a feedback loop.
12:45:32 <EvilTerran> eg, things that've happened in the past, or the most recent event, or whatever. i guess you could encode those into the state, but it seems messy
12:45:39 <bparkis> no they can't EvilTerran
12:45:59 <wli> IOW lazy evaluation in hardware.
12:46:00 <bparkis> invariants can only restrict the current state or interpret it
12:46:15 <bparkis> because the next state only depends on the current state
12:46:47 <goalieca> async compuers though would theoretically use lots less power.. and the routing of the clock signal would no longer be a problem
12:46:51 <goalieca> no clock skew :-)
12:47:01 <wli> goalieca: Wrong kind of clock.
12:47:29 <EvilTerran> meh. okay then, we'll go with your definition
12:47:36 <wli> goalieca: This is all internal to the CPU anyway. The rest of the system sees a normal CPU.
12:48:28 <bparkis> it's not just a definition, there is no invariant that you can state that does more than restrict the current state or interpret it
12:48:37 * goalieca admits to have not read the whole convo
12:48:48 <wli> goalieca: I also came in late.
12:49:08 <bparkis> assuming that the program only reads/writes to the memory
12:50:32 <wli> Computers are just large repositories of state (register files, TLB's, L1/L2/etc. caches, RAM) and finite control. Ultimately it comes down to a calculator with wires on boards instead of buttons.
12:50:41 <wli> "Finite control" means FSM.
12:51:07 <EvilTerran> bparkis, it's a definition in that the word can be used to mean other things. death by semantics, an' all that.
12:51:14 <EvilTerran> but now i have to be elsewhere. laters.
12:51:17 <bparkis> ok
12:51:33 <Olathe> wli: La la la la la ! I can't hear you ! La la la la la !
12:51:37 <wli> I take it my commentary here wasn't helpful.
12:52:14 <bparkis> although that does bring up a point, that real computers allow only certain transitions from one state to another, not arbitrary ones
12:52:43 <bparkis> so you could call that an invariant on any 2 consecutive states instead of just one
12:53:04 <wli> bparkis: Or an invariant on the state transition function.
12:53:07 <bparkis> but that's not so much about the program as it is about the architecture
12:53:13 <bparkis> yes wli
12:54:41 <wli> I don't completely understand the low-level operation of asynchronous computers, but they aren't fundamentally different AIUI.
12:55:22 <bparkis> so optimization of a program at the machine level is the problem of finite state machine minimization, subject to certain constraints on the state transition function
12:57:46 <bparkis> well, almost, because of the problem of execution without input
12:58:46 <bparkis> which can be interpreted as state transitions on the empty string
13:02:26 <bparkis> so i assume that finite state machine minimization, _with_ a restricted state transition function, is a hard problem
13:03:13 <dmwit> State transitions on an empty string can be turned into normal state transitions, no?
13:03:24 <bparkis> not if the state transition function is restricted
13:03:25 <dmwit> i.e. epsilon-NFA's are equivalent in power to DFA's
13:03:43 <dmwit> What do you mean by restricted?
13:04:04 <bparkis> for example if you can only transition from one state to another if there is a machine instruction that does it
13:04:48 <dmwit> That's just the usual definition of a transition function, what's the restriction?
13:05:14 <bparkis> machine instructions being from a real computer chip, and fixed
13:05:43 <dmwit> How much have you learned about finite state automota?
13:05:50 <dmwit> s/automota/automata/
13:06:12 <newsham> are you talking about a finite state acceptor?  or a finite state transducer?
13:06:21 <bparkis> well, undergrad course + honors colloquium, and I got an A
13:06:43 <bparkis> for example suppose you have a loop that places, over the course of 50 instructions, the square of a number in one memory location into another
13:07:03 <bparkis> this is 50 (restricted) transitions on the null string
13:07:20 <bparkis> and it can't be condensed into 1 unless there is also a squaring instruction
13:07:57 <dmwit> ooooh, ok
13:08:02 <dmwit> Now I'm with you. =)
13:08:06 <hpaste>  noob annotated "do know how to iterate, please help" with "what if i don't want  putStrLn "Welcome to Mastermind" in loop" at http://hpaste.org/4055#a6
13:08:06 <newsham> doesnt sound like you're talking about FSM's
13:08:49 <dmwit> noobie: mastermind = putStrLn "whatever" >> mmloop (atries - 1)
13:08:50 <noobie> i am looping something but i don't want the welcome mesage to be looped
13:09:15 <dmwit> noobie: Actually, you'd have to do it one level higher than mastermind, I guess.
13:09:25 <noobie> how?
13:09:28 <newsham> noob: why are you making one very large copmlex function?
13:09:30 <dmwit> noobie: In any case, just move the putStrLn out of the loop, like you would in any language.
13:09:34 <newsham> instead of lots of really small easy to understand functions?
13:09:35 <noobie> can u anotate pleas
13:10:14 <bparkis> let a machine specification, K, be a set of states and a set of state transitions between those states, where some of the transitions may be null transitions and the machine may have more than one transition per symbol for a state
13:10:39 <noobie> i am gonna do a readFile, but i want it to read and print only once
13:11:08 <bparkis> let a finite state machine restricted to K, called a K-FSM, be a subset of those states and transitions, such that the K-FSM has at most one transition per symbol for a state (including at most one transition for the null string)
13:11:36 <noobie> any help?
13:11:41 <bparkis> a K-FSM is an approximation of a computer program running on a computer with a fixed memory and fixed instruction set
13:12:22 <dmwit> noobie: I think you can figure this one out on your own.  I'll give you a hint: you need another top-level function that prints your message (once), then starts the loop.
13:12:36 <noobie> ok
13:12:42 <noobie> jus got it
13:12:47 <dmwit> noobie: But, I think this function is a bit long, and you may not be taking full advantage of Haskell's abilities.
13:13:03 <noobie> wat
13:13:05 <Mr_Awesome> dmwit: well, he is a noobie ;)
13:13:21 <noobie> i am a newbie help!!!!!!!!
13:13:24 <newsham> and he just got good advice.  noobie, rewrite simpler small pieces
13:14:14 <Mr_Awesome> im not against the advice
13:14:32 <dmwit> You might want a function like "nextStep :: String -> IO ()" or so that handles a single line of input.
13:14:44 <newsham> noobie: you prompt the user for his last guess but never look at it, when tries drops to zero
13:14:46 <dmwit> Then you can use pattern matching to get rid of all the if/then/else clauses in there.
13:14:47 <newsham> thats kind of rude :)
13:15:13 <dmwit> newsham: I... don't think that's true.
13:17:49 <newsham> dmwit: guess <- getLine. if tries == 0 then putStrLn "Game Over, ..."
13:17:58 <dmwit> oh
13:18:00 <newsham> else if guess == code ...
13:18:03 * dmwit is often wrong
13:19:04 <newsham> should check tries after checking guess, and right before recursing
13:20:03 <noobie> i tried putting it putside the loop but i got an erro
13:22:10 <newsham> promptLoop prompt state proc = do { putStrLn prompt; hFlush stdout; guess <- getLine; case proc state guess of Nothing -> return (); Just state' -> promptLoop prompt state' proc
13:22:42 <newsham> err I guess proc would have to be an action not a function
13:23:56 <newsham> mstate <- proc state guess;  case mstate of ...
13:29:56 <noobie> i can't get to not loop
13:30:39 <noobie> i built a game and i draws a random value from a file,  but everytime it loops it changes
13:30:54 <noobie> don't know what to do
13:31:13 <newsham> dont understand the problem
13:33:36 <noobie> i ave a file with codes in it e.g. [1,2,2,3,3,4,4], i use the index function to take one of them and the user as to guess it
13:33:49 <noobie> if it changes he will never
13:33:51 <noobie> win
13:34:10 <noobie> readFile <- "code.txt"
13:34:26 <noobie> file !! (index)
13:34:36 <noobie> user as to guess that value
13:34:50 <noobie> the loop is changing the value
13:37:34 <newsham> so dont make the loop change its value?
13:38:30 <noobie> how?
13:38:44 <newsham> i dunno.. how did you make the loop change the value?
13:39:00 <newsham> you're asking specific questions about code that you have
13:39:06 <newsham> I cant possibly answer it
13:39:12 <newsham> (also your questions are somewhat vague)
13:39:15 <noobie> it gives the user 8 tries
13:39:43 <noobie> on each try the it changes the value
13:39:57 <noobie> in other words i want to read the file once
13:39:58 <newsham> so make it not change the value on each try
13:40:06 <newsham> make it read the file just once
13:40:07 <noobie> how???
13:40:13 <newsham> read the file
13:40:20 <newsham> then run your loop
13:40:35 <newsham> you're trying to do so many things in your function
13:40:40 <newsham> i'm not suprised its confusing you
13:40:45 <newsham> you need to make little baby steps
13:40:50 <newsham> not do everything all at once
13:40:56 <noobie> it is a game
13:41:02 <noobie> and it is dew monday
13:41:21 <newsham> yes.  so you need to think of your game and how it breaks down into small problems
13:41:27 <newsham> and write solutions to each of those small problems
13:41:39 <newsham> not write one big honking function that does the wholething
13:43:23 <newsham> here's an example.  you could write a function which runs the main game loop, then asks the user if he wants to go again or not
13:43:26 <newsham> and loop if he does
13:43:29 <newsham> and dont loop if he doesnt
13:43:38 <noobie> Syntax error in input (unexpected `<-')
13:43:39 <newsham> thats a small 3-line function
13:44:11 <newsham> let me know when you have a question
13:45:46 <noobie> :e
13:46:30 <noobie> i wrote this
13:46:31 <noobie> cod = do
13:46:31 <noobie>   codeDB <- readFile "code.txt"
13:46:38 <noobie> outside the loop
13:46:42 <noobie> getting a erro
13:49:12 <newsham> what error are you getting?
13:49:26 <noobie>  Syntax error in input (unexpected `<-')
13:50:06 <newsham> thats not what I get when I do that same thing
13:51:25 <dmwit> noobie: The more you hpaste, the better we can help you.
13:51:35 <noobie> ok
13:51:55 <newsham> you need to come up with a question, ask it, and then listen to and accept the answer
13:52:53 <hpaste>  (anonymous) annotated "do know how to iterate, please help" with "(no title)" at http://hpaste.org/4055#a7
13:52:57 <noobie> there
13:53:59 <noobie> i am trying to take the codeDB       <-   readFile "code.txt" out the loop
13:55:05 <newsham> do you have a question?
13:55:24 <noobie> how do i take it out the loop?
13:55:46 <newsham> why dont you read your data before calling mmloop?
13:55:46 <noobie> is dat a difficult ques?
13:55:54 <newsham> and pass it in to mmloop?
13:56:14 <noobie> yes
13:56:28 <noobie> i want the code to be retrieved once
13:56:44 <newsham> so before calling mmloop, read it and pass it in to mmloop
13:57:08 <dobblego> does the Either ADT have another name in different fields?
13:58:33 <newsham> mmloop happens every time you ask the user for another value
13:58:44 <newsham> things that you dont want to do every time shouldnt be done in mmloop
13:59:02 <ddarius> dobblego: sum or or or disjoint union
13:59:12 <ddarius> or coproduct
13:59:23 <dobblego> ddarius, can you please use parentheses? :)
13:59:42 <noobie> how do i take it out
13:59:52 <dobblego> (sum) or (or) or (disjoint union)?
14:00:01 <noobie> thats what i av been askin u for the past hour
14:00:13 <noobie> r u gonna help or not
14:00:23 <newsham> noobie: I dont know how to answer that question without doing your homework for you
14:00:28 <newsham> you basically dont put it there
14:00:29 <ddarius> dobblego: or coproduct, yes.  There are others for the analogous idea in other specific fields.
14:00:32 <newsham> and you put it somewhere else
14:00:44 <noobie> i did most of the code
14:00:46 <newsham> noobie: i can help you, but I cant do your homework for you.
14:00:53 <dobblego> ddarius, great thanks
14:00:53 <noobie> i just want 1 answer
14:01:13 <newsham> "how do I take it out?"  "you dont put it in mmloop"
14:01:17 <newsham> thats as simple as I can state that.
14:01:31 <noobie> where do i put it?
14:01:32 <newsham> perhaps someone else has a more enlightening answer.
14:01:34 <dmwit> (sum, or) or (or, disjoint, union) or (coproduct) is my guess
14:01:51 <Heffalump> noobie: how about in mastermind?
14:01:52 <newsham> noobie: how about in one of the functions that calls mmloop?
14:02:18 <noobie> codeDB <- readFile "code.txt"
14:02:35 <noobie> i tried to put i there and got an err
14:02:43 <newsham> where did you put it?
14:02:55 <Heffalump> well, show us the code and the error and perhaps we can help..
14:03:19 <newsham> *sigh*
14:03:39 * ddarius suggests reading the assigned material or talking to your instructor or a tutor or someone else who is paid to educate you.
14:03:44 <noobie>  Syntax error in input (unexpected `<-')
14:03:50 <noobie> thats the err
14:03:54 <dmwit> noobie: Keep in mind that the (<-) notation must be inside a do-block, which means it has to be in a function.
14:03:59 <newsham> I dont mind trying to educate you,  i just refuse to do the work for you.
14:04:08 <dmwit> noobie: That's pretty useless without the code that produced it.
14:04:12 <newsham> if you ask questions about what you're doing and how its not working i can try to answer
14:05:57 <newsham> noobie: you'd find this a lot easier if you took your big problem and broke it down into smaller problems
14:06:01 <noobie> some of persons from school as been googling  me code and i don't want to post everythin
14:06:02 <newsham> and wrote solutions for the smaller problems
14:06:58 <noobie> they r cheatin
14:07:01 <newsham> you dont have to post your code.  but if you dont, we might not be able to help
14:07:08 <newsham> if you talk to a tutor directly you can avoid posting any code
14:07:38 <ddarius> noobie: You need a tutor.  You do not appear to be at the level your instructor expects you to be.  Looking at your code and what you are having problems with, you have misunderstandings deeper than can be resolved with some IRCing (at least the way you are approaching it).
14:08:17 <newsham> also keep in mind that we're just people here hanging out in our spare time.  we're not necessarily here to help people with homework.
14:08:17 <hpaste>  dmwit pasted "Is there a nicer way to do this pattern?" at http://hpaste.org/4075
14:08:19 <noobie> my tutor taught me nothing about this,
14:09:13 <noobie> i had to learn it
14:09:26 <noobie> i did that way first but i got stuck
14:10:46 <noobie> u know what guys i'll jus read my course book
14:10:54 <noobie> wasted a hour
14:11:00 <dmwit> noobie: If you're hoping to avoid work, you came to the wrong place.  Ask a good question here and the answer might be a link to a scholarly journal paper. =P
14:11:24 <hpaste>  ddarius annotated "Is there a nicer way to do this pattern?" with "maybe not nicer" at http://hpaste.org/4075#a1
14:11:34 <dmwit> But do come back after you've read the book, and I'm sure people will be happy to try again to help you.
14:11:41 <newsham> you didnt waste an hour, you used an hour to learn that there were things you didnt yet know about
14:11:45 <newsham> and now you can go learn those things
14:12:11 * ddarius agrees with noobie.  He wasted an hour that he could have spent reading the assigned material.
14:12:12 <dmwit> ddarius: Ah, I like that a bit better.
14:12:21 <dmwit> It scales to having more conditions.
14:13:03 <newsham> dmwit: some cpus have instructions to do that (where a word is considered a vector of bools)
14:13:30 <dmwit> I'm not expecting this MasterMind test program to be very CPU-intensive. =)
14:13:57 <noobie> actually it lags
14:16:08 <newsham> http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear
14:16:09 <lambdabot> Title: Bit Twiddling Hacks, http://tinyurl.com/3j7nq
14:16:41 <dmwit> Wait, why can't I do this: "case () of { () | x = a | y = b | z = c | otherwise = d }"?
14:16:57 <ddarius> dmwit: You need a ->
14:17:15 <dmwit> doh
14:17:30 <Saizan> mmh, with type-level lists there's no way to abstract recursion in a class and avoid the repetitive instance Foo Nil, instance Foo t => instance Foo (Cons a t), pattern?
14:17:43 <ddarius> There should be.
14:18:01 <ddarius> It's like encoding hofs in a logic language almost.
14:18:09 <ddarius> (I think it works out a little nicer actually.)
14:18:43 <Saizan> so i need a type that represent the class?
14:24:49 <firefly> I think noobie did waste an hour of other people's time :/
14:24:56 * firefly likes the comp.arch solution to those problems
14:25:32 <EvilTerran> Saizan, sth like: class List a l; instance List a Nil; instance List a l => List a (Cons a l); helpful?
14:26:41 <newsham> firefly: thats a prespective he hasnt seen from yet
14:26:59 <monochrom> What is the comp.arch solution?
14:27:03 * firefly can't quite parse that
14:27:24 * EvilTerran may not be thinking of the same problem as Saizan
14:27:25 <monochrom> prespective = perspective ?
14:27:36 <firefly> we have an informal competition about posting the most misleading but plausible answers to obvious homework questions.
14:27:45 <monochrom> Hehe.
14:27:59 <dmwit> heh
14:28:01 <dmwit> yikes
14:28:03 <newsham> firefly: noobie would rather complain about his wasted hour than apologize for wasting our hour
14:28:21 <firefly> The best answers are so misleading that one or two classes or a few hours spent with an intro book will be enough to spot them -- but some people still use them verbatim :)
14:28:41 <dmwit> Has anybody ever spotted a turned-in comp.arch answer?
14:28:52 <Saizan> EvilTerran: mmh, i don't see even what the meaning of List there is
14:28:58 <dmwit> (Are there any profs in comp.arch?)
14:29:04 <firefly> some of the regulars sometimes teach... :)
14:29:14 <firefly> yes, and chip designers.
14:29:32 <monochrom> "r u gonna help or not" is the sign #haskell needs to detect and stop "helping".
14:29:39 <EvilTerran> firefly: and, presumably, they're sufficiently stupid that the tutor would realise that no-one could've written it from scratch and thought it correct?
14:29:52 <firefly> Andy Glew, who was one of the main P6 guys and also defined MMX and the x86 memory ordering is there.
14:30:13 <firefly> They are NOT stupid.  They are clearly wrong but in sophisticated ways.
14:30:23 <EvilTerran> well, yes. that's what i mean
14:30:31 <firefly> Mike Haertel who did work on P4 is often there.
14:31:03 <firefly> Mitch Alsup (Athlon, K8 + a bunch of older cpus) is there.
14:31:16 <newsham> so all the people who made the worst archs we use today? ;-)
14:31:22 <firefly> Sophie Wilson (who did the ARM) has posted there occasionally.
14:31:52 <firefly> The X86 is actually not that bad and P6 is fantastic implementation of it.
14:32:32 <newsham> ia32 is pretty bad.  they do some pretty amazing jobs with it, though.
14:32:34 <firefly> There used to be some Alpha guys and a MIPS guy who "retired" from the group.
14:32:45 <wli> The x86 (from a microarchitectural POV) looks fantastic until it has to interact with programs that run on it and compilers.
14:32:47 <firefly> newsham: absolutely 100% wrong.
14:33:00 <firefly> Too few registers, but that's about it.
14:33:10 <wli> Try floating point.
14:33:24 <newsham> very irregular instruction set, many instructions that are rarely useful.
14:33:28 <newsham> oh yah, floating point.. heh...
14:33:56 <firefly> Quite regular, actually, from 386 and onwards.
14:34:09 <newsham> can you name an instruction set design that is worse than ia32?
14:34:15 <newsham> firefly: wrong.
14:34:17 <firefly> HPPA
14:34:17 <nominolo> interestingly though, x86 compact instruction set gives it a boost at integer performance
14:34:35 <firefly> IA64.
14:34:39 <newsham> i've written iset models for ia32 and hppa.  the ia32 one was much much much much larger
14:34:43 <newsham> and more complicated
14:34:59 <nominolo> compact = average bytes per instruction
14:35:00 <newsham> (hppa1.1 and 2.0)
14:35:01 <firefly> newsham: how and why am I wrong?  References, please.
14:35:13 <firefly> The IA32 set is big but that is not necessarily all that bad.
14:36:00 <newsham> firefly: what sort of references are you looking for?   the encoding rules in the appendices of ia32 arch ref manual vol2 are pretty large and awkward (compare re: parisc 2.0 or sparc v9)
14:36:17 <firefly> does that make the architecture bad?
14:36:18 <newsham> or alternately take alook at the disassembler code in binutils for ia32 vs. parisc
14:36:20 <nominolo> firefly: it's hard to decode and encode, but that size of the ship takes a (mostly) constant number of transistors, so it's becoming less and less of a problem
14:36:45 <nominolo> s/ship/chip/
14:36:46 <newsham> its also harder to learn (more irregular)
14:36:48 <firefly> I'd contend that the register windows of the sparc is a truly bad feature of the architecture, for example.
14:36:55 <newsham> and harder to write backend code generators for
14:36:58 <newsham> and peephole optimizers
14:36:58 <firefly> Does IA32 have anything that bad?
14:37:05 <nominolo> IA64 has some very nifty features
14:37:18 <newsham> the instruction set of the ia32 is much more crippling for backend code generation than register windows are
14:37:21 <firefly> nominolo: it has too many nifty features that don't play together well.
14:37:32 <firefly> newsham: what !?!?!?!?!
14:37:35 <nominolo> firefly: for example?
14:38:27 <firefly> the asynchronous stack engine, which plays badly with lots of things.  IA64 code basically has two stacks and needs "fat pointers" (two pointers together) for function pointers or lots of trampolines.
14:39:05 <firefly> IA64 does have logic instructions for its floating-point registers.  I like that.
14:39:40 <nominolo> vliw is too close to the hardware, also
14:39:55 <nominolo> vliw works better with JIT, though
14:40:07 <wli> Register class nasties out the wazoo, floating point is at best described as "grossly irregular," immense amounts of effectively useless system state needing to be carried around (e.g. the useless crap in/around TSS's) and often even updated, etc.
14:40:08 <EvilTerran> -blah
14:40:28 <firefly> You can sometimes play a few tricks with logic on IEEE fp values.  If you have to ship the values to the integers, operate on them, and then ship them back you usually lose more than you gain for playing those tricks.  You don't have to ship back and forth on IA64.
14:41:02 <firefly> wli: IA32 still has fewer kinds of fp than the PDP-11 ;)
14:41:06 <newsham> ia32 memory management is the superset of all bad ideas
14:41:19 <firefly> you won't say HPPA is worse?
14:41:32 <firefly> the many modes are a drawback on IA32, though.
14:41:32 <newsham> not even close.
14:41:51 <firefly> do you prefer HPPA's segmentation over IA32's?
14:41:51 <wli> My description still applies to x86-64.
14:42:10 <newsham> firefly: sure.  by simple virtue of his minimality in comparison.
14:42:26 <newsham> s/his/its/
14:42:37 <newsham> ia32 is baroquen
14:42:38 <EvilTerran> -blah!
14:43:03 <newsham> the only thing it has going for it is sheer popularity by virtue of long history of backwards compatibility and the windows operating system
14:43:26 <ddarius> EvilTerran: You may want to use more complete sentences.
14:43:33 <firefly> do I remember correctly:  it takes a few of the upper bits of the 32- or 64-bit "logical address" (register + offset) and uses that to index into a table of segments and adds that value (shifted) to the value of the remaining bits and then feeds that into the page table logic?
14:43:43 <EvilTerran> ddarius, it's perfectly obvious what i mean
14:43:56 <ddarius> EvilTerran: To -me-
14:44:13 <newsham> ff: i dont remember the exact details.
14:44:39 <firefly> as far as I recall it is basically that (with a few more complications).  Is that better than what the IA32 has?  I don't think so.
14:44:50 <wli> Tell me this: if you're going to get more instruction-level parallelism via Haskell, compare how you do it on x86-64 vs. Alpha, ARM, IA64, MIPS, PA-RISC, IBM Power, etc.
14:44:55 <newsham> yes it is better.  less is more.
14:45:07 <newsham> its not the number of features they implemented that makes a chip great
14:45:18 <newsham> its the number of features they didnt implement
14:45:23 <firefly> wli: less of a need for memory barriers on IA32/AMD64 :)
14:45:24 <newsham> s/chip/architecture/
14:45:41 <wli> firefly: Instruction-level parallellism.
14:45:43 <firefly> newsham: no, it's about their interplay.
14:46:21 <firefly> instruction-level.  ok, so we're talking register names, renaming...
14:46:34 <alexyk> anybody knows python around here?  I'm trying to do a reduce on tuples: f0 = [(1, 2, 3), (4, 5, 6)];  reduce(lambda x,y: x[2]+y[2], f0, (_,_,0)) =>  'int' object is unsubscriptable...  sorry for FP python, but I figure it's more likely folks here know and I'm subscribed anyways :)
14:46:49 <firefly> good thing core 2 (and amd barcelona) can do some speculative out of order stuff with memory too.
14:46:50 <wli> firefly: Not just that. Register classes.
14:46:59 <EvilTerran> ddarius, okay, you may have a point
14:47:06 <EvilTerran> given current evidence, anyway
14:48:06 <dmwit> alexyk: There seems to be a pretty active #python here on FreeNode.
14:48:16 <wli> firefly: The register names have to be available to the application to be used by a compiler. Insufficient registers or too many clobbers and classes and bizarre things that can't be translated effectively and the game's over.
14:48:33 <firefly> a pity ghc doesn't use the real stack much.  The "stack engine" of Pentium M (and core, core 2) and barcelona breaks the dependency chain of stack relative access combined with ESP modifications.  I don't think that works with EBP :(
14:48:41 <newsham> "To this very day, idiot software managers measure 'programmer produtivity' in terms of 'lines of code produced' whereas the notion of 'lines of code spent' is much more appropriate" -dijkstra
14:49:25 <mauke> alexyk: you want to reduce to an int?
14:49:46 <alexyk> mauke: yeah, it's a sum of the third element of tuples (x,y,z)
14:49:58 <alexyk> mauke: works without the initializer
14:50:00 <dmwit> alexyk: In any case, wouldn't it be (0,0,x[2] + y[2]) in your lambda?
14:50:22 <dmwit> Or, x+y[2] or something.
14:50:34 <newsham> alex: you're assunming both of your arguments are going to be tuples
14:50:35 <alexyk> dmwit: works without initializer: reduce(lambda x,y: x[2]+y[2], f0) => 9
14:50:39 <newsham> but you're returning a scalar value
14:50:39 <dmwit> (If you choose the latter, the initializer has to be only the int, not a tuple.)
14:51:18 <dmwit> alexyk: This is why you need type checking. ;-)  You're mixing tuples and scalars in ways they shouldn't.
14:51:27 <alexyk> int doesn't work either: reduce(lambda x,y: x[2]+y[2], f0, 0) => 'int' object is unsubscriptable
14:51:34 <dmwit> x+y[2]
14:51:36 <mauke> x+y[2]
14:51:41 <dmwit> Or maybe x[2]+y, I'm not sure.
14:51:59 <dmwit> But wouldn't this be better?
14:51:59 <alexyk> oh my
14:52:02 <newsham> firefly: you seem to be impressed by the implementation flash of the recent ia32 members (rightly so) and carrying that over to being impressed about the ia32 architecture itself (which is horrible)
14:52:07 <dmwit> map(lambda (x,y,z): z)
14:52:11 <alexyk> yeah, thats why we need types in Haskell
14:52:14 <dmwit> then use "sum" or its equivalent.
14:52:18 <newsham> if we had all gone to alphas a decade ago, the chips would be all the omre impressive today
14:52:30 <alexyk> thx guys, sorry for the Python :)
14:52:36 <newsham> by virtue of not having to jump through hoops to support a baroque architecture
14:52:48 <mauke> alexyk:  reduce(lambda x,y: x[2]+y[2], [(1,2,3), (4,5,6), (7,8,9)])  doesn't work either
14:53:11 <alexyk> hmm
14:53:15 <alexyk> works with two
14:53:18 <alexyk> tuples
14:53:22 <dmwit> Guess why. ;-)
14:53:36 <firefly> wli: actually, we are not even close to generating semi efficient code with ghc.  The current limiter seems to be branch prediction on indirect jumps (not a problem on recent X86 implementations) and the enormous amount of memory accessing going on.  The X86 implementations tend to be better at handling that than the competition (they've historically had very fast L1).
14:53:40 <dmwit> Hint: how many parameters does your lambda have?
14:53:46 <newsham> >>> xs = [(n,n,n) for n in xrange(100)]
14:53:47 <newsham> >>> reduce(lambda x,y : x + y[2], xs, 0)
14:53:47 <newsham> 4950
14:53:58 <Japsu> reduce = foldr?
14:53:59 <alexyk> dmwit: 2, so it just deduces types?
14:54:12 <alexyk> reduce is a foldr with initializer optional
14:54:26 <dmwit> alexyk: Do you know about the function(*args) syntax?
14:54:26 <wli> newsham: Sadly, x86-64 is the last architecture ever. It'll be the last arch standing when the rest are dead and the only thing left for the rest of the history of computing.
14:54:26 <ddarius> More likely a foldl I'd think
14:54:27 <firefly> newsham: no.  not at all.  I've spent a lot of time over the last year or so reading about, thinking about, and writing about microarchitecture and the cost of implementing various macroarchitectural features.
14:54:41 <newsham> ia32 is not the microarchitecture
14:54:47 <dmwit> alexyk: I'm guessing that's what's happening here.  It's treating your list as both initializer and reducer.
14:54:50 <newsham> ia32 is the instruction set and cpu features the programmer sees
14:54:57 <firefly> My target is the VAX which sadly has been much maligned.  Most of the conclusions are the same for the VAX and X86.
14:55:00 <alexyk> ddarius: sorry foldl
14:55:37 <firefly> we will still have 8051!
14:55:38 <newsham> vax is a great cisc.  i love the 68k iset which is a shadow of the vaxes
14:55:48 <newsham> ia32 is nothing like the vax
14:55:59 <newsham> the vax instruction set *WAS* orthogonal
14:55:59 <wli> VAX is good. x86 is bad. etc.
14:56:07 <firefly> they are not exactly all that similar (VAX and 68K).  They both look a bit like PDP11.
14:56:17 <firefly> IA32 is actually a lot like the VAX.
14:56:21 <alexyk> dmwit: thx, I'm happy you guys helped!  very illuminating about typed FP
14:56:32 <wli> No, it's nothing like the VAX.
14:56:36 <dmwit> alexyk: But you really should do the equivalent of (sum . map (\(x, y, z) -> z)); it will be a lot faster and it is more orthogonal in case your datatype changes later.
14:56:41 <firefly> Or rather, the problems one have to solve to make it go fast are very similar.
14:57:19 <firefly> 68K is not nearly as nice as I used to think -- the encoding is atrocious already in the first version of the architecture.
14:57:50 <newsham> the only major faux pas in the 68k is separating A and D registers
14:57:56 <alexyk> dmwit: yes, absolutely
14:57:58 <wli> I think you're judging the CPU/program interface by the microarchitecture.
14:58:09 <newsham> wli++   exactly what I said.
14:58:18 <firefly> I tried an experiment to see how complex a decode to ¬µops would be... it turned out to take over 200 PLA terms to figure out whether an instruction was valid or not and how big it was (you can determine this from the first word).
14:59:18 <firefly> it was a single-stage solution, a smaller one could probably be found if one used a hierarchical decoding scheme.
14:59:30 <firefly> (I just threw a PLA compactor at it)
14:59:59 <newsham> there are only 56 instructions on the 68k
15:00:25 <firefly> newsham: I think you might want to look at the binary encodings and change your mind a bit.
15:00:58 <firefly> A fast implementation of the 68K needs to decode instructions fast, preferably several in parallel (or cache the decodings).
15:01:02 <EvilTerran> ... still talking about processors, i see.
15:01:24 <firefly> In order to do that it has to distinguish between a lot more than 56 cases -- I've done the experiment.
15:01:41 <goalieca> risc FTW
15:01:51 * firefly loves processors and coding to the metal
15:02:08 * goalieca like vhdl and designing the processors
15:02:14 <goalieca> well fpga's anyways
15:02:15 * firefly prefers verilog
15:02:21 <wli> firefly: Have you seen what compilers' code generators have to do get optimizations going on x86 and x86-64 vs. other cpus (ignoring ia64, which everyone does)?
15:02:30 * EvilTerran is quite happy with his far-removed-from-computers computing
15:02:59 <wli> firefly: That's more of the sort of issue newsham and I are on about.
15:03:27 <goalieca> computers are boring at the "everything is a database" level
15:03:33 <firefly> errr... what do you mean by "vs. other cpus" ?  They generally perform heroics (in some places) and are a bit naive (in others).  That seems to be the same for all architectures.
15:03:36 <newsham> or conversely, the amount of effort to semantically operate on arbitrary assembly code for said systems
15:04:04 <firefly> nope, newsham seems to have bought into the "x86 is ugly, 68K and risc are kool".  I know you are a bit smarter than that :)
15:04:20 <newsham> ad hominem
15:04:27 <wli> firefly: It's vastly different when the instruction set is a horrible mess. You can't even use the same classes of algorithms.
15:04:32 <newsham> my argument does not hold water so I will call you a dummy.
15:04:55 <wli> firefly: Case in point: graph coloring sucking on x86 where it does fine elsewhere.
15:05:08 <firefly> too few registers, alas :(
15:05:12 <goalieca> firefly, x86 is an ugly ISA but intel and amd have done amazing things underneath it.
15:05:30 <newsham> I havent "bought into" anything.  I've implemented systems that use instruction sets from many cpus
15:05:35 <newsham> and formed my own decisions
15:05:39 <newsham> opinions
15:05:45 <wli> firefly: Not just that, but also register class badness, clobbers, etc.
15:06:04 <firefly> I don't agree that those really are that bad.
15:06:09 <wli> firefly: Moving on to floating point...
15:06:22 <firefly> I don't think SP should have been a general register, though.
15:06:58 <firefly> one of the fp problems was that they took too long to realize that people wanted consistency over precision.
15:07:23 <firefly> Code that was 80-bit when everything was in registers and rounded to 64-bit when spilling tended to confuse people.
15:07:29 <newsham> how about make the fpu a stack machine.  who would want CSE?
15:07:33 <firefly> They got smarter and added some rounding bits.
15:07:45 <Brian`> hey, sorry to interrupt, but can I ask you a question? I'm having trouble understanding Writer monad..
15:08:06 <wli> firefly: The need for something vaguely resembling a normal register file is the real problem. All the SSE bits don't really cover it. They just add more SIMD crap on.
15:08:07 <ddarius> Brian`: Seeing as you are on-topic, you certainly can ask a question.
15:08:09 <firefly> The fpu stack is smallish.  It had a good size when they made it originally, but it should probably have been enlarged.
15:08:11 <newsham> brian: this is #haskell.  you have priority
15:08:19 <firefly> newsham: CSE is still possible.
15:08:30 <Brian`> I was looking at http://www.haskell.org/all_about_monads/examples/example17.hs and it says logMsg :: String -> Writer [Entry] ()
15:08:33 <Brian`> :t Writer
15:08:40 <lambdabot> forall a w. (a, w) -> Writer w a
15:09:02 <Brian`> how does it work? Writer accepts (a, w) but [Entry] () is not in the form (a,w)
15:09:24 <ddarius> Brian`: Writer is being used here in two different ways.
15:09:36 <ddarius> Brian`: One is the -type- constructor that takes two arguments w and a
15:09:39 <ddarius> :k Writer
15:09:39 <lambdabot> * -> * -> *
15:09:50 <ddarius> The other is the -data- constructor that takes a pair
15:09:53 <ddarius> :t Writer
15:09:54 <lambdabot> forall a w. (a, w) -> Writer w a
15:10:02 <ddarius> @src Writer
15:10:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:10:15 <ddarius> newtype Writer w a = Writer (a,w)
15:10:21 <Brian`> that's type constructor?
15:10:42 <ddarius> The thing on the left is a type constructor, the thing on the right is a data constructor
15:10:52 <ddarius> Compare to say, data Maybe a = Nothing | Just a
15:10:57 <firefly> that's a confusing aspect of Haskell -- it still caused me to read Haskell code a bit slower up until a week ago when the same name was used for both a type and a data constructor :(
15:11:05 <ddarius> Just and Nothing are data constructors, Maybe is a type constructor
15:11:23 <Brian`> oh.. yeah that's confusing :(
15:11:50 <ddarius> Brian`: It isn't really.  Types and values live on entirely different levels so their namespaces are entirely separater.
15:11:52 <newsham> Writer [Entry] ()     means its a writer that writes out [Entries] and results in ()
15:11:57 <newsham> ?type tell
15:11:58 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
15:12:02 <wli> firefly: Also, tacking on progressively more SIMD registers is making progressively more work for the kernel in its FPU save/restore, which has degraded context switching, signal handling, and more.
15:12:18 <firefly> yes, it is.  They can have the same name.  They probably should have shared the same namespace so people would have to use different names.
15:12:46 <firefly> wli: but is it worse than the register stacks of Sparc? ;)
15:12:58 <wli> firefly: I'd certainly say so.
15:13:01 <Brian`> newsham, so in logMsg :: String -> Writer [Entry] (), is Writer type constructor then?
15:13:08 <ddarius> firefly: -Most- people do it on purpose, so that suggests that it was the correct thing to do.  Certainly having the type and value levels share namespace would be a complete mistake.
15:13:08 <firefly> really?!   Ok, that surprises me!
15:13:14 <newsham> > runWriter (do {tell "test"; tell "this"; tell "out"; return 1})
15:13:16 <lambdabot>  (1,"testthisout")
15:13:18 <ddarius> Brian`: That is a type...
15:13:34 <firefly> ddarius: have you done usability studies on this? ;)
15:13:34 <wli> firefly: You're asking the wrong person to bash SPARC.
15:14:16 <firefly> with "really?!" I also sort of mean: "you probably actually have some data on this, at least anecdotally... can you share?"
15:14:16 <wli> firefly: Register windowing is a fantastic hardware assist to register spilling.
15:14:24 <newsham> brian: its a function which takes a string and gives you back an Writer [Entry] () action which puts the string in the writer state
15:14:26 <ddarius> firefly: On what?  That it'd be a mistake is clear because 1) people don't choose to work that way and 2) people would be very upset if some data constructor somewhere took up their type name.
15:14:46 <newsham> when you run that action, it puts the string in the writer state and results in ()
15:15:02 <newsham> > runWriter (tell "test")
15:15:02 <firefly> ddarius: on how long it takes before newcomers stop being confused by the feature + on how much it slows their reading of programs down.
15:15:03 <lambdabot>  ((),"test")
15:15:22 <firefly> You can't necessarily trust self-reported data ("oh, I like it and it doesn't slow me down").
15:15:43 <firefly> We know for a fact that different fonts for example not only influence people's reading speed but also their *comprehension*.
15:15:44 <ddarius> firefly: I am not in the school of making a language cater to beginners at the expense of experienced users.
15:15:54 <resiak> > runWriter (tell "foo" >> tell "bar")
15:15:54 <lambdabot>  ((),"foobar")
15:15:59 <firefly> I'd wager that this feature continues to have costs after people stop being newbies.
15:16:03 <dobblego> @remember <ddarius> firefly: I am not in the school of making a language cater to beginners at the expense of experienced users.
15:16:03 <lambdabot> Done.
15:16:12 <ddarius> firefly: The type level -purposely- puns the value level.
15:16:28 <firefly> errr... what?
15:16:50 <Brian`> newsham, okay.. I'm starting to see the picture :) but I guess I need to study the codes more to fully understand :) thanks for the help
15:16:53 <ddarius> firefly: The syntax for types is almost exactly a subset of the syntax of values (and there is as reason for this)
15:16:54 <firefly> does "pun" have a meaning I'm not aware of?  (quite likely, since I'm not a native speaker)
15:17:08 <wli> firefly: It might help if you knew who I was before you asked me to bash SPARC. ;)
15:17:17 <Saizan> firefly: having two intrinsicly related things have names that reminds of each other doesn't seem a bad thing
15:17:24 <firefly> William Lee Irwin III, Linux hacker and much else.
15:17:34 <firefly> (and mathematician)
15:17:35 <Philippa_> firefly: it's not necessarily a joke, but it's otherwise the same class of thing
15:17:42 <firefly> thanks.
15:17:48 <wli> firefly: Maintainer (at least nominally) of which Linux kernel architecture port?
15:18:05 <firefly> wli: you've worked on scalability stuff for IBM, right?
15:18:12 <firefly> wli: the debian linux kernel ;)
15:18:20 <firefly> (one of the maintainers, right?)
15:18:33 <firefly> did you take over sparc or just 32-bit sparc?
15:18:48 <wli> firefly: That's not a Linux kernel architecture port. That's a project (which I mostly just rounded up people to work on and did nothing myself).
15:19:02 <wli> firefly: 32-bit SPARC
15:19:30 <firefly> so you would actually know about the comparative context-switch costs :)
15:19:42 <newsham> the best thing ever to come in a pizza box is a pizza
15:20:04 <firefly> how does Sparc do TLS?  does it sacrifice one of the GPRs or does it have an extra register squirrelled away somewhere?
15:20:29 <wli> You've got to spill the stack sometime.
15:20:34 <EvilTerran> sjanssen! tell us something interesting about haskell!
15:20:47 <wli> firefly: It has enough GPR's to dedicate one.
15:21:29 <ddarius> Okay, since EvilTerran can't seem to say it outright.  EvilTerran would like you all, firefly, newsham, wli, anyone else to have this discussion on CPU architechtures in the channel #haskell-blah
15:21:33 <firefly> one of those that don't participate in the windowing?
15:21:44 <firefly> ok, I'll stop now.
15:21:46 <newsham> ddarius: thank you.  I agree completely
15:21:51 <EvilTerran> thanks, ddarius :)
15:22:03 <firefly> my point about using the stack more still holds, though.
15:22:14 <EvilTerran> I'm afraid i suffer sometimes from being too polite/snide to be direct ;)
15:22:19 <firefly> (in compiled haskell, I mean)
15:22:36 <wli> firefly: The stack pointer is not unique. There are other global registers to hold such things as TLS pointers.
15:23:00 <wli> firefly: So you're poking at a non-issue.
15:23:16 <newsham> arguing on the internet is like running in the special olympics.  even if you win, you're still a retard.
15:24:59 <newsham> ?src Writer tell
15:24:59 <lambdabot> Source not found.
15:25:08 <Saizan> so.. are gcc defined cpp constants in scope when ghc runs cpp on sources?
15:25:29 <goalieca> newsham, and just like in real-life no one cares.
15:25:50 <EvilTerran> Saizan, wouldn't that be fairly easy to check?
15:25:57 <newsham> saizan:  ghc -v foo.c   shoudl tell you the answer
15:26:16 <EvilTerran> although it seems likely
15:27:06 <newsham> seems to me like most of the "normal" gcc defines arent there
15:27:43 * EvilTerran is still bothered by the use of cpp as a haskell preprocessor
15:27:54 * ddarius suggests m4
15:28:06 <EvilTerran> as an *anything* preprocessor, even, but us haskellers in particular should be able to come up with something better
15:28:29 <ddarius> EvilTerran: There are benefits of using CPP
15:28:47 <newsham> oh wait i think i answered the wrong question
15:28:52 <EvilTerran> other than it being generally available?
15:29:11 <ddarius> EvilTerran: Often times the defines wanted are in .h files
15:32:03 <EvilTerran> hmm
15:34:50 <noobie> hey guys i built another function, and use within the loop and it works
15:35:46 <newsham> noobie: congrats!
15:41:35 <newsham> ghc -cpp -v foo.hs   shows me the following -D's:   __HASKELL1__=5 __GLASGOW_HASKELL__=608 __HASKELL98__ __CONCURRENT_HASKELL__ freebsd_BUILD_OS=1 x86_64_BUILD_ARCH=1 freebsd_HOST_OS=1 x86_64_HOST_ARCH=1
15:52:00 <thoughtpolice> with cabal (1.2), how can you specify that an executable you're building depends on a library that's built in the same package?
16:01:38 <Brian`> hey, does "let rules     = (read ruleData)::[Rule]" mean read ruleData and convert the type to [Rule] ?
16:01:53 <noobie> is it possible to use a IO function with a another IO function
16:01:54 <EvilTerran> not convert, restrict
16:02:17 <EvilTerran> :: annotations *never* actually change anything at runtime
16:02:26 <EvilTerran> including conversion between types
16:02:37 <noobie> can a IO be converted IO Int be converted to a Int?
16:02:45 <Brian`> thanks EvilTerran
16:02:53 <Lemmih> noobie: No.
16:02:55 <Cale> noobie: No, but you can run IO actions as part of other IO actions.
16:03:02 <Cale> For example, in a do-block:
16:03:08 <Cale> do x <- getLine
16:03:10 <Cale>    print x
16:03:19 <Cale> x :: String
16:03:24 <Cale> getLine :: IO String
16:03:39 <oerjan> what is "a IO" anyway?
16:04:59 <EvilTerran> oerjan, a transformed IO monad? :P
16:05:05 <oerjan> perhaps
16:06:12 <EvilTerran> geordi laforge with his mouth open and a fish about to land on his head?
16:07:51 <oerjan> i doubt it's a fish.  obviously something far more sinister and alien.
16:08:03 <noobie> can <- be used without a do statement
16:08:24 <oerjan> noobie: also in list comprehensions, which are equivalent to do statements
16:08:30 <oerjan> but not alone, no
16:08:55 <shachaf> noobie: <- is just syntax sugar.
16:09:07 <EvilTerran> noobie, part of the point of the do {...<-...} form is that values gotten at with <- can't escape the do{...}
16:09:15 <shachaf> noobie: It gets translated, in do-blocks, to (>>=).
16:09:18 <ddarius> 90% pointier than cane sugar
16:09:20 <oerjan> @undo do x <- argle; bargle x
16:09:20 <lambdabot> argle >>= \ x -> bargle x
16:09:42 <noobie> i am building a function to be used within another function to avoid it been looped but it is giving me hell
16:09:49 <shachaf> @wiki Monads as computation
16:09:49 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
16:12:24 <noobie> ok
16:12:34 <Cale> @wiki Introduction to IO
16:12:34 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
16:12:36 <Cale> :)
16:12:38 <noobie> but i have reached that topic yet
16:12:50 <Cale> Introduction to IO is probably better for this :)
16:12:54 <shachaf> noobie: Which topic?
16:13:08 <Cale> It's a quick intro to how to think about IO in Haskell.
16:13:13 <EvilTerran> noobie, you have or you haven't?
16:13:48 <oerjan> noobie: well essentially, any function that uses IO inside has to have an IO result type
16:14:38 <noobie> i built a function (i think) to be used. I am building a game that loops, but i don't want the actaul code to be looped. i want to be retrieved only once.
16:14:59 <Philippa_> that doesn't make sense
16:15:02 <EvilTerran> what
16:15:20 <Philippa_> "I don't want the actual code to be looped. I want to be retrieved only once"
16:15:22 <EvilTerran> I'd rather not be retrieved at all when people run my code
16:15:36 <newsham> he has a function which recurses to form a loop
16:15:41 <newsham> and he is doing something in that function
16:15:45 <newsham> and it happens every time he loops
16:15:53 <newsham> and he wants to do it only once before it starts looping
16:16:00 <Philippa_> and it's loop-invariant so it wants hoisting?
16:16:00 <newsham> and we told him that he needs to move it outside of that function
16:16:01 <EvilTerran> so... move it outside the loop?
16:16:08 <noobie> i tried
16:16:14 <Philippa_> what exactly did you try?
16:16:26 <noobie> gonna post it
16:16:30 <oerjan> noobie: you can either pass the code as a parameter to the loop function
16:16:34 <EvilTerran> our patience? ;)
16:17:07 <oerjan> or you can put the loop inside a where clause of the function that selects the code
16:17:27 <ddarius> Philippa_: "code" here does not mean "source code" but rather the "code" that the user is supposed to guess read in from a file.
16:17:35 <newsham> he has a very large function which does most of his program
16:17:44 <noobie> yes
16:17:45 <newsham> and we told him that he should break it into smaller simpler functions
16:18:04 <hpaste>  (anonymous) annotated "do know how to iterate, please help" with "(no title)" at http://hpaste.org/4055#a8
16:18:17 <noobie> there
16:18:51 <newsham> noobie: your function "code" does several IO actions in sequence
16:18:54 <noobie> it draws a random code froma text file
16:18:57 <newsham> to do that you need a "do" block or something like it
16:19:13 <newsham> also your "let code =" at the end of that function doesnt do what you probably think it does
16:19:37 <newsham> if you want to have a sequence of actions with a particular result, you need the last action in the block to have that value as its result
16:19:47 <newsham> ie  do { foo; bar; blah; return 3 }
16:19:52 <newsham> to set the result to "3"
16:20:08 <njbartlett> @seen dons
16:20:08 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 1h 11m 6s ago.
16:20:17 <noobie> te let converts the text file to a data type i created named Color
16:20:30 <Philippa_> noobie: why is "mmloop" doing all the start-of-game and end-of-game stuff?
16:20:42 <newsham> phila: he hasnt moved it out yet.
16:21:16 <noobie> it loops the game 8 times
16:21:56 <Philippa_> as in, it plays entire games of Mastermind, 8 times? Complete with welcome message and everything?
16:22:10 <Philippa_> if not, what do you want it to do?
16:22:12 <oerjan> noobie: i suggest you make a singleGame function which handles all the setup and ending for a single game
16:22:30 <Philippa_> right, and then singleGame would call mmloop
16:22:43 <noobie> oh ok
16:23:13 <Philippa_> is haskell your first programming language? (HTML and the like don't count)
16:24:04 <noobie> yep
16:24:16 <noobie> i av to learn it for first yr
16:24:21 <dons> njbartlett: ?
16:24:30 <noobie> my teacher hardly comes to class
16:24:43 <noobie> and there is limited material on the web
16:24:57 <njbartlett> dons: Oh hi. Just reading your latest blog post... either gmane is broken at the moment or all your links are bad
16:25:00 <newsham> hardly anything about haskell on the web
16:25:14 <dons> mm
16:25:34 <noobie> newbie friendly that is
16:25:39 <Philippa_> be fair, the student's not just looking to learn haskell but programming as a whole
16:25:46 <Philippa_> most of our material's aimed at existing programmers
16:25:54 <dons> njbartlett: Warning: fopen(/var/tmp/weft/gmane/comp/lang/haskell/cafe/30685): failed to open stream: Input/output error in /home/httpd/gmane/news/wefta.php o
16:25:57 <dons> ?
16:26:00 <dons> njbartlett: looks like gmane is being stupid
16:26:06 <njbartlett> dons: Yeah that's what I'm getting too
16:26:12 <Philippa_> there's not a lot I'd show to eg my girlfriend to look through on her own
16:26:14 <njbartlett> dons: Okay. Maybe just temporary
16:26:20 <dons> hopefully
16:26:56 <resiak> @t Just "temporary"
16:26:56 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:27:00 <resiak> bah.
16:27:34 <njbartlett> dons: I've decided I really want a job doing Haskell :-) I guess Credit Suisse looks good but then I talked to Lennart he said they have a strong preference for people in NY
16:28:11 <newsham> if you wanna work for a big financial you'll prob be in NYC or london
16:28:19 <newsham> (or shanghai or tokyo or ...)
16:28:33 <njbartlett> newsham: London's no problem, that's where I am....
16:28:37 <noobie> i built the game and it as a single turn how do i make it call mmloop
16:28:43 <noobie> ??
16:28:48 <jsedgwick> hey, what do you guys recommend as a haskell tutorial? I know C/C++, Java, and Perl pretty well, but this is my first functional languages. the tutorial should be good witrh the foreign concepts of haskell...
16:28:55 <njbartlett> newsham: But Credit Suisse want Haskell hackers in NY
16:29:17 <noobie> coulde i put mmloop tries at the end
16:29:21 <Philippa_> noobie: you need to give us more information about what you've done, your questions assume too much context
16:29:39 <Philippa_> however, let's ignore your code for a moment... can you tell me in english what you want your program to do?
16:29:49 <EvilTerran> @go haskell for c programmers
16:29:49 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
16:29:49 <lambdabot> Title: Haskell for C Programmers
16:29:57 <EvilTerran> jsedgwick, that might be worth a look
16:30:40 <jsedgwick> i made it through YAHT up to CPS, which baffled me.
16:30:59 <newsham> nj: have you tried other financials?  like goldman/sachs?
16:31:18 <Philippa_> CPS confuses a lot of people, it's a strange concept
16:31:32 <njbartlett> newsham: I used to work at Goldman Sachs. They don't use any Haskell. They do have a couple of languages they invented themselves though
16:31:34 <resiak> seems like just about every Haskelly jobvert either requires a PhD or is for a PhD :)
16:32:04 <EvilTerran> njbartlett, home-brew langauges? sounds delightful =/
16:32:28 <njbartlett> EvilTerran: Yup. The main one is called Slang. It looks like a cross between Perl and C++
16:32:37 <njbartlett> Oh and they have their own database as well
16:32:48 * EvilTerran runs away screaming
16:33:05 <noobie> i want my program to play a game of mastermind. a random code is drawn from a text file and used as the "secret code" for the game. the user will then have 8 tries in which to solve the game. if he fails upon the 8 tries been completed to crack the "secret code" he is asked if he want to continue and the process should be restart. my code works fine, but only that a new "secret code" is generated everytime the game loops. i don't want that!!
16:33:25 <Botje> noobie: can you put your code on hptaste?
16:33:26 <firefly> CPS is not all that hard.  You might even say that "return" is an explicit instruction for invoking the continuation ;)
16:33:28 <Botje> -t
16:33:43 <newsham> botje: its there already
16:33:56 <firefly> the continuation is even passed on the stack and everything (or in a register on a typical RISC)
16:33:57 * EvilTerran likes hptaste
16:33:57 <oerjan> noobie: put the things that should be done only once per game in a function other than mmloop
16:33:58 <Philippa_> noobie: okay, you've missed a number of things out there. For example, what about the welcome message?
16:34:05 <EvilTerran> goes well in sauce form on chips ;)
16:34:09 <Botje> oh. that'll teach me not to scroll up. sorry
16:34:40 <firefly> njbartlett: can I help you with CPS?
16:34:42 <Philippa_> I *think* what you want to do is: Print a welcome message, generate a code. Then, play turns until you've run out or the user's quit, possibly print a message, quit. We'll ignore the details of how to play a turn for now...
16:34:56 <noobie> my classmates are trying to steal my work so i rather not
16:35:00 <noobie> sorry
16:35:05 <njbartlett> firefly: Nope, but maybe you can help jsedgwick
16:35:09 <Philippa_> how would you write that as a haskell function? Assume you've got "generate code" and "play a turn" as functions
16:35:13 <firefly> sorry ;)
16:35:21 <firefly> jsedgwick:  can I help you with CPS?
16:35:23 <Philippa_> don't worry about classmates stealing code. Worry about getting your own code right
16:35:25 <noobie> ithey googled my first paste and used it
16:35:42 <newsham> lucky for you your first paste was wrong ;-)
16:35:44 * EvilTerran found his rudimentary knowledge of CPS very handy when it came to trying to translate an imperative program into CSP
16:35:47 <jsedgwick> well hold the phone a second, i haven't looked at yaht for a month or so. let me brush up to that point
16:36:10 <EvilTerran> noobie, so? it's not your problem if they're cheating themselves out of a proper education
16:36:22 <noobie> haha
16:36:22 <firefly> ok.  I'll probably go to bed soon, though.  Be back tomorrow.
16:36:53 <noobie> haha
16:37:20 <newsham> perhaps noobie misunderstands school
16:37:27 <firefly> noobie: it really seems like you are trying too much in one go.
16:37:30 <noobie> write what?
16:37:37 <firefly> Try getting iteration right in isolation, for example.
16:38:03 <newsham> [14:33] < Philippa_> I *think* what you want to do is: Print a welcome message, generate a code. Then, play turns until you've run out or the user's quit, possibly print a message, quit. We'll ignore the details of how to play a turn for now...
16:38:08 <newsham> [14:33] < Philippa_> how would you write that as a haskell function? Assume you've got "generate code" and "play a turn" as functions
16:38:31 <noobie> my teach thing we r geniuosed
16:38:44 <noobie> r genious
16:38:45 <EvilTerran> please try to take a little more care over your typing
16:38:50 <noobie> hardly come to class
16:39:05 <firefly> spellinkz and gramma.  want.
16:39:15 <newsham> noobie: thats not relevant to this problem :)
16:39:17 <EvilTerran> if that bothers you, tell him/her; send him an email or something.
16:39:21 <noobie> sorry my keyboard is failing from too much beating
16:39:44 <EvilTerran> but don't let it stop you using hpaste ;)
16:40:10 <noobie> @commands
16:40:10 <lambdabot> Unknown command, try @list
16:40:15 <noobie> @list
16:40:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:41:36 <jsedgwick> firefly: yikes, i don't remember much
16:41:52 <noobie> Philippa_ what function sould i write?
16:42:05 <jsedgwick> firefly: perhaps we can begin with why foldl doesn't work on infinite lists and foldr does?
16:42:23 <firefly> noobie: can you write a simple iteration?  say, a function that prints something 10 times?
16:42:43 <newsham> ff: we should let phila drive
16:44:14 <ddarius> That could be harmful to noobie's health.
16:44:57 <firefly> http://cale.yi.org/index.php/Fold_Diagrams
16:44:58 <lambdabot> Title: Fold Diagrams - CaleWiki
16:45:36 <Philippa_> heh. Nah, I'm being reasonably polite today
16:46:16 <Philippa_> noobie: start by doing the 'outermost' function - the one that prints the messages, grabs the code, starts the loop going then quits when the loop's done
16:46:19 <hpaste>  noob pasted "loop" at http://hpaste.org/4076
16:46:23 <Philippa_> assume you've got another function to "grab the code"
16:46:31 <noobie> yes
16:46:46 <noobie> firefly
16:46:48 <firefly> Philippa_: I think you are driving too fast.  Way too fast.
16:46:49 <Philippa_> noobie: a variant on your loop - instead of checking for 1 and printing one last time, check for 0 and return
16:46:49 <ddarius> Philippa_: Right now you are.
16:47:30 <Philippa_> people do things that way because you don't have to write the bit about printing twice so you can't get two different versions
16:47:37 <Philippa_> ddarius: I'll hand over if I start losing it
16:47:38 <newsham> phila: i think he was referring to your driving skills. ;-)
16:47:41 <firefly> jsedgwick: err??  they both try to consume the whole list, don't they?  which is a problem with infinite lists.
16:47:44 <ddarius> Philippa_: Yeah, I know.
16:48:10 <ddarius> newsham: If that was in reference to my comment, Philippa interpreted correctly.
16:48:14 <jsedgwick> that's what i thought
16:48:14 <ddarius> +it
16:48:19 <jsedgwick> but yaht says:
16:48:21 <jsedgwick> NOTE foldl is often more efficient than foldr for reasons that
16:48:21 <jsedgwick> we will discuss in Section 7.8. However, foldr can work on infinite
16:48:21 <jsedgwick> lists, while foldl cannot. This is because before foldl does anything,
16:48:21 <jsedgwick> it has to go to the end of the list. On the other hand, foldr
16:48:21 <jsedgwick> starts producing output immediately. For instance, foldr (:) []
16:48:22 <jsedgwick> [1,2,3,4,5] simply returns the same list. Even if the list were infinite,
16:48:24 <jsedgwick> it would produce output. A similar function using foldl would
16:48:26 <jsedgwick> fail to produce any output.
16:48:28 <jsedgwick> oh crap, my bad
16:48:54 <ddarius> foldl' is good for something, foldr for others, they aren't really in competition.  foldl is mostly a piece of junk
16:48:54 <firefly> oh, that's what you mean :)
16:49:15 <Philippa_> noobie: if you follow what I'm suggesting you're going to end up with at least three functions by the way - one that runs a whole game, one that does the turn-by-turn loop and one that creates the code
16:49:41 <Philippa_> the reason for that is that when I asked you to write the "whole game" function, "create the code" and "run the loop" were single items to be done
16:50:01 <jsedgwick> firefly: i don't understand that passage. probably should have pastebinned, my bad
16:50:03 <Philippa_> the rule of thumb is that if you can think of something as an item on a to-do list, it probably wants to be a function
16:50:08 <noobie> ok
16:50:13 <Philippa_> that is, you want to have a name for it
16:50:20 <firefly> jsedgwick: Cale's diagrams help a lot.  The depth of the right side of the diagram parallels the stack depth of the recursion before it can construct anything.
16:50:24 <Philippa_> brb - have a go at that outermost function?
16:50:25 <Botje> WorldDomination :: IO ()
16:50:41 <Botje> except that W should be a w. bah
16:51:00 <EvilTerran> jsedgwick, foldr f e [1..] = 1 `f` foldr f e [2..] = 1 `f` (2 `f` foldr f e [3..]) = ..., so, if f discards its second parameter on one occasion, the remainder of those recursive foldrs are never evaluated
16:51:22 <noobie> ok
16:51:49 <EvilTerran> foldl f e [1..] = foldl f (e `f` 1) [2..] = foldl f ((e `f` 1) `f` 2) [3..] = foldl f (((e `f` 1) `f` 2) `f` 3) [4..] = ...
16:52:14 <EvilTerran> so foldl keeps expanding to just another application of foldl 'til it's exhausted its list, which, in the case of an infinite list, is never
16:52:52 <EvilTerran> slightly counter-intuitively, tail recursion is often a bad thing in a lazy language
16:52:56 <ddarius> foldl c n (x:xs) = foldl c (c x n) xs -- if all there are are conses ((:)s) then you never do anything but immediately recurse
16:53:15 <firefly> yep.  Whether using foldr will buy you anything (= will start producing output as it goes) depends on what function you pass it.
16:54:15 <EvilTerran> tail-recursion means that the base case must be reached before even a partial value can be computed, while non-tail-recursion leaves stuff around the recursive call that can be evaluated *before* the recursion is done
16:54:18 <firefly> (+) will really need both operands to be evaluated so foldr with that won't terminate.  : doesn't need the right operand to be evaluated so it goes fine with infinite lists.
16:54:52 <Philippa_> back
16:55:34 <EvilTerran> (\x y -> if p x then x else y) *sometimes* needs its second operand evaluated, but sometimes doesn't
16:55:42 <EvilTerran> depending on p
16:56:23 <EvilTerran> > foldr (\x y -> if x^2 >= 200 then x else y) undefined [1..]
16:56:25 <lambdabot>  15
16:57:49 * firefly wonders how much compiler smarts that took!
16:58:03 <ddarius> firefly: ?
16:59:26 <jleedev> > head $ foldr1 (:) [1..]
16:59:26 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
16:59:26 <lambdabot>       Expected...
17:00:02 <ddarius> :t foldr1
17:00:03 <ddarius> :t (:)
17:00:09 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
17:00:09 <lambdabot> forall a. a -> [a] -> [a]
17:00:12 <jleedev> ah
17:01:15 <firefly> ddarius: that the compiler knows there is a fixpoint there so it should stop looping.
17:01:36 <firefly> (or recursing, whatever)
17:03:34 <newsham> why does the compiler have to know?
17:03:35 <ddarius> firelfly: It just applies the definition of foldr in normal order as per the language spec.
17:04:04 <noobie> how do u pin someone?
17:04:13 <noobie> ping someone?
17:04:23 <newsham> ?seen noobie
17:04:23 <lambdabot> noobie is in #haskell. I last heard noobie speak 10s ago.
17:04:25 <newsham> like that?
17:04:40 <firefly> and at some point the result doesn't change and keeps being 15.  At that point it stops feeding more integers from the list into the function and returns.  I think that's neat.
17:05:03 <noobie> no i mean ip address
17:05:04 <jleedev> > if True then "done evaluating" else undefined
17:05:04 <lambdabot>  "done evaluating"
17:05:53 <ddarius> firefly: Integers aren't being "fed in", they are being "pulled out".  If the function doesn't ask for any more then no more are generated.
17:06:02 <ddarius> firefly: The compiler does no reasoning whatsoever.
17:06:08 <newsham> ff: it doesnt have to know any more than factorial in C requires the compiler to know that recursion terminates
17:06:18 <firefly> but there was also a fold on a list involved.  The fold does stop (the program terminated).
17:06:45 <ddarius> firefly: Just apply the definition of foldr mechanically.
17:07:00 <newsham> > foldr (\x y -> if x^2 >= 200 then x else y) undefined 100
17:07:02 <lambdabot>   add an instance declaration for (Num [a])
17:07:12 <newsham> > foldr (\x y -> if x^2 >= 200 then x else y) undefined [100...]
17:07:12 <lambdabot>  Parse error at "]" (column 62)
17:07:16 <newsham> > foldr (\x y -> if x^2 >= 200 then x else y) undefined [100..]
17:07:17 <lambdabot>  100
17:07:20 <newsham> ?src foldr
17:07:20 <lambdabot> foldr k z xs = go xs
17:07:20 <lambdabot>     where go []     = z
17:07:20 <lambdabot>           go (y:ys) = y `k` go ys
17:07:53 <newsham> go (100:101:102:...) = k 100 (go (101:102:...))
17:08:19 <hpaste>  (anonymous) pasted "lisp to haskell?" at http://hpaste.org/4077
17:08:19 <newsham> if 100^2 >= 200 then 100 else (101:102:...)
17:08:21 <newsham> 200
17:08:26 <newsham> err 100
17:08:32 <ddarius> else go (101:102:...)
17:08:50 <newsham> else go, yes, oops
17:08:54 <dcoutts> @seen ndm
17:08:54 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 8h 7m 30s ago, and .
17:09:11 * dcoutts will see ndm talk on Monday in Oxford
17:09:11 <lambdabot> dcoutts: You have 4 new messages. '/msg lambdabot @messages' to read them.
17:09:13 <dcoutts> :-)
17:09:14 <EvilTerran> ''Integers aren't being "fed in", they are being "pulled out"''  <- ddarius++ , that's a great way of putting it
17:10:30 <resiak> dcoutts: is he talking in some context accessible to mere undergrads?
17:11:20 <fxr> who is asking the "lisp to haskell" question?
17:11:22 <Philippa_> dcoutts: that reminds me, did you make it to FitA? I missed it, wanted to see several of the talks too...
17:11:26 <dcoutts> resiak: accessible if you ask nicely :-)
17:11:42 <dcoutts> Philippa_: unfortunately not, I was teaching that afternoon
17:12:42 <Philippa_> dcoutts: shame. I think I was actually just asleep the whole afternoon :-(
17:12:57 <dcoutts> resiak: it'll be Monday at 4pm in room 441 on detecting pattern-match failures in Haskell.
17:13:24 <dcoutts> resiak: so you just need to persuade reception to let you in
17:13:50 <dcoutts> Philippa_: sleeping is a very sensible thing to do all afternoon :-)
17:14:52 <Philippa_> it's nice to have a choice in the matter though
17:15:04 <hpaste>  oerjan annotated "lisp to haskell?" with "thus" at http://hpaste.org/4077#a1
17:15:36 <dcoutts> Philippa_: true true
17:15:37 * dcoutts often naps under his desk after lunch
17:15:47 <dcoutts> hia waern
17:15:51 <waern> hi!
17:16:00 <dcoutts> waern: you're up late aren't you?
17:16:04 <dcoutts> @localtime waern
17:16:04 <lambdabot> Local time for waern is Sun Nov 25 02:16:04
17:16:22 <waern> dcoutts: yes :)
17:16:32 <Philippa_> dcoutts: sensible. Make productive use of the digestive torpor, kind of thing
17:17:03 <dcoutts> waern: we need to get in some more cabal make hacking next week, do you think you might have time/energy?
17:17:06 <hpaste>  ddarius annotated "lisp to haskell?" with "another two" at http://hpaste.org/4077#a2
17:17:24 <dcoutts> waern: I've decided I'm not satisfied with the current design of dynamic dependencies
17:17:34 <resiak> dcoutts: heh, d'oh, i'll be in 478 in a categories lecture :(
17:17:46 <dcoutts> resiak: oh that's a shame
17:17:49 <waern> dcoutts: sure, I don't have anything to do next week actually
17:17:58 <waern> dcoutts: I'm unemployed atm
17:18:09 <resiak> dcoutts: i wonder if i can convince nikos that he only needs one hour of the two hours allocated :)
17:18:13 <dcoutts> waern: good time to get hacking done, being unemployed :-)
17:18:19 <waern> yep :)
17:18:35 <dcoutts> being unemployed or being a PhD student ;-)
17:19:43 <EvilTerran> doesn't unemployment pay better?
17:20:20 <ddarius> EvilTerran: It certainly has nicer hours.
17:20:51 <Philippa_> EvilTerran: strictly speaking I'm probably receiving more money than some PhD students, but not PhD students who receive the same benefit I'd get whether I work or not
17:20:58 <Philippa_> I'm a special case though
17:21:13 <edwinb> when I was unemployed I had to get up as early as 10am once a fortnight to get benefits
17:21:17 <edwinb> it was awful, getting up that early
17:21:21 <ihope_> @docs
17:21:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:21:33 <EvilTerran> dcoutts, is that talk in the comlab?
17:21:41 <oerjan> ddarius: map abs is wrong there, it would give 43 rather than -43
17:22:23 <Philippa_> edwinb: it's definitely different if you're long-term disabled - far less messing about with JobCentres, though they mess you about more when they get the chance
17:22:40 <edwinb> it keeps them busy I suppose
17:23:04 <edwinb> although as far as I could tell they were busy enough fighting with people who couldn't be bothered to apply for jobs
17:23:08 <Philippa_> yeah. Much easier to chase honest people rather than the fraudulent, you get results that way
17:23:21 <Philippa_> they go for the IB crowd in writing instead
17:23:51 <dcoutts> EvilTerran: yep
17:23:54 <edwinb> the best they did for me was offer me a job in web design at minimum wage...
17:24:10 * EvilTerran makes a note
17:25:01 <Philippa_> edwinb: sucks, but it's what they're supposed to do in the short term
17:25:22 <Philippa_> thing is, the jobcentre won't get the high-paid stuff generally
17:25:25 <edwinb> well they knew perfectly well that it was a waste of time
17:25:28 <Philippa_> and the staff don't know where to look
17:25:46 <Philippa_> they wouldn't have a clue what to do with me if I started looking for part-time work that made use of my skills
17:38:05 <nburlett> hey all, I remember someone (dons?) having a program that would quick-start a cabal project
17:38:12 <nburlett> but I can't find it :-<
17:39:00 <Cale> http://www.cse.unsw.edu.au/~dons/code/mkcabal/
17:39:01 <lambdabot> Title: Index of /~dons/code/mkcabal
17:39:31 <nburlett> huzzay
17:39:33 <nburlett> thanks, Caelum
17:39:34 <nburlett> err
17:39:37 <nburlett> Cale
17:40:02 <nburlett> wow, the tab-completion should be a bit better about that
17:40:57 <mauke> upgrade to irssi :-)
17:41:21 <nburlett> hm... colloquy is a nice IRC program though
17:41:55 <ddarius> oerjan: Point.
17:42:19 <ddarius> @index maximumBy
17:42:19 <lambdabot> Data.List
17:42:28 <ddarius> :t maximumBy
17:42:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:42:51 <ddarius> :t Data.List.maximumBy
17:42:52 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:43:42 * ddarius thought there were two versions of maximumBy
17:43:55 <oerjan> what would the other do?
17:43:58 <ddarius> :t List.maximumBy
17:43:59 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:44:25 <ddarius> oerjan: One was \max -> foldr1 max
17:44:36 <oerjan> :t maximum
17:44:36 <lambdabot> forall a. (Ord a) => [a] -> a
17:44:37 <ddarius> If I remember correctly.
17:44:50 <oerjan> oh
17:45:06 <oerjan> um that would be just foldr1
17:45:37 <oerjan> @src maximum
17:45:37 <lambdabot> maximum [] = undefined
17:45:37 <lambdabot> maximum xs = foldl1 max xs
17:46:01 <oerjan> @src maximumBy
17:46:01 <lambdabot> Source not found. Are you on drugs?
17:46:37 <ddarius> I just remember two functions that were *By functions that took different arguments but were both in the hierarchical libraries.
17:48:35 <ddarius> @hoogle maximumBy
17:48:36 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
17:48:36 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
17:48:39 <ddarius> There we go.
17:48:47 <ddarius> I guess Hoogle's database is wrong.
17:48:56 <oerjan> oh
17:49:32 <nburlett> hoogle seems to be falling apart lately.. it never shows me the documentation for functions it finds
17:50:21 <Philippa_> the docs folder for 6.8.1 on windows seems to've changed, don't know about elsewhere
17:50:26 <shachaf> nburlett: That's probably because all the URLs changed since 6.8.
17:50:35 <oerjan> and the hierarchical libraries have stopped including source links.  IS THIS THE END?
17:50:43 <nburlett> also, grr.. mkcabal won't build on my system
17:50:58 <oerjan> *libraries page
17:51:11 <ddarius> The source links should come back.
17:51:27 <ddarius> Later or more later ndm will release Hoogle 4 and hopefully things will be better.
17:52:00 <oerjan> when at the most laterest?
18:09:21 <newsham> ?seen noobie
18:09:21 <lambdabot> noobie is in #haskell. I last heard noobie speak 1h 4m 18s ago.
18:15:52 <nburlett> ?seen alpheccar
18:15:52 <lambdabot> I haven't seen alpheccar.
18:16:58 <Philippa_> newsham: it went private a while back
18:17:18 <Philippa_> noobie's now got an outer loop (it asks if you want to play another game) and is getting the code fine and just needs to clear up the turn by turn loop
18:17:30 <Philippa_> I'll probably go to bed soon
18:19:15 <newsham> awesome
18:21:36 <Philippa_> better yet, noobie just spotted a function call with a missing parameter from the type error without being told
18:23:31 <Philippa_> I explained currying earlier, he wasn't sure about how to pass in multiple parameters because he'd realised the syntax is designed for single parm functions
18:23:36 <Philippa_> which is pretty smart in my book
18:26:01 <ddarius> We will probably see.
18:35:03 <ddarius> Why have I never heard of Piers Anthony if he's regarded as one of the most well-known science fiction/fantasy authors ever.
18:35:33 <mauke> because you're living in a cave
18:36:00 <noobie> just want to say thanks to everyone who helped me in the completion of this code
18:36:10 <noobie> u guys av been great help
18:36:38 <ddarius> noobie: Wait until you learn some other language and go to their IRC channels/mailing lists etc.
18:37:03 <noobie> better than any text, u r true teachers and great haskell programmers
18:37:11 <noobie> why u say that
18:37:24 * ddarius laughs.
18:37:34 <mauke> please stop saying "u" :(
18:37:56 <ddarius> noobie: You'll see one day.
18:38:12 <oerjan> noobie: apparently some other irc language channels are rather less friendly, i hear.  (never been to them myself)
18:39:48 <rue> ddarius: OT, Piers Anthony's most famous books are the Incarnations series ones. His problem is that while his basic ideas are fantastic, his microplotlines are horrible and he writes at the level of a six-year old
18:39:53 * rue lurks again
18:54:17 <ddarius> Anyone know a quick way to stick a bunch of pdf files together into one pdf file?
18:55:21 <shachaf> ddarius: Maybe http://ansuz.sooke.bc.ca/software/pdf-append.php can help?
18:55:21 <lambdabot> Title: How to concatenate PDFs without pain
18:56:20 <shachaf> ddarius: (I haven't tried it, though. Maybe also look at the comments.)
18:57:53 <ddarius> Looks like it could be useful.
18:58:28 <landijk> ?hoogle second
18:58:28 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
18:59:08 <ddarius> Though the author of the article, while recognizing postscript is a language (but unless I'm quite mistaken, PDF is a sub-Turing subset of it), doesn't understand the issue with writing a "psmerge program that would actually work".
19:00:43 <mwc> pdf is sort of like pre-interpreted ps,
19:01:12 <mwc> best bet is to use pdflatex, and include the pdf documents
19:01:24 <oerjan> > second (+1) (True, 5)
19:01:26 <lambdabot>  (True,6)
19:01:43 <EvilTerran> ddarius, i think, at least in theory, it should be possible to catenate arbitrary terminating postscript files fairly reasonably
19:01:56 <shachaf> PDF pages are independent of each other, right?
19:02:14 <shachaf> > fmap (+1) (True,5)
19:02:14 <lambdabot>  (True,6)
19:02:29 <EvilTerran> you'd need to re-bind a load of primatives after (or even before) running the first file, so the layouts were compatible, but it should work
19:03:24 <oerjan> > liftA2 (+) ("test",1) ("ing",2)
19:03:24 <lambdabot>  ("testing",3)
19:04:16 <EvilTerran> whaaa?
19:04:21 <oerjan> > liftM2 (+) ("test",1) ("ing",2)
19:04:21 <lambdabot>   add an instance declaration for (Monad ((,) [Char]))
19:04:21 <lambdabot>     In the expression:...
19:04:23 <shachaf> @src (,) pure
19:04:23 <lambdabot> pure x = (mempty, x)
19:04:24 <oerjan> bah
19:04:27 <shachaf> @src (,) (<*>)
19:04:27 <lambdabot> (u, f) <*> (v, x) = (u `mappend` v, f x)
19:04:33 <EvilTerran> looks like Writer...
19:04:48 <oerjan> yep, so why doesn't it have a monad instance too?
19:05:09 <EvilTerran> @instances Monad
19:05:09 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:05:48 <oerjan> (actually i was surprised the Applicative worked :) )
19:06:27 <EvilTerran> @src Writer
19:06:27 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:06:33 <EvilTerran> @unmtl Writer w a
19:06:34 <lambdabot> (a, w)
19:07:00 <EvilTerran> ... isn't that the wrong way 'round?
19:07:13 <oerjan> newtype Writer w a = Writer { runWriter :: (a, w) }
19:07:22 <oerjan> you might think so
19:07:31 <oerjan> otoh it is consistent with State
19:07:57 <EvilTerran> i thought it was supposed to effectively be "the (w,) monad"
19:08:12 <ddarius> It's isomorphic to (w,)
19:08:56 <EvilTerran> well, yes. seems funny to swap it over cf partially applying (,), though
19:09:13 <oerjan> newtype State s a = State { runState :: s -> (a, s) }
19:09:36 <oerjan> s -> (a, s) is very standard ordering
19:10:29 <oerjan> and if you drop one s, you get Writer or Reader
19:10:30 <ddarius> I view the w and the s as "side" information and the "fst" component as being more "important"
19:11:26 <noobie> hey guys i am commenting my code can i out in that a piece was contributed by #haskell, i don't like takin credit for people effort
19:12:04 <moconnor> Does anyone know of examples of creating a circular data structure in haskell of arbitrary size?
19:12:08 <moconnor> I see examples of doing it by hand, relying on laziness (e.g. x = Foo y; y = Foo x).  But it's not clear to me if it's possible to extend that technique to a circle of arbitrary size (e.g. 1->2->3...->n->1).
19:12:22 <EvilTerran> @src cycle
19:12:22 <lambdabot> cycle [] = undefined
19:12:22 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
19:12:23 <kpreid> moconnor: look at the 'cycle' function
19:12:28 <kpreid> > cycle [1,2,3]
19:12:29 <moconnor> kpreid: thank you!
19:12:29 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
19:12:41 <kpreid> you can do other-than-lists the same way
19:13:16 <kpreid> generally, you need to carry the root of the structure along to the cyclic leaves
19:13:42 <kpreid> 'cycle' does that by passing xs' to ++, and ++ does the carrying along to its second argument
19:13:52 <moconnor> kpreid: How do I find how cycle is implemented?
19:14:03 <kpreid> @src cycle
19:14:03 <lambdabot> cycle [] = undefined
19:14:03 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
19:14:09 <moconnor> oh, I missed that
19:14:11 <kpreid> @src ++
19:14:11 <lambdabot> (++) []     ys = ys
19:14:11 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:14:30 <EvilTerran> @src (:)
19:14:30 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:14:35 <EvilTerran> :P
19:14:48 <ddarius> @src []
19:14:48 <lambdabot> data [] a = [] | a : [a]
19:14:48 <TSC> Would it be equivalent if it was "cycle xs = xs ++ cycle xs" ?
19:15:01 <ddarius> TSC: Yes and no and maybe.
19:15:04 <TSC> Thanks
19:15:05 <TSC> (:
19:15:08 <TSC> Sharing differences?
19:15:09 <kpreid> TSC: Depends on the implementation's optimizer.
19:15:16 <kpreid> Yeah.
19:15:32 <ddarius> TSC: Yes semantically, no as most implementations would share the former but not the latter, maybe as the standard doesn't actually specify any sharing semantics.
19:15:36 <kpreid> If there's a let/where, it's going to be shared in any sane implementation. If not...
19:16:07 <TSC> Might the second version produce stack overflow too?
19:16:26 <ddarius> No
19:16:27 <kpreid> No.
19:16:58 <TSC> Ok, thanks
19:17:10 <oerjan> > fix ("cycle "++)
19:17:10 <lambdabot>  "cycle cycle cycle cycle cycle cycle cycle cycle cycle cycle cycle cycle cyc...
19:17:19 <ddarius> The old TyingTheKnot page was good, but it's not up anymore.
19:17:30 <ddarius> You can find outdated versions of it several places.
19:17:45 <Olathe> @src fixb
19:17:46 <lambdabot> Source not found. stty: unknown mode: doofus
19:17:47 <Olathe> @src fix
19:17:47 <lambdabot> fix f = let x = f x in x
19:17:47 <oerjan> TSC: fix might be useful for other things than lists too
19:18:13 <Olathe> How does it get the base case ?
19:18:29 <ddarius> Olathe: "base case"?
19:18:31 <oerjan> it doesn't
19:18:37 <oerjan> it never reaches it
19:18:45 <ddarius> There isn't a base case to reach.
19:19:05 <Olathe> @src (++)
19:19:05 <lambdabot> (++) []     ys = ys
19:19:05 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:19:16 <davidL> @type fix
19:19:16 <Olathe> Ahh.
19:19:17 <lambdabot> forall a. (a -> a) -> a
19:19:24 <Olathe> > fix (++"cycle")
19:19:25 <lambdabot>  Exception: <<loop>>
19:20:29 <oerjan> general rule: fix f = undefined <=> f undefined = undefined
19:21:09 <ddarius> clearly, is fix f = f (fix f)
19:21:15 <ddarius> s/is/as
19:21:40 <oerjan> that gives you =>
19:21:50 <ddarius> True.
19:22:03 <oerjan> the other direction is more subtle
19:22:08 <shachaf> Is there a reason Control.Monad doesn't have the (w,) instance?
19:22:29 <oerjan> too old?
19:23:12 <oerjan> otoh why it's not in Control.Monad.Instances i don't know
19:25:28 <oerjan> also Control.Monad.Instances seems to be the general place for extra Functor and Monad instances for h98 types
19:31:40 <hpaste>  jonpv annotated "wtfomgnoes" with "notagain" at http://hpaste.org/4078#a2
19:35:01 <monochrom> Haha, the optimal party problem.
19:35:33 <EvilTerran> ah, yes. i'm helping the guy in another channel (on another network, even)
19:35:49 <EvilTerran> i suggested hpaste 'cos of its nifty syntax highlighting :)
19:36:24 <monochrom> hpaste is the only appropriate pastebin for haskell code. all other pastebins are inferior.
19:37:32 <hpaste>  jonpv annotated "wtfomgnoes" with "now it works" at http://hpaste.org/4078#a3
19:38:59 <chessguy> 'evening fellow haskellers
19:40:04 <chessguy> @seen osfameron
19:40:04 <lambdabot> osfameron is in #haskell. I last heard osfameron speak 1d 11h 57m 21s ago.
19:40:48 <landijk> Would anyone like to discuss http://www.haskell.org/haskellwiki/Blow_your_mind ?  I think I've found a problem with one of the examples, but I'm not sure the best way to fix it.
19:40:49 <lambdabot> Title: Blow your mind - HaskellWiki
19:41:41 <oerjan> which example?
19:41:50 <landijk> There seems to be a bug in example 2, which is supposed to be equivalent to "words," but it doesn't handle leading or trailing whitespace properly.
19:42:07 <landijk> >words "  a bcd e   "
19:42:24 <jonpv> sorry if i forgot to uncheck 'announce'
19:42:37 <chessguy> landijk, you need a space after the >
19:42:48 <landijk> > words "  a bcd e   "
19:42:50 <lambdabot>  ["a","bcd","e"]
19:43:10 <landijk> > unfoldr (\b -> fmap (const . (second $ drop 1) . break (==' ') $ b) . listToMaybe $ b) "  a bcd e   "
19:43:11 <lambdabot>  ["","","a","bcd","e","",""]
19:44:05 <landijk> Obviously you could just filter ""
19:44:06 <oerjan> > fmap (const . (second $ drop 1) . break (==' ') $ b) . listToMaybe $ "  a bcd e   "
19:44:07 <lambdabot>   Not in scope: `b'
19:44:27 <oerjan> > (\b -> fmap (const . (second $ drop 1) . break (==' ') $ b) . listToMaybe $ b) "  a bcd e   "
19:44:27 <lambdabot>  Just (""," a bcd e   ")
19:44:49 <ddarius> @pl \x -> [1+x,1%(x+1)]
19:44:49 <lambdabot> liftM2 (:) (1 +) (return . (1 %) . (1 +))
19:45:28 <oerjan> @pl \x -> [x, 1%x]
19:45:28 <lambdabot> ap (:) (return . (1 %))
19:45:45 <ddarius> > fix ((1:) . (>>= \x -> [1+x,1%(1+x)]))
19:45:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = Ratio a
19:45:45 <lambdabot>       Expe...
19:46:04 <ddarius> > fix ((1:) . (>>= \x -> [1+x,1/(1+x)]))
19:46:04 <lambdabot>  [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.333333...
19:46:14 <ddarius> > fix ((1:) . (>>= \x -> [1+x,1/(1+x)])) :: [Rational]
19:46:14 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
19:46:36 <dons> haskell rocks my world
19:46:53 <chessguy> join the crowd :)
19:52:52 <ddarius> Good 'ole Polya
19:55:12 <landijk> It seems to me that if you've decided to use unfoldr with break (==' '), there's no getting around adding a check for leading whitespace, and that sort of ruins the one-liner-ness.  Perhaps, on the other hand, someone sees something I don't.
19:56:17 <thoughtpolice> hm, asking again: with cabal 1.2, how can you specify that an executable depends on a library that's also built in the same package?
19:56:26 <chessguy> you could always do dropWhile (== ' ') . unfoldr...
19:56:37 <chessguy> err
19:56:41 <chessguy> other way 'round
19:57:18 <chessguy> it's the trailing whitespace that's the problem
19:59:05 * ddarius hugs von Neumann
19:59:25 <chessguy> > takeWhile (not . null) . unfoldr (\b -> fmap (const . (second $ drop 1) . break (==' ') $ b) . listToMaybe $ b) . dropWhile (== ' ') $ "  a bcd e   "
19:59:26 <lambdabot>  ["a","bcd","e"]
19:59:34 <chessguy> yay for inefficient hacks
20:01:18 <chessguy> ddarius, nice to see you getting over your necrophobia
20:02:11 <landijk> It doesn't look like there is any circumstance in which "words" is supposed to return a list containing an empty string, so I guess simply post-processing the result is the best idea
20:02:25 <ddarius> chessguy: At least I have high standards.
20:02:27 <dobblego> ?type words
20:02:28 <lambdabot> String -> [String]
20:02:44 <ddarius> > words []
20:02:44 <lambdabot>  []
20:02:47 <dobblego> ?check \xs -> not (null (words xs))
20:02:49 <lambdabot>  Falsifiable, after 1 tests: ""
20:02:59 * ddarius misread.
20:03:34 <ddarius> @check all (not . null) . words
20:03:35 <lambdabot>  OK, passed 500 tests.
20:03:47 <ddarius> Pretty point-free code
20:09:16 <nburlett> :t all
20:09:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:09:30 <nburlett> :t xs -> not (null (words xs))
20:09:31 <lambdabot> Parse error in pattern
20:09:38 <nburlett> :t \xs -> not (null (words xs))
20:09:39 <lambdabot> String -> Bool
20:09:41 <oerjan> Johansen is no. 2 on the list
20:09:48 <oerjan> wrong channel
20:09:55 <dons> heh
20:10:14 <dons> i think you mean `Johansson'
20:10:28 <dons> :P
20:10:31 <oerjan> not in Norway
20:10:43 <dons> (i know, teasing ;)
20:11:13 <chessguy> @type all (not . null) . words
20:11:14 <lambdabot> String -> Bool
20:15:44 <Olathe> @src null
20:15:45 <lambdabot> null []     = True
20:15:45 <lambdabot> null (_:_)  = False
20:17:41 <dobblego> heh, who wrote that source?
20:18:06 <dobblego> I thought I was the only one who does crazy things like that
20:18:24 <sjanssen> probably the Haskell '98 committee
20:18:41 <oerjan> what's crazy about it?
20:18:43 <chessguy> dobblego, what's wrong with that?
20:18:52 <dobblego> sorry, non-overlapping pattern I mean
20:18:54 <dons> the report does things differently
20:18:58 <chessguy> i guess you can write null _ = False
20:18:59 <dobblego> as opposed to null _ = False
20:19:19 <dons> actually even ghc uses that
20:19:26 <dons> however, i suspect it doesn't matter :)
20:19:56 <P_D> somebody wanted to test out infix constructors on the lhs?
20:23:24 <oerjan> i understand it all gets turned into non-overlapping patterns in the STG anyway
20:43:27 * SamB wonders why the heck people are still using TTF and not type1 outlines in OpenType fonts, if everything since win2k supports that...
20:56:22 <Lycurgus> SamB: maybe because they have trusty collections of TTFs for all occasions.
21:23:50 <mwc> Lycurgus, rubbish. The only font anyone ever needs is computer modern
21:24:05 <mwc> along with their preferred monospace font. I like bitstream vera sans mono myself
21:44:58 <chessguy> so i have this wierd idea, and not a clue how to go about it
21:45:22 <mwc> just make sure you use sufficient lubricant, and it shouldn't be a problem
21:46:11 <chessguy> i'm wondering if one could write soemthing on top of QuickCheck's Arbitrary, which would let you derive arbitrary instances which meet certain conditions
21:46:34 <dons> sure
21:46:47 <dons> oh, 'instances' ?
21:46:58 <chessguy> like, say, i want to be able to generate random Tree Ints where every node has at least 6 children
21:47:09 <chessguy> or no more than 60% of the nodes have less than 2 children
21:47:11 <chessguy> etc.
21:47:54 <waern>  chessguy: fredrik lindblad has made something similar where data is generated from preconditions
21:48:09 <waern> chessguy: but that is outside Haskell
21:48:10 <dons> you can do that with just normal Arbitrary though
21:48:23 <dons> the distribution of values and so on
21:49:53 <chessguy> dons, what about being able to also specify specific things, like "there must be some node in the tree where the rootlabel is 5, and it has a child whose rootlabel is 6, the rest of the tree is arbitrary
21:49:57 <chessguy> waern, link?
21:50:15 <waern> I'm trying to find it...
21:51:03 <ddarius> @src Arbitrary
21:51:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:51:25 <dons> chessguy: you can filter any elements you want from arbitrary values, at construction
21:51:43 <chessguy> ...
21:51:48 <waern> chessguy: cs.shu.edu/tfp2007/drafts/71.pdf
21:51:50 <dons> assuming you can write haskell code to check the condition
21:51:56 <hoelzro> does anyone know of a good way to convert between Int32 and Word32?  I can't seem to find the right functions...
21:52:00 <dons> fromIntegral
21:52:15 <dons> > (fromIntegral (-1) :: Int32) :: Word32
21:52:16 <lambdabot>  Couldn't match expected type `Word32' against inferred type `Int32'
21:52:23 <dons> > fromIntegral ((-1) :: Int32) :: Word32
21:52:24 <lambdabot>  4294967295
21:52:28 <chessguy> dons, you lost me
21:52:29 <hoelzro> oh geez
21:52:31 <hoelzro> thanks
21:52:35 * ddarius again suggests a simple lambdabot plugin to answer such questions.
21:52:37 <hoelzro> should have checked Prelude =P
21:52:44 <chessguy> waern, thanks
21:53:00 <chessguy> @where lambdabot
21:53:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:53:08 <chessguy> ^^ ddarius, start hacking
21:53:20 <chessguy> if you even manage to compile it :)
21:53:31 <ddarius> chessguy: Why would I need to compile it?
21:54:20 <waern> chessguy: this stuff might be relevant as well http://www-users.cs.york.ac.uk/~mfn/reach/index.html
21:54:20 <lambdabot> Title: Reach
21:55:08 <chessguy> waern++
21:55:13 <chessguy> ddarius, testing?
21:58:27 <waern> chessguy: actually this: http://www-users.cs.york.ac.uk/~mfn/sparsecheck/index.html might be even more relevant
21:58:28 <lambdabot> Title: SparseCheck
21:58:40 <waern> that's what I was looking for
22:01:26 <waern> it has the advantage of being a Haskell library
22:02:13 <chessguy> hmm, looks interesting
22:02:22 <chessguy> looks like i've got some reading to do :)
22:06:46 <ddarius> chessguy: I'm fairly confident I could correctly write this code the first time.
22:07:49 <chessguy> ddarius, go for it then. personally i would never write code without compiling it
22:08:07 <Brian`> hey, is there a library that reads xml file(single line) and pretty print?
22:08:09 <chessguy> http://blog.kickin-the-darkness.com/2007/09/confessions-of-terrible-programmer.html
22:08:11 <lambdabot> Title: Kickin' the Darkness: Confessions of a Terrible Programmer, http://tinyurl.com/2qrv5a
22:08:20 <chessguy> i most certainly am a terrible programmer
22:14:06 * wli rematerializes from an Ubuntu LiveCD.
22:14:31 <mwc> wli, I've been there before, when my HD crashed in January
22:21:36 <goalieca> solid state disks scare me
22:22:35 <mwc> really? I can't imagine how mechanically positioning a head over a rapidly spinning disk could ever work
22:22:40 <Philippa> yeah? Write limit, by any chance? Do the maths on how long it actually takes to burn the modern ones out, it's long enough for most uses
22:23:12 <wli> Use the solid state bits as a giant cache. Blah blah blah.
22:23:23 <mwc> plus I'm sure that SSHDs have load-levelling logic internally
22:23:30 <mwc> so you don't have to worry about FS hotspots
22:24:36 <Philippa> yeah, they do. So between that and 100,000 writes actually taking quite some time, you can happily use them for swap and still expect the comp in question to last years in a lot of situations
22:24:50 * Philippa is looking at picking up an Eee PC sometime, they've only got flash storage
22:26:13 <rue> Style question.. am I considered a neanderthal for using explicit braces rather than $? Should I just get with the times?
22:26:52 <Cale> Hm? Braces instead of $
22:27:00 <Cale> Do you mean braces instead of layout?
22:27:00 <rue> Erm, parentheses
22:27:03 <Cale> Ah
22:27:21 <Cale> No, but it's often a good idea to use (.) and some ($)
22:27:30 <thoughtpolice> i wouldn't call you a 'neanderthal' for using parenthesis, if that's what you mean
22:27:41 <Cale> f . g . h $ x
22:27:46 <Olathe> If you aren't using your $, send it to me. PayPal.
22:27:46 <Cale> Is the same as
22:27:53 <Cale> f (g (h x))
22:28:12 <Olathe> Hmm, I like that.
22:28:20 <Olathe> I've been doing it with f $ g $ h $ x
22:28:29 <Philippa> I don't so much because it doesn't play neatly with multi-parm functions
22:28:33 <Olathe> Quite ugly.
22:28:34 <Cale> Olathe: it's good to avoid multiple $'s in a row like that
22:28:39 <rue> Yeap. It may be just me but it seems that ($) has become more prevalent since I last did anything more involved
22:28:45 <thoughtpolice> on the other hand you wouldn't exactly be the most sophisticated person ever for superfluous use of $
22:29:10 <Cale> Olathe: the way with function composition has the advantage that g . h is still a meaningful expression, but g $ h most likely is not
22:29:11 <mwc> I tend to find f . g . h $ x scans very nicely
22:29:24 <rue> thoughtpolice: Darn, I thought THIS would surely be my angle to get in that group :)
22:29:30 <thoughtpolice> normally I find myself doing (f . g . h) x personally
22:29:49 <Cale> thoughtpolice: yeah, that works well also :)
22:29:57 <nornagon> i prefer the . . . $ style myself
22:30:03 <mwc> hahaahah
22:30:16 <rue> nornagon, Olathe: Hiya!
22:30:21 <Olathe> rue: Hello :)
22:30:25 <nornagon> rue: :)
22:30:29 <mwc> We've reinvented a style religion war as silly as the One True C/C++/Java/C# brace-indent style
22:30:47 <nornagon> another ruby convert! (unless I'm much mistaken?)
22:30:51 <rue> Hehe. Alright, thanks for the pointeroos. I hereby decree all styles are just as good
22:31:39 <thoughtpolice> :)
22:31:45 <Olathe> Ambiguity: The best style is completely pointless.
22:31:49 <Philippa> the . . $ is nicer than $ $ $ IMO because you get a nice distinction between "the function" and the parameter
22:31:57 <mwc> actually, there's some truth to what cale mentioned about g . h being meaninful and g $ h not being
22:32:03 <rue> nornagon: Have not had any time for .hs in a good while, mostly consumed by ruby/rubinius
22:32:13 <nornagon> ah :)
22:32:30 <thoughtpolice> personally I don't like using $ if i'm doing function composition. doing f . g . h $ x doesn't sit well with me.
22:32:41 <thoughtpolice> i might just be clinically insane, though.
22:32:49 <ddarius> (Cale's ulterior motive for promulgating the ...$ style is his hopes that one day $'s associativity will be swapped and this minimizes code that would need to be changed.)
22:33:00 <Cale> hehe :)
22:33:12 <Cale> Well, not my only reason, but it's one :)
22:33:24 <nornagon> ech
22:33:31 <shachaf> Cale: Can you give an example of the advantage of making $ infixl?
22:33:35 <Cale> Sure
22:33:36 <nornagon> associativity is hard enough to remember when it *doesn't* change
22:33:43 <thoughtpolice> left associative? :)
22:33:47 * shachaf is undecided about that.
22:33:59 <Cale> f (g x) (h y) -- try removing the parens from this
22:34:23 <Cale> If ($) was infixl, like function application already is,
22:34:28 <nornagon> f . g x $ h y?
22:34:45 <Cale> nope
22:34:47 <nornagon> oh, hm
22:34:47 <mwc> f $ g x $ h y = (f (g x)) (h y) with left associative $
22:34:55 <mwc> it would be the greatest thing ever
22:35:17 <Cale> mwc: right
22:35:24 <mwc> no, left
22:35:40 <Cale> mwc: hehe
22:35:51 <Cale> (I meant 'correct' of course :)
22:35:57 <mjrosenb> what is $?
22:36:02 <Olathe> @src $
22:36:02 <lambdabot> f $ x = f x
22:36:02 <ddarius> @src ($)
22:36:02 <lambdabot> f $ x = f x
22:36:02 <dmwit> f $ x = f x
22:36:07 <shachaf> mjrosenb: Function application.
22:36:08 <Olathe> Heh
22:36:10 <dmwit> Just a fancy way of doing function application.
22:36:16 <ddarius> ($) = id
22:36:31 <thoughtpolice> so rather than having f $ h $ g $ x -> f (h (g x)) you'd have it ((f h) g) x? it does seem somewhat counter intuitive when application is to the left, but say, types and $ associate to the right
22:36:36 <Cale> Function application is normally left associative too. So it would make a heck of a lot more sense to make ($), its representative as an operator left associative as well.
22:36:54 <Cale> thoughtpolice: right.
22:37:08 <mjrosenb> oic
22:37:15 <mjrosenb> yay for syntatic sugar
22:37:22 <Philippa> thoughtpolice: the difference between application and -> is there for a reason though
22:37:31 <Cale> mjrosenb: Of course, it's just an ordinary function defined in the Prelude.
22:38:00 <mjrosenb> Cale: yeah, not hard to define either
22:38:02 <shachaf> This would also make $! infixl, which would probably be nice.
22:38:13 <Cale> f $ h $ g $ x would be the same as f h g x, but ($) would still have really low precedence, so f . h . g $ x would still mean f (h (g x))
22:38:24 <Olathe> g x `f` h y
22:38:37 <chessguy> @pl \ f x -> f x
22:38:37 <lambdabot> id
22:38:41 <Cale> Olathe: yeah, but that only works for two parameters :)
22:39:04 <nornagon> g x `f` h y $ i z
22:39:04 <dmwit> It's sort of pointless to have some expressions where either ($) or (.) works and some where neither does.
22:39:21 <thoughtpolice> Philippa: yeah. still though, i see what Cale is saying about flipping its associativity.
22:40:21 <thoughtpolice> why do types associate to the right anyway? i realize the whole a -> b -> c -> d === a -> (b -> (c -> d)) i.e. 'all functions take one parameters' thing, but why?
22:40:21 <dmwit> nornagon: That doesn't really scale...
22:40:39 <nornagon> dmwit: but when do you need so many arguments? <.<
22:40:56 <Olathe> thoughtpolice: That's currying.
22:41:00 <mjrosenb> thoughtpolice: because currying is nice when it doesn't add extra parens
22:41:02 <Philippa> thoughtpolice: that /is/ why. It's more convenient that way
22:41:07 <shachaf> thoughtpolice: What does (((a -> b) -> c) -> d) mean?
22:41:23 <thoughtpolice> shachaf's answer wins.
22:41:34 <Olathe> Yay, shachaf !
22:41:49 <thoughtpolice> :)
22:44:24 <mjrosenb> shachaf: that looks like something that never returns
22:44:29 <slava> can i ask a parser combinators question here?
22:44:34 <Philippa> sure
22:44:44 <slava> i'm trying to parse a left-recursive grammar:
22:44:51 * wli is getting very close to GUI-capable again.
22:44:53 <slava> X ::== <any char>+
22:44:54 <thoughtpolice> in any case, it makes sense why when you just say 'currying' :)
22:45:01 <slava> Y ::== X | X "+" X
22:45:05 <slava> that's it
22:45:10 <slava> how do people do this with parser combinators?
22:45:20 <slava> wait
22:45:30 <slava> Y ::== X | Y "+" Y
22:45:32 <slava> that's what i meant.
22:45:47 <Philippa> do you want it left- or right-associative?
22:45:52 <slava> doesn't matter
22:45:55 <Olathe> X ::== <any char except '+'>+
22:46:00 <Philippa> it does matter that you pick one though
22:46:07 <shachaf> mjrosenb: Well, it depends on the a,b,c,d.
22:46:09 <slava> pick one for me
22:46:38 <Philippa> okay. You write a combinator (I'll use chainl from the literature) that parses an X and then looks for a "+" before recursing if it finds it
22:47:05 <mjrosenb> shachaf: something with that as the most restrictive type isn't going to be returning
22:47:08 <ddarius> @src chainl
22:47:08 <lambdabot> Source not found. My mind is going. I can feel it.
22:47:15 <Philippa> so I'd write the parser something like x `chainl1` y with Parsec
22:47:26 <mjrosenb> Philippa: what literature is there on parser combinators?
22:47:31 <Philippa> (the 1 makes it + rather than *)
22:47:38 <ddarius> @google Daan Leijin Parsec letter
22:47:39 <lambdabot> No Result Found.
22:48:06 <Philippa> I wouldn't suggest the parsec paper first anyway. The Hutton-Meijer paper's probably a better intro if you're happy covering monadic combinators
22:48:26 <Philippa> but you can find the Parsec paper on Daan's site and it's got plenty of references
22:48:31 <shachaf> mjrosenb: Sure, but neither is (a -> (b -> (c -> d))). :-)
22:48:50 <ddarius> Doh, Leijen
22:50:06 <Philippa> slava: basically, you pattern around it. Solution make sense?
22:50:24 <slava> i'm using a parser combinator library for another language. what does 'chainl1' do
22:50:49 <Philippa> it's the one I was talking about - it munches an X then looks for a + and recurses if there is one
22:51:20 <Philippa> and it builds up an appropriate chain of applications for a left-associative parsing
22:52:10 <slava> suppose you were writing a parser for a left-associative infix language
22:52:20 <slava> with parenthesis for grouping
22:52:41 <slava> you want arbtirary nesting, how do you eliminate left recursion here?
22:52:44 <Philippa> and presumably multiple precedence levels
22:53:45 <Philippa> precedence0 = precedence0 `chainl1` precedence1, etc etc, precedenceMin = lowPrecedenceThing <|> openParen; precedence0; closeParen
22:53:52 <Philippa> er, nearly
22:54:08 <Philippa> precedence0 = predence1 `chainl1` precedence0Op
22:54:12 <Philippa> sorry, it's silly am here
22:54:22 <Philippa> gah, typos. Did the idea make it across?
22:54:38 <Olathe> I are do agree sillily.
22:54:39 <Philippa> gah, min should be max too
22:54:53 <Philippa> Olathe: it's nearly 7am, which counts as silly if you've not slept yet
22:55:21 <Olathe> Sometimes, it counts as silly if you're dreaming, too.
22:55:45 <Olathe> So, I think it's just an inherent property of 7 am.
22:55:49 <Philippa> slava: the standard 4-op arithmetic parser in Parsec goes something like:
22:56:02 <Philippa> expression = term `chainl1` addop
22:56:12 <Philippa> term = factor `chainl1` mulop
22:56:34 <Philippa> factor = number <|> do char '('; e <- expression; char ')'
22:56:48 <Philippa> then fill in the blanks for addop, mulop and number. Oh, and you might want to return stuff
22:57:09 <Philippa> (that is, I missed a ; return e off the end of the parens case)
22:57:34 <Philippa> if you return the functions matching the operators in addop and mulop and return an integer in number you get a calculator
22:58:26 <mwc> how does one parse Haskell's dynamic precedences?
22:58:59 <mwc> I've assumed that they converted it to stack notation using a shunting yard algo that takes into account the current precedences
22:59:24 * wli is not familiar with the term "shunting yard algorithm."
22:59:36 <mwc> wikipedia has an article i
22:59:51 <mwc> it's just a way of converting infix to post|pre-fix notation
23:00:12 * wli will have to either get a window manager working on gentoo or blow away gentoo in favor of ubuntu.
23:00:31 <Philippa> mwc: strictly speaking, you don't because there's a nasty interaction between nested fixity declarations and the layout rule
23:00:46 <mwc> yeah, I could never figure that out actually
23:01:29 * wli would just go for multipass parsing.
23:01:29 <Philippa> that aside, you just have to know the predences in play at the time and build a parser appropriately. If necessary you can delay resolving precedence and just munch stuff on the basis that you'll catch anything that doesn't make sense with precedence in play later
23:02:13 <Philippa> internally you want a representation where it's all just application as soon as you're done parsing anyway
23:02:27 <Philippa> but there isn't really fixity at the abstract syntax level
23:03:02 <wli> AIUI there are delimiters between which fixity doesn't matter.
23:03:19 <wli> So you can leave everything between them unparsed until later.
23:04:09 <wli> I could be (very) wrong.
23:04:31 <Philippa> you can get conflicts which mean there's an outright parsing error still
23:04:48 <Philippa> but it's only valid or invalid unless you've got something daft (like the layout rule) in play
23:05:08 <wli> Layout's daft?
23:05:28 <Philippa> one of the cases in it has a side-condition "if there would otherwise be a parsing error at this point"
23:05:53 <Philippa> by putting fixity declarations in the right point in a series of nested binding groups you can create a paradox
23:05:58 <wli> Oh dear. Sounds like they're begging for CYK -type affairs.
23:06:09 <Philippa> "if it didn't parse right then this comes into scope but then it would've parsed right..."
23:06:38 <wli> Okay, that's even worse.
23:08:42 <wli> There should be a "right way" to go about layout but I've not looked at it hard.
23:11:30 <mwc> if you want another example, they added a layout mode to F#, which is very similar to ocaml
23:11:55 <slava> Philippa: i'm writing a regex parser using parser combinators, which constructs parser combinators at run time :)
23:12:05 <slava> well, my friend is writing it actually, i just helped him get started
23:12:13 <slava> thanks for helping us with the left recursion issue
23:12:14 <dons> sounds like some things the pugs guys were into
23:12:22 <slava> i've only used parser combinators for really simple stuff before
23:12:27 <slava> never ran into this issue
23:12:33 <allbery_b> someone suggested a "layout done right" on the list some time back
23:12:54 <wli> What was the conclusion of all that?
23:13:00 <allbery_b> it changes the layout rules, but the result is IIRC consistent and easier to parse
23:13:15 <allbery_b> dunno.  probably got referred to haskell' which doesn
23:13:23 <allbery_b> t seem to be doing very much
23:13:47 <wli> The purpose of Haskell' is not to absorb randomized cleanups.
23:14:30 <wli> Getting an implementation out the door and adopted would be a good first step to getting it into a successor of Haskell'
23:14:34 <allbery_b> if the result is to make haskell' parseable, it is
23:15:05 <allbery_b> (haskell98 having some well known problems in that area)
23:15:05 <wli> allbery_b: There needs to be an FAQ addressing these sorts of enhancements.
23:16:11 <oerjan> i understand haskell' is likely to remove the interaction of precedence with the rest of parsing
23:16:57 <Philippa> yeah, on the grounds that having decidable parsing is a good thing
23:17:34 <oerjan> Philippa: thanks for your explanation, i had suspected something like a paradox was possible but i hadn't seen it discussed
23:17:49 <Olathe> Decisions, decisions.
23:18:04 <Olathe> Too many decisions.
23:18:06 <Olathe> I quit.
23:18:54 <Philippa> sorear explained it to me in PM a while back
23:22:11 <newsham> you've got a unit sphere, its packed into the corner of a box whose corner is at the origin.  how big of a sphere can you squeeze into the corner between the sphere and the box?
23:22:35 <sorear> is the box cubic?
23:23:03 <newsham> cubic?
23:23:09 <sorear> l = w = h
23:23:16 <mwc> sorear, don't think it matters
23:23:37 <mwc> consider the x, y, and z normal planes containing the origin.
23:23:41 <newsham> box is infinite in the positive quadrant
23:23:53 <mwc> you have a unit spere with center (1,1,1)
23:24:06 <sorear> newsham: oh, I assumed you meant opposite corner
23:25:10 <oerjan> hm, will the centers of the spheres and the corner necessarily be on a line?
23:25:16 <sorear> 3 * (1-ssr)^2 = (1 + ssr)^2
23:26:01 <impresive> Á‰Â
23:26:23 <sorear> the small sphere has radius 2 - sqrt(3)
23:27:02 <sorear> ooc, where did this come up?
23:27:19 <newsham> sorear: same number I got (though I expressed it differently)
23:27:39 <newsham> its a puzzle i saw today
23:27:51 <oerjan> > (sqrt 3 - 1)/(sqrt 3 + 1)/(2 - sqrt(3))
23:27:52 <lambdabot>  1.0
23:28:19 <sorear> flash-o-geometric intuition told me the small sphere was tangent to the big sphere and all three basic planes
23:28:20 <newsham> (‚àö3 - 1)/(‚àö3 + 1)
23:28:26 <sorear> work out distance formula
23:28:44 <sorear> (%i7) solve(3 * (1-ssr)^2 - (1 + ssr)^2, ssr);
23:28:44 <sorear> (%o7) [ssr = 2-sqrt(3),ssr = sqrt(3)+2]
23:29:27 <sorear> note the second solution, the largest sphere which can touch the ball
23:29:52 <newsham> two spheres kiss along line through both radii and origin (diagonal line x=y=z)
23:30:05 * sorear hugs maxima
23:30:36 <newsham> r(sqrt3-1) = r'(sqrt3+1)
23:30:50 <newsham> r' = r(sqrt3-1)/(sqrt3+1)
23:30:57 <oerjan> my intuition is that the outermost point of the small sphere touches the innermost point of the large one, everything is similar and so just divide the inner point's distance from the origin by the outer point's
23:31:13 <oerjan> i guess that's what newsham is doing too
23:31:14 * wli just brute forces it with vectors.
23:31:41 <newsham> distance from origin to (r,r,r) = r*sqrt3
23:31:56 <newsham> distance from origin to sphere = r*sqrt3 - r
23:32:18 <newsham> dinstance from origin to outter edge of inner sphere = r*srqt3 - r = r'*srqt3 + r'
23:33:20 * wli notes an eigensolver in HSSL and makes a mental note to finish the quadric classifier he started on.
23:33:51 <newsham> should generalize to n dimensions    (sqrtn - 1)/(sqrtn + 1)
23:34:09 <newsham> since distance (0,0,..) to (r,r,...) is r*sqrt(n)
23:38:41 <newsham> > map (\n -> (sqrt(n)-1)/(sqrt(n)+1)) [1..20]
23:38:42 <lambdabot>  [0.0,0.1715728752538099,0.2679491924311227,0.3333333333333333,0.381966011250...
